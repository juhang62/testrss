<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>了不得，我可能发现了Jar 包冲突的秘密 - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/11028975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/11028975.html</guid>
<description>&lt;p&gt;这篇是类加载器相关的第三篇：&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/grey-wolf/p/10992671.html&quot;&gt;实战分析Tomcat的类加载器结构（使用Eclipse MAT验证）&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/grey-wolf/p/11017253.html&quot;&gt;还是Tomcat，关于类加载器的趣味实验&lt;/a&gt;&lt;/p&gt;
&lt;p class=&quot;postTitle&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;昨天下午刚写了篇 类加载器相关的，晚上想着验证个问题：Tomcat 跑了多个spring web项目，那么org.springframework.web.servlet.DispatcherServlet 这种类是怎么个情况呢？多个不同类加载器加载的，同时存在的同名类？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我是打算利用阿里开源的arthas工具来查看的，但是这个工具只支持 linux。说来也不怕让人笑话，公司的后端服务，开发环境、测试环境用的windows的，以后交付给客户不知道是用啥。先不说这个吧，反正我们打的war包，在windows服务器的tomcat 上没什么问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是当我把同样的war包丢到 linux 上时，发现报错了，没启动成功。。。。hahhah。。。尴尬。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;错误如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Caused by: &lt;span&gt;java.lang.NoSuchMethodError: javax.persistence.Table.indexes()&lt;/span&gt;[Ljavax/persistence/Index;
        at org.hibernate.cfg.annotations.EntityBinder.processComplementaryTableDefinitions(EntityBinder.java:936)
        at org.hibernate.cfg.AnnotationBinder.bindClass(AnnotationBinder.java:824)
        at org.hibernate.cfg.Configuration$MetadataSourceQueue.processAnnotatedClassesQueue(Configuration.java:3790)
        at org.hibernate.cfg.Configuration$MetadataSourceQueue.processMetadata(Configuration.java:3744)
        at org.hibernate.cfg.Configuration.secondPassCompile(Configuration.java:1410)
        at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1844)
        at org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1928)
        at org.springframework.orm.hibernate4.LocalSessionFactoryBuilder.buildSessionFactory(LocalSessionFactoryBuilder.java:372)
        at org.springframework.orm.hibernate4.LocalSessionFactoryBean.buildSessionFactory(LocalSessionFactoryBean.java:454)
        at org.springframework.orm.hibernate4.LocalSessionFactoryBean.afterPropertiesSet(LocalSessionFactoryBean.java:439)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1687)
        at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1624)
        ... 38 common frames omitted
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;大概意思是， javax.persistence.Table 的 indexes（）方法不存在。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;首先，我在idea 中搜了一把 “javax.persistence.Table”，搜到的结果是，hibernate-jpa-2.1-api-1.0.0.Final.jar 这里面有个同名的类，看了下，indexes（）方法是存在的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好吧，学了一阵子类加载器了，我觉得，首先还是看看，这个类是从哪加载的吧。 懒得去加 -XX:+TraceClassLoading参数了，直接 用阿里的神器，greys（用arthas也可以，arthas是基于greys搞的） 挂载上去，用下面的命令搜索了一下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
ga?&amp;gt;&lt;span&gt;sc -df&lt;/span&gt;&lt;span&gt;&lt;span&gt; javax.persistence.Table   &lt;/span&gt; 
&lt;/span&gt;+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                         class-&lt;span&gt;info&lt;/span&gt; | javax.persistence.Table                                                          |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                        code-source | &lt;span&gt;/home/upload/apache-tomcat-8.5.28/webapps/CAD-WebService/WEB-INF/lib/persistence-api |
|                                                    | -1.0.jar&lt;/span&gt;                                                                         |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                               name | javax.persistence.Table                                                          |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                        isInterface | &lt;span&gt;true&lt;/span&gt;                                                                             |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                       isAnnotation | &lt;span&gt;true&lt;/span&gt;                                                                             |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                             isEnum | &lt;span&gt;false&lt;/span&gt;                                                                            |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                   isAnonymousClass | &lt;span&gt;false&lt;/span&gt;                                                                            |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                            isArray | &lt;span&gt;false&lt;/span&gt;                                                                            |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                       isLocalClass | &lt;span&gt;false&lt;/span&gt;                                                                            |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                      isMemberClass | &lt;span&gt;false&lt;/span&gt;                                                                            |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                        isPrimitive | &lt;span&gt;false&lt;/span&gt;                                                                            |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                        isSynthetic | &lt;span&gt;false&lt;/span&gt;                                                                            |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                        simple-name | Table                                                                            |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                           modifier | abstract,interface,public                                                        |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                         annotation | java.lang.annotation.Target,java.lang.annotation.Retention                       |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                         interfaces | java.lang.annotation.Annotation                                                  |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                        super-class |                                                                                  |
+----------------------------------------------------+----------------------------------------------------------------------------------+
|                                       class-loader | &lt;span&gt;ParallelWebappClassLoader&lt;/span&gt;                                                        |
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;从上图看出来，javax.persistence.Table 这个类啊，是 webappclassloader 从 webapps/CAD-WebService/WEB-INF/lib/persistence-api -1.0.jar 加载的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是我打开 这个jar包看了下，里面确实有javax.persistence.Table ，这个类也确实没有indexes（）方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615211614751-840498677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 看来问题就在这里，是加载到了错误的jar包。 接下来的处理，就要结合业务代码，看看到底是从哪引入了这个包，这个包是否需要，不需要的话，直接排除掉即可。（可使用idea 插件 maven helper）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 如果只是 尽快解决问题，一般到这步就可以了。但我奇怪的是，windows上为啥没问题呢？？？（黑人问号）&lt;/p&gt;
&lt;p&gt; 后边在windows 的 tomcat 启动脚本加了 -XX:+TraceClassLoading，发现，该类是从hibernate 那个jar包加载的，所以没问题。（要让windows上输出类加载日志，要修改点东西。https://www.cnblogs.com/welcomer/p/5068340.html）&lt;/p&gt;


&lt;p&gt;我看了下代码，这个jar包，确实需要，不能排除掉。。。只是比较奇怪， 在linux上，为啥会优先加载了 persitance-api.jar，难道在windows没有先加载 persistence-api.jar？&lt;/p&gt;
&lt;p&gt;带着这些疑问，我恶向胆边生，直接dump了windows下和linux的堆内存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre readability=&quot;5&quot;&gt;
jmap -dump:live,format=b,&lt;span&gt;file&lt;/span&gt;=heap3.bin &lt;span readability=&quot;4&quot;&gt;123072  -----linux的&lt;p&gt;jmap -dump:live,format=b,file=heap-windows.bin 11640 --windows的 &lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;eclipse mat 一把打开 linux的堆dump后，用 oql 语句，查询了一下所有的 ParallelWebappClassLoader：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615212637250-962284419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;好，再看看 windows 的，操作和上面差不多，直接看结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615212836858-2067961786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201906/519126-20190615212908770-121306804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可见，windows上，是按字母序来的， hibernate那个包，妥妥地排在 persistence-api.jar 的前面。。。 这让人不得不吐槽下，这个顺序怎么搞的，linux上文件感觉跟乱序一样。。。&lt;/p&gt;

&lt;p&gt;由于 tomcat 8 才有localRepositories 这个字段，我这里没有可运行的源码，所以只能大概看看 spring-boot 内嵌的tomcat jar包的源码了，大概是这么个方法：&lt;/p&gt;
&lt;p&gt;org.apache.catalina.loader.WebappClassLoaderBase#start&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; start() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {

        state &lt;/span&gt;=&lt;span&gt; LifecycleState.STARTING_PREP;

        WebResource classes &lt;/span&gt;= resources.getResource(&quot;/WEB-INF/classes&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (classes.isDirectory() &amp;amp;&amp;amp;&lt;span&gt; classes.canRead()) {
            localRepositories.add(classes.getURL());
        }
&lt;span&gt;        WebResource[] jars &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= resources.listResources(&quot;/WEB-INF/lib&quot;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (WebResource jar : jars) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (jar.getName().endsWith(&quot;.jar&quot;) &amp;amp;&amp;amp; jar.isFile() &amp;amp;&amp;amp;&lt;span&gt; jar.canRead()) {
&lt;span&gt;                localRepositories.add(jar.getURL());
&lt;/span&gt;                jarModificationTimes.put(
                        jar.getName(), Long.valueOf(jar.getLastModified()));
            }
        }

        state &lt;/span&gt;=&lt;span&gt; LifecycleState.STARTED;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;上面标红处，就是 去 /WEB-INF/lib 下面获取所有的 jar 包，然后遍历，加入到localRepositories。 这里看来，去读文件系统后，没有根据文件名排序吧。。。而正好呢，windows下和linux 下返回的文件列表，顺序不同。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;综上，可以大概总结下，一般来说，不同操作系统返回的文件，顺序都是不太一致的，如果代码里，直接依赖了这种顺序，就会出现这类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试：小哥哥，你程序有bug。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你：不可能，我这好好的。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试：小哥哥，不骗你，你过来看嘛。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你：不看不看，烦不烦？？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;想到以前遇到的一个 spring 循环依赖的问题（linux上不行，windows上可以），应该也是这个原因。。。哎。。恼火&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 16 Jun 2019 00:35:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>一、前言 这篇是类加载器相关的第三篇： 实战分析Tomcat的类加载器结构（使用Eclipse MAT验证） 还是Tomcat，关于类加载器的趣味实验 昨天下午刚写了篇 类加载器相关的，晚上想着验证个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/11028975.html</dc:identifier>
</item>
<item>
<title>Go语言入门——函数 - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/go-function.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/go-function.html</guid>
<description>&lt;p&gt;写了快一个月的Go，已经没有什么陌生感了。&lt;/p&gt;

&lt;p&gt;一行代码写完，不会在行尾本能的敲上“；”，直接Enter键换行；&lt;/p&gt;
&lt;p&gt;定义变量把变量名放在前面，类型放在后面；&lt;/p&gt;
&lt;p&gt;使用struct去定义自己想要的数据模型就好比定义一个Java中的model一样……&lt;/p&gt;

&lt;p&gt;这些不用可以经过大脑加工思考，就想自己还在写Java一样。&lt;/p&gt;

&lt;p&gt;还记得当时在看《Go实战》的时候看到变量类型后置的声明方式，我还在极力吐槽这种不人性的语法，如果我已经站在了真香的队伍里，和其他的真香同学别无二致。&lt;/p&gt;
&lt;p&gt;感慨，人的适应能力真的强👍&lt;/p&gt;
&lt;p&gt;作为一个Java重度爱好者，其实在每次写Go的时候都会情不自禁的把两者进行对比，在写文章的时候也会经常提到。当然了，今天主要说的还是Go的函数。&lt;/p&gt;

&lt;h3 id=&quot;go&quot;&gt;&lt;span&gt;1、Go语言中的函数长啥样&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f(a int, b int) (ret int, err error) {
    fmt.Println(&quot;This is function&quot;)
    return
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;没错，这大概就是一个典型的Go风格的函数，那么它有哪些特色&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;入参&lt;/li&gt;
&lt;li&gt;返回值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;span&gt;2、入参&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;-1&quot;&gt;&lt;span&gt;2.1 参数合并声明&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;入参的变量也是变量后置的，这里a变量和b变量是相同类型的，所以也可以写成&lt;/p&gt;

&lt;p&gt;对于不同类型的参数需要分开定义。&lt;/p&gt;

&lt;h4 id=&quot;-2&quot;&gt;&lt;span&gt;2.2 不定参数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;除此以外，入参还支持不定参数&lt;/p&gt;
&lt;p&gt;比如可以这样定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f(args ...int) {
    for _, arg := range args {
        fmt.Println(arg)
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对不定参数的函数，我们可以这样调用&lt;/p&gt;
&lt;p&gt;f(1)&lt;/p&gt;
&lt;p&gt;f(1, 2)&lt;/p&gt;
&lt;p&gt;f(1, 2, 3)&lt;/p&gt;
&lt;p&gt;避免了我们在函数里定义一长串变量的情况。&lt;/p&gt;
&lt;p&gt;上面的不定参数是int类型的，那么是否支持多种类型混用的不定参数呢？&lt;/p&gt;
&lt;p&gt;是可以的，使用...interface{}这种形式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f(args ...interface{}) {
    for _, arg := range args {
        switch arg.(type) {
            case int:
                fmt.Println(&quot;It is int type&quot;)
            case string:
                fmt.Println(&quot;It is string type&quot;)
            case int64:
                fmt.Println(&quot;It is int64 type&quot;)
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意，这里的i.(T)形式不是强制转换或者隐式类型转换，这是类型断言，表示判定类型的。&lt;/p&gt;
&lt;p&gt;Go里面是没有隐式类型转换的，不仅没有，而且强制类型转换也很严格。&lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4 id=&quot;-3&quot;&gt;&lt;span&gt;3、返回值&lt;/span&gt;&lt;/h4&gt;
&lt;h4 id=&quot;-4&quot;&gt;&lt;span&gt;3.1 返回参数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;不同于Java，Go函数是可以支持多返回值的，比如这里返回了ret和err两个参数。&lt;/p&gt;
&lt;p&gt;返回值的定义方式也很灵活，可以写成&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f(a int, b int) (int, error) {
    fmt.Println(&quot;This is function&quot;)
    return
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果返回只有一个参数可以写成&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f(a int, b int) (ret int) {
    fmt.Println(&quot;This is function&quot;)
    return
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f(a int, b int) int {
    fmt.Println(&quot;This is function&quot;)
    return
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;_&quot;&gt;&lt;span&gt;3.2 “_”的用法&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;在前面的文章，我们也顺带提过，对于函数返回的值，有些我们不关心或者不需要的话，我们不能抹掉他的位置，但是可以使用&quot;_&quot;来表示这个参数的存在，只是不用而已，比如这样调用上面的函数是不行的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
ret := f(1, 2)       // 缺少err返回值
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样是OK的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
ret, _ := f(1, 2)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者这样&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
_, err := f(1, 2)    
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;error&quot;&gt;&lt;span&gt;3.3 error&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;error接口是Go标准库为了错误处理提供的接口。&lt;/p&gt;
&lt;p&gt;一般在业务代码中，我们会调用某个方法后，判定方法对应的值是否为nil判定方法是否被正常执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
if err != nil {
    // 没有正常执行
} else {
    // 正常执行
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;panicrecoverdefer&quot;&gt;&lt;span&gt;3.4 panic和recover和defer&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;说到error，正好说说panic()和recover()两个函数&lt;/p&gt;
&lt;p&gt;当我们遇到一些err的时候，我们可能就会直接抛出panic，这里的panic可以近似理解为Java里面的Exception，即抛出异常。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
if err != nil {
    panic(err)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦抛出panic，则程序将会终止，除非遇到一种情况，即有recover的存在。&lt;/p&gt;
&lt;p&gt;说到recover则不得不提defer&lt;/p&gt;
&lt;p&gt;defer是Go里面的新特性，有点类型Java里面的finally，承担回收资源或者解锁这类的收尾工作，但是比finally要灵活，Go函数的defer可以放在函数的任意位置，不管函数是否正常执行，在跳出函数前都会执行defer定义的函数。&lt;/p&gt;
&lt;p&gt;接着说recover，如果在函数抛出panic，只要在最后遇到recover也是可以恢复正常的，形式如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
defer func() {
    if ret := recover(); ret != nil {
        fmt.Println(&quot;Catch Runtime Error:)
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;-5&quot;&gt;&lt;span&gt;4、其他&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;func&quot;&gt;&lt;span&gt;4.1 说说func&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;每个函数都以func开始，来表明自己是一个函数。&lt;/p&gt;
&lt;p&gt;那么学过Java的肯定会问，没有像public、private这样的访问修饰符吗？&lt;/p&gt;
&lt;p&gt;没有，但是Go通过另外一种规则实现了访问范围即可见性。对于函数名使用大写字母开头，则表示可以被其他包使用，如果使用小写字母开头，则只能本包内使用。&lt;/p&gt;
&lt;p&gt;当然，这个规则，也适用于变量的声明。&lt;/p&gt;

&lt;h4 id=&quot;-6&quot;&gt;&lt;span&gt;4.2 匿名函数&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;和Java等其他语言一样，Go函数也有匿名函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func (a, b int, s string) int {
    ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以通过直接在后面赋值的方式直接执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func (a, b int, s string) int {
    ...
}(1, 2, &quot;test&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里主要从Go语言的函数构成包括关键字func，入参和返回值介绍Go函数的一些特性。当然了，Go函数还有很多灵活性就不再一一阐述了，有待你我在业务项目中慢慢实践体会了。&lt;/p&gt;

&lt;h3 id=&quot;-7&quot;&gt;&lt;span&gt;5、技术沙龙&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;今天去参加了一个技术沙龙，主题是数据存储与微服务架构实践方面的。&lt;/p&gt;
&lt;p&gt;这是自己第一次除了参加公司组织的各种会议以外，自己主动报名的线下技术沙龙。&lt;/p&gt;
&lt;p&gt;会上听到了阿里、百度的大佬分享关于过去的技术沉淀和对未来技术方向的展望，整体还是蛮有收获的。&lt;/p&gt;
&lt;p&gt;拓宽了自己的知识面，也加深了对一些框架或者工具的理解，比如ServiceMesh。之前对于ServiceMesh的理解仅限于阅读各种文章，自己的理解也比较有限，这次通过阿里大佬的解释，更加清晰的了解了ServiceMesh以及它的优势。&lt;/p&gt;
&lt;p&gt;最后晒一下在回答问题环节，主办方送的马克杯，好评&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201906/619240-20190615234404728-2134591643.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的&lt;strong&gt;“推荐”&lt;/strong&gt;将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;/p&gt;
&lt;pre&gt;
&lt;em&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/619240/201505/162205410643708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 15 Jun 2019 15:54:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>从Go语言的函数构成包括关键字func，入参和返回值介绍Go函数的一些特性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigdataZJ/p/go-function.html</dc:identifier>
</item>
<item>
<title>商务系统的构造思路（无源码！）+如何用jsp实现点击单选框内容显示在另一个jsp页面 - 编程变现</title>
<link>http://www.cnblogs.com/dyxi/p/11029365.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dyxi/p/11029365.html</guid>
<description>&lt;p&gt;敲码经验总结：&lt;/p&gt;
&lt;p&gt;之前犯了一个错误就是，没有从底层开始学起，有啥问题，就直接博客园找源码，去CSDN找源代码，看到代码就复制粘贴，结果从新梳理知识点的时候，貌似除了复制粘贴，印象深刻的知识啥也没学到。&lt;/p&gt;
&lt;p&gt;看来代码这些东西还是得多敲多总结才有效，不要害怕从底层开始学起，因为没有底层的知识作为支撑，即使你能做出效果也不知道如何做出来，万不可知其然而不知其所以然。&lt;/p&gt;

&lt;p&gt;好了，敲码经验总结结束了，现在到了知识点回顾：&lt;/p&gt;
&lt;p&gt;总纲分成两个部分：&lt;/p&gt;
&lt;p&gt;一、总体商务平台的构思&lt;/p&gt;
&lt;p&gt;二、实现JSP点击单选按钮，内容显示到JSP里&lt;/p&gt;

&lt;p&gt;细节：&lt;/p&gt;
&lt;p&gt;总体商务平台的构架需要一个框架，比如说MVC，M指的是Model模型，V指的是Vison视图，C指的是Cotrol&lt;/p&gt;
&lt;p&gt;三个层次各司其职，他们的结构呈现上中下，&lt;/p&gt;
&lt;p&gt;最顶层是Vison。主要功能是显示用户输入的数据和呈现用户需要的数据&lt;/p&gt;
&lt;p&gt;中间层是Model。主要功能是传递作用，当用户输入数据后，它便接受数据传递给Model，让他寻找相应的数据处理 方式&lt;/p&gt;
&lt;p&gt;最底层是Model。主要功能是处理用户的数据，其中有个模型称为数据模型，它和数据库有着千丝万缕的联系&lt;/p&gt;
&lt;p&gt;三者之间你可以近似看成是顾客，中间商，供应商的关系，顾客有需求，中间商接受顾客需求告知供应商，供应商寻找用户需要的产品给中间商，中间商再呈现给顾客，满足顾客的需要。&lt;/p&gt;

&lt;p&gt;重点：MVC只是个复杂的系统，并不是拿手就可用的框架&lt;/p&gt;
&lt;p&gt;但MVC系统有多个小弟，其中有个小弟特别突出，他就是SSH，SSH是能力极强的框架，我要介绍的商务系统就是建立在它的基础上&lt;/p&gt;

&lt;p&gt;SSH，S指的是Struts，S指的是Spring，H指的是Hibernate&lt;/p&gt;
&lt;p&gt;他们继承了老大的思维模式，三个层次也是各司其职，他们的结构也是呈现上中下&lt;/p&gt;
&lt;p&gt;最顶层是Struts。主要功能是提交数据，通过Action处理，从forward到对应的网页。采用的技术是Servlet、JSP&lt;/p&gt;
&lt;p&gt;中间层是Spring。主要的功能是提供管理业务对象的调用接口。【Spring也称为Service、Manager】&lt;/p&gt;
&lt;p&gt;底层是Hibernate。主要的功能是与数据库打交道&lt;/p&gt;

&lt;p&gt;因此&lt;/p&gt;
&lt;p&gt;在我的商务系统的SSH的构造是【从后到前顺序】：&lt;/p&gt;
&lt;p&gt;实体层（数据库的数据）&lt;/p&gt;
&lt;p&gt;Dao层（服务方法的接口）&lt;/p&gt;
&lt;p&gt;服务层（调用Dao层实现各种服务方法的编写）&lt;/p&gt;
&lt;p&gt;Web层（编写Action和form【主要是对数据进行必要的验证和转换】、JSP页面对业务数据的操作）&lt;/p&gt;
&lt;p&gt;对应SSH的框架就是&lt;/p&gt;
&lt;p&gt;Hibernate：负责实体层&lt;/p&gt;
&lt;p&gt;Spring：负责Dao层和服务层&lt;/p&gt;
&lt;p&gt;Struts：负责Web层&lt;/p&gt;

&lt;p&gt;按照这样思路：&lt;/p&gt;
&lt;p&gt;对象的调用流程就是：JSP页面--&amp;gt;通过Acrion等方法--&amp;gt;反映到Service--&amp;gt;寻找相应的DAO接口--&amp;gt;到Hibernate寻找&lt;/p&gt;
&lt;p&gt;数据的流向：ActionFormBean接受用户数据--&amp;gt;Action将数据从中提取出来--&amp;gt;封装成VO或PO--&amp;gt;调用业务层的Bean类，接受这个PO对象，调用DAO接口方法--&amp;gt;到实体层进行持久化操作&lt;/p&gt;

&lt;p&gt;这就是我的商务平台的构建思路，当然这只是万里长征的第一步，源码什么的还没摆出来，不过我会争取持久更新的（毕竟有时候搞一个方法就花去我一天或者以上），但是路漫漫其修远兮，吾将上下而求索！&lt;/p&gt;

&lt;p&gt;二、实现JSP点击单选按钮，内容显示到JSP上&lt;/p&gt;
&lt;p&gt;效果图先摆上：&lt;/p&gt;
&lt;p&gt;【选择前：】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1696579/201906/1696579-20190615231823622-430734272.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【选择后：】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1696579/201906/1696579-20190615231902133-1103042950.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有两个JSP源码，&lt;/p&gt;
&lt;p&gt;以下是单选前的源码（select.jsp）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;head&amp;gt;
&lt;span&gt; 4&lt;/span&gt;     &amp;lt;title&amp;gt;选择&amp;lt;/title&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &amp;lt;/head&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;选择自己的城市信息
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &amp;lt;form action=&quot;selec_result.jsp&quot; method=&quot;post&quot;&amp;gt;&amp;lt;!--开始跳转新的jsp--&amp;gt;
&lt;span&gt;10&lt;/span&gt;     选择你所在的城市&amp;lt;select name=&quot;home&quot;&amp;gt;&amp;lt;!--相当于引用变量--&amp;gt;
&lt;span&gt;11&lt;/span&gt;     &amp;lt;option value=&quot;beijing&quot;&amp;gt;北京&amp;lt;/option&amp;gt;&amp;lt;!--value后面是显示的值，再后面的是界面选择项--&amp;gt;
&lt;span&gt;12&lt;/span&gt;     &amp;lt;option value=&quot;shanghai&quot;&amp;gt;上海&amp;lt;/option&amp;gt;
&lt;span&gt;13&lt;/span&gt;     &amp;lt;option value=&quot;guangzhou&quot;&amp;gt;广州&amp;lt;/option&amp;gt;
&lt;span&gt;14&lt;/span&gt; &amp;lt;/select&amp;gt;
&lt;span&gt;15&lt;/span&gt;     &amp;lt;input type=&quot;submit&quot; value=&quot;提交&quot;&amp;gt;&amp;lt;!--type是提交操作，value是按钮名字--&amp;gt;
&lt;span&gt;16&lt;/span&gt; &amp;lt;/form&amp;gt;
&lt;span&gt;17&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt;18&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以下是单选后的源码（selec_result.jsp）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &amp;lt;%@ page import=&quot;java.io.PrintWriter&quot; %&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &amp;lt;html&amp;gt;
&lt;span&gt; 4&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt; 5&lt;/span&gt; &amp;lt;%
&lt;span&gt; 6&lt;/span&gt;     String home=request.getParameter(&quot;home&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     PrintWriter out1=&lt;span&gt;response.getWriter();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     out1.print(&quot;你所在的城市是：&quot;+&lt;span&gt;home);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; %&amp;gt;
&lt;span&gt;10&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt;11&lt;/span&gt; &amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;源码已经有了，我就讲讲在其中要注意什么，有两点：&lt;/p&gt;
&lt;p&gt;一、要导入servlet-api.jar包，只有导入才能响应respone的操作，【在下载的Tomcat的lib文件里可以找到，要是懒得找，笔者这里有链接：https://pan.baidu.com/s/16C1GF9cPvo08MC3rxPGmSw；提取码：q4tq；笔者使用的是Tomcat 8.5】&lt;/p&gt;
&lt;p&gt;二、每次修改其中jsp源码，需要将端口重新启动才能显示最新修改的信息【这是缺点，目前笔者没有找到解决方案】&lt;/p&gt;

&lt;p&gt;今天的分享到这里结束了，希望对你有帮助。&lt;/p&gt;
</description>
<pubDate>Sat, 15 Jun 2019 15:52:00 +0000</pubDate>
<dc:creator>编程&amp;lt;--&amp;gt;变现</dc:creator>
<og:description>主要讲解商务系统的构造思路（无源码！），和如何用jsp实现点击单选框内容显示在另一个jsp页面中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dyxi/p/11029365.html</dc:identifier>
</item>
<item>
<title>马上要到30岁，你也被催婚了吗 - Refain</title>
<link>http://www.cnblogs.com/longronglang/p/11029355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longronglang/p/11029355.html</guid>
<description>
&lt;p&gt;如果年近30岁，对于每个单身的男、女同学来说，都是个极其具有压力的事情。&lt;/p&gt;

&lt;p&gt;简单来说，有两方面：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;家庭方面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先父母层面最大，每天要面对父母的“嘴遁”，这时候不想说话。其次就是邻居小区方面、亲戚逢年过节时候，亲戚的“特别关心”，会觉得他们好多管闲事。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自身方面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每每看到朋友圈晒结婚照，心里总会有种说不出的羡慕和感叹。高兴自然是因为真心祝福，感叹是因为自己何时能遇见幸福，也可以享受属于自己的那份“久长时”和“朝朝幕幕”，内心是无比的羡慕和憧憬。再有一个重要的原因就是自己不想将就，总觉得会有那么一个“理想的他/她”在等待你。&lt;/p&gt;

&lt;p&gt;于是就有了相亲，从古到今最为流行的方式，认识未来的另一半的途径。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;出现矛盾，不是相互指责，而是能够一起面对&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;和很多人一样，在大学时，都有一段刻骨铭心的爱情，但也有着类似的结局，那就是毕业就分手。&lt;/p&gt;

&lt;p&gt;大学读的是机械专业，毕业去某机构培训了三个月，和很多年轻人一样，带着自己的梦想投身于北京。我可能是感情方面比其他人差了好多吧，每天的生活和上了发条一样，更多时间把精力放在工作和学习中，状态好的时候，5天利用坐地铁时间可以看完一本书，也会因为写代码兴奋到两天不睡觉，不知道饿、困。&lt;/p&gt;

&lt;p&gt;就这样一个看似很励志的状态，在北京快满5年的时候，和一个校友突然联系上了，莫名其妙的相互喜欢，和她相处近半年吧。&lt;/p&gt;

&lt;p&gt;由于异地的关系，也总有矛盾，因为见面的机会太少，而且即使见面待在一起的时间太少，我总穿梭于老家和北京两座城市，那时感觉和喜欢的人多呆一会都感觉好奢侈。&lt;/p&gt;

&lt;p&gt;当时，我做了人生中第一次重大选择，&lt;strong&gt;我想回老家上班，我想见她！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当时内心十分复杂，要面临的现实问题有：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;能接受回老家薪资比北京低的现实吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;老家的软件公司多吗，我会不会失业？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我和她会有结果吗？这无疑是一次赌注，这一切都值得吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;书上说，每个情侣适不适合在一起，出去旅行一次就知道了。回到老家后，我没有着急去找工作，而是带着她出去旅游了。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201906/718867-20190616084418563-1801542381.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一起出去的第一天玩的过程中，发现很多问题渐渐暴露，遇到问题只会指责，但作为男孩来说，&lt;strong&gt;路痴确实是致命的硬伤&lt;/strong&gt;，我傻傻的站在原地，任凭她说，什么都没说。默默拿着手机给当地的朋友打电话，在朋友的帮忙下，找到了景点的位置。&lt;/p&gt;

&lt;p&gt;接下的事就不一一列举，&lt;strong&gt;出现问题的时候，我不需要你的指责，更希望你能理解我，和我一起面对问题，而不是你的指责和嘲讽！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原定旅行一周的行程，第三天早上就全部取消，我和她说了分手的事。虽然她哭的很伤心，但是我也很清楚她并不是想和我一起能走到最后的人，把她安顿在我同学那后，一个人坐着高铁回到了老家，一路上在想，为了一个人，放弃了自己的事业，值得吗？&lt;strong&gt;答案，很清晰，只因为喜欢。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;三观一致很重要吗&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;“三观”指的是双方各自的人生观、价值观和世界观。&lt;/p&gt;

&lt;p&gt;什么是真正的三观不合？&lt;/p&gt;

&lt;p&gt;在知乎上看过一段解释，深以为然。&lt;/p&gt;
&lt;p&gt;你喜欢看书，他喜欢玩游戏。这不叫三观不合。你喜欢看书，他说看书有什么用，不就是装文艺嘛。这才是三观不合。你喜欢去西餐厅吃牛排，他喜欢在大排档撸串。这不叫三观不合。但是他说那玩意死贵，还不好吃，说你真是做作。这就是三观不合。你喜欢假期去各地旅游，他就喜欢宅在家里。这不是三观不合。但是他说旅游有什么好玩的，不就是花钱遭罪嘛，躺在家里多舒服。&lt;/p&gt;

&lt;p&gt;这就是典型三观不合。&lt;/p&gt;

&lt;p&gt;简单点来说，不能接受并尊重对方一些行为和习惯。&lt;/p&gt;

&lt;p&gt;之前在网上看到一个段子说：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201906/718867-20190616084204210-168986191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;虽然算是撒了一波狗粮，但是脑补下这个画面还是觉得很温馨、浪漫。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201906/718867-20190616084233479-2053306026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;虽然两人三观不同，生活习惯也不同，却并不影响交往和接触。&lt;/p&gt;

&lt;p&gt;都说三观一致很重要，其实可以这么理解，就是和另一个人在一起呆着很舒服，更是为一种陪伴吧。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最好的关系，可以是我在床前安静的看书，你在手机上忘我的五杀，我不会鄙视你的游戏，你也偶尔会来看看我最近在看什么书。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;你从来都不会主动找我&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在相亲不比以前了，而是两人先加微信聊天，然后自己去了解。&lt;/p&gt;

&lt;p&gt;个人感觉微信形式相亲，从某种角度看，好像在剥夺着我们的“幸福”，为什么这样说。我相信很多朋友都遇到过类似的情况：&lt;/p&gt;




&lt;p&gt;当你发送的微信一直没有回复，那一刻是多么的悲伤和无奈，对方会如此忙碌，甚至微信也无法回复！&lt;/p&gt;

&lt;p&gt;事实上，那些经常以没看见为借口的人只是假装没看见，我们甚至去厕所都会看电话，怎么可能很久没看见！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;都不沟通，试问怎么知道是否合适呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事实上，我最想说的借口是假的，没感觉是真的，所以要找那些愿意花时间陪你的人，真爱应该是浪费彼此的时间一起聊天和大笑，过着无聊的生活，憧憬浪漫的未来！&lt;/p&gt;

&lt;p&gt;如果彼此都有感觉，那就多些聊天互动，互动多了，就自然而言的可以出来约会了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;关于相亲的一些看法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;现在的相亲对象，并不着急结婚，享受相处的过程，一提结婚，就吵架，这是种什么样的想法呢？&lt;/p&gt;

&lt;p&gt;先聊微信能聊出来啥，不如先见，没眼缘也不加微信，要不删了还麻烦。&lt;/p&gt;

&lt;p&gt;接触过程中，都不想付出，甚至连话都不想说，总会说我觉得我们没有什么话题，或者我们不合适告终。&lt;/p&gt;

&lt;p&gt;说好接触，可是，当你发出去微信后，这个信息就出去了，然后就没然后了，连话都不说，怎么接触熟悉，最后也是以我们不合适告终。&lt;/p&gt;

&lt;p&gt;现在的相亲，不单单是必须有车子、房子、你有多少存款了，重要的一点是你必须得有点颜值，更有甚者附加父母必须有劳保，是否无病。&lt;/p&gt;

&lt;p&gt;都说你若主动，我们就有故事了，都不主动，或者只等对方主动，恋爱是两个人的事，一个人那便是自作多情了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201906/718867-20190616084305522-281644652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;璎珞说：“自然，我付出三分，得让他见五分。付出五分，得让他还十分。只有这样才是公平公正，若一直背地付出，根本没人懂得珍惜。”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果不愿意就早早说，何必耗着地方，让等待的一方提出不合适之类的话，这样真的很折磨人心，时间宝贵，毕竟大家都挺忙的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;都说在爱情里最棒的状态是相爱的时候，我付出的一切都是心甘情愿。你若投桃报李，我必心生欢喜。直到有一天，我不愿再这般爱你，那就让我们，一别两宽，各生欢喜。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;爱情，是需要你主动，不主动，哪里会有故事发生！&lt;/p&gt;

</description>
<pubDate>Sat, 15 Jun 2019 15:48:00 +0000</pubDate>
<dc:creator>Refain</dc:creator>
<og:description>如果年近30岁，对于每个单身的男、女同学来说，都是个极其具有压力的事情。 简单来说，有两方面： 家庭方面 首先父母层面最大，每天要面对父母的“嘴遁”，这时候不想说话。其次就是邻居小区方面、亲戚逢年过节</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/longronglang/p/11029355.html</dc:identifier>
</item>
<item>
<title>从提升树到 XGBoost, 原理简介 - resolvent</title>
<link>http://www.cnblogs.com/shiina922/p/11029340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shiina922/p/11029340.html</guid>
<description>&lt;h2 id=&quot;提升树-boosting-trees&quot;&gt;提升树 (Boosting Trees)&lt;/h2&gt;
&lt;p&gt;提升树是以分类树或回归树为基本分类器的提升方法, 模型表示为决策树的加法模型:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_M(x) = \sum_{m=0}^M f(x;\Theta_m), \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt; 为树的个数, &lt;span class=&quot;math inline&quot;&gt;\(f(x;\Theta_m)\)&lt;/span&gt; 表示决策树, &lt;span class=&quot;math inline&quot;&gt;\(\Theta_m\)&lt;/span&gt; 为其参数.&lt;/p&gt;
&lt;h3 id=&quot;提升树算法&quot;&gt;1. 提升树算法&lt;/h3&gt;
&lt;p&gt;提升树算法采用向前分步 (forward stagewise) 算法 (本质上是一种贪心算法). 对于训练数据集 &lt;span class=&quot;math inline&quot;&gt;\(D = \{(x_i, y_i) \}_{i=1}^N​\)&lt;/span&gt;, 首先确定初始提升树 &lt;span class=&quot;math inline&quot;&gt;\(F_0(x)=0​\)&lt;/span&gt;, 然后第 &lt;span class=&quot;math inline&quot;&gt;\(m​\)&lt;/span&gt; 步的模型是&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_m(x) = F_{m-1}(x) + f(x;\Theta_m), \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(F_{m-1}\)&lt;/span&gt; 为当前模型, 通过经验风险最小化确定下一颗决策树的参数,&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \hat\Theta_m = \operatorname*{argmin}_{\Theta_m}\sum_{i=1}^N l(y_i, F_{m-1}(x_i) + f(x_i;\Theta_m)), \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 为损失函数.&lt;/p&gt;
&lt;p&gt;回归问题的提升树可以表示为简单函数&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ f(x;\Theta) = \sum_{j=1}^T c_j 1_{R_j}(x), \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(R_j\)&lt;/span&gt; 互不相交, &lt;span class=&quot;math inline&quot;&gt;\(1_{R_j}(x)\)&lt;/span&gt; 为示性函数, &lt;span class=&quot;math inline&quot;&gt;\(c_j\)&lt;/span&gt; 为常数, 参数 &lt;span class=&quot;math inline&quot;&gt;\(\Theta=\{(R_j,c_j)\}_{j=1}^T\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 为叶节点个数.&lt;/p&gt;
&lt;p&gt;综上,&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;回归问题的提升树算法&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化 &lt;span class=&quot;math inline&quot;&gt;\(F_0(x) = 0\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;对 &lt;span class=&quot;math inline&quot;&gt;\(m = 1,\dots,M\)&lt;/span&gt;: (a) 通过经验风险最小化学习一个回归树 &lt;span class=&quot;math inline&quot;&gt;\(f(x;\Theta_m)\)&lt;/span&gt;. (b) 更新 &lt;span class=&quot;math inline&quot;&gt;\(F_m(x) = F_{m-1}(x) + f(x;\Theta_m)\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;输出回归问题提升树 &lt;span class=&quot;math inline&quot;&gt;\(F_M(x) = \sum_{m=1}^M f(x;\Theta_m)\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;梯度提升树-gradient-boosting-decision-trees&quot;&gt;2. 梯度提升树 (Gradient Boosting Decision Trees)&lt;/h3&gt;
&lt;p&gt;对于一般的损失函数, 每一步经验风险最小化都不容易. GBDT 是为了便于计算而提出的方法, 它的主要想法来自于梯度下降法.&lt;/p&gt;
&lt;p&gt;记损失函数的梯度在当前模型的值为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ g_{im} = \left(\frac{\partial l(y_i,F(x_i))}{\partial F(x_i)}\right)_{F = F_{m-1}}. \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则由梯度下降法,&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ F_m(x_i) = F_{m-1}(x_i) -\rho_m g_{im}, \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中步长 &lt;span class=&quot;math inline&quot;&gt;\(\rho_m\)&lt;/span&gt; 可以通过线搜索获得, 即&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \rho_m = \operatorname*{argmin}_{\rho} \sum_{i=1}^Nl(y_i, F_{m-1}(x_i)-\rho g_{im}). \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;梯度下降法是一个很贪心的算法, 即在当前点取函数下降最快的方向. 但如上这样做的话我们只获得了在训练数据点上的预测, 为了得到可以预测新数据的决策树, 一种可行的做法是, 用 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 逼近负梯度方向, ESL [2] p. 321 使用了平方误差来度量 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 与负梯度的距离, 即&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \tilde\Theta_m = \operatorname*{argmin}_{\Theta}\sum_{i=1}^N (-g_{im} - f(x_i;\Theta))^2. \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意到对于 &lt;span class=&quot;math inline&quot;&gt;\(l(x,y) = \frac12(x-y)^2\)&lt;/span&gt; 的情形, &lt;span class=&quot;math inline&quot;&gt;\(\tilde\Theta_m\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(\hat\Theta_m\)&lt;/span&gt; 相等.&lt;/p&gt;
&lt;p&gt;其余操作同提升树算法, 从略.&lt;/p&gt;
&lt;h3 id=&quot;xgboost&quot;&gt;3. XGBoost&lt;/h3&gt;
&lt;h4 id=&quot;总体框架&quot;&gt;3.1. 总体框架&lt;/h4&gt;
&lt;p&gt;XGBoost 的主要想法是, 除了原有的损失函数, 在目标函数中加入正则项, 利用二阶 Taylor 近似代替目标函数再求极值 (回忆之前的梯度提升树只用了一阶导数), 其余操作同提升树算法.&lt;/p&gt;
&lt;p&gt;记 &lt;span class=&quot;math inline&quot;&gt;\(F_m(x_i) = \hat y_i^{(m)}\)&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\hat y_i^{(0)}=0\)&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\hat y_i^{(m)} = \hat y_i^{(m-1)} + f_m(x_i)\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(m=1,\dots,M\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(f_m\)&lt;/span&gt; 表示第 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 轮时所得的树, 是由最小化目标函数而得; &lt;span class=&quot;math inline&quot;&gt;\(\hat y_i^{(m)}\)&lt;/span&gt; 表示第 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 轮时 &lt;span class=&quot;math inline&quot;&gt;\(y_i\)&lt;/span&gt; 的预测值.&lt;/p&gt;
&lt;p&gt;第 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 轮目标函数为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \mathrm{Obj}^{(m)} = \sum_{i=1}^N l\left(y_i, \hat y_i^{(m-1)} + f_m(x_i)\right) + \Omega(f_m), \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt; 为损失函数; &lt;span class=&quot;math inline&quot;&gt;\(\Omega\)&lt;/span&gt; 为正则项, 是人为定义的复杂度, 可以降低模型复杂度, 减小过拟合的风险, 在原论文 [3] 中定义为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \Omega(f) = \gamma T + \frac12 \lambda\sum_{j=1}^T w_j^2, \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt; 为参数, &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt; 为 &lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt; 表示的数的叶节点数, &lt;span class=&quot;math inline&quot;&gt;\(w_j\)&lt;/span&gt; 为第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个叶节点的预测值 (权重).&lt;/p&gt;
&lt;p&gt;除了加入正则项外, 还可以通过 shrinkage 来降低过拟合风险, 即 &lt;span class=&quot;math inline&quot;&gt;\(F_m = F_{m-1} + \nu f_m\)&lt;/span&gt;, 其中 &lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;\nu&amp;lt;1\)&lt;/span&gt;, 可以看为学习率, 原来的做法相当于取 &lt;span class=&quot;math inline&quot;&gt;\(\nu=1\)&lt;/span&gt;. 这么做主要的理由是减少每颗树对总模型的影响, 防止前几颗树拟合地太好 (过拟合) 以至于后面的树没有了学习空间.&lt;/p&gt;
&lt;h4 id=&quot;寻找分裂点&quot;&gt;3.2. 寻找分裂点&lt;/h4&gt;
&lt;p&gt;对目标函数做二阶 Taylor 展开, 略去更高阶的无穷小量. 记&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ g_i = \frac{\partial l(y_i, \hat y_i^{(m-1)})}{\partial{\hat y^{(m-1)}}},\quad h_i = \frac{\partial^2 l(y_i, \hat y_i^{(m-1)})}{\partial{\left(\hat y^{(m-1)}\right)^2}}. \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如对于平方损失函数 &lt;span class=&quot;math inline&quot;&gt;\((y_i - \hat y_i^{(m-1)})^2\)&lt;/span&gt; 来说, &lt;span class=&quot;math inline&quot;&gt;\(g_i = 2(\hat y_i^{(m-1)} - y_i)\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(h_i = 2\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;经过简单的推导可得最优权重为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ w_j^* = -\frac{\sum_{i\in I_j}g_i}{\sum_{i\in I_j} h_i + \lambda}, \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(I_j\)&lt;/span&gt; 表示被归到第 &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; 个叶节点的全体实例 (的脚标) 集合.&lt;/p&gt;
&lt;p&gt;一般而言, 穷举所有可能的树结构是不可能的, 作为代替, 我们考虑贪心算法. 从一个叶节点开始二分, 假设 &lt;span class=&quot;math inline&quot;&gt;\(I_L\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(I_R\)&lt;/span&gt; 分别表示分裂后归为左节点和右节点的实例集合, 记 &lt;span class=&quot;math inline&quot;&gt;\(I = I_L \cup I_R\)&lt;/span&gt;, 则易得分裂后的目标函数减少值 (loss reduction) 为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac12\left[\frac{(\sum_{i\in I_L}g_i)^2}{\sum_{i\in I_L} h_i + \lambda} + \frac{(\sum_{i\in I_R}g_i)^2}{\sum_{i\in I_R} h_i + \lambda} - \frac{(\sum_{i\in I}g_i)^2}{\sum_{i\in I} h_i + \lambda}\right] - \gamma \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;把上式第一项视为 gain, 则 &lt;span class=&quot;math inline&quot;&gt;\(\gamma\)&lt;/span&gt; 相当于设置了分裂所需的最小的 gain, 起到了剪枝的作用.&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;寻找分裂点的精确贪心算法 (原文 [3] 中本段有一些 typo)&lt;br/&gt;输入: &lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt;, 当前节点的实例集; &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;, 特征维数 (个数).&lt;br/&gt;初始化 &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{gain} \leftarrow 0\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(G \leftarrow \sum_{i\in I}g_i\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(H \leftarrow \sum_{i\in I}h_i\)&lt;/span&gt;&lt;br/&gt;for &lt;span class=&quot;math inline&quot;&gt;\(k=1\)&lt;/span&gt; to &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt; do&lt;br/&gt;     &lt;span class=&quot;math inline&quot;&gt;\(G_L \leftarrow 0\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(H_L \leftarrow 0\)&lt;/span&gt;&lt;br/&gt;     for &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; in sorted (&lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt;, by &lt;span class=&quot;math inline&quot;&gt;\(x_{jk}\)&lt;/span&gt;) do&lt;br/&gt;         &lt;span class=&quot;math inline&quot;&gt;\(G_L\leftarrow G_L + g_j\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(H_L\leftarrow H_L + h_j\)&lt;/span&gt;&lt;br/&gt;         &lt;span class=&quot;math inline&quot;&gt;\(G_R \leftarrow G-G_L\)&lt;/span&gt;, &lt;span class=&quot;math inline&quot;&gt;\(H_R \leftarrow H- H_L\)&lt;/span&gt;&lt;br/&gt;         &lt;span class=&quot;math inline&quot;&gt;\(\mathrm{gain} \leftarrow \max(\mathrm{gain}, \frac{G_L^2}{H_L + \lambda} + \frac{G_R^2}{H_R + \lambda} - \frac{G^2}{H + \lambda})\)&lt;/span&gt;&lt;br/&gt;输出: 最大 gain 的分裂&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;精确贪心法是在所有特征上, 对所有可能的分裂点都进行遍历, 在数据量大的时候是不现实的. 一个简单的近似方法是, 排序后 (for &lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt; in sorted (&lt;span class=&quot;math inline&quot;&gt;\(I\)&lt;/span&gt;, by &lt;span class=&quot;math inline&quot;&gt;\(x_{jk}\)&lt;/span&gt;) 那步), 取适当的分位数作为分裂候选点进行贪心算法.&lt;/p&gt;
&lt;h4 id=&quot;稀疏数据的分裂点寻找-sparsity-aware&quot;&gt;3.3. 稀疏数据的分裂点寻找 (sparsity-aware)&lt;/h4&gt;
&lt;p&gt;主要分为两种情况:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若数据有缺失值, 则把缺失值都归到同一个节点. 这是处理缺失值的常用方法之一 (另一种常用方法是用适当的方法填补缺失值), 这使得 XGB 可以直接训练和预测带有缺失值的数据.&lt;/li&gt;
&lt;li&gt;若数据稀疏 (比如 one-hot 编码, 使得数据包含大量的 0), 则把 0 当做缺失值处理. 这个做法的关键点在于遍历时只对非缺失 (非零) 数据遍历, 在稀疏数据的情况下会大大提高训练速率.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注: 按照原论文 [3] 的说法, 作者似乎把缺失和稀疏时的 0 都统称为 &quot;稀疏/缺失&quot;, 用同样的方式处理, [5] 也证实了这一点.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6127196-6d65d0c25f3853d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 应该为 &lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;, score 应该为 gain.&lt;/p&gt;
&lt;h4 id=&quot;xgb-的优点&quot;&gt;3.4. XGB 的优点&lt;/h4&gt;
&lt;p&gt;XGB 把决策树的许多启发式的想法通过最小化目标函数统一起来处理. 除了使用近似算法, 在系统设计上, 通过并行处理, 优化缓存等工程层面上的优化大幅提高了运行速度, 减小了内存使用.&lt;/p&gt;
&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;[1] 李航. (2012). 统计学习方法 (pp. 55-74, 137-153). 北京: 清华大学出版社.&lt;br/&gt;[2] Friedman, J., Hastie, T., &amp;amp; Tibshirani, R. (2001). &lt;em&gt;The elements of statistical learning&lt;/em&gt; (pp. 299-344). New York: Springer series in statistics.&lt;br/&gt;[3] Chen, T., &amp;amp; Guestrin, C. (2016). Xgboost: A scalable tree boosting system. &lt;em&gt;Proceedings of the 22nd acm sigkdd international conference on knowledge discovery and data mining&lt;/em&gt; (pp. 785-794). ACM.&lt;br/&gt;[4] Introduction to Boosted Trees. (n.d.). Retrieved from &lt;a href=&quot;https://xgboost.readthedocs.io/en/latest/tutorials/model.html#&quot; class=&quot;uri&quot;&gt;https://xgboost.readthedocs.io/en/latest/tutorials/model.html#&lt;/a&gt;&lt;br/&gt;[5] Kodi Arfer. XGBoost, missing values, and sparsity. (2018). Retrieved from &lt;a href=&quot;http://arfer.net/w/xgboost-sparsity&quot; class=&quot;uri&quot;&gt;http://arfer.net/w/xgboost-sparsity&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Jun 2019 15:42:00 +0000</pubDate>
<dc:creator>resolvent</dc:creator>
<og:description>提升树 (Boosting Trees) 提升树是以分类树或回归树为基本分类器的提升方法, 模型表示为决策树的加法模型: $$ F_M(x) = \sum_{m=0}^M f(x;\Theta_m),</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shiina922/p/11029340.html</dc:identifier>
</item>
<item>
<title>聊聊数据库~6.SQL运维中篇 - 鲲逸鹏</title>
<link>http://www.cnblogs.com/dotnetcrazy/p/11029323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotnetcrazy/p/11029323.html</guid>
<description>&lt;p&gt;上篇回顾：&lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/10810798.html#top&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/dotnetcrazy/p/10810798.html#top&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;mysql日志相关&quot;&gt;1.6.5.MySQL日志相关&lt;/h3&gt;
&lt;p&gt;本文的测试环境：&lt;code&gt;MySQL5.7.26&lt;/code&gt;、&lt;code&gt;MariaDB5.5.60&lt;/code&gt;、&lt;code&gt;MySQL8.0.16&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：版本查询&lt;code&gt;select version();&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;mysql常用日志&quot;&gt;1.MySQL常用日志&lt;/h4&gt;
&lt;p&gt;服务器层日志（存储引擎层有自己的日志）&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;error_log&lt;/code&gt;(错误日志)&lt;/td&gt;
&lt;td&gt;记录MySQL启动、运行或停止时出现的问题&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;general_log&lt;/code&gt;(常规日志)&lt;/td&gt;
&lt;td&gt;记录所有发送给MySQL的请求（耗性能）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;code&gt;slow_query_log&lt;/code&gt;&lt;/strong&gt;(慢查日志)&lt;/td&gt;
&lt;td&gt;记录符合条件的查询（eg：超过10s、没有使用索引等）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;code&gt;binary_log&lt;/code&gt;&lt;/strong&gt;(二进制日志)&lt;/td&gt;
&lt;td&gt;记录全部有效的数据修改日志（老版本数据库不会开启）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;relay_log&lt;/code&gt;(中继日志)&lt;/td&gt;
&lt;td&gt;用于主从复制，临时存储主从同步的二进制日志（增量复制）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;知识扩展：&lt;a href=&quot;https://blog.csdn.net/zhang123456456/article/details/72811875&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/zhang123456456/article/details/72811875&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实时查看文件：&lt;code&gt;tail -f /var/log/mysqld.log&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tail -f 用于监视文件增长（默认是末尾10行）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;error_log错误日志&quot;&gt;2.error_log（错误日志）&lt;/h4&gt;
&lt;p&gt;一般记录MySQL&lt;code&gt;运行错误&lt;/code&gt;和和&lt;code&gt;未授权的访问&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;老版：&lt;code&gt;log_error&lt;/code&gt; + &lt;code&gt;log_warnings&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常用：&lt;code&gt;log_error&lt;/code&gt; + &lt;code&gt;log_error_verbosity&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;新版：&lt;code&gt;log_error&lt;/code&gt; + &lt;code&gt;log_error_verbosity&lt;/code&gt; + &lt;code&gt;log_error_services&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;查询MySQL配置：&lt;code&gt;show variables like '%log_error%';&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SQL查询可以这么干：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- Ubuntu下默认是：`/var/log/mysql/error.log`
-- CentOS下默认是：`/var/log/mysqld.log` | `/var/log/mariadb/mariadb.log`
select @@log_error; -- 尽可能和Data分开存储

-- 0：不记录警告信息，1：告警信息写入错误日志，2：各类告警信息都写入（eg:网络故障和重连信息）
select @@log_warnings; -- MySQL8中已经移除（MySQL5.7默认是2，MariaDB5.5.60默认是1）

-- 错误级别（1：Error，2：Error、Warning，3：Error、Warning、Info
select @@log_error_verbosity; -- MySQL8默认是2，MySQL5.7默认是3
-- PS：从MySQL 5.7.2开始，首选`log_error_verbosity`系统变量

-- 默认是`log_filter_internal; log_sink_internal`
select @@log_error_services; -- MySQL8.0中新增&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：其实MySQL在市面上有很多成熟解决方案（基本上都是基于5.6、5.7的）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这也是为什么我开篇主推&lt;code&gt;MySQL5.7&lt;/code&gt;系列和&lt;code&gt;MariaDB5.5.60&lt;/code&gt;（很多时候不是不用最新DB，而是架构依赖做不到啊）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知识拓展：&lt;a href=&quot;https://www.cnblogs.com/kerrycode/p/8973285.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/kerrycode/p/8973285.html&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;mysql8.0新增参数log_error_services&quot;&gt;MySQL8.0新增参数：log_error_services&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;日志服务组件&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;log_sink_internal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认的日志输出组件（依赖&lt;code&gt;log_error&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;code&gt;log_filter_internal&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;默认的日志过滤组件（依赖&lt;code&gt;log_error_verbosity&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;code&gt;log_sink_json&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;将错误日志输出到&lt;code&gt;json&lt;/code&gt;文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;log_sink_syseventlog&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将错误日志输出到系统日志文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;PS：&lt;code&gt;log_filter_internal&lt;/code&gt;：过滤错误信息（&lt;strong&gt;达不到级别的不记录&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日记格式一般是这样的&lt;/strong&gt;：&lt;code&gt;UTC时间戳 进程id [日志级别] [错误代码] [由什么产生的日志（Server or Client）] 详细信息&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;eg：&lt;code&gt;2019-05-19T09:54:11.590474Z 8 [Warning] [MY-010055] [Server] IP address '192.168.36.144' could not be resolved: Name or service not known&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;一般&lt;code&gt;log_sink_json&lt;/code&gt;用的比较多&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;1.3125&quot;&gt;
&lt;p&gt;官方文档参考：&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/error-log-json.html&quot; class=&quot;uri&quot;&gt;https://dev.mysql.com/doc/refman/8.0/en/error-log-json.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS：第一次使用需要安装一下json组件：&lt;code&gt;install component 'file://component_log_sink_json';&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;常用设置：&lt;code&gt;set persist log_error_services='log_filter_internal;log_sink_json';&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;时间戳相关的小知识点&quot;&gt;时间戳相关的小知识点&lt;/h5&gt;
&lt;p&gt;上面的时间默认是UTC的时间戳，和我们是有时差的，这个时间戳可以通过设置&lt;code&gt;log_timestamps&lt;/code&gt;来本地化：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询
select @@log_timestamps; -- MySQL5.7新增

-- 从8开始,可通过SET PERSIST命令将全局变量的修改持久化到配置文件中
set persist log_timestamps='SYSTEM'; -- 需要root权限&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PS：&lt;code&gt;set persist&lt;/code&gt;生成的配置文件路径在：&lt;code&gt;/var/lib/mysql/mysqld-auto.cnf&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;general_log常规日志&quot;&gt;3.general_log（常规日志）&lt;/h4&gt;
&lt;p&gt;以前开发调试的时候基本上都是会开启的，上线后关闭（系统V1初期的时候也会开启一段时间）&lt;/p&gt;
&lt;blockquote readability=&quot;4.2857142857143&quot;&gt;
&lt;p&gt;&lt;strong&gt;现在开发可以使用&lt;a href=&quot;https://www.cnblogs.com/dotnetcrazy/p/10443522.html&quot;&gt;go-sniffer&lt;/a&gt;来抓包查看客户端执行的SQL&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 是否打开常规日志（0不打开，1打开）
-- 一般不打开（性能）
select @@general_log; -- 默认为0

-- Ubuntu默认：/var/lib/mysql/ubuntuserver.log
-- CentOS默认：/var/lib/mysql/localhost.log
select @@general_log_file; -- 常规日志的路径

-- 日志的存储方式（FILE | TABLE | NONE）
select @@log_output; -- 默认是文件存储&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单看一下常规日志在数据库中的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201905/1127869-20190522182213738-70856259.png&quot; alt=&quot;2.常规日志.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;临时开启参考&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 开启
set global general_log = 1;

# set [global | persist] general_log_file = '日志路径';

set global log_output = 'TABLE';&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;slow_query_log慢查询日志&quot;&gt;4.&lt;code&gt;slow_query_log&lt;/code&gt;（慢查询日志）&lt;/h4&gt;
&lt;p&gt;这个是&lt;code&gt;最常用&lt;/code&gt;的，把符合条件的查询语句记录在日志中，&lt;strong&gt;一般都是些需要优化的SQL&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：出现性能瓶颈的时候，或者为了优化SQL会开启一段时间（小项目推荐直接开启）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先看下默认值：&lt;strong&gt;&lt;code&gt;show variables like '%slow%';&lt;/code&gt;、&lt;code&gt;show variables like 'long%';&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201905/1127869-20190522192146261-1133467961.png&quot; alt=&quot;2.慢查询.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQL查询&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 是否开启
select @@slow_query_log; -- 默认是关闭

-- CentOS：/var/lib/mysql/localhost-slow.log
-- Ubuntu：/var/lib/mysql/ubuntuserver-slow.log
select @@slow_query_log_file;

-- 条件：设置超过多少秒为慢查询（一般设置1s）
select @@long_query_time; -- 默认是10s（支持小数：0.003)

-- PS：设置为0就会记录所有SQL（不推荐这么干）

-- 条件：没有使用索引的查询记录到日志中
select @@log_queries_not_using_indexes; -- 默认是0（不开启）

-- 记录optimize table、analyze table和alter table的管理语句
select @@log_slow_admin_statements; -- 默认是0（不开启）

-- 记录由Slave所产生的慢查询
select @@log_slow_slave_statements;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;常用设置&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：高并发下的互联网项目，对SQL执行时间的容忍度一般都是&lt;strong&gt;低于&lt;code&gt;300~500ms&lt;/code&gt;&lt;/strong&gt;的（&lt;code&gt;long_query_time=0.05&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 常用如下：（需要MySQL的root权限）
set global slow_query_log = 1; # 开启慢查询日志
set global long_query_time = 1; # 记录大于1s的SQL
set global log_slow_admin_statements = 1; # 记录管理语句
set global log_queries_not_using_indexes = 1; # 记录没有使用索引的SQL
# set [global | persist] slow_query_log_file = '路径'; # 设置log路径&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;设置&lt;code&gt;long_query_time&lt;/code&gt;时，需要重新连接才能生效（不需要重启DB）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：当前会话不生效，之后的会话就生效了（不想重连可以再设置下当前会话的&lt;code&gt;long_query_time&lt;/code&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知识拓展：（&lt;code&gt;chown mysql:mysql /work/log/xxx.log&lt;/code&gt;）&lt;/p&gt;
&lt;h4 id=&quot;扩展慢查询工具&quot;&gt;扩展：慢查询工具&lt;/h4&gt;
&lt;p&gt;先简单分析下慢查询日志：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# Time: 2019-05-22T21:16:28.759491+08:00
# User@Host: root[root] @ localhost []  Id:    11
# Query_time: 0.000818  Lock_time: 0.000449 Rows_sent: 5  Rows_examined: 5
SET timestamp=1558530988;
select * from mysql.user order by host; # SQL语句&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Time&lt;/code&gt;：查询的&lt;strong&gt;执行时间&lt;/strong&gt;（&lt;code&gt;start_time&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;User@Host: root[root] @ localhost [] Id:11&lt;/code&gt;：执行 sql 的&lt;strong&gt;主机信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Query_time&lt;/code&gt;：SQL&lt;strong&gt;&lt;code&gt;查询&lt;/code&gt;&lt;/strong&gt;所&lt;strong&gt;耗&lt;/strong&gt;的&lt;strong&gt;时&lt;/strong&gt;间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Lock_time&lt;/code&gt;：&lt;strong&gt;锁定时间&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Rows_sent&lt;/code&gt;：所&lt;strong&gt;发送的行数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Rows_examined&lt;/code&gt;：&lt;strong&gt;锁扫描的行数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SET timestamp=1558530988;&lt;/code&gt;：SQL&lt;strong&gt;执行时间&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在可以说说工具了，推荐两款：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自带的慢日志分析工具：&lt;code&gt;mysqldumpslow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MySQL工具箱（&lt;code&gt;percona-toolkit&lt;/code&gt;）中的&lt;code&gt;pt-query-digest&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;mysqldumpslow精简&quot;&gt;mysqldumpslow（精简）&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;查询最慢的10条SQL：&lt;code&gt;mysqldumpslow -s t -t 10 /var/lib/mysql/localhost-slow.log&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;-s 按照那种方式排序
    t: 查询时间
    c：访问计数
    l：锁定时间
    r:返回记录
    al：平均锁定时间
    ar：平均访问记录数
    at：平均查询时间
-t 返回多少条数据（可以理解为top n）
-g 可以跟上正则匹配模式，大小写不敏感。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：使用mysqldumpslow的分析结果不会显示具体完整的sql语句：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;翻页sql不一样，性能也是不一样的，越往后的页数越容易出现慢查询，而mysqldumpslow把所有翻页sql当成一个sql了&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;eg：&lt;code&gt;select * from tb_table where uid=20 group by createtime limit 10000, 1000;&lt;/code&gt; ==&amp;gt; &lt;code&gt;select * from tb_table where uid=N group by createtime limit N, N;&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;不管你uid和limit怎么变，mysqldumpslow认为是一样的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;pt-query-digest推荐&quot;&gt;pt-query-digest（推荐）&lt;/h5&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html&quot; class=&quot;uri&quot;&gt;https://www.percona.com/doc/percona-toolkit/3.0/pt-query-digest.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;分析慢查询日志：&lt;code&gt;pt-query-digest /var/lib/mysql/localhost-slow.log&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;使用tcppdump捕获MySQL协议数据，然后报告最慢的查询：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 &amp;gt; mysql.tcp.txt&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pt-query-digest --type tcpdump mysql.tcp.txt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;查看来自远程进程列表上最慢的查询：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pt-query-digest --processlist h=ip&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;安装可以参考：&lt;a href=&quot;https://github.com/lotapp/awesome-tools/blob/master/README.md#4%E8%BF%90%E7%BB%B4&quot;&gt;https://github.com/lotapp/awesome-tools/blob/master/README.md#4%E8%BF%90%E7%BB%B4&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：percona-toolkit的常用工具我也在里面简单说了下，对应文档也贴了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;other&quot;&gt;other&lt;/h5&gt;
&lt;p&gt;PS：还有一款&lt;strong&gt;&lt;code&gt;mysqlsla&lt;/code&gt;&lt;/strong&gt;我没用过，所以贴个参考文章，感兴趣的同志自己研究下&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/fengchi/p/6187099.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/fengchi/p/6187099.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知识拓展：&lt;a href=&quot;https://www.cnblogs.com/fengchi/p/6187099.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/fengchi/p/6187099.html&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;binary_log二进制日志&quot;&gt;5.binary_log（二进制日志）&lt;/h4&gt;
&lt;p&gt;上节主要说了通用日志和慢查日志，今天说下二进制日志：&lt;/p&gt;
&lt;p&gt;二进制日志算是最常用的了，主要就是&lt;strong&gt;&lt;code&gt;记录对数据库的修改&lt;/code&gt;&lt;/strong&gt;，然后就是&lt;strong&gt;&lt;code&gt;主从复制&lt;/code&gt;&lt;/strong&gt;用的比较多（比如增量备份）&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：记录了修改操作，那么衍生出的场景就是：&lt;code&gt;增量备份和恢复&lt;/code&gt;（基于时间点的备份和恢复）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PS：MySQL日志主要分为这两类：（互不干扰）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;服务层&lt;/code&gt;日志（和使用存储引擎无关）
&lt;ul&gt;&lt;li&gt;通用日志、慢查询日志、二进制日志&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;存储引擎层&lt;/code&gt;日志
&lt;ul&gt;&lt;li&gt;eg：innodb的重做日志(&lt;code&gt;redo log&lt;/code&gt;)和回滚日志(&lt;code&gt;undo log&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Q：那什么样的修改会记录下来呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;A：记录所有对MySQL数据库的修改事件（包括增删改查事件和对表结构修改的事件），而且&lt;strong&gt;只记录已经成功执行的事件&lt;/strong&gt;（失败的不会记录）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这么说可能有点抽象，熟悉SQLServer的同志看个图就秒懂：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615114306346-1188080944.png&quot; alt=&quot;3.二进制日志.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;二进制日志格式&quot;&gt;5.1.二进制日志格式&lt;/h5&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;STATEMENT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基于段的格式，记录执行数据修改时候所执行的SQL语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;code&gt;ROW&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基于行的格式，记录增删改查操作所修改行的信息（每修改一行就会有一条信息）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;&lt;code&gt;MIXED&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;基于行和端的混合格式，根据SQL语句由系统决定是基于段还是基于行的日志格式记录&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;查看方式：&lt;strong&gt;&lt;code&gt;show variables like 'binlog_format';&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;binlog_format=&lt;code&gt;statement&lt;/code&gt;&lt;/strong&gt;：基于段的记录格式（老版本的默认值）
&lt;ol&gt;&lt;li&gt;优点：记录量较小，节约磁盘和网络IO（单条操作Row更节约）&lt;/li&gt;
&lt;li&gt;缺点：必须记录上下文信息来保证语句在从服务器上执行结果与主服务器相同
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;但是如果使用了&lt;code&gt;uuid()&lt;/code&gt;、&lt;code&gt;user()&lt;/code&gt;等结果非确定的函数，可能会造成MySQL主从不一致&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志查看&lt;/strong&gt;：&lt;code&gt;mysqlbinlog /var/lib/mysql/binlog.0000xx | more&lt;/code&gt;（不用指定参数）&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;binlog_format=&lt;code&gt;row&lt;/code&gt;&lt;/strong&gt;：基于行的记录格式（5.7以后的默认值）
&lt;ol&gt;&lt;li&gt;优点：可以避免MySQL复制中出现的主从不一致的问题（主从更安全）
&lt;ul&gt;&lt;li&gt;PS：没有备份的时候可以通过分析row格式的二进制日志来反向恢复&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缺点：记录日志量较大（顺序写入）
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;现在增加了新参数来优化&lt;/strong&gt;：&lt;code&gt;binlog_row_image=[full|minimal|noblob]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志查看&lt;/strong&gt;：&lt;code&gt;mysqlbinlog -vv /var/lib/mysql/binlog.0000xx | more&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;binlog_format=&lt;code&gt;mixed&lt;/code&gt;&lt;/strong&gt;：基于行和端的混合格式（&lt;code&gt;推荐&lt;/code&gt;）
&lt;ul&gt;&lt;li&gt;PS：数据量大小由所执行的SQL决定（非确定性函数越多，行数越多）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;PS：&lt;strong&gt;DDL操作（create、drop、alter）的时候都是基于段方式来记录log&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果一条一条记录，表有上亿数据，我就修改某列的状态值，那不得疯？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;对&lt;code&gt;binlog_row_image=[FULL|MINIMAL|NOBLOB]&lt;/code&gt;的补充说明&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：&lt;strong&gt;查看方式：&lt;code&gt;show variables like 'binlog_row_image'&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;默认是&lt;code&gt;full&lt;/code&gt;：完整
&lt;ul&gt;&lt;li&gt;记录修改行的全部内容&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;noblob&lt;/code&gt;：就是在full记录的基础上对大文本列的优化
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;没有对text或者blob列修改就不记录该列&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minimal&lt;/code&gt;：简单记录，&lt;strong&gt;只记录修改的那一列&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;PS：&lt;strong&gt;这个要特别注意一点，虽然容量小了，但是一旦误操作，很难恢复的&lt;/strong&gt;（不知道原来内容）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;推荐使用&quot;&gt;推荐使用&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;一般使用&lt;code&gt;binlog_format=mixed&lt;/code&gt;混合格式&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;binlog_format=row&lt;/code&gt;&lt;/strong&gt; + &lt;strong&gt;&lt;code&gt;binlog_row_image=minimal&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PS：如果对安全性要求特别高，推荐使用&lt;code&gt;binlog_format=row&lt;/code&gt; + &lt;code&gt;binlog_row_image=full&lt;/code&gt;（不怕误操作）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个和SQLServer的日志恢复模式有点类似，我贴下图你们可以对比参考：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615114311864-1704843102.png&quot; alt=&quot;3.容量.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;二进制日志配置&quot;&gt;5.2.二进制日志配置&lt;/h5&gt;
&lt;p&gt;上面虽然说完了二进制日志的常用3种格式，但老版本默认都是不启用二进制日志的，咋办？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：如果是MariaDB可以去示例配置中查看：&lt;code&gt;ls /usr/share/mysql/ |grep .cnf&lt;/code&gt;（CentOS）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;验证下：&lt;/p&gt;
&lt;p&gt;MySQL8之前：&lt;code&gt;cat /etc/mysql/mysql.conf.d/mysqld.cnf&lt;/code&gt;（UbuntuServer）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615105438869-1854139695.png&quot; alt=&quot;3.binlog.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MySQL8：&lt;code&gt;cat /etc/my.cnf |grep log&lt;/code&gt;（CentOS）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615105953261-70366363.png&quot; alt=&quot;3.binlog2.png&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Q：有些人可能疑惑了，为什么用&lt;strong&gt;&lt;code&gt;show variables like 'log_bin';&lt;/code&gt;&lt;/strong&gt;查询出来的结果和配置文件中不大一样啊？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：一般配置项中的参数都可以使用&lt;code&gt;show variables like 'xx'&lt;/code&gt;来查询对应的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615112651069-338309897.png&quot; alt=&quot;3.log_bin.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A：那是因为5.7之后版本分成了两个参数：&lt;strong&gt;&lt;code&gt;log_bin&lt;/code&gt;和&lt;code&gt;log_bin_basename&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：&lt;strong&gt;配置文件的&lt;code&gt;log_bin=xxx&lt;/code&gt;相当于命令中的&lt;code&gt;log_bin&lt;/code&gt;和&lt;code&gt;log_bin_basename&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show variables like 'log_bin%';
+---------------------------------+-----------------------------+
| Variable_name                   | Value                       |
+---------------------------------+-----------------------------+
| log_bin                         | ON                          |
| log_bin_basename                | /var/lib/mysql/binlog       |
| log_bin_index                   | /var/lib/mysql/binlog.index |
| log_bin_trust_function_creators | OFF                         |
| log_bin_use_v1_row_events       | OFF                         |
+---------------------------------+-----------------------------+
5 rows in set (0.00 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;开启演示&quot;&gt;开启演示&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;MariaDB开启binlog图示&lt;/strong&gt;：（CentOS）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615215014750-902512611.jpg&quot; alt=&quot;4.MariaDB开启binlog.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL5.7演示&lt;/strong&gt;：（UbuntuServer）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615215118756-1227225512.jpg&quot; alt=&quot;4.UbuntuServer下MySQL5.7演示.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置文件中修改：（&lt;strong&gt;&lt;code&gt;show variables like 'binlog_format';&lt;/code&gt;：查看当前binlog基于什么格式&lt;/strong&gt;）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 服务器标识
server-id=1 # 单机MariaDB可不开启

# 开启binlog并设置路径
# 不指定路径则默认在数据目录下
log_bin=binlog # 这个代表以binlog开头的文件

# binlog采用ROW|MIXED格式
# binlog_format=MIXED # 5.7默认是ROW&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看下文件前缀（&lt;code&gt;log_bin=binlog&lt;/code&gt;）的概念，一张图就懂：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615223600204-780006208.png&quot; alt=&quot;4.文件前缀.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：&lt;strong&gt;如果log_bin只是指定一个名字，那么默认路径一般都是在数据文件的文件夹中&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;配置文件一般都会写，eg:&lt;code&gt;datadir=/var/lib/mysql&lt;/code&gt;，或者通过&lt;strong&gt;&lt;code&gt;show variables like 'datadir';&lt;/code&gt;&lt;/strong&gt;也可以查询到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然和SQLServer文件组不是一个概念，但有些相似 ==&amp;gt; &lt;code&gt;log可以多个也可以动态调整&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615114910706-1077844738.png&quot; alt=&quot;3.多日志文件.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;row模式下记录sql&quot;&gt;5.3.ROW模式下记录SQL&lt;/h5&gt;
&lt;p&gt;Q：虽然ROW记录能保证主从数据安全，但我们排查问题的时候往往需要知道SQL，而用段的记录方式又不合适，咋办？&lt;/p&gt;
&lt;p&gt;A：有个新参数可以解决：&lt;strong&gt;&lt;code&gt;binlog_rows_query_log_events&lt;/code&gt;&lt;/strong&gt;，开启后就可以记录sql了&lt;/p&gt;
&lt;p&gt;查看方式：&lt;strong&gt;&lt;code&gt;show variables like 'binlog_row%';&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;mysql&amp;gt; show variables like 'binlog_row%';
+------------------------------+-------+
| Variable_name                | Value |
+------------------------------+-------+
| binlog_row_image             | FULL  |
| binlog_rows_query_log_events | OFF   |
+------------------------------+-------+
2 rows in set (0.01 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;binlog演示&quot;&gt;binlog演示&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;显示binlog列表：&lt;code&gt;show binary logs;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刷新一份新的binlog：&lt;code&gt;flush logs;&lt;/code&gt;&lt;/strong&gt;（现在开始的二进制日志就记录在这个新文件中）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615230123267-704005638.jpg&quot; alt=&quot;5.新建binlog.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;binlog现在是空的：(&lt;code&gt;-vv&lt;/code&gt;：把二进制格式的日志显示为能读懂的字符串)&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;mysqlbinlog --no-defaults -vv --base64-output=DECODE-ROWS /var/lib/mysql/binlog.000006&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615230220876-63662242.png&quot; alt=&quot;5.新建binlog2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在简单摸拟几个SQL操作，然后看看binlog：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615230537927-1686327416.png&quot; alt=&quot;6.sql.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看下binlog日志：(线上开发一般都是FULL模式，主要是防止程序员修改SQL的时候不加条件等误操作)&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;FULL模式就是这样，该行数据全部记录（修改部分其实就绿色框的地方）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615231013171-515634847.jpg&quot; alt=&quot;6.binlog.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想要binlog中记录SQL就开启&lt;code&gt;binlog_rows_query_log_events&lt;/code&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：像这种操作，如果模式选混合模式，binlog中会记录SQL的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;临时开启下&lt;code&gt;binlog_rows_query_log_events&lt;/code&gt;（如果你有需要可以配置文件设置一下）&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS：MySQL8可通过&lt;code&gt;set persist&lt;/code&gt;命令将全局变量的修改持久化到配置文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615231626834-759896379.png&quot; alt=&quot;6.sql2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615231542008-1771345221.png&quot; alt=&quot;6.binlog2.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;二进制日志的清除&quot;&gt;5.4.二进制日志的清除&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;自动清除
&lt;ul&gt;&lt;li&gt;配置文件中设置时间：&lt;code&gt;expire_logs_days = 30&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;手动清除
&lt;ul&gt;&lt;li&gt;删除指定编号之前的日志：&lt;code&gt;purge binary logs to 'binlog.000006';&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;删除指定时间之前的日志：&lt;code&gt;purge binary logs before '2019-06-15 14:14:00';&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;已经23:23了，我们快速演示下：&lt;/p&gt;
&lt;p&gt;MySQL命令行中执行命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615232721720-252354903.png&quot; alt=&quot;7.删除.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文件列表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1127869/201906/1127869-20190615232749442-1177374128.png&quot; alt=&quot;7.文件.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;二进制日志与主从&quot;&gt;5.5.二进制日志与主从&lt;/h5&gt;
&lt;p&gt;这个把运维篇讲完会继续说，运维篇结束后会有个高级篇（架构），这边就简单提下&lt;code&gt;二进制格式对主从复制的影响&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于SQL语句的复制（SBR）
&lt;ul&gt;&lt;li&gt;二进制日志格式使用的是&lt;code&gt;statement&lt;/code&gt;格式（5.7前的默认）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;基于行的复制（RBR）
&lt;ul&gt;&lt;li&gt;二进制日志格式使用的是基于行的日志格式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;混合模式
&lt;ul&gt;&lt;li&gt;根据实际在上面两者中切换&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;贴个课后拓展文章：&lt;a href=&quot;https://www.cnblogs.com/gujianzhe/p/9371682.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/gujianzhe/p/9371682.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下级预估：备份与恢复、监控&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Jun 2019 15:34:00 +0000</pubDate>
<dc:creator>鲲逸鹏</dc:creator>
<og:description>上篇回顾： 1.6.5.MySQL日志相关 本文的测试环境： 、`MariaDB5.5.60 MySQL8.0.16` PS：版本查询 1.MySQL常用日志 服务器层日志（存储引擎层有自己的日志）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dotnetcrazy/p/11029323.html</dc:identifier>
</item>
<item>
<title>Android Bitmap（位图）详解 - 摇头耶稣</title>
<link>http://www.cnblogs.com/shakinghead/p/11025805.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shakinghead/p/11025805.html</guid>
<description>&lt;p&gt;WebP 是 Google 在 2010 年发布的图片格式，希望以更高的压缩率替代 JPEG。它用 VP8 视频帧内编码作为其算法基础，取得了不错的压缩效果。WebP支持有损和无损压缩、支持完整的透明通道、也支持多帧动画，并且没有版权问题，是一种非常理想的图片格式。WebP支持动图，基本取代gif。&lt;/p&gt;&lt;p&gt;WebP不仅集成了PNG、JPEG和Gif的所有功能，而且相同质量的无损压缩WebP图片体积比PNG小大约26%；如果是有损压缩，相同质量的WebP图片体积比JPEG小25%-34%。&lt;/p&gt;&lt;p&gt;很多人会认为，既然WebP功能完善、压缩率更高，那直接用WebP取代上述所有的图片压缩格式不就行了吗？其实不然，WebP也有其缺点：我们知道JPEG是有损压缩而PNG是无损压缩，所以JPEG的压缩率高于PNG；但是有损压缩的算法决定了其压缩时间一定是高于无损压缩的，也就是说JPEG的压缩时间高于PNG。而WebP无论是无损还是有损压缩，压缩率都分别高于PNG和JPEG；与其相对应的是其压缩时间也比它们长的多。经测试，WebP图片的编码时间比JPEG长8倍。可以看出，时间和空间是一对矛盾；如果想要节省更多的空间，必然要付出额外的时间；如果想要节省时间，那么必然要付出空间的代价。这取决于我们在实际中对于时空不同的需求程度来做出选择。&lt;/p&gt;&lt;p&gt;不管怎么说，WebP还是一种强大的、理想的图片压缩格式，并且借由 Google 在网络世界的影响力，WebP 在几年的时间内已经得到了广泛的应用。看看你手机里的 App：微博、微信、QQ、淘宝等等，每个 App 里都有 WebP 的身影。&lt;/p&gt;&lt;p&gt;目前来说，以上所述的五种压缩格式，Android操作系统都提供了原生支持；但是在上层能直接调用的编码方式只有 JPEG、PNG、WebP 这三种。具体的，可以查看Bitmap类的枚举内部类CompressFormat类的枚举值来获取上层能调用的图片编码方式。你会发现枚举值也是JPEG、PNG和WEBP三种。&lt;/p&gt;&lt;p&gt;如果我们想要在应用层使用Gif格式图片，需要自行引入第三方函数库来提供对Gif格式图片的支持。不过一般我们用WebP取代Gif。&lt;/p&gt;&lt;p&gt;因此，我们只需要比较分析PNG、JPEG、WebP这三种压缩格式即可。&lt;/p&gt;&lt;p&gt;①对于摄影类等真彩图片：因为我们对这类色彩丰富的图片的透明度没有要求（一般默认为不透明），可以采用JPEG有损压缩格式，因为JPEG本身就不支持透明度，而且因为是有损压缩，所以尽管会牺牲一丢丢照片的质量但是可以大大减少体积。如果非要采用PNG格式，那么首先因为PNG支持透明度通道，所以明明不必要的透明度值却会被存储；其次因为是无损压缩，所以压缩率不会很高从而导致保存的图片非常大！综上比较，建议采用JPEG格式，不要用PNG格式。&lt;/p&gt;&lt;p&gt;JPEG格式可以与Bitmap.Config参数值为RGB_565搭配使用，这是一个理想的设置。&lt;/p&gt;&lt;p&gt;②对于logo图标、背景图等图片：这类图片的特点是往往是有大块的颜色相同的区域，这与无损压缩的思路不谋而合（即删除重复数据）。而且这类图片对透明度是有要求的，因此可以采用PNG无损压缩格式；尽管使用PNG格式会让图片有点大，但是可以在后续进行PNG图片优化以对APP体积进行瘦身。如果非要采用JPEG格式，那么由于有损压缩的原理（利用人脑的自动补全机制），可能会随机地丢失一些线条导致最终的图片完全不是想要的效果。综上比较，建议使用PNG格式，不要用JPEG格式。&lt;/p&gt;&lt;p&gt;PNG格式可以与Bitmap.Config参数值为ARGB_8888搭配使用，这是一个理想的设置。&lt;/p&gt;&lt;p&gt;当然，以上两种情况，我们都可以使用WebP取代PNG或JPEG，如果我们想要这么做的话。如果你的项目中对空间的需求程度更高，你完全有理由这么做。但是如果你对空间需求程度还OK，你也可以选择分情况使用PNG或JPEG格式。&lt;/p&gt;&lt;p&gt;图片优化属于Android性能优化的一种，这里主要是针对PNG图片的大小进行优化，毕竟PNG这种无损压缩格式往往会导致图片都比较大。除非你的项目已经全面支持了WebP格式，否则对PNG格式图片的优化都会是你必须考虑的一点，这有利于减少APP的体积大小。&lt;/p&gt;&lt;p&gt;对PNG图片进行优化的思想是：减少PNG图片的体积，常用方式有：&lt;/p&gt;&lt;p&gt;ImageOptim是一种无损压缩工具，所以你不用担心利用该工具对PNG图片进行压缩后图片质量会受影响。它的压缩原理是：优化PNG压缩参数，移除冗余元数据以及非必需的颜色配置文件等，在不牺牲图片质量的前提下，既减少了PNG图片的大小，又提高了其加载的速度。&lt;/p&gt;&lt;p&gt;ImageAlpha与ImageOptim是同一个作者，不过ImageAlpha属于有损压缩，因此图片质量会受到影响。所以使用ImageAlpha对PNG图片进行压缩后，必须让设计师检视一下优化后的PNG图片，以免影响APP的视觉效果。但是ImageAlpha的优点是可以极大减少PNG图片的体积大小。&lt;/p&gt;&lt;p&gt;前面两个工具是应用程序，TinyPNG是一个Web站点。你可以上传原PNG图片，它对PNG图片压缩后你就可以下载优化后的结果了。因为TinyPNG也是有损压缩，所以优缺点同②&lt;/p&gt;&lt;p&gt;以上方案都属于对PNG图片进行二次压缩（有的是有损有的是无损），我们需要在图片质量和图片大小这对矛盾中根据实际情况进行选择。&lt;/p&gt;&lt;p&gt;如果不想对PNG图片进行二次压缩，可以考虑直接将其替换为WebP格式的图片。另外，我们对JPEG格式的图片也可以这么替换。毕竟WebP无论是与PNG还是与JPEG格式想比，压缩后体积大小都小很多。WebP转换工具有：&lt;/p&gt;&lt;p&gt;.9.png图片格式简称为NinaPatch图，本质上仍然是PNG格式图片。不过它的优点是体积小、拉伸不变形，能够很好地适配Android各种机型。我们可以利用Android Studio提供的功能，右键一张PNG图片点击“create 9=Patch File”即可完成转换。&lt;/p&gt;&lt;p&gt;总结：无论是二次压缩还是格式转换，无论是有损二次压缩还是无损二次压缩，我们都需要根据实际需求进行方案和工具的选择。&lt;/p&gt;&lt;p&gt;我们已经知道了Android中图片内存中的表示形式（Bitmap）和磁盘上的表示形式（各种压缩格式），以及二者的关系（压缩和解压缩的过程）。下面具体看看Bitmap的使用方式和注意事项，毕竟磁盘上存储的图片终究还是要加载到内存中以Bitmap的形式进行展示的。&lt;/p&gt;&lt;p&gt;Bitmap的工厂类BitmapFactory提供了四类静态方法用于加载Bitmap对象：decodeFile、decodeResource、decodeStream、decodeByteArray。&lt;/p&gt;&lt;p&gt;分别代表从本地图片文件、项目资源文件、流对象（可以是网络输入流对象或本地文件输入流对象）、字节序列中加载一个Bitmap对象。&lt;/p&gt;&lt;p&gt;之前讲的图片的三个来源，都可以找到对应的decodeXXXX方法来获取该图片对应的Bitmap对象。&lt;/p&gt;&lt;p&gt;举个例子，假设需要通过网络请求一张图片资源并展示：先处理该网络请求并得到返回结果的输入流对象；依据该流对象调用decodeStream方法得到一个Bitmap对象，该对象即表示这张图片的内容；最后通过ImageView的setImageBitmap()方法显示该图片即可。&lt;/p&gt;&lt;p&gt;Bitmap的压缩存储与Bitmap的加载是相反的过程，通过compress()方法来实现，该方法原型为：&lt;/p&gt;&lt;p&gt;format参数表示压缩存储的格式，可选为PNG、JPEG和WEBP；quality表示压缩率，取值在0~100之间，100表示未压缩，30表示压缩为原大小的30%，但是该参数在format值为PNG时无效，因为PNG属于无损压缩无法设置压缩率；stream就是希望输出到某个位置的输出流对象，比如某个文件的输出流对象。&lt;/p&gt;&lt;p&gt;通过compress()方法可以将Bitmap按照指定的格式和压缩率（非PNG格式时）压缩存储到指定的位置。&lt;/p&gt;&lt;p&gt;BitmapFactory是Bitmap的工厂类，通过BitmapFactory的静态方法来创建Bitmap对象；BitmapFactory.Options类代表对Bitmap对象的属性设置（配置）。一般情况下，我们调用decodeXXXX方法时不需要传递一个BitmapFactory.Options对象作为参数，因此此时是利用默认的配置信息来创建Bitmap对象。如果需要对创建的Bitmap对象进行自定义的配置，那么就需要给decodeXXXX方法传递一个BitmapFactory.Options对象，该对象包含了对Bitmap对象的配置信息。&lt;/p&gt;&lt;p&gt;通过BitmapFactory.Options类的构造器创建BitmapFactory.Options对象。该对象包含的Bitmap配置信息即为该对象的各属性值，主要有：&lt;/p&gt;&lt;div readability=&quot;236.69208150985&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1218256/201906/1218256-20190615162345712-1901971754.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;介绍一下比较不好理解的属性：&lt;/p&gt;
&lt;p&gt;①inJustDecodeBounds：这个属性表示是否只扫描轮廓，默认为false。如果该属性为true，decodeXXXX方法不会返回一个Bitmap对象（即不会为Bitmap分配内存）而是返回null。那如果decodeXXXX方法不再分配内存以创建一个Bitmap对象，那么还有什么用呢?答案就是：扫描轮廓。&lt;/p&gt;
&lt;p&gt;BitmapFactory.Options对象的outWidth和outHeight属性分别代表Bitmap对象的宽和高，但是这两个属性在Bitmap对象未创建之前显然默认为0，默认只有在Bitmap对象创建后才能被赋予正确的值。而当inJustDecodeBounds属性为true，虽然不会分配内存创建Bitmap对象，但是会扫描轮廓来给outWidth和outHeight属性赋值，就相当于绕过了Bitmap对象创建的这一步提前获取到Bitmap对象的宽高值。那这个属性到底有啥用呢？具体用处体现在Bitmap的采样率计算中，后面会详细介绍。&lt;/p&gt;
&lt;p&gt;②inSample：这个表示Bitmap的采样率，默认为1。比如说有一张图片是2048像素X1024像素，那么默认情况下该图片加载到内存中的Bitmap对象尺寸也是2048像素X1024像素。如果采用的是ARGB_8888方式，那么该Bitmap对象加载所消耗的内存为2048X1024X4/1024/1024=8M。这只是一张图片消耗的内存，如果当前活动需要加载几张甚至几十张图片，那么会导致严重的OOM错误。&lt;/p&gt;
&lt;p&gt;OOM错误：尽管Android设备内存大小可能达到好几个G（比如4G），但是Andorid中每个应用其运行内存都有一个阈值，超过这个阈值就会引发out of memory即OOM错误（内存溢出错误）。因为现在市场上流行的手机设备其操作系统都是在Andori原生操作系统基础上的拓展，所以不同的设备环境中这个内存阈值不一样。可以通过以下方法获取到当前应用所分配的内存阈值大小，单位为字节： Runtime.getRuntime().maxMemory()；&lt;/p&gt;
&lt;p&gt;尽管我们确实可以通过设置来修改这个阈值大小以提高应用的最大分配内存（具体方式是在在Manifest中设置android.largeHeap=&quot;true&quot;），但是需要注意的是：内存是一种很宝贵的资源，不加考虑地无脑给每个应用提高最大分配内存是一个糟糕的选择。因为手机总内存相比较每个应用默认的最大分配内存虽然高很多，但是手机中的应用数量是非常多的，每个应用都修改其运行内存阈值为几百MB甚至一个G，这很严重影响手机性能！另外，如果应用的最大分配内存很高，这意味着其垃圾回收工作也会变得更加耗时，这也会影响应用和手机的性能。所以，这个方案需要慎重考虑不能滥用。&lt;/p&gt;
&lt;p&gt;关于这个方案的理解可以参考一位大神的解释：“在一些特殊的情景下，你可以通过在manifest的application标签下添加largeHeap=true的属性来为应用声明一个更大的heap空间。然后，你可以通过getLargeMemoryClass()来获取到这个更大的heap size阈值。然而，声明得到更大Heap阈值的本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。不要轻易的因为你需要使用更多的内存而去请求一个大的Heap Size。只有当你清楚的知道哪里会使用大量的内存并且知道为什么这些内存必须被保留时才去使用large heap。因此请谨慎使用large heap属性。使用额外的内存空间会影响系统整体的用户体验，并且会使得每次gc的运行时间更长。在任务切换时，系统的性能会大打折扣。另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。”&lt;/p&gt;
&lt;p&gt;综上，我们已经知道了Bitmap的加载是一个很耗内存的操作，特别是在大位图的情况下。这很容易引发OOM错误，而我们又不能轻易地通过修改或提供应用的内存阈值来避免这个错误。那么我们该怎么做呢？答案就是：利用这里所说的采样率属性来创建一个原Bitmap的子采样版本。这也是官方推荐的对于大位图加载的OOM问题的解决方案。其具体思想为：比如还是那张尺寸为2048像素X1024像素图片，在inSample值默认为1的情况下，我们现在已经知道它加载到内存中默认是一个2048像素X1024像素大位图了。我们可以将inSample设置为2，那么该图片加载到内存中的位图宽高都会变成原宽高的1/2，即1024像素X512像素。进一步，如果inSample值设置为4，那么位图尺寸会变成512像素X256像素，这个时候该位图所消耗的内存（假设还是ARGB_8888方式）为512X256X4/1024/1024=0.5M，可以看出从8M到0.5M，这极大的节省了内存资源从而避免了OOM错误。&lt;/p&gt;
&lt;p&gt;切记：官方对于inSample值的要求是，必须为2的幂，比如2、4、8...等整数值。&lt;/p&gt;
&lt;p&gt;这里会有两个疑问：第一：通过设置inSample属性值来创建一个原大位图的子采样版本的方式来降低内存消耗，听不上确实很不错。但是这不会导致图片严重失真吗？毕竟你丢失了那么多像素点，这意味着你丢失了很多颜色信息。对这个疑问的解释是：尽管在采样的过程确实会丢失很多像素点，但是原位图的尺寸也在减小，其像素密度是不变的。比如说如果inSample值为2，那么子采样版本的像素点数量是原来的1/4，但是子采样版本的显示尺寸（区域面积）也会变成原来的1/4，这样的话像素密码是不变的因此图片不用担心严重失真问题。第二：inSample值如何选取才是最佳？这其实取决于ImageView的尺寸，具体采样率的计算方式后面会详细介绍。&lt;/p&gt;
&lt;p&gt;③inPreferredConfig：该属性指定Bitmap的色深值，该属性类型为Bitmap.Config值。&lt;/p&gt;
&lt;p&gt;例如你可以指定某图片加载为Bitmap对象的色深模式为ARGB_8888，即：options.inPreferredConfig=Bitmap.Config.ARGB_8888；&lt;/p&gt;
&lt;p&gt;④isMutable：该属性表示通过decodeXXXX方法创建的Bitmap对象其代表的图片内容是否允许被外部修改，比如利用Canvas重新绘制其内容等。默认为false，即不允许被外部操作修改。&lt;/p&gt;
&lt;p&gt;利用这些属性定制BitmapFactory.Options对象，从而灵活地按照自己的需求配置创建的Bitmap对象。&lt;/p&gt;

&lt;p&gt;五、Bitmap的进阶使用&lt;/p&gt;
&lt;p&gt;1、高效地加载大位图&lt;/p&gt;
&lt;p&gt;上面刚说了大位图加载时的OOM问题，解决方式是通过inSample属性创建一个原位图的子采样版本以减低内存。那么这里的采样率inSample值如何选取最好呢？这里我们利用官方推荐的采样率最佳计算方式：基本步骤就是：①获取位图原尺寸 ②获取ImageView即最终图片显示的尺寸  ③依据两种尺寸计算采样率（或缩放比例）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; calculateInSampleSize(
            BitmapFactory.Options options, &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; reqWidth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; reqHeight) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 位图的原宽高通过options对象获取&lt;/span&gt;
    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; height =&lt;span&gt; options.outHeight;
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; width =&lt;span&gt; options.outWidth;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; inSampleSize = 1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (height &amp;gt; reqHeight || width &amp;gt;&lt;span&gt; reqWidth) {

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; halfHeight = height / 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; halfWidth = width / 2&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当要显示的目标大小和图像的实际大小比较接近时，会产生没必要的采样，先除以2再判断以防止过度采样&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; ((halfHeight / inSampleSize) &amp;gt;=&lt;span&gt; reqHeight
                &lt;/span&gt;&amp;amp;&amp;amp; (halfWidth / inSampleSize) &amp;gt;=&lt;span&gt; reqWidth) {
            inSampleSize &lt;/span&gt;*= 2&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inSampleSize;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;依据上面的最佳采样率计算方法，进一步可以封装出利用最佳采样率创建子采样版本再创建位图对象的方法，这里以从项目图片资源文件加载Bitmap对象为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Bitmap decodeSampledBitmapFromResource(Resources res, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; resId,
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; reqWidth, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; reqHeight) {

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; BitmapFactory.Options options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BitmapFactory.Options();
    options.inJustDecodeBounds &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为inJustDecodeBounds为true，所以不会创建Bitmap对象只会扫描轮廓从而给options对象的宽高属性赋值&lt;/span&gt;
&lt;span&gt;    BitmapFactory.decodeResource(res, resId, options);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算最佳采样率&lt;/span&gt;
    options.inSampleSize =&lt;span&gt; calculateInSampleSize(options, reqWidth, reqHeight);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记得将inJustDecodeBounds属性设置回false值&lt;/span&gt;
    options.inJustDecodeBounds = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BitmapFactory.decodeResource(res, resId, options);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、Bitmap加载时的异步问题&lt;/p&gt;
&lt;p&gt;由于图片的来源有三种，如果是项目图片资源文件的加载，一般采取了子采样版本加载方案后不会导致ANR问题，毕竟每张图加载消耗的内存不会很大了。但是对于本地图片文件和网络图片资源，由于分别涉及到文件读取和网络请求，所以属于耗时操作。为了避免ANR的产生，必须将图片加载为Bitmap对象的过程放入工作线程中；获取到Bitmap对象后再回到UI线程设置ImageView的显示。举个例子，如果采用AsyncTask作为我们的异步处理方案，那么代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; BitmapWorkerTask &lt;span&gt;extends&lt;/span&gt; AsyncTask&amp;lt;Integer, Void, Bitmap&amp;gt;&lt;span&gt; {
         &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ImageView iv;
         &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id = 0&lt;span&gt;;
 
         &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BitmapWorkerTask(ImageView imageView) {
             iv &lt;/span&gt;=&lt;span&gt; imageView;
          }
 
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decode image in background.&lt;/span&gt;
&lt;span&gt;         @Override
         &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Bitmap doInBackground(Integer... params) {
             id &lt;/span&gt;= params[0&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设ImageView尺寸为500X500，为了方便还是以项目资源文件的加载方式为例，因为这可以复用上面封装的方法&lt;/span&gt;
             &lt;span&gt;return&lt;/span&gt; decodeSampledBitmapFromResource(getResources(), id, 500, 500&lt;span&gt;);
        }
 
         @Override
         &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onPostExecute(Bitmap bitmap) {
             iv.setImageBitmap(bitmap);
         }
     }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方案中，doInBackground方法执行在子线程，用来处理 ”图片文件读取操作+Bitmap对象的高效加载操作” 或 ”网络请求图片资源操作+Bimap对象的高效加载操作”等两种情形下的耗时操作。onPostExecute方法执行在UI线程，用于设置ImageView的显示内容。看上去这个方案很完美，但是有一个很隐晦的严重问题：&lt;/p&gt;
&lt;p&gt;由当前活动启动了BitmapWorkerTask任务后：当我们退出当前活动时，由于异步任务只依赖于UI线程所以BitmapWorkerTask任务会继续执行。正常的操作是遍历当前活动实例的对象图来释放各对象的内存以销毁该活动，但是由于当前活动实例的ImageView引用被BitmapWorkerTask对象持有，而且还是强引用关系。这会导致Activity实例无法被销毁，引发内存泄露问题。内存泄露问题会进一步导致内存溢出错误。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，我们只需要让BitmapWorkerTask类持有ImageView的弱引用即可。这样当活动退出时，BitmapWorkerTask对象由于持有的是ImageView的弱引用，所以ImageView对象会被回收，继而Activity实例得到销毁，从而避免了内存泄露问题。具体修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; BitmapWorkerTask &lt;span&gt;extends&lt;/span&gt; AsyncTask&amp;lt;Integer, Void, Bitmap&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; WeakReference&amp;lt;ImageView&amp;gt;&lt;span&gt; imageViewReference;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; data = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BitmapWorkerTask(ImageView imageView) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用弱引用来关联这个imageview！弱引用是避免android 在各种callback回调里发生内存泄露的最佳方法！
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;而软引用则是做缓存的最佳方法 两者不要搞混了！&lt;/span&gt;
            imageViewReference = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;ImageView&amp;gt;&lt;span&gt;(imageView);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Decode image in background.&lt;/span&gt;
&lt;span&gt;        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Bitmap doInBackground(Integer... params) {
            data &lt;/span&gt;= params[0&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; decodeSampledBitmapFromResource(getResources(), data, 100, 100&lt;span&gt;);
        }

        @Override
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onPostExecute(Bitmap bitmap) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当后台线程结束后 先看看ImageView对象是否被回收：如果被回收就什么也不做，等着系统回收他的资源
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果ImageView对象没被回收的话，设置其显示内容即可&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (imageViewReference != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; bitmap != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; ImageView imageView =&lt;span&gt; imageViewReference.get();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (imageView != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    imageView.setImageBitmap(bitmap);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;拓展：①WeakReference是弱引用，其中保存的对象实例可以被GC回收掉。这个类通常用于在某处保存对象引用，而又不干扰该对象被GC回收，可以用于避免内存泄露。②SoftReference是软引用，它保存的对象实例，不会被GC轻易回收，除非JVM即将OutOfMemory，否则不会被GC回收。这个特性使得它非常适合用于设计Cache缓存。缓存可以省去重复加载的操作，而且缓存属于内存因此读取数据非常快，所以我们自然不希望缓存内容被GC轻易地回收掉；但是因为缓存本质上就是一种内存资源，所以在内存紧张时我们需要能释放一部分缓存空间来避免OOM错误。综上，软引用非常适合用于设计缓存Cache。但是，这只是早些时候的缓存设计思想，比如在Android2.3版本之前。在Android2.3版本之后，JVM的垃圾收集器开始更积极地回收软引用对象，这使得原本的缓存设计思想失效了。因为如果使用软引用来实现缓存，那么动不动缓存对象就被GC回收掉实在是无法接受。所以，Android2.3之后对于缓存的设计使用的是强引用关系（也就是普通对象引用关系）。很多人会问这样不会由于强引用的缓存对象无法被回收从而导致OOM错误吗？确实会这样，但是我们只需要给缓存设置一个合理的阈值就好了。将缓存大小控制在这个阈值范围内，就不会引发OOM错误了。&lt;/p&gt;

&lt;p&gt;3、列表加载Bitmap时的图片显示错乱问题&lt;/p&gt;
&lt;p&gt; 我们已经知道了如何高效地加载位图以避免OOM错误，还知道了如何合理地利用异步机制来避免Bitmap加载时的ANR问题和内存泄露问题。现在考虑另一种常见的Bitmap加载问题：当我们使用列表，如ListView、GridView和RecyclerView等来加载多个Bitmap时，可能会产生图片显示错乱的问题。先看一下该问题产生的原因。以ListView为例：&lt;/p&gt;
&lt;p&gt;①ListView为了提高列表展示内容在滚动时的流畅性，使用了一种item复用机制，即：在屏幕中显示的每个ListView的item对应的布局只有在第一次的时候被加载，然后缓存在convertView里面，之后滑动改变ListView时调用的getView就会复用缓存在converView中的布局和控件，所以可以使得ListView变得流畅（因为不用重复加载布局）。&lt;/p&gt;
&lt;p&gt;②每个Item中的ImageView加载图片时往往都是异步操作，比如在子线程中进行图片资源的网络请求再加载为一个Bitmap对象最后回到UI线程设置该item的ImageView的显示内容。&lt;/p&gt;
&lt;p&gt;③ 听上去①是一种非常合理有效的提高列表展示流畅性的机制，②看起来也是图片加载时很常见的一个异步操作啊。其实①和②本身都没有问题，但是①+②+用户滑动列表=图片显示错乱！具体而言：当我们在其中一个itemA加载图片A的时候，由于加载过程是异步操作需要耗费一定的时间，那么有可能图片A未被加载完该itemA就“滚出去了”，这个itemA可能被当做缓存应用到另一个列表项itemB中，这个时候刚好图片A加载完成显示在itemB中（因为ImageView对象在缓存中被复用了），原本itemB该显示图片B，现在显示图片A。这只是最简单的一种情况，当滑动频繁时这种图片显示错乱问题会愈加严重，甚至让人毫无头绪。&lt;/p&gt;
&lt;p&gt;那么如何解决这种图片显示错乱问题呢？解决思路其实非常简单：在图片A被加载到ImageView之前做一个判断，判断该ImageView对象是否还是对应的是itemA，如果是则将图片加载到ImageView当中；如果不是则放弃加载（因为itemB已经启动了图片B的加载，所以不用担心控件出现空白的情况）。&lt;/p&gt;
&lt;p&gt;那么新的问题出现了，如何判断ImageView对象对应的item已经改变了？我们可以采取下面的方式：&lt;/p&gt;
&lt;p&gt;①在每次getView的复用布局控件时，对会被复用的控件设置一个标签（在这里就是对ImageView设置标签）。标签内容必须可以标识不同的item！这里使用图片的url作为标签内容，然后再异步加载图片。&lt;/p&gt;
&lt;p&gt;②在图片下载完成后要加载到ImageView之前做判断，判断该ImageView的标签内容是否和图片的url一样：如果一样说明ImageView没有被复用，可以将图片加载到ImageView当中；如果不一样，说明ListView发生了滑动，导致其他item调用了getView从而将该ImageView的标签改变，此时放弃图片的加载（尽管图片已经被下载成功了）。&lt;/p&gt;
&lt;p&gt;总结：解决ListView异步加载Bitmap时的图片错乱问题的方式是：为被复用的控件对象（即ImageView对象）设置标签来标识item，异步任务结束后要将图片加载到ImageView时取出标签值进行比对是否一致：如果一致意味着没有发生滑动，正常加载图片；如果不一样意味着发生了滑动，取消加载。&lt;/p&gt;

&lt;p&gt;4、Android中的Bitmap缓存策略&lt;/p&gt;
&lt;p&gt;如果只是加载若干张图片，上述的Bitmap使用方式已经绝对够用了；但是如果在应用中需要频繁地加载大量的图片，特别是有些图片会被重复加载时，这个时候利用缓存策略可以很好地提高图片的加载速度。比如说有几张图片被重复加载的频率很高，那么可以在缓存中保留这几张图片的Bitmap对象；后续如果需要加载这些图片，则不需要花费很多时间去重新在网络上获取并加载这些图片的Bitmap对象，只需要直接向缓存中获取之前保留下来的Bitmap对象即可。&lt;/p&gt;
&lt;p&gt;Android中对Bitmap的缓存策略分为两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存缓存：图像存储在设备内存中，因此访问速度非常快。事实上，比图像解码过程要快得多，所以将图像存储在这里是让app更快更稳定的一个好主意。内存缓存的唯一缺点是：它只存活于app的生命周期，这意味着一旦app被Android操作系统内存管理器关闭或杀死（全部或部分），那么储存在那里的所有图像都将丢失。由于内存缓存本质上就是一种内存资源，所以切记：内存缓存必须设置一个最大可用的内存量。否则可能会导致臭名昭著的outOfMemoryError。&lt;/li&gt;
&lt;li&gt;磁盘缓存：图像存储在设备的物理存储器上（磁盘）。磁盘缓存本质上就是设备SD卡上的某个目录。只要app不被卸载，其磁盘缓存可以一直安全地存储图片，只要有足够的磁盘空间即可。缺点是，磁盘读取和写入操作可能会很慢，而且总是比访问内存缓存慢。由于这个原因，因此所有的磁盘操作必须在工作线程执行，UI线程之外。否则，app会冻结，并导致ANR警报。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在实际使用中，我们不需要强行二选一，可以二者都使用，毕竟各有优势。所以Android中完整的图片缓存策略为：先尝试在内存缓存中查找Bitmap对象，如果有直接加载使用；如果没有，再尝试在磁盘缓存中查找图片文件是否存在，如果有将其加载至内存使用；如果还是没有，则老老实实发送网络请求获取图片资源并加载使用。需要注意的是，后面两种情况下的操作都必须使用异步机制以避免ANR的发生。&lt;/p&gt;
&lt;p&gt;Android中通过LruCache实现内存缓存，通过DiskLruCache实现磁盘缓存，它们采用的都是LRU(Least Recently Used)最近最少使用算法来移除缓存中的最近不常访问的内容（变相地保留了最近经常访问的内容）。&lt;/p&gt;
&lt;p&gt;①内存缓存LruCache&lt;/p&gt;
&lt;p&gt;LruCache原理：LruCache底层是使用LinkedHashMap来实现的，所以LruCache也是一个泛型类。在图片缓存中，其键类型是字符串，值类型为Bitmap。利用LinkedHashMap的accessOrder属性可以实现LRU算法。accessOrder属性决定了LinkedHashMap的链表顺序：accessOrder为true则以访问顺序维护链表，即被访问过的元素会安排到链表的尾部；accessorder为false则以插入的顺序维护链表。&lt;/p&gt;
&lt;p&gt;而LruCache利用的正是accessOrder为true的LinkedHashMap来实现LRU算法的。具体表现为：&lt;/p&gt;
&lt;div readability=&quot;22&quot;&gt;
&lt;p&gt;1° put：通过LinkedHashMap的put方法来实现元素的插入，插入的过程还是要先寻找有没有相同的key的数据，如果有则替换掉旧值，并且将该节点移到链表的尾部。这可以保证最近经常访问的内容集中保存在链表尾部，最近不常访问的内存集中保存在链表头部位置。在插入后如果缓存大小超过了设定的最大缓存大小（阈值），则将LinkedHashMap头部的节点（最近不常访问的内容）删除，直到size小于maxSize。&lt;/p&gt;
&lt;p&gt;2° get：通过LinkedHashMap的get方法来实现元素的访问，由于accessOrder为true，因此被访问到的元素会被调整到链表的尾部，因此不常被访问的元素就会留到链表的头部，当触发清理缓存时不常被访问的元素就会被删除，这里是实现LRU最关键的地方。&lt;/p&gt;
&lt;p&gt;3° remove：通过LinkedHashMap的remove方法来实现元素的移除。&lt;/p&gt;
&lt;p&gt;3° size：LruCache中很重要的两个成员变量size和maxSize，因为清理缓存的是在size&amp;gt;maxSize时触发的，因此在初始化的时候要传入maxSize定义缓存的大小，然后重写sizeOf方法，因为LruCache是通过sizeOf方法来计算每个元素的大小。这里我们是使用LruCache来缓存图片，所以sizeOf方法需要计算Bitmap的大小并返回。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;LruCache对其缓存对象采用的是强引用关系，采用maxSize来控制缓存空间大小以避免OOM错误。而且LruCache类在Android SDK中已经提供了，在实际使用中我们只需要完成以下几步即可：&lt;/p&gt;
&lt;div readability=&quot;79.600840336134&quot;&gt;
&lt;ul&gt;&lt;li&gt;设计LruCache的最大缓存大小：一般是通过计算当前可用的内存大小继而来获取到应该设置的缓存大小&lt;/li&gt;
&lt;li&gt;创建LruCache对象：传入最大缓存大小的参数，同时重写sizeOf方法来设置存在LruCache里的每个对象的大小&lt;/li&gt;
&lt;li&gt;封装对LruCache的数据访问和添加操作并对外提供接口以供调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码参考如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化LruCache对象&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initLruCache()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前进程的可用内存，转换成KB单位&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; maxMemory = (&lt;span&gt;int&lt;/span&gt;) (Runtime.getRuntime().maxMemory() / 1024&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配缓存的大小&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; maxSize = maxMemory / 8&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建LruCache对象并重写sizeOf方法&lt;/span&gt;
    lruCache = &lt;span&gt;new&lt;/span&gt; LruCache&amp;lt;String, Bitmap&amp;gt;&lt;span&gt;(maxSize)
        {
            @Override
            &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; sizeOf(String key, Bitmap value) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; value.getWidth() * value.getHeight() / 1024&lt;span&gt;;
            }
        };
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 封装将图片存入缓存的方法
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; key 图片的url转化成的key
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bitmap对象
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addBitmapToMemoryCache(String key, Bitmap bitmap)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(getBitmapFromMemoryCache(key) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
        mLruCache.put(key, bitmap);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;封装从LruCache中访问数据的方法&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Bitmap getBitmapFromMemoryCache(String key)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mLruCache.get(key);
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 因为外界一般获取到的是url而不是key，因此为了方便再做一层封装
 * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; url http url
 * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; bitmap
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Bitmap loadBitmapFromMemoryCache(String url)
{
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; String key =&lt;span&gt; hashKeyFromUrl(url);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getBitmapFromMemoryCache(key);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;②磁盘缓存DiskLruCache&lt;/p&gt;
&lt;p&gt;由于DiskLruCache并不属于Android SDK的一部分，需要自行设计。与LruCache实现LRU算法的思路基本上是一致的，但是有很多不一样的地方：LruCache是内存缓存，其键对应的值类型直接为Bitmap；而DiskLruCache是磁盘缓存，所以其键对应的值类型应该是一个代表图片文件的类。其次，前者访问或添加元素时，查找成功可以直接使用该Bitmap对象；后者访问或添加元素时，查找到指定图片文件后还需要通过文件的读取和Bitmap的加载过程才能使用。另外，前者是在内存中的数据读写操作所以不需要异步；后者涉及到文件操作必须开启子线程实现异步处理。&lt;/p&gt;
&lt;p&gt;具体DiskLruCache的设计方案和使用方式可以参考这篇博客：&lt;a href=&quot;https://www.jianshu.com/p/765640fe474a&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/765640fe474a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有了LruCache类和DiskLruCache类，可以实现完整的Android图片二级缓存策略：在具体的图片加载时：先尝试在LruCache中查找Bitmap对象，如果有直接拿来使用。如果没有再尝试在DiskLruCache中查找图片文件，如果有将其加载为Bitmap对象再使用，并将其添加至LruCache中；如果没有查找到指定的图片文件，则发送网络请求获取图片资源并加载为Bitmap对象再使用，并将其添加DiskLruCache中。&lt;/p&gt;

&lt;p&gt;5、Bitmap内存管理&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Android设备的内存包括本机Native内存和Dalvik（类似于JVM虚拟机）堆内存两部分。在Android 2.3.3（API级别10）及更低版本中，位图的支持像素数据存储在Native内存中。&lt;/span&gt;&lt;span&gt;它与位图本身是分开的，Bitmap对象本身存储在Dalvik堆中。&lt;/span&gt;&lt;span&gt;Native内存中的像素数据不会以可预测的方式释放，可能导致应用程序短暂超出其内存限制并崩溃。&lt;/span&gt;&lt;span&gt;从Android 3.0（API级别11）到Android 7.1（API级别25），像素数据与相关Bitmap对象一起存储在Dalvik堆上，一起交由Dalvik虚拟机的垃圾收集器来进行回收，因此比较安全。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①在Android2.3.3版本之前：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Bitmap对象不再使用并希望将其销毁时，Bitmap对象自身由于保存在Dalvik堆中，所以其自身会由GC自动回收；但是由于Bitmap的像素数据保存在native内存中，所以必须由开发者手动调用Bitmap的recycle()方法来回收这些像素数据占用的内存空间。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;②在Android2.3.3版本之后：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于Bitmap对象和其像素数据一起保存在Dalvik堆上，所以在其需要回收时只要将Bitmap引用置为null 就行了，不需要如此麻烦的手动释放内存操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然，一般我们在实际开发中往往向下兼容到Android4.0版本，所以你懂得。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;③在Android&lt;/span&gt;3.0以后的版本，还提供了一个很好用的参数，叫options.inBitmap。如果你使用了这个属性，那么在调用decodeXXXX方法时会直接复用 inBitmap 所引用的那块内存。大家都知道，很多时候ui卡顿是因为gc 操作过多而造成的。使用这个属性能避免频繁的内存的申请和释放。带来的好处就是gc操作的数量减少，这样cpu会有更多的时间执行ui线程，界面会流畅很多，同时还能节省大量内存。简单地说，就是内存空间被各个Bitmap对象复用以避免频繁的内存申请和释放操作。&lt;/p&gt;
&lt;p&gt;需要注意的是，如果要使用这个属性，必须将BitmapFactory.Options的isMutable属性值设置为true，否则无法使用这个属性。&lt;/p&gt;
&lt;p&gt;具体使用方式参考如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; BitmapFactory.Options options = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BitmapFactory.Options();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;size必须为1 否则是使用inBitmap属性会报异常&lt;/span&gt;
        options.inSampleSize = 1&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个属性一定要在用在src Bitmap decode的时候 不然你再使用哪个inBitmap属性去decode时候会在c++层面报异常
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;BitmapFactory: Unable to reuse an immutable bitmap as an image decoder target.&lt;/span&gt;
        options.inMutable = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        inBitmap2 &lt;/span&gt;=&lt;span&gt; BitmapFactory.decodeFile(path1,options);
        iv.setImageBitmap(inBitmap2);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将inBitmap属性代表的引用指向inBitmap2对象所在的内存空间，即可复用这块内存区域&lt;/span&gt;
        options.inBitmap =&lt;span&gt; inBitmap2;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于启用了inBitmap属性，所以后续的Bitmap加载不会申请新的内存空间而是直接复用inBitmap属性值指向的内存空间&lt;/span&gt;
&lt;span&gt;        iv2.setImageBitmap(BitmapFactory.decodeFile(path2,options));
        iv3.setImageBitmap(BitmapFactory.decodeFile(path3,options));
        iv4.setImageBitmap(BitmapFactory.decodeFile(path4,options));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;补充：Android4.4以前，你要使用这个属性，那么要求复用内存空间的Bitmap对象大小必须一样；但是Android4.4 以后只要求后续复用内存空间的Bitmap对象大小比inBitmap指向的内存空间要小就可以使用这个属性了。另外，如果你不同的imageview 使用的scaletype 不同，但是你这些不同的imageview的bitmap在加载是如果都是引用的同一个inBitmap的话，&lt;/p&gt;
&lt;p&gt;这些图片会相互影响。综上，使用inBitmap这个属性的时候 一定要小心小心再小心。&lt;/p&gt;

&lt;p&gt;六、开源框架&lt;/p&gt;
&lt;p&gt;我们现在已经知道了，Android图片加载的知识点和注意事项实在太多了：单个的位图加载我们要考虑Bitmap加载的OOM问题、异步处理问题和内存泄露问题；列表加载位图要考虑显示错乱问题；频繁大量的位图加载时我们要考虑二级缓存策略；我们还有考虑不同版本下的Bitmap内存管理问题，在这部分最后我们介绍了Bitmap内存复用方式，我们需要小心使用这种方式。&lt;/p&gt;
&lt;p&gt;那么，能不能有一种方式让我们省去这么多繁琐的细节，方便我们对图片进行加载呢？答案就是：利用已有的成熟的图片加载和缓存开源框架！比如square公司的Picasso框架、Google公司的Glide框架和Facebook公司的Fresco框架等。特别是Fresco框架，提供了三级缓存策略，非常的专业。根据APP对图片显示和缓存的需求从低到高排序，我们可以采用的方案依次为：Bitmapfun、Picasso、Android-Universal-Image-Loader、Glide、Fresco。&lt;/p&gt;
&lt;p&gt;这些框架可以方便我们实现对网络图片的加载和缓存操作。具体不再赘述。&lt;/p&gt;

&lt;/div&gt;

&lt;/div&gt;</description>
<pubDate>Sat, 15 Jun 2019 15:04:00 +0000</pubDate>
<dc:creator>摇头耶稣</dc:creator>
<og:description>一、背景 在Android开发中，任何一个APP都离不开图片的加载和显示问题。这里的图片来源分为三种：项目图片资源文件（一般为res/drawable目录下的图片文件）、手机本地图片文件、网络图片资源</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shakinghead/p/11025805.html</dc:identifier>
</item>
<item>
<title>nginx中共享内存的使用 - atskyline</title>
<link>http://www.cnblogs.com/atskyline/p/11029068.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atskyline/p/11029068.html</guid>
<description>&lt;p&gt;在nginx的进程模型下，类似流量统计、流量控制、数据共享、等需要多个工作进程共同配合完成任务，共享内存是一个重要的进程通讯的方案。本文介绍在nginx的代码中与共享内存相关的功能，包括ngx_shmem与ngx_slab的使用与注意事项，但不包括ngx_slab中实现的内存管理算法。&lt;/p&gt;

&lt;p&gt;ngx_shmem.c/h文件只是对mmap()/munmap()系统调用或者shmget()/shmdt()的一个很简单的封装。实现了ngx风格的基础库，可以申请和释放一段连续的共享内存空间。一般用于固定长度的共享数据使用，使用过程中数据长度固定不会伸缩。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;typedef struct {
    u_char      *addr;
    size_t       size;
    ...
} ngx_shm_t;
ngx_int_t ngx_shm_alloc(ngx_shm_t *shm);
void ngx_shm_free(ngx_shm_t *shm);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在ngxin中共享内存的使用流程，一般是由master进程创建，worker进程通过继承的方式获得内存指针。&lt;/p&gt;
&lt;p&gt;关于ngx_shmem的使用，可以参考ngx_event_module_init()中部分片段，这部分代码在共享内存中创建了若干个变量，用于记录各个状态(accepted/reading/writing...)的请求数量，并在ngx_event_module中的几个关键事件入口对这几个变量进行加减统计操作。实现统计所有worker进程当前的请求状态。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;shm.size = size;
ngx_str_set(&amp;amp;shm.name, &quot;nginx_shared_zone&quot;);
shm.log = cycle-&amp;gt;log;

if (ngx_shm_alloc(&amp;amp;shm) != NGX_OK) {
    return NGX_ERROR;
}

shared = shm.addr;
...
ngx_stat_accepted = (ngx_atomic_t *) (shared + 3 * cl);
ngx_stat_handled = (ngx_atomic_t *) (shared + 4 * cl);
ngx_stat_requests = (ngx_atomic_t *) (shared + 5 * cl);
ngx_stat_active = (ngx_atomic_t *) (shared + 6 * cl);
ngx_stat_reading = (ngx_atomic_t *) (shared + 7 * cl);
ngx_stat_writing = (ngx_atomic_t *) (shared + 8 * cl);
ngx_stat_waiting = (ngx_atomic_t *) (shared + 9 * cl);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于这个功能的更多细节，可以查看代码中的NGX_STAT_STUB宏定义相关代码与ngx_http_stub_status_module。&lt;/p&gt;

&lt;p&gt;ngx_shmem是一层极简的封装，实现了共享内存的基本功能。但我们程序中大部分的场景共享数据并不会一个固定大小的结构，而更多是像ngx_array、ngx_list、ngx_queue、ngx_rbtree这类大小可以变化的数据结构。&lt;/p&gt;
&lt;p&gt;我们期望能有像ngx_pool_t一样可以动态申请释放空间一个内存池。ngx_slab正是一个这样的结构体，原理上与系统的malloc()有相识之处都是通过一系列算法实现对一段段内存片段的申请与释放。只不过ngx_slab操作的对象是基于ngx_shmem的共享内存。&lt;/p&gt;
&lt;p&gt;先看一下ngx_slab的接口&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;typedef struct {
    ngx_shmtx_t       mutex;
    ...
    void             *data; /* 一般存放从pool中申请获得的根数据地址（pool中第一个申请的数据接口） */
    void             *addr; /* 使用ngx_shmem申请获得的共享内存基地址 */
} ngx_slab_pool_t;

void ngx_slab_init(ngx_slab_pool_t *pool);
void *ngx_slab_alloc(ngx_slab_pool_t *pool, size_t size);
void *ngx_slab_alloc_locked(ngx_slab_pool_t *pool, size_t size);
void *ngx_slab_calloc(ngx_slab_pool_t *pool, size_t size);
void *ngx_slab_calloc_locked(ngx_slab_pool_t *pool, size_t size);
void ngx_slab_free(ngx_slab_pool_t *pool, void *p);
void ngx_slab_free_locked(ngx_slab_pool_t *pool, void *p);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到接口并不复杂，alloc与calloc的区别在于是否对申请获得的内存段清零，_locked结尾的接口表示操作的pool已经是获取到锁的。在ngx_slab_pool_t的结构体有一个ngx_shmtx_t的互斥锁用于同步多进程同时访问pool的并发场景。注意ngx_slab_alloc()会先获取锁、然后申请空间、最后释放锁。而ngx_slab_alloc_locked()则直接申请空间，认为程序已经在其他逻辑中获得锁了。&lt;/p&gt;
&lt;p&gt;在nginx的开发中使用ngx_shmem一般需要遵循以下初始化流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模块在配置解析过程中调用ngx_shared_memory_add()接口，注册一段共享内存。提供共享内存大小与内存初始化的回调函数。&lt;/li&gt;
&lt;li&gt;框架在ngx_init_cycle()中使用ngx_shmem申请内存，并初始化ngx_slab，然后回调模块注册的初始化函数&lt;/li&gt;
&lt;li&gt;模块使用ngx_slab的申请/是否接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这个流程中，涉及到ngx_shared_memory_add()接口与对应的ngx_shm_zone_t结构体。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct ngx_shm_zone_s {
    void                     *data;
    ngx_shm_t                 shm;
    ngx_shm_zone_init_pt      init;
    void                     *tag;
    void                     *sync;
    ngx_uint_t                noreuse;  /* unsigned  noreuse:1; */
};
ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf, ngx_str_t *name,
    size_t size, void *tag);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中值得一提的是noreuse属性，这个属性控制了在nginx的reload过程中是否会重新申请共享内存。&lt;/p&gt;
&lt;p&gt;由于关于ngx_init_cycle()函数较长，这个流程可以通过查找/* create shared memory */这个注释或者cycle-&amp;gt;shared_memory这个对象查看相关代码。&lt;/p&gt;
&lt;p&gt;关于ngx_slab更多细节的使用，建议可以参考ngx_http_limit_conn_module，这是通过共享内存实现连接数限制的模块，模块复杂度底，是一个很好的参考范例。&lt;/p&gt;

&lt;p&gt;同时安利一波《深入理解Nginx》作者 陶辉 在极客时间出版的《Nginx核心知识100讲》，近期618似乎有打折活动，通过我分享的链接进行购买，我也将获得部分返现，感谢支持。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/271120/201906/271120-20190615221247740-236102145.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 15 Jun 2019 14:14:00 +0000</pubDate>
<dc:creator>atskyline</dc:creator>
<og:description>在nginx的进程模型下，类似流量统计、流量控制、数据共享、等需要多个工作进程共同配合完成任务，共享内存是一个重要的进程通讯的方案。本文介绍在nginx的代码中与共享内存相关的功能，包括ngx_shm</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/atskyline/p/11029068.html</dc:identifier>
</item>
<item>
<title>sql server编写通用脚本自动检查两个不同服务器的新旧数据库的表结构差异 - 张工502219048</title>
<link>http://www.cnblogs.com/zhang502219048/p/11028767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhang502219048/p/11028767.html</guid>
<description>&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;br/&gt;工作过程中，不管是什么项目，伴随着项目不断升级版本，对应的项目数据库业务版本也不断升级，数据库出现新增表、修改表、删除表、新增字段、修改字段、删除字段等变化，如果人工检查，数据库表和字段比较多的话，工作量就非常大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;br/&gt;这里博主为大家分享一个在工作过程中编写的自动检查数据库表结构版本差异的通用脚本，&lt;span&gt;只需要把新旧数据库名称批量替换成实际的名称&lt;/span&gt;就可以，支持通过链接服务器跨服务器检查不同服务器的两个数据库表结构差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脚本：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    使用说明：Old数据库为DB_V1，New数据库为[localhost].DB_V2。根据实际需要批量替换数据库名称
    脚本来源：https://www.cnblogs.com/zhang502219048/p/11028767.html
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;--&lt;/span&gt;&lt;span&gt; sysobjects插入临时表&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; s.name &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; t.name &lt;span&gt;as&lt;/span&gt; TableName, t.&lt;span&gt;*&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;&lt;span&gt; #tempTA 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; DB_V1.sys.tables t
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; DB_V1.sys.schemas s &lt;span&gt;on&lt;/span&gt; s.schema_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; t.schema_id

&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; s.name &lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; t.name &lt;span&gt;as&lt;/span&gt; TableName, t.&lt;span&gt;*&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;&lt;span&gt; #tempTB 
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.DB_V2.sys.tables t
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;.DB_V2.sys.schemas s &lt;span&gt;on&lt;/span&gt; s.schema_id &lt;span&gt;=&lt;/span&gt;&lt;span&gt; t.schema_id

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; syscolumns插入临时表&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; #tempCA &lt;span&gt;from&lt;/span&gt;&lt;span&gt; DB_V1.dbo.syscolumns 
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; #tempCB &lt;span&gt;from&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;.DB_V2.dbo.syscolumns

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 第一个数据库表和字段 &lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; b.TableName &lt;span&gt;as&lt;/span&gt; 表名, a.name &lt;span&gt;as&lt;/span&gt; 字段名, a.length &lt;span&gt;as&lt;/span&gt; 长度, c.name &lt;span&gt;as&lt;/span&gt;&lt;span&gt; 类型
&lt;/span&gt;&lt;span&gt;into&lt;/span&gt;&lt;span&gt; #tempA
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; #tempCA a
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; #tempTA b &lt;span&gt;on&lt;/span&gt; b.&lt;span&gt;object_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; a.id
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; systypes c &lt;span&gt;on&lt;/span&gt; c.xusertype &lt;span&gt;=&lt;/span&gt;&lt;span&gt; a.xusertype
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; b.name 
&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt; 第二个数据库表和字段 &lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; b.TableName &lt;span&gt;as&lt;/span&gt; 表名, a.name &lt;span&gt;as&lt;/span&gt; 字段名, a.length &lt;span&gt;as&lt;/span&gt; 长度, c.name &lt;span&gt;as&lt;/span&gt;&lt;span&gt; 类型
&lt;/span&gt;&lt;span&gt;into&lt;/span&gt;&lt;span&gt; #tempB
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; #tempCB a
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; #tempTB b &lt;span&gt;on&lt;/span&gt; b.&lt;span&gt;object_id&lt;/span&gt; &lt;span&gt;=&lt;/span&gt;&lt;span&gt; a.id
&lt;/span&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; systypes c &lt;span&gt;on&lt;/span&gt; c.xusertype &lt;span&gt;=&lt;/span&gt;&lt;span&gt; a.xusertype
&lt;/span&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt;&lt;span&gt; b.name

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;删掉的字段&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt;    
( 
    &lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; #tempA
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;
    &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; #tempB
) a;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;增加的字段&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt;    
( 
    &lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; #tempB
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;
    &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; #tempA
) a;

&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;select * from #tempA&lt;/span&gt;&lt;span&gt;
--&lt;/span&gt;&lt;span&gt;select * from #tempB&lt;/span&gt;

&lt;span&gt;drop&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; #tempTA, #tempTB, #tempCA, #tempCB, #tempA, #tempB
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;示例旧数据库DB_V1：&lt;br/&gt;&lt;/strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1703141/201906/1703141-20190615203228961-840775818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例新数据库DB_V2：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1703141/201906/1703141-20190615203305147-668282207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;脚本运行结果：&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1703141/201906/1703141-20190615203357483-611951059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;br/&gt;&lt;/strong&gt;从上面几个图可以看到，表和字段的差异部分就被自动检测到了。&lt;/p&gt;
&lt;p&gt;【转载请注明博文来源：&lt;a href=&quot;https://www.cnblogs.com/zhang502219048/p/11028767.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zhang502219048/p/11028767.html&lt;/a&gt;】&lt;/p&gt;
</description>
<pubDate>Sat, 15 Jun 2019 12:39:00 +0000</pubDate>
<dc:creator>张工502219048</dc:creator>
<og:description>问题：工作过程中，不管是什么项目，伴随着项目不断升级版本，对应的项目数据库业务版本也不断升级，数据库出现新增表、修改表、删除表、新增字段、修改字段、删除字段等变化，如果人工检查，数据库表和字段比较多的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhang502219048/p/11028767.html</dc:identifier>
</item>
<item>
<title>MyBatis 源码分析 - 当年明月123</title>
<link>http://www.cnblogs.com/paulwang92115/p/11028715.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/paulwang92115/p/11028715.html</guid>
<description>&lt;h3 id=&quot;mybatis-运行过程&quot;&gt;MyBatis 运行过程&lt;/h3&gt;
&lt;p&gt;传统的 JDBC 编程查询数据库的代码和过程总结。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加载驱动。&lt;/li&gt;
&lt;li&gt;创建连接，Connection 对象。&lt;/li&gt;
&lt;li&gt;根据 Connection 创建 Statement 或者 PreparedStatement 来执行 sql 语句。&lt;/li&gt;
&lt;li&gt;返回结果集到 ResultSet 中。&lt;/li&gt;
&lt;li&gt;手动将 ResultSet 映射到 JavaBean 中。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        public static void main(String[] args) {
            //声明Connection对象
            Connection con = null;
            //遍历查询结果集
            try {
                //加载驱动程序
                Class.forName(&quot;com.mysql.jdbc.Driver&quot;);
                //创建 connection 对象
                con = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/db&quot;,&quot;username&quot;,&quot;password&quot;);

                //使用 connection 对象创建statement 或者 PreparedStatement 类对象，用来执行SQL语句
                Statement statement = con.createStatement();
                //要执行的SQL语句
                String sql = &quot;select * from emp&quot;;
                //3.ResultSet类，用来存放获取的结果集！！
                ResultSet rs = statement.executeQuery(sql);
   
                String job = &quot;&quot;;
                String id = &quot;&quot;;
                while(rs.next()){
                    //获取stuname这列数据
                    job = rs.getString(&quot;job&quot;);
                    //获取stuid这列数据
                    id = rs.getString(&quot;ename&quot;);

                    //输出结果
                    System.out.println(id + &quot;\t&quot; + job);
                }
            } catch(ClassNotFoundException e) {
                e.printStackTrace();
            } catch(SQLException e) {
                //数据库连接失败异常处理
                e.printStackTrace();
            }catch (Exception e) {
                e.printStackTrace();
            }finally{
                rs.close();
                con.close();
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编码方式实现 MyBatis 查询数据库，方便大家理解，不使用 SpringMybatis，加入 Spring 后整体流程会复杂很多。使用 MyBatis 后能将原来的传统的 JDBC 编程编的如此简单。具体流程总结。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用配置文件构建 SqlSessionFactory。&lt;/li&gt;
&lt;li&gt;使用 SqlSessionFactory 获得 SqlSession，SqlSession 相当于传统 JDBC 的 Conection。&lt;/li&gt;
&lt;li&gt;使用 SqlSession 得到 Mapper。&lt;/li&gt;
&lt;li&gt;用 Mapper 来执行 sql 语句，并返回结果直接封装到 JavaBean 中。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//获取 sqlSession，sqlSession 相当于传统 JDBC 的 Conection
public static SqlSession getSqlSession(){
        InputStream configFile = new FileInputStream(filePath);
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder.build(configFile);
    return sqlSessionFactory.openSession();
}

//使用 sqlSession 获得对应的 mapper，mapper 用来执行 sql 语句。
public static User get(SqlSession sqlSession, int id){
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    return userMapper.selectByPrimaryKey(id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/15/16b5af6a6614ccea?w=796&amp;amp;h=422&amp;amp;f=png&amp;amp;s=32535&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;mybatis-源码分析&quot;&gt;MyBatis 源码分析&lt;/h3&gt;
&lt;p&gt;下面来具体分析 MyBatis 代码的执行过程**&lt;/p&gt;
&lt;p&gt;整体架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/15/16b5af70f47fa37f?w=866&amp;amp;h=720&amp;amp;f=png&amp;amp;s=19802&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先说一下大部分框架的代码流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/15/16b5af7706ce94e8?w=515&amp;amp;h=454&amp;amp;f=png&amp;amp;s=15407&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看我们的配置文件。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;environments default=&quot;development&quot;&amp;gt;
    &amp;lt;environment id=&quot;development&quot;&amp;gt;
        &amp;lt;transactionManager type=&quot;JDBC&quot;&amp;gt;
        &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
          &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
          &amp;lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db&quot;/&amp;gt;
          &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
          &amp;lt;property name=&quot;password&quot; value=&quot;123456&quot;/&amp;gt;
        &amp;lt;/dataSource&amp;gt;
      &amp;lt;/transactionManager&amp;gt;
    &amp;lt;/environment&amp;gt;
  &amp;lt;/environments&amp;gt;
&amp;lt;/configuration&amp;gt;
&amp;lt;mappers&amp;gt;
  &amp;lt;mapper resource=&quot;xml/UserMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static SqlSession getSqlSession(){
    //读取上面的配置文件
        InputStream configFile = new FileInputStream(filePath);
    //根据上面配置的 dataSource 配置 SqlSessionFactory，并且建立 Mapper 接口和 xml 之间的关系。
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder.build(configFile);
    //工厂方法返回一个 sqlSession
    return sqlSessionFactory.openSession();
}

//我们来重点看看 openSession 做了什么操作, DefaultSqlSessionFactory.java
@Override
public SqlSession openSession() {
  return this.openSessionFromDataSource(this.configuration.getDefaultExecutorType(), (TransactionIsolationLevel)null, false);
}

public Configuration getConfiguration() {
  return this.configuration;
}
//这个函数里面有着事务控制相关的代码。
private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {
  Transaction tx = null;

  DefaultSqlSession var8;
  try {
    Environment environment = this.configuration.getEnvironment();
    TransactionFactory transactionFactory = this.getTransactionFactoryFromEnvironment(environment);
    //根据上面的参数得到 TransactionFactory，通过 TransactionFactory 生成一个 Transaction，可以理解为这个 SqlSession 的事务控制器
    tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);
    // 将这个事务控制器封装在 Executor 里
    Executor executor = this.configuration.newExecutor(tx, execType);
    // 使用 configuration 配置类，Executor，和 configuration(是否自动提交) 来构建一个 DefaultSqlSession。
    var8 = new DefaultSqlSession(this.configuration, executor, autoCommit);
  } catch (Exception var12) {
    this.closeTransaction(tx);
    throw ExceptionFactory.wrapException(&quot;Error opening session.  Cause: &quot; + var12, var12);
  } finally {
    ErrorContext.instance().reset();
  }

  return var8;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SqlSession 的实现流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/15/16b5af7d534916be?w=583&amp;amp;h=442&amp;amp;f=png&amp;amp;s=16160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SqlSession 的接口定义：里面定义了增删改查和提交回滚等方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface SqlSession extends Closeable {
    &amp;lt;T&amp;gt; T selectOne(String var1);

    &amp;lt;T&amp;gt; T selectOne(String var1, Object var2);

    &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String var1);

    &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String var1, Object var2);

    &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String var1, Object var2, RowBounds var3);

    &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; selectMap(String var1, String var2);

    &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; selectMap(String var1, Object var2, String var3);

    &amp;lt;K, V&amp;gt; Map&amp;lt;K, V&amp;gt; selectMap(String var1, Object var2, String var3, RowBounds var4);

    &amp;lt;T&amp;gt; Cursor&amp;lt;T&amp;gt; selectCursor(String var1);

    &amp;lt;T&amp;gt; Cursor&amp;lt;T&amp;gt; selectCursor(String var1, Object var2);

    &amp;lt;T&amp;gt; Cursor&amp;lt;T&amp;gt; selectCursor(String var1, Object var2, RowBounds var3);

    void select(String var1, Object var2, ResultHandler var3);

    void select(String var1, ResultHandler var2);

    void select(String var1, Object var2, RowBounds var3, ResultHandler var4);

    int insert(String var1);

    int insert(String var1, Object var2);

    int update(String var1);

    int update(String var1, Object var2);

    int delete(String var1);

    int delete(String var1, Object var2);

    void commit();

    void commit(boolean var1);

    void rollback();

    void rollback(boolean var1);

    List&amp;lt;BatchResult&amp;gt; flushStatements();

    void close();

    void clearCache();

    Configuration getConfiguration();

    &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; var1);

    Connection getConnection();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来用 sqlSession 获取对应的 Mapper：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//使用 sqlSession 获得对应的 mapper，mapper 用来执行 sql 语句。
public static User get(SqlSession sqlSession, int id){
    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    return userMapper.selectByPrimaryKey(id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DefaultSqlSession 的 getMapper 实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type) {
  return this.configuration.getMapper(type, this);
}

//从 configuration 里面 getMapper，Mapper 就在 Configuration 里
public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type, SqlSession sqlSession) {
  return this.mapperRegistry.getMapper(type, sqlSession);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MapperRegistry 里 getMapper 的最终实现：&lt;/p&gt;
&lt;p&gt;这里就要说明一下，我们的接口里面只定义了抽象的增删改查，而这个接口并没有任何实现类，那么这个 xml 到底是如何与接口关联起来并生成实现类那？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MapperRegistry {
    private final Configuration config;
    // 用一个 Map 来存储接口和 xml 文件之间的映射关系，key 应该是接口，但是 value 是 MapperProxyFactory
    private final Map&amp;lt;Class&amp;lt;?&amp;gt;, MapperProxyFactory&amp;lt;?&amp;gt;&amp;gt; knownMappers = new HashMap();

    public MapperRegistry(Configuration config) {
        this.config = config;
    }

    public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type, SqlSession sqlSession) {
      //获取到这个接口对应的 MapperProxyFactory。
        MapperProxyFactory&amp;lt;T&amp;gt; mapperProxyFactory = (MapperProxyFactory)this.knownMappers.get(type);
        if (mapperProxyFactory == null) {
            throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);
        } else {
            try {
                //用上一步获取的 MapperProxyFactory 和 sqlSession 构建对应的 Class
                return mapperProxyFactory.newInstance(sqlSession);
            } catch (Exception var5) {
                throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + var5, var5);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们看看 newInstance 的具体实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public T newInstance(SqlSession sqlSession) {
  // mapperInterface 就是接口
  MapperProxy&amp;lt;T&amp;gt; mapperProxy = new MapperProxy(sqlSession, this.mapperInterface, this.methodCache);
  return this.newInstance(mapperProxy);
}

protected T newInstance(MapperProxy&amp;lt;T&amp;gt; mapperProxy) {
  //动态代理，这里的动态代理有一些不一样
  return Proxy.newProxyInstance(this.mapperInterface.getClassLoader(), new Class[]{this.mapperInterface}, mapperProxy);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常流程的动态代理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/15/16b5af89a5c31f0f?w=502&amp;amp;h=332&amp;amp;f=png&amp;amp;s=12301&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与传统的动态代理相比，MyBatis 的接口是没有实现类的，那么它又是怎么实现动态代理的那？&lt;/p&gt;
&lt;p&gt;我们来看一下 MapperProxy 的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MapperProxy&amp;lt;T&amp;gt; implements InvocationHandler, Serializable {
    private static final long serialVersionUID = -6424540398559729838L;
    private final SqlSession sqlSession;
    private final Class&amp;lt;T&amp;gt; mapperInterface;
    private final Map&amp;lt;Method, MapperMethod&amp;gt; methodCache;

    public MapperProxy(SqlSession sqlSession, Class&amp;lt;T&amp;gt; mapperInterface, Map&amp;lt;Method, MapperMethod&amp;gt; methodCache) {
        this.sqlSession = sqlSession;
        this.mapperInterface = mapperInterface;
        this.methodCache = methodCache;
    }
        // 正常的动态代理中 Object proxy 这个参数应该是接口的实现类
    // com.paul.pkg.UserMapper@5a123uf
    // 现在里面是 org.apache.ibatis.binding.MapperProxy@6y213kn, 这俩面
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        try {
            if (Object.class.equals(method.getDeclaringClass())) {
                return method.invoke(this, args);
            }

            if (this.isDefaultMethod(method)) {
                return this.invokeDefaultMethod(proxy, method, args);
            }
        } catch (Throwable var5) {
            throw ExceptionUtil.unwrapThrowable(var5);
        }
        // Mapper 走这个流程，先尝试在缓存里获取 method
        MapperMethod mapperMethod = this.cachedMapperMethod(method);
        return mapperMethod.execute(this.sqlSession, args);
    }

    private MapperMethod cachedMapperMethod(Method method) {
        MapperMethod mapperMethod = (MapperMethod)this.methodCache.get(method);
        if (mapperMethod == null) {
            // mapperMethod 的构建，通过接口名，方法，和 xml 配置（通过 sqlSession 的 Configuration 获得）
            mapperMethod = new MapperMethod(this.mapperInterface, method, this.sqlSession.getConfiguration());
          //通过 execute 执行方法，因为 sqlSession 封装了 Executor，所以还要传进来，execute 方法使用
          //sqlSession 里面的方法。
            this.methodCache.put(method, mapperMethod);
        }

        return mapperMethod;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看 MapperMethod 的定义：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// command 里面包含了方法名，比如 com.paul.pkg.selectByPrimaryKey
// type, 表示是 SELECT，UPDATE，INSERT，或者 DELETE
// method 是方法的签名
public class MapperMethod {
    private final MapperMethod.SqlCommand command;
    private final MapperMethod.MethodSignature method;

    public MapperMethod(Class&amp;lt;?&amp;gt; mapperInterface, Method method, Configuration config) {
        this.command = new MapperMethod.SqlCommand(config, mapperInterface, method);
        this.method = new MapperMethod.MethodSignature(config, mapperInterface, method);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入 DefaultSqlSession 执行对应的 sql 语句：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public &amp;lt;T&amp;gt; T selectOne(String statement, Object parameter) {
  List&amp;lt;T&amp;gt; list = this.selectList(statement, parameter);
  if (list.size() == 1) {
    return list.get(0);
  } else if (list.size() &amp;gt; 1) {
    throw new TooManyResultsException(&quot;Expected one result (or null) to be returned by selectOne(), but found: &quot; + list.size());
  } else {
    return null;
  }
}

public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; selectList(String statement, Object parameter, RowBounds rowBounds) {
  List var5;
  try {
    // 这里又需要 configuration 来获取对应的 statement
    // MappedStatement 里面有 xml 文件，和要执行的方法，就是 xml 里面的 id，statementType，以及 sql 语句。
    MappedStatement ms = this.configuration.getMappedStatement(statement);
    // 用 executor 执行 query，executor 里面应该是包装了 JDBC。
    var5 = this.executor.query(ms, this.wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);
  } catch (Exception var9) {
    throw ExceptionFactory.wrapException(&quot;Error querying database.  Cause: &quot; + var9, var9);
  } finally {
    ErrorContext.instance().reset();
  }

  return var5;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Executor 的实现类里面执行 query 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException {
  BoundSql boundSql = ms.getBoundSql(parameterObject);
  CacheKey key = this.createCacheKey(ms, parameterObject, rowBounds, boundSql);
  return this.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}
public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
  Cache cache = ms.getCache();
  if (cache != null) {
    this.flushCacheIfRequired(ms);
    if (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == null) {
      this.ensureNoOutParams(ms, boundSql);
      List&amp;lt;E&amp;gt; list = (List)this.tcm.getObject(cache, key);
      if (list == null) {
        list = this.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
        this.tcm.putObject(cache, key, list);
      }

      return list;
    }
  }
  // 使用 delegate 去 query，delegate 是 SimpleExecutor。里面使用 JDBC 进行数据库操作。
  return this.delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;手动实现一个简单的-mybatis&quot;&gt;手动实现一个简单的 MyBatis&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/15/16b5af919c30d430?w=813&amp;amp;h=454&amp;amp;f=png&amp;amp;s=16522&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建 SqlSessionFactory 实例。&lt;/li&gt;
&lt;li&gt;实例化过程，加载配置文件创建 Configuration 对象。&lt;/li&gt;
&lt;li&gt;通过 factory 创建 SqlSession。&lt;/li&gt;
&lt;li&gt;通过 SqlSession 获取 mapper 接口动态代理。&lt;/li&gt;
&lt;li&gt;动态代理回调 SqlSession 中某查询方法。&lt;/li&gt;
&lt;li&gt;SqlSession 将查询方法转发给 Executor。&lt;/li&gt;
&lt;li&gt;Executor 基于 JDBC 访问数据库获取数据。&lt;/li&gt;
&lt;li&gt;Executor 通过反射将数据转换成 POJO并返回给 SqlSession。&lt;/li&gt;
&lt;li&gt;将数据返回给调用者。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;项目整体使用 Maven 构建，mybatis-demo 是脱离 Spring 的 MyBatis 使用的例子。paul-mybatis 是我们自己实现的 mybatis 框架。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/6/15/16b5afb9e8fc79de?w=688&amp;amp;h=1208&amp;amp;f=png&amp;amp;s=133402&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;49.5&quot;&gt;&lt;li readability=&quot;21&quot;&gt;
&lt;p&gt;首先按照我们以前的使用 mybatis 代码时的流程，创建 mapper 接口，xml 文件，和 POJO以及集一些配置文件。&lt;/p&gt;
&lt;p&gt;接口：TUserMapper&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  package com.paul.mybatis.mapper;

  import com.paul.mybatis.entity.TUser;

  import java.util.List;

  public interface TUserMapper {

      TUser selectByPrimaryKey(Integer id);

      List&amp;lt;TUser&amp;gt; selectAll();
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;xml 文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
  &amp;lt;!DOCTYPE mapper
          PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
          &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
  &amp;lt;mapper namespace=&quot;com.paul.mybatis.mapper.TUserMapper&quot;&amp;gt;

      &amp;lt;select id=&quot;selectByPrimaryKey&quot; resultType=&quot;TUser&quot;&amp;gt;
          select *
          from t_user
          where id = #{id,jdbcType=INTEGER}
      &amp;lt;/select&amp;gt;

      &amp;lt;select id=&quot;selectAll&quot; resultType=&quot;TUser&quot;&amp;gt;
          select *
          from t_user
      &amp;lt;/select&amp;gt;

  &amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实体类，属性应该与数据库想匹配&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  package com.paul.mybatis.entity;

  public class TUser {

  private Integer id;

  private String userName;

  private String realName;

  private Byte sex;

  private String mobile;

  public Integer getId() {
      return id;
  }

  public void setId(Integer id) {
      this.id = id;
  }

  public String getUserName() {
      return userName;
  }

  public void setUserName(String userName) {
      this.userName = userName;
  }

  public String getRealName() {
      return realName;
  }

  public void setRealName(String realName) {
      this.realName = realName;
  }

  public Byte getSex() {
      return sex;
  }

  public void setSex(Byte sex) {
      this.sex = sex;
  }

  public String getMobile() {
      return mobile;
  }

  public void setMobile(String mobile) {
      this.mobile = mobile;
  }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库连接配置文件，db.properties&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  jdbc.driver=com.mysql.jdbc.Driver
  jdbc.url=jdbc:mysql://localhost:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf8
  jdbc.username=root
  jdbc.password=root&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;下面我们来关注 xml 文件，mapper 文件里的 namespace，id，resultType 和 sql 语句都要存储起来，我们定义一个 POJO 来存储这些信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  package com.paul.mybatis.confiuration;


  /**
  *
  * XML 中的 sql 配置信息加载到这个类中
  *
  */
  public class MappedStatement {

  private String namespace;

  private String id;

  private String resultType;

  private String sql;

  public String getNamespace() {
      return namespace;
  }

  public void setNamespace(String namespace) {
      this.namespace = namespace;
  }

  public String getId() {
      return id;
  }

  public void setId(String id) {
      this.id = id;
  }

  public String getResultType() {
      return resultType;
  }

  public void setResultType(String resultType) {
      this.resultType = resultType;
  }

  public String getSql() {
      return sql;
  }

  public void setSql(String sql) {
      this.sql = sql;
  }
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;下面来创建一个 Configuration 类，用来保存所有配置文件和 xml 文件里的信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  package com.paul.mybatis.confiuration;

  import java.util.HashMap;
  import java.util.List;
  import java.util.Map;

  /**
  *
  * 所有的配置信息
  *
  */
  public class Configuration {

  private String jdbcDriver;

  private String jdbcUrl;

  private String jdbcPassword;

  private String jdbcUsername;

  private Map&amp;lt;String,MappedStatement&amp;gt; mappedStatement = new HashMap&amp;lt;&amp;gt;();

  public Map&amp;lt;String, MappedStatement&amp;gt; getMappedStatement() {
      return mappedStatement;
  }

  public void setMappedStatement(Map&amp;lt;String, MappedStatement&amp;gt; mappedStatement) {
      this.mappedStatement = mappedStatement;
  }

  public String getJdbcDriver() {
      return jdbcDriver;
  }

  public void setJdbcDriver(String jdbcDriver) {
      this.jdbcDriver = jdbcDriver;
  }

  public String getJdbcUrl() {
      return jdbcUrl;
  }

  public void setJdbcUrl(String jdbcUrl) {
      this.jdbcUrl = jdbcUrl;
  }

  public String getJdbcPassword() {
      return jdbcPassword;
  }

  public void setJdbcPassword(String jdbcPassword) {
      this.jdbcPassword = jdbcPassword;
  }

  public String getJdbcUsername() {
      return jdbcUsername;
  }

  public void setJdbcUsername(String jdbcUsername) {
      this.jdbcUsername = jdbcUsername;
  }
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;有了配置类之后，我们可以通过这个配置类构建一个 SqlSessionFactory 了。&lt;br/&gt;SqlSessionFactory 抽象模版&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  package com.paul.mybatis.factory;

  import com.paul.mybatis.sqlsession.SqlSession;

  public interface SqlSessionFactory {

      SqlSession openSession();
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Default 实现类主要完成了两个功能，加载配置信息到 Configuration 对象里，实现创建 SqlSession 的功能。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  package com.paul.mybatis.factory;

  import com.paul.mybatis.confiuration.Configuration;
  import com.paul.mybatis.confiuration.MappedStatement;
  import com.paul.mybatis.sqlsession.DefaultSqlSession;
  import com.paul.mybatis.sqlsession.SqlSession;
  import org.dom4j.Document;
  import org.dom4j.DocumentException;
  import org.dom4j.Element;
  import org.dom4j.io.SAXReader;

  import java.io.File;
  import java.io.IOException;
  import java.io.InputStream;
  import java.net.URL;
  import java.util.ArrayList;
  import java.util.List;
  import java.util.Properties;

  /**
   *
   * 1.初始化时就完成了 configuration 的实例化
   * 2.工厂类，生成 sqlSession
   *
   */
  public class DefaultSqlSessionFactory implements SqlSessionFactory{

      //希望Configuration 是单例子并且唯一的
      private final Configuration configuration = new Configuration();

      // xml 文件存放的位置
      private static final String MAPPER_CONFIG_LOCATION = &quot;mappers&quot;;

      // 数据库信息存放的位置
      private static final String DB_CONFIG_FILE = &quot;db.properties&quot;;


      public DefaultSqlSessionFactory() {
          loadDBInfo();
          loadMapperInfo();
      }

      private void loadDBInfo() {
          InputStream db = this.getClass().getClassLoader().getResourceAsStream(DB_CONFIG_FILE);
          Properties p = new Properties();

          try {
              p.load(db);
          } catch (IOException e) {
              e.printStackTrace();
          }
          //将配置信息写入Configuration 对象
          configuration.setJdbcDriver(p.get(&quot;jdbc.driver&quot;).toString());
          configuration.setJdbcUrl(p.get(&quot;jdbc.url&quot;).toString());
          configuration.setJdbcUsername(p.get(&quot;jdbc.username&quot;).toString());
          configuration.setJdbcPassword(p.get(&quot;jdbc.password&quot;).toString());

      }

      //解析并加载xml文件
      private void loadMapperInfo(){
          URL resources = null;
          resources = this.getClass().getClassLoader().getResource(MAPPER_CONFIG_LOCATION);
          File mappers = new File(resources.getFile());
          //读取文件夹下面的文件信息
          if(mappers.isDirectory()){
              File[] files = mappers.listFiles();
              for(File file:files){
                  loadMapperInfo(file);
              }
          }
      }

      private void loadMapperInfo(File file){
          SAXReader reader = new SAXReader();
          //通过read方法读取一个文件转换成Document 对象
          Document document = null;
          try {
              document = reader.read(file);
          } catch (DocumentException e) {
              e.printStackTrace();
          }
          //获取根结点元素对象&amp;lt;mapper&amp;gt;
          Element e = document.getRootElement();
          //获取命名空间namespace
          String namespace = e.attribute(&quot;namespace&quot;).getData().toString();
          //获取select,insert,update,delete子节点列表
          List&amp;lt;Element&amp;gt; selects = e.elements(&quot;select&quot;);
          List&amp;lt;Element&amp;gt; inserts = e.elements(&quot;select&quot;);
          List&amp;lt;Element&amp;gt; updates = e.elements(&quot;select&quot;);
          List&amp;lt;Element&amp;gt; deletes = e.elements(&quot;select&quot;);

          List&amp;lt;Element&amp;gt; all = new ArrayList&amp;lt;&amp;gt;();
          all.addAll(selects);
          all.addAll(inserts);
          all.addAll(updates);
          all.addAll(deletes);

          //遍历节点，组装成 MappedStatement 然后放入到configuration 对象中
          for(Element ele:all){
              MappedStatement mappedStatement = new MappedStatement();
              String id = ele.attribute(&quot;id&quot;).getData().toString();
              String resultType = ele.attribute(&quot;resultType&quot;).getData().toString();
              String sql = ele.getData().toString();

              mappedStatement.setId(namespace+&quot;.&quot;+id);
              mappedStatement.setResultType(resultType);
              mappedStatement.setNamespace(namespace);
              mappedStatement.setSql(sql);

              configuration.getMappedStatement().put(namespace+&quot;.&quot;+id,mappedStatement);
          }
      }

      @Override
      public SqlSession openSession() {
          return new DefaultSqlSession(configuration);
      }
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;23&quot;&gt;
&lt;p&gt;在 SqlSessionFactory 里创建了 DefaultSqlSession，我们看看它的具体实现。SqlSession里面应该封装了所有数据库的具体操作和一些获取 mapper 实现类的方法。使用动态代理生成一个加强类。这里面最终还是把数据库的相关操作转给 SqlSession，使用 mapper 能使编程更加优雅。&lt;br/&gt;SqlSession 接口，定义模版方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  package com.paul.mybatis.sqlsession;

  import java.util.List;

  /**
   *
   * 封装了所有数据库的操作
   * 所有功能都是基于 Excutor 来实现的，Executor 封装了 JDBC 操作
   *
   *
   */
  public interface SqlSession {

      /**
       * 根据传入的条件查询单一结果
       * @param statement  方法对应 sql 语句，namespace+id
       * @param parameter  要传入 sql 语句中的查询参数
       * @param &amp;lt;T&amp;gt; 返回指定的结果对象
       * @return
       */
      &amp;lt;T&amp;gt; T selectOne(String statement, Object parameter);

      &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; selectList(String statement, Object parameter);

      &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Default 的 SqlSession 实现类。里面需要传入 Executor，这个 Executor 里面封装了 JDBC 操作数据库的流程。我们重点关注 getMapper 方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  package com.paul.mybatis.sqlsession;

  import com.paul.mybatis.bind.MapperProxy;
  import com.paul.mybatis.confiuration.Configuration;
  import com.paul.mybatis.confiuration.MappedStatement;
  import com.paul.mybatis.executor.Executor;
  import com.paul.mybatis.executor.SimpleExecutor;

  import java.lang.reflect.Proxy;
  import java.util.List;

  public class DefaultSqlSession implements  SqlSession {

      private final Configuration configuration;

      private Executor executor;

      public DefaultSqlSession(Configuration configuration) {
          super();
          this.configuration = configuration;
          executor = new SimpleExecutor(configuration);
      }

      @Override
      public &amp;lt;T&amp;gt; T selectOne(String statement, Object parameter) {
          List&amp;lt;T&amp;gt; selectList = this.selectList(statement,parameter);
          if(selectList == null || selectList.size() == 0){
              return null;
          }
          if(selectList.size() == 1){
              return (T) selectList.get(0);
          }else{
              throw new RuntimeException(&quot;too many result&quot;);
          }
      }

      @Override
      public &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; selectList(String statement, Object parameter) {
          MappedStatement ms = configuration.getMappedStatement().get(statement);
          return executor.query(ms,parameter);
      }

      @Override
      public &amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type) {
          MapperProxy mp = new MapperProxy(this);
          //给我一个接口，还你一个实现类
          return (T)Proxy.newProxyInstance(type.getClassLoader(),new Class[]{type},mp);
      }
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;动态代理的 InvocationHandler。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  package com.paul.mybatis.bind;

  import com.paul.mybatis.sqlsession.SqlSession;

  import java.lang.reflect.InvocationHandler;
  import java.lang.reflect.Method;
  import java.util.Collection;
  import java.util.Collections;

  /**
   *
   * 将请求转发给 sqlSession
   *
   */
  public class MapperProxy implements InvocationHandler {

      private SqlSession sqlSession;

      public MapperProxy(SqlSession sqlSession) {
          this.sqlSession = sqlSession;
      }

      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          System.out.println(method.getDeclaringClass().getName()+&quot;.&quot;+method.getName());
          if(Collection.class.isAssignableFrom(method.getReturnType())){
              return sqlSession.selectList(method.getDeclaringClass().getName()+&quot;.&quot;+method.getName(),args==null?null:args[0]);
          }else{
              return sqlSession.selectOne(method.getDeclaringClass().getName()+&quot;.&quot;+method.getName(),args==null?null:args[0]);
          }
      }
  }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;最后来看我们的测试类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; package com.paul.mybatis;

 import com.paul.mybatis.entity.TUser;
 import com.paul.mybatis.factory.DefaultSqlSessionFactory;
 import com.paul.mybatis.factory.SqlSessionFactory;
 import com.paul.mybatis.mapper.TUserMapper;
 import com.paul.mybatis.sqlsession.SqlSession;

 public class TestDemo {

     public static void main(String[] args) {
         SqlSessionFactory sqlSessionFactory = new DefaultSqlSessionFactory();

         SqlSession sqlSession = sqlSessionFactory.openSession();

         TUserMapper mapper = sqlSession.getMapper(TUserMapper.class);

         TUser user = mapper.selectByPrimaryKey(1);

         System.out.println(user.toString());
     }
 }
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;整个项目的源码在&lt;a href=&quot;https://github.com/PaulWang92115/Paul-MyBatis&quot;&gt;项目源码&lt;/a&gt;，希望大家 mark 一下，一起改进。&lt;/p&gt;
</description>
<pubDate>Sat, 15 Jun 2019 12:18:00 +0000</pubDate>
<dc:creator>当年明月123</dc:creator>
<og:description>MyBatis 运行过程 传统的 JDBC 编程查询数据库的代码和过程总结。 1. 加载驱动。 2. 创建连接，Connection 对象。 3. 根据 Connection 创建 Statement</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/paulwang92115/p/11028715.html</dc:identifier>
</item>
</channel>
</rss>