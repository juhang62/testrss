<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SLAM+语音机器人DIY系列：（四）差分底盘设计——2.stm32主控软件设计 - 小虎哥哥爱学习</title>
<link>http://www.cnblogs.com/hiram-zhang/p/10403822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiram-zhang/p/10403822.html</guid>
<description>&lt;p&gt;&lt;span&gt;运动底盘是移动机器人的重要组成部分，不像激光雷达、IMU、麦克风、音响、摄像头这些通用部件可以直接买到，很难买到通用的底盘。一方面是因为底盘的尺寸结构和参数是要与具体机器人匹配的；另一方面是因为底盘包含软硬件整套解决方案，是很多机器人公司的核心技术，一般不会随便公开。出于强烈的求知欲与学习热情，我想自己DIY一整套&lt;span&gt;两轮差分底盘&lt;/span&gt;，并且将完整的设计过程公开出去供大家学习。说干就干，本章节主要内容：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.stm32主控硬件设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.stm32主控软件设计&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.底盘通信协议&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.底盘ROS驱动开发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.底盘PID控制参数整定&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.底盘里程计标&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;上一节搭建好了底盘的&lt;/span&gt;stm32&lt;span&gt;主控硬件，现在就来说说怎么开发配套的&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;软件。关于建立&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;工程、使用&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;开发库、&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;软件调试方法等基础知识就不多说了，有需要的可以查阅相关资料学习，我觉得&lt;/span&gt;&lt;a href=&quot;http://www.openedv.com/&quot;&gt;&lt;span&gt;http://www.openedv.com&lt;/span&gt;&lt;/a&gt;&lt;span&gt;《正点原子》的开发资料写的还可以。我就直接从底盘控制的项目入手，直接进行项目中各个功能需求开始分析讲解，如图&lt;/span&gt;11&lt;span&gt;，是我的底盘控制&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;工程项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219223840131-90996817.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;11&lt;span&gt;）底盘控制&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;工程项目&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.1.&lt;span&gt;电机控制                &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;电机控制分为两个部分（电机转向控制、电机转速控制），这些都集成在了电机驱动芯片&lt;/span&gt;TB6612FNG&lt;span&gt;里面，所以只需要用单片机的&lt;/span&gt;&lt;span&gt;IO&lt;/span&gt;&lt;span&gt;口产生控制转向的高低电平和控制转速的&lt;/span&gt;&lt;span&gt;PWM&lt;/span&gt;&lt;span&gt;波就能实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，初始化&lt;/span&gt;IO&lt;span&gt;口作为输出脚，用于产生高低电平输出来控制转向，实例代码如图&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219224045542-1305035799.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;12&lt;span&gt;）电机转向控制&lt;/span&gt;&lt;span&gt;IO&lt;/span&gt;&lt;span&gt;口初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，用通用定时器&lt;/span&gt;TIM4&lt;span&gt;的通道&lt;/span&gt;&lt;span&gt;CH1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CH2&lt;/span&gt;&lt;span&gt;分别产生两路&lt;/span&gt;&lt;span&gt;PWM&lt;/span&gt;&lt;span&gt;输出用于两个电机的转速控制，定时器默认引脚分配如图&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219224147782-1482840505.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;13&lt;span&gt;）&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;定时器通道默认引脚分配&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初始化通用定时器&lt;/span&gt;TIM4&lt;span&gt;的通道&lt;/span&gt;&lt;span&gt;CH1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CH2&lt;/span&gt;&lt;span&gt;为&lt;/span&gt;&lt;span&gt;PWM&lt;/span&gt;&lt;span&gt;输出，实例代码如&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219224251591-576317140.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;14&lt;span&gt;）电机转速控制&lt;/span&gt;&lt;span&gt;IO&lt;/span&gt;&lt;span&gt;口初始化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，将电机转向和速度控制的操作封装在一个函数中，便于其它地方调用，实例代码如图&lt;/span&gt;15&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219224348640-66937201.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;15&lt;span&gt;）电机转向和速度控制封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;span&gt;2.2.&lt;span&gt;编码器数据读取           &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;编码器对底盘来说至关重要，一方面底盘通过编码器的反馈进行&lt;/span&gt;PID&lt;span&gt;闭环速度控制，另一方面底盘通过编码器进行航迹推演得到里程计用于后续的定位与导航等高级算法中。这里用到的编码器是正交编码器，所以直接使用通用定时器的输入捕获中的编码器模式来读取编码器。采用通用定时器&lt;/span&gt;&lt;span&gt;TIM2&lt;/span&gt;&lt;span&gt;的通道&lt;/span&gt;&lt;span&gt;CH1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CH2&lt;/span&gt;&lt;span&gt;捕获&lt;/span&gt;&lt;span&gt;encoder1&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;相和&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;相脉冲，采用通用定时器&lt;/span&gt;&lt;span&gt;TIM3&lt;/span&gt;&lt;span&gt;的通道&lt;/span&gt;&lt;span&gt;CH1&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;CH2&lt;/span&gt;&lt;span&gt;捕获&lt;/span&gt;&lt;span&gt;encoder2&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;相和&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;相脉冲。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;先初始化&lt;/span&gt;TIM2&lt;span&gt;作为编码器&lt;/span&gt;&lt;span&gt;encoder1&lt;/span&gt;&lt;span&gt;的捕获，实例代码如图&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225012510-1485248446.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;16&lt;span&gt;）初始化&lt;/span&gt;&lt;span&gt;TIM2&lt;/span&gt;&lt;span&gt;作为编码器&lt;/span&gt;&lt;span&gt;encoder1&lt;/span&gt;&lt;span&gt;的捕获&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;然后，将读取编码器计数值的操作封装在一个函数中，便于其它地方调用，实例代码如图&lt;/span&gt;17&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225355067-1799512936.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;17&lt;span&gt;）读取编码器&lt;/span&gt;&lt;span&gt;encoder1&lt;/span&gt;&lt;span&gt;计数值封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，编写&lt;/span&gt;TIM2&lt;span&gt;计数溢出时的中断处理函数，实例代码如图&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225449521-1365626348.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;18&lt;span&gt;）&lt;/span&gt;&lt;span&gt;TIM2&lt;/span&gt;&lt;span&gt;计数溢出中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理可得&lt;/span&gt;TIM3&lt;span&gt;捕获&lt;/span&gt;&lt;span&gt;encoder2&lt;/span&gt;&lt;span&gt;的代码实现，这里就不在赘述了。&lt;/span&gt;&lt;/p&gt;
&lt;h2 align=&quot;justify&quot;&gt;&lt;span&gt;2.3.&lt;span&gt;串口数据收发            &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;串口&lt;/span&gt;2&lt;span&gt;是数据接口，负责接收上位机发送过来的控制指令，同时将编码器值返回给上位机；串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;debug&lt;/span&gt;&lt;span&gt;接口，负责接收上位机发送过来的版本信息请求、&lt;/span&gt;&lt;span&gt;PIDm&lt;/span&gt;&lt;span&gt;默认值恢复、&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;值设定等调试指令，同时将程序中的&lt;/span&gt;&lt;span&gt;debug&lt;/span&gt;&lt;span&gt;打印信息返回给上位机。但是在底盘正常工作时，只需要连接串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;；串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;是预留出来给有需要自己动手修改&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;参数使用的。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;首先，配置串口&lt;/span&gt;1&lt;span&gt;，先对串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;的输出进行&lt;/span&gt;&lt;span&gt;printf&lt;/span&gt;&lt;span&gt;函数打印支持，实例代码如图&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225745273-280586997.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;19&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;的输出进行&lt;/span&gt;&lt;span&gt;printf&lt;/span&gt;&lt;span&gt;函数打印支持&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;然后，初始化串口&lt;/span&gt;1&lt;span&gt;，实例代码如图&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219225932746-1773228303.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;20&lt;span&gt;）初始化串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，编写串口&lt;/span&gt;1&lt;span&gt;接收中断处理函数，此函数主要进行对上位机发过来的数据进行协议解析，实例代码如图&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230022609-1926741224.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;21&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;接收中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，介绍串口&lt;/span&gt;2&lt;span&gt;，初始化串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;，实例代码如图&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230129539-934639601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;22&lt;span&gt;）初始化串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，将串口&lt;/span&gt;2&lt;span&gt;发送数据的操作封装到函数中，便于其它地方调用，实例代码如图&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230216692-153454569.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;23&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;发送数据封装&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，编写串口&lt;/span&gt;2&lt;span&gt;接收中断处理函数，此函数主要进行对上位机发过来的数据进行协议解析，实例代码如图&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230332778-64772980.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;24&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;接收中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到这里，串口有&lt;/span&gt;1&lt;span&gt;和串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的数据发送与接收都编写好了，依据我们定义的&lt;/span&gt;&lt;span&gt;usart2&lt;/span&gt;&lt;span&gt;数据通信协议和&lt;/span&gt;&lt;span&gt;usart1&lt;/span&gt;&lt;span&gt;调试通信协议，上位机就可以编写对应的程序来跟底盘的串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;和串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;进行通信了。关于通信协议的具体内容，将在后续做展开。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.4.&lt;span&gt;电机速度&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;控制         &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我在底盘中采用的是增量型&lt;/span&gt;PID&lt;span&gt;算法，编程涉及到的数学表达式有&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个，分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;e(k) = target_value - current_value&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;delta_u(k) = Kp*[e(k)-e(k-1)] + Ki*e(k) + Kd*[e(k)-2*e(k-1)+e(k-2)]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;u(k) = u(k-1) + delta_u(k)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将这&lt;/span&gt;3&lt;span&gt;个数学表达式封装到函数中，便于其它地方调用，实例代码如图&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230607634-1414638330.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;25&lt;span&gt;）串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;接收中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;电机&lt;/span&gt;1&lt;span&gt;与电机&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;采用同样的&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;算法，所以电机&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;算法代码实现就不赘述了。关于&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;参数的整定方法，将在后续做展开。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.5.&lt;span&gt;周期性控制           &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过上面的讲解，各个模块的驱动代码都准备就绪了，现在需要产生一个周期性的过程，在里面实现编码器计数值采样、&lt;/span&gt;PID&lt;span&gt;控制等具体实现。这里采用定时器&lt;/span&gt;&lt;span&gt;TIM1&lt;/span&gt;&lt;span&gt;产生一个周期性的中断，在中断处理函数中实现各模块的具体操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，配置定时器&lt;/span&gt;TIM1&lt;span&gt;，实例代码如图&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219230825074-1969727839.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;26&lt;span&gt;）配置定时器&lt;/span&gt;&lt;span&gt;TIM1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后，编写中断处理函数，实例代码如图&lt;/span&gt;27&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219231153468-1585582961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;27&lt;span&gt;）&lt;/span&gt;&lt;span&gt;TIM1&lt;/span&gt;&lt;span&gt;中断处理函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;2.6.stm32&lt;span&gt;主控软件整体框图&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;通过上面的讲解，对底盘控制的&lt;/span&gt;stm32&lt;span&gt;程序实现有了一定的了解，接下来就来做一个总结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先来看看&lt;/span&gt;main()&lt;span&gt;函数实现，如图&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219231331226-1210325130.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;28&lt;span&gt;）&lt;/span&gt;&lt;span&gt;main()&lt;/span&gt;&lt;span&gt;函数实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;结合上面&lt;/span&gt;TIM1&lt;span&gt;中断处理函数，不难发现，整个&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;程序的执行过程：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;a.&lt;span&gt;在&lt;/span&gt;&lt;span&gt;main()&lt;/span&gt;&lt;span&gt;函数中初始化各个模块；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;b.TIM1&lt;span&gt;中断处理函数周期性的读取编码器值、反馈获取的编码值、&lt;/span&gt;&lt;span&gt;PID&lt;/span&gt;&lt;span&gt;控制；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;c.&lt;span&gt;剩下的就是串口&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;和串口&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;的通信交互。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;具体&lt;/span&gt;stm32&lt;span&gt;主控软件整体框图如图&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1204799/201902/1204799-20190219231437207-647232679.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（图&lt;/span&gt;29&lt;span&gt;）&lt;/span&gt;&lt;span&gt;stm32&lt;/span&gt;&lt;span&gt;主控软件整体框图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;需要说明的是，在周期性循环体中，要首先读取编码器的值，来保证严格的等间隔采样。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 15:19:00 +0000</pubDate>
<dc:creator>小虎哥哥爱学习</dc:creator>
<og:description>摘要 运动底盘是移动机器人的重要组成部分，不像激光雷达、IMU、麦克风、音响、摄像头这些通用部件可以直接买到，很难买到通用的底盘。一方面是因为底盘的尺寸结构和参数是要与具体机器人匹配的；另一方面是因为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hiram-zhang/p/10403822.html</dc:identifier>
</item>
<item>
<title>Aria2序之导言 - A.Z</title>
<link>http://www.cnblogs.com/A-Z/p/aria2_2019_0.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/A-Z/p/aria2_2019_0.html</guid>
<description>&lt;p&gt;aria2是什么，如果此时此刻你看到标题读到第一行正在思索着一个问题，很抱歉 ，这篇以及后续我的blog不适合你，请移步。&lt;/p&gt;
&lt;p&gt;我在aria2的官方站点抄袭了如下语句用来充实本文：&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;aria2 is a &lt;strong data-mce-=&quot;&quot;&gt;lightweight&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt; multi-protocol &amp;amp; multi-source command-line&lt;strong data-mce-=&quot;&quot;&gt;download utility&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt;. It supports &lt;strong data-mce-=&quot;&quot;&gt;HTTP/HTTPS&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt;, &lt;strong data-mce-=&quot;&quot;&gt;FTP&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt;, &lt;strong data-mce-=&quot;&quot;&gt;SFTP&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt;, &lt;strong data-mce-=&quot;&quot;&gt;BitTorrent&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt;and &lt;strong data-mce-=&quot;&quot;&gt;Metalink&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt;. aria2 can be manipulated via built-in &lt;strong data-mce-=&quot;&quot;&gt;JSON-RPC&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt; and &lt;strong data-mce-=&quot;&quot;&gt;XML-RPC&lt;/strong&gt;&lt;span data-mce-=&quot;&quot;&gt; interfaces.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我们再一次重新审视这一个划时代的工具时，它的原作者已经去忙HTTP2了，无暇顾及这个他的早期作品。&lt;/p&gt;
&lt;p&gt;而我接触到这个工具自从购买了NAS以后，当然NAS不可能自带这样的工具，因为我们一般不会为了一个工具而支付更多的费用，或者为了那些锦上添花的图形界面承担过多的开销，作为一个务实的人，我们选择自给自足丰衣足食，说来惭愧，作为生手党之一，最开始的日子，一切从Optware开始，Optware包含了古老的ARM一些基础库和工具，收手党只要加好feeds就可以从容的为自己的主机添砖加瓦。&lt;/p&gt;
&lt;p&gt;The &lt;span class=&quot;wikiword&quot;&gt;NSLU2 has an Intel &lt;span class=&quot;wikiword&quot;&gt;IXP420 as its processor.  Currently &lt;span class=&quot;wikiword&quot;&gt;NSLU2's are supplied with a B0 stepping &lt;span class=&quot;wikiword&quot;&gt;IXP420.  This is a stripped down version of the &lt;span class=&quot;wikiword&quot;&gt;IXP425 and therefore does not have any of the cryptographic features or extra interfaces.  The &lt;a class=&quot;urllink&quot; href=&quot;http://en.wikipedia.org/wiki/XScale&quot; rel=&quot;nofollow&quot;&gt;XScale&lt;/a&gt; core inside the &lt;span class=&quot;wikiword&quot;&gt;IXP420 is based on a ARMv5TE architecture and is rated for 266MHz operation.  Units supplied by Linksys,  before May 2006 run at 133 Mhz and can set for 266MHz operation using a &lt;a class=&quot;wikilink&quot; href=&quot;http://www.nslu2-linux.org/wiki/HowTo/OverClockTheSlug&quot;&gt;simple modification&lt;/a&gt;.  After this manufacture date, most users have discovered their Nslu2 already operating at 266MHz. Due to limitations of the IXP NPE access library and microcode at the time of release, the &lt;span class=&quot;wikiword&quot;&gt;NSLU2 runs in big endian mode (the cpu supports little endian as well).&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;wikiword&quot;&gt;这是Optware的出发点ARMV5TE，也是本作系列的出发点，也是ARM历史的一个标志性出发点，请牢记。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;wikiword&quot;&gt;Optware有很多硬件编译环境在&lt;a href=&quot;http://www2.nslu2-linux.org/wiki/pmwiki.php?pagename=Optware/Platforms&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;可以找到他们各自的代表。作为一个Marvell的粉丝当然选择cs06q3armel分类。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Marvell Orion devices&lt;/h2&gt;
&lt;p&gt;Known to work: Maxtor Shared Storage II, Buffalo Linkstation Pro/Live and Terastation Prov2, HP &lt;span class=&quot;wikiword&quot;&gt;&lt;a class=&quot;createlinktext&quot; title=&quot;Page not found - click link to create page&quot; href=&quot;http://www.nslu2-linux.org/wiki/Optware/MediaVault2?action=edit&quot;&gt;MediaVault2&lt;/a&gt;&lt;a class=&quot;createlink&quot; title=&quot;Page not found - click link to create page&quot; href=&quot;http://www.nslu2-linux.org/wiki/Optware/MediaVault2?action=edit&quot;&gt;?&lt;/a&gt;, QNAP &lt;span class=&quot;wikiword&quot;&gt;&lt;a class=&quot;createlinktext&quot; title=&quot;Page not found - click link to create page&quot; href=&quot;http://www.nslu2-linux.org/wiki/Optware/TurboStation?action=edit&quot;&gt;TurboStation&lt;/a&gt;&lt;a class=&quot;createlink&quot; title=&quot;Page not found - click link to create page&quot; href=&quot;http://www.nslu2-linux.org/wiki/Optware/TurboStation?action=edit&quot;&gt;?&lt;/a&gt; x09, Freecom &lt;span class=&quot;wikiword&quot;&gt;&lt;a class=&quot;createlinktext&quot; title=&quot;Page not found - click link to create page&quot; href=&quot;http://www.nslu2-linux.org/wiki/Optware/DT2?action=edit&quot;&gt;DT2&lt;/a&gt;&lt;a class=&quot;createlink&quot; title=&quot;Page not found - click link to create page&quot; href=&quot;http://www.nslu2-linux.org/wiki/Optware/DT2?action=edit&quot;&gt;?&lt;/a&gt; Feed: &lt;a class=&quot;urllink&quot; href=&quot;http://ipkg.nslu2-linux.org/feeds/optware/cs05q3armel&quot; rel=&quot;nofollow&quot;&gt;cs05q3armel&lt;/a&gt; Kernel: 2.6.12.6 Cross toolchain: arm-none-linux-gnueabi/gcc-2005q3-glibc-2.3.6 Native toolchain: gcc 4.1.2 from cs06q3armel feed Project Page for MSS II: &lt;a class=&quot;urllink&quot; href=&quot;http://www.nslu2-linux.org/wiki/MSSII/HomePage&quot; rel=&quot;nofollow&quot;&gt;http://www.nslu2-linux.org/wiki/MSSII/HomePage&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;wikiword&quot;&gt;写到这里，我觉得这个序已经很充实了，既没有大家习惯的网络工具傻瓜式图文教程，也没有离题推销全家桶工具，开局两张图，剩下的全靠编：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;wikiword&quot;&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/A-Z/117549/o_aria2_0.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;auto&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/A-Z/117549/o_aria2_1.png&quot; alt=&quot;&quot; width=&quot;600&quot; height=&quot;auto&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图片贴（tiao）好(zheng)了(qi)，序也快写完了。如果你在图片里发现了什么，那一定是幻觉，没有错这个世界上第一个此uri不是http的下载链接，不要问我为什么如此自信的知道，请注意我在图中两处重点标记。&lt;/p&gt;
&lt;p&gt;以上，序终，图穷。&lt;/p&gt;
&lt;p&gt;2019. 2&lt;/p&gt;

</description>
<pubDate>Tue, 19 Feb 2019 15:19:00 +0000</pubDate>
<dc:creator>A.Z</dc:creator>
<og:description>aria2是什么，如果此时此刻你看到标题读到第一行正在思索着一个问题，很抱歉 ，这篇以及后续我的blog不适合你，请移步。 我在aria2的官方站点抄袭了如下语句用来充实本文： aria2 is a&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/A-Z/p/aria2_2019_0.html</dc:identifier>
</item>
<item>
<title>工作中常用的 Linux 命令 - Michael_翔</title>
<link>http://www.cnblogs.com/michael-xiang/p/10404016.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/michael-xiang/p/10404016.html</guid>
<description>&lt;h2 id=&quot;awk&quot;&gt;awk&lt;/h2&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;env变量值如下，需要获得pkg_url的链接值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;name&quot;: &quot;michael&quot;, &quot;sex&quot;: &quot;male&quot;, &quot;pkg_url&quot;: &quot;www.github.com&quot;, &quot;number&quot;: &quot;888&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;pkg_url=$(echo $env | awk -F &quot;pkg_url\&quot;: \&quot;&quot; '{print $2}' | awk -F &quot;\&quot;,&quot; '{print $1}')
echo $pkg_url 
www.github.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;-F 指定分隔规则，因为分隔规则中包含了双引号，所以需要用转义符号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 格式
$ awk 动作 文件名

# 示例
$ awk '{print $0}' demo.txt

echo 'hello:michael:xiang'|awk -F ':' '{print $1}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;## basename&lt;/p&gt;
&lt;p&gt;basename命令用于打印目录或者文件的基本名称&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@HGH1000059721 test]# basename a.tar .tar  #后缀：可选参数，指定要去除的文件后缀字符串。
a
[root@HGH1000059721 test]# basename /tmp/test/a.tar  #不带后缀，获取文件名
a.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;cp&quot;&gt;cp&lt;/h2&gt;
&lt;p&gt;将目录&lt;code&gt;src&lt;/code&gt;复制到&lt;code&gt;dest&lt;/code&gt;目录下，复制好后，&lt;code&gt;dest/src&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp -r src dest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将目录&lt;code&gt;src&lt;/code&gt;下的内容复制到&lt;code&gt;dest&lt;/code&gt;目录下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp -r src/* dest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;复制文件，覆盖不询问：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cp -nrf a.txt b.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;系统默认给&lt;code&gt;cp&lt;/code&gt;命令设置了别名&lt;code&gt;cp -i&lt;/code&gt;，所以，复制时有冲突需要确认，使用如下方式即可不改变别名，也实现默认覆盖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/bin/cp xx yy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;crontab&quot;&gt;crontab&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181122165329818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI1OTMyOTA=,size_16,color_FFFFFF,t_70&quot; alt=&quot;![图片描述][1]&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在以上各个字段中，还可以使用以下特殊字符：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。&lt;/li&gt;
&lt;li&gt;逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”&lt;/li&gt;
&lt;li&gt;中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。&lt;/p&gt;
&lt;p&gt;任务执行文件所在位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/var/spool/cron/crontabs&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-u&lt;/code&gt; user：用来设定某个用户的crontab服务；&lt;br/&gt;file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt;：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt;：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt;：在删除用户的crontab文件时给确认提示&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每隔2分钟执行&lt;code&gt;/tmp/test.sh&lt;/code&gt;脚本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;crontab -e # 使用crontab -e命令，编辑的是/var/spool/cron下对应用户的 cron 文件
*/2 * * * * /tmp/test.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第星期六、星期日的时10分重启smb-也就是每周六、周日：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;10 1 * * 6,0 /etc/init.d/smb restart &amp;gt;&amp;gt;  /tmp/run.log 2&amp;gt;&amp;amp;1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例4：每隔两天的上午8点到11点的第3和第15分钟执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3,15 8-11 */2  *  * myCommand&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例5：清理httpd服务日志超过3天的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0 5 * * * /usr/bin/find /var/log/httpd/ -type f -mtime +3 -exec rm -rf {} \;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例6：通过正则清理指定文件夹的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#update-20181122: clean dir +120 days
0 6 * * * find /data/michael -maxdepth 7 -type d -mtime +120 -regextype posix-egrep -regex '.*/[0-9]{2}/[0-9]{6}$' -exec rm -rf {} \;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动 / 停止 / 重启 crontab&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ /etc/init.d/crond start
$ /etc/init.d/crond stop
$ /etc/init.d/crond restart&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看日志&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tail -f /var/log/cron&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;date&quot;&gt;date&lt;/h2&gt;
&lt;p&gt;选项：&lt;br/&gt;不加: 显示当前的时间.&lt;br/&gt;-d &amp;lt;字符串&amp;gt;：显示字符串所指的日期与时间。字符串前后必须加上双引号；&lt;br/&gt;-s &amp;lt;字符串&amp;gt;：根据字符串来设置日期与时间。字符串前后必须加上双引号；&lt;br/&gt;-u：显示GMT；&lt;br/&gt;--help：在线帮助；&lt;br/&gt;--version：显示版本信息。&lt;/p&gt;
&lt;p&gt;参数 &amp;lt;+时间日期格式&amp;gt;：指定显示时使用的日期时间格式。&lt;br/&gt;就是格式化字符串处理.当需要用到空格时要使用双引号,如&lt;code&gt;&quot;+%Y-%m-%d %H:%M:%S&quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;一般,&lt;code&gt;%Y %m %d %H %M %S&lt;/code&gt; 是最基本的. 使用星期月份时也会用到&lt;code&gt;%a %b&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;VERSION=$(date +%Y%m%d%H%M%S) #20180410192702 #date后面有空格
time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;) #时间格式中有空格，需要加引号
» date &quot;+%Y-%m-%d %T %a %A&quot;                                                               
2018-06-04 11:31:25 Mon Monday&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;df&quot;&gt;df&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;df&lt;/code&gt;命令很容易发现那个磁盘的存储空间快没了。查看挂载状态和硬盘使用量信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;df -hT&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;dig&quot;&gt;dig&lt;/h2&gt;
&lt;p&gt;查看域名的信息。一般一个域名都会绑定到多个 IP 上，ping 命令只能一次看到一个 ip，这个可以看到域名解析的信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dig baidu.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能机器上没有这个命令，可以如下&lt;a href=&quot;https://unix.stackexchange.com/questions/121874/how-to-install-dig-on-centos&quot;&gt;方式&lt;/a&gt;安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install -y bind-utils&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;du&quot;&gt;du&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;du&lt;/code&gt;命令可以显示某个特定目录（默认情况下是当前目录）的磁盘使用情况。这一方法可以判断系统上某个目录下是不是有超大的文件。&lt;/p&gt;
&lt;p&gt;查看当前文件夹的文件大小：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;du -sh *  
du -sh /usr/* | sort -rn # 按M大小排序&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;env&quot;&gt;env&lt;/h2&gt;
&lt;p&gt;查看环境变量值，例：&lt;br/&gt;查看带有SVN的环境变量值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;env|grep SVN&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;find&quot;&gt;find&lt;/h2&gt;
&lt;p&gt;实例：定时清理httpd服务日志超过3天的内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0 5 * * * /usr/bin/find /var/log/httpd/ -type f -mtime +3 -exec rm -rf {} \;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例： 通过正则清理指定文件夹的内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#update-20181122: clean dir +120 days
0 6 * * * find /data/michael -maxdepth 7 -type d -mtime +120 -regextype posix-egrep -regex '.*/[0-9]{2}/[0-9]{6}$' -exec rm -rf {} \;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例：搜索/etc目录下第一层的conf配置文件，文件夹下层的不需要&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find /etc/ -maxdepth 1 -name &quot;*.conf&quot; # 最好加上引号&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例：只搜索当前目录，但是不包括.git目录，统计目录数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find . -maxdepth 1 -mindepth 1 -type d | grep -v .git |wc -l&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例：仅列出目录&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;find . -type d -maxdepth 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;fdisk&quot;&gt;fdisk&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;fdisk -l&lt;/code&gt;看到目前系统中所有分区的信息&lt;br/&gt;https://blog.csdn.net/cc_net/article/details/2894510&lt;/p&gt;
&lt;h2 id=&quot;free&quot;&gt;free&lt;/h2&gt;
&lt;p&gt;free命令可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。在Linux系统监控的工具中，free命令是最经常使用的命令之一。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;free -h -s 2 -t&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-h&lt;/code&gt; 单位会更人性化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt; 每2秒，显示内存使用信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-t&lt;/code&gt; 显示内存总和&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# 结果
              total        used        free      shared  buff/cache   available
Mem:           7.6G        935M        6.1G        9.7M        631M        6.4G
Swap:          7.5G          0B        7.5G
Total:          15G        935M         13G&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;total:总计物理内存的大小。&lt;/li&gt;
&lt;li&gt;used:已使用多大。&lt;/li&gt;
&lt;li&gt;free:可用有多少。&lt;/li&gt;
&lt;li&gt;Shared:多个进程共享的内存总额。&lt;/li&gt;
&lt;li&gt;Buffers/cached:磁盘缓存的大小&lt;/li&gt;
&lt;li&gt;交换分区SWAP，也就是我们通常所说的虚拟内存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从应用程序角度来看，对于应用程序来说，buffers/cached 是等于可用的，因为buffer/cached 是为了提高文件读取的性能，当应用程序需在用到内存的时候，buffer/cached 会很快地被回收。&lt;/p&gt;
&lt;p&gt;所以从应用程序的角度来说 &lt;code&gt;可用内存=系统free memory+buffers+cached&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们看linux,只要不用swap的交换空间,就不用担心自己的内存太少.如果常常swap用很多,可能你就要考虑加物理内存了.这也是linux看内存是否够用的标准.&lt;/p&gt;
&lt;p&gt;+buffers/cache,即对应用程序来说free的内存太少了，也是该考虑优化程序或加内存了&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;fuser&quot;&gt;fuser&lt;/h2&gt;
&lt;p&gt;fuser通常被用在诊断系统的“resource busy”问题，通常是在你希望umount指定的挂载点得时候遇到。 如果你希望kill所有正在使用某一指定的file, file system or sockets的进程的时候，你可以使用-k option&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fuser –k –i /path/to/your/filename # 加上-i 表示杀死之前，需确认&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;groups&quot;&gt;groups&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;whoami # 查看用户名
groups # 查看当前用户所属组&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;grep&quot;&gt;grep&lt;/h2&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;grep [options] pattern [file]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# 递归、显示行号、忽略大小写、显示搜到的匹配内容上下2行 搜索范围是当前目录下
grep -rni 'github.com'  -C 2 .&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;grep 'shopbase' /home/admin -r -n --include *.{vm,java} #指定文件后缀
grep 'shopbase' /home/admin -r -n --exclude *.{vm,java} #反匹配&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;gzip&quot;&gt;gzip&lt;/h2&gt;
&lt;p&gt;gzip是GNU项目的产物。这个软件下买呢含有下面的工具：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;gzip ：用来压缩文件&lt;/li&gt;
&lt;li&gt;gzcat：用来查看压缩过的文本文件的内容&lt;/li&gt;
&lt;li&gt;gunzip:用来解压文件。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;gzip xxx
gzip -l &amp;lt;filename&amp;gt; # list compressed file contents&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;head&quot;&gt;head&lt;/h2&gt;
&lt;p&gt;显示前n行内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;head -n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;https://www.linuxdaxue.com/linux-command-intro-head.html&lt;/p&gt;
&lt;h2 id=&quot;less&quot;&gt;less&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;more&lt;/code&gt;的时候，我们并没有办法向前面翻，只能往后面看，但若使用了&lt;code&gt;less&lt;/code&gt;时，就可以使用 &lt;code&gt;[pageup] [pagedown]&lt;/code&gt; 等按键的功能来往前往后翻看文件。&lt;/p&gt;
&lt;h2 id=&quot;locate&quot;&gt;locate&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;locate  GPG-KEY
# find /etc -name '*GPG-KEY*' 等同&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能系统没有自带&lt;code&gt;locate&lt;/code&gt;命令，可以使用&lt;code&gt;yum install mlocate -y&lt;/code&gt;安装，安装结束执行&lt;code&gt;updatedb&lt;/code&gt;命令。&lt;/p&gt;
&lt;h2 id=&quot;ls&quot;&gt;ls&lt;/h2&gt;
&lt;p&gt;仅显示目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ll -d&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ls命令显示文件大小，会根据文件大小自己决定单位，M或者Kb或者G&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ll -h&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mount&quot;&gt;mount&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mount&lt;/code&gt;可以显示全部挂载情况。&lt;/p&gt;
&lt;p&gt;将分区挂载到目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mount /dev/xvde /data&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mkdir&quot;&gt;mkdir&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;mkdir sysadmin/admim_{1,2,3,4,5}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;netstat&quot;&gt;netstat&lt;/h2&gt;
&lt;p&gt;检查端口占用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;netstat -anp|grep 80 &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;rm&quot;&gt;rm&lt;/h2&gt;
&lt;p&gt;只删除当前文件夹下的隐藏文件和隐藏文件夹：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rm -rf .*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;https://blog.csdn.net/ficksong/article/details/52447729&lt;/p&gt;
&lt;h2 id=&quot;rpm&quot;&gt;rpm&lt;/h2&gt;
&lt;p&gt;我的系统中安装了那些rpm软件包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rpm -qa &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要查找所有安装过的包含某个字符串sql的软件包&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rpm -qa | grep sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个rpm包中的文件安装到那里去了？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rpm -ql 包名&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;软件包的卸载&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rpm -e &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：http://man.linuxde.net/rpm&lt;/p&gt;
&lt;h2 id=&quot;rpm2cpio&quot;&gt;rpm2cpio&lt;/h2&gt;
&lt;p&gt;RPM 包解压缩：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 注意，要加上 cpio -div，否则终端会打印多余的内容出来
rpm2cpio xxxx.rpm | cpio -div&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你的 Linux 下可能没有rpm2cpio这个命令，用过简单指令安装即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get install  rpm2cpio
sudo yum install rpm2cpio&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sed&quot;&gt;sed&lt;/h2&gt;
&lt;p&gt;eg1：截取日志中的两行之间的内容，同时去掉匹配的首尾行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cat mock.log |sed -n '/tee/,/find/p' mock.log|sed -n '1!p'|sed -n '$!p'|awk '{print $2,$3}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg2:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;nl passwd|sed &quot;1d;10d&quot; #删除第1行，第10行&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg3:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sed -i -e &quot;1i%define upstream_version $UPSTREAMVERSION\\&quot; *.spec #第一行插入
sed -i -e &quot;s/UPSTREAMVERSION/$UPSTREAMVERSION/g&quot; *.spec #替换&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;selinux&quot;&gt;SELinux&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;sestatus [-v] # 查看selinux开启状态
getenforce # 查看当前selinux的状态&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;selinux开启常常影响其他一些服务，比如httpd等，所以，运维往往一般拿到机器就会默认将其关闭。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;setenforce 1 # 设置SELinux 成为enforcing模式
setenforce 0 # 设置SELinux 成为permissive模式 不重启关闭selinux的解决办法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开机重启后，上面利用&lt;code&gt;setenforce&lt;/code&gt;方式修改的值会失效，所以，开机重启也有效的话，需要修改如下文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/etc/selinux/config # 文件的软链接是/etc/sysconfig/selinux 是&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sort&quot;&gt;sort&lt;/h2&gt;
&lt;p&gt;对之前提到的密码文件&lt;code&gt;/etc/passwd&lt;/code&gt;根据用户ID进行数值排序。&lt;code&gt;-k&lt;/code&gt;和&lt;code&gt;-t&lt;/code&gt;参数在对安字段分割的数据进行排序时非常有用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sort -t &quot;:&quot; -k 3 -n /etc/passwd&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;systemctl&quot;&gt;systemctl&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;使某服务自动启动&lt;/td&gt;
&lt;td&gt;chkconfig –level 3 httpd on&lt;/td&gt;
&lt;td&gt;systemctl enable httpd.service&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;使某服务不自动启动&lt;/td&gt;
&lt;td&gt;chkconfig –level 3 httpd off&lt;/td&gt;
&lt;td&gt;systemctl disable httpd.service&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;检查服务状态&lt;/td&gt;
&lt;td&gt;service httpd status&lt;/td&gt;
&lt;td&gt;systemctl status httpd.service&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;显示所有已启动的服务&lt;/td&gt;
&lt;td&gt;chkconfig –list&lt;/td&gt;
&lt;td&gt;systemctl list-units –type=service&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;启动某服务&lt;/td&gt;
&lt;td&gt;service httpd start&lt;/td&gt;
&lt;td&gt;systemctl start httpd.service&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;停止某服务&lt;/td&gt;
&lt;td&gt;service httpd stop&lt;/td&gt;
&lt;td&gt;systemctl stop httpd.service&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;重启某服务&lt;/td&gt;
&lt;td&gt;service httpd restart&lt;/td&gt;
&lt;td&gt;systemctl restart httpd.service&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;sha256sum&quot;&gt;sha256sum&lt;/h2&gt;
&lt;p&gt;生成文件对应的sha256值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sha256sum FusionSphere_Upgrade_6.2.50.4001.tar.gz &amp;gt; a.sha256sum # 校验
sha256sum -c &amp;lt;(grep FusionSphere_Upgrade_6.2.50.4001.tar.gz a.sha256sum) # 校验&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;tar&quot;&gt;tar&lt;/h2&gt;
&lt;p&gt;目前Unix和Linux上最广泛使用的归档工具是 tar 命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar function [options] object1 object2 ……&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，创建一个归档文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -cvf test.tar test/ test2/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建了名为test.tar归档文件，含有 test 和 test2 目录内容。&lt;/p&gt;
&lt;p&gt;接着，列出 tar 文件 test.tar 内容（但并不提取文件）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -tf test.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后用命令提取文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tar -xvzf test.tar&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;tar命令是给整个目录创建归档文件的简便方法&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;窍门：下载开源软件之后，经常会看到文件名以.tgz结尾。这些事gzip压缩过的tar文件，可以用tar -zxvf filename.tgz来解压&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;tee&quot;&gt;tee&lt;/h2&gt;
&lt;p&gt;tee命令用于将数据重定向到文件，另一方面还可以提供一份重定向数据的副本作为后续命令的stdin。简单的说就是把数据重定向到给定文件和屏幕上。&lt;/p&gt;
&lt;p&gt;eg1 在终端打印stdout同时重定向到文件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls | tee out.txt | cat -n&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;eg2 创建daemon.json文件，EOF之间内容作为stdin：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tee /etc/docker/daemon.json &amp;lt;&amp;lt; EOF
{
    &quot;insecure-registries&quot; : [ &quot;&quot;, &quot;&quot;]
}
EOF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt; EOF …… EOF&lt;/code&gt;的作用是在命令执行过程中用户自定义输入，它类似于起到一个临时文件的作用，只是比使用文件更方便灵活。&lt;/p&gt;
&lt;p&gt;EOF妙用：&lt;/p&gt;
&lt;p&gt;它的作用就是将两个&lt;code&gt;delimiter&lt;/code&gt;之间的内容(Here Document Content 部分) 传递给&lt;code&gt;cmd&lt;/code&gt; 作为输入参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cmd &amp;lt;&amp;lt; delimiter
  Here Document Content
delimiter&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[root@ecs-6b86 tmp]# cat &amp;lt;&amp;lt; EOF &amp;gt;tt.sh
123123123
345345
asdfasds
EOF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自定义EOF，比如自定义为michael&lt;br/&gt;[root@slave-server opt]# cat &amp;lt;&amp;lt; michael &amp;gt; haha.txt&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;ggggggg&lt;br/&gt;4444444&lt;br/&gt;6666666&lt;br/&gt;michael&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 变为 &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt;。 使用 &lt;code&gt;&amp;lt;&amp;lt;-&lt;/code&gt; 的唯一变化就是Here Document 的内容部分每行前面的 &lt;code&gt;tab&lt;/code&gt; (制表符)将会被删除掉，这种用法是为了编写Here Document的时候可以将内容部分进行缩进，方便阅读代码。&lt;/p&gt;
&lt;p&gt;有时脚本内容里变量不想被系统环境变量替换掉，可以通过在起始的 delimiter的前后添加 &quot; 来实现&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;tree&quot;&gt;tree&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;tree -FCL 2 FusionUpgrade&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;time&quot;&gt;time&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;time nslookup michael.com
nslookup: can't resolve '(null)': Name does not resolve

Name:      micahel.com
Address 1: 10.248.250.158
real    0m 5.00s
user    0m 0.00s
sys     0m 0.00s&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;test&quot;&gt;test&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;判断字符串是否为空，可以通过&lt;code&gt;help test&lt;/code&gt;查看&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;      -z STRING      True if string is empty.
    
      -n STRING
         STRING      True if string is not empty.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh

STRING=&quot;&quot;
# -z 
if [ -z &quot;$STRING&quot; ]; then 
    echo &quot;STRING is empty&quot; 
fi

if [ -n &quot;$STRING&quot; ]; then 
    echo &quot;STRING is not empty&quot; 
fi

# STRING is empty&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;tcpdump&quot;&gt;tcpdump&lt;/h2&gt;
&lt;p&gt;首先，先用 &lt;code&gt;tcpdump -D&lt;/code&gt; 命令列出可以抓包的网络接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tcpdump -D
1.virbr0
2.docker0
3.bluetooth0 (Bluetooth adapter number 0)
4.nflog (Linux netfilter log (NFLOG) interface)
5.nfqueue (Linux netfilter queue (NFQUEUE) interface)
6.usbmon1 (USB bus number 1)
7.usbmon2 (USB bus number 2)
8.wlp3s0
9.enp5s0
10.any (Pseudo-device that captures on all interfaces)
11.lo [Loopback]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中， &lt;code&gt;lo&lt;/code&gt; 就是 &lt;code&gt;localhost&lt;/code&gt; 。其中特殊接口 any 可用于抓取所有活动的网络接口的数据包。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo tcpdump -i any -c5 -nn icmp port 80 -A -w webserver.pcap

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on any, link-type LINUX_SLL (Linux cooked), capture size 262144 bytes
22:10:51.809330 IP 192.168.3.43.22 &amp;gt; 192.168.3.66.50051: Flags [P.], seq 2040167007:2040167203, ack 59350146, win 1432, options [nop,nop,TS val 89942170 ecr 111122685], length 196
22:10:51.812472 IP 192.168.3.43.22 &amp;gt; 192.168.3.66.50051: Flags [P.], seq 196:416, ack 1, win 1432, options [nop,nop,TS val 89942173 ecr 111122685], length 220
22:10:51.833093 IP 192.168.3.66.50051 &amp;gt; 192.168.3.43.22: Flags [.], ack 0, win 23490, options [nop,nop,TS val 111123121 ecr 89942122], length 0
22:10:51.833193 IP 192.168.3.43.22 &amp;gt; 192.168.3.66.50051: Flags [P.], seq 416:612, ack 1, win 1432, options [nop,nop,TS val 89942194 ecr 111123121], length 196
22:10:51.835541 IP 192.168.3.66.50051 &amp;gt; 192.168.3.43.22: Flags [.], ack 196, win 23487, options [nop,nop,TS val 111123121 ecr 89942170], length 0
5 packets captured
7 packets received by filter
0 packets dropped by kernel&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; 选项可以用于限制 tcpdump 抓包的数量&lt;/li&gt;
&lt;li&gt;用 &lt;code&gt;-n&lt;/code&gt; 选项显示 IP 地址，&lt;code&gt;-nn&lt;/code&gt; 选项显示端口号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;icmp&lt;/code&gt; 这里用作过滤条件，只要抓取 &lt;code&gt;ICMP&lt;/code&gt; 报文&lt;/li&gt;
&lt;li&gt;&lt;code&gt;port&lt;/code&gt; 指定端口号，根据端口号来筛选数据包&lt;/li&gt;
&lt;li&gt;tcpdump 提供了两个选项可以查看数据包内容，&lt;code&gt;-X&lt;/code&gt; 以十六进制打印出数据报文内容，&lt;code&gt;-A&lt;/code&gt; 打印数据报文的 ASCII 值&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;-w&lt;/code&gt; 选项来保存数据包而不是在屏幕上显示出抓取的数据包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;tcpdump 将数据包保存在二进制文件中，所以不能简单的用文本编辑器去打开它。使用 &lt;code&gt;-r&lt;/code&gt; 选项参数来阅读该文件中的报文内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;tcpdump -nn -r webserver.pcap&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用 host 参数只抓取和特定主机相关的数据包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo tcpdump -i any -c5 -nn host 54.204.39.132&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用括号来创建更为复杂的过滤规则，但在 shell 中请用引号包含你的过滤规则以防止被识别为 shell 表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo tcpdump -i any -c5 -nn &quot;port 80 and (src 192.168.122.98 or src 54.204.39.132)&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;src&lt;/code&gt; 抓取源 IP 地址&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;dst&lt;/code&gt; 就是按目的 IP/主机名来筛选数据包&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;and&lt;/code&gt; 以及 &lt;code&gt;or&lt;/code&gt; 逻辑操作符来创建过滤规则&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;unzip&quot;&gt;unzip&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;unzip -l demo1-0.1-py2.7.egg&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;unzip -o -d /home/sunny myfile.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把myfile.zip文件解压到 &lt;code&gt;/home/sunny/&lt;/code&gt;&lt;br/&gt;&lt;code&gt;-o&lt;/code&gt;:不提示的情况下覆盖文件；&lt;br/&gt;&lt;code&gt;-d&lt;/code&gt;:-d /home/sunny 指明将文件解压缩到/home/sunny目录下；&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;wc&quot;&gt;wc&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;wc [-clw][--help][--version][文件...]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-c或--bytes或--chars 只显示Bytes数。
-l或--lines 只显示行数。
-w或--words 只显示字数。
--help 在线帮助。
--version 显示版本信息。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;who&quot;&gt;who&lt;/h2&gt;
&lt;p&gt;who //显示当前登录系统的用户&lt;br/&gt;显示标题栏&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# who -H&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只显示当前用户&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# who -m -H&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;wget&quot;&gt;wget&lt;/h2&gt;
&lt;p&gt;将远程目录下的全部内容下载到&lt;code&gt;save目录下&lt;/code&gt;。&lt;code&gt;-nd&lt;/code&gt;参数表示，如果远程目录下也有子目录，会将子目录中的文件下载下来而不创建多余目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget -r -np -nd -R &quot;index.html*&quot; -P test http://xxx/FusionUpgrade/master/euler/20181101130551/ # 注意，URL末尾需要有/，否则会递归下载的&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;-r：递归下载，下载指定网页某一目录下（包括子目录）的所有文件&lt;/li&gt;
&lt;li&gt;-nd:–-no-directories 不创建目录&lt;/li&gt;
&lt;li&gt;-np：–-no-parent 不要追溯到父目录&lt;/li&gt;
&lt;li&gt;P:指定下载下来的存放目录，没有会自动创建&lt;/li&gt;
&lt;li&gt;-nH:–-no-host-directories 不创建主机目录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例2：&lt;/p&gt;
&lt;p&gt;将远程文件夹原封不动下载下来，并且下载下来的本地路径也是远程目录，而不会创建多级目录。&lt;code&gt;-nH&lt;/code&gt;表示不会创建&lt;br/&gt;&lt;code&gt;xxx.com&lt;/code&gt;目录，&lt;code&gt;--cut-dirs&lt;/code&gt;将其余多余层级目录不下载，实现效果下载到本地就只是&lt;code&gt;DLRN_RPMS&lt;/code&gt;目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wget -r -p -k -np -nH --cut-dirs=4 http://xxx.com/cps/FusionNetwork-for-fc/master/suse/DLRN_RPMS/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;watch&quot;&gt;watch&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;watch -d 'ls -l|grep scf'       # 监测当前目录中 scf' 的文件的变化
watch -n 10 'cat /proc/loadavg' # 10秒一次输出系统的平均负载
watch -n 1 -d netstat -ant       # 命令：每隔一秒高亮显示网络链接数的变化情况&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;h2 id=&quot;systemd-service服务&quot;&gt;systemd service服务&lt;/h2&gt;
&lt;h2 id=&quot;xargs&quot;&gt;xargs&lt;/h2&gt;
&lt;p&gt;为了快速修改后缀名字&lt;/p&gt;
&lt;p&gt;源文件夹下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CentOS-base.repo.repo.bak
epel.repo.repo.bak&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法一：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ls *.bak|awk -F. '{print $1}'|xargs -t -i mv {}.repo.repo.bak {}.repo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小伙伴们觉得有用的话，动动手指点个「推荐」吧 :)&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 15:14:00 +0000</pubDate>
<dc:creator>Michael_翔</dc:creator>
<og:description>[toc] awk 示例： env变量值如下，需要获得pkg_url的链接值： F 指定分隔规则，因为分隔规则中包含了双引号，所以需要用转义符号。 'awk print函数' 'printf+awk完</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/michael-xiang/p/10404016.html</dc:identifier>
</item>
<item>
<title>约瑟夫环问题解决采用闭包函数实现 - friendwrite</title>
<link>http://www.cnblogs.com/friendwrite/p/10403995.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/friendwrite/p/10403995.html</guid>
<description>&lt;p&gt;约瑟夫环问题采用最优算法实现，主要采用php的闭包函数（用于回调且没有函数名的函数），结合php自带的数组函数 array_keys  获取数组键值函数、&lt;/p&gt;
&lt;p&gt;array_values 获取数组元素值函数、其中最重要的数组函数array_splice()数组定向指定位置移除函数。&lt;/p&gt;
&lt;p&gt;　　约瑟夫环问简述：一 群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停的 进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt; monkey(&lt;span&gt;$n&lt;/span&gt;,&lt;span&gt;$m&lt;/span&gt;&lt;span&gt;){
    &lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt;=&lt;span&gt;range&lt;/span&gt;(1,&lt;span&gt;$n&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;$fn&lt;/span&gt;=&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;$m&lt;/span&gt;,&amp;amp;&lt;span&gt;$arr&lt;/span&gt;)&lt;span&gt;use&lt;/span&gt;(&amp;amp;&lt;span&gt;$fn&lt;/span&gt;&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;)==1&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;$arrKey&lt;/span&gt;=&lt;span&gt;array_keys&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;)&amp;gt;=&lt;span&gt;$m&lt;/span&gt;&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;$arrKey=array_keys($arr);&lt;/span&gt;
            &lt;span&gt;$key&lt;/span&gt;=&lt;span&gt;$arrKey&lt;/span&gt;[&lt;span&gt;$m&lt;/span&gt;-1&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;unset&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$key&lt;/span&gt;&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;$arr&lt;/span&gt;=&lt;span&gt;array_merge&lt;/span&gt;(&lt;span&gt;array_splice&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;,&lt;span&gt;$m&lt;/span&gt;-1),&lt;span&gt;array_splice&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;,0,&lt;span&gt;$m&lt;/span&gt;-1&lt;span&gt;));
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;$fla&lt;/span&gt;=&lt;span&gt;$m&lt;/span&gt;%&lt;span&gt;count&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;$key&lt;/span&gt;=&lt;span&gt;$arrKey&lt;/span&gt;[&lt;span&gt;$fla&lt;/span&gt;-1&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;unset&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;[&lt;span&gt;$key&lt;/span&gt;&lt;span&gt;]);

        }
        &lt;/span&gt;&lt;span&gt;$fn&lt;/span&gt;(&lt;span&gt;$m&lt;/span&gt;,&lt;span&gt;$arr&lt;/span&gt;&lt;span&gt;);
    };

    &lt;/span&gt;&lt;span&gt;$fn&lt;/span&gt;(&lt;span&gt;$m&lt;/span&gt;,&lt;span&gt;$arr&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;$value&lt;/span&gt;=&lt;span&gt;array_values&lt;/span&gt;(&lt;span&gt;$arr&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;$value&lt;/span&gt;['0'&lt;span&gt;];
}
monkey(&lt;/span&gt;5,3);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;时间复杂度分析：&lt;/p&gt;
&lt;p&gt;，对于时间复杂度，要通过逻辑思考，回调函数要执行(n-m)次合并数组，回调函数要执行($m)次取模，表达式为：(n-m)+m大O表达为：O(n);&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 15:11:00 +0000</pubDate>
<dc:creator>friendwrite</dc:creator>
<og:description>约瑟夫环问题采用最优算法实现，主要采用php的闭包函数（用于回调且没有函数名的函数），结合php自带的数组函数 array_keys 获取数组键值函数、 array_values 获取数组元</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/friendwrite/p/10403995.html</dc:identifier>
</item>
<item>
<title>解决chrome无法启用印象笔记-剪藏功能 - 寻找任大侠</title>
<link>http://www.cnblogs.com/xunzhaorendaxia/p/10403984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xunzhaorendaxia/p/10403984.html</guid>
<description>&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;   　新版Chrome浏览器安全的问题，导致从印象笔记官网下载的rxs（crx）文件无法直接通过drap&amp;amp;drop功能添加功能块。可以将rxs（crx）文件后缀名改成rar格式，然后解压，通过CH浏览器扩展界面勾选开发者选项，然后点击加载解压包选项，选择刚才解压出的目录即可。重新F5刷新一下页面。印象笔记拓展程序就可以用了。&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Tue, 19 Feb 2019 15:08:00 +0000</pubDate>
<dc:creator>寻找任大侠</dc:creator>
<og:description>新版Chrome浏览器安全的问题，导致从印象笔记官网下载的rxs（crx）文件无法直接通过drap&amp;drop功能添加功能块。可以将rxs（crx）文件后缀名改成rar格式，然后解压，通过CH浏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xunzhaorendaxia/p/10403984.html</dc:identifier>
</item>
<item>
<title>可变类型变量(列表、字典等)定为函数默认值时的陷阱 - 白桦林_HK</title>
<link>http://www.cnblogs.com/baihualin/p/10403942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baihualin/p/10403942.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt;可变类型变量在函数默认值中的一坑，以后大家记得绕着走，话不多说，上代码！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;可变类型变量列表测试：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; abc(a=&lt;span&gt;[]):
    a.append(&lt;/span&gt;123&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
abc()
abc()&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时大家可能觉得应该输出如下内容：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[123&lt;span&gt;]
[&lt;/span&gt;123]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其实不然，实际情况如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[123&lt;span&gt;]
[&lt;/span&gt;123, 123]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;那换另一个可变类型变量字典试下呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; abc(a=&lt;span&gt;{}):
    a[random.randint(&lt;/span&gt;1, 5)] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
abc()
abc()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时大家可能觉得应该输出如下内容：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
{随机值: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{随机值: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其实不然，实际情况如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
{2: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;}
{&lt;/span&gt;2: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, 3: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;那么换成不可变类型变量会是怎样的呢？那么拿字符串来举例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; abc(a=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;):
    a &lt;/span&gt;= a + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
abc()
abc()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;按照上面的惯性大家可能会以为输出结果为下面这样：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实不然，实际情况如下：&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、表象：在python中可变类型变量作为默认值赋给函数时，多次调用该函数实际只初始化一次，这看起来好像是个bug。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、本质：在python中对不可变类型(比如字符串)进行修改后其实不是对原本的值进行了更改(不可变类型之所以叫不可变类型就是值是固定的，不可修改)，而是又开辟了一块新内存来新创建了一个值，然后再将变量指向这个新值的内存地址&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
def abc(a=[]):  ===&amp;gt;假设此处空列表位于内存0x00001111
    a.append(123)  ===&amp;gt;将内存0x00001111的值增加了一个“123”
    print(a)
abc()
abc() ====&amp;gt;第二次调用时a的默认值其实还是原来的空列表内存处的值，即0x00001111，只不过此时该值增加了一个“123”


def abc(a=''):   ===&amp;gt;假设此处空列表位于内存0x00001111
    a = a + '1'  ===&amp;gt;由于字符串为不可变类型，故此处其实是将a指向了另外一个内存空间，假设为0x00002222，而在0x00002222处存放了一个&quot;1&quot;
    print(a)
abc()
abc() ====&amp;gt;第二次调用时a的默认值其实还是原来的空字符串内存处的值，即0x00001111，由于上一次变化是将a指向了另外一个值，所以此处的值还为空字符串
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;如需要可变类型变量作为默认值时可以采用如下方法：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; abc(a=&lt;span&gt;None):
    a &lt;/span&gt;=&lt;span&gt; []
    a.append(&lt;/span&gt;123&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
abc()
abc()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出结果为：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[123&lt;span&gt;]
[&lt;/span&gt;123]
&lt;/pre&gt;&lt;/div&gt;




</description>
<pubDate>Tue, 19 Feb 2019 15:01:00 +0000</pubDate>
<dc:creator>白桦林_HK</dc:creator>
<og:description>可变类型变量在函数默认值中的一坑，以后大家记得绕着走，话不多说，上代码！ 可变类型变量列表测试： 此时大家可能觉得应该输出如下内容： 其实不然，实际情况如下： 那换另一个可变类型变量字典试下呢？ 此时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baihualin/p/10403942.html</dc:identifier>
</item>
<item>
<title>爸爸又给Spring MVC生了个弟弟叫Spring WebFlux - 李新杰</title>
<link>http://www.cnblogs.com/lixinjie/p/a-brother-of-spring-mvc-is-spring-webflux.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/a-brother-of-spring-mvc-is-spring-webflux.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;情景引入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很早之前，Java就火起来了，是因为它善于开发和处理网络方面的应用。&lt;/p&gt;&lt;p&gt;Java有一个爱好，就是喜欢制定规范标准，但自己又不善于去实现。&lt;/p&gt;&lt;p&gt;反倒是一些服务提供商使用它的规范标准来制造应用服务器而赚的盆满钵满。&lt;/p&gt;&lt;p&gt;企业用户因要使用这些应用服务器而向提供商支付高额费用，而且也不是特别好用。&lt;/p&gt;&lt;p&gt;一个青年才俊为了打破这种局面而奔走呼号、奋发图强。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;自我介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;显然，这个青年才俊就是后来的Spring。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;因企业应用大都和web相关，而Java的web标准中较核心的一部分其实就是JavaEE里的Servlet。&lt;/p&gt;&lt;p&gt;Spring和Servlet“相亲相爱”一番后，我就来到了这个世界。我的全名叫Spring MVC，这里的Spring既是我的姓也是我的“爸爸”，那Servlet就是我的“妈妈”了，大家叫我MVC就行了。&lt;/p&gt;&lt;p&gt;那个年代社会很落后，条件也不好，好歹我们要求也不高，求个温饱就行了。&lt;/p&gt;&lt;p&gt;所以我的妈妈Servlet和她的闺蜜Filter天生就是同步阻塞的，包括她们同事HttpServletRequest的getParameter，getPart等这些方法也都是阻塞的。&lt;/p&gt;&lt;p&gt;虽然我的爸爸Spring给了我23条染色体来进行改良，但不要忘了我还从Servlet妈妈那里继承了23条，所以我也是同步阻塞的。不过我的“长相”已经好看很多了，因为Spring爸爸知道，在以后的日子里，除了拼实力之外，颜值也是非常重要的。&lt;/p&gt;&lt;p&gt;因为我妈妈Servlet是一个规范，我爸爸Spring是一个框架，所以我跟他们一样，都是无法自己独立运行的。&lt;/p&gt;&lt;p&gt;所以在我们要运行的时候，必须要寻找一个特殊的“家”，通常称它为Servlet容器，比如tomcat就算非常知名的一个。&lt;/p&gt;&lt;p&gt;Servlet容器熟知我极有可能阻塞当前执行线程，所以专门量身打造。它给我准备了一个非常大的线程池，里面有好多线程。每过来一个请求，它就扔给我一个线程，说自己玩去吧，随便“折腾”。&lt;/p&gt;&lt;p&gt;好在那时美国那个叫乔布斯的家伙被自己的公司赶出去在外面“流浪”，Servlet容器为我量身打造的这种方法完全能够胜任日常，关键还非常的简单。&lt;/p&gt;&lt;p&gt;这种小富即安的日子就这样往前过着。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;兄弟出生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;生命不息，变化不止。随着乔布斯推出iphone，智能机瞬间大火，全民进入移动互联网时代。激增的网民数量，给现有软件架构带来极大的挑战。&lt;/p&gt;&lt;p&gt;一般来说，社会越发达，分工越精细，对单一工种的要求就越高。&lt;/p&gt;&lt;p&gt;软件也是如此，在传统“大块头”软件表现的越来越格格不入的时候，微服务就如一丝春风吹了进来。&lt;/p&gt;&lt;p&gt;按它的指导原则，将大软件按某种方式拆分为一个个小工程。小工程规模小，便于管理，而且机动性也好，功能聚合性更好。它承受的并发应该更高。&lt;/p&gt;&lt;p&gt;有人觉得与微服务比起来，过去使用的web服务器如tomcat略显笨重，不够轻量级。也有人说tomcat内部一个请求一个线程这种阻塞执行方式消耗太多线程，不太容易支撑超高并发。&lt;/p&gt;&lt;p&gt;无论怎么说，简而言之一句话，一个全新的时代已经到来。&lt;/p&gt;&lt;p&gt;此时我们需要一个更加轻量级web应用，它使用更少的硬件资源和线程，反而更容易处理高并发。那么它一定是异步非阻塞的。&lt;/p&gt;&lt;p&gt;这样的使命自然落到了响应式编程的范畴上了。所以我的爸爸Spring审时度势，在5.0之后就赶紧把我推出来了。&lt;/p&gt;&lt;p&gt;没错，我就是Spring WebFlux，这里的Spring既是我的姓也是我爸爸。大家可以叫我WebFlux。初来乍到，好多人都对我不熟悉，请容许我介绍一番。&lt;/p&gt;&lt;p&gt;首先这个响应式究竟是什么意思呢？响应式这个术语，指的是一个编程模型，它是围绕着对变化的反映来构建的。&lt;/p&gt;&lt;p&gt;如网络组件用来响应I/O事件，UI控制器用来响应鼠标事件等等。按照这种意识的话，非阻塞就是响应式的，对操作完成或数据可用通知事件的响应方式。&lt;/p&gt;&lt;p&gt;另外一个关于响应式的机制是非阻塞后压。在命令式代码中，同步阻塞调用带有自然的后压迫使调用者等待。&lt;/p&gt;&lt;p&gt;在异步代码中，它变得非常重要，用来控制事件的速率，以至于不让一个快速的事件源压垮它的响应者。就是响应者能够控制事件源发射事件的快慢。&lt;/p&gt;&lt;p&gt;因为响应式编程是非阻塞的，所以我也是非阻塞的，因此我通常运行在非阻塞web服务器上，如Netty，Undertow等。&lt;/p&gt;&lt;p&gt;因为我不会阻塞线程的执行，所以使用一个小的固定数量的线程池（event loop workers）来处理请求。典型地，线程数与CPU的核数相同。&lt;/p&gt;&lt;p&gt;这里还要感谢我的姥爷Java 8，他老人家引入了lambda表达式造就了函数式编程API。这对于非阻塞应用和连续式API来说是一个非常棒的东西，允许以声明的方式把异步逻辑组合起来。&lt;/p&gt;&lt;p&gt;我感觉我的爸爸Spring已经超越了一个框架，成为一个平台了。所以他自己并没有亲自去实现响应式处理，而是为我选择Reactor作为响应式库。&lt;/p&gt;&lt;p&gt;Reactor提供Flux和Mono类型，拥有丰富的操作符，支持非阻塞后压，使用函数式API来组合异步逻辑。并且Reactor强烈聚焦于Java服务器端。它在开发时就已经与爸爸Spring亲密协作了。&lt;/p&gt;&lt;p&gt;爸爸说，我也支持其它的库如RxJava，但看样子似乎让我更爱Reactor一些。&lt;/p&gt;&lt;p&gt;这就是我，WebFlux，一个集天时地利于一身的幸运儿。但你是不是已经晕晕的啦，没关系，慢慢来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;包罗万象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我想，大家都看出了我爸爸Spring的野心，他不仅要成为一个平台，还要建起自己的生态系统，竖起壁垒。&lt;/p&gt;&lt;p&gt;所以他的核心事业就是进行抽象，组合和装配，进而包罗万象。说的掉渣一些，就是哪个技术好，就给它整合进来。&lt;/p&gt;&lt;p&gt;为了抹平底层不同web服务器的差异，我爸爸抽象了一个最低级别的契约接口，HttpHandler，用于响应式HTTP请求的处理。&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;Mono&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Void&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerHttpRequest&lt;/span&gt; &lt;span class=&quot;&quot;&gt;request&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;ServerHttpResponse&lt;/span&gt; &lt;span class=&quot;&quot;&gt;response&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;它是一个通用的接口，要横跨不同的运行时。它是有意设计成最小化的，只有一个方法，主要唯一目的就是在不同的HTTP服务器API上面成为一个最小化的抽象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果想用Netty服务器的话，就基于Netty实现一下，同理也可以基于Undertow实现一下，等等，只要以后有了新的服务器，都可以加进来的。&lt;/p&gt;&lt;p&gt;显而易见，HttpHandler的目标是抽象出来对不同HTTP服务器的使用，说白了就是为了和底层服务器对接。但由于太偏底层，不利用上层代码使用。&lt;/p&gt;&lt;p&gt;为此，我的爸爸又抽象出一个稍微高一点级别的契约接口，WebHandler，用于Web请求处理。很明显，WebHandler的目标是提供web应用中广泛使用的通用特性，如Session、表单数据和附件等等，也是为了更容易和上层代码对接。&lt;/p&gt;&lt;p&gt;很自然的，WebHandler是构建于HttpHandler之上的，换句话说WebHander的处理会通过一个适配器HttpWebHandlerAdapter最终代理给HttpHandler来执行。&lt;/p&gt;&lt;p&gt;WebHandler接口也只有一个方法：&lt;br/&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;Mono&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Void&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerWebExchange&lt;/span&gt; &lt;span class=&quot;&quot;&gt;exchange&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;参数类型是ServerWebExchange，可以这样理解，你发一个请求，给你一个响应，相当于用请求交换了一个响应，而且是在服务器端交换的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;其实，整个web请求的处理过程是一个链式的，最后才是一个WebHandler，它前面可以插入多个错误处理器，WebExceptionHandler，多个过滤器，WebFilter。&lt;/p&gt;&lt;p&gt;这是错误处理器接口：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;Mono&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Void&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;handle&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerWebExchange&lt;/span&gt; &lt;span class=&quot;&quot;&gt;exchange&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Throwable&lt;/span&gt; &lt;span class=&quot;&quot;&gt;ex&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;这是过滤器接口：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;Mono&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;java&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;&quot;&gt;.Void&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;filter&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerWebExchange&lt;/span&gt; &lt;span class=&quot;&quot;&gt;exchange&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;WebFilterChain&lt;/span&gt; &lt;span class=&quot;&quot;&gt;chain&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;可见，我的爸爸Spring的抽象能力非常强，对下抽象一个接口，抹平了不同服务器的差异。对上抽象一个接口，可以用于支撑不同的编程模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;都有哪些编程模型呢，请继续往下看吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;皮囊之下&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面我在介绍自己的时候使用了美颜，所以诸位很难看清我的“真面目”，下面就来进行一下自我剖析，看看真实的我。&lt;/p&gt;&lt;p&gt;我包含一个轻量级函数式编程模型，函数被用来参与处理请求，它是相对于基于注解编程模型的另一种选择，这种编程模型叫做函数式端点，functional endpoints，是构建于上面提到的WebHandler之上的。&lt;/p&gt;&lt;p&gt;我是使用HandlerFunction来处理一个HTTP请求的，这是一个函数式接口，也称处理函数：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;HandlerFunction&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;&quot;&gt;ServerResponse&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;reactor.core.publisher.&lt;span class=&quot;&quot;&gt;Mono&amp;lt;T&amp;gt; &lt;span class=&quot;&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(ServerRequest request)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;带有一个ServerRequest参数，返回一个Mono&amp;lt;ServerResponse&amp;gt;，其中request和response对象都是不可变的，HandlerFunction就等价于Controller中的@RequestMapping标记的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;实际当中，请求很多，处理函数也很多，如何知道一个请求过来后，该由哪个处理函数去处理呢？&lt;/p&gt;&lt;p&gt;这自然要用到我的另一个函数式接口RouterFunction来搞定，称为路由函数：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;@FunctionalInterface&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;RouterFunction&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;&quot;&gt;ServerResponse&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;reactor.core.publisher.Mono&amp;lt;HandlerFunction&amp;lt;T&amp;gt;&amp;gt; route(ServerRequest request);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;带有一个ServerRequest参数，返回一个Mono&amp;lt;HandlerFunction&amp;gt;。就是它把一个请求路由到一个HandlerFunction的，当路由函数匹配时，就返回一个处理函数，否则返回一个空的Mono。RouterFunction等价于@RequestMapping注解，但主要不同的是路由函数提供的不仅是数据，还有行为。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面通过一些示例，来更加直观的帮助大家认识这两个函数式接口。&lt;/p&gt;&lt;p&gt;因处理函数是函数式接口，所以可以直接用一个lambda表达式来处理请求，如下：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;HandlerFunction&amp;lt;ServerResponse&amp;gt; handler = &lt;span class=&quot;&quot;&gt;request&lt;/span&gt; -&amp;gt; &lt;span class=&quot;&quot;&gt;Response&lt;/span&gt;.ok().body(&lt;span class=&quot;&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;这就表示当任何一个请求过来时，都返回Hello World作为响应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在实际应用中，处理逻辑一般都很复杂，肯定不是一个lambda表达式能搞定的，此时希望把处理方法专门写到一个类里，就叫处理器类，和MVC里的Controller差不多一回事。&lt;/p&gt;&lt;p&gt;下面就是一个Person的处理器类：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;&quot;&gt;PersonHandler&lt;/span&gt; {&lt;p&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;&quot;&gt;listPeople&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerRequest request&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;&quot;&gt;createPerson&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerRequest request&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; Mono&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;&quot;&gt;getPerson&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;ServerRequest request&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;此时就可以通过处理函数，引用这些处理器方法了，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;6&quot;&gt;PersonHandler handler = &lt;span class=&quot;&quot;&gt;new&lt;/span&gt; PersonHandler();&lt;p&gt;HandlerFunction&amp;lt;ServerResponse&amp;gt; &lt;span class=&quot;&quot;&gt;list&lt;/span&gt; = handler::listPeople;&lt;/p&gt;&lt;p&gt;HandlerFunction&amp;lt;ServerResponse&amp;gt; create = handler::createPerson;&lt;/p&gt;&lt;p&gt;HandlerFunction&amp;lt;ServerResponse&amp;gt; get = handler::getPerson;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;要想使请求能够正确被路由，首先要定义好路由函数，如下：&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;6&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;RouterFunction&amp;lt;ServerResponse&amp;gt; route = RouterFunctions.route()&lt;br/&gt;.&lt;span class=&quot;&quot;&gt;GET&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;/person/{id}&quot;&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;get&lt;/span&gt;)&lt;br/&gt;.&lt;span class=&quot;&quot;&gt;GET&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&quot;/person&quot;&lt;/span&gt;, list)&lt;br/&gt;.POST(&lt;span class=&quot;&quot;&gt;&quot;/person&quot;&lt;/span&gt;, create)&lt;br/&gt;.build();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;它表示当以GET方法请求/person/{id}时，最终会由getPerson方法处理。当以GET方法请求/person时，最后会由listPeople方法处理。同理，以POST方法请求/person时，会由createPerson方法处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;可见，一个路由函数可以包含多个路由规则，实际当中，可以定义多个路由函数，这些路由函数可以组合在一起。&lt;/p&gt;&lt;p&gt;路由函数是按顺序计算的，如果第一个路由不匹配，计算第二个，等等。因此，把更加具体的路由放到通用路由前面是非常有意义的。注意这和基于注解的不同。&lt;/p&gt;&lt;p&gt;怎么样，关掉滤镜的我是不是更加真实了。我相信你也看明白了，至少要记住，这是基于函数式的一种编程模型，叫做函数式端点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;雨露均沾&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;像我这样的幸运儿，你们一定以为Spring爸爸对我非常溺爱吧，告诉你，确实是这样的。不过考虑到大家伙一路走来对Spring的不离不弃，爸爸也设身处地为你们着想。&lt;/p&gt;&lt;p&gt;为此，我除了支持函数式端点这种编程模型之外，还支持一种编程模型叫基于注解的控制器，annotated controllers，没错，就是MVC里的那个。&lt;/p&gt;&lt;p&gt;话说的再白一些，就是大家已经非常熟悉的Spring MVC那套东西，我百分之百的完全支持，妥妥的，放心使用。&lt;/p&gt;&lt;p&gt;但是，并不是所有的控制器方法参数都支持响应式类型，只有一些支持，如WebSession，java.security.Principal，@RequestBody，HttpEntity&amp;lt;B&amp;gt;，@RequestPart等。&lt;/p&gt;&lt;p&gt;下面看一个示例：&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;5&quot;&gt;&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;&quot;&gt;@PostMapping(&lt;span class=&quot;&quot;&gt;&quot;/&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; String handle(&lt;span class=&quot;&quot;&gt;@RequestBody&lt;/span&gt; Mono&amp;lt;MultiValueMap&amp;lt;String, Part&amp;gt;&amp;gt; parts) { &lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;&quot;&gt;@PostMapping(&lt;span class=&quot;&quot;&gt;&quot;/&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; String handle(&lt;span class=&quot;&quot;&gt;@RequestBody&lt;/span&gt; Flux&amp;lt;Part&amp;gt; parts) { &lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;@PostMapping(&lt;span class=&quot;&quot;&gt;&quot;/accounts&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; void handle(&lt;span class=&quot;&quot;&gt;@RequestBody&lt;/span&gt; Mono&amp;lt;Account&amp;gt; account) {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;不过对于控制器方法的所有返回值，都是支持响应式类型的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;各有千秋&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Spring MVC和Spring WebFlux可以一起使用，从设计上讲，它们互为继续、互为一致。&lt;/p&gt;&lt;p&gt;它们的关系，请看下图，既有共同的部分，也有互相独立的部分。&lt;br/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201902/76066-20190219222515699-1633837851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;Spring MVC的特点就是，它是命令式编程，代码非常容易写，也好理解和调试。但是它是同步的，会有人觉得它性能不好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;但是我要说的是，响应式和非阻塞通常来讲也不会使应用运行的更快。相反，非阻塞方式要求做更多的事情，而且还会稍微增加一些必要的处理时间。也就是说，还可能稍稍变慢一点，what，那为啥还要用它呢？&lt;/p&gt;&lt;p&gt;响应式和非阻塞的关键好处是，在使用很少固定数目的线程和较少的内存情况下的扩展能力。&lt;/p&gt;&lt;p&gt;这使应用在负载下更有适应能力，因为它们以一个更加具有可预见性的方式在扩展。&lt;/p&gt;&lt;p&gt;为了能够观察到这些好处，你需要有一些延迟才行，比如一个既不可靠且速度又慢的网络I/O，这才是响应式开始展示它强劲的地方，带来的差异（惊喜）可能是巨大的哦。&lt;/p&gt;&lt;p&gt;其实技术无好坏，各有各的适用场景罢了。&lt;br/&gt;&lt;/p&gt;



&lt;p&gt;（完）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;编程新说&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr data-width=&quot;80%&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;用独特的视角说技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201901/76066-20190124185847216-1263582225.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 14:31:00 +0000</pubDate>
<dc:creator>李新杰</dc:creator>
<og:description>情景引入 很早之前，Java就火起来了，是因为它善于开发和处理网络方面的应用。 Java有一个爱好，就是喜欢制定规范标准，但自己又不善于去实现。 反倒是一些服务提供商使用它的规范标准来制造应用服务器而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lixinjie/p/a-brother-of-spring-mvc-is-spring-webflux.html</dc:identifier>
</item>
<item>
<title>Angular6.x学习笔记——内容投影, ViewChild和ContentChild - 半路独行</title>
<link>http://www.cnblogs.com/banluduxing/p/10394387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/banluduxing/p/10394387.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;内容投影&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1为什么需要内容投影?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一个事物的出现,必然存在它所能解决的问题,让我们先从问题出发吧:&lt;/p&gt;
&lt;p&gt;大家应该都知道,在html规范里面,它定义了非常多的标签,在这些标签里面,相同标签之间的嵌套,不同标签之间的嵌套,是十分常见,并且可行&lt;/p&gt;
&lt;p&gt;同时,在Angular里面,我们可以通过自定义标签的方式引用组件,那么这里的标签能否像原生的html标签一样,来嵌入html标签,或者嵌套其他组件标签呢?&lt;/p&gt;
&lt;p&gt;于是就引入我们今天的主要问题,用一个详细的例子来描述吧:&lt;/p&gt;
&lt;p&gt;假设存在父组件Content,和它下面2个子组件PartA和PartB,自定义标签分别为:&amp;lt;app-content&amp;gt;,&amp;lt;app-content-part-a&amp;gt;,&amp;lt;app-content-part-b&amp;gt;,如果想在父组件的视图里面,完成下面的内容,是否可行呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; content.component.html &lt;p&gt;1&lt;/p&gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Content&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;app-content-part-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PartA--start&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;app-content-part-b&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;app-content-part-b&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;PartA--end&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;app-content-part-a&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样是不行的,其结果只会显示自定义的组件&amp;lt;app-content-part-a&amp;gt;自身的内容,因为自定义组件标签会忽略嵌套其中的html原生标签或者其他的自定义组件标签,从而使它们无法产生任何效果&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2如何使用内容投影?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述问题通过内容投影则能够解决,那么如何使用内容投影呢?&lt;/p&gt;
&lt;p&gt;只需要在组件PartA的视图里面做一些改动,内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; part-a.component.html&lt;p&gt;1&lt;/p&gt;&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-content &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;h1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-content &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;app-content-part-b&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ng-content &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;span&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ng-content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过这样的修改,上述想要实现的效果就可以达到&lt;/p&gt;
&lt;p&gt;那么内容投影是如何工作的呢?&lt;/p&gt;
&lt;p&gt;首先通过angular里面的一个指令ng-content,实现占位,再通过select,达到选择器的作用,这样在组件生命周期过程,初始渲染投影内容的时候,就能够将对应的内容投影到特定的位置,这就是内容投影工作的简单描述&lt;/p&gt;
&lt;p&gt;组件里面嵌套组件,之间的通讯问题可以参考&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/banluduxing/p/9290569.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;组件间的通讯&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ContentChild和ViewChild   &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;                                                                              &lt;/p&gt;
&lt;p&gt;首先做个简单的介绍:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ContentChild&lt;/strong&gt;:与内容子节点有关,操作投影进来的内容;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ViewChild&lt;/strong&gt;:与视图子节点有关,操作自身的视图内容;&lt;/p&gt;
&lt;p&gt;在上一部分,我们通过内容投影,让自定义的组件标签能够嵌入html标签或自定义组件标签,那么它如何操作投影进来的内容呢?&lt;/p&gt;
&lt;p&gt;还是以上述内容为例,从实际的问题出发:假设嵌入的自定义组件标签&amp;lt;app-content-part-b&amp;gt;里面声明了一个方法func(),那么如何在&amp;lt;app-content-part-a&amp;gt;里面去操作这个方法呢?&lt;br/&gt;上面说过,ContentChild是操作投影进来的内容,那么在这里我们也可以通过它解决问题,在组件PartA内,通过ContentChild获取投影进来的组件PartB,并对它进行操作(部分代码在上一部分已经贴出,这一部分不予重复),代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; part-b.component.ts&lt;p&gt;1&lt;/p&gt;&lt;/span&gt; import { Component, OnInit,Output} &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@angular/core&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;@Component({
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   selector: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;app-content-part-b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   templateUrl: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-b.component.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   styleUrls: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-b.component.scss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; export &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PartBComponent implements OnInit {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  constructor() { }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  ngOnInit() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;public&lt;/span&gt; func():&lt;span&gt;void&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;    console.log(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PartB&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  } 
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; part-a.component.ts&lt;p&gt;1&lt;/p&gt;&lt;/span&gt; import { Component, OnInit, ContentChild } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@angular/core&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; import { PartBComponent } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../part-b/part-b.component&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Component({
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   selector: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;app-content-part-a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   templateUrl: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-a.component.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   styleUrls: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-a.component.scss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; export &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PartAComponent implements OnInit {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@ContentChild(PartBComponent) PartB:PartBComponent
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;  constructor() { }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;  ngOnInit() {}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;   ngAfterContentInit(): &lt;span&gt;void&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.PartB.func();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意一点:在组件的生命周期里面,有一个钩子ngAfterContentInit()是与投影内容初始化有关,所以我们有关投影的内容操作尽量放在它初始化完成之后进行&lt;/p&gt;
&lt;p&gt; 如果理解了ContentChild的用法,那么ViewChild几乎没有理解难度,他们的差异不大,所不同的是:&lt;/p&gt;
&lt;p&gt;  1ViewChild是操作视图本身存在的节点,而不是投影进来的内容&lt;/p&gt;
&lt;p&gt;  2ngAfterContentInit()对应的是ngAfterViewInit()(视图节点初始化是在投影内容初始化之后)&lt;/p&gt;
&lt;p&gt;其他没有什么不同,这里我就不再赘述&lt;/p&gt;
&lt;p&gt; ContentChild和ViewChild还存在复数的形式,即ContentChildren和ViewChildren,它们取到的是节点的一个集合,其他的没有什么区别&lt;/p&gt;
&lt;p&gt;写法如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; import { Component, OnInit, ContentChild,ContentChildren ,QueryList } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;@angular/core&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; import { PartBComponent } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;../part-b/part-b.component&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Component({
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   selector: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;app-content-part-a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   templateUrl: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-a.component.html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   styleUrls: [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./part-a.component.scss&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; export &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PartAComponent implements OnInit {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;@ContentChildren(PartBComponent)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; PartBs: QueryList&amp;lt;PartBComponent&amp;gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;  constructor() { }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  ngOnInit() {}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码中PartBs是组件PartB的一个集合,这就是复数的用法,ViewChildren不再赘述&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;内容投影是一个比较容易理解而又实用的东西,再加上ContentChild的使用,使得我们不仅可以把内容投影进去,还能够加以操作&lt;/p&gt;

&lt;p&gt;学习参考资源(大漠穷秋):&lt;a href=&quot;http://www.ngfans.net/topic/12/post/2&quot; target=&quot;_blank&quot;&gt;http://www.ngfans.net/topic/12/post/2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;出自:博客园-半路独行&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://www.cnblogs.com/banluduxing/p/10394387.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/banluduxing/p/10394387.html&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/banluduxing/p/9290208.html&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文出自于&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 菜鸟的Xamarin.Forms前行之路——各种报错问题解决方法合集(不定时更新)&quot; href=&quot;http://www.cnblogs.com/banluduxing&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/banluduxing&lt;/a&gt; 转载请注明出处。&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 14:16:00 +0000</pubDate>
<dc:creator>半路独行</dc:creator>
<og:description>内容投影 1为什么需要内容投影? 一个事物的出现,必然存在它所能解决的问题,让我们先从问题出发吧: 大家应该都知道,在html规范里面,它定义了非常多的标签,在这些标签里面,相同标签之间的嵌套,不同标</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/banluduxing/p/10394387.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Gateway中异常处理 - 只喝牛奶的杀手</title>
<link>http://www.cnblogs.com/viaiu/p/10403557.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viaiu/p/10403557.html</guid>
<description>&lt;p&gt; 最近我们的项目在考虑使用Gateway，考虑使用Spring Cloud Gateway，发现网关的异常处理和spring boot 单体应用异常处理还是有很大区别的。让我们来回顾一下异常。&lt;/p&gt;
&lt;p&gt;关于异常是拿来干什么的，很多人老程序员认为就是拿来我们Debug的时候排错的，当然这一点确实是异常机制非常大的一个好处，但异常机制包含着更多的意义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;关注业务实现&lt;/strong&gt;。异常机制使得业务代码与异常处理代码可以分开，你可以将一些你调用数据库操作的代码写在一个方法里而只需要在方法上加上throw DB相关的异常。至于如何处理它，你可以在调用该方法的时候处理或者甚至选择不处理，而不是直接在该方法内部添加上if判断如果数据库操作错误该如何办，这样业务代码会非常混乱。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统一异常处理&lt;/strong&gt;。与上一点有所联系。我当前所在项目的实践是，自定义业务类异常，在Controller或Service中抛出，让后使用Spring提供的异常接口统一处理我们自己在内部抛出的异常。这样一个异常处理架构就非常明了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;程序的健壮性&lt;/strong&gt;。如果没有异常机制，那么来了个对空对象的某方法调用怎么办呢？直接让程序挂掉？这令人无法接受，当然，我们自己平时写的一些小的东西确实是这样，没有处理它，让后程序挂了。但在web框架中，可以利用异常处理机制捕获该异常并将错误信息传递给我们然后继续处理下个请求。所以异常对于健壮性是非常有帮助的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;异常处理（又称为错误处理）功能提供了处理程序运行时出现的任何意外或异常情况的方法。异常处理使用 try、catch 和 finally 关键字来尝试可能未成功的操作，处理失败，以及在事后清理资源。异常根据意义成三种：业务、系统、代码异常，不同的异常采用不同的处理方式。具体的什么样的异常怎么处理就不说了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/810680/201902/810680-20190219213503621-560199857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红线和绿线代表两条异常路径&lt;/p&gt;
&lt;p&gt;1，红线代表：请求到Gateway发生异常，可能由于后端app在启动或者是没启动&lt;/p&gt;
&lt;p&gt;2，绿线代表：请求到Gateway转发到后端app，后端app发生异常，然后Gateway转发后端异常到前端&lt;/p&gt;
&lt;p&gt;红线肯定是走Gateway自定义异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/810680/201902/810680-20190219214205865-413677260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两个类的代码如下（参考：http://cxytiandi.com/blog/detail/20548）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Configuration
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @EnableConfigurationProperties({ServerProperties.&lt;span&gt;class&lt;/span&gt;, ResourceProperties.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionHandlerConfiguration {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ServerProperties serverProperties;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ApplicationContext applicationContext;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ResourceProperties resourceProperties;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; List&amp;lt;ViewResolver&amp;gt;&lt;span&gt; viewResolvers;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ServerCodecConfigurer serverCodecConfigurer;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ExceptionHandlerConfiguration(ServerProperties serverProperties,
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                                         ResourceProperties resourceProperties,
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                                          ObjectProvider&amp;lt;List&amp;lt;ViewResolver&amp;gt;&amp;gt;&lt;span&gt; viewResolversProvider,
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                                         ServerCodecConfigurer serverCodecConfigurer,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                                         ApplicationContext applicationContext) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.serverProperties =&lt;span&gt; serverProperties;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.applicationContext =&lt;span&gt; applicationContext;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.resourceProperties =&lt;span&gt; resourceProperties;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.viewResolvers =&lt;span&gt; viewResolversProvider.getIfAvailable(Collections::emptyList);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.serverCodecConfigurer =&lt;span&gt; serverCodecConfigurer;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    @Order(Ordered.HIGHEST_PRECEDENCE)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ErrorWebExceptionHandler errorWebExceptionHandler(ErrorAttributes errorAttributes) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         JsonExceptionHandler exceptionHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonExceptionHandler(
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                errorAttributes,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resourceProperties,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serverProperties.getError(),
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.applicationContext);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         exceptionHandler.setViewResolvers(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.viewResolvers);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         exceptionHandler.setMessageWriters(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serverCodecConfigurer.getWriters());
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         exceptionHandler.setMessageReaders(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.serverCodecConfigurer.getReaders());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; exceptionHandler;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; JsonExceptionHandler &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; DefaultErrorWebExceptionHandler {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(JsonExceptionHandler.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonExceptionHandler(ErrorAttributes errorAttributes, ResourceProperties resourceProperties,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                                ErrorProperties errorProperties, ApplicationContext applicationContext) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(errorAttributes, resourceProperties, errorProperties, applicationContext);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;         * 获取异常属性
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; getErrorAttributes(ServerRequest request, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; includeStackTrace) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; code =&lt;span&gt; HttpStatus.INTERNAL_SERVER_ERROR.value();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             Throwable error = &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.getError(request);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (error &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; org.springframework.cloud.gateway.support.NotFoundException) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 code =&lt;span&gt; HttpStatus.NOT_FOUND.value();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; response(code, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.buildMessage(request, error));
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;         * 指定响应处理方法为JSON处理的方法
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorAttributes
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; RouterFunction&amp;lt;ServerResponse&amp;gt;&lt;span&gt; getRoutingFunction(ErrorAttributes errorAttributes) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; RouterFunctions.route(RequestPredicates.all(), &lt;span&gt;this&lt;/span&gt;&lt;span&gt;::renderErrorResponse);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;         * 根据code获取对应的HttpStatus
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorAttributes
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        @Override
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt; HttpStatus getHttpStatus(Map&amp;lt;String, Object&amp;gt;&lt;span&gt; errorAttributes) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; statusCode = (&lt;span&gt;int&lt;/span&gt;) errorAttributes.get(&quot;code&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; HttpStatus.valueOf(statusCode);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;         * 构建异常信息
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; ex
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String buildMessage(ServerRequest request, Throwable ex) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             StringBuilder message = &lt;span&gt;new&lt;/span&gt; StringBuilder(&quot;Failed to handle request [&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;            message.append(request.methodName());
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             message.append(&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            message.append(request.uri());
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             message.append(&quot;]&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (ex != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 message.append(&quot;: &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                message.append(ex.getMessage());
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; message.toString();
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;63&lt;/span&gt; &lt;span&gt;         * 构建返回的JSON数据格式
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; status        状态码
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; errorMessage  异常信息
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, Object&amp;gt; response(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; status, String errorMessage) {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             Map&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             map.put(&quot;code&quot;&lt;span&gt;, status);
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             map.put(&quot;message&quot;&lt;span&gt;, errorMessage);
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;             map.put(&quot;data&quot;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;            logger.error(map.toString());
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; &lt;span&gt;        }&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;绿线代表Gateway转发异常&lt;/p&gt;
&lt;p&gt;转发的异常，肯定是springboot单体中处理的，至于spring单体中的异常是怎么处理的呢？肯定是用@ControllerAdvice去做。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     @ExceptionHandler(value = Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @ResponseBody
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; AppResponse exceptionHandler(HttpServletRequest request, Exception e) {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         String ip =&lt;span&gt; RequestUtil.getIpAddress(request);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         logger.info(&quot;调用者IP：&quot; +&lt;span&gt; ip);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         String errorMessage = String.format(&quot;Url:[%s]%n{%s}&quot;&lt;span&gt;, request.getRequestURL().toString(), e.getMessage());
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        logger.error(errorMessage, e);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; AppResponse.error(HttpStatus.INTERNAL_SERVER_ERROR.value(), e.getMessage());
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里基本上可以了，大家不要试着去用Gateway去捕获后端异常，回到最初的起点，API 网关（API Gateway）主要负责服务请求路由、组合及协议转换，异常同样也是一样，Gateway只负责转发单体应用的异常，不要试图Gateway捕获后端服务异常，然后再输出给前端。感谢猿天地的一句惊醒梦中人！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/810680/201902/810680-20190219215930541-480230897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Feb 2019 14:02:00 +0000</pubDate>
<dc:creator>只喝牛奶的杀手</dc:creator>
<og:description>最近我们的项目在考虑使用Gateway，考虑使用Spring Cloud Gateway，发现网关的异常处理和spring boot 单体应用异常处理还是有很大区别的。让我们来回顾一下异常。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viaiu/p/10403557.html</dc:identifier>
</item>
<item>
<title>彻底搞清楚浏览器渲染过程 - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10403622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10403622.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在分析浏览器的渲染过程之前，我们先了解一下什么是进程和线程：&lt;/p&gt;
&lt;p&gt;（1）什么是进程？&lt;/p&gt;
&lt;p&gt;进程是CPU进行资源分配的基本单位&lt;/p&gt;
&lt;p&gt;（2）什么是线程？&lt;/p&gt;
&lt;p&gt;线程是CPU调度的最小单位，是建立在进程的基础上运行的单位，共享进程的内存空间。&lt;/p&gt;
&lt;p&gt;那么我们可以得出结论：&lt;/p&gt;
&lt;p&gt;1、进程是会占用系统资源；2、一个进程内可以存在一个或者多个线程，这就是单线程和多线程；3、无论是单线程还是多线程都是在一个进程内。&lt;/p&gt;
&lt;p&gt;博客首发地址（sau交流学习社区）：&lt;a href=&quot;https://www.mwcxs.top/page/567.html&quot; target=&quot;_blank&quot;&gt;https://www.mwcxs.top/page/567.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、多进程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/30kENgQ3YAc7yhpMVHg9kMEbob.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可知：&lt;/p&gt;
&lt;p&gt;1、浏览器是多进程&lt;/p&gt;
&lt;p&gt;2、不同类型的标签页都会开启一个新的进程&lt;/p&gt;
&lt;p&gt;3、相同类型的标签页是会合并到一个进程&lt;/p&gt;
&lt;p&gt;上图中浏览器的各个进程的主要作用：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、浏览器进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）负责管理各个标签页的创建和销毁&lt;/p&gt;
&lt;p&gt;（2）负责浏览器的页面显示和功能（前进，后退，收藏等）&lt;/p&gt;
&lt;p&gt;（3）负责资源的管理与下载&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、第三方插件进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）负责每个第三方插件的使用，每个第三方插件使用时候都会创建一个对应的进程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、GPU进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）负责3D绘制和硬件加速&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、浏览器渲染进程&lt;/strong&gt;（咱们这回主要分析的）&lt;/p&gt;
&lt;p&gt;1、浏览器内核，主要负责HTML，CSS，JS等文件的解析和执行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、浏览器内核&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器内核就是&lt;strong&gt;浏览器渲染进程&lt;/strong&gt;，从接收下载文件后再到呈现整个页面的过程，由浏览器渲染进程负责，主要流程如下：&lt;/p&gt;
&lt;p&gt;1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面&lt;/p&gt;
&lt;p&gt;2、执行解析js文件脚本代码&lt;/p&gt;
&lt;p&gt;这里主要讲浏览器页面渲染过程，js脚本解析执行过程，可以看这篇文章：&lt;span&gt;&lt;a href=&quot;https://www.mwcxs.top/page/564.html&quot; target=&quot;_blank&quot;&gt;Javascript引擎执行的过程的理解--执行阶段&lt;/a&gt; ，所以本文的js解析的内容会省略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在该过程中浏览器渲染进程会开启多个线程协作完成，主要的线程以及作用如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、GUI渲染线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）负责解析HTML文件构建DOM树，解析CSS，结合DOM树渲染成RenderObject树，然后布局和绘制页面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）当RenderObject树需要更新&lt;strong&gt;样式属性&lt;/strong&gt;时，即发生&lt;strong&gt;重绘&lt;/strong&gt;（Repaint）；当RenderObject树中的&lt;strong&gt;元素规则尺寸，布局或显示隐藏&lt;/strong&gt;等发生变化，即发生&lt;strong&gt;回流&lt;/strong&gt;（reflow）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、JS引擎线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、时间出发线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、定时器触发线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、异步Http请求线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：&lt;strong&gt;GUI渲染线程与JS引擎线程是相互排斥的，因为JS引擎线程在执行的过程中可能会发生重绘和回流，&lt;/strong&gt;所以GUI渲染线程执行时候，JS引擎线程会被挂起，等待GUI渲染线程执行完毕之后，JS引擎线程执行时候同理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.1GUI渲染线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先看一张图，图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.mwcxs.top/static/upload/pics/2019/1/30KeF3LDuZQNL1dtoFDGB1Wcje.jpg&quot; alt=&quot;timg&quot;/&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们主要分析GUI渲染线程执行的详细过程：&lt;/p&gt;
&lt;p&gt;1、解析HTML文件，构建DOM树，同时浏览器主进程负责下载CSS文件&lt;/p&gt;
&lt;p&gt;2、CSS文件下载完成，解析CSS文件成树形的数据结构，然后结合DOM树合并成RenderObject树&lt;/p&gt;
&lt;p&gt;3、布局RenderObject树，负责RenderObject树中的元素的尺寸，位置等计算&lt;/p&gt;
&lt;p&gt;4、绘制RenderObject树，绘制页面的像素信息&lt;/p&gt;
&lt;p&gt;5、浏览器主进程将默认的图层和复合图层交给GPU进程，GPU进程再将各个图层合成（conposite），最后显示出页面&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;1、默认图层指的是出于普通文档流的元素&lt;/p&gt;
&lt;p&gt;2、复合图层一般指的使用动画执行或者&amp;lt;video&amp;gt;&amp;lt;iframe&amp;gt;&amp;lt;canvas&amp;gt;&amp;lt;webgl&amp;gt;等元素，也可以使用z-index将层级高的元素变成复合图层，使用复合图层可以进行硬件加速，其原理是避免了默认图层的重绘和回流，想了解更深入介意自行研究&lt;/p&gt;

&lt;p&gt;了解GUI渲染线程的执行过程，我们可以根据原理进行渲染优化：&lt;/p&gt;
&lt;p&gt;1、尽可能早的提前引入css文件，例如在头部引入css文件。&lt;/p&gt;
&lt;p&gt;2、尽可能早的加载css文件中的引入的资源，例如自定义字体文件，可以使用预加载，在link标签中加入rel=“preload” as = “font”该元素属性，不会造成渲染阻塞。&lt;/p&gt;
&lt;p&gt;3、在DOM和CSS渲染之后加载js文件，例如在尾部加载js文件，或者使用该元素属性defer和async，进行js问价异步加载，但是不同的浏览器会有兼容性问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是介绍浏览器的渲染过程，但是没有分析js脚本文件解析过程。&lt;/p&gt;
&lt;p&gt;（一）浏览器渲染进程包含1、解析HTML文件和CSS文件，加载图片等资源文件，渲染成用户看到的页面；2、执行解析js文件脚本代码。&lt;/p&gt;
&lt;p&gt;（二）整个过程浏览器会开启多个线程协作完成，包括：GUI渲染线程，JS引擎线程，事件触发线程，定时器触发线程，异步HTTP请求线程。&lt;/p&gt;
&lt;p&gt;（三）其中GUI渲染线程和JS引擎线程是相互排斥的，因为JS引擎线程在执行的时候有可能会发生重绘和回流。&lt;/p&gt;

</description>
<pubDate>Tue, 19 Feb 2019 13:57:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>一、概述 在分析浏览器的渲染过程之前，我们先了解一下什么是进程和线程： （1）什么是进程？ 进程是CPU进行资源分配的基本单位 （2）什么是线程？ 线程是CPU调度的最小单位，是建立在进程的基础上运行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10403622.html</dc:identifier>
</item>
</channel>
</rss>