<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>中年程序员对核心竞争力“不可替代”的重新认识 - 猿界汪汪队</title>
<link>http://www.cnblogs.com/donlianli/p/11484280.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/donlianli/p/11484280.html</guid>
<description>&lt;p&gt;今天没有技术文章，谈谈最近体会深刻的道理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;职场新认识&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;观点一：过去成功的项目经验才是职场上真正不可代替的，你有成功的项目经验，能解决当前团队面临的最大问题，这个才是不可代替的；所以频繁跳槽的人通常要比在一个公司待长时间的人更有竞争力（从结果看，软件行业人才流动性高并不是中国人忠诚度不高）&lt;/p&gt;
&lt;p&gt;观点二：不可代替是暂时性的，问题解决，你的价值就已经开始下降和贬值，如果公司有新的业务要发展，而你如果没有相关经验的话，大概率会被淘汰；（所以说见好就收，及时调整成长路线才是发展的正确思路）&lt;/p&gt;
&lt;p&gt;观点三：一个技术员工技术的好坏，随着年龄的增大，越来越容易评价，有没有自己的作品，通常就是一个潜规则；但是从技术转型做管理的人，却很难被评价做的好还是坏，即便他做的很差，跳槽的时候也很难被新公司调查出来；而做技术的却很好评价，你有没有自己的作品，在行业名气如何，都能很快就调查出来；所以说如果你有机会做管理岗，还是尽快转吧；&lt;/p&gt;
&lt;p&gt;观点四、年龄越大，努力和勤奋越廉价，格局和职场人脉优势越明显；这个观点，应该比较容易认同，一个初入职场的新人，如果经常加班赶项目进度和学习，通常会得到领导的称赞和晋升；相反，如果一个领导整天加班，大家更觉得是敬业或者无法胜任所在的岗位；如果你现在正在靠加班和勤奋来发挥你的价值，你一定要抽出时间反思一下，这条路是无法长期持续的；别等到被通知的那一天追悔莫及；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;从另一角度来看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、公司需要持续创新来保证公司的竞争力。如何持续创新？当然是不断的尝试新业务，如何快速取得新业务的发展，人才引进当然是最快和最见效的方式，因而引出上面的观点一；&lt;/p&gt;
&lt;p&gt;2、创新是持续的，当新业务发展比较稳定后，新引入的人才和团队逐步稳定，此时，放任何人上去，一般都不会影响业务的持续稳定发展，引入的人才价值开始降低，因而证明观点二；&lt;/p&gt;
&lt;p&gt;3、当一个公司招聘一个高级技术人才时，如何判断物有所值？通常一个高级职位，几次简短的面试，很难甄别出一个技术人员的真正价值；这个时候，如果你在行业很有名气，或者有一个很好的技术作品，毫无疑问就提前有了“入场券”。举个最简单的例子，当年李开复在进入google之前，就已经在语音识别方面非常有名，后来只需一封email，简单走了一个流程，便进入了google；&lt;/p&gt;

&lt;p&gt;所以，无论你是正在迈向中年，还是已经中年，都应该及时回顾自己的职业发展路线，是否还在朝着正确的方向发展；&lt;/p&gt;
&lt;p&gt;也欢迎大家留言区交流；&lt;/p&gt;

&lt;p&gt;关注我的公众号“猿界汪汪队”,关注大并发架构实战。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/544558/201906/544558-20190622105830206-1507309394.jpg&quot; alt=&quot;&quot; width=&quot;258&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 08 Sep 2019 00:42:00 +0000</pubDate>
<dc:creator>猿界汪汪队</dc:creator>
<og:description>今天没有技术文章，谈谈最近体会深刻的道理。 职场新认识： 观点一：过去成功的项目经验才是职场上真正不可代替的，你有成功的项目经验，能解决当前团队面临的最大问题，这个才是不可代替的；所以频繁跳槽的人通常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/donlianli/p/11484280.html</dc:identifier>
</item>
<item>
<title>【JavaScript】吃饱了撑的系列之JavaScript模拟多线程并发 - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/11483291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/11483291.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;cksk1-0-0&quot;&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;ailrt-0-0&quot; readability=&quot;8.8632619439868&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;ailrt-0-0&quot;&gt;&lt;span data-offset-key=&quot;ailrt-0-0&quot;&gt;最近，明学是一个火热的话题，而我，却也想当那么一回明学家，那就是，&lt;strong&gt;把JavaScript和多线程并发这两个八竿子打不找的东西，给硬凑了起来&lt;/strong&gt;，还写了一个并发库&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://github.com/penghuwan/concurrent-thread.js&quot; target=&quot;_blank&quot; data-offset-key=&quot;ailrt-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;ailrt-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;concurrent-thread-js&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;ailrt-2-0&quot;&gt;。尴尬的是，当我发现其中的不合理之处，即这个东东的应用场景究竟是什么时，我发现我已经把代码写完了。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;ailrt-0-0&quot;&gt;&lt;span data-offset-key=&quot;ailrt-2-0&quot;&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;ailrt-0-0&quot;&gt;&lt;span data-offset-key=&quot;ailrt-2-0&quot;&gt;⚠️&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;注意！ 本文中的线程指的都是用JS异步函数模拟的“假线程”，不是真正意义上的多线程，请不要误解⚠️&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;ailrt-0-0&quot;&gt;&lt;span data-offset-key=&quot;ailrt-0-0&quot;&gt;&lt;span data-offset-key=&quot;ailrt-2-0&quot;&gt;github地址&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ailrt-0-0&quot;&gt;&lt;span data-offset-key=&quot;ailrt-2-0&quot;&gt;&lt;a href=&quot;https://github.com/penghuwan/concurrent-thread.js&quot;&gt;https://github.com/penghuwan/concurrent-thread.js&lt;/a&gt;&lt;a href=&quot;https://github.com/penghuwan/concurrent-thread.js&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;77bc8-0-0&quot;&gt;&lt;span data-offset-key=&quot;77bc8-0-0&quot;&gt;本文的目的&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;5roo9-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5roo9-0-0&quot;&gt;事实上，这个库用处很小，但是在写的过程中，我对Promise,Async函数以及event事件流的使用产生了新的认识，同时也逐渐去学习和了解怎么去从零开始去写一个非业务的，通用的npm模块，所以希望拿出来和大家分享一下，这才是本文的真正的目的。&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;j9r4-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;j9r4-0-0&quot;&gt;好，我们从一个故事开始。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/v2-024c0eb60e96a7178d7eacdfc5553924_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;432&quot; data-rawheight=&quot;406&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-024c0eb60e96a7178d7eacdfc5553924_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-6d4e26e45d2e17903cd5158f191c4e4d_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;span&gt;场景一&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/v2-b539cf84592b7dcdd07e7cbaa52f1a8d_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;432&quot; data-rawheight=&quot;406&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-b539cf84592b7dcdd07e7cbaa52f1a8d_b.jpg&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-107559786c533e54aeb70463ba2c9aab_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;strong&gt;&lt;span&gt;场景二&lt;/span&gt;&lt;/strong&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;a49j9-0-0&quot;&gt;&lt;span data-offset-key=&quot;a49j9-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;github地址&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;LinkCard FocusPlugin--unfocused LinkCard--noImage&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-offset-key=&quot;f2uee-0-0&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/penghuwan/concurrent-thread.js​github.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;2u0l4-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;注意！倘若不考虑webworker这种解决方案，我们一般都认为JS是单线程的。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;3e0st-0-0&quot;&gt;&lt;span data-offset-key=&quot;3e0st-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;concurrent-thread-js功能简介&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;8vtvt-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8vtvt-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;为单线程的JavaScript实现并发协调的功能，语意，命名和作用性质上参考Java的实现，提sleep/join/interupt等API以及锁和条件变量等内容，并提供线程间通信的功能，依赖ES6语法，基于Promise和Async函数实现，故需要Babel编译才能运行。JavaScrpt本来就是单线程的，所以这只是在API的层面实现了模拟，&lt;span data-offset-key=&quot;8vtvt-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在下文的介绍中，每条所谓的线程其实就是普通的异步函数，并在此基础上实现不同线程的协调配合。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;efalq-0-0&quot;&gt;&lt;span data-offset-key=&quot;efalq-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;为什么不选用webworker实现？&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;cj5gb-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cj5gb-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;没错，一般来说JS中模拟多线程我们也许会选用webworker，但是它必须要求你手动创建额外的webworker脚本文件，并通过new work('work.js')这种方式使用，这并不能达到我项目中想要的API的效果，而且注意：webwork中的环境不是window!很多方法你调用不了的。你只能采取这种方案，也即在主线程完成该功能，这是我没有选择webworker的另一个原因。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;btghd-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;btghd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;说是这样说，但其实在大多数时候还是用webworker就够了&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;3da2i-0-0&quot;&gt;&lt;span data-offset-key=&quot;3da2i-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;什么时候使用concurrent-thread-js&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;7280j-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7280j-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这个问题真是灵魂拷问，可是既然代码写都写了，我怎么也得编一个理由出来啊！额。。。让我想想哈&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;8h7dd-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8h7dd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;它的作用是&lt;span data-offset-key=&quot;8h7dd-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;：当JS工程需要让两个函数在执行上不互相干扰，同时也不希望它们会阻塞主线程，与此同时，还希望这两个函数实现类似并发多线程之间的协调的需求的时候，你可以使用这个并发模拟库，&lt;span data-offset-key=&quot;8h7dd-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;实际上这种应用场景。。。这尼玛有这种应用场景吗？！（扎心了呀）&lt;span data-offset-key=&quot;8h7dd-0-3&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;chkhk-0-0&quot;&gt;&lt;span data-offset-key=&quot;chkhk-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;API总览&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;3789s-0-0&quot; readability=&quot;12.5&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;3789s-0-0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3789s-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;submit(function,[namespace])&lt;span data-offset-key=&quot;3789s-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;: 接收一个函数，普通函数或Async函数均可，并异步执行&quot;线程&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;5i4pd-0-0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5i4pd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;sleep(ms)&lt;span data-offset-key=&quot;5i4pd-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;: &quot;线程&quot;休眠,可指定休眠时间ms,以毫秒计算&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;fp4t7-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fp4t7-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;join(threadName)&lt;span data-offset-key=&quot;fp4t7-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;: &quot;线程&quot;同步，调用此方法的&quot;线程&quot;函数将在threadName执行结束后继续执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;bv3si-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bv3si-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;interupt(threadName)&lt;span data-offset-key=&quot;bv3si-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;: &quot;线程&quot;中断，影响&quot;线程&quot;内部调this.isInterrupted()的返回值&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;bnr21-0-0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bnr21-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Lock.lock&lt;span data-offset-key=&quot;bnr21-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;: 加锁，一个时刻只能有一个&quot;线程&quot;函数进入临界区，其他&quot;线程&quot;函数需要等待，锁是非公平的，也就是说后面排队的线程函数没有先后，以随机的方式进行竞争。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;5ssvg-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5ssvg-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Lock.unlock&lt;span data-offset-key=&quot;5ssvg-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;:解除非公平锁&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;89t7e-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;89t7e-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Condition.wait&lt;span data-offset-key=&quot;89t7e-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;:不具备执行条件，&quot;线程&quot;进入waiting状态，等待被唤醒&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;2k5b7-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2k5b7-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Condition.notify&lt;span data-offset-key=&quot;2k5b7-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;:随机唤醒一个wait的&quot;线程&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;1k8et-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1k8et-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Condition.notifyAll&lt;span data-offset-key=&quot;1k8et-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;: 尚未编写，唤醒所有wait的&quot;线程&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;c35pb-0-0&quot; readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c35pb-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;getState&lt;span data-offset-key=&quot;c35pb-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;: 还没写完 获取&quot;线程&quot;状态，包括RUNNALE(运行),WAITING（等待）,BLOCKED（阻塞）,TERMINATED（终止）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;cm2dc-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;三个类:ThreadPool,Lock和Condition&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;7ni76-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7ni76-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们的API分别写入三个类中，分别是&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;cgapa-0-0&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;cgapa-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cgapa-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;ThreadPool类&lt;span data-offset-key=&quot;cgapa-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;：包含submit/sleep/join/interrupt/getState方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;cn726-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cn726-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Lock类&lt;span data-offset-key=&quot;cn726-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;：包含Lock.lock和Lock.unLock方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;5rgo8-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5rgo8-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Condition类&lt;span data-offset-key=&quot;5rgo8-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;：包含Condition.wait和Condition.notify方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;8njb-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;注：以下所说的&quot;线程&quot;都是指JS中模拟的异步函数&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;7jags-0-0&quot;&gt;&lt;span data-offset-key=&quot;7jags-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;A1.submit方法&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;ekken-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ekken-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;submit模拟提交线程至线程池&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6e3mv-0-0&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 备注：为循序渐进介绍，以下为简化代码&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 存储每个线程函数的状态，例如是否中断，以及线程状态等&lt;/span&gt;
const threadMap =&lt;span&gt; {};

class ThreadPool {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟线程中断&lt;/span&gt;
&lt;span&gt;    interrupt(threadName) {   }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟线程同步&lt;/span&gt;
&lt;span&gt;    join(threadName, targetThread) {   }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟线程休眠&lt;/span&gt;
&lt;span&gt;    sleep(ms) { }
};
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; submit(func, name) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!func &lt;span&gt;instanceof&lt;/span&gt; Function) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方式1：传入一个具名函数；方式2：传入第二个参数，即线程命名空间&lt;/span&gt;
    const threadName = func.name ||&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; threadMap负责存储线程状态数据&lt;/span&gt;
    threadMap[threadName] = { state: RUNNABLE, isInterrupted: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; };
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让func异步调用，同时将传入函数的作用域绑定为 ThreadPool原型&lt;/span&gt;
&lt;span&gt;    Promise.resolve({
        then: func.bind(ThreadPool.prototype);
   })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;a8uua-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a8uua-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;首先，我们做了三件事情：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;c6cuu-0-0&quot; readability=&quot;4&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;c6cuu-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c6cuu-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;获取线程函数的命名空间，并初始化线程初始数据，不同线程状态由threadMap全局存储&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;a49q3-0-0&quot; readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;a49q3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;将提交的函数func作为Promise.resolve方法中的一个thenable对象的then参数，这相当于立即&quot;完成&quot;一个Promise，同时在then方法中执行func，&lt;span data-offset-key=&quot;a49q3-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;func会以异步而不是同步的方式进行执行&lt;span data-offset-key=&quot;a49q3-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;，你也可以简单的理解成&lt;span data-offset-key=&quot;a49q3-0-3&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;类似于执行了setTimeOut(func,0)；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;esgu1-0-0&quot; readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;esgu1-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;将func的作用域绑定为新生成的ThreadPool实例，ThreadPool中定义了我们上面我们介绍到的方法，如sleep/join/interupt等，&lt;span data-offset-key=&quot;esgu1-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这有什么好处呢？这意味着我们可以直接在函数中通过调用this.interrupt的方式去调用我们定义的API了&lt;span data-offset-key=&quot;esgu1-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;，符合我们的使用习惯（注意,class中定义的除箭头函数外的普通函数实际上都存放在原型中）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;9gs9j-0-0&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
submit(async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; example() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interrupt();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;3cf7m-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3cf7m-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;但问题在于：现在因为所有的函数通过this调用的都是ThreadPool原型中的方法，我们要在调用唯一的interrupt方法，&lt;span data-offset-key=&quot;3cf7m-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;需要在异步函数中传入&quot;线程&quot;标识，如线程名。这显然不方便，也不优雅,&lt;span data-offset-key=&quot;3cf7m-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;例如下面的命名为example的线程函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;bfp94-0-0&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
submit(async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; example() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.interrupt('example'&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;2h7n3-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2h7n3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;使用这个模块用户会感到奇怪：我明明在example函数中，为什么还要给调用方法传example这个名字参数？？难道不能在模块内部把这事情干了吗？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;8tbp6-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8tbp6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;对！我们下面做的就是这件事情，我们编写一个delegateThreadPool方法，由它为ThreadPool代理处理不同“线程“函数的函数名&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;46sdv-0-0&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回代理后的ThreadPool&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; delegateThreadPool(threadName) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; threadName为待定的线程名，在submit方法调用时候传入&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理后的ThreadPool&lt;/span&gt;
    const proxyClass =&lt;span&gt; {};
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取ThreadPool原来的所有的方法,赋给props数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; props =&lt;span&gt; Object.getOwnPropertyNames(ThreadPool.prototype);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (let prop of props) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 代理ThreadPool，为其所有方法增加threadName这个参数&lt;/span&gt;
        let fnName =&lt;span&gt; prop;
        proxyClass[fnName] &lt;/span&gt;= (...args) =&amp;gt;&lt;span&gt; {
            const fn &lt;/span&gt;=&lt;span&gt; baseClass[fnName];
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fn(threadName, ...args);
        };
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; proxyClass;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; submit(func, name) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略其他代码 。。。&lt;/span&gt;
    const proxyScope =&lt;span&gt; delegateThreadPool(threadName);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让func异步调用，不阻塞主线程，同时实现并发&lt;/span&gt;
&lt;span&gt;    Promise.resolve({
        then: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给func绑定this为代理后的ThreadPool对象，以便调用方法&lt;/span&gt;
&lt;span&gt;            func.call(proxyScope);
        }
    });
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用this.sleep方法时，已经无需增加函数命名作为参数了&lt;/span&gt;
submit(async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; example() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.interrupt();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;d3hua-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;d3hua-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;也就是说，我们的线程函数func绑定的已经不是ThreadPool.prototype了，而是delegateThreadPool处理后返回的对象：proxyScope。这时候，我们在“线程”函数体里调用this.interrupt方法时，已经无需增加函数命名作为参数了，因为这个工作，proxyScope对象帮我们做了，其实它的工作很简单——就是它的每个函数，都在一个返回的闭包里面调用ThreadPool的同名函数，并传递线程名作为第一个参数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;96l5u-0-0&quot;&gt;&lt;span data-offset-key=&quot;96l5u-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;A2. sleep方法&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;19h0-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;19h0-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;作用：&lt;span data-offset-key=&quot;19h0-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;线程休眠&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;5u17r-0-0&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5u17r-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;sleep方法很简单,无非就是返回一个Promise实例，在Promise的函数里面调setTimeOut,等时间到了执行resolve函数,这段时间里修饰Promise的await语句会阻塞一段时间，resolve后又await语句又继续向下执行了，能满足我们想要的休眠效果&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;7dro4-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟“线程”休眠&lt;/span&gt;
&lt;span&gt;sleep(ms) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (resolve) {
    setTimeout(resolve, ms);
  })
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交“线程”&lt;/span&gt;
submit(async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; example() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞停留3秒，然后才输出1&lt;/span&gt;
    await &lt;span&gt;this&lt;/span&gt;.sleep(3000&lt;span&gt;);
    console.log(&lt;/span&gt;1&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;aqc2v-0-0&quot;&gt;&lt;span data-offset-key=&quot;aqc2v-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;A3. interrupt方法&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;ckluu-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ckluu-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;作用：&lt;span data-offset-key=&quot;ckluu-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;线程中断，可用于处理线程停止等操作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;edklv-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;edklv-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这里要先介绍一下Java里面的interrupt方法：在JAVA里，你不能通过调用terminate方法停掉一个线程，因为这有可能会因为处理逻辑突然中断而导致数据不一致的问题，所以要通过interrupt方法把一个中断标志位置为true，然后通过isInterrupted方法作为判断条件跳出关键代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;9b9cj-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9b9cj-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;所以为了模拟，我在JS中处理“线程”中断也是这么去做的,但是我们这样做的根本原因是：我们压根没有可以停掉一个线程函数的方法！（JAVA是有但是不准用，即废弃了而已）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;8kpdl-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟线程中断&lt;/span&gt;
&lt;span&gt;    interrupt(threadName) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!threadName) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('Miss function parameters'&lt;span&gt;) }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (threadMap[threadName]) {
            threadMap[threadName].isInterrupted &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取线程中断状态&lt;/span&gt;
&lt;span&gt;    isInterrupted(threadName) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!threadName) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('Miss function parameters'&lt;span&gt;) }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; !!的作用是：将undefined转为false&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; !!&lt;span&gt;threadMap[threadName].isInterrupted;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;adkib-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;A4. join方法&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;bo24v-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bo24v-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;join(threadName)&lt;span data-offset-key=&quot;bo24v-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;: &quot;线程&quot;同步，调用此方法的&quot;线程&quot;函数将在threadName执行结束后继续执行&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;befmr-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;befmr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;join方法和上面的sleep方法是一样的道理，我们让它返回一个Promise，只要我们不调resolve，那么外部修饰Promise的await语句就会一直暂停，等到join的那个另一个线程执行完了，我们看准时机！把这个Promise给resolve,这时候外部修饰Promise的await语句不就又可以向下执行了吗？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;1us6s-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1us6s-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;但问题在于：我们如何实现这个“&lt;span data-offset-key=&quot;1us6s-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;一个函数执行完通知另一个函数的功能呢&lt;span data-offset-key=&quot;1us6s-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;”？没错！&lt;span data-offset-key=&quot;1us6s-0-3&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;那就是我们JavaScript最喜欢的套路: 事件流！ &lt;span data-offset-key=&quot;1us6s-0-4&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们下面使用event-emitter这个前后端通用的模块实现事件流。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;647m3-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;647m3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们只要在任何一个函数结束的时候触发结束事件（join-finished），同时传递该线程的函数名作为参数，然后在join方法内部监听该事件，并在响应时候调用resolve方法不就可以了嘛。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;2mvrg-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2mvrg-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;首先是在join方法内部监听线程函数的结束事件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6onso-0-0&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import ee from 'event-emitter'&lt;span&gt;;
const emitter &lt;/span&gt;=&lt;span&gt; ee();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模拟线程同步&lt;/span&gt;
&lt;span&gt;join(threadName, targetThread) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听其他线程函数的结束事件&lt;/span&gt;
    emitter.on('join-finished', (finishThread) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据结束线程的线程名finishThread做判断&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (finishThread ===&lt;span&gt; targetThread) {
        resolve();
      }
    })
  })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;emdft-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;emdft-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;同时在线程函数执行结束时触发join-finished事件，传递线程名做参数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;57ki7-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import ee from 'event-emitter'&lt;span&gt;;
const emitter &lt;/span&gt;=&lt;span&gt; ee();
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; submit(func, name) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    Promise.resolve({
        then: func().then(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
          emitter.emit(&lt;/span&gt;'join-finished'&lt;span&gt;, threadName);
        })
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;c43us-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c43us-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;使用如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;c43us-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
submit(async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; thread1 () {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.join('thread2'&lt;span&gt;);
  console.log(&lt;/span&gt;1&lt;span&gt;);
});
submit(async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; thread2 () {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sleep(3000&lt;span&gt;);
  console.log(&lt;/span&gt;2&lt;span&gt;)
})
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3s后，依次输出 2 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;6q3qj-0-0&quot;&gt;&lt;span class=&quot;prism-token token function&quot;&gt;&lt;span data-offset-key=&quot;6q3qj-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;A5. Lock.lock &amp;amp; Lock.unlock（非公平锁）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;11jk8-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;11jk8-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们主要是要编写两个方法：lock和unlock方法。我们需要设置一个Boolean属性isLock&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;98qpr-0-0&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;98qpr-0-0&quot; readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;98qpr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;lock方法：&lt;span data-offset-key=&quot;98qpr-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;lock方法首先会判断isLock是否为false，如果是，则代表没有线程占领临界区，那么允许该线程进入临界区，同时把isLock设置为true，不允许其他线程函数进入。其他线程进入时，由于判断isLock为true，会setTimeOut每隔一段时间递归调用判断isLock是否为false，从而以较低性能消耗的方式模拟while死循环。当它们检测到isLock为false时候，则会进入临界区，同时设置isLock为true。因为后面的线程没有先后顺序，所以这是一个非公平锁&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;6bv31-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6bv31-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;unLock方法：&lt;span data-offset-key=&quot;6bv31-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;unlock则是把isLock属性设置为false,解除锁定就可以了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;8fqbe-0-0&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是一个非公平锁&lt;/span&gt;
&lt;span&gt;class Lock {
    constructor() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.isLock = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁&lt;/span&gt;
&lt;span&gt;    lock() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isLock) {
            const self &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环while死循环，不停测试isLock是否等于false&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve) =&amp;gt;&lt;span&gt; {
                (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; recursion() {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;self.isLock) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 占用锁&lt;/span&gt;
                        self.isLock = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使外部await语句继续往下执行&lt;/span&gt;
&lt;span&gt;                        resolve();
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                    setTimeout(recursion, &lt;/span&gt;100&lt;span&gt;);
                })();
            });
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.isLock = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Promise.resolve();
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解锁&lt;/span&gt;
&lt;span&gt;    unLock() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.isLock = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
}
const lockObj &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Lock();
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; lockObj;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;ck8ce-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ck8ce-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;运行示例如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;bsqsh-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; commonCode() {
    await Lock.lock();
    await Executor.sleep(&lt;/span&gt;3000&lt;span&gt;);
    Lock.unLock();
}

submit(async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; example1() {
    console.log(&lt;/span&gt;'example1 start'&lt;span&gt;)
    await commonCode();
    console.log(&lt;/span&gt;'example1 end'&lt;span&gt;)
});
submit(async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; example2() {
    console.log(&lt;/span&gt;'example2 start'&lt;span&gt;)
    await commonCode();
    console.log(&lt;/span&gt;'example2 end'&lt;span&gt;)
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;eobkv-0-0&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;eobkv-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;输出&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;eobkv-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 立即输出&lt;/span&gt;
&lt;span&gt;example1 start
example2 start
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3秒后输出&lt;/span&gt;
&lt;span&gt;example1 end
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再3秒后输出&lt;/span&gt;
example2 end
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;98dma-0-0&quot;&gt;&lt;span data-offset-key=&quot;98dma-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;A6. Condition.wait &amp;amp; Condition.notify（条件变量）&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;8d0af-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;8d0af-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;对不起！写到这里，我实在是口干舌燥，写不下去了，但是道理和前面是一样的：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;egdoj-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;egdoj-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;无非是：事件监听 + Promise + Async函数组合拳，一套搞定&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;egdoj-0-0&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
import ee from 'event-emitter'&lt;span&gt;;
const ev &lt;/span&gt;=&lt;span&gt; ee();

class Condition {
    constructor() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.n = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; [];
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当不满足条件时，让线程处于等待状态&lt;/span&gt;
&lt;span&gt;    wait() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve) =&amp;gt;&lt;span&gt; {
            const eventName &lt;/span&gt;= `notify-${&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.n}`;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.n++&lt;span&gt;;
            const list &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.list;
            list.push(eventName);
            ev.on(eventName, () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从列表中删除事件名&lt;/span&gt;
                const i =&lt;span&gt; list.indexOf(eventName);
                list.splice(i, &lt;/span&gt;1&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让外部函数恢复执行&lt;/span&gt;
                &lt;span&gt;debugger&lt;/span&gt;&lt;span&gt;;
                resolve();
            })
        })
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 选择一个线程唤醒&lt;/span&gt;
&lt;span&gt;    notify() {
        const list &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.list;
        let i &lt;/span&gt;= Math.random() * (&lt;span&gt;this&lt;/span&gt;.list.length - 1&lt;span&gt;);
        i &lt;/span&gt;=&lt;span&gt; Math.floor(i);
        ev.emit(list[i])
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;fm8d3-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fm8d3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;测试代码&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;ac1at-0-0&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testCode() {
    console.log(&lt;/span&gt;'i will be wait'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
        await Condition.wait();
    };
    console.log(&lt;/span&gt;'i was notified '&lt;span&gt;);
}

submit(async &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; example() {
    testCode();
    setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        Condition.notify();
    }, &lt;/span&gt;3000&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;atqr1-0-0&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;i will be wait
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3秒后输出&lt;/span&gt;
i was notified
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;42ejl-0-0&quot;&gt;&lt;span data-offset-key=&quot;42ejl-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;最后的大总结&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;1q8d0-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;1q8d0-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;其实说到底，我想和大家分享的不是什么并发啊，什么多线程啦。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;32f92-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;32f92-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;其实我想表达的是：事件监听 + Promise + Async函数这套组合拳很好用啊&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;5ov5e-0-0&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;5ov5e-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5ov5e-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;你想让一段代码停一下？&lt;span data-offset-key=&quot;5ov5e-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;OK!&lt;span data-offset-key=&quot;5ov5e-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;写个返回Promise的函数，用await修饰，&lt;span data-offset-key=&quot;5ov5e-0-3&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;它就停啦！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;ciohf-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ciohf-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;你想控制它(await)不要停了，继续往下走？&lt;span data-offset-key=&quot;ciohf-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;OK! &lt;span data-offset-key=&quot;ciohf-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;把Promise给resolve掉，&lt;span data-offset-key=&quot;ciohf-0-3&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;它就往下走啦&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;c0gt4-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c0gt4-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;你说你不知道怎么控制它停，因为监听和发射事件的代码分布在两个地方？&lt;span data-offset-key=&quot;c0gt4-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;OK！那就使用事件流&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;eig7e&quot; data-offset-key=&quot;ecmgc-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ecmgc-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;本文完，下面是全部项目代码（刚写了文章才发现有bug，待会改改）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 08 Sep 2019 00:15:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<og:description>最近，我当了回糊涂月老，乱点鸳鸯，把JavaScript和多线程并发这两个八竿子打不找的东西，给硬凑了起来，还写了一个并发库concurrent-thread-js。尴尬的是，当我发现其中的不合理之处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/penghuwan/p/11483291.html</dc:identifier>
</item>
<item>
<title>10 UA池和代理池 - HongLingLiu</title>
<link>http://www.cnblogs.com/Summer-skr--blog/p/11484259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Summer-skr--blog/p/11484259.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;Scrapy中，&lt;span&gt;引擎和下载器之间&lt;/span&gt;&lt;span&gt;有一个组件，叫&lt;/span&gt;&lt;span&gt;下载中间件（&lt;/span&gt;Downloader Middlewares&lt;span&gt;）&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;因它是&lt;/span&gt;&lt;span&gt;介于&lt;/span&gt;Scrapy&lt;span&gt;的&lt;/span&gt;&lt;span&gt;request/response&lt;/span&gt;&lt;span&gt;处理的钩子&lt;/span&gt;&lt;span&gt;，所以有&lt;/span&gt;2&lt;span&gt;方面&lt;/span&gt;&lt;span&gt;作用：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）引擎将请求传递给下载器过程中，下载中间件可以对Requests进行一系列处理。比如设置请求的&lt;/span&gt; &lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;，设置代理&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;等&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）在下载器完成将&lt;/span&gt;&lt;span&gt;Response&lt;/span&gt;&lt;span&gt;传递给引擎中，下载中间件可以对Responses进行一系列处理。比如进行&lt;/span&gt;&lt;span&gt;gzip&lt;/span&gt;&lt;span&gt;解压等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1518468/201909/1518468-20190908080554892-2106026981.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;爬虫中，&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;主要使用下载中间件处理请求，一般会对请求设置随机的&lt;/span&gt;User-Agent &lt;span&gt;，设置随机的代理&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;。目的在于防止爬取网站的反爬虫策略。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt; 一、&lt;strong&gt;UA&lt;span&gt;池：&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;池&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;- &lt;span&gt;作用：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;尽可能多的将&lt;/span&gt;scrapy&lt;span&gt;工程中的请求伪装成不同类型的浏览器身份。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;- &lt;span&gt;操作流程：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.&lt;span&gt;在下载中间件中拦截请求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.&lt;span&gt;将拦截到的请求的请求头信息中的&lt;/span&gt;&lt;span&gt;UA&lt;/span&gt;&lt;span&gt;进行篡改伪装&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3.&lt;span&gt;在配置文件中开启下载中间件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Middleware.py&lt;span&gt;中部分&lt;/span&gt;&lt;span&gt;代码展示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; scrapy.contrib.downloadermiddleware.useragent &lt;span&gt;import&lt;/span&gt; UserAgentMiddleware        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导包&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;UA池代码的编写（单独给UA池封装成一个类）&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; RandomUserAgent(UserAgentMiddleware):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request, spider):
        ua &lt;/span&gt;=&lt;span&gt; random.choice(user_agent_list)                
        request.headers.setdefault(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,ua)            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当前拦截到请求的ua的写入操作&lt;/span&gt;
&lt;span&gt;


user_agent_list &lt;/span&gt;=&lt;span&gt; [
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、代理池&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt; - &lt;span&gt;作用：尽可能多的将&lt;/span&gt;&lt;span&gt;scrapy&lt;/span&gt;&lt;span&gt;工程中的请求的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;设置成不同的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;- &lt;span&gt;操作流程：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    1.&lt;span&gt;在下载中间件中拦截请求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2.&lt;span&gt;将拦截到的请求的&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;修改成某一代理&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    3.&lt;span&gt;在配置文件中开启下载中间件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Middleware&lt;span&gt;代码展示：批量对拦截到的请求进行&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;更换&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;单独封装下载中间件类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Proxy(object):

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request, spider):

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对拦截到请求的url进行判断（协议头到底是http还是https）, request.url返回值：http://www.xxx.com&lt;/span&gt;
        h = request.url.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0]                              &lt;span&gt;#&lt;/span&gt;&lt;span&gt;请求的协议头&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; h == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            ip &lt;/span&gt;=&lt;span&gt; random.choice(PROXY_https)
            request.meta[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proxy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;ip
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            ip &lt;/span&gt;=&lt;span&gt; random.choice(PROXY_http)
            request.meta[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proxy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; ip

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;可被选用的代理IP&lt;/span&gt;
PROXY_http =&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;153.180.102.104:80&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;195.208.131.189:56055&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]
PROXY_https &lt;/span&gt;=&lt;span&gt; [
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;120.83.49.90:9000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;95.189.112.214:35508&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;代理&lt;/span&gt;ip&lt;span&gt;一般都是在发送请求不成功的时候进行的，所以，我们以后可以将代理&lt;/span&gt;&lt;span&gt;ip&lt;/span&gt;&lt;span&gt;写到&lt;/span&gt;&lt;span&gt;process_exception&lt;/span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;三、UA池和代理池在中间件中的使用示例&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;span&gt;以麦田房产为例，将代码展示在下方，详细展示了如何在Scrapy框架中使用UA池和代理池。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1518468/201909/1518468-20190908082550079-1929711409.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;爬虫文件&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;:maitian.py&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; houseinfo.items &lt;span&gt;import&lt;/span&gt; HouseinfoItem               &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将item导入&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MaitianSpider(scrapy.Spider):
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;maitian&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; start_urls = ['http://bj.maitian.cn/zfall/PG{}'.format(page for page in range(1,101))]&lt;/span&gt;
    start_urls = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://bj.maitian.cn/zfall/PG100&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]


    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;解析函数&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):

        li_list &lt;/span&gt;= response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@class=&quot;list_wrap&quot;]/ul/li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; li &lt;span&gt;in&lt;/span&gt;&lt;span&gt; li_list:
            item &lt;/span&gt;=&lt;span&gt; HouseinfoItem(
                title &lt;/span&gt;=  li.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./div[2]/h1/a/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract_first().strip(),
                price &lt;/span&gt;= li.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./div[2]/div/ol/strong/span/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract_first().strip(),
                square &lt;/span&gt;= li.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./div[2]/p[1]/span[1]/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).extract_first().replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;㎡&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;''&lt;/span&gt;&lt;span&gt;),
                area &lt;/span&gt;= li.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./div[2]/p[2]/span/text()[2]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).extract_first().strip().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xa0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)[0],
                adress &lt;/span&gt;= li.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./div[2]/p[2]/span/text()[2]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).extract_first().strip().split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\xa0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[2&lt;span&gt;]
            )

            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; item                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提交给管道，然后管道定义存储方式&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;items&lt;span&gt;文件：&lt;/span&gt;&lt;span&gt;items.py&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HouseinfoItem(scrapy.Item):
    title &lt;/span&gt;= scrapy.Field()          &lt;span&gt;#&lt;/span&gt;&lt;span&gt;存储标题，里面可以存储任意类型的数据&lt;/span&gt;
    price =&lt;span&gt; scrapy.Field()
    square &lt;/span&gt;=&lt;span&gt; scrapy.Field()
    area &lt;/span&gt;=&lt;span&gt; scrapy.Field()
    adress &lt;/span&gt;= scrapy.Field()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;管道文件：&lt;/span&gt;pipelines.py&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HouseinfoPipeline(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.file &lt;/span&gt;=&lt;span&gt; None

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开始爬虫时，执行一次&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self,spider):
        self.file &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;maitian.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选用了追加模式&lt;/span&gt;
        self.file.write(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.join([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;月租金&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;面积&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;区域&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始爬虫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因为该方法会被执行调用多次，所以文件的开启和关闭操作写在了另外两个只会各自执行一次的方法中。&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
        content &lt;/span&gt;= [item[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], item[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], item[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;square&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], item[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;area&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], item[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
        self.file.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.join(content))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结束爬虫时，执行一次&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_spider(self,spider):
        self.file.close()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;结束爬虫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;中间件文件Middlewares.py&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;82&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; scrapy &lt;span&gt;import&lt;/span&gt;&lt;span&gt; signals

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; HouseinfoDownloaderMiddleware(object):

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;UA池&lt;/span&gt;
    user_agent_list =&lt;span&gt; [
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/22.0.1207.1 Safari/537.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (X11; CrOS i686 2268.111.0) AppleWebKit/536.11 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/20.0.1132.57 Safari/536.11&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.6 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/20.0.1090.0 Safari/536.6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.1 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.77.34.5 Safari/537.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/536.5 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1084.9 Safari/536.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.0) AppleWebKit/536.5 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1084.36 Safari/536.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_0) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1063.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1062.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1061.1 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2) AppleWebKit/536.3 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1061.0 Safari/536.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.24 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/535.24 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;(KHTML, like Gecko) Chrome/19.0.1055.1 Safari/535.24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    ]

    PROXY_http &lt;/span&gt;=&lt;span&gt; [
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;153.180.102.104:80&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;195.208.131.189:56055&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
    ]
    PROXY_https &lt;/span&gt;=&lt;span&gt; [
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;120.83.49.90:9000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;95.189.112.214:35508&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_request(self, request, spider):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用UA池设置请求的UA&lt;/span&gt;
        request.headers[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;User-Agent&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; random.choice(self.user_agent_list)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; None

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_response(self, request, response, spider):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;拦截发生异常的请求对象&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_exception(self, request, exception, spider):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; request.url.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            request.meta[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proxy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;random.choice(self.PROXY_http)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            request.meta[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;proxy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + random.choice(self.PROXY_https)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;配置文件：&lt;/span&gt;settings.py&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
BOT_NAME = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;houseinfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;

SPIDER_MODULES &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;houseinfo.spiders&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
NEWSPIDER_MODULE &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;houseinfo.spiders&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;p&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Obey robots.txt rules&lt;/span&gt;
ROBOTSTXT_OBEY =&lt;span&gt; False

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启管道&lt;/span&gt;
ITEM_PIPELINES =&lt;span&gt; {
   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;houseinfo.pipelines.HouseinfoPipeline&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 300,                    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;数值300表示为优先级，值越小优先级越高&lt;/span&gt;
&lt;span&gt;}
&lt;br/&gt;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启下载中间件&lt;/span&gt;
DOWNLOADER_MIDDLEWARES =&lt;span&gt; {
   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;houseinfo.middlewares.HouseinfoDownloaderMiddleware&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 543&lt;span&gt;,
}&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 08 Sep 2019 00:07:00 +0000</pubDate>
<dc:creator>HongLingLiu</dc:creator>
<og:description>在Scrapy中，引擎和下载器之间有一个组件，叫下载中间件（Downloader Middlewares）。因它是介于Scrapy的request/response处理的钩子，所以有2方面作用： （1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Summer-skr--blog/p/11484259.html</dc:identifier>
</item>
<item>
<title>selenium爬虫 - 凌逆战</title>
<link>http://www.cnblogs.com/LXP-Never/p/11386933.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LXP-Never/p/11386933.html</guid>
<description>&lt;p&gt;&lt;span&gt;Web自动化测试工具，可运行在浏览器，根据指令操作浏览器，&lt;/span&gt;&lt;span&gt;只是工具，必须与第三方浏览器结合使用，相比于之前学的爬虫只是慢了一点而已。而且这种方法爬取的东西不用在意时候ajax动态加载等反爬机制。因此找标签可以直接F12找，不用确定源码中是否存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Linux: sudo pip3 install selenium&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Windows: python -m pip install selenium&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;phantomjs浏览器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;phantomjs浏览器又叫做无界面浏览器(又称无头浏览器)，在内存中进行页面加载，运行高效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;安装(phantomjs(无界面浏览器)、chromedriver(谷歌浏览器)、geckodriver(火狐浏览器))&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Windows&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、下载对应版本的&lt;a href=&quot;https://phantomjs.org/download.html&quot; target=&quot;_blank&quot;&gt;phantomjs&lt;/a&gt;、&lt;a href=&quot;http://chromedriver.storage.googleapis.com/index.html&quot; target=&quot;_blank&quot;&gt;chromedriver&lt;/a&gt;、&lt;a href=&quot;https://github.com/mozilla/geckodriver/releases&quot; target=&quot;_blank&quot;&gt;geckodriver&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、chromedriver下载与谷歌浏览器对应的版本，把chromedriver.exe拷贝到python安装目录的Scripts目录下(添加到系统环境变量)，&lt;/span&gt;&lt;span&gt;查看python安装路径: where python&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、验证，&lt;/span&gt;&lt;span&gt;cmd命令行: &lt;span&gt;chromedriver&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Linux&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、下载后解压：&lt;/span&gt;&lt;span&gt;tar -zxvf geckodriver.tar.gz&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、拷贝解压后文件到 /usr/bin/ （添加环境变量）：&lt;/span&gt;&lt;span&gt;sudo cp geckodriver /usr/bin/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、更改权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  sudo -i&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  cd /usr/bin/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  chmod 777 geckodriver&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例代码一：使用 selenium+谷歌浏览器 打开百度，并截图百度首页&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

browser &lt;/span&gt;= webdriver.Chrome()            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建浏览器对象&lt;/span&gt;
browser.get(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开百度&lt;/span&gt;
browser.save_screenshot(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baidu.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 截屏&lt;/span&gt;
browser.quit()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 退出浏览器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;示例代码二：打开百度，搜索赵丽颖&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建浏览器对象 - 已经打开了浏览器&lt;/span&gt;
browser =&lt;span&gt; webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打开百度&lt;/span&gt;
ele = browser.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;kw&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到搜索框&lt;/span&gt;
ele.send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;赵丽颖&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 向搜索框发送文字: 赵丽颖&lt;/span&gt;
&lt;span&gt;
time.sleep(&lt;/span&gt;1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到 百度一下 按钮,点击一下&lt;/span&gt;
browser.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;su&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
time.sleep(&lt;/span&gt;2&lt;span&gt;)
browser.quit()      &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭浏览器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;browser浏览器对象方法&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;browser = webdriver.Chrome(executable_path='path')  path为浏览器驱动地址&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.get(url)         打开path路径&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.page_source：      查看响应内容（网页源代码）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.page_source.find('字符串')：&lt;/span&gt;&lt;span&gt;从html源码中搜索指定字符串,没有找到返回：-1&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.quit()：关闭浏览器&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;元素查找&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;单元素查找(1个节点对象)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;browser.find_element_by_id('')&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.find_element_by_name('')&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.find_element_by_class_name('')&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.find_element_by_xpath('')&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.find_element_by_link_text('')&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;... ...&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;多元素查找([节点对象列表])&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;browser.find_elements_by_id('')&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.find_elements_by_name('')&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.find_elements_by_class_name('')&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;browser.find_elements_by_xpath('')&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;... ...&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span&gt;节点对象操作&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;.send_keys('')     搜索框发送内容&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;.click()　　　　    点击&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;.text           获取文本内容&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;.get_attribute('src') 获取属性值&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;.find(&quot;&quot;)     　　 查找响应中的字符串&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.qiushibaike.com/text/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 单元素查找&lt;/span&gt;
div = browser.find_element_by_class_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(div.text)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多元素查找: [&amp;lt;selenium xxx at xxx&amp;gt;,&amp;lt;selenium xxx &amp;gt;]&lt;/span&gt;
divs = browser.find_elements_by_class_name(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; div &lt;span&gt;in&lt;/span&gt;&lt;span&gt; divs:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*************************&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(div.text)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*************************&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

browser.quit()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 退出浏览器&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;目标网址 ：https://www.jd.com/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;抓取目标 ：商品名称、商品价格、评价数量、商品商家&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;思路提醒&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;打开京东，到商品搜索页&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;匹配所有商品节点对象列表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;把节点对象的文本内容取出来，查看规律，是否有更好的处理办法？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;提取完1页后，判断如果不是最后1页，则点击下一页&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;&lt;span&gt;实现步骤&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;找节点&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;首页搜索框 : //*[@id=&quot;key&quot;]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;首页搜索按钮   ://*[@id=&quot;search&quot;]/div/div[2]/button&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;商品页的 商品信息节点对象列表 ://*[@id=&quot;J_goodsList&quot;]/ul/li&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;执行JS脚本，获取动态加载数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　browser.execute_script(&lt;span&gt;'window.scrollTo(0,document.body.scrollHeight)'&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; JdSpider(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.i &lt;/span&gt;=&lt;span&gt; 0
        self.url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.jd.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取页面信息 - 到具体商品的页面&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_html(self):
        self.browser.get(self.url)
        self.browser.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;key&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;爬虫书&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 搜索框输入“爬虫书”&lt;/span&gt;
        self.browser.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;search&quot;]/div/div[2]/button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).click()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 点击搜索&lt;/span&gt;
        time.sleep(3)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给商品页面加载时间&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解析页面&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse_html(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把下拉菜单拉到底部,执行JS脚本&lt;/span&gt;
        self.browser.execute_script(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;window.scrollTo(0,document.body.scrollHeight)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;2&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取所有商品节点对象列表 li列表&lt;/span&gt;
        li_list = self.browser.find_elements_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;J_goodsList&quot;]/ul/li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; li &lt;span&gt;in&lt;/span&gt;&lt;span&gt; li_list:
            info_list &lt;/span&gt;= li.text.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; info_list[0].startswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;每满&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;or&lt;/span&gt; info_list[1].startswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;￥&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
                price &lt;/span&gt;= info_list[1&lt;span&gt;]
                name &lt;/span&gt;= info_list[2&lt;span&gt;]
                comment &lt;/span&gt;= info_list[3&lt;span&gt;]
                shop &lt;/span&gt;= info_list[4&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; info_list[0].startswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;单件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
                price &lt;/span&gt;= info_list[3&lt;span&gt;]
                name &lt;/span&gt;= info_list[4&lt;span&gt;]
                comment &lt;/span&gt;= info_list[5&lt;span&gt;]
                shop &lt;/span&gt;= info_list[6&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                price &lt;/span&gt;=&lt;span&gt; info_list[0]
                name &lt;/span&gt;= info_list[1&lt;span&gt;]
                comment &lt;/span&gt;= info_list[2&lt;span&gt;]
                shop &lt;/span&gt;= info_list[3&lt;span&gt;]

            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(price, comment, shop, name)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主函数&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(self):
        self.get_html()
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            self.parse_html()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否该点击下一页,没有找到说明不是最后一页&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; self.browser.page_source.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pn-next disabled&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) == -1&lt;span&gt;:
                self.browser.find_element_by_class_name(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pn-next&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
                time.sleep(&lt;/span&gt;2&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.i)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    spider &lt;/span&gt;=&lt;span&gt; JdSpider()
    spider.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;chromedriver设置无界面模式&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

options &lt;/span&gt;= webdriver.ChromeOptions()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置无界面&lt;/span&gt;
options.add_argument(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加无界面参数&lt;/span&gt;
browser = webdriver.Chrome(options=&lt;span&gt;options)
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
browser.save_screenshot(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;baidu.png&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
browser.quit()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;把上面的代码改为无界面模式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a3c3c4ad-4d4d-42c2-ad10-8c50c49db05a')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_a3c3c4ad-4d4d-42c2-ad10-8c50c49db05a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a3c3c4ad-4d4d-42c2-ad10-8c50c49db05a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a3c3c4ad-4d4d-42c2-ad10-8c50c49db05a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a3c3c4ad-4d4d-42c2-ad10-8c50c49db05a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; JdSpider(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.url &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.jd.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
        self.options &lt;/span&gt;= webdriver.ChromeOptions()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置无界面&lt;/span&gt;
        self.options.add_argument(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加无界面参数&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 正常创建浏览器对象即可&lt;/span&gt;
        self.browser = webdriver.Chrome(options=&lt;span&gt;self.options)
        self.i &lt;/span&gt;= 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 统计商品数&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取页面信息 - 到具体商品的页面&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_html(self):
        self.browser.get(self.url)
        self.browser.find_element_by_xpath(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;key&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;爬虫书&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 搜索框输入“爬虫书”&lt;/span&gt;
        self.browser.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;search&quot;]/div/div[2]/button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).click()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 点击搜索&lt;/span&gt;
        time.sleep(3)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 给商品页面加载时间&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse_html(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把进度条拉到底部,使所有数据动态加载&lt;/span&gt;
        self.browser.execute_script(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;window.scrollTo(0,document.body.scrollHeight)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;2)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等待动态数据加载完成&lt;/span&gt;

        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取所有商品节点对象列表 li列表&lt;/span&gt;
        li_list = self.browser.find_elements_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;J_goodsList&quot;]/ul/li&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        item &lt;/span&gt;=&lt;span&gt; {}
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; li &lt;span&gt;in&lt;/span&gt;&lt;span&gt; li_list:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; find_element: 查找单元素&lt;/span&gt;
            item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = li.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//div[@class=&quot;p-name&quot;]/a/em&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text.strip()
            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;price&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = li.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//div[@class=&quot;p-price&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text.strip()
            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;comment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = li.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//div[@class=&quot;p-commit&quot;]/strong&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text.strip()
            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shop&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = li.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//div[@class=&quot;p-shopnum&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text.strip()

            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(item)
            self.i &lt;/span&gt;+= 1

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(self):
        self.get_html()
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            self.parse_html()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否为最后一页&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; self.browser.page_source.find(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pn-next disabled&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) == -1&lt;span&gt;:
                self.browser.find_element_by_class_name(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pn-next&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
                time.sleep(&lt;/span&gt;3&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;商品数量:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self.i)
        self.browser.quit()


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    spider &lt;/span&gt;=&lt;span&gt; JdSpider()
    spider.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;键盘操作&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.keys &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Keys
​
browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、在搜索框中输入&quot;selenium&quot;&lt;/span&gt;
browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;赵丽颖&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、输入空格&lt;/span&gt;
browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).send_keys(Keys.SPACE)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3、Ctrl+a 模拟全选&lt;/span&gt;
browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(Keys.CONTROL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4、Ctrl+c 模拟复制&lt;/span&gt;
browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(Keys.CONTROL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5、Ctrl+v 模拟粘贴&lt;/span&gt;
browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(Keys.CONTROL, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;v&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6、输入回车,代替 搜索 按钮&lt;/span&gt;
browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;kw&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(Keys.ENTER)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;鼠标操作&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入鼠标事件&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; selenium.webdriver &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ActionChains

browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.baidu.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到“设置”节点&lt;/span&gt;
element = browser.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//*[@id=&quot;u1&quot;]/a[8]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把鼠标移动到 设置 节点,move_to_element()&lt;/span&gt;
actions =&lt;span&gt; ActionChains(browser)
actions.move_to_element(element)
actions.perform()       &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; perform()是真正执行操作&lt;/span&gt;
time.sleep(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到高级设置节点,并点击&lt;/span&gt;
browser.find_element_by_link_text(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;高级搜索&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).click()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;切换页面&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;适用与&lt;/span&gt;&lt;span&gt;页面中点开链接出现新的页面的网站，但是浏览器对象browser还是之前页面的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;all_handles = browser.window_handles&lt;/strong&gt;&lt;/span&gt;　　获取当前所有句柄（窗口）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;browser.switch_to_window(all_handles[1])&lt;/strong&gt;&lt;/span&gt;　　切换browser到新的窗口，获取新窗口对象&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;民政部网站&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;将民政区划代码爬取到数据库中，按照层级关系（分表 -- 省表、市表、县表）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据库中建表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 建库
&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;database&lt;/span&gt;&lt;span&gt; govdb charset utf8;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; govdb;
&lt;span&gt;# 建表
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; province(
        p_name &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
        p_code &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
        )charset&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;
        &lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; city(
        c_name &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
        c_code &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
        c_father_code &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
        )charset&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;utf8;
        &lt;/span&gt;&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;&lt;span&gt; county(
        x_name &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
        x_code &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;),
        x_father_code &lt;/span&gt;&lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;)
        )charset&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;utf8;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;思路&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;selenium+Chrome打开一级页面，并提取二级页面最新链接&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;增量爬取: 和数据库version表中进行比对，确定之前是否爬过（是否有更新）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果没有更新，直接提示用户，无须继续爬取&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果有更新，则删除之前表中数据，重新爬取并插入数据库表&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最终完成后: 断开数据库连接，关闭浏览器&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GovSpider(object):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置无界面&lt;/span&gt;
        options =&lt;span&gt; webdriver.ChromeOptions()
        options.add_argument(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;--headless&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.browser &lt;/span&gt;= webdriver.Chrome(options=options)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加参数&lt;/span&gt;
        self.one_url = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.mca.gov.cn/article/sj/xzqh/2019/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建数据库和相关变量&lt;/span&gt;
        self.db = pymysql.connect(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;govdb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.cursor &lt;/span&gt;=&lt;span&gt; self.db.cursor()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建3个列表,用来executemany()往3张表中插入记录&lt;/span&gt;
        self.province_list =&lt;span&gt; []
        self.city_list &lt;/span&gt;=&lt;span&gt; []
        self.county_list &lt;/span&gt;=&lt;span&gt; []

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取首页,并提取二级页面链接(虚假链接)&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_incr_url(self):
        self.browser.get(self.one_url)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取最新链接,判断是否需要增量爬&lt;/span&gt;
        td = self.browser.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//td[@class=&quot;arlisttd&quot;]/a[contains(@title,&quot;代码&quot;)]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取链接 和 数据库中做比对,确定是否需要怎俩那个抓取&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; get_attribute()会自动补全提取的链接&lt;/span&gt;
        two_url = td.get_attribute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;href&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; result为返回的受影响的条数&lt;/span&gt;
        result = self.cursor.execute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;select url from version where url=%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, [two_url])
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; result:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;无须爬取&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            td.click()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 切换句柄&lt;/span&gt;
            all_handlers =&lt;span&gt; self.browser.window_handles
            self.browser.switch_to.window(all_handlers[&lt;/span&gt;1&lt;span&gt;])
            self.get_data()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据抓取&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把URL地址存入version表&lt;/span&gt;
            self.cursor.execute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete from version&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
            self.cursor.execute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;insert into version values(%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, [two_url])
            self.db.commit()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 二级页面中提取行政区划代码&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_data(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 基准xpath&lt;/span&gt;
        tr_list = self.browser.find_elements_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//tr[@height=&quot;19&quot;]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; tr &lt;span&gt;in&lt;/span&gt;&lt;span&gt; tr_list:
            code &lt;/span&gt;= tr.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./td[2]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text.strip()
            name &lt;/span&gt;= tr.find_element_by_xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./td[3]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).text.strip()
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(name, code)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断层级关系,添加到对应的数据库表中(对应表中字段)&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; province: p_name p_code&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; city    : c_name c_code c_father_code&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; county  : x_name x_code x_father_code&lt;/span&gt;

            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把数据添加到对应的表中&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; code[-4:] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                self.province_list.append([name, code])
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; name &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京市&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;天津市&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;上海市&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;重庆市&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
                    self.city_list.append([name, code, code])

            &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; code[-2:] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                self.city_list.append([name, code, (code[:&lt;/span&gt;2] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)])

            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; code[:2] &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]:
                    self.county_list.append([name, code, (code[:&lt;/span&gt;2] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)])
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    self.county_list.append([name, code, (code[:&lt;/span&gt;4] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)])

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; # 和for循环同缩进,所有数据爬完后统一excutemany()，&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行数据库插入语句&lt;/span&gt;
&lt;span&gt;        self.insert_mysql()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; insert_mysql(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 更新时一定要先删除表记录&lt;/span&gt;
        self.cursor.execute(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete from province&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.cursor.execute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete from city&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.cursor.execute(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;delete from county&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 插入新数据&lt;/span&gt;
        self.cursor.executemany(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;insert into province values(%s,%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self.province_list)
        self.cursor.executemany(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;insert into city values(%s,%s,%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self.city_list)
        self.cursor.executemany(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;insert into county values(%s,%s,%s)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self.county_list)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.提交到数据库执行&lt;/span&gt;
&lt;span&gt;        self.db.commit()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;数据抓取完成,成功存入数据库&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; main(self):
        self.get_incr_url()
        self.cursor.close()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 所有数据处理完成后断开连接&lt;/span&gt;
&lt;span&gt;        self.db.close()
        self.browser.quit()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 关闭浏览器&lt;/span&gt;


&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    spider &lt;/span&gt;=&lt;span&gt; GovSpider()
    spider.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;SQL命令练习&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. 查询所有省市县信息（多表查询实现）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; province.p_name,city.c_name,county.x_name &lt;span&gt;from&lt;/span&gt; province,city,county  &lt;span&gt;where&lt;/span&gt; province.p_code&lt;span&gt;=&lt;/span&gt;city.c_father_code &lt;span&gt;and&lt;/span&gt; city.c_code&lt;span&gt;=&lt;/span&gt;county.x_father_code;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 查询所有省市县信息（连接查询实现）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; province.p_name,city.c_name,county.x_name &lt;span&gt;from&lt;/span&gt; province &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; city &lt;span&gt;on&lt;/span&gt; province.p_code&lt;span&gt;=&lt;/span&gt;city.c_father_code &lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; county &lt;span&gt;on&lt;/span&gt; city.c_code&lt;span&gt;=&lt;/span&gt;county.x_father_code;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;Web客户端验证&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在URL地址中填入即可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;url = 'http://用户名:密码@正常地址'&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例: 爬取某一天笔记&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt;&lt;span&gt; selenium import webdriver
​
url &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://tarenacode:code_2013@code.tarena.com.cn/AIDCode/aid1904/15-spider/spider_day06_note.zip&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
browser &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; webdriver.Chrome()
browser.get(url)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;iframe子框架&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;iframe子框架适用于&lt;/span&gt;&lt;span&gt;网页中嵌套了网页，这种情况应该先切换到iframe子框架，然后再执行其他操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;browser.switch_to.iframe(iframe_element)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例 - 登录qq邮箱&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver

browser &lt;/span&gt;=&lt;span&gt; webdriver.Chrome()
browser.get(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://mail.qq.com/cgi-bin/loginpage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找iframe子框架并切换到此iframe&lt;/span&gt;
login_frame = browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login_frame&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
browser.switch_to.frame(login_frame)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; qq+密码+登录&lt;/span&gt;
browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;账号&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
browser.find_element_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
browser.find_element_by_id(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;login_button&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()

time.sleep(&lt;/span&gt;5)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 预留页面记载时间&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取数据&lt;/span&gt;
ele = browser.find_element_by_id(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;useralias&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ele.text)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 07 Sep 2019 17:14:00 +0000</pubDate>
<dc:creator>凌逆战</dc:creator>
<og:description>Web自动化测试工具，可运行在浏览器，根据指令操作浏览器，只是工具，必须与第三方浏览器结合使用，相比于之前学的爬虫只是慢了一点而已。而且这种方法爬取的东西不用在意时候ajax动态加载等反爬机制。因此找</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LXP-Never/p/11386933.html</dc:identifier>
</item>
<item>
<title>【原创】（三）Linux paging_init解析 - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/11483948.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/11483948.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Kernel版本：4.14&lt;/li&gt;
&lt;li&gt;ARM64处理器，Contex-A53，双核&lt;/li&gt;
&lt;li&gt;使用工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从&lt;code&gt;（二）Linux物理内存初始化&lt;/code&gt;中，可知在&lt;code&gt;paging_init&lt;/code&gt;调用之前，存放&lt;code&gt;Kernel Image&lt;/code&gt;和&lt;code&gt;DTB&lt;/code&gt;的两段物理内存区域可以访问了（相应的页表已经建立好）。尽管物理内存已经通过&lt;code&gt;memblock_add&lt;/code&gt;添加进系统，但是这部分的物理内存到虚拟内存的映射还没有建立，可以通过&lt;code&gt;memblock_alloc&lt;/code&gt;分配一段物理内存，但是还不能访问，一切还需要等待&lt;code&gt;paging_init&lt;/code&gt;的执行。最终页表建立好后，可以通过虚拟地址去访问最终的物理地址了。&lt;/p&gt;
&lt;p&gt;按照惯例，先上图，来一张ARM64内核的内存布局图片吧，最终的布局如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201909/1771657-20190907233854385-1365207283.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开启探索之旅吧！&lt;/p&gt;

&lt;p&gt;&lt;code&gt;paging_init&lt;/code&gt;源代码短小精悍，直接贴上来，分模块来介绍吧。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;/*
 * paging_init() sets up the page tables, initialises the zone memory
 * maps and sets up the zero page.
 */
void __init paging_init(void)
{
    phys_addr_t pgd_phys = early_pgtable_alloc();   /********(mark 1)*******/
    pgd_t *pgd = pgd_set_fixmap(pgd_phys);

    map_kernel(pgd);                                        /********(mark 2)*******/
    map_mem(pgd);                                         /********(mark 3)*******/

    /*
     * We want to reuse the original swapper_pg_dir so we don't have to
     * communicate the new address to non-coherent secondaries in
     * secondary_entry, and so cpu_switch_mm can generate the address with
     * adrp+add rather than a load from some global variable.
     *
     * To do this we need to go via a temporary pgd.
     */
    cpu_replace_ttbr1(__va(pgd_phys));                 /********(mark 4)*******/
    memcpy(swapper_pg_dir, pgd, PGD_SIZE);
    cpu_replace_ttbr1(lm_alias(swapper_pg_dir));

    pgd_clear_fixmap();
    memblock_free(pgd_phys, PAGE_SIZE);

    /*
     * We only reuse the PGD from the swapper_pg_dir, not the pud + pmd
     * allocated with it.
     */
    memblock_free(__pa_symbol(swapper_pg_dir) + PAGE_SIZE,
              SWAPPER_DIR_SIZE - PAGE_SIZE);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;mark 1&lt;/code&gt;：分配一页大小的物理内存存放&lt;code&gt;pgd&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mark 2&lt;/code&gt;：将内核的各个段进行映射；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mark 3&lt;/code&gt;：将memblock子系统添加的物理内存进行映射；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mark 4&lt;/code&gt;：切换页表，并将新建立的页表内容替换&lt;code&gt;swappper_pg_dir&lt;/code&gt;页表内容；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码看起来费劲？图来了：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201909/1771657-20190907233919382-85485881.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下边将对各个子模块进一步的分析。&lt;/p&gt;

&lt;p&gt;这个模块与&lt;code&gt;FIX MAP&lt;/code&gt;映射区域相关，建议先阅读前文&lt;code&gt;（二）Linux物理内存初始化&lt;/code&gt;&lt;br/&gt;先上图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201909/1771657-20190907233938369-447541387.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FIX MAP&lt;/code&gt;的区域划分从图中可以看出来&lt;br/&gt;本函数会先分配物理内存，然后借用之前的全局页表&lt;code&gt;bm_pte&lt;/code&gt;，建立物理地址到虚拟地址的映射，这次映射的作用是为了去访问物理内存，把内存清零，所以它只是一个临时操作，操作完毕后，会调用&lt;code&gt;pte_clear_fixmap()&lt;/code&gt;来清除映射。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;early_pgtable_alloc&lt;/code&gt;之后，我们看到&lt;code&gt;paging_init&lt;/code&gt;调用了&lt;code&gt;pgd_set_fixmap&lt;/code&gt;函数，这个函数调用完后，通过&lt;code&gt;memblock_alloc&lt;/code&gt;分配的物理内存，最终就会用来存放&lt;code&gt;pgd table&lt;/code&gt;了，这片区域的内容最后也会拷贝到&lt;code&gt;swapper_pg_dir&lt;/code&gt;中去。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;map_kernel&lt;/code&gt;的主要工作是完成内核中各个段的映射，此外还包括了&lt;code&gt;FIXADDR_START&lt;/code&gt;虚拟地址的映射，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201909/1771657-20190907233959419-1599284142.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;映射完成之后，可以看一下具体各个段的区域，以我自己使用的平台为例：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201909/1771657-20190907234010351-796860477.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些地址信息也能从&lt;code&gt;System.map&lt;/code&gt;文件中找到。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;aarch64-linux-gnu-objdump -x vmlinux&lt;/code&gt;能查看更详细的地址信息。&lt;/p&gt;

&lt;p&gt;从函数名字中可以看出，&lt;code&gt;map_mem&lt;/code&gt;主要完成的是物理内存的映射，这部分的物理内存是通过&lt;code&gt;memblock_add&lt;/code&gt;添加到系统中的，当对应的memblock设置了&lt;code&gt;MEMBLOCK_NOMAP&lt;/code&gt;的标志时，则不对其进行地址映射。&lt;br/&gt;&lt;code&gt;map_mem&lt;/code&gt;函数中，会遍历memblock中的各个块，然后调用&lt;code&gt;__map_memblock&lt;/code&gt;来完成实际的映射操作。先来一张效果图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201909/1771657-20190907234053558-1917912244.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map_mem&lt;/code&gt;都是将物理地址映射到线性区域中，我们也发现了&lt;code&gt;Kernel Image&lt;/code&gt;中的&lt;code&gt;text, rodata&lt;/code&gt;段映射了两次，原因是其他的子系统，比如&lt;code&gt;hibernate&lt;/code&gt;，会映射到线性区域中，可能需要线性区域的地址来引用内核的&lt;code&gt;text, rodata&lt;/code&gt;，映射的时候也会限制成了&lt;code&gt;只读/不可执行&lt;/code&gt;，防止意外修改或执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map_kernel&lt;/code&gt;和&lt;code&gt;map_mem&lt;/code&gt;函数中的页表映射，最终都是调用&lt;code&gt;__create_pgd_mapping&lt;/code&gt;函数实现的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201909/1771657-20190907234105579-1641393232.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总体来说，就是逐级页表建立映射关系，同时中间会进行权限的控制等。&lt;br/&gt;细节不再赘述，代码结合图片阅读，效果会更佳噢。&lt;/p&gt;

&lt;p&gt;这部分代码不多，不上图了，看代码吧：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;    /*
     * We want to reuse the original swapper_pg_dir so we don't have to
     * communicate the new address to non-coherent secondaries in
     * secondary_entry, and so cpu_switch_mm can generate the address with
     * adrp+add rather than a load from some global variable.
     *
     * To do this we need to go via a temporary pgd.
     */
    cpu_replace_ttbr1(__va(pgd_phys));
    memcpy(swapper_pg_dir, pgd, PGD_SIZE);
    cpu_replace_ttbr1(lm_alias(swapper_pg_dir));

    pgd_clear_fixmap();
    memblock_free(pgd_phys, PAGE_SIZE);

    /*
     * We only reuse the PGD from the swapper_pg_dir, not the pud + pmd
     * allocated with it.
     */
    memblock_free(__pa_symbol(swapper_pg_dir) + PAGE_SIZE,
              SWAPPER_DIR_SIZE - PAGE_SIZE);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说，将新建立好的pgd页表内容，拷贝到&lt;code&gt;swapper_pg_dir&lt;/code&gt;中，也就是覆盖掉之前的临时页表了。当拷贝完成后，显而易见的是，我们可以把&lt;code&gt;paging_init&lt;/code&gt;一开始分配的物理内存给释放掉。&lt;br/&gt;此外，在之前的文章也分析过&lt;code&gt;swapper_pg_dir&lt;/code&gt;页表存放的时候，是连续存放的&lt;code&gt;pgd, pud, pmd&lt;/code&gt;等，现在只需要复用&lt;code&gt;swapper_pg_dir&lt;/code&gt;，其余的当然也是可以释放的了。&lt;/p&gt;
&lt;p&gt;好了，点到为止，前路漫漫，离Buddy System，Slab，Malloc以及各种内存的骚操作好像还有很远的样子，待续吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201909/1771657-20190907234128359-1375441302.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Sep 2019 15:43:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背景 By 鲁迅 By 高尔基 说明： 1. Kernel版本：4.14 2. ARM64处理器，Contex A53，双核 3. 使用工具：Source Insight 3.5， Visio 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/11483948.html</dc:identifier>
</item>
<item>
<title>数据导出excel - 尚僧疯</title>
<link>http://www.cnblogs.com/fjl0418/p/11461393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fjl0418/p/11461393.html</guid>
<description>&lt;p&gt;在开发过程中，系统中经常有些列表需要导出，运用poi的API简单导出是可以很快的完成此功能，但是随着系统数据的增多，前端和后端一般是采用短链接的方式进行交互，由于后台数据量过大，前后端连接超时，导致导出excel失败，（如果sql没问题一般可导出几百数据），当数据达到上千或者上万数据导出失败。现在可利用redis缓存技术实现成千上万条数据导出，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1281255/201909/1281255-20190904203103103-357885072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上是思路示意图，从示意图中可以看出，此功能的开发必须要有前端的绝对配合。在此设计思路中有一个缺陷，只要有足够的耐心等待，好像可以导出N多数据，实际结果是这样的，但是对于业务上来说是不符合的，大量的数据导出时要考虑到分页，还有考虑到对redis的内存占用，所以最好是在业务上有一定的限制，比如指定时间段，或者按照其他的过滤条件。&lt;/p&gt;


</description>
<pubDate>Sat, 07 Sep 2019 15:26:00 +0000</pubDate>
<dc:creator>尚僧疯</dc:creator>
<og:description>在开发过程中，系统中经常有些列表需要导出，运用poi的API简单导出是可以很快的完成此功能，但是随着系统数据的增多，前端和后端一般是采用短链接的方式进行交互，由于后台数据量过大，前后端连接超时，导致导</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fjl0418/p/11461393.html</dc:identifier>
</item>
<item>
<title>多表操作 - 小中配奇</title>
<link>http://www.cnblogs.com/xiaozhongfeixiang/p/11483513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaozhongfeixiang/p/11483513.html</guid>
<description>&lt;h2&gt;表关系&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一对多&lt;/li&gt;
&lt;li&gt;一对多      &amp;gt;&amp;gt;  &lt;strong&gt;&lt;span&gt;一：主表     &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;多：从表&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;多对多     &amp;gt;&amp;gt;  &lt;span&gt;中间表中&lt;span&gt;&lt;strong&gt;最少应该由两个字段组成&lt;/strong&gt;&lt;/span&gt;，这两个字段作为外键指向两张表的主键，又组成了联合主键&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; 分析步骤&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;明确表关系&lt;/li&gt;
&lt;li&gt;确定表关系（ 描述： 外键  |  中间表 ）&lt;/li&gt;
&lt;li&gt;编写实体类，在实体类中描述表关系（包含关系）&lt;/li&gt;
&lt;li&gt;配置映射关系&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;完成多表操作&lt;/h2&gt;
&lt;h3&gt;一对多操作 &lt;span&gt;&lt;strong&gt;案例：客户和联系人（一对多关系）&lt;/strong&gt;&lt;/span&gt; &lt;/h3&gt;
&lt;p&gt;    &amp;gt;&amp;gt; &lt;strong&gt;客户&lt;/strong&gt;：一家公司     &lt;strong&gt;联系人&lt;/strong&gt;：这家公司的员工&lt;/p&gt;
&lt;p&gt;　一个客户可以具有多个联系人，一个联系人从属于一家公司&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;分析步骤&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　1. 明确表关系  &amp;gt;&amp;gt; 一对多关系&lt;/p&gt;
&lt;p&gt;　　2. 确定表关系,&lt;span&gt;再从表上添加外键&lt;/span&gt;（描述: 外键 I 中间表）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主表：客户表   &lt;/li&gt;
&lt;li&gt;从表：联系人表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　3. 编写实体类，在实体类中描述表关系（包含关系）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户：在客户的实体类中包含一个联系人的集合&lt;/li&gt;
&lt;li&gt;联系人：在联系人的实体类中包含一个客户的对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　4. 配置映射关系&lt;br/&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;使用JPA注解配置一对多映射关系&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;操作步骤&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1.引入依赖坐标，导入实体类和xml文件&lt;/p&gt;
&lt;p&gt;2.  &lt;strong&gt;&lt;span&gt;Customer&lt;/span&gt;   &lt;/strong&gt;&amp;gt;&amp;gt;&lt;strong&gt; &lt;/strong&gt;配置客户和联系人之间的一对多关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;   @OneToMany(targetEntity = LinkMan.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) &lt;span&gt;&lt;strong&gt;&lt;span&gt;//对方实体类的字节码对象
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   @JoinColumn(name = &quot;lkm_cust_id&quot;,referencedColumnName = &quot;cust_id&quot;&lt;span&gt;) &lt;span&gt;&lt;strong&gt;//name：外键的名称   referencedColumnName： 外键的取值来源
&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; Set&amp;lt;LinkMan&amp;gt; linkMans = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;LinkMan&amp;gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  LinkMan   &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&amp;gt;&amp;gt; 配置客户和联系人之间的一对多关系&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt;   @ManyToOne(targetEntity = Customer.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   @JoinColumn(name = &quot;lkm_cust_id&quot;,referencedColumnName = &quot;cust_id&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;private&lt;/span&gt; Customer customer;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;配置外键的过程中，配置到多的一方，就会在多的一方维护外键&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3. 保存一个客户，保存一个联系人&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; @RunWith(SpringJUnit4ClassRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; @ContextConfiguration(locations = &quot;classpath:applicationContext.xml&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OneToManyTest {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; CustomerDao customerDao;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; LinkManDao linkManDao;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;     * &lt;span&gt;保存一个客户，保存一个联系人
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;10      *  效果：客户和联系人作为独立的数据保存到数据库中
11      *      &lt;span&gt;联系人的外键为空
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;     *  &lt;span&gt;&lt;strong&gt;原因？ &amp;gt;&amp;gt; &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;实体类中没有配置关系!!
&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Test
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     @Transactional &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置事务&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     @Rollback(&lt;span&gt;false&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;不自动回滚&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testAdd() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个客户，创建一个联系人&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         Customer customer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Customer();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         customer.setCustname(&quot;百度&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         LinkMan linkMan = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LinkMan();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         linkMan.setLkmName(&quot;小李&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;         * 配置了客户到联系人的关系
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;         *      从客户的角度上：发送两条insert语句，发送一条更新语句更新数据库&lt;span&gt;（更新外键）
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;         * 由于我们配置了客户到联系人的关系：客户可以对外键进行维护
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;customer.getLinkMans().add(linkMan);
&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        customerDao.save(customer);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        linkManDao.save(linkMan);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;进行改进&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;         * 配置联系人到客户的关系（多对一）
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;         *    只发送了两条insert语句
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;         * 由于配置了联系人到客户的映射关系（多对一），联系人就能在保存的时候维护外键&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;          &lt;span&gt;*/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;strong&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;linkMan.setCustomer(customer);&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再进行改进&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; linkMan.setCustomer(customer);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于配置了多的一方到一的一方的关联关系（当保存的时候，就已经对外键赋值）&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         customer.getLinkMans().add(linkMan);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;由于配置了一的一方到多的一方的关联关系（发送一条update语句）&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：会有一条多余的update语句 ，是由于一的一方会维护外键，发送update语句&lt;/p&gt;
&lt;p&gt;解决的办法：只需要在一的一方放弃维护权即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@OneToMany(mappedBy = &quot;&lt;strong&gt;customer&lt;/strong&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;//  &lt;span&gt;&lt;span&gt;&lt;strong&gt;mappedBy&lt;/strong&gt;&lt;/span&gt;：对方配置关系的属性名称，如下&lt;span&gt;橙色条
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Set&amp;lt;LinkMan&amp;gt; linkMans = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;LinkMan&amp;gt;();对方配置关系的属性名称&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
@ManyToOne(targetEntity = Customer.class)&lt;br/&gt;@JoinColumn(name = &quot;lkm_cust_id&quot;,referencedColumnName = &quot;cust_id&quot;)&lt;br/&gt;&lt;span&gt;private Customer &lt;span&gt;&lt;strong&gt;customer&lt;/strong&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 07 Sep 2019 14:31:00 +0000</pubDate>
<dc:creator>小中配奇</dc:creator>
<og:description>多表之间的关系和操作多表的操作步骤 表关系 一对多 一对多 &amp;gt;&amp;gt; 一：主表 多：从表 多对多 &amp;gt;&amp;gt; 中间表中最少应该由两个字段组成，这两个字段作为外键指向两张表的主键，又组成了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaozhongfeixiang/p/11483513.html</dc:identifier>
</item>
<item>
<title>堆实战(动态数据流求top k大元素,动态数据流求中位数) - H&amp;K</title>
<link>http://www.cnblogs.com/HKUI/p/11483392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HKUI/p/11483392.html</guid>
<description>&lt;h4 id=&quot;动态数据集合中求top-k大元素&quot;&gt;动态数据集合中求top k大元素&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;第1大，第2大 ...第k大
k是这群体里最小的

所以要建立个小顶堆
只需要维护一个大小为k的小顶堆 即可

当来的元素(newCome)&amp;gt; 堆顶元素(smallTop),说明进来的元素有和堆顶竞争的资格,此时的堆顶被踢出 这时把进来的元素放到堆顶
newCome&amp;gt;smallTop,smallTop的左右孩子&amp;gt;smallTop,所以无法确认 newCome和smallTop的左右孩子的大小关系，
在newCome和smallTop的左右子节点找到最小的元素和newCome交换，然后继续比较newCome与被交换的左右孩子的大小关系
持续这个过程(堆化)即可
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果每次询问前K大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是O(nlogK)，n表示当前的数据的大小&lt;/p&gt;
&lt;p&gt;部分代码&lt;br/&gt;topn.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$static_data=[2,5,3,1,0,7,6,10];


//第3大
/*
2,5,3               2
2,5,3 1             2
2,5,3,1,0           2
2,5,3,1,0,7         3
2,5,3,1,0,7,6       5
2,5,3,1,0,7,6,10    6

维持1个小顶堆 大小为3即可
*/
$heap=new Heap(3); //建立一个大小为3的小顶堆
foreach ($static_data as $v){
    echo $heap-&amp;gt;topn($v).PHP_EOL;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;heap.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function topn($data)
{
    //堆满了
    if ($this-&amp;gt;isFull()) {
        if ($data &amp;gt; $this-&amp;gt;dataArr[1]) {
            $this-&amp;gt;dataArr[1] = $data;
            $this-&amp;gt;smallHeapFirst();
        }
    } else {
        $this-&amp;gt;dataArr[$this-&amp;gt;count + 1] = $data;
        $this-&amp;gt;count++;
        $this-&amp;gt;smallHeapLast();

    }
    return $this-&amp;gt;dataArr[1];

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hkui/algo_practice/blob/master/php/10_heap/topn.php&quot;&gt;完整代码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;动态数据留求中位数&quot;&gt;动态数据留求中位数&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;2,3,1,7,5       返回3
1,3,1,7,5,4     返回3,4
数据持续往里面进，每进来一个数，就询问中位数是谁们
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;step1-思路分析&quot;&gt;step1 思路分析:&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;
所谓中位数，就是中间大的1个或者2个元素，中位数满足的性质，中位数之前的数都它，之后的数都大于它
先以奇数个分析，偶数个原理一样
1.如果是固定的数据集合，比如数据为n个，中位数即为n/2+1 大的元素，此时只需维护一个大小为(n/2+1) 大小的小顶堆即可
    为什么不能是大顶堆呢，如果堆顶最大，除了知能找到这群集合的最大值外，其它的都无从知晓了
    如果是小顶堆，堆顶最小，数据集合比如为5个，第3大的元素肯定小于已经比较过的前2个数，即为中间元素
    
    但是现在是动态数据流，每次进来1个元素，都会询问中间元素
    
    和静态数据的区别是:不知道维护的小顶堆的大小了
    这时需要维护2个堆了，来了数据，分别放到这2个堆
    1个大顶堆，1个小顶堆，大顶堆的数据均小于小顶堆的数据，当要询问的时候
    如果是偶数个数据，两个堆的堆顶元素即为中间元素
    如果奇数个数据，两个堆中数据较多的那个堆的堆顶元素即为中间元素&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;step1-步骤分析&quot;&gt;step1 步骤分析&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;大顶堆为big,堆顶元素bigpeak,大小为bigsize,小顶堆称small,堆顶元素为smallpeak,大小为smallsize


进来1个元素，big为空  :放入big
             big不为空:
                        放入元素&amp;lt;bigpeak，放入到big
                        放入元素&amp;gt;bigpeak, 放入到small
             
             放入1个元素完成后
                    如果bigsize-smallsize&amp;gt;1,把big元素的堆顶元素拿掉 堆化big,把拿掉的元素放入small 然后堆化
                    如果bigsize-smallsize&amp;lt;1,把small元素的堆顶元素拿掉 堆化small,把拿掉的元素放入big 然后堆化
             
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;findmiddle.php&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$arr = [9, 8, 11, 4, 2, 6, 5, 1, -1, 3, 20, 10];
//$arr=[9,8,11,4,2,6,5,100];

findMiddle($arr);

//动态数据实时获取中位数
function findMiddle($arr)
{
    //大顶堆
    $bigHeap = new Heap(0, 1);
    //小顶堆
    $smallHeap = new Heap(0, 0);

    foreach ($arr as $k =&amp;gt; $v) {
        if ($bigHeap-&amp;gt;isEmpty()) {
            $bigHeap-&amp;gt;insert($v);
        } else {
            $bigPeak = $bigHeap-&amp;gt;peak();
            if ($v &amp;lt; $bigPeak) {
                $bigHeap-&amp;gt;insert($v);
            } else {
                $smallHeap-&amp;gt;insert($v);
            }

            if ($bigHeap-&amp;gt;count - $smallHeap-&amp;gt;count &amp;gt; 1) {
                $bigPeak = $bigHeap-&amp;gt;deleteFirst();
                $smallHeap-&amp;gt;insert($bigPeak);
            } elseif ($smallHeap-&amp;gt;count - $bigHeap-&amp;gt;count &amp;gt; 1) {
                $smallPeak = $smallHeap-&amp;gt;deleteFirst();
                $bigHeap-&amp;gt;insert($smallPeak);
            }

        }
        //实时获取中位数
        echo implode(',', midPeak($bigHeap, $smallHeap)) . PHP_EOL;
    }


}

function midPeak($heap1, $heap2)
{
    if ($heap1-&amp;gt;count == $heap2-&amp;gt;count) {
        $midArr = [$heap1-&amp;gt;peak(), $heap2-&amp;gt;peak()];
    } elseif ($heap2-&amp;gt;count &amp;gt; $heap1-&amp;gt;count) {
        $midArr = [$heap2-&amp;gt;peak()];
    } else {
        $midArr = [$heap1-&amp;gt;peak()];
    }
    return $midArr;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;过程分析&quot;&gt;过程分析&lt;/h4&gt;
&lt;h5 id=&quot;几个重要的点&quot;&gt;几个重要的点&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;两个堆元素数相等时中间元素为两个堆顶&lt;br/&gt;否者为较多元素堆的堆顶&lt;/li&gt;
&lt;li&gt;两者元素个数差值大于1时，要调整堆的元素个数&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;依次插入的元素 为 9, 8, 11, 4, 2, 6, 5, 1, -1, 3, 20, 10，大顶堆 称为big,小顶堆称为small,各自大小bigsize,smallsize,堆顶为bigpeak，smallpeak,

9进来  big为空，插入big, bigsize-smallsize=1  不大于1       
            此时bigsize&amp;gt;smallsize  中间元素为bigpeak即为[9]
8进来  8&amp;lt;bigpeak,  插入big,bigsize-smallsize=2 大于1        
            此时bigpeak 需要从Big删除，big堆化，放入到small ，small堆化 ,此时bigsize=smallsize  所以中间元素为[bigpeak,smallpeak] 即为[8,9]
11进来 11&amp;gt;bigpeak(8),11插入small,此时smallsize=2,bigsize=1,差值不大于1，因为smallsize&amp;gt;bigsize,中间元素为[smallpeak] 即为[9]
4进来  4&amp;lt;bigpeak(8),4插入到big,big堆化，此时bigsize=2,smallsize=2,中间元素为[bigpeak,smallpeak] 即为[8,9]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时堆图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/7F8DC5F04F7845E2893A161832B555F9?method=download&amp;amp;shareKey=ebaec91e828d91674360a56254028b32&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2进来 2&amp;lt;8 ,2插入big然后堆化，bigsize=3,smallsize=2 所以此时中位数为[8]
6进来 6&amp;lt;8,6插入big后堆化 为下图&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/AB34E79ED452491BB0CBC3D1C06DB483?method=download&amp;amp;shareKey=6676650724b8eb11bfff1ad858fa6fc1&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 此时,bigsize=4,smallsize=2,bigsize-smallsize&amp;gt;1,删除big的堆顶元素 堆化，然后把把删除的元素插入到small，堆化后
 此时big,small见下图,中间元素位[bigpeak,smallpeak]即 [6,8]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/EFF6CB6257F640CCA6026A74F8526227?method=download&amp;amp;shareKey=0c3c7a7ea39420b1ff9371bcdccc09f4&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;5进来 5&amp;lt;bigpeak(8),5插入big堆化
此时Bigsize=4,smallsize=3,差值不大于1，中间元素位bigpeak 即为[6]
之后的步骤同理
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入数据因为需要涉及堆化，所以时间复杂度变成了O(logn)，但是求中位数我们只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是O(1)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hkui/algo_practice/blob/master/php/10_heap/findmiddle.php&quot;&gt;完整代码&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 07 Sep 2019 14:10:00 +0000</pubDate>
<dc:creator>H&amp;amp;K</dc:creator>
<og:description>堆应用(动态数据求top k,动态数据求中位数)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/HKUI/p/11483392.html</dc:identifier>
</item>
<item>
<title>8. 函数-闭包 - qi.hu</title>
<link>http://www.cnblogs.com/hq82/p/11483338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hq82/p/11483338.html</guid>
<description>&lt;h3 id=&quot;一函数名&quot;&gt;一、函数名&lt;/h3&gt;
&lt;p&gt;​ 函数名是⼀个变量, 但它是⼀个特殊的变量, 与括号配合可以执⾏函数的变量。&lt;/p&gt;
&lt;h4 id=&quot;函数名的内存地址&quot;&gt;1. 函数名的内存地址&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def func():
    print(&quot;呵呵&quot;)
    print(func)
结果:
&amp;lt;function func at 0x1101e4ea0&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数名可以赋值给其他变量&quot;&gt;2. 函数名可以赋值给其他变量&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def func():
    print(&quot;呵呵&quot;)
    print(func)
# 把函数当成⼀个变量赋值给另⼀个变量
a = func
# 函数调⽤ func()
a() &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数名可以当做函数的参数&quot;&gt;3. 函数名可以当做函数的参数&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def func():
    print(&quot;吃了么&quot;)
def func2(fn):
    print(&quot;我是func2&quot;)
    fn() 
    print(&quot;我是func2&quot;)
# 把函数func当成参数传递给func2的参数fn.
func2(func) &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数名可以作为函数的返回值&quot;&gt;4. 函数名可以作为函数的返回值&lt;/h4&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def func_1():
    print(&quot;这⾥是函数1&quot;)
def func_2():
    print(&quot;这⾥是函数2&quot;)
    print(&quot;这⾥是函数1&quot;)
    return func_2
# 执⾏函数1. 函数1返回的是函数2, 这时fn指向的就是上⾯函数2
fn = func_1()
# 执⾏上⾯返回的函数
fn()    &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二闭包&quot;&gt;二、闭包&lt;/h3&gt;
&lt;h4 id=&quot;定义&quot;&gt;1. 定义&lt;/h4&gt;
&lt;p&gt;​ 如果在一个内部函数里，对在外部作用于（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包。&lt;/p&gt;
&lt;p&gt;​ 闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，闭包是由函数和与其相关的引用环境组合而成的实体。&lt;/p&gt;
&lt;p&gt;​ 通俗的讲就是：如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包（closure）。它只不过是个“内层”的函数，由一个名字（变量）来指代，而这个名字（变量）对于“外层”包含它的函数而言，是本地变量。&lt;/p&gt;
&lt;p&gt;​ 闭包的主要用途：&lt;strong&gt;实现装饰器&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;闭包运用&quot;&gt;2. 闭包运用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;闭包函数必须有内嵌函数&lt;/li&gt;
&lt;li&gt;内嵌函数需要引用该嵌套函数上一级namespace中的变量&lt;/li&gt;
&lt;li&gt;闭包函数必须返回内嵌函数&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;普通闭包&quot;&gt;(1) 普通闭包&lt;/h5&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def func(a, b):
    def line(x):
        return a * x - b
    return line

line = func(2, 3)
print(line(5))&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;修改值闭包&quot;&gt;(2) 修改值闭包&lt;/h5&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def func(a, b):
    def line(x):
        nonlocal a
        a = 3
        return a * x - b
    return line

line = func(2, 3)
print(line(5))&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 07 Sep 2019 13:59:00 +0000</pubDate>
<dc:creator>qi.hu</dc:creator>
<og:description>一、函数名 ​	函数名是⼀个变量, 但它是⼀个特殊的变量, 与括号配合可以执⾏函数的变量。 1. 函数名的内存地址 2. 函数名可以赋值给其他变量 3. 函数名可以当做函数的参数 4. 函数名可以作为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hq82/p/11483338.html</dc:identifier>
</item>
<item>
<title>Three.js 开发机房（三） - 朱格利斯</title>
<link>http://www.cnblogs.com/teersky/p/11481397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/teersky/p/11481397.html</guid>
<description>&lt;p&gt;之前三节都没涉及到机房，只是一些零零散散的知识点，这一节我们就开始正式画外墙。&lt;/p&gt;
&lt;p&gt;首先我了明显理解以下啥是墙？其实说白了就是一个长方体，长不确定，宽一般也就是40cm，高也就是两米，这就是一个简单的墙，当然很多墙上都有窗户、门啥的，其实也就是在长方体的固定的位置掏个洞，然后放上我们需要方的东西，比如门，窗户。&lt;/p&gt;
&lt;p&gt;在画墙之前我们需要对一个机房的俯视图进行分析，就比如下面这张机房的图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1151321/201909/1151321-20190907134739350-347006302.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图片来自网络）&lt;/p&gt;
&lt;p&gt;就像图片中显示的一样，这个机房非常标准，是个很标准的长方形机房，长900cm, 宽600cm，左侧的墙体是玻璃隔断，还有一扇门，&lt;/p&gt;
&lt;p&gt;那好，我们就可以开干了，首先我们要初始化一个机房的结构布局的Json，注意门不能和窗户重合，有门的地方窗户需要分成门左边和门右边两个数组（当然你也可以写多个判断进行操作，但是比较麻烦）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;76&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
{
　　houseWidth: 900,   // 房间长度
　　houseHeight: 600,  // 房间宽
　　angle: 45,         // 房间朝向
　　wall: [
　　　　{position:{x: 0, y: 0, endX: 900, endY: 0}, door: {isDoor: false}, windows: {isWindows:false}},
　　　　{position:{x: 900, y: 0, endX: 900, endY: 600}, door: {isDoor: false},  windows: {isWindows: false}},
　　　　{position:{x: 0, y: 600, endX: 900, endY: 600}, door: {isDoor: false}, windows: {isWindows:false}},
　　　　{position:{x: 0, y: 0, endX: 0, endY: 600}, door: {isDoor: true, doorNum: 2, door_PointL [{x: 0, y: 200, endX: 0, endY: 400, doorDirection: 2}]},  windows: {isWindows: true, windows__Point: [{x: 0, y: 0, endX: 0, endY: 150}, {x: 0, y: 450, endX: 0, endY: 600}]}}
　　]
},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接下来我们开始画地板，我们目前就将地板和机房大小做一样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    createFloor() {
            let _self = this;
            this.imgRendering.load(&quot;地板的图片&quot;, texture =&amp;gt; {
                texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                texture.repeat.set(8, 8);
                var floorGeometry = new THREE.BoxGeometry(this.houseWidth, this.houseHeight, 1);
                var floorMaterial = new THREE.MeshBasicMaterial({
                    map: texture,
                    side: THREE.DoubleSide
                });
                floorMaterial.opacity = 1;
                floorMaterial.transparent = true;
                var floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = 0;
                floor.rotation.x = Math.PI / 2;

                _self.scene.add(floor);
            })
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1151321/201909/1151321-20190907174856008-1934784637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;紫色是我加给整个Html的颜色，主要是方便观看地板，接下来我们就开始画墙了，在画墙之前我们先初始化一个画长方体（窗宽高均默认为1）的函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
initLambert() {
　　var cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
　　this.initLambertMod = new THREE.Mesh(cubeGeometry, this.wallMatArray);
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;封装好之后我们在画墙的时候就不用每画一道墙就新建一个几何体和材质，我们只需要克隆我们刚才初始化的墙体就好了&lt;/p&gt;
&lt;p&gt;之后我们正式封装具有具体长度、角度和位置在的墙&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/**
  * 画长方体
  * @param { 长方体的长度 } width 
  * @param { 长方体的高度 } height 
  * @param { 长方体的厚度 } depth 
  * @param { 长方体旋转的角度 } angle 
  * @param { 长方体的材质 } material 
  * @param { 长方体的X轴坐标 } x 
  * @param { 长方体的Y轴坐标 } y 
  * @param { 长方体的Z轴坐标 } z 
  */
createLambert(width, height, depth, angle, material, x, y, z) {
    var code = this.initLambertMod.clone();
    code.scale.set(width, height, depth)
    code.position.set(x, y, z);
    code.rotation.set(0, angle * Math.PI, 0); //-逆时针旋转,+顺时针
    return code;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样我们就将一个具有长宽高、方向、位置的长方体就画出来了,&lt;/p&gt;
&lt;p&gt;只是画出来还不行，我们需要将数据和模型关联起来，我们先对 &lt;em&gt;&lt;strong&gt;this.data.wall&lt;/strong&gt;&lt;/em&gt; 进行遍历得到这道墙的具体信息，是否有门窗，墙的起始点和结束点，知道了起始点和结束点，我们就能算出这道墙具体有多长，还有这道墙的角度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1151321/201909/1151321-20190907192953405-1192681520.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，有以上两个点我们能得出该条线的信息&lt;/p&gt;
&lt;p&gt;　　长度：Math.sqrt(Math.pow(Math.abs(300 -0), 2) +Math.pow(Math.abs(0 -300), 2))；&lt;/p&gt;
&lt;p&gt;　　角度：Math.asin((300- 0) / (0 - 300)) / Math.PI&lt;/p&gt;
&lt;p&gt;这样我们就知道了该条线的具体信息，下面我们就能画墙了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
createHouseWall() {
　　this.data.wall.map((item) =&amp;gt; {
　　　　var position = item.position;
　　　　var w = position.endX - position.x;
　　　　var h = position.endY - position.y;
　　　　var x = (position.x + w / 2) - (this.houseWidth / 2);
　　　　var z = (position.y + h / 2) - (this.houseHeight / 2);
　　　　var width = Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2));
　　　　var angle = Math.asin(h / width) / Math.PI;
   
　　　　if (item.windows.isWindows || item.door.isDoor) {
　　　　　　// 有窗户或有门或都有
　　　　} else {
　　　　　　// 没门、没窗户
　　　　　　let code = this.createLambert(width, 200, 10, angle, this.matArrayB, x, 100, z);
　　　　　　this.scene.add(code);
　　　　}
　　});
};        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　执行完我们就能看到如下图这样的结果了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1151321/201909/1151321-20190907200513360-1979856469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还差一面墙，上面既有门又有窗户，那我们就先作既有门又有窗户的，献上一张图爽一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1151321/201909/1151321-20190907211511677-1854794209.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要实现这样，那我们首先要封装一个几何ti裁切函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
/**
  * 几何体裁切函数
  * @param { 被采裁切的集合体 } bsp 
  * @param { 要裁掉的集合体 } less_bsp 
  * @param { 区分是机房的墙还是机柜裁切的 } mat 
  */
returnResultBsp(bsp, less_bsp, mat) {
        switch (mat) {
            case 1:
                var material = new THREE.MeshPhongMaterial({
                    color: 0x9cb2d1,
                    specular: 0x9cb2d1,
                    shininess: 30,
                    transparent: true,
                    opacity: 1
                });
                break;
            case 2:
                var material = new THREE.MeshPhongMaterial({
                    color: 0x42474c,
                    specular: 0xafc0ca,
                    shininess: 30,
                    transparent: true,
                    opacity: 1
                });
                break;
            default:
        }

        var sphere1BSP = new ThreeBSP(bsp);
        var cube2BSP = new ThreeBSP(less_bsp); //0x9cb2d1 淡紫,0xC3C3C3 白灰 , 0xafc0ca灰
        var resultBSP = sphere1BSP.subtract(cube2BSP);
        var result = resultBSP.toMesh(material);
        result.material.flatshading = THREE.FlatShading;
        result.geometry.computeFaceNormals(); //重新计算几何体侧面法向量
        result.geometry.computeVertexNormals();
        result.material.needsUpdate = true; //更新纹理
        result.geometry.buffersNeedUpdate = true;
        result.geometry.uvsNeedUpdate = true;
        if (mat == 2) {
            result.nature = &quot;Cabinet&quot;;
        }
        return result;
    };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　之后我们就开始对有门或者有窗户的墙面开始处理，先整理数据，将数据整理成我么能够最简单就能处理的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;52&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
createHouseWall() {
　　this.data.wall.map((item) =&amp;gt; {
　　　　var position = item.position;
　　　　var w = position.endX - position.x;
　　　　var h = position.endY - position.y;
　　　　var x = (position.x + w / 2) - (this.houseWidth / 2);
　　　　var z = (position.y + h / 2) - (this.houseHeight / 2);
　　　　var width = Math.sqrt(Math.pow(w, 2) + Math.pow(h, 2));
　　　　var angle = Math.asin(h / width) / Math.PI;
   
　　　　if (item.windows.isWindows || item.door.isDoor) {
　　　　　　// 有窗户或有门或都有
          // 当然判断里面还是分开成有门或者有窗户，但互不干涉
          var window__List = [];   // 盛放窗户的数组
          var door__List = [];       // 盛放门的数组
          if (item.windows.isWindows) {
          　　item.windows.windows__Point.map((windows__Point, window__index) =&amp;gt; {
                 let window__Json = {};
                 let windows__w = windows__Point.endX - windows__Point.x;&lt;br/&gt;let windows__h = windows__Point.endY - windows__Point.y;
                 window__Json.window__x = (windows__Point.x + windows__w / 2) - (this.houseWidth / 2);
                 window__Json.window__z = (windows__Point.y + windows__h / 2) - (this.houseHeight / 2);
                 window__Json.window__width = Math.sqrt(Math.pow(windows__w, 2) + Math.pow(windows__h, 2));
                 window__Json.w_Height = 120;
                 window__Json.window__y = 100;
                 window__List.push(window__Json);
              });
          }
　　　　　　if (item.door.isDoor) {
              var door__num = item.door.doorNum || 1;
              item.door.door_Point.map((door__Point, door__index) =&amp;gt; {
                  var door__Json = {};
                  var windows__w = door__Point.endX - door__Point.x;
                  var windows__h = door__Point.endY - door__Point.y;
                  if (door__num == 2) {
                      let doubleDoorList = [];
                      for (var i = 0; i &amp;lt; 2; i++) {
                          door__Json = {};
                          door__Json.door__x = (door__Point.x + windows__w / 2) - (this.houseWidth / 2) + (door__Point.endX - door__Point.x) / 2 * i;
                          door__Json.door__z = (door__Point.y + windows__h / 2) - (this.houseHeight / 2) + (door__Point.endY - door__Point.y) / 2 * i;
                          door__Json.door__width = (Math.sqrt(Math.pow(windows__w, 2) + Math.pow(windows__h, 2))) / 2;
                          door__Json.door__height = 180;
                          door__Json.door__y = 100;
                          door__Json.doorDirection = door__Point.doorDirection;
                          if (door__Point.doorDirection &amp;lt; 2) {
                              doubleDoorList.unshift(door__Json);
                          } else {
                               doubleDoorList.push(door__Json);
                          }
                      }
                       door__List.push(doubleDoorList);
                  } else {
                      door__Json.door__x = (door__Point.x + windows__w / 2) - (this.houseWidth / 2);
                      door__Json.door__z = (door__Point.y + windows__h / 2) - (this.houseHeight / 2);
                      door__Json.door__width = Math.sqrt(Math.pow(windows__w, 2) + Math.pow(windows__h, 2));
                      door__Json.door__height = 180;
                      door__Json.door__y = 100;
                      door__Json.doorDirection = door__Point.doorDirection;
                      door__List.push(door__Json);
                  }
              });
           }
　　　　} else {
　　　　　　// 没门、没窗户
　　　　　　let code = this.createLambert(width, 200, 10, angle, this.matArrayB, x, 100, z);
　　　　　　this.scene.add(code);
　　　　}
　　});
};                
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　整理完成之后我们就要开始对以上数据进行操作了，此时我们就需要创建函数cerateWallHadDoorOrGlass来开始画有玻璃和门的墙了&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;103&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//画有门和有窗子的墙（工具函数）
    cerateWallHadDoorOrGlass(width, height, depth, angle, material, x, y, z, door__list, windows__List) {
        //茶色：0x58ACFA   透明玻璃色：0XECF1F3
        var glass_material = new THREE.MeshBasicMaterial({
            color: 0XECF1F3
        });
        glass_material.opacity = 0.5;
        glass_material.transparent = true;
        var wall = this.returnLambertObject(width, height, depth, angle, material, x, y, z);
        windows__List.map((item, index) =&amp;gt; {
            var window_cube = this.returnLambertObject(item.window__width, item.w_Height, depth, angle, material, item.window__x, item.window__y, item.window__z);
            wall = this.returnResultBsp(wall, window_cube, 1);
            let code = this.returnLambertObject(item.window__width, item.w_Height, 2, angle, glass_material, item.window__x, item.window__y, item.window__z);
            this.scene.add(code);
        });
        var status__result = [0.5, 0.5, 0, 0, ]
        door__list.map((item, index) =&amp;gt; {
            if (item.length == 2) {
                item.map((c_item, c_index) =&amp;gt; {
                    let door_cube = this.returnLambertObject(c_item.door__width, c_item.door__height, 10, angle, this.matArrayB, c_item.door__x, c_item.door__y, c_item.door__z);
                    wall = this.returnResultBsp(wall, door_cube, 1);
                    let doorgeometry = new THREE.BoxGeometry(100, 180, 2);
                    let door = &quot;&quot;;
                    if (c_index == 0) {
                        door = new THREE.Mesh(doorgeometry, this.LeftDoorRenderingList);
                    } else {
                        door = new THREE.Mesh(doorgeometry, this.DoorRenderingList);
                    }
                    door.position.set(c_item.door__x, c_item.door__y, c_item.door__z);
                    door.rotation.y = status__result[c_item.doorDirection] * Math.PI;
                    door.nature = &quot;door&quot;;
                    door.direction = c_item.doorDirection;
                    door.isClose = 1;
                    door.doorIndex = c_index;
                    this.scene.add(door);
                });
            } else {
                let door_cube = this.returnLambertObject(item.door__width, item.door__height, 10, angle, this.matArrayB, item.door__x, item.door__y, item.door__z);
                wall = this.returnResultBsp(wall, door_cube, 1);
                let doorgeometry = new THREE.BoxGeometry(100, 180, 2);
                let door = new THREE.Mesh(doorgeometry, this.DoorRenderingList);
                door.position.set(item.door__x, item.door__y, item.door__z);
                door.rotation.y = status__result[item.doorDirection] * Math.PI;
                door.nature = &quot;door&quot;;
                door.direction = item.doorDirection;
                door.isClose = 1;
                this.scene.add(door);
            }

        });
        this.scene.add(wall);
    };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如此，大功告成，我们在放一面没有门但有玻璃的墙看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1151321/201909/1151321-20190907213933360-1485240901.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;画墙这块就到这儿，这篇文章整整花费了我一下午的时间，项目是直接从&lt;em&gt;&lt;strong&gt;vue init webpack dome&lt;/strong&gt;&lt;/em&gt; 开始的，各位看客如果觉得还行，麻烦给个“推荐”，哈哈哈，全当我一下午的辛苦没白费! * _ *&lt;/p&gt;

</description>
<pubDate>Sat, 07 Sep 2019 13:45:00 +0000</pubDate>
<dc:creator>朱格利斯</dc:creator>
<og:description>Three.js画房子的墙的详解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/teersky/p/11481397.html</dc:identifier>
</item>
</channel>
</rss>