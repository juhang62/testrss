<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>十一大行为型模式之七：观察者模式。 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10508419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10508419.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/1DqPjUZNT5UuRrZwl5QjqQ&quot;&gt;行为型模式：观察者模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/71f24b4564f44f288bcc17af4ecfd6f0_0036_01.jpg&quot; alt=&quot;灯塔&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;十一大行为型模式之七：观察者模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;姓名&lt;/strong&gt; ：观察者模式&lt;br/&gt;&lt;strong&gt;英文名&lt;/strong&gt; ：Observer Pattern&lt;br/&gt;&lt;strong&gt;价值观&lt;/strong&gt; ：盯着你怎么着&lt;br/&gt;&lt;strong&gt;个人介绍&lt;/strong&gt; ：&lt;br/&gt;Define a one-to-many dependency between objects so that when one object changes state,all its dependents are notified and updated automatically.&lt;br/&gt;定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。&lt;br/&gt;（来自《设计模式之禅》）&lt;/p&gt;
&lt;h2 id=&quot;你要的故事&quot;&gt;你要的故事&lt;/h2&gt;
&lt;p&gt;想来想去，就拿我们现在生活中最常体会到的事情来讲观察者模式--朋友圈。小明、小红、小东 3 人是好朋友，最近他们的父母都给安排了手机，刚用上手机那是相当的兴奋呀。他们立马从 QQ 转投到微信的怀抱，对微信的朋友圈玩的不亦乐乎，什么事情都往上面发。突然有一天，小明和小红因为一些小事争执闹别扭了，原因就是他们对一道数学题有不同的见解。就跟我们小时候和朋友玩得好好的，突然因为一点小事就闹翻了。小红比较孩子气，立马就屏蔽了小明的朋友圈，不想再看到有关小明相关的信息。故事就是这么一回事，关注点就在这&lt;code&gt;朋友圈&lt;/code&gt;上。朋友圈就是运用观察者模式的一个很好的样例。为什么这么说？我们发朋友圈的时候，那些没有屏蔽我们朋友圈的好友，会收到信息推送。也就是没有屏蔽我们朋友圈的好友其实是订阅了我们朋友圈，好友相当于观察者，我们是被观察的对象。符合观察者模式这个关系。&lt;/p&gt;
&lt;p&gt;我们通过代码来描述小明、小红、小东他们在朋友圈玩的场景。利用观察者模式，需要观察对象和被观察对象，所以我们先定义 2 个接口，分别是 &lt;code&gt;Observable&lt;/code&gt; (可被观察接口) 和 &lt;code&gt;Observer&lt;/code&gt; (观察者接口)。&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;Observable&lt;/code&gt; 接口的对象说明是可被订阅观察的，所以它需要 &lt;code&gt;addObserver()&lt;/code&gt; 新增订阅者方法和 &lt;code&gt;removeObserver()&lt;/code&gt; 移除订阅者方法，另外还有一个是必须的，就是通知各个订阅者消息的方法 &lt;code&gt;notifyObservers()&lt;/code&gt;。那 &lt;code&gt;Observable&lt;/code&gt; 接口代码如下所示。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;interface Observable {
    void addObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers(String message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现 &lt;code&gt;Observer&lt;/code&gt; 接口的对象说明是可以去订阅观察的，也就是说可以接收被订阅的对象发出来的消息，那就需要一个接收消息的方法 &lt;code&gt;update()&lt;/code&gt;。代码如下所示。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;interface Observer {
    void update(String name, String message);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;为了让大家不混淆，先把观察者和被观察者分离开&lt;/strong&gt;，其实在这个例子中，观察者和被观察者是同一个对象 &lt;code&gt;User&lt;/code&gt; 的。这里就分开，分成 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Friend&lt;/code&gt;，后面会给出正确的代码，稍安勿躁哈。这里 &lt;code&gt;User&lt;/code&gt; 作为被观察者，实现了 &lt;code&gt;Observable&lt;/code&gt; 接口，而 &lt;code&gt;Friend&lt;/code&gt; 作为观察者，实现了 &lt;code&gt;Observer&lt;/code&gt; 接口。代码如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class User implements Observable {

    private List&amp;lt;Observer&amp;gt; friends;
    private String name;

    public User(String name) {
        this.name = name;
        this.friends = new LinkedList&amp;lt;&amp;gt;();
    }

    public void sendMessage(String message) {
        this.notifyObservers(message);
    }

    @Override
    public void addObserver(Observer observer) {
        this.friends.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        this.friends.remove(observer);
    }

    @Override
    public void notifyObservers(String message) {
        this.friends.forEach(friend -&amp;gt; {
            friend.update(this.name, message);
        });
    }
}

class Friend implements Observer {

    private String name;

    public Friend(String name) {
        this.name = name;
    }
    @Override
    public void update(String name, String message) {
        System.out.println(&quot;【&quot; + this.name + &quot;】看到【&quot; + name + &quot;】发的朋友圈：&quot; + message);
    }
}

public class ObserverTest {

    public static void main(String[] args) {
        User xiaoMing = new User(&quot;小明&quot;);
        Friend xiaoHong = new Friend(&quot;小红&quot;);
        Friend xiaoDong = new Friend(&quot;小东&quot;);
        xiaoMing.addObserver(xiaoHong);
        xiaoMing.addObserver(xiaoDong);
        xiaoMing.sendMessage(&quot;今天真开心&quot;);
        // 小红和小明闹别扭了，小红取消订阅小明的朋友圈
        xiaoMing.removeObserver(xiaoHong);
        xiaoMing.sendMessage(&quot;希望明天也像今天一样开心&quot;);
    }

}

打印结果：
【小红】看到【小明】发的朋友圈：今天真开心
【小东】看到【小明】发的朋友圈：今天真开心
【小东】看到【小明】发的朋友圈：希望明天也像今天一样开心&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到代码执行结果，小红和小东都订阅了小明的朋友圈，小明发了朋友圈：今天真开心。他们俩都收到了，因为小红和小明闹别扭，小红取消订阅小明的朋友圈，所以小明后来发的朋友圈，小红没收到。&lt;/p&gt;
&lt;p&gt;上面代码其实是不对的，不应该用 &lt;code&gt;User&lt;/code&gt; 和 &lt;code&gt;Friend&lt;/code&gt; 2 个类来定义。如果小明订阅小红和小东的朋友圈呢？这样实现比较麻烦，主要是为了分清 &lt;code&gt;观察者&lt;/code&gt; 和 &lt;code&gt;被观察者&lt;/code&gt; 这 2 个概念，通过上面的例子应该分清楚了 2 个概念了，那就可以来看正确的代码，小明、小红、小东他们其实都是观察者和被观察者，所以我们用 &lt;code&gt;User2&lt;/code&gt; 来定义他们就可以，&lt;code&gt;User2&lt;/code&gt; 实现了 &lt;code&gt;Observable&lt;/code&gt; 和 &lt;code&gt;Observer&lt;/code&gt; 接口。代码如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class User2 implements Observable, Observer {

    private List&amp;lt;Observer&amp;gt; friends;
    private String name;

    public User2(String name) {
        this.name = name;
        this.friends = new LinkedList&amp;lt;&amp;gt;();
    }

    @Override
    public void addObserver(Observer observer) {
        this.friends.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        this.friends.remove(observer);
    }

    @Override
    public void notifyObservers(String message) {
        this.friends.forEach(friend -&amp;gt; {
            friend.update(this.name, message);
        });
    }

    @Override
    public void update(String name, String message) {
        System.out.println(&quot;【&quot; + this.name + &quot;】看到【&quot; + name + &quot;】发的朋友圈：&quot; + message);
    }

    public void sendMessage(String message) {
        this.notifyObservers(message);
    }
}

public class ObserverTest {

    public static void main(String[] args) {
        User2 xiaoMing2 = new User2(&quot;小明&quot;);
        User2 xiaoHong2 = new User2(&quot;小红&quot;);
        User2 xiaoDong2 = new User2(&quot;小东&quot;);
        xiaoMing2.addObserver(xiaoHong2);
        xiaoMing2.addObserver(xiaoDong2);
        xiaoMing2.sendMessage(&quot;今天真开心&quot;);
        xiaoMing2.removeObserver(xiaoHong);
        xiaoMing2.sendMessage(&quot;希望明天也像今天一样开心&quot;);

        xiaoHong2.addObserver(xiaoMing2);
        xiaoHong2.addObserver(xiaoDong2);
        xiaoHong2.sendMessage(&quot;今天和小明吵架了，屏蔽他的朋友圈&quot;);

        xiaoDong2.addObserver(xiaoMing2);
        xiaoDong2.addObserver(xiaoHong2);
        xiaoDong2.sendMessage(&quot;小明和小红吵架了，夹在中间好尴尬&quot;);
    }

}

打印结果:
【小红】看到【小明】发的朋友圈：今天真开心
【小东】看到【小明】发的朋友圈：今天真开心
【小红】看到【小明】发的朋友圈：希望明天也像今天一样开心
【小东】看到【小明】发的朋友圈：希望明天也像今天一样开心
【小明】看到【小红】发的朋友圈：今天和小明吵架了，屏蔽他的朋友圈
【小东】看到【小红】发的朋友圈：今天和小明吵架了，屏蔽他的朋友圈
【小明】看到【小东】发的朋友圈：小明和小红吵架了，夹在中间好尴尬
【小红】看到【小东】发的朋友圈：小明和小红吵架了，夹在中间好尴尬&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中，我们看到小明、小红、小东 3 个人互相订阅朋友圈，当然中途小红屏蔽了小明的朋友圈。这就是 &lt;code&gt;观察者&lt;/code&gt; 和 &lt;code&gt;被观察者&lt;/code&gt; 刚好是同一个对象的实现。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;观察者模式&lt;/code&gt; 是一个比较特殊的设计模式，它定义了触发机制，观察者只要订阅了被观察者，就可以第一时间得到被观察者传递的信息。在工作中，使用观察者模式的场景也比较多，比如消息队列消费，Android 开发中的事件触发机制等等。好，观察者模式就到这。&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ItQUqfzzXw4387PVK0ib_g&quot;&gt;行为型模式：迭代器模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/jaejRfi4zAtnMEL8Bf0avg&quot;&gt;行为型模式：策略模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/xr_jwktNoW8nrFK5cthFkQ&quot;&gt;行为型模式：责任链模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设计模式系列文章持续更新中，欢迎关注公众号 &lt;strong&gt;LieBrother&lt;/strong&gt;，一起交流学习。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 23:41:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>十一大行为型模式之七：观察者模式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10508419.html</dc:identifier>
</item>
<item>
<title>上周热点回顾（3.4-3.10） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/10508412.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/10508412.html</guid>
<description>[unable to retrieve full-text content]恢复内容开始 热点随笔： · 博客园知名博主 Vamei 英年早逝！（纯洁的微笑）· 记一次在咸鱼上购买 MacBook Pro 的经历（JaJian）· Asp.NETCore轻松学系列阅读指引目录（Ron.Liang）· .NET开源快速开发框架Colder发布 (NET452+AdminLTE</description>
<pubDate>Sun, 10 Mar 2019 23:30:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>恢复内容开始 热点随笔： · 博客园知名博主 Vamei 英年早逝！（纯洁的微笑）· 记一次在咸鱼上购买 MacBook Pro 的经历（JaJian）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/10508412.html</dc:identifier>
</item>
<item>
<title>开源一个CSV解析器（附设计过程 ） - 韩兆新</title>
<link>http://www.cnblogs.com/hanzhaoxin/p/10508393.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hanzhaoxin/p/10508393.html</guid>
<description>&lt;p&gt;在ExcelReport支持csv的开发过程中，需要一个NETStandard的csv解析器。在nuget上找了几个试用，但都不太适合。&lt;/p&gt;
&lt;p&gt;于是，便有了：&lt;a class=&quot;package-title&quot; href=&quot;https://www.nuget.org/packages/AxinLib.IO.CSV/&quot;&gt;AxinLib.IO.CSV&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466760/201903/466760-20190310174011717-153728865.png&quot; alt=&quot;&quot; width=&quot;707&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 先看看怎么用：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466760/201903/466760-20190310174942847-155130785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;读出的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466760/201903/466760-20190310174359158-145931473.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h2&gt;回到开始：&lt;/h2&gt;
&lt;h4&gt;步骤一、了解CSV格式规范&lt;/h4&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://blog.csdn.net/woaixiaoyu520/article/details/78455650&quot; target=&quot;_blank&quot;&gt;理解CSV格式规范（解析CSV必备）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 总结：&lt;/p&gt;
&lt;p&gt;1）字段分隔符：&lt;/p&gt;

&lt;p&gt;2）行结束符：&lt;/p&gt;

&lt;p&gt;3）转义符：&lt;/p&gt;

&lt;p&gt;4）出现以上字符的字段需要用转义符前后括起来&lt;/p&gt;
&lt;p&gt;5）转义符的原义需要两个转义符标识&lt;/p&gt;
&lt;p&gt;6）文件中的最后一行记录可以有结尾回车换行符，也可以没有。&lt;/p&gt;
&lt;h4&gt;步骤二、定义状态&lt;/h4&gt;
&lt;p&gt;通过主流程识别状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466760/201903/466760-20190310181003653-1792611502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1）新字段开始 &lt;br/&gt;2）非转义状态&lt;br/&gt;3）转义状态&lt;br/&gt;4）转义符原义判定状态&lt;br/&gt;5）字段结束&lt;br/&gt;6）行结束&lt;br/&gt;7）文档结束&lt;br/&gt;8）解析失败&lt;/p&gt;
&lt;h4&gt;步骤三：通过状态迁移图查缺补漏&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/466760/201903/466760-20190310181158170-1820574276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;步骤四：根据状态迁移图实现代码&lt;/h4&gt;
&lt;p&gt; 详参见：&lt;/p&gt;
&lt;p&gt; AxinLib.IO.CSV 源码：&lt;a href=&quot;https://github.com/hanzhaoxin/AxinLib/tree/master/src/AxinLib.IO.CSV&quot;&gt;https://github.com/hanzhaoxin/AxinLib/tree/master/src/AxinLib.IO.CSV&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 22:50:00 +0000</pubDate>
<dc:creator>韩兆新</dc:creator>
<og:description>在ExcelReport支持csv的开发过程中，需要一个NETStandard的csv解析器。在nuget上找了几个试用，但都不太适合。 于是，便有了：AxinLib.IO.CSV。 先看看怎么用：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hanzhaoxin/p/10508393.html</dc:identifier>
</item>
<item>
<title>【RAY TRACING THE REST OF YOUR LIFE 超详解】 光线追踪 3-4 基于重要性采样的材质初探 - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10508352.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10508352.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Preface&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们今天来把第三本书从开局到现在讲的一大堆理论运用到我们的框架中，那么今天我们首先将原始的材质改为基于重要性采样原理的材质&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一篇是代码工程中进行MC理论应用的初步尝试篇&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要这几个重要的文件，我担心大家手上的文件可能不太对，所以再贴一下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('de199f12-7d0b-4831-a223-df0658690542')&quot; readability=&quot;77.5&quot;&gt;&lt;img id=&quot;code_img_closed_de199f12-7d0b-4831-a223-df0658690542&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_de199f12-7d0b-4831-a223-df0658690542&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('de199f12-7d0b-4831-a223-df0658690542',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_de199f12-7d0b-4831-a223-df0658690542&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;150&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; rectangle.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2019.1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the rectangle-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing the next week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;the statement of xy_rect class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; xy_rect : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; intersect
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    xy_rect() {  }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: the rectangle in the x-y plane
    @param: the boundary of x axis
            the boundary of y axis
            the value of z axis
            the material of rectangle
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    xy_rect(rtvar x1, rtvar x2, rtvar y1, rtvar y2, rtvar z0, material&lt;/span&gt;*&lt;span&gt; mat);

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; aabb getbox()&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    material &lt;/span&gt;*&lt;span&gt; _materialp;

    rtvar _x1, _x2;

    rtvar _y1, _y2;

    rtvar _other;
    };

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;the statement of xz_rect class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; xz_rect : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; intersect
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    xz_rect() {  }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: the rectangle in the x-z plane
    @param: the boundary of x axis
            the boundary of z axis
            the value of y axis
            the material of rectangle
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    xz_rect(rtvar x1, rtvar x2, rtvar z1, rtvar z2, rtvar y0, material&lt;/span&gt;*&lt;span&gt; mat);

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; aabb getbox()&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    material &lt;/span&gt;*&lt;span&gt; _materialp;

    rtvar _x1, _x2;

    rtvar _z1, _z2;

    rtvar _other;
    };

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;the statement of yz_rect class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; yz_rect : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; intersect
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    yz_rect() {  }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: the rectangle in the y-z plane
    @param: the boundary of y axis
            the boundary of z axis
            the value of x axis
            the material of rectangle
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    yz_rect(rtvar y1, rtvar y2, rtvar z1, rtvar z2, rtvar x0, material&lt;/span&gt;*&lt;span&gt; mat);

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; aabb getbox()&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    material &lt;/span&gt;*&lt;span&gt; _materialp;

    rtvar _z1, _z2;

    rtvar _y1, _y2;

    rtvar _other;
    };



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the implementation of xy_rect class&lt;/span&gt;
&lt;span&gt;
inline xy_rect::xy_rect(rtvar x1, rtvar x2, rtvar y1, rtvar y2, rtvar z0, material&lt;/span&gt;*&lt;span&gt; mat)
    :_x1(x1)
    , _x2(x2)
    , _y1(y1)
    , _y2(y2)
    , _other(z0)
    , _materialp(mat)
    {
    }

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; xy_rect::hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvar t &lt;/span&gt;= (_other - sight.origin().z()) /&lt;span&gt; sight.direction().z();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &amp;lt; t_min || t &amp;gt; t_max)&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    rtvar x &lt;/span&gt;= sight.origin().x() + t*&lt;span&gt;sight.direction().x();
    rtvar y &lt;/span&gt;= sight.origin().y() + t*&lt;span&gt;sight.direction().y();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;lt; _x1 || x &amp;gt; _x2 || y &amp;lt; _y1 || y &amp;gt;&lt;span&gt; _y2)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    info._u &lt;/span&gt;= (x - _x1) / (_x2 -&lt;span&gt; _x1);
    info._v &lt;/span&gt;= (y - _y1) / (_y2 -&lt;span&gt; _y1);
    info._t &lt;/span&gt;=&lt;span&gt; t;
    info._materialp &lt;/span&gt;=&lt;span&gt; _materialp;
    info._p &lt;/span&gt;=&lt;span&gt; sight.go(t);
    info._n &lt;/span&gt;= rtvec(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

aabb xy_rect::getbox()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; aabb(rtvec(_x1, _y1, _other - &lt;span&gt;0.0001&lt;/span&gt;), rtvec(_x2, _y2, _other + &lt;span&gt;0.0001&lt;/span&gt;&lt;span&gt;));
    }


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the implementation of xz_rect class&lt;/span&gt;
&lt;span&gt;
inline xz_rect::xz_rect(rtvar x1, rtvar x2, rtvar z1, rtvar z2, rtvar y0, material&lt;/span&gt;*&lt;span&gt; mat)
    :_x1(x1)
    , _x2(x2)
    , _z1(z1)
    , _z2(z2)
    , _other(y0)
    , _materialp(mat)
    {
    }

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; xz_rect::hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvar t &lt;/span&gt;= (_other - sight.origin().y()) /&lt;span&gt; sight.direction().y();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &amp;lt; t_min || t &amp;gt; t_max)&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    rtvar x &lt;/span&gt;= sight.origin().x() + t*&lt;span&gt;sight.direction().x();
    rtvar z &lt;/span&gt;= sight.origin().z() + t*&lt;span&gt;sight.direction().z();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;lt; _x1 || x &amp;gt; _x2 || z &amp;lt; _z1 || z &amp;gt;&lt;span&gt; _z2)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    info._u &lt;/span&gt;= (x - _x1) / (_x2 -&lt;span&gt; _x1);
    info._v &lt;/span&gt;= (z - _z1) / (_z2 -&lt;span&gt; _z1);
    info._t &lt;/span&gt;=&lt;span&gt; t;
    info._materialp &lt;/span&gt;=&lt;span&gt; _materialp;
    info._p &lt;/span&gt;=&lt;span&gt; sight.go(t);
    info._n &lt;/span&gt;= rtvec(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

aabb xz_rect::getbox()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; aabb(rtvec(_x1, _other - &lt;span&gt;0.0001&lt;/span&gt;, _z1), rtvec(_x2, _other + &lt;span&gt;0.0001&lt;/span&gt;&lt;span&gt;, _z2));
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the implementation of yz_rect class&lt;/span&gt;
&lt;span&gt;
inline yz_rect::yz_rect(rtvar y1, rtvar y2, rtvar z1, rtvar z2, rtvar x0, material&lt;/span&gt;*&lt;span&gt; mat)
    :_y1(y1)
    , _y2(y2)
    , _z1(z1)
    , _z2(z2)
    , _other(x0)
    , _materialp(mat)
    {
    }

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; yz_rect::hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvar t &lt;/span&gt;= (_other - sight.origin().x()) /&lt;span&gt; sight.direction().x();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &amp;lt; t_min || t &amp;gt; t_max)&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    rtvar y &lt;/span&gt;= sight.origin().y() + t*&lt;span&gt;sight.direction().y();
    rtvar z &lt;/span&gt;= sight.origin().z() + t*&lt;span&gt;sight.direction().z();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (y &amp;lt; _y1 || y &amp;gt; _y2 || z &amp;lt; _z1 || z &amp;gt;&lt;span&gt; _z2)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    info._u &lt;/span&gt;= (y - _y1) / (_y2 -&lt;span&gt; _y1);
    info._v &lt;/span&gt;= (z - _z1) / (_z2 -&lt;span&gt; _z1);
    info._t &lt;/span&gt;=&lt;span&gt; t;
    info._materialp &lt;/span&gt;=&lt;span&gt; _materialp;
    info._p &lt;/span&gt;=&lt;span&gt; sight.go(t);
    info._n &lt;/span&gt;= rtvec(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

aabb yz_rect::getbox()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; aabb(rtvec(_other - &lt;span&gt;0.0001&lt;/span&gt;, _y1, _z1), rtvec(_other + &lt;span&gt;0.0001&lt;/span&gt;&lt;span&gt;, _y2, _z2));
    }

}&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;rectangle.hpp&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('52f2304e-4dc4-4931-8e97-19e533628f84')&quot; readability=&quot;73.5&quot;&gt;&lt;img id=&quot;code_img_closed_52f2304e-4dc4-4931-8e97-19e533628f84&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_52f2304e-4dc4-4931-8e97-19e533628f84&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('52f2304e-4dc4-4931-8e97-19e533628f84',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_52f2304e-4dc4-4931-8e97-19e533628f84&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;142&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; box.hpp&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt; &lt;span&gt;https://www.cnblogs.com/lv-anchoret/p/10307569.html&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2019.1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the box-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing the next week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the statement of box class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; box: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; intersect
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    box() {  }

    box(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; pointmin, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; pointmax, material *&lt;span&gt; mat);

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; aabb getbox()&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
public:
    // the normal of xy_rect, the normal's direction is +
    inline const rtvec&amp;amp; xy_n()        const    { return _list[0].Getnormal(); }

    // the normal of xy_rect, the normal's direction is -
    inline const rtvec&amp;amp; xy_nflip()    const    { return _list[1].Getnormal(); }
    
    inline const rtvec&amp;amp; xz_n()        const    { return _list[2].Getnormal(); }

    inline const rtvec&amp;amp; xz_nflip()    const    { return _list[3].Getnormal(); }
        
    inline const rtvec&amp;amp; yz_n()        const    { return _list[4].Getnormal(); }

    inline const rtvec&amp;amp; yz_nflip() const    { return _list[5].Getnormal(); }


    inline void set_xy_material(material* m) { _list[0].setmaterial(m); }

    inline void set_xy_flipmaterial(material* m) { _list[1].setmaterial(m); }

    inline void set_xz_material(material* m) { _list[2].setmaterial(m); }

    inline void set_xz_flipmaterial(material* m) { _list[3].setmaterial(m); }

    inline void set_yz_material(material* m) { _list[4].setmaterial(m); }

    inline void set_yz_flipmaterial(material* m) { _list[5].setmaterial(m); }
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    rtvec _min;
    
    rtvec _max;
    intersections&lt;/span&gt;*&lt;span&gt; _list;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rectangles* _list;&lt;/span&gt;
&lt;span&gt;    };



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the implementation of box class&lt;/span&gt;
&lt;span&gt;
inline     box::box(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; pointmin, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; pointmax, material *&lt;span&gt; mat)
    :_min(pointmin)
    ,_max(pointmax)
    {
        intersect &lt;/span&gt;** list = &lt;span&gt;new&lt;/span&gt; intersect*[&lt;span&gt;6&lt;/span&gt;&lt;span&gt;];
        list[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; xy_rect(_min.x(), _max.x(), _min.y(), _max.y(), _max.z(), mat);
        list[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; xy_rect(_min.x(), _max.x(), _min.y(), _max.y(), _min.z(), mat));
        list[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; xz_rect(_min.x(), _max.x(), _min.z(), _max.z(), _max.y(), mat);
        list[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; xz_rect(_min.x(), _max.x(), _min.z(), _max.z(), _min.y(), mat));
        list[&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; yz_rect(_min.y(), _max.y(), _min.z(), _max.z(), _max.x(), mat);
        list[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; yz_rect(_min.y(), _max.y(), _min.z(), _max.z(), _min.x(), mat));
        _list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; intersections(list, &lt;span&gt;6&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    rectangle ** list = new rectangle*[6];
    list[0] = new xy_rect(_min.x(), _max.x(), _min.y(), _max.y(), _max.z(), mat);
    list[1] = new xy_rect(_min.x(), _max.x(), _min.y(), _max.y(), _min.z(), mat, true);
    list[2] = new xz_rect(_min.x(), _max.x(), _min.z(), _max.z(), _max.y(), mat);
    list[3] = new xz_rect(_min.x(), _max.x(), _min.z(), _max.z(), _min.y(), mat, true);
    list[4] = new yz_rect(_min.y(), _max.y(), _min.z(), _max.z(), _max.x(), mat);
    list[5] = new yz_rect(_min.y(), _max.y(), _min.z(), _max.z(), _min.x(), mat, true);
    _list = new rectangles(list, 6);&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; box::hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _list-&amp;gt;&lt;span&gt;hit(sight, t_min, t_max, info);
    }

aabb box::getbox()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; aabb(_min, _max);
    }

} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;box.hpp&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为了统一测试效果，所以把main文件代码也贴在下面了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;136&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; LOWPRECISION
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define uvwtest
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define listtest
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define accumulatetest
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define attenuationtest
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#define colortest&lt;/span&gt;
&lt;span&gt;#define&lt;/span&gt; STB_IMAGE_IMPLEMENTATION&lt;span&gt;

#include &lt;/span&gt;&amp;lt;fstream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;stb\stb_image.h&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;include\texture\RTtexture.hpp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;include\material\RTmaterial.hpp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;include\hit\RThit.hpp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;camera.hpp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt;


rtvec lerp(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, intersect* world, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; depth)
{
    hitInfo info;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (world-&amp;gt;hit(sight, (rtvar)&lt;span&gt;0.001&lt;/span&gt;&lt;span&gt;, rtInf(), info))
    {
        ray scattered;
        rtvec attenuation;
        rtvec light &lt;/span&gt;= info._materialp-&amp;gt;&lt;span&gt;emitted(info._u, info._v, info._p);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (depth &amp;lt; &lt;span&gt;50&lt;/span&gt; &amp;amp;&amp;amp; info._materialp-&amp;gt;&lt;span&gt;scatter(sight, info, attenuation, scattered))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; light + attenuation * lerp(scattered, world, depth + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; light;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtvec();
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Cornell(intersections** scene, camera**&lt;span&gt; cam, rtvar aspect)
{
    intersect &lt;/span&gt;** list = &lt;span&gt;new&lt;/span&gt; intersect*[&lt;span&gt;9&lt;/span&gt;&lt;span&gt;];
    size_t cnt &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    material &lt;/span&gt;* red = &lt;span&gt;new&lt;/span&gt; lambertian(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;0.65&lt;/span&gt;, &lt;span&gt;0.05&lt;/span&gt;, &lt;span&gt;0.05&lt;/span&gt;&lt;span&gt;)));
    material &lt;/span&gt;* blue = &lt;span&gt;new&lt;/span&gt; lambertian(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;0.05&lt;/span&gt;, &lt;span&gt;0.05&lt;/span&gt;, &lt;span&gt;0.73&lt;/span&gt;&lt;span&gt;)));
    material &lt;/span&gt;* white = &lt;span&gt;new&lt;/span&gt; lambertian(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;0.88&lt;/span&gt;, &lt;span&gt;0.88&lt;/span&gt;, &lt;span&gt;0.88&lt;/span&gt;&lt;span&gt;)));
    material &lt;/span&gt;* green = &lt;span&gt;new&lt;/span&gt; lambertian(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;0.12&lt;/span&gt;, &lt;span&gt;0.45&lt;/span&gt;, &lt;span&gt;0.15&lt;/span&gt;&lt;span&gt;)));
    material &lt;/span&gt;* light = &lt;span&gt;new&lt;/span&gt; areaLight(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;)));

    list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt; yz_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;&lt;span&gt;, green));
    list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; yz_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, red);
    list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; xz_rect(&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;350&lt;/span&gt;, &lt;span&gt;220&lt;/span&gt;, &lt;span&gt;340&lt;/span&gt;, &lt;span&gt;550&lt;/span&gt;&lt;span&gt;, light);
    list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt; xz_rect(&lt;span&gt;200&lt;/span&gt;, &lt;span&gt;350&lt;/span&gt;, &lt;span&gt;220&lt;/span&gt;, &lt;span&gt;340&lt;/span&gt;, &lt;span&gt;550&lt;/span&gt;&lt;span&gt;, light));
    list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt; xz_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;&lt;span&gt;, white));
    list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; xz_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, white);
    list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt; xy_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;&lt;span&gt;, blue));

    list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; translate(&lt;span&gt;new&lt;/span&gt; rotate_x(&lt;span&gt;new&lt;/span&gt; rotate_y(&lt;span&gt;new&lt;/span&gt; box(rtvec(), rtvec(&lt;span&gt;165&lt;/span&gt;, &lt;span&gt;165&lt;/span&gt;, &lt;span&gt;165&lt;/span&gt;), white), -&lt;span&gt;45&lt;/span&gt;), -&lt;span&gt;30&lt;/span&gt;), rtvec(&lt;span&gt;130&lt;/span&gt;, &lt;span&gt;200&lt;/span&gt;, &lt;span&gt;65&lt;/span&gt;&lt;span&gt;));
    list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; translate(&lt;span&gt;new&lt;/span&gt; rotate_z(&lt;span&gt;new&lt;/span&gt; rotate_y(&lt;span&gt;new&lt;/span&gt; box(rtvec(), rtvec(&lt;span&gt;165&lt;/span&gt;, &lt;span&gt;330&lt;/span&gt;, &lt;span&gt;165&lt;/span&gt;), white), &lt;span&gt;30&lt;/span&gt;), &lt;span&gt;20&lt;/span&gt;), rtvec(&lt;span&gt;265&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;295&lt;/span&gt;&lt;span&gt;));

    &lt;/span&gt;*scene =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; intersections(list, cnt);

    rtvec lookfrom(&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;, &lt;span&gt;278&lt;/span&gt;, -&lt;span&gt;800&lt;/span&gt;&lt;span&gt;);
    rtvec lookat(&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;, &lt;span&gt;278&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    rtvar dist_to_focus &lt;/span&gt;= &lt;span&gt;10.0&lt;/span&gt;&lt;span&gt;;
    rtvar aperture &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    rtvar vfov &lt;/span&gt;= &lt;span&gt;40.0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;*cam = &lt;span&gt;new&lt;/span&gt; camera(lookfrom, lookat, rtvec(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;),
        vfov, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, aperture, dist_to_focus, &lt;span&gt;0&lt;/span&gt;., &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; build_1_1()
{
    stds ofstream file(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;graph-1-1.ppm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    size_t W &lt;/span&gt;= &lt;span&gt;200&lt;/span&gt;, H = &lt;span&gt;200&lt;/span&gt;, sample = &lt;span&gt;200&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (file.is_open())
    {
        file &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;P3\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; W &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; H &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n255\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;

        intersections &lt;/span&gt;*&lt;span&gt; world;
        camera &lt;/span&gt;*&lt;span&gt; cma;

        Cornell(&lt;/span&gt;&amp;amp;world, &amp;amp;cma, (rtvar)W /&lt;span&gt; H);

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y = H - &lt;span&gt;1&lt;/span&gt;; y &amp;gt;= &lt;span&gt;0&lt;/span&gt;; --&lt;span&gt;y)
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; W; ++&lt;span&gt;x)
            {
                rtvec color;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; cnt = &lt;span&gt;0&lt;/span&gt;; cnt &amp;lt; sample; ++&lt;span&gt;cnt)
                {
                    lvgm::vec2&lt;/span&gt;&amp;lt;rtvar&amp;gt;&lt;span&gt; para{
                        (lvgm::rand01() &lt;/span&gt;+ x) /&lt;span&gt; W,
                        (lvgm::rand01() &lt;/span&gt;+ y) /&lt;span&gt; H };
                    color &lt;/span&gt;+= lerp(cma-&amp;gt;get_ray(para), world, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
                }
                color &lt;/span&gt;/=&lt;span&gt; sample;

#ifdef colortest
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (color.x() &amp;lt; &lt;span&gt;0&lt;/span&gt;)stds cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color.x &amp;lt; 0 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (color.y() &amp;lt; &lt;span&gt;0&lt;/span&gt;)stds cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color.y &amp;lt; 0 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (color.z() &amp;lt; &lt;span&gt;0&lt;/span&gt;)stds cout &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;color.z &amp;lt; 0 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;span&gt;

                color &lt;/span&gt;= rtvec(sqrt(color.r()), sqrt(color.g()), sqrt(color.b()));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;gamma 校正&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; r = &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;255.99&lt;/span&gt; *&lt;span&gt; color.r());
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; g = &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;255.99&lt;/span&gt; *&lt;span&gt; color.g());
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;255.99&lt;/span&gt; *&lt;span&gt; color.b());
                file &lt;/span&gt;&amp;lt;&amp;lt; r &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; g &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; b &amp;lt;&amp;lt;&lt;span&gt; stds endl;
            }
        file.close();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (world)&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; world;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cma)&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; cma;

        stds cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;complished&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        stds cerr &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;open file error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    build_1_1();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;Chapter4 Important Sampling Materials&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的目标就是向光源发送额外的光线使得我们的图片噪声更少&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们假定我们发送的一束朝向光源的光线的pdf为&lt;em&gt;&lt;strong&gt;pLight(direction)&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们假定一个和s有关的pdf函数，我们叫它为&lt;em&gt;&lt;strong&gt;pSurface(direction)&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以把两者进行线性组合，得到一个综合的pdf，最简单的形式如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;p(direction)&lt;/strong&gt;&lt;/em&gt; = 0.5*&lt;em&gt;&lt;strong&gt;pLight(direction)&lt;/strong&gt;&lt;/em&gt; + 0.5*&lt;em&gt;&lt;strong&gt;pSurface(direction)&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实，只要我们的权重是正的，并且加起来等于1,也就是我们经常提到的——pdf积分一定要能积到1，任意pdf函数组合形成的pdf只要满足这两点都是合理的，所以我们可以将几个分量因素的pdf组合控制，使我们的pdf函数更加贴近真实效果。虽然我们可以使用任何的pdf，但是它一定不能改变我们收敛的答案，这是最重要的一点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，这就是一个关于寻找pdf的小游戏，要弄清楚如何使&lt;em&gt;&lt;strong&gt;s（direction）*color（direction）&lt;/strong&gt;&lt;/em&gt;大的pdf更大，也就是找到合适的pdf，创造更真实的颜色比例效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于漫反射（diffuse or Lambertian）表面，我们猜测它更偏重color（direction）因子。 对于镜面（metal）材质表面来说，s（）因子只在一个方向附近很大，所以它更重要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;事实上，大多数渲染器将镜面设计成一种特殊情况，只是隐含地使用s / p 进行计算，所以，我们的代码目前也是这样。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们今天先来测试一下漫反射表面，我们用之前的Cornell盒子做测试，为了方便，我们把相机的设置也放在里面，因为很多时候放在外面，经常换场景，无法记录每个场景采用的合适的摄像机参数，所以就把它和场景放在一起了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;already中的main函数中有Cornell函数，这里就不贴了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们先用之前的方法跑一个200*200的图，sample为200，光线渲染路径计算递归上限50次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可能效果不是很好，但是噪声多一点，方便看效果&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;用时如图&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190310012837266-554883191.png&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;318&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;效果如图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190311014252524-174264002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的目的是减少噪声，我们将构造一个pdf，使得更多的光线反射到光源&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;趁着等待渲染的时间，再叨叨两句我们的核心思想，我们的渲染路径是这样计算的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;首先我们从eye（或者 camera）发射采样光线，它指向投影屏幕的一个像素位置，也就是当前采样光线正在计算的那个像素位置。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;然后光线以射线的形式计算eye与投影屏幕之间所有的几何体交点，得到与eye最近的那个，然后我们以那个交点为落脚点，作为新的eye，按照光学表面散射原理计算新的射线的方向（结合具体的材质），然后继续测交。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;如果在递归深度上限范围内没有找到光源，那么说明该像素位置不会有光传入眼睛，也就是当前像素位置是黑色的；如果它找到光源了，也就是经过多次散射最后指向了光源，那么就说明光源发出的光线可以沿着我们的路径逆向进入眼睛，那么我们就看到了这个像素，那么如何计算像素值呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这就涉及到了路径渲染方程，里面有一个rgb分量衰减比例控制参数，它依据材质和纹理计算得出，这是之前的，我们现在要加上pdf函数，帮助我们更逼真地计算像素值&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，唠完了，上图片&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190311020917306-1954424341.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;貌似没区别，但是我们下面还会继续优化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;刚刚那个图跑了53min，接下来你就会知道为什么时间还多了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们要把重要性采样嵌入进去，首先MC模拟f(x)的积分形式为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;em&gt;&lt;strong&gt;f(r)/p(r)&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于Lambertian材质，我们用上一篇的pdf函数：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　&lt;em&gt;&lt;strong&gt;p(direction)&lt;/strong&gt;&lt;/em&gt; = cosθ/π&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们修改material基类如下：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; material.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2018.12
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the material-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing in one week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the statement of material class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; material
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: produce a scattered ray
    @param: InRay -&amp;gt; Incident light
            info -&amp;gt; the information of intersect-point(hit-point)
            attenuation -&amp;gt; when scattered, how much the ray should be attenuated by tis reflectance R
            scattered -&amp;gt; as we talk, it is a new sight; or
                         it is the scattered ray with the intersect-point
            pdf -&amp;gt; the Important Sample's pdf function
    @retur: the function calculate a scattered ray or not
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; scatter(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; InRay, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, rtvec&amp;amp; attenuation, ray&amp;amp; scattered, rtvar&amp;amp; pdf)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: produce a scattered ray
    @param: 
    InRay -&amp;gt; Incident light
    info -&amp;gt; the information of intersect-point(hit-point)
    scattered -&amp;gt; as we talk, it is a new sight; or
                it is the scattered ray with the intersect-point
    @retur: the function calculate a scattered ray or not
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvar scatter_pdf(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; InRay, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, &lt;span&gt;const&lt;/span&gt; ray&amp;amp; scattered)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; scatter(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; rIn, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, rtvec&amp;amp; attenuation, ray&amp;amp; scattered)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: 自发光
    @param: 纹理所需信息
    @retur: 纹理像素值
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec emitted(rtvar u, rtvar v, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; p)&lt;span&gt;const&lt;/span&gt;&lt;span&gt; 
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtvec(); 
        }

    };

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; diffuse.hpp&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt; &lt;span&gt;https://www.cnblogs.com/lv-anchoret/p/10198423.html&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2018.12
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        one of the materials
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; texture;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the statement of lambertian class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; lambertian : &lt;span&gt;public&lt;/span&gt;&lt;span&gt; material
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    lambertian(texture&lt;/span&gt;*&lt;span&gt; _tex);

    rtvar scatter_pdf(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; ray&amp;amp; rIn, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, &lt;span&gt;const&lt;/span&gt; ray&amp;amp; scattered)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; scatter(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; rIn, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, rtvec&amp;amp; attenuation, ray&amp;amp; scattered, rtvar&amp;amp; pdf)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; texture* get_texture()&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _albedo; }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; set_texture(texture* tex) { _albedo =&lt;span&gt; tex; }

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt;:

    texture&lt;/span&gt;*&lt;span&gt; _albedo;
    };



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the implementation of lambertian class&lt;/span&gt;
&lt;span&gt;
inline lambertian::lambertian(texture&lt;/span&gt;*&lt;span&gt; _tex)
    :_albedo(_tex) 
    {
    }

rtvar lambertian::scatter_pdf(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; ray&amp;amp; rIn, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, &lt;span&gt;const&lt;/span&gt; ray&amp;amp; scattered)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvar cosine &lt;/span&gt;=&lt;span&gt; dot(info._n, scattered.direction().ret_unitization()); 
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cosine &amp;lt; &lt;span&gt;0&lt;/span&gt;)cosine = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; cosine /&lt;span&gt; π;
    }

&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; lambertian::scatter(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; rIn, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, rtvec&amp;amp; attenuation, ray&amp;amp; scattered, rtvar&amp;amp; pdf)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvec target &lt;/span&gt;= info._p + info._n +&lt;span&gt; lvgm::random_unit_sphere();
    scattered &lt;/span&gt;= ray{ info._p, (target -&lt;span&gt; info._p).ret_unitization(), rIn.time() };
    attenuation &lt;/span&gt;= _albedo-&amp;gt;&lt;span&gt;value(info._u, info._v, info._p);
    pdf &lt;/span&gt;= dot(info._n, scattered.direction()) /&lt;span&gt; π;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;以及主函数中的lerp函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
rtvec lerp(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, intersect* world, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; depth)
{
    hitInfo info;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (world-&amp;gt;hit(sight, (rtvar)&lt;span&gt;0.001&lt;/span&gt;&lt;span&gt;, rtInf(), info))
    {
        ray scattered;
        rtvec emitted &lt;/span&gt;= info._materialp-&amp;gt;&lt;span&gt;emitted(info._u, info._v, info._p);
        rtvar pdf;
        rtvec albedo;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (depth &amp;lt; &lt;span&gt;50&lt;/span&gt; &amp;amp;&amp;amp; info._materialp-&amp;gt;&lt;span&gt;scatter(sight, info, albedo, scattered, pdf))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; emitted + albedo *info._materialp-&amp;gt;scatter_pdf(sight, info, scattered)*lerp(scattered, world, depth + &lt;span&gt;1&lt;/span&gt;) /&lt;span&gt; pdf;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; emitted;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtvec();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; 所以，它运行时间多了3min，新代码的运算只增无减&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;解释一些东西：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;scatter_pdf函数里面的cosine值是散射光线和表面法线的夹角，所以大于90°无效，表示采样失败，上一篇说过&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;scatter函数还是原来的差不多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上述是基于上一本书的第一次修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面来进行第二次修改&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们尝试一下不同的采样策略，比如，我们选择从表面的上半球部分随机采样（可以把物体放入球坐标系中，我们只取上半球部分），那么我们的&lt;em&gt;&lt;strong&gt;p（direction）&lt;/strong&gt;&lt;/em&gt; = 1/（2π）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为球体的球面度是4πsr，所以半球就是2πsr，采取表面均匀采样的话，就是一立体角对应的球面度量1sr，所以就是1/（2π）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; lambertian::scatter(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; rIn, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, rtvec&amp;amp; attenuation, ray&amp;amp; scattered, rtvar&amp;amp; pdf)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    rtvec direction;
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{
        direction &lt;/span&gt;=&lt;span&gt; lvgm::random_unit_sphere();
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (dot(direction, info._n) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    scattered &lt;/span&gt;=&lt;span&gt; ray{ info._p,direction.ret_unitization(),rIn.time() };
    attenuation &lt;/span&gt;= _albedo-&amp;gt;&lt;span&gt;value(info._u, info._v, info._p);
    pdf &lt;/span&gt;= &lt;span&gt;0.5&lt;/span&gt; /&lt;span&gt; π;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;按理说应该得到同上述两张图片相同的图片，但是可能事与愿违&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190311032330368-1024642825.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;书作者采用的是咱们2-7教程里面的如下图左上角那张，而我们今天采用的是右下角那张，因为它让问题看的更清楚&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190311031122974-1468848130.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面是书中的结尾&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190311032045586-987047724.png&quot; alt=&quot;&quot; width=&quot;845&quot; height=&quot;288&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其实你看一下这张图顶部的白光（这一变化更容易让我们捕捉到），就可以验证作者所提出的问题&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;本来是周六就写了这篇的草稿的，但是因为抄错代码了，出不来效果，白天调了好久。。。可能不适合抄东西。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 19:30:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>Important Sampling Materials</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10508352.html</dc:identifier>
</item>
<item>
<title>Perl进程：僵尸进程和孤儿进程 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10508297.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10508297.html</guid>
<description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;僵尸进程&lt;/strong&gt;：当子进程退出时，父进程还没有(使用wait或waitpid)接收其退出状态时，子进程就成了僵尸进程&lt;br/&gt;&lt;strong&gt;孤儿进程&lt;/strong&gt;：当子进程还在运行时，父进程先退出了，子进程就会成为孤儿进程被pid=1的init/systemd进程收养&lt;/p&gt;
&lt;p&gt;需要说明的是，僵尸进程的父进程死掉后，僵尸进程也会被pid=1的init/systemd进程收养，而init/systemd进程会定期清理其下僵尸进程，并在它的任意子进程退出时检查它的领土下是否有僵尸进程存在，从而保证init/systemd下不会有太多僵尸进程。&lt;/p&gt;
&lt;h2 id=&quot;僵尸进程模拟&quot;&gt;僵尸进程模拟&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
#
use strict;
use warnings;

defined(my $pid = fork) or die &quot;fork failed: $!&quot;;

unless($pid){
    # child process
    print &quot;I am child process\n&quot;;
    exit;
}

# parent process
print &quot;I am parent process\n&quot;;
sleep(2);
system(&quot;ps -o pid,ppid,state,tty,command&quot;);
print &quot;parent process exiting\n&quot;;
exit;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I am parent process
I am child process
   PID   PPID S TT       COMMAND
 22342  22340 S pts/0    -bash
 22647  22342 S pts/0    perl zombie2.pl
 22648  22647 Z pts/0    [perl] &amp;lt;defunct&amp;gt;
 22649  22647 R pts/0    ps -o pid,ppid,state,tty,command
parent process exiting&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;孤儿进程模拟&quot;&gt;孤儿进程模拟&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
use strict;
use warnings;

defined(my $pid = fork) or die &quot;fork failed: $!&quot;;
unless($pid){
    # 子进程
    print &quot;second child, ppid=&quot;,getppid(),&quot;\n&quot;;
    sleep(5);
    print &quot;second child, ppid=&quot;,getppid(),&quot;\n&quot;;
    exit 0;
}

# 父进程
sleep 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;second child, ppid=22683
# 5秒之后输出
second child, ppid=1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解决僵尸进程的方式&quot;&gt;解决僵尸进程的方式&lt;/h2&gt;
&lt;p&gt;僵尸进程是因为没有使用wait/waitpid接收子进程的退出状态，只要使用wait/waitpid接收该子进程的退出状态，父进程就会为子进程收尸善后。&lt;/p&gt;
&lt;p&gt;另外，当子进程退出时，内核会立即发送SIGCHLD信号给父进程告知其该子进程退出了。&lt;/p&gt;
&lt;p&gt;有几种方式可以应对僵尸进程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;直接在父进程中使用wait/waitpid等待所有子进程退出(不能留下任一个子进程)&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;父进程中定义SIGCHLD信号的处理程序，并在该信号处理程序中调用wait/waitpid为每个退出的子进程收尸&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连续fork两次&lt;/strong&gt;，在第二次fork中执行主代码，第一次fork的子进程立即退出并在父进程中被收尸。这使得第一个退出的子进程不会成为僵尸进程，也使得第二个子进程立即成为孤儿进程被pid=1的init/systemd收养，从而保证其不会成为僵尸进程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三种方式中，前两种用的比较多，第三种比较技巧化，但是也有其用处。&lt;/p&gt;
&lt;h3 id=&quot;等待所有子进程退出&quot;&gt;等待所有子进程退出&lt;/h3&gt;
&lt;p&gt;父进程中等待所有子进程退出的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;until(wait == -1){}
until(waitpid -1, 0 == -1){}
until(waitpid -1, WNOHANG == -1){}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
use strict;
use warnings;
use POSIX qw(WNOHANG);

# fork 5个子进程
for (1..5) {
    defined(my $pid = fork) or die &quot;fork error: $!&quot;;
    unless($pid){
        # 子进程
        print &quot;I am child: $_\n&quot;;
        sleep 1;
        exit 0;
    }
}

# 每秒非阻塞wait一次
until(waitpid(-1, WNOHANG) == -1){
    print &quot;any children still exists\n&quot;;
    sleep 1;
}

print &quot;all child exits\n&quot;;
system(&quot;ps -o pid,ppid,state,tty,command&quot;);
exit 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I am child: 1
I am child: 2
I am child: 3
any children still exists
I am child: 5
I am child: 4
any children still exists
any children still exists
any children still exists
any children still exists
any children still exists
any children still exists
all child exits
   PID   PPID S TT       COMMAND
 22342  22340 S pts/0    -bash
 24547  22342 S pts/0    perl waitallchild.pl
 24553  24547 R pts/0    ps -o pid,ppid,state,tty,command&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里输出了多个&quot;any children...&quot;，是因为waitpid对于每个等待到的pid都返回一次，此外如果检查的时候没有任何退出的子进程，也会每秒返回一次。&lt;/p&gt;
&lt;p&gt;最终的结果中显示没有僵尸进程的存在。&lt;/p&gt;
&lt;h3 id=&quot;sigchld处理程序收掉僵尸进程&quot;&gt;SIGCHLD处理程序收掉僵尸进程&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/perl
use strict;
use warnings;
use POSIX qw(WNOHANG);

sub reap_child;

# 注册SIGCHLD信号的处理程序
$SIG{CHLD}=\&amp;amp;reap_child;

# fork 5个子进程
for (1..5){
    defined(my $pid = fork) or die &quot;fork failed: $!&quot;;
    unless($pid){
        # 子进程
        print &quot;I am child: $_\n&quot;;
        sleep 1;
        exit 0;
    } else {
        print &quot;child $_: pid=$pid\n&quot;;
    }
}

# 父进程
sleep 20;
system(&quot;ps -o pid,ppid,state,tty,command&quot;);

sub reap_child {
    print &quot;SIGCHLD triggered at:&quot;,~~localtime, &quot;\n&quot;;
    # 只要有子进程退出，就收尸
    while((my $kid = waitpid -1, WNOHANG) &amp;gt; 0){
        print &quot;$kid reaped\n&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;child 1: pid=24857
I am child: 1
child 2: pid=24858
I am child: 2
child 3: pid=24859
I am child: 3
child 4: pid=24860
I am child: 4
child 5: pid=24861
I am child: 5
SIGCHLD triggered at:Mon Feb 25 13:49:43 2019
24857 reaped
24859 reaped
24860 reaped
   PID   PPID S TT       COMMAND
 22342  22340 S pts/0    -bash
 24856  22342 S pts/0    perl reap_zombie.pl
 24858  24856 Z pts/0    [perl] &amp;lt;defunct&amp;gt;
 24861  24856 Z pts/0    [perl] &amp;lt;defunct&amp;gt;
 24862  24856 R pts/0    ps -o pid,ppid,state,tty,command
SIGCHLD triggered at:Mon Feb 25 13:49:43 2019
24858 reaped
24861 reaped&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现只需1-2秒程序就终止了，但父进程明明就sleep 20了，为什么？还有结果好像很奇怪？不仅有两个僵尸进程还只触发了两次SIGCHLD信号处理程序。&lt;/p&gt;
&lt;p&gt;上面触发了两次SIGCHLD信号处理程序，因为第二次触发的是system()打开的子进程ps命令退出时触发的。&lt;/p&gt;
&lt;p&gt;之所以1-2秒就结束，是因为子进程结束时，内核发送SIGCHLD信号给父进程，会中断父进程的sleep睡眠。&lt;/p&gt;
&lt;p&gt;只触发两次信号处理程序就能收走5个子进程，其中第一次触发收走了3个子进程，第二次触发收走了2个子进程，是因为waitpid会返回所有等待到的子进程pid，第一次等待到了3个子进程的退出，第二次等待到了2个子进程的退出。&lt;/p&gt;
&lt;p&gt;那么为什么system()中的ps退出时没有被SIGCHLD信号处理程序中的waitpid收走？这是因为system()函数自身就带有了wait阻塞函数，它自己会收走经过它fork出来的子进程，使得虽然ps的退出触发了SIGCHLD，但ps的退出状态值已经清空了，无法被信号处理程序中的waitpid处理。&lt;/p&gt;
&lt;h3 id=&quot;fork两次收掉僵尸进程&quot;&gt;fork两次收掉僵尸进程&lt;/h3&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env perl
use strict;
use warnings;

defined(my $pid = fork) or die &quot;fork failed: $!&quot;;
unless($pid){
    # 第一个子进程
    # 继续fork一个孙子进程：第二个子进程
    defined(my $kid = fork) or die &quot;fork failed: $!&quot;;
    if($kid){
        # 第一个子进程5秒后退出
        sleep 5;
        exit 0;
    }

    # 孙子进程
    sleep(10);
    print &quot;second child, ppid=&quot;,getppid(),&quot;\n&quot;;
    exit 0;
}

# 为第一个子进程收尸
(waitpid $pid, 0 == $pid) or die &quot;waitpid error: $!&quot;;

exit 0;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码中，在5秒后第一个子进程退出并被父进程收尸，第二个进程将成为孤儿进程被pid=1的进程收养。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 17:32:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>概念 僵尸进程 ：当子进程退出时，父进程还没有(使用wait或waitpid)接收其退出状态时，子进程就成了僵尸进程 孤儿进程 ：当子进程还在运行时，父进程先退出了，子进程就会成为孤儿进程被pid=1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10508297.html</dc:identifier>
</item>
<item>
<title>Django的rest_framework的分页组件源码分析 - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/10508191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/10508191.html</guid>
<description>&lt;p&gt;前言：&lt;/p&gt;
&lt;p&gt;　　分页大家应该都很清楚，今天我来给大家做一下Django的rest_framework的分页组件的分析；我的讲解的思路是这样的，分别使用APIview的视图类和基于ModelViewSet的视图类两种方式实现分页的功能，同时我也会介绍两个分页的类，&lt;span&gt;&lt;strong&gt;PageNumberPagination&lt;/strong&gt;&lt;/span&gt;类和&lt;span&gt;&lt;strong&gt;LimitOffsetPagination，&lt;/strong&gt;&lt;span&gt;希望能对大家有所帮助！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　今天的博客主要的这样的，先讲解基于APIView类的两种分页类的实现方式，然后在讲解基于ModelViewSet类的两种分页类的实现方式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;正文：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;一、基于APIView的视图类，使用PageNumberPagination&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、先导入我们要用到的分页的类&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from rest_framework.pagination import PageNumberPagination
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、下面我们来看下这个这个类的类是属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class PageNumberPagination(BasePagination):
    &quot;&quot;&quot;
    A simple page number based style that supports page numbers as
    query parameters. For example:

    http://api.example.org/accounts/?page=4
    http://api.example.org/accounts/?page=4&amp;amp;page_size=100
    &quot;&quot;&quot;
    # The default page size.
    # Defaults to `None`, meaning pagination is disabled.
    page_size = api_settings.PAGE_SIZE

    django_paginator_class = DjangoPaginator

    # Client can control the page using this query parameter.
    page_query_param = 'page'
    page_query_description = _('A page number within the paginated result set.')

    # Client can control the page size using this query parameter.
    # Default is 'None'. Set to eg 'page_size' to enable usage.
    page_size_query_param = None
    page_size_query_description = _('Number of results to return per page.')

    # Set to an integer to limit the maximum page size the client may request.
    # Only relevant if 'page_size_query_param' has also been set.
    max_page_size = None

    last_page_strings = ('last',)

    template = 'rest_framework/pagination/numbers.html'

    invalid_page_message = _('Invalid page.')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里我们重点介绍一下类的属性，重点的参数如下，等下我们会测试的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310232131865-1387968621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3、然后看下类的paginate_queryset方法，这个方法主要就是用来显示数据的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def paginate_queryset(self, queryset, request, view=None):
        &quot;&quot;&quot;
        Paginate a queryset if required, either returning a
        page object, or `None` if pagination is not configured for this view.
        &quot;&quot;&quot;
        page_size = self.get_page_size(request)
        if not page_size:
            return None

        paginator = self.django_paginator_class(queryset, page_size)
        page_number = request.query_params.get(self.page_query_param, 1)
        if page_number in self.last_page_strings:
            page_number = paginator.num_pages

        try:
            self.page = paginator.page(page_number)
        except InvalidPage as exc:
            msg = self.invalid_page_message.format(
                page_number=page_number, message=six.text_type(exc)
            )
            raise NotFound(msg)

        if paginator.num_pages &amp;gt; 1 and self.template is not None:
            # The browsable API should display pagination controls.
            self.display_page_controls = True

        self.request = request
        return list(self.page)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、PageNumberPagination用到知识点，我们已经讲解完了，下面我们介绍下如何使用，首先我们先继承一下PageNumberPagination，然后自定义我们的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class MyPageNumberPagination(PageNumberPagination):
    page_size = 1
    page_query_param = &quot;mypage&quot;
    page_size_query_param = &quot;size&quot;
    max_page_size = 4
    last_page_strings = ('mylast',)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5、然后在视图类中使用我们自己写的分页类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Book_cbv(APIView):
    authentication_classes = []
    # permission_classes = [SVIPpermission(),]
    # throttle_classes = [throttlerate(),]
    # parser_classes = []
    def get(self,request):

        query_list = models.Book.objects.all()
        mypageobj = MyPageNumberPagination()
        obj = mypageobj.paginate_queryset(queryset=query_list,request=request,view=None)
        bs = bookmodelserializer(obj,many=True,context={'request': request})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重点看下这里，关注一下paginate_queryset这个方法的参数，和源码中的参数对应一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310232519258-198656772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 源码中的参数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310232621097-1819300601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 6、下面我们测试一下&lt;/p&gt;
&lt;p&gt;每页显示一条数据，显示第一页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310232855460-1605668245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/bainianminguo/p/10463893.html&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;每页显示1条数据，显示第二页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310232931744-755087813.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;类中设定每页显示1条数据，我们临时修改为显示2条数据，显示第一页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310233048003-1604974174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 类中设定每页显示1条数据，我们临时修改为显示5条数据，显示第一页,理论上5是不生效的，实际只显示了4条数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310233129138-2136652350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;经过测试，我们上面的四个参数都已经生效 &lt;/p&gt;
&lt;p&gt;最后在补充一点，上面的每页显示多少条的设置针对单个表生效，如何基于所有的表生效。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class PageNumberPagination(BasePagination):
    &quot;&quot;&quot;
    A simple page number based style that supports page numbers as
    query parameters. For example:

    http://api.example.org/accounts/?page=4
    http://api.example.org/accounts/?page=4&amp;amp;page_size=100
    &quot;&quot;&quot;
    # The default page size.
    # Defaults to `None`, meaning pagination is disabled.
    page_size = api_settings.PAGE_SIZE
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后看下api_setttings水里对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
api_settings = APISettings(None, DEFAULTS, IMPORT_STRINGS)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看下APISettigns这个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def __init__(self, user_settings=None, defaults=None, import_strings=None):
        if user_settings:
            self._user_settings = self.__check_user_settings(user_settings)
        self.defaults = defaults or DEFAULTS
        self.import_strings = import_strings or IMPORT_STRINGS
        self._cached_attrs = set()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到了这里，我们大致就知道了，我们需要进入我们的project的settings文件中进行设置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
REST_FRAMEWORK = {
#     &quot;DEFAULT_AUTHENTICATION_CLASSES&quot;:(
#         &quot;app1.utils.Book_auther&quot;,
#     ),
#     &quot;DEFAULT_PERMISSION_CLASSES_CLASSES&quot;: (
#         &quot;app1.utils.SVIPpermission&quot;,
#     ),
#     &quot;DEFAULT_DEFAULT_THROTTLE_CLASSES_CLASSES&quot;: (
#         &quot;app1.utils.throttlerate&quot;,
#     )
    &quot;PAGE_SIZE&quot; : 2,
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;二、基于APIView的视图类，使用LimitOffsetPagination类&lt;/h3&gt;
&lt;p&gt;1、导入LimitOffsetPagination类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from rest_framework.pagination import LimitOffsetPagination
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、我们同样看下这个类的属性&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class LimitOffsetPagination(BasePagination):
    &quot;&quot;&quot;
    A limit/offset based style. For example:

    http://api.example.org/accounts/?limit=100
    http://api.example.org/accounts/?offset=400&amp;amp;limit=100
    &quot;&quot;&quot;
    default_limit = api_settings.PAGE_SIZE
    limit_query_param = 'limit'
    limit_query_description = _('Number of results to return per page.')
    offset_query_param = 'offset'
    offset_query_description = _('The initial index from which to return the results.')
    max_limit = None
    template = 'rest_framework/pagination/numbers.html'
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重点看下下面几个属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310233451132-1811947966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、然后看下LimitOffsetPagination类的paginate_queryset的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def paginate_queryset(self, queryset, request, view=None):
        self.count = self.get_count(queryset)
        self.limit = self.get_limit(request)
        if self.limit is None:
            return None

        self.offset = self.get_offset(request)
        self.request = request
        if self.count &amp;gt; self.limit and self.template is not None:
            self.display_page_controls = True

        if self.count == 0 or self.offset &amp;gt; self.count:
            return []
        return list(queryset[self.offset:self.offset + self.limit])
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、然后我们看下如何在我们的视图类中使用这个分页插件，其实和前面的插件的用法是一样的，只是参数不一样而已&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Book_cbv(APIView):
    authentication_classes = []
    # permission_classes = [SVIPpermission(),]
    # throttle_classes = [throttlerate(),]
    # parser_classes = []
    def get(self,request):

        query_list = models.Book.objects.all()
        # mypageobj = MyPageNumberPagination()        
        # obj = mypageobj.paginate_queryset(queryset=query_list,request=request,view=None)
        mypageobj = MyLimitOffsetPagination()
        obj = mypageobj.paginate_queryset(queryset=query_list,request=request,view=None)
        bs = bookmodelserializer(obj,many=True,context={'request': request})


        return Response(bs.data)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重点是这里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310233902506-323765283.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 5、最后我们测试一下&lt;/p&gt;
&lt;p&gt;默认不传参数，每页显示2条&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310233948557-1123692785.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;临时修改每页显示为1个，偏移量为1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310234111767-194228013.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 临时修改每页显示1条，偏移量为2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310234147073-1687932140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;三、基于ModelViewSet的视图类，实现分页功能&lt;/h3&gt;
&lt;p&gt;通过上面的讲解，我们知道两个分页的类就是参数不一样，使用的逻辑都一样，我们这里就不分开讲解2个类，只讲一下如何ModelViewSet类实现分页&lt;/p&gt;
&lt;p&gt;1、先看下基于ModelViewSet的视图类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from rest_framework import viewsets

class AutherModelCBV(viewsets.ModelViewSet):
    queryset = models.Auther.objects.all()
    serializer_class = authermodelserializer
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、因为这个ModelViewSet这个类重写了list方法，分页肯定在list方法中，所以我们先要找到list方法，ModelViewSet这个类一共有4个父类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310234704289-1420719630.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 3、我们看下mixins.ListModelMixin这个类，因为list方法是在这个类中实现的，进入这个类，看下list方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class ListModelMixin(object):
    &quot;&quot;&quot;
    List a queryset.
    &quot;&quot;&quot;
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、重点看下paginate_queryset这个方法，首先要先找到这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310234846475-2099902384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 5、如果找这个方法呢，我们从最开始找这个方法&lt;/p&gt;
&lt;p&gt;首先AutherModelCBV这个类没有这个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from rest_framework import viewsets

class AutherModelCBV(viewsets.ModelViewSet):
    queryset = models.Auther.objects.all()
    serializer_class = authermodelserializer
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后去ModelViewSet类中找这个方法，同样没有&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class ModelViewSet(mixins.CreateModelMixin,
                   mixins.RetrieveModelMixin,
                   mixins.UpdateModelMixin,
                   mixins.DestroyModelMixin,
                   mixins.ListModelMixin,
                   GenericViewSet):
    &quot;&quot;&quot;
    A viewset that provides default `create()`, `retrieve()`, `update()`,
    `partial_update()`, `destroy()` and `list()` actions.
    &quot;&quot;&quot;
    pass
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ModelViewSet这个类继承了有5个类，我们从左到右一个一个看，最终在GenericViewSet，我们看到这个类还继承了2个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class GenericViewSet(ViewSetMixin, generics.GenericAPIView):
    &quot;&quot;&quot;
    The GenericViewSet class does not provide any actions by default,
    but does include the base set of generic view behavior, such as
    the `get_object` and `get_queryset` methods.
    &quot;&quot;&quot;
    pass
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;再次从左到右依次查找paginate_queryset这个方法，最终下面这个类中找到这个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class GenericAPIView(views.APIView):
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;方法的源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def paginate_queryset(self, queryset):
        &quot;&quot;&quot;
        Return a single page of results, or `None` if pagination is disabled.
        &quot;&quot;&quot;
        if self.paginator is None:
            return None
        return self.paginator.paginate_queryset(queryset, self.request, view=self)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;那么这个paginator是什么呢，原来他是静态方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    @property
    def paginator(self):
        &quot;&quot;&quot;
        The paginator instance associated with the view, or `None`.
        &quot;&quot;&quot;
        if not hasattr(self, '_paginator'):
            if self.pagination_class is None:
                self._paginator = None
            else:
                self._paginator = self.pagination_class()
        return self._paginator
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到这里，我们就非常清楚的了，我们需要在我们自己的视图类中定义一个这样的属性，然后把我们的分页类赋值给pagination_class这个属性就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190310235813726-661119277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 6、然后看下在ModelViewSet类中如何操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from rest_framework import viewsets

class AutherModelCBV(viewsets.ModelViewSet):
    queryset = models.Auther.objects.all()
    serializer_class = authermodelserializer
    pagination_class = MyPageNumberPagination
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;重点看下这里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190311000034037-344680341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 最后我们测试一下&lt;/p&gt;
&lt;p&gt;下面这个是我们禁用分页的显示效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190311000200431-1670182705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 下面开始启用分页的效果,显示第一页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190311000247903-1167691211.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 显示第二页的效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190311000307939-2076236749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;总结：至此，Django的Rest_framework的分页组件就介绍完了，大家有不清楚的，可以留言，我们共同进步。 &lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 16:09:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<og:description>前言： 分页大家应该都很清楚，今天我来给大家做一下Django的rest_framework的分页组件的分析；我的讲解的思路是这样的，分别使用APIview的视图类和基于ModelViewSet的视图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bainianminguo/p/10508191.html</dc:identifier>
</item>
<item>
<title>Laravel 和 Spring Boot 两个框架比较创业篇（二：人工成本） - 曾俊杰的专栏</title>
<link>http://www.cnblogs.com/ymstars/p/10508175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ymstars/p/10508175.html</guid>
<description>&lt;p&gt;前面从开发效率比较了 Laravel 和 Spring Boot两个框架，见：&lt;a href=&quot;https://www.cnblogs.com/ymstars/p/10480934.html&quot;&gt;Laravel 和 Spring Boot 两个框架比较创业篇（一：开发效率）&lt;/a&gt; ，这一篇打算比较一下人工成本。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本文说的人工成本是狭义的技术支出成本。当然人工成本不单纯是开发人员的人工成本，同时包含了团队协作管理、架构设计、运维等方面的人工（团队）成本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文从以下几个维度分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序员&lt;/li&gt;
&lt;li&gt;技术管理&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;程序员&quot;&gt;程序员&lt;/h2&gt;
&lt;p&gt;相信这个是大家比较关注的维度，很好理解，就是要根据需求撸一套产品出来，无论是后端、前端、APP还是小程序、中台，都要士兵冲锋前阵，也就是靠程序员实现出来，所以这个是刚需。&lt;/p&gt;
&lt;p&gt;相信很多猿都会认为自己是全栈工程师，后端OK、前端也OK、APP也能撸，微信小程序也没问题，这样的人还是不少的，但是大部分是停留在框架或者类库的使用上，称为 “github工程师”，必然会有自己比较精的一个端。&lt;/p&gt;
&lt;p&gt;例如前端的Single Page Application，一般现代的猿对JavaScript语言都会了解，如果对Vue技术熟悉，配合Vue Route、Element UI、Vuex 就能撸出一个像模像样的SPA，如果对 React 语法和单向数据流思维熟悉，Dvajs + Ant Design也能撸出一个绚丽的中台系统。&lt;/p&gt;
&lt;p&gt;对于Android开发，熟悉 Java 语法，了解 Android 四大组件，不需要对Android Framework 内核、NDK 有深入的理解，只要有大牛工具库的加持，例如Retrofit、EventBus、GreenDao、，也能撸出一个看起来还不错原生Android APP。何况还有Flutter！&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;现代框架的高度封装特性使生产力获得提高，同时容易让开发人员对底层原理失去探索需求，这种失去不但体现在开发人员本身，同样也体现在软件企业在人才筛选上为了降低成本而对技术要求做出让步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大厂考底层原理和算法、初创看项目经验，这似乎成为了一种行业规律。&lt;/p&gt;
&lt;p&gt;不扯远了，回到找猿的话题。&lt;/p&gt;
&lt;h3 id=&quot;spring-boot-猿&quot;&gt;Spring Boot 猿&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Java 猿多，优秀的 Java 猿难找，有项目思路快速出项目的Java程序猿太难找&lt;/li&gt;
&lt;li&gt;J2EE 猿多，优秀的 J2EE 猿太难找，熟悉 J2EE 体系、精通 Spring 全家桶的猿更是难找&lt;/li&gt;
&lt;li&gt;精通 J2EE 而且能适应 Spring Boot 开发思维的猿可遇不可求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;J2EE 非常庞大复杂，知识点数量不亚于一本字典，Spring Boot 配置方式从传统的xml定义向Java类注入转变，现在很多J2EE 猿仍然是起手一个裹脚布似的xml配置文件，一看洋洋洒洒上千行，看起来牛逼，其实只是刚把项目运行起来而已，九九八十一关才过了一关。也正是因为传统J2EE的这个特点，Java 给人一种开发速度慢、成本高的印象。&lt;/p&gt;
&lt;p&gt;Java Web 体系就像饮食业&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;J2EE饭店内，只见顾客光着膀子走进饭店，和工作人员说道：我要红色的衬衣，扣子要六角形的，鞋子要皮鞋黑色的，吃饭的筷子要长度16cm，木头做的，吃饭的椅子要四只脚的，垫子厚度1cm，6号桌子...，一个小时后一切定制完毕，可以吃饭了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Spring Boot饭店内人不多，迎宾在声嘶力竭的呼喊：“南来得北往的老少爷们，快来看看瞧瞧啦”，一个顾客走过来，迎宾马上把他迎进大厅领到空桌坐下，服务员拿出菜单，问道：“您要吃点什么呢？”。顾客露出惊讶的表情：“我还没有定制我的衣服、筷子、椅子呢？”。服务员道：“我们都准备好了，每个顾客都一样，16cm的筷子，四只脚的椅子，1cm垫子，不需要定制呢，您可以直接点菜用餐”。顾客停了一会说道：“垫子我要1.5cm的，其他的就这样吧”，服务员：“好嘞”。顾客点了一个驴肉火烧，15分钟后吃饱了满足的离开了店里，喃喃说着：“以后再也不去J2EE饭店了，还是这里方便。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此我们要找的不是Java猿，也不是J2EE猿，而是Spring Boot猿。&lt;/p&gt;
&lt;p&gt;价格方面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;6k可以招到Java猿，但是不能指望他能独当一面，独立负责你的项目开发，而且要花费精力和资源去培训&lt;/li&gt;
&lt;li&gt;10K能招到一个会 Spring Boot的猿，J2EE熟不熟悉就不知道了，你猜&lt;/li&gt;
&lt;li&gt;15k能招到一个靠谱的J2EE猿&lt;/li&gt;
&lt;li&gt;20K运气好的话能够招到一个懂 J2EE 而且能用Spring Boot框架独立开发后端的靠谱猿&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;貌似成本不低。&lt;/p&gt;
&lt;h3 id=&quot;laravel&quot;&gt;Laravel&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;PHP猿很多，等等，先让我们过滤一下，啥？会Discuz、DeDeCms、帝国Cms？用原生PHP开发一个项目会吗？不会？那算了&lt;/li&gt;
&lt;li&gt;遵守规范、代码漂亮的PHP猿少，PSR是啥？我也不知道？呃...&lt;/li&gt;
&lt;li&gt;自制力强的猿少，咦，这个功能加个全局function就搞定了，就这么干。这么简单的业务逻辑也就100多行，我逻辑思维能力超强，直接写在controller方法里吧，看我开发速度多快。团队成员：呃...&lt;/li&gt;
&lt;li&gt;PHP猿怼道：我会ThinkPHP，你说 Laravel 搞得和Java一样复杂，你干嘛不去找Java猿，国内 Laravel 人才还真不多&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;价格方面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3k可以招到“CMS PHP猿”&lt;/li&gt;
&lt;li&gt;6k可以招到PHP猿，同样不能指望他能独当一面，独立负责你的项目开发，而且要花费精力和资源去培训&lt;/li&gt;
&lt;li&gt;15K也是能够招到一个靠谱Laravel 猿，当然这里面的运气成分很大，嗯，天时地利人和，缺一不可。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;技术管理&quot;&gt;技术管理&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;啥？技术管理是啥？CTO吗？小项目还折腾啥CTO？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实不然，当开始一个项目的时候，产出的软件不可能只是一个端，至少需要后端和前端，或者APP端、小程序端。&lt;/p&gt;
&lt;p&gt;技术管理的作用是协调各个端的交互和接口规范，还有项目开发里程碑和任务安排 &lt;strong&gt;（注意不包含架构，在初创快速实现的强烈需求下，架构先不考虑）&lt;/strong&gt;。我们不可能让专职后端来制定APP端的里程碑，同样也不能够让专职APP客户端来定后端的里程碑。必然会有一个技术比较全面的枢纽人物，我认为这是项目快速推进的基础，同样也可以负责测试和code review。尽管这和产品经理有点类似，对于产品规划较全面的初创来说，是可以合二为一的。出于成本考虑，我们需要低成本招到这样的人来统揽项目技术全局。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;后端在产品体系中属于重合度最高的端，需要和每个端产生交互，最低成本的方式是将技术管理这部分成本附加到后端，说人话：“找一个符合前面所述开发要求的全栈后端来承担技术管理工作”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人总结（按照通用水平，大神级别的不在讨论范围内）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于专职后端：Laravel 人工成本要略低于 Spring Boot&lt;/li&gt;
&lt;li&gt;对于技术管理：脚本系（PHP、Python、JavaScript）的猿往往更容易向全栈发展，J2EE 这种企业级巨无霸框架，分工概念很强，比起脚本系语言全栈工程师就显得更少。而且既能胜任J2EE+Spring Boot 开发，又是全栈的猿，初创还是不要考虑了，太贵。&lt;/li&gt;
&lt;li&gt;从PHP猿中找到符合初创技术管理要求的，概率要比从Java猿里面找高一些，参考对象多，议价能力自然也高些。&lt;/li&gt;
&lt;li&gt;在不考虑系统架构优劣的前提下，人工成本方面 Laravel 比 Spring Boot 更有优势&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后再多嘴说一句初创的软件系统架构问题：我接触过很多初创，而且还把软件系统架构看的很重，这是一个严重的误区。正如网友们说的，Laravel 存在性能问题，为了做大之后流量大了服务不挂掉，嚷嚷着要上微服务。&lt;/p&gt;
&lt;p&gt;产品上线了没？产品都还没上线，要啥高并发，要啥高性能，要啥微服务。&lt;/p&gt;
&lt;p&gt;初创项目一般流量不大，也不是计算密集型服务，性能瓶颈不会是在PHP框架本身，没有必要纠结是 &lt;code&gt;C/C++&lt;/code&gt;和&lt;code&gt;JVM&lt;/code&gt;谁执行速度快，&lt;code&gt;PHP&lt;/code&gt;比&lt;code&gt;C&lt;/code&gt;慢了多少个数量级，这些毫无意义。当你有了这个性能需求的时候，如果公司还没那个资金去高薪找人才，那商业模式真的是没谁了！&lt;/p&gt;
&lt;p&gt;还有微服务，一个街边小摊嚷嚷着要按照阿里巴巴的运营模式来搞，其实这样没啥问题，自己选的路，冷暖自知吧。微服务天生就是分布式，分布式本身就是一个非常大的系统，不是初创适合玩的。就像跨国运营战略适合阿里这种体量的公司，因为业务复杂度已经到达了某种程度，经过评估是对公司短、中、长期发展都是有利的。街边小摊套用这种模式，只会被复杂度困住手脚，当然当您的小吃迈出国门，走向世界，手底下几千人，战略模式自然就有了。当软件复杂度和项目业务量到达一定程度，有了服务拆分和分布式需求，微服务自然就有了，初创要做的可能是关注扩展性，并不是微服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/11/169685b77de3d1b1?w=1021&amp;amp;h=540&amp;amp;f=png&amp;amp;s=67162&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;小流量前提下谈高并发和架构就是耍流氓！您要的可能不是架构，而是扩展性！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 10 Mar 2019 16:04:00 +0000</pubDate>
<dc:creator>曾俊杰的专栏</dc:creator>
<og:description>前面从开发效率比较了 Laravel 和 Spring Boot两个框架，见： 'Laravel 和 Spring Boot 两个框架比较创业篇（一：开发效率）' ，这一篇打算比较一下人工成本。 本文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ymstars/p/10508175.html</dc:identifier>
</item>
<item>
<title>工程实践：如何规范地打印程序日志？ - Matrix海子</title>
<link>http://www.cnblogs.com/dolphin0520/p/10396894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dolphin0520/p/10396894.html</guid>
<description>&lt;h3&gt;工程实践：如何规范地打印程序日志？&lt;/h3&gt;
&lt;p&gt;    很久之前，有个朋友问我，如果一个老项目让你接手去进行后续维护，你会先从哪里入手、让自己更快地上手项目？当时我没有特别正面去回答这个朋友的问题，我说：一个老项目是否容易上手，一个非常关键的地方就是这个项目的日志是否打得足够好。因为通常来说，一个老项目相对比较稳定了，后续大概率不会有比较大的变更和改动，那么对于这样的项目，核心就是“维稳”。但是任何人都无法保证项目在线上运行时不会出线上故障，在出现线上问题或者故障时，如何快速止损就是第一要义，而日志在止损过程中就扮演着非常重要的角色。日志打的足够明了清晰，可以帮助开发和运维人员快速定位问题，继而决定采取何种方案进行止损。&lt;/p&gt;
&lt;p&gt;    今天就让我们一起来聊一聊如何把项目程序日志打“好”。以下是本文大纲目录：&lt;/p&gt;
&lt;p&gt;    一.为何需要规范地打印程序日志？&lt;/p&gt;
&lt;p&gt;    二.如何规范地打印程序日志？ &lt;/p&gt;
&lt;p&gt;    若有不正之处请多多谅解，并欢迎批评指正。&lt;/p&gt;
&lt;p&gt;    请尊重作者劳动成果，转载请标明原文链接：&lt;/p&gt;
&lt;p&gt;    http://www.dolphin0520.com/archives/2018/11/26/176.html&lt;/p&gt;

&lt;h2&gt;一.为何需要规范地打印程序日志？&lt;/h2&gt;
&lt;p&gt;    我们平时在写程序代码过程中，一般会把主要精力集中在功能实现上，往往会忽视日志的重要性，然而日志在系统上线后是极其重要的，因为系统上线后，只有通过日志才能了解当前系统的运行状态，在出现线上故障时，日志是否足够清晰明了决定了是否能够快速找到止损方案。我们可以看一下下面这段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class HttpClient {
    private static final Logger LOG = LoggerFactory.getLogger(HttpClient.class);

    private static int CONNECT_TIMEOUT = 5000;   // unit ms
    private static int READ_TIMEOUT = 10000;     // unit ms
    
    public static String sendPost(String url, String param) {
        OutputStream out = null;
        BufferedReader in = null;
        String result = &quot;&quot;;
        try {
            URL realUrl = new URL(url);
            URLConnection conn = realUrl.openConnection();
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setConnectTimeout(CONNECT_TIMEOUT);
            conn.setReadTimeout(READ_TIMEOUT);
            conn.setRequestProperty(&quot;charset&quot;, &quot;UTF-8&quot;);
            out = new PrintWriter(conn.getOutputStream());
            out.print(parm);
            out.flush();
            in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line;
            while ((line = in.readLine()) != null) {
                result += line;
            }
        } catch (Exception ex) {
            LOG.error(&quot;post request error!!!&quot;);
        } finally {
            try {
                if (out != null) {
                    out.close();
                }
                if (in != null) {
                    in.close();
                }
            } catch (IOException ex) {
                LOG.error(&quot;close stream error!!!&quot;);
            }
            return result;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    某一天线上突然大量http请求失败，然后查看日志，发现了大量的“post request error!!!”错误，此时假如看到这样的日志你可能完全不知道究竟是什么原因导致的，还得继续通过一些其他的手段来定位具体原因。&lt;/p&gt;
&lt;p&gt;    假如打印的错误日志是这样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
post request error!!!, url:[http://www.123.test.com], param:[name=jack]
java.net.ConnectException: Connection refused
        at java.net.PlainSocketImpl.socketConnect(Native Method)
        at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:339)
        at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:200)
        at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:182)
        at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)
        at java.net.Socket.connect(Socket.java:579)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    那么便能很快地断定是下游http服务问题导致的，且下游http服务域名为www.123.test.com(Connection refused通常是由于下游服务端口未启动引起的)，可以迅速找相应的人员进行止损，避免在故障定位阶段耗费大量的时间。&lt;/p&gt;
&lt;p&gt;        上面举的例子只是一个非常小的例子，实际日常开发中可能碰到的线上问题比这个更加复杂和棘手，总结来看，日志的主要作用有以下几点：&lt;/p&gt;
&lt;p&gt;    1）日志是系统运行的“照妖镜”，通过它能够实时反映系统的运行状态；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/288799/201903/288799-20190304215151492-1943547461.png&quot; alt=&quot;&quot; width=&quot;702&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    如上图所示，系统A中producer不断产生数据放入到data queue中，sender不断从data queue中取数据发送给下游系统B的receiver，那么对于系统A来说，data queue中的待发送数据量便是一个非常关键的指标，它能够从侧面真实反应当前系统的运行状况，如果data queue中的element个数超过容量的90%了，那么标志着此时系统可能运行不正常了，会有队列堵塞的风险；如果data queue中的element个数不到容量的10%，那么标志着此时系统运行比较正常，出现队列堵塞的风险较低。&lt;/p&gt;
&lt;p&gt;    如果这个指标没有输出到日志中，开发和运维人员是无法确切知道当前系统A的运行状态的(当然也有其他的方式来获取这个指标，比如通过http接口暴露出来也是一种方式之一)。&lt;/p&gt;
&lt;p&gt;    2）良好的日志便于后期运维和开发人员迅速定位线上问题，加快止损速度，减少系统故障带来的损失；&lt;/p&gt;
&lt;p&gt;    3）日志还有另外一个作用便是能够无缝与监控系统结合，通过监控系统进行日志采集，拿到系统运行的相关性能指标，有利于分析系统的性能瓶颈、提前规避风险；&lt;/p&gt;
&lt;p&gt;    举例说明：&lt;/p&gt;
&lt;p&gt;    假如有一个商城系统，在初期，数据库通过2台服务器提供服务(1台master，1台slave)，此时大部分接口能在秒级内响应用户请求。随着时间的推移，商城系统的用户量逐渐增多，并发查询和写入量都出现了一定的增长，数据库中的数据量也慢慢增多，导致部分sql语句查询越来越慢，突然有一天，数据库的slave机器由于过多的慢查询导致被拖垮，彻底宕机了，导致商城服务不可用。&lt;/p&gt;
&lt;p&gt;    如果商城系统在日志中记录了每个http请求的耗时情况，通过监控系统配置日志采集，同时配置相应的报警，那么便能提前发现由于业务增长带来的系统性能瓶颈，提前进行系统优化(如机器扩容、sql语句优化、分库分表等)，规避风险。&lt;/p&gt;
&lt;p&gt;    4）便于统计与业务相关的指标数据，进行相关业务分析和功能优化。&lt;/p&gt;
&lt;p&gt;    举例说明：&lt;/p&gt;
&lt;p&gt;    比如一个搜索系统，想统计过去一周不同地域(如南北地域)的搜索使用占比，如果日志中本身打印了每个搜索query请求的ip，则很容易统计，否则需要重新上线加日志才能统计。&lt;/p&gt;
&lt;p&gt;    因此，大家在日常编写代码过程中要注重日志书写的规范性，让它发挥出它应有的价值，在辅助保障我们服务稳定运行的同时，能够有效提升后期系统维护效率。&lt;/p&gt;
&lt;h2&gt;二.如何规范地打印程序日志？&lt;/h2&gt;
&lt;p&gt;    接下来，我们从以下几个方面来谈谈如何规范地打印日志。&lt;/p&gt;
&lt;h3&gt;2.1 日志文件命名&lt;/h3&gt;
&lt;p&gt;    通常来说日志文件的命名可包括以下几个关键信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
类型标识(logTypeName)
日志级别(logLevel)
日志生成时间(logCreateTime)
日志备份编号(logBackupNum)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;    类型标识&lt;/strong&gt;：指此日志文件的功能或者用途，比如一个web服务，记录http请求的日志通常命名为request.log或者access.log，request、access就是类型标识，而java的gc日志通常命名为gc.log，这样看一目了然；而通常用来记录服务的整体运行的日志一般用服务名称(serviceName、appKey)或者机器名(hostName)来命名，如 nginx.log；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;日志级别&lt;/strong&gt;：打印日志的时候直接通过文件来区分级别是一种比较推荐的方式，如果把所有级别的日志打到同一个日志文件中，在定位问题时，还需要去文件中进行查找操作，相对繁琐。日志级别一般包括DEBUG、INFO、WARN、ERROR、FATAL这五个级别，在实际编写代码中，可以采取严格匹配模式或者非严格匹配模式，严格匹配模式即INFO日志文件中只打印INFO日志，ERROR日志文件只打印ERROR日志；非严格匹配模式即INFO日志文件可以打印INFO日志、WARN日志、ERROR日志、FATAL日志，WARN日志文件可以打印WARN日志、ERROR日志、FATAL日志，以此类推。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;日志生成时间&lt;/strong&gt;：即在日志文件名称中附带上日志文件创建的时间，方便在查找日志文件时进行排序；&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;日志备份编号&lt;/strong&gt;：当进行日志切割时，如果是以文件大小进行滚动，此时可以在日志文件名称末尾加上编号；&lt;/p&gt;
&lt;h3&gt;2.2 日志滚动&lt;/h3&gt;
&lt;p&gt;　　虽然日志中能够保存系统运行时的关键信息，但是由于磁盘空间有限，所以我们不能无限制地保留日志，因此必须有日志滚动策略。日志滚动通常有以下几种模式：&lt;/p&gt;
&lt;p&gt;　　第一种：按照时间滚动&lt;/p&gt;
&lt;p&gt;　　第二种：按照单个日志文件大小滚动&lt;/p&gt;
&lt;p&gt;　　第三种：同时按照时间和单个日志文件大小滚动。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按照时间滚动，即每隔一定的时间建立一个新的日志文件，通常可以按照小时级别滚动或者天级别滚动，具体采取哪种方式取决于系统日志的打印量。如果系统日志比较少，可以采取天级别滚动；而如果系统日常量比较大，则建议采取小时级别滚动。&lt;/li&gt;
&lt;li&gt;按照单个日志文件大小滚动，即每当日志文件达到一定大小则建立一个新的日志文件，通常建议单个日志文件大小不要超过500M，日志文件过大的话，对于日志监控或者问题定位排查都可能会造成一定影响。&lt;/li&gt;
&lt;li&gt;按照时间和单个日志文件大小滚动，这种模式通常适用于希望保留一定时间的日志，但是又不希望单个日志文件过大的场景。比如logback就提供了这种配置模式，可参考：&lt;a title=&quot;logback日志滚动方式&quot; href=&quot;https://logback.qos.ch/manual/appenders.html#SizeAndTimeBasedFNATP&quot; target=&quot;_blank&quot;&gt;https://logback.qos.ch/manual/appenders.html#SizeAndTimeBasedFNATP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　对于日志滚动策略来说，有2个比较关键的参数：&lt;span&gt;最大保留日志数量和最大磁盘占用空间&lt;/span&gt;。这2个参数切记一定要设置，如果没有设置，则很有可能会出现把线上机器磁盘打满的情况。&lt;/p&gt;
&lt;h3&gt;2.3 日志级别&lt;/h3&gt;
&lt;p&gt;　　日志的级别通常有以下几种：&lt;/p&gt;
&lt;p&gt;　　debug/trace、info、warning、error、fatal&lt;/p&gt;
&lt;p&gt;　　这几种日志级别的严重程序依次递增：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;debug/trace&lt;/strong&gt;：debug和trace级别的日志由于打印内容较多，所以通常情况下不适用于线上生产环境使用，一般使用于前期线下环境调试。即使线上环境要使用，也需要通过开关来控制，只在定位追踪线上问题时才开启；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;info&lt;/strong&gt;：info日志一般用来记录系统运行的关键状态、关键业务逻辑或者关键执行节点。但切记一点，info日志绝不可滥用，如果info日志滥用，则和debug/trace日志没有太大区别了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;warning：&lt;/strong&gt;warning日志一般用来记录系统运行时的一些非预期情况，顾名思义，是作为一种警示，提醒开发和运维人员需要关注，但是不用人为介入立刻去处理的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;error&lt;/strong&gt;：error日志一般用来记录系统运行时的一些普通错误，这些错误一旦出现，则表示已经影响了用户的正常访问或者使用，通常意味着需要人为介入处理。但很多时候在生产环境中，也不一定是出现error日志就需要人工立即介入处理的，通常会结合error日志的数量以及持续时间来进行综合判断。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;fatal&lt;/strong&gt;：属于系统致命错误，一般出现意味着系统基本等于挂掉了，需要人工立即介入处理。&lt;/p&gt;
&lt;p&gt;　　下面举个简单的例子来说明，假如我们有这样一个场景，我们有一个工资计算系统，每隔月1号需要从员工考勤系统获取公司所有员工的考勤数据，然后根据考勤数据来计算上月应发工资，那么需要有一个函数从考勤系统获取员工考勤数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;66&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public Map&amp;lt;Long, Double&amp;gt; getEmployeeWorkDaysFromAttendance(int year, int month, Set&amp;lt;Long&amp;gt; employeeList) throws BusiessException {
        // 入口关键日志，需要打印关键的参数，因为employeeList可能数量较大，所以次数没有直接打印employeeList列表内容，只打印了size
        logger.info(&quot;get employee work days, year:{}, month:{}, employeeList.size:{}&quot;, year, month, employeeList.size());

        // 如果需要临时检验员工列表，可以把debug日志开关打开
        if (debugOpen()) {
            logger.debug(&quot;employ list content:{}&quot;, JSON.toJsonString(employeeList));
        }
        
        int retry = 1;
        while (retry &amp;lt;= MAX_RETRY_TIMES) {
            try {
                Map&amp;lt;Long, Double&amp;gt; employeeWorkDays = employeeAttendanceRPC.getEmployeeWorkDays(year, month, employeeList);
                logger.info(&quot;get employee work days success, year:{}, month:{}, employeeList.size:{}, employeeWorkDays.size:{}&quot;, year, month, employeeList.size(), employeeWorkDays.size());
                return employeeWorkDays;
            } catch (Exception ex) {
                logger.warning(&quot;rpc invoke failed(employeeAttendanceRPC.getEmployeeWorkDays), retry times:{}, year：{}, month:{},  employeeList.size:{}&quot;, retry, year, month, employeeList.size(), ex);
                
                // 连续重试失败之后，向上跑出异常
                // 对于没有异常机制的语言，此处应该打印error日志
                if (retry == MAX_RETRY_TIMES) {
                    throw new BusiessException(ex, &quot;rpc invoke failed(employeeAttendanceRPC.getEmployeeWorkDays)&quot;);
                }
            }
            retry++;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.4 日志打印时机的选择&lt;/h3&gt;
&lt;p&gt;　　由于日志是为了方便我们了解系统当前的运行状况以及定位线上问题，所以日志打印的时机非常重要，如果滥用日志，则会导致日志内容过多，影响问题定位的效率；如果日志打印过少，则容易导致缺少关键日志，导致在线上定位问题时找不到问题根音。因此把握日志打印的时机至关重要，以下是常见的适合打印日志的时机：&lt;/p&gt;
&lt;p&gt;1）http调用或者rpc接口调用&lt;/p&gt;
&lt;p&gt;　　在程序调用其他服务或者系统的时候，需要打印接口调用参数和调用结果(成功/失败)。&lt;/p&gt;
&lt;p&gt;2）程序异常&lt;/p&gt;
&lt;p&gt;　　在程序出现exception的时候，要么选择向上抛出异常，要么必须在catch块中打印异常堆栈信息。不过需要注意的是，最好不要重复打印异常日志，比如在catch块里既向上抛出了异常，又去打印错误日志(对外rpc接口函数入口处除外)。&lt;/p&gt;
&lt;p&gt;3）特殊的条件分支&lt;/p&gt;
&lt;p&gt;　　程序进入到一些特殊的条件分支时，比如特殊的else或者switch分支。比如我们根据工龄计算薪资：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public double calSalaryByWorkingAge(int age) {
        if (age &amp;lt; 0) {
            logger.error(&quot;wrong age value, age:{}&quot;, age);
            return 0;
        }
        // ..
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　理论上工龄不可能小于0，所以需要打印出这种非预期情况，当然通过抛出异常的方式也是可行的。&lt;/p&gt;
&lt;p&gt;4）关键执行路径及中间状态&lt;/p&gt;
&lt;p&gt;　　在一些关键的执行路径以及中间状态也需要记录下关键日志信息，比如一个算法可能分为很多步骤，每隔步骤的中间输出结果是什么，需要记录下来，以方便后续定位跟踪算法执行状态。&lt;/p&gt;
&lt;p&gt;5）请求入口和出口&lt;/p&gt;
&lt;p&gt;　　在函数或者对外接口的入口/出口处需要打印入口/出口日志，一来方便后续进行日志统计，同时也更加方便进行系统运行状态的监控。&lt;/p&gt;
&lt;h3&gt;2.5 日志内容与格式&lt;/h3&gt;
&lt;p&gt;　　日志打印时机决定了能够根据日志去进行问题定位，而日志的内容决定了是否能够根据日志快速找出问题原因，因此日志内容也是至关重要的。通常来说，一行日志应该至少包括以下几个组成部分：&lt;/p&gt;
&lt;p&gt;　　logTag、param、exceptionStacktrace&lt;/p&gt;
&lt;p&gt;　　logTag为日志标识，用来标识此日志输出的场景或者原因，param为函数调用参数，exceptionStacktrace为异常堆栈。举例说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;47&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class HttpClient {
        private static final Logger LOG = LoggerFactory.getLogger(HttpClient.class);

        private static int CONNECT_TIMEOUT = 5000;   // unit ms
        private static int READ_TIMEOUT = 10000;     // unit ms

        public static String sendPost(String url, String param) {
            OutputStream out = null;
            BufferedReader in = null;
            String result = &quot;&quot;;
            try {
                URL realUrl = new URL(url);
                URLConnection conn = realUrl.openConnection();
                conn.setDoInput(true);
                conn.setDoOutput(true);
                conn.setConnectTimeout(CONNECT_TIMEOUT);
                conn.setReadTimeout(READ_TIMEOUT);
                conn.setRequestProperty(&quot;charset&quot;, &quot;UTF-8&quot;);
                out = new PrintWriter(conn.getOutputStream());
                out.print(parm);
                out.flush();
                in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                String line;
                while ((line = in.readLine()) != null) {
                    result += line;
                }
            } catch (Exception ex) {
                // 有关键logTag，有参数信息，有错误堆栈
                LOG.error(&quot;post request error!!!, url:[[}], param:[{}]&quot;, url, param, ex);
            } finally {
                try {
                    if (out != null) {
                        out.close();
                    }
                    if (in != null) {
                        in.close();
                    }
                } catch (IOException ex) {
                    LOG.error(&quot;close stream error!!!, url:[[}], param:[{}]&quot;, url, param, ex);
                }
                return result;
            }
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class HttpClient {
    private static final Logger LOG = LoggerFactory.getLogger(HttpClient.class);

    private static int CONNECT_TIMEOUT = 5000;   // unit ms
    private static int READ_TIMEOUT = 10000;     // unit ms
    
    public static String sendPost(String url, String param) {
        OutputStream out = null;
        BufferedReader in = null;
        String result = &quot;&quot;;
        try {
            URL realUrl = new URL(url);
            URLConnection conn = realUrl.openConnection();
            conn.setDoInput(true);
            conn.setDoOutput(true);
            conn.setConnectTimeout(CONNECT_TIMEOUT);
            conn.setReadTimeout(READ_TIMEOUT);
            conn.setRequestProperty(&quot;charset&quot;, &quot;UTF-8&quot;);
            out = new PrintWriter(conn.getOutputStream());
            out.print(parm);
            out.flush();
            in = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line;
            while ((line = in.readLine()) != null) {
                result += line;
            }
        } catch (Exception ex) {
            // 没有任何错误信息
            LOG.error(&quot;post request error!!!&quot;);
        } finally {
            try {
                if (out != null) {
                    out.close();
                }
                if (in != null) {
                    in.close();
                }
            } catch (IOException ex) {
                LOG.error(&quot;close stream error!!!&quot;);
            }
            return result;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　另外，对于对外http接口或者rpc接口，&lt;strong&gt;最好对于每个请求都有requestId&lt;/strong&gt;，以便跟踪每个请求后续所有的执行路径。&lt;/p&gt;

&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27363484&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://zhuanlan.zhihu.com/p/27363484&quot;&gt;https://zhuanlan.zhihu.com/p/27363484&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/zollty/article/details/53958428&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://blog.csdn.net/zollty/article/details/53958428&quot;&gt;https://blog.csdn.net/zollty/article/details/53958428&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/59cd61eb93c2&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.jianshu.com/p/59cd61eb93c2&quot;&gt;https://www.jianshu.com/p/59cd61eb93c2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/6149463aec94&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.jianshu.com/p/6149463aec94&quot;&gt;https://www.jianshu.com/p/6149463aec94&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.jobbole.com/56574/&quot; target=&quot;_blank&quot; data-ke-src=&quot;http://blog.jobbole.com/56574/&quot;&gt;http://blog.jobbole.com/56574/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/kofxxf/p/3713472.html&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.cnblogs.com/kofxxf/p/3713472.html&quot;&gt;https://www.cnblogs.com/kofxxf/p/3713472.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitbook.cn/books/5ae6883ce9a7f01a861df619/index.html&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://gitbook.cn/books/5ae6883ce9a7f01a861df619/index.html&quot;&gt;https://gitbook.cn/books/5ae6883ce9a7f01a861df619/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xybaby/p/7954610.html&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.cnblogs.com/xybaby/p/7954610.html&quot;&gt;https://www.cnblogs.com/xybaby/p/7954610.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.didispace.com/cxy-wsm-zml-4/&quot; target=&quot;_blank&quot; data-ke-src=&quot;http://blog.didispace.com/cxy-wsm-zml-4/&quot;&gt;http://blog.didispace.com/cxy-wsm-zml-4/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kancloud.cn/digest/javabug/138401&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://www.kancloud.cn/digest/javabug/138401&quot;&gt;https://www.kancloud.cn/digest/javabug/138401&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/bad_yu/article/details/81035862&quot; target=&quot;_blank&quot; data-ke-src=&quot;https://blog.csdn.net/bad_yu/article/details/81035862&quot;&gt;https://blog.csdn.net/bad_yu/article/details/81035862&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 15:40:00 +0000</pubDate>
<dc:creator>Matrix海子</dc:creator>
<og:description>工程实践：如何规范地打印程序日志？ 很久之前，有个朋友问我，如果一个老项目让你接手去进行后续维护，你会先从哪里入手、让自己更快地上手项目？当时我没有特别正面去回答这个朋友的问题，我说：一个老项目是否容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dolphin0520/p/10396894.html</dc:identifier>
</item>
<item>
<title>神经网络入门——神经元算法 - 胖喵~</title>
<link>http://www.cnblogs.com/by-dream/p/10497816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/by-dream/p/10497816.html</guid>
<description>
&lt;p&gt;目前机器学习、深度学习在业界使用的越来越广泛，做为一个有着技术追求的it人，我觉得有必要学习和了解一下这块的知识，今天就从最简单的单层神经网络开始介绍。&lt;/p&gt;
&lt;p&gt;在介绍人工神经网络之前，首先认知下神经元。&lt;/p&gt;

&lt;h4 id=&quot;4f0e34e0&quot;&gt;神经元&lt;/h4&gt;
&lt;p&gt;不知道大家还有印象这个图吗？这个是出现在我们生物课本中的一幅图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190309094006876-920210380.png&quot; alt=&quot;&quot; width=&quot;428&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个神经元的组成基本就是上图这些东西组成。&lt;/p&gt;
&lt;p&gt;通常一个神经元具有多个树突，主要用来接受传入信息信息，信息通过轴突传递进来后经过一系列的计算（细胞核）最终产生一个信号传递到轴突，轴突只有一条，轴突尾端有许多轴突末梢可以给其他多个神经元传递信息。轴突末梢跟其他神经元的树突产生连接，从而传递信号。这个连接的位置在生物学上叫做“突触”。&lt;/p&gt;
&lt;p&gt;也就是说一个神经元接入了多个输入，最终只变成一个输出，给到了后面的神经元，那么基于此，我们尝试去构造一个类似的结构。&lt;/p&gt;

&lt;h4 id=&quot;8a95a6d1&quot;&gt;结构&lt;/h4&gt;
&lt;p&gt;神经元的树突我们类比为多条输入，而轴突可以类比为最终的输出。&lt;/p&gt;
&lt;p&gt;这里我们构造一个典型的神经元模型，该模型包含有3个输入，1个输出，以及中间的计算功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626346/201903/626346-20190310222105243-723483366.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;152&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意在每一个输入的“连接”上，都有一个对应的“权值”。&lt;/p&gt;

&lt;p&gt;说个通俗的例子来理解下权值。比如今天你要决定今是否要去看电影，可能要考虑这3个因素： 1、女朋友有没有时间，2、有没有好看的电影，3、今天工作忙不忙； 而这三个因素对于每个人来说权重都是不同的，因为有的人看重工作、有的人看重家人，不同的权重最终的结果也会不一样。&lt;/p&gt;
&lt;p&gt;因此权重的大小是比较关键的。而一个神经网络的训练算法就是让权重的值调整到最佳，以便使得整个网络的预测效果最好。&lt;/p&gt;

&lt;p&gt;接下里，我们用数学的方式来表示一下神经元，我们定义 w为权重，x为输入&lt;/p&gt;
&lt;p&gt;$$ w = \begin{bmatrix} w_{1}  \\  ... \\ w_{m} \end{bmatrix} ,  x = \begin{bmatrix} x_{1}  \\  ... \\ x_{m} \end{bmatrix}$$&lt;/p&gt;
&lt;p&gt;$$ z = w_{1} * x_{1}  + ... + w_{m} * x_{m} $$&lt;/p&gt;
&lt;p&gt;z输入的总和，也就是这两个矩阵的点乘，也叫内积。这里补充点数学知识。&lt;/p&gt;
&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552032252550-893e545b-c2c2-47e1-964a-8910b637eb72.png%22%2C%22originWidth%22%3A1518%2C%22originHeight%22%3A524%2C%22name%22%3A%22image.png%22%2C%22size%22%3A190586%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A424%2C%22height%22%3A146%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;​$$ z = w_{1} * x_{1}  + ... + w_{m} * x_{m} = \sum\limits_{j=1}^{m} w_{j} * w_{j} = w^{T}*x $$&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;lake-image&quot;&gt;
&lt;div class=&quot;lake-image-content lake-image-content-isvalid&quot; readability=&quot;31&quot;&gt;
&lt;div class=&quot;lake-image-detail&quot; data-role=&quot;detail&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;$w^{T}$代表矩阵的转置，即将列转未行，举个例子：&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;$\phi$(z) = { 1  if  z&amp;gt;=θ;   -1  otherwise&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;注意这里有一个阈值 &lt;span id=&quot;MathJax-Span-337&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-338&quot; class=&quot;mi&quot;&gt;θ ，阈值的确定也需要在训练过程中进行完成。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mrow&quot;&gt;&lt;span class=&quot;mi&quot;&gt;那么如何进行训练，这里的我们需要用到&lt;strong&gt;感知器（preceptron）&lt;/strong&gt;算法，具体过程分为下面这么几个步骤：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、首先将权重向量w进行初始化，可以为0或者是[0,1]之间的随机数；&lt;/p&gt;
&lt;p&gt;2、将训练样本输入感知器（计算内积后输入激活函数得到最终结果），最后得到分类的结果（结果为1 或 -1）；&lt;/p&gt;
&lt;p&gt;3、根据分类的结果再次更新权重向量w；&lt;/p&gt;

&lt;p&gt;前面提到激活函数是当z值大于一定的阈值&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;​ θ 后，才进行激活或者不激活。因此为了计算方便呢，我们再多加入一组向量，w0 和 x0 ，w 取 -θ ，x0 取 1；将其放到等式左边，这样&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;当 z&amp;gt;0 的时候 激活函数输出 1，而 z&amp;lt;0 激活函数输出 -1。&lt;/p&gt;
&lt;p&gt;$$ z = w_{0} * x_{0} + w_{1} * x_{1}  + ... + w_{m} * x_{m} $$&lt;/p&gt;
&lt;p&gt;$\phi$(z) = { 1  if  z&amp;gt;=0;   -1  otherwise&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;权重更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好，前面所有的准备都已经完成，接下来我们看下刚才提到的第三步，权重向量的更新，其实也就是神经网络训练的过程：&lt;/p&gt;
&lt;p&gt;权重的更新每一轮迭代  Wj = Wj+ &lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033435237-a42ac738-a9d1-4b49-9a3c-180c1f2f1358.png%22%2C%22originWidth%22%3A52%2C%22originHeight%22%3A58%2C%22name%22%3A%22image.png%22%2C%22size%22%3A2473%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A26%2C%22height%22%3A29%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;​ ▽Wj&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033435237-a42ac738-a9d1-4b49-9a3c-180c1f2f1358.png%22%2C%22originWidth%22%3A52%2C%22originHeight%22%3A58%2C%22name%22%3A%22image.png%22%2C%22size%22%3A2473%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A26%2C%22height%22%3A29%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;而 ▽Wj = η * ( y - y' ) * Xj &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033435237-a42ac738-a9d1-4b49-9a3c-180c1f2f1358.png%22%2C%22originWidth%22%3A52%2C%22originHeight%22%3A58%2C%22name%22%3A%22image.png%22%2C%22size%22%3A2473%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A26%2C%22height%22%3A29%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;上式中 η 叫做&lt;strong&gt;学习率&lt;/strong&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是[0, 1]之间的一个小数，由我们自己定义；y是真实 的样本分类，而 y’ 是感知器计算出来的分类。&lt;/p&gt;
&lt;p&gt;我们可以简单推导一下，当 y 和 y' 相等，&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033435237-a42ac738-a9d1-4b49-9a3c-180c1f2f1358.png%22%2C%22originWidth%22%3A52%2C%22originHeight%22%3A58%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A26%2C%22height%22%3A29%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;▽Wj 的值为0，Wj则不会&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F0%2F2019%2Fpng%2F96011%2F1552033463069-f125024c-0b4f-4e2e-8e2c-8e79af97716c.png%22%2C%22originWidth%22%3A56%2C%22originHeight%22%3A70%2C%22name%22%3A%22image.png%22%2C%22size%22%3A1858%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A28%2C%22height%22%3A35%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;left&quot;&gt;&lt;span data-card-element=&quot;center&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;&lt;span data-card-element=&quot;right&quot;&gt;更新。对应的意义就是真实和预测的结果是相同的，因此权重也不需要再更新了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里举个例子 : &lt;/p&gt;
&lt;p&gt;假设初始化 W = [ 0, 0, 0] ， X = [1, 2, 3],  假设定义 η = 0.3，y = 1，y' = -1 &lt;/p&gt;
&lt;p&gt;▽W(1) = 0.3 * (1 - (-1)) * X(1) = 0.3*2*1 = 0.6;      W(1) = W(1) + ▽W(1) = 0.6;&lt;/p&gt;
&lt;p&gt;▽W(2) = 0.3 * (1 - (-1)) * X(2) = 0.3*2*2 = 1.2;      W(1) = W(1) + ▽W(1) = 1.2;&lt;/p&gt;
&lt;p&gt;▽W(3) = 0.3 * (1 - (-1)) * X(3) = 0.3*2*3 = 1.8;      W(1) = W(1) + ▽W(1) = 1.8;&lt;/p&gt;
&lt;p&gt;更新之后的向量 w = [0.6, 1.2, 1.8]  然后接着继续计算，更新。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;阈值更新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面提到，我们将阈值经过变换后变成了 w0，再每一轮的迭代训练过程中，w0也需要跟着一起更新。&lt;/p&gt;
&lt;p&gt;最初w0 也需要初始化为0，因为x0等于1，因此 ▽W(0) = η * ( y - y' ) ；&lt;/p&gt;
&lt;p&gt;这里很多人可能会和我开始有一样的疑惑，阈值不是提前定义好的吗？其实不是的，这里不断的迭代，其实就是阀值计算的过程，和权重向量一样，最终都是通过一轮一轮更新计算出来的，由于一开始我们设定的w0 = - θ，所以当最终我们的阀值更新出来后，-w0 就是我们学习出来的阀值。&lt;/p&gt;

&lt;p&gt;看到上面的过程是否有些晕，从整体上看，其实就是这样一个过程：&lt;/p&gt;
&lt;p&gt;初始化权重向量和阈值，然后计算预测结果和真实结果是否存在误差，有误差就根据结果不断的更新权重，直到权重计算的结果最终达到最佳，权重的值就是我们学习出的规律。&lt;/p&gt;

&lt;p&gt;感知器目前的适用场景为线性可分的场景，就是用一条直线可以分割的二分类问题。&lt;/p&gt;

&lt;p&gt;用python实现了上述过程，可以看下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 简单神经网络 感知器&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

reload(sys)
sys.setdefaultencoding(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Perception(object):
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    eta: 学习率 η
    time: 训练次数
    w_: 权重向量
    
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, eta = 0.01, time=10&lt;span&gt;):
        self.eta &lt;/span&gt;=&lt;span&gt; eta
        self.time &lt;/span&gt;=&lt;span&gt; time
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
        
    &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    输入训练数据，X为输入样本向量，y对应样本分类
    X:shape[n_samples, n_features]
    X:[[1,2,3], [4,5,6]]
    n_samples : 2
    n_features: 3
    y:[1, -1]
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; fit(self, X, y):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化权重向量为0，加一为w0，也就是损失函数的阈值&lt;/span&gt;
        self.w_ = np.zero[1 + X.shape[1&lt;span&gt;]]
        self.errors_ &lt;/span&gt;=&lt;span&gt; []
        
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(self.time):
            errors &lt;/span&gt;=&lt;span&gt; 0
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; x:[[1,2,3], [4,5,6]]&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; y:[1, -1]&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; zip(X,y) = [[1,2,3,1], [4,5,6.-1]]&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; xi, target &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(X, y):
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; update = η * ( y - y' )&lt;/span&gt;
                update = self.eta * (target -&lt;span&gt; self.predict(xi))
                
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; xi 为向量, 这里每个向量都会乘&lt;/span&gt;
                self.w_[1:] += update *&lt;span&gt; xi
                self.w_[0] &lt;/span&gt;+=&lt;span&gt; update;
                
                errors &lt;/span&gt;+= int(update != 0.0&lt;span&gt;)
                
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
    
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 损失函数&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; predict(self, X):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; z = w1*x1+...+wj*xj + w0*1&lt;/span&gt;
        z = np.dot(X, self.w_[1:]) +&lt;span&gt; self.w_[0]
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 损失函数&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; z &amp;gt;= 0.0&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 1
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -1
        
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 10 Mar 2019 15:30:00 +0000</pubDate>
<dc:creator>胖喵~</dc:creator>
<og:description>目前机器学习、深度学习在业界使用的越来越广泛，做为一个有着技术追求的it人，我觉得有必要学习和了解一下这块的知识，今天就从最简单的单层神经网络开始介绍。 在介绍人工神经网络之前，首先认知下神经元。 神</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/by-dream/p/10497816.html</dc:identifier>
</item>
<item>
<title>利用过滤器和反射技术对string类型的入参进行统一trim - 五色花的</title>
<link>http://www.cnblogs.com/luao/p/10508054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luao/p/10508054.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;最近做的一些项目都是后台管理系统，主要是对表单数据的增删改查操作，其中有些表单项是字符串类型的，对于这些类型的表单项就需要在保存或编辑之前要进行.trim()处理,刚开始感觉没什么，遇到了就手动进行.trim()一下，感觉很正常，因为Java本身就提供了这么一个字符串处理的方法，感觉每次都这么做也不能嫌麻烦，理所应当。但是是随着业务的发展，需要这么处理的地方越来越多，虽然每次都小心谨慎，但难免会有遗漏，导致不该出现问题的地方出现了问题，对于这些不该出现的低级错误感到痛心。于是想，能不能写一个拦截器或者过滤器对string类型的入参进行统一trim处理，不用在数据持久化前分别对string类型的参数进行trim操作呢？于是就有了这篇文章。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;过滤器+重写HttpServletRequestWrapper类，将修改后的参数列表写回request中。&lt;/p&gt;
&lt;h2 id=&quot;代码示例&quot;&gt;代码示例&lt;/h2&gt;
&lt;h3 id=&quot;第一步-编写-参数过滤器&quot;&gt;第一步 编写 参数过滤器&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
package com.xx.controller.filter;

import org.springframework.web.filter.OncePerRequestFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @description: 类描述：参数过滤器
 * @author: 
 * @createdate: 2019/3/10 22:33
 * @lastdate:
 */
public class ParamsFilter extends OncePerRequestFilter {
    /**
     * Same contract as for {@code doFilter}, but guaranteed to be
     * just invoked once per request within a single request thread.
     * See {@link #shouldNotFilterAsyncDispatch()} for details.
     * &amp;lt;p&amp;gt;Provides HttpServletRequest and HttpServletResponse arguments instead of the
     * default ServletRequest and ServletResponse ones.
     *
     * @param request
     * @param response
     * @param filterChain
     */
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
            ParameterRequestWrapper requestWrapper = new ParameterRequestWrapper(request);
        filterChain.doFilter(requestWrapper, response);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第二步-重写-parameterrequestwrapper&quot;&gt;第二步 重写 ParameterRequestWrapper&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.jd.lifetravel.assistincome.controller.filter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

/**
 * @description: 类描述：重写 ParameterRequestWrapper
 * @author:
 * @createdate: 2019/3/10 22:35
 * @lastdate:
 */
public class ParameterRequestWrapper extends HttpServletRequestWrapper {
    private Map&amp;lt;String, String[]&amp;gt; params = new HashMap&amp;lt;String, String[]&amp;gt;();


    public ParameterRequestWrapper(HttpServletRequest request) {
        // 将request交给父类，以便于调用对应方法的时候，将其输出，其实父亲类的实现方式和第一种new的方式类似
        super(request);
        // 将参数表，赋予给当前的Map以便于持有request中的参数
        this.params.putAll(request.getParameterMap());
        this.modifyParameterValues();

    }

    /**
     * 重载一个构造方法
     *
     * @param request
     * @param extendParams
     */
    public ParameterRequestWrapper(HttpServletRequest request, Map&amp;lt;String, Object&amp;gt; extendParams) {
        this(request);
        addAllParameters(extendParams);
    }

    /**
     * 将parameter的值去除空格后重写回去
     */
    public void modifyParameterValues() {
        Set&amp;lt;String&amp;gt; set = params.keySet();
        Iterator&amp;lt;String&amp;gt; it = set.iterator();
        while (it.hasNext()) {
            String key = (String) it.next();
            String[] values = params.get(key);
            values[0] = values[0].trim();
            params.put(key, values);
        }
    }

    /**
     * 重写getParameter，代表参数从当前类中的map获取
     *
     * @param name
     * @return
     */
    @Override
    public String getParameter(String name) {
        String[] values = params.get(name);
        if (values == null || values.length == 0) {
            return null;
        }
        return values[0];
    }

    @Override
    public String[] getParameterValues(String name) {//同上
        return params.get(name);
    }

    public void addAllParameters(Map&amp;lt;String, Object&amp;gt; otherParams) {//增加多个参数
        for (Map.Entry&amp;lt;String, Object&amp;gt; entry : otherParams.entrySet()) {
            addParameter(entry.getKey(), entry.getValue());
        }
    }

    public void addParameter(String name, Object value) {//增加参数
        if (value != null) {
            if (value instanceof String[]) {
                params.put(name, (String[]) value);
            } else if (value instanceof String) {
                params.put(name, new String[]{(String) value});
            } else {
                params.put(name, new String[]{String.valueOf(value)});
            }
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;第三步-在web.xml配置过滤器&quot;&gt;第三步 在web.xml配置过滤器&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    &amp;lt;filter&amp;gt;  
        &amp;lt;filter-name&amp;gt;ParamsFilter&amp;lt;/filter-name&amp;gt;  
        &amp;lt;filter-class&amp;gt;top.lushunde.interceptor.ParamsFilter&amp;lt;/filter-class&amp;gt;  
    &amp;lt;/filter&amp;gt;  
    &amp;lt;filter-mapping&amp;gt;  
        &amp;lt;filter-name&amp;gt;ParamsFilter&amp;lt;/filter-name&amp;gt;  
        &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;  
    &amp;lt;/filter-mapping&amp;gt; &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 10 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>五色花的</dc:creator>
<og:description>背景 最近做的一些项目都是后台管理系统，主要是对表单数据的增删改查操作，其中有些表单项是字符串类型的，对于这些类型的表单项就需要在保存或编辑之前要进行.trim()处理,刚开始感觉没什么，遇到了就手动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/luao/p/10508054.html</dc:identifier>
</item>
</channel>
</rss>