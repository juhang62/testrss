<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>缓存中间件-缓存架构的实现（上） - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/12154529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/12154529.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;一眨眼，2019年就过去了。我希望从按照中间件，分别阐述一些常见的架构问题，以及解决方案。一方面这些问题与解决方案具备一定通用性 。另一方面，也算是面试中常见的问题。&lt;/p&gt;
&lt;p&gt;我希望根据自己待过各种规模公司的经验来谈一些看法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是针对大部分小公司的工作或面试，这些问题都稍微留下个印象即可。因为小公司的技术对这些问题并不是很看重，或者说机会用不到（小型公司往往追求产品功能的实现，业务的推进等）。&lt;/li&gt;
&lt;li&gt;如果是针对大部分中型公司的工作或面试，希望可以完整地知道这些问题与解决方案。因为在中型公司中，这些问题都或多或少遇到，甚至是需要迫切解决的。&lt;/li&gt;
&lt;li&gt;如果是大型公司的话，那么不仅仅需要知道这些问题与解决方案。还需要从中理解为什么会有这样的问题，为什么这样解决，在现有的项目中应该如何应用，是否提升空间等。因为在大公司中，一方面其内部往往采用自研框架，其它框架能够借鉴的只有方案，思想等精髓；另一方面大公司不缺乏那些应用开源框架的人，缺的是把握方案通用思想的人。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果上述无法理解的话，大家可以从功能性追求与非功能性追求两个方面去思考。就像写一个简单的方法一样，最基本的要求是实现其功能，紧接着就是不断追求其非功能性（如性能，扩展性，安全性等）。放大来看，对于公司的技术发展也是如此，或者说更为严格。&lt;/p&gt;
&lt;p&gt;之后找个机会，专门写个博客，来谈谈我对公司技术与公司的看法。&lt;/p&gt;
&lt;p&gt;话题收回来，接下来，让我开始有关中间件问题与解决方案的阐述吧。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;h3 id=&quot;缓存的认识&quot;&gt;缓存的认识&lt;/h3&gt;
&lt;p&gt;既然提及缓存中间件相关的问题及方案，首先就要谈谈这个缓存。&lt;/p&gt;
&lt;p&gt;原本我想通过高速缓存举例，但是想了想还是用内存举例子吧。&lt;/p&gt;
&lt;p&gt;比如我们现在玩的单机游戏，往往都容量都非常大（几十G，乃至上百G），轻轻松松都超过了电脑内存（16G）。那么很明显电脑在运行游戏时，是不可能将整个游戏文件都放入内存的。但是如果文件都在硬盘里，需要的时候再读取，显然硬盘的读写速度时不够的（由于游戏文件类别很多，所以硬盘不可能一直顺序读写），那游戏也会经常卡顿，加载缓慢等。那么该如何解决这个问题呢？&lt;/p&gt;
&lt;p&gt;其实这个问题和我们业务中遇到的一些问题是很类似的。一方面我们希望用户可以在保证用户体验的前提下查询数据（如设备列表，订单列表等），另一方面我们不可能将所有数据都放在内存（内存的读写速度比硬盘快，所以就不解释为什么用硬盘了）中。那么到底该怎么解决这个问题呢？&lt;/p&gt;
&lt;p&gt;这里就需要说到局部性原理了。局部性原理指的是数据的访问往往趋向于聚集在较小的连续区域。这里的连续区域包含两个方面：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间维度：一个被使用的数据，在接下来较短的时间内，往往会被再次使用。&lt;/li&gt;
&lt;li&gt;空间维度：一个被使用的数据，其关联的数据，往往也会被使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;局部性原理是在内存，高速缓存部分，提出来用于解决问题的。&lt;/p&gt;
&lt;p&gt;其实，我与朋友交流分布式的一些想法时，经常说：分布式系统和单机内部是非常相似的，很多理念都是相通的。当想通了这点后，就可以去思考两者的区别的。&lt;/p&gt;
&lt;p&gt;缓存中间件其实就是利用了局部性原理，不过缓存中间件本身只实现了局部性原理的时间维度。这也是为什么很多人都说缓存中间件是用来保存热点数据，符合二八定律。不过我们可以在应用部分实现局部性原理的空间维度。&lt;/p&gt;
&lt;h3 id=&quot;缓存的定位&quot;&gt;缓存的定位&lt;/h3&gt;
&lt;p&gt;五六年前，有人就提出一个有关缓存的问题，那就是缓存作为一个非持久化数据，我们该怎么划分它。是否需要保证它的可用性。其中就有一位阿里的前辈在他的书中提到，他更倾向于认为缓存并不是一种持久化数据，不该将缓存作为一种可靠数据源。但是这位前辈也表示现有的框架中对缓存依赖较重，应该在一定程度上保护它们，避免缓存雪崩等情况。&lt;/p&gt;
&lt;p&gt;我的看法是，在现有的技术体系中，缓存中间件等已经不再只是一个缓存了。一方面我们已经将Session等重要数据放在了缓存中，并且目前没有一个更合适的对应存储（我认为暂时也不需要一个新的存储方式。但是如果需要的话，可以将缓存中间件实例等按照内容的生命周期等进行分组）。另一方面，我们会需要明确缓存在系统中职责，它只是用来作为缓存，以及一些分布式内存。但是诸如单机所有的内部调用，应该通过消息中间件或RPC等来实现。并且明确不同缓存的职责，如Session不该放在Cookie中等。&lt;/p&gt;
&lt;h3 id=&quot;缓存的分类&quot;&gt;缓存的分类&lt;/h3&gt;
&lt;p&gt;缓存框架大致可以从客户端到数据源，分成以下分类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器缓存
&lt;ul&gt;&lt;li&gt;Cookie&lt;/li&gt;
&lt;li&gt;LocalStorage&lt;/li&gt;
&lt;li&gt;SessionStorage&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CDN缓存&lt;/li&gt;
&lt;li&gt;负载层缓存
&lt;ul&gt;&lt;li&gt;Nginx缓存模块&lt;/li&gt;
&lt;li&gt;Squid缓存服务器&lt;/li&gt;
&lt;li&gt;Lua扩展&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;应用层缓存
&lt;ul&gt;&lt;li&gt;Etag&lt;/li&gt;
&lt;li&gt;ThreadLocal&lt;/li&gt;
&lt;li&gt;Guava&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;外部缓存
&lt;/li&gt;
&lt;li&gt;数据库缓存
&lt;ul&gt;&lt;li&gt;MySql缓存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我特意查询了一下百度，首页上的有关缓存架构的博客，一半都只是在围绕着缓存中间件阐述缓存架构，剩下的一般也往往在大分类上有所遗漏（如浏览器缓存，数据库缓存）。当然也有一些博客在专门的领域阐述得较为深入，或者层次的划分比较不错。故本博客只是在阐述现阶段我对缓存架构的认识（也借鉴了一些书籍，课程的缓存体系）。&lt;/p&gt;
&lt;h2 id=&quot;浏览器缓存&quot;&gt;浏览器缓存&lt;/h2&gt;
&lt;p&gt;浏览器缓存，也是很多时候被后端所遗忘的部分。因为这已经不属于后端的工作了，但这一定属于架构师或者相关技术负责的职责。当然还有一个原因是我做过专门的前端开发。&lt;/p&gt;
&lt;p&gt;说白了，就是在浏览器保存一部分数据，当然这需要前端进行开发。&lt;/p&gt;
&lt;p&gt;这里直接上图，大家可以看一下Cookie，LocalStorage，SessionStorage：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180803193700323?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1NTg1NzAx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PS：图片来自&lt;a href=&quot;https://blog.csdn.net/qq_35585701/article/details/81393361&quot;&gt;网络&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;优势&quot;&gt;优势&lt;/h3&gt;
&lt;p&gt;由于是浏览器缓存，位于整个web请求相应框架的client端，所以对业务提供方没有任何负载压力与影响。只是客户端的浏览器存在些许的存储占据与计算负载。&lt;/p&gt;
&lt;h3 id=&quot;注意&quot;&gt;注意&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Cookie等的存储容量是有限的，需要注意分配。&lt;/li&gt;
&lt;li&gt;Cookie等的存储是明文的，不可以存储敏感数据，否则会存在安全隐患。&lt;/li&gt;
&lt;li&gt;Cookie等需要注意存储时间时间的有效设置。&lt;/li&gt;
&lt;li&gt;Cookie等存在一定的学习成本，与相关特性（如Cookie的域名设置问题，父域名无法读子域名的Cookie数据）。&lt;/li&gt;
&lt;li&gt;Cookie等需要明确业务中有哪些数据适合放在这里，如域名等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;实际应用&quot;&gt;实际应用&lt;/h3&gt;
&lt;p&gt;在我之前负责的IOT项目中，页面往往存在大量的数据，如终端列表，传感器列表，监测点列表等。并且数据间存在一定数据关系，如需要通过现存的终端列表来获取对应传感器列表，又如通过传感器列表来获取对应报警列表等。&lt;/p&gt;
&lt;p&gt;为了避免页面切换时，为了获取一个列表而需要多次请求（如为了获得已选定的终端列表的传感器列表，需要先请求终端列表），所以通过LocalStorage来存储终端列表。&lt;/p&gt;
&lt;h2 id=&quot;cdn缓存&quot;&gt;CDN缓存&lt;/h2&gt;
&lt;p&gt;CDN，Content Delivery Network，即内容分发网络。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CDN是构建网络上的内容分发网络&lt;/li&gt;
&lt;li&gt;CDN可以使得用户就近获取所需内容，避免网络拥塞，提高用户访问速度&lt;/li&gt;
&lt;li&gt;CDN依靠部署在各地的服务器，通过镜像服务器实现内容同步，其包括负载均衡，内容分发，调度等模块。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;优势-1&quot;&gt;优势&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;降低访问延迟。使得用户就近获取所需内容，避免过多路由造成用户访问延迟问题。&lt;/li&gt;
&lt;li&gt;降低服务器压力。毕竟放在CDN服务器的内容，就不用到应用服务器获取了。&lt;/li&gt;
&lt;li&gt;消除运营商差别。消除运营商之家互联的瓶颈造成的影响，使得所有用户获得同样的访问质量&lt;/li&gt;
&lt;li&gt;集群抗攻击。广泛分布的CDN节点，可有有效避免DDOS等攻击。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;同步缓慢。由于CDN是大量且分层的节点分布，所以数据的下发与同步会比较缓慢。&lt;/li&gt;
&lt;li&gt;如果是使用收费服务，则需要一定支出。如果是自建CDN，则需要技术付出。个人推荐，不必要的话，还是直接采用CDN收费服务吧，性价比更高一些。&lt;/li&gt;
&lt;li&gt;自身Web体系需要进行相应的调整。如CDN文件更新与服务器文件更新（版本号等手段）等问题。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关键技术&quot;&gt;关键技术&lt;/h3&gt;
&lt;p&gt;该部分内容，引自网易云课堂。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存
&lt;ul&gt;&lt;li&gt;缓存代理软件：Squid&lt;/li&gt;
&lt;li&gt;缓存算法决定命中率，源服务器压力，FTP节点存储能力&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分发能力
&lt;ul&gt;&lt;li&gt;分发能力取决于IDC（网络数据中西）能力和IDC策略性分布&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;负载均衡
&lt;ul&gt;&lt;li&gt;负载均衡软件：Nginx&lt;/li&gt;
&lt;li&gt;负载均衡（智能调度）决定最佳路由，响应时间，可用性，服务质量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;基于DNS
&lt;ul&gt;&lt;li&gt;DNS服务器软件：BIND&lt;/li&gt;
&lt;li&gt;基于DNS的负载均衡以CNAME实现域名中专，智取最优节点服务&lt;/li&gt;
&lt;li&gt;缓存点有客户端浏览器缓存，本地DNS服务器缓存&lt;/li&gt;
&lt;li&gt;缓存内哦让那个有DNS地址缓存，客户请求内容缓存，动态内容缓存&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;支持协议
&lt;ul&gt;&lt;li&gt;静动态加速（图片加速，https带证书加速）&lt;/li&gt;
&lt;li&gt;下载加速&lt;/li&gt;
&lt;li&gt;流媒体加速&lt;/li&gt;
&lt;li&gt;企业应用加速&lt;/li&gt;
&lt;li&gt;手机应用加速&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就当扩展一下见识吧（囧）&lt;/p&gt;
&lt;h3 id=&quot;实际应用-1&quot;&gt;实际应用&lt;/h3&gt;
&lt;p&gt;如果写过前端代码，会知道有的时候，我们采用的jQuery等通用JS，CSS等大多是使用公共的cdn地址。&lt;/p&gt;
&lt;p&gt;有的公司，会将公司的一些公共JS，图片等静态资源（尤其是公司Logo等），放在CDN上。进行网页开发时，直接引用对应的CDN地址。&lt;/p&gt;
&lt;h2 id=&quot;负载层缓存&quot;&gt;负载层缓存&lt;/h2&gt;
&lt;p&gt;负载层缓存一般是与负载均衡器相关的缓存，这里我就拿Nginx举例。&lt;/p&gt;
&lt;p&gt;Nginx可以通过以下三种手段，实现缓存：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本身的缓存模块&lt;/li&gt;
&lt;li&gt;转发请求至对应缓存服务器&lt;/li&gt;
&lt;li&gt;可以通过lua模块，直接从外部缓存（如Redis等）获取缓存数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来一一阐述&lt;/p&gt;
&lt;h3 id=&quot;nginx缓存模块&quot;&gt;Nginx缓存模块&lt;/h3&gt;
&lt;p&gt;Nginx的http_proxy模块，可以实现类似于Squid的缓存功能.&lt;/p&gt;
&lt;p&gt;Nginx对客户端已经访问的内容在Nginx服务器本地建立缓存副本，那么在一定时间内再次访问这些内容时，就不需要请求后面的应用服务器了。&lt;/p&gt;
&lt;p&gt;与此同时，当后面的应用服务器无法提供服务时（如宕机），Nginx服务器上的缓存资源还能够回应相关的用户请求，提高了后面应用服务器的鲁棒性（健壮性）。&lt;/p&gt;
&lt;h4 id=&quot;优势-2&quot;&gt;优势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;商业成本无。Nginx是开源的，无需商业付费。&lt;/li&gt;
&lt;li&gt;技术迭代成本低。现有的Web体系大多采用Nginx，进行技术迭代时，在Nginx只需要增加一个新的模块即可。&lt;/li&gt;
&lt;li&gt;可定制。可以根据需要，对指定路径，指定资源等进行定制化的缓存策略。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点-1&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;需要对Nginx的缓存模块进行一定的认识与学习。毕竟很多人使用Nginx都只是CV一下配置。&lt;/li&gt;
&lt;li&gt;需要根据业务需要与技术特点，进行缓存策略的调整。如果缺乏经验与足够的认识，可能会指定出不恰当的缓存技术规范（如哪些数据该走Nginx缓存模块等）。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;基本认识&quot;&gt;基本认识&lt;/h4&gt;
&lt;h5 id=&quot;缓存文件位置设置&quot;&gt;缓存文件位置设置&lt;/h5&gt;
&lt;p&gt;通过proxy_cache_path参数指定。proxy_cache_path有两个必填参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个参数为缓存目录。&lt;/li&gt;
&lt;li&gt;第二个keys_zone参数指定缓存名称和占用内存空间的大小。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;指定特定请求被缓存&quot;&gt;指定特定请求被缓存&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Nginx默认会缓存所有get和head方法的请求结果，缓存的key默认使用请求字符串&lt;/li&gt;
&lt;li&gt;自定义key。如proxy_cache_key &quot;$host$request_uri$cookie_user&quot;;&lt;/li&gt;
&lt;li&gt;指定请求至少被发送了多少次以上才被缓存，从而避免低频请求被缓存。如proxy_cache_min_uses 5;&lt;/li&gt;
&lt;li&gt;指定哪些方法的请求被缓存。如proxy_cache_methods GET HEAD POST;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;缓存有效期&quot;&gt;缓存有效期&lt;/h5&gt;
&lt;p&gt;默认情况下，缓存内容是长期留存，除非缓存的容量超出谁知的限制。也可以自定义设置有效时间。如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应状态码为200 302时，10分钟有效期限：proxy_cache_valid 200 302 10m;&lt;/li&gt;
&lt;li&gt;对任何状态码，5分钟有效期限：proxy_cache_valid any 5m;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;部分请求跳过缓存&quot;&gt;部分请求跳过缓存&lt;/h5&gt;
&lt;p&gt;通过proxy_cache_bypass指令，明确请求对应的响应来自原始数据，而不是缓存。&lt;/p&gt;
&lt;p&gt;例如（该示例来自网易云课堂） proxy_cache_bypass $cookie_nocache $arg_nocache$arg_comment;&lt;/p&gt;
&lt;p&gt;表示：如果任何一个参数不为空，或者不等于0，nginx就不会查找缓存，直接进行代理转发。&lt;/p&gt;
&lt;h4 id=&quot;扩展&quot;&gt;扩展&lt;/h4&gt;
&lt;p&gt;网页的缓存是由HTTP消息头中的“Cache-control”来控制的，常见的取值有private,no-cache,max-age,must-revalidate等，默认为private。详见下表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200105201930329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;squid缓存服务器&quot;&gt;Squid缓存服务器&lt;/h3&gt;
&lt;p&gt;其实Squid缓存服务器与Nginx缓存十分类似（毕竟Nginx的缓存就是仿照Squid的），所以这里只是表示有这么个选择，不做深入。&lt;/p&gt;
&lt;h3 id=&quot;lua扩展&quot;&gt;Lua扩展&lt;/h3&gt;
&lt;p&gt;Nginx是C语言开发（这也是Nginx高性能的根本原因之一），并且Nginx模块需要用C开发，并且需要符合一系列复杂的规则，还需要熟悉Nginx源码。&lt;/p&gt;
&lt;h4 id=&quot;ngx_lua模块&quot;&gt;ngx_lua模块&lt;/h4&gt;
&lt;p&gt;所以Nginx提供了ngx_lua模块，通过lua解释器集成进Nginx。而ngx_lua模块具备以下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高并发，非阻塞地处理各种请求。&lt;/li&gt;
&lt;li&gt;Lua内建协程（可对比golang），从而将异步回调转换成顺序调用的形式。&lt;/li&gt;
&lt;li&gt;每个协程都有一个独立的全局环境（变量空间），继承于全局共享的，只读的“comman data”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述只是简单提一下Lua扩展，感兴趣的可以查询相关资料。&lt;/p&gt;
&lt;p&gt;这里继续阐述Lua扩展，实现缓存功能。&lt;/p&gt;
&lt;h4 id=&quot;实际应用-2&quot;&gt;实际应用&lt;/h4&gt;
&lt;p&gt;为了帮助大家理解，先说一下实际应用。&lt;/p&gt;
&lt;p&gt;Nginx针对HTTP请求处理，有十一个阶段。与之相对的，ngx_lua模块的执行指令都包含在了上述的十一个阶段。这里只说一下其中的content_by_lua指令，针对的是Nginx的content阶段，可以在location，location if范围内使用，主要作为内容处理器，接收请求处理并输出响应。&lt;/p&gt;
&lt;p&gt;具体配置如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200105204035409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样配置后，直接浏览器访问本地ip（或者通过curl命令），可以看到“Hello,world”。&lt;/p&gt;
&lt;p&gt;当然，这种用法相对比较初级。在OpenResty中存在一些组件，可以帮助ngx_lua模块直接访问Redis这样的数据源。这样就可以将一些简单的数据通过这种方式来进行访问，降低应用服务器压力。&lt;/p&gt;
&lt;h4 id=&quot;优势-3&quot;&gt;优势&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;降低应用服务器压力&lt;/li&gt;
&lt;li&gt;门槛较低。可以按照一些配置模板，直接进行使用&lt;/li&gt;
&lt;li&gt;扩展性较强。ngx_lua模块的应用上限还是比较高的&lt;/li&gt;
&lt;li&gt;灵活性强。ngx_lua模块的灵活性，表示其在缓存方面具有较高的灵活性&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;缺点-2&quot;&gt;缺点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;精通难。想要精通这部分的话，需要了解lua脚本，以及Nginx的HTTP请求阶段等。&lt;/li&gt;
&lt;li&gt;额外的开发任务。除了应用开发外，还需要专门的lua开发。&lt;/li&gt;
&lt;li&gt;耦合性较高。一个页面，一个功能，却往往需要进行Nginx与后端联合开发。&lt;/li&gt;
&lt;li&gt;任务难以界定。在业务上难以界定一些功能的开发该归于哪个模块（Nginx，后端）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;至此，我们已经了解了缓存架构中最靠近用户的三层缓存：浏览器缓存，CDN缓存，负载层缓存。&lt;/p&gt;
&lt;p&gt;如果存在什么问题，或者疑惑，可以私信或@我。&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jan 2020 00:28:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>缓存中间件 缓存架构的实现（上） 前言 一眨眼，2019年就过去了。我希望从按照中间件，分别阐述一些常见的架构问题，以及解决方案。一方面这些问题与解决方案具备一定通用性 。另一方面，也算是面试中常见的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/12154529.html</dc:identifier>
</item>
<item>
<title>面试中经常问到的Redis七种数据类型，你都真正了解吗？ - 万猫学社</title>
<link>http://www.cnblogs.com/heihaozi/p/12164700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heihaozi/p/12164700.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Redis不是一个简单的键值对存储，它实际上是一个支持各种类型数据结构的存储。在传统的键值存储中，是将字符串键关联到字符串值，但是在Redis中，这些值不仅限于简单的字符串，还可以支持更复杂的数据结构。下面就是Redis支持的数据结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;字符串&lt;/strong&gt;（String）：二进制安全字符串。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;列表&lt;/strong&gt;（List）：根据插入顺序排序的字符串元素列表，基于链表实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合&lt;/strong&gt;（Set）：唯一的乱序的字符串元素的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有序集合&lt;/strong&gt;（Sorted Set）：与&lt;strong&gt;集合&lt;/strong&gt;类似，但是每个字符串元素都与一个称为score的数字相关联。 元素总是按其score排序，并且可以检索一定score范围的元素。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希&lt;/strong&gt;（Hash）：由字段与值相关联组成的映射，字段和值都是字符串。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;位图&lt;/strong&gt;（Bitmap）:像操作位数组一样操作字符串值，可以设置和清除某个位，对所有为1的位进行计数，找到第一个设置1的位，找到第一个设置0的位等等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HyperLogLogs&lt;/strong&gt;：一种概率数据结构，使用较小的内存空间来统计唯一元素的数量，误差小于1％。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;键key&quot;&gt;键（Key）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;键&lt;/code&gt;是二进制安全的，这意味着您可以使用任何二进制序列作为键，可以是&lt;code&gt;OneMoreStudy&lt;/code&gt;这样的字符串，也可以使图片文件的内容，空字符串也是有效的&lt;code&gt;键&lt;/code&gt;。不过，还有一些其他规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要使用过长的&lt;code&gt;键&lt;/code&gt;，比如一个1KB的键。不仅是多占内存方面的问题，而是在数据集中查找&lt;code&gt;键&lt;/code&gt;可能需要进行一些耗时的&lt;code&gt;键&lt;/code&gt;比较。如果真的有比较大的&lt;code&gt;键&lt;/code&gt;，先对它进行哈希（比如：&lt;code&gt;MD5&lt;/code&gt;、&lt;code&gt;SHA1&lt;/code&gt;）是一个好主意。&lt;/li&gt;
&lt;li&gt;也不要使用过短的&lt;code&gt;键&lt;/code&gt;，比如：&lt;code&gt;OMS100f&lt;/code&gt;，相对于&lt;code&gt;one-more-study:100:fans&lt;/code&gt;，后者更具有可读性。可能会占用更多内存，但是相对于值所占的内存，&lt;code&gt;键&lt;/code&gt;所增加的内存还是小很多的。我们要找到一个平衡点，不长也不短。&lt;/li&gt;
&lt;li&gt;多个字段以冒号分隔，一个字段内多个单词以连词符或点分隔，比如：&lt;code&gt;one-more-study:100:fans&lt;/code&gt;，或者&lt;code&gt;one.more.study:100:fans&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;键&lt;/code&gt;允许的最大值为512MB。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符串string&quot;&gt;字符串（String）&lt;/h3&gt;
&lt;p&gt;字符串类型是和&lt;code&gt;键&lt;/code&gt;关联的最简单的类型。它是Memcached中唯一的数据类型，因此对于新手来说，在Redis中使用它也是很容易的。&lt;code&gt;键&lt;/code&gt;是字符串类型，当我们也使用字符串类型作为值时，我们会可以从一个字符串映射到另一个字符串。 字符串数据类型有很多应用场景，例如缓存HTML片段或页面。&lt;/p&gt;
&lt;p&gt;下面简单介绍一下字符串的命令（在redis-cli中使用）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; set one-more-key OneMoreStudy
OK
&amp;gt; get one-more-key
&quot;OneMoreStudy&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;SET&lt;/code&gt;和&lt;code&gt;GET&lt;/code&gt;命令来设置和查询字符串值的方式。需要注意的是，如果当前&lt;code&gt;键&lt;/code&gt;已经和字符串值相关联，&lt;code&gt;SET&lt;/code&gt;命令将会替换已存储在&lt;code&gt;键&lt;/code&gt;中的现有值。字符串可以是任意的二进制数据，比如jpeg图像。字符串最多不能大于512MB。&lt;code&gt;SET&lt;/code&gt;命令还有一些实用的可选参数，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; set one-more-key Java nx   #如果key存在，则设置失败。
(nil)
&amp;gt; set one-more-key Java xx   #如果key存在，才设置成功。
OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然字符串是Redis的基本值，但也可以使用它们执行一些实用的操作。 比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; set one-more-counter 50
OK
&amp;gt; incr one-more-counter   #自增加1
(integer) 51
&amp;gt; incr one-more-counter   #自增加1
(integer) 52
&amp;gt; incrby one-more-counter 5   #自增加5
(integer) 57&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;INCR&lt;/code&gt;命令将字符串值解析为整数，将其自增加1，最后将获得的值设置为新值。 还有其他类似的命令，例如&lt;code&gt;INCRBY&lt;/code&gt;，&lt;code&gt;DECR&lt;/code&gt;和&lt;code&gt;DECRBY&lt;/code&gt;等命令。 &lt;code&gt;INCR&lt;/code&gt;命令是原子操作，即时有多个客户端同时同一个key的&lt;code&gt;INCR&lt;/code&gt;命令，也不会进入竞态条件。比如，上面的例子先设置&lt;code&gt;one-more-counter&lt;/code&gt;的值为50，即使两个客户端同时发出INCR命令，那么最后的值也肯定是52。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;MSET&lt;/code&gt;和&lt;code&gt;MGET&lt;/code&gt;命令在单个命令中设置或查询多个&lt;code&gt;键&lt;/code&gt;的值，对于减少延迟也很有用。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; mset a 1 b 2 c 3
OK
&amp;gt; mget a b c
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;MGET&lt;/code&gt;命令时，Redis返回一个值的数组。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用DEL命令可以删除&lt;code&gt;键&lt;/code&gt;和相关联的值，存在指定的&lt;code&gt;键&lt;/code&gt;则返回1，不存在指定的&lt;code&gt;键&lt;/code&gt;则返回0。使用&lt;code&gt;EXISTS&lt;/code&gt;命令判断Redis中是否存在指定的&lt;code&gt;键&lt;/code&gt;，存在指定的&lt;code&gt;键&lt;/code&gt;则返回1，不存在指定的&lt;code&gt;键&lt;/code&gt;则返回0。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; set one-more-key OneMoreStudy
OK
&amp;gt; exists one-more-key
(integer) 1
&amp;gt; del one-more-key
(integer) 1
&amp;gt; exists one-more-key
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;TYPE&lt;/code&gt;命令，可以返回存储在指定key的值的数据类型，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; set one-more-key OneMoreStudy
OK
&amp;gt; type one-more-key
string
&amp;gt; del one-more-key
(integer) 1
&amp;gt; type one-more-key
none&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在讨论更复杂的数据结构之前，我们需要讨论另一个功能，该功能无论值类型是什么都适用，它就是&lt;code&gt;EXPIRE&lt;/code&gt;命令。 它可以为&lt;code&gt;键&lt;/code&gt;设置到期时间，当超过这个到期时间后，该&lt;code&gt;键&lt;/code&gt;将自动销毁，就像对这个&lt;code&gt;键&lt;/code&gt;调用了&lt;code&gt;DEL&lt;/code&gt;命令一样。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; set one-more-key OneMoreStudy
OK
&amp;gt; expire one-more-key 5
(integer) 1
&amp;gt; get one-more-key #立刻调用
&quot;OneMoreStudy&quot;
&amp;gt; get one-more-key #5秒钟后调用
(nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子，适用了&lt;code&gt;EXPIRE&lt;/code&gt;命令设置了过期时间，也可以使用&lt;code&gt;PERSIST&lt;/code&gt;命令移除&lt;code&gt;键&lt;/code&gt;的过期时间，这个&lt;code&gt;键&lt;/code&gt;将持久保持。除了&lt;code&gt;EXPIRE&lt;/code&gt;命令，还可以使用SET命令设置过期时间，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; set one-more-key OneMoreStudy ex 10 #设置过期时间为10秒
OK
&amp;gt; ttl one-more-key
(integer) 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子，设置了一个字符串值&lt;code&gt;OneMoreStudy&lt;/code&gt;的&lt;code&gt;one-more-key&lt;/code&gt;，该&lt;code&gt;键&lt;/code&gt;的到期时间为10秒。之后，调用&lt;code&gt;TTL&lt;/code&gt;命令以检查该&lt;code&gt;键&lt;/code&gt;的剩余生存时间。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到期时间可以使用秒或毫秒精度进行设置，但到期时间的分辨率始终为1毫秒。实际上，Redis服务器上存储的不是到期时间长度，而是该&lt;code&gt;键&lt;/code&gt;到期的时间。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;列表list&quot;&gt;列表（List）&lt;/h3&gt;
&lt;p&gt;Redis列表是使用链表实现的，这就意味着在头部或尾部增加或删除一个的元素的时间复杂度是O(1)，非常快的。不过，按索引查询对应元素的时间复杂度就是O(n)，慢很多。如果想快速查询大量数据，可以使用有序集合，后面会有介绍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LPUSH&lt;/code&gt;命令将一个新元素添加到列表的左侧（顶部），而&lt;code&gt;RPUSH&lt;/code&gt;命令将一个新元素添加到列表的右侧（底部）。最后，&lt;code&gt;LRANGE&lt;/code&gt;命令可以从列表中按范围提取元素。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; rpush one-more-list A
(integer) 1
&amp;gt; rpush one-more-list B
(integer) 2
&amp;gt; lpush one-more-list first
(integer) 3
&amp;gt; lrange one-more-list 0 -1
1) &quot;first&quot;
2) &quot;A&quot;
3) &quot;B&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LRANGE&lt;/code&gt;命令需要另外两个参数，要返回的第一个元素的索引和最后一个元素的索引。如果索引为负值，Redis将从末尾开始计数，-1是列表的最后一个元素，-2是列表的倒数第二个元素，依此类推。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LPUSH&lt;/code&gt;和&lt;code&gt;RPUSH&lt;/code&gt;命令支持多个参数，可以使用一次命令添加多个元素，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; rpush one-more-list 1 2 3 4 5 &quot;last&quot;
(integer) 9
&amp;gt; lrange one-more-list 0 -1
1) &quot;first&quot;
2) &quot;A&quot;
3) &quot;B&quot;
4) &quot;1&quot;
5) &quot;2&quot;
6) &quot;3&quot;
7) &quot;4&quot;
8) &quot;5&quot;
9) &quot;last&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Redis列表上，也可以移除并返回元素。 与&lt;code&gt;LPUSH&lt;/code&gt;和&lt;code&gt;RPUSH&lt;/code&gt;命令，对应的就是&lt;code&gt;LPOP&lt;/code&gt;和&lt;code&gt;RPOP&lt;/code&gt;命令，&lt;code&gt;LPOP&lt;/code&gt;命令是将列表的左侧（顶部）的元素移除并返回，&lt;code&gt;RPOP&lt;/code&gt;命令是将列表的右侧（底部）的元素移除并返回。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; rpush one-more-list a b c
(integer) 3
&amp;gt; rpop one-more-list
&quot;c&quot;
&amp;gt; rpop one-more-list
&quot;b&quot;
&amp;gt; rpop one-more-list
&quot;a&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们添加了三个元素，并移除并返回了三个元素，此时列表为空，没有任何元素。如果再使用&lt;code&gt;RPOP&lt;/code&gt;命令，会返回一个&lt;code&gt;NULL&lt;/code&gt;值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; rpop one-more-list
(nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;RPUSH&lt;/code&gt;和&lt;code&gt;RPOP&lt;/code&gt;命令，或者&lt;code&gt;LPUSH&lt;/code&gt;和&lt;code&gt;LPOP&lt;/code&gt;命令可以实现栈的功能，使用&lt;code&gt;LPUSH&lt;/code&gt;和&lt;code&gt;RPOP&lt;/code&gt;命令，或者&lt;code&gt;RPUSH&lt;/code&gt;和&lt;code&gt;LPOP&lt;/code&gt;命令可以实现队列的功能。也可以实现生产者和消费者模式，比如多个生产者使用&lt;code&gt;LPUSH&lt;/code&gt;命令将任务添加到列表中，多个消费者使用&lt;code&gt;RPOP&lt;/code&gt;命令将任务从列表中取出。但是，有时列表可能为空，没有任何要处理的任务，因此&lt;code&gt;RPOP&lt;/code&gt;命令仅返回&lt;code&gt;NULL&lt;/code&gt;。在这种情况下，消费者被迫等待一段时间，然后使用&lt;code&gt;RPOP&lt;/code&gt;命令重试。这就暴露了有几个缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;客户端和服务端之间可以处理无用的命令，因为在列表为空时的所有请求将无法完成任何实际工作，它们只会返回&lt;code&gt;NULL&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由于消费者在收到&lt;code&gt;NULL&lt;/code&gt;之后会等待一段时间，因此会增加任务处理的延迟。为了减小延迟，我们可以在两次调用&lt;code&gt;RPOP&lt;/code&gt;之间等待更少的时间，这就扩大了更多对Redis的无用调用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有什么办法可以解决呢？使用&lt;code&gt;BRPOP&lt;/code&gt;和&lt;code&gt;BLPOP&lt;/code&gt;的命令，它们和&lt;code&gt;RPOP&lt;/code&gt;和&lt;code&gt;LPOP&lt;/code&gt;命令类似，唯一的区别是：如果列表为空时，命令会被阻塞，直到有新元素添加到列表中，或指定的超时时间到了时，它们才会返回到调用方。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; brpop tasks 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它含义是，列表为空时，等待列表中的元素，但如果5秒钟后没有新的元素被添加，则返回。您可以将超时时间传入0，表示永远等待元素添加。也可以传入多个列表，这时会按参数先后顺序依次检查各个列表，返回第一个非空列表的尾部元素。另外还有以下3点需要注意的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当列表为空，并且有多个客户端在等待时，有一个新的元素被添加到列表中，它会被第一个等待的客户端获取到，以此类推。&lt;/li&gt;
&lt;li&gt;返回值与&lt;code&gt;RPOP&lt;/code&gt;命令相比有所不同，它是一个包含两个元素的数组，包含key和对应的元素，因为&lt;code&gt;BRPOP&lt;/code&gt;和&lt;code&gt;BLPOP&lt;/code&gt;命令能够阻止等待来自多个列表的元素。&lt;/li&gt;
&lt;li&gt;超过了超时时间，会返回&lt;code&gt;NULL&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;列表的创建和删除都是由Redis自动完成的，当尝试向不存在的&lt;code&gt;键&lt;/code&gt;添加元素时，Redis会自动创建一个空的列表；当最后一个元素被移除时，Redis会自动删除这个列表。这不是特定于列表的，它适用于由多个元素组成的所有Redis数据类型，比如集合、有序集合、哈希，它们都有3条规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当我们将元素添加到聚合数据类型时，如果目标&lt;code&gt;键&lt;/code&gt;不存在，则在添加元素之前会创建一个空的聚合数据类型。比如：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; del one-more-list
(integer) 1
&amp;gt; lpush one-more-list 1 2 3
(integer) 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但是，在&lt;code&gt;键&lt;/code&gt;存在时，就不能操作错误的数据类型了，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; set one-more-key OneMoreStudy
OK
&amp;gt; lpush one-more-key 1 2 3
(error) WRONGTYPE Operation against a key holding the wrong kind of value
&amp;gt; type one-more-key
string&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;当我们从聚合数据类型中删除元素时，如果该值保持为空，则key将自动销毁。比如：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; lpush one-more-list 1 2 3
(integer) 3
&amp;gt; exists one-more-list
(integer) 1
&amp;gt; lpop one-more-list
&quot;3&quot;
&amp;gt; lpop one-more-list
&quot;2&quot;
&amp;gt; lpop one-more-list
&quot;1&quot;
&amp;gt; exists one-more-list
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;当对应key不存在，并且调用只读命令（如&lt;code&gt;LLEN&lt;/code&gt;命令，获取列表长度）或写命令（如&lt;code&gt;LPOP&lt;/code&gt;命令）时，都会返回空聚合数据类型的结果。比如：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; del one-more-list
(integer) 0
&amp;gt; llen one-more-list
(integer) 0
&amp;gt; lpop one-more-list
(nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redis为了追求高性能，列表的内部实现不是一个简单的链表，这里先卖个关子，后续的文章会详细介绍。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;集合set&quot;&gt;集合（Set）&lt;/h3&gt;
&lt;p&gt;集合是一个字符串的无序集合，&lt;code&gt;SADD&lt;/code&gt;命令可以将新元素添加到集合中。还可以对集合进行许多其他操作，例如：判断给定元素是否已存在、执行多个集合之间的交集、并集或差等等。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; sadd one-more-set 1 2 3
(integer) 3
&amp;gt; smembers one-more-set
1) &quot;1&quot;
2) &quot;3&quot;
3) &quot;2&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子中，在集合中添加了三个元素，并让Redis返回所有元素。 正如你所见，返回的元素是没有排序的。在每次调用时，元素的顺序都有可能不一样。&lt;/p&gt;
&lt;p&gt;还可以使用&lt;code&gt;SISMEMBER&lt;/code&gt;命令判断给定元素是否已存在，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; sismember one-more-set 3
(integer) 1
&amp;gt; sismember one-more-set 30
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子中，3在集合中，所以返回1；而30不在集合中，所以返回0。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;SINTER&lt;/code&gt;命令，计算出多个集合的交集；使用&lt;code&gt;SUNION&lt;/code&gt;命令，计算多个集合的并集；使用&lt;code&gt;SPOP&lt;/code&gt;命令，移除并返回集合中的一个随机元素；使用&lt;code&gt;SCARD&lt;/code&gt;命令，计算集合中的元素的数量。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; sadd one-more-set1 1 2 3
(integer) 3
&amp;gt; sadd one-more-set2 2 3 4
(integer) 3
&amp;gt; sinter one-more-set1 one-more-set2 #交集
1) &quot;3&quot;
2) &quot;2&quot;
&amp;gt; sunion one-more-set1 one-more-set2 #并集
1) &quot;1&quot;
2) &quot;3&quot;
3) &quot;2&quot;
4) &quot;4&quot;
&amp;gt; spop one-more-set1 #随机移除一个元素
&quot;3&quot;
&amp;gt; scard one-more-set1 #元素数量
(integer) 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;有序集合sorted-set&quot;&gt;有序集合（Sorted Set）&lt;/h3&gt;
&lt;p&gt;有序集合是一种类似于集合和哈希之间混合的数据类型。像集合一样，有序集合中由唯一的、非重复的字符串元素组成，因此从某种意义上说，有序集合也是一个集合。但是集合中的元素是没有排序的，而有序集合中的每个元素都与一个称为&lt;code&gt;分数&lt;/code&gt;（score）的浮点值相关联，这就是为什么有序集合也类似于哈希的原因，因为每个元素都映射到一个值。有序集合的排序规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果A和B是两个具有不同分数的元素，那么如果A.分数&amp;gt;B.分数，则A&amp;gt;B。&lt;/li&gt;
&lt;li&gt;如果A和B的分数完全相同，那么如果A字符串在字典排序上大于B字符串，则A&amp;gt;B。 A和B字符串不能相等，因为有序集合中的元素都是唯一的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们来举个例子，把&lt;strong&gt;王者荣耀&lt;/strong&gt;战队的名字和积分添加到有序集合中，其中把战队的名字作为值，把战队的积分作为分数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; zadd kpl 12 &quot;eStarPro&quot;
(integer) 1
&amp;gt; zadd kpl 12 &quot;QGhappy&quot;
(integer) 1
&amp;gt; zadd kpl 10 &quot;XQ&quot;
(integer) 1
&amp;gt; zadd kpl 8 &quot;EDG.M&quot;
(integer) 1
&amp;gt; zadd kpl 8 &quot;RNG.M&quot;
(integer) 1
&amp;gt; zadd kpl 4 &quot;TES&quot;
(integer) 1
&amp;gt; zadd kpl 2 &quot;VG&quot;
(integer) 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所示，&lt;code&gt;ZADD&lt;/code&gt;命令和&lt;code&gt;SADD&lt;/code&gt;命令相似，但是多了一个额外的参数（在要添加的元素的前面）作为分数。&lt;code&gt;ZADD&lt;/code&gt;命令也支持多个参数，虽然在上面的例子中未使用它，但你也可以指定多个分数和值对。使用有序集合，快速地返回按其积分排序的战队列表，因为实际上它们已经被排序了。&lt;/p&gt;
&lt;p&gt;需要注意的是，为了快速获取有序集合中的元素，每次添加元素的时间复杂度都为O(log(N))，这是因为有序集合是同时使用跳跃表和字典来实现的，具体原理这里先卖个关子，后续的文章会详细介绍。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;ZRANGE&lt;/code&gt;命令按照升序获取对应的值，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; zrange kpl 0 -1
1) &quot;VG&quot;
2) &quot;TES&quot;
3) &quot;EDG.M&quot;
4) &quot;RNG.M&quot;
5) &quot;XQ&quot;
6) &quot;QGhappy&quot;
7) &quot;eStarPro&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;0和-1代表查询从第一个到最后一个的元素。还可以使用&lt;code&gt;ZREVRANGE&lt;/code&gt;命令按照降序获取对应的值，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; zrevrange kpl 0 -1
1) &quot;eStarPro&quot;
2) &quot;QGhappy&quot;
3) &quot;XQ&quot;
4) &quot;RNG.M&quot;
5) &quot;EDG.M&quot;
6) &quot;TES&quot;
7) &quot;VG&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上&lt;code&gt;WITHSCORES&lt;/code&gt;参数，就可以连同分数一起返回，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; zrange kpl 0 -1 withscores
 1) &quot;VG&quot;
 2) &quot;2&quot;
 3) &quot;TES&quot;
 4) &quot;4&quot;
 5) &quot;EDG.M&quot;
 6) &quot;8&quot;
 7) &quot;RNG.M&quot;
 8) &quot;8&quot;
 9) &quot;XQ&quot;
10) &quot;10&quot;
11) &quot;QGhappy&quot;
12) &quot;12&quot;
13) &quot;eStarPro&quot;
14) &quot;12&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有序集合还有更强大的功能，比如在分数范围内操作，让我们获取小于10（含）的战队，使用&lt;code&gt;ZRANGEBYSCORE&lt;/code&gt;命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; zrangebyscore kpl -inf 10
1) &quot;VG&quot;
2) &quot;TES&quot;
3) &quot;EDG.M&quot;
4) &quot;RNG.M&quot;
5) &quot;XQ&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是获取分数从负无穷到10所对应的值，同样的我们也可以获取分数从4到10所对应的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; zrangebyscore kpl 4 10
1) &quot;TES&quot;
2) &quot;EDG.M&quot;
3) &quot;RNG.M&quot;
4) &quot;XQ&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外有用的命令：&lt;code&gt;ZRANK&lt;/code&gt;命令，它可以返回指定值的升序排名（从0开始）；&lt;code&gt;ZREVRANK&lt;/code&gt;命令，它可以返回指定值的降序排名（从0开始），比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; zrank kpl &quot;EDG.M&quot;
(integer) 2
&amp;gt; zrevrank kpl &quot;EDG.M&quot;
(integer) 4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有序集合的分数是随时更新的，只要对已有的有序集合调用&lt;code&gt;ZADD&lt;/code&gt;命令，就会以O(log(N))时间复杂度更新其分数和排序。这样，当有大量更新时，有序集合是合适的。由于这种特性，常见的场景是排行榜，可以方便地显示排名前N位的用户和用户在排行榜中的排名。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;哈希hash&quot;&gt;哈希（Hash）&lt;/h3&gt;
&lt;p&gt;Redis的哈希和人们期望的“哈希”结构是一样的，它是一个无序哈希，内部存储了很多键值对，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; hmset one-more-fans:100 name Lily age 25
OK
&amp;gt; hget one-more-fans:100 name
&quot;Lily&quot;
&amp;gt; hget one-more-fans:100 age
&quot;25&quot;
&amp;gt; hgetall one-more-fans:100
1) &quot;name&quot;
2) &quot;Lily&quot;
3) &quot;age&quot;
4) &quot;25&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尽管哈希很容易用来表示对象，但是实际上可以放入哈希中的字段数是没有实际限制的，因此您可以以更多种的不同方式使用哈希。除了&lt;code&gt;HGET&lt;/code&gt;命令获取单个字段对应的值，也可以使用&lt;code&gt;HMSET&lt;/code&gt;命令获取多个字段及对应的值，它返回的是一个数组，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; hmget one-more-fans:100 name age non-existent-field
1) &quot;Lily&quot;
2) &quot;25&quot;
3) (nil)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以使用&lt;code&gt;HINCRBY&lt;/code&gt;命令，为指定字段的值做增量，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; hget one-more-fans:100 age
&quot;25&quot;
&amp;gt; hincrby one-more-fans:100 age 3
(integer) 28
&amp;gt; hget one-more-fans:100 age
&quot;28&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redis哈希的实现结构，和Java中的HashMap是一样的，也是“数组+链表”的结构，当发生数组位置碰撞是，就会将碰撞的元素用链表串起来。不过Redis为了追求高性能，rehash的方式不太一样，这里先卖个关子，后续的文章会详细介绍。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;位图bitmap&quot;&gt;位图（Bitmap）&lt;/h3&gt;
&lt;p&gt;位图不是实际的数据类型，而是在String类型上定义的一组面向位的操作。 由于字符串是二进制安全的，并且最大长度为512MB，因此可以设置多达2^32个不同的位。位图操作分为两类：固定单个位操作，比如将一个位设置为1或0或获取其值；对位组的操作，比如计算给定位范围内设置位的数量。&lt;/p&gt;
&lt;p&gt;位图的最大优点之一是，它们在存储信息时通常可以节省大量空间。例如，在以增量用户ID位标识表示用户是否要接收新闻通讯，仅使用512 MB内存就可以记住40亿用户的一位信息。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;SETBIT&lt;/code&gt;和&lt;code&gt;GETBIT&lt;/code&gt;命令来设置和获取指定位，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; setbit one-more-key 10 1
(integer) 0
&amp;gt; getbit one-more-key 10
(integer) 1
&amp;gt; getbit one-more-key 11
(integer) 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SETBIT&lt;/code&gt;命令将位号作为其第一个参数，将其设置为1或0的值作为其第二个参数。如果位号超出当前字符串长度，该命令将会自动扩大字符串。&lt;code&gt;GETBIT&lt;/code&gt;命令只是返回指定位号的位的值，如果位号超出存储的字符串长度则会返回0。&lt;/p&gt;
&lt;p&gt;对位组的操作有以下3个命令：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;BITOP&lt;/code&gt;命令可以在不同的字符串之间执行按位运算，提供的位运算有与、或、非和异或。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BITCOUNT&lt;/code&gt;命令可以统计指定范围内位数为1的个数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BITPOS&lt;/code&gt;命令可以查找指定范围内为0或1的第一位。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; set one-more-key &quot;\x13\x7f&quot; #二进制为0001 0011 0111 1111
OK
&amp;gt; bitcount one-more-key #整个字符串中1的位数
(integer) 10
&amp;gt; bitcount one-more-key 0 0 #第一个字符（0001 0011）中1的位数
(integer) 3
&amp;gt; bitcount one-more-key 1 1 #第二个字符（0111 1111）中1的位数
(integer) 7
&amp;gt; bitpos one-more-key 0 #整个字符串中第一个0位
(integer) 0
&amp;gt; bitpos one-more-key 1 #整个字符串中第一个1位
(integer) 3
&amp;gt; bitpos one-more-key 1 0 0 #第一个字符（0001 0011）中第一个1位
(integer) 3
&amp;gt; bitpos one-more-key 1 1 1 #第二个字符（0111 1111）中第一个1位
(integer) 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;位图可以应用于各类实时分析，也可以节省空间高效地存储位信息。比如，记录用户每天的签到数据，每一个位表示用户是否签到过，这样就可以计算出某个时间段用户签到了几次，某个时间段用户第一次签到是哪一天。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;hyperloglogs&quot;&gt;HyperLogLogs&lt;/h3&gt;
&lt;p&gt;HyperLogLog是一种概率数据结构，用于统计唯一元素的数量，也可以理解为估计集合中元素的个数。&lt;/p&gt;
&lt;p&gt;通常情况下，对唯一元素进行统计数量时，需要使用与要统计的元素数量成比例的内存量，因为需要记住过去已经看到的元素，以避免多次对其进行统计。但是，有一组算法可以以内存换取精度，最终会得到带有标准误差的估计数量，在Redis的HyperLogLogs中，该误差小于1％。&lt;/p&gt;
&lt;p&gt;这个算法的神奇之处在于，不再需要使用与所统计元素数量成比例的内存量，而可以使用恒定数量的内存。在最坏的情况下占据12KB的内存空间，Redis对HyperLogLog的存储进行了优化，在计数比较少时，占据的内存空间会更小，这里先卖个关子，后续的文章会详细介绍其中原理。&lt;/p&gt;
&lt;p&gt;在集合中，可以将每个元素添加到集合中，并使用&lt;code&gt;SCARD&lt;/code&gt;命令获取集合中的元素数量，因为&lt;code&gt;SADD&lt;/code&gt;命令不会重新添加现有元素，所以元素都是唯一的。HyperLogLog的操作和集合比较类似，使用&lt;code&gt;PFADD&lt;/code&gt;命令将元素添加到HyperLogLog中，类似于集合的&lt;code&gt;SADD&lt;/code&gt;命令；使用&lt;code&gt;PFCOUNT&lt;/code&gt;命令获取HyperLogLog中的唯一元素的当前近似值数量，类似于集合的&lt;code&gt;SCARD&lt;/code&gt;命令。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; pfadd one-more-hll a b c d e
(integer) 1
&amp;gt; pfcount one-more-hll 
(integer) 5&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Redis中的HyperLogLog尽管在技术上是不同的数据结构，但被编码为字符串，因此可以调用&lt;code&gt;GET&lt;/code&gt;命令来序列化HyperLogLog，然后调用&lt;code&gt;SET&lt;/code&gt;命令来将其反序列化回服务器。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;Redis提供更加丰富的数据结构，&lt;strong&gt;键&lt;/strong&gt;（Key）和&lt;strong&gt;字符串&lt;/strong&gt;（String），都是二进制安全的字符串；&lt;strong&gt;列表&lt;/strong&gt;（List），根据插入顺序排序的字符串元素列表，基于链表实现；&lt;strong&gt;集合&lt;/strong&gt;（Set），唯一的乱序的字符串元素的集合；&lt;strong&gt;有序集合&lt;/strong&gt;（Sorted Set），与&lt;strong&gt;集合&lt;/strong&gt;类似，但是每个字符串元素都与一个称为score的数字相关联；&lt;strong&gt;哈希&lt;/strong&gt;（Hash），由字段与值相关联组成的映射，字段和值都是字符串；&lt;strong&gt;位图&lt;/strong&gt;（Bitmap），像操作位数组一样操作字符串值，可以设置和清除某个位，对所有为1的位进行计数，找到第一个设置1的位，找到第一个设置0的位等等；&lt;strong&gt;HyperLogLogs&lt;/strong&gt;，一种概率数据结构，使用较小的内存空间来统计唯一元素的数量，误差小于1％。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;onemorestudy&quot;&gt;欢迎关注微信公众号：&lt;strong&gt;万猫学社&lt;/strong&gt;，每周一分享Java技术干货。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Jan 2020 00:12:00 +0000</pubDate>
<dc:creator>万猫学社</dc:creator>
<og:description>Redis提供更加丰富的数据结构，如：字符串、列表、集合、有序集合、哈希、位图、HyperLogLogs，你都真正了解嘛？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heihaozi/p/12164700.html</dc:identifier>
</item>
<item>
<title>JAVA8学习——Stream底层的实现三（学习过程） - dawa大娃bigbaby</title>
<link>http://www.cnblogs.com/bigbaby/p/12164699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigbaby/p/12164699.html</guid>
<description>&lt;p&gt;心得：之前学习流，深入了流的底层。但是学的这些东西在平时日常开发的过程中，是根本不会用到的。只是为了更好帮助自己去理解流的底层设施。用起来也更自信，能够确定用的东西非常正确。&lt;/p&gt;
&lt;p&gt;专注技术：这种纯技术的这种环境。&lt;/p&gt;
&lt;p&gt;而不是说：专注业务开发了5年，技术没有长进。&lt;/p&gt;
&lt;p&gt;这位张龙老师给讲课的方式，就是学习一门新技术的过程。如果觉得这种方式学习起来很有效的话。可以使用这种方式去学习一门新的技术。&lt;/p&gt;
&lt;h2 id=&quot;lambda表达式和匿名内部类完全不同&quot;&gt;lambda表达式和匿名内部类完全不同&lt;/h2&gt;
&lt;p&gt;之前虽然学了流了，但是还不太够。我们还缺少了一个能够把一个流从头到尾的执行过程给用起来的过程。&lt;/p&gt;
&lt;p&gt;接下来会完成这个目的&lt;/p&gt;
&lt;p&gt;用程序入门。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LambdaTest {
    //内部类和lambda表达式到底有什么关系
    Runnable r1 = () -&amp;gt; System.out.println(this);

    //匿名内部类 - 标识我生成了一个Runnable的实例 . 是一个类
    Runnable r2 = new Runnable() {
        @Override
        public void run() {
            System.out.println(this);
        }
    };

    public static void main(String[] args) {
        LambdaTest lambdaTest = new LambdaTest();
        Thread t1 = new Thread(lambdaTest.r1);
        t1.start();

        System.out.println(&quot;-------------&quot;);
        Thread t2 = new Thread(lambdaTest.r2);
        t2.start();
        //请问，输出结果一样吗？
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;-------------
com.dawa.jdk8.LambdaTest@59a30351   (lambda表达式的结果)
com.dawa.jdk8.LambdaTest$1@2831008d  (匿名内部类的结果)

Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LambdaTest$1&lt;/code&gt;， 这个1就是匿名内部类的类名。 （匿名内部类的名字）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经过对比，虽然说 lambda是匿名内部类的不同实现，但是 他们两个是完全一样的。原理不同。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结论：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;匿名内部类会开辟一个新的作用域&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lambda是不会开辟新的作用域的&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里普及这个知识点，是为了以后在Debug的时候会发现 匿名内部类和lambda表达式的类名不同、&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;系统的去走一遍stream的执行流程&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StreamTest3 {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;welcome&quot;);
        list.stream().map(item-&amp;gt;item+&quot;_abc&quot;).forEach(System.out::println);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;map（）实现&lt;/p&gt;
&lt;p&gt;返回值为&lt;code&gt;StatelessOp&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public final &amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super P_OUT, ? extends R&amp;gt; mapper) {
        Objects.requireNonNull(mapper);
        return new StatelessOp&amp;lt;P_OUT, R&amp;gt;(this, StreamShape.REFERENCE,
                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
            @Override
            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;R&amp;gt; sink) {
                return new Sink.ChainedReference&amp;lt;P_OUT, R&amp;gt;(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        downstream.accept(mapper.apply(u));
                    }
                };
            }
        };
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//StatelessOp类的定义和构造方法
    /**
     * Base class for a stateless intermediate stage of a Stream.
     *
     * @param &amp;lt;E_IN&amp;gt; type of elements in the upstream source
     * @param &amp;lt;E_OUT&amp;gt; type of elements in produced by this stage
     * @since 1.8
     */
abstract static class StatelessOp&amp;lt;E_IN, E_OUT&amp;gt;
            extends ReferencePipeline&amp;lt;E_IN, E_OUT&amp;gt; {
        /**
         * Construct a new Stream by appending a stateless intermediate
         * operation to an existing stream.
         *
         * @param upstream The upstream pipeline stage
         * @param inputShape The stream shape for the upstream pipeline stage
         * @param opFlags Operation flags for the new stage
         */
        StatelessOp(AbstractPipeline&amp;lt;?, E_IN, ?&amp;gt; upstream,
                    StreamShape inputShape,
                    int opFlags) {
            super(upstream, opFlags);
            assert upstream.getOutputShape() == inputShape;
        }

        @Override
        final boolean opIsStateful() {
            return false;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;StatelessOp&lt;/code&gt;继承&lt;code&gt;ReferencePipeline&lt;/code&gt;，而&lt;code&gt;ReferencePipeline&lt;/code&gt;实现了&lt;code&gt;Stream&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;所以map方法返回&lt;code&gt;new StatelessOp&amp;lt;P_OUT, R&amp;gt;&lt;/code&gt;就等于返回了一个&lt;code&gt;Stream&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回的是继承了&lt;code&gt;StatelessOp&lt;/code&gt;的子类的对象。完成了上游和下游流的互通.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reference Pipeline&lt;/strong&gt; 无非就是一个双向链表&lt;/p&gt;
&lt;p&gt;操作包装：map（）方法中的 opWrapSink（）的ChainedReference，实现了流的包装操作。把剩下的流给warp到一起&lt;/p&gt;
&lt;p&gt;然后就一个元素，同时经过了剩下的方法操作。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
            Sink&amp;lt;P_OUT&amp;gt; opWrapSink(int flags, Sink&amp;lt;R&amp;gt; sink) {
                return new Sink.ChainedReference&amp;lt;P_OUT, R&amp;gt;(sink) {
                    @Override
                    public void accept(P_OUT u) {
                        downstream.accept(mapper.apply(u));
                    }
                };
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; Sink 类
 * &amp;lt;p&amp;gt;A sink may be in one of two states: an initial state and an active state.
 * It starts out in the initial state; the {@code begin()} method transitions
 * it to the active state, and the {@code end()} method transitions it back into
 * the initial state, where it can be re-used.  Data-accepting methods (such as
 * {@code accept()} are only valid in the active state.
 *&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ChainedReference（）链接引用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * Abstract {@code Sink} implementation for creating chains of
     * sinks.  The {@code begin}, {@code end}, and
     * {@code cancellationRequested} methods are wired to chain to the
     * downstream {@code Sink}.  This implementation takes a downstream
     * {@code Sink} of unknown input shape and produces a {@code Sink&amp;lt;T&amp;gt;}.  The
     * implementation of the {@code accept()} method must call the correct
     * {@code accept()} method on the downstream {@code Sink}.
     */
    static abstract class ChainedReference&amp;lt;T, E_OUT&amp;gt; implements Sink&amp;lt;T&amp;gt; {
        protected final Sink&amp;lt;? super E_OUT&amp;gt; downstream;

        public ChainedReference(Sink&amp;lt;? super E_OUT&amp;gt; downstream) {
            this.downstream = Objects.requireNonNull(downstream);
        }

        @Override
        public void begin(long size) {
            downstream.begin(size);
        }

        @Override
        public void end() {
            downstream.end();
        }

        @Override
        public boolean cancellationRequested() {
            return downstream.cancellationRequested();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sink类中的end（），和 begin（）方法，切换两种状态：1.初始状态 2.激活状态&lt;/p&gt;
&lt;p&gt;每一次accept（）方法执行之前，需要调用Sink中的begin（）方法，进入激活状态，执行完毕之后调用end()方法，进入初始状态。&lt;/p&gt;
&lt;p&gt;涉及设计模式：模板方法模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;opWrapSink（）&lt;/strong&gt; 的上级实现：&lt;/p&gt;
&lt;p&gt;接受了一个Sink对象，这个对象接受了操作的结果，并且返回了一个Sink，还会执行这个操作，并将这个结果传递给所提供的sink。 *（输入参数才是带结果的sinK）&lt;br/&gt;正是因为这种操作，才能将sink给包装起来。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * Accepts a {@code Sink} which will receive the results of this operation,
     * and return a {@code Sink} which accepts elements of the input type of
     * this operation and which performs the operation, passing the results to
     * the provided {@code Sink}.
     接受了一个Sink对象，这个对象接受了操作的结果，并且返回了一个Sink，还会执行这个操作，并将这个结果传递给所提供的sink。  *（输入参数才是带结果的sinK）
     正式因为这种操作，才能将sink给包装起来。
     *
     * @apiNote
     * The implementation may use the {@code flags} parameter to optimize the
     * sink wrapping.  For example, if the input is already {@code DISTINCT},
     * the implementation for the {@code Stream#distinct()} method could just
     * return the sink it was passed.
     *
     * @param flags The combined stream and operation flags up to, but not
     *        including, this operation
     
     * @param sink sink to which elements should be sent after processing
     * @return a sink which accepts elements, perform the operation upon
     *         each element, and passes the results (if any) to the provided
     *         {@code Sink}.
     参数本身是用来接收结果的，而不是用返回值来返回结果的。
     */
    abstract Sink&amp;lt;E_IN&amp;gt; opWrapSink(int flags, Sink&amp;lt;E_OUT&amp;gt; sink);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        @Override
        final Sink&amp;lt;E_IN&amp;gt; opWrapSink(int flags, Sink&amp;lt;E_OUT&amp;gt; sink) {
            throw new UnsupportedOperationException();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;流的特性：惰性求值和延迟求值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;map()方法，包括其他的peek(),filter()等等中间操作的这些方法。只是完成了返回了一个StatelessOp对象。&lt;/p&gt;
&lt;p&gt;所以中间操作返回一个终止对象可能执行的StatelessOp，没有终止操作，所以流不会被处理。&lt;/p&gt;
&lt;p&gt;那么终止操作。我们要去追一下了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;拿代码中写的 forEach（）方法开始去追&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // Terminal operations from Stream

    @Override
    public void forEach(Consumer&amp;lt;? super P_OUT&amp;gt; action) {
        evaluate(ForEachOps.makeRef(action, false));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是调用了makeRef()方法.方法在ForEachOps类中.&lt;/p&gt;
&lt;p&gt;先看ForEachOps类的javadoc&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Factory for creating instances of {@code TerminalOp} that perform an
 * action for every element of a stream.  Supported variants include unordered
 * traversal (elements are provided to the {@code Consumer} as soon as they are
 * available), and ordered traversal (elements are provided to the
 * {@code Consumer} in encounter order.)
 这是一个工厂，用来创建 TerminalOp 对象，（终止操作。）这个对象会对每一个元素执行一个动作。
 所支持的变化包括：无序的遍历，有序的遍历（按照所提供的的顺序来遍历）。
 *
 * &amp;lt;p&amp;gt;Elements are provided to the {@code Consumer} on whatever thread and
 * whatever order they become available.  For ordered traversals, it is
 * guaranteed that processing an element &amp;lt;em&amp;gt;happens-before&amp;lt;/em&amp;gt; processing
 * subsequent elements in the encounter order.
 元素被提供被一个任何可用的Consumer队形。
 处理一个元素，一定是发生在 另外一件事之前 (happens-before)。
也就事 先遇到的元素先处理，后遇到的元素后处理。
 
 *
 * &amp;lt;p&amp;gt;Exceptions occurring as a result of sending an element to the
 * {@code Consumer} will be relayed to the caller and traversal will be
 * prematurely terminated.
 提供了大量的  静态方法。
 *
 * @since 1.8
 */
final class ForEachOps {
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如makeRef()&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   /**
     * Constructs a {@code TerminalOp} that perform an action for every element
     * of a stream.
     *
     * @param action the {@code Consumer} that receives all elements of a
     *        stream
     * @param ordered whether an ordered traversal is requested
     * @param &amp;lt;T&amp;gt; the type of the stream elements
     * @return the {@code TerminalOp} instance
     */
    public static &amp;lt;T&amp;gt; TerminalOp&amp;lt;T, Void&amp;gt; makeRef(Consumer&amp;lt;? super T&amp;gt; action,
                                                  boolean ordered) {
        Objects.requireNonNull(action);
        return new ForEachOp.OfRef&amp;lt;&amp;gt;(action, ordered);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TerminalOp说明&lt;/p&gt;
&lt;p&gt;默认执行的是串行的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * An operation in a stream pipeline that takes a stream as input and produces
 * a result or side-effect.  A {@code TerminalOp} has an input type and stream
 * shape, and a result type.  A {@code TerminalOp} also has a set of
 * &amp;lt;em&amp;gt;operation flags&amp;lt;/em&amp;gt; that describes how the operation processes elements
 * of the stream (such as short-circuiting or respecting encounter order; see
 * {@link StreamOpFlag}).
 流管道中的一个操作。会接受一个流作为输入，  产生的结果，是有副作用的（副作用：你传递了一个引用，你修改了这个引用）。
 一个 TerminalOp 会有一个输入类型，和流的shape 和一个结果类型。
 TerminalOp 还会有一个 如何处理流中的元素  的标识。
 TerminalOp 必须要提供一种 串行的和并行的 实现。
 
 *
 * &amp;lt;p&amp;gt;A {@code TerminalOp} must provide a sequential and parallel implementation
 * of the operation relative to a given stream source and set of intermediate
 * operations.
 *
 * @param &amp;lt;E_IN&amp;gt; the type of input elements
 * @param &amp;lt;R&amp;gt;    the type of the result
 * @since 1.8
 */
interface TerminalOp&amp;lt;E_IN, R&amp;gt; {
        /**
     * Gets the shape of the input type of this operation.
     *
     * @implSpec The default returns {@code StreamShape.REFERENCE}.
     *
     * @return StreamShape of the input type of this operation
     */
    default StreamShape inputShape() { return StreamShape.REFERENCE; }

    /**
     * Gets the stream flags of the operation.  Terminal operations may set a
     * limited subset of the stream flags defined in {@link StreamOpFlag}, and
     * these flags are combined with the previously combined stream and
     * intermediate operation flags for the pipeline.
     *
     * @implSpec The default implementation returns zero.
     *
     * @return the stream flags for this operation
     * @see StreamOpFlag
     */
    default int getOpFlags() { return 0; }

    /**
     * Performs a parallel evaluation of the operation using the specified
     * {@code PipelineHelper}, which describes the upstream intermediate
     * operations.
     *
     * @implSpec The default performs a sequential evaluation of the operation
     * using the specified {@code PipelineHelper}.
     *
     * @param helper the pipeline helper
     * @param spliterator the source spliterator
     * @return the result of the evaluation
     */
    default &amp;lt;P_IN&amp;gt; R evaluateParallel(PipelineHelper&amp;lt;E_IN&amp;gt; helper,
                                      Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
        if (Tripwire.ENABLED)
            Tripwire.trip(getClass(), &quot;{0} triggering TerminalOp.evaluateParallel serial default&quot;);
        return evaluateSequential(helper, spliterator);
    }

    /**
     * Performs a sequential evaluation of the operation using the specified
     * {@code PipelineHelper}, which describes the upstream intermediate
     * operations.
     *
     * @param helper the pipeline helper
     * @param spliterator the source spliterator
     * @return the result of the evaluation
     */
    &amp;lt;P_IN&amp;gt; R evaluateSequential(PipelineHelper&amp;lt;E_IN&amp;gt; helper,
                                Spliterator&amp;lt;P_IN&amp;gt; spliterator);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;终止操作的实现就4类：&lt;/p&gt;
&lt;p&gt;1.find&lt;/p&gt;
&lt;p&gt;2.match&lt;/p&gt;
&lt;p&gt;3.forEach 遍历&lt;/p&gt;
&lt;p&gt;4.reduce&lt;/p&gt;
&lt;p&gt;返回去： forEach（）操作就是返回了一个终止操作对象。&lt;/p&gt;
&lt;p&gt;然后：evaluate（）方法， 执行那个终止操作对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
    // Terminal evaluation methods

    /**
     * Evaluate the pipeline with a terminal operation to produce a result.
     *
     * @param &amp;lt;R&amp;gt; the type of result
     * @param terminalOp the terminal operation to be applied to the pipeline.
     * @return the result
     */
final &amp;lt;R&amp;gt; R evaluate(TerminalOp&amp;lt;E_OUT, R&amp;gt; terminalOp) {
        assert getOutputShape() == terminalOp.inputShape();
        if (linkedOrConsumed)
            throw new IllegalStateException(MSG_STREAM_LINKED);
        linkedOrConsumed = true;

        return isParallel()
               ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
               : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;PipelineHelper类&lt;/p&gt;
&lt;p&gt;用来描述流的各种信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Helper class for executing &amp;lt;a href=&quot;package-summary.html#StreamOps&quot;&amp;gt;
 * stream pipelines&amp;lt;/a&amp;gt;, capturing all of the information about a stream
 * pipeline (output shape, intermediate operations, stream flags, parallelism,
 * etc) in one place.
 Helper是一个帮助类，用于执行流管道
 包含流管道的所有信息：源数据。输出类型，操作，流标识，并行标记等。
 
 *
 * &amp;lt;p&amp;gt;
 * A {@code PipelineHelper} describes the initial segment of a stream pipeline,
 * including its source, intermediate operations, and may additionally
 * incorporate information about the terminal (or stateful) operation which
 * follows the last intermediate operation described by this
 * {@code PipelineHelper}. The {@code PipelineHelper} is passed to the
 * {@link TerminalOp#evaluateParallel(PipelineHelper, java.util.Spliterator)},
 * {@link TerminalOp#evaluateSequential(PipelineHelper, java.util.Spliterator)},
 * and {@link AbstractPipeline#opEvaluateParallel(PipelineHelper, java.util.Spliterator,
 * java.util.function.IntFunction)}, methods, which can use the
 * {@code PipelineHelper} to access information about the pipeline such as
 * head shape, stream flags, and size, and use the helper methods
 * such as {@link #wrapAndCopyInto(Sink, Spliterator)},
 * {@link #copyInto(Sink, Spliterator)}, and {@link #wrapSink(Sink)} to execute
 * pipeline operations..
 一个流管道的最初的分块，包含源，中间操作和增加的操作。等
 
 PipelineHelper会被传递给。。。。 方法， 就可以通过PipelineHelper来访问管道的各种信息。
 
 *
 * @param &amp;lt;P_OUT&amp;gt; type of output elements from the pipeline
 * @since 1.8
 */
abstract class PipelineHelper&amp;lt;P_OUT&amp;gt; {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PipelineHelper类里的方法：wrapAndCopyInto()&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   /**
     * Applies the pipeline stages described by this {@code PipelineHelper} to
     * the provided {@code Spliterator} and send the results to the provided
     * {@code Sink}.
     将调用了这个方法的pipeline所描述的管道的各个阶段，同时 应用到Spliterator和发送给Sink对象
     *
     * @implSpec
     * The implementation behaves as if:
     * &amp;lt;pre&amp;gt;{@code
     *     intoWrapped(wrapSink(sink), spliterator);
     * }&amp;lt;/pre&amp;gt;
     *
     * @param sink the {@code Sink} to receive the results
     * @param spliterator the spliterator describing the source input to process
     */
    abstract&amp;lt;P_IN, S extends Sink&amp;lt;P_OUT&amp;gt;&amp;gt; S wrapAndCopyInto(S sink, Spliterator&amp;lt;P_IN&amp;gt; spliterator);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wrapAndCopyInto具体实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    final &amp;lt;P_IN, S extends Sink&amp;lt;E_OUT&amp;gt;&amp;gt; S wrapAndCopyInto(S sink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
        copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);
        return sink;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Sink中的wrapSink（）方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * Takes a {@code Sink} that accepts elements of the output type of the
     * {@code PipelineHelper}, and wrap it with a {@code Sink} that accepts
     * elements of the input type and implements all the intermediate operations
     * described by this {@code PipelineHelper}, delivering the result into the
     * provided {@code Sink}.
     接受了一个Sink， Sink接受了PipelineHelper的所有输出类型。
     
     *
     * @param sink the {@code Sink} to receive the results
     * @return a {@code Sink} that implements the pipeline stages and sends
     *         results to the provided {@code Sink}
     */
    abstract&amp;lt;P_IN&amp;gt; Sink&amp;lt;P_IN&amp;gt; wrapSink(Sink&amp;lt;P_OUT&amp;gt; sink);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wrapSink（）方法具体实现 &lt;strong&gt;（完成了对于多个流操作的串联。）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    final &amp;lt;P_IN&amp;gt; Sink&amp;lt;P_IN&amp;gt; wrapSink(Sink&amp;lt;E_OUT&amp;gt; sink) {
        Objects.requireNonNull(sink);

        //根据depth判断是否有中间操作。 从后往前的去走。
        for ( @SuppressWarnings(&quot;rawtypes&quot;) AbstractPipeline p=AbstractPipeline.this; p.depth &amp;gt; 0; p=p.previousStage) {
            sink = p.opWrapSink(p.previousStage.combinedFlags, sink);
        }
        return (Sink&amp;lt;P_IN&amp;gt;) sink;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wrapSink（）&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;自我总结stream的执行流程&quot;&gt;自我总结：Stream的执行流程。&lt;/h2&gt;
&lt;p&gt;源数据-中间操作-中间操作-终止操作&lt;/p&gt;
&lt;p&gt;1.串联起来所有的操作。（中间操作 和 终止操作）&lt;/p&gt;
&lt;p&gt;2.让流中的元素，一个一个的执行所含有的所有操作。&lt;/p&gt;
&lt;p&gt;最核心的方法：copyInto()中的：spliterator.forEachRemaining(wrappedSink); //最最核心的一步&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; @Override
    final &amp;lt;P_IN&amp;gt; void copyInto(Sink&amp;lt;P_IN&amp;gt; wrappedSink, Spliterator&amp;lt;P_IN&amp;gt; spliterator) {
        Objects.requireNonNull(wrappedSink);

        if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) {
            wrappedSink.begin(spliterator.getExactSizeIfKnown());
            spliterator.forEachRemaining(wrappedSink); //最最核心的一步
            wrappedSink.end();
        }
        else {
            copyIntoWithCancel(wrappedSink, spliterator);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wrappedSink : 所有的中间操作，封装到了这个 sink对象&lt;/p&gt;
&lt;p&gt;spliterator：源数据- 执行forEachRemaining 遍历，执行每一次这过sink对象封装的操作。&lt;/p&gt;
&lt;p&gt;上面是静态分析（通过源码分析）&lt;/p&gt;
&lt;p&gt;自行通过动态分析（程序Debug分析）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;t通过Debug去跟一遍代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StreamTest3 {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list = Arrays.asList(&quot;hello&quot;, &quot;world&quot;, &quot;welcome&quot;);
//        list.stream().map(item-&amp;gt;item+&quot;_abc&quot;).forEach(System.out::println);

        Stream&amp;lt;String&amp;gt; stream = list.stream(); 
        System.out.println(&quot;1&quot;);//断点
        Stream&amp;lt;String&amp;gt; stream1 = stream.map(item -&amp;gt; item + &quot;_abc&quot;);
        System.out.println(&quot;2&quot;);//断点
        stream1.forEach(System.out::println);
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 08 Jan 2020 00:11:00 +0000</pubDate>
<dc:creator>dawa大娃bigbaby</dc:creator>
<og:description>Stream的深入（三） 心得：之前学习流，深入了流的底层。但是学的这些东西在平时日常开发的过程中，是根本不会用到的。只是为了更好帮助自己去理解流的底层设施。用起来也更自信，能够确定用的东西非常正确。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigbaby/p/12164699.html</dc:identifier>
</item>
<item>
<title>【原创】（十五）Linux内存管理之RMAP - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/12164683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/12164683.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Kernel版本：4.14&lt;/li&gt;
&lt;li&gt;ARM64处理器，Contex-A53，双核&lt;/li&gt;
&lt;li&gt;使用工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;RMAP反向映射&lt;/code&gt;是一种物理地址反向映射虚拟地址的方法。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;映射&lt;br/&gt;页表用于虚拟地址到物理地址映射，其中的&lt;code&gt;PTE&lt;/code&gt;页表项记录了映射关系，同时&lt;code&gt;struct page&lt;/code&gt;结构体中的&lt;code&gt;mapcount&lt;/code&gt;字段保存了有多少&lt;code&gt;PTE&lt;/code&gt;页表项映射了该物理页。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;反向映射&lt;br/&gt;当某个物理地址要进行回收或迁移时，此时需要去找到有多少虚拟地址射在该物理地址，并断开映射处理。在没有反向映射的机制时，需要去遍历进程的页表，这个效率显然是很低下的。反向映射可以找到虚拟地址空间&lt;code&gt;VMA&lt;/code&gt;，并仅从&lt;code&gt;VMA&lt;/code&gt;使用的用户页表中取消映射，可以快速解决这个问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072125306-655765057.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反向映射的典型应用场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;kswapd&lt;/code&gt;进行页面回收时，需要断开所有映射了该匿名页面的PTE表项；&lt;/li&gt;
&lt;li&gt;页面迁移时，需要断开所有映射了该匿名页面的PTE表项；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;反向映射有三个关键的结构体：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;struct vm_area_struct&lt;/code&gt;，简称&lt;code&gt;VMA&lt;/code&gt;;&lt;br/&gt;&lt;code&gt;VMA&lt;/code&gt;我们在之前的文章中介绍过，用于描述进程地址空间中的一段区域。与反向映射相关的字段如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct vm_area_struct {
...
/*
     * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma
     * list, after a COW of one of the file pages.  A MAP_SHARED vma
     * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack
     * or brk vma (with NULL file) can only be in an anon_vma list.
     */
    struct list_head anon_vma_chain; /* Serialized by mmap_sem &amp;amp;
                      * page_table_lock */
    struct anon_vma *anon_vma;  /* Serialized by page_table_lock */
...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;struct anon_vma&lt;/code&gt;，简称&lt;code&gt;AV&lt;/code&gt;;&lt;br/&gt;&lt;code&gt;AV&lt;/code&gt;结构用于管理匿名类型&lt;code&gt;VMAs&lt;/code&gt;，当有匿名页需要&lt;code&gt;unmap&lt;/code&gt;处理时，可以先找到&lt;code&gt;AV&lt;/code&gt;，然后再通过&lt;code&gt;AV&lt;/code&gt;进行查找处理。结构如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;/*
 * The anon_vma heads a list of private &quot;related&quot; vmas, to scan if
 * an anonymous page pointing to this anon_vma needs to be unmapped:
 * the vmas on the list will be related by forking, or by splitting.
 *
 * Since vmas come and go as they are split and merged (particularly
 * in mprotect), the mapping field of an anonymous page cannot point
 * directly to a vma: instead it points to an anon_vma, on whose list
 * the related vmas can be easily linked or unlinked.
 *
 * After unlinking the last vma on the list, we must garbage collect
 * the anon_vma object itself: we're guaranteed no page can be
 * pointing to this anon_vma once its vma list is empty.
 */
struct anon_vma {
    struct anon_vma *root;      /* Root of this anon_vma tree */
    struct rw_semaphore rwsem;  /* W: modification, R: walking the list */
    /*
     * The refcount is taken on an anon_vma when there is no
     * guarantee that the vma of page tables will exist for
     * the duration of the operation. A caller that takes
     * the reference is responsible for clearing up the
     * anon_vma if they are the last user on release
     */
    atomic_t refcount;

    /*
     * Count of child anon_vmas and VMAs which points to this anon_vma.
     *
     * This counter is used for making decision about reusing anon_vma
     * instead of forking new one. See comments in function anon_vma_clone.
     */
    unsigned degree;

    struct anon_vma *parent;    /* Parent of this anon_vma */

    /*
     * NOTE: the LSB of the rb_root.rb_node is set by
     * mm_take_all_locks() _after_ taking the above lock. So the
     * rb_root must only be read/written after taking the above lock
     * to be sure to see a valid next pointer. The LSB bit itself
     * is serialized by a system wide lock only visible to
     * mm_take_all_locks() (mm_all_locks_mutex).
     */

    /* Interval tree of private &quot;related&quot; vmas */
    struct rb_root_cached rb_root;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;struct anon_vma_chain&lt;/code&gt;，简称&lt;code&gt;AVC&lt;/code&gt;;&lt;br/&gt;&lt;code&gt;AVC&lt;/code&gt;是连接&lt;code&gt;VMA&lt;/code&gt;和&lt;code&gt;AV&lt;/code&gt;之间的桥梁。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;/*
 * The copy-on-write semantics of fork mean that an anon_vma
 * can become associated with multiple processes. Furthermore,
 * each child process will have its own anon_vma, where new
 * pages for that process are instantiated.
 *
 * This structure allows us to find the anon_vmas associated
 * with a VMA, or the VMAs associated with an anon_vma.
 * The &quot;same_vma&quot; list contains the anon_vma_chains linking
 * all the anon_vmas associated with this VMA.
 * The &quot;rb&quot; field indexes on an interval tree the anon_vma_chains
 * which link all the VMAs associated with this anon_vma.
 */
struct anon_vma_chain {
    struct vm_area_struct *vma;
    struct anon_vma *anon_vma;
    struct list_head same_vma;   /* locked by mmap_sem &amp;amp; page_table_lock */
    struct rb_node rb;          /* locked by anon_vma-&amp;gt;rwsem */
    unsigned long rb_subtree_last;
#ifdef CONFIG_DEBUG_VM_RB
    unsigned long cached_vma_start, cached_vma_last;
#endif
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来一张图就清晰明了了：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072200806-1580650219.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;same_vma&lt;/code&gt;链表节点，将&lt;code&gt;anon_vma_chain&lt;/code&gt;添加到&lt;code&gt;vma-&amp;gt;anon_vma_chain&lt;/code&gt;链表中；&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;rb&lt;/code&gt;红黑树节点，将&lt;code&gt;anon_vma_chain&lt;/code&gt;添加到&lt;code&gt;anon_vma-&amp;gt;rb_root&lt;/code&gt;的红黑树中；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先看一下宏观的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072227687-242824885.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;地址空间&lt;code&gt;VMA&lt;/code&gt;可以通过页表完成虚拟地址到物理地址的映射；&lt;/li&gt;
&lt;li&gt;页框与&lt;code&gt;page&lt;/code&gt;结构对应，&lt;code&gt;page&lt;/code&gt;结构中的&lt;code&gt;mapping&lt;/code&gt;字段指向&lt;code&gt;anon_vma&lt;/code&gt;，从而可以通过&lt;code&gt;RMAP&lt;/code&gt;机制去找到与之关联的&lt;code&gt;VMA&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;anon_vma_prepare&quot;&gt;2.1 &lt;code&gt;anon_vma_prepare&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;之前在&lt;code&gt;page fault&lt;/code&gt;的文章中，提到过&lt;code&gt;anon_vma_prepare&lt;/code&gt;函数，这个函数完成的工作就是为进程地址空间中的&lt;code&gt;VMA&lt;/code&gt;准备&lt;code&gt;struct anon_vma&lt;/code&gt;结构。&lt;/p&gt;
&lt;p&gt;调用例程及函数流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072245927-1661167663.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于&lt;code&gt;VMA，AV，AVC&lt;/code&gt;三者之间的关联关系，在上文的图中已经有所描述。&lt;/p&gt;
&lt;p&gt;当创建了与&lt;code&gt;VMA&lt;/code&gt;关联的&lt;code&gt;AV&lt;/code&gt;后，还有关键的一步需要做完，才能算是真正的把&lt;code&gt;RMAP&lt;/code&gt;通路打通，那就是让&lt;code&gt;page&lt;/code&gt;与&lt;code&gt;AV&lt;/code&gt;关联起来。只有这样才能通过&lt;code&gt;page&lt;/code&gt;找到&lt;code&gt;AV&lt;/code&gt;，进而找到&lt;code&gt;VMA&lt;/code&gt;，从而完成对应的&lt;code&gt;PTE unmap&lt;/code&gt;操作。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072341714-741985817.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;子进程创建anon_vma&quot;&gt;2.2 子进程创建&lt;code&gt;anon_vma&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;父进程通过&lt;code&gt;fork()&lt;/code&gt;来创建子进程，子进程会复制整个父进程的地址空间及页表。子进程拷贝了父进程的&lt;code&gt;VMA&lt;/code&gt;数据结构内容，而子进程创建相应的&lt;code&gt;anon_vma&lt;/code&gt;结构，是通过&lt;code&gt;anon_vma_fork()&lt;/code&gt;函数来实现的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;anon_vma_fork()&lt;/code&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072403988-1994558264.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以实际&lt;code&gt;fork()&lt;/code&gt;两次为例，发生&lt;code&gt;COW&lt;/code&gt;之后，看看三个进程的链接关系，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072418968-1780160966.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ttutry-to-unmap和rmap-walk&quot;&gt;2.3 &lt;code&gt;TTU（try to unmap）&lt;/code&gt;和&lt;code&gt;Rmap Walk&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;如果有&lt;code&gt;page&lt;/code&gt;被映射到多个虚拟地址，可以通过&lt;code&gt;Rmap Walk机制&lt;/code&gt;来遍历所有的&lt;code&gt;VMA&lt;/code&gt;，并最终调用回调函数来取消映射。&lt;/p&gt;
&lt;p&gt;与之相关的结构体为&lt;code&gt;struct rmap_walk_control&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;/*
 * rmap_walk_control: To control rmap traversing for specific needs
 *
 * arg: passed to rmap_one() and invalid_vma()
 * rmap_one: executed on each vma where page is mapped
 * done: for checking traversing termination condition
 * anon_lock: for getting anon_lock by optimized way rather than default
 * invalid_vma: for skipping uninterested vma
 */
struct rmap_walk_control {
    void *arg;
    /*
     * Return false if page table scanning in rmap_walk should be stopped.
     * Otherwise, return true.
     */
    bool (*rmap_one)(struct page *page, struct vm_area_struct *vma,
                    unsigned long addr, void *arg);
    int (*done)(struct page *page);
    struct anon_vma *(*anon_lock)(struct page *page);
    bool (*invalid_vma)(struct vm_area_struct *vma, void *arg);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072439659-1368899682.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;取消映射的入口为&lt;code&gt;try_to_unmap&lt;/code&gt;，流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072504817-1230865870.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本的套路就是围绕着&lt;code&gt;struct rmap_walk_control&lt;/code&gt;结构，初始化回调函数，以便在适当的时候能调用到。&lt;/p&gt;
&lt;p&gt;关于取消映射&lt;code&gt;try_to_unmap_one&lt;/code&gt;的详细细节就不进一步深入了，把握好大体框架即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/202001/1771657-20200108072524210-1840144447.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jan 2020 23:28:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背景 By 鲁迅 By 高尔基 说明： 1. Kernel版本：4.14 2. ARM64处理器，Contex A53，双核 3. 使用工具：Source Insight 3.5， Visio 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/12164683.html</dc:identifier>
</item>
<item>
<title>SpringBoot 2.X整合Mybatis - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/12164679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/12164679.html</guid>
<description>&lt;h2 id=&quot;创建工程环境&quot;&gt;1、创建工程环境&lt;/h2&gt;
&lt;p&gt;勾选Web、Mybatis、MySQL，如下&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020010716425519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;依赖如下&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.1.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建完成之后注意，MyBatis依赖的命名和其他库的命名不太一样，是的这个整合jar包并不是springboot自己的，这表示该starter是由第三方提供的，就像&lt;code&gt;Druid&lt;/code&gt;数据源一样，也是第三方的。&lt;/p&gt;
&lt;p&gt;方便阅读，先贴出下面操作编写的类位置信息，如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107200733721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置数据库连接信息&quot;&gt;2、配置数据库连接信息&lt;/h2&gt;
&lt;p&gt;这里使用yml方式&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;spring:
  datasource:
    username: root
    url: jdbc:mysql://localhost:3306/ufida?serverTimezone=UTC
    password: 123456
    driver-class-name: com.mysql.jdbc.Driver
#如果要使用Druid数据源就要导入相应jar包，当然也可以不指定type
    type: com.alibaba.druid.pool.DruidDataSource&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完成后，MyBatis就可以创建实体类来使用。&lt;/p&gt;
&lt;h2 id=&quot;编写实体类&quot;&gt;3、编写实体类&lt;/h2&gt;
&lt;p&gt;实体类：dao包下的Userdao&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public class Userdao {
    private int user_id;
    private String userName;
    private String passWord;
    private int usertypeid;

    getXXX...
    setXXX...
    toString...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写mapper接口类&quot;&gt;4、编写Mapper接口类&lt;/h2&gt;
&lt;p&gt;Mapper接口类：mapper包下的UserMapper&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Mapper
@Repository   
public interface UserMapper {
   //只是整合测试，为了可读性，只写了一个方法
    List&amp;lt;Userdao&amp;gt; queryUserList();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里要注意一下@Mapper注解，@Mapper注解添加位置在接口类上面它的作用是在编译之后会生成相应的接口实现类，这种方法也是官方推荐使用的！这里只是测试整合mybatis编写一个Mapper接口即可，如果有需求要很多接口都要变成实现类，那么需要在每个接口类上加上@Mapper注解，比较麻烦，解决这个问题用@MapperScan注解。简单点说@MapperScan注解就相当于直接扫描指定包，上面的代码所在包是&lt;code&gt;com.yichunnnn.jdbcboot.mapper&lt;/code&gt;包下，如果要用@MapperScan注解，就相当于如下即可&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@MapperScan(&quot;com.yichunnnn.jdbcboot.mapper&quot;)  //相当于@Mapper
@SpringBootApplication
public class JdbcbootApplication {
    public static void main(String[] args) {
        SpringApplication.run(JdbcbootApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写mapper映射文件&quot;&gt;5、编写Mapper映射文件&lt;/h2&gt;
&lt;p&gt;Mapper映射文件编写的位置以及名字为：&lt;code&gt;classpath:mybatis/mapper/UserMapper.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;

&amp;lt;mapper namespace=&quot;com.yichunnnn.jdbcboot.mapper.UserMapper&quot;&amp;gt;

    &amp;lt;select id=&quot;queryUserList&quot; resultType=&quot;Userdao&quot;&amp;gt;
        select * from user
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;考虑到可读性，这里只编写一个查询的方法，同时特别注意&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107171958407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;只要错了一处都会报错！&lt;/p&gt;
&lt;h2 id=&quot;springboot-整合mybatis&quot;&gt;6、SpringBoot 整合Mybatis&lt;/h2&gt;
&lt;p&gt;实际上Mybatis的整合过程像极了我们程序员的一生。&lt;/p&gt;
&lt;p&gt;在SpringBoot 整合Mybatis之前，我们回忆回忆以前 MyBatis 单独使用时，myBatis 核心配置文件要配置数据源、事务、连接数据库账号、密码....是的全是这货一个人干，都要亲力亲为。这就是我们的低谷期&lt;/p&gt;
&lt;p&gt;myBatis 与 spring 整合的时候，配置数据源、事务、连接数据库的账号什么的都交由 spring 管理就行，就不用什么都自己管理自己去干。这就是我们春风得意的时候，事业有着落...&lt;/p&gt;
&lt;p&gt;再后来，SpringBoot 整合Mybatis的时候，数据源什么的，springboot都默认准备好了，甚至不使用mybatis配置文件也没问题，如果我们自己已经编写了 myBatis 的映射配置文件，则只要告诉 spring boot 这些文件的位置的好了，如下（yml写法），这简直是事业有成，迎娶白富美，走上人生巅峰...&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;#整合Mybatis   #指定myBatis的核心配置文件与Mapper映射文件
mybatis:
  mapper-locations: classpath:mybatis/mapper/*.xml&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;#注意：对应实体类的路径
  type-aliases-package: com.yichunnnn.jdbcboot.dao&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107195730563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;故事是美好的，然而事实却是骨感的.....&lt;/p&gt;
&lt;p&gt;最后的配置文件也就如上图效果所示，如果需要完全理解配置文件可以从 &lt;code&gt;org.mybatis.spring.boot.autoconfigure.MybatisProperties&lt;/code&gt; 类中查看（鼠标点击属性就可以进入），当然也可以从官方文档中查阅：&lt;a href=&quot;http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/&quot; class=&quot;uri&quot;&gt;http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;编写controller层代码&quot;&gt;7、编写controller层代码&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@RestController
public class MybatisController {
    @Autowired
    private UserMapper userMapper;

    @GetMapping(&quot;/selectUser&quot;)
    public String selectUser(){
        List&amp;lt;Userdao&amp;gt; userdaos = userMapper.queryUserList();
        for (Userdao user : userdaos) {
            System.out.println(user);
        }
        return &quot;select success == SpringBoot 2.X整合Mybatis成功！&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行测试&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107201631265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;效果如上，则整合成功！&lt;/p&gt;
&lt;h2 id=&quot;springboot-2.x整合mybatis原理&quot;&gt;8、SpringBoot 2.X整合Mybatis原理&lt;/h2&gt;
&lt;p&gt;SpringBoot 2.X整合Mybatis原理实际上就隐含在&lt;code&gt;org.mybatis.spring.boot.autoconfigure&lt;/code&gt; 包中，这里面蕴含着SpringBoot 整合Mybatis的精华原理所在，具体位置如下&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200107202455921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;在myBatis 与 spring 整合的时候，开发者需要自己提供两个&lt;code&gt;Bean&lt;/code&gt;，一个&lt;code&gt;SqlSessionFactoryBean&lt;/code&gt;，还有一个是&lt;code&gt;MapperScannerConfigurer&lt;/code&gt;，在&lt;code&gt;Spring Boot&lt;/code&gt;中，这两个东西虽然不用开发者自己提供了，但是并不意味着这两个Bean不需要了，在&lt;code&gt;org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration&lt;/code&gt;类中，我们可以看到Spring Boot提供了这两个Bean，关键源码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@org.springframework.context.annotation.Configuration
@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class })
@ConditionalOnSingleCandidate(DataSource.class)
@EnableConfigurationProperties(MybatisProperties.class)
@AutoConfigureAfter(DataSourceAutoConfiguration.class)
public class MybatisAutoConfiguration implements InitializingBean {

  @Bean
  @ConditionalOnMissingBean
  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception {
    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();
    factory.setDataSource(dataSource);
    return factory.getObject();
  }
  @Bean
  @ConditionalOnMissingBean
  public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) {
    ExecutorType executorType = this.properties.getExecutorType();
    if (executorType != null) {
      return new SqlSessionTemplate(sqlSessionFactory, executorType);
    } else {
      return new SqlSessionTemplate(sqlSessionFactory);
    }
  }
  @org.springframework.context.annotation.Configuration
  @Import({ AutoConfiguredMapperScannerRegistrar.class })
  @ConditionalOnMissingBean(MapperFactoryBean.class)
  public static class MapperScannerRegistrarNotFoundConfiguration implements InitializingBean {

    @Override
    public void afterPropertiesSet() {
      logger.debug(&quot;No {} found.&quot;, MapperFactoryBean.class.getName());
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从类上的注解可以看出，当当前类路径下存在&lt;code&gt;SqlSessionFactory&lt;/code&gt;、 &lt;code&gt;SqlSessionFactoryBean&lt;/code&gt;以及&lt;code&gt;DataSource&lt;/code&gt;时，这里的配置才会生效，&lt;code&gt;SqlSessionFactory&lt;/code&gt;和&lt;code&gt;SqlTemplate&lt;/code&gt;都被提供了。这段代码的意义就在于&lt;code&gt;Spring Boot&lt;/code&gt;中&lt;code&gt;MyBatis&lt;/code&gt;多数据源的配置时做了重要的参考！&lt;/p&gt;
&lt;p&gt;当然如果对mybatis的配置属性感兴趣的也可以参考&lt;code&gt;MybatisProperties&lt;/code&gt;类，要探索更多原理主要以&lt;code&gt;org.mybatis.spring.boot.autoconfigure&lt;/code&gt; 包为中心进行参考！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，里面有一些java学习资料和一大波java电子书籍，比如说周志明老师的深入java虚拟机、java编程思想、核心技术卷、大话设计模式、java并发编程实战.....都是java的圣经，不说了快上Tomcat车，咋们走！最主要的是一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;参考：&lt;br/&gt;http://mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/u012702547/article/details/88643598&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jan 2020 23:15:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>1、创建工程环境 勾选Web、Mybatis、MySQL，如下 依赖如下 创建完成之后注意，MyBatis依赖的命名和其他库的命名不太一样，是的这个整合jar包并不是springboot自己的，这表示</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/12164679.html</dc:identifier>
</item>
<item>
<title>来吧，一文彻底搞懂Java中的Comparable和Comparator - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12164669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12164669.html</guid>
<description>&lt;p&gt;大家好，我是沉默王二，今天在逛 programcreek 的时候，我发现了一些专注细节但价值连城的主题。比如说：Java 的 Comparable 和 Comparator 是兄弟俩吗？像这类灵魂拷问的主题，非常值得深入地研究一下。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-comparable-cmoparator-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;Comparable 和 Comparator 是 Java 的两个接口，从名字上我们就能够读出来它们俩的相似性：以某种方式来比较两个对象。但它们之间到底有什么区别呢？请随我来，打怪进阶喽！&lt;/p&gt;
&lt;h3 id=&quot;h01comparable&quot;&gt;&lt;span&gt;01、Comparable&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Comparable 接口的定义非常简单，源码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一个类实现了 Comparable 接口（只需要干一件事，重写 &lt;code&gt;compareTo()&lt;/code&gt; 方法），就可以按照自己制定的规则将由它创建的对象进行比较。下面给出一个例子。&lt;/p&gt;
&lt;pre readability=&quot;9.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;13&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Cmower&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Cmower&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String name;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Cmower&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; age, String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Cmower o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.getAge() - o.getAge();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Cmower wanger = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Cmower(&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;Cmower wangsan = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Cmower(&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (wanger.compareTo(wangsan) &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;System.out.println(wanger.getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;比较年轻有为&quot;&lt;/span&gt;);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;System.out.println(wangsan.getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;比较年轻有为&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我创建了一个 Cmower 类，它有两个字段：age 和 name。Cmower 类实现了 Comparable 接口，并重写了 &lt;code&gt;compareTo()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;程序输出的结果是“沉默王三比较年轻有为”，因为他比沉默王二小三岁。这个结果有什么凭证吗？&lt;/p&gt;
&lt;p&gt;凭证就在于 &lt;code&gt;compareTo()&lt;/code&gt; 方法，该方法的返回值可能为负数，零或者正数，代表的意思是该对象按照排序的规则小于、等于或者大于要比较的对象。如果指定对象的类型与此对象不能进行比较，则引发 &lt;code&gt;ClassCastException&lt;/code&gt; 异常（自从有了泛型，这种情况就少有发生了）。&lt;/p&gt;
&lt;h3 id=&quot;h02comparator&quot;&gt;&lt;span&gt;02、Comparator&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Comparator 接口的定义相比较于 Comparable 就复杂的多了，不过，核心的方法只有两个，来看一下源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Comparator&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(T o1, T o2)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object obj)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个方法 &lt;code&gt;compare(T o1, T o2)&lt;/code&gt; 的返回值可能为负数，零或者正数，代表的意思是第一个对象小于、等于或者大于第二个对象。&lt;/p&gt;
&lt;p&gt;第二个方法 &lt;code&gt;equals(Object obj)&lt;/code&gt; 需要传入一个 Object 作为参数，并判断该 Object 是否和 Comparator 保持一致。&lt;/p&gt;
&lt;p&gt;有时候，我们想让类保持它的原貌，不想主动实现 Comparable 接口，但我们又需要它们之间进行比较，该怎么办呢？&lt;/p&gt;
&lt;p&gt;Comparator 就派上用场了，来看一下示例。&lt;/p&gt;
&lt;p&gt;1）原封不动的 Cmower 类。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Cmower&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; age;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String name;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Cmower&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; age, String name)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.age = age;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.name = name;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（说好原封不动，getter/setter 吃了啊）&lt;/p&gt;
&lt;p&gt;Cmower 类有两个字段：age 和 name，意味着该类可以按照 age 或者 name 进行排序。&lt;/p&gt;
&lt;p&gt;2）再来看 Comparator 接口的实现类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CmowerComparator&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Comparator&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Cmower&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Cmower o1, Cmower o2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; o1.getAge() - o2.getAge();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照 age 进行比较。当然也可以再实现一个比较器，按照 name 进行自然排序，示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CmowerNameComparator&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Comparator&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;Cmower&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Cmower o1, Cmower o2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (o1.getName().hashCode() &amp;lt; o2.getName().hashCode()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; -&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (o1.getName().hashCode() == o2.getName().hashCode()) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3）再来看测试类。&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;Cmower wanger = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Cmower(&lt;span class=&quot;hljs-number&quot;&gt;19&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;Cmower wangsan = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Cmower(&lt;span class=&quot;hljs-number&quot;&gt;16&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;);&lt;br/&gt;Cmower wangyi = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Cmower(&lt;span class=&quot;hljs-number&quot;&gt;28&lt;/span&gt;,&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王一&quot;&lt;/span&gt;);&lt;p&gt;List&amp;lt;Cmower&amp;gt; list = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(wanger);&lt;br/&gt;list.add(wangsan);&lt;br/&gt;list.add(wangyi);&lt;/p&gt;&lt;p&gt;list.sort(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; CmowerComparator());&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Cmower c : list) {&lt;br/&gt;System.out.println(c.getName());&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建了三个对象，age 不同，name 不同，并把它们加入到了 List 当中。然后使用 List 的 &lt;code&gt;sort()&lt;/code&gt; 方法进行排序，来看一下输出的结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;沉默王三&lt;br/&gt;沉默王二&lt;br/&gt;沉默王一&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这意味着沉默王三的年纪比沉默王二小，排在第一位；沉默王一的年纪比沉默王二大，排在第三位。和我们的预期完全符合。&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;&lt;span&gt;03、到底该用哪一个呢？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;通过上面的两个例子可以比较出 Comparable 和 Comparator 两者之间的区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一个类实现了 Comparable 接口，意味着该类的对象可以直接进行比较（排序），但比较（排序）的方式只有一种，很单一。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个类如果想要保持原样，又需要进行不同方式的比较（排序），就可以定制比较器（实现 Comparator 接口）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;Comparable 接口在 &lt;code&gt;java.lang&lt;/code&gt; 包下，而 &lt;code&gt;Comparator&lt;/code&gt; 接口在 &lt;code&gt;java.util&lt;/code&gt; 包下，算不上是亲兄弟，但可以称得上是表（堂）兄弟。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个不恰当的例子。我想从洛阳出发去北京看长城，体验一下好汉的感觉，要么坐飞机，要么坐高铁；但如果是孙悟空的话，翻个筋斗就到了。我和孙悟空之间有什么区别呢？孙悟空自己实现了 Comparable 接口（他那年代也没有飞机和高铁，没得选），而我可以借助 Comparator 接口（现代化的交通工具）。&lt;/p&gt;
&lt;p&gt;总而言之，如果对象的排序需要基于自然顺序，请选择 &lt;code&gt;Comparable&lt;/code&gt;，如果需要按照对象的不同属性进行排序，请选择 &lt;code&gt;Comparator&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;&lt;span&gt;04、鸣谢&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;好了，各位读者朋友们，以上就是本文的全部内容了。&lt;strong&gt;能看到这里的都是最胖的程序员（不，最棒），升职加薪就是你了&lt;/strong&gt;👍。如果觉得不过瘾，还想看到更多，可以 star 二哥的 GitHub【&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;itwanger.github.io&lt;/a&gt;】，本文已收录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原创不易，如果觉得有点用的话，请不要吝啬你手中点赞的权力&lt;/strong&gt;——这将是我最强的写作动力。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/cmower_4.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;</description>
<pubDate>Tue, 07 Jan 2020 22:31:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>大家好，我是沉默王二，今天在逛 programcreek 的时候，我发现了一些专注细节但价值连城的主题。比如说：Java 的 Comparable 和 Comparator 是兄弟俩吗？像这类灵魂拷问</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12164669.html</dc:identifier>
</item>
<item>
<title>聊聊密码学中的DES算法 - 龙跃十二</title>
<link>http://www.cnblogs.com/zhonglongbo/p/12164434.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhonglongbo/p/12164434.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;用心分享，共同成长&lt;/p&gt;
&lt;p&gt;没有什么比你每天进步一点点更实在了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt;本文已经收录至我的github,欢迎大家踊跃star 和 issues。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;a href=&quot;https://github.com/midou-tech/articles&quot; target=&quot;_blank&quot;&gt;https://github.com/midou-tech/articles&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 今天要说点和你的隐私有关的事情，在这个信息化的时代，是不是真的有人一手握着你的信息，一手数着钞票呢？答案一定是&lt;strong&gt;&lt;em&gt;当然&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 说到网络安全，我就不得不提一个东西——&lt;span&gt;&lt;strong&gt;密码学&lt;/strong&gt;&lt;/span&gt;（是不是听起来头皮发麻心跳加速），稳住稳住，老司机上线带你学。今天给大家say&amp;amp;see什么是密码学中的&lt;span&gt;&lt;strong&gt;DES&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;h4 id=&quot;h&quot;&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt; &lt;strong&gt;DES&lt;/strong&gt;：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;English Name：Data Encrytion Standard&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;中文名：DES 算法，数据加密标准&lt;/p&gt;
&lt;p&gt;是迄今为止世界上最为广泛使用和流行的一种分组密码算法。（听到这里有没有感觉有点东西）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;h1&quot;&gt;&lt;span&gt;1、参数介绍：&lt;/span&gt;&lt;/h5&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;data（加解密的数据）：64bit的明文或者密文需要被加密或被解密的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;key（加解密的密钥）：8Byte，64bit密钥（56bit密钥+8bit奇偶校验位）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mode（工作模式）：加密或者解密的工作流程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;h2&quot;&gt;&lt;span&gt;2、工作流程：&lt;/span&gt;&lt;/h5&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1gaod7ysxdcj30t20y80t6.jpg&quot; alt=&quot;WechatIMG112&quot; title=&quot;WechatIMG112&quot;/&gt;WechatIMG112
&lt;h5 id=&quot;h3ip&quot;&gt;&lt;span&gt;3、初始IP置换：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; DES算法使用64位的密钥key将64位的明文输入块变为64位的密文输出块，并把输出块分为L0、R0两部分，每部分均为32位。左部分Li=Ri-1,右部分Ri=Li-1⊕F(Ri-1,Ki)&lt;span&gt;&lt;strong&gt;（注：这里的⊕指二元域上的加法，即异或）&lt;/strong&gt;&lt;/span&gt;，初始置换规则如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;1  58,50,42,34,26,18,10,02,&lt;br/&gt;2  60,52,44,36,28,20,12,04,&lt;br/&gt;3  62,54,46,38,30,22,14,06,&lt;br/&gt;4  64,56,48,40,32,24,16,08,&lt;br/&gt;5  57,49,41,33,25,17,09,01,&lt;br/&gt;6  59,51,43,35,27,19,11,03,&lt;br/&gt;7  61,53,45,37,29,21,13,05,&lt;br/&gt;8  63,55,47,39,31,23,15,07,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 即将输入的64位明文的第1位置换到第40位，第2位置换到第8位，第3位置换到第48位。以此类推，最后一位是原来的第7位。置换规则是规定的。L0是置换后的数据的前32位（D1-D32），R0是置换后的数据的后32位（D33-D64）。&lt;/p&gt;
&lt;h5 id=&quot;h4&quot;&gt;&lt;span&gt;4、轮结构：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; F函数是DES的加密核心，作用也是非常大的，而Feistel结构决定了其加密解密流程是相同的，无论是硬件实现还是软件实现都只需要一种结构，不需要分别实现。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;函数F由四步运算构成&lt;/strong&gt;：密钥置换；扩展E变换；S-盒代替；P-盒置换。&lt;/p&gt;
&lt;h6 id=&quot;h1-1&quot;&gt;&lt;span&gt;(1)、密钥置换------子密钥生成&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt; DES算法由64位密钥产生16轮的48位子密钥。在每一轮的迭代过程中，使用不同的子密钥。&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;a、把密钥的奇偶校验位忽略不参与计算，即每个字节的第8位，将64位密钥降至56位，然后根据选择置换PC-1将这56位分成两块C0(28位)和D0(28位)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;b、将C0和D0进行循环左移变化&lt;span&gt;&lt;strong&gt;(注：每轮循环左移的位数由轮数决定)&lt;/strong&gt;&lt;/span&gt;，变换后生成C1和D1，然后C1和D1合并，并通过选择置换PC-2生成子密钥K1(48位)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;c、C1和D1在次经过循环左移变换，生成C2和D2，然后C2和D2合并，通过选择置换PC-2生成密钥K2(48位)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;d、以此类推，得到K16(48位)。但是最后一轮的左右两部分不交换，而是直接合并在一起R16L16，作为逆置换的输入块。其中循环左移的位数一共是循环左移16次，其中第一次、第二次、第九次、第十六次是循环左移一位，其他都是左移两位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;h2e&quot;&gt;&lt;span&gt;(2）、扩展E变换&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;扩展E变换是将数据的右半部分Ri从32位扩展到48位。&lt;/p&gt;
&lt;p&gt;扩展置换的目的：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;a、产生与密钥相同长度的数据以进行异或运算，R0是32位，子密钥是48位，所以R0要先进行扩展置换之后与子密钥进行异或运算；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;b、提供更长的结果，使得在替代运算时能够进行压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;扩展置换E规则如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;1  32,01,02,03,04,05,&lt;br/&gt;2  04,05,06,07,08,09,&lt;br/&gt;3  08,09,10,11,12,13,&lt;br/&gt;4  12,13,14,15,16,17,&lt;br/&gt;5  16,17,18,19,20,21,&lt;br/&gt;6  20,21,22,23,24,25,&lt;br/&gt;7  24,25,26,27,28,29,&lt;br/&gt;8  28,29,30,31,32,31,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 也就是说，表中的第i个数据j表示输出的第i位为输入的第j位。例如；输出的第1位是输入的第32位，输出的第7位为输入的第4位。&lt;/p&gt;
&lt;h6 id=&quot;h3s&quot;&gt;&lt;span&gt;（3）、S-盒&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt; S-盒作为feistel结构的&lt;span&gt;&lt;strong&gt;核心&lt;/strong&gt;&lt;/span&gt;，起着至关重要的作用。输入的32bit数据经扩展置换之后与48bit子密钥Kn异或，生成的结果作为输入，传入S盒中进行代替运算。S-盒功能是把48位数据变为32位数据，feistel结构中是由8个不同的S盒共同协作完成。其中，每个S-盒有6位输入，4位输出。所以48位的输入块被分成8个6位的分组，每一个分组对应一个S-盒代替操作。经过S-盒代替，形成8个4位分组结果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注：每一个S-盒的输入数据是6位，输出数据是4位，但是每个S-盒自身是64位！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; S-盒1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,&lt;br/&gt;0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,&lt;br/&gt;4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,&lt;br/&gt;15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; S-盒2：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,&lt;br/&gt;3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,&lt;br/&gt;0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,&lt;br/&gt;13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; S-盒3：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,&lt;br/&gt;13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,&lt;br/&gt;13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,&lt;br/&gt;1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; S-盒4：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,&lt;br/&gt;13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,&lt;br/&gt;10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,&lt;br/&gt;3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; S-盒5：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,&lt;br/&gt;14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,&lt;br/&gt;4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,&lt;br/&gt;11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; S-盒6：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,&lt;br/&gt;10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,&lt;br/&gt;9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,&lt;br/&gt;4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; S-盒7：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,&lt;br/&gt;13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,&lt;br/&gt;1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,&lt;br/&gt;6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; S-盒8：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,&lt;br/&gt;1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,&lt;br/&gt;7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,&lt;br/&gt;2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;S盒的计算：第一位和第六位确定行数，第二、三、四行确定列数，在表中找出对应的数据，将其表示为二进制数据。&lt;/p&gt;
&lt;h6 id=&quot;h4p&quot;&gt;&lt;span&gt;（4）、P-盒&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt; 在S-盒代替运算中，每一个S-盒得到4位，8盒共得到32bit输出数据。这32位输出作为P盒置换的输入块，最终输出为32bit的输出数据。P盒置换将每一位输入位映射到输出位。任何一位都不能被映射两次，也不能被略去。&lt;/p&gt;
&lt;h5 id=&quot;h5&quot;&gt;&lt;span&gt;5、逆置换：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; 将初始置换进行16次的迭代，即进行16层的加密变换，这个运算过程我们暂时称为函数f。得到L16和R16，将此作为输入块，进行逆置换得到最终的密文输出块。逆置换是初始置换的逆运算。从初始置换规则中可以看到，原始数据的第1位置换到了第40位，第2位置换到了第8位。则逆置换就是将第40位置换到第1位，第8位置换到第2位。以此类推，逆置换规则如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;html language-html hljs xml&quot;&gt;1  40,08,48,16,56,24,64,32,39,07,47,15,55,23,63,31,&lt;br/&gt;2  38,06,46,14,54,22,62,30,37,05,45,13,53,21,61,29,&lt;br/&gt;3  36,04,44,12,52,20,60,28,35,03,43,11,51,19,59,27,&lt;br/&gt;4  34,02,42,10,50,18,58 26,33,01,41,09,49,17,57,25,&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;strong&gt;注&lt;/strong&gt;：DES算法的加密密钥是根据用户输入的秘钥生成的,该算法把64位密码中的第8位、第16位、第24位、第32位、第40位、第48位、第56位、第64位作为奇偶校验位,在计算密钥时要忽略这8位.所以实际中使用的秘钥有效位是56位。&lt;/p&gt;
&lt;p&gt; 秘钥共64位，每次置换都不考虑每字节的第8个比特位，这一位是在密钥产生过程中生成的奇偶校验位，所以64位秘钥的第8、16、24、32、40、48、56、64位在计算秘钥时均忽略。&lt;/p&gt;
&lt;h5 id=&quot;h6&quot;&gt;&lt;span&gt;6、解密过程：&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt; DES的解密过程和DES的加密过程基本类似，唯一的不同是将16轮的子密钥序列的顺序反过来，即在加密过程中所用的加密密钥k1，…，k16在解密过程中需要转换成k16，…，k1。&lt;/p&gt;
&lt;h5 id=&quot;h7des&quot;&gt;&lt;span&gt;7、DES算法整理：&lt;/span&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;分组加密算法：以64bit为分组。输入64bit明文，输出64bit密文。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对称算法：加密和解密使用同一秘钥。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;有效秘钥长度：56bit秘钥，通常表示为64位数，但每个第8位用作奇偶校验，可以忽略。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;代替和置换：DES算法是两种加密技术的组合：混乱和扩散。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;易于实现：DES算法只是使用了标准的算术和逻辑运算，其作用的数最多也只有64 位，因此用70年代末期的硬件技术很容易实现算法的重复特性使得它可以非常理想地用在一个专用芯片中。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h-1&quot;&gt;&lt;span&gt;龙跃十二的热门文章：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/nMTsD2y_drV971RxdE1a5g&quot;&gt;🔥🔥学习linux命令，看这篇2w多字的命令详解就够了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/V0_fcjr9t-lyqy2qyg6MWw&quot;&gt;🔥HTTP就是这么简单&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/OZRGLGk3MkdkwaNliITTUQ&quot;&gt;🔥Redis基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Sel5ySSh0YJXdQ6KExQxyw&quot;&gt;🔥顶级程序员工具集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/pcMWdKh9cFMS75sAxgCrWg&quot;&gt;🔥二十多个免费高清图片素材网站送给你&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/NuHIVl5SjQ0_v1EPKnT9Vw&quot;&gt;🔥什么是消息队列？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/wTv67aYUHmrNGPWsWNbpBg&quot;&gt;🔥初学者该如何选择一门编程语言？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;如果有人想发文章，我这里提供&lt;/code&gt;&lt;span&gt;&lt;strong&gt;有偿征文&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;(具体细则微信联系)，欢迎投稿或推荐你的项目。提供以下几种投稿方式：&lt;/code&gt;&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;去我的github提交 issue:&lt;/code&gt; https://github.com/midou-tech/articles&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;发送到邮箱: 2507367760@qq.com 或者 longyueshier@163.com 或者 longyueshier@gmail.com&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;微信发送: 扫描下面二维码，公众号里面有作者微信号。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;精选文章都同步在公众号里面，公众号看起会更方便，随时随地想看就看。微信搜索 龙跃十二 或者扫码即可订阅。&lt;/code&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwly1galsp9a07kj30p00dwae3.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我喜欢那些闪光的东西，比如冬日的雪花，天上的星星，还有你发光的眼睛。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 07 Jan 2020 16:13:00 +0000</pubDate>
<dc:creator>龙跃十二</dc:creator>
<og:description>DES算法为密码体制中的对称密码体制，又被称为美国数据加密标准。DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。密钥长64位，密钥事实上是56位参与DES运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhonglongbo/p/12164434.html</dc:identifier>
</item>
<item>
<title>Spring Bean管理 - CoderJerry</title>
<link>http://www.cnblogs.com/yangyuanhu/p/12164380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyuanhu/p/12164380.html</guid>
<description>&lt;p&gt;工厂只负责创建对象,而Spring当然不仅仅是一个对象工厂;其核心是一个对象容器,由于具备控制反转的能力,所以也叫它IOC容器;&lt;/p&gt;
&lt;p&gt;容器可以理解为存放对象的地方,当然不仅仅是存储,还有对象的管理,包括-创建-销毁-装配; 这样原本程序要做的事情交给了Spring,所以这属于IOC,称之为IOC容器;&lt;/p&gt;
&lt;p&gt;Spring有两个容器接口ApplicationContext是BeanFactory的子接口。它们都可以作为Spring的容器;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gakrpgtubbj30uf0q7q9f.jpg&quot; alt=&quot;image-20200104180458270&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;两种容器的区别&quot;&gt;两种容器的区别:&lt;/h2&gt;

&lt;h2 id=&quot;bean的实例化&quot;&gt;Bean的实例化&lt;/h2&gt;
&lt;h3 id=&quot;使用类构造器默认无参数&quot;&gt;1. 使用类构造器(默认无参数)&lt;/h3&gt;
&lt;p&gt;该方式Bean类中必须存在无参构造器&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;UserService1&quot; class=&quot;com.yyh.serviceimpl.UserServiceImpl&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用静态工厂方法&quot;&gt;2. 使用静态工厂方法&lt;/h3&gt;
&lt;p&gt;xml配置:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;userService&quot; class=&quot;com.yyh.serviceimpl.ServiceFactory&quot; factory-method=&quot;getService&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;工厂:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.yyh.service.UserService;
public class ServiceFactory {
    public static UserService getService() {
          System.out.println(&quot;factory static run!&quot;);
        return new UserServiceImpl();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用实例工厂方法&quot;&gt;3. 使用实例工厂方法&lt;/h3&gt;
&lt;p&gt;xml配置:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--工厂Bean--&amp;gt;
&amp;lt;bean id=&quot;serviceFactory&quot; class=&quot;com.yyh.serviceimpl.ServiceFactory&quot;/&amp;gt;
&amp;lt;!--Service Bean--&amp;gt;
&amp;lt;bean id=&quot;userService2&quot; factory-bean=&quot;serviceFactory&quot; factory-method=&quot;getService2&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;工厂添加方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public UserService getService2() {
    System.out.println(&quot;factory instance run!&quot;);
    return new UserServiceImpl();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bean的命名&quot;&gt;Bean的命名&lt;/h2&gt;
&lt;p&gt;配置Bean时，可以使用 id 或者 name 属性给bean命名。 id 和 name 属性作用上一样，推荐使用id。&lt;/p&gt;
&lt;ul readability=&quot;18&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;id取值要求严格些，必须满足XML的命名规范。id是唯一的，配置文件中不允许出现两个id相同的bean。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;name取值比较随意，甚至可以用数字开头。在配置文件中允许出现多个name相同的bean，在用getBean()返回实例时，最后的一个Bean将被返回。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意:在spring5中name和id一样也不允许有重复的名称。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果没有id，name，则用类的全名作为name&lt;/p&gt;
&lt;p&gt;如 &lt;code&gt;&amp;lt;bean class=&quot;test.Test&quot;&amp;gt;&lt;/code&gt; ,可以使用 getBean(&quot;test.Test&quot;) 返回该实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;如果存在多个id和name都没有指定，且类都一样的，如:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean class=&quot;com.yh.service.UserService&quot;/&amp;gt;
&amp;lt;bean class=&quot;com.yh.service.UserService&quot;/&amp;gt; 
&amp;lt;bean class=&quot;com.yh.service.UserService&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则可以通过getBean(“完整类名#索引”)来获得,如:&lt;code&gt;getBean(&quot;com.yh.service.UserService#1&quot;)&lt;/code&gt;,索引从0开始,若要获取第一个则可以忽略索引,直接写类名&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;name中可以使用分号（“；”）、空格（“ ”）或逗号（“，”）来给这个Bean添加多个名称（相当于别名 alias 的作用）。如：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;&quot;
name=“a b c d”等同于 name=“a,b,c,d” 这样写相当于有 1 2 3 4（4个）个标识符标识当前bean id=“1 2 3 4” 这样写相当于有 “1 2 3 4”(1个)个标识符标识当前bean
&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而id中的任何字符都被作为一个整体 ;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果既配置了 id ，也配置了 name ，则两个都生效。当然也不能重复;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当注解中出现与xml配置中相同的id或相同name时,优先是用xml中的配置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;bean的作用域&quot;&gt;Bean的作用域&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;singleton&lt;/td&gt;
&lt;td&gt;默认值; 在Spring IoC容器中仅存在一个Bean实例，Bean以单例方式存在。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;prototype&lt;/td&gt;
&lt;td&gt;每次从容器中调用Bean时，都返回一个新的实例;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;request&lt;/td&gt;
&lt;td&gt;每次HTTP请求都会创建一个新的Bean，该作用域仅适用于WebApplicationContext环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;session&lt;/td&gt;
&lt;td&gt;同一个HTTP Session 共享一个Bean，不同Session使用不同Bean，仅适用于WebApplicationContext 环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;application&lt;/td&gt;
&lt;td&gt;Bean的作用域为ServletContext ，仅适用于WebApplicationContext环境。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;作用域就是指作用范围:单例则表示对象的作用范围是整个Spring容器,而prototype则表示不管理作用范围,每次get就直接创建新的&lt;/p&gt;
&lt;h2 id=&quot;生命周期&quot;&gt;生命周期&lt;/h2&gt;
&lt;h4 id=&quot;init和destroy&quot;&gt;init和destroy&lt;/h4&gt;
&lt;p&gt;Spring提供了非入侵(不强制类继承或实现)方式的生命周期方法,可以在Bean的初始化以及销毁时做一些额外的操作&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;service&quot; class=&quot;com.yh.service.UserService&quot; scope=&quot;singleton&quot;
      init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;/&amp;gt;
&amp;lt;!--
init-method     用于初始化操作
detroy-method       用于销毁操作&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;注意:destroy仅在scope为singleton时有效 因为多例情况下&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;bean的完整生命周期&quot;&gt;Bean的完整生命周期&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1ganzkvhltgj30ki0gj44q.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行顺序及其含义:&lt;/p&gt;
&lt;p&gt;1 构造对象&lt;br/&gt;2 设置属性&lt;br/&gt;3 了解Bean在容器中的name&lt;br/&gt;4 了解关联的beanFactory&lt;br/&gt;5 初始化前处理&lt;br/&gt;6 属性设置完成&lt;br/&gt;7 自定义初始化方法&lt;br/&gt;8 初始化后处理&lt;br/&gt;9 业务方法&lt;br/&gt;10 Bean销毁方法&lt;br/&gt;11 自定义销毁方法&lt;/p&gt;
&lt;h2 id=&quot;依赖注入&quot;&gt;依赖注入&lt;/h2&gt;
&lt;p&gt;依赖指的是当前对象在运行过程中需要使用到的其他参数,Spring可以帮助我们来完成这个依赖关系的建立,说的简单点就是把你需要参数的给你,而你不用管参数怎么来的,已达到尽可能的解耦 ;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举个例子:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Controller 中需要Service对象,Spring可以把Service自动丢到你的Controller中,你不需要关系Service是怎么来的,用就完了;&lt;/p&gt;
&lt;p&gt;要使用依赖注入,必须现在需要依赖的一方(Controller)中为被依赖的一方(Service)定义属性,用以接收注入;&lt;/p&gt;
&lt;h3 id=&quot;构造方法注入&quot;&gt;构造方法注入&lt;/h3&gt;
&lt;p&gt;bean:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User2 {
    private String name;
    private int age;
    private Phone phone;

    public User2(String name, int age, Phone phone) {
        this.name = name;
        this.age = age;
        this.phone = phone;
    }
    @Override
    public String toString() {
        return &quot;User2{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                &quot;, phone=&quot; + phone +
                '}';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;xml:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;!--依赖注入--&amp;gt;
    &amp;lt;bean id=&quot;user&quot; class=&quot;com.yh.demo2.User2&quot;&amp;gt;
        &amp;lt;!--按参数名称注入        --&amp;gt;
        &amp;lt;constructor-arg name=&quot;name&quot; value=&quot;jerry&quot;/&amp;gt;
        &amp;lt;!--按参数位置注入           --&amp;gt;
        &amp;lt;constructor-arg index=&quot;1&quot; value=&quot;18&quot;/&amp;gt;

        &amp;lt;!--参数类型为其他bean对象时value换成ref        --&amp;gt;
        &amp;lt;constructor-arg name=&quot;phone&quot; ref=&quot;phone&quot;/&amp;gt;

        &amp;lt;!--type指定类型不常用        --&amp;gt;
        &amp;lt;!--&amp;lt;constructor-arg type=&quot;java.lang.String&quot; name=&quot;name&quot; value=&quot;jerry&quot;/&amp;gt;--&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--user需要的依赖phoneBean--&amp;gt;
    &amp;lt;bean id=&quot;phone&quot; class=&quot;com.yh.demo2.Phone&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;setter方法注入&quot;&gt;setter方法注入&lt;/h3&gt;
&lt;p&gt;依然对上面的User2类的依赖进行注入&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--setter方法注入(属性注入)  --&amp;gt;
&amp;lt;bean id=&quot;user2&quot; class=&quot;com.yh.demo2.User2&quot;&amp;gt;
    &amp;lt;property name=&quot;name&quot; value=&quot;jerry&quot;/&amp;gt; &amp;lt;!--注入常量值--&amp;gt;
    &amp;lt;property name=&quot;age&quot; value=&quot;20&quot;/&amp;gt;
    &amp;lt;property name=&quot;phone&quot; ref=&quot;phone&quot;/&amp;gt; &amp;lt;!--注入其他Bean--&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;注意:上述配置要求User2必须存在空参构造器&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;c命名标签&quot;&gt;c命名标签&lt;/h3&gt;
&lt;p&gt;上面通过嵌套标签constructor的方式注入依赖,在需要注入的依赖较多时导致xml显得很臃肿,C名称空间来简化xml中&lt;code&gt;&amp;lt;constructor-arg&amp;gt;&lt;/code&gt;标签的书写&lt;/p&gt;
&lt;p&gt;使用前需要先在xml头部进行声明&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;xmlns:c=&quot;http://www.springframework.org/schema/c&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gao2fyg6oqj30nl05zmye.jpg&quot; alt=&quot;image-20200107161358548&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--c命名空间的使用--&amp;gt;
&amp;lt;bean id=&quot;user3&quot; class=&quot;com.yh.demo2.User2&quot; c:name=&quot;jerry&quot; c:_1=&quot;21&quot; c:phone-ref=&quot;phone&quot;&amp;gt;&amp;lt;/bean&amp;gt;
&amp;lt;!--
c:name              指定为name参数赋值
c:_1                指定为构造函数的第2个参数赋值
c:phone-ref   指定为构造函数的第phone参数赋值为id为&quot;phone&quot;的Bean
--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;p命名标签&quot;&gt;p命名标签&lt;/h3&gt;
&lt;p&gt;同样的p命名空间则是用于简化&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;标签的书写&lt;/p&gt;
&lt;p&gt;声明:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;xmlns:p=&quot;http://www.springframework.org/schema/p&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean id=&quot;user4&quot; class=&quot;com.yh.demo2.User2&quot; p:name=&quot;jerry&quot; p:age=&quot;20&quot; p:phone-ref=&quot;phone&quot;/&amp;gt;
&amp;lt;!--
p:name              指定为name属性赋值
p:age               指定为age属性赋值
p:phone-ref   为phone属性赋值为id为&quot;phone&quot;的Bean
--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spel注入&quot;&gt;SpEL注入&lt;/h3&gt;
&lt;p&gt;SpEL即Spring Expression Language的缩写,与JSTL一样是表达式语言,可以支持使用更加复杂的语法注入依赖,包括标准数学运算符，关系运算符，逻辑运算符，条件运算符，集合和正则表达式等;&lt;/p&gt;
&lt;p&gt;语法:&lt;code&gt;#{表达式}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;用例:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--SpEL    --&amp;gt;
&amp;lt;bean id=&quot;user5&quot; class=&quot;com.yh.demo2.User2&quot;&amp;gt;
&amp;lt;!--&amp;lt;property name=&quot;name&quot; value=&quot;#{'jerry'}&quot;/&amp;gt;--&amp;gt;           &amp;lt;!--字符常量--&amp;gt;
&amp;lt;!--&amp;lt;property name=&quot;age&quot; value=&quot;#{100.0}&quot;/&amp;gt;--&amp;gt;              &amp;lt;!--数字常量--&amp;gt;
&amp;lt;!--&amp;lt;property name=&quot;phone&quot; value=&quot;#{phone}&quot;/&amp;gt;--&amp;gt;            &amp;lt;!--对象引用--&amp;gt;
&amp;lt;!--&amp;lt;property name=&quot;name&quot; value=&quot;#{phone.model.concat(' jerry')}&quot;/&amp;gt;--&amp;gt; &amp;lt;!--方法调用--&amp;gt;
&amp;lt;!--&amp;lt;property name=&quot;age&quot; value=&quot;#{1+100}&quot;/&amp;gt;--&amp;gt;              &amp;lt;!--算数符--&amp;gt;
&amp;lt;!--&amp;lt;property name=&quot;name&quot; value=&quot;#{'11' &amp;gt; '22'}&quot;/&amp;gt;--&amp;gt;       &amp;lt;!--比较符--&amp;gt;
&amp;lt;!--&amp;lt;property name=&quot;name&quot; value=&quot;#{true or false}&quot;/&amp;gt;--&amp;gt;     &amp;lt;!--逻辑符--&amp;gt;
&amp;lt;!--&amp;lt;property name=&quot;name&quot; value=&quot;#{1 &amp;gt; 0?1:0}&quot;/&amp;gt;--&amp;gt;         &amp;lt;!--三目--&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;容器类型的注入&quot;&gt;容器类型的注入&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--    容器数据类型注入--&amp;gt;
&amp;lt;bean id=&quot;user100&quot; class=&quot;com.yh.demo2.User3&quot;&amp;gt;
    &amp;lt;!--set注入        --&amp;gt;
    &amp;lt;property name=&quot;set&quot;&amp;gt;
        &amp;lt;set&amp;gt;
            &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;a&amp;lt;/value&amp;gt;
        &amp;lt;/set&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!--list注入        --&amp;gt;
    &amp;lt;property name=&quot;list&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
            &amp;lt;value&amp;gt;a&amp;lt;/value&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!--map注入        --&amp;gt;
    &amp;lt;property name=&quot;map&quot;&amp;gt;
        &amp;lt;map&amp;gt;
            &amp;lt;entry key=&quot;name&quot; value=&quot;jerry&quot;/&amp;gt;
            &amp;lt;entry key=&quot;age&quot; value=&quot;18&quot;/&amp;gt;
            &amp;lt;entry key=&quot;sex&quot; value=&quot;man&quot;/&amp;gt;
        &amp;lt;/map&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;!--properties注入        --&amp;gt;
    &amp;lt;property name=&quot;properties&quot;&amp;gt;
        &amp;lt;props&amp;gt;
            &amp;lt;prop key=&quot;jdbc.user&quot;&amp;gt;root&amp;lt;/prop&amp;gt;
            &amp;lt;prop key=&quot;jdbc.password&quot;&amp;gt;admin&amp;lt;/prop&amp;gt;
            &amp;lt;prop key=&quot;jdbc.driver&quot;&amp;gt;com.mysql.jdbc.Driver&amp;lt;/prop&amp;gt;
        &amp;lt;/props&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;强调:Spring的依赖注入要么通过构造函数,要么通过setter,什么接口注入都tm扯犊子;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口注入不是一种注入方式,只不过由于OOP的多态,Spring在按照类型注入时,会在容器中查找类型匹配的Bean,如果没有则查找该类的子类,如果容器中有多个匹配的子类Bean时会抛出异常,坑了一堆人,然后就开始意淫给这个问题取个名字吧.....接口注入.....&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;注解配置&quot;&gt;注解配置&lt;/h2&gt;
&lt;h3 id=&quot;注解配置bean&quot;&gt;注解配置Bean&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;通用注解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ @Component 用于在Spring中加入Bean&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVC场景下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ @Controller 等价于 @Component 标注控制层&lt;/p&gt;
&lt;p&gt;​ @Service 等价于 @Component 标注业务层&lt;/p&gt;
&lt;p&gt;​ @Repository 等价于 @Component 标注数据访问层(DAO)&lt;/p&gt;
&lt;p&gt;在实现上没有任何不同,仅仅是为了对Bean进行分层是结构更清晰&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用步骤:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 1.需要依赖context和aop两个jar包&lt;/p&gt;
&lt;p&gt;​ 2.添加命名空间&lt;/p&gt;
&lt;p&gt;​ 3.指定扫描的注解所在的包&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;

       xsi:schemaLocation=&quot;
       http://www.springframework.org/schema/beans
       https://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;


    &amp;lt;!--指定要扫描注解的包    --&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;com.yh.demo&quot;/&amp;gt;


&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注册的Bean:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.stereotype.Component;

@Component(&quot;userService)
public class UserService {

    public String hello(String name){
        return &quot;hello &quot; + name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Tester {
    @Test
    public void test(){
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService service = (UserService) context.getBean(&quot;userService&quot;);
        System.out.println(service.hello(&quot;jerry&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若注解中没有指定id则默认使用简单类名且小写开头,&lt;code&gt;userService&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;注解注入&quot;&gt;注解注入&lt;/h3&gt;
&lt;p&gt;@Value用于对基本类型属性进行注入&lt;/p&gt;
&lt;p&gt;@Autowired将容器中的其他Bean注入到属性中&lt;/p&gt;
&lt;p&gt;@Qualifier(&quot;BeanID&quot;) 指定要注入的Bean的ID&lt;/p&gt;
&lt;p&gt;准备UserDAO类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.stereotype.Repository;

@Repository(&quot;userDAO&quot;)
public class UserDAO {
    public void save(){
        System.out.println(&quot;user saved!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UserService类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component(&quot;userService&quot;)
public class UserService {

    @Value(&quot;hello&quot;)//基本类型
    private String info;
        //@Autowired(required = false) //默认为true表示属性时必须的不能为空
    @Autowired //注入类型匹配的Bean
    //@Qualifier(&quot;userDAO&quot;) //明确指定需要的BeanID
    private UserDAO userDAO;

//set/get.....
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Tester {
    @Test
    public void test(){
        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        UserService service = (UserService) context.getBean(&quot;userService&quot;);
        System.out.println(service.getInfo());//普通属性测试
        service.getUserDAO().save();//对象属性测试
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Autowired默认自动注入类型一致的Bean;required属性用于设置属性是否是必须的默认为true&lt;/p&gt;
&lt;p&gt;Qualifier需要和Autowired搭配使用,用于明确指定要注入的Bean的ID&lt;/p&gt;
&lt;h4 id=&quot;注意&quot;&gt;注意:&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;当Spring中存在多个类型都匹配的Bean时直接报错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接口:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface PersonDao {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个实现类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Repository()
public class PersonDaoImpl1 implements PersonDao{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Repository()
public class PersonDaoImpl2 implements PersonDao{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注入:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component(&quot;userService&quot;)
public class UserService {
    @Autowired
    private PersonDao personDao;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;resource&quot;&gt;@Resource&lt;/h4&gt;
&lt;p&gt;Qualifier和Autowired书写繁琐,@Resource可将两个标签的功能整合,即注入指定ID的Bean&lt;/p&gt;
&lt;p&gt;@Resource标准注解的支持是JSR-250中定义的,所以时使用需要导入扩展包,Maven依赖如下:&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.annotation&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.annotation-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Resource默认按照使用属性名称作为id查找,查找失败则使用类型查找&lt;/p&gt;
&lt;p&gt;可以利用name属性指定通过id查找&lt;/p&gt;
&lt;p&gt;也可通过type指定类型,当出现相同类型的多个Bean时抛出异常&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import javax.annotation.Resource;

@Component(&quot;userService&quot;)
public class UserService {
        //@Resource()//默认按照id/name
    //@Resource(name=&quot;xx&quot;)//指定name
    //@Resource(type = PersonDaoImpl1.class) //指定type
    @Resource(name=&quot;xx&quot;,type = PersonDaoImpl1.class)//同时指定name和type
    private PersonDao personDao;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;scope&quot;&gt;@Scope&lt;/h4&gt;
&lt;p&gt;用于标注Bean的作用域&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Repository()
@Scope(&quot;prototype&quot;) //每次get都创建新的 
public class UserDAO {
    public void save(){
        System.out.println(&quot;user saved!&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为注解的表达能力有限,很多时候无法满足使用需求;我们可以将注解和XML配合使用,让XML负责管理Bean,注解仅负责属性注入;&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jan 2020 15:47:00 +0000</pubDate>
<dc:creator>CoderJerry</dc:creator>
<og:description>IOC容器 工厂只负责创建对象,而Spring当然不仅仅是一个对象工厂;其核心是一个对象容器,由于具备控制反转的能力,所以也叫它IOC容器; 容器可以理解为存放对象的地方,当然不仅仅是存储,还有对象的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yangyuanhu/p/12164380.html</dc:identifier>
</item>
<item>
<title>SpringBoot 总结篇 - 龙四丶</title>
<link>http://www.cnblogs.com/loongk/p/12164334.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loongk/p/12164334.html</guid>
<description>&lt;p&gt;        时至今日，SpringBoot 系列文章也算是告一段落，回想起当初立flag的情景，仿佛还历历在目。用一个月时间学完 SpringBoot 并整理成文章？又定一些异想天开计划，当时这样想着。不过，虽然过程比较艰辛，但结局也还算完美，在最后一篇文章完成那一刻，心情却很平静，我想，大概是习以为常了吧。&lt;/p&gt;
&lt;p&gt;        在系列结尾，再对 SpringBoot 做一个总结，也算是尘埃落定了。&lt;/p&gt;

&lt;p&gt;        SpringBoot 最显著的功能就是快速启动一个 Spring 应用，为 Spring 所有特性提供了更广泛的支持；提供一系列大型项目通用的非功能性功能（例如嵌入式服务器，安全性，指标，运行状况检查和外部化配置）；完全没有代码生成，也不需要XML配置也是一大亮点。&lt;/p&gt;
&lt;p&gt;该系列文章虽然以讨论 SpringBoot 为中心，但也涉及到了 Spring 技术栈，因为 SpringBoot 底层核心是就是 Spring ，如果对 Spring 了如指掌，那学习 SpringBoot 就轻而易举了。&lt;/p&gt;
&lt;h2 id=&quot;自动装配基础&quot;&gt;1、自动装配基础&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;https://www.cnblogs.com/loongk/p/11970246.html&quot;&gt;《SpringBoot（一）自动装配基础》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot 中运用了大量的 Spring 注解，其注解大致分为这几类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置注解：@Configuration、@ComponentScan、@Import、@Conditional、Bean&lt;/li&gt;
&lt;li&gt;模式注解：@Componnt、@Repository、@Service、@Controller&lt;/li&gt;
&lt;li&gt;@Enable 模块注解：@EnableWebMvc、@EnableTransactionManagement、@EnableWebFlux&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;配置注解都在 Spring 的 ConfigurationClassParser#doProcessConfigurationClass 方法中进行处理，后续会在 Spring 系列文章中详细介绍；模式注解都标注了 @Component 注解，属于 @Component 的派生注解，@ComponentScan 会扫描标注 &lt;code&gt;@Component&lt;/code&gt; 及其派生注解的类，并将这些类加入到 Spring 容器中；&lt;code&gt;@Enable&lt;/code&gt; 模块注解中通过 &lt;code&gt;@Import&lt;/code&gt; 导入配置类，在这些配置类中加载 &lt;code&gt;@Enable&lt;/code&gt; 模块需要的组件。&lt;/p&gt;
&lt;h2 id=&quot;自动装配正文&quot;&gt;2、自动装配正文&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;https://www.cnblogs.com/loongk/p/11973642.html&quot;&gt;《SpringBoot（二）自动装配正文》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;SpringBoot&lt;/code&gt; 时代，通过一个main方法就可以启动一个应用，其底层依赖的就是 &lt;code&gt;Spring&lt;/code&gt; 几个注解。从 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 注解中的 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 注解开始，&lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 属于 &lt;code&gt;Spring&lt;/code&gt; 的 &lt;code&gt;@Enable&lt;/code&gt; 模块注解，在该注解中通过 &lt;code&gt;@Import&lt;/code&gt; 导入 &lt;code&gt;AutoConfigurationImportSelector&lt;/code&gt; 类，在该类中加载所有以 &lt;code&gt;AutoConfiguration&lt;/code&gt; 为后缀且标注 &lt;code&gt;@Configuration&lt;/code&gt; 注解的自动配置类，每个自动配置类可以装配一个外部模块，如 Web MVC 模块对应的配置类是 &lt;code&gt;WebMvcAutoConfiguration&lt;/code&gt; 。在自动配置类中又有众多 &lt;code&gt;@Conditional&lt;/code&gt; 条件注解，可达到灵活装配的目的。&lt;/p&gt;
&lt;h2 id=&quot;springapplication启动类准备阶段&quot;&gt;3、SpringApplication启动类准备阶段&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;https://www.cnblogs.com/loongk/p/11973665.html&quot;&gt;《SpringBoot（三）SpringApplication启动类准备阶段》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在构造 &lt;code&gt;SpringApplication&lt;/code&gt; 启动类时，初始化了几个重要的类，如 &lt;code&gt;WebApplicationType&lt;/code&gt; 、&lt;code&gt;ApplicationContextInitializer&lt;/code&gt;、&lt;code&gt;ApplicationListener&lt;/code&gt;。其中 &lt;code&gt;WebApplicationType&lt;/code&gt; 存储的是当前应用类型，如 Servlet Web 、Reactive Web； &lt;code&gt;ApplicationContextInitializer&lt;/code&gt; 和 &lt;code&gt;ApplicationListener&lt;/code&gt; 则是 &lt;code&gt;SpringBoot&lt;/code&gt; 通过扩展 Spring 特性创建的初始化器及监听器。&lt;/p&gt;
&lt;h2 id=&quot;springapplication启动类运行阶段&quot;&gt;4、SpringApplication启动类运行阶段&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;https://www.cnblogs.com/loongk/p/12006840.html&quot;&gt;《SpringBoot（四）SpringApplication启动类运行阶段》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;SpringApplication&lt;/code&gt; 运行阶段中，先是通过扩展 &lt;code&gt;Spring&lt;/code&gt; 监听机制，在 &lt;code&gt;SpringBoot&lt;/code&gt; 各个阶段发布不同事件，执行多个事件监听器；然后创建 &lt;code&gt;Environment&lt;/code&gt; 类，这是外部化配置的核心类；最后启动 &lt;code&gt;Spring&lt;/code&gt; 容器，通过 &lt;code&gt;WebApplicationType&lt;/code&gt; 判定当前应用类型，创建应用对应 &lt;code&gt;ApplicationContext&lt;/code&gt; 应用上下文，再调用 &lt;code&gt;ApplicationContext#refresh&lt;/code&gt; 方法启动容器。&lt;/p&gt;
&lt;h2 id=&quot;外部化配置之environment&quot;&gt;5、外部化配置之Environment&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;https://www.cnblogs.com/loongk/p/12046582.html&quot;&gt;《SpringBoot（五）外部化配置之Environment》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章介绍了外部化配置的几种资源类型，如 properties、YAML、环境变量、系统属性、启动参数等。还详细介绍了 &lt;code&gt;Environment&lt;/code&gt; 类，该类是外部化配置核心类，所有外部化配置数据，都保存在该类中，并和大家讨论了整个存储流程。&lt;/p&gt;
&lt;h2 id=&quot;外部化配置之configurationproperties&quot;&gt;6、外部化配置之@ConfigurationProperties&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;https://www.cnblogs.com/loongk/p/12076402.html&quot;&gt;《SpringBoot（六）外部化配置之@ConfigurationProperties》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 是 &lt;code&gt;SpringBoot&lt;/code&gt; 实现外部化配置的重要注解，配合 &lt;code&gt;SprinBoot&lt;/code&gt; 自动装配特性来达到快速开发的目的。主要将 properties 配置文件和 Properties 配置类中的属性进行映射，同样也和大家讨论了整个映射流程。&lt;/p&gt;
&lt;h2 id=&quot;嵌入式web容器&quot;&gt;7、嵌入式Web容器&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;https://www.cnblogs.com/loongk/p/12112320.html&quot;&gt;《SpringBoot（七）嵌入式Web容器》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章详细讨论了容器的创建及启动。传统 &lt;code&gt;Spring&lt;/code&gt; 应用需手动创建和启动 Web 容器，在 &lt;code&gt;SpringBoot&lt;/code&gt; 中，则是嵌入式的方式自动创建和启动。&lt;code&gt;SpringBoot&lt;/code&gt; 支持的 Web 容器类型有 Servlet Web 容器和 Reactive Web 容器，它们都有具体容器实现，Sevlet Web 对应的是 &lt;code&gt;Tomcat&lt;/code&gt;、&lt;code&gt;Jetty&lt;/code&gt;、&lt;code&gt;Undertow&lt;/code&gt;，默认实现是 &lt;code&gt;Tomcat&lt;/code&gt;；Reactive Web 对应的是 &lt;code&gt;Netty&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;starter机制之自定义starter&quot;&gt;8、Starter机制之自定义Starter&lt;/h2&gt;
&lt;p&gt;详见&lt;a href=&quot;https://www.cnblogs.com/loongk/p/12129529.html&quot;&gt;《SpringBoot（八）Starter机制之自定义Starter》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这篇文章详细介绍了 &lt;code&gt;SpringBoot&lt;/code&gt; 的 &lt;code&gt;Starter&lt;/code&gt; 机制，并通过自定义 &lt;code&gt;Starter&lt;/code&gt; 来深入理解整个运行机制。&lt;code&gt;Starter&lt;/code&gt; 也是 &lt;code&gt;SpringBoot&lt;/code&gt; 重要特性，通过集成 &lt;code&gt;Starter&lt;/code&gt; 依赖，来简化项目搭建以及开发过程。&lt;/p&gt;

&lt;p&gt;总结篇就到这里结束，最后，江湖路远，我们，下个系列见。&lt;/p&gt;
</description>
<pubDate>Tue, 07 Jan 2020 15:31:00 +0000</pubDate>
<dc:creator>龙四丶</dc:creator>
<og:description>时至今日，SpringBoot 系列文章也算是告一段落，回想起当初立flag的情景，仿佛还历历在目。用一个月时间学完 SpringBoot 并整理成文章？又定一些异想天开计划，当时这样想着。不过，虽然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/loongk/p/12164334.html</dc:identifier>
</item>
<item>
<title>性能数据的准备-Jmeter - 测试酱</title>
<link>http://www.cnblogs.com/rachelxiao/p/12164259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rachelxiao/p/12164259.html</guid>
<description>&lt;p&gt;性能测试的一般流程：&lt;/p&gt;
&lt;p&gt;收集性能需求——&amp;gt;编写性能脚本——&amp;gt;执行性能测试——&amp;gt;分析测试报告——&amp;gt;系统性能调优&lt;/p&gt;
&lt;p&gt;在收集性能需求后，我们会思考：&lt;/p&gt;
&lt;p&gt;负载测试时并发时需要多少数据？例：登录&lt;/p&gt;
&lt;p&gt;DB数据是否和线上接近？&lt;/p&gt;
&lt;p&gt;所以——我们需要在测试前批量造一批数据进行性能测试&lt;/p&gt;
&lt;p&gt;性能数据有个重要的点：&lt;strong&gt;数据必须带有特殊标记，方便与其他正常数据隔离并且在测试完成后销毁。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不同公司的性能数据不一样，这里我讲一下最常见的两种制造方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、数据库直接插入性能测试数据&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先下载一个&lt;strong&gt;mysql的jar包&lt;/strong&gt;放到jmeter安装目录的lib下或者直接在测试计划处引用&lt;/p&gt;

&lt;div readability=&quot;14.5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1846887/202001/1846887-20200107225618570-361720450.png&quot; alt=&quot;&quot;/&gt;
&lt;p&gt;然后新建一个&lt;strong&gt;jdbc connection configration&lt;/strong&gt;,连接目标数据库，需要填写数据库ip+端口号，用户名和密码（改用户需有修改的权限）&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1846887/202001/1846887-20200107225911053-151200467.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;创建一个&lt;strong&gt;jdbc request&lt;/strong&gt;,把需要插入的数据库语句附上，并且把需要动态修改的参数（类似用户名）&lt;strong&gt;参数化&lt;/strong&gt;：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1846887/202001/1846887-20200107225959872-1613374913.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;新增一个&lt;strong&gt;用户自定义变量&lt;/strong&gt;，将参数化的变量写入，并且通过函数助手生成随机数，变量我以&lt;strong&gt;rac为标记&lt;/strong&gt;，性能测试完成便于删除这些脏数据。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1846887/202001/1846887-20200107230050413-2114925843.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/F00EADACBC3E4FDEAD966EA2D46316DD&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div readability=&quot;12.5&quot;&gt;
&lt;p&gt;最后在&lt;strong&gt;线程组&lt;/strong&gt;输入你需要创建的数据个数就可以啦～&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;我比较喜欢用&lt;strong&gt;循环控制器&lt;/strong&gt;，看起来比较简洁～&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;通过数据库插入的方式造数据的方式，sql厉害的童鞋也可以写&lt;strong&gt;存储过程&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;2、批量轮询跑接口造数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最简洁的版本，只跑一个接口造数据：&lt;/p&gt;
&lt;p&gt;将自己需要创建的用户名+密码放在一个&lt;strong&gt;csv&lt;/strong&gt;文件里面，通过&lt;strong&gt;csv data config&lt;/strong&gt;参数化获取uname，pass&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1846887/202001/1846887-20200107230921707-1627387515.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;

&lt;p&gt;创建一个&lt;strong&gt;http请求&lt;/strong&gt;，在注册用户的接口data处参数化用户名和密码：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1846887/202001/1846887-20200107231026329-1179715695.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;最后一步，&lt;strong&gt;线程组设置csv文件里的用户数&lt;/strong&gt;，跑一遍后就创建了一批性能测试用户啦！&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;当然，这只是最基础版本的。&lt;strong&gt;通常的测试数据都关联多张表&lt;/strong&gt;，所以我们需要给每个用户跑多个接口，那么这个时候，我们就需要参数关联这个秘诀了——&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;首先同上，添加一个csv data config，将创建的性能测试数据的用户名，密码的csv文件添加进去&lt;/p&gt;
&lt;p&gt;新建一个http请求，放登录接口，参数化登录名和密码，从性能测试用户的csv文件中动态获取&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1846887/202001/1846887-20200107231143089-748322476.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;登录成功后，需要获取到token作为其他接口造数据的关键！常用postman调接口的开发大哥都知道token的重要性，通行证呀！&lt;/p&gt;
&lt;p&gt;通过&lt;strong&gt;正则表达提取器获取到token&lt;/strong&gt;后放到&lt;strong&gt;公共信息头管理器&lt;/strong&gt;中。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1846887/202001/1846887-20200107231305751-637429813.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后添加几个http请求，将造数据需要的接口写入即可&lt;/strong&gt;～&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这次先介绍这两种方式，后续持续更新。&lt;/p&gt;
&lt;p&gt;其实有写python版本的，后续放在对应的分类里面做链接～&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/445C2F5F6C9A4414AEAE95EBF89C319D&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Tue, 07 Jan 2020 15:25:00 +0000</pubDate>
<dc:creator>测试酱</dc:creator>
<og:description>性能测试的一般流程： 收集性能需求——&amp;gt;编写性能脚本——&amp;gt;执行性能测试——&amp;gt;分析测试报告——&amp;gt;系统性能调优 在收集性能需求后，我们会思考： 负载测试时并发时需要多少数据？例：登</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rachelxiao/p/12164259.html</dc:identifier>
</item>
</channel>
</rss>