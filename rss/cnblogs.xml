<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>针对.NET Core, Xamarin以及.NET的自动类型安全Rest库： Refit - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10817537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10817537.html</guid>
<description>&lt;p&gt;本文大部分内容是针对Refit官网的翻译。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5686274509804&quot;&gt;
&lt;p&gt;官网地址： &lt;a href=&quot;https://github.com/reactiveui/refit&quot; class=&quot;uri&quot;&gt;https://github.com/reactiveui/refit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Refit是一个类似于Retrofit的Restful Api库，使用它，你可以将你的Restful Api定义在接口中。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IGitHubApi
{
    [Get(&quot;/users/{user}&quot;)]
    Task&amp;lt;User&amp;gt; GetUser(string user);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;RestService&lt;/code&gt;类生成了一个&lt;code&gt;IGitHubApi&lt;/code&gt;接口的实现，它使用&lt;code&gt;HttpClient&lt;/code&gt;来进行api调用。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var gitHubApi = RestService.For&amp;lt;IGitHubApi&amp;gt;(&quot;https://api.github.com&quot;);

var octocat = await gitHubApi.GetUser(&quot;octocat&quot;);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;当前Refit支持一下平台。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UWP&lt;/li&gt;
&lt;li&gt;Xamarin.Android&lt;/li&gt;
&lt;li&gt;Xamarin.Mac&lt;/li&gt;
&lt;li&gt;Xamarin.iOS&lt;/li&gt;
&lt;li&gt;Desktop .NET 4.6.1&lt;/li&gt;
&lt;li&gt;.NET Core&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;.NET Core的注意事项：&lt;/p&gt;
&lt;p&gt;对于.NET Core的构建时支持(Build-Time support), 你必须使用.NET Core 2.x SDK。你可以针对所有的支持平台构建你的库，只要构建时使用2.x SDK即可。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;基本用法&quot;&gt;基本用法&lt;/h2&gt;
&lt;p&gt;针对每个方法都必须提供一个HTTP属性，这个属性指定了请求的方式和相关的URL。这里有6种内置的批注：Get, Post, Put, Delete, Patch和Head。在批注中需要指定资源对应的URL。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Get(&quot;/users/list&quot;)]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你同样可以指定URL中的查询字符串。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Get(&quot;/users/list?sort=desc&quot;)]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;动态url&quot;&gt;动态URL&lt;/h2&gt;
&lt;p&gt;你还可以使用可替换块（replacement block）和方法参数创建动态URL。这里可替换块是一个被大括号包裹的字符串变量。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Get(&quot;/group/{id}/users&quot;)]
Task&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; GroupList([AliasAs(&quot;id&quot;)] int groupId);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;URL中没有指定的参数，就会自动作为URL的查询字符串。这与Retrofit不同，在Retrofit中所有参数都必须显示指定。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Get(&quot;/group/{id}/users&quot;)]
Task&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; GroupList([AliasAs(&quot;id&quot;)] int groupId, [AliasAs(&quot;sort&quot;)] string sortOrder);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里当调用&lt;code&gt;GroupList(4, &quot;desc&quot;);&lt;/code&gt;方法时，调用API会是&lt;code&gt;&quot;/group/4/users?sort=desc&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;回转路由语法&quot;&gt;回转路由语法&lt;/h2&gt;
&lt;p&gt;回转路由参数语法：使用双星号的捕获所有参数(catch-all parameter)且不会对&quot;/&quot;进行编码，&lt;/p&gt;
&lt;p&gt;在生成链接的过程, 路由系统将编码双星号捕获的全部参数(catch-all parameter)，而不会编码&quot;/&quot;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Get(&quot;/search/{**page}&quot;)]
Task&amp;lt;List&amp;lt;Page&amp;gt;&amp;gt; Search(string page);&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;回转路由参数必须是字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里当调用&lt;code&gt;Search(&quot;admin/products&quot;);&lt;/code&gt;时，生成的连接是&lt;code&gt;&quot;/search/admin/products&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当你指定一个对象作为查询参数的时候，所有非空的public属性将被用作查询参数。使用&lt;code&gt;Query&lt;/code&gt;特性将改变默认的行为，它会扁平化你的查询字符串对象。如果使用&lt;code&gt;Query&lt;/code&gt;特性，你还可以针对扁平化查询字符串对象添加指定的分隔符和前缀。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class MyQueryParams
{
    [AliasAs(&quot;order&quot;)]
    public string SortOrder { get; set; }

    public int Limit { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;普通的扁平化查询字符串对象：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Get(&quot;/group/{id}/users&quot;)]
Task&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; GroupList([AliasAs(&quot;id&quot;)] int groupId, MyQueryParams params);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;扁平化查询字符串对象并附加分隔符和前缀&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Get(&quot;/group/{id}/users&quot;)]
Task&amp;lt;List&amp;lt;User&amp;gt;&amp;gt; GroupListWithAttribute([AliasAs(&quot;id&quot;)] int groupId, [Query(&quot;.&quot;,&quot;search&quot;)] MyQueryParams params);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码调用及结果。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;params.SortOrder = &quot;desc&quot;;
params.Limit = 10;

GroupList(4, params)
//结果 &quot;/group/4/users?order=desc&amp;amp;Limit=10&quot;

GroupListWithAttribute(4, params)
//结果 &quot;/group/4/users?search.order=desc&amp;amp;search.Limit=10&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Query&lt;/code&gt;特性同样可以指定查询字符串中应该如何格式化集合对象。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Get(&quot;/users/list&quot;)]
Task Search([Query(CollectionFormat.Multi)]int[] ages);

Search(new [] {10, 20, 30})
//结果 &quot;/users/list?ages=10&amp;amp;ages=20&amp;amp;ages=30&quot;

[Get(&quot;/users/list&quot;)]
Task Search([Query(CollectionFormat.Csv)]int[] ages);

Search(new [] {10, 20, 30})
//结果 &quot;/users/list?ages=10%2C20%2C30&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在你的方法签名中，你还可以将使用&lt;code&gt;Body&lt;/code&gt;特性将参数中的一个标记为正文内容。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Post(&quot;/users/new&quot;)]
Task CreateUser([Body] User user);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里Refit支持4种请求体数据&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果正文内容类型是&lt;code&gt;Stream&lt;/code&gt;, 其内容会包裹在一个&lt;code&gt;StreamContent&lt;/code&gt;对象中。&lt;/li&gt;
&lt;li&gt;如果正文内容类型是&lt;code&gt;string&lt;/code&gt;, 其内容会直接用作正文内容。当指定当前参数拥有特性&lt;code&gt;[Body(BodySerializationMethod.Json)]&lt;/code&gt;时，它会被包裹在一个&lt;code&gt;StringContent&lt;/code&gt;对象中。&lt;/li&gt;
&lt;li&gt;如果当前参数拥有特性&lt;code&gt;[Body(BodySerializationMethod.UrlEncoded)]&lt;/code&gt;, 其内容会被URL编码。&lt;/li&gt;
&lt;li&gt;针对其他类型，当前指定的参数会被默认序列化成JSON。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认情况下，Refit会流式传输正文内容，而不会缓冲它。这意味着，你可以从磁盘流式传输文件，而不产生将整个文件加载到内存中的开销。这样做的缺点是，请求头部没有设置&lt;code&gt;Content-Length&lt;/code&gt;。如果你的API需要发送一个请求并指定&lt;code&gt;Content-Length&lt;/code&gt;请求头，则需要将&lt;code&gt;Body&lt;/code&gt;特性的&lt;code&gt;buffered&lt;/code&gt;参数设置为true。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Task CreateUser([Body(buffered: true)] User user);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;json内容&quot;&gt;Json内容&lt;/h2&gt;
&lt;p&gt;JSON请求和响应可以使用Json.NET来序列化和反序列化，默认情况下，Refit会使用&lt;code&gt;Newtonsoft.Json.JsonConvert.DefaultSettings&lt;/code&gt;的默认序列化配置。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;JsonConvert.DefaultSettings = 
    () =&amp;gt; new JsonSerializerSettings() { 
        ContractResolver = new CamelCasePropertyNamesContractResolver(),
        Converters = {new StringEnumConverter()}
    };

// Serialized as: {&quot;day&quot;:&quot;Saturday&quot;}
await PostSomeStuff(new { Day = DayOfWeek.Saturday });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为默认设置是全局设置，它会影响你的整个应用。所以这里我们最好使用针对特定API使用独立的配置。当使用Refit生成一个接口对象的时候，你可以传入一个&lt;code&gt;RefitSettings&lt;/code&gt;参数，这个参数可以指定你使用的JSON序列化配置。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var gitHubApi = RestService.For&amp;lt;IGitHubApi&amp;gt;(&quot;https://api.github.com&quot;,
    new RefitSettings {
        ContentSerializer = new JsonContentSerializer( 
            new JsonSerializerSettings {
                ContractResolver = new SnakeCasePropertyNamesContractResolver()
        }
    )});

var otherApi = RestService.For&amp;lt;IOtherApi&amp;gt;(&quot;https://api.example.com&quot;,
    new RefitSettings {
        ContentSerializer = new JsonContentSerializer( 
            new JsonSerializerSettings {
                ContractResolver = new CamelCasePropertyNamesContractResolver()
        }
    )});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对自定义属性的序列化和反序列化，我们同样可以使用Json.NET的&lt;code&gt;JsonProperty&lt;/code&gt;属性。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Foo 
{
    // Works like [AliasAs(&quot;b&quot;)] would in form posts (see below)
    [JsonProperty(PropertyName=&quot;b&quot;)] 
    public string Bar { get; set; }
} &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;xml内容&quot;&gt;Xml内容&lt;/h2&gt;
&lt;p&gt;针对XML请求和响应的序列化和反序列化，Refit使用了&lt;code&gt;System.Xml.Serialization.XmlSerializer&lt;/code&gt;。默认情况下， Refit会使用JSON内容序列化器，如果想要使用XML内容序列化器，你需要将&lt;code&gt;RefitSetting&lt;/code&gt;的&lt;code&gt;ContentSerializer&lt;/code&gt;属性指定为&lt;code&gt;XmlContentSerializer&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var gitHubApi = RestService.For&amp;lt;IXmlApi&amp;gt;(&quot;https://www.w3.org/XML&quot;,
    new RefitSettings {
        ContentSerializer = new XmlContentSerializer()
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们同样可以使用&lt;code&gt;System.Xml.Serialization&lt;/code&gt;命名空间下的特性，自定义属性的序列化和反序列化。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Foo
{
    [XmlElement(Namespace = &quot;https://www.w3.org/XML&quot;)]
    public string Bar { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;System.Xml.Serialization.XmlSerializer&lt;/code&gt;提供了多种序列化方式，你可以通过在&lt;code&gt;XmlContentSerialier&lt;/code&gt;对象的构造函数中指定一个&lt;code&gt;XmlContentSerializerSettings&lt;/code&gt; 对象类进行配置。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var gitHubApi = RestService.For&amp;lt;IXmlApi&amp;gt;(&quot;https://www.w3.org/XML&quot;,
    new RefitSettings {
        ContentSerializer = new XmlContentSerializer(
            new XmlContentSerializerSettings
            {
                XmlReaderWriterSettings = new XmlReaderWriterSettings()
                {
                    ReaderSettings = new XmlReaderSettings
                    {
                        IgnoreWhitespace = true
                    }
                }
            }
        )
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;表单post&quot;&gt;表单Post&lt;/h2&gt;
&lt;p&gt;针对采用表单Post的API( 正文会被序列化成application/x-www-form-urlencoded ), 我们可以将指定参数的正文特性指定为&lt;code&gt;BodySerializationMethod.UrlEncoded&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个参数可以是字典&lt;code&gt;IDictionary&lt;/code&gt;接口对象。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IMeasurementProtocolApi
{
    [Post(&quot;/collect&quot;)]
    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Dictionary&amp;lt;string, object&amp;gt; data);
}

var data = new Dictionary&amp;lt;string, object&amp;gt; {
    {&quot;v&quot;, 1}, 
    {&quot;tid&quot;, &quot;UA-1234-5&quot;}, 
    {&quot;cid&quot;, new Guid(&quot;d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&quot;)}, 
    {&quot;t&quot;, &quot;event&quot;},
};

// 序列化为: v=1&amp;amp;tid=UA-1234-5&amp;amp;cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&amp;amp;t=event
await api.Collect(data);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然参数也可以是一个普通对象，Refit会将对象中所有public, 可读取的属性序列化成表单字段。当然这里你可以使用&lt;code&gt;AliasAs&lt;/code&gt;特性，为序列化的表单字段起别名。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface IMeasurementProtocolApi
{
    [Post(&quot;/collect&quot;)]
    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Measurement measurement);
}

public class Measurement
{
    // Properties can be read-only and [AliasAs] isn't required
    public int v { get { return 1; } }
 
    [AliasAs(&quot;tid&quot;)]
    public string WebPropertyId { get; set; }

    [AliasAs(&quot;cid&quot;)]
    public Guid ClientId { get; set; }

    [AliasAs(&quot;t&quot;)] 
    public string Type { get; set; }

    public object IgnoreMe { private get; set; }
}

var measurement = new Measurement { 
    WebPropertyId = &quot;UA-1234-5&quot;, 
    ClientId = new Guid(&quot;d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&quot;), 
    Type = &quot;event&quot; 
}; 

// 序列化为: v=1&amp;amp;tid=UA-1234-5&amp;amp;cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&amp;amp;t=event
await api.Collect(measurement);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果当前属性同时指定了&lt;code&gt;[JsonProperty(PropertyName)]&lt;/code&gt; 和&lt;code&gt;AliasAs()&lt;/code&gt;, Refit会优先使用&lt;code&gt;AliasAs()&lt;/code&gt; 中指定的名称。这意味着，以下类型会被序列化成&lt;code&gt;one=value1&amp;amp;two=value2&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class SomeObject
{
    [JsonProperty(PropertyName = &quot;one&quot;)]
    public string FirstProperty { get; set; }

    [JsonProperty(PropertyName = &quot;notTwo&quot;)]
    [AliasAs(&quot;two&quot;)]
    public string SecondProperty { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意： &lt;code&gt;AliasAs&lt;/code&gt;只能应用在请求参数和Form正文Post中，不能应用于响应对象。如果要为响应对象属性起别名，你依然需要使用&lt;code&gt;[JsonProperty(&quot;full-property-name&quot;)]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;静态头&quot;&gt;静态头&lt;/h2&gt;
&lt;p&gt;你可以使用&lt;code&gt;Headers&lt;/code&gt;特性指定一个或多个静态的请求头。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Headers(&quot;User-Agent: Awesome Octocat App&quot;)]
[Get(&quot;/users/{user}&quot;)]
Task&amp;lt;User&amp;gt; GetUser(string user);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了简便使用，你也可以将&lt;code&gt;Headers&lt;/code&gt;特性放在接口定义上，从而使当前接口中定义的所有Rest请求都添加相同的静态头。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Headers(&quot;User-Agent: Awesome Octocat App&quot;)]
public interface IGitHubApi
{
    [Get(&quot;/users/{user}&quot;)]
    Task&amp;lt;User&amp;gt; GetUser(string user);
    
    [Post(&quot;/users/new&quot;)]
    Task CreateUser([Body] User user);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;动态头&quot;&gt;动态头&lt;/h2&gt;
&lt;p&gt;如果头部内容需要在运行时动态设置，你可以在方法签名处，使用&lt;code&gt;Header&lt;/code&gt;特性指定一个动态头部参数，你可以在调用Api时，为这个参数指定一个&lt;code&gt;dynamic&lt;/code&gt;类型的值，从而实现动态头。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[Get(&quot;/users/{user}&quot;)]
Task&amp;lt;User&amp;gt; GetUser(string user, [Header(&quot;Authorization&quot;)] string authorization);

// Will add the header &quot;Authorization: token OAUTH-TOKEN&quot; to the request
var user = await GetUser(&quot;octocat&quot;, &quot;token OAUTH-TOKEN&quot;); &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;授权动态头的升级版&quot;&gt;授权(动态头的升级版)&lt;/h2&gt;
&lt;p&gt;使用请求头的最常见场景就是授权。当今绝大多数的API都是使用OAuth, 它会提供一个带过期时间的access token和一个负责刷新access token的refresh token。&lt;/p&gt;
&lt;p&gt;为了封装这些授权令牌的使用，我们可以自定义一个&lt;code&gt;HttpClientHandler&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class AuthenticatedHttpClientHandler : HttpClientHandler
{
    private readonly Func&amp;lt;Task&amp;lt;string&amp;gt;&amp;gt; getToken;

    public AuthenticatedHttpClientHandler(Func&amp;lt;Task&amp;lt;string&amp;gt;&amp;gt; getToken)
    {
        if (getToken == null) throw new ArgumentNullException(nameof(getToken));
        this.getToken = getToken;
    }

    protected override async Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        // See if the request has an authorize header
        var auth = request.Headers.Authorization;
        if (auth != null)
        {
            var token = await getToken().ConfigureAwait(false);
            request.Headers.Authorization = new AuthenticationHeaderValue(auth.Scheme, token);
        }

        return await base.SendAsync(request, cancellationToken).ConfigureAwait(false);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然&lt;code&gt;HttpClient&lt;/code&gt;包含了几乎相同的方法签名，但是它的使用方式不同。Refit不会调用&lt;code&gt;HttpClient.SendAsync&lt;/code&gt;方法，这里必须使用自定义的&lt;code&gt;HttpClientHandler&lt;/code&gt;替换它。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class LoginViewModel
{
    AuthenticationContext context = new AuthenticationContext(...);
    
    private async Task&amp;lt;string&amp;gt; GetToken()
    {
        // The AcquireTokenAsync call will prompt with a UI if necessary
        // Or otherwise silently use a refresh token to return
        // a valid access token 
        var token = await context.AcquireTokenAsync(&quot;http://my.service.uri/app&quot;, &quot;clientId&quot;, new Uri(&quot;callback://complete&quot;));
        
        return token;
    }

    public async Task LoginAndCallApi()
    {
        var api = RestService.For&amp;lt;IMyRestService&amp;gt;(new HttpClient(new AuthenticatedHttpClientHandler(GetToken)) { BaseAddress = new Uri(&quot;https://the.end.point/&quot;) });
        var location = await api.GetLocationOfRebelBase();
    }
}

interface IMyRestService
{
    [Get(&quot;/getPublicInfo&quot;)]
    Task&amp;lt;Foobar&amp;gt; SomePublicMethod();

    [Get(&quot;/secretStuff&quot;)]
    [Headers(&quot;Authorization: Bearer&quot;)]
    Task&amp;lt;Location&amp;gt; GetLocationOfRebelBase();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在以上代码中，当任何需要身份验证的的方法被调用的时候，&lt;code&gt;AuthenticatedHttpClientHandler&lt;/code&gt;会尝试获取一个新的access token。 这里程序会检查access token是否到期，并在需要时获取新的令牌。&lt;/p&gt;

&lt;p&gt;当一个接口方法被指定为&lt;code&gt;[Multipart]&lt;/code&gt;, 这意味着当前Api提交的内容中包含分段内容类型。针对分段方法，Refit当前支持一下几种参数类型&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符串&lt;/li&gt;
&lt;li&gt;二进制数组&lt;/li&gt;
&lt;li&gt;Stream流&lt;/li&gt;
&lt;li&gt;FileInfo&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里参数名会作为分段数据的字段名。当然你可以用&lt;code&gt;AliasAs&lt;/code&gt;特性复写它。&lt;/p&gt;
&lt;p&gt;为了给二进制数组，Stream流以及FileInfo参数的内容指定文件名和内容类型，我们必须要使用封装类。Refit中默认的封装类有3种，&lt;code&gt;ByteArrarPart&lt;/code&gt;, &lt;code&gt;StreamPart&lt;/code&gt;, &lt;code&gt;FileInfoPart&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface ISomeApi
{
    [Multipart]
    [Post(&quot;/users/{id}/photo&quot;)]
    Task UploadPhoto(int id, [AliasAs(&quot;myPhoto&quot;)] StreamPart stream);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了将一个Stream流对象传递给以上定义的方法，我们需要构建一个&lt;code&gt;StreamObject&lt;/code&gt;对象：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;someApiInstance.UploadPhoto(id, new StreamPart(myPhotoStream, &quot;photo.jpg&quot;, &quot;image/jpeg&quot;));&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;为了封装可能来自服务的任何异常，你可以捕获包含请求和响应信息的&lt;code&gt;ApiException&lt;/code&gt;。 Refit还支持捕获由于不良请求而引发的验证异常，以解决问题详细信息。 有关验证异常的问题详细信息的特定信息，只需捕获&lt;code&gt;ValidationApiException&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// ...
try
{
   var result = await awesomeApi.GetFooAsync(&quot;bar&quot;);
}
catch (ValidationApiException validationException)
{
   // handle validation here by using validationException.Content, 
   // which is type of ProblemDetails according to RFC 7807
}
catch (ApiException exception)
{
   // other exception handling
}
// ...&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 05 May 2019 23:13:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>本文大部分内容是针对Refit官网的翻译。 官网地址： Refit是一个类似于Retrofit的Restful Api库，使用它，你可以将你的Restful Api定义在接口中。 例如： 这里 类生成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10817537.html</dc:identifier>
</item>
<item>
<title>CSharpGL(54)用基于图像的光照(IBL)来计算PBR的Specular部分 - BIT祝威</title>
<link>http://www.cnblogs.com/bitzhuwei/p/specular-IBL.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bitzhuwei/p/specular-IBL.html</guid>
<description>&lt;p&gt;&lt;span&gt;CSharpGL(54)用基于图像的光照(IBL)来计算PBR的Specular部分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来本系列将通过翻译（&lt;a href=&quot;https://learnopengl.com/&quot;&gt;https://learnopengl.com&lt;/a&gt;）这个网站上关于PBR的内容来学习PBR（Physically Based Rendering）。&lt;/p&gt;
&lt;p&gt;本文对应（&lt;a href=&quot;https://learnopengl.com/PBR/IBL/Specular-IBL&quot;&gt;https://learnopengl.com/PBR/IBL/Specular-IBL&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;原文虽然写得挺好，但是仍旧不够人性化。过一阵我自己总结总结PBR，写一篇更容易理解的。 &lt;/p&gt;

&lt;p&gt;In the &lt;a href=&quot;https://learnopengl.com/#!PBR/IBL/Diffuse-irradiance&quot; target=&quot;_blank&quot;&gt;previous&lt;/a&gt; tutorial we've set up PBR in combination with image based lighting by pre-computing an irradiance map as the lighting's indirect diffuse portion. In this tutorial we'll focus on the specular part of the reflectance equation:&lt;/p&gt;
&lt;p&gt;在上一篇教程中我们已经用IBL（基于图像的光照）来解决了PBR的一个问题：用预计算的辐照度贴图作为非直接光照的diffuse部分。在本教程中我们将关注反射率方程中的speclar部分。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023147480-670290819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;You'll notice that the Cook-Torrance specular portion (multiplied by kS) isn't constant over the integral and is dependent on the incoming light direction, but &lt;strong&gt;also&lt;/strong&gt; the incoming view direction. Trying to solve the integral for all incoming light directions including all possible view directions is a combinatorial overload and way too expensive to calculate on a real-time basis. Epic Games proposed a solution where they were able to pre-convolute the specular part for real time purposes, given a few compromises, known as the split sum approximation.&lt;/p&gt;
&lt;p&gt;你会注意到Cook-Torrance的specular部分（乘以kS的那个）在积分上不是常量，它既依赖入射光方向，又依赖观察者方向。对所有入射光反向和所有观察者方向的乘积的积分进行求解，是过载又过载，对于实时计算是太过昂贵了。Epic游戏公司提出了一个解决方案（被称为拆分求和近似），用一点妥协，通过预计算卷积实现了specular部分的实时计算。&lt;/p&gt;
&lt;p&gt;The split sum approximation splits the specular part of the reflectance equation into two separate parts that we can individually convolute and later combine in the PBR shader for specular indirect image based lighting. Similar to how we pre-convoluted the irradiance map, the split sum approximation requires an HDR environment map as its convolution input. To understand the split sum approximation we'll again look at the reflectance equation, but this time only focus on the specular part (we've extracted the diffuse part in the &lt;a href=&quot;https://learnopengl.com/#!PBR/IBL/Diffuse-irradiance&quot; target=&quot;_blank&quot;&gt;previous&lt;/a&gt; tutorial):&lt;/p&gt;
&lt;p&gt;拆分求和近似方案，将反射率方程的specular部分拆分为两个单独的部分，我们可以分别对齐进行卷积，之后再结合起来。在shader中可以实现这样的specular的IBL。与我们预计算辐照度贴图相似，拆分求和近似方案需要一个HDR环境贴图作为输入。为了理解这个方案，我们再看一下反射率方程，但这次只关注specular部分（我们已经在上一篇教程中分离出了diffuse部分）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023155529-1091118219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;For the same (performance) reasons as the irradiance convolution, we can't solve the specular part of the integral in real time and expect a reasonable performance. So preferably we'd pre-compute this integral to get something like a specular IBL map, sample this map with the fragment's normal and be done with it. However, this is where it gets a bit tricky. We were able to pre-compute the irradiance map as the integral only depended on ωi and we could move the constant diffuse albedo terms out of the integral. This time, the integral depends on more than just ωi as evident from the BRDF:&lt;/p&gt;
&lt;p&gt;由于和辐照度卷积相同的原因（性能），我们不能实时求解specular部分的积分，还期待一个可接受的性能。所以我们倾向于预计算这个积分，得到某种specular的IBL贴图，用片段的法线在贴图上采样，得到所需结果。但是，这里比较困难。我们能预计算辐照度贴图，是因为它的积分只依赖ωi，而且我们还能吧diffuse颜色项移到积分外面。这次，从BRDF公式上可见，积分不止依赖一个ωi。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023213081-347489420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This time the integral also depends on wo and we can't really sample a pre-computed cubemap with two direction vectors. The position p is irrelevant here as described in the previous tutorial. Pre-computing this integral for every possible combination of ωi and ωo isn't practical in a real-time setting.&lt;/p&gt;
&lt;p&gt;这次，积分还依赖于wo，我们无法对有2个方向向量的预计算cubemap贴图进行采样。这里的位置p是无关的，我们在上一篇教程中讲过。在实时系统中预计算这个积分的ωi和ωo的每种组合，是不实际的。&lt;/p&gt;
&lt;p&gt;Epic Games' split sum approximation solves the issue by splitting the pre-computation into 2 individual parts that we can later combine to get the resulting pre-computed result we're after. The split sum approximation splits the specular integral into two separate integrals:&lt;/p&gt;
&lt;p&gt;Epic游戏公司的拆分求和近似方案解决了这个问题：把预计算拆分为2个互相独立的部分，且之后可以联合起来得到我们需要的预计算结果。拆分求和近似方案将specular积分拆分为2个独立的积分：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023218055-1635719270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The first part (when convoluted) is known as the pre-filtered environment map which is (similar to the irradiance map) a pre-computed environment convolution map, but this time taking roughness into account. For increasing roughness levels, the environment map is convoluted with more scattered sample vectors, creating more blurry reflections. For each roughness level we convolute, we store the sequentially blurrier results in the pre-filtered map's mipmap levels. For instance, a pre-filtered environment map storing the pre-convoluted result of 5 different roughness values in its 5 mipmap levels looks as follows:&lt;/p&gt;
&lt;p&gt;卷积时的第一部分被称为pre-filter环境贴图（类似辐照度贴图），是个预计算的环境卷积贴图，但这次它考虑了粗糙度。对于增长的粗糙度level，环境贴图用更散射的采样向量进行卷积，这造成了更模糊的反射。对我们卷积的每个粗糙度level，我们依次在pre-filter贴图的mipmap层上保存它。例如，一个保存着预计算结果的5个不同粗糙度（用6个mipmap层）的pre-fitler环境贴图如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023223616-940458014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We generate the sample vectors and their scattering strength using the normal distribution function (NDF) of the Cook-Torrance BRDF that takes as input both a normal and view direction. As we don't know beforehand the view direction when convoluting the environment map, Epic Games makes a further approximation by assuming the view direction (and thus the specular reflection direction) is always equal to the output sample direction ωo. This translates itself to the following code:&lt;/p&gt;
&lt;p&gt;Cook-Torrance函数以法线和观察者方向为输入，我们用这个函数生成采样的方向向量和散射强度。卷积环境贴图时，我们无法提前预知观察者方向，Epic游戏公司又做了个近似，假设观察者方向（即specular反射方向）总是等于输出采样方向ωo。相应的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; vec3 N =&lt;span&gt; normalize(w_o);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; vec3 R =&lt;span&gt; N;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; vec3 V = R;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This way the pre-filtered environment convolution doesn't need to be aware of the view direction. This does mean we don't get nice grazing specular reflections when looking at specular surface reflections from an angle as seen in the image below (courtesy of the &lt;em&gt;Moving Frostbite to PBR&lt;/em&gt; article); this is however generally considered a decent compromise:&lt;/p&gt;
&lt;p&gt;这样，pre-filter环境贴图就不需要知道观察者方向。这意味着，在从下图（感谢&lt;em&gt;Moving Frostbite to PBR&lt;/em&gt; 文章）所示的角度观察光滑表面反射时，我们得不到比较好的掠角反射结果。但是这一般被认为是相当好的折衷方案了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023252884-1796042868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The second part of the equation equals the BRDF part of the specular integral. If we pretend the incoming radiance is completely white for every direction (thus L(p,x)=1.0) we can pre-calculate the BRDF's response given an input roughness and an input angle between the normal n and light direction ωi, or n⋅ωi. Epic Games stores the pre-computed BRDF's response to each normal and light direction combination on varying roughness values in a 2D lookup texture (LUT) known as the BRDF integration map. The 2D lookup texture outputs a scale (red) and a bias value (green) to the surface's Fresnel response giving us the second part of the split specular integral:&lt;/p&gt;
&lt;p&gt;方程的第二部分是specular积分的BRDF部分。如果我们假设入射光在所有方向上都是白色（即L(p,x)=1.0），我们就能预计算BRDF对给定粗糙度和入射角（法线n和入射方向ωi的夹角，或n⋅ωi）的返回值。Epic游戏公司保存了预计算的BRDF对每个法线+入射方向组合的返回值，保存到一个二维查询纹理(LUT)上，即BRDF积分贴图。这个二维查询纹理输出的是表面的菲涅耳效应的一个缩放和偏移值，也就是拆分开的specular积分的第二部分。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;（我不懂这是啥）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023301378-1055636818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We generate the lookup texture by treating the horizontal texture coordinate (ranged between &lt;code&gt;0.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt;) of a plane as the BRDF's input n⋅ωi and its vertical texture coordinate as the input roughness value. With this BRDF integration map and the pre-filtered environment map we can combine both to get the result of the specular integral:&lt;/p&gt;
&lt;p&gt;我们将纹理坐标的U（从0.0到1.0）作为BRDF的n⋅ωi参数，将V坐标视为粗糙度参数，以此生成查询纹理。现在我们就可以联合BRDF积分贴图和pre-filter环境贴图来得到specular的积分结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; lod =&lt;span&gt; getMipLevelFromRoughness(roughness);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; vec3 prefilteredColor =&lt;span&gt; textureCubeLod(PrefilteredEnvMap, refVec, lod);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; vec2 envBRDF =&lt;span&gt; texture2D(BRDFIntegrationMap, vec2(NdotV, roughness)).xy;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; vec3 indirectSpecular = prefilteredColor * (F * envBRDF.x + envBRDF.y)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This should give you a bit of an overview on how Epic Games' split sum approximation roughly approaches the indirect specular part of the reflectance equation. Let's now try and build the pre-convoluted parts ourselves.&lt;/p&gt;
&lt;p&gt;这些应该让你大体上理解，Epic游戏公司的拆分求和近似方案是如何计算反射率方程的非直接specular部分的。现在我们试试自己构建预卷积部分。&lt;/p&gt;
&lt;h2&gt;预卷积HDR环境贴图&lt;/h2&gt;
&lt;p&gt;Pre-filtering an environment map is quite similar to how we convoluted an irradiance map. The difference being that we now account for roughness and store sequentially rougher reflections in the pre-filtered map's mip levels.&lt;/p&gt;
&lt;p&gt;预卷积一个环境贴图，与我们卷积辐照度贴图类似。不同点在于，我们现在要考虑粗糙度，并且将越来越粗糙的反射情况依次保存到贴图的各个mipmap层里。&lt;/p&gt;
&lt;p&gt;First, we need to generate a new cubemap to hold the pre-filtered environment map data. To make sure we allocate enough memory for its mip levels we call glGenerateMipmap as an easy way to allocate the required amount of memory.&lt;/p&gt;
&lt;p&gt;首先，我们需要生成一个cubemap对象，用于保存pre-filter的环境贴图数据。为保证我们为它的mipmap层分配了足够的内存，我们使用glGenerateMipmap这一简便方式来分配需要的内存。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; prefilterMap;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; glGenTextures(&lt;span&gt;1&lt;/span&gt;, &amp;amp;&lt;span&gt;prefilterMap);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;glBindTexture(GL_TEXTURE_CUBE_MAP, prefilterMap);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (unsigned &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;6&lt;/span&gt;; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, &lt;span&gt;0&lt;/span&gt;, GL_RGB16F, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;128&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, GL_RGB, GL_FLOAT, nullptr);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR); 
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; glGenerateMipmap(GL_TEXTURE_CUBE_MAP);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that because we plan to sample the &lt;var&gt;prefilterMap&lt;/var&gt; its mipmaps you'll need to make sure its minification filter is set to &lt;var&gt;GL_LINEAR_MIPMAP_LINEAR&lt;/var&gt; to enable trilinear filtering. We store the pre-filtered specular reflections in a per-face resolution of 128 by 128 at its base mip level. This is likely to be enough for most reflections, but if you have a large number of smooth materials (think of car reflections) you may want to increase the resolution.&lt;/p&gt;
&lt;p&gt;注意，因为我们计划对&lt;var&gt;prefilterMap&lt;/var&gt; 的各层mipmap采样，你需要确保它的最小过滤参数设置为&lt;var&gt;GL_LINEAR_MIPMAP_LINEAR&lt;/var&gt; ，这样才能启用三线过滤。以128x128像素为mipmap基层（第一层），我们将pre-filter的反射情况保存到cubemap的各个面上。这对大多数反射情况都足够用，但是如果你有大量光滑材质（例如汽车的反射），你可能需要增加分辨率。&lt;/p&gt;
&lt;p&gt;In the previous tutorial we convoluted the environment map by generating sample vectors uniformly spread over the hemisphere Ω using spherical coordinates. While this works just fine for irradiance, for specular reflections it's less efficient. When it comes to specular reflections, based on the roughness of a surface, the light reflects closely or roughly around a reflection vector r over a normal n, but (unless the surface is extremely rough) around the reflection vector nonetheless:&lt;/p&gt;
&lt;p&gt;在之前的教程中，我们用球坐标均匀地在半球上进行采样，实现了对环境贴图的卷积。虽然这对辐照度贴图很好用，但是对specular反射就不够高效。谈到specular反射时，根据表面粗糙度的不同，the light reflects closely or roughly around a reflection vector r over a normal n, but (unless the surface is extremely rough) around the reflection vector nonetheless:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023446333-2053523319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The general shape of possible outgoing light reflections is known as the specular lobe. As roughness increases, the specular lobe's size increases; and the shape of the specular lobe changes on varying incoming light directions. The shape of the specular lobe is thus highly dependent on the material.&lt;/p&gt;
&lt;p&gt;光反射的可能形状被称为specular叶。随着粗糙度增加，specular叶的尺寸也增加，它的形状随入射光方向而变化。因此它的形状高度依赖材质。&lt;/p&gt;
&lt;p&gt;When it comes to the microsurface model, we can imagine the specular lobe as the reflection orientation about the microfacet halfway vectors given some incoming light direction. Seeing as most light rays end up in a specular lobe reflected around the microfacet halfway vectors it makes sense to generate the sample vectors in a similar fashion as most would otherwise be wasted. This process is known as importance sampling.&lt;/p&gt;
&lt;p&gt;对于微平面模型，我们可以将specular叶想象为，对给定的入射光方向，微平面半向量的朝向。鉴于大多数光线都在specular叶范围内，就可以合理地用这种方式生成采样向量（反正其他被浪费的都是少数）。这个过程被称为重要性采样&lt;/p&gt;
&lt;h2&gt;蒙特卡罗积分和重要性采样&lt;/h2&gt;
&lt;p&gt;To fully get a grasp of importance sampling it's relevant we first delve into the mathematical construct known as Monte Carlo integration. Monte Carlo integration revolves mostly around a combination of statistics and probability theory. Monte Carlo helps us in discretely solving the problem of figuring out some statistic or value of a population without having to take &lt;strong&gt;all&lt;/strong&gt; of the population into consideration.&lt;/p&gt;
&lt;p&gt;为真正理解自行车采样，我们要先研究一些“蒙特卡罗积分”的数学概念。蒙特卡罗积分围绕统计学和概率理论，帮助我们用离散的方式解决统计或求值问题，且不需要考虑所有的样本。&lt;/p&gt;
&lt;p&gt;For instance, let's say you want to count the average height of all citizens of a country. To get your result, you could measure &lt;strong&gt;every&lt;/strong&gt; citizen and average their height which will give you the &lt;strong&gt;exact&lt;/strong&gt; answer you're looking for. However, since most countries have a considerable population this isn't a realistic approach: it would take too much effort and time.&lt;/p&gt;
&lt;p&gt;例如，假设你想统计一个国家的所有国民的平均身高。为得到这个结果，你可以测量每个人，然后得到准确的答案。但是，显示这不可能实现，它太费时间和精力了。&lt;/p&gt;
&lt;p&gt;A different approach is to pick a much smaller &lt;strong&gt;completely random&lt;/strong&gt; (unbiased) subset of this population, measure their height and average the result. This population could be as small as a 100 people. While not as accurate as the exact answer, you'll get an answer that is relatively close to the ground truth. This is known as the law of large numbers. The idea is that if you measure a smaller set of size N of truly random samples from the total population, the result will be relatively close to the true answer and gets closer as the number of samples N increases.&lt;/p&gt;
&lt;p&gt;另一个办法是，挑选一个完全随机的人口子集，测量他们的身高，求平均值。这个子集可能小到100人。虽然不是准确答案，但是相对来说也很接近。这就是“大数定律”。其思想是，如果你测量完整数据的一个完全随机的子集（数量为N），那么结果会相对接近真实答案，且随着N的增加，会更接近。&lt;/p&gt;
&lt;p&gt;Monte Carlo integration builds on this law of large numbers and takes the same approach in solving an integral. Rather than solving an integral for all possible (theoretically infinite) sample values x, simply generate N sample values randomly picked from the total population and average. As N increases we're guaranteed to get a result closer to the exact answer of the integral:&lt;/p&gt;
&lt;p&gt;蒙特卡罗积分基于这个“大数定律”，用它来解决积分问题。与其计算所有可能的（理论上无限的）采样值x，不如简单地随机生成N个采样值，然后求平均值。随着N增加，我们就能保证得到一个越来越接近真实答案的积分结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023458252-1128744155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;To solve the integral, we take N random samples over the population a to b, add them together and divide by the total number of samples to average them. The pdf stands for the probability density function that tells us the probability a specific sample occurs over the total sample set. For instance, the pdf of the height of a population would look a bit like this:&lt;/p&gt;
&lt;p&gt;为求解此积分，我们在a到b之间采集N个随机值，加起来，求平均值。那个pdf代表概率密度函数，它告诉我们一个特定采样值在整个样品集中出现的概率。例如，高度的pdf如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023505173-254949816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;From this graph we can see that if we take any random sample of the population, there is a higher chance of picking a sample of someone of height 1.70, compared to the lower probability of the sample being of height 1.50.&lt;/p&gt;
&lt;p&gt;从此图中我们可以看到，如果我们随机采集一个样品，采到1.70的概率比其他（如1.50）的概率更高。&lt;/p&gt;
&lt;p&gt;When it comes to Monte Carlo integration, some samples might have a higher probability of being generated than others. This is why for any general Monte Carlo estimation we divide or multiply the sampled value by the sample probability according to a pdf. So far, in each of our cases of estimating an integral, the samples we've generated were uniform, having the exact same chance of being generated. Our estimations so far were unbiased, meaning that given an ever-increasing amount of samples we will eventually converge to the &lt;strong&gt;exact&lt;/strong&gt; solution of the integral.&lt;/p&gt;
&lt;p&gt;对于蒙特卡罗积分，有的采样比其他的出现的概率更高。这就是为什么，对于一般的蒙特卡罗估算，我们都用一个pdf概率除采样值。目前为止，对于每种估算积分的情形，我们生成的采样都是均匀的，其生成概率都相同。我们的估算目前没有偏差，也就是说，给你定一个逐步增加的采样量，我们会最终收敛到积分的准确值。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;However, some Monte Carlo estimators are biased, meaning that the generated samples aren't completely random, but focused towards a specific value or direction. These biased Monte Carlo estimators have a faster rate of convergence meaning they can converge to the exact solution at a much faster rate, but due to their biased nature it's likely they won't ever converge to the exact solution. This is generally an acceptable tradeoff, especially in computer graphics, as the exact solution isn't too important as long as the results are visually acceptable. As we'll soon see with importance sampling (which uses a biased estimator) the generated samples are biased towards specific directions in which case we account for this by multiplying or dividing each sample by its corresponding pdf.&lt;/p&gt;
&lt;p&gt;但是，有的蒙特卡罗估算是有偏差的。也就是说，生成的采样值不是完全随机的，而是集中于某个值或方向。这些有偏差的蒙特卡罗估算会更快地收敛，但是收敛结果不是严格准确的。一般这是可接收的折衷，特别是在计算机图形领域，因为严格准确的结果并不重要，只要视觉上可接受就行了。如我们马上将看到的，用重要性采样（使用了一个有片擦汗的估算法）生成的采样值偏向特定的方向。我们通过乘或除每个采样值的pdf来算进这个偏差。&lt;/p&gt;
&lt;p&gt;Monte Carlo integration is quite prevalent in computer graphics as it's a fairly intuitive way to approximate continuous integrals in a discrete and efficient fashion: take any area/volume to sample over (like the hemisphere Ω), generate N amount of random samples within the area/volume and sum and weigh every sample contribution to the final result.&lt;/p&gt;
&lt;p&gt;蒙特卡罗积分在计算机图形学中相当普遍，因为它相当直观地高效地用离散数据近似得到连续积分的值：对任何面积\体积进行采样（例如半球Ω），生成N个随机采样值，求和，评估每个人采样值对最后结果的贡献。&lt;/p&gt;
&lt;p&gt;Monte Carlo integration is an extensive mathematical topic and I won't delve much further into the specifics, but we'll mention that there are also multiple ways of generating the &lt;em&gt;random samples&lt;/em&gt;. By default, each sample is completely (pseudo)random as we're used to, but by utilizing certain properties of semi-random sequences we can generate sample vectors that are still random, but have interesting properties. For instance, we can do Monte Carlo integration on something called low-discrepancy sequences which still generate random samples, but each sample is more evenly distributed:&lt;/p&gt;
&lt;p&gt;蒙特卡罗积分是个广阔的数学话题，我不会再深入探讨它了。但是我们将提到，生成随机采样值的方式是多样的。默认的，每个采样值是完全（伪）随机数，但是通过利用半随机数的某种性质，我们可以生成有有趣性质的随机数。例如，我们里对“低差异序列”进行蒙特卡罗积分，这会生成随机采样值，但是每个采样值都更均匀地分布。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023515402-287833968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;When using a low-discrepancy sequence for generating the Monte Carlo sample vectors, the process is known as Quasi-Monte Carlo integration. Quasi-Monte Carlo methods have a faster rate of convergence which makes them interesting for performance heavy applications.&lt;/p&gt;
&lt;p&gt;当使用低差异序列生成蒙特卡罗采样向量时，这个过程就被称为“准蒙特卡罗积分”。它的收敛速度更快，所以对性能要求严格的应用程序很有吸引力。&lt;/p&gt;
&lt;p&gt;Given our newly obtained knowledge of Monte Carlo and Quasi-Monte Carlo integration, there is an interesting property we can use for an even faster rate of convergence known as importance sampling. We've mentioned it before in this tutorial, but when it comes to specular reflections of light, the reflected light vectors are constrained in a specular lobe with its size determined by the roughness of the surface. Seeing as any (quasi-)randomly generated sample outside the specular lobe isn't relevant to the specular integral it makes sense to focus the sample generation to within the specular lobe, at the cost of making the Monte Carlo estimator biased.&lt;/p&gt;
&lt;p&gt;基于蒙特卡罗和准蒙特卡罗积分的知识，我们可以用一个有趣的性质——重要性采样来得到更快速的收敛。本教程之前提过它，但是对于光的specular反射，反射光向量被束缚在特定的specular叶内，其尺寸由表面的粗糙度决定。鉴于任何（准）随机生成的specular叶外部的采样值都对specular积分没有影响，那么就有理由仅关注specular叶内部的采样值生成。其代价是，蒙特卡罗估算有偏差。&lt;/p&gt;
&lt;p&gt;This is in essence what importance sampling is about: generate sample vectors in some region constrained by the roughness oriented around the microfacet's halfway vector. By combining Quasi-Monte Carlo sampling with a low-discrepancy sequence and biasing the sample vectors using importance sampling we get a high rate of convergence. Because we reach the solution at a faster rate, we'll need less samples to reach an approximation that is sufficient enough. Because of this, the combination even allows graphics applications to solve the specular integral in real-time, albeit it still significantly slower than pre-computing the results.&lt;/p&gt;
&lt;p&gt;重要性采样的本质是：围绕微平面的半角向量，在受粗糙度约束的区域内生成采样向量。通过联合使用低差异序列的准蒙特卡罗采样和使用重要性采样的有偏差的采样向量，我们得到了很快的收敛速度。因为我们接近答案的速度更快，所以我们需要的采样量更少。因此，这一联合方案甚至允许图形应用程序实时计算specular积分，虽然它还是比预计算要慢得多。&lt;/p&gt;
&lt;h2&gt;低差异序列&lt;/h2&gt;
&lt;p&gt;In this tutorial we'll pre-compute the specular portion of the indirect reflectance equation using importance sampling given a random low-discrepancy sequence based on the Quasi-Monte Carlo method. The sequence we'll be using is known as the Hammersley Sequence as carefully described by &lt;a href=&quot;http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html&quot; target=&quot;_blank&quot;&gt;Holger Dammertz&lt;/a&gt;. The Hammersley sequence is based on the Van Der Corpus sequence which mirrors a decimal binary representation around its decimal point.&lt;/p&gt;
&lt;p&gt;在本教程中，我们将预计算非直接反射公式中的specular部分，方式是用基于准蒙特卡罗方法的随机低差异序列的重要性采样。我们要用的序列被称为Hammersley序列，它由&lt;a href=&quot;http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html&quot; target=&quot;_blank&quot;&gt;Holger Dammertz&lt;/a&gt;给出了详尽的描述。Hammersley序列基于Van Der Corpus 序列，它mirrors a decimal binary representation around its decimal point。&lt;/p&gt;
&lt;p&gt;Given some neat bit tricks we can quite efficiently generate the Van Der Corpus sequence in a shader program which we'll use to get a Hammersley sequence sample &lt;var&gt;i&lt;/var&gt; over &lt;code&gt;N&lt;/code&gt; total samples:&lt;/p&gt;
&lt;p&gt;利用一些漂亮的技巧，我们可以用shader程序高效地生成Van Der Corpus序列，然后可以用它得到Hammersley序列（在N个采样中采集i个？）。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; RadicalInverse_VdC(&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; bits) 
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     bits = (bits &amp;lt;&amp;lt; &lt;span&gt;16u&lt;/span&gt;) | (bits &amp;gt;&amp;gt; &lt;span&gt;16u&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     bits = ((bits &amp;amp; &lt;span&gt;0x55555555u&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;1u&lt;/span&gt;) | ((bits &amp;amp; &lt;span&gt;0xAAAAAAAAu&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;1u&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     bits = ((bits &amp;amp; &lt;span&gt;0x33333333u&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;2u&lt;/span&gt;) | ((bits &amp;amp; &lt;span&gt;0xCCCCCCCCu&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;2u&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     bits = ((bits &amp;amp; &lt;span&gt;0x0F0F0F0Fu&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;4u&lt;/span&gt;) | ((bits &amp;amp; &lt;span&gt;0xF0F0F0F0u&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;4u&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     bits = ((bits &amp;amp; &lt;span&gt;0x00FF00FFu&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;8u&lt;/span&gt;) | ((bits &amp;amp; &lt;span&gt;0xFF00FF00u&lt;/span&gt;) &amp;gt;&amp;gt; &lt;span&gt;8u&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;(bits) * &lt;span&gt;2.3283064365386963e-10&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; / 0x100000000&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; vec2 Hammersley(&lt;span&gt;uint&lt;/span&gt; i, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; N)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; vec2(&lt;span&gt;float&lt;/span&gt;(i)/&lt;span&gt;float&lt;/span&gt;&lt;span&gt;(N), RadicalInverse_VdC(i));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The GLSL Hammersley function gives us the low-discrepancy sample &lt;var&gt;i&lt;/var&gt; of the total sample set of size &lt;var&gt;N&lt;/var&gt;.&lt;/p&gt;
&lt;p&gt;GLSL代码的Hammersley 函数，给出数目为N的集合的低差异i次采样。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;不使用位操作的&lt;/strong&gt;Hammersley &lt;strong&gt;序列&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Not all OpenGL related drivers support bit operators (WebGL and OpenGL ES 2.0 for instance) in which case you might want to use an alternative version of the Van Der Corpus Sequence that doesn't rely on bit operators:&lt;/p&gt;
&lt;p&gt;不是所有的OpenGL驱动程序都支持位操作（例如WebGL和OpenGl ES 2.0），所以你可能想用另一个不依赖微操作版本的Van Der Corpus序列：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; VanDerCorpus(&lt;span&gt;uint&lt;/span&gt; n, &lt;span&gt;uint&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; invBase = &lt;span&gt;1.0&lt;/span&gt; / &lt;span&gt;float&lt;/span&gt;(&lt;span&gt;base&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; denom   = &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; result  = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0u&lt;/span&gt;; i &amp;lt; &lt;span&gt;32u&lt;/span&gt;; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(n &amp;gt; &lt;span&gt;0u&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             denom   = mod(&lt;span&gt;float&lt;/span&gt;(n), &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             result += denom *&lt;span&gt; invBase;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             invBase = invBase / &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             n       = &lt;span&gt;uint&lt;/span&gt;(&lt;span&gt;float&lt;/span&gt;(n) / &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; vec2 HammersleyNoBitOps(&lt;span&gt;uint&lt;/span&gt; i, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; N)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; vec2(&lt;span&gt;float&lt;/span&gt;(i)/&lt;span&gt;float&lt;/span&gt;(N), VanDerCorpus(i, &lt;span&gt;2u&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that due to GLSL loop restrictions in older hardware the sequence loops over all possible &lt;code&gt;32&lt;/code&gt; bits. This version is less performant, but does work on all hardware if you ever find yourself without bit operators.&lt;/p&gt;
&lt;p&gt;注意，由于GLSL循环在旧硬件上的约束，序列在所有可能的32位上循环。这个版本的代码不那么高效，但是能够在所有硬件上工作。如果你发现你用不了位操作，就可以选这个。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;h2&gt;GGX重要性采样&lt;/h2&gt;
&lt;p&gt;Instead of uniformly or randomly (Monte Carlo) generating sample vectors over the integral's hemisphere Ω we'll generate sample vectors biased towards the general reflection orientation of the microsurface halfway vector based on the surface's roughness. The sampling process will be similar to what we've seen before: begin a large loop, generate a random (low-discrepancy) sequence value, take the sequence value to generate a sample vector in tangent space, transform to world space and sample the scene's radiance. What's different is that we now use a low-discrepancy sequence value as input to generate a sample vector:&lt;/p&gt;
&lt;p&gt;与其在半球Ω上均匀或随机地（蒙特卡罗）生成采样向量，我们生成了朝着微平面半角向量方向偏差的采样向量。采样过程与我们之前见到的类似：开始一个大循环，生成随机（低差异）序列值，在tangent空间用序列值生成采样向量，变换到world空间，采集场景的辐射率。区别是，我们现在用低差异序列作为输入来生成采样向量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;uint&lt;/span&gt; SAMPLE_COUNT = &lt;span&gt;4096u&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0u&lt;/span&gt;; i &amp;lt; SAMPLE_COUNT; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     vec2 Xi = Hammersley(i, SAMPLE_COUNT);   
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Additionally, to build a sample vector, we need some way of orienting and biasing the sample vector towards the specular lobe of some surface roughness. We can take the NDF as described in the &lt;a href=&quot;https://learnopengl.com/#!PBR/Theory&quot; target=&quot;_blank&quot;&gt;Theory&lt;/a&gt; tutorial and combine the GGX NDF in the spherical sample vector process as described by Epic Games:&lt;/p&gt;
&lt;p&gt;另外，为构造采样向量，我们需要某种方式让采样向量朝向和偏向specular叶。我们可以用理论教程中的NDF函数，联合GGX NDF，用于采样向量的处理过程，如Epic游戏公司所述：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; roughness)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; a = roughness*&lt;span&gt;roughness;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; phi = &lt;span&gt;2.0&lt;/span&gt; * PI *&lt;span&gt; Xi.x;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; cosTheta = sqrt((&lt;span&gt;1.0&lt;/span&gt; - Xi.y) / (&lt;span&gt;1.0&lt;/span&gt; + (a*a - &lt;span&gt;1.0&lt;/span&gt;) *&lt;span&gt; Xi.y));
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; sinTheta = sqrt(&lt;span&gt;1.0&lt;/span&gt; - cosTheta*&lt;span&gt;cosTheta);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; from spherical coordinates to cartesian coordinates&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    vec3 H;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     H.x = cos(phi) *&lt;span&gt; sinTheta;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     H.y = sin(phi) *&lt;span&gt; sinTheta;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     H.z =&lt;span&gt; cosTheta;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; from tangent-space vector to world-space sample vector&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     vec3 up        = abs(N.z) &amp;lt; &lt;span&gt;0.999&lt;/span&gt; ? vec3(&lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;) : vec3(&lt;span&gt;1.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     vec3 tangent   =&lt;span&gt; normalize(cross(up, N));
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     vec3 bitangent =&lt;span&gt; cross(N, tangent);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt;     vec3 sampleVec = tangent * H.x + bitangent * H.y + N *&lt;span&gt; H.z;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; normalize(sampleVec);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This gives us a sample vector somewhat oriented around the expected microsurface's halfway vector based on some input roughness and the low-discrepancy sequence value &lt;var&gt;Xi&lt;/var&gt;. Note that Epic Games uses the squared roughness for better visual results as based on Disney's original PBR research.&lt;/p&gt;
&lt;p&gt;这给出了朝向微平面半角向量的采样向量。注意，根据Disney的PBR研究，Epic游戏公司使用了粗糙度的平方，以求更好的视觉效果。&lt;/p&gt;
&lt;p&gt;With the low-discrepancy Hammersley sequence and sample generation defined we can finalize the pre-filter convolution shader:&lt;/p&gt;
&lt;p&gt;有了低差异序列和采样生成，我们可以实现pre-filter卷积shader了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #version &lt;span&gt;330&lt;/span&gt;&lt;span&gt; core
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt; vec4 FragColor;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; vec3 localPos;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;uniform samplerCube environmentMap;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; uniform &lt;span&gt;float&lt;/span&gt;&lt;span&gt; roughness;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; PI = &lt;span&gt;3.14159265359&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; RadicalInverse_VdC(&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; bits);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; vec2 Hammersley(&lt;span&gt;uint&lt;/span&gt; i, &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; N);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; roughness);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;{        
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     vec3 N =&lt;span&gt; normalize(localPos);    
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     vec3 R =&lt;span&gt; N;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     vec3 V =&lt;span&gt; R;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;uint&lt;/span&gt; SAMPLE_COUNT = &lt;span&gt;1024u&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; totalWeight = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;   
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     vec3 prefilteredColor = vec3(&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);     
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0u&lt;/span&gt;; i &amp;lt; SAMPLE_COUNT; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         vec2 Xi =&lt;span&gt; Hammersley(i, SAMPLE_COUNT);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         vec3 H  =&lt;span&gt; ImportanceSampleGGX(Xi, N, roughness);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         vec3 L  = normalize(&lt;span&gt;2.0&lt;/span&gt; * dot(V, H) * H -&lt;span&gt; V);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;float&lt;/span&gt; NdotL = max(dot(N, L), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(NdotL &amp;gt; &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             prefilteredColor += texture(environmentMap, L).rgb *&lt;span&gt; NdotL;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             totalWeight      +=&lt;span&gt; NdotL;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     prefilteredColor = prefilteredColor /&lt;span&gt; totalWeight;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     FragColor = vec4(prefilteredColor, &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We pre-filter the environment, based on some input roughness that varies over each mipmap level of the pre-filter cubemap (from &lt;code&gt;0.0&lt;/code&gt; to &lt;code&gt;1.0&lt;/code&gt;) and store the result in &lt;var&gt;prefilteredColor&lt;/var&gt;. The resulting &lt;var&gt;prefilteredColor&lt;/var&gt; is divided by the total sample weight, where samples with less influence on the final result (for small &lt;var&gt;NdotL&lt;/var&gt;) contribute less to the final weight.&lt;/p&gt;
&lt;p&gt;我们对环境进行预计算得到pre-filter，以粗糙度为输入参数，在不同的mipmap层上，粗糙度不同（从0.0到1.0），将结果保存到&lt;var&gt;prefilteredColor&lt;/var&gt;。&lt;var&gt;prefilteredColor&lt;/var&gt; 被除以了采样的总权重，其中影响小的采样其权重就小。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;h2&gt;捕捉pre-filter的mipmap层&lt;/h2&gt;
&lt;p&gt;What's left to do is let OpenGL pre-filter the environment map with different roughness values over multiple mipmap levels. This is actually fairly easy to do with the original setup of the &lt;a href=&quot;https://learnopengl.com/#!PBR/IBL/Diffuse-irradiance&quot; target=&quot;_blank&quot;&gt;irradiance&lt;/a&gt; tutorial:&lt;/p&gt;
&lt;p&gt;剩下要做的，就是让OpenGL对环境贴图预计算pre-filter，将不同粗糙度的结果放到不同mipmap层上。有了辐照度教程的基础设施，这相当简单：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;prefilterShader.use();
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; prefilterShader.setInt(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environmentMap&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; prefilterShader.setMat4(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;projection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, captureProjection);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;glActiveTexture(GL_TEXTURE0);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;glBindTexture(GL_TEXTURE_CUBE_MAP, envCubemap);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt; maxMipLevels = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; (unsigned &lt;span&gt;int&lt;/span&gt; mip = &lt;span&gt;0&lt;/span&gt;; mip &amp;lt; maxMipLevels; ++&lt;span&gt;mip)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; reisze framebuffer according to mip-level size.&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt; mipWidth  = &lt;span&gt;128&lt;/span&gt; * std::pow(&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;, mip);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     unsigned &lt;span&gt;int&lt;/span&gt; mipHeight = &lt;span&gt;128&lt;/span&gt; * std::pow(&lt;span&gt;0.5&lt;/span&gt;&lt;span&gt;, mip);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    glBindRenderbuffer(GL_RENDERBUFFER, captureRBO);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, mipWidth, mipHeight);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     glViewport(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, mipWidth, mipHeight);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; roughness = (&lt;span&gt;float&lt;/span&gt;)mip / (&lt;span&gt;float&lt;/span&gt;)(maxMipLevels - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     prefilterShader.setFloat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;roughness&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, roughness);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (unsigned &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;6&lt;/span&gt;; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         prefilterShader.setMat4(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;view&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, captureViews[i]);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                                GL_TEXTURE_CUBE_MAP_POSITIVE_X +&lt;span&gt; i, prefilterMap, mip);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         glClear(GL_COLOR_BUFFER_BIT |&lt;span&gt; GL_DEPTH_BUFFER_BIT);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        renderCube();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; glBindFramebuffer(GL_FRAMEBUFFER, &lt;span&gt;0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The process is similar to the irradiance map convolution, but this time we scale the framebuffer's dimensions to the appropriate mipmap scale, each mip level reducing the dimensions by 2. Additionally, we specify the mip level we're rendering into in glFramebufferTexture2D's last parameter and pass the roughness we're pre-filtering for to the pre-filter shader.&lt;/p&gt;
&lt;p&gt;过程与辐照度贴图卷积类似，但是这次我们需要将framebuffer的尺寸缩放到mipmap的大小，每个mipmap层都缩小一半。另外，我们将mipmap层数传入glFramebufferTexture2D的最后参数，将粗糙度传入shader。&lt;/p&gt;
&lt;p&gt;This should give us a properly pre-filtered environment map that returns blurrier reflections the higher mip level we access it from. If we display the pre-filtered environment cubemap in the skybox shader and forecefully sample somewhat above its first mip level in its shader like so:&lt;/p&gt;
&lt;p&gt;这会给我们一个合适的pre-filter环境贴图，他的mipmap层越高，反射就越模糊。如果我们把pre-filter环境贴图显示到天空盒上，对第一层mipmap采样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
vec3 envColor = textureLod(environmentMap, WorldPos, &lt;span&gt;1.2&lt;/span&gt;).rgb;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We get a result that indeed looks like a blurrier version of the original environment:&lt;/p&gt;
&lt;p&gt;我们会得到模糊版本的原始环境：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023733148-208666580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;If it looks somewhat similar you've successfully pre-filtered the HDR environment map. Play around with different mipmap levels to see the pre-filter map gradually change from sharp to blurry reflections on increasing mip levels.&lt;/p&gt;
&lt;p&gt;这看起来有点像HDR环境贴图的天空盒，证明你成功地得到了pre-filter贴图。用不同mkpmap层显示看看，pre-filter会逐渐从清晰到模糊。&lt;/p&gt;
&lt;h2&gt;Pre-filter卷积的瑕疵&lt;/h2&gt;
&lt;p&gt;While the current pre-filter map works fine for most purposes, sooner or later you'll come across several render artifacts that are directly related to the pre-filter convolution. I'll list the most common here including how to fix them.&lt;/p&gt;
&lt;p&gt;尽管现在的pre-filter贴图在大多数时候工作得很好，早晚你会发现几个直接与pre-fitler有关的瑕疵。这里列举几个最常见的，并说明如何解决它们。&lt;/p&gt;
&lt;h3&gt;高粗糙度时的cubemap缝合线&lt;/h3&gt;
&lt;p&gt;Sampling the pre-filter map on surfaces with a rough surface means sampling the pre-filter map on some of its lower mip levels. When sampling cubemaps, OpenGL by default doesn't linearly interpolate &lt;strong&gt;across&lt;/strong&gt; cubemap faces. Because the lower mip levels are both of a lower resolution and the pre-filter map is convoluted with a much larger sample lobe, the lack of &lt;em&gt;between-cube-face filtering&lt;/em&gt; becomes quite apparent:&lt;/p&gt;
&lt;p&gt;对更高粗糙度的表面采样意味着对更深的mipmap层采样。对cubemap采样时，OpenGL默认不在face之间线性插值。因为更深的mipmap层既是低分辨率，又是卷积了更大的采样叶，face之间的过滤损失变得十分明显。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023740362-367908956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Luckily for us, OpenGL gives us the option to properly filter across cubemap faces by enabling &lt;var&gt;GL_TEXTURE_CUBE_MAP_SEAMLESS&lt;/var&gt;:&lt;/p&gt;
&lt;p&gt;幸运的是，OpenGL给了我们选项，可以适当地在face之间过滤。只需启用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Simply enable this property somewhere at the start of your application and the seams will be gone.&lt;/p&gt;
&lt;p&gt;在应用程序启动的时候，启用这个开关，缝合线就消失了。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;h3&gt;Pre-fitler卷积中的亮点&lt;/h3&gt;
&lt;p&gt;Due to high frequency details and wildly varying light intensities in specular reflections, convoluting the specular reflections requires a large number of samples to properly account for the wildly varying nature of HDR environmental reflections. We already take a very large number of samples, but on some environments it might still not be enough at some of the rougher mip levels in which case you'll start seeing dotted patterns emerge around bright areas:&lt;/p&gt;
&lt;p&gt;由于specular反射中的高频细节和广泛变化的强度，卷积需要很大的采样量。虽然如此，在比较粗糙的mipmap上仍旧不够，你会看到点状的模式出现在亮光区域：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023805695-1366326358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;One option is to further increase the sample count, but this won't be enough for all environments. As described by &lt;a href=&quot;https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/&quot; target=&quot;_blank&quot;&gt;Chetan Jags&lt;/a&gt; we can reduce this artifact by (during the pre-filter convolution) not directly sampling the environment map, but sampling a mip level of the environment map based on the integral's PDF and the roughness:&lt;/p&gt;
&lt;p&gt;一个选择是增加采样量，但这对有的环境仍旧不够。如&lt;a href=&quot;https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/&quot; target=&quot;_blank&quot;&gt;Chetan Jags&lt;/a&gt;所述，我们可以通过（在pre-filter卷积中）不直接对环境贴图采样来减少瑕疵，而是基于积分的pdf和粗糙度对环境贴图的一个mipmap层采样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; D   =&lt;span&gt; DistributionGGX(NdotH, roughness);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; pdf = (D * NdotH / (&lt;span&gt;4.0&lt;/span&gt; * HdotV)) + &lt;span&gt;0.0001&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; resolution = &lt;span&gt;512.0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; resolution of source cubemap (per face)&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; saTexel  = &lt;span&gt;4.0&lt;/span&gt; * PI / (&lt;span&gt;6.0&lt;/span&gt; * resolution *&lt;span&gt; resolution);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; saSample = &lt;span&gt;1.0&lt;/span&gt; / (&lt;span&gt;float&lt;/span&gt;(SAMPLE_COUNT) * pdf + &lt;span&gt;0.0001&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; mipLevel = roughness == &lt;span&gt;0.0&lt;/span&gt; ? &lt;span&gt;0.0&lt;/span&gt; : &lt;span&gt;0.5&lt;/span&gt; * log2(saSample / saTexel);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Don't forget to enable trilinear filtering on the environment map you want to sample its mip levels from:&lt;/p&gt;
&lt;p&gt;别忘了启用三线过滤：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;glBindTexture(GL_TEXTURE_CUBE_MAP, envCubemap);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And let OpenGL generate the mipmaps &lt;strong&gt;after&lt;/strong&gt; the cubemap's base texture is set:&lt;/p&gt;
&lt;p&gt;在cubemap的第一个mipmap层完成&lt;strong&gt;之后&lt;/strong&gt;生成后续的mipmap：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; convert HDR equirectangular environment map to cubemap equivalent&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;[...]
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; then generate mipmaps&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;glBindTexture(GL_TEXTURE_CUBE_MAP, envCubemap);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; glGenerateMipmap(GL_TEXTURE_CUBE_MAP);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This works surprisingly well and should remove most, if not all, dots in your pre-filter map on rougher surfaces.&lt;/p&gt;
&lt;p&gt;这工作得出人意料得好，能够移出大部分（或全部）pre-filter贴图中的粗糙表面的点现象。&lt;/p&gt;
&lt;h2&gt;预计算BRDF&lt;/h2&gt;
&lt;p&gt;With the pre-filtered environment up and running, we can focus on the second part of the split-sum approximation: the BRDF. Let's briefly review the specular split sum approximation again:&lt;/p&gt;
&lt;p&gt;随着pre-fitler环境贴图上线运行，我们可以关注拆分求和近似的第二个部分：BRDF。我们简单地回忆一下拆分求和近似：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023900477-1265534898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We've pre-computed the left part of the split sum approximation in the pre-filter map over different roughness levels. The right side requires us to convolute the BRDF equation over the angle n⋅ωo, the surface roughness and Fresnel's F0. This is similar to integrating the specular BRDF with a solid-white environment or a constant radiance Li of &lt;code&gt;1.0&lt;/code&gt;. Convoluting the BRDF over 3 variables is a bit much, but we can move F0 out of the specular BRDF equation:&lt;/p&gt;
&lt;p&gt;我们已经预计算了左边的积分。右边的积分要求我们围绕角度n⋅ωo、粗糙度和菲涅耳尝试F0队BRDF卷积。这类似于对纯白色环境贴图或辐照度为常量1.0的BRDF积分。对3个变量卷积太难了，但我们可以把F0移到积分外面：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023905387-944369965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;With F being the Fresnel equation. Moving the Fresnel denominator to the BRDF gives us the following equivalent equation:&lt;/p&gt;
&lt;p&gt;其中F代表菲涅耳方程。将菲涅耳分母移到BRDF，得到：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023910965-1664575316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Substituting the right-most F with the Fresnel-Schlick approximation gives us:&lt;/p&gt;
&lt;p&gt;用Fresnel-Schlick近似代替右边的F，得到：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023918185-1224049039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Let's replace (1−ωo⋅h)&lt;sup&gt;5&lt;/sup&gt; by α to make it easier to solve for F0:&lt;/p&gt;
&lt;p&gt;我们用α代替(1−ωo⋅h)&lt;sup&gt;5&lt;/sup&gt;，从而对收拾F0简单点：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506023954982-1478798558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024008049-1698904807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024013307-1173016538.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Then we split the Fresnel function F over two integrals:&lt;/p&gt;
&lt;p&gt;然后我们把菲涅耳方程F拆分为2个积分：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024026351-105169978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This way, F0 is constant over the integral and we can take F0 out of the integral. Next, we substitute α back to its original form giving us the final split sum BRDF equation:&lt;/p&gt;
&lt;p&gt;这样，F0在积分上就是常量，我们可以将F0移出积分。下一步，我们将α替换回它原来的形式。现在就得到了最终的拆分求和BRDF方程：&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024037322-1548385462.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The two resulting integrals represent a scale and a bias to F0 respectively. Note that as f(p,ωi,ωo) already contains a term for F they both cancel out, removing F from f.&lt;/p&gt;
&lt;p&gt;这两个积分分别表示对F0的缩放和偏移。注意，由于f(p,ωi,ωo)已经包含了F项，他们抵消了，从f中移除了。&lt;/p&gt;
&lt;p&gt;In a similar fashion to the earlier convoluted environment maps, we can convolute the BRDF equations on their inputs: the angle between n and ωo and the roughness, and store the convoluted result in a texture. We store the convoluted results in a 2D lookup texture (LUT) known as a BRDF integration map that we later use in our PBR lighting shader to get the final convoluted indirect specular result.&lt;/p&gt;
&lt;p&gt;类似之前的卷积操作，我们可以针对BRDF的输入参数进行卷积：n和ωo之间的角度，以及粗糙度。然后将结果保存到贴图中。我们将卷积结果保存到一个二维查询纹理（LUT），即BRDF积分贴图，稍后用于PBR光照shader，得到最终的非直接specular光照结果。&lt;/p&gt;
&lt;p&gt;The BRDF convolution shader operates on a 2D plane, using its 2D texture coordinates directly as inputs to the BRDF convolution (&lt;var&gt;NdotV&lt;/var&gt; and &lt;var&gt;roughness&lt;/var&gt;). The convolution code is largely similar to the pre-filter convolution, except that it now processes the sample vector according to our BRDF's geometry function and Fresnel-Schlick's approximation:&lt;/p&gt;
&lt;p&gt;BRDF卷积shader在二维平面上工作，它使用二维纹理坐标直接作为输入参数，以此卷积BRDF（&lt;var&gt;NdotV&lt;/var&gt; 和&lt;var&gt;roughness&lt;/var&gt;）。卷积代码和pre-filter卷积很相似，除了它现在根据几何函数G和Fresnel-Schlick近似来处理采样限量：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('7d565c2c-df79-4a68-b8d0-f87140c346ed')&quot; readability=&quot;41&quot;&gt;&lt;img id=&quot;code_img_closed_7d565c2c-df79-4a68-b8d0-f87140c346ed&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7d565c2c-df79-4a68-b8d0-f87140c346ed&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('7d565c2c-df79-4a68-b8d0-f87140c346ed',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7d565c2c-df79-4a68-b8d0-f87140c346ed&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;77&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; vec2 IntegrateBRDF(&lt;span&gt;float&lt;/span&gt; NdotV, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; roughness)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    vec3 V;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     V.x = sqrt(&lt;span&gt;1.0&lt;/span&gt; - NdotV*&lt;span&gt;NdotV);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     V.y = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     V.z =&lt;span&gt; NdotV;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; A = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; B = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     vec3 N = vec3(&lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;0.0&lt;/span&gt;, &lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;uint&lt;/span&gt; SAMPLE_COUNT = &lt;span&gt;1024u&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0u&lt;/span&gt;; i &amp;lt; SAMPLE_COUNT; ++&lt;span&gt;i)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         vec2 Xi =&lt;span&gt; Hammersley(i, SAMPLE_COUNT);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         vec3 H  =&lt;span&gt; ImportanceSampleGGX(Xi, N, roughness);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         vec3 L  = normalize(&lt;span&gt;2.0&lt;/span&gt; * dot(V, H) * H -&lt;span&gt; V);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;float&lt;/span&gt; NdotL = max(L.z, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;float&lt;/span&gt; NdotH = max(H.z, &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;float&lt;/span&gt; VdotH = max(dot(V, H), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(NdotL &amp;gt; &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; G =&lt;span&gt; GeometrySmith(N, V, L, roughness);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; G_Vis = (G * VdotH) / (NdotH *&lt;span&gt; NdotV);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;float&lt;/span&gt; Fc = pow(&lt;span&gt;1.0&lt;/span&gt; - VdotH, &lt;span&gt;5.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;             A += (&lt;span&gt;1.0&lt;/span&gt; - Fc) *&lt;span&gt; G_Vis;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             B += Fc *&lt;span&gt; G_Vis;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     A /= &lt;span&gt;float&lt;/span&gt;&lt;span&gt;(SAMPLE_COUNT);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     B /= &lt;span&gt;float&lt;/span&gt;&lt;span&gt;(SAMPLE_COUNT);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; vec2(A, B);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() 
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     vec2 integratedBRDF =&lt;span&gt; IntegrateBRDF(TexCoords.x, TexCoords.y);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     FragColor =&lt;span&gt; integratedBRDF;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;IntegrateBRDF&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;As you can see the BRDF convolution is a direct translation from the mathematics to code. We take both the angle θ and the roughness as input, generate a sample vector with importance sampling, process it over the geometry and the derived Fresnel term of the BRDF, and output both a scale and a bias to F0 for each sample, averaging them in the end.&lt;/p&gt;
&lt;p&gt;你可以看到，BRDF卷积就是直接把数学公式转换为代码。我们以角度θ和粗糙度为输入参数，用重要性采样方法生成采样向量，用几何函数G和菲涅耳项处理它，输出F0的缩放和偏移量，最后求平均值。&lt;/p&gt;
&lt;p&gt;You might've recalled from the &lt;a href=&quot;https://learnopengl.com/#!PBR/Theory&quot; target=&quot;_blank&quot;&gt;theory&lt;/a&gt; tutorial that the geometry term of the BRDF is slightly different when used alongside IBL as its k variable has a slightly different interpretation:&lt;/p&gt;
&lt;p&gt;你可能回想起在理论教程中，BRDF的几何函数项在用于IBL时有所不同，k变量的解释是不同的：&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024125696-1967288388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Since the BRDF convolution is part of the specular IBL integral we'll use kIBL for the Schlick-GGX geometry function:&lt;/p&gt;
&lt;p&gt;既然BRDF卷积是specular的IBL的一部分，我们将在几何函数中用k&lt;sub&gt;IBL&lt;/sub&gt;这个解释：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; GeometrySchlickGGX(&lt;span&gt;float&lt;/span&gt; NdotV, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; roughness)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; a =&lt;span&gt; roughness;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; k = (a * a) / &lt;span&gt;2.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; nom   =&lt;span&gt; NdotV;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; denom = NdotV * (&lt;span&gt;1.0&lt;/span&gt; - k) +&lt;span&gt; k;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; nom /&lt;span&gt; denom;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; GeometrySmith(vec3 N, vec3 V, vec3 L, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; roughness)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; NdotV = max(dot(N, V), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; NdotL = max(dot(N, L), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; ggx2 =&lt;span&gt; GeometrySchlickGGX(NdotV, roughness);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; ggx1 =&lt;span&gt; GeometrySchlickGGX(NdotL, roughness);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; ggx1 *&lt;span&gt; ggx2;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that while k takes &lt;var&gt;a&lt;/var&gt; as its parameter we didn't square &lt;var&gt;roughness&lt;/var&gt; as &lt;var&gt;a&lt;/var&gt; as we originally did for other interpretations of &lt;var&gt;a&lt;/var&gt;; likely as &lt;var&gt;a&lt;/var&gt; is squared here already. I'm not sure whether this is an inconsistency on Epic Games' part or the original Disney paper, but directly translating &lt;var&gt;roughness&lt;/var&gt; to &lt;var&gt;a&lt;/var&gt; gives the BRDF integration map that is identical to Epic Games' version.&lt;/p&gt;
&lt;p&gt;注意，尽管k以&lt;var&gt;a&lt;/var&gt;为输入参数，我们没有将&lt;var&gt;roughness&lt;/var&gt; 的平方作为&lt;var&gt;a&lt;/var&gt;，我们之前却是这么做的。可能这里的&lt;var&gt;a&lt;/var&gt;已经平方过了。我不确定这是Epic游戏公司的不一致性，还是最初的Disney文献的问题，但是直接将&lt;var&gt;roughness&lt;/var&gt; 传递给&lt;var&gt;a&lt;/var&gt;，确实得到了与Epic游戏公司相同的BRDF积分贴图。&lt;/p&gt;
&lt;p&gt;Finally, to store the BRDF convolution result we'll generate a 2D texture of a 512 by 512 resolution.&lt;/p&gt;
&lt;p&gt;最后，为保存BRDF卷积结果，我们创建一个二维纹理，尺寸为512x512：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; brdfLUTTexture;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; glGenTextures(&lt;span&gt;1&lt;/span&gt;, &amp;amp;&lt;span&gt;brdfLUTTexture);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre-allocate enough memory for the LUT texture.&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;glBindTexture(GL_TEXTURE_2D, brdfLUTTexture);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; glTexImage2D(GL_TEXTURE_2D, &lt;span&gt;0&lt;/span&gt;, GL_RG16F, &lt;span&gt;512&lt;/span&gt;, &lt;span&gt;512&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, GL_RG, GL_FLOAT, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that we use a 16-bit precision floating format as recommended by Epic Games. Be sure to set the wrapping mode to &lt;var&gt;GL_CLAMP_TO_EDGE&lt;/var&gt; to prevent edge sampling artifacts.&lt;/p&gt;
&lt;p&gt;注意，我们使用16位精度浮点数格式，这是Epic游戏公司推荐的。确保wrapping模式为&lt;var&gt;GL_CLAMP_TO_EDGE&lt;/var&gt; ，防止边缘采样瑕疵。&lt;/p&gt;
&lt;p&gt;Then, we re-use the same framebuffer object and run this shader over an NDC screen-space quad:&lt;/p&gt;
&lt;p&gt;然后，我们复用相同的Framebuffer对象，在NDC空间（画一个铺满屏幕的四边形）运行下面的shader：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;glBindRenderbuffer(GL_RENDERBUFFER, captureRBO);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, &lt;span&gt;512&lt;/span&gt;, &lt;span&gt;512&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, brdfLUTTexture, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; glViewport(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;512&lt;/span&gt;, &lt;span&gt;512&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;brdfShader.use();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; glClear(GL_COLOR_BUFFER_BIT |&lt;span&gt; GL_DEPTH_BUFFER_BIT);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;RenderQuad();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; glBindFramebuffer(GL_FRAMEBUFFER, &lt;span&gt;0&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The convoluted BRDF part of the split sum integral should give you the following result:&lt;/p&gt;
&lt;p&gt;拆分求和积分的BRDF部分的卷积会得到如下图所示的结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024218369-407485057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;With both the pre-filtered environment map and the BRDF 2D LUT we can re-construct the indirect specular integral according to the split sum approximation. The combined result then acts as the indirect or ambient specular light.&lt;/p&gt;
&lt;p&gt;有了pre-filter环境贴图和BRDF的二维LUT贴图，我们可以根据拆分求和近似来重构非直接specular积分。相乘的结果就是非直接或环境specular光。&lt;/p&gt;
&lt;h2&gt;IBL反射完成&lt;/h2&gt;
&lt;p&gt;To get the indirect specular part of the reflectance equation up and running we need to stitch both parts of the split sum approximation together. Let's start by adding the pre-computed lighting data to the top of our PBR shader:&lt;/p&gt;
&lt;p&gt;为了让反射率方程中的非直接specular部分上线运行，我们需要将拆分求和近似的两部分钉在一起。开始时，让我们把预计算的光照数据放到PBR shaer的开头：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;uniform samplerCube prefilterMap;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; uniform sampler2D   brdfLUT;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;First, we get the indirect specular reflections of the surface by sampling the pre-filtered environment map using the reflection vector. Note that we sample the appropriate mip level based on the surface roughness, giving rougher surfaces &lt;em&gt;blurrier&lt;/em&gt;specular reflections.&lt;/p&gt;
&lt;p&gt;首先，使用反射向量，通过对pre-filter环境贴图采样，我们得到表面的非直接specular反射强度。注意，我们根据表面的粗糙度度对最接近的mipmap层采样，这会让更粗糙的表面表现出更模糊的反射效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    [...]
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     vec3 R = reflect(-&lt;span&gt;V, N);   
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; MAX_REFLECTION_LOD = &lt;span&gt;4.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness *&lt;span&gt; MAX_REFLECTION_LOD).rgb;    
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    [...]
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;In the pre-filter step we only convoluted the environment map up to a maximum of 5 mip levels (0 to 4), which we denote here as &lt;var&gt;MAX_REFLECTION_LOD&lt;/var&gt; to ensure we don't sample a mip level where there's no (relevant) data.&lt;/p&gt;
&lt;p&gt;在pre-tilter步骤中我们只卷积了5个mipmap层（0-4），我们这里用&lt;var&gt;MAX_REFLECTION_LOD&lt;/var&gt; 确保不对没有数据的位置采样。&lt;/p&gt;
&lt;p&gt;Then we sample from the BRDF lookup texture given the material's roughness and the angle between the normal and view vector:&lt;/p&gt;
&lt;p&gt;给定材质的粗糙度和角度（法线和观察者之间的角度），我们从BRDF的查询纹理中采样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; vec3 F        = FresnelSchlickRoughness(max(dot(N, V), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;), F0, roughness);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;), roughness)).rg;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Given the scale and bias to F0 (here we're directly using the indirect Fresnel result &lt;var&gt;F&lt;/var&gt;) from the BRDF lookup texture we combine this with the left pre-filter portion of the IBL reflectance equation and re-construct the approximated integral result as &lt;var&gt;specular&lt;/var&gt;.&lt;/p&gt;
&lt;p&gt;从BRDF的查询纹理中找到了F0的缩放和偏移（这里我们直接使用了非直接菲涅耳函数F），我们联合IBL反射率方程左边的pre-filter部分，重构出&lt;var&gt;specular&lt;/var&gt;的近似积分值。&lt;/p&gt;
&lt;p&gt;This gives us the indirect specular part of the reflectance equation. Now, combine this with the diffuse part of the reflectance equation from the &lt;a href=&quot;https://learnopengl.com/#!PBR/IBL/Diffuse-irradiance&quot; target=&quot;_blank&quot;&gt;last&lt;/a&gt; tutorial and we get the full PBR IBL result:&lt;/p&gt;
&lt;p&gt;这就得到了反射率方程的非直接specular部分。现在，联合反射率方程的diffuse部分（从上一篇教程中）我们就得到了PBR全部的IBL结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; vec3 F = FresnelSchlickRoughness(max(dot(N, V), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;), F0, roughness);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; vec3 kS =&lt;span&gt; F;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; vec3 kD = &lt;span&gt;1.0&lt;/span&gt; -&lt;span&gt; kS;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; kD *= &lt;span&gt;1.0&lt;/span&gt; -&lt;span&gt; metallic;      
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   
&lt;span&gt; 7&lt;/span&gt; vec3 irradiance =&lt;span&gt; texture(irradianceMap, N).rgb;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; vec3 diffuse    = irradiance *&lt;span&gt; albedo;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;   
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; MAX_REFLECTION_LOD = &lt;span&gt;4.0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness *&lt;span&gt; MAX_REFLECTION_LOD).rgb;   
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;), roughness)).rg;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; vec3 specular = prefilteredColor * (F * envBRDF.x +&lt;span&gt; envBRDF.y);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   
&lt;span&gt;15&lt;/span&gt; vec3 ambient = (kD * diffuse + specular) * ao;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that we don't multiply &lt;var&gt;specular&lt;/var&gt; by &lt;var&gt;kS&lt;/var&gt; as we already have a Fresnel multiplication in there.&lt;/p&gt;
&lt;p&gt;注意，我们没有用&lt;var&gt;kS&lt;/var&gt; 乘以&lt;var&gt;specular&lt;/var&gt; ，因为我们这里已经有个菲涅耳乘过了。&lt;/p&gt;
&lt;p&gt;Now, running this exact code on the series of spheres that differ by their roughness and metallic properties we finally get to see their true colors in the final PBR renderer:&lt;/p&gt;
&lt;p&gt;现在，运行本系列教程中不同粗糙度和金属度球体的那个代码，我们最终得以看它们在PBR渲染下的真正颜色：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024333290-653364968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We could even go wild, and use some cool textured &lt;a href=&quot;http://freepbr.com/&quot; target=&quot;_blank&quot;&gt;PBR materials&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;我们还可以更疯狂点，用一些酷炫的纹理（来自&lt;a href=&quot;http://freepbr.com/&quot; target=&quot;_blank&quot;&gt;PBR materials&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024339619-1631747353.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Or load &lt;a href=&quot;http://artisaverb.info/PBT.html&quot; target=&quot;_blank&quot;&gt;this awesome free PBR 3D model&lt;/a&gt; by Andrew Maximov:&lt;/p&gt;
&lt;p&gt;或者加载这个棒棒的免费PBR三维模型（Andrew Maximov所做）：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024346518-216886587.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;I'm sure we can all agree that our lighting now looks a lot more convincing. What's even better, is that our lighting looks physically correct, regardless of which environment map we use. Below you'll see several different pre-computed HDR maps, completely changing the lighting dynamics, but still looking physically correct without changing a single lighting variable!&lt;/p&gt;
&lt;p&gt;我确定我们都同意这一点：我们的光照现在看起来真实得多了。更好的是，我们的光照是物理正确的，无论我们用那个环境贴图。下面你将看到几个不同的预计算的HDR贴图，完全改变了光照效果，但是仍旧是看起来物理正确的。这不需要改变一丢丢光照参数！&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/383191/201905/383191-20190506024355321-1384221865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;p&gt;Well, this PBR adventure turned out to be quite a long journey. There are a lot of steps and thus a lot that could go wrong so carefully work your way through the &lt;a href=&quot;https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/2.2.1.ibl_specular/ibl_specular.cpp&quot; target=&quot;_blank&quot;&gt;sphere scene&lt;/a&gt; or &lt;a href=&quot;https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/2.2.2.ibl_specular_textured/ibl_specular_textured.cpp&quot; target=&quot;_blank&quot;&gt;textured scene&lt;/a&gt; code samples (including all shaders) if you're stuck, or check and ask around in the comments.&lt;/p&gt;
&lt;p&gt;此次PBR探险之旅最终显得相当漫长。有很多步骤，所以有很多可能出错的地方，所以，如果卡住了，仔细小心地检查&lt;a href=&quot;https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/2.2.1.ibl_specular/ibl_specular.cpp&quot; target=&quot;_blank&quot;&gt;sphere scene&lt;/a&gt; 或&lt;a href=&quot;https://learnopengl.com/code_viewer_gh.php?code=src/6.pbr/2.2.2.ibl_specular_textured/ibl_specular_textured.cpp&quot; target=&quot;_blank&quot;&gt;textured scene&lt;/a&gt;代码（包括所有的shader），或者检查下注释。&lt;/p&gt;
&lt;h2&gt;接下来？&lt;/h2&gt;
&lt;p&gt;Hopefully, by the end of this tutorial you should have a pretty clear understanding of what PBR is about, and even have an actual PBR renderer up and running. In these tutorials, we've pre-computed all the relevant PBR image-based lighting data at the start of our application, before the render loop. This was fine for educational purposes, but not too great for any practical use of PBR. First, the pre-computation only really has to be done once, not at every startup. And second, the moment you use multiple environment maps you'll have to pre-compute each and every one of them at every startup which tends to build up.&lt;/p&gt;
&lt;p&gt;但愿，在本教程结束时你已经对PBR有了很清除的理解，甚至有了可能实际运行起来的渲染器。这些教程中，我们在程序开始时预计算了所有相关的IBL数据，然后启动渲染循环。这对教程是没问题的，但是对任何实际应用的软件是不可行的。首先，预计算只需要完成一次，不需要每次启动都做。其次，使用多环境贴图时，你不得不每次都把它们全算一遍，这太浪费了。&lt;/p&gt;
&lt;p&gt;For this reason you'd generally pre-compute an environment map into an irradiance and pre-filter map just once, and then store it on disk (note that the BRDF integration map isn't dependent on an environment map so you only need to calculate or load it once). This does mean you'll need to come up with a custom image format to store HDR cubemaps, including their mip levels. Or, you'll store (and load) it as one of the available formats (like .dds that supports storing mip levels).&lt;/p&gt;
&lt;p&gt;因此，你应该将预计算结果保存到硬盘上（注意BRDF积分贴图不依赖环境贴图，所以你只需计算和加载一次）。这意味着你需要找一个自定义的图片格式来存储HDR的cubemap，包括它们的各个mipmap层。或者，你用现有的格式（比如*.dss支持保存多个mipmap层）。&lt;/p&gt;
&lt;p&gt;Furthermore, we've described the &lt;strong&gt;total&lt;/strong&gt; process in these tutorials, including generating the pre-computed IBL images to help further our understanding of the PBR pipeline. But, you'll be just as fine by using several great tools like &lt;a href=&quot;https://github.com/dariomanesku/cmftStudio&quot; target=&quot;_blank&quot;&gt;cmftStudio&lt;/a&gt; or &lt;a href=&quot;https://github.com/derkreature/IBLBaker&quot; target=&quot;_blank&quot;&gt;IBLBaker&lt;/a&gt; to generate these pre-computed maps for you.&lt;/p&gt;
&lt;p&gt;此外，我们在教程中描述了预计算的所有过程，这是为了加深对PBR管道的理解。你完全可以用一些棒棒的工具（例如&lt;a href=&quot;https://github.com/dariomanesku/cmftStudio&quot; target=&quot;_blank&quot;&gt;cmftStudio&lt;/a&gt; 或&lt;a href=&quot;https://github.com/derkreature/IBLBaker&quot; target=&quot;_blank&quot;&gt;IBLBaker&lt;/a&gt; ）来为你完成这些预计算。&lt;/p&gt;
&lt;p&gt;One point we've skipped over is pre-computed cubemaps as reflection probes: cubemap interpolation and parallax correction. This is the process of placing several reflection probes in your scene that take a cubemap snapshot of the scene at that specific location, which we can then convolute as IBL data for that part of the scene. By interpolating between several of these probes based on the camera's vicinity we can achieve local high-detail image-based lighting that is simply limited by the amount of reflection probes we're willing to place. This way, the image-based lighting could correctly update when moving from a bright outdoor section of a scene to a darker indoor section for instance. I'll write a tutorial about reflection probes somewhere in the future, but for now I recommend the article by Chetan Jags below to give you a head start.&lt;/p&gt;
&lt;p&gt;我们跳过的一个点，是将预计算的cubemap用作反射探针：cubemap插值和视差校正。这个说的是，在你的场景中放置几个反射探针，它们在各自的位置拍个cubemap快照，卷积为IBL数据，用作场景中那一部分的光照计算。通过在camera最近的几个探针间插值，我们可以实现局部高细节度的IBL光照（只要我们愿意放置够多的探针）。这样，当从一个明亮的门外部分移动到比较暗的门内部分时，IBL光照可以正确地更新。未来我将写一篇关于探针的教程，但是现在我推荐下面Chetan Jags的文章，你可以从此开始。&lt;/p&gt;
&lt;p&gt;+BIT祝威+悄悄在此留下版了个权的信息说：&lt;/p&gt;
&lt;h2&gt;更多阅读&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf&quot; target=&quot;_blank&quot;&gt;Real Shading in Unreal Engine 4&lt;/a&gt;: explains Epic Games' split sum approximation. This is the article the IBL PBR code is based of.&lt;/li&gt;
&lt;li&gt;解释了Epic游戏公司的拆分求和近似方案。本文基于此而作。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.trentreed.net/blog/physically-based-shading-and-image-based-lighting/&quot; target=&quot;_blank&quot;&gt;Physically Based Shading and Image Based Lighting&lt;/a&gt;: great blog post by Trent Reed about integrating specular IBL into a PBR pipeline in real time.&lt;/li&gt;
&lt;li&gt;了不起的Trent Reed的博客，关于实时的将BL集成进PBR管道。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://chetanjags.wordpress.com/2015/08/26/image-based-lighting/&quot; target=&quot;_blank&quot;&gt;Image Based Lighting&lt;/a&gt;: very extensive write-up by Chetan Jags about specular-based image-based lighting and several of its caveats, including light probe interpolation.&lt;/li&gt;
&lt;li&gt;由Chetan Jags广泛评论的基于specular和IBL的光照及其警告，包括光探针插值。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf&quot; target=&quot;_blank&quot;&gt;Moving Frostbite to PBR&lt;/a&gt;: well written and in-depth overview of integrating PBR into a AAA game engine by Sébastien Lagarde and Charles de Rousiers.&lt;/li&gt;
&lt;li&gt;由bastien Lagarde和Charles de Rousiers编写的深度好文，探讨了如何将PBR集成到AAA游戏引擎。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jmonkeyengine.github.io/wiki/jme3/advanced/pbr_part3.html&quot; target=&quot;_blank&quot;&gt;Physically Based Rendering – Part Three&lt;/a&gt;: high level overview of IBL lighting and PBR by the JMonkeyEngine team.&lt;/li&gt;
&lt;li&gt;由JMonkeyEngine小组提供的IBL光照和PBR高层概览。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://placeholderart.wordpress.com/2015/07/28/implementation-notes-runtime-environment-map-filtering-for-image-based-lighting/&quot; target=&quot;_blank&quot;&gt;Implementation Notes: Runtime Environment Map Filtering for Image Based Lighting&lt;/a&gt;: extensive write-up by Padraic Hennessy about pre-filtering HDR environment maps and significanly optimizing the sample process.&lt;/li&gt;
&lt;li&gt;由Padraic Hennessy的评论，关于pre-filter的HDR环境贴图及其高度优化。&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Sun, 05 May 2019 18:46:00 +0000</pubDate>
<dc:creator>BIT祝威</dc:creator>
<og:description>CSharpGL(54)用基于图像的光照(IBL)来计算PBR的Specular部分 接下来本系列将通过翻译（https://learnopengl.com）这个网站上关于PBR的内容来学习PBR（P</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bitzhuwei/p/specular-IBL.html</dc:identifier>
</item>
<item>
<title>在 FR 网络配置 OSPF - Qftm</title>
<link>http://www.cnblogs.com/qftm/p/10817370.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qftm/p/10817370.html</guid>
<description>&lt;p&gt;1、在路由器 R2 和 R3 上配置模拟帧中继交换机的功能，参考命令如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R2(config)#frame-relay switching

R2(config)#interface Serial1/0

R2(config-if)#clock rate 64000

R2(config-if)#encapsulation frame-relay

R2(config-if)#frame-relay lmi-type cisco

R2(config-if)#frame-relay intf-type dce

R2(config-if)#frame-relay route 104 interface Serial1/2 401

R2(config-if)#frame-relay route 105 interface Serial1/1 300

R2(config)#interface Serial1/1

R2(config-if)#clock rate 64000

R2(config-if)#encapsulation frame-relay

R2(config-if)#frame-relay lmi-type q933a

R2(config-if)#frame-relay intf-type nni 

R2(config-if)#frame-relay route 300 interface Serial1/0 105&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R2 的 S1/2 接口和 R3 的配置参考 R2 的配置自行配置。&lt;/p&gt;

&lt;p&gt;2、在路由器 R1 上配置帧中继，参考命令如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1(config)#interface s1/0

R1(config-if)#encapsulation frame-relay

R1(config-if)#no frame-relay inverse-arp

R1(config-if)#frame-relay lmi-type cisco

R1(config-if)#frame-relay map ip 145.1.1.4 104 broadcast

R1(config-if)#frame-relay map ip 145.1.1.5 105 broadcast&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R4 和 R5 参考 R1 的配置进行配置&lt;/p&gt;
&lt;p&gt;问题 1：配置后在 R1 上 show frame-relay map 可以看到哪些映射？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190506011613010-673165626.png&quot; alt=&quot;&quot; width=&quot;594&quot; height=&quot;122&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：映射：145.1.1.4 104&lt;/p&gt;
&lt;p&gt;　　　　：145.1.1.5 105&lt;/p&gt;
&lt;p&gt;问题 2：在路由器 R2 上 show frame-relay route 能够看到哪些帧中继转发表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190506011655279-215455946.png&quot; alt=&quot;&quot; width=&quot;597&quot; height=&quot;111&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：帧中继转发表中有四条数据，分别如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Input Intf      Input Dlci      Output Intf     Output Dlci     Status
Serial1/0       104             Serial1/2       401             active
Serial1/0       105             Serial1/1       300             active
Serial1/1       300             Serial1/0       105             active
Serial1/2       401             Serial1/0       104             active&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、按照拓扑图给路由器 R1、R4、R5 各接口配置 IP 地址。&lt;/p&gt;
&lt;p&gt;问题 3：配置后在 R4 上分别 ping R1 和 R5 能否通信?原因是什么？&lt;/p&gt;
&lt;p&gt;答：在 R4 上分别 ping R1 和 R5 不能通信。因为R1路由表中没有到达R1和R5的路由条目。&lt;/p&gt;
&lt;p&gt;4、在路由器 R1，R4，R5 上起 OSPF 路由选择协议，全部加入区域 0，参考命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1(config)#router ospf 100

R1(config-router)#network 1.1.1.0 0.0.0.255 area 0

R1(config-router)#network 145.1.1.0 0.0.0.255 area 0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;路由器 R4、R5 参考 R1 配置进行配置&lt;/p&gt;
&lt;p&gt;问题 4：配置后，在 R1 上查看邻居，能否看到 R4 和 R5？为什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190505235428911-1863249672.png&quot; alt=&quot;&quot; width=&quot;368&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：不能看到 R4 和 R5。因为需要在R1上通过手动添加邻居。&lt;/p&gt;
&lt;p&gt;5、在 R1 上手动添加邻居，参考命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1(config-router)#neighbor 145.1.1.4

R1(config-router)#neighbor 145.1.1.5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;问题 5：配置后，在 R1 上查看邻居，能否看到 R4 和 R5？为什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190505235716278-2090610014.png&quot; alt=&quot;&quot; width=&quot;571&quot; height=&quot;87&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：可以看到 R4 和 R5。因为Hello包这个时候以单播形式传送。&lt;/p&gt;
&lt;p&gt;问题 6：在 R4 上使用 ping 5.5.5.5 source 4.4.4.4，能否 ping 通？为什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190506012251425-852402357.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190506012554381-2093337146.png&quot; alt=&quot;&quot; width=&quot;562&quot; height=&quot;96&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：不能 ping 通。因为帧中继交换机中不存在R4和R5的映射关系。&lt;/p&gt;
&lt;p&gt;6、在 R4 和 R5 中手动添加帧中继映射，解决问题 6 的问题，参考命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
R4(config-if)#frame-relay map ip 145.1.1.5 401 broadcast
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考 R4 命令配置 R5&lt;/p&gt;
&lt;p&gt;问题 7：此时在 R4 上使用 ping 5.5.5.5 source 4.4.4.4，能否 ping 通？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190506012516156-977454529.png&quot; alt=&quot;&quot; width=&quot;567&quot; height=&quot;106&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：可以 ping 通。&lt;/p&gt;
&lt;p&gt;7、为了保持网络稳定，手动设置 R1 为 DR，将 R4、R5 优先级设为 0，参考命令为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
R4(config-if)#ip ospf priority 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R5 参考 R4 的配置进行设置&lt;/p&gt;
&lt;p&gt;8、删除步骤 5 和步骤 6 的配置，修改 R1 接口工作类型为 P2MP，R4 和 R5 接口修改为 P2P，&lt;/p&gt;
&lt;p&gt;参考命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R1(config)#interface s1/0

R1(config-if)#ip ospf network point-to-multipoint&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R4 和 R5 参考 R1 配置进行配置&lt;/p&gt;
&lt;p&gt;问题 8：此时 R1 和 R4，R5 之间能否形成邻居，为什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190506013918583-1133477025.png&quot; alt=&quot;&quot; width=&quot;540&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：不能形成邻居。&lt;/p&gt;
&lt;p&gt;9、修改 R4 和 R5 的 hello 时间间隔，参考命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
R4(config-if)#ip ospf hello-interval 30
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;R5 参考 R4 命令进行配置&lt;/p&gt;
&lt;p&gt;问题 9：配置后在 R1 上能否看到邻居？&lt;/p&gt;
&lt;p&gt;答：在 R1 上能看到邻居。&lt;/p&gt;
&lt;p&gt;问题 10：在 R4 上使用 ping 5.5.5.5 source 4.4.4.4，能否 ping 通？为什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190506014430079-87449343.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/201905/1594459-20190506014321689-1211130526.png&quot; alt=&quot;&quot; width=&quot;559&quot; height=&quot;92&quot;/&gt;&lt;/p&gt;
&lt;p&gt;答：不能 ping 通。因为帧中继交换机中不存在R4和R5的映射关系。&lt;/p&gt;

</description>
<pubDate>Sun, 05 May 2019 17:47:00 +0000</pubDate>
<dc:creator>Qftm</dc:creator>
<og:description>一、环境准备 1. 软件：GNS3 2. 路由：c7200 二、实验操作 实验要求： 1、掌握配置帧中继的基本方法。 2、掌握在路由器中模拟帧中继交换机的方法。 3、掌握 NBMA </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qftm/p/10817370.html</dc:identifier>
</item>
<item>
<title>Python 爬取 13 个旅游城市，告诉你五一大家最爱去哪玩？ - 初一丶</title>
<link>http://www.cnblogs.com/wyl-0120/p/10817418.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyl-0120/p/10817418.html</guid>
<description>&lt;p&gt;五一假期已经结束，小伙伴是不是都还没有玩过瘾？但是没办法，还有很多bug等着我们去写，同样还有需要money需要我们去赚。为了生活总的拼搏。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190506010127395-1632502037.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;













&lt;p&gt;今年五一放了四天假，很多人不再只是选择周边游，因为时间充裕，选择了稍微远一点的景区，甚至出国游。各个景点成了人山人海，拥挤的人群，甚至去卫生间都要排队半天，那一刻我突然有点理解灭霸的行为了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190506010325433-1982525054.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;今天，通过分析去哪儿网部分城市门票售卖情况，简单的分析一下哪些景点比较受欢迎。等下次假期可以做个参考。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190506010325314-1709824187.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;通过请求https://piao.qunar.com/ticket/list.htm?keyword=北京，获取北京地区热门景区信息，再通过BeautifulSoup去分析提取出我们需要的信息。&lt;/p&gt;
&lt;p&gt;这里为了偷懒只爬取了前4页的景点信息，每页有15个景点。因为去哪儿并没有什么反爬措施，所以直接请求就可以了。&lt;/p&gt;
&lt;p&gt;这里只是随机选择了13个热门城市：北京, 上海, 成都, 三亚, 广州, 重庆, 深圳, 西安, 杭州, 厦门, 武汉, 大连, 苏州。&lt;/p&gt;
&lt;p&gt;并将爬取的数据存到了MongoDB数据库 。&lt;/p&gt;
&lt;p&gt;爬虫部分完整代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
import requests
from bs4 import BeautifulSoup
from pymongo import MongoClient

class QuNaEr():
    def __init__(self, keyword, page=1):
        self.keyword = keyword
        self.page = page

    def qne_spider(self):
        url = 'https://piao.qunar.com/ticket/list.htm?keyword=%s&amp;amp;region=&amp;amp;from=mpl_search_suggest&amp;amp;page=%s' % (self.keyword, self.page)
        response = requests.get(url)
        response.encoding = 'utf-8'
        text = response.text
        bs_obj = BeautifulSoup(text, 'html.parser')

        arr = bs_obj.find('div', {'class': 'result_list'}).contents
        for i in arr:
            info = i.attrs
            # 景区名称
            name = info.get('data-sight-name')
            # 地址
            address = info.get('data-address')
            # 近期售票数
            count = info.get('data-sale-count')
            # 经纬度
            point = info.get('data-point')

            # 起始价格
            price = i.find('span', {'class': 'sight_item_price'})
            price = price.find_all('em')
            price = price[0].text

            conn = MongoClient('localhost', port=27017)
            db = conn.QuNaEr # 库
            table = db.qunaer_51 # 表

            table.insert_one({
                'name'      :   name,
                'address'   :   address,
                'count'     :   int(count),
                'point'     :   point,
                'price'     :   float(price),
                'city'      :   self.keyword
            })



if __name__ == '__main__':
    citys = ['北京', '上海', '成都', '三亚', '广州', '重庆', '深圳', '西安', '杭州', '厦门', '武汉', '大连', '苏州']
    for i in citys:
        for page in range(1, 5):
            qne = QuNaEr(i, page=page)
            qne.qne_spider()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;效果图如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190506010416316-147972932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;有了数据，我们就可以分析出自己想要的东西了&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;1、最受欢迎的15个景区&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190506010434984-467260407.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;由图可以看出，在选择的13个城市中，最热门的景区为上海的迪士尼乐园&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from pymongo import MongoClient
# 设置字体，不然无法显示中文
from pylab import *

mpl.rcParams['font.sans-serif'] = ['SimHei']

conn = MongoClient('localhost', port=27017)
db = conn.QuNaEr # 库
table = db.qunaer_51 # 表

result = table.find().sort([('count', -1)]).limit(15)
# x,y轴数据
x_arr = []  # 景区名称
y_arr = []  # 销量
for i in result:
    x_arr.append(i['name'])
    y_arr.append(i['count'])

&quot;&quot;&quot;
去哪儿月销量排行榜
&quot;&quot;&quot;
plt.bar(x_arr, y_arr, color='rgb')  # 指定color，不然所有的柱体都会是一个颜色
plt.gcf().autofmt_xdate() # 旋转x轴，避免重叠
plt.xlabel(u'景点名称')  # x轴描述信息
plt.ylabel(u'月销量')  # y轴描述信息
plt.title(u'拉钩景点月销量统计表')  # 指定图表描述信息
plt.ylim(0, 4000)  # 指定Y轴的高度
plt.savefig('去哪儿月销售量排行榜')  # 保存为图片
plt.show()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;2、景区热力图&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里为了方(tou)便(lan)，只展示一下北京地区的景区热力图。用到了百度地图的开放平台。首先需要先注册开发者信息，首页底部有个&lt;strong&gt;申请秘钥&lt;/strong&gt;的按钮，点击进行创建就可以了。我的应用类型选择的是浏览器端，因此只需要组装数据替换掉相应html代码即可。另外还需要将自己访问应用的AK替换掉。效果图如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190506010506607-1644632382.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;3、景区价格&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;价格是出游第一个要考虑的，一开始想统计一下各城市的平均价格，但是后来发现效果不是很好，比如北京的刘老根大舞台价格在580元，这样拉高了平均价格。就好比姚明和潘长江的平均身高在190cm，并没有什么说服力。所以索性展示一下景区的价格分布。&lt;/p&gt;
&lt;p&gt;根据价格设置了六个区间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190506010519950-2053562581.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过上图得知，大部分的景区门票价格都在200元以下。每次旅游花费基本都在交通、住宿、吃吃喝喝上了。门票占比还是比较少的。&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;67&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
arr = [[0, 50], [50,100], [100, 200], [200,300], [300,500], [500,1000]]
name_arr = []
total_arr = []
for i in arr:
    result = table.count({'price': {'$gte': i[0], '$lt': i[1]}})
    name = '%s元 ~ %s元 ' % (i[0], i[1])
    name_arr.append(name)
    total_arr.append(result)

color = 'red', 'orange', 'green', 'blue', 'gray', 'goldenrod' # 各类别颜色
explode = (0.2, 0, 0, 0, 0, 0)  # 各类别的偏移半径

# 绘制饼状图
pie = plt.pie(total_arr, colors=color, explode=explode, labels=name_arr, shadow=True, autopct='%1.1f%%')

plt.axis('equal')
plt.title(u'热点旅游景区门票价格比例', fontsize=12)

plt.legend(loc=0, bbox_to_anchor=(0.82, 1))  # 图例
# 设置legend的字体大小
leg = plt.gca().get_legend()
ltext = leg.get_texts()
plt.setp(ltext, fontsize=6)
# 显示图
plt.show()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;最后欢迎大家关注我的公众号，每天都会努力分享各种干货&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201905/1457234-20190506010558433-1831304814.png&quot; alt=&quot;&quot; width=&quot;884&quot; height=&quot;884&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 05 May 2019 17:07:00 +0000</pubDate>
<dc:creator>初一丶</dc:creator>
<og:description>五一假期已经结束，小伙伴是不是都还没有玩过瘾？但是没办法，还有很多bug等着我们去写，同样还有需要money需要我们去赚。为了生活总的拼搏。 今年五一放了四天假，很多人不再只是选择周边游，因为时间充裕</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyl-0120/p/10817418.html</dc:identifier>
</item>
<item>
<title>死磕 java魔法类之Unsafe解析 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/Unsafe.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/Unsafe.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）Unsafe是什么？&lt;/p&gt;
&lt;p&gt;（2）Unsafe只有CAS的功能吗？&lt;/p&gt;
&lt;p&gt;（3）Unsafe为什么是不安全的？&lt;/p&gt;
&lt;p&gt;（4）怎么使用Unsafe？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;本章是java并发包专题的第一章，但是第一篇写的却不是java并发包中类，而是java中的魔法类sun.misc.Unsafe。&lt;/p&gt;
&lt;p&gt;Unsafe为我们提供了访问底层的机制，这种机制仅供java核心类库使用，而不应该被普通用户使用。&lt;/p&gt;
&lt;p&gt;但是，为了更好地了解java的生态体系，我们应该去学习它，去了解它，不求深入到底层的C/C++代码，但求能了解它的基本功能。&lt;/p&gt;
&lt;h2 id=&quot;获取unsafe的实例&quot;&gt;获取Unsafe的实例&lt;/h2&gt;
&lt;p&gt;查看Unsafe的源码我们会发现它提供了一个getUnsafe()的静态方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@CallerSensitive
public static Unsafe getUnsafe() {
    Class var0 = Reflection.getCallerClass();
    if (!VM.isSystemDomainLoader(var0.getClassLoader())) {
        throw new SecurityException(&quot;Unsafe&quot;);
    } else {
        return theUnsafe;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，如果直接调用这个方法会抛出一个SecurityException异常，这是因为Unsafe仅供java内部类使用，外部类不应该使用它。&lt;/p&gt;
&lt;p&gt;那么，我们就没有方法了吗？&lt;/p&gt;
&lt;p&gt;当然不是，我们有反射啊！查看源码，我们发现它有一个属性叫theUnsafe，我们直接通过反射拿到它即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UnsafeTest {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {
        Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
        f.setAccessible(true);
        Unsafe unsafe = (Unsafe) f.get(null);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用unsafe实例化一个类&quot;&gt;使用Unsafe实例化一个类&lt;/h2&gt;
&lt;p&gt;假如我们有一个简单的类如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class User {
    int age;

    public User() {
        this.age = 10;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们通过构造方法实例化这个类，age属性将会返回10。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;User user1 = new User();
// 打印10
System.out.println(user1.age);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们调用Unsafe来实例化呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;User user2 = (User) unsafe.allocateInstance(User.class);
// 打印0
System.out.println(user2.age);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;age将返回0，因为&lt;code&gt;Unsafe.allocateInstance()&lt;/code&gt;只会给对象分配内存，并不会调用构造方法，所以这里只会返回int类型的默认值0。&lt;/p&gt;
&lt;h2 id=&quot;修改私有字段的值&quot;&gt;修改私有字段的值&lt;/h2&gt;
&lt;p&gt;使用Unsafe的putXXX()方法，我们可以修改任意私有字段的值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UnsafeTest {
    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InstantiationException {
        Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
        f.setAccessible(true);
        Unsafe unsafe = (Unsafe) f.get(null);

        User user = new User();
        Field age = user.getClass().getDeclaredField(&quot;age&quot;);
        unsafe.putInt(user, unsafe.objectFieldOffset(age), 20);

        // 打印20
        System.out.println(user.getAge());
    }
}

class User {
    private int age;

    public User() {
        this.age = 10;
    }

    public int getAge() {
        return age;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦我们通过反射调用得到字段age，我们就可以使用Unsafe将其值更改为任何其他int值。（当然，这里也可以通过反射直接修改）&lt;/p&gt;
&lt;h2 id=&quot;抛出checked异常&quot;&gt;抛出checked异常&lt;/h2&gt;
&lt;p&gt;我们知道如果代码抛出了checked异常，要不就使用try...catch捕获它，要不就在方法签名上定义这个异常，但是，通过Unsafe我们可以抛出一个checked异常，同时却不用捕获或在方法签名上定义它。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 使用正常方式抛出IOException需要定义在方法签名上往外抛
public static void readFile() throws IOException {
    throw new IOException();
}
// 使用Unsafe抛出异常不需要定义在方法签名上往外抛
public static void readFileUnsafe() {
    unsafe.throwException(new IOException());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用堆外内存&quot;&gt;使用堆外内存&lt;/h2&gt;
&lt;p&gt;如果进程在运行过程中JVM上的内存不足了，会导致频繁的进行GC。理想情况下，我们可以考虑使用堆外内存，这是一块不受JVM管理的内存。&lt;/p&gt;
&lt;p&gt;使用Unsafe的allocateMemory()我们可以直接在堆外分配内存，这可能非常有用，但我们要记住，这个内存不受JVM管理，因此我们要调用freeMemory()方法手动释放它。&lt;/p&gt;
&lt;p&gt;假设我们要在堆外创建一个巨大的int数组，我们可以使用allocateMemory()方法来实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class OffHeapArray {
    // 一个int等于4个字节
    private static final int INT = 4;
    private long size;
    private long address;

    private static Unsafe unsafe;
    static {
        try {
            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
            f.setAccessible(true);
            unsafe = (Unsafe) f.get(null);
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    // 构造方法，分配内存
    public OffHeapArray(long size) {
        this.size = size;
        // 参数字节数
        address = unsafe.allocateMemory(size * INT);
    }
    
    // 获取指定索引处的元素
    public int get(long i) {
        return unsafe.getInt(address + i * INT);
    }
    // 设置指定索引处的元素
    public void set(long i, int value) {
        unsafe.putInt(address + i * INT, value);
    }
    // 元素个数
    public long size() {
        return size;
    }
    // 释放堆外内存
    public void freeMemory() {
        unsafe.freeMemory(address);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构造方法中调用allocateMemory()分配内存，在使用完成后调用freeMemory()释放内存。&lt;/p&gt;
&lt;p&gt;使用方式如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;OffHeapArray offHeapArray = new OffHeapArray(4);
offHeapArray.set(0, 1);
offHeapArray.set(1, 2);
offHeapArray.set(2, 3);
offHeapArray.set(3, 4);
offHeapArray.set(2, 5); // 在索引2的位置重复放入元素

int sum = 0;
for (int i = 0; i &amp;lt; offHeapArray.size(); i++) {
    sum += offHeapArray.get(i);
}
// 打印12
System.out.println(sum);

offHeapArray.freeMemory();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，一定要记得调用freeMemory()将内存释放回操作系统。&lt;/p&gt;
&lt;h2 id=&quot;compareandswap操作&quot;&gt;CompareAndSwap操作&lt;/h2&gt;
&lt;p&gt;JUC下面大量使用了CAS操作，它们的底层是调用的Unsafe的CompareAndSwapXXX()方法。这种方式广泛运用于无锁算法，与java中标准的悲观锁机制相比，它可以利用CAS处理器指令提供极大的加速。&lt;/p&gt;
&lt;p&gt;比如，我们可以基于Unsafe的compareAndSwapInt()方法构建线程安全的计数器。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Counter {
    private volatile int count = 0;

    private static long offset;
    private static Unsafe unsafe;
    static {
        try {
            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
            f.setAccessible(true);
            unsafe = (Unsafe) f.get(null);
            offset = unsafe.objectFieldOffset(Counter.class.getDeclaredField(&quot;count&quot;));
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }

    public void increment() {
        int before = count;
        // 失败了就重试直到成功为止
        while (!unsafe.compareAndSwapInt(this, offset, before, before + 1)) {
            before = count;
        }
    }

    public int getCount() {
        return count;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们定义了一个volatile的字段count，以便对它的修改所有线程都可见，并在类加载的时候获取count在类中的偏移地址。&lt;/p&gt;
&lt;p&gt;在increment()方法中，我们通过调用Unsafe的compareAndSwapInt()方法来尝试更新之前获取到的count的值，如果它没有被其它线程更新过，则更新成功，否则不断重试直到成功为止。&lt;/p&gt;
&lt;p&gt;我们可以通过使用多个线程来测试我们的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Counter counter = new Counter();
ExecutorService threadPool = Executors.newFixedThreadPool(100);

// 起100个线程，每个线程自增10000次
IntStream.range(0, 100)
    .forEach(i-&amp;gt;threadPool.submit(()-&amp;gt;IntStream.range(0, 10000)
        .forEach(j-&amp;gt;counter.increment())));

threadPool.shutdown();

Thread.sleep(2000);

// 打印1000000
System.out.println(counter.getCount());&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;parkunpark&quot;&gt;park/unpark&lt;/h2&gt;
&lt;p&gt;JVM在上下文切换的时候使用了Unsafe中的两个非常牛逼的方法park()和unpark()。&lt;/p&gt;
&lt;p&gt;当一个线程正在等待某个操作时，JVM调用Unsafe的park()方法来阻塞此线程。&lt;/p&gt;
&lt;p&gt;当阻塞中的线程需要再次运行时，JVM调用Unsafe的unpark()方法来唤醒此线程。&lt;/p&gt;
&lt;p&gt;我们之前在分析java中的集合时看到了大量的LockSupport.park()/unpark()，它们底层都是调用的Unsafe的这两个方法。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;使用Unsafe几乎可以操作一切：&lt;/p&gt;
&lt;p&gt;（1）实例化一个类；&lt;/p&gt;
&lt;p&gt;（2）修改私有字段的值；&lt;/p&gt;
&lt;p&gt;（3）抛出checked异常；&lt;/p&gt;
&lt;p&gt;（4）使用堆外内存；&lt;/p&gt;
&lt;p&gt;（5）CAS操作；&lt;/p&gt;
&lt;p&gt;（6）阻塞/唤醒线程；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;论实例化一个类的方式？&lt;/p&gt;
&lt;p&gt;（1）通过构造方法实例化一个类；&lt;/p&gt;
&lt;p&gt;（2）通过Class实例化一个类；&lt;/p&gt;
&lt;p&gt;（3）通过反射实例化一个类；&lt;/p&gt;
&lt;p&gt;（4）通过克隆实例化一个类；&lt;/p&gt;
&lt;p&gt;（5）通过反序列化实例化一个类；&lt;/p&gt;
&lt;p&gt;（6）通过Unsafe实例化一个类；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class InstantialTest {

    private static Unsafe unsafe;
    static {
        try {
            Field f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
            f.setAccessible(true);
            unsafe = (Unsafe) f.get(null);
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    
    public static void main(String[] args) throws Exception {
        // 1. 构造方法
        User user1 = new User();
        // 2. Class，里面实际也是反射
        User user2 = User.class.newInstance();
        // 3. 反射
        User user3 = User.class.getConstructor().newInstance();
        // 4. 克隆
        User user4 = (User) user1.clone();
        // 5. 反序列化
        User user5 = unserialize(user1);
        // 6. Unsafe
        User user6 = (User) unsafe.allocateInstance(User.class);

        System.out.println(user1.age);
        System.out.println(user2.age);
        System.out.println(user3.age);
        System.out.println(user4.age);
        System.out.println(user5.age);
        System.out.println(user6.age);
    }

    private static User unserialize(User user1) throws Exception {
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;D://object.txt&quot;));
        oos.writeObject(user1);
        oos.close();

        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(&quot;D://object.txt&quot;));
        // 反序列化
        User user5 = (User) ois.readObject();
        ois.close();
        return user5;
    }

    static class User implements Cloneable, Serializable {
        private int age;

        public User() {
            this.age = 10;
        }

        @Override
        protected Object clone() throws CloneNotSupportedException {
            return super.clone();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 17:01:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>Unsafe是什么？ Unsafe只有CAS的功能吗？ Unsafe为什么是不安全的？ 怎么使用Unsafe？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/Unsafe.html</dc:identifier>
</item>
<item>
<title>记一次Lua语言中死循环查错 - 李嘉的博客</title>
<link>http://www.cnblogs.com/lijiajia/p/10817407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiajia/p/10817407.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;如果在Lua语言中某一处死循环了！你特么的怎么去查出这特么的该死的循环到底在特么的哪里！！！&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-e243d834ae107e2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/128&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;重现步骤&quot;&gt;重现步骤&lt;/h3&gt;
&lt;p&gt;一打开技能界面，整个游戏就卡死不动了&lt;/p&gt;
&lt;h3 id=&quot;开始排查&quot;&gt;开始排查&lt;/h3&gt;
&lt;p&gt;查看一下cpu占用率，unity占用60%+，应该是死循环&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-57c0578d4c66f16b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一开始采取冒烟式查错法，去一些可疑的地方一个个打断点（我们有lua调试工具可断点）。&lt;br/&gt;游戏的大循环，事件派发基层接口，lua调用c#的基层接口等等，都加了很多断点&lt;/p&gt;
&lt;p&gt;可喜的是~~ 完全没有进来！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-c6b89bcde4a8a22d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要怎么才知道当前运行哪段代码呢？这个问题让我想起一个东西&lt;br/&gt;&lt;strong&gt;debug.sethook&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;debug库提供了一种hook的方式，可以通过注册一个handler函数，在lua脚本运行到某个调用时，会触发这个handler，&lt;br/&gt;获取到相应的执行信息，并且给你一个记录和数据维护的机会。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它主要有四种事件会触发这个handler的调用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;当调用一个lua函数的时候，会触发call事件&lt;/li&gt;
&lt;li&gt;当函数返回的时候，会触发一个return事件&lt;/li&gt;
&lt;li&gt;当执行下一行代码的时候，会触发一个line事件&lt;/li&gt;
&lt;li&gt;当运行指定数目的指令后，会触发count事件&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;我们可以通过debug.sethook这个函数来注册一个hook的handler，他有三个参数：&lt;/p&gt;
&lt;p&gt;handler的处理函数，hook事件触发后被调用&lt;br/&gt;描述需要hook的事件类型，call、return和line事件分别对应：’c’, ‘r’, ‘l’，可以互相组合成一个字符串&lt;br/&gt;获取count事件的频率（可选）&lt;/p&gt;
&lt;p&gt;根据这个函数，我可以让lua每执行一行代码，就把它的文件名已经行号输出到我的日志文件中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;debug.sethook(
function (event, line)
   WriteLogToFile(debug.getinfo(2).short_src .. &quot;:&quot; .. line)
end
, &quot;l&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写好这个工具后，我来到了技能界面前，开启了hook！然后打开技能界面！出现吧！死循环！&lt;/p&gt;
&lt;p&gt;我发现我的日志文件，正在以肉眼可见的速度快速增大！&lt;/p&gt;
&lt;p&gt;打开日志后查看后，很快就找到了一段死循环逻辑！&lt;/p&gt;
&lt;p&gt;果然，这个害我加班的BUG, 就是我的写的！&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;debug.sethook确实可以干很多事情，比如基于这个写一个性能监听工具，在函数call、return事件触发时，计算出这个函数的执行时间。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;另外这个锅其实是我们把游戏从c#语言转换到lua语言出现的。因为语法不一样，c#那边用整形除以整形得到的还是整形，但是lua会得到浮点数。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 17:00:00 +0000</pubDate>
<dc:creator>李嘉的博客</dc:creator>
<og:description>前言 如果在Lua语言中某一处死循环了！你特么的怎么去查出这特么的该死的循环到底在特么的哪里！！！ 重现步骤 一打开技能界面，整个游戏就卡死不动了 开始排查 查看一下cpu占用率，unity占用60%</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijiajia/p/10817407.html</dc:identifier>
</item>
<item>
<title>zookeeper源码 — 三、集群启动—leader、follower同步 - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/10817333.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/10817333.html</guid>
<description>&lt;p&gt;zookeeper集群启动的时候，首先读取配置，接着开始选举，选举完成以后，每个server根据选举的结果设置自己的角色，角色设置完成后leader需要和所有的follower同步。上面一篇介绍了leader选举过程，这篇接着介绍启动过程中的leader和follower同步过程。&lt;/p&gt;
&lt;p&gt;本文结构如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步过程&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;同步过程&quot;&gt;同步过程&lt;/h2&gt;
&lt;h3 id=&quot;设置server当前状态&quot;&gt;设置server当前状态&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846961/201905/846961-20190506002009587-1914202829.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;server刚启动的时候都处于LOOKING状态，选举完成后根据选举结果和对应配置进入对应的状态，设置状态的方法是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void setPeerState(long proposedLeader, SyncedLearnerTracker voteSet) {
    ServerState ss = (proposedLeader == self.getId()) ?
            ServerState.LEADING: learningState();
    self.setPeerState(ss);
    if (ss == ServerState.LEADING) {
        leadingVoteSet = voteSet;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;如果当前server.myId等于选举出的leader的myId——也就是proposedLeader，则当前server就是leader，设置peerState为ServerState.LEADING&lt;/li&gt;
&lt;li&gt;否则判断当前server的具体角色，因为follower和observer都是learner，需要根据各自的配置来决定该server的状态(配置文件里面的key是peerType，可选的值是participant、observer，如果不配置learnerType默认是LearnerType.PARTICIPANT)
&lt;ol&gt;&lt;li&gt;如果配置的learnerType是LearnerType.PARTICIPANT，则状态为ServerState.FOLLOWING&lt;/li&gt;
&lt;li&gt;否则，状态为ServerState.OBSERVING&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;准备同步&quot;&gt;准备同步&lt;/h3&gt;
&lt;p&gt;leader开始工作的入口就是leader.lead方法，这里的leader是Leader的实例，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846961/201905/846961-20190506002028586-701072024.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;准备的过程是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建leader的实例，Leader，构造方法中传入LeaderZooKeeperServer的实例&lt;/li&gt;
&lt;li&gt;调用leader.lead
&lt;ul&gt;&lt;li&gt;加载ZKDatabase&lt;/li&gt;
&lt;li&gt;监听指定的端口（配置的用来监听learner连接请求的端口，配置的第一个冒号后的端口），接收来自follower的请求&lt;/li&gt;
&lt;li&gt;while循环，检查当前选举的状态是否发生变化需要重新进行选举&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时，follower设置完自己的状态后，也开始进行类似leader的工作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846961/201905/846961-20190506002046172-2119708776.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建follower，也就是Follower的实例，同时创建FollowerZooKeeperServer&lt;/li&gt;
&lt;li&gt;建立和leader的连接&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;进行同步&quot;&gt;进行同步&lt;/h3&gt;
&lt;p&gt;同步的总体过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846961/201905/846961-20190506002115031-1195624027.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在准备阶段完成follower连接到leader，具备通信状态&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;leader阻塞等待follower发来的第一个packet
&lt;ol&gt;&lt;li&gt;校验packet类型是否是Leader.FOLLOWERINFO或者Leader.OBSERVERINFO&lt;/li&gt;
&lt;li&gt;读取learner信息
&lt;ol&gt;&lt;li&gt;sid&lt;/li&gt;
&lt;li&gt;protocolVersion&lt;/li&gt;
&lt;li&gt;校验follower的version不能比leader的version还要新&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;leader发送packet(Leader.LEADERINFO)给follower&lt;/li&gt;
&lt;li&gt;follower收到Leader.LEADERINFO后给leader回复Leader.ACKEPOCH&lt;/li&gt;
&lt;li&gt;leader根据follower ack的packet内容来决定同步的策略
&lt;ol&gt;&lt;li&gt;lastProcessedZxid == peerLastZxid，leader的zxid和follower的相同&lt;/li&gt;
&lt;li&gt;peerLastZxid &amp;gt; maxCommittedLog &amp;amp;&amp;amp; !isPeerNewEpochZxid follower超前，删除follower多出的txlog部分&lt;/li&gt;
&lt;li&gt;(maxCommittedLog &amp;gt;= peerLastZxid) &amp;amp;&amp;amp; (minCommittedLog &amp;lt;= peerLastZxid) follower落后于leader，处于leader的中间 同步(peerLaxtZxid, maxZxid]之间的commitlog给follower&lt;/li&gt;
&lt;li&gt;peerLastZxid &amp;lt; minCommittedLog &amp;amp;&amp;amp; txnLogSyncEnabled follower落后于leader，使用txlog和commitlog同步给follower&lt;/li&gt;
&lt;li&gt;接下来leader会不断的发送packet给follower，follower处理leader发来的每个packet&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;同步完成后follower回复ack给leader&lt;/li&gt;
&lt;li&gt;leader、follower进入正式处理客户端请求的while循环&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;zookeeper为了保证启动后leader和follower的数据一致，在启动的时候就进行数据同步，leader与follower数据传输的端口和leader选举的端口不一样。数据同步完成后就可以接受client的请求进行处理了。&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 16:19:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<og:description>zookeeper集群启动的时候，首先读取配置，接着开始选举，选举完成以后，每个server根据选举的结果设置自己的角色，角色设置完成后leader需要和所有的follower同步。上面一篇介绍了le</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/10817333.html</dc:identifier>
</item>
<item>
<title>c#语法复习总结（1）-浅谈c#.net - 在神</title>
<link>http://www.cnblogs.com/zaisheng/p/10817218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zaisheng/p/10817218.html</guid>
<description>
&lt;p&gt;出来工作两年，发现自己进步太小了，工作能力是不能混的，想先从基础知识好好复习一下，再深入的学习一些高级框架和先进的理念。找回了博客园的密码账号，好好学习和总结。先从数据类型总结一下，无非就是值类型，引用类型，在菜鸟教程上看到一种指针类型，这个之前没学习到之后总结一下。说明一下，个人总结方便查看，快速的话推荐看菜鸟教程，实体书效果更好，我自己买了一本厚厚的C#...&lt;/p&gt;
&lt;p&gt; c# .net关系，&lt;strong&gt;c#是语言，.net是框架&lt;/strong&gt;。大体是这样，有时候面试题也会这样问c# .net关系，这样回答在百度上也可以百度到。个人对c#总结一下，c#是专门为Microsoft的.net framework一起使用设计，它是基于面向对象设计的语言。c#基于.net 两只一起使用。&lt;/p&gt;
&lt;p&gt;.NET Framework的核心是公共语言运行库（CLR）或.NET运行库，一般将CLR控制台下运行的代码称为托管代码（managed code）. 在.NET中完成编译的两种方法：1·将源代码转换为Microsoft中间语言。2·利用CLR把IL编译成平台专用代码。Microsoft中间语言的理念：低级语言，语法简单，（语法简单表现在它使用数字代码而不是文本代码），能快速的转换为本地机器码，对于代码来说这种设计具有重要的有点：平台无关性，提高性能和语言的互操作&lt;/p&gt;
&lt;p&gt;说到托管这个词，就说一个&lt;strong&gt;垃圾回收&lt;/strong&gt;，用来在.NET中进行内存管理，特别是它可以恢复正在恢复在运行的应用程序需要的内存，再说说资源托管与非资源托管 详细有点长引用下（https://www.cnblogs.com/88lang/p/3961797.html）这个是有次面试面到的一道题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;托管资源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;Net平台中，CLR为程序员提供了一种很好的内存管理机制，使得程序员在编写代码时不要显式的去释放自己使用的内存资源（这些在先前C和C++中是需要程序员自己去显式的释放的）。这种管理机制称为GC(garbage collection)。GC的作用是很明显的，当系统内存资源匮乏时，它就会被激发，然后自动的去释放那些没有被使用的&lt;strong&gt;托管资源&lt;/strong&gt;（也就是程序员没有显式释放的对象）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;con&quot;&gt;所以托管就是.net framework 负责帮你管理内存及资源释放，不需要自己控制，当然&lt;strong&gt;对象只针对托管资源（部分引用类型）, 不回收非托管资源&lt;/strong&gt;。 &lt;span class=&quot;con&quot;&gt;像数组，用户定义的类、接口、委托，object，字符串等引用类型，栈上保存着一个地址而已，当栈释放后， 即使对象已经没有用了，但&lt;strong&gt;堆上分配的内存还在&lt;/strong&gt;，只能等&lt;strong&gt;GC收集时才能真正释放&lt;/strong&gt; ；但注意int,string,float,DateTime之类的值类型，GC会&lt;strong&gt;自动释放&lt;/strong&gt;他们占用的内存，不需要GC来&lt;strong&gt;回收释放&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;con&quot;&gt;那么非托管的资源怎么释放回收呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;&lt;br/&gt;&lt;strong&gt;非托管资源：&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;对于非托管资源，&lt;strong&gt;GC只能跟踪非托管资源的生存期，而不知道如何去释放它&lt;/strong&gt;。这样就会出现当资源用尽时就不能提供资源能够提供的服务，windows的运行速度就会变慢。比如当你链接了数据库，用完后你没有显式的释放数据库资源，如果还是不断的申请数据库资源，那么到一定时候程序就会抛出一个异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;&lt;br/&gt;所以，当我们在类中封装了对非托管资源的操作时，&lt;strong&gt;我们就需要显式，或者是隐式的释放这些资源&lt;/strong&gt;。&lt;strong&gt;在.Net中释放非托管资源主要有2种方式，Dispose，Finalize，&lt;/strong&gt;&lt;span class=&quot;con&quot;&gt;而Finalize和Dispose方法分别就是隐式和显式操作中分别使用到的方法。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;answer-text line&quot; readability=&quot;34&quot;&gt; 
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;例如文件流，数据库的连接，系统的窗口句柄，打印机资源等等，&lt;span class=&quot;con&quot;&gt;当&lt;span class=&quot;con&quot;&gt;你读取文件之后，就需要对各种Stream进行Dispose等操作。比如 SqlDataReader 读取数据完毕之后，需要 reader.Dispose();等&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;con&quot;&gt;Finalize一般情况下用于基类不带close方法或者不带Dispose显式方法的类，也就是说，在Finalize过程中我们需要隐式的去实现非托管资源的释放，然后系统会在Finalize过程完成后，自己的去释放托管资源。&lt;span class=&quot;con&quot;&gt;在.NET中应该尽可能的少用析构函数释放资源，MSDN2上有这样一段话:实现 Finalize 方法或析构函数对性能可能会有负面影响，因此应避免不必要地使用它们。&lt;strong&gt;用 Finalize 方法回收对象使用的内存需要至少两次垃圾回收&lt;/strong&gt;。所以有析构函数的对象，需要两次，第一次调用析构函数，第二次删除对象。而且在析构函数中包含大量的释放资源代码，会降低垃圾回收器的工作效率，影响性能。&lt;strong&gt;所以对于包含非托管资源的对象，最好及时的调用Dispose()方法来回收资源&lt;/strong&gt;，而不是依赖垃圾回收器。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 还有.net 的一些 中间语言，反射，程序集就不多说 详细可以查查别的博客看看 &lt;/strong&gt;&lt;/p&gt;



</description>
<pubDate>Sun, 05 May 2019 15:46:00 +0000</pubDate>
<dc:creator>在神</dc:creator>
<og:description>出来工作两年，发现自己进步太小了，工作能力是不能混的，想先从基础知识好好复习一下，再深入的学习一些高级框架和先进的理念。找回了博客园的密码账号，好好学习和总结。先从数据类型总结一下，无非就是值类型，引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zaisheng/p/10817218.html</dc:identifier>
</item>
<item>
<title>STM32之模拟串口设计 - 树荫下的阳光</title>
<link>http://www.cnblogs.com/wangshucai/p/10817204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangshucai/p/10817204.html</guid>
<description>&lt;p&gt;一、设计用途：&lt;/p&gt;
&lt;p&gt; 公司PCB制成板降成本，选择的MCU比项目需求少一个串口，为满足制成板成本和项目对串口需求，选择模拟一路串口。&lt;/p&gt;
&lt;p&gt;二、硬件电路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252227/201905/1252227-20190505232154202-1059822249.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;三、设计实现：&lt;/p&gt;
&lt;p&gt;工具&amp;amp;软件：STM32F030R8    KEIL5    STM32CubeMX&lt;/p&gt;
&lt;p&gt;1、 串口通信&lt;/p&gt;
&lt;p&gt;串口是一种很常用的通信接口，按位(bit)发送和接收字节，&lt;a href=&quot;https://baike.so.com/doc/5430972-5669264.html&quot; target=&quot;_blank&quot;&gt;串口通信&lt;/a&gt;是异步传输，端口能够在一根线上发送数据同时在另一根线上接收数据。&lt;a href=&quot;https://baike.so.com/doc/5430972-5669264.html&quot; target=&quot;_blank&quot;&gt;串口通信&lt;/a&gt;最重要的参数是&lt;a href=&quot;https://baike.so.com/doc/663747-702662.html&quot; target=&quot;_blank&quot;&gt;比特率&lt;/a&gt;、&lt;a href=&quot;https://baike.so.com/doc/6144803-6357979.html&quot; target=&quot;_blank&quot;&gt;数据位&lt;/a&gt;、停止位和&lt;a href=&quot;https://baike.so.com/doc/5568344-5783505.html&quot; target=&quot;_blank&quot;&gt;奇偶校验&lt;/a&gt;。对于两个进行通信的端口，这些参数必须匹配，在我们单片机设计中发送和接收一个字节的位格式一般由起始信号位，数据位，停止位组成，很少有校验位，但是可以有。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252227/201905/1252227-20190505232300122-263953928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2、 串口STM32串口硬件实现原理&lt;/p&gt;
&lt;p&gt;既然想要模拟串口通信，那就需要设计得最接近于硬件串口，那么硬件串口是怎样实现数据的采集的呢?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252227/201905/1252227-20190505232320382-137876127.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以设置过采样率为8时进行分析：&lt;/p&gt;
&lt;p&gt;在硬件串口接收线空闲时，串口一般会以一定频率去采集接收线上电平信号，如果辨认出一个特殊序列，1110X0X0X0X0X0X0 则确认接收到起始帧，触发接收中断。在前面判断三个1后如果后面采集到的位中有1则会降噪声位置1，所以在模拟串口时也需要加入噪声处理。&lt;/p&gt;

&lt;p&gt;硬件串口的噪声处理： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252227/201905/1252227-20190505232341778-250912052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252227/201905/1252227-20190505232353559-1148280286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来说，噪声处理就是将采集到的正中间的三位值进行判定，取三个中至少两个相同值作为最终采集值。&lt;/p&gt;

&lt;p&gt;3、 实现方式选择&lt;/p&gt;
&lt;p&gt;在网上大概看了一些前辈做的模拟串口，大致分为以下几种：&lt;/p&gt;
&lt;p&gt;1、 阻塞式：接收使用中断，发送直接在主函数中进行，接收时以波特率的位时间进行定时采集，尽量的将采集点位于位中间。&lt;/p&gt;
&lt;p&gt;2、 非阻塞式：使用一个定时器或者两个定时器，将接收和发送作于中断中，但接收方式基本一致，都只采集一次，未将噪声考虑进入。&lt;/p&gt;
&lt;p&gt;也许每个行业对噪声的关注度都不太一样，但是在我这项目中噪声确是一个不得不面对的一个问题，只为通信更可靠。&lt;/p&gt;

&lt;p&gt;自写第一种实现方式：&lt;/p&gt;
&lt;p&gt;以波特率位时间的1/6进行中断采集，将每一位均分六等份，采集五次，然后取中间三次进行值判断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252227/201905/1252227-20190505232418441-180059386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UartSet.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

uint8_t ucRecvData &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次接收的字节&lt;/span&gt;
uint8_t ucAcquCx = &lt;span&gt;0&lt;/span&gt;;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;三次滤波计数&lt;/span&gt;
uint8_t ucRecvBitCx = &lt;span&gt;0&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收位计数&lt;/span&gt;
uint8_t ucSendBitCx = &lt;span&gt;0&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送位计数&lt;/span&gt;
uint8_t ucSendLengCx = &lt;span&gt;0&lt;/span&gt;;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送长度计数&lt;/span&gt;
&lt;span&gt;
uint8_t ucRecvLastBit &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上次接收位记录&lt;/span&gt;
uint8_t ucRecvNowBit = &lt;span&gt;0&lt;/span&gt;;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前位记录&lt;/span&gt;
uint8_t ucRecvTrueCx = &lt;span&gt;0&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正确计数&lt;/span&gt;
&lt;span&gt;
uint32_t Prescaler &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
uint32_t Period &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
UART gsUARTBuff;               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义串口&lt;/span&gt;
&lt;span&gt;
TIM_HandleTypeDef htim6;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MX_TIM6_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{

    __HAL_RCC_TIM6_CLK_ENABLE();

    htim6.Instance &lt;/span&gt;=&lt;span&gt; TIM6;
    htim6.Init.Prescaler &lt;/span&gt;=&lt;span&gt; Prescaler;
    htim6.Init.CounterMode &lt;/span&gt;=&lt;span&gt; TIM_COUNTERMODE_UP;
    htim6.Init.Period &lt;/span&gt;=&lt;span&gt; Period;
    htim6.Init.AutoReloadPreload &lt;/span&gt;=&lt;span&gt; TIM_AUTORELOAD_PRELOAD_ENABLE;

    HAL_NVIC_SetPriority(TIM6_IRQn, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    HAL_NVIC_EnableIRQ(TIM6_IRQn);

    HAL_TIM_Base_Init(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);

}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; UART_GPIO_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    GPIO_InitTypeDef GPIO_InitStruct &lt;/span&gt;= {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};

    __HAL_RCC_GPIOB_CLK_ENABLE();

    GPIO_InitStruct.Pin &lt;/span&gt;=&lt;span&gt; COM_TX_Pin;
    GPIO_InitStruct.Mode &lt;/span&gt;=&lt;span&gt; GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull &lt;/span&gt;=&lt;span&gt; GPIO_PULLUP;
    GPIO_InitStruct.Speed &lt;/span&gt;=&lt;span&gt; GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(COM_TX_GPIO_Port, &lt;/span&gt;&amp;amp;&lt;span&gt;GPIO_InitStruct);

    GPIO_InitStruct.Pin &lt;/span&gt;=&lt;span&gt; COM_RX_Pin;
    GPIO_InitStruct.Mode &lt;/span&gt;=&lt;span&gt; GPIO_MODE_IT_FALLING;
    GPIO_InitStruct.Pull &lt;/span&gt;=&lt;span&gt; GPIO_PULLUP;
    HAL_GPIO_Init(COM_RX_GPIO_Port, &lt;/span&gt;&amp;amp;&lt;span&gt;GPIO_InitStruct);

    HAL_NVIC_SetPriority(EXTI4_15_IRQn, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);

}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
* @FunctionName   : UART_Init.
* @Description    : 模拟串口结构体初始化.
* @Input          : None.
* @Output         : None.
* @Return         : None.
* @Author&amp;amp;Data    : MrShuCai  2019.4.11.
******************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; UART_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    gsUARTBuff.CheckType &lt;/span&gt;=&lt;span&gt; NONE;
    gsUARTBuff.UartMaxLength &lt;/span&gt;=&lt;span&gt; Uartlength;
    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_NONE_BIT_DEAL;
    UART_GPIO_Init();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(BaudRate == &lt;span&gt;1200&lt;/span&gt;&lt;span&gt;)
    {
        Prescaler &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
        Period &lt;/span&gt;= &lt;span&gt;623&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(BaudRate == &lt;span&gt;2400&lt;/span&gt;&lt;span&gt;)
    {
        Prescaler &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
        Period &lt;/span&gt;= &lt;span&gt;207&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(BaudRate == &lt;span&gt;4800&lt;/span&gt;&lt;span&gt;)
    {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Prescaler = 15;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        Period = 50;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9600&lt;/span&gt;
             Prescaler = &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
             Period &lt;/span&gt;= &lt;span&gt;103&lt;/span&gt;&lt;span&gt;;
    }

    MX_TIM6_Init();
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
* @FunctionName   : UART_Send_Data.
* @Description    : 模拟串口发送数据接口.
* @Input          : None.
* @Output         : None.
* @Return         : None.
* @Author&amp;amp;Data    : MrShuCai  2019.4.11.
******************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; UART_Send_Data(uint8_t *&lt;span&gt; data, uint8_t size)
{
    gsUARTBuff.Sendlength &lt;/span&gt;=&lt;span&gt; size;
    memcpy(gsUARTBuff.UART_Send_buf, data, size);
    gsUARTBuff.TxEn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    gsUARTBuff.RxEn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_START_BIT_DEAL;
    HAL_TIM_Base_Start_IT(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
* @FunctionName   : EXTI4_15_IRQHandler.
* @Description    : 接收引脚外部中断，下降沿触发，触发后即进入起始位判断.
* @Input          : None.
* @Output         : None.
* @Return         : None.
* @Author&amp;amp;Data    : MrShuCai  2019.4.11.
******************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; EXTI4_15_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_4) !=&lt;span&gt; RESET)
    {
        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_4);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.UartStat ==&lt;span&gt; COM_NONE_BIT_DEAL)
        {
            gsUARTBuff.RxEn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            ucRecvData &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_START_BIT_DEAL;
            HAL_TIM_Base_Start_IT(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);
        }
    }
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
* @FunctionName   : TIM6_IRQHandler.
* @Description    : 中断处理函数，包括发送和接收两部分.
* @Input          : None.
* @Output         : None.
* @Return         : None.
* @Author&amp;amp;Data    : MrShuCai  2019.4.11.
******************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; TIM6_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    HAL_TIM_IRQHandler(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.TxEn == &lt;span&gt;1&lt;/span&gt;)       &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;数据发送，发送优先，无发送后才进入接收状态&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;(gsUARTBuff.UartStat)  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;串口发送位状态判断&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COM_START_BIT_DEAL :
        {
            HAL_GPIO_WritePin(COM_TX_GPIO_Port, COM_TX_Pin, GPIO_PIN_RESET);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(++ ucAcquCx == &lt;span&gt;6&lt;/span&gt;)    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;由于发送时在立即拉低就进入判断，且自加，所以需要加到4，实际延时3个周期&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            {
                gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_DATA_BIT_DEAL;
                ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                ucSendBitCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COM_DATA_BIT_DEAL :
        {

            HAL_GPIO_WritePin(COM_TX_GPIO_Port, COM_TX_Pin, (GPIO_PinState)((gsUARTBuff.UART_Send_buf[ucSendLengCx] &lt;/span&gt;&amp;gt;&amp;gt; ucSendBitCx) &amp;amp; &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(++ ucAcquCx &amp;gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
            {
                ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                            
                ucSendBitCx &lt;/span&gt;++&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucSendBitCx &amp;gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.CheckType ==&lt;span&gt; NONE)
                    {
                        gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_STOP_BIT_DEAL;
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_CHECK_BIT_DEAL;
                    }
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COM_CHECK_BIT_DEAL :
        {

        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COM_STOP_BIT_DEAL :
        {
            HAL_GPIO_WritePin(COM_TX_GPIO_Port, COM_TX_Pin, GPIO_PIN_SET);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(++ ucAcquCx == &lt;span&gt;7&lt;/span&gt;&lt;span&gt;)
            {
                ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                ucSendBitCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucSendLengCx &amp;lt; gsUARTBuff.Sendlength - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                {
                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_START_BIT_DEAL;
                    ucSendLengCx &lt;/span&gt;++&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    ucSendLengCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_NONE_BIT_DEAL;
                    gsUARTBuff.TxEn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    gsUARTBuff.RxEn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

                    HAL_TIM_Base_Stop_IT(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);
                    TIM6&lt;/span&gt;-&amp;gt;CNT = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        }
    }


    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.RxEn == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(gsUARTBuff.UartStat)
        {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; COM_START_BIT_DEAL :                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;起始位 必须连续三次采集正确才认可&lt;/span&gt;
&lt;span&gt;        {
            ucRecvLastBit &lt;/span&gt;=&lt;span&gt; ucRecvNowBit;
            ucRecvNowBit &lt;/span&gt;=&lt;span&gt; HAL_GPIO_ReadPin(COM_RX_GPIO_Port, COM_RX_Pin);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(    ucAcquCx == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                ucAcquCx &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucRecvLastBit ==&lt;span&gt; ucRecvNowBit)
            {
                ucRecvTrueCx &lt;/span&gt;++&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(++ ucAcquCx &amp;gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucRecvTrueCx &amp;gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_DATA_BIT_DEAL;
                    ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    ucRecvTrueCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    ucRecvTrueCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_STOP_BIT_DEAL;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; COM_DATA_BIT_DEAL :                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据位&lt;/span&gt;
&lt;span&gt;        {

            ucRecvLastBit &lt;/span&gt;=&lt;span&gt; ucRecvNowBit;
            ucRecvNowBit &lt;/span&gt;=&lt;span&gt; HAL_GPIO_ReadPin(COM_RX_GPIO_Port, COM_RX_Pin);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt; ==&lt;span&gt; ucAcquCx)
            {
                ucAcquCx &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucRecvNowBit ==&lt;span&gt; ucRecvLastBit)
            {
                ucRecvTrueCx &lt;/span&gt;++&lt;span&gt;;
            }


            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(++ ucAcquCx &amp;gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
            {
                ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucRecvTrueCx &amp;gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucRecvLastBit == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
                    {
                        ucRecvData &lt;/span&gt;|= (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; ucRecvBitCx);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        ucRecvData &lt;/span&gt;&amp;amp;= ~(&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; ucRecvBitCx);
                    }

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucRecvBitCx &amp;gt;= &lt;span&gt;7&lt;/span&gt;&lt;span&gt;)
                    {
                        ucRecvBitCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.CheckType ==&lt;span&gt; NONE)
                        {
                            gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_STOP_BIT_DEAL;
                        }
                        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                        {
                            gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_CHECK_BIT_DEAL;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        ucRecvBitCx &lt;/span&gt;++&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    ucRecvTrueCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_STOP_BIT_DEAL;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; COM_CHECK_BIT_DEAL :                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验位&lt;/span&gt;
&lt;span&gt;        {

        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; COM_STOP_BIT_DEAL :                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止位&lt;/span&gt;
&lt;span&gt;        {

            ucRecvLastBit &lt;/span&gt;=&lt;span&gt; ucRecvNowBit;
            ucRecvNowBit &lt;/span&gt;=&lt;span&gt; HAL_GPIO_ReadPin(COM_RX_GPIO_Port, COM_RX_Pin);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt; ==&lt;span&gt; ucAcquCx)
            {
                ucAcquCx &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucRecvNowBit == ucRecvLastBit &amp;amp;&amp;amp; ucRecvNowBit == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                ucRecvTrueCx &lt;/span&gt;++&lt;span&gt;;
            }


            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( ++ ucAcquCx &amp;gt;= &lt;span&gt;6&lt;/span&gt;&lt;span&gt;)
            {
                ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucRecvTrueCx &amp;gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;)
                {
                                      ucRecvTrueCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.Recvlength &amp;lt;&lt;span&gt; gsUARTBuff.UartMaxLength)
                    {
                        gsUARTBuff.UART_Recv_buf[gsUARTBuff.Recvlength] &lt;/span&gt;=&lt;span&gt; ucRecvData;
                        gsUARTBuff.Recvlength &lt;/span&gt;++&lt;span&gt;;
                    }

                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_NONE_BIT_DEAL;
                    HAL_TIM_Base_Stop_IT(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);
                    TIM6&lt;/span&gt;-&amp;gt;CNT = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    ucRecvTrueCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在使用中已经达到要求，无错误识别，但是由于在电路中使用了光耦，所以波形存在一定形变，不能及时将电平立即拉低，同时中断次数还是比较频繁的，为减少误判和减少中断次数，采取另一种方式。&lt;/p&gt;

&lt;p&gt;4、 最优实现&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1252227/201905/1252227-20190505232613207-706980555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;减少中断次数，每位只需中断三次，同时为避免光耦导致的滞后，将前面部分过滤不采集，只在中间快速采集三次，动态实现定时器定时时间调整。&lt;/p&gt;
&lt;p&gt;比如在4800波特率下，一位208us，则定时器从起始位开始，定时序列为80，20，20，168，20，20，168，20，20，168......这样的序列。168为前一位的最后定时时间加当前位的前80us时间，也就是上图的起始位的4位置到第0位的2位置的时间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UartSet.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
#include &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

typedef &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt;
{
    TimeRecvStartStep1 &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,
    TimeRecvStep2 &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
    TimeRecvStep3 &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;,
    TimeRecvStep1 &lt;/span&gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;,
    TimeSendStep &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;,

} TimeStep;

uint16_t TimeSet[&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];

uint16_t TimeSetBuff[][&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;] = {{&lt;span&gt;1199&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;, &lt;span&gt;2378&lt;/span&gt;, &lt;span&gt;2498&lt;/span&gt; }, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1200&lt;/span&gt;
    {&lt;span&gt;539&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;, &lt;span&gt;1128&lt;/span&gt;, &lt;span&gt;1247&lt;/span&gt; },  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2400&lt;/span&gt;
    {&lt;span&gt;239&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;, &lt;span&gt;59&lt;/span&gt;, &lt;span&gt;503&lt;/span&gt;, &lt;span&gt;624&lt;/span&gt;  },   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;4800&lt;/span&gt;
    {&lt;span&gt;149&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;29&lt;/span&gt;, &lt;span&gt;251&lt;/span&gt;, &lt;span&gt;311&lt;/span&gt;  },   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;9600&lt;/span&gt;
    {&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;    },         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;预留&lt;/span&gt;
&lt;span&gt;};

UART gsUARTBuff;                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义串口&lt;/span&gt;
&lt;span&gt;
uint8_t ucRecvData &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次接收的字节&lt;/span&gt;
uint8_t ucAcquCx = &lt;span&gt;0&lt;/span&gt;;           &lt;span&gt;//&lt;/span&gt;&lt;span&gt;三次滤波计数&lt;/span&gt;
uint8_t ucRecvBitCx = &lt;span&gt;0&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收位计数&lt;/span&gt;
uint8_t ucSendBitCx = &lt;span&gt;0&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送位计数&lt;/span&gt;
uint8_t ucSendLengCx = &lt;span&gt;0&lt;/span&gt;;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送长度计数&lt;/span&gt;
&lt;span&gt;
uint8_t ucRecvBitBuff &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;采集位保存&lt;/span&gt;
&lt;span&gt;

TIM_HandleTypeDef htim6;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; MX_TIM6_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{

    __HAL_RCC_TIM6_CLK_ENABLE();

    htim6.Instance &lt;/span&gt;=&lt;span&gt; TIM6;
    htim6.Init.Prescaler &lt;/span&gt;= &lt;span&gt;15&lt;/span&gt;&lt;span&gt;;
    htim6.Init.CounterMode &lt;/span&gt;=&lt;span&gt; TIM_COUNTERMODE_UP;
    htim6.Init.Period &lt;/span&gt;=&lt;span&gt; TimeSet[TimeRecvStartStep1];
    htim6.Init.AutoReloadPreload &lt;/span&gt;=&lt;span&gt; TIM_AUTORELOAD_PRELOAD_ENABLE;

    HAL_NVIC_SetPriority(TIM6_IRQn, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    HAL_NVIC_EnableIRQ(TIM6_IRQn);

    HAL_TIM_Base_Init(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);

}


&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; UART_GPIO_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    GPIO_InitTypeDef GPIO_InitStruct &lt;/span&gt;= {&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};

    __HAL_RCC_GPIOB_CLK_ENABLE();

    GPIO_InitStruct.Pin &lt;/span&gt;=&lt;span&gt; COM_TX_Pin;
    GPIO_InitStruct.Mode &lt;/span&gt;=&lt;span&gt; GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull &lt;/span&gt;=&lt;span&gt; GPIO_PULLUP;
    GPIO_InitStruct.Speed &lt;/span&gt;=&lt;span&gt; GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(COM_TX_GPIO_Port, &lt;/span&gt;&amp;amp;&lt;span&gt;GPIO_InitStruct);

    GPIO_InitStruct.Pin &lt;/span&gt;=&lt;span&gt; COM_RX_Pin;
    GPIO_InitStruct.Mode &lt;/span&gt;=&lt;span&gt; GPIO_MODE_IT_FALLING;
    GPIO_InitStruct.Pull &lt;/span&gt;=&lt;span&gt; GPIO_PULLUP;
    HAL_GPIO_Init(COM_RX_GPIO_Port, &lt;/span&gt;&amp;amp;&lt;span&gt;GPIO_InitStruct);

    HAL_NVIC_SetPriority(EXTI4_15_IRQn, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);

}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
* @FunctionName   : UART_Init.
* @Description    : 模拟串口结构体初始化.
* @Input          : None.
* @Output         : None.
* @Return         : None.
* @Author&amp;amp;Data    : MrShuCai  2019.4.11.
******************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; UART_Init(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    gsUARTBuff.CheckType &lt;/span&gt;=&lt;span&gt; NONE;
    gsUARTBuff.UartMaxLength &lt;/span&gt;=&lt;span&gt; Uartlength;
    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_NONE_BIT_DEAL;
    UART_GPIO_Init();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(BaudRate == &lt;span&gt;1200&lt;/span&gt;&lt;span&gt;)
    {
        memcpy(TimeSet, &lt;/span&gt;&amp;amp;TimeSetBuff[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(TimeSet));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(BaudRate == &lt;span&gt;2400&lt;/span&gt;&lt;span&gt;)
    {
        memcpy(TimeSet, &lt;/span&gt;&amp;amp;TimeSetBuff[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(TimeSet));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(BaudRate == &lt;span&gt;4800&lt;/span&gt;&lt;span&gt;)
    {
        memcpy(TimeSet, &lt;/span&gt;&amp;amp;TimeSetBuff[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(TimeSet));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(BaudRate == &lt;span&gt;9600&lt;/span&gt;&lt;span&gt;)
    {
        memcpy(TimeSet, &lt;/span&gt;&amp;amp;TimeSetBuff[&lt;span&gt;3&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(TimeSet));
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {

    }

    MX_TIM6_Init();
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
* @FunctionName   : UART_Send_Data.
* @Description    : 模拟串口发送数据接口.
* @Input          : None.
* @Output         : None.
* @Return         : None.
* @Author&amp;amp;Data    : MrShuCai  2019.4.11.
******************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; UART_Send_Data(uint8_t *&lt;span&gt; data, uint8_t size)
{
    gsUARTBuff.Sendlength &lt;/span&gt;=&lt;span&gt; size;
    memcpy(gsUARTBuff.UART_Send_buf, data, size);
   
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.UartStat ==&lt;span&gt; COM_NONE_BIT_DEAL)
        {
            gsUARTBuff.TxEn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            gsUARTBuff.RxEn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_START_BIT_DEAL;

            TIM6&lt;/span&gt;-&amp;gt;ARR =&lt;span&gt; TimeSet[TimeSendStep];
            TIM6&lt;/span&gt;-&amp;gt;EGR =&lt;span&gt; TIM_EGR_UG;

            HAL_TIM_Base_Start_IT(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);
        }
      
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
* @FunctionName   : EXTI4_15_IRQHandler.
* @Description    : 接收引脚外部中断，下降沿触发，触发后即进入起始位判断.
* @Input          : None.
* @Output         : None.
* @Return         : None.
* @Author&amp;amp;Data    : MrShuCai  2019.4.11.
******************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; EXTI4_15_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(__HAL_GPIO_EXTI_GET_IT(GPIO_PIN_4) !=&lt;span&gt; RESET)
    {
        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_4);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.UartStat ==&lt;span&gt; COM_NONE_BIT_DEAL)
        {
            gsUARTBuff.RxEn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            ucRecvData &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_START_BIT_DEAL;

            TIM6&lt;/span&gt;-&amp;gt;ARR =&lt;span&gt; TimeSet[TimeRecvStartStep1];
            TIM6&lt;/span&gt;-&amp;gt;EGR = TIM_EGR_UG;                  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化定时器&lt;/span&gt;
                      EXTI-&amp;gt;IMR &amp;amp;= ~(&lt;span&gt;0x10&lt;/span&gt;&lt;span&gt;);
                      EXTI&lt;/span&gt;-&amp;gt;EMR &amp;amp;= ~(&lt;span&gt;0x10&lt;/span&gt;&lt;span&gt;);
            HAL_TIM_Base_Start_IT(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);
        }
    }

}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
* @FunctionName   : BitValueChk.
* @Description    : 判断采集bit值，三次中为1的次数大于等于2则值为1否则为0.
* @Input          : n 采集记录的位值.
* @Output         : BitValue.
* @Return         : BitValue.
* @Author&amp;amp;Data    : MrShuCai  2019.5.1.
******************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
uint8_t BitValueChk(uint8_t n)
{
    uint8_t BitValCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(BitValCx = &lt;span&gt;0&lt;/span&gt;; n; n &amp;gt;&amp;gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        BitValCx &lt;/span&gt;+= n &amp;amp; &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (BitValCx &amp;lt; &lt;span&gt;2&lt;/span&gt;) ? (&lt;span&gt;0&lt;/span&gt;) : (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;******************************************************************************
* @FunctionName   : TIM6_IRQHandler.
* @Description    : 中断处理函数，包括发送和接收两部分.
* @Input          : None.
* @Output         : None.
* @Return         : None.
* @Author&amp;amp;Data    : MrShuCai  2019.4.11.
******************************************************************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; TIM6_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{

    HAL_TIM_IRQHandler(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.TxEn == &lt;span&gt;1&lt;/span&gt;)         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;数据发送，发送优先，无发送后才进入接收状态&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;(gsUARTBuff.UartStat)  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;串口发送位状态判断&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COM_START_BIT_DEAL :
        {
            HAL_GPIO_WritePin(COM_TX_GPIO_Port, COM_TX_Pin, GPIO_PIN_RESET);
            gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_DATA_BIT_DEAL;
            ucSendBitCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COM_DATA_BIT_DEAL :
        {
            HAL_GPIO_WritePin(COM_TX_GPIO_Port, COM_TX_Pin, (GPIO_PinState)((gsUARTBuff.UART_Send_buf[ucSendLengCx] &lt;/span&gt;&amp;gt;&amp;gt; ucSendBitCx) &amp;amp; &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;));

            ucSendBitCx &lt;/span&gt;++&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucSendBitCx &amp;gt;= &lt;span&gt;8&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.CheckType ==&lt;span&gt; NONE)
                {
                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_STOP_BIT_DEAL;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_CHECK_BIT_DEAL;
                }
            }

        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COM_CHECK_BIT_DEAL :
        {

        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COM_STOP_BIT_DEAL :
        {
            HAL_GPIO_WritePin(COM_TX_GPIO_Port, COM_TX_Pin, GPIO_PIN_SET);

            ucSendBitCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucSendLengCx &amp;lt; gsUARTBuff.Sendlength - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_START_BIT_DEAL;
                ucSendLengCx &lt;/span&gt;++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                ucSendLengCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_NONE_BIT_DEAL;
                gsUARTBuff.TxEn &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                gsUARTBuff.RxEn &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
                HAL_TIM_Base_Stop_IT(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);
                              EXTI&lt;/span&gt;-&amp;gt;IMR |= &lt;span&gt;0x10&lt;/span&gt;&lt;span&gt;;
                          EXTI&lt;/span&gt;-&amp;gt;EMR |= &lt;span&gt;0x10&lt;/span&gt;&lt;span&gt;;
                TIM6 &lt;/span&gt;-&amp;gt;CNT = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }

        }
        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

        }
    }


    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.RxEn == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(gsUARTBuff.UartStat)
        {
                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COM_START_BIT_DEAL :
                    {
                            ucRecvBitBuff &lt;/span&gt;= (ucRecvBitBuff &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;) | (HAL_GPIO_ReadPin(COM_RX_GPIO_Port, COM_RX_Pin) &amp;amp; &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;);

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(++ ucAcquCx &amp;gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
                            {
                                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(BitValueChk(ucRecvBitBuff) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)                        
                                    {
                                            gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_DATA_BIT_DEAL;
                                            TIM6&lt;/span&gt;-&amp;gt;ARR =&lt;span&gt; TimeSet[ucAcquCx];
                                    }
                                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    {
                                            gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_STOP_BIT_DEAL;
                                    }
                                    
                                    ucRecvBitBuff &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                                    ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            {
                                    TIM6&lt;/span&gt;-&amp;gt;ARR =&lt;span&gt; TimeSet[ucAcquCx];
                            }


                    }
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; COM_DATA_BIT_DEAL :                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据位&lt;/span&gt;
&lt;span&gt;                    {

                            ucRecvBitBuff &lt;/span&gt;= (ucRecvBitBuff &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;) | (HAL_GPIO_ReadPin(COM_RX_GPIO_Port, COM_RX_Pin) &amp;amp; &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;);

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(++ ucAcquCx &amp;gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
                            {
                                    ucRecvData &lt;/span&gt;|= (BitValueChk(ucRecvBitBuff) &amp;amp; &lt;span&gt;0x01&lt;/span&gt;) &amp;lt;&amp;lt;&lt;span&gt; ucRecvBitCx;

                                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(ucRecvBitCx &amp;gt;= &lt;span&gt;7&lt;/span&gt;&lt;span&gt;)
                                    {
                                            ucRecvBitCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

                                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.CheckType ==&lt;span&gt; NONE)
                                            {
                                                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_STOP_BIT_DEAL;
                                            }
                                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                            {
                                                    gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_CHECK_BIT_DEAL;
                                            }
                                    }
                                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    {
                                            ucRecvBitCx &lt;/span&gt;++&lt;span&gt;;
                                    }

                                    TIM6&lt;/span&gt;-&amp;gt;ARR =&lt;span&gt; TimeSet[ucAcquCx];

                                    ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                                    ucRecvBitBuff &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            {
                                    TIM6&lt;/span&gt;-&amp;gt;ARR =&lt;span&gt; TimeSet[ucAcquCx];
                            }
                    }
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; COM_CHECK_BIT_DEAL :                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;校验位&lt;/span&gt;
&lt;span&gt;                    {

                    }
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; COM_STOP_BIT_DEAL :                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;停止位&lt;/span&gt;
&lt;span&gt;                    {

                        ucRecvBitBuff &lt;/span&gt;= (ucRecvBitBuff &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;) | (HAL_GPIO_ReadPin(COM_RX_GPIO_Port, COM_RX_Pin) &amp;amp; &lt;span&gt;0x01&lt;/span&gt;&lt;span&gt;);

                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;( ++ ucAcquCx &amp;gt;= &lt;span&gt;3&lt;/span&gt;&lt;span&gt;)
                            { 
                                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(BitValueChk(ucRecvBitBuff) == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)    
                                    {
                                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(gsUARTBuff.Recvlength &amp;lt;&lt;span&gt; gsUARTBuff.UartMaxLength)
                                            {
                                                    gsUARTBuff.UART_Recv_buf[gsUARTBuff.Recvlength] &lt;/span&gt;=&lt;span&gt; ucRecvData;
                                                    gsUARTBuff.Recvlength &lt;/span&gt;++&lt;span&gt;;
                                            }

                                            gsUARTBuff.UartStat &lt;/span&gt;=&lt;span&gt; COM_NONE_BIT_DEAL;
                                            HAL_TIM_Base_Stop_IT(&lt;/span&gt;&amp;amp;&lt;span&gt;htim6);
                                            
                                            EXTI&lt;/span&gt;-&amp;gt;IMR |= &lt;span&gt;0x10&lt;/span&gt;&lt;span&gt;;
                                            EXTI&lt;/span&gt;-&amp;gt;EMR |= &lt;span&gt;0x10&lt;/span&gt;&lt;span&gt;;
                                            TIM6&lt;/span&gt;-&amp;gt;CNT = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                                    }
                                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    {
                                            ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                                    }
                                    
                                    ucRecvBitBuff &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                                    ucAcquCx &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                            }
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                            {
                                    TIM6&lt;/span&gt;-&amp;gt;ARR =&lt;span&gt; TimeSet[ucAcquCx];
                            }
                    }
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送就以波特率时间定时发送位状态即可，实现简单。&lt;/p&gt;
&lt;p&gt;仅供初学或者有兴趣的朋友参考，第一种方法由于后来放弃，只是大致实现，推荐第二种，欢迎大家指点。&lt;/p&gt;
</description>
<pubDate>Sun, 05 May 2019 15:43:00 +0000</pubDate>
<dc:creator>树荫下的阳光</dc:creator>
<og:description>一、设计用途： 公司PCB制成板降成本，选择的MCU比项目需求少一个串口，为满足制成板成本和项目对串口需求，选择模拟一路串口。 二、硬件电路： 三、设计实现： 工具&amp;软件：STM32F030R</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangshucai/p/10817204.html</dc:identifier>
</item>
<item>
<title>Mysql（7）---存储过程 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10816954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10816954.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;存储过程接下来会有三篇相关博客&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一篇存储过程常用语法。&lt;/li&gt;
&lt;li&gt;第二篇存储过程中的游标。&lt;/li&gt;
&lt;li&gt;第三篇单独讲一个实际开发过程中复杂的真实的案例。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一概述&quot;&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;什么是存储过程&quot;&gt;1、什么是存储过程&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;概述&lt;/code&gt;：简单的说，就是&lt;code&gt;一组SQL语句集&lt;/code&gt;，功能强大，可以实现一些比较&lt;code&gt;复杂&lt;/code&gt;的逻辑功能，类似于JAVA语言中的方法；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; :存储过程跟触发器有点类似，都是一组SQL集，但是存储过程是主动调用的，且功能比触发器更加强大，触发器是某件事触发后自动调用。&lt;/p&gt;
&lt;h4 id=&quot;优点&quot;&gt;2、优点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;提高代码的重用性&lt;/li&gt;
&lt;li&gt;简化操作&lt;/li&gt;
&lt;li&gt;减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二delimiter命令&quot;&gt;&lt;span&gt;二、delimiter命令&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;讲存储过程先讲下delimiter命令。我们都知道sql语句默认都是以分号';'解释。如果下select * from test_table;&lt;/p&gt;
&lt;p&gt;这个会有一个问题对于存储过程：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE  PROCEDURE `proc_if`(IN type int)
BEGIN
    DECLARE c varchar(500);
    IF type = 0 THEN
        set c = 'param is 0';
    ELSEIF type = 1 THEN
        set c = 'param is 1';
    ELSE
        set c = 'param is others, not 0 or 1';
    END IF;
    select c;
END;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上面的存储过程,它们应该是一个整体，应该是一起执行，而不是遇到&lt;code&gt;分号&lt;/code&gt;就执行。默认情况下，不可能等到用户把这些语句全部输入完之后，再执行整段语句。 因为mysql一遇到分号，它就要自动执行。 即，在语句遇到';'时，mysql解释器就要执行了。 这种情况下，就需要事先把delimiter换成其它符号，如//或$$。&lt;/p&gt;
&lt;p&gt;这个时候&lt;code&gt;delimiter&lt;/code&gt;命令就起作用了。&lt;/p&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;# 这路我们讲默认的 ; 结尾改成 $ 再执行下面语句
DELIMITER $
select * from mall_pro ;
select * from member ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会发现能之前能正常执行的语句这里报错了,因为现在修改结尾标志为 &lt;code&gt;$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190505230221263-959933307.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们改成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select * from mall_pro $
select * from member $&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190505230231966-208000816.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;重点&lt;/code&gt;：delimiter作用域是会话级别的，当你设置了&lt;code&gt;DELIMITER $&lt;/code&gt;那么在当前会话级别都是变成以$结束。&lt;/p&gt;
&lt;p&gt;附一个详细讲delimiter的博客：&lt;a href=&quot;https://www.cnblogs.com/nickup/p/6628892.html&quot;&gt;MySql中 delimiter 详解&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三存储过程语法&quot;&gt;&lt;span&gt;三、存储过程语法&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;创建&quot;&gt;1、创建&lt;/h4&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE PROCEDURE 存储过程名(参数列表)
BEGIN
     # 存储过程体（一组合法的SQL语句）
END&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;参数说明&quot;&gt;2、参数说明&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1) 参数列表包含三部分&lt;/strong&gt;&lt;br/&gt;参数模式 参数名 参数类型&lt;br/&gt;举例：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;in stuname varchar(20)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以写成stuname varchar(20) 但最好把 in 加上。&lt;br/&gt;&lt;strong&gt;2) 参数模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;in：该参数可以作为输入，也就是该参数需要调用方传入值。
out：该参数可以作为输出，也就是该参数可以作为返回值。
inout：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;调用&quot;&gt;3、调用&lt;/h4&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CALL 存储过程名(实参列表);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;删除&quot;&gt;4、删除&lt;/h4&gt;
&lt;p&gt;如果存在该存储过程 则删除该存储过程。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;drop procedure if exists 存储过程名称&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;重点&lt;/code&gt;：存储过程体中的每条sql语句的结尾要求必须加&lt;code&gt;分号&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;：如果存储过程体仅仅只有一句话，begin end可以省略。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;：存储过程的结尾可以使用 delimiter 重新设置（一般如果存储过程中存在多个分号结尾，就可以使用delimiter）&lt;/p&gt;
&lt;h4 id=&quot;示例&quot;&gt;5、示例&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1）空参列表&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;# 案例：插入到admin表中五条记录
DELIMITER $
CREATE PROCEDURE myp1()
BEGIN
    INSERT INTO admin(username,`password`) 
    VALUES('john1','0000'),('lily','0000'),('rose','0000'),('jack','0000'),('tom','0000');
END $
# 调用
CALL myp1()$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2):创建带in模式参数的存储过程&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;## 创建存储过程实现 根据女神名，查询对应的男神信息
CREATE PROCEDURE myp2(IN beautyName VARCHAR(20))
BEGIN
    SELECT bo.*
    FROM boys bo
    RIGHT JOIN beauty b ON bo.id = b.boyfriend_id
    WHERE b.name=beautyName;
END $
#  调用
CALL myp2('柳岩')$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3) ：创建存储过程实现，用户是否登录成功&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE PROCEDURE myp4(IN username VARCHAR(20),IN PASSWORD VARCHAR(20))
BEGIN
    DECLARE result INT DEFAULT 0;# 声明并初始化
    SELECT COUNT(*) INTO result# 赋值
    FROM admin
    WHERE admin.username = username
    AND admin.password = PASSWORD;
    SELECT IF(result&amp;gt;0,'成功','失败');# 使用
END $
# 调用
CALL myp3('张飞','8888')$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;4) 带有IN 和 OUT 参数&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE PROCEDURE myp7(IN beautyName VARCHAR(20),OUT boyName VARCHAR(20),OUT usercp INT) 
BEGIN
    SELECT boys.boyname ,boys.usercp INTO boyname,usercp
    FROM boys 
    RIGHT JOIN
    beauty b ON b.boyfriend_id = boys.id
    WHERE b.name=beautyName ;
END $
# 调用
CALL myp7('小昭',@name,@cp)$ # 注意OUT的变量一定要是用户自定义的用户变量。
SELECT @name,@cp$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;5) 创建带inout模式参数的存储过程&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;# 传入a和b两个值，最终a和b都翻倍并返回
DELIMITER $
CREATE PROCEDURE myp8(INOUT a INT ,INOUT b INT)
BEGIN
    SET a=a*2;
    SET b=b*2;
END $
# 调用
SET @m=10$
SET @n=20$
CALL myp8(@m,@n)$
# 输出 20 和 40
SELECT @m,@n$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里都是举了写简单的例子，后面会根据实际开发过程写一个复杂的存储过程。&lt;/p&gt;

&lt;h2 id=&quot;三流程控制结构&quot;&gt;&lt;span&gt;三、流程控制结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们知道java对于流程控制有：if、switch。对于Mysql也一样，它有它自己的流程控制语句，下面我们一个一个来分析。&lt;/p&gt;
&lt;h4 id=&quot;if语句&quot;&gt;1、IF语句&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1) if函数&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;语法：if(条件,值1，值2)
功能：实现双分支
应用在begin end中或外面&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2) if结构&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;# 如果expression为true 执行 statements
IF expression THEN 
   statements;
END IF;  # 有IF一定要有 END IF

# 如果expression为true 执行 statements 否则执行else-statements
IF expression THEN
   statements;
ELSE
   else-statements;
END IF;

# 不说了。
IF expression THEN
   statements;
ELSEIF elseif-expression THEN
   elseif-statements;
...
ELSE
   else-statements;
END IF;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;重点&lt;/code&gt;:IF结构最后都需要&lt;code&gt;END IF&lt;/code&gt;;结尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3)示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;DELIMITER $
CREATE PROCEDURE test_if(score FLOAT) 
BEGIN
    DECLARE ch CHAR DEFAULT 'A';
    IF score&amp;gt;90 THEN SET ch='A';
    ELSEIF score&amp;gt;80 THEN SET ch='B';
    ELSEIF score&amp;gt;60 THEN SET ch='C';
    ELSE SET ch='D';
    END IF;
    select ch;  
END $

call test_if(87)
#输出 B&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;case结构&quot;&gt;2.case结构&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1、语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;#情况1：类似于switch
case 变量或表达式
when 值1 then 语句1;
when 值2 then 语句2;
...
else 语句n;
end 

#情况2：
case 
when 条件1 then 语句1;
when 条件2 then 语句2;
...
else 语句n;
end 
#应用在begin end 中或外面&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;DELIMITER $
CREATE PROCEDURE test_case(in score FLOAT) 
BEGIN 
    DECLARE ch CHAR DEFAULT 'A';
    CASE 
    WHEN score&amp;gt;90 THEN SET ch='A';
    WHEN score&amp;gt;80 THEN SET ch='B';
    WHEN score&amp;gt;60 THEN SET ch='C';
    ELSE SET ch='D';
    END CASE;   
    select ch;
END $

call test_case(56)$
# 输出 D&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;五循环结构&quot;&gt;&lt;span&gt;五、循环结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于java循环结构有：for、while、do-while。而对于mysql则有：&lt;code&gt;while、loop、repeat&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;还有很重要的一点，对于java跳出循环有:continue 和 break。对于mysql也有自己跳出循环命令。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;iterate: 类似于 continue，继续，结束本次循环，继续下一次
leave:   类似于  break，跳出，结束当前所在的循环
# 至于它们怎么用，下面会举例说明&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;while&quot;&gt;1.while&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;特点&lt;/code&gt;：先判断后执行。(相当于java中while)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;【标签:】while 循环条件 do
    循环体;
 end while【 标签】;
 # 当你需要用到 iterate 或者 leave 时就需要用到标签。如果不需要用到这两个那么可以不需要标签&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2）示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;#案例：1+2+...100
DELIMITER $
drop procedure if exists `pro_while1` $
CREATE PROCEDURE pro_while1(IN insertCount INT)
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    WHILE i&amp;lt;=insertCount DO
        set total:=total+i;
        SET i=i+1;
    END WHILE;
    select total;
END $

# 输出：5050
CALL pro_while1(100)$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3）带有leave语句示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;#案例：1+2+...100
DELIMITER $
drop procedure if exists `pro_while1` $
CREATE PROCEDURE pro_while1(IN insertCount INT)
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    a:WHILE i&amp;lt;=insertCount DO
          IF i=11 THEN  LEAVE a; #当i=11是跳出循环 这里就需要用到标签了
          END IF;
    set total:=total+i;
    SET i=i+1;
    END WHILE a;
    select total;
END $

# 输出：55
CALL pro_while1(100)$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就用到&lt;code&gt;标签&lt;/code&gt;（这里为a)了。&lt;/p&gt;
&lt;h4 id=&quot;repeat&quot;&gt;2、repeat&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1) 语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;特点&lt;/code&gt;：先执行后判断。(相当于Do-while)&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;【标签：】repeat
    循环体;
until 结束循环的条件
end repeat 【标签】;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2）示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;#案例：1+2+...100
DELIMITER $
drop procedure if exists `pro_while1` $
CREATE PROCEDURE pro_while1(IN insertCount INT)
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    repeat 
    set total:=total+i;
    SET i=i+1;
    until i=10 #这里不需要分号
    END repeat;
    select total;
END $
# 输出：45
CALL pro_while1(100)$&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;loop&quot;&gt;3、loop&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;特点&lt;/code&gt;：简单死循环。(相当于while(true))&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;【标签:】loop
    循环体;
end loop 【标签】;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2) 示例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;#案例：1+2+...100
DELIMITER $
drop procedure if exists `pro_while1` $
CREATE PROCEDURE pro_while1(IN insertCount INT)
BEGIN
    DECLARE total INT DEFAULT 0;
    DECLARE i INT DEFAULT 1;
    a:loop 
    IF i=11 THEN
    LEAVE a;
    END IF;
    set total:=total+i;
    SET i=i+1;
    END loop a;
    select total;
END $

# 输出：55
CALL pro_while1(100)$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt;: 有while一定要有 end while。有repeat一定要有end repeat。有loop一定要有end loop。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将9）
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 05 May 2019 15:21:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Mysql（7） 存储过程 存储过程接下来会有三篇相关博客 第一篇存储过程常用语法。 第二篇存储过程中的游标。 第三篇单独讲一个实际开发过程中复杂的真实的案例。 一、概述 1、什么是存储过程 ：简单的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10816954.html</dc:identifier>
</item>
</channel>
</rss>