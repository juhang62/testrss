<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>matplotlib简单示例 - 傻傻de</title>
<link>http://www.cnblogs.com/dblsha/p/10111889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dblsha/p/10111889.html</guid>
<description>&lt;h2 id=&quot;一简介&quot;&gt;一、简介&lt;/h2&gt;
&lt;p&gt;以下引用自百度百科&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形 。&lt;br/&gt;通过 Matplotlib，开发者可以仅需要几行代码，便可以生成绘图，直方图，功率谱，条形图，错误图，散点图等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二流程&quot;&gt;二、流程&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 明确要研究的问题&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;2. 选择需要使用什么图形（折线图、直方图……）来呈现&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;3. 准备相应的数据&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;4. 绘制图形和完善美化图形&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在某些情况下，个人认为还有最后一点，是&lt;span&gt;&lt;strong&gt;从图中可以得出什么结论。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;以下只是简单的示例，就没有一定按照上面的流程。&lt;/p&gt;
&lt;h2 id=&quot;三简单示例&quot;&gt;三、简单示例&lt;/h2&gt;
&lt;h4 id=&quot;折线图&quot;&gt;1.折线图&lt;/h4&gt;
&lt;h5 id=&quot;什么是折线图&quot;&gt;&lt;span&gt;1.1 什么是折线图&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;以下引用自百度百科&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;折线图是排列在工作表的列或行中的数据可以绘制到折线图中。折线图可以显示随时间（根据常用比例设置）而变化的连续数据，因此非常适用于显示在相等时间间隔下数据的趋势。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，&lt;span&gt;&lt;strong&gt;折线图可以反映事物的变化情况。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 id=&quot;准备数据&quot;&gt;&lt;span&gt;1.2 准备数据&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;数据来自&lt;a href=&quot;http://data.stats.gov.cn/easyquery.htm?cn=C01&quot;&gt;国家数据&lt;/a&gt;，选取了1978年至2017年的&lt;strong&gt;研究生招生数&lt;/strong&gt;和&lt;strong&gt;研究生毕业生数&lt;/strong&gt;，下面只列举了部分数据。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;研究生招生数(万人)&lt;/td&gt;
&lt;td&gt;80.6103&lt;/td&gt;
&lt;td&gt;66.7064&lt;/td&gt;
&lt;td&gt;64.5055&lt;/td&gt;
&lt;td&gt;62.1323&lt;/td&gt;
&lt;td&gt;61.1381&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;研究生毕业生数(万人)&lt;/td&gt;
&lt;td&gt;57.8045&lt;/td&gt;
&lt;td&gt;56.3938&lt;/td&gt;
&lt;td&gt;55.1522&lt;/td&gt;
&lt;td&gt;53.5863&lt;/td&gt;
&lt;td&gt;51.3626&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;绘制完善图形&quot;&gt;&lt;span&gt;1.3 绘制完善图形&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;附上代码，看注释吧。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt
from matplotlib import font_manager

# matplotlib默认不支持中文字符，设置中文字体，参数的值为系统字体路径
my_font = font_manager.FontProperties(fname=r&quot;C:\Windows\Fonts\simsun.ttc&quot;)

# 需要绘制的数据
x = list(range(1978, 2018))
y_recruit = list(reversed(
    [80.6103, 66.7064, 64.5055, 62.1323, 61.1381, 58.9673, 56.0168, 53.8177, 51.0953, 44.6422, 41.8612, 39.7925,
     36.4831, 32.6286, 26.8925, 20.2611, 16.5197, 12.8484, 9.2225, 7.2508, 6.3749, 5.9398, 5.1053, 5.0864, 4.2145,
     3.3439, 2.9679, 2.9649, 2.8569, 3.5645, 3.9017, 4.131, 4.6871, 2.3181, 1.5642, 1.108, 0.9363, 0.3616, 0.811,
     1.0708]))
y_graduate = list(reversed(
    [57.8045, 56.3938, 55.1522, 53.5863, 51.3626, 48.6455, 42.9994, 38.36, 37.1273, 34.4825, 31.1839, 25.5902, 18.9728,
     15.0777, 11.1091, 8.0841, 6.7809, 5.8767, 5.467, 4.7077, 4.6539, 3.9652, 3.1877, 2.8047, 2.8214, 2.5692, 3.2537,
     3.544, 3.7232, 4.0838, 2.7603, 1.695, 1.7004, 0.2756, 0.4497, 0.4058, 1.1669, 0.0476, 0.014, 0.0009]))

# 设置图形大小，dpi
plt.figure(figsize=(10,6.18),dpi=100)

# 绘制第一条折线
plt.plot(x,y_recruit,label=&quot;研究生招生数&quot;)
# 绘制第二条折线
plt.plot(x,y_graduate,
         label=&quot;研究生毕业生数&quot;,       # 图例显示内容
         color=&quot;orange&quot;,             # 线条颜色
         linewidth=3,                # 线宽
         linestyle=&quot;--&quot;)             # 线条样式

# 设置x轴刻度，rotation为旋转度数
plt.xticks(x[::2],rotation=45)

# 设置图例，prop为设置字体，fontsize为设置字体大小
plt.legend(prop=my_font,fontsize=12)

# 绘制网格，alpha为透明度
plt.grid(alpha=0.5)

# 添加描述信息，fontproperties为设置字体，fontsize为设置字体大小
plt.xlabel(&quot;年份&quot;,fontproperties=my_font,fontsize=12)
plt.ylabel(&quot;人数（万人）&quot;,fontproperties=my_font,fontsize=12)
plt.title(&quot;1978年至2017年研究生招生数和研究生毕业生数情况&quot;,fontproperties=my_font,fontsize=18)

# 显示图形
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;绘制图形结果&quot;&gt;&lt;span&gt;1.4 绘制图形结果&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;运行上述代码，结果如下。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/12/12/5c10ff35e3908.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;条形图&quot;&gt;2.条形图&lt;/h4&gt;
&lt;h5 id=&quot;什么是条形图&quot;&gt;&lt;span&gt;2.1 什么是条形图&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;以下引用自百度百科&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;条形图（bar chart）是用宽度相同的条形的高度或长短来表示数据多少的图形。条形图可以横置或纵置，纵置时也称为柱形图（column chart）。此外，条形图有简单条形图、复式条形 图等形式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，&lt;span&gt;&lt;strong&gt;条形图可以直观地反映数据的大小。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h5 id=&quot;准备数据-1&quot;&gt;&lt;span&gt;2.2 准备数据&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;数据同样来自&lt;a href=&quot;http://data.stats.gov.cn/easyquery.htm?cn=C01&quot;&gt;国家数据&lt;/a&gt;，选取了2009年、2010年和2011年各级各类学校数，具体数据如下。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;普通高等学校数(所)&lt;/td&gt;
&lt;td&gt;2305&lt;/td&gt;
&lt;td&gt;2358&lt;/td&gt;
&lt;td&gt;2409&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;普通中学学校数(所)&lt;/td&gt;
&lt;td&gt;70774&lt;/td&gt;
&lt;td&gt;68881&lt;/td&gt;
&lt;td&gt;67751&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;高中学校数(所)&lt;/td&gt;
&lt;td&gt;14607&lt;/td&gt;
&lt;td&gt;14058&lt;/td&gt;
&lt;td&gt;13688&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;初中学校数(所)&lt;/td&gt;
&lt;td&gt;56167&lt;/td&gt;
&lt;td&gt;54823&lt;/td&gt;
&lt;td&gt;54063&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;职业中学学校数(所)&lt;/td&gt;
&lt;td&gt;5805&lt;/td&gt;
&lt;td&gt;5273&lt;/td&gt;
&lt;td&gt;4856&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;普通小学学校数(所)&lt;/td&gt;
&lt;td&gt;280184&lt;/td&gt;
&lt;td&gt;257410&lt;/td&gt;
&lt;td&gt;241249&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;特殊教育学校学校数(所)&lt;/td&gt;
&lt;td&gt;1672&lt;/td&gt;
&lt;td&gt;1706&lt;/td&gt;
&lt;td&gt;1767&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;学前教育学校数(所)&lt;/td&gt;
&lt;td&gt;138209&lt;/td&gt;
&lt;td&gt;150420&lt;/td&gt;
&lt;td&gt;166750&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;绘制完善图形-1&quot;&gt;&lt;span&gt;2.3 绘制完善图形&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;x = [&quot;普通高等学校数&quot;, &quot;普通中学学校数&quot;,&quot;高中学校数&quot;,
        &quot;初中学校数&quot;,&quot;职业中学学校数&quot;,&quot;普通小学学校数&quot;,
        &quot;特殊教育学校数&quot;,&quot;学前教育学校数&quot;]
y_09 = [2305,70774,14607,56167,5805,280184,1672,138209]
y_10 = [2358,68881,14058,54823,5273,257410,1706,150420]
y_11 = [2409,67751,13688,54063,4856,241249,1767,166750]

plt.figure(figsize=(10,6.18),dpi=100)
bar_width = 0.25

x_09 = list(range(len(x)))
x_10 = list(i + bar_width for i in range(len(x)))
x_11 = list(i + bar_width * 2 for i in range(len(x)))

plt.barh(x_09,y_09,height=bar_width,label=&quot;2009年&quot;)
plt.barh(x_10,y_10,height=bar_width,label=&quot;2010年&quot;)
plt.barh(x_11,y_11,height=bar_width,label=&quot;2011年&quot;)

plt.legend(prop=my_font, fontsize=12)
plt.grid(alpha=0.5,linestyle=&quot;--&quot;)
plt.yticks(x_10,x,fontproperties=my_font)
plt.xlabel(&quot;数量（所）&quot;,fontproperties=my_font,fontsize=12)
plt.title(&quot;2009年、2010年及2011年各级各类学校数情况&quot;,fontproperties=my_font,fontsize=18)

plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;绘制图形结果-1&quot;&gt;&lt;span&gt;2.4 绘制图形结果&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;运行上述代码，结果如下。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/12/12/5c110a5ed9a89.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;直方图&quot;&gt;3.直方图&lt;/h4&gt;
&lt;h5 id=&quot;什么是直方图&quot;&gt;&lt;span&gt;3.1 什么是直方图&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;以下引用自百度百科&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;直方图(Histogram)又称质量分布图。是一种统计报告图，由一系列高度不等的纵向条纹或线段表示数据分布的情况。 一般用横轴表示数据类型，纵轴表示分布情况。&lt;br/&gt;为了构建直方图，第一步是将值的范围分段，即将整个值的范围分成一系列间隔，然后计算每个间隔中有多少值。 这些值通常被指定为连续的，不重叠的变量间隔。 间隔必须相邻，并且通常是（但不是必须的）相等的大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;准备数据-2&quot;&gt;&lt;span&gt;3.2 准备数据&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;数据选用上一篇随笔：&lt;a href=&quot;https://www.cnblogs.com/dblsha/p/10095850.html&quot;&gt;爬取豆瓣电影信息&lt;/a&gt;中爬取到的电影的时长。去除无效数据后，从下图可以看出总共有2247条数据，最大值为170，最小值为3。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/12/13/5c113cdb63329.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;绘制完善图形-2&quot;&gt;&lt;span&gt;3.3 绘制完善图形&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;plt.figure(figsize=(10,6.18),dpi=100)

plt.hist(df[&quot;running_time&quot;],range(0,171,10),color=&quot;#009900&quot;)

plt.xticks(range(0,171,10))
plt.yticks(range(0,650,50))

plt.grid(alpha=0.5,linestyle=&quot;--&quot;)

plt.xlabel(&quot;时长（分钟）&quot;,fontproperties=my_font,fontsize=12)
plt.ylabel(&quot;数量&quot;, fontproperties=my_font,fontsize=12)
plt.title(&quot;电影片长分布情况&quot;, fontproperties=my_font,fontsize=18)

plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;绘制图形结果-2&quot;&gt;&lt;span&gt;3.4 绘制图形结果&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;运行上述代码，结果如下。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/12/13/5c1144670b6c1.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四结语&quot;&gt;四、结语&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文简单举例介绍了matplotlib绘制折线图、条形图和直方图的方法，matplotlib很强大，可以绘制非常多的图形，可以&lt;strong&gt;参考&lt;a href=&quot;https://matplotlib.org/gallery/index.html&quot; class=&quot;uri&quot;&gt;https://matplotlib.org/gallery/index.html&lt;/a&gt;。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果文中有错误的地方，希望大家指出，我会积极地学习改正。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最后，感谢大家的阅读！&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;开心一点，人间不值得&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2018/12/13/5c11408b1cd4d.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Dec 2018 17:10:00 +0000</pubDate>
<dc:creator>傻傻de</dc:creator>
<og:description>一、简介 以下引用自百度百科 Matplotlib 是一个 Python 的 2D绘图库，它以各种硬拷贝格式和跨平台的交互式环境生成出版质量级别的图形 。 通过 Matplotlib，开发者可以仅需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dblsha/p/10111889.html</dc:identifier>
</item>
<item>
<title>[Python] 用python做一个游戏辅助脚本，完整思路 - 蜗牛噢</title>
<link>http://www.cnblogs.com/reader/p/10111777.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reader/p/10111777.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;一、说明&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　简述：本文将以4399小游戏《&lt;span&gt;宠物连连看经典版2&lt;/span&gt;》作为测试案例，通过识别小图标，模拟鼠标点击，快速完成配对。对于有兴趣学习游戏脚本的同学有一定的帮助。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　运行环境：Win10/Python3.5。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　主要模块：win32gui（识别窗口、窗口置顶等操作）、PIL（屏幕截图）、numpy（创建矩阵）、operator（比较值）、pymouse（模拟鼠标点击）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　注意点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　1、如果安装pymouse不成功或者运行报错，可以考虑先通过whl 安装pyHook、然后再通过pip安装pyuserinput。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　2、如果报错 [ImportError: No module named 'windows' ]，可以修改__init__.py相应的行 为 windows =&amp;gt; pymouse.windows。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　本文主要参考：https://baijiahao.baidu.com/s?id=1618385402903335091&amp;amp;wfr=spider&amp;amp;for=pc。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;二、开发前景（随便唠叨一哈，可跳过）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　游戏辅助脚本在当前环境也算是比较流行了，对于经常玩游戏人来说，适当的游戏辅助还是很有帮助的，让计算机做一些繁琐乏味的操作。当然还有更加高大上的其他操作，这里就不赘述了。对于游戏辅助脚本，能想到基本有以下两种：一是读取游戏在内存中的数据，理想的话可以做到更改游戏一些基本属性，原理和很多的外挂或破解游戏类似；二是模拟用户用户行为，模拟鼠标点击、键盘操作等。当然，由于本人从未涉及游戏辅助脚本这一领域，出于个人兴趣，学习研究一下，本文例子则是第二种，主要还是模拟用户行为，让程序代替用户操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;三、开发流程&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　先看看程序运行图吧：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://hiphotos.baidu.com/feed/pic/item/03087bf40ad162d9884fc9561cdfa9ec8b13cdd3.jpg&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;277&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　浏览器打开游戏窗口（单个一个窗口），游戏界面如下图所示，游戏主要界面截图需要两个坐标（左上角坐标和右下角坐标）来确定，原点一般是屏幕左上角，不确定坐标点值的同学，可以全屏截图，用编辑图片软件查看坐标值。获取窗口句柄，这里就是浏览器标题栏的标题了（右键-查看源代码-title，加上软件名）比如：“宠物连连看经典2,宠物连连看经典版2小游戏,4399小游戏 www.4399.com - Google Chrome“。获取窗口句柄就可以开始了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　总体开发思路：截取游戏主图 ---&amp;gt; 分割成小图 ---&amp;gt; 对比每个小图，对比图片相识度，编号存入矩阵 ---&amp;gt; 对矩阵进行可连计算 ---&amp;gt; 模拟点击。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/709419/201812/709419-20181212222710255-1969516894.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;　　3.1、获取窗口句柄，把窗口置顶&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　python可以使用win32gui模块调用Windows API实现对窗口的操作，使用FindWindow()方法可以获取窗口的句柄（handle），需要传入两个参数，第一个为父窗口句柄（这里填0即可），第二个参数是窗口的名称（标签title - Google Chrome）。获取句柄之后然后通过SetForegroundWindows() 设置窗口在前面，这里传入游戏窗口的举报即可，代码如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; win32gui
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameAssist:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, wdname):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取得窗口句柄&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         self.hwnd =&lt;span&gt; win32gui.FindWindow(0, wdname)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.hwnd:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;窗口找不到，请确认窗口句柄名称：【%s】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; wdname )
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            exit()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 窗口显示最前面&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        win32gui.SetForegroundWindow(self.hwnd)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; wdname 为连连看窗口的名称，必须写完整&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     wdname = u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;宠物连连看经典版2,宠物连连看经典版2小游戏,4399小游戏 www.4399.com - Google Chrome&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     demo =&lt;span&gt; GameAssist(wdname)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     demo.start()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　3.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;2、截取游戏界面，分割图标，图片比较&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　这里需要花费一些时间来校验程序，如果截取的图片不好，则会影响后续操作，所以比较主要的是确认游戏左上角和右下角这两个坐标值，以及每个小图标的宽高。如下图所示，先截取整个游戏界面图，然后分割小图标，接着对每个图标进行比较，然后以编号代替图标存入矩阵（这里的编号矩阵和游戏图不一致，原理一样）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/709419/201812/709419-20181212225919343-591183088.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　根据初始化设定的左上角和右下角两个坐标，使用ImageGrab.grab()方法进行截图，传入一个元组即可，然后对这个大图进行分割，切割成一个个小图标存入到images_list数组中。　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; screenshot(self):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;屏幕截图&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、用grab函数截图，参数为左上角和右下角左标&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; image = ImageGrab.grab((417, 257, 885, 569))&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         image =&lt;span&gt; ImageGrab.grab(self.scree_left_and_right_point)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、分切小图&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; exit()&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         image_list =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         offset = self.im_width  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 8行12列&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(8&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             image_list[x] =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt; range(12&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;show&quot;,x, y)&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; exit()&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 top = x *&lt;span&gt; offset
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 left = y *&lt;span&gt; offset
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 right = (y + 1) *&lt;span&gt; offset
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 bottom = (x + 1) *&lt;span&gt; offset
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用crop函数切割成小图标，参数为图标的左上角和右下角左边&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 im =&lt;span&gt; image.crop((left, top, right, bottom))
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将切割好的图标存入对应的位置&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                 image_list[x][y] =&lt;span&gt; im
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; image_list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　通过上面代码切割的小图标，转成数字矩阵，如果图标已经存入image_type_list则返回这个索引，如果不存在，则在追加进去，然后当前长度就是这个新加入图标的编号，代码如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; image2num(self, image_list):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将图标矩阵转换成数字矩阵&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、创建全零矩阵和空的一维数组&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         arr = np.zeros((10, 14), dtype=np.int32)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以数字代替图片&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         image_type_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、识别出不同的图片，将图片矩阵转换成数字矩阵&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(image_list)):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(image_list[0])):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 im =&lt;span&gt; image_list[i][j]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 
&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 验证当前图标是否已存入&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 index =&lt;span&gt; self.getIndex(im, image_type_list)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不存在image_type_list&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; index &amp;lt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    image_type_list.append(im)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     arr[i + 1][j + 1] =&lt;span&gt; len(image_type_list)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     arr[i + 1][j + 1] = index + 1
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图标数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, len(image_type_list))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         self.im2num_arr =&lt;span&gt; arr
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; arr&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　上面的getIndex就是对比图片，判断图标是否出现过（是否已存在image_type_list中，没出现则追加进去），这里使用汉明距离判断两个图片的相识度，设置阀值10，当小于阀值则认为是同一个图片，具体代码如下：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查数组中是否有图标,如果有则返回索引下表&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getIndex(self,im, im_list):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(im_list)):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.isMatch(im, im_list[i]):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -1
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 汉明距离判断两个图标是否一样&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isMatch(self, im1, im2):
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 缩小图标，转成灰度&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         image1 = im1.resize((20, 20), Image.ANTIALIAS).convert(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         image2 = im2.resize((20, 20), Image.ANTIALIAS).convert(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将灰度图标转成01串,即系二进制数据&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         pixels1 =&lt;span&gt; list(image1.getdata())
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         pixels2 =&lt;span&gt; list(image2.getdata())
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         avg1 = sum(pixels1) /&lt;span&gt; len(pixels1)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         avg2 = sum(pixels2) /&lt;span&gt; len(pixels2)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         hash1 = &lt;span&gt;&quot;&quot;&lt;/span&gt;.join(map(&lt;span&gt;lambda&lt;/span&gt; p: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; p &amp;gt; avg1 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pixels1))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         hash2 = &lt;span&gt;&quot;&quot;&lt;/span&gt;.join(map(&lt;span&gt;lambda&lt;/span&gt; p: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; p &amp;gt; avg2 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pixels2))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 统计两个01串不同数字的个数&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         match =&lt;span&gt; sum(map(operator.ne, hash1, hash2))
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 阀值设为10&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; match &amp;lt; 10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;四、程序核心-图标连接算法（路径寻找）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这里仅对算法代码进行简单分析，如果对程序不好理解，可以留言，后续可以图文分析。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　通过上面的开发流程，基本获取如下这样的矩阵，只要比较两个编号相同的值进行可连路径寻找，如果找到即进行模拟点击操作。这里简单介绍下游戏规则：8行乘12列游戏图标区域，外围的0其实表示寻找路径的时候可以通过，例如坐标（1, 1）可以与（1,10）进行连接、（7, 1）和（7,2）进行连接。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;174&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; arr =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0],
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     [ 0,  1,  2,  3,  4,  5,  4,  6,  7,  2,  1,  1,  8&lt;span&gt;,  0],
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     [ 0,  9,  3,  3, 10,  4,  7, 11,  7,  2,  3,  1,  6&lt;span&gt;,  0],
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     [ 0,  6,  7,  4, 11,  5,  8,  1,  6,  5,  4,  2,  8&lt;span&gt;,  0],
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     [ 0,  6,  2,  9,  6,  8,  9,  7, 12, 11,  3, 11, 11&lt;span&gt;,  0],
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     [ 0,  5,  9,  8,  9,  2,  6, 11, 11,  3,  9,  2, 12&lt;span&gt;,  0],
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     [ 0, 12,  5, 12,  5, 10,  5,  6,  5,  7, 12,  4,  3&lt;span&gt;,  0],
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     [ 0,  1,  8, 10, 12,  9, 10,  4,  3,  7,  2,  1, 10&lt;span&gt;,  0],
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     [ 0,  1,  4, 10,  8, 12, 10, 10,  9, 12,  8,  7, 11&lt;span&gt;,  0],
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    [ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　算法的思路：路径的寻找首先是寻找一个坐标的横向竖向可以直接相连的坐标集合，比如坐标p1（1,1）这样的集合有[ （0,1）, （1,0） ]，另外一个坐标p2（1,10）的可连集合为[ （0,10） ]，然后再对p1和p2的可连坐标集合进行比较，如果集合中坐标也有可连，则表示p1和p2可连，很明显，（0,1）和（0,10）为同一行且可连，这样就表示p1和p2两点存在可连路径了，代码如下所示：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　简单分析下代码实现过程：在isReachable()传入两个需要比较的坐标值，然后分别获取两个点横竖向（isRowConnect()、isColConnect()）可以连接的坐标集合，最后再对集合进行遍历比较是否存在可连的，如果存在则表示传入的两个坐标是可以连接的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否为同行或同列且可连&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isReachable(self, x1, y1, x2, y2):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、先判断值是否相同&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.im2num_arr[x1][y1] !=&lt;span&gt; self.im2num_arr[x2][y2]:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、分别获取两个坐标同行或同列可连的坐标数组&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         list1 =&lt;span&gt; self.getDirectConnectList(x1, y1)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         list2 =&lt;span&gt; self.getDirectConnectList(x2, y2)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(x1, y1, list1)&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(x2, y2, list2)&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; exit()&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、比较坐标数组中是否可连&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; x1, y1 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list1:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; x2, y2 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list2:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.isDirectConnect(x1, y1, x2, y2):
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取同行或同列可连的坐标数组&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getDirectConnectList(self, x, y):
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         plist =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; px &lt;span&gt;in&lt;/span&gt; range(0, 10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; py &lt;span&gt;in&lt;/span&gt; range(0, 14&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取同行或同列且为0的坐标&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; self.im2num_arr[px][py] == 0 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; self.isDirectConnect(x, y, px, py):
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    plist.append([px, py])
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; plist
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否为同行或同列且可连&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isDirectConnect(self, x1, y1, x2, y2):
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、位置完全相同&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; x1 == x2 &lt;span&gt;and&lt;/span&gt; y1 ==&lt;span&gt; y2:
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、行列都不同的&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; x1 != x2 &lt;span&gt;and&lt;/span&gt; y1 !=&lt;span&gt; y2:
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3、同行&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; x1 == x2 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; self.isRowConnect(x1, y1, y2):
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4、同列&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; y1 == y2 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; self.isColConnect(y1, x1, x2):
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; 
&lt;span&gt;52&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断同行是否可连&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isRowConnect(self, x, y1, y2):
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         minY =&lt;span&gt; min(y1, y2)
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         maxY =&lt;span&gt; max(y1, y2)
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相邻直接可连&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; maxY - minY == 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断两个坐标之间是否全为0&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; y0 &lt;span&gt;in&lt;/span&gt; range(minY + 1&lt;span&gt;, maxY):
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; self.im2num_arr[x][y0] !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; 
&lt;span&gt;69&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断同列是否可连&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isColConnect(self, y, x1, x2):
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;         minX =&lt;span&gt; min(x1, x2)
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;         maxX =&lt;span&gt; max(x1, x2)
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; 
&lt;span&gt;74&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相邻直接可连&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; maxX - minX == 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断两个坐标之间是否全为0&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; x0 &lt;span&gt;in&lt;/span&gt; range(minX + 1&lt;span&gt;, maxX):
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; self.im2num_arr[x0][y] !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;五、开发总结&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　学习这样一个游戏辅助脚本，对于个人培养编程兴趣也是有很多帮助的，在工作之余不失为一个好的消遣方式，以后会多向这些方向研究学习。本案例仅仅是截图、比较图片和模拟鼠标点击，我觉得还可以更加强大，而且还不局限于游戏这样一个领域，相信大家应该见过自动发QQ消息的软件吧，我觉得这完全可以做。还有很多模拟操作可以实现：鼠标滚轮，左右键、键盘输入等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;六、附件-源码&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;注意：源码仅供学习，转发注明出处，谢谢！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;87.5&quot;&gt;&lt;img id=&quot;code_img_closed_3e856140-885d-42b4-8e9a-b0bebb0a0f35&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3e856140-885d-42b4-8e9a-b0bebb0a0f35&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3e856140-885d-42b4-8e9a-b0bebb0a0f35&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;170&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; win32gui
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; PIL &lt;span&gt;import&lt;/span&gt;&lt;span&gt; ImageGrab, Image
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; operator
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; pymouse &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PyMouse
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GameAssist:
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, wdname):
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 取得窗口句柄&lt;/span&gt;
&lt;span&gt; 17&lt;/span&gt;         self.hwnd =&lt;span&gt; win32gui.FindWindow(0, wdname)
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.hwnd:
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;窗口找不到，请确认窗口句柄名称：【%s】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; wdname )
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;            exit()
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 窗口显示最前面&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;        win32gui.SetForegroundWindow(self.hwnd)
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 小图标编号矩阵&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;         self.im2num_arr =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 主截图的左上角坐标和右下角坐标&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;         self.scree_left_and_right_point = (299, 251, 768, 564&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 小图标宽高&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;         self.im_width = 39
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; PyMouse对象，鼠标点击&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;         self.mouse =&lt;span&gt; PyMouse()
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; screenshot(self):
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;屏幕截图&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、用grab函数截图，参数为左上角和右下角左标&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; image = ImageGrab.grab((417, 257, 885, 569))&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;         image =&lt;span&gt; ImageGrab.grab(self.scree_left_and_right_point)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; 
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、分切小图&lt;/span&gt;
&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; exit()&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;         image_list =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;         offset = self.im_width  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt; 
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 8行12列&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; x &lt;span&gt;in&lt;/span&gt; range(8&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             image_list[x] =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; y &lt;span&gt;in&lt;/span&gt; range(12&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;show&quot;,x, y)&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; exit()&lt;/span&gt;
&lt;span&gt; 54&lt;/span&gt;                 top = x *&lt;span&gt; offset
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                 left = y *&lt;span&gt; offset
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                 right = (y + 1) *&lt;span&gt; offset
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                 bottom = (x + 1) *&lt;span&gt; offset
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用crop函数切割成小图标，参数为图标的左上角和右下角左边&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;                 im =&lt;span&gt; image.crop((left, top, right, bottom))
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将切割好的图标存入对应的位置&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;                 image_list[x][y] =&lt;span&gt; im
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; 
&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; image_list
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; image2num(self, image_list):
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;将图标矩阵转换成数字矩阵&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、创建全零矩阵和空的一维数组&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;         arr = np.zeros((10, 14), dtype=np.int32)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 以数字代替图片&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;         image_type_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、识别出不同的图片，将图片矩阵转换成数字矩阵&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(image_list)):
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(image_list[0])):
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 im =&lt;span&gt; image_list[i][j]
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; 
&lt;span&gt; 78&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 验证当前图标是否已存入&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;                 index =&lt;span&gt; self.getIndex(im, image_type_list)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不存在image_type_list&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; index &amp;lt;&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;                    image_type_list.append(im)
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                     arr[i + 1][j + 1] =&lt;span&gt; len(image_type_list)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                     arr[i + 1][j + 1] = index + 1
&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图标数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, len(image_type_list))
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;         self.im2num_arr =&lt;span&gt; arr
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查数组中是否有图标,如果有则返回索引下表&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getIndex(self,im, im_list):
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(im_list)):
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.isMatch(im, im_list[i]):
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; i
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; 
&lt;span&gt; 99&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -1
&lt;span&gt;100&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 汉明距离判断两个图标是否一样&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isMatch(self, im1, im2):
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 缩小图标，转成灰度&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;         image1 = im1.resize((20, 20), Image.ANTIALIAS).convert(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;         image2 = im2.resize((20, 20), Image.ANTIALIAS).convert(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; 
&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将灰度图标转成01串,即系二进制数据&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;         pixels1 =&lt;span&gt; list(image1.getdata())
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;         pixels2 =&lt;span&gt; list(image2.getdata())
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt;         avg1 = sum(pixels1) /&lt;span&gt; len(pixels1)
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;         avg2 = sum(pixels2) /&lt;span&gt; len(pixels2)
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;         hash1 = &lt;span&gt;&quot;&quot;&lt;/span&gt;.join(map(&lt;span&gt;lambda&lt;/span&gt; p: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; p &amp;gt; avg1 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pixels1))
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;         hash2 = &lt;span&gt;&quot;&quot;&lt;/span&gt;.join(map(&lt;span&gt;lambda&lt;/span&gt; p: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; p &amp;gt; avg2 &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, pixels2))
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 统计两个01串不同数字的个数&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;         match =&lt;span&gt; sum(map(operator.ne, hash1, hash2))
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 阀值设为10&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; match &amp;lt; 10
&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断矩阵是否全为0&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isAllZero(self, arr):
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 9&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(1, 13&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; arr[i][j] !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否为同行或同列且可连&lt;/span&gt;
&lt;span&gt;132&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isReachable(self, x1, y1, x2, y2):
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、先判断值是否相同&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; self.im2num_arr[x1][y1] !=&lt;span&gt; self.im2num_arr[x2][y2]:
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、分别获取两个坐标同行或同列可连的坐标数组&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt;         list1 =&lt;span&gt; self.getDirectConnectList(x1, y1)
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;         list2 =&lt;span&gt; self.getDirectConnectList(x2, y2)
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(x1, y1, list1)&lt;/span&gt;
&lt;span&gt;141&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(x2, y2, list2)&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt; 
&lt;span&gt;143&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; exit()&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、比较坐标数组中是否可连&lt;/span&gt;
&lt;span&gt;146&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; x1, y1 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list1:
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; x2, y2 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list2:
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.isDirectConnect(x1, y1, x2, y2):
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt; 
&lt;span&gt;152&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取同行或同列可连的坐标数组&lt;/span&gt;
&lt;span&gt;153&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getDirectConnectList(self, x, y):
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt; 
&lt;span&gt;155&lt;/span&gt;         plist =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; px &lt;span&gt;in&lt;/span&gt; range(0, 10&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; py &lt;span&gt;in&lt;/span&gt; range(0, 14&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取同行或同列且为0的坐标&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; self.im2num_arr[px][py] == 0 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; self.isDirectConnect(x, y, px, py):
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;                    plist.append([px, py])
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; plist
&lt;/span&gt;&lt;span&gt;163&lt;/span&gt; 
&lt;span&gt;164&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否为同行或同列且可连&lt;/span&gt;
&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isDirectConnect(self, x1, y1, x2, y2):
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、位置完全相同&lt;/span&gt;
&lt;span&gt;167&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; x1 == x2 &lt;span&gt;and&lt;/span&gt; y1 ==&lt;span&gt; y2:
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; 
&lt;span&gt;170&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、行列都不同的&lt;/span&gt;
&lt;span&gt;171&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; x1 != x2 &lt;span&gt;and&lt;/span&gt; y1 !=&lt;span&gt; y2:
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt; 
&lt;span&gt;174&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3、同行&lt;/span&gt;
&lt;span&gt;175&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; x1 == x2 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; self.isRowConnect(x1, y1, y2):
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; 
&lt;span&gt;178&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4、同列&lt;/span&gt;
&lt;span&gt;179&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; y1 == y2 &lt;span&gt;and&lt;/span&gt;&lt;span&gt; self.isColConnect(y1, x1, x2):
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; 
&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; 
&lt;span&gt;184&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断同行是否可连&lt;/span&gt;
&lt;span&gt;185&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isRowConnect(self, x, y1, y2):
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;         minY =&lt;span&gt; min(y1, y2)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;         maxY =&lt;span&gt; max(y1, y2)
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt; 
&lt;span&gt;189&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相邻直接可连&lt;/span&gt;
&lt;span&gt;190&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; maxY - minY == 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; 
&lt;span&gt;193&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断两个坐标之间是否全为0&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; y0 &lt;span&gt;in&lt;/span&gt; range(minY + 1&lt;span&gt;, maxY):
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; self.im2num_arr[x][y0] !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; 
&lt;span&gt;199&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断同列是否可连&lt;/span&gt;
&lt;span&gt;200&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; isColConnect(self, y, x1, x2):
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;         minX =&lt;span&gt; min(x1, x2)
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;         maxX =&lt;span&gt; max(x1, x2)
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt; 
&lt;span&gt;204&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 相邻直接可连&lt;/span&gt;
&lt;span&gt;205&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; maxX - minX == 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; 
&lt;span&gt;208&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断两个坐标之间是否全为0&lt;/span&gt;
&lt;span&gt;209&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; x0 &lt;span&gt;in&lt;/span&gt; range(minX + 1&lt;span&gt;, maxX):
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; self.im2num_arr[x0][y] !=&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; False
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;213&lt;/span&gt; 
&lt;span&gt;214&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 点击事件并设置数组为0&lt;/span&gt;
&lt;span&gt;215&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; clickAndSetZero(self, x1, y1, x2, y2):
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;click&quot;, x1, y1, x2, y2)&lt;/span&gt;
&lt;span&gt;217&lt;/span&gt; 
&lt;span&gt;218&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; (299, 251, 768, 564)&lt;/span&gt;
&lt;span&gt;219&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 原理：左上角图标中点 + 偏移量&lt;/span&gt;
&lt;span&gt;220&lt;/span&gt;         p1_x = int(self.scree_left_and_right_point[0] + (y1 - 1)*self.im_width + (self.im_width / 2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt;         p1_y = int(self.scree_left_and_right_point[1] + (x1 - 1)*self.im_width + (self.im_width / 2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; 
&lt;span&gt;223&lt;/span&gt;         p2_x = int(self.scree_left_and_right_point[0] + (y2 - 1)*self.im_width + (self.im_width / 2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;         p2_y = int(self.scree_left_and_right_point[1] + (x2 - 1)*self.im_width + (self.im_width / 2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; 
&lt;span&gt;226&lt;/span&gt;         time.sleep(0.2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;227&lt;/span&gt; &lt;span&gt;        self.mouse.click(p1_x, p1_y)
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;         time.sleep(0.2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;        self.mouse.click(p2_x, p2_y)
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; 
&lt;span&gt;231&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置矩阵值为0&lt;/span&gt;
&lt;span&gt;232&lt;/span&gt;         self.im2num_arr[x1][y1] =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;         self.im2num_arr[x2][y2] =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; 
&lt;span&gt;235&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消除：(%d, %d) (%d, %d)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (x1, y1, x2, y2))
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; exit()&lt;/span&gt;
&lt;span&gt;237&lt;/span&gt; 
&lt;span&gt;238&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 程序入口、控制中心&lt;/span&gt;
&lt;span&gt;239&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; start(self):
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; 
&lt;span&gt;241&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1、先截取游戏区域大图，然后分切每个小图&lt;/span&gt;
&lt;span&gt;242&lt;/span&gt;         image_list =&lt;span&gt; self.screenshot()
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; 
&lt;span&gt;244&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2、识别小图标，收集编号&lt;/span&gt;
&lt;span&gt;245&lt;/span&gt; &lt;span&gt;        self.image2num(image_list)
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt; 
&lt;span&gt;247&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.im2num_arr)
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt; 
&lt;span&gt;249&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3、遍历查找可以相连的坐标&lt;/span&gt;
&lt;span&gt;250&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; self.isAllZero(self.im2num_arr):
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; x1 &lt;span&gt;in&lt;/span&gt; range(1, 9&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; y1 &lt;span&gt;in&lt;/span&gt; range(1, 13&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; self.im2num_arr[x1][y1] ==&lt;span&gt; 0:
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;                         &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;255&lt;/span&gt; 
&lt;span&gt;256&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; x2 &lt;span&gt;in&lt;/span&gt; range(1, 9&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; y2 &lt;span&gt;in&lt;/span&gt; range(1, 13&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 跳过为0 或者同一个&lt;/span&gt;
&lt;span&gt;259&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; self.im2num_arr[x2][y2] == 0 &lt;span&gt;or&lt;/span&gt; (x1 == x2 &lt;span&gt;and&lt;/span&gt; y1 ==&lt;span&gt; y2):
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt;                                 &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;261&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; self.isReachable(x1, y1, x2, y2):
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt; &lt;span&gt;                                self.clickAndSetZero(x1, y1, x2, y2)
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt; 
&lt;span&gt;264&lt;/span&gt; 
&lt;span&gt;265&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; wdname 为连连看窗口的名称，必须写完整&lt;/span&gt;
&lt;span&gt;267&lt;/span&gt;     wdname = u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;宠物连连看经典版2,宠物连连看经典版2小游戏,4399小游戏 www.4399.com - Google Chrome&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;268&lt;/span&gt; 
&lt;span&gt;269&lt;/span&gt;     demo =&lt;span&gt; GameAssist(wdname)
&lt;/span&gt;&lt;span&gt;270&lt;/span&gt;     demo.start()
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;GameAssist.py&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 12 Dec 2018 16:00:00 +0000</pubDate>
<dc:creator>蜗牛噢</dc:creator>
<og:description>一、说明 简述：本文将以4399小游戏《宠物连连看经典版2》作为测试案例，通过识别小图标，模拟鼠标点击，快速完成配对。对于有兴趣学习游戏脚本的同学有一定的帮助。 运行环境：Win10/Python3.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/reader/p/10111777.html</dc:identifier>
</item>
<item>
<title>评估机器学习模型的几种方法（验证集的重要性） - 左手十字</title>
<link>http://www.cnblogs.com/zuoshoushizi/p/10111722.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuoshoushizi/p/10111722.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;什么是评估机器学习模型    &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　机器学习的目的是得到可以泛化（generalize）的模型，即在前所未见的数据上表现很好的模型，而过拟合则是核心难点。你只能控制可以观察的事情，所以能够可靠地衡量模型的泛化能力非常重要。　　&lt;/p&gt;
&lt;p&gt;如何衡量泛化能力，即如何评估机器学习模型。&lt;/p&gt;
&lt;p&gt;评估模型的重点是将数据划分为三个集合：训练集、验证集和测试集。在训练数据上训练模型，在验证数据上评估模型。一旦找到了最佳参数，就在测试数据上最后测试一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么需要验证集&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　　原因在于开发模型时总是需要调节模型配置，比如选择层数或每层大小［这叫作模型的超参数（hyperparameter），以便与模型参数（即权重）区分开］。这个调节过程需要使用模型在验证数据上的性能作为反馈信号。这个调节过程本质上就是一种学习：在某个参数空间中寻找良好的模型配置。因此，如果基于模型在验证集上的性能来调节模型配置，会很快导致模型在验证集上过拟合，即使你并没有在验证集上直接训练模型也会如此。&lt;br/&gt;　　造成这一现象的关键在于信息泄露（information leak）。每次基于模型在验证集上的性能来调节模型超参数，都会有一些关于验证数据的信息泄露到模型中。如果对每个参数只调节一次，那么泄露的信息很少，验证集仍然可以可靠地评估模型。但如果你多次重复这一过程（运行一次实验，在验证集上评估，然后据此修改模型），那么将会有越来越多的关于验证集的信息泄露到模型中。&lt;br/&gt;　　最后，你得到的模型在验证集上的性能非常好（人为造成的），因为这正是你优化的目的。你关心的是模型在全新数据上的性能，而不是在验证数据上的性能，因此你需要使用一个完全不同的、前所未见的数据集来评估模型，它就是测试集。你的模型一定不能读取与测试集有关的任何信息，既使间接读取也不行。如果基于测试集性能来调节模型，那么对泛化能力的衡量是不准确的。&lt;br/&gt;将数据划分为训练集、验证集和测试集可能看起来很简单，但如果可用数据很少，还有几种高级方法可以派上用场。&lt;/p&gt;
&lt;p&gt;我们先来介绍三种经典的评估方法：简单的留出验证、K 折验证，以及带有打乱数据的重复 K 折验证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 简单的留出验证&lt;/strong&gt;&lt;br/&gt;留出一定比例的数据作为测试集。在剩余的数据上训练模型，然后在测试集上评估模型。&lt;br/&gt;如前所述，为了防止信息泄露，你不能基于测试集来调节模型，所以还应该保留一个验证集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1224905/201812/1224905-20181212230212931-1190393639.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;留出验证的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;、将原有数据集打乱顺序shuffle_data
&lt;/span&gt;2、将打乱的数据集的一部分（一般为10%-20%&lt;span&gt;）定义为验证集valify_data
&lt;/span&gt;3&lt;span&gt;、剩余的数据定义为训练数据train_data
&lt;/span&gt;4&lt;span&gt;、根据需求建模 model
&lt;/span&gt;5&lt;span&gt;、训练模型model.train(train_data)
&lt;/span&gt;6&lt;span&gt;、在验证集上评估模型model.evaluate(valify_data)
&lt;/span&gt;7&lt;span&gt;、调节模型
&lt;/span&gt;8、重复5、6&lt;span&gt;、7直到模型在验证集上表现良好
&lt;/span&gt;9、在测试集上测试模型
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是最简单的评估方法，但有一个缺点：如果可用的数据很少，那么可能验证集和测试集包含的样本就太少，从而无法在统计学上代表数据。这个问题很容易发现：如果在划分数据前进行不同的随机打乱，最终得到的模型性能差别很大，那么就存在这个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. K 折验证&lt;/strong&gt;&lt;br/&gt;　　K 折验证（K-fold validation）将数据划分为大小相同的 K 个分区。对于每个分区 i ，在剩余的 K-1 个分区上训练模型，然后在分区 i 上评估模型。最终分数等于 K 个分数的平均值。对于不同的训练集 - 测试集划分，如果模型性能的变化很大，那么这种方法很有用。与留出验证一样，这种方法也需要独立的验证集进行模型校正。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1224905/201812/1224905-20181212232128154-1976962001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;伪代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;将原来的数据平均k份
根据需求建模 model
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(k)
    将第 i 份数据作为验证集，其他k&lt;/span&gt;-&lt;span&gt;1份数据作为训练集
    在训练集上训练模型
    在验证集上【】评估模型
在测试集上测试模型&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;数据量小的时候，k 可以设大一点，这样训练集占整体比例就比较大，不过同时训练的模型个数也增多。 &lt;br/&gt;数据量大的时候，k 可以设小一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、带有打乱数据的重复 K 折验证&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　如果可用的数据相对较少，而你又需要尽可能精确地评估模型，那么可以选择带有打乱数据的重复 K 折验证（iterated K-fold validation with shuffling）。具体做法是多次使用 K 折验证，在每次将数据划分为 K 个分区之前都先将数据打乱。最终分数是多次 k 折交叉验证再求均值，例如：10 次 10 折交叉验证，以求更精确一点。注意，这种方法一共要训练和评估 P×K 个模型（P是重复次数），计算代价很大。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;　　除此之外还有一种比较特殊的交叉验证方法，有人将其叫做&lt;strong&gt;Bootstrapping&lt;/strong&gt;。通过又放回的抽样，抽取与train_data相同数量的数据作为新的训练集。即在含有 m 个样本的数据集中，每次随机挑选一个样本，再放回到数据集中，再随机挑选一个样本，这样有放回地进行抽样 m 次，组成了新的数据集作为训练集。&lt;/p&gt;
&lt;p&gt;优点是训练集的样本总数和原数据集一样都是 m，并且仍有约 1/3 的数据不被训练而可以作为测试集。 &lt;br/&gt;缺点是这样产生的训练集的数据分布和原数据集的不一样了，会引入估计偏差。 &lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 15:41:00 +0000</pubDate>
<dc:creator>左手十字</dc:creator>
<og:description>什么是评估机器学习模型 机器学习的目的是得到可以泛化（generalize）的模型，即在前所未见的数据上表现很好的模型，而过拟合则是核心难点。你只能控制可以观察的事情，所以能够可靠地衡量模型的泛化能力</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuoshoushizi/p/10111722.html</dc:identifier>
</item>
<item>
<title>大数据学习-1   在阿里云上集成6台云服务器 - 蒙山一只鸽</title>
<link>http://www.cnblogs.com/SAM-CJM/p/10111653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SAM-CJM/p/10111653.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.为什么要大数据学习？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是一个大数据的时代，一个企业只有掌握了大数据才能把握住市场的命脉，一个人掌握了大数据就可以比较轻松的向机器学习、人工智能等方向发展。所以我们有必要去掌握大数据的技术同时也关注大数据的发展趋势，不能裹足不前。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.关于本专题的学习&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 作为一个普通本科大学生，在校的大数据学习比较的“水”，普通大学嘛，大家都懂。在一个就是编程实战方向上的东西本来就该靠自学，而不是靠别人去教。我觉得大数据的学习是一个缓慢的过程，需要半年的时间去学习。我想在大二结束差不多就可以完成大数据最基本的学习了。（看看明年暑假能不能去个公司实习一下:-)）&lt;span&gt;&lt;strong&gt;因为这也是我也是第一次学习大数据，这一系列文章是我的学习笔记而不是我的工作经历总结，其中难免有部分错误，还望前辈们不啬赐教。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三.在阿里云上安装hadoop，同时集成6台云主机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.1&lt;/strong&gt;版本说明：1.Linux   centos7&lt;/p&gt;
&lt;p&gt;　　　　　       2.Java    jdk1.8&lt;/p&gt;
&lt;p&gt;　　　　           3.Hadoop  Hadoop2.7.3&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.2&lt;/strong&gt; 安装Java&lt;/p&gt;
&lt;p&gt;在这里我们使用的是Java 1.8，当然你也可以使用其他的版本，但是一定要是Linux版本的Java！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212202748264-791030159.png&quot; alt=&quot;&quot;/&gt;我们下载的压缩包格式，下载到本地后通过winscp上传到阿里云上&lt;/p&gt;
&lt;p&gt;下载链接 &lt;a target=&quot;_blank&quot;&gt;https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/a&gt; &lt;/p&gt;
&lt;p&gt; 我们在阿里云上的opt文件夹下创建Java文件夹和hadoop文件夹如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212203349413-190120302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们将我们的Java压缩包放到Java文件夹中去。&lt;/p&gt;
&lt;p&gt; 然后进入该文件夹执行解压操作&lt;/p&gt;
&lt;p&gt; 进入该文件夹      &lt;strong&gt;cd /opt/java&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 解压操作   &lt;strong&gt;tar -zxvf jdk-8u 191-linux-x64.tar.gz&lt;/strong&gt;  (注意你自己的jdk版本号和你自己的文件名)&lt;/p&gt;
&lt;p&gt; 解压完成后会看见一个文件夹如下&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212215945223-89239789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们呢就要去配置文件了&lt;/p&gt;
&lt;p&gt;修改/etc/profile文件   使用命令符  &lt;strong&gt;vim  /etc/profile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在文件的&lt;strong&gt;最后&lt;/strong&gt;加上&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;export JAVA_HOME=/opt/java/jdk1.8.0_191   （注意你自己的版本号）&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;export PATH=$JAVA_HOME/bin:$PATH&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;更改完后输入命令命令符 &lt;strong&gt;Java、&lt;/strong&gt; &lt;strong&gt;javac、java -version&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;出现下面的字符说明安装成功：&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212221056589-850841451.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;294&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212221118669-1757228788.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;297&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212221144285-951813783.png&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;81&quot;/&gt;&lt;p&gt;&lt;strong&gt;3.3&lt;/strong&gt;实现6个机子ssh免密码登录&lt;/p&gt;
&lt;p&gt;检查机器名称&lt;/p&gt;
输入命令符  &lt;strong&gt;hostname &lt;/strong&gt; 可以查看你们的机器名称，如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212221736274-662897986.png&quot; alt=&quot;&quot;/&gt;如果你没有改过你的hostname那么应该是一个乱码，那么我们使用命令来修改主机名称 &lt;strong&gt;hostname  hserver1&lt;/strong&gt;（1号一般为namenode）&lt;p&gt;其他的5台服务器也是分别为hserver2、hserver3、hserver4、hserver5、hserver6（这几个为datenode）&lt;/p&gt;
修改映射文件&lt;br/&gt;&lt;/div&gt;
&lt;p&gt; 输入命令符vim /etc/hosts 将所有的服务器的&lt;strong&gt;主机ip地址和他们的hostname相对应&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212222547996-282631914.png&quot; alt=&quot;&quot; width=&quot;579&quot; height=&quot;185&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改完成后我们检查一下是否能够发送成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ping -c  3 hserver2 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212222921733-1203222914.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就说明成功了，当然剩下的5台服务器也测试后成功了。&lt;/p&gt;
&lt;p&gt;配置ssh文件&lt;/p&gt;
&lt;p&gt;输入命令  &lt;strong&gt;ssh-keygen  -t  rsa -P ''&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在过程中需要输入回车&lt;/p&gt;
&lt;p&gt;然后&lt;strong&gt;ls  /root/.ssh/ &lt;/strong&gt; 出现下图&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212223502341-1819116277.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看id_rsa.pub   &lt;strong&gt;vim  id_rsa.pub&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212224403524-925069035.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们将所有主机中的id_rsa.pub 文件中的公匙复制到一个文件中&lt;span&gt;authorized_keys，然后将&lt;span&gt;authorized_keys&lt;/span&gt;放置到&lt;span&gt;/root/.ssh/&lt;/span&gt;文件夹下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;查看&lt;span&gt;&lt;span&gt;authorized_keys   &lt;strong&gt;vim  &lt;span&gt;&lt;span&gt;authorized_keys&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt; 如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212224311199-1898885327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 测试是否ssh配置成功&lt;/p&gt;
&lt;p&gt; 依次检查&lt;strong&gt;ssh hserver2&lt;/strong&gt; 、3、4、5、6&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212224611917-1424972583.png&quot; alt=&quot;&quot;/&gt;第一次输入一般会询问链接  输入yes&lt;/p&gt;
&lt;p&gt;测试完后一定要关闭链接否者你在本机上的命令会在那一台机子上执行，&lt;/p&gt;
&lt;p&gt;命令符 &lt;strong&gt;exit&lt;/strong&gt; 退出&lt;/p&gt;
&lt;p&gt; 3.4安装hadoop&lt;/p&gt;
&lt;p&gt;下载hadoop到本地然后上传到阿里云上，解压。资源网上都有可以去找 ，我这里使用的Hadoop版本为2.7.3下面解压后所有的路径你们根据你们的版本去修改。&lt;/p&gt;
&lt;p&gt;我们的将Hadoop的压缩包放到/opt/hadoop/文件夹下：&lt;/p&gt;
&lt;p&gt;然后我们进入该文件夹 &lt;strong&gt;cd  /opt/hadoop/&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接着执行   &lt;strong&gt;tar -xvf hadoop-2.7.3.tar.gz&lt;/strong&gt; （注意你们的文件版本名）解压文件&lt;/p&gt;
&lt;p&gt;解压完成后你会的得到一个文件夹&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212225517506-120794880.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后创建如下几个文件夹&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/tmp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/var&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/dfs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/dfs/name&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mkdir /root/hadoop/dfs/data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改配置文件：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; vim   /opt/hadoop/hadoop-&lt;span&gt;2.7.3&lt;/span&gt;/etc/hadoop/core-site.xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;span&gt;&amp;lt;configuration&amp;gt;节点中写入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;/root/hadoop/tmp&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;Abase for other temporary directories.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;fs.default.name&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;hdfs://&lt;strong&gt;&lt;span&gt;hserver1&lt;/span&gt;&lt;/strong&gt;:9000&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;注意如果你的namenode的hostname不为hserver1你要改成你的namenode的hostname&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;vim &lt;span&gt;/opt/hadoop/hadoop-&lt;span&gt;2.7.3&lt;/span&gt;/etc/hadoop/hadoop-env.sh&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 将export   JAVA_HOME=${JAVA_HOME}&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 修改为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; export   JAVA_HOME=/opt/java/jdk1.8.0_191   (注意你自己的Java版本号)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;vim /opt/hadoop/hadoop-&lt;span&gt;2.7.3&lt;/span&gt;/etc/hadoop/hdfs-site.xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;span&gt;&amp;lt;configuration&amp;gt;节点中写入：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;name&amp;gt;dfs.name.dir&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;value&amp;gt;/root/hadoop/dfs/name&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;description&amp;gt;Path on the local filesystem where theNameNode stores the namespace and transactions logs persistently.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;name&amp;gt;dfs.data.dir&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;value&amp;gt;/root/hadoop/dfs/data&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;description&amp;gt;Comma separated list of paths on the localfilesystem of a DataNode where it should store its blocks.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;value&amp;gt;2&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;      &amp;lt;name&amp;gt;dfs.permissions&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;      &amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;      &amp;lt;description&amp;gt;need not permissions&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在该版本中，有一个名为mapred-site.xml.template的文件，复制该文件，然后改名为mapred-site.xml，命令是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;code class=&quot;language-cpp&quot;&gt;cp /opt/hadoop/hadoop&lt;span class=&quot;hljs-number&quot;&gt;-2.8&lt;span class=&quot;hljs-number&quot;&gt;.0/etc/hadoop/mapred-site.xml.&lt;span class=&quot;hljs-keyword&quot;&gt;template /opt/hadoop/hadoop&lt;span class=&quot;hljs-number&quot;&gt;-2.7&lt;span class=&quot;hljs-number&quot;&gt;.3/etc/hadoop/mapred-site.xml&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vim  &lt;span&gt;/opt/hadoop/hadoop-2.7.3/etc/hadoop/mapred-site.xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在&amp;lt;configuration&amp;gt;节点内加入配置:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;name&amp;gt;mapred.job.tracker&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;value&amp;gt;&lt;strong&gt;&lt;span&gt;hserver1&lt;/span&gt;&lt;/strong&gt;:49001&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;      &amp;lt;name&amp;gt;mapred.local.dir&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;       &amp;lt;value&amp;gt;/root/hadoop/var&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;       &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;       &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;vim /opt/hadoop/hadoop-2.7.3/etc/hadoop/slaves&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加入你的datenode的hostname&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212230928813-2002612534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; vim  &lt;span&gt;/opt/hadoop/hadoop-2.7.3/etc/hadoop/yarn-site.xml&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;在&amp;lt;configuration&amp;gt;节点内加入配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;&lt;strong&gt;&lt;span&gt;hserver1&lt;/span&gt;&lt;/strong&gt;&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The address of the applications manager interface in the RM.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8032&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The address of the scheduler interface.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.scheduler.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8030&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The http address of the RM web application.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.webapp.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8088&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The https adddress of the RM web application.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.webapp.https.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8090&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.resource-tracker.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8031&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;description&amp;gt;The address of the RM admin interface.&amp;lt;/description&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.resourcemanager.admin.address&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;0.0.0.0:8033&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.scheduler.maximum-allocation-mb&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;2048&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;discription&amp;gt;每个节点可用内存,单位MB,默认8182MB&amp;lt;/discription&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.nodemanager.vmem-pmem-ratio&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;2.1&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.nodemanager.resource.memory-mb&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;2048&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;/p&gt;&lt;p&gt;   &amp;lt;property&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;name&amp;gt;yarn.nodemanager.vmem-check-enabled&amp;lt;/name&amp;gt;&lt;/p&gt;&lt;p&gt;        &amp;lt;value&amp;gt;false&amp;lt;/value&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/property&amp;gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;四.初始化hadoop和执行hadoop&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;cd   /opt/hadoop/hadoop-2.7.3/bin&lt;/span&gt;&lt;/strong&gt;   进入文件夹&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ./hadoop  namenode  -format       &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;初始化脚本&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;格式化成功后，可以在看到在/root/hadoop/dfs/name/目录多了一个current目录，而且该目录内有一系列文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在namenode上去执行启动命令&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;cd    /opt/hadoop/hadoop-2.8.0/sbin   （进入文件夹）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ./start-all.sh    （执行命令）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;过程中所有询问输入yes&lt;/p&gt;
&lt;p&gt;五.测试hadoop是否成功&lt;/p&gt;
&lt;p&gt;namenode的地址为39.105.201.218&lt;/p&gt;
&lt;p&gt;关闭防火墙&lt;span&gt;      &lt;span&gt;&lt;strong&gt;    &lt;span&gt;systemctl   stop   firewalld.service 后&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;打开：&lt;/p&gt;
&lt;p&gt;http://39.105.201.218:50090/（HDFS管理界面）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212231659616-451790671.png&quot; alt=&quot;&quot; width=&quot;746&quot; height=&quot;477&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;http://39.105.201.218:8088/   (cluster页面)&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1433995/201812/1433995-20181212231722247-2119338862.png&quot; alt=&quot;&quot; width=&quot;876&quot; height=&quot;332&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考文章    &lt;a href=&quot;https://blog.csdn.net/pucao_cug/article/details/71698903&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/pucao_cug/article/details/71698903&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 15:19:00 +0000</pubDate>
<dc:creator>蒙山一只鸽</dc:creator>
<og:description>一.为什么要大数据学习？ 这是一个大数据的时代，一个企业只有掌握了大数据才能把握住市场的命脉，一个人掌握了大数据就可以比较轻松的向机器学习、人工智能等方向发展。所以我们有必要去掌握大数据的技术同时也关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/SAM-CJM/p/10111653.html</dc:identifier>
</item>
<item>
<title>python多任务-线程 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-thread.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-thread.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;多任务的概念&quot;&gt;多任务的概念&lt;/h2&gt;
&lt;p&gt;什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。&lt;/p&gt;
&lt;p&gt;现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？&lt;/p&gt;
&lt;p&gt;答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。&lt;/p&gt;
&lt;p&gt;真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;并发：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）&lt;/li&gt;
&lt;li&gt;并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;线程基础&quot;&gt;线程基础&lt;/h2&gt;
&lt;p&gt;python的thread模块是比较底层的模块，python的threading模块是对thread做了一些包装的，可以更加方便的被使用&lt;/p&gt;
&lt;h3 id=&quot;单线程执行&quot;&gt;单线程执行&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time


def test():
        print(&quot;test...&quot;)
        time.sleep(1)


if __name__ == '__main__':

        for i in range(5):
                test()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行效果：程序在控制台每隔一秒打印&lt;code&gt;test...&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;多线程执行&quot;&gt;多线程执行&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading

def test():
        print(&quot;test...&quot;)
        time.sleep(1)


if __name__ == '__main__':

        for i in range(5):
                t = threading.Thread(target=test)
                t.start() # 启动线程
    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行效果：程序在控制台一下子输出五行&lt;code&gt;test...&lt;/code&gt;，等待1秒左右结束&lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以明显看出使用了多线程并发的操作，花费时间要短很多&lt;/li&gt;
&lt;li&gt;当调用&lt;code&gt;start()&lt;/code&gt;时，才会真正的创建线程，并且开始执行&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;主线程会等待所有子线程结束后才结束&quot;&gt;主线程会等待所有子线程结束后才结束&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading


def playPhone():

        print('玩手机...')
        time.sleep(1)


def eat():

        print(&quot;吃东西...&quot;)
        time.sleep(1)


if __name__ == '__main__':

        print(&quot;--开始--&quot;)

        t1 = threading.Thread(target=playPhone)
        t1.start()

        t2 = threading.Thread(target=eat)
        t2.start()

        print('--执行结束')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行效果：主线程阻塞1秒左右后程序结束，说明主线程在等待其他线程执行完毕。&lt;/p&gt;
&lt;h3 id=&quot;查看线程数量&quot;&gt;查看线程数量&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;          print('玩手机...')
                time.sleep(1)


def eat():

        for i in range(10):
                print(&quot;吃东西...&quot;)
                time.sleep(1)


if __name__ == '__main__':

        print(&quot;--开始--&quot;)

        t1 = threading.Thread(target=playPhone)
        t1.start()

        t2 = threading.Thread(target=eat)
        t2.start()
    
        # 查看正在执行的线程数量
        while True:
                length = len(threading.enumerate())
                print(&quot;当前运行的线程数量：%d&quot; % length)
                print(&quot;这些线程是：%s&quot; % str(threading.enumerate()))
    
    
                if length == 1:
                        break
    
                time.sleep(0.5)    

        print('--执行结束')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在python中，调用&lt;code&gt;threading.enumerate()&lt;/code&gt;能获取当前正在运行的所有线程，返回值是一个list，调用&lt;code&gt;length()&lt;/code&gt;函数并传入该list对象就获取到当前运行线程的数量。&lt;/p&gt;
&lt;h2 id=&quot;线程-注意点&quot;&gt;线程-注意点&lt;/h2&gt;
&lt;h3 id=&quot;线程执行代码的封装&quot;&gt;线程执行代码的封装&lt;/h3&gt;
&lt;p&gt;通过上一篇，能够看出，通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用threading模块时，往往会定义一个新的子类class，只要继承&lt;code&gt;threading.Thread&lt;/code&gt;就可以了，然后重写&lt;code&gt;run&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import threading


class MyThread(threading.Thread):

        def run(self):
                for i in range(5):
                        time.sleep(1)
                        print(&quot;我是%s@%d&quot; % (self.name, i)) 


if __name__ == &quot;__main__&quot;:
        mt = MyThread()
        mt.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;我是Thread-1@0
我是Thread-1@1
我是Thread-1@2
我是Thread-1@3
我是Thread-1@4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;python的threading.Thread类有一个run方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过Thread类的start方法，可以启动该线程，交给python虚拟机进行调度，当该线程获得执行的机会时，就会调用run方法执行线程。&lt;/p&gt;
&lt;h3 id=&quot;线程的执行顺序&quot;&gt;线程的执行顺序&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;mport time
import threading


class MyThread(threading.Thread):

        def run(self):
                for i in range(5):
                        time.sleep(1)
                        print(&quot;我是%s@%d&quot; % (self.name, i)) 


if __name__ == &quot;__main__&quot;:
    
        for i in range(5):
                mt = MyThread()
                mt.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果(运行的结果可能不一样，但是大体是一致的)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;我是Thread-5@0
我是Thread-2@0
我是Thread-3@0
我是Thread-4@0
我是Thread-1@0
我是Thread-3@1
我是Thread-4@1
我是Thread-2@1
我是Thread-5@1
我是Thread-1@1
我是Thread-3@2
我是Thread-4@2
我是Thread-2@2
我是Thread-5@2
我是Thread-1@2
我是Thread-3@3
我是Thread-4@3
我是Thread-2@3
我是Thread-5@3
我是Thread-1@3
我是Thread-3@4
我是Thread-4@4
我是Thread-5@4
我是Thread-2@4
我是Thread-1@4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码和执行结果我们可以看出，多线程程序的执行顺序是不确定的。当执行到sleep语句时，线程将被阻塞（Blocked），到sleep结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个run函数，但是线程的启动顺序、run函数中每次循环的执行顺序都不能确定。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的name，但是python会自动为线程指定一个名字。&lt;/li&gt;
&lt;li&gt;当线程的run()方法结束时该线程完成。&lt;/li&gt;
&lt;li&gt;无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 12 Dec 2018 14:31:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>[TOC] 多任务的概念 什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-thread.html</dc:identifier>
</item>
<item>
<title>.net core i上 K8S(四).netcore程序的pod管理，重启策略与健康检查 - 老六代码</title>
<link>http://www.cnblogs.com/chenyishi/p/10111368.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyishi/p/10111368.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/chenyishi/p/10094923.html&quot; target=&quot;_blank&quot;&gt;上一章&lt;/a&gt;我们已经通过yaml文件将.netcore程序跑起来了，但还有一下细节问题可以分享给大家。&lt;/p&gt;
&lt;h2&gt;1.pod管理&lt;/h2&gt;
&lt;h5&gt;1.1创建pod&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl create -f netcore-pod.yaml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们创建一个netcore-pod.yaml文件，内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod　　　　　　　　　　#指明类型
metadata: 
  name: netcore&lt;/span&gt;-&lt;span&gt;pod
  labels:
    app: netcorepod
spec:
  containers:
  &lt;/span&gt;-&lt;span&gt; name: netcorepod
    image: chenyishi&lt;/span&gt;/&lt;span&gt;webdocker_s_provider
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;1000&lt;/span&gt;
    &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;-&lt;span&gt; name: serverport
      value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;1.2查看pod是否创建成功&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212213337402-1983745976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;1.3查看pod描述&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212213651369-2063877634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;1.4替换pod&lt;/h5&gt;
&lt;p&gt;&lt;span&gt;先修改netcore-pod.yaml，name改成netcorepod1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212213913039-1193118325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再执行替换命令&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl replace -f netcore-pod.yaml --force
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212214014533-1842649875.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以看到，是先删除旧的，再替换的。&lt;/span&gt;&lt;/p&gt;
&lt;h5&gt;1.5删除pod&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 kubectl delete -f netcore-pod.yaml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212214220658-1832595545.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2.重启策略&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;k8s有三种重启策略Always（总是重启，默认），OnFailue（错误时重启），Never（从不），下面我们来修改netcore-pod.yaml配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata: 
  name: netcore&lt;/span&gt;-&lt;span&gt;pod
  labels:
    app: netcorepod
spec:
  containers:
  &lt;/span&gt;-&lt;span&gt; name: netcorepod
    image: chenyishi&lt;/span&gt;/&lt;span&gt;webdocker_s_provider
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;1000&lt;/span&gt;
    &lt;span&gt;env&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;-&lt;span&gt; name: serverport
      value: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  restartPolicy: OnFailure　　　　　　#策略&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后create&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl create -f netcore-pod.yaml  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们手动制造一个异常，去Node节点查询并kill掉进程dotnet&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212214909490-526897226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;kill&lt;/span&gt; -&lt;span&gt;9&lt;/span&gt; &lt;span&gt;82043&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后回到master节点，查看pod信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212215106952-316647707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以看到重启次数已经从0变成1了，说明我门的重启策略发挥作用了，大家可以多kill几次，这个数字会递增。另外两种策略大家也可以试一下&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3.健康检查&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;k8s为我们提供了对pod的健康检查，我们可以查看一下支持哪些&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212220508184-714343569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我们使用httpGet测试一下，修改配置如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212220645358-2142728816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用一个存在的接口/api/values/1测试，创建pod，并查看信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212220825919-721864546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;策略已生效，我们重新修改一下，改成一个不存在的接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212220950911-40047223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后replace掉旧的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212221047768-466582806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后查看信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033233/201812/1033233-20181212221140475-2136845809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们发现已经出发了健康检查策略，在不停重启，restart count再增加，Events事件信息也在增加。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;4.进入容器&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
kubectl exec pod/netcore-pod -it bash
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;至此，我们.netcore程序的pod管理，重启策略与健康检查分享完了。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 14:15:00 +0000</pubDate>
<dc:creator>老六代码</dc:creator>
<og:description>上一章我们已经通过yaml文件将.netcore程序跑起来了，但还有一下细节问题可以分享给大家。 1.pod管理 我们创建一个netcore-pod.yaml文件，内容如下： 先修改netcore-p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenyishi/p/10111368.html</dc:identifier>
</item>
<item>
<title>ffmpeg滤波格式协商 - TaigaComplex</title>
<link>http://www.cnblogs.com/TaigaCon/p/10111326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TaigaCon/p/10111326.html</guid>
<description>&lt;p&gt;ffmpeg的中滤波器是以帧为原料来进行滤波的，那么自然地就会对帧的格式有所要求，可以说如果滤波器不知道帧的格式，就无法对帧进行处理。在进行视频滤波时，滤波格式指的是视频的像素格式；在进行音频滤波时，滤波格式包括音频采样格式，采样率以及通道数目。&lt;/p&gt;


&lt;p&gt;滤波器可能只支持某一种帧格式，也有可能对所有的帧格式都支持，因此在执行滤波操作之前，有必要对滤波过程中的各个滤波器所支持的格式进行协商。&lt;/p&gt;
&lt;p&gt;相邻的两个滤波实例之间是由AVFilterLink来连接的，因此AVFilterLink也承担了协商相邻两个滤波实例的滤波格式的任务。AVFilterLink的结构体中与滤波格式相关如下的变量如下：&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
struct AVFilterLink {
    /*format negotiation valuables*/
    uint64_t channel_layout;
    int sample_rate;
    int format;

    AVFilterFormats *in_formats;
    AVFilterFormats *out_formats;
    AVFilterFormats  *in_samplerates;
    AVFilterFormats *out_samplerates;
    struct AVFilterChannelLayouts  *in_channel_layouts;
    struct AVFilterChannelLayouts *out_channel_layouts;
}
&lt;/pre&gt;
&lt;p&gt;其中，in_formats/in_samplerates/in_channel_layouts、out_formats/out_samplerates/out_channel_layouts分别为当前Link输入端滤波器支持的输出滤波格式以及输出端滤波器支持的输入滤波格式，以Link的视点来说，分别就是可能的输入（所以变量被命名为in）格式以及可能的输出格式（所以变量被命名为out）。而format/sample_rate/channel_layout就是经过协商后得出唯一的格式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220653741-598601644.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220654510-954875747.png&quot; alt=&quot;image&quot; width=&quot;350&quot; height=&quot;138&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;滤波格式的协商分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置所有AVFilterLink上的格式列表&lt;/li&gt;
&lt;li&gt;如果AVFilterLink的输入输出格式列表中有相同的格式，则提取相同格式作为新的输入以及输出格式&lt;/li&gt;
&lt;li&gt;否则表明需要进行格式转换&lt;/li&gt;
&lt;li&gt;提取合并后的格式列表中的某个格式作为最终格式&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;设置格式列表&lt;/h4&gt;
&lt;p&gt;滤波格式的协商是在AVFilterLink上执行的，因此滤波器需要向AVFilterLink表明自己所支持的输入以及输出格式，即由AVFilter来设置它周围的AVFilterLink上的格式列表。这个设置的操作是由AVFilter内的query_formats函数来实现的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220654852-1683305644.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220655242-1736492670.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;216&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;query_formats是AVFilter中的一个回调函数，如果某个滤波器对输入以及输出格式有要求或者限制，则需要通过query_formats来设置输入link的out_formats以及输出link的in_formats。如果滤波器不实现query_formats，则表明该滤波器的输入输出默认支持所有格式。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
    for (i = 0; i &amp;lt; graph-&amp;gt;nb_filters; i++) {
        AVFilterContext *f = graph-&amp;gt;filters[i];
        if (formats_declared(f))
            continue;
        if (f-&amp;gt;filter-&amp;gt;query_formats)
            ret = filter_query_formats(f);
        else
            ret = ff_default_query_formats(f);
        if (ret &amp;lt; 0 &amp;amp;&amp;amp; ret != AVERROR(EAGAIN))
            return ret;
        /* note: EAGAIN could indicate a partial success, not counted yet */
        count_queried += ret &amp;gt;= 0;
    }
&lt;/pre&gt;

&lt;h4&gt;AVFilterLink的格式合并&lt;/h4&gt;
&lt;p&gt;在设置完graph上所有link的in_formats以及out_formats后，就需要提取每个link上in_formats与out_formats的共同formats，我们称这一步骤为合并（merge）。&lt;/p&gt;
&lt;p&gt;在讨论怎么merge formats之前，我们需要先了解AVFilterFormats这一结构体。AVFilterFormats就是我们前文所说的格式列表，定义如下：&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
struct AVFilterFormats {
    unsigned nb_formats;        ///&amp;lt; number of formats
    int *formats;               ///&amp;lt; list of media formats

    unsigned refcount;          ///&amp;lt; number of references to this list
    struct AVFilterFormats ***refs; ///&amp;lt; references to this list
};
&lt;/pre&gt;
&lt;p&gt;nb_formats是列表中format的数目；formats是指向format列表的指针；refcount代表本列表被引用的次数；refs指向一个列表，该列表中存放的是引用了本列表的地方的地址。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220655566-1398332039.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220655882-1190086376.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;175&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里的合并，是要从AVFilterLink的in_formats以及out_formats中挑出相同的format，然后组合成新的一个AVFilterFormats。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220656236-1014892298.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220656854-1544582005.png&quot; alt=&quot;image&quot; width=&quot;600&quot; height=&quot;413&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在实际滤波过程中，我们需要通过名为buffersrc的滤波器输入帧，而buffersrc在进行初始化的时候需要指定唯一的帧格式，即位于整个滤波图头部的是一个format个数为1的AVFilterFormats。并且，对于很多滤波器来说，所支持的输入输出格式是一样的，因此位于滤波器输入端link的out_formats与输出端link的in_formats会指向同一个AVFilterFormats。出于这两个原因，在循环地对graph上的AVFilterLink进行merge的时候，很容易地就能使得整个graph上所有的link中的in_formats与out_formats都指向同一个AVFilterFormats，并且其中含有唯一一个format就是输入帧的format。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220657362-1397731773.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220657776-1580006482.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;367&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如上图就是filter的输入与输出端支持同样格式，因此会把输入link的out_formats以及输出link的in_formats指向同一AVFilterFormats。不过如果filter两端支持不同的格式，则表示该filter内可能对帧的格式进行了转换。&lt;/p&gt;

&lt;h4&gt;自动格式转换&lt;/h4&gt;
&lt;p&gt;如果AVFilterLink的in_formats与out_formats中不含有相同format，就表明需要进行格式转换。出现这种情况的时候ffmpeg会在该link上插入一个用于格式转换的滤波器，进行视频像素格式转换的滤波器名为scale，进行音频采样格式转换的滤波器名为aresample。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
if (convert_needed) {
    switch (link-&amp;gt;type) {
    case AVMEDIA_TYPE_VIDEO:
        filter = avfilter_get_by_name(&quot;scale&quot;);
        avfilter_graph_create_filter(&amp;amp;convert, filter,
                                        inst_name, graph-&amp;gt;scale_sws_opts, NULL,
                                        graph);
        break;
    case AVMEDIA_TYPE_AUDIO:
        filter = avfilter_get_by_name(&quot;aresample&quot;);
        avfilter_graph_create_filter(&amp;amp;convert, filter,
                                            inst_name, graph-&amp;gt;aresample_swr_opts,
                                            NULL, graph);
        break;
    default:
        return AVERROR(EINVAL);
    }

    if ((ret = avfilter_insert_filter(link, convert, 0, 0)) &amp;lt; 0)
        return ret;

    if ((ret = filter_query_formats(convert)) &amp;lt; 0)
        return ret;
    if (!ff_merge_formats( inlink-&amp;gt;in_formats,  inlink-&amp;gt;out_formats,  inlink-&amp;gt;type) ||
        !ff_merge_formats(outlink-&amp;gt;in_formats, outlink-&amp;gt;out_formats, outlink-&amp;gt;type))
        ret = AVERROR(ENOSYS);
&lt;/pre&gt;
&lt;p&gt;插入格式转换滤波器包含以下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;插入格式转换滤波器的函数avfilter_insert_filter会把原来的link的出口连接到格式转换滤波器的入口上，然后用新的link连接格式转换滤波器的出口以及源link原来的目标端口。最后还会把源link的out_formats移给新link的out_formats。&lt;/li&gt;
&lt;li&gt;filter_query_formats则会调用格式转换滤波器的query_formats函数来设置其两端的out_formats以及in_formats，由于此时我们一般不会为其设置任何参数，因此此时格式转换滤波器两端的out_formats以及in_formats会支持所有格式。&lt;/li&gt;
&lt;li&gt;最后的ff_merge_formats把涉及到的这两个link上的格式进行merge，这样就使得格式转换滤波器两端的out_formats以及in_formats设定完毕。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220658263-1549122583.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220658827-1465176215.png&quot; alt=&quot;image&quot; width=&quot;600&quot; height=&quot;629&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在得到格式转换滤波器两边的两个link的最终格式后，会通过调用格式转换滤波器的config_props函数来进行转换的初始化，初始化时的输入参数就是这两个link的最终格式。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
static int config_output(AVFilterLink *outlink)
{
    AVFilterContext *ctx = outlink-&amp;gt;src;
    AVFilterLink *inlink = ctx-&amp;gt;inputs[0];

    aresample-&amp;gt;swr = swr_alloc_set_opts(aresample-&amp;gt;swr,
                                        outlink-&amp;gt;channel_layout, outlink-&amp;gt;format, outlink-&amp;gt;sample_rate,
                                        inlink-&amp;gt;channel_layout, inlink-&amp;gt;format, inlink-&amp;gt;sample_rate,
                                        0, ctx);
}
&lt;/pre&gt;


&lt;h4&gt;提取最终格式&lt;/h4&gt;
&lt;p&gt;经过前面的流程，已经能保证link上的in_formats与out_formats是merge过的了，下面处理同一个滤波器的输入以及输出link之间的格式问题。&lt;/p&gt;
&lt;p&gt;尽管我们前面说过，对于内部不会进行格式转换的滤波器，通常其输入输出会支持相同的格式，因此输入link的out_formats与输出link的in_formats一般来说都是指向同一个AVFilterFormats，不过滤波器多种多样，也有可能会出现明明可以不用格式转换，输入link的out_formats却与输出link的in_formats却指向不同AVFilterFormats。为了防止滤波器做不必要的格式转换，有以下处理方式：一旦发现输入link的out_formats当中只有唯一一个格式，并且输出link的in_formats当中包含该格式，则会把该格式移动到in_formats[0]，并把格式数目设置为1。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220659258-554022812.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220659634-324384534.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;247&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在选取link的最终格式时，一般来说link的格式列表中只有一个格式，因此会直接选则这一个格式。&lt;/p&gt;
&lt;pre class=&quot;brush: js; auto-links: true; collapse: false; first-line: 1; gutter: true; html-script: false; light: false; ruler: false; smart-tabs: true; tab-size: 4; toolbar: true;&quot;&gt;
static int pick_format(AVFilterLink *link, AVFilterLink *ref)
{
    link-&amp;gt;in_formats-&amp;gt;nb_formats = 1;
    link-&amp;gt;format = link-&amp;gt;in_formats-&amp;gt;formats[0];
}
&lt;/pre&gt;

&lt;p&gt;不过也存在特殊情况：如果滤波器支持不同于源格式的多种输出格式，但是用户并没有指定具体的输出格式，那么应该根据源格式从当前列表中选择最优的输出格式。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220659980-309464394.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/421096/201812/421096-20181212220700343-1333511776.png&quot; alt=&quot;image&quot; width=&quot;400&quot; height=&quot;230&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 12 Dec 2018 14:07:00 +0000</pubDate>
<dc:creator>TaigaComplex</dc:creator>
<og:description>ffmpeg的中滤波器是以帧为原料来进行滤波的，那么自然地就会对帧的格式有所要求，可以说如果滤波器不知道帧的格式，就无法对帧进行处理。在进行视频滤波时，滤波格式指的是视频的像素格式；在进行音频滤波时，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TaigaCon/p/10111326.html</dc:identifier>
</item>
<item>
<title>将ijkplayer播放器移植到windows平台（附源码） - HarlanC</title>
<link>http://www.cnblogs.com/harlanc/p/10111290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/harlanc/p/10111290.html</guid>
<description>&lt;p&gt;ijkplayer windows版本的移植工作终于有了一些进展，起初自己做这个项目是因为公司有可能会用到，于是用业余时间慢慢熟悉相关知识和ijkplayer的代码。现在应该是用不到了，到这里做一个总结吧，最终能够达到的效果是是能够在windows上用OpenGL ES渲染视频和用OpenAL播放声音，但是还有音画不同步的问题，以后有时间的话再去解决。各位如果有想学习音视频渲染的可以参考我的代码相互交流学习。&lt;/p&gt;
&lt;p&gt;下面是编译源码的说明文档，如果有任何问题可以通知我。&lt;/p&gt;
&lt;h2 id=&quot;编译环境&quot;&gt;编译环境&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;MinGW32&lt;/li&gt;
&lt;li&gt;WIN7&lt;/li&gt;
&lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;MinGW32环境的搭建可以参考之前的&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9569960.html&quot;&gt;帖子&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;h3 id=&quot;编译ijkplayer-ffmpeg&quot;&gt;编译ijkplayer-ffmpeg&lt;/h3&gt;
&lt;p&gt;ijkplayer使用的ffmpeg直接拿来在windows上编译会出错，需要merge官方ffmpeg的最新代码，可以看之前的&lt;a href=&quot;https://www.cnblogs.com/harlanc/p/9794811.html&quot;&gt;帖子&lt;/a&gt;。merge后的代码push到了&lt;a href=&quot;https://github.com/harlanc/FFmpeg.git&quot;&gt;github&lt;/a&gt;上。&lt;/p&gt;
&lt;p&gt;将代码clone到MInGW_root_path/msys/1.0/home/Admistrator/下面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/harlanc/FFmpeg.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将ijkplayer branch checkout下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git checkout origin/ijkplayer -b ijkplayer&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;configure&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ ./configure --disable-static --enable-shared --enable-gpl --enable-version3 --enable-sdl --enable-debug=3 --disable-optimizations --disable-mmx --disable-s tripping&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;make &amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编译angle库&quot;&gt;编译Angle库&lt;/h3&gt;
&lt;p&gt;clone到本地&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/Microsoft/angle.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用批处理生成sln文件然后用Vistual Studio编译生成以下3个dll:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;d3dcompiler_47.dll&lt;/li&gt;
&lt;li&gt;libEGL.dll&lt;/li&gt;
&lt;li&gt;libGLESv2.dll&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体流程参考微软的&lt;a href=&quot;https://github.com/Microsoft/angle#quick-start-compiling-from-source&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将上面三个dll拷贝到 MInGW_root_path/msys/1.0/local/bin下面&lt;/p&gt;
&lt;h2 id=&quot;编译ijkplayer-windows&quot;&gt;编译ijkplayer-windows&lt;/h2&gt;
&lt;p&gt;clone代码到本地&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/harlanc/ijkplayer-windows.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将ijkplayer-windows branch checkout下来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git checkout origin/ijkplayer-windows -b ijkplayer-windows&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将Angle代码库下面的include文件夹拷贝到ijkplayer-windows/ijkmedia/ijksdl 下面。&lt;/p&gt;
&lt;p&gt;到ijkplayer-windows/ijkmedia目录下执行configure命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./configure&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行make&amp;amp;&amp;amp; make install&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;执行&quot;&gt;执行&lt;/h2&gt;
&lt;p&gt;最后会在ijkplayer-windows/ijkmedia/ijkplayer/windows/.libs 下面生成winplayer.exe可执行文件。将视频文件拷贝到此目录下面，执行下面的命令播放：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; ./winplayer.exe test.mp4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;附一个最终的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://files-cdn.cnblogs.com/files/harlanc/ijkplayer_windows.bmp&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;已知问题&quot;&gt;已知问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;音画不同步&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 12 Dec 2018 14:01:00 +0000</pubDate>
<dc:creator>HarlanC</dc:creator>
<og:description>将ijkplayer移植到windows平台（附源码） ijkplayer windows版本的移植工作终于有了一些进展，起初自己做这个项目是因为公司有可能会用到，于是用业余时间慢慢熟悉相关知识和ij</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/harlanc/p/10111290.html</dc:identifier>
</item>
<item>
<title>CSS float的相关图文详解（一） - 公主666</title>
<link>http://www.cnblogs.com/xuln/p/10111169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuln/p/10111169.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;大家好，作为一个刚入门的小前端，第一次写博客，很是鸡冻。由于涉猎较浅，有些知识可能说的不清楚，或者有什么错误，欢迎留言指正。我的第一篇博客写的关于css的浮动的。想必很多小伙伴特别是刚学的，对浮动有一定的迷惑，当然了，并不是所有初学者都像我一样迷迷糊糊。哈哈，废话不多说，现在谈谈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我对浮动的理解，更应该说是总结吧，还是那句话，如果哪里不对，请留言指出，这也是帮助我进步。　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　历史：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　 浮动最开始是为了实现文字环绕的效果，也就是说浮动最开始是用来做一些文字混排效果&lt;/span&gt;&lt;span&gt;的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　浮动：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　元素的浮动是指设置了浮动属性的元素会脱离标准流的控制，移动到其父元素中指定位置的过程。如果元素设置了浮动，会使元素向左或向右移动，也就是说元素只能水平方向浮动，不能上下浮动，而元素设置了浮动后，周围的元素也会重新排列。一个浮动的元素会尽量向左或向右移动，直到它的外边缘碰到包含边框或另一个浮动框的边框为止。需要&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;的是：浮动元素之前的元素不会受到影响，而浮动元素之后的元素会围绕它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;图1：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212195649464-1607322921.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　图1解释：这是三个自上而下排列的块级元素，块级元素独占一行，当给框1设置向右浮动时，框1会脱离文档流，不占据原来的位置，并且向右移动，直到框1的右边缘碰到包含框的右边缘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;浮动元素会脱离文档流，不占据原来的位置。浮动的元素总是找离它最近的父级元素对齐，但是不会超出内边距的范围。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;图2：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212200724561-1119751257.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;图2解释：当给框1设置左浮动时，框1会脱离文档流并且向左移动，直到框1的左边缘碰到包含框的左边缘。前面说过浮动的元素会脱离文档流，不占据原来的位置，所以，现在，框1不再处于文档流中，也就意味着框1不占据空间了，而这时框2就跑到了框1原来的位置，因为框1现在漂浮着，实际上框1覆盖住了框2，使得框2从视图中消失了。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;如果你将三个框都设置向左浮动，那么，框1向左浮动直到碰到包含框，框2向左浮动直到碰到框1，而框3向左浮动直到碰到框2。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;图3：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212201834071-2011967750.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;图3解释：当包含框太窄，无法容纳水平排列的浮动元素时，那么其他浮动块向下移动，直到有足够的空间。如果浮动元素的高度不同，那么当它们向下移动时可能会被其他浮动元素&quot;卡住&quot;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　特性：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　(1).浮动的元素排列位置，跟上一个元素(块级)有关系。也就是说浮动对它下面的盒子有影响。例如：A元素和B元素是上下排列的，A元素在B元素的上面，如果A元素设置了浮动，那么B元素的顶部会和A元素的顶部对齐(可参看图2解释)；如果A元素是标准流，那么B元素的顶部会和A元素的底部对齐(即使B元素添加了浮动也会和A元素的底部对齐，因为B元素的浮动只对它的下面的盒子有影响)。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　举例：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;html代码　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!Doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;浮动&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;ab&quot;&amp;gt;A&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;ba&quot;&amp;gt;B&amp;lt;/div&amp;gt;     
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;CSS代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .ab{
                width:100px;
                height:100px;
                background-color:orange;
                font-size:50px;
                line-height:100px;
                text-align:center;
}

        .ba{
                width:100px;
                height:100px;
                background-color:pink;
                font-size:50px;
                line-height:100px;
                text-align:center;
}

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;显示效果&lt;/strong&gt;&lt;/span&gt;　　&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212204129421-346798654.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上面是A元素和B元素初始化默认的状态，这时，给A元素添加左浮动，代码如下：&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .ab{
                width:100px;
                height:100px;
                background-color:orange;
                font-size:50px;
                line-height:100px;
                text-align:center;
               /*给A元素设置float属性，其值为left*/
               float：left；  
}

        .ba{
                /*width:100px;
                height:100px;*/&lt;br/&gt;　　　　　　　　　　/*为了能够更好的显示效果，将B元素的宽度高度都设置为200px*/&lt;br/&gt;　　　　　　　　　　width:200px;&lt;br/&gt;　　　　　　　　　　height:200px;
                background-color:pink;
                font-size:50px;
                line-height:100px;
                text-align:center;
}

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　&lt;span&gt;　给A元素添加左浮动显示效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212204759753-585023196.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;从上图可以看出，A元素脱离了文档流，不占据原来的位置，而B元素就占据了A元素原来的位置，这时，A元素的顶部与B元素的顶部对齐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果是给B元素设置了浮动，而A元素没有设置浮动，会有什么样的效果呢？代码如下：&lt;/span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .ab{
                width:100px;
                height:100px;
                background-color:orange;
                font-size:50px;
                line-height:100px;
                text-align:center;
                
}

        .ba{
                width:100px;
                height:100px;
                background-color:pink;
                font-size:50px;
                line-height:100px;
                text-align:center;
                /*给B元素设置浮动*/ 
                float:left;
}

&amp;lt;/style&amp;gt;    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　显示效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212205249783-940067851.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然是给B元素设置了浮动，但是A元素和B元素的排列方式跟最开始没有设置时的排列方式一样。这说明添加浮动的元素只会对它下面的元素产生影响，而上面的元素不会产生影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2).&lt;span&gt;一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;html代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!Doctype html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;浮动&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;div class=&quot;father&quot;&amp;gt;
                &amp;lt;div class=&quot;son1&quot;&amp;gt;son1&amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;son2&quot;&amp;gt;son2&amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;son3&quot;&amp;gt;son3&amp;lt;/div&amp;gt;        
        &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;css代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .father{
                width:310px;
                height:310px;
                border:1px solid red;
}
        .son1{
                width:100px;
                height:100px;
                background-color:orange;
                font-size:20px;
                line-height:100px;
                text-align:center;
                float:left;
                
}

        .son2{
                width:100px;
                height:100px;
                background-color:pink;
                font-size:20px;
                line-height:100px;
                text-align:center;
                float:left;
}
        .son3{
                width:100px;
                height:100px;
                background-color:yellowgreen;
                font-size:20px;
                line-height:100px;
                text-align:center;
                float:left;
}

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;显示效果如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212210309747-1502388088.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(3).&lt;/span&gt;&lt;span&gt;元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。浮动可以让元素默认转换为行内块元素。行内元素手动设置的宽高是不生效的，给个display:inline-block就生效了，现在不给display给个float也会生效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;html代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;浮动&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
        &amp;lt;span class=&quot;cls&quot;&amp;gt;我是行内元素&amp;lt;/span&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;css代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:css;gutter:true;&quot;&gt;
&amp;lt;style&amp;gt;
        .cls{
                width:100px;
                height:100px;
                background-color:red;
                /*添加浮动*/
               float:left;     
}

&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;显示效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485647/201812/1485647-20181212211055671-1966917227.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;本身span元素是行内元素，设置宽度高度是没有效果的，只有将span转为块级元素或者行内块元素才会生效，可以直接给span元素设置float属性就可以转化为块级元素或行内块元素。　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(4).浮动的元素不会压住padding　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;关于浮动这里总结了个小口诀，大家感兴趣的话可以参考下。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;float 浮 漏 特&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　特： 特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　浮动是把双刃剑，在给我们的布局带来便利的同时有一些缺点需要我们去解决。例如最常见的父元素塌陷。下一节详细介绍如果清除浮动等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果您看到这里，文章中有哪些不对的欢迎留言指出，也可以提出更宝贵的意见。第一次写博客，如果字体或者排版给您带来不便，我深感抱歉。也希望自己的一点点小总结对您多少有点帮助。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 12 Dec 2018 13:33:00 +0000</pubDate>
<dc:creator>公主666</dc:creator>
<og:description>大家好，作为一个刚入门的小前端，第一次写博客，很是鸡冻。由于涉猎较浅，有些知识可能说的不清楚，或者有什么错误，欢迎留言指正。我的第一篇博客写的关于css的浮动的。想必很多小伙伴特别是刚学的，对浮动有一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuln/p/10111169.html</dc:identifier>
</item>
<item>
<title>Python with/as使用说明 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10111121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10111121.html</guid>
<description>&lt;h2 id=&quot;withas&quot;&gt;with/as&lt;/h2&gt;
&lt;p&gt;使用open打开过文件的对with/as都已经非常熟悉，其实with/as是对try/finally的一种替代方案。&lt;/p&gt;
&lt;p&gt;当某个对象支持一种称为&quot;环境管理协议&quot;的协议时，就会通过环境管理器来自动执行某些善后清理工作，就像finally一样：不管中途是否发生异常，最终都会执行某些清理操作。&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with expression [as var]:
    with_block_code&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当expression返回的对象是支持环境管理协议的时候，就可以使用with。as var是可选的，如果不使用as var，expression返回对象将被丢弃，如果使用as var，就会将expression的返回对象赋值给变量var。&lt;/p&gt;
&lt;p&gt;整个流程大致如下：先评估expression，如果支持环境管理协议，然后开始with/as语句块结构，当准备退出with语句块的时候，将执行对象中定义的善后操作。工作机制的细节见下文。&lt;/p&gt;
&lt;p&gt;例如，open()返回的文件对象是支持环境管理协议的，所以可以用with/as来安全地打开文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with open(r'd:\a\b\c\a.log') as logfile:
    for line in logfile:
        print(line)
        ...more code here...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个过程是先open()，然后with/as，输出每一行后将要退出with语句块的时候，环境管理器根据文件对象中定义的操作关闭文件。&lt;/p&gt;
&lt;p&gt;它实际上等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;myfile = open(r'd:\a\b\c\a.log')
try:
    for line in myfile:
        print(line)
        ...more code here...
finally:
    myfile.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然在文件不被引用之后，垃圾回收器会自动回收这个文件对象，但是垃圾回收器的回收操作是有等待时间的。换句话说，如果不使用with/as打开文件，也不显示close()关闭文件，那么这个文件很可能会在用完之后保持空闲一段时间，然后才被垃圾回收器回收。&lt;/p&gt;
&lt;p&gt;with/as不仅用于文件打开/关闭，锁操作也支持环境管理协议，也就是说，在有需要的时候会自动释放锁资源。&lt;/p&gt;
&lt;h2 id=&quot;嵌套多个环境管理器&quot;&gt;嵌套多个环境管理器&lt;/h2&gt;
&lt;p&gt;在python 3.1之后，with as支持多个环境管理器，使用逗号隔开即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with A() as a, B() as b:
    ...statements...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它等价于嵌套的with：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with A() as a:
    with B() as b:
        ...statements...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多环境管理器管理的多个对象会在with语句块中出现异常的时候，或者执行完with语句块的时候全部自动被清理(例如文件关闭操作)。&lt;/p&gt;
&lt;p&gt;例如，打开两个文件，将它们的内容通过zip()合并在一起，并且同时关闭它们：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with open('a.file') as f1, open('b.file') as f2:
    for pair in zi[(f1, f2):
        print(pair)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义环境管理器&quot;&gt;自定义环境管理器&lt;/h2&gt;
&lt;p&gt;无论是文件还是锁，都是别人已经写好了环境管理器的对象。我们自己也可以写环境管理器，让它可以使用with/as，这实际上属于运算符重载的范畴。&lt;/p&gt;
&lt;p&gt;要写自己的环境管理器，先了解with/as的工作机制的细节：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先评估expression，评估的返回结果是一个对象，这个对象要具有&lt;code&gt;__enter__&lt;/code&gt;和&lt;code&gt;__exit__&lt;/code&gt;方法，返回的对象称为&quot;环境管理器&quot;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;然后调用环境管理器的&lt;code&gt;__enter__&lt;/code&gt;方法。&lt;code&gt;__enter__&lt;/code&gt;方法的返回值赋值给 as 指定的变量，或者直接丢弃(没有使用as)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;然后执行with语句块中的内容&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果执行with语句块中的内容时抛出了异常，将调用&lt;code&gt;__exit__(type,value,traceback)&lt;/code&gt;方法，其中这3个和异常相关的参数来源于&lt;code&gt;sys.exc_info&lt;/code&gt;。如果&lt;code&gt;__exit__&lt;/code&gt;返回值为False，则会自动重新抛异常以便传播异常，否则异常被认为合理处理&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果with语句块中的内容没有抛异常，则直接调用&lt;code&gt;__exit__(None,None,None)&lt;/code&gt;，即这三个参数都传递为None值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看一个简单的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TraceBlock:
    def message(self, arg):
        print('running ' + arg)

    def __enter__(self):
        print('starting with block')
        return self

    def __exit__(self, exc_type, exc_value, exc_tb):
        if exc_type is None:
            print('exited normally\n')
        else:
            print('raise an exception! ' + str(exc_type))
            return False&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的&lt;code&gt;__enter__&lt;/code&gt;方法返回的对象会赋值给as关键字指定的变量，在这个示例中即将对象自身返回。如果有需求，可以返回其它对象。&lt;/p&gt;
&lt;p&gt;上面的&lt;code&gt;__exit__&lt;/code&gt;中，如果异常的类型为None，说明with语句块中的语句执行过程没有抛异常，正常结束即可。但是如果有异常，则要求返回False，实际上上面的&lt;code&gt;return False&lt;/code&gt;可以去掉，因为函数没有return时默认返回None，它的布尔值代表的就时False。&lt;/p&gt;
&lt;p&gt;测试下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;with TraceBlock() as action:
    action.message(&quot;test 1&quot;)
    print(&quot;reached&quot;)
    
print('-' * 20, &quot;\n&quot;)

with TraceBlock() as action:
    action.message(&quot;test 2&quot;)
    raise TypeError
    print(&quot;not reached&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;starting with block
running test 1
reached
exited normally

--------------------

starting with block
running test 2
raise an exception! &amp;lt;class 'TypeError'&amp;gt;
Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 23, in &amp;lt;module&amp;gt;
    raise TypeError
TypeError&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义环境管理器不是件简单的事。一般来说，如果不是很复杂的需求，直接使用try/finally来定义相关操作即可。&lt;/p&gt;
</description>
<pubDate>Wed, 12 Dec 2018 13:25:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>with/as 使用open打开过文件的对with/as都已经非常熟悉，其实with/as是对try/finally的一种替代方案。 当某个对象支持一种称为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10111121.html</dc:identifier>
</item>
</channel>
</rss>