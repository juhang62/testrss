<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>给计算机专业学生的几条建议 - 天下技术</title>
<link>http://www.cnblogs.com/mysqlcskdpl/p/13769294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mysqlcskdpl/p/13769294.html</guid>
<description>&lt;p&gt;计算机专业的学生毕业后基本还会从事这个行业的。毕竟市场需要和行业待遇摆在那里，三百六十行行行转it，不是乱说的。&lt;/p&gt;
&lt;p&gt;然而，大学教育无非就是上课-自习-考试，老师辅导员校长都不会细致的告诉每一个专业的同学，还应该做点什么？这导致很多计算机专业毕业生写简历的时候只能写学了哪些课程，成绩如何，面试官看不到你对这个行业的哪怕一点兴趣。这样在找工作季是很吃亏的，甚至会因为压力过大，基于找到工作，落入传销陷阱。&lt;/p&gt;
&lt;p&gt;本文给各位同学提几条建议，要做到这些不需要花很多功夫，但天天打游戏看电影肯定是不行的。如果你能在上学期间做到我下面给的这些建议，你已经超过了50%的同学了，将来胜出是很容易的。等到公司再努力，就很难这么轻易的胜出了，因为那时大家就都知道该做什么了。&lt;/p&gt;
&lt;p&gt;一、学会习惯使用github（&lt;a href=&quot;https://github.com/%EF%BC%89%EF%BC%8C%E5%BD%93%E4%BD%A0%E7%9A%84%E5%90%8C%E5%AD%A6%E8%BF%98%E5%8F%AA%E4%BC%9Acsdn%E4%B8%8B%E8%BD%BD%E4%BB%A3%E7%A0%81%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E4%BC%9A%E4%BD%BF%E7%94%A8github%EF%BC%8C%E4%BD%A0%E5%B0%B1%E9%A2%86%E5%85%88%E4%B8%80%E5%8D%8A%E7%9A%84%E4%BA%BA%E4%BA%86%E3%80%82%E8%BF%99%E9%87%8C%E6%9C%89%E6%B5%B7%E9%87%8F%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%A0%E7%94%9A%E8%87%B3%E8%83%BD%E5%9C%A8%E9%87%8C%E9%9D%A2%E6%89%BE%E5%88%B0%E4%BD%A0%E7%9A%84%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E3%80%82%E4%B8%8D%E6%98%AF%E8%AE%A9%E4%BD%A0%E6%8A%84%EF%BC%8C%E6%98%AF%E8%AE%A9%E4%BD%A0%E5%80%9F%E9%89%B4%EF%BC%8C%E4%BD%BF%E4%BD%A0%E7%9A%84%E8%AE%BA%E6%96%87%E6%9B%B4%E5%8A%A0%E4%B8%B0%E5%AF%8C%E3%80%82&quot;&gt;https://github.com/），当你的同学还只会csdn下载代码的时候，如果你会使用github，你就领先一半的人了。这里有海量代码，你甚至能在里面找到你的毕业设计。不是让你抄，是让你借鉴，使你的论文更加丰富。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;二、学会习惯使用谷歌镜像（&lt;a href=&quot;https://ac.scmor.com/%EF%BC%89%E6%90%9C%E7%B4%A2%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF%E3%80%82%E6%9C%89%E7%9A%84%E4%B8%9C%E8%A5%BF%E7%99%BE%E5%BA%A6%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BC%9A%E4%B8%8D%E5%85%A8%E9%9D%A2%EF%BC%8C%E6%9C%89%E4%BA%86%E8%B0%B7%E6%AD%8C%E9%95%9C%E5%83%8F%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B&quot;&gt;https://ac.scmor.com/）搜索一些东西。有的东西百度的结果会不全面，有了谷歌镜像，可以看看&lt;/a&gt; 谷歌的结果。和百度的结果形成互补，能高效帮助你解决问题。&lt;br/&gt;三、闲暇时间刷刷算法，推荐(&lt;a href=&quot;https://leetcode-cn.com&quot;&gt;https://leetcode-cn.com&lt;/a&gt;），据说刷完里面100道题，所有互联网公司的第一面都能通过了。同学们可以打游戏打累了，心态打崩了，来这里刷刷算法，到找工作季闲庭信步的感觉是不是很好。&lt;/p&gt;
&lt;p&gt;四、给自己的电脑安装Linux虚拟机。学生电脑都是window，运行在window上的大型系统在工作中并不多见，尤其互联网公司，购买的都是Linux小型机，这会使得你刚工作时很不适应。不如上学时在电脑上装一个VMware（vbox也可以），在vmware里面安装Linux，什么版本的Linux都可以，大同小异。下载Linux的iso文件可以到盘搜搜找（&lt;a href=&quot;https://www.pansoso.com/&quot;&gt;https://www.pansoso.com/&lt;/a&gt; ），然后百度网盘下载，我最近都是从这里找的。登陆虚拟机可以安装xshell、或者securecrt等工具。&lt;/p&gt;
&lt;p&gt;五、熟练掌握一门编程语言，可以根据市场需求，可以根据自身爱好。一定要买本对应的经典书籍认真阅读。&lt;/p&gt;
&lt;p&gt;六、做一套简单的BS系统（指的是浏览器-服务端系统），无论多简单，都会遇到很多坑，帮你对什么是系统有个完整的概念是很重要的。也会逼着你学会简单的建立web服务的方法，http服务行业标准，学一些html、css、javascript等前端知识，别看东西多，但如果只学一点皮毛，并不需要大量时间。而且这些写在简历里，比学过《数据结构和算法》《操作系统原理》，比通过四六级考试，要更吸引眼球吧！&lt;/p&gt;
&lt;p&gt;七、如果你能学习一些搜索引擎技术，人工智能技术，并进行简单的实践（这时候Linux虚拟机就派上用场了），那就是锦上添花了。&lt;/p&gt;
&lt;p&gt;八、如果你想从事手机app开发，做个微信小程序，做个一点按钮，就弹窗hello world！对话框的安卓apk安装包，应该是必须的了吧。&lt;/p&gt;
</description>
<pubDate>Mon, 05 Oct 2020 00:42:00 +0000</pubDate>
<dc:creator>天下技术</dc:creator>
<og:description>计算机专业学生做到这些，轻松超过50%同学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mysqlcskdpl/p/13769294.html</dc:identifier>
</item>
<item>
<title>IdentityServer4系列 | 初识基础知识点 - 艾三元</title>
<link>http://www.cnblogs.com/i3yuan/p/13768815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/i3yuan/p/13768815.html</guid>
<description>&lt;p&gt;我们现在日常生活中，会使用各式各样的应用程序，层出不穷，其中有基于网页浏览方式的应用，有基于手机端的App，甚至有基于流行的公众号和小程序等等，这些应用，我们不仅要实现各个应用的功能之外，还要考虑各个应用之间的交互作用，其中身份的认证和授权就是每个应用必不可少的的一部分。&lt;/p&gt;
&lt;p&gt;所以我们以身份认证和授权这一部分为例，需要考虑各个应用直接的交互，统一管理以及信息安全问题。&lt;/p&gt;
&lt;p&gt;而现在的互联网，对于信息安全要求又十分苛刻，所以一套统一的身份认证和授权就至关重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231601497-1611168987.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们可以根据&lt;code&gt;Identity Server4&lt;/code&gt;框架开发一套统一的身份认证和授权项目应用在平时的多个项目中，实现多平台应用授权统一管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231430447-1977709387.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们通过查看 &lt;a href=&quot;https://identityserver4.readthedocs.io/en/latest/&quot;&gt;IdentityServer4&lt;/a&gt;官网，就可以看到给出的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markdown&quot;&gt;IdentityServer4 is an OpenID Connect and OAuth 2.0 framework for ASP.NET Core.
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;OpenID Connect + OAuth2.0 相结合的认证框架&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由此可见，IdentityServer是基于OpenID Connect协议标准的身份认证和授权程序，实现了OpenID Connect和OAuth2.0协议的结合。&lt;/p&gt;
&lt;p&gt;所以，IdentityServer4是为ASP.NET CORE量身定制的实现了OpenId Connect和OAuth2.0协议的认证授权中间件。通常，你构建（或重新使用）包含登录和注销页面的应用程序，IdentityServer中间件会向其添加必要的协议头，以便客户端应用程序可以使用这些标准协议与其对话。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231555497-1513467258.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;21-特性&quot;&gt;2.1 特性&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231504842-1237811853.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过不同的文献使用的术语我们会发现，同一个概念可能存在着多种解释，比如有些把他称为安全令牌服务（Security Token Service），&lt;br/&gt;身份提供（Identity Provider），授权服务器（Authorization Server），IP-STS 等等。其实他们都是一个意思，目的都是在软件应用中为客户端颁发令牌并用于安全访问的。&lt;/p&gt;
&lt;h2 id=&quot;22-功能&quot;&gt;2.2 功能&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231511802-2052102664.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-oauth20&quot;&gt;3.1 OAuth2.0&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;OAuth2.0&lt;/strong&gt; 是OAuth协议的延续，&lt;strong&gt;OAuth2.0&lt;/strong&gt; 关注客户端开发者的简易性，为用户资源提供一个安全的、开放而有建议的标准。是目前流行的授权机制，用于授权第三方应用就可以获取该用户资源。因此OAuth是安全的。&lt;/p&gt;
&lt;p&gt;为了安全，Oauth2.0 引入了两个措施：&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;　　1，Oauth2.0 要求，refresh token 一定是保存在客户端的服务器上的，而绝不能存放在狭义的客户端（例如移动 app、PC端软件） 上。调用 refresh 接口的时候，一定是从服务器到服务器的访问；&lt;/p&gt;
&lt;p&gt;　　2，Oauth2.0 引入了 client_secret 机制。即每一个 client_id 都对应一个 client_secret。这个 client_secret 会在客户端申请 client_id 时，随 client_id 一起分配给客户端。客户端必须把 client_secret 妥善保管在服务器上，决不能泄露。刷新 access token 时，需要验证这个 client_secret。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;311-场景&quot;&gt;3.1.1 场景&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;OAuth2.0&lt;/strong&gt; 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。&lt;/p&gt;
&lt;p&gt;（以下以 第三方A网站用户访问授权获取在B网站资源 为例 。参考：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&quot;&gt;理解OAuth 2.0&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;为了让A网站应用访问在B网站上的存储的照片、视频或者联系方式等等私密资源，我们可能需要做到的就是让B网站同意A网站访问读取这些资源，那么，在传统的方式中，会将自己在B网站中的用户名和密码告诉A，后者就可以读取用户的资源信息了，但是这样做存在了严重的问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;A网站为了后续服务，会保存用户的密码，这样不安全。&lt;/li&gt;
&lt;li&gt;B网站必须部署密码登录方式，才能以此方式获取，但这种单纯的密码登录也不安全。&lt;/li&gt;
&lt;li&gt;A网站用户获取某个网站资源的权力，但却没有限制获取的范围和期限。&lt;/li&gt;
&lt;li&gt;当用户修改密码的时候，就会收回A网站的权力，但是这样做，会使得其他所有获得用户授权的A应用程序全部失效。&lt;/li&gt;
&lt;li&gt;只要有一个A应用程序被破解，就会导致用户密码泄漏，以及所有被密码保护的数据泄漏。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，这种方式是不安全的，所以为了解决这种问题，&lt;strong&gt;OAuth&lt;/strong&gt;就解决了这种问题。&lt;/p&gt;
&lt;p&gt;允许用户让第三方A应用访问该用户在B网站上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。就比如我用QQ登录博客园，那博客园（第三方应用）的昵称就可以是我的QQ（某网站）昵称，它获取到了我的QQ昵称，并存到了博客园的数据库，我以后就一直可以使用QQ来登录博客园，但是博客园却不知道我QQ的用户名和密码。&lt;/p&gt;
&lt;h3 id=&quot;312-说明&quot;&gt;3.1.2 说明&lt;/h3&gt;
&lt;p&gt;OAuth在&quot;客户端&quot;与&quot;服务提供商&quot;之间，设置了一个授权层（authorization layer）。&quot;客户端&quot;不能直接登录&quot;服务提供商&quot;，只能登录授权层，以此将用户与客户端区分开来。&quot;客户端&quot;登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。&lt;/p&gt;
&lt;p&gt;&quot;客户端&quot;登录授权层以后，&quot;服务提供商&quot;根据令牌的权限范围和有效期，向&quot;客户端&quot;开放用户储存的资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004232147717-129403731.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（A）用户打开客户端以后，客户端要求用户给予授权。&lt;br/&gt;（B）用户同意给予客户端授权。&lt;br/&gt;（C）客户端使用上一步获得的授权，向认证服务器申请令牌。&lt;br/&gt;（D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。&lt;br/&gt;（E）客户端使用令牌，向资源服务器申请获取资源。&lt;br/&gt;（F）资源服务器确认令牌无误，同意向客户端开放资源。&lt;/p&gt;
&lt;h3 id=&quot;313-模式&quot;&gt;3.1.3 模式&lt;/h3&gt;
&lt;p&gt;用户怎样实现客户端授权，所以需要通过不同的授权模式让客户端可以获取令牌，进而获取资源。因此，客户端获取授权常用的模式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231517808-917889351.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;后续篇章会对这些模式进行说明和搭建应用项目。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;32-openid-connect&quot;&gt;3.2 OpenID Connect&lt;/h2&gt;
&lt;p&gt;OpenID Connect是基于OAuth 2.0规范族的可互操作的身份验证协议。它使用简单的REST / JSON消息流来实现，和之前任何一种身份认证协议相比，开发者可以轻松集成。&lt;/p&gt;
&lt;p&gt;OpenID Connect允许开发者验证跨网站和应用的用户，而无需拥有和管理密码文件。&lt;/p&gt;
&lt;p&gt;OpenID Connect允许所有类型的客户,包括基于浏览器的&lt;a href=&quot;https://link.jianshu.com?t=http://lib.csdn.net/base/javascript&quot;&gt;JavaScript&lt;/a&gt;和本机移动应用程序,启动登录流动和接收可验证断言对登录用户的身份。&lt;/p&gt;
&lt;p&gt;进一步来说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;OpenID Connect是OAuth 2.0协议之上的简单身份层，用 API 进行身份交互的框架，允许&lt;strong&gt;客户端根据授权服务器的认证结果最终确认用户的身份，以及获取基本的用户信息&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;它支持包括Web、移动、JavaScript在内的所有客户端类型；&lt;/li&gt;
&lt;li&gt;它是可扩展的协议，允许你使用某些可选功能，如身份数据加密、OpenID提供商发现、会话管理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OpenID Connect vs OpenID 2.0：OpenID Connect完成很多与OpenID 2.0（即认证，对用户的身份进行认证，判断其身份是否有效）相同的任务，是API-friendly，定义了可选的签名和加密的机制；&lt;/p&gt;
&lt;p&gt;OAuth 1.0和OpenID 2.0的集成需要扩展，而OpenID Connect协议本身就建立在OAuth 2.0之上。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;(身份验证)+ OAuth 2.0 = OpenID Connect&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，&lt;strong&gt;OpenID Connect 是“认证”和“授权”的结合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231540827-279634019.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;我们经常会混淆OpenID和OAuth协议之间的关系，下文会对这两者进行区分说明。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么开发者要使用OpenID Connect？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;因为它很简单,可靠,安全,并让他们摆脱困难和危险的存储和管理别人的密码。也有好处,它让用户的生活更容易在网站注册和注册从而减少遗弃。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;41-oauth-与-openid&quot;&gt;4.1 OAuth 与 OpenID&lt;/h2&gt;
&lt;p&gt;首先，来认识两个英文单词，也是我们在平时中很容易混淆的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;authorization&lt;/strong&gt; : n. 授权，认可；批准，委任。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;authentication&lt;/strong&gt; : n. 证明；鉴定；证实。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而在认证授权服务中，也应用了这两个单词的表面意思。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;OpenID 是一个&lt;strong&gt;以用户为中心的数字身份识别框架&lt;/strong&gt;，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的身份认证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;OpenID ：&lt;/strong&gt; 是&lt;em&gt;Authentication&lt;/em&gt;，即认证，对用户的身份进行认证，判断其身份是否有效，也就是让网站知道“你是你所声称的那个用户”。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;侧重的是authentication： 即证明 “用户是谁？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;OAuth ：&lt;/strong&gt; 是&lt;em&gt;Authorization&lt;/em&gt;，即授权，在已知用户身份合法的情况下，经用户授权来允许某些操作，也就是让网站知道“你能被允许做那些事情”。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;侧重的是authorization ：即授权 “用户能做什么？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由此可知，授权要在认证之后进行，只有确定用户身份只有才能授权。&lt;/p&gt;
&lt;h3 id=&quot;411-场景&quot;&gt;4.1.1 场景&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;OpenID&lt;/strong&gt; 是证实身份（Authentication）作用的，就好比我们参加大型考试一下，进考场的时候，监考官需要我们拿出身份证和准考证来检验，比对是否是同一个人。这个过程就是在验证 “身份，这就是我”，同时也证实了这不是一个匿名伪造的不可信任信息。考官比对身份成功后，就会进一步询问。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;比如我用 Google 的 OpenID 服务登录 xxx.com ， xxx.com 先把我导向 Google 的授权页面，我使用 Google 帐号 test@gmail.com 登录并同意后，页面跳回 xxx.com ， xxx.com 拿到了我的“唯一标识”，这个唯一标识可能是 abbcccxxxxxxxddccddxxxx11 ，xxx.com 从这个字符串里无法获得任何 xxx@gmail.com 的个人信息（甚至连邮箱地址也不知道）， xxx.com 只知道以后只要使用谷歌登录并返回 abbcccxxxxxxxddccddxxxx11 这个标识符，那就是我在登录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;但是如果你想在认证过程中获得用户的其他信息（比如手机号等 ）就得多做一步了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OAuth&lt;/strong&gt; 是关于授权、许可（Authorization）的，当考官看完比对你的身份后，还要求掏出兜里的东西，拿出随身携带里的东西、手机等随身物品以便检查，检查你是否携带考场违规物品，这时就需要得到被检查人的许可才行，被检查人有权利扭头就走，但要想进场考试，必须给予许可、配合检查。这是在回答「我同意让你对我进一步做些什么」，是为了在被授予权限的前提下，更多的获取除了个人信息以外，身上携带的东西是否包含违规物品。（如：手机，计算器，手表，非指定文具等）&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我想通过微博登录 xxx.com ，xxx.com 要先把我 redirect 到新浪微博的授权页面，我通过微博帐号登录并授权后，页面跳回 xxx.com ，xxx.com 拿到我的访问 token 后还要再调用一个接口来获得我的会员 UID ，这个 UID 就是新浪用户的“唯一标识”了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markdown&quot;&gt;  # 借鉴网友的说明： 
   如今越来越多的网站，以及一些应用程序都开始使用第三方社交平台账户登录，那这里就会涉及到安全性的问题，隐私的问题，你不能随意来获取我的资料，当然你来使用我的资料，你要经过用户的同意，那这个用户是不是我平台上，还是要来向我求证，那在这个过程中，实际上就出现了两个过程，我们还是直接使用上次的例子来说明，比较直观，博客园使用QQ登录，进入博客园的登录页，点击使用QQ登录：

    在进入到QQ登录界面后，最开始是要请求认证，用户输入QQ号和密码，点击登录，腾讯互联会先进行验证该用户是否为我的用户，如果是我的用户，那么我会通知你（博客园），他是我的用户，你可以使用该账户登录你的系统，这个过程就是认证（Authentication），认证就是证明你是谁，你是否是真实存在的，就好像，快递员来给你送快递，让你出示你的身份证，他确定你是本人后，把快递给你，这就是OpenID。

   而在QQ授权登录下方，有两给CheckBox复选框，可以允许博客园获得您的昵称、头像、性别，这是在认证之后的事了，在腾讯互联你是我平台的用户后，你可以自己选择博客园是否有权去获取你的相关信息，当你勾选后，腾讯互联就把你的这些基本信息给了博客园，这个过程就是授权（Authorization），授权就是确定了你是谁后，又把属于你的东西给了别人，犹如你向快递员出示了身份证，然后你又把你房门的密码给了他，并告诉他说，我把房门密码给你，你帮我放到我客厅里吧。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231533322-1182520118.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，&lt;strong&gt;OAuth 相对于 OpenID 最大的区别就是&lt;/strong&gt;，网站在认证授权的过程中实际上是拿到了你的帐户访问权限继而确认你的身份，但是这同时也存在一个安全隐患，因为网站在拿到你的“唯一标识”的同时还拿到了一把你的账户的 “临时钥匙”。但是你不知道网站会不会拿这把钥匙“干坏事”，这个只有站长心里清楚。同时 OAuth 还比 OpenID 多了几个额外的请求步骤，登录所费时间一定是长于 OpenID 的。&lt;/p&gt;
&lt;h2 id=&quot;42--oauth、openid-与-openid-connect&quot;&gt;4.2 OAuth、OpenID 与 OpenID Connect&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231450112-1259674324.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OpenID Connect&lt;/strong&gt; 因为其基于&lt;em&gt;OAuth&lt;/em&gt;协议（可以看上文OAuth说明），所以&lt;em&gt;OpenID-Connect&lt;/em&gt;协议中也包含了&lt;strong&gt;client_id&lt;/strong&gt;、&lt;strong&gt;client_secret&lt;/strong&gt;还有&lt;strong&gt;redirect_uri&lt;/strong&gt;等字段标识。这些信息被保存在“身份认证服务器”，以确保特定的客户端收到的信息只来自于合法的应用平台。这样做是目的是为了防止&lt;em&gt;client_id&lt;/em&gt;泄露而造成的恶意网站发起的&lt;em&gt;OIDC&lt;/em&gt;流程。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;OpenID Connect完成很多与OpenID 2.0 相同的任务，是API-friendly，定义了可选的签名和加密的机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;OAuth 1.0 和 OpenID 2.0 的集成需要扩展，而OpenID Connect协议本身就建立在OAuth 2.0之上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，&lt;strong&gt;OpenID Connect 是“认证”和“授权”的结合。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;(身份验证)+ OAuth 2.0 = OpenID Connect (OIDC) = ( Authentication + Authorization + OAuth2.0)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简要而言，&lt;em&gt;OIDC&lt;/em&gt;是一种安全机制，用于应用连接到身份认证服务器（Identity Service）获取用户信息，并将这些信息以安全可靠的方法返回给应用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markdown&quot;&gt;# 借鉴网友说明
举个例子。某个用户使用*Facebook*应用*“What online quiz best describes you?”* ，该应用可以通过*Facebook*账号登录，则你可以在应用中发起请求到“身份认证服务器”（也就是Facebook的服务器）请求登录。这时你会看到界面，询问是否授权。

 在 OAuth 中，这些授权被称为scope。OpenID-Connect也有自己特殊的scope--openid ,它必须在第一次请求“身份鉴别服务器”（Identity Provider,简称IDP）时发送过去。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202010/1576550-20201004231420517-548646317.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;43-jwt-与-oauth2-0&quot;&gt;4.3 JWT 与 OAuth2 .0&lt;/h2&gt;
&lt;p&gt;要比较JWT和OAuth2，首先要明白一点就是，这两个根本没有可比性，是两个完全不同的东西。&lt;/p&gt;
&lt;p&gt;但是既然是没有可比性，为何还要放一块比较呢？实际开发应用中，就发现很多拿 JWT和OAuth2.0 作对比，很多情况下，在讨论OAuth2的实现时，会把JSON Web Token作为一种认证机制使用。这也是为什么他们会经常一起出现。&lt;/p&gt;
&lt;h3 id=&quot;431-内容区别&quot;&gt;4.3.1 内容区别&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;JWT是一种认证协议&lt;br/&gt;JWT提供了一种用于发布接入&lt;strong&gt;令牌&lt;/strong&gt;（Access Token)，并对发布的签名接入令牌进行验证的方法。 令牌（Token）本身包含了一系列声明，应用程序可以根据这些声明限制用户对资源的访问。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一个token包含三部分：&lt;strong&gt;header&lt;/strong&gt;、&lt;strong&gt;claims&lt;/strong&gt;、&lt;strong&gt;signature&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;OAuth2是一种安全的授权框架&lt;/p&gt;
&lt;p&gt;提供了一套详细的授权机制。用户或应用可以通过公开的或私有的&lt;strong&gt;设置&lt;/strong&gt;，授权&lt;strong&gt;第三方应用访问特定资源&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Oauth2定义了一组想当复杂的规范。涉及到：Roles角色、Client Types客户端类型、Client Profile客户端描述、Authorization Grants认证授权、Endpoints终端等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;432-场景区别&quot;&gt;4.3.2 场景区别&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;JWT的主要优势在于使用无状态、可扩展的方式处理应用中的用户会话。服务端可以通过内嵌编码的声明信息，很容易地获取用户的会话信息，而不需要去访问用户或会话的数据库。但是，如果系统中需要使用黑名单实现长期有效的token刷新机制，这种无状态的优势就不明显了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;API的使用依赖于外部的第三方认证提供者。去认证服务商 那里注册你的应用，然后设置需要访问的用户信息，比如电子邮箱、姓名等。当用户访问站点的注册页面时，会看到连接到第三方认证提供商的入口。用户点击以后被重定向到对应的认证服务商网站，获得用户的授权后就可以访问到需要的信息，然后重定向回来你的应用中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;433-归纳说明&quot;&gt;4.3.3 归纳说明&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Oauth2和JWT是完全不同的两种东西，一个是授权认证的框架，另一种则是认证验证的方式方法。OAuth2不像JWT一样是一个严格的标准协议，因此在实施过程中更容易出错。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;两种方案都需要SSL安全保护，也就是对要传输的数据进行加密编码。安全地传输用户提供的私密信息，在任何一个安全的系统里都是必要的。否则任何人都可以通过侵入网络，在用户登录的时候窃取用户的用户名和密码等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;&lt;li&gt;本篇主要是对&lt;strong&gt;Identity Server4&lt;/strong&gt;的说明，认识到是一个基于OpenID Connect协议标准的身份认证和授权程序。&lt;/li&gt;
&lt;li&gt;简单的涉及对基础知识的认识以及区别说明，从OAuth、OpenID、OpenID Connect以及JWT等进行对比区别说明。&lt;/li&gt;
&lt;li&gt;在后续中会对&lt;strong&gt;Identity Server4&lt;/strong&gt;中常用术语说明，多种授权模式，数据库持久化以及UI界面优化和常见问题，搭建一个完整可用的认证授权项目。&lt;/li&gt;
&lt;li&gt;如果有不对的或不理解的地方，希望大家可以多多指正，提出问题，一起讨论,不断学习,共同进步。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://docs.identityserver.io/en/release/index.html&quot;&gt;Identity Server 官方文档&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://jwt.io/introduction/&quot;&gt;JSON Web Token&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&quot;&gt;理解OAuth 2.0&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://docs.identityserver.io/en/release/topics/grant_types.html&quot;&gt;Identity Server 授权类型&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 05 Oct 2020 00:01:00 +0000</pubDate>
<dc:creator>艾三元</dc:creator>
<og:description>前言 我们现在日常生活中，会使用各式各样的应用程序，层出不穷，其中有基于网页浏览方式的应用，有基于手机端的App，甚至有基于流行的公众号和小程序等等，这些应用，我们不仅要实现各个应用的功能之外，还要考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/i3yuan/p/13768815.html</dc:identifier>
</item>
<item>
<title>走进shiro，构建安全的应用程序---shiro修仙序章 - code81192</title>
<link>http://www.cnblogs.com/bingfengdev/p/13768813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bingfengdev/p/13768813.html</guid>
<description>&lt;h2 id=&quot;0-写在前面&quot;&gt;0. 写在前面&lt;/h2&gt;
&lt;p&gt;在最近的一个项目当中，我们基于Shiro实现我们系统的认证和授权。借此机会，写几篇博客，总结一下在本次实践当中遇到的问题，和较全面地学习一下Shiro的知识点，&lt;/p&gt;
&lt;h2 id=&quot;1-权限管理&quot;&gt;1. 权限管理&lt;/h2&gt;
&lt;p&gt;权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户访问而且只能访问授权访问的资源。&lt;/p&gt;
&lt;p&gt;权限管理主要分为两个部分，一是身份认证（authentication），二是授权（authorization）。&lt;/p&gt;
&lt;h2 id=&quot;2-实现方案与模型&quot;&gt;2. 实现方案与模型&lt;/h2&gt;
&lt;p&gt;目前主流的解决方案spring security+JWT或者Shiro+JWT方案。当然也有相关团队（公司）是自己编写过滤器进行访问控制。但这并不值得推荐，除非你设计的权限管理方案能经得起生产环境的考验。&lt;/p&gt;
&lt;p&gt;如果大家需要了解关于spring security的相关内容，可以阅读我spring security的相关文章。&lt;/p&gt;
&lt;p&gt;权限管理模型的话，主要有这么几种：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;自主访问控制(DAC: Discretionary Access Control)。一个典型的例子就是windows操作系统的权限管理。DAC 最大的缺陷就是对权限控制比较分散，不便于管理，比如说简单地对一组文件设置统一的权限并授予指定的一组用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;强制访问控制模型(MAC: Mandatory Access Control)。MAC为了弥补DAC而生，MAC给用户和资源分别数字化标记其权限等级。当用户访问某一资源时，只有它的权限等级高于或等于资源的权限等级时，才能访问，否则拒绝访问。比如存在某一资源404.MP4，资源等级为1024.存在用户Ferrayman，其权限等级为256，存在用户boss，其权限等级为2048.那么，boss就能正常访问资源404.MP4，而Ferrayman则无权访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;基于角色的访问控制模型(RBAC: Role-based Access Control)，即给用户分配角色，角色下对应一定的资源，用户对其角色下的资源具有访问权限。RBAC细分为RBAC0、RBAC1、RBAC2、RBAC3几个版本。&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;我们主要采用的也是RBAC模型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;3-shiro是什么？&quot;&gt;3. Shiro是什么？&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;Apache Shiro™ is a powerful and easy-to-use Java security framework that performs 
authentication, authorization, cryptography, and session management. With Shiro’s 
easy-to-understand API, you can quickly and easily secure any application – from the 
smallest mobile applications to the largest web and enterprise applications.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API,您可以快速、轻松地获得任何应用程序,从最小的移动应用程序到最大的网络和企业应用程序。&lt;/p&gt;
&lt;h3 id=&quot;31-shiro组成&quot;&gt;3.1 Shiro组成&lt;/h3&gt;
&lt;p&gt;Shiro三大组件：Subject, SecurityManager 和 Realms.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2129357/202010/2129357-20201004232424141-434960604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;311-subject：&quot;&gt;3.1.1 Subject：&lt;/h4&gt;
&lt;p&gt;即“当前主体”。在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。&lt;/p&gt;
&lt;p&gt;它主要由身份信息Principal和凭证Principals组成。Principal可以理解为主体在系统中的账号，且是具有唯一性的。Principals可以理解为主体在当前系统账户所对应的密码、证书。&lt;/p&gt;
&lt;h4 id=&quot;312-securitymanager：&quot;&gt;3.1.2 SecurityManager：&lt;/h4&gt;
&lt;p&gt;它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。&lt;/p&gt;
&lt;h4 id=&quot;313-realm：&quot;&gt;3.1.3 Realm：&lt;/h4&gt;
&lt;p&gt;Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。&lt;/p&gt;
&lt;p&gt;从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。&lt;/p&gt;
&lt;p&gt;Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。&lt;/p&gt;
&lt;h2 id=&quot;4-shiro的优势&quot;&gt;4 Shiro的优势&lt;/h2&gt;
&lt;p&gt;简单、灵活。&lt;/p&gt;
&lt;p&gt;使用起来相对于spring security简单。不仅支持Web应用也支持非Web应用，无缝集成。&lt;/p&gt;
&lt;h2 id=&quot;5-一个demo&quot;&gt;5 一个Demo&lt;/h2&gt;
&lt;h3 id=&quot;创建一个空的maven工程并引入如下依赖&quot;&gt;创建一个空的maven工程并引入如下依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;shiro-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.5.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!--方便测试--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
     &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;引入shiro的配置文件&quot;&gt;引入shiro的配置文件&lt;/h3&gt;
&lt;p&gt;shiro的配置文件是以“.ini”结尾的文件。之所以使用.ini格式，是因为该文件类型支持比较复杂的数据格式。主要用来存储shiro的一些权限数据。这个主要是拿来学习shiro用的，平时项目中，权限数据存储于数据库中。&lt;/p&gt;
&lt;p&gt;配置主体的身份信息和凭证&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ini&quot;&gt;[users]
xiangbei=123
xiangname=123
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建认证器&quot;&gt;创建认证器&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package pers.lbf.shirodemo.core;

import org.apache.shiro.SecurityUtils;
import org.apache.shiro.authc.*;
import org.apache.shiro.mgt.DefaultSecurityManager;
import org.apache.shiro.realm.text.IniRealm;
import org.apache.shiro.subject.Subject;

/**认证器
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/9/21 0:50
 */
public class Authenticator {

    private DefaultSecurityManager securityManager;

    public Authenticator(){
        //1. 创建安全管理器
        this.securityManager = new DefaultSecurityManager();

        //2. 给安全管理器设置问题域
        //因为权限信息从ini文件中读取，所以是IniRealm
        this.securityManager.setRealm(new IniRealm(&quot;classpath:shiro.ini&quot;));

        //3. 注入安全管理器，并使用SecurityUtils全局安全工具类完成认证
        SecurityUtils.setSecurityManager(securityManager);



    }

    /**认证
     * @author 赖柄沣 bingfengdev@aliyun.com
     * @date 2020-09-23 16:22:11
     * @param username 用户名
     * @param password 密码
     * @return void
     * @version 1.0
     */
    public void authenticate(String username,String password){
        //4. 获取当前主题
        Subject subject = SecurityUtils.getSubject();

        //5.根据登录对象身份凭证信息创建登录令牌
        UsernamePasswordToken token = new UsernamePasswordToken(username,password);

        //6.认证
        //如果认证通过，则不抛出异常，否则抛出AuthenticationExceptixon异常子类
        //正式项目建议直接抛出，统一异常处理
        try {
            subject.login(token);
        }catch (IncorrectCredentialsException e) {
            e.printStackTrace();
        }catch (ConcurrentAccessException e){
            e.printStackTrace();
        }catch (UnknownAccountException e){
            e.printStackTrace();
        }catch (ExcessiveAttemptsException e){
            e.printStackTrace();
        }catch (ExpiredCredentialsException e){
            e.printStackTrace();
        }catch (LockedAccountException e){
            e.printStackTrace();
        }

    }


}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试，模拟认证&quot;&gt;测试，模拟认证&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package shirodemo;

import org.apache.shiro.SecurityUtils;
import org.apache.shiro.subject.Subject;
import org.junit.Before;
import org.junit.Test;
import pers.lbf.shirodemo.core.Authenticator;

/**测试认证
 * @author 赖柄沣 bingfengdev@aliyun.com
 * @version 1.0
 * @date 2020/9/21 0:49
 */

public class TestAuthenticator {
    private  Authenticator authenticator=null;

    @Before
    public void init() {
        authenticator = new Authenticator();
    }

    @Test
    public void testAuth(){

        authenticator.authenticate(&quot;xiangbei&quot;,&quot;123&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;6-写在最后&quot;&gt;6 写在最后&lt;/h2&gt;
&lt;p&gt;今天，我们主要通过一个简单的demo，去开始学习shiro的相关知识。但这些知识还不足以让我们应用到我们的产品中去，接下来的shiro系列修仙功法(文章)，作者将跟着大家一起去学习shiro的应用。&lt;/p&gt;
</description>
<pubDate>Sun, 04 Oct 2020 15:25:00 +0000</pubDate>
<dc:creator>code81192</dc:creator>
<og:description>shiro系列的序章，简单介绍一下shiro。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bingfengdev/p/13768813.html</dc:identifier>
</item>
<item>
<title>ECharts系列:玩转ECharts之常用图（折线、柱状、饼状、散点、关系、树） - IT技术派</title>
<link>http://www.cnblogs.com/vic-tory/p/13768626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vic-tory/p/13768626.html</guid>
<description>&lt;h2&gt;一.背景&lt;/h2&gt;
&lt;p&gt;最近产品叫我做一些集团系列的统计图，包括集团组织、协作、销售、采购等方面的。作为一名后端程序员，于是趁此机会来研究研究这个库。&lt;/p&gt;
&lt;p&gt;如果你仅仅停留在用的层面，那还是蛮简单的。&lt;/p&gt;
&lt;h2&gt;二.介绍&lt;/h2&gt;
&lt;p&gt;ECharts，缩写来自Enterprise Charts，商业级数据图表，它最初是为了满足&lt;abbr title=&quot;百度&quot;&gt;公司&lt;/abbr&gt;商业体系里各种业务系统（如凤巢、广告管家等等）的报表需求。以前这些系统的图表需求我们都是使用flash去实现的，百度分工很细，有专门的flash组同学去做这个事情，这就不可避免多了一个沟通环节，作为前端工程师无法独立掌控，不管是数据接口的设计，个性化的需求都得沟通商定。而且一个系统内会有很多个flash在不同场景下出现，他们并没有实现通用。加上乔帮主不让i系列上运行flash以及html5的火热，我们需要寻求一个解决方案。于是在2012年初，当时还是凤巢前端技术负责人的&lt;a href=&quot;http://weibo.com/kenerlinfeng&quot; target=&quot;_blank&quot;&gt;Kener-林峰&lt;/a&gt;在凤巢数据平台项目中尝试使用Canvas去做图表，他写了一个全新的轻量级Canvas类库ZRender，那可以说是ECharts的原型，虽然跟现在已经相去十万八千里了。&lt;/p&gt;
&lt;p&gt;更多详细的自己百度&lt;/p&gt;
&lt;h2&gt;三.使用&lt;/h2&gt;
&lt;p&gt;当拿到一到框架或者一个需求的时候，不要着急动手，先看文档或者理解需求&lt;/p&gt;
&lt;p&gt;五分钟上手文档：&lt;a href=&quot;https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts&quot; target=&quot;_blank&quot;&gt;https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width: 600px;height:400px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.jsdelivr.net/npm/echarts@4.9.0/dist/echarts.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于准备好的dom，初始化echarts实例&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; myChart &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; echarts.init(document.getElementById(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定图表的配置项和数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; option &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
                title: {
                    text: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ECharts 入门示例&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                },
                tooltip: {},
                legend: {
                    data: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;销量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                },
                xAxis: {
                    data: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;衬衫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;羊毛衫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;雪纺衫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;裤子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;高跟鞋&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;袜子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
                },
                yAxis: {},
                series: [{
                    name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;销量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    data: [&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;36&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;20&lt;/span&gt;&lt;span&gt;]
                }]
            };

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用刚指定的配置项和数据显示图表。&lt;/span&gt;
&lt;span&gt;            myChart.setOption(option);
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699002/202010/1699002-20201004215031991-580985893.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四.重要的配置项和属性&lt;/h2&gt;
&lt;p&gt;tooltip:提示框组件&lt;/p&gt;
&lt;p&gt;legend:图例组件,展现了不同系列的标记(symbol)，颜色和名字。可以通过点击图例控制哪些系列不显示。&lt;/p&gt;
&lt;p&gt;xAxis:直角坐标系 grid 中的 x 轴，一般情况下单个 grid 组件最多只能放上下两个 x 轴，多于两个 x 轴需要通过配置 &lt;a href=&quot;https://echarts.apache.org/zh/option.html#xAxis.offset&quot;&gt;offset&lt;/a&gt; 属性防止同个位置多个 x 轴的重叠。&lt;/p&gt;
&lt;p&gt;yAxis:直角坐标系 grid 中的 y 轴，一般情况下单个 grid 组件最多只能放左右两个 y 轴，多于两个 y 轴需要通过配置 &lt;a href=&quot;https://echarts.apache.org/zh/option.html#yAxis.offset&quot;&gt;offset&lt;/a&gt; 属性防止同个位置多个 Y 轴的重叠。&lt;/p&gt;
&lt;p&gt;series:系列列表。每个系列通过 &lt;code class=&quot;codespan&quot;&gt;type&lt;/code&gt; 决定自己的图表类型&lt;/p&gt;
&lt;p&gt;formatter：显示的格式器&lt;/p&gt;
&lt;p&gt;取个例子：我们公司一个统计集团下的供应商发布的产品和本公司发布在同行的产品，要用echarts的正负柱状图，如何去实现正数显示在柱子上面，负数显示在柱子下面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;main&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;width: 600px; height: 400px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;https://cdn.jsdelivr.net/npm/echarts@4.9.0/dist/echarts.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;            
            &lt;span&gt;var&lt;/span&gt;&lt;span&gt; myChart &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; echarts.init(document.querySelector(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#main&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; option &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
                tooltip: {
                    trigger: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;axis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    axisPointer: { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 坐标轴指示器，坐标轴触发有效&lt;/span&gt;
&lt;span&gt;                        type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shadow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认为直线，可选为：'line' | 'shadow'&lt;/span&gt;
&lt;span&gt;                    },
                     formatter: (params) &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;!&lt;/span&gt;&lt;span&gt;params.length) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;''&lt;/span&gt;&lt;span&gt;
                        let s &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; params[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].axisValueLabel &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
                        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (const iterator of params) {
                           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是负数则反转&lt;/span&gt;
&lt;span&gt;                          let d &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; iterator.data &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;?&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;iterator.data : iterator.data
                          s &lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt; iterator.marker &lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt; iterator.seriesName &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; d  &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
                        }
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; s
                      }
                },
                legend: {
                    data: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;准入在售产品数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发布在售产品数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                },
                grid: {
                    left: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    right: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    bottom: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;3%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    containLabel: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                },
                xAxis: [{
                    type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                     axisLabel: {
                             formatter: (value) &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
                            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 负数取反 显示的就是正数了&lt;/span&gt;
                               &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (value &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;value
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;return&lt;/span&gt;&lt;span&gt; value
                             }
                        }
                }],
                yAxis: [{
                    type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;category&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                    axisTick: {
                        show: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
                    },
                    data: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;公司1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;公司2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;公司2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
                }],
                series: [
                    {
                        name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;准入在售产品数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        stack: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;总量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        label: {
                            show: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
                        },
                        data: [&lt;/span&gt;&lt;span&gt;320&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;302&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;341&lt;/span&gt;&lt;span&gt;]
                    },
                    {
                        name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发布在售产品数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        type: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;bar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        stack: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;总量&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                        label: {
                            show: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                            position: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;left&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                            formatter: (value) &lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt; {
                                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 值都是负数的 所以需要取反一下&lt;/span&gt;
                                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;span&gt;value.data
                                   }
                        },
                        data: [&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;&lt;span&gt;]
                    }
                ]
            };
            
            myChart.setOption(option);
        &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1699002/202010/1699002-20201004223255896-672171533.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 04 Oct 2020 14:16:00 +0000</pubDate>
<dc:creator>IT技术派</dc:creator>
<og:description>一.背景 最近产品叫我做一些集团系列的统计图，包括集团组织、协作、销售、采购等方面的。作为一名后端程序员，于是趁此机会来研究研究这个库。 如果你仅仅停留在用的层面，那还是蛮简单的。 二.介绍 ECha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vic-tory/p/13768626.html</dc:identifier>
</item>
<item>
<title>spring-boot-route（四）全局异常处理 - Java旅途</title>
<link>http://www.cnblogs.com/zhixie/p/13768583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/13768583.html</guid>
<description>&lt;p&gt;在开发中，我们经常会使用&lt;code&gt;try/catch块&lt;/code&gt;来捕获异常进行处理，如果有些代码中忘记捕获异常或者不可见的一些异常出现，就会响应给前端一些不友好的提示，这时候我们可以使用全局异常处理。这样就不用在代码中写那些烦人的&lt;code&gt;try/catch块了&lt;/code&gt;，代码的可读性也会提高。&lt;/p&gt;
&lt;p&gt;SpringBoot提供的的注解&lt;code&gt;@ControllerAdvice&lt;/code&gt;表示开启全局异常捕获，在自定义的异常方法上使用&lt;code&gt;ExceptionHandler&lt;/code&gt;来进行统一处理。&lt;/p&gt;
&lt;p&gt;下面一起看看如何优雅的处理全局异常！&lt;/p&gt;
&lt;h3 id=&quot;一-定义响应状态码及信息的枚举类&quot;&gt;一 定义响应状态码及信息的枚举类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Getter
public enum CodeEnum {
    
    SUCCESS(0,&quot;请求成功&quot;),
    ERROR(500,&quot;未知异常&quot;),
    ERROR_EMPTY_RESULT(1001,&quot;查询结果为空&quot;),
    ERROR_INCOMPLETE_RESULT(1002,&quot;请求参数不全&quot;);
    
    private int code;
    private String message;
    CodeEnum(int code,String message){
        this.code = code;
        this.message = message;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二-定义响应数据的实体类&quot;&gt;二 定义响应数据的实体类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Data
public class R&amp;lt;T&amp;gt; implements Serializable {

    private static final long serialVersionUID = 572235155491705152L;
    /**
     * 响应的状态码
     */
    private int code;
    /***
     * 响应的信息
     */
    private String message;
    /**
     * 响应数据
     */
    private T data;

    /**
     * 放入响应码并返回
     * @param code
     * @param msg
     * @return
     */
    public R fillCode(int code,String msg){
        this.code = code;
        this.message = msg;
        return this;
    }

    /**
     * 放入响应码并返回
     * @param codeEnum
     * @return
     */
    public R fillCode(CodeEnum codeEnum){
        this.code = codeEnum.getCode();
        this.message = codeEnum.getMessage();
        return this;
    }

    /**
     * 放入数据并响应成功状态
     * @param data
     * @return
     */
    public R fillData(T data){
        this.code = CodeEnum.SUCCESS.getCode();
        this.message = CodeEnum.SUCCESS.getMessage();
        this.data = data;
        return this;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三-自定义两个异常&quot;&gt;三 自定义两个异常&lt;/h3&gt;
&lt;p&gt;根据业务需求自定义异常，在本文中我定义了两个异常，分别用作响应结果为空时处理和请求参数错误时处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class EmptyResutlException extends RuntimeException {

    private static final long serialVersionUID = -8839210969758687047L;
    private int code;
    private String message;

    public EmptyResutlException(CodeEnum codeEnum){
        this.code = codeEnum.getCode();
        this.message = codeEnum.getMessage();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class RequestParamException extends RuntimeException {

    private static final long serialVersionUID = 4748844811214637041L;
    private int code;
    private String message;

    public RequestParamException(CodeEnum codeEnum){
        this.code = codeEnum.getCode();
        this.message = codeEnum.getMessage();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四-定义全局异常处理类&quot;&gt;四 定义全局异常处理类&lt;/h3&gt;
&lt;p&gt;由于这里我想要响应的结果为实体类对象，因此我直接用&lt;code&gt;@RestControllerAdvice&lt;/code&gt;来代替了&lt;code&gt;@ControllerAdvice&lt;/code&gt;，这两个注解的差别跟&lt;code&gt;@Controller&lt;/code&gt;和&lt;code&gt;@RestController&lt;/code&gt;一样，rest的响应体为json格式的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 查询结果为空时处理
     * @param e
     * @return
     */
    @ExceptionHandler(EmptyResutlException.class)
    public R emptyResultExceptionHandler(EmptyResutlException e){
        log.error(&quot;查询结果为空：{}&quot;,e.getMessage());
        R result = new R();
        result.fillCode(e.getCode(),e.getMessage());
        return result;
    }

    /**
     * 请求参数错误时处理
     * @param e
     * @return
     */
    @ExceptionHandler(RequestParamException.class)
    public R requestParamExceptionHandler(RequestParamException e){
        log.error(&quot;请求参数不合法：{}&quot;,e.getMessage());
        R result = new R();
        result.fillCode(e.getCode(),e.getMessage());
        return result;
    }

    /**
     * 处理其他异常
     * @param e
     * @return
     */
    @ExceptionHandler(Exception.class)
    public R exceptionHandler(Exception e){
        log.error(&quot;未知异常：{}&quot;,e.getMessage());
        R result = new R();
        result.fillCode(CodeEnum.ERROR);
        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;五-自定义接口测试异常&quot;&gt;五 自定义接口测试异常&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class TestController {

    @GetMapping(&quot;getString&quot;)
    public R getString(String name){

        if(StringUtils.isEmpty(name)){
            throw new RequestParamException(1002,&quot;请求参数name为空&quot;);
        }else if (&quot;Java旅途&quot;.equals(name)) {
            // 这里没有查询操作，当请求参数是Java旅途的时候，模拟成查询结果为空
            throw new EmptyResutlException(1001,&quot;查询结果为空&quot;);
        }
        // 这里模拟一下除自定义异常外的其他两种异常
        int i = 0;
        i = 5/i;
        return new R().fillData(name);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在实际开发中可以自定义响应状态码的枚举类和自定义异常以满足需求。&lt;/p&gt;
&lt;p&gt;此是spring-boot-route系列的第四篇文章，这个系列的文章都比较简单，主要目的就是为了帮助初次接触Spring Boot 的同学有一个系统的认识。本文已收录至我的&lt;a href=&quot;https://github.com/binzh303/spring-boot-route&quot;&gt;github&lt;/a&gt;，欢迎各位小伙伴&lt;code&gt;star&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;github&lt;/strong&gt;：&lt;a href=&quot;https://github.com/binzh303/spring-boot-route&quot;&gt;https://github.com/binzh303/spring-boot-route&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;点关注、不迷路&quot;&gt;点关注、不迷路&lt;/h2&gt;
&lt;p&gt;如果觉得文章不错，欢迎&lt;strong&gt;关注&lt;/strong&gt;、&lt;strong&gt;点赞&lt;/strong&gt;、&lt;strong&gt;收藏&lt;/strong&gt;，你们的支持是我创作的动力，感谢大家。&lt;/p&gt;
&lt;p&gt;如果文章写的有问题，请不要吝啬，欢迎留言指出，我会及时核查修改。&lt;/p&gt;
&lt;p&gt;如果你还想更加深入的了解我，可以微信搜索「&lt;strong&gt;Java旅途&lt;/strong&gt;」进行关注。回复「&lt;strong&gt;1024&lt;/strong&gt;」即可获得学习视频及精美电子书。每天7:30准时推送技术文章，让你的上班路不在孤独，而且每月还有送书活动，助你提升硬实力！&lt;/p&gt;
</description>
<pubDate>Sun, 04 Oct 2020 14:04:00 +0000</pubDate>
<dc:creator>Java旅途</dc:creator>
<og:description>在开发中，我们经常会使用try/catch块来捕获异常进行处理，如果有些代码中忘记捕获异常或者不可见的一些异常出现，就会响应给前端一些不友好的提示，这时候我们可以使用全局异常处理。这样就不用在代码中写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/13768583.html</dc:identifier>
</item>
<item>
<title>深入解读 ASP.NET Core 身份认证过程 - 有态度的小码甲</title>
<link>http://www.cnblogs.com/JulianHuang/p/13766100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JulianHuang/p/13766100.html</guid>
<description>&lt;p&gt;长话短说：上文我们讲了 ASP.NET Core 基于声明的访问控制到底是什么鬼？&lt;br/&gt;今天我们乘胜追击：聊一聊ASP.NET Core 中的身份验证。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;身份验证是确定用户身份的过程。 授权是确定用户是否有权访问资源的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-万变不离其宗&quot;&gt;1. 万变不离其宗&lt;/h3&gt;
&lt;p&gt;显而易见，一个常规的身份认证用例包括两部分：&lt;br/&gt;① 对用户进行身份验证&lt;br/&gt;② 在未经身份验证的用户试图访问受限资源时作出反应&lt;/p&gt;
&lt;p&gt;已注册的身份验证处理程序及其配置选项被称为“方案”，方案可用作一种机制，供用户参考相关处理程序的身份验证、挑战和禁止行为。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们口头上常说的：&lt;br/&gt;基于cookie认证方案，若认证成功，go on，若认证失败则跳转回登录页面；&lt;br/&gt;基于基本身份认证（BA）方案，若认证成功，go on，若认证失败则给浏览器返回&lt;code&gt;WWW-Authenticate&lt;/code&gt;标头， 浏览器会再次弹出认证窗口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;2-aspnet-core认证原理&quot;&gt;2. ASP.NET Core认证原理&lt;/h3&gt;
&lt;p&gt;在 ASP.NET Core 中，身份验证由&lt;code&gt;IAuthenticationService&lt;/code&gt;负责，身份验证服务会调用已注册的身份验证处理程序来完成与身份验证相关的操作， 整个验证过程由&lt;code&gt;认证中间件&lt;/code&gt;来串联。&lt;/p&gt;
&lt;p&gt;一图以蔽之：&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/c99ce9c3-22f9-43da-958a-92c281838c02.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=7tOjcM%252B2V8NpeVRkXw1g4De8VcU%253D&amp;amp;Expires=1601817858&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中有几个关键步骤&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;认证处理程序&lt;br/&gt;可结合方案Scheme中的配置项&lt;code&gt;AuthenticationSchemeOptions&lt;/code&gt;编写认证处理程序。&lt;/p&gt;
&lt;p&gt;基于Cookie的认证方案可在Options项中可指定登录地址，&lt;br/&gt;基于基本身份的认证方案可在Options项中指定用户名/密码;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;身份认证程序继承自&lt;code&gt;AuthenticationHandler类&lt;/code&gt;或&lt;code&gt;IAuthenticationHandler接口&lt;/code&gt;。&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/12b7d893-1c68-4626-ad62-f918576bcb7f.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=hf5u%252Bm9cWNkNCWJVWTgr5vaDp%252FQ%253D&amp;amp;Expires=1601822570&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;核心认证函数可落地基于声明的访问控制，生成绑定了ClaimsPrincipal、Scheme的&lt;code&gt;AuthenticationTicket对象&lt;/code&gt;； 无论认证成功/失败，函数返回&lt;code&gt;AuthenticateResult对象&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;挑战(对未认证的用户做出的反应)： 例如返回登录页面&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;禁止(对已认证，但对特定资源无权访问做出的反应) ： 例如返回提示字符串&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上均为服务注册过程&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;收到请求，认证中间件使用&lt;code&gt;IAuthenticationService&lt;/code&gt;对HttpContext按照要求的scheme进行认证， 实际内部会调用第2步编写的认证处理程序。&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/333638e3-d5a6-4651-a43d-18ae2315f17a.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=xRvEYpXEQMYrE7tw0NwWE%252BIgq9s%253D&amp;amp;Expires=1601822194&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上认证原理，之前有一个近身实战： ASP.NET Core 实现基本身份验证。&lt;br/&gt;源代码如下： &lt;a href=&quot;https://www.cnblogs.com/JulianHuang/p/10345365.html&quot;&gt;https://www.cnblogs.com/JulianHuang/p/10345365.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-aspnet-core获取当前用户&quot;&gt;3. ASP.NET Core获取当前用户&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;基于声明的访问控制, 我们会在HttpContext.User属性存储身份信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt; var claims = new[] {
               new Claim(ClaimTypes.NameIdentifier,username),
               new Claim(ClaimTypes.Name,username),
           };
 var identity = new ClaimsIdentity(claims, Scheme.Name);
 var principal = new ClaimsPrincipal(identity);
 Context.User = principal;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Web应用程序中获取当前登录用户， 有两种代码场合：&lt;/p&gt;
&lt;h5 id=&quot;31-在控制器中获取当前登录用户&quot;&gt;3.1 在控制器中获取当前登录用户&lt;/h5&gt;
&lt;p&gt;控制器是处理请求的 一等公民，天生自带HttpContext。&lt;br/&gt;直接通过ControllerBase基类中包含的HttpContext属性，获取User对象。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;实际上Razor Page、Razor View、Middleware均包含HttpContext属性/参数， 可直接使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;32-在服务中获取当前登录用户&quot;&gt;3.2 在服务中获取当前登录用户&lt;/h5&gt;
&lt;p&gt;这个时候，服务是作为请求处理中的一个环节，并没有直接可用的HttpContext。&lt;br/&gt;ASP.NET Core 提供了&lt;code&gt;IHttpContextAccessor类&lt;/code&gt;能够注入此次请求中的HttpContext对象（依赖注入框架的作用）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//  下面的用户实体类，需要获取当前登录用户，借助IHttpContextAccessor注入httpContext
public class UserEntityService : IUserEntityService
{
   private IHttpContextAccessor _accessor;
   private readonly IMongoCollection&amp;lt;UserProfile&amp;gt; _users;

   public UserEntityService(IHttpContextAccessor accessor, IDefaultMongoDatabaseProvider databaseProvider)
   {
       _accessor = accessor;
       _users = databaseProvider.GetCollection&amp;lt;UserProfile&amp;gt;(CollectionNames.UserProfiles);
   }

   public Task&amp;lt;UserProfile&amp;gt; GetCurrentUserAsync()
   {
       var rawUser = this._accessor.HttpContext.User();
       if (rawUser == null)
       {
          return null;
       }
       var filter = Builders&amp;lt;UserProfile&amp;gt;.Filter.Eq(&quot;UserId&quot;, rawUser.UserId);
      return _users.Find(filter).FirstOrDefaultAsync();
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;-abp-vnext&quot;&gt;+ abp vnext&lt;/h4&gt;
&lt;p&gt;我们不需要区分以上代码场合，在Controller或者Application 服务中使用&lt;code&gt;ICurrentUser&lt;/code&gt;接口拿到登录用户。&lt;/p&gt;
&lt;h3 id=&quot;旁白&quot;&gt;旁白&lt;/h3&gt;
&lt;p&gt;个人认为，ASP.NET Core身份认证的源代码, 基于现实认知提炼而来，让我们惊叹于框架代码的的简洁精炼、层次分明。&lt;/p&gt;
&lt;p&gt;基于声明的访问控制已成标准，ASP.NET Core/abp vnext 均提供了完善的支持。&lt;/p&gt;
</description>
<pubDate>Sun, 04 Oct 2020 13:32:00 +0000</pubDate>
<dc:creator>有态度的小码甲</dc:creator>
<og:description>长话短说：上文我们讲了 ASP.NET Core 基于声明的访问控制到底是什么鬼？ 今天我们乘胜追击：聊一聊ASP.NET Core 中的身份验证。 身份验证是确定用户身份的过程。 授权是确定用户是否</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JulianHuang/p/13766100.html</dc:identifier>
</item>
<item>
<title>在C++中使用libuv时对回调的处理 (2) - ink19</title>
<link>http://www.cnblogs.com/ink19/p/13768425.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ink19/p/13768425.html</guid>
<description>&lt;p&gt;在完成了第一版的《&lt;a href=&quot;https://www.cnblogs.com/ink19/p/13618393.html&quot;&gt;在C++中使用libuv时对回调的处理&lt;/a&gt;》之后，在对项目进行开发的时候，还是感觉有一些难受。&lt;/p&gt;
&lt;p&gt;因为在实际操作的时候，需要构建一个结构体，并且需要对这个结构体的内存进行管理，非常的麻烦。&lt;/p&gt;
&lt;p&gt;在对C++的模板编程进行简单的学习后，了解到一个比较基本的知识。如果一个值或者类型能在编译的时候确定，那么它是一定可以作为模板参数的。&lt;/p&gt;
&lt;p&gt;反观我之前为了完成操作构建的结构体，可以很明显的发现，成员函数指针那一个变量是一直保持不变的，而且可以在编译的时候确定，所以是有办法将成员函数指针放入模板里面的。&lt;/p&gt;

&lt;h2 id=&quot;使用回调的函数&quot;&gt;使用回调的函数&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;typedef struct {
    void *data;
    int s;
} call_back_t;

typedef void (*call_back_func_t)(call_back_t *t, int s, int v);

int call_back_func(call_back_t *t, call_back_func_t func) {
    func(t, t-&amp;gt;s, 12);
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;回调函数及其类&quot;&gt;回调函数及其类&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;class CallBack {
public:
    int a = 0;
    void call_back(call_back_t *t, int s, int v) {
        std::cout &amp;lt;&amp;lt; &quot;t-&amp;gt;s:&quot; &amp;lt;&amp;lt; t-&amp;gt;s &amp;lt;&amp;lt; std::endl;
        std::cout &amp;lt;&amp;lt; &quot;s:&quot; &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
        std::cout &amp;lt;&amp;lt; &quot;v:&quot; &amp;lt;&amp;lt; v &amp;lt;&amp;lt; std::endl;
        std::cout &amp;lt;&amp;lt; &quot;a:&quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; std::endl; 
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解决方案-2&quot;&gt;解决方案&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;template&amp;lt;typename T,  T&amp;gt;
struct comm_call_back_s;

template&amp;lt;typename ClassType, typename ...ArgTypes, void (ClassType::*FunType)(call_back_t *t, ArgTypes...) &amp;gt;
struct comm_call_back_s&amp;lt;void (ClassType::*)(call_back_t *t, ArgTypes...), FunType&amp;gt; {
    static void comm_call_back(call_back_t *t, ArgTypes... Value) {
        ClassType *mClass = static_cast&amp;lt;ClassType *&amp;gt;(t-&amp;gt;data);
        (mClass-&amp;gt;*FunType)(t, std::forward&amp;lt;ArgTypes&amp;gt;(Value)...);
    }
};

#define define_comm_call_back_s(F) (comm_call_back_s&amp;lt;decltype((F)), (F)&amp;gt;::comm_call_back)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码是根据[1]中大佬代码修改得来的。首先是第一段&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;template&amp;lt;typename T,  T&amp;gt;
struct comm_call_back_s;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一段代码定义了模板的原型，模板包括两个参数。一个是类型T，另一个是类型为T的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;template&amp;lt;typename ClassType, typename ...ArgTypes, void (ClassType::*FunType)(call_back_t *t, ArgTypes...) &amp;gt;
struct comm_call_back_s&amp;lt;void (ClassType::*)(call_back_t *t, ArgTypes...), FunType&amp;gt; {
    static void comm_call_back(call_back_t *t, ArgTypes... Value) {
        ClassType *mClass = static_cast&amp;lt;ClassType *&amp;gt;(t-&amp;gt;data);
        (mClass-&amp;gt;*FunType)(t, std::forward&amp;lt;ArgTypes&amp;gt;(Value)...);
    }
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二段代码是我们主要使用的偏特化模板。一共定义了三个模板参数，第一个是包含回调函数的类，第二个是回调函数的部分参数，第三个是回调函数。&lt;/p&gt;
&lt;p&gt;在具体的特化中，我们将回调函数的类型作为原型里面的类型T,回调函数作为值。&lt;/p&gt;
&lt;p&gt;然后，我们定义了一个comm_call_back函数作为我们封装的回调函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;#define define_comm_call_back_s(F) (comm_call_back_s&amp;lt;decltype((F)), (F)&amp;gt;::comm_call_back)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一段，我们定义了一个宏，方便我们的调用。&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;int main() {
    CallBack b;
    b.a = 100;
    call_back_t call;
    call.s = 1024;
    call.data = static_cast&amp;lt;void *&amp;gt;(&amp;amp;b);
    call_back_func(&amp;amp;call, define_comm_call_back_s(&amp;amp;CallBack::call_back));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://gcc.godbolt.org/z/45MeP7&quot;&gt;完整代码示范&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在写完这一些代码后，我思考了几个问题，并做了一定的解答。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么使用结构体，而不直接使用模板函数。&lt;br/&gt;因为我们在定义模板原型的时候没办法决定函数的参数，所以先使用结构体定义，然后使用偏特化实现具体的函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://stackoverflow.com/questions/9779105/generic-member-function-pointer-as-a-template-parameter&quot;&gt;https://stackoverflow.com/questions/9779105/generic-member-function-pointer-as-a-template-parameter&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 04 Oct 2020 13:19:00 +0000</pubDate>
<dc:creator>ink19</dc:creator>
<og:description>前情简介 在完成了第一版的《在C++中使用libuv时对回调的处理》之后，在对项目进行开发的时候，还是感觉有一些难受。 因为在实际操作的时候，需要构建一个结构体，并且需要对这个结构体的内存进行管理，非</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ink19/p/13768425.html</dc:identifier>
</item>
<item>
<title>CAS 原子操作 - 彼岸舞</title>
<link>http://www.cnblogs.com/flower-dance/p/13767956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flower-dance/p/13767956.html</guid>
<description>&lt;p&gt;&lt;span&gt;理会CAS和CAS:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有时候面试官面试问你的时候,会问,谈谈你对CAS的理解,这时应该有很多人,就会比较懵,当然,我也会比较懵,当然我和很多人的懵不同,很多人可能,并不知道CAS是一个什么东西,而在我看来我是不知道他问的是那个CAS&lt;/p&gt;
&lt;p&gt;　　我一般会问面试官,问他问的CAS是&quot;原子操作&quot;,还是&quot;单点登录&quot;&lt;/p&gt;
&lt;p&gt;　　因为在JAVA并发中的原子操作是称为CAS的,也就是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。&lt;/p&gt;
&lt;p&gt;　　但是在企业应用中CAS也被称为企业级开源单点登录解决方案,是 Central Authentication Service 的缩写 —— 中央认证服务，一种独立开放指令协议，是 Yale 大学发起的一个企业级开源项目，旨在为 Web 应用系统提供一种可靠的 SSO 解决方案。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CAS(Compare And Swap):&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们先要学习的是并发编程中的CAS,也就是原子操作&lt;/p&gt;
&lt;p&gt;　　那么,什么是原子操作?如何实现原子操作?&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是原子操作:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　原子,也是最小单位,是一个不可再分割的单位,不可被中断的一个或者一系列操作&lt;/p&gt;
&lt;p&gt;　　CAS是以一种无锁的方式实现并发控制,在实际情况下,同时操作一个对象的概率非常小,所以多数加锁操作做的基本是无用功&lt;/p&gt;
&lt;p&gt;　　CAS以一种乐观锁的方式实现并发控制&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如何实现原子操作:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Java可以通过锁和循环CAS的方式实现原子操作&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么要有CAS:&lt;/span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　CAS就是比较并且替换的一个原子操作,在CPU的指令级别上进行保证&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;为什么要有CAS:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　Sync是基于阻塞的锁的机制,&lt;/p&gt;
&lt;p&gt;　　　　　　1:被阻塞的线程优先级很高&lt;/p&gt;
&lt;p&gt;　　　　　　2:拿到锁的线程一直不释放锁则么办&lt;/p&gt;
&lt;p&gt;　　　　　　3:大量的竞争,消耗CPU,同时带来死锁或者其他线程安全&lt;/p&gt;
&lt;p&gt;　　　　因为通过锁实现原子操作时,其他线程必须等待已经获得锁的线程运行完车之后才能获取锁,这样就会占用系统大量资源&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CAS原理:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从CPU指令级别保证这是一个原子操作&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CAS包含哪些参数:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;三个运算符:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　一个内存地址V&lt;/p&gt;
&lt;p&gt;　　　　一个期望的值A&lt;/p&gt;
&lt;p&gt;　　　　一个新值B&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;基本思路:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　如果地址V上的值和期望的值A相等,就给地址V赋值新值B,如果不是,不做任何操作&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　循环CAS:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　在一个(死)循环中[for(;;)]里不断进行CAS操作,直到成功为止(自旋操作即死循环)&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CAS问题:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;ABA问题:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　那么什么是ABA问题?就是内存中原本是A,然后通过CAS变成了B,然后再次通过CAS变成了A,这个过程中,相对于结果来说,是没有任何改变的,但是相对于内存来说,至少发生过两次变化,这就是ABA问题&lt;/p&gt;
&lt;p&gt;　　　　生活中:&lt;/p&gt;
&lt;p&gt;　　　　　　就像你接了一杯水,这时水是满的,但是这个时候,你的同时很渴,过来拿你的水直接喝掉了一半,这时水剩下了一半,接着,你的同事又重新把你的水帮你接满了,那么这时你的水还是满的,相对于水来说,他还是满的,但是相对于杯子来说,他已经被用过了两次,一次是喝水,一次是接水,这就是ABA问题&lt;/p&gt;
&lt;p&gt;　　　　从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。&lt;/p&gt;
&lt;p&gt;　　　　生活中:&lt;/p&gt;
&lt;p&gt;　　　　　　你接了一杯水,然后旁边放上一张登记表,这个时候你同事过来,直接喝掉了一半,然后登记上,XXX喝掉了一半的水,然后去给你接满了,再次登记上,我给你接满了,这时,ABA的问题就得到了解决,你一看这个表就知道了一切&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;开销问题:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　在自旋或者死循环中不断进行CAS操作,但是长期操作不成功,CPU不断的循环,带来的开销问题&lt;/p&gt;
&lt;p&gt;　　　　自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　只能保证一个共享变量的原子操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;CAS的目的:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;利用CPU的CAS指令，同时借助JNI来完成Java的非阻塞算法。其它原子操作都是利用类似的特性完成的。而整个J.U.C都是建立在CAS之上的，因此对于synchronized阻塞算法，J.U.C在性能上有了很大的提升。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JDK中相关原子操作类的使用:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　更新基本类型类:AtomicBoolean,AtomicInteger,AtomicLong&lt;/p&gt;
&lt;p&gt;　　更新数组类:AtomicIntegerArray,AtomicLongArray,AtomicReferenceArrat&lt;/p&gt;
&lt;p&gt;　　更新引用类型:AtomicReference,AtomicMarkableReference,AtomicStampedReference&lt;/p&gt;
&lt;p&gt;　　原子更新字段类:AtomicReferenceFieldUpdater,AtomicIntegerFieldUpdater,AtomicLongFieldUpdater&lt;/p&gt;
&lt;p&gt;理论已经理解的差不多了,接下来写写代码&lt;/p&gt;
&lt;p&gt;使用AtomicInteger&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicInteger;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用原子类int类型
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseAtomicInt {

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; AtomicInteger atomicInteger = &lt;span&gt;new&lt;/span&gt; AtomicInteger(10&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10-&amp;gt;11 10先去再增加&lt;/span&gt;
&lt;span&gt;        System.out.println(atomicInteger.getAndIncrement());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11-&amp;gt;12 12先增加再取&lt;/span&gt;
&lt;span&gt;        System.out.println(atomicInteger.incrementAndGet());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取&lt;/span&gt;
&lt;span&gt;        System.out.println(atomicInteger.get());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回值:&lt;/p&gt;

&lt;p&gt;通过返回值可以看到,第一个是先获取返回值后累加1,第二个是先累加1后再返回,第三个是获取当前值&lt;/p&gt;
&lt;p&gt;使用AtomicIntegerArray&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicIntegerArray;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用原子类int[]
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseAtomicIntegerArray {

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] values = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{1,2&lt;span&gt;};

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; AtomicIntegerArray atomicIntegerArray = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicIntegerArray(values);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;改变的第一个参数是 数组的下标,第二个是新值&lt;/span&gt;
        atomicIntegerArray.getAndSet(0,3&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取原子数组类中的下标为0的值&lt;/span&gt;
        System.out.println(atomicIntegerArray.get(0&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取源数组中下标为0的值&lt;/span&gt;
        System.out.println(values[0&lt;span&gt;]);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回结果:&lt;/p&gt;

&lt;p&gt;通过返回结果我们可以看到,源数组中的值并没有改变,只有引用中的值发生了改变,这是则么回事?&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Creates a new AtomicIntegerArray with the same length as, and
     * all elements copied from, the given array.
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; array the array to copy elements from
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; NullPointerException if array is null
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; AtomicIntegerArray(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] array) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Visibility guaranteed by final field guarantees&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.array =&lt;span&gt; array.clone();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过看源码我们得知他是调用了数组的克隆方法,克隆了一个一模一样的&lt;/p&gt;
&lt;p&gt;使用AtomicReference&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicReference;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用原子类引用类型
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseAtomicReference {

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; AtomicReference&amp;lt;UserInfo&amp;gt; atomicReference = &lt;span&gt;new&lt;/span&gt; AtomicReference&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

        UserInfo src &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; UserInfo(&quot;彼岸舞&quot;,18&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用原子引用类包装一下&lt;/span&gt;
&lt;span&gt;        atomicReference.set(src);

        UserInfo target &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; UserInfo(&quot;彼岸花&quot;,19&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里就是CAS改变了,这个应用类就好像一个容器也就是内存V,而src就是原值A,target就是新值B
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 期望原值是src,如果是的话,改变为target,否则不变&lt;/span&gt;
&lt;span&gt;        atomicReference.compareAndSet(src,target);

        System.out.println(atomicReference.get());

        System.out.println(src);

    }

    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfo{
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;UserInfo{&quot; +
                    &quot;name='&quot; + name + '\'' +
                    &quot;, age=&quot; + age +
                    '}'&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserInfo() {
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo(String name, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; name;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setName(String name) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
UserInfo{name='彼岸花', age=19&lt;span&gt;}
UserInfo{name&lt;/span&gt;='彼岸舞', age=18}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过返回结果可以直观的看到,原子引用类中的值发生了改变,但是源对象src却没有改变,因为原子引用类和原对象本身是两个东西,CAS后就可以理解为内存中的东西变了,也可以说是引用变了,他只能保证你在改变这个引用的时候保证是原子性的&lt;/p&gt;
&lt;p&gt;记得之前上面说的&lt;strong&gt;ABA问题&lt;/strong&gt;吧,在这里就是&lt;strong&gt;解决&lt;/strong&gt;代码&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JDK中提供了两种解决ABA问题的类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　AtomicStampedReference&lt;/p&gt;
&lt;p&gt;　　　　AtomicStampedReference,里面是用int类型,他关心的是被人动过几次&lt;/p&gt;
&lt;p&gt;　　AtomicMarkableReference&lt;/p&gt;
&lt;p&gt;　　　　AtomicMarkableReference,里面是用boolean类型,他只关心这个版本有没有人动过&lt;/p&gt;
&lt;p&gt; 两个类关心的点不一样,侧重的方向不一样,就像之前说的喝水问题,AtomicStampedReference关心的是,被几个人动过,而AtomicMarkableReference关心的是有没有人动过&lt;/p&gt;
&lt;p&gt;使用AtomicStampedReference解决ABA问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day3;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.atomic.AtomicStampedReference;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 使用版本号解决ABA问题
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ZYGisComputer
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseAtomicStampedReference {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 构造参数地第一个是默认值,第二个就是版本号
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; AtomicStampedReference&amp;lt;String&amp;gt; atomicStampedReference = &lt;span&gt;new&lt;/span&gt; AtomicStampedReference&amp;lt;&amp;gt;(&quot;src&quot;,0&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取初始版本号&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; oldStamp =&lt;span&gt; atomicStampedReference.getStamp();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取初始值&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; String oldValue =&lt;span&gt; atomicStampedReference.getReference();

        System.out.println(&lt;/span&gt;&quot;oldValue:&quot;+oldValue+&quot; oldStamp:&quot;+&lt;span&gt;oldStamp);

        Thread success &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                System.out.println(Thread.currentThread().getName()&lt;/span&gt;+&quot;,当前变量值:&quot;+oldValue+&quot;当前版本号:&quot;+&lt;span&gt;oldStamp);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 变更值和版本号&lt;/span&gt;
                &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
                 * 第一个参数:期望值
                 * 第二个参数:新值
                 * 第三个参数:期望版本号
                 * 第四个参数:新版本号
                 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;boolean&lt;/span&gt; b = atomicStampedReference.compareAndSet(oldValue, oldValue + &quot;java&quot;, oldStamp, oldStamp + 1&lt;span&gt;);
                System.out.println(b);
            }
        });

        Thread error &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取原值&lt;/span&gt;
                String sz =&lt;span&gt; atomicStampedReference.getReference();
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; stamp =&lt;span&gt; atomicStampedReference.getStamp();
                System.out.println(Thread.currentThread().getName()&lt;/span&gt;+&quot;,当前变量值:&quot;+sz+&quot;当前版本号:&quot;+&lt;span&gt;stamp);
                &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; b = atomicStampedReference.compareAndSet(oldValue, oldValue + &quot;C&quot;, oldStamp, oldStamp + 1&lt;span&gt;);
                System.out.println(b);
            }
        });

        success.start();
        success.join();
        error.start();
        error.join();
        System.out.println(atomicStampedReference.getReference()&lt;/span&gt;+&quot;:&quot;+&lt;span&gt;atomicStampedReference.getStamp());
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
oldValue:src oldStamp:0&lt;span&gt;
Thread&lt;/span&gt;-0,当前变量值:src当前版本号:0
&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
Thread&lt;/span&gt;-1,当前变量值:srcjava当前版本号:1
&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
srcjava:&lt;/span&gt;1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过返回结果可以观察到,原始值是src,版本是0,然后使用join方法使我们的正确线程确保咋错误线程之前执行完毕,当正确线程执行完毕后,会把值改为srcjava,版本改为+1,然后执行错误的线程,错误的线程在尝试去改值的时候,发现期望的值是src,但是值已经被改变成srcjava了,并且期望的版本是0,但是版本已经被改为1了,所以他无法修改,在两个线程都执行完毕之后,打印的值是 srcjava,版本是1,成功的解决了ABA问题,当然在这里面我的期望值是还是src,也可以改为src+java但是因为版本不一样也是无法修改成功的;亲测没问题&lt;/p&gt;
&lt;p&gt;原子更新字段类就不写了,那个使用比较麻烦,如果多个字段的话,就直接使用AtomicReference类就可以了&lt;/p&gt;
&lt;p&gt;作者：彼岸舞&lt;/p&gt;
&lt;p&gt;时间：2020\10\04&lt;/p&gt;
&lt;p&gt;内容关于：并发编程&lt;/p&gt;
&lt;p&gt;本文来源于网络，只做技术分享，一概不负任何责任&lt;/p&gt;
</description>
<pubDate>Sun, 04 Oct 2020 12:30:00 +0000</pubDate>
<dc:creator>彼岸舞</dc:creator>
<og:description>理会CAS和CAS: 有时候面试官面试问你的时候,会问,谈谈你对CAS的理解,这时应该有很多人,就会比较懵,当然,我也会比较懵,当然我和很多人的懵不同,很多人可能,并不知道CAS是一个什么东西,而在我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flower-dance/p/13767956.html</dc:identifier>
</item>
<item>
<title>Web开发初探之JavaScript 快速入门 - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/13768208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/13768208.html</guid>
<description>&lt;blockquote readability=&quot;2.65625&quot;&gt;
&lt;p&gt;本文改编和学习自 &lt;a href=&quot;https://www.discovermeteor.com/blog/javascript-for-meteor/&quot;&gt;A JavaScript Primer For Meteor&lt;/a&gt; 和 MDN Web教程&lt;/p&gt;
&lt;p&gt;前文 &lt;a href=&quot;https://www.cnblogs.com/RioTian/p/13668124.html&quot;&gt;Web开发初探&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;本文以介绍 JavaScript 为主，初学者掌握本文的内容后，将能够对 JavaScript 有大体了解。&lt;/p&gt;
&lt;p&gt;JavaScript（缩写：JS）是一门完备的 &lt;a href=&quot;https://www.cnblogs.com/RioTian/p/13768208.html&quot;&gt;动态编程语言&lt;/a&gt;。当应用于 &lt;a href=&quot;https://www.cnblogs.com/RioTian/p/13768208.html&quot;&gt;HTML&lt;/a&gt; 文档时，可为网站提供动态交互特性。由布兰登·艾克（ Brendan Eich，Mozilla 项目、Mozilla 基金会和 Mozilla 公司的联合创始人）发明。&lt;/p&gt;
&lt;p&gt;JavaScript 的应用场合极其广泛，简单到幻灯片、照片库、浮动布局和响应按钮点击，复杂到游戏、2D/3D 动画、大型数据库驱动程序等等。&lt;/p&gt;
&lt;p&gt;JavaScript 相当简洁，却非常灵活。开发者们基于 JavaScript 核心编写了大量实用工具，可以使 开发工作事半功倍。其中包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浏览器应用程序接口（&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Glossary/API&quot;&gt;API&lt;/a&gt;）—— 浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成3D 图像与音频样本等等。&lt;/li&gt;
&lt;li&gt;第三方 API —— 让开发者可以在自己的站点中整合其它内容提供者（Twitter、Facebook 等）提供的功能。&lt;/li&gt;
&lt;li&gt;第三方框架和库 —— 用来快速构建网站和应用。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7.6873889875666&quot;&gt;
&lt;p&gt;JavaScript是一门充满争议的编程语言：它以 Java 命名，但实际上和 Java 毫无关系。JavaScript 的创造 &lt;a href=&quot;https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript&quot;&gt;只用了 10 天时间&lt;/a&gt;，但在20年时间里却发展成世界上最流行的 Web 开发语言。如果为 JavaScript 今日的地位和流行程度找一个原因，那毫无疑问是容易上手的语言特性。当然，精通 JavaScript 是一项艰巨的任务，但学会足够开发 Web 应用和游戏的知识却很简单，如果你已经有了一定编程基础，熟悉 JavaScript 语言特性不会花费你多长时间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;边读边尝试&quot;&gt;边读边尝试&lt;/h2&gt;
&lt;p&gt;如果你能看到这篇文章，那么你已经具备了全功能的 JavaScript 开发环境 —— 我说的就是你正在使用的浏览器！&lt;/p&gt;
&lt;p&gt;在本页面中读到的所有例子，你都可以把它们输入到浏览器的控制台里并查看运行结果，如果你不清楚怎么做，可以阅读文档 &lt;a href=&quot;http://webmasters.stackexchange.com/a/77337&quot;&gt;如何在不同浏览器中打开控制台的指南&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;准备好了吗？让我们开始学习 JavaScript 吧！&lt;/p&gt;
&lt;h2 id=&quot;变量（variable）&quot;&gt;变量（Variable）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;变量&lt;/strong&gt; 是存储值的容器。在 JavaScript 中，我们像这样声明一个变量，先输入关键字 &lt;code&gt;let&lt;/code&gt; 或 &lt;code&gt;var&lt;/code&gt;，然后输入合适的名称：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var a;
let myVariable;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保留字 &lt;code&gt;var&lt;/code&gt; 之后紧跟着的，就是一个变量名，接下来我们可以为变量赋值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var a = 12;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在阅读其他人的 JavaScript 代码时，你也会看到下面这样的变量声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;a = 12;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;16.329113924051&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;行末的分号表示当前语句结束，不过只有在单行内需要分割多条语句时，这个分号才是必须的。然而，一些人认为每条语句末尾加分号是一种好的风格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;几乎任何内容都可以作为变量名，但还是有一些限制：如类型名无法作为变量名（详情请参阅 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_Types#%E5%8F%98%E9%87%8F&quot;&gt;变量命名规则&lt;/a&gt;）。如果你不确定，还可以 &lt;a href=&quot;https://mothereff.in/js-variables&quot;&gt;验证变量名&lt;/a&gt; 是否有效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;JavaScript 对大小写敏感，&lt;code&gt;myVariable&lt;/code&gt; 和 &lt;code&gt;myvariable&lt;/code&gt; 是不同的。如果代码出现问题了，先检查一下大小写！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;想要了解更多关于 &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 的不同点，可以参阅 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/First_steps/Variables#var_%E4%B8%8E_let_%E7%9A%84%E5%8C%BA%E5%88%AB&quot;&gt;var 与 let 的区别&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;注意变量可以有不同的 &lt;a href=&quot;https://www.cnblogs.com/RioTian/p/13768208.html&quot;&gt;数据类型&lt;/a&gt; ：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么变量有什么用呢？我们说，编程时它们无所不在。如果值无法改变，那么就无法做任何动态的工作，比如发送个性化的问候，或是改变在图片库当前展示的图片。&lt;/p&gt;
&lt;h2 id=&quot;注释&quot;&gt;注释&lt;/h2&gt;
&lt;p&gt;类似于 CSS、C++，JavaScript 中可以添加注释。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;/*
这里的所有内容
都是注释。
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果注释只有一行，可以更简单地将注释放在两个斜杠之后，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 这是一条注释。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数&quot;&gt;函数&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/RioTian/p/13768208.html&quot;&gt;函数&lt;/a&gt; 用来封装可复用的功能。如果没有函数，一段特定的操作过程用几次就要重复写几次，而使用函数则只需写下函数名和一些简短的信息。&lt;/p&gt;
&lt;p&gt;比如：在 JavaScript 里我们像这样声明函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var myAwesomeFunction = function (myArgument) {
    // do something
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像这样调用函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;myAwesomeFunction(something);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到函数声明也和变量声明一样遵从 &lt;code&gt;var something = somethingElse&lt;/code&gt; 的模式。因为在 JavaScript 里，函数和变量本质上是一样的，我们可以像下面这样把一个函数当做参数传入另一个函数中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;square = function (a) {
    return a * a;
}
applyOperation = function (f, a) {
    return f(a);
}
applyOperation (square, 10); // 100
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;返回值&quot;&gt;返回值&lt;/h2&gt;
&lt;p&gt;函数的返回值是由 &lt;code&gt;return&lt;/code&gt; 打头的语句定义的，我们这里要了解的是函数体内 &lt;code&gt;return&lt;/code&gt; 语句之后的内容是不会被执行的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;myFunction = function (a) {
    return a * 3;
    explodeComputer(); // will never get executed (hopefully!)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.7065217391304&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;code&gt;return&lt;/code&gt; 语句告诉浏览器当前函数返回 &lt;code&gt;result&lt;/code&gt; 变量。这是一点很有必要，因为函数内定义的变量只能在函数内使用。这叫做变量的 &lt;a href=&quot;https://www.cnblogs.com/RioTian/p/13768208.html&quot;&gt;作用域&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;if&quot;&gt;if&lt;/h2&gt;
&lt;p&gt;JavaScript 中条件判断语句 &lt;code&gt;if&lt;/code&gt; 是这样用的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;if (foo) {
    return bar;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;if--else&quot;&gt;if / Else&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 后的值如果为 false，会执行 &lt;code&gt;else&lt;/code&gt; 中的语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;if (foo) {
    function1();
}
else {
    function2();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; / &lt;code&gt;else&lt;/code&gt; 条件判断还可以像这样写成一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;foo ? function1() : function2();
//三目运算符：条件：条件True时返回值：条件False时返回值
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;foo&lt;/code&gt; 的值为 true 时，表达式会返回 &lt;code&gt;function1()&lt;/code&gt; 的执行结果，反之会返回 &lt;code&gt;function2()&lt;/code&gt; 的执行结果。当我们需要根据条件来为变量赋值时，这种写法就非常方便：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var n = foo ? 1 : 2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的语句可以表述为：当 &lt;code&gt;foo&lt;/code&gt; 是 true 时，将 &lt;code&gt;n&lt;/code&gt; 的值赋为 1，否则赋为 2。&lt;/p&gt;
&lt;p&gt;当然我们还可以使用 &lt;code&gt;else if&lt;/code&gt; 来处理更多的判断类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;if (foo) {
    function1();
}
else if (bar) {
    function2();
}
else {
    function3();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;javascript-数组（array）&quot;&gt;JavaScript 数组（Array）&lt;/h2&gt;
&lt;p&gt;JavaScript 里像这样声明数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;a = [123, 456, 789];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像这样访问数组中的成员：（从0开始索引）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;a[1]; // 456
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;javascript-对象（object）&quot;&gt;JavaScript 对象（Object）&lt;/h2&gt;
&lt;p&gt;我们像这样声明一个对象（object）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;myProfile = {
    name: &quot;Jare Guo&quot;,
    email: &quot;blabla@gmail.com&quot;,
    'zip code': 12345,
    isInvited: true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在对象声明的语法（&lt;code&gt;myProfile = {...}&lt;/code&gt;）之中，有一组用逗号相隔的键值对。每一对都包括一个 key（字符串类型，有时候会用双引号包裹）和一个 value（可以是任何类型：包括 string，number，boolean，变量名，数组，对象甚至是函数）。我们管这样的一对键值叫做对象的属性（property），key 是属性名，value 是属性值。&lt;/p&gt;
&lt;p&gt;你可以在 value 中嵌套其他对象，或者由一组对象组成的数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;myProfile = {
    name: &quot;Jare Guo&quot;,
    email: &quot;blabla@gmail.com&quot;,
    city: &quot;Xiamen&quot;,
    points: 1234,
    isInvited: true,
    friends: [
        {
            name: &quot;Johnny&quot;,
            email: &quot;blablabla@gmail.com&quot;
        },
        {
            name: &quot;Nantas&quot;,
            email: &quot;piapiapia@gmail.com&quot;
        }
    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问对象的某个属性非常简单，我们只要使用 dot 语法就可以了，还可以和数组成员的访问结合起来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;myProfile.name; // Jare Guo
myProfile.friends[1].name; // Nantas
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JavaScript 中的对象无处不在，在函数的参数传递中也会大量使用，比如在 Cocos Creator 中，我们就可以像这样定义 FireClass 对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var MyComponent = cc.Class({
    extends: cc.Component
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;{extends: cc.Component}&lt;/code&gt; 这就是一个用做函数参数的对象。在 JavaScript 中大多数情况我们使用对象时都不一定要为他命名，很可能会像这样直接使用。&lt;/p&gt;
&lt;h2 id=&quot;匿名函数&quot;&gt;匿名函数&lt;/h2&gt;
&lt;p&gt;我们之前试过了用变量声明的语法来定义函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;myFunction = function (myArgument) {
    // do something
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再复习一下将函数作为参数传入其他函数调用中的用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;square = function (a) {
    return a * a;
}
applyOperation = function (f, a) {
    return f(a);
}
applyOperation(square, 10); // 100
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还见识了 JavaScript 的语法是多么喜欢偷懒，所以我们就可以用这样的方式代替上面的多个函数声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;applyOperation = function (f, a) {
    return f(a);
}
applyOperation(
    function(a){
      return a*a;
    },
    10
) // 100
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们这次并没有声明 &lt;code&gt;square&lt;/code&gt; 函数，并将 &lt;code&gt;square&lt;/code&gt; 作为参数传递，而是在参数的位置直接写了一个新的函数体，这样的做法被称为匿名函数，在 JavaScript 中是最为广泛使用的模式。&lt;/p&gt;
&lt;h2 id=&quot;链式语法&quot;&gt;链式语法&lt;/h2&gt;
&lt;p&gt;下面我们介绍一种在数组和字符串操作中常用的语法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var myArray = [123, 456];
myArray.push(789) // 123, 456, 789
var myString = &quot;abcdef&quot;;
myString.replace(&quot;a&quot;, &quot;z&quot;); // &quot;zbcdef&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中的点符号表示“调用 &lt;code&gt;myString&lt;/code&gt; 字符串对象的 &lt;code&gt;replace&lt;/code&gt; 函数，并且传递 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;z&lt;/code&gt; 作为参数，然后获得返回值。&lt;/p&gt;
&lt;p&gt;使用点符号的表达式，最大的优点是你可以把多项任务链接在一个表达式里，当然前提是每个调用的函数必须有合适的返回值。我们不会过多介绍如何定义可链接的函数，但是使用它们是非常简单的，只要使用以下的模式：&lt;code&gt;something.function1().function2().function3()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;链条中的每个环节都会接到一个初始值，调用一个函数，然后把函数执行结果传递到下一环节：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var n = 5;
n.double().square(); // 100
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;this&quot;&gt;this&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 可能是 JavaScript 中最难以理解和掌握的概念了。&lt;/p&gt;
&lt;p&gt;简单地说，&lt;code&gt;this&lt;/code&gt; 关键字能让你访问正在处理的对象：就像变色龙一样，&lt;code&gt;this&lt;/code&gt; 也会随着执行环境的变化而变化。&lt;/p&gt;
&lt;p&gt;解释 &lt;code&gt;this&lt;/code&gt; 的原理是很复杂的，不妨让我们使用两种工具来帮助我们在实践中理解 &lt;code&gt;this&lt;/code&gt; 的值：&lt;/p&gt;
&lt;p&gt;首先是最普通又最常用的 &lt;code&gt;console.log()&lt;/code&gt;，它能够将对象的信息输出到浏览器的控制台里。在每个函数体开始的地方加入一个 &lt;code&gt;console.log()&lt;/code&gt;，确保我们了解当时运行环境下正在处理的对象是什么。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;myFunction = function (a, b) {
    console.log(this);
    // do something
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外一个方法是将 &lt;code&gt;this&lt;/code&gt; 赋值给另外一个变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;myFunction = function (a, b) {
    var myObject = this;
    // do something
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;乍一看好像这样子并没有什么作用，实际上它允许你安全的使用 &lt;code&gt;myObject&lt;/code&gt; 这个变量来指代最初执行函数的对象，而不用担心在后面的代码中 &lt;code&gt;this&lt;/code&gt; 会变成其他东西。&lt;/p&gt;
&lt;p&gt;关于 JavaScript 里 &lt;code&gt;this&lt;/code&gt; 的详细原理说明，请参考这篇文章 &lt;a href=&quot;http://zhuanlan.zhihu.com/p/23804247&quot;&gt;this 的值到底是什么？一次说清楚&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;运算符&quot;&gt;运算符&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Operator&quot;&gt;运算符&lt;/a&gt; 是一类数学符号，可以根据两个值（或变量）产生结果。以下表格中介绍了一些最简单的运算符，可以在浏览器控制台里尝试一下后面的示例。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;译注：&lt;/strong&gt;这里说“根据&lt;strong&gt;两个&lt;/strong&gt;值（或变量）产生结果”是不严谨的，计算两个变量的运算符称为“二元运算符”，还有一元运算符和三元运算符，下表中的“取非”就是一元运算符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;加&lt;/td&gt;
&lt;td&gt;将两个数字相加，或拼接两个字符串。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;6 + 9;&quot;Hello &quot; + &quot;world!&quot;;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;减、乘、除&lt;/td&gt;
&lt;td&gt;这些运算符操作与基础算术一致。只是乘法写作星号，除法写作斜杠。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;9 - 3;8 * 2; //乘法在JS中是一个星号9 / 3;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;赋值运算符&lt;/td&gt;
&lt;td&gt;为变量赋值（你之前已经见过这个符号了）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;=&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;let myVariable = '李雷';&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;等于&lt;/td&gt;
&lt;td&gt;测试两个值是否相等，并返回一个 &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt; （布尔）值。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;===&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;let myVariable = 3;myVariable === 4; // false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;不等于&lt;/td&gt;
&lt;td&gt;和等于运算符相反，测试两个值是否不相等，并返回一个 &lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt; （布尔）值。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!==&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;let myVariable = 3;myVariable !== 3; // false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;取非&lt;/td&gt;
&lt;td&gt;返回逻辑相反的值，比如当前值为真，则返回 &lt;code&gt;false&lt;/code&gt;。&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;原式为真，但经取非后值为 &lt;code&gt;false&lt;/code&gt;： &lt;code&gt;let myVariable = 3;!(myVariable === 3); // false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;运算符种类远不止这些，不过目前上表已经够用了。完整列表请参阅 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators&quot;&gt;表达式和运算符&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;不同类型数据之间的计算可能出现奇怪的结果，因此必须正确引用变量，才能得出预期结果。比如在控制台输入 &lt;code&gt;&quot;35&quot; + &quot;25&quot;&lt;/code&gt;，为什么不能得到 &lt;code&gt;60&lt;/code&gt;？因为引号将数字转换成了字符串，所以结果是连接两个字符串而不是把两个数字相加。输入 &lt;code&gt;35 + 25&lt;/code&gt; 才能得到正确结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;=&lt;/code&gt; 是赋值运算符，&lt;code&gt;a = 12&lt;/code&gt; 表示把 “12” 赋值给变量 &lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你需要比较两个值，可以使用 &lt;code&gt;==&lt;/code&gt;，例如 &lt;code&gt;a == 12&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;JavaScript 中还有个独特的 &lt;code&gt;===&lt;/code&gt; 运算符，它能够比较两边的值和类型是否全都相同。（类型是指 string, number 这些）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;a = &quot;12&quot;;
a == 12; // true
a === 12; // false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大多数情况下，我们都推荐使用 &lt;code&gt;===&lt;/code&gt; 运算符来比较两个值，因为希望比较两个不同类型但有着相同值的情况是比较少见的。&lt;/p&gt;
&lt;p&gt;下面是 JavaScript 判断两个值是否不相等的比较运算符：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;a = 12;
a !== 11; // true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;!&lt;/code&gt; 运算符还可以单独使用，用来对一个 boolean 值取反：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;a = true;
!a; // false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;!&lt;/code&gt; 运算符总会得到一个 boolean 类型的值，所以可以用来将非 boolean 类型的值转为 boolean 类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;a = 12;
!a; // false
!!a; // true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;a = 0;
!a; // true
!!a; // false
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代码风格&quot;&gt;代码风格&lt;/h2&gt;
&lt;p&gt;最后，下面这些代码风格上的规则能帮助我们写出更清晰明确的代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用驼峰命名法：定义 &lt;code&gt;myRandomVariable&lt;/code&gt; 这样的变量名，而不是 &lt;code&gt;my_random_variable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在每一行结束时写一个 &lt;code&gt;;&lt;/code&gt;，尽管在 JavaScript 里行尾的 &lt;code&gt;;&lt;/code&gt; 是可以忽略的&lt;/li&gt;
&lt;li&gt;在每个关键字前后都加上空格，如 &lt;code&gt;a = b + 1&lt;/code&gt;，而不是 &lt;code&gt;a = b + 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;组合我们学到的知识&quot;&gt;组合我们学到的知识&lt;/h2&gt;
&lt;p&gt;以上基础的 JavaScript 语法知识已经介绍完了，下面我们来看看能否理解实际的脚本代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var Comp = cc.Class({
    extends: cc.Component,

    properties: {
        target: {
            default: null,
            type: cc.Entity
        }
    },

    onStart: function () {
        this.target = cc.Entity.find('/Main Player/Bip/Head');
    },

    update: function () {
        this.transform.worldPosition = this.target.transform.worldPosition;
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码向引擎定义了一个新组件，这个组件具有一个 &lt;code&gt;target&lt;/code&gt; 参数，在运行时会初始化为指定的对象，并且在运行的过程中每一帧都将自己设置成和 &lt;code&gt;target&lt;/code&gt; 相同的坐标。&lt;/p&gt;
&lt;p&gt;让我们分别看下每一句的作用（我会高亮有用的语法模式）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var Comp = cc.Class({&lt;/code&gt;：这里我们使用 &lt;code&gt;cc&lt;/code&gt; 这个对象，通过 &lt;strong&gt;点语法&lt;/strong&gt; 来调用对象的 &lt;code&gt;Class()&lt;/code&gt; 方法（该方法是 &lt;code&gt;cc&lt;/code&gt; 对象的一个属性），调用时传递的参数是一个匿名的 &lt;strong&gt;JavaScript 对象&lt;/strong&gt;（&lt;code&gt;{}&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;target: { default: null, type: cc.Entity }&lt;/code&gt;：这个键值对声明了一个名为 &lt;code&gt;target&lt;/code&gt; 的属性，值是另一个 JavaScript 匿名对象。这个对象定义了 target 的默认值和值类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extends: cc.Component&lt;/code&gt;：这个键值对声明这个 Class 的父类是 cc.Component。cc.Component 是 Cocos Creator 的内置类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;onStart: function () {&lt;/code&gt;：这一对键值定义了一个成员方法，叫做 &lt;code&gt;onStart&lt;/code&gt;，它的值是一个匿名函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this.target = cc.Entity.find('&lt;/code&gt;：在这一句的上下文中，&lt;code&gt;this&lt;/code&gt; 表示正在被创建的 Component 组件，这里通过 &lt;code&gt;this.target&lt;/code&gt; 来访问 &lt;code&gt;target&lt;/code&gt; 属性。&lt;/p&gt;
&lt;h2 id=&quot;继续学习&quot;&gt;继续学习&lt;/h2&gt;
&lt;p&gt;这篇简短的教程从任何角度上说都无法代替系统的 JavaScript 学习，但这里介绍的几种语法模式已经能够帮助你理解绝大部分 Javascript 文档和教程中的代码了，至少从语法上完全可以理解。&lt;/p&gt;
&lt;p&gt;如果你像我一样喜欢通过实践学习，那么现在就可以开始跟随教程和文档学习在 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript&quot;&gt;MDN上进阶学习&lt;/a&gt;了&lt;/p&gt;
&lt;h2 id=&quot;javascript-resources&quot;&gt;JavaScript Resources&lt;/h2&gt;
&lt;p&gt;以下是 JavaScript 的一些入门教程:&lt;/p&gt;
</description>
<pubDate>Sun, 04 Oct 2020 12:09:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>本文改编和学习自 A JavaScript Primer For Meteor 和 MDN Web教程 前文 Web开发初探 概述 本文以介绍 JavaScript 为主，初学者掌握本文的内容后，将能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/13768208.html</dc:identifier>
</item>
<item>
<title>日志分析平台ELK之日志收集器filebeat - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13767152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13767152.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200516034012elastic.jpg&quot; class=&quot;desc_img&quot;/&gt; 前面我们了解了elk集群中的logstash的用法，使用logstash处理日志挺好的，但是有一个缺陷，就是太慢了；当然logstash慢的原因是它依赖jruby虚拟机，jruby虚拟机就是用java语言开发的ruby虚拟机，本身java程序运行在jvm上就已经很慢了，而logstash还要运行在用java语言开发的ruby虚拟机上，就相当于虚拟机上跑一个虚拟机，可想而知；如果我们只需要收集和处理日志，在agent端如果运行logstash，显得格外的消耗资源；为了解决这种问题，elastic开发了一款更加轻量级的日志收集器beats；而filebeat只是其中的一种，它是基于收集本地日志文件中的内容，然后输出到某个地方；中间不会对日志做过多的处理；有点类似rsyslog，只做日志转发；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;171.5&quot;&gt;
&lt;p&gt;　　前面我们了解了elk集群中的logstash的用法，使用logstash处理日志挺好的，但是有一个缺陷，就是太慢了；当然logstash慢的原因是它依赖jruby虚拟机，jruby虚拟机就是用java语言开发的ruby虚拟机，本身java程序运行在jvm上就已经很慢了，而logstash还要运行在用java语言开发的ruby虚拟机上，就相当于虚拟机上跑一个虚拟机，可想而知；如果我们只需要收集和处理日志，在agent端如果运行logstash，显得格外的消耗资源；为了解决这种问题，elastic开发了一款更加轻量级的日志收集器beats；而filebeat只是其中的一种，它是基于收集本地日志文件中的内容，然后输出到某个地方；中间不会对日志做过多的处理；有点类似rsyslog，只做日志转发；如果我们需要对日志做处理，我们可以把filebeat的输出源配置成logstash，让logstash运行在一个独立的服务器上，专门做日志处理；&lt;/p&gt;
&lt;p&gt;　　filebeat收集日志过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004134807363-1484740335.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上是filebeat收集日志，然后把日志转发给logstash进行分析，然后logstash把filebeat发送过来的日志，做切词，分析，处理以后，然后在把日志发送给elasticsearch存储；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004135758089-1105623035.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：如果后端的filebeat一旦增多，logstash的压力会非常大，为了解决这样的问题，我们可在中间加redis是做临时缓存；然后logstash就到redis里读日志；然后再把读到的日志存储到elasticsearch中；当然filebeat也是可以直接将日志数据发送给elasticsearch进行存储；&lt;/p&gt;
&lt;p&gt;　　filebeat安装&lt;/p&gt;
&lt;p&gt;　　下载同elasticsearch版本的filebeat rpm包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.8.12-x86_64.rpm
--2020-10-04 14:03:03--  https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.8.12-x86_64.rpm
Resolving artifacts.elastic.co (artifacts.elastic.co)... 151.101.230.222, 2a04:4e42:36::734
Connecting to artifacts.elastic.co (artifacts.elastic.co)|151.101.230.222|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 11904164 (11M) [application/octet-stream]
Saving to: ‘filebeat-6.8.12-x86_64.rpm’

100%[================================================================================&amp;gt;] 11,904,164  9.76KB/s   in 16m 35s

2020-10-04 14:19:41 (11.7 KB/s) - ‘filebeat-6.8.12-x86_64.rpm’ saved [11904164/11904164]

[root@node03 ~]# ll
total 184540
-rw-r--r-- 1 root root  11904164 Aug 18 19:35 filebeat-6.8.12-x86_64.rpm
-rw-r--r-- 1 root root 177059640 Aug 18 19:41 logstash-6.8.12.rpm
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　安装filebeat-6.8.12.rpm包&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# yum install ./filebeat-6.8.12-x86_64.rpm -y
Loaded plugins: fastestmirror
Examining ./filebeat-6.8.12-x86_64.rpm: filebeat-6.8.12-1.x86_64
Marking ./filebeat-6.8.12-x86_64.rpm to be installed
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package filebeat.x86_64 0:6.8.12-1 will be installed
--&amp;gt; Finished Dependency Resolution

Dependencies Resolved

==========================================================================================================================
 Package                  Arch                   Version                    Repository                               Size
==========================================================================================================================
Installing:
 filebeat                 x86_64                 6.8.12-1                   /filebeat-6.8.12-x86_64                  38 M

Transaction Summary
==========================================================================================================================
Install  1 Package

Total size: 38 M
Installed size: 38 M
Downloading packages:
Running transaction check
Running transaction test
Transaction test succeeded
Running transaction
  Installing : filebeat-6.8.12-1.x86_64                                                                               1/1 
  Verifying  : filebeat-6.8.12-1.x86_64                                                                               1/1 

Installed:
  filebeat.x86_64 0:6.8.12-1                                                                                              

Complete!
[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：配置filebeat收集httpd的日志，然后将收集的日志输出到logstash&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004142614419-596556201.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示开启filebeat插件收集/var/log/httpd/access_log中的日志；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004142925396-108228385.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示把filebeat收集的日志发送给node03：5044；&lt;/p&gt;
&lt;p&gt;　　配置node03的logstash输入数据监听5044端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004143255452-1536169649.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示启动logstash中的beats插件作为数据输入，并监听5044端口；然后logstash将处理后端日志数据输出到标准输出；&lt;/p&gt;
&lt;p&gt;　　启动filebeat和logstash&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004144743375-1163097532.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到logstash启动时，它监听5044端口；&lt;/p&gt;
&lt;p&gt;　　用其他主机模拟互联网用户访问node03的httpd提供的页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node01 ~]# curl -H &quot;X-Forwarded-For:$[$RANDOM%223+1].$[RANDOM%255].$[RANDOM%255].$[RANDOM%255]&quot; http://node03/test$[$RANDOM%20+1].html
page 18
[root@node01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在node03的logstash的标准输出上，看看是否收集到httpd的访问日志？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;74&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
/usr/share/logstash/vendor/bundle/jruby/2.5.0/gems/awesome_print-1.7.0/lib/awesome_print/formatters/base_formatter.rb:31: warning: constant ::Fixnum is deprecated
{
            &quot;host&quot; =&amp;gt; {
                   &quot;os&quot; =&amp;gt; {
            &quot;platform&quot; =&amp;gt; &quot;centos&quot;,
             &quot;version&quot; =&amp;gt; &quot;7 (Core)&quot;,
              &quot;family&quot; =&amp;gt; &quot;redhat&quot;,
                &quot;name&quot; =&amp;gt; &quot;CentOS Linux&quot;,
            &quot;codename&quot; =&amp;gt; &quot;Core&quot;
        },
        &quot;containerized&quot; =&amp;gt; false,
         &quot;architecture&quot; =&amp;gt; &quot;x86_64&quot;,
                 &quot;name&quot; =&amp;gt; &quot;node03.test.org&quot;,
                   &quot;id&quot; =&amp;gt; &quot;002f3e572e3e4886ac9e98db8584b467&quot;
    },
      &quot;prospector&quot; =&amp;gt; {
        &quot;type&quot; =&amp;gt; &quot;log&quot;
    },
            &quot;auth&quot; =&amp;gt; &quot;-&quot;,
        &quot;clientip&quot; =&amp;gt; &quot;25.99.168.124&quot;,
           &quot;agent&quot; =&amp;gt; &quot;\&quot;curl/7.29.0\&quot;&quot;,
            &quot;tags&quot; =&amp;gt; [
        [0] &quot;beats_input_codec_plain_applied&quot;
    ],
      &quot;@timestamp&quot; =&amp;gt; 2020-10-04T06:49:34.000Z,
        &quot;@version&quot; =&amp;gt; &quot;1&quot;,
           &quot;bytes&quot; =&amp;gt; &quot;8&quot;,
          &quot;offset&quot; =&amp;gt; 0,
            &quot;verb&quot; =&amp;gt; &quot;GET&quot;,
        &quot;referrer&quot; =&amp;gt; &quot;\&quot;-\&quot;&quot;,
          &quot;source&quot; =&amp;gt; &quot;/var/log/httpd/access_log&quot;,
             &quot;log&quot; =&amp;gt; {
        &quot;file&quot; =&amp;gt; {
            &quot;path&quot; =&amp;gt; &quot;/var/log/httpd/access_log&quot;
        }
    },
    &quot;clientipInfo&quot; =&amp;gt; {
        &quot;continent_code&quot; =&amp;gt; &quot;EU&quot;,
             &quot;longitude&quot; =&amp;gt; -0.1224,
         &quot;country_code2&quot; =&amp;gt; &quot;GB&quot;,
                    &quot;ip&quot; =&amp;gt; &quot;25.99.168.124&quot;,
          &quot;country_name&quot; =&amp;gt; &quot;United Kingdom&quot;,
         &quot;country_code3&quot; =&amp;gt; &quot;GB&quot;,
              &quot;location&quot; =&amp;gt; {
            &quot;lat&quot; =&amp;gt; 51.4964,
            &quot;lon&quot; =&amp;gt; -0.1224
        },
              &quot;timezone&quot; =&amp;gt; &quot;Europe/London&quot;,
              &quot;latitude&quot; =&amp;gt; 51.4964
    },
            &quot;beat&quot; =&amp;gt; {
        &quot;hostname&quot; =&amp;gt; &quot;node03.test.org&quot;,
         &quot;version&quot; =&amp;gt; &quot;6.8.12&quot;,
            &quot;name&quot; =&amp;gt; &quot;node03.test.org&quot;
    },
         &quot;request&quot; =&amp;gt; &quot;/test18.html&quot;,
           &quot;input&quot; =&amp;gt; {
        &quot;type&quot; =&amp;gt; &quot;log&quot;
    },
           &quot;ident&quot; =&amp;gt; &quot;-&quot;,
        &quot;response&quot; =&amp;gt; &quot;200&quot;,
     &quot;httpversion&quot; =&amp;gt; &quot;1.1&quot;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在node03的标准输出上能够看到我们刚才访问httpd的访问日志；&lt;/p&gt;
&lt;p&gt;　　示例：配置filebeat将日志输出到elasticsearch&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004145900510-356562396.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　重启filebeat&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004145957488-1104971306.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　验证：访问httpd看看elasticsearch中是否有保存httpd的访问日志？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004150129800-460651237.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在elasticsearch中查看是否有新的index生成？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004150236480-2117060826.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到es上有一个新的index生成；&lt;/p&gt;
&lt;p&gt;　　查看es上存储的日志内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004150622792-638277479.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的返回的日志，存放在es中的日志并没有做拆分，说明filebeat只是把httpd的日志当作message字段的值处理，并没有去把ip地址信息做拆分；所以要想实现把日志内容拆分成不同字段，我们可以借助logstash，当然也可以在httpd上直接将日志格式记录为json格式，然后再由filebeat将日志信息传给es存储；&lt;/p&gt;
&lt;p&gt;　　示例：配置filebeat将收集的日志信息输出到redis&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004183103520-140971755.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置是配置filebeat将收集到的日志输出到redis；这里需要注意一点，这个配置文件是yml格式的文件，需要注意下面的缩进关系要对其；其次filebeat它不支持多路输出，例如，配置filebeat 输出到logstash，又配置filebeat输出到redis，这个它不支持，它支持单路输出；&lt;/p&gt;
&lt;p&gt; 　　重新启动filebeat&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004183544734-1780026222.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　用其他主机模拟访问httpd&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004183701215-190806649.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　验证：去node04上的redis 3号库查看是否有key生成？是否有数据？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004183857652-2119995140.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到此时redis的3号库有指定key生成，对应key里面也存了httpd的访问日志；&lt;/p&gt;
&lt;p&gt;　　配置logstash到redis上读数据，并删除filebeat的冗余字段&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node03 ~]# cat /etc/logstash/conf.d/httpd-es.conf
input {
    redis {
        host =&amp;gt; [&quot;node04&quot;]
        port =&amp;gt; 6379
        password =&amp;gt; &quot;admin&quot;
        key =&amp;gt; &quot;filebeat-node03-httpd-access_log&quot;
        db =&amp;gt; 3
        data_type =&amp;gt; &quot;list&quot;
    }
}

filter {
    grok {
        match =&amp;gt; {&quot;message&quot; =&amp;gt; &quot;%{HTTPD_COMBINEDLOG}&quot; }
        remove_field =&amp;gt; &quot;message&quot;
    }
    date {
        match =&amp;gt; [&quot;timestamp&quot;,&quot;dd/MMM/YYYY:H:m:s Z&quot;]
        remove_field =&amp;gt; &quot;timestamp&quot;
    }
    geoip {
        source =&amp;gt; &quot;clientip&quot;
        target =&amp;gt; &quot;geoip&quot;
        database =&amp;gt; &quot;/etc/logstash/geoip/GeoLite2-City.mmdb&quot;
    }
    mutate {
        rename =&amp;gt; [&quot;geoip&quot;, &quot;clientipInfo&quot; ]
        remove_field =&amp;gt; [&quot;@metadata&quot;,&quot;prospector&quot;,&quot;input&quot;,&quot;beat&quot;,&quot;host&quot;,&quot;id&quot;,&quot;containerized&quot;]
    }
}

output {
#    elasticsearch {
#       hosts =&amp;gt; [&quot;http://node01:9200&quot;,&quot;http://node02:9200&quot;]
#       index =&amp;gt; &quot;httpd.log&quot;
#       codec =&amp;gt; &quot;rubydebug&quot;
#    }
    stdout { codec =&amp;gt; &quot;rubydebug&quot; }
}

[root@node03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试语法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004190811569-1064397190.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　启动logstash&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004191146546-1425162973.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看输出到标准输出的日志信息是否还有filebeat生成的多余字段？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202010/1503305-20201004191253078-1186916708.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：现在从redis读出来的数据，然后经由logstash处理以后，filebeat生成的多余字段就删除了；后续我们就可以直接将这些日志数据放到es中存储；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 04 Oct 2020 11:29:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前面我们了解了elk集群中的logstash的用法，使用logstash处理日志挺好的，但是有一个缺陷，就是太慢了；当然logstash慢的原因是它依赖jruby虚拟机，jruby虚拟机就是用java</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13767152.html</dc:identifier>
</item>
</channel>
</rss>