<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何快速融入团队并成为团队核心（五） - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/12262437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/12262437.html</guid>
<description>&lt;p&gt;团队激励，有时候虽然被称为“胡萝卜加大棒”主义，这套做法其实和美国人在伊拉克或阿富汗搞的拉一派打一派的民族主义似乎差不多，似乎大家也不太愿意听，但是没办法，我们有时候还是得承认，这就是一个客观存在的现实问题。&lt;/p&gt;
&lt;p&gt;归根结底，其实每个人都是俗世中的人，难免逃脱不了对于物质和精神欲望的追求。&lt;/p&gt;
&lt;p&gt;不同的人在不同的阶段对于目标往往存在不同的衡量标准，有金钱的利益，也有对于声望上的追求，也有人其实看似没什么追求，其实也许也有追求，例如追求团队的认同感，追求工作和生活的平衡？追求更高层面的精神满足？追求在技术上的自我突破？&lt;/p&gt;

&lt;p&gt;我们的语言表达方式和肢体动作都是内心实际心理或甚至动机的投影，所以作为团队管理者，虽然不能仅凭一言一行来判断一个人的心态，但是如果他做出了明显异于自身常规做法的行为时，那就或许是在给你提醒了。&lt;/p&gt;
&lt;p&gt;例如，假设你们公司有一个同事，平时特别喜欢往公司寄快递，突然有一天不寄了，全往家里寄了，那搞不好就是有什么异常的动向了。或者有一位同事平时都特别易于沟通，然后有一天突然特别容易焦躁不安，对工作的事情开始排斥心理，当你问他问题时，他特别反感，或许就需要采取必要的引导措施，给他以激励，以便让他能够更好的为公司继续奋斗。有时有个人平时热衷于跟你讨论技术问题，但是有那么几天突然腻歪了，以至于让你从他的言谈举止中明显的看出来，那也是在暗示着什么。当然，以上这些表现并非都说明对方有离职的趋势，只是说他可能需要接受一些来自于组织的激励了。&lt;/p&gt;
&lt;p&gt;每个人都存在被激励的需求，那哪些需求是对大家来说必不可少的底线？哪些是能够让团队持续保持高昂的战斗力，又能紧密的团结到以老板为核心的组织周围，既能共同进退，又能游刃有余？&lt;/p&gt;
&lt;p&gt;管理学大佬赫茨伯格对这个有个总结，并形成了一个备受争议的理论，“双因素理论”，大概能够用来总结这些东西。&lt;/p&gt;

&lt;p&gt;在这个理论中，包含两个部分，分别是保健因素和激励性因素。&lt;/p&gt;
&lt;p&gt;保健因素是指在团队中能产生的效果能够起到“保健”的作用，保健能够从环境中消除对身心造成的伤害，虽然无法带来身心健康，但是他能起到预防疾病的作用。&lt;/p&gt;
&lt;p&gt;例如待遇问题。。很现实。有的老板说：我的钱都给足了，你还有什么不能满足的？好吧，其实钱的需求只是最基本的需求而已。他无法给人带来满意，只能使人维持在“既不是满意，又不是不满意的状态”。这种状态，大概有点像“我充满怨言，但是我忍了”。好吧。显然，这是一种危险的状态。当然，如果连金钱的基本需求都无法满足，试图靠XX主义的画饼，又如何能使团队成员获得激励？顶多就是维系了一群能够干事的绵羊，却总呼吁他们要保持狼性而已。&lt;/p&gt;
&lt;p&gt;除了金钱所涵盖的工资、福利待遇、物质工作条件外，还有公司政策、管理措施、监督、人际关系等。大概还有劳动生产工具，例如是否给开发者配备双显示器或者更好的机械键盘，这些能够极大的改善团队的保健性需求啊。。当然，如果给团队提供“马杀鸡”服务，虽然很奇葩，但是似乎能够对团队提供一定积极正面的效果？没有，只是让那些有怨言的人，多了个忍耐怨言的借口而已，以及在跟其他公司的人交流公司福利待遇时，多一个可以称赞公司的点。&lt;/p&gt;
&lt;p&gt;除此之外还有同事关系，同事关系能够给人带来激励么？大概可以，如果团队都很专业，大家干起来很轻松，确实能够带来激励，但是。。如果团队都不专业，或者虽然大家都很专业，但是天天加班，各种开会，常常因为拖工期而被迫赶工熬夜，哪怕大家平时相处的再好，也会充满怨言。&lt;/p&gt;
&lt;p&gt;激励因素是指与工作有关，能够令员工满意，激发员工以饱满的状态全付身心的投入到工作中，并把工作当做实现自己理想的因素。例如工作自身能否充满挑战？是不是过度充满挑战？ 例如工作中的认可、成就和责任感，以及技术进步等。&lt;/p&gt;
&lt;p&gt;尤其对于开发者来说，过于简单纯粹的工作并不能带来激励，就在于优秀开发者的心目中总有一种对于技术天然的追求，如果无法从现有工作中发掘到令其技术G点满意的内容，或多或少会使其逐渐离心。所以优秀的管理者乐于让团队钻研技术，并鼓励他们发现现有产品中的固有缺陷，并鼓励大家进行改进，这也能客观上起到激励的作用。Google每周允许开发者拿出20%的时间做与本职工作之外的其他技术工作，反而使得开发者能够更好的利用自己的工作时间，从而创造出了更大的价值。&lt;/p&gt;

&lt;p&gt;发掘团队的优点与适当的激励团队同样重要，根据每个人的特点选择不同的激励措施，例如，如果拆了四套房的，就别试图给金钱激励了，也许给点荣誉证书，对方就很开心了；而经济条件相对较差的，则不然。&lt;/p&gt;
&lt;p&gt;有的技术开发者不太擅长表达自己的技术专注点，但是又都愿意分享自己的收获，并希望能从团队分享中获得激励。但作为技术管理者最大的毛病就是吝惜表达自己的赞美，总是易于忽略对方的心理感受，甚至一根筋的认为对方是和自己一样的个体，当对方表达出独特见解时，甚至也许你的评价会过于锋芒，使得其他人关注于你的情绪，而非具体内容本身，这些同样会使人产生不舒适的感觉。&lt;/p&gt;
&lt;p&gt;团队中的每个成员都是有血有肉的个体组成的乌合之众，有自己的情绪，想法，文化倾向，也有抱怨和缺点，该如何适当的发掘团队的能力，使战斗力最大化呢？这从来就不是一个简单的问题。&lt;/p&gt;
</description>
<pubDate>Wed, 05 Feb 2020 00:28:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>一 团队激励，有时候虽然被称为“胡萝卜加大棒”主义，这套做法其实和美国人在伊拉克或阿富汗搞的拉一派打一派的民族主义似乎差不多，似乎大家也不太愿意听，但是没办法，我们有时候还是得承认，这就是一个客观存在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/12262437.html</dc:identifier>
</item>
<item>
<title>Kotlin DSL for HTML实例解析 - 圣骑士wind</title>
<link>http://www.cnblogs.com/mengdd/p/kotlin-dsl-for-html.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengdd/p/kotlin-dsl-for-html.html</guid>
<description>&lt;p&gt;Kotlin DSL, 指用Kotlin写的Domain Specific Language.&lt;br/&gt;本文通过解析官方的Kotlin DSL写html的例子, 来说明Kotlin DSL是什么.&lt;/p&gt;
&lt;p&gt;首先是一些基础知识, 包括什么是DSL, 实现DSL利用了那些Kotlin的语法, 常用的情形和流行的库.&lt;/p&gt;
&lt;p&gt;对html实例的解析, 没有一冲上来就展示正确答案, 而是按照分析需求, 设计, 和实现细化的步骤来逐步让解决方案变得明朗清晰.&lt;/p&gt;
&lt;h2 id=&quot;理论基础&quot;&gt;理论基础&lt;/h2&gt;
&lt;h3 id=&quot;dsl-领域特定语言&quot;&gt;DSL: 领域特定语言&lt;/h3&gt;
&lt;p&gt;DSL: Domain Specific Language.&lt;br/&gt;专注于一个方面而特殊设计的语言.&lt;/p&gt;
&lt;p&gt;可以看做是封装了一套东西, 用于特定的功能, 优势是复用性和可读性的增强. -&amp;gt; 意思是提取了一套库吗?&lt;/p&gt;
&lt;p&gt;不是.&lt;/p&gt;
&lt;p&gt;DSL和简单的方法提取不同, 有可能代码的形式或者语法变了, 更接近自然语言, 更容易让人看懂.&lt;/p&gt;
&lt;h3 id=&quot;kotlin语言基础&quot;&gt;Kotlin语言基础&lt;/h3&gt;
&lt;p&gt;做一个DSL, 改变语法, 在Kotlin中主要依靠:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;lambda表达式.&lt;/li&gt;
&lt;li&gt;扩展方法.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三个lambda语法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果只有一个参数, 可以用&lt;code&gt;it&lt;/code&gt;直接表示.&lt;/li&gt;
&lt;li&gt;如果lambda表达式是函数的最后一个参数, 可以移到小括号&lt;code&gt;()&lt;/code&gt;外面. 如果lambda是唯一的参数, 可以省略小括号&lt;code&gt;()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;lambda可以带receiver.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;扩展方法.&lt;/p&gt;
&lt;h3 id=&quot;流行的dsl使用场景&quot;&gt;流行的DSL使用场景&lt;/h3&gt;
&lt;p&gt;Gradle的build文件就是用DSL写的.&lt;br/&gt;之前是Groovy DSL, 现在也有Kotlin DSL了.&lt;/p&gt;
&lt;p&gt;还有&lt;a href=&quot;https://github.com/Kotlin/anko&quot;&gt;Anko&lt;/a&gt;.&lt;br/&gt;这个库包含了很多功能, UI组件, 网络, 后台任务, 数据库等.&lt;/p&gt;
&lt;p&gt;和服务器端用的: &lt;a href=&quot;https://ktor.io/servers/features/routing.html&quot;&gt;Ktor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;应用场景: Type-Safe Builders&lt;br/&gt;type-safe builders指类型安全, 静态类型的builders.&lt;/p&gt;
&lt;p&gt;这种builders就比较适合创建Kotlin DSL, 用于构建复杂的层级结构数据, 用半陈述式的方式.&lt;/p&gt;
&lt;p&gt;官方文档举的是html的例子.&lt;br/&gt;后面就对这个例子进行一个梳理和解析.&lt;/p&gt;
&lt;h2 id=&quot;html实例解析&quot;&gt;html实例解析&lt;/h2&gt;
&lt;h3 id=&quot;需求分析&quot;&gt;1 需求分析&lt;/h3&gt;
&lt;p&gt;首先明确一下我们的目标.&lt;/p&gt;
&lt;p&gt;做一个最简单的假设, 我们期待的结果是在Kotlin代码中类似这样写:&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;html {
    head { }
    body { }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就能输出这样的文本:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;发现1-调用形式&quot;&gt;发现1: 调用形式&lt;/h4&gt;
&lt;p&gt;仔细观察第一段Kotlin代码, &lt;code&gt;html{}&lt;/code&gt;应该是一个方法调用, 只不过这个方法只有一个lambda表达式作为参数, 所以省略了&lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;里面的&lt;code&gt;head{}&lt;/code&gt;和&lt;code&gt;body{}&lt;/code&gt;也是同理, 都是两个以lambda作为唯一参数的方法.&lt;/p&gt;
&lt;h4 id=&quot;发现2-层级关系&quot;&gt;发现2: 层级关系&lt;/h4&gt;
&lt;p&gt;因为标签的层级关系, 可以理解为每个标签都负责自己包含的内容, 父标签只负责按顺序显示子标签的内容.&lt;/p&gt;
&lt;h4 id=&quot;发现3-调用限制&quot;&gt;发现3: 调用限制&lt;/h4&gt;
&lt;p&gt;由于&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;等标签只在&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;标签中才有意义, 所以应该限制外部只能调用&lt;code&gt;html{}&lt;/code&gt;方法, &lt;code&gt;head{}&lt;/code&gt;和&lt;code&gt;body{}&lt;/code&gt;方法只有在&lt;code&gt;html{}&lt;/code&gt;的方法体中才能调用.&lt;/p&gt;
&lt;h4 id=&quot;发现4-应该需要完成的&quot;&gt;发现4: 应该需要完成的&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;如何加入和显示文字.&lt;/li&gt;
&lt;li&gt;标签可能有自己的属性.&lt;/li&gt;
&lt;li&gt;标签应该有正确的缩进.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;设计&quot;&gt;2 设计&lt;/h3&gt;
&lt;h4 id=&quot;标签基类&quot;&gt;标签基类&lt;/h4&gt;
&lt;p&gt;因为标签看起来都是类似的, 为了代码复用, 首先设计一个抽象的标签类&lt;code&gt;Tag&lt;/code&gt;, 包含:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标签名称.&lt;/li&gt;
&lt;li&gt;一个子标签的list.&lt;/li&gt;
&lt;li&gt;一个属性列表.&lt;/li&gt;
&lt;li&gt;一个渲染方法, 负责输出本标签内容(包含标签名, 子标签和所有属性).&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;怎么加文字&quot;&gt;怎么加文字&lt;/h4&gt;
&lt;p&gt;文字比较特殊, 它不带标签符号&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, 就输出自己.&lt;br/&gt;所以它的渲染方法就是输出文字本身.&lt;/p&gt;
&lt;p&gt;可以提取出一个更加基类的接口&lt;code&gt;Element&lt;/code&gt;, 只包含渲染方法. 这个接口的子类是&lt;code&gt;Tag&lt;/code&gt;和&lt;code&gt;TextElement&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;有文字的标签, 如&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;, 它的输出结果:&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;    &amp;lt;title&amp;gt;
      HTML encoding with Kotlin
    &amp;lt;/title&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文字元素是作为标签的一个子标签的.&lt;br/&gt;这里的实现不容易自己想到, 直接看后面的实现部分揭晓答案吧.&lt;/p&gt;
&lt;h3 id=&quot;实现&quot;&gt;3 实现&lt;/h3&gt;
&lt;p&gt;有了前面的心路历程, 再来看实现就能容易一些.&lt;/p&gt;
&lt;h4 id=&quot;基类实现&quot;&gt;基类实现&lt;/h4&gt;
&lt;p&gt;首先是最基本的接口, 只包含了渲染方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;interface Element {
    fun render(builder: StringBuilder, indent: String)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的直接子类标签类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class Tag(val name: String) : Element {
    val children = arrayListOf&amp;lt;Element&amp;gt;()
    val attributes = hashMapOf&amp;lt;String, String&amp;gt;()

    protected fun &amp;lt;T : Element&amp;gt; initTag(tag: T, init: T.() -&amp;gt; Unit): T {
        tag.init()
        children.add(tag)
        return tag
    }

    override fun render(builder: StringBuilder, indent: String) {
        builder.append(&quot;$indent&amp;lt;$name${renderAttributes()}&amp;gt;\n&quot;)
        for (c in children) {
            c.render(builder, indent + &quot;  &quot;)
        }
        builder.append(&quot;$indent&amp;lt;/$name&amp;gt;\n&quot;)
    }

    private fun renderAttributes(): String {
        val builder = StringBuilder()
        for ((attr, value) in attributes) {
            builder.append(&quot; $attr=\&quot;$value\&quot;&quot;)
        }
        return builder.toString()
    }

    override fun toString(): String {
        val builder = StringBuilder()
        render(builder, &quot;&quot;)
        return builder.toString()
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成了自身标签名和属性的渲染, 接着遍历子标签渲染其内容. 注意这里为所有子标签加上了一层缩进.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initTag()&lt;/code&gt;这个方法是&lt;code&gt;protected&lt;/code&gt;的, 供子类调用, 为自己加上子标签.&lt;/p&gt;
&lt;h4 id=&quot;带文字的标签&quot;&gt;带文字的标签&lt;/h4&gt;
&lt;p&gt;带文字的标签有个抽象的基类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;abstract class TagWithText(name: String) : Tag(name) {
    operator fun String.unaryPlus() {
        children.add(TextElement(this))
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个对&lt;code&gt;+&lt;/code&gt;运算符的重载, 这个扩展方法把字符串包装成&lt;code&gt;TextElement&lt;/code&gt;类对象, 然后加到当前标签的子标签中去.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TextElement&lt;/code&gt;做的事情就是渲染自己:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class TextElement(val text: String) : Element {
    override fun render(builder: StringBuilder, indent: String) {
        builder.append(&quot;$indent$text\n&quot;)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以, 当我们调用:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;html {
    head {
        title { +&quot;HTML encoding with Kotlin&quot; }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;
      HTML encoding with Kotlin
    &amp;lt;/title&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中用到的&lt;code&gt;Title&lt;/code&gt;类定义:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Title : TagWithText(&quot;title&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过'+'运算符的操作, 字符串: &quot;HTML encoding with Kotlin&quot;被包装成了&lt;code&gt;TextElement&lt;/code&gt;, 他是title标签的child.&lt;/p&gt;
&lt;h4 id=&quot;程序入口&quot;&gt;程序入口&lt;/h4&gt;
&lt;p&gt;对外的公开方法只有这一个:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fun html(init: HTML.() -&amp;gt; Unit): HTML {
    val html = HTML()
    html.init()
    return html
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;init&lt;/code&gt;参数是一个函数, 它的类型是&lt;code&gt;HTML.() -&amp;gt; Unit&lt;/code&gt;. 这是一个带接收器的函数类型, 也就是说, 需要一个&lt;code&gt;HTML&lt;/code&gt;类型的实例来调用这个函数.&lt;/p&gt;
&lt;p&gt;这个方法实例化了一个&lt;code&gt;HTML&lt;/code&gt;类对象, 在实例上调用传入的lambda参数, 然后返回该对象.&lt;/p&gt;
&lt;p&gt;调用此lambda的实例会被作为&lt;code&gt;this&lt;/code&gt;传入函数体内(&lt;code&gt;this&lt;/code&gt;可以省略), 我们在函数体内就可以调用&lt;code&gt;HTML&lt;/code&gt;类的成员方法了.&lt;/p&gt;
&lt;p&gt;这样保证了外部的访问入口, 只有:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;html {
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过成员函数创建内部标签.&lt;/p&gt;
&lt;h4 id=&quot;html类&quot;&gt;HTML类&lt;/h4&gt;
&lt;p&gt;HTML类如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class HTML : TagWithText(&quot;html&quot;) {
    fun head(init: Head.() -&amp;gt; Unit) = initTag(Head(), init)

    fun body(init: Body.() -&amp;gt; Unit) = initTag(Body(), init)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出&lt;code&gt;html&lt;/code&gt;内部可以通过调用&lt;code&gt;head&lt;/code&gt;和&lt;code&gt;body&lt;/code&gt;方法创建子标签, 也可以用&lt;code&gt;+&lt;/code&gt;来添加字符串.&lt;/p&gt;
&lt;p&gt;这两个方法本来可以是这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fun head(init: Head.() -&amp;gt; Unit) : Head {
    val head = Head()
    head.init()
    children.add(head)
    return head
}

fun body(init: Body.() -&amp;gt; Unit) : Body {
    val body = Body()
    body.init()
    children.add(body)
    return body
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于形式类似, 所以做了泛型抽象, 被提取到了基类&lt;code&gt;Tag&lt;/code&gt;中, 作为更加通用的方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected fun &amp;lt;T : Element&amp;gt; initTag(tag: T, init: T.() -&amp;gt; Unit): T {
    tag.init()
    children.add(tag)
    return tag
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;做的事情: 创建对象, 在其之上调用init lambda, 添加到子标签列表, 然后返回.&lt;/p&gt;
&lt;p&gt;其他标签类的实现与之类似, 不作过多解释.&lt;/p&gt;
&lt;h3 id=&quot;修bug-隐式receiver穿透问题&quot;&gt;4 修Bug: 隐式receiver穿透问题&lt;/h3&gt;
&lt;p&gt;以上都写完了之后, 感觉大功告成, 但其实还有一个隐患.&lt;/p&gt;
&lt;p&gt;我们居然可以这样写:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;html {
    head {
        title { +&quot;HTML encoding with Kotlin&quot; }
        head { +&quot;haha&quot; }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在head方法的lambda块中, html块的receiver仍然是可见的, 所以还可以调用&lt;code&gt;head&lt;/code&gt;方法.&lt;br/&gt;显式地调用是这样的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;this@html.head { +&quot;haha&quot; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这里&lt;code&gt;this@html.&lt;/code&gt;是可以省略的.&lt;/p&gt;
&lt;p&gt;这段代码输出的是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    haha
  &amp;lt;/head&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;
      HTML encoding with Kotlin
    &amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最内层的haha反倒是最先被加到html对象的孩子列表里.&lt;/p&gt;
&lt;p&gt;这种穿透性太混乱了, 容易导致错误, 我们能不能限制每个大括号里只有当前的对象成员是可访问的呢? -&amp;gt; 可以.&lt;/p&gt;
&lt;p&gt;为了解决这种问题, Kotlin 1.1推出了管理receiver scope的机制, 解决方法是使用&lt;code&gt;@DslMarker&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;html的例子, 定义注解类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@DslMarker
annotation class HtmlTagMarker&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种被&lt;code&gt;@DslMarker&lt;/code&gt;修饰的注解类叫做&lt;code&gt;DSL marker&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;然后我们只需要在基类上标注:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@HtmlTagMarker
abstract class Tag(val name: String)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有的子类都会被认为也标记了这个marker.&lt;/p&gt;
&lt;p&gt;加上注解之后隐式访问会编译报错:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;html {
    head {
        head { } // error: a member of outer receiver
    }
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是显式还是可以的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;html {
    head {
        this@html.head { } // possible
    }
    // ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有最近的receiver对象可以隐式访问.&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文通过实例, 来逐步解析如何用Kotlin代码, 用半陈述式的方式写html结构, 从而看起来更加直观. 这种就叫做DSL.&lt;/p&gt;
&lt;p&gt;Kotlin DSL通过精心的定义, 主要的目的是为了让使用者更加方便, 代码更加清晰直观.&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;More resources:&lt;/p&gt;
</description>
<pubDate>Tue, 04 Feb 2020 23:57:00 +0000</pubDate>
<dc:creator>圣骑士wind</dc:creator>
<og:description>Kotlin DSL, 指用Kotlin写的Domain Specific Language. 本文通过解析官方的Kotlin DSL写html的例子, 来说明Kotlin DSL是什么.  首先是一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengdd/p/kotlin-dsl-for-html.html</dc:identifier>
</item>
<item>
<title>Spring（四）核心容器 - BeanDefinition 解析 - 龙四丶</title>
<link>http://www.cnblogs.com/loongk/p/12262101.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loongk/p/12262101.html</guid>
<description>&lt;p&gt;在上篇文章中，我们讨论了 refresh 的前四个方法，主要是对 ApplicationContext 上下文启动做一些准备工作。原计划是对接下来的 invokeBeanFactoryPostProcessors 方法进行讨论，但该方法涉及 Spring 中一个非常重要的概念： BeanDefinition，所以，这里先对 BeanDefinition 进行讨论，这样也有利于完善 Spring 的知识体系。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注：本篇文章使用的 SpringBoot 版本为 2.0.3.RELEASE，其 Spring 版本为 5.0.7.RELEASE&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现如今，我们一般获取对象的方式有两种，一种是手动直接 new；另一种是交给 Spring 管理，Spring 将管理的对象称之为 Bean，容器会先实例化 Bean，然后自动注入，实例化的过程就需要依赖 BeanDefinition。&lt;/p&gt;
&lt;p&gt;BeanDefinition 用于保存 Bean 的相关信息，包括属性、构造方法参数、依赖的 Bean 名称及是否单例、延迟加载等，它是实例化 Bean 的原材料，Spring 就是根据 BeanDefinition 中的信息实例化 Bean。&lt;/p&gt;
&lt;h2 id=&quot;beandefinition的继承体系&quot;&gt;BeanDefinition的继承体系&lt;/h2&gt;
&lt;p&gt;BeanDefinition 是一个接口，它有多个实现类，这些实现类分别描述不同类型的 Bean。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gbhqndzte2j31i00cqq7k.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;beandefinition&quot;&gt;BeanDefinition&lt;/h3&gt;
&lt;p&gt;一个 BeanDefinition 描述了一个 Bean 实例，实例包含属性值、构造方法参数值以及更多实现信息。该 BeanDefinition 只是是一个最小的接口，主要目的是允许修改属性值和其他 Bean 元数据，这里列出几个核心方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {

    // 单例、原型标识符
    String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;
    String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;

    // 标识 Bean 的类别，分别对应 用户定义的 Bean、来源于配置文件的 Bean、Spring 内部的 Bean
    int ROLE_APPLICATION = 0;
    int ROLE_SUPPORT = 1;
    int ROLE_INFRASTRUCTURE = 2;

    // 设置、返回 Bean 的父类名称
    void setParentName(@Nullable String parentName);
    String getParentName();

    // 设置、返回 Bean 的 className
    void setBeanClassName(@Nullable String beanClassName);
    String getBeanClassName();

    // 设置、返回 Bean 的作用域
    void setScope(@Nullable String scope);
    String getScope();

    // 设置、返回 Bean 是否懒加载
    void setLazyInit(boolean lazyInit);
    boolean isLazyInit();
    
    // 设置、返回当前 Bean 所依赖的其它 Bean 名称。
    void setDependsOn(@Nullable String... dependsOn);
    String[] getDependsOn();
    
    // 设置、返回 Bean 是否可以自动注入。只对 @Autowired 注解有效
    void setAutowireCandidate(boolean autowireCandidate);
    boolean isAutowireCandidate();
    
    // 设置、返回当前 Bean 是否为主要候选 Bean 。
    // 当同一个接口有多个实现类时，通过该属性来配置某个 Bean 为主候选 Bean。
    void setPrimary(boolean primary);
    boolean isPrimary();

    // 设置、返回创建该 Bean 的工厂类。
    void setFactoryBeanName(@Nullable String factoryBeanName);
    String getFactoryBeanName();
    
    // 设置、返回创建该 Bean 的工厂方法
    void setFactoryMethodName(@Nullable String factoryMethodName);
    String getFactoryMethodName();
    
    // 返回该 Bean 构造方法参数值、所有属性
    ConstructorArgumentValues getConstructorArgumentValues();
    MutablePropertyValues getPropertyValues();

    // 返回该 Bean 是否是单例、是否是非单例、是否是抽象的
    boolean isSingleton();
    boolean isPrototype();
    boolean isAbstract();

    // 返回 Bean 的类别。类别对应上面的三个属性值。
    int getRole();

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 BeanDefinition 接口提供了一系列操作 Bean 元数据的set、get方法，这些操作为 Bean 的描述定义了一套模板，具体的实现则交由子类。&lt;/p&gt;
&lt;h3 id=&quot;annotatedbeandefinition&quot;&gt;AnnotatedBeanDefinition&lt;/h3&gt;
&lt;p&gt;AnnotatedBeanDefinition 是 BeanDefinition 子接口之一，该接口扩展了 BeanDefinition 的功能，其用来操作注解元数据。一般情况下，通过注解方式得到的 Bean（@Component、@Bean），其 BeanDefinition 类型都是该接口的实现类。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface AnnotatedBeanDefinition extends BeanDefinition {

    // 获得当前 Bean 的注解元数据
    AnnotationMetadata getMetadata();

    // 获得当前 Bean 的工厂方法上的元数据
    MethodMetadata getFactoryMethodMetadata();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该接口可以返回两个元数据的类：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;AnnotationMetadata：主要对 Bean 的注解信息进行操作，如：获取当前 Bean 标注的所有注解、判断是否包含指定注解。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;MethodMetadata：方法的元数据类。提供获取方法名称、此方法所属类的全类名、是否是抽象方法、判断是否是静态方法、判断是否是final方法等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;abstractbeandefinition&quot;&gt;AbstractBeanDefinition&lt;/h3&gt;
&lt;p&gt;AbstractBeanDefinition 是 BeanDefinition 的子抽象类，也是其他 BeanDefinition 类型的基类，其实现了接口中定义的一系列操作方法，并定义了一系列的常量属性，这些常量会直接影响到 Spring 实例化 Bean 时的策略。核心属性如下。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor
        implements BeanDefinition, Cloneable {

    // 默认的 SCOPE，默认是单例
    public static final String SCOPE_DEFAULT = &quot;&quot;;

    // 不进行自动装配
    public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;
    // 根据 Bean 的名字进行自动装配，byName
    public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;
    // 根据 Bean 的类型进行自动装配，byType
    public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;
    // 根据构造器进行自动装配
    public static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;
    // 首先尝试按构造器自动装配。如果失败，再尝试使用 byType 进行自动装配。（Spring 3.0 之后已废除）
    public static final int AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;

    // 通过依赖检查来查看 Bean 的每个属性是否都设置完成
    // 以下常量分别对应：不检查、对依赖对象检查、对基本类型，字符串和集合进行检查、对全部属性进行检查
    public static final int DEPENDENCY_CHECK_NONE = 0;
    public static final int DEPENDENCY_CHECK_OBJECTS = 1;
    public static final int DEPENDENCY_CHECK_SIMPLE = 2;
    public static final int DEPENDENCY_CHECK_ALL = 3;

    // 关闭应用上下文时需调用的方法名称
    public static final String INFER_METHOD = &quot;(inferred)&quot;;

    // 存放 Bean 的 Class 对象
    private volatile Object beanClass;

    // Bean 的作用范围
    private String scope = SCOPE_DEFAULT;

    // 非抽象
    private boolean abstractFlag = false;
    // 非延迟加载
    private boolean lazyInit = false;
    // 默认不自动装配
    private int autowireMode = AUTOWIRE_NO;
    // 默认不依赖检查
    private int dependencyCheck = DEPENDENCY_CHECK_NONE;

    // 依赖的 Bean 列表
    private String[] dependsOn;

    // 可以作为自动装配的候选者，意味着可以自动装配到其他 Bean 的某个属性中
    private boolean autowireCandidate = true;
    
    // 创建当前 Bean 实例工厂类名称
    private String factoryBeanName;
    // 创建当前 Bean 实例工厂类中方法名称
    private String factoryMethodName;

    // 存储构造方法的参数
    private ConstructorArgumentValues constructorArgumentValues;
    // 存储 Bean 属性名称以及对应的值
    private MutablePropertyValues propertyValues;
    // 存储被覆盖的方法信息
    private MethodOverrides methodOverrides;

    // init、destroy 方法名称
    private String initMethodName;
    private String destroyMethodName;

    // 是否执行 init 和 destroy 方法
    private boolean enforceInitMethod = true;
    private boolean enforceDestroyMethod = true;

    // Bean 是否是用户定义的而不是应用程序本身定义的
    private boolean synthetic = false;

    // Bean 的身份类别，默认是用户定义的 Bean
    private int role = BeanDefinition.ROLE_APPLICATION;

    // Bean 的描述信息
    private String description;

    // Bean 定义的资源
    private Resource resource;
    
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是 AbstractBeanDefinition 中定义的一些常量和属性，该类中还有一部分是操作这些属性的 set 和 get 方法，这些方法都由子类来操作，且应用程序中真正使用的也是这些子类 BeanDefinition。&lt;/p&gt;
&lt;p&gt;先来看 AbstractBeanDefinition 直接实现类：RootBeanDefinition、GenericBeanDefinition、ChildBeanDefinition。&lt;/p&gt;
&lt;h4 id=&quot;rootbeandefinition&quot;&gt;RootBeanDefinition&lt;/h4&gt;
&lt;p&gt;该类继承自 AbstractBeanDefinition，它可以单独作为一个 BeanDefinition，也可以作为其他 BeanDefinition 的父类。&lt;/p&gt;
&lt;p&gt;RootBeanDefinition 在 AbstractBeanDefinition 的基础上定义了更多属性。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RootBeanDefinition extends AbstractBeanDefinition {

    // BeanDefinitionHolder 存储 Bean 的名称、别名、BeanDefinition
    private BeanDefinitionHolder decoratedDefinition;

    // AnnotatedElement 是java反射包的接口，通过它可以查看 Bean 的注解信息
    private AnnotatedElement qualifiedElement;

    // 允许缓存
    boolean allowCaching = true;
    
    // 工厂方法是否唯一
    boolean isFactoryMethodUnique = false;

    // 封装了 java.lang.reflect.Type，提供了泛型相关的操作
    volatile ResolvableType targetType;

    // 缓存 Class，表示 RootBeanDefinition 存储哪个类的信息
    volatile Class&amp;lt;?&amp;gt; resolvedTargetType;

    // 缓存工厂方法的返回类型
    volatile ResolvableType factoryMethodReturnType;

    // 这是以下四个构造方法字段的通用锁
    final Object constructorArgumentLock = new Object();
    // 用于缓存已解析的构造方法或工厂方法
    Executable resolvedConstructorOrFactoryMethod;
    // 将构造方法参数标记为已解析
    boolean constructorArgumentsResolved = false;
    // 用于缓存完全解析的构造方法参数
    Object[] resolvedConstructorArguments;
    // 缓存待解析的构造方法参数
    Object[] preparedConstructorArguments;

    // 这是以下两个后处理字段的通用锁
    final Object postProcessingLock = new Object();
    // 表明是否被 MergedBeanDefinitionPostProcessor 处理过
    boolean postProcessed = false;
    // 在生成代理的时候会使用，表明是否已经生成代理
    volatile Boolean beforeInstantiationResolved;

    // 实际缓存的类型是 Constructor、Field、Method 类型
    private Set&amp;lt;Member&amp;gt; externallyManagedConfigMembers;

    // InitializingBean中 的 init 回调函数名 afterPropertiesSet 会在这里记录，以便进行生命周期回调
    private Set&amp;lt;String&amp;gt; externallyManagedInitMethods;

    // DisposableBean 的 destroy 回调函数名 destroy 会在这里记录，以便进生命周期回调
    private Set&amp;lt;String&amp;gt; externallyManagedDestroyMethods;

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;childbeandefinition&quot;&gt;ChildBeanDefinition&lt;/h4&gt;
&lt;p&gt;该类继承自 AbstractBeanDefinition。其相当于一个子类，不可以单独存在，必须依赖一个父 BeanDetintion，构造 ChildBeanDefinition 时，通过构造方法传入父 BeanDetintion 的名称或通过 setParentName 设置父名称。它可以从父类继承方法参数、属性值，并可以重写父类的方法，同时也可以增加新的属性或者方法。若重新定义 init 方法，destroy 方法或者静态工厂方法，ChildBeanDefinition 会重写父类的设置。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;从 Spring 2.5 开始，以编程方式注册 Bean 定义的首选方法是 GenericBeanDefinition，GenericBeanDefinition 可以有效替代 ChildBeanDefinition 的绝大分部使用场合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;genericbeandefinition&quot;&gt;GenericBeanDefinition&lt;/h4&gt;
&lt;p&gt;GenericBeanDefinition 是 Spring 2.5 以后新引入的 BeanDefinition，是 ChildBeanDefinition 更好的替代者，它同样可以通过 setParentName 方法设置父 BeanDefinition。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;最后三个 BeanDefinition 既实现了 AnnotatedBeanDefinition 接口，又间接继承 AbstractBeanDefinition 抽象类，这些 BeanDefinition 描述的都是注解形式的 Bean。&lt;/p&gt;
&lt;h4 id=&quot;configurationclassbeandefinition&quot;&gt;ConfigurationClassBeanDefinition&lt;/h4&gt;
&lt;p&gt;该类继承自 RootBeanDefinition ，并实现了 AnnotatedBeanDefinition 接口。这个 BeanDefinition 用来描述在标注 @Configuration 注解的类中，通过 @Bean 注解实例化的 Bean。&lt;/p&gt;
&lt;p&gt;其功能特点如下：&lt;/p&gt;
&lt;p&gt;1、如果 @Bean 注解没有指定 Bean 的名字，默认会用方法的名字命名 Bean。&lt;/p&gt;
&lt;p&gt;2、标注 @Configuration 注解的类会成为一个工厂类，而标注 @Bean 注解的方法会成为工厂方法，通过工厂方法实例化 Bean，而不是直接通过构造方法初始化。&lt;/p&gt;
&lt;p&gt;3、标注 @Bean 注解的类会使用构造方法自动装配&lt;/p&gt;
&lt;h4 id=&quot;annotatedgenericbeandefinition&quot;&gt;AnnotatedGenericBeanDefinition&lt;/h4&gt;
&lt;p&gt;该类继承自 GenericBeanDefinition ，并实现了 AnnotatedBeanDefinition 接口。这个 BeanDefinition 用来描述标注 @Configuration 注解的 Bean。&lt;/p&gt;
&lt;h4 id=&quot;scannedgenericbeandefinition&quot;&gt;ScannedGenericBeanDefinition&lt;/h4&gt;
&lt;p&gt;该类继承自 GenericBeanDefinition ，并实现了 AnnotatedBeanDefinition 接口。这个 BeanDefinition 用来描述标注 @Component 注解的 Bean，其派生注解如 @Service、@Controller 也同理。&lt;/p&gt;

&lt;p&gt;最后，我们来做个总结。BeanDefinition 主要是用来描述 Bean，其存储了 Bean 的相关信息，Spring 实例化 Bean 时需读取该 Bean 对应的 BeanDefinition。BeanDefinition 整体可以分为两类，一类是描述通用的 Bean，还有一类是描述注解形式的 Bean。一般前者在 XML 时期定义 &amp;lt;bean‘&amp;gt; 标签以及在 Spring 内部使用较多，而现今我们大都使用后者，通过注解形式加载 Bean。&lt;/p&gt;

&lt;p&gt;以上就是本章内容，如果文章中有错误或者需要补充的请及时提出，本人感激不尽。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;http://cmsblogs.com/?p=11731&lt;br/&gt;https://cloud.tencent.com/developer/article/1497805&lt;/p&gt;
</description>
<pubDate>Tue, 04 Feb 2020 15:32:00 +0000</pubDate>
<dc:creator>龙四丶</dc:creator>
<og:description>前言 在上篇文章中，我们讨论了 refresh 的前四个方法，主要是对 ApplicationContext 上下文启动做一些准备工作。原计划是对接下来的 invokeBeanFactoryPostP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/loongk/p/12262101.html</dc:identifier>
</item>
<item>
<title>SparkSQL 如何自定义函数 - 顾鹏pen</title>
<link>http://www.cnblogs.com/tjpeng/p/12261901.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tjpeng/p/12261901.html</guid>
<description>
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tjpeng/p/12261901.html#s1&quot;&gt;1. SparkSql如何自定义函数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tjpeng/p/12261901.html#s2&quot;&gt;2. 示例：Average&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tjpeng/p/12261901.html#s4&quot;&gt;3. 类型安全的自定义函数&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1. SparkSql如何自定义函数？&lt;/h3&gt;
&lt;p&gt;　　spark中我们定义一个函数，需要继承 UserDefinedAggregateFunction这个抽象类，实现这个抽象类中所定义的方法，这是一个&lt;strong&gt;模板设计模式？&lt;/strong&gt; 我只要实现抽象类的中方法，具体的所有的计算步骤由内部完成。而我们可以看一下UserDefinedAggregateFunction这个抽象类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
package org.apache.spark.sql.expressions&lt;br/&gt;@org.apache.spark.annotation.InterfaceStability.Stable&lt;br/&gt;abstract class UserDefinedAggregateFunction() extends scala.AnyRef with scala.Serializable {
  def &lt;strong&gt;inputSchema&lt;/strong&gt; : org.apache.spark.sql.types.StructType
  def &lt;strong&gt;bufferSchema&lt;/strong&gt; : org.apache.spark.sql.types.StructType
  def &lt;strong&gt;dataType&lt;/strong&gt; : org.apache.spark.sql.types.DataType
  def &lt;strong&gt;deterministic&lt;/strong&gt; : scala.Boolean
  def &lt;strong&gt;initialize&lt;/strong&gt;(buffer : org.apache.spark.sql.expressions.MutableAggregationBuffer) : scala.Unit
  def &lt;strong&gt;update&lt;/strong&gt;(buffer : org.apache.spark.sql.expressions.MutableAggregationBuffer, input : org.apache.spark.sql.Row) : scala.Unit
  def &lt;strong&gt;merge&lt;/strong&gt;(buffer1 : org.apache.spark.sql.expressions.MutableAggregationBuffer, buffer2 : org.apache.spark.sql.Row) : scala.Unit
  def &lt;strong&gt;evaluate&lt;/strong&gt;(buffer : org.apache.spark.sql.Row) : scala.Any
  @scala.annotation.varargs
  def apply(exprs : org.apache.spark.sql.Column*) : org.apache.spark.sql.Column = { /* compiled code */ }
  @scala.annotation.varargs
  def distinct(exprs : org.apache.spark.sql.Column*) : org.apache.spark.sql.Column = { /* compiled code */ }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也就是说对于这几个函数，我们只要依次实现他们的功能，其余的交给spark就可以了。&lt;/p&gt;

&lt;h3&gt;2. 自定义Average函数&lt;/h3&gt;
&lt;p&gt;　　首先新建一个Object类MyAvage类，继承UserDefinedAggregateFunction。下面对每一个函数的实现进行解释。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def inputSchema: StructType = StructType(StructField(&quot;inputColumn&quot;, LongType) :: Nil)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个规定了输入数据的数据结构&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
def bufferSchema: StructType = {
    StructType(StructField(&quot;sum&quot;, LongType) :: StructField(&quot;count&quot;, LongType) :: Nil)
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个规定了缓存区的数据结构&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def dataType: DataType = DoubleType
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个规定了返回值的数据类型&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
def deterministic: Boolean = true
def initialize(buffer: MutableAggregationBuffer): Unit = {
    buffer(0) = 0L
    buffer(1) = 0L
  }　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进行初始化，这里要说明一下，官网中提到：&lt;/p&gt;
&lt;pre&gt;
&lt;span class=&quot;c1&quot;&gt;// Initializes the given aggregation buffer. The buffer itself is a `Row` that in addition to
  &lt;span class=&quot;c1&quot;&gt;// standard methods like retrieving a value at an index (e.g., get(), getBoolean()), provides
  &lt;span class=&quot;c1&quot;&gt;// the opportunity to update its values. Note that arrays and maps inside the buffer are still
  &lt;span class=&quot;c1&quot;&gt;// immutable.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;c1&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;span class=&quot;c1&quot;&gt;&lt;span class=&quot;c1&quot;&gt;这里翻译一下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们为我们的缓冲区设置初始值，我们不仅可以设置数字，还可以使用index getBoolen等去改变他的值，但是我们需要知道的是，在这个缓冲区中，数组和map依然是不可变的。&lt;/p&gt;
&lt;p&gt;其实最后一句我也是不太明白，等我以后如果能研究并理解这句话，再回来补充吧。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
def update(buffer: MutableAggregationBuffer, input: Row): Unit = {
    if (!input.isNullAt(0)) {
      buffer(0) = buffer.getLong(0) + input.getLong(0)
      buffer(1) = buffer.getLong(1) + 1
    }
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个是重要的update函数，对于平均值，我们可以不断迭代输入的值进行累加。buffer(0)统计总和，buffer(1)统计长度。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
def merge(buffer1: MutableAggregationBuffer, buffer2: Row): Unit = {
    buffer1(0) = buffer1.getLong(0) + buffer2.getLong(0)
    buffer1(1) = buffer1.getLong(1) + buffer2.getLong(1)
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在做完update后spark 需要将结果进行merge到我们的区域，因此有一个merge 进行覆盖buffer&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
  def evaluate(buffer: Row): Double = buffer.getLong(0).toDouble / buffer.getLong(1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这是将最终的结果进行计算。&lt;/p&gt;

&lt;p&gt;在写完这个类以后我们在我们的sparksession里面进行编写测试案例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
spark.sparkContext.textFile(&quot;file:///Users/4pa/Desktop/people.txt&quot;)
      .map(_.split(&quot;,&quot;))
      .map(agg=&amp;gt;Person(agg(0),agg(1).trim.toInt))
      .toDF().createOrReplaceTempView(&quot;people&quot;)
spark.udf.register(&quot;myAverage&quot;,Myaverage)
val udfRes = spark.sql(&quot;select name,myAverage(age) as avgAge from people group by name&quot;)
udfRes.show()
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;3. 类型安全的自定义函数&lt;/h3&gt;
&lt;p&gt;从上面我们可以看出来，这种自定义函数不是类型安全的，因此能否实现一个安全的自定义函数呢？&lt;/p&gt;
&lt;p&gt;个人觉得最好的例子还是官网给的例子，具体的解释都已经给了出来，思路其实和上面是一样的，只不过定义了两个caseclass，用于类型的验证。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:scala;gutter:true;&quot;&gt;
case class Employee(name: String, salary: Long)
case class Average(var sum: Long, var count: Long)

object MyAverage extends Aggregator[Employee, Average, Double] {
  // 初始化
  def zero: Average = Average(0L, 0L)
  // 这个其实有点map-reduce的意思，只不过是对一个类的reduce，第一个值是和，第二个是总数
  def reduce(buffer: Average, employee: Employee): Average = {
    buffer.sum += employee.salary
    buffer.count += 1
    buffer
  }
  // 实现缓冲区的一个覆盖
  def merge(b1: Average, b2: Average): Average = {
    b1.sum += b2.sum
    b1.count += b2.count
    b1
  }
  // 计算最终数值
  def finish(reduction: Average): Double = reduction.sum.toDouble / reduction.count
  // Specifies the Encoder for the intermediate value type
  def bufferEncoder: Encoder[Average] = Encoders.product
  // 指定返回类型
  def outputEncoder: Encoder[Double] = Encoders.scalaDouble
}
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Tue, 04 Feb 2020 14:46:00 +0000</pubDate>
<dc:creator>顾鹏pen</dc:creator>
<og:description>1. SparkSql如何自定义函数 2. 示例：Average 3. 类型安全的自定义函数 1. SparkSql如何自定义函数？ spark中我们定义一个函数，需要继承 UserDefinedAg</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tjpeng/p/12261901.html</dc:identifier>
</item>
<item>
<title>Linux 6种日志查看方法，不会看日志会被鄙视的 - 程序员内点事</title>
<link>http://www.cnblogs.com/chengxy-nds/p/12261892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxy-nds/p/12261892.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;作为一名后端程序员，和Linux打交道的地方很多，不会看Linux日志，非常容易受到来自同事和面试官的嘲讽，所以掌握一种或者几种查看日志的方法非常重要。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux查看日志的命令有多种: tail、cat、tac、head、echo等，本文只介绍几种常用的方法。&lt;/p&gt;
&lt;h2 id=&quot;tail&quot;&gt;1、tail&lt;/h2&gt;
&lt;p&gt;这个是我最常用的一种查看方式&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;命令格式: tail[必要参数][选择参数][文件]
-f 循环读取
-q 不显示处理信息
-v 显示详细的处理信息
-c&amp;lt;数目&amp;gt; 显示的字节数
-n&amp;lt;行数&amp;gt; 显示行数
-q, --quiet, --silent 从不输出给出文件名的首部
-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用法如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;tail  -n  10   test.log   查询日志尾部最后10行的日志;
tail  -n +10   test.log   查询10行之后的所有日志;
tail  -fn 10   test.log   循环实时查看最后1000行记录(最常用的)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般还会配合着grep用，例如 :&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; tail -fn 1000 test.log | grep '关键字'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果一次性查询的数据量太大,可以进行翻页查看，例如:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;tail -n 4700  aa.log |more -1000 可以进行多屏显示(ctrl + f 或者 空格键可以快捷键)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;head&quot;&gt;2、head&lt;/h2&gt;
&lt;p&gt;跟tail是相反的head是看前多少行日志&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;head -n  10  test.log   查询日志文件中的头10行日志;
head -n -10  test.log   查询日志文件除了最后10行的其他所有日志;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;head其他参数参考tail&lt;/p&gt;
&lt;h2 id=&quot;cat&quot;&gt;3、cat&lt;/h2&gt;
&lt;p&gt;cat 是由第一行到最后一行连续显示在屏幕上&lt;/p&gt;
&lt;p&gt;一次显示整个文件 :&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; $ cat filename&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从键盘创建一个文件 :&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;$cat &amp;gt; filename&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将几个文件合并为一个文件：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;$cat file1 file2 &amp;gt; file 只能创建新文件,不能编辑已有文件.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将一个日志文件的内容追加到另外一个 :&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;$cat -n textfile1 &amp;gt; textfile2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;清空一个日志文件:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;$cat : &amp;gt;textfile2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;code&gt;&amp;gt;&lt;/code&gt; 意思是创建，&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;是追加。千万不要弄混了。&lt;br/&gt;&lt;code&gt;cat&lt;/code&gt;其他参数参考&lt;code&gt;tail&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;4、more&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;more&lt;/code&gt;命令是一个基于&lt;code&gt;vi&lt;/code&gt;编辑器文本过滤器，它以全屏幕的方式按页显示文本文件的内容，支持vi中的关键字定位操作。&lt;code&gt;more&lt;/code&gt;名单中内置了若干快捷键，常用的有H（获得帮助信息），&lt;code&gt;Enter&lt;/code&gt;（向下翻滚一行），空格（向下滚动一屏），&lt;code&gt;Q&lt;/code&gt;（退出命令）。&lt;code&gt;more&lt;/code&gt;命令从前向后读取文件，因此在启动时就加载整个文件。&lt;/p&gt;
&lt;p&gt;该命令一次显示一屏文本，满屏后停下来，并且在屏幕的底部出现一个提示信息，给出至今己显示的该文件的百分比：&lt;code&gt;–More–（XX%）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;more&lt;/code&gt;的语法：&lt;code&gt;more&lt;/code&gt; 文件名&lt;br/&gt;&lt;code&gt;Enter&lt;/code&gt; 向下&lt;code&gt;n&lt;/code&gt;行，需要定义，默认为1行&lt;br/&gt;&lt;code&gt;Ctrl f&lt;/code&gt; 向下滚动一屏&lt;br/&gt;空格键 向下滚动一屏&lt;br/&gt;&lt;code&gt;Ctrl b&lt;/code&gt; 返回上一屏&lt;br/&gt;&lt;code&gt;=&lt;/code&gt; 输出当前行的行号&lt;br/&gt;&lt;code&gt;:f&lt;/code&gt; 输出文件名和当前行的行号&lt;br/&gt;&lt;code&gt;v&lt;/code&gt; 调用vi编辑器&lt;br/&gt;&lt;code&gt;!&lt;/code&gt;命令 调用&lt;code&gt;Shell&lt;/code&gt;，并执行命令&lt;br/&gt;&lt;code&gt;q&lt;/code&gt;退出&lt;code&gt;more&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;sed&quot;&gt;5、sed&lt;/h2&gt;
&lt;p&gt;这个命令可以查找日志文件特定的一段 , 根据时间的一个范围查询，可以按照行号和时间范围查询&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按照行号&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;sed -n '5,10p' filename 这样你就可以只查看文件的第5行到第10行。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;按照时间段&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; sed -n '/2014-12-17 16:17:20/,/2014-12-17 16:17:36/p'  test.log&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;less&quot;&gt;6、less&lt;/h2&gt;
&lt;p&gt;less命令在查询日志时，一般流程是这样的&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;less log.log

shift + G 命令到文件尾部  然后输入 ？加上你要搜索的关键字例如 ？1213

按 n 向上查找关键字

shift+n  反向查找关键字&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;less与more类似，使用less可以随意浏览文件，而more仅能向前移动，不能向后移动，而且 less 在查看之前不会加载整个文件。
less log2013.log 查看文件
ps -ef | less   ps查看进程信息并通过less分页显示
history | less   查看命令历史使用记录并通过less分页显示
less log2013.log log2014.log   浏览多个文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用命令参数：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;less与more类似，使用less可以随意浏览文件，而more仅能向前移动，不能向后移动，而且 less 在查看之前不会加载整个文件。
less log2013.log 查看文件
ps -ef | less   ps查看进程信息并通过less分页显示
history | less   查看命令历史使用记录并通过less分页显示
less log2013.log log2014.log   浏览多个文件
常用命令参数：
-b &amp;lt;缓冲区大小&amp;gt; 设置缓冲区的大小
-g 只标志最后搜索的关键词
-i 忽略搜索时的大小写
-m 显示类似more命令的百分比
-N 显示每行的行号
-o &amp;lt;文件名&amp;gt; 将less 输出的内容在指定文件中保存起来
-Q 不使用警告音
-s 显示连续空行为一行
/字符串：向下搜索&quot;字符串&quot;的功能
?字符串：向上搜索&quot;字符串&quot;的功能
n：重复前一个搜索（与 / 或 ? 有关）
N：反向重复前一个搜索（与 / 或 ? 有关）
b 向后翻一页
h 显示帮助界面
q 退出less 命令&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一般本人查日志配合应用的其他命令&quot;&gt;一般本人查日志配合应用的其他命令&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;history // 所有的历史记录

history | grep XXX  // 历史记录中包含某些指令的记录

history | more // 分页查看记录

history -c // 清空所有的历史记录

!! 重复执行上一个命令

查询出来记录后选中 :　!323&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;linux日志文件说明&quot;&gt;linux日志文件说明&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;/var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一
/var/log/secure 与安全相关的日志信息
/var/log/maillog 与邮件相关的日志信息
/var/log/cron 与定时任务相关的日志信息
/var/log/spooler 与UUCP和news设备相关的日志信息
/var/log/boot.log 守护进程启动和停止相关的日志消息
/var/log/wtmp 该日志文件永久记录每个用户登录、注销及系统的启动、停机的事件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;水文一篇没什么含金量，只为给大家温习一下功课&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;WeChat：关注公重号：【程序员内点事】,免费获取2000G学习资料，内含精选面试题，SSM、Spring全家桶、微服务、MySQL、MyCat、集群、分布式、中间件、Linux、网络、多线程，Jenkins、Nexus、Docker、ELK等等免费学习视频，持续更新！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC8yLzQvMTcwMGU0Mjk1MDQzMjQ0Yg?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 04 Feb 2020 14:42:00 +0000</pubDate>
<dc:creator>程序员内点事</dc:creator>
<og:description>作为一名后端程序员，和Linux打交道的地方很多，不会看Linux日志，非常容易受到来自同事和面试官的嘲讽，所以掌握一种或者几种查看日志的方法非常重要。 Linux查看日志的命令有多种: tail、c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chengxy-nds/p/12261892.html</dc:identifier>
</item>
<item>
<title>Java设计模式之单例模式 - 烟雨星空</title>
<link>http://www.cnblogs.com/starry-skys/p/12261857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/starry-skys/p/12261857.html</guid>
<description>&lt;p&gt;单例模式，是特别常见的一种设计模式，因此我们有必要对它的概念和几种常见的写法非常了解，而且这也是面试中常问的知识点。&lt;/p&gt;
&lt;p&gt;所谓单例模式，就是所有的请求都用一个对象来处理，如我们常用的Spring默认就是单例的，而多例模式是每一次请求都创建一个新的对象来处理，如structs2中的action。&lt;/p&gt;
&lt;p&gt;使用单例模式，可以确保一个类只有一个实例，并且易于外部访问，还可以节省系统资源。如果在系统中，希望某个类的对象只存在一个，就可以使用单例模式。&lt;/p&gt;
&lt;p&gt;那怎么确保一个类只有一个实例呢？&lt;/p&gt;
&lt;p&gt;我们知道，通常我们会通过new关键字来创建一个新的对象。这个时候类的构造函数是public公有的，你可以随意创建多个类的实例。所以，首先我们需要把构造函数改为private私有的，这样就不能随意new对象了，也就控制了多个实例的随意创建。&lt;/p&gt;
&lt;p&gt;然后，定义一个私有的静态属性，来代表类的实例，它只能类内部访问，不允许外部直接访问。&lt;/p&gt;
&lt;p&gt;最后，通过一个静态的公有方法，把这个私有静态属性返回出去，这就为系统创建了一个全局唯一的访问点。&lt;/p&gt;
&lt;p&gt;以上，就是单例模式的三个要素。总结为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;私有构造方法&lt;/li&gt;
&lt;li&gt;指向自己实例的私有静态变量&lt;/li&gt;
&lt;li&gt;对外的静态公共访问方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;单例模式分为饿汉式和懒汉式。它们的主要区别就是，实例化对象的时机不同。饿汉式，是在类加载时就会实例化一个对象。懒汉式，则是在真正使用的时候才会实例化对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;饿汉式单例代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    // 饿汉式单例，直接创建一个私有的静态实例
    private static Singleton singleton = new Singleton();

    //私有构造方法
    private Singleton(){

    }

    //提供一个对外的静态公有方法
    public static Singleton getInstance(){
        return singleton;

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;懒汉式单例代码实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    // 懒汉式单例，类加载时先不创建实例
    private static Singleton singleton = null;

    //私有构造方法
    private Singleton(){

    }

    //真正使用时才创建类的实例
    public static Singleton getInstance(){
        if(singleton == null){
            singleton = new Singleton();
        }
        return singleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;稍有经验的程序员就发现了，以上懒汉式单例的实现方式，在单线程下是没有问题的。但是，如果在多线程中使用，就会发现它们返回的实例有可能不是同一个。我们可以通过代码来验证一下。创建十个线程，分别启动，线程内去获得类的实例，把实例的 hashcode 打印出来，只要相同则认为是同一个实例；若不同，则说明创建了多个实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TestSingleton {
    public static void main(String[] args) {
        for (int i = 0; i &amp;lt; 10 ; i++) {
            new MyThread().start();
        }
    }
}

class MyThread extends Thread {
    @Override
    public void run() {
        Singleton singleton = Singleton.getInstance();
        System.out.println(singleton.hashCode());
    }
}
/**
运行多次，就会发现，hashcode会出现不同值
668770925
668770925
649030577
668770925
668770925
668770925
668770925
668770925
668770925
668770925
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，以上懒汉式的实现方式是线程不安全的。那饿汉式呢？你可以手动测试一下，会发现不管运行多少次，返回的hashcode都是相同的。因此，认为饿汉式单例是线程安全的。&lt;/p&gt;
&lt;p&gt;那为什么饿汉式就是线程安全的呢？这是因为，饿汉式单例在类加载时，就创建了类的实例，也就是说在线程去访问单例对象之前就已经创建好实例了。而一个类在整个生命周期中只会被加载一次。因此，也就可以保证实例只有一个。所以说，饿汉式单例天生就是线程安全的。（可以了解一下类加载机制）&lt;/p&gt;
&lt;p&gt;既然懒汉式单例不是线程安全的，那么我们就需要去改造一下，让它在多线程环境下也能正常工作。以下介绍几种常见的写法：&lt;/p&gt;
&lt;p&gt;1) 使用synchronized方法&lt;/p&gt;
&lt;p&gt;实现非常简单，只需要在方法上加一个synchronized关键字即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    private static Singleton singleton = null;

    private Singleton(){

    }

    //使用synchronized修饰方法，即可保证线程安全
    public static synchronized Singleton getInstance(){
        if(singleton == null){
            singleton = new Singleton();
        }
        return singleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式，虽然可以保证线程安全，但是同步方法的作用域太大，锁的粒度比较粗，因此，执行效率就比较低。&lt;/p&gt;
&lt;p&gt;2) synchronized 同步块&lt;/p&gt;
&lt;p&gt;既然，同步整个方法的作用域大，那我缩小范围，在方法里边，只同步创建实例的那一小部分代码块不就可以了吗（因为方法较简单，所以锁代码块和锁方法没什么明显区别）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    private static Singleton singleton = null;

    private Singleton(){

    }

    public static Singleton getInstance(){
        //synchronized只修饰方法内部的部分代码块
        synchronized (Singleton.class){
            if(singleton == null){
                singleton = new Singleton();
            }
        }
        return singleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法，本质上和第一种没什么区别，因此，效率提升不大，可以忽略不计。&lt;/p&gt;
&lt;p&gt;3) 双重检测（double check）&lt;/p&gt;
&lt;p&gt;可以看到，以上的第二种方法只要调用getInstance方法，就会走到同步代码块里。因此，会对效率产生影响。其实，我们完全可以先判断实例是否已经存在。若已经存在，则说明已经创建好实例了，也就不需要走同步代码块了；若不存在即为空，才进入同步代码块，这样可以提高执行效率。因此，就有以下双重检测了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    //注意，此变量需要用volatile修饰以防止指令重排序
    private static volatile Singleton singleton = null;

    private Singleton(){

    }

    public static Singleton getInstance(){
        //进入方法内，先判断实例是否为空，以确定是否需要进入同步代码块
        if(singleton == null){
            synchronized (Singleton.class){
                //进入同步代码块时也需要判断实例是否为空
                if(singleton == null){
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的一点是，此方式中，静态实例变量需要用volatile修饰。因为，new Singleton() 是一个非原子性操作，其流程为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a.给 singleton 实例分配内存空间
b.调用Singleton类的构造函数创建实例
c.将 singleton 实例指向分配的内存空间，这时认为singleton实例不为空&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常顺序为 a-&amp;gt;b-&amp;gt;c，但是，jvm为了优化编译程序，有时候会进行指令重排序。就会出现执行顺序为 a-&amp;gt;c-&amp;gt;b。这在多线程中就会表现为，线程1执行了new对象操作，然后发生了指令重排序，会导致singleton实例已经指向了分配的内存空间(c)，但是实际上，实例还没创建完成呢(b)。&lt;/p&gt;
&lt;p&gt;这个时候，线程2就会认为实例不为空，判断 if(singleton == null)为false，于是不走同步代码块，直接返回singleton实例（此时拿到的是未实例化的对象），因此，就会导致线程2的对象不可用而使用时报错。&lt;/p&gt;
&lt;p&gt;4）使用静态内部类&lt;/p&gt;
&lt;p&gt;思考一下，由于类加载是按需加载，并且只加载一次，所以能保证线程安全，这也是为什么说饿汉式单例是天生线程安全的。同样的道理，我们是不是也可以通过定义一个静态内部类来保证类属性只被加载一次呢。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    private Singleton(){

    }

    //静态内部类
    private static class Holder {
        private static Singleton singleton = new Singleton();
    }

    public static Singleton getInstance(){
        //调用内部类的属性，获取单例对象
        return Holder.singleton;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而且，JVM在加载外部类的时候，不会加载静态内部类，只有在内部类的方法或属性（此处即指singleton实例）被调用时才会加载，因此不会造成空间的浪费。&lt;/p&gt;
&lt;p&gt;5）使用枚举类&lt;/p&gt;
&lt;p&gt;因为枚举类是线程安全的，并且只会加载一次，所以利用这个特性，可以通过枚举类来实现单例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Singleton {

    private Singleton(){

    }

    //定义一个枚举类
    private enum SingletonEnum {
        //创建一个枚举实例
        INSTANCE;

        private Singleton singleton;

        //在枚举类的构造方法内实例化单例类
        SingletonEnum(){
            singleton = new Singleton();
        }

        private Singleton getInstance(){
            return singleton;
        }
    }

    public static Singleton getInstance(){
        //获取singleton实例
        return SingletonEnum.INSTANCE.getInstance();
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 04 Feb 2020 14:33:00 +0000</pubDate>
<dc:creator>烟雨星空</dc:creator>
<og:description>单例模式，是特别常见的一种设计模式，因此我们有必要对它的概念和几种常见的写法非常了解，而且这也是面试中常问的知识点。 所谓单例模式，就是所有的请求都用一个对象来处理，如我们常用的Spring默认就是单</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/starry-skys/p/12261857.html</dc:identifier>
</item>
<item>
<title>HanLP《自然语言处理入门》笔记--1.新手上路 - mantch</title>
<link>http://www.cnblogs.com/mantch/p/12261599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mantch/p/12261599.html</guid>
<description>&lt;h2 id=&quot;新手上路&quot;&gt;1. 新手上路&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;自然语言处理&lt;/strong&gt;(Natural Language Processing，NLP)是一门融合了计算机科学、人工智能及语言学的交叉学科，它们的关系如下图所示。这门学科研究的是如何通过机器学习等技术，让计算机学会处理人类语言，乃至实现终极目标--理解人类语言或人工智能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20va2t3ZWlzaGUvaW1hZ2VzMS9yYXcvbWFzdGVyL01MLzIwMjAtMi0zXzEwLTUwLTMwLnBuZw?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;美国计算机科学家Bill Manaris在《计算机进展》( Advances in Computers)第47卷的《从人机交互的角度看自然语言处理》一文中曾经给&lt;strong&gt;自然语言处理提出了如下的定义&lt;/strong&gt;:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;“自然语言处理可以定义为研究在人与人交际中以及在人与计算机交际中的语言问题的一门学科。自然语言处理要研制表示语言能力和语言应用的模型，建立计算框架来实现这样的语言模型，提出相应的方法来不断地完善这样的语言模型，根据这样的语言模型设计各种实用系统，并探讨这些实用系统的评测技术。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;自然语言与编程语言的比较&quot;&gt;1.1 自然语言与编程语言的比较&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&lt;strong&gt;词汇量&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;自然语言中的词汇比编程语言中的关键词丰富，我们还可以随时创造各种类型的新词&lt;/td&gt;
&lt;td&gt;蓝瘦、香菇&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;结构化&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;自然语言是非结构化的，而编程语言是结构化的&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;歧义性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;自然语言含有大量歧义，而编程语言是确定性的&lt;/td&gt;
&lt;td&gt;这人真有意思:没意思&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;容错性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;自然语言错误随处可见，而编程语言错误会导致编译不通过&lt;/td&gt;
&lt;td&gt;的、地的用法错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;strong&gt;易变性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;自然语言变化相对迅速嘈杂一些，而编程语言的变化要缓慢得多&lt;/td&gt;
&lt;td&gt;新时代词汇&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;&lt;strong&gt;简略性&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;自然语言往往简洁、干练，而编程语言就要明确定义&lt;/td&gt;
&lt;td&gt;“老地方”不必指出&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;自然语言处理的层次&quot;&gt;1.2 自然语言处理的层次&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20va2t3ZWlzaGUvaW1hZ2VzMS9yYXcvbWFzdGVyL01MLzIwMjAtMi0zXzExLTE3LTM4LnBuZw?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;15.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;语音、图像和文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自然语言处理系统的输入源一共有3个，即语音、图像与文本。语音和图像这两种形式一般经过识别后转化为文字，转化后就可以进行后续的NLP任务了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;中文分词、词性标注和命名实体识别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这3个任务都是围绕词语进行的分析，所以统称&lt;strong&gt;词法分析&lt;/strong&gt;。词法分析的主要任务是将文本分隔为有意义的词语(&lt;strong&gt;中文分词&lt;/strong&gt;)，确定每个词语的类别和浅层的歧义消除(&lt;strong&gt;词性标注&lt;/strong&gt;)，并且识别出一些较长的专有名词(&lt;strong&gt;命名实体识别&lt;/strong&gt;)。对中文而言，词法分析常常是后续高级任务的基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;信息抽取&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;词法分析之后，文本已经呈现出部分结构化的趋势，根据分析出来的每个单词和附有自己词性及其他标签的数据，抽取出一部分有用的信息，关键词、专业术语等，也可以根据统计学信息抽取出更大颗粒度的文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;文本分类与文本聚类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将文本拆分为一系列词语之后，就可以对文本进行分类和聚类操作，找出相类似的文本。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;句法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;词法分析只能得到零散的词汇信息，计算机不知道词语之间的关系。在一些问答系统中，需要得到句子的主谓宾结构，这就是句法分析得到的结果，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20va2t3ZWlzaGUvaW1hZ2VzMS9yYXcvbWFzdGVyL01MLzIwMjAtMi0zXzEyLTgtNTUucG5n?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不仅是问答系统或搜索引擎，句法分析还经常应用有基于短语的机器翻译，给译文的词语重新排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;语义分析与篇章分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;相较于句法分析，语义分析侧重语义而非语法。它包括&lt;strong&gt;词义消歧&lt;/strong&gt;(确定一个词在语境中的含义，而不是简单的词性)、&lt;strong&gt;语义角色标注&lt;/strong&gt;(标注句子中的谓语与其他成分的关系)乃至&lt;strong&gt;语义依存分析&lt;/strong&gt;(分析句子中词语之间的语义关系)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;其他高级任务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;自动问答、自动摘要、机器翻译&lt;/p&gt;
&lt;p&gt;注意，一般认为信息检索(Information Retrieve，IR)是区别于自然语言处理的独立学科，IR的目标是查询信息，而NLP的目标是理解语言。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;自然语言处理的流派&quot;&gt;1.3 自然语言处理的流派&lt;/h3&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于规则的专家系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;规则，指的是由专家手工制定的确定性流程。专家系统要求设计者对所处理的问题具备深入的理解，并且尽量以人力全面考虑所有可能的情况。它最大的弱点是难以拓展。当规则数量增加或者多个专家维护同一个系统时，就容易出现冲突。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于统计的学习方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人们使用统计方法让计算机自动学习语言。所谓“&lt;strong&gt;统计&lt;/strong&gt;”，指的是在语料库上进行的统计。所谓“&lt;strong&gt;语料库&lt;/strong&gt;”，指的是人工标注的结构化文本。&lt;/p&gt;
&lt;p&gt;统计学习方法其实是机器学习的别称，而机器学习则是当代实现人工智能的主要途径。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;历史&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20va2t3ZWlzaGUvaW1hZ2VzMS9yYXcvbWFzdGVyL01MLzIwMjAtMi0zXzEyLTI2LTExLnBuZw?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;机器学习&quot;&gt;1.4 机器学习&lt;/h3&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;什么是机器学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;美国工程院院士 Tom Mitchell 给过一个更明确的定义，&lt;strong&gt;机器学习&lt;/strong&gt;指的是计算机通过某项任务的经验数据提高了在该项任务上的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模型是对现实问题的数学抽象，由一个假设函数以及一系列参数构成。以下就是最简单的模型公式：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(x)=w*x+b\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中，w 和 b 是函数的参数，而 x 是函数的自变量。不过模型并不包括具体的自变量x，因为自变量是由用户输入的。自变量 x 是一个特征向量，用来表示一个对象的特征。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特征&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;特征&lt;/strong&gt;指的是事物的特点转化的数值。&lt;/li&gt;
&lt;li&gt;如何挑选特征，如何设计特征模板，这称作&lt;strong&gt;特征工程&lt;/strong&gt;。特征越多，参数就越多；参数越多，模型就越复杂。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;数据集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;样本的集合在机器学习领域称作&lt;strong&gt;数据集&lt;/strong&gt;，在自然语言处理领域称作&lt;strong&gt;语料库&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;监督学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果数据集附带标准答案 y，则此时的学习算法称作&lt;strong&gt;监督学习&lt;/strong&gt;。学习一遍误差还不够小，需要反复学习、反复调整。此时的算法是一种迭代式的算法，每一遍学习称作&lt;strong&gt;一次迭代&lt;/strong&gt;。这种在有标签的数据集上迭代学习的过程称作&lt;strong&gt;训练&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;无监督学习&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们只给机器做题，却不告诉它参考答案，机器仍然可以学到知识吗？可以，此时的学习称作&lt;strong&gt;无监督学习&lt;/strong&gt;，而不含标准答案的数据集被称作&lt;strong&gt;无标注的数据集&lt;/strong&gt;。无监督学习一般用于聚类和降维，&lt;strong&gt;降维&lt;/strong&gt;指的是将样本点从高维空间变换成低维空间的过程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;其他类型的机器学习算法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;半监督学习&lt;/strong&gt;：如果我们训练多个模型，然后对同一个实例执行预测，会得到多个结果。如果这些结果多数一致，则可以将该实例和结果放到一起作为新的训练样本，用力啊扩充训练集。这样的算法被称为半监督学习。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强化学习&lt;/strong&gt;：现实世界中的事物之间往往有很长的因果链：我们要正确地执行一系列彼此关联的决策，才能得到最终的成果。这类问题往往需要一边预测，一边根据环境的反馈规划下次决策。这类算法被称为强化学习。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;语料库&quot;&gt;1.5 语料库&lt;/h3&gt;
&lt;ol readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;中文分词语料库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;中文分词语料库指的是，由人工正确切分的句子集合。以著名的1998年《人民日报》语料库为例：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先 有 通货膨胀 干扰，后 有 通货 紧缩 叫板。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;词性标注语料库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它指的是切分并为每个词语制定一个词性的语料。依然以《人民日报》语料库为例：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;迈向/v 充满/v 希望/n 的/u 新/a 世纪/n --/w 一九九八年/t 新年/t 讲话/n&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里每个单词后面用斜杠隔开的就是词性标签。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;命名实体识别语料库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种语料库人工标注了文本内部制作者关心的实体名词以及实体类别。比如《人民日报》语料库中-共含有人名、地名和机构名3种命名实体:&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;萨哈夫/nr&lt;/strong&gt; 说/v ,/w &lt;strong&gt;伊拉克/ns&lt;/strong&gt; 将/d 同/p &lt;strong&gt;[联合国/nt 销毁/v 伊拉克/ns 大规模/b 杀伤性/n 武器/n 特别/a 委员会/n] /nt&lt;/strong&gt; 继续/v 保持/v 合作/v 。/w&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个句子中的加粗词语分别是人名、地名和机构名。中括号括起来的是复合词，我们可以观察到:有时候机构名和地名复合起来会构成更长的机构名，这种构词法上的嵌套现象增加了命名实体识别的难度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;句法分析语料库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;汉语中常用的句法分析语料库有CTB(Chinese Treebank，中文树库)，其中一个句子可视化后如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20va2t3ZWlzaGUvaW1hZ2VzMS9yYXcvbWFzdGVyL01MLzIwMjAtMi0zXzEzLTQwLTU2LnBuZw?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中文单词上面的英文标签标示词性，而箭头表示有语法联系的两个单词，具体是何种联系由箭头上的标签标示。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;文本分类语料库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它指的是人工标注了所属分类的文章构成的语料库。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;语料库的建设&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;语料库建设指的是构建一份语料库的过程，分为规范制定、人员培训与人工标注这三个阶段。针对不同类型的任务，人们开发出许多标注软件，其中比较成熟的一款是brat，它支持词性标注、命名实体识别和句法分析等任务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;开源工具&quot;&gt;1.6 开源工具&lt;/h3&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;主流NLP工具比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20va2t3ZWlzaGUvaW1hZ2VzMS9yYXcvbWFzdGVyL01MLzIwMjAtMi0zXzEzLTUyLTEyLnBuZw?x-oss-process=image/format,png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，也研究过其他开源项目的原理，借鉴了其中优秀的设计。但毕竟还是自己写的代码讲得最清楚，所以综合以上各种考虑，最后选取了&lt;strong&gt;HanLP作为本书的实现&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Python接口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HanLP 的 Python 接口由 pyhanlp 包提供，其安装只需一句命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ pip install pyhanlp&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;1.7 总结&lt;/h3&gt;
&lt;p&gt;本章给出了人工智能、机器学习与自然语言处理的宏观缩略图与发展时间线。机器学习是人工智能的子集，而自然语言处理则是人工智能与语言学、计算机科学的交集。这个交集虽然小，它的难度却很大。为了实现理解自然语言这个宏伟目标，人们尝试了规则系统，并最终发展到基于大规模语料库的统计学习系统。&lt;/p&gt;
&lt;p&gt;在接下来的章节中，就让我们按照这种由易到难的发展规律去解决第一个NLP问题一中文分词。我们将先从规则系统人手，介绍一些快而不准的算法，然后逐步进化到更加准确的统计模型。&lt;/p&gt;
&lt;h3 id=&quot;github项目&quot;&gt;1.8 GitHub项目&lt;/h3&gt;
&lt;p&gt;HanLP何晗--《自然语言处理入门》笔记：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/NLP-LOVE/Introduction-NLP&quot; class=&quot;uri&quot;&gt;https://github.com/NLP-LOVE/Introduction-NLP&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目持续更新中......&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;8.0091743119266&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/NLP-LOVE/Introduction-NLP/blob/master/chapter/1.%20%E6%96%B0%E6%89%8B%E4%B8%8A%E8%B7%AF.md&quot;&gt;第 1 章：新手上路&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;&lt;a href=&quot;https://github.com/NLP-LOVE/Introduction-NLP/blob/master/chapter/2.%E8%AF%8D%E5%85%B8%E5%88%86%E8%AF%8D.md&quot;&gt;第 2 章：词典分词&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;第 3 章：二元语法与中文分词&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;第 4 章：隐马尔可夫模型与序列标注&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;第 5 章：感知机分类与序列标注&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;第 6 章：条件随机场与序列标注&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;第 7 章：词性标注&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;第 8 章：命名实体识别&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;第 9 章：信息抽取&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;第 10 章：文本聚类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;第 11 章：文本分类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;第 12 章：依存句法分析&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;第 13 章：深度学习与自然语言处理&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 04 Feb 2020 13:42:00 +0000</pubDate>
<dc:creator>mantch</dc:creator>
<og:description>**自然语言处理**(Natural Language Processing，NLP)是一门融合了计算机科学、人工智能及语言学的交叉学科，它们的关系如下图所示。这门学科研究的是如何通过机器学习等技术，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mantch/p/12261599.html</dc:identifier>
</item>
<item>
<title>Python学习，第八课 - 函数  - 承受</title>
<link>http://www.cnblogs.com/yidaoge/p/12261561.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yidaoge/p/12261561.html</guid>
<description>&lt;p&gt;本次讲解函数，由于内容比较多，小编列了个大纲，主要有一下内容：&lt;/p&gt;
&lt;p&gt;1. 函数基本语法及特性&lt;/p&gt;
&lt;p&gt;2. 函数参数&lt;/p&gt;
&lt;p&gt;3.局部变量&lt;/p&gt;
&lt;p&gt;4. 返回值&lt;/p&gt;
&lt;p&gt;5.嵌套函数&lt;/p&gt;
&lt;p&gt;6.递归&lt;/p&gt;
&lt;p&gt;7.匿名函数&lt;/p&gt;
&lt;p&gt;8.高阶函数&lt;/p&gt;
&lt;p&gt;9.内置函数&lt;/p&gt;

&lt;h5&gt;1. 函数基本语法及特性&lt;/h5&gt;
&lt;p&gt;函数的定义：函数是指将一组语句的集合通过一个名字(函数名)封装起来，要想执行这个函数，只需调用其函数名即可&lt;/p&gt;
&lt;p&gt;函数的特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;减少重复代码&lt;/li&gt;
&lt;li&gt;使程序变的可扩展&lt;/li&gt;
&lt;li&gt;使程序变的易维护&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;函数的语法定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; def 是定义函数的关键字&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt; test():&lt;span&gt;#&lt;/span&gt;&lt;span&gt;test既是函数名&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;学习Python的第一个函数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    
test() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;调用函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;同时函数也可以带参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
a, b = 1, 3


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 带参函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt; test(x, y):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; x 和 y 即是在我们调用函数时传入的参数&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x + y  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回执行的结果&lt;/span&gt;
&lt;span&gt;

c &lt;/span&gt;= test(a, b)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把函数返回结果赋值给 C&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(c)
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;2. 函数参数&lt;/h5&gt;
&lt;p&gt;在说函数参数前，大家需要了解一个知识点，&lt;span&gt;形参 &amp;amp; 实参&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何为形参？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。&lt;/p&gt;
&lt;p&gt;因此，形参只在函数内部有效，函数调用结束返回主调用函数后则不能再使用该形参变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何为实参？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们都必须有确定的值，以便把这些值传送给形参。&lt;/p&gt;
&lt;p&gt;因此应预先用赋值，输入等办法使参数获得确定值&lt;/p&gt;
&lt;p&gt;这么说可能有些不理解，还是来个实例让大家更加清晰：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
a, b = 1, 3


&lt;span&gt;def&lt;/span&gt; test(x, y):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; x 和 y 即是形参&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y

c &lt;/span&gt;= test(a, b)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; a,b既是实参&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(c)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;关键参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的例子中，我们调用函数传参是根据函数的形参位置来传递的。&lt;/p&gt;
&lt;p&gt;既 a 传给 x ，b 传给 y。这种叫做位置参数。&lt;/p&gt;
&lt;p&gt;我们还可以使用关键参数，既传递的时候给函数的参数名传递你的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
a, b = 1, 3


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 带参函数&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(x, y):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y


c &lt;/span&gt;= test(y=a, x=b)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这里把 a 传给 y ， b 传给 x&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(c)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这样参数就可以不用按照顺序传递，根据参数名传递给函数。&lt;/p&gt;
&lt;p&gt;我们甚至可以把位置参数和关键参数同时使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
a, b = 1, 3


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(x, y):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y


c &lt;/span&gt;= test(1, y=&lt;span&gt;b)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(c)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果同时使用一定要注意：关键参数必须要放在位置参数的后面，并且已经传值的位置参数不能再用关键参数&lt;/p&gt;
&lt;p&gt;下面是一些错误的用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
c = test(x=&lt;span&gt;a, b)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;报错：TypeError: test() got multiple values for argument 'x'&lt;/span&gt;
c = test(a, x=&lt;span&gt;b)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;报错：TypeError: test() got multiple values for argument 'x'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;默认参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参数还可以设置一个默认值，这样我们在调用的时候既可以不传参给默认参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; test(x, y, z=9):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置了 z 的默认值是 9&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(x + y +&lt;span&gt; z)

test(&lt;/span&gt;1, 3)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果我们第三个参数也就是z 不传的话，z的默认值就是9&lt;/span&gt;
test(1, 3, 10)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;我们传了第三个参数，则 z 的值就变成10&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;非固定参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所谓非固定参数就是可以传递任意个数的参数，比如你的函数在定义的时候不能确定用户想传入多少个参数，就可以使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt; test(*args):  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用 *args, 这里args可以改成任意变量名，但是不建议这么做。&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(args)


test()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：()&lt;/span&gt;
test(1, 2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：(1, 2)&lt;/span&gt;
test(1, 2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;承受&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果：(1, 2, '承受', 'Python')&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调用函数可以传入任意个数的参数，然后转换成 元组 的形式&lt;/p&gt;

&lt;h5&gt;3.局部变量&lt;/h5&gt;
&lt;p&gt;局部变量：就是只能在局部使用的变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cheng Shou&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_name(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;改变前：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;承受&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;改变后：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)


change_name(name)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;在外面在看下name的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;改变前： Cheng Shou&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;改变后： 承受&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;在外面在看下name的值： Cheng Shou&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;从上面的例子大家发现了没？函数里面的name修改了，函数外面的name没有改变。&lt;/p&gt;
&lt;p&gt;其实函数里面的name 就是局部变量，他并没有调用外部的name。&lt;/p&gt;

&lt;p&gt;那函数里面就不能使用全局变量了吗？非要用也是可以的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cheng Shou&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_name():
    &lt;/span&gt;&lt;span&gt;global&lt;/span&gt; name &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在函数中使用global既可&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;改变前：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;承受&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;改变后：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)


change_name()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;在外面在看下name的值：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;改变前： Cheng Shou&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;改变后： 承受&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;在外面在看下name的值： 承受&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用global 既可，我们的全局变量也被修改了。&lt;/p&gt;
&lt;p&gt;当然不建议这么做。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;全局变量与局部变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在子程序中定义的变量称为局部变量，在程序的一开始定义的变量称为全局变量。&lt;/p&gt;
&lt;p&gt;全局变量作用域是整个程序，局部变量作用域是定义该变量的子程序。&lt;/p&gt;
&lt;p&gt;当全局变量与局部变量同名时：&lt;/p&gt;
&lt;p&gt;在定义局部变量的子程序内，局部变量起作用；在其它地方全局变量起作用&lt;/p&gt;

&lt;h5&gt;4. 返回值&lt;/h5&gt;
&lt;p&gt;其实我们第一个例子中就有用到返回值，既 return 语句。return可以吧函数的执行结果返回&lt;/p&gt;
&lt;p&gt;返回值记住两点：&lt;/p&gt;
&lt;p&gt;1.函数在执行过程中只要遇到 return 语句就会停止函数的执行，并且返回结果。所以 return 语句出现就代表着函数结束&lt;/p&gt;
&lt;p&gt;2.如果函数中未使用 return ，那函数执行完毕后，返回的值为 None&lt;/p&gt;

&lt;h5&gt;5.嵌套函数&lt;/h5&gt;
&lt;p&gt;顾名思义就是函数里面套函数，小编看到这个也是内心惊呼一声：python 果然牛掰&lt;/p&gt;
&lt;p&gt;那么怎么套呢，上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cheng Shou&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_name():
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;小承&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; change_name2():
        name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;小受&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第三层：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)

    change_name2() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用内存函数&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;第二层：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)


change_name()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;最外层：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, name)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;第三层： 小受&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;第二层： 小承&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;最外层： Cheng Shou&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;神奇吧，一层套一层，跟俄罗斯套娃一样&lt;/p&gt;
&lt;p&gt;至于这个嵌套函数什么作用，之后学习到装饰器的时候我们就知道了。&lt;/p&gt;

&lt;h5&gt;6.递归&lt;/h5&gt;
&lt;p&gt;在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。&lt;/p&gt;
&lt;p&gt;说白了，就是在函数里面调用自身函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; subtraction(n):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(n)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; n &amp;lt; 1&lt;span&gt;:
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; n
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; subtraction(n-1&lt;span&gt;)

subtraction(&lt;/span&gt;5&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出结果：&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：python默认的递归深度是很有限的（默认是1000），因此当递归深度超过999的样子，就会引发这样的一个异常。&lt;/p&gt;
&lt;p&gt;报错：RecursionError: maximum recursion depth exceeded while calling a Python object&lt;/p&gt;
&lt;p&gt;如果你的业务需要递归深度超过1000，则需要修改递归深度的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
sys.setrecursionlimit(&lt;/span&gt;10000)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;导入sys模块，然后设置，需要多大就设置多大既可。&lt;/p&gt;
&lt;p&gt;一般我们的业务代码不建议超过默认深度，否则代码性能不好。&lt;/p&gt;
&lt;p&gt;在二分查找的时候，我们会用到递归，不过这讲到算法问题本篇就直接带过，后续有时间小编在写一篇算法相关的文章&lt;/p&gt;
&lt;p&gt;递归特性:&lt;/p&gt;
&lt;p&gt;1. 必须有一个明确的结束条件&lt;/p&gt;
&lt;p&gt;2. 每次进入更深一层递归时，问题规模相比上次递归都应有所减少&lt;/p&gt;
&lt;p&gt;3. 递归效率不高，递归层次过多会导致栈溢出（在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出）&lt;/p&gt;

&lt;h5&gt;7.匿名函数&lt;/h5&gt;
&lt;p&gt;匿名函数就是不需要显式的指定函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(n):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n + 1

&lt;span&gt;print&lt;/span&gt;(test(2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上面的函数修改成匿名函数后&lt;/span&gt;
test = &lt;span&gt;lambda&lt;/span&gt; n: n + 1
&lt;span&gt;print&lt;/span&gt;(test(2))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;一般匿名函数是和其它函数搭配使用的，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(map(&lt;span&gt;lambda&lt;/span&gt; x: x ** 2, [1, 2, 3, 4, 5&lt;span&gt;]) )
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出：[1, 4, 9, 16, 25]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h5&gt;8.高阶函数&lt;/h5&gt;
&lt;p&gt;变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。&lt;/p&gt;
&lt;p&gt;简单的说就是把函数当做参数传递给另一个函数，在函数中调用传递过来的函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add(x, y, func):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func(x) +&lt;span&gt; func(y)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; square(n):
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; n ** 2&lt;span&gt;

res &lt;/span&gt;= add(3, 6&lt;span&gt;, square)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(res)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里把square函数，传递给了add ，并且在add中使用了 square函数。这便实现了高阶函数&lt;/p&gt;

&lt;h5&gt;9.内置函数&lt;/h5&gt;
&lt;p&gt;直接展示一张图，不做详解，大家使用到的时候在了解既可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1928357/202002/1928357-20200204213106513-496463866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h5&gt; &lt;/h5&gt;

</description>
<pubDate>Tue, 04 Feb 2020 13:33:00 +0000</pubDate>
<dc:creator>承受</dc:creator>
<og:description>本次讲解函数，由于内容比较多，小编列了个大纲，主要有一下内容： 1. 函数基本语法及特性 2. 函数参数 3.局部变量 4. 返回值 5.嵌套函数 6.递归 7.匿名函数 8.高阶函数 9.内置函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yidaoge/p/12261561.html</dc:identifier>
</item>
<item>
<title>Java小白入门：聊聊Java这门编程语言 - 谭少学Java</title>
<link>http://www.cnblogs.com/quan2018/p/tanquan.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quan2018/p/tanquan.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、什么叫做编程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们应该了解一下什么叫做编程。&lt;/p&gt;
&lt;p&gt;&lt;a title=&quot;什么叫做编程-百度百科&quot; href=&quot;https://baike.baidu.com/item/%E7%BC%96%E7%A8%8B/139828?fr=aladdin&quot; target=&quot;_blank&quot;&gt;百度百科&lt;/a&gt;词条的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;编程是编定程序的简称，是让计算机代我们解决某个问题，是对某个计算体系规定一定的运算方式，使计算体系按照该计算方式运行，并最终得到相应结果的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于该解释，大家也包括我自己可能并不是很理解，那我们反正就这么理解，一般来说编程就是写代码，目的是为了解决问题，解决什么问题需要看需求，看甲方爸爸的需求，所以也就有了&lt;strong&gt;需求工程师&lt;/strong&gt;这个职位。&lt;/p&gt;
&lt;p&gt;这么理解，简单、粗暴，哈哈哈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是有个误区要提醒一下，编程不一定是针对计算机程序而言的，针对具备逻辑计算力的体系，都可以算编程&lt;/strong&gt;（这是词条中提到的，我觉得有必要提一下）。&lt;/p&gt;
&lt;h3&gt;二、白话编程语言&lt;/h3&gt;
&lt;p&gt;然后，我们来了解一下关于编程语言的知识。&lt;/p&gt;
&lt;p&gt;我们都知道，语言嘛，当然是用来沟通交流、传递信息的，在人类的世界里，语言的种类非常多，像汉语、英语、日语、法语等等。&lt;/p&gt;
&lt;p&gt;所以，我们不妨猜想一下，在计算机的世界里，会不会也是这样的呢？答案是，的确如此。&lt;/p&gt;
&lt;p&gt;为了使计算机能够理解人的意图，人类就必须将需解决的问题的思路、方法和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。&lt;/p&gt;
&lt;p&gt;这种形式就是指编程语言。&lt;/p&gt;&lt;p&gt;在计算机领域，编程语言也很多，按发展历程来划分大致可以分为三大类：机器语言、汇编语言以及高级语言。从机器语言到高级语言，经历了很长一段时间的发展。它们是发明者为了满足现实的需要，不断迭代发展到今天这个简单、易于学习的高级语言的。&lt;/p&gt;
&lt;p&gt;所以如今最常用的编程语言就是高级语言，而高级语言像比较常见的有C、C++、Java、Python等等，那么我们可以用它们做什么事呢？&lt;/p&gt;
&lt;p&gt;前面说了，编程语言和我们熟悉的汉语一样，也是用来沟通交流的，只是在沟通对象上有区别而已。&lt;/p&gt;
&lt;p&gt;汉语是人与人之间的沟通，而编程语言则是人与计算机之间的沟通&lt;strong&gt;（简称人机交互）&lt;/strong&gt;，并且这种沟通是单向的，只有人可以主动来和计算机“交流”，而计算机是不会主动和我们说话的。&lt;br/&gt;但是，在科技发展如此迅速的时代，或许未来真的会诞生智能电脑（人工智能领域）也很有可能哦。（这个只是谭少额外的一点想法，说的可能不太准确，毕竟对这些不懂）。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;在IT领域中，编程语言是程序员小哥哥和计算机打交道、指挥计算机帮其解决现实问题的工具。&lt;/p&gt;
&lt;p&gt;对编程和编程语言有了一个大概的了解之后，下面我们开始介绍Java。&lt;/p&gt;
&lt;h3&gt; 三&lt;strong&gt;、Java介绍&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;那有的人可能就想问了，既然编程语言这么多种，那为什么偏偏就选择Java呢？这其实就和很多人会选择努力学好英语一样，它们都比较火热，而且都在各自领域起着重大作用。&lt;/p&gt;
&lt;p&gt;Java被称之为计算机界的“英语”，在编程语言排行榜中多年来一直名列前茅，并且连续多年排名第一，你说它火不火。说白了，学好它对你很有用，不管是靠它找工作以此谋生还是作为一个爱好，对你生活和工作的发展都很有帮助。&lt;/p&gt;
&lt;p&gt;所以，想出国、想到外企工作的人就要学好英语，而想当程序员，拿高薪，迎娶白富美的你（男生），学好Java就很大程度上能帮你实现。&lt;br/&gt;当然了，你也可以选择学其他语言，不一定非得是Java，只是相对来说，学Java的人比较多些，学Java出身做程序员的叫做Java程序员。&lt;/p&gt;
&lt;p&gt;可能有人想说，学的人这么多，岂不是竞争也很大啊。&lt;br/&gt;&lt;strong&gt;是的，竞争非常大，但是通往成功的路上并不拥挤，因为很多人由于坚持不下去而放弃了，坚持到最后的人很少，所以，要成功，那就做那个坚持到最后的人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好了，废话不多说了，正式开始介绍Java。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;1、Java诞生及其发展简史&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;1991年，SUN公司的Green项目，播下了Java语言的种子，当时Java还不叫Java，叫Oak。&lt;br/&gt;1995年年初，Sun公司发布了Java语言，开源免费给大家使用，短短几个月内，Java受到了大家的广泛喜爱，成为了互联网上最热门的宝贝。&lt;/p&gt;
&lt;p&gt;但是，此时的Java还不能开发复杂的应用程序，要开发的话，必须要有一个强大的开发类库。&lt;br/&gt;因此，Sun公司在1996年发布了JDK1.0。&lt;/p&gt;
&lt;p&gt;有了这个东西，我们就能使用Java开发复杂的应用程序了。&lt;br/&gt;在接下来几年里，Sun公司陆续又接着发布了JDK1.1、JDK1.2，而1998年12月&lt;strong&gt;JDK1.2的发布是Java历史上最重要的一个版本&lt;/strong&gt;&lt;strong&gt;，这次将Java分成了J2SE、J2EE、J2ME三个版本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三个版本之间的关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1394552/202002/1394552-20200204201544334-279824657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;J2SE是Java技术的基础和核心，也是其他两个版本的基础，初学Java就是从J2SE学起的。&lt;br/&gt;J2EE是Java技术中应用最广泛的部分，主要用于企业级应用的开发。&lt;br/&gt;J2ME则主要用于控制移动设备和信息家电等有限存储的设备（实际开发中用的比较少，了解即可）。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这个版本的发布，标志着Java吹响了向桌面、企业、移动三个领域进军的号角&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;2004年10月，Sun公司发布了万众期待的JDK1.5，并将JDK1.5改名为JavaSE 5.0，同样的，J2EE和J2ME也改名为JavaEE和JavaME。&lt;/p&gt;&lt;p&gt;2009年4月，Oracle宣布收购Sun，从此Java成了Oracle公司的资产，而Sun公司也永远的消失了，但Sun公司创造的传奇是老一辈程序员心中的怀念。&lt;/p&gt;&lt;p&gt;……此处省略部分历史&lt;/p&gt;&lt;p&gt;经过二十多年的发展，至今Java已经成为互联网上最受欢迎的编程语言了。如今JDK的最新版本已经到JDK13了，并且还在不断的发展中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、学好Java具体能够做什么呢？&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;可以做软件，分为三类，电脑桌面应用和网页版应用，还有移动客户端程序。&lt;/p&gt;
&lt;p&gt; 　　但是现在有专门搞移动端的安卓开发和IOS开发了，所以Java主要应用于前两个领域（用的最多的还是网页版应用开发，也就是前面提到的企业级应用），不过学安卓开发也是要有Java基础的，IOS开发就要学别的东西了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Java语言的特性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;简单易用&lt;/li&gt;
&lt;li&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;面向对象&lt;/em&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;安全性高&lt;/em&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;支持多线程&lt;/em&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;跨平台&lt;/em&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;简单易用&lt;/strong&gt;：任何事物都是相对的，Java相对C、C++来说要简单易学，容易上手，但是这不代表学好也比它们容易。&lt;br/&gt;&lt;strong&gt;跨平台&lt;/strong&gt;：我们称能够支持程序运行的硬件或软件环境为平台，各操作系统也是软件，所以Windows、Linux、Mac都可以称之为一个平台。&lt;/p&gt;
&lt;p&gt;Java程序不是直接运行在操作系统上，而是运行在一个叫做Java虚拟机（Java Virtual Machine，简称JVM）的虚拟计算机上。&lt;br/&gt;Java针对不同的系统有不同的JVM实现，只要你的系统中安装了对应的JVM，就能运行Java程序，而不依赖于操作系统。&lt;/p&gt;
&lt;p&gt;简单点说就是，你拿一个Java程序，在Windows、Linux、Mac上都能运行，只要它们各自都安装了JVM。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JVM是Java语言的运行环境，也是Java 最具吸引力的特性之一&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;JVM用于读取并处理编译过的与平台无关的字节码文件，从而实现Java的可移植性。（字节码文件后面会讲到）。&lt;br/&gt;&lt;strong&gt;但是值得注意的是Java虚拟机是不跨平台的，也就是说在Windows下得装&lt;/strong&gt;Windows&lt;/em&gt;版的JVM，在Linux下装Linux版的JVM，在Mac下得装Mac版的JVM。&lt;/p&gt;

&lt;p&gt;文章首发于同名微信公众号：谭少学Java&lt;/p&gt;
&lt;p&gt;这是我在博客园的第一篇博客，以后的Java学习、更博之路还很漫长，感兴趣的老铁可以关注一波。&lt;/p&gt;

</description>
<pubDate>Tue, 04 Feb 2020 12:44:00 +0000</pubDate>
<dc:creator>谭少学Java</dc:creator>
<og:description>我们都知道，语言嘛，当然是用来沟通交流、传递信息的，在人类的世界里，语言的种类非常多，像汉语、英语、日语、法语等等。 所以，我们不妨猜想一下，在计算机的世界里，会不会也是这样的呢？答案是，的确如此。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/quan2018/p/tanquan.html</dc:identifier>
</item>
<item>
<title>复盘：我是如何从一个差生考上重点大学的 - 朱季谦</title>
<link>http://www.cnblogs.com/zhujiqian/p/12259268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhujiqian/p/12259268.html</guid>
<description>&lt;p&gt;　　原创/朱季谦&lt;/p&gt;

&lt;p&gt;　　在外地念大学的这些年，我一直反复地思考一个问题：如果在我十二岁那年里没能考出理想的分数，如果当年我母亲没有答应要将她的孩子送到县城里去念书，那么，十年后的我，又将成为怎样的一个我呢？或许在那之后，我会像村里的其他同龄孩子一样，念完小学，就开始跟着亲戚到外地打工，等到适合结婚的年龄，再经父辈们的介绍，在邻近的村里找个同样平凡的姑娘，然后一起建个小家，继续像父辈那样，平庸地待在中国南方的村庄里，碌碌无为，就此度过这短暂而平凡的一生。&lt;/p&gt;

&lt;p&gt;　　如果真是这样的话，那么十二岁那年之后的人生，我可能会走向另一条与今日截然不同的道路，可能我永远都不会走出家乡，今日也不会坐在窗明几净的教室里，写下这些有关回忆的文字……&lt;/p&gt;

&lt;p&gt;　　我仍然清楚地记得，在我十一岁那年的一个晚上，父亲第一次在我面前用一种严厉的口吻对我说道，在我的面前只有两条路可以选择，一是尽自己的全部努力，考上镇上最好的初中；如果考到另一所很差的初中，以后就老老实实地跟着亲戚到外地去打工……&lt;/p&gt;

&lt;p&gt;　　那时的我仍是一个年幼无知的孩子，沉浸在一种无忧无虑的岁月里。 当我终于要去面临人生第一次残酷选择时，我忽然开始感受到什么叫做彷徨。&lt;/p&gt;

&lt;p&gt;　　有一天晚上，当我坐在电视机前偶然看到一个介绍县城的公益广告时，心里突然出现一种从未有过的念头。于是我把电视机关上，走到正在忙着帮弟弟洗澡的母亲面前，用一种坚定的目光看着她，说道:“我不想考去镇上最好的那所中学……我想考去县城里念书，如果我能考上了，你们愿意供我去读吗？”&lt;/p&gt;

&lt;p&gt;　　母亲听到这话后，眼睛里突然浮现出惊讶的目光，她沉默了片刻后，开始语重心长地说道：“如果你能在小学升初中的考试里，考到县城去，那我就一定会送你去读。你爸之所以对你这么严格，就是希望你能好好念书。我们年轻的时候，家里面没什么钱，供不起我们去念书，到了你们这一代，就希望你们都能够有点出息。不要像我们一样，吃了读书少的亏，只能一辈子都待在农村里，碌碌无为……”&lt;/p&gt;

&lt;p&gt;　　听完母亲的这番话后，我重重地点了点头，在转过身的那一刻，心里面只剩下一个宛若磐石般坚定的念头——尽自己所有努力，从村庄走出去，去到自己向往的县城里读书。在那之后的许多白天与黑夜，我收敛起自己爱玩的天性，把所有的心思都放在学习上。一年之后，我带上坚定的信念，以及所有的努力，走进了考场。后来，我以优异的成绩考进县城里的重点初中。那是我有生以来第一个梦想，也是我这辈子第一次如愿将梦想变成了现实。&lt;/p&gt;

&lt;p&gt;　　去县城报道的那天，母亲送我来学校的路上，忽然说了这么一句话，她说：“村里面很多人都没有你这么好的机会，可以到县城里念书，既然今天你有机会考到县城里去念书了，就好好念下去，你要相信，命运总会留给努力的人。”&lt;/p&gt;

&lt;p&gt;　　母亲那天说过的话语，后来在很长一段岁月里，我都铭记于心。我就这样从中国大陆最南方的村庄里走出来，带着年少的梦想，带着一份从未放弃过的努力，走向了大千世界。那时候我并不知道，原来后来的自己还能走得更远，远到横跨大半个中国。那些曾经嘲笑过我的人，那些曾经以为我走不出那座牢笼般村庄的同龄人，都被我远远地抛在看不见的地方。&lt;/p&gt;

&lt;p&gt;　　在念初中的三年短暂时光里，我丝毫都没有让父母失望，也没有让自己留下任何遗憾。我花了整整三年的时间，以最优异的成绩，考到县城最好的高中尖子班，两个月后，当我拖着行李箱走进那所每年都会有大批学子考上重点大学的高中时，眼泪莫名其妙就流了出来，那是我第一次被以前那么努力的自己所感动……&lt;/p&gt;

&lt;p&gt;　　我以为自己可以一帆风顺念完三年高中，最后考取心仪的大学，但所有安静的时光都被高二那年的文理分科打乱了……在高二文理分科的时候，我听取了长辈们的建议，选择了理科。这样的选择，使我在后来很长的时间里，都沉浸在一种消极的情绪当中。我从小就是一个喜欢文字的孩子，对文科有种与生俱来的热爱。高二那年文理分科后，我的成绩一落再落，很长时间里，都提不起对理综的兴趣，特别是物理，甚至有一种极度厌恶的感觉。每当看到满桌子的理综试卷，我就有种想要撕卷子的冲动。慢慢的，就开始有了厌学的心态，直到有一天，终于忍受不了那种压抑的感觉，我连假条都懒得请，电话也没给班主任打一个，直接就背上书包回了家。&lt;/p&gt;

&lt;p&gt;　　在家里睡了好几天，待心情稍微好点，才懒洋洋地回到学校，这样的情况，反反复复，越是临近高三，就越不想待在学校。终于有一天，再也忍受不了那种压抑而又无奈的心情，我给母亲打了一个电话。那天，我竟像一个无助的孩子，流下了眼泪，我在电话里对母亲说道：“我想回家，不想念了。”&lt;/p&gt;

&lt;p&gt;　　电话那头的母亲沉默了好久，才用一种平静的语气对我说：“当你想要放弃的时候，你应该想想过去是怎么走过来的，还记得六年前你是怎么考到县里去的吗，后来又是怎样考到县里最好的高中？如果你现在放弃了，那么以前的一切都是白费的，回来又能干什么，去打工，还是像你父亲那样当一辈子的农民？你老是抱怨选了理科，觉得自己学不好，但如果你没有去好好努力，又怎么知道自己学不好呢？”&lt;/p&gt;

&lt;p&gt;　　那天我挂完电话，回想起这近六年来的努力，泪水忽然忍不住一直往下掉。那时距离高考已经不到一年，然而我的成绩仍排在班级的倒数，前路渺茫，根本看不到任何希望。&lt;/p&gt;

&lt;p&gt;　　这时，我的班主任找到了我。&lt;/p&gt;

&lt;p&gt;　　那天在教室外面的走廊上，他跟我聊了很久的天，说到后来，他说了这么一句话，他说，当你遇到困难的时候，首先想到的，不是想着怎么去逃避，而是要尽自己的最大努力，去面对它。&lt;/p&gt;

&lt;p&gt;　　我似懂非懂地点了点头，沉默了好一会儿，才抬起头问道，如果现在开始努力，还有机会考上好的大学吗？&lt;/p&gt;

&lt;p&gt;　　他反而问了我一句，你最想去的地方是哪？&lt;/p&gt;

&lt;p&gt;　　我愣了一下，答道，我最想去的地方是江南，那个曾经从古诗词里认识的地方。&lt;/p&gt;

&lt;p&gt;　　他微笑着拍了拍我的肩膀，说道，那就努力地考去你想去的地方吧。&lt;/p&gt;

&lt;p&gt;　　那时候，距离高考只剩半年了，在班主任与同学的鼓励下，我逐渐振作起来，为了能够快点把成绩赶上来，我开始逼着把自己埋在了无尽的题海里，将每一个遇到的问题都整理起来，然后反复去思考去分析，或者请教同学，或者直接跑到办公室里请教老师，就这样，我成了老师办公室里的常客。&lt;/p&gt;

&lt;p&gt;　　在那段艰苦的时光里，每天早上，当舍友还赖在床上时，我就已趁着朦胧的天色赶到了教室，然后啃着面包，开始一天的复习。&lt;/p&gt;

&lt;p&gt;　　后来，我一直都记得那些灰蒙蒙的天空，记得那样寂寥无人的校园早晨，以及，那个曾孤独地穿过大半个校园而往教学楼走去的身影。&lt;/p&gt;

&lt;p&gt;　　就这样努力地走过了高中最后的日子，当高考终于要到来时，我的成绩已经成功挤进全班前十名。那年的高考，我得以发挥正常，如愿考到了江南的一所重点大学。&lt;/p&gt;

&lt;p&gt;　　很多年以后的今天，当我回过头去重温这近十年的岁月，才发现，原来自己曾经所立下的每个理想，都在自己的努力下变成了现实。我曾从中国大陆最南方的村庄里走出来，之后又考到县城里最好的高中，再后来，我来到了自己梦想的江南念书。&lt;/p&gt;

&lt;p&gt;　　我始终相信那么一句话，岁月终会眷顾努力的孩子。&lt;/p&gt;
</description>
<pubDate>Tue, 04 Feb 2020 12:19:00 +0000</pubDate>
<dc:creator>朱季谦</dc:creator>
<og:description>原创/朱季谦 在外地念大学的这些年，我一直反复地思考一个问题：如果在我十二岁那年里没能考出理想的分数，如果当年我母亲没有答应要将她的孩子送到县城里去念书，那么，十年后的我，又将成为怎样的一个我呢？或许</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhujiqian/p/12259268.html</dc:identifier>
</item>
</channel>
</rss>