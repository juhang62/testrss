<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>计量经济学导论11：波动率模型 - 李旭东东东东东阿东</title>
<link>http://www.cnblogs.com/lixddd/p/14407876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixddd/p/14407876.html</guid>
<description>&lt;p&gt;波动率模型主要用于研究金融时间序列分析，本章主要介绍了ARCH模型和GARCH模型的基本性质和推导。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;341.92774637503&quot;&gt;


&lt;h2 id=&quot;什么是波动率？&quot;&gt;什么是波动率？&lt;/h2&gt;
&lt;p&gt;波动率指的是资产价格的波动强弱程度，类似于概率论中随机变量标准差的概念。波动率不能直接观测，可以从资产收益率中看出波动率的一些特征。&lt;/p&gt;
&lt;p&gt;为建立波动率随时间变化的一般模型，我们定义波动率是收益率的条件标准差。设 &lt;span class=&quot;math inline&quot;&gt;\(r_t\)&lt;/span&gt; 是某种资产在 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 时刻的基于某时间单位的对数收益率，一般认为 &lt;span class=&quot;math inline&quot;&gt;\(\{r_t\}\)&lt;/span&gt; 序列是前后不相关的或低阶自相关的，但不是前后独立的时间序列。&lt;/p&gt;
&lt;p&gt;一元波动率模型就是试图刻画收益率这种本身不相关或低阶自相关，但前后不独立的模型。用 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{F}_{t-1}\)&lt;/span&gt; 表示截止到 &lt;span class=&quot;math inline&quot;&gt;\(t-1\)&lt;/span&gt; 时刻的收益率的全部历史信息，尤其是包括这些收益率的线性组合。考虑 &lt;span class=&quot;math inline&quot;&gt;\(r_t\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{F}_{t-1}\)&lt;/span&gt; 条件下的条件均值和条件方差：&lt;/p&gt;
&lt;p&gt;\[\mu_t={\rm E}(r_t|\mathcal{F}_{t-1}) \ , \ \ \ \ \sigma_t^2={\rm Var}(r_t|\mathcal{F}_{t-1}) \ . \]&lt;/p&gt;
&lt;p&gt;可以将 &lt;span class=&quot;math inline&quot;&gt;\(r_t\)&lt;/span&gt; 分解为：&lt;/p&gt;
&lt;p&gt;\[r_t=\mu_t+a_t \ , \]&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\{a_t\}\)&lt;/span&gt; 为不相关的白噪声序列，这里我们对白噪声序列假设 &lt;span class=&quot;math inline&quot;&gt;\({\rm E}(a_t|\mathcal{F}_{t-1})=0\)&lt;/span&gt; 。这个条件比不相关零均值白噪声序列的条件要强一些。综合以上条件，可以有&lt;/p&gt;
&lt;p&gt;\[\sigma_t^2={\rm Var}(r_t|\mathcal{F}_{t-1})={\rm Var}(a_t|\mathcal{F}_{t-1})={\rm E}(a_t^2|\mathcal{F}_{t-1}) \ . \]&lt;/p&gt;
&lt;p&gt;这里的 &lt;span class=&quot;math inline&quot;&gt;\(\sigma_t\)&lt;/span&gt; 就是波动率，是收益率的条件标准差。&lt;/p&gt;
&lt;p&gt;如果假设模型中的白噪声 &lt;span class=&quot;math inline&quot;&gt;\(\{a_t\}\)&lt;/span&gt; 是独立序列， 则 &lt;span class=&quot;math inline&quot;&gt;\(\sigma_t^2\equiv\sigma^2\)&lt;/span&gt; ，波动率就没有建模的可能。但是实际上，假定 &lt;span class=&quot;math inline&quot;&gt;\(\{a_t\}\)&lt;/span&gt; 是零均值不相关的白噪声，满足 &lt;span class=&quot;math inline&quot;&gt;\({\rm E}(a_t|\mathcal{F}_{t-1})=0\)&lt;/span&gt; ，但并不是独立序列。&lt;/p&gt;
&lt;p&gt;波动率模型的主要问题就是对 &lt;span class=&quot;math inline&quot;&gt;\(\sigma_t^2\)&lt;/span&gt; 建模，这种模型叫做条件异方差模型。将收益率 &lt;span class=&quot;math inline&quot;&gt;\(r_t\)&lt;/span&gt; 分解后，有&lt;/p&gt;
&lt;p&gt;\[a_t=r_t-{\rm E}(r_t|\mathcal{F}_{t-1}) \ , \]&lt;/p&gt;
&lt;p&gt;称 &lt;span class=&quot;math inline&quot;&gt;\(\{a_t\}\)&lt;/span&gt; 为资产收益率 &lt;span class=&quot;math inline&quot;&gt;\(\{r_t\}\)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 时刻的新息。&lt;span class=&quot;math inline&quot;&gt;\(\sigma_t^2\)&lt;/span&gt; 的模型称为 &lt;span class=&quot;math inline&quot;&gt;\(\{r_t\}\)&lt;/span&gt; 的波动率方程。&lt;/p&gt;
&lt;h2 id=&quot;模型引入&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}\)&lt;/span&gt; 模型引入&lt;/h2&gt;
&lt;p&gt;自回归条件异方差模型，简称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}\)&lt;/span&gt; 模型。这是我们将波动率定义为条件标准差之后，第一次提出的波动率的理论模型。&lt;/p&gt;
&lt;p&gt;我们通常意义上考虑的异方差问题，是指在一个静态模型中，随机误差项的方差取决于模型中的解释变量。然而在时间序列模型中，我们还需要对异方差的动态形式加以考虑。即使不存在通常意义上的异方差，随机误差项的方差还可能取决于时间序列在以前时期的波动程度。我们用条件方差来理解这一问题。&lt;/p&gt;
&lt;p&gt;考虑一个简单静态模型&lt;/p&gt;
&lt;p&gt;\[y_t=\beta_0+\beta_1x_t+u_t \ , \]&lt;/p&gt;
&lt;p&gt;如果该模型满足时间序列模型假设 TS.1-TS.5，则显然 OLS 估计量仍然是 BLUE 的。这里的同方差假设指的是 &lt;span class=&quot;math inline&quot;&gt;\({\rm Var}(u_t|X)\)&lt;/span&gt; 是一个常数。但如果改变条件，还可能存在其他形式的异方差：&lt;/p&gt;
&lt;p&gt;\[{\rm Var}(u_t|X,u_{t-1},u_{t-2},\cdots)={\rm Var}(u_t|X,u_{t-1})\triangleq\alpha_0+\alpha_1u_{t-1}^2 \ , \]&lt;/p&gt;
&lt;p&gt;这就是一阶自回归条件异方差模型。&lt;/p&gt;
&lt;p&gt;一般地，我们省略解释变量条件，将 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}(1)\)&lt;/span&gt; 模型写为&lt;/p&gt;
&lt;p&gt;\[{\rm Var}(u_t|u_{t-1},u_{t-2},\cdots)={\rm Var}(u_t|u_{t-1})\triangleq\alpha_0+\alpha_1u_{t-1}^2 \ . \]&lt;/p&gt;
&lt;h2 id=&quot;模型&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}(1)\)&lt;/span&gt; 模型&lt;/h2&gt;
&lt;p&gt;建立 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}\)&lt;/span&gt; 模型考虑了两个基本思想：&lt;/p&gt;
&lt;p&gt;(1) 随机扰动序列 &lt;span class=&quot;math inline&quot;&gt;\(u_t\)&lt;/span&gt; 是前后不相关的，但不独立的。&lt;/p&gt;
&lt;p&gt;(2) 序列 &lt;span class=&quot;math inline&quot;&gt;\(u_t\)&lt;/span&gt; 的不独立性可以描述为基于历史信息的条件方差 &lt;span class=&quot;math inline&quot;&gt;\({\rm Var}(u_t|\mathcal{F}_{t-1})\)&lt;/span&gt; 可以用二次项序列 &lt;span class=&quot;math inline&quot;&gt;\(u_t^2\)&lt;/span&gt; 的滞后项的线性组合表示。&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{F}_{t-1}\)&lt;/span&gt; 指的是 &lt;span class=&quot;math inline&quot;&gt;\(t-1\)&lt;/span&gt; 期的全部信息。&lt;/p&gt;
&lt;p&gt;在 Wooldridge 的《计量经济学导论》中，将 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}(1)\)&lt;/span&gt; 模型近似设定为&lt;/p&gt;
&lt;p&gt;\[u_t^2=\alpha_0+\alpha_1u_{t-1}^2+v_t \ , \ \ \ \ v_t\sim{\rm WN}(0,\,\sigma_0^2) \ . \]&lt;/p&gt;
&lt;p&gt;由于条件方差恒正，因此在这个模型中，只有当 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_0&amp;gt;0\)&lt;/span&gt; 且 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_1&amp;gt;0\)&lt;/span&gt; 时该模型是有具有动态意义的。&lt;/p&gt;
&lt;p&gt;更加广为使用的 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}(1)\)&lt;/span&gt; 模型是 Tsay 在《金融时间序列分析》中给出的模型设定：&lt;/p&gt;
&lt;p&gt;\[u_t=\sigma_t\varepsilon_t \ , \]&lt;/p&gt;
&lt;p&gt;\[\sigma_t^2=\alpha_0+\alpha_1u_{t-1}^2 \ , \]&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\{\varepsilon_t\}\)&lt;/span&gt; 是零均值标准方差的独立同分布白噪声 &lt;span class=&quot;math inline&quot;&gt;\({\rm WN}(0,\,1)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先求解条件方差：&lt;/p&gt;
&lt;p&gt;\[{\rm Var}(u_t|u_{t-1})={\rm E}(u_t^2|u_{t-1})=\sigma_t^2{\rm E}(\varepsilon_t^2)=\sigma_t^2 \]&lt;/p&gt;
&lt;p&gt;接着求解无条件方差：&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} {\rm Var}(u_t)&amp;amp;={\rm E}(u_t^2)={\rm E}\left[{\rm E}(u_t^2|u_{t-1})\right]={\rm E}\left[\sigma^2_t{\rm E}(\varepsilon_t^2)\right] \\ &amp;amp;={\rm E}(\sigma_t^2)={\rm E}(\alpha_0+\alpha_1u_{t-1}^2)=\alpha_0+\alpha_1{\rm E}(u_{t-1}^2)\ . \end{aligned} \]&lt;/p&gt;
&lt;p&gt;由于 &lt;span class=&quot;math inline&quot;&gt;\(\{u_t\}\)&lt;/span&gt; 是一个零均值平稳序列，有 &lt;span class=&quot;math inline&quot;&gt;\({\rm E}(u_t)=0\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\({\rm Var}(u_t)={\rm Var}(u_{t-1})\)&lt;/span&gt; ，因此&lt;/p&gt;
&lt;p&gt;\[{\rm Var}(u_t)=\alpha_0+\alpha_1{\rm Var}(u_{t-1})=\alpha_0+\alpha_1{\rm Var}(u_{t}) \ , \]&lt;/p&gt;
&lt;p&gt;进而有&lt;/p&gt;
&lt;p&gt;\[{\rm Var}(u_t)=\frac{\alpha_0}{1-\alpha_1} \ . \]&lt;/p&gt;
&lt;p&gt;这里要求 &lt;span class=&quot;math inline&quot;&gt;\(0&amp;lt;\alpha_1&amp;lt;1\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;模型-1&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}(m)\)&lt;/span&gt; 模型&lt;/h2&gt;
&lt;p&gt;进而我们将模型扩展为一般的 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}(m)\)&lt;/span&gt; 模型，首先给出模型设定：&lt;/p&gt;
&lt;p&gt;\[u_t=\sigma_t\varepsilon_t \ , \]&lt;/p&gt;
&lt;p&gt;\[\sigma_t^2=\alpha_0+\alpha_1u_{t-1}^2+\cdots+\alpha_mu_{t-m}^2 \]&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\{\varepsilon_t\}\)&lt;/span&gt; 是零均值标准方差的独立同分布白噪声 &lt;span class=&quot;math inline&quot;&gt;\({\rm WN}(0,\,1)\)&lt;/span&gt; ，并且 &lt;span class=&quot;math inline&quot;&gt;\(\alpha_0&amp;gt;0\ ,\ \alpha_j\geq0\ ,\ j=1,2,\cdots,m\)&lt;/span&gt; 。一般假设为标准正态分布或是标准化的 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 分布。&lt;/p&gt;
&lt;p&gt;另外 &lt;span class=&quot;math inline&quot;&gt;\(\{\alpha_j\}\)&lt;/span&gt; 还需要满足使得 &lt;span class=&quot;math inline&quot;&gt;\({\rm Var}(u_t)\)&lt;/span&gt; 有限的条件，类似于 &lt;span class=&quot;math inline&quot;&gt;\({\rm AR}(p)\)&lt;/span&gt; 序列的平稳性的特征根条件，并且&lt;/p&gt;
&lt;p&gt;\[\sum_{j=1}^m\alpha_j&amp;lt;1\ . \]&lt;/p&gt;
&lt;p&gt;模型设定中的第二个方程被称为波动率方程。由于该方程的右侧仅出现了截止到 &lt;span class=&quot;math inline&quot;&gt;\(t-1\)&lt;/span&gt; 时刻的确定性函数而没有新增的随机扰动，所以称 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}\)&lt;/span&gt; 模型为确定性的波动率模型。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{F}_{t-1}\)&lt;/span&gt; 表示 &lt;span class=&quot;math inline&quot;&gt;\(t-1\)&lt;/span&gt; 期的全部历史信息，由 &lt;span class=&quot;math inline&quot;&gt;\(\{\varepsilon_t\}\)&lt;/span&gt; 的独立性知 &lt;span class=&quot;math inline&quot;&gt;\(\{\varepsilon_t\}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{F}_{t-1}\)&lt;/span&gt; 独立。&lt;/p&gt;
&lt;p&gt;类似于 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}(1)\)&lt;/span&gt; 模型的无条件方差，可以利用全期望公式计算得到 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}(m)\)&lt;/span&gt; 模型的无条件方差如下：&lt;/p&gt;
&lt;p&gt;首先计算条件方差&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} {\rm Var}(u_t|u_{t-1},u_{t-2},\cdots)&amp;amp;= {\rm E}(u_t^2|u_{t-1},u_{t-2},\cdots) \\ &amp;amp;=\sigma_t^2{\rm E}(\varepsilon_t^2|u_{t-1},u_{t-2},\cdots) \\ &amp;amp;=\sigma_t^2 \end{aligned} \]&lt;/p&gt;
&lt;p&gt;进而计算无条件方差&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} {\rm Var}(u_t)={\rm E}(u_t^2)&amp;amp;= {\rm E}\left[{\rm E}(u_t^2|u_{t-1},u_{t-2},\cdots)\right] \\ &amp;amp;={\rm E}(\sigma_t^2) \\ &amp;amp;={\rm E}(\alpha_0+\alpha_1u_{t-1}^2+\cdots+\alpha_mu_{t-m}^2) \\ &amp;amp;=\alpha_0+\alpha_1{\rm E}(u_{t-1}^2)+\cdots+\alpha_m{\rm E}(u_{t-m}^2)\ . \end{aligned} \]&lt;/p&gt;
&lt;p&gt;由 &lt;span class=&quot;math inline&quot;&gt;\(\{u_t\}\)&lt;/span&gt; 的平稳性 &lt;span class=&quot;math inline&quot;&gt;\({\rm E}(u_t^2)={\rm E}(u_{t-1}^2)=\cdots={\rm E}(u_{t-m}^2)\)&lt;/span&gt; 可以解得&lt;/p&gt;
&lt;p&gt;\[{\rm Var}(u_t)={\rm E}(u_t^2)=\frac{\alpha_0}{1-\displaystyle\sum_{j=1}^m\alpha_j} \ . \]&lt;/p&gt;
&lt;p&gt;以上就是常用的 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}\)&lt;/span&gt; 模型的性质。但我们也会发现 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}(m)\)&lt;/span&gt; 模型的具有如下缺点：模型中引入的都是扰动项 &lt;span class=&quot;math inline&quot;&gt;\(u_t\)&lt;/span&gt; 的平方项，因此恒为正值，没有考虑正、负扰动对于波动率的不对称影响。此外，&lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}\)&lt;/span&gt; 模型不能提供更多信息来帮助理解方程的来源，仅仅提供一种方法来描述条件方差是如何变化的。&lt;/p&gt;
&lt;h2 id=&quot;模型引入和模型设定&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}\)&lt;/span&gt; 模型引入和模型设定&lt;/h2&gt;
&lt;p&gt;在之前的介绍中，&lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}\)&lt;/span&gt; 模型用来描述波动率能得到很好的效果，但实际建模时可能需要较高的阶数。提出了ARCH模型的一种重要推广模型，称为 &lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}\)&lt;/span&gt; 模型。&lt;/p&gt;
&lt;p&gt;Tsay 在《金融时间序列分析》一书中引入了对数收益率 &lt;span class=&quot;math inline&quot;&gt;\(r_t\)&lt;/span&gt; 的概念。事实上，对于一个对数收益率 &lt;span class=&quot;math inline&quot;&gt;\(r_t\)&lt;/span&gt; 的新息序列&lt;/p&gt;
&lt;p&gt;\[u_t=r_t-{\rm E}(r_t|\mathcal{F}_{t-1}) \ , \]&lt;/p&gt;
&lt;p&gt;常常用 &lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}\)&lt;/span&gt; 模型来刻画 &lt;span class=&quot;math inline&quot;&gt;\(\{u_t\}\)&lt;/span&gt; 序列的性质。下面给出一般情况下 &lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}(m,\,s)\)&lt;/span&gt; 的模型设定：&lt;/p&gt;
&lt;p&gt;\[u_t=\sigma_t\varepsilon_t \ , \]&lt;/p&gt;
&lt;p&gt;\[\sigma_t^2=\alpha_0+\sum_{i=1}^m\alpha_iu_{t-i}^2+\sum_{j=1}^s\beta_j\sigma_{t-j}^2 \ , \]&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(\{\varepsilon_t\}\)&lt;/span&gt; 为零均值单位方差的独立同分布白噪声序列，&lt;span class=&quot;math inline&quot;&gt;\(\alpha_0&amp;gt;0\ , \ \alpha_i\geq0\ , \ \beta_j\geq0\)&lt;/span&gt; ，并且&lt;/p&gt;
&lt;p&gt;\[0&amp;lt;\sum_{i=1}^m\alpha_i+\sum_{j=1}^s\beta_j&amp;lt;1 \]&lt;/p&gt;
&lt;p&gt;这个条件用来保证满足模型的的 &lt;span class=&quot;math inline&quot;&gt;\(u_t\)&lt;/span&gt; 无条件方差有限且不变，而条件方差 &lt;span class=&quot;math inline&quot;&gt;\(\sigma_t^2\)&lt;/span&gt; 可以随时间 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 的变化而变化。&lt;/p&gt;
&lt;h2 id=&quot;模型-2&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}(1,\,1)\)&lt;/span&gt; 模型&lt;/h2&gt;
&lt;p&gt;下面以最简单的 &lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}(1,\,1)\)&lt;/span&gt; 模型为例研究 &lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}\)&lt;/span&gt; 模型的性质。依然定义 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{F}_{t-1}\)&lt;/span&gt; 表示截止到 &lt;span class=&quot;math inline&quot;&gt;\(t-1\)&lt;/span&gt; 时刻的 &lt;span class=&quot;math inline&quot;&gt;\(u_{t-i}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\sigma_{t-j}\)&lt;/span&gt; 所包含的全部历史信息。首先写出模型设定：&lt;/p&gt;
&lt;p&gt;\[u_t=\sigma_t\varepsilon_t \ , \ \ \ \ \varepsilon_t\sim{\rm i.i.d.}\,{\rm WN}(0,\,1)\ , \]&lt;/p&gt;
&lt;p&gt;\[\sigma_t^2=\alpha_0+\alpha_1u_{t-1}^2+\beta_1\sigma_{t-1}^2\ , \]&lt;/p&gt;
&lt;p&gt;计算出条件期望：&lt;/p&gt;
&lt;p&gt;\[{\rm E}(u_t|\mathcal{F}_{t-1})={\rm E}(\sigma_t\varepsilon_t|\mathcal{F}_{t-1})=\sigma_t{\rm E}(\varepsilon_t|\mathcal{F}_{t-1})=0 \ . \]&lt;/p&gt;
&lt;p&gt;这里利用了 &lt;span class=&quot;math inline&quot;&gt;\(\sigma_t\in\mathcal{F}_{t-1}\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\varepsilon_t\)&lt;/span&gt; 与 &lt;span class=&quot;math inline&quot;&gt;\(\mathcal{F}\)&lt;/span&gt; 独立。&lt;br/&gt;进而计算无条件期望&lt;/p&gt;
&lt;p&gt;\[{\rm E}(u_t)={\rm E}[{\rm E}(u_t|\mathcal{F}_{t-1})]=0 \ . \]&lt;/p&gt;
&lt;p&gt;即 &lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}\)&lt;/span&gt; 模型的新息 &lt;span class=&quot;math inline&quot;&gt;\(u_t\)&lt;/span&gt; 的无条件期望为零。&lt;br/&gt;最后利用全期望公式计算无条件方差，假设 &lt;span class=&quot;math inline&quot;&gt;\(\{u_t\}\)&lt;/span&gt; 序列存在严平稳解，则有&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} {\rm Var}(u_t)={\rm E}(u_t^2)&amp;amp;={\rm E}\left[{\rm E}(u_t^2|\mathcal{F}_{t-1})\right]={\rm E}\left[{\rm E}(\sigma_t^2\varepsilon_t^2|\mathcal{F}_{t-1})\right] \\ \\ &amp;amp;={\rm E}\left[\sigma_t^2{\rm E}(\varepsilon_t^2|\mathcal{F}_{t-1})\right]={\rm E}\left[\sigma_t^2{\rm E}(\varepsilon_t^2)\right] \\ \\ &amp;amp;={\rm E}\left[\sigma_t^2\right]={\rm E}\left[\alpha_0+\alpha_1u_{t-1}^2+\beta_1\sigma_{t-1}^2\right] \\ \\ &amp;amp;=\alpha_0+\alpha_1{\rm E}(u_{t-1}^2)+\beta_1{\rm E}(\sigma_{t-1}^2) \\ \\ &amp;amp;=\alpha_0+(\alpha_1+\beta_1){\rm E}(u_{t-1}^2)\ . \end{aligned} \]&lt;/p&gt;
&lt;p&gt;由 &lt;span class=&quot;math inline&quot;&gt;\({\rm E}(u_t^2)={\rm E}(u_{t-1}^2)\)&lt;/span&gt; 解得&lt;/p&gt;
&lt;p&gt;\[{\rm Var}(u_t)={\rm E}(u_t^2)=\frac{\alpha_0}{1-\alpha_1-\beta_1} \ . \]&lt;/p&gt;
&lt;h2 id=&quot;预测波动率示例&quot;&gt;&lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}(1,\,1)\)&lt;/span&gt; 预测波动率示例&lt;/h2&gt;
&lt;p&gt;首先写出利用截止到 &lt;span class=&quot;math inline&quot;&gt;\(h\)&lt;/span&gt; 时刻的观测值作一步预测的波动率模型：&lt;/p&gt;
&lt;p&gt;\[\sigma_{h+1}^2=\alpha_0+\alpha_1u_{h}^2+\beta_1\sigma_h^2\in\mathcal{F}_h \ . \]&lt;/p&gt;
&lt;p&gt;因此有数学期望&lt;/p&gt;
&lt;p&gt;\[\sigma_h^2(1)={\rm E}(\sigma^2_{h+1}|\mathcal{F}_h)=\sigma_{h+1}^2=\alpha_0+\alpha_1u_{h}^2+\beta_1\sigma_h^2 \ . \]&lt;/p&gt;
&lt;p&gt;这说明对未来波动率的一步预测可以利用波动率模型直接给出。&lt;/p&gt;
&lt;p&gt;继续计算两步预测：&lt;br/&gt;利用 &lt;span class=&quot;math inline&quot;&gt;\(u_t=\sigma_t\varepsilon_t\)&lt;/span&gt; 化简 &lt;span class=&quot;math inline&quot;&gt;\(\sigma_{h+2}^2\)&lt;/span&gt; :&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \sigma_{h+2}^2&amp;amp;=\alpha_0+\alpha_1u_{h+1}^2+\beta_1\sigma_{h+1}^2 \\ \\ &amp;amp;=\alpha_0+\alpha_1\sigma_{h+1}^2\varepsilon_{j+1}^2+\beta_1\sigma_{h+1}^2 \\ \\ &amp;amp;=\alpha_0+(\alpha_1\varepsilon_{h+1}^2+\beta_1)\sigma_{h+1}^2 \ . \end{aligned} \]&lt;/p&gt;
&lt;p&gt;\[\begin{aligned} \sigma_h^2(2)&amp;amp;={\rm E}(\sigma^2_{h+2}|\mathcal{F}_h) \\ \\ &amp;amp;={\rm E}\left[\alpha_0+(\alpha_1\varepsilon_{h+1}^2+\beta_1)\sigma_{h+1}^2|\mathcal{F}_h\right] \\ \\ &amp;amp;=\alpha_0+{\rm E}\left[\alpha_1\varepsilon_{h+1}^2+\beta_1|\mathcal{F}_h\right]\sigma_h^2(1) \\ \\ &amp;amp;=\alpha_0+\left(\alpha_1+\beta_1\right)\sigma_h^2(1) \ . \end{aligned} \]&lt;/p&gt;
&lt;p&gt;类似地，可以求得递推预测公式：&lt;/p&gt;
&lt;p&gt;\[\sigma_h^2(l)=\alpha_0+\left(\alpha_1+\beta_1\right)\sigma_h^2(l-1) \ , \]&lt;/p&gt;
&lt;p&gt;迭代计算得&lt;/p&gt;
&lt;p&gt;\[\sigma_h^2(l)=\frac{\alpha_0\left[1-(\alpha_1+\beta_1)^{l-1}\right]}{1-(\alpha_1+\beta_1)}+(\alpha_1+\beta_1)^{l-1}\sigma_h^2(1) \ , \]&lt;/p&gt;
&lt;p&gt;当 &lt;span class=&quot;math inline&quot;&gt;\(l\to\infty\)&lt;/span&gt; 时，有&lt;/p&gt;
&lt;p&gt;\[\sigma_h^2(l)\to\frac{\alpha_0}{1-(\alpha_1+\beta_1)}={\rm Var}(u_t) \ . \]&lt;/p&gt;
&lt;p&gt;即波动率的多步条件方差预测趋于的 &lt;span class=&quot;math inline&quot;&gt;\(u_t\)&lt;/span&gt; 的无条件方差。&lt;/p&gt;
&lt;p&gt;和 &lt;span class=&quot;math inline&quot;&gt;\({\rm ARCH}\)&lt;/span&gt; 模型类似，使用 &lt;span class=&quot;math inline&quot;&gt;\({\rm GARCH}\)&lt;/span&gt; 模型对于收益率的正负不对称性仍然无法反映。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 16 Feb 2021 15:10:00 +0000</pubDate>
<dc:creator>李旭东东东东东阿东</dc:creator>
<og:description>波动率模型主要用于研究金融时间序列分析，本章主要介绍了ARCH模型和GARCH模型的基本性质和推导。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixddd/p/14407876.html</dc:identifier>
</item>
<item>
<title>Bean的生命周期 - 是倩倩不是欠欠</title>
<link>http://www.cnblogs.com/cathyqq/p/14407796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cathyqq/p/14407796.html</guid>
<description>&lt;p&gt;bean创建--&amp;gt;初始化--&amp;gt;销毁&lt;/p&gt;
&lt;h2 id=&quot;容器管理bean的生命周期&quot;&gt;容器管理Bean的生命周期&lt;/h2&gt;
&lt;p&gt;我们可以自定义初始化和销毁方法,容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;创建&lt;/strong&gt;（对象创建）&lt;/p&gt;
&lt;p&gt;单实例：在容器启动的时候创建&lt;/p&gt;
&lt;p&gt;多实例：在每次获取的时候创建&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对象创建完成，并赋值好，调用初始化方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;销毁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单实例bean在容器关闭的时候销毁&lt;/p&gt;
&lt;p&gt;多实例bean容器不会调用销毁，这时候可以手动来调用销毁方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-指定初始化和销毁方法：&quot;&gt;1. 指定初始化和销毁方法：&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;通过@Bean注解指定init-method和destory-method
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要被注入的bean类Car&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class Car {
    public Car(){
        System.out.println(&quot;car constructor---&quot;);
    }
    //初始化里可以进行一系列操作，如属性赋值
    public void init(){
        System.out.println(&quot;car init---&quot;);
    }
    //销毁里可以进行比如连接数据源的关闭等等
    public void destroy(){
        System.out.println(&quot;car destory---&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置类：指定了初始化方法initMethod = &quot;init&quot;和销毁方法destroyMethod = &quot;destroy&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class BeanConfigOfLifeCycle {

    @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)
    public Car car(){
        return new Car();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class IOCTestLifeCycle {

    @Test
    public void test01() {
        //1、ioc容器的创建
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfigOfLifeCycle.class);
        System.out.println(&quot;容器创建完成---&quot;);
        //关闭容器
        applicationContext.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;car constructor---
car init---
容器创建完成---
car destory---
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2--通过实现接口的方式&quot;&gt;2. 通过实现接口的方式&lt;/h2&gt;
&lt;p&gt;让Bean实现Spring提供的InitializingBean（定义初始化逻辑）接口和 DisposableBean（定义销毁逻辑）接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class Cat implements InitializingBean, DisposableBean {

    public Cat(){
        System.out.println(&quot;car constructor---&quot;);
    }

    @Override
    public void destroy() throws Exception {
        System.out.println(&quot;cat destory---&quot;);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println(&quot;cat afterPropertiesSet---&quot;);
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-使用jsr250&quot;&gt;3. 使用JSR250&lt;/h2&gt;
&lt;p&gt;@PostConstruct：在bean创建完成并且属性赋值完成之后来执行初始化方法&lt;/p&gt;
&lt;p&gt;@PreDestroy：在容器销毁bean之前通知我们进行清理工作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class Dog implements ApplicationContextAware {

    public Dog(){
        System.out.println(&quot;dog constructor---&quot;);
    }

    /**
     * 对象创建并赋值之后调用
     */
    @PostConstruct
    public void init(){
        System.out.println(&quot;dog postConstructor---&quot;);
    }

    /**
     * 在容器移除对象之前调用
     */
    @PreDestroy
    public void preDestroy(){
        System.out.println(&quot;dog preDestroy---&quot;);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4--使用bean的后置处理器&quot;&gt;4. 使用Bean的后置处理器&lt;/h2&gt;
&lt;p&gt;BeanPostProcessor接口：bean的后置处理器，在bean初始化前后进行一些处理工作&lt;br/&gt;postProcessBeforeInitialization：在初始化之前工作&lt;br/&gt;postProcessAfterInitialization：在初始化之后工作&lt;/p&gt;
&lt;p&gt;自定义的BeanPostProcessor还可以实现Ordered接口进行自定义排序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class MyBeanPostProcessor implements BeanPostProcessor, Ordered {

    /**
     * 在所有其他初始化操作（Bean指定、实现、JSR250）之前执行处理
     * @param bean
     * @param beanName
     * @return
     * @throws BeansException
     */
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;postProcessBeforeInitialization---&quot;+beanName+&quot;---&quot;);
        return bean;
    }

    /**
     * 在所有初始化之后操作之后执行处理
     * @param bean
     * @param beanName
     * @return
     * @throws BeansException
     */
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println(&quot;postProcessAfterInitialization---&quot;+beanName+&quot;---&quot;);
        return bean;
    }

    @Override
    public int getOrder() {
        return 0;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置类：@Import注入MyBeanPostProcessor&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@Import(MyBeanPostProcessor.class)
public class BeanConfigOfLifeCycle {

    @Bean(initMethod = &quot;init&quot;, destroyMethod = &quot;destroy&quot;)
    public Car car(){
        return new Car();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class IOCTestLifeCycle {

    @Test
    public void test01() {
        //1、ioc容器的创建
        AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(BeanConfigOfLifeCycle.class);
        System.out.println(&quot;容器创建完成---&quot;);
        //关闭容器
        applicationContext.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;car constructor---
postProcessBeforeInitialization---car---
car init---
postProcessAfterInitialization---car---
容器创建完成---
car destory---
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 16 Feb 2021 14:42:00 +0000</pubDate>
<dc:creator>是倩倩不是欠欠</dc:creator>
<og:description>(目录) Bean的生命周期 bean创建--&amp;amp;gt;初始化--&amp;amp;gt;销毁 容器管理Bean的生命周期 我们可以自定义初始化和销毁方法,容器在bean进行到当前生命周期的时候来调用我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cathyqq/p/14407796.html</dc:identifier>
</item>
<item>
<title>Go string 一清二楚 - YahuiAn</title>
<link>http://www.cnblogs.com/yahuian/p/14407700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yahuian/p/14407700.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1459179/202102/1459179-20210216220217972-221111251.png&quot; class=&quot;desc_img&quot;/&gt;字符串（string） 作为 go 语言的基本数据类型，在开发中必不可少，我们务必深入学习一下，做到一清二楚。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;156.35490753912&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1459179/202102/1459179-20210216220217972-221111251.png&quot; alt=&quot;gopher&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;字符串（string） 作为 go 语言的基本数据类型，在开发中必不可少，我们务必深入学习一下，做到一清二楚。&lt;/p&gt;
&lt;p&gt;本文假设读者已经知道切片（slice）的使用，如不了解，可阅读 &lt;a href=&quot;https://www.cnblogs.com/yahuian/p/11521501.html#%E5%88%87%E7%89%87&quot; target=&quot;_blank&quot;&gt;Go 切片 基本知识点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了更好的理解后文，推荐先阅读 &lt;a href=&quot;http://c.biancheng.net/cpp/html/3420.html&quot; target=&quot;_blank&quot;&gt;Unicode 字符集，UTF-8 编码&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;是什么&quot;&gt;是什么&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;In Go, a string is in effect a read-only slice of bytes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 go 语言中，字符串实际上是一个&lt;strong&gt;只读&lt;/strong&gt;的&lt;strong&gt;字节切片&lt;/strong&gt;，其数据结构定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// runtime/string.go
type stringStruct struct {
        str unsafe.Pointer      // 指向底层字节数组的指针
        len int                         // 字节数组的长度 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：byte 其实是 uint8 的类型别名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
// used, by convention, to distinguish byte values from 8-bit unsigned
// integer values.
type byte = uint8
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;怎么用&quot;&gt;怎么用&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func main() {
        // 使用字符串字面量初始化
        var a = &quot;hi,狗&quot;
        fmt.Println(a)

        // 可以使用下标访问，但不可修改
        fmt.Printf(&quot;a[0] is %d\n&quot;, a[0])
        fmt.Printf(&quot;a[0:2] is %s\n&quot;, a[0:2])
        // a[0] = 'a' 编译报错，Cannot assign to a[0]
    
    // 字符串拼接
        var b = a + &quot;狗&quot;
        fmt.Printf(&quot;b is %s\n&quot;, b)

        // 使用内置 len() 函数获取其长度
        fmt.Printf(&quot;a's length is: %d\n&quot;, len(a))

        // 使用 for;len 遍历
        for i := 0; i &amp;lt; len(a); i++ {
                fmt.Println(i, a[i])
        }

        // 使用 for;range 遍历
        for i, v := range a {
                fmt.Println(i, v)
        }
}


/* output
hi,狗

a[0] is 104
a[0:2] is hi

b is hi,狗狗

a's length is: 6

0 104
1 105
2 44
3 231
4 139
5 151

0 104
1 105
2 44
3 29399
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果读者在看上面的代码时有疑惑，不用着急，下文将会挨个解读。&lt;/p&gt;
&lt;h2 id=&quot;只读&quot;&gt;只读&lt;/h2&gt;
&lt;p&gt;字符串常量会在编译期分配到只读段，对应数据地址不可写入，相同的字符串常量不会重复存储&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func main() {
        var a = &quot;hello&quot;
        fmt.Println(a, &amp;amp;a, (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;a)))
        a = &quot;world&quot;
        fmt.Println(a, &amp;amp;a, (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;a)))
        var b = &quot;hello&quot;
        fmt.Println(b, &amp;amp;b, (*reflect.StringHeader)(unsafe.Pointer(&amp;amp;b)))
}

/* output
字符串字面量 该变量的内存地址 底层字节切片
hello 0xc0000381f0 &amp;amp;{5033779 5}
world 0xc0000381f0 &amp;amp;{5033844 5}
hello 0xc000038220 &amp;amp;{5033779 5}
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 hello 在底层只存储了一份&lt;/p&gt;
&lt;h2 id=&quot;forlen-遍历&quot;&gt;for;len 遍历&lt;/h2&gt;
&lt;p&gt;go 的源代码都是 UTF-8 编码格式的，上例中的”狗“字占用三个字节，即 231 139 151（&lt;a href=&quot;https://unicode-table.com/en/72D7/&quot; target=&quot;_blank&quot;&gt;Unicode Character Table&lt;/a&gt;），所以上例的运行结果很清楚。&lt;/p&gt;
&lt;p&gt;于此同时，也可以将字符串转化为字节切片&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func main() {
        var a = &quot;hi,狗&quot;
        b := []byte(a)
        fmt.Println(b)  // [104 105 44 231 139 151]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;forrange-遍历&quot;&gt;for;range 遍历&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;The Unicode standard uses the term &quot;code point&quot; to refer to the item represented by a single value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Unicode 标准中，使用术语 &lt;code&gt;code point&lt;/code&gt; 来表示由单个值表示的项，通俗点来说，U+72D7（十进制表示为 29399）代表符号 ”狗“&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&quot;Code point&quot; is a bit of a mouthful, so Go introduces a shorter term for the concept: &lt;em&gt;rune&lt;/em&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;code point 有点拗口，所以在 go 语言中专门有一个术语来代表它，即 rune&lt;/p&gt;
&lt;p&gt;注意：rune 其实是 int32 的类型别名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// rune is an alias for int32 and is equivalent to int32 in all ways. It is
// used, by convention, to distinguish character values from integer values.
type rune = int32
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在对字符串类型进行 for;range 遍历时，其实是按照 rune 类型来解码的，所以上例的运行结果也很清晰。&lt;/p&gt;
&lt;p&gt;与此同时，也可以将字符串转化为 rune 切片&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func main() {
        // 使用字符串字面量初始化
        var a = &quot;hi,狗&quot;
        r := []rune(a)
        fmt.Println(r) // [104 105 44 29399]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然我们也可以使用 &lt;code&gt;&quot;unicode/utf8&quot;&lt;/code&gt; 标准库，手动实现 for;range 语法糖相同的效果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func main() {
        var a = &quot;hi,狗&quot;
        for i, w := 0, 0; i &amp;lt; len(a); i += w {
                runeValue, width := utf8.DecodeRuneInString(a[i:])
                fmt.Printf(&quot;%#U starts at byte position %d\n&quot;, runeValue, i)
                w = width
        }
}

/* output
U+0068 'h' starts at byte position 0
U+0069 'i' starts at byte position 1
U+002C ',' starts at byte position 2
U+72D7 '狗' starts at byte position 3
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.golang.org/strings&quot; target=&quot;_blank&quot;&gt;Strings, bytes, runes and characters in Go&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://studygolang.com/topics/3727&quot; target=&quot;_blank&quot;&gt;为什么说go语言中的string是不可变的？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1ff4y1m72A&quot; target=&quot;_blank&quot;&gt;字符咋存？utf8咋编码？string啥结构？&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 16 Feb 2021 14:05:00 +0000</pubDate>
<dc:creator>YahuiAn</dc:creator>
<og:description>前言 字符串（string） 作为 go 语言的基本数据类型，在开发中必不可少，我们务必深入学习一下，做到一清二楚。 本文假设读者已经知道切片（slice）的使用，如不了解，可阅读 Go 切片 基本知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yahuian/p/14407700.html</dc:identifier>
</item>
<item>
<title>高并发之Phaser、ReadWriteLock、StampedLock - 等不到的口琴</title>
<link>http://www.cnblogs.com/Courage129/p/14407661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Courage129/p/14407661.html</guid>
<description>&lt;p&gt;本系列研究总结高并发下的几种同步锁的使用以及之间的区别,分别是:ReentrantLock、CountDownLatch、CyclicBarrier、Phaser、ReadWriteLock、StampedLock、Semaphore、Exchanger、LockSupport。由于博客园对博客字数的要求限制,会分为三个篇幅:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Courage129/p/14406756.html&quot; target=&quot;_blank&quot;&gt;高并发之ReentrantLock、CountDownLatch、CyclicBarrier&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Courage129/p/14407661.html&quot; target=&quot;_blank&quot;&gt;高并发之Phaser、ReadWriteLock、StampedLock&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Courage129/p/14408179.html&quot; target=&quot;_blank&quot;&gt;高并发之Semaphore、Exchanger、LockSupport&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;phaser&quot;&gt;Phaser&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Phaser&lt;/code&gt;是JDK7开始引入的一个同步工具类，适用于一些需要分阶段的任务的处理。它的功能与 &lt;strong&gt;CyclicBarrier&lt;/strong&gt;和&lt;strong&gt;CountDownLatch&lt;/strong&gt;有些类似，功能上与 CountDownLatch 和 CyclicBarrier类似但支持的场景更加灵活类似于一个多阶段的栅栏，并且功能更强大，我们来比较下这三者的功能：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;同步器&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;CountDownLatch&lt;/td&gt;
&lt;td&gt;倒数计数器，初始时设定计数器值，线程可以在计数器上等待，当计数器值归0后，所有等待的线程继续执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;CyclicBarrier&lt;/td&gt;
&lt;td&gt;循环栅栏，初始时设定参与线程数，当线程到达栅栏后，会等待其它线程的到达，当到达栅栏的总数满足指定数后，所有等待的线程继续执行&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;Phaser&lt;/td&gt;
&lt;td&gt;多阶段栅栏，可以在初始时设定参与线程数，也可以中途注册/注销参与者，当到达的参与者数量满足栅栏设定的数量后，会进行阶段升级（advance）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;相对于前面的CyclicBarrier和CountDownLatch而言,这个稍微有一些难以理解,这儿引入一个场景:&lt;strong&gt;结婚&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一场婚礼中势必分成很多个阶段,例如宾客到齐、举行婚礼、新郎新娘拜天地、入洞房、吃宴席、宾客离开等,如果把不同的人看成是不同的线程的话,那么不同的线程所要到的阶段是不一样的,例如新郎新娘可能要走完全流程,而宾客可能只是其中的几步而已。&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210216215157342-1364493326.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码示例:&lt;/p&gt;
&lt;p&gt;Person&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  static class Person {
        String name;

        public Person(String name) {
            this.name = name;
        }

        public void arrive() {
            milliSleep(r.nextInt(1000));
            System.out.printf(&quot;%s 到达现场！\n&quot;, name);
        }

        public void eat() {
            milliSleep(r.nextInt(1000));
            System.out.printf(&quot;%s 吃完!\n&quot;, name);
        }

        public void leave() {
            milliSleep(r.nextInt(1000));
            System.out.printf(&quot;%s 离开！\n&quot;, name);
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MarriagePhaser&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    static class MarriagePhaser extends Phaser {
        @Override
        protected boolean onAdvance(int phase, int registeredParties) {

            switch (phase) {
                case 0:
                    System.out.println(&quot;所有人到齐了！&quot;);
                    return false;
                case 1:
                    System.out.println(&quot;所有人吃完了！&quot;);
                    return false;
                case 2:
                    System.out.println(&quot;所有人离开了！&quot;);
                    System.out.println(&quot;婚礼结束！&quot;);
                    return true;
                default:
                    return true;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TestPhaser&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TestPhaser {
    static Random r = new Random();
    static MarriagePhaser phaser = new MarriagePhaser();

    static void milliSleep(int milli) {
        try {
            TimeUnit.MILLISECONDS.sleep(milli);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {

        phaser.bulkRegister(5);

        for(int i=0; i&amp;lt;5; i++) {
            final int nameIndex = i;
            new Thread(()-&amp;gt;{

                Person p = new Person(&quot;person &quot; + nameIndex);
                p.arrive();
                phaser.arriveAndAwaitAdvance();

                p.eat();
                phaser.arriveAndAwaitAdvance();

                p.leave();
                phaser.arriveAndAwaitAdvance();
            }).start();
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;person 0 到达现场！
person 2 到达现场！
person 4 到达现场！
person 1 到达现场！
person 3 到达现场！
所有人到齐了！
person 2 吃完!
person 0 吃完!
person 4 吃完!
person 3 吃完!
person 1 吃完!
所有人吃完了！
person 3 离开！
person 1 离开！
person 0 离开！
person 4 离开！
person 2 离开！
所有人离开了！
婚礼结束！
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;phaser常见的方法&quot;&gt;Phaser常见的方法&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;Phaser() //默认的构造方法，初始化注册的线程数量为0
Phaser(int parties)//一个指定线程数量的构造方法
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外Phaser还支持Tiering类型具有父子关系的构造方法，主要是为了减少在注册者数量庞大的时候，通过分组的形式复用Phaser从而减少竞争，提高吞吐，这种形式一般不常见，所以这里不再提及，有兴趣的可以参考官网文档。&lt;/p&gt;
&lt;p&gt;其他几个常见方法：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;register()//添加一个新的注册者&lt;br/&gt;bulkRegister(int parties)//添加指定数量的多个注册者&lt;br/&gt;arrive()// 到达栅栏点直接执行，无须等待其他的线程&lt;br/&gt;arriveAndAwaitAdvance()//到达栅栏点，必须等待其他所有注册者到达&lt;br/&gt;arriveAndDeregister()//到达栅栏点，注销自己无须等待其他的注册者到达&lt;br/&gt;onAdvance(int phase, int registeredParties)//多个线程达到注册点之后，会调用该方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;arriveAndAwaitAdvance()&lt;/strong&gt; 当前线程当前阶段执行完毕，等待其它线程完成当前阶段。如果当前线程是该阶段最后一个未到达的，则该方法直接返回下一个阶段的序号（阶段序号从0开始），同时其它线程的该方法也返回下一个阶段的序号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;arriveAndDeregister()&lt;/strong&gt; 该方法立即返回下一阶段的序号，并且其它线程需要等待的个数减一，并且把当前线程从之后需要等待的成员中移除。如果该Phaser是另外一个Phaser的子Phaser（层次化Phaser会在后文中讲到），并且该操作导致当前Phaser的成员数为0，则该操作也会将当前Phaser从其父Phaser中移除。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;arrive()&lt;/strong&gt;该方法不作任何等待，直接返回下一阶段的序号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;awaitAdvance(int phase)&lt;/strong&gt; 该方法等待某一阶段执行完毕。如果当前阶段不等于指定的阶段或者该Phaser已经被终止，则立即返回。该阶段数一般由&lt;em&gt;arrive()&lt;/em&gt;方法或者&lt;em&gt;arriveAndDeregister()&lt;/em&gt;方法返回。返回下一阶段的序号，或者返回参数指定的值（如果该参数为负数），或者直接返回当前阶段序号（如果当前Phaser已经被终止）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;awaitAdvanceInterruptibly(int phase)&lt;/strong&gt; 效果与&lt;em&gt;awaitAdvance(int phase)&lt;/em&gt;相当，唯一的不同在于若该线程在该方法等待时被中断，则该方法抛出&lt;strong&gt;InterruptedException&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;awaitAdvanceInterruptibly(int phase, long timeout, TimeUnit unit)&lt;/strong&gt; 效果与&lt;em&gt;awaitAdvanceInterruptibly(int phase)&lt;/em&gt;相当，区别在于如果超时则抛出&lt;strong&gt;TimeoutException&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bulkRegister(int parties)&lt;/strong&gt; 注册多个party。如果当前phaser已经被终止，则该方法无效，并返回负数。如果调用该方法时，&lt;em&gt;onAdvance&lt;/em&gt;方法正在执行，则该方法等待其执行完毕。如果该Phaser有父Phaser则指定的party数大于0，且之前该Phaser的party数为0，那么该Phaser会被注册到其父Phaser中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;forceTermination()&lt;/strong&gt; 强制让该Phaser进入终止状态。已经注册的party数不受影响。如果该Phaser有子Phaser，则其所有的子Phaser均进入终止状态。如果该Phaser已经处于终止状态，该方法调用不造成任何影响。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;readwritelock&quot;&gt;ReadWriteLock&lt;/h2&gt;
&lt;p&gt;根据翻译,读写锁,顾名思义，在读的时候上读锁，在写的时候上写锁，这样就很巧妙的解决synchronized的一个性能问题：读与读之间互斥。&lt;/p&gt;
&lt;p&gt;ReadWriteLock也是一个接口，原型如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface ReadWriteLock {
    Lock readLock();
    Lock writeLock();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该接口只有两个方法，读锁和写锁。也就是说，我们在写文件的时候，可以将读和写分开，分成2个锁来分配给线程，从而可以做到&lt;strong&gt;读和读互不影响，读和写互斥，写和写互斥&lt;/strong&gt;，提高读写文件的效率。该接口也有一个实现类ReentrantReadWriteLock，下面我们就来学习下这个类。&lt;/p&gt;
&lt;p&gt;我们先看一下，多线程同时读取文件时，用synchronized实现的效果，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ReadAndWriteLock {

    public synchronized void get(Thread thread) {
        long start = System.currentTimeMillis();
        for(int i=0; i&amp;lt;5; i++){
            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(thread.getName() + &quot;:正在进行读操作……&quot;);
        }
        System.out.println(thread.getName() + &quot;:读操作完毕！&quot;);
        long end = System.currentTimeMillis();
        System.out.println(&quot;用时:&quot;+(end-start)+&quot;ms&quot;);
    }

    public static void main(String[] args) {
        final ReadAndWriteLock lock = new ReadAndWriteLock();
        new Thread(new Runnable() {
            @Override
            public void run() {
                lock.get(Thread.currentThread());
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                lock.get(Thread.currentThread());
            }
        }).start();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Thread-1:正在进行读操作……
Thread-1:正在进行读操作……
Thread-1:正在进行读操作……
Thread-1:正在进行读操作……
Thread-1:正在进行读操作……
Thread-1:读操作完毕！
用时:112ms
Thread-0:正在进行读操作……
Thread-0:正在进行读操作……
Thread-0:正在进行读操作……
Thread-0:正在进行读操作……
Thread-0:正在进行读操作……
Thread-0:读操作完毕！
用时:107ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，即使是在读取文件，在加了synchronized关键字之后，读与读之间，也是互斥的，也就是说，必须等待Thread-0读完之后，才会轮到Thread-1线程读，而无法做到同时读文件，这种情况在大量线程同时都需要读文件的时候，读写锁的效率，明显要高于synchronized关键字的实现。下面我们来测试一下，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ReadAndWriteLock {
        ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
        public void get(Thread thread) {
                lock.readLock().lock();
                try{
                        System.out.println(&quot;start time:&quot;+System.currentTimeMillis());
                        for(int i=0; i&amp;lt;5; i++){
                                try {
                                        Thread.sleep(20);
                                } catch (InterruptedException e) {
                                        e.printStackTrace();
                                }
                                System.out.println(thread.getName() + &quot;:正在进行读操作……&quot;);
                        }
                        System.out.println(thread.getName() + &quot;:读操作完毕！&quot;);
                        System.out.println(&quot;end time:&quot;+System.currentTimeMillis());
                }finally{
                        lock.readLock().unlock();
                }
        }
        
        public static void main(String[] args) {
                final ReadAndWriteLock lock = new ReadAndWriteLock();
                new Thread(new Runnable() {
                        @Override
                        public void run() {
                                lock.get(Thread.currentThread());
                        }
                }).start();
                
                new Thread(new Runnable() {
                        @Override
                        public void run() {
                                lock.get(Thread.currentThread());
                        }
                }).start();
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。读锁和写锁是互斥的。&lt;/p&gt;
&lt;p&gt;下面我们来验证下读写锁的互斥关系，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ReadAndWriteLock {
   ReentrantReadWriteLock lock = new ReentrantReadWriteLock();
        public static void main(String[] args) {
                final ReadAndWriteLock lock = new ReadAndWriteLock();
    // 建N个线程，同时读
                ExecutorService service = Executors.newCachedThreadPool();
                service.execute(new Runnable() {
                        @Override
                        public void run() {
                                lock.readFile(Thread.currentThread());
                        }
                });
                // 建N个线程，同时写
                ExecutorService service1 = Executors.newCachedThreadPool();
                service1.execute(new Runnable() {
                        @Override
                        public void run() {
                                lock.writeFile(Thread.currentThread());
                        }
                });
        }
        // 读操作
        public void readFile(Thread thread){
                lock.readLock().lock();
                boolean readLock = lock.isWriteLocked();
                if(!readLock){
                        System.out.println(&quot;当前为读锁！&quot;);
                }
                try{
                        for(int i=0; i&amp;lt;5; i++){
                                try {
                                        Thread.sleep(20);
                                } catch (InterruptedException e) {
                                        e.printStackTrace();
                                }
                                System.out.println(thread.getName() + &quot;:正在进行读操作……&quot;);
                        }
                        System.out.println(thread.getName() + &quot;:读操作完毕！&quot;);
                }finally{
         System.out.println(&quot;释放读锁！&quot;);
                        lock.readLock().unlock();
                }
        }
        // 写操作
        public void writeFile(Thread thread){
                lock.writeLock().lock();
                boolean writeLock = lock.isWriteLocked();
                if(writeLock){
                        System.out.println(&quot;当前为写锁！&quot;);
                }
                try{
                        for(int i=0; i&amp;lt;5; i++){
                                try {
                                        Thread.sleep(20);
                                } catch (InterruptedException e) {
                                        e.printStackTrace();
                                }
                                System.out.println(thread.getName() + &quot;:正在进行写操作……&quot;);
                        }
                        System.out.println(thread.getName() + &quot;:写操作完毕！&quot;);
                }finally{
         System.out.println(&quot;释放写锁！&quot;);
                        lock.writeLock().unlock();
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;// 读锁和读锁测试结果：
当前为读锁！
当前为读锁！
pool-2-thread-1:正在进行读操作……
pool-1-thread-1:正在进行读操作……
pool-2-thread-1:正在进行读操作……
pool-1-thread-1:正在进行读操作……
pool-2-thread-1:正在进行读操作……
pool-1-thread-1:正在进行读操作……
pool-2-thread-1:正在进行读操作……
pool-1-thread-1:正在进行读操作……
pool-1-thread-1:正在进行读操作……
pool-2-thread-1:正在进行读操作……
pool-1-thread-1:读操作完毕！
pool-2-thread-1:读操作完毕！
释放读锁！
释放读锁！
// 测试结果不互斥
 
// 读锁和写锁，测试结果如下：
当前为读锁！
pool-1-thread-1:正在进行读操作……
pool-1-thread-1:正在进行读操作……
pool-1-thread-1:正在进行读操作……
pool-1-thread-1:正在进行读操作……
pool-1-thread-1:正在进行读操作……
pool-1-thread-1:读操作完毕！
释放读锁！
当前为写锁！
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:写操作完毕！
释放写锁！
// 测试结果互斥
 
// 写锁和写锁，测试结果如下：
当前为写锁！
pool-1-thread-1:正在进行写操作……
pool-1-thread-1:正在进行写操作……
pool-1-thread-1:正在进行写操作……
pool-1-thread-1:正在进行写操作……
pool-1-thread-1:正在进行写操作……
pool-1-thread-1:写操作完毕！
释放写锁！
当前为写锁！
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:正在进行写操作……
pool-2-thread-1:写操作完毕！
释放写锁！
// 测试结果互斥
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;readwritelock小结&quot;&gt;ReadWriteLock小结&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;ReadWriteLock&lt;/code&gt;可以提高读取效率：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;只允许一个线程写入；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;允许多个线程在没有写入时同时读取；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReadWriteLock&lt;/code&gt;适合读多写少的场景。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;stampedlock&quot;&gt;StampedLock&lt;/h2&gt;
&lt;p&gt;前面介绍的&lt;code&gt;ReadWriteLock&lt;/code&gt;可以解决多线程同时读，但只有一个线程能写的问题。&lt;/p&gt;
&lt;p&gt;如果我们深入分析&lt;code&gt;ReadWriteLock&lt;/code&gt;，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。&lt;/p&gt;
&lt;p&gt;要进一步提升并发执行效率，Java 8引入了新的读写锁：&lt;code&gt;StampedLock&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StampedLock&lt;/code&gt;和&lt;code&gt;ReadWriteLock&lt;/code&gt;相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。&lt;/p&gt;
&lt;p&gt;乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。&lt;/p&gt;
&lt;p&gt;我们来看例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Point {
    private final StampedLock stampedLock = new StampedLock();

    private double x;
    private double y;

    public void move(double deltaX, double deltaY) {
        long stamp = stampedLock.writeLock(); // 获取写锁
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            stampedLock.unlockWrite(stamp); // 释放写锁
        }
    }

    public double distanceFromOrigin() {
        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁
        // 注意下面两行代码不是原子操作
        // 假设x,y = (100,200)
        double currentX = x;
        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)
        double currentY = y;
        // 此处已读取到y，如果没有写入，读取是正确的(100,200)
        // 如果有写入，读取是错误的(100,400)
        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生
            stamp = stampedLock.readLock(); // 获取一个悲观读锁
            try {
                currentX = x;
                currentY = y;
            } finally {
                stampedLock.unlockRead(stamp); // 释放悲观读锁
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和&lt;code&gt;ReadWriteLock&lt;/code&gt;相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过&lt;code&gt;tryOptimisticRead()&lt;/code&gt;获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过&lt;code&gt;validate()&lt;/code&gt;去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。&lt;/p&gt;
&lt;p&gt;可见，&lt;code&gt;StampedLock&lt;/code&gt;把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：&lt;/p&gt;
&lt;p&gt;一是代码更加复杂&lt;/p&gt;
&lt;p&gt;二是&lt;code&gt;StampedLock&lt;/code&gt;是不可重入锁，不能在一个线程中反复获取同一个锁。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StampedLock&lt;/code&gt;还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。&lt;/p&gt;
&lt;h3 id=&quot;stampedlock小结&quot;&gt;StampedLock小结&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;StampedLock&lt;/code&gt;提供了乐观读锁，可取代&lt;code&gt;ReadWriteLock&lt;/code&gt;以进一步提升并发性能；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;StampedLock&lt;/code&gt;是不可重入锁。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Feb 2021 13:52:00 +0000</pubDate>
<dc:creator>等不到的口琴</dc:creator>
<og:description>本系列研究总结高并发下的几种同步锁的使用以及之间的区别,分别是:ReentrantLock、CountDownLatch、CyclicBarrier、Phaser、ReadWriteLock、Stam</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Courage129/p/14407661.html</dc:identifier>
</item>
<item>
<title>人工智能必备数学基础：概率论与数理统计（2） - 战争热诚</title>
<link>http://www.cnblogs.com/wj-1314/p/9034681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wj-1314/p/9034681.html</guid>
<description>&lt;h3&gt;如果需要小编其他数学基础博客，请移步小编的GitHub地址&lt;/h3&gt;
&lt;p&gt;　　传送门：&lt;a href=&quot;https://github.com/LeBron-Jian/DeepLearningNote&quot; target=&quot;_blank&quot;&gt;请点击我&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　如果点击有误：https://github.com/LeBron-Jian/DeepLearningNote&lt;/p&gt;
&lt;p&gt; 　　这里我打算再补充一下关于常见概率分布，似然函数，后验概率估计和一些距离公式的基础。&lt;/p&gt;
&lt;p&gt;　　（注意：目前自己补充到的所有知识点，均按照自己网课视频中老师课程知识点走的，同时一些公式是网友辛辛苦苦敲的，这里用到那个博客均在文末补充地址，不过这里首先表示感谢！！）&lt;/p&gt;

&lt;h3&gt;1，常见离散概率分布&lt;/h3&gt;
&lt;p&gt;　　介绍一个概念：&lt;strong&gt;PMF（概率质量函数）&lt;/strong&gt;：是对离散随机变量的定义，是离散随机变量在各个特定取值的概率，该函数通俗来说，就是对于一个离散型概率事件来说，使用这个函数来求它的各个成功事件结果的概率。&lt;/p&gt;
&lt;h4&gt;1.1  0-1分布&lt;/h4&gt;
&lt;p&gt;　　0-1 分布是单个二值型（n=1情况下）离散随机变量的分布。即只先进行一次事件实验，该事件发生的概率为 p，不发生的概率为 1-p，这是一个最简单的分布，任何只有两种结果的随机现象都服从0-1分布，其概率分布函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204143926937-888734979.png&quot; alt=&quot;&quot;/&gt;　　性质：&lt;strong&gt;数学期望为 E(X) = p，方差为 D(X)=p(1-p)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; 　　举个例子，比如抛硬币观察正反面，新生儿是男还是女，检测产品是否合格等，都可以用0-1分布描述。&lt;/p&gt;
&lt;h4&gt;1.2 伯努利分布&lt;/h4&gt;
&lt;p&gt;　　伯努利分布指的是对于随机变量 X 有参数为 p（0&amp;lt;p&amp;lt;1），如果它以概率 p 和 1-p 取 1和 0 的值。EX=p，DX=p(1-p)。伯努利试验成功的次数服从伯努利分布，参数p是试验成功的概率。伯努利分布是一个离散型机率分布，是 N=1时的二项分布的特殊情况，为纪念瑞士科学家詹姆斯*伯努利而命名。&lt;/p&gt;
&lt;p&gt;　　如果随机变量 X 只取0和1两个值，并且相应的概率为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113154044823-1446712411.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　则称随机变量X服从参数为 p 的伯努利分布，若令 q = 1-p，则X的概率函数可写为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113154136722-1560845365.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210123151638500-1899812247.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;1.3  二项分布（Binomial Distribution）&lt;/h4&gt;
&lt;p&gt;　　让我们看看玩板球这个例子，假设你今天赢了一场比赛，这表示一个成功的事件。你再比了一场，但是你输了。如果你今天赢了一场比赛，但这并不表示你明天肯定会赢。我们来分配一个随机变量X，用于表示赢得的次数。X可能的值是多少呢？他可以是任意值，这取决于你掷硬币的次数。只有两种可能的结果，成功和失败。因此，成功的概率为0.5，失败的概率也很容易计算出来，即 q = 1- p = 0.5。&lt;/p&gt;
&lt;p&gt;　　二项分布即重复 n 次伯努利试验，各种试验之间都相互独立，并且每次试验中只有两种可能的结果，而且这两种结果发生与否相互对立，比如成功与失败，得到与失去等。如果每次试验时，事件发生的概率为 p，不发生的概率为 1-p，则 n次重复独立试验中发生 k 次的概率为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204144323882-807413430.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　性质：每一次尝试都是独立的，因为前一次投掷的结果不能影响或决定当前投掷的结果。只有两个可能的结果并且重复n次的试验叫二项式，二项式分布的参数为n和p，其中n是试验总数，p是每次试验成功的概率，一般的二项分布是 n 次独立的伯努利试验的和，它的期望值和方差分别等于每次单独试验的期望值和方差的和：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204144339463-1207316099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这个事实很容易证明。首先假设有一个伯努利试验。实验中有两个可能的结果：1和0，前者发生的概率为p，后者发生的概率为 1-p。该试验的期望值等于 1*p + 0*(1-p) = p。该试验的方差也可以类似的计算：σ&lt;sup class=&quot;normal&quot;&gt;2&lt;/sup&gt;= (1−p)&lt;sup class=&quot;normal&quot;&gt;2&lt;/sup&gt;·p+ (0−p)&lt;sup class=&quot;normal&quot;&gt;2&lt;/sup&gt;·(1−p) =p(1 − p)&lt;/p&gt;
&lt;p&gt;　　总结一下，二项式分布的属性包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1，每个实验都是独立的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2，在实验中只有两个可能的结果：成功或失败&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3，总共进行了 n 次相同的实验&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4，所有实验成功和失败的概率是相同的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.4  泊松分布&lt;/h4&gt;
&lt;p&gt;　　Poisson分布，是一种统计与概率学里面常见到的离散概率分布，由法国数学家西摩恩*德尼*泊松在 2838年时发表，现实生活中多数服从泊松分布。&lt;/p&gt;
&lt;p&gt;　　日常生活中，大量事件是由固定频率的，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;某医院平均每小时出生 3 个婴儿&lt;/li&gt;
&lt;li&gt;某网站平均每分钟有 2次访问&lt;/li&gt;
&lt;li&gt;某超市平均每小时销售 4 包奶粉&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　他们的特点就是，我们可以预估这些事情的总数，但是没法知道具体的发生时间。已知平均每小时出生 3 个婴儿，请问下一个小时，会出生几个？有可能一下出生 6 个，也有可能一个都不出生，这是我们没法知道的。&lt;/p&gt;
&lt;p&gt;　　当以下假设有效时，则称为泊松分布：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1，任何一个成功的事件都不应该影响另一个成功的事件&lt;/li&gt;
&lt;li&gt;2，在短时间内成功的概率必须等于在更长的时间内成功的概率&lt;/li&gt;
&lt;li&gt;3，时间间隔很小时，在给间隔时间内成功的概率趋于零&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　泊松分布就是描述某段时间内，事件具体的发生概率。其概率函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204151000265-1927683344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中：P表示概率，N表示某种函数关系，t 表示时间（即时间间隔的长），n 表示数量（即该时间间隔内的事件数），λ 表示事件的频率，令 μ 表示长度为 t 的间隔中的平均事件数，那么 μ = λ*t。&lt;/p&gt;
&lt;p&gt;　　例如说一个医院内，每个出生婴儿的都是随机并独立的概率，则该医院一天（或者其他特定时间段，一小时，一周等等）要出生的婴儿总数可以看作是一个服从 poisson 分布的随机变量。但是为什么可以这样处理你？通俗定义：假设一个事件在一段时间内随机发生，且符合以下条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1，将该时间段无限分割成果若干个小的时间段，在这个接近于零的小时间段内，该事件发生一次的概率与这个极小时间段的长度成正比&lt;/li&gt;
&lt;li&gt;2，在每个极小时间段内，该事件发生两次及以上的概率恒等于零&lt;/li&gt;
&lt;li&gt;3，该事件在不同的小时间段里，发生与否相互独立&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　继续用上面的例子，1小时内出生3个婴儿的概率，就表示为 P(N(1) = 3)，那么接下来两个小时，请问会出生几个孩子？&lt;/p&gt;
&lt;p&gt;　　有可能一下生出6个孩子，也有可能一个都不出生，这是我们没法知道的。而泊松分布就是描述某段时间内，事件具体发生的概率。&lt;/p&gt;
&lt;p&gt;　　一个婴儿都不出生的概率可以求得为0.0025，说明概率非常小，基本不可能发生，计算如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204151127993-163173383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　同理，我们可以求接下来一个小时，至少出生两个婴儿的概率0.8，说明概率非常大，计算如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204151201269-353770582.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　完整计算如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210216113438626-1176426622.png&quot; alt=&quot;&quot; width=&quot;365&quot; height=&quot;235&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　泊松分布的图形大概是下面的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210216113539869-358466492.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;1.5  泊松分布与二项分布的关系&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　当二项分布的 n 很大而 p 很小时，泊松分布可作为二项分布的近似，其中 λ 为 np。通常当 n &amp;gt;=20，p &amp;lt;=0.05时，就可以用泊松公式近似的计算。&lt;/p&gt;
&lt;p&gt; 　　事实上，泊松分布正是由二项分布推导而来的。&lt;/p&gt;

&lt;h3&gt;2，常见连续概率分布&lt;/h3&gt;
&lt;p&gt;　　与PMF相对应的，在连续随机变量中叫 &lt;strong&gt;PDF（概率密度函数）&lt;/strong&gt;：是对连续性随机变量的定义，与PMF 不同的是 PDF 在特定点上的值并不是该点的概率，连续随机概率事件只能求一段区域内发生事件的概率，通过对这段区间进行积分来求，通俗来说，使用这个概率密度函数将想要求的概率的区间的临界点（最大值和最小值）带入求积分，就是该区间的概率。&lt;/p&gt;
&lt;h4&gt;2.1  均匀分布&lt;/h4&gt;
&lt;p&gt;　　在概率论和统计学中，均匀分布也叫矩形分布，它是对称概率分布，在相同长度间隔的分布概率是等可能的。均匀分布由两个参数a和b定义，他们是数轴上的最小值和最大值，通常缩写为 U(a,  b)&lt;/p&gt;
&lt;p&gt;　　对于掷骰子来说，结果是1~6，得到任何一个结果的概率是相同的，这就是均匀分布的基础。与伯努利分布不同，均匀分布的所有可能结果的 n 个数也是相等的。如果变量 X 是均匀分布的，则密度函数可以表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210114165411343-1024370713.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　均匀分布的曲线是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210114165428434-438557951.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　你可以看到，均匀分布曲线的形状是一个矩形，这也是均匀分布又称为矩形分布的原因，其中a和b是参数。&lt;/p&gt;
&lt;p&gt;　　均值和方差如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210122172103006-753809078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　举个例子，花店每天销售的花束数量是均匀分布的，最多为 40 ，最小为 10，我们来计算一下销售量在 15~30之间的概率。&lt;/p&gt;
&lt;p&gt;　　日销售量 在 15~30之间的概率为 （30-15）/（40-10）） = 0.5，同样的，日销售量大于 20 的概率为 0.667。&lt;/p&gt;
&lt;h4&gt;2.2   指数分布&lt;/h4&gt;
&lt;p&gt;　　在概率理论和统计学中，指数分布（也称为负指数分布）是描述泊松过程中的事件之间的时间的概率分布，即事件以恒定平均速率连续且独立地发生的过程。这是伽马分布的一个特殊情况。他是几何分布的连续模拟，它具有无记忆的关键性质。除了用于分析泊松过程外，还可以在其他各种环境中找到。&lt;/p&gt;
&lt;p&gt;　　指数分布是指事件的时间间隔的概率，它的一个重要特征是无记忆性。例如：如果某一元件的寿命为T，已知元件使用了 t 小时，它总共使用至少 t+s 小时的条件概率，与从开始使用时他使用至少 s 小时的概率相等。下面这些都属于指数分布：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;婴儿出生的时间间隔&lt;/li&gt;
&lt;li&gt;网站访问的时间间隔&lt;/li&gt;
&lt;li&gt;奶粉销售的时间间隔&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　指数分布的公式可以从泊松分布推断出来。如果下一个婴儿要间隔时间 t，就等同于 t 之内没有任何婴儿出生，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204150503682-1734367973.png&quot; alt=&quot;&quot;/&gt;　　则：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204150518686-1914705631.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如：接下来 15 分钟，会有婴儿出生的概率为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204150551385-1006624601.png&quot; alt=&quot;&quot;/&gt;　　指数分布的图像如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204150611092-1410362573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　指数分布的均值和方差：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210122172202901-1407153642.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.3  高斯分布（整体分布）&lt;/h4&gt;
&lt;p&gt;　　高斯分布又叫正态分布，其曲线呈钟形，两头低，中间高，左右对称因其曲线呈钟形，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201204144451835-1690545774.png&quot; alt=&quot;&quot;/&gt;　　若随机变量 X 服从一个数学期望为 μ ，方差为 σ&lt;sup&gt;2&lt;/sup&gt; 的概率分布，且其概率密度函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210122172614225-150217253.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　则这个随机变量就称为正态随机变量，正态随机变量服从的分布称为正态分布，我们将其记为：X~N(μ， σ&lt;sup&gt;2&lt;/sup&gt;)。其期望值 μ 决定了正态分布的位置，其标准差 σ （方差的开方）决定了正态分布的幅度。&lt;/p&gt;
&lt;p&gt;　　标准正态分布为当 μ = 0， σ = 1时，正态分布就成了标注正态分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210122172820544-1204852456.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　正态分布为什么常见？&lt;/p&gt;
&lt;p&gt;　　真正原因是&lt;strong&gt;中心极限定理&lt;/strong&gt;（Central limit theorem）。根据中心极限定理，如果一个事物受到多种因素的英雄，不管每个匀速本身是什么分布，他们加总后，结果的平均值就是正态分布。正态分布只适合各种因素累加的情况，如果这些因素不是彼此独立的，会互相加强英雄，那么就不是正态分布了。&lt;/p&gt;
&lt;h4&gt;2.4  卡方分布（Chi-Squared Distribution)&lt;/h4&gt;
&lt;p&gt;　　卡方分布通俗的说，就是通过小数量的样本容量去预估总体容量的分布情况。卡方检验就是统计样本的实际观测值与理论推断值之间的偏离程度。&lt;/p&gt;
&lt;p&gt;　　若 n 个相互独立的随机变量 ζ1， ζ2， ζ3.... ζn，均服从标准正态分布（也称独立同分布于标准正态分布），则这 n 个服从标准正态分布的随机变量的平方和构成一新的随机变量，其分布规律成为卡方分布（chi-square distribution)。&lt;/p&gt;
&lt;p&gt;　　自由度：假设你现在手头有3个样本。因为样本具有随机性，所以他们取值不定。但是假设处于某种原因，我们需要让样本均值固定，比如说有一个样本是固定的，那么这时真正取值自由，”有随机性“ 的样本只有两个，试想，如果每取一组的值，将影响下一组的值，那么对于后面样本来说，就被剥夺了自由度。所以就这个例子而言，三个样本最终”自由“的样本只有一个。&lt;/p&gt;
&lt;p&gt;　　卡方检验的思想是根据样本数据推断总体的频次与期望频次是否有显著性差异。&lt;/p&gt;
&lt;p&gt;　　公式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210216154731216-1454428843.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.5  beta 分布&lt;/h4&gt;
&lt;p&gt;　　贝塔分布（Beta Distribution） 是一个作为伯努利分布和二项式分布的共轭先验分布的密度函数，在及其学习和数理统计学中有重要应用。在概率论中，贝塔分布也称为 B分布，是指一组定义在（0， 1）区间的连续概率分布。&lt;/p&gt;
&lt;p&gt;　　B 分布的概率密度函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210216205532413-451862508.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;64&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　其中，Γ(z) 是 Γ 函数，随机变量  X 服从参数为 α，β 的 B 分布通常写作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210216205719708-1664177375.png&quot; alt=&quot;&quot; width=&quot;136&quot; height=&quot;37&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　B 分布的累积分布函数是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210216205753127-1442375047.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;53&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　其中 Bx(α，β )  是不完全 B 函数， Ix(α，β ) 是正则不完全贝塔函数。&lt;/p&gt;
&lt;p&gt;　　简单说，Beta分布可以看作一个概率的概率分布，当你不知道一个东西的具体概率是多少时，他可以给出来所有概率出现的可能性大小。&lt;/p&gt;
&lt;p&gt;　　举一个简单的例子，熟悉棒球运动的都知道有一个指标就是棒球击球率（ betting  average)，就是用一个运动员击中的球数除以击球的总数，我们一般认为 0.266 是正常水平的击球率，而如果击球率高达 0.3 就被认为是非常优秀的。现在有一个棒球运动员，我们希望能够预测他在这一赛季中的棒球击球率是多少。你可能就会直接计算棒球击球率，用击中的数除以击球数，但是如果这个棒球运动员只打了一次，而且还命中了，那么他的击球率就是 100%，这显然是不合理的，因为根据棒球的历史信息，我们知道这个击球率应该是 0.215~0.36之间才对。所以对于这个问题一个最好的办法就是用 beta 分布，这表示我们没有看见这个运动员打球之前，我们就有了一个大概的范围。beta分布的定义域是（0， 1），这就跟概率的范围是一样的。接下来我们将这些先验信息转换为 beta 分布的参数，我们知道一个击球率应该是平均 0.27 左右，而他的范围是 0.21~0.35 ，那么根据这个信息，我们可以取 α = 81，β = 219 （击中了 81 次，未击中 219 次）。&lt;/p&gt;
&lt;p&gt;　　之所以取这两个参数是因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;beta 分布的均值是从图中可以看到这个分布主要落在了 （0.2， 0.35）区间，这是从经验中得到的合理范围&lt;/li&gt;
&lt;li&gt;在这个例子中，我们的 x 轴就表示各个击球率的取值，x 对应的 y 值就是这个击球率所对应的概率，也就是说 beta 分布可以堪称一个概率的概率分布&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210216211212452-325241937.png&quot; alt=&quot;&quot; width=&quot;762&quot; height=&quot;386&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　0 和 β0 是一开始的参数，在这里是 81 和 219，当 α 增加了 1（击中了一次）。β 没有增加（没有漏球）。这就是我们的新的 beta 分布 Beta(81,  219)，可以看到这个分布其实没有多大的变化，这是因为只打了一次球并不能说明什么问题。但如果我们得到了更多的数据，假设一共打了 300 次，其中击中了 100次，200次没有击中，那么这一新分布就是 Beta（81+100， 219+200）。注意到这个曲线变得更尖，并且平移到了一个右边的位置，表示比平均水平要高。因此，对于一个我们不知道概率是什么，而又有一些合理的猜测时，Beta分布能够很好的作为一个表示概率的概率分布。&lt;/p&gt;

&lt;h3&gt;3， 极大似然估计与最大后验概率估计&lt;/h3&gt;
&lt;h4&gt;3.1  概率和似然的区别&lt;/h4&gt;
&lt;p&gt;　　其实将似然放在这里有些不妥，毕竟似然和概率还是有些区别的。不过我在学习似然之前，还是先学习一下其与概率的区别。&lt;/p&gt;
&lt;p&gt;　　概率用于在已知一些参数的情况下，预测接下来的观测所得到的结果，而似然性则是用于在已知某些观测所得到的结果时，对有关事物的性质的参数进行估计。这里需要对参数估计进行说明，参数估计（parameter estimation） 则是根据从总体中抽取的样本估计总体分布中包含的未知参数的方法。人们常常需要根据手中的数据，分析或推断数据反应的本质规律。即根据样本数据如何选择统计量去推断总体的分布或数字特征等。统计推断是数理统计研究的核心问题。所谓统计推断是根据样本对总体分布或分布的数字特征等做出合理的推断。他是统计推断的一种基本形式，是数理统计学的一个重要分支，分为点估计和区间估计两部分。&lt;/p&gt;
&lt;p&gt;　　顺带提一下先验概率和后验概率的区别：&lt;/p&gt;
&lt;p&gt;　　先验概率是指根据以往经验和分析得到的概率，如全概率公式中的，他往往作为”由因求果“问题中的”因“ 出现。后验概率是指在得到”结果“ 的信息后重新修正概率，是”执果寻因“ 问题中的”因“。&lt;/p&gt;
&lt;h4&gt;3.2 频率学派和贝叶斯学派&lt;/h4&gt;
&lt;p&gt;　　在说极大似然估计（Maximum  Likelihood Estimate） 与最大后验概率估计（Maximum A Posteriori estimation）之前，我们要学习一下对概率看法的两大学派频率学派和贝叶斯学派。他们看待世界的视角不同，导致他们对于产生数据的模型参数的理解也不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;频率学派&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　他们认为世界是确定的。他们直接为事件本身建模，也就是说事件在多次重复实验中趋于一个稳定的值 p，那么这个值就是该事件的概率。&lt;/p&gt;
&lt;p&gt;　　他们认为模型参数是个定值。希望通过类似解方程组的方式从数据中求得未知数。这就是频率学派使用的参数估计方法——&lt;strong&gt;极大似然估计（MLE）&lt;/strong&gt;，这种方法往往在大数据量的情况下可以很好的还原模型的真实情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;贝叶斯学派&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　他们认为世界是不确定的，因获取的信息不同而异。假设对世界先有一个预先的估计，然后通过获取的信息来不断调整之前的预估计。他们不试图对事件本身进行建模，而是从旁观者的角度来说。因此对于同一个事件，不同的人掌握的先验不同的话，那么他们所认为的事件状态也会不同。&lt;/p&gt;
&lt;p&gt;　　他们认为模型参数源自于某种潜在的分布，希望从数据中推出该分部。对于数据的观测方式不同或者假设不同，那么推知的该参数因此也存在差异。这就是贝叶斯学派视角下用来估计参数的常用方法——&lt;strong&gt;最大后验概率估计（MAP）&lt;/strong&gt;，这种方法在先验假设比较靠谱的情况下效果显著，随着数据量的增加，先验假设对于模型参数的主导作用会逐渐削弱，相反真实数据样例会大大占据有利地位。极端情况下，比如把先验假设去掉，或者假设先验满足均匀分布的话，那么她和极大似然估计就如出一辙。&lt;/p&gt;
&lt;h4&gt;3.3  似然函数的概念&lt;/h4&gt;
&lt;p&gt;　　&lt;strong&gt;统计学中，似然函数是一种关于统计模型参数的函数，表示模型参数中的似然性&lt;/strong&gt;。给定输出 x 时，关于参数 Θ 的似然函数 L(Θ|x) （在数值上）等于给定参数 Θ 后变量  X 的概率：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210112163923568-434777061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中 P(x|Θ) 是密度函数，表示给定 Θ 下的联合密度函数。而&lt;strong&gt;似然函数是关于 Θ 的函数，密度函数是关于 x 的函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　似然函数在推断统计学（Statistical  inference）中扮演重要角色，如在最大似然估计和费雪信息之中的应用等等。“似然性” 与 “或然性” 或“概率” 意思相近，都是指某件事情发生的可能性，但是在统计学中，“似然性” 与 “或然性” 或“概率” 又有明确的区分。&lt;strong&gt;概率&lt;/strong&gt;用于在已知一些参数的情况下，预测接下来的观测所得到的结果，而似然性则是用于在已知某些观测所得到的结果时，对有关事物的性质的参数进行估计。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;离散型概率分布&lt;/strong&gt;：假设一个关于参数 Θ ，具有离散型概率分布 P 的随机变量 X，则在给定 X 的输出X时，参数 Θ 的似然函数可表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113111720547-46478980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　其中， p(x) 表示 X 取 x 时的概率。上式常常写为 P(X=x|Θ) 或者 P(X=x ;Θ)，需要注意的是，此处并非条件概率，因为 Θ 不（总）是随机变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113111928800-1271373115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　如果有上式成立，则在参数 Θ1 下随机变量 X取到 x 值的可能性大于 Θ2。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;连续型概率分布&lt;/strong&gt;：假定一个关于参数 Θ，具有连续概率密度函数 f 的随机变量X，则在给定 X 的输出 x 时，参数 Θ 的似然函数可表示为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113112321533-2075125932.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上式常常写为 f(x|Θ)，同样需要注意的是，此处并非条件概率密度函数。&lt;/p&gt;
&lt;p&gt;　　连续情况下的概率密度函数是：如果X是连续随机变量给定足够小的 ε &amp;gt;0 ，那么其在（x-ε, x+ε）内的概率为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113112858298-775456398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　得到的结果与离散型是一致的，概率表达了在给定参数 Θ 时X=x 的可能性而似然表示的是给定样本 X=x 时，参数的可能性！&lt;/p&gt;
&lt;h4&gt;3.4   极大似然估计&lt;/h4&gt;
&lt;p&gt;　　极大似然估计方法（Maximum Likelihood Estimate，MLE）也称为最大概似估计或最大似然估计，它是频率学派模型参数估计的常用方法，是求估计的另一种方法。&lt;/p&gt;
&lt;p&gt;　　似然，可以简单理解为概率，可能性。极大似然估计，通俗理解就是：&lt;strong&gt;利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值&lt;/strong&gt;！换句话说：极大似然估计提供了一种给定观察数据来评估模型参数的方法，即“模型已定，参数未知”。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;极大似然估计的原理&lt;/strong&gt;：它是建立在极大似然原理的基础上的一个统计方法，极大似然原理的直观想法是，一个随机试验如有若干个可能的结果A，B，C，...，若在一次实验中，结果A出现了，那么可以认为实验条件对A的出现有利，也即出现的概率P(A) 较大。极大似然原理的直观想法我们用心下面的例子说明。设甲箱中有 99 个白球，1个黑球；乙箱中有1个白球，99个黑球。现随机取出一箱，再从抽取的箱子中随机取出一球，结果是黑球，这一黑球从乙箱抽取的概率比甲箱抽取的概率大得多，这时我们自然更多的相信这个黑球是取自乙箱的。一般来说，事件A发生的概率与某一未知参数 Θ 有关，Θ 取值不同，则事件发生的概率 P(A|Θ) 也不同，当我们在一次实验中事件A发生了，则认为此时的 Θ 值应该是 t 的一切可能取值中使 P(A|Θ) 达到最大的哪一个，极大似然估计法就是要选取这样的 t 值作为参数 t 的估计值，使所选取的样本在被选的总体中出现的可能性为最大。&lt;/p&gt;
&lt;p&gt; 　　或者看如下例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113113027909-1697607956.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　求&lt;strong&gt;极大似然函数估计值的一般步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1，写出似然函数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2，对似然函数取对数，并整理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3，求导数&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4，解似然函数&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　&lt;strong&gt;利用高等数学中求多元函数的极值的方法，有以下极大似然估计法的具体做法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;1，根据总体的分布，建立似然函数 L(x1, x2,...xn；Θ1,Θ2,...Θk)&lt;/p&gt;
&lt;p&gt;2，当  L关于 Θ1,Θ2,...Θk 可微时，（由微积分求极值的原理）可知方程组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113114525164-1687102422.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　定出 Θhat&lt;sub&gt;i&lt;/sub&gt;(i=1,2,...k)，称以上方程组为似然函数。&lt;/p&gt;
&lt;p&gt;　　因为 L与 InL 具有相同的极大值点，所以 Θhat&lt;sub&gt;i&lt;/sub&gt;(i=1,2,...k) 也可由方程组&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113114713234-1109646541.png&quot; alt=&quot;&quot;/&gt;　　定出 Θhat&lt;sub&gt;i&lt;/sub&gt;(i=1,2,...k) ，称以上方程组为对数似然方程；Θhat&lt;sub&gt;i&lt;/sub&gt;(i=1,2,...k) 就是所求参数Θ&lt;sub&gt;i&lt;/sub&gt;(i=1,2,...k) 的极大似然估计值。&lt;/p&gt;
&lt;p&gt;　　当总体是离散型的，将上面的概率密度函数 f(x, Θ1,Θ2,...Θk) 换成它的分布律：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113114903057-847219456.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113114934101-787757527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;例1&lt;/strong&gt;：设X服从参数 λ（ λ &amp;gt; 0） 的泊松分布， x1, x2,...xn 是来自 X 的一个样本值，求 λ 的极大似然估计值。&lt;/p&gt;
&lt;p&gt;　　因为 X的分布律为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113113720846-2071835751.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以 λ 的似然函数为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113113751768-401977743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对似然函数取对数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113113828005-882950661.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再取 λ 的偏导数等于 0的解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113113845512-1687245108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　解得 λ 的极大似然估计值为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202101/1226410-20210113113922037-209504804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;例2&lt;/strong&gt;：假设一个盒子里面有红黑共10个球，每次有放回的取出，取了10次，结果为7次黑球，3次红球。问拿出黑球的概率 p 是多少？&lt;/p&gt;
&lt;p&gt;　　我们假设7次黑球，三次红球为事件 A，一个理所当然的想法就是既然事件 A 已经发生了，那么事件 A 发生的概率应该最大。所以既然事件 A 的结果已定，我们就有理由相信这不是一个偶然发生的事件，这个已发生的事件肯定一定程度上反映了黑球在整体中的比例。所以我们要让模型产生这个整体事件的概率最大，我们把这十次抽取看成一个整体事件 A，很明显事件 A发生的概率是每次子事件概率之积。我们把 P(A) 看成一个关于 p 的函数，求 P(A) 取最大值时的 p，这就是极大似然估计的思想。具体公式化描述为 P(A) = p&lt;sup&gt;7&lt;/sup&gt;*(1-p)&lt;sup&gt;3&lt;/sup&gt;，接下来就是取对数转换为累加，然后通过求导令式子为 0 来求极值，求出 p 的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206095601772-8882748.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.5  最大后验概率估计&lt;/h4&gt;
&lt;p&gt;　　最大后验概率估计（Maximum a posteriori probability estimate，简称 MAP）是贝叶斯模型参数估计的常用方法，与最大似然估计类似，但是在似然函数后面多乘了一项，即“待估计参数的先验分布”。故最大后验估计可以看做规则化的最大似然估计。&lt;/p&gt;
&lt;p&gt;　　顾名思义就是最大化在给定数据样本的情况下模型参数的后验概率。它依然是根据已知样本，来通过调整模型参数使得模型能够产生该数据样本的概率最大，只不过对于模型参数有了一个先验假设，即模型参数可能满足某种分布，不再一味地依赖数据样例（万一数据量少或者数据不靠谱呢）。&lt;/p&gt;
&lt;p&gt;　　根据贝叶斯理论，对于 θ 的后验分布：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206150051372-2008141084.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　后验分布的目标为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206150140695-813730164.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　分母为 f(x) ，是固定值。&lt;/p&gt;
&lt;p&gt;　　MAP 认为， θ 是一个随机变量，其先验概率密度函数是已知的，为 P(θ)，所以其目标为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206150335383-979770521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　MLE 认为，θ 是非随机变量或者分布未知的随机变量，这两种情况都可以认为 P(θ) 均匀分布的，即该概率是一个固定值，P(θ)=C，所以其目标为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206150457678-446370785.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　注意：最大后验估计可以看做是贝叶斯估计的一种特定形式。&lt;/p&gt;
&lt;p&gt;　　在这里举个掷硬币的例子：掷一枚硬币10次，有10次正面朝上，0次反面朝上。问证明朝上的概率 θ。&lt;/p&gt;
&lt;p&gt;　　在频率学派看来，利用极大似然估计可以得到 θ = 10/10 = 1.0 。显然当缺乏数据时 级大师让邮寄会产生严重的偏差。&lt;/p&gt;
&lt;p&gt;　　如果我们利用最大后验概率估计来看这件事，先验认为大概率下这个硬币是均匀的（例如最大值取在0.5 处的 beta分布），那么P(θ|X)  是一个分布，最大值会介于 0.5~1 之间，而不是武断的给出 θ =1。&lt;/p&gt;
&lt;p&gt;　　显然，随着数据量的增加，参数分布会更倾向于向数据靠拢，先验假设的影响会越来越小。&lt;/p&gt;
&lt;h4&gt;3.6  经验风险最小化与结构风险最小化&lt;/h4&gt;
&lt;p&gt;　　经验风险最小化与结构风险最小化是对于损失函数而言的。可以说经验风险最小化只侧重训练数据集上的损失降到最低；而结构风险最小化是在经验风险最小化的基础上约束模型的复杂度，使其在训练数据集的损失降到最低的同时，模型不至于过于复杂，相当于在损失函数上增加了正则项，防止模型出现过拟合状态。这一点也符合了&lt;strong&gt;奥卡姆剃刀原理：如无必要，勿增实体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　经验风险最小化可以看做是采用了极大似然估计的参数评估方法，更侧重从数据中学习模型的潜在参数，而且是只看重数据样本本身。这种在数据样本缺失的情况下，很容易管中窥豹，模型发生过拟合的状态；结构风险最小化采用了最大后验概率估计的思想来推测模型参数，不仅仅是依赖数据，还依靠模型参数的先验假设。这样在数据样本不是很充分的情况下，我们可以通过模型参数的先验假设，辅助以数据样本，做到尽可能的还原真实模型分布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经验风险最小化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　MLE（极大似然估计）是经验风险最小化的例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。这里举个逻辑（LR）回归的例子。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于二分类的逻辑回归来说，我们试图把所有数据正确分类，要么0，要么1&lt;/li&gt;
&lt;li&gt;通过累乘每个数据样例来模拟模型产生数据的过程，并最大化 ΠP(1)ΠP(0)&lt;/li&gt;
&lt;li&gt;我们需要通过取对数来实现概率之积转为概率之和 Σ lnP(1) + Σ lnP(0)&lt;/li&gt;
&lt;li&gt;我们可以根据数据标签的0， 1 特性来将上式改为 1/m*Σ(y * lnP(1) + (1-y) * lnP(0) )&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　这样我们通过极大似然估计来推导出了逻辑回归的损失函数，同时极大似然是经验风险最小化的一个特例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构风险最小化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　MAP（最大后验概率估计）是结构风险最小化的例子。当模型是条件概率分布，损失函数是对数损失函数，模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。在这里举个推荐系统中的矩阵概率分解（PMF）的例子。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先说一下矩阵分解的原理：推荐系统的评分预测场景可以看做是一个矩阵补全的游戏，矩阵补全是推荐系统的任务，矩阵分解是其达到目的的手段。因此，矩阵分解是为了更好地完成矩阵补全任务（欲其补全，先其分解之）。之所以可以利用矩阵分解来完成矩阵补全的操作，那是因为基于这样的假设——假设 UI矩阵是低秩的，即在大千世界中，总会存在相似的人或物，即物以类聚人以群分，然后我们可以利用两个小矩阵相乘来还原评分大矩阵。&lt;/li&gt;
&lt;li&gt;它假设评分矩阵中的元素 Rij 是由用户潜在偏好向量 Ui 和物品潜在属性向量 Vj 的内积决定的，并且服从均值为 Ui&lt;sup&gt;T&lt;/sup&gt;Vj ，方差为 σ&lt;sup&gt;2&lt;/sup&gt; 的正态分布：R&lt;sub&gt;ij&lt;/sub&gt;~n(Ui&lt;sup&gt;T&lt;/sup&gt;Vj, σ&lt;sup&gt;2&lt;/sup&gt;)&lt;/li&gt;
&lt;li&gt;则观测到的评分矩阵条件概率为：&lt;/li&gt;
&lt;li&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206142934355-764383452.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;同时，假设用户偏好向量与物品偏好向量服从均值都为0，方差分别为 σ&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;U&lt;/sub&gt;I, σ&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;V&lt;/sub&gt;I 的正态分布：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206143148836-55497392.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;根据最大后验概率估计，可以得出隐变量 U，V 的后验概率为：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206143231588-1769135781.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接着，等式两边取对数 In，并且将正态分布展开后得到：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206143307743-667846259.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样，我们通过最大后验概率估计推导出了概率矩阵分解的损失函数。可以看出结构风险最小化是在经验风险最小化的基础上增加了模型参数的先验。&lt;/p&gt;
&lt;h4&gt;3.7  MLE 和 MAP 的联系&lt;/h4&gt;
&lt;p&gt;　　在介绍经验风险与结构风险最小化的时候以具体的逻辑回归（LR）与概率矩阵分解（PMF）模型来介绍 MLE 和 MAP，接下来从宏观的角度，不局限于具体的某个模型来推导 MLE 和 MAP。&lt;/p&gt;
&lt;p&gt;　　假设数据 x1, x2, ....xn 是满足独立同分布（i.i.d）的一组抽样 X=(x1, x2, ...xn)，接下来就利用两种参数估计方法来求解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MLE 对参数 θ 的估计方法如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206144449314-1601338215.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MAP 对参数 θ 的估计方法如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202102/1226410-20210206144820526-1508063734.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　所以 MAP 和 MLE 在优化时的不同就是在于增加一个先验项  -log P(Θ)。&lt;/p&gt;
&lt;p&gt;　　通过上面的分析可以大致给出他们的联系：MAP(Θ) ≈  MLEP(Θ)  -log P(Θ)&lt;/p&gt;

&lt;h3&gt;4，几种常用的距离&lt;/h3&gt;
&lt;p&gt;　　在机器学习里，我们的运算一般都是基于向量的，一条用户具有100个特征，那么它对应的就是一个 100 维的向量，通过计算两个用户对应向量之间的距离值大小，有时候能反映出这两个用户的相似程度（这个在KNN算法和K-Means算法中很明显）。&lt;/p&gt;
&lt;p&gt;　　这里设有两个 n 维变量 A={x11, x12, ... x1n} 和  B={x21, x22, ... x2n}，则一些常用的距离公式定义如下：&lt;/p&gt;
&lt;h4&gt;4.1  曼哈顿距离&lt;/h4&gt;
&lt;p&gt;　　曼哈顿距离也称为城市街区距离，数学定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201203161335964-888159343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　曼哈顿距离的 Python实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from numpy import *

vector1 = mat([1,2,3])
vector2 = mat([4,5,6])

Manhattan_distance = sum(abs(vector1 - vector2))
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.2  欧式距离&lt;/h4&gt;
&lt;p&gt;　　欧式距离其实就是L2范数，数学定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201203162343324-1969947985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　欧式距离的Python实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from numpy import *

vector1 = mat([1,2,3])
vector2 = mat([4,5,6])

Euclidean_distance = sqrt((vector1 - vector2)*(vector1 - vector2).T)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.3  闵可夫斯基距离&lt;/h4&gt;
&lt;p&gt;　　从严格意义上讲，闵可夫斯基距离不是一组距离，而是一组距离的定义：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201203162626366-767615705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　实际上，当 p=1 时，就是曼哈顿距离；当 p=2 时，就是欧式距离。&lt;/p&gt;
&lt;h4&gt;4.4  切比雪夫距离&lt;/h4&gt;
&lt;p&gt;　　切比雪夫距离就是 Lw，即无穷范围，数学表达式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201203162729541-554514460.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　切比雪夫距离Python实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from numpy import *

vector1 = mat([1,2,3])
vector2 = mat([4,5,6])

Chebyshev_distance = sqrt(abs(vector1 - vector2).max)
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.5  夹角余弦&lt;/h4&gt;
&lt;p&gt;　　夹角余弦的取值范围为 [-1, 1]，可以用来衡量两个向量方向的差异；夹角余弦越大，表示两个向量的夹角越小；当两个向量的方向重合时，夹角余弦取最大值1，当两个向量的方向完全相反时，夹角余弦取最小值 -1。&lt;/p&gt;
&lt;p&gt;　　机器学习中用这一概念来衡量样本向量之间的差异，其数学表达式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201203163057671-1439935112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　夹角余弦的Python实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from numpy import *
vector1 = mat([1,2,3])
vector2 = mat([4,5,6])
IncludedAngleCosine = dot(vector1,vector2)/(linalg.norm(vector1)*linalg.norm(vector2))
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.6  汉明距离&lt;/h4&gt;
&lt;p&gt;　　汉明距离定义的是两个字符串中不相同维数的数目。例如：字符串“1111”与“1001”之间的汉明距离为2。&lt;/p&gt;
&lt;p&gt;　　信息编码中一般应使得编码间的汉明距离尽可能的小。&lt;/p&gt;
&lt;p&gt;　　汉明距离的Python实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from numpy import *

matV = mat([1,1,1,1], [1,0,0,1])

Hanming_distance = nonzero(matV[0] - matV[1])
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4.7  杰拉德相似系数&lt;/h4&gt;
&lt;p&gt;　　两个集合 A 和 B 的交集元素在 A 和 B 的并集中所占的比例称为两个集合的杰拉德相似系数，用符号 J(A, B) 表示，数学表达式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201203163757031-1451550234.png&quot; alt=&quot;&quot;/&gt;　　杰拉德相似系数是衡量两个集合的相似度的一种指标。一般可将其用在衡量样本的相似度上。&lt;/p&gt;
&lt;h4&gt;4.8  杰拉德距离&lt;/h4&gt;
&lt;p&gt;　　与杰拉德相似系数相反的概念是杰拉德距离，其定义式为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1226410/202012/1226410-20201203163914227-1115418303.png&quot; alt=&quot;&quot;/&gt;　　杰拉德距离的Python实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
from numpy import *
import scipy.spatial.distance as dist

matV = mat([1,1,1,1],[1,0,0,1])
jaccard_distance =  dist.pdist(matV,'jaccard')
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;参考地址： 距离 https://zhuanlan.zhihu.com/p/25197792&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/40024110&lt;/p&gt;
</description>
<pubDate>Tue, 16 Feb 2021 13:44:00 +0000</pubDate>
<dc:creator>战争热诚</dc:creator>
<og:description>如果需要小编其他数学基础博客，请移步小编的GitHub地址 传送门：请点击我 如果点击有误：https://github.com/LeBron-Jian/DeepLearningNote 这里我打算再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wj-1314/p/9034681.html</dc:identifier>
</item>
<item>
<title>C#通过NI-VISA操作Tektronix TBS 2000B系列示波器 - seabluescn</title>
<link>http://www.cnblogs.com/seabluescn/p/14404546.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seabluescn/p/14404546.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文描述采用C#语言访问控制Tektronix TBS 2000B 系列示波器。接口协议采用NI-VISA。&lt;/p&gt;
&lt;p&gt;最近一个项目需要和一款示波器进行通信，需要对示波器进行一些简单控制并获取到波形数据。经过一段时间研究，大致了解了相关操作，因为发现相关资料不是很多，所以把我了解的相关知识和大家分享一下。文末将提供本文涉及的相关文档、代码、安装程序的下载地址。&lt;/p&gt;
&lt;p&gt;正常情况下，我们如果需要和一个设备进行通信，首先需要知道PC通过什么方式和设备进行连接，通信协议是什么。由于工作需要和很多设备进行过连接，常用的连接方式主要有：网络连接、串口连接、USB接口连接等；通信协议都是自定义的协议文本。 本来以为这个项目首先得需要搞清楚示波器的通信协议，然后才能进行下一步开发，在官方网站下载了一些编程资料，发现该设备是可以通过VISA进行连接的，那什么是VISA呢？VISA是由National Instruments公司牵头，联合一些设备制造厂商共同指定的一个通用设备连接标准，不管设备通过何种方式进行连接，只要符合VISA规范就可以通过该标准协议进行连接，而NI-VISA就是NI公司实现的一个协议，通过这个协议接口，我们不用直接和设备进行通信，只需要通过NI-VISA提供的接口就可以访问设备，而常用的接口非常简单，主要就是OPEN、WRITE、READ等几个命令。符合规范的设备都会公开一份SCPI指令集的文档，只要仔细阅读该文档就可以实现设备的控制。在整个项目过程中，我仅仅通过几个官方网站下载的文档就完成项目开发，几乎没有什么障碍，在此不得不感慨我们的制造业和发达国家相比确实有很大差距，我们就缺少这样标准性的东西，什么事情都得从底层做起，很不科学。要是那些巨头们肯做一些这方面的工作就太好了，比做什么买菜、卖鱼的APP有意义得多了。&lt;/p&gt;


&lt;p&gt;示波器通过网络接口和PC进行连接&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/18393/202102/18393-20210215205832745-1236885538.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 配置示波器IP和PC在同一个网段，例如：192.168.11.11，在设置时注意IP内不要有0，然后在PC上先ping一下，看能否ping通。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/18393/202102/18393-20210215205916462-831575525.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 如果能ping通就在浏览器输入http://192.168.11.11看能否打开示波器主页，确认SCPI指令可以运行。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/18393/202102/18393-20210215205926929-652838554.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;运行NI-VISA Runtime安装程序，选中运行时基础包和.NET支持包。 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/18393/202102/18393-20210215211939935-1459996749.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  .NET支持包选.NET 4.0-4.5.1 Runtime Support(IVI)，不选.NET XX Runtime Support(NS)，NS的包是老版本。&lt;/p&gt;
&lt;p&gt;安装完成后形成两个包：Ivi.Visa和NationalInstruments.Visa&lt;/p&gt;
&lt;p&gt;其中Ivi.Visa有两个版本：&lt;/p&gt;
&lt;p&gt;32位位置：C:\Program Files (x86)\IVI Foundation\VISA\Microsoft.NET\Framework32\v2.0.50727\VISA.NET Shared Components 5.8.0&lt;/p&gt;
&lt;p&gt;64位位置：C:\Program Files\IVI Foundation\VISA\Microsoft.NET\Framework64\v2.0.50727\VISA.NET Shared Components 5.8.0&lt;/p&gt;
&lt;p&gt;NationalInstruments.Visa位置：C:\Windows\Microsoft.NET\assembly\GAC_MSIL\NationalInstruments.Visa\v4.0_17.0.0.0__2eaa5af0834e221d&lt;/p&gt;


&lt;p&gt;新建VS工程，按上述地址添加Ivi.Visa和NationalInstruments.Visa两个引用。Ivi.Visa的库根据需要可以选32位或64位。&lt;/p&gt;
&lt;p&gt;程序运行需要在目标机器安装运行时，所以引用的库不需要复制到项目文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/18393/202102/18393-20210215212001108-1902002050.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 已经有网友把VISA接口调用进行了封装，我直接使用了相关代码，几乎一字未改，相关代码请查阅：https://www.cnblogs.com/cncc/p/7866899.html&lt;/p&gt;
&lt;p&gt;连接代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_c910e46c-1ad5-48d8-9f8b-6c060ea0c1fe&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_c910e46c-1ad5-48d8-9f8b-6c060ea0c1fe&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c910e46c-1ad5-48d8-9f8b-6c060ea0c1fe&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;string&lt;/span&gt; IP = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.txtIP.Text.Trim();

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; IpRegex = &lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;^((25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Regex.IsMatch(IP, IpRegex))
            {
                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP地址不正确！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!PortUltility.OpenIPAddress(IP, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; fullAddress))
            {
                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;未找到设备!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                _portOperatorBase &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LANPortOperator(fullAddress);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                MessageBox.Show($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;初始化设备失败:{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                _portOperatorBase.Timeout &lt;/span&gt;= &lt;span&gt;2000&lt;/span&gt;&lt;span&gt;;
                _portOperatorBase.Open();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                MessageBox.Show($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接设备失败:{ex.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            EnabledControls(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;写指令一共有两种，一种不需要返回数据、一种需要返回数据，下发了需要返回数据的指令后才能进行读取指令，否则就会读取失败。&lt;/p&gt;
&lt;p&gt;读写指令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_04ce2262-c54f-4474-9e40-27778ccbcfe2&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_04ce2262-c54f-4474-9e40-27778ccbcfe2&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_04ce2262-c54f-4474-9e40-27778ccbcfe2&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnWrite_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; CmdStr = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.txtCommand.Text.Trim();

           
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                _portOperatorBase.WriteLine(CmdStr);
                ShowLog($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Write][{CmdStr}][Success]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
            {
                ShowLog($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Write][{CmdStr}][ERROR]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; btnReadString_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; _portOperatorBase.Read();
                ShowLog($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Read][{result}][{result.Length}]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOTimeoutException)
            {
                ShowLog($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Read][ERROR:Timeout]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                ShowLog($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[Read][Exception:{ex.Message}]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;核心代码就这么多，剩下的就根据需要查询SCPI指令表就可以了。&lt;/p&gt;


&lt;p&gt; 以下指令仅适用于Tektronix TBS 2000B系列示波器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_937dc108-4c14-4e17-9213-138430cfb09d&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_937dc108-4c14-4e17-9213-138430cfb09d&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_937dc108-4c14-4e17-9213-138430cfb09d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;(一)       基本指令
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.     身份
WRITE：&lt;/span&gt;*IDN?&lt;span&gt;

READ：

(二)       设置
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.     默认设置
RECAll:SETUp FACtory

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.    通道控制
Select:CH&lt;/span&gt;&amp;lt;x&amp;gt; ON/&lt;span&gt;OFF

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.    水平位置与比例
HORizontal:POSition&lt;/span&gt;?&lt;span&gt;

HORizontal:POSition &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;

 

HORizontal:SCAle&lt;/span&gt;?

&lt;span&gt;400&lt;/span&gt;&lt;span&gt;   单位是秒

HORizontal:SCAle &lt;/span&gt;&lt;span&gt;0.2&lt;/span&gt;

 

&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.    垂直位置与比例
CH1:POSition？

CH1:POSition &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;

 

CH1:SCAle&lt;/span&gt;?&lt;span&gt;

CH1:SCAle &lt;/span&gt;&lt;span&gt;2.5&lt;/span&gt;

 

&lt;span&gt;5&lt;/span&gt;&lt;span&gt;.    触发
模式

TRIGger:A:MODe&lt;/span&gt;?&lt;span&gt;

NORMAL

 

触发类型

TRIGger:A:TYPe&lt;/span&gt;?&lt;span&gt;

EDGE

 

触发源

TRIGger:A:EDGE:SOUrce CH1

 

耦合：

TRIGger:A:EDGE:COUPling g {DC&lt;/span&gt;|HFRej|LFRej|&lt;span&gt;NOISErej}

 

斜率

TRIGger:A:EDGE:SLOpe {RISe&lt;/span&gt;|&lt;span&gt;FALL}

 

触发电平（当前）

TRIGger:A:LEVel&lt;/span&gt;?

&lt;span&gt;2.0800&lt;/span&gt;&lt;span&gt;

TRIGger:A:LEVel &lt;/span&gt;&lt;span&gt;3.5&lt;/span&gt;&lt;span&gt;

 

触发电平（指定通道）

TRIGger:A:LEVel:CH1&lt;/span&gt;?

&lt;span&gt;2.0800&lt;/span&gt;&lt;span&gt;

TRIGger:A:LEVel :CH1 &lt;/span&gt;&lt;span&gt;3.5&lt;/span&gt;&lt;span&gt;

 

(三)       控制
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.     设置/&lt;span&gt;查询工作类型
ACQuire:STOPAfter SEQuence

ACQuire:STOPAfter RUNSTOP

查询：ACQuire:STOPAfter&lt;/span&gt;?&lt;span&gt;

返回最后一次设置的工作类型

 

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;.    设置/&lt;span&gt;查询运行状态
ACQuire:STATE？

&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;：Run或Single

&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：Stop

设置：ACQuire:STATE ON&lt;/span&gt;/&lt;span&gt;OFF

 

&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.    查询触发状态
TRIGger:STATE&lt;/span&gt;?&lt;span&gt;

READY：等待触发

SAVE：已经触发

 

(四)       读取数据
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.     设置数据来源（通道）
DATA:SOURCE CH1

 

&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;.    设置/&lt;span&gt;读取记录宽度
HORizontal:RECOrdlength&lt;/span&gt;?

&lt;span&gt;2000&lt;/span&gt;

 

&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.    读取波形数据宽度（仅读取，触发完成后有效）
WFMOutpre:RECOrdlength&lt;/span&gt;?

&lt;span&gt;2000&lt;/span&gt;

&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.    设置传输数据窗口
DATa:STARt &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;    最小为1

DATa:STOP &lt;/span&gt;&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;

DATa:WIDth&lt;/span&gt;?&lt;span&gt; 单个数据宽度（字节数）默认为1，可以修改为2字节，但高位始终为0

 

&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;.    数据读取
CURVe&lt;/span&gt;?&lt;span&gt;

Read（Bytes）：返回指定长度的字节数据【LENGTH&lt;/span&gt;= N+(STOP-STARt+&lt;span&gt;1&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;】

数据为：帧头（N字节）&lt;/span&gt;+数据（STOP-STARt+1字节）+&lt;span&gt;帧尾（1字节）。

帧头为:#（1字节）&lt;/span&gt;+数据长度的长度（1字节）+数据长度（&lt;span&gt;1&lt;/span&gt;~&lt;span&gt;9字节）

帧尾为：\n

数据每个字节表示一个波形高度值，采用补码方式，即第一个位表示符号，范围从&lt;/span&gt;-&lt;span&gt;128&lt;/span&gt;~&lt;span&gt;127&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;相关文档、代码下载：https://gitee.com/seabluescn/tksamples.git&lt;/p&gt;
</description>
<pubDate>Tue, 16 Feb 2021 12:57:00 +0000</pubDate>
<dc:creator>seabluescn</dc:creator>
<og:description>一、概述 本文描述采用C#语言访问控制Tektronix TBS 2000B 系列示波器。接口协议采用NI-VISA。 最近一个项目需要和一款示波器进行通信，需要对示波器进行一些简单控制并获取到波形数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/seabluescn/p/14404546.html</dc:identifier>
</item>
<item>
<title>R语言学习2：绘图 - 江景景景页</title>
<link>http://www.cnblogs.com/jy333/p/14407381.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jy333/p/14407381.html</guid>
<description>&lt;p&gt;本系列是一个新的系列，在此系列中，我将和大家共同学习R语言。由于我对R语言的了解也甚少，所以本系列更多以一个学习者的视角来完成。&lt;/p&gt;
&lt;p&gt;参考教材：《R语言实战》第二版（Robert I.Kabacoff），书中所提到的&lt;a href=&quot;https://www.johndcook.com/blog/r_language_for_programmers/&quot; target=&quot;_blank&quot;&gt;John Cook的优秀博文&lt;/a&gt;，关于代码规范的《&lt;a href=&quot;https://nanx.me/rstyle/&quot; target=&quot;_blank&quot;&gt;来自Google的R语言编码风格指南&lt;/a&gt;》。&lt;/p&gt;

&lt;h2 id=&quot;part-1：图形参数&quot;&gt;Part 1：图形参数&lt;/h2&gt;
&lt;h3 id=&quot;unit-1：点型和线型&quot;&gt;Unit 1：点型和线型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;plot()&lt;/code&gt;是R中为对象作图的一个泛型函数，它的输出由所绘制对象的类型不同而不同。如果&lt;code&gt;x&lt;/code&gt;和&lt;code&gt;y&lt;/code&gt;是两个等长的数字向量，则以下代码将绘制点集&lt;span class=&quot;math inline&quot;&gt;\((x,y)\)&lt;/span&gt;，并用线段将其连接。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;plot(x, y, type=&quot;b&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;type=&quot;b&quot;&lt;/code&gt;代表同时绘制点和线。还有以下的几种&lt;code&gt;type&lt;/code&gt;属性的选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&quot;p&quot;&lt;/code&gt;：只绘制点，不绘制线段。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;l&quot;&lt;/code&gt;：只绘制线段，不绘制点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;b&quot;&lt;/code&gt;：绘制点和线，但实线不通过点。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;o&quot;&lt;/code&gt;：绘制点和线，且实线会通过点，与&lt;code&gt;&quot;b&quot;&lt;/code&gt;的视觉效果不同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;h&quot;&lt;/code&gt;：只绘制各点到&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;轴的竖线，不绘制点和线。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;s&quot;&lt;/code&gt;：绘制阶梯型曲线。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;S&quot;&lt;/code&gt;：绘制阶梯型区间，但是阶梯方向不同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;n&quot;&lt;/code&gt;：不绘制任何点、线。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在使用&lt;code&gt;plot()&lt;/code&gt;作图&lt;strong&gt;之前&lt;/strong&gt;，可以使用&lt;code&gt;par()&lt;/code&gt;函数修改图形的参数，这个函数可以任意次调用。在使用&lt;code&gt;par()&lt;/code&gt;修改图形参数之前，往往会加入以下两句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;opar &amp;lt;- par(no.readonly=TRUE)
...
par(opar)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当调用&lt;code&gt;par(opar)&lt;/code&gt;后，将还原&lt;strong&gt;默认参数环境&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以下是用于指定符号和线条类型的参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pch&lt;/code&gt;：指定绘制点时使用的符号，范围是&lt;span class=&quot;math inline&quot;&gt;\(\{0,1,\cdots,25\}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cex&lt;/code&gt;：指定符号的大小，表示绘图符号相对于默认大小的缩放倍数，默认值是1。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lty&lt;/code&gt;：指定线条类型，范围是&lt;span class=&quot;math inline&quot;&gt;\(\{1,2,\cdots,6\}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lwd&lt;/code&gt;：指定线条宽度，表示之于默认值的相对粗细，默认值是1。&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://i.loli.net/2021/02/09/YuRhTnSItWHGb7C.png&quot; alt=&quot;image-20210209232858753&quot;/&gt;&lt;p&gt;也可以直接在&lt;code&gt;plot&lt;/code&gt;处加上这四个参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;plot(x, y, type=&quot;b&quot;, pch=11, lty=2, cex=2, lwd=2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;unit-2：颜色&quot;&gt;Unit 2：颜色&lt;/h3&gt;
&lt;p&gt;以下是用于指定颜色的参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;col&lt;/code&gt;：默认的绘图颜色，可以传入一个向量并循环使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;col.axis&lt;/code&gt;：坐标轴刻度文字的颜色。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;col.lab&lt;/code&gt;：坐标轴标签文字的颜色。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;col.main&lt;/code&gt;：标题颜色。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;col.sub&lt;/code&gt;：副标题颜色。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fg&lt;/code&gt;：图形前景色，如坐标轴线。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bg&lt;/code&gt;：图形背景色。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;颜色的指定，可以用颜色下标、颜色名字、十六进制颜色值、RGB值、HSV值来指定，函数&lt;code&gt;colors()&lt;/code&gt;可以返回所有可用颜色的名称（657种）。&lt;/p&gt;
&lt;p&gt;可以用&lt;code&gt;rainbow(n)&lt;/code&gt;创建一个&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;种连续的彩虹形颜色列表，可以用&lt;code&gt;gray(vector)&lt;/code&gt;来获得一个灰度色列表，常用的&lt;code&gt;vector=0:n/n&lt;/code&gt;，是一个&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;之间的均匀列表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RColorBrewer&lt;/code&gt;是一个用于创建颜色的常用包，其中&lt;code&gt;brewer.pal(n, name)&lt;/code&gt;可以从调色盘&lt;code&gt;name&lt;/code&gt;中创建一个颜色值的向量，以下程序段是一个&lt;code&gt;brewer.par()&lt;/code&gt;函数的使用示例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;library(RColorBrewer)
n &amp;lt;- 9
mycolor &amp;lt;- brewer.pal(n, &quot;Set1&quot;)  # 使用的颜色集合是&quot;Set1&quot;
barplot(rep(1,n), col = mycolor)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用&lt;code&gt;display.brewer.all()&lt;/code&gt;显示所有调色板的颜色，或者&lt;code&gt;display.brewer.pal(name)&lt;/code&gt;显示某个调色板的颜色。&lt;code&gt;brewer.pal.info&lt;/code&gt;命令可以给出所有调色板的列表。&lt;/p&gt;
&lt;h3 id=&quot;unit-3：文本&quot;&gt;Unit 3：文本&lt;/h3&gt;
&lt;p&gt;字体族和字样通过以下参数进行控制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cex&lt;/code&gt;：相对默认大小的缩放倍数，默认值是1（代表以下一类，&lt;strong&gt;不要直接调用&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cex.axis&lt;/code&gt;：坐标轴刻度文字的缩放倍数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cex.lab&lt;/code&gt;：坐标轴标签的缩放倍数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cex.main&lt;/code&gt;：标题的缩放倍数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cex.sub&lt;/code&gt;：副标题的缩放倍数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font&lt;/code&gt;：整数，指定字体样式。&lt;span class=&quot;math inline&quot;&gt;\(\{1,2,3,4,5\}\)&lt;/span&gt;分别代表常规、粗体、斜体、粗斜体、符号字体（代表以下一类，不要直接调用）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font.axis&lt;/code&gt;：坐标轴刻度文字的字体样式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font.lab&lt;/code&gt;：坐标轴标签的字体样式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font.main&lt;/code&gt;：标题的字体样式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font.sub&lt;/code&gt;：副标题的字体样式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ps&lt;/code&gt;：字体磅值，文本的最终大小为&lt;code&gt;ps*cex&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;family&lt;/code&gt;：绘制文本时使用的字体族，标准取值为&lt;code&gt;serif&lt;/code&gt;（衬线）、&lt;code&gt;sans&lt;/code&gt;（无衬线）、&lt;code&gt;mono&lt;/code&gt;（等宽）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;字体族的设置稍显复杂，&lt;strong&gt;在Windows系统中&lt;/strong&gt;，&lt;code&gt;mono&lt;/code&gt;映射为TT Courier New，&lt;code&gt;sarif&lt;/code&gt;映射为TT Times New Roman，&lt;code&gt;sans&lt;/code&gt;映射为TT Arial，这里TT指True Type。如果想要使用其他字体，需要创建新的映射，使用&lt;code&gt;windowsFonts()&lt;/code&gt;和&lt;code&gt;windowsFont()&lt;/code&gt;来创建。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;x &amp;lt;- c(20, 30, 40, 45, 60)
y &amp;lt;- c(16, 20, 27, 40, 60)

windowsFonts(
    A=windowsFont(&quot;Arial Black&quot;),
    B=windowsFont(&quot;Bookman Old Style&quot;),
    C=windowsFont(&quot;Comic Sans MS&quot;)
)

par(pch=17, lty=6, cex=2, lwd=3)  # 注意cex参数也会对文本产生影响
par(col='red')
par(font.main=4, family=&quot;C&quot;, ps=6)

plot(x, y, type=&quot;b&quot;, main=&quot;A Simple Try&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://i.loli.net/2021/02/10/tKqDgAGnLjb2i9l.png&quot; alt=&quot;Rplot01&quot;/&gt;&lt;h3 id=&quot;unit-4：图形尺寸与边界尺寸&quot;&gt;Unit 4：图形尺寸与边界尺寸&lt;/h3&gt;
&lt;p&gt;控制图形尺寸和边界大小的参数为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;pin&lt;/code&gt;：以英寸表示的图形尺寸，是一个二元列表（宽和高）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mai&lt;/code&gt;：以数值向量表示的边界大小，单位为英寸（下、左、上、右）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mar&lt;/code&gt;：以数值向量表示的边界大小，单位为英分（下、左、上、右）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;part-2：添加要素&quot;&gt;Part 2：添加要素&lt;/h2&gt;
&lt;h3 id=&quot;unit-1：添加标题和坐标轴标签&quot;&gt;Unit 1：添加标题和坐标轴标签&lt;/h3&gt;
&lt;p&gt;添加标题和坐标轴标签：使用&lt;code&gt;title()&lt;/code&gt;函数，其调用格式为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;title(main=&quot;main title&quot;,
      sub=&quot;subtitle&quot;,
      xlab=&quot;x-axis label&quot;,
      ylab=&quot;y-axis label&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在&lt;code&gt;title()&lt;/code&gt;函数中添加其他图形参数，如&lt;code&gt;col.main&lt;/code&gt;、&lt;code&gt;col.lab&lt;/code&gt;、&lt;code&gt;cex.lab&lt;/code&gt;等。&lt;/p&gt;
&lt;h3 id=&quot;unit-2：添加个性化坐标轴&quot;&gt;Unit 2：添加个性化坐标轴&lt;/h3&gt;
&lt;p&gt;如果要添加个性化的坐标轴，通常要在&lt;code&gt;plot()&lt;/code&gt;函数中设置一些图形参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ann&lt;/code&gt;：取&lt;code&gt;FALSE&lt;/code&gt;时，将不会画出标题，包括主标题和副标题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bty&lt;/code&gt;：设置边框样式，默认为&lt;code&gt;&quot;o&quot;&lt;/code&gt;表示全部画出，还有&lt;code&gt;&quot;l&quot;&lt;/code&gt;（左下）、&lt;code&gt;&quot;7&quot;&lt;/code&gt;（右上）、&lt;code&gt;&quot;c&quot;&lt;/code&gt;（上下左）、&lt;code&gt;&quot;u&quot;&lt;/code&gt;（左下右）、&lt;code&gt;&quot;]&quot;&lt;/code&gt;（上下右）、&lt;code&gt;&quot;n&quot;&lt;/code&gt;（无）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xaxs&lt;/code&gt;和&lt;code&gt;yaxs&lt;/code&gt;：设置&lt;span class=&quot;math inline&quot;&gt;\(x, y\)&lt;/span&gt;轴的范围，默认为&lt;code&gt;&quot;r&quot;&lt;/code&gt;表示比范围略大，&lt;code&gt;&quot;i&quot;&lt;/code&gt;表示和给定作图范围完全相同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xaxt&lt;/code&gt;和&lt;code&gt;yaxt&lt;/code&gt;：可以取&lt;code&gt;&quot;n&quot;&lt;/code&gt;，此时坐标轴、刻度线和刻度值将不会画出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;axes&lt;/code&gt;：如果取&lt;code&gt;FALSE&lt;/code&gt;，则所有坐标轴和框线都不会被画出。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;添加自定义的坐标轴：使用&lt;code&gt;axis()&lt;/code&gt;函数，其调用格式为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;axis(side, at=, labels=, pos=, lty=, col=, las=, tck=, ...)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各个参数的释义为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;side&lt;/code&gt;：&lt;span class=&quot;math inline&quot;&gt;\(\{1,2,3,4\}\)&lt;/span&gt;，表示在图形的哪一边绘制坐标轴（下、左、上、右）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;at&lt;/code&gt;：数值型向量，表示需要绘制刻度线的位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;labels&lt;/code&gt;：字符型向量，刻度线旁的文字标签，如果缺省则直接使用&lt;code&gt;at&lt;/code&gt;中的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pos&lt;/code&gt;：坐标轴线绘制位置的坐标。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lty&lt;/code&gt;：线条类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;col&lt;/code&gt;：线条和刻度线颜色。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;las&lt;/code&gt;：标签平行于坐标轴&lt;code&gt;=0&lt;/code&gt;，垂直于坐标轴&lt;code&gt;=2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tck&lt;/code&gt;：刻度线的长度，以相对于绘图区域大小的分数表示，默认为-0.01，负值表示在图形外侧。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;x &amp;lt;- c(20, 30, 40, 45, 60)
y &amp;lt;- c(16, 20, 27, 40, 60)

windowsFonts(
  A=windowsFont(&quot;Arial Black&quot;),
  B=windowsFont(&quot;Bookman Old Style&quot;),
  C=windowsFont(&quot;Comic Sans MS&quot;)
)

par(pch=17, lty=6, cex=1, lwd=3)
par(col='red')
par(font.main=2, family=&quot;C&quot;, ps=12)

plot(x, y, type=&quot;b&quot;, main=&quot;A Simple Try&quot;, yaxt=&quot;n&quot;)

z &amp;lt;- c(20, 21, 22, 23, 24, 26, 28, 30, 35, 42, 50, 60)
axis(4, at=z, labels=z, col.axis='blue', pos=50, las=2, lty=2, tck=-0.02, )
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://i.loli.net/2021/02/10/Zk6T5HKcbR2jMGW.png&quot; alt=&quot;Rplot&quot;/&gt;&lt;h3 id=&quot;unit-3：添加图例和参考线&quot;&gt;Unit 3：添加图例和参考线&lt;/h3&gt;
&lt;p&gt;要添加参考线，应当使用&lt;code&gt;abline()&lt;/code&gt;函数，其使用格式为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;abline(h=yvalues, v=xvalues)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里&lt;code&gt;h&lt;/code&gt;代表添加水平参考线的高度位置，&lt;code&gt;v&lt;/code&gt;代表添加垂直参考线的水平位置。可以在其中添加其他图形参数。&lt;/p&gt;
&lt;p&gt;要添加图例，应当使用&lt;code&gt;legend()&lt;/code&gt;函数，其使用格式为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;legend(location, title, legend, ...)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;location&lt;/code&gt;：指定图例的位置，可以给定图例左上角的&lt;span class=&quot;math inline&quot;&gt;\(x,y\)&lt;/span&gt;坐标，也可以使用&lt;code&gt;locator(1)&lt;/code&gt;用鼠标点击，还可以使用&lt;code&gt;bottom, bottomleft, left, topleft, top, topright, right, bottomright, center&lt;/code&gt;等关键字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title&lt;/code&gt;：图例标题的字符串。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;legend&lt;/code&gt;：图例标签组成的字符型向量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下给出书上的案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;rm(list=ls())
dose &amp;lt;- c(20, 30, 40, 45, 60)
drugA &amp;lt;- c(16, 20, 27, 40, 60)
drugB &amp;lt;- c(15, 18, 25, 31, 40)

opar &amp;lt;- par(no.readonly = T)

par(lwd=2, cex=1.5, font.lab=2)

plot(dose, drugA, type=&quot;b&quot;,
     pch=15, lty=1, col=&quot;red&quot;, ylim=c(0,60),
     main=&quot;Drug A vs. Drug B&quot;,
     xlab=&quot;Drug Dosage&quot;, ylab=&quot;Drug Response&quot;)

lines(dose, drugB, type=&quot;b&quot;,
      pch=17, lty=2, col=&quot;blue&quot;)

abline(h=30, lwd=1.5, lty=2, col=&quot;gray&quot;)

library(Hmisc)
minor.tick(nx=3, ny=3, tick.ratio=0.5)  # 添加次要刻度线

legend(&quot;topleft&quot;, inset=0.05, title=&quot;Drug Type&quot;, c(&quot;A&quot;, &quot;B&quot;),
       lty=c(1, 2), pch=c(15, 17), col=c(&quot;red&quot;, &quot;blue&quot;))

par(opar)
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://i.loli.net/2021/02/10/e7bs8oWEBRJYfIa.png&quot; alt=&quot;Rplot02&quot;/&gt;&lt;h3 id=&quot;unit-4：添加辅助文本&quot;&gt;Unit 4：添加辅助文本&lt;/h3&gt;
&lt;p&gt;文本添加可以通过函数函数&lt;code&gt;text()&lt;/code&gt;，向图形内部（通常是各个点）添加文本，使用格式为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;text(location, &quot;text to place&quot;, pos, ...)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;location&lt;/code&gt;：文本的位置参数，可以是一对&lt;span class=&quot;math inline&quot;&gt;\((x, y)\)&lt;/span&gt;坐标，也可以通过&lt;code&gt;location=locator(1)&lt;/code&gt;用鼠标来确定摆放位置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pos&lt;/code&gt;：文本相对于位置参数的方位，&lt;span class=&quot;math inline&quot;&gt;\(\{1,2,3,4\}\)&lt;/span&gt;代表下、左、上、右。还可以追加指定参数&lt;code&gt;offset&lt;/code&gt;作为偏移量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还可以通过&lt;code&gt;mtext()&lt;/code&gt;向图形的四个边界之一添加文本，使用格式为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;mtext(&quot;text to place&quot;, side, line=n, ...)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;side&lt;/code&gt;：指定摆放文本的边，&lt;span class=&quot;math inline&quot;&gt;\(\{1,2,3,4\}\)&lt;/span&gt;代表下、左、上、右。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;line&lt;/code&gt;：内移或外移文本，值越大，文本外移的程度越大。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;adj&lt;/code&gt;：文本可以向左下对齐&lt;code&gt;=0&lt;/code&gt;，或向右上对齐&lt;code&gt;=1&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;part-3：图形组合&quot;&gt;Part 3：图形组合&lt;/h2&gt;
&lt;p&gt;规则排布：可以使用&lt;code&gt;par()&lt;/code&gt;函数中的图形参数&lt;code&gt;mfrow=c(nrows, ncols)&lt;/code&gt;来创建按行填充的、行数为&lt;code&gt;nrows&lt;/code&gt;、列数为&lt;code&gt;ncols&lt;/code&gt;的图形矩阵。以下案例书上的实例代码，数据集为R语言内置的&lt;code&gt;mtcars&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;rm(list=ls())

opar &amp;lt;- par(no.readonly = T)

par(mfrow=c(2, 2))  # 将绘图区域分成四块
attach(mtcars)
plot(wt, mpg, main=&quot;Scatterplot of wt vs. mpg&quot;)  # 第一个图
plot(wt, disp, main=&quot;Scatterplot of wt vs. disp&quot;)  # 第二个图
hist(wt, main=&quot;Histogram of wt&quot;)  # 第三个图
boxplot(wt, main=&quot;Boxplot of wt&quot;)  # 第四个图
detach(mtcars)
par(opar)
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://i.loli.net/2021/02/16/N3ozwLRYXitkhAv.png&quot; alt=&quot;Rplot02&quot;/&gt;&lt;p&gt;复杂排布：可以使用&lt;code&gt;layout(matrix)&lt;/code&gt;函数来组合图形，这里&lt;code&gt;matrix&lt;/code&gt;给定了图形的所在位置，如&lt;/p&gt;
&lt;p&gt;\[\begin{pmatrix} 1 &amp;amp; 1 \\ 2 &amp;amp; 3 \end{pmatrix} \]&lt;/p&gt;
&lt;p&gt;就代表第一幅图位于第一行的1、2列，第二幅图位于第二行第一列，第三幅图位于第二行第二列。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;rm(list=ls())
opar &amp;lt;- par(no.readonly = T)
attach(mtcars)

mat &amp;lt;- matrix(c(1, 1, 2, 3), nrow=2, ncol=2, byrow=T)
layout(mat)  # 按照mat矩阵给出划分
hist(wt, main = &quot;Graph_1&quot;)
hist(mpg, main = &quot;Graph_2&quot;)
hist(disp, main = &quot;Graph_3&quot;)

detach(mtcars)
par(opar)
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://i.loli.net/2021/02/16/bjW5dncLJ3iMFlu.png&quot; alt=&quot;Rplot&quot;/&gt;&lt;p&gt;为了精细控制每幅图形的相对大小，可以在&lt;code&gt;layout()&lt;/code&gt;函数中使用&lt;code&gt;widths&lt;/code&gt;和&lt;code&gt;heights&lt;/code&gt;两个参数，它们分别是各列宽度值构成的向量与各行宽度值构成的向量。现在，在上述代码中加入这两个参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-R&quot;&gt;rm(list=ls())
opar &amp;lt;- par(no.readonly = T)
attach(mtcars)

mat &amp;lt;- matrix(c(1, 1, 2, 3), nrow=2, ncol=2, byrow=T)
layout(mat, widths = c(3, 1), heights = c(1, 1.5))  # 按照mat矩阵给出划分
hist(wt, main = &quot;Graph_1&quot;)
hist(mpg, main = &quot;Graph_2&quot;)
hist(disp, main = &quot;Graph_3&quot;)

detach(mtcars)
par(opar)
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://i.loli.net/2021/02/16/J56XHvxmKWULICj.png&quot; alt=&quot;Rplot01&quot;/&gt;&lt;p&gt;精细控制：可以使用&lt;code&gt;par()&lt;/code&gt;函数的参数&lt;code&gt;fig&lt;/code&gt;来精细控制，它接受四个&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;之间的数，分别代表图形在窗口内所占有矩形的四个端点。一般还要加入&lt;code&gt;new=TRUE&lt;/code&gt;，使得新加入的图形与原图形位于同样的画布中。&lt;/p&gt;
&lt;p&gt;注意，如果遇到&lt;code&gt;Error in plot.new(): figure margins too large&lt;/code&gt;，则应当&lt;strong&gt;修改参数&lt;/strong&gt;，这是因为由于设备的原因，子图所需的大小与设置的参数冲突了。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Feb 2021 12:09:00 +0000</pubDate>
<dc:creator>江景景景页</dc:creator>
<og:description>绘图，包括图形元素的更改、添加与图形的组合。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jy333/p/14407381.html</dc:identifier>
</item>
<item>
<title>翻译：《实用的Python编程》01_04_Strings - codists</title>
<link>http://www.cnblogs.com/codists/p/14407162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codists/p/14407162.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/codists/practical-python-zh/blob/main/Notes/Contents.md&quot; target=&quot;_blank&quot;&gt;目录&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/codists/p/14405609.html&quot; target=&quot;_blank&quot;&gt;上一节 (1.3 数字)&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/codists/p/05_Lists.md&quot; target=&quot;_blank&quot;&gt;下一节 (1.5 列表)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本节介绍处理文本的方法。&lt;/p&gt;
&lt;h3 id=&quot;表示字面量文本&quot;&gt;表示字面量文本&lt;/h3&gt;
&lt;p&gt;在程序中字符串字面量使用引号来书写。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 单引号（Single quote）
a = 'Yeah but no but yeah but...'

# 双引号（Double quote）
b = &quot;computer says no&quot;

# 三引号（Triple quotes）
c = '''
Look into my eyes, look into my eyes, the eyes, the eyes, the eyes,
not around the eyes,
don't look around the eyes,
look into my eyes, you're under.
'''
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常，字符串只能占一行。三引号捕获在引号结束之前的所有文本，包含所有的格式。&lt;/p&gt;
&lt;p&gt;使用单引号（'）和双引号（“）没有区别。但是，以什么样的引号开始字符串，必须以什么样的引号结束字符串。&lt;/p&gt;
&lt;h3 id=&quot;字符串转义码&quot;&gt;字符串转义码&lt;/h3&gt;
&lt;p&gt;转义码被用于表示控制字符和不能轻易在键盘上输入的字符。以下是一些常见的转义码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;'\n'      换行符（Line feed）
'\r'      回车符（Carriage return）
'\t'      制表符（Tab）
'\''      字面量单引号（Literal single quote）
'\&quot;'      字面量双引号（Literal double quote）
'\\'      字面量反斜杠（Literal backslash）
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串表示&quot;&gt;字符串表示&lt;/h3&gt;
&lt;p&gt;字符串中的每个字符在内部被存储为所谓的 Unicode “代码点（code-point）”，代码点是一个整数。可以使用下列转移序列指定确切的代码点 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = '\xf1'          # a = 'ñ'
b = '\u2200'        # b = '∀'
c = '\U0001D122'    # c = '𝄢'
d = '\N{FOR ALL}'   # d = '∀'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所有可用的字符码请参考 &lt;a href=&quot;https://unicode.org/charts&quot; target=&quot;_blank&quot;&gt;Unicode 字符数据库&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;字符串索引&quot;&gt;字符串索引&lt;/h3&gt;
&lt;p&gt;可以像访问数组那样访问字符串的单个字符。你可以使用从 0 开始的整数索引，负索引指定相对于字符串尾部的位置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = 'Hello world'
b = a[0]          # 'H'
c = a[4]          # 'o'
d = a[-1]         # 'd' (end of string)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以指定一个索引范围来切割或者选择子串：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;d = a[:5]     # 'Hello'
e = a[6:]     # 'world'
f = a[3:8]    # 'lo wo'
g = a[-5:]    # 'world'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不包括结尾索引处的字符。缺失的索引假定为字符串的开始或者结尾。&lt;/p&gt;
&lt;h3 id=&quot;字符串操作&quot;&gt;字符串操作&lt;/h3&gt;
&lt;p&gt;字符串的操作包括：拼接，长度计算，成员判断和复制。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# Concatenation (+)
a = 'Hello' + 'World'   # 'HelloWorld'
b = 'Say ' + a          # 'Say HelloWorld'

# Length (len)
s = 'Hello'
len(s)                  # 5

# Membership test (`in`, `not in`)
t = 'e' in s            # True
f = 'x' in s            # False
g = 'hi' not in s       # True

# Replication (s * n)
rep = s * 5             # 'HelloHelloHelloHelloHello'
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串的方法&quot;&gt;字符串的方法&lt;/h3&gt;
&lt;p&gt;字符串具有对数据执行各种操作的方法。&lt;/p&gt;
&lt;p&gt;示例：删除开头或者结尾处的任何空白。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;s = '  Hello '
t = s.strip()     # 'Hello'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：大小写转换。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;s = 'Hello'
l = s.lower()     # 'hello'
u = s.upper()     # 'HELLO'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：文本替换。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;s = 'Hello world'
t = s.replace('Hello' , 'Hallo')   # 'Hallo world'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;更多字符串方法:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符串具有各种各样的方法用于测试和处理文本数据。&lt;/p&gt;
&lt;p&gt;下面是字符串方法的一小部分示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;s.endswith(suffix)     # Check if string ends with suffix
s.find(t)              # First occurrence of t in s
s.index(t)             # First occurrence of t in s
s.isalpha()            # Check if characters are alphabetic
s.isdigit()            # Check if characters are numeric
s.islower()            # Check if characters are lower-case
s.isupper()            # Check if characters are upper-case
s.join(slist)          # Join a list of strings using s as delimiter
s.lower()              # Convert to lower case
s.replace(old,new)     # Replace text
s.rfind(t)             # Search for t from end of string
s.rindex(t)            # Search for t from end of string
s.split([delim])       # Split string into list of substrings
s.startswith(prefix)   # Check if string starts with prefix
s.strip()              # Strip leading/trailing space
s.upper()              # Convert to upper case
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字符串的可变性&quot;&gt;字符串的可变性&lt;/h3&gt;
&lt;p&gt;字符串是“不可变的”或者说是只读的。一旦创建，字符串的值就无法修改。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = 'Hello World'
&amp;gt;&amp;gt;&amp;gt; s[1] = 'a'
Traceback (most recent call last):
File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'str' object does not support item assignment
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;所有处理字符串数据的操作和方法始终会创建一个新的字符串。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;字符串转换&quot;&gt;字符串转换&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;str()&lt;/code&gt; 函数可以将任何值转换为字符串。 &lt;code&gt;str()&lt;/code&gt; 函数得到的结果是一个字符串，该字符串包含的文本与 &lt;code&gt;print()&lt;/code&gt; 语句产生的文本相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; x = 42
&amp;gt;&amp;gt;&amp;gt; str(x)
'42'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;字节字符串&quot;&gt;字节字符串&lt;/h3&gt;
&lt;p&gt;通常，在底层 I/O 中会遇到 8 位字节的字符串（译注：字节字符串），它是这样写的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;data = b'Hello World\r\n'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过把小写的 b 放到第一个引号之前来指定一个字节字符串而不是文本字符串（&lt;strong&gt;译注：在字符串前面加 b 表示这是使用 ASCII 编码的字节字符串&lt;/strong&gt;）。大部分常用的文本字符串操作可应用于字节字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;len(data)                         # 13
data[0:5]                         # b'Hello'
data.replace(b'Hello', b'Cruel')  # b'Cruel World\r\n'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字节字符串索引有点不同，因为它返回的是整数形式的字节值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;data[0]   # 72 (ASCII code for 'H')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字节字符串与文本字符串之间的转换：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;text = data.decode('utf-8') # bytes -&amp;gt; text
data = text.encode('utf-8') # text -&amp;gt; bytes
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;'utf-8'&lt;/code&gt; 这个参数指定了字符的编码方式。其它常见的编码方式有 &lt;code&gt;'ascii'&lt;/code&gt; 和 &lt;code&gt;'latin1'&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;原始字符串&quot;&gt;原始字符串&lt;/h3&gt;
&lt;p&gt;原始字符串是未解释的带有反斜杠的字符串字面量。通过在原始引号之前添加 “r” 前缀来指定。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; rs = r'c:\newdata\test' # Raw (uninterpreted backslash)
&amp;gt;&amp;gt;&amp;gt; rs
'c:\\newdata\\test'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出的字符串是包含在引号里面的字面量文本，与输入的文本完全相同。这在反斜杠有特殊意义的情况下很有用。例如：文件名、正则表达式等。&lt;/p&gt;
&lt;h3 id=&quot;f-strings&quot;&gt;f-Strings&lt;/h3&gt;
&lt;p&gt;具有格式化表达式替换的字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name = 'IBM'
&amp;gt;&amp;gt;&amp;gt; shares = 100
&amp;gt;&amp;gt;&amp;gt; price = 91.1
&amp;gt;&amp;gt;&amp;gt; a = f'{name:&amp;gt;10s} {shares:10d} {price:10.2f}'
&amp;gt;&amp;gt;&amp;gt; a
'       IBM        100      91.10'
&amp;gt;&amp;gt;&amp;gt; b = f'Cost = ${shares*price:0.2f}'
&amp;gt;&amp;gt;&amp;gt; b
'Cost = $9110.00'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意: 这要求 Python 3.6 或者更新的版本.&lt;/strong&gt; 格式化代码的含义稍后介绍。&lt;/p&gt;
&lt;h2 id=&quot;练习&quot;&gt;练习&lt;/h2&gt;
&lt;p&gt;在这些习题中，你将尝试对 Python 字符串类型进行操作。你应该在 Python 交互提示符下操作，在该提示符下可以轻松地查看到结果。重要提示：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在应该与解释器进行交互的习题中，&lt;br/&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 当 Python 希望你输入一个新的语句， 你将获得一个解释器提示符。习题中某些语句会跨越多行——要使这些语句执行，你可能需要多按几次回车键。提醒你，在做这些示例时，请勿输入 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 提示符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过定义一个包含一系列股票代号的字符串开始吧。字符串如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; symbols = 'AAPL,IBM,MSFT,YHOO,SCO'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;练习-113：提取单个字符和子串&quot;&gt;练习 1.13：提取单个字符和子串&lt;/h3&gt;
&lt;p&gt;字符串是字符数组。尝试提取一些字符：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; symbols[0]
?
&amp;gt;&amp;gt;&amp;gt; symbols[1]
?
&amp;gt;&amp;gt;&amp;gt; symbols[2]
?
&amp;gt;&amp;gt;&amp;gt; symbols[-1]        # Last character
?
&amp;gt;&amp;gt;&amp;gt; symbols[-2]        # Negative indices are from end of string
?
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Python 语言中，字符串是只读的。&lt;/p&gt;
&lt;p&gt;尝试通过将 &lt;code&gt;symbols&lt;/code&gt; 字符串的第一个字符变为小写字母 ‘a’ 来验证这一点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; symbols[0] = 'a'
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'str' object does not support item assignment
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;练习-114：字符串拼接&quot;&gt;练习 1.14：字符串拼接&lt;/h3&gt;
&lt;p&gt;尽管字符串数据是只读的，但是你始终可以将变量重新分配给新创建的字符串。&lt;/p&gt;
&lt;p&gt;尝试下面的语句，该语句将一个新的股票代码 “GOOG” 拼接到 &lt;code&gt;symbols&lt;/code&gt; 字符串的末尾。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; symbols = symbols + 'GOOG'
&amp;gt;&amp;gt;&amp;gt; symbols
'AAPL,IBM,MSFT,YHOO,SCOGOOG'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;糟糕！这不是我们想要的。修改它使得变量 &lt;code&gt;symbols&lt;/code&gt; 保存的值为 &lt;code&gt;'AAPL,IBM,MSFT,YHOO,SCO,GOOG'&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; symbols = ?
&amp;gt;&amp;gt;&amp;gt; symbols
'AAPL,IBM,MSFT,YHOO,SCO,GOOG'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把 &lt;code&gt;'HPQ'&lt;/code&gt; 添加到 &lt;code&gt;symbols&lt;/code&gt; 字符串的前面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; symbols = ?
&amp;gt;&amp;gt;&amp;gt; symbols
'HPQ,AAPL,IBM,MSFT,YHOO,SCO,GOOG'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这些示例中，表面上看起来原始字符串像正在被修改，明显违反了字符串是只读的。实际上不是这样的。每次，这些操作都会创建一个全新的字符串。当变量名 &lt;code&gt;symbols&lt;/code&gt; 被重新分配，它会指向一个新创建的字符串。然后，旧的字符串被销毁，因为它不再被使用了。&lt;/p&gt;
&lt;h3 id=&quot;练习-115：成员测试（子串测试）&quot;&gt;练习 1.15：成员测试（子串测试）&lt;/h3&gt;
&lt;p&gt;尝试使用 &lt;code&gt;in&lt;/code&gt; 操作符检查子串。请在交互提示符下尝试这些操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 'IBM' in symbols
?
&amp;gt;&amp;gt;&amp;gt; 'AA' in symbols
True
&amp;gt;&amp;gt;&amp;gt; 'CAT' in symbols
?
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么检查 &lt;code&gt;AA&lt;/code&gt; 的时候返回 &lt;code&gt;True&lt;/code&gt; ?&lt;/p&gt;
&lt;h3 id=&quot;练习-116：字符串方法&quot;&gt;练习 1.16：字符串方法&lt;/h3&gt;
&lt;p&gt;在 Python 交互提示符下，尝试一些新的字符串方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; symbols.lower()
?
&amp;gt;&amp;gt;&amp;gt; symbols
?
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请记住，字符串始终是只读的。如果你想要保存操作的结果，你需要把它放置到一个变量中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; lowersyms = symbols.lower()
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请尝试更多的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; symbols.find('MSFT')
?
&amp;gt;&amp;gt;&amp;gt; symbols[13:17]
?
&amp;gt;&amp;gt;&amp;gt; symbols = symbols.replace('SCO','DOA')
&amp;gt;&amp;gt;&amp;gt; symbols
?
&amp;gt;&amp;gt;&amp;gt; name = '   IBM   \n'
&amp;gt;&amp;gt;&amp;gt; name = name.strip()    # Remove surrounding whitespace
&amp;gt;&amp;gt;&amp;gt; name
?
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;练习-117：f-strings&quot;&gt;练习 1.17：f-strings&lt;/h3&gt;
&lt;p&gt;有时你想创建一个字符串并把其它变量的值嵌入到其中。&lt;/p&gt;
&lt;p&gt;要做到这点，可以使用 f-strings。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; name = 'IBM'
&amp;gt;&amp;gt;&amp;gt; shares = 100
&amp;gt;&amp;gt;&amp;gt; price = 91.1
&amp;gt;&amp;gt;&amp;gt; f'{shares} shares of {name} at ${price:0.2f}'
'100 shares of IBM at $91.10'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 &lt;a href=&quot;https://www.cnblogs.com/codists/p/03_Numbers.md&quot; target=&quot;_blank&quot;&gt;练习 1.10&lt;/a&gt; 中修改 mortgage.py 程序来使用 f-strings 创建它的输出。&lt;/p&gt;
&lt;p&gt;尝试实现它，使得输出能够很好地对齐。&lt;/p&gt;
&lt;h3 id=&quot;练习-118：正则表达式&quot;&gt;练习 1.18：正则表达式&lt;/h3&gt;
&lt;p&gt;基本字符串操作的一个局限性在于它们不支持任何类型的高级模式匹配。为此，你需要使用 Python 的 &lt;code&gt;re&lt;/code&gt; 模块和正则表达式。正则表达式处理是一个大的主题，这里只是一个简短的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; text = 'Today is 3/27/2018. Tomorrow is 3/28/2018.'
&amp;gt;&amp;gt;&amp;gt; # Find all occurrences of a date
&amp;gt;&amp;gt;&amp;gt; import re
&amp;gt;&amp;gt;&amp;gt; re.findall(r'\d+/\d+/\d+', text)
['3/27/2018', '3/28/2018']
&amp;gt;&amp;gt;&amp;gt; # Replace all occurrences of a date with replacement text
&amp;gt;&amp;gt;&amp;gt; re.sub(r'(\d+)/(\d+)/(\d+)', r'\3-\1-\2', text)
'Today is 2018-3-27. Tomorrow is 2018-3-28.'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有关 &lt;code&gt;re&lt;/code&gt; 模块的更多信息，请查看官方文档：&lt;a href=&quot;https://docs.python.org/3/library/re.html&quot; target=&quot;_blank&quot;&gt;https://docs.python.org/library/re.html&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;说明&quot;&gt;说明&lt;/h3&gt;
&lt;p&gt;当你开始尝试使用解释器时，你总是希望了解更多有关不同对象所支持的操作。例如，如何找出哪些操作是对字符串是有效的？&lt;/p&gt;
&lt;p&gt;根据你的 Python 环境，你可能可以通过 tab 键补全来查看可用方法的列表。例如，尝试输入下面的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = 'hello world'
&amp;gt;&amp;gt;&amp;gt; s.&amp;lt;tab key&amp;gt;
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果单击 tab 键没有任何作用，你可以使用 Python 的内建函数 &lt;code&gt;dir()&lt;/code&gt;。示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; s = 'hello'
&amp;gt;&amp;gt;&amp;gt; dir(s)
['__add__', '__class__', '__contains__', ..., 'find', 'format',
'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace',
'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'partition',
'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit',
'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase',
'title', 'translate', 'upper', 'zfill']
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;dir()&lt;/code&gt; 函数生成一个在 &lt;code&gt;(.)&lt;/code&gt; 后出现的所有操作的列表。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;help()&lt;/code&gt; 函数可以获取有关特定操作的更多信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; help(s.upper)
Help on built-in function upper:

upper(...)
    S.upper() -&amp;gt; string

    Return a copy of the string S converted to uppercase.
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/codists/practical-python-zh/blob/main/Notes/Contents.md&quot; target=&quot;_blank&quot;&gt;目录&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/codists/p/14405609.html&quot; target=&quot;_blank&quot;&gt;上一节 (1.3 数字)&lt;/a&gt; | &lt;a href=&quot;https://www.cnblogs.com/codists/p/05_Lists.md&quot; target=&quot;_blank&quot;&gt;下一节 (1.5 列表)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：完整翻译见&lt;/span&gt; &lt;a href=&quot;https://github.com/codists/practical-python-zh&quot; target=&quot;_blank&quot;&gt;https://github.com/codists/practical-python-zh&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Feb 2021 10:40:00 +0000</pubDate>
<dc:creator>codists</dc:creator>
<og:description>目录 | 上一节 (1.3 数字) | 下一节 (1.5 列表) 1.4 字符串 本节介绍处理文本的方法。 表示字面量文本 在程序中字符串字面量使用引号来书写。 # 单引号（Single quote）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codists/p/14407162.html</dc:identifier>
</item>
<item>
<title>恕我直言！！！对于Maven，菜鸟玩dependency，神仙玩plugin - 大数据君</title>
<link>http://www.cnblogs.com/mr-bigdata/p/14407045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mr-bigdata/p/14407045.html</guid>
<description>&lt;p&gt;打包是一项神圣、而庄严的工作。package意味着我们离生产已经非常近了。它会把我们之前的大量工作浓缩成为一个、或者多个文件。接下来，运维的同学就可以拿着这些个打包文件在生产上纵横四海了。&lt;/p&gt;
&lt;p&gt;这么一项庄严、神圣的工作，却没有受到多数人的关注，大家习惯去网上随意copy一段pom的xml代码，往自己项目里面一扔，然后就开始执行package打包了。大多数只知道，Maven帮助我管理了JAR包的依赖，可以自动下载，很方便。确实，因为它太方便了，很多时候，我们几乎是没有感知它的存在。想起来某个功能的时候，直接去使用就可以了。&lt;/p&gt;
&lt;p&gt;而构建的工作其实并不简单！例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打包后的程序，与生产环境JAR包冲突&lt;/li&gt;
&lt;li&gt;依赖中有多个版本的依赖，如何选择、排除依赖&lt;/li&gt;
&lt;li&gt;编译scala，某些JAR包的调用存在兼容问题&lt;/li&gt;
&lt;li&gt;如何根据不同的环境来加载不同的配置，例如：本地环境、集群环境。&lt;/li&gt;
&lt;li&gt;编译开源项目报错，根本无从下手解决。&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，稍微离生产环境近一些，我们会发现很多的问题都暴露了出来。碰到这些问题的时候，当然可以第一时间百度。但为了能够更精准的定位问题、减少打包时候给别人挖坑，我们还是很有必要来了解一些关于Maven的细节。&lt;/p&gt;


&lt;h2 id=&quot;菜鸟玩dependency，神仙玩plugin&quot;&gt;菜鸟玩dependency，神仙玩plugin&lt;/h2&gt;
&lt;p&gt;我们使用Maven的时候，95%的时候关注是dependency，而很少有人真正会花时间去研究Maven的plugin。但小猴要告诉大家，其实Maven工作的核心是plugin，而不是dependency。好吧！再直接一点，菜鸟玩dependency，神仙玩plugin。是不是拼命想要反驳我，大家看看官网Plugin在Maven文档的位置，这意味着什么？&lt;/p&gt;
&lt;p&gt;灵魂拷问：大家留意过吗？是不是只去官网上下载Maven，然后随便百度一个教程就开始用Maven了？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206120452.png&quot; alt=&quot;image-20210206120452130&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析hadoop-example模块打包&quot;&gt;分析Hadoop Example模块打包&lt;/h2&gt;
&lt;p&gt;学习的一种最好方式就是借鉴，借鉴优秀的开源项目。看看别人是怎么做的。所以，接下来，我们就来看看Hadoop是如何打包的。为了方便给大家演示，小猴特意用Maven给大家演示一遍编译、打包。这样效果会明显些。&lt;/p&gt;
&lt;p&gt;操作步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在github上找到Apahce/hadoop项目（&lt;a href=&quot;https://github.com/apache/hadoop%EF%BC%89&quot; target=&quot;_blank&quot;&gt;https://github.com/apache/hadoop）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;找到hadoop-mapreduce-project / hadoop-mapreduce-examples模块。&lt;/li&gt;
&lt;li&gt;打开pom.xml文件。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0
                      https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
  &amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hadoop-project&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.4.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;relativePath&amp;gt;../../hadoop-project&amp;lt;/relativePath&amp;gt;
  &amp;lt;/parent&amp;gt;
  &amp;lt;artifactId&amp;gt;hadoop-mapreduce-examples&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;3.4.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;description&amp;gt;Apache Hadoop MapReduce Examples&amp;lt;/description&amp;gt;
  &amp;lt;name&amp;gt;Apache Hadoop MapReduce Examples&amp;lt;/name&amp;gt;
  &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;mr.examples.basedir&amp;gt;${basedir}&amp;lt;/mr.examples.basedir&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;commons-cli&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;commons-cli&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;commons-logging&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;commons-logging&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;hadoop-mapreduce-client-jobclient&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;hadoop-mapreduce-client-jobclient&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
      &amp;lt;type&amp;gt;test-jar&amp;lt;/type&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;hadoop-common&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;hadoop-common&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
      &amp;lt;type&amp;gt;test-jar&amp;lt;/type&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;hadoop-hdfs-client&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;hadoop-hdfs&amp;lt;/artifactId&amp;gt;
       &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
       &amp;lt;type&amp;gt;test-jar&amp;lt;/type&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;hadoop-yarn-server-tests&amp;lt;/artifactId&amp;gt;
       &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
       &amp;lt;type&amp;gt;test-jar&amp;lt;/type&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;hadoop-mapreduce-client-app&amp;lt;/artifactId&amp;gt;
       &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;hadoop-mapreduce-client-app&amp;lt;/artifactId&amp;gt;
       &amp;lt;type&amp;gt;test-jar&amp;lt;/type&amp;gt;
       &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
     &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.sun.jersey.jersey-test-framework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jersey-test-framework-grizzly2&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;hadoop-mapreduce-client-hs&amp;lt;/artifactId&amp;gt;
       &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.hsqldb&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;hsqldb&amp;lt;/artifactId&amp;gt;
       &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.hadoop.thirdparty&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;hadoop-shaded-guava&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
     &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.assertj&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;assertj-core&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
  
  &amp;lt;build&amp;gt;
   &amp;lt;plugins&amp;gt;
    &amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;configuration&amp;gt;
       &amp;lt;archive&amp;gt;
         &amp;lt;manifest&amp;gt;
           &amp;lt;mainClass&amp;gt;org.apache.hadoop.examples.ExampleDriver&amp;lt;/mainClass&amp;gt;
         &amp;lt;/manifest&amp;gt;
       &amp;lt;/archive&amp;gt;
     &amp;lt;/configuration&amp;gt;
    &amp;lt;/plugin&amp;gt;

      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;findbugs-maven-plugin&amp;lt;/artifactId&amp;gt;
         &amp;lt;configuration&amp;gt;
          &amp;lt;findbugsXmlOutput&amp;gt;true&amp;lt;/findbugsXmlOutput&amp;gt;
          &amp;lt;xmlOutput&amp;gt;true&amp;lt;/xmlOutput&amp;gt;
          &amp;lt;excludeFilterFile&amp;gt;${mr.examples.basedir}/dev-support/findbugs-exclude.xml&amp;lt;/excludeFilterFile&amp;gt;
          &amp;lt;effort&amp;gt;Max&amp;lt;/effort&amp;gt;
        &amp;lt;/configuration&amp;gt;
      &amp;lt;/plugin&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.rat&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;apache-rat-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;configuration&amp;gt;
          &amp;lt;excludes&amp;gt;
            &amp;lt;exclude&amp;gt;src/main/java/org/apache/hadoop/examples/dancing/puzzle1.dta&amp;lt;/exclude&amp;gt;
          &amp;lt;/excludes&amp;gt;
        &amp;lt;/configuration&amp;gt;
      &amp;lt;/plugin&amp;gt;
   &amp;lt;/plugins&amp;gt;
   &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过浏览hadoop example的xml文件，我们发现了以下几点：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所有的依赖都在父工程hadoop-project的pom.xml中定义好了。在hadoop example项目中，没有出现任何一个版本号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206104307.png&quot; alt=&quot;image-20210206104307402&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Hadoop使用了三个插件，一个是maven-jar-plugin、一个是findbugs-maven-plugin、还有一个是apache-rat-plugin。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们进入到example模块中pom.xml所在的目录中，直接执行mvn package试试看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@compile hadoop-mapreduce-examples]# mvn package
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------&amp;lt; org.apache.hadoop:hadoop-mapreduce-examples &amp;gt;-------------
[INFO] Building Apache Hadoop MapReduce Examples 3.2.1
[INFO] --------------------------------[ jar ]---------------------------------
Downloading from apache.snapshots.https: https://repository.apache.org/content/repositories/snapshots/org/apache/hadoop/hadoop-mapreduce-client-app/3.2.1/hadoop-mapreduce-client-app-3.2.1-tests.jar
.....

[INFO] 
[INFO] --- maven-antrun-plugin:1.7:run (create-testdirs) @ hadoop-mapreduce-examples ---
[INFO] Executing tasks

main:
[INFO] Executed tasks
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hadoop-mapreduce-examples ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /opt/hadoop-3.2.1-src/hadoop-mapreduce-project/hadoop-mapreduce-examples/src/main/resources
[INFO] 

[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hadoop-mapreduce-examples ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 

[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hadoop-mapreduce-examples ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /opt/hadoop-3.2.1-src/hadoop-mapreduce-project/hadoop-mapreduce-examples/src/test/resources
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hadoop-mapreduce-examples ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] --- maven-surefire-plugin:3.0.0-M1:test (default-test) @ hadoop-mapreduce-examples ---
Downloading from central: http://maven.aliyun.com/nexus/content/groups/public/org/apache/maven/surefire/surefire-junit4/3.0.0-M1/surefire-junit4-3.0.0-M1.jar

..........

[INFO] 
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running org.apache.hadoop.examples.TestBaileyBorweinPlouffe
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.536 s - in org.apache.hadoop.examples.TestBaileyBorweinPlouffe

..........

[INFO] 
[INFO] Results:
[INFO] 
[INFO] Tests run: 11, Failures: 0, Errors: 0, Skipped: 0
[INFO] 
[INFO] 
[INFO] --- maven-jar-plugin:2.5:jar (default-jar) @ hadoop-mapreduce-examples ---
[INFO] 
[INFO] --- maven-site-plugin:3.6:attach-descriptor (attach-descriptor) @ hadoop-mapreduce-examples ---
[INFO] Skipping because packaging 'jar' is not pom.
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  01:11 min
[INFO] Finished at: 2021-02-06T10:49:18+08:00
[INFO] ------------------------------------------------------------------------

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很快就编译成功了，我们来看看Maven做了什么：&lt;/p&gt;
&lt;p&gt;1、执行maven-antrun-plugin插件的run create-testdirs任务。奇怪的是，Example模块中并没有引入该插件。一会来看看该插件在何处配置的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[INFO] --- maven-antrun-plugin:1.7:run (create-testdirs) @ hadoop-mapreduce-examples ---
[INFO] Executing tasks
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、执行maven-resources-plugin插件的resources任务，这个插件应该是拷贝resource目录到target的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ hadoop-mapreduce-examples ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /opt/hadoop-3.2.1-src/hadoop-mapreduce-project/hadoop-mapreduce-examples/src/main/resources
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、执行maven-compiler-plugin插件的compile任务，注意：现在才开始编译代码。因为发现我们之前已经编译过了，所以此处并没有重新编译class。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ hadoop-mapreduce-examples ---
[INFO] Compiling 47 source files to /opt/hadoop-3.2.1-src/hadoop-mapreduce-project/hadoop-mapreduce-examples/target/classes
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、执行maven-resources-plugin插件的testResources任务，顾名思义，就是将单元测试相关的resource目录拷贝到target。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ hadoop-mapreduce-examples ---
[INFO] Using 'UTF-8' encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory /opt/hadoop-3.2.1-src/hadoop-mapreduce-project/hadoop-mapreduce-examples/src/test/resources
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、执行maven-compiler-plugin插件的testCompile任务，同样，将单元测试的文件编译一遍。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ hadoop-mapreduce-examples ---
[INFO] Compiling 7 source files to /opt/hadoop-3.2.1-src/hadoop-mapreduce-project/hadoop-mapreduce-examples/target/test-classes
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、执行maven-surefire-plugin插件的test任务，开始执行单元测试。确保编译的代码没有问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running org.apache.hadoop.examples.TestBaileyBorweinPlouffe
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.436 s - in org.apache.hadoop.examples.TestBaileyBorweinPlouffe
[INFO] Running org.apache.hadoop.examples.TestWordStats
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.332 s - in org.apache.hadoop.examples.TestWordStats
[INFO] Running org.apache.hadoop.examples.pi.math.TestLongLong
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.163 s - in org.apache.hadoop.examples.pi.math.TestLongLong
[INFO] Running org.apache.hadoop.examples.pi.math.TestModular
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.164 s - in org.apache.hadoop.examples.pi.math.TestModular
[INFO] Running org.apache.hadoop.examples.pi.math.TestSummation
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.091 s - in org.apache.hadoop.examples.pi.math.TestSummation
[INFO] Running org.apache.hadoop.examples.terasort.TestTeraSort
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 4.449 s - in org.apache.hadoop.examples.terasort.TestTeraSort
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、执行maven-jar-plugin插件的jar任务，这个任务是打包成jar文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[INFO] --- maven-jar-plugin:2.5:jar (default-jar) @ hadoop-mapreduce-examples ---
[INFO] Building jar: /opt/hadoop-3.2.1-src/hadoop-mapreduce-project/hadoop-mapreduce-examples/target/hadoop-mapreduce-examples-3.2.1.jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、执行maven-site-plugin的attach-descriptor任务。该任务只有项目是pom打包时候才可用，将site.xml（site描述符）添加到部署的文件列表中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[INFO] --- maven-site-plugin:3.6:attach-descriptor (attach-descriptor) @ hadoop-mapreduce-examples ---
[INFO] Skipping because packaging 'jar' is not pom.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此，我们可以发现，当我们执行一个package、compile、或者clean命令时，其实背后都是执行Maven的一个插件。只不过有的插件是Maven自带的，直接可以使用，当我们需要自定义插件的行为时，就需要显示在pom.xml中显式配置插件了。&lt;/p&gt;
&lt;p&gt;Maven中有大量的、丰富的插件供开发人员使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206110859.png&quot; alt=&quot;image-20210206110859445&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://maven.apache.org/plugins/&quot; target=&quot;_blank&quot;&gt;https://maven.apache.org/plugins/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以点击任意一个plugin，查看其具体的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206111024.png&quot; alt=&quot;image-20210206111024621&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;maven-antrun-plugin插件&quot;&gt;maven-antrun-plugin插件&lt;/h3&gt;
&lt;p&gt;我们发现在example模块的父模块hadoop-project中有一个pom.xml。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt; &amp;lt;plugin&amp;gt;
     &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;maven-antrun-plugin&amp;lt;/artifactId&amp;gt;
     &amp;lt;executions&amp;gt;
         &amp;lt;execution&amp;gt;
             &amp;lt;id&amp;gt;create-testdirs&amp;lt;/id&amp;gt;
             &amp;lt;phase&amp;gt;validate&amp;lt;/phase&amp;gt;
             &amp;lt;goals&amp;gt;
                 &amp;lt;goal&amp;gt;run&amp;lt;/goal&amp;gt;
             &amp;lt;/goals&amp;gt;
             &amp;lt;configuration&amp;gt;
                 &amp;lt;target&amp;gt;
                     &amp;lt;mkdir dir=&quot;${test.build.dir}&quot;/&amp;gt;
                     &amp;lt;mkdir dir=&quot;${test.build.data}&quot;/&amp;gt;
                 &amp;lt;/target&amp;gt;
             &amp;lt;/configuration&amp;gt;
         &amp;lt;/execution&amp;gt;
     &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到这里面有配置一些插件，其中就个maven-antrun-plugin。该插件会执行run#create-testdirs任务，并且在validate阶段执行。我们看到，该插件执行了两次mkdir。&lt;/p&gt;
&lt;h3 id=&quot;maven-jar-plugin插件&quot;&gt;maven-jar-plugin插件&lt;/h3&gt;
&lt;p&gt;插件配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;archive&amp;gt;
            &amp;lt;manifest&amp;gt;
                &amp;lt;mainClass&amp;gt;org.apache.hadoop.examples.ExampleDriver&amp;lt;/mainClass&amp;gt;
            &amp;lt;/manifest&amp;gt;
        &amp;lt;/archive&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面，我们看到了是在执行package阶段时自动执行的。并且指定了运行的主类是ExampleDriver。通过查看打包后的JAR文件，我们可以发现，JAR插件只会将项目中的class文件打包到JAR文件中，并不会打包其他的依赖。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206114017.png&quot; alt=&quot;image-20210206114017839&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且，在JAR包的META-INF（元数据中），可以看到MAINFEST.MF文件，已经生成了运行主类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206114118.png&quot; alt=&quot;image-20210206114118518&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个插件的相关说明，可以参看官网：&lt;a href=&quot;https://maven.apache.org/plugins/maven-jar-plugin/&quot; target=&quot;_blank&quot;&gt;https://maven.apache.org/plugins/maven-jar-plugin/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在每个jar包中有一个META-INF目录，顾名思义。它肯定是包含了JAR文件的元数据相关。Java基于META-INF目录中的文件来配置Java应用程序、类加载器以及其他服务。它包含以下内容：&lt;/p&gt;
&lt;h3 id=&quot;manifestmf&quot;&gt;MANIFEST.MF&lt;/h3&gt;
&lt;p&gt;用于定义扩展名以及打包相关的清单。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;Manifest-Version: 1.0
Archiver-Version: Plexus Archiver
Built-By: China
Created-By: Apache Maven 3.5.0
Build-Jdk: 1.8.0_241
Main-Class: cn.monkey.StreamingJob
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该文件中显示了文件的版本、由哪个用户构建的、由哪个应用创建的、构建的JDK版本、以及非常重要的Main-Class。&lt;/p&gt;
&lt;h3 id=&quot;indexlist&quot;&gt;INDEX.LIST&lt;/h3&gt;
&lt;p&gt;该文件由JAR工具的-i选项生成，包括了应用程序或者扩展中定义的包的位置。用于类加载器加速类加载过程。&lt;/p&gt;
&lt;h3 id=&quot;xxxsf&quot;&gt;xxx.SF&lt;/h3&gt;
&lt;p&gt;JAR包的签名文件&lt;/p&gt;
&lt;h3 id=&quot;xxxdsa&quot;&gt;xxx.DSA&lt;/h3&gt;
&lt;p&gt;与SF文件关联的签名块文件。该文件存储了签名文件对应的数字签名。&lt;/p&gt;
&lt;h2 id=&quot;maven插件&quot;&gt;Maven插件&lt;/h2&gt;
&lt;h3 id=&quot;maven构建生命周期&quot;&gt;Maven构建生命周期&lt;/h3&gt;
&lt;p&gt;Maven是一个项目管理工具，它把项目的构建主要分为了以下阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;validate：验证项目是否正确，所有必要的信息是否均已经提供&lt;/li&gt;
&lt;li&gt;compile：编译项目的源代码。&lt;/li&gt;
&lt;li&gt;test：运行单元测试。&lt;/li&gt;
&lt;li&gt;package：打包已编译的代码。&lt;/li&gt;
&lt;li&gt;verify：对集成测试结果进行检查，确保符合质量标准。&lt;/li&gt;
&lt;li&gt;install：将软件包安装到本地仓库。&lt;/li&gt;
&lt;li&gt;deploy：将最终的软件包复制到远程仓库，方便和其他开发人员共享。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是说，只要是一个Maven项目，从源代码到一个可运行的程序，需要经历着一系列的构建阶段。而每个阶段的背后，是Maven提供了一个构建过程的核心执行引擎，这个核心的项目构建执行引擎是由大量的插件来执行具体的任务。&lt;/p&gt;
&lt;h3 id=&quot;重新定义maven&quot;&gt;重新定义Maven&lt;/h3&gt;
&lt;p&gt;让我们从技术角度，重新定义Maven——一个包含了很多插件的框架。真正执行各种Maven操作的其实都是插件。例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构建JAR包&lt;/li&gt;
&lt;li&gt;构建WAR包&lt;/li&gt;
&lt;li&gt;编译代码&lt;/li&gt;
&lt;li&gt;执行单元测试&lt;/li&gt;
&lt;li&gt;创建项目文档&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;等等。只要是能够想到需要在项目上执行的所有操作，其背后都是插件实现的。&lt;/p&gt;
&lt;p&gt;插件是Maven的核心功能，一旦定义好了插件，就可以在多个项目中重用。想想，我们是不是在每个pom.xml配置打包插件、编译插件等等。找到pom.xml的位置，然后执行 package、comile、clean等操作即可。当我们执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn compile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;的时候，Maven得知道，哦！当前要执行编译了。由此可以知道，Maven的插件是由mvn的参数来驱动的。这些参数定义了插件的目标（或者Mojo）。&lt;/p&gt;
&lt;h3 id=&quot;mojo&quot;&gt;Mojo&lt;/h3&gt;
&lt;p&gt;Maven中最简单的插件是Clean Plugin。它只是负责删除Maven项目的target目录。但运行&lt;code&gt;mvn clean&lt;/code&gt;时，Maven将执行Clean插件中定义的clean目标（Goal），并删除目标目录。Clean插件还定义了可用于自定义插件行为的参数，长概述为outputDirectory，默认为${project.build.directory}。&lt;/p&gt;
&lt;p&gt;Mojo实际上是Maven插件中的一个目标（Goal），一个插件可以包含许多的Goal。我们可以用带注解的Java类或者BeanShell脚本来定义Mojo。它指定了Goal相关的元数据：Goal名称、以及Goal所运行的生命周期、以及参数。&lt;/p&gt;
&lt;h3 id=&quot;查看clean插件源码&quot;&gt;查看clean插件源码&lt;/h3&gt;
&lt;p&gt;通过Maven官网的plugins链接，我们可以找到clean插件在github的地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206124814.png&quot; alt=&quot;image-20210206124814385&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206124929.png&quot; alt=&quot;image-20210206124929870&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到src目录和pom.xml，我们就可以知道，原来Maven的plugin也是一个Maven标准项目。先来看看pom.xml里面有什么。为了方便观察，我删除了一些代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;project&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-plugins&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;34&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt;
  &amp;lt;/parent&amp;gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;mavenVersion&amp;gt;3.1.1&amp;lt;/mavenVersion&amp;gt;
    &amp;lt;javaVersion&amp;gt;7&amp;lt;/javaVersion&amp;gt;
    &amp;lt;surefire.version&amp;gt;2.22.2&amp;lt;/surefire.version&amp;gt;
    &amp;lt;mavenPluginToolsVersion&amp;gt;3.6.0&amp;lt;/mavenPluginToolsVersion&amp;gt;
    &amp;lt;project.build.outputTimestamp&amp;gt;2020-04-07T21:04:00Z&amp;lt;/project.build.outputTimestamp&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.maven&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;maven-plugin-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;${mavenVersion}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.maven.shared&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;maven-shared-utils&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.2.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!-- dependencies to annotations --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.apache.maven.plugin-tools&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;maven-plugin-annotations&amp;lt;/artifactId&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;

  &amp;lt;build&amp;gt;
    &amp;lt;pluginManagement&amp;gt;
      &amp;lt;plugins&amp;gt;
        &amp;lt;!-- remove with next parent upgrade --&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-project-info-reports-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.1.1&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-enforcer-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.0.0-M3&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-javadoc-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
        &amp;lt;plugin&amp;gt;
          &amp;lt;artifactId&amp;gt;maven-site-plugin&amp;lt;/artifactId&amp;gt;
          &amp;lt;version&amp;gt;3.9.1&amp;lt;/version&amp;gt;
        &amp;lt;/plugin&amp;gt;
      &amp;lt;/plugins&amp;gt;
    &amp;lt;/pluginManagement&amp;gt;
  &amp;lt;/build&amp;gt;
      
  &amp;lt;profiles&amp;gt;
    &amp;lt;profile&amp;gt;
      &amp;lt;id&amp;gt;run-its&amp;lt;/id&amp;gt;
      &amp;lt;build&amp;gt;
        &amp;lt;pluginManagement&amp;gt;
          &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
              &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
              &amp;lt;artifactId&amp;gt;maven-invoker-plugin&amp;lt;/artifactId&amp;gt;
              &amp;lt;configuration&amp;gt;
                &amp;lt;debug&amp;gt;true&amp;lt;/debug&amp;gt;
                &amp;lt;addTestClassPath&amp;gt;true&amp;lt;/addTestClassPath&amp;gt;
                &amp;lt;projectsDirectory&amp;gt;src/it&amp;lt;/projectsDirectory&amp;gt;
                &amp;lt;cloneProjectsTo&amp;gt;${project.build.directory}/it&amp;lt;/cloneProjectsTo&amp;gt;
                &amp;lt;pomIncludes&amp;gt;
                  &amp;lt;pomInclude&amp;gt;*/pom.xml&amp;lt;/pomInclude&amp;gt;
                &amp;lt;/pomIncludes&amp;gt;
                &amp;lt;preBuildHookScript&amp;gt;setup&amp;lt;/preBuildHookScript&amp;gt;
                &amp;lt;postBuildHookScript&amp;gt;verify&amp;lt;/postBuildHookScript&amp;gt;
                &amp;lt;localRepositoryPath&amp;gt;${project.build.directory}/local-repo&amp;lt;/localRepositoryPath&amp;gt;
                &amp;lt;settingsFile&amp;gt;src/it/settings.xml&amp;lt;/settingsFile&amp;gt;
                &amp;lt;goals&amp;gt;
                  &amp;lt;goal&amp;gt;clean&amp;lt;/goal&amp;gt;
                &amp;lt;/goals&amp;gt;
              &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
          &amp;lt;/plugins&amp;gt;
        &amp;lt;/pluginManagement&amp;gt;
      &amp;lt;/build&amp;gt;
    &amp;lt;/profile&amp;gt;
  &amp;lt;/profiles&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到，pom.xml中引入了一些必要的依赖、以及定义了一些其他插件的版本、在profile中，还定义了maven-invoker-plugin的配置。里面配置了&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Invoker插件：用于运行一组Maven项目，该插件可以确定每个项目执行是否成功，并且可以选择验证从给定项目执行生成的输出。比较适合用于集成测试。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206130007.png&quot; alt=&quot;image-20210206130007340&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到了源码中有一个CleanMojo的源文件，代码中使用了注解来定义插件的Goal和参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206130107.png&quot; alt=&quot;image-20210206130107577&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206130431.png&quot; alt=&quot;image-20210206130431392&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看到execute中就是执行clean目标，里面调用了Cleaner来清理文件。再查看下install插件的Mojo&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206130701.png&quot; alt=&quot;image-20210206130701348&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;install默认绑定的是INSTALL阶段。&lt;/p&gt;
&lt;p&gt;看完上面的源码，我们知道：以后使用插件，可以看看它的Mojo文件就知道它对应的目标是什么、参数是什么。我们还可以通过插件的源码来进行错误排查。&lt;/p&gt;
&lt;h2 id=&quot;分析flink-archetype中的pomxml&quot;&gt;分析Flink Archetype中的pom.xml&lt;/h2&gt;
&lt;p&gt;scala版本的pom.xml依赖要比Java版本要复杂，因为Maven默认就是用于构建Java的。而针对scala的构建，需要进行额外配置Maven支持。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn archetype:generate \
-DarchetypeGroupId=org.apache.flink \
-DarchetypeArtifactId=flink-quickstart-scala \
-DarchetypeVersion=1.12.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Flink自动生成的代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
        &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

        &amp;lt;groupId&amp;gt;cn.monkey&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;flink_scala_demo_1.12.1&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

        &amp;lt;name&amp;gt;Flink Quickstart Job&amp;lt;/name&amp;gt;

        &amp;lt;repositories&amp;gt;
                &amp;lt;repository&amp;gt;
                        &amp;lt;id&amp;gt;apache.snapshots&amp;lt;/id&amp;gt;
                        &amp;lt;name&amp;gt;Apache Development Snapshot Repository&amp;lt;/name&amp;gt;
                        &amp;lt;url&amp;gt;https://repository.apache.org/content/repositories/snapshots/&amp;lt;/url&amp;gt;
                        &amp;lt;releases&amp;gt;
                                &amp;lt;enabled&amp;gt;false&amp;lt;/enabled&amp;gt;
                        &amp;lt;/releases&amp;gt;
                        &amp;lt;snapshots&amp;gt;
                                &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
                        &amp;lt;/snapshots&amp;gt;
                &amp;lt;/repository&amp;gt;
        &amp;lt;/repositories&amp;gt;

        &amp;lt;properties&amp;gt;
                &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
                &amp;lt;flink.version&amp;gt;1.12.1&amp;lt;/flink.version&amp;gt;
                &amp;lt;scala.binary.version&amp;gt;2.11&amp;lt;/scala.binary.version&amp;gt;
                &amp;lt;scala.version&amp;gt;2.11.12&amp;lt;/scala.version&amp;gt;
                &amp;lt;log4j.version&amp;gt;2.12.1&amp;lt;/log4j.version&amp;gt;
        &amp;lt;/properties&amp;gt;

        &amp;lt;dependencies&amp;gt;
                &amp;lt;!-- Apache Flink dependencies --&amp;gt;
                &amp;lt;!-- These dependencies are provided, because they should not be packaged into the JAR file. --&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;flink-scala_${scala.binary.version}&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${flink.version}&amp;lt;/version&amp;gt;
                        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;flink-streaming-scala_${scala.binary.version}&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${flink.version}&amp;lt;/version&amp;gt;
                        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;flink-clients_${scala.binary.version}&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${flink.version}&amp;lt;/version&amp;gt;
                        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
                &amp;lt;/dependency&amp;gt;

                &amp;lt;!-- Scala Library, provided by Flink as well. --&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.scala-lang&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;scala-library&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${scala.version}&amp;lt;/version&amp;gt;
                        &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
                &amp;lt;/dependency&amp;gt;

                &amp;lt;!-- Add connector dependencies here. They must be in the default scope (compile). --&amp;gt;

                &amp;lt;!-- Example:

                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;flink-connector-kafka_${scala.binary.version}&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${flink.version}&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;
                --&amp;gt;

                &amp;lt;!-- Add logging framework, to produce console output when running in the IDE. --&amp;gt;
                &amp;lt;!-- These dependencies are excluded from the application JAR by default. --&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;log4j-slf4j-impl&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt;
                        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;log4j-api&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt;
                        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
                &amp;lt;/dependency&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.logging.log4j&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;log4j-core&amp;lt;/artifactId&amp;gt;
                        &amp;lt;version&amp;gt;${log4j.version}&amp;lt;/version&amp;gt;
                        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
                &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;

        &amp;lt;build&amp;gt;
                &amp;lt;plugins&amp;gt;
                        &amp;lt;!-- We use the maven-shade plugin to create a fat jar that contains all necessary dependencies. --&amp;gt;
                        &amp;lt;!-- Change the value of &amp;lt;mainClass&amp;gt;...&amp;lt;/mainClass&amp;gt; if your program entry point changes. --&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;3.1.1&amp;lt;/version&amp;gt;
                                &amp;lt;executions&amp;gt;
                                        &amp;lt;!-- Run shade goal on package phase --&amp;gt;
                                        &amp;lt;execution&amp;gt;
                                                &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                                                &amp;lt;goals&amp;gt;
                                                        &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
                                                &amp;lt;/goals&amp;gt;
                                                &amp;lt;configuration&amp;gt;
                                                        &amp;lt;artifactSet&amp;gt;
                                                                &amp;lt;excludes&amp;gt;
                                                                        &amp;lt;exclude&amp;gt;org.apache.flink:force-shading&amp;lt;/exclude&amp;gt;
                                                                        &amp;lt;exclude&amp;gt;com.google.code.findbugs:jsr305&amp;lt;/exclude&amp;gt;
                                                                        &amp;lt;exclude&amp;gt;org.slf4j:*&amp;lt;/exclude&amp;gt;
                                                                        &amp;lt;exclude&amp;gt;org.apache.logging.log4j:*&amp;lt;/exclude&amp;gt;
                                                                &amp;lt;/excludes&amp;gt;
                                                        &amp;lt;/artifactSet&amp;gt;
                                                        &amp;lt;filters&amp;gt;
                                                                &amp;lt;filter&amp;gt;
                                                                        &amp;lt;!-- Do not copy the signatures in the META-INF folder.
                                                                        Otherwise, this might cause SecurityExceptions when using the JAR. --&amp;gt;
                                                                        &amp;lt;artifact&amp;gt;*:*&amp;lt;/artifact&amp;gt;
                                                                        &amp;lt;excludes&amp;gt;
                                                                                &amp;lt;exclude&amp;gt;META-INF/*.SF&amp;lt;/exclude&amp;gt;
                                                                                &amp;lt;exclude&amp;gt;META-INF/*.DSA&amp;lt;/exclude&amp;gt;
                                                                                &amp;lt;exclude&amp;gt;META-INF/*.RSA&amp;lt;/exclude&amp;gt;
                                                                        &amp;lt;/excludes&amp;gt;
                                                                &amp;lt;/filter&amp;gt;
                                                        &amp;lt;/filters&amp;gt;
                                                        &amp;lt;transformers&amp;gt;
                                                                &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&amp;gt;
                                                                        &amp;lt;mainClass&amp;gt;cn.monkey.StreamingJob&amp;lt;/mainClass&amp;gt;
                                                                &amp;lt;/transformer&amp;gt;
                                                        &amp;lt;/transformers&amp;gt;
                                                &amp;lt;/configuration&amp;gt;
                                        &amp;lt;/execution&amp;gt;
                                &amp;lt;/executions&amp;gt;
                        &amp;lt;/plugin&amp;gt;

                        &amp;lt;!-- Java Compiler --&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;3.1&amp;lt;/version&amp;gt;
                                &amp;lt;configuration&amp;gt;
                                        &amp;lt;source&amp;gt;1.8&amp;lt;/source&amp;gt;
                                        &amp;lt;target&amp;gt;1.8&amp;lt;/target&amp;gt;
                                &amp;lt;/configuration&amp;gt;
                        &amp;lt;/plugin&amp;gt;

                        &amp;lt;!-- Scala Compiler --&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;net.alchim31.maven&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;scala-maven-plugin&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;3.2.2&amp;lt;/version&amp;gt;
                                &amp;lt;executions&amp;gt;
                                        &amp;lt;execution&amp;gt;
                                                &amp;lt;goals&amp;gt;
                                                        &amp;lt;goal&amp;gt;compile&amp;lt;/goal&amp;gt;
                                                        &amp;lt;goal&amp;gt;testCompile&amp;lt;/goal&amp;gt;
                                                &amp;lt;/goals&amp;gt;
                                        &amp;lt;/execution&amp;gt;
                                &amp;lt;/executions&amp;gt;
                                &amp;lt;configuration&amp;gt;
                                        &amp;lt;args&amp;gt;
                                                &amp;lt;arg&amp;gt;-nobootcp&amp;lt;/arg&amp;gt;
                                        &amp;lt;/args&amp;gt;
                                &amp;lt;/configuration&amp;gt;
                        &amp;lt;/plugin&amp;gt;

                        &amp;lt;!-- Eclipse Scala Integration --&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;maven-eclipse-plugin&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;2.8&amp;lt;/version&amp;gt;
                                &amp;lt;configuration&amp;gt;
                                        &amp;lt;downloadSources&amp;gt;true&amp;lt;/downloadSources&amp;gt;
                                        &amp;lt;projectnatures&amp;gt;
                                                &amp;lt;projectnature&amp;gt;org.scala-ide.sdt.core.scalanature&amp;lt;/projectnature&amp;gt;
                                                &amp;lt;projectnature&amp;gt;org.eclipse.jdt.core.javanature&amp;lt;/projectnature&amp;gt;
                                        &amp;lt;/projectnatures&amp;gt;
                                        &amp;lt;buildcommands&amp;gt;
                                                &amp;lt;buildcommand&amp;gt;org.scala-ide.sdt.core.scalabuilder&amp;lt;/buildcommand&amp;gt;
                                        &amp;lt;/buildcommands&amp;gt;
                                        &amp;lt;classpathContainers&amp;gt;
                                                &amp;lt;classpathContainer&amp;gt;org.scala-ide.sdt.launching.SCALA_CONTAINER&amp;lt;/classpathContainer&amp;gt;
                                                &amp;lt;classpathContainer&amp;gt;org.eclipse.jdt.launching.JRE_CONTAINER&amp;lt;/classpathContainer&amp;gt;
                                        &amp;lt;/classpathContainers&amp;gt;
                                        &amp;lt;excludes&amp;gt;
                                                &amp;lt;exclude&amp;gt;org.scala-lang:scala-library&amp;lt;/exclude&amp;gt;
                                                &amp;lt;exclude&amp;gt;org.scala-lang:scala-compiler&amp;lt;/exclude&amp;gt;
                                        &amp;lt;/excludes&amp;gt;
                                        &amp;lt;sourceIncludes&amp;gt;
                                                &amp;lt;sourceInclude&amp;gt;**/*.scala&amp;lt;/sourceInclude&amp;gt;
                                                &amp;lt;sourceInclude&amp;gt;**/*.java&amp;lt;/sourceInclude&amp;gt;
                                        &amp;lt;/sourceIncludes&amp;gt;
                                &amp;lt;/configuration&amp;gt;
                        &amp;lt;/plugin&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;build-helper-maven-plugin&amp;lt;/artifactId&amp;gt;
                                &amp;lt;version&amp;gt;1.7&amp;lt;/version&amp;gt;
                                &amp;lt;executions&amp;gt;
                                        &amp;lt;!-- Add src/main/scala to eclipse build path --&amp;gt;
                                        &amp;lt;execution&amp;gt;
                                                &amp;lt;id&amp;gt;add-source&amp;lt;/id&amp;gt;
                                                &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                                                &amp;lt;goals&amp;gt;
                                                        &amp;lt;goal&amp;gt;add-source&amp;lt;/goal&amp;gt;
                                                &amp;lt;/goals&amp;gt;
                                                &amp;lt;configuration&amp;gt;
                                                        &amp;lt;sources&amp;gt;
                                                                &amp;lt;source&amp;gt;src/main/scala&amp;lt;/source&amp;gt;
                                                        &amp;lt;/sources&amp;gt;
                                                &amp;lt;/configuration&amp;gt;
                                        &amp;lt;/execution&amp;gt;
                                        &amp;lt;!-- Add src/test/scala to eclipse build path --&amp;gt;
                                        &amp;lt;execution&amp;gt;
                                                &amp;lt;id&amp;gt;add-test-source&amp;lt;/id&amp;gt;
                                                &amp;lt;phase&amp;gt;generate-test-sources&amp;lt;/phase&amp;gt;
                                                &amp;lt;goals&amp;gt;
                                                        &amp;lt;goal&amp;gt;add-test-source&amp;lt;/goal&amp;gt;
                                                &amp;lt;/goals&amp;gt;
                                                &amp;lt;configuration&amp;gt;
                                                        &amp;lt;sources&amp;gt;
                                                                &amp;lt;source&amp;gt;src/test/scala&amp;lt;/source&amp;gt;
                                                        &amp;lt;/sources&amp;gt;
                                                &amp;lt;/configuration&amp;gt;
                                        &amp;lt;/execution&amp;gt;
                                &amp;lt;/executions&amp;gt;
                        &amp;lt;/plugin&amp;gt;
                &amp;lt;/plugins&amp;gt;
        &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个标准Flink Maven脚手架，Flink清晰地告诉了我们，哪些依赖是需要设置为provided、哪些是runtime，如果需要使用connector，需要自己额外引入对应不同存储库的connector。我们重点来分析插件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;maven-shade-plugin：可以看到，Flink是使用shade插件进行fat jar打包的。可以通过mainClass参数配置jar包的入口。&lt;/li&gt;
&lt;li&gt;maven-compiler-plugin：配置Java编译器。Flink默认使用1.8进行编译。&lt;/li&gt;
&lt;li&gt;scala-maven-plugin：配置Scala编译器。&lt;/li&gt;
&lt;li&gt;maven-eclipse-plugin：该插件定义了编译scala和java文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们重点来看shade插件。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;如果多个插件配置的生命周期阶段为package，那么会按照pom.xml的顺序依次执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;shade插件&quot;&gt;Shade插件&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.1.1&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;!-- Run shade goal on package phase --&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;artifactSet&amp;gt;
                    &amp;lt;excludes&amp;gt;
                        &amp;lt;exclude&amp;gt;org.apache.flink:force-shading&amp;lt;/exclude&amp;gt;
                        &amp;lt;exclude&amp;gt;com.google.code.findbugs:jsr305&amp;lt;/exclude&amp;gt;
                        &amp;lt;exclude&amp;gt;org.slf4j:*&amp;lt;/exclude&amp;gt;
                        &amp;lt;exclude&amp;gt;org.apache.logging.log4j:*&amp;lt;/exclude&amp;gt;
                    &amp;lt;/excludes&amp;gt;
                &amp;lt;/artifactSet&amp;gt;
                &amp;lt;filters&amp;gt;
                    &amp;lt;filter&amp;gt;
                        &amp;lt;!-- Do not copy the signatures in the META-INF folder.
         Otherwise, this might cause SecurityExceptions when using the JAR. --&amp;gt;
                        &amp;lt;artifact&amp;gt;*:*&amp;lt;/artifact&amp;gt;
                        &amp;lt;excludes&amp;gt;
                            &amp;lt;exclude&amp;gt;META-INF/*.SF&amp;lt;/exclude&amp;gt;
                            &amp;lt;exclude&amp;gt;META-INF/*.DSA&amp;lt;/exclude&amp;gt;
                            &amp;lt;exclude&amp;gt;META-INF/*.RSA&amp;lt;/exclude&amp;gt;
                        &amp;lt;/excludes&amp;gt;
                    &amp;lt;/filter&amp;gt;
                &amp;lt;/filters&amp;gt;
                &amp;lt;transformers&amp;gt;
                    &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&amp;gt;
                        &amp;lt;mainClass&amp;gt;cn.monkey.StreamingJob&amp;lt;/mainClass&amp;gt;
                    &amp;lt;/transformer&amp;gt;
                &amp;lt;/transformers&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Shade插件可以将打包所有的artifact到一个uber-jar（uber-jar表示在一个JAR文件中包含自身、以及所有的依赖）。Shade插件只有一个goal：shade:shade。&lt;/p&gt;
&lt;p&gt;Mojo源码URL：&lt;a href=&quot;https://github.com/apache/maven-shade-plugin/blob/master/src/main/java/org/apache/maven/plugins/shade/mojo/ShadeMojo.java&quot; target=&quot;_blank&quot;&gt;https://github.com/apache/maven-shade-plugin/blob/master/src/main/java/org/apache/maven/plugins/shade/mojo/ShadeMojo.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206143601.png&quot; alt=&quot;image-20210206143601564&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，该插件的生命周期配置在package，也就是执行package时，会自动运行。&lt;/p&gt;
&lt;p&gt;在configuration中配置了要排除哪些artifacts。filter中配置了排除所有JAR包中的签名文件。我们可以在artifactSet、filter中来解决包冲突问题。&lt;/p&gt;
&lt;h2 id=&quot;assembly插件&quot;&gt;Assembly插件&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;很多时候我们需要把项目打包成一个tar.gz包，就像Apache的一些组件一样。通过使用Assembly插件可以将程序、文档、配置文件等等打包成一个“assemblies”。使用一个assembly descriptor可以描述整个过程。使用该插件，可以把应用打包成以下类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;zip
tar
tar.gz (or tgz)
tar.bz2 (or tbz2)
tar.snappy
tar.xz (or txz)
jar
dir
war
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果要打包成user-jar，assembly插件提供了一些基本的支持。官方建议还是使用shade插件。Assembly插件的使用步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择或编写一个assembly descriptor&lt;/li&gt;
&lt;li&gt;在pom.xml文件中配置assembly插件&lt;/li&gt;
&lt;li&gt;运行mvn assembly:single&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;assembly介绍&quot;&gt;Assembly介绍&lt;/h3&gt;
&lt;p&gt;Assembly（程序集）指的是一组文件、目录以及相关的依赖，为了方便软件的安装、部署、以及分发，我们可以把Assembly组织成一个zip包、或者tar.gz这种类型的包。例如：一个Maven项目中包含了控制台应用和FX桌面客户端应用。可以定义两个Assembly，将应用和不同的脚本、依赖绑定到一起。&lt;/p&gt;
&lt;p&gt;针对Assembly，需要有一个Assembly Descriptor（程序集描述符），通过assembly descripor文件可以描述将哪些文件复制到bin目录，并且可以修改目录中文件的权限。&lt;/p&gt;
&lt;h3 id=&quot;goal&quot;&gt;Goal&lt;/h3&gt;
&lt;p&gt;每一个Maven插件都会有一个Goal，Assembly插件也有一个Goal，那就是single，表示创建所有的Assembly。&lt;/p&gt;
&lt;h3 id=&quot;分析hadoop项目的assembly插件&quot;&gt;分析Hadoop项目的Assembly插件&lt;/h3&gt;
&lt;h4 id=&quot;maven插件配置&quot;&gt;Maven插件配置&lt;/h4&gt;
&lt;p&gt;我们来看一下Hadoop中如何使用该插件的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;inherited&amp;gt;false&amp;lt;/inherited&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;id&amp;gt;src-dist&amp;lt;/id&amp;gt;
            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;appendAssemblyId&amp;gt;false&amp;lt;/appendAssemblyId&amp;gt;
                &amp;lt;attach&amp;gt;false&amp;lt;/attach&amp;gt;
                &amp;lt;finalName&amp;gt;hadoop-${project.version}-src&amp;lt;/finalName&amp;gt;
                &amp;lt;outputDirectory&amp;gt;hadoop-dist/target&amp;lt;/outputDirectory&amp;gt;
                &amp;lt;!-- Not using descriptorRef and hadoop-assembly dependency --&amp;gt;
                &amp;lt;!-- to avoid making hadoop-main to depend on a module      --&amp;gt;
                &amp;lt;descriptors&amp;gt;
                    &amp;lt;descriptor&amp;gt;hadoop-assemblies/src/main/resources/assemblies/hadoop-src.xml&amp;lt;/descriptor&amp;gt;
                &amp;lt;/descriptors&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释下每个XML节点的意义：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置项&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;appendAssemblyId&lt;/td&gt;
&lt;td&gt;设置为false表示从最终的输出程序集中排除src-dist名字&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;attach&lt;/td&gt;
&lt;td&gt;控制Assembly插件是否将生成的assembly附加到项目中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;finalName&lt;/td&gt;
&lt;td&gt;Assembly发行版最终的文件名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;outputDirectory&lt;/td&gt;
&lt;td&gt;Assembly文件的最终输出目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;descriptors&lt;/td&gt;
&lt;td&gt;默认会从bin、jar-with-dependencies、src、project中加载内置描述符。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;内置的descriptors可以从assembly.jar中加载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206183715.png&quot; alt=&quot;image-20210206183715685&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以参考https://maven.apache.org/plugins/maven-assembly-plugin/descriptor-refs.html看到所有内置的descriptor中说明。这里Hadoop配置的是自己的descriptor。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;大家可以参考插件的AbstractAssemblyMojo.java中的定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;hadoop-srcxml-assembly配置&quot;&gt;hadoop-src.xml Assembly配置&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;assembly xmlns=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3&quot;
  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.3 http://maven.apache.org/xsd/assembly-1.1.3.xsd&quot;&amp;gt;
  &amp;lt;id&amp;gt;hadoop-src&amp;lt;/id&amp;gt;
  &amp;lt;formats&amp;gt;
    &amp;lt;format&amp;gt;tar.gz&amp;lt;/format&amp;gt;
  &amp;lt;/formats&amp;gt;
  &amp;lt;includeBaseDirectory&amp;gt;true&amp;lt;/includeBaseDirectory&amp;gt;
  &amp;lt;fileSets&amp;gt;
    &amp;lt;fileSet&amp;gt;
      &amp;lt;directory&amp;gt;.&amp;lt;/directory&amp;gt;
      &amp;lt;includes&amp;gt;
        &amp;lt;include&amp;gt;LICENCE.txt&amp;lt;/include&amp;gt;
        &amp;lt;include&amp;gt;README.txt&amp;lt;/include&amp;gt;
        &amp;lt;include&amp;gt;NOTICE.txt&amp;lt;/include&amp;gt;
      &amp;lt;/includes&amp;gt;
    &amp;lt;/fileSet&amp;gt;
    &amp;lt;fileSet&amp;gt;
      &amp;lt;directory&amp;gt;./licenses&amp;lt;/directory&amp;gt;
      &amp;lt;includes&amp;gt;
        &amp;lt;include&amp;gt;*&amp;lt;/include&amp;gt;
      &amp;lt;/includes&amp;gt;
    &amp;lt;/fileSet&amp;gt;
    &amp;lt;fileSet&amp;gt;
      &amp;lt;directory&amp;gt;.&amp;lt;/directory&amp;gt;
      &amp;lt;useDefaultExcludes&amp;gt;true&amp;lt;/useDefaultExcludes&amp;gt;
      &amp;lt;excludes&amp;gt;
        &amp;lt;exclude&amp;gt;.git/**&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/.gitignore&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/.svn&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/*.iws&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/*.ipr&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/*.iml&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/.classpath&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/.project&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/.settings&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/target/**&amp;lt;/exclude&amp;gt;
        &amp;lt;!-- until the code that does this is fixed --&amp;gt;
        &amp;lt;exclude&amp;gt;**/*.log&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/build/**&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/file:/**&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;**/SecurityAuth.audit*&amp;lt;/exclude&amp;gt;
        &amp;lt;exclude&amp;gt;patchprocess/**&amp;lt;/exclude&amp;gt;
      &amp;lt;/excludes&amp;gt;
    &amp;lt;/fileSet&amp;gt;
  &amp;lt;/fileSets&amp;gt;
&amp;lt;/assembly&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以参考：&lt;a href=&quot;https://maven.apache.org/plugins/maven-assembly-plugin/assembly.html%E7%9C%8B%E5%88%B0assembly%E7%9B%B8%E5%85%B3%E7%9A%84%E6%89%80%E6%9C%89%E9%85%8D%E7%BD%AE%E3%80%82&quot; target=&quot;_blank&quot;&gt;https://maven.apache.org/plugins/maven-assembly-plugin/assembly.html看到assembly相关的所有配置。&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置项&lt;/th&gt;
&lt;th&gt;配置&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;hadoop-src&lt;/td&gt;
&lt;td&gt;设置Assembly的id。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;formats/format*&lt;/td&gt;
&lt;td&gt;tar.gz&lt;/td&gt;
&lt;td&gt;指定assembly的最终格式。这里hadoop配置的是tar.gz，表示最终打包出来一个tar.gz文件，当然可以配置多个。例如：zip、tar、jar等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;includeBaseDirectory&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;在tar.gz中包括一个base目录。就是tar.gz会包含一个文件夹。而不是直接把大量的文件直接放在tar.gz中。（这个一定要配置true，不然解压安装的时候会很蛋疼。）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;fileSets&lt;/td&gt;
&lt;td&gt;fileset&lt;/td&gt;
&lt;td&gt;指定要包含在Assembly中的模块文件。就是最终要将哪些文件复制到tar.gz中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;fileset/useDefaultExcludes&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;td&gt;是否应使用标准排除模式。对于向后兼容性，默认值为true。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;fileset/directory&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;设置模块目录中的绝对或相对位置。例如，“src/main/bin”将选择定义此依赖项的项目的子目录。该目录配置表示要打包哪个目录下的文件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;includes/include*&lt;/td&gt;
&lt;td&gt;LICENCE.txt&lt;/td&gt;
&lt;td&gt;定义一组要包含的文件和目录。如果没有配置，表示所有target内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;excludes/exclude*&lt;/td&gt;
&lt;td&gt;**/.settings&lt;/td&gt;
&lt;td&gt;定义一组要排除的文件和目录。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;制作一个属于我们自己的打包程序&quot;&gt;制作一个属于我们自己的打包程序&lt;/h2&gt;
&lt;h3 id=&quot;需求&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;我们通过编写一个简单的代码，然后将代码打包成类似于Apache的软件包。代码非常简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HelloMaven {
    public static void main(String[] args) {
        System.out.println(&quot;Hello! Maven Assembly Plugin!&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一个配置文件，我们也需要打包：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;version=1.1.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206210951.png&quot; alt=&quot;image-20210206210951618&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;添加一个测试依赖&quot;&gt;添加一个测试依赖&lt;/h3&gt;
&lt;p&gt;在pom.xml中添加以下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;commons-cli&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;commons-cli&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一会我们会用shade插件，将该依赖直接打成uber-jar。&lt;/p&gt;
&lt;h3 id=&quot;配置shade插件&quot;&gt;配置shade插件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.1.1&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;!-- Run shade goal on package phase --&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;filters&amp;gt;
                    &amp;lt;filter&amp;gt;
                        &amp;lt;artifact&amp;gt;*:*&amp;lt;/artifact&amp;gt;
                        &amp;lt;excludes&amp;gt;
                            &amp;lt;exclude&amp;gt;META-INF/*.SF&amp;lt;/exclude&amp;gt;
                            &amp;lt;exclude&amp;gt;META-INF/*.DSA&amp;lt;/exclude&amp;gt;
                            &amp;lt;exclude&amp;gt;META-INF/*.RSA&amp;lt;/exclude&amp;gt;
                            &amp;lt;exclude&amp;gt;shell-scripts/*&amp;lt;/exclude&amp;gt;
                        &amp;lt;/excludes&amp;gt;
                    &amp;lt;/filter&amp;gt;
                &amp;lt;/filters&amp;gt;
                &amp;lt;transformers&amp;gt;
                    &amp;lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&amp;gt;
                        &amp;lt;mainClass&amp;gt;cn.monkey.HelloMaven&amp;lt;/mainClass&amp;gt;
                    &amp;lt;/transformer&amp;gt;
                &amp;lt;/transformers&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行package时，会先执行maven-jar-plugin。然后就会执行shade插件了。注意：因为我们一会要使用assembly打包，将shade打包的user-jar直接打进tar.gz。所以，shade要配置在assembly插件之前。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意配置mainClass，也就是JAR的运行主类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;配置assembly插件&quot;&gt;配置Assembly插件&lt;/h3&gt;
&lt;h4 id=&quot;配置maven-pomxml&quot;&gt;配置Maven pom.xml&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;inherited&amp;gt;false&amp;lt;/inherited&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;id&amp;gt;assembly-test&amp;lt;/id&amp;gt;
            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;appendAssemblyId&amp;gt;false&amp;lt;/appendAssemblyId&amp;gt;
                &amp;lt;attach&amp;gt;false&amp;lt;/attach&amp;gt;
                &amp;lt;finalName&amp;gt;${project.artifactId}-bin&amp;lt;/finalName&amp;gt;
                &amp;lt;outputDirectory&amp;gt;${project.build.directory}&amp;lt;/outputDirectory&amp;gt;
                &amp;lt;!-- Not using descriptorRef and hadoop-assembly dependency --&amp;gt;
                &amp;lt;!-- to avoid making hadoop-main to depend on a module      --&amp;gt;
                &amp;lt;descriptors&amp;gt;
                    &amp;lt;descriptor&amp;gt;test-assemblies/test-descriptor.xml&amp;lt;/descriptor&amp;gt;
                &amp;lt;/descriptors&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;finalName为最终打包的文件名，此处为artifactId加上bin后缀&lt;/li&gt;
&lt;li&gt;outputDirectory配置为Maven默认的输出目录，也就是一会打包完会自动在target目录生成tar.gz&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;配置assembly-descriptor&quot;&gt;配置assembly descriptor&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;assembly xmlns=&quot;http://maven.apache.org/ASSEMBLY/2.1.0&quot;
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
          xsi:schemaLocation=&quot;http://maven.apache.org/ASSEMBLY/2.1.0 http://maven.apache.org/xsd/assembly-2.1.0.xsd&quot;&amp;gt;
&amp;lt;id&amp;gt;assembly-test&amp;lt;/id&amp;gt;
&amp;lt;formats&amp;gt;
    &amp;lt;format&amp;gt;tar.gz&amp;lt;/format&amp;gt;
&amp;lt;/formats&amp;gt;
&amp;lt;fileSets&amp;gt;
    &amp;lt;fileSet&amp;gt;
        &amp;lt;directory&amp;gt;${project.build.directory}&amp;lt;/directory&amp;gt;
        &amp;lt;useDefaultExcludes&amp;gt;&amp;lt;/useDefaultExcludes&amp;gt;
        &amp;lt;outputDirectory&amp;gt;lib&amp;lt;/outputDirectory&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;*-shaded.jar&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
    &amp;lt;/fileSet&amp;gt;
    &amp;lt;fileSet&amp;gt;
        &amp;lt;directory&amp;gt;${project.build.directory}/classes&amp;lt;/directory&amp;gt;
        &amp;lt;outputDirectory&amp;gt;conf&amp;lt;/outputDirectory&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;**/config.properties&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
    &amp;lt;/fileSet&amp;gt;
    &amp;lt;fileSet&amp;gt;
        &amp;lt;directory&amp;gt;${project.build.directory}/classes/shell-scripts&amp;lt;/directory&amp;gt;
        &amp;lt;outputDirectory&amp;gt;bin&amp;lt;/outputDirectory&amp;gt;
        &amp;lt;fileMode&amp;gt;755&amp;lt;/fileMode&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;**/start.sh&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
    &amp;lt;/fileSet&amp;gt;
&amp;lt;/fileSets&amp;gt;
&amp;lt;/assembly&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们最终的文件以tar.gz方式打包&lt;/li&gt;
&lt;li&gt;第一个fileset为打包lib，我们最终的程序以jar包形式存放在tar.gz的lib文件夹中&lt;/li&gt;
&lt;li&gt;第二个fileset打包配置文件，这里直接打包config.properties&lt;/li&gt;
&lt;li&gt;第三个fileset打包运行的shell脚本，并且配置了755可执行权限&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建运行脚本&quot;&gt;创建运行脚本&lt;/h3&gt;
&lt;p&gt;在main目录中添加shell-scripts/start.sh，要执行程序直接执行start.sh即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#!/bin/bash
java -jar lib/${artifact.name}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置资源打包&quot;&gt;配置资源打包&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
        &amp;lt;/resource&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;targetPath&amp;gt;${project.build.outputDirectory}/shell-scripts&amp;lt;/targetPath&amp;gt;
            &amp;lt;directory&amp;gt;src/main/shell-scripts&amp;lt;/directory&amp;gt;
            &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
        &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
    ....
&amp;lt;/build&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们需要对shell-scriptrs下的脚本进行变量替换。&lt;/p&gt;
&lt;h3 id=&quot;配置profile&quot;&gt;配置profile&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;project&amp;gt;
        &amp;lt;profiles&amp;gt;
        &amp;lt;profile&amp;gt;
            &amp;lt;id&amp;gt;pro&amp;lt;/id&amp;gt;
            &amp;lt;properties&amp;gt;
                &amp;lt;artifact.name&amp;gt;${project.artifactId}-${project.version}-shaded.jar&amp;lt;/artifact.name&amp;gt;
            &amp;lt;/properties&amp;gt;
            &amp;lt;activation&amp;gt;
                &amp;lt;!-- 默认激活该profile --&amp;gt;
                &amp;lt;activeByDefault&amp;gt;true&amp;lt;/activeByDefault&amp;gt;
            &amp;lt;/activation&amp;gt;
        &amp;lt;/profile&amp;gt;
    &amp;lt;/profiles&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处配置默认的Profile为pro，当打包时会用artifact.name属性直接对shell-script中的脚本进行替换。&lt;/p&gt;
&lt;h3 id=&quot;执行打包&quot;&gt;执行打包&lt;/h3&gt;
&lt;p&gt;我把Maven的执行过程给大家解析一遍。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;# 注意此处自动指定了profile为pro

C:\opt\jdk1.8.0_241\bin\java.exe -Dmaven.multiModuleProjectDirectory=C:\Users\China\Desktop\assembly-test -Dmaven.multiModuleProjectDirectory=$MAVEN_HOME -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Dmaven.wagon.http.ssl.ignore.validity.dates=true -Dmaven.home=C:\Java\apache-maven-3.5.0 -Dclassworlds.conf=C:\Java\apache-maven-3.5.0\bin\m2.conf &quot;-Dmaven.ext.class.path=C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2020.3.2\plugins\maven\lib\maven-event-listener.jar&quot; &quot;-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2020.3.2\lib\idea_rt.jar=58840:C:\Program Files\JetBrains\IntelliJ IDEA Community Edition 2020.3.2\bin&quot; -Dfile.encoding=UTF-8 -classpath C:\Java\apache-maven-3.5.0\boot\plexus-classworlds-2.5.2.jar org.codehaus.classworlds.Launcher -Didea.version=2020.3.2 package -P pro
[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Building assembly-test 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 

# 拷贝resoource资源文件
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ assembly-test ---
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 1 resource
[INFO] Copying 1 resource to C:\Users\China\Desktop\assembly-test\target\classes/shell-scripts
[INFO] 

# 执行编译插件
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ assembly-test ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 

# 执行test资源拷贝，当前为空
[INFO] --- maven-resources-plugin:2.6:testResources (default-testResources) @ assembly-test ---
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] skip non existing resourceDirectory C:\Users\China\Desktop\assembly-test\src\test\resources
[INFO] 

# 执行编译测试用例代码
[INFO] --- maven-compiler-plugin:3.1:testCompile (default-testCompile) @ assembly-test ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 

# 执行单元测试
[INFO] --- maven-surefire-plugin:2.12.4:test (default-test) @ assembly-test ---
[INFO] No tests to run.
[INFO] 

# 执行Maven的默认jar打包
[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ assembly-test ---
[INFO] Building jar: C:\Users\China\Desktop\assembly-test\target\assembly-test-1.0-SNAPSHOT.jar
[INFO] 

# 执行shade插件打包
[INFO] --- maven-shade-plugin:3.1.1:shade (default) @ assembly-test ---
[INFO] Including commons-cli:commons-cli:jar:1.2 in the shaded jar.
[INFO] Replacing original artifact with shaded artifact.
[INFO] Replacing C:\Users\China\Desktop\assembly-test\target\assembly-test-1.0-SNAPSHOT.jar with C:\Users\China\Desktop\assembly-test\target\assembly-test-1.0-SNAPSHOT-shaded.jar
[INFO] Dependency-reduced POM written at: C:\Users\China\Desktop\assembly-test\dependency-reduced-pom.xml
[INFO] 

# 执行assembly插件打包
[INFO] --- maven-assembly-plugin:2.2-beta-5:single (assembly-test) @ assembly-test ---
[INFO] Reading assembly descriptor: test-assemblies/test-descriptor.xml
[INFO] Building tar : C:\Users\China\Desktop\assembly-test\target\assembly-test-bin.tar.gz
[WARNING] Assembly file: C:\Users\China\Desktop\assembly-test\target\assembly-test-bin.tar.gz is not a regular file (it may be a directory). It cannot be attached to the project build for installation or deployment.

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2.202 s
[INFO] Finished at: 2021-02-06T21:19:21+08:00
[INFO] Final Memory: 15M/491M
[INFO] ------------------------------------------------------------------------

Process finished with exit code 0

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是一目了然？&lt;/p&gt;
&lt;p&gt;一顿操作后，我们发现确实打包成了tar.gz了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206212226.png&quot; alt=&quot;image-20210206212226277&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用压缩软件打开看一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206212250.png&quot; alt=&quot;image-20210206212250495&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;全部都已经打包好了。而且shell脚本已经进行了变量替换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206212250.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;在linux上部署&quot;&gt;在Linux上部署&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 上传到Linux服务器
[root@compile assembly-test]# ll
总用量 40
-rw-r--r--. 1 root root 39611 2月   6 21:19 assembly-test-bin.tar.gz

# 解压
[root@compile assembly-test]# tar -xvzf assembly-test-bin.tar.gz 
assembly-test-bin/lib/assembly-test-1.0-SNAPSHOT-shaded.jar
assembly-test-bin/conf/config.properties
assembly-test-bin/bin/start.sh

# 执行
[root@compile assembly-test-bin]# pwd
/root/assembly-test/assembly-test-bin
[root@compile assembly-test-bin]# bin/start.sh 
Hello! Maven Assembly Plugin!
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很酷~这样的程序才是真正的、很正式的程序。&lt;/p&gt;
&lt;h3 id=&quot;打包源代码&quot;&gt;打包源代码&lt;/h3&gt;
&lt;p&gt;最后为了方便小伙伴们测试，我们把Maven项目的源码打包一份。还是使用assembly插件。&lt;/p&gt;
&lt;h4 id=&quot;在assembly中创建一个新的execution&quot;&gt;在Assembly中创建一个新的execution&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;execution&amp;gt;
    &amp;lt;id&amp;gt;test-source-descriptor&amp;lt;/id&amp;gt;
    &amp;lt;phase&amp;gt;compile&amp;lt;/phase&amp;gt;
    &amp;lt;goals&amp;gt;
        &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;
    &amp;lt;/goals&amp;gt;
    &amp;lt;configuration&amp;gt;
        &amp;lt;appendAssemblyId&amp;gt;false&amp;lt;/appendAssemblyId&amp;gt;
        &amp;lt;attach&amp;gt;false&amp;lt;/attach&amp;gt;
        &amp;lt;finalName&amp;gt;${project.artifactId}-source&amp;lt;/finalName&amp;gt;
        &amp;lt;outputDirectory&amp;gt;${project.build.directory}&amp;lt;/outputDirectory&amp;gt;
        &amp;lt;!-- Not using descriptorRef and hadoop-assembly dependency --&amp;gt;
        &amp;lt;!-- to avoid making hadoop-main to depend on a module      --&amp;gt;
        &amp;lt;descriptors&amp;gt;
            &amp;lt;descriptor&amp;gt;test-assemblies/test-source-descriptor.xml&amp;lt;/descriptor&amp;gt;
        &amp;lt;/descriptors&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/execution&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：我当前配置的phase为compile，也就是编译阶段就会打包好maven的源代码.&lt;/p&gt;
&lt;h4 id=&quot;为打包源码配置assembly-descriptor&quot;&gt;为打包源码配置assembly descriptor&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;assembly xmlns=&quot;http://maven.apache.org/ASSEMBLY/2.1.0&quot;
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
          xsi:schemaLocation=&quot;http://maven.apache.org/ASSEMBLY/2.1.0 http://maven.apache.org/xsd/assembly-2.1.0.xsd&quot;&amp;gt;
&amp;lt;id&amp;gt;test-source-descriptor&amp;lt;/id&amp;gt;
&amp;lt;formats&amp;gt;
    &amp;lt;format&amp;gt;zip&amp;lt;/format&amp;gt;
&amp;lt;/formats&amp;gt;
&amp;lt;fileSets&amp;gt;
    &amp;lt;fileSet&amp;gt;
        &amp;lt;directory&amp;gt;${project.basedir}&amp;lt;/directory&amp;gt;
        &amp;lt;useDefaultExcludes&amp;gt;&amp;lt;/useDefaultExcludes&amp;gt;
        &amp;lt;outputDirectory&amp;gt;.&amp;lt;/outputDirectory&amp;gt;
        &amp;lt;includes&amp;gt;
            &amp;lt;include&amp;gt;src/**/*&amp;lt;/include&amp;gt;
            &amp;lt;include&amp;gt;test-assemblies/**/*&amp;lt;/include&amp;gt;
            &amp;lt;include&amp;gt;pom.xml&amp;lt;/include&amp;gt;
        &amp;lt;/includes&amp;gt;
    &amp;lt;/fileSet&amp;gt;
&amp;lt;/fileSets&amp;gt;
&amp;lt;/assembly&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处j将src源码目录、test-assemblies下的所有文件、以及pom.xml一块打包给小伙伴。&lt;/p&gt;
&lt;h4 id=&quot;执行compile&quot;&gt;执行compile&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[INFO] Scanning for projects...
[INFO] 
[INFO] ------------------------------------------------------------------------
[INFO] Building assembly-test 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO] 
[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ assembly-test ---
[WARNING] File encoding has not been set, using platform encoding UTF-8, i.e. build is platform dependent!
[WARNING] Using platform encoding (UTF-8 actually) to copy filtered resources, i.e. build is platform dependent!
[INFO] Copying 1 resource
[INFO] Copying 1 resource to C:\Users\China\Desktop\assembly-test\target\classes/shell-scripts
[INFO] 
[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ assembly-test ---
[INFO] Nothing to compile - all classes are up to date
[INFO] 
[INFO] --- maven-assembly-plugin:2.2-beta-5:single (test-source-descriptor) @ assembly-test ---
[INFO] Reading assembly descriptor: test-assemblies/test-source-descriptor.xml
[INFO] Building zip: C:\Users\China\Desktop\assembly-test\target\assembly-test-source.zip
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 1.274 s
[INFO] Finished at: 2021-02-06T21:38:37+08:00
[INFO] Final Memory: 13M/491M
[INFO] ------------------------------------------------------------------------

Process finished with exit code 0

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家看到assembly插件已经执行，并将代码打包好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pick-bed2021.oss-cn-beijing.aliyuncs.com/img/2021Q1/20210206214137.png&quot; alt=&quot;image-20210206214137329&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家看到了，这才是我们做为一个开发应该玩的Maven。本次的案例代码在我公众号上回复：maven-plugin即可获取下载链接。大家自取之。&lt;/p&gt;
&lt;p&gt;我们下期再见！&lt;/p&gt;
&lt;p&gt;以上&lt;/p&gt;
&lt;p&gt;参考文献&lt;/p&gt;
&lt;blockquote readability=&quot;1.5567226890756&quot;&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://maven.apache.org/plugins/&quot; target=&quot;_blank&quot;&gt;https://maven.apache.org/plugins/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2] &lt;a href=&quot;https://github.com/apache/hadoop&quot; target=&quot;_blank&quot;&gt;https://github.com/apache/hadoop&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3] &lt;a href=&quot;https://maven.apache.org/guides/introduction/introduction-to-plugins.html&quot; target=&quot;_blank&quot;&gt;https://maven.apache.org/guides/introduction/introduction-to-plugins.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4] &lt;a href=&quot;https://github.com/apache/spark&quot; target=&quot;_blank&quot;&gt;https://github.com/apache/spark&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5] &lt;a href=&quot;https://stackoverflow.com/questions/11947037/what-is-an-uber-jar&quot; target=&quot;_blank&quot;&gt;https://stackoverflow.com/questions/11947037/what-is-an-uber-jar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6] &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html&quot; target=&quot;_blank&quot;&gt;https://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7] &lt;a href=&quot;https://maven.apache.org/plugins/maven-assembly-plugin/index.html&quot; target=&quot;_blank&quot;&gt;https://maven.apache.org/plugins/maven-assembly-plugin/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[8] &lt;a href=&quot;https://github.com/cko/predefined_maven_properties/blob/master/README.md&quot; target=&quot;_blank&quot;&gt;https://github.com/cko/predefined_maven_properties/blob/master/README.md&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 16 Feb 2021 09:35:00 +0000</pubDate>
<dc:creator>大数据君</dc:creator>
<og:description>打包是一项神圣、而庄严的工作。package意味着我们离生产已经非常近了。它会把我们之前的大量工作浓缩成为一个、或者多个文件。接下来，运维的同学就可以拿着这些个打包文件在生产上纵横四海了。 这么一项庄</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mr-bigdata/p/14407045.html</dc:identifier>
</item>
<item>
<title>线程池源码分析 - Createsequence</title>
<link>http://www.cnblogs.com/Createsequence/p/14406981.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Createsequence/p/14406981.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;在 java 中，线程池 ThreadPoolExecutor 是一个绕不过去的类，它是享元模式思想的体现，通过在容器中创建一定数量的线程加以重复利用，从而避免频繁创建线程带来的额外开销。一个设置合理的线程池可以提高任务响应的速度，并且避免线程数超过硬件能力带来的意外情况。&lt;/p&gt;
&lt;p&gt;在本文，将深入线程池源码，了解线程池的底层实现与运行机制。&lt;/p&gt;
&lt;h2 id=&quot;一、构造方法&quot;&gt;一、构造方法&lt;/h2&gt;
&lt;p&gt;ThreadPoolExecutor 类一共提供了四个构造方法，我们基于参数最完整构造方法了解一下线程池创建所需要的变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ThreadPoolExecutor(int corePoolSize, // 核心线程数
                          int maximumPoolSize, // 最大线程数
                          long keepAliveTime, // 非核心线程闲置存活时间
                          TimeUnit unit, // 时间单位
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, // 工作队列
                          ThreadFactory threadFactory, // 创建线程使用的线程工厂
                          RejectedExecutionHandler handler // 拒绝策略) {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;核心线程数：即长期存在的线程数，当线程池中运行线程未达到核心线程数时会优先创建新线程；&lt;/li&gt;
&lt;li&gt;最大线程数：当核心线程已满，工作队列已满，同时线程池中线程总数未超过最大线程数，会创建非核心线程；&lt;/li&gt;
&lt;li&gt;非核心线程闲置存活时间：当非核心线程闲置的时的最大存活时间；&lt;/li&gt;
&lt;li&gt;时间单位：非核心线程闲置存活时间的时间单位；&lt;/li&gt;
&lt;li&gt;任务队列：当核心线程满后，任务会优先加入工作队列，等等待核心线程消费；&lt;/li&gt;
&lt;li&gt;线程工厂：线程池创建新线程时使用的线程工厂；&lt;/li&gt;
&lt;li&gt;拒绝策略：当工作队列与线程池都满时，用于执行的策略；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、线程池状态&quot;&gt;二、线程池状态&lt;/h2&gt;
&lt;h3 id=&quot;1线程池状态&quot;&gt;1.线程池状态&lt;/h3&gt;
&lt;p&gt;线程池拥有一个 AtomicInteger 类型的成员变量 ctl ，通过位运算分别使用 ctl 的高位低位以便在一个值中存储线程数量以及线程池状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// 29（32-3）
private static final int COUNT_BITS = Integer.SIZE - 3;
// 允许的最大工作线程（2^29-1 约5亿）
private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;

// 运行状态。线程池接受并处理新任务
private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
// 关闭状态。线程池不能接受新任务，处理完剩余任务后关闭。调用shutdown()方法会进入该状态。
private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
// 停止状态。线程池不能接受新任务，并且尝试中断旧任务。调用shutdownNow()方法会进入该状态。
private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
// 整理状态。由关闭状态转变，线程池任务队列为空时进入该状态，会调用terminated()方法。
private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
// 终止状态。terminated()方法执行完毕后进入该状态，线程池彻底停止。
private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2线程状态的计算&quot;&gt;2.线程状态的计算&lt;/h3&gt;
&lt;p&gt;这里比较不好理解的是上述-1的位运算，下面我们来分析一下：&lt;/p&gt;
&lt;p&gt;在计算机中，二进制负数一般用补码表示，即源码取反再加一。但又有这种说法，即将最高位作为符号位，0为正数，1为负数。实际上两者是可以结合在一起看的。假如数字是单字节数，1 字节对应8 bit，即八位，现在，我们要计算 - 1。&lt;/p&gt;
&lt;p&gt;按照第二种说法，最高位为符号位，则有 1/000 0001，然后按第一种说法取反后+1，并且符号位不变，则有 1/111 1110 + 1，即 1/111 1111。&lt;/p&gt;
&lt;p&gt;现在回到 &lt;code&gt;-1 &amp;lt;&amp;lt; COUNT_BITS&lt;/code&gt;这行代码：&lt;/p&gt;
&lt;p&gt;一个 int 是 4 个字节，对应 32 bit，按上述过程 -1 转为二进制即为 1/111......1111（32个1）， &lt;code&gt;COUNT_BITS&lt;/code&gt;是 29，-1 左移 29 位，最终得到 111.0...0000。&lt;/p&gt;
&lt;p&gt;同理，计算其他的几种状态，可知分别是：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;二进制&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;RUNNING&lt;/td&gt;
&lt;td&gt;111...0....00&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SHUTDOWN&lt;/td&gt;
&lt;td&gt;000...0....00&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;STOP&lt;/td&gt;
&lt;td&gt;001...0....00&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIDYING&lt;/td&gt;
&lt;td&gt;010...0....00&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TERMINATED&lt;/td&gt;
&lt;td&gt;011...0....00&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中，&lt;strong&gt;我们可以知道 SHUTDOWN 状态转为十进制也是 0 ，而 RUNNING 作为有符号数，它的最高位是 1，说明转为十进制以后是个负数，其他的状态最高位都是 0，转为十进制之后都是正数&lt;/strong&gt;，也就是说，我们可以这么认为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小于 SHUTDOWN 的就是 RUNNING，大于 SHUTDOWN 就是停止或者停止中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这也是后面状态计算的一些写法的基础。比如 &lt;code&gt;isRunning()&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static boolean isRunning(int c) {
    return c &amp;lt; SHUTDOWN;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3线程状态与工作线程数的获取&quot;&gt;3.线程状态与工作线程数的获取&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 根据当前运行状态和工作线程数获取当前的 ctl
private static int ctlOf(int rs, int wc) { return rs | wc; }
// 获取运行状态
private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
// 获取工作线程数
private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面获取状态的时候调用了 &lt;code&gt;ctlOf()&lt;/code&gt;方法，根据前面，我们可以知道，&lt;code&gt;CAPACITY&lt;/code&gt;实际上是 29 位，而线程状态用的是 32 - 30 共 3 位，也就是说，&lt;strong&gt;ctl 共 32 位，高3 位用于表示线程池状态，而低 29 位表示工作线程的数量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样上述三个方法就很好理解了：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ctlOf()&lt;/code&gt;：获取 ctl。&lt;/p&gt;
&lt;p&gt;将工作线程数量与运行状态进行于运算，假如我们处于 RUNNING，并且有 1 个工作线程，那么 ctl = 111....000 | 000.... 001，最终得到 111 ..... 001；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;runStateOf()&lt;/code&gt;：获取运行状态。&lt;/p&gt;
&lt;p&gt;继续根据上文的数据，&lt;code&gt;~CAPACITY&lt;/code&gt; 取反即为 111....000，与运行状态 111...0000 与运算，最终得到 111....000，相当于低位掩码，消去低 29 位；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;workerCountOf()&lt;/code&gt;：获取工作线程数。&lt;/p&gt;
&lt;p&gt;同理，&lt;code&gt;c &amp;amp; CAPACITY&lt;/code&gt;里的 CAPACITY 相当于高位掩码，用于消去高 3 位，最终得到 00...001，即工作线程数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同理，&lt;strong&gt;如果要增加工作线程数，就直接通过 CAS 去递增 ctl&lt;/strong&gt;，比如新建线程中使用的公共方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private boolean compareAndIncrementWorkerCount(int expect) {
    // 通过 CAS 递增 ctl
    return ctl.compareAndSet(expect, expect + 1);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;要改变线程池状态，就根据当前工作线程和要改变的状态去合成新的 ctl，然后 CAS 改变 ctl&lt;/strong&gt;，比如 &lt;code&gt;shutdown()&lt;/code&gt;中涉及的相关代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void advanceRunState(int targetState) {
        for (;;) {
            int c = ctl.get();
            if (runStateAtLeast(c, targetState) ||       
                        // 通过 CAS 改变 ctl
                ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))
                break;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、任务的创建与执行&quot;&gt;三、任务的创建与执行&lt;/h2&gt;
&lt;p&gt;线程池任务提交方法是 &lt;code&gt;execute()&lt;/code&gt;，根据代码可知，当一个任务进来时，分四种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前工作线程数小于核心线程数，启动新线程；&lt;/li&gt;
&lt;li&gt;当前工作线程数大于核心线程数，但是未大于最大线程数，尝试添加到工作队列；&lt;/li&gt;
&lt;li&gt;当前线程池核心线程和队列都满了，尝试创建新非核心线程。&lt;/li&gt;
&lt;li&gt;非核心线程创建失败，说明线程池彻底满了，执行拒绝策略。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();
    
    // 1.当前工作线程数小于核心线程数，启动新线程
    if (workerCountOf(c) &amp;lt; corePoolSize) {
        // 添加任务
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    
    // 2. 当前工作线程数大于核心线程数，但是未大于最大线程数，尝试添加到工作队列
    if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        // 如果当前线程处于非运行态，并且移除当前任务成功，则拒绝任务（防止添加到一半就shutdown）
        if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command)) 
            reject(command);
        // 如果当前没有工作线程了，就启动新线程
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    
    // 3.当前线程池核心线程和队列都满了，尝试创建新非核心线程
    else if (!addWorker(command, false))
        // 4.线程池彻底满了，执行拒绝策略
        reject(command);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1添加任务&quot;&gt;1.添加任务&lt;/h3&gt;
&lt;p&gt;添加任务依靠 &lt;code&gt;addWorker()&lt;/code&gt;方法，这个方法很长，但是主要就干了两件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CAS 让 ctl 的工作线程数 +1；&lt;/li&gt;
&lt;li&gt;启动新的线程；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    // 1.改变 ctl 使工作线程+1
    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // 如果当前不处于运行状态，传入任务为空，并且任务队列为空的时候拒绝添加新任务
        // 即线程池 shutdown 时不让添加新任务，但是运行继续跑完任务队列里的任务。
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp;
            ! (rs == SHUTDOWN &amp;amp;&amp;amp;
               firstTask == null &amp;amp;&amp;amp;
               ! workQueue.isEmpty()))
            return false;

        for (;;) {
            int wc = workerCountOf(c);
            // 线程不允许超过最大线程数，核心线程不允许超过最大核心线程数
            if (wc &amp;gt;= CAPACITY ||
                wc &amp;gt;= (core ? corePoolSize : maximumPoolSize))
                return false;
            // CAS 递增工作线程数
            if (compareAndIncrementWorkerCount(c))
                // 失败了就重新回到上面的retry处继续往下执行
                break retry;
            // 更新 ctl
            c = ctl.get();
            // 如果运行状态改变了就全部从来
            if (runStateOf(c) != rs)
                continue retry;
        }
    }

    // 2.启动新线程
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 创建新线程
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            // 加锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                int rs = runStateOf(ctl.get());
                           
                // 如果线程池处于运行状态，或者没有新任务的SHUTDOWN状态（即SHUTDOW以后还在消费工作队列里的任务） 
                if (rs &amp;lt; SHUTDOWN ||
                    (rs == SHUTDOWN &amp;amp;&amp;amp; firstTask == null)) {
                    // 线程是否在未启动前就已经启动了
                    if (t.isAlive()) // precheck that t is startable
                        throw new IllegalThreadStateException();
                    workers.add(w);
                    int s = workers.size();
                     // 如果集合中的工作线程数大于最大线程数，则将池中最大线程数改为当前工作线程数
                    if (s &amp;gt; largestPoolSize)
                        largestPoolSize = s;
                    // 线程创建完成
                    workerAdded = true;
                }
            } finally {
                mainLock.unlock();
            }
            // 如果线程成功创建，就启动线程，并且更改启动状态为成功
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        // 如果线程启动不成功，就执行失败策略
        if (! workerStarted)
            // 启动失败策略，从当前工作线程队列移除当前启动失败的线程，递减工作线程数，然后尝试关闭线程池（如果当前任务就是线程池最后一个任务）
            addWorkerFailed(w);
    }
    return workerStarted;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-任务对象worker&quot;&gt;2. 任务对象Worker&lt;/h3&gt;
&lt;p&gt;根据上文，不难发现，在线程池中线程往往以 Worker 对象的方式存在，那么这个 Worker 又是何方神圣？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {

        // 工作线程
        final Thread thread;
    
        // 要执行的任务
        Runnable firstTask;
    
        // 线程执行过的任务数
        volatile long completedTasks;

        // 通过线程工厂创建工作线程
        Worker(Runnable firstTask) {
            setState(-1);
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }

        // 执行任务
        public void run() {
            runWorker(this);
        }
    
        ... ...
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 Worker 类继承了 AQS，也就是说，他本身就相当于一个同步队列，结合他的成员变量 thread 和 firstTask，可以知道他实际上就是我们线程池中所说的“线程”。除了父类 AQS 本身提供的独占锁以外，Worker 还提供了一些检查任务线程运行状态以及中断线程相关的方法。&lt;/p&gt;
&lt;p&gt;此外，线程池中还有一个&lt;strong&gt;工作队列 workers，用于保存当前全部的 Worker&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;Worker&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3任务的启动&quot;&gt;3.任务的启动&lt;/h3&gt;
&lt;p&gt;当调用 &lt;code&gt;Worker.run()&lt;/code&gt;的时候，其实调用的是 &lt;code&gt;runWorker()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;runWorker()&lt;/code&gt;方法实际上就是调用线程执行任务的方法，他的逻辑大题是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拿到入参的新 Worker，一直循环获取 Worker 里的任务；&lt;/li&gt;
&lt;li&gt;加锁然后执行任务；&lt;/li&gt;
&lt;li&gt;如果执行完任务流程，并且没有发生异常导致 Worker 挂掉，就直接复用 Worker(在获取任务的方法 &lt;code&gt;getTask()&lt;/code&gt;中循环等待任务)；&lt;/li&gt;
&lt;li&gt;如果执行完任务流程后发现&lt;strong&gt;发生异常&lt;/strong&gt;导致 Worker 挂掉，就从工作队列中移除当前 Worker，并且补充一个新的；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果整个流程执行完毕，就删除当前的 Worker。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); // 新创建的Worker默认state为-1，AQS的unlock方法会将其改为0，此后允许使用interruptIfStarted()方法进行中断
    
    // 完成任务以后是否需要移除当前Worker，即当前任务是否意外退出
    boolean completedAbruptly = true;
    
    try {
        // 循环获取任务
        while (task != null || (task = getTask()) != null) {
            // 加锁，防止 shundown 时中断正在运行的任务
            w.lock();
            // 如果线程池状态为 STOP 或更后面的状态，中断线程任务
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;amp;&amp;amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                // 钩子方法，默认空实现，需要自己提供
                beforeExecute(wt, task);
                Throwable thrown = null;
                try {
                    // 执行任务
                    task.run();
                } catch (RuntimeException x) {
                    thrown = x; throw x;
                } catch (Error x) {
                    thrown = x; throw x;
                } catch (Throwable x) {
                    thrown = x; throw new Error(x);
                } finally {
                    // 钩子方法
                    afterExecute(task, thrown);
                }
            } finally {
                task = null;
                // 任务执行完毕
                w.completedTasks++;
                w.unlock();
            }
        }
        
        completedAbruptly = false;
    } finally {
        // 根据completedAbruptly决定是否要移除意外退出的Worker，并补充新的Worker
        // 也就是说，如果上述过程顺利完成，工作线程没有挂掉，就不删除，下次继续用，否则就干掉它再补充一个。
        processWorkerExit(w, completedAbruptly);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4任务的获取与超时处理&quot;&gt;4.任务的获取与超时处理&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;runWorker()&lt;/code&gt;方法中，通过 &lt;code&gt;getTask()&lt;/code&gt;方法去获取任务。值得注意的是，超时处理也在此处，简单的来说，整套流程是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;判断线程池是否关闭，工作队列是否为空，如果是说明没任务了，直接返回null，否则接着往下判断；&lt;/li&gt;
&lt;li&gt;判断当前是否存在非核心线程，如果是说明需要进行超时处理；&lt;/li&gt;
&lt;li&gt;获取任务，如果不需要超时处理，则直接从任务队列获取任务，否则根据 keepaliveTime 阻塞一段时间后获取任务，如果获取不到，说明非核心线程超时，返回 null 交给 &lt;code&gt;runWorker()&lt;/code&gt;中的&lt;code&gt;processWorkerExit()&lt;/code&gt;方法去删除；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;换句话说，&lt;code&gt;runWorker()&lt;/code&gt;方法一旦执行完毕，必然会删除当前的 Worker，而通过 &lt;code&gt;getTask()&lt;/code&gt;拿任务的 Worker，在线程池正常运行的状态下，&lt;strong&gt;核心线程只会一直在 for 循环中等待直到拿到任务&lt;/strong&gt;，而非核心线程超时以后拿不到任务就会返回一个 null，然后回到 &lt;code&gt;runWorker()&lt;/code&gt;中走完&lt;code&gt;processWorkerExit()&lt;/code&gt;方法被删除。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        // 如果线程池关闭了，并且工作队列里的任务都完成了，或者线程池直接进入了 STOP 或更进一步的状态，就不返回新任务
        if (rs &amp;gt;= SHUTDOWN &amp;amp;&amp;amp; (rs &amp;gt;= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        // 获取当前工作线程
        int wc = workerCountOf(c);

        // 核心线程是否超时（默认false）或当前是否存在非核心线程，即判断当前当前是否需要进行超时控制
        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;

        // 判断线程是否超过最大线程数或存在非核心线程
        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
            // 并且除非任务队列为空，否则池中最少有一个线程
            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            // 获取任务
            Runnable r = timed ?
                // 阻塞 keepaliveTime 以获取任务，如果在 keepaliveTime 时间内没有获取到任务，则返回 null.
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            // 如果获取不到任务，说明非核心线程超时了，下一轮判断确认是否退出循环。
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、线程池的中断&quot;&gt;四、线程池的中断&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiajibagao.top/image-20210211171605477.png&quot; alt=&quot;image-20210211171605477&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程池的中断方法分为三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;shutdown()&lt;/code&gt;：中断线程池，不再添加新任务，同时&lt;strong&gt;等待当前进行和队列中的任务完成&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shutdownNow()&lt;/code&gt;：立即中断线程池，不再添加新任务，&lt;strong&gt;同时中断所有工作中的任务，不再处理任务队列中任务&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;1shutdown&quot;&gt;1.shutdown&lt;/h3&gt;
&lt;p&gt;shutdown 是有序关闭。主要干了三件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;改变当前线程池状态为 SHUTDOWN；&lt;/li&gt;
&lt;li&gt;将当前工作队列中的全部线程标记为中断；&lt;/li&gt;
&lt;li&gt;完成上述过程后将线程池状态改为 TIDYING&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    // 加锁
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 改变当前线程池状态
        advanceRunState(SHUTDOWN);
        // 中断当前线程
        interruptIdleWorkers();
        // 钩子函数，默认空实现
        onShutdown(); // hook for ScheduledThreadPoolExecutor
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;interruptIdleWorkers()&lt;/code&gt;方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void interruptIdleWorkers(boolean onlyOne) {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 遍历工作队列中的全部 Worker
        for (Worker w : workers) {
            Thread t = w.thread;
            if (!t.isInterrupted() &amp;amp;&amp;amp; w.tryLock()) {
                try {
                    // 标记为中断
                    t.interrupt();
                } catch (SecurityException ignore) {
                } finally {
                    w.unlock();
                }
            }
            if (onlyOne)
                break;
        }
    } finally {
        mainLock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2shutdownnow&quot;&gt;2.shutdownNow&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;shutdownNow()&lt;/code&gt; 与 &lt;code&gt;shutdown()&lt;/code&gt;流程类似，但是会直接将状态转为 STOP，在 &lt;code&gt;addWorker()&lt;/code&gt; 或者&lt;code&gt;getTask()&lt;/code&gt;等处理任务的相关方法里，&lt;strong&gt;会针对 STOP 或更进一步的状态做区分，将不会再处理任务队列中的任务&lt;/strong&gt;，配合&lt;code&gt;drainQueue()&lt;/code&gt;方法以删除任务队列中的任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public List&amp;lt;Runnable&amp;gt; shutdownNow() {
    List&amp;lt;Runnable&amp;gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 改变当前线程池状态
        advanceRunState(STOP);
        // 中断当前线程
        interruptWorkers();
        // 删除任务队列中的任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五、拒绝策略&quot;&gt;五、拒绝策略&lt;/h2&gt;
&lt;p&gt;当任务队列已满，并且线程池中线程也到达最大线程数的时候，就会调用拒绝策略。也就是&lt;code&gt;reject()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void reject(Runnable command) {
    handler.rejectedExecution(command, this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;拒绝策略共分四种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AbortPolicy：拒绝策略，直接抛出异常，默认策略；&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：调用者运行策略，用调用者所在的线程来执行任务；&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy：弃老策略，无声无息的丢弃阻塞队列中靠最前的任务，并执行当前任务；&lt;/li&gt;
&lt;li&gt;DiscardPolicy：丢弃策略，直接无声无息的丢弃任务；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以简单的了解一下他们的实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AbortPolicy&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +
                                     &quot; rejected from &quot; +
                                     e.toString());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;CallerRunsPolicy&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
        r.run();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DiscardOldestPolicy&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    if (!e.isShutdown()) {
        // 弹出队头元素
        e.getQueue().poll();
        e.execute(r);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;DiscardPolicy&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        // Does nothing
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六、线程池的钩子函数&quot;&gt;六、线程池的钩子函数&lt;/h2&gt;
&lt;p&gt;和 HashMap 与 LinkedHashMap 中的行为有点类似，在线程池的代码中，有些方法调用了一些具有空实现的方法，这些方法是提供给用户去继承并重写的钩子函数，主要包括三个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;beforeExecute()&lt;/code&gt;：在执行任务之前回调&lt;/li&gt;
&lt;li&gt;&lt;code&gt;afterExecute()&lt;/code&gt;：在任务执行完后回调&lt;/li&gt;
&lt;li&gt;&lt;code&gt;terminated()&lt;/code&gt;：在线程池中的所有任务执行完毕后回调&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过继承 ThreadPoolExecutor 类，并重写以上三个方法，我们可以进行监控或者输出日志，更方便的了解线程池的状态。&lt;/p&gt;
&lt;p&gt;值得一提的是，&lt;code&gt;afterExecute()&lt;/code&gt;方法的入参类型是&lt;code&gt;（Runnable r, Throwable t）&lt;/code&gt;，也就是说，如果线程运行中抛出异常，我们也可以通过该方法去捕获异常并作出相应的处理。&lt;/p&gt;
&lt;h2 id=&quot;七、总结&quot;&gt;七、总结&lt;/h2&gt;
&lt;p&gt;线程池提供了四个构造方法，参数最全的构造方法参数按顺序有：核心线程数，最大线程数，非核心线程闲置存活时间，存活时间单位，任务队列，线程工厂，拒绝策略。&lt;/p&gt;
&lt;p&gt;线程池共有五种状态，分别是：RUNNING，SHUTDOWN，STOP，TYDYING，TERMINATED，它们与工作线程数量一同记录在成员变量 ctl 中，其中高 3 位用于记录状态，低 29 位用于记录工作线程数，实际使用中通过位运算去获取。&lt;/p&gt;
&lt;p&gt;线程池中任务线程以继承了 AQS 的 Worker 类的实例形式存在。当添加任务时，会有四种情况：核心线程不满，优先创建核心线程；核心线程满，优先添加任务队列；核心线程与队列都满，创建非核心线程；线程和队列都满，则执行拒绝策略。&lt;/p&gt;
&lt;p&gt;其中，拒绝策略分为四类，默认的拒绝策略 AbortPolicy；调用者运行策略 CallerRunsPolicy；弃老策略 DiscardOldestPolicy；丢弃策略 DiscardPolicy。&lt;/p&gt;
&lt;p&gt;线程池的中断有两个方法：&lt;code&gt;shutdown()&lt;/code&gt;与 &lt;code&gt;shutdownNow()&lt;/code&gt;，两者都会让线程池不再接受新任务，但是 &lt;code&gt;shutdown()&lt;/code&gt;会等待当前与任务队列中的任务执行完毕，而 &lt;code&gt;shutdownNow()&lt;/code&gt;会直接中断当前任务，忽略并删除任务队列中的任务。&lt;/p&gt;
&lt;p&gt;线程池提供了&lt;code&gt;beforeExecute()&lt;/code&gt;，&lt;code&gt;afterExecute()&lt;/code&gt;，&lt;code&gt;terminated()&lt;/code&gt;三个钩子函数，其中，&lt;code&gt;afterExecute()&lt;/code&gt;的入参含有抛出的异常，因此可以借由该方法处理线程池中线程抛出的异常。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Feb 2021 09:05:00 +0000</pubDate>
<dc:creator>Createsequence</dc:creator>
<og:description>概述 在 java 中，线程池 ThreadPoolExecutor 是一个绕不过去的类，它是享元模式思想的体现，通过在容器中创建一定数量的线程加以重复利用，从而避免频繁创建线程带来的额外开销。一个设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Createsequence/p/14406981.html</dc:identifier>
</item>
</channel>
</rss>