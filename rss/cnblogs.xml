<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>poj-2232 New Stone-Forfex-Cloth Game 思维题 - Caution_X</title>
<link>http://www.cnblogs.com/cautx/p/11616742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cautx/p/11616742.html</guid>
<description>&lt;div id=&quot;description-container&quot; class=&quot;container&quot; readability=&quot;28.5&quot;&gt;
&lt;div class=&quot;ptx&quot; lang=&quot;en-US&quot; readability=&quot;22&quot;&gt;Acm is a clever boy, and he developed a new game form the old Stone-Forfex-Cloth game.&lt;p&gt;In this game, a number of children sit in a circle, each one shows a gesture (one of the Stone, the Forfex and the Cloth), which can't be changed in the whole game. Then a randomly chosen child (we call him player A) compares his gesture with the one on his anticlockwise (we call him play B) direction. And the loser should jump out of the circle. This operation continues until there is only one child left, which is the winner. Of course the winner is decided by both the gestures the children show and the order to compare. Your task is to tell the total number of possible winners.&lt;/p&gt;&lt;p&gt;The game obeys the following rulers:&lt;br/&gt;1. Forfex beat Cloth.&lt;br/&gt;2. Cloth beat Stone.&lt;br/&gt;3. Stone beat Forfex.&lt;br/&gt;4. If it is a draw, play A wins.&lt;br/&gt;&lt;/p&gt;&lt;/div&gt;
Input
&lt;p&gt;The input contains several test cases. In each case, the first line contains an integer N (the number of children, 1 &amp;lt;= N &amp;lt;= 1000), and the second line contains N capitals including 'S', 'F' and 'C, which are separated by a single space and represent the gestures of N children in clockwise order. Here 'S' expresses the Stone, 'F' expresses the Forfex, and 'C' expresses the Cloth.&lt;/p&gt;
Output
&lt;p&gt;For each case, output the total number of possible winners in a single line.&lt;/p&gt;
Sample Input
&lt;pre class=&quot;sio&quot;&gt;
3
C S F
2
S C
4
S S S S
&lt;/pre&gt;
Sample Output
&lt;pre class=&quot;sio&quot;&gt;
3
1
4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;poj-2232;Caution_X;20191002;规律;-&lt;br/&gt;description modelling：n个人围成一圈玩石头剪刀布，任选一人开始，逆时再任选一人玩石头剪刀布，输的人出圈，问最后留下的人有多少种情况;-&lt;br/&gt;major steps to solve it：;-&lt;br/&gt;考虑三种情况：;-&lt;br/&gt;（1）所有人只出一个手势，那么任意一个人都有可能留下，答案为n;-&lt;br/&gt;（2）所有人只出两种手势，虽然对手是任意挑选的，但是赢的人的手势是确定的，所以留下的人只能是出了能赢手势的人，此时答案为出了赢得手势的人的人数;-&lt;br/&gt;（3）三种手势都有，显然任意一种手势，只要合理安排对手就一定能赢，所以此时答案还是n;-&lt;br/&gt;warnings：A挑了B当对手，两人出相同手势，A赢;.&lt;/p&gt;
&lt;p&gt;AC CODE:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
#include&amp;lt;iostream&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;cstdio&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;&lt;span&gt;set&lt;/span&gt;&amp;gt;&lt;span&gt;
#include&lt;/span&gt;&amp;lt;map&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;char&lt;/span&gt; a[&lt;span&gt;1010&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&amp;lt;&lt;span&gt;char&lt;/span&gt;&amp;gt;&lt;span&gt; book;
map&lt;/span&gt;&amp;lt;&lt;span&gt;char&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;freopen(&quot;input.txt&quot;,&quot;r&quot;,stdin);&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(~scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;n)){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cnt=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;){
            cin&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;a[i];
            list[a[i]]&lt;/span&gt;++&lt;span&gt;;
            book.insert(a[i]);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(book.size()==&lt;span&gt;1&lt;/span&gt;||book.size()==&lt;span&gt;3&lt;/span&gt;)    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,n);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(book.size()==&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)    {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(list[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]!=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;list[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]!=&lt;span&gt;0&lt;/span&gt;)    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,list[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(list[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]!=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;list[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]!=&lt;span&gt;0&lt;/span&gt;)    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,list[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(list[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]!=&lt;span&gt;0&lt;/span&gt;&amp;amp;&amp;amp;list[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]!=&lt;span&gt;0&lt;/span&gt;)    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,list[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]);
        }
        list.clear();
        book.clear();
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 02 Oct 2019 00:16:00 +0000</pubDate>
<dc:creator>Caution_X</dc:creator>
<og:description>Acm is a clever boy, and he developed a new game form the old Stone-Forfex-Cloth game. In this game,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cautx/p/11616742.html</dc:identifier>
</item>
<item>
<title>为什么要将局部变量的作用域最小化？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11616726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11616726.html</guid>
<description>&lt;p&gt;嗨，本篇文章来说说 Java 的一个小细节：为什么要将局部变量的作用域最小化？&lt;/p&gt;
&lt;p&gt;明人不说暗话啊。这篇文章的灵感来源于《Effective Java》，这本书我买了有好长好长一段时间了，书页都已经泛黄，烙下了时间的痕迹，但我仍然还没有把这本书读完。说来惭愧啊。&lt;/p&gt;
&lt;p&gt;为什么呢？总感觉这本书的中文翻译有点拙劣，读起来烦闷枯燥。明明感觉作者说得非常有道理，但就是提不起半点兴致。&lt;/p&gt;
&lt;p&gt;（说完这句话，总觉得有点对不住这本书的译者，毕竟吐槽容易，分享难啊。）&lt;/p&gt;
&lt;p&gt;为什么要说这些废话呢，因为怕大家觉得这是不值一提的细节，但往往细节决定成败啊。大家不妨换一种比较轻松的心态来读一读。反正我是不怎么喜欢高谈阔论的文章，读完后往往只能感慨一句：“说得不错啊”，但也仅此而已。&lt;/p&gt;
&lt;p&gt;好了，来步入正题。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;String [] strs = {&lt;span class=&quot;hljs-string&quot;&gt;&quot;洛阳&quot;,&lt;span class=&quot;hljs-string&quot; readability=&quot;3&quot;&gt;&quot;牡丹&quot;,&lt;span class=&quot;hljs-string&quot; readability=&quot;6&quot;&gt;&quot;甲天下&quot;};&lt;br/&gt;List&amp;lt;String&amp;gt; list = Arrays.asList(strs);&lt;p&gt;Iterator&amp;lt;String&amp;gt; iterator = list.iterator();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while (iterator.hasNext()) {&lt;br/&gt;String s = (String) iterator.next();&lt;br/&gt;System.out.println(s);&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;list.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;);&lt;br/&gt;Iterator&amp;lt;String&amp;gt; iterator1 = list.iterator();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while (iterator.hasNext()) {&lt;br/&gt;String s = (String) iterator1.next();&lt;br/&gt;System.out.println(s);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家用“肉眼”看完上面这段代码后，会觉得有问题吗？&lt;/p&gt;
&lt;p&gt;如果不细心的话，好像真的很难发现“复制-粘贴”引发的这个问题：第二个 while 循环的条件中使用了之前的变量 iterator，而不是它应该使用的 iterator1（粘贴后遗漏了变量的修改）。这个问题将会导致代码在运行的时候抛出 &lt;code&gt;java.lang.UnsupportedOperationException&lt;/code&gt; 的错误。&lt;/p&gt;
&lt;p&gt;说句实在话，在敲代码的这十年来，没少复制粘贴，没少因为粘贴后变量没有修改彻底，而导致出现了各种意料之外的 bug。&lt;/p&gt;
&lt;p&gt;假如把变量的作用域最小化的话，还真的能够减少这种因为“复制-粘贴”而导致出现的错误。比如说把 while 循环改造成 for 循环。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;1.5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;3&quot;&gt;for (Iterator&amp;lt;String&amp;gt; iterator = list.iterator();iterator.hasNext();) {&lt;br/&gt;String s = (String) iterator.next();&lt;br/&gt;System.out.println(s);&lt;br/&gt;}&lt;p&gt;list.add(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (Iterator&amp;lt;String&amp;gt; iterator = list.iterator();iterator.hasNext();) {&lt;br/&gt;String s = (String) iterator.next();&lt;br/&gt;System.out.println(s);&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个 for 循环使用了和第一个 for 循环一模一样的代码，连 iterator 这个变量也不需要修改了。&lt;/p&gt;
&lt;p&gt;从另一方面来看的话，for 循环比 while 循环更简短，可读性更好。for 循环还有另外一种最常用的写法，示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; list.size(); i++) {&lt;br/&gt;System.out.println(list.get(i));&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这种写法仍有改进的地方，因为从字节码的角度来看，每次循环都要调用一次 &lt;code&gt;size()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;2: iload_1&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;3: aload_0&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;4: getfield      #4                  // Field list:Ljava/util/List;&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;7: invokeinterface #5,  1            // InterfaceMethod java/util/List.size:()I&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;12: if_icmpge     40&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;15: getstatic     #6                  // Field java/lang/System.out:Ljava/io/PrintStream;&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;18: aload_0&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;19: getfield      #4                  // Field list:Ljava/util/List;&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;22: iload_1&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;23: invokeinterface #7,  2            // InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;28: checkcast     #8                  // class java/lang/String&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;31: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;34: iinc          1, 1&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;37: goto          2&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;40: return&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;size()&lt;/code&gt; 方法虽然简短，但也有消耗啊。都有什么消耗呢？说几个专业名词大家感受一下，比如说：创建栈帧、调用方法时保护现场、调用方法完毕后恢复现场。&lt;/p&gt;
&lt;p&gt;（容许我尴尬一下，在写这篇文章之前，我一直用的上面这种 for 循环格式。看来写文章还是能够督促自己进步啊。）&lt;/p&gt;
&lt;p&gt;怎么改进呢，看下面这种写法（强烈推荐啊）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0, n = list.size(); i &amp;lt; n; i++) {&lt;br/&gt;System.out.println(list.get(i));&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 for 循环内部声明两个变量：i 和 n，n 用来保存 i 的极限值，这样就减少了 &lt;code&gt;size()&lt;/code&gt; 方法的调用次数（仅有一次了）。&lt;/p&gt;
&lt;p&gt;再来看一段代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;String pre_name = &lt;span class=&quot;hljs-string&quot; readability=&quot;1&quot;&gt;&quot;沉默&quot;;&lt;br/&gt;String last_name = &lt;span class=&quot;hljs-string&quot; readability=&quot;2&quot;&gt;&quot;王二&quot;;&lt;p&gt;System.out.println(pre_name);&lt;br/&gt;System.out.println(last_name);&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码看起来挺规整的，没什么问题，对吧？它没有遵守约定——将局部变量的作用域最小化。&lt;/p&gt;
&lt;p&gt;pre_name 变量的作用域结束的有点晚；last_name 变量的作用域开始的有点早。假如第一个 &lt;code&gt;System.out.println()&lt;/code&gt; 出错的话，last_name 的声明就变得毫无意义了。&lt;/p&gt;
&lt;p&gt;（这只是一个例子，变量的处理方法可能比 &lt;code&gt;System.out.println()&lt;/code&gt; 复杂得多。）&lt;/p&gt;
&lt;p&gt;好的写法应该是下面这样子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;1&quot;&gt;String pre_name = &lt;span class=&quot;hljs-string&quot; readability=&quot;2&quot;&gt;&quot;沉默&quot;;&lt;br/&gt;System.out.println(pre_name);&lt;p&gt;String last_name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;王二&quot;;&lt;br/&gt;System.out.println(last_name);&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有人可能觉得这不是在吹毛求疵吗？真不是的，&lt;strong&gt;变量就应该是在第一次使用它的时候声明&lt;/strong&gt;。否则的话，变量的作用域要么开始的太早，要么结束的太晚。&lt;/p&gt;
&lt;p&gt;好了，这篇文章到此就结束了，非常的简短，但讲清楚了“为什么要将局部变量的作用域最小化”。&lt;/p&gt;

</description>
<pubDate>Tue, 01 Oct 2019 23:57:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>嗨，本篇文章来说说 Java 的一个小细节：为什么要将局部变量的作用域最小化？ 明人不说暗话啊。这篇文章的灵感来源于《Effective Java》，这本书我买了有好长好长一段时间了，书页都已经泛黄，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11616726.html</dc:identifier>
</item>
<item>
<title>python自动化测试三部曲之unittest框架 - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/11616526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/11616526.html</guid>
<description>&lt;p&gt;终于等到十一，有时间写博客了，准备利用十一这几天的假期把这个系列的博客写完&lt;/p&gt;
&lt;p&gt;该系列文章本人准备写三篇博客&lt;/p&gt;
&lt;p&gt;第一篇：介绍python自动化测试框架unittest&lt;/p&gt;
&lt;p&gt;第二篇：介绍django框架+request库实现接口测试&lt;/p&gt;
&lt;p&gt;第三篇：介绍利用Jenkins实现持续集成&lt;/p&gt;
&lt;p&gt;今天进入第一篇，unittest框架介绍&lt;/p&gt;
&lt;h3&gt;一、unittest简述&lt;/h3&gt;
&lt;p&gt;unittest是python语言的单元测试框架，在python的官方文档中，对unittest单元测试框架进行了详细的介绍，感兴趣的读者可以到https://www.python.org/doc&lt;br/&gt;网站去了解；本篇博客重点介绍unittest单元测试框架在自动化测试中的应用&lt;/p&gt;
&lt;p&gt;unittest单元测试框架提供了创建测试用例，测试套件，和批量执行测试用例的方法，在python安装成功后，unittest单元测试框架可以直接导入使用，他属于&lt;br/&gt;python的标准库；作为单元测试的框架，unittest单元测试框架也是对程序的最小模块进行的一种敏捷化的测试。在自动化测试i中，我们虽然不需要做白盒测试，&lt;br/&gt;但是必须知道所使用语言的单元测试框架，这是因为后面我们测试，就会遇到用例组织的问题，虽然函数式编程和面向对象编程提供了对代码的重构，但是对于所&lt;br/&gt;编写的每个测试用例，不可能编写成一个函数来调用执行；利用单元测试框架，可以创建一个类，该类继承unittest的TestCase，这样可以把每个TestCase看成是&lt;br/&gt;一个最小的单元，由测试套件组织起来，运行时直接执行即可，同时可引入测试报告。unittest各个组件的关系如果&lt;/p&gt;
&lt;p&gt;TestCase-------------------------------&amp;gt;TestFixture（测试固件）&lt;br/&gt;|&lt;br/&gt;|&lt;br/&gt;|&lt;br/&gt;|&lt;br/&gt;|&lt;br/&gt;|&lt;br/&gt;|&lt;br/&gt;|&lt;br/&gt;|&lt;/p&gt;&lt;p&gt;TestSuite(测试套件)-----------------------&amp;gt;TestRunner（测试执行）--------------------&amp;gt;TestReport（测试报告）&lt;/p&gt;

&lt;pre&gt;
# TestCase&lt;br/&gt;# 类，必须要继承unittest.TestCase&lt;br/&gt;# 一个类class继承 unittest.TestCase，就是一个测试用例。一个TestCase的实例就是一个测试用例，就是一个完整的测试流程。&lt;br/&gt;# 包括测试前环境准备setUp()|setUpClass()、执行代码run()、测试环境后的还原tearDown()|tearDownClass()。&lt;br/&gt;# 继承自unittest.TestCase的类中，测试方法的名称要以test开头。且只会执行以test开头定义的方法（测试用例）。
&lt;/pre&gt;

&lt;h3&gt;二、测试固件（TestFixture）&lt;/h3&gt;
&lt;p&gt;在unittest单元测试框架中，测试固件用于处理初始化的操作，例如，在对百度的搜索进行测试前，首先需要打开浏览器并且进入百度的首页；测试结束后，&lt;br/&gt;需要关闭浏览器；测试固件提哦功能了两种执行形式，一种是每执行一个测试用例，测试固件就会被执行一次；另外一种就不管有多少个用例i，测试固件只会执&lt;br/&gt;行一次&lt;/p&gt;
&lt;pre&gt;
# 用于一个测试环境的准备和销毁还原。&lt;br/&gt;# 当测试用例每次执行之前需要准备测试环境，每次测试完成后还原测试环境，比如执行前连接数据库、打开浏览器等，执行完成后需要还原数据库、关闭浏览器等操作。&lt;br/&gt;# 这时候就可以启用testfixture。&lt;/pre&gt;
&lt;pre&gt;
# setUp()：准备环境，执行每个测试用例的前置条件；&lt;br/&gt;# tearDown()：环境还原，执行每个测试用例的后置条件；&lt;br/&gt;# setUpClass()：必须使用@classmethod装饰器，所有case执行的前置条件，只运行一次；&lt;br/&gt;# tearDownClass()：必须使用@classmethod装饰器，所有case运行完后只运行一次；
&lt;/pre&gt;
&lt;h4&gt;1、测试固件每次均执行&lt;/h4&gt;
&lt;p&gt;unittest单元测试框架提供了名为setUp的tearDown的测试固件。下面，我们通过编写一个例子来看测试固件的执行方式，测试代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 import&lt;span&gt; unittest
 2 
 3 class&lt;span&gt; Test1(unittest.TestCase):
 4     
 5     # 测试固件之前置条件
 6     def&lt;span&gt; setUp(self):
 7         print(&quot;这是前置条件&quot;&lt;span&gt;)
 8     
 9     # 测试固件之后置条件
10     def&lt;span&gt; tearDown(self):
11         print(&quot;这是后置条件&quot;&lt;span&gt;)
12 
13     def&lt;span&gt; test_case1(self):
14         print(&quot;test_case1&quot;&lt;span&gt;)
15 
16     def&lt;span&gt; test_case2(self):
17         print(&quot;test_case2&quot;&lt;span&gt;)
18 
19 
20 if __name__ == '__main__'&lt;span&gt;:
21     unittest.main(verbosity=2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201910/1101486-20191001224504041-573888723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;他的执行顺序是先执行setUp方法，在执行具体的用例，最后执行tearDown方法&lt;/p&gt;

&lt;h4&gt;2、测试固件只执行一次&lt;/h4&gt;
&lt;p&gt;钩子方法setUp和tearDown虽然经常使用，但是在自动化测试中，一个系统的测试用例多达上千条，每次都执行一次的setUp和tearDown方法会耗费大量的性能，&lt;br/&gt;在unittest单元测试框架中还可以使用另外一种测试固件来解决这一问题，他就是setUpClass和tearDownClass方法，该测试固件方法是类方法，需要在方法上&lt;br/&gt;面加装饰器@classmethod，使用该测试固件，不管有多少个用例，测试固件只执行一次，具体代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 import&lt;span&gt; unittest
 2 
 3 class&lt;span&gt; Test1(unittest.TestCase):
 4     # def setUp(self):
 5     #     print(&quot;这是前置条件&quot;)
 6     #
 7     # def tearDown(self):
 8     #     print(&quot;这是后置条件&quot;)
 9     
10 &lt;span&gt;    @classmethod
11     def&lt;span&gt; setUpClass(cls):
12         print(&quot;这是类方法前置条件&quot;&lt;span&gt;)
13 
14 &lt;span&gt;    @classmethod
15     def&lt;span&gt; tearDownClass(cls):
16         print(&quot;这是类方法后置条件&quot;&lt;span&gt;)
17 
18     def&lt;span&gt; test_case1(self):
19         print(&quot;test_case1&quot;&lt;span&gt;)
20 
21     def&lt;span&gt; test_case2(self):
22         print(&quot;test_case2&quot;&lt;span&gt;)
23 
24 
25 if __name__ == '__main__'&lt;span&gt;:
26     unittest.main(verbosity=2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201910/1101486-20191001224830529-1168947900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;3、两种测试固件并存&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import&lt;span&gt; unittest


class&lt;span&gt; Test1(unittest.TestCase):
    def&lt;span&gt; setUp(self):
        print(&quot;这是前置条件&quot;&lt;span&gt;)

    def&lt;span&gt; tearDown(self):
        print(&quot;这是后置条件&quot;&lt;span&gt;)

    @classmethod
    def&lt;span&gt; setUpClass(cls):
        print(&quot;这是类方法前置条件&quot;&lt;span&gt;)

    @classmethod
    def&lt;span&gt; tearDownClass(cls):
        print(&quot;这是类方法后置条件&quot;&lt;span&gt;)

    def&lt;span&gt; test_case1(self):
        print(&quot;test_case1&quot;&lt;span&gt;)

    def&lt;span&gt; test_case2(self):
        print(&quot;test_case2&quot;&lt;span&gt;)


if __name__ == '__main__'&lt;span&gt;:
    unittest.main(verbosity=2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201910/1101486-20191001225223794-1717308458.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;结果表明，先执行被@classmethod装饰器装饰的测试固件，在执行普通的测试固件 &lt;/p&gt;

&lt;h3&gt;三、测试执行&lt;/h3&gt;
&lt;p&gt;在以上事例中，可以看到测试用例的执行是在主函数中，unittest调用的是main，代码如下,TestProjram还是一个类，再来看该类的构造函数，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
main = TestProgram
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;TestProjram还是一个类，再来看该类的构造函数，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
class&lt;span&gt; TestProgram(object):
    &quot;&quot;&quot;A command-line program that runs a set of tests; this is primarily
       for making test modules conveniently executable.
    &quot;&quot;&quot;
    # defaults for testing
    module=&lt;span&gt;None
    verbosity = 1&lt;span&gt;
    failfast = catchbreak = buffer = progName = warnings =&lt;span&gt; None
    _discovery_parser =&lt;span&gt; None

    def __init__(self, module='__main__', defaultTest=None, argv=&lt;span&gt;None,
                    testRunner=None, testLoader=&lt;span&gt;loader.defaultTestLoader,
                    exit=True, verbosity=1, failfast=None, catchbreak=&lt;span&gt;None,
                    buffer=None, warnings=None, *, tb_locals=&lt;span&gt;False):
        if&lt;span&gt; isinstance(module, str):
            self.module = __import__&lt;span&gt;(module)
            for part in module.split('.')[1&lt;span&gt;:]:
                self.module =&lt;span&gt; getattr(self.module, part)
        else&lt;span&gt;:
            self.module =&lt;span&gt; module
        if argv is&lt;span&gt; None:
            argv =&lt;span&gt; sys.argv

        self.exit =&lt;span&gt; exit
        self.failfast =&lt;span&gt; failfast
        self.catchbreak =&lt;span&gt; catchbreak
        self.verbosity =&lt;span&gt; verbosity
        self.buffer =&lt;span&gt; buffer
        self.tb_locals =&lt;span&gt; tb_locals
        if warnings is None and not&lt;span&gt; sys.warnoptions:
            # even if DeprecationWarnings are ignored by default
            # print them anyway unless other warnings settings are
            # specified by the warnings arg or the -W python flag
            self.warnings = 'default'
        else&lt;span&gt;:
            # here self.warnings is set either to the value passed
            # to the warnings args or to None.
            # If the user didn't pass a value self.warnings will
            # be None. This means that the behavior is unchanged
            # and depends on the values passed to -W.
            self.warnings =&lt;span&gt; warnings
        self.defaultTest =&lt;span&gt; defaultTest
        self.testRunner =&lt;span&gt; testRunner
        self.testLoader =&lt;span&gt; testLoader
        self.progName =&lt;span&gt; os.path.basename(argv[0])
        self.parseArgs(argv)
        self.runTests()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在unittest模块中包含的main方法，可以方便的将测试模块转变为可以运行的测试脚本。main使用unittest.TestLoader类来自动查找和加载模块内的测试用例，TestProgram类中的该部分的代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    def&lt;span&gt; createTests(self):
        if self.testNames is&lt;span&gt; None:
            self.test =&lt;span&gt; self.testLoader.loadTestsFromModule(self.module)
        else&lt;span&gt;:
            self.test =&lt;span&gt; self.testLoader.loadTestsFromNames(self.testNames,
                                                           self.module)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在执行测试用例时候，在main方法中加入了verbosity=2，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
if __name__ == '__main__'&lt;span&gt;:
    unittest.main(verbosity=2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面解释一下verbosity部分，在verbosity中默认是1。0代表执行的测试总数和全局结果，2代表详细的信息&lt;/p&gt;

&lt;h3&gt;四、测试套件，TestSuite&lt;/h3&gt;
&lt;pre&gt;
# TestSuite&lt;br/&gt;# 上述简单的测试会产生两个问题，可不可以控制test测试用例的执行顺序？若不想执行某个测试用例，有没有办法可以跳过？&lt;br/&gt;# 对于执行顺序，默认按照test的 A-Z、a-z的方法执行。若要按自己编写的用例的先后关系执行，需要用到testSuite。&lt;br/&gt;# 把多个测试用例集合起来，一起执行，就是testSuite。testsuite还可以包含testsuite。&lt;br/&gt;# 一般通过addTest()或者addTests()向suite中添加。case的执行顺序与添加到Suite中的顺序是一致的。&lt;/pre&gt;
&lt;h4&gt;1、直接执行案例&lt;/h4&gt;
&lt;pre&gt;
我们在func.py这个文件中定义加减乘除4个测试函数
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#Auther Bob
#--*--conding:utf-8 --*--
def&lt;span&gt; add(a,b):
    return a +&lt;span&gt; b
def&lt;span&gt; minus(a,b):
    return a -&lt;span&gt; b
def&lt;span&gt; multi(a,b):
    return a *&lt;span&gt; b
def&lt;span&gt; divide(a,b):
    return a / b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201910/1101486-20191001231137254-259535263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;然后在myunittest.py文件中定义我们的测试代码，这里用到了断言，我们后面会介绍&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
from test1 import&lt;span&gt; func

class&lt;span&gt; Test2(unittest.TestCase):
    def&lt;span&gt; setUp(self):
        print(&quot;前置条件&quot;&lt;span&gt;)

    def&lt;span&gt; tearDown(self):
        print(&quot;后置条件&quot;&lt;span&gt;)

    def&lt;span&gt; test_add(self):
        self.assertEqual(3,func.add(1,2&lt;span&gt;))

    def&lt;span&gt; test_minus(self):
        self.assertEqual(4,func.minus(5,1&lt;span&gt;))

    def&lt;span&gt; test_multi(self):
        self.assertEqual(4,func.multi(2,2&lt;span&gt;))

    def&lt;span&gt; test_divide(self):
        self.assertEqual(10,func.divide(100,10&lt;span&gt;))


if __name__ == '__main__'&lt;span&gt;:
    unittest.main(verbosity=2)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;执行结果如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201910/1101486-20191001231339005-854176025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;2、添加案例到测试套件中&lt;/h4&gt;
&lt;pre readability=&quot;7&quot;&gt;
上述简单的测试会产生两个问题，可不可以控制test测试用例的执行顺序？若不想执行某个测试用例，有没有办法可以跳过？&lt;br/&gt;对于执行顺序，默认按照test的 A-Z、a-z的方法执行。若要按自己编写的用例的先后关系执行，需要用到testSuite。&lt;br/&gt;把多个测试用例集合起来，一起执行，就是testSuite。testsuite还可以包含testsuite。&lt;br/&gt;一般通过addTest()或者addTests()向suite中添加。case的执行顺序与添加到Suite中的顺序是一致的。&lt;p&gt;如果用到测试套件TestSuite，则需要先写好测试代码，但是先不要执行&lt;/p&gt;&lt;p&gt;我们同样在myunittest.py文件中定义我们的测试代码
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
from test1 import&lt;span&gt; func


class&lt;span&gt; Test3(unittest.TestCase):
    def&lt;span&gt; setUp(self):
        print(&quot;前置条件&quot;&lt;span&gt;)

    def&lt;span&gt; tearDown(self):
        print(&quot;后置条件&quot;&lt;span&gt;)


    def&lt;span&gt; test_add(self):
        self.assertEqual(3,func.add(1,2&lt;span&gt;))


    def&lt;span&gt; test_minus(self):
        self.assertEqual(4,func.minus(5,1&lt;span&gt;))


    def&lt;span&gt; test_multi(self):
        self.assertEqual(4,func.multi(2,2&lt;span&gt;))

    def&lt;span&gt; test_divide(self):
        self.assertEqual(10,func.divide(100,10))&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们在test_suit.py文件中引入测试案例，然后通过TestSuite类的addTests方法把测试用例添加到测试套件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import&lt;span&gt; unittest
from test1.myunittest import&lt;span&gt; Test3
# from test1.myunittest2 import Test3 as t3



if __name__ == '__main__'&lt;span&gt;:
    # 输出信息到控制台
    
    # 实例化一个TestSuite类
    suite =&lt;span&gt; unittest.TestSuite()
    
    # 把需要执行的案例放在一个list中
    tests = [Test3(&quot;test_add&quot;), Test3(&quot;test_minus&quot;), Test3(&quot;test_multi&quot;), Test3(&quot;test_divide&quot;&lt;span&gt;)]
    
    # 把案例添加到实例化好的测试套件中
&lt;span&gt;    suite.addTests(tests)
    # t = [t3(&quot;test_add&quot;), t3(&quot;test_minus&quot;), t3(&quot;test_multi&quot;), t3(&quot;test_divide&quot;)]
    # suite.addTests(tests)
    
    # 实例化一个参数执行类
    runner = unittest.TextTestRunner(verbosity=2&lt;span&gt;)
    
    # 测试执行类的实例执行测试套件
    runner.run(suite)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;br/&gt;以上的案例我们是添加一个文件的测试案例，我们同样可以添加多个文件中的案例到一个测试套件中，然后执行这个测试套件即可
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
import&lt;span&gt; unittest
from test1.myunittest import&lt;span&gt; Test3
from test1.myunittest2 import&lt;span&gt; Test3 as t3



if __name__ == '__main__'&lt;span&gt;:
    # 输出信息到控制台

    # 实例化一个TestSuite类
    suite =&lt;span&gt; unittest.TestSuite()

    # 把需要执行的案例放在一个list中
    tests = [Test3(&quot;test_add&quot;), Test3(&quot;test_minus&quot;), Test3(&quot;test_multi&quot;), Test3(&quot;test_divide&quot;&lt;span&gt;)]

    # 把案例添加到实例化好的测试套件中
&lt;span&gt;    suite.addTests(tests)
    
    # 添加另外一个文件中的测试案例到测试套件中
    t = [t3(&quot;test_add&quot;), t3(&quot;test_minus&quot;), t3(&quot;test_multi&quot;), t3(&quot;test_divide&quot;&lt;span&gt;)]
    suite.addTests(t)

    # 实例化一个参数执行类
    runner = unittest.TextTestRunner(verbosity=2&lt;span&gt;)

    # 测试执行类的实例执行测试套件
    runner.run(suite)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的执行方式是输出结果到控制台，我们也可以输出结果到文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
import&lt;span&gt; unittest
from test1.myunittest import&lt;span&gt; Test3
from test1.myunittest2 import&lt;span&gt; Test3 as t3



if __name__ == '__main__'&lt;span&gt;:
    
    # 输出信息到txt文件中
    suite =&lt;span&gt; unittest.TestSuite()
    tests = [Test3(&quot;test_add&quot;), Test3(&quot;test_minus&quot;), Test3(&quot;test_multi&quot;), Test3(&quot;test_divide&quot;&lt;span&gt;)]
    suite.addTests(tests)
    t = [t3(&quot;test_add&quot;), t3(&quot;test_minus&quot;), t3(&quot;test_multi&quot;), t3(&quot;test_divide&quot;&lt;span&gt;)]
    suite.addTests(t)
    with open('UnittestTextReport.txt', 'a'&lt;span&gt;) as  f:
        runner = unittest.TextTestRunner(stream=f, verbosity=2&lt;span&gt;)
        runner.run(suite)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3、直接添加测试类到测试套件中&lt;/h4&gt;
&lt;p&gt;案例一个一个添加还是比较麻烦，我们可以直接添加一个测试类到测试套件中&lt;/p&gt;
&lt;p&gt;利用下面的方法加载一个测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
unittest.TestLoader().loadTestsFromTestCase(t3)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import&lt;span&gt; unittest
from unittest import&lt;span&gt; TestLoader

from test1 import&lt;span&gt; myunittest

from test1.myunittest2 import&lt;span&gt; Test3 as t3

if __name__ == '__main__'&lt;span&gt;:
    suite =&lt;span&gt; unittest.TestSuite()
    loader =&lt;span&gt; TestLoader()
    test_cases1 =&lt;span&gt; unittest.TestLoader().loadTestsFromTestCase(t3)
    # 参数是一个类，而这个类必须是unittest.TestCase的子类或者孙类
&lt;span&gt;    suite.addTests(test_cases1)
    runner = unittest.TextTestRunner(verbosity=2&lt;span&gt;)
    runner.run(suite)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;4、直接加载一个模块到测试套件中，如果这个模块中有多个类，则会把所有的类的测试案例加载到测试套件中&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
unittest.TestLoader().loadTestsFromModule(myunittest)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import&lt;span&gt; unittest
from unittest import&lt;span&gt; TestLoader

from test1 import&lt;span&gt; myunittest

from test1.myunittest2 import&lt;span&gt; Test3 as t3

if __name__ == '__main__'&lt;span&gt;:
    suite =&lt;span&gt; unittest.TestSuite()
    loader =&lt;span&gt; TestLoader()
    test_cases1 =&lt;span&gt; unittest.TestLoader().loadTestsFromModule(myunittest)
    # 参数是一个模块，会把这个模块里的所有case加载进来
&lt;span&gt;    suite.addTests(test_cases1)
    runner = unittest.TextTestRunner(verbosity=2&lt;span&gt;)
    runner.run(suite)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我给大家截图看下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201910/1101486-20191001234009365-1475209399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h4&gt;5、通过案例名称添加案例到测试套件中&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    test_cases1 = unittest.TestLoader().loadTestsFromName('test1.myunittest2.Test3.test_minus')
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import&lt;span&gt; unittest
from unittest import&lt;span&gt; TestLoader

from test1 import&lt;span&gt; myunittest

from test1.myunittest2 import&lt;span&gt; Test3 as t3

if __name__ == '__main__'&lt;span&gt;:

    suite =&lt;span&gt; unittest.TestSuite()
    loader =&lt;span&gt; TestLoader()
    test_cases1 = unittest.TestLoader().loadTestsFromName('test1.myunittest2.Test3.test_minus'&lt;span&gt;)
    # 加载某个cese
    runner = unittest.TextTestRunner(verbosity=2&lt;span&gt;)
    suite.addTests(test_cases1)
    runner.run(suite)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我截图给大家看下目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201910/1101486-20191001234345556-458651351.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;五、忽略执行案例&lt;/h3&gt;
&lt;p&gt;在实际的项目中，有些案例我们可能暂时不需要执行，如果有这样的问题，我们该怎么办，unittest框架已经为我们提供了解决方案&lt;/p&gt;

&lt;p&gt;1、无条件跳过该案例，用该装饰器修饰要执行的案例，则该案例会被忽略不执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
@unittest.skip(&quot;do not exec&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    @unittest.skip(&quot;do not exec&quot;&lt;span&gt;)
    # 无条件跳过执行该案例
    def&lt;span&gt; test_add(self):
        self.assertEqual(3,func.add(1,2))&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、满足某个条件才跳过该案例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@unittest.skipIf(4 &amp;gt; 3,&quot;2 &amp;gt; 3 do not exec&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @unittest.skipIf(4 &amp;gt; 3,&quot;2 &amp;gt; 3 do not exec&quot;&lt;span&gt;)
    # 满足某个条件才跳过执行
    def&lt;span&gt; test_minus(self):
        self.assertEqual(4,func.minus(5,1))&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3、不满足某个条件才跳过案例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@unittest.skipUnless(4 &amp;lt; 3,&quot;hahah&quot;)
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    @unittest.skipUnless(4 &amp;lt; 3,&quot;hahah&quot;&lt;span&gt;)
    # 不满足某个条件才跳过执行
    def&lt;span&gt; test_multi(self):
        self.assertEqual(4,func.multi(2,2))&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、我们也可以在案例里面定义忽略执行这条案例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    def&lt;span&gt; test_divide(self):
        self.skipTest(&quot;wydd&quot;&lt;span&gt;)
        self.assertEqual(10,func.divide(100,10))&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;六、断言&lt;/h3&gt;
&lt;p&gt;断言就是判断实际测试结果与预期结果是否一致，一致则测试通过，否则失败。因此，在自动化测试中，无断言的测试用例是无效的，这是因为当一个功能自动化已经全部实现，在每次版本迭代中执行测试用例时，执行的结果必须是权威的，也就是说自动化测试用例执行结果应该无功能性或者逻辑性问题，在自动化测试中最忌讳的就是自动化测试的用例虽然是通过的，但是被测试的功能却是存在问题的，自动化测试用例经常应用在回归测试中，发现的问题不是特别多，如果测试结果存在功能上的问题，则投入了人力去做的自动化参数就没有多大的意义了，所以每一个测试用例必须要有断言；在测试的结果中只有两种可能，一种是执行通过，另外一种是执行失败，也就是功能存在问题，在TestCase类中提供了assert方法来检查和报告失败，常用的方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
     self.assertEqual(3,func.add(1,2&lt;span&gt;))
        # 判断是否相等
&lt;span&gt;        
        self.assertNotEqual()
        # 判断是否不等于
&lt;span&gt;        
        self.assertTrue()
        # 判断布尔值是否为True
&lt;span&gt;        
        self.assertFalse()
        # 判断布尔值是否为False
&lt;span&gt;        
        self.assertIs()
        # 判断类型是否相同
&lt;span&gt;        
        self.assertIsNot()
        # 判断类型是否不同
&lt;span&gt;        
        self.assertIsNone()
        # 判断是否为None
&lt;span&gt;        
        self.assertIsNotNone()
        # 判断是否不为None
&lt;span&gt;        
        self.assertIn()
        # 判断在某个范围内
&lt;span&gt;        
        self.assertNotIn()
        # 判断是否不在某个范围内
&lt;span&gt;        
        self.assertIsInstance()
        # 判断是否为某个类的实例
&lt;span&gt;        
        self.assertNotIsInstance()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 01 Oct 2019 15:57:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<og:description>终于等到十一，有时间写博客了，准备利用十一这几天的假期把这个系列的博客写完 该系列文章本人准备写三篇博客 第一篇：介绍python自动化测试框架unittest 第二篇：介绍django框架+requ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bainianminguo/p/11616526.html</dc:identifier>
</item>
<item>
<title>10秒钟理解react生命周期 - 大~熊</title>
<link>http://www.cnblogs.com/floor/p/11616467.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/floor/p/11616467.html</guid>
<description>&lt;blockquote readability=&quot;8.145251396648&quot;&gt;
&lt;p&gt;慎点！这是一篇很水很水的文章, 抄自&lt;a href=&quot;https://zh-hans.reactjs.org/docs/react-component.html&quot;&gt;react中文文档&lt;/a&gt;, 本文详细介绍了react生命周期函数执行顺序, 以及各生命周期函数的含义和具体作用.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;不同阶段生命周期函数执行顺序&quot;&gt;不同阶段生命周期函数执行顺序&lt;/h2&gt;
&lt;h3 id=&quot;挂载mounting&quot;&gt;挂载(Mounting)&lt;/h3&gt;
&lt;p&gt;挂载指的是组件被实例化并插入到dom中&lt;/p&gt;
&lt;p&gt;顺序如下:&lt;/p&gt;
&lt;p&gt;constructor -&amp;gt; getDerivedStateFromProps -&amp;gt; render -&amp;gt; componentDidMount&lt;/p&gt;
&lt;h3 id=&quot;更新updating&quot;&gt;更新(Updating)&lt;/h3&gt;
&lt;p&gt;当state变化或者props变化会引起更新&lt;/p&gt;
&lt;p&gt;顺序如下:&lt;/p&gt;
&lt;p&gt;getDerivedStateFromProps -&amp;gt; shouldComponentUpdate -&amp;gt; render -&amp;gt; getSnapshotBeforeUpdate -&amp;gt; componentDidUpdate&lt;/p&gt;
&lt;h3 id=&quot;卸载&quot;&gt;卸载&lt;/h3&gt;
&lt;p&gt;指的是组件被从dom移除&lt;/p&gt;
&lt;p&gt;只会执行一个生命周期:&lt;/p&gt;
&lt;p&gt;componentWillUnmount&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这张图形象表示了不同阶段生命周期函数执行顺序.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1128201/201910/1128201-20191001232453114-1666226727.png&quot; alt=&quot;react生命周期&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;各生命周期函数介绍&quot;&gt;各生命周期函数介绍&lt;/h2&gt;
&lt;h3 id=&quot;常用的生命周期&quot;&gt;常用的生命周期&lt;/h3&gt;
&lt;h4 id=&quot;render&quot;&gt;render()&lt;/h4&gt;
&lt;p&gt;render() 方法是 class 组件中唯一必须实现的方法。&lt;/p&gt;
&lt;p&gt;当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;React 元素。通常通过 JSX 创建。例如，&lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 会被 React 渲染为 DOM 节点，&lt;code&gt;&amp;lt;MyComponent /&amp;gt;&lt;/code&gt; 会被 React 渲染为自定义组件，无论是 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 还是 &lt;code&gt;&amp;lt;MyComponent /&amp;gt;&lt;/code&gt; 均为 React 元素。&lt;/li&gt;
&lt;li&gt;数组或 fragments。 使得 render 方法可以返回多个元素。&lt;/li&gt;
&lt;li&gt;Portals。可以渲染子节点到不同的 DOM 子树中。&lt;/li&gt;
&lt;li&gt;字符串或数值类型。它们在 DOM 中会被渲染为文本节点&lt;/li&gt;
&lt;li&gt;布尔类型或 null。什么都不渲染。（主要用于支持返回 test &amp;amp;&amp;amp; &lt;code&gt;&amp;lt;Child /&amp;gt;&lt;/code&gt; 的模式，其中 test 为布尔类型。)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;render() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果 shouldComponentUpdate() 返回 false，则不会调用 render()。&lt;/p&gt;
&lt;h4 id=&quot;constructor&quot;&gt;constructor()&lt;/h4&gt;
&lt;p&gt;在 React 组件挂载之前，会调用它的构造函数。&lt;/p&gt;
&lt;p&gt;通常，在 React 中，在构造函数中只做两件事：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过给 this.state 赋值对象来初始化内部 state。&lt;/li&gt;
&lt;li&gt;为事件处理函数绑定实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在为 React.Component 子类实现构造函数时，应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug。&lt;/li&gt;
&lt;li&gt;不要在里边调用setState&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;componentdidmount&quot;&gt;componentDidMount()&lt;/h4&gt;
&lt;p&gt;componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。&lt;/p&gt;
&lt;p&gt;在这里可以&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;setState&lt;/li&gt;
&lt;li&gt;操作dom&lt;/li&gt;
&lt;li&gt;发请求获取初始数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你可以在 componentDidMount() 里可以直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理.&lt;/p&gt;
&lt;h4 id=&quot;componentdidupdateprevprops-prevstate-snapshot&quot;&gt;componentDidUpdate(prevProps, prevState, snapshot)&lt;/h4&gt;
&lt;p&gt;componentDidUpdate() 会在更新(dom已经更新)后会被立即调用。首次渲染不会执行此方法。&lt;/p&gt;
&lt;p&gt;当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。&lt;/p&gt;
&lt;p&gt;你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语件里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。&lt;/p&gt;
&lt;p&gt;如果组件实现了 getSnapshotBeforeUpdate() 生命周期（不常用），则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined。&lt;/p&gt;
&lt;h4 id=&quot;componentwillunmount&quot;&gt;componentWillUnmount()&lt;/h4&gt;
&lt;p&gt;componentWillUnmount() 会在组件卸载及销毁之前直接调用。&lt;/p&gt;
&lt;p&gt;在这里可以释放资源, 比如清除定时器, removeEventListener&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里边setState是无效的, 不应该调用&lt;/p&gt;
&lt;h3 id=&quot;不常用的生命周期&quot;&gt;不常用的生命周期&lt;/h3&gt;
&lt;h4 id=&quot;shouldcomponentupdatenextprops-nextstate&quot;&gt;shouldComponentUpdate(nextProps, nextState)&lt;/h4&gt;
&lt;p&gt;他的返回值可以决定是否重新渲染, 当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用。返回值默认为 true。首次渲染或使用 forceUpdate() 时不会调用该方法。&lt;/p&gt;
&lt;p&gt;这是一个性能优化的生命周期方法, 只有当你清楚的知道自己在做什么的是使用&lt;/p&gt;
&lt;h4 id=&quot;static-getderivedstatefrompropsprops-state&quot;&gt;static getDerivedStateFromProps(props, state)&lt;/h4&gt;
&lt;p&gt;getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 null 则不更新任何内容。&lt;/p&gt;
&lt;h4 id=&quot;getsnapshotbeforeupdateprevprops-prevstate&quot;&gt;getSnapshotBeforeUpdate(prevProps, prevState)&lt;/h4&gt;
&lt;p&gt;getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。&lt;/p&gt;
&lt;p&gt;此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。&lt;/p&gt;
&lt;h3 id=&quot;与错误相关的生命周期&quot;&gt;与错误相关的生命周期&lt;/h3&gt;
&lt;h4 id=&quot;static-getderivedstatefromerror&quot;&gt;static getDerivedStateFromError()&lt;/h4&gt;
&lt;p&gt;此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;getDerivedStateFromError() 会在渲染阶段调用，因此不允许出现副作用。 如遇此类情况，请改用 componentDidCatch()。&lt;/p&gt;
&lt;h4 id=&quot;componentdidcatch&quot;&gt;componentDidCatch()&lt;/h4&gt;
&lt;p&gt;此生命周期在后代组件抛出错误后被调用。 它接收两个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;error —— 抛出的错误。&lt;/li&gt;
&lt;li&gt;info —— 带有 componentStack key 的对象，其中包含有关组件引发错误的栈信息。&lt;br/&gt;componentDidCatch() 会在“提交”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况.&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 01 Oct 2019 15:28:00 +0000</pubDate>
<dc:creator>大~熊</dc:creator>
<og:description>慎点！这是一篇很水很水的文章, 抄自[react中文文档](https://zh-hans.reactjs.org/docs/react-component.html), 本文详细介绍了react生命</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/floor/p/11616467.html</dc:identifier>
</item>
<item>
<title>java8泛型 - 堕落门徒</title>
<link>http://www.cnblogs.com/cord/p/11616353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cord/p/11616353.html</guid>
<description>&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;泛型，也就是将类型参数化，然后在使用类或者方法的时候可以传入类型，在不需要创建新类型实现的前提下可以通过泛型控制形参的类型。泛型可以用在类，方法和接口中。&lt;/p&gt;
&lt;h2 id=&quot;泛型中的相关操作符&quot;&gt;1，泛型中的相关操作符&lt;/h2&gt;
&lt;p&gt;​ 在使用泛型的代码中经常可以看到一些泛型相关的符号，它们的作用如下表所示：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;T,E,K,V&lt;/td&gt;
&lt;td&gt;泛型标识，可以写人任意标识，不同字母更多是一种约定，等同于&amp;lt; T extends Object&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;无限制通配符，表示不确定类型，等同于&amp;lt; ? extends Object&amp;gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;extend&lt;/td&gt;
&lt;td&gt;上界通配符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;super&lt;/td&gt;
&lt;td&gt;下界通配符&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;&amp;amp;&lt;/td&gt;
&lt;td&gt;附加约束(AdditionalBound, tjls8-4.4)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;泛型基本使用示例&quot;&gt;2，泛型基本使用示例&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class GenericDemo&amp;lt;C&amp;gt; { //泛型类

    public static void main(String[] args) {
        //泛型类用Integer初始化，所以C相关的方法属性必须是Integer
        GenericDemo&amp;lt;Integer&amp;gt; gd = new GenericDemo&amp;lt;Integer&amp;gt;();
        gd.classPrint(1);
        gd.setX(2);
        //----------------------
        //泛型方法，与调用的类型保持一致，参数类型得为String
        GenericDemo.&amp;lt;String&amp;gt;methodPrint(&quot;abc&quot;);
        //---------------------
        //泛型接口，与初始化时候传入的类型保持一致,参数类型得是Double
        IFC&amp;lt;Double&amp;gt; ifc = new IFC&amp;lt;Double&amp;gt;() {};
        ifc.interfacePrint(2.9);
    }

    private C c;

    public void setX(C c) {
        this.c = c;
    }
        public void classPrint(C c) {
        System.out.println(c.getClass());
    }

    //泛型方法，前面的&amp;lt;T&amp;gt;是为了标识这是一个泛型方法
    public static &amp;lt;T&amp;gt; void methodPrint(T t) {
        System.out.println(t.getClass());
    }

    interface IFC&amp;lt;I&amp;gt; { //泛型接口
        default void interfacePrint(I i) { System.out.println(i.getClass());}
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通配符&quot;&gt;3，通配符&lt;/h2&gt;
&lt;h3 id=&quot;t和的区别&quot;&gt;3.1, T和?的区别&lt;/h3&gt;
&lt;p&gt;基本泛型T是用于定义，将数据类型参数化，不能用于实例化。而 ? 则是在实例化对象时不确定泛型具体参数类型的时候泛指Object的所有子类型。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T&lt;/td&gt;
&lt;td&gt;&amp;lt; T extends Object&amp;gt;，用于定义&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;?&lt;/td&gt;
&lt;td&gt;&amp;lt; ? extends Object&amp;gt;，用于实例化&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;?不能和Object等效，&lt;u&gt;?是类型实参而不是类型形参，它用于泛指各种类型实参&lt;/u&gt;，当具体类型不确定的时候就可以使用？，示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class test6 {
    public static void main(String[] args) {
        List&amp;lt;String&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;();
        List&amp;lt;Integer&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();
        test(list1);
        test(list2);
    }

    public static void test(List&amp;lt;?&amp;gt; list) {
        System.out.println(list);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上下界通配符&quot;&gt;3.2，上下界通配符&lt;/h3&gt;
&lt;p&gt;上下界通配符其实涉及到java 的多态属性，上下转型的可行性，&lt;u&gt;子类实例可以转换成父类实例，但是父类实例却不一定能转换成子类实例，只有本身就是该子类实例向上转型的父类实例才可以向下转型为子类实例。&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;? extends T&amp;gt; 表示类型范围为T以及其子类，&amp;lt;? super T&amp;gt;表示类型范围为T及其父类。&lt;/p&gt;
&lt;p&gt;界限通配符在应用于集合的时候会影响集合的读写行为：&lt;/p&gt;
&lt;p&gt;上界&amp;lt;? extends T&amp;gt; 限制了类型上限，只能向上转型，可以读，但是没法写，因为子类型不确定，没法向下转型；&lt;/p&gt;
&lt;p&gt;下界&amp;lt;? super T&amp;gt;限制类型的下限，只能向下转型，可以写，但是没法读，因为父类型不确定，没法向上转型。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class test {

    public static void main(String[] args) {
        //&amp;lt;? extends B&amp;gt; 范围: A类或者A的子类
        //由于下限不确定，所以无法向下转型至具体类型
        List&amp;lt;? extends B&amp;gt; list1 = new ArrayList&amp;lt;B&amp;gt;(){{add(new B());}};
//        list1.add(new B()); //无法添加该类型, 向下转型无法确定目标类型
//        list1.add(new C());
        A a = list1.get(0); //正常向上转型

        //&amp;lt;? super B&amp;gt; 范围: B类或者B的父类
        //由于上限不确定，所以B类和B类的子类均可以加入，但是B类的父类不行
        List&amp;lt;? super B&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();
//        list2.add(new A()); //无法向下转型
        list2.add(new B()); //正常向上转型
        list2.add(new C());
//        C c = list2.get(0);//无法向下转型，不加强制转换会报错
        C c = (C)list2.get(0);
    }
    //   A -&amp;gt; B -&amp;gt; C
    static class A {};
    static class B extends A {};
    static class C extends B {};
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;附加约束&quot;&gt;4, 附加约束(&amp;amp;)&lt;/h2&gt;
&lt;p&gt;AdditionalBound 的语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TypeBound:
extends ClassOrInterfaceType {AdditionalBound}
AdditionalBound:
&amp;amp; InterfaceType&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说extends后面可以在加个额外约束，具体为接口类型，可以I1 &amp;amp; I2 &amp;amp; I3这样连排，注意必须是接口类型，不能是class或者类型变量，这里额外约束的作用是限制类型必须实现相关的接口，示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class test {

    public static void main(String[] args) {
        test1(1); test1(&quot;1&quot;);
        test2(2); test2(&quot;2&quot;);
//        test3(3);  //test3方法String类型才满足额外约束
        test3(&quot;3&quot;);
    }

    public static &amp;lt;T extends Object&amp;gt; void test1(T t) {
        System.out.println(t.getClass());
    }
    //得同时实现Serializable和Comparable接口
    public static &amp;lt;T extends Object &amp;amp; Serializable &amp;amp; Comparable&amp;gt; void test2(T t) {
        System.out.println(t.getClass());
    }
    //得同时实现Serializable,CharSequence和Comparable接口
    public static &amp;lt;T extends Object &amp;amp; Serializable &amp;amp; CharSequence &amp;amp; Comparable&amp;gt; void test3(T t) {
        System.out.println(t.getClass());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，附加约束还可用于类型强制转换：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class test12 {
    public static void main(String[] args) {
        System.out.println(test());
    }
    public static Object test() {
//        return (Object &amp;amp; Number)&quot;abced&quot;; //编译不通过
//        return (Object)&quot;abced&quot;; //编译通过
        return (Object &amp;amp; CharSequence &amp;amp; Comparable)&quot;abcde&quot;; //编译通过
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在一些类型转换的场景可以通过附加约束控制类型转换的范围。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeday.me/bug/20190313/767875.html&quot; class=&quot;uri&quot;&gt;https://codeday.me/bug/20190313/767875.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5b614848e51d45355d51f792&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5b614848e51d45355d51f792&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/whatlonelytear/p/11055126.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/whatlonelytear/p/11055126.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/s10461/article/details/53941091&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/s10461/article/details/53941091&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/claram/article/details/51943742&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/claram/article/details/51943742&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Oct 2019 14:28:00 +0000</pubDate>
<dc:creator>堕落门徒</dc:creator>
<og:description>[TOC]​ 泛型，也就是将类型参数化，然后在使用类或者方法的时候可以传入类型，在不需要创建新类型实现的前提下可以通过泛型控制形参的类型。泛型可以用在类，方法和接口中。 1，泛型中的相关操作符 ​ 在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cord/p/11616353.html</dc:identifier>
</item>
<item>
<title>波士顿房价预测 - 最简单入门机器学习 - Jupyter - HoLoong</title>
<link>http://www.cnblogs.com/helongBlog/p/11612128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/helongBlog/p/11612128.html</guid>
<description>&lt;p&gt;该分享源于Udacity机器学习进阶中的一个mini作业项目，用于入门非常合适，刨除了繁琐的部分，保留了最关键、基本的步骤，能够对机器学习基本流程有一个最清晰的认识；&lt;/p&gt;
&lt;h2 id=&quot;项目描述&quot;&gt;项目描述&lt;/h2&gt;
&lt;p&gt;利用马萨诸塞州波士顿郊区的房屋信息数据训练和测试一个模型，并对模型的性能和预测能力进行测试；&lt;/p&gt;
&lt;h2 id=&quot;项目分析&quot;&gt;项目分析&lt;/h2&gt;
&lt;p&gt;数据集字段解释：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;RM&lt;/code&gt;: 住宅平均房间数量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LSTAT&lt;/code&gt;: 区域中被认为是低收入阶层的比率；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PTRATIO&lt;/code&gt;: 镇上学生与教师数量比例；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MEDV&lt;/code&gt;: 房屋的中值价格（目标特征，即我们要预测的值）；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实现在回过头来看，前三个特征应该都是挖掘后的组合特征，比如RM，通常在原始数据中会分为多个特征：一楼房间、二楼房间、厨房、卧室个数、地下室房间等等，这里应该是为了教学简单化了；&lt;/p&gt;
&lt;p&gt;MEDV为我们要预测的值，属于回归问题，另外数据集不大（不到500个数据点），小数据集上的回归问题，现在的我初步考虑会用SVM，稍后让我们看看当时的选择；&lt;/p&gt;
&lt;h2 id=&quot;show-time&quot;&gt;Show Time&lt;/h2&gt;
&lt;h3 id=&quot;step-1-导入数据&quot;&gt;Step 1 导入数据&lt;/h3&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果数据在多个csv中（比如很多销售项目中，销售数据和店铺数据是分开两个csv的，类似数据库的两张表），这里一般要连接起来；&lt;/li&gt;
&lt;li&gt;训练数据和测试数据连接起来，这是为了后续的数据处理的一致，否则训练模型时会有问题（比如用训练数据训练的模型，预测测试数据时报错维度不一致）；&lt;/li&gt;
&lt;li&gt;观察下数据量，数据量对于后续选择算法、可视化方法等有比较大的影响，所以一般会看一下；&lt;/li&gt;
&lt;li&gt;pandas内存优化，这一点项目中目前没有，但是我最近的项目有用到，简单说一下，通过对特征字段的数据类型向下转换（比如int64转为int8）降低对内存的使用，这里很重要，数据量大时很容易撑爆个人电脑的内存存储；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    # 载入波士顿房屋的数据集
    data = pd.read_csv('housing.csv')
    prices = data['MEDV']
    features = data.drop('MEDV', axis = 1)
        
    # 完成
    print &quot;Boston housing dataset has {} data points with {} variables each.&quot;.format(*data.shape)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;step-2-分析数据&quot;&gt;Step 2 分析数据&lt;/h3&gt;
&lt;p&gt;加载数据后，不要直接就急匆匆的上各种处理手段，加各种模型，先慢一点，对数据进行一个初步的了解，了解其各个特征的统计值、分布情况、与目标特征的关系，最好进行可视化，这样会看到很多意料之外的东西；&lt;/p&gt;
&lt;h4 id=&quot;基础统计运算&quot;&gt;基础统计运算&lt;/h4&gt;
&lt;p&gt;统计运算用于了解某个特征的整体取值情况，它的最大最小值，平均值中位数，百分位数等等，这些都是最简单的对一个字段进行了解的手段；&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    #目标：计算价值的最小值
    minimum_price = np.min(prices)# prices.min()

    #目标：计算价值的最大值
    maximum_price = np.max(prices)# prices.max()

    #目标：计算价值的平均值
    mean_price = np.mean(prices)# prices.mean()

    #目标：计算价值的中值
    median_price = np.median(prices)# prices.median()

    #目标：计算价值的标准差
    std_price = np.std(prices)# prices.std()&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;特征观察&quot;&gt;特征观察&lt;/h4&gt;
&lt;p&gt;这里主要考虑各个特征与目标之间的关系，比如是正相关还是负相关，通常都是通过对业务的了解而来的，这里就延伸出一个点，机器学习项目通常来说，对业务越了解，越容易得到好的效果，因为所谓的特征工程其实就是理解业务、深挖业务的过程；&lt;/p&gt;
&lt;p&gt;比如这个问题中的三个特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RM：房间个数明显应该是与房价正相关的；&lt;/li&gt;
&lt;li&gt;LSTAT：低收入比例一定程度上表示着这个社区的级别，因此应该是负相关；&lt;/li&gt;
&lt;li&gt;PTRATIO：学生/教师比例越高，说明教育资源越紧缺，也应该是负相关；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上述这三个点，同样可以通过可视化的方式来验证，事实上也应该去验证而不是只靠主观猜想，有些情况下，主观感觉与客观事实是完全相反的，这里要注意；&lt;/p&gt;
&lt;h3 id=&quot;step-3-数据划分&quot;&gt;Step 3 数据划分&lt;/h3&gt;
&lt;p&gt;为了验证模型的好坏，通常的做法是进行cv，即交叉验证，基本思路是将数据平均划分N块，取其中N-1块训练，并对另外1块做预测，并比对预测结果与实际结果，这个过程反复N次直到每一块都作为验证数据使用过；&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    # 提示： 导入train_test_split
    from sklearn.model_selection import train_test_split

    X_train, X_test, y_train, y_test = train_test_split(features, prices, test_size=0.2, random_state=RANDOM_STATE)
    print X_train.shape
    print X_test.shape
    print y_train.shape
    print y_test.shape&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;step-4-定义评价函数&quot;&gt;Step 4 定义评价函数&lt;/h3&gt;
&lt;p&gt;这里主要是根据问题来定义，比如分类问题用的最多的是准确率（精确率、召回率也有使用，具体看业务场景中更重视什么），回归问题用RMSE（均方误差）等等，实际项目中根据业务特点经常会有需要去自定义评价函数的时候，这里就比较灵活；&lt;/p&gt;
&lt;h3 id=&quot;step-5-模型调优&quot;&gt;Step 5 模型调优&lt;/h3&gt;
&lt;p&gt;通过GridSearch对模型参数进行网格组合搜索最优，注意这里要考虑数据量以及组合后的可能个数，避免运行时间过长哈；&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    from sklearn.model_selection import KFold,GridSearchCV
    from sklearn.tree import DecisionTreeRegressor
    from sklearn.metrics import make_scorer


    def fit_model(X, y):
        &quot;&quot;&quot; 基于输入数据 [X,y]，利于网格搜索找到最优的决策树模型&quot;&quot;&quot;
        
        cross_validator = KFold()
        
        regressor = DecisionTreeRegressor()

        params = {'max_depth':[1,2,3,4,5,6,7,8,9,10]}

        scoring_fnc = make_scorer(performance_metric)

        grid = GridSearchCV(estimator=regressor, param_grid=params, scoring=scoring_fnc, cv=cross_validator)

        # 基于输入数据 [X,y]，进行网格搜索
        grid = grid.fit(X, y)

        # 返回网格搜索后的最优模型
        return grid.best_estimator_&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到当时项目中选择的是决策树模型，现在看，树模型在这种小数据集上其实是比较容易过拟合的，因此可以考虑用SVM代替，你也可以试试哈，我估计是SVM效果最好；&lt;/p&gt;
&lt;h3 id=&quot;学习曲线&quot;&gt;学习曲线&lt;/h3&gt;
&lt;p&gt;通过绘制分析学习曲线，可以对模型当前状态有一个基本了解，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666842/201910/666842-20191001221724459-435898198.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，超参数max_depth为1和3时，明显训练分数过低，这说明此时模型有欠拟合的情况，而当max_depth为6和10时，明显训练分数和验证分析差距过大，说明出现了过拟合，因此我们初步可以猜测，最佳参数在3和6之间，即4,5中的一个，其他参数一样可以通过学习曲线来进行可视化分析，判断是欠拟合还是过拟合，再分别进行针对处理；&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;通过以上的几步，可以非常简单、清晰的看到一个机器学习项目的全流程，其实再复杂的流程也是这些简单步骤的一些扩展，而更难的往往是对业务的理解，没有足够的理解很难得到好的结果，体现出来就是特征工程部分做的好坏，这里就需要各位小伙伴们奋发图强了，路漫漫啊；&lt;/p&gt;
&lt;h2 id=&quot;项目链接&quot;&gt;项目链接&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通篇浏览可以通过&lt;a href=&quot;https://nbviewer.jupyter.org/github/NemoHoHaloAi/boston_housing/blob/master/boston_housing.ipynb&quot;&gt;nbviewer&lt;/a&gt;来看；&lt;/li&gt;
&lt;li&gt;项目源文件、数据集文件可以通过&lt;a href=&quot;https://github.com/NemoHoHaloAi/boston_housing&quot;&gt;GitHub波士顿项目&lt;/a&gt;获取，欢迎Follow、Fork、Star；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;大家可以到我的Github上看看有没有其他需要的东西，目前主要是自己做的机器学习项目、Python各种脚本工具、数据分析挖掘项目以及Follow的大佬、Fork的项目等：&lt;a href=&quot;https://github.com/NemoHoHaloAi&quot; class=&quot;uri&quot;&gt;https://github.com/NemoHoHaloAi&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Oct 2019 14:25:00 +0000</pubDate>
<dc:creator>HoLoong</dc:creator>
<og:description>机器学习入门项目分享 波士顿房价预测 该分享源于Udacity机器学习进阶中的一个mini作业项目，用于入门非常合适，刨除了繁琐的部分，保留了最关键、基本的步骤，能够对机器学习基本流程有一个最清晰的认</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/helongBlog/p/11612128.html</dc:identifier>
</item>
<item>
<title>opencv之霍夫曼变换 - core!</title>
<link>http://www.cnblogs.com/sdu20112013/p/11616236.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/11616236.html</guid>
<description>&lt;p&gt;霍夫变换不仅可以找出图片中的直线,也可以找出圆,椭圆,三角形等等,只要你能定义出直线方程,圆形的方程等等.&lt;/p&gt;
&lt;p&gt;不得不说,现在网上的各种博客质量真的不行,网上一堆文章,乱TM瞎写,误人子弟.本身自己就没有理解的很清楚,又不去读算法实现的源码,写的云山雾罩的,越看越懵逼.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;霍夫变换本身的思路是很简明的.&lt;/strong&gt;这篇文章我们就以霍夫直线变换说明算法的思想.&lt;/p&gt;
&lt;h2 id=&quot;霍夫变换&quot;&gt;霍夫变换&lt;/h2&gt;
&lt;p&gt;思考一下,二维平面里我们怎么表达直线.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001093847798-1450309260.png&quot;/&gt;&lt;br/&gt;有两种表达方式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直角坐标系(也叫笛卡尔坐标系)&lt;/li&gt;
&lt;li&gt;极坐标系(也叫球坐标系)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一种就是最常见的直角坐标系下的表达:y=ax+b的形式.&lt;br/&gt;第二种就是极坐标系下的表达:&lt;br/&gt;我们把直角坐标系下的直线方程用r,theta去表达直线方程的斜率和截距.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001095413621-2108429704.png&quot;/&gt;&lt;br/&gt;则得到极坐标下的表达: r=xcosθ+ysinθ&lt;/p&gt;
&lt;p&gt;假设图像中某像素点坐标为(x,y).在直角坐标系下穿过这一点我们可以画出无数条直线.&lt;br/&gt;转化到一个r-θ坐标系下,我们就可以绘制出一条曲线.&lt;strong&gt;也就是r=xcosθ+ysinθ中的x,y是已知数,θ和r是未知数&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001125326002-318269699.png&quot;/&gt;&lt;br/&gt;&lt;strong&gt;这条曲线上每一个θ对应一个r,代表了一条直线.这些直线的共同点是他们都穿过了坐标为(x,y)的像素点.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001130726384-1685500661.png&quot;/&gt;&lt;br/&gt;针对图像中的每一个像素点,我都可以绘制出一条曲线来表达穿过该点的无数条直线. 那曲线的交点代表什么呢? &lt;strong&gt;很显然,代表着交点处的(θ,r)所代表的直线即穿过了像素点A,又穿过了像素点B,像素点C....&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;怎么样叫做找到图中的一条直线&quot;&gt;怎么样叫做&quot;找到图中的一条直线&quot;&lt;/h3&gt;
&lt;p&gt;回到我们的问题,&lt;strong&gt;我们想找出图像中的一条线.意味着什么?&lt;/strong&gt;&lt;br/&gt;很多博客说了,意味着找出一条直线,尽可能多地穿过各个像素点.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001133529402-1383337569.png&quot;/&gt;&lt;br/&gt;我TM随便在图像上画直线,不都能穿过很多像素点吗?&lt;br/&gt;&lt;strong&gt;实际上,应该是找出一条直线尽可能多地穿过&quot;有效像素点&quot;.&lt;/strong&gt;这也是为什么霍夫变换前一定要先做边缘检测的原因.经过canny检测以后(不知道的参考&lt;a href=&quot;https://www.cnblogs.com/sdu20112013/p/11614059.html&quot;&gt;上一篇文章&lt;/a&gt;),得到的图像矩阵,只有在边缘处其像素灰度值才是比较大的,反映在图像上就是白色亮点,在非边缘处,其灰度值是0,反映在图像上就是黑色.&lt;strong&gt;这些代表了边缘的像素点就是有效像素点.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;即:&lt;strong&gt;假如我能找到这么一条直线,穿过了很多个有效像素点(这个就是我们需要调参的阈值),那我就说我在图像中找到了一条直线.&lt;/strong&gt; . 同理,找圆,找三角形还是找任意形状都是一个道理.&lt;/p&gt;
&lt;p&gt;比方说,下面这个图&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001134054665-2084602480.png&quot;/&gt;&lt;br/&gt;你就找不到一条直线,穿过很多个白点.所以图中是不存在直线的.&lt;/p&gt;
&lt;h3 id=&quot;霍夫变换的过程&quot;&gt;霍夫变换的过程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;canny边缘检测提取出边缘&lt;/li&gt;
&lt;li&gt;对边缘图像中的每个像素点,&lt;br/&gt;伪代码如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;for (every pixel)
{
    if(pixel is effective edge pixel)
    {
        for(int theta = 0; theta &amp;lt; 360; theta++)
        {
            r=xcosθ+ysinθ;//x,y为pixel坐标
            accum(theta,r) += 1; //(theta,r)所代表的直线经过的像素点数量加1
        }
    }
}

for(every element in accum)
{
    if (count of (theta,r) &amp;gt; thershold)
    {
        find line (theta,r)
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;opencv示例&quot;&gt;opencv示例&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.opencv.org/master/dd/d1a/group__imgproc__feature.html#ga46b4e588934f6c8dfd509cc6e0e4545a&quot;&gt;houghlines api&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001135506893-101291161.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001135533150-960040493.png&quot;/&gt;&lt;br/&gt;其中, double rho, double theta,决定了最终有多少种(theta,r)的组合.决定了过每个像素点的线的可能情况.这个值越小,粒度就越细,需要的计算量也越大. 一般取rho=1,即1像素.theta取1度.&lt;br/&gt;下面是一个提取车位图片中直线的示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import sys
import math
import cv2 as cv
import numpy as np
def test():
    src = cv.imread(&quot;/home/sc/disk/keepgoing/opencv_test/houghtest.jpg&quot;)
    src = cv.GaussianBlur(src, (3, 3), 0)
    gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)
    
    dst = cv.Canny(src, 150, 300, None, 3)
    lines = cv.HoughLines(dst, 1, np.pi / 180, 150, None, 0, 0)
    
    # Copy edges to the images that will display the results in BGR
    cdst = cv.cvtColor(dst, cv.COLOR_GRAY2BGR)
    cdstP = np.copy(cdst)
    
    lines = cv.HoughLines(dst, 1, np.pi / 180, 200, None, 0, 0)
    
    if lines is not None:
        for i in range(0, len(lines)):
            rho = lines[i][0][0]
            theta = lines[i][0][1]
            a = math.cos(theta)
            b = math.sin(theta)
            x0 = a * rho
            y0 = b * rho
            pt1 = (int(x0 + 1000*(-b)), int(y0 + 1000*(a)))
            pt2 = (int(x0 - 1000*(-b)), int(y0 - 1000*(a)))
            cv.line(cdst, pt1, pt2, (0,0,255), 3, cv.LINE_AA)
    
    
    cv.imshow(&quot;origin&quot;,src)
    cv.imshow(&quot;dst1&quot;,dst)
    cv.imshow(&quot;dst2&quot;,cdst)
    if 27 == cv.waitKey():
        cv.destroyAllWindows()

test()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001150751514-1102085480.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/583030/201910/583030-20191001150819514-895915800.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;opencv源码解读&quot;&gt;opencv源码解读&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/opencv/opencv/blob/master/modules/imgproc/src/hough.cpp&quot;&gt;opencv 官方实现&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void
HoughLinesStandard( InputArray src, OutputArray lines, int type,
                    float rho, float theta,
                    int threshold, int linesMax,
                    double min_theta, double max_theta )
{
    CV_CheckType(type, type == CV_32FC2 || type == CV_32FC3, &quot;Internal error&quot;);

    Mat img = src.getMat();

    int i, j;
    float irho = 1 / rho;

    CV_Assert( img.type() == CV_8UC1 );
    CV_Assert( linesMax &amp;gt; 0 );

    const uchar* image = img.ptr();
    int step = (int)img.step;
    int width = img.cols;
    int height = img.rows;

    int max_rho = width + height;
    int min_rho = -max_rho;

    CV_CheckGE(max_theta, min_theta, &quot;max_theta must be greater than min_theta&quot;);

    int numangle = cvRound((max_theta - min_theta) / theta);
    int numrho = cvRound(((max_rho - min_rho) + 1) / rho);

#if defined HAVE_IPP &amp;amp;&amp;amp; IPP_VERSION_X100 &amp;gt;= 810 &amp;amp;&amp;amp; !IPP_DISABLE_HOUGH
    if (type == CV_32FC2 &amp;amp;&amp;amp; CV_IPP_CHECK_COND)
    {
        IppiSize srcSize = { width, height };
        IppPointPolar delta = { rho, theta };
        IppPointPolar dstRoi[2] = {{(Ipp32f) min_rho, (Ipp32f) min_theta},{(Ipp32f) max_rho, (Ipp32f) max_theta}};
        int bufferSize;
        int nz = countNonZero(img);
        int ipp_linesMax = std::min(linesMax, nz*numangle/threshold);
        int linesCount = 0;
        std::vector&amp;lt;Vec2f&amp;gt; _lines(ipp_linesMax);
        IppStatus ok = ippiHoughLineGetSize_8u_C1R(srcSize, delta, ipp_linesMax, &amp;amp;bufferSize);
        Ipp8u* buffer = ippsMalloc_8u_L(bufferSize);
        if (ok &amp;gt;= 0) {ok = CV_INSTRUMENT_FUN_IPP(ippiHoughLine_Region_8u32f_C1R, image, step, srcSize, (IppPointPolar*) &amp;amp;_lines[0], dstRoi, ipp_linesMax, &amp;amp;linesCount, delta, threshold, buffer);};
        ippsFree(buffer);
        if (ok &amp;gt;= 0)
        {
            lines.create(linesCount, 1, CV_32FC2);
            Mat(linesCount, 1, CV_32FC2, &amp;amp;_lines[0]).copyTo(lines);
            CV_IMPL_ADD(CV_IMPL_IPP);
            return;
        }
        setIppErrorStatus();
    }
#endif


    Mat _accum = Mat::zeros( (numangle+2), (numrho+2), CV_32SC1 );
    std::vector&amp;lt;int&amp;gt; _sort_buf;
    AutoBuffer&amp;lt;float&amp;gt; _tabSin(numangle);
    AutoBuffer&amp;lt;float&amp;gt; _tabCos(numangle);
    int *accum = _accum.ptr&amp;lt;int&amp;gt;();
    float *tabSin = _tabSin.data(), *tabCos = _tabCos.data();

    // create sin and cos table
    createTrigTable( numangle, min_theta, theta,
                     irho, tabSin, tabCos);

    // stage 1. fill accumulator
    for( i = 0; i &amp;lt; height; i++ )
        for( j = 0; j &amp;lt; width; j++ )
        {
            if( image[i * step + j] != 0 )
                for(int n = 0; n &amp;lt; numangle; n++ )
                {
                    int r = cvRound( j * tabCos[n] + i * tabSin[n] );
                    r += (numrho - 1) / 2;
                    accum[(n+1) * (numrho+2) + r+1]++;
                }
        }

    // stage 2. find local maximums
    findLocalMaximums( numrho, numangle, threshold, accum, _sort_buf );

    // stage 3. sort the detected lines by accumulator value
    std::sort(_sort_buf.begin(), _sort_buf.end(), hough_cmp_gt(accum));

    // stage 4. store the first min(total,linesMax) lines to the output buffer
    linesMax = std::min(linesMax, (int)_sort_buf.size());
    double scale = 1./(numrho+2);

    lines.create(linesMax, 1, type);
    Mat _lines = lines.getMat();
    for( i = 0; i &amp;lt; linesMax; i++ )
    {
        LinePolar line;
        int idx = _sort_buf[i];
        int n = cvFloor(idx*scale) - 1;
        int r = idx - (n+1)*(numrho+2) - 1;
        line.rho = (r - (numrho - 1)*0.5f) * rho;
        line.angle = static_cast&amp;lt;float&amp;gt;(min_theta) + n * theta;
        if (type == CV_32FC2)
        {
            _lines.at&amp;lt;Vec2f&amp;gt;(i) = Vec2f(line.rho, line.angle);
        }
        else
        {
            CV_DbgAssert(type == CV_32FC3);
            _lines.at&amp;lt;Vec3f&amp;gt;(i) = Vec3f(line.rho, line.angle, (float)accum[idx]);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;stage1即核心逻辑,挨个遍历有效像素,统计出各种(theta,r)代表的直线穿过的像素点点的数量&lt;/p&gt;
&lt;p&gt;Mat _accum = Mat::zeros( (numangle+2), (numrho+2), CV_32SC1 );&lt;br/&gt;可以看到统计直线穿过的点数量的矩阵的个数是 (2 + numangle) x (numrho+2),即与我们传入的double rho, double theta有关.&lt;strong&gt;这个值越小,相应的我们搜索的直线数量就越多&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;opencv的实现里有一些可能是出于工程上的考虑,这点不太确定,&lt;/strong&gt;比如这里为什么要(2 + numangle) x (numrho+2) 而不是 numangle x numrho&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int max_rho = width + height;
int min_rho = -max_rho;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么是w + h,而没有用开平方根求对角线长度.&lt;br/&gt;希望知道的朋友可以留言告诉我.&lt;/p&gt;
&lt;p&gt;// stage 2. find local maximums&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void
findLocalMaximums( int numrho, int numangle, int threshold,
                   const int *accum, std::vector&amp;lt;int&amp;gt;&amp;amp; sort_buf )
{
    for(int r = 0; r &amp;lt; numrho; r++ )
        for(int n = 0; n &amp;lt; numangle; n++ )
        {
            int base = (n+1) * (numrho+2) + r+1;
            if( accum[base] &amp;gt; threshold &amp;amp;&amp;amp;
                accum[base] &amp;gt; accum[base - 1] &amp;amp;&amp;amp; accum[base] &amp;gt;= accum[base + 1] &amp;amp;&amp;amp;
                accum[base] &amp;gt; accum[base - numrho - 2] &amp;amp;&amp;amp; accum[base] &amp;gt;= accum[base + numrho + 2] )
                sort_buf.push_back(base);
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;寻找计数的局部最大值.类似于非极大值抑制.进一步细化检测到的直线,把局部的很相似的直线只取最精准的.&lt;/p&gt;
&lt;p&gt;// stage 3. sort the detected lines by accumulator value&lt;br/&gt;按accum数量大小排序&lt;/p&gt;
&lt;p&gt;// stage 4. store the first min(total,linesMax) lines to the output buffer&lt;br/&gt;保存前n条lines到输出Buffer.&lt;/p&gt;
</description>
<pubDate>Tue, 01 Oct 2019 13:41:00 +0000</pubDate>
<dc:creator>core!</dc:creator>
<og:description>霍夫变换不仅可以找出图片中的直线,也可以找出圆,椭圆,三角形等等,只要你能定义出直线方程,圆形的方程等等. 不得不说,现在网上的各种博客质量真的不行,网上一堆文章,乱TM瞎写,误人子弟.本身自己就没有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdu20112013/p/11616236.html</dc:identifier>
</item>
<item>
<title>如何免费使用GPU跑深度学习代码 - 凌逆战</title>
<link>http://www.cnblogs.com/LXP-Never/p/11614053.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LXP-Never/p/11614053.html</guid>
<description>&lt;p&gt;　　从事深度学习的研究者都知道，深度学习代码需要设计海量的数据，需要很大很大很大(重要的事情说三遍)的&lt;strong&gt;计算量&lt;/strong&gt;，以至于CPU算不过来，需要通过GPU帮忙，但这必不意味着CPU的性能没GPU强，CPU是那种综合性的，GPU是专门用来做图像渲染的，这我们大家都知道，做图像矩阵的计算GPU更加在行，应该我们一般把深度学习程序让GPU来计算，事实也证明GPU的计算速度比CPU块，但是(&lt;span&gt;但是前面的话都是废话&lt;/span&gt;)我们穷，买不起呀，一块1080Ti现在也要3500左右，2080Ti要9000左右，具体价格还要看显存大小，因此本文给大家带来了福利——Google免费的GPU Colaboratory。&lt;/p&gt;

&lt;p&gt;　　Google Colaboratory是谷歌开放的一款研究工具，主要用于机器学习的开发研究，这款工具现在可以&lt;strong&gt;&lt;span&gt;免费使用&lt;/span&gt;&lt;/strong&gt;，但是不是永久免费暂时还不确定，Google Colab最大的好处是给广大开发AI者提供免费的GPU使用！GPU型号是Tesla K80，你可以在上面轻松地跑例如：Keras、Tensorflow、Pytorch等框架。&lt;/p&gt;
&lt;p&gt;　　Colabortory是一个jupyter notebook环境，它支持python2和python3，还包括TPU和GPU加速，该软件与Google云盘硬盘集成，用户可以轻松共享项目或将其他共享项目复制到自己的帐户中。&lt;/p&gt;

&lt;h2&gt;1、登录谷歌云盘&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://drive.google.com/drive/my-drive&quot;&gt;https://drive.google.com/drive/my-drive&lt;/a&gt;（没有账号的可以注册一个）&lt;/p&gt;
&lt;p&gt;(1)、右键新建文件夹，作为我们的项目文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930193233187-133716050.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2、创建Colab文件&lt;/h2&gt;
&lt;p&gt;右键在更多里面选择google Colaboratry（如果没有Colaboratory需要在关联更多应用里面关联Colaboratory）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930193356506-606502682.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;429&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3、开始使用&lt;/h2&gt;
&lt;p&gt;这时候会直接跳转到Colaboratory界面，这个界面很像Jupyter Notebook，Jupyter的命令在Colaboratory一样适用，值得一提的是，Colab不仅可以运行Python代码，只要在命令前面加一个&quot;  ！&quot;，这条命令就变成了linux命令，比如我们可以&quot; ! ls&quot;查看文件夹文件，还可以!pip安装库。以及运行py程序!python2 temp.py&lt;/p&gt;
&lt;p&gt;可以写一段代码进行测试&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930205555388-1417198206.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更改工作目录，在Colab中cd命令是无效的，切换工作目录使用&lt;span&gt;chdir&lt;/span&gt;函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
!pwd &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用 pwd 命令显示工作路径&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; /content&lt;/span&gt;
!ls &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看的是 content 文件夹下有哪些文件&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sample_data&lt;/span&gt;
!ls &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;drive/My Drive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TensorFlow （这就是我们之前创建的那个文件夹）&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 更改工作目录&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
os.chdir(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/content/drive/My Drive/TensorFlow&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
os.getcwd()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; '/content/drive/My Drive/TensorFlow'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;重新启动Colab命令：！kill -9 -1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(3)、选择配置环境&lt;/p&gt;
&lt;p&gt;　　我们大家肯定会疑虑，上述方法跑的那段程序是不是用GPU跑的呢？不是，想要用GPU跑程序我们还需要配置环境，&lt;/p&gt;
&lt;p&gt;　　点击工具栏“修改”，选择笔记本设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930194046049-19118800.png&quot; alt=&quot;&quot; width=&quot;205&quot; height=&quot;367&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930194136055-289759682.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在运行时类型我们可以选择Python 2或Python 3，硬件加速器我们可以选择GPU或者TPU&lt;span&gt;（后面会讲到）&lt;/span&gt;，或者None什么都不用。&lt;/p&gt;

&lt;h2&gt;从本地加载数据&lt;/h2&gt;
&lt;h3&gt;从本地上传数据&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;files.upload&lt;/code&gt; 会返回已上传文件的字典。 此字典的键为文件名，值为已上传的数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; google.colab &lt;span&gt;import&lt;/span&gt;&lt;span&gt; files

uploaded &lt;/span&gt;=&lt;span&gt; files.upload()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; fn &lt;span&gt;in&lt;/span&gt;&lt;span&gt; uploaded.keys():
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;用户上传的文件 &quot;{name}&quot; 有 {length} bytes&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(
      name&lt;/span&gt;=fn, length=len(uploaded[fn])))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们运行该段程序之后，就会让我们选择本地文件，点击上传后，该文件就能被读取了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191001185633079-74525977.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;将文件下载到本地&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; google.colab &lt;span&gt;import&lt;/span&gt;&lt;span&gt; files

files.download(&lt;/span&gt;&lt;span&gt;'./&lt;/span&gt;&lt;span&gt;example.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下载文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;从谷歌云盘加载数据&lt;/h2&gt;
&lt;p&gt;使用授权代码在运行时装载 Google 云端硬盘&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; google.colab &lt;span&gt;import&lt;/span&gt;&lt;span&gt; drive
drive.mount(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/content/gdrive&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Colab中运行上述代码，会出现一段链接，点击链接，复制链接中的密钥，输入到Colab中就可以成功把Colab与谷歌云盘相连接，连接后进行路径切换，就可以直接读取谷歌云盘数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201910/1433301-20191001190542426-1039062561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为了不每次都在代码中更改超参数，您可以简单地将表单添加到Google Colab。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930215751500-1367479133.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930215818108-1796027022.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击之后就会出现左右两个框，我们在左框中输入&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930220821135-444027570.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; @title 字符串&lt;/span&gt;
&lt;span&gt;
text &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;@param {type:&quot;string&quot;}&lt;/span&gt;
dropdown = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1st option&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;@param [&quot;1st option&quot;, &quot;2nd option&quot;, &quot;3rd option&quot;]&lt;/span&gt;
text_and_dropdown = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;value&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;@param [&quot;选项1&quot;, &quot;选项2&quot;, &quot;选项3&quot;] {allow-input: true}&lt;/span&gt;

&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(text)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(dropdown)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(text_and_dropdown)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930221857076-1456262768.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;双击右边栏可以隐藏代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930221927112-1031476863.png&quot; alt=&quot;&quot; width=&quot;537&quot; height=&quot;212&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先我们要让Colab连上GPU，导航栏--&amp;gt;编辑--&amp;gt;笔记本设置--&amp;gt;选择GPU&lt;/p&gt;
&lt;p&gt;接下来我们来确认可以使用Tensorflow连接到GPU&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

device_name &lt;/span&gt;=&lt;span&gt; tf.test.gpu_device_name()
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; device_name != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/device:GPU:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; SystemError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;没有发现GPU device&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Found GPU at: {}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(device_name))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Found GPU at: /device:GPU:0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以在Colab上运行以下代码测试GPU和CPU的速度&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('9ccd558a-aa1f-4250-a601-4b66f7bfb99a')&quot; readability=&quot;39.5&quot;&gt;&lt;img id=&quot;code_img_closed_9ccd558a-aa1f-4250-a601-4b66f7bfb99a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_9ccd558a-aa1f-4250-a601-4b66f7bfb99a&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('9ccd558a-aa1f-4250-a601-4b66f7bfb99a',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_9ccd558a-aa1f-4250-a601-4b66f7bfb99a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; timeit

config &lt;/span&gt;=&lt;span&gt; tf.ConfigProto()
config.gpu_options.allow_growth &lt;/span&gt;=&lt;span&gt; True

with tf.device(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/cpu:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
  random_image_cpu &lt;/span&gt;= tf.random_normal((100, 100, 100, 3&lt;span&gt;))
  net_cpu &lt;/span&gt;= tf.layers.conv2d(random_image_cpu, 32, 7&lt;span&gt;)
  net_cpu &lt;/span&gt;=&lt;span&gt; tf.reduce_sum(net_cpu)

with tf.device(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/device:GPU:0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;):
  random_image_gpu &lt;/span&gt;= tf.random_normal((100, 100, 100, 3&lt;span&gt;))
  net_gpu &lt;/span&gt;= tf.layers.conv2d(random_image_gpu, 32, 7&lt;span&gt;)
  net_gpu &lt;/span&gt;=&lt;span&gt; tf.reduce_sum(net_gpu)

sess &lt;/span&gt;= tf.Session(config=&lt;span&gt;config)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 确保TF可以检测到GPU&lt;/span&gt;
&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
  sess.run(tf.global_variables_initializer())
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; tf.errors.InvalidArgumentError:
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(
      &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n\n此错误很可能表示此笔记本未配置为使用GPU。 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
      &lt;span&gt;'&lt;/span&gt;&lt;span&gt;通过命令面板（CMD/CTRL-SHIFT-P）或编辑菜单在笔记本设置中更改此设置.\n\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; cpu():
  sess.run(net_cpu)
  
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; gpu():
  sess.run(net_gpu)
  
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行一次进行测试&lt;/span&gt;
&lt;span&gt;cpu()
gpu()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 多次运行op&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;将100*100*100*3通过滤波器卷积到32*7*7*3(批处理x高度x宽度x通道)大小的图像&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;'&lt;/span&gt;&lt;span&gt;计算10次运训时间的总和&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CPU (s):&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
cpu_time &lt;/span&gt;= timeit.timeit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, number=10, setup=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from __main__ import cpu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(cpu_time)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GPU (s):&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
gpu_time &lt;/span&gt;= timeit.timeit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gpu()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, number=10, setup=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;from __main__ import gpu&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(gpu_time)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;GPU加速超过CPU: {}倍&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.format(int(cpu_time/&lt;span&gt;gpu_time)))

sess.close()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; CPU (s):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 3.593296914000007&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; GPU (s):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 0.1831514239999592&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; GPU加速超过CPU: 19倍&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;首先我们要让Colab连上GPU，导航栏--&amp;gt;编辑--&amp;gt;笔记本设置--&amp;gt;选择TPU&lt;/p&gt;
&lt;p&gt;接下来我们来确认可以使用Tensorflow连接到TPU&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pprint
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLAB_TPU_ADDR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.environ:
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;您没有连接到TPU，请完成上述操作&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
  tpu_address &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;grpc://&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + os.environ[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;COLAB_TPU_ADDR&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TPU address is&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, tpu_address)     
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; TPU address is grpc://10.97.206.146:8470&lt;/span&gt;
&lt;span&gt;
  with tf.Session(tpu_address) as session:
    devices &lt;/span&gt;=&lt;span&gt; session.list_devices()
    
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TPU devices:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  pprint.pprint(devices)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用TPU进行简单运算&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; add_op(x, y):
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y
  
x &lt;/span&gt;= tf.placeholder(tf.float32, [10&lt;span&gt;,])
y &lt;/span&gt;= tf.placeholder(tf.float32, [10&lt;span&gt;,])
tpu_ops &lt;/span&gt;=&lt;span&gt; tf.contrib.tpu.rewrite(add_op, [x, y])
  
session &lt;/span&gt;=&lt;span&gt; tf.Session(tpu_address)
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Initializing...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  session.run(tf.contrib.tpu.initialize_system())
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Running ops&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(session.run(tpu_ops, {x: np.arange(10), y: np.arange(10&lt;span&gt;)}))
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; [array([ 0.,  2.,  4.,  6.,  8., 10., 12., 14., 16., 18.], dtype=float32)]&lt;/span&gt;
&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 目前，tpu会话必须与关闭会话分开关闭。&lt;/span&gt;
&lt;span&gt;  session.run(tf.contrib.tpu.shutdown_system())
  session.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;想要在Google Colab中运行Tensorboard，请运行以下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
!wget https://bin.equinox.io/c/4VmDzA7iaHb/ngrok-stable-linux-&lt;span&gt;amd64.zip
!unzip ngrok&lt;/span&gt;-stable-linux-&lt;span&gt;amd64.zip

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加TensorBoard的路径&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
log_dir &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tb_logs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; os.path.exists(log_dir):
  os.makedirs(log_dir)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开启ngrok service，绑定port 6006(tensorboard)&lt;/span&gt;
get_ipython().system_raw(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tensorboard --logdir {} --host 0.0.0.0 --port 6006 &amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(log_dir))
get_ipython().system_raw(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./ngrok http 6006 &amp;amp;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 产生网站，点击网站访问tensorboard&lt;/span&gt;
!curl -s http://localhost:4040/api/tunnels | python3 -&lt;span&gt;c \
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;import sys, json; print(json.load(sys.stdin)['tunnels'][0]['public_url'])&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p id=&quot;10b2&quot; data-selectable-paragraph=&quot;&quot;&gt;您可以使用创建的ngrok.io URL 跟踪Tensorboard日志。您将在输出末尾找到URL。请注意，您的Tensorboard日志将保存到tb_logs目录。当然，您可以更改目录名称。&lt;/p&gt;
&lt;p data-selectable-paragraph=&quot;&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930213537589-388278787.png&quot; alt=&quot;&quot; width=&quot;734&quot; height=&quot;473&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;lf lg dz ap lh b li lj lk ll lm ln lo lp lq lr ls&quot; data-selectable-paragraph=&quot;&quot;&gt;&lt;span class=&quot;lh lt&quot;&gt;&lt;span&gt;之后，我们可以看到Tensorboard发挥作用！&lt;/span&gt;&lt;span&gt;运行以下代码后，您可以通过ngrok URL跟踪Tensorboard日志。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ecded09c-d70f-443b-976d-a16bb0ec89c0')&quot; readability=&quot;61.5&quot;&gt;&lt;img id=&quot;code_img_closed_ecded09c-d70f-443b-976d-a16bb0ec89c0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ecded09c-d70f-443b-976d-a16bb0ec89c0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ecded09c-d70f-443b-976d-a16bb0ec89c0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ecded09c-d70f-443b-976d-a16bb0ec89c0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;118&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; &lt;span&gt;__future__&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; print_function
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; keras
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; mnist
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Sequential
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dense, Dropout, Flatten
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Conv2D, MaxPooling2D
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras &lt;span&gt;import&lt;/span&gt;&lt;span&gt; backend as K
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.callbacks &lt;span&gt;import&lt;/span&gt;&lt;span&gt; TensorBoard

batch_size &lt;/span&gt;= 128&lt;span&gt;
num_classes &lt;/span&gt;= 10&lt;span&gt;
epochs &lt;/span&gt;= 12

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; input image dimensions&lt;/span&gt;
img_rows, img_cols = 28, 28

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; the data, shuffled and split between train and test sets&lt;/span&gt;
(x_train, y_train), (x_test, y_test) =&lt;span&gt; mnist.load_data()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; K.image_data_format() == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;channels_first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    x_train &lt;/span&gt;= x_train.reshape(x_train.shape[0], 1&lt;span&gt;, img_rows, img_cols)
    x_test &lt;/span&gt;= x_test.reshape(x_test.shape[0], 1&lt;span&gt;, img_rows, img_cols)
    input_shape &lt;/span&gt;= (1&lt;span&gt;, img_rows, img_cols)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    x_train &lt;/span&gt;= x_train.reshape(x_train.shape[0], img_rows, img_cols, 1&lt;span&gt;)
    x_test &lt;/span&gt;= x_test.reshape(x_test.shape[0], img_rows, img_cols, 1&lt;span&gt;)
    input_shape &lt;/span&gt;= (img_rows, img_cols, 1&lt;span&gt;)

x_train &lt;/span&gt;= x_train.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
x_test &lt;/span&gt;= x_test.astype(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
x_train &lt;/span&gt;/= 255&lt;span&gt;
x_test &lt;/span&gt;/= 255
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;x_train shape:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, x_train.shape)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(x_train.shape[0], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;train samples&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(x_test.shape[0], &lt;span&gt;'&lt;/span&gt;&lt;span&gt;test samples&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; convert class vectors to binary class matrices&lt;/span&gt;
y_train =&lt;span&gt; keras.utils.to_categorical(y_train, num_classes)
y_test &lt;/span&gt;=&lt;span&gt; keras.utils.to_categorical(y_test, num_classes)

model &lt;/span&gt;=&lt;span&gt; Sequential()
model.add(Conv2D(&lt;/span&gt;32, kernel_size=(3, 3&lt;span&gt;),
                 activation&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                 input_shape&lt;/span&gt;=&lt;span&gt;input_shape))
model.add(Conv2D(&lt;/span&gt;64, (3, 3), activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
model.add(MaxPooling2D(pool_size&lt;/span&gt;=(2, 2&lt;span&gt;)))
model.add(Dropout(&lt;/span&gt;0.25&lt;span&gt;))
model.add(Flatten())
model.add(Dense(&lt;/span&gt;128, activation=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
model.add(Dropout(&lt;/span&gt;0.5&lt;span&gt;))
model.add(Dense(num_classes, activation&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))

model.compile(loss&lt;/span&gt;=&lt;span&gt;keras.losses.categorical_crossentropy,
              optimizer&lt;/span&gt;=&lt;span&gt;keras.optimizers.Adadelta(),
              metrics&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])


tbCallBack &lt;/span&gt;= TensorBoard(log_dir=&lt;span&gt;LOG_DIR, 
                         histogram_freq&lt;/span&gt;=1&lt;span&gt;,
                         write_graph&lt;/span&gt;=&lt;span&gt;True,
                         write_grads&lt;/span&gt;=&lt;span&gt;True,
                         batch_size&lt;/span&gt;=&lt;span&gt;batch_size,
                         write_images&lt;/span&gt;=&lt;span&gt;True)

model.fit(x_train, y_train,
          batch_size&lt;/span&gt;=&lt;span&gt;batch_size,
          epochs&lt;/span&gt;=&lt;span&gt;epochs,
          verbose&lt;/span&gt;=1&lt;span&gt;,
          validation_data&lt;/span&gt;=&lt;span&gt;(x_test, y_test),
          callbacks&lt;/span&gt;=&lt;span&gt;[tbCallBack])
score &lt;/span&gt;= model.evaluate(x_test, y_test, verbose=&lt;span&gt;0)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test loss:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, score[0])
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test accuracy:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, score[1])
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1433301/201909/1433301-20190930213710839-2071015424.png&quot; alt=&quot;&quot; width=&quot;877&quot; height=&quot;507&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://colab.research.google.com/notebooks/welcome.ipynb&quot; target=&quot;_blank&quot;&gt;Colaboratory官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/deep-learning-turkey/google-colab-free-gpu-tutorial-e113627b9f5d&quot; target=&quot;_blank&quot;&gt;一位外国小哥写的博客，总结的不错&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Oct 2019 12:25:00 +0000</pubDate>
<dc:creator>凌逆战</dc:creator>
<og:description>从事深度学习的研究者都知道，深度学习代码需要设计海量的数据，需要很大很大很大(重要的事情说三遍)的计算量，以至于CPU算不过来，需要通过GPU帮忙，但这必不意味着CPU的性能没GPU强，CPU是那种综</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LXP-Never/p/11614053.html</dc:identifier>
</item>
<item>
<title>每个人都要学的图片压缩终极奥义，有效解决 Android 程序 OOM - __yuanhao</title>
<link>http://www.cnblogs.com/yuanhao-1999/p/11615941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanhao-1999/p/11615941.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16244318-94bffe13e9e784fc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;学Android&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;由来&quot;&gt;# 由来&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在我们编写 &lt;code&gt;Android&lt;/code&gt; 程序的时候，几乎永远逃避不了图片压缩的难题。除了应用图标之外，我们所要显示的图片基本上只有两个来源：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;来自网络下载&lt;/li&gt;
&lt;li&gt;本地相册中加载&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;不管是网上下载下来的也好，还是从系统图片库中读取的图片，都有一个相同的特点：像素一帮较高。同时我们都知道，&lt;code&gt;Android&lt;/code&gt; 系统分配给我们每个应用的内存是有限的，由于解析、加载一张图片，需要占用的内存大小，是远大于图片自身大小的。所以，这时程序就可能因为占用了过多的内存，从而出现&lt;code&gt;OOM&lt;/code&gt; 现象。那么什么是 &lt;code&gt;OOM&lt;/code&gt; 呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Exception java.lang.OutOfMemoryError: Failed to allocate a 916 byte allocation with 8388608 free bytes and 369MB until OOM; failed due to fragmentation (required continguous free 65536 bytes for a new buffer where largest contiguous free 32768 bytes)
java.nio.CharBuffer.allocate (CharBuffer.java:54)
java.nio.charset.CharsetDecoder.allocateMore (CharsetDecoder.java:226)
java.nio.charset.CharsetDecoder.decode (CharsetDecoder.java:188)
org.java_websocket.util.Charsetfunctions.stringUtf8 (Charsetfunctions.java:77)
org.java_websocket.WebSocketImpl.decodeFrames (WebSocketImpl.java:375)
org.java_websocket.WebSocketImpl.decode (WebSocketImpl.java:158)
org.java_websocket.client.WebSocketClient.run (WebSocketClient.java:185)
java.lang.Thread.run (Thread.java:818)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;OOM&lt;/code&gt; 即 &lt;code&gt;OutOfMemory&lt;/code&gt; 异常，也就是我们所说的 内存溢出 ，其一般表现为应用闪退等现象。那么我们该如何下手去解决呢？&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;# 解决方案&lt;/h2&gt;
&lt;p&gt;首先我们发现，我们所加载的这些图片的分辨率，要比我们手机屏幕高得多，更有甚者，我们在一个拇指大的控件上，去加载一个 4k 大图是完全没有必要的，也就是说，如果我们能让每个控件上都去显示相应大小的图片，那么这个问题也就迎刃而解了&lt;/p&gt;
&lt;p&gt;那么，要怎样才能达到图片与控件的对号入座？这时我们就引进了图片压缩的方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，获得原图片大小&lt;/li&gt;
&lt;li&gt;其次，获取控件大小&lt;/li&gt;
&lt;li&gt;接着，获取我们图片和控件的比例&lt;/li&gt;
&lt;li&gt;最后，根据这一比例，将图片压缩为适合显示的大小&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么就让我们开始吧：&lt;/p&gt;
&lt;h2 id=&quot;获取原图大小&quot;&gt;# 获取原图大小&lt;/h2&gt;
&lt;p&gt;我们都知道，&lt;code&gt;Android 向我们提供了 BitmapFactory&lt;/code&gt; 这个类，在这个类中有着诸如：&lt;code&gt;decodeResource()&lt;/code&gt; &lt;code&gt;decodeFile()&lt;/code&gt; &lt;code&gt;decodeStream()&lt;/code&gt; 等:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Bitmap decodeResource(Resources res, int id)

public static Bitmap decodeFile(String pathName)

public static Bitmap decodeStream(InputStream is)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;其中&quot;&gt;其中：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;decodeResource() ： 用于解析资源文件，即 res 文件夹下的图片&lt;/li&gt;
&lt;li&gt;decodeFile() ： 用于解析系统相册中的图片&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;decodeStream() ： 用于解析输入输出流中图片通常，是采用 HttpClient 从下载的图片&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他的方法这里就不多说了，因为在源码中我们可有i看到，几乎所有的方法，最后都会将图片解析为流的形式，最后调用 &lt;code&gt;decodeStream()&lt;/code&gt; 方法，实例化出我们的 &lt;code&gt;Bitmap&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;虽然这些方法对我们是再熟悉不过的了，但对于某些初学者而言，却经常忽略了一个重要的内部类 ：&lt;code&gt;BitmapFactory.Options&lt;/code&gt; ，然而他确实我们图片压缩必不可少的，为什么需要这个参数呢？&lt;code&gt;Options&lt;/code&gt; 的对象用于确定需要生成的 Bitmap 即目标图片的参数。&lt;br/&gt;他的用法很简单，我们先 new 一个 &lt;code&gt;BitmapFactory.Options&lt;/code&gt; 对象。再去调用含有 &lt;code&gt;Options&lt;/code&gt; 参数的方法，如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public static Bitmap decodeResource(Resources res, int id, Options opts)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static Bitmap decodeResourceStream(@Nullable Resources res,@Nullable TypedValue value,@Nullable InputStream is, @Nullable Rect pad, @Nullable Options opts)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调用完之后我们发现，除了方法放回给我们一个实例化出来的 &lt;code&gt;Bitmap&lt;/code&gt; 图片之外，这个 &lt;code&gt;Options&lt;/code&gt; 对象中长度、宽度、类型等等属性，也都被设置成了了我们图片的相应属性。所以，我们很容易想到：通过将 &lt;code&gt;Options&lt;/code&gt; 对象传入，来获得图片的原始尺寸，为后期的压缩做准备，说干就干，我们将 &lt;code&gt;Options&lt;/code&gt; 对象，和 &lt;code&gt;Resources&lt;/code&gt;中一张 4k 图片的&lt;code&gt;id&lt;/code&gt; 一块传入上诉方法中，来尝试获得它的尺寸，结果我们发现：程序 &lt;code&gt;OOM&lt;/code&gt; 崩溃了！&lt;/p&gt;
&lt;p&gt;为什么会发生这种情况？首先我们想想我们为什么要获得这个&lt;code&gt;Options&lt;/code&gt; 对象？时为了获得图片的尺寸大小；那我们为什么要获得原图尺寸大小？是为了按照原图尺寸和控件尺寸的比例，将其压缩为适合显示的大小？那我们又为什么要去压缩它为合适的大小呢？是因为如果按照原大小去调用相应的 &lt;code&gt;decode...()&lt;/code&gt;方法解析图片，会导致内存占有率过高触发&lt;code&gt;OOM&lt;/code&gt; 异常，进而导致程序崩溃啊！没想到的是：结果我们为了获得 &lt;code&gt;Options&lt;/code&gt; 而调用了相应的 &lt;code&gt;decode...()&lt;/code&gt; 方法，的确 &lt;code&gt;Options&lt;/code&gt; 是复制了，但由于该方法适用于生成图片，也就是 &lt;code&gt;Bitmap&lt;/code&gt; 对象的。所以程序也在解析这张超大图的过程中&lt;code&gt;OOM&lt;/code&gt; 崩溃了&lt;/p&gt;
&lt;p&gt;那么难道就没方法了吗？&lt;/p&gt;
&lt;p&gt;有的，我之前说过：&lt;code&gt;Option&lt;/code&gt; 内部有着众多参数，其中有一个叫做： &lt;code&gt;inJustDecodeBounds&lt;/code&gt; 。这个参数默认值为&lt;code&gt;false&lt;/code&gt; 。但如果我们先把这个参数设置为 true 时，该方法便不在会去生成相应的 &lt;code&gt;Bitmap&lt;/code&gt; ，而仅仅是去测量图片的各种属性，如长度、宽度、类型等等，然后放回一个 &lt;code&gt;null&lt;/code&gt; 。所以，我们很容易想到：可以先通过将 &lt;code&gt;inJustDecodeBounds&lt;/code&gt; 的值设为 &lt;code&gt;true&lt;/code&gt; ，再去调用相应的相应的 &lt;code&gt;decode...()&lt;/code&gt;方法，最后再将&lt;code&gt;inJustDecodeBounds&lt;/code&gt; 的值改回 &lt;code&gt;false&lt;/code&gt; 。这种做法有两个好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;既能获得图片大小，由于后续操作&lt;/li&gt;
&lt;li&gt;又成功避免了去解析图片，导致程序 &lt;code&gt;OOM&lt;/code&gt; 而崩溃。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但这恰恰是被很多人所忽略的一点。&lt;/p&gt;
&lt;h4 id=&quot;好了现在给出具体的实现&quot;&gt;好了，现在给出具体的实现：&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void calculateOptionsById(@NonNull Resources res,@NonNull BitmapFactory.Options options, int imgId) {
        BitmapFactory.decodeResource(res, imgId, options);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;大家可能发现，这里只将 &lt;code&gt;inJustDecodeBounds&lt;/code&gt; 设为&lt;code&gt;true&lt;/code&gt;却没有改回&lt;code&gt;false&lt;/code&gt; ，这是因为获得 &lt;code&gt;Options&lt;/code&gt; 只是图片压缩的第一步，我们在后续方法中将会进行修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何进行压缩&quot;&gt;# 如何进行压缩&lt;/h2&gt;
&lt;p&gt;我们继续看 &lt;code&gt;Options&lt;/code&gt; 的构成。我们发现，其中有个名为 &lt;code&gt;inSampleSize&lt;/code&gt; 的数据成员，他就是关键所在，那么他有着什么意义呢？&lt;/p&gt;
&lt;p&gt;这里我给大家举个例子，比如我这有张 4000*1000 像素的图片：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当我们把 &lt;code&gt;inSampleSize&lt;/code&gt; 的值设为 &lt;code&gt;4&lt;/code&gt;时，最后生成出来的图片大小将会是：1000 x 250 像素&lt;/li&gt;
&lt;li&gt;当我们把&lt;code&gt;inSampleSize&lt;/code&gt; 的值设为&lt;code&gt;5&lt;/code&gt;时，最后生成出来的图片大小将会是：800 x 200 像素。这是个什么概念？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这不仅仅是长宽都变为原来四分之一或者五分之一这么简单，而是其图片大小，直接变为原图的 &lt;code&gt;1/(n^2)&lt;/code&gt;！也就是说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果原图 &lt;code&gt;2MB&lt;/code&gt;，那么当 &lt;code&gt;inSampleSize&lt;/code&gt; 赋值为&lt;code&gt;4&lt;/code&gt;加载时就只需要 &lt;code&gt;0.125MB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;那 如果 &lt;code&gt;inSampleSize&lt;/code&gt; 赋值为 &lt;code&gt;5&lt;/code&gt; 呢？只需要 &lt;code&gt;0.08 MB&lt;/code&gt;！连&lt;code&gt;100k&lt;/code&gt; 都不到的小图啊！&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;那么下面我就给出这个方法的具体实现&quot;&gt;那么下面我就给出这个方法的具体实现：&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static int calculateInSamplesizeByOptions(@NonNull BitmapFactory.Options options, int reqWidth, int reqHeight) {
        int inSamplesize   = 1;
        int originalWidth  = options.outWidth;
        int originalHeight = options.outHeight;
        if (originalHeight &amp;gt; reqHeight || originalWidth &amp;gt; reqWidth) {
            int heightRatio = originalHeight / reqHeight;
            int widthRatio  = originalWidth  / reqWidth;
            inSamplesize = heightRatio &amp;gt; widthRatio ? heightRatio : widthRatio;
        }
        return inSamplesize;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们发现，这里我先计算出了，原图尺寸与目标大小大比例，在三目运算符中，将&lt;code&gt;inSamplesize&lt;/code&gt; 赋值为较大的一个。为什么不用小的那一个呢？这里我就卖个关子，大家可以在评论区中发表自己的想法&lt;/p&gt;
&lt;h2 id=&quot;生成目标图片&quot;&gt;# 生成目标图片&lt;/h2&gt;
&lt;p&gt;经过前面的两个步骤，想必大家已经能勾勒处这最后一步的做法了，思路非常简单：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先生成一个 &lt;code&gt;Options&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;Options 的 inJustDecodeBounds&lt;/code&gt;设置为&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接着调用方法一&lt;code&gt;calculateOptionsById&lt;/code&gt;获得原图尺寸到&lt;code&gt;Options&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;调用方法三&lt;code&gt;calculateInSamplesizeByOptions&lt;/code&gt; 获得相应的&lt;code&gt;inSampleSize&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;将 &lt;code&gt;Options&lt;/code&gt;的&lt;code&gt;inJustDecodeBounds&lt;/code&gt;改回 &lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;再次调用 &lt;code&gt;decode...()&lt;/code&gt;方法（这里是 &lt;code&gt;decodeResource&lt;/code&gt; ）获得压缩后的 &lt;code&gt;Bitmap&lt;/code&gt;对象&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;具体实现如下&quot;&gt;具体实现如下&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static Bitmap decodeBitmapById (@NonNull Resources res, int resId, int reqWidth, int reqHeight) {
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        calculateOptionsById(res, options, resId);
        options.inSampleSize = calculateInSamplesizeByOptions(options, reqWidth, reqHeight);
        options.inJustDecodeBounds = false;
        Bitmap bitmap = BitmapFactory.decodeResource(res, resId, options);
        return bitmap;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非常棒，我们赶紧看看效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16244318-db39640ec9a466d8?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;太棒了，几乎和原图效果一摸一样，但软件运行的流畅性确大大提高了！但是，这真的就完美了吗？&lt;/p&gt;
&lt;p&gt;最求完美的我们可能会有个想法：如果调用我们方法的人，或者说特殊时候的我们。不想用这个已经写好的 &lt;code&gt;decodeBitmapById&lt;/code&gt;方法，而是像自己通过前两个方法：&lt;code&gt;calculateOptionsById&lt;/code&gt; &lt;code&gt;calculateInSamplesizeByOptions&lt;/code&gt; 来实现图片压缩功能，这是问题就出现了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用 &lt;code&gt;calculateOptionsById&lt;/code&gt; 前可能忘记，设置 &lt;code&gt;inJustDecodeBound&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，进而导致计算超大图时，直接发生 &lt;code&gt;OOM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调用完 &lt;code&gt;calculateInSamplesizeByOptions&lt;/code&gt; 后可能忘记，设置&lt;code&gt;inJustDecodeBounds&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;，进而导致无法获得&lt;code&gt;Bitmap&lt;/code&gt; 对象，一脸懵逼&lt;/li&gt;
&lt;li&gt;啥都做了结果调用完 &lt;code&gt;calculateInSamplesizeByOptions&lt;/code&gt; 没把没回的值赋给 &lt;code&gt;options.inSampleSize&lt;/code&gt; ，白忙活一场&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，我们需要在优化一下：&lt;/p&gt;
&lt;p&gt;首先，在&lt;code&gt;calculateOptionsById&lt;/code&gt;中，默认将 &lt;code&gt;options.inJustDecodeBounds&lt;/code&gt; 设置为&lt;code&gt;true&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void calculateOptionsById(@NonNull Resources res,@NonNull BitmapFactory.Options options, int imgId) {
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeResource(res, imgId, options);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次，在 &lt;code&gt;calculateInSamplesizeByOptions&lt;/code&gt;最后，默认将 &lt;code&gt;options.inJustDecodeBounds&lt;/code&gt;设置为&lt;code&gt;false&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static int calculateInSamplesizeByOptions(@NonNull BitmapFactory.Options options, int reqWidth, int reqHeight) {
        int inSamplesize   = 1;
        int originalWidth  = options.outWidth;
        int originalHeight = options.outHeight;
        if (originalHeight &amp;gt; reqHeight || originalWidth &amp;gt; reqWidth) {
            int heightRatio = originalHeight / reqHeight;
            int widthRatio  = originalWidth  / reqWidth;
            inSamplesize = heightRatio &amp;gt; widthRatio ? heightRatio : widthRatio;
        }
        options.inJustDecodeBounds = false;
        return inSamplesize;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么不在该方法后面，对 &lt;code&gt;options.inSampleSize&lt;/code&gt;进行赋值呢？这主要是防止，有时我们可能只想得到计算相应比例来做其他操作，而不想改变原有属性，所以是否赋值，就交给用户去选择吧&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;# 总结&lt;/h2&gt;
&lt;p&gt;好了，到这里为止，历时有关图片压缩的所有坑坑洼洼都已经总结好了，我们从头理以边思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;借助&lt;code&gt;options.inJustDecodeBounds&lt;/code&gt; 参数赋值&lt;code&gt;true&lt;/code&gt;时，不生成图片的特性，将原图尺寸保存在 &lt;code&gt;Options&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;options&lt;/code&gt; 中原图尺寸与目标（控件）尺寸的比例，对 &lt;code&gt;options.inSampleSize&lt;/code&gt; 进行设置&lt;/li&gt;
&lt;li&gt;生成目标图片&lt;/li&gt;
&lt;li&gt;压缩的问题解决了，但是每次打开图片都压缩也太麻烦了！下面我将针对这个问题进行更有效地解决 ，有兴趣可以继续关注 &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/&quot;&gt;_yuanhao 的编程世界&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11582265.html&quot;&gt;Android 让你的 Room 搭上 RxJava 的顺风车 从重复的代码中解脱出来&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11534568.html&quot;&gt;ViewModel 和 ViewModelProvider.Factory：ViewModel 的创建者&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11202784.html&quot;&gt;单例模式-全局可用的 context 对象，这一篇就够了&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11102806.html&quot;&gt;缩放手势 ScaleGestureDetector 源码解析，这一篇就够了&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11049875.html&quot;&gt;Android 属性动画框架 ObjectAnimator、ValueAnimator ，这一篇就够了&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11061493.html&quot;&gt;看完这篇再不会 View 的动画框架，我跪搓衣板&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11081980.html&quot;&gt;看完这篇还不会 GestureDetector 手势检测，我跪搓衣板！&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11065219.html&quot;&gt;android 自定义控件之-绘制钟表盘&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11068467.html&quot;&gt;Android 进阶自定义 ViewGroup 自定义布局&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yuanhao-1999/p/11073398.html&quot;&gt;看完这篇还不会自定义 View ，我跪搓衣板&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;p&gt;定期分享&lt;code&gt;Android开发&lt;/code&gt;湿货，追求文章&lt;code&gt;幽默与深度&lt;/code&gt;的完美统一。&lt;/p&gt;
&lt;p&gt;源码 Demo 链接：&lt;strong&gt;&lt;a href=&quot;https://github.com/FishInWater-1999/Drop/blob/master/app/src/main/java/com/example/drop/utils/BitmapBuilder.java&quot;&gt;Drop 我第一次写的 Android 项目，希望大家点歌 star~ 谢谢！&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;请点赞因为你的鼓励是我写作的最大动力&quot;&gt;请点赞！因为你的鼓励是我写作的最大动力！&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16244318-ee4e876332115e5d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;学Android&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Oct 2019 11:39:00 +0000</pubDate>
<dc:creator>__yuanhao</dc:creator>
<og:description>由来 在我们编写 程序的时候，几乎永远逃避不了图片压缩的难题。除了应用图标之外，我们所要显示的图片基本上只有两个来源： 来自网络下载 本地相册中加载 不管是网上下载下来的也好，还是从系统图片库中读取的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanhao-1999/p/11615941.html</dc:identifier>
</item>
<item>
<title>基于C#的机器学习--c# .NET中直观的深度学习 - 王振耀</title>
<link>http://www.cnblogs.com/wangzhenyao1994/p/11615754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangzhenyao1994/p/11615754.html</guid>
<description>&lt;p&gt;在本章中，将会学到:&lt;/p&gt;
&lt;p&gt;l  如何使用Kelp.Net来执行自己的测试&lt;/p&gt;
&lt;p&gt;l  如何编写测试&lt;/p&gt;
&lt;p&gt;l  如何对函数进行基准测试&lt;/p&gt;
&lt;p&gt;Kelp.Net是一个用c#编写的深度学习库。由于能够将函数链到函数堆栈中，它在一个非常灵活和直观的平台中提供了惊人的功能。它还充分利用OpenCL语言平台，在支持cpu和gpu的设备上实现无缝操作。深度学习是一个非常强大的工具，对Caffe和Chainer模型加载的本机支持使这个平台更加强大。您将看到，只需几行代码就可以创建一个100万个隐藏层的深度学习网络。&lt;/p&gt;
&lt;p&gt;Kelp.Net还使得从磁盘存储中保存和加载模型变得非常容易。这是一个非常强大的特性，允许您执行训练、保存模型，然后根据需要加载和测试。它还使代码的产品化变得更加容易，并且真正地将训练和测试阶段分离开来。&lt;/p&gt;
&lt;p&gt;其中，Kelp.Net是一个非常强大的工具，可以帮助你更好地学习和理解各种类型的函数、它们的交互和性能。例如，你可以使用不同的优化器在相同的网络上运行测试，并通过更改一行代码来查看结果。此外，可以轻松地设计你的测试，以查看使用不同批处理大小、隐藏层数、纪元、和更多内容。&lt;/p&gt;
&lt;h2&gt;什么是深度学习?&lt;/h2&gt;
&lt;p&gt;深度学习是机器学习和人工智能的一个分支，它使用许多层次的神经网络层(如果你愿意，可以称之为层次结构)来完成它的工作。在很多情况下，这些网络的建立是为了反映我们对人类大脑的认知，神经元像错综复杂的网状结构一样将不同的层连接在一起。这允许以非线性的方式进行数据处理。每一层都处理来自上一层的数据(当然，第一层除外)，并将其信息传递到下一层。幸运的话，每一层都改进了模型，最终，我们实现了目标并解决了问题。&lt;/p&gt;
&lt;h2&gt;OpenCL&lt;/h2&gt;
&lt;p&gt;Kelp.Net 大量使用了开源计算语言（OpenCL）.&lt;/p&gt;
&lt;p&gt;OpenCL认为计算系统是由许多计算设备组成的，这些计算设备可以是中央处理器(CPU)，也可以是附加在主机处理器(CPU)上的图形处理单元(GPU)等加速器。在OpenCL设备上执行的函数称为内核。单个计算设备通常由几个计算单元组成，这些计算单元又由多个处理元素(PS)组成。一个内核执行可以在所有或多个PEs上并行运行。&lt;/p&gt;
&lt;p&gt;在OpenCL中，任务是在命令队列中调度的。每个设备至少有一个命令队列。OpenCL运行时将调度数据的并行任务分成几部分，并将这些任务发送给设备处理元素。&lt;/p&gt;
&lt;p&gt;OpenCL定义了一个内存层次结构:&lt;/p&gt;
&lt;p&gt;       Global：由所有处理元素共享，并且具有高延迟。&lt;/p&gt;
&lt;p&gt;Read-only：更小，更低的延迟，可由主机CPU写入，但不包括计算设备。&lt;/p&gt;
&lt;p&gt;Local：由流程元素组共享。&lt;/p&gt;
&lt;p&gt;Per-elemen：私有内存。&lt;/p&gt;
&lt;p&gt;OpenCL还提供了一个更接近数学的API。这可以在固定长度向量类型的公开中看到，比如float4(单精度浮点数的四个向量)，它的长度为2、3、4、8和16。如果你接触了更多的Kelp.Net并开始创建自己的函数，你将会遇到OpenCL编程。现在，只要知道它的存在就足够了，而且它正在被广泛地使用。&lt;/p&gt;
&lt;h3&gt;     OpenCL 层次结构&lt;/h3&gt;
&lt;p&gt;       在Kelp.Net各种OpenCL资源的层次结构如下图所示:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201910/912798-20191001180238623-932605166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;让我们更详细地描述这些。&lt;/p&gt;
&lt;p&gt;       Compute kernel&lt;/p&gt;
&lt;p&gt;            内核对象封装在程序中声明的特定内核函数，以及执行此内核函数时使用的参数值。&lt;/p&gt;
&lt;p&gt;       Compute program&lt;/p&gt;
&lt;p&gt;由一组内核组成的OpenCL程序。程序还可以包含内核函数和常量数据调用的辅助函数。&lt;/p&gt;
&lt;p&gt;       Compute sampler&lt;/p&gt;
&lt;p&gt;描述如何在内核中读取图像时对图像进行采样的对象。图像读取函数以采样器作为参数。采样器指定图像寻址模式(表示如何处理范围外的坐标)、过滤模式以及输入图像坐标是规范化还是非规范化值。&lt;/p&gt;
&lt;p&gt;    Compute device&lt;/p&gt;
&lt;p&gt;计算设备是计算单元的集合。命令队列用于将命令排队到设备。命令示例包括执行内核或读写内存对象。OpenCL设备通常对应于GPU、多核CPU和其他处理器，如数字信号处理器(DSP)和cell/B.E.处理器。&lt;/p&gt;
&lt;p&gt;    Compute resource&lt;/p&gt;
&lt;p&gt;可以由应用程序创建和删除的OpenCL资源。&lt;/p&gt;
&lt;p&gt;Compute object&lt;/p&gt;
&lt;p&gt;    在OpenCL环境中由句柄标识的对象。&lt;/p&gt;
&lt;p&gt;Compute context&lt;/p&gt;
&lt;p&gt;计算上下文是内核执行的实际环境和定义同步和内存管理的域。&lt;/p&gt;
&lt;p&gt;Compute command queue&lt;/p&gt;
&lt;p&gt;命令队列是一个对象，它包含将在特定设备上执行的命令。命令队列是在上下文中的特定设备上创建的。对队列的命令按顺序排队，但可以按顺序执行，也可以不按顺序执行。&lt;/p&gt;
&lt;p&gt;Compute buffer&lt;/p&gt;
&lt;p&gt;存储线性字节集合的内存对象。可以使用在设备上执行的内核中的指针来访问缓冲区对象。&lt;/p&gt;
&lt;p&gt;Compute event&lt;/p&gt;
&lt;p&gt;    事件封装了操作(如命令)的状态。它可用于同步上下文中的操作。&lt;/p&gt;
&lt;p&gt;Compute image&lt;/p&gt;
&lt;p&gt;存储2D或3D结构数组的内存对象。图像数据只能通过读写函数访问。读取函数使用采样器。&lt;/p&gt;
&lt;p&gt;Compute platform&lt;/p&gt;
&lt;p&gt;主机加上OpenCL框架管理的设备集合，允许应用程序共享资源并在平台上的设备上执行内核。&lt;/p&gt;
&lt;p&gt;Compute user event&lt;/p&gt;
&lt;p&gt;    这表示用户创建的事件。&lt;/p&gt;
&lt;h2&gt;Kelp.Net Framework&lt;/h2&gt;
&lt;h3&gt;函数&lt;/h3&gt;
&lt;p&gt;       函数是Kelp.Net神经网络的基本组成部分。单个函数在函数堆栈中链接在一起，以创建功能强大且可能复杂的网络链。&lt;/p&gt;
&lt;p&gt;我们需要了解四种主要的函数类型:&lt;/p&gt;
&lt;p&gt;Single-input functions 单输入函数&lt;br/&gt;Dual-input functions 双输入函数&lt;br/&gt;Multi-input functions 多输入函数&lt;br/&gt;Multi-output functions 多输出函数&lt;/p&gt;
&lt;p&gt;       当从磁盘加载网络时，函数也被链接在一起。&lt;/p&gt;
&lt;p&gt;       每个函数都有一个向前和向后的方法。           &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; NdArray[] Forward(&lt;span&gt;params&lt;/span&gt;&lt;span&gt; NdArray[] xs);

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Backward([CanBeNull] &lt;span&gt;params&lt;/span&gt; NdArray[] ys){}    
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;     函数栈&lt;/h3&gt;
&lt;p&gt;       函数堆栈是在向前、向后或更新传递中同时执行的函数层。当我们创建一个测试或从磁盘加载一个模型时，将创建函数堆栈。下面是一些函数堆栈的例子。&lt;/p&gt;
&lt;p&gt;       它们可以小而简单:             &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 FunctionStack nn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FunctionStack(

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l1 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Sigmoid(name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l1 Sigmoid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l2 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它们也可以在大一点:       &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
FunctionStack nn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FunctionStack(

                  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Do not forget the GPU flag if necessary&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; Convolution2D(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;conv1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, gpuEnable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReLU(),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MaxPooling(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Convolution2D(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;conv2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, gpuEnable: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReLU(),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; MaxPooling(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fl3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReLU(),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fl4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

             );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       它们也可以非常大:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;135&quot;&gt;
&lt;pre&gt;
 FunctionStack nn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FunctionStack(

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(neuronCount * neuronCount, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l1 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),&lt;span&gt;//&lt;/span&gt;&lt;span&gt;L1&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l1 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LeakyReLU(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l1 LeakyReLU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l2 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L2&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l2 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LeakyReLU(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l2 LeakyReLU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l3 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L3&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l3 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LeakyReLU(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l3 LeakyReLU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l4 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L4&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l4 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LeakyReLU(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l4 LeakyReLU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l5 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L5&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l5 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LeakyReLU(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l5 LeakyReLU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l6 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L6&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l6 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LeakyReLU(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l6 LeakyReLU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l7 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L7&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l7 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LeakyReLU(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l7 ReLU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l8 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L8&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l8 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; LeakyReLU(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l8 LeakyReLU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l9 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L9&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l9 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PolynomialApproximantSteep(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l9 PolynomialApproximantSteep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l10 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L10&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l10 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PolynomialApproximantSteep(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l10 PolynomialApproximantSteep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l11 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L11&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l11 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PolynomialApproximantSteep(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l11 PolynomialApproximantSteep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l12 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L12&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l12 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PolynomialApproximantSteep(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l12 PolynomialApproximantSteep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l13 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L13&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l13 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PolynomialApproximantSteep(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l13 PolynomialApproximantSteep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l14 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L14&lt;/span&gt;

                 &lt;span&gt;new&lt;/span&gt; BatchNormalization(N, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l14 BatchNorm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; PolynomialApproximantSteep(slope: &lt;span&gt;0.000001&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l14 PolynomialApproximantSteep&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(N, &lt;span&gt;10&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l15 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; L15&lt;/span&gt;
&lt;span&gt;
             );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;函数字典&lt;/h3&gt;
&lt;p&gt;     函数字典是一个可序列化的函数字典(如前所述)。当从磁盘加载网络模型时，将返回一个函数字典，并且可以像在代码中创建函数堆栈一样对其进行操作。函数字典主要用于Caffe数据模型加载器。&lt;/p&gt;
&lt;h3&gt;Caffe1&lt;/h3&gt;
&lt;p&gt;Kelp.Net是围绕Caffe风格开发的，它支持许多特性。&lt;/p&gt;
&lt;p&gt;Caffe为多媒体科学家和实践者提供了一个简洁和可修改的框架，用于最先进的深度学习算法和一组参考模型。该框架是一个bsd许可的c++库，带有Python和MATLAB绑定，用于在普通架构上高效地培训和部署通用卷积神经网络和其他深度模型。Caffe通过CUDA GPU计算满足了行业和互联网规模的媒体需求，在一个K40或Titan GPU上每天处理超过4000万张图像(大约每张图像2毫秒)。通过分离模型表示和实际实现，Caffe允许在平台之间进行试验和无缝切换，以简化开发和部署，从原型机到云环境。&lt;/p&gt;
&lt;h3&gt;链&lt;/h3&gt;
&lt;p&gt;“Chainer是一个灵活的神经网络框架。一个主要的目标是灵活性，因此它必须使我们能够简单而直观地编写复杂的体系结构。”&lt;/p&gt;
&lt;p&gt;Chainer采用了按运行定义的方案，即通过实际的正向计算动态地定义网络。更准确地说，Chainer存储的是计算历史，而不是编程逻辑。例如，Chainer不需要任何东西就可以将条件和循环引入到网络定义中。按运行定义方案是Chainer的核心概念。这种策略也使得编写多gpu并行化变得容易，因为逻辑更接近于网络操作。&lt;/p&gt;
&lt;p&gt;Kelp.Net可以直接从磁盘加载Chainer模型。&lt;/p&gt;
&lt;h3&gt;Loss&lt;/h3&gt;
&lt;p&gt;       Kelp.Net由一个抽象的LossFunction类组成，设计用于确定如何评估损失的特定实例。&lt;/p&gt;
&lt;p&gt;       在机器学习中，损失函数或成本函数是将一个事件或一个或多个变量的值直观地映射到一个实数上的函数，表示与该事件相关的一些成本。Kelp.Net提供了两个开箱即用的损失函数:均方误差和软最大交叉熵。我们可以很容易地扩展它们以满足我们的需求。&lt;/p&gt;
&lt;h3&gt;模型保存和加载&lt;/h3&gt;
&lt;p&gt;Kelp.Net使得通过调用一个简单的类来保存和加载模型变得非常容易。ModelIO类同时提供了保存和加载方法，以便轻松地保存和加载到磁盘。下面是一个非常简单的例子，在训练、重新加载并对模型执行测试之后保存模型:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201910/912798-20191001180929854-869380733.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;优化程序&lt;/h3&gt;
&lt;p&gt;       优化算法根据模型的参数最小化或最大化误差函数。参数的例子有权重和偏差。它们通过最小化损失来帮助计算输出值并将模型更新到最优解的位置。扩展Kelp.Net以添加我们自己的优化算法是一个简单的过程，尽管添加OpenCL和资源方面的东西是一个协调的工作。&lt;/p&gt;
&lt;p&gt;       Kelp.Net提供了许多预定义的优化器，比如:&lt;/p&gt;
&lt;p&gt;              AdaDelta&lt;/p&gt;
&lt;p&gt;　　　　AdaGrad&lt;/p&gt;
&lt;p&gt;　　　　Adam&lt;/p&gt;
&lt;p&gt;　　　　GradientClipping&lt;/p&gt;
&lt;p&gt;　　　　MomentumSGD&lt;/p&gt;
&lt;p&gt;　　　　RMSprop&lt;/p&gt;
&lt;p&gt;　　　　SGD&lt;/p&gt;
&lt;p&gt;这些都是基于抽象的优化器类。&lt;/p&gt;
&lt;h3&gt;数据集&lt;/h3&gt;
&lt;p&gt;       Kelp.Net本身支持以下数据集:&lt;/p&gt;
&lt;p&gt;              CIFAR&lt;/p&gt;
&lt;p&gt;　　　　MNIST&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CIFAR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CIFAR数据集有两种形式，CIFAR-10和CIFAR 100，它们之间的区别是类的数量。让我们简要地讨论一下两者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CIFAR-10&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CIFAR-10数据集包含10个类中的60000张32×32张彩色图像，每个类包含6000张图像。有50,000张训练图像和10,000张测试图像。数据集分为五个训练批次和一个测试批次，每个测试批次有10,000张图像。测试批次包含从每个类中随机选择的1000个图像。训练批次包含随机顺序的剩余图像，但是一些训练批次可能包含一个类的图像多于另一个类的图像。在他们之间，每批训练包含了5000张图片。&lt;/p&gt;
&lt;p&gt;              &lt;strong&gt;CIFAR-100&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CIFAR-100数据集与CIFAR-10一样，只是它有100个类，每个类包含600个图像。每班有500张训练图片和100张测试图片。CIFAR-100中的100个类被分为20个超类。每个图像都有一个细标签(它所属的类)和一个粗标签(它所属的超类)。以下是CIFAR-100的类型列表:&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;22&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;&lt;strong&gt;Superclass&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;&lt;strong&gt;Classes&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;水生哺乳动物&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;海狸、海豚、水獭、海豹和鲸鱼&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;鱼&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;水族鱼，比目鱼，鳐鱼，鲨鱼和鱼&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;花&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;兰花、罂粟、玫瑰、向日葵和郁金香&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;食品容器&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;瓶子、碗、罐子、杯子和盘子&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;水果和蔬菜&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;苹果、蘑菇、桔子、梨和甜椒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;家用电器设备&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;时钟、电脑键盘、灯、电话和电视&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;家用家具&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;床、椅子、沙发、桌子和衣柜&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;昆虫&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;蜜蜂、甲虫、蝴蝶、毛虫和蟑螂&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;大型食肉动物&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;熊、豹、狮子、老虎和狼&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;大型人造户外用品&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;桥、城堡、房子、道路和摩天大楼&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;大型自然户外景观&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;云、林、山、平原、海&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;大型杂食动物和食草动物&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;骆驼、牛、黑猩猩、大象和袋鼠&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;中等大小的哺乳动物&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;狐狸，豪猪，负鼠，浣熊和臭鼬&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;无脊椎动物&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;螃蟹、龙虾、蜗牛、蜘蛛和蠕虫&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;人&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;宝贝，男孩，女孩，男人，女人&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;爬行动物&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;鳄鱼、恐龙、蜥蜴、蛇和乌龟&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;小型哺乳动物&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;仓鼠，老鼠，兔子，鼩鼱和松鼠&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;树&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;枫树、橡树、棕榈树、松树和柳树&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;车辆1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;自行车、公共汽车、摩托车、小货车和火车&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;车辆2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;277&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;割草机、火箭、有轨电车、坦克和拖拉机&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;MNIST&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MNIST数据库是一个手写数字的大型数据库，通常用于训练各种图像处理系统。该数据库还广泛用于机器学习领域的培训和测试。它有一个包含6万个例子的训练集和一个包含1万个例子的测试集。数字的大小已经标准化，并集中在一个固定大小的图像中，这使它成为人们想要尝试各种学习技术而不需要进行预处理和格式化的标准选择:&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/912798/201910/912798-20191001181033556-1948838506.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;测试&lt;/h3&gt;
&lt;p&gt;       测试是实际的执行事件，也可以说是小程序。由于OpenCL的使用，这些程序是在运行时编译的。要创建一个测试，您只需要提供一个封装代码的静态运行函数。Kelp.Net提供了一个预配置的测试器，这使得添加我们自己的测试变得非常简单。&lt;/p&gt;
&lt;p&gt;现在，这里有一个简单的XOR测试程序的例子:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Run()

    {

         &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; learningCount = &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;;

　　　　　 Real[][] trainData &lt;/span&gt;=&lt;span&gt;
         {    

           &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Real[] { &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },     
           &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Real[] { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },
           &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Real[] { &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; },     
           &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Real[] { &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;span&gt; }   
        };

　　　　　　Real[][] trainLabel &lt;/span&gt;=&lt;span&gt;
         {   
             &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Real[] { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; },   
             &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Real[] { &lt;span&gt;1&lt;/span&gt;&lt;span&gt; },   
             &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Real[] { &lt;span&gt;1&lt;/span&gt;&lt;span&gt; },   
             &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Real[] { &lt;span&gt;0&lt;/span&gt;&lt;span&gt; }   
         };

    FunctionStack nn &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FunctionStack(   

             &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l1 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),   

             &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ReLU(name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l1 ReLU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),   

             &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l2 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

     nn.SetOptimizer(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AdaGrad());

　　　RILogManager.Default&lt;/span&gt;?.SendDebug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Training...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);   

　　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; learningCount; i++&lt;span&gt;)   
　　　{   

    　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;use MeanSquaredError for loss function   &lt;/span&gt;
&lt;span&gt;
    　　　　Trainer.Train(nn,trainData[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;],trainLabel[&lt;span&gt;0&lt;/span&gt;],newMeanSquaredError(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);   

    　　　　Trainer.Train(nn, trainData[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;], trainLabel[&lt;span&gt;1&lt;/span&gt;], &lt;span&gt;new&lt;/span&gt; MeanSquaredError(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);   

    　　　　Trainer.Train(nn, trainData[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;], trainLabel[&lt;span&gt;2&lt;/span&gt;], &lt;span&gt;new&lt;/span&gt; MeanSquaredError(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);                

　　　　　　Trainer.Train(nn, trainData[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;], trainLabel[&lt;span&gt;3&lt;/span&gt;], &lt;span&gt;new&lt;/span&gt; MeanSquaredError(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);

　　　　　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;If you do not update every time after training, you can update it as a mini batch&lt;/span&gt;
&lt;span&gt;
          nn.Update();          
　　}

　　RILogManager.Default&lt;/span&gt;?.SendDebug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test Start...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

　　&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (Real[] val &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trainData)
　　{

  　　NdArray result &lt;/span&gt;= nn.Predict(val)[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];   

  　　RILogManager.Default&lt;/span&gt;?.SendDebug($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{val[0]} xor {val[1]} = {(result.Data[0] &amp;gt; 0.5 ? 1 : 0)} {result}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);   

　　}    
}    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Weaver&lt;/h3&gt;
&lt;p&gt;       Weaver是Kelp.Net的重要组成部分。是运行测试时要执行的第一个对象调用。这个对象包含各种OpenCL对象，比如:&lt;/p&gt;
&lt;p&gt;l  计算上下文&lt;/p&gt;
&lt;p&gt;l  一组计算设备&lt;/p&gt;
&lt;p&gt;l  计算命令队列&lt;/p&gt;
&lt;p&gt;l  一个布尔标志，表明GPU是否为启用状态&lt;/p&gt;
&lt;p&gt;l  可核心计算资源的字典&lt;/p&gt;
&lt;p&gt;       Weaver是用来告诉我们的程序我们将使用CPU还是GPU，以及我们将使用哪个设备(如果我们的系统能够支持多个设备)的地方。我们只需要在我们的程序开始时对Weaver做一个简单的调用，就像在这里看到的:              &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Weaver.Initialize(ComputeDeviceTypes.Gpu);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       我们还可以避免使用weaver的初始化调用，并允许它确定需要自动发生什么。&lt;/p&gt;
&lt;p&gt;       以下是Weaver的基本内容。它的目的是构建（在运行时动态编译）将执行的程序：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　　　///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;上下文&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
         &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ComputeContext Context;

         &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;设备&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ComputeDevice[] Devices;

         &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;命令队列&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
         &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ComputeCommandQueue CommandQueue;

         &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;设备的从零开始索引&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; DeviceIndex;

         &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;True启用，false禁用&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
         &lt;span&gt;internal&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; Enable;

         &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;平台&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ComputePlatform Platform;

         &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;核心资源&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; KernelSources = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;编写测试&lt;/h3&gt;
&lt;p&gt;       为Kelp.Net创建测试非常简单。我们编写的每个测试只需要公开一个运行函数。剩下的就是我们希望网络如何运作的逻辑了。&lt;/p&gt;
&lt;p&gt;运行函数的一般准则是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;负载数据(真实或模拟):&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　Real[][] trainData = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Real[N][];

　　Real[][] trainLabel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Real[N][];

　　&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; N; i++&lt;span&gt;)

　　{

    　　&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Prepare Sin wave for one cycle&lt;/span&gt;
&lt;span&gt;
    　　Real radian &lt;/span&gt;= -Math.PI + Math.PI * &lt;span&gt;2.0&lt;/span&gt; * i / (N - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

    　　trainData[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[] { radian };

    　　trainLabel[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Real[] { Math.Sin(radian)

　　};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2.创建函数堆栈:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
　　FunctionStack nn = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FunctionStack(

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l1 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Tanh(name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l1 Tanh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),

                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Linear(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;l2 Linear&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

             );&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3.选择优化器:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
　　nn.SetOptimizer(&lt;span&gt;new&lt;/span&gt; SGD());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.训练数据:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; EPOCH; i++&lt;span&gt;)
{

      Real loss &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; N; j++&lt;span&gt;)
      {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;When training is executed in the network, an error is returned to the return value&lt;/span&gt;&lt;span&gt;
           loss &lt;/span&gt;+= Trainer.Train(nn, trainData[j], trainLabel[j], &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MeanSquaredError());
      }

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i % (EPOCH / &lt;span&gt;10&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
      {
          RILogManager.Default&lt;/span&gt;?.SendDebug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;loss:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + loss /&lt;span&gt; N);
          RILogManager.Default&lt;/span&gt;?.SendDebug(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
      }
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5.测试数据:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
RILogManager.Default?.SendDebug(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test Start...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (Real[] val &lt;span&gt;in&lt;/span&gt;&lt;span&gt; trainData)
{
    RILogManager.Default&lt;/span&gt;?.SendDebug(val[&lt;span&gt;0&lt;/span&gt;]+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+nn.Predict(val)[&lt;span&gt;0&lt;/span&gt;].Data[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;       在这一章中，我们进入了深度学习的世界。我们学习了如何使用Kelp.Net作为我们的研究平台，它几乎可以测试任何假设。我们还看到了Kelp.Net的强大功能和灵活性。&lt;/p&gt;
</description>
<pubDate>Tue, 01 Oct 2019 10:21:00 +0000</pubDate>
<dc:creator>王振耀</dc:creator>
<og:description>在本章中，将会学到: l 如何使用Kelp.Net来执行自己的测试 l 如何编写测试 l 如何对函数进行基准测试 Kelp.Net是一个用c#编写的深度学习库。由于能够将函数链到函数堆栈中，它在一个非</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangzhenyao1994/p/11615754.html</dc:identifier>
</item>
</channel>
</rss>