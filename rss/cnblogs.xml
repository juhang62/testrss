<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>IdentityServer4与ocelot实现认证与客户端统一入口 - ~那啥</title>
<link>http://www.cnblogs.com/nasha/p/10160695.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nasha/p/10160695.html</guid>
<description>&lt;p&gt;关于IdentityServer4与ocelot博客园里已经有很多介绍我这里就不再重复了。&lt;/p&gt;
&lt;p&gt;ocelot与IdentityServer4组合认证博客园里也有很多，但大多使用ocelot内置的认证，而且大多都是用来认证API的，查找了很多资料也没看到如何认证oidc，所以这里的ocelot实际只是作为统一入口而不参与认证，认证的完成依然在客户端。代码是使用IdentityServer4的Quickstart5_HybridAndApi 示例修改的。项目结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222135521249-541466072.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;一 ocelot网关&lt;/h4&gt;
&lt;p&gt;我们先在示例添加一个网关。&lt;/p&gt;
&lt;p&gt;修改launchSettings.json中的端口为54660&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222130029442-542789168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;NanoFabricApplication&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;commandName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;launchBrowser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;applicationUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;environmentVariables&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASPNETCORE_ENVIRONMENT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置文件如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;&lt;img id=&quot;code_img_closed_531d56b2-f1f6-4a1d-9110-8a7f2daa4cfe&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_531d56b2-f1f6-4a1d-9110-8a7f2daa4cfe&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_531d56b2-f1f6-4a1d-9110-8a7f2daa4cfe&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReRoutes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MvcClient&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/MvcClient/{route}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;50891&lt;/span&gt;&lt;span&gt;
        }
      ],
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/MvcClient/{route}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHeaderTransform&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-Forwarded-For&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{RemoteIpAddress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    },
    { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; signin-oidc&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/signin-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;50891&lt;/span&gt;&lt;span&gt;
        }
      ],
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/signin-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHeaderTransform&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-Forwarded-For&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{RemoteIpAddress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    },
    { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; signout-callback-oidc&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/signout-callback-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;50891&lt;/span&gt;&lt;span&gt;
        }
      ],
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/signout-callback-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHeaderTransform&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-Forwarded-For&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{RemoteIpAddress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    },
    { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; MyApi&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/MyApi/{route}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;50890&lt;/span&gt;&lt;span&gt;
        }
      ],
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/MyApi/{route}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHeaderTransform&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-Forwarded-For&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{RemoteIpAddress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    },
    { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IdentityServer&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{route}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;50875&lt;/span&gt;&lt;span&gt;
        }
      ],
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/IdentityServer/{route}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHeaderTransform&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-Forwarded-For&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{RemoteIpAddress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    },
    { &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; IdentityServer&lt;/span&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{route}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
        {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;50875&lt;/span&gt;&lt;span&gt;
        }
      ],
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{route}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHeaderTransform&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;X-Forwarded-For&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{RemoteIpAddress}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      }
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这里我们定义3个下游服务，MvcClient，MyApi，IdentityServer，并使用路由特性把signin-oidc，signout-callback-oidc导航到MvcClient，由MvcClient负责生成最后的Cooike。并将默认路由指定到IdentityServer服务。&lt;/p&gt;
&lt;p&gt;在ConfigureServices中添加Ocelot服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;services.AddOcelot()
            .AddCacheManager(x &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                x.WithDictionaryHandle();
            })
            .AddPolly()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Configure中使用Ocelot中间件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
app.UseOcelot().Wait();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Ocelot网关就部署完成了。&lt;/p&gt;
&lt;h4&gt;二 修改QuickstartIdentityServer配置&lt;/h4&gt;
&lt;p&gt;首先依然是修改launchSettings.json中的端口为50875&lt;/p&gt;
&lt;p&gt;在ConfigureServices中修改AddIdentityServer配置中的PublicOrigin和IssuerUri的Url为http://localhost:54660/IdentityServer/&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 services.AddIdentityServer(Option =&amp;gt;&lt;span&gt;
            {
                Option.PublicOrigin &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/IdentityServer/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                Option.IssuerUri &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/IdentityServer/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            })
                .AddDeveloperSigningCredential()
                .AddInMemoryIdentityResources(Config.GetIdentityResources())
                .AddInMemoryApiResources(Config.GetApiResources())
                .AddInMemoryClients(Config.GetClients())
                .AddTestUsers(Config.GetUsers());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样一来发现文档中的IdentityServer地址就变为网关的地址了，进一步实现IdentityServer的负载均衡也是没有问题的。&lt;/p&gt;
&lt;p&gt;修改Config.cs中mvc客户端配置如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
  ClientId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    ClientName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MVC Client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    AllowedGrantTypes &lt;/span&gt;=&lt;span&gt; GrantTypes.HybridAndClientCredentials,
                    ClientSecrets &lt;/span&gt;=&lt;span&gt;
                    {
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Secret(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.Sha256())
                    },
                   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; AccessTokenType = AccessTokenType.Reference,&lt;/span&gt;
                    RequireConsent = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    RedirectUris &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/signin-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    PostLogoutRedirectUris &lt;/span&gt;= { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/signout-callback-oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                    AllowedScopes &lt;/span&gt;=&lt;span&gt;
                    {
                        IdentityServerConstants.StandardScopes.OpenId,
                        IdentityServerConstants.StandardScopes.Profile,
                        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                    },
                    AllowOfflineAccess &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;直接返回客户端需要的Claims&lt;/span&gt;
                    AlwaysIncludeUserClaimsInIdToken = &lt;span&gt;true&lt;/span&gt;,
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要修改RedirectUris和PostLogoutRedirectUris为网关地址，在网关也设置了signin-oidc和signout-callback-oidc转发请求到Mvc客户端。&lt;/p&gt;
&lt;h4&gt;三 修改MvcClient&lt;/h4&gt;
&lt;p&gt;修改MvcClient的launchSettings.json端口为50891。&lt;/p&gt;
&lt;p&gt;修改MvcClient的Authority地址为http://localhost:54660/IdentityServer和默认路由地址MvcClient/{controller=Home}/{action=index}/{id?}&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_e7e3a293-608e-44c8-b282-9f42aee0fa46&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e7e3a293-608e-44c8-b282-9f42aee0fa46&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e7e3a293-608e-44c8-b282-9f42aee0fa46&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;          JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();

            services.AddAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    options.DefaultScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    options.DefaultChallengeScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.DefaultSignInScheme = CookieAuthenticationDefaults.AuthenticationScheme;&lt;/span&gt;
&lt;span&gt;                })
                .AddCookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,options=&amp;gt;&lt;span&gt; {
                    options.ExpireTimeSpan &lt;/span&gt;= TimeSpan.FromMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;);
                    options.SlidingExpiration &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                })
                .AddOpenIdConnect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
                {
                    options.SignInScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    options.Authority &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/IdentityServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                    options.ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    options.ClientSecret &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    options.ResponseType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code id_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    options.SaveTokens &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    options.GetClaimsFromUserInfoEndpoint &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    options.Scope.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    options.Scope.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;offline_access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_b5eb9c00-081c-4ae5-8f77-3786747216fb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b5eb9c00-081c-4ae5-8f77-3786747216fb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b5eb9c00-081c-4ae5-8f77-3786747216fb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
   app.UseMvc(routes =&amp;gt;&lt;span&gt;
            {
   
                    routes.MapRoute(
                        name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                        template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MvcClient/{controller=Home}/{action=index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
           
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;修改HomeController，将相关地址修改为网关地址&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_03164329-0932-461d-9fbd-677d43e7c1cf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_03164329-0932-461d-9fbd-677d43e7c1cf&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_03164329-0932-461d-9fbd-677d43e7c1cf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; CallApiUsingClientCredentials()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tokenClient = &lt;span&gt;new&lt;/span&gt; TokenClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/IdentityServer/connect/token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tokenResponse = &lt;span&gt;await&lt;/span&gt; tokenClient.RequestClientCredentialsAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            client.SetBearerToken(tokenResponse.AccessToken);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content = &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/MyApi/identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            ViewBag.Json &lt;/span&gt;=&lt;span&gt; JArray.Parse(content).ToString();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; CallApiUsingUserAccessToken()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; accessToken = &lt;span&gt;await&lt;/span&gt; HttpContext.GetTokenAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;OpenIdConnectParameterNames&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            client.SetBearerToken(accessToken);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content = &lt;span&gt;await&lt;/span&gt; client.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/MyApi/identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            ViewBag.Json &lt;/span&gt;=&lt;span&gt; JArray.Parse(content).ToString();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; View(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h4&gt;四 修改Api项目&lt;/h4&gt;
&lt;p&gt;Api项目修改多一点。&lt;/p&gt;
&lt;p&gt;将MvcClient的HomeController和相关视图复制过来，模拟MVC与API同时存在的项目。&lt;/p&gt;
&lt;p&gt;修改Api的launchSettings.json端口为50890。&lt;/p&gt;
&lt;p&gt;修改Startup&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_07d1e485-8a70-4c4c-a541-1b9872b42afb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_07d1e485-8a70-4c4c-a541-1b9872b42afb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_07d1e485-8a70-4c4c-a541-1b9872b42afb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddDataProtection(options &lt;/span&gt;=&amp;gt; options.ApplicationDiscriminator = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;00000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).SetApplicationName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;00000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            services.AddMvc();
            JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();

            services.AddAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.DefaultScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                options.DefaultChallengeScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }).AddCookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
               .AddOpenIdConnect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
               {
                   options.SignInScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cookies&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                   options.Authority &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/IdentityServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                   options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                   options.ClientId &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                   options.ClientSecret &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                   options.ResponseType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;code id_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                   options.SaveTokens &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                   options.GetClaimsFromUserInfoEndpoint &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                   options.Scope.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                   options.Scope.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;offline_access&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
               })
                    .AddIdentityServerAuthentication(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, options =&amp;gt;&lt;span&gt;
                     {
                         options.Authority &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/IdentityServer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                         options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                         options.ApiSecret &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;secret123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                         options.ApiName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                         options.SupportedTokens&lt;/span&gt;=&lt;span&gt; SupportedTokens.Both;
                     });

            services.AddAuthorization(option &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认 只写 [Authorize]，表示使用oidc进行认证&lt;/span&gt;
                option.DefaultPolicy = &lt;span&gt;new&lt;/span&gt; AuthorizationPolicyBuilder(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oidc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).RequireAuthenticatedUser().Build();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ApiController使用这个  [Authorize(Policy = &quot;ApiPolicy&quot;)]，使用jwt认证方案&lt;/span&gt;
                option.AddPolicy(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ApiPolicy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, policy =&amp;gt;&lt;span&gt;
                {
                    policy.AddAuthenticationSchemes(JwtBearerDefaults.AuthenticationScheme);
                    policy.RequireAuthenticatedUser();
                });
            });
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var options = new ForwardedHeadersOptions
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto | ForwardedHeaders.XForwardedHost,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    ForwardLimit = 1
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;};
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.KnownNetworks.Clear();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.KnownProxies.Clear();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;app.UseForwardedHeaders(options);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if (env.IsDevelopment())
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    app.UseDeveloperExceptionPage();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;else
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    app.UseExceptionHandler(&quot;/Home/Error&quot;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;
            app.UseAuthentication();

            app.UseStaticFiles();
            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                routes.MapRoute(
                    name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MyApi/{controller=MAccount}/{action=Login}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            });
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;主要添加了oidc认证配置和配置验证策略来同时支持oidc认证和Bearer认证。&lt;/p&gt;
&lt;p&gt;修改IdentityController中的[Authorize]特性为[Authorize(Policy = &quot;ApiPolicy&quot;)]&lt;/p&gt;


&lt;p&gt; 依次使用调试-开始执行(不调试)并选择项目名称启动QuickstartIdentityServer，Gateway，MvcClient，Api，启动方式如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222141851295-591544303.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应该可以看到Gateway启动后直接显示了IdentityServer的默认首页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222142145556-1735255786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在浏览器输入http://localhost:54660/MVCClient/Home/index进入MVCClient&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222142432486-496379091.png&quot; alt=&quot;&quot;/&gt;样式没加载是因为我们修改了默认路由，没有影响就不再修改了。&lt;/p&gt;
&lt;p&gt;点击Secure进入需要授权的页面，这时候会跳转到登陆页面（才怪&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222143038435-607842701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上我们会遇到一个错误，这是因为ocelot做网关时下游服务获取到的Host实际为localhost:50891，而在IdentityServer中设置的RedirectUris为网关的54660，我们可以通过ocelot转发X-Forwarded-Host头，并在客户端通过UseForwardedHeaders中间件来获取头。但是UseForwardedHeaders中间件为了防止IP欺骗攻击需要设置KnownNetworks和KnownProxies以实现严格匹配。当然也可以通过清空KnownNetworks和KnownProxies的默认值来不执行严格匹配，这样一来就有可能受到攻击。所以这里我直接使用硬编码的方式设置Host，实际使用时应从配置文件获取，同时修改MvcClient和Api相关代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
            app.Use(&lt;span&gt;async&lt;/span&gt; (context, next) =&amp;gt;&lt;span&gt;
            {
                context.Request.Host &lt;/span&gt;= HostString.FromUriComponent(&lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:54660/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; next.Invoke();
            });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;var options = new ForwardedHeadersOptions
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto | ForwardedHeaders.XForwardedHost,
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    ForwardLimit = 1
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;};
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.KnownNetworks.Clear();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;options.KnownProxies.Clear();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;app.UseForwardedHeaders(options);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;在反向代理情况下通过转发X-Forwarded-Host头来获取Host地址应该时常见设置不知道还有没有其他更好的解决办法。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再次启动MVCClient并输入http://localhost:54660/MvcClient/Home/Secure。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222144525463-1228150826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 使用bob，password登陆一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222144723135-632130383.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Yes, Allow返回http://localhost:54660/MvcClient/Home/Secure，此时可以查看到登陆后的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222144838423-1012366867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 分别点击Call API using user token&lt;em id=&quot;__mceDel&quot;&gt;和Call API using application identity来验证一下通过access_token和ClientCredent模式请求来请求API&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222145116175-423209567.png&quot; alt=&quot;&quot;/&gt;成功获取到返回值。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 输入http://localhost:54660/myapi/Home/index来查看API情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222145442599-504241108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求成功。&lt;/p&gt;
&lt;p&gt;点击Secure从API项目查看用户信息，此时展示信息应该和MvcClient一致&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222150330350-366071749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;嗯，并没有看到用户信息而是又到了授权页.....，这是因为.netCore使用DataProtection来保护数据（&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/security/data-protection/introduction?view=aspnetcore-2.2&quot; target=&quot;_blank&quot;&gt;点击查看详细信息&lt;/a&gt;），Api项目不能解析由Mvc生成的Cookie，而被重定向到了IdentityServer服务中。&lt;/p&gt;
&lt;p&gt;在MvcClient和Api的ConfigureServices下添加如下代码来同步密钥环。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            services.AddDataProtection(options =&amp;gt; options.ApplicationDiscriminator = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;00000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).SetApplicationName(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;00000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;再次启动MvcClient和Api项目并在浏览器中输入http://localhost:54660/MvcClient/home/Secure，此时被要求重新授权，点击Yes, Allow后看到用户信息&lt;/p&gt;
&lt;p&gt;再输入http://localhost:54660/myapi/Home/Secure从API项目查看用户信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222151401704-1290592030.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 分别点击Call API using user token&lt;em id=&quot;__mceDel&quot;&gt;和Call API using application identity来验证一下通过access_token和ClientCredent模式请求来请求API&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1549456/201812/1549456-20181222151545385-709253966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求成功。&lt;/p&gt;

&lt;p&gt;如此我们便实现了通过ocelot实现统一入口，通过IdentityServer4来实现认证的需求&lt;/p&gt;

&lt;p&gt;源代码 &lt;a href=&quot;https://github.com/saber-wang/Quickstart5_HybridAndApi&quot; target=&quot;_blank&quot;&gt;https://github.com/saber-wang/Quickstart5_HybridAndApi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/stulzq/category/1060023.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/stulzq/category/1060023.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xiaoti/p/10118930.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/xiaoti/p/10118930.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jackcao/tag/identityserver4/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/jackcao/tag/identityserver4/&lt;/a&gt;&lt;/p&gt;


</description>
<pubDate>Sat, 22 Dec 2018 07:33:00 +0000</pubDate>
<dc:creator>~那啥</dc:creator>
<og:description>关于IdentityServer4与ocelot博客园里已经有很多介绍我这里就不再重复了。 ocelot与IdentityServer4组合认证博客园里也有很多，但大多使用ocelot内置的认证，而且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nasha/p/10160695.html</dc:identifier>
</item>
<item>
<title>Underscore.js 源码学习笔记（下） - wenruo</title>
<link>http://www.cnblogs.com/wenruo/p/10136541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenruo/p/10136541.html</guid>
<description>
&lt;p&gt;=== 756 行开始 函数部分。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; executeBound = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(sourceFunc, boundFunc, context, callingContext, args) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(callingContext &lt;span&gt;instanceof&lt;/span&gt; boundFunc)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; sourceFunc.apply(context, args);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self =&lt;span&gt; baseCreate(sourceFunc.prototype);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; sourceFunc.apply(self, args);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_.isObject(result)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; self;
};

_.bind &lt;/span&gt;= restArguments(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(func, context, args) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_.isFunction(func)) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; TypeError('Bind must be called on a function'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bound = restArguments(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(callArgs) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; executeBound(func, bound, context, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args.concat(callArgs));
  });
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bound;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;_.bind(func, context, args)&lt;/span&gt;  就是将 func 的 this 绑定到 context 并且预先传入参数 args （柯里化）&lt;/p&gt;
&lt;p&gt;通过  &lt;span class=&quot;cnblogs_code&quot;&gt;args.concat(callArgs)&lt;/span&gt;  实现了柯里化&lt;/p&gt;
&lt;p&gt;bound 是绑定 this 后的函数，func 是传入的函数&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;if&lt;/span&gt; (!(callingContext &lt;span&gt;instanceof&lt;/span&gt; boundFunc))&lt;/span&gt;  如果 callingContext 不是 boundFunc 的实例 就通过 apply 实现指定函数运行的 this&lt;/p&gt;
&lt;p&gt;如果 callingContext 是 boundFunc 的实例，那意味着你可能是这么使用的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bindFoo = _.bind(foo, context&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;没写定义，随便什么东西&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bindFooInstance = &lt;span&gt;new&lt;/span&gt; bindFoo();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时 bindFoo() 的 this 就是 bindFoo 的一个实例&lt;/p&gt;
&lt;p&gt;那么 bindFooInstance 的 this 是应该绑定到 context 还是 bindFoo 的实例还是什么呢？&lt;/p&gt;
&lt;p&gt;JavaScript 中 this 一共有四种绑定 默认绑定 &amp;lt; 隐式绑定 &amp;lt; 显示绑定 &amp;lt; new绑定&lt;/p&gt;
&lt;p&gt;所以 这里应该优先使用... foo 的实例&lt;/p&gt;
&lt;p&gt;思考一下嘛 如果是 ES5 中 new foo.bind(context) 是不是应该先使用 foo 的实例嘛 bound 只是一个中间函数&lt;/p&gt;
&lt;p&gt;然后就是判断 foo 是否有返回值 有的话直接返回该值 否则返回 this 也是操作符 new 的规定&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
_.partial = restArguments(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(func, boundArgs) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; placeholder =&lt;span&gt; _.partial.placeholder;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bound = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; position = 0, length =&lt;span&gt; boundArgs.length;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; args =&lt;span&gt; Array(length);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; length; i++&lt;span&gt;) {
      args[i] &lt;/span&gt;= boundArgs[i] === placeholder ? arguments[position++&lt;span&gt;] : boundArgs[i];
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (position &amp;lt; arguments.length) args.push(arguments[position++&lt;span&gt;]);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; executeBound(func, bound, &lt;span&gt;this&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args);
  };
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bound;
});

_.partial.placeholder &lt;/span&gt;=&lt;span&gt; _;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; add(a, b) { &lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b; }
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; addOne = _.partial(add, 1&lt;span&gt;, _);
addOne(&lt;/span&gt;3); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认占位符是 _ 先给函数指定部分参数 不指定的就用下划线占位 生成一个新的只需要填写剩余参数的函数&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
_.bindAll = restArguments(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj, keys) {
  keys &lt;/span&gt;= flatten(keys, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index =&lt;span&gt; keys.length;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (index &amp;lt; 1) &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('bindAll must be passed function names'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (index--&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key =&lt;span&gt; keys[index];
    obj[key] &lt;/span&gt;=&lt;span&gt; _.bind(obj[key], obj);
  }
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
  name: &lt;/span&gt;'xiaoming'&lt;span&gt;,
  age: &lt;/span&gt;'25'&lt;span&gt;,
  getName() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name;
  },
  getAge() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.age;
  },
  sayHello() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'hello, I am ' + &lt;span&gt;this&lt;/span&gt;.name + ' and i am ' + &lt;span&gt;this&lt;/span&gt;.age + ' years old.'&lt;span&gt;;
  }
}
name &lt;/span&gt;= 'global name'&lt;span&gt;;
_.bindAll(obj, &lt;/span&gt;'getName', 'getAge'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; getName = obj.getName, getAge = obj.getAge, sayHello =&lt;span&gt; obj.sayHello;
getName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; xiaoming&lt;/span&gt;
getAge();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;
sayHello(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; hello, I am global name and i am undefined years old.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把一个对象的指定方法绑定到该对象。keys 可以是要绑定的函数数组或函数。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
_.memoize = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(func, hasher) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; memoize = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(key) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; cache =&lt;span&gt; memoize.cache;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; address = '' + (hasher ? hasher.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments) : key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!has(cache, address)) cache[address] = func.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache[address];
  };
  memoize.cache &lt;/span&gt;=&lt;span&gt; {};
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; memoize;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个函数还是简单实用的，通过缓存一个变量 cache 当传入相同的参数时直接返回上一次的结果即可。&lt;/p&gt;
&lt;p&gt;hasher 是入参的哈希函数，来判断多次入参是否相同。如果不传哈希函数的话，默认就用第一个参数判断是否重复。所以如果入参不是只有一个的话，记得传 hasher 函数。&lt;/p&gt;
&lt;p&gt;比如在计算斐波那契数列  &lt;span class=&quot;cnblogs_code&quot;&gt;fib(n) = fib(n - 1) + fib(n - 2)&lt;/span&gt; 可以通过记忆化递归防止大量重复计算。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
_.delay = restArguments(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(func, wait, args) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func.apply(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;, args);
  }, wait);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;封装了一个函数，每次调用时都要等待 wait 毫秒再执行。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
_.defer = _.partial(_.delay, _, 1);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 _.defer 来执行函数 _.defer(log) 可以使函数放到异步调用队列中，防止一些奇怪的错误吧。（确实遇到了一些时候需要  &lt;span class=&quot;cnblogs_code&quot;&gt;setTimeout(()=&amp;gt;{...}, 0)&lt;/span&gt;  来执行函数才有效的情况，但是还不知道怎么总结规律= =）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在指定时间间隔 wait 内只会被执行一次&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 在某一时间点 函数被执行 那么之后 wait 时间内的调用都不会被立即执行 而是设置一个定时器等到间隔等于 wait 再执行&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 如果在计时器等待的时间又被调用了 那么定时器将执行在等待时间内的最后一次调用&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; options 有两个字段可填  { leading: false } 或 { trailing: false }&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; { leading: false } 表示调用时不会立即执行 而是等待 wait 毫秒之后执行&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; { trailing: false } 表示执行之后的 wait 时间内的调用都忽略掉&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 不要同时设置这两个字段&lt;/span&gt;
_.throttle = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(func, wait, options) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; timeout, context, args, result;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; previous = 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!options) options =&lt;span&gt; {};

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; later 函数是定时器指定执行的函数 context, args 不是设置定时器时指定的 而是执行 later 时决定的&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; later = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 options.leading = false 的话就将 previous 设置为 0 作为标记 下一次执行 func 时就不会被立即执行了&lt;/span&gt;
    previous = options.leading === &lt;span&gt;false&lt;/span&gt; ? 0&lt;span&gt; : _.now();
    timeout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    result &lt;/span&gt;=&lt;span&gt; func.apply(context, args);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里判断 !timeout 真的好迷啊...&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  };

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; throttled = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; now =&lt;span&gt; _.now();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有上一次调用 或者 之前的调用已经结束 且 leading = false 会设置 previous = 0&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; previous = 0 且 options.leading = false 说明上一次 func 执行完成 此次的 fun 不需要立即执行 等 wait ms 再执行&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!previous &amp;amp;&amp;amp; options.leading === &lt;span&gt;false&lt;/span&gt;) previous =&lt;span&gt; now;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据当前时间和上一次调用的时间间隔与 wait 比较判断&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; remaining = wait - (now -&lt;span&gt; previous);
    context &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意每一次调用都会更新 context 和 args 而执行 later 用到的是这两个参数&lt;/span&gt;
    args = arguments; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是说设置定时器时对应的参数 不一定是执行对应的参数~&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; remaining &amp;lt;= 0 则证明距离上次调用间隔大于 wait 了 可以被执行&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 理论上 remaining &amp;gt; wait 不会存在 除非 now &amp;lt; previous 也就是系统时间出错了（被修改了&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (remaining &amp;lt;= 0 || remaining &amp;gt;&lt;span&gt; wait) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当设置了 leading 是不会进入这个分支的= =&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除定时器 重置 previous 为当前时间 并执行 func&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timeout) {
        clearTimeout(timeout);
        timeout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
      }
      previous &lt;/span&gt;=&lt;span&gt; now;
      result &lt;/span&gt;=&lt;span&gt; func.apply(context, args);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!timeout) context = args = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则如果有 timeout 证明隔一段已经设置一段时间后执行 不再设置定时器&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 间隔小于 wait 而且没有 timeout 的话 就设置一个定时器 到指定时间间隔后再执行&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 options.trailing = false 则忽略这次调用 因为时间间隔在 timeout 之内&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!timeout &amp;amp;&amp;amp; options.trailing !== &lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置了 trailing 不会进入这个分支&lt;/span&gt;
      timeout =&lt;span&gt; setTimeout(later, remaining);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  };
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置 throttled 的状态 同时取消还没有执行的定时器&lt;/span&gt;
  throttled.cancel = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    clearTimeout(timeout);
    previous &lt;/span&gt;= 0&lt;span&gt;;
    timeout &lt;/span&gt;= context = args = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  };

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; throttled;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; log(sth) {
  console.log(&lt;/span&gt;'===&amp;gt; ' + sth + '  ' + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toLocaleTimeString());
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tLog = _.throttle(log, 1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; === start === 20:29:54&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ===&amp;gt; 1  20:29:54&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ===&amp;gt; 4  20:29:55&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; tLog = _.throttle(log, 1000, { leading: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; === start === 20:30:15&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ===&amp;gt; 4  20:30:16&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; tLog = _.throttle(log, 1000, { trailing: &lt;span&gt;false&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; === start === 20:30:39&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; ===&amp;gt; 1  20:30:39&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 不要同时设置 leading 和 trailing ~ 否则永远都不会被执行&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; var tLog = _.throttle(log, 1000, { leading: false, trailing: false });&lt;/span&gt;
&lt;span&gt;
console.log(&lt;/span&gt;'=== start === ' + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().toLocaleTimeString());
tLog(&lt;/span&gt;1&lt;span&gt;);
tLog(&lt;/span&gt;2&lt;span&gt;);
tLog(&lt;/span&gt;3&lt;span&gt;);
tLog(&lt;/span&gt;4);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经典的函数来了= =&lt;/p&gt;
&lt;p&gt;被称作节流函数 作用是在一定时间范围内只会被调用一次 即使被多次触发&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
_.debounce = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(func, wait, immediate) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; timeout, result;

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; later = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(context, args) {
    timeout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (args) result =&lt;span&gt; func.apply(context, args);
  };

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; debounced = restArguments(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(args) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (timeout) clearTimeout(timeout);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (immediate) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; callNow = !&lt;span&gt;timeout;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 虽然有 timeout 但是这里的 later 没有传参所以不会执行 func&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只是为了标记之后的 wait 时间内都不会再执行函数&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果等待的过程中又被调用 那么就从那个时间点开始再进行 wait 时间的不执行&lt;/span&gt;
      timeout =&lt;span&gt; setTimeout(later, wait);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callNow) result = func.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      timeout &lt;/span&gt;= _.delay(later, wait, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;, args);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  });

  debounced.cancel &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    clearTimeout(timeout);
    timeout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  };

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; debounced;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;debounce 防抖函数 只有当隔指定时间没有重复调用该函数时才会执行，可应用于输入和页面滑动等情况&lt;/p&gt;
&lt;p&gt;可以分成两种情况看 传 immediate 和不传 immediate&lt;/p&gt;
&lt;p&gt;不传 immediate 的话 就是调用后设置定时器 wait 秒之后执行 这中间又被调用 那么从调用时刻开始重新计时&lt;/p&gt;
&lt;p&gt;传 immediate 表示第一次调用就会被执行 然后标记之后的 wait ms 内不会被执行 这中间又被调用 那么从调用时刻开始重新计时&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; _.partial(wrapper, func) 是预先给 wrapper 传入参数 func&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 所以 _.wrap(func, wrapper) 就是 返回 wrapper 先传入 func 后返回的函数&lt;/span&gt;
_.wrap = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(func, wrapper) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _.partial(wrapper, func);
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func(name) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 'hi ' +&lt;span&gt; name;
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; wrapper(func, ...args) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func(args).toUpperCase();
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sayHi =&lt;span&gt; _.wrap(func, wrapper);
&lt;/span&gt;sayHi('saber', 'kido'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; HI SABER,KIDO&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
_.compose = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; args =&lt;span&gt; arguments;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; start = args.length - 1&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; i =&lt;span&gt; start;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从最后一个函数开始执行&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; result = args[start].apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每一个函数的入参是上一个函数的出参&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (i--) result = args[i].call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, result);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  };
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt; getName(firstname, lastname) { &lt;span&gt;return&lt;/span&gt; firstname + ' ' +&lt;span&gt; lastname; }
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; toUpperCase(str) { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; str.toUpperCase(); }
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; sayHi(str) { &lt;span&gt;return&lt;/span&gt; 'Hi ' +&lt;span&gt; str; }
_.compose(sayHi, toUpperCase, getName)(&lt;/span&gt;'wenruo', 'duan'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Hi WENRUO DUAN&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我记得之前写过这个函数啊= =但是没找到 记忆出错了&lt;/p&gt;
&lt;p&gt;就是一个把一堆函数从右到左连起来执行的函数。函数式编程中很重要的函数。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
_.after = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(times, func) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (--times &amp;lt; 1&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; func.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
    }
  };
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ajax(url, fn) {
  console.log(`获取 ${url} 资源...`);
  setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(`获取 ${url} 资源完成`);
    fn();
  }, Math.random() &lt;/span&gt;* 1000&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; finish() {
  console.log(&lt;/span&gt;'资源全部获取完成 可以进行下一步操作...'&lt;span&gt;);
}


&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; urls = ['urla', 'urlb', 'urlc'&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; finishWithAfter =&lt;span&gt; _.after(urls.length, finish);

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; urls.length; i++&lt;span&gt;) {
  ajax(urls[i], finishWithAfter);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 urla 资源...&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 获取 urlb 资源...&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 获取 urlc 资源...&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 获取 urla 资源完成&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 获取 urlc 资源完成&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 获取 urlb 资源完成&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 资源全部获取完成 可以进行下一步操作...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数调用 times 遍才会被执行&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
_.before = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(times, func) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; memo;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (--times &amp;gt; 0&lt;span&gt;) {
      memo &lt;/span&gt;= func.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, arguments);
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (times &amp;lt;= 1) func = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; memo;
  };
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用前 times-1 次执行 之后每一次都返回之前的运行的值&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; foo = _.before(3&lt;span&gt;, _.identity);

console.log(foo(&lt;/span&gt;1)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
console.log(foo(2)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
console.log(foo(3)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 (第 n 次开始调用不再执行 func 直接返回上一次的结果&lt;/span&gt;
console.log(foo(4)) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只有前 times-1 次执行传入的函数 func 后面就直接返回上一次调用的值。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
_.once = _.partial(_.before, 2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是只有一次调用的时候会只执行，后面直接返回之前的值。&lt;/p&gt;
&lt;p&gt;使用场景比如……单例模式？&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
_.restArguments = restArguments;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将 restArguments 函数导出。&lt;/p&gt;

&lt;p&gt;969行===下面是对象相关的函数了&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Keys in IE &amp;lt; 9 that won't be iterated by `for key in ...` and thus missed.&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; hasEnumBug = !{toString: &lt;span&gt;null&lt;/span&gt;}.propertyIsEnumerable('toString'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString'&lt;span&gt;,
  &lt;/span&gt;'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; collectNonEnumProps = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj, keys) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; nonEnumIdx =&lt;span&gt; nonEnumerableProps.length;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; constructor =&lt;span&gt; obj.constructor;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; proto = _.isFunction(constructor) &amp;amp;&amp;amp; constructor.prototype ||&lt;span&gt; ObjProto;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Constructor is a special case.&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; prop = 'constructor'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (has(obj, prop) &amp;amp;&amp;amp; !&lt;span&gt;_.contains(keys, prop)) keys.push(prop);

  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (nonEnumIdx--&lt;span&gt;) {
    prop &lt;/span&gt;=&lt;span&gt; nonEnumerableProps[nonEnumIdx];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prop &lt;span&gt;in&lt;/span&gt; obj &amp;amp;&amp;amp; obj[prop] !== proto[prop] &amp;amp;&amp;amp; !&lt;span&gt;_.contains(keys, prop)) {
      keys.push(prop);
    }
  }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IE9一下浏览器有bug就是一些属性重写后 不能在 for ... in 中遍历到，所以要单独判断。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
_.keys = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_.isObject(obj)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nativeKeys) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nativeKeys(obj);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys =&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt; obj) &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (has(obj, key)) keys.push(key);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ahem, IE &amp;lt; 9.&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasEnumBug) collectNonEnumProps(obj, keys);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果ES5的  &lt;span class=&quot;cnblogs_code&quot;&gt;Object.keys&lt;/span&gt; 存在就直接调用，否则通过 for..in 获取所有的属性。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
_.allKeys = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_.isObject(obj)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys =&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj) keys.push(key);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ahem, IE &amp;lt; 9.&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hasEnumBug) collectNonEnumProps(obj, keys);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; keys;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取对象的所有属性，包括原型链上的。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
_.values = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys =&lt;span&gt; _.keys(obj);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; keys.length;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; values =&lt;span&gt; Array(length);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; length; i++&lt;span&gt;) {
    values[i] &lt;/span&gt;=&lt;span&gt; obj[keys[i]];
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; values;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有对象自有属性的值的集合&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
_.mapObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj, iteratee, context) {
  iteratee &lt;/span&gt;=&lt;span&gt; cb(iteratee, context);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys =&lt;span&gt; _.keys(obj),
      length &lt;/span&gt;=&lt;span&gt; keys.length,
      results &lt;/span&gt;=&lt;span&gt; {};
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; index = 0; index &amp;lt; length; index++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentKey =&lt;span&gt; keys[index];
    results[currentKey] &lt;/span&gt;=&lt;span&gt; iteratee(obj[currentKey], currentKey, obj);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; results;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; _2camel = str =&amp;gt; str.replace(/_(\w)/g, (item, letter) =&amp;gt;&lt;span&gt; letter.toUpperCase());
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj = { first: 'mo_li_xiang_pian', second: 'yong_ren_zi_rao'&lt;span&gt; };
_.mapObject(obj, _2camel); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; { first: 'moLiXiangPian', second: 'yongRenZiRao' }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对对象中每一个值执行 iteratee 函数，和 _.map 的区别是它返回的是对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
_.pairs = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys =&lt;span&gt; _.keys(obj);
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; keys.length;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pairs =&lt;span&gt; Array(length);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; length; i++&lt;span&gt;) {
    pairs[i] &lt;/span&gt;=&lt;span&gt; [keys[i], obj[keys[i]]];
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pairs;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回一个数组，每一项都是键、值组成的数组。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
_.invert = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; {};
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keys =&lt;span&gt; _.keys(obj);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0, length = keys.length; i &amp;lt; length; i++&lt;span&gt;) {
    result[obj[keys[i]]] &lt;/span&gt;=&lt;span&gt; keys[i];
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象的键值互换，值要变成建，所以确保值是可序列化的。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
_.functions = _.methods = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; names =&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_.isFunction(obj[key])) names.push(key);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; names.sort();
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对象中所有属性值为函数的属性名的集合按照字典序排序后返回。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; createAssigner = &lt;span&gt;function&lt;/span&gt;(keysFunc, defaults) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [defaults] {Boolean}&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; arguments.length;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaults) obj = Object(obj); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  把 obj 转成对象&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (length &amp;lt; 2 || obj == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; index = 1; index &amp;lt; length; index++&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source =&lt;span&gt; arguments[index],
          keys &lt;/span&gt;= keysFunc(source), &lt;span&gt;//&lt;/span&gt;&lt;span&gt; keysFunc 是获取对象指定的 key 集合的函数&lt;/span&gt;
          l =&lt;span&gt; keys.length;
      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; l; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key =&lt;span&gt; keys[i];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果设置 defaults 则只有在在当前对象没有 key 属性的时候 才添加 key 属性&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则就为 obj 添加 key 属性 存在就替换&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!defaults || obj[key] === &lt;span&gt;void&lt;/span&gt; 0) obj[key] =&lt;span&gt; source[key];
      }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
  };
};

_.extend &lt;/span&gt;=&lt;span&gt; createAssigner(_.allKeys); 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; _.extend(obj, ...otherObjs)&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 把 otherObjs 上面的所有的属性都添加到 obj 上 相同属性后面会覆盖前面的&lt;/span&gt;
&lt;span&gt;
_.extendOwn &lt;/span&gt;= _.assign =&lt;span&gt; createAssigner(_.keys);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; _.extendOwn(obj, ...otherObjs)&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 把 otherObjs 上面的所有的自有属性都添加到 obj 上 相同属性后面会覆盖前面的&lt;/span&gt;
&lt;span&gt;
_.defaults &lt;/span&gt;= createAssigner(_.allKeys, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; _.extend(obj, ...otherObjs)&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 对 otherObjs 上面的所有的属性 如果 obj 不存在相同属性名的话 就添加到 obj 上 相同属性后面被忽略&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;扩展对象的一些函数。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; keyInObj = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value, key, obj) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj;
};

_.pick &lt;/span&gt;= restArguments(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj, keys) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过 restArguments 传入的参数除了第一个都被合成了一个数组 keys&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; result = {}, iteratee = keys[0&lt;span&gt;];
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_.isFunction(iteratee)) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 iteratee (keys[0]) 是一个函数&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以看做是 _.pick(obj, iteratee, context)&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; obj 中符合 iteratee(value, key, obj) 的键值对被返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (keys.length &amp;gt; 1) iteratee = optimizeCb(iteratee, keys[1&lt;span&gt;]);
    keys &lt;/span&gt;=&lt;span&gt; _.allKeys(obj);
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 iteratee (keys[0]) 不是函数&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 keys 数组递归压平 成为一个新数组 keys&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于 obj 中的属性在 keys 中的键值对被返回&lt;/span&gt;
    iteratee =&lt;span&gt; keyInObj;
    keys &lt;/span&gt;= flatten(keys, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    obj &lt;/span&gt;=&lt;span&gt; Object(obj);
  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0, length = keys.length; i &amp;lt; length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key =&lt;span&gt; keys[i];
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; value =&lt;span&gt; obj[key];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (iteratee(value, key, obj)) result[key] =&lt;span&gt; value;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;筛选对象中部分符合条件的属性。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
_.omit = restArguments(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj, keys) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; iteratee = keys[0&lt;span&gt;], context;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_.isFunction(iteratee)) {
    iteratee &lt;/span&gt;=&lt;span&gt; _.negate(iteratee);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (keys.length &amp;gt; 1) context = keys[1&lt;span&gt;];
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    keys &lt;/span&gt;= _.map(flatten(keys, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;), String);
    iteratee &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value, key) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !&lt;span&gt;_.contains(keys, key);
    };
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _.pick(obj, iteratee, context);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;逻辑同上，相当于反向 pick 了。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
_.create = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(prototype, props) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result =&lt;span&gt; baseCreate(prototype);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (props) _.extendOwn(result, props);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;给定原型和属性创建一个对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
_.clone = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_.isObject(obj)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _.isArray(obj) ?&lt;span&gt; obj.slice() : _.extend({}, obj);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浅克隆一个对象。&lt;/p&gt;

&lt;p&gt;看到  &lt;span class=&quot;cnblogs_code&quot;&gt;_.tap&lt;/span&gt; 有点没看懂，感觉事情有点不简单……于是向下翻到了 1621 行，看到这有一堆代码……&lt;/p&gt;
&lt;p&gt;首先一开始的时候 （42行） 我们看过   &lt;span class=&quot;cnblogs_code&quot;&gt;_&lt;/span&gt;  的定义，_ 是一个函数，_(obj) 返回一个 _ 实例，该实例有一个 _wrapped 属性是传入的 obj 。&lt;/p&gt;

&lt;p&gt;我们上面的函数都是 _ 的属性，所以 _(obj) 中是没有这些属性的（_.prototype 中的属性才能被获得）&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; chain 是一个函数 传入一个对象 obj 返回一个下划线的实例，该实例有一个 _wrapped 属性为 obj 同时有 _chain 属性为 true 标记此对象用于链式调用&lt;/span&gt;
_.chain = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; instance =&lt;span&gt; _(obj);
  instance._chain &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; instance;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回链式结果 如果当前实例就有 _chain 则将结果包装成链式对象返回 否则就直接返回对象本身&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; chainResult = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(instance, obj) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; instance._chain ?&lt;span&gt; _(obj).chain() : obj;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将对象 obj 中的函数添加到 _.prototype&lt;/span&gt;
_.mixin = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对于 obj 中每一为函数的属性&lt;/span&gt;
  _.each(_.functions(obj), &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 都将该属性赋值给下划线&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; func = _[name] =&lt;span&gt; obj[name];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同时在下划线的原型链上挂这个函数 同时这个函数可以支持链式调用&lt;/span&gt;
    _.prototype[name] = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; args = [&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._wrapped];
      push.apply(args, arguments);
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 this._wrapped 添加到 arguments 最前面传入 func&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为 this._wrapped 就是生成的一个下划线实例的原始的值&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; func 运行的 this 是 _ 把 this._wrapped 也就是上一个链式函数的运行结果 传入 func&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 this 和 func 的返回值传入 chainResult &lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 this 是一个链式对象（有 _chain 属性）就继续返回链式对象&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则直接返回 obj&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; chainResult(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, func.apply(_, args));
    };
  });
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add all of the Underscore functions to the wrapper object.&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 将 _ 传入 mixin&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 下划线上每一个函数都会被绑定到 _.prototype 这样这些函数才能被实例访问&lt;/span&gt;
&lt;span&gt;_.mixin(_);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add all mutator Array functions to the wrapper.&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 把一些数组相关的函数也加到 _.prototype&lt;/span&gt;
_.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method =&lt;span&gt; ArrayProto[name];
  _.prototype[name] &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._wrapped;
    method.apply(obj, arguments);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((name === 'shift' || name === 'splice') &amp;amp;&amp;amp; obj.length === 0) &lt;span&gt;delete&lt;/span&gt; obj[0&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; chainResult(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, obj);
  };
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add all accessor Array functions to the wrapper.&lt;/span&gt;
_.each(['concat', 'join', 'slice'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method =&lt;span&gt; ArrayProto[name];
  _.prototype[name] &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; chainResult(&lt;span&gt;this&lt;/span&gt;, method.apply(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._wrapped, arguments));
  };
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从一个含有链式的 _ 实例中获取本来的值 &lt;/span&gt;
_.prototype.value = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._wrapped;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 &lt;span class=&quot;cnblogs_code&quot;&gt;_.prototype&lt;/span&gt; 上添加一个函数，同时支持链式调用。惊叹于其实现的巧妙。&lt;/p&gt;

&lt;p&gt;现在可以继续看 _.tap 作用就是插入一个链式调用中间，查看中间值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
_.tap = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj, interceptor) {
  interceptor(obj);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
let obj = [1, 2, 3&lt;span&gt;];
let interceptor &lt;/span&gt;= (x) =&amp;gt; { console.log('中间值是：'&lt;span&gt;, x) }
let result &lt;/span&gt;= _(obj).chain().map(x =&amp;gt; x * x).tap(interceptor).filter(x =&amp;gt; x &amp;lt; 5&lt;span&gt;).max().value();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;              [1,2,3]      [1,4,9]        打印中间值         [1,4]            取最大值 4&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;  .value() 就是从 _ 实例 这里是 { [Number: 4] _wrapped: 4, _chain: true } 获取本来的数据&lt;/span&gt;
&lt;span&gt;console.log(result);  
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 中间值是： [ 1, 4, 9 ]&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过例子可以感受的更清晰。 接下来_.isMatch 前面看过了，略。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Internal recursive comparison function for `isEqual`.&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt;&lt;span&gt; eq, deepEq;
eq &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b, aStack, bStack) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Identical objects are equal. `0 === -0`, but they aren't identical.&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (a === b) &lt;span&gt;return&lt;/span&gt; a !== 0 || 1 / a === 1 /&lt;span&gt; b;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; `null` or `undefined` only equal to itself (strict comparison).&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (a == &lt;span&gt;null&lt;/span&gt; || b == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; `NaN`s are equivalent, but non-reflexive.&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (a !== a) &lt;span&gt;return&lt;/span&gt; b !==&lt;span&gt; b;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Exhaust primitive checks&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; type = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; a;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (type !== 'function' &amp;amp;&amp;amp; type !== 'object' &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; b != 'object') &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; deepEq(a, b, aStack, bStack);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Internal recursive comparison function for `isEqual`.&lt;/span&gt;
deepEq = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b, aStack, bStack) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Unwrap any wrapped objects.&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (a &lt;span&gt;instanceof&lt;/span&gt; _) a =&lt;span&gt; a._wrapped;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (b &lt;span&gt;instanceof&lt;/span&gt; _) b =&lt;span&gt; b._wrapped;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Compare `[[Class]]` names.&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; className =&lt;span&gt; toString.call(a);
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (className !== toString.call(b)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (className) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Strings, numbers, regular expressions, dates, and booleans are compared by value.&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; '[object RegExp]'&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; '[object String]'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Primitives and their corresponding object wrappers are equivalent; thus, `&quot;5&quot;` is&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; equivalent to `new String(&quot;5&quot;)`.&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; '' + a === '' +&lt;span&gt; b;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; '[object Number]'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; `NaN`s are equivalent, but non-reflexive.&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Object(NaN) is equivalent to NaN.&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (+a !== +a) &lt;span&gt;return&lt;/span&gt; +b !== +&lt;span&gt;b;
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; An `egal` comparison is performed for other numeric values.&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; +a === 0 ? 1 / +a === 1 / b : +a === +&lt;span&gt;b;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; '[object Date]'&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; '[object Boolean]'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Coerce dates and booleans to numeric primitive values. Dates are compared by their&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; millisecond representations. Note that invalid dates with millisecond representations&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; of `NaN` are not equivalent.&lt;/span&gt;
      &lt;span&gt;return&lt;/span&gt; +a === +&lt;span&gt;b;
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; '[object Symbol]'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; SymbolProto.valueOf.call(a) ===&lt;span&gt; SymbolProto.valueOf.call(b);
  }

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; areArrays = className === '[object Array]'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;areArrays) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不是数组也不是对象的话 其他情况都已经比较完了 所以一定是 false&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; a != 'object' || &lt;span&gt;typeof&lt;/span&gt; b != 'object') &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Objects with different constructors are not equivalent, but `Object`s or `Array`s&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; from different frames are.&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果都是自定义类型的实例 都有 constructor 的话 那么构造函数一定要相等&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; aCtor = a.constructor, bCtor =&lt;span&gt; b.constructor;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (aCtor !== bCtor &amp;amp;&amp;amp; !(_.isFunction(aCtor) &amp;amp;&amp;amp; aCtor &lt;span&gt;instanceof&lt;/span&gt; aCtor &amp;amp;&amp;amp;&lt;span&gt;
                             _.isFunction(bCtor) &lt;/span&gt;&amp;amp;&amp;amp; bCtor &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; bCtor)
                        &lt;/span&gt;&amp;amp;&amp;amp; ('constructor' &lt;span&gt;in&lt;/span&gt; a &amp;amp;&amp;amp; 'constructor' &lt;span&gt;in&lt;/span&gt;&lt;span&gt; b)) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Assume equality for cyclic structures. The algorithm for detecting cyclic&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.&lt;/span&gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initializing stack of traversed objects.&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; It's done here since we only need them for objects and arrays comparison.&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较 stack 是为了防止对象的一个属性是对象本身这种情况&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; let obj = {}; obj.prop = obj;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这种情况下比较对象再比较对象的每一个属性 就会发生死循环&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以比较到每一个属性的时候都要判断和之前的对象有没有相等的&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果相等的话 就判断另一个对象是不是也这样 来判断两个对象是否相等&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而不需要继续比较下去了~ 是不是很巧妙~&lt;/span&gt;
  aStack = aStack ||&lt;span&gt; [];
  bStack &lt;/span&gt;= bStack ||&lt;span&gt; [];
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; aStack.length;
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (length--&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Linear search. Performance is inversely proportional to the number of&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; unique nested structures.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (aStack[length] === a) &lt;span&gt;return&lt;/span&gt; bStack[length] ===&lt;span&gt; b;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add the first object to the stack of traversed objects.&lt;/span&gt;
&lt;span&gt;  aStack.push(a);
  bStack.push(b);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recursively compare objects and arrays.&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (areArrays) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是数组的话 需要比较其每一项都相等&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Compare array lengths to determine if a deep comparison is necessary.&lt;/span&gt;
    length =&lt;span&gt; a.length;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (length !== b.length) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Deep compare the contents, ignoring non-numeric properties.&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (length--&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!eq(a[length], b[length], aStack, bStack)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果是对象的话 需要比较其每一个键都相等 对应的值再深度比较&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Deep compare objects.&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; keys =&lt;span&gt; _.keys(a), key;
    length &lt;/span&gt;=&lt;span&gt; keys.length;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure that both objects contain the same number of properties before comparing deep equality.&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (_.keys(b).length !== length) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (length--&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Deep compare each member&lt;/span&gt;
      key =&lt;span&gt; keys[length];
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(has(b, key) &amp;amp;&amp;amp; eq(a[key], b[key], aStack, bStack))) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Remove the first object from the stack of traversed objects.&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 讨论一个为什么要出栈 这个有点像 dfs 哈&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; obj = { a: { a1: ... }, b: { b1: ... } }&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断属性 a 的时候栈里是 [obj] 然后判断 a != obj&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接下来会递归判断 a1 以及其下属性&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 到 a1 的时候 栈中元素为 [obj, a]&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当属性 a 被判断完全相等后 需要继续比较 b 属性&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当比较到 b 的时候 栈中应该是 [obj] 而不是 [obj, a]&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a == b 不会造成死循环 我们不需要对不是父子（或祖先）关系的属性进行比较&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 综上 这里需要出栈（大概没讲明白...反正我明白了...&lt;/span&gt;
&lt;span&gt;  aStack.pop();
  bStack.pop();
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Perform a deep comparison to check if two objects are equal.&lt;/span&gt;
_.isEqual = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(a, b) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; eq(a, b);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;深度比较两个对象是否相等。我已经开始偷懒了，英文有注释的地方不想翻译成中文了。&lt;/p&gt;
&lt;p&gt;虽然很长，但是真的，考虑的很全面。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
_.isEmpty = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isArrayLike(obj) &amp;amp;&amp;amp; (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) &lt;span&gt;return&lt;/span&gt; obj.length === 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _.keys(obj).length === 0&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;判断一个值是否为空。为 null、undefined、长度为空的（类）数组、空字符串、没有自己可枚举属性的对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
_.isElement = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !!(obj &amp;amp;&amp;amp; obj.nodeType === 1&lt;span&gt;);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;判断一个值是否是 DOM 元素。&lt;/p&gt;
&lt;p&gt;nodeType 属性返回节点类型。&lt;/p&gt;
&lt;p&gt;如果节点是一个元素节点，nodeType 属性返回 1。&lt;/p&gt;
&lt;p&gt;如果节点是属性节点, nodeType 属性返回 2。&lt;/p&gt;
&lt;p&gt;如果节点是一个文本节点，nodeType 属性返回 3。&lt;/p&gt;
&lt;p&gt;如果节点是一个注释节点，nodeType 属性返回 8。&lt;/p&gt;
&lt;p&gt;该属性是只读的。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
_.isArray = nativeIsArray || &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; toString.call(obj) === '[object Array]'&lt;span&gt;;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Is a given variable an object?&lt;/span&gt;
_.isObject = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; type = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt; obj;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; type === 'function' || type === 'object' &amp;amp;&amp;amp; !!&lt;span&gt;obj;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;isArray 判断一个值是否是数组 &lt;/p&gt;
&lt;p&gt;isObject 判断对象是否是 object 或 function 注意判断 null&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
_.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name) {
  _[&lt;/span&gt;'is' + name] = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; toString.call(obj) === '[object ' + name + ']'&lt;span&gt;;
  };
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;批量增加一些判断类型的函数，逻辑和 isArray 一样呀。Map WeakMap Set WeakSet 都是 ES6 新增的数据类型。WeakSet 和 WeakMap 都没听过。该补习一波了~~~&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_.isArguments(arguments)) {
  _.isArguments &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; has(obj, 'callee'&lt;span&gt;);
  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一开始看到的，这个文件就是一个大的IIFE所以会有 arguments ，在 IE 低版本有 bug 不能通过&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Object.prototype.toString.apply(arguments) === '[object Arguments]'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来判断。&lt;code&gt;callee&lt;/code&gt; 是 &lt;code&gt;arguments&lt;/code&gt; 对象的一个属性。可以通过该属性来判断。&lt;/p&gt;
&lt;p&gt;都 8102 年了 放过 IE 不好吗？Edge 都开始使用 Chromium 内核了~~~~&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; nodelist = root.document &amp;amp;&amp;amp;&lt;span&gt; root.document.childNodes;
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; /./ != 'function' &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; Int8Array != 'object' &amp;amp;&amp;amp; &lt;span&gt;typeof&lt;/span&gt; nodelist != 'function'&lt;span&gt;) {
  _.isFunction &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;typeof&lt;/span&gt; obj == 'function' || &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;优化 isFunction 因为在一些平台会出现bug 看了下提到的 issue #1621 （https://github.com/jashkenas/underscore/issues/1621）也不是很明白……&lt;/p&gt;
&lt;p&gt;反正我试了下 nodejs v8 和最新版 Chrome 都进入了这个分支……emmm不管了……&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Is a given object a finite number?&lt;/span&gt;
_.isFinite = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !_.isSymbol(obj) &amp;amp;&amp;amp; isFinite(obj) &amp;amp;&amp;amp; !&lt;span&gt;isNaN(parseFloat(obj));
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Is the given value `NaN`?&lt;/span&gt;
_.isNaN = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _.isNumber(obj) &amp;amp;&amp;amp;&lt;span&gt; isNaN(obj);
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Is a given value a boolean?&lt;/span&gt;
_.isBoolean = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj === &lt;span&gt;true&lt;/span&gt; || obj === &lt;span&gt;false&lt;/span&gt; || toString.call(obj) === '[object Boolean]'&lt;span&gt;;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Is a given value equal to null?&lt;/span&gt;
_.isNull = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj === &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Is a given variable undefined?&lt;/span&gt;
_.isUndefined = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj === &lt;span&gt;void&lt;/span&gt; 0&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;emmm 显而易见了吧&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
_.has = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj, path) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_.isArray(path)) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; has(obj, path);
  }
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; path.length;
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key =&lt;span&gt; path[i];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt; || !&lt;span&gt;hasOwnProperty.call(obj, key)) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    obj &lt;/span&gt;=&lt;span&gt; obj[key];
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !!&lt;span&gt;length;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
let obj = { a: { b: { c: 1&lt;span&gt; } } };
_.has(obj, [&lt;/span&gt;'a', 'b', 'c']); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
_.has(obj, ['a', 'b', 'd']); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
_.has(obj, []); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;判断一个对象是否有指定属性，如果是数组则判断嵌套属性。空数组返回 false。和前面 deepGet 不同的是这里有 hasOwnProperty 判断是否是自有属性。&lt;/p&gt;

&lt;p&gt;=== 1390 行 下面是 Utility Functions 一些工具方法 胜利在望✌️&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
_.noConflict = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  root._ &lt;/span&gt;=&lt;span&gt; previousUnderscore;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果运行在浏览器等环境 不能直接导出变量 只能将 _ 赋值到全局变量 如果之前已经有变量叫做 _ 可以通过  &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;var&lt;/span&gt; underscore = _.noConflict();&lt;/span&gt;  获得_工具函数同时将 _ 赋值回原来的值。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
_.identity = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是一个传入什么就返回什么的函数。看起来好像没什么用，但是前面有用到哒，可以作为 map 等函数的默认 iteratee &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = [&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, [1,2,3], &lt;span&gt;null&lt;/span&gt;, [10, 12], &lt;span&gt;null&lt;/span&gt;&lt;span&gt;];
a.filter(_.identity)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考 Stack Overflow 上面的一个找到的 &amp;gt;_&amp;lt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
_.constant = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
  };
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; api: image.fill( function(x, y) { return color })&lt;/span&gt;
image.fill( _.constant( black ) );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码不难 同样让人困惑的是用途，在 Stack Overflow 找到一个用法举例。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
_.noop = &lt;span&gt;function&lt;/span&gt;(){};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回一个空函数。可以用在需要填写函数但又不需要做任何操作的地方。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
_.propertyOf = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){};
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(path) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; !_.isArray(path) ?&lt;span&gt; obj[path] : deepGet(obj, path);
  };
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;_.propertyOf 返回获取指定对象属性的方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
_.times = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(n, iteratee, context) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; accum = Array(Math.max(0, n)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; n 不能小于 0&lt;/span&gt;
  iteratee = optimizeCb(iteratee, context, 1&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; n; i++) accum[i] =&lt;span&gt; iteratee(i);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accum;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
_.times(6, i =&amp;gt; i * i); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ 0, 1, 4, 9, 16, 25 ]&lt;/span&gt;
_.times(6, _.identity); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; [ 0, 1, 2, 3, 4, 5 ]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行一个函数 n 次来生成一个数组。每一次参数都是运行的次数，从 0 开始。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
_.now = Date.now || &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime();
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Date.now 是 ES5（还是6）新增的，旧版本没有，通过new Date().getTime()获得&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一些 HTML 的转义字符&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; escapeMap =&lt;span&gt; {
  &lt;/span&gt;'&amp;amp;': '&amp;amp;amp;'&lt;span&gt;,
  &lt;/span&gt;'&amp;lt;': '&amp;amp;lt;'&lt;span&gt;,
  &lt;/span&gt;'&amp;gt;': '&amp;amp;gt;'&lt;span&gt;,
  &lt;/span&gt;'&quot;': '&amp;amp;quot;'&lt;span&gt;,
  &lt;/span&gt;&quot;'&quot;: '&amp;amp;#x27;'&lt;span&gt;,
  &lt;/span&gt;'`': '&amp;amp;#x60;'&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; unescapeMap =&lt;span&gt; _.invert(escapeMap);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Functions for escaping and unescaping strings to/from HTML interpolation.&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; createEscaper = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(map) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以传入 escapeMap 举例&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; escaper = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(match) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回对应的转义后的字符串&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; map[match];
  };
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成一个正则表达式用来匹配所有的需要转义的字符 (?:&amp;amp;|&amp;lt;|&amp;gt;|&quot;|'|`)&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正则表达式有两种创建方式 通过 /.../ 字面量直接创建 或者通过 new RegExp(regStr) 创建&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里的 ?: 表示正则表达不捕获分组 如果不添加这个的话 在 replace 中可使用 $i 代替捕获的分组&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比如&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; '2015-12-25'.replace(/(\d{4})-(\d{2})-(\d{2})/g,'$2/$3/$1'); --&amp;gt; &quot;12/25/2015&quot;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; '2015-12-25'.replace(/(?:\d{4})-(\d{2})-(\d{2})/g,'$2/$3/$1'); --&amp;gt;  &quot;25/$3/12&quot;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 为了防止 $1 变成捕获的字符串这里使用了 ?: （其实好像也用不到吧= =&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; source = '(?:' + _.keys(map).join('|') + ')'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; testRegexp = RegExp(source); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成的正则表达式 /(?:&amp;amp;|&amp;lt;|&amp;gt;|&quot;|'|`)/&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; replaceRegexp = RegExp(source, 'g'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成的正则表达式 /(?:&amp;amp;|&amp;lt;|&amp;gt;|&quot;|'|`)/g&lt;/span&gt;
  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(string) {
    string &lt;/span&gt;= string == &lt;span&gt;null&lt;/span&gt; ? '' : '' +&lt;span&gt; string;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; testRegexp.test(string) ?&lt;span&gt; string.replace(replaceRegexp, escaper) : string;
  };
};
_.escape &lt;/span&gt;=&lt;span&gt; createEscaper(escapeMap);
_.unescape &lt;/span&gt;=&lt;span&gt; createEscaper(unescapeMap);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
_.escape('&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;amp;lt;html&amp;amp;gt;&amp;amp;lt;/html&amp;amp;gt;&lt;/span&gt;
_.unescape('&amp;amp;lt;html&amp;amp;gt;&amp;amp;lt;/html&amp;amp;gt;') &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;html实体字符的一些转义和反转义。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
_.result = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj, path, fallback) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!_.isArray(path)) path =&lt;span&gt; [path];
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; length =&lt;span&gt; path.length;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;length) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _.isFunction(fallback) ?&lt;span&gt; fallback.call(obj) : fallback;
  }
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; length; i++&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prop = obj == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;void&lt;/span&gt; 0&lt;span&gt; : obj[path[i]];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prop === &lt;span&gt;void&lt;/span&gt; 0&lt;span&gt;) {
      prop &lt;/span&gt;=&lt;span&gt; fallback;
      i &lt;/span&gt;= length; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure we don't continue iterating.&lt;/span&gt;
&lt;span&gt;    }
    obj &lt;/span&gt;= _.isFunction(prop) ?&lt;span&gt; prop.call(obj) : prop;
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
_.result({ a: { b: 2 } }, ['a','d'], () =&amp;gt; 'failed');   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; failed&lt;/span&gt;
_.result({ a: { b: 2 } }, ['a','b'], () =&amp;gt; 'failed');   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
_.result({ a: () =&amp;gt; ({ b: 2 }) }, ['a','b'], 'failed'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
_.result({ a: () =&amp;gt; ({ b: 2 }) }, ['a','d'], 'failed'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; failed&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;又是一个看得莫名其妙的函数...&lt;/p&gt;
&lt;p&gt;根据 path 获取 obj 的属性值，当获取不到时就返回 fallback 的执行结果。当遇到属性为函数时就把 上一层对象作为 this 传入执行函数然后继续向下查找。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; idCounter = 0&lt;span&gt;;
_.uniqueId &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(prefix) {
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; id = ++idCounter + ''&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; prefix ? prefix +&lt;span&gt; id : id;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; e.g.&lt;/span&gt;
_.uniqueId('DWR'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DWR1&lt;/span&gt;
_.uniqueId('DWR'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; DWR2&lt;/span&gt;
_.uniqueId('XIA');   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; XIA3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就是通过闭包 返回一个不断递增的 id&lt;/p&gt;

&lt;p&gt;_.template 我觉得值得用单独一篇博客来讲 = = &lt;strong&gt;但其实我都是胡诌的！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先要理解一下这个函数的用法&lt;/p&gt;
&lt;p&gt;学过 jsp 的同学应该知道 jsp 中表达式可以写在 &amp;lt;%= %&amp;gt; 之间 而脚本可以写在 &amp;lt;% %&amp;gt; 在渲染的时候 会将脚本执行 表达式也会替换成实际值&lt;/p&gt;
&lt;p&gt;这里的用法和那个基本一样&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let template =&lt;span&gt; `
&lt;/span&gt;&amp;lt;lable&amp;gt;用户ID：&amp;lt;/lable&amp;gt;&amp;lt;span&amp;gt;&amp;lt;%= userId %&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;lable&amp;gt;用户名：&amp;lt;/lable&amp;gt;&amp;lt;span&amp;gt;&amp;lt;%= username %&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;lable&amp;gt;用户密码：&amp;lt;/lable&amp;gt;&amp;lt;span&amp;gt;&amp;lt;%- password %&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;% 
&lt;span&gt;if&lt;/span&gt; (userId === 1) { console.log('管理员登录...'&lt;span&gt;) }
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { console.log('普通用户登录...'&lt;span&gt;) } 
&lt;/span&gt;%&amp;gt;&lt;span&gt;
`

let render &lt;/span&gt;=&lt;span&gt; _.template(template);

render({userId: &lt;/span&gt;1, username: '管理员', password: '&amp;lt;pwd&amp;gt;'&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; render 返回:
&amp;lt;lable&amp;gt;用户ID：&amp;lt;/lable&amp;gt;&amp;lt;span&amp;gt;1&amp;lt;/span&amp;gt;
&amp;lt;lable&amp;gt;用户名：&amp;lt;/lable&amp;gt;&amp;lt;span&amp;gt;管理员&amp;lt;/span&amp;gt;
&amp;lt;lable&amp;gt;用户密码：&amp;lt;/lable&amp;gt;&amp;lt;span&amp;gt;&amp;amp;lt;pwd&amp;amp;gt;&amp;lt;/span&amp;gt;
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同时控制台打印: 管理员登录...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前端三门语言中 只有 JavaScript 是图灵完备语言，你以为你写的模板是 html 添加了一些数据、逻辑，实际上 html 并不能处理这些代码&lt;/p&gt;
&lt;p&gt;所以我们需要使用 JS 来处理它。处理后在生成对应的 HTML&lt;/p&gt;
&lt;p&gt;把模板先生成一个 render 函数 然后为函数传入数据 就能生成对应 html 了。&lt;/p&gt;
&lt;p&gt;除了上面的基础用法 我们可以自定义模板的语法 注意 key 要和 underscore 中定义的相等&lt;/p&gt;
&lt;p&gt;默认是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
_.templateSettings =&lt;span&gt; {
evaluate: &lt;/span&gt;/&amp;lt;%([\s\S]+?)%&amp;gt;/g, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;% %&amp;gt; js脚本&lt;/span&gt;
interpolate: /&amp;lt;%=([\s\S]+?)%&amp;gt;/g, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;%= %&amp;gt; 表达式&lt;/span&gt;
escape: /&amp;lt;%-([\s\S]+?)%&amp;gt;/g &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;%- %&amp;gt; 表达式 生成后对 html 字符进行转义 如 &amp;lt; 转义为 &amp;amp;lt; 防止 XSS 攻击&lt;/span&gt;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以自定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
let settings = { interpolate: /{{([\s\S]+?)}}/ }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在 Vue 不是很火嘛 用一下 Vue 的语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let template =&lt;span&gt; `
&lt;/span&gt;&amp;lt;div&amp;gt;欢迎{{ data }}登录&amp;lt;/div&amp;gt;
&lt;span&gt;`;
let render &lt;/span&gt;= _.template(template, { interpolate: /{{([\s\S]+?)}}/, variable: 'data'&lt;span&gt; });
render(&lt;/span&gt;'OvO'); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;div&amp;gt;欢迎OvO登录&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;variable 指定了作用域 不指定时传入 render 的参数为 obj 的话 那么插值中 prop 获取到是 obj.prop 的值&lt;/p&gt;
&lt;p&gt;variable 指定传入 render 函数参数的名字&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;理解了用法 现在思考怎样实现 如果让你写程序传入一段 js 代码输出运行结果 你会怎么办&lt;/p&gt;
&lt;p&gt;憋说写一个解释器 &amp;gt;_&amp;lt;&lt;/p&gt;
&lt;p&gt;大概就两种选择 eval() 和 new Function() （原谅我学艺不精 还有其他办法吗？）而 eval 只能运行一次 function 是生成一个函数 可以运行多次&lt;/p&gt;
&lt;p&gt;生成的 render 有一个参数 source 是生成的函数字符串&lt;/p&gt;
&lt;p&gt;这样我们可以达到预编译的效果 就像 vue 打包后的文件里面是没有 template 的 都是编译好的 render 函数&lt;/p&gt;
&lt;p&gt;为什么要预编译？我们应该不想每一次运行都 new Function 吧 这个效率低大家应该都知道。其次，动态生成的函数，debug 不方便。&lt;/p&gt;
&lt;p&gt;我们传入字符串 但这个字符串中不只有 js 代码还有些不相关的字符串。所以需要使用正则表达式将其中的 js 代码找出来，templateSettings 定义的就是这个正则表达式&lt;/p&gt;
&lt;p&gt;如果是表达式就把运行结果和前后的字符串连接起来 如果是脚本就执行&lt;/p&gt;
&lt;p&gt;具体看代码就好了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; \s  匹配一个空白字符，包括空格、制表符、换页符和换行符。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; \S  匹配一个非空白字符。&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 所以 \s\S 就是匹配所有字符 和 . 比起来它多匹配了换行&lt;/span&gt;
_.templateSettings =&lt;span&gt; {
  evaluate: &lt;/span&gt;/&amp;lt;%([\s\S]+?)%&amp;gt;/g,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;%  %&amp;gt;&lt;/span&gt;
  interpolate: /&amp;lt;%=([\s\S]+?)%&amp;gt;/g,  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;%= %&amp;gt;&lt;/span&gt;
  escape: /&amp;lt;%-([\s\S]+?)%&amp;gt;/g        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;%- %&amp;gt;&lt;/span&gt;
&lt;span&gt;};

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这是一个一定不会匹配的正则表达式&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; noMatch = /(.)^/&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为后面要拼接一个函数体 有些字符放到字符串需要被转义 这里定义了需要转义的字符&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; \u2028 和 \u2029 不知道是啥 不想查了= =&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; escapes =&lt;span&gt; {
  &lt;/span&gt;&quot;'&quot;: &quot;'&quot;&lt;span&gt;,
  &lt;/span&gt;'\\': '\\'&lt;span&gt;,
  &lt;/span&gt;'\r': 'r'&lt;span&gt;,
  &lt;/span&gt;'\n': 'n'&lt;span&gt;,
  &lt;/span&gt;'\u2028': 'u2028'&lt;span&gt;,
  &lt;/span&gt;'\u2029': 'u2029'&lt;span&gt;
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/&lt;span&gt;g;

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; escapeChar = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(match) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; '\\' +&lt;span&gt; escapes[match];
};

_.template &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(text, settings, oldSettings) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; oldSettings 为了向下兼容 可以无视&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!settings &amp;amp;&amp;amp; oldSettings) settings =&lt;span&gt; oldSettings;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可以传入 settings 要和 _.templateSettings 中属性名相同来覆盖 templateSettings&lt;/span&gt;
  settings =&lt;span&gt; _.defaults({}, settings, _.templateSettings);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; reg.source 返回正则表达式两个斜杠之间的字符串 /\d+/g --&amp;gt; &quot;\d+&quot;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; matcher 就是把三个正则连起来 /&amp;lt;%-([\s\S]+?)%&amp;gt;|&amp;lt;%=([\s\S]+?)%&amp;gt;|&amp;lt;%([\s\S]+?)%&amp;gt;|$/g&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加了一个 $ 表示匹配字符串结尾&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; matcher =&lt;span&gt; RegExp([
    (settings.escape &lt;/span&gt;||&lt;span&gt; noMatch).source,
    (settings.interpolate &lt;/span&gt;||&lt;span&gt; noMatch).source,
    (settings.evaluate &lt;/span&gt;||&lt;span&gt; noMatch).source
  ].join(&lt;/span&gt;'|') + '|$', 'g'&lt;span&gt;);

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; index = 0&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source = &quot;__p+='&quot;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设传入的 text 是 '&amp;lt;p&amp;gt;&amp;lt;%=x+1%&amp;gt;&amp;lt;/p&amp;gt;'&lt;/span&gt;
  text.replace(matcher, &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(match, escape, interpolate, evaluate, offset) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数的参数分别是：&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配的字符串&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配的分组（有三个括号，所以有三个分组，分别表示 escape, interpolate, evaluate 匹配的表达式）&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配字符串的下标&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次匹配： &quot;&amp;lt;p&amp;gt;&amp;lt;%=x+1%&amp;gt;&amp;lt;/p&amp;gt;&quot; 会和 interpolate: /&amp;lt;%=([\s\S]+?)%&amp;gt;/g 匹配 interpolate 的值为 &quot;x+1&quot;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; index = 0, offset 匹配的起始下标 就是截取字符串最前面未匹配的那一段&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; text.slice(index, offset) 就是 &quot;&amp;lt;p&amp;gt;&quot; 此时的 source 就是 &quot;__p+='&amp;lt;p&amp;gt;&quot;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; replace(escapeRegExp, escapeChar) 的作用是：&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; source 拼接的是一个 '' 包裹的字符串 有些字符放到 ' ' 里需要被转义&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二次匹配：匹配字符串（&quot;&amp;lt;p&amp;gt;&amp;lt;%=x+1%&amp;gt;&amp;lt;/p&amp;gt;&quot;）结尾&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; text.slice(index, offset) 此时获取的是 &quot;&amp;lt;/p&amp;gt;&quot;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拼接后 source 为 &quot;__p+='&amp;lt;p&amp;gt;'+\n((__t=(x+1))==null?'':__t)+\n'&amp;lt;/p&amp;gt;&quot;&lt;/span&gt;
    source +=&lt;span&gt; text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index &lt;/span&gt;= offset + match.length; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 匹配的起始下标+匹配字符串长度 就是匹配字符串末尾的下标&lt;/span&gt;

    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (escape) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ((__t = (_.escape(escape))) == null ? '' : __t)&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; _.escape 是将生成的表达式中的 html 字符进行转义&lt;/span&gt;
      source += &quot;'+\n((__t=(&quot; + escape + &quot;))==null?'':_.escape(__t))+\n'&quot;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (interpolate) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ((__t = (interpolate)) == null ? '' : __t)&lt;/span&gt;
      source += &quot;'+\n((__t=(&quot; + interpolate + &quot;))==null?'':__t)+\n'&quot;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (evaluate) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前面的字符串加分号 同时执行该脚本&lt;/span&gt;
      source += &quot;';\n&quot; + evaluate + &quot;\n__p+='&quot;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一次匹配后 interpolate 为 &quot;x+1&quot;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时 source 是 &quot;__p+='&amp;lt;p&amp;gt;'+\n((__t=(x+1))==null?'':__t)+\n'&quot;&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二次匹配 escape、interpolate、evaluate 都不存在 不会改变 source&lt;/span&gt;

    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Adobe VMs need the match returned to produce the correct offset.&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回 match 只是为了获取正确的 offset 而替换后的 text 并没有改变&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; match;
  });
  source &lt;/span&gt;+= &quot;';\n&quot;&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有指定 settings.variable 就添加 with 指定作用域&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加 with 之后 source 为 &quot;with(obj||{}){\n__p+='&amp;lt;p&amp;gt;'+\n((__t=(x+1))==null?'':__t)+\n'&amp;lt;/p&amp;gt;\';\n}\n&quot;&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n'&lt;span&gt;;

  source &lt;/span&gt;= &quot;var __t,__p='',__j=Array.prototype.join,&quot; +
    &quot;print=function(){__p+=__j.call(arguments,'');};\n&quot; +&lt;span&gt;
    source &lt;/span&gt;+ 'return __p;\n'&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最后生成的 source 为&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; with(obj||{}){&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; __p+='&amp;lt;p&amp;gt;'+&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ((__t=(x+1))==null?'':__t)+&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; '&amp;lt;/p&amp;gt;';\n}\nreturn __p;&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;&lt;/span&gt;

  &lt;span&gt;var&lt;/span&gt;&lt;span&gt; render;
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入的参数1： settings.variable || obj&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 传入的参数2： _ 使用于可以在插值中使用 _ 里的函数&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 函数体 source&lt;/span&gt;
    render = &lt;span&gt;new&lt;/span&gt; Function(settings.variable || 'obj', '_'&lt;span&gt;, source);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 生成函数 render
      function anonymous(obj, _) {
        var __t, __p = '',
          __j = Array.prototype.join,
          print = function() {
            __p += __j.call(arguments, '');
          };
        with(obj || {}) {
          __p += '&amp;lt;p&amp;gt;' +
            ((__t = (x + 1)) == null ? '' : __t) +
            '&amp;lt;/p&amp;gt;';
        }
        return __p;
      }
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
    e.source &lt;/span&gt;=&lt;span&gt; source;
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
  }

  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; template = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(data) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, data, _);
  };

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Provide the compiled source as a convenience for precompilation.&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; argument = settings.variable || 'obj'&lt;span&gt;;
  template.source &lt;/span&gt;= 'function(' + argument + '){\n' + source + '}'&lt;span&gt;;

  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; template;
};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; template = _.template(&quot;&amp;lt;p&amp;gt;&amp;lt;%=x+1%&amp;gt;&amp;lt;/p&amp;gt;&quot;&lt;span&gt;);
template({x: &lt;/span&gt;'void'}) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;p&amp;gt;void1&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尽管我看的一知半解，但是还是感觉学到了好多。&lt;/p&gt;

&lt;p&gt;再下面就是 OOP 的部分上面已经基本分析过了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
_.prototype.value = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._wrapped;
};

_.prototype.valueOf &lt;/span&gt;= _.prototype.toJSON =&lt;span&gt; _.prototype.value;

_.prototype.toString &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; String(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._wrapped);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重写下划线的实例的 valueOf 、 toJSON 和 toString 函数&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; define == 'function' &amp;amp;&amp;amp;&lt;span&gt; define.amd) {
  define(&lt;/span&gt;'underscore', [], &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _;
  });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;AMD（异步模块定义，Asynchronous Module Definition），这里为了兼容 amd 规范。&lt;/p&gt;


&lt;p&gt;到此就把 下划线 1693 行全部看完了。&lt;/p&gt;
&lt;p&gt;其实这是我第二遍看，到这次才能说勉强看懂，第一次真的是一头雾水。这期间看了点函数式编程的文章，也许有点帮助吧。&lt;/p&gt;
&lt;p&gt;也开始理解了大家为什么说新手想阅读源码的话推荐这个，因为短、耦合度低、而且涉及到很多基础知识。&lt;/p&gt;
&lt;p&gt;整体看下来，executeBound、OOP部分 和 _.template 这三部分花了很长时间思考。当然抽丝剥茧后搞懂明白的感觉，真的很爽呀哈哈哈哈哈&lt;/p&gt;

&lt;p&gt;总之，完结撒花吧~&lt;/p&gt;
</description>
<pubDate>Sat, 22 Dec 2018 07:33:00 +0000</pubDate>
<dc:creator>wenruo</dc:creator>
<og:description>上接 Underscore.js 源码学习笔记（上） 756 行开始 函数部分。 _.bind(func, context, args) 就是将 func 的 this 绑定到 context 并且预</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenruo/p/10136541.html</dc:identifier>
</item>
<item>
<title>知识小罐头06（tomcat8简单源码分析 下） - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10158888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10158888.html</guid>
<description>&lt;p&gt;　　感觉最近想偷懒了，哎，强迫自己也要写点东西，偷懒可是会上瘾的，嘿嘿！一有写博客的想法要赶紧行动起来，养成良好的习惯。&lt;/p&gt;
&lt;p&gt;　　ok，继续上一篇所说的一些东西，上一篇说到Connector包装了那两个对象，最后变成了HttpServletRequest和HttpServletResponse对象，这两个对象应该就是原生servlet的service方法可以使用的了，但是隔了这么多堵墙，要怎么穿过这么多墙进去呢？&lt;/p&gt;
&lt;p&gt;　　我们还是从上一篇的Adapter的这里开始说，下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222115621183-1801953569.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一看到这么长的调用简直就是日了狗了，但是仔细一看，嘿嘿！其实都是我们比较熟悉的东西，getService就是取到包装Connector和Container的Service，然后拿到Container，再拿到Engine中的管道，管道里面的阀门很多，我们先拿到第一个阀门（第一个阀门里面肯定有指向下一个阀门的游标，只需要执行第一个阀门，后面一系列的阀门都会执行的），最后的invoke（）应该就是阀门中的方法了（哎，没细看，居然不是反射啊！我前面一篇应该没说成反射吧。。。不好意思，我去修改一下）。&lt;/p&gt;
&lt;p&gt;　　总结起来就是一句话，将Request和Response作为形参，调用Container的管道第一个阀门中的invoke方法，就会一直到最后的Wrapper中的Servlet的service方法了！&lt;/p&gt;
&lt;p&gt;　　下面我们就大概看一看这个过程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.断点调试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;我也在网上看了很多大佬的博客，最然很多博客都把源码分析的非常详细，但是都有一个缺陷，就是你根本不知道从这个类调用的方法是另外某某抽象类的什么什么方法啊？难道要一个一个的手动去找吗？贼坑！根本的原因就是很多博客也是看其他人的博客，直接Ctrl+H找那个类，然后截图...这样的教程无论写得怎么样，反正我是评价不高的，因为你这博客是给你自己看的！&lt;/p&gt;
&lt;p&gt;　　就像我听过的一个牛逼数学家高斯的故事：高斯可谓是不得了的数学家，数学难题对他来说都是小菜一碟，很多数学难题他一个晚上就做出来了！最牛的就是搞定了困扰了数学家两千年之久的正十七边形尺规作图问题。那一年，高斯只有19岁！高斯死前都说过，我死了之后在我的墓碑上给我刻一个正十七边形就可以了！然而高斯这货有个很坑的地方：有同时代的人就评价他，高斯就像一个狡猾的狐狸，他最后给你看一个结果，但是他用尾巴把所有他得到这个结果的痕迹全部给你扫的干干净净，就给你一个非常完美而漂亮的结果。&lt;/p&gt;
&lt;p&gt;　　写博客就是让自己站在一个新人的角度，重头开始再来剖析整个过程！新人嘛，假如分析的切入点和过程都不知道，看的再多效果其实不是很大！&lt;/p&gt;
&lt;p&gt;　　我承认我水平很菜，但是我会尽量把我怎么思考这些问题的过程给表达出来，适不适合你，自己判断；&lt;/p&gt;
&lt;p&gt;　　不说废话了，断点位置如下：&lt;/p&gt;
&lt;p&gt;　　方式一：Ctrl+H搜索一个类StandardWrapperValve，打断点！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222134925337-1034737457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　方式二：断点位置可以打的更深一点的，搜索一个类JspServlet，Ctrl+F12找到service方法，在下面这里打断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222135841803-1852622629.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后调试启动tomcat&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222135029539-1087320360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　最后就是浏览输入localhost：8080就ok了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222140738000-263544530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.简单看一看管道和阀门的类&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 Ctrl+N，搜一个Valve的接口，然后选中那个接口，Ctrl+H看看继承树，我们就看几个后面要用到的Valve（日了狗啊，一直把阀门看作Value，正确的应该是Valve）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222121509480-942474155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　例如StandardEngineValve，Ctrl+F12，看看类中所有的方法就是那个invoke方法最重要！&lt;/p&gt;
&lt;p&gt;　　其他的Valve差不多的，可以自己打开看看，无非就是做一些事情，然后就调用下一个容器的invoke方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222141909959-2047654391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　而管道又是一个什么呢？Ctrl+N，搜一个Pipline，看看继承树，发现只有一个实现类；&lt;/p&gt;
&lt;p&gt;　　进入那个类，Ctrl+F12，看看类中所有的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222140952149-1780557078.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222141313553-1562653992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;3.接上一篇继续&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;&lt;/span&gt;上一篇说到这里&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222115621183-1801953569.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　我们只看看Engine的阀门的invoke方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222142830764-830028320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　这个invoke方法就是调用下面这个阀门的invoke方法，对request或者response进行一些处理&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222143343482-531473861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222143708645-1501203737.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　跑了这么多阀门，终于到了Host的阀门了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222143905430-432380536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222144043731-644751364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222144307276-949424696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　跑了大半年，终于跑到了Context的阀门这里来了，这里其实就是判断请求路径是否合法，如果是包含META-INF或者WEB-INF的就抛异常！下面说的比较清楚判断规则&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222144533684-1416878325.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222144822664-2030745060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　快筋疲力竭了，终于差不多就到终点了，到达Wrapper的阀门&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222145238554-936943913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222145506539-1404168782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222145601550-364963064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　其实还可以继续跟进，看看这个doFilter方法里面是什么鬼&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222145655969-108329011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222145734935-1595493354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222145902797-1938213903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222150018424-2115247536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201812/1368608-20181222150056132-1735437101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　到这里应该就差不多了，有兴趣的小伙伴可以继续跟进，我感觉应该就是拿到Request中的url的具体servlet（jsp其实也是servlet），然后就去执行了，但是细节比较多，我又比较懒，就到这里吧！&lt;/p&gt;
&lt;p&gt; 　　其实内容也没有多少吧！（主要是我大删特删，很多细节直接跳过，嘿嘿！），就是request和response像两条鱼一样慢慢游，经过了九九八十一难，终于到了servlet中的service方法的这么一个过程吧！后面应该就是说说Tomcat启动原理了，然后Tomcat大概的轮廓就清晰了不少，哈哈！&lt;/p&gt;

</description>
<pubDate>Sat, 22 Dec 2018 07:25:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>感觉最近想偷懒了，哎，强迫自己也要写点东西，偷懒可是会上瘾的，嘿嘿！一有写博客的想法要赶紧行动起来，养成良好的习惯。 ok，继续上一篇所说的一些东西，上一篇说到Connector包装了那两个对象，最后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10158888.html</dc:identifier>
</item>
<item>
<title>微信公众号开发之回复图文消息(被动) - 潇十一郎</title>
<link>http://www.cnblogs.com/zhangxiaoyong/p/10161188.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangxiaoyong/p/10161188.html</guid>
<description>&lt;h4 class=&quot;postTitle&quot;&gt;目录&lt;/h4&gt;
&lt;h5&gt;（一）&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/6248096.html&quot;&gt;微信公众号开发之VS远程调试&lt;/a&gt;&lt;/h5&gt;
&lt;h5&gt;（二）&lt;a href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/6254162.html&quot; target=&quot;_blank&quot;&gt;微信公众号开发之基础梳理&lt;/a&gt;&lt;/h5&gt;
&lt;h5&gt;（三）&lt;a href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/6257981.html&quot; target=&quot;_blank&quot;&gt;微信公众号开发之自动消息回复和自定义菜单&lt;/a&gt;&lt;/h5&gt;
&lt;h5&gt;（四）&lt;a href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/6270768.html&quot; target=&quot;_blank&quot;&gt;微信公众号开发之网页授权获取用户基本信息&lt;/a&gt;&lt;/h5&gt;
&lt;h5&gt;（五）&lt;a href=&quot;http://www.cnblogs.com/zhangxiaoyong/p/6280045.html&quot; target=&quot;_blank&quot;&gt;微信公众号开发之网页中及时获取当前用户Openid及注意事项&lt;/a&gt;&lt;/h5&gt;
&lt;h5&gt;（六）&lt;a href=&quot;https://www.cnblogs.com/zhangxiaoyong/p/9269016.html&quot; target=&quot;_blank&quot;&gt;微信公众号开发之扫码支付&lt;/a&gt;&lt;/h5&gt;
&lt;h5&gt;（七）&lt;a href=&quot;https://www.cnblogs.com/zhangxiaoyong/p/9269034.html&quot; target=&quot;_blank&quot;&gt;微信公众号开发之公众号支付&lt;/a&gt;&lt;/h5&gt;
&lt;h5&gt;（八）&lt;a href=&quot;https://www.cnblogs.com/zhangxiaoyong/p/9268983.html&quot; target=&quot;_blank&quot;&gt;微信公众号开发之现金红包&lt;/a&gt;&lt;/h5&gt;
&lt;h5&gt;（九）&lt;a href=&quot;https://www.cnblogs.com/zhangxiaoyong/p/10161188.html&quot; target=&quot;_blank&quot;&gt;微信公众号开发之回复图文消息(被动)&lt;/a&gt;&lt;/h5&gt;

&lt;p&gt;题记：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　.NET Core 经过几年的发展，已经可以说是遍地开花了，现在如果还不展开.NET Core探索之路，那未免也太有点落后于.NET的时代潮流了.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;前几篇已经提及到了关注和回复消息事件，但此前都局限于回复文本消息。那么，如果有个需求是，用户发送特定字符，如何回复特定的图文消息给用户呢？&lt;/p&gt;
&lt;p&gt;首先我们来看看实现后的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201812/762349-20181222142459509-621413014.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;实现过程&lt;/h4&gt;

&lt;h2 id=&quot;-&quot;&gt;回复图片消息&lt;/h2&gt;
&lt;p&gt;我们先看一下 回复图文消息的XML字符格式&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　&amp;lt;&lt;/span&gt;&lt;span&gt;ToUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;![CDATA&lt;/span&gt;&lt;span&gt;[toUser] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ToUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　&amp;lt;&lt;/span&gt;&lt;span&gt;FromUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt; ![CDATA&lt;/span&gt;&lt;span&gt;[fromUser] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;FromUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　&amp;lt;&lt;/span&gt;&lt;span&gt;CreateTime&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;12345678&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;CreateTime&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　&amp;lt;&lt;/span&gt;&lt;span&gt;MsgType&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;![CDATA&lt;/span&gt;&lt;span&gt;[image] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MsgType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;　　&amp;lt;&lt;/span&gt;&lt;span&gt;Image&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MediaId&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;![CDATA&lt;/span&gt;&lt;span&gt;[media_id] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MediaId&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Image&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;br/&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201812/762349-20181222144415958-1350521198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据这个XML格式，我们很清楚已经知道这个地方需要用到几个必要的参数，包括：OpenID，微信号、创建时间、封面图片以及Mediald这些。&lt;/p&gt;
&lt;p&gt;我们这个是在.NET Core2.1上实现的，这里稍微说明下,此前我们在.NET 4.5中使用的一般处理程序是这样写的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ProcessRequest(HttpContext context)
{
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO      &lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;ASP.NET Core中提供了一个&lt;span class=&quot;goog-text-highlight&quot;&gt;IHttpContextAccessor接口，HttpContextAccessor 默认实现了它简化了访问HttpContext。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;goog-text-highlight&quot;&gt;它必须在程序启动时在ConfigureServices中注册，这样在程序中就能获取到HttpContextAccessor，并用来访问HttpContext。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
services.AddSingleton&amp;lt;IHttpContextAccessor, HttpContextAccessor&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们在控制器中注入进来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHttpContextAccessor _accessor;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HandlerController(IHttpContextAccessor accessor)
        {
            _accessor &lt;/span&gt;=&lt;span&gt; accessor;
        }
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ProcessRequest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ProcessRequest()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; context =&lt;span&gt; _accessor.HttpContext;
            context.Response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/plain&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; responseMsg =&lt;span&gt; Response(context.Request);
            context.Response.Clear();
            context.Response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            context.Response.WriteAsync(responseMsg);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了，前面是一些铺垫，代码部分和之前.NET 相差无几，玩.NET Core 记住一句话：无处不在的依赖注入。&lt;/p&gt;
&lt;p&gt;这里，我们提前将一些用到的关键词以及上面提到的必要参数放到appsetting.json配置中,方面后面修改。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new_images_messages&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keyword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;触发的关键字&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;validTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018-12-28&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;文章标题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;描述&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;picUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;图片url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;图文消息的url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，我这里采用读取配置的方式封装了一层，在Startup中DI进IConfiguration 接口&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：需要引入&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt; Microsoft.Extensions.Configuration;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;      public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 然后新建一个ConfigurationKeys 类，专门存放配置文件中不同类型的数据值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NEW_IMAGES_MESSAGES_TITLE = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new_images_messages:title&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NEW_IMAGES_MESSAGES_DES = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new_images_messages:description&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NEW_IMAGES_MESSAGES_PIC = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new_images_messages:picUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NEW_IMAGES_MESSAGES_URL = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new_images_messages:url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NEW_IMAGES_MESSAGES_KEYWORD = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new_images_messages:keyword&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NEW_IMAGES_MESSAGES_VALIDTIME = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;new_images_messages:validTime&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用时首先在控制器中注入配置接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IConfiguration _config;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EventHandler(IConfiguration config)
{
  _config &lt;/span&gt;=&lt;span&gt; config;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与发过来消息做对比&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断接收到的文本消息是否是配置文件中的触发关键词  &lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (content ==&lt;span&gt; _config[ConfigurationKeys.NEW_IMAGES_MESSAGES_KEYWORD])
{
      _logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;答复图文消息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      response &lt;/span&gt;=&lt;span&gt;ReArticle(tm.FromUserName, tm.ToUserName);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ReArticle(&lt;span&gt;string&lt;/span&gt; fromUserName, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; toUserName)
  {
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; title =&lt;span&gt; _config[ConfigurationKeys.NEW_IMAGES_MESSAGES_TITLE];
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; description =&lt;span&gt; _config[ConfigurationKeys.NEW_IMAGES_MESSAGES_DES];
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; picUrl =&lt;span&gt; _config[ConfigurationKeys.NEW_IMAGES_MESSAGES_PIC];
      &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; url =&lt;span&gt; _config[ConfigurationKeys.NEW_IMAGES_MESSAGES_URL];
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NewsMessage().Template(fromUserName, toUserName, title, description, picUrl, url);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要将模板提前配置好，所以这里新建了一个Template方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Template(&lt;span&gt;string&lt;/span&gt; fromUserName, &lt;span&gt;string&lt;/span&gt; toUserName, &lt;span&gt;string&lt;/span&gt; title, &lt;span&gt;string&lt;/span&gt; description, &lt;span&gt;string&lt;/span&gt; picUrl, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; url)
{
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; xml = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;xml&amp;gt;&amp;lt;ToUserName&amp;gt;&amp;lt;![CDATA[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + fromUserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]]&amp;gt;&amp;lt;/ToUserName&amp;gt;&amp;lt;FromUserName&amp;gt;&amp;lt;![CDATA[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + toUserName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]]&amp;gt;&amp;lt;/FromUserName&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            xml &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;CreateTime&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + FileUtility.DateTimeToUnixTimestamp(DateTime.Now) + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/CreateTime&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            xml &lt;/span&gt;+=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;MsgType&amp;gt;&amp;lt;![CDATA[news]]&amp;gt;&amp;lt;/MsgType&amp;gt;&amp;lt;Content&amp;gt;&amp;lt;![CDATA[]]&amp;gt;&amp;lt;/Content&amp;gt;&amp;lt;ArticleCount&amp;gt;1&amp;lt;/ArticleCount&amp;gt;&amp;lt;Articles&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            xml &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;item&amp;gt;&amp;lt;Title&amp;gt;&amp;lt;![CDATA[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + title + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]]&amp;gt;&amp;lt;/Title&amp;gt;&amp;lt;Description&amp;gt;&amp;lt;![CDATA[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + description +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]]&amp;gt;&amp;lt;/Description&amp;gt;&amp;lt;PicUrl&amp;gt;&amp;lt;![CDATA[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + picUrl + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]]&amp;gt;&amp;lt;/PicUrl&amp;gt;&amp;lt;Url&amp;gt;&amp;lt;![CDATA[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + url +&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]]&amp;gt;&amp;lt;/Url&amp;gt;&amp;lt;/item&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            xml &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/Articles&amp;gt;&amp;lt;FuncFlag&amp;gt;0&amp;lt;/FuncFlag&amp;gt;&amp;lt;/xml&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xml;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 上述的时间转换方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; DateTimeToUnixTimestamp(DateTime dateTime)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; start = &lt;span&gt;new&lt;/span&gt; DateTime(&lt;span&gt;1970&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, dateTime.Kind);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Convert.ToInt64((dateTime -&lt;span&gt; start).TotalSeconds);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 至此，已经全部实现，那如果项目已经上线，需要增加这个功能项，但是又不能破坏现有服务器，如何进行调试呢，可以借助微信的测试号，用于在线调试公众号。&lt;/p&gt;
&lt;p&gt; 地址：&lt;a href=&quot;https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login&quot; target=&quot;_blank&quot;&gt;微信测试号&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;进入测试号里面，有appID,appsecret我们需要将这两个信息替换本地的TokenContext中的值。然后URL可以借助花生壳等内网穿透的工具 映射到本地 进行开发调试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/762349/201812/762349-20181222151357159-493598392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整体做完就可以实现开始的展示图的效果了。&lt;/p&gt;
&lt;p&gt;       End&lt;/p&gt;
</description>
<pubDate>Sat, 22 Dec 2018 07:20:00 +0000</pubDate>
<dc:creator>潇十一郎</dc:creator>
<og:description>目录 题记： .NET Core 经过几年的发展，已经可以说是遍地开花了，现在如果还不展开.NET Core探索之路，那未免也太有点落后于.NET的时代潮流了. 前几篇已经提及到了关注和回复消息事件，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangxiaoyong/p/10161188.html</dc:identifier>
</item>
<item>
<title>javascript： 数组详细操作方法及解析合集（9个改变8个不变12个遍历） - 小太阳xdq</title>
<link>http://www.cnblogs.com/xuxiaoyu/p/10145411.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuxiaoyu/p/10145411.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;改变原数组的方法(9个):&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_819728&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1,2,3];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;ES5:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;a.pop()/ a.shift()/ a.push()/ a.unshift()/ a.reverse()/ a.splice()/ a.sort()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;ES6:&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;a.copyWithin() / a.fill&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;对于这些能够改变原数组的方法，要注意避免在循环遍历中改变原数组的选项，比如: 改变数组的长度，导致遍历的长度出现问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pop() 删除一个数组中的最后的一个元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: &lt;code&gt;pop() &lt;/code&gt;方法删除一个数组中的最后的一个元素，并且返回这个元素。&lt;/p&gt;
&lt;p&gt;参数: 无。&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_42431&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1,2,3];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = a.pop();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;shift() 删除数组的第一个元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: &lt;code&gt;shift()&lt;/code&gt;方法删除数组的第一个元素，并返回这个元素。&lt;/p&gt;
&lt;p&gt;参数: 无。&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_37377&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1,2,3];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = a.shift();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;push() 向数组的末尾添加元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：&lt;code&gt;push() &lt;/code&gt;方法可向数组的末尾添加一个或多个元素，并返回新的长度。&lt;/p&gt;
&lt;p&gt;参数: item1, item2, …, itemX ,要添加到数组末尾的元素&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_34829&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1,2,3];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = a.push(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'末尾'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;unshift()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：unshift() 方法可向数组的开头添加一个或更多元素，并返回新的长度。&lt;/p&gt;
&lt;p&gt;参数: item1, item2, …, itemX ,要添加到数组开头的元素&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_374698&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1,2,3];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = a.unshift(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'开头'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;reverse() 颠倒数组中元素的顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: &lt;code&gt;reverse() &lt;/code&gt;方法用于颠倒数组中元素的顺序。&lt;/p&gt;
&lt;p&gt;参数: 无&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_275166&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1,2,3];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;a.reverse();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;splice() 添加/删除数组元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义： &lt;code&gt;splice() &lt;/code&gt;方法向/从数组中添加/删除项目，然后返回被删除的项目&lt;/p&gt;
&lt;p&gt;语法： array.splice(index,howmany,item1,.....,itemX)&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。&lt;/li&gt;
&lt;li&gt;howmany：必需。要删除的项目数量。如果设置为 0，则不会删除项目。&lt;/li&gt;
&lt;li&gt;item1, …, itemX： 可选。向数组添加的新项目。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;返回值: 如果有元素被删除,返回包含被删除项目的新数组。&lt;/p&gt;
&lt;p&gt;eg1:删除元素&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_415358&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1, 2, 3, 4, 5, 6, 7];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = a.splice(0, 3);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a);&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = a.splice(-1, 3);&lt;/code&gt; &lt;/p&gt;

&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;eg2: 删除并添加&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_708987&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;20&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;15.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;30&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1, 2, 3, 4, 5, 6, 7];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = a.splice(0,3,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'添加'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a);&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;let b = [1, 2, 3, 4, 5, 6, 7];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = b.splice(-2,3,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'添加1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'添加2'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(b);&lt;/code&gt; &lt;/p&gt;

&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;eg3: 不删除只添加:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_772405&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr readability=&quot;21&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;16&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;31&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1, 2, 3, 4, 5, 6, 7];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = a.splice(0,0,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'添加1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'添加2'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let b = [1, 2, 3, 4, 5, 6, 7];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let item = b.splice(-1,0,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'添加1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'添加2'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(b);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上述三个栗子可以得出:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数组如果元素不够，会删除到最后一个元素为止&lt;/li&gt;
&lt;li&gt;操作的元素，包括开始的那个元素&lt;/li&gt;
&lt;li&gt;可以添加很多个元素&lt;/li&gt;
&lt;li&gt;添加是在开始的元素前面添加的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;sort() 数组排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: &lt;code&gt;sort()&lt;/code&gt;方法对数组元素进行排序，并返回这个数组。&lt;/p&gt;
&lt;p&gt;参数可选: 规定排序顺序的比较函数。&lt;/p&gt;
&lt;p&gt;默认情况下&lt;code&gt;sort()&lt;/code&gt;方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_940945&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;17&quot;&gt;

&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;a = [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;&quot;Banana&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;Orange&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;Apple&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;&quot;Mango&quot;&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;a.sort();&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;a = [10, 1, 3, 20,25,8];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a.sort())&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;比较函数的两个参数：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sort的比较函数有两个默认参数，要在函数中接收这两个参数，这两个参数是数组中两个要比较的元素，通常我们用 a 和 b 接收两个将要比较的元素：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若比较函数返回值&amp;lt;0，那么a将排到b的前面;&lt;/li&gt;
&lt;li&gt;若比较函数返回值=0，那么a 和 b 相对位置不变；&lt;/li&gt;
&lt;li&gt;若比较函数返回值&amp;gt;0，那么b 排在a 将的前面；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于sort()方法更深层级的内部实现以及处理机制可以看一下这篇文章&lt;a href=&quot;https://www.jb51.net/article/141331.htm&quot; target=&quot;_blank&quot;&gt;深入了解javascript的sort方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sort排序常见用法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、数组元素为数字的升序、降序:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_315246&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;array = [10, 1, 3, 4,20,4,25,8];&lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;array.sort(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(a,b){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;a-b;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(array);&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;array.sort(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(a,b){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;b-a;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(array);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2、数组多条件排序&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_807979&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;16&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;array = [{id:10,age:2},{id:5,age:4},{id:6,age:10},{id:9,age:6},{id:2,age:8},{id:10,age:9}];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;array.sort(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(a,b){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;if&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(a.id === b.id){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;   &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;b.age - a.age&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;else&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;   &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;a.id - b.id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3、自定义比较函数，天空才是你的极限&lt;/p&gt;
&lt;p&gt;类似的：运用好返回值，我们可以写出任意符合自己需求的比较函数&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div id=&quot;highlighter_514075&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;array = [{name:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},{name:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},{name:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},{name:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},{name:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},{name:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;array.sort(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(a,b){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;if&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(a.name ===&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;){&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;-1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;else&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;{&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt;  &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;})&lt;/code&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ES6: copyWithin() 指定位置的成员复制到其他位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: 在当前数组内部，将指定位置的成员复制到其他位置,并返回这个数组。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;p&gt;array.copyWithin(target, start = 0, end = this.length)&lt;br/&gt;参数:&lt;/p&gt;
&lt;p&gt;三个参数都是数值，如果不是，会自动转为数值.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;target（必需）：从该位置开始替换数据。如果为负值，表示倒数。&lt;/li&gt;
&lt;li&gt;start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。&lt;/li&gt;
&lt;li&gt;end（可选）：到该位置前停止读取数据，默认等于数组长度。使用负数可从数组结尾处规定位置。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;浏览器兼容(MDN): chrome 45,Edge 12,Firefox32,Opera 32,Safari 9, IE 不支持&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_441770&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;20&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;12.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;24&quot;&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;[1, 2, 3, 4, 5].copyWithin(0, -2, -1)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;var&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;a=[&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB2'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro2'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB3'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro3'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB4'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro4'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB5'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro5'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;a.copyWithin(2,3,5)&lt;/code&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;从上述栗子:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一个参数是开始被替换的元素位置&lt;/li&gt;
&lt;li&gt;要替换数据的位置范围:从第二个参数是开始读取的元素，在第三个参数前面一个元素停止读取&lt;/li&gt;
&lt;li&gt;数组的长度不会改变&lt;/li&gt;
&lt;li&gt;读了几个元素就从开始被替换的地方替换几个元素&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;ES6: fill() 填充数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: 使用给定值，填充一个数组。&lt;/p&gt;
&lt;p&gt;参数:&lt;/p&gt;
&lt;p&gt;第一个元素(必须): 要填充数组的值&lt;/p&gt;
&lt;p&gt;第二个元素(可选): 填充的开始位置,默认值为0&lt;/p&gt;
&lt;p&gt;第三个元素(可选)：填充的结束位置，默认是为this.length&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_749623&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;[&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'a'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'b'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'c'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;].fill(7)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;[&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'a'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'b'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'c'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;].fill(7, 1, 2)&lt;/code&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;不改变原数组的方法(8个):&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;ES5：&lt;br/&gt;join、toLocateString、toStrigin、slice、cancat、indexOf、lastIndexOf、&lt;br/&gt;ES7：&lt;br/&gt;includes&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;join() 数组转字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: &lt;code&gt;join() &lt;/code&gt;方法用于把数组中的所有元素通过指定的分隔符进行分隔放入一个字符串，返回生成的字符串。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;p&gt;array.join(str)&lt;br/&gt;参数:&lt;/p&gt;
&lt;p&gt;str(可选): 指定要使用的分隔符，默认使用逗号作为分隔符。&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_569431&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a= [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'hello'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'world'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let str=a.join();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let str2=a.join(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'+'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用join方法或者下文说到的toString方法时，当数组中的元素也是数组或者是对象时会出现什么情况？&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_700743&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a= [[&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OBKoro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'23'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;],&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'test'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let str1=a.join();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let b= [{name:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OBKoro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,age:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'23'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'test'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let str2 = b.join();&lt;/code&gt; &lt;/p&gt;

&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;所以，&lt;code&gt;join()&lt;/code&gt;/&lt;code&gt;toString()&lt;/code&gt;方法在数组元素是数组的时候，会将里面的数组也调用join()/toString(),如果是对象的话，对象会被转为[object Object]字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;toLocaleString() 数组转字符串&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: 返回一个表示数组元素的字符串。该字符串由数组中的每个元素的 &lt;code&gt;toLocaleString() &lt;/code&gt;返回值经调用 join() 方法连接（由逗号隔开）组成。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;p&gt;array.toLocaleString()&lt;br/&gt;参数：无。&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_990591&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a=[{name:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OBKoro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;},23,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'abcd'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;new&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;Date()];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let str=a.toLocaleString();&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如上述栗子：调用数组的&lt;code&gt;toLocaleString&lt;/code&gt;方法，数组中的每个元素都会调用自身的toLocaleString方法，对象调用对象的toLocaleString,Date调用Date的toLocaleString。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;toString() 数组转字符串 不推荐&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: &lt;code&gt;toString() &lt;/code&gt;方法可把数组转换为由逗号链接起来的字符串。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;p&gt;array.toString()&lt;br/&gt;参数: 无。&lt;/p&gt;
&lt;p&gt;该方法的效果和join方法一样，都是用于数组转字符串的，但是与join方法相比没有优势，也不能自定义字符串的分隔符，因此不推荐使用。&lt;/p&gt;
&lt;p&gt;值得注意的是：当数组和字符串操作的时候，js 会调用这个方法将数组自动转换成字符串&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_491013&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let b= [&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'toString'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'演示'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;].toString();&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a= [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'调用toString'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'连接在我后面'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;]+&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'啦啦啦'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;;&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;slice() 浅拷贝数组的元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义： 方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象，且原数组不会被修改。&lt;/p&gt;
&lt;p&gt;注意：字符串也有一个&lt;code&gt;slice() &lt;/code&gt;方法是用来提取字符串的，不要弄混了。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;p&gt;array.slice(begin, end);&lt;br/&gt;参数:&lt;/p&gt;
&lt;p&gt;begin(可选): 索引数值,接受负值，从该索引处开始提取原数组中的元素,默认值为0。&lt;/p&gt;
&lt;p&gt;end(可选):索引数值(不包括),接受负值，在该索引处前结束提取原数组元素，默认值为数组末尾(包括最后一个元素)。&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_17166&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a= [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'hello'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'world'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let b=a.slice(0,1);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;a[0]=&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'改变原数组'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a,b);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;b[0]=&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'改变拷贝的数组'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a,b);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如上：新数组是浅拷贝的，元素是简单数据类型，改变之后不会互相干扰。&lt;/p&gt;
&lt;p&gt;如果是复杂数据类型(对象,数组)的话，改变其中一个，另外一个也会改变。&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_426983&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;4&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a= [{name:&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OBKoro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;}];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let b=a.slice();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(b,a);&lt;/code&gt; &lt;/p&gt;




&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;原因在定义上面说过了的：slice()是浅拷贝，对于复杂的数据类型浅拷贝，拷贝的只是指向原数组的指针，所以无论改变原数组，还是浅拷贝的数组，都是改变原数组的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;cancat&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义： 方法用于合并两个或多个数组，返回一个新数组。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;var newArr =oldArray.concat(arrayX,arrayX,......,arrayX)&lt;br/&gt;参数：&lt;/p&gt;
&lt;p&gt;arrayX（必须）：该参数可以是具体的值，也可以是数组对象。可以是任意多个。&lt;/p&gt;
&lt;p&gt;eg1:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_111417&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;18&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1, 2, 3];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;let b = [4, 5, 6];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;let newVal=a.concat(b);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;let c = [7, 8, 9]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;let newVal2 = a.concat(b, c);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;let newVal3 = a.concat(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'添加元素'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,b, c,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'再加一个'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let d = [1,2 ];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let f = [3,[4]];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let newVal4 = d.concat(f);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;ES6扩展运算符...合并数组：&lt;/p&gt;
&lt;p&gt;因为ES6的语法更简洁易懂，所以现在合并数组我大部分采用...来处理，...运算符可以实现cancat的每个栗子，且更简洁和具有高度自定义数组元素位置的效果。&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_849277&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [2, 3, 4, 5]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let b = [ 4,...a, 4, 4]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a,b);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;indexOf() 查找数组是否存在某个元素，返回下标&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: 返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;p&gt;array.indexOf(searchElement,fromIndex)&lt;br/&gt;参数:&lt;/p&gt;
&lt;p&gt;searchElement(必须):被查找的元素&lt;/p&gt;
&lt;p&gt;fromIndex(可选):开始查找的位置(不能大于等于数组的长度，返回-1)，接受负值，默认值为0。&lt;/p&gt;
&lt;p&gt;严格相等的搜索:&lt;/p&gt;
&lt;p&gt;数组的indexOf搜索跟字符串的indexOf不一样,数组的indexOf使用严格相等===搜索元素，即数组元素要完全匹配才能搜索成功。&lt;/p&gt;
&lt;p&gt;注意：indexOf()不能识别NaN&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_479328&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a=[&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'啦啦'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,2,4,24,NaN]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a.indexOf(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'啦'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;));&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a.indexOf(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'NaN'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;));&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(a.indexOf(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'啦啦'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;));&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数组去重&lt;/li&gt;
&lt;li&gt;根据获取的数组下标执行操作，改变数组中的值等。&lt;/li&gt;
&lt;li&gt;判断是否存在，执行操作。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;lastIndexOf() 查找指定元素在数组中的最后一个位置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: 方法返回指定元素,在数组中的最后一个的索引，如果不存在则返回 -1。（从数组后面往前查找）&lt;/p&gt;
&lt;p&gt;语法:&lt;/p&gt;
&lt;p&gt;arr.lastIndexOf(searchElement,fromIndex)&lt;br/&gt;参数:&lt;/p&gt;
&lt;p&gt;searchElement(必须): 被查找的元素&lt;/p&gt;
&lt;p&gt;fromIndex(可选): 逆向查找开始位置，默认值数组的长度-1，即查找整个数组。&lt;/p&gt;
&lt;p&gt;关于fromIndex有三个规则:&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;正值。如果该值大于或等于数组的长度，则整个数组会被查找。&lt;/li&gt;
&lt;li&gt;负值。将其视为从数组末尾向前的偏移。(比如-2，从数组最后第二个元素开始往前查找)&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;负值。其绝对值大于数组长度，则方法返回 -1，即数组不会被查找。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_471879&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a=[&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,4,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,1,2,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,3,4,5,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;];&lt;/code&gt; &lt;/p&gt;



&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let b=a.lastIndexOf(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,-9);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ES7 includes() 查找数组是否包含某个元素 返回布尔&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义： 返回一个布尔值，表示某个数组是否包含给定的值&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;array.includes(searchElement,fromIndex=0)&lt;br/&gt;参数：&lt;/p&gt;
&lt;p&gt;searchElement(必须):被查找的元素&lt;/p&gt;
&lt;p&gt;fromIndex(可选):默认值为0，参数表示搜索的起始位置，接受负值。正值超过数组长度，数组不会被搜索，返回false。负值绝对值超过长数组度，重置从0开始搜索。&lt;/p&gt;
&lt;p&gt;includes方法是为了弥补indexOf方法的缺陷而出现的:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;indexOf方法不能识别NaN&lt;/li&gt;
&lt;li&gt;indexOf方法检查是否包含某个值不够语义化，需要判断是否不等于-1，表达不够直观&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_229040&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;5.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a=[&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'OB'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'Koro1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,1,NaN];&lt;/code&gt;&lt;/p&gt;




&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;兼容性(MDN): chrome47, Firefox 43,Edge 14,Opera 34, Safari 9,IE 未实现。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;遍历方法(12个):&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;js中遍历数组并不会改变原始数组的方法总共有12个:&lt;/p&gt;
&lt;p&gt;ES5：&lt;br/&gt;forEach、every 、some、 fliter、map、reduce、reduceRight、&lt;br/&gt;ES6：&lt;br/&gt;find、findIndex、keys、values、entries&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于遍历：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;尽量不要在遍历的时候，修改后面要遍历的值&lt;/li&gt;
&lt;li&gt;尽量不要在遍历的时候修改数组的长度（删除/添加）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;forEach&lt;br/&gt;定义: 按升序为数组中含有效值的每一项执行一次回调函数。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;array.forEach(function(currentValue, index, arr), thisValue)&lt;br/&gt;参数:&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;// 回调函数的参数&lt;br/&gt;1. currentValue(必须),数组当前元素的值&lt;br/&gt;2. index(可选), 当前元素的索引值&lt;br/&gt;3. arr(可选),数组对象本身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;hisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于forEach()你要知道：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无法中途退出循环，只能用return退出本次回调，进行下一次回调。&lt;/li&gt;
&lt;li&gt;它总是返回 undefined值,即使你return了一个值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;下面类似语法同样适用这些规则&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1. 对于空数组是不会执行回调函数的&lt;br/&gt;2. 对于已在迭代过程中删除的元素，或者空元素会跳过回调函数&lt;br/&gt;3. 遍历次数再第一次循环前就会确定，再添加到数组中的元素不会被遍历。&lt;br/&gt;4. 如果已经存在的值被改变，则传递给 callback 的值是遍历到他们那一刻的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_270702&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1, 2, ,3];&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let obj = { name:&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'OBKoro1'&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;};&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let result = a.forEach(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(value, index, array) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;a[3] =&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'改变元素'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;a.push(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'添加到尾端，不会被遍历'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(value,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'forEach传递的第一个参数'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;this&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;.name);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;value;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'不会执行，因为return 会执行下一次循环回调'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;}, obj);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(result);&lt;/code&gt; &lt;/p&gt;

&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;every 检测数组所有元素是否都符合判断条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: 方法用于检测数组所有元素是否都符合函数定义的条件&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;array.every(function(currentValue, index, arr), thisValue)&lt;br/&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;// 回调函数的参数&lt;br/&gt;1. currentValue(必须),数组当前元素的值&lt;br/&gt;2. index(可选), 当前元素的索引值&lt;br/&gt;3. arr(可选),数组对象本身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined&lt;/p&gt;
&lt;p&gt;方法返回值规则:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果数组中检测到有一个元素不满足，则整个表达式返回 false，且剩余的元素不会再进行检测。&lt;/li&gt;
&lt;li&gt;如果所有元素都满足条件，则返回 true。=&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_953555&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr readability=&quot;22&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;17&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;33&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;isBigEnough(element, index, array) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;element &amp;gt;= 10;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let result = [12, 5, 8, 130, 44].every(isBigEnough);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let result = [12, 54, 18, 130, 44].every(isBigEnough);&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;[12, 5, 8, 130, 44].every(x =&amp;gt; x &amp;gt;= 10);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;[12, 54, 18, 130, 44].every(x =&amp;gt; x &amp;gt;= 10);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;some 数组中的是否有满足判断条件的元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：数组中的是否有满足判断条件的元素&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;array.some(function(currentValue, index, arr), thisValue)&lt;br/&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;// 回调函数的参数&lt;br/&gt;1. currentValue(必须),数组当前元素的值&lt;br/&gt;2. index(可选), 当前元素的索引值&lt;br/&gt;3. arr(可选),数组对象本身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined&lt;/p&gt;
&lt;p&gt;方法返回值规则：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;如果有一个元素满足条件，则表达式返回true, 剩余的元素不会再执行检测。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果没有满足条件的元素，则返回false。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_657702&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;23&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;isBigEnough(element, index, array) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(element &amp;gt;= 10);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let result = [2, 5, 8, 1, 4].some(isBigEnough);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let result = [12, 5, 8, 1, 4].some(isBigEnough);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;filter 过滤原始数组，返回新数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义: 返回一个新数组, 其包含通过所提供函数实现的测试的所有元素。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;let new_array = arr.filter(function(currentValue, index, arr), thisArg)&lt;br/&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;// 回调函数的参数&lt;br/&gt;1. currentValue(必须),数组当前元素的值&lt;br/&gt;2. index(可选), 当前元素的索引值&lt;br/&gt;3. arr(可选),数组对象本身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_70357&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [32, 33, 16, 40];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let result = a.filter(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(value, index, array) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;value &amp;gt;= 18;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(result,a);&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;map 对数组中的每个元素进行处理，返回新的数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;let new_array = arr.map(function(currentValue, index, arr), thisArg)&lt;br/&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;// 回调函数的参数&lt;br/&gt;1. currentValue(必须),数组当前元素的值&lt;br/&gt;2. index(可选), 当前元素的索引值&lt;br/&gt;3. arr(可选),数组对象本身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_801604&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'1'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'2'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'3'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'4'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let result = a.map(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(value, index, array) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;value +&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'新数组的新元素'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;});&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(result, a);&lt;/code&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;reduce 为数组提供累加器，合并为一个值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，最终合并为一个值。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;p&gt;array.reduce(function(total, currentValue, currentIndex, arr), initialValue)&lt;br/&gt;参数：&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;// 回调函数的参数&lt;br/&gt;1. total(必须)，初始值, 或者上一次调用回调返回的值&lt;br/&gt;2. currentValue(必须),数组当前元素的值&lt;br/&gt;3. index(可选), 当前元素的索引值&lt;br/&gt;4. arr(可选),数组对象本身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;initialValue(可选): 指定第一次回调 的第一个参数。&lt;/p&gt;
&lt;p&gt;回调第一次执行时:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 initialValue 在调用 reduce 时被提供，那么第一个 total 将等于 initialValue，此时 currentValue 等于数组中的第一个值；&lt;/li&gt;
&lt;li&gt;如果 initialValue 未被提供，那么 total 等于数组中的第一个值，currentValue 等于数组中的第二个值。此时如果数组为空，那么将抛出 TypeError。&lt;/li&gt;
&lt;li&gt;如果数组仅有一个元素，并且没有提供 initialValue，或提供了 initialValue 但数组为空，那么回调不会被执行，数组的唯一值将被返回。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_616208&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr readability=&quot;15&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;18&quot;&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let sum = [0, 1, 2, 3].reduce(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(a, b) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;a + b;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;}, 0);&lt;/code&gt;&lt;/p&gt;


&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let flattened = [[0, 1], [2, 3], [4, 5]].reduce(&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(a, b) =&amp;gt; a.concat(b),&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;[]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;reduceRight 从右至左累加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法除了与reduce执行方向相反外，其他完全与其一致，请参考上述 reduce 方法介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ES6：find()&amp;amp; findIndex() 根据条件找到数组成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;find()定义：用于找出第一个符合条件的数组成员，并返回该成员，如果没有符合条件的成员，则返回undefined。&lt;/p&gt;
&lt;p&gt;findIndex()定义：返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。&lt;/p&gt;
&lt;p&gt;这两个方法&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_540416&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;15&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let new_array = arr.find(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(currentValue, index, arr), thisArg)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;let new_array = arr.findIndex(&lt;/code&gt;&lt;code class=&quot;js keyword&quot;&gt;function&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;(currentValue, index, arr), thisArg)&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;参数:(这几个方法的参数，语法都类似)&lt;/p&gt;
&lt;p&gt;function(必须): 数组中每个元素需要调用的函数。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;// 回调函数的参数&lt;br/&gt;1. currentValue(必须),数组当前元素的值&lt;br/&gt;2. index(可选), 当前元素的索引值&lt;br/&gt;3. arr(可选),数组对象本身&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;thisValue(可选): 当执行回调函数时this绑定对象的值，默认值为undefined&lt;/p&gt;
&lt;p&gt;这两个方法都可以识别NaN,弥补了indexOf的不足.&lt;/p&gt;
&lt;p&gt;eg:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_766482&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;20&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;15&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;29&quot;&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1, 4, -5, 10].find((n) =&amp;gt; n &amp;lt; 0);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let b = [1, 4, -5, 10,NaN].find((n) =&amp;gt; Object.is(NaN, n));&lt;/code&gt; &lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let a = [1, 4, -5, 10].findIndex((n) =&amp;gt; n &amp;lt; 0);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let b = [1, 4, -5, 10,NaN].findIndex((n) =&amp;gt; Object.is(NaN, n));&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;浏览器兼容(MDN):Chrome 45,Firefox 25,Opera 32, Safari 8, Edge yes,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ES6 keys()&amp;amp;values()&amp;amp;entries() 遍历键名、遍历键值、遍历键名+键值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：三个方法都返回一个新的 Array Iterator 对象，对象根据方法不同包含不同的值。&lt;/p&gt;
&lt;p&gt;语法：&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_421534&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot;&gt;
&lt;div class=&quot;container&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;array.keys()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;array.values()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;array.entries()&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;参数：无。&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_77368&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;p&gt;8&lt;/p&gt;
&lt;p&gt;9&lt;/p&gt;
&lt;p&gt;10&lt;/p&gt;
&lt;p&gt;11&lt;/p&gt;
&lt;p&gt;12&lt;/p&gt;
&lt;p&gt;13&lt;/p&gt;
&lt;p&gt;14&lt;/p&gt;
&lt;p&gt;15&lt;/p&gt;
&lt;p&gt;16&lt;/p&gt;
&lt;p&gt;17&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;for&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(let index of [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'a'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'b'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;].keys()) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(index);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;



&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;for&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(let elem of [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'a'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'b'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;].values()) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(elem);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;



&lt;p&gt;&lt;code class=&quot;js keyword&quot;&gt;for&lt;/code&gt; &lt;code class=&quot;js plain&quot;&gt;(let [index, elem] of [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'a'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'b'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;].entries()) {&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js spaces&quot;&gt; &lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(index, elem);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;}&lt;/code&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在for..of中如果遍历中途要退出，可以使用break退出循环。&lt;/p&gt;
&lt;p&gt;如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历:&lt;/p&gt;
&lt;div class=&quot;jb51code&quot;&gt;
&lt;div&gt;
&lt;div id=&quot;highlighter_778370&quot; class=&quot;syntaxhighlighter js&quot;&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td class=&quot;gutter&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td class=&quot;code&quot; readability=&quot;9&quot;&gt;
&lt;div class=&quot;container&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let letter = [&lt;/code&gt;&lt;code class=&quot;js string&quot;&gt;'a'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'b'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;,&lt;/code&gt; &lt;code class=&quot;js string&quot;&gt;'c'&lt;/code&gt;&lt;code class=&quot;js plain&quot;&gt;];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;let entries = letter.entries();&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(entries.next().value);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(entries.next().value);&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;js plain&quot;&gt;console.log(entries.next().value);&lt;/code&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;entries()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 7.1&lt;/p&gt;
&lt;p&gt;keys()浏览器兼容性(MDN):Chrome 38, Firefox 28,Opera 25,Safari 8,&lt;/p&gt;
&lt;p&gt;注意:目前只有Safari 9支持,，其他浏览器未实现，babel转码器也还未实现&lt;/p&gt;
</description>
<pubDate>Sat, 22 Dec 2018 07:17:00 +0000</pubDate>
<dc:creator>小太阳xdq</dc:creator>
<og:description>改变原数组的方法(9个): 1 2 3 4 5 let a = [1,2,3]; ES5: a.pop()/ a.shift()/ a.push()/ a.unshift()/ a.reverse()</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuxiaoyu/p/10145411.html</dc:identifier>
</item>
<item>
<title>SpringBoot应用启动过程分析 - pinezhang</title>
<link>http://www.cnblogs.com/ilovena/p/10161129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ilovena/p/10161129.html</guid>
<description>&lt;p&gt;真的好奇害死猫！之前写过几个SpringBoot应用，但是一直没搞明白应用到底是怎么启动的，心里一直有点膈应。好吧，趁有空去看了下源码，写下这篇博客作为学习记录吧！&lt;br/&gt;个人拙见，若哪里有理解不对的地方，请各路大神指正，小弟不胜感激！&lt;/p&gt;
&lt;h2 id=&quot;一.应用启动类&quot;&gt;一.应用启动类&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开发SpirngBoot应用时，入口类就这简单的几行。但是却完成了N多服务的初始化、加载和发布。那么这几行代码究竟干了什么呢，SpringBoot应用到底是怎么启动的。&lt;/p&gt;
&lt;h2 id=&quot;二.springbootapplication注解&quot;&gt;二.@SpringBootApplication注解&lt;/h2&gt;
&lt;h3 id=&quot;springbootapplication注解&quot;&gt;2.1.SpringBootApplication注解&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@SpringBootApplication=@SpringBootConfiguration+@EnableAutoConfiguration+@ComponentScan&lt;/p&gt;
&lt;h3 id=&quot;springbootconfiguration&quot;&gt;2.2.@SpringBootConfiguration&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Indicates that a class Spring Boot application
 * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's
 * standard {@code @Configuration} annotation so that configuration can be found
 * automatically (for example in tests).
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface SpringBootConfiguration {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SpringBootConfiguration注解和Spring的@Configuration注解作用一样。标注当前类是配置类，并会将当前类内声明的一个或多个以@Bean注解标记的方法的实例纳入到spring容器中。比如容器加载时，会生成Hello的Bean加载到IOC容器中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootConfiguration
public class ExampleConfig {
    @Bean
    public void Hello(){
        System.out.println(&quot;hello&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;enableautoconfiguration&quot;&gt;2.3.@EnableAutoConfiguration&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SuppressWarnings(&quot;deprecation&quot;)
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(EnableAutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个注解是SpringBoot能进行自动配置的关键。@Import注解用于导入配置类，我们看下导入类EnableAutoConfigurationImportSelector。容器刷新时，会调用AutoConfigurationImportSelector类的selectImports方法，扫描META-INF/spring.factories文件自动配置类（key为EnableAutoConfiguration），然后Spring容器处理配置类。（对Spring的一些加载过程不清晰，我是相当的迷啊）&lt;/p&gt;
&lt;h3 id=&quot;componentscan&quot;&gt;2.4.@ComponentScan&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ComponentScan(excludeFilters = {
      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
/**
 * Configures component scanning directives for use with @{@link Configuration} classes.
 * Provides support parallel with Spring XML's {@code &amp;lt;context:component-scan&amp;gt;} element.
 *
 * &amp;lt;p&amp;gt;Either {@link #basePackageClasses} or {@link #basePackages} (or its alias
 * {@link #value}) may be specified to define specific packages to scan. If specific
 * packages are not defined, scanning will occur from the package of the
 * class that declares this annotation.
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
@Documented
@Repeatable(ComponentScans.class)
public @interface ComponentScan &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@ComponentScan扫描指定的包路径，若未指定包路径，则以声明这个注解的类作为基本包路径。比如@SpringBootApplication就没有指定包路径，则DemoApplication的包路径将作为扫描的基本包路径，因此强烈建议将主类放在顶层目录下。&lt;/p&gt;
&lt;p&gt;excludeFilters属性指定哪些类型不符合组件扫描的条件，会在扫描的时候过滤掉。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如上面这段代码。@Filter声明了过滤器类型类为自定义类型（需要实现TypeFilter接口），过滤器为AutoConfigurationExcludeFilter。当match方法为true，返回扫描类对象，否则过滤掉。但是要注意@ComponentScan的key为excludeFilters，因此这些类型将在包扫描的时候过滤掉，也就是说，ComponentScan在扫描时，发现当前扫描类满足macth的条件(match返回true)，是不会将该类加载到容器的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //metadataReader  表示读取到的当前正在扫描的类的信息
    //metadataReaderFactory 表示可以获得到其他任何类的信息
    @Override
    public boolean match(MetadataReader metadataReader,
            MetadataReaderFactory metadataReaderFactory) throws IOException {
        return isConfiguration(metadataReader) &amp;amp;&amp;amp; isAutoConfiguration(metadataReader);
    }
    //该类是带有Configuration注解的配置类
    private boolean isConfiguration(MetadataReader metadataReader) {
        return metadataReader.getAnnotationMetadata()
                .isAnnotated(Configuration.class.getName());
    }
    //该类是否为spring.factory配置的自动配置类
    private boolean isAutoConfiguration(MetadataReader metadataReader) {
        return getAutoConfigurations()
                .contains(metadataReader.getClassMetadata().getClassName());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.rundemoapplication.class-args解析&quot;&gt;三.run(DemoApplication.class, args)解析&lt;/h2&gt;
&lt;h3 id=&quot;进入springapplication&quot;&gt;3.1.进入SpringApplication&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt;[] primarySources,
      String[] args) {
   return new SpringApplication(primarySources).run(args);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们根据DemoApplication跟进代码，发现其调用的SpringApplication类的run方法。这个方法就干了2件事：一是创建SpringApplication对象，二是启动SpringApplication。&lt;/p&gt;
&lt;h3 id=&quot;springapplication构造器分析&quot;&gt;3.2.SpringApplication构造器分析&lt;/h3&gt;
&lt;h4 id=&quot;构造器&quot;&gt;1.构造器&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public SpringApplication(Class&amp;lt;?&amp;gt;... primarySources) {
    this(null, primarySources);
}
/**
* Create a new {@link SpringApplication} instance. The application context will load
* beans from the specified primary sources
*/
public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) {
   this.resourceLoader = resourceLoader;
   Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);
   this.primarySources = new LinkedHashSet&amp;lt;&amp;gt;(Arrays.asList(primarySources));
  //根据应用是否存在某些类推断应用类型，分为响应式web应用，servlet类型web应用和非web应用，在后面用于确定实例化applicationContext的类型
   this.webApplicationType = WebApplicationType.deduceFromClasspath();
   //设置初始化器，读取spring.factories文件key ApplicationContextInitializer对应的value并实例化
   //ApplicationContextInitializer接口用于在Spring上下文被刷新之前进行初始化的操作
   setInitializers((Collection) getSpringFactoriesInstances(
         ApplicationContextInitializer.class));

   //设置监听器，读取spring.factories文件key ApplicationListener对应的value并实例化
   // interface ApplicationListener&amp;lt;E extends ApplicationEvent&amp;gt; extends EventListener
   //ApplicationListener继承EventListener，实现了观察者模式。对于Spring框架的观察者模式实现，它限定感兴趣的事件类型需要是ApplicationEvent类型事件

   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
   //没啥特别作用，仅用于获取入口类class对象
   this.mainApplicationClass = deduceMainApplicationClass();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在构造器里主要干了2件事，一个设置初始化器，二是设置监听器。&lt;/p&gt;
&lt;h4 id=&quot;设置初始化器&quot;&gt;2.设置初始化器&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;setInitializers((Collection) getSpringFactoriesInstances(
      ApplicationContextInitializer.class));&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt; type) {
   return getSpringFactoriesInstances(type, new Class&amp;lt;?&amp;gt;[] {});
}

private &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt; type,
      Class&amp;lt;?&amp;gt;[] parameterTypes, Object... args) {
   ClassLoader classLoader = getClassLoader();
   // Use names and ensure unique to protect against duplicates
   Set&amp;lt;String&amp;gt; names = new LinkedHashSet&amp;lt;&amp;gt;(
    //从类路径的META-INF处读取相应配置文件spring.factories，然后进行遍历，读取配置文件中Key(type)对应的value
         SpringFactoriesLoader.loadFactoryNames(type, classLoader));
   //将names的对象实例化
   List&amp;lt;T&amp;gt; instances = createSpringFactoriesInstances(type, parameterTypes,
         classLoader, args, names);
   AnnotationAwareOrderComparator.sort(instances);
   return instances;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据入参type类型ApplicationContextInitializer.class从类路径的META-INF处读取相应配置文件spring.factories并实例化对应Initializer。上面这2个函数后面会反复用到。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;设置监听器&quot;&gt;3.设置监听器&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和设置初始化器一个套路，通过getSpringFactoriesInstances函数实例化监听器。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;org.springframework.context.ApplicationListener=\
org.springframework.boot.ClearCachesApplicationListener,\
org.springframework.boot.builder.ParentContextCloserApplicationListener,\
org.springframework.boot.context.FileEncodingApplicationListener,\
org.springframework.boot.context.config.AnsiOutputApplicationListener,\
org.springframework.boot.context.config.ConfigFileApplicationListener,\
org.springframework.boot.context.config.DelegatingApplicationListener,\
org.springframework.boot.context.logging.ClasspathLoggingApplicationListener,\
org.springframework.boot.context.logging.LoggingApplicationListener,\
org.springframework.boot.liquibase.LiquibaseServiceLocatorApplicationListener&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;runstring...-args解析&quot;&gt;3.3.run(String... args)解析&lt;/h3&gt;
&lt;h4 id=&quot;run函数&quot;&gt;1.run函数&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
* Run the Spring application, creating and refreshing a new ApplicationContext
*/

public ConfigurableApplicationContext run(String... args) {
   //计时器
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();

   ConfigurableApplicationContext context = null;
   Collection&amp;lt;SpringBootExceptionReporter&amp;gt; exceptionReporters = new ArrayList&amp;lt;&amp;gt;();

   //设置java.awt.headless系统属性为true，Headless模式是系统的一种配置模式。
   // 在该模式下，系统缺少了显示设备、键盘或鼠标。但是服务器生成的数据需要提供给显示设备等使用。
   // 因此使用headless模式，一般是在程序开始激活headless模式，告诉程序，现在你要工作在Headless        mode下，依靠系统的计算能力模拟出这些特性来
   configureHeadlessProperty();

   //获取监听器集合对象
   SpringApplicationRunListeners listeners = getRunListeners(args);

   //发出开始执行的事件。
   listeners.starting();

   try {
      //根据main函数传入的参数，创建DefaultApplicationArguments对象
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      //根据扫描到的监听器对象和函数传入参数，进行环境准备。
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);

      configureIgnoreBeanInfo(environment);
      Banner printedBanner = printBanner(environment);

      context = createApplicationContext();

      //和上面套路一样，读取spring.factories文件key SpringBootExceptionReporter对应的value
      exceptionReporters = getSpringFactoriesInstances(
            SpringBootExceptionReporter.class,
            new Class[] { ConfigurableApplicationContext.class }, context);

      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);

      //和上面的一样，context准备完成之后，将触发SpringApplicationRunListener的contextPrepared执行
      refreshContext(context);

      //其实啥也没干。但是老版本的callRunners好像是在这里执行的。
      afterRefresh(context, applicationArguments);

      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      //发布ApplicationStartedEvent事件，发出结束执行的事件
      listeners.started(context);
      //在某些情况下，我们希望在容器bean加载完成后执行一些操作，会实现ApplicationRunner或者CommandLineRunner接口
      //后置操作，就是在容器完成刷新后，依次调用注册的Runners，还可以通过@Order注解设置各runner的执行顺序。
      callRunners(context, applicationArguments);
   }
   catch (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, listeners);
      throw new IllegalStateException(ex);
   }

   try {
      listeners.running(context);
   }
   catch (Throwable ex) {
      handleRunFailure(context, ex, exceptionReporters, null);
      throw new IllegalStateException(ex);
   }
   return context;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取run-listeners&quot;&gt;2.获取run listeners&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SpringApplicationRunListeners listeners = getRunListeners(args);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和构造器设置初始化器一个套路，根据传入type SpringApplicationRunListener去扫描spring.factories文件，读取type对应的value并实例化。然后利用实例化对象创建SpringApplicationRunListeners对象。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;org.springframework.boot.SpringApplicationRunListener=\
org.springframework.boot.context.event.EventPublishingRunListener&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;EventPublishingRunListener的作用是发布SpringApplicationEvent事件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EventPublishingRunListener更像是被监听对象，这个命名让我有点迷。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered {
    ......
   @Override
   public void starting() {
      this.initialMulticaster.multicastEvent(
            new ApplicationStartingEvent(this.application, this.args));
   }

   @Override
   public void environmentPrepared(ConfigurableEnvironment environment) {
      this.initialMulticaster.multicastEvent(new ApplicationEnvironmentPreparedEvent(
            this.application, this.args, environment));
   }
    ........
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;发出开始执行的事件&quot;&gt;3.发出开始执行的事件&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;listeners.starting();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续跟进starting函数，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void starting() {
   this.initialMulticaster.multicastEvent(
         new ApplicationStartingEvent(this.application, this.args));
}
//获取ApplicationStartingEvent类型的事件后，发布事件
    @Override
    public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) {
        ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
        for (final ApplicationListener&amp;lt;?&amp;gt; listener : getApplicationListeners(event, type)) {
            Executor executor = getTaskExecutor();
            if (executor != null) {
                executor.execute(() -&amp;gt; invokeListener(listener, event));
            }
            else {
                invokeListener(listener, event);
            }
        }
    }
//继续跟进invokeListener方法,最后调用ApplicationListener监听者的onApplicationEvent处理事件
    private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) {
        try {
            listener.onApplicationEvent(event);
        }
        catch (ClassCastException ex) {
            .....
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个后面也会反复遇到，比如listeners.running(context)。&lt;/p&gt;
&lt;p&gt;这里是典型的观察者模式。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//观察者：监听&amp;lt;E extends ApplicationEvent&amp;gt;类型事件
ApplicationListener&amp;lt;E extends ApplicationEvent&amp;gt; extends EventListener

//事件类型：
Event extends SpringApplicationEvent  extends ApplicationEvent extends EventObject

//被观察者：发布事件
EventPublishingRunListener implements SpringApplicationRunListener&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SpringApplication根据当前事件Event类型，比如ApplicationStartingEvent，查找到监听ApplicationStartingEvent的观察者EventPublishingRunListener，调用观察者的onApplicationEvent处理事件。&lt;/p&gt;
&lt;h4 id=&quot;环境准备&quot;&gt;4.环境准备&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//根据main函数传入的参数，创建DefaultApplicationArguments对象
ApplicationArguments applicationArguments = new DefaultApplicationArguments(
      args);
//根据扫描到的listeners对象和函数传入参数，进行环境准备。
ConfigurableEnvironment environment = prepareEnvironment(listeners,
      applicationArguments);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ApplicationArguments提供运行application的参数，后面会作为一个Bean注入到容器。这里重点说下prepareEnvironment方法做了些什么。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private ConfigurableEnvironment prepareEnvironment(
      SpringApplicationRunListeners listeners,
      ApplicationArguments applicationArguments) {

   // Create and configure the environment
   ConfigurableEnvironment environment = getOrCreateEnvironment();

   configureEnvironment(environment, applicationArguments.getSourceArgs());

    //和listeners.starting一样的流程
   listeners.environmentPrepared(environment);

   //上述完成了环境的创建和配置，传入的参数和资源加载到environment

   //绑定环境到SpringApplication
   bindToSpringApplication(environment);
   if (!this.isCustomEnvironment) {
      environment = new EnvironmentConverter(getClassLoader())
            .convertEnvironmentIfNecessary(environment, deduceEnvironmentClass());
   }
   ConfigurationPropertySources.attach(environment);
   return environment;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码核心有3个。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;configureEnvironment，用于基本运行环境的配置。&lt;/li&gt;
&lt;li&gt;发布事件ApplicationEnvironmentPreparedEvent。和发布ApplicationStartingEvent事件的流程一样。&lt;/li&gt;
&lt;li&gt;绑定环境到SpringApplication&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;创建applicationcontext&quot;&gt;5.创建ApplicationContext&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;context = createApplicationContext();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;传说中的IOC容器终于来了。&lt;/p&gt;
&lt;p&gt;在实例化context之前，首先需要确定context的类型，这个是根据应用类型确定的。应用类型webApplicationType在构造器已经推断出来了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected ConfigurableApplicationContext createApplicationContext() {
   Class&amp;lt;?&amp;gt; contextClass = this.applicationContextClass;
   if (contextClass == null) {
      try {
         switch (this.webApplicationType) {
         case SERVLET:
            //应用为servlet类型的web应用
            contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
            break;
         case REACTIVE:
            //应用为响应式web应用
            contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
            break;
         default:
            //应用为非web类型的应用
            contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
         }
      }
      catch (ClassNotFoundException ex) {
         throw new IllegalStateException(
               &quot;Unable create a default ApplicationContext, &quot;
                     + &quot;please specify an ApplicationContextClass&quot;,
               ex);
      }
   }
   return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取context类型后，进行实例化，这里根据class类型获取无参构造器进行实例化。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static &amp;lt;T&amp;gt; T instantiateClass(Class&amp;lt;T&amp;gt; clazz) throws BeanInstantiationException {
   Assert.notNull(clazz, &quot;Class must not be null&quot;);
   if (clazz.isInterface()) {
      throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);
   }
   try {
       //clazz.getDeclaredConstructor()获取无参的构造器，然后进行实例化
      return instantiateClass(clazz.getDeclaredConstructor());
   }
   catch (NoSuchMethodException ex) {
    .......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如web类型为servlet类型，就会实例化org.springframework.boot.web.servlet.context.&lt;/p&gt;
&lt;p&gt;AnnotationConfigServletWebServerApplicationContext类型的context。&lt;/p&gt;
&lt;h4 id=&quot;context前置处理阶段&quot;&gt;6.context前置处理阶段&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void prepareContext(ConfigurableApplicationContext context,
      ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
      ApplicationArguments applicationArguments, Banner printedBanner) {
   //关联环境
   context.setEnvironment(environment);

   //ApplicationContext预处理，主要配置Bean生成器以及资源加载器
   postProcessApplicationContext(context);
    
   //调用初始化器，执行initialize方法，前面set的初始化器终于用上了
   applyInitializers(context);
   //发布contextPrepared事件，和发布starting事件一样，不多说
   listeners.contextPrepared(context);
   if (this.logStartupInfo) {
      logStartupInfo(context.getParent() == null);
      logStartupProfileInfo(context);
   }

   // Add boot specific singleton beans
   ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();
   //bean, springApplicationArguments,用于获取启动application所需的参数
   beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments);
    
   //加载打印Banner的Bean
   if (printedBanner != null) {
      beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner);
   }
   
   if (beanFactory instanceof DefaultListableBeanFactory) {
      ((DefaultListableBeanFactory) beanFactory)
            .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
   }
   // Load the sources，根据primarySources加载resource。primarySources:一般为主类的class对象
   Set&amp;lt;Object&amp;gt; sources = getAllSources();
   Assert.notEmpty(sources, &quot;Sources must not be empty&quot;);
   //构造BeanDefinitionLoader并完成定义的Bean的加载
   load(context, sources.toArray(new Object[0]));
   //发布ApplicationPreparedEvent事件，表示application已准备完成
   listeners.contextLoaded(context);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;刷新容器&quot;&gt;7.刷新容器&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void refreshContext(ConfigurableApplicationContext context) {
   refresh(context);
   // 注册一个关闭容器时的钩子函数,在jvm关闭时调用
   if (this.registerShutdownHook) {
      try {
         context.registerShutdownHook();
      }
      catch (AccessControlException ex) {
         // Not allowed in some environments.
      }
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用父类AbstractApplicationContext刷新容器的操作，具体的还没看。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // Prepare this context for refreshing.
      prepareRefresh();

      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // Prepare the bean factory for use in this context.
      prepareBeanFactory(beanFactory);

      try {
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);

         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);

         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);

         // Initialize message source for this context.
         initMessageSource();

         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();

         // Initialize other special beans in specific context subclasses.
         onRefresh();

         // Check for listener beans and register them.
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);

         // Last step: publish corresponding event.
         finishRefresh();
      }
       ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;后置操作调用runners&quot;&gt;8.后置操作，调用Runners&lt;/h4&gt;
&lt;p&gt;后置操作，就是在容器完成刷新后，依次调用注册的Runners，还可以通过@Order注解设置各runner的执行顺序。&lt;/p&gt;
&lt;p&gt;Runner可以通过实现ApplicationRunner或者CommandLineRunner接口。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private void callRunners(ApplicationContext context, ApplicationArguments args) {
        List&amp;lt;Object&amp;gt; runners = new ArrayList&amp;lt;&amp;gt;();
        runners.addAll(context.getBeansOfType(ApplicationRunner.class).values());
        runners.addAll(context.getBeansOfType(CommandLineRunner.class).values());
        AnnotationAwareOrderComparator.sort(runners);
        for (Object runner : new LinkedHashSet&amp;lt;&amp;gt;(runners)) {
            if (runner instanceof ApplicationRunner) {
                callRunner((ApplicationRunner) runner, args);
            }
            if (runner instanceof CommandLineRunner) {
                callRunner((CommandLineRunner) runner, args);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据源码可知，runners收集从容器获取的ApplicationRunner和CommandLineRunner类型的Bean，然后依次执行。&lt;/p&gt;
&lt;h4 id=&quot;发布applicationreadyevent事件&quot;&gt;9.发布ApplicationReadyEvent事件&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;listeners.running(context);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;应用启动完成，可以对外提供服务了，在这里发布ApplicationReadyEvent事件。流程还是和starting时一样。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Dec 2018 07:07:00 +0000</pubDate>
<dc:creator>pinezhang</dc:creator>
<og:description>真的好奇害死猫！之前写过几个SpringBoot应用，但是一直没搞明白应用到底是怎么启动的，心里一直有点膈应。好吧，趁有空去看了下源码，写下这篇博客作为学习记录吧！ 个人拙见，若哪里有理解不对的地方，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ilovena/p/10161129.html</dc:identifier>
</item>
<item>
<title>浅说机器学习理论 - kangheng</title>
<link>http://www.cnblogs.com/kangheng/p/10160363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kangheng/p/10160363.html</guid>
<description>&lt;p&gt;机器学习是现在在风口上。其包括一系列的具体算法，学习这些算法需要一定的数学基础（线性代数、概率论），网上有大量的资料可以参考学习；对于工程来说门槛就更低了，有许多优秀的现成框架可以使用。虽然我们调用一些api、调调参数就能完成很多工作，但是理解这背后的“为什么”还需要下一番功夫。机器学习理论是该领域的分析框架，这方面的内容比较抽象，且“实用性不强”，所以常常被人忽略。这篇博客就来通俗地讲讲这些理论。&lt;/p&gt;
&lt;h3&gt;1.什么是机器学习&lt;/h3&gt;
&lt;p&gt;计算机编程算法是用来解决各种实际问题的。在传统的算法中，面对一个实际问题，程序员靠个人的智慧推导出了问题准确的解决方法，然后通过编写程序解决问题。如果把寻找解决方案的过程比喻成寻宝，把具体解决问题的方案比作宝藏的话，那么传统的编程就是靠人的推理的推导出了宝藏的具体位置。但现实中有大量的问题很难由人推测出精确的解决方案，尤其是那些涉及变量很多（高维）的问题。面对这类问题虽然难于给出一个确切的解决方案，但我们总觉得可以找到一个“大概”或者说“模糊”的解决方案（有统计规律）。&lt;/p&gt;
&lt;p&gt;机器学习正是为了解决这种问题的，它是对“确切推导出宝藏位置”这一条件的软化，虽然我们不能推出宝藏的准确位置，但是我们可以给出这一宝藏的大致范围（对应着hypothesis set）然后利用算法通过大量的数据从这个范围中筛选出“宝藏”。例如在预测房价这种机器学习的典型任务中，影响因素可能上千个，我们不太可能推导出一个包含这些影响因素的确切方程。但是我们可以给出一个范围，即一个相对模糊的解决方案，例如：“这些影响因素与房价呈线性关系”，这么一来我们划定的宝藏范围就是“所有的线性方程的集合”，然后机器学习要做的是从这些候选集中通过与大量数据进行“比对”找出一个合适的具体方程当做我们要找的“宝藏”。这就是机器学习算法的寻宝过程。&lt;/p&gt;
&lt;p&gt;一个机器学习算法要成功，首先这个定的范围需要能框住正在的“宝藏”，其次这个找宝藏的过程也得合理高效，并且还得有足够的数据进行比对筛选。下面我们来说说这么判定我们挖出了真正的宝藏。&lt;/p&gt;
&lt;h3&gt;2.怎么判断机器学习“学”到了东西&lt;/h3&gt;
&lt;p&gt;前文我们说机器学习是在一堆算法的候选集中，通过大量数据的“比对”选出一个表现好的算法。这部分用于“比对”的数据就叫“训练集”。通过训练集“选出来”的算法往往在训练集上表现很好。但这样的效果并不仅仅是我们想要的，机器学习算法的输出是一个“解决方案”，靠这个“解决方案”去应对所有的输入情况，而训练集仅仅包括了输入可能性的一小部分，我们希望以这一小部分的数据训练模型，能让模型处理它没有见过的数据（泛化）。打个比方，你通过一些例题去教一个孩子线性方程组的解法，教完过后这些孩子对于例题应该都能熟练解答，但是评价这个孩子是否“学会了”不应该拿这些例题去考他，而应该用他没见过的线性方程组去考他，即看他是否有举一反三（泛化）的能力。&lt;/p&gt;
&lt;p&gt;机器学习中有一套理论去保证泛化能力。为了体现我不是民科，我还是搬几个公式吧：） 。首先一个理论基础是霍夫丁不等式Hoeffding Inequality ：&lt;/p&gt;
&lt;p&gt; $P(\left | \nu -\mu  \right |&amp;gt; \varepsilon )&amp;lt; 2exp(-2\varepsilon ^{2}N)......(1)$  &lt;/p&gt;
&lt;p&gt;这篇文章不打算详细推导数学，所以这里我只讲公式背后的故事。这个不等式告诉我们的是：我们通过有限数据得到的参数$\nu$（算法在训练集上的误差）与理想中的参数$\mu$（算法在所有数据上的误差）之间的关系：$\nu$与$\mu$之间的误差大于 $\varepsilon$的概率小于不等式的右边的指数表达式的结果。不等式右边N是计算出用到的数据量（训练集大小）， $\varepsilon$是允许的误差。&lt;/p&gt;
&lt;p&gt;这个公式告诉我们只要使用的数据量足够大，单个算法在训练集的表现能够代表这个算法在所有数据上的真实表现。这个公式只是告诉我们一个算法的情况，但是我们说过机器学习的过程是在所有候选集上挑一个最好的算法。候选集一多，出现小概率事件的概率会变大。例如买彩票，对于我一个人而言中大奖的概率是微乎其微的，但对于一个集合来说，比如全北京买彩票的中有人中大奖的概率还是很高的。数学上我们用union bound 来代表这类问题：&lt;/p&gt;
&lt;p&gt;$P( A_{1}\cup A_{2} ...\cup A_{k} )&amp;lt; P ( A_{1} )+ P ( A_{2} )+...+P( A_{k}  )......(2)$&lt;/p&gt;
&lt;p&gt; 在（1）中考虑union bound后可以得到：&lt;/p&gt;
&lt;p&gt;$P\left ( \exists h_{i}\in H ,\left | \nu (h_{i})-\mu (h_{i}) \right | &amp;gt;\varepsilon \right ) \leqslant  2kexp(-2\varepsilon^{2}N )......(3)$&lt;/p&gt;
&lt;p&gt;与（1）式不同的是（3）式中k是模型候选集的大小，其余参数基本相同，这个式子告诉我们即使训练数据足够大，如果我们的候选集中包含的候选算法太多（k太大）也可能得到错误的结果。这也应了那句谚语“林子大了什么鸟都有”：）。因此在机器学习中模型复杂度的选择是一个需要折中考虑的量，一方面模型越复杂即我们划的“范围”越大，则这个范围内包含“宝藏”的概率就越大，另一方面林子变大了出现“坏鸟”的概率也变大了。理想的情况是我们模型的范围取得“准且小”，这当然需要我们对要解决的这类问题有比较多的先验知识，一种极端的情况是当我们的先验知识足够充分了，就可以把我们的范围缩小成一个“点”，即直接找到一个具体算法，这本质上就退化到了传统编程解决问题的方法了。实际上（3）式的刻画是比较粗糙的，大多数情况下k是无穷大的。在机器学习中为了解决无穷问题又有“打散”、VC维等概念，这些概念的补充对（3）式右边所代表的上界进行了更精确地刻画。但是在这里（3）式足够表达上述思想了，那些“更精确”的理论这里就不讲了，如果感兴趣可以参考相关教材。&lt;/p&gt;
&lt;p&gt;        机器学习算法对应着两类误差即偏差和方差，在实际工作中，判断模型的主要误差是哪一种是后续进一步优化模型才有正确的方向。你可以在网上查到大量方差和偏差的“正统”定义，在本文里我就讲一讲我的偏门理解：偏差度量的是由于圈的地太小了，没有圈住“宝藏”引起的误差；方差是指圈的地太大了，林子里出现了“坏鸟”产生的误差。当机器学习的误差由偏差主导时，这时候就可以考虑增大模型的复杂度，即圈更大的范围。当模型的误差由方差主导时，这时就需要降低模型的复杂度，加更多的数据（筛选更严）或者采用一些正则化的方法。说道正则化，我理解的就是对模型做出一些限制，让模型选择的范围缩小，正则化有效地前提是这样的范围缩小是合理的，而要满足这个要的还是先验知识。以上就是对机器学习理论的一些理解，下面用一个例子进行说明。&lt;/p&gt;
&lt;h3&gt;3一个实例&lt;/h3&gt;
&lt;p&gt;现在以公司招聘为例子对机器学习进行类比。公司招人的目的是找一个合适的员工到公司，对应着机器学习里面是“训练”出一个合适的算法供以后使用。现在假设公司招人的办法就是出一些题让候选者解答，从中选出得分最高的人，把这个人招进来；这对应着机器学习里面通过大量的数据挑选出合适的算法，此处“题”和“数据”相对应，“候选人”和“候选算法”相对应。假设公司的题都是选择题的类型，现在公司有20道这样的题（数据量），那么对于一个应聘者来说如果他能全部做对这些题，那么他大概率是合格的，因为这些题他全部能蒙对的概率很小（0.25^20）。&lt;/p&gt;
&lt;p&gt;现在公司定了个算法：去外面大街拉50个人来做题，如果能全部做对就认为他是合格的候选者。这个算法的缺点是很可能这50个人里面没一个人做得好，所以招不到合适的人，这对应着机器学习里的欠拟合：由于模型不够强（候选集太小）导致的效果不好；而且这个例子中是“去大街上拉50个人”，这个模型的选取没有利用好先验知识，这在机器学习中属于模型选取不当，比如本来应该用gmm模型而实际用成了hmm模型。&lt;/p&gt;
&lt;p&gt;由于上面的方法没招到人，于是老板说：“既然候选人太少了，那咱多拉点人来，反正咱们国家最不缺的就是人”，然后拉了1亿人来做题。这种情况下有候选人拿了满分，那么这个人就是合格的吗？在上一个50个候选人的情况下如果有人全做对我们可以认为他大概率很优秀，但是现在这个基数变成了1亿人，一个人要全部蒙对的概率很小，但是1亿人中出一个全蒙对的概率还是很大。所以这对应着机器学习里面的“过拟合”问题，算法在训练集上表现很好，但实际应用时却效果却很差（这个凭运气进入公司的人并不能胜任工作）。面对这种问题可以出更有难度的试题（更好的数据）或这增加题量（加数据）来让蒙对的概率变低。另外也可以换候选者范围（对应着换算法或加正则化），让候选者的范围合理地变小一点。&lt;/p&gt;
&lt;p&gt;例如在这个例子中更理性一点的算法是将候选者范围换成大学本科毕业相关专业的几百个人，再让他们来答题，这样的话大概率能选出我们的要的人。机器学习里面有个定理叫“没有免费午餐定律”说的就是不能抛开具体的任务，去评价算法。因为一个机器学习算法对应着一个候选的范围，当我们问题的答案落在了这个范围内，有足够的数据就能训练出合适的答案。另一方面如果一个算法非常强大，但它的范围没包含我们的答案，那么有再多的数据也白搭，其效果可能还不如那些不那么“强大”的算法。这就是我对于机器学习理论的一些理解，希望能够对你有点启发，如果想要全面、严谨、数学化的理解机器学习的理论我推荐林轩田的《机器学习基石》的公开课。&lt;/p&gt;
&lt;h3&gt;4人工智能“智能”吗&lt;/h3&gt;
&lt;p&gt;人工智能很火，但现在的人工智能真的智能吗？让我们从之前的分析中看一下在机器学习中有多少是人的“智能”，又有多少是机器的“智能”。还是以寻找宝藏为例，首先判断有没有宝藏可寻，即判断一个问题是否有统计规律可循，这是人的“智能”做出的判断；其次划定宝藏的范围也是人做的决定（选模型及模型的规模）；最后划定范围后确定怎么去找宝藏（优化函数、优化算法）也是由人指定的。因此纵观整个机器学习的过程，基本还是靠人类的智慧在解决问题，机器只是按部就班地服从人的指挥，在一定的范围中执行优化算法去找宝藏，这个过程中并没有展现出机器“智能”。&lt;/p&gt;
&lt;p&gt;虽然目前的人工智能还根本谈不上“智能”，但是我们也不必沮丧。机器学习的算法让计算机能解决更多的问题，从以前的“确定性”问题到现在的“范围”问题。而“能够解决更多的问题”这本身就是一个巨大的进步。&lt;/p&gt;
&lt;p&gt;这几年机器学习里面成功的技术是深度学习。这类算法也并未跳出上述机器学习的理论框架。但是其在计算机视觉、自然语言处理等领域表现出了最好的效果、在某些子领域中其效果甚至能超过人类。我们对深度学习为什么有效或者说深度学习模型圈下的是怎样一块地还不甚清楚，期待后续这方面的研究能够揭示出“智能”的一些边边角角。&lt;/p&gt;
</description>
<pubDate>Sat, 22 Dec 2018 06:27:00 +0000</pubDate>
<dc:creator>kangheng</dc:creator>
<og:description>机器学习是现在在风口上。其包括一系列的具体算法，学习这些算法需要一定的数学基础（线性代数、概率论），网上有大量的资料可以参考学习；对于工程来说门槛就更低了，有许多优秀的现成框架可以使用。虽然我们调用一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kangheng/p/10160363.html</dc:identifier>
</item>
<item>
<title>类和接口的使用(一) - StepByUs</title>
<link>http://www.cnblogs.com/tongAngle/p/10160971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tongAngle/p/10160971.html</guid>
<description>&lt;p&gt;一个良好的程序设计应该是层次清晰，各模块对于外部模块来说，是否只提供了对外的API而隐藏了具体的实现细节，通常对于使用者而言，只需要知道实现功能的API 而无法操作具体实现的过程，这种设计理念被称为信息隐藏也就是我们通常所说的封装。&lt;/p&gt;
&lt;p&gt;对于顶层的设计 例如接口之类的类只有两种访问级别&lt;/p&gt;
&lt;p&gt;包级私有（只能被同级包下的其他类和接口访问  也就是默认修饰符 default）和公有（public）&lt;/p&gt;
&lt;p&gt;举个例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package IO.Demo;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; DemoTest {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; final String NUMBER=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ONE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;package IO.FileIo;&lt;/span&gt;&lt;p&gt;import IO.Demo.DemoTest;&lt;/p&gt;&lt;p&gt;public class Demo {&lt;br/&gt;private DemoTest demoTest;&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接口 DemoTest 和类 Demo 分别属于不同的包&lt;/p&gt;
&lt;pre&gt;
IO.Demo和IO.FileIo
&lt;/pre&gt;
&lt;p&gt;请注意这时的 DemoTest 是属于顶级接口 被public修饰 表示公有的 这时它可以在Demo类中被调用&lt;/p&gt;
&lt;p&gt;假如此时去掉public修饰符 则此时的会发生这样的情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1562822/201812/1562822-20181222104211103-488484959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Demo此时无法调用接口 原因就是不在同级包下无法调用&lt;/p&gt;
&lt;p&gt;如果类和接口能被设定为包级私有的，请将它设计为包级私有的&lt;/p&gt;

&lt;p&gt;对于成员(域（也就是变量常量）、方法、嵌套类和嵌套接口)有四种可能的访问级别&lt;/p&gt;
&lt;p&gt;1 private (私有的)  只有在声明的该成员的顶层类内部才能访问到这个成员 但是有一点需要注意 在接口里面是不能被声明为private的。 大家可以考虑下为什么会是这样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1562822/201812/1562822-20181222110516982-1361125134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2 包级私有的 简称缺省的(default)   &lt;/p&gt;
&lt;p&gt;3 受保护的(protected) 声明该成员的子类可以访问这个成员(有一定限制)&lt;/p&gt;
&lt;p&gt;4 公有的(public) 表示在任意地方都可以访问该成员 &lt;/p&gt;
&lt;p&gt;以上的4中访问修饰符是按照访问递增等级排列的。&lt;/p&gt;
&lt;p&gt;举个应用例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; IO.FileIo;



&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run(){

    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startRun(){
            run();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Demo.startRun();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在同包内的Test类中无法调用Demo类私有的Run()方法 但是Demo提供了使用Run方法的startRun()方法&lt;/p&gt;
&lt;p&gt;这种做法就是应用了封装的理念&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1562822/201812/1562822-20181222135157198-1220563471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最近项目中 有一个程序设计的要求是要求把数据库查询的数据存储到内存中，减少对数据库的访问次数，减少程序的开销&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; IO.FileIo;


&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.HashMap;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String,Object&amp;gt; cache=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String,Object&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;  Map&amp;lt;String,Object&amp;gt;&lt;span&gt; run(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;假定这个方法里面执行了获取数据库数据的方法 getData():
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cache=getData();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时cache里面已经存在了数据 注意看cache是被static修饰的 cache存在方法区中
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以此时cache的值被存储在内存中&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; cache;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String,Object&amp;gt;&lt;span&gt; startRun(){
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; run();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何拿到这个map&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; IO.FileIo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Map;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时调用的Demo.startRun() 会有一个Map的引用被传回来 我们就可以对数据进行操作了
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在spring框架中Controller层就可以把这个map传到页面呈现&lt;/span&gt;
        Map&amp;lt;String,Object&amp;gt; map=&lt;span&gt; Demo.startRun();

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们用到了啥 &lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; private static Map&amp;lt;String,Object&amp;gt; cache=new HashMap&amp;lt;String,Object&amp;gt;();&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;

&lt;pre&gt;
Demo类中cache是私有的 我们对外提供了获得这个对象引用的API
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;startRun()&lt;br/&gt;在其他类中我们就可以调用这个方法来获取cache 而隐藏了具体怎么获得cache的细节&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 22 Dec 2018 06:25:00 +0000</pubDate>
<dc:creator>StepByUs</dc:creator>
<og:description>一个良好的程序设计应该是层次清晰，各模块对于外部模块来说，是否只提供了对外的API而隐藏了具体的实现细节，通常对于使用者而言，只需要知道实现功能的API 而无法操作具体实现的过程，这种设计理念被称为信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tongAngle/p/10160971.html</dc:identifier>
</item>
<item>
<title>(24/24) webpack小案例--自己动手用webpack构建一个React的开发环境 - 吴封斌技术博客</title>
<link>http://www.cnblogs.com/wfaceboss/p/10160064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wfaceboss/p/10160064.html</guid>
<description>&lt;p&gt;通过前面的学习，对webpack有了更深的认识，故此节我们就利用前面相关知识自己动手用webpack构建一个React的开发环境，就算是一个小案例吧。&lt;/p&gt;
&lt;p&gt;注：此处使用的开发工具是Webstorm。&lt;/p&gt;

&lt;h2&gt;1.1 新建文件夹&lt;/h2&gt;
&lt;p&gt;在安装webpack之前，我们先建立一个文件夹,并利用开发工具webstorm打开刚才新建的文件夹（或者新建项目，其项目目录选择刚才新建的文件夹），然后使用webstorm终端初始化webpack项目，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm  init -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-y:表示默认初始化所有选项。&lt;/p&gt;
&lt;p&gt; 初始化成功后可以在项目根目录下看到package.json文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181222105609861-813755707.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;1.2 安装webpack&lt;/h2&gt;
&lt;p&gt;package.json文件建立好以后，开始安装webpack，同样是在webstorm终端输入安装命令（可以使用npm安装也可以使用cnpm安装）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save-dev webpack@3.8.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;--&lt;span class=&quot;hljs-built_in&quot;&gt;save-&lt;span class=&quot;hljs-built_in&quot;&gt;dev：安装到该项目目录中。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：此处为了兼容，webpack使用3.8.1版本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;安装好后，则会在package.json里看到当前安装的webapck版本号。&lt;/p&gt;

&lt;p&gt;在项目根目录建立webpack.config.js文件，这个文件是进行webpack配置的，先建立基本的入口和出口文件。&lt;/p&gt;
&lt;h2&gt;2.1 配置&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; path =require('path'&lt;span&gt;);
module.exports &lt;/span&gt;=&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;入口文件&lt;/span&gt;
    entry:'./app/index.js'&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;出口文件&lt;/span&gt;
&lt;span&gt;    output:{
        filename:&lt;/span&gt;'index.js'&lt;span&gt;,
        path:path.resolve(__dirname,&lt;/span&gt;'dist'&lt;span&gt;)
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2 根据结构修改项目目录&lt;/h2&gt;
&lt;p&gt;文件配置好后，我们要根据文件的结构改造我们的项目目录，我们在根目录下新建app和dist文件夹，然后进入app文件夹，新建一个index.js文件。&lt;/p&gt;

&lt;p&gt;在根目录新建index.html文件，并引入webpack设置中的出口文件，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;webpack react案例&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入出口文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./temp/index.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;4.1 增加命令&lt;/h2&gt;
&lt;p&gt;打开package.json文件，在scripts属性中加入build命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;build&quot;: &quot;webpack&quot;&lt;span&gt;
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;4.2 测试配置&lt;/h2&gt;
&lt;h3&gt;4.2.1 测试代码&lt;/h3&gt;
&lt;p&gt;操作为在入口文件中写入部分代码，并进行打包测试：&lt;/p&gt;
&lt;p&gt;app/index.js文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; component(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; element = document.createElement('div'&lt;span&gt;);
    element.innerHTML &lt;/span&gt;= ('Hello webpack react'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; element;
}
document.body.appendChild(component());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.2.2 打包操作&lt;/h3&gt;
&lt;p&gt;在终端中输入npm run build进行打包，如果没有出现错误，手动在浏览器中打开index.html,出现以下效果说明配置成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181222121527610-552107083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;到该步我们还缺少一个实时更新的服务，我们开始配置：&lt;/p&gt;
&lt;h2&gt;5.1 插件安装&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;此处为了兼容使用指定安装方式。安装的版本为2.9.7。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save-dev webpack-dev-server@2.9.7
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.2 配置webpack.config.js文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;devServer:{
    contentBase:&lt;/span&gt;'./'&lt;span&gt;,
    host:&lt;/span&gt;'localhost'&lt;span&gt;,
    compress:&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,//启动压缩
    port:&lt;/span&gt;1818&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5.3 新增命令&lt;/h2&gt;
&lt;p&gt;配置好后再packeage.json里增加一个scripts命令，我们起名叫server。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;build&quot;: &quot;webpack&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;server&quot;: &quot;webpack-dev-server --open&quot;&lt;span&gt;
  },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;–open表示是直接打开浏览器。&lt;/p&gt;
&lt;h2&gt;5.4 启动服务&lt;/h2&gt;
&lt;p&gt;在终端执行npm run server 命令启动服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 浏览器自动打开，效果与前面手动结果一致。&lt;/p&gt;

&lt;p&gt;到此我们修改代码时，浏览器不能自动刷新，无法实时呈现我们编写的代码结果，只能重复新打包才能生效。&lt;/p&gt;
&lt;p&gt;解决方法为：使公共路径指向内存。temp是系统的临时文件，存放内存刷新值。&lt;/p&gt;
&lt;h2&gt;6.1 配置出口文件&lt;/h2&gt;
&lt;p&gt;在出口文件配置中加一个publicPath:’temp/’ 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;出口文件&lt;/span&gt;
&lt;span&gt;    output:{
        filename:&lt;/span&gt;'index.js'&lt;span&gt;,
        path:path.resolve(__dirname,&lt;/span&gt;'dist'&lt;span&gt;),
        publicPath:&lt;/span&gt;'temp/'&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.2 修改index.html中引入的js文件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;./temp/index.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.3 重新启动服务配置成功&lt;/h2&gt;
&lt;p&gt;关闭之前的服务，然后使用npm run server 重新启动服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run server
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;6.4 测试自动刷新浏览器是否成功&lt;/h2&gt;
&lt;p&gt;改写入口文件中内容，然后保存，可以看到浏览器自动刷新，渲染了最新的值，说明自动刷新配置成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181222132342775-1769108978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在webpack中配置Babel需要先加入babel-loader，我们使用npm来进行安装，我们还需要支持es2015和React，所以要安装如下四个包：&lt;/p&gt;
&lt;p&gt;此处为了兼容问题我使用指定版本的安装方式，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
npm  install --save-dev babel-core@6.26.3 babel-loader@7.1.4 babel-preset-es2015@6.24.1 babel-preset-react@6.24.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然你也可以使用下列方式安装最新的，出现版本问题在对应去调整即可（不过有些费时费力而已，呵呵）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里四个包的安装，这四个包是不能省略。安装后你会在package.json里看到这些包的版本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &quot;babel-core&quot;: &quot;^6.26.3&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;babel-loader&quot;: &quot;^7.1.4&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;babel-preset-react&quot;: &quot;^6.24.1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;webpack&quot;: &quot;^3.8.1&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;webpack-dev-server&quot;: &quot;^2.9.7&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装完成后，我们需要对我们的babel进行一些相关配置,使其对es6、react等进行支持。&lt;/p&gt;
&lt;h2&gt;8.1 新建  &lt;code&gt;.babelrc&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;在项目根目录新建.babelrc文件，并把配置写到文件里。&lt;/p&gt;
&lt;p&gt;.babelrc:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;presets&quot;:[&quot;react&quot;,&quot;es2015&quot;&lt;span&gt;]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;.babelrc配置完成后，到webpack.config.js里配置module，也就是配置我们常说的loader。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;module:{
    loaders:[
        {
            test:&lt;/span&gt;/\.(jsx|js)$/&lt;span&gt;,//匹配掉js或者jsx的正则
            exclude:&lt;/span&gt;/node_modules/&lt;span&gt;,//排除不操作的文件
            loaders:&lt;/span&gt;&quot;babel-loader&quot;&lt;span&gt;,//使用loader进行操作&lt;/span&gt;&lt;span&gt;
        }
    ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;webpack通过上边的步骤，基本已经配置完成了，这里我们写一个React文件来进行测试一下。&lt;/p&gt;
&lt;h2&gt;10.1 安装React相关包&lt;/h2&gt;
&lt;p&gt;安装React和React-dom：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save react  react-dom
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;10.2 改写入口文件&lt;/h2&gt;
&lt;p&gt;安装完成后，我们改写app/index.js文件，把原来原生的JavaScript代码改成React代码。&lt;/p&gt;
&lt;p&gt;app/index.js:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import React from &lt;span&gt;'&lt;/span&gt;&lt;span&gt;react&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
import ReactDOM from &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;react-dom&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
ReactDOM.render(
    &lt;/span&gt;&amp;lt;div&amp;gt;Hello react&amp;lt;/div&amp;gt;&lt;span&gt;,
    document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;10.3 新增挂载点&lt;/h2&gt;
&lt;p&gt;在index.html中新增一个div层，设置id=&quot;app&quot;作为react的挂载点。&lt;/p&gt;
&lt;p&gt;index.html：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;webpack react案例&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;挂载点&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;app&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;引入出口文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./temp/index.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当上述都配置完成后，使用npm run server 重新启动服务，&lt;span&gt;若是出现失败，建议先把node_modules删除了，然后在使用 npm install 进行安装。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm run server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果在浏览器中看到了Hello react 这段文字，说明我们的配置是成功的。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/860581/201812/860581-20181222141310295-247385563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述只是简单的配置了一些内容，还很不成熟，支持的较少，实际在现实开发中已经有很多做好的脚手架供我们使用，我们不必去造轮子。&lt;/p&gt;
&lt;p&gt;若是在上述配置中出现什么问题，欢迎留言我们共同探讨。。。&lt;/p&gt;

</description>
<pubDate>Sat, 22 Dec 2018 06:18:00 +0000</pubDate>
<dc:creator>吴封斌技术博客</dc:creator>
<og:description>通过前面的学习，对webpack有了更深的认识，故此节我们就利用前面相关知识自己动手用webpack构建一个React的开发环境，就算是一个小案例吧。 注：此处使用的开发工具是Webstorm。 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wfaceboss/p/10160064.html</dc:identifier>
</item>
<item>
<title>设计模式之代理模式 - codecarver</title>
<link>http://www.cnblogs.com/1314xf/p/10160932.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1314xf/p/10160932.html</guid>
<description>&lt;h2 id=&quot;一代理模式概述&quot;&gt;一：代理模式概述&lt;/h2&gt;
&lt;p&gt;高中的时候遇到一个喜欢的女生，那时候我们都比较害羞，我们的交流全靠传话，有一个姑娘成了我们的中介，每天都给我们传递狗粮，就这样我们开心的过完了高中。然后大学。。。。好了继续代理模式的学习：&lt;code&gt;当我们没办法访问某个对象的时候可以通过一个代理对象来间接访问。&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是代理&quot;&gt;1.1 什么是代理&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;代理是一种设计模式。当我们想要添加或修改现有类的某些功能时，我们创建并使用代理对象。使用代理对象而不是原始代理对象。通常，代理对象具有与原始代理对象相同的方法，并且在Java代理类中通常会扩展原始类。代理有一个原始对象的句柄，可以调用该方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;代理的概念结构图&quot;&gt;1.2 代理的概念结构图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;结构图：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://piw7yv6sx.bkt.clouddn.com/toskye/designPattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E5%9B%BE.png&quot; alt=&quot;1545400167418&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;角色说明如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Subject(抽象主题角色)&lt;/code&gt;：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Proxy(代理主题角色)&lt;/code&gt;:包含了对真实主题的引用，从而可以在任何时候操作真实主题对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RealSubject(真实主题角色)&lt;/code&gt;：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代理可以做什么&quot;&gt;1.3 代理可以做什么&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;方法启动和停止时记录信息&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;对参数执行额外检查&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;模仿原始类的行为&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;实现对某些资源的延时访问&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在实际应用中，代理类不直接实现该功能。遵循单一责任原则，代理类仅执行代理，并且实际行为修改在处理程序中实现。当调用代理对象而不是原始对象时，代理会决定是否必须调用原始方法或某个处理程序。处理程序可以执行其任务，也可以调用原始方法。&lt;/p&gt;
&lt;p&gt;我们常常接触的代理模式主要分为两种：&lt;code&gt;静态代理模式&lt;/code&gt;和&lt;code&gt;动态代理模式&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;二静态代理模式&quot;&gt;二：静态代理模式&lt;/h2&gt;
&lt;h3 id=&quot;静态代理概念&quot;&gt;2.1 静态代理概念&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;代理对象需要实现和目标对象相同的接口或者继承相同的父类。&lt;/li&gt;
&lt;li&gt;每一个目标对象都需要对应的代理类。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;静态代理实战&quot;&gt;2.2 静态代理实战&lt;/h3&gt;
&lt;p&gt;模拟：要求更新数据前后记录日志。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象接口：IPerson&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface IPerson {
    // 更新信息
    void update();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;目标对象Person（要被代理的对象）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person implements IPerson {
    @Override
    public void update() {
        System.out.println(&quot;更新&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代理对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PersonProxy implements IPerson {

    // 接收目标对象(要被代理的对象) 针对抽象编程
    private IPerson target;
    public PersonProxy(IPerson target){
        this.target = target;
    }
    // 扩展的功能 记录日志开始
    private void handleBefore(){
        System.out.println(&quot;进入更新方法--获取参数&quot;);
    }
    // 扩展的功能 记录日志结束
    private void handleAfter(){
        System.out.println(&quot;更新成功&quot;);
    }
    // 同样的是更新方法，我们加入了记录日志的功能
    @Override
    public void update() {
       handleBefore();
       target.update();
       handleAfter();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class StaticProxyClient {
    public static void main(String[] args) {
        // 目标对象
        IPerson target = new Person();
        // 代理对象
        PersonProxy proxy = new PersonProxy(target);
        // 执行代理的方法
        proxy.update();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;总结：&lt;/em&gt;&lt;code&gt;静态代理可以在不侵入目标对象的前提下扩展功能，但是代理对象需要和目标对象实现相同的接口，导致了大量的代理类，会增加维护量，那么便引入接下来的动态代理&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三动态代理模式&quot;&gt;三：动态代理模式&lt;/h2&gt;
&lt;h3 id=&quot;动态代理概念&quot;&gt;3.1 动态代理概念&lt;/h3&gt;
&lt;p&gt;相较于静态代理，动态代理不再需要写各个&lt;code&gt;静态代理类&lt;/code&gt;，只需要简单地指定一组接口以及目标类对象就可以&lt;code&gt;动态的获得对象&lt;/code&gt;，可以简单的理解这两个的区别：&lt;code&gt;静态代理的代理类是程序员手动创建的，而动态代理的代理类是由程序创建的&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;jdk动态代理和cglib动态代理&quot;&gt;3.2 JDK动态代理和Cglib动态代理&lt;/h3&gt;
&lt;h4 id=&quot;jdk动态代理&quot;&gt;3.2.1 JDK动态代理&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;编写抽象主题接口&lt;/li&gt;
&lt;li&gt;实现InvocationHandler接口来自定义自己的InvocationHandler。&lt;/li&gt;
&lt;li&gt;通过Proxy.newProxyInstance获得动态代理类&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;--------------编码实战 ---------------&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象主题角色&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IPerson {
    void update();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;真实主题&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person implements IPerson {
    @Override
    public void update() {
        System.out.println(&quot;更新&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;自定义InvocationHandler&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyInvocationHandler implements InvocationHandler {
    //目标对象
    private Object target;
    public MyInvocationHandler(Object target){
        this.target = target;
    }
    // 横向功能扩展
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;------更新前记录日志-------------&quot;);
        //执行相应的目标方法
        Object res = method.invoke(target,args);
        System.out.println(&quot;------更新后记录日志-------------&quot;);
        return res;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;客户端调用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class client {
    public static void main(String[] args) {
        // 动态获取代理类
        IPerson proxyInstance = (IPerson) Proxy.newProxyInstance(
                IPerson.class.getClassLoader(), // 加载接口的类加载器
                new Class[]{IPerson.class}, // 一组接口
                new MyInvocationHandler(new Person())); // 自定义的InvocationHandler
        proxyInstance.update();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果打印&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;------更新前记录日志-------------&lt;br/&gt;更新&lt;br/&gt;------更新后记录日志-------------&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;---------------使用静态工厂方法来重构代码----------------&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;抽象主题角色和真实主题角色的代理不需要变动，我们新建一个proxyFactory,将MyInvocationHandler的代码和Proxy.newProxyInstance结合起来（&lt;code&gt;其实这两部分就是整个jdk代理的核心要实现的内容&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ProxyFactory&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;effective java 推荐使用静态工厂方法来创建类实例&lt;/li&gt;
&lt;li&gt;对于内部类调用外层方法参数必须要用final修饰&lt;/li&gt;
&lt;li&gt;泛型T和Object的区别&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ProxyFactory {
    public static&amp;lt;T&amp;gt; Object  getProxyInstance(final T target){
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(), new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println(&quot;------更新前记录日志-------------&quot;);
                        Object proxyInstance = method.invoke(target, args);
                        System.out.println(&quot;-----更新后记录日志-------------&quot;);
                        return proxyInstance;
                    }
                });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;那么客户端的调用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class JDKProxyClient {
    public static void main(String[] args) {
        IPerson target = new Person();
        IPerson proxy = (IPerson) ProxyFactory.getProxyInstance(target);
        proxy.update();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看完了小例子，再回顾一下InvocationHandler是干什么的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InvocationHandler:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;InvocationHandler是由代理实例的&lt;code&gt;调用处理程序&lt;/code&gt;实现的接口。 每个代理实例都有一个&lt;code&gt;关联的调用处理程序&lt;/code&gt;。当在代理实例上调用方法时，方法调用将被编码并调度到其调用处理程序的&lt;code&gt;invoke&lt;/code&gt;方法 。（调用处理程序指的就是我们的MyInvocationHandler类）&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;@Param proxy 调用该方法的&lt;code&gt;代理实例&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;@Param Method 与代理实例上调用的接口方法对应的 &lt;code&gt;Method&lt;/code&gt;实例。 &lt;code&gt;Method&lt;/code&gt;对象的声明类将是声明方法的接口，它可以是代理接口继承方法的代理接口的超接口&lt;/li&gt;
&lt;li&gt;@param args 包含在代理实例上的方法调用中传递的参数值的对象数组，如果接口方法不带参数，则为null。 原始类型的参数包含在适当的原始包装类的实例中，例如java.lang.Integer&lt;/li&gt;
&lt;li&gt;@return 从代理实例上的方法调用返回的值。 如果接口方法的声明返回类型是基本类型，&lt;code&gt;则此方法返回的值必须是相应原始包装类的实例&lt;/code&gt;; 否则，&lt;code&gt;它必须是可分配给声明的返回类型的类型&lt;/code&gt;。 如果此方法返回的值为&lt;code&gt;null且接口方法的返回类型为原始值&lt;/code&gt;，则代理实例上的方法调用将抛出 &lt;code&gt;NullPointerException&lt;/code&gt;。 如果此方法返回的值与上面描述的接口方法声明的返回类型不兼容，则代理实例上的方法调用将抛出&lt;code&gt;ClassCastException&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface InvocationHandler {
    public Object invoke(Object proxy, Method method, Object[] args)throws Throwable;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jdk动态代理总结&quot;&gt;3.2.2 JDK动态代理总结&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;jdk动态代理不再需要编写许多静态的代理类，但是目标类对象还是必须实现接口，那么当目标类不实现接口的话，jdk就无法再提供动态代理了。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h4 id=&quot;cglib动态代理&quot;&gt;3.2.3 Cglib动态代理&lt;/h4&gt;
&lt;p&gt;jdk提供的代理有个明显的缺点：需要目标对象实现一个或者多个接口。而假如你需要代理没有接口的类，可以使用Cglib库。&lt;/p&gt;
&lt;p&gt;CGLIB是一个强大、高性能的代码生成库，被广泛的运用于AOP框架提供方法拦截，在实现内部，CGLIB库使用了ASM这轻量性能高的字节码操作框架来转化字节码，产生新类。spring的aop默认使用JDK动态代理，除非强制使用CGLIB。但是有个主意点：&lt;code&gt;CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;实现的基本步骤如下：&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;编写目标对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编写MethodInterceptor，当代理对象调用方法时候，会调用该类的intercept方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;编写Cglib动态代理类&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;cglib实例演示&quot;&gt;3.2.4 Cglib实例演示&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;目标对象&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Hello {
    public String sayHello(String msg){
        return &quot;hello&quot; + msg;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;拦截器：类似于jdk代理的InvocationHandler&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyMethodInterceptor implements MethodInterceptor {

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println(&quot; --- 记录日志开始--- &quot;);
        return methodProxy.invokeSuper(o, objects);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class client {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        // 设置父类，cglib代理将会产生hello的子类
        enhancer.setSuperclass(Hello.class);
        // 设置回调方法，将会执行MyMethodInterceptor的interapt()方法
        enhancer.setCallback(new MyMethodInterceptor());
        // 创建代理对象
        Hello proxy = (Hello) enhancer.create();
        System.out.println(proxy.sayHello(&quot;codecarver&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果打印&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;--- 记录日志开始---&lt;br/&gt;hello：codecarver&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述代码通过CGLIB的的Enhancer来生成代理对象，&lt;code&gt;通过将目标对象设置为父类，以及设置回调方法，生成继承自父类的代理类，所以我们的目标对象绝对不能是final类型&lt;/code&gt;,我们可以在&lt;code&gt;intercept&lt;/code&gt;方法中加入我们要增强的逻辑，通过methodProxy.invokeSuper(o, objects)来将调用转发给目标对象（原始对象）。可以再看看jdk的动态代理，其实很类似，只不过&lt;code&gt;一个是目标对象必须实现接口，一个是目标对象必须可以被继承&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;四总结&quot;&gt;四：总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;代理可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;静态代理模式要求代理对象实现和目标对象一样的接口，且由程序员提前写好。会产生大量的代理类。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;动态代理可以动态生成代理类，不会产生大量的静态class文件。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;动态代理也是需要代理对象和目标对象实现一样的接口，但要求是目标对象必须实现接口。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;glib代理不要求目标对象实现接口，它是根据目标对象生成子类，让子类作为代理对象去工作的&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;号外号外：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果有小伙伴觉得我写的不错的话可以关注一下我的博客哦&lt;/li&gt;
&lt;li&gt;可以关注下方我的公众号&lt;strong&gt;&lt;code&gt;java架构师小密圈&lt;/code&gt;&lt;/strong&gt;,回复&lt;strong&gt;1&lt;/strong&gt;：&lt;strong&gt;获取2Tjava架构师必备干货&lt;/strong&gt; ，&lt;strong&gt;&lt;code&gt;另外：小伙伴可以回复任意想学的技术，可以免费帮你搜寻&lt;/code&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;code&gt;其实我们还需要学很多！！！！！！&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://piw7yv6sx.bkt.clouddn.com/toskye/%E7%99%BE%E5%BA%A6%E4%BA%91%E6%88%AA%E5%9B%BE.jpg&quot; alt=&quot;1545271756941&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;还会分享一些赚钱理财的小套路哦，欢迎大家来支持，一起学习成长，程序员不仅仅是搬瓦工！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;公众号：分享系列好文章&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://piw7yv6sx.bkt.clouddn.com/mine/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7.jpg&quot; alt=&quot;java架构师小密圈&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;交流群：一起奔着java架构师努力&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://piw7yv6sx.bkt.clouddn.com/mine/java%E6%9E%B6%E6%9E%84%E5%B8%88%E5%B0%8F%E5%AF%86%E5%9C%88%E7%BE%A4%E8%81%8A%E4%BA%8C%E7%BB%B4%E7%A0%81.png&quot; alt=&quot;java架构师小密圈&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 22 Dec 2018 06:10:00 +0000</pubDate>
<dc:creator>codecarver</dc:creator>
<og:description>代理模式 一：代理模式概述 高中的时候遇到一个喜欢的女生，那时候我们都比较害羞，我们的交流全靠传话，有一个姑娘成了我们的中介，每天都给我们传递狗粮，就这样我们开心的过完了高中。然后大学。。。。好了继续</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/1314xf/p/10160932.html</dc:identifier>
</item>
</channel>
</rss>