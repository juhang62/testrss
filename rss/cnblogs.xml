<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C#反射与特性(六)：设计一个仿ASP.NETCore依赖注入Web - 痴者工良</title>
<link>http://www.cnblogs.com/whuanle/p/12181308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whuanle/p/12181308.html</guid>
<description>&lt;p&gt;【微信平台，此文仅授权《NCC 开源社区》订阅号发布】&lt;/p&gt;
&lt;p&gt;从前面第四篇开始，进入了实践练习；第五篇实现了实例化一个类型以及对成员方法等的调用。当然，还有一些操作尚将在后面的章节进行介绍。&lt;/p&gt;
&lt;p&gt;因为本系列属于实践练习，所以系列文章可能比较多，内容比较长。要学会一种技术，最好的方法是跟着例子代码写一次，运行调试。&lt;/p&gt;
&lt;p&gt;本篇文章属于阶段练习，将前面学习到的所有知识点进行总结，实现一个依赖注入功能，仿照 ASP.NET Core 访问 API，自动传递参数以及执行方法，最后返回结果。&lt;/p&gt;
&lt;p&gt;本章的代码已上传至 &lt;a href=&quot;https://gitee.com/whuanle/codes/pby1q6amnzosgkxw830c470&quot; class=&quot;uri&quot;&gt;https://gitee.com/whuanle/codes/pby1q6amnzosgkxw830c470&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1315495/202001/1315495-20200111220243549-1393308884.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;对用户效果&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户能够访问 Controller&lt;/li&gt;
&lt;li&gt;用户能够访问 Action&lt;/li&gt;
&lt;li&gt;访问 Action 时，传递参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;程序要求效果&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实例化类型&lt;/li&gt;
&lt;li&gt;识别类型构造函数类型&lt;/li&gt;
&lt;li&gt;根据构造函数类型动态实例化类型并且注入&lt;/li&gt;
&lt;li&gt;动态调用合适的重载方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1315495/202001/1315495-20200112084249631-485986994.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;编写依赖注入框架&quot;&gt;1，编写依赖注入框架&lt;/h2&gt;
&lt;p&gt;写完后的代码大概是这样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1315495/202001/1315495-20200112084342952-491718189.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;笔者直接在 Program 类里面写了，代码量为 200 行左右（包括详细注释、空白隔行）。&lt;/p&gt;
&lt;p&gt;开始编写代码前，请先引入以下命名空间：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Program 中，增加以下代码&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        private static Assembly assembly = Assembly.GetCallingAssembly();
        private static Type[] types;
        static Program()
        {
            types = assembly.GetTypes();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码的作用是，获取到当前程序的程序集，并且获取元数据信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是反射第一步&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;路由索引&quot;&gt;1.1 路由索引&lt;/h3&gt;
&lt;p&gt;ASP.NET Core 中的路由规则十分丰富，我们自定义各种 URL 规则。主要原理是程序在运行时，将 Controller 、Action 的 [route] 等特性收集起来，生成路由表。&lt;/p&gt;
&lt;p&gt;程序执行的基础是类型、方法，ASP.NET Core 中的 Controller 即是 Class，Action 即 Method。&lt;/p&gt;
&lt;p&gt;从前面的学习中，我们了解到，通过反射实例化和调用一个类型的成员，只需要确定类型名称、方法名称即可。&lt;/p&gt;
&lt;p&gt;对于路由表，我们可以假设(不是指ASP.NET Core的原理)用户访问 URL 时，先从路由表中对比，如果有结果，则将对应的 Class 、Method 拿到手，通过反射机制调用实例化类型调用函数。&lt;/p&gt;
&lt;p&gt;这里不实现这么复杂的结构，只实现 Controller-Action 层次的路由。&lt;/p&gt;
&lt;h4 id=&quot;判断控制器-controller-是否存在&quot;&gt;1.1.1 判断控制器 Controller 是否存在&lt;/h4&gt;
&lt;p&gt;Program 中，添加一个方法，用于判断当前程序集中是否存在此控制器。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 判断是否有此控制器，并且返回 Type
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;controllerName&quot;&amp;gt;控制器名称(不带Controller)&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private static (bool, Type) IsHasController(string controllerName)
        {
            // 不分大小写

            string name = controllerName + &quot;Controller&quot;;
            if (!types.Any(x =&amp;gt; x.Name.ToLower() == name.ToLower()))
                return (false, null);

            return (true, types.FirstOrDefault(x =&amp;gt; x.Name.ToLower() == name.ToLower()));
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码非常简单，而且有 Linq 的加持，几行代码就 OK。&lt;/p&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;p&gt;判断程序集中是否具有 &lt;code&gt;{var}Controller&lt;/code&gt; 命名的类型，例如 &lt;code&gt;HomeController&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果存在，则获取此控制器的 Type 。&lt;/p&gt;
&lt;h4 id=&quot;判断-action-是否存在&quot;&gt;1.1.2 判断 Action 是否存在&lt;/h4&gt;
&lt;p&gt;Action 是在 Controller 里面的(方法在类型里面)，所以我们这里只需要判断以下就行。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 判断一个控制器中是否具有此方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;控制器类型&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;actionName&quot;&amp;gt;Action名称&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private static bool IsHasAction(Type type, string actionName)
        {
            // 不分大小写

            return type.GetMethods().Any(x =&amp;gt; x.Name.ToLower() == actionName.ToLower());
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;p&gt;判断一个类型中，是否存在 &lt;code&gt;{actionname}&lt;/code&gt; 这个方法。&lt;/p&gt;
&lt;p&gt;这里不返回 &lt;code&gt;MethodInfo&lt;/code&gt;，而是返回 &lt;code&gt;bool&lt;/code&gt; ，是因为考虑到，方法是可以重载的，我们要根据请求时的参数，确定使用哪个方法。&lt;/p&gt;
&lt;p&gt;所以这里只做判断，获取 &lt;code&gt;MethodInfo&lt;/code&gt; 的过程在后面。&lt;/p&gt;
&lt;h3 id=&quot;依赖实例化&quot;&gt;1.2 依赖实例化&lt;/h3&gt;
&lt;p&gt;意思是，获取一个类型的构造函数中，所有参数信息，并且为每一个类型实现自动创建实例。&lt;/p&gt;
&lt;p&gt;传入参数：&lt;/p&gt;
&lt;p&gt;需要进行依赖注入的类型的 Type。&lt;/p&gt;
&lt;p&gt;返回数据：&lt;/p&gt;
&lt;p&gt;构造函数参数的实例对象列表(反射都是object)。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 实例化依赖
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;要被实例化依赖注入的类型&amp;lt;/param&amp;gt;
        public static object[] CreateType(Type type)
        {
            // 这里只使用一个构造函数
            ConstructorInfo construct = type.GetConstructors().FirstOrDefault();

            // 获取类型的构造函数参数
            ParameterInfo[] paramList = construct.GetParameters();

            // 依赖注入的对象列表
            List&amp;lt;object&amp;gt; objectList = new List&amp;lt;object&amp;gt;();

            // 为构造函数的每个参数类型，实例化一个类型
            foreach (ParameterInfo item in paramList)
            {
                //获取参数类型：item.ParameterType.Name

                // 获取程序中，哪个类型实现了 item 的接口

                Type who = types.FirstOrDefault(x =&amp;gt; x.GetInterfaces().Any(z =&amp;gt; z.Name == item.ParameterType.Name));

                // 实例化
                object create = Activator.CreateInstance(who, new object[] { });
                objectList.Add(create);
            }
            return objectList.ToArray();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有两个点：&lt;/p&gt;
&lt;p&gt;① 对于一个类型来说，可能有多个构造函数；&lt;/p&gt;
&lt;p&gt;② 使用 ASP.NET Core 编写一个控制器时，估计没谁会写两个构造函数吧。。。&lt;/p&gt;
&lt;p&gt;基于以上两点，我们只要一个构造函数就行，不需要考虑很多情况，我们默认：一个控制器只允许定义一个构造函数，不能定义多个构造函数。&lt;/p&gt;
&lt;p&gt;过程实现原理：&lt;/p&gt;
&lt;p&gt;获取到构造函数后，接着获取构造函数中的参数列表(&lt;code&gt;ParameterInfo[]&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;这里又有几个问题&lt;/p&gt;
&lt;p&gt;那么，按照以上划分，要考虑的情况更加多了。这里我们根据依赖倒置原则，我们约定，构造函数中的类型，只允许是接口。&lt;/p&gt;
&lt;p&gt;因为这里没有 IOC 容器，只是简单的反射实现，所以我们不需要考虑那么多情况（200行代码还想怎么样。。。）。&lt;/p&gt;
&lt;p&gt;后面我们查找有哪个类型实现了此接口，就把这个类型实例化做参数传递进去。&lt;/p&gt;
&lt;p&gt;注：后面会持续推出更多实战型教程，敬请期待；可以关注微信订阅号 《NCC 开源社区》，获取最新资讯。&lt;/p&gt;
&lt;h3 id=&quot;实例化类型依赖注入调用方法&quot;&gt;1.3 实例化类型、依赖注入、调用方法&lt;/h3&gt;
&lt;p&gt;目前来到了依赖注入的最后阶段，实例化一个类型、注入依赖、调用方法。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 实现依赖注入、调用方法
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;类型&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;actionName&quot;&amp;gt;方法名称&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;paramList&quot;&amp;gt;调用方法的参数列表&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private static object StartASPNETCORE(Type type, string actionName, params object[] paramList)
        {
            // 获取 Action 重载方法 
            // 名字一样，参数个数一致
            MethodInfo method = type.GetMethods()
                .FirstOrDefault(x =&amp;gt; x.Name.ToLower() == actionName.ToLower()
                &amp;amp;&amp;amp; x.GetParameters().Length == paramList.Length);

            // 参数有问题，找不到合适的 Action 重载进行调用
            // 报 405 
            if (method == null)
                return &quot;405&quot;;

            // 实例化控制器

            // 获取依赖对象
            object[] inject = CreateType(type);
            // 注入依赖，实例化对象
            object example = Activator.CreateInstance(type, inject);

            // 执行方法并且返回执行结果
            object result;
            try
            {
                result = method.Invoke(example, paramList);
                return result;
            }
            catch
            {
                // 报 500
                result = &quot;500&quot;;
                return result;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现原理：&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;CreateType&lt;/code&gt; 方法，已经拿到实例化类型的构造函数的参数对象了。&lt;/p&gt;
&lt;p&gt;这里确定调用哪个重载方法的方式，是通过&lt;strong&gt;参数的多少&lt;/strong&gt;，因为这里控制台输入只能获取 &lt;code&gt;string&lt;/code&gt;，更加复杂通过参数类型获取重载方法，可以自行另外测试。&lt;/p&gt;
&lt;p&gt;调用一个方法大概以下几个步骤（不分顺序）：&lt;/p&gt;
&lt;p&gt;获取类型实例；&lt;/p&gt;
&lt;p&gt;获取类型 Type；&lt;/p&gt;
&lt;p&gt;获取方法 MethodInfo；&lt;/p&gt;
&lt;p&gt;方法的参数对象；&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            // 获取依赖对象
            object[] inject = CreateType(type);
            // 注入依赖，实例化对象
            object example = Activator.CreateInstance(type, inject);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，就是实现非常简单的依赖注入过程。&lt;/p&gt;
&lt;p&gt;剩下的就是调用方法，通过参数多少去调用相应的重载方法了。&lt;/p&gt;
&lt;h2 id=&quot;编写控制器和参数类型&quot;&gt;2，编写控制器和参数类型&lt;/h2&gt;
&lt;h3 id=&quot;编写类型&quot;&gt;2.1 编写类型&lt;/h3&gt;
&lt;p&gt;编写一个接口&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 接口
    /// &amp;lt;/summary&amp;gt;
    public interface ITest
    {
        string Add(string a, string b);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现接口&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 实现
    /// &amp;lt;/summary&amp;gt;
    public class Test : ITest
    {
        public string Add(string a, string b)
        {
            Console.WriteLine(&quot;Add方法被执行&quot;);
            return a + b;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现控制器&quot;&gt;2.2 实现控制器&lt;/h3&gt;
&lt;p&gt;我们按照 ASP.NET Core 写一个控制器的大概形式，实现一个低仿的山寨控制器。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 需要自动实例化并且进行依赖注入的类
    /// &amp;lt;/summary&amp;gt;
    public class MyClassController
    {
        private ITest _test;
        public MyClassController(ITest test)
        {
            _test = test;
        }
        
        /// &amp;lt;summary&amp;gt;
        /// 这是一个 Action
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public string Action(string a, string b)
        {
            // 校验http请求的参数
            if (string.IsNullOrEmpty(a) || string.IsNullOrEmpty(b))
                return &quot;验证不通过&quot;;
            //开始运行
            var result = _test.Add(a, b);
            Console.WriteLine(&quot;NCC社区&quot;, &quot;牛逼&quot;);
            // 响应结果
            return result;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是常见的依赖注入使用场景：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        private ITest _test;
        public MyClassController(ITest test)
        {
            _test = test;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以是一个数据库上下文，可以各种类型。&lt;/p&gt;
&lt;p&gt;由于控制台输入获取到的是 &lt;code&gt;string&lt;/code&gt;，为了减少麻烦，里面只使用的 &lt;code&gt;Action&lt;/code&gt; 方法，参数类型都是 &lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;实现低配山寨-asp.net-core&quot;&gt;3，实现低配山寨 ASP.NET Core&lt;/h2&gt;
&lt;p&gt;好吧，我承认我这跟ASP.NET Core没关系，这个这是一个非常简单的功能。&lt;/p&gt;
&lt;p&gt;主要就是仿照 StartUp ，实现请求流程和数据返回。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        static void Main(string[] args)
        {

            while (true)
            {
                string read = string.Empty;
                Console.WriteLine(&quot;用户你好，你要访问的控制器(不需要带Controller)&quot;);

                read = Console.ReadLine();

                // 检查是否具有此控制器并且获取 Type

                var hasController = IsHasController(read);

                // 找不到控制器，报 404 ，让用户重新请求
                if (!hasController.Item1)
                {
                    Console.WriteLine(&quot;404&quot;);
                    continue;
                }

                Console.WriteLine(&quot;控制器存在，请接着输入要访问的 Action&quot;);

                read = Console.ReadLine();

                // 检查是否具有此 Action 并且获取 Type
                bool hasAction = IsHasAction(hasController.Item2, read);

                // 找不到，继续报 404 
                if (hasAction == false)
                {
                    Console.WriteLine(&quot;404&quot;);
                    continue;
                }

                // 目前为止，URL存在，那么就是传递参数了

                Console.WriteLine(&quot;用户你好，URL 存在，请输入参数&quot;);
                Console.WriteLine(&quot;输入每个参数按一下回车键，结束输入请输入0再按下回车键&quot;);

                // 开始接收用户输入的参数
                List&amp;lt;object&amp;gt; paramList = new List&amp;lt;object&amp;gt;();
                while (true)
                {
                    string param = Console.ReadLine();
                    if (param == &quot;0&quot;)
                        break;
                    paramList.Add(param);
                }

                Console.WriteLine(&quot;输入结束，正在发送 http 请求 \n&quot;);

                // 用户的请求已经校验通过并且开始，现在来继续仿 ASP.NET Core 执行

                object response = StartASPNETCORE(hasController.Item2, read, paramList.ToArray());

                Console.WriteLine(&quot;执行结果是：&quot;);
                Console.WriteLine(response);


                Console.ReadKey();
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现过程和原理：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;判断 URL 是否存在（路由）&lt;/li&gt;
&lt;li&gt;接收用户输入的参数&lt;/li&gt;
&lt;li&gt;依赖注入实现&lt;/li&gt;
&lt;li&gt;调用方法，传输参数，返回实现结果&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 12 Jan 2020 00:39:00 +0000</pubDate>
<dc:creator>痴者工良</dc:creator>
<og:description>【微信平台，此文仅授权《NCC 开源社区》订阅号发布】 从前面第四篇开始，进入了实践练习；第五篇实现了实例化一个类型以及对成员方法等的调用。当然，还有一些操作尚将在后面的章节进行介绍。 因为本系列属于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whuanle/p/12181308.html</dc:identifier>
</item>
<item>
<title>【一起学源码-微服务】Feign 源码三：Feign结合Ribbon实现负载均衡的原理分析 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12181895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12181895.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;h4 id=&quot;前情回顾&quot;&gt;前情回顾&lt;/h4&gt;
&lt;p&gt;上一讲我们已经知道了Feign的工作原理其实是在项目启动的时候，通过JDK动态代理为每个FeignClinent生成一个动态代理。&lt;/p&gt;
&lt;p&gt;动态代理的数据结构是：ReflectiveFeign.FeignInvocationHandler。其中包含&lt;code&gt;target&lt;/code&gt;(里面是serviceName等信息)和&lt;code&gt;dispatcher&lt;/code&gt;(map数据结构，key是请求的方法名，方法参数等，value是&lt;code&gt;SynchronousMethodHandler&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200112083259578-1927295338.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;本讲目录&quot;&gt;本讲目录&lt;/h4&gt;
&lt;p&gt;这一讲主要是Feign与Ribbon结合实现负载均衡的原理分析。&lt;/p&gt;
&lt;h4 id=&quot;说明&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;原创不易，如若转载 请标明来源！&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;一枝花算不算浪漫&lt;/a&gt;&lt;br/&gt;微信公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;h4 id=&quot;feign结合ribbon实现负载均衡原理&quot;&gt;Feign结合Ribbon实现负载均衡原理&lt;/h4&gt;
&lt;p&gt;通过前面的分析，我们可以直接来看下&lt;code&gt;SynchronousMethodHandler&lt;/code&gt;中的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final class SynchronousMethodHandler implements MethodHandler {

    @Override
    public Object invoke(Object[] argv) throws Throwable {
        // 生成请求类似于：GET /sayHello/wangmeng HTTP/1.1
        RequestTemplate template = buildTemplateFromArgs.create(argv);
        Retryer retryer = this.retryer.clone();
        while (true) {
            try {
                return executeAndDecode(template);
            } catch (RetryableException e) {
                retryer.continueOrPropagate(e);
                if (logLevel != Logger.Level.NONE) {
                    logger.logRetry(metadata.configKey(), logLevel);
                }
                continue;
            }
        }
    }

    Object executeAndDecode(RequestTemplate template) throws Throwable {
        // 构建request对象：GET http://serviceA/sayHello/wangmeng HTTP/1.1
        Request request = targetRequest(template);

        if (logLevel != Logger.Level.NONE) {
            logger.logRequest(metadata.configKey(), logLevel, request);
        }

        Response response;
        long start = System.nanoTime();
        try {
            // 这个client就是之前构建的LoadBalancerFeignClient，options是超时时间
            response = client.execute(request, options);
            // ensure the request is set. TODO: remove in Feign 10
            response.toBuilder().request(request).build();
        } catch (IOException e) {
            if (logLevel != Logger.Level.NONE) {
                logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime(start));
            }
            throw errorExecuting(request, e);
        }
        long elapsedTime = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);

        // 下面逻辑都是构建返回值response
        boolean shouldClose = true;
        try {
            if (logLevel != Logger.Level.NONE) {
                response =
                        logger.logAndRebufferResponse(metadata.configKey(), logLevel, response, elapsedTime);
                // ensure the request is set. TODO: remove in Feign 10
                response.toBuilder().request(request).build();
            }
            if (Response.class == metadata.returnType()) {
                if (response.body() == null) {
                    return response;
                }
                if (response.body().length() == null ||
                        response.body().length() &amp;gt; MAX_RESPONSE_BUFFER_SIZE) {
                    shouldClose = false;
                    return response;
                }
                // Ensure the response body is disconnected
                byte[] bodyData = Util.toByteArray(response.body().asInputStream());
                return response.toBuilder().body(bodyData).build();
            }
            if (response.status() &amp;gt;= 200 &amp;amp;&amp;amp; response.status() &amp;lt; 300) {
                if (void.class == metadata.returnType()) {
                    return null;
                } else {
                    return decode(response);
                }
            } else if (decode404 &amp;amp;&amp;amp; response.status() == 404 &amp;amp;&amp;amp; void.class != metadata.returnType()) {
                return decode(response);
            } else {
                throw errorDecoder.decode(metadata.configKey(), response);
            }
        } catch (IOException e) {
            if (logLevel != Logger.Level.NONE) {
                logger.logIOException(metadata.configKey(), logLevel, e, elapsedTime);
            }
            throw errorReading(request, response, e);
        } finally {
            if (shouldClose) {
                ensureClosed(response.body());
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要是构建request数据，然后通过request和options去通过&lt;code&gt;LoadBalancerFeignClient.execute()&lt;/code&gt;方法去获得返回值。我们可以接着看client端的调用：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoadBalancerFeignClient implements Client {

    @Override
    public Response execute(Request request, Request.Options options) throws IOException {
        try {
            // asUri: http://serviceA/sayHello/wangmeng
            URI asUri = URI.create(request.url());

            // clientName:serviceA
            String clientName = asUri.getHost();

            // uriWithoutHost: http://sayHello/wangmeng
            URI uriWithoutHost = cleanUrl(request.url(), clientName);

            // 这里ribbonRequest：GET http:///sayHello/wangmeng HTTP/1.1  
            FeignLoadBalancer.RibbonRequest ribbonRequest = new FeignLoadBalancer.RibbonRequest(
                    this.delegate, request, uriWithoutHost);

            // 这里面config只有两个超时时间，一个是connectTimeout：5000，一个是readTimeout：5000
            IClientConfig requestConfig = getClientConfig(options, clientName);

            // 真正执行负载均衡的地方
            return lbClient(clientName).executeWithLoadBalancer(ribbonRequest,
                    requestConfig).toResponse();
        }
        catch (ClientException e) {
            IOException io = findIOException(e);
            if (io != null) {
                throw io;
            }
            throw new RuntimeException(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们看下&lt;code&gt;lbClient()&lt;/code&gt;和&lt;code&gt;executeWithLoadBalancer()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoadBalancerFeignClient implements Client {

    private FeignLoadBalancer lbClient(String clientName) {
        return this.lbClientFactory.create(clientName);
    }
}

public class CachingSpringLoadBalancerFactory {
    public FeignLoadBalancer create(String clientName) {
        if (this.cache.containsKey(clientName)) {
            return this.cache.get(clientName);
        }
        IClientConfig config = this.factory.getClientConfig(clientName);
        // 获取Ribbon ILoadBalancer信息
        ILoadBalancer lb = this.factory.getLoadBalancer(clientName);
        ServerIntrospector serverIntrospector = this.factory.getInstance(clientName, ServerIntrospector.class);
        FeignLoadBalancer client = enableRetry ? new RetryableFeignLoadBalancer(lb, config, serverIntrospector,
            loadBalancedRetryPolicyFactory, loadBalancedBackOffPolicyFactory, loadBalancedRetryListenerFactory) : new FeignLoadBalancer(lb, config, serverIntrospector);
        this.cache.put(clientName, client);
        return client;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是获取了&lt;code&gt;ILoadBalancer&lt;/code&gt;数据，里面包含了Ribbon获取的serviceA所有服务节点信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200112083303104-2075322481.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里已经获取到&lt;code&gt;ILoadBalancer&lt;/code&gt;，里面包含serviceA服务器所有节点请求host信息。接下来就是从中负载均衡选择一个节点信息host出来。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class AbstractLoadBalancerAwareClient&amp;lt;S extends ClientRequest, T extends IResponse&amp;gt; extends LoadBalancerContext implements IClient&amp;lt;S, T&amp;gt;, IClientConfigAware {

    public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException {
        LoadBalancerCommand&amp;lt;T&amp;gt; command = buildLoadBalancerCommand(request, requestConfig);

        try {
            return command.submit(
                new ServerOperation&amp;lt;T&amp;gt;() {
                    @Override
                    public Observable&amp;lt;T&amp;gt; call(Server server) {
                        URI finalUri = reconstructURIWithServer(server, request.getUri());
                        S requestForServer = (S) request.replaceUri(finalUri);
                        try {
                            return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig));
                        } 
                        catch (Exception e) {
                            return Observable.error(e);
                        }
                    }
                })
                .toBlocking()
                .single();
        } catch (Exception e) {
            Throwable t = e.getCause();
            if (t instanceof ClientException) {
                throw (ClientException) t;
            } else {
                throw new ClientException(e);
            }
        }
        
    }
}

public class LoadBalancerCommand&amp;lt;T&amp;gt; {
    
    public Observable&amp;lt;T&amp;gt; submit(final ServerOperation&amp;lt;T&amp;gt; operation) {
        final ExecutionInfoContext context = new ExecutionInfoContext();
        
        if (listenerInvoker != null) {
            try {
                listenerInvoker.onExecutionStart();
            } catch (AbortExecutionException e) {
                return Observable.error(e);
            }
        }

        final int maxRetrysSame = retryHandler.getMaxRetriesOnSameServer();
        final int maxRetrysNext = retryHandler.getMaxRetriesOnNextServer();

        // Use the load balancer
        Observable&amp;lt;T&amp;gt; o = 
                (server == null ? selectServer() : Observable.just(server))
                .concatMap(new Func1&amp;lt;Server, Observable&amp;lt;T&amp;gt;&amp;gt;() {
                }

        // 省略代码...

    // selectServer是真正执行负载均衡的逻辑
    private Observable&amp;lt;Server&amp;gt; selectServer() {
        return Observable.create(new OnSubscribe&amp;lt;Server&amp;gt;() {
            @Override
            public void call(Subscriber&amp;lt;? super Server&amp;gt; next) {
                try {
                    // loadBalancerURI是http:///sayHello/wangmeng， loadBalancerKey为null
                    Server server = loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   
                    next.onNext(server);
                    next.onCompleted();
                } catch (Exception e) {
                    next.onError(e);
                }
            }
        });
    }
}

public class LoadBalancerContext implements IClientConfigAware {

    public Server getServerFromLoadBalancer(@Nullable URI original, @Nullable Object loadBalancerKey) throws ClientException {
        String host = null;
        int port = -1;
        if (original != null) {
            host = original.getHost();
        }
        if (original != null) {
            Pair&amp;lt;String, Integer&amp;gt; schemeAndPort = deriveSchemeAndPortFromPartialUri(original);        
            port = schemeAndPort.second();
        }

        // 获取到ILoadBalancer，这里面有IRule的信息及服务节点所有信息
        ILoadBalancer lb = getLoadBalancer();
        if (host == null) {
            // Partial URI or no URI Case
            // well we have to just get the right instances from lb - or we fall back
            if (lb != null){
                // 这里就执行真正的chooseServer的逻辑了。默认的rule为ZoneAvoidanceZule
                Server svc = lb.chooseServer(loadBalancerKey);
                if (svc == null){
                    throw new ClientException(ClientException.ErrorType.GENERAL,
                            &quot;Load balancer does not have available server for client: &quot;
                                    + clientName);
                }
                host = svc.getHost();
                if (host == null){
                    throw new ClientException(ClientException.ErrorType.GENERAL,
                            &quot;Invalid Server for :&quot; + svc);
                }
                logger.debug(&quot;{} using LB returned Server: {} for request {}&quot;, new Object[]{clientName, svc, original});
                return svc;
            }

            // 省略代码
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码已经很清晰了，这里就是真正的通过ribbon的 &lt;code&gt;rule.chooseServer()&lt;/code&gt;负载均衡地选择了一个服务节点调用，debug如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200112083304636-736012805.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到了这里feign与ribbon的分析也就结束了，返回请求url信息，然后得到response结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200112083306444-1849024119.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;上面已经分析了Feign与Ribbon的整合，最终还是落到Ribbon中的ILoadBalancer中，使用最后使用IRule去选择对应的server数据。&lt;/p&gt;
&lt;p&gt;下一讲 会画一个很大的图，包含Feign、Ribbon、Eureka关联的图，里面会画出每个组件的细节及依赖关系。也算是学习至今的一个总复习了。&lt;/p&gt;
&lt;h3 id=&quot;申明&quot;&gt;申明&lt;/h3&gt;
&lt;p&gt;本文章首发自本人博客：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;https://www.cnblogs.com/wang-meng&lt;/a&gt; 和公众号：&lt;strong&gt;壹枝花算不算浪漫&lt;/strong&gt;，如若转载请标明来源!&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴可关注个人公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200112083306756-643644418.jpg&quot; alt=&quot;22.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 12 Jan 2020 00:33:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 前情回顾 上一讲我们已经知道了Feign的工作原理其实是在项目启动的时候，通过JDK动态代理为每个FeignClinent生成一个动态代理。 动态代理的数据结构是：ReflectiveFeign</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12181895.html</dc:identifier>
</item>
<item>
<title>iOS滤镜系列-滤镜开发概览 - KenshinCui</title>
<link>http://www.cnblogs.com/kenshincui/p/12181735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenshincui/p/12181735.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/dL3t6E9yzojCVDK.png&quot; alt=&quot;filter-logo&quot;/&gt;&lt;/p&gt;

&lt;p&gt;滤镜最早的出现应该是应用在相机镜头前实现自然光过滤和调色的镜片，然而在软件开发中更多的指的是软件滤镜，是对镜头滤镜的模拟实现。当然这种方式更加方便快捷，缺点自然就是无法还原拍摄时的真实场景，例如无法实现偏光镜和紫外线滤色镜的效果。今天简单介绍一下iOS滤镜开发中的正确姿势，让刚刚接触滤镜开发的朋友少走弯路。&lt;/p&gt;
&lt;p&gt;在iOS开发中常见的滤镜开发方式大概包括：CIFilter、GPUImage、OpenCV等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/GlKkFTxMXZvrS6D.png&quot; alt=&quot;core_image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cifilter&quot;&gt;CIFilter&lt;/h2&gt;
&lt;p&gt;CIFilter存在于CoreImage框架中，它基于OpenGL着色器来处理图像（最新的已经基于Metal实现），优点当然是快，因为它可以充分利用GPU加速来处理图像渲染，同时它自身支持滤镜链，多个滤镜同时使用时迅速高效。&lt;/p&gt;
&lt;p&gt;CIFilter目前已经支持21个分类（如下代码）&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346&quot;&gt;196种滤镜&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;public let kCICategoryDistortionEffect: String
public let kCICategoryGeometryAdjustment: String
public let kCICategoryCompositeOperation: String
public let kCICategoryHalftoneEffect: String
public let kCICategoryColorAdjustment: String
public let kCICategoryColorEffect: String
public let kCICategoryTransition: String
public let kCICategoryTileEffect: String
public let kCICategoryGenerator: String
@available(iOS 5.0, *)
public let kCICategoryReduction: String
public let kCICategoryGradient: String
public let kCICategoryStylize: String
public let kCICategorySharpen: String
public let kCICategoryBlur: String
public let kCICategoryVideo: String
public let kCICategoryStillImage: String
public let kCICategoryInterlaced: String
public let kCICategoryNonSquarePixels: String
public let kCICategoryHighDynamicRange: String
public let kCICategoryBuiltIn: String
@available(iOS 9.0, *)
public let kCICategoryFilterGenerator: String&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;open class func filterNames(inCategory category: String?) -&amp;gt; [String]&lt;/code&gt;可以查看每个分类的滤镜名称。而每个滤镜的属性设置通过CIFilter的&lt;strong&gt;attributes&lt;/strong&gt;就可以查看。而应用一个CIFilter滤镜也仅仅需要：创建滤镜-&amp;gt;设置属性（KVC）-&amp;gt;读取输入图片（下面演示了高斯模糊滤镜的简单实现）：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;guard let cgImage = UIImage(named:&quot;CIFilter_Demo_Origin&quot;)?.cgImage else { return }
        let ciImage = CIImage(cgImage: cgImage)
        let filter = CIFilter(name: &quot;CIGaussianBlur&quot;)
        filter?.setValue(ciImage, forKey: kCIInputImageKey)
        filter?.setValue(5.0, forKey: &quot;inputRadius&quot;)
        
        if let outputImage = filter?.value(forKeyPath: kCIOutputImageKey) as? CIImage {
            let context = CIContext()
            if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {
                let image = UIImage(cgImage: cgImage)
                UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/u4ZBwv5aVJ3GhtL.jpg&quot; alt=&quot;CIFilter_Demo_Origin&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用高斯模糊&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/745dQEVcakSnjN1.jpg&quot; alt=&quot;CIFilter_Demo_Gauss&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;36&quot;&gt;
&lt;p&gt;滤镜链&lt;br/&gt;所谓滤镜链就是将一个滤镜A的输出作为另一个滤镜B的输入形成有向图，使用这种方式Core Image并非一步步执行结果应用到B滤镜，而是将多个滤镜的着色器合并操作，从而提高性能。&lt;br/&gt;例如在上面的高斯模糊滤镜基础上应用像素化滤镜:&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;guard let cgImage = UIImage(named:&quot;CIFilter_Demo_Origin&quot;)?.cgImage else { return }
        let ciImage = CIImage(cgImage: cgImage)
        let blurFilter = CIFilter(name: &quot;CIGaussianBlur&quot;)
        blurFilter?.setValue(ciImage, forKey: kCIInputImageKey)
        blurFilter?.setValue(5.0, forKey: &quot;inputRadius&quot;)
        
        let pixelFilter = CIFilter(name: &quot;CIPixellate&quot;, parameters: [kCIInputImageKey:blurFilter!.outputImage!])
        pixelFilter?.setDefaults()
        
        if let outputImage = pixelFilter?.outputImage {
            let context = CIContext()
            if let cgImage = context.createCGImage(outputImage, from: outputImage.extent) {
                let image = UIImage(cgImage: cgImage)
                UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外新的API（iOS 11）如果使用滤镜建议使用更加直观的表达以简化书写：&lt;code&gt;let outputImage = ciImage.applyingFilter(&quot;CIGaussianBlur&quot;, parameters: [kCIInputRadiusKey:5.0]).applyingFilter(&quot;CIPixellate&quot;)&lt;/code&gt;&lt;br/&gt;此外说到CoreImage的高斯模糊时直接使用是有一个问题的，那就是radius越大越会产生一个明显的空白边缘，当然这个问题是因为滤镜的卷积操作通常从中心点开始应用造成的，这样就会致使边缘上的像素值不能得到有效应用，类似于OpenCV会自己处理这个问题，但是Core Image并没有处理这个边缘问题，通常的处理方法就是放大图片，然后剪切到原来的图片大小即可(其实就是在滤镜前后分别调用clampedToExtend()获取一个边缘扩展的图像，应用滤镜之后调用croped()获取一个裁剪边缘的图像即可)。&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;guard let cgImage = UIImage(named:&quot;CIFilter_Demo_Origin&quot;)?.cgImage else { return }
        let ciImage = CIImage(cgImage: cgImage)
        let outputImage = ciImage.clampedToExtent().applyingFilter(&quot;CIGaussianBlur&quot;, parameters: [kCIInputRadiusKey:5.0]).cropped(to: ciImage.extent)
        let context = CIContext()
        if let cgImage = context.createCGImage(outputImage, from: ciImage.extent) {
            let image = UIImage(cgImage: cgImage)
            UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
        }&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;自定义算子&quot;&gt;自定义算子&lt;/h2&gt;
&lt;p&gt;尽管Core Image提供了不少滤镜可以使用，不过实际开发中还并不能够满足需求，比如说描绘边缘这个操作在Core Image中应该就没有提供直接的滤镜。而有不少滤镜是通过卷积操作完成的，只要提供一个算子就可以形成一个新的滤镜效果，事实上Core Image框架也提供了这个滤镜：&lt;strong&gt;CIConvolution3X3&lt;/strong&gt;和&lt;strong&gt;CIConvolution5X5&lt;/strong&gt;。这两个滤镜支持开发者自定义算子实现一个滤镜操作，下面是使用CIConvolution3X3实现的sobel算子提取边缘的滤镜：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;guard let cgImage = UIImage(named:&quot;CIFilter_Demo_Origin&quot;)?.cgImage else { return }
        let ciImage = CIImage(cgImage: cgImage)
        let sobel:[CGFloat] = [-1,0,1,-2,0,2,-1,0,1]
        let weight = CIVector(values: sobel, count: 9)
        let outputImage = ciImage.applyingFilter(&quot;CIConvolution3X3&quot;, parameters: [kCIInputWeightsKey:weight,kCIInputBiasKey:0.5])
        
        let context = CIContext()
        if let cgImage = context.createCGImage(outputImage, from: ciImage.extent) {
            let image = UIImage(cgImage: cgImage)
            UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面的图应用Sobel算子后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/qEY1uWoVrCB7TNe.jpg&quot; alt=&quot;CIFilter_Demo_Sobel&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出来边缘已经被提取出来，其实无论是CIConvolution3X3还是CIConvolution5X5都只是进行一个卷积操作，本质就是对应的像素分别乘以对应算子上的值最后相加等于产生一个新的值作为当前像素的值（这个值通常是待处理图像区块中心）如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/Arf4CVdZLS6z7jW.jpg&quot; alt=&quot;sobel_demo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了上面的Sobel算子，常见的算子还有锐化算子{0,-1,0,-1,5,-1,0,-1,0}、浮雕算子{1,0,0,0,0,0,0,0,-1}、拉普拉斯算子（边缘检测）{0,1,0,1,-4,1,0,1,0}等等。&lt;/p&gt;
&lt;h2 id=&quot;自定义滤镜&quot;&gt;自定义滤镜&lt;/h2&gt;
&lt;p&gt;如果仅仅是自定义算子恐怕还不能体现出CIFilter的强大之处，毕竟不少滤镜通过特定算子还是无法满足的，CIFilter支持自定义片段着色器实现自己的滤镜效果。&lt;br/&gt;自定义的 Filter 和系统内置的各种 CIFilter，使用起来方式是一样的。我们唯一要做的，就是实现一个符合规范的 CIFilter 的子类。过程大家就是：编写 kernel-&amp;gt;加载 kernel-&amp;gt;设置参数。假设现在编写一个图片翻转的效果大概过程如下：&lt;/p&gt;
&lt;p&gt;1.编写kernel脚本,保存为Flip.kernel&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kernel vec2 mirrorX ( float imageWidth ) 
{
    vec2 currentVec = destCoord();
    return vec2 ( imageWidth - currentVec.x , currentVec.y ); 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.加载kernel&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;class FlipFilterGenerator:NSObject, CIFilterConstructor {
    func filter(withName name: String) -&amp;gt; CIFilter? {
        if name == &quot;\(FlipFilter.self)&quot; {
            return FlipFilter()
        }
        return nil
    }
}
private let flipKernel:CIWarpKernel? = CIWarpKernel(source:try! String(contentsOf:Bundle.main.url(forResource: &quot;Flip&quot;, withExtension: &quot;cikernel&quot;)!))
class FlipFilter: CIFilter {
    
    
    
    override init() {
        super.init()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    static func register() {
        CIFilter.registerName(&quot;\(FlipFilter.self)&quot;, constructor: FlipFilterGenerator(), classAttributes: [kCIAttributeFilterName:&quot;\(FlipFilter.self)&quot;])
    }
    
    override func setDefaults() {
        
    }
    
    @objc var inputImage: CIImage?
    
    override var outputImage: CIImage? {
        guard let width = self.inputImage?.extent.size.width else { return nil }
        let result = flipKernel?.apply(extent: inputImage!.extent, roiCallback: { (index, rect) -&amp;gt; CGRect in
            return rect
        }, image: self.inputImage!, arguments: [width])
        return result
    }
    
    override var name: String {
        get {
            return &quot;\(FlipFilter.self)&quot;
        }
        set {
            
        }
    }
    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用CIFilter的source构造函数传入着色器代码，然后通过apply()方法传入参数即可执行着色。当然使用之前记得进行注册，这样在使用的时候就可以像使用内置滤镜一样使用了。&lt;/p&gt;
&lt;p&gt;但是这里必须着重看一下apply()方法的几个参数&lt;br/&gt;extent:要处理的输入图片的区域(称之为DOD ( domain of definition ) )，一般处理的都是原图，并不会改变图像尺寸所以上面传的是inputImage.extent&lt;br/&gt;roiCallback:感兴趣的处理区域（ROI ( region of interest )，可以理解为当前处理区域对应的原图区域）处理完后的回调，回调参数index代表图片索引顺序，回调参数rect代表输出图片的区域DOD，但是需要注意在Core Image处理中这个回调会多次调用。这个值通常只要不发生旋转就是当前图片的坐标（如果旋转90°，则返回为CGRect(x: rect.origin.y, y: rect.origin.x, width: rect.size.height, height: rect.size.width)）&lt;br/&gt;arguments:着色器函数中需要的参数，按顺序传入。&lt;/p&gt;
&lt;p&gt;自定义滤镜调用：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;FlipFilter.register()
        guard let cgImage = UIImage(named:&quot;CIFilter_Demo_Origin&quot;)?.cgImage else { return }
        let ciImage = CIImage(cgImage: cgImage)
        let outputImage = ciImage.applyingFilter(&quot;FlipFilter&quot;)
        
        let context = CIContext()
        if let cgImage = context.createCGImage(outputImage, from: ciImage.extent) {
            let image = UIImage(cgImage: cgImage)
            UIImageWriteToSavedPhotosAlbum(image, nil, nil, nil)
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是上图使用翻转滤镜后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/Y9RW7AqKlP2ykO1.jpg&quot; alt=&quot;CIFilter_Demo_Flip&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实准确的来说实现一个自定义滤镜就是实现一个自定义的CIKernel类，当然这个类本身包括两个子类&lt;strong&gt;CIColorKernel&lt;/strong&gt;和&lt;strong&gt;CIWarpKernel&lt;/strong&gt;，前者用于图像颜色转化滤镜，而后者用于形变滤镜，如前面的翻转很明显不是一个颜色值的修改就能解决的，必须依赖于形变操作所以继承自CIWarpKernel要简单些。当然如果你的滤镜综合了二者的特点那么直接选择使用&lt;strong&gt;CIKernel&lt;/strong&gt;是正确的。至于着色器代码编写使用的是Core Image Kernel Language (CIKL)，它是OpenGL Shading Language (GLSL) 的子集。CIKL 集成了 GLSL 绝大部分的参数类型和内置函数，另外它还添加了一些适应 Core Image 的参数类似和函数。另外编写CIKL需要注意坐标系，它的坐标系从左下角开始而不是UIKit的左上角。&lt;/p&gt;
&lt;p&gt;由于篇幅原因关于编写CIKL的具体细节这里不再赘述，感兴趣可以参考&lt;a href=&quot;https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/ImageUnitTutorial/WritingKernels/WritingKernels.html&quot;&gt;Writing Kernels&lt;/a&gt;和&lt;a href=&quot;https://developer.apple.com/library/content/documentation/GraphicsImaging/Reference/CIKernelLangRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004397-CH1-SW1&quot;&gt;Core Image Kernel Language Reference&lt;/a&gt;，而编写CIKL的工具自然推荐官方的&lt;a href=&quot;https://developer.apple.com/download/more/&quot;&gt;Quartz Composer&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;从前面的演示也可以看到图片在UIImage、CGImage和CIImage之间不停的转化，那么三者之间有什么区别呢？&lt;br/&gt;UIImage存在于UIKit中，CGImage存在于Core Graphics中，CIImage存在于Core Image中。前者负责展示和管理图片数据，例如可以使用UIImageView展示、或者绘制到UIView、layer上等，主要在CPU上操作；CGImage表示图像的像素矩阵，每个点都对应了图片的像素信息，主要运行在GPU上；而CIImage包含了创建图片的必要数据，自身并不会渲染成图片，代表了图像的数据或者操作图像的流程（如滤镜），主要运行在GPU上。换句话说对于CIImage的操作并不会进行大量的图片运算，只有要输出图片时才需要转化成图片数据（推荐这一步尽量放到异步线程中操作）。&lt;br/&gt;注意：获取一个图片的CIImage类型时请使用CIImage()构造方法创建，请勿直接访问uiImage.ciImage，因为如果一个UIImage不是从CIImage创建是无法获取ciImage的（uiImage.cgImage类似,上面之所以可以直接使用UIImage.cgImage属性是因为它并非从ciImage创建）。反之，如果从ciImage创建UIImage就不推荐使用UIImage的构造方法了，因为这种方式会丢失信息，例如使用UIViewImage显示时会丢失contentMode设置，如果使用上面的代码保存会出现保存失败的情况，推荐的方式则是使用UIContext先生成CGImage，然后从CGImage创建UIImage（总结起来就是UIImage到CGImage明确的情况下可以直接访问cgImage属性，但是cgImage为空则访问ciImage属性再从ciImage创建cgImage，从CGImage转化为UIImage使用构造函数；UIImage到CIImage推荐使用构造函数，也可以使用CGImage从中间过渡，而从CIImage转化为UIImage只能通过CGImage过渡再用构造函数创建）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/xRAGFhHKaS6U5Jb.png&quot; alt=&quot;CIKL-MetalShader&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你编写过CIKL你会发现这种开发方式很古老，Quartz Composer尽管作为目前开发CIKL最合适的工具但在Xcode7之后几乎没有更新过，尽管有语法高亮但是没有错误调试，更不用说运行时出错的问题（尽管可以使用&lt;strong&gt;+(id)kernelsWithString:(id)arg1 messageLog:(id)arg2&lt;/strong&gt;这个私有方法打印kernel中的错误，但是调试依然很麻烦），自身以字符串传入CIKernel类的方式让它天然失去了语法检查。更重要的是这种方式最终要将CIKL片段变成CIKernel必须经过CIKL-&amp;gt;GLSL-&amp;gt;CIKernel-&amp;gt;IL-&amp;gt;GPU识别码-&amp;gt;Render到GPU，如果遇到滤镜链还必须在中间链接Kernel，而这些操作全部在运行时进行。所以首次使用会比较慢（后面使用会缓存），而2017年Metal支持CIKernel则将Kernel的编译提前到了App编译阶段，从而支持了语法检查，大大提高了开发效率和运行效率。&lt;/p&gt;
&lt;p&gt;例如前面的滤镜链中使用了一个马赛克风格的滤镜，这里不妨先看一下使用CIKL编写这个滤镜(注意这是一个CIWrapKernel，返回值是变化后的坐标位置)：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;kernel vec2 pixellateKernel(float radius)
{
    vec2 positionOfDestPixel, centerPoint;
    positionOfDestPixel = destCoord();
    centerPoint.x = positionOfDestPixel.x - mod(positionOfDestPixel.x, radius * 2.0) + radius;
    centerPoint.y = positionOfDestPixel.y - mod(positionOfDestPixel.y, radius * 2.0) + radius;

    return centerPoint;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个CIKL用Metal Shader书写如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;extern &quot;C&quot; {
    namespace coreimage {
        
        float2 pixellateMetal(float radius,destination dest) {
            float2 positionOfDestPixel, centerPoint;
            positionOfDestPixel = dest.coord();
            centerPoint.x = positionOfDestPixel.x - fmod(positionOfDestPixel.x, radius * 2.0) + radius;
            centerPoint.y = positionOfDestPixel.y - fmod(positionOfDestPixel.y, radius * 2.0) + radius;
            
            return centerPoint;
        }
        
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然对应的自定义CIFilter需要做少许调整：&lt;/p&gt;
&lt;pre class=&quot;swift&quot;&gt;
&lt;code&gt;class PixellateFilterGenerator:NSObject, CIFilterConstructor {
    func filter(withName name: String) -&amp;gt; CIFilter? {
        if name == &quot;\(PixellateFilter.self)&quot; {
            return PixellateFilter()
        }
        return nil
    }
}

private var pixellateKernel:CIWarpKernel? = {
    guard let url = Bundle.main.url(forResource: &quot;default&quot;, withExtension: &quot;metallib&quot;) else { return nil }
    guard let data = try? Data(contentsOf: url) else { return nil }
    let kernel = try? CIWarpKernel(functionName: &quot;pixellateMetal&quot;, fromMetalLibraryData: data)
    return kernel
}()
class PixellateFilter: CIFilter {
    
    override init() {
        super.init()
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    static func register() {
        CIFilter.registerName(&quot;\(PixellateFilter.self)&quot;, constructor: PixellateFilterGenerator(), classAttributes: [kCIAttributeFilterName:&quot;\(PixellateFilter.self)&quot;])
    }
    
    override func setDefaults() {
        
    }
    
    @objc var inputImage: CIImage?
    
    @objc var radius:CGFloat = 5.0
    
    override var outputImage: CIImage? {
        let result = pixellateKernel?.apply(extent: inputImage!.extent, roiCallback: { (index, rect) -&amp;gt; CGRect in
            return rect
        }, image: self.inputImage!, arguments: [radius])
        return result
    }
    
    override var name: String {
        get {
            return &quot;\(PixellateFilter.self)&quot;
        }
        set {
            
        }
    }
    
    override var attributes: [String : Any] {
        get {
            return [
                &quot;radius&quot;:[
                    kCIAttributeMin:1,
                    kCIAttributeDefault:5.0,
                    kCIAttributeType:kCIAttributeTypeScalar
                ]
            ]
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果说只是像前面一样简单的使用这个滤镜恐怕还无法体现Metal Shader的高性能，不妨把上面应用自定义滤镜后直接保存相册的操作改成一个滑动条在UIImageView直接预览：&lt;/p&gt;
&lt;pre class=&quot;swfit&quot;&gt;
&lt;code&gt;class ViewController: UIViewController {

    var filter:CIFilter?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        self.view.addSubview(self.imageView)
        self.view.addSubview(sliderBar)
        
        PixellateFilter.register()
        filter = CIFilter(name: &quot;PixellateFilter&quot;)

        guard let cgImage = UIImage(named: &quot;CIFilter_Demo_Origin&quot;)?.cgImage else { return }
        let ciImage = CIImage(cgImage: cgImage)
        filter?.setValue(ciImage, forKey: kCIInputImageKey)
    }
    
    @objc func sliderValueChange(_ sender:UISlider) {
        filter?.setValue(sender.value, forKey: &quot;radius&quot;)
        if let outputImage = filter?.outputImage {
            self.imageView.image = UIImage(ciImage: outputImage)
        }
    }
    
    private lazy var imageView:UIImageView = {
        let temp = UIImageView(frame: CGRect(x: 0.0, y: 0.0, width: Constants.screenSize.width, height: Constants.screenSize.height-60))
        temp.contentMode = .scaleAspectFill
        temp.image = UIImage(named: &quot;CIFilter_Demo_Origin&quot;)
        return temp
    }()
    
    private lazy var sliderBar:UISlider = {
        let temp = UISlider(frame: CGRect(x: 0.0, y: Constants.screenSize.height-50, width: Constants.screenSize.width, height: 30))
        temp.minimumValue = 1
        temp.maximumValue = 20
        temp.addTarget(self, action: #selector(sliderValueChange(_:)), for: UIControl.Event.valueChanged)
        return temp
    }()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/yk1elBNduIazH4A.gif&quot; alt=&quot;Metal-Shader-Demo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，拖动滑动条可以实时预览滤镜效果而没有丝毫卡顿，前面也提到CIImage本身并不包含图像数据，当UIImageView显示时会在GPU上执行Core Image操作，释放了CPU的压力（这也是UIImageView针对Core Image优化的结果）。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;无论是通过CIKL还是通过Metal自定义CIFilter都不是万能的，这是由于kernel本身的限制所造成的。kernel的原理简单理解就是遍历一个图片的所有像素点，然后通过kernel处理后返回新的像素点作为新的图片的像素点。而类似于绘制直方图、动漫风格等操作依赖于整个图片的分布或者依赖于机器学习的操作则很难使用kernel完成，当然这可以借助于后面的OpenCV轻松做到。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GPUImage可以说是iOS滤镜开发中多数app的首选，原因在于它不仅高效（从名字就可以看出它运行在GPU上），而且简单（下面三行代码就实现了上面的高斯模糊效果），当然还有它强大的工具属性。它不仅支持实时滤镜预览，还支持视频实时滤镜等。&lt;/p&gt;
&lt;p&gt;下面是使用高斯模糊的演示：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;GPUImageGaussianBlurFilter * blurFilter = [[GPUImageGaussianBlurFilter alloc] init];
 blurFilter.blurRadiusInPixels = 2.0;
 UIImage * image = [UIImage imageNamed:@&quot;CIFilter_Demo_Origin&quot;];
 UIImage *blurredImage = [blurFilter imageByFilteringImage:image];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;滤镜后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/aQ18n5r4VclKMq2.jpg&quot; alt=&quot;GPUImage_GaussianBlur_Demo&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不过可以对比之前的效果，发现GPUImage对于高斯模糊的处理包括了边缘的处理，并不需要针对边缘进行重新裁剪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然如果不支持自定义那么GPUImage也谈不上强大，GPUImage 自定义滤镜需要使用 OpenGL 着色语言( GLSL )编写 Fragment Shader（片段着色器），这些其实和自定义Core Image是类似的。&lt;/p&gt;
&lt;p&gt;下面演示了使用GPUImage自定义实现一个图片暗角滤镜：&lt;/p&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;#import &amp;lt;GPUImage/GPUImage.h&amp;gt;

@interface VignetteFilter : GPUImageFilter
    
    @property (nonatomic,assign) CGPoint center;
    @property (nonatomic,assign) CGFloat radius;
    @property (nonatomic,assign) CGFloat alpha;
    
@end&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;objc&quot;&gt;
&lt;code&gt;@implementation VignetteFilter {
    GLint centerXUniform,centerYUniform,alphaUniform,radiusUniform;
}

    - (instancetype)init
    {
        self = [super initWithFragmentShaderFromFile:@&quot;VignetteFilter&quot;];
        if (!self) {
            return nil;
        }
        
        centerXUniform = [filterProgram uniformIndex:@&quot;centerX&quot;];
        centerYUniform = [filterProgram uniformIndex:@&quot;centerY&quot;];
        alphaUniform = [filterProgram uniformIndex:@&quot;alpha&quot;];
        radiusUniform = [filterProgram uniformIndex:@&quot;radius&quot;];
        
        self.alpha = 0.5;
        self.radius = 100;
        return self;
    }

    - (void)setCenter:(CGPoint)center {
        [self setFloat:center.x forUniform:centerXUniform program:filterProgram];
        [self setFloat:center.y forUniform:centerYUniform program:filterProgram];
    }
    
    - (void)setAlpha:(CGFloat)alpha {
        [self setFloat:alpha forUniform:alphaUniform program:filterProgram];
    }
    
    - (void)setRadius:(CGFloat)radius {
        [self setFloat:radius forUniform:radiusUniform program:filterProgram];
    }

@end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;片段着色器代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;uniform highp float alpha;
uniform lowp float radius;
uniform lowp float centerX;
uniform lowp float centerY;
varying highp vec2 textureCoordinate;
uniform sampler2D inputImageTexture;
void main()
{
    highp vec2 centerPoint = vec2(centerX, centerY);
    lowp vec4 textureColor = texture2D(inputImageTexture, textureCoordinate);
    highp float distance = distance(gl_FragCoord.xy, centerPoint);
    highp float darken = 1.0 - (distance / (radius*0.5) * alpha);
    gl_FragColor = vec4(textureColor.rgb*darken,textureColor.a);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;滤镜后的图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/kTRUOv5yxjYoPXW.gif&quot; alt=&quot;GPUImage_Vignette_Demo&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和Core Image不同的是GPUImage使用的并非CIKL而是GLSL(二者均是类C语言)来编写滤镜，优点自然是了解片段着色器就可以无过渡编写滤镜着色代码，无需转化，同时它也是跨平台的。缺点就是iOS 12之后Core Image使用Metal引擎逐渐摒弃了OpenGL，效率则更高（当然GPUImage3已经支持Metal Shader，这样二者就逐渐没有了区别）。&lt;/p&gt;

&lt;p&gt;既然前面提到了OpenGL，那么就离不开另外一个库OpenCV，前者主要用于显示，后者用于运算处理，当然OpenCV默认编译是不支持的GPU加速的，不过胜在它的算法强大，算法速度很快，而且令人兴奋的是3.0以后使用CUDA是可以支持使用GPU运算的。&lt;/p&gt;
&lt;p&gt;使用OpenCV实现滤镜更像是使用vImage（存在于Accelerate.framework），不仅可以像上面一样直接基于像素进行处理，还能使用它提供的很多强大算法，同时考虑到自定义算子OpenCV甚至直接暴漏了Filter2D让我们可以直接像编写上面的着色器那样方便的进行卷积操作。&lt;/p&gt;
&lt;p&gt;下面使用OpenCV实现一个羽化操作：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;math.h&amp;gt;
#include &amp;lt;opencv/cv.h&amp;gt;
#include &amp;lt;opencv/highgui.h&amp;gt;
#define MAXSIZE (32768)
using namespace cv;
using namespace std;



float mSize = 0.5;

int main()
{
    Mat src = imread(&quot;/Users/Kenshin/Downloads/CIFilter_Demo_Origin.jpg&quot;,1);
    imshow(&quot;src&quot;,src);
    int width=src.cols;
    int heigh=src.rows;
    int centerX=width&amp;gt;&amp;gt;1;
    int centerY=heigh&amp;gt;&amp;gt;1;
    
    int maxV=centerX*centerX+centerY*centerY;
    int minV=(int)(maxV*(1-mSize));
    int diff= maxV -minV;
    float ratio = width &amp;gt;heigh ? (float)heigh/(float)width : (float)width/(float)heigh;
    
    Mat img;
    src.copyTo(img);
    
    Scalar avg=mean(src);
    Mat dst(img.size(),CV_8UC3);
    Mat mask1u[3];
    float tmp,r;
    for (int y=0;y&amp;lt;heigh;y++)
    {
        uchar* imgP=img.ptr&amp;lt;uchar&amp;gt;(y);
        uchar* dstP=dst.ptr&amp;lt;uchar&amp;gt;(y);
        for (int x=0;x&amp;lt;width;x++)
        {
            int b=imgP[3*x];
            int g=imgP[3*x+1];
            int r=imgP[3*x+2];
            
            float dx=centerX-x;
            float dy=centerY-y;
            
            if(width &amp;gt; heigh)
                dx= (dx*ratio);
            else
                dy = (dy*ratio);
            
            int dstSq = dx*dx + dy*dy;
            
            float v = ((float) dstSq / diff)*255;
            
            r = (int)(r +v);
            g = (int)(g +v);
            b = (int)(b +v);
            r = (r&amp;gt;255 ? 255 : (r&amp;lt;0? 0 : r));
            g = (g&amp;gt;255 ? 255 : (g&amp;lt;0? 0 : g));
            b = (b&amp;gt;255 ? 255 : (b&amp;lt;0? 0 : b));
            
            dstP[3*x] = (uchar)b;
            dstP[3*x+1] = (uchar)g;
            dstP[3*x+2] = (uchar)r;
        }
    }
    imshow(&quot;blur&quot;,dst);
    
    waitKey();
    imwrite(&quot;/Users/Kenshin/Downloads/blur.jpg&quot;,dst);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，这是一段c++代码，但在OC中可以很方便的使用，只要实现一个Wrapper类，将.m改为.mm就可以直接调用c++代码。&lt;/p&gt;
&lt;p&gt;下面是羽化后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/01/12/jHAEridWOB165vF.jpg&quot; alt=&quot;CIFilter_Demo_EdgeBlur&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从上面可以看到其实开发滤镜选择很多，普通的滤镜使用GPUImage这种基于OpenGL的滤镜效率比较高、可移植性强，缺点当然就是GLSL调试比较难，遇到错误需要反复试验。如果你的App仅仅考虑iOS 11以上的运行环境，自然首推Metal Shading Language，调试方便又高效，尽管GPUImage3已经支持了Metal Shader但是当前还不完善，很多GPUImage有的功能还在待开发阶段当前不建议使用。而OpenCV自然是一把倚天剑，强大的算法，天然的可移植性，但是由于过于强大，不是类似于人脸识别这种复杂的非着色滤镜不推荐使用，当然换句话说一旦遇到机器学习相关（例如CARTOONGAN），高级特效一般非OpenCV莫属。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Jan 2020 18:35:00 +0000</pubDate>
<dc:creator>KenshinCui</dc:creator>
<og:description>概述 滤镜最早的出现应该是应用在相机镜头前实现自然光过滤和调色的镜片，然而在软件开发中更多的指的是软件滤镜，是对镜头滤镜的模拟实现。当然这种方式更加方便快捷，缺点自然就是无法还原拍摄时的真实场景，例如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kenshincui/p/12181735.html</dc:identifier>
</item>
<item>
<title>手动滑稽之golang-vmware-driver广告篇 - A.Z</title>
<link>http://www.cnblogs.com/A-Z/p/build_docker_vmware_driver.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/A-Z/p/build_docker_vmware_driver.html</guid>
<description>&lt;p&gt;本来在&lt;a id=&quot;post_title_link_12174190&quot; href=&quot;https://www.cnblogs.com/A-Z/p/docker2dockerfile.html&quot;&gt;Windows 7 + Tiny Linux 4.19 + XFS + Vmware Workstation 15 (PRO) 下篇dockerの奥义&lt;/a&gt;之后的UEFI补完延迟了...&lt;/p&gt;
&lt;p&gt;虽然用efiboot的做的光盘可以双引导，但是总有些不开心，顺着man 1 xorrisofs的思路，把syslinux放在光盘里INstall了好多次&lt;/p&gt;
&lt;p&gt;基本思路围绕以下文件&lt;/p&gt;
&lt;p&gt;SYSLINUX.EFI/efi64/syslinux.efi&lt;br/&gt;syslinux/modules/efi64/ldlinux.e64&lt;/p&gt;
&lt;p&gt;syslinux/modules/efi64/menu.c32&lt;br/&gt;syslinux/modules/efi64/libutil.c32&lt;/p&gt;
&lt;p&gt;mkfs.msdos + mmd + mcopy&lt;/p&gt;
&lt;p&gt;制作很顺利，但是在开机的时候一闪而过，自己关机...看样子syslinux和xorrisofs在EFI问题上八字不合，从man里就可以一见端倪，syslinux共提及5处，Now for EFI话题一转祭起了祖传的GRUB2，挂着xorriso卖grub-mkrescue，有那么一点点小觉悟，没有仙人指点，ueFI光盘是遥遥无期了&lt;/p&gt;
&lt;p&gt;于是，我又有了一个idea...&lt;/p&gt;
&lt;p&gt;于是，我又pull一个image...&lt;/p&gt;
&lt;p&gt;到底是什么呢???&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你猜?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你猜?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你猜?&lt;/span&gt;&lt;/p&gt;






&lt;hr/&gt;&lt;p&gt;熟悉标题的小朋友一定欢声雀跃 golang:latest for VMware driver登场&lt;/p&gt;
&lt;p&gt;size=803M,又又又是漫长的等待&lt;/p&gt;
&lt;p&gt;打开后，生食，味美？&lt;/p&gt;
&lt;p&gt;呕&lt;sub&gt;233&lt;/sub&gt;&lt;/p&gt;
&lt;p&gt;基本盘如下图所示，这是&lt;span&gt;&lt;strong&gt;第一个&lt;/strong&gt;&lt;/span&gt;手动滑稽的golang项目，大家鼓掌&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/A-Z/117549/o_vmware_driver_golang.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/p&gt;

&lt;p&gt;vendor文件夹内文件不是submodule???作者有内味了，找不到引用，GOPATH总是要用src附加在路径上，是不是没有放在/go/src下，就变成了离经叛道?请go熟练工进来说两句&lt;/p&gt;
&lt;p&gt;Gopkg.lock明示这个项目很旧，dep???不存在的，顺着?网站的思路，govendor list也有问题&lt;/p&gt;
&lt;p&gt;于是我一个offline build诉求变成了拉锯战&lt;/p&gt;
&lt;p&gt;果断全面替换，好在整个项目异常简单，也在意料之中，把main.driver.go两处import改成GOPATH search path就这样简简单单不好吗？vendor.json?不存在的&lt;/p&gt;
&lt;p&gt;于是我的offline build在强力植入下，成功了，无图无假象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/A-Z/117549/o_vmware_driver_exe.PNG&quot; alt=&quot;&quot; width=&quot;360&quot; height=&quot;245&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一次build成功，感觉...就那样了，运行???肯定是没有问题，大小比公开下载的release大了一点点，毕竟还是有一些commit/ref在后面的更新的&lt;/p&gt;
&lt;p&gt;然后还记得在&lt;a id=&quot;post_title_link_12174190&quot; href=&quot;https://www.cnblogs.com/A-Z/p/docker2dockerfile.html&quot;&gt;Windows 7 + Tiny Linux 4.19 + XFS + Vmware Workstation 15 (PRO) 下篇dockerの奥义&lt;/a&gt;提到的知识点1？&lt;/p&gt;
&lt;p&gt;改成和另一个大众driver一样可配置吧，另外改一下virtualHW.version到只兼容Workstation 15，配合我的新光盘，组合在一起&lt;/p&gt;
&lt;p&gt;是不是全世界都找不到的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/A-Z/117549/o_boot2eva.PNG&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;
&lt;p&gt;滑稽！&lt;/p&gt;
&lt;p&gt;OVer&lt;/p&gt;
&lt;p&gt;奥里给！！！&lt;/p&gt;

</description>
<pubDate>Sat, 11 Jan 2020 16:40:00 +0000</pubDate>
<dc:creator>A.Z</dc:creator>
<og:description>本来在Windows 7 + Tiny Linux 4.19 + XFS + Vmware Workstation 15 (PRO) 下篇dockerの奥义之后的UEFI补完延迟了... 虽然用efi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/A-Z/p/build_docker_vmware_driver.html</dc:identifier>
</item>
<item>
<title>pdf文件内容查看器 --  采用wpf开发 - 源之缘</title>
<link>http://www.cnblogs.com/yuanchenhui/p/WpfPdfExplorer.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanchenhui/p/WpfPdfExplorer.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt; pdf是一种应用非常广的版式文档格式，已成为事实上的国际标准。关于pdf格式的文章汗牛充栋，本文也是关于pdf格式的文章，但是本文不是纸上谈兵；本人这几周一直研究pdf格式内容，不但对pfd格式的内容有所了解，同时也写了一款软件，可以方便查看pdf文件内容。使用该软件，同时结合pdf相关文章，可以很快掌握pdf格式内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;软件截图：&lt;/strong&gt; &lt;span&gt;&lt;a href=&quot;https://files.cnblogs.com/files/yuanchenhui/pdf%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B%E5%99%A8.zip&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;软件下载地址 点我下载&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111220930169-2058507931.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pdf文件内容简要介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里对pdf文件格式做个粗略介绍，只有了解了这些内容，才能知道如何使用该软件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pdf文档总结构如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111221307248-1130843333.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）header：主要包含版本信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111221429370-1262032611.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）tailer：pdf树结构的入口点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111221631577-937886615.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3）交叉索引表；该表包含pdf每个obj在文件中的位置，根据该表，可以快速定位和加载obj的内容。对于大文件，不必一次加载所有的内容，只需加载当前页包含的obj即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111222117568-206085437.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4） body。 包含obj对应的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pdf obj树状结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要完成对pdf文件的分析和显示，首先需要构建pdf文件的obj的树状模型。这个树状模型的入口点就是trailer，trailer包含root元素（Catalog），其下包含Pages，Page。Page中包含内容和资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111222334638-1685913822.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结合软件分析pdf文件格式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用该软件打开一个pdf文件，对照示例来分析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）pdf header： &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111223131141-1406318863.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）trailer和交叉引用表，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111223350711-1572583347.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;3）body&lt;/strong&gt;&lt;/strong&gt; 由一系列obj组成。每个obj由唯一编号，可根据编号定位到内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111223803486-1840942728.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 4）文档树状结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;页集是页的集合，pdf规范建议用平衡树来组织页，便于快速查找。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111223912301-1897388281.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;编程心得&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1 不能严格按照pdf标准来分析pdf。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pdf文档应用非常广，生成pdf文件的软件非常多。不是所有的pdf文档都严格符合标准。所谓“林子大了，什么鸟都有“。所以开发软件要经过大量的pfd文档测试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2 分析obj的内容&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pdf索引表只给出了obj开始文件位置。obj一般包含dictionary和stream两部分。所以需要根据关键词来解析obj，这就需要有一定的技巧。dictionary开始和结束的关键字为“&amp;lt;&amp;lt;” 和&quot;&amp;gt;&amp;gt;&quot;，但是dictionary可能包含子dictionary。只靠关键字是无法确定dictionary的开始和结束位置的，需要一定的技巧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/245753/202001/245753-20200111225522934-79682640.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3 读取obj的效率。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不必一次加载所有的obj，可以采取按需加载。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;后记&lt;/strong&gt;&lt;/span&gt; 读取pdf文件的内容，在内存中构建obj树形结构，是下一步分析和显示pdf的基础。本人通过阅读相关资料，加上编写代码，实现了对pdf文件内容的分析。理论和实践相结合，就能快速的掌握相关知识。本软件可以方便的窥探pdf内部结构，希望该软件为你了解和开发pdf有所帮助。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 11 Jan 2020 15:16:00 +0000</pubDate>
<dc:creator>源之缘</dc:creator>
<og:description>前言 pdf是一种应用非常广的版式文档格式，已成为事实上的国际标准。关于pdf格式的文章汗牛充栋，本文也是关于pdf格式的文章，但是本文不是纸上谈兵；本人这几周一直研究pdf格式内容，不但对pfd格式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanchenhui/p/WpfPdfExplorer.html</dc:identifier>
</item>
<item>
<title>JVM垃圾回收 - 不懒人</title>
<link>http://www.cnblogs.com/wuwuyong/p/12181458.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuwuyong/p/12181458.html</guid>
<description>

&lt;h2&gt;写在前面&lt;/h2&gt;
&lt;h3&gt;本节常见面试题&lt;/h3&gt;
&lt;p&gt;问题答案在文中都有提到&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如何判断对象是否死亡（两种方法）。&lt;/li&gt;
&lt;li&gt;简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。&lt;/li&gt;
&lt;li&gt;如何判断一个常量是废弃常量&lt;/li&gt;
&lt;li&gt;如何判断一个类是无用的类&lt;/li&gt;
&lt;li&gt;垃圾收集有哪些算法，各自的特点？&lt;/li&gt;
&lt;li&gt;HotSpot 为什么要分为新生代和老年代？&lt;/li&gt;
&lt;li&gt;常见的垃圾回收器有哪些？&lt;/li&gt;
&lt;li&gt;介绍一下 CMS,G1 收集器。&lt;/li&gt;
&lt;li&gt;Minor Gc 和 Full GC 有什么不同呢？&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;本文导火索&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/29176325.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当需要排查各种内存溢出问题、当垃圾收集成为系统达到更高并发的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。&lt;/p&gt;
&lt;h2&gt;1 揭开 JVM 内存分配与回收的神秘面纱&lt;/h2&gt;
&lt;p&gt;Java 的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。&lt;/p&gt;
&lt;p&gt;Java 堆是垃圾收集器管理的主要区域，因此也被称作GC 堆（Garbage Collected Heap）.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。&lt;/p&gt;
&lt;p&gt;堆空间的基本结构：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424223/202001/1424223-20200111225401719-1716882477.png&quot; alt=&quot;&quot;/&gt;

&lt;/div&gt;
&lt;p&gt;上图所示的 eden 区、s0(&quot;From&quot;) 区、s1(&quot;To&quot;) 区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s1(&quot;To&quot;)，并且对象的年龄还会加 1(Eden 区-&amp;gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 &lt;code&gt;-XX:MaxTenuringThreshold&lt;/code&gt; 来设置。经过这次GC后，Eden区和&quot;From&quot;区已经被清空。这个时候，&quot;From&quot;和&quot;To&quot;会交换他们的角色，也就是新的&quot;To&quot;就是上次GC前的“From”，新的&quot;From&quot;就是上次GC前的&quot;To&quot;。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，&quot;To&quot;区被填满之后，会将所有对象移动到老年代中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1424223/202001/1424223-20200111225416354-2096139772.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;1.1 对象优先在 eden 区分配&lt;/h3&gt;
&lt;p&gt;目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。&lt;/p&gt;
&lt;p&gt;大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.下面我们来进行实际测试以下。&lt;/p&gt;
&lt;p&gt;在测试之前我们先来看看 Minor GC 和 Full GC 有什么不同呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新生代 GC（Minor GC）:指发生新生代的的垃圾收集动作，Minor GC 非常频繁，回收速度一般也比较快。&lt;/li&gt;
&lt;li&gt;老年代 GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC 经常会伴随至少一次的 Minor GC（并非绝对），Major GC 的速度一般会比 Minor GC 的慢 10 倍以上。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试：&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;GCTest &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;main&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;String&lt;span class=&quot;o&quot;&gt;[] &lt;span class=&quot;n&quot;&gt;args&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;kt&quot;&gt;byte&lt;span class=&quot;o&quot;&gt;[] &lt;span class=&quot;n&quot;&gt;allocation1&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;n&quot;&gt;allocation2&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;allocation1 &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;kt&quot;&gt;byte&lt;span class=&quot;o&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;30900&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;mi&quot;&gt;1024&lt;span class=&quot;o&quot;&gt;];
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;c1&quot;&gt;//allocation2 = new byte[900*1024];
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过以下方式运行： &lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/25178350.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加的参数：&lt;code&gt;-XX:+PrintGCDetails&lt;/code&gt; &lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/10317146.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行结果 (红色字体描述有误，应该是对应于 JDK1.7 的永久代)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28954286.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图我们可以看出 eden 区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用 2000 多 k 内存）。假如我们再为 allocation2 分配内存会出现什么情况呢？&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;n&quot;&gt;allocation2 &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;kt&quot;&gt;byte&lt;span class=&quot;o&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;900&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;mi&quot;&gt;1024&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-26/28128785.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单解释一下为什么会出现这种情况： 因为给 allocation2 分配内存的时候 eden 区内存几乎已经被分配完了，我们刚刚讲了当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.GC 期间虚拟机又发现 allocation1 无法存入 Survivor 空间，所以只好通过 分配担保机制 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放 allocation1，所以不会出现 Full GC。执行 Minor GC 后，后面分配的对象如果能够存在 eden 区的话，还是会在 eden 区分配内存。可以执行如下代码验证：&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;14&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;GCTest &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;main&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;String&lt;span class=&quot;o&quot;&gt;[] &lt;span class=&quot;n&quot;&gt;args&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;kt&quot;&gt;byte&lt;span class=&quot;o&quot;&gt;[] &lt;span class=&quot;n&quot;&gt;allocation1&lt;span class=&quot;o&quot;&gt;, &lt;span class=&quot;n&quot;&gt;allocation2&lt;span class=&quot;o&quot;&gt;,&lt;span class=&quot;n&quot;&gt;allocation3&lt;span class=&quot;o&quot;&gt;,&lt;span class=&quot;n&quot;&gt;allocation4&lt;span class=&quot;o&quot;&gt;,&lt;span class=&quot;n&quot;&gt;allocation5&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;allocation1 &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;kt&quot;&gt;byte&lt;span class=&quot;o&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;32000&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;mi&quot;&gt;1024&lt;span class=&quot;o&quot;&gt;];
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;allocation2 &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;kt&quot;&gt;byte&lt;span class=&quot;o&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;1000&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;mi&quot;&gt;1024&lt;span class=&quot;o&quot;&gt;];
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;allocation3 &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;kt&quot;&gt;byte&lt;span class=&quot;o&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;1000&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;mi&quot;&gt;1024&lt;span class=&quot;o&quot;&gt;];
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;allocation4 &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;kt&quot;&gt;byte&lt;span class=&quot;o&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;1000&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;mi&quot;&gt;1024&lt;span class=&quot;o&quot;&gt;];
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;allocation5 &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;kt&quot;&gt;byte&lt;span class=&quot;o&quot;&gt;[&lt;span class=&quot;mi&quot;&gt;1000&lt;span class=&quot;o&quot;&gt;*&lt;span class=&quot;mi&quot;&gt;1024&lt;span class=&quot;o&quot;&gt;];
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;   &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;}
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;1.2 大对象直接进入老年代&lt;/h3&gt;
&lt;p&gt;大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。&lt;/p&gt;
&lt;p&gt;为什么要这样呢？&lt;/p&gt;
&lt;p&gt;为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。&lt;/p&gt;
&lt;h3&gt;1.3 长期存活的对象将进入老年代&lt;/h3&gt;
&lt;p&gt;既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。&lt;/p&gt;
&lt;p&gt;如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 &lt;code&gt;-XX:MaxTenuringThreshold&lt;/code&gt; 来设置。&lt;/p&gt;
&lt;h3&gt;1.4 动态对象年龄判定&lt;/h3&gt;
&lt;p&gt;为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。&lt;/p&gt;
&lt;h2&gt;2 对象已经死亡？&lt;/h2&gt;
&lt;p&gt;堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/11034259.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.1 引用计数法&lt;/h3&gt;
&lt;p&gt;给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。&lt;/p&gt;
&lt;p&gt;这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;&lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;class &lt;span class=&quot;nc&quot;&gt;ReferenceCountingGc &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;nc&quot;&gt;Object &lt;span class=&quot;n&quot;&gt;instance &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;    &lt;span class=&quot;kd&quot;&gt;public &lt;span class=&quot;kd&quot;&gt;static &lt;span class=&quot;kt&quot;&gt;void &lt;span class=&quot;nf&quot;&gt;main&lt;span class=&quot;o&quot;&gt;(&lt;span class=&quot;nc&quot;&gt;String&lt;span class=&quot;o&quot;&gt;[] &lt;span class=&quot;n&quot;&gt;args&lt;span class=&quot;o&quot;&gt;) &lt;span class=&quot;o&quot;&gt;{
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;ReferenceCountingGc &lt;span class=&quot;n&quot;&gt;objA &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;ReferenceCountingGc&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;nc&quot;&gt;ReferenceCountingGc &lt;span class=&quot;n&quot;&gt;objB &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;k&quot;&gt;new &lt;span class=&quot;nc&quot;&gt;ReferenceCountingGc&lt;span class=&quot;o&quot;&gt;();
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;objA&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;instance &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;objB&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;objB&lt;span class=&quot;o&quot;&gt;.&lt;span class=&quot;na&quot;&gt;instance &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;n&quot;&gt;objA&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;objA &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC9&quot; class=&quot;line&quot;&gt;            &lt;span class=&quot;n&quot;&gt;objB &lt;span class=&quot;o&quot;&gt;= &lt;span class=&quot;kc&quot;&gt;null&lt;span class=&quot;o&quot;&gt;;
&lt;span id=&quot;LC10&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC11&quot; class=&quot;line&quot;&gt;   &lt;span class=&quot;o&quot;&gt;}
&lt;span id=&quot;LC12&quot; class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2.2 可达性分析算法&lt;/h3&gt;
&lt;p&gt;这个算法的基本思想就是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/72762049.jpg&quot; alt=&quot;可达性分析算法 &quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.3 再谈引用&lt;/h3&gt;
&lt;p&gt;无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。&lt;/p&gt;
&lt;p&gt;JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。&lt;/p&gt;
&lt;p&gt;JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）&lt;/p&gt;
&lt;p&gt;1．强引用（StrongReference）&lt;/p&gt;
&lt;p&gt;以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。&lt;/p&gt;
&lt;p&gt;2．软引用（SoftReference）&lt;/p&gt;
&lt;p&gt;如果一个对象只具有软引用，那就类似于可有可无的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。&lt;/p&gt;
&lt;p&gt;软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。&lt;/p&gt;
&lt;p&gt;3．弱引用（WeakReference）&lt;/p&gt;
&lt;p&gt;如果一个对象只具有弱引用，那就类似于可有可无的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。&lt;/p&gt;
&lt;p&gt;弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。&lt;/p&gt;
&lt;p&gt;4．虚引用（PhantomReference）&lt;/p&gt;
&lt;p&gt;&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。&lt;/p&gt;
&lt;p&gt;虚引用主要用来跟踪对象被垃圾回收的活动。&lt;/p&gt;
&lt;p&gt;虚引用与软引用和弱引用的一个区别在于： 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。&lt;/p&gt;
&lt;p&gt;特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。&lt;/p&gt;
&lt;h3&gt;2.4 不可达的对象并非“非死不可”&lt;/h3&gt;
&lt;p&gt;即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。&lt;/p&gt;
&lt;p&gt;被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。&lt;/p&gt;
&lt;h3&gt;2.5 如何判断一个常量是废弃常量&lt;/h3&gt;
&lt;p&gt;运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？&lt;/p&gt;
&lt;p&gt;假如在常量池中存在字符串 &quot;abc&quot;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 &quot;abc&quot; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，&quot;abc&quot; 就会被系统清理出常量池。&lt;/p&gt;
&lt;p&gt;注意：我们在 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;amp;mid=2247484303&amp;amp;idx=1&amp;amp;sn=af0fd436cef755463f59ee4dd0720cbd&amp;amp;chksm=fd9855eecaefdcf8d94ac581cfda4e16c8a730bda60c3b50bc55c124b92f23b6217f7f8e58d5&amp;amp;token=506869459&amp;amp;lang=zh_CN#rd&quot;&gt;可能是把 Java 内存区域讲的最清楚的一篇文章 &lt;/a&gt;也讲了 JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。&lt;/p&gt;
&lt;h3&gt;2.6 如何判断一个类是无用的类&lt;/h3&gt;
&lt;p&gt;方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？&lt;/p&gt;
&lt;p&gt;判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。&lt;/li&gt;
&lt;li&gt;加载该类的 ClassLoader 已经被回收。&lt;/li&gt;
&lt;li&gt;该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。&lt;/p&gt;
&lt;h2&gt;3 垃圾收集算法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95.jpg&quot; alt=&quot;垃圾收集算法分类&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.1 标记-清除算法&lt;/h3&gt;
&lt;p&gt;该算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;效率问题&lt;/li&gt;
&lt;li&gt;空间问题（标记清除后会产生大量不连续的碎片）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/63707281.jpg&quot; alt=&quot;公众号&quot; width=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2 复制算法&lt;/h3&gt;
&lt;p&gt;为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/90984624.jpg&quot; alt=&quot;公众号&quot; width=&quot;500px&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.3 标记-整理算法&lt;/h3&gt;
&lt;p&gt;根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/94057049.jpg&quot; alt=&quot;标记-整理算法 &quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.4 分代收集算法&lt;/h3&gt;
&lt;p&gt;当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。&lt;/p&gt;
&lt;p&gt;比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。&lt;/p&gt;
&lt;p&gt;延伸面试问题： HotSpot 为什么要分为新生代和老年代？&lt;/p&gt;
&lt;p&gt;根据上面的对分代收集算法的介绍回答。&lt;/p&gt;
&lt;h2&gt;4 垃圾收集器&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.jpg&quot; alt=&quot;垃圾收集器分类&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。&lt;/p&gt;
&lt;p&gt;虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的 HotSpot 虚拟机就不会实现那么多不同的垃圾收集器了。&lt;/p&gt;
&lt;h3&gt;4.1 Serial 收集器&lt;/h3&gt;
&lt;p&gt;Serial（串行）收集器收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ &quot;Stop The World&quot; ），直到它收集结束。&lt;/p&gt;
&lt;p&gt;新生代采用复制算法，老年代采用标记-整理算法。 &lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/46873026.jpg&quot; alt=&quot; Serial 收集器 &quot;/&gt;&lt;/p&gt;
&lt;p&gt;虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。&lt;/p&gt;
&lt;p&gt;但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的单线程相比）。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。&lt;/p&gt;
&lt;h3&gt;4.2 ParNew 收集器&lt;/h3&gt;
&lt;p&gt;ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。&lt;/p&gt;
&lt;p&gt;新生代采用复制算法，老年代采用标记-整理算法。 &lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/22018368.jpg&quot; alt=&quot;ParNew 收集器 &quot;/&gt;&lt;/p&gt;
&lt;p&gt;它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。&lt;/p&gt;
&lt;p&gt;并行和并发概念补充：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.3 Parallel Scavenge 收集器&lt;/h3&gt;
&lt;p&gt;Parallel Scavenge 收集器也是使用复制算法的多线程收集器，它看上去几乎和ParNew都一样。 那么它有什么特别之处呢？&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span id=&quot;LC1&quot; class=&quot;line&quot;&gt;-XX:+UseParallelGC 
&lt;span id=&quot;LC2&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;    使用 Parallel 收集器+ 老年代串行
&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;-XX:+UseParallelOldGC
&lt;span id=&quot;LC6&quot; class=&quot;line&quot;&gt;
&lt;span id=&quot;LC7&quot; class=&quot;line&quot;&gt;    使用 Parallel 收集器+ 老年代并行
&lt;span id=&quot;LC8&quot; class=&quot;line&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。 Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在困难的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。&lt;/p&gt;
&lt;p&gt;新生代采用复制算法，老年代采用标记-整理算法。 &lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/22018368.jpg&quot; alt=&quot;Parallel Scavenge 收集器 &quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.4.Serial Old 收集器&lt;/h3&gt;
&lt;p&gt;Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。&lt;/p&gt;
&lt;h3&gt;4.5 Parallel Old 收集器&lt;/h3&gt;
&lt;p&gt;Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。&lt;/p&gt;
&lt;h3&gt;4.6 CMS 收集器&lt;/h3&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。&lt;/p&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。&lt;/p&gt;
&lt;p&gt;从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；&lt;/li&gt;
&lt;li&gt;并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。&lt;/li&gt;
&lt;li&gt;重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短&lt;/li&gt;
&lt;li&gt;并发清除： 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-27/82825079.jpg&quot; alt=&quot;CMS 垃圾收集器 &quot;/&gt;&lt;/p&gt;
&lt;p&gt;从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对 CPU 资源敏感；&lt;/li&gt;
&lt;li&gt;无法处理浮动垃圾；&lt;/li&gt;
&lt;li&gt;它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4.7 G1 收集器&lt;/h3&gt;
&lt;p&gt;G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.&lt;/p&gt;
&lt;p&gt;被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;并行与并发：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。&lt;/li&gt;
&lt;li&gt;分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。&lt;/li&gt;
&lt;li&gt;空间整合：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。&lt;/li&gt;
&lt;li&gt;可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;G1 收集器的运作大致分为以下几个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始标记&lt;/li&gt;
&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;最终标记&lt;/li&gt;
&lt;li&gt;筛选回收&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。&lt;/p&gt;
&lt;h2&gt;参考&lt;/h2&gt;
</description>
<pubDate>Sat, 11 Jan 2020 14:55:00 +0000</pubDate>
<dc:creator>不懒人</dc:creator>
<og:description>JVM 垃圾回收 写在前面 本节常见面试题 问题答案在文中都有提到 如何判断对象是否死亡（两种方法）。 简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuwuyong/p/12181458.html</dc:identifier>
</item>
<item>
<title>CSS3(5)---伸缩布局(Flex) - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11953758.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11953758.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;有关页面布局之前写过三篇相关文章：&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11801815.html&quot;&gt;CSS(5)---盒子模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11806402.html&quot;&gt;CSS(6)---浮动(float)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11826981.html&quot;&gt;CSS(8)---定位(position)&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一什么是flex-布局&quot;&gt;&lt;span&gt;一、什么是Flex 布局&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;flex-布局特点&quot;&gt;1、Flex 布局特点&lt;/h4&gt;
&lt;p&gt;上面三种布局都是基于盒状模型。依赖 &lt;strong&gt;display属性&lt;/strong&gt; + &lt;strong&gt;position属性&lt;/strong&gt; + &lt;strong&gt;float属性&lt;/strong&gt;。它对于有些特殊布局并不友好，比如，垂直居中就不容易实现，会有溢出容器的问题。&lt;/p&gt;
&lt;p&gt;Flex是意思是”弹性布局”，它可以为盒状模型提供最大的灵活性。主要思想是让容器有能力让其子项目能够改变其 &lt;strong&gt;宽度&lt;/strong&gt;、&lt;strong&gt;高度&lt;/strong&gt;、&lt;strong&gt;顺序&lt;/strong&gt;，以&lt;code&gt;最佳的方式填充可用空间&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;简单来讲就是当你设置好父元素的宽度或者高度,对于它的子元素会根据父类的宽度或者高度来填充可用空间。&lt;/p&gt;
&lt;h4 id=&quot;flex-布局&quot;&gt;2、Flex 布局&lt;/h4&gt;
&lt;p&gt;任何一个容器都可以指定为 Flex 布局。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.box{
  display: flex;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;行内元素也可以使用 Flex 布局&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;.box{
  display: inline-flex;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;注意&lt;/code&gt; 设为 Flex 布局后，CSS的columns在伸缩容器上没有效果。&lt;strong&gt;子元素(伸缩项目)的 float、clear和vertical-align属性将失效&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;二重要概念&quot;&gt;&lt;span&gt;二、重要概念&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;容器和项目&quot;&gt;1、容器和项目&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;容器&lt;/code&gt; 采用Flex布局的元素，称为Flex容器，简称”容器”。(&lt;strong&gt;父元素&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;项目&lt;/code&gt; 容器下所有子元素自动成为容器成员，简称”项目”。（&lt;strong&gt;父元素下的子元素&lt;/strong&gt;）&lt;/p&gt;
&lt;h4 id=&quot;主轴和交叉轴&quot;&gt;2、主轴和交叉轴&lt;/h4&gt;
&lt;p&gt;(盗图 这幅图自己画太费时间了 ）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128205418254-1211131688.jpg&quot; width=&quot;700&quot; height=&quot;403&quot;/&gt;&lt;/p&gt;
&lt;p&gt;容器默认存在两根轴：&lt;code&gt;水平的叫主轴&lt;/code&gt; 和 &lt;code&gt;垂直的叫交叉轴&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;主轴的开始位置叫做 &lt;strong&gt;main start&lt;/strong&gt;，结束位置叫做 &lt;strong&gt;main end&lt;/strong&gt;；交叉轴的开始位置叫做 &lt;strong&gt;cross start&lt;/strong&gt;，结束位置叫做 &lt;strong&gt;cross end&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。&lt;/p&gt;

&lt;h2 id=&quot;三容器的属性&quot;&gt;&lt;span&gt;三、容器的属性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面解释了什么是容器，简单理解就是父元素上设置的属性&lt;/p&gt;
&lt;p&gt;有6个属性设置在容器上&lt;code&gt;flex-direction&lt;/code&gt;、&lt;code&gt;flex-wrap&lt;/code&gt; 、&lt;code&gt;flex-flow&lt;/code&gt; 、&lt;code&gt;justify-content&lt;/code&gt;、&lt;code&gt;align-items&lt;/code&gt; 、&lt;code&gt;align-content&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-direction伸缩流方向&quot;&gt;1、flex-direction(伸缩流方向)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;重点&lt;/code&gt; flex-direction 属性决定 &lt;strong&gt;主轴的方向&lt;/strong&gt;（即项目的排列方向）。&lt;/p&gt;
&lt;p&gt;它有4个属性值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-direction: row | row-reverse | column | column-reverse;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;效果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128205604649-1234644425.jpg&quot; width=&quot;600&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;row（默认值）:       主轴为水平方向，起点在左端。 
row-reverse:       主轴为水平方向，起点在右端。 
column:            主轴为垂直方向，起点在上沿。
column-reverse:    主轴为垂直方向，起点在下沿。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;flex-wrap换行&quot;&gt;2、flex-wrap(换行)&lt;/h4&gt;
&lt;p&gt;项目(子元素)在容器(父元素)中有时候也会溢出伸缩容器。与传统的CSS盒模型一样，CSS允许使用&lt;strong&gt;overflow:hidden&lt;/strong&gt; 属性来处理溢出内容的显示方式。在容器中有一个&lt;/p&gt;
&lt;p&gt;换行属性，主要用来设置容器中的项目是单行显示还是多行显示，以及决定侧轴的方向。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt; flex-wrap: nowrap | wrap | wrap-reverse;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128205648758-1372406814.jpg&quot; width=&quot;600&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- nowrap:          伸缩容器单行显示。（默认）  
- wrap:            换行，第一行在上方。 
- wrap-reverse:    换行，第一行在下方。 &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;flex-flow伸缩方向与换行&quot;&gt;3、flex-flow(伸缩方向与换行)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;  flex-flow: &amp;lt;flex-direction&amp;gt; || &amp;lt;flex-wrap&amp;gt;;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;justify-content主轴对齐&quot;&gt;4、justify-content(主轴对齐)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; justify-content属性定义了项目在主轴上的对齐方式。&lt;/p&gt;
&lt;p&gt;属性值&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;justify-content: flex-start | flex-end | center | space-between | space-around;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128205740401-678211910.jpg&quot; width=&quot;600&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  flex-start(默认值):    左对齐  
  flex-end:             右对齐 
  center:               居中  
  space-between:        两端对齐，项目之间的间隔都相等。 
  space-around:         每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;align-items侧轴对齐&quot;&gt;5、 align-items(侧轴对齐)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; align-items属性定义项目在交叉轴上如何对齐。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; align-items: flex-start | flex-end | center | baseline | stretch;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128205822468-1881778971.jpg&quot; width=&quot;600&quot; height=&quot;340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-start:         交叉轴的起点对齐。  
flex-end:           交叉轴的终点对齐。 
center:             交叉轴的中点对齐。   
baseline:           项目的第一行文字的基线对齐。 
stretch(默认值):     如果项目未设置高度或设为auto，将占满整个容器的高度。  &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;align-content多根轴线的对齐&quot;&gt;6、 align-content(多根轴线的对齐)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128210104290-1181645167.jpg&quot; width=&quot;600&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该属性可能取6个值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;flex-start:      与交叉轴的起点对齐。
flex-end:        与交叉轴的终点对齐。
center:          与交叉轴的中点对齐。
space-between:   与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around:    每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch(默认值):  轴线占满整个交叉轴。&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;四项目的属性&quot;&gt;&lt;span&gt;四、项目的属性&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面说明，项目就是父元素中的子元素。以下6个属性设置在项目上。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;order
flex-grow
flex-shrink
flex-basis
flex
align-self&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;order属性&quot;&gt;1、order属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; order: &amp;lt;integer&amp;gt;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128210218870-1364559042.jpg&quot; width=&quot;600&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;flex-grow属性&quot;&gt;2、flex-grow属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.item {
  flex-grow: &amp;lt;number&amp;gt;; /* default 0 */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128210327484-113678879.jpg&quot; width=&quot;600&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。&lt;/p&gt;
&lt;h4 id=&quot;flex-shrink属性&quot;&gt;3、flex-shrink属性&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt; flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.item {
  flex-shrink: &amp;lt;number&amp;gt;; /* default 1 */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128210425371-1783161999.jpg&quot; width=&quot;600&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。&lt;/p&gt;
&lt;p&gt;负值对该属性无效。&lt;/p&gt;
&lt;h4 id=&quot;flex-basis属性&quot;&gt;4、 flex-basis属性&lt;/h4&gt;
&lt;p&gt;flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.item {
  flex-basis: &amp;lt;length&amp;gt; | auto; /* default auto */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。&lt;/p&gt;
&lt;h4 id=&quot;flex属性&quot;&gt;5 flex属性&lt;/h4&gt;
&lt;p&gt;flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.item {
  flex: none | [ &amp;lt;'flex-grow'&amp;gt; &amp;lt;'flex-shrink'&amp;gt;? || &amp;lt;'flex-basis'&amp;gt; ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。&lt;/p&gt;
&lt;p&gt;建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。&lt;/p&gt;
&lt;h4 id=&quot;align-self属性&quot;&gt;6、align-self属性&lt;/h4&gt;
&lt;p&gt;align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128210528655-1960143748.jpg&quot; width=&quot;600&quot; height=&quot;260&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该属性可能取6个值，除了auto，其他都与align-items属性完全一致。&lt;/p&gt;

&lt;h2 id=&quot;五示例&quot;&gt;&lt;span&gt;五、示例&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;水平布局&quot;&gt;1、水平布局&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;效果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128210610634-666302035.jpg&quot; width=&quot;600&quot; height=&quot;160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;水平布局&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;

    section {
        width: 50%;
        height: 150px;
        /*background-color: pink;*/
        margin: 100px auto;
        border: 2px solid red; 

        /*父亲添加 伸缩布局*/
        display: flex;    
    }
    section div {   
        height: 100%;
        flex: 1;   /* 孩子的份数*/

    }
    section div:nth-child(1) {
        background-color: pink;
        flex:  2;
    }
    section div:nth-child(2) {
        background-color: purple;
        margin: 0 10px;
    }
    section div:nth-child(3) {
        background-color: yellow;
        flex: 3;
    }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;section&amp;gt;
        &amp;lt;div&amp;gt;1&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;2&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;3&amp;lt;/div&amp;gt;
    &amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;垂直分布&quot;&gt;2、垂直分布&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;效果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128210700354-124438654.jpg&quot; width=&quot;600&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;水平布局&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;

    section {
        width: 50%;
        height: 150px;
        /*background-color: pink;*/
        margin: 100px auto;
        border: 2px solid red; 

        /*父亲添加 伸缩布局*/
        display: flex;    
    }
    section div {   
        height: 100%;
        flex: 1;   /* 孩子的份数*/

    }
    section div:nth-child(1) {
        background-color: pink;
        flex:  2;
    }
    section div:nth-child(2) {
        background-color: purple;
        margin: 0 10px;
    }
    section div:nth-child(3) {
        background-color: yellow;
        flex: 3;
    }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;section&amp;gt;
        &amp;lt;div&amp;gt;1&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;2&amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;3&amp;lt;/div&amp;gt;
    &amp;lt;/section&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;携程网案例&quot;&gt;3、携程网案例&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;效果&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201911/1090617-20191128210743262-163545784.jpg&quot; width=&quot;600&quot; height=&quot;570&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;代码&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    html, body {
        min-width: 320px; 
        max-width: 540px;
        margin: 100px auto;
        font: normal 14px/1.5 Tahoma,&quot;Lucida Grande&quot;,Verdana,&quot;Microsoft Yahei&quot;,STXihei,hei;
    }
    header {
        height: 108px;
    }
    header img {
        height: 100%;
        width: auto;
    }
    nav {
        border: 1px solid #ccc;
        padding: 4px;
    }
    nav  a  {
        text-decoration: none;
        color: #fff;
        text-shadow: 0 2px 1px rgba(0,0,0,.2);
        /*text-shadow:水平位置 垂直位置 模糊距离 阴影颜色;*/
    }
    .row {
        height: 90px;
        display: flex; /*伸缩布局*/
        border-radius: 5px; 
        overflow: hidden;
        margin-bottom: 5px;
    }
    .row div {
        height: 100%;
        flex: 1;
        background-color: #FF697A;
        border-right: 1px solid #fff;
    }
    .row div:nth-child(3) {
        border-right: 0;
    }
    .row div a {
        display: block;
        width: 100%;
        height: 100%;
    }
    .row33 {
        display: flex;
        flex-direction: column;
    }
    .row33 a {
        flex: 1;
        text-align: center;
        line-height: 45px;
    }
    .row33 a:first-child {
        border-bottom: 1px solid #fff;
    }
    .row em {
        display: block;
        height: 45px;
        text-align: center;
        line-height: 45px;
        font-style: normal;
    }
    .row i {
        display: block;
        width: 43px;
        height: 43px;
        margin: -5px auto 0;
        background: url(images/ctrip.png) no-repeat 0 -127px;
        -webkit-background-size: 104px;  /* 前缀 */
        -moz-background-size: 104px;  /* 前缀 火狐 */
        -ms-background-size: 104px;  /* 前缀 ie */
        -o-background-size: 104px;  /* 前缀 ie */
        background-size: 104px;

    }
    .row .icon-flight {
        background-position: 0 -288px;
    }

    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;header&amp;gt;
        &amp;lt;img src=&quot;images/banner.jpg&quot; height=&quot;307&quot; width=&quot;1536&quot; alt=&quot;&quot;&amp;gt;
    &amp;lt;/header&amp;gt;
    &amp;lt;nav&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;
                    &amp;lt;em&amp;gt;酒店&amp;lt;/em&amp;gt;
                    &amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;
                &amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;row33&quot;&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;海外酒店&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;特价酒店&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;row33&quot;&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;团购&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;同福客栈&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;
                    &amp;lt;em&amp;gt;酒店&amp;lt;/em&amp;gt;
                    &amp;lt;i class=&quot;icon-flight&quot;&amp;gt;&amp;lt;/i&amp;gt;
                &amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;row33&quot;&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;海外酒店&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;特价酒店&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;row33&quot;&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;团购&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;同福客栈&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;
                    &amp;lt;em&amp;gt;酒店&amp;lt;/em&amp;gt;
                    &amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;
                &amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;row33&quot;&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;海外酒店&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;特价酒店&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;row33&quot;&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;团购&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;同福客栈&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            
        &amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;row&quot;&amp;gt;
            &amp;lt;div class=&quot;row33&quot;&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;海外酒店&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;特价酒店&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;row33&quot;&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;海外酒店&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;特价酒店&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;row33&quot;&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;团购&amp;lt;/a&amp;gt;
                &amp;lt;a href=&quot;#&quot;&amp;gt;同福客栈&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
            
        &amp;lt;/div&amp;gt;
    &amp;lt;/nav&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;你如果愿意有所作为，就必须有始有终。(19)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 11 Jan 2020 13:55:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>CSS3(5) 伸缩布局 有关页面布局之前写过三篇相关文章： 1、 &amp;quot;CSS(5) 盒子模型&amp;quot; 2、 &amp;quot;CSS(6) 浮动(float)&amp;quot; 3、 &amp;quot;C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11953758.html</dc:identifier>
</item>
<item>
<title>PHP的一些安全设置 - 有痣青年</title>
<link>http://www.cnblogs.com/zydj333/p/12181175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zydj333/p/12181175.html</guid>
<description>&lt;p&gt;小伙伴们新年好啊，又有半个月没有更新博客了。更新也比较随性，想起什么就写点什么，方便和大家工作同学习总结。&lt;/p&gt;
&lt;p&gt;最近和同事说起了PHP安全相关的问题，记录下一些心得体会。&lt;/p&gt;
&lt;p&gt;由于脚本语言和早期版本设计的诸多原因，php项目存在不少安全隐患。从配置选项来看，可以做如下的优化。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.屏蔽PHP错误输出。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;在/etc/php.ini(默认配置文件位置)，将如下配置值改为Off&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
display_errors=Off
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不要将错误堆栈信息直接输出到网页上，防止黑客加以利用相关信息。&lt;/p&gt;
&lt;p&gt;正确的做法是：&lt;br/&gt;把错误日志写到日志文件中，方便排查问题。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.屏蔽PHP版本。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;默认情况下PHP版本会被显示在返回头里，如：&lt;br/&gt;&lt;span&gt;&lt;code&gt;Response Headers X-powered-by: PHP/7.2.0&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将php.ini中如下的配置值改为Off&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
expose_php=Off
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.关闭全局变量。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;如果开启全局变量会使一些表单提交的数据被自动注册为全局变量。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;form &lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;=&quot;/login&quot;&lt;/span&gt;&lt;span&gt; method&lt;/span&gt;&lt;span&gt;=&quot;post&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;username&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;submit&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;form&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;如果开启了全局变量，则服务器端PHP脚本可以用$username和$password来获取到用户名和密码，这会造成极大的脚本注入危险。&lt;/p&gt;
&lt;p&gt;开启方法是在php.ini中修改如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
register_globals=On
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建议关闭，参数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
register_globals=Off
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;当关闭后，就只能从$_POST、$_GET、$_REQUEST里面获取相关参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.文件系统限制&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;可以通过open_basedir来限制PHP可以访问的系统目录。&lt;/p&gt;
&lt;p&gt;如果不限制使用下面的脚本代码（hack.php）可以获取到系统密码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;file_get_contents&lt;/span&gt;('/etc/passwd');
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当设置了后则会报错,不再显示相关信息，让系统目录b不会被非法访问：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;PHP Warning: file_get_contents(): open_basedir restriction in effect. File(/etc/passwd) is not within the allowed path(s): (/var/www) in /var/www/hack.php on line 3&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Warning: file_get_contents(): open_basedir restriction in effect. File(/etc/passwd) is not within the allowed path(s): (/var/www) in /var/www/hack.php on line 3 PHP Warning: file_get_contents(/etc/passwd): failed to open stream: Operation not permitted in /var/www/hack.php on line 3&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;Warning: file_get_contents(/etc/passwd): failed to open stream: Operation not permitted in /var/www/hack.php on line 3&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设置方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
open_basedir=/&lt;span&gt;var&lt;/span&gt;/www
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.禁止远程资源访问。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
allow_url_fopen=&lt;span&gt;Off

allow_url_include&lt;/span&gt;=Off
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他第三方安全扩展&lt;br/&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;code&gt;6.Suhosin。&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;Suhosin是一个PHP程序的保护系统。它的设计初衷是为了保护服务器和用户，抵御PHP程序和PHP核心中已知或者未知的缺陷（感觉挺实用的，可以抵御一些小攻击）。Suhosin有两个独立的部分，使用时可以分开使用或者联合使用。&lt;/p&gt;
&lt;p&gt;第一部分是一个用于PHP核心的补丁，它能抵御缓冲区溢出或者格式化串的弱点（这个必须的！）；&lt;/p&gt;
&lt;p&gt;第二部分是一个强大的 PHP扩展（扩展模式挺好的，安装方便…），包含其他所有的保护措施。&lt;/p&gt;
&lt;h3 id=&quot;wiz_toc_2&quot;&gt;安装扩展&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
wget http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;download.suhosin.org/suhosin-0.9.37.1.tar.gz&lt;/span&gt;
tar zxvf suhosin-0.9.37.1.tar.&lt;span&gt;gz
cd suhosin&lt;/span&gt;-0.9.37.1/&lt;span&gt;
phpize
&lt;/span&gt;./configure  --with-php-config=/usr/local/bin/php-&lt;span&gt;config
make
make install
在php&lt;/span&gt;.ini下加入suhosin.&lt;span&gt;so即可

extension&lt;/span&gt;=suhosin.so
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;模拟器保护模式&lt;/li&gt;
&lt;li&gt;增加两个函数sha256()和sha256_file()到PHP核心中&lt;/li&gt;
&lt;li&gt;所有平台，加入CRYPT_BLOWFISH到函数crypt()中&lt;/li&gt;
&lt;li&gt;打开对phpinfo()页的透明保护&lt;/li&gt;
&lt;li&gt;SQL数据库用户保护（测试阶段）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;运行时保护&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt; 加密cookies&lt;/li&gt;
&lt;li&gt;防止不同种类的包含漏洞（不允许远程URL包含（黑/白名单）；不允许包含已上传的文件；防止目录穿越攻击）&lt;/li&gt;
&lt;li&gt;允许禁止preg_replace() &lt;/li&gt;
&lt;li&gt;允许禁止eval()函数&lt;/li&gt;
&lt;li&gt;通过配置一个最大执行深度，来防止无穷递归&lt;/li&gt;
&lt;li&gt;支持每个vhost配置黑白名单&lt;/li&gt;
&lt;li&gt;为代码执行提供分离的函数黑白名单&lt;/li&gt;
&lt;li&gt;防止HTTP响应拆分漏洞&lt;/li&gt;
&lt;li&gt;防止脚本控制memory_limit选项&lt;/li&gt;
&lt;li&gt;保护PHP的superglobals，如函数extract()，import_request_vars()&lt;/li&gt;
&lt;li&gt;防止mail()函数的新行攻击&lt;/li&gt;
&lt;li&gt;防止preg_replace()的攻击&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Session 保护&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加密session数据&lt;/li&gt;
&lt;li&gt;防止session被劫持&lt;/li&gt;
&lt;li&gt;防止超长的session id&lt;/li&gt;
&lt;li&gt;防止恶意的session id&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;SESSION里的数据通常在服务器上的明文存放的。这里通过在服务端来加解密&lt;code&gt;$_SESSION&lt;/code&gt;。这样将Session的句柄存放在Memcache或数据库时,就不会被轻易攻破，很多时候我们的session数据会存放一些敏感字段。&lt;/p&gt;
&lt;p&gt;这个特性在缺省情况下是启用的,也可以通过php.ini来修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
suhosin.session.encrypt =&lt;span&gt; On
suhosin&lt;/span&gt;.session.cryptkey =&lt;span&gt; zuHywawAthLavJohyRilvyecyondOdjo
suhosin&lt;/span&gt;.session.cryptua =&lt;span&gt; On
suhosin&lt;/span&gt;.session.cryptdocroot =&lt;span&gt; On

;; IPv4 only
suhosin&lt;/span&gt;.session.cryptraddr = 0&lt;span&gt;
suhosin&lt;/span&gt;.session.checkraddr = 0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Cookie加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Cookie在客户端浏览器的传输的HTTP头也是明文的。通过加密cookie，您可以保护您的应用程序对众多的攻击，如&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Cookie篡改：攻击者可能会尝试猜测其他合理的cookie值来攻击程序。&lt;/li&gt;
&lt;li&gt;跨应用程序使用Cookie：不正确配置的应用程序可能具有相同的会话存储，如所有会话默认存储在/tmp目录下，一个应用程序的cookie可能永远不会被重新用于另一应用，只要加密密钥不同。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Cookie加密在php.ini中的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
suhosin.cookie.encrypt =&lt;span&gt; On

;; the cryptkey should be generated&lt;/span&gt;, e.g. with 'apg -m 32'&lt;span&gt;
suhosin&lt;/span&gt;.cookie.cryptkey =&lt;span&gt; oykBicmyitApmireipsacsumhylWaps1
suhosin&lt;/span&gt;.cookie.cryptua =&lt;span&gt; On
suhosin&lt;/span&gt;.cookie.cryptdocroot =&lt;span&gt; On

;; whitelist&lt;/span&gt;/blacklist (&lt;span&gt;use&lt;/span&gt;&lt;span&gt; only one)
;suhosin&lt;/span&gt;.cookie.cryptlist = WALLET,&lt;span&gt;IDEAS
suhosin&lt;/span&gt;.cookie.plainlist =&lt;span&gt; LANGUAGE

;; IPv4 only
suhosin&lt;/span&gt;.cookie.cryptraddr = 0&lt;span&gt;
suhosin&lt;/span&gt;.cookie.checkraddr = 0&lt;span&gt;
Blocking Functions
测试

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#默认PHP的Session保存在tmp路径下&lt;/span&gt;
ll  -rt /tmp |&lt;span&gt; grep sess
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#扩展未开启时查看某条sesson的数据&lt;/span&gt;
&lt;span&gt;cat  sess_ururh83qvkkhv0n51lg17r4aj6
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录是明文的&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;#扩展开启后查看某条sesson 的数据&lt;/span&gt;
&lt;span&gt;cat  sess_ukkiiiheedupem8k4hheo0b0v4
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录是密文的&lt;/span&gt;
可见加密对安全的重要性
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;wiz_toc_5&quot;&gt;阻断功能&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;白名单&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#显式指定指定白名单列表&lt;/span&gt;
suhosin.executor.func.whitelist = &lt;span&gt;htmlentities&lt;/span&gt;,&lt;span&gt;htmlspecialchars&lt;/span&gt;,&lt;span&gt;base64_encode&lt;/span&gt;&lt;span&gt;
suhosin&lt;/span&gt;.executor.&lt;span&gt;eval&lt;/span&gt;.whitelist = &lt;span&gt;htmlentities&lt;/span&gt;,&lt;span&gt;htmlspecialchars&lt;/span&gt;,&lt;span&gt;base64_encode&lt;/span&gt;

&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;htmlentities&lt;/span&gt;('&amp;lt;test&amp;gt;'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;eval&lt;/span&gt;('echo htmlentities(&quot;&amp;lt;test&amp;gt;&quot;);');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;黑名单&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;#显式指定指定黑名单列表&lt;/span&gt;
suhosin.executor.func.blacklist = &lt;span&gt;assert&lt;/span&gt;,&lt;span&gt;unserialize&lt;/span&gt;,&lt;span&gt;exec&lt;/span&gt;,&lt;span&gt;popen&lt;/span&gt;,&lt;span&gt;proc_open&lt;/span&gt;,&lt;span&gt;passthru&lt;/span&gt;,&lt;span&gt;shell_exec&lt;/span&gt;,&lt;span&gt;system&lt;/span&gt;,hail,&lt;span&gt;parse_str&lt;/span&gt;,&lt;span&gt;mt_srand&lt;/span&gt;&lt;span&gt;
suhosin&lt;/span&gt;.executor.&lt;span&gt;eval&lt;/span&gt;.whitelist = &lt;span&gt;assert&lt;/span&gt;,&lt;span&gt;unserialize&lt;/span&gt;,&lt;span&gt;exec&lt;/span&gt;,&lt;span&gt;popen&lt;/span&gt;,&lt;span&gt;proc_open&lt;/span&gt;,&lt;span&gt;passthru&lt;/span&gt;,&lt;span&gt;shell_exec&lt;/span&gt;,&lt;span&gt;system&lt;/span&gt;,hail,&lt;span&gt;parse_str&lt;/span&gt;,&lt;span&gt;mt_srand&lt;/span&gt;&lt;span&gt;
通过日志来查看非法调用黑白名单

suhosin&lt;/span&gt;.simulation = 1&lt;span&gt;
suhosin&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;.&lt;span&gt;file&lt;/span&gt; = 511&lt;span&gt;
suhosin&lt;/span&gt;.&lt;span&gt;log&lt;/span&gt;.&lt;span&gt;file&lt;/span&gt;.name = /tmp/suhosin-alert.&lt;span&gt;log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;wiz_toc_6&quot;&gt;其他配置项&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
suhosin.executor.&lt;span&gt;include&lt;/span&gt;.&lt;span&gt;max_traversal    扩目录的最大深度，可以屏蔽切换到非法路径
suhosin&lt;/span&gt;.executor.&lt;span&gt;include&lt;/span&gt;.&lt;span&gt;whitelist        允许包含的URL，用逗号分隔
suhosin&lt;/span&gt;.executor.&lt;span&gt;include&lt;/span&gt;.&lt;span&gt;blacklist        禁止包含的URL，用逗号分隔
suhosin&lt;/span&gt;.executor.disable_eval =&lt;span&gt; On        禁用eval函数

suhosin&lt;/span&gt;.upload.&lt;span&gt;max_uploads
suhosin&lt;/span&gt;.upload.&lt;span&gt;disallow_elf
suhosin&lt;/span&gt;.upload.&lt;span&gt;disallow_binary
suhosin&lt;/span&gt;.upload.&lt;span&gt;remove_binary
suhosin&lt;/span&gt;.upload.verification_script        上传文件检查脚本，可以来检测上传的内容是否包含webshell特征
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用Suhosin，你可以得到一些错误日志，你能把这些日志放到系统日志中，也可以同时写到其他任意的日志文件中去;&lt;/p&gt;
&lt;p&gt;它还可以为每一个虚拟主机创建黑名单和白名单;&lt;/p&gt;
&lt;p&gt;可以过滤GET和POST请求、文件上载和cookie;&lt;/p&gt;
&lt;p&gt;你还能传送加密的会话和cookie，可以设置不能传送的存储上线等等;&lt;/p&gt;
&lt;p&gt;它不像原始的PHP强化补丁，Suhosin是可以被像Zend Optimizer这样的第三方扩展软件所兼容的。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Jan 2020 13:14:00 +0000</pubDate>
<dc:creator>有痣青年</dc:creator>
<og:description>小伙伴们新年好啊，又有半个月没有更新博客了。更新也比较随性，想起什么就写点什么，方便和大家工作同学习总结。 最近和同事说起了PHP安全相关的问题，记录下一些心得体会。 由于脚本语言和早期版本设计的诸多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zydj333/p/12181175.html</dc:identifier>
</item>
<item>
<title>一步一步教你制作销售目标分析报告 - 黄昏前黎明后</title>
<link>http://www.cnblogs.com/fly-bird/p/12181139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fly-bird/p/12181139.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　前面的文章中我已经使用了一个入门案例动态销售报告来带领大家入门PowerBI的入门学习，基于动态销售报告，我可以在来进行细化处理销售目标表中的数据。本文的主题就是销售目标的分析。我们都知道销售目标是销售的起点，销售人员每天的跟进都可以来反映销售目标完成情况。因此，将销售目标的颗粒度细化到每一天很有必要。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　销售目标的细化主要的难点在于许多的企业在销售业务中有季节性。比如说在相同的月份中，去年的2月和今年的2月可能天数不同，无法全部复制。还有就是月份中的周末时间，有些月份存在4个周末，有些月份存在5个周末。这些时间因素都会对销售趋势造成一定的影响。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　回到数据源结构，我们回顾一下动态销售报告中的销售明细数据。这个表中有销售日期和销售额，我们可以使用DAX函数来将销售目标处理到该表的汇总数据表中。接下就一起来处理数据吧。在PowerQuery中手动输入销售目标表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205236928-1359760184.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、汇总销售数据&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;　　在销售明细表中，有每一天，每一单，每个商品的详细记录数据，我们只需要对每天的销售金额进行汇总，可以借助DAX函数SUMMARIZE进行数据汇总处理。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1、提前销售日期和销售金额字段&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　在建模中新建表输入公式：销售汇总=SUMMARIZE('销售明细','销售明细'[销售日期],&quot;销售额&quot;,SUM('销售明细'[业绩金额]))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205310354-413234129.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　2、新建年，月，星期，年月，月周等列，方便后面计算指标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　年 = YEAR('销售汇总'[销售日期])&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　月 = MONTH('销售汇总'[销售日期])&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　周 = WEEKDAY('销售汇总'[销售日期],2)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　年月 = '销售汇总'[年]&amp;amp;'销售汇总'[月]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　月周 = '销售汇总'[月]&amp;amp;'销售汇总'[周]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、计算平均销售额构建销售系数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　由于销售数据存在不确定性，尤其是小的销售店铺可能存在销售数据差异比较大，所以我们需要通过计算平均销售额来计算出具有参考价值的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　1、计算每个月，每周七天的平均销售情况&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　某月星期几平均销售额=DIVIDE(SUMX(FILTER('销售汇总',EARLIER('销售汇总'[月周])='销售汇总'[月周]),'销售汇总'[周]),'销售汇总'[销售额]),COUNTAX(FILTER('销售汇总'，EARLIER('销售汇总'[月周])='销售汇总'[月周]),'销售汇总'[周]))&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　公式解析：以9月份的星期一为例，在本公式中，最外层通过DIVIDE对9月份所有的星期一的销售额和星期一的个数相除得到9月份星期一的平均销售额。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　SUMX计算星期一销售额的和，COUNTAX用来对星期一的个数进行计数，FILTER与EARLIER配合，只筛选表格中的9月份星期一的值进行求和与计数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　计算出平均销售额后，将格式更改为定点小数，并设置位数为2，设置千分位&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205417857-1311188039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　2、计算销售系数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　新建一列，输入公式：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　某月星期几的系数 = DIVIDE('销售汇总'[某月星期几平均销售额],MINX(FILTER('销售汇总',EARLIER('销售汇总'[月])='销售汇总'[月]),'销售汇总'[某月星期几平均销售额]))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　公式解析：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　最外层DIVIDE用来对星期几和星期几的最小值进行相除计算，MINX提取某月每周的最小平均销售额，FILTER与EARLIER的用法与上一步相同&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205503608-1834680151.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　三、新建销售系数表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　本次进行提取表中的月，周，月周，某月星期几的系数，还是使用SUMMARIZE&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　公式如下：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　销售系数 = SUMMARIZE('销售汇总','销售汇总'[月],'销售汇总'[周],'销售汇总'[月周],'销售汇总'[某月星期几的系数])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205554130-2003476161.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　到这里我们已经完成了销售系数的建立过程，接下来我们开始处理销售目标数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;四、销售目标分析&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　我们要将销售目标细化到每一天，就需要通过计算2019年每个月的不同星期的销售情况，与销售目标和销售系数进行匹配。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　1、生成日期表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2019销售目标 = CALENDAR(DATE(2019,1,1),DATE(2019,12,31))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　年= YEAR('2019销售目标'[Date])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　月 = MONTH('2019销售目标'[Date])&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　周 = WEEKDAY('2019销售目标'[Date],2)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　月周 = '2019销售目标'[月]&amp;amp;'2019销售目标'[周]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　2、建立表之间的关联关系&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205645375-1093237744.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　3、引入其他表中的指标到2019销售目标&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;　　销售系数 = RELATED('销售系数'[某月星期几的系数])&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当月销售目标 = RELATED('2019销售总目标'[销售目标])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205733078-1583873164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　4、计算当月每天销售占比&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　新建列，输入公式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　当月销售占比 = DIVIDE('2019销售目标'[销售系数],SUMX(FILTER('2019销售目标',EARLIER('2019销售目标'[月])='2019销售目标'[月]),'2019销售目标'[销售系数]))&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205815938-948463060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;br/&gt;&lt;span&gt;　　5、计算当天销售目标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　新建列，输入公式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　当天销售目标 = '2019销售目标'[当月销售目标]*'2019销售目标'[当月销售占比]&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205829712-927749010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;五、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　通过本文我们通过构建销售系数实现对销售目标的细化处理，同时我们也可以学习DAX函数的使用方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　1、SUMMARIZE函数对数据进行透视和汇总&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　2、SUMX,COUNTAX,MINX进行条件求和，计数，求最小值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　3、FILTER,EARLIER函数配合对表格进行筛选&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;　　4、CALENDAR生成一个日期表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/662342/202001/662342-20200111205902657-643579175.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



</description>
<pubDate>Sat, 11 Jan 2020 13:04:00 +0000</pubDate>
<dc:creator>黄昏前黎明后</dc:creator>
<og:description>前面的文章中我已经使用了一个入门案例动态销售报告来带领大家入门PowerBI的入门学习，基于动态销售报告，我可以在来进行细化处理销售目标表中的数据。本文的主题就是销售目标的分析。我们都知道销售目标是销</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fly-bird/p/12181139.html</dc:identifier>
</item>
<item>
<title>C#反射与特性(五)：类型成员操作 - 痴者工良</title>
<link>http://www.cnblogs.com/whuanle/p/12180972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whuanle/p/12180972.html</guid>
<description>&lt;p&gt;【微信平台，此文仅授权《NCC 开源社区》订阅号发布】&lt;/p&gt;
&lt;p&gt;前面三篇中，介绍了反射的基本内容和信息对象，反射主要作用于构造函数、属性、字段、方法、事件等类型成员对象；第四篇介绍了类型的实例化和事件操作。&lt;/p&gt;
&lt;p&gt;本篇介绍类型的成员操作和实践练习。&lt;/p&gt;
&lt;p&gt;由于内容较多，多动手实践一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1315495/202001/1315495-20200111200936131-1946985557.png&quot; alt=&quot;目录5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1315495/202001/1315495-20200111200737884-2142343271.png&quot; alt=&quot;成员类型&quot;/&gt;&lt;/p&gt;
&lt;center&gt;[图片1 来源：《C# 7.0核心技术指南：19.2 反射并调用成员》]&lt;/center&gt;
&lt;p&gt;那么，如何通过 Type 获取相应的成员呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1315495/202001/1315495-20200111200821436-265687405.png&quot; alt=&quot;检索元数据成员&quot;/&gt;&lt;/p&gt;
&lt;center&gt;[图片2 来源：《C# 7.0核心技术指南：19.2 反射并调用成员》]&lt;/center&gt;
&lt;p&gt;以上方法具有获取单个成员或多个成员的版本。&lt;/p&gt;
&lt;p&gt;所有的 *Info 实例都会在第一次使用时，由反射 API 缓存起来，这种缓存有助于优化 API 的性能。&lt;/p&gt;
&lt;h2 id=&quot;memberinfo&quot;&gt;1，MemberInfo&lt;/h2&gt;
&lt;p&gt;MemberInfo 可以获取有关成员属性的信息，并提供对成员元数据的访问权限。&lt;/p&gt;
&lt;p&gt;MemberInfo 类是用于获取有关类的所有成员（构造函数、事件、字段、方法和属性）的信息的类的抽象基类。&lt;/p&gt;
&lt;p&gt;由图片1可以看到，MemberInfo 是所有反射类型的基类，此类为所有成员提供了基本功能。&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;GetMember()&lt;/code&gt; 或 &lt;code&gt;GetMembers()&lt;/code&gt; 可以获取类型的一个或多个成员。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetMembers()&lt;/code&gt;该方法会返回当前类型（及其基类）的所有&lt;strong&gt;公有成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetMember&lt;/code&gt; 方法可以通过名称检索特定的成员。由于成员（方法、属性等）可能会被重载，因此该方法会返回一个数组。&lt;/p&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            MemberInfo[] members = type.GetMember(&quot;test&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;练习-获取类型的成员以及输出信息&quot;&gt;1.1 练习-获取类型的成员以及输出信息&lt;/h3&gt;
&lt;p&gt;创建一个类型&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class MyClass
    {
        private static string A { get; set; }
        public string B;
        public string C { get; set; }

        [Required] 
        public int Id { get; set; }
        
        [Phone] 
        public string Phone { get; set; }

        [EmailAddress]
        public string Email { get; set; }

        static MyClass()
        {
            A = &quot;666&quot;;
        }

        public MyClass()
        {
            B = &quot;666&quot;;
        }

        public MyClass(string message)
        {
            C = message;
        }

        public string Add(string a, string b)
        {
            return a + b;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            Type type = typeof(MyClass);
            MemberInfo[] members = type.GetMembers();
            foreach (var item in members)
            {
                Console.WriteLine(item.Name + &quot;    |     &quot; + item.MemberType);
            }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;get_C    |     Method
set_C    |     Method
get_Id    |     Method
set_Id    |     Method
get_Phone    |     Method
set_Phone    |     Method
get_Email    |     Method
set_Email    |     Method
Add    |     Method
GetType    |     Method
ToString    |     Method
Equals    |     Method
GetHashCode    |     Method
.ctor    |     Constructor
.ctor    |     Constructor
C    |     Property
Id    |     Property
Phone    |     Property
Email    |     Property
B    |     Field&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;membertype-枚举&quot;&gt;1.2 MemberType 枚举&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MemberInfo&lt;/code&gt; 中有个 MemberType 枚举的属性 名为 MemberType 。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MemberType&lt;/code&gt; 枚举的定义如下&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;All&lt;/td&gt;
&lt;td&gt;191&lt;/td&gt;
&lt;td&gt;指定所有成员类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Constructor&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;指定该成员是构造函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Custom&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;指定该成员是自定义成员类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Event&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;指定该成员是事件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Field&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;指定该成员是字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Method&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;指定该成员是方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NestedType&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td&gt;指定该成员是嵌套类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Property&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;指定该成员是属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;TypeInfo&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;指定该成员是类型&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;其中 &lt;code&gt;MemverType.All&lt;/code&gt; 的定义如下 &lt;code&gt;All = NestedType | TypeInfo | Property | Method | Field | Event | Constructor&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;memberinfo-获取成员方法并且调用&quot;&gt;1.3 MemberInfo 获取成员方法并且调用&lt;/h3&gt;
&lt;p&gt;下面的例子是通过 GetMembers 获取到 方法成员，并且传递参数调用。&lt;/p&gt;
&lt;p&gt;这里只是示例一下，关于方法的实例化和调用，在本文的第三节。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            MemberInfo[] members = type.GetMembers();
            foreach (var item in members)
            {
                // 如果成员属于方法
                if (item.MemberType == MemberTypes.Method)
                {
                    // 输出此方法的参数列表：参数类型+参数名称
                    foreach (ParameterInfo pi in ((MethodInfo)item).GetParameters())
                    {
                        Console.WriteLine(&quot;Parameter: Type={0}, Name={1}&quot;, pi.ParameterType, pi.Name);
                    }
                    // 如果是方法有两个参数，则调用
                    if (((MethodInfo)item).GetParameters().Length == 2)
                    {
                        // 调用一个方法以及传递参数
                        MethodInfo method = (MethodInfo)item;
                        Console.WriteLine(&quot;调用一个方法，输出结果：&quot;);
                        Console.WriteLine(method.Invoke(example, new object[] { &quot;1&quot;, &quot;2&quot; }));
                    }
                }
            }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;获取继承中方法的信息declaringtype-和-reflectedtype&quot;&gt;1.4 获取继承中方法的信息(DeclaringType 和 ReflectedType)&lt;/h3&gt;
&lt;p&gt;MemberInfo 中，有三种获取类型的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MemberType 获取成员何种函数(例如字段、属性、方法等)；&lt;/li&gt;
&lt;li&gt;DeclaringType 该属性返回该成员的定义类型；&lt;/li&gt;
&lt;li&gt;ReflectedType 返回调用 GetMembers 的具体类型；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为一个方法可以继承，也可以重写，那么很多时候判断和调用，就需要了解相关信息；&lt;/p&gt;
&lt;p&gt;DeclaringType ：一个类型中使用了父类或者自己的方法，那么返回此方法的出处；&lt;/p&gt;
&lt;p&gt;ReflectedType ：从哪个类型中获取，就返回哪个类型；即从个 Type 里获得成员实例，就返回这个 Type 的名称；&lt;/p&gt;
&lt;p&gt;新建一个两个类型&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 父类
    /// &amp;lt;/summary&amp;gt;
    public class MyClassFather
    {
        /// &amp;lt;summary&amp;gt;
        /// 重写 ToString()
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public override string ToString()
        {
            return base.ToString();
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 子类
    /// &amp;lt;/summary&amp;gt;
    public class MyClassSon : MyClassFather
    {
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台 Program.Main 中，编写&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            Type typeFather = typeof(MyClassFather);
            Type typeSon = typeof(MyClassSon);
            Type typeObj = typeof(object);
            Type typeProgram = typeof(Program);

            // 为了省步骤，就不用 MemberInfo 了
            MethodInfo methodObj = typeObj.GetMethod(&quot;ToString&quot;);
            MethodInfo methodFather = typeFather.GetMethod(&quot;ToString&quot;);
            MethodInfo methodSon = typeSon.GetMethod(&quot;ToString&quot;);
            MethodInfo methodProgram = typeProgram.GetMethod(&quot;ToString&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印 &lt;code&gt;DeclaringType&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            Console.WriteLine(methodObj.DeclaringType);
            Console.WriteLine(methodFather.DeclaringType);
            Console.WriteLine(methodSon.DeclaringType);
            Console.WriteLine(methodProgram.DeclaringType);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;System.Object
Mytest.MyClassFather
Mytest.MyClassFather
System.Object&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析：&lt;/p&gt;
&lt;p&gt;MyClassFather 对 &lt;code&gt;ToString&lt;/code&gt; 方法进行了重写，所以 &lt;code&gt;DeclaringType&lt;/code&gt; 获取到的类型就是 MyClassFather ;&lt;/p&gt;
&lt;p&gt;MyClassSon 继承了 MyClassFather，直接使用父类的 &lt;code&gt;ToString()&lt;/code&gt; 方法，所以返回的是 MyClassFather ；&lt;/p&gt;
&lt;p&gt;Program 没有对 &lt;code&gt;ToString()&lt;/code&gt; 进行重写，所以返回的是 Object；&lt;/p&gt;
&lt;h2 id=&quot;从-il-看反射&quot;&gt;2，从 IL 看反射&lt;/h2&gt;
&lt;p&gt;笔者的 IL 知识非常薄弱，只能列出一些简单的内容。&lt;/p&gt;
&lt;p&gt;在最前面的练习中，我们发现&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        public string C { get; set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;get_C    |     Method
set_C    |     Method
C    |     Property&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的 IL 是这样的&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;.property instance string C()
{  
    .get instance string Mytest.MyClass::get_C()  
    .set instance void Mytest.MyClass::set_C(string)
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性、索引器、事件生成的 IL 总结：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1315495/202001/1315495-20200111200851777-645332115.png&quot; alt=&quot;生成的IL&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面三种类型，生成 IL 时，都会有相应的 方法生成，通过 &lt;code&gt;GetMethods()&lt;/code&gt; 或者 &lt;code&gt;GetMembers()&lt;/code&gt; 可以获取到。&lt;/p&gt;
&lt;h3 id=&quot;获取属性的构造&quot;&gt;2.1 获取属性的构造&lt;/h3&gt;
&lt;p&gt;定义一个类型&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class MyClass
    {
        private string Test;

        public string A
        {
            get { return Test; }
        }

        public string B
        {
            set { Test = value; }
        }

        public string C { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从前面的实例中，有不少是获取属性列表的示例，但是无法从中识别出里面的构造，例如上面的 MyClass 类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PropertyInfo&lt;/code&gt; 中有个 &lt;code&gt;GetAccessors()&lt;/code&gt; 方法，可以获取相应的信息。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;GetAccessors()&lt;/td&gt;
&lt;td&gt;返回一个数组，其元素反射了由当前实例反射的属性的公共 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 访问器。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;GetAccessors(Boolean)&lt;/td&gt;
&lt;td&gt;返回一个数组，其元素反射了当前实例反射的属性的公共及非公共（如果指定）&lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;set&lt;/code&gt; 取值函数。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用示例&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            Type type = typeof(MyClass);
            PropertyInfo[] list = type.GetProperties();
            foreach (var item in list)
            {
                var c = item.GetAccessors();
                foreach (var node in c)
                {
                    Console.WriteLine(node);
                }

                Console.WriteLine(&quot;************&quot;);
            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;System.String get_A()
************
Void set_B(System.String)
************
System.String get_C()
Void set_C(System.String)
************&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果将上面的属性 C 改成&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        public string C { get; private set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么只能输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.String get_A()
************
Void set_B(System.String)
************
System.String get_C()
************&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想获取私有构造器，可以使用&lt;code&gt;.GetAccessors(true)&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;属性的方法&quot;&gt;2.2 属性的方法&lt;/h3&gt;
&lt;p&gt;从反射和 IL 我们得知，一个属性会自动生成两个方法。&lt;/p&gt;
&lt;p&gt;那么我们通过 PropertyInfo 可以获取到这些方法。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GetSetMethod&lt;/td&gt;
&lt;td&gt;获取 set 方法，返回 MethodInfo&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GetGetMethod&lt;/td&gt;
&lt;td&gt;获取 get 方法，返回 MethodInfo&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GetAccessors&lt;/td&gt;
&lt;td&gt;获取上面两个方法的集合，返回 MethodInfo[]&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;创建一个属性&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;        public string C { get;  set; }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            Type type = typeof(MyClass);
            PropertyInfo property = type.GetProperty(&quot;C&quot;);
            // 指定获取 get 或 set
            MethodInfo set = property.GetSetMethod();
            MethodInfo get = property.GetGetMethod();

            MethodInfo[] all = property.GetAccessors();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;方法操作&quot;&gt;3，方法操作&lt;/h2&gt;
&lt;p&gt;我们要记得，反射，是对元数据的利用；只有实例才能被执行调用。&lt;/p&gt;
&lt;p&gt;在这里，说一下 &lt;code&gt;nameof&lt;/code&gt; 关键字，nameof 没有任何作用，他不会对程序产生任何影响。&lt;/p&gt;
&lt;p&gt;nameof(T) 可以输出 T，例如 &lt;code&gt;namaof(Program)&lt;/code&gt; 输出 &lt;code&gt;Program&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么什么情况下使用到他呢？&lt;/p&gt;
&lt;p&gt;我们在写代码时，会使用到例如 Visual Studio 等 IDE，如果使用 nameof，里面的类型是强类型的，可以查找引用、跳转、获取注释等。如果需要重构，也可以快速重命名所有引用。&lt;/p&gt;
&lt;p&gt;如果直接使用字符串的话，容易拼错命名、一旦修改一个命名，需要手动找到所有字符串进行修改。&lt;/p&gt;
&lt;p&gt;调用一个实例方法有如下步骤：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;获取 Type&lt;/td&gt;
&lt;td&gt;Type&lt;/td&gt;
&lt;td&gt;通过程序集等各种方式获取 Type 类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;获取实例&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;通过 &lt;code&gt;Activator.CreateInstance(type);&lt;/code&gt; 创建实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;获取方法&lt;/td&gt;
&lt;td&gt;MethodInfo或 MemberInfo&lt;/td&gt;
&lt;td&gt;通过 Type 获取对应的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;设置参数列表&lt;/td&gt;
&lt;td&gt;object[] parameters&lt;/td&gt;
&lt;td&gt;调用方法时传递的参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;执行方法&lt;/td&gt;
&lt;td&gt;.Invoke() 方法&lt;/td&gt;
&lt;td&gt;执行 MethodInfo.Invoke()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;获取返回结果&lt;/td&gt;
&lt;td&gt;object&lt;/td&gt;
&lt;td&gt;执行方法获取到返回结果&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;各种方式调用方法&quot;&gt;3.1 各种方式调用方法&lt;/h3&gt;
&lt;p&gt;首先我们定义一个类型&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class MyClass
    {
        /// &amp;lt;summary&amp;gt;
        /// 无参数，五返回值
        /// &amp;lt;/summary&amp;gt;
        public void A()
        {
            Console.WriteLine(&quot;A被执行&quot;);
        }

        /// &amp;lt;summary&amp;gt;
        /// 有参数，有返回值
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;a&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public string B(string left)
        {
            Console.WriteLine(&quot;执行 B(string left)&quot;);
            return left + &quot;666&quot;;
        }

        public string C(string left,int right)
        {
            Console.WriteLine(&quot;执行 C(string left,int right)&quot;);
            return left + right;
        }

        public string C(string left, string right)
        {
            Console.WriteLine(&quot;执行 C(string left, string right)&quot;);
            return left + right;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Program 编写代码获取到类型的 Type 以及创建实例。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            Type type = typeof(MyClass);

            object example = Activator.CreateInstance(type);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;调用方法&quot;&gt;3.1.1 调用方法&lt;/h4&gt;
&lt;p&gt;我们来调用方法 &lt;code&gt;A()&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            // 获取 A
            MethodInfo methodA = type.GetMethod(nameof(MyClass.A));
            
            // 传递实例，并且执行实例的 A 方法
            methodA.Invoke(example, new Object[] { });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;方法 &lt;code&gt;B&lt;/code&gt; 有一个参数，我们调用时添加参数进去&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            object result;

            // 获取 B
            MethodInfo methodB = type.GetMethod(nameof(MyClass.B));

            // 传递参数
            // 执行获取返回结果
            result = methodB.Invoke(example, new[] {&quot;测试&quot;});&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取参数列表&quot;&gt;3.1.2 获取参数列表&lt;/h4&gt;
&lt;p&gt;前面 1.1 中，示例有关于获取方法参数的代码。这里不再赘述&lt;/p&gt;
&lt;h4 id=&quot;获取重载方法&quot;&gt;3.1.3 获取重载方法&lt;/h4&gt;
&lt;p&gt;在 《C# 反射与特性》系列的第四篇，我们介绍了构造函数 ConstructorInfo 的调用和重载，MethodInfo 实际上也是差不多的。&lt;/p&gt;
&lt;p&gt;上面我们使用了 &lt;code&gt;type.GetMethod(&quot;方法名称&quot;)&lt;/code&gt; 的方法获取了 MethodInfo ，对于 &lt;code&gt;MyClass.C&lt;/code&gt;，有两个重载，那么我们可以这样指定要使用的重载方法&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            // 获取 C
            // 执行获取返回结果
            MethodInfo methodC = type.GetMethod(nameof(MyClass.C), new Type[] {typeof(string), typeof(string)});
            result = methodC.Invoke(example, new string[] {&quot;测试&quot;, &quot;测试&quot;});
            //       result = methodC.Invoke(example, new Object[] {&quot;测试&quot;, &quot;测试&quot;});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，对于类型、构造函数、委托、方法的实例化与操作，已经讲了一次。&lt;/p&gt;
&lt;p&gt;下面将说一下属性和字段如何设置值和获取值。&lt;/p&gt;
</description>
<pubDate>Sat, 11 Jan 2020 12:11:00 +0000</pubDate>
<dc:creator>痴者工良</dc:creator>
<og:description>【微信平台，此文仅授权《NCC 开源社区》订阅号发布】 前面三篇中，介绍了反射的基本内容和信息对象，反射主要作用于构造函数、属性、字段、方法、事件等类型成员对象；第四篇介绍了类型的实例化和事件操作。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/whuanle/p/12180972.html</dc:identifier>
</item>
</channel>
</rss>