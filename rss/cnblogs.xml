<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[从源码学设计]蚂蚁金服SOFARegistry之消息总线异步处理 - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/14088011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/14088011.html</guid>
<description>&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列文章重点在于分析设计和架构，即利用多篇文章，从多个角度反推总结 DataServer 或者 SOFARegistry 的实现机制和架构思路，让大家借以学习阿里如何设计。本文为第五篇，介绍SOFARegistry消息总线的异步处理。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;338.76208704336&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。&lt;/p&gt;
&lt;p&gt;本系列文章重点在于分析设计和架构，即利用多篇文章，从多个角度反推总结 DataServer 或者 SOFARegistry 的实现机制和架构思路，让大家借以学习阿里如何设计。&lt;/p&gt;
&lt;p&gt;本文为第五篇，介绍SOFARegistry消息总线的异步处理。&lt;/p&gt;
&lt;h2 id=&quot;0x01-为何分离&quot;&gt;0x01 为何分离&lt;/h2&gt;
&lt;p&gt;前文我们讲述了SOFARegistry的消息总线，本文我们讲讲一个变种 DataChangeEventCenter。&lt;/p&gt;
&lt;p&gt;DataChangeEventCenter 是被独立出来的，专门处理数据变化相关的消息。&lt;/p&gt;
&lt;p&gt;为什么要分离呢？因为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从架构说，DataChangeEventCenter 是专门处理数据变化消息，这是一种解耦；&lt;/li&gt;
&lt;li&gt;从技术上来说，DataChangeEventCenter 也和 EventCenter 有具体实现技巧的不同，所以需要分开处理；&lt;/li&gt;
&lt;li&gt;但更深入的原因是业务场景不同，下面分析中我们可以看出，DataChangeEventCenter 和业务耦合的相当紧密；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x02-业务领域&quot;&gt;0x02 业务领域&lt;/h2&gt;
&lt;h3 id=&quot;21-应用场景&quot;&gt;2.1 应用场景&lt;/h3&gt;
&lt;p&gt;DataChangeEventCenter 的独特业务场景如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要提供归并功能。即短期内会有多个通知来到，不需要逐一处理，只处理最后一个即可；&lt;/li&gt;
&lt;li&gt;异步处理消息；&lt;/li&gt;
&lt;li&gt;需要保证消息顺序；&lt;/li&gt;
&lt;li&gt;有延迟操作；&lt;/li&gt;
&lt;li&gt;需要提高处理能力，并行处理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，DataChangeEventCenter 代码和业务联系相当紧密，前文的 EventCenter 已经不适合了。&lt;/p&gt;
&lt;h3 id=&quot;22-延迟和归并&quot;&gt;2.2 延迟和归并&lt;/h3&gt;
&lt;p&gt;关于延迟和归并操作，我们单独说明下。&lt;/p&gt;
&lt;h4 id=&quot;221-业务特点&quot;&gt;2.2.1 业务特点&lt;/h4&gt;
&lt;p&gt;蚂蚁金服业务的一个&lt;strong&gt;特点&lt;/strong&gt;是：&lt;u&gt;通过连接敏感的特性对服务宕机做到秒级发现&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;因此 SOFARegistry 在健康检测的设计方面决定“服务数据与服务发布者的实体连接绑定在一起，断连马上清数据”，简称此特点叫做&lt;u&gt;连接敏感性&lt;/u&gt;。连接敏感性是指在 SOFARegistry 里所有 Client 都与 SessionServer 保持长连接，每条长连接都设置基于 SOFABolt 的连接心跳，如果长连接断连客户端立即发起重新建连，时刻保持 Client 与 SessionServer 之间可靠的连接。&lt;/p&gt;
&lt;h4 id=&quot;222-问题&quot;&gt;2.2.2 问题&lt;/h4&gt;
&lt;p&gt;但带来了&lt;u&gt;一个问题&lt;/u&gt;就是：可能因为网络问题，短期内会出现大量重新建连操作。比如只是网络问题导致连接断开，实际的服务进程没有宕机，此时客户端立即发起重新连接 SessionServer 并且重新注册所有服务数据。&lt;/p&gt;
&lt;p&gt;但是 假如此过程耗时足够短暂（例如 500ms 内发生断连和重连），服务订阅者&lt;strong&gt;&lt;u&gt;应该&lt;/u&gt;&lt;/strong&gt;感受不到服务下线。从而 SOFARegistry 内部&lt;u&gt;应该做相应处理&lt;/u&gt;。&lt;/p&gt;
&lt;h4 id=&quot;223-解决&quot;&gt;2.2.3 解决&lt;/h4&gt;
&lt;p&gt;SOFARegistry 内部做了归并和延迟操作来保证用户不受影响。比如 DataServer 内部的数据通过 mergeDatum 延迟合并变更的 Publisher 服务信息，version 是合并后最新的版本号。&lt;/p&gt;
&lt;p&gt;对于 &lt;u&gt;DataChangeEventCenter，就是通过消息的延迟和归并来协助完成这个功能&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;23-蚂蚁金服实现&quot;&gt;2.3 蚂蚁金服实现&lt;/h3&gt;
&lt;p&gt;下面是 DataChangeEventCenter 总体的功能描述：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当有数据发布者 publisher 上下线时，会分别触发 publishDataProcessor 或 unPublishDataHandler；&lt;/li&gt;
&lt;li&gt;Handler 首先会判断当前节点的状态：
&lt;ul&gt;&lt;li&gt;若是非工作状态则返回请求失败；&lt;/li&gt;
&lt;li&gt;若是工作状态，Handler 会往 dataChangeEventCenter 中添加一个数据变更事件，则触发数据变化事件中心 DataChangeEventCenter 的 onChange 方法。用于异步地通知事件变更中心数据的变更；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;事件变更中心收到该事件之后，会往队列中加入事件。此时 dataChangeEventCenter 会根据不同的事件类型异步地对上下线数据进行相应的处理；&lt;/li&gt;
&lt;li&gt;与此同时，DataChangeHandler 会把这个事件变更信息通过 ChangeNotifier 对外发布，通知其他节点进行数据同步；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x03-datachangeeventcenter&quot;&gt;0x03 DataChangeEventCenter&lt;/h2&gt;
&lt;h3 id=&quot;31-总述&quot;&gt;3.1 总述&lt;/h3&gt;
&lt;p&gt;DataChangeEventCenter具体分成四部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Event Center：组织成消息中心；&lt;/li&gt;
&lt;li&gt;Event Queue：用于多路分别处理，增加处理能力；&lt;/li&gt;
&lt;li&gt;Event Task：每一个Queue内部启动一个线程，用于异步处理，增加处理能力；&lt;/li&gt;
&lt;li&gt;Event Handler：用于处理内部ChangeData；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们一一介绍，因为 DataChangeEventCenter 和业务结合紧密，所以我们会深入结合业务进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;32-datachangeeventcenter&quot;&gt;3.2 DataChangeEventCenter&lt;/h3&gt;
&lt;h4 id=&quot;321-定义&quot;&gt;3.2.1 定义&lt;/h4&gt;
&lt;p&gt;DataChangeEventCenter 中维护着一个 DataChangeEventQueue 队列数组，这是核心。数组中的每个元素是一个事件队列。具体定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataChangeEventCenter {

    /**
     * count of DataChangeEventQueue
     */
    private int                    queueCount;

    /**
     * queues of DataChangeEvent
     */
    private DataChangeEventQueue[] dataChangeEventQueues;

    @Autowired
    private DataServerConfig       dataServerConfig;

    @Autowired
    private DatumCache             datumCache;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;322-消息类型&quot;&gt;3.2.2 消息类型&lt;/h4&gt;
&lt;p&gt;DataChangeEventCenter 专门处理 IDataChangeEvent 类型消息，其具体实现为三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public class ClientChangeEvent implements IDataChangeEvent&lt;/li&gt;
&lt;li&gt;public class DataChangeEvent implements IDataChangeEvent&lt;/li&gt;
&lt;li&gt;public class DatumSnapshotEvent implements IDataChangeEvent&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些不同类型的消息可以放入同一个队列，&lt;u&gt;具体放入哪个队列，是根据特定判别方式来决定&lt;/u&gt;，比如根据Publisher的DataInfoId来做hash，以此决定放入哪个Queue。&lt;/p&gt;
&lt;p&gt;即，当对应 handler 的 onChange 方法被触发时，会计算该变化服务的 dataInfoId 的 Hash 值，从而进一步确定出该服务注册数据所在的队列编号，进而把该变化的数据封装成一个数据变化对象，传入到队列中。&lt;/p&gt;
&lt;h4 id=&quot;323-初始化&quot;&gt;3.2.3 初始化&lt;/h4&gt;
&lt;p&gt;在初始化函数中，构建了EventQueue，每一个Queue启动了一个线程，用来处理消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PostConstruct
public void init() {
    if (isInited.compareAndSet(false, true)) {
        queueCount = dataServerConfig.getQueueCount();
        dataChangeEventQueues = new DataChangeEventQueue[queueCount];
        for (int idx = 0; idx &amp;lt; queueCount; idx++) {
            dataChangeEventQueues[idx] = new DataChangeEventQueue(idx, dataServerConfig, this,datumCache);
            dataChangeEventQueues[idx].start();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;324-put-消息&quot;&gt;3.2.4 Put 消息&lt;/h4&gt;
&lt;p&gt;put消息比较简单，具体如何判别应该把Event放入哪一个Queue是根据具体方式来判断，比如根据Publisher的DataInfoId来做hash，以此决定放入哪个Queue：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int idx = hash(publisher.getDataInfoId());
Datum datum = new Datum(publisher, dataCenter);
dataChangeEventQueues[idx].onChange(new DataChangeEvent(DataChangeTypeEnum.MERGE,
                DataSourceTypeEnum.PUB, datum));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;325-如何处理消息&quot;&gt;3.2.5 如何处理消息&lt;/h4&gt;
&lt;p&gt;具体是通过 dataChangeEventQueues.onChange 来做处理，比如如下几个函数，分别处理不同的消息类型。具体都是找到queue，然后调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void onChange(Publisher publisher, String dataCenter) {
    int idx = hash(publisher.getDataInfoId());
    Datum datum = new Datum(publisher, dataCenter);
    if (publisher instanceof UnPublisher) {
        datum.setContainsUnPub(true);
    }
    if (publisher.getPublishType() != PublishType.TEMPORARY) {
        dataChangeEventQueues[idx].onChange(new DataChangeEvent(DataChangeTypeEnum.MERGE,
            DataSourceTypeEnum.PUB, datum));
    } else {
        dataChangeEventQueues[idx].onChange(new DataChangeEvent(DataChangeTypeEnum.MERGE,
            DataSourceTypeEnum.PUB_TEMP, datum));
    }
}

public void onChange(ClientChangeEvent event) {
    for (DataChangeEventQueue dataChangeEventQueue : dataChangeEventQueues) {
        dataChangeEventQueue.onChange(event);
    }
}

public void onChange(DatumSnapshotEvent event) {
    for (DataChangeEventQueue dataChangeEventQueue : dataChangeEventQueues) {
        dataChangeEventQueue.onChange(event);
    }
}

public void sync(DataChangeTypeEnum changeType, DataSourceTypeEnum sourceType, Datum datum) {
    int idx = hash(datum.getDataInfoId());
    DataChangeEvent event = new DataChangeEvent(changeType, sourceType, datum);
    dataChangeEventQueues[idx].onChange(event);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-datachangeevent&quot;&gt;3.3 DataChangeEvent&lt;/h3&gt;
&lt;p&gt;因为 DataChangeEvent 最常用，所以我们单独拿出来说明。&lt;/p&gt;
&lt;p&gt;DataChangeEvent会根据DataChangeTypeEnum和DataSourceTypeEnum来进行区分，就是处理类型和消息来源。&lt;/p&gt;
&lt;p&gt;DataChangeTypeEnum具体分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MERGE，如果变更类型是MERGE，则会更新缓存中需要更新的新Datum，并且更新版本号；&lt;/li&gt;
&lt;li&gt;COVER，如果变更类型是 COVER，则会覆盖原有的缓存；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DataSourceTypeEnum 具体分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;PUB ：pub by client；&lt;/li&gt;
&lt;li&gt;PUB_TEMP ：pub temporary data；&lt;/li&gt;
&lt;li&gt;SYNC：sync from dataservers in other datacenter；&lt;/li&gt;
&lt;li&gt;BACKUP：from dataservers in the same datacenter；&lt;/li&gt;
&lt;li&gt;CLEAN：local dataInfo check,not belong this node schedule remove；&lt;/li&gt;
&lt;li&gt;SNAPSHOT：Snapshot data, after renew finds data inconsistent；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataChangeEvent implements IDataChangeEvent {

    /**
     * type of changed data, MERGE or COVER
     */
    private DataChangeTypeEnum changeType;

    private DataSourceTypeEnum sourceType;

    /**
     * data changed
     */
    private Datum              datum;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;34-datachangeeventqueue&quot;&gt;3.4 DataChangeEventQueue&lt;/h3&gt;
&lt;p&gt;DataChangeEventQueue 是这个子模块的核心，用于&lt;u&gt;多路分别处理，增加处理能力&lt;/u&gt;。每一个Queue内部启动一个线程，用于&lt;u&gt;异步处理，也能增加处理能力&lt;/u&gt;。&lt;/p&gt;
&lt;h4 id=&quot;341-核心变量&quot;&gt;3.4.1 核心变量&lt;/h4&gt;
&lt;p&gt;这里的核心是：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;BlockingQueue eventQueue;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Map&amp;lt;String, Map&amp;lt;String, ChangeData&amp;gt;&amp;gt; CHANGE_DATA_MAP_FOR_MERGE = new ConcurrentHashMap&amp;lt;&amp;gt;();&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;DelayQueue CHANGE_QUEUE = new DelayQueue();&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;讲解如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以看到，这里操作的数据类型是ChangeData，&lt;u&gt;把Datum转换成 ChangeData 可以把消息处理方式 或者 来源统一起来处理&lt;/u&gt;；&lt;/li&gt;
&lt;li&gt;eventQueue 用来存储投放的消息，所有消息block在queue上，这可以保证消息的顺序处理；&lt;/li&gt;
&lt;li&gt;CHANGE_DATA_MAP_FOR_MERGE。顾名思义，主要处理消息归并。这是按照 dataCenter，dataInfoId 作为维度，分别存储 ChangeData，可以理解为一个矩阵Map，使用putIfAbsent方法添加键值对，如果map集合中没有该key对应的值，则直接添加，并返回null，如果已经存在对应的值，则依旧为原来的值。&lt;u&gt;这样如果短期内向map中添加多个消息，这样就对多余的消息做了归并&lt;/u&gt;；&lt;/li&gt;
&lt;li&gt;CHANGE_QUEUE 的作用是用于统一处理投放的ChangeData，无论是哪个 data center的数据，都会统一在这里处理；这里需要注意的是&lt;u&gt;使用了DelayQueue来进行延迟操作&lt;/u&gt;，就是我们之前业务中提到的延迟操作；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataChangeEventQueue {

    private final String                               name;

    /**
     * a block queue that stores all data change events
     */
    private final BlockingQueue&amp;lt;IDataChangeEvent&amp;gt;      eventQueue;

    private final Map&amp;lt;String, Map&amp;lt;String, ChangeData&amp;gt;&amp;gt; CHANGE_DATA_MAP_FOR_MERGE = new ConcurrentHashMap&amp;lt;&amp;gt;();

    private final DelayQueue&amp;lt;ChangeData&amp;gt;               CHANGE_QUEUE              = new DelayQueue();

    private final int                                  notifyIntervalMs;

    private final int                                  notifyTempDataIntervalMs;

    private final ReentrantLock                        lock                      = new ReentrantLock();

    private final int                                  queueIdx;

    private DataServerConfig                           dataServerConfig;

    private DataChangeEventCenter                      dataChangeEventCenter;

    private DatumCache                                 datumCache;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;342-启动和引擎&quot;&gt;3.4.2 启动和引擎&lt;/h4&gt;
&lt;p&gt;DataChangeEventQueue#start 方法在 DataChangeEventCenter 初始化的时候被一个新的线程调用，&lt;u&gt;该线程会源源不断地从队列中获取新增事件，并且进行分发。新增数据会由此添加进节点内，实现分片&lt;/u&gt;。因为 eventQueue 是一个 BlockingQueue，所以可以使用while (true)来控制。&lt;/p&gt;
&lt;p&gt;当event被取出之后，会根据 DataChangeScopeEnum.DATUM 的不同，会做不同的处理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是DataChangeScopeEnum.DATUM，则判断dataChangeEvent.getSourceType()；
&lt;ul&gt;&lt;li&gt;如果是 DataSourceTypeEnum.PUB_TEMP，则addTempChangeData，就是往CHANGE_QUEUE添加ChangeData；&lt;/li&gt;
&lt;li&gt;如果不是，则handleDatum；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如果是DataChangeScopeEnum.CLIENT，则handleClientOff((ClientChangeEvent) event);&lt;/li&gt;
&lt;li&gt;如果是DataChangeScopeEnum.SNAPSHOT，则handleSnapshot((DatumSnapshotEvent) event)；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void start() {
    Executor executor = ExecutorFactory
            .newSingleThreadExecutor(String.format(&quot;%s_%s&quot;, DataChangeEventQueue.class.getSimpleName(), getName()));
    executor.execute(() -&amp;gt; {
        while (true) {
            try {
                IDataChangeEvent event = eventQueue.take();
                DataChangeScopeEnum scope = event.getScope();
                if (scope == DataChangeScopeEnum.DATUM) {
                    DataChangeEvent dataChangeEvent = (DataChangeEvent) event;
                    //Temporary push data will be notify as soon as,and not merge to normal pub data;
                    if (dataChangeEvent.getSourceType() == DataSourceTypeEnum.PUB_TEMP) {
                        addTempChangeData(dataChangeEvent.getDatum(), dataChangeEvent.getChangeType(),
                                dataChangeEvent.getSourceType());
                    } else {
                        handleDatum(dataChangeEvent.getChangeType(), dataChangeEvent.getSourceType(),
                                dataChangeEvent.getDatum());
                    }
                } else if (scope == DataChangeScopeEnum.CLIENT) {
                    handleClientOff((ClientChangeEvent) event);
                } else if (scope == DataChangeScopeEnum.SNAPSHOT) {
                    handleSnapshot((DatumSnapshotEvent) event);
                }
            } 
        }
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体如下图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;      +----------------------------+
      |   DataChangeEventCenter    |
      |                            |
      | +-----------------------+  |
      | | DataChangeEventQueue[]|  |
      | +-----------------------+  |
      +----------------------------+
                   |
                   |
                   v
+------------------+------------------------+
|          DataChangeEventQueue             |
|                                           |
| +---------------------------------------+ |
| |                                       | |
| |    BlockingQueue&amp;lt;IDataChangeEvent&amp;gt; +-------------+
| |                                       | |        |
| |                                       | |      +-v---------+
| | Map&amp;lt;String, Map&amp;lt;String, ChangeData&amp;lt;&amp;gt;  | | &amp;lt;--&amp;gt; |           |
| |                                       | |      | Executor  |
| |                                       | |      |           |
| |         start +------------------------------&amp;gt; |           |
| |                                       | |      +-+---------+
| |                                       | |        |
| |      DelayQueue&amp;lt;ChangeData&amp;gt;  &amp;lt;-------------------+
| |                                       | |
| +---------------------------------------+ |
+-------------------------------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;343-changedata&quot;&gt;3.4.3 ChangeData&lt;/h4&gt;
&lt;p&gt;handleDatum 具体处理是把Datum转换为 ChangeData来处理，&lt;/p&gt;
&lt;p&gt;为什么要转换成 ChangeData来存储呢。&lt;/p&gt;
&lt;p&gt;因为无论是消息处理方式或者来源，都有不同的类型。&lt;strong&gt;比如&lt;/strong&gt;在 NotifyFetchDatumHandler . fetchDatum 函数中，会先从其他 data server 获取 Datum，然后会根据 Datum 向dataChangeEventCenter中投放消息，通知本 Data Server 进行 BACKUP 操作，类型是 COVER 类型。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;转换成 ChangeData就可以把消息处理方式或者来源统一起来处理&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;用户会存储一个包含 datum 的消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;dataChangeEventCenter.sync(DataChangeTypeEnum.COVER, DataSourceTypeEnum.BACKUP, datum);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DataChangeEventQueue 会从 DataChangeEvent 中获取 Datum，然后把 Datum 转换为 ChangeData，存储起来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void handleDatum(DataChangeTypeEnum changeType, DataSourceTypeEnum sourceType,
                         Datum targetDatum) {
            //get changed datum
            ChangeData changeData = getChangeData(targetDatum.getDataCenter(),
                targetDatum.getDataInfoId(), sourceType, changeType);
            Datum cacheDatum = changeData.getDatum();
            if (changeType == DataChangeTypeEnum.COVER || cacheDatum == null) {
                changeData.setDatum(targetDatum);
            } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ChangeData 定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ChangeData implements Delayed {

    /** data changed */
    private Datum              datum;

    /** change time */
    private Long               gmtCreate;

    /** timeout */
    private long               timeout;

    private DataSourceTypeEnum sourceType;

    private DataChangeTypeEnum changeType;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;344-处理datum&quot;&gt;3.4.4 处理Datum&lt;/h4&gt;
&lt;h5 id=&quot;3441-加入datum&quot;&gt;3.4.4.1 加入Datum&lt;/h5&gt;
&lt;p&gt;这里是处理真实ChangeData缓存，以及新加入的Datum。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先从 CHANGE_DATA_MAP_FOR_MERGE 获取之前存储的变更的ChangeData，如果没有，就生成一个加入，此时要为后续可能的归并做准备；&lt;/li&gt;
&lt;li&gt;拿到ChangeData之后
&lt;ul&gt;&lt;li&gt;如果变更类型是 COVER，则会覆盖原有的缓存。changeData.setDatum(targetDatum);&lt;/li&gt;
&lt;li&gt;否则是MERGE，则会更新缓存中需要更新的新Datum，并且更新版本号；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void handleDatum(DataChangeTypeEnum changeType, DataSourceTypeEnum sourceType,
                         Datum targetDatum) {
    lock.lock();
    try {
        //get changed datum
        ChangeData changeData = getChangeData(targetDatum.getDataCenter(),
            targetDatum.getDataInfoId(), sourceType, changeType);
        Datum cacheDatum = changeData.getDatum();
        if (changeType == DataChangeTypeEnum.COVER || cacheDatum == null) {
            changeData.setDatum(targetDatum);
        } else {
            Map&amp;lt;String, Publisher&amp;gt; targetPubMap = targetDatum.getPubMap();
            Map&amp;lt;String, Publisher&amp;gt; cachePubMap = cacheDatum.getPubMap();
            for (Publisher pub : targetPubMap.values()) {
                String registerId = pub.getRegisterId();
                Publisher cachePub = cachePubMap.get(registerId);
                if (cachePub != null) {
                    // if the registerTimestamp of cachePub is greater than the registerTimestamp of pub, it means
                    // that pub is not the newest data, should be ignored
                    if (pub.getRegisterTimestamp() &amp;lt; cachePub.getRegisterTimestamp()) {
                        continue;
                    }
                    // if pub and cachePub both are publisher, and sourceAddress of both are equal,
                    // and version of cachePub is greater than version of pub, should be ignored
                    if (!(pub instanceof UnPublisher) &amp;amp;&amp;amp; !(cachePub instanceof UnPublisher)
                        &amp;amp;&amp;amp; pub.getSourceAddress().equals(cachePub.getSourceAddress())
                        &amp;amp;&amp;amp; cachePub.getVersion() &amp;gt; pub.getVersion()) {
                        continue;
                    }
                }
                cachePubMap.put(registerId, pub);
                cacheDatum.setVersion(targetDatum.getVersion());
            }
        }
    } finally {
        lock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;3442-提出datum&quot;&gt;3.4.4.2 提出Datum&lt;/h5&gt;
&lt;p&gt;当提取时候，使用take函数，从CHANGE_QUEUE 和 CHANGE_DATA_MAP_FOR_MERGE 提出ChangeData。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public ChangeData take() throws InterruptedException {
    ChangeData changeData = CHANGE_QUEUE.take();
    lock.lock();
    try {
        removeMapForMerge(changeData);
        return changeData;
    } finally {
        lock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体提取Datum会在DataChangeHandler。&lt;/p&gt;
&lt;h3 id=&quot;35-datachangehandler&quot;&gt;3.5 DataChangeHandler&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;DataChangeHandler 会定期提取DataChangeEventCenter中的消息，然后进行处理&lt;/u&gt;，主要功能就是执行ChangeNotifier 来通知相关模块：hi，这里有新数据变化来到了，兄弟们走起来。&lt;/p&gt;
&lt;h4 id=&quot;351-类定义&quot;&gt;3.5.1 类定义&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DataChangeHandler {

    @Autowired
    private DataServerConfig          dataServerConfig;

    @Autowired
    private DataChangeEventCenter     dataChangeEventCenter;

    @Autowired
    private DatumCache                datumCache;

    @Resource
    private List&amp;lt;IDataChangeNotifier&amp;gt; dataChangeNotifiers;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;352-执行引擎changenotifier&quot;&gt;3.5.2 执行引擎ChangeNotifier&lt;/h4&gt;
&lt;p&gt;DataChangeHandler 会遍历 DataChangeEventCenter 中所有 DataChangeEventQueue，然后从 DataChangeEventQueue 之中取出ChangeData，针对每一个ChangeData，生成一个ChangeNotifier。&lt;/p&gt;
&lt;p&gt;每个ChangeNotifier都是一个处理线程。&lt;/p&gt;
&lt;p&gt;每个 dataChangeEventQueue 生成了 5 个 ChangeNotifier。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@PostConstruct
public void start() {
    DataChangeEventQueue[] queues = dataChangeEventCenter.getQueues();
    int queueCount = queues.length;
    Executor executor = ExecutorFactory.newFixedThreadPool(queueCount, DataChangeHandler.class.getSimpleName());
    Executor notifyExecutor = ExecutorFactory
            .newFixedThreadPool(dataServerConfig.getQueueCount() * 5, this.getClass().getSimpleName());
  
    for (int idx = 0; idx &amp;lt; queueCount; idx++) {
        final DataChangeEventQueue dataChangeEventQueue = queues[idx];
        final String name = dataChangeEventQueue.getName();
        executor.execute(() -&amp;gt; {
            while (true) {
                 final ChangeData changeData = dataChangeEventQueue.take();
                 notifyExecutor.execute(new ChangeNotifier(changeData, name));
            }
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;353-notify&quot;&gt;3.5.3 Notify&lt;/h4&gt;
&lt;p&gt;我们回顾下业务：&lt;/p&gt;
&lt;p&gt;当有数据发布者 publisher 上下线时，会分别触发 publishDataProcessor 或 unPublishDataHandler ，Handler 会往 dataChangeEventCenter 中添加一个数据变更事件，用于异步地通知事件变更中心数据的变更。事件变更中心收到该事件之后，会往队列中加入事件。此时 dataChangeEventCenter 会根据不同的事件类型异步地对上下线数据进行相应的处理。&lt;/p&gt;
&lt;p&gt;&lt;u&gt;对于 ChangeData，会生成 ChangeNotifier 进行处理。会把这个事件变更信息通过 ChangeNotifier 对外发布，通知其他节点进行数据同步&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private class ChangeNotifier implements Runnable {

    private ChangeData changeData;
    private String     name;

    @Override
    public void run() {
        if (changeData instanceof SnapshotData) {
           ......
        } else {
            Datum datum = changeData.getDatum();

            String dataCenter = datum.getDataCenter();
            String dataInfoId = datum.getDataInfoId();
            DataSourceTypeEnum sourceType = changeData.getSourceType();
            DataChangeTypeEnum changeType = changeData.getChangeType();

            if (changeType == DataChangeTypeEnum.MERGE
                &amp;amp;&amp;amp; sourceType != DataSourceTypeEnum.BACKUP
                &amp;amp;&amp;amp; sourceType != DataSourceTypeEnum.SYNC) {
                //update version for pub or unPub merge to cache
                //if the version product before merge to cache,it may be cause small version override big one
                datum.updateVersion();
            }

            long version = datum.getVersion();

            try {
                if (sourceType == DataSourceTypeEnum.CLEAN) {
                    if (datumCache.cleanDatum(dataCenter, dataInfoId)) {
                      ......
                    }

                } else if (sourceType == DataSourceTypeEnum.PUB_TEMP) {
                    notifyTempPub(datum, sourceType, changeType);
                } else {
                    MergeResult mergeResult = datumCache.putDatum(changeType, datum);
                    Long lastVersion = mergeResult.getLastVersion();

                    if (lastVersion != null
                        &amp;amp;&amp;amp; lastVersion.longValue() == LocalDatumStorage.ERROR_DATUM_VERSION) {
                        return;
                    }

                    //lastVersion null means first add datum
                    if (lastVersion == null || version != lastVersion) {
                        if (mergeResult.isChangeFlag()) {
                            notify(datum, sourceType, lastVersion);
                        }
                    }
                }
            } 
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;notify函数会遍历dataChangeNotifiers&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void notify(Datum datum, DataSourceTypeEnum sourceType, Long lastVersion) {
    for (IDataChangeNotifier notifier : dataChangeNotifiers) {
        if (notifier.getSuitableSource().contains(sourceType)) {
            notifier.notify(datum, lastVersion);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的Bean是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean(name = &quot;dataChangeNotifiers&quot;)
public List&amp;lt;IDataChangeNotifier&amp;gt; dataChangeNotifiers() {
    List&amp;lt;IDataChangeNotifier&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
    list.add(sessionServerNotifier());
    list.add(tempPublisherNotifier());
    list.add(backUpNotifier());
    return list;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于如何处理通知，我们后续会撰文处理。&lt;/p&gt;
&lt;p&gt;至此，DataChangeEventCenter 整体逻辑如下图所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                +----------------------------+
                |   DataChangeEventCenter    |
                |                            |
                | +-----------------------+  |
                | | DataChangeEventQueue[]|  |
                | +-----------------------+  |
                +----------------------------+
                             |
                             |
                             v
          +------------------+------------------------+
          |          DataChangeEventQueue             |
          |                                           |
          | +---------------------------------------+ |
          | |                                       | |
          | |    BlockingQueue&amp;lt;IDataChangeEvent&amp;gt; +-------------+
          | |                                       | |        |
          | |                                       | |      +-v---------+
          | | Map&amp;lt;String, Map&amp;lt;String, ChangeData&amp;lt;&amp;gt;  | | &amp;lt;--&amp;gt; |           |
          | |                                       | |      | Executor  |
          | |                                       | |      |           |
          | |         start +------------------------------&amp;gt; |           |
          | |                                       | |      +-+---------+
          | |                                       | |        |
+----------------+ DelayQueue&amp;lt;ChangeData&amp;gt;  &amp;lt;-------------------+
|         | |                                       | |
|         | +---------------------------------------+ |
|         +-------------------------------------------+
|
|
|         +--------------------------+
|  take   |                          |    notify   +-------------------+
+-------&amp;gt; |    DataChangeHandler     | +---------&amp;gt; |dataChangeNotifiers|
          |                          |             +-------------------+
          +--------------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202012/1850883-20201204221227604-831044251.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x04-结论&quot;&gt;0x04 结论&lt;/h2&gt;
&lt;p&gt;因为独特的业务场景，所以阿里把 DataChangeEventCenter 单独分离出来，满足了以下业务需求。如果大家在实际工作中有类似的需求，可以参考借鉴，具体处理方式如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要提高处理能力，并行处理；
&lt;ul&gt;&lt;li&gt;用&lt;u&gt;queue数组&lt;/u&gt;实现，每一个Queue都可以处理消息，增加处理能力；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;异步处理消息；
&lt;ul&gt;&lt;li&gt;每一个Queue内部启动一个线程，用于异步处理；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;需要保证消息顺序；
&lt;ul&gt;&lt;li&gt;eventQueue 用来存储投放的消息，所有消息block在queue上，这可以保证消息的顺序处理；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有延迟操作；
&lt;ul&gt;&lt;li&gt;使用了DelayQueue来进行延迟操作；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;需要归并操作，即短期内会有多个通知来到，不需要逐一处理，只处理最后一个即可；
&lt;ul&gt;&lt;li&gt;使用putIfAbsent方法添加键值对，如果map集合中没有该key对应的值，则直接添加，并返回null，如果已经存在对应的值，则依旧为原来的值。&lt;u&gt;这样如果短期内向map中添加多个消息，这样就对多余的消息做了归并&lt;/u&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wagne/p/10188091.html&quot;&gt;Guava中EventBus分析&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 04 Dec 2020 23:53:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。本系列文章重点在于分析设计和架构，即利用多篇文章，从多个角度反推总结 DataServer 或者 SOFARegis</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/14088011.html</dc:identifier>
</item>
<item>
<title>Django搭建示例项目实战与避坑细节 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14087725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14087725.html</guid>
<description>&lt;p&gt;Django 开发项目是很快的，有多快？看完本篇文章，你就知道了。&lt;/p&gt;

&lt;p&gt;前提条件：已安装 Python。&lt;/p&gt;
&lt;p&gt;Django 使用 pip 命令直接就可以安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pip install django
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果安装失败，很可能是因为网络连接超时了，试试国内镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pip install --default-timeout=6000 -i https://pypi.tuna.tsinghua.edu.cn/simple django
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条命令同时延长了超时时间，提高成功率。&lt;/p&gt;
&lt;p&gt;安装完成后，通过 &lt;code&gt;django-admin --version&lt;/code&gt; 这条命令验证。&lt;/p&gt;

&lt;p&gt;按住 Windows 键 + R，输入 cmd 回车，接着 cd 到任意目录：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201204204441109-1055369351.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;或者先打开目录窗口，在地址栏输入 cmd 回车，不需要 cd（推荐）：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201204204441568-498442269.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;在命令行窗口输入命令创建 project：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;django-admin startproject mysite
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目录结构如下（注意有 2 个 mysite 哦）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        asgi.py
        wsgi.py
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;Django 项目由 1 个 project 和多个 app 组成。project 存放项目配置，app 是网站各个功能的具体实现。&lt;/p&gt;
&lt;p&gt;app 的放置目录没有限制，这里先放在和 mysite 的同级目录中，先进入外层的 mysite 文件夹：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd mysite
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入命令创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;django-admin startapp polls
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目录结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysite/
        polls/
        __init__.py
        admin.py
        apps.py
        migrations/
            __init__.py
        models.py
        tests.py
        views.py
    mysite/
    manage.py
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 cmd 创建完 project 和 app 以后，就可以打开 PyCharm，再 Open mysite 项目了：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201204204442025-396397434.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;为了让 app 和 project 关联起来，需要在 mysite/settings.py 文件中添加配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'polls.apps.PollsConfig',  # 添加
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 polls/models.py 文件中添加数据模型：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.db import models


class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')


class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;前提条件：已安装 MySQL，创建好数据库。&lt;/p&gt;
&lt;p&gt;Django 默认使用轻量级数据库 SQLite，我们切换为常用的 MySQL。&lt;/p&gt;
&lt;p&gt;修改 mysite/settings.py 中的数据库配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'HOST': '主机',
        'PORT': 端口,
        'NAME': '数据库名',
        'USER': '用户名',
        'PASSWORD': '密码'
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Django 默认通过底层调用 mysqlclient 这个库和 MySQL 交互。但是 mysqlclient 非常不好安装！我们改用 pymysql。&lt;/p&gt;
&lt;p&gt;先安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pip install pymysql
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在与 mysite/settings.py 文件同级的 &lt;code&gt;__init__&lt;/code&gt; 文件中添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import pymysql

pymysql.version_info = (1, 4, 0, &quot;final&quot;, 0)
pymysql.install_as_MySQLdb()
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;数据迁移，指的是把代码中的数据模型，迁移到数据库中，创建相应的表结构。&lt;/p&gt;
&lt;p&gt;第一步，告诉 Django 数据模型有更新：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;python manage.py makemigrations polls
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Migrations for 'polls':
  polls/migrations/0001_initial.py
    - Create model Question
    - Create model Choice
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步，执行数据迁移同步：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py migrate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行后输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Operations to perform:
  Apply all migrations: admin, auth, contenttypes, polls, sessions
Running migrations:
  Rendering model states... DONE
  Applying polls.0001_initial... OK
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库表就创建好了：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201204204442226-41352202.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;万事俱备，只差 1 条启动命令，在根目录执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py runserver
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://127.0.0.1:8000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%9D%A5%E8%87%AA&quot;&gt;http://127.0.0.1:8000/，就可以看到来自&lt;/a&gt; Django 老铁的这发火箭了：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201204204442432-2083342958.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;本文是对《匆匆一眼》文章的补充。介绍了如何安装 Django，创建 Django 的 project 和 app，连接 MySQL，执行数据迁移，最后启动项目的实际操作步骤。思路很清晰。整体流程清楚了，可这些文件都是干嘛的呢？&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/3.1/intro/tutorial01/&quot;&gt;https://docs.djangoproject.com/en/3.1/intro/tutorial01/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 Dec 2020 23:34:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>搭建示例项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14087725.html</dc:identifier>
</item>
<item>
<title>可参考才是有价值的，架构设计的技改之路从来都不容易 - 互联网应用架构</title>
<link>http://www.cnblogs.com/lemeno/p/14088430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lemeno/p/14088430.html</guid>
<description>&lt;blockquote class=&quot;pgc-blockquote-abstract&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;溪云阁：专注编程教学，架构，JAVA，Python，微服务，机器学习等领域，欢迎关注，一起学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p3-tt.byteimg.com/origin/dfic-imagehandler/34f8c046-188a-4d4a-9a77-653deb795868?from=pc&quot; alt=&quot;可参考才是有价值的，架构设计的技改之路从来都不容易&quot; class=&quot;syl-page-img&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;有本书说：会使用框架不一定能成为一个优秀的架构师，但优秀的架构师一定会使用框架。架构师除了会使用工具，还需要有架构设计思想和性能调优技能。在设计上追求简单有效，不做过度设计。&lt;/p&gt;

&lt;p&gt;目前很多企业都是以项目为主，一个项目撑起整片天的大把存在，这样的情况在设计上需要非常把握一个度，尽可能以项目为导向做到点到即可，年轻人要讲武德。但是当我们有了几十个，几百个甚至上千个应用的时候，此时需要的不单单是单个项目设计，更需要整个企业级别的总体规划及总体设计，在这个上面需要做顶层思考与设计。&lt;/p&gt;
&lt;p&gt;大公司有大公司的好，小公司有小公司的温暖，大公司很多时候人情冷暖心里自知，小公司小团队常常存在家庭般的体贴。在大公司里面做技术，由于公司体积庞大导致经常难以看到这个商业的全貌，在规划上非常吃亏，除非站在非常高的层面去俯瞰整个体系；小公司又缺乏最基础的流量及各种中间件的应用场景，或者在使用了某些技术框架后也只是存在单纯意义上的使用，不是为了贴近业务场景；中型公司基本上针对这两者都能兼顾到，此时在做整体的企业级架构设计的时候往往比较容易落地。&lt;/p&gt;
&lt;p&gt;说起来简单做起来难，落地这两个字是非常考验能力，整个企业整体架构设计需要在技术，管理，业务三方做取舍，游刃有余的同时又能动态切换，架构师在设计上还包含业务架构，应用架构，数据架构，技术架构4种，但是现在很多都是总包做，没办法的事。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p1-tt.byteimg.com/origin/dfic-imagehandler/5819bdcc-d53f-4c17-860d-8726e5b81567?from=pc&quot; alt=&quot;可参考才是有价值的，架构设计的技改之路从来都不容易&quot; class=&quot;syl-page-img&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;小孩子学画画从来都是从一张白纸开始，一笔一画进行涂鸦。在项目或者企业的开始阶段，应用架构的设计就跟小孩子画画一样都是从一张白纸开始，也是一个不断试错、不断进化的过程。这样子的架构其实就是起到一个承上启下的作用，承接功能需求，下连代码编写，这就是应用架构灵魂所在，它是最快能体现出价值的东西。&lt;/p&gt;
&lt;p&gt;从功能设计来分析设计，涉及到各类UML图，领域图，整体架构分层，核心组件或者代码的编写，这些都是紧密结合并如铜环般串起来，环环相扣。整体的架构关注点永远在于职责问题、领域边界、应用关系、存储设计、部署。&lt;/p&gt;
&lt;p&gt;任何东西都是可大可小，做大了做复杂了容易增加开发人员的压力，直接导致项目延期。每一个应用的分层，需要做到简单有效，易用学习成本低，业务场景支持性强等。在我们设计上，参考了DDD的边界思想设计好我们的接口边界，并限定统一的出参入参来进行区分处理，这样子的设计其实就是还原了机器最原始的输入输出设计。&lt;/p&gt;
&lt;p&gt;人都是懒惰的，特别是研发人员，总想着我做了一个东西后面不用写了，所有的东西都来复用它；但是研发人员又是最勤奋的，他们想方设法做了一个适应了所有方法的东西，花费了巨大的时间。其实这种设计往往带有很大的危险性，容易在后面的运维上增加运维的时间并且让这个系统的复杂度变得非常高。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p1-tt.byteimg.com/origin/dfic-imagehandler/e815b129-d8d2-42df-89b6-213caf37fabd?from=pc&quot; alt=&quot;可参考才是有价值的，架构设计的技改之路从来都不容易&quot; class=&quot;syl-page-img&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;任何架构都是要落地的、要标准化、要不断演化的，这部分是需要通过融合技术架构与组织架构来实现。每一个角色的转化，从架构师到技术管理，所关注的角度跟层面并不一样，单纯的留在技术层面演化成关注技术在商业的应用价值，技术跟业务的契合度，整个技术团队的文化、能力不断成长。&lt;/p&gt;
&lt;p&gt;微服务的出现是个契机也是个痛苦的根源所在。很多企业刚开始使用最简单的单体架构，开始往微服务架构迁移，这就是技改的过程。这样子的过程无论项目大小都是痛苦的，项目小投入少但是微服务所需要的资源多，项目小涉及到的业务量多，很容易变成为了不影响业务而小改，不敢全盘推倒去做而采用慢慢吞并方式去做，最终变成单体与微服务并行的存在，你却又无可奈何并且筋疲力劲不想继续做，反正对上层的领导有交代就行，他们更加关注的就是系统，业务的稳定性。&lt;/p&gt;
&lt;p&gt;技改其实并不是单纯的技术改造，而是道路的演变，但是技改无论对大公司或者小公司而言，都是非常痛苦的，“小赌怡情，大赌伤财”。那什么样的技改才是正确之路，应该是能驱动公司业务发展的技改才是正确之路，让技术与业务互相融合，互相匹配，同时技改的时候一定要尊重食物的发展规律，不要为了技改而技改，那就纯粹为了炫技。这让我想起以前面试过一家公司，从各类语言问到架构，从架构问到数据科学，范围很广，技术很牛逼，一问没啥量，一年顶了天就1T非架构化数据，量能也就不到上万人。WTF，垃圾。&lt;/p&gt;
&lt;p&gt;每一个技术团队都是可爱的，不像外面穿的死气沉沉，如果一个部门整天都是死气沉沉，那就是这个部门领导有问题，让整个部门充满激情活力，从固步自分到分享为乐，这就是团队文化的建设。信任是团队非常重要的存在，只有这样子出来的团队文化，才能真正留得住人。&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;https://p6-tt.byteimg.com/origin/dfic-imagehandler/1739b292-18e9-4069-8883-c6f4b6e15b16?from=pc&quot; alt=&quot;可参考才是有价值的，架构设计的技改之路从来都不容易&quot; class=&quot;syl-page-img&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 04 Dec 2020 23:17:00 +0000</pubDate>
<dc:creator>互联网应用架构</dc:creator>
<og:description>架构设计的技改之路从来都不容易</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lemeno/p/14088430.html</dc:identifier>
</item>
<item>
<title>Docker实战 | 第二篇：IDEA集成Docker插件实现一键自动打包部署微服务项目，一劳永逸的技术手段值得一试 - 你好，旧时光</title>
<link>http://www.cnblogs.com/haoxianrui/p/14088400.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoxianrui/p/14088400.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://i.loli.net/2020/12/05/OrCfWcXuQ5n9jBA.jpg&quot; class=&quot;desc_img&quot;/&gt;大家在自己玩微服务项目的时候，动辄十几个服务，每次修改逐一部署繁琐不说也会浪费越来越多时间，所以本篇整理通过一次性配置实现一键部署微服务，实现真正所谓的一劳永逸。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;147.65985333125&quot;&gt;
&lt;h2 id=&quot;一-前言&quot;&gt;一. 前言&lt;/h2&gt;
&lt;p&gt;大家在自己玩微服务项目的时候，动辄十几个服务，每次修改逐一部署繁琐不说也会浪费越来越多时间，所以本篇整理通过一次性配置实现一键部署微服务，实现真正所谓的一劳永逸。&lt;/p&gt;
&lt;h2 id=&quot;二-配置服务器&quot;&gt;二. 配置服务器&lt;/h2&gt;
&lt;h3 id=&quot;1-docker安装&quot;&gt;1. Docker安装&lt;/h3&gt;
&lt;p&gt;服务器需要安装Docker，如未安装参考这篇文章安装即可 &lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14067423.html&quot;&gt;Docker实战 | 第一篇：Linux 安装 Docker&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-docker开启远程访问&quot;&gt;2. Docker开启远程访问&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;vim /usr/lib/systemd/system/docker.service
# 在ExecStart=/usr/bin/dockerd追加
-H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/02/zjmryVLKf4U2sCv.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 重新启动
systemctl daemon-reload
systemctl restart docker
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# 开放2375端口
firewall-cmd --zone=public --add-port=2375/tcp --permanent
firewall-cmd --reload
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-远程访问测试&quot;&gt;3. 远程访问测试&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# 查看端口监听是否开启
netstat -nlpt
# curl测试是否生效
curl http://127.0.0.1:2375/info
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二-配置idea&quot;&gt;二. 配置IDEA&lt;/h2&gt;
&lt;p&gt;IDEA安装Docker插件,打开插件市场（File-&amp;gt;Settings-&amp;gt;Plugins）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/02/twmD13ReHbFTiA6.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装Docker插件后，配置Docker远程链接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/02/otZXbuYAlciwUPQ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三-maven插件构建docker镜像&quot;&gt;三. Maven插件构建Docker镜像&lt;/h2&gt;
&lt;h3 id=&quot;1-maven构建docker镜像方式&quot;&gt;1. Maven构建Docker镜像方式&lt;/h3&gt;
&lt;p&gt;maven构建docker镜像有两种方式，分别docker-maven-plugin和dockerfile-maven，都是出自Spotify公司之手。&lt;/p&gt;
&lt;p&gt;进入项目 &lt;a href=&quot;https://github.com/spotify/docker-maven-plugin&quot;&gt;https://github.com/spotify/docker-maven-plugin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中有个很显眼的提示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/02/m8vkO7Kqn2dlYZz.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/02/kUORVwigomFhtIx.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;docker-maven-plugin&lt;/strong&gt;可以不用Dockerfile,纯粹通过pom.xml的配置自动生成Dockerfile来构建Docker镜像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dockerfile-maven&lt;/strong&gt;依赖Dockerfile文件，需放到项目根目录下，也就是和pom.xml同级。&lt;/p&gt;
&lt;p&gt;显然官方推荐的是 dockerfile-maven 这种依赖Dockerfile的方式,但是在部署 &lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;youlai-mall&lt;/a&gt; 项目使用 docker-maven-plugin 只要配置好 pom.xml 便无需修改外置配置了，所以更为方便省心，下面就这两种方式如何实现镜像构造进行逐一说明。其中统一以 &lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;youlai-mall&lt;/a&gt; 的 youlai-gateway 网关模块进行构建。&lt;/p&gt;
&lt;h3 id=&quot;2-docker-maven-plugin方式构造镜像&quot;&gt;2. docker-maven-plugin方式构造镜像&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;(1). 配置pom.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;plugin&amp;gt;
    &amp;lt;groupId&amp;gt;com.spotify&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;docker-maven-plugin&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0&amp;lt;/version&amp;gt;
    &amp;lt;executions&amp;gt;
        &amp;lt;!--执行mvn package,即执行 mvn clean package docker:build--&amp;gt;
        &amp;lt;execution&amp;gt;
            &amp;lt;id&amp;gt;build-image&amp;lt;/id&amp;gt;
            &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
            &amp;lt;goals&amp;gt;
                &amp;lt;goal&amp;gt;build&amp;lt;/goal&amp;gt;
            &amp;lt;/goals&amp;gt;
        &amp;lt;/execution&amp;gt;
    &amp;lt;/executions&amp;gt;

    &amp;lt;configuration&amp;gt;
        &amp;lt;!-- 镜像名称 --&amp;gt;
        &amp;lt;imageName&amp;gt;${project.artifactId}&amp;lt;/imageName&amp;gt;
        &amp;lt;!-- 指定标签 --&amp;gt;
        &amp;lt;imageTags&amp;gt;
            &amp;lt;imageTag&amp;gt;latest&amp;lt;/imageTag&amp;gt;
        &amp;lt;/imageTags&amp;gt;
        &amp;lt;!-- 基础镜像--&amp;gt;
        &amp;lt;baseImage&amp;gt;openjdk:8-jdk-alpine&amp;lt;/baseImage&amp;gt;

        &amp;lt;!-- 切换到容器工作目录--&amp;gt;
        &amp;lt;workdir&amp;gt;/ROOT&amp;lt;/workdir&amp;gt;

        &amp;lt;entryPoint&amp;gt;[&quot;java&quot;,&quot;-jar&quot;,&quot;${project.build.finalName}.jar&quot;]&amp;lt;/entryPoint&amp;gt;

        &amp;lt;!-- 指定远程 Docker API地址  --&amp;gt;
        &amp;lt;dockerHost&amp;gt;http://101.37.69.49:2375&amp;lt;/dockerHost&amp;gt;

        &amp;lt;!-- 复制 jar包到docker容器指定目录--&amp;gt;
        &amp;lt;resources&amp;gt;
            &amp;lt;resource&amp;gt;
                &amp;lt;targetPath&amp;gt;/ROOT&amp;lt;/targetPath&amp;gt;
                &amp;lt;!-- 用于指定需要复制的根目录，${project.build.directory}表示target目录 --&amp;gt;
                &amp;lt;directory&amp;gt;${project.build.directory}&amp;lt;/directory&amp;gt;
                &amp;lt;!-- 用于指定需要复制的文件，${project.build.finalName}.jar就是打包后的target目录下的jar包名称　--&amp;gt;
                &amp;lt;include&amp;gt;${project.build.finalName}.jar&amp;lt;/include&amp;gt;
            &amp;lt;/resource&amp;gt;
        &amp;lt;/resources&amp;gt;
    &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(2). maven打包制作镜像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目是聚合工程，先全局执行 &lt;code&gt;mvn install -DskipTests=true&lt;/code&gt; 完成安装模块jar包到本地仓库，不然模块之间的依赖会报错。&lt;/p&gt;
&lt;p&gt;切到文件夹 &lt;code&gt;youlai-gateway&lt;/code&gt; 执行项目的打包 &lt;code&gt;mvn package -DskipTests = true&lt;/code&gt;, 在 &lt;code&gt;package&lt;/code&gt; 生命周期完成镜像的生成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/05/VOkm4SJ6LMWl5oa.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3). idea创建和启动容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/05/hQ7KBXTAGf6FMpl.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/05/8SsoM3VpTJnjIOv.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4). 容器启动测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/05/7v1xZC9FHfAncUl.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-dockerfile-maven方式构造镜像&quot;&gt;3. dockerfile-maven方式构造镜像&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;(1). 创建Dockerfile&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照dockerfile-maven插件的使用说明，创建Dockerfile放置到项目根目录下(pom.xml同级)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/04/CjVMrqefbFi2G5v.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FROM openjdk:8-jdk-alpine
VOLUME /tmp
ARG JAR_FILE
ADD target/${JAR_FILE} /app.jar
EXPOSE 9999
ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dockerfile参考Spring官方，参考链接 &lt;a href=&quot;https://spring.io/guides/gs/spring-boot-docker/&quot;&gt;https://spring.io/guides/gs/spring-boot-docker/&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;FROM openjdk:8-jdk-alpine&lt;/td&gt;
&lt;td&gt;基础镜像JDK，无则自动拉取镜像&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;VOLUME /tmp&lt;/td&gt;
&lt;td&gt;挂载容器/tmp目录至宿主机，SpringBoot使用内置Tomcat，默认工作目录/tmp；VOLUME不能指定挂载目录，默认挂载到宿主机/var/lib/docker目录。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ARG JAR_FILE&lt;/td&gt;
&lt;td&gt;变量声明，对应pom.xml的JAR_FILE标签的变量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;ADD target/${JAR_FILE} /app.jar&lt;/td&gt;
&lt;td&gt;复制jar包至容器并重命名为app.jar&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;EXPOSE 9999&lt;/td&gt;
&lt;td&gt;声明容器暴露端口，仅仅声明无实际作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]&lt;/td&gt;
&lt;td&gt;设定容器启动时第一个运行的命令及其参数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;(2). 配置pom.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
    &amp;lt;dockerfile-maven-version&amp;gt;1.4.13&amp;lt;/dockerfile-maven-version&amp;gt;
&amp;lt;/properties&amp;gt;

&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
        &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;com.spotify&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dockerfile-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${dockerfile-maven-version}&amp;lt;/version&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;default&amp;lt;/id&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;build&amp;lt;/goal&amp;gt;
                        &amp;lt;goal&amp;gt;push&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;repository&amp;gt;${project.artifactId}&amp;lt;/repository&amp;gt;
                &amp;lt;tag&amp;gt;latest&amp;lt;/tag&amp;gt;
                &amp;lt;buildArgs&amp;gt;
                    &amp;lt;JAR_FILE&amp;gt;${project.build.finalName}.jar&amp;lt;/JAR_FILE&amp;gt;
                &amp;lt;/buildArgs&amp;gt;
            &amp;lt;/configuration&amp;gt;
        &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(3). 设置环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dockerfile-maven插件默认的DOCKER_HOST=localhost:2375,如果需要构建镜像到服务器，需要修改DOCKER_HOST系统环境变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/04/sLUBEPHbvgqxlAV.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果DOCKER_HOST不固定的也可以设置临时变量方便灵活切换&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set DOCKER_HOST=tcp://101.37.69.49:2375
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(4). idea创建和启动容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和 &lt;code&gt;docker-maven-plugin&lt;/code&gt; 一致，请参考上文。&lt;/p&gt;
&lt;h2 id=&quot;四-结语&quot;&gt;四. 结语&lt;/h2&gt;
&lt;p&gt;本文旨在使用IDEA搭配Docker插件快速构建Docker镜像实现一键部署SpringBoot项目，其中讲到两种方式，虽然 &lt;code&gt;docker-maven-plugin&lt;/code&gt; 已被官方抛弃，但是在我这里部署 &lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;youlai-mall&lt;/a&gt; 使用优于 &lt;code&gt;dockerfile-maven&lt;/code&gt; , 因为 &lt;code&gt;dockerfile-maven&lt;/code&gt; 除了配置 pom.xml 、编写 DockerFile 文件之外还要配置系统环境变量。如果你的服务器不只一台呢，环境变量如何处理，切来切去吗？所以这两种插件如何选择，真要看自己的使用场景，不能盲目的人云亦云。尤其会在下一篇介绍如何避免Docker远程2375端口暴露被挖矿做改动时更能体现 &lt;code&gt;docker-maven-plugin&lt;/code&gt;的优势。&lt;/p&gt;
&lt;p&gt;最后再推荐一下自己的开源项目 &lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;youlai-mall&lt;/a&gt;，前后端分离 + 微服务的一套完整的OAuth2统一认证鉴权全栈商城系统，有兴趣的朋友可以联系我，能让你有一个很不错的开源项目经验和能力提升的机会。微信号（haoxianrui）。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 04 Dec 2020 18:05:00 +0000</pubDate>
<dc:creator>你好，旧时光</dc:creator>
<og:description>一. 前言 大家在自己玩微服务项目的时候，动辄十几个服务，每次修改逐一部署繁琐不说也会浪费越来越多时间，所以本篇整理通过一次性配置实现一键部署微服务，实现真正所谓的一劳永逸。 二. 配置服务器 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haoxianrui/p/14088400.html</dc:identifier>
</item>
<item>
<title>3、Spring Cloud Rest工程创建(通过IDEA创建) - HOsystem</title>
<link>http://www.cnblogs.com/HOsystem/p/14057208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HOsystem/p/14057208.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;em&gt;&amp;lt;?&lt;/em&gt;&lt;strong&gt;xml version&lt;/strong&gt;&lt;strong&gt;=&quot;1.0&quot;&lt;/strong&gt; &lt;strong&gt;encoding&lt;/strong&gt;&lt;strong&gt;=&quot;UTF-8&quot;&lt;/strong&gt;&lt;em&gt;?&amp;gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;&lt;strong&gt;project&lt;/strong&gt; &lt;strong&gt;xmlns&lt;/strong&gt;&lt;strong&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;/strong&gt;&lt;strong&gt;xmlns:&lt;/strong&gt;&lt;strong&gt;xsi&lt;/strong&gt;&lt;strong&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;         &lt;/strong&gt;&lt;strong&gt;xsi&lt;/strong&gt;&lt;strong&gt;:schemaLocation&lt;/strong&gt;&lt;strong&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;&lt;strong&gt;modelVersion&lt;/strong&gt;&amp;gt;4.0.0&amp;lt;/&lt;strong&gt;modelVersion&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;com.hosystem&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;microservicecloud&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;1.0-SNAPSHOT&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;&lt;strong&gt;packaging&lt;/strong&gt;&amp;gt;pom&amp;lt;/&lt;strong&gt;packaging&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;&lt;strong&gt;properties&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &amp;lt;&lt;strong&gt;project.build.sourceEncoding&lt;/strong&gt;&amp;gt;UTF-8&amp;lt;/&lt;strong&gt;project.build.sourceEncoding&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &amp;lt;&lt;strong&gt;maven.compiler.source&lt;/strong&gt;&amp;gt;1.8&amp;lt;/&lt;strong&gt;maven.compiler.source&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &amp;lt;&lt;strong&gt;maven.compiler.target&lt;/strong&gt;&amp;gt;1.8&amp;lt;/&lt;strong&gt;maven.compiler.target&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &amp;lt;&lt;strong&gt;junit.version&lt;/strong&gt;&amp;gt;4.12&amp;lt;/&lt;strong&gt;junit.version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &amp;lt;&lt;strong&gt;log4j.version&lt;/strong&gt;&amp;gt;1.2.17&amp;lt;/&lt;strong&gt;log4j.version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &amp;lt;&lt;strong&gt;lombok.version&lt;/strong&gt;&amp;gt;1.16.18&amp;lt;/&lt;strong&gt;lombok.version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;/&lt;strong&gt;properties&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;&lt;strong&gt;dependencyManagement&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &amp;lt;&lt;strong&gt;dependencies&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;org.springframework.cloud&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;spring-cloud-dependencies&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;Dalston.SR1&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;type&lt;/strong&gt;&amp;gt;pom&amp;lt;/&lt;strong&gt;type&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;scope&lt;/strong&gt;&amp;gt;import&amp;lt;/&lt;strong&gt;scope&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;org.springframework.boot&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;spring-boot-dependencies&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;1.5.9.RELEASE&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;type&lt;/strong&gt;&amp;gt;pom&amp;lt;/&lt;strong&gt;type&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;scope&lt;/strong&gt;&amp;gt;import&amp;lt;/&lt;strong&gt;scope&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;mysql&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;mysql-connector-java&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;5.0.4&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;com.alibaba&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;druid&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;1.0.31&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;org.mybatis.spring.boot&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;mybatis-spring-boot-starter&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;1.3.0&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;ch.qos.logback&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;logback-core&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;1.2.3&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;junit&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;junit&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;${junit.version}&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;scope&lt;/strong&gt;&amp;gt;test&amp;lt;/&lt;strong&gt;scope&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;log4j&amp;lt;/&lt;strong&gt;groupId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;log4j&amp;lt;/&lt;strong&gt;artifactId&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                &amp;lt;&lt;strong&gt;version&lt;/strong&gt;&amp;gt;${log4j.version}&amp;lt;/&lt;strong&gt;version&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;            &amp;lt;/&lt;strong&gt;dependency&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &amp;lt;/&lt;strong&gt;dependencies&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &amp;lt;/&lt;strong&gt;dependencyManagement&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;/&lt;strong&gt;project&lt;/strong&gt;&amp;gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 Dec 2020 16:06:00 +0000</pubDate>
<dc:creator>HOsystem</dc:creator>
<og:description>1.Rest微服务构建简介 (1).介绍 以Dept部门模块做一个微服务通用案例Consumer消费者（Client）通过REST调用Provider提供者（Server）提供的服务。 (2).Myb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/HOsystem/p/14057208.html</dc:identifier>
</item>
<item>
<title>那些把公司当家的程序员，后来怎么样了？ - pointersss</title>
<link>http://www.cnblogs.com/pointers/p/14088264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pointers/p/14088264.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;成长&amp;amp;认知 丨 作者 / 袁吴范&lt;/p&gt;
&lt;p&gt;这是&lt;strong&gt;pointers&lt;/strong&gt;公众号的第26篇原创文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;家是什么？&lt;/p&gt;
&lt;p&gt;家是渴了有水喝，饿了有饭吃，冷了有衣穿。&lt;/p&gt;
&lt;p&gt;家是不管如何也会满心欢喜的期待着要回去的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一句话：此心安处是吾家。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个家庭都这么温馨吗？&lt;/p&gt;
&lt;p&gt;不见得，至少在公司这个大家庭中，并不是这样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;给大家讲一个故事&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你有一个温馨的家，家里每个人都各司其职，你的工作就是每天早上9到晚上9，一周6天，这样不停的熬出一锅热气腾腾的鸡汤。&lt;/p&gt;
&lt;p&gt;因为汤是给家庭所有成员享用，所以爸妈要求你熬出的汤要鲜醇味美。&lt;/p&gt;
&lt;p&gt;你最喜欢吃的是大饼，你从小就被爸妈告知，饼是世界上最好吃的东西，任何美食都没有大饼味美，而且富含营养。&lt;/p&gt;
&lt;p&gt;因此你养成了吃大饼的习惯，你每天都渴望吃饼。&lt;/p&gt;
&lt;p&gt;你拼命的熬汤，生怕有一天爸妈不给你吃大饼。&lt;/p&gt;
&lt;p&gt;你也很享受这种感觉，因为爸妈同样告诉你咱们家以后有钱了，就不需要你熬汤了，会招个保姆帮你熬汤。&lt;/p&gt;
&lt;p&gt;你深信不疑，就这样日子虽然过的平平淡淡，但保暖不愁，很是安逸。&lt;/p&gt;
&lt;p&gt;终于有一天，你的爸妈把你拉到他们身边，对你说“孩子，实在抱歉，你熬的鸡汤实在太难喝了，我和你爸爸商量了，觉得你，你最近熬鸡汤的表现越来越差，不是咸就是淡，不是烫的难以下咽就是苦得难以入口，你最好拿上几块大饼尽快离开这个家吧。”&lt;/p&gt;
&lt;p&gt;你听到这个噩耗，由于晴天霹雳，心里一万只草泥马在狂奔。&lt;/p&gt;
&lt;p&gt;不是当初说的好的，一个温馨有爱的大家庭吗？&lt;/p&gt;
&lt;p&gt;你感觉到委屈极了，愤怒和泪水淹没了你。&lt;/p&gt;
&lt;p&gt;你默默的收拾自己的衣物，心中有太多的无奈，但现实就是这么无情。&lt;/p&gt;
&lt;p&gt;你孤零零的站在路边，临走前深深看了眼这个曾被称作“家”的地方，看着飞驰的汽车，看到人行道的人来人往，深入到了前所未有的迷茫。&lt;/p&gt;
&lt;p&gt;曾经的家人，今天成了敌人。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;把公司当作家，到底有什么不好？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我相信上面的故事已经给出了答案。&lt;/p&gt;
&lt;p&gt;过去一年中，因为职位的关系，我有机会与所有的同事进行一对一交流，倾听他们的问题和顾虑，同时共同分享他们的成就和喜庆。&lt;/p&gt;
&lt;p&gt;然而，在这些对话中，我逐渐意识到一种不安。&lt;/p&gt;
&lt;p&gt;当我决定写下这篇文章的时候，我的内心其实是非常复杂和纠结的。&lt;/p&gt;
&lt;p&gt;毕竟，这样的想法与我们公司的文化似乎有点格格不入的感觉。&lt;/p&gt;
&lt;p&gt;公司就是公司，家庭就是家庭。&lt;strong&gt;工作可不是你家庭生活中的一部分。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，公司并不是你讨厌的地方；而家庭也不是唯一一个可以展现自己最真实一面的地方。&lt;/p&gt;
&lt;p&gt;一旦把这两个概念混为一谈，可能你的工作和家庭生活都会受到一定程度的影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么不能把公司当作家？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公司其存在的目的是追求利润&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果公司一直亏损，便会走向倒闭。公司要盈利、要发展，就要协调好各个部门之间的目标，以绩效为考核。&lt;/p&gt;
&lt;p&gt;如果员工在一番考核下来后发现其价值不符时，便说明该员工不合格，公司就会辞退他；&lt;/p&gt;
&lt;p&gt;如果该员工价值符合时，便说明该员工合格，公司便会考虑留下和提拔他，于是公司便不断出演着招人、裁人的景象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;家庭其存在的目的是安生&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个家庭不管是贫穷还是富有，日子还是要过下去的，总不能因为夫妻一方赚不到钱便离去，总不能因为孩子一时调皮将其丢弃。&lt;/p&gt;
&lt;p&gt;在公司里，公司和职员的关系是不断的在相互考核。&lt;/p&gt;
&lt;p&gt;一个职员可以从这家公司跳槽到另一家公司，公司也可以以一定的条件辞退职员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在公司与职员的关系里，都是有双向选择的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对职员来说，只有让公司离不开你，才有稳定性的说法；&lt;/p&gt;
&lt;p&gt;对公司来说，只有让职员的要求得到了满足，才能留住人才。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在家里，家庭成员关系是比较稳定的&lt;/strong&gt;，没有谁会频繁的去更换家庭。&lt;/p&gt;
&lt;p&gt;相比较公司而言，人与家庭的的关系是单向的，依附性高。&lt;/p&gt;
&lt;p&gt;正式因为这样很多多人在做抉择公司与家庭的时候，会偏向家庭多一点，工作没了可以再找，而家没了就很难再找一个了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以你不能抱有公司是我家的思想。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;公司的目的只有一个，就是盈利。&lt;/p&gt;
&lt;p&gt;不会因为你是来了多久之类的理由养着你，该裁掉你的时候还是裁掉你，公司不是慈善机构。&lt;/p&gt;
&lt;p&gt;只有在不断的提高自身能力，让公司觉得自己留在这里有价值才是安稳之道。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只有自己有实力了，公司才会成为你的家，不然即使步入不惑还是要去面临失业的困扰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我是袁吴范，程序员的职场导师，公众号：”pointers“；如有疑问，欢迎微信撩我：“pointersss” &lt;strong&gt;坑位有限，先到先得。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;推荐阅读（干货）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484114&amp;amp;idx=1&amp;amp;sn=8e7dc76fa54087cf0784ef13dc261078&amp;amp;chksm=cf2097c0f8571ed6de8272864698e35cf0c78183bceb109fe71ee450d077f72ba29e5ac819f2&amp;amp;scene=21#wechat_redirect&quot;&gt;7年，从“游戏少年”到大厂技术总监的逆袭之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484027&amp;amp;idx=1&amp;amp;sn=fb6fe35037e1693bf0f1c0a81d059bdc&amp;amp;chksm=cf209769f8571e7f311b5195d1f4c8fc1dc7f6905375bbdc6b0afbec0abc4775889b1012db7c&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员成为高级管理者的三次跃升&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484011&amp;amp;idx=1&amp;amp;sn=e52d915760314e3300c145039ede831b&amp;amp;chksm=cf209779f8571e6f81be5951b70607c2a2518fd0fc94c80c8f96c3331f82bdd6e07807179ce4&amp;amp;scene=21#wechat_redirect&quot;&gt;技术总监7年总结，如何进行正确的沟通？&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;从业7年。从软件开发、高级软件开发、技术经理再到技术总监，分享职业发展、技术管理、职场晋升、技术成长等个人多年经验和心得。一起成长！&lt;/p&gt;
&lt;p&gt;关注我↓↓，帮你答疑解惑！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4XQ0RVoHjpwwHPUKTfFPuXricWutdgzqDd8IhicA9rFr2MtXU3SaVfxfR9Y5sfhTib9Wq0kkU5bEZj6aSkAQC7zzA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 Dec 2020 15:44:00 +0000</pubDate>
<dc:creator>pointersss</dc:creator>
<og:description>成长&amp;amp;amp;认知 丨 作者 / 袁吴范 这是pointers公众号的第26篇原创文章 家是什么？ 家是渴了有水喝，饿了有饭吃，冷了有衣穿。 家是不管如何也会满心欢喜的期待着要回去的地方。 一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pointers/p/14088264.html</dc:identifier>
</item>
<item>
<title>傅里叶变换1.基本函数 - 哇哩顾得</title>
<link>http://www.cnblogs.com/robsann/p/14088223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/robsann/p/14088223.html</guid>
<description>&lt;p&gt;在信号与系统分析中，有两类函数特别重要,可以称之为构建傅里叶变化的基石(BuildingBlocks).本文主要讨论着这两类函数以及一些后续课程需要的知识&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;mi font-size-20&quot;&gt;1.第一类函数是三角函数信号(Sinusoidal Signals)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mi font-size-20&quot;&gt;&lt;span class=&quot;mi font-size-20&quot;&gt;x&lt;span class=&quot;mo font-size-20&quot;&gt;(&lt;span class=&quot;mi font-size-20&quot;&gt;t&lt;span class=&quot;mo font-size-20&quot;&gt;)&lt;span class=&quot;mo font-size-20&quot;&gt;=&lt;span class=&quot;mi font-size-20&quot;&gt;A&lt;span class=&quot;mi font-size-20&quot;&gt;c&lt;span class=&quot;mi font-size-20&quot;&gt;o&lt;span class=&quot;mi font-size-20&quot;&gt;s&lt;span class=&quot;mo font-size-20&quot;&gt;(&lt;span class=&quot;mi font-size-20&quot;&gt;ω&lt;span class=&quot;mi font-size-20&quot;&gt;t&lt;span class=&quot;mo font-size-20&quot;&gt;+&lt;span class=&quot;mi font-size-20&quot;&gt;θ&lt;span class=&quot;mo font-size-20&quot;&gt;).&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/a51da65a539f02c706e4b58e392ad6da9379e324.png&quot; width=&quot;851&quot; height=&quot;422&quot; data-size=&quot;30550&quot;/&gt;&lt;/p&gt;
&lt;p&gt;x(t)=Acos(ωt+θ)&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;mo font-size-20&quot;&gt;ω称之为角频率，含义是一秒转过多少弧度值(radians per second).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mo font-size-20&quot;&gt;分析:令t=0得到Acos(&lt;span class=&quot;mi font-size-20&quot;&gt;ω&lt;span class=&quot;mi font-size-20&quot;&gt;t&lt;span class=&quot;mo font-size-20&quot;&gt;+&lt;span class=&quot;mi font-size-20&quot;&gt;θ) = &lt;span class=&quot;font-size-20&quot;&gt;A&lt;span class=&quot;font-size-20&quot;&gt;cos&lt;span class=&quot;font-size-20&quot;&gt;(&lt;span class=&quot;mi font-size-20&quot;&gt;θ)&lt;span class=&quot;font-size-20&quot;&gt;, 令t=1 得到&lt;span class=&quot;font-size-20&quot;&gt;A&lt;span class=&quot;font-size-20&quot;&gt;cos&lt;span class=&quot;font-size-20&quot;&gt;(&lt;span class=&quot;mi font-size-20&quot;&gt;ω&lt;span class=&quot;mi font-size-20&quot;&gt;t&lt;span class=&quot;mo font-size-20&quot;&gt;+&lt;span class=&quot;mi font-size-20&quot;&gt;θ)&lt;span class=&quot;mi font-size-20&quot;&gt; = &lt;span class=&quot;font-size-20&quot;&gt;A&lt;span class=&quot;font-size-20&quot;&gt;cos(&lt;span class=&quot;mi font-size-20&quot;&gt;ω&lt;span class=&quot;mo font-size-20&quot;&gt;+&lt;span class=&quot;mi font-size-20&quot;&gt;θ). 所以在t=0到t=1的这1秒时间中，&lt;span class=&quot;font-size-20&quot;&gt;A&lt;span class=&quot;font-size-20&quot;&gt;cos(x)的弧度差为&lt;span class=&quot;mi font-size-20&quot;&gt;&lt;span class=&quot;font-size-20&quot;&gt;(&lt;span class=&quot;mi font-size-20&quot;&gt;ω&lt;span class=&quot;mo font-size-20&quot;&gt;+&lt;span class=&quot;mi font-size-20&quot;&gt;θ) - &lt;span class=&quot;font-size-20&quot;&gt;θ = w. 所以&lt;span class=&quot;font-size-20&quot;&gt;ω代表1秒转过弧度. &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mo font-size-20&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mo font-size-20&quot;&gt;f称为频率(frequency), f=&lt;span class=&quot;font-size-20&quot;&gt;ω/&lt;span class=&quot;font-size-20&quot;&gt;2&lt;span class=&quot;font-size-20&quot;&gt;π. f与&lt;span class=&quot;font-size-20&quot;&gt;ω的不同在于，f描述的是1秒转过多少圈(units of cycles per second),而&lt;span class=&quot;font-size-20&quot;&gt;ω描述的是一秒转过多少弧度.从下图可以知道,当&lt;span class=&quot;font-size-20&quot;&gt;ω从x轴迎着逆时针转过&lt;span class=&quot;font-size-20&quot;&gt;2&lt;span class=&quot;font-size-20&quot;&gt;π弧度，实际转过的圈数为1圈.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;mi font-size-20&quot;&gt;2.第二类函数是幂函数(Exponential Signals)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/860478fc4fba740d79b77cdb47eb532f5209d18d.png&quot; width=&quot;498&quot; height=&quot;61&quot; data-size=&quot;2787&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/4ae56a251dac87988e0d79febc080065d119e16d.png&quot; width=&quot;528&quot; height=&quot;471&quot; data-size=&quot;36731&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的 i 是虚数，引入了虚数，我们的坐标系从实数域变成了复数(complex number)域， 虚数(imaginery number)的定义是i² = - 1.在现实生活中，一个数的平方不可能为负1，所以虚数是一个自然界不存在的数字.但是通过引入虚数这个概念，可以使我们数学的计算带来方便。 &lt;/p&gt;
&lt;p&gt;由欧拉公式(Euler Formula)可以画出如下的复数图.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/c661c9799a699b2a9c3945d05c7028fb6eef5973.png&quot; width=&quot;309&quot; height=&quot;63&quot; data-size=&quot;3967&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/391ddd8e3f99dd9fd694b533acc0de2045bf5365.png&quot; width=&quot;702&quot; height=&quot;710&quot; data-size=&quot;34742&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分析：可见e^(i&lt;span class=&quot;font-size-16&quot;&gt;θ)是一个复数,实数部分为cos(θ), 虚数部分为sin(θ).&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于欧拉公式的理解与推导：&lt;/p&gt;
&lt;p&gt;根据 e^x 在0点的泰勒公式展开(泰勒公式就是对一个函数的模拟，泰勒公式的阶数越高即n越大，函数被还原的越准确)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/92461476e2241d70e40e8a0133f8ae6e421b8349.png&quot; width=&quot;876&quot; height=&quot;239&quot; data-size=&quot;30226&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据cos(x) 在0点的泰勒公式,以及sin(x)在0点的泰勒展开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/f53bca6a863cd87ed21ed7d9821d2634433a8216.png&quot; width=&quot;884&quot; height=&quot;263&quot; data-size=&quot;28547&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对比（1）和（2）我们发现e^(ix) = cos(x) + isin(x)，从此与欧拉公式风雨同路&lt;/p&gt;
&lt;p&gt;另外f(x) = e^(ix) 是一个以2pi为周期的函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/5695d48ff761405c74d850ca6955f59fe886c589.png&quot; width=&quot;603&quot; height=&quot;84&quot; data-size=&quot;7797&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;mi font-size-20&quot;&gt;3.基本信号(Exponential Signals)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;mi font-size-20&quot;&gt;3.1连续时间阶跃信号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;连续时间的阶跃信号(unit step)的定义如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/116dec2a7e39b003a63214c43bf2fe37cddc5086.png&quot; width=&quot;333&quot; height=&quot;80&quot; data-size=&quot;4014&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/cdb2a62e4cfc8f09bef6cba0aaec4ca7cd25d92f.png&quot; width=&quot;400&quot; height=&quot;399&quot; data-size=&quot;7665&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span class=&quot;mi font-size-20&quot;&gt;3.2连续时间的冲激信号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;连续时间的冲激信号(unit impluse)&lt;span class=&quot;mjx-mi&quot;&gt;δ&lt;span class=&quot;mjx-mo&quot;&gt;(&lt;span class=&quot;mjx-mi&quot;&gt;t&lt;span class=&quot;mjx-mo&quot;&gt;)的定义如下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/80ec926edb710b2b6194e07fd278d69c14ac7759.png&quot; width=&quot;266&quot; height=&quot;100&quot; data-size=&quot;6214&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mjx-mi&quot;&gt;δ&lt;span class=&quot;mjx-mo&quot;&gt;(&lt;span class=&quot;mjx-mi&quot;&gt;t&lt;span class=&quot;mjx-mo&quot;&gt;)可以看作是如下函数r(t)的在T-&amp;gt;趋向于0时候的导数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/4a1e9f843f5519b85d02e075eea2270177a3228e.png&quot; width=&quot;543&quot; height=&quot;405&quot; data-size=&quot;35536&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mjx-mo&quot;&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/1e964ace1c2d9ba994e20004f1f906032828fef8.png&quot; width=&quot;406&quot; height=&quot;68&quot; data-size=&quot;4470&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/2ce8b72de2b5bc66f231622f5036187fde8fa055.png&quot; width=&quot;527&quot; height=&quot;429&quot; data-size=&quot;10369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;mjx-mo&quot;&gt;  &lt;strong&gt;&lt;span class=&quot;mi font-size-20&quot;&gt;3.3 &lt;span class=&quot;mjx-mi&quot;&gt;离散时间阶跃信号&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;mjx-mi&quot;&gt;离散时间阶跃信号u[n]的定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/b688c3937127164f19df0f5fc3266b51bb7b3ef3.png&quot; width=&quot;535&quot; height=&quot;74&quot; data-size=&quot;4548&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/4113fc11ab9f9d4c85a25ca9b77f68a45db54976.png&quot; width=&quot;596&quot; height=&quot;476&quot; data-size=&quot;11801&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span class=&quot;mi font-size-20&quot;&gt;3.3 离散时间冲激信号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;离散时间冲激信号&lt;span class=&quot;mjx-mi&quot;&gt;δ[n]的定义如下:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/7477621a74772747872e7ae7509c5bbff8fc5420.png&quot; width=&quot;359&quot; height=&quot;85&quot; data-size=&quot;4336&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i0.hdslb.com/bfs/article/c3ca67ab24af815ecce0d66890ea2e0ccd028701.png&quot; width=&quot;591&quot; height=&quot;477&quot; data-size=&quot;10084&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; Thanks guy for wathcing, wish you have a good day &lt;/strong&gt;XD.&lt;/span&gt;&lt;br/&gt; &lt;/p&gt;

</description>
<pubDate>Fri, 04 Dec 2020 15:23:00 +0000</pubDate>
<dc:creator>哇哩顾得</dc:creator>
<og:description>在信号与系统分析中，有两类函数特别重要,可以称之为构建傅里叶变化的基石(BuildingBlocks).本文主要讨论着这两类函数以及一些后续课程需要的知识 1.第一类函数是三角函数信号(Sinusoi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/robsann/p/14088223.html</dc:identifier>
</item>
<item>
<title>自动化运维工具之Puppet模块 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14086315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14086315.html</guid>
<description>&lt;p&gt;　　前文我们了解来puppet的变量、流程控制、正则表达式、类和模板的相关话题，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14079208.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14079208.html&lt;/a&gt;；今天我们来了解下puppet中的模块相关概念；&lt;/p&gt;
&lt;p&gt;　　什么是模块？&lt;/p&gt;
&lt;p&gt;　　在puppet中模块的概念有点类似ansible中的角色；在puppet中模块就是把定义在一个资源清单中的各个资源拆分到不同的资源文件中，然后把对应的文件放在特定的目录中；简单讲puppet中的模块就是一个按约定的、预定义的结构存放了多个文件或子目录的目录，目录里的文件或子目录必须遵循某种命名规范；puppet会按照此种规范在特定位置查找模块所需文件，不过这些特定的目录可以通过puppet配置参数modulepath来指定；&lt;/p&gt;
&lt;p&gt;　　模块的目录结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201204153038455-643046959.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：MODULE NAME是模块的名称，模块名称必须是小写字母开头，可以包含小写字母，数字，下划线；不能将“main”，“setting”作为模块名称；manifests是用来存在当前模块的所有资源清单文件，每个资源清单文件中必须包含一个类或一个定义的类，但init.pp这个文件中只能包含一个单独的类定义，且类名必须同模块名相同；资源清单文件访问路径格式遵循MOUDLE_NAME::[SubDirectoryName::]ManifastFileName;这里需要注意一点访问资源清单文件，不需要加后缀.pp；files目录主要用来存放静态文件，这些静态文件可被节点下载使用，每个文件的访问遵循puppet://modules/MODULE_NAME/filename的路径格式；templates目录主要用来存放模版文件其访问路径遵循template('ModuleName/TemplateFileName')格式；lib目录主要用来存放自定义fact和自定义资源类型等；tests目录主要用来存放当前模块的使用帮助或使用范例文件；类似如何声明当前模块中的类以及定义的类型等；spec目录类似tests目录，不同tests目录的是，该目录主要存放lib中存放的自定义fact和资源类型的帮助或使用范例文件；一个模块中如果没有自定义fact或资源类型，后面的lib，tests，spec这三个目录可以不用创建；&lt;/p&gt;
&lt;p&gt;　　示例：将以下资源清单更改为模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# cat redis.pp 
class redis{
        package{&quot;redis&quot;:
                ensure  =&amp;gt; installed,
        }
        service{&quot;redis&quot;:
                ensure  =&amp;gt; running,
                enable  =&amp;gt; true,
                hasrestart      =&amp;gt; true,
                restart =&amp;gt; 'service redis restart',
        }
}
 
class redis::master($masterport='6379',$masterpass='admin') inherits redis {
        file{&quot;/etc/redis.conf&quot;:
                ensure  =&amp;gt; file,
                content =&amp;gt; template('/root/redis-master.conf.erb'),
                owner   =&amp;gt; 'redis',
                group   =&amp;gt; 'root',
                mode    =&amp;gt; '0644',
        }
        Service[&quot;redis&quot;]{
                subscribe       =&amp;gt; File[&quot;/etc/redis.conf&quot;],
                restart =&amp;gt; 'systemctl restart redis'
        }
}

class redis::slave($masterip,$masterport='6379',$masterpass='admin') inherits redis {
        file{&quot;/etc/redis.conf&quot;:
                ensure  =&amp;gt; file,
                content =&amp;gt; template('/root/redis-slave.conf.erb'),
                owner   =&amp;gt; 'redis',
                group   =&amp;gt; 'root',
                mode    =&amp;gt; '0644',
        }
        Service[&quot;redis&quot;]{
                subscribe       =&amp;gt; File[&quot;/etc/redis.conf&quot;],
                restart =&amp;gt; 'systemctl restart redis'
        }
}
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　创建目录结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# mkdir -p /etc/puppet/modules/redis/{manifests,files,templates,lib,tests,spec}
[root@slave03 ~]# tree /etc/puppet/modules/redis/
/etc/puppet/modules/redis/
├── files
├── lib
├── manifests
├── spec
├── templates
└── tests

6 directories, 0 files
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：puppet默认模块存放在/etc/puppet/modules或/usr/share/puppet/modules/目录下，可以通过puppet config print modulepath 命令查看；如果要修改其模块存放位置，可以使用puppet config set modulepath 'path/to/somewhere';&lt;/p&gt;
&lt;p&gt;　　移动模版文件到templates目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# mv redis-master.conf.erb redis-slave.conf.erb /etc/puppet/modules/redis/templates/
[root@slave03 ~]# ll /etc/puppet/modules/redis/templates/
total 8
-rw-r--r-- 1 root root 1247 Dec  4 16:20 redis-master.conf.erb
-rw-r--r-- 1 root root 1276 Dec  4 16:18 redis-slave.conf.erb
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在manifests目录下创建init.pp&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# cat /etc/puppet/modules/redis/manifests/init.pp
class redis{
        package{&quot;redis&quot;:
                ensure  =&amp;gt; installed,
        }
        service{&quot;redis&quot;:
                ensure  =&amp;gt; running,
                enable  =&amp;gt; true,
                hasrestart      =&amp;gt; true,
                restart =&amp;gt; 'service redis restart',
        }
}
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：通常这个init.pp这个文件主要用来定义基类；其他子类需要单独定一个文件；&lt;/p&gt;
&lt;p&gt;　　在manifests目下创建master.pp和slave.pp资源清单文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# cat /etc/puppet/modules/redis/manifests/master.pp
class redis::master($masterport='6379',$masterpass='admin') inherits redis {
        file{&quot;/etc/redis.conf&quot;:
                ensure  =&amp;gt; file,
                content =&amp;gt; template('redis/redis-master.conf.erb'),
                owner   =&amp;gt; 'redis',
                group   =&amp;gt; 'root',
                mode    =&amp;gt; '0644',
        }
        Service[&quot;redis&quot;]{
                subscribe       =&amp;gt; File[&quot;/etc/redis.conf&quot;],
                restart =&amp;gt; 'systemctl restart redis'
        }
}
[root@slave03 ~]# cat /etc/puppet/modules/redis/manifests/slave.pp
class redis::slave($masterip,$masterport='6379',$masterpass='admin') inherits redis {
        file{&quot;/etc/redis.conf&quot;:
                ensure  =&amp;gt; file,
                content =&amp;gt; template('redis/redis-slave.conf.erb'),
                owner   =&amp;gt; 'redis',
                group   =&amp;gt; 'root',
                mode    =&amp;gt; '0644',
        }
        Service[&quot;redis&quot;]{
                subscribe       =&amp;gt; File[&quot;/etc/redis.conf&quot;],
                restart =&amp;gt; 'systemctl restart redis'
        }
}
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：如果复制文件是一个模版需要将模版文件放在templates目录下，使用template内建函数访问时需要遵循template('ModuleName/TemplateFileName')的格式引用；如果是复制文件是一个普通文件（非模版格式文件）在对应的files目录要存在对应的文件；其次在用source属性指定访问文件时，需要使用puppet:///modules/ModuleName/filename的格式；&lt;/p&gt;
&lt;p&gt;　　最终redis模块目录结构&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# tree /etc/puppet/modules/redis/
/etc/puppet/modules/redis/
├── files
├── lib
├── manifests
│   ├── init.pp
│   ├── master.pp
│   └── slave.pp
├── spec
├── templates
│   ├── redis-master.conf.erb
│   └── redis-slave.conf.erb
└── tests

6 directories, 5 files
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看puppet现有的模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# puppet module list
/etc/puppet/modules
└── redis (???)
/usr/share/puppet/modules (no modules installed)
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到redis模块已经可以看到，其实我们在对应的模块存放路径下创建目录就可以看到对应的名称；后面的问号是因为我们自定义的模块没有写说明信息，它这里可能是没有获取到指定的信息，所以显示问号；但这不影响我们使用模块；&lt;/p&gt;
&lt;p&gt;　　单机模型下使用模块&lt;/p&gt;
&lt;p&gt;　　调用模块(调用基类)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# rpm -q redis
package redis is not installed
[root@slave03 ~]# ss -tnl
State      Recv-Q Send-Q                    Local Address:Port                                   Peer Address:Port              
LISTEN     0      128                                   *:22                                                *:*                  
LISTEN     0      100                           127.0.0.1:25                                                *:*                  
LISTEN     0      80                                 [::]:3306                                           [::]:*                  
LISTEN     0      128                                [::]:22                                             [::]:*                  
LISTEN     0      100                               [::1]:25                                             [::]:*                  
[root@slave03 ~]# puppet apply -v --noop -e 'include redis'
Notice: Compiled catalog for slave03 in environment production in 0.49 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1607074610'
Notice: /Stage[main]/Redis/Package[redis]/ensure: current_value absent, should be present (noop)
Notice: /Stage[main]/Redis/Service[redis]/ensure: current_value stopped, should be running (noop)
Info: /Stage[main]/Redis/Service[redis]: Unscheduling refresh on Service[redis]
Notice: Class[Redis]: Would have triggered 'refresh' from 2 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.29 seconds
[root@slave03 ~]# puppet apply -v -e 'include redis'
Notice: Compiled catalog for slave03 in environment production in 0.49 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1607074622'
Notice: /Stage[main]/Redis/Package[redis]/ensure: created
Notice: /Stage[main]/Redis/Service[redis]/ensure: ensure changed 'stopped' to 'running'
Info: /Stage[main]/Redis/Service[redis]: Unscheduling refresh on Service[redis]
Notice: Finished catalog run in 3.66 seconds
[root@slave03 ~]# rpm -q redis 
redis-3.2.12-2.el7.x86_64
[root@slave03 ~]# ss -tnl
State      Recv-Q Send-Q                    Local Address:Port                                   Peer Address:Port              
LISTEN     0      128                           127.0.0.1:6379                                              *:*                  
LISTEN     0      128                                   *:22                                                *:*                  
LISTEN     0      100                           127.0.0.1:25                                                *:*                  
LISTEN     0      80                                 [::]:3306                                           [::]:*                  
LISTEN     0      128                                [::]:22                                             [::]:*                  
LISTEN     0      100                               [::1]:25                                             [::]:*                  
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：单机模型下调用模块中的类，需要使用-e选项来声明类；以上信息可以看到redis安装好了，并以默认配置启动起来，监听在127.0.0.1的6379端口；这里只是调用了init.pp中的代码；&lt;/p&gt;
&lt;p&gt;　　调用子类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# puppet apply -v -e 'include redis::master'
Warning: Config file /etc/puppet/hiera.yaml not found, using Hiera defaults
Notice: Compiled catalog for slave03 in environment production in 0.63 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1607074812'
Info: FileBucket got a duplicate file {md5}d98629fded012cd2a25b9db0599a9251
Info: /Stage[main]/Redis::Master/File[/etc/redis.conf]: Filebucketed /etc/redis.conf to puppet with sum d98629fded012cd2a25b9db0599a9251
Notice: /Stage[main]/Redis::Master/File[/etc/redis.conf]/content: content changed '{md5}d98629fded012cd2a25b9db0599a9251' to '{md5}9bcaca33cf09d7cb0bb1beec2006a644'
Notice: /Stage[main]/Redis::Master/File[/etc/redis.conf]/mode: mode changed '0640' to '0644'
Info: /Stage[main]/Redis::Master/File[/etc/redis.conf]: Scheduling refresh of Service[redis]
Info: /Stage[main]/Redis::Master/File[/etc/redis.conf]: Scheduling refresh of Service[redis]
Notice: /Stage[main]/Redis/Service[redis]: Triggered 'refresh' from 2 events
Notice: Finished catalog run in 0.29 seconds
[root@slave03 ~]# ss -tnl
State      Recv-Q Send-Q                    Local Address:Port                                   Peer Address:Port              
LISTEN     0      128                                   *:6379                                              *:*                  
LISTEN     0      128                                   *:22                                                *:*                  
LISTEN     0      100                           127.0.0.1:25                                                *:*                  
LISTEN     0      80                                 [::]:3306                                           [::]:*                  
LISTEN     0      128                                [::]:22                                             [::]:*                  
LISTEN     0      100                               [::1]:25                                             [::]:*                  
[root@slave03 ~]# cat /etc/redis.conf 
bind 0.0.0.0
protected-mode yes
port 6379
tcp-backlog 511
timeout 0
tcp-keepalive 300
daemonize no
supervised no
pidfile /var/run/redis_6379.pid
loglevel notice
logfile /var/log/redis/redis.log
databases 16
requirepass admin
save 900 1
save 300 10
save 60 10000
stop-writes-on-bgsave-error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir /var/lib/redis
slave-serve-stale-data yes
slave-read-only yes
repl-diskless-sync no
repl-diskless-sync-delay 5
repl-disable-tcp-nodelay no
slave-priority 100
appendonly no
appendfilename &quot;appendonly.aof&quot;
appendfsync everysec
no-appendfsync-on-rewrite no
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
aof-load-truncated yes
lua-time-limit 5000
slowlog-log-slower-than 10000
slowlog-max-len 128
latency-monitor-threshold 0
notify-keyspace-events &quot;&quot;
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
list-max-ziplist-size -2
list-compress-depth 0
set-max-intset-entries 512
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
hll-sparse-max-bytes 3000
activerehashing yes
client-output-buffer-limit normal 0 0 0
client-output-buffer-limit slave 256mb 64mb 60
client-output-buffer-limit pubsub 32mb 8mb 60
hz 10
aof-rewrite-incremental-fsync yes
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到调用master子类，对应redis就监听在本机所有地址的6379端口上，并且在配置文件也变成了我们手动提供的配置文件，对应模版中的变量已经替换成变量默认值；&lt;/p&gt;
&lt;p&gt;　　redis-master.conf.erb模版文件内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_c874ad49-c44a-4f4a-b8d1-0b02edfc14f3&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_c874ad49-c44a-4f4a-b8d1-0b02edfc14f3&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c874ad49-c44a-4f4a-b8d1-0b02edfc14f3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
[root@slave03 ~]# cat /etc/puppet/modules/redis/templates/redis-&lt;span&gt;master.conf.erb 
bind &lt;/span&gt;&lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt;-&lt;span&gt;mode yes
port &lt;/span&gt;&amp;lt;%= @masterport %&amp;gt;&lt;span&gt;
tcp&lt;/span&gt;-backlog &lt;span&gt;511&lt;/span&gt;&lt;span&gt;
timeout &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
tcp&lt;/span&gt;-keepalive &lt;span&gt;300&lt;/span&gt;&lt;span&gt;
daemonize no
supervised no
pidfile &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/run/&lt;span&gt;redis_6379.pid
loglevel notice
logfile &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/log/redis/&lt;span&gt;redis.log
databases &lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
requirepass &lt;/span&gt;&amp;lt;%= @masterpass %&amp;gt;&lt;span&gt;
save &lt;/span&gt;&lt;span&gt;900&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
save &lt;/span&gt;&lt;span&gt;300&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;
save &lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
stop&lt;/span&gt;-writes-on-bgsave-&lt;span&gt;error yes
rdbcompression yes
rdbchecksum yes
dbfilename dump.rdb
dir &lt;/span&gt;/&lt;span&gt;var&lt;/span&gt;/lib/&lt;span&gt;redis
slave&lt;/span&gt;-serve-stale-&lt;span&gt;data yes
slave&lt;/span&gt;-read-&lt;span&gt;only yes
repl&lt;/span&gt;-diskless-&lt;span&gt;sync no
repl&lt;/span&gt;-diskless-sync-delay &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
repl&lt;/span&gt;-disable-tcp-&lt;span&gt;nodelay no
slave&lt;/span&gt;-priority &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
appendonly no
appendfilename &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appendonly.aof&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
appendfsync everysec
no&lt;/span&gt;-appendfsync-on-&lt;span&gt;rewrite no
auto&lt;/span&gt;-aof-rewrite-percentage &lt;span&gt;100&lt;/span&gt;&lt;span&gt;
auto&lt;/span&gt;-aof-rewrite-min-&lt;span&gt;size 64mb
aof&lt;/span&gt;-load-&lt;span&gt;truncated yes
lua&lt;/span&gt;-time-limit &lt;span&gt;5000&lt;/span&gt;&lt;span&gt;
slowlog&lt;/span&gt;-log-slower-than &lt;span&gt;10000&lt;/span&gt;&lt;span&gt;
slowlog&lt;/span&gt;-max-len &lt;span&gt;128&lt;/span&gt;&lt;span&gt;
latency&lt;/span&gt;-monitor-threshold &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
notify&lt;/span&gt;-keyspace-events &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
hash&lt;/span&gt;-max-ziplist-entries &lt;span&gt;512&lt;/span&gt;&lt;span&gt;
hash&lt;/span&gt;-max-ziplist-value &lt;span&gt;64&lt;/span&gt;&lt;span&gt;
list&lt;/span&gt;-max-ziplist-size -&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
list&lt;/span&gt;-compress-depth &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;set&lt;/span&gt;-max-intset-entries &lt;span&gt;512&lt;/span&gt;&lt;span&gt;
zset&lt;/span&gt;-max-ziplist-entries &lt;span&gt;128&lt;/span&gt;&lt;span&gt;
zset&lt;/span&gt;-max-ziplist-value &lt;span&gt;64&lt;/span&gt;&lt;span&gt;
hll&lt;/span&gt;-sparse-max-bytes &lt;span&gt;3000&lt;/span&gt;&lt;span&gt;
activerehashing yes
client&lt;/span&gt;-output-buffer-limit normal &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
client&lt;/span&gt;-output-buffer-limit slave 256mb 64mb &lt;span&gt;60&lt;/span&gt;&lt;span&gt;
client&lt;/span&gt;-output-buffer-limit pubsub 32mb 8mb &lt;span&gt;60&lt;/span&gt;&lt;span&gt;
hz &lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
aof&lt;/span&gt;-rewrite-incremental-&lt;span&gt;fsync yes
[root@slave03 &lt;/span&gt;~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　调用子类，并向子类中传递参数&lt;/p&gt;
&lt;p&gt;　　模版中需要传递的参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# grep -Ei ^&quot;slaveof|masterauth&quot; /etc/puppet/modules/redis/templates/redis-slave.conf.erb
slaveof &amp;lt;%= @masterip %&amp;gt; &amp;lt;%= @masterport %&amp;gt;
masterauth &amp;lt;%= @masterpass %&amp;gt;
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　声明slave子类，并应用对应的清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@slave03 ~]# puppet apply -v -e 'class{&quot;redis::slave&quot;: masterip  =&amp;gt; &quot;10.0.0.3&quot;}'
Warning: Config file /etc/puppet/hiera.yaml not found, using Hiera defaults
Notice: Compiled catalog for slave03 in environment production in 0.66 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1607075455'
Info: FileBucket got a duplicate file {md5}9bcaca33cf09d7cb0bb1beec2006a644
Info: /Stage[main]/Redis::Slave/File[/etc/redis.conf]: Filebucketed /etc/redis.conf to puppet with sum 9bcaca33cf09d7cb0bb1beec2006a644
Notice: /Stage[main]/Redis::Slave/File[/etc/redis.conf]/content: content changed '{md5}9bcaca33cf09d7cb0bb1beec2006a644' to '{md5}15f84c31c3f4582b526724da6ffd08d5'
Info: /Stage[main]/Redis::Slave/File[/etc/redis.conf]: Scheduling refresh of Service[redis]
Notice: /Stage[main]/Redis/Service[redis]: Triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.38 seconds
[root@slave03 ~]# ss -tnl
State      Recv-Q Send-Q                    Local Address:Port                                   Peer Address:Port              
LISTEN     0      128                                   *:6379                                              *:*                  
LISTEN     0      128                                   *:22                                                *:*                  
LISTEN     0      100                           127.0.0.1:25                                                *:*                  
LISTEN     0      80                                 [::]:3306                                           [::]:*                  
LISTEN     0      128                                [::]:22                                             [::]:*                  
LISTEN     0      100                               [::1]:25                                             [::]:*                  
[root@slave03 ~]# grep -Ei ^&quot;slaveof|masterauth&quot; /etc/redis.conf
slaveof 10.0.0.3 6379
masterauth admin
[root@slave03 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在slave.pp文件中masterport和masterpass这两个变量都有默认值，所以传递声明类可以只传递masterip这个变量的值即可；从上面的信息可以看到redis的配置文件中slaveof 的值就是我们传递的IP地址，对应端口和master密码都是使用的默认值；&lt;/p&gt;
</description>
<pubDate>Fri, 04 Dec 2020 15:22:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们了解来puppet的变量、流程控制、正则表达式、类和模板的相关话题，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/14079208.html；今天我们来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14086315.html</dc:identifier>
</item>
<item>
<title>对于Web开发最棒的22个Visual Studio Code插件 - 三分恶</title>
<link>http://www.cnblogs.com/three-fighter/p/14087956.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/three-fighter/p/14087956.html</guid>
<description>&lt;blockquote readability=&quot;2.5714285714286&quot;&gt;
&lt;p&gt;&lt;span&gt;翻译&lt;/span&gt;    原文作者：James Quick    原文地址：&lt;a href=&quot;https://scotch.io/bar-talk/22-best-visual-studio-code-extensions-for-web-development&quot;&gt;https://scotch.io/bar-talk/22-best-visual-studio-code-extensions-for-web-development&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;@&lt;/p&gt;

&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome&quot;&gt;https://marketplace.visualstudio.com/items?itemName=msjsdiag.debugger-for-chrome&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201130223146128.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信我，调试JavaScript不仅仅是写 console.log() （虽然这种方式应用最多）。Chrome内置了一些功能，可以拥有更好的调试体验。这个插件能让你在vs code里使用所有（或者几乎所有）这些调试功能。&lt;/p&gt;
&lt;p&gt;如果你想了解更多，你可以阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://scotch.io/tutorials/debugging-javascript-in-google-chrome-and-visual-studio-code&quot;&gt;Debugging JavaScript in Chrome and Visual Studio Code.&lt;/a&gt;&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets&quot;&gt;https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204210153632.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我喜欢Snippets插件。我觉得没有必要反复输入同一段代码。这个插件为你提供了流行的（ES6）JavaScript代码片段。&lt;/p&gt;
&lt;p&gt;注…如果你没有用es6javascript特性——赶紧用起来吧！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint&quot;&gt;https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204210624829.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;是否想编写更好的代码？ 是否需要整个团队使用一致的格式？ 安装ESLint。 这个插件可以配置为自动设置代码格式以及带有错误或警告的“yell（提示）”。 VS Code通过合适的配置，可以向你展示这些提示。&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer&quot;&gt;https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204210919210.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;在代码编辑器中进行更改，切换到浏览器，然后刷新以查看更改。 那是开发人员无休止的循环，但是如果你在进行更改时浏览器会自动刷新会怎样呢？ 这就是Live Server的用武之地！&lt;/p&gt;
&lt;p&gt;它还在本地服务器上运行你的应用程序。 有些事情只有在服务器里运行应用程序时才能测试，因此这也是个利好之处。&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer&quot;&gt;https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204211240698.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;括号阻止开发人员活着的祸害。 使用大量嵌套代码，几乎不可能确定哪些括号彼此匹配。 Bracket Pair Colorizor（如你所料）为括号匹配颜色，以使代码更具可读性。 相信我，你想要！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag&quot;&gt;https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204211509369.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是否需要重命名HTML中的元素？ 好了，使用“Auto Rename Tag”，你只需要重命名开始或结束标签，其他标签将自动重命名。 简单但有效！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode&quot;&gt;https://marketplace.visualstudio.com/items?itemName=WallabyJs.quokka-vscode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204211637701.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;需要一个快速的地方来测试一些JavaScript吗？ 我曾经习惯在Chrome中打开控制台，然后在其中输入一些代码，但缺点很多。 Quokka在VS Code中为你提供了一个JavaScript（和TypeScript）暂存器。 这意味着你可以在自己喜欢的编辑器中测试一段代码！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense&quot;&gt;https://marketplace.visualstudio.com/items?itemName=christian-kohler.path-intellisense&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204211823153.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在大型项目中，记住特定的文件名和文件所在的目录可能会很麻烦。 此插件将为你提供智能提示。 当你开始在引号中输入路径时，你将看到目录和文件名的智能提示。 这样可以避免你在文件浏览中花费大量时间：)&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager&quot;&gt;https://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204212104922.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我讨厌的一件事是在VS Code中的项目之间切换。 每次我必须打开文件资源管理器并在计算机上找到项目时。 但这随Project Manager 的应用而改变。 使用此插件，你可以在项目的侧边菜单中打开一个额外的菜单。 你可以在项目之间快速切换，保存收藏夹或从文件系统自动检测Git项目。&lt;/p&gt;
&lt;p&gt;如果你开发多个不同的项目，那么这是保持组织状态和提高效率的好方法。&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig&quot;&gt;https://marketplace.visualstudio.com/items?itemName=EditorConfig.EditorConfig&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204212515842.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Editor Config是少数几种编码样式的标准，在主要文本编辑器/ IDE中都得到支持。 运行方式如下如下。 你将配置文件保存在你的编辑器支持的存储库中。 在这种情况下，你必须为VS Code添加扩展名，以使其遵守这些配置文件。 设置起来超级容易，非常适合团队项目。&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-vscode.sublime-keybindings&quot;&gt;https://marketplace.visualstudio.com/items?itemName=ms-vscode.sublime-keybindings&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204212804781.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;你是Sublime的狂热用户，不愿意切换到VS Code吗？ 通过更改所有快捷方式以匹配Sublime的快捷方式，此扩展程序将使你切换得没有任何感知。 现在，你有什么理由不进行切换？&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=auchenberg.vscode-browser-preview&quot;&gt;https://marketplace.visualstudio.com/items?itemName=auchenberg.vscode-browser-preview&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204213030784.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我喜欢 Live Server extension 扩展（上文提到的），但就便利性而言，这个扩展更进一步。它为您提供了VS Code内部的实时重新加载预览。 无需再查看浏览器即可看到很小的变化！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens&quot;&gt;https://marketplace.visualstudio.com/items?itemName=eamodio.gitlens&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204213303590.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;git插件一大堆，但是其中一个功能最强大，最多。 您会得到有关警告的信息，行和文件的历史记录，提交搜索等等。 如果你需要有关Git工作流程的帮助，请从这个插件开始！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=pnp.polacode&quot;&gt;https://marketplace.visualstudio.com/items?itemName=pnp.polacode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204213523165.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;你知道你在博客和推特中看到的那些漂亮的代码截图吗？ 好吧，很可能它们来自Polacode。 使用起来超级简单。 将一段代码复制到剪贴板，打开扩展名，粘贴代码，然后单击保存图像！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode&quot;&gt;https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204213734658.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;不要花时间格式化代码...它做了。 前面，我提到了ESLint，它提供格式化和检查。 如果你不需要棉绒检查，那么选择Prettier。 它非常容易设置，可以配置为在保存时自动格式化代码。&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments&quot;&gt;https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204214017750.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此插件对各种类型的注释进行不同颜色标记，以赋予它们不同的含义，并在其余代码中突出。 我一直在用这个来做提示。 很难忽略一个橙色的大提示，告诉我我有一些未完成的工作要做。&lt;/p&gt;
&lt;p&gt;还有用于问题，警报和强调的颜色代码。 你也可以添加自己定义的！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=qezhu.gitlink&quot;&gt;https://marketplace.visualstudio.com/items?itemName=qezhu.gitlink&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204214242271.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你想在Github中查看正在处理的文件，则这个插件适合你。 安装后，只需右键单击文件，你将看到在Github中打开文件的选项。 如果你不使用Git Lens插件的话，这个插件对于检查历史记录，分支版本等非常好用。&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons&quot;&gt;https://marketplace.visualstudio.com/items?itemName=robertohuertasm.vscode-icons&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204214448438.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;你知道可以自定义VS Code中的图标吗？ 如果你查看设置，将会看到“文件图标主题”的选项。 从那里，你可以从预安装的图标中选择或安装图标包。 这个插件为你提供了一个非常可爱的图标包，已有1100万人使用！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme&quot;&gt;https://marketplace.visualstudio.com/items?itemName=PKief.material-icon-theme&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204214642285.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;你是Google Material 设计的粉丝吗？ 那么，检出这个“ Material主题”图标包。 有数百种不同的图标，它们看起来很棒！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync&quot;&gt;https://marketplace.visualstudio.com/items?itemName=Shan.code-settings-sync&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204214906916.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开发人员（包括我自己）花费大量时间自定义开发环境，尤其是文本编辑器。 使用“Settings Sync”插件，你可以在Github中保存设置。 然后，可以使用一个命令将它们加载到任何新版本的VS Code。&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=wwm.better-align&quot;&gt;https://marketplace.visualstudio.com/items?itemName=wwm.better-align&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204215059325.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如果你是那种喜欢代码中完美对齐的人，那么你需要Better Align。 你可以对齐多个变量声明，尾随注释，代码段等。没有比安装并尝试一下更好的办法来了解这个插件的过人之处了！&lt;/p&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=vscodevim.vim&quot;&gt;https://marketplace.visualstudio.com/items?itemName=vscodevim.vim&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201204215254745.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你是VIM深度用户吗？ 如果是的话，恭喜，你所掌握所有VIM骚操作，可以直接在VS Code中使用它。 我个人并不善于此道，但是我知道使用VIM发挥其潜力时会产生多么疯狂的生产力，从而为你提供更多的功能。&lt;/p&gt;

</description>
<pubDate>Fri, 04 Dec 2020 13:56:00 +0000</pubDate>
<dc:creator>三分恶</dc:creator>
<og:description>翻译 原文作者：James Quick 原文地址：https://scotch.io/bar-talk/22-best-visual-studio-code-extensions-for-web-de</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/three-fighter/p/14087956.html</dc:identifier>
</item>
<item>
<title>C++的编程指南 - DanielandCalf</title>
<link>http://www.cnblogs.com/zzw19940404/p/14087883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzw19940404/p/14087883.html</guid>
<description>&lt;p&gt;&lt;span&gt;每个&lt;/span&gt;C++/C&lt;span&gt;程序通常分为两个文件。一个文件用于保存程序的声明（&lt;/span&gt;&lt;span&gt;declaration&lt;/span&gt;&lt;span&gt;），称为头文件。另一个文件用于保存程序的实现（&lt;/span&gt;implementation），称为定义（definition）文件。&lt;/p&gt;
&lt;p&gt;C++/C&lt;span&gt;程序的头文件以“&lt;/span&gt;.h&lt;span&gt;”为后缀，&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;程序的定义文件以“&lt;/span&gt;.c”为后缀，&lt;span&gt;C++&lt;/span&gt;&lt;span&gt;程序的定义文件通常以“&lt;/span&gt;.cpp”为后缀（也有一些系统以“.cc”或“.cxx”为后缀）。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.1&lt;/strong&gt; &lt;strong&gt;版权和版本的声明&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;版权和版本的声明位于头文件和定义文件的开头（参见示例&lt;/span&gt;1-1），主要内容有：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）版权信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）文件名称，标识符，摘要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）当前版本号，作者&lt;/span&gt;/修改者，完成日期。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）版本历史信息。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;19&quot;&gt;
&lt;p&gt;/*&lt;/p&gt;
&lt;p&gt;* Copyright (c) 时间  公司&lt;/p&gt;
&lt;p&gt;* All rights reserved.&lt;/p&gt;
&lt;p&gt;* &lt;/p&gt;
&lt;p&gt;* 文件名称：&lt;em&gt;filename.h&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;* 文件标识：&lt;em&gt;见配置管理计划书&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;* 摘    要：&lt;em&gt;简要描述本文件的内容&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;p&gt;* 当前版本：&lt;em&gt;1.&lt;/em&gt;&lt;em&gt;1&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;* 作    者：&lt;em&gt;输入作者（或修改者）名字&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;* 完成日期：时间到日&lt;/p&gt;
&lt;p&gt;*&lt;/p&gt;
&lt;p&gt;* 取代版本：&lt;em&gt;1&lt;/em&gt;&lt;em&gt;.0&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;* 原作者  ：&lt;em&gt;输入原作者（或修改者）名字&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;* 完成日期：时间到日&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;示例1-1 版权和版本的声明&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;头文件的结构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;头文件由三部分内容组成：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）头文件开头处的版权和版本声明（参见示例&lt;/span&gt;1-1）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）预处理块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）函数和类结构声明等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设头文件名称为&lt;/span&gt; graphics.h，头文件的结构参&lt;span&gt;见示例&lt;/span&gt;1-2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【规则&lt;/strong&gt;&lt;strong&gt;1-2-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;&lt;span&gt;为了防止头文件被重复引用，应当用&lt;/span&gt;ifndef/define/endif&lt;span&gt;结构产生预处理块。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【规则&lt;/strong&gt;&lt;strong&gt;1-2-2&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;用 #include &amp;lt;filename.h&amp;gt; 格式来引用标准库的头文件（编译器将从标准库目录开始搜索）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【规则&lt;/strong&gt;&lt;strong&gt;1-2-3&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;用 #include “filename.h” 格式来引用非标准库的头文件（编译器将从用户的工作目录开始搜索）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【建议&lt;/strong&gt;&lt;strong&gt;1-2-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;&lt;span&gt;头文件中只存放&lt;/span&gt;“声明”而不存放“定义”&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;C++ &lt;span&gt;语法中，类的成员函数可以在声明的同时被定义，并且自动成为内联函数。这虽然会带来书写上的方便，但却造成了风格不一致，弊大于利。建议将成员函数的定义与声明分开，不论该函数体有多么小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【建议&lt;/strong&gt;&lt;strong&gt;1-2-2&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;不提倡使用全局变量，尽量不要在头文件中出现象extern int value &lt;span&gt;这类声明。&lt;/span&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;17&quot;&gt;
&lt;p&gt;// 版权和版本声明见示例1-1，此处省略。&lt;/p&gt;

&lt;p&gt;#ifndef GRAPHICS_H // 防止graphics.h被重复引用&lt;/p&gt;
&lt;p&gt;#define GRAPHICS_H&lt;/p&gt;
&lt;p&gt;//#ifndef GRAPHICS_H&lt;/p&gt;
&lt;p&gt;//#define GRAPHICS_H&lt;/p&gt;
&lt;p&gt;//#include&amp;lt;math.h&amp;gt;&lt;/p&gt;
&lt;p&gt;//#include”myheader.h”&lt;/p&gt;
&lt;p&gt;//Void Functionl()&lt;/p&gt;
&lt;p&gt;//Class Box&lt;/p&gt;
&lt;p&gt;#include &amp;lt;math.h&amp;gt; // 引用标准库的头文件&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;#include “myheader.h”  // 引用非标准库的头文件&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;void Function1(…); // 全局函数声明&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;class Box     // 类结构声明&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;#endif&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;&lt;span&gt;示例&lt;/span&gt;1-2 C++/C头文件的结构&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;定义文件的结构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;定义文件有三部分内容：&lt;/p&gt;
&lt;p&gt;（1） 定义文件开头处的版权和版本声明（参见示例1-1）。&lt;/p&gt;
&lt;p&gt;（2） 对一些头文件的引用。&lt;/p&gt;
&lt;p&gt;（3） 程序的实现体（包括数据和代码）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设定义文件的名称为&lt;/span&gt; graphics.cpp，定义文件的结构参&lt;span&gt;见示例&lt;/span&gt;1-3&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;13&quot;&gt;
&lt;p&gt;// 版权和版本声明见示例1-1，此处省略。&lt;/p&gt;

&lt;p&gt;#include “graphics.h” // 引用头文件&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;// 全局函数的实现体&lt;/p&gt;
&lt;p&gt;void Function1(…)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;// 类成员函数的实现体&lt;/p&gt;
&lt;p&gt;void Box::Draw(…)//void Box::Draw&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;&lt;span&gt;示例&lt;/span&gt;1-3 C++/C定义文件的结构&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;头文件的作用&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;早期的编程语言如&lt;/span&gt;Basic&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Fortran&lt;/span&gt;&lt;span&gt;没有头文件的概念，&lt;/span&gt;&lt;span&gt;C++/C&lt;/span&gt;&lt;span&gt;语言的初学者虽然会用使用头文件，但常常不明其理。这里对头文件的作用略作解释：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）通过头文件来调用库功能。在很多场合，源代码不便（或不准）向用户公布，只要向用户提供头文件和二进制的库即可。用户只需要按照头文件中的接口声明来调用库功能，而不必关心接口怎么实现的。编译器会从库中提取相应的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）头文件能加强类型安全检查。如果某个接口被实现或被使用时，其方式与头文件中的声明不一致，编译器就会指出错误，这一简单的规则能大大减轻程序员调试、改错的负担。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;目录结构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;如果一个软件的头文件数目比较多（如超过十个），通常应将头文件和定义文件分别保存于不同的目录，以便于维护。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如可将头文件保存于&lt;/span&gt;include&lt;span&gt;目录，将定义文件保存于&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;目录（可以是多级目录）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果某些头文件是私有的，它不会被用户的程序直接引用，则没有必要公开其&lt;/span&gt;“声明”。为了加强信息隐藏，这些私有的头文件可以和定义文件存放于同一个目录。&lt;/p&gt;

&lt;p&gt;版式虽然不会影响程序的功能，但会影响可读性。程序的版式追求清晰、美观，是程序风格的重要构成因素。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以把程序的版式比喻为&lt;/span&gt;“书法”。好的“书法”可让人对程序一目了然，看得兴致勃勃。差的程序“书法”如螃蟹爬行，让人看得索然无味，更令维护者烦恼有加。请程序员们学习程序的“书法”，弥补大学计算机教育的漏洞，实在很有必要。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;.1&lt;/strong&gt; &lt;strong&gt;空行&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;空行起着分隔程序段落的作用。空行得体（不过多也不过少）将使程序的布局更加清晰。空行不会浪费内存，虽然打印含有空行的程序是会多消耗一些纸张，但是值得。所以不要舍不得用空行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;在每个类声明之后、每个函数定义结束之后都要加空行。参见示例2-1（a）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;在一个函数体内，逻揖上密切相关的语句之间不加空行，其它地方应加空行分隔。参见示例2-1（b ）&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p&gt;// 空行&lt;/p&gt;
&lt;p&gt;void Function1(…)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  …&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// 空行&lt;/p&gt;
&lt;p&gt;void Function2(…)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  …&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// 空行&lt;/p&gt;
&lt;p&gt;void Function3(…)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  …&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;// 空行&lt;/p&gt;
&lt;p&gt;while (condition)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;statement1;&lt;/p&gt;
&lt;p&gt;// 空行&lt;/p&gt;
&lt;p&gt;if (condition)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;statement2;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;else&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;statement3;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// 空行&lt;/p&gt;
&lt;p&gt;statement4;&lt;/p&gt;
&lt;p&gt;}  &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　示例2-1(a) &lt;span&gt;函数之间的空行&lt;/span&gt;                   &lt;span&gt;示例&lt;/span&gt;2-1(b) 函数内部的空行&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;.2&lt;/strong&gt; &lt;strong&gt;代码行&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;一行代码只做一件事情，如只定义一个变量，或只写一条语句。这样的代码容易阅读，并且方便于写注释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;if、for、while、do等语句自占一行，执行语句不得紧跟其后。不论执行语句有多少都要加{}。这样可以防止书写失误。&lt;/p&gt;
&lt;p&gt;示例2-2（a）为风格良好的代码行，示例2-2（b）为风格不良的代码行。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;

&lt;p&gt;int width; // 宽度&lt;/p&gt;
&lt;p&gt;int height; // 高度&lt;/p&gt;
&lt;p&gt;int depth; // 深度&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;int width, height, depth; // 宽度高度深度&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p&gt;x = a + b;&lt;/p&gt;
&lt;p&gt;y = c + d;&lt;/p&gt;
&lt;p&gt;z = e + f;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;X ＝ a + b;   y = c + d;  z = e + f;&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p&gt;if (width &amp;lt; height)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;dosomething();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;if (width &amp;lt; height) dosomething();&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;for (initialization; condition; update)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;dosomething();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;// 空行&lt;/p&gt;
&lt;p&gt;other();&lt;/p&gt;

&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;for (initialization; condition; update)&lt;/p&gt;
&lt;p&gt;     dosomething();&lt;/p&gt;
&lt;p&gt;other();&lt;/p&gt;


&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　示例2-2(a) &lt;strong&gt;风格良好&lt;/strong&gt;&lt;span&gt;的代码行&lt;/span&gt;                 示例2-2(b) &lt;strong&gt;风格不良&lt;/strong&gt;的代码行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【建议&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;尽可能在定义变量的同时初始化该变量（就近原则）&lt;/p&gt;
&lt;p&gt;如果变量的引用处和其定义处相隔比较远，变量的初始化很容易被忘记。如果引用了未被初始化的变量，可能会导致程序错误。本建议可以减少隐患。例如&lt;/p&gt;
&lt;p&gt;int width = 10;  // 定义并初绐化width &lt;/p&gt;
&lt;p&gt;int height = 10; // 定义并初绐化height &lt;/p&gt;
&lt;p&gt;int depth = 10;  // 定义并初绐化depth &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;.3&lt;/strong&gt; &lt;strong&gt;代码行内的空格&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;关键字之后要留空格。象const、virtual、inline、case &lt;span&gt;等关键字之后至少要留一个空格，否则无法辨析关键字。象&lt;/span&gt;if、for、while&lt;span&gt;等关键字之后应留一个空格再跟左括号&lt;/span&gt;‘（’，以突出关键字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;2&lt;span&gt;】&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;函数名之后不要留空格，紧跟左括号&lt;/span&gt;‘（’，以与关键字区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;3&lt;span&gt;】&lt;/span&gt;&lt;/strong&gt;‘（’向后紧跟，‘）’、‘，’、‘;’向前紧跟，紧跟处不留空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;4&lt;span&gt;】&lt;/span&gt;&lt;/strong&gt;‘，’之后要留空格，如Function(x, y, z)&lt;span&gt;。如果&lt;/span&gt;‘;’不是一行的结束符号，其后要留空格，如for (initialization; condition; update)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;5&lt;span&gt;】&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;赋值操作符、比较操作符、算术操作符、逻辑操作符、位域操作符，如&lt;/span&gt;“&lt;span&gt;=&lt;/span&gt;&lt;span&gt;”、“&lt;/span&gt;&lt;span&gt;+=&lt;/span&gt;&lt;span&gt;” “&lt;/span&gt;&amp;gt;=”、“&amp;lt;=”、“&lt;span&gt;+&lt;/span&gt;&lt;span&gt;”、“&lt;/span&gt;*”、“&lt;span&gt;%&lt;/span&gt;&lt;span&gt;”、“&lt;/span&gt;&lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span&gt;”、“&lt;/span&gt;||”、“&lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;^&lt;/span&gt;&lt;span&gt;”等二元操作符的前后应当加空格。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;6&lt;span&gt;】&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;一元操作符如&lt;/span&gt;“!”、“~”、“++”、“--”、“&amp;amp;”（地址运算符）等前后不加空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;7&lt;span&gt;】&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;象&lt;/span&gt;“&lt;span&gt;［］&lt;/span&gt;”、“.”、“-&amp;gt;”这类操作符前后不加空格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【建议&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;1&lt;span&gt;】&lt;/span&gt;&lt;/strong&gt;对于表达式比较长的for语句和if语句，为了紧凑起见可以适当地去掉一些空格，如for (i=0; i&amp;lt;10; i++)和if ((a&amp;lt;=b) &amp;amp;&amp;amp; (c&amp;lt;=d))&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;void Func1(int x, int y, int z);          // 良好的风格&lt;/p&gt;
&lt;p&gt;void Func1 (int x,int y,int z);           // 不良的风格&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;if (year &amp;gt;= 2000)                         // 良好的风格&lt;/p&gt;
&lt;p&gt;if(year&amp;gt;=2000)                            // 不良的风格&lt;/p&gt;
&lt;p&gt;if ((a&amp;gt;=b) &amp;amp;&amp;amp; (c&amp;lt;=d))                     // 良好的风格&lt;/p&gt;
&lt;p&gt;if(a&amp;gt;=b&amp;amp;&amp;amp;c&amp;lt;=d)                            // 不良的风格&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;for (i=0; i&amp;lt;10; i++)                      // 良好的风格&lt;/p&gt;
&lt;p&gt;for(i=0;i&amp;lt;10;i++)                         // 不良的风格&lt;/p&gt;
&lt;p&gt;for (i = 0; I &amp;lt; 10; i ++)                 // 过多的空格&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;x = a &amp;lt; b ? a : b;                        // 良好的风格&lt;/p&gt;
&lt;p&gt;x=a&amp;lt;b?a:b;                                // 不好的风格&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;int *x = &amp;amp;y;                              // 良好的风格  &lt;/p&gt;
&lt;p&gt;int * x = &amp;amp; y;                            // 不良的风格  &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;array[5] = 0;                             // 不要写成 array [ 5 ] = 0;&lt;/p&gt;
&lt;p&gt;a.Function();                             // 不要写成 a . Function();&lt;/p&gt;
&lt;p&gt;b-&amp;gt;Function();                            // 不要写成 b -&amp;gt; Function();&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;示例2-3 代码行内的空格&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;对齐&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;&lt;span&gt;程序的分界符&lt;/span&gt;‘&lt;span&gt;{&lt;/span&gt;&lt;span&gt;’和‘&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;’应独占一行并且位于同一列，同时与引用它们的语句左对齐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;{ }&lt;span&gt;之内的代码块在&lt;/span&gt;‘&lt;span&gt;{&lt;/span&gt;&lt;span&gt;’右边数格处左对齐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;示例2-4&lt;span&gt;（&lt;/span&gt;a）为风格良好的对齐，示例2-4&lt;span&gt;（&lt;/span&gt;b）为风格不良的对齐。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;

&lt;p&gt;void Function(int x)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;

&lt;p&gt;void Function(int x){&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p&gt;if (condition)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;else&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;if (condition){&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;else {&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;for (initialization; condition; update)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;for (initialization; condition; update){&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;
&lt;p&gt;While (condition)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;while (condition){&lt;/p&gt;
&lt;p&gt;… // program code&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;如果出现嵌套的｛｝，则使用缩进对齐，如：&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;   …&lt;/p&gt;
&lt;p&gt; {&lt;/p&gt;
&lt;p&gt;   …&lt;/p&gt;
&lt;p&gt; }&lt;/p&gt;
&lt;p&gt;  …&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　示例2-4(a) &lt;strong&gt;风格良好&lt;/strong&gt;&lt;span&gt;的对齐&lt;/span&gt;                       &lt;span&gt;示例&lt;/span&gt;2-4(b) &lt;strong&gt;风格不良&lt;/strong&gt;的对齐&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;长行拆分&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;&lt;span&gt;代码行最大长度宜控制在&lt;/span&gt;70&lt;span&gt;至&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;个字符以内。代码行不要过长，否则眼睛看不过来，也不便于打印。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;长表达式要在低优先级操作符处拆分成新行，操作符放在新行之首（以便突出操作符）。拆分出的新行要进行适当的缩进，使排版整齐，语句可读。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;if ((very_longer_variable1 &amp;gt;= very_longer_variable12)&lt;/p&gt;
&lt;p&gt;&amp;amp;&amp;amp; (very_longer_variable3 &amp;lt;= very_longer_variable14)&lt;/p&gt;
&lt;p&gt;&amp;amp;&amp;amp; (very_longer_variable5 &amp;lt;= very_longer_variable16))&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;    dosomething();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;virtual CMatrix CMultiplyMatrix (CMatrix leftMatrix,&lt;/p&gt;
&lt;p&gt;                                 CMatrix rightMatrix);&lt;/p&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;567&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;for (very_longer_initialization;&lt;/p&gt;
&lt;p&gt; very_longer_condition;&lt;/p&gt;
&lt;p&gt; very_longer_update)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;dosomething();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;示例2-5 长行的拆分&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;修饰符的位置&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;修饰符 * &lt;span&gt;和 ＆ 应该靠近数据类型还是该靠近变量名，是个有争议的活题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;若将&lt;span&gt;修饰符&lt;/span&gt; * 靠近数据类型，例如：int*  x; &lt;span&gt;从语义上讲此写法比较直观，即&lt;/span&gt;x是int 类型的指针。&lt;/p&gt;
&lt;p&gt;上述写法的弊端是容易引起误解，例如：int*  x, y; 此处y容易被误解为指针变量。虽然将x和y分行定义可以避免误解，但并不是人人都愿意这样做。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;&lt;span&gt;应当将修饰符&lt;/span&gt; * &lt;span&gt;和 ＆ 紧靠变量名&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;char  *name;&lt;/p&gt;
&lt;p&gt;int   *x, y; // 此处y不会被误解为指针&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;注释&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;C&lt;span&gt;语言的注释符为&lt;/span&gt;“&lt;span&gt;/*&lt;/span&gt;…*/&lt;span&gt;”。&lt;/span&gt;C++&lt;span&gt;语言中，程序块的注释常采用&lt;/span&gt;“&lt;span&gt;/*&lt;/span&gt;…*/&lt;span&gt;”，行注释一般采用“&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;…”。注释通常用于：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）版本、版权声明；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）函数接口说明；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）重要的代码行或段落提示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然注释有助于理解代码，但注意不可过多地使用注释。参见示例2-6。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;-1&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;&lt;span&gt;注释是对代码的&lt;/span&gt;“提示”，而不是文档。程序中的注释不可喧宾夺主，注释太多了会让人眼花缭乱。注释的花样要少。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;-2&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;如果代码本来就是清楚的，则不必加注释。否则多此一举，令人厌烦。例如 &lt;/p&gt;
&lt;p&gt;i++; // i &lt;span&gt;加&lt;/span&gt; 1，多余的注释&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;-3&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;边写代码边注释，修改代码同时修改相应的注释，以保证注释与代码的一致性。不再有用的注释要删除。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;-4&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;注释应当准确、易懂，防止注释有二义性。错误的注释不但无益反而有害。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;-5&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;尽量避免在注释中使用缩写，特别是不常用缩写。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;-6&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;注释的位置应与被描述的代码相邻，可以放在代码的上方或右方，不可放在下方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【规则&lt;/span&gt;2&lt;/strong&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;strong&gt;-8&lt;/strong&gt;&lt;strong&gt;】&lt;/strong&gt;当代码比较长，特别是有多重嵌套时，应当在一些段落的结束处加注释，便于阅读。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;283&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;/*&lt;/p&gt;
&lt;p&gt;* 函数介绍：&lt;/p&gt;
&lt;p&gt;* 输入参数：&lt;/p&gt;
&lt;p&gt;* 输出参数：&lt;/p&gt;
&lt;p&gt;* 返回值  ：&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;
&lt;p&gt;void Function(float x, float y, float z)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  …&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;283&quot;&gt;

&lt;p&gt;if (…)&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  …&lt;/p&gt;
&lt;p&gt;  while (…)&lt;/p&gt;
&lt;p&gt;  {&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;} // end of while&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;} // end of if&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;示例2-6 程序的注释&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;类的版式&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;类可以将数据和函数封装在一起，其中函数表示了类的行为（或称服务）。类提供关键字public、protected和private，分别用于声明哪些数据和函数是公有的、受保护的或者是私有的。这样可以达到信息隐藏的目的，即让类仅仅公开必须要让外界知道的内容，而隐藏其它一切内容。我们不可以滥用类的封装功能，不要把它当成火锅，什么东西都往里扔。&lt;/p&gt;
&lt;p&gt;类的版式主要有两种方式：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）将&lt;/span&gt;private类型的数据写在前面，而将public类型的函数写在后面，如示例8-3（a&lt;span&gt;）。采用这种版式的程序员主张类的设计&lt;/span&gt;“以数据为中心”，重点关注类的内部结构。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）将&lt;/span&gt;public类型的函数写在前面，而将private类型的数据写在后面，如示例8.3&lt;span&gt;（&lt;/span&gt;b&lt;span&gt;）采用这种版式的程序员主张类的设计&lt;/span&gt;“以行为为中心”，重点关注的是类应该提供什么样的接口（或服务）。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很多&lt;/span&gt;C++&lt;span&gt;教课书受到&lt;/span&gt;Biarne Stroustrup&lt;span&gt;第一本著作的影响，不知不觉地采用了&lt;/span&gt;“以数据为中心”的书写方式，并不见得有多少道理。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我建议读者采用&lt;/span&gt;“以行为为中心”的书写方式，即首先考虑类应该提供什么样的函数。这是很多人的经验——“这样做不仅让自己在设计类时思路清晰，而且方便别人阅读。因为用户最关心的是接口，谁愿意先看到一堆私有数据成员！”&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;10&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;277&quot;&gt;
&lt;p&gt;class A&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  private:&lt;/p&gt;
&lt;p&gt;int    i, j;&lt;/p&gt;
&lt;p&gt;float  x, y;&lt;/p&gt;
&lt;p&gt;    …&lt;/p&gt;
&lt;p&gt;  public:&lt;/p&gt;
&lt;p&gt;void Func1(void);&lt;/p&gt;
&lt;p&gt;void Func2(void);&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;284&quot;&gt;
&lt;p&gt;class A&lt;/p&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;  public:&lt;/p&gt;
&lt;p&gt;void Func1(void);&lt;/p&gt;
&lt;p&gt;void Func2(void);&lt;/p&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;p&gt;  private:&lt;/p&gt;
&lt;p&gt;int    i, j;&lt;/p&gt;
&lt;p&gt;float  x, y;&lt;/p&gt;
&lt;p&gt;    …&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;center&quot;&gt;示例8.3(a) &lt;span&gt;以数据为中心版式&lt;/span&gt;              示例8.3(b) &lt;span&gt;以行为为中心的版式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;学习C++编程需要有耐心也是需要注意细节，多规范自己的写法，对自己的习惯有莫大的好处，要勤加练习。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;em&gt;&lt;em&gt;改变自己，从现在做起-----------久馆&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 04 Dec 2020 13:29:00 +0000</pubDate>
<dc:creator>DanielandCalf</dc:creator>
<og:description>序言：每天更新C++的内容 一、文件结构 每个C++/C程序通常分为两个文件。一个文件用于保存程序的声明（declaration），称为头文件。另一个文件用于保存程序的实现（implementatio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzw19940404/p/14087883.html</dc:identifier>
</item>
</channel>
</rss>