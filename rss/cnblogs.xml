<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Sping、SpringMVC、SpringBoot的对比 - 锅外的大佬</title>
<link>http://www.cnblogs.com/liululee/p/10925989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liululee/p/10925989.html</guid>
<description>&lt;p&gt;原文链接：https://dzone.com/articles/spring-boot-vs-spring-mvc-vs-spring-how-do-they-compare&lt;/p&gt;
&lt;p&gt;作者： Ranga Karanam&lt;/p&gt;
&lt;p&gt;译者：Yunooa&lt;/p&gt;
&lt;p&gt;推荐关注公众号： 锅外的大佬&lt;br/&gt;每日推送，专注分享国外最新技术内容，帮助每位开发者更优秀地成长&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201905/1692986-20190526143342504-1248192935.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在本文中，你将获取到有关于Spring，Spring MVC和Spring Boot的概述，了解他们解决的问题以及最佳的应用位置。最重要的是Spring，Spring MVC和Spring Boot不会矛盾。他们很好的解决了不同的问题。&lt;/p&gt;
&lt;h2 id=&quot;1-spring-&quot;&gt;1.Spring框架解决的核心问题是什么？&lt;/h2&gt;
&lt;p&gt;好好想想，Spring Framework解决了什么问题？&lt;/p&gt;

&lt;hr/&gt;

&lt;center readability=&quot;2&quot;&gt;&lt;br/&gt;Spring Framework最重要的特性是依赖注入&lt;p&gt;所有Spring模块的核心是依赖注入或IOC控制反转&lt;/p&gt;&lt;/center&gt;


&lt;hr/&gt;&lt;br/&gt;为什么这很重要？因为，当正确使用DI或IOC时，我们可以开发松耦合的应用程序。松耦合的应用程序可以很方便进行单元测试。

&lt;p&gt;举个简单的例子。&lt;/p&gt;
&lt;h2 id=&quot;2-&quot;&gt;2.没有依赖注入的示例&lt;/h2&gt;
&lt;p&gt;请考虑以下示例：&lt;code&gt;WelcomeController&lt;/code&gt;依赖于&lt;code&gt;WelcomeService&lt;/code&gt;来获取&lt;code&gt;欢迎&lt;/code&gt;消息。它是如何获取&lt;code&gt;WelcomeService&lt;/code&gt;实例的？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-java&quot;&gt;WelcomeService service = new WelcomeService();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它正在创建它的一个实例，这意味着他们紧密相连。例如：如果我在&lt;code&gt;WelcomeController&lt;/code&gt;的单元测试中为&lt;code&gt;WelcomeService&lt;/code&gt;创建一个模拟器，我如何使用模&lt;code&gt;mock&lt;/code&gt;创建&lt;code&gt;WelcomeController&lt;/code&gt;？没那么简单！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-java&quot;&gt;@RestController
public class WelcomeController {
    private WelcomeService service = new WelcomeService();
    @RequestMapping(&quot;/welcome&quot;)
    public String welcome() {
        return service.retrieveWelcomeMessage();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-&quot;&gt;3.相同的示例使用依赖注入&lt;/h2&gt;
&lt;p&gt;依赖注入使世界看起来更简单。&lt;code&gt;Spring Framework&lt;/code&gt;为你做了很多艰难的工作。我们只使用两个简单的注解：&lt;code&gt;@Component&lt;/code&gt;和&lt;code&gt;@Autowired&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;@Component&lt;/code&gt;告诉&lt;code&gt;Spring Framework&lt;/code&gt;：这是一个你需要管理的&lt;code&gt;bean&lt;/code&gt;。&lt;br/&gt;使用&lt;code&gt;@Autowired&lt;/code&gt;告诉&lt;code&gt;Spring Framework&lt;/code&gt;：找到这个特定类型的正确匹配并自动装配它。&lt;br/&gt;在下面的示例中，&lt;code&gt;Spring&lt;/code&gt;框架将为&lt;code&gt;WelcomeService&lt;/code&gt;创建一个&lt;code&gt;bean&lt;/code&gt;，并将其自动装入&lt;code&gt;WelcomeController&lt;/code&gt;。&lt;br/&gt;在单元测试中，我可以要求&lt;code&gt;Spring&lt;/code&gt;框架将&lt;code&gt;WelcomeService&lt;/code&gt;的模拟自动连接到&lt;code&gt;WelcomeController&lt;/code&gt;。（&lt;code&gt;Spring Boot&lt;/code&gt;使用&lt;code&gt;@MockBean&lt;/code&gt;可以很容易地做到这一点。但是，这是另外一件事了！）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-java&quot;&gt;@Component
public class WelcomeService {
    //Bla Bla Bla
}
@RestController
public class WelcomeController {
    @Autowired
    private WelcomeService service;
    @RequestMapping(&quot;/welcome&quot;)
    public String welcome() {
        return service.retrieveWelcomeMessage();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-spring-framework-&quot;&gt;3.Spring Framework还能解决什么问题？&lt;/h2&gt;
&lt;h3 id=&quot;3-2-1-&quot;&gt;3.2.问题1：减少样板代码&lt;/h3&gt;
&lt;p&gt;Spring Framework停止了依赖注入？不。许多Spring模块建立在依赖注入的核心概念之上：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring JDBC&lt;/li&gt;
&lt;li&gt;Spring MVC&lt;/li&gt;
&lt;li&gt;Spring AOP&lt;/li&gt;
&lt;li&gt;Spring ORM&lt;/li&gt;
&lt;li&gt;Spring JMS&lt;/li&gt;
&lt;li&gt;Spring Test&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;仔细想想&lt;code&gt;Spring JMS&lt;/code&gt;和&lt;code&gt;Spring JDBC&lt;/code&gt;。&lt;br/&gt;这些模块是否带来了任何新功能？并没有！我们可以使用&lt;code&gt;J2EE&lt;/code&gt;或&lt;code&gt;Java EE&lt;/code&gt;完成所有这些工作。那么，它们带来了什么？它们带来了简单的抽象。这些抽象的目的是为了：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;减少样版代码/减少重复&lt;/li&gt;
&lt;li&gt;促进解耦/增加单元可测试性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如，与传统的&lt;code&gt;JDBC&lt;/code&gt;或&lt;code&gt;JMS&lt;/code&gt;相比，使用&lt;code&gt;JDBCTemplate&lt;/code&gt;或&lt;code&gt;JMSTemplate&lt;/code&gt;所需的代码要少得多。&lt;/p&gt;
&lt;h3 id=&quot;3-2-2-&quot;&gt;3.2.问题2：与其他框架的良好集成&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Spring Framework&lt;/code&gt;的优点在于它不会尝试解决已经解决的问题。它所做的就是提供与框架的完美集成，从而提供出色的解决方案。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Hibernate for ORM&lt;/li&gt;
&lt;li&gt;iBatis for Object Mapping&lt;/li&gt;
&lt;li&gt;JUnit和Mockito进行单元测试&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;4-spring-mvc-&quot;&gt;4.Spring MVC框架解决的核心问题是什么？&lt;/h2&gt;

&lt;hr/&gt;

&lt;center&gt;&lt;br/&gt;Spring MVC Framewrok提供了开发Web应用程序的分离方式。使用Dispatcher Servlet,ModelAndView,View Resolver等概念，可以轻松开发Web应用程序&lt;/center&gt;

&lt;hr/&gt;&lt;h2 id=&quot;5-springboot-&quot;&gt;5.我们为什么需要springboot？&lt;/h2&gt;
&lt;p&gt;基于&lt;code&gt;Spring&lt;/code&gt;的应用程序有很多配置。当我们使用&lt;code&gt;Spring MVC&lt;/code&gt;时，我们需要配置组件扫描(&lt;code&gt;component scan&lt;/code&gt;)，&lt;code&gt;dispatcher servlet&lt;/code&gt;，视图解析器(&lt;code&gt;View Resolver&lt;/code&gt;)，&lt;code&gt;Web jar&lt;/code&gt;（用于提供静态内容）等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-java&quot;&gt;&amp;lt;bean
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
        &amp;lt;property name=&quot;prefix&quot;&amp;gt;
            &amp;lt;value&amp;gt;/WEB-INF/views/&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;suffix&quot;&amp;gt;
            &amp;lt;value&amp;gt;.jsp&amp;lt;/value&amp;gt;
        &amp;lt;/property&amp;gt;
  &amp;lt;/bean&amp;gt;
  &amp;lt;mvc:resources mapping=&quot;/webjars/**&quot; location=&quot;/webjars/&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的代码片段显示了&lt;code&gt;Web&lt;/code&gt;应用程序中调度程序&lt;code&gt;servlet&lt;/code&gt;的典型配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-java&quot;&gt;&amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;dispatcher&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;
            org.springframework.web.servlet.DispatcherServlet
        &amp;lt;/servlet-class&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;/WEB-INF/todo-servlet.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;dispatcher&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们使用&lt;code&gt;Hibernate/JPA&lt;/code&gt;时，我们需要配置数据源（datasource），实体管理器工厂(entity manager factory)，事务管理器(transaction manager)等众多其他事物。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-java&quot;&gt;&amp;lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;
        destroy-method=&quot;close&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClass&quot; value=&quot;${db.driver}&quot; /&amp;gt;
        &amp;lt;property name=&quot;jdbcUrl&quot; value=&quot;${db.url}&quot; /&amp;gt;
        &amp;lt;property name=&quot;user&quot; value=&quot;${db.username}&quot; /&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${db.password}&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;jdbc:initialize-database data-source=&quot;dataSource&quot;&amp;gt;
        &amp;lt;jdbc:script location=&quot;classpath:config/schema.sql&quot; /&amp;gt;
        &amp;lt;jdbc:script location=&quot;classpath:config/data.sql&quot; /&amp;gt;
    &amp;lt;/jdbc:initialize-database&amp;gt;
    &amp;lt;bean
        class=&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;
        id=&quot;entityManagerFactory&quot;&amp;gt;
        &amp;lt;property name=&quot;persistenceUnitName&quot; value=&quot;hsql_pu&quot; /&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;&amp;gt;
        &amp;lt;property name=&quot;entityManagerFactory&quot; ref=&quot;entityManagerFactory&quot; /&amp;gt;
        &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5-1-1-spring-boot-&quot;&gt;5.1.问题1：&lt;code&gt;Spring Boot&lt;/code&gt;自动配置：我们能有不同的想法吗？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt;带来了一个全新的思维过程:&lt;/p&gt;

&lt;hr/&gt;

&lt;center readability=&quot;2&quot;&gt;&lt;br/&gt;我们能在这方面思考更深入吗?&lt;p&gt;当&lt;code&gt;spring mvc jar&lt;/code&gt;被添加到应用程序中时，我们可以自动配置一些bean吗?&lt;/p&gt;&lt;/center&gt;


&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;Hibernate jar&lt;/code&gt;在&lt;code&gt;classpath&lt;/code&gt;上，自动配置数据源怎么样？&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;Spring MVC jar&lt;/code&gt;在&lt;code&gt;classpath&lt;/code&gt;上，那么自动配置&lt;code&gt;Dispatcher Servlet&lt;/code&gt;怎么样?&lt;br/&gt;这将有规定会覆盖默认的自动配置。&lt;br/&gt;&lt;hr/&gt;&lt;br/&gt;&lt;center&gt;&lt;br/&gt;Spring Boot查看应用的CLASSPATH已存在的配置，基于这些，SpringBoot提供应用程序中框架所需要的这些基本配置。这被称为自动装配（Auto Configuration）&lt;/center&gt;
&lt;hr/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;5-2-2-spring-boot-starter-&quot;&gt;5.2.问题2：&lt;code&gt;Spring Boot Starter&lt;/code&gt;项目：围绕众所周知的模式构建&lt;/h3&gt;
&lt;p&gt;假设我们想开发一个Web应用程序。&lt;/p&gt;
&lt;p&gt;首先，我们需要确定我们想要使用的框架，使用哪些框架版本以及如何将它们连接在一起。所有Web应用程序都有类似的需求。下面列出了我们在Spring MVC课程中使用的一些依赖项。这些包括&lt;code&gt;Spring MVC&lt;/code&gt;，&lt;code&gt;Jackson Databind&lt;/code&gt;（用于数据绑定），&lt;code&gt;Hibernate-Validator&lt;/code&gt;（用于使用&lt;code&gt;Java Validation API&lt;/code&gt;的服务器端验证）和&lt;code&gt;Log4j&lt;/code&gt;（用于日志记录）。在创建此课程时，我们必须选择所有这些框架的兼容版本。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-java&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;4.2.2.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.5.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.hibernate&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;hibernate-validator&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;5.0.2.Final&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是&lt;code&gt;Spring Boot&lt;/code&gt;文档中关于&lt;code&gt;starter&lt;/code&gt;的内容.&lt;/p&gt;

&lt;hr/&gt;

&lt;center readability=&quot;4&quot;&gt;&lt;br/&gt;&lt;code&gt;starter&lt;/code&gt;是一组方便的依赖关系描述符，你可以在应用程序中包含这些描述符。可以获得所需的所有Spring和相关技术的一站式服务，而无需搜索示例代码并复制粘贴依赖。&lt;p&gt;例如，如果你想使用Spring 和JPA进行数据库访问&lt;/p&gt;&lt;p&gt;只需在项目中包含spring-boot-starter-data-jpa依赖项就行了&lt;/p&gt;&lt;/center&gt;


&lt;hr/&gt;&lt;br/&gt;让我们考虑一个示例&lt;code&gt;starter&lt;/code&gt;：&lt;code&gt;Spring Boot Starter Web&lt;/code&gt;。

&lt;p&gt;如果您想开发Web应用程序或应用程序来公开&lt;code&gt;restful&lt;/code&gt;服务，&lt;code&gt;Spring Boot Start Web&lt;/code&gt;是首选。使用&lt;code&gt;Spring Initializr&lt;/code&gt;创建一个使用&lt;code&gt;Spring Boot Starter Web&lt;/code&gt;的快速项目。&lt;br/&gt;&lt;code&gt;Spring Boot Starter Web&lt;/code&gt;的依赖关系&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下截图显示了应用程序中不同依赖项:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1692986/201905/1692986-20190526143306898-1509304093.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;依赖关系可分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Spring：核心，bean，context，aop&lt;/li&gt;
&lt;li&gt;Web MVC :( Spring MVC）&lt;/li&gt;
&lt;li&gt;JackSon：用于JSON绑定&lt;/li&gt;
&lt;li&gt;Validation：Hibernate验证器，验证API&lt;/li&gt;
&lt;li&gt;嵌入式Servlet容器：Tomcat&lt;/li&gt;
&lt;li&gt;Logging：logback，slf4j&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;任何典型的Web应用程序都将使用所有这些依赖项。&lt;code&gt;Spring Boot Starter Web&lt;/code&gt;预装了这些。作为开发人员，我不需要担心这些依赖项或它们的兼容版本。&lt;/p&gt;
&lt;h2 id=&quot;6-spring-boot-starter-&quot;&gt;6.Spring Boot Starter项目选项&lt;/h2&gt;
&lt;p&gt;正如我们从&lt;code&gt;Spring Boot Starter Web&lt;/code&gt;中看到的那样，入门项目帮助我们快速开始开发特定类型的应用程序。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring-boot-starter-web-services：SOAP Web服务&lt;/li&gt;
&lt;li&gt;spring-boot-starter-web：Web和RESTful应用程序&lt;/li&gt;
&lt;li&gt;spring-boot-starter-test：单元测试和集成测试&lt;/li&gt;
&lt;li&gt;spring-boot-starter-jdbc：传统的JDBC&lt;/li&gt;
&lt;li&gt;spring-boot-starter-hateoas：为您的服务添加HATEOAS功能&lt;/li&gt;
&lt;li&gt;spring-boot-starter-security：使用Spring Security进行身份验证和授权&lt;/li&gt;
&lt;li&gt;spring-boot-starter-data-jpa：带有Hibernate的Spring Data JPA&lt;/li&gt;
&lt;li&gt;spring-boot-starter-cache：启用Spring Framework的缓存支持&lt;/li&gt;
&lt;li&gt;spring-boot-starter-data-rest：使用Spring Data REST公开简单REST服务&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;7-spring-boot-&quot;&gt;7.Spring Boot的其他目标&lt;/h2&gt;
&lt;p&gt;一些技术性的starter:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring-boot-starter-actuator：使用开箱即用的监控和跟踪等高级功能&lt;/li&gt;
&lt;li&gt;spring-boot-starter-undertow，spring-boot-starter-jetty，spring-boot- starter-tomcat：选择特定的嵌入式Servlet容器&lt;/li&gt;
&lt;li&gt;spring-boot-starter-logging：用于使用logback进行日志记录&lt;/li&gt;
&lt;li&gt;spring-boot-starter-log4j2：使用Log4j2进行日志记录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Spring Boot&lt;/code&gt;旨在快速实现生产就绪应用程序。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Actuator：启用高级监控和跟踪应用程序。&lt;/li&gt;
&lt;li&gt;嵌入式服务器集成：由于服务器已集成到应用程序中，因此我需要在服务器上安装单独的应用程序服务器。&lt;/li&gt;
&lt;li&gt;默认错误处理&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 26 May 2019 06:34:00 +0000</pubDate>
<dc:creator>锅外的大佬</dc:creator>
<og:description>原文链接：https://dzone.com/articles/spring-boot-vs-spring-mvc-vs-spring-how-do-they-compare 作者： Ranga Ka</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liululee/p/10925989.html</dc:identifier>
</item>
<item>
<title>Unity3D游戏开发之C#编程中常见数据结构的比较 - 黑色spider</title>
<link>http://www.cnblogs.com/spiderljx/p/10925992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spiderljx/p/10925992.html</guid>
<description>&lt;p&gt;一．前言  &lt;/p&gt;
&lt;p&gt;Unity3D是如今最火爆的游戏开发引擎，它可以让我们能轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型的互动内容。它支持2D/3D游戏开发，据不完全统计，目前国内80%的手机游戏都是用Unity3D开发。&lt;/p&gt;
&lt;p&gt;由于Unity3D在开发过程中使用最多的是C# 语言，所以就要合理的使用C#提供的一些数据结构是非常有必要的，合理的选择数据结构可以加快开发速度，提高游戏运行性能，不合理的使用数据结构则会导致游戏运行性能降低，加大开发复杂程度！&lt;/p&gt;
&lt;p&gt;先通过表格看看常用的数据结构：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;C#常用数据结构&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;中文名&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Array&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;普通数组&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;ArrayList&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;数组集合&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;List&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;泛型数组&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;LinkList&amp;lt;T&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;泛型链表&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Stack&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;栈&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Queue&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;队列&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;HashTable&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;哈希表&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;Dictionary&amp;lt;K,T&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;355&quot;&gt;
&lt;p align=&quot;center&quot;&gt;字典&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;然后先大概了解这些数据结构的用法。&lt;/p&gt;
&lt;p&gt;二．数据结构之间比较和部分使用案列&lt;/p&gt;
&lt;p&gt;1.数组（Array）在一般的编程中较为常见，是最简单的数据结构之一，具有三个特点：数组存储的数据都是在连续的内存单元上，数组中的元素都是同一类型,数组可通过下标直接访问。缺点是数组是连续存储，在两个元素之间插入新的元素时很不方便，在创建数组时必须指定长度或初始化元素，就会面临溢出或内存浪费的问题。2.ArrayList就可以解决Array带来的一些缺点：无需指定大小或初始化元素。可以动态的插入数据元素，无需考虑溢出或浪费内存的事。ArrayList可以存储不同数据类型的原因是由于把所有类型都当作Object类型来处理，使用时很有可能会发生类型不匹配的问题，这也就说明ArrayList是类型不安全的数据结构，在频繁的进行读写（装箱拆箱）操作ArrayList的过程中会产生额外的开销，导致性能下降，所以在开发过程中使用ArrayList较少！&lt;/p&gt;
&lt;p&gt;3.为了解决ArrayList不安全类型与装箱拆箱的缺点，List&amp;lt;T&amp;gt;作为一种新的数组类型引入，继承了ArrayList的一些优点，且确保了类型的安全，因无需进行装箱拆箱操作，因此List&amp;lt;T&amp;gt;是高性能的，所以List&amp;lt;T&amp;gt;在游戏开发过程中经常用到的数组类型。以下是List&amp;lt;T&amp;gt;的简单操作：&lt;/p&gt;
&lt;p&gt;List&amp;lt;string&amp;gt;  Lstr=new List&amp;lt;string&amp;gt;();&lt;/p&gt;
&lt;p&gt;Lstr.Add(“元素一”);   // 插入数据元素&lt;/p&gt;
&lt;p&gt;Lstr[0]=“元素二”;     // 修改数据元素&lt;/p&gt;
&lt;p&gt;Lstr.RemoveAt(0);       // 移除数据元素&lt;/p&gt;
&lt;p&gt;在Unity3D游戏开发中，我们可以使用List&amp;lt;GameObject&amp;gt;来存储游戏对象,比如在射击游戏中的子弹，或角色扮演游戏中的NPC，都可以使用List&amp;lt;GameObject&amp;gt;进行存储。&lt;/p&gt;
&lt;p&gt;4.LinkList&amp;lt;T&amp;gt;的特点是链中的每一个元素都指向下一个元素，这样救构成了一条链。在插入和删除某个数据元素时时间复杂度都为O（1）。&lt;/p&gt;
&lt;p&gt;5.Stack(栈)的特点是先进后出。&lt;/p&gt;
&lt;p&gt;6.Queue（队列）的特点是先进先出。&lt;/p&gt;
&lt;p&gt;7.我通过游戏开发中的用法来介绍哈希表的使用和它的一些特点。在游戏开发过程中，我们通常会涉及到通过游戏角色的ID来正确匹配英雄角色，所以每个英雄角色都要有自己唯一的ID，每个英雄角色的ID和他们的角色名进行一一对应，那么，我们就可以使用哈希表进行存储这种数据，假设有如下信息：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;序号&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;ID&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;角色名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2059&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;亚瑟&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;“2060”&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;妲己&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;“ABC”&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;后羿&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;2061.5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;237&quot;&gt;
&lt;p align=&quot;center&quot;&gt;宫本武藏&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用哈希表存储的代码如下：&lt;/p&gt;
&lt;p&gt;Hashtable Hero = new Hashtable ();&lt;/p&gt;
&lt;p&gt;         // Hero.Add (key,value);&lt;/p&gt;
&lt;p&gt;         Hero.Add (2059,&quot;亚瑟&quot;);        //插入第1个元素&lt;/p&gt;
&lt;p&gt;         Hero.Add (“2060”,&quot;妲己&quot;);        //插入第2个元素&lt;/p&gt;
&lt;p&gt;         Hero.Add (“ABC”,&quot;后羿&quot;);        //插入第3个元素&lt;/p&gt;
&lt;p&gt;         Hero.Add (2061.5,&quot;宫本武藏&quot;);    //插入第4个元素&lt;/p&gt;

&lt;p&gt;         //  通过key访问value&lt;/p&gt;
&lt;p&gt;         if (Hero.ContainsKey (“2060”)) {&lt;/p&gt;
&lt;p&gt;            Debug.Log (&quot;该队伍中包含妲己&quot;);&lt;/p&gt;
&lt;p&gt;         } else {&lt;/p&gt;
&lt;p&gt;          Debug.Log (&quot;该队伍中不包含妲己&quot;);&lt;/p&gt;
&lt;p&gt;         }&lt;/p&gt;
&lt;p&gt;通过以上的代码可以发现哈希表可以接收任意类型值作为key(key和value的类型都为object类型),其实这就体现出哈希表类型不安全。&lt;/p&gt;
&lt;p&gt;8.为了解决哈希表类型不安全，我们可以使用Dictionary&amp;lt;K,T&amp;gt;来存储数据，可以将上面的代码改写成下面代码：&lt;/p&gt;
&lt;p&gt;Dictionary&amp;lt;int ,string&amp;gt; Hero = new Dictionary&amp;lt;int, string&amp;gt; ();&lt;/p&gt;
&lt;p&gt;// Hero.Add (int key,string value);&lt;/p&gt;
&lt;p&gt;Hero.Add (2059,&quot;亚瑟&quot;);        //插入第1个元素&lt;/p&gt;
&lt;p&gt;Hero.Add (2060,&quot;妲己&quot;);        //插入第2个元素&lt;/p&gt;
&lt;p&gt;Hero.Add (2061,&quot;后羿&quot;);        //插入第3个元素&lt;/p&gt;
&lt;p&gt;Hero.Add (2062,&quot;宫本武藏&quot;);    //插入第4个元素&lt;/p&gt;
&lt;p&gt;//  通过 key（int）访问value(string)&lt;/p&gt;
&lt;p&gt;if (Hero.ContainsKey (2061)) {&lt;/p&gt;
&lt;p&gt;      Debug.Log (&quot;该队伍中包含后羿&quot;);&lt;/p&gt;
&lt;p&gt;} else {&lt;/p&gt;
&lt;p&gt;      Debug.Log (&quot;该队伍中不包含后羿&quot;);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;对比哈希表，字典保证了类型的安全，但世界上并不存在十全十美的东西，代码也是如此，字典通过空间换时间，通过更多的内存开销来满足对速度的追求。在创建字典时，可以传入一个字典容量值，但在实际使用时并非该值，而是使用不小于该值的最小质数最为它的实际容量，所以字典容量的最小值是3。且当有了实际容量后，并非直接实现索引，而是通过创建了两个额外的Array数组来实现间接的索引。面临的情况就是，即便创建了一个空的字典，伴随而来的是两个长度为3的数组。所以当处理的数据不多时，慎重使用字典。&lt;/p&gt;
&lt;p&gt;三．总结&lt;/p&gt;
&lt;p&gt;     在游戏开发过程中，很多情况下使用普通数组也是可以的，数据结构的选取需要考虑数据的大小和使用场景才能合理的存储和处理该数据。优秀的程序员需要考虑机器运行的性能，合理的选择一些数据结构可以提高程序运行性能和降低开发复杂度。&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 06:34:00 +0000</pubDate>
<dc:creator>黑色spider</dc:creator>
<og:description>一．前言 Unity3D是如今最火爆的游戏开发引擎，它可以让我们能轻松创建诸如三维视频游戏、建筑可视化、实时三维动画等类型的互动内容。它支持2D/3D游戏开发，据不完全统计，目前国内80%的手机游戏都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/spiderljx/p/10925992.html</dc:identifier>
</item>
<item>
<title>【WEB基础】HTML &amp; CSS 基础入门（7）表格 - 青衫烟雨客</title>
<link>http://www.cnblogs.com/nnzhang/p/10925846.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnzhang/p/10925846.html</guid>
<description>&lt;h2&gt;表格的基本结构&lt;/h2&gt;
&lt;p&gt;表格是网页上最常见的元素，它除了可以用来展示数据，还常常被用来排版。虽然现在提倡使用DIV+CSS完成页面布局，但表格框架简单明了，对于繁杂的数据，一个简洁的表格能让其展现的极有条理。&lt;/p&gt;
&lt;p&gt;简单来说，表格是由行、列（单元格）组成。表格由 &amp;lt;table&amp;gt; 标签来定义。每个表格均有若干行（由 &amp;lt;tr&amp;gt; 标签定义），每行又由若干单元格（即列，由 &amp;lt;td&amp;gt; 标签定义）组成。表格单元格里可以包含文本、图片、列表、段落、表单、水平线、表格（嵌套）等等。&lt;/p&gt;
&lt;p&gt;别罗嗦，看代码。&lt;/p&gt;
&lt;p&gt;下面的代码是一个两行两列的表格。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格开始&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;        
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格第一行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第一行第一个单元格&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;张三&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第一行第二个单元格&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格第二行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;民族&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第二行第一个单元格&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;汉族&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第二行第二个单元格&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格结束&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表格默认是没有边框的，下面的效果图加入了边框，目的是能让表格的结构更清晰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190526134539565-2037403449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;表格的标准结构&lt;/h2&gt;
&lt;p&gt;表格除了行&amp;lt;tr&amp;gt;和单元格&amp;lt;td&amp;gt;，还可以有标题&amp;lt;caption&amp;gt;和表头&amp;lt;th&amp;gt;。另外，表格的语义化还将表格分为表格页眉&amp;lt;thead&amp;gt;、表格主体&amp;lt;tbody&amp;gt;、表格页脚&amp;lt;tfoot&amp;gt;三个部分。引入语义化，能够让表格结构更清晰、代码语义更良好。&lt;/p&gt;
&lt;p&gt;下面的示例代码加入了标题和表头，同时引入了表格语义化，将表格分为页眉、主体。页脚三个部分，表格语义化是否添加不会影响到表格的显示效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格开始&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;        
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;caption&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;第一学期学生成绩表&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;caption&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格标题&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格页眉&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第一行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表头&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;语文&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;数学&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;物理&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;th&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;thead&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格主体&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第二行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;张小明&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;90&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第三行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;王小花&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;90&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;70&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tbody&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tfoot&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格页脚&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第四行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;平均分&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;85&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;80&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tfoot&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;表格结束&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表格默认是没有边框的，下面的效果图加入了边框，目的是能让表格的结构更清晰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190526134651648-672042952.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;表格的行、列合并&lt;/h2&gt;
&lt;p&gt;在表格的实际应用中，经常需要将表格相邻的两个或多个单元格合并，以满足不同长度或不同类型的数据展示。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;td&amp;gt;标签的【rowspan】属性可以实现合并行，&amp;lt;td rowspan=&quot;合并的行数&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&amp;lt;td&amp;gt;标签的【colspan】属性可以实现合并列，&amp;lt;td colspan=&quot;合并的列数&quot;&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;Content-Type&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;text/html; charset=utf-8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置图片的宽和高，防止将表格撑变形&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        img &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;76px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;82px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第1行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;姓名:&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;小叮当&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;下面是合并两行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;rowspan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;小叮当.jpg&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第2行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;作品:&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;哆啦A梦&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;第3行&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;简介:&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;下面是合并两列&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td &lt;/span&gt;&lt;span&gt;colspan&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;来自一部漫画作品&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;表格默认是没有边框的，下面的效果图加入了边框，目的是能让表格的结构更清晰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190526134806387-36561977.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;表格的CSS样式&lt;/h2&gt;
&lt;p&gt;表格默认是没有边框的，我们可以使用border属性为table设置边框。上面的代码都是加入边框，可以看到，表格都是双线条边框，这是由于 table、th 以及 td 元素都有独立的边框。【border-collapse】属性可以设置是否把表格边框合并为单一的边框，该属性的取值主要有两个，值【separate】为默认值，表示边框分开不合并，值【collapse】为合并边框。&lt;/p&gt;
&lt;p&gt;当表格的边框属性【border-collapse】的值为默认值【separate】，即边框分开时，我们还可以利用属性【border-spacing】来设置相邻单元格的边框间的距离。该属性可以设置一个或两个像素值，当设置一个像素值时，表示水平和垂直间隔为同一值；如果设置了两个值，则第一个为水平间距，第二个为垂直间距。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html &lt;/span&gt;&lt;span&gt;lang&lt;/span&gt;&lt;span&gt;=&quot;en&quot;&lt;/span&gt;&lt;span&gt; xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/css&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;为表格设置边框样式&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        table,th,td&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;1px solid red&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        table.one 
        &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置第一个表格为合并边框&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            border-collapse&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; collapse&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
        &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
        table.two
        &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;设置第二个表格为分离边框，同时设置水平间距10px，垂直间距50px&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            border-collapse&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; separate&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            border-spacing&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px 30px
        &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;one&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单元格1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单元格2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单元格1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单元格2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;br &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;table &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;two&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单元格1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单元格2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单元格1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;单元格2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;td&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tr&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;table&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617698/201905/1617698-20190526134905987-1906951718.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em&gt;------------------&lt;/em&gt;-------- &lt;/span&gt;END &lt;em&gt;------------------&lt;/em&gt;--------&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 05:53:00 +0000</pubDate>
<dc:creator>青衫烟雨客</dc:creator>
<og:description>表格的基本结构 表格是网页上最常见的元素，它除了可以用来展示数据，还常常被用来排版。虽然现在提倡使用DIV+CSS完成页面布局，但表格框架简单明了，对于繁杂的数据，一个简洁的表格能让其展现的极有条理。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nnzhang/p/10925846.html</dc:identifier>
</item>
<item>
<title>程序员，选择和努力哪个重要？ - owenandhisfriends</title>
<link>http://www.cnblogs.com/owenandhisfriends/p/10925755.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/owenandhisfriends/p/10925755.html</guid>
<description>&lt;p&gt;从年初到现在面试了近百人。面试中发现，有的同学还应该再努力些再换工作；而有的同学已经很努力了，做的很好，但没有选择好，去了不适合自己的公司。&lt;/p&gt;
&lt;p&gt;能力好，又选择了好公司好岗位的，还真是不多。&lt;/p&gt;
&lt;p&gt;如何才能选到好公司好岗位呢？到底选择和努力哪个更重要呢？&lt;/p&gt;
&lt;h2 id=&quot;选择&quot;&gt;选择&lt;/h2&gt;
&lt;p&gt;这里说的选择，是说程序员如何选择一个好工作。&lt;/p&gt;
&lt;p&gt;要做到的是选择好行业、公司、和岗位，三者层层递进。&lt;/p&gt;
&lt;h3 id=&quot;行业&quot;&gt;行业&lt;/h3&gt;
&lt;p&gt;选行业就是要选择大环境。就像90年代的通信行业，2000年之后的互联网行业，金融行业。这些行业的发展速度快，短期内能够聚集大量的资金。所在行业的公司市值要比其他行业的高。当然这些行业的从业者待遇也会更好。&lt;/p&gt;
&lt;p&gt;行业决定了整体发展的大势，要顺势而为。如果行业的发展已经到了天花板，或稳定期，那么同样的努力，效果也不如发展期的行业。&lt;/p&gt;
&lt;p&gt;有些行业即使现在待遇高，但是未来如何，是否适合程序员发展，也要综合考量。&lt;/p&gt;
&lt;p&gt;例如有些房地产公司也有专门的研发岗位，是否在这个行业一直做软件开发有发展，要综合考量下。&lt;/p&gt;
&lt;h3 id=&quot;公司&quot;&gt;公司&lt;/h3&gt;
&lt;p&gt;即使是相同的行业，其中不同的公司之间，差别也比较大。选公司也要选有前景，靠谱的公司。&lt;/p&gt;
&lt;p&gt;大多数人容易犯的一个错误，只看薪资。可能只差几千块，就选择了工资高的公司。&lt;/p&gt;
&lt;p&gt;不是不看薪资，而是不能只看薪资，要从多维度查看。&lt;/p&gt;
&lt;p&gt;公司是否在扩张期，是否是一个有前景的公司。未来是否会成为行业龙头。&lt;/p&gt;
&lt;p&gt;公司的企业文化和自己是否吻合。&lt;/p&gt;
&lt;p&gt;公司环境怎么样，公司工作几年后，是否可以实现自己的目标。&lt;/p&gt;
&lt;p&gt;看人，公司的人是否靠谱。和一群靠谱的人工作，结果肯定不会差。&lt;/p&gt;
&lt;h3 id=&quot;位置&quot;&gt;位置&lt;/h3&gt;
&lt;p&gt;两个公司差不多，待遇差不多，去哪家公司呢？&lt;/p&gt;
&lt;p&gt;不要只看做的产品，或者部门的重要性。要看你去的位置。是否有牛人能够带你等。去了会在什么位置，是否有足够的空间供你发挥。&lt;/p&gt;
&lt;p&gt;就像宰相蔡京家里的厨娘，什么菜都不用做，只需要剥葱。&lt;/p&gt;
&lt;p&gt;职业生涯是不断发展的，要从长远看，不要只看眼前，要设想从未来往回看。再过些年，你的技能实力会提高吗，会变得更值钱吗？&lt;/p&gt;
&lt;p&gt;上面说的都是选择参考的一些纬度，但本质还是要自身有明确的目标，知道你想要什么？否则你不知道什么是好，什么是不好。好这个概念是人主观的想象的，客观不存在的，别人认为好的不一定适合你。是否好，只有你自己知道。&lt;/p&gt;
&lt;p&gt;需要独立思考，有明确目标。但对于大多数人，都是未曾有过的能力。&lt;/p&gt;
&lt;p&gt;要做好选择固然重要，但是不能一直在选择。选的时候要仔细斟酌，但是选好后要沉下心来，专心做事，修炼自己。就像找老婆一样，谈女朋友时要慎重，可以多选选，结婚后就老老实实过日子吧。&lt;/p&gt;
&lt;h2 id=&quot;努力&quot;&gt;努力&lt;/h2&gt;
&lt;p&gt;如何让自己更值钱？努力学习！&lt;/p&gt;
&lt;p&gt;对于程序员来说，专业技能的提高是必须要做到的。同样的技术，要知道原理，学习的更深刻。而且行业迭代快，要不停地学习，接收新知识。&lt;/p&gt;
&lt;p&gt;要掌握好安身立命的技能，当机会来的时候才能抓住。而不会因为自身的能力拖后腿而后悔。&lt;/p&gt;
&lt;p&gt;普通人之间智商差不多，更多比的是努力，谁花的时间多，谁更勤奋，谁就会更强。&lt;/p&gt;
&lt;p&gt;除了专业技能努力提高外，还需要提高「软技能」。专业技能是解决具体的问题。但是随着层次越高，问题越模糊，解决的方法也越来越多。就要对问题分析与解决、决策能力、心理学等有所训练。&lt;/p&gt;
&lt;p&gt;不管学什么，都要投入时间，精力，经过不断地修炼，才能卓有成效。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;选择和努力要有个平衡。&lt;/p&gt;
&lt;p&gt;重选择轻努力：频繁跳槽，到哪都「怀才不遇」；&lt;/p&gt;
&lt;p&gt;重努力轻选择：交给「运气」，没有把控。&lt;/p&gt;
&lt;p&gt;努力是基础，是自我能够控制的。特别在东亚这几个国家，从来不缺努力的人。&lt;/p&gt;
&lt;p&gt;努力的过程会比较苦，要有坚强的毅力，有时要克服「人性」。长远看对自身是有好处的，需要延迟满足的准备。&lt;/p&gt;
&lt;p&gt;选择充满了不确定性。即使科学决策，也不一定是最优决策。因为选择的时候还受到掌握信息量是否足够，还有选择后，事物的发展还受到其他因素的影响，都是不可控的。但是能力强的人机会更广，更好。选择后结果的稳定性会也更好。例如：读书成绩好的人不一定最有钱，不一定都有钱，但是读书好的人的平均收入肯定比读书差的平均收入高，受到运气的影响波动低。&lt;/p&gt;
&lt;p&gt;努力是前提，只靠运气，概率太低。选择要掌握足够的信息，并且要科学决策，还要加一点点运气。作为人来说，做好自己能控制的，控制不了的，怨天尤人也没用。能力越强，运气也随之变好。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;给在找好公司的同学推荐一个好选择：&lt;strong&gt;富途&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;简单介绍下富途：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好前景&lt;/strong&gt;：金融互联网两个行业的结合，行业好。公司2019年3月上市，正处于高速发展时期。&lt;strong&gt;有足够的空间供个人发展。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好团队&lt;/strong&gt;：技术团队大多来自腾讯，技术氛围好。与牛人共事，能够快速成长。团队不断壮大，也需要能力强的人承担更重要的责任。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好环境&lt;/strong&gt;：公司文化和腾讯相近，自由开放的互联网公司文化。你的好想法能够得到尊重和实现。&lt;/p&gt;
&lt;p&gt;需要什么样的人才：&lt;strong&gt;web后端、或web前端的开发工程师&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（关于公司的详细介绍，还有招聘岗位的详细描述和要求，在网上都有。在互联网行业，搜索能力也很重要。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要要求&lt;/strong&gt;：&lt;strong&gt;努力，爱学习，技术能力强。有潜力和意愿。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;投递方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送简历到邮箱「owenandhisfriends@qq.com」或者通过微信公众号后台投递均可。&lt;/p&gt;
&lt;p&gt;推荐他人也可以，入职成功有&lt;strong&gt;价值千元的红包奖励&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FAQ&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、没有web相关经验可以吗？&lt;/p&gt;
&lt;p&gt;可以，但是要有其他计算机相关开发经验，并且要有意愿转web开发。&lt;/p&gt;
&lt;p&gt;2、来了做什么？&lt;/p&gt;
&lt;p&gt;从事证券业务逻辑、社区、活动、官网等维护和开发。&lt;/p&gt;
&lt;p&gt;3、用什么语言？&lt;/p&gt;
&lt;p&gt;前端就是HTML、CSS、 JavaScript；后端主要是PHP。&lt;/p&gt;
&lt;p&gt;4、我不想写PHP怎么办？&lt;/p&gt;
&lt;p&gt;语言只是工具，不要因为工具而错过一个好机会。&lt;/p&gt;
&lt;p&gt;重要的是思想和做事能力，语言真的只是工具。&lt;/p&gt;
&lt;p&gt;如果你认为其他语言好， 也可以来了带我们转下语言。&lt;/p&gt;
&lt;p&gt;给自己一个机会，可能人生就此改变！&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 05:14:00 +0000</pubDate>
<dc:creator>owenandhisfriends</dc:creator>
<og:description>从年初到现在面试了近百人。面试中发现，有的同学还应该再努力些再换工作；而有的同学已经很努力了，做的很好，但没有选择好，去了不适合自己的公司。 能力好，又选择了好公司好岗位的，还真是不多。 如何才能选到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/owenandhisfriends/p/10925755.html</dc:identifier>
</item>
<item>
<title>Go语言入门——数组、切片和映射（下） - JackieZheng</title>
<link>http://www.cnblogs.com/bigdataZJ/p/array-slice-map-part2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bigdataZJ/p/array-slice-map-part2.html</guid>
<description>&lt;p&gt;&lt;span&gt;上篇主要介绍了Go语言里面常见的复合数据类型的声明和初始化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这篇主要针对数组、切片和映射这些复合数据类型从其他几个方面介绍比较下。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;span&gt;1、遍历&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　不管是数组、切片还是映射结构，都是一种集合类型，要从这些集合取出元素就要查找或者遍历。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于从其他语言转到Go语言，在遍历这边还是有稍稍不同的。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;-1&quot;&gt;&lt;span&gt;数组遍历&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;形式1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;package main

import &quot;fmt&quot;

func main() {
        arr := [5]int{1, 2, 3, 4, 5}

        for i := 0; i &amp;lt; len(arr); i++ {
                fmt.Println(arr[i])
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种最“老土”的遍历形式应该是所有的语言都通用的吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201905/619240-20190526124544447-968031502.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;形式2&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;package main

import &quot;fmt&quot;

func main() {
        arr := [5]int{1, 2, 3, 4, 5}

        for index, value := range arr  {
                fmt.Println(index, value)
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　range关键字表示遍历，后面在切片和映射的遍历我们也可以看到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个遍历就有点Java里面的增强for的味道了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但是还有有点不一样，我前两天刚写Go代码的时候还在这里掉坑里了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　for关键字后面有两个变量，一个是index即数组角标表示第几个元素，一个是value即每个元素的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　坑就坑在，如果只有一个变量也是可以遍历的，比如这样&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;func main() {
        arr := [5]int{1, 2, 3, 4, 5}

        for v := range arr  {
                fmt.Println(v)
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这样和Java的增强for循环遍历几乎就一样了，所以我想当然的以为这里的v就是arr对应的每个元素值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　但其实不是，这里v表示的是数组角标。所以如果按照这样的写法本以为取到的是数组的值，其实是数组的角标值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　另外，Go语言中有一个特性，对于有些用不上的变量，可以使用&quot;_&quot;代替，比如上面的代码可以写成&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;func main() {
        arr := [5]int{1, 2, 3, 4, 5}
        
        for _, value := range arr  {
                fmt.Println(value)
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;-2&quot;&gt;&lt;span&gt;切片遍历&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　切片的遍历和数组没有什么区别。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;package main

import &quot;fmt&quot;

func main() {
        s := []int{1, 2, 3, 4, 5}

        for i := 0; i &amp;lt; len(s); i++ {
                fmt.Println(s[i])
        }

        for index, v := range s {
                fmt.Println(index, v)
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　两种遍历方式也都是适用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　注意这里len函数表示获取切片的长度，除此以外，切片还有一个数组没有的函数即cap，cap表示切片的容量，后面在扩容部分会在提到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201905/619240-20190526124555735-2076641202.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;-3&quot;&gt;&lt;span&gt;映射遍历&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　相较于Java里面对于Map遍历与其他集合遍历有些差别来说，Go里面对于Map的遍历与其他集合的遍历倒显得比较一致。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;package main

import &quot;fmt&quot;

func main()  {
        m := make(map[string]string)
        m[&quot;Jackie&quot;] = &quot;Zheng&quot;
        m[&quot;Location&quot;] = &quot;Shanghai&quot;

        for key, value := range m {
                fmt.Println(key, value)
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　除此以外，我们可以只针对key进行遍历，如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;func main()  {
        m := make(map[string]string)
        m[&quot;Jackie&quot;] = &quot;Zheng&quot;
        m[&quot;Location&quot;] = &quot;Shanghai&quot;

        for key := range m {
                fmt.Println(key, m[key])
        }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201905/619240-20190526124604923-7935.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;-4&quot;&gt;&lt;span&gt;2、切片扩容&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　数组和struct结构体都是静态数据，数组是定长的，而切片和映射都是动态数据类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　为什么说是动态数据类型？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面有顺带提过，切片除了有长度len的概念，还有容量的概念。上篇说到切片声明初始化的一种方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;s := make([]int, 3, 5) // 3所在位置表示切片长度，5所在位置表示容量即最大可能存储的元素个数
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们可以动态向切片添加或者删除元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果新添加元素后已经超出切片原来的容量，那么就会扩容了。借用Go圣经里面的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;var x, y []int
        for i := 0; i &amp;lt; 10; i++ {
                y = append(x, i)
                fmt.Printf(&quot;%d cap=%d\t %v\n&quot;, i, cap(y), y)
                x = y
        }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用append添加新元素每次都会校验当前切片的长度如果已经达到最大容量，则会考虑先扩容，从执行结果可以看出每次扩容是原来的两倍，实际的扩容过程是会先创建一个两倍长的底层数组，然后将原切片数据拷贝到这个底层数组，再添加要插入的元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　所以，这里append函数之后要赋值给对应的切片，因为扩容后和扩容前的内存地址变了，如果不做赋值，可能会出现使用原来的变量无法访问到新切片的情况。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/619240/201905/619240-20190526124613654-1793795551.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;-5&quot;&gt;&lt;span&gt;3、传值还是传引用&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　首先来看一个数组的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;package main

import &quot;fmt&quot;

func main() {
        var arr = [5]int{1, 2, 3, 4, 5}
        fmt.Println(arr)
        fmt.Printf(&quot;origin array address: %p \n&quot;, &amp;amp;arr)
        passArray(arr)
        fmt.Println(arr)
}

func passArray (arr1 [5]int) {
        fmt.Printf(&quot;passed array address, arr1: %p \n&quot;, &amp;amp;arr1)
        fmt.Println(arr1)
        arr1[3] = 111
        fmt.Println(&quot;pass array arr1: &quot;, arr1)
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;code class=&quot;go language-go&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;执行结果如下&lt;/span&gt;&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;[1 2 3 4 5]
origin array address: 0xc000090000 
passed array address, arr1: 0xc000090060 
[1 2 3 4 5]
pass array arr1:  [1 2 3 111 5]
[1 2 3 4 5]
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;先打印该数组，没有问题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在打印当前数组的地址为：0xc000090000&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;再调用函数passArray，先打印改数组地址为：0xc000090060，可以看出这里的地址和原始数组的地址不一样，这是因为这里传的是一个数组的副本，并非指向原数组&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后打印arr1数组，和原数组数据一致&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;再更新角标为3的元素值为111，打印后的结果为：[1 2 3 111 5]。可以发现arr1数组已经更新了&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用完成passArray后，在打印原始数组，发现数据仍为：[1 2 3 4 5]并没有因为arr1的更新而受影响。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　这是因为，在调用函数passArray时，传的是arr数组的一个副本，重新开辟了一个新空间存储这5个数组元素，不同内存空间的数组变动是不会影响另一块存储数组元素的内存空间的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　这种数组传递是非常笨重的，因为需要重新开辟一块空间把原来的数组copy一份，这里是5个元素，如果是1000或者10000个元素呢？所以，我们可以通过其他的方式规避这种笨重的操作，没错，就是指针，代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;package main

import &quot;fmt&quot;

func main() {
        var arr = [5]int{1, 2, 3, 4, 5}
        fmt.Println(arr)
        fmt.Printf(&quot;origin array address: %p \n&quot;, &amp;amp;arr)
        passAddress(&amp;amp;arr)
        fmt.Println(arr)
}

func passAddress (arr2 *[5]int) {
        fmt.Printf(&quot;passed array address, arr2: %p \n&quot;, arr2)
        fmt.Printf(&quot;passed array address, arr2: %p \n&quot;, &amp;amp;arr2)
        fmt.Println(arr2)
        arr2[3] = 111
        fmt.Println(&quot;pass array arr2: &quot;, *arr2)
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　执行结果如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
&lt;span&gt;[1 2 3 4 5]
origin array address: 0xc000084000 
passed array address, arr2: 0xc000084000 
passed array address, arr2: 0xc00000e010 
&amp;amp;[1 2 3 4 5]
pass array arr2:  [1 2 3 111 5]
[1 2 3 111 5]
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;先打印该数组，没有问题&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在打印当前数组的地址为：0xc000084000&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后调用函数passAddress，注意这里传的是数组的地址，接收的是一个指针类型变量arr2。第一次我们直接打印arr2，得到地址为：0xc000084000。没错，这里的意思是arr2这个指针指向的内存地址就是0xc000084000，即和原始数组指向的是同一块内存区域，也就是指向同一块存储这5个元素的区域。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;紧接着，打印arr2的地址，这个&amp;amp;arr2的意思是arr2这个指针的地址，为0xc00000e010，通过上面一点，我们已经知道这个指针指向的地址是0xc000084000&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;然后我们打印arr2，得到&amp;amp;[1 2 3 4 5]&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;之后我们再改变第三个角标的值为111，并打印arr2指针指向的数组的值为：[1 2 3 111 5]，即arr2中元素已经更新&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;调用完passAddress后，我们再次打印原始数组，得到的是：[1 2 3 111 5]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　原始数组的值被改变了，这是因为我们传递的是一个引用，通过一个地址指向了原来数组存储的地址。所以在函数passAddress中实际上是对原来的内存空间的数据更新，显然也会反应到原来的数组上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如上是数组传值的例子，slice和map也是传值的。虽然我们在传递slice或者map的时候没有显式使用指针，但是他们的内部结构都间接使用了指针，所以slice和map都是引用类型，传递的时候相当于传递的是指针的副本，可以理解为上面数组中传指针的例子。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果您觉得阅读本文对您有帮助，请点一下“&lt;strong&gt;推荐&lt;/strong&gt;”按钮，您的&lt;strong&gt;“推荐”&lt;/strong&gt;将是我最大的写作动力！如果您想持续关注我的文章，请扫描二维码，关注JackieZheng的微信公众号，我会将我的文章推送给您，并和您一起分享我日常阅读过的优质文章。&lt;/p&gt;
&lt;pre&gt;
&lt;em&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/619240/201505/162205410643708.jpg&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 26 May 2019 04:49:00 +0000</pubDate>
<dc:creator>JackieZheng</dc:creator>
<og:description>上篇主要介绍了Go语言里面常见的复合数据类型的声明和初始化。 这篇主要针对数组、切片和映射这些复合数据类型从其他几个方面介绍比较。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bigdataZJ/p/array-slice-map-part2.html</dc:identifier>
</item>
<item>
<title>java并发之hashmap源码 - 迷茫中守候</title>
<link>http://www.cnblogs.com/teach/p/10922730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/teach/p/10922730.html</guid>
<description>&lt;p&gt;在上篇博客中分析了hashmap的用法，详情查看&lt;a href=&quot;https://www.cnblogs.com/teach/p/10921846.html&quot;&gt;java并发之hashmap&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇博客重点分析下hashmap的源码（基于JDK1.8）&lt;/p&gt;
&lt;p&gt;一、成员变量&lt;/p&gt;
&lt;p&gt;HashMap有以下主要的成员变量&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The default initial capacity - MUST be a power of two.
     默认初始容量
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; aka 16&lt;/span&gt;

    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The maximum capacity, used if a higher value is implicitly specified
     * by either of the constructors with arguments.
     * MUST be a power of two &amp;lt;= 1&amp;lt;&amp;lt;30.
      最大容量
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The load factor used when none specified in constructor.
     默认的加载因子
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; DEFAULT_LOAD_FACTOR = 0.75f&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The bin count threshold for using a tree rather than list for a
     * bin.  Bins are converted to trees when adding an element to a
     * bin with at least this many nodes. The value must be greater
     * than 2 and should be at least 8 to mesh with assumptions in
     * tree removal about conversion back to plain bins upon
     * shrinkage.
     JDK1.8在哈希冲突后，使用链表的方式存储数据，当链表中元素个数超过8个，则转化为红黑树的格式
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TREEIFY_THRESHOLD = 8&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The bin count threshold for untreeifying a (split) bin during a
     * resize operation. Should be less than TREEIFY_THRESHOLD, and at
     * most 6 to mesh with shrinkage detection under removal.
     当红黑树的节点数少于6个，则转化为链表
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; UNTREEIFY_THRESHOLD = 6&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The table, initialized on first use, and resized as
     * necessary. When allocated, length is always a power of two.
     * (We also tolerate length zero in some operations to allow
     * bootstrapping mechanics that are currently not needed.)
     存储元素的数组
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] table;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Holds cached entrySet(). Note that AbstractMap fields are used
     * for keySet() and values().
     
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; Set&amp;lt;Map.Entry&amp;lt;K,V&amp;gt;&amp;gt;&lt;span&gt; entrySet;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * The number of key-value mappings contained in this map.
     key-value的个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;transient&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面对HashMap中的主要成员变量做了注释，重点关注以下几个，&lt;/p&gt;
&lt;p&gt;transient Node&amp;lt;K,V&amp;gt;[] table  这个成员变量是HashMap存储键值对的载体，Node类型的数组，可以联想到把键值对封装成了Node对象，然后使用数组存储一个一个的Node，体现了Java三大特性中的封装。&lt;/p&gt;
&lt;p&gt;static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4;  HashMap的默认容量，即table数据组的默认长度，在构建table数组时使用。&lt;/p&gt;
&lt;p&gt;static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30  HashMap的最大容量，即table数据的最大长度。&lt;/p&gt;
&lt;p&gt;static final float DEFAULT_LOAD_FACTOR = 0.75f  默认的加载因子，这个变量很重要，关系到HashMap扩容以及数组的饱和程度等&lt;/p&gt;
&lt;p&gt;final float loadFactor  加载因子&lt;/p&gt;
&lt;p&gt;int threshold  代表HashMap的阈值，=table数组的长度*loadFactor，当HashMap中键值对的数量大于threshold的时候便需要扩容，即把数据的长度扩大一倍&lt;/p&gt;
&lt;p&gt;二、构造函数&lt;/p&gt;
&lt;p&gt;HashMap提供了以下4个构造函数，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/985599/201905/985599-20190525150212941-508940527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、HashMap()&lt;/p&gt;
&lt;p&gt;这个是默认的构造函数，其实现如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HashMap() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor = DEFAULT_LOAD_FACTOR; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; all other fields defaulted&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从其实现来看，仅指定了默认的负载因子，其他的均为默认值，默认的负载因子为0.75，这个值是经过经验得出的，是空间和时间上的一个均衡。&lt;/p&gt;
&lt;p&gt;2、HashMap(int initialCapacity)&lt;/p&gt;
&lt;p&gt;这个可以指定HashMap的初始容量，但此容量并非要创建的Node类型的table的长度，HashMap使用了tableSizeFor(int cap)方法对其处理，此方法下面会说到。构造方法的实现如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; initialCapacity) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;(initialCapacity, DEFAULT_LOAD_FACTOR);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现即调用了另一个构造方法&lt;/p&gt;
&lt;p&gt;3、HashMap(int initialCapacity, float loadFactor)&lt;/p&gt;
&lt;p&gt;这个构造方法可以指定两个参数，一个是初始容量，另一个是负载因子，前面说到容量*负载因子=阀值（threshold）,当键值对的数量（size）大于阀值时便要扩容。构造方法实现如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(&lt;span&gt;int&lt;/span&gt; initialCapacity, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; loadFactor) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; 0&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal initial capacity: &quot; +&lt;span&gt;
                                               initialCapacity);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;gt;&lt;span&gt; MAXIMUM_CAPACITY)
            initialCapacity &lt;/span&gt;=&lt;span&gt; MAXIMUM_CAPACITY;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loadFactor &amp;lt;= 0 ||&lt;span&gt; Float.isNaN(loadFactor))
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;Illegal load factor: &quot; +&lt;span&gt;
                                               loadFactor);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; loadFactor;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.threshold =&lt;span&gt; tableSizeFor(initialCapacity);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对给定的初始容量做了判断，最后通过tableSizeFor函数计算出的值给了threshold。&lt;/p&gt;
&lt;p&gt;4、HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m)&lt;/p&gt;
&lt;p&gt;使用一个Map类型的变量构造HashMap，其实现如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; HashMap(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; m) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.loadFactor =&lt;span&gt; DEFAULT_LOAD_FACTOR;
        putMapEntries(m, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;指定了负载因子，看起来负载因子很重要。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putMapEntries(Map&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt; m, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; s =&lt;span&gt; m.size();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (s &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (table == &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; pre-size&lt;/span&gt;
                &lt;span&gt;float&lt;/span&gt; ft = ((&lt;span&gt;float&lt;/span&gt;)s / loadFactor) + 1.0F&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; t = ((ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY) ?&lt;span&gt;
                         (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : MAXIMUM_CAPACITY);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t &amp;gt;&lt;span&gt; threshold)
                    threshold &lt;/span&gt;=&lt;span&gt; tableSizeFor(t);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; threshold)
                resize();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;? &lt;span&gt;extends&lt;/span&gt; K, ? &lt;span&gt;extends&lt;/span&gt; V&amp;gt;&lt;span&gt; e : m.entrySet()) {
                K key &lt;/span&gt;=&lt;span&gt; e.getKey();
                V value &lt;/span&gt;=&lt;span&gt; e.getValue();
                putVal(hash(key), key, value, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, evict);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从4个构造方法中，可以看出都并未初始话table变量，即存储数据的数组，那么table变量在什么时候初始化那，是在put方法中。为什么要放在put方法中，那是因为如果我就调用了构造方法，然后初始化了table数组，分配了内存，然而我不向HashMap中放数据，即不调用put方法，那么肯定会造成内存的浪费，所以只有在真正调用put的时候才初始化table，考虑周全呀。&lt;/p&gt;
&lt;p&gt;二、工具函数&lt;/p&gt;
&lt;p&gt;这里重点分析两个工具函数，hash和tableSizeFor。&lt;/p&gt;
&lt;p&gt;1、hash(Object key)&lt;/p&gt;
&lt;p&gt;此函数的作用是传递一个key参数，返回一个int数值，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash(Object key) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; h;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果key为null，则返回0，否则，取key的hashCode值h和h无符号右移16位的异或值。为什么要这样做我们放在后边分析。这个函数决定了每个键值对在table数组中的位置。&lt;/p&gt;
&lt;p&gt;2、tableForInt(int cap)&lt;/p&gt;
&lt;p&gt;此函数是为了计算大于或等于给定参数的最小的2的N次方。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; tableSizeFor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; cap) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = cap - 1&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 1&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 2&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 4&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 8&lt;span&gt;;
        n &lt;/span&gt;|= n &amp;gt;&amp;gt;&amp;gt; 16&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (n &amp;lt; 0) ? 1 : (n &amp;gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举个例子，现在给一个数19，调用此函数后返回32；给一个数16，调用此函数后返回16，给一个数15，调用此函数后返回16。&lt;/p&gt;
&lt;p&gt;三、put/get操作&lt;/p&gt;
&lt;p&gt;put和get操作是HashMap中常用的操作，使用频率很高，了解其实现对编写代码很有提升。&lt;/p&gt;
&lt;p&gt;1、put(K key, V value)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V put(K key, V value) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; putVal(hash(key), key, value, &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码中可以看出调用了putVal方法，使用hash函数对key进行了哈希。putVal的定义如下，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; V putVal(&lt;span&gt;int&lt;/span&gt; hash, K key, V value, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; onlyIfAbsent,
                   &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; evict) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; p; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, i;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果HashMap底层的数组table为空，或者其长度位0&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((tab = table) == &lt;span&gt;null&lt;/span&gt; || (n = tab.length) == 0&lt;span&gt;)
            n &lt;/span&gt;= (tab = resize()).length;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用扩容方法进行扩容，并返回扩容后的长度
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果要存储的key在table中的索引处元素p为null，则说明此key所在索引处未产生hash冲突&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((p = tab[i = (n - 1) &amp;amp; hash]) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个Node节点，放在此key的索引处&lt;/span&gt;
            tab[i] = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果此key所在的索引处的元素p不为null，说明已经有其他的key的hash值和现在key的hash相同，产生了hash冲突，两个元素在table中的索引一致&lt;/span&gt;
            Node&amp;lt;K,V&amp;gt;&lt;span&gt; e; K k;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果要插入的key value和p的全部相同，把p赋给e&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (p.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                ((k &lt;/span&gt;= p.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                e &lt;/span&gt;=&lt;span&gt; p;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不相等，判断p的节点类型，如果是TreeNode类型，则证明是红黑树的结构，调用putTreeVal进行元素插入&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                e &lt;/span&gt;= ((TreeNode&amp;lt;K,V&amp;gt;)p).putTreeVal(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, tab, hash, key, value);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不是TreeNode类型，则说明是链表的结构，使用链表的方式插入，找到链表的尾部，进行插入&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; binCount = 0; ; ++&lt;span&gt;binCount) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = p.next) == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在p后插入元素&lt;/span&gt;
                        p.next = newNode(hash, key, value, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断链表的元素数量，如果大于8，则调用treeifyBin方法转化为红黑树&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (binCount &amp;gt;= TREEIFY_THRESHOLD - 1) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; -1 for 1st&lt;/span&gt;
&lt;span&gt;                            treeifyBin(tab, hash);
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                        ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    p &lt;/span&gt;=&lt;span&gt; e;
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;e不为null，说明存在一个相同的key，则需要进行value的替换，并返回旧值&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; existing mapping for key&lt;/span&gt;
                V oldValue =&lt;span&gt; e.value;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!onlyIfAbsent || oldValue == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    e.value &lt;/span&gt;=&lt;span&gt; value;
                afterNodeAccess(e);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldValue;
            }
        }
        &lt;/span&gt;++&lt;span&gt;modCount;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果插入元素后，元素个数大于threshold（阀值=数组容量*负载因子），进行扩容&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (++size &amp;gt;&lt;span&gt; threshold)
            resize();
        afterNodeInsertion(evict);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中做了详细的注释，下面把过程概括如下&lt;/p&gt;
&lt;p&gt;1、判断HashMap底层存储数据的数组table是否为null或者长度为0（这里在进行table的初始化），如果是则进行扩容（第一次叫初始化）；&lt;/p&gt;
&lt;p&gt;2、如果不是，取出要插入key在数组中索引位置的元素p，判断p是否为null，如果为null，则直接插入；&lt;/p&gt;
&lt;p&gt;3、如果p不为null，判断判断p和待插入数据是否相等，如果相等使用e存储p（后面会判断e是否null，如果不为null，则进行值的替换）；&lt;/p&gt;
&lt;p&gt;4、如果不等，判断p的类型是否为TreeNode，即是否为红黑树的结构，如果是则使用红黑树的方式插入；&lt;/p&gt;
&lt;p&gt;5、如果不是TreeNode，则使用链表的方式插入；&lt;/p&gt;
&lt;p&gt;6、插入完成后更新元素的个数size，如果size大于threshold进行扩容；&lt;/p&gt;
&lt;p&gt;上面是put的大体过程，对于红黑树的插入，暂不做分析，下面分析下扩容函数resize，其源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt;&lt;span&gt;[] resize() {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] oldTab =&lt;span&gt; table;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span&gt;null&lt;/span&gt;) ? 0&lt;span&gt; : oldTab.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; oldThr =&lt;span&gt; threshold;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; newCap, newThr = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt; 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (oldCap &amp;gt;=&lt;span&gt; MAXIMUM_CAPACITY) {
                threshold &lt;/span&gt;=&lt;span&gt; Integer.MAX_VALUE;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; oldTab;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; 1) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;&lt;span&gt;
                     oldCap &lt;/span&gt;&amp;gt;=&lt;span&gt; DEFAULT_INITIAL_CAPACITY)
                newThr &lt;/span&gt;= oldThr &amp;lt;&amp;lt; 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; double threshold&lt;/span&gt;
&lt;span&gt;        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (oldThr &amp;gt; 0) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; initial capacity was placed in threshold&lt;/span&gt;
            newCap =&lt;span&gt; oldThr;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; {               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; zero initial threshold signifies using defaults&lt;/span&gt;
            newCap =&lt;span&gt; DEFAULT_INITIAL_CAPACITY;
            newThr &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR *&lt;span&gt; DEFAULT_INITIAL_CAPACITY);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (newThr == 0&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; ft = (&lt;span&gt;float&lt;/span&gt;)newCap *&lt;span&gt; loadFactor;
            newThr &lt;/span&gt;= (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?&lt;span&gt;
                      (&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;)ft : Integer.MAX_VALUE);
        }
        threshold &lt;/span&gt;=&lt;span&gt; newThr;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、创建一个新的Node数组，保存数据&lt;/span&gt;
        @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;&lt;span&gt;})
            Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Node[newCap];
        table &lt;/span&gt;=&lt;span&gt; newTab;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、如果旧数组不为空，则要把元素拷贝到新数组&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (oldTab != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环旧数组中的元素&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = 0; j &amp;lt; oldCap; ++&lt;span&gt;j) {
                Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;j索引处不为null，取出给e&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; ((e = oldTab[j]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;清空j处的元素&lt;/span&gt;
                    oldTab[j] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.1、判断e是否有后继，如果没有说明仅有一个Node元素，重新计算e中key的hash值，得到在新数组中的索引，进行插入&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (e.next == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                        newTab[e.hash &lt;/span&gt;&amp;amp; (newCap - 1)] =&lt;span&gt; e;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.2.1判断e是否为TreeNode类型，如果是使用红黑树的方式&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (e &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                        ((TreeNode&lt;/span&gt;&amp;lt;K,V&amp;gt;)e).split(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, newTab, j, oldCap);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.2.2不是红黑树的数据结构，为链表结构，进行链表结构的数据拷贝&lt;/span&gt;
                    &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; preserve order&lt;/span&gt;
                        Node&amp;lt;K,V&amp;gt; loHead = &lt;span&gt;null&lt;/span&gt;, loTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        Node&lt;/span&gt;&amp;lt;K,V&amp;gt; hiHead = &lt;span&gt;null&lt;/span&gt;, hiTail = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;
                        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                            next &lt;/span&gt;=&lt;span&gt; e.next;
                            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == 0&lt;span&gt;) {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    loHead &lt;/span&gt;=&lt;span&gt; e;
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    loTail.next &lt;/span&gt;=&lt;span&gt; e;
                                loTail &lt;/span&gt;=&lt;span&gt; e;
                            }
                            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hiTail == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                                    hiHead &lt;/span&gt;=&lt;span&gt; e;
                                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                                    hiTail.next &lt;/span&gt;=&lt;span&gt; e;
                                hiTail &lt;/span&gt;=&lt;span&gt; e;
                            }
                        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((e = next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (loTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            loTail.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            newTab[j] &lt;/span&gt;=&lt;span&gt; loHead;
                        }
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (hiTail != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            hiTail.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                            newTab[j &lt;/span&gt;+ oldCap] =&lt;span&gt; hiHead;
                        }
                    }
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; newTab;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面源码中进行了详细注释，具体步骤可查看注释。&lt;/p&gt;
&lt;p&gt;2、get(Object key)&lt;/p&gt;
&lt;p&gt;get函数是使用key取出其对于的value的过程，其源码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; V get(Object key) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (e = getNode(hash(key), key)) == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt;&lt;span&gt; : e.value;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用getNode函数取出Node元素，如果Node为null，则返回null，如果不为则返回其value属性值，关于Node类的构成稍后分析，先看getNode函数，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; Node&amp;lt;K,V&amp;gt; getNode(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash, Object key) {
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;[] tab; Node&amp;lt;K,V&amp;gt; first, e; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n; K k;
        &lt;/span&gt;&lt;span&gt;//1、&lt;/span&gt;&lt;span&gt;判断table不为null且长度大于0，且要取的key处索引位置元素不为null&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ((tab = table) != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (n = tab.length) &amp;gt; 0 &amp;amp;&amp;amp;&lt;span&gt;
            (first &lt;/span&gt;= tab[(n - 1) &amp;amp; hash]) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//2、&lt;/span&gt;&lt;span&gt;如果第一个元素和给定的key相等则直接返回第一个元素first&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (first.hash == hash &amp;amp;&amp;amp; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; always check first node&lt;/span&gt;
                ((k = first.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; first;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((e = first.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//3.1、&lt;/span&gt;&lt;span&gt;如果第一个元素的类型为TreeNode，使用红黑树的方式取得Node&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (first &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; TreeNode)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ((TreeNode&amp;lt;K,V&amp;gt;&lt;span&gt;)first).getTreeNode(hash, key);
                &lt;/span&gt;&lt;span&gt;//3.2、&lt;/span&gt;&lt;span&gt;使用链表的方式取得Node&lt;/span&gt;
                &lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.hash == hash &amp;amp;&amp;amp;&lt;span&gt;
                        ((k &lt;/span&gt;= e.key) == key || (key != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; key.equals(k))))
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; e;
                } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; ((e = e.next) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在上面的代码中进行了详细注释，可参考。&lt;/p&gt;
&lt;p&gt;下面看下Node的结构，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Node&amp;lt;K,V&amp;gt; &lt;span&gt;implements&lt;/span&gt; Map.Entry&amp;lt;K,V&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hash;
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt;&lt;span&gt; K key;
        V value;
        Node&lt;/span&gt;&amp;lt;K,V&amp;gt;&lt;span&gt; next;

        Node(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hash, K key, V value, Node&amp;lt;K,V&amp;gt;&lt;span&gt; next) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hash =&lt;span&gt; hash;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.value =&lt;span&gt; value;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next =&lt;span&gt; next;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Node作为HashMap的静态内部类，其属性有hash、key、value、next，使用这些属性存储数据，其中key value即为我们说的hashMap中的键值对，这里使用Node进行封装。next指向下个Node的地址。&lt;/p&gt;

&lt;p&gt;以上对HashMap做了主要分析，后面计划对其哈希hash函数即红黑树做分析。&lt;/p&gt;
&lt;p&gt;有不正之处，欢迎指正！&lt;/p&gt;

</description>
<pubDate>Sun, 26 May 2019 04:04:00 +0000</pubDate>
<dc:creator>迷茫中守候</dc:creator>
<og:description>在上篇博客中分析了hashmap的用法，详情查看java并发之hashmap 本篇博客重点分析下hashmap的源码（基于JDK1.8） 一、成员变量 HashMap有以下主要的成员变量 上面对Has</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/teach/p/10922730.html</dc:identifier>
</item>
<item>
<title>Linux VFS - 一罪</title>
<link>http://www.cnblogs.com/yizui/p/10890939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yizui/p/10890939.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;翻译自Linux文档中的vfs.txt&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;VFS（Virtual File System）是内核提供的文件系统抽象层，其提供了文件系统的操作接口，可以隐藏底层不同文件系统的实现。&lt;/p&gt;
&lt;h2 id=&quot;directiry-entry-cachedcache&quot;&gt;Directiry Entry Cache（dcache）&lt;/h2&gt;
&lt;p&gt;VFS通过&lt;code&gt;open()&lt;/code&gt;、&lt;code&gt;stat()&lt;/code&gt;这些接口传入的文件名搜索dcache，快速找到文件名对应的dentry。dentry的结构是&lt;code&gt;struct dentry&lt;/code&gt;，这只是一个内存结构，不会持久化到磁盘中，仅仅是为了提升性能而已。&lt;/p&gt;
&lt;p&gt;dentry cache是整个文件空间的视图，但是大部分情况下并不能同时将所有dentry都加载到内存。VFS会在执行&lt;code&gt;lookup()&lt;/code&gt;时，创建还不在内存中的dentry。&lt;/p&gt;
&lt;h2 id=&quot;the-inode-object&quot;&gt;The Inode Object&lt;/h2&gt;
&lt;p&gt;inode代表真实存储在文件系统中的对象，比如文件、目录、FIFO等等。inode的结构是&lt;code&gt;struct inode&lt;/code&gt;。一个dentry只能指向一个inode，但一个inode可以被多个dentry指向。&lt;/p&gt;
&lt;p&gt;对于块设备的文件系统，inode存储在磁盘上，并在需要的时候拷贝到内存中，修改inode后又会写回磁盘进行持久化。对于伪文件系统，inode保存在内存中。&lt;/p&gt;
&lt;p&gt;VFS调用&lt;code&gt;lookup()&lt;/code&gt;从指定路径的第一级目录的dentry开始查找对应的inode。&lt;code&gt;lookup()&lt;/code&gt;的真实实现是由inode所在的底层文件系统提供的。&lt;/p&gt;
&lt;h2 id=&quot;the-file-object&quot;&gt;The File Object&lt;/h2&gt;
&lt;p&gt;打开一个文件实际就是创建一个file对象。file的结构是&lt;code&gt;struct file&lt;/code&gt;，其有指向一个dentry的指针，和一组操作file的函数指针。这些信息是从inode中获取的。在打开文件的最后，file会被加入当前进程的文件描述符表中。&lt;/p&gt;
&lt;p&gt;用户的读、写、关闭文件都通过&lt;code&gt;fd&lt;/code&gt;进行，内核会可以根据&lt;code&gt;fd&lt;/code&gt;获取到对应的file对象，这些操作最终都会调用到底层文件系统提供的函数。&lt;/p&gt;

&lt;p&gt;注册和注销文件系统的函数如下&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;#include &amp;lt;linux/fs.h&amp;gt;

extern int register_filesystem(struct file_system_type *);
extern int unregister_filesystem(struct file_system_type *);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当挂载文件系统时，VFS会调用底层文件系统指定的&lt;code&gt;mount()&lt;/code&gt;函数，&lt;code&gt;mount()&lt;/code&gt;会返回一个dentry作为文件系统的根目录。所有已挂载的文件系统，可以在/proc/filesystems中看到。&lt;/p&gt;
&lt;h2 id=&quot;struct-file_system_type&quot;&gt;struct file_system_type&lt;/h2&gt;
&lt;p&gt;该结构用于描述文件系统，自内核2.6.30，有如下定义&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct file_system_type {
    const char *name;
    int fs_flags;
    struct dentry *(*mount) (struct file_system_type *, int,
                    const char *, void *);
    void (*kill_sb) (struct super_block *);
    struct module *owner;
    struct file_system_type * next;
    struct list_head fs_supers;
    struct lock_class_key s_lock_key;
    struct lock_class_key s_umount_key;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;name：文件系统的名字，比如&quot;ext2&quot;等。&lt;/li&gt;
&lt;li&gt;fs_flags：比如FS_REQUIRES_DEV、FS_NO_DCACHE等一些标志。&lt;/li&gt;
&lt;li&gt;mount：挂载文件系统时调用。&lt;/li&gt;
&lt;li&gt;kill_sb：卸载文件系统时调用。&lt;/li&gt;
&lt;li&gt;owner：在大部分情况下，应当初始化为THIS_MODULE。&lt;/li&gt;
&lt;li&gt;next：应当初始化为NULL。&lt;/li&gt;
&lt;li&gt;s_lock_key，s_umount_key：用于检查死锁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;mount()&lt;/code&gt;的参数如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;struct file_system_type* fs_type&lt;/code&gt;：描述文件系统，其中部分底层文件系统初始化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int flags&lt;/code&gt;：挂载的标志，如&lt;code&gt;FS_REQUIRES_DEV&lt;/code&gt;,&lt;code&gt;FS_NO_DCACHE&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const char *dev_name&lt;/code&gt;：挂载的设备名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void *data&lt;/code&gt;：任意的选项，通常是ASCII字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;mount()&lt;/code&gt;成功时，要求加锁并获得superblock的活动引用，返回dentry（可以是子目录的dentry），失败时返回&lt;code&gt;ERR_PTR(error)&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;grab_super()&lt;/code&gt;是获取活动引用的函数，即让&lt;code&gt;spuer_block::a_active&lt;/code&gt;加1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;mount()&lt;/code&gt;会创建一个superblock，其结构是&lt;code&gt;struct superblock&lt;/code&gt;。&lt;code&gt;struct superblock&lt;/code&gt;中有一个指向&lt;code&gt;struct super_operations&lt;/code&gt;的指针&lt;code&gt;s_op&lt;/code&gt;，其由一系列操作文件系统的函数指针组成。&lt;/p&gt;
&lt;p&gt;VFS提供了如下方法挂载不同类型的文件系统&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;mount_bdev()&lt;/code&gt;：挂载基于块设备的文件系统。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mount_nodev()&lt;/code&gt;：挂载不基于设备的文件系统。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mount_single()&lt;/code&gt;：挂载共享实例的文件系统。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些函数都有一个入参&lt;code&gt;int (*fill_super)(struct super_block *, void *, int)&lt;/code&gt;，其用于初始化&lt;code&gt;struct superblock&lt;/code&gt;的部分字段。&lt;/p&gt;
&lt;p&gt;fill_super的参数如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;struct super_block *sb&lt;/code&gt;：指向superblock。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void *data&lt;/code&gt;：mount的参数，通常是一个ASCII字符串，需要自行解析。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int silent&lt;/code&gt;：确定是否输出错误信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个superblock代表了一个已挂载的文件系统。&lt;/p&gt;
&lt;h2 id=&quot;struct-super_operations&quot;&gt;struct super_operations&lt;/h2&gt;
&lt;p&gt;VFS通过&lt;code&gt;struct super_operations&lt;/code&gt;操作superblock&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct super_operations {
        struct inode *(*alloc_inode)(struct super_block *sb);
        void (*destroy_inode)(struct inode *);

        void (*dirty_inode) (struct inode *, int flags);
        int (*write_inode) (struct inode *, int);
        void (*drop_inode) (struct inode *);
        void (*delete_inode) (struct inode *);
        void (*put_super) (struct super_block *);
        int (*sync_fs)(struct super_block *sb, int wait);
        int (*freeze_fs) (struct super_block *);
        int (*unfreeze_fs) (struct super_block *);
        int (*statfs) (struct dentry *, struct kstatfs *);
        int (*remount_fs) (struct super_block *, int *, char *);
        void (*clear_inode) (struct inode *);
        void (*umount_begin) (struct super_block *);

        int (*show_options)(struct seq_file *, struct dentry *);

        ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
        ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
    int (*nr_cached_objects)(struct super_block *);
    void (*free_cached_objects)(struct super_block *, int);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除非有额外的说明，否则VFS不会加锁调用这些函数。这意味着这些函数阻塞时，不会影响到其他线程。所有的函数只会在进程上下文调用，不会在中断上下文中调用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;alloc_inode：用于分配和初始化inode。如果未指定该方法，则使用纯粹的&lt;code&gt;struct inode&lt;/code&gt;。通常情况下，文件系统会自定义自己的inode结构，除了包含&lt;code&gt;struct inode&lt;/code&gt;外，还会包含和底层文件系统相关的字段。&lt;/li&gt;
&lt;li&gt;destroy_inode：销毁inode，必须和alloc_inode一起实现。&lt;/li&gt;
&lt;li&gt;dirty_inode：将inode标记为脏inode&lt;/li&gt;
&lt;li&gt;write_inode：将inode写回到磁盘。该函数第二个参数用于指定是否同步写入，并非所有文件系统都检查这个标志&lt;/li&gt;
&lt;li&gt;drop_inode：用于判断是否从内存中移除inode。当inode引用计数为0时调用该函数，&lt;strong&gt;调用前会锁定&lt;code&gt;inode-&amp;gt;i_lock&lt;/code&gt;&lt;/strong&gt;。drop_inode应该是NULL（正常UNIX文件系统语义）或者是&lt;code&gt;generic_delete_inode()&lt;/code&gt;（不考虑引用计数，强制清除inode，适用于不想缓存inode的文件系统）。&lt;/li&gt;
&lt;li&gt;delete_inode：从内存中移除inode。v2.6.39的&lt;code&gt;struct super_operations&lt;/code&gt;就没有这个字段，取而代之的是evict_inode&lt;/li&gt;
&lt;li&gt;put_super：释放&lt;code&gt;superblock&lt;/code&gt;，&lt;strong&gt;调用前锁定&lt;code&gt;superblock lock&lt;/code&gt;&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;sync_fs：将superblock关联的脏数据写回到存储。第二个参数用于指明是否等待数据写完后再返回。&lt;/li&gt;
&lt;li&gt;freeze_fs：锁定文件系统并迫使它进入一致状态。目前被逻辑卷管理（LVM）会用到该函数。&lt;/li&gt;
&lt;li&gt;unfreeze_fs：解锁文件系统，使其可以重新写入。&lt;/li&gt;
&lt;li&gt;statfs：获取文件系统统计信息。&lt;/li&gt;
&lt;li&gt;remount_fs：重新挂载文件系统，主要用于更新挂载参数。调用前锁定**&lt;code&gt;kernel lock&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;clear_inode：标记不再使用该inode。v2.6.39的&lt;code&gt;struct super_operations&lt;/code&gt;就没有这个字段&lt;/li&gt;
&lt;li&gt;umount_begin：卸载文件系统&lt;/li&gt;
&lt;li&gt;show_options：用于在/proc//mounts里输出挂载选项&lt;/li&gt;
&lt;li&gt;quota_read：读quota file&lt;/li&gt;
&lt;li&gt;quota_write：写quota file&lt;/li&gt;
&lt;li&gt;nr_cached_objects：返回可释放的对象个数。&lt;/li&gt;
&lt;li&gt;free_cache_objects：清理对象。需要和nr_cached_objects一起定义&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果这些函数内会执行批量任务，那么必须包含支持重新调度的函数，这使得VFS无需担心这些函数长时间处理的问题。&lt;/p&gt;
&lt;p&gt;设置inode时必须初始化&lt;code&gt;struct inode&lt;/code&gt;的&lt;code&gt;i_op&lt;/code&gt;字段，其指向&lt;code&gt;struct inode_operations&lt;/code&gt;，该结构包含了一系列操作&lt;code&gt;inode&lt;/code&gt;的函数。&lt;/p&gt;
&lt;h2 id=&quot;struct-xattr_handler&quot;&gt;struct xattr_handler&lt;/h2&gt;
&lt;p&gt;当文件系统需要支持扩展属性时，可以指定&lt;code&gt;superblock&lt;/code&gt;的&lt;code&gt;s_xattr&lt;/code&gt;字段，其指向一个一NULL结尾的&lt;code&gt;struct xattr_handler&lt;/code&gt;数组。扩展属性是一个name-value对。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct xattr_handler {
    const char *name;
    const char *prefix;
    int flags;      /* fs private flags */
    bool (*list)(struct dentry *dentry);
    int (*get)(const struct xattr_handler *, struct dentry *dentry,
           struct inode *inode, const char *name, void *buffer,
           size_t size);
    int (*set)(const struct xattr_handler *, struct dentry *dentry,
           struct inode *inode, const char *name, const void *buffer,
           size_t size, int flags);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;name：该结构中的函数用于处理该名字代表的属性，比如&quot;system.posix_acl_access&quot;。指定name，则prefix必须是NULL&lt;/li&gt;
&lt;li&gt;prefix：该结构中的函数用于处理该前缀代表的属性，比如&quot;user.&quot;。指定了prefix，则name必须是NULL&lt;/li&gt;
&lt;li&gt;list：确定是否应为特定的dentry列出与此处理函数匹配的属性。&lt;/li&gt;
&lt;li&gt;get：获取扩展属性的值。该方法在&lt;code&gt;getxattr(2)&lt;/code&gt;流程中调用&lt;/li&gt;
&lt;li&gt;set：设置扩展属性的值。如果新值为NULL，则移除扩展属性。该函数在&lt;code&gt;setxattr(2)&lt;/code&gt;和&lt;code&gt;removexattr(2)&lt;/code&gt;流程中调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当文件系统没有xattr的处理方法或者没有匹配的属性时，会返回&lt;code&gt;-EOPNOTSUPP&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;一个inode代表了一个文件系统对象&lt;/p&gt;
&lt;h2 id=&quot;struct-inode_operations&quot;&gt;&lt;code&gt;struct inode_operations&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;struct inode_operations&lt;/code&gt;描述了VFS如何操作inode&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct inode_operations {
    int (*create) (struct inode *,struct dentry *, umode_t, bool);
    struct dentry * (*lookup) (struct inode *,struct dentry *, unsigned int);
    int (*link) (struct dentry *,struct inode *,struct dentry *);
    int (*unlink) (struct inode *,struct dentry *);
    int (*symlink) (struct inode *,struct dentry *,const char *);
    int (*mkdir) (struct inode *,struct dentry *,umode_t);
    int (*rmdir) (struct inode *,struct dentry *);
    int (*mknod) (struct inode *,struct dentry *,umode_t,dev_t);
    int (*rename) (struct inode *, struct dentry *,
            struct inode *, struct dentry *, unsigned int);
    int (*readlink) (struct dentry *, char __user *,int);
    const char *(*get_link) (struct dentry *, struct inode *,
                 struct delayed_call *);
    int (*permission) (struct inode *, int);
    int (*get_acl)(struct inode *, int);
    int (*setattr) (struct dentry *, struct iattr *);
    int (*getattr) (const struct path *, struct kstat *, u32, unsigned int);
    ssize_t (*listxattr) (struct dentry *, char *, size_t);
    void (*update_time)(struct inode *, struct timespec *, int);
    int (*atomic_open)(struct inode *, struct dentry *, struct file *,
            unsigned open_flag, umode_t create_mode);
    int (*tmpfile) (struct inode *, struct dentry *, umode_t);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除非有额外说明，否则所有方法都不会持锁调用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;create：创建inode，由&lt;code&gt;open(2)&lt;/code&gt;和&lt;code&gt;creat(2)&lt;/code&gt;调用。只有当需要支持常规文件时，才实现该函数。入参dentry必须没有指向任何&lt;code&gt;inode&lt;/code&gt;的，最后需要调用&lt;code&gt;d_instantiate()&lt;/code&gt;将新创建的inode加入到这个dentry中。&lt;/li&gt;
&lt;li&gt;lookup：查找inode。&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;需要查找的inode的名字记录在dentry中。如果找到了则需要调用&lt;code&gt;d_add()&lt;/code&gt;将inode加入到dentry中，并且inode的引用计数要加1。如果inode不存在，则需要将NULL加入到dentry，代表dentry是无效的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;当错误发生时，必须返回错误。如果只是将dentry指向NULL，VFS会执行&lt;code&gt;create(2)&lt;/code&gt;, &lt;code&gt;mknod(2)&lt;/code&gt;, &lt;code&gt;mkdir(2)&lt;/code&gt;去创建&lt;code&gt;inode&lt;/code&gt;，但这些函数还是会因为lookup失败的原因而再次失败。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;如果需要重新设置&lt;code&gt;dentry&lt;/code&gt;的操作函数，可以给&lt;code&gt;d_dop&lt;/code&gt;赋值。这些函数被调用时，会使用目录inode的信号量。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;link：创建硬链接。和create一样，该函数中需要调用&lt;code&gt;d_instantiate()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;unlink：支持删除inode。&lt;/li&gt;
&lt;li&gt;symlink：创建符号链接。&lt;/li&gt;
&lt;li&gt;mkdir：创建目录。该函数中也需要调用&lt;code&gt;d_instantiate()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;rmdir：删除目录。&lt;/li&gt;
&lt;li&gt;mknod：创建设备inode、命名管道或socket。该函数中也需要调用&lt;code&gt;d_instantiate()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;rename：重命名。当文件系统不支持某些方法和flag时，必须返回&lt;code&gt;-EINVAL&lt;/code&gt;。当前以下flag已经实现&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;RENAME_NOREPLACE：如果新文件名已经存在，则应当返回&lt;code&gt;-EEXIST&lt;/code&gt;。但是目前VFS已经检查了新文件名是否存在。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;RENAME_EXCHANGE：两个文件必须都存在，只是交换一下文件名。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;get_link：获取符号链接所指向的inode。&lt;/li&gt;
&lt;li&gt;readlink：读取符号链接所指向的inode的文件名。正常情况下，文件系统只需要实现get_link。&lt;/li&gt;
&lt;li&gt;permission：检查类POSIX文件系统的访问权限。可能会在rcu-walk模式下调用。如果在rcu-walk模式下，文件系统必须在不阻塞或者不存储inode的情况下检查权限。如果在rcu-walk模式下，发生一个无法处理的情况，则返回&lt;code&gt;-ECHILD&lt;/code&gt;,此后会在ref-walk模式下再尝试一次。&lt;/li&gt;
&lt;li&gt;setattr：设置文件属性，由&lt;code&gt;chmod(2)&lt;/code&gt;和相关的系统调用触发。&lt;/li&gt;
&lt;li&gt;getattr：获取文件属性，由&lt;code&gt;stat(2)&lt;/code&gt;和相关的系统调用触发。&lt;/li&gt;
&lt;li&gt;listxattr：由VFS调用列出一个文件的所有扩展属性，由&lt;code&gt;listxattr(2)&lt;/code&gt;触发。&lt;/li&gt;
&lt;li&gt;update_time：更新inode的时间(atime、ctime、mtime)或&lt;code&gt;i_version&lt;/code&gt;。如果该方法未定义，那么VFS会自行更新inode，然后调用&lt;code&gt;mark_inode_dirty_sync()&lt;/code&gt;标记该&lt;code&gt;inode&lt;/code&gt;为脏&lt;code&gt;inode&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;atomic_open：在open操作的最后调用。使用这个可选的方法，文件系统可以原子性地查找、创建、打开一个文件。如果该方法想让调用者去打开文件，则应当通过&lt;code&gt;finish_no_open()&lt;/code&gt;通知调用者。该方法只在最后一步是无效或者需要lookup时才调用。缓存有效的dentry需要在&lt;code&gt;f_op-&amp;gt;open()&lt;/code&gt;中完成。如果文件创建成功了，则需要在&lt;code&gt;file-&amp;gt;f_mode&lt;/code&gt;设置&lt;code&gt;FMODE_CREATED&lt;/code&gt;。如果指定了&lt;code&gt;O_EXCL&lt;/code&gt;，该方法需要在文件存在时返回失败。返回成功就设置&lt;code&gt;FMODE_CREATED&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;tmpfile：在&lt;code&gt;open(O_TMPFILE)&lt;/code&gt;的最后被调用。这是一个可选的方法，等同于在一个指定的目录下，原子性地创建、打开、删除一个文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;address space对象用于组织和管理page cache中的page。它可以追踪一个文件使用的page以及一个文件被映射到进程空间的page。它可以根据地址查找page，追踪被标记为Dirty或Writeback的page。&lt;/p&gt;
&lt;p&gt;VM可以调用&lt;code&gt;writepage()&lt;/code&gt;来清理脏页，或者设置&lt;code&gt;PagePrivate&lt;/code&gt;后调用&lt;code&gt;releasepage()&lt;/code&gt;来释放干净的页以便重新使用。如果干净的页没有设置&lt;code&gt;PagePrivate&lt;/code&gt;或者没有外部引用，就会在没有通知address space的情况下被释放掉。为了实现这些功能，page需要通过&lt;code&gt;lru_cache_add()&lt;/code&gt;方法放到LRU中，当page被使用时需要调用&lt;code&gt;mark_page_active()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;page使用一个基数树（radix tree）来保存。这棵树维护了所有page的&lt;code&gt;PG_Diry&lt;/code&gt;和&lt;code&gt;PG_Writeback&lt;/code&gt;状态，因此这些页能被快速找到。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mpage_writepages()&lt;/code&gt;是默认的&lt;code&gt;writepages&lt;/code&gt;,它使用&lt;code&gt;Dirty&lt;/code&gt;标记查找脏页并写回。如果没有使用&lt;code&gt;mpage_writepages()&lt;/code&gt;（可能是address space提供了自己的&lt;code&gt;writepage&lt;/code&gt;），那么&lt;code&gt;PAGECACHE_TAG_DIRTY&lt;/code&gt;标记就不会被使用。&lt;code&gt;write_inode_now()&lt;/code&gt;和&lt;code&gt;sync_inode()&lt;/code&gt;使用&lt;code&gt;PAGECACHE_TAG_DIRTY&lt;/code&gt;来检查&lt;code&gt;writepages&lt;/code&gt;是否将整个address space写回到存储中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;filemap*wait*&lt;/code&gt;和&lt;code&gt;sync_page*&lt;/code&gt;会使用&lt;code&gt;Writeback&lt;/code&gt;标记，并通过&lt;code&gt;filemap_fdatawait_range()&lt;/code&gt;等待所有写回操作完成。&lt;/p&gt;
&lt;p&gt;address space的处理方法可以通过&lt;code&gt;page::private&lt;/code&gt;附加一些额外的信息到page中。如果附加了信息，那么必须设置&lt;code&gt;PG_Private&lt;/code&gt;。VM会调用address space的额外函数来处理这些数据。&lt;/p&gt;
&lt;p&gt;address space作为存储和应用之间的中间层。每次从存储读取一页的数据到address space中，供应用读取。应用可以将任意大小的数据写入address space，但最后以页为单位写入到存储中。&lt;/p&gt;
&lt;p&gt;读进程只需要&lt;code&gt;readpage&lt;/code&gt;。写进程则复杂一点，需要&lt;code&gt;write_begin/write_end&lt;/code&gt;将数据写入到address space，还需要&lt;code&gt;writepage&lt;/code&gt;和&lt;code&gt;writepages&lt;/code&gt;将数据写到存储中。&lt;/p&gt;
&lt;p&gt;address space增删页受&lt;code&gt;inode::i_mutex&lt;/code&gt;的保护。&lt;/p&gt;
&lt;p&gt;当数据被写入到page中时，需要设置&lt;code&gt;PG_Dirty&lt;/code&gt;（&lt;code&gt;set_page_dirty()&lt;/code&gt;）。当需要&lt;code&gt;writepages&lt;/code&gt;时会设置&lt;code&gt;PG_Writeback&lt;/code&gt;并清除&lt;code&gt;PG_Dirty&lt;/code&gt;。标记为&lt;code&gt;PG_Writeback&lt;/code&gt;的page可以在任意时间写回到存储，一旦写回完成后，该标志被清除。&lt;/p&gt;
&lt;p&gt;写回会使用&lt;code&gt;struct writeback_control&lt;/code&gt;给&lt;code&gt;writepage&lt;/code&gt;和&lt;code&gt;writepages&lt;/code&gt;提供写回的请求和限制信息，该结构也用于返回写回的结果。&lt;/p&gt;
&lt;h2 id=&quot;处理写回的错误&quot;&gt;处理写回的错误&lt;/h2&gt;
&lt;p&gt;大部分使用缓存IO的应用都会周期性地调用同步接口（如&lt;code&gt;fsync()&lt;/code&gt;，&lt;code&gt;fdatasync()&lt;/code&gt;，&lt;code&gt;msync()&lt;/code&gt;，&lt;code&gt;sync_file_rage()&lt;/code&gt;）来保证数据被写回到存储中。如果写回时发生错误，这些接口应当返回错误，但仅在第一次返回错误，后续应当返回0，除非又有新的数据写入且再次调用同步接口时又发生写回错误。&lt;/p&gt;
&lt;p&gt;理想情况下，内核应当以文件为单位，返回其写回的错误。但实际上page cache并没有以文件为单位追踪脏页，因此当发生写回错误时，内核无法知道是哪个文件发生的写回错误。当前当发生写回错误时，内核给所有打开的文件都返回错误，即使这个文件并没有写入或者已经写回成功了。&lt;/p&gt;
&lt;p&gt;想使用该框架的文件系统应当调用&lt;code&gt;mapping_set_error()&lt;/code&gt;来记录错误。在写回数据后，文件系统还应当调用&lt;code&gt;file_check_and_advance_wb_err()&lt;/code&gt;来确保&lt;code&gt;struct file::f_wb_err&lt;/code&gt;记录的是正确的写回错误。&lt;/p&gt;
&lt;h2 id=&quot;struct-address_space_operations&quot;&gt;struct address_space_operations&lt;/h2&gt;
&lt;p&gt;VFS使用该结构操作文件的page cache。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct address_space_operations {
    int (*writepage)(struct page *page, struct writeback_control *wbc);
    int (*readpage)(struct file *, struct page *);
    int (*writepages)(struct address_space *, struct writeback_control *);
    int (*set_page_dirty)(struct page *page);
    int (*readpages)(struct file *filp, struct address_space *mapping,
            struct list_head *pages, unsigned nr_pages);
    int (*write_begin)(struct file *, struct address_space *mapping,
                loff_t pos, unsigned len, unsigned flags,
                struct page **pagep, void **fsdata);
    int (*write_end)(struct file *, struct address_space *mapping,
                loff_t pos, unsigned len, unsigned copied,
                struct page *page, void *fsdata);
    sector_t (*bmap)(struct address_space *, sector_t);
    void (*invalidatepage) (struct page *, unsigned int, unsigned int);
    int (*releasepage) (struct page *, int);
    void (*freepage)(struct page *);
    ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);
    /* isolate a page for migration */
    bool (*isolate_page) (struct page *, isolate_mode_t);
    /* migrate the contents of a page to the specified target */
    int (*migratepage) (struct page *, struct page *);
    /* put migration-failed page back to right list */
    void (*putback_page) (struct page *);
    int (*launder_page) (struct page *);

    int (*is_partially_uptodate) (struct page *, unsigned long,
                    unsigned long);
    void (*is_dirty_writeback) (struct page *, bool *, bool *);
    int (*error_remove_page) (struct mapping *mapping, struct page *page);
    int (*swap_activate)(struct file *);
    int (*swap_deactivate)(struct file *);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;writepage：基于数据完整性（sync）或者释放内存（flush）的原因，VM会调用该方法将脏页写回到存储。写回过程：清除&lt;code&gt;PG_Dirty&lt;/code&gt;,设置&lt;code&gt;PageLocked&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;，然后writepage开始写回，并设置&lt;code&gt;PG_Writeback&lt;/code&gt;，然后在完成写回后解锁page。&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;wbc-&amp;gt;sync_mode&lt;/code&gt;是&lt;code&gt;WB_SYNC_NONE&lt;/code&gt;，那么writepage在无法完成写回指定页的情况下，返回&lt;code&gt;AOP_WRITEPAGE_ACTIVATE&lt;/code&gt;，这样VM就不会一直为该页调用writepage了。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;readpage：VM调用该方法从存储中读取一页的数据。该页会被锁定，但需要在读取完成后，标记为&lt;code&gt;uptodate&lt;/code&gt;并解锁。如果&lt;code&gt;readpage&lt;/code&gt;需要解锁，也可以解锁，并返回&lt;code&gt;AOP_TRUNCATED_PAGE&lt;/code&gt;。在这种情况下，VM会重新安置和加锁该页，再次调用&lt;code&gt;readpage&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;writepages：VM调用该方法将address space相关联的页都写回到存储。如果如果&lt;code&gt;wbc-&amp;gt;sync_mode&lt;/code&gt;是&lt;code&gt;WBC_SYNC_ALL&lt;/code&gt;，那么&lt;code&gt;writeback_control&lt;/code&gt;就会指定一组必须写回的页。如果是&lt;code&gt;WBC_SYNC_NONE&lt;/code&gt;的话，则只要求尽可能写入nr_to_write页。如果该方法未定义，那么会用&lt;code&gt;mpage_writepages&lt;/code&gt;来替代。该方法会从address space中获取所有标记为&lt;code&gt;DIRTY&lt;/code&gt;的页，然后传递给writepage&lt;/li&gt;
&lt;li&gt;set_page_dirty：VM调用该方法设置脏页。只有在address space中有私有数据的page且在页变脏时需要更新这些私有数据时，才需要该方法。如果定义了该方法，那么它必须设置&lt;code&gt;PageDirty&lt;/code&gt;标志和基数树中的&lt;code&gt;PAGECACHE_TAG_DIRTY&lt;/code&gt;标志。&lt;/li&gt;
&lt;li&gt;readpages：VM调用该方法读取address space相关联的页。这个方法本质上是多次调用readpage。readpages只用于预读，因此读取错误被忽略了。&lt;/li&gt;
&lt;li&gt;write_begin：由&lt;code&gt;generic_perform_write()&lt;/code&gt;调用，用于告知文件系统准备在指定偏移处写len字节的数据。address space应预留一些资源保证完成这次写入操作。如果写入要更新页中的一部分，那么需要将整页块读取到内存中，即读改写。文件系统通过pagep返回page cache中&lt;strong&gt;已锁定的page&lt;/strong&gt;。调用者会将数据写入到该page中。需要支持实际写入的数据长度小于传给&lt;code&gt;write_begin&lt;/code&gt;的长度的场景。可通过fsdata保存需要传递给write_end的数据。&lt;/li&gt;
&lt;li&gt;write_end：该函数必须在成功调用write_begin和拷贝数据后被调用。len是传递给write_begin的len，copied则是实际拷贝的长度。文件系统必须释放page的锁和引用，并更新&lt;code&gt;struct inode::i_size&lt;/code&gt;。失败返回小于0，否则返回实际拷贝到page cache的长度。&lt;/li&gt;
&lt;li&gt;bmap：VFS调用该方法将逻辑块偏移映射为物理块序号。该方法用于&lt;code&gt;ioctl(FIBMAP)&lt;/code&gt;和swap文件。为了swap一个文件，文件必须固定地映射到一个块设备上。swap系统会通过bmap来找到文件所在的块，然后直接存储，而不通过文件系统。&lt;/li&gt;
&lt;li&gt;invalidatepage：如果page设置了&lt;code&gt;PagePrivate&lt;/code&gt;，那么当部分或全部的page从address space中被移除时，就会调用invalidatepage。&lt;/li&gt;
&lt;li&gt;releasepage：释放标记为&lt;code&gt;PagePrivate&lt;/code&gt;的page，该方法需要移除page的私有数据，并清除&lt;code&gt;PagePrivate&lt;/code&gt;。如果该方法失败了则返回0。releasepage用于两种场景&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;VM发现一个没有活动用户的干净page，并向释放该page。如果释放成功，那么该页就会从address space中移除，变为自由的page。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;需要让address space中的部分或全部page失效。这种场景由&lt;code&gt;fadvise(POSIX_FADV_DONTNEED)&lt;/code&gt;触发，或者文件系统明确请求（比如当nfs和9fs认为cache的数据已经与存储不一致时，会调用&lt;code&gt;invalidate_inode_pages2()&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;freepage：一旦page在page cache中不可见时，为了允许清除私有数据，就会调用该方法。因为该方法可能被内存回收者调用，所以该方法不能假设原始的address space还存在，也不应当阻塞。&lt;/li&gt;
&lt;li&gt;direct_IO：由&lt;code&gt;generic read/write&lt;/code&gt;类函数调用来执行direct IO。&lt;/li&gt;
&lt;li&gt;isolate_page：VM在需要隔离一个可移动的非LRU的page时调用。如果成功了，VM会通过&lt;code&gt;__SetPageIsolated&lt;/code&gt;将该页标记为&lt;code&gt;PG_isolated&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;migrate_page：该方法用于压缩物理内存使用量。如果VM想重新放置page（可能是内存卡的故障信号触发的），就会传递一个老page和一个新page给这个方法。该方法需要传输私有数据，并更新所有引用。&lt;/li&gt;
&lt;li&gt;putback_page：当已隔离的页迁移失败时，VM会调用该方法。&lt;/li&gt;
&lt;li&gt;launder_page：在释放页前调用。该方法将脏页写回存储并避免重新弄脏该页，在整个过程中，都会加锁。&lt;/li&gt;
&lt;li&gt;is_partially_uptodate：块大小不等于页大小，一页可能包含多个块。如果VM读取到所需的块数据，那么就无需等待整个页读取完毕。&lt;/li&gt;
&lt;li&gt;is_dirty_writeback：当VM想回收page时调用。VM会根据dirty和writeback的值决定是否需要停顿回收页，以便能完成某些IO。通常情况下，VM可以使用&lt;code&gt;PageDirty&lt;/code&gt;和&lt;code&gt;PageWriteback&lt;/code&gt;，但是某些文件系统会有更复杂的状态（比如NFS的unstable pages需要避免被回收），或者因为锁的问题没有设置这些标志。该方法可以向VM表明该页是脏页或正在写回的页，让VM停止回收该页。&lt;/li&gt;
&lt;li&gt;error_remove_page：如果&lt;code&gt;truncation&lt;/code&gt;是正常的话，通常设置为&lt;code&gt;generic_error_remove_page()&lt;/code&gt;。主要用于处理内存失败。实现该方法，意味着你会处理那些页，除非你已经锁定或者增加了引用计数。&lt;/li&gt;
&lt;li&gt;swap_activate：当文件使用了swapon时调用，用于分配空间并将块的查询信息保存在内存中。返回0代表成功，也意味着该文件可以被当做备份的交换空间。&lt;/li&gt;
&lt;li&gt;swap_deactivate：当swap_activate成功后，调用该方法使得该文件变为swapoff。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个file对象代表进程打开的一个文件。&lt;/p&gt;
&lt;h2 id=&quot;struct-file_operations&quot;&gt;struct file_operations&lt;/h2&gt;
&lt;p&gt;VFS使用&lt;code&gt;struct file_operations&lt;/code&gt;操作一个打开的文件。&lt;/p&gt;
&lt;p&gt;自v4.18，&lt;code&gt;struct file_operations&lt;/code&gt;定义如下&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct file_operations {
    struct module *owner;
    loff_t (*llseek) (struct file *, loff_t, int);
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
    ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
    int (*iterate) (struct file *, struct dir_context *);
    int (*iterate_shared) (struct file *, struct dir_context *);
    __poll_t (*poll) (struct file *, struct poll_table_struct *);
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
    long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
    int (*mmap) (struct file *, struct vm_area_struct *);
    int (*open) (struct inode *, struct file *);
    int (*flush) (struct file *, fl_owner_t id);
    int (*release) (struct inode *, struct file *);
    int (*fsync) (struct file *, loff_t, loff_t, int datasync);
    int (*fasync) (int, struct file *, int);
    int (*lock) (struct file *, int, struct file_lock *);
    ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
    unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
    int (*check_flags)(int);
    int (*flock) (struct file *, int, struct file_lock *);
    ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
    ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
    int (*setlease)(struct file *, long, struct file_lock **, void **);
    long (*fallocate)(struct file *file, int mode, loff_t offset,
              loff_t len);
    void (*show_fdinfo)(struct seq_file *m, struct file *f);
#ifndef CONFIG_MMU
    unsigned (*mmap_capabilities)(struct file *);
#endif
    ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
    int (*clone_file_range)(struct file *, loff_t, struct file *, loff_t, u64);
    int (*dedupe_file_range)(struct file *, loff_t, struct file *, loff_t, u64);
    int (*fadvise)(struct file *, loff_t, loff_t, int);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除非额外说明，否则这些函数都不会持锁调用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;read_iter：支持将文件数据读取到非连续的内存中&lt;/li&gt;
&lt;li&gt;write_iter：支持将非连续内存中的数据写入到文件中。&lt;/li&gt;
&lt;li&gt;iterate：读取目录内容&lt;/li&gt;
&lt;li&gt;iterate_shared：当文件系统支持并发的目录迭代时，使用该函数读取目录内容&lt;/li&gt;
&lt;li&gt;compat_ioctl：在64位内核上兼容32位的系统调用&lt;/li&gt;
&lt;li&gt;open：创建一个新的&lt;code&gt;struct file&lt;/code&gt;，并初始化&lt;code&gt;strutc file::private_data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;flush：由&lt;code&gt;close(2)&lt;/code&gt;调用&lt;/li&gt;
&lt;li&gt;release：当文件的引用计数为0时调用&lt;/li&gt;
&lt;li&gt;fasync：文件为非阻塞模式时，由&lt;code&gt;fcntl(2)&lt;/code&gt;调用&lt;/li&gt;
&lt;li&gt;lock：由&lt;code&gt;fcntl(2)&lt;/code&gt;调用，执行&lt;code&gt;F_GETLK&lt;/code&gt;，&lt;code&gt;F_SETLK&lt;/code&gt;，&lt;code&gt;F_SETLKW&lt;/code&gt;命令&lt;/li&gt;
&lt;li&gt;fallocate：预分配block&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dentry属于VFS和单个文件系统，与设备驱动无关。每个dentry都有一个指向其父dentry的指针，以及一个子dentry的hash链表。&lt;/p&gt;
&lt;h2 id=&quot;struct-dentry_operations&quot;&gt;struct dentry_operations&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;struct dentry_operations&lt;/code&gt;是可选的，可以设置为NULL，或是使用VFS默认的函数。&lt;/p&gt;
&lt;p&gt;v2.6.22中，其定义如下&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;struct dentry_operations {
    int (*d_revalidate)(struct dentry *, unsigned int);
    int (*d_weak_revalidate)(struct dentry *, unsigned int);
    int (*d_hash)(const struct dentry *, struct qstr *);
    int (*d_compare)(const struct dentry *,
            unsigned int, const char *, const struct qstr *);
    int (*d_delete)(const struct dentry *);
    int (*d_init)(struct dentry *);
    void (*d_release)(struct dentry *);
    void (*d_iput)(struct dentry *, struct inode *);
    char *(*d_dname)(struct dentry *, char *, int);
    struct vfsmount *(*d_automount)(struct path *);
    int (*d_manage)(const struct path *, bool);
    struct dentry *(*d_real)(struct dentry *, const struct inode *);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;d_revalidate：当在cache中找到dentry时，判断dentry是否有效，返回正数代表还有效，返回0或负数代表无效。大多数本地文件系统将其设为NULL，因为它们的dentry总是有效的。网络文件系统则不同，因为服务端的变更，客户端可能感知不到。&lt;/li&gt;
&lt;li&gt;d_weak_revalidate&lt;/li&gt;
&lt;li&gt;d_hash：计算hash值，根据hash值加入父dentry的hash表中&lt;/li&gt;
&lt;li&gt;d_compare：比较dentry的名字，必须是常熟且幂等&lt;/li&gt;
&lt;li&gt;d_delete：判断是否删除dentry。返回1表示立即删除，返回0代表缓存。d_delete必须是常熟且幂等&lt;/li&gt;
&lt;li&gt;d_init：当分配dentry后调用，初始化dentry&lt;/li&gt;
&lt;li&gt;d_release：释放dentry&lt;/li&gt;
&lt;li&gt;d_iput：归还inode引用（在d_release前调用）。如果是NULL，VFS会调用&lt;code&gt;iput()&lt;/code&gt;，否则需要自行调用&lt;code&gt;iput()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;d_dname：当需要生成dentry的路径名时调用。对于伪文件系统（sockfs，pipefs）延迟生成路径名来说很有用。因为没有加锁，所以d_dname不能修改dentry本身&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;directory-entry-cache-api&quot;&gt;Directory Entry Cache API&lt;/h2&gt;
&lt;p&gt;以下是操作dentry的函数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;dget()&lt;/code&gt;：获取一个已存在的dentry的引用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dput()&lt;/code&gt;：归还一个dentry的引用。如果引用计数为0，且该dentry还在其父dentry的hash表中，则调用&lt;code&gt;d_delete()&lt;/code&gt;检查该dentry是否还应该缓存。如果需要缓存，则放入LRU链表中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d_drop()&lt;/code&gt;：从父dentry的hash表中删除dentry&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d_delete()&lt;/code&gt;：删除一个dentry，如果没有其他引用，则该dentry变为一个无效的dentry（即指向NULL inode），&lt;code&gt;d_iput()&lt;/code&gt;就会被调用。如果还有引用，则调用&lt;code&gt;d_drop()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d_add()&lt;/code&gt;：将dentry加入到其父dentry的hash表中，然后调用&lt;code&gt;d_instantiate()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d_instantiate()&lt;/code&gt;：将dentry加入到inode的dentry链表中，并更新dentry指向的inode（即&lt;code&gt;struct dentry::d_inode&lt;/code&gt;）。inode的引用计数也会增加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d_lookup()&lt;/code&gt;：查找dentry，如果找到了则增加引用计数后返回。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 26 May 2019 03:50:00 +0000</pubDate>
<dc:creator>一罪</dc:creator>
<og:description>翻译自Linux文档中的vfs.txt 介绍 VFS（Virtual File System）是内核提供的文件系统抽象层，其提供了文件系统的操作接口，可以隐藏底层不同文件系统的实现。 Directir</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yizui/p/10890939.html</dc:identifier>
</item>
<item>
<title>PV、PVC、StorageClass讲解 - 昀溪</title>
<link>http://www.cnblogs.com/rexcheny/p/10925464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rexcheny/p/10925464.html</guid>
<description>&lt;p&gt;为了方便开发人员更加容易的使用存储才出现的概念。通常我们在一个POD中定义使用存储是这样的方式，我们以hostpath类型来说：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - image: nginx
    name: mynginx
    volumeMounts:
    - mountPath: /usr/share/nginx/html
      name: html
  volumes:
  - name: html # 名称
    hostPath: # 存储类型
      path: /data # 物理节点上的真实路径
      type: Directory # 如果该路径不存在讲如何处理，Directory是要求目录必须存在&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实通过上面可以看出来，无论你使用什么类型的存储你都需要手动定义，指明存储类型以及相关配置。这里的hostpath类型还是比较简单的，如果是其他类型的比如分布式存储，那么这对开发人员来说将会是一种挑战，因为毕竟真正的存储是由存储管理员来设置的他们会更加了解，那么有没有一种方式让我们使用存储更加容易，对上层使用人员屏蔽底层细节呢？答案是肯定的，这就是PV、PVC的概念。不过需要注意的是我们在集群中通常不使用hostPath、emptyDir这种类型，除非你只是测试使用。&lt;/p&gt;
&lt;h2 id=&quot;什么是pv&quot;&gt;什么是PV&lt;/h2&gt;
&lt;p&gt;PV全称叫做Persistent Volume，持久化存储卷。它是用来描述或者说用来定义一个存储卷的，这个通常都是有运维或者数据存储工程师来定义。比如下面我们定义一个NFS类型的PV：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:  # PV建立不要加名称空间，因为PV属于集群级别的
  name: nfs-pv001  # PV名称
  labels: # 这些labels可以不定义
    name: nfs-pv001
    storetype: nfs
spec:  # 这里的spec和volumes里面的一样
  storageClassName: normal
  accessModes:  # 设置访问模型
    - ReadWriteMany
    - ReadWriteOnce
    - ReadOnlyMany
  capacity: # 设置存储空间大小
    storage: 500Mi
  persistentVolumeReclaimPolicy: Retain # 回收策略
  nfs:
    path: /work/volumes/v1
    server: stroagesrv01.contoso.com&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;accessModes：支持三种类型&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ReadWriteMany 多路读写，卷能被集群多个节点挂载并读写&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ReadWriteOnce 单路读写，卷只能被单一集群节点挂载读写&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;ReadOnlyMany 多路只读，卷能被多个集群节点挂载且只能读&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里的访问模型总共有三种，但是不同的存储类型支持的访问模型不同，具体支持什么需要查询官网。比如我们这里使用nfs，它支持全部三种。但是ISCI就不支持ReadWriteMany；HostPath就不支持ReadOnlyMany和ReadWriteMany。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;persistentVolumeReclaimPolicy：也有三种策略，这个策略是当与之关联的PVC被删除以后，这个PV中的数据如何被处理&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Retain 当删除与之绑定的PVC时候，这个PV被标记为released（PVC与PV解绑但还没有执行回收策略）且之前的数据依然保存在该PV上，但是该PV不可用，需要手动来处理这些数据并删除该PV。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Delete 当删除与之绑定的PVC时候&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Recycle 这个在1.14版本中以及被废弃，取而代之的是推荐使用动态存储供给策略，它的功能是当删除与该PV关联的PVC时，自动删除该PV中的所有数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：PV必须先与POD创建，而且只能是网络存储不能属于任何Node，虽然它支持HostPath类型但由于你不知道POD会被调度到哪个Node上，所以你要定义HostPath类型的PV就要保证所有节点都要有HostPath中指定的路径。&lt;/p&gt;
&lt;h2 id=&quot;pvc&quot;&gt;PVC&lt;/h2&gt;
&lt;p&gt;PVC是用来描述希望使用什么样的或者说是满足什么条件的存储，它的全称是Persistent Volume Claim，也就是持久化存储声明。开发人员使用这个来描述该容器需要一个什么存储。比如下面使用NFS的PVC：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: nfs-pvc001
  namespace: default
  labels: # 这些labels可以不定义
    name: nfs-pvc001
    storetype: nfs
    capacity: 500Mi
spec:
  storageClassName: normal
  accessModes:  # PVC也需要定义访问模式，不过它的模式一定是和现有PV相同或者是它的子集，否则匹配不到PV
  - ReadWriteMany
  resources: # 定义资源要求PV满足这个PVC的要求才会被匹配到
    requests:
      storage: 500Mi  # 定义要求有多大空间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个PVC就会和上面的PV进行绑定，为什么呢？它有一些原则：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PV和PVC中的spec关键字段要匹配，比如存储（storage）大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PV和PVC中的storageClassName字段必须一致，这个后面再说。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上面的labels中的标签只是增加一些描述，对于PVC和PV的绑定没有关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448094/201905/1448094-20190526112210809-1558254013.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用了上面的PV和PVC，可以看到自动绑定了。&lt;/p&gt;
&lt;h2 id=&quot;在pod中如何使用pvc呢&quot;&gt;在POD中如何使用PVC呢&lt;/h2&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: tomcat-deploy
spec:
  replicas: 1
  selector:
    matchLabels:
      appname: myapp
  template:
    metadata:
      name: myapp
      labels:
        appname: myapp
    spec:
      containers:
      - name: myapp
        image: tomcat:8.5.38-jre8
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        volumeMounts:
          - name: tomcatedata
            mountPath : &quot;/data&quot;
      volumes:
        - name: tomcatedata
          persistentVolumeClaim:
            claimName: nfs-pvc001&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里通过volumes来声明使用哪个PVC，可以看到和自己定义持久化卷类似，但是这里更加简单了，直接使用PVC的名字即可。在容器中使用/data目录就会把数据写入到NFS服务器上的目录中。&lt;/p&gt;
&lt;p&gt;当我们删除那个PVC的时候，该PV变成Released状态，由于我们的策略是Retain，所以如果想让这个PV变为可用我们就需要手动清理数据并删除这个PV。这里你可能会觉得矛盾，你让这个PV变为可用，为什么还要删除这个PV呢？其实所谓可用就是删除这个PV然后建立一个同名的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448094/201905/1448094-20190526112222092-319841648.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出来PVC就相当于是容器和PV之间的一个接口，使用人员只需要和PVC打交道即可。另外你可能也会想到如果当前环境中没有合适的PV和我的PVC绑定，那么我创建的POD不就失败了么？的确是这样的，不过如果发现这个问题，那么就赶快创建一个合适的PV，那么这时候持久化存储循环控制器会不断的检查PVC和PV，当发现有合适的可以绑定之后它会自动给你绑定上然后被挂起的POD就会自动启动，而不需要你重建POD。&lt;/p&gt;
&lt;h2 id=&quot;什么是持久化存储&quot;&gt;什么是持久化存储&lt;/h2&gt;
&lt;p&gt;我们知道所谓容器挂载卷就是将宿主机的目录挂载到容器中的某个目录。而持久化则意味着这个目录里面的内容不会因为容器被删除而清除，也不会和当前宿主机有什么直接关系，而是一个外部的。这样当POD重建以后或者在其他主机节点上启动后依然可以访问这些内容。不过之前说过hostPath和emptyDir则推荐使用，因为前者和当前宿主机有必然联系而后者就是一个随POD删除而被删除的临时目录。&lt;/p&gt;
&lt;h2 id=&quot;宿主机是如何挂载远程目录的&quot;&gt;宿主机是如何挂载远程目录的&lt;/h2&gt;
&lt;p&gt;挂载过程会有不同，这取决于远程存储的类型，它是块设备存储还是文件设备存储。但是不管怎么样POD有这样一个目录&lt;code&gt;/var/lib/kubelet/pods/&amp;lt;Pod 的 ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume 类型 &amp;gt;/&amp;lt;Volume 名字 &amp;gt;&lt;/code&gt;这个目录是POD被调度到该节点之后，由kubelet为POD创建的。因为它一定会被创建，因为系统中的默认secret就会被挂载到这里。之后就要根据存储设备类型的不同做不同处理。&lt;/p&gt;
&lt;h3 id=&quot;文件存储设备&quot;&gt;文件存储设备&lt;/h3&gt;
&lt;p&gt;以nfs这种文件设备存储来说。我们依然启动之前的容器继续使用之前的PVC。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448094/201905/1448094-20190526112233956-2020699942.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于这个POD运行在node01节点，我们登陆node01节点，查看这个目录&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/var/lib/kubelet/pods/&amp;lt;Pod 的 ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume 类型 &amp;gt;/&amp;lt;Volume 名字 &amp;gt;&lt;/code&gt;当你创建POD的时候它由于它被调度到node01节点，所以会创建这个目录，而且根据YAML中的定义就也会在这个目录中创建你在volumesMount中定义的目录，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448094/201905/1448094-20190526112244862-45730824.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过命令查看在本地宿主机的挂载情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448094/201905/1448094-20190526112253999-811269512.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于创建了必要的目录，那么kubelet就直接使用mount命令把nfs目录挂载到这个目录上&lt;code&gt;volumes/kubernetes.io~&amp;lt;type&amp;gt;/&amp;lt;Volume 名字&amp;gt;&lt;/code&gt;，注意这时候仅仅是把这个远程存储挂载到宿主机目录上，要想让容器使用还需要做调用相关接口来把这个宿主机上的目录挂载到容器上。所以当准备好之后启动容器的时候就是利用CRI里的mounts参数把这个宿主机的目录挂载到容器中指定的目录上，就相当于执行&lt;code&gt;docker run -v&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;不过需要注意的是由于nfs文件存储不是一个块设备，所以宿主机系统需要扮演的就是nfs客户端角色，kubelet就是调用这个客户端工具来完成挂载的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;块存储设备&quot;&gt;块存储设备&lt;/h3&gt;
&lt;p&gt;块存储设备你可以理解为一个磁盘。这个的处理要稍微复杂一点，就好像你为Linux服务器添加一块磁盘一样，你得先安装然后分区格式化之后挂载到某个目录使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/var/lib/kubelet/pods/&amp;lt;Pod 的 ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume 类型 &amp;gt;/&amp;lt;Volume 名字 &amp;gt;&lt;/code&gt;这个目录依然会创建。当POD被调度到该节点上会做如下操作&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;首先要安装一个块设备存储到宿主机（不是物理安装，而是通过API来安装），如何安装取决于不同块存储设备的API，很多云厂商有这种块存储设备比如Google的GCE。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;格式化磁盘，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;把格式化好的磁盘设备挂载到宿主机上的目录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;启动容器挂载宿主机上的目录到容器中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相对于文件设备存储来说块设备要稍微复杂一点，不过上面这些过程都是自动的有kubelet来完成。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;负责把PVC绑定到PV的是一个持久化存储卷控制循环，这个控制器也是kube-manager-controller的一部分运行在master上。而真正把目录挂载到容器上的操作是在POD所在主机上发生的，所以通过kubelet来完成。而且创建PV以及PVC的绑定是在POD被调度到某一节点之后进行的，完成这些操作，POD就可以运行了。下面梳理一下挂载一个PV的过程：&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用户提交一个包含PVC的POD&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调度器把根据各种调度算法把该POD分配到某个节点，比如node01&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Node01上的kubelet等待Volume Manager准备存储设备&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;PV控制器调用存储插件创建PV并与PVC进行绑定&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Attach/Detach Controller或Volume Manager通过存储插件实现设备的attach。（这一步是针对块设备存储）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Volume Manager等待存储设备变为可用后，挂载该设备到&lt;code&gt;/var/lib/kubelet/pods/&amp;lt;Pod 的 ID&amp;gt;/volumes/kubernetes.io~&amp;lt;Volume 类型 &amp;gt;/&amp;lt;Volume 名字 &amp;gt;&lt;/code&gt;目录上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Kubelet被告知卷已经准备好，开始启动POD，通过映射方式挂载到容器中&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;storageclass&quot;&gt;StorageClass&lt;/h2&gt;
&lt;p&gt;PV是运维人员来创建的，开发操作PVC，可是大规模集群中可能会有很多PV，如果这些PV都需要运维手动来处理这也是一件很繁琐的事情，所以就有了动态供给概念，也就是Dynamic Provisioning。而我们上面的创建的PV都是静态供给方式，也就是Static Provisioning。而动态供给的关键就是StorageClass，它的作用就是创建PV模板。&lt;/p&gt;
&lt;p&gt;创建StorageClass里面需要定义PV属性比如存储类型、大小等；另外创建这种PV需要用到存储插件。最终效果是，用户提交PVC，里面指定存储类型，如果符合我们定义的StorageClass，则会为其自动创建PV并进行绑定。&lt;/p&gt;
&lt;p&gt;我们这里演示一下NFS的动态PV创建&lt;/p&gt;
&lt;blockquote readability=&quot;5.4174757281553&quot;&gt;
&lt;p&gt;kubernetes本身支持的动态PV创建不包括nfs，所以需要使用额外插件实现。&lt;a href=&quot;https://github.com/kubernetes-incubator/external-storage/tree/master/nfs-client&quot;&gt;nfs-client&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我这里就按照网站的例子来创建，里面的内容毫无修改，当然你需要自己准备NFS服务器。由于用于提供动态创建PV的程序是运行在POD中，所以你需要保证你的Kubernetes节点到NFS的网络通畅，我这里就在我的Kubernetes集群的某个节点上建立的NFS服务。下面是PVC文件&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mytomcat-pvc
spec:
  storageClassName:  managed-nfs-storage
  accessModes:
    - ReadWriteMany
  resources: 
    requests:
      storage: 500Mi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你应用这个PVC的时候，由于例子中的storageClassName也是managed-nfs-storage（当然这个名字你可以修改）就会去自动创建PV。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448094/201905/1448094-20190526112335993-2023842158.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是在Node02这个节点上看到的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448094/201905/1448094-20190526112348433-1402117465.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基于这种形式，我们只需要根据我们有的存储系统来定义StorageClass，通过名称来标识不同种类的存储，比如SSD、block-device这种名称，而不需要定义具体大小。那么使用人员就可以根据需要通过StorageClass的名字来使用，从而实现动态创建PV的过程。&lt;/p&gt;
&lt;p&gt;这里有个要求就是你的存储系统需要提供某种接口来让controller可以调用并传递进去PVC的参数去创建PV，很多云存储都支持。可是也有不支持的，比如NFS就不支持所以我们需要一个单独的插件来完成这个工作。也就是例子中使用的&lt;code&gt;quay.io/external_storage/nfs-client-provisioner&lt;/code&gt;镜像，但是创建PV也需要相关权限，也就是例子中rabc.yaml部分。在定义StorageClass中有一个叫做&lt;code&gt;provisioner: fuseim.pri/ifs&lt;/code&gt;这个就是插件的名称，这个名称其实也就是官方例子中deployment中设置的名字，这个名字你可以修改。&lt;/p&gt;
&lt;p&gt;当然我们说过有些本身就支持，比如下面的kubernetes官网中的一个AWS的例子：&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: slow
provisioner: kubernetes.io/aws-ebs
parameters:
  type: io1
  iopsPerGB: &quot;10&quot;
  fsType: ext4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;kubernetes.io/aws-ebs&lt;/code&gt;就是kubernetes内置的存储插件名称，如果你使用aws就用这个名称就好。因为kubernetes就会去调用AWS的API来创建存储然后在创建PV。&lt;/p&gt;
&lt;p&gt;这里你可能会有个疑问，为什么开篇的例子里面也用了&lt;code&gt;storageClassName: normal&lt;/code&gt;，可是我们并没有定义任何StorageClass。其实虽然我们使用了，但是系统上并没有一个叫做normal的存储类，这时候还是静态绑定，只是绑定的时候它会考虑你的PV和PVC中的存储类名称是否一致。当然如果是静态绑定你可以不写&lt;code&gt;storageClassName&lt;/code&gt;，因为如果开起一个的叫做&lt;code&gt;DefaultStorageClass&lt;/code&gt;plugin插件就会默认有这样一个存储类，它会自动添加到你的任何没有明确声明&lt;code&gt;storageClassName&lt;/code&gt;的PV和PVC中。&lt;/p&gt;
&lt;h2 id=&quot;本地持久化存储&quot;&gt;本地持久化存储&lt;/h2&gt;
&lt;p&gt;本地持久化存储（Local Persistent Volume）就是把数据存储在POD运行的宿主机上，我们知道宿主机有hostPath和emptyDir，由于这两种的特定不适用于本地持久化存储。那么本地持久化存储必须能保证POD被调度到具有本地持久化存储的节点上。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为什么需要这种类型的存储呢？有时候你的应用对磁盘IO有很高的要求，网络存储性能肯定不如本地的高，尤其是本地使用了SSD这种磁盘。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但这里有个问题，通常我们先创建PV，然后创建PVC，这时候如果两者匹配那么系统会自动进行绑定，哪怕是动态PV创建，也是先调度POD到任意一个节点，然后根据PVC来进行创建PV然后进行绑定最后挂载到POD中，可是本地持久化存储有一个问题就是这种PV必须要先准备好，而且不一定集群所有节点都有这种PV，如果POD随意调度肯定不行，如何保证POD一定会被调度到有PV的节点上呢？这时候就需要在PV中声明节点亲和，且POD被调度的时候还要考虑卷的分布情况。&lt;/p&gt;
&lt;p&gt;定义PV&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv
spec:
  capacity:
    storage: 5Gi
  volumeMode: Filesystem
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage
  local: # local类型
    path: /data/vol1  # 节点上的具体路径
  nodeAffinity: # 这里就设置了节点亲和
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - node01 # 这里我们使用node01节点，该节点有/data/vol1路径&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果你在node02上也有/data/vol1这个目录，上面这个PV也一定不会在node02上，因为下面的nodeAffinity设置了主机名就等于node01。&lt;/p&gt;
&lt;p&gt;另外这种本地PV通常推荐使用的是宿主机上单独的硬盘设备，而不是和操作系统共有一块硬盘，虽然可以这样用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定义存储类&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: local-storage
provisioner: kubernetes.io/no-provisioner
volumeBindingMode: WaitForFirstConsumer&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;volumeBindingMode: WaitForFirstConsumer&lt;/code&gt;很关键，意思就是延迟绑定，当有符合PVC要求的PV不立即绑定。因为POD使用PVC，而绑定之后，POD被调度到其他节点，显然其他节点很有可能没有那个PV所以POD就挂起了，另外就算该节点有合适的PV，而POD被设置成不能运行在该节点，这时候就没法了，延迟绑定的好处是，POD的调度要参考卷的分布。当开始调度POD的时候看看它要求的LPV在哪里，然后就调度到该节点，然后进行PVC的绑定，最后在挂载到POD中，这样就保证了POD所在的节点就一定是LPV所在的节点。所以让PVC延迟绑定，就是等到使用这个PVC的POD出现在调度器上之后（真正被调度之前），然后根据综合评估再来绑定这个PVC。&lt;/p&gt;
&lt;p&gt;定义PVC&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: local-claim
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  storageClassName: local-storage&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448094/201905/1448094-20190526112405478-1871202194.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这个PVC是pending状态，这也就是延迟绑定，因为此时还没有POD。&lt;/p&gt;
&lt;p&gt;定义POD&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: tomcat-deploy
spec:
  replicas: 1
  selector:
    matchLabels:
      appname: myapp
  template:
    metadata:
      name: myapp
      labels:
        appname: myapp
    spec:
      containers:
      - name: myapp
        image: tomcat:8.5.38-jre8
        ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        volumeMounts:
          - name: tomcatedata
            mountPath : &quot;/data&quot;
      volumes:
        - name: tomcatedata
          persistentVolumeClaim:
            claimName: local-claim&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1448094/201905/1448094-20190526112417378-513268410.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个POD被调度到node01上，因为我们的PV就在node01上，这时候你删除这个POD，然后在重建该POD，那么依然会被调度到node01上。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;总结&lt;/em&gt;：本地卷也就是LPV不支持动态供给的方式，延迟绑定，就是为了综合考虑所有因素再进行POD调度。其根本原因是动态供给是先调度POD到节点，然后动态创建PV以及绑定PVC最后运行POD；而LPV是先创建与某一节点关联的PV，然后在调度的时候综合考虑各种因素而且要包括PV在哪个节点，然后再进行调度，到达该节点后在进行PVC的绑定。也就说动态供给不考虑节点，LPV必须考虑节点。所以这两种机制有冲突导致无法在动态供给策略下使用LPV。换句话说动态供给是PV跟着POD走，而LPV是POD跟着PV走。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/volumes/&quot;&gt;kubernetes支持的存储类型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/storage/storage-classes/&quot;&gt;Kubernetes支持的动态PV创建类型&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 26 May 2019 03:25:00 +0000</pubDate>
<dc:creator>昀溪</dc:creator>
<og:description>在Kubernetes中如何方便的使用存储呢？PV、PVC、StorageClass将会为你带来答案</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rexcheny/p/10925464.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 中间件基本用法 - qifei2012</title>
<link>http://www.cnblogs.com/youring2/p/10924705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youring2/p/10924705.html</guid>
<description>&lt;p&gt;ASP.NET Core的处理流程是一个管道，而中间件是装配到管道中的用于处理请求和响应的组件。中间件按照装配的先后顺序执行，并决定是否进入下一个组件。中间件管道的处理流程如下图（图片来源于官网）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/index/_static/request-delegate-pipeline.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;管道式的处理方式，更加方便我们对程序进行扩展。&lt;/p&gt;
&lt;h2 id=&quot;使用中间件&quot;&gt;使用中间件&lt;/h2&gt;
&lt;p&gt;ASP.NET Core中间件模型是我们能够快捷的开发自己的中间件，完成对应用的扩展，我们先从一个简单的例子了解一下中间件的开发。&lt;/p&gt;
&lt;h3 id=&quot;run&quot;&gt;Run&lt;/h3&gt;
&lt;p&gt;首先，我们创建一个ASP.NET Core 应用，在Startup.cs中有如下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.Run(async (context) =&amp;gt;
{
    await context.Response.WriteAsync(&quot;Hello World!&quot;);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码中，使用Run方法运行一个委托，这就是最简单的中间件，它拦截了所有请求，返回一段文本作为响应。Run委托终止了管道的运行，因此也叫作&lt;strong&gt;终端中间件&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;use&quot;&gt;Use&lt;/h3&gt;
&lt;p&gt;我们再看另外一个例子：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.Use(async (context, next) =&amp;gt;
{
    //Do something here
    
    //Invoke next middleware
    await next.Invoke();
    
    //Do something here
    
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码中，使用Use方法运行一个委托，我们可以在Next调用之前和之后分别执行自定义的代码，从而可以方便的进行日志记录等工作。这段代码中，使用next.Invoke()方法调用下一个中间件，从而将中间件管道连贯起来；如果不调用next.Invoke()方法，则会造成&lt;strong&gt;管道短路&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;map和mapwhen&quot;&gt;Map和MapWhen&lt;/h3&gt;
&lt;p&gt;处理上面两种方式，ASP.NET Core 还可以使用Map创建基于路径匹配的分支、使用MapWhen创建基于条件的分支。代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static void HandleMap(IApplicationBuilder app)
{
    app.Run(async context =&amp;gt;
    {
        await context.Response.WriteAsync(&quot;Handle Map&quot;);
    });
}

private static void HandleBranch(IApplicationBuilder app)
{
    app.Run(async context =&amp;gt;
    {
        var branchVer = context.Request.Query[&quot;branch&quot;];
        await context.Response.WriteAsync($&quot;Branch used = {branchVer}&quot;);
    });
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.Map(&quot;/map&quot;, HandleMap);
    
    app.MapWhen(context =&amp;gt; context.Request.Query.ContainsKey(&quot;branch&quot;),
               HandleBranch);
    
    app.Run(async context =&amp;gt;
    {
        await context.Response.WriteAsync(&quot;Hello World!&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码演示了如何使用Map和MapWhen创建基于路径和条件的分支。另外，Map方法还支持层级的分支，我们参照下面的代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.Map(&quot;/level1&quot;, level1App =&amp;gt; {
    level1App.Map(&quot;/level2a&quot;, level2AApp =&amp;gt; {
        // &quot;/level1/level2a&quot; processing
    });
    level1App.Map(&quot;/level2b&quot;, level2BApp =&amp;gt; {
        // &quot;/level1/level2b&quot; processing
    });
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意，使用 Map 时，将从 HttpRequest.Path 中删除匹配的Path，并针对每个请求将该线段追加到 HttpRequest.PathBase。例如对于路径&lt;code&gt;/level1/level2a&lt;/code&gt;，当在level1App中进行处理时，它的请求路径被截断为&lt;code&gt;/level2a&lt;/code&gt;，当在level2AApp中进行处理时，它的路径就变成&lt;code&gt;/&lt;/code&gt;了，而相应的PathBase会变为&lt;code&gt;/level1/level2a&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;开发中间件&quot;&gt;开发中间件&lt;/h2&gt;
&lt;p&gt;看到这里，我们已经知道中间件的基本用法，是时候写一个真正意义的中间件了。&lt;/p&gt;
&lt;h3 id=&quot;基于约定的中间件开发&quot;&gt;基于约定的中间件开发&lt;/h3&gt;
&lt;p&gt;在 ASP.NET Core 官网上面提供了一个简单的例子，通过中间件来设置应用的区域信息，代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app)
{
    app.Use((context, next) =&amp;gt;
    {
        var cultureQuery = context.Request.Query[&quot;culture&quot;];
        if (!string.IsNullOrWhiteSpace(cultureQuery))
        {
            var culture = new CultureInfo(cultureQuery);

            CultureInfo.CurrentCulture = culture;
            CultureInfo.CurrentUICulture = culture;
        }

        // Call the next delegate/middleware in the pipeline
        return next();
    });

    app.Run(async (context) =&amp;gt;
    {
        await context.Response.WriteAsync(
            $&quot;Hello {CultureInfo.CurrentCulture.DisplayName}&quot;);
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这段代码，我们可以通过QueryString的方式设置应用的区域信息。但是这样的代码怎样复用呢？注意，中间件一定要是可复用、方便复用的。我们来改造这段代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class RequestCultureMiddleware
{
    private readonly RequestDelegate _next;

    public RequestCultureMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        //......

        // Call the next delegate/middleware in the pipeline
        await _next(context);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义一个委托，用于执行具体的业务逻辑，然后在Configure中调用这个委托：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.UseMiddleware&amp;lt;RequestCultureMiddleware&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样还是不太方便，不像我们使用app.UseMvc()这么方便，那么我们来添加一个扩展方法，来实现更方便的复用：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class RequestCultureMiddlewareExtensions
{
    public static IApplicationBuilder UseRequestCulture(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&amp;lt;RequestCultureMiddleware&amp;gt;();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们就可以这样使用中间件了：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.UseRequestCulture();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过委托构造中间件，应用程序在运行时创建这个中间件，并将它添加到管道中。这里需要注意的是，中间件的创建是单例的，每个中间件在应用程序生命周期内只有一个实例。那么问题来了，如果我们业务逻辑需要多个实例时，该如何操作呢？请继续往下看。&lt;/p&gt;
&lt;h4 id=&quot;基于请求的依赖注入&quot;&gt;基于请求的依赖注入&lt;/h4&gt;
&lt;p&gt;通过上面的代码我们已经知道了如何编写一个中间件，如何方便的复用这个中间件。在中间件的创建过程中，容器会为我们创建一个中间件实例，并且整个应用程序生命周期中只会创建一个该中间件的实例。通常我们的程序不允许这样的注入逻辑。&lt;/p&gt;
&lt;p&gt;其实，我们可以把中间件理解成业务逻辑的入口，真正的业务逻辑是通过Application Service层实现的，我们只需要把应用服务注入到Invoke方法中即可。&lt;/p&gt;
&lt;p&gt;ASP.NET Core为我们提供了这种机制，允许我们按照请求进行依赖的注入，也就是每次请求创建一个服务。代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class CustomMiddleware
{
    private readonly RequestDelegate _next;

    public CustomMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    // IMyScopedService is injected into Invoke
    public async Task Invoke(HttpContext httpContext, IMyScopedService svc)
    {
        svc.MyProperty = 1000;
        await _next(httpContext);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码中，CustomMiddleware的实例仍然是单例的，但是IMyScopedService是按照请求进行注入的，每次请求都会创建IMyScopedService的实例，svc对象的生命周期是PerRequest的。&lt;/p&gt;
&lt;h4 id=&quot;基于约定的中间件模板&quot;&gt;基于约定的中间件模板&lt;/h4&gt;
&lt;p&gt;这里提供一个完整的示例，可以理解为一个中间件的开发模板，方便以后使用的时候参考。整个过程分以下几步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将业务逻辑封装到ApplicationService中&lt;/li&gt;
&lt;li&gt;创建中间件代理类&lt;/li&gt;
&lt;li&gt;创建中间件扩展类&lt;/li&gt;
&lt;li&gt;使用中间件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;namespace MiddlewareDemo
{
    using Microsoft.AspNetCore.Http;
    using System.Threading.Tasks;
    
    //1.定义并实现业务逻辑
    public interface IMyScopedService
    {
        int MyProperty { get; set; }
    }

    public class MyScopedService : IMyScopedService
    {
        public int MyProperty { get; set; }
    }

    //2.创建中间件代理类
    public class CustomMiddleware
    {
        private readonly RequestDelegate _next;

        public CustomMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        // IMyScopedService is injected into Invoke
        public async Task Invoke(HttpContext httpContext, IMyScopedService svc)
        {
            svc.MyProperty = 1000;
            await _next(httpContext);
        }
    }
}

//3.1 添加依赖服务注册
namespace Microsoft.Extensions.DependencyInjection
{
    using MiddlewareDemo;
    public static partial class CustomMiddlewareExtensions
    {
        /// &amp;lt;summary&amp;gt;
        /// 添加服务的依赖注册
        /// &amp;lt;/summary&amp;gt;
        public static IServiceCollection AddCustom(this IServiceCollection services)
        {
            return services.AddScoped&amp;lt;IMyScopedService, MyScopedService&amp;gt;();
        }

    }
}

//3.2 创建中间件扩展类
namespace Microsoft.AspNetCore.Builder
{
    using MiddlewareDemo;

    public static partial class CustomMiddlewareExtensions
    {
        /// &amp;lt;summary&amp;gt;
        /// 使用中间件
        /// &amp;lt;/summary&amp;gt;
        public static IApplicationBuilder UseCustom(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware&amp;lt;CustomMiddleware&amp;gt;();
        }
    }
}

//4. 使用中间件
public void ConfigureServices(IServiceCollection services)
{
    services.AddCustom();
}

public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    app.UseCustom();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于工厂激活的中间件&quot;&gt;基于工厂激活的中间件&lt;/h3&gt;
&lt;p&gt;我们前面介绍的中间件开发都是基于约定的，可以让我们快速上手进行开发。同时ASP.NET Core还提供了基于工厂激活的中间件开发方式，我们可以通过实现IMiddlewareFactory、IMiddleware接口进行中间件开发。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class FactoryActivatedMiddleware : IMiddleware
{
    private readonly AppDbContext _db;

    public FactoryActivatedMiddleware(AppDbContext db)
    {
        _db = db;
    }

    public async Task InvokeAsync(HttpContext context, RequestDelegate next)
    {
        var keyValue = context.Request.Query[&quot;key&quot;];

        if (!string.IsNullOrWhiteSpace(keyValue))
        {
            _db.Add(new Request()
                {
                    DT = DateTime.UtcNow, 
                    MiddlewareActivation = &quot;FactoryActivatedMiddleware&quot;, 
                    Value = keyValue
                });

            await _db.SaveChangesAsync();
        }

        await next(context);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码演示了如何使用基于工厂激活的中间件，在使用过程中有两点需要注意：1.需要在ConfigureServices中进行服务注册；2.在UseMiddleware()方法中不支持传递参数。&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
</description>
<pubDate>Sun, 26 May 2019 03:05:00 +0000</pubDate>
<dc:creator>qifei2012</dc:creator>
<og:description>ASP.NET Core 中间件 ASP.NET Core的处理流程是一个管道，而中间件是装配到管道中的用于处理请求和响应的组件。中间件按照装配的先后顺序执行，并决定是否进入下一个组件。中间件管道的处</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/youring2/p/10924705.html</dc:identifier>
</item>
<item>
<title>Jmeter(四十九)_常用的性能测试监听器 - 飞天小子</title>
<link>http://www.cnblogs.com/Zfc-Cjk/p/10925264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zfc-Cjk/p/10925264.html</guid>
<description>&lt;p&gt;&lt;span&gt;jmeter中提供了很多性能数据的监听器，我们通过监听器可以来分析性能瓶颈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文以500线程的阶梯加压测试结果来描述图表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526102254990-1606701119.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;常用监听器&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1：Transactions per Second&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监听动态TPS，用来分析吞吐量。&lt;/span&gt;&lt;span&gt;其中横坐标是运行时间，纵坐标是TPS值。红色表示通过的TPS，绿色表示失败的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最大TPS大约在140左右，从1分26秒左右，开始有未通过的事物&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526092537165-1810919856.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2：Hits per Second&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态监听单位时间的点击率，也就是触发的请求数。其中横坐标是运行时间，纵坐标是HPS值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;点击率波动较大，且不能持续上升。说明性能很不稳定&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526093203032-218893779.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3：Response Times Over Time&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监听整个事物运行期间的响应时间。其中横坐标是运行时间，纵坐标是响应时间（单位是毫秒）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;响应时间在4950ms左右开始稳定下来，后续又经历一次大的波动&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526093842567-1235493233.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4：Response Times vs Threads&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程活动期间的响应时间监听。其中横坐标是活动的线程数（也就是并发数），纵坐标是响应时间（单位是毫秒）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526094134743-1434008123.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;5： Active Threads Over Time&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监听单位时间内活动的线程数。其中横坐标是单位时间（单位是毫秒），纵坐标是活动线程数（也就是并发数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526095057717-1104609555.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6：Response Times Percentiles&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;监听响应时间分布的百分比。其中横坐标是请求数的百分比，纵坐标是响应时间。此图表示有99.7%的请求响应时间在5s以内。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526095329914-1841217966.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7：Response Times Distribution&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;响应时间分布的柱状图。其中横坐标是柱状分布图，纵坐标是响应时间。此图表示大约有111个请求响应时间在5076ms。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526095912039-392415670.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8：Composite Graph&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;组合式的监听器。其中横坐标是运行时间，纵坐标是各性能数据的汇总值（其中有一些数据需要除以10）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526100406654-149478928.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;不同的监听器可以监听不同的性能数据，但是想要在图表中直观的分析出性能的瓶颈，就需要组合式的监听器。例如通过响应时间和吞吐量的分布得出吞吐量的拐点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;通过以上图表能看出来，在持续加压的事物场景中，99.7%的请求响应时间都控制在了5s以内。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一篇文章，我们将通过实际项目来演示监听器在性能测试中的用法，同时分析一些性能瓶颈。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;同时会有视频公开课，用视频讲解的方式来给大家实际讲解哦！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://shang.qq.com/wpa/qunwpa?idkey=0ef7ec4bf4e0b832114b34583aecb7419b0a5537f57497c88acbbef93de5a5fd&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;☞点击这里，参加公开课&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可以添加微信：14751700162&lt;br/&gt;或者联系QQ：1144890271&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201905/946454-20190526101442813-1615381692.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 26 May 2019 02:17:00 +0000</pubDate>
<dc:creator>飞天小子</dc:creator>
<og:description>概述 jmeter中提供了很多性能数据的监听器，我们通过监听器可以来分析性能瓶颈 本文以500线程的阶梯加压测试结果来描述图表。 常用监听器 1：Transactions per Second 监听动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Zfc-Cjk/p/10925264.html</dc:identifier>
</item>
</channel>
</rss>