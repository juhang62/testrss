<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>利用Docker的Commit功能实现Chrome浏览器的缓存快照功能 - L33K</title>
<link>http://www.cnblogs.com/l33klin/p/10336968.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/l33klin/p/10336968.html</guid>
<description>&lt;h2&gt;背景/问题&lt;/h2&gt;
&lt;p&gt;    由于前后端功能分离，现在的前端开发大都采用现成的框架来实现比如Angular.js\Vue.js\React等。前端功能越重，在前端保存的数据就越多，包括配置，用户数据等等，再加上Cookie和Cache的缓存，这些数据一般都有缓存的失效性和版本兼容性问题。在实际的测试过程中就遇到两个个真实的案例，第一个是前端上线一个新的版本，使用到了一些新的数据格式，但是没有考虑到和旧的数据格式的兼容，导致一些有缓存的用户无法正常使用，一般这种数据格式不兼容的问题都比较严重，大部分时候都是基本功能都不能使用，另外一个真实案例就是后端开发在开发新功能时在Session中添加了一个新的字段，但是没有考虑到对旧的Session进行兼容，导致用户带着旧的Session来访问的时候报错。这两个问题都是很基础的问题，在平常的测试环境大家使用浏览器无痕模式测试的时候很难遇到，一般如果遇到了也会当做是偶发的问题去处理，因为测试环境不稳定的情况实在太多。面对这样的问题要怎么做呢？&lt;/p&gt;
&lt;h2&gt;解决思路&lt;/h2&gt;
&lt;p&gt;    有段时间一直在思考，怎么把浏览器缓存还有cookies这些数据的快照给保存下来，下次打开浏览器的时候可以直接使用这些缓存和数据打开浏览器，这样不就可以复原一个旧的缓存和cookies的场景了吗？这个看似平常的问题，我在Google和百度搜索了好久都没有搜到好的解决方法，就这样搁置了一段时间。最近在使用Docker时候接触到了容器和镜像的概念，其中Docker有个Commit功能，我们在运行一个容器，在容器中做了某些操作之后，可以通过commit功能生成一个镜像，这个镜像就会包含我们当前所有的改动，包括环境配置和历史记录等等，这个功能本来的应用场景是在容器遭到黑客攻击后保留现场用的，但是用在我们现在这种场景也是非常的合适。&lt;/p&gt;
&lt;h2&gt;解决方法&lt;/h2&gt;
&lt;p&gt;    &lt;strong&gt;使用的工具：&lt;/strong&gt;Docker, VNC Viewer&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;使用的镜像：selenium/standalone-chrome-debug&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;　步骤 &lt;/h3&gt;
&lt;h4&gt;    第一步：&lt;/h4&gt;
&lt;p&gt;　　　　安装&lt;a href=&quot;https://www.docker.com/products/docker-desktop&quot; target=&quot;_blank&quot;&gt;Docker&lt;/a&gt;、&lt;a href=&quot;https://www.realvnc.com/en/connect/download/viewer/&quot; target=&quot;_blank&quot;&gt;VNC Viewer&lt;/a&gt;，拉取镜像，详细步骤不再赘述，可以在百度或者Google搜索相应教程和软件。（参考：&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/image/pull.html&quot; target=&quot;_blank&quot;&gt;Docker拉取镜像&lt;/a&gt;）&lt;/p&gt;
&lt;h4&gt;    第二步：&lt;/h4&gt;
&lt;p&gt;　　　　使用selenium/standalone-chrome-debug镜像启动一个容器：(参考：&lt;a href=&quot;https://github.com/SeleniumHQ/docker-selenium&quot; target=&quot;_blank&quot;&gt;Selenium Docker官方文档&lt;/a&gt;)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -d -p &lt;span&gt;4444&lt;/span&gt;:&lt;span&gt;4444&lt;/span&gt; -p &lt;span&gt;5900&lt;/span&gt;:&lt;span&gt;5900&lt;/span&gt; -e VNC_NO_PASSWORD=&lt;span&gt;1&lt;/span&gt; --name container_name -v /dev/shm:/dev/shm selenium/standalone-chrome-debug
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;执行这个命令之后就启动了一个包含Chrome的容器，容器内部已经运行了VNC Server，并将容器的5900端口绑定到宿主机的5900端口，这样就可以使用VNC Viewer去连接容器并进行操作了。&lt;/p&gt;
&lt;h4&gt;    第三步：&lt;/h4&gt;
&lt;p&gt;　　　　打开VNC Viewer，输入“localhost:5900”，回车。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/909317/201902/909317-20190202151109282-1795809802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　这样就可以连接到容器内部了。&lt;/p&gt;
&lt;h4&gt;    第四步：&lt;/h4&gt;
&lt;p&gt;　　　　打开浏览器执行想要的操作。打开浏览器方法如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/909317/201902/909317-20190202151625225-1774766804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;    第五步：&lt;/h4&gt;
&lt;p&gt;　　　　将当前容器状态Commit到一个新的镜像：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker commit --author &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;User&amp;lt;email&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; --message &lt;span&gt;&quot;&lt;/span&gt;提示信息&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; container_name selenium/standalone-chrome-debug:image_tag&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　其中用户信息，提示信息和image_tag都是可以自定义的，container_name为启动容器时给容器设置的命名。&lt;/p&gt;
&lt;p&gt;    大功告成啦！&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;    这个解决方法用到了一些Docker的基本操作，并使用了Selenium的一个基础镜像，这个基础镜像中包含了桌面版的Chrome和VNC Server，可以很好的解决我们的问题，而且同时运行了一个Selenium Hub，之后如果想通过自动化的方法来实现对浏览器的操作也是可以很好的满足的，可扩展性非常不错。&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 07:26:00 +0000</pubDate>
<dc:creator>L33K</dc:creator>
<og:description>使用Docker Commit保存Chrome缓存快照，这个方法可以应用于任意想保存快照的场景，相比于虚拟机轻量很多，而且便于之后的自动化扩展。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/l33klin/p/10336968.html</dc:identifier>
</item>
<item>
<title>装饰模式 - 女屌丝逆袭白富美案例 - 刷书小将</title>
<link>http://www.cnblogs.com/zh1996/p/10348516.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zh1996/p/10348516.html</guid>
<description>&lt;p&gt;&lt;strong&gt;接下来用一个女屌丝变白富美的案子，来描述装饰模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、女孩接口&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，无论是女屌丝，还是白女孩、富女孩、美女孩，都是女孩。&lt;/p&gt;
&lt;p&gt;所以定义&lt;span&gt;&lt;strong&gt;女孩接口IGirl&lt;/strong&gt;&lt;/span&gt;如下，&lt;span&gt;&lt;strong&gt;其中show方法，就是女孩来展现自己现在的状态......&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IGirl {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、女屌丝登场&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;女屌丝：BaseGirl&lt;/span&gt;&lt;span&gt;。意思就是最基础、一无所有的女孩（女屌丝）。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;show方法实现了接口，女屌丝目前一无所有，只能说：我是女孩&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseGirl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IGirl {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseGirl() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated constructor stub&lt;/span&gt;
&lt;span&gt;    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
        System.out.println(&quot;我是女孩&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、装饰类RichGirl：变富&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;女孩虽然出身贫困，但是有一颗难得的上进心，她工作努力、团结同事，终于在某公司当上了个小领导，&lt;/p&gt;
&lt;p&gt;从此迈入了小康生活。&lt;/p&gt;
&lt;p&gt;此时，show方法中，女孩骄傲地说：我富....&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; RichGirl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IGirl {

    IGirl girl;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RichGirl(IGirl girl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.girl =&lt;span&gt; girl;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基本功能&lt;/span&gt;
&lt;span&gt;        girl.show();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加装饰&lt;/span&gt;
        System.out.println(&quot;我富&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、装饰类WhiteGirl：变白&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;女孩自从变有钱后，开始慢慢随着主流开始&lt;strong&gt;&lt;span&gt;化妆&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了让自己皮肤变白，女孩买了好多化妆品。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，show方法中，女孩高兴地说：我白....&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WhiteGirl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IGirl {

    IGirl girl;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WhiteGirl(IGirl girl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.girl=&lt;span&gt;girl;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基本功能&lt;/span&gt;
&lt;span&gt;        girl.show();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加装饰&lt;/span&gt;
        System.out.println(&quot;我白&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、装饰类BeautifulGirl：变美&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;女孩现在是又白又富，高傲气质也自然而然的流露出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时的show方法，女孩激动的说：我美...&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时，一个女屌丝不见了，一个白富美诞生了...故事也结束了...&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BeautifulGirl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; IGirl {

    IGirl girl;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BeautifulGirl(IGirl girl) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.girl =&lt;span&gt; girl;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; show() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;基本功能&lt;/span&gt;
&lt;span&gt;        girl.show();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加装饰&lt;/span&gt;
        System.out.println(&quot;我美&quot;&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;六、运行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流程很简单，首先创建一个朴素女孩（&lt;span&gt;&lt;strong&gt;gril对象&lt;/strong&gt;&lt;/span&gt;），她此时show，只会说：我是一个女孩&lt;/p&gt;
&lt;p&gt;经过三个装饰类（白、富、美）依次装饰，此时的女孩（&lt;strong&gt;&lt;span&gt;gril对象&lt;/span&gt;&lt;/strong&gt;），再次show的时候，已经是：我是一个女孩，我白，我富，我美&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建出一个朴素的女孩&lt;/span&gt;
        IGirl girl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseGirl();
        girl.show();

        System.out.println(&lt;/span&gt;&quot;\n-----------------------------------\n&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 女孩变白了&lt;/span&gt;
        girl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WhiteGirl(girl);
        girl.show();

        System.out.println(&lt;/span&gt;&quot;\n-----------------------------------\n&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 女孩变有钱了&lt;/span&gt;
        girl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RichGirl(girl);
        girl.show();

        System.out.println(&lt;/span&gt;&quot;\n-----------------------------------\n&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 女孩变漂亮了&lt;/span&gt;
        girl = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BeautifulGirl(girl);
        girl.show();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此故事，你我共勉。。&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 07:25:00 +0000</pubDate>
<dc:creator>刷书小将</dc:creator>
<og:description>接下来用一个女屌丝变白富美的案子，来描述装饰模式。 一、女孩接口 首先，无论是女屌丝，还是白女孩、富女孩、美女孩，都是女孩。 所以定义女孩接口IGirl如下，其中show方法，就是女孩来展现自己现在的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zh1996/p/10348516.html</dc:identifier>
</item>
<item>
<title>过年了，给亲朋好友解释「啥是程序员」 - Java3y</title>
<link>http://www.cnblogs.com/Java3y/p/10348397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java3y/p/10348397.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;一年一度的春节又到了，作为程序员的你是怎么告诉亲朋好友自己日常到底是做什么工作的呢？&lt;/p&gt;
&lt;p&gt;程序员是一个&lt;strong&gt;新兴&lt;/strong&gt;的职业，我在上大学以前不了解程序员到底是做什么的，对编程语言也一窍不通，也不关心玩过的「游戏」和天天逛的「网站」究竟是怎么来的。&lt;/p&gt;
&lt;p&gt;当年加了计算机科学与技术专业的&lt;strong&gt;新生群&lt;/strong&gt;，听着师兄和师姐们在聊天，其中就聊到了「程序员」这份职业。当时脑海里第一反应想象的&lt;strong&gt;竟是&lt;/strong&gt;「复印机、打印机等办公」乱七八糟的东西&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb7941dc0c0?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=121439&quot; alt=&quot;复印机、打印机&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;外行人看程序员&quot;&gt;外行人看程序员&lt;/h2&gt;
&lt;p&gt;有的「初高中」同学知道我读了计算机专业，于是过来问我：计算机专业应该会组装电脑的吧，我想组装一台新电脑，能不能帮帮忙给点意见，比如电脑&lt;strong&gt;配置清单&lt;/strong&gt;什么的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb7936b38ae?w=623&amp;amp;h=512&amp;amp;f=png&amp;amp;s=298212&quot; alt=&quot;电脑配置清单&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我大学期间我爸希望我&lt;strong&gt;多考&lt;/strong&gt;一些证书，比如有关「电气和会计」之类证书。他认为：只要证书多，那找工作肯定不成问题，工资也会比没有证书的人要高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb79281467f?w=596&amp;amp;h=501&amp;amp;f=png&amp;amp;s=214574&quot; alt=&quot;N多证书&quot;/&gt;&lt;/p&gt;
&lt;p&gt;临毕业了，跟同学出去吃宵夜，我当时正忙着找工作，同学也多问了一句：“你在找什么工作啊”。于是我说：”就IT呗，程序员了解不“。他说：”不懂啊，你&lt;strong&gt;会不会盗QQ、做游戏外挂&lt;/strong&gt;那些东西的啊？“。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb79551c567?w=596&amp;amp;h=501&amp;amp;f=png&amp;amp;s=117334&quot; alt=&quot;盗QQ&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前几天跟亲戚去吃饭，得知我年后要离开广州去杭州做软件相关的工作，几杯酒过后，深长意味告诉我：“还是做&lt;strong&gt;「行政」相关的工作有前途&lt;/strong&gt;，走那么远做软件有啥用啊，我来给你介绍去xxx工作”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb795b53bca?w=640&amp;amp;h=640&amp;amp;f=gif&amp;amp;s=101860&quot; alt=&quot;啥才是好工作！&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我这里想表达的是：老一辈的人大多不太了解互联网行业，认为行政、银行、老师、医生这些行业才是“正道”。我对这些行业都持有敬畏之心，并没有讽刺的意思。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;程序员喜欢自嘲&quot;&gt;程序员喜欢自嘲&lt;/h2&gt;
&lt;p&gt;外行人对程序员的误解，也有可能只是看到网上有很多关于程序员的言论，&lt;strong&gt;真以为&lt;/strong&gt;「大多数」程序员都那样。&lt;/p&gt;
&lt;p&gt;比如说程序员都爱穿格子衫：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb7942514f5?w=596&amp;amp;h=501&amp;amp;f=png&amp;amp;s=144618&quot; alt=&quot;程序员最爱格子衫&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员没有女朋友：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb80e155985?w=440&amp;amp;h=485&amp;amp;f=gif&amp;amp;s=103527&quot; alt=&quot;程序员女朋友&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员人傻话少死得快：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8112abd00?w=240&amp;amp;h=240&amp;amp;f=gif&amp;amp;s=25124&quot; alt=&quot;人傻话少死得快&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实很多的言论都是程序员们在闲暇之余的时候「&lt;strong&gt;自嘲&lt;/strong&gt;」罢了。大多数程序员跟其他行业的人&lt;strong&gt;都一样&lt;/strong&gt;，并没有像网上说得那么玄乎。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;程序员在网上一般称自己为「码农」(编码的农民)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;程序员加班&quot;&gt;程序员加班&lt;/h2&gt;
&lt;p&gt;暂且不管关于程序员其他的言论，但对于互联网行业来说，加班的确是「&lt;strong&gt;普遍&lt;/strong&gt;」存在的现象，就在前阵子，「有赞」在年会上公开宣布996工作制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb81744404f?w=660&amp;amp;h=452&amp;amp;f=jpeg&amp;amp;s=57745&quot; alt=&quot;「有赞」在年会上公开宣布996工作制&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有人可能不知道996是什么意思，这里我解释一下：从早上9点工作至晚上9点，一周上六天班。简称996&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在秋招跑了几个广州游戏公司的宣讲会，大多在宣讲会上明确公司需要「&lt;strong&gt;加班&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb819559fd4?w=654&amp;amp;h=649&amp;amp;f=gif&amp;amp;s=53750&quot; alt=&quot;经验都是加班出来的&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「苏宁」之前也闹出一事&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb871712d76?w=442&amp;amp;h=496&amp;amp;f=png&amp;amp;s=37100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「华为」的狼性文化也是家喻户晓的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb83a9c30f6?w=442&amp;amp;h=496&amp;amp;f=png&amp;amp;s=143324&quot; alt=&quot;狼性文化&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;啥是编程语言&quot;&gt;啥是编程语言&lt;/h2&gt;
&lt;p&gt;基本大家能想到程序员能做的事，而程序员们几乎都不会&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb880c9b46b?w=681&amp;amp;h=582&amp;amp;f=png&amp;amp;s=129718&quot; alt=&quot;程序员要你有何用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个程序员都会有一门自己拿手的&lt;strong&gt;编程语言&lt;/strong&gt;，有的时候一门编程语言可以对应不同的「岗位」。(比如说，Java程序员、PHP程序员)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb885c0af9e?w=350&amp;amp;h=350&amp;amp;f=jpeg&amp;amp;s=27880&quot; alt=&quot;一大堆编程语言&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员每天都是跟「计算机」打交道，让计算机干什么，计算机就会去干什么，很是听话&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb89feac5ce?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=45820&quot; alt=&quot;让计算机干什么，计算机就会去干什么&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那计算机咋能听懂程序员让它去干啥呀。有点计算机基础的同学可能会知道，计算机只认「&lt;strong&gt;二进制&lt;/strong&gt;」&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8a0408a08?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=167379&quot; alt=&quot;计算机只认二进制&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「二进制」：逢二进一。「十进制」：逢十进一&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8b80b303f?w=492&amp;amp;h=499&amp;amp;f=png&amp;amp;s=24903&quot; alt=&quot;「二进制」：逢二进一&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这里，大家可能都看不懂了。没事，我们继续往下看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8c92cc9d3?w=492&amp;amp;h=499&amp;amp;f=png&amp;amp;s=132468&quot; alt=&quot;看不懂&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序员也是人，人与人的交流，「常用的语言」有阿拉伯语、汉语、英语、法语、俄语和西班牙语等，而不是啥「二进制」的东西。为了&lt;strong&gt;方便&lt;/strong&gt;，聪明的「程序员」企图让计算机去读懂「自然语言」。(能够让计算机去读懂阿拉伯语、汉语、英语、法语、俄语和西班牙语等这些语言)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8e8188dea?w=555&amp;amp;h=497&amp;amp;f=png&amp;amp;s=47419&quot; alt=&quot;聪明的「程序员」企图让计算机去读懂「自然语言」&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以程序员们就搞出了一个「编译器」，编译器说白了就是能将这些「自然语言」&lt;strong&gt;翻译&lt;/strong&gt;成二进制，让计算机读得懂！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb8fb4d009e?w=717&amp;amp;h=496&amp;amp;f=png&amp;amp;s=34551&quot; alt=&quot;将自然语言翻译成二进制&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在计算机世界里，对任何事物都不含糊，说一就是一，说二就是二。想要让「自然语言」能够&lt;strong&gt;准确地&lt;/strong&gt;翻译成二进制，就必须定下相应的「&lt;strong&gt;规则&lt;/strong&gt;」。而使用不同的「规则」，就出现了不同的编程语言。因为大多数编程语言都是「&lt;strong&gt;外国人&lt;/strong&gt;」发明的，并且由于英语的「&lt;strong&gt;广泛性&lt;/strong&gt;」和「&lt;strong&gt;易用性&lt;/strong&gt;」。所以，绝大多数的编程语言都由「&lt;strong&gt;英文&lt;/strong&gt;」组成。&lt;/p&gt;
&lt;p&gt;(以下就是各种常见的编程语言，由于「&lt;strong&gt;规则&lt;/strong&gt;」不同，所以看起来都不一样。但所做的事都是相同的)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
print_r('点个好看、转发吧！');
var_dump('点个好看、转发吧！');
NSLog(@&quot;点个好看、转发吧！&quot;);
System.out.println(&quot;点个好看、转发吧！&quot;);
console.log(&quot;点个好看、转发吧！&quot;);
print(&quot;点个好看、转发吧！&quot;);
printf(&quot;点个好看、转发吧！&quot;);
cout &amp;lt;&amp;lt; &quot;点个好看、转发吧！&quot; &amp;lt;&amp;lt; endl;
Console.WriteLine(&quot;点个好看、转发吧！&quot;);
fmt.Println(&quot;点个好看、转发吧！&quot;);
Response.Write(&quot;点个好看、转发吧！&quot;);
alert(&quot;点个好看、转发吧！&quot;)
echo &quot;点个好看、转发吧！&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解释程序员干啥活&quot;&gt;解释程序员干啥活&lt;/h2&gt;
&lt;p&gt;别人问到我是做什么的，我往往会说“你平时用过的「微信」，「百度」这些软件啊，网站啊就是我们程序员做的”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb90b0305ba?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=75448&quot; alt=&quot;微信等有名软件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(一般到这里就不会继续往下问细节了，但还是遇到过继续问究竟是怎么做的)&lt;/p&gt;
&lt;p&gt;接下来，为了继续演示，我们可以掏出手机，打开微信：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb90dc24ef8?w=399&amp;amp;h=499&amp;amp;f=png&amp;amp;s=69179&quot; alt=&quot;掏出手机，打开微信&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“我们都是玩微信的人，要进入微信先得有个账户，所以要先注册“&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb9122da161?w=828&amp;amp;h=978&amp;amp;f=jpeg&amp;amp;s=91092&quot; alt=&quot;微信注册页面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“注册实际上就是把你的账号和密码「&lt;strong&gt;保存&lt;/strong&gt;」起来”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb91c41682b?w=694&amp;amp;h=509&amp;amp;f=png&amp;amp;s=27274&quot; alt=&quot;账号和密码「保存」起来&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“如果你注册成功了，那&lt;del&gt;小本本&lt;/del&gt;「数据库」就有你的账号和密码了。等你登录的时候，就去&lt;del&gt;小本本&lt;/del&gt;「数据库」查一下你输入的账号和密码是否&lt;strong&gt;匹配&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb92ec898b6?w=752&amp;amp;h=545&amp;amp;f=png&amp;amp;s=74112&quot; alt=&quot;登录&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“看到这里，有没有觉得「程序员」真是容易当，不就把输入的数据记录下小本本，等用到的时候再查一下而已嘛。其实不然，就好比微信的注册页面，拿IOS系统来说，从&lt;code&gt;IOS 6&lt;/code&gt; 到现在的&lt;code&gt;IOS 12&lt;/code&gt;已经有6个版本了。Iphone手机屏幕的尺寸也一直在变，从&lt;code&gt;3.5&lt;/code&gt;英寸到现在的&lt;code&gt;6.5&lt;/code&gt;英寸。微信团队需要对不同的「版本」，不同的「屏幕大小」进行&lt;strong&gt;兼容&lt;/strong&gt;，让iPhone4s还是iPhoneXS Max都能用上微信。(起码在不同的手机上，看到的注册功能都是完整的，而不是东一块西一块不整齐的)”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb9497c0a4a?w=610&amp;amp;h=465&amp;amp;f=png&amp;amp;s=45683&quot; alt=&quot;兼容问题&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“还比如说，&lt;del&gt;小本本&lt;/del&gt;「数据库」记下的密码不能是你输入的「原始密码」。举个例子：某一天，一个在微信团队的小伙子拿到了存放账号和密码的&lt;del&gt;小本本&lt;/del&gt;「数据库」，把&lt;del&gt;小本本&lt;/del&gt;「数据库」的内容给&lt;strong&gt;公开&lt;/strong&gt;了。(或者说一个黑客把微信给攻破了，然后公开&lt;del&gt;小本本&lt;/del&gt;「数据库」)，&lt;strong&gt;那岂不是谁都可以上我的微信号了&lt;/strong&gt;？”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb93460fd74?w=717&amp;amp;h=600&amp;amp;f=png&amp;amp;s=137332&quot; alt=&quot;公开小本本的内容&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“程序员们当然可以考虑到这点，他们会这样做，将你输入的密码进行「&lt;strong&gt;加密&lt;/strong&gt;」存到&lt;del&gt;小本本&lt;/del&gt;「数据库」中。&lt;strong&gt;无论是谁&lt;/strong&gt;，拿到加密后的密码，都&lt;strong&gt;不能「反推」&lt;/strong&gt;你原始输入的密码。”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb96df3cd0d?w=543&amp;amp;h=539&amp;amp;f=png&amp;amp;s=36274&quot; alt=&quot;密码加密&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“所以，每次比对的都是加密后的密码”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb953950874?w=490&amp;amp;h=503&amp;amp;f=png&amp;amp;s=35939&quot; alt=&quot;比对的是加密后的密码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“当然啦，程序员考虑的远远不止这些。不管怎么样，每个程序员都希望自己写的东西「&lt;strong&gt;简单易用，受人喜欢&lt;/strong&gt;」”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb9726dc218?w=637&amp;amp;h=517&amp;amp;f=png&amp;amp;s=29474&quot; alt=&quot;其实我是一个软件工程师&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;文章首发公众号&lt;strong&gt;Java3y&lt;/strong&gt;：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&amp;amp;mid=2247484732&amp;amp;idx=1&amp;amp;sn=2f478a802024b648a2814ff2bd77c6f9&amp;amp;chksm=ebd7443ddca0cd2bb28bf6f923a6d96a54b491790bfa18d98dea67c4172b2a0bc36d29ce89d1&amp;amp;token=1676899695&amp;amp;lang=zh_CN#rd&quot;&gt;过年了，给亲朋好友解释「啥是程序员」&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;乐于输出&lt;strong&gt;干货&lt;/strong&gt;的Java技术公众号：Java3y。公众号内有200多篇&lt;strong&gt;原创&lt;/strong&gt;技术文章、海量视频资源、精美脑图，不妨来&lt;strong&gt;关注&lt;/strong&gt;一下！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/2/168acdb97440ad09?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=21338&quot; alt=&quot;帅的人都关注了&quot;/&gt;&lt;/p&gt;
&lt;p&gt;觉得我的文章写得不错，不妨点一下&lt;strong&gt;赞&lt;/strong&gt;！&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 06:30:00 +0000</pubDate>
<dc:creator>Java3y</dc:creator>
<og:description>前言 一年一度的春节又到了，作为程序员的你是怎么告诉亲朋好友自己日常到底是做什么工作的呢？ 程序员是一个 新兴 的职业，我在上大学以前不了解程序员到底是做什么的，对编程语言也一窍不通，也不关心玩过的「</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java3y/p/10348397.html</dc:identifier>
</item>
<item>
<title>Python之celery的简介与使用 - jclian91</title>
<link>http://www.cnblogs.com/jclian91/p/10348261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jclian91/p/10348261.html</guid>
<description>&lt;h3 id=&quot;celery的简介&quot;&gt;celery的简介&lt;/h3&gt;
&lt;p&gt;  celery是一个基于分布式消息传输的异步任务队列，它专注于实时处理，同时也支持任务调度。它的执行单元为任务（task），利用多线程，如&lt;a href=&quot;http://eventlet.net/&quot;&gt;Eventlet&lt;/a&gt;，&lt;a href=&quot;http://gevent.org/&quot;&gt;gevent&lt;/a&gt;等，它们能被并发地执行在单个或多个职程服务器（worker servers）上。任务能异步执行（后台运行）或同步执行（等待任务完成）。&lt;br/&gt;  在生产系统中，celery能够一天处理上百万的任务。它的完整架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-87ea2c0bc2cf1b8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;celery架构图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;组件介绍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Producer：调用了Celery提供的API、函数或者装饰器而产生任务并交给任务队列处理的都是任务生产者。&lt;/li&gt;
&lt;li&gt;Celery Beat：任务调度器，Beat进程会读取配置文件的内容，周期性地将配置中到期需要执行的任务发送给任务队列。&lt;/li&gt;
&lt;li&gt;Broker：消息代理，又称消息中间件，接受任务生产者发送过来的任务消息，存进队列再按序分发给任务消费方（通常是消息队列或者数据库）。Celery目前支持RabbitMQ、Redis、MongoDB、Beanstalk、SQLAlchemy、Zookeeper等作为消息代理，但适用于生产环境的只有RabbitMQ和Redis, 官方推荐 RabbitMQ。&lt;/li&gt;
&lt;li&gt;Celery Worker：执行任务的消费者，通常会在多台服务器运行多个消费者来提高执行效率。&lt;/li&gt;
&lt;li&gt;Result Backend：任务处理完后保存状态信息和结果，以供查询。Celery默认已支持Redis、RabbitMQ、MongoDB、Django ORM、SQLAlchemy等方式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  在客户端和消费者之间传输数据需要序列化和反序列化。 Celery 支出的序列化方案如下所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-d4ee3804d2031aa5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;celery序列化&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;
&lt;p&gt;  在本文中，我们使用的celery的消息代理和后端存储数据库都使用redis，序列化和反序列化选择msgpack。&lt;br/&gt;  首先，我们需要安装redis数据库，具体的安装方法可参考：http://www.runoob.com/redis/redis-install.html 。启动redis，我们会看到如下界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-eb99f34a2cb5d27b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;redis启动&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在redis可视化软件rdm中，我们看到的数据库如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-4f85ceca520d70be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;rdm&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面没有任何数据。&lt;br/&gt;  接着，为了能够在python中使用celery，我们需要安装以下模块：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;celery&lt;/li&gt;
&lt;li&gt;redis&lt;/li&gt;
&lt;li&gt;msgpack&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样，我们的准备工作就完毕了。&lt;/p&gt;
&lt;h3 id=&quot;一个简单的例子&quot;&gt;一个简单的例子&lt;/h3&gt;
&lt;p&gt;  我们创建的工程名称为proj，结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-caabb7807fd71e79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  首先是主程序app_test.py，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from celery import Celery

app = Celery('proj', include=['proj.tasks'])
app.config_from_object('proj.celeryconfig')

if __name__ == '__main__':
    app.start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析一下这个程序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&quot;from celery import Celery&quot;是导入celery中的Celery类。&lt;/li&gt;
&lt;li&gt;app是Celery类的实例，创建的时候添加了proj.tasks这个模块，也就是包含了proj/tasks.py这个文件。&lt;/li&gt;
&lt;li&gt;把Celery配置存放进proj/celeryconfig.py文件，使用app.config_from_object加载配置。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;  接着是任务函数文件tasks.py，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
from proj.app_test import app

@app.task
def add(x, y):
    time.sleep(1)
    return x + y&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;tasks.py只有一个任务函数add，让它生效的最直接的方法就是添加app.task这个装饰器。add的功能是先休眠一秒，然后返回两个数的和。&lt;/p&gt;
&lt;p&gt;  接着是配置文件celeryconfig.py，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;BROKER_URL = 'redis://localhost' # 使用Redis作为消息代理

CELERY_RESULT_BACKEND = 'redis://localhost:6379/0' # 把任务结果存在了Redis

CELERY_TASK_SERIALIZER = 'msgpack' # 任务序列化和反序列化使用msgpack方案

CELERY_RESULT_SERIALIZER = 'json' # 读取任务结果一般性能要求不高，所以使用了可读性更好的JSON

CELERY_TASK_RESULT_EXPIRES = 60 * 60 * 24 # 任务过期时间

CELERY_ACCEPT_CONTENT = ['json', 'msgpack'] # 指定接受的内容类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  最后是调用文件diaoyong.py，代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from proj.tasks import add
import time

t1 = time.time()

r1 = add.delay(1, 2)
r2 = add.delay(2, 4)
r3 = add.delay(3, 6)
r4 = add.delay(4, 8)
r5 = add.delay(5, 10)

r_list = [r1, r2, r3, r4, r5]
for r in r_list:
    while not r.ready():
        pass
    print(r.result)

t2 = time.time()

print('共耗时：%s' % str(t2-t1))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个程序中，我们调用了add函数五次，delay()用来调用任务。&lt;/p&gt;
&lt;h3 id=&quot;例子的运行&quot;&gt;例子的运行&lt;/h3&gt;
&lt;p&gt;  到此为止，我们已经理解了整个项目的结构与代码。&lt;br/&gt;  接下来，我们尝试着把这个项目运行起来。&lt;br/&gt;  首先，我们需要启动redis。接着，切换至proj项目所在目录，并运行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;celery -A proj.app_test worker -l info&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;界面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-1ee4cc4a651dbfc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;celery启动&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后，我们运行diaoyong.py，输出的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3
6
9
12
15
共耗时：1.1370790004730225&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后台输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-bf9bbebd0485d3ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;celery后台运行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，我们看一下rdm中的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/9419034-218bc4dcb30b137f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;rdm中的数据&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经成功运行了这个项目。&lt;br/&gt;  下面，我们尝试着对这个运行结果做些分析。首先，我们一次性调用了五次add函数，但是运行的总时间才1秒多。这是celery异步运行的结果，如果是同步运行，那么，至少需要5秒多，因为每调用add函数一次，就会休眠一秒。这就是celery的强大之处。&lt;br/&gt;  从后台输出可以看到，程序会先将任务分发出来，每个任务一个ID，在后台统一处理，处理完后会有相应的结果返回，同时该结果也会储存之后台数据库。可以利用ready()判断任务是否执行完毕，再用result获取任务的结果。&lt;br/&gt;  本文项目的github地址为：https://github.com/percent4/celery_example 。&lt;br/&gt;  本次分享到此结束，感谢阅读~&lt;br/&gt;  注意：本人现已开通微信公众号： Python爬虫与算法（微信号为：easy_web_scrape）， 欢迎大家关注哦~~&lt;/p&gt;
&lt;h3 id=&quot;参考文献&quot;&gt;参考文献&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Celery 初步：http://docs.jinkan.org/docs/celery/getting-started/first-steps-with-celery.html#first-steps&lt;/li&gt;
&lt;li&gt;使用Celery：https://zhuanlan.zhihu.com/p/22304455&lt;/li&gt;
&lt;li&gt;异步神器celery：https://www.jianshu.com/p/9be4d8d30d8e&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 02 Feb 2019 05:27:00 +0000</pubDate>
<dc:creator>jclian91</dc:creator>
<og:description>Python之celery的简介与使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jclian91/p/10348261.html</dc:identifier>
</item>
<item>
<title>asp.net core microservices 架构之eureka服务发现 - 无为有道</title>
<link>http://www.cnblogs.com/ck0074451665/p/10347330.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ck0074451665/p/10347330.html</guid>
<description>
&lt;p&gt;&lt;span&gt;一 简介                                                     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　微服务将需多的功能拆分为许多的轻量级的子应用，这些子应用相互调度。好处就是轻量级，完全符合了敏捷开发的精神。我们知道ut（单元测试），不仅仅提高我们的程序的健壮性，而且可以强制将类和方法的设计尽量的单一化。那么微服务也是这样，敏捷对于软件工程的意义就是快速开发，验证市场需求，然后快速改进，从而适应市场节奏。什么东西要快速，就必须轻量级。大家知道一个应用的复杂程度，完全是和这个项目的功能和代码数量挂钩的，这是软件自诞生就存在的问题，一个设计不好的软件，最后会让这个软件更新和改进变的非常复杂，直至没有人敢去碰这个应用，我一直认为这个代码量和复杂程度挂钩，困难程度是以指数的量增加的，而不仅仅是线性增加。这就需要一个好的设计去解决问题，一个微服务尽量的单一，与其他子应用几乎没有代码上的关联，所以可以快速出原型，快速开发，验证市场，也可以快速砍掉一个项目，而不影响其他的应用。&lt;/p&gt;
&lt;p&gt;　　当然，因为微服务有他的局限性，所以也有它的坏处，比如一致性会打折扣，对于一致性的问题，我前几篇文章已经做过探讨。还有就是虽然软件开发部署工作解脱了，但是您想，原来一个应用，现在三四个应用进行协调和通讯，对于这个分布式架构的要求就会高，如何把他们打散又要弱关联在一起，那么eureka诞生了。asp.net core支持一个底层的库，Microsoft.Extensions.Http.Polly，这个库是表达策略，例如以流畅且线程安全的方式处理重试、断路器、超时、Bulkhead 隔离和回退，就是防止雪崩，熔断降级等特性。感兴趣的可以看asp.net core 官方文档： https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.2#use-polly-based-handlers 。多说一句，asp.net core也有后台服务job的底层api，有兴趣的可以试着做出一套asp.net core的job框架。甚至服务发现，配合zookeeper，也可以开发出一套属于asp.net core的框架。&lt;/p&gt;
&lt;p&gt;　　言归正传，这里还需要注意的是一点是，一个微服务是可以和以前的比如面向传统服务类型的应用共存的，如果公司内部可以提出一个应用作为微服务来设计，那么我恭喜你，从泥潭中跨出了一步，如果你们公司全部用微服务设计了，那么真的恭喜，完全跳出了泥潭。当然一些重量级的应用，因为必须使用分布式事务等等的特殊要求，还是可以存在，微服务还是需要根据实际情况来实施的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二 eureka集成                                                           &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　说到eureka前，我们需要明白一个术语：backing service。我把他翻译为协助服务，或者帮助服务。主要意思就是对资源具有管理，丢失处理，连接和配置等功能的一个程序。那微服务资源自然就是我们各种各样的服务，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190131140247599-1292671219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然除过eureka，还有etcd，Consul，Marathon，ZooKeeper可以供大家挑选。&lt;/p&gt;
&lt;p&gt;使用docker运行eureka服务器端：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run -p &lt;span&gt;8081&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; -d --&lt;span&gt;name eureka \
&lt;/span&gt;-d netflixoss/eureka:&lt;span&gt;1.3&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行成功后，如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190131141836565-1920349512.png&quot; alt=&quot;&quot; width=&quot;1052&quot; height=&quot;645&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们用我们的Walt.Framework.OrderService项目定义一个api接口和将配置eureka客户端，然后至今运行，就会直接将实例添加进eureka服务端：&lt;/p&gt;
&lt;p&gt;设计api，我们直接看生成的api描述，使用swagger生成的api描述：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201902/46403-20190201142629889-1867197826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再安装eureka客户端，首先查找都有那些包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
nuget.exe list eureka
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显示结果，红框中的包就是文档中要求针对netcore的包：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190131161341367-1734633075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;客户端需要引入包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
dotnet add Walt.TestMcroServices.Webapi.csproj package Steeltoe.Discovery.ClientCore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再注册服务，这个大家都应该熟悉的不能再熟悉了，因为我们开发自定义的服务已经有三个了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup {
    ...
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(...)
    {
      ...
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add Steeltoe Discovery Client service&lt;/span&gt;
&lt;span&gt;        services.AddDiscoveryClient(Configuration); &lt;span&gt;//添加服务

        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add framework services.&lt;/span&gt;
&lt;span&gt;        services.AddMvc();
        ...
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, ...)
    {
        ...
        app.UseStaticFiles();
        app.UseMvc();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use the Steeltoe Discovery Client service&lt;/span&gt;
&lt;span&gt;        app.UseDiscoveryClient();&lt;br/&gt;&lt;/span&gt;　　　　&lt;span&gt;//这里是将服务应用到&lt;/span&gt;http&lt;span&gt;通道，我们知道这里处理的都是asp.net core 相关请求的http通道的一些事情，类似与asp.net的那几个application事件。&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里多说一句关于owin的事情，上面代码的&lt;em&gt;中间件技术和&lt;/em&gt;&lt;span data-ttu-id=&quot;cd8c6-117&quot;&gt;OWIN完全不同，OWIN：开放 Web 接口，它定义了在管道中使用中间件来处理请求和相关响应的标准方法。我们看看asp.net core 的管道都干些什么？&lt;/span&gt;&lt;span data-ttu-id=&quot;cd8c6-117&quot;&gt;如图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;cd8c6-117&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190131163000334-1641918075.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;官方说辞：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201901/46403-20190131163120492-240355105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以无论各个环节都是处理http上下文中的内容，web驱动监听到http请求和发送请求的内容，就是request，和response，在这两个之间就是我们的通道，不管是处理生成http内容时，还是身份验证，session处理，都是这个通道之间的某个环节。&lt;/p&gt;
&lt;p&gt;那owin作用是什么尼？就是定义这些中间环节的一些标准，所以任何web框架，只要实现了owin接口标准，两个不同web框架，就都可以相互兼容。&lt;/p&gt;
&lt;p&gt;言归正准，继续eureka的客户配置， 配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trace&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Steeltoe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KafkaLog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Prix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是我的自定义日志提供程序&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogStoreTopic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mylog-orderservice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KafkaService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootstrap.servers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.249.106:9092&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group.id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zookeeperService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connectstring&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.249.106:2181&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SessionTimeout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;12000000&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;spring&quot;: {
    &quot;application&quot;: {
      &quot;name&quot;: &quot;orderservice&quot;
    }
  },
  &quot;eureka&quot;: {
    &quot;client&quot;: {
      &quot;serviceUrl&quot;: &quot;http://192.168.249.105:8080/eureka/v2/&quot;,
      &quot;shouldFetchRegistry&quot;: false
    },
    &quot;instance&quot;: {
      &quot;ipAddress&quot;:&quot;192.168.249.102&quot;,
      &quot;preferIpAddress&quot;:true,
      &quot;port&quot;: 802,
      &quot;instanceId&quot;:&quot;orderserviceinstance&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
    }
  }&lt;/span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;红颜色的就是eureka需要使用的配直节。&lt;/p&gt;
&lt;p&gt;所以在startup中的配置就需要把整个configuration传进去，让他自己查找，而不用精确找到configuration配直节后，再传入服务构建，这个非常简单，总共就两行代码。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Steeltoe.Discovery.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Swashbuckle.AspNetCore.Swagger;


&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Walt.TestMicroservices.OrderService
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration
            ,IHostingEnvironment hostingEn
            , ILoggerFactory loggerFac )
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
            HostingEn &lt;/span&gt;=&lt;span&gt; hostingEn;
            LoggerFac &lt;/span&gt;=&lt;span&gt; loggerFac; 
        }
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHostingEnvironment HostingEn { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ILoggerFactory LoggerFac { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddMvc(mvcOptions&lt;/span&gt;=&amp;gt;&lt;span&gt;{
                
            }).SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     services.AddAuthorization();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;     services.AddAuthentication(&quot;Bearer&quot;)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   .AddIdentityServerAuthentication(options =&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       options.Authority = &quot;&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:64433&quot;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       options.RequireHttpsMetadata = false;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;       options.ApiName = &quot;api1&quot;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add Steeltoe Discovery Client service&lt;/span&gt;
&lt;span&gt;            services.AddDiscoveryClient(Configuration);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register the Swagger generator, defining 1 or more Swagger documents&lt;/span&gt;
            services.AddSwaggerGen(c =&amp;gt;&lt;span&gt;
            {
                c.SwaggerDoc(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; Info { Title = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My API&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Version = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
            });
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; log = LoggerFac.CreateLogger&amp;lt;Startup&amp;gt;&lt;span&gt;();
            log.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务配置完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; log = LoggerFac.CreateLogger&amp;lt;Startup&amp;gt;&lt;span&gt;();
            log.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;infomation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseHsts();
            }
            &lt;span&gt;app.UseDiscoveryClient();&lt;/span&gt;
            app.UseSwagger();
            app.UseSwaggerUI(c &lt;/span&gt;=&amp;gt;&lt;span&gt;
           {
               c.SwaggerEndpoint(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/swagger/v1/swagger.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;My API V1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
               c.RoutePrefix &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty;
           });
            app.UseMvc(routes &lt;/span&gt;=&amp;gt;&lt;span&gt; {
                        routes.MapRoute(
                            name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            template: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    });


            app.UseAuthentication();
            log.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;通道配置完毕&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt; 运行：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201902/46403-20190202120305673-269455075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们看到注册成功了，那看调用方：Walt.TestMicroServices.Webapi&lt;/p&gt;
&lt;p&gt;startup类中注册：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Walt.Framework.Service;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Walt.Framework.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Walt.Framework.Service.Kafka;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Steeltoe.Discovery.Client;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Steeltoe.Common.Http.Discovery;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Walt.TestMicroServoces.Webapi
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration
            ,IHostingEnvironment hostingEn
            , ILoggerFactory loggerFac )
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
            HostingEn &lt;/span&gt;=&lt;span&gt; hostingEn;
            LoggerFac &lt;/span&gt;=&lt;span&gt; loggerFac; 
        }
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHostingEnvironment HostingEn { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ILoggerFactory LoggerFac { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddSingleton&lt;/span&gt;&amp;lt;IKafkaService, KafkaService&amp;gt;&lt;span&gt;();
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
            services.AddAuthorization();
            services.AddAuthentication(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
          .AddIdentityServerAuthentication(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
          {
              options.Authority &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:64433&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
              options.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

              options.ApiName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
          });

            services.AddKafka(KafkaBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; kafkaConfig = Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KafkaService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                KafkaBuilder.AddConfiguration(kafkaConfig);
            });

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;services.AddSingleton&amp;lt;IOrderService, OrderService&amp;gt;();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add Steeltoe Discovery Client service&lt;/span&gt;
&lt;span&gt;            services.AddDiscoveryClient(Configuration);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add Steeltoe handler to container&lt;/span&gt;
            services.AddTransient&amp;lt;DiscoveryHttpMessageHandler&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configure a HttpClient&lt;/span&gt;
           &lt;span&gt; services.AddHttpClient&amp;lt;OrderService&amp;gt;(c =&amp;gt;
            {
                c.BaseAddress = new Uri(&quot;http://orderservice&quot;);
            })
             .AddHttpMessageHandler&amp;lt;DiscoveryHttpMessageHandler&amp;gt;() //这个就是拦截http请求，然后让发现服务处理这个http请求，而不适用默认的http请求处理程序
             .AddTypedClient&amp;lt;IOrderService, OrderService&amp;gt;(); //将上面DiscoveryHttpMessageHandler这个处理程序生成httpclient然后注入给这个服务类，然后再将这个服务类加入DI&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; log = LoggerFac.CreateLogger&amp;lt;Startup&amp;gt;&lt;span&gt;();
            log.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务配置完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        { 
            
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; log= LoggerFac.CreateLogger&amp;lt;Startup&amp;gt;&lt;span&gt;();
            log.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;infomation&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
           
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseHsts();
            }
            app.UseMvc();
            app.UseDiscoveryClient();
            app.UseAuthentication();  
           
            log.LogDebug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;通道配置完毕&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;这里看配置文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogLevel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Microsoft&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KafkaLog&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Prix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是我的自定义日志提供程序&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogStoreTopic&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mylog-webapi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KafkaService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bootstrap.servers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.249.106:9092&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group.id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zookeeperService&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Connectstring&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.249.106:2181&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SessionTimeout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;12000000&lt;/span&gt;&lt;span&gt;
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;spring&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webapi&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  },
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eureka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;client&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;serviceUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://192.168.249.105:8080/eureka/v2/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shouldRegisterWithEureka&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ipAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.249.102&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;preferIpAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;801&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;instanceId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webapiinstance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看调用类，很简单，因为asp.net core和eueka的集成已经在上一步骤中的startup中处理，这里直接使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Net.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Steeltoe.Common.Discovery;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; Walt.TestMicroServoces.Webapi
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderService:IOrderService
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IConfiguration _config;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpClient _httpClient;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; OrderService(IConfiguration config
        ,HttpClient httpClient)
        {
            _config&lt;/span&gt;=&lt;span&gt;config;
            _httpClient &lt;/span&gt;=&lt;span&gt; httpClient;
        }  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetOrder()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; task=_httpClient.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; task;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用：&lt;/p&gt;
&lt;p&gt;首先看日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201902/46403-20190202121143405-2104010858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;只要获取到这个实例，就没什么问题了。&lt;/p&gt;
&lt;p&gt;页面结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201902/46403-20190201204041337-960142502.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;注意：我在用nuget包的时候，总是获取不到实例，不知道什么，后来没办法就用源码：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201902/46403-20190202121300093-1837916046.png&quot; alt=&quot;&quot;/&gt;直接就可以了，就算不可以，调式源码，很快也就解决了，看来坑都怕源码，尤其是这种还没大规模使用和讨论的小项目，所以我这次的代码就把这个引用保留，大家下载后需要自己下载 Descover源码，然后引用这个工程就ok了。&lt;/p&gt;
&lt;p&gt;Discovery github地址：https://github.com/SteeltoeOSS/Discovery&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;span&gt;三 集成polly                                               &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　polly 提供了微服务之间调用的容错功能，无论是慢超市，还是失败，对于微服务之间提供了很多策略，如下的策略：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Policy&lt;/th&gt;
&lt;th&gt;Premise&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;Aka&lt;/th&gt;
&lt;th&gt;How does the policy mitigate?&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;30.019424460432&quot;&gt;&lt;tr readability=&quot;6.4615384615385&quot;&gt;&lt;td&gt;&lt;span&gt;Retry&lt;/span&gt; &lt;br/&gt;(policy family)&lt;br/&gt;&lt;span&gt;(&lt;a href=&quot;https://github.com/App-vNext/Polly#retry&quot;&gt;quickstart&lt;/a&gt; ; &lt;a href=&quot;https://github.com/App-vNext/Polly/wiki/Retry&quot;&gt;deep&lt;/a&gt;)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;Many faults are transient and may self-correct after a short delay.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;重试&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&quot;Maybe it's just a blip&quot;&lt;/td&gt;
&lt;td&gt;Allows configuring automatic retries.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;15.91959798995&quot;&gt;&lt;td&gt;&lt;span&gt;Circuit-breaker&lt;/span&gt;&lt;br/&gt;(policy family)&lt;br/&gt;&lt;span&gt;(&lt;a href=&quot;https://github.com/App-vNext/Polly#circuit-breaker&quot;&gt;quickstart&lt;/a&gt; ; &lt;a href=&quot;https://github.com/App-vNext/Polly/wiki/Circuit-Breaker&quot;&gt;deep&lt;/a&gt;)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;When a system is seriously struggling, failing fast is better than making users/callers wait. &lt;/p&gt;
&lt;p&gt;&lt;span&gt;失败而不是调用等待&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Protecting a faulting system from overload can help it recover.&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot; readability=&quot;5&quot;&gt;&quot;Stop doing it if it hurts&quot; &lt;p&gt;&quot;Give that system a break&quot;&lt;/p&gt;&lt;/td&gt;
&lt;td&gt;Breaks the circuit (blocks executions) for a period, when faults exceed some pre-configured threshold.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.8&quot;&gt;&lt;td&gt;&lt;span&gt;Timeout&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;a href=&quot;https://github.com/App-vNext/Polly#timeout&quot;&gt;quickstart&lt;/a&gt; ; &lt;a href=&quot;https://github.com/App-vNext/Polly/wiki/Timeout&quot;&gt;deep&lt;/a&gt;)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;
&lt;p&gt;Beyond a certain wait, a success result is unlikely.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;超时&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&quot;Don't wait forever&quot;&lt;/td&gt;
&lt;td&gt;Guarantees the caller won't have to wait beyond the timeout.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;18.512820512821&quot;&gt;&lt;td&gt;&lt;span&gt;Bulkhead Isolation&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;a href=&quot;https://github.com/App-vNext/Polly#bulkhead&quot;&gt;quickstart&lt;/a&gt; ; &lt;a href=&quot;https://github.com/App-vNext/Polly/wiki/Bulkhead&quot;&gt;deep&lt;/a&gt;)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;13&quot;&gt;
&lt;p&gt;When a process faults, multiple failing calls backing up can easily swamp resource (eg threads/CPU) in a host.&lt;/p&gt;&lt;p&gt;A faulting downstream system can also cause 'backed-up' failing calls upstream.&lt;/p&gt;&lt;p&gt;Both risk a faulting process bringing down a wider system.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个进程失败或多个失败的调用可以很容易的淹没主机的资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以需要隔离墙。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&quot;One fault shouldn't sink the whole ship&quot;&lt;/td&gt;
&lt;td&gt;Constrains the governed actions to a fixed-size resource pool, isolating their potential to affect others.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;10.718446601942&quot;&gt;&lt;td&gt;&lt;span&gt;Cache&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;a href=&quot;https://github.com/App-vNext/Polly#cache&quot;&gt;quickstart&lt;/a&gt; ; &lt;a href=&quot;https://github.com/App-vNext/Polly/wiki/Cache&quot;&gt;deep&lt;/a&gt;)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Some proportion of requests may be similar.&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&quot;You've asked that one before&quot;&lt;/td&gt;
&lt;td readability=&quot;6&quot;&gt;Provides a response from cache if known. &lt;p&gt;Stores responses automatically in cache, when first retrieved.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.556338028169&quot;&gt;&lt;td&gt;&lt;span&gt;Fallback&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;a href=&quot;https://github.com/App-vNext/Polly#fallback&quot;&gt;quickstart&lt;/a&gt; ; &lt;a href=&quot;https://github.com/App-vNext/Polly/wiki/Fallback&quot;&gt;deep&lt;/a&gt;)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;Things will still fail - plan what you will do when that happens.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某些将仍然失败，在它发生的时候，你要有计划准备做一些事。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&quot;Degrade gracefully&quot;&lt;/td&gt;
&lt;td&gt;Defines an alternative value to be returned (or action to be executed) on failure.&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8.5699658703072&quot;&gt;&lt;td&gt;&lt;span&gt;PolicyWrap&lt;/span&gt;&lt;br/&gt;&lt;span&gt;(&lt;a href=&quot;https://github.com/App-vNext/Polly#policywrap&quot;&gt;quickstart&lt;/a&gt; ; &lt;a href=&quot;https://github.com/App-vNext/Polly/wiki/PolicyWrap&quot;&gt;deep&lt;/a&gt;)&lt;/span&gt;&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;Different faults require different strategies; resilience means using a combination.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同的失败请求有不同的情况，所以可以对上面的策略有不同的结合处理。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;&quot;Defence in depth&quot;&lt;/td&gt;
&lt;td&gt;Allows any of the above policies to be combined flexibly.&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　每个策略大家有兴趣试着做例子。&lt;/p&gt;
&lt;p&gt;　　代码中开发非常简单，提供了三种配置策略的方法，下面是其中之一：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; timeout = Policy.TimeoutAsync&amp;lt;HttpResponseMessage&amp;gt;&lt;span&gt;(
    TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; longTimeout = Policy.TimeoutAsync&amp;lt;HttpResponseMessage&amp;gt;&lt;span&gt;(
    TimeSpan.FromSeconds(&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;));

services.AddHttpClient(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;conditionalpolicy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Run some code to select a policy based on the request&lt;/span&gt;
    .AddPolicyHandler(request =&amp;gt;&lt;span&gt; 
        request.Method &lt;/span&gt;== HttpMethod.Get ? timeout : longTimeout);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个在官方文档：https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/http-requests?view=aspnetcore-2.2#use-polly-based-handlers&lt;/p&gt;
&lt;p&gt;讲解的非常详细。&lt;/p&gt;
&lt;p&gt;还有就是polly的github地址：https://github.com/App-vNext/Polly&lt;/p&gt;
&lt;p&gt;都有非常详细的介绍。&lt;/p&gt;

</description>
<pubDate>Sat, 02 Feb 2019 04:32:00 +0000</pubDate>
<dc:creator>无为有道</dc:creator>
<og:description>一 简介 微服务将需多的功能拆分为许多的轻量级的子应用，这些子应用相互调度。好处就是轻量级，完全符合了敏捷开发的精神。我们知道ut（单元测试），不仅仅提高我们的程序的健壮性，而且可以强制将类和方法的设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ck0074451665/p/10347330.html</dc:identifier>
</item>
<item>
<title>详解什么是平衡二叉树（AVL）（修订补充版） - 五分钟学算法</title>
<link>http://www.cnblogs.com/fivestudy/p/10348045.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fivestudy/p/10348045.html</guid>
<description>&lt;h3 id=&quot;h&quot;&gt;前言&lt;/h3&gt;
&lt;blockquote readability=&quot;6.6551126516464&quot;&gt;
&lt;p&gt;Wiki:在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6&quot;&gt;计算机科学&lt;/a&gt;中，&lt;strong&gt;AVL树&lt;/strong&gt;是最早被发明的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&quot;&gt;自平衡二叉查找树&lt;/a&gt;。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为&lt;strong&gt;高度平衡树&lt;/strong&gt;。查找、插入和删除在平均和最坏情况下的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&quot;&gt;时间复杂度&lt;/a&gt;都是 O(logn）。增加和删除元素的操作则可能需要借由一次或多次&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC&quot;&gt;树旋转&lt;/a&gt;，以实现树的重新平衡。AVL 树得名于它的发明者 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%A5%A5%E5%B0%94%E5%90%89%C2%B7%E9%98%BF%E6%9D%B0%E5%B0%94%E6%9D%BE-%E9%9F%A6%E5%88%A9%E6%96%AF%E5%9F%BA&quot;&gt;G. M. Adelson-Velsky&lt;/a&gt; 和 &lt;a href=&quot;https://zh.wikipedia.org/w/index.php?title=Evgenii_Landis&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Evgenii Landis&lt;/a&gt;，他们在1962年的论文《An algorithm for the organization of information》中公开了这一数据结构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;h1&quot;&gt;1 为什么要有平衡二叉树&lt;/h3&gt;
&lt;p&gt;二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列 A = {1，2，3，4，5，6}，构造二叉搜索树如图 1.1。依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 1.1&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fzofsmoafpj31hc0u0t8y.jpg&quot; alt=&quot;图 1.1&quot;/&gt;图 1.1&lt;/p&gt;
&lt;p&gt;在此二叉搜索树中查找元素 6 需要查找 6 次。&lt;/p&gt;
&lt;p&gt;二叉搜索树的查找效率取决于树的高度，因此保持树的高度最小，即可保证树的查找效率。同样的序列 A，将其改为图 1.2 的方式存储，查找元素 6 时只需比较 3 次，查找效率提升一倍。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 1.2&quot; src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fzofyo9w0wj31k60mcjrg.jpg&quot; alt=&quot;图 1.2&quot;/&gt;图 1.2&lt;/p&gt;
&lt;p&gt;可以看出当节点数目一定，保持树的左右两端保持平衡，树的查找效率最高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种左右子树的高度相差不超过 1 的树为平衡二叉树。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;h2&quot;&gt;2. 定义&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;平衡二叉查找树&lt;/strong&gt;：简称平衡二叉树。由前苏联的数学家 &lt;strong&gt;A&lt;/strong&gt;delse-&lt;strong&gt;V&lt;/strong&gt;elskil 和 &lt;strong&gt;L&lt;/strong&gt;andis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。它具有如下几个性质：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以是空树。&lt;/li&gt;
&lt;li&gt;假如不是空树，任何一个节点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;平衡之意，如天平，即两边的分量大约相同。&lt;/p&gt;
&lt;p&gt;例如图 2.1 不是平衡二叉树，因为节点 60 的左子树不是平衡二叉树。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 2.1&quot; src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fzogeu6pn5j31ke0nyq35.jpg&quot; alt=&quot;图 2.1&quot;/&gt;图 2.1&lt;/p&gt;
&lt;p&gt;图 2.2 也不是平衡二叉树，因为虽然任何一个节点的左子树与右子树都是平衡二叉树，但高度之差已经超过 1 。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 2.2&quot; src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fzogewh2naj31kc0n6t8w.jpg&quot; alt=&quot;图 2.2&quot;/&gt;图 2.2&lt;/p&gt;
&lt;p&gt;图 2.3 是平衡二叉树。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 2.3&quot; src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fzqme36qn7j31h40rmac6.jpg&quot; alt=&quot;图 2.3&quot;/&gt;图 2.3&lt;/p&gt;
&lt;h3 id=&quot;h3&quot;&gt;3. 平衡因子&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义：&lt;/strong&gt;某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 3.1&quot; src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fzogqxlo4zj31k80lc3yl.jpg&quot; alt=&quot;图 3.1&quot;/&gt;图 3.1 &lt;img title=&quot;图 3.2&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fzogscuvtzj31jy0kwaa5.jpg&quot; alt=&quot;图 3.2&quot;/&gt;图 3.2 &lt;img title=&quot;图 3.3&quot; src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fzogsc9r7xj31jw0laglp.jpg&quot; alt=&quot;图 3.3&quot;/&gt;图 3.3&lt;/p&gt;
&lt;h3 id=&quot;h4&quot;&gt;4. 节点结构&lt;/h3&gt;
&lt;p&gt;定义平衡二叉树的节点结构：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct &lt;span class=&quot;hljs-title&quot; readability=&quot;1&quot;&gt;AVLNode *&lt;span class=&quot;hljs-title&quot; readability=&quot;2&quot;&gt;Tree;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;typedef &lt;span class=&quot;hljs-keyword&quot;&gt;int ElementType;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;struct &lt;span class=&quot;hljs-title&quot;&gt;AVLNode{&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int depth; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;Tree parent; &lt;/p&gt;&lt;p&gt;ElementType val; &lt;/p&gt;&lt;p&gt;Tree lchild;&lt;/p&gt;&lt;p&gt;Tree rchild;&lt;/p&gt;&lt;p&gt;AVLNode(&lt;span class=&quot;hljs-keyword&quot;&gt;int val=&lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;br/&gt;parent = &lt;span class=&quot;hljs-literal&quot;&gt;NULL;&lt;br/&gt;depth = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;lchild = rchild = &lt;span class=&quot;hljs-literal&quot;&gt;NULL;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this-&amp;gt;val=val;&lt;br/&gt;}&lt;br/&gt;};&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h5avl&quot;&gt;5. AVL树插入时的失衡与调整&lt;/h3&gt;
&lt;p&gt;图 5.1 是一颗平衡二叉树&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 5.1 &quot; src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fzolcmx1qqj31b00g6glk.jpg&quot; alt=&quot;图 5.1 &quot;/&gt;图 5.1&lt;/p&gt;
&lt;p&gt;在此平衡二叉树插入节点 99 ，树结构变为：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;动图 5.2&quot; src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1fzolopfxzxg30q60be41k.gif&quot; alt=&quot;动图 5.2&quot;/&gt;动图 5.2&lt;/p&gt;
&lt;p&gt;在动图 5.2 中，节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2，树失去平衡。&lt;/p&gt;
&lt;p&gt;在动图 5.2 中，以节点 66 为父节点的那颗树就称为 &lt;strong&gt;最小失衡子树&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最小失衡子树&lt;/strong&gt;：在新插入的节点向上查找，以第一个平衡因子的&lt;strong&gt;绝对值&lt;/strong&gt;超过 1 的节点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的&lt;/strong&gt;。根据旋转的方向有两种处理方式，&lt;strong&gt;左旋&lt;/strong&gt; 与 &lt;strong&gt;右旋&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。&lt;/p&gt;
&lt;h4 id=&quot;h51&quot;&gt;5.1 左旋&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;图 5.1.1&quot; src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fzolu39ojoj31gw0lumx9.jpg&quot; alt=&quot;图 5.1.1&quot;/&gt;图 5.1.1&lt;/p&gt;
&lt;p&gt;以图 5.1.1 为例，加入新节点 99 后， 节点 66 的左子树高度为 1，右子树高度为 3，此时平衡因子为 -2。为保证树的平衡，此时需要对节点 66 做出旋转，因为右子树高度高于左子树，对节点进行左旋操作，流程如下：&lt;/p&gt;
&lt;p&gt;（1）节点的右孩子替代此节点位置&lt;br/&gt;（2）右孩子的左子树变为该节点的右子树&lt;br/&gt;（3）节点本身变为右孩子的左子树&lt;/p&gt;
&lt;p&gt;整个操作流程如动图 5.1.2 所示。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;动图 5.1.2&quot; src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fzom2pmmr5g30q50ekdiy.gif&quot; alt=&quot;动图 5.1.2&quot;/&gt;动图 5.1.2&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;节点的右孩子替代此节点位置 —— 节点 66 的右孩子是节点 77 ，将节点 77 代替节点 66 的位置&lt;/li&gt;
&lt;li&gt;右孩子的左子树变为该节点的右子树 —— 节点 77 的左子树为节点 75，将节点 75 挪到节点 66 的右子树位置&lt;/li&gt;
&lt;li&gt;节点本身变为右孩子的左子树 —— 节点 66 变为了节点 77 的左子树&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;h52&quot;&gt;5.2 右旋&lt;/h4&gt;
&lt;p&gt;右旋操作与左旋类似，操作流程为：&lt;/p&gt;
&lt;p&gt;（1）节点的左孩子代表此节点&lt;br/&gt;（2）节点的左孩子的右子树变为节点的左子树&lt;br/&gt;（3）将此节点作为左孩子节点的右子树。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;动图 5.2.1&quot; src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1fzomfzo5eag30q50ek40u.gif&quot; alt=&quot;动图 5.2.1&quot;/&gt;动图 5.2.1&lt;/p&gt;
&lt;h3 id=&quot;h6avl&quot;&gt;6. AVL树的四种插入节点方式&lt;/h3&gt;
&lt;p&gt;假设一颗 AVL 树的某个节点为 A，有四种操作会使 A 的左右子树高度差大于 1，从而破坏了原有 AVL 树的平衡性。平衡二叉树插入节点的情况分为以下四种：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 6.0&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fzqpwcjzy5j318i0akq3t.jpg&quot; alt=&quot;图 6.0&quot;/&gt;图 6.0&lt;/p&gt;
&lt;p&gt;具体分析如下：&lt;/p&gt;
&lt;h4 id=&quot;h61all&quot;&gt;6.1 A的左孩子的左子树插入节点(LL)&lt;/h4&gt;
&lt;p&gt;只需要执行一次右旋即可。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;动图 6.1&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fzomzssf3ng30q50ekmyt.gif&quot; alt=&quot;动图 6.1&quot;/&gt;动图 6.1&lt;/p&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h62arr&quot;&gt;6.2 A的右孩子的右子树插入节点(RR)&lt;/h4&gt;
&lt;p&gt;只需要执行一次左旋即可。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;动图 6.2&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fzonjzgewgg30q50ek0uh.gif&quot; alt=&quot;动图 6.2&quot;/&gt;动图 6.2&lt;/p&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h63alr&quot;&gt;6.3 A的左孩子的右子树插入节点(LR)&lt;/h4&gt;
&lt;p&gt;若 A 的左孩子节点 B 的右子树 E 插入节点 F ，导致节点 A 失衡，如图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 6.3&quot; src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fzonocvbarj31gm0k4jrh.jpg&quot; alt=&quot;图 6.3&quot;/&gt;图 6.3&lt;/p&gt;
&lt;p&gt;A 的平衡因子为 2 ，若仍按照右旋调整，则变化后的图形为这样：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 6.3.1&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fzonqswj1cj31gy0j074a.jpg&quot; alt=&quot;图 6.3.1&quot;/&gt;图 6.3.1&lt;/p&gt;
&lt;p&gt;经过右旋调整发现，调整后树仍然失衡，说明这种情况单纯的进行右旋操作不能使树重新平衡。那么这种插入方式需要执行两步操作，使得旋转之后为 &lt;strong&gt;原来根节点的左孩子的右孩子作为新的根节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（1）对失衡节点 A 的左孩子 B 进行左旋操作，即上述 RR 情形操作。&lt;br/&gt;（2）对失衡节点 A 做右旋操作，即上述 LL 情形操作。&lt;/p&gt;
&lt;p&gt;调整过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 6.3.2&quot; src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1fzoo8glkatj31gq0l0t8v.jpg&quot; alt=&quot;图 6.3.2&quot;/&gt;图 6.3.2 &lt;img title=&quot;图 6.3.3&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fzoo8g596dj31gw0jit8t.jpg&quot; alt=&quot;图 6.3.3&quot;/&gt;图 6.3.3&lt;/p&gt;
&lt;p&gt;也就是说，经过这两步操作，使得 &lt;strong&gt;原来根节点的左孩子的右孩子 E 节点成为了新的根节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h64arl&quot;&gt;6.4 A的右孩子的左子树插入节点(RL)&lt;/h4&gt;
&lt;p&gt;右孩子插入左节点的过程与左孩子插入右节点过程类似，也是需要执行两步操作，使得旋转之后为 &lt;strong&gt;原来根节点的右孩子的左孩子作为新的根节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;（1）对失衡节点 A 的右孩子 C 进行右旋操作，即上述 LL 情形操作。&lt;br/&gt;（2）对失衡节点 A 做左旋操作，即上述 RR 情形操作。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;图 6.4&quot; src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fzqmh6y5ohj31me0mc3yl.jpg&quot; alt=&quot;图 6.4&quot;/&gt;图 6.4 &lt;img title=&quot;图 6.4.1&quot; src=&quot;https://ws2.sinaimg.cn/large/006tNc79gy1fzooj35wnqj31gs0jsmxb.jpg&quot; alt=&quot;图 6.4.1&quot;/&gt;图 6.4.1 &lt;img title=&quot;图 6.4.2&quot; src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1fzooj2th5lj31gc0jqwel.jpg&quot; alt=&quot;图 6.4.2&quot;/&gt;图 6.4.2&lt;/p&gt;
&lt;p&gt;也就是说，经过这两步操作，使得 &lt;strong&gt;原来根节点的右孩子的左孩子 D 节点成为了新的根节点&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;补充&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;上述四种插入方式的代码实现的辅助代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c++ language-c++ hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h65&quot;&gt;6.5 小总结&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;在所有的不平衡情况中，都是按照先 &lt;strong&gt;寻找最小不平衡树&lt;/strong&gt;，然后 &lt;strong&gt;寻找所属的不平衡类别&lt;/strong&gt;，再 &lt;strong&gt;根据 4 种类别进行固定化程序的操作&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;LL , LR ，RR ，RL其实已经为我们提供了最后哪个节点作为新的根指明了方向。如 LR 型最后的根节点为原来的根的左孩子的右孩子，RL 型最后的根节点为原来的根的右孩子的左孩子。只要记住这四种情况，可以很快地推导出所有的情况。&lt;/li&gt;
&lt;li&gt;维护平衡二叉树，最麻烦的地方在于平衡因子的维护。建议读者们根据小吴提供的图片和动图，自己动手画一遍，这样可以更加感性的理解操作。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;h7avl&quot;&gt;7. AVL树的四种删除节点方式&lt;/h3&gt;
&lt;p&gt;AVL 树和二叉查找树的删除操作情况一致，都分为四种情况：&lt;/p&gt;
&lt;p&gt;（1）删除叶子节点&lt;br/&gt;（2）删除的节点只有左子树&lt;br/&gt;（3）删除的节点只有右子树&lt;br/&gt;（4）删除的节点既有左子树又有右子树&lt;/p&gt;
&lt;p&gt;只不过 AVL 树在删除节点后需要重新&lt;strong&gt;检查平衡性并修正&lt;/strong&gt;，同时，删除操作与插入操作后的平衡修正区别在于，插入操作后只需要对插入栈中的弹出的第一个非平衡节点进行修正，而删除操作需要修正栈中的所有非平衡节点。&lt;/p&gt;
&lt;p&gt;删除操作的大致步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以前三种情况为基础尝试删除节点，并将访问节点入栈。&lt;/li&gt;
&lt;li&gt;如果尝试删除成功，则依次检查栈顶节点的平衡状态，遇到非平衡节点，即进行旋转平衡，直到栈空。&lt;/li&gt;
&lt;li&gt;如果尝试删除失败，证明是第四种情况。这时先找到被删除节点的右子树最小节点并删除它，将访问节点继续入栈。&lt;/li&gt;
&lt;li&gt;再依次检查栈顶节点的平衡状态和修正直到栈空。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于删除操作造成的非平衡状态的修正，可以这样理解：对左或者右子树的删除操作相当于对右或者左子树的插入操作，然后再对应上插入的四种情况选择相应的旋转就好了。&lt;/p&gt;
&lt;h4 id=&quot;h71&quot;&gt;7.1 删除叶子节点&lt;/h4&gt;
&lt;p&gt;处理步骤：&lt;/p&gt;
&lt;p&gt;①、将该节点直接从树中删除；&lt;/p&gt;
&lt;p&gt;②、其父节点的子树高度的变化将导致父节点平衡因子的变化，通过向上检索并推算其父节点是否失衡；&lt;/p&gt;
&lt;p&gt;③、如果其父节点未失衡，则继续向上检索推算其父节点的父节点是否失衡…如此反复②的判断，直到根节点 ；如果向上推算过程中发现了失衡的现象，则进行 ④ 的处理；&lt;/p&gt;
&lt;p&gt;④、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;动图 7.1.1&quot; src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fzqnvf8q5mg30qe0epach.gif&quot; alt=&quot;动图 7.1.1&quot;/&gt;动图 7.1.1&lt;/p&gt;
&lt;p&gt;具体数字演示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;动图 7.1&quot; src=&quot;https://ws4.sinaimg.cn/large/006tNc79gy1fzqne0cjl8g30qe0epdi7.gif&quot; alt=&quot;动图 7.1&quot;/&gt;动图 7.1&lt;/p&gt;
&lt;h4 id=&quot;h7273&quot;&gt;7.2 &amp;amp; 7.3 删除的节点只有左子树或右子树&lt;/h4&gt;
&lt;p&gt;处理步骤：&lt;/p&gt;
&lt;p&gt;①、将左子树（右子树）替代原有节点 C 的位置；&lt;/p&gt;
&lt;p&gt;②、节点 C 被删除后，则以 C 的父节点 B 为起始推算点，依此向上检索推算各节点（父、祖先）是否失衡；&lt;/p&gt;
&lt;p&gt;③、如果其父节点未失衡，则继续向上检索推算其父节点 的父节点 是否失衡…如此反复 ② 的判断，直到根节点 ；如果向上推算过程中发现了失衡的现象，则进行 ④ 的处理；&lt;/p&gt;
&lt;p&gt;④、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;动图 7.2&quot; src=&quot;https://ws3.sinaimg.cn/large/006tNc79gy1fzqovwao9xg30qe0epwfv.gif&quot; alt=&quot;动图 7.2&quot;/&gt;动图 7.2&lt;/p&gt;
&lt;h4 id=&quot;h74&quot;&gt;7.4 删除的节点既有左子树又有右子树&lt;/h4&gt;
&lt;p&gt;处理步骤：&lt;/p&gt;
&lt;p&gt;①、找到被删节点 B 和替代节点 BLR (节点 B 的前继节点或后继节点 —— 在此选择 &lt;strong&gt;前继&lt;/strong&gt;)；&lt;/p&gt;
&lt;p&gt;②、将替代节点 BLR 的值赋给节点 B ，再把替代节点 BLR 的左孩子 BLRL 替换替代节点 BLR 的位置；&lt;/p&gt;
&lt;p&gt;③、以 BLR 的父节点 BL 为起始推算点，依此向上检索推算父节点或祖先节点是否失衡；&lt;/p&gt;
&lt;p&gt;④、如果其父节点未失衡，则继续向上检索推算其父节点的父节点是否失衡…如此反复③的判断，直到根节点；如果向上推算过程中发现了失衡的现象，则进行⑤的处理；&lt;/p&gt;
&lt;p&gt;⑤、如果其父节点失衡，则判断是哪种失衡类型 [LL、LR、RR、RL] ，并对其进行相应的平衡化处理。如果平衡化处理结束后，发现与原来以父节点为根节点的树的高度发生变化，则继续进行 ② 的检索推算；如果与原来以父节点为根节点的高度一致时，则可说明父节点的父节点及祖先节点的平衡因子将不会有变化，因此可以退出处理；&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;动图 7.4&quot; src=&quot;https://ws1.sinaimg.cn/large/006tNc79gy1fzqpk97lodg30qe0epju1.gif&quot; alt=&quot;动图 7.4&quot;/&gt;动图 7.4&lt;/p&gt;
&lt;p&gt;注：在这里，小吴并没有给出 AVL 的删除操作的代码，也没有给出平衡性修复的动画，因为我并不打算过多去讨论它，更复杂的删除操作过程将放在后续的 &lt;strong&gt;红黑树&lt;/strong&gt; 中进行讨论。&lt;/p&gt;
&lt;h3 id=&quot;h-1&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;通过对 AVL 的插入操作和删除操作可以看出，平衡二叉树的优势在于不会出现普通二叉查找树的最差情况，即退化成链表结构，但为了保证高度平衡（对称），动态插入和删除的代价也随之增加。&lt;/p&gt;
&lt;p&gt;AVL 的旋转问题看似复杂，但实际上如果你亲自用笔纸操作一下还是很好理解的。&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 03:15:00 +0000</pubDate>
<dc:creator>五分钟学算法</dc:creator>
<og:description>详解什么是平衡二叉树（AVL）（修订补充版） 前言 Wiki:在计算机科学中，AVL树是最早被发明的自平衡二叉查找树。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为高度平衡树。查</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fivestudy/p/10348045.html</dc:identifier>
</item>
<item>
<title>深入浅出Tomcat/4 - Tomcat容器 - 张太国</title>
<link>http://www.cnblogs.com/confach/p/10348037.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/confach/p/10348037.html</guid>
<description>&lt;p&gt;Container是一个Tomcat容器的接口，Tomcat有四种容器&lt;/p&gt;
&lt;p&gt;·     Engine&lt;/p&gt;
&lt;p&gt;·     Host&lt;/p&gt;
&lt;p&gt;·     Context&lt;/p&gt;
&lt;p&gt;·     Wrapper&lt;/p&gt;

&lt;p&gt;Engine代表整个Catalina的Servlet引擎，Host则代表若干个上下文的虚拟主机。Context则代表一个Web应用，而一个Context则会用有多个Wrapper。Wrapper是一个单独的Servlet。&lt;/p&gt;

&lt;p&gt;下图是几种容器实现的类继承图，我们可以看到最下层以Standard开头的几个类&lt;/p&gt;
&lt;p&gt;·     StandardEngine&lt;/p&gt;
&lt;p&gt;·     StandardHost&lt;/p&gt;
&lt;p&gt;·     StandardContext&lt;/p&gt;
&lt;p&gt;·     StandardWrapper&lt;/p&gt;
&lt;p&gt;以上几个类是Tomcat对几种容器的默认实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1249/201902/1249-20190202111218705-1278099371.png&quot; alt=&quot;&quot; width=&quot;694&quot; height=&quot;310&quot;/&gt;&lt;/p&gt;

&lt;p&gt;以上几个类是Tomcat对几种容器的默认实现。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;Engine&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Engine的属性name，是Engine的名字，如果有多个Engine，Engine需要唯一。defaultHost也非常重要，如果一个Engine有多个Host时，如果匹配不到合适的Host时，则需要默认选取一个，也就是defaultHost定义的，它的值为Host的name。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Engine &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Catalina&quot;&lt;/span&gt;&lt;span&gt; defaultHost&lt;/span&gt;&lt;span&gt;=&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RealmclassName&lt;/span&gt;&lt;span&gt;=&quot;org.apache.catalina.realm.LockOutRealm&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;This Realm uses the UserDatabase configured in the global JNDI
         resources under the key&quot;UserDatabase&quot;.  Any edits
         that are performed against thisUserDatabase are immediately
         available for use by theRealm.  &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RealmclassName&lt;/span&gt;&lt;span&gt;=&quot;org.apache.catalina.realm.UserDatabaseRealm&quot;&lt;/span&gt;&lt;span&gt;
           resourceName&lt;/span&gt;&lt;span&gt;=&quot;UserDatabase&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Realm&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Host &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;  appBase&lt;/span&gt;&lt;span&gt;=&quot;webapps&quot;&lt;/span&gt;&lt;span&gt;
        unpackWARs&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; autoDeploy&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;SingleSignOn valve, share authentication between web applications
         Documentation at: /docs/config/valve.html&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;
    &amp;lt;ValveclassName=&quot;org.apache.catalina.authenticator.SingleSignOn&quot; /&amp;gt;
    &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Access log processes allexample.
         Documentation at:/docs/config/valve.html
         Note: The pattern used isequivalent to using pattern=&quot;common&quot; &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ValveclassName&lt;/span&gt;&lt;span&gt;=&quot;org.apache.catalina.valves.AccessLogValve&quot;&lt;/span&gt;&lt;span&gt;directory&lt;/span&gt;&lt;span&gt;=&quot;logs&quot;&lt;/span&gt;&lt;span&gt;
           prefix&lt;/span&gt;&lt;span&gt;=&quot;localhost_access_log&quot;&lt;/span&gt;&lt;span&gt; suffix&lt;/span&gt;&lt;span&gt;=&quot;.txt&quot;&lt;/span&gt;&lt;span&gt;
           pattern&lt;/span&gt;&lt;span&gt;=&quot;%h %l %u %t &amp;amp;quot;%r&amp;amp;quot; %s %b&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Engine&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Engine还有另外一个非常重要的属性叫jvmRoute，它一般用在Cluster里。&lt;/p&gt;
&lt;p&gt;假设Cluster是这么配置的，Tomcat1的 conf/server.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Engine &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Catalina&quot;&lt;/span&gt;&lt;span&gt; defaultHost&lt;/span&gt;&lt;span&gt;=&quot;localhost&quot;&lt;/span&gt;&lt;span&gt; jvmRoute&lt;/span&gt;&lt;span&gt;=&quot;tomcat1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Tomcat2的conf/server.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Engine &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Catalina&quot;&lt;/span&gt;&lt;span&gt; defaultHost&lt;/span&gt;&lt;span&gt;=&quot;localhost&quot;&lt;/span&gt;&lt;span&gt; jvmRoute&lt;/span&gt;&lt;span&gt;=&quot;tomcat2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在生成SessionID时，jvmRoute会用到的，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class StandardSessionIdGeneratorextends SessionIdGeneratorBase{
    @Override
    publicString generateSessionId(String route) {

        byterandom[] = newbyte[16];
        int sessionIdLength = getSessionIdLength();

        //Render the result as a String of hexadecimal digits
        // Start with enough space forsessionIdLength and medium route size
        StringBuilderbuffer = new StringBuilder(2 * sessionIdLength + 20);

        int resultLenBytes = 0;

        while (resultLenBytes &amp;lt; sessionIdLength) {
            getRandomBytes(random);
            for (int j = 0;
            j &amp;lt; random.length &amp;amp;&amp;amp; resultLenBytes &amp;lt; sessionIdLength;
            j++) {
                byte b1 = (byte) ((random[j] &amp;amp; 0xf0) &amp;gt;&amp;gt; 4);
                byte b2 = (byte) (random[j] &amp;amp; 0x0f);
                if (b1 &amp;lt; 10)
                    buffer.append((char) ('0' + b1));
                else
                    buffer.append((char) ('A' + (b1 - 10)));
                if (b2&amp;lt; 10)
                    buffer.append((char) ('0' + b2));
                else
                    buffer.append((char) ('A' + (b2 - 10)));
                resultLenBytes++;
            }
        }

        if(route != null&amp;amp;&amp;amp; route.length() &amp;gt; 0) {
            buffer.append('.').append(route);
        }else {
            String jvmRoute =getJvmRoute();
            if (jvmRoute != null &amp;amp;&amp;amp; jvmRoute.length() &amp;gt; 0) {
                buffer.append('.').append(jvmRoute);
            }
        }

        returnbuffer.toString();
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;最后几行代码显示如果在Cluster情况下会将jvmRoute加在sessionID后面。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Host是代表虚拟主机，主要设置appbase目录，例如webapps等。Host中的name代表域名,所以下面的例子中代表的localhost，可以通过localhost来访问。appBase是指该站点所在的目录，默认一般是webapps。unpackWARs这个属性也很重要，一般来说，一个webapp的发布包有格式各样，例如zip，war等，对于war包放到appBase&lt;/p&gt;
&lt;p&gt;下是否自动解压缩，显而易见，当为true时，自动解包。autoDeploy是指是指Tomcat在运行时应用程序是否自动部署。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Host &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;localhost&quot;&lt;/span&gt;&lt;span&gt;  appBase&lt;/span&gt;&lt;span&gt;=&quot;webapps&quot;&lt;/span&gt;&lt;span&gt;
      unpackWARs&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; autoDeploy&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;Context&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Context可以在以下几个地方声明：&lt;/p&gt;
&lt;p&gt;1.    Tomcat的server.xml配置文件中的&amp;lt;Context&amp;gt;节点用于配置Context，它直接在Tomcat解析server.xml的时候，就完成Context对象的创建。&lt;/p&gt;
&lt;p&gt;2.    Web应用的/META-INF/context.xml文件可用于配置Context，此配置文件用于配置Web应用对应的Context属性。&lt;/p&gt;
&lt;p&gt;3.    可用%CATALINA_HOME%/conf[EngineName]/[HostName]/[Web项目名].xml文件声明创建一个Context。&lt;/p&gt;
&lt;p&gt;4.    Tomcat全局配置为conf/context.xml，此文件配置的属性会设置到所有的Context中&lt;/p&gt;
&lt;p&gt;5.    Tomcat的Host级别配置文件为/conf[EngineName]/[HostName]/context.xml.default文件，它配置的属性会设置到某Host下面所有的Context中。&lt;/p&gt;

&lt;p&gt;以上5种方法有些是共享的，有些是独享的。其中后面2种是被Tomcat共享的。在实际的应用中，个人非常推荐第三种方法。如果在采用第一种方法，这种方法是有侵入性的，不建议，而且该文件是在Tomcat启动时才加载。对于共享的方法我个人也是不推荐使用的，毕竟在实际的应用中还是希望自己的app配置单独出来更合理一些。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;Wrapper&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Wrapper 代表一个Servlet，它负责管理一个Servlet，包括Servlet 的装载、初始化、执行以及资源回收。Wrapper的父容器一般是Context，Wrapper是最底层的容器，它没有子容器了，所以调用它的addChild 将会抛illegalargumentexception。Wrapper的实现类是StandardWrapper，StandardWrapper还实现了拥有一个Servlet 初始化信息的ServletConfig，由此看出StandardWrapper 将直接和Servlet 的各种信息打交道。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;Container的启动&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;前面的类图讲过，前面提到的容容器都实现或继承了LifeCycle，所以LifeCycle里的几个生命周期同样适用于这里。不过除了继承自LifeCycle之外，几个容器也继承ContainerBase这个类。几个Container的初始化和启动都是通过initInternal和startInternal来实现的。需要的话，各个容器可以实现自己的逻辑。&lt;/p&gt;

&lt;p&gt;因为4大容器都继承ContainerBase，我们看看该类的initInternal和startInternal的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {
   reconfigureStartStopExecutor(getStartStopThreads());
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.initInternal();
}


&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * Implementation note: If there is ademand for more control than this then
 * it is likely that the best solutionwill be to reference an external
 * executor.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; reconfigureStartStopExecutor(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; threads) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (threads == 1&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Use a fake executor&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;(startStopExecutorinstanceof InlineExecutorService)) {
            startStopExecutor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InlineExecutorService();
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Delegate utility execution to the Service&lt;/span&gt;
        Serverserver = Container.getService(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).getServer();
        server.setUtilityThreads(threads);
        startStopExecutor&lt;/span&gt;=&lt;span&gt; server.getUtilityExecutor();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到这里并没有设置一些状态。在初始化的过程中，初始化statStopExecutor，它的类型是java.util.concurrent.ExecutorService。&lt;/p&gt;

&lt;p&gt;下面是startInternal的代码，我们可以看出这里做的事情：&lt;/p&gt;
&lt;p&gt;1.    如果cluster和realm都配置后，需要调用它们自己的启动方法。&lt;/p&gt;
&lt;p&gt;2.    调用子容器的启动方法。&lt;/p&gt;
&lt;p&gt;3.    启动管道。&lt;/p&gt;
&lt;p&gt;4.    设置生命周期的状态。&lt;/p&gt;
&lt;p&gt;5.    同时启动一些background的监控线程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start our subordinate components, if any&lt;/span&gt;
    logger = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    getLogger();
    Cluster cluster &lt;/span&gt;=&lt;span&gt; getClusterInternal();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cluster &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Lifecycle) {
        ((Lifecycle) cluster).start();
    }
    Realm realm &lt;/span&gt;=&lt;span&gt; getRealmInternal();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (realm &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Lifecycle) {
        ((Lifecycle) realm).start();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start our child containers, if any&lt;/span&gt;
    Container children[] =&lt;span&gt; findChildren();
    List&lt;/span&gt;&amp;lt;Future&amp;lt;Void&amp;gt;&amp;gt; results = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; children.length; i++&lt;span&gt;) {
        results.add(startStopExecutor.submit(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; StartChild(children[i])));
    }

    MultiThrowable multiThrowable &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Future&amp;lt;Void&amp;gt;&lt;span&gt; result : results) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            result.get();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
            log.error(sm.getString(&lt;/span&gt;&quot;containerBase.threadedStartFailed&quot;&lt;span&gt;), e);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (multiThrowable == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                multiThrowable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MultiThrowable();
            }
            multiThrowable.add(e);
        }

    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (multiThrowable != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LifecycleException(sm.getString(&quot;containerBase.threadedStartFailed&quot;&lt;span&gt;),
                multiThrowable.getThrowable());
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start the Valves in our pipeline (including the basic), if any&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (pipeline &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; Lifecycle) {
        ((Lifecycle) pipeline).start();
    }

    setState(LifecycleState.STARTING);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start our thread&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (backgroundProcessorDelay &amp;gt; 0&lt;span&gt;) {
        monitorFuture &lt;/span&gt;= Container.getService(ContainerBase.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;).getServer()
                .getUtilityExecutor().scheduleWithFixedDelay(
                        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ContainerBackgroundProcessorMonitor(), 0, 60&lt;span&gt;, TimeUnit.SECONDS);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里首先根据配置启动了Cluster和Realm，启动的方法也很直观，直接调用它们的start方法。Cluster一般用于集群，Realm是Tomcat的安全域，管理资源的访问权限，例如身份认证，权限等。一个Tomcat可以拥有多个Realm的。&lt;/p&gt;

&lt;p&gt;根据代码，子容器是使用startStopExecutor来实现的，startStopExecutor会使用新的线程来启动，这样可以使用多个线程来同时启动多个子容器，这样在性能上更胜一筹。因为可能有多个子容器，把他们存入到Future的List里，然后遍历每个Future并调用其get方法。&lt;/p&gt;
&lt;p&gt;遍历Future的作用是什么？1，get方法是阻塞的，只有线程处理完后才能继续往下走，这样保证了Pipeline启动之前容器确保调用完成。2，可以处理启动过程中的异常，如果有容器启动失败，也不至于继续执行下去。&lt;/p&gt;

&lt;p&gt;启动子容器调用了StartChild这么一个类似，它的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; StartChild &lt;span&gt;implements&lt;/span&gt; Callable&amp;lt;Void&amp;gt;&lt;span&gt; {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Container child;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StartChild(Container child) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.child =&lt;span&gt; child;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Void call() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {
        child.start();
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个类也是定义在ContainerBase里的，所以所有容器的启动过程都对调用容器的start方法。&lt;/p&gt;
&lt;p&gt;我们可以看到StartChild实现了Callable接口。我们知道启动线程，有Runnable和Callable等方式，那么Runnable和Callable的区别在哪里呢？我认为的区别是：&lt;/p&gt;
&lt;p&gt;1.    对于实现Runnable，run方法并不会返回任何东西，但是对于Callable，真是可以实现当执行完成后返回结果的。但需要注意，一个线程并不能和Callable创建，尽可以和Runnable一起创建。&lt;/p&gt;
&lt;p&gt;2.    另外一个区别就是Callable的Call方式可以抛出Exception，但是Runnable的run方法这不可以。&lt;/p&gt;
&lt;p&gt;根据以上，我们可以看出为什么要用Callable，前面说捕获到异常也正是这个原理。&lt;/p&gt;
&lt;p&gt;在这里我们也看到了Future这个东西。有必要在这里详细解释一下Future的概念。Future用来表示异步计算的结果，它提供了一些方法用来检查计算是否已经完成，或等待计算的完成以及获取计算的结果。计算结束后的结果只能通过get方法来获取。当然，也可以使用Cancel方法来取消计算。在回到我们这里的代码，如下，我们可以看到结果已经存在result里，通过get方法来获取，前面我们分析Callable可以抛出异常，这里我们可以看到有捕获到这些异常的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (Future&amp;lt;Void&amp;gt;&lt;span&gt; result : results) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        result.get();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
        log.error(sm.getString(&lt;/span&gt;&quot;containerBase.threadedStartFailed&quot;&lt;span&gt;), e);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (multiThrowable == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            multiThrowable &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MultiThrowable();
        }
        multiThrowable.add(e);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;Engine&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Engine的默认实现类是StandardEngine，它的初始化和启动会调用initInternal和startInternal。下面是StandardEngine的结构图&lt;/p&gt;

&lt;p&gt;初始化和启动的代码分别如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure that a Realm is present before any attempt is made to start
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; one. This will create the default NullRealm if necessary.&lt;/span&gt;
&lt;span&gt;    getRealm();
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.initInternal();
}


&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Start this component and implement the requirements
 * of {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; org.apache.catalina.util.LifecycleBase#startInternal()}.
 *
 * &lt;/span&gt;&lt;span&gt;@exception&lt;/span&gt;&lt;span&gt; LifecycleException if this component detects a fatal error
 *  that prevents this component from being used
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Log our server identification information&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isInfoEnabled()) {
        log.info(sm.getString(&lt;/span&gt;&quot;standardEngine.start&quot;&lt;span&gt;, ServerInfo.getServerInfo()));
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Standard container startup&lt;/span&gt;
    &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.startInternal();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;初始化和启动还是分别调用了ContainerBase的initInternal·和startInternal。特别要注意的是initInternal额外调用了getRealm获取Realm的信息。那么getRealm的实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;@Override&lt;br/&gt;&lt;/strong&gt;public Realm getRealm() {&lt;br/&gt;Realm configured = super.getRealm();&lt;br/&gt;// If no set realm has been called - default to NullRealm&lt;br/&gt;// This can be overridden at engine, context and host level&lt;br/&gt;if (configured == null) {&lt;br/&gt;configured = new NullRealm();&lt;br/&gt;this.setRealm(configured);&lt;br/&gt;}&lt;br/&gt;return configured;&lt;br/&gt;}
&lt;/pre&gt;
&lt;p&gt;我们可以看出，如果没有realm配置，直接返回默认的NullRealm。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Host的默认实现类是StandardHost，继承图如下。&lt;/p&gt;

&lt;p&gt; 下面代码只有startInternal，并没有initInternal，那是因为StandardHost并没有重写initInternal。&lt;/p&gt;
&lt;p&gt;代码比较简单，除了调用ContainerBase的startInternal，前面还需要查询Pipeline里的Valve有没有和ErrorReport相关的。如果没有创建Valve一下，然后加到Pipeline里。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Set error report valve&lt;/span&gt;
    String errorValve =&lt;span&gt; getErrorReportValveClass();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((errorValve != &lt;span&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; (!errorValve.equals(&quot;&quot;&lt;span&gt;))) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; found = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            Valve[] valves &lt;/span&gt;=&lt;span&gt; getPipeline().getValves();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Valve valve : valves) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (errorValve.equals(valve.getClass().getName())) {
                    found &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;found) {
                Valve valve &lt;/span&gt;=&lt;span&gt;
                    (Valve) Class.forName(errorValve).getConstructor().newInstance();
                getPipeline().addValve(valve);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            ExceptionUtils.handleThrowable(t);
            log.error(sm.getString(
                    &lt;/span&gt;&quot;standardHost.invalidErrorReportValveClass&quot;&lt;span&gt;,
                    errorValve), t);
        }
    }
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.startInternal();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中默认的ErrorReport Valve是&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * The Java class name of the default error reporter implementation class
 * for deployed web applications.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; String errorReportValveClass =
    &quot;org.apache.catalina.valves.ErrorReportValve&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;strong&gt;Context&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;下面是Context的初始化代码，后面调用了NamingResource相关信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {
    &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.initInternal();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Register the naming resources&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (namingResources != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        namingResources.init();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send j2ee.object.created notification&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.getObjectName() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        Notification notification &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Notification(&quot;j2ee.object.created&quot;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getObjectName(), sequenceNumber.getAndIncrement());
        broadcaster.sendNotification(notification);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来看看startInternal，这个方法非常长，节选重要代码.&lt;/p&gt;
&lt;p&gt;如果resouce没有启动，需要调用resource的启动，接下来是调用web.xml中定义的Listener，另外还需要初始化该配置文件定义的Filter以及load-on-startup的Servlet。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;… …&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ok) {
        resourcesStart();
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;… …
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configure and call application event listeners&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ok) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;listenerStart()) {
                log.error(sm.getString(&lt;/span&gt;&quot;standardContext.listenerFail&quot;&lt;span&gt;));
                ok &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;……

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configure and call application filters&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ok) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;filterStart()) {
                log.error(sm.getString(&lt;/span&gt;&quot;standardContext.filterFail&quot;&lt;span&gt;));
                ok &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load and initialize all &quot;load on startup&quot; servlets&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ok) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;loadOnStartup(findChildren())){
                log.error(sm.getString(&lt;/span&gt;&quot;standardContext.servletFail&quot;&lt;span&gt;));
                ok &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 02 Feb 2019 03:11:00 +0000</pubDate>
<dc:creator>张太国</dc:creator>
<og:description>Container是一个Tomcat容器的接口，Tomcat有四种容器 · Engine · Host · Context · Wrapper Engine代表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/confach/p/10348037.html</dc:identifier>
</item>
<item>
<title>Geatpy遗传算法在曲线寻优上的初步探究 - 精灵族的魂</title>
<link>http://www.cnblogs.com/dent-lu/p/10340709.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dent-lu/p/10340709.html</guid>
<description>&lt;p&gt;园子里关于遗传算法的教案不少，但基于geatpy框架的并未多见，故分享此文以作参考，还望广大园友多多指教！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Geatpy&lt;/strong&gt;出自三所名校联合团队之手，是遗传算法领域的权威框架（python），其效率之高、应用领域之广远胜诸多第三方工具，此处不作赘述，直接上链接：&lt;/p&gt;
&lt;p&gt;官网：http://www.geatpy.com/start&lt;/p&gt;
&lt;p&gt;源码：https://github.com/geatpy-dev/geatpy/tree/master/geatpy&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;Geatpy&lt;/strong&gt;需要安装geatpy模块（pip install geatpy），linux下如果装完后import时出现报错，可以下载我帖尾链接里的wheel文件进行安装。&lt;/p&gt;
&lt;p&gt;言归正传，根据经典的遗传算法流程，无外乎这几个步骤：&lt;strong&gt;种群初始化&lt;/strong&gt; -&amp;gt;（&lt;strong&gt;&lt;strong&gt;适应度评价&lt;/strong&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;strong&gt;&lt;strong&gt;遴选&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt; -&amp;gt; &lt;strong&gt;交叉&lt;/strong&gt; -&amp;gt; &lt;strong&gt;&lt;strong&gt;变异&lt;/strong&gt;&lt;/strong&gt;）&amp;lt;- 循环进化直至终止条件达标。&lt;/p&gt;
&lt;p&gt;当然，有关遗传算法的原理和过程不做深讨，本文旨在剖析遗传算法在阵曲线寻优上的高效应用，我写了一个简单示例来帮助大家更好的理解，代码如下：&lt;/p&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;punishing.py - 罚函数demo&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; punishing(LegV, FitnV):
    FitnV[np.where(LegV &lt;/span&gt;== 0)[0]] =&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; FitnV
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; aimfc.py即目标函数，本例通过输入每一代的染色体，由自定义评价函数计算与目标曲线的面积差，作为目标函数值ObjV来输出 &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; MakeObjCurve(width):
    &lt;/span&gt;&lt;span&gt;''' &lt;/span&gt;&lt;span&gt;创建目标曲线，此处定义为一组正弦波拼接序列 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    n1 &lt;/span&gt;= width//3&lt;span&gt;
    n2 &lt;/span&gt;= width - 2*&lt;span&gt;n1
    x1&lt;/span&gt;=np.cos(np.arange(0,n1)) * 1&lt;span&gt;
    x2&lt;/span&gt;=np.cos(np.arange(0,n1)) * 4&lt;span&gt;
    x3&lt;/span&gt;=np.cos(np.arange(0,n2)) * 2&lt;span&gt;
    ObjCurve&lt;/span&gt;=&lt;span&gt;np.hstack((x1,x2,x3))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ObjCurve

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; CalScore(chrom):
    &lt;/span&gt;&lt;span&gt;''' &lt;/span&gt;&lt;span&gt;返回染色体与目标曲线之间的面积的倒数作为评分值 '''&lt;/span&gt;
    objCurve =&lt;span&gt; MakeObjCurve(len(chrom))
    area &lt;/span&gt;= chrom -&lt;span&gt; objCurve
    area &lt;/span&gt;*= 10**5                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;调整系数确保分值不受小数项干扰&lt;/span&gt;
    score = 1 / np.dot(area, area)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;计算差值的平方和以简化求面积过程&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; score

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; myEvaFunc(chroms):
    &lt;/span&gt;&lt;span&gt;''' &lt;/span&gt;&lt;span&gt;自定义评价函数，以评分值作为目标函数值 &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    scores &lt;/span&gt;=&lt;span&gt; []
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; chrom &lt;span&gt;in&lt;/span&gt;&lt;span&gt; chroms:
        score &lt;/span&gt;=&lt;span&gt; CalScore(chrom)
        scores.append(score)
    scores &lt;/span&gt;=&lt;span&gt; np.array([scores]).T
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; scores

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; aimfuc(Phen, LegV):

    ObjV &lt;/span&gt;=&lt;span&gt; myEvaFunc(Phen)
    exIdx &lt;/span&gt;=&lt;span&gt; np.argmin(ObjV[:, 0])

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 惩罚方法2： 标记非可行解在可行性列向量中对应的值为0，并编写punishing罚函数来修改非可行解的适应度。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 也可以不写punishing，因为Geatpy内置的算法模板及内核已经对LegV标记为0的个体的适应度作出了修改。&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用punishing罚函数实质上是对非可行解个体的适应度作进一步的修改&lt;/span&gt;
    LegV[exIdx] = 0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对非可行解作出标记，使其在可行性列向量中对应的值为0，此处标记的是得分最小项&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt; [ObjV, LegV]
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;163&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt; main.py即主函数，本例仅用于演示“已知曲线寻优”的过程 &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;

&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; geatpy as ga
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; search_objects(directory):
    directory&lt;/span&gt;=os.path.normpath(directory)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;规格化，防止分隔符造成的差异&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; os.path.isdir(directory):
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; IOError(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;The directory '&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' doesn't exist!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    objects&lt;/span&gt;=&lt;span&gt;{}
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; curdir,substrs,files &lt;span&gt;in&lt;/span&gt;&lt;span&gt; os.walk(directory):
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; jpeg &lt;span&gt;in&lt;/span&gt; (file &lt;span&gt;for&lt;/span&gt; file &lt;span&gt;in&lt;/span&gt; files &lt;span&gt;if&lt;/span&gt; file.endswith(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)):
            path&lt;/span&gt;=&lt;span&gt;os.path.join(curdir,jpeg)
            label&lt;/span&gt;=path.split(os.path.sep)[-2&lt;span&gt;]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; label &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; objects:
                objects[label]&lt;/span&gt;=&lt;span&gt;[]
            objects[label].append(path)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; objects

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; sga_mps_real_templet(AIM_M, AIM_F, PUN_M, PUN_F, FieldDRs, problem, maxormin, MAXGEN, NIND, SUBPOP, GGAP, selectStyle, recombinStyle, recopt, pm, distribute, drawing = 1&lt;span&gt;):
    &lt;span&gt;&lt;span&gt;&quot;&quot;&quot; &lt;/span&gt;&lt;/span&gt;&lt;span&gt;基于多种群独立进化单目标编程模板(实值编码)，各种群独立将父子两代合并进行选择，采取精英保留机制&lt;/span&gt; &lt;span&gt;&quot;&quot;&quot;&lt;br/&gt;&lt;/span&gt;
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;==========================初始化配置===========================&lt;/span&gt;
    GGAP = 0.5 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因为父子合并后选择，因此要将代沟设为0.5以维持种群规模&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取目标函数和罚函数&lt;/span&gt;
    aimfuc = getattr(AIM_M, AIM_F) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获得目标函数&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; PUN_F &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
        punishing &lt;/span&gt;= getattr(PUN_M, PUN_F) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获得罚函数&lt;/span&gt;
    NVAR = FieldDRs[0].shape[1] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到控制变量的个数&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义全局进化记录器，初始值为nan&lt;/span&gt;
    pop_trace = (np.zeros((MAXGEN ,2)) *&lt;span&gt; np.nan)
    pop_trace[:, 0] &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义变量记录器，记录控制变量值，初始值为nan&lt;/span&gt;
    var_trace = (np.zeros((MAXGEN ,NVAR)) *&lt;span&gt; np.nan)
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;=========================开始遗传算法进化=======================&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
    start_time &lt;/span&gt;= time.time() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始计时&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对于各个网格分别进行进化，采用全局进化记录器记录最优值&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; index &lt;span&gt;in&lt;/span&gt; range(len(FieldDRs)): &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历各个子种群，各子种群独立进化，互相不竞争&lt;/span&gt;
        FieldDR =&lt;span&gt; FieldDRs[index]
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; problem == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            Chrom &lt;/span&gt;= ga.crtrp(NIND, FieldDR) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成初始种群&lt;/span&gt;
        &lt;span&gt;elif&lt;/span&gt; problem == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
            Chrom &lt;/span&gt;=&lt;span&gt; ga.crtip(NIND, FieldDR)
        LegV &lt;/span&gt;= np.ones((NIND, 1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化种群的可行性列向量&lt;/span&gt;
        [ObjV, LegV] = aimfuc(Chrom, LegV) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 求初始种群的目标函数值&lt;/span&gt;
        repnum = 0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化重复个体数为0&lt;/span&gt;
        ax = None &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储上一帧图形&lt;/span&gt;
        gen =&lt;span&gt; 0
        badCounter &lt;/span&gt;= 0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用于记录在“遗忘策略下”被忽略的代数&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始进化！！&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; gen &amp;lt;&lt;span&gt; MAXGEN:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; badCounter &amp;gt;= 10 * MAXGEN: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 若多花了10倍的迭代次数仍没有可行解出现，则跳出&lt;/span&gt;
                &lt;span&gt;break&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进行遗传算子，生成子代&lt;/span&gt;
            SelCh = ga.recombin(recombinStyle, Chrom, recopt, SUBPOP) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 重组&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; problem == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                SelCh &lt;/span&gt;= ga.mutbga(SelCh,FieldDR, pm) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 变异&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; repnum &amp;gt; Chrom.shape[0] * 0.01: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当最优个体重复率高达1%时，进行一次高斯变异&lt;/span&gt;
                    SelCh = ga.mutgau(SelCh, FieldDR, pm) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 高斯变异&lt;/span&gt;
            &lt;span&gt;elif&lt;/span&gt; problem == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
                SelCh &lt;/span&gt;=&lt;span&gt; ga.mutint(SelCh, FieldDR, pm)
            LegVSel &lt;/span&gt;= np.ones((SelCh.shape[0], 1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化育种种群的可行性列向量&lt;/span&gt;
            [ObjVSel, LegVSel] = aimfuc(SelCh, LegVSel) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 求育种种群的目标函数值&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 父子合并&lt;/span&gt;
            Chrom =&lt;span&gt; np.vstack([Chrom, SelCh])
            ObjV &lt;/span&gt;=&lt;span&gt; np.vstack([ObjV, ObjVSel])
            LegV &lt;/span&gt;=&lt;span&gt; np.vstack([LegV, LegVSel])
            FitnV &lt;/span&gt;= ga.ranking(maxormin * ObjV, LegV, None, SUBPOP) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 适应度评价&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; PUN_F &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
                FitnV &lt;/span&gt;= punishing(LegV, FitnV) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用惩罚函数&lt;/span&gt;
            repnum = len(np.where(ObjV[np.argmax(FitnV)] == ObjV)[0]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算最优个体重复数&lt;/span&gt;
            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录进化过程&lt;/span&gt;
            bestIdx =&lt;span&gt; np.argmax(FitnV)
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (LegV[bestIdx] != 0) &lt;span&gt;and&lt;/span&gt; ((np.isnan(pop_trace[gen,1])) &lt;span&gt;or&lt;/span&gt; ((maxormin == 1) &amp;amp; (pop_trace[gen,1] &amp;gt;= ObjV[bestIdx])) &lt;span&gt;or&lt;/span&gt; ((maxormin == -1) &amp;amp; (pop_trace[gen,1] &amp;lt;=&lt;span&gt; ObjV[bestIdx]))):
                feasible &lt;/span&gt;= np.where(LegV != 0)[0] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 排除非可行解&lt;/span&gt;
                pop_trace[gen,0] += np.sum(ObjV[feasible]) / ObjV[feasible].shape[0] / len(FieldDRs) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录种群个体平均目标函数值&lt;/span&gt;
                pop_trace[gen,1] = ObjV[bestIdx] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当代目标函数的最优值&lt;/span&gt;
                var_trace[gen,:] = Chrom[bestIdx, :] &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录当代最优的控制变量值&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘制动态图&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; drawing == 2&lt;span&gt;:
                    ax &lt;/span&gt;= ga.sgaplot(pop_trace[:,[1]],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;子种群&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+str(index+1)+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;各代种群最优个体目标函数值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, False, ax, gen)
                badCounter &lt;/span&gt;= 0 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; badCounter计数器清零&lt;/span&gt;
            &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                gen &lt;/span&gt;-= 1 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 忽略这一代（遗忘策略）&lt;/span&gt;
                badCounter += 1
            &lt;span&gt;if&lt;/span&gt; distribute == True: &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 若要增强种群的分布性（可能会造成收敛慢）&lt;/span&gt;
                idx =&lt;span&gt; np.argsort(ObjV[:, 0], 0)
                dis &lt;/span&gt;= np.diff(ObjV[idx,0]) / (np.max(ObjV[idx,0]) - np.min(ObjV[idx,0]) + 1)&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 差分计算距离的修正偏移量&lt;/span&gt;
                dis = np.hstack([dis, dis[-1&lt;span&gt;]])
                dis &lt;/span&gt;= dis + np.min(dis) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修正偏移量+最小量=修正绝对量&lt;/span&gt;
                FitnV[idx, 0] *= np.exp(dis) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据相邻距离修改适应度，突出相邻距离大的个体，以增加种群的多样性&lt;/span&gt;
            [Chrom, ObjV, LegV] = ga.selecting(selectStyle, Chrom, FitnV, GGAP, SUBPOP, ObjV, LegV) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 选择&lt;/span&gt;
            gen += 1&lt;span&gt;
    end_time &lt;/span&gt;= time.time() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结束计时&lt;/span&gt;
    times = end_time -&lt;span&gt; start_time
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 后处理进化记录器&lt;/span&gt;
    delIdx =&lt;span&gt; np.where(np.isnan(pop_trace))[0]
    pop_trace &lt;/span&gt;=&lt;span&gt; np.delete(pop_trace, delIdx, 0)
    var_trace &lt;/span&gt;=&lt;span&gt; np.delete(var_trace, delIdx, 0)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pop_trace.shape[0] ==&lt;span&gt; 0:
        &lt;/span&gt;&lt;span&gt;raise&lt;/span&gt; RuntimeError(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error: no feasible solution. (有效进化代数为0，没找到可行解。)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出结果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; maxormin == 1&lt;span&gt;:
        best_gen &lt;/span&gt;= np.argmin(pop_trace[:, 1]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录最优种群是在哪一代&lt;/span&gt;
        best_ObjV = np.min(pop_trace[:, 1&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;elif&lt;/span&gt; maxormin == -1&lt;span&gt;:
        best_gen &lt;/span&gt;= np.argmax(pop_trace[:, 1]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录最优种群是在哪一代&lt;/span&gt;
        best_ObjV = np.max(pop_trace[:, 1&lt;span&gt;])
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;最优的目标函数值为：%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(best_ObjV))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;最优的控制变量值为：&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(NVAR):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(var_trace[best_gen, i])
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;有效进化代数：%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(pop_trace.shape[0]))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;最优的一代是第 %s 代&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(best_gen + 1&lt;span&gt;))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;时间已过 %s 秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(times))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 绘图&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; drawing !=&lt;span&gt; 0:
        ga.trcplot(pop_trace, [[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;种群个体平均目标函数值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;种群最优个体目标函数值&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]])
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回进化记录器、变量记录器以及执行时间&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; [pop_trace, var_trace, times, best_gen]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取函数接口地址&lt;/span&gt;
AIM_M = &lt;span&gt;__import__&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;aimfuc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
PUN_M &lt;/span&gt;= &lt;span&gt;__import__&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;punishing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
POP_SIZE &lt;/span&gt;= 300          &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 种群高度&lt;/span&gt;
CHROM_LENGTH = 20       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 染色体宽度&lt;/span&gt;
max_generation = 150    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进化代数&lt;/span&gt;
chrom_bottom = -4       &lt;span&gt;#&lt;/span&gt;&lt;span&gt;染色体数值下限&lt;/span&gt;
chrom_top = 4           &lt;span&gt;#&lt;/span&gt;&lt;span&gt;染色体数值上限&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 变量设置&lt;/span&gt;
x = []; b =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(CHROM_LENGTH):
    x.append([chrom_bottom, chrom_top]) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自变量的范围&lt;/span&gt;
    b.append([0, 0]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自变量是否包含下界&lt;/span&gt;
ranges=np.vstack(x).T &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成自变量的范围矩阵&lt;/span&gt;
borders = np.vstack(b).T &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成自变量的边界矩阵&lt;/span&gt;
precisions = [1]*CHROM_LENGTH &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在二进制/格雷码编码中代表自变量的编码精度，当控制变量是连续型时，根据crtfld参考资料，该变量只表示边界精度，故设置为一定的正数即可&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 生成网格化后的区域描述器集合&lt;/span&gt;
FieldDRs =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1&lt;span&gt;):
    FieldDRs.append(ga.crtfld(ranges, borders, precisions))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用编程模板(设置problem = 'R'处理实数型变量问题，详见该算法模板的源代码)&lt;/span&gt;
[pop_trace, var_trace, times, best_gen] = sga_mps_real_templet(AIM_M, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;aimfuc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, PUN_M, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;punishing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;br/&gt;FieldDRs, problem = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, maxormin = -1, MAXGEN = max_generation, NIND = POP_SIZE, SUBPOP = 1&lt;span&gt;, &lt;span&gt;GGAP = 0.9, &lt;/span&gt;\
 &lt;/span&gt;selectStyle = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tour&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, recombinStyle = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;xovdprs&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, recopt = 0.9, pm = 0.3, distribute = True, drawing = 1&lt;span&gt;)

bstChrom &lt;/span&gt;=&lt;span&gt; var_trace[best_gen]
objCurve &lt;/span&gt;=&lt;span&gt; AIM_M.MakeObjCurve(CHROM_LENGTH)

plt.ion()
fig &lt;/span&gt;= plt.figure(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;曲线寻优演示&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,facecolor=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lightgray&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ax1 &lt;/span&gt;= fig.add_subplot(2, 1, 1&lt;span&gt;)
ax2 &lt;/span&gt;= fig.add_subplot(2, 1, 2&lt;span&gt;)
ax1.set_title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Evaluation Map&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
ax1.grid(axis&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, linestyle=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(max_generation):
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i%5==&lt;span&gt;0:
        ax1.plot(var_trace[i], &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;o-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        ax2.cla()
        ax2.set_title(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;最优染色体[gen:%i]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(i+1&lt;span&gt;))
        ax2.plot(var_trace[i], &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;o-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dodgerblue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        plt.pause(&lt;/span&gt;0.001&lt;span&gt;)
ax2.cla()
ax2.grid(axis&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, linestyle=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ax2.plot(objCurve, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;o-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;orangered&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;目标曲线&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
ax2.plot(bstChrom, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;o-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, c=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dodgerblue&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;最优染色体[gen:%i]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(best_gen+1&lt;span&gt;))
plt.legend()
plt.ioff()
plt.show()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;请注意，此处我已&lt;strong&gt;将模板函数单独放到主函数中&lt;/strong&gt;以便大家更好的理解，返回值中增加了最优代数以便后续图例的显示。&lt;/p&gt;
&lt;p&gt;本例采用的进化模板是&lt;strong&gt;sga_mps_real_templet&lt;/strong&gt;，基于多种群进化单目标（实数值），用于实现&lt;strong&gt;寻找目标曲线&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目标曲线的定义函数在aimfc.py&lt;span&gt;&lt;span&gt;&lt;span&gt;的&lt;span&gt;MakeObjCurve函数中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，本例为3段振幅不同的cos函数拼接而成的模拟曲线，宽度20。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;种群初始值设置：种群高度300、染色体宽度20（与目标曲线宽度保持一致）、进化代数150、染色体数值上下限[-4,4]（与&lt;span&gt;目标&lt;/span&gt;曲线的上下限保持一致）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;接着我们开始寻优，&lt;/span&gt;通过&lt;span&gt;CalScore&lt;/span&gt;函数计算每代种群的每条染色体与目标函数之间的差值，经过一定的系数转换得到评分值（差值越大，评分越低），以单目标（1列）形式输出，由geatpy的ranking函数来决定适应度评价，然后继续遴选、交叉、变异，如此循环往复，直至达到近似目标值时终止（本例设定为150代时终止），寻优过程如下图：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316548/201902/1316548-20190201171411781-265629305.jpg&quot; alt=&quot;&quot; width=&quot;461&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最优的目标函数值为：7.287567405118076e-09&lt;br/&gt;有效进化代数：150&lt;br/&gt;最优的一代是第 148 代&lt;br/&gt;时间已过 1.3259999752044678 秒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以看到从50代左右优化曲线开始显著上扬，直到130代左右逐渐平缓，并且耗时非常少，来看寻优结果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316548/201902/1316548-20190201171405803-745336363.jpg&quot; alt=&quot;&quot; width=&quot;676&quot; height=&quot;571&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到除了第6个点的数值有细微差异之外，其他点几乎都是吻合的，基本实现了目标曲线的寻求。&lt;/p&gt;
&lt;p&gt;之所以抛出本例，最重要的一点在于geatpy遗传算法&lt;span&gt;&lt;strong&gt;不仅能寻求已知的目标函数&lt;/strong&gt;，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;还可以通过自定义的评分体系或第三方接口来参与实现寻优&lt;/strong&gt;&lt;/span&gt;过程，只需将&lt;strong&gt;&lt;span&gt;CalScore&lt;/span&gt;&lt;/strong&gt;函数稍作改动即可，以上。&lt;/p&gt;
&lt;p&gt;【wheel文件】: https://pan.baidu.com/s/1BwLq_m3Dd5RMqatvTYXrAw 提取码: vgkz&lt;/p&gt;

</description>
<pubDate>Sat, 02 Feb 2019 03:09:00 +0000</pubDate>
<dc:creator>精灵族的魂</dc:creator>
<og:description>园子里关于遗传算法的教案不少，但基于geatpy框架的并未多见，故分享此文以作参考，还望广大园友多多指教！ Geatpy出自三所名校联合团队之手，是遗传算法领域的权威框架（python），其效率之高、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dent-lu/p/10340709.html</dc:identifier>
</item>
<item>
<title>C#中为什么会出现空静态构造方法的写法 - CodeBear</title>
<link>http://www.cnblogs.com/CodeBear/p/10347834.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CodeBear/p/10347834.html</guid>
<description>&lt;p&gt;再过几个小时，就要回家过春节了，今天说些简单点的东西，大家在看C#代码的时候，一定会对这样的写法非常迷茫：在一个类中会出现一个空的静态构造方法。这不是多此一举吗，这样做的目的是什么？今天我就来说说这个内容。&lt;/p&gt;
&lt;p&gt;前段时间，小伙伴遇到一个问题，百思不得其解，我先来模拟下这个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; class Program
    {
        static void Main(string[] args)
        {
            //1.初始化配置中心
            Console.WriteLine(&quot;初始化配置中心&quot;);
           
            //2.利用从配置中心读取出来的内容进行了一些操作
             String config= MyTest.config;
            //dosomething
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public class MyTest
    {
        public static string config = getConfig();

        private static string getConfig()
        {
            //读取配置中心的内容,并返回
            return &quot;&quot;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码比较简单，就是有两个类，一个是主程序入口，一个是业务类，在业务类里面，定义了一个static的变量，给它赋上一个方法，方法中读取了配置中心的内容，并且返回，那么这个static的变量的值就是配置中心的内容了，在主程序入口，一开始就初始化了配置中心，然后访问在业务类中的静态变量，并且利用这个值，做一些后续操作。&lt;/p&gt;
&lt;p&gt;我们先不管这样的逻辑是否合理，就只看能否正常运行。&lt;/p&gt;
&lt;p&gt;这样的代码看上去并没有什么问题，但是让人不解的是，抛出了异常，内容是“配置中心未初始化”，小伙伴懵了，明明一开始就初始了配置中心啊，为什么读取配置中心内容的时候，还会出现这样的异常呢。&lt;/p&gt;
&lt;p&gt;我一看，立刻懂了，于是我在业务类中，加了一个静态的构造方法，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class MyTest
    {
        public static string config = getConfig();

        private static string getConfig()
        {
            //读取配置中心的内容,并返回
            return &quot;&quot;;
        }

        static MyTest() { }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一切都好了。&lt;/p&gt;
&lt;p&gt;我加了一个空的静态方法，注意是空的，为什么加了一个空的静态方法可以解决问题呢？我们再来做个试验把：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    class Program
    {
        static void Main(string[] args)
        {
            //初始化配置中心
            Console.WriteLine(&quot;初始化配置中心&quot;);

            //2.利用从配置中心读取出来的内容进行了一些操作
            String config = MyTest.config;
            Console.WriteLine(config);
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;  public class MyTest
    {
        public static string config = getConfig();

        private static string getConfig()
        {
            Console.WriteLine(&quot;进到了getConfig方法&quot;);
            //读取配置中心的内容,并返回
            return &quot;配置中心的内容&quot;;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们想想会输出什么？这还不简单，当然是 初始化配置中心 进到了getConfig方法 配置中心的内容，但是，当我们运行：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-62ca31a4d2beca85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;你会发现，奇怪的事情出现了，第一个输出的竟然是 进到了“getConfig方法”。&lt;/p&gt;
&lt;p&gt;我们为MyTest类加上一个空的静态构造方法，再看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class MyTest
    {
        public static string config = getConfig();

        private static string getConfig()
        {
            Console.WriteLine(&quot;进到了getConfig方法&quot;);
            //读取配置中心的内容,并返回
            return &quot;配置中心的内容&quot;;
        }

        static MyTest() { }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-71f4ff111f235254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出竟然被改变了。&lt;/p&gt;
&lt;p&gt;这就是解释了为什么小伙伴一开始的代码会出现问题的原因，因为程序一上来，还没有执行 初始化配置中心呢，直接读取了配置中心的内容，而我加上的空静态构造方法，就改变了代码的执行顺序，是不是很神奇。&lt;/p&gt;
&lt;p&gt;我们在用ILSpy看下IL代码，当类中没有静态构造方法的时候：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-e88b7591a6d6755b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;IL代码有一个标记：beforefieldinit&lt;/p&gt;
&lt;p&gt;当类中的静态构造方法的时候：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15100432-7e3b680be9ca56b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;beforefieldinit标记消失了。&lt;/p&gt;
&lt;p&gt;我们来做一个总结，当一个类中没有静态构造方法的时候，IL会有beforefieldinit标记，程序一运行，就会初始化静态字段，当一个类中有静态构造方法的时候，IL没有beforefieldinit标记，程序一开始就不会初始化静态字段，而是用到这个类了，才初始化静态字段。&lt;/p&gt;
&lt;p&gt;现在我们可以解释为什么在饿汉式的单例模式中，经常会看到空的构造方法了，因为不想让程序在一开始的时候就初始化这个单例对象，而是用到了才去初始化，相当于懒加载，其实这也是一种优化，如果程序运行后，长时间没有使用到这个单例对象，而一开始程序就把单例对象加载到内存中去了，也是一种浪费。&lt;/p&gt;
&lt;p&gt;这篇的内容到这里就结束了，哈哈，马上就解放啦。&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 03:05:00 +0000</pubDate>
<dc:creator>CodeBear</dc:creator>
<og:description>再过几个小时，就要回家过春节了，今天说些简单点的东西，大家在看C 代码的时候，一定会对这样的写法非常迷茫：在一个类中会出现一个空的静态构造方法。这不是多此一举吗，这样做的目的是什么？今天我就来说说这个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CodeBear/p/10347834.html</dc:identifier>
</item>
<item>
<title>maven快速入门 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10347823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10347823.html</guid>
<description>&lt;p&gt;&lt;span&gt;maven是基于JAVA平台的自动化构建工具&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和maven有同样用途的工具还有以下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;make----ant----maven-----gradle&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要用途就是便于管理第三方jar包，方便jar包的下载，jar包之间版本的关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;maven的仓库主要分为本地仓库，中央仓库和多个远程镜像仓库，加载jar包时先从本地仓库再到中央仓库&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190202111601486-1781586270.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190202111343055-1360769748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;maven的官网下载地址：&lt;a href=&quot;http://maven.apache.org/download.cgi&quot; target=&quot;_blank&quot;&gt;http://maven.apache.org/download.cgi&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载二进制包，解压后，配置环境变量，在cmd窗口中运行mvn -v 能查到安装的版本，则表示安装成功。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;JavaProject的pom.xml文件说明&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、pom意思就是project object model。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2、pom.xml包含了项目构建的信息，包括项目的信息、项目的依赖等。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3、pom.xml文件是可以继承的，大型项目中，子模块的pom.xml一般都会继承于父模块的pom.xml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pom.xml文件的内容如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.2.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    
    &amp;lt;groupId&amp;gt;com.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybaitis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;mybaitis&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.0.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;8.0.14&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;


        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-generator-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.3.5&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;!--添加mybatis generator maven插件--&amp;gt;
            &amp;lt;plugin&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.generator&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-generator-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.3.5&amp;lt;/version&amp;gt;
            &amp;lt;configuration&amp;gt;
                &amp;lt;!--generatorConfig.xml位置--&amp;gt;
                &amp;lt;configurationFile&amp;gt;src/main/resources/mybatis-generator/generatorConfig.xml&amp;lt;/configurationFile&amp;gt;
                &amp;lt;verbose&amp;gt;true&amp;lt;/verbose&amp;gt;
                &amp;lt;overwrite&amp;gt;true&amp;lt;/overwrite&amp;gt;
            &amp;lt;/configuration&amp;gt;
            &amp;lt;executions&amp;gt;
                &amp;lt;execution&amp;gt;
                    &amp;lt;id&amp;gt;Generate MyBatis Artifacts&amp;lt;/id&amp;gt;
                    &amp;lt;goals&amp;gt;
                        &amp;lt;goal&amp;gt;generate&amp;lt;/goal&amp;gt;
                    &amp;lt;/goals&amp;gt;
                    &amp;lt;phase&amp;gt;generate-sources&amp;lt;/phase&amp;gt;
                &amp;lt;/execution&amp;gt;
            &amp;lt;/executions&amp;gt;
            &amp;lt;!--此处必须添加mysql驱动包--&amp;gt;
            &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&amp;gt;
                &amp;lt;dependency&amp;gt;
                    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
                    &amp;lt;version&amp;gt;8.0.14&amp;lt;/version&amp;gt;
                &amp;lt;/dependency&amp;gt;

            &amp;lt;/dependencies&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190202112359018-2125500970.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;其中由groupId、artifactId和version唯一的确定了一个项目坐标&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 02 Feb 2019 03:01:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>maven是基于JAVA平台的自动化构建工具 和maven有同样用途的工具还有以下： make ant maven gradle 主要用途就是便于管理第三方jar包，方便jar包的下载，jar包之间版</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10347823.html</dc:identifier>
</item>
</channel>
</rss>