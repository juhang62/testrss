<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Maven入门 - Sheldon_Lou</title>
<link>http://www.cnblogs.com/sheldon-lou/p/10649269.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheldon-lou/p/10649269.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://spring.io/guides/gs/maven/&quot;&gt;原文1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://maven.apache.org/install.html&quot;&gt;原文2&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;你要做的东西&quot;&gt;你要做的东西&lt;/h3&gt;
&lt;p&gt;通过Maven来构建一个显示当天时间的应用。&lt;/p&gt;
&lt;h3 id=&quot;你需要的东西&quot;&gt;你需要的东西&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;15分钟&lt;/li&gt;
&lt;li&gt;你喜欢的文本编辑器或者IDE&lt;/li&gt;
&lt;li&gt;JDK 8 或者更新&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;如何完成这个指南&quot;&gt;如何完成这个指南&lt;/h3&gt;
&lt;p&gt;我是新手，走最基础的方式&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;创建项目&quot;&gt;创建项目&lt;/h3&gt;
&lt;p&gt;首先，你需要创建一个项目用来给Maven构建。把注意力集中到Maven上，项目做得尽可能简单。项目结构如下。&lt;/p&gt;
&lt;pre class=&quot;restructuredtext&quot;&gt;
&lt;code&gt;src
    main
        java
            hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找个文件夹先创建一下目录 &lt;code&gt;mkdir -p src/main/java/hello&lt;/code&gt;，然后创建2个类。&lt;code&gt;HelloWorld.java&lt;/code&gt; 和 &lt;code&gt;Greeter.java&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package hello;

public class HelloWorld {
    public static void main(String[] args) {
        Greeter greeter = new Greeter();
        System.out.println(greeter.sayHello());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package hello;

public class Greeter {
    public String sayHello() {
        return &quot;Hello world!&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就有了一个可以用Maven构建的项目，下一步就是要安装Maven。&lt;/p&gt;
&lt;h4 id=&quot;安装maven&quot;&gt;安装Maven&lt;/h4&gt;
&lt;p&gt;Maven可以在&lt;a href=&quot;https://maven.apache.org/download.cgi&quot;&gt;链接&lt;/a&gt;下载。只需要二进制文件就好，像&lt;code&gt;apache-maven-*{version}*-bin.zip&lt;/code&gt;或&lt;code&gt;apache-maven-*{version}*-bin.tar.gz&lt;/code&gt;这样的链接。&lt;/p&gt;
&lt;p&gt;下载完成之后解压，然后把解压出来的&lt;code&gt;bin&lt;/code&gt;目录添加到&lt;code&gt;PATH&lt;/code&gt;环境变量中。&lt;/p&gt;
&lt;p&gt;先检查一下JAVA_HOME环境变量的值。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;echo $JAVA_HOME
/Library/Java/JavaVirtualMachines/jdk1.8.0_45.jdk/Contents/Home&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后修改&lt;code&gt;PATH&lt;/code&gt;的值&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;export PATH=/opt/apache-maven-3.6.0/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后用&lt;code&gt;mvn -v&lt;/code&gt;测试一下&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;Apache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功安装。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;跳过&lt;code&gt;Maven Wrapper&lt;/code&gt;相关的介绍&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;定义一个简单的maven构建&quot;&gt;定义一个简单的Maven构建&lt;/h3&gt;
&lt;p&gt;按照上面步骤装好Maven，现在需要创建一个Maven项目的定义文件。通过&lt;code&gt;pom.xml&lt;/code&gt;来实现。这里可以指定项目的名称，版本，外部依赖项。&lt;/p&gt;
&lt;p&gt;在项目的根目录创建一个_pom.xml_文件，和src文件夹同级，内容如下。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;gs-maven&amp;lt;/artifactId&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;
    &amp;lt;version&amp;gt;0.1.0&amp;lt;/version&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;maven-shade-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.1&amp;lt;/version&amp;gt;
                &amp;lt;executions&amp;gt;
                    &amp;lt;execution&amp;gt;
                        &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
                        &amp;lt;goals&amp;gt;
                            &amp;lt;goal&amp;gt;shade&amp;lt;/goal&amp;gt;
                        &amp;lt;/goals&amp;gt;
                        &amp;lt;configuration&amp;gt;
                            &amp;lt;transformers&amp;gt;
                                &amp;lt;transformer
                                    implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&amp;gt;
                                    &amp;lt;mainClass&amp;gt;hello.HelloWorld&amp;lt;/mainClass&amp;gt;
                                &amp;lt;/transformer&amp;gt;
                            &amp;lt;/transformers&amp;gt;
                        &amp;lt;/configuration&amp;gt;
                    &amp;lt;/execution&amp;gt;
                &amp;lt;/executions&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了可选的&lt;code&gt;&amp;lt;packaging&amp;gt;&lt;/code&gt;元素，这是一个最简单的用来构建项目的pom 配置文件。他包括以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;modelVersion&amp;gt;&lt;/code&gt; pom文件模型的版本。一直是4.0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;groupId&amp;gt;&lt;/code&gt; 表示项目所属的组或组织，通常是反过来写的域名。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;artifactId&amp;gt;&lt;/code&gt; 项目最后生成的文件的名字，比如jar 或者 war文件的名字。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; 项目的版本。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;packaging&amp;gt;&lt;/code&gt; 打包的方式，默认是jar，也可以指定war。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;4.4545454545455&quot;&gt;
&lt;p&gt;当选择版本的时候，建议使用 &lt;a href=&quot;https://semver.org/&quot;&gt;链接&lt;/a&gt;方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;编译java代码&quot;&gt;编译java代码&lt;/h3&gt;
&lt;p&gt;现在可以用Maven来编译你的项目了。可以用Maven做到以下几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编译你的项目代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn compile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成之后在 &lt;em&gt;target/classes&lt;/em&gt; 目录下会生成编译好的.class 文件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建jar包&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn package&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;package命令会编译代码+运行测试+生成jar文件。jar文件名是依据pom里面设置的artifactId和version来的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在本地Maven仓库安装依赖&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Maven也会在本机上维护依赖项。通常是在&lt;code&gt;.m2/repository&lt;/code&gt;目录以便下次用到的时候尽快访问到。如果你想把你项目的jar文件安装到本地仓库，你需要使用install命令。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个命令会编译，测试，打包你的代码，然后安装到本地仓库，用于其他项目的依赖引用。&lt;/p&gt;
&lt;h3 id=&quot;声明依赖项&quot;&gt;声明依赖项&lt;/h3&gt;
&lt;p&gt;上面的项目很简单，没有依赖其他任何库。但通常来说，大部分项目都是需要依赖外部库来处理一系列问题。&lt;/p&gt;
&lt;p&gt;举个例子说，我们需要使用&lt;code&gt;Joda&lt;/code&gt;这个库来打印当前时间。&lt;/p&gt;
&lt;p&gt;首先改一下HelloWorld.java的代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package hello;

import org.joda.time.LocalTime;

public class HelloWorld {
    public static void main(String[] args) {
        LocalTime currentTime = new LocalTime();
        System.out.println(&quot;The current local time is: &quot; + currentTime);
        Greeter greeter = new Greeter();
        System.out.println(greeter.sayHello());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果直接运行&lt;code&gt;mvn compile&lt;/code&gt;，编译会报错。我们需要在&lt;code&gt;&amp;lt;project&amp;gt;&lt;/code&gt;节点中增加下面内容。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;joda-time&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;joda-time&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的xml定义了项目需要用到的依赖项。group，artifactId，version和上面的意思一样。dependency默认的作用域是&lt;code&gt;compile&lt;/code&gt;，这意味着他们的在编译期间是可用的。可以通过&lt;code&gt;&amp;lt;scope&amp;gt;&lt;/code&gt;来指定他们的作用域。还有两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;provided&lt;/code&gt; 编译+运行时可用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;test&lt;/code&gt;编译+测试时可用，运行时不可用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再次运行compile，mvn就会去下载对应的dependency。&lt;/p&gt;
&lt;h3 id=&quot;编写测试&quot;&gt;编写测试&lt;/h3&gt;
&lt;p&gt;第一步，添加一下JUnit依赖到pom.xml文件中，作用域是test。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.12&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个&lt;code&gt;src/test/java/hello/GreeterTest&lt;/code&gt;测试用例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package hello;

import static org.hamcrest.CoreMatchers.containsString;
import static org.junit.Assert.*;

import org.junit.Test;

public class GreeterTest {

    private Greeter greeter = new Greeter();

    @Test
    public void greeterSaysHello() {
        assertThat(greeter.sayHello(), containsString(&quot;Hello&quot;));
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Maven使用&lt;code&gt;surefire&lt;/code&gt;插件来运行单元测试。默认的配置是运行所有&lt;code&gt;src/test/java&lt;/code&gt;下&lt;code&gt;Test&lt;/code&gt;结尾的类。下面来运行。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;恭喜，你完成了。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Apr 2019 07:42:00 +0000</pubDate>
<dc:creator>Sheldon_Lou</dc:creator>
<og:description>'原文1' '原文2' 你要做的东西 通过Maven来构建一个显示当天时间的应用。 你需要的东西 15分钟 你喜欢的文本编辑器或者IDE JDK 8 或者更新 如何完成这个指南 我是新手，走最基础的方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sheldon-lou/p/10649269.html</dc:identifier>
</item>
<item>
<title>海思uboot启动流程详细分析（一） - yooooooo</title>
<link>http://www.cnblogs.com/linhaostudy/p/10649273.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linhaostudy/p/10649273.html</guid>
<description>&lt;h2 id=&quot;第一阶段-start.s&quot;&gt;第一阶段 start.S&lt;/h2&gt;
&lt;p&gt;首先我们可以在u-boot.lds中看到&lt;code&gt;ENTRY(_start)&lt;/code&gt;，即指定了入口&lt;code&gt;_start&lt;/code&gt;，&lt;code&gt;_start&lt;/code&gt;也就是整个&lt;code&gt;start.S&lt;/code&gt;的最开始；&lt;/p&gt;
&lt;h3 id=&quot;reset&quot;&gt;1. reset&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;arch\arm\cpu\armv8\hi3559av100&lt;/code&gt;中的&lt;code&gt;start.S&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
reset:
    /*
     * Could be EL3/EL2/EL1, Initial State:
     * Little Endian, MMU Disabled, i/dCache Disabled
     */
    adr    x0, vectors
    switch_el x1, 3f, 2f, 1f
3:  msr    vbar_el3, x0
    mrs    x0, scr_el3
    orr    x0, x0, #0xf             /* SCR_EL3.NS|IRQ|FIQ|EA */
    msr    scr_el3, x0
    msr    cptr_el3, xzr            /* Enable FP/SIMD */
#ifdef COUNTER_FREQUENCY
    ldr    x0, =COUNTER_FREQUENCY
    msr    cntfrq_el0, x0           /* Initialize CNTFRQ */
#endif
    b      0f
2:  msr    vbar_el2, x0
    mov    x0, #0x33ff
    msr    cptr_el2, x0             /* Enable FP/SIMD */
    b      0f
1:  msr    vbar_el1, x0
    mov    x0, #3 &amp;lt;&amp;lt; 20
    msr    cpacr_el1, x0            /* Enable FP/SIMD */
0:
    /*
     * Cache/BPB/TLB Invalidate
     * i-cache is invalidated before enabled in icache_enable()
     * tlb is invalidated before mmu is enabled in dcache_enable()
     * d-cache is invalidated before enabled in dcache_enable()
     */

    /*
     *  read system register REG_SC_GEN2
     *  check if ziju flag
     */
    ldr    x0, =SYS_CTRL_REG_BASE
    ldr    w1, [x0, #REG_SC_GEN2]
    ldr    w2, =0x7a696a75         /* magic for &quot;ziju&quot; */
    cmp    w1, w2
    bne    normal_start_flow
    mov    x1, sp                  /* save sp */
    str    w1, [x0, #REG_SC_GEN2]  /* clear ziju flag */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;adr x0, vectors&lt;/code&gt;，其中的vectors代表了异常向量表&lt;/p&gt;
&lt;p&gt;主要做了如下事情：&lt;/p&gt;
&lt;p&gt;1）reset SCTRL寄存器&lt;/p&gt;
&lt;p&gt;具体可参考reset_sctrl函数，由CONFIG_SYS_RESET_SCTRL控制，一般不需要打开。该配置项的解释如下：&lt;/p&gt;
&lt;blockquote readability=&quot;5.5879396984925&quot;&gt;
&lt;p&gt;Reset the SCTRL register at the very beginning of execution to avoid interference from stale mappings set up by early firmware/loaders/etc.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://lists.denx.de/pipermail/u-boot/2015-April/211147.html&quot; class=&quot;uri&quot;&gt;http://lists.denx.de/pipermail/u-boot/2015-April/211147.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2）根据当前的EL级别，配置中断向量、MMU、Endian、i/d Cache等。&lt;/p&gt;
&lt;p&gt;3）配置ARM的勘误表&lt;/p&gt;
&lt;p&gt;具体可参考apply_core_errata函数，由CONFIG_ARM_ERRATA_XXX控制，在项目的初期，可以不打开，后续根据实际情况打开）。&lt;/p&gt;
&lt;h3 id=&quot;normal_start_flow流程&quot;&gt;2. normal_start_flow流程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;这里是正常启动流程&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;normal_start_flow:
    /* set stack for C code  */
    ldr    x0, =(CONFIG_SYS_INIT_SP_ADDR)
    bic    sp, x0, #0xf            /* 16-byte alignment for ABI compliance */

    bl      uart_early_init
    adr     x0, Str_SystemSartup
    bl      uart_early_puts
    ldr  x0, =0x1202008c
    ldr w0, [x0]
    bl uart_early_put_hex
    /* enable I-Cache  */
    bl     icache_enable&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1）设置代码的堆栈&lt;br/&gt;2.）跳转到uart_early_init&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为uart_early_init是全局的伪汇编指令（在uart.S中定义），所以在start.S中也可以使用到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3）声明一个字符串Str_SystemSartup&lt;br/&gt;4）使能icache&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;bne normal_start_flow&lt;/code&gt;是不跳转回来的，所以会继续向下执行&lt;/p&gt;
&lt;h3 id=&quot;running_addr_check流程&quot;&gt;3. running_addr_check流程&lt;/h3&gt;
&lt;p&gt;判断是否进入not_ddr_init中，不需要DDR初始化，直接copy到DDR中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;check_boot_mode:
    ldr    x0, =SYS_CTRL_REG_BASE
    ldr    w0, [x0, #REG_SYSSTAT]
    lsr    w6, w0, #4
    and    w6, w6, #0x3
    cmp    w6, #BOOT_FROM_EMMC  //判断是不是EMMC启动
    bne    ufs_boot //如果不是，则进入ufs_boot&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ziju_flow流程&quot;&gt;4. ziju_flow流程&lt;/h3&gt;
&lt;p&gt;自举模式从这里我可以推断出，芯片的启动分为两种，一种是自举模式也就是本地的spiflash或nand或emmc等启动，另一种就是pcie启动模式。不同启动模式对应不同的启动流程。但不同启动模式代码是相互交织的，需要分清楚！&lt;/p&gt;
&lt;p&gt;1） 初始化PLL和DDRC控制器和管脚复用情况。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* init PLL/DDRC/pin mux/... */
    ldr r0, _blank_zone_start
    ldr r1, _TEXT_BASE
    sub r0, r0, r1
    ldr r1, =RAM_START_ADRS
    add r0, r0, r1
    mov r1, #0x0                 /* flags: 0-&amp;gt;normal 1-&amp;gt;pm */
    bl  init_registers           /* init PLL/DDRC/... */&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;bl init_registers&lt;/code&gt;这个函数是初始化一些寄存器，这些寄存器分了很多，包括中断、网络、哈希功能形式的寄存器，初始化的意思就是给一个值，但这值一般没什么意义，具体的寄存器，后面会再进行配置！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2） start_ddr_training&lt;/p&gt;
&lt;p&gt;/* DDR training：DR布线，完全按等长约束就没有ddr training的说法。&lt;br/&gt;当布线去掉等长约束或放宽约束条件，就要做ddr training，以保证时序的完整性，使信号的建立&amp;amp;保持时间窗口一致。ddr training是调整Addr/Cmd信号对CLK，DQ信号对DQS的延时。由于没做等长约束，信号有长，有短，就会导致信号有快，慢之差（信号在1000mil走线耗时约160~180ps，相对FR-4的板材），ddr training就是找到一套参数，使信号的建立与保持时间充足。并保存且写到配置中。*/&lt;/p&gt;
&lt;p&gt;3） pcie_slave_boot&lt;/p&gt;
&lt;h3 id=&quot;jump_to_ddr&quot;&gt;6. jump_to_ddr&lt;/h3&gt;
&lt;p&gt;自举模式省略了一些PCIE判断的情况的解释，我也没怎么看懂&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;jump_to_ddr:
    adr    x0, _start_armboot
    ldr    x30,[x0]
    ret&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开始进入跳转到C语言阶段&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;关cache，关mmu，SVC模式&lt;/li&gt;
&lt;li&gt;检测是不是自举模式还是pcie启动，也包括是冷启动还是热启动&lt;/li&gt;
&lt;li&gt;串口初始化&lt;/li&gt;
&lt;li&gt;DDR初始化和DDR training&lt;/li&gt;
&lt;li&gt;正常启动时，会检测启动方式，对代码进行相应的拷贝，重定位&lt;/li&gt;
&lt;li&gt;设置堆栈&lt;/li&gt;
&lt;li&gt;清bss段&lt;/li&gt;
&lt;li&gt;跳转到第二阶段，即C语言阶段&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 03 Apr 2019 07:41:00 +0000</pubDate>
<dc:creator>yooooooo</dc:creator>
<og:description>第一阶段 start.S 首先我们可以在u boot.lds中看到 ，即指定了入口 ，`_start start.S`的最开始； 1. reset 在 中的 normal_start_flow: /</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linhaostudy/p/10649273.html</dc:identifier>
</item>
<item>
<title>Android音视频之AudioRecord录音(一) - 原心木</title>
<link>http://www.cnblogs.com/sskbskdrin/p/10647975.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sskbskdrin/p/10647975.html</guid>
<description>&lt;p&gt;在音视频开发中，录音当然是必不可少的。首先我们要学会单独的录音功能，当然这里说的录音是指用AudioRecord来录音，读取录音原始数据，读到的就是所谓的PCM数据。对于录音来说，最重要的几个参数要搞明白：&lt;/p&gt;
&lt;p&gt;1、simpleRate采样率，采样率就是采样频率，每秒钟记录多少个样本。&lt;/p&gt;
&lt;p&gt;2、channelConfig通道配置，其实就是所谓的单通道，双通道之类的，AudioFormat.CHANNEL_IN_MONO单通道，AudioFormat.CHANNEL_IN_STEREO双通道，这里只列了这两种，还有其它的，可自行查阅。&lt;/p&gt;
&lt;p&gt;3、audioFormat音频格式，其实就是采样的精度，每个样本的位数，AudioFormat.ENCODING_PCM_8BIT每个样本占8位，AudioFormat.ENCODING_PCM_16BIT每个样本占16位，这里也只用了这两个，别的没研究。&lt;/p&gt;
&lt;p&gt;在学习过程中会用到的一些参数，我这里封装了一个类，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AudioParams {

    &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Format {
        SINGLE_8_BIT, DOUBLE_8_BIT, SINGLE_16_BIT, DOUBLE_16_BIT
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Format format;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; simpleRate;

    AudioParams(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; simpleRate, Format f) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.simpleRate =&lt;span&gt; simpleRate;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.format =&lt;span&gt; f;
    }

    AudioParams(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; simpleRate, &lt;span&gt;int&lt;/span&gt; channelCount, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bits) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.simpleRate =&lt;span&gt; simpleRate;
        set(channelCount, bits);
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getBits() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (format == Format.SINGLE_8_BIT || format == Format.DOUBLE_8_BIT) ? 8 : 16&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getEncodingFormat() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (format == Format.SINGLE_8_BIT || format == Format.DOUBLE_8_BIT) ?&lt;span&gt; AudioFormat.ENCODING_PCM_8BIT :
            AudioFormat.ENCODING_PCM_16BIT;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; getChannelCount() {&lt;span&gt;return&lt;/span&gt; (format == Format.SINGLE_8_BIT || format == Format.SINGLE_16_BIT) ? 1 : 2&lt;span&gt;;}

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getChannelConfig() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (format == Format.SINGLE_8_BIT || format == Format.SINGLE_16_BIT) ?&lt;span&gt; AudioFormat.CHANNEL_IN_MONO :
            AudioFormat.CHANNEL_IN_STEREO;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; getOutChannelConfig() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (format == Format.SINGLE_8_BIT || format == Format.SINGLE_16_BIT) ?&lt;span&gt; AudioFormat.CHANNEL_OUT_MONO :
            AudioFormat.CHANNEL_OUT_STEREO;
    }

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; set(&lt;span&gt;int&lt;/span&gt; channelCount, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bits) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((channelCount != 1 &amp;amp;&amp;amp; channelCount != 2) || (bits != 8 &amp;amp;&amp;amp; bits != 16&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&quot;不支持其它格式 channelCount=$channelCount bits=$bits&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channelCount == 1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bits == 8&lt;span&gt;) {
                format &lt;/span&gt;=&lt;span&gt; Format.SINGLE_8_BIT;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                format &lt;/span&gt;=&lt;span&gt; Format.SINGLE_16_BIT;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bits == 8&lt;span&gt;) {
                format &lt;/span&gt;=&lt;span&gt; Format.DOUBLE_8_BIT;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                format &lt;/span&gt;=&lt;span&gt; Format.DOUBLE_16_BIT;
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里固定使用了单通道8位，双通道8位，单通道16位，双通道16位，所以用了枚举来限制。&lt;/p&gt;
&lt;p&gt;为了方便把录音数据拿出来显示、存储，这里写了一个回调方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RecordCallback {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 数据回调
         *
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bytes 数据
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; len   数据有效长度，-1时表示数据结束
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; onRecord(&lt;span&gt;byte&lt;/span&gt;[] bytes, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了这些参数，现在就可以录音了，先看一下样例&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startRecord(AudioParams params, RecordCallback callback) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; simpleRate =&lt;span&gt; params.simpleRate;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; channelConfig =&lt;span&gt; params.getChannelConfig();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; audioFormat =&lt;span&gt; params.getEncodingFormat();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据AudioRecord提供的api拿到最小缓存大小&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; bufferSize =&lt;span&gt; AudioRecord.getMinBufferSize(simpleRate, channelConfig, audioFormat);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Record对象&lt;/span&gt;
        record = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AudioRecord(MediaRecorder.AudioSource.MIC, simpleRate, channelConfig, audioFormat, bufferSize);
        recordThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[bufferSize];
            record.startRecording();
            recording &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (recording) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; read = record.read(buffer, 0&lt;span&gt;, bufferSize);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将数据回调到外部&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (read &amp;gt; 0 &amp;amp;&amp;amp; callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    callback.onRecord(buffer, read);
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; len 为-1时表示结束&lt;/span&gt;
                callback.onRecord(buffer, -1&lt;span&gt;);
                recording &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放资源&lt;/span&gt;
&lt;span&gt;            release();
        });
        recordThread.start();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法就是简单的采集音频数据，这个数据就是最原始的pcm数据。&lt;/p&gt;
&lt;p&gt;拿到pcm数据以后，如果直接保存到文件是无法直接播放的，因为这只是一堆数据，没有任何格式说明，如果想让普通播放器可以播放，需要在文件中加入文件头，来告诉播放器这个数据的格式，这里是直接保存成wav格式的数据。下面就是加入wav格式文件头的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getWaveFileHeader(&lt;span&gt;int&lt;/span&gt; totalDataLen, &lt;span&gt;int&lt;/span&gt; sampleRate, &lt;span&gt;int&lt;/span&gt; channelCount, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bits) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] header = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[44&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RIFF/WAVE header&lt;/span&gt;
        header[0] = 'R'&lt;span&gt;;
        header[&lt;/span&gt;1] = 'I'&lt;span&gt;;
        header[&lt;/span&gt;2] = 'F'&lt;span&gt;;
        header[&lt;/span&gt;3] = 'F'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fileLength = totalDataLen + 36&lt;span&gt;;
        header[&lt;/span&gt;4] = (&lt;span&gt;byte&lt;/span&gt;) (fileLength &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;5] = (&lt;span&gt;byte&lt;/span&gt;) (fileLength &amp;gt;&amp;gt; 8 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;6] = (&lt;span&gt;byte&lt;/span&gt;) (fileLength &amp;gt;&amp;gt; 16 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;7] = (&lt;span&gt;byte&lt;/span&gt;) (fileLength &amp;gt;&amp;gt; 24 &amp;amp; 0xff&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WAVE&lt;/span&gt;
        header[8] = 'W'&lt;span&gt;;
        header[&lt;/span&gt;9] = 'A'&lt;span&gt;;
        header[&lt;/span&gt;10] = 'V'&lt;span&gt;;
        header[&lt;/span&gt;11] = 'E'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'fmt ' chunk&lt;/span&gt;
        header[12] = 'f'&lt;span&gt;;
        header[&lt;/span&gt;13] = 'm'&lt;span&gt;;
        header[&lt;/span&gt;14] = 't'&lt;span&gt;;
        header[&lt;/span&gt;15] = ' '&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4 bytes: size of 'fmt ' chunk&lt;/span&gt;
        header[16] = 16&lt;span&gt;;
        header[&lt;/span&gt;17] = 0&lt;span&gt;;
        header[&lt;/span&gt;18] = 0&lt;span&gt;;
        header[&lt;/span&gt;19] = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pcm format = 1&lt;/span&gt;
        header[20] = 1&lt;span&gt;;
        header[&lt;/span&gt;21] = 0&lt;span&gt;;
        header[&lt;/span&gt;22] = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) channelCount;
        header[&lt;/span&gt;23] = 0&lt;span&gt;;

        header[&lt;/span&gt;24] = (&lt;span&gt;byte&lt;/span&gt;) (sampleRate &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;25] = (&lt;span&gt;byte&lt;/span&gt;) (sampleRate &amp;gt;&amp;gt; 8 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;26] = (&lt;span&gt;byte&lt;/span&gt;) (sampleRate &amp;gt;&amp;gt; 16 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;27] = (&lt;span&gt;byte&lt;/span&gt;) (sampleRate &amp;gt;&amp;gt; 24 &amp;amp; 0xff&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; byteRate = sampleRate * bits * channelCount / 8&lt;span&gt;;
        header[&lt;/span&gt;28] = (&lt;span&gt;byte&lt;/span&gt;) (byteRate &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;29] = (&lt;span&gt;byte&lt;/span&gt;) (byteRate &amp;gt;&amp;gt; 8 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;30] = (&lt;span&gt;byte&lt;/span&gt;) (byteRate &amp;gt;&amp;gt; 16 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;31] = (&lt;span&gt;byte&lt;/span&gt;) (byteRate &amp;gt;&amp;gt; 24 &amp;amp; 0xff&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; block align&lt;/span&gt;
        header[32] = (&lt;span&gt;byte&lt;/span&gt;) (channelCount * bits / 8&lt;span&gt;);
        header[&lt;/span&gt;33] = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bits per sample&lt;/span&gt;
        header[34] = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) bits;
        header[&lt;/span&gt;35] = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;
        header[36] = 'd'&lt;span&gt;;
        header[&lt;/span&gt;37] = 'a'&lt;span&gt;;
        header[&lt;/span&gt;38] = 't'&lt;span&gt;;
        header[&lt;/span&gt;39] = 'a'&lt;span&gt;;
        header[&lt;/span&gt;40] = (&lt;span&gt;byte&lt;/span&gt;) (totalDataLen &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;41] = (&lt;span&gt;byte&lt;/span&gt;) (totalDataLen &amp;gt;&amp;gt; 8 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;42] = (&lt;span&gt;byte&lt;/span&gt;) (totalDataLen &amp;gt;&amp;gt; 16 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;43] = (&lt;span&gt;byte&lt;/span&gt;) (totalDataLen &amp;gt;&amp;gt; 24 &amp;amp; 0xff&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; header;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;根据几个参数设置一下文件头，然后直接写入录音采集到的pcm数据，就可被正常播放了。wav文件头格式定义，可&lt;a href=&quot;https://www.cnblogs.com/sskbskdrin/p/10648585.html&quot; target=&quot;_blank&quot;&gt;点击这里&lt;/a&gt;查看或自行百度。&lt;/p&gt;
&lt;p&gt;如果想要通过AudioRecord录音直接保存到文件，可参考下面方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startRecord(String filePath, AudioParams params, RecordCallback callback) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; channelCount =&lt;span&gt; params.getChannelCount();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bits =&lt;span&gt; params.getBits();

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; storeFile = filePath != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;filePath.isEmpty();

        startRecord(params, (bytes, len) &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (storeFile) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (file == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    File f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(filePath);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (f.exists()) {
                        f.delete();
                    }
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RandomAccessFile(f, &quot;rw&quot;&lt;span&gt;);
                        file.write(getWaveFileHeader(&lt;/span&gt;0&lt;span&gt;, params.simpleRate, channelCount, bits));
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len &amp;gt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        file.write(bytes, &lt;/span&gt;0&lt;span&gt;, len);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为在前面已经写入头信息，所以这里要减去头信息才是数据的长度&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt; length = (&lt;span&gt;int&lt;/span&gt;) file.length() - 44&lt;span&gt;;
                        file.seek(&lt;/span&gt;0&lt;span&gt;);
                        file.write(getWaveFileHeader(length, params.simpleRate, channelCount, bits));
                        file.close();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                callback.onRecord(bytes, len);
            }
        });
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;先通过RandomAccessFile创建文件，先写入文件头，由于暂时我们不知道会录多长，有多少pcm数据，长度先用0表示，等录音结束后，通过seek(int)方法重新写入文件头信息，也可以先把pcm数据保存到临时文件，然后再写入到一个新的文件中，这里就不举例说明了。&lt;/p&gt;
&lt;p&gt;最后放入完整类的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('a837297c-1956-4bf6-805c-9993b9032fb9')&quot; readability=&quot;49.5&quot;&gt;&lt;img id=&quot;code_img_closed_a837297c-1956-4bf6-805c-9993b9032fb9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a837297c-1956-4bf6-805c-9993b9032fb9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('a837297c-1956-4bf6-805c-9993b9032fb9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a837297c-1956-4bf6-805c-9993b9032fb9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.sskbskdrin.record.audio;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.media.AudioRecord;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.media.MediaRecorder;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.File;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.RandomAccessFile;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; sskbskdrin
 * @date 2019/April/3
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AudioRecordManager {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; AudioParams DEFAULT_FORMAT = &lt;span&gt;new&lt;/span&gt; AudioParams(8000, 1, 16&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; AudioRecord record;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Thread recordThread;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; recording = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; RandomAccessFile file;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startRecord(String filePath, RecordCallback callback) {
        startRecord(filePath, DEFAULT_FORMAT, callback);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startRecord(String filePath, AudioParams params, RecordCallback callback) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; channelCount =&lt;span&gt; params.getChannelCount();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; bits =&lt;span&gt; params.getBits();

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; storeFile = filePath != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;filePath.isEmpty();

        startRecord(params, (bytes, len) &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (storeFile) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (file == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    File f &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(filePath);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (f.exists()) {
                        f.delete();
                    }
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; RandomAccessFile(f, &quot;rw&quot;&lt;span&gt;);
                        file.write(getWaveFileHeader(&lt;/span&gt;0&lt;span&gt;, params.simpleRate, channelCount, bits));
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                    }
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (len &amp;gt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        file.write(bytes, &lt;/span&gt;0&lt;span&gt;, len);
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为在前面已经写入头信息，所以这里要减去头信息才是数据的长度&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt; length = (&lt;span&gt;int&lt;/span&gt;) file.length() - 44&lt;span&gt;;
                        file.seek(&lt;/span&gt;0&lt;span&gt;);
                        file.write(getWaveFileHeader(length, params.simpleRate, channelCount, bits));
                        file.close();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                callback.onRecord(bytes, len);
            }
        });
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startRecord(AudioParams params, RecordCallback callback) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; simpleRate =&lt;span&gt; params.simpleRate;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; channelConfig =&lt;span&gt; params.getChannelConfig();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; audioFormat =&lt;span&gt; params.getEncodingFormat();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据AudioRecord提供的api拿到最小缓存大小&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; bufferSize =&lt;span&gt; AudioRecord.getMinBufferSize(simpleRate, channelConfig, audioFormat);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建Record对象&lt;/span&gt;
        record = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AudioRecord(MediaRecorder.AudioSource.MIC, simpleRate, channelConfig, audioFormat, bufferSize);
        recordThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[bufferSize];
            record.startRecording();
            recording &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (recording) {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; read = record.read(buffer, 0&lt;span&gt;, bufferSize);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将数据回调到外部&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (read &amp;gt; 0 &amp;amp;&amp;amp; callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    callback.onRecord(buffer, read);
                }
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (callback != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; len 为-1时表示结束&lt;/span&gt;
                callback.onRecord(buffer, -1&lt;span&gt;);
                recording &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;释放资源&lt;/span&gt;
&lt;span&gt;            release();
        });
        recordThread.start();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stop() {
        recording &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; release() {
        recording &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (record != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            record.stop();
            record.release();
        }
        record &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        file &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        recordThread &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] getWaveFileHeader(&lt;span&gt;int&lt;/span&gt; totalDataLen, &lt;span&gt;int&lt;/span&gt; sampleRate, &lt;span&gt;int&lt;/span&gt; channelCount, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; bits) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] header = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[44&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; RIFF/WAVE header&lt;/span&gt;
        header[0] = 'R'&lt;span&gt;;
        header[&lt;/span&gt;1] = 'I'&lt;span&gt;;
        header[&lt;/span&gt;2] = 'F'&lt;span&gt;;
        header[&lt;/span&gt;3] = 'F'&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; fileLength = totalDataLen + 36&lt;span&gt;;
        header[&lt;/span&gt;4] = (&lt;span&gt;byte&lt;/span&gt;) (fileLength &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;5] = (&lt;span&gt;byte&lt;/span&gt;) (fileLength &amp;gt;&amp;gt; 8 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;6] = (&lt;span&gt;byte&lt;/span&gt;) (fileLength &amp;gt;&amp;gt; 16 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;7] = (&lt;span&gt;byte&lt;/span&gt;) (fileLength &amp;gt;&amp;gt; 24 &amp;amp; 0xff&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WAVE&lt;/span&gt;
        header[8] = 'W'&lt;span&gt;;
        header[&lt;/span&gt;9] = 'A'&lt;span&gt;;
        header[&lt;/span&gt;10] = 'V'&lt;span&gt;;
        header[&lt;/span&gt;11] = 'E'&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 'fmt ' chunk&lt;/span&gt;
        header[12] = 'f'&lt;span&gt;;
        header[&lt;/span&gt;13] = 'm'&lt;span&gt;;
        header[&lt;/span&gt;14] = 't'&lt;span&gt;;
        header[&lt;/span&gt;15] = ' '&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4 bytes: size of 'fmt ' chunk&lt;/span&gt;
        header[16] = 16&lt;span&gt;;
        header[&lt;/span&gt;17] = 0&lt;span&gt;;
        header[&lt;/span&gt;18] = 0&lt;span&gt;;
        header[&lt;/span&gt;19] = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; pcm format = 1&lt;/span&gt;
        header[20] = 1&lt;span&gt;;
        header[&lt;/span&gt;21] = 0&lt;span&gt;;
        header[&lt;/span&gt;22] = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) channelCount;
        header[&lt;/span&gt;23] = 0&lt;span&gt;;

        header[&lt;/span&gt;24] = (&lt;span&gt;byte&lt;/span&gt;) (sampleRate &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;25] = (&lt;span&gt;byte&lt;/span&gt;) (sampleRate &amp;gt;&amp;gt; 8 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;26] = (&lt;span&gt;byte&lt;/span&gt;) (sampleRate &amp;gt;&amp;gt; 16 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;27] = (&lt;span&gt;byte&lt;/span&gt;) (sampleRate &amp;gt;&amp;gt; 24 &amp;amp; 0xff&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; byteRate = sampleRate * bits * channelCount / 8&lt;span&gt;;
        header[&lt;/span&gt;28] = (&lt;span&gt;byte&lt;/span&gt;) (byteRate &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;29] = (&lt;span&gt;byte&lt;/span&gt;) (byteRate &amp;gt;&amp;gt; 8 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;30] = (&lt;span&gt;byte&lt;/span&gt;) (byteRate &amp;gt;&amp;gt; 16 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;31] = (&lt;span&gt;byte&lt;/span&gt;) (byteRate &amp;gt;&amp;gt; 24 &amp;amp; 0xff&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; block align&lt;/span&gt;
        header[32] = (&lt;span&gt;byte&lt;/span&gt;) (channelCount * bits / 8&lt;span&gt;);
        header[&lt;/span&gt;33] = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; bits per sample&lt;/span&gt;
        header[34] = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) bits;
        header[&lt;/span&gt;35] = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;
        header[36] = 'd'&lt;span&gt;;
        header[&lt;/span&gt;37] = 'a'&lt;span&gt;;
        header[&lt;/span&gt;38] = 't'&lt;span&gt;;
        header[&lt;/span&gt;39] = 'a'&lt;span&gt;;
        header[&lt;/span&gt;40] = (&lt;span&gt;byte&lt;/span&gt;) (totalDataLen &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;41] = (&lt;span&gt;byte&lt;/span&gt;) (totalDataLen &amp;gt;&amp;gt; 8 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;42] = (&lt;span&gt;byte&lt;/span&gt;) (totalDataLen &amp;gt;&amp;gt; 16 &amp;amp; 0xff&lt;span&gt;);
        header[&lt;/span&gt;43] = (&lt;span&gt;byte&lt;/span&gt;) (totalDataLen &amp;gt;&amp;gt; 24 &amp;amp; 0xff&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; header;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; RecordCallback {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 数据回调
         *
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; bytes 数据
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; len   数据有效长度，-1时表示数据结束
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;void&lt;/span&gt; onRecord(&lt;span&gt;byte&lt;/span&gt;[] bytes, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;如有不对之处还请评论指正&lt;/p&gt;
</description>
<pubDate>Wed, 03 Apr 2019 07:34:00 +0000</pubDate>
<dc:creator>原心木</dc:creator>
<og:description>在音视频开发中，录音当然是必不可少的。首先我们要学会单独的录音功能，当然这里说的录音是指用AudioRecord来录音，读取录音原始数据，读到的就是所谓的PCM数据。对于录音来说，最重要的几个参数要搞</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sskbskdrin/p/10647975.html</dc:identifier>
</item>
<item>
<title>gitbook 入门教程之使用 gitbook-cli 开发电子书 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10649210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10649210.html</guid>
<description>&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 生成电子书主要有三种方式:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;gitbook-cli&lt;/code&gt; 命令行操作,简洁高效,适合从事软件开发的相关人员.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gitbook-editor&lt;/code&gt; 编辑器操作,可视化编辑,适合无编程经验的文学创作者.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gitbook.com&lt;/code&gt; 官网操作,在线编辑实时发布,适合无本地环境且科学上网的体验者.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文主要讲解第一种 &lt;code&gt;gitbook-cli&lt;/code&gt; 命令行操作流程,其他两种见另外两篇教程.&lt;/p&gt;
&lt;h2 id=&quot;gitbook-的一些常用命令&quot;&gt;&lt;code&gt;gitbook&lt;/code&gt; 的一些常用命令&lt;/h2&gt;
&lt;h3 id=&quot;安装-gitbook-cli-脚手架工具&quot;&gt;安装 &lt;code&gt;gitbook-cli&lt;/code&gt; 脚手架工具&lt;/h3&gt;
&lt;p&gt;本机已安装 &lt;code&gt;node.js&lt;/code&gt; 开发环境,安装完成后运行 &lt;code&gt;gitbook -V&lt;/code&gt; 能够打印出版本信息,则表示安装成功.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ sudo npm install -g gitbook-cli&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.8461538461538&quot;&gt;
&lt;p&gt;关于安装配置相关问题请参考 &lt;a href=&quot;https://snowdreams1006.github.io/myGitbook/preparation/environmental-requirements.html&quot;&gt;环境要求&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;初始化-gitbook-项目&quot;&gt;初始化 &lt;code&gt;gitbook&lt;/code&gt; 项目&lt;/h3&gt;
&lt;p&gt;初始化项目,按照 &lt;code&gt;gitbook&lt;/code&gt; 规范会自动创建 &lt;code&gt;README.md&lt;/code&gt; 和 &lt;code&gt;SUMMARY.md&lt;/code&gt; 两个文件,具体用途见下文.&lt;/p&gt;
&lt;p&gt;其实 &lt;code&gt;SUMMARY.md&lt;/code&gt; 是电子书的章节目录,&lt;code&gt;gitbook&lt;/code&gt; 会初始化相应的文件目录结构,所以主要是用于&lt;strong&gt;开发初始阶段&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gitbook init&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动-gitbook-项目&quot;&gt;启动 &lt;code&gt;gitbook&lt;/code&gt; 项目&lt;/h3&gt;
&lt;p&gt;启动本地服务,程序无报错则可以在浏览器预览电子书效果: &lt;a href=&quot;http://localhost:4000&quot; class=&quot;uri&quot;&gt;http://localhost:4000&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于能够实时预览电子书效果,并且大多数开发环境搭建在本地而不是远程服务器中,所以主要用于&lt;strong&gt;开发调试阶段&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gitbook serve&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构建-gitbook-静态网页&quot;&gt;构建 &lt;code&gt;gitbook&lt;/code&gt; 静态网页&lt;/h3&gt;
&lt;p&gt;构建静态网页而不启动本地服务器,默认生成文件存放在 &lt;code&gt;_book/&lt;/code&gt; 目录,当然输出目录是可配置的,暂不涉及,见高级部分.&lt;/p&gt;
&lt;p&gt;输出静态网页后可打包上传到服务器,也可以上传到 &lt;code&gt;github&lt;/code&gt; 等网站进行托管,因而主要用于&lt;strong&gt;发布准备阶段&lt;/strong&gt;.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ gitbook build&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;章节小结&quot;&gt;章节小结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;gitbook init&lt;/code&gt; 初始化 &lt;code&gt;README.md&lt;/code&gt; 和 &lt;code&gt;SUMMARY.md&lt;/code&gt; 两个文件.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gitbook build&lt;/code&gt; 本地构建但不运行服务,默认输出到 &lt;code&gt;_book/&lt;/code&gt; 目录.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gitbook serve&lt;/code&gt; 本地构建并运行服务,默认访问 &lt;code&gt;http://localhost:4000&lt;/code&gt; 实时预览.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# 创建 `gitbook` 演示项目
$ mkdir gitbook-demo

# 初始化项目
$ gitbook init
warn: no summary file in this book 
info: create README.md 
info: create SUMMARY.md 
info: initialization is finished 

# 启动本地服务器
$ gitbook serve
Live reload server started on port: 35729
Press CTRL+C to quit ...

info: 7 plugins are installed 
info: loading plugin &quot;livereload&quot;... OK 
info: loading plugin &quot;highlight&quot;... OK 
info: loading plugin &quot;search&quot;... OK 
info: loading plugin &quot;lunr&quot;... OK 
info: loading plugin &quot;sharing&quot;... OK 
info: loading plugin &quot;fontsettings&quot;... OK 
info: loading plugin &quot;theme-default&quot;... OK 
info: found 1 pages 
info: found 0 asset files 
info: &amp;gt;&amp;gt; generation finished with success in 1.2s ! 

Starting server ...
Serving book on http://localhost:4000

# 查看当前目录结构
$ tree
.
├── README.md
├── SUMMARY.md
└── _book
    ├── gitbook
    │   ├── fonts
    │   │   └── fontawesome
    │   │       ├── FontAwesome.otf
    │   │       ├── fontawesome-webfont.eot
    │   │       ├── fontawesome-webfont.svg
    │   │       ├── fontawesome-webfont.ttf
    │   │       ├── fontawesome-webfont.woff
    │   │       └── fontawesome-webfont.woff2
    │   ├── gitbook-plugin-fontsettings
    │   │   ├── fontsettings.js
    │   │   └── website.css
    │   ├── gitbook-plugin-highlight
    │   │   ├── ebook.css
    │   │   └── website.css
    │   ├── gitbook-plugin-livereload
    │   │   └── plugin.js
    │   ├── gitbook-plugin-lunr
    │   │   ├── lunr.min.js
    │   │   └── search-lunr.js
    │   ├── gitbook-plugin-search
    │   │   ├── lunr.min.js
    │   │   ├── search-engine.js
    │   │   ├── search.css
    │   │   └── search.js
    │   ├── gitbook-plugin-sharing
    │   │   └── buttons.js
    │   ├── gitbook.js
    │   ├── images
    │   │   ├── apple-touch-icon-precomposed-152.png
    │   │   └── favicon.ico
    │   ├── style.css
    │   └── theme.js
    ├── index.html
    └── search_index.json

11 directories, 27 files
$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-68c5858b7dfbb984.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;gitbook-serve.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;gitbook-的目录结构说明&quot;&gt;&lt;code&gt;gitbook&lt;/code&gt; 的目录结构说明&lt;/h2&gt;
&lt;p&gt;既然要书写一本电子书,那么起码的章节介绍和章节详情自然是必不可少的.&lt;/p&gt;
&lt;p&gt;当然还有标题,作者和联系方式等个性化信息需要指定,如果不指定的话,一旦采用默认配合,八成不符合我们的预期,说不定都会变成匿名电子书?所以配置文件一般也是需要手动设置的!&lt;/p&gt;
&lt;p&gt;真正可选的文件要数词汇表了,毕竟不是每一本电子书都有专业词汇需要去解释说明.如果在章节详情顺便解释下涉及到的专业词汇,那么自然也就不需要词汇表文件了.&lt;/p&gt;
&lt;p&gt;简单解释下各个文件的作用:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;README.md&lt;/code&gt; 是默认首页文件,相当于网站的首页 &lt;code&gt;index.html&lt;/code&gt; ,一般是介绍文字或相关导航链接.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUMMARY.md&lt;/code&gt; 是默认概括文件,主要是根据该文件内容生成相应的目录结构,同 &lt;code&gt;README.md&lt;/code&gt; 一样都是被&lt;code&gt;gitbook init&lt;/code&gt; 初始化默认创建的重要文件.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_book&lt;/code&gt; 是默认的输出目录,存放着原始 &lt;code&gt;markdown&lt;/code&gt; 渲染完毕后的 &lt;code&gt;html&lt;/code&gt; 文件,可以直接打包到服务器充当&lt;strong&gt;静态网站&lt;/strong&gt;使用.一般是执行 &lt;code&gt;gitbook build&lt;/code&gt; 或 &lt;code&gt;gitbook serve&lt;/code&gt; &lt;strong&gt;自动生成&lt;/strong&gt;的.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;book.json&lt;/code&gt; 是配置文件,用于个性化调整 &lt;code&gt;gitbook&lt;/code&gt; 的相关配置,如定义电子书的标题,封面,作者等信息.虽然是手动创建但一般是必选的.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GLOSSARY.md&lt;/code&gt; 是默认的词汇表,主要说明专业词汇的详细解释,这样阅读到专业词汇时就会有相应提示信息,也是手动创建但是可选的.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LANGS.md&lt;/code&gt; 是默认的语言文件,用于国际化版本翻译,和 &lt;code&gt;GLOSSARY.md&lt;/code&gt; 一样是手动创建但是可选的.&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;readme.md-首页文件必须&quot;&gt;&lt;code&gt;README.md&lt;/code&gt; 首页文件[必须]&lt;/h3&gt;
&lt;p&gt;编辑 &lt;code&gt;README.md&lt;/code&gt; 文件,随便写点内容并启动本地服务(&lt;code&gt;gitbook serve&lt;/code&gt;)实时预览效果.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-1ac5eb0b72916526.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-experience-cli-readme.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;summary.md-概括文件必须&quot;&gt;&lt;code&gt;SUMMARY.md&lt;/code&gt; 概括文件[必须]&lt;/h3&gt;
&lt;p&gt;先停止本地服务,编辑章节目录结构,然后重新再初始化(&lt;code&gt;gitbook init&lt;/code&gt;)自动创建相应目录.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-27537a1940953437.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;gitbook-experience-cli-summary.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;book-输出目录可选&quot;&gt;&lt;code&gt;_book&lt;/code&gt; 输出目录[可选]&lt;/h3&gt;
&lt;p&gt;执行 &lt;code&gt;gitbook build&lt;/code&gt; 或 &lt;code&gt;gitbook serve&lt;/code&gt; 命令后会自动生成静态网页.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 构建电子书
$ gitbook build
info: 7 plugins are installed 
info: 6 explicitly listed 
info: loading plugin &quot;highlight&quot;... OK 
info: loading plugin &quot;search&quot;... OK 
info: loading plugin &quot;lunr&quot;... OK 
info: loading plugin &quot;sharing&quot;... OK 
info: loading plugin &quot;fontsettings&quot;... OK 
info: loading plugin &quot;theme-default&quot;... OK 
info: found 5 pages 
info: found 0 asset files 
info: &amp;gt;&amp;gt; generation finished with success in 0.7s ! 

# 查看输出目录
$ tree _book/
_book/
├── first
│   ├── 01.html
│   └── 02.html
├── first.html
├── gitbook
│   ├── fonts
│   │   └── fontawesome
│   │       ├── FontAwesome.otf
│   │       ├── fontawesome-webfont.eot
│   │       ├── fontawesome-webfont.svg
│   │       ├── fontawesome-webfont.ttf
│   │       ├── fontawesome-webfont.woff
│   │       └── fontawesome-webfont.woff2
│   ├── gitbook-plugin-fontsettings
│   │   ├── fontsettings.js
│   │   └── website.css
│   ├── gitbook-plugin-highlight
│   │   ├── ebook.css
│   │   └── website.css
│   ├── gitbook-plugin-lunr
│   │   ├── lunr.min.js
│   │   └── search-lunr.js
│   ├── gitbook-plugin-search
│   │   ├── lunr.min.js
│   │   ├── search-engine.js
│   │   ├── search.css
│   │   └── search.js
│   ├── gitbook-plugin-sharing
│   │   └── buttons.js
│   ├── gitbook.js
│   ├── images
│   │   ├── apple-touch-icon-precomposed-152.png
│   │   └── favicon.ico
│   ├── style.css
│   └── theme.js
├── index.html
├── search_index.json
└── second.html

10 directories, 28 files
$ &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;book.json-配置文件可选&quot;&gt;&lt;code&gt;book.json&lt;/code&gt; 配置文件[可选]&lt;/h3&gt;
&lt;p&gt;在根目录下新建 &lt;code&gt;book.json&lt;/code&gt; 配置文件,完整的支持项请参考&lt;a href=&quot;https://toolchain.gitbook.com/config.html&quot;&gt;官方文档&lt;/a&gt;,下面仅列举常用的一些配置项.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-1b64c68c3a742407.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-experience-cli-book-config.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;title-标题&quot;&gt;&lt;code&gt;title&lt;/code&gt; 标题&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;书籍的标题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;title&quot;: &quot;雪之梦技术驿站&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;author-作者&quot;&gt;&lt;code&gt;author&lt;/code&gt; 作者&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;书籍的作者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;author&quot;: &quot;snowdreams1006&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;description-描述&quot;&gt;&lt;code&gt;description&lt;/code&gt; 描述&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;书籍的简要描述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &quot;description&quot;: &quot;雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;isbn-国际标准书号&quot;&gt;&lt;code&gt;isbn&lt;/code&gt; 国际标准书号&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;书籍的国际标准书号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &quot;isbn&quot;: &quot;978-0-13-601970-1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;3.6428571428571&quot;&gt;
&lt;p&gt;选填,请参考 &lt;a href=&quot;https://isbnsearch.org/&quot;&gt;ISBN Search&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;language-语言&quot;&gt;&lt;code&gt;language&lt;/code&gt; 语言&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;支持语言项: 默认英语(&lt;code&gt;en&lt;/code&gt;),设置成简体中文(&lt;code&gt;zh-hans&lt;/code&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;language&quot;: &quot;zh-hans&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;direction-阅读顺序&quot;&gt;&lt;code&gt;direction&lt;/code&gt; 阅读顺序&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;阅读顺序,支持从右到左(&lt;code&gt;rtl&lt;/code&gt;)或从左到右(&lt;code&gt;ltr&lt;/code&gt;),默认值取决于语言值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;direction&quot; : &quot;ltr&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;gitbook-版本&quot;&gt;&lt;code&gt;gitbook&lt;/code&gt; 版本&lt;/h4&gt;
&lt;blockquote readability=&quot;5.88&quot;&gt;
&lt;p&gt;指定 &lt;code&gt;gitbook&lt;/code&gt; 版本,支持&lt;a href=&quot;http://semver.org/&quot;&gt;SemVer规范&lt;/a&gt;,接受类似于 &lt;code&gt;&amp;gt;=3.2.3&lt;/code&gt; 的条件.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;gitbook&quot;: &quot;3.2.3&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;root-根目录&quot;&gt;&lt;code&gt;root&lt;/code&gt; 根目录&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;指定存放 &lt;code&gt;gitbook&lt;/code&gt; 文件(除了&lt;code&gt;book.json&lt;/code&gt;文件本身)的根目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;root&quot;: &quot;.&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;links-侧边栏链接&quot;&gt;&lt;code&gt;links&lt;/code&gt; 侧边栏链接&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;左侧导航栏添加链接,支持外链&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;links&quot;: {
    &quot;sidebar&quot;: {
        &quot;我的网站&quot;: &quot;https://snowdreams1006.cn/&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;styles-自定义样式&quot;&gt;&lt;code&gt;styles&lt;/code&gt; 自定义样式&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;自定义全局样式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;styles&quot;: {
    &quot;website&quot;: &quot;styles/website.css&quot;,
    &quot;ebook&quot;: &quot;styles/ebook.css&quot;,
    &quot;pdf&quot;: &quot;styles/pdf.css&quot;,
    &quot;mobi&quot;: &quot;styles/mobi.css&quot;,
    &quot;epub&quot;: &quot;styles/epub.css&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;plugins-插件&quot;&gt;&lt;code&gt;plugins&lt;/code&gt; 插件&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;配置额外的插件列表,添加新插件项后需要运行 &lt;code&gt;gitbook install&lt;/code&gt; 安装到当前项目.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;gitbook&lt;/code&gt; 默认自带5个插件,分别是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;highlight&lt;/code&gt; 语法高亮插件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;search&lt;/code&gt; 搜索插件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sharing&lt;/code&gt; 分享插件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;font-settings&lt;/code&gt; 字体设置插件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;livereload&lt;/code&gt; 热加载插件&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;4.7294117647059&quot;&gt;
&lt;p&gt;后续会介绍一些常用插件,如需获取更多插件请访问&lt;a href=&quot;https://plugins.gitbook.com/&quot;&gt;官网插件市场&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;plugins&quot;: [
    &quot;github&quot;,
    &quot;pageview-count&quot;,
    &quot;mermaid-gb3&quot;,
    &quot;-lunr&quot;, 
    &quot;-search&quot;, 
    &quot;search-plus&quot;,
    &quot;splitter&quot;,
    &quot;-sharing&quot;, 
    &quot;sharing-plus&quot;,
    &quot;expandable-chapters-small&quot;,
    &quot;anchor-navigation-ex&quot;,
    &quot;edit-link&quot;,
    &quot;copy-code-button&quot;,
    &quot;chart&quot;,
    &quot;favicon-plus&quot;,
    &quot;donate&quot;
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;pluginsconfig-插件配置&quot;&gt;&lt;code&gt;pluginsConfig&lt;/code&gt; 插件配置&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;安装插件的相应配置项,具体有哪些配置项是由插件本身提供的,应访问插件官网进行查询.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&quot;pluginsConfig&quot;: {
    &quot;github&quot;: {
      &quot;url&quot;: &quot;https://github.com/snowdreams1006/snowdreams1006.github.io&quot;
    },
    &quot;sharing&quot;: {
       &quot;douban&quot;: true,
       &quot;facebook&quot;: false,
       &quot;google&quot;: false,
       &quot;hatenaBookmark&quot;: false,
       &quot;instapaper&quot;: false,
       &quot;line&quot;: false,
       &quot;linkedin&quot;: false,
       &quot;messenger&quot;: false,
       &quot;pocket&quot;: false,
       &quot;qq&quot;: true,
       &quot;qzone&quot;: true,
       &quot;stumbleupon&quot;: false,
       &quot;twitter&quot;: false,
       &quot;viber&quot;: false,
       &quot;vk&quot;: false,
       &quot;weibo&quot;: true,
       &quot;whatsapp&quot;: false,
       &quot;all&quot;: [
           &quot;facebook&quot;, &quot;google&quot;, &quot;twitter&quot;,
           &quot;weibo&quot;, &quot;instapaper&quot;, &quot;linkedin&quot;,
           &quot;pocket&quot;, &quot;stumbleupon&quot;
       ]
   },
   &quot;edit-link&quot;: {
      &quot;base&quot;: &quot;https://github.com/snowdreams1006/snowdreams1006.github.io/blob/master&quot;,
      &quot;label&quot;: &quot;编辑本页&quot;
    },
    &quot;chart&quot;: {
      &quot;type&quot;: &quot;c3&quot;
    },
    &quot;favicon&quot;: &quot;/images/favicon.ico&quot;,
    &quot;appleTouchIconPrecomposed152&quot;: &quot;/images/apple-touch-icon-precomposed-152.png&quot;,
    &quot;output&quot;: &quot;_book&quot;,
    &quot;donate&quot;: {
      &quot;wechat&quot;: &quot;/images/wechat.jpg&quot;,
      &quot;alipay&quot;: &quot;/images/alipay.jpg&quot;,
      &quot;title&quot;: &quot;赏&quot;,
      &quot;button&quot;: &quot;捐赠&quot;,
      &quot;alipayText&quot;: &quot;支付宝&quot;,
      &quot;wechatText&quot;: &quot;微信&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;structure-目录结构配置&quot;&gt;&lt;code&gt;structure&lt;/code&gt; 目录结构配置&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;指定&lt;code&gt;README.md&lt;/code&gt;,&lt;code&gt;SUMMARY.md&lt;/code&gt;,&lt;code&gt;GLOSSARY.md&lt;/code&gt; 和 &lt;code&gt;LANGS.md&lt;/code&gt; &lt;strong&gt;文件名称&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;structure.readme&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;readme&lt;/code&gt; 文件名(默认值是 &lt;code&gt;README.md&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;structure.summary&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;summary&lt;/code&gt; 文件名(默认值是 &lt;code&gt;SUMMARY.md&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;structure.glossary&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;glossary&lt;/code&gt; 文件名(默认值是 &lt;code&gt;GLOSSARY.md&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;structure.languages&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;languages&lt;/code&gt; 文件名(默认值是 &lt;code&gt;LANGS.md&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;pdf-配置&quot;&gt;&lt;code&gt;pdf&lt;/code&gt; 配置&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;定制 &lt;code&gt;pdf&lt;/code&gt; 输出格式,可能需要安装 &lt;code&gt;ebook-convert&lt;/code&gt; 等相关插件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;16&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;pdf.pageNumbers&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;添加页码(默认值是 &lt;code&gt;true&lt;/code&gt; )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;pdf.fontSize&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字体大小(默认值是 &lt;code&gt;12&lt;/code&gt; )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;pdf.fontFamily&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字体集(默认值是 &lt;code&gt;Arial&lt;/code&gt; )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;18&quot;&gt;&lt;td&gt;&lt;code&gt;pdf.paperSize&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;页面尺寸(默认值是 &lt;code&gt;a4&lt;/code&gt; ),支持&lt;code&gt;a0&lt;/code&gt;,&lt;code&gt;a1&lt;/code&gt;,&lt;code&gt;a2&lt;/code&gt;,&lt;code&gt;a3&lt;/code&gt;,&lt;code&gt;a4&lt;/code&gt;,&lt;code&gt;a5&lt;/code&gt;,&lt;code&gt;a6&lt;/code&gt;,&lt;code&gt;b0&lt;/code&gt;,&lt;code&gt;b1&lt;/code&gt;,&lt;code&gt;b2&lt;/code&gt;,&lt;code&gt;b3&lt;/code&gt;,&lt;code&gt;b4&lt;/code&gt;,&lt;code&gt;b5&lt;/code&gt;,&lt;code&gt;b6&lt;/code&gt;,&lt;code&gt;legal&lt;/code&gt;,&lt;code&gt;letter&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;pdf.margin.top&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上边界(默认值是 &lt;code&gt;56&lt;/code&gt; )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;pdf.margin.bottom&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下边界(默认值是 &lt;code&gt;56&lt;/code&gt; )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;pdf.margin.left&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;左边界(默认值是 &lt;code&gt;62&lt;/code&gt; )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;pdf.margin.right&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;右边界(默认值是 &lt;code&gt;62&lt;/code&gt; )&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;电子书封面照片 &lt;code&gt;cover.jpg&lt;/code&gt; 和 &lt;code&gt;cover_small.jpg&lt;/code&gt;,后续会详细说明.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;glossary.md-词汇表文件可选&quot;&gt;&lt;code&gt;GLOSSARY.md&lt;/code&gt; 词汇表文件[可选]&lt;/h3&gt;
&lt;p&gt;词汇表文件,用于全书的专业词汇解释说明,比如鼠标悬停在专业词汇上会有相应提示.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;语法格式: &lt;code&gt;##&lt;/code&gt; + ` &lt;code&gt;+&lt;/code&gt;专业词汇`&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习 &lt;code&gt;gitbook&lt;/code&gt; 前最好先学习下markdown和git,你知道他们的用途吗?&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## markdown
简洁优雅的排版语言,简化版的 `HTML`,加强版的 `TXT`,详情请参考 [https://snowdreams1006.github.io/markdown/](https://snowdreams1006.github.io/markdown/)

## git
分布式版本控制系统,详情请参考 [https://snowdreams1006.github.io/git/](https://snowdreams1006.github.io/git/)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;langs.md-语言文件可选&quot;&gt;&lt;code&gt;LANGS.md&lt;/code&gt; 语言文件[可选]&lt;/h3&gt;
&lt;p&gt;支持国际化编写图书,一种语言一个单独子目录,同样地,将语言文件放到根目录下.&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* [English](en/)
* [French](fr/)
* [Español](es/)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;章节小结-1&quot;&gt;章节小结&lt;/h3&gt;
&lt;p&gt;开发初始阶段运行 &lt;code&gt;gitbook init&lt;/code&gt; 命令按照 &lt;code&gt;SUMMARY.md&lt;/code&gt; 文件内容自动创建对应目录结构,编写各自文件内容后运行 &lt;code&gt;gitbook serve&lt;/code&gt; 启动本地服务实时预览效果.&lt;/p&gt;
&lt;p&gt;开发到一定程度后打算发布服务,再运行 &lt;code&gt;gitbook build&lt;/code&gt; 输出到 &lt;code&gt;_book/&lt;/code&gt; 目录,别忘了配置 &lt;code&gt;book.json&lt;/code&gt; 文件,然后就可以将 &lt;code&gt;_book/&lt;/code&gt; 文件夹整个扔到 &lt;code&gt;nginx&lt;/code&gt; 等静态服务器上,这样就能联网访问你的电子书了.&lt;/p&gt;
&lt;p&gt;是不是很简单,后续还会有如何发布与导出等相关教程,今天先到这里,下次见!&lt;/p&gt;
</description>
<pubDate>Wed, 03 Apr 2019 07:33:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>给我一个命令行,生成你专属的电子书</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowdreams1006/p/10649210.html</dc:identifier>
</item>
<item>
<title>为什么要重写 hashcode 和 equals 方法？ - 程序猿杂货铺</title>
<link>http://www.cnblogs.com/zhoudl/p/10648860.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoudl/p/10648860.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;引言&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;以前面试的时候被面试官问到过这样一个问题：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你有没有重写过 hashCode 方法？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;心里想着我没事重写哪玩意干啥，能不写就不写。嘴上当然没敢这么说，只能略表遗憾的说抱歉，我没写过。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;撇了面试官一眼，明显看到他对这个回答不满意，但是这已经触及到我的知识盲点了，我也很惭愧，可是确实没有重写过,咱也不能胡扯不是。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;然后他又问到另外一个问题：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你在用 HashMap 的时候，键（Key）部分，有没有放过自定义对象？&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我说我放过，很自信的说我放过（其实我忘了我有没有放过），但是不能怂啊，第一个都不会了，第二个再说不会哪不是直接拜拜要走人了吗？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;面试官狡猾的笑了，说是你既然没有重写过 hashCode 方法，你怎么把自定义对象放进去的？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我勒个去，原来你在这等着我呢，没想到这还是个连环炮，惹不起惹不起，认怂三连&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://images.zhoudl.top/0315/09777303.jpg&quot;&gt;&lt;img src=&quot;http://images.zhoudl.top/0315/09777303.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;不过不会就学，不懂就问，这一直都是咱程序猿优秀的素养，今天就干脆从 Hash 表学起，讲述 HashMap 的存取数据规则，由此来搞定上述问题的答案。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过 Hash 算法来了解 HashMap 对象的高效性&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们先复习数据结构里的一个知识点：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在一个长度为 n（假设是100）的线性表（假设是 ArrayList）里，存放着无序的数字；如果我们要找一个指定的数字，就不得不通过从头到尾依次遍历来查找，这样的平均查找次数是 n / 2（这里是50）。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们再来观察 Hash 表（这里所说的 Hash 表纯粹是数据结构上的概念，和 Java 无关）。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即 key，即可查找到其对应的值。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;它的平均查找次数接近于 1，代价相当小。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用哈希查找有两个步骤:&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用哈希函数将被查找的键转换为数组的索引：在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;处理哈希碰撞冲突：有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;既然哈希查找第一步就是使用哈希函数将键映射成索引，那我们就先假设一个 Hash 函数是&lt;span&gt;&lt;code&gt;x * x % 5&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，（当然实际编程中不可能用这么简单的 Hash 函数，一般选择的哈希函数都是要易于计算并且能够均匀分布所有键的，这里纯粹为了说明方便），然后假设 Hash 表是一个长度是 11 的线性表。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;接下来如果我们如果要把 6 放入其中，那么我们首先会对 6 用 Hash 函数计算一下，结果是 1，所以我们就把 6 放入到索引号是 1 这个位置。同样如果我们要放数字 7，经过 Hash 函数计算，7 的结果是 4，那么它将被放入索引是 4 的这个位置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如下如所示：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://images.zhoudl.top/0315/1552616238675.png&quot;&gt;&lt;img src=&quot;http://images.zhoudl.top/0315/1552616238675.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这样做的好处非常明显：比如我们要从中找 6 这个元素，我们可以先通过 Hash 函数计算 6 的索引位置，然后直接从 1 号索引里找到它了。不过我们有可能会遇到&lt;span&gt;&lt;strong&gt;Hash值冲突&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;这个问题，比如经过 Hash 函数计算后，7 和 8 会有相同的 Hash 值，此时我们就需要了解一下解决哈希碰撞的几种常见方式：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;开放地址法&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用某种探查(亦称探测)技术在散列表中形成一个探查序列。沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存入该地址单元）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、线性补偿探测法以及随机探测等。限于篇幅，我们此处只讨论线性探查法。&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;线性探查法&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;该方法基本思想是：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;将散列表 T[0..m-1] 看成是一个循环向量，若初始探查的地址为d(即h(key)=d)，则最长的探查序列为：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;d，d+l，d+2，…，m-1，0，1，…，d-1&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;即 : 探查时从地址 d 开始，首先探查 T[d]，然后依次探查 T[d+1]，…，直到 T[m-1]，此后又循环到 T[0]，T[1],…，直到探查到 T[d-1] 为止。 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;探查过程终止于三种情况：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;*&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;若当前探查的单元为空，则表示查找失败（若是插入则将 key 写入其中）；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;若当前探查的单元中含有 key，则查找成功，但对于插入意味着失败；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;若探查到 T[d-1] 时仍未发现空单元也未找到 key，则无论是查找还是插入均意味着失败(此时表满)。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;利用开放地址法的一般形式，线性探查法的探查序列为：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt; hi = (h(key)+i)％m 0≤i≤m-1 // 即di=i&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;用线性探测法处理冲突，思路清晰，算法简单，但存在下列缺点：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;3.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;处理溢出需另编程序。一般可另外设立一个溢出表，专门用来存放上述哈希表中放不下的记录。此溢出表最简单的结构是顺序表，查找方法可用顺序查找。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;按上述算法建立起来的哈希表，删除工作非常困难。假如要从哈希表 HT 中删除一个记录，按理应将这个记录所在位置置为空，但我们不能这样做，而只能标上已被删除的标记，否则，将会影响以后的查找。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;线性探测法很容易产生堆聚现象。所谓堆聚现象，就是存入哈希表的记录在表中连成一片。按照线性探测法处理冲突，如果生成哈希地址的连续序列愈长 ( 即不同关键字值的哈希地址相邻在一起愈长 ) ，则当新的记录加入该表时，与这个序列发生冲突的可能性愈大。因此，哈希地址的较长连续序列比较短连续序列生长得快，这就意味着，一旦出现堆聚 ( 伴随着冲突 ) ，就将引起进一步的堆聚。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在使用了上述线性探查法的情况下，则 7 和 8 在存储的时候，因为两者哈希后得到的索引一致，并且 7 已经存到了哈希表中，哪么 8 在找到索引 4 的时候会发现已经有值了，则它继续开始往后查找，此时找到索引为 5 的位置发现为空，它就会把 8 放到索引为 5 的位置上，如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://images.zhoudl.top/0315/1552617550188.png&quot;&gt;&lt;img src=&quot;http://images.zhoudl.top/0315/1552617550188.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;链地址法&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;拉链法解决冲突的做法是：将所有关键字为同义词的结点链接在同一个单链表中。若选定的散列表长度为 m，则可将散列表定义为一个由 m 个头指针组成的指针数 组 T[0..m-1]。凡是散列地址为 i 的结点，均插入到以 T[i] 为头指针的单链表中。T 中各分量的初值均应为空指针。在拉链法中，装填因子 α 可以大于 1，但一般均取 α≤1。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;与开放定址法相比，拉链法有如下几个优点：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;4.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;由于拉链法中各链表上的结点空间是动态申请的，故它更适合于造表前无法确定表长的情况；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;开放定址法为减少冲突，要求装填因子 α 较小，故当结点规模较大时会浪费很多空间。而拉链法中可取 α≥1，且结点较大时，拉链法中增加的指针域可忽略不计，因此节省空间；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在用拉链法构造的散列表中，删除结点的操作易于实现。只要简单地删去链表上相应的结点即可。而对开放地址法构造的散列表，删除结点不能简单地将被删结 点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在 用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用拉链法的时候 7 和 8 的时候具体的做法是：为所有 Hash 值是 i 的对象建立一个同义词链表。假设我们在放入 8 的时候，发现 4 号位置已经被占，那么就会新建一个链表结点放入 8。同样，如果我们要找 8，那么发现 4 号索引里不是 8，那会沿着链表依次查找。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;存储位置如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://images.zhoudl.top/0315/1552618159233.png&quot;&gt;&lt;img src=&quot;http://images.zhoudl.top/0315/1552618159233.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Java 中的 HashMap 对象采用的是&lt;span&gt;&lt;strong&gt;链地址法&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;的解决方案。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;虽然我们还是无法彻底避免 Hash 值冲突的问题，但是 Hash 函数设计合理，仍能保证同义词链表的长度被控制在一个合理的范围里。这里讲的理论知识并非无的放矢，大家能在后文里清晰地了解到重写 hashCode 方法的重要性。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2 为什么要重写 equals 和 hashCode 方法&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当我们用 HashMap 存入自定义的类时，如果不重写这个自定义类的 equals 和 hashCode 方法，得到的结果会和我们预期的不一样。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们来看一个例子,定义一个 HashMapKey.java 的类，这个类只有一个属性 id ：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HashMapKey {
​
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer id;
​
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HashMapKey(Integer id) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.id =&lt;span&gt; id;
    }
​
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Integer getId() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;测试类如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestHashMap {
​
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        HashMapKey k1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMapKey(1&lt;span&gt;);
        HashMapKey k2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; HashMapKey(1&lt;span&gt;);
        HashMap&lt;/span&gt;&amp;lt;HashMapKey, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();
        map.put(k1, &lt;/span&gt;&quot;程序猿杂货铺&quot;&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;map.get(k2) : &quot; +&lt;span&gt; map.get(k2));
    }
​
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在 main 函数里，我们定义了两个 HashMapKey 对象，它们的 id 都是 1，然后创建了一个 HashMap 对象，紧接着我们通过 put 方法把 k1 和一串字符放入到 map里，最后用 k2 去从 HashMap 里得到值，因为 k1 和 k2 值是一样的，理论上我们是可以用这个键获取到对应的值的，看似符合逻辑，实则不然，它的执行结果是：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
map.get(k2) : &lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://images.zhoudl.top/0315/09D6AC84.jpg&quot;&gt;&lt;img src=&quot;http://images.zhoudl.top/0315/09D6AC84.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实出现这个情况的原因有两个：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当我们往 HashMap 里放 k1 时，首先会调用 HashMapKey 这个类的 hashCode 方法计算它的 hash 值，随后把 k1 放入 hash 值所指引的内存位置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;但是我们没有在 HashMapKey 里重写 hashCode 方法，所以这里调用的是 Object 类的 hashCode 方法，而 Object 类的 hashCode 方法返回的 hash 值其实是 k1 对象的内存地址（假设是 0x100）。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://images.zhoudl.top/0315/1552619614241.png&quot;&gt;&lt;img src=&quot;http://images.zhoudl.top/0315/1552619614241.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;如果我们随后是调用 map.get(k1)，那么我们会再次调用 hashCode 方法（还是返回 k1 的地址 0x100），随后根据得到的 hash 值，能很快地找到 k1。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;但我们这里的代码是 map.get(k2)，当我们调用Object类的 hashCode方法（因为 HashMapKey 里没定义）计算 k2 的 hash值时，其实得到的是 k2 的内存地址（假设是 0x200）。由于 k1 和 k2 是两个不同的对象，所以它们的内存地址一定不会相同，也就是说它们的 hash 值一定不同，这就是我们无法用 k2 的 hash 值去拿 k1 的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;接下来我们在类 HashMapKey 中重写 hashCode 方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode() {
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; id.hashCode();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;此时因为 hashCode 方法返回的是 id 的 hash值，所以此处 k1 和 k2 这两个对象的 hash 值就变得相等了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;但是问题还没有结束，我们再来更正一下存 k1 和 取 k2 的动作。存 k1 时，是根据它 id 的 hash 值，假设这里是 103，把 k1 对象放入到对应的位置。而取 k2 时，是先计算它的 hash 值（由于 k2 的 id 也是 1，这个值也是 103），随后到这个位置去找。但运行结果还是会出乎我们意料：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
map.get(k2) : &lt;span&gt;null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;明明 103号位置已经有 k1，但打印输出结果依然是 null。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://images.zhoudl.top/0315/09E512FA.gif&quot;&gt;&lt;img src=&quot;http://images.zhoudl.top/0315/09E512FA.gif&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实原因就是没有重写 HashMapKey 对象的 equals 方法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;HashMap 是用&lt;span&gt;&lt;strong&gt;链地址法&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;来处理冲突，也就是说，在 103号位置上，有可能存在着多个用链表形式存储的对象。它们通过 hashCode 方法返回的 hash 值都是 103。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://images.zhoudl.top/0315/1552620245018.png&quot;&gt;&lt;img src=&quot;http://images.zhoudl.top/0315/1552620245018.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当我们通过 k2 的 hashCode 到 103号位置查找时，确实会得到 k1。但 k1 有可能仅仅是和 k2 具有相同的 hash值，但未必和 k2 相等，这个时候，就需要调用 HashMapKey 对象的 equals 方法来判断两者是否相等了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;由于我们在 HashMapKey 对象里没有定义 equals 方法，系统就不得不调用 Object 类的 equals 方法，同理由于 Object 的固有方法是根据两个对象的内存地址来判断，所以 k1 和 k2 一定不会相等，这就是为什么通过 map.get(k2) 依然得到 null 的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;为了解决这个问题，我们继续重写 equals 方法，在这个方法里，只要两个对象都是 Key 类型，而且它们的 id 相等，它们就相等。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object o) {
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (o == &lt;span&gt;null&lt;/span&gt; || !(o &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; HashMapKey)) {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
     } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
         &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getId().equals(((HashMapKey) o).getId());
     }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;至此，问题已经解决。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;http://images.zhoudl.top/0315/09ED7FD7.jpg&quot;&gt;&lt;img src=&quot;http://images.zhoudl.top/0315/09ED7FD7.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们平时在项目开发中经常会用到 HashMap，虽然很多时候我们都会尽可能避免去在键值存放自定义对象，但是正因为如此，一旦碰到需要存放自定义对象了就容易出问题，重申一遍：如果你需要要在 HashMap 的“键”部分存放自定义的对象，一定要重写 equals 和 hashCode 方法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实 这个问题本身不难，只要我们平时稍微注意以下就可以避免，本文也是大概总结了以下，避免大家以后碰到了踩坑，希望对你有所帮助，保不齐下次面试也有人问你同样的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-plain&quot;&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Apr 2019 07:01:00 +0000</pubDate>
<dc:creator>程序猿杂货铺</dc:creator>
<og:description>我们平时在项目开发中经常会用到 HashMap，虽然很多时候我们都会尽可能避免去在键值存放自定义对象，但是正因为如此，一旦碰到需要存放自定义对象了就容易出问题，重申一遍：如果你需要要在 HashMap</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhoudl/p/10648860.html</dc:identifier>
</item>
<item>
<title>ES 11 - 配置Elasticsearch的映射（mapping） - 马瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/10648835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/10648835.html</guid>
<description>&lt;h2 id=&quot;什么是映射&quot;&gt;1.1 什么是映射&lt;/h2&gt;
&lt;p&gt;(1) 映射(mapping): 定义index的元数据, 指定要索引并存储的文档的字段类型.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;也就是说映射决定了Elasticsearch在建立倒排索引、进行检索时对文档采取的相关策略, 如数字类型、日期类型、文本类型等等.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;需要注意的是: &lt;strong&gt;检索时用到的分析策略, 要和建立索引时的分析策略相同, 否则将导致数据不准确.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(2) ES对不同的类型有不同的存储和检索策略.&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;① 比如: 对full text型的数据类型(如text), 在索引时, 会经过各类处理 (包括分词、normalization(时态转换、同义词转换、大小写转换)等处理), 才会建立到索引数据中.&lt;br/&gt;② 再比如: 对exact value(如date), 在索引的分词阶段, 会将整个value作为一个关键词建立到倒排索引中.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;映射的组成&quot;&gt;1.2 映射的组成&lt;/h2&gt;
&lt;p&gt;每个index都有一 &lt;del&gt;(至多)&lt;/del&gt; 个type, 每个type对应一个mapping.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在Elasticsearch 6.X版本开始, 1个index只能有1个type.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个mapping都由下述部分组成:&lt;/p&gt;
&lt;blockquote readability=&quot;11.5&quot;&gt;
&lt;p&gt;① 元字段: &lt;code&gt;_index&lt;/code&gt;、&lt;code&gt;_type&lt;/code&gt;、&lt;code&gt;_id&lt;/code&gt; 和 &lt;code&gt;_source&lt;/code&gt;.&lt;br/&gt;② field/properties(字段或属性): &lt;strong&gt;同一index中, 同名的field的映射配置必须相同&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;a) 因为index是根据&lt;code&gt;_type&lt;/code&gt;元字段来区分type的, 也就是存储的每个文档中都有&lt;code&gt;_type&lt;/code&gt;等元字段, 如果相同名称的field的映射(&lt;code&gt;_type&lt;/code&gt;字段的值)不同, Elasticsearch在解析时就会出现冲突.&lt;/p&gt;
&lt;p&gt;b) 这些参数可以例外: &lt;code&gt;copy_to、dynamic、enabled、ignore_above、include_in_all&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于type的处理方法, 可以参考博客: &lt;a href=&quot;http://www.cnblogs.com/shoufeng/p/10648835.html&quot;&gt;ES XX - Elasticsearch对type的处理（type的底层结构）&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;元字段&quot;&gt;1.3 元字段&lt;/h2&gt;
&lt;p&gt;每个文档都有与之关联的元数据 —— ES内部为所有的文档配备的field, 都是以下划线&lt;code&gt;_&lt;/code&gt;开头的内置字段.&lt;/p&gt;
&lt;p&gt;具体的内容请参考博文 &lt;a href=&quot;http://www.cnblogs.com/shoufeng/p/10648835.html&quot;&gt;ES XX - Elasticsearch的元字段&lt;/a&gt; 中详细讲解.&lt;/p&gt;
&lt;h2 id=&quot;字段的类型&quot;&gt;1.4 字段的类型&lt;/h2&gt;
&lt;p&gt;Elasticsearch中每个field都对应一至多个数据类型.&lt;/p&gt;
&lt;p&gt;详细的内容请参考博文 &lt;a href=&quot;http://www.cnblogs.com/shoufeng/p/10648835.html&quot;&gt;ES XX - Elasticsearch中字段的类型&lt;/a&gt; 中详细讲解.&lt;/p&gt;

&lt;h2 id=&quot;创建mapping&quot;&gt;2.1 创建mapping&lt;/h2&gt;
&lt;p&gt;(1) 必读说明:&lt;/p&gt;
&lt;p&gt;① 创建mapping时, 可以指定每个field是否需要:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;索 引: &lt;kbd&gt;&lt;code&gt;&quot;index&quot;: true&lt;/code&gt;&lt;/kbd&gt; —— 默认配置&lt;br/&gt;不索引: &lt;kbd&gt;&lt;code&gt;&quot;index&quot;: false&lt;/code&gt;&lt;/kbd&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;② &lt;kbd&gt;&lt;code&gt;mapping root object&lt;/code&gt;&lt;/kbd&gt;:&lt;/p&gt;
&lt;p&gt;每个type对应的mapping的JSON串, 包括&lt;code&gt;properties, metadata(_id, _source, _type) , settings(analyzer) , 其他settings(如include_in_all)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(2) 创建mapping的示例:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求: 创建名为website的索引, 包含一个user类型. user类型中禁用元字段&lt;code&gt;_all&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT website
{
    &quot;mappings&quot;: {
        &quot;user&quot;: {       // 这就是一个root object
            &quot;_all&quot;: { &quot;enabled&quot;: false },  // 禁用_all字段
            &quot;properties&quot;: {
                &quot;user_id&quot;: { &quot;type&quot;: &quot;text&quot; },
                  &quot;name&quot;: {
                    &quot;type&quot;: &quot;text&quot;,
                    &quot;analyzer&quot;: &quot;english&quot;
                },
                &quot;age&quot;: { &quot;type&quot;: &quot;integer&quot; },
                &quot;sex&quot;: { &quot;type&quot;: &quot;keyword&quot; },
                &quot;birthday&quot;: {
                    &quot;type&quot;: &quot;date&quot;, 
                    &quot;format&quot;: &quot;strict_date_optional_time||epoch_millis&quot;
                },
                &quot;address&quot;: {
                    &quot;type&quot;: &quot;text&quot;,
                    &quot;index&quot;: false         // 不分词
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) 过期提示说明 —— 这里使用的是Elasticsearch 6.6.10版本:&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;① 是否索引的API已经做了修改, 若使用&quot;analyzed&quot; | &quot;not_analyzed&quot; | &quot;yes&quot; | &quot;no&quot;等, 将抛出如下警告:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#! Deprecation: Expected a boolean [true/false] for property [index] but got [not_analyzed]
#! Deprecation: Expected a boolean [true/false] for property [index] but got [no]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;② &lt;code&gt;_all&lt;/code&gt;元字段也将在7.0版本中移除, 它建议我们使用&lt;code&gt;copy_to&lt;/code&gt;定制自己的&lt;code&gt;all field&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;#! Deprecation: [_all] is deprecated in 6.0+ and will be removed in 7.0. As a replacement, you can use [copy_to] on mapping fields to create your own catch all field.&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;更新mapping&quot;&gt;2.2 更新mapping&lt;/h2&gt;
&lt;p&gt;(1) 必读说明:&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;映射一旦创建完成, 就不允许修改:&lt;/p&gt;
&lt;p&gt;—— Elasticsearch对文档的分析、存储、检索等过程, 都是严格按照mapping中的配置进行的. 如果允许后期修改mapping, 在检索时对索引的处理将存在不一致的情况, 导致数据检索行为不准确.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;只能在创建index的时候手动配置mapping, 或者新增field mapping, 但是不能update field mapping.&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(2) 更新mapping出现异常:&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;修改已经创建好的mapping&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT website
{
    &quot;mappings&quot;: {
        &quot;user&quot;: {
            &quot;properties&quot;: {
                &quot;author_id&quot;: { &quot;type&quot;: &quot;text&quot; }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;抛出如下错误 —— 索引已经存在的异常:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;error&quot;: {
    &quot;root_cause&quot;: [
      {
        &quot;type&quot;: &quot;resource_already_exists_exception&quot;,
        &quot;reason&quot;: &quot;index [website/mVYk4-a7RMOZbkcCp2avfw] already exists&quot;,
        &quot;index_uuid&quot;: &quot;mVYk4-a7RMOZbkcCp2avfw&quot;,
        &quot;index&quot;: &quot;website&quot;
      }
    ],
    &quot;type&quot;: &quot;resource_already_exists_exception&quot;,
    &quot;reason&quot;: &quot;index [website/mVYk4-a7RMOZbkcCp2avfw] already exists&quot;,
    &quot;index_uuid&quot;: &quot;mVYk4-a7RMOZbkcCp2avfw&quot;,
    &quot;index&quot;: &quot;website&quot;
  },
  &quot;status&quot;: 400
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(3) 向mapping中添加新type:&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;向已有mapping中添加字段及其映射信息:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT website/_mapping/user     // 修改user类型的_mapping, 注意API的顺序
{
    &quot;properties&quot;: {
        &quot;new_field&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;index&quot;: false
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;查看mapping&quot;&gt;2.3 查看mapping&lt;/h2&gt;
&lt;p&gt;(1) 查看mapping的API:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;GET website/_mapping&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 查看的结果信息如下:&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;website&quot; : {
    &quot;mappings&quot; : {
      &quot;user&quot; : {
        &quot;_all&quot; : {
          &quot;enabled&quot; : false        // 禁用元字段_all
        },
        &quot;properties&quot; : {
          &quot;address&quot; : {
            &quot;type&quot; : &quot;text&quot;,
            &quot;index&quot; : false        // 不索引
          },
          &quot;age&quot; : {
            &quot;type&quot; : &quot;integer&quot;
          },
          &quot;birthday&quot; : {
            &quot;type&quot; : &quot;date&quot;
          },
          &quot;name&quot; : {
            &quot;type&quot; : &quot;text&quot;,
            &quot;analyzer&quot; : &quot;english&quot;
          },
          &quot;new_field&quot; : {          // 后期添加的新字段
            &quot;type&quot; : &quot;text&quot;,
            &quot;index&quot; : false        // 不索引
          },
          &quot;sex&quot; : {
            &quot;type&quot; : &quot;keyword&quot;
          },
          &quot;user_id&quot; : {
            &quot;type&quot; : &quot;text&quot;
          }
        }
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;16.040752351097&quot;&gt;

&lt;p&gt;作者: ma_shoufeng(马瘦风)&lt;/p&gt;
&lt;p&gt;出处: 博客园 &lt;a href=&quot;https://www.cnblogs.com/shoufeng&quot;&gt;马瘦风的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;您的支持是对博主的极大鼓励, 感谢您的阅读.&lt;/p&gt;
&lt;p&gt;本文版权归博主所有, 欢迎转载, 但请保留此段声明, 并在文章页面明显位置给出原文链接, 否则博主保留追究相关人员法律责任的权利.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 03 Apr 2019 06:57:00 +0000</pubDate>
<dc:creator>马瘦风</dc:creator>
<og:description>Elasticsearch的映射(mapping)是什么? 在创建索引时, 如何对不同的数据类型进行特殊的配置与操作? 映射(mapping)有哪些组成部分? 如何配置和更新mapping? 这篇文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufeng/p/10648835.html</dc:identifier>
</item>
<item>
<title>C语言数组操作和指针操作谁更高效 - Vedic</title>
<link>http://www.cnblogs.com/vedic/p/10648648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vedic/p/10648648.html</guid>
<description>&lt;pre&gt;
0000842c &amp;lt;main&amp;gt;&lt;span&gt;:
    842c:       e92d4800        push    {fp, lr}
    &lt;/span&gt;&lt;span&gt;8430&lt;/span&gt;:       e28db004        add     fp, sp, #&lt;span&gt;4&lt;/span&gt;
    &lt;span&gt;8434&lt;/span&gt;:       e24dd038        sub     sp, sp, #&lt;span&gt;56&lt;/span&gt;     ; &lt;span&gt;0x38&lt;/span&gt;
    &lt;span&gt;8438&lt;/span&gt;:       e3a03000        mov     r3, #&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    843c:       e50b3018        str     r3, [fp, #&lt;/span&gt;-&lt;span&gt;24&lt;/span&gt;]  ; &lt;span&gt;0xffffffe8&lt;/span&gt;
    &lt;span&gt;8440&lt;/span&gt;:       e3a03000        mov     r3, #&lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;8444&lt;/span&gt;:       e54b3014        strb    r3, [fp, #-&lt;span&gt;20&lt;/span&gt;]  ; &lt;span&gt;0xffffffec&lt;/span&gt;
    &lt;span&gt;8448&lt;/span&gt;:       e3a03001        mov     r3, #&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    844c:       e54b3017        strb    r3, [fp, #&lt;/span&gt;-&lt;span&gt;23&lt;/span&gt;]  ; &lt;span&gt;0xffffffe9&lt;/span&gt;
    &lt;span&gt;8450&lt;/span&gt;:       e3a03002        mov     r3, #&lt;span&gt;2&lt;/span&gt;
    &lt;span&gt;8454&lt;/span&gt;:       e54b3016        strb    r3, [fp, #-&lt;span&gt;22&lt;/span&gt;]  ; &lt;span&gt;0xffffffea&lt;/span&gt;
    &lt;span&gt;8458&lt;/span&gt;:       e24b3024        sub     r3, fp, #&lt;span&gt;36&lt;/span&gt;     ; &lt;span&gt;0x24&lt;/span&gt;&lt;span&gt;
    845c:       e3a02000        mov     r2, #&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;8460&lt;/span&gt;&lt;span&gt;:       e5832000        str     r2, [r3]
    &lt;/span&gt;&lt;span&gt;8464&lt;/span&gt;:       e2833004        add     r3, r3, #&lt;span&gt;4&lt;/span&gt;
    &lt;span&gt;8468&lt;/span&gt;:       e3a02000        mov     r2, #&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    846c:       e5832000        str     r2, [r3]
    &lt;/span&gt;&lt;span&gt;8470&lt;/span&gt;:       e2833004        add     r3, r3, #&lt;span&gt;4&lt;/span&gt;
    &lt;span&gt;8474&lt;/span&gt;:       e3a02000        mov     r2, #&lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;8478&lt;/span&gt;&lt;span&gt;:       e1c320b0        strh    r2, [r3]
    847c:       e2833002        add     r3, r3, #&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
    &lt;span&gt;8480&lt;/span&gt;:       e3a03001        mov     r3, #&lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;8484&lt;/span&gt;:       e14b32b4        strh    r3, [fp, #-&lt;span&gt;36&lt;/span&gt;]  ; &lt;span&gt;0xffffffdc&lt;/span&gt;
    &lt;span&gt;8488&lt;/span&gt;:       e3a03002        mov     r3, #&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    848c:       e14b32b2        strh    r3, [fp, #&lt;/span&gt;-&lt;span&gt;34&lt;/span&gt;]  ; &lt;span&gt;0xffffffde&lt;/span&gt;
    &lt;span&gt;8490&lt;/span&gt;:       e3a03003        mov     r3, #&lt;span&gt;3&lt;/span&gt;
    &lt;span&gt;8494&lt;/span&gt;:       e14b32b0        strh    r3, [fp, #-&lt;span&gt;32&lt;/span&gt;]  ; &lt;span&gt;0xffffffe0&lt;/span&gt;
    &lt;span&gt;8498&lt;/span&gt;:       e24b3038        sub     r3, fp, #&lt;span&gt;56&lt;/span&gt;     ; &lt;span&gt;0x38&lt;/span&gt;&lt;span&gt;
    849c:       e3a02000        mov     r2, #&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    84a0:       e5832000        str     r2, [r3]
    84a4:       e2833004        add     r3, r3, #&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    84a8:       e3a02000        mov     r2, #&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    84ac:       e5832000        str     r2, [r3]
    84b0:       e2833004        add     r3, r3, #&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    84b4:       e3a02000        mov     r2, #&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    84b8:       e5832000        str     r2, [r3]
    84bc:       e2833004        add     r3, r3, #&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    84c0:       e3a02000        mov     r2, #&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    84c4:       e5832000        str     r2, [r3]
    84c8:       e2833004        add     r3, r3, #&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    84cc:       e3a02000        mov     r2, #&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    84d0:       e5832000        str     r2, [r3]
    84d4:       e2833004        add     r3, r3, #&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    84d8:       e3a03002        mov     r3, #&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;
    84dc:       e50b3038        str     r3, [fp, #&lt;/span&gt;-&lt;span&gt;56&lt;/span&gt;]  ; &lt;span&gt;0xffffffc8&lt;/span&gt;&lt;span&gt;
    84e0:       e3a03003        mov     r3, #&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
    84e4:       e50b3034        str     r3, [fp, #&lt;/span&gt;-&lt;span&gt;52&lt;/span&gt;]  ; &lt;span&gt;0xffffffcc&lt;/span&gt;&lt;span&gt;
    84e8:       e3a03004        mov     r3, #&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    84ec:       e50b3030        str     r3, [fp, #&lt;/span&gt;-&lt;span&gt;48&lt;/span&gt;]  ; &lt;span&gt;0xffffffd0&lt;/span&gt;&lt;span&gt;
    84f0:       e24b3018        sub     r3, fp, #&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;
    84f4:       e50b3008        str     r3, [fp, #&lt;/span&gt;-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]
    84f8:       e24b3024        sub     r3, fp, #&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     ; &lt;span&gt;0x24&lt;/span&gt;&lt;span&gt;
    84fc:       e50b300c        str     r3, [fp, #&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;8500&lt;/span&gt;:       e24b3038        sub     r3, fp, #&lt;span&gt;56&lt;/span&gt;     ; &lt;span&gt;0x38&lt;/span&gt;
    &lt;span&gt;8504&lt;/span&gt;:       e50b3010        str     r3, [fp, #-&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;8508&lt;/span&gt;:       e59f00b0        ldr     r0, [pc, #&lt;span&gt;176&lt;/span&gt;]  ; 85c0 &amp;lt;main+&lt;span&gt;0x194&lt;/span&gt;&amp;gt;&lt;span&gt;
    850c:       ebffff8f        bl      &lt;/span&gt;&lt;span&gt;8350&lt;/span&gt; &amp;lt;_init+&lt;span&gt;0x20&lt;/span&gt;&amp;gt;
    &lt;span&gt;8510&lt;/span&gt;:       e51b3008        ldr     r3, [fp, #-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;8514&lt;/span&gt;:       e2833002        add     r3, r3, #&lt;span&gt;2&lt;/span&gt;
    &lt;span&gt;8518&lt;/span&gt;&lt;span&gt;:       e5d32000        ldrb    r2, [r3]
    851c:       e2822001        add     r2, r2, #&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;8520&lt;/span&gt;:       e20220ff        and     r2, r2, #&lt;span&gt;255&lt;/span&gt;    ; &lt;span&gt;0xff&lt;/span&gt;
    &lt;span&gt;8524&lt;/span&gt;&lt;span&gt;:       e5c32000        strb    r2, [r3]
    &lt;/span&gt;&lt;span&gt;8528&lt;/span&gt;:       e59f0094        ldr     r0, [pc, #&lt;span&gt;148&lt;/span&gt;]  ; 85c4 &amp;lt;main+&lt;span&gt;0x198&lt;/span&gt;&amp;gt;&lt;span&gt;
    852c:       ebffff87        bl      &lt;/span&gt;&lt;span&gt;8350&lt;/span&gt; &amp;lt;_init+&lt;span&gt;0x20&lt;/span&gt;&amp;gt;
    &lt;span&gt;8530&lt;/span&gt;:       e55b3016        ldrb    r3, [fp, #-&lt;span&gt;22&lt;/span&gt;]  ; &lt;span&gt;0xffffffea&lt;/span&gt;
    &lt;span&gt;8534&lt;/span&gt;:       e2833001        add     r3, r3, #&lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;8538&lt;/span&gt;:       e20330ff        and     r3, r3, #&lt;span&gt;255&lt;/span&gt;    ; &lt;span&gt;0xff&lt;/span&gt;&lt;span&gt;
    853c:       e54b3016        strb    r3, [fp, #&lt;/span&gt;-&lt;span&gt;22&lt;/span&gt;]  ; &lt;span&gt;0xffffffea&lt;/span&gt;
    &lt;span&gt;8540&lt;/span&gt;:       e59f0078        ldr     r0, [pc, #&lt;span&gt;120&lt;/span&gt;]  ; 85c0 &amp;lt;main+&lt;span&gt;0x194&lt;/span&gt;&amp;gt;
    &lt;span&gt;8544&lt;/span&gt;:       ebffff81        bl      &lt;span&gt;8350&lt;/span&gt; &amp;lt;_init+&lt;span&gt;0x20&lt;/span&gt;&amp;gt;
    &lt;span&gt;8548&lt;/span&gt;:       e51b300c        ldr     r3, [fp, #-&lt;span&gt;12&lt;/span&gt;&lt;span&gt;]
    854c:       e2833004        add     r3, r3, #&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
    &lt;span&gt;8550&lt;/span&gt;&lt;span&gt;:       e1d320b0        ldrh    r2, [r3]
    &lt;/span&gt;&lt;span&gt;8554&lt;/span&gt;:       e2822001        add     r2, r2, #&lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;8558&lt;/span&gt;:       e1a02802        lsl     r2, r2, #&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
    855c:       e1a02822        lsr     r2, r2, #&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;
    &lt;span&gt;8560&lt;/span&gt;&lt;span&gt;:       e1c320b0        strh    r2, [r3]
    &lt;/span&gt;&lt;span&gt;8564&lt;/span&gt;:       e59f0058        ldr     r0, [pc, #&lt;span&gt;88&lt;/span&gt;]   ; 85c4 &amp;lt;main+&lt;span&gt;0x198&lt;/span&gt;&amp;gt;
    &lt;span&gt;8568&lt;/span&gt;:       ebffff78        bl      &lt;span&gt;8350&lt;/span&gt; &amp;lt;_init+&lt;span&gt;0x20&lt;/span&gt;&amp;gt;&lt;span&gt;
    856c:       e15b32b0        ldrh    r3, [fp, #&lt;/span&gt;-&lt;span&gt;32&lt;/span&gt;]  ; &lt;span&gt;0xffffffe0&lt;/span&gt;
    &lt;span&gt;8570&lt;/span&gt;:       e2833001        add     r3, r3, #&lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;8574&lt;/span&gt;:       e1a03803        lsl     r3, r3, #&lt;span&gt;16&lt;/span&gt;
    &lt;span&gt;8578&lt;/span&gt;:       e1a03823        lsr     r3, r3, #&lt;span&gt;16&lt;/span&gt;&lt;span&gt;
    857c:       e14b32b0        strh    r3, [fp, #&lt;/span&gt;-&lt;span&gt;32&lt;/span&gt;]  ; &lt;span&gt;0xffffffe0&lt;/span&gt;
    &lt;span&gt;8580&lt;/span&gt;:       e59f0038        ldr     r0, [pc, #&lt;span&gt;56&lt;/span&gt;]   ; 85c0 &amp;lt;main+&lt;span&gt;0x194&lt;/span&gt;&amp;gt;
    &lt;span&gt;8584&lt;/span&gt;:       ebffff71        bl      &lt;span&gt;8350&lt;/span&gt; &amp;lt;_init+&lt;span&gt;0x20&lt;/span&gt;&amp;gt;
    &lt;span&gt;8588&lt;/span&gt;:       e51b3010        ldr     r3, [fp, #-&lt;span&gt;16&lt;/span&gt;&lt;span&gt;]
    858c:       e2833008        add     r3, r3, #&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;
    &lt;span&gt;8590&lt;/span&gt;&lt;span&gt;:       e5932000        ldr     r2, [r3]
    &lt;/span&gt;&lt;span&gt;8594&lt;/span&gt;:       e2822001        add     r2, r2, #&lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;8598&lt;/span&gt;&lt;span&gt;:       e5832000        str     r2, [r3]
    859c:       e59f0020        ldr     r0, [pc, #&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;]   ; 85c4 &amp;lt;main+&lt;span&gt;0x198&lt;/span&gt;&amp;gt;&lt;span&gt;
    85a0:       ebffff6a        bl      &lt;/span&gt;&lt;span&gt;8350&lt;/span&gt; &amp;lt;_init+&lt;span&gt;0x20&lt;/span&gt;&amp;gt;&lt;span&gt;
    85a4:       e51b3030        ldr     r3, [fp, #&lt;/span&gt;-&lt;span&gt;48&lt;/span&gt;]  ; &lt;span&gt;0xffffffd0&lt;/span&gt;&lt;span&gt;
    85a8:       e2833001        add     r3, r3, #&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    85ac:       e50b3030        str     r3, [fp, #&lt;/span&gt;-&lt;span&gt;48&lt;/span&gt;]  ; &lt;span&gt;0xffffffd0&lt;/span&gt;&lt;span&gt;
    85b0:       e3a03000        mov     r3, #&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    85b4:       e1a00003        mov     r0, r3
    85b8:       e24bd004        sub     sp, fp, #&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;
    85bc:       e8bd8800        pop     {fp, pc}
    85c0:       000086a0        .word   &lt;/span&gt;&lt;span&gt;0x000086a0&lt;/span&gt;&lt;span&gt;
    85c4:       000086a4        .word   &lt;/span&gt;&lt;span&gt;0x000086a4&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 03 Apr 2019 06:34:00 +0000</pubDate>
<dc:creator>Vedic</dc:creator>
<og:description>在上一篇博文 代码优化小技巧（持续更新......） 第三条关于数组和指针谁更高效， 意犹未尽， 决定单独拉出一篇来讲 编译和反汇编 &lt;main&gt;: 400596: 55 pus</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/vedic/p/10648648.html</dc:identifier>
</item>
<item>
<title>springboot+mybatis+dubbo+aop日志第一篇 - Eric.Chen</title>
<link>http://www.cnblogs.com/lc-chenlong/p/10648523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lc-chenlong/p/10648523.html</guid>
<description>&lt;p&gt;本篇文章主要讲述项目搭建过程，不会涉及过多的基础知识，本项目是作者对前段时间学习的一个总结，主要使用到技术有：maven父子工程、springboot、mybatis、dubbo、zookeeper、使用aop记录每个service服务方法的入参、方法名称、调用时长、出参到日志文件等，绝对是一个入门的好案列。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/340919/201904/340919-20190403141139160-1970090056.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h5&gt;节点角色说明&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;节点&lt;/th&gt;
&lt;th&gt;角色说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Provider&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;暴露服务的服务提供方&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Consumer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;调用远程服务的服务消费方&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Registry&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;服务注册与发现的注册中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;Monitor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;统计服务的调用次数和调用时间的监控中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;Container&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;服务运行容器&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5&gt;调用关系说明&lt;/h5&gt;
&lt;ol start=&quot;0&quot;&gt;&lt;li&gt;服务容器负责启动，加载，运行服务提供者。&lt;/li&gt;
&lt;li&gt;服务提供者在启动时，向注册中心注册自己提供的服务。&lt;/li&gt;
&lt;li&gt;服务消费者在启动时，向注册中心订阅自己所需的服务。&lt;/li&gt;
&lt;li&gt;注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。&lt;/li&gt;
&lt;li&gt;服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。&lt;/li&gt;
&lt;li&gt;服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;健壮性&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监控中心宕掉不影响使用，只是丢失部分采样数据&lt;/li&gt;
&lt;li&gt;数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务&lt;/li&gt;
&lt;li&gt;注册中心对等集群，任意一台宕掉后，将自动切换到另一台&lt;/li&gt;
&lt;li&gt;注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯&lt;/li&gt;
&lt;li&gt;服务提供者无状态，任意一台宕掉后，不影响使用&lt;/li&gt;
&lt;li&gt;服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多的dubbo使用说明，请参见dubbo官方文档说明&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html&quot; target=&quot;_blank&quot;&gt;http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;zookeeper下载地址：https:&lt;/p&gt;
&lt;p&gt;1.把下载文件解压到D盘（其他盘也可以，作者的是解压到D盘）&lt;/p&gt;
&lt;p&gt;2.打开zookeeper-3.4.5目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/340919/201904/340919-20190403141433666-447363244.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.在该目录里新建两个文件夹：data、log&lt;/p&gt;
&lt;p&gt;4.点击conf目录，复制zoo_sample.cfg文件到该目录，并修改复制后的文件名字为：zoo.cfg&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/340919/201904/340919-20190403141501719-1945626645.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、打开zoo.cfg文件，把步骤3创建的data、log路径赋值给dataDir和dataDirLog，如下所示（这是作者创建的额data、log目录）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;dataDir=D:\\java\\zookeeper-3.4.5\\zookeeper-3.4.5\\data

dataDirLog=D:\\java\\zookeeper-3.4.5\\zookeeper-3.4.5\\log&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/340919/201904/340919-20190403141529057-1025384295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、找到bin目录，双击zkServer.cmd，即可启动zookeeper服务，启动成功如下如所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/340919/201904/340919-20190403141541211-1703022537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;项目采用maven父子工程的模式进行管理，如下图所示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/340919/201904/340919-20190403141612258-1723189868.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;dubbo-demo-master为父工程，管理其他子工程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;dubbo-demo-model为实体层，主要用来定义实体、DTO等数据对象&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;dubbo-demo-api为接口层，单独抽出来一层，可以提供其他项目引用，该层依赖dubbo-demo-model&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;dubbo-demo-service为服务层，实现dubbo-demo-api里定义的接口，该层依赖dubbo-demo-api、dubbo-demo-model，zookeeper&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;dubbo-demo-web为UI层，主要定义各种Controller，该层依赖dubbo-demo-api、dubbo-demo-model、zookeeper&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下一篇文章会介绍api、service层的代码实现，如何通过dubbo把服务发布出去。&lt;/p&gt;


</description>
<pubDate>Wed, 03 Apr 2019 06:19:00 +0000</pubDate>
<dc:creator>Eric.Chen</dc:creator>
<og:description>本篇文章主要讲述项目搭建过程，不会涉及过多的基础知识，本项目是作者对前段时间学习的一个总结，主要使用到技术有：maven父子工程、springboot、mybatis、dubbo、zookeeper、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lc-chenlong/p/10648523.html</dc:identifier>
</item>
<item>
<title>java并发编程(2) --Synchronized与Volatile区别 - 正先生</title>
<link>http://www.cnblogs.com/zhxiansheng/p/10648452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxiansheng/p/10648452.html</guid>
<description>&lt;h2 id=&quot;synchronized&quot;&gt;1 Synchronized&lt;/h2&gt;
&lt;p&gt;在多线程并发中synchronized一直是元老级别的角色。利用synchronized来实现同步具体有一下三种表现形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于普通的同步方法，锁是当前实例对象。&lt;/li&gt;
&lt;li&gt;对于静态同步方法，锁是当前类的class对象。&lt;/li&gt;
&lt;li&gt;对于同步方法块，锁是synchronized括号里配置的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当一个代码，方法或者类被synchronized修饰以后。当一个线程试图访问同步代码块的时候，它首先必须得到锁，退出或抛出异常的时候必须释放锁。那么这样做有什么好处呢？&lt;/p&gt;
&lt;p&gt;它主要确保多个线程在同一时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量的&lt;strong&gt;可见性&lt;/strong&gt;和&lt;strong&gt;排他性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;如何实现排他性&quot;&gt;1.1 如何实现排他性&lt;/h3&gt;
&lt;p&gt;如下图所示，一个普通的方法会有一个左右摆动的开关，可以连接到任意一个线程，如果该方法代码不是原子性的，可能会出现一个线程并没有将方法代码执行完毕就链接到另一个线程中去。而被synchronized修饰的方法，链接到一个线程后，除非这个线程将方法执行完毕或者抛出异常，开关才会链接至别的线程。就这样将一个并行的操作变了穿行操作。（同一时间保证只有一个线程在执行方法代码）&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190327220345127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F6czE1NDkxMTA3Mw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;帮你买吧&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    int i = 1;
    public synchronized void increment(){
        i++;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面&lt;a href=&quot;https://blog.csdn.net/azs154911073/article/details/88809611&quot;&gt;并发基础及锁的原理&lt;/a&gt;中我们介绍过i++并不是原子操作，所有当多个线程同时操作i++的时候可能会出现多线程并发问题。而上诉代码块中i++是在synchronized修饰的方法中。其中一个线程进入该方法首先获得当前实例对象的锁，当另一个线程试图执行该方法的时候，由于前一个线程并没有执行完毕释放掉锁，所以该线程挂起等待锁的释放。&lt;/p&gt;
&lt;p&gt;通过加锁的方式我们实现了将i++非原子操作的方法变成了原子操作的方法。从而实现了&lt;strong&gt;排他性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;如何实现可见性&quot;&gt;1.2 如何实现可见性&lt;/h3&gt;
&lt;p&gt;因为在java内存模型中规定：在执行被synchronized修饰的代码时，线程首先获取锁→清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将工作内存中更改后的共享变量的值刷新到主内存中→释放互斥锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;这里有一个细节需要注意： 当一个线程A将最新的共享变量刷新到主内存的时候，会导致缓存在其他线程B的工作内存的这个共享变量失效。
当线程B下一次去访问这个变量的时候，会发现，工作缓存的这个变量已经失效。会强制从主内存中重新读取这个共享变量&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;volatile&quot;&gt;2 Volatile&lt;/h2&gt;
&lt;p&gt;当声明共享变量为volatile后，对这个变量的读/写将会很特别。volatile可以说是java虚拟机提供的最轻量级的同步机制。他只能能只能保证变量的可见性与读/写的原子性。要理解volatile确实是不容易的，接下来我们进入深入的分析！&lt;/p&gt;
&lt;h3 id=&quot;volatile的特性&quot;&gt;2.1 volatile的特性&lt;/h3&gt;
&lt;p&gt;下面有两个示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class VolatileTest1 {
    volatile long a = 0L;                   //使用volatile声明64位的long型变量

    public void set(long b) {           
        a = b;                              //单个volatile变量的写
    }

    public void increment() {           
        a++;                                //复合（多个）volatile变量的读/写
    }

    public long get() {
        return a;                           //的那个volatile变量的读
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class VolatileTest2 {
    long a = 0L;                                //64位的普通long型变量

    public synchronized void set(long b) {      //单个普通变量的写使用同步锁
        a = b;
    }

    public void increment() {                   //普通方法调用
        long tmp = get();                       //调用以同步的读方法
        tmp += 1;                               //普通的写操作
        set(tmp);                               //调用以同步的写方法
    }

    public synchronized long get() {            //单个普通变量的读使用同步锁
        return a;                       
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述两个示例代码所带来的的执行效果是相同的。&lt;/p&gt;
&lt;p&gt;可以看到被volatile修饰的变量读与写操作是原子性的。如前面所述，被Synchronized修饰的变量每次写操作完成后，会强制将工作内存中缓存的共享变量强制刷新到主内存中。所以保证了volatile修饰变量的可见性。&lt;/p&gt;
&lt;p&gt;从上述示例代码中我们也能看出，即便读与写是原子性，但是依旧不能保证 a++；是原子操作。这也是很多人对volatile字段理解困难的原因所在。&lt;/p&gt;
&lt;p&gt;简而言之，volatile变量自身具有下列特征。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;原子性：对任意单个volat变量的读 / 写具有原子性，但类似volatile++这种复合操作不具有原子性。&lt;/p&gt;
&lt;p&gt;在这里楼主插一个之前遇到的面试题：请问对于double和long类型的读写是原子性的吗？&lt;br/&gt;double和long类型是64位的，在一些32位的处理器上，可能会把一个64位的long/double型变量的&lt;br/&gt;写操作才分为两个32位的写操作来执行。座椅此时对这个64位变量的写操作将不具有原子性。&lt;br/&gt;但是如果被volatile修饰的话，写64位的double和long的操作依旧是原子操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;volatile的禁止重排序&quot;&gt;2.2 volatile的禁止重排序&lt;/h3&gt;
&lt;p&gt;除了前面内存可见性中讲到的volatile关键字可以保证变量修改的可见性之外，还有另一个重要的作用：在JDK1.5之后，可以使用volatile变量禁止指令重排序。&lt;/p&gt;
&lt;p&gt;volatile关键字通过提供“内存屏障”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。&lt;/p&gt;
&lt;p&gt;对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在每个volatile写操作的前面插入一个StoreStore屏障。&lt;/li&gt;
&lt;li&gt;在每个volatile写操作的后面插入一个StoreLoad屏障。&lt;/li&gt;
&lt;li&gt;在每个volatile读操作的后面插入一个LoadLoad屏障。&lt;/li&gt;
&lt;li&gt;在每个volatile读操作的后面插入一个LoadStore屏障&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结来说：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;volatile写操作之前的操作不会被编译器重排序到写操作之后。&lt;/li&gt;
&lt;li&gt;volatile读之后的操作不会被编译器重排序到volatile读操作之前。&lt;/li&gt;
&lt;li&gt;第一个是volatile读操作，第二个是volatile写操作，不能重排序&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;volatile的使用场景&quot;&gt;2.3 volatile的使用场景&lt;/h3&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li&gt;状态标志&lt;br/&gt;用volatile修饰的boolean 变量来作为while循环的的判断条件：当这个变量被其他线程修改的时候能保证while循环能立即读到。&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;一次性安全发布&lt;br/&gt;初始化对象的正确步骤为：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1、分配对象的内存空间&lt;br/&gt;2、初始化对象&lt;br/&gt;3、设置引用指向刚分配的内存地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而由于重排序机制，可能导致2、3步骤重排序，导致初始化对象的步骤变为 1-3-2。&lt;br/&gt;著名的&lt;strong&gt;双重检查锁&lt;/strong&gt;定存在的问题就是因为初始化对象的重排序，引用所指向的对象可能还没有完成初始化，而仅仅是指向了一个空的内存地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;独立观察&lt;br/&gt;这是第一种使用场景的引用。例如一种环境传感器能够感觉环境温度。一个后台线程可能会每隔几秒读取一次该传感器，并更新包含当前文档的 volatile 变量。然后，其他线程可以读取这个变量，从而随时能够看到最新的温度值。&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;开销较低的读－写锁策略&lt;br/&gt;前面我们介绍过，因为 ++x 实际上是三种操作（读、添加、存储）的简单组合，如果多个线程凑巧试图同时对 volatile 计数器执行增量操作，那么它的更新值有可能会丢失。但是被volatile修饰变量的读 / 写却是原子操作。所以当共享变量被volatile修饰之后，我们只需要在复合操作的方法上加上synchronized比直接用synchronized修饰该变量效率高的多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;volatile总结&quot;&gt;2.4 volatile总结&lt;/h3&gt;
&lt;p&gt;相对于synchronized块的代码锁，volatile应该是提供了一个轻量级的针对共享变量的锁，当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。&lt;/p&gt;
&lt;p&gt;volatile是一种稍弱的同步机制，在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。&lt;/p&gt;
&lt;h2 id=&quot;synchronized和volatile的区别&quot;&gt;3 synchronized和volatile的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、 volatile不会进行加锁操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、volatile变量作用类似于同步变量读写操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从内存可见性的角度看，写入volatile变量相当于退出同步代码块，而读取volatile变量相当于进入同步代码块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、volatile不如synchronized安全：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在代码中如果过度依赖volatile变量来控制状态的可见性，通常会比使用锁的代码更脆弱，也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它。一般来说，用同步机制会更安全些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、volatile无法同时保证内存可见性和原则性：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;加锁机制（即同步机制）既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性，原因是声明为volatile的简单变量如果当前值与该变量以前的值相关，那么volatile关键字不起作用，也就是说如下的表达式都不是原子操作：“count++”、“count = count+1”。&lt;/p&gt;
</description>
<pubDate>Wed, 03 Apr 2019 06:10:00 +0000</pubDate>
<dc:creator>正先生</dc:creator>
<og:description>1 Synchronized 在多线程并发中synchronized一直是元老级别的角色。利用synchronized来实现同步具体有一下三种表现形式： 对于普通的同步方法，锁是当前实例对象。 对于静</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhxiansheng/p/10648452.html</dc:identifier>
</item>
<item>
<title>基于JavaMail开发邮件发送器工具类 - 架构与我</title>
<link>http://www.cnblogs.com/atcloud/p/10648202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atcloud/p/10648202.html</guid>
<description>&lt;p&gt;在开发当中肯定会碰到利用Java调用邮件服务器的服务发送邮件的情况，比如账号激活、找回密码等功能。本人之前也碰到多次这样需求，为此特意将功能封装成一个简单易用工具类，需要用邮件发送功能时，只需要调用相关的接口即可。本人也将该工具提交到了GitHub上（https://github.com/lzj09/mail-helper），供大家参考。接下来，简单介绍一下该工具类及使用方法。&lt;/p&gt;
&lt;h2 id=&quot;工程依赖&quot;&gt;1、工程依赖&lt;/h2&gt;
&lt;p&gt;本工程主要依赖如下Jar:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;javax.mail&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.mail-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.6.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.sun.mail&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;javax.mail&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.6.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.freemarker&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;freemarker&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.3.23&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于邮件发送是基于JavaMail的所以需要依赖JavaMail相关的Jar;&lt;/p&gt;
&lt;p&gt;发送邮件的模板不仅支持简单的文本内容，也支持html，同时邮件模板中的语法支持freemarker语法，所以需要freemarker相关Jar;&lt;/p&gt;
&lt;p&gt;记录日志信息，目前使用log4j。&lt;/p&gt;
&lt;h2 id=&quot;核心类mailhelper&quot;&gt;2、核心类MailHelper&lt;/h2&gt;
&lt;p&gt;核心类MailHelper中最重要的send方法，即邮件发送方法，该方法的签名为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void send(SenderConfig sender, String receiver, String subject, String template, Map&amp;lt;String, Object&amp;gt; data) throws Exception&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法有5个参数，分别是：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;SenderConfig sender：邮件发送账号的配置信息，配置信息有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 用户名
private String username;
// 密码
private String password;
// 昵称
private String nickname;
// smtp服务主机名
private String smtpHost;
// smtp服务端口
private String smtpPort;
// 是否开启ssl
private boolean isSsl;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实最主要就是smtp的配置信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;String receiver：邮件接收者邮箱地址&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;String subject：邮件的主题，也即在邮件列表上显示的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;String template：邮件模板内容，支持freemarker语法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Map&amp;lt;String, Object&amp;gt; data：邮件模板中需要替换的数据内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该方法的实现为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 将SenderConfig配置信息转换成Properties
Properties prop = wrapProperties(sender);

// 获取权限配置
AuthConfig auth = getAuthConfig(sender);

// 构建邮件会话
Session mailSession = Session.getDefaultInstance(prop, auth);  
mailSession.setDebug(false); 

// 构建邮件消息
Message mailMessage = new MimeMessage(mailSession);

// 设置昵称
String nick = MimeUtility.encodeText(getNickname(sender));
Address from = new InternetAddress(nick + &quot; &amp;lt;&quot; + sender.getUsername() + &quot;&amp;gt;&quot;); 
mailMessage.setFrom(from);

// 设置邮件接收者
Address to = new InternetAddress(receiver);
mailMessage.setRecipient(Message.RecipientType.TO, to);  

// 设置邮件主题
mailMessage.setSubject(subject);

// 设置发送时间
mailMessage.setSentDate(new Date());

// 设置邮件内容
Multipart mainPart = new MimeMultipart();
// 内容是可以包含html
BodyPart html = new MimeBodyPart();
html.setContent(getContent(template, data), &quot;text/html; charset=utf-8&quot;);
mainPart.addBodyPart(html);
mailMessage.setContent(mainPart);

// 发送邮件  
Transport.send(mailMessage);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;3、测试&lt;/h2&gt;
&lt;p&gt;利用邮件发送的工具类测试将邮件发送出去：&lt;/p&gt;
&lt;p&gt;首先准备需要发送的邮件模板：test.html&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;测试邮件&amp;lt;/title&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;/head&amp;gt;
    
    &amp;lt;body&amp;gt;
        &amp;lt;h2&amp;gt;${name}&amp;lt;/h2&amp;gt;
        &amp;lt;div&amp;gt;${description}&amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中模板中放置了2个占位符，分别是${name}和${description}&lt;/p&gt;
&lt;p&gt;构建测试例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 配置邮件发送信息
SenderConfig sender = new SenderConfig();
sender.setNickname(&quot;架构与我&quot;);
// 改成自己的邮件帐号
sender.setUsername(&quot;xxx@163.com&quot;);
// 改成自己的邮件密码
sender.setPassword(&quot;xxx&quot;);
sender.setSmtpHost(&quot;smtp.163.com&quot;);
sender.setSmtpPort(&quot;25&quot;);
sender.setSsl(false);

// 获取邮件模板
File tpl = new File(&quot;src/test/resources/test.html&quot;);
StringBuilder builder = new StringBuilder();
try (BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(tpl), &quot;utf-8&quot;));) {
    String line = null;
    while ((line = reader.readLine()) != null) {
        builder.append(line);
    }
}

// 测试数据
Map&amp;lt;String, Object&amp;gt; data = new HashMap&amp;lt;String, Object&amp;gt;();
data.put(&quot;name&quot;, &quot;架构与我&quot;);
data.put(&quot;description&quot;, &quot;专注大数据、微服务架构、高并发高吞吐量大型网站、移动开发。&quot;);

// 测试发送邮件
// 改成自己的接收邮件地址
MailHelper.send(sender, &quot;xxx@qq.com&quot;, &quot;来自架构与我的邮件&quot;, builder.toString(), data);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发送成功后，可以看到接收邮箱的内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190403131800693-158994678.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该邮件昵称和主题都是按我们的设置显示出来了，打开邮件内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190403131754510-1923624720.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到模板当中占位符内容也替换成了我们设置的数据。&lt;/p&gt;
&lt;h2 id=&quot;关注我&quot;&gt;关注我&lt;/h2&gt;
&lt;p&gt;以你最方便的方式关注我：&lt;br/&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201904/840503-20190403131743581-45544223.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 03 Apr 2019 05:18:00 +0000</pubDate>
<dc:creator>架构与我</dc:creator>
<og:description>基于JavaMail开发邮件发送器工具类 在开发当中肯定会碰到利用Java调用邮件服务器的服务发送邮件的情况，比如账号激活、找回密码等功能。本人之前也碰到多次这样需求，为此特意将功能封装成一个简单易用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atcloud/p/10648202.html</dc:identifier>
</item>
</channel>
</rss>