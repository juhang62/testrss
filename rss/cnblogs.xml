<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>十分钟脑图加说明，搞定系统分析师的绝对核心-需求工程 - 血夜之末</title>
<link>http://www.cnblogs.com/Tiancheng-Duan/p/12799806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tiancheng-Duan/p/12799806.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;分析师系列，我已经很久没有写了。&lt;br/&gt;因为系统分析师的考试内容与系统架构设计师的考试内容有许多重合部分。所以，我在&lt;a href=&quot;https://www.cnblogs.com/Tiancheng-Duan/p/11850898.html&quot;&gt;系统分析师-软件水平考试（高级）-开篇&lt;/a&gt;着重描述了两者的区别，就没有花费太多时间在这方面了。&lt;/p&gt;
&lt;p&gt;然后最近有好几位私信我，向我询问系统分析师的相关问题。所以我打算将之前有关系统分析师的总结分享出来，并加上这一年来自己的一些实践思考。&lt;/p&gt;
&lt;p&gt;之前的系统架构设计师部分，已经有了需求相关的理论总结-&lt;a href=&quot;https://www.cnblogs.com/Tiancheng-Duan/p/9952050.html&quot;&gt;系统架构设计师-软件水平考试（高级）-理论-需求&lt;/a&gt;。但是一方面当时总结得有些零碎，另一方面系统分析师的需求部分更为全面与体系。所以这次分享的是有关系统分析师的需求部分。&lt;/p&gt;
&lt;h2 id=&quot;xmind&quot;&gt;XMIND&lt;/h2&gt;
&lt;p&gt;老规矩，直接上Xmind。干脆利落，不藏着掖着。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200428211718687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2N1cmVraW5n,size_16,color_FFFFFF,t_70&quot; alt=&quot;系统分析师-需求工程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片一定是清晰的。如果看不清晰，说明显示器分辨率不够。请下载图片，或在新页面单独打开图片，便于放大。&lt;/p&gt;
&lt;p&gt;上述图片的UML部分没有展开，是由于这部分内容是比较大的。之后有机会，我会单开一章，来专门谈论这点。如果大家比较迫切的话，可以给我留言，那我会将该文章的优先级提高。&lt;/p&gt;
&lt;h2 id=&quot;补充&quot;&gt;补充&lt;/h2&gt;
&lt;p&gt;如果看了之前架构师的需求博客，会发现这次的需求博客有这样三个优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更加体系化：将原本零散的几个部分，有机组成了一个整体。&lt;/li&gt;
&lt;li&gt;无效剔除：将原来不再考察，日常也用不到的软系统方法等剔除。&lt;/li&gt;
&lt;li&gt;更加丰富：内容方面更加丰富，完善了需求定义，需求验证，需求管理等内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外，内容的多寡，较为合适地体现了考察的力度。&lt;/p&gt;
&lt;p&gt;在实践中，需求分析是系统分析师的核心之一。系统分析师的重心倾向于业务的分析模型的建立。而架构师的重心倾向于系统的设计模型。分析模型与设计模型的关联性与差别，我会在别的博客中论述。不过这里可以给大家推荐一本书籍-《系统分析与设计方法》。&lt;/p&gt;
&lt;p&gt;这个时候，大家可能会比较好奇什么是分析模型。其实这里针对的分析模型，有好几种解释。除了考试中最关心的需求分析模型外，还有业务分析模型。分析模型的优劣，决定了系统的设计模型的上限，甚至决定业务的上限与方向。真正的系统分析师有着如认识论，方法论，管理学，经济等诸多能力的需要。说句白话，系统分析师就是通过信息技术，完成现有生产关系的变革。&lt;/p&gt;
&lt;p&gt;好啦。话题收回来，让我们关注需求这一核心。毕竟如果连需求都整不好，说其他的东西，也不过是镜花水月。&lt;/p&gt;
&lt;p&gt;考试方面，需求工程在客观题中就有着10+'的内容，已经算是核心考察章节了。并且在后续的案例分析中也有着举足轻重的地位，也是常考内容。需求工程在论文中，也是常客，最近五年几乎每年都考。打个比方，需求工程在系统分析师考试中的地位就是架构风格在架构设计师考试中的地位，只是分值比例没那么夸张。主要是系统分析师的考试内容太多了，稀释了需求工程的分值比例。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;需求工程作为系统分析师的绝对核心，需要大家慎重对待。尤其需求工程还是我们开发生涯中的重要组成，所以，希望大家可以知其然，知其所以然。&lt;/p&gt;
&lt;p&gt;如果实在遇到一些内容暂时无法理解，那么先背下来，也许是一个不错的选择，后面慢慢就懂了。&lt;/p&gt;
&lt;p&gt;至此，系统分析师考试的绝对核心-需求工程，就搞定了。&lt;/p&gt;
&lt;p&gt;愿与诸君共进步。&lt;/p&gt;
</description>
<pubDate>Wed, 29 Apr 2020 00:51:00 +0000</pubDate>
<dc:creator>血夜之末</dc:creator>
<og:description>十分钟脑图加说明，搞定系统分析师的绝对核心 需求工程 前言 分析师系列，我已经很久没有写了。 因为系统分析师的考试内容与系统架构设计师的考试内容有许多重合部分。所以，我在 &amp;quot;系统分析师 软件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Tiancheng-Duan/p/12799806.html</dc:identifier>
</item>
<item>
<title>python工业互联网监控项目实战5—Collector到opcua服务 - wuch</title>
<link>http://www.cnblogs.com/haozi0804/p/12785800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haozi0804/p/12785800.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　本小节演示项目是如何从连接器到获取&lt;/span&gt;Tank4C9&lt;span&gt;服务上的设备对象的值，并通过&lt;/span&gt;&lt;span&gt;Connector&lt;/span&gt;&lt;span&gt;服务的&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;返回给&lt;/span&gt;&lt;span&gt;UI&lt;/span&gt;&lt;span&gt;端请求的&lt;/span&gt;。&lt;span&gt;另外，实际项目中考虑&lt;/span&gt;websocket&lt;span&gt;中间可能因为网络通信等原因出现中断情况，我们增加一个“心跳”设计来定时发送连接请求，确保出现冲断的情况下，能够重新连接到服务端&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;1. &lt;strong&gt;OPCUA-Client&lt;span&gt;读取&lt;/span&gt;&lt;span&gt;OPCUA&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;值&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt; &lt;span&gt;　　现在重构&lt;/span&gt;Connector APP views&lt;span&gt;文件里的&lt;/span&gt;&lt;span&gt;pushCollectorData&lt;/span&gt;&lt;span&gt;函数，通过引入&lt;/span&gt;OPCUA-Client&lt;span&gt;来读取&lt;/span&gt;&lt;span&gt;OPCUA&lt;/span&gt;&lt;span&gt;服务端的&lt;/span&gt;&lt;span&gt;Tag&lt;/span&gt;&lt;span&gt;值，代码如下：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.shortcuts &lt;span&gt;import&lt;/span&gt;&lt;span&gt; render
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.http &lt;span&gt;import&lt;/span&gt;&lt;span&gt; HttpResponse
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; dwebsocket.decorators &lt;span&gt;import&lt;/span&gt;&lt;span&gt; accept_websocket
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; opcua &lt;span&gt;import&lt;/span&gt; Client &lt;span&gt;#&lt;/span&gt;&lt;span&gt;引入 opcua-client&lt;/span&gt;
&lt;span&gt;@accept_websocket   
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; pushCollectorData(request):

    tank4C9&lt;/span&gt;=&lt;span&gt;{            
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeviceId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeviceName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1#反应罐&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设备运行状态&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;OverheadFlow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:0 ,&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'顶流量',&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ButtomsFlow&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;#&lt;/span&gt;&lt;span&gt;'低流量'&lt;/span&gt;
        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Power&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 0, &lt;span&gt;#&lt;/span&gt;&lt;span&gt;功率&lt;/span&gt;
&lt;span&gt;    }
    Collector&lt;/span&gt;=&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CollectorId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CollectorName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1#采集器&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeviceList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:[tank4C9],
            } 
    Collector&lt;/span&gt;=&lt;span&gt;{
         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CollectorId&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 1&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CollectorName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1#采集器&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Status&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: 0,
         &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;DeviceList&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:[tank4C9],
         }  

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; request.is_websocket():
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建opcua-client&lt;/span&gt;
        client = Client(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;opc.tcp://localhost:4840/freeopcua/server/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) 
        client.connect() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;连接服务器&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:  

                root &lt;/span&gt;= client.get_root_node() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取OPCUA服务根节点&lt;/span&gt;
                &lt;span&gt;#&lt;/span&gt;&lt;span&gt;获取Tank4C9子节点的所有变量&lt;/span&gt;
                items = root.get_child([&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0:Objects&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2:Tank4C9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]).get_children() 
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; items:
                    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;给字典赋读取opcua服务tag当前值&lt;/span&gt;
                    tank4C9[item.get_display_name().Text]=&lt;span&gt;item.get_value() 

                request.websocket.send(\
                    json.dumps( {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rows&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[Collector],&lt;span&gt;'&lt;/span&gt;&lt;span&gt;total&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:1&lt;span&gt;}))
                time.sleep(&lt;/span&gt;2&lt;span&gt;)
 
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;:
            client.disconnect()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;　　代码改动并不大，数据获取从原来的&lt;/span&gt;OPC DA&lt;span&gt;切换到了&lt;/span&gt;&lt;span&gt;OPC UA&lt;/span&gt;&lt;span&gt;组件，从前面的章节起笔者就奉行迭代推进的思路，好的代码结构（组织）会让后面的升级重构非常的方便，实际项目中减少很多工作量。&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;2. &lt;strong&gt;运行调试&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　首先，我们在集成开发环境&lt;/span&gt;VS Community 2019 选择CollectorSvr项目，右键在python环境启动运行CollectorSvr项目，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202004/67400-20200427131359745-1688814373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　然后，F5调试默认服务端项目Tank4C9Svr。我们即可通过浏览器访问监控页面&lt;/p&gt;
&lt;p&gt;　　url：&lt;a href=&quot;http://127.0.0.1:8090/tank4C9/&quot;&gt;&lt;span&gt;http://127.0.0.1:8090/tank4C9/&lt;/span&gt;&lt;/a&gt; 运行效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202004/67400-20200427131605426-461347011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 3. &lt;strong&gt;客户端心跳&lt;/strong&gt;&lt;strong&gt;机制&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　本章节我们在&lt;/span&gt;UI&lt;span&gt;端增加一个与服务端心跳检测函数，当&lt;/span&gt;&lt;span&gt;websocket&lt;/span&gt;&lt;span&gt;网络通信故障或其它原因不能正常传输数据时，&lt;/span&gt;&lt;span&gt;UI&lt;/span&gt;&lt;span&gt;端能够重新创建连接来确保系统可靠性的手段。&lt;/span&gt;&lt;span&gt;UI&lt;/span&gt;&lt;span&gt;端保存一个最后更新时间的变量，心跳检测时查看当前时间&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;最后更新时间大于&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;&lt;span&gt;秒时，就关闭当前连接重新创建一个新得&lt;/span&gt;&lt;span&gt;websocket&lt;/span&gt;&lt;span&gt;连接获取数据，这样就确保了&lt;/span&gt;&lt;span&gt;websocket&lt;/span&gt;&lt;span&gt;出现其它原因断开后，保证能够自动重新连接并刷新数据得机制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　更多得看代码吧如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JQuery 代码入口&lt;/span&gt;
        $(document).ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
            getData()
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置心跳检测时间&lt;/span&gt;
            setInterval(&quot;heartbeat(window.ws,window.lastUpdateTime)&quot;,30000&lt;span&gt;);

 
        });


        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; heartbeat(ws,lastUpdateTime) {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; time = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((time.getTime() - lastUpdateTime &amp;gt; 30000&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后更新时间与当前检查时间大于30秒，关闭连接重新创建并获取数据&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(ws) 
                    ws.close();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭连接&lt;/span&gt;
&lt;span&gt;
                getData();
            } 
        }



        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getData() {
           &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;WebSocket&quot; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; window) {
               &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;连接server--TagCurValue&lt;/span&gt;
&lt;span&gt;
                window.ws &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; WebSocket(&quot;ws://127.0.0.1:8090/pushCollectorData/&quot;&lt;span&gt;);
                window.lastUpdateTime &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime()
                ws.onmessage &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (evt) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最后更新时间戳&lt;/span&gt;
                    lastUpdateTime = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date().getTime()
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 接收数据&lt;/span&gt;
                    d =&lt;span&gt; JSON.parse(evt.data);
                    collector &lt;/span&gt;= d.rows[0&lt;span&gt;]
                    tank4C9 &lt;/span&gt;= collector.DeviceList[0&lt;span&gt;]

                    $(&lt;/span&gt;&quot;#OverheadFlow&quot;&lt;span&gt;).html(tank4C9.OverheadFlow);
                    $(&lt;/span&gt;&quot;#ButtomsFlow&quot;&lt;span&gt;).html(tank4C9.ButtomsFlow);
                    $(&lt;/span&gt;&quot;#Power&quot;&lt;span&gt;).html(tank4C9.Power);


                };

            } 
    }

    &lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4. &lt;strong&gt;小结&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　本章节代码的改动不大，一个改动是切换到了OPC UA，另一个是增加了心跳检测函数，这个两个看似不大的改动，尤其心跳函数在实际项目中作用非常大，工业监控画面，如果出现长时间的数据不刷新（仅仅是插拔了一下电脑网线）画面不能自动连接到服务端刷新数据，现场管理员就看不到数据的变化，画面就不能真实的反应设备运行情况，这个在实际项目中是不能被客户接受的。OPC UA 的升级让体系可以逐步演进到新的架构下，却不会导致客户端任何调整，这个就是好的分层架构的优势，早些年笔者经历的很多项目都是从后台改到前台，并测试发布才能更新功能。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;5.后记&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　python开发工业监控系列文章到本章节就告以段落了，这个系列带着大家从技术原型的探索到项目实战，从一个简单监控页面开始一步一步的也演示了项目迭代的实际过程，笔者的项目最佳实践准则：敏捷开发，有一个基本的功能蓝图后，从简设计、开发、迭代、重构、单元测试、集成测试和发布等环环相扣。同时，采用一个好的可繁可简的技术体系对持续改进非常重要，笔者转换python体系以来，越发喜欢上开源社区，互联网开发架构也会给传统企业软件开发领域带来新的机遇，尤其国家大力推进的工业互联网时代，期待python开发生态会带给我们更多的惊喜。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这里的案例&lt;/span&gt;UI&lt;span&gt;比较简单，实际的项目可能还会设计&lt;/span&gt;&lt;span&gt;APP UI&lt;/span&gt;&lt;span&gt;，或者更发杂的&lt;/span&gt;&lt;span&gt;web 3D&lt;/span&gt;&lt;span&gt;界面等，但是总体来说服务端的架构思路是不变的，开发设计的分层（逻辑分层）是好的技术架构的重要体现。本序列文章我们更多的着重在监控界面上，没有交代业务逻辑和模型层面的知识，下一个系列笔者计划更多的着重在业务逻辑和模型层。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 29 Apr 2020 00:40:00 +0000</pubDate>
<dc:creator>wuch</dc:creator>
<og:description>本小节演示项目是如何从连接器到获取Tank4C9服务上的设备对象的值，并通过Connector服务的url返回给UI端请求的。另外，实际项目中考虑websocket中间可能因为网络通信等原因出现中断情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haozi0804/p/12785800.html</dc:identifier>
</item>
<item>
<title>你离黑客的距离，就差这20个神器了 - 轩辕之风</title>
<link>http://www.cnblogs.com/xuanyuan/p/12799773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuanyuan/p/12799773.html</guid>
<description>&lt;p&gt;&lt;code&gt;郑重声明：本文仅限技术交流，不得用于从事非法活动&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在不少电影电视剧中，主角的身边都有这么一位电脑高手：他们分分钟可以黑进反派的网络，攻破安全防线，破解口令密码，拿到重要文件。他们的电脑屏幕上都是一些看不懂的图形和数字，你能看懂的就只有那个进度条，伴随着紧张的BGM，慢慢的向100%靠近······&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/fc3b62b5-7dad-4dd3-aba6-c689dbe747cb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的场景和套路是不是很眼熟？&lt;/p&gt;
&lt;p&gt;影视作品中的黑客当然有夸张和戏剧化的表现，不过，现实世界中的黑客也有一套他们的工具库，轩辕君梳理了常用的20个工具。有了他们，你也能化身电脑高手，成为那个瞩目的焦点。&lt;/p&gt;
&lt;p&gt;以下分系统终端侧和网络侧两个方向，分别介绍10款常用的黑客工具。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- OllyDbg
- WinDbg
- IDA
- APIMonitor
- PCHunter
- ProcExp
- ProcMon
- dex2jar
- jd-gui
- Mimikatz

- WireShark
- Fiddler
- nmap
- netcat
- Nessus
- SQLMap
- hydra
- shodan
- zoomeye
- metasploit
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;系统终端&quot;&gt;系统终端&lt;/h2&gt;
&lt;p&gt;系统终端侧的工具主要用于程序逆向分析、破解等用途。&lt;/p&gt;
&lt;h3 id=&quot;ollydbg&quot;&gt;OllyDbg&lt;/h3&gt;
&lt;p&gt;调试工具，简称OD，其名头在圈子里也算得上是顶流了。其黑客风的交互界面，丰富便捷的调试功能成为软件破解爱好者的首选利器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/f4978035-6b43-4b99-beb7-c04bdd1e492a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;windbg&quot;&gt;WinDbg&lt;/h3&gt;
&lt;p&gt;也是一款调试工具，微软出品，必属精品？与上面的OD不同，它的界面就要朴素无华许多（当然如果你愿意折腾，比如像我，也能自定义配置出黑客风的界面）。WinDbg没有浮华的外表，但有强大的内核。自带了一套强大的调试命令，习惯了GUI调试工具的朋友初期可能不习惯，但时间久了之后绝对爱不释手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/4f0b4b21-f522-4bd9-ac72-f43085e898f5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WinDbg最特色的是结合VMWare虚拟机可以进行内核驱动程序调试，也能用于学习操作系统内核，是驱动玩家必备神器。&lt;/p&gt;
&lt;h3 id=&quot;ida&quot;&gt;IDA&lt;/h3&gt;
&lt;p&gt;IDA绝对是圈子中顶流中的顶流，强大的反汇编引擎和源代码级的函数构建插件，是程序逆向分析必不可少的强大工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/9c3cbfcb-22ef-47db-afd1-57821649c621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;函数调用执行流图形模式：&lt;br/&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a542cf6a-5873-40b7-b17e-bf9b8cdf47b2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;支持Windows、Linux、OSX等多操作系统以及x86、x64、ARM甚至Java字节码等多种指令集的分析。&lt;/p&gt;
&lt;p&gt;源码级自动构建：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/d2fba85d-0029-499c-97ba-c712a00abee5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;apimonitor&quot;&gt;APIMonitor&lt;/h3&gt;
&lt;p&gt;这款工具的知名度比起上面几位要低调不少，这是一款用来监控目标进程的函数调用情况的工具，你可以监控任意你想要监控的进程，查看他们调用了哪些关键系统函数，以及对应的参数和返回值，有了它，目标程序的一切活动尽在掌握。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/0d37b643-8237-4803-93bd-36bd24ff8232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;procmon&quot;&gt;ProcMon&lt;/h3&gt;
&lt;p&gt;APIMonitor是指定监控对象进行监控，那如果监控目标不明确，想找出干坏事的进程该怎么办呢？&lt;/p&gt;
&lt;p&gt;ProcMon则能派上用场，它通过驱动程序加载到操作系统内核，实现对全系统的整体监控，所有进程的行为都逃不过它的法眼（这话有点绝对，还是有办法逃过的），是检测主机活动的常用工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/997a27ad-7ddc-4ea8-980b-e21e88a4bad2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;procexp&quot;&gt;ProcExp&lt;/h3&gt;
&lt;p&gt;Windows自带的任务管理器功能太弱，这是一款全新增强版的任务管理器，全称ProcessExplorer。和上面的ProcMon师出同门，是兄弟软件，常常配套使用。&lt;/p&gt;
&lt;p&gt;它可以帮助你看到系统所有活动进程以及这些进程包含的所有线程、加载的动态库模块，打开的文件，网络连接等等信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/5deb229c-3615-43bb-823e-955fac11770e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;pchunter&quot;&gt;PCHunter&lt;/h3&gt;
&lt;p&gt;这是一款国产软件，其前身是Xuetur。是一款Windows操作系统上监控系统安全的瑞士军刀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/51ae4055-23ec-4d7e-baa3-566c3674c24d.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/7c60b158-92d7-451f-9166-86bd9251d7a8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PCHunter可以帮助你杀掉任务管理器干不掉的进程，查看隐藏的进程、驱动程序，查看有没有键盘记录器等木马程序，有没有恶意程序在篡改内核代码等等。&lt;/p&gt;
&lt;h3 id=&quot;dex2jar&quot;&gt;dex2jar&lt;/h3&gt;
&lt;p&gt;这是一款用于Android平台程序逆向分析的工具，从名字中可以看出，通过它，可以将Android的APK包中的可执行程序dex文件转换成jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/1e3cd17a-e9f7-4ded-afe9-f9c8ba568542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;jd-gui&quot;&gt;jd-gui&lt;/h3&gt;
&lt;p&gt;转换成Jar包之后，怎么看Java源代码呢，接下来是jd-gui出场的时刻，通过它，实现Java字节码的反编译到源代码，其可读性还是非常高的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/80879375-bcd8-4ba6-80f4-695529349a8d.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;mimikatz&quot;&gt;Mimikatz&lt;/h3&gt;
&lt;p&gt;当你的电脑被黑客攻破以后，为了以后能经常“光顾”，他们通常会获取你的用户名与密码，用户名很容易获取，但电脑密码呢？&lt;/p&gt;
&lt;p&gt;国外的牛人开发的这款&lt;code&gt;Mimikatz&lt;/code&gt;就可以做到，在你的电脑上执行后，将会在电脑内存中找出你的密码，是不是很可怕？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/b777308c-bea1-415d-8060-9b365be0dfcd.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;网络&quot;&gt;网络&lt;/h2&gt;
&lt;p&gt;网络部分的工具就更厉害了，接入网络意味着你的活动半径迈出了自己的电脑，可以去到更为广阔的空间。&lt;/p&gt;
&lt;h3 id=&quot;wireshark&quot;&gt;WireShark&lt;/h3&gt;
&lt;p&gt;WireShark的大名应该很多人都听过，即便在非安全行业，作为一个普通的后端开发工程师，掌握网络数据抓包也是一项基础技能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/b68db53f-5b0f-43d4-b127-18eade963aef.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;WireShark就是一款强大的抓包工具，支持你能想到的几乎所有通信协议的字段解码。通过它，网络中流淌的数据将无所遁形，一目了然。&lt;/p&gt;
&lt;h3 id=&quot;fiddler&quot;&gt;Fiddler&lt;/h3&gt;
&lt;p&gt;Fiddler同样也是一款抓包工具，与WireShark这样的纯抓包分析不同，Fiddler更偏向基于HTTP协议的Web流量。对HTTP协议的解码支持做得更好，在交互上也更易用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/81d28eda-7f36-486d-97f4-6681ccfe3daa.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，Fiddler还有一项重要的功能就是可以搭建代理，常用于分析加密的HTTPS流量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/0a26a9d1-e1b8-4626-a5c6-bc201bc15ee6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;nmap&quot;&gt;nmap&lt;/h3&gt;
&lt;p&gt;网络渗透之前很重要的一环就是要进行信息搜集，了解渗透目标开启了什么服务，软件是什么版本，拿到了这些信息才能制定接下来选择什么样的漏洞进行攻击。&lt;/p&gt;
&lt;p&gt;nmap就是这样一款知名的网络扫描工具，在Linux下以命令行形式调用，另外还有一个可视化界面的zenmap，通过发起网络数据包探测，分析得出目标的信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a5fdc1ab-a4f4-4f32-a326-ff4cabdddd33.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;netcat&quot;&gt;netcat&lt;/h3&gt;
&lt;p&gt;netcat号称网络工具中的瑞士军刀，功能强大，是网络渗透最最常用的工具&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/fb4aa0d1-1913-40a4-95c7-dd90a1b6f125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;netcat命令简写nc，通过它，你可以：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;端口扫描&lt;/li&gt;
&lt;li&gt;网络通信&lt;/li&gt;
&lt;li&gt;文件传输&lt;/li&gt;
&lt;li&gt;加密传输&lt;/li&gt;
&lt;li&gt;硬盘克隆&lt;/li&gt;
&lt;li&gt;远程控制&lt;/li&gt;
&lt;li&gt;······&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，瑞士军刀，绝不会让你失望，是你工（zhuang）作（bi）的极好帮手！&lt;/p&gt;
&lt;h3 id=&quot;nessus&quot;&gt;Nessus&lt;/h3&gt;
&lt;p&gt;Nessus号称是世界上最流行的漏洞扫描工具，内置丰富的漏洞特征库，图形化的界面降低了操作难度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/d20269ea-a9ca-4683-8b02-adcbe83c0b98.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扫描结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/5f737b1a-29f0-4e5a-bd54-35e807abb0e4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;sqlmap&quot;&gt;SQLMap&lt;/h3&gt;
&lt;p&gt;SQL注入是web服务器程序最常出现的漏洞，发起SQL注入攻击的工具也非常多。SQLMap就是其中一款，其丰富的参数提供了强大的注入能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/7929744e-95a4-495a-b121-a1cdf88eeba6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过由于其命令行操作，不如一些傻瓜式的可视化工具来的容易上手。&lt;/p&gt;
&lt;h3 id=&quot;hydra&quot;&gt;hydra&lt;/h3&gt;
&lt;p&gt;Hydra，这个名字应该很眼熟吧，没错，它就是漫威宇宙中的九头蛇。名字听上去就很霸气，这是一款自动化爆破的工具，支持众多协议，包括&lt;code&gt;POP3，SMB，RDP，SSH，FTP，POP3，Telnet，MYSQL&lt;/code&gt;等等服务，一般的弱口令，Hydra都能轻松拿下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/34c02669-451d-47b1-8272-454837537449.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;metasploit&quot;&gt;metasploit&lt;/h3&gt;
&lt;p&gt;metasploit是网络渗透使用最多最广的工具。说它是工具某种意义上来说不太准确，它更像是一个平台，一个车间，一个提供了众多工具的操作空间，通过它，你可以完成涵盖信息搜集、探测扫描、漏洞攻击、数据传输等几乎完整的黑客攻击过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/6be3d0e1-4980-44ea-a91b-27267a7e1807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/772833b3-3c49-4237-8d61-2e40c53be687.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/6ac885ee-ee89-440b-968b-8e1f659c67fa.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;shodan&quot;&gt;shodan&lt;/h3&gt;
&lt;p&gt;这是一款号称互联网上最可怕的“搜索引擎”。注意它和百度、谷歌搜索普通互联网内容不同，它搜索的目标是计算机、手机、摄像头、打印机等等看得见摸得着的网络设备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/3fb4c673-4eee-402a-9b2f-f6af415ea617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随便搜一个H3C结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/6c522d7b-d9a0-40dd-a858-96fbf73ee3f5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再随便点击一个IP结果进去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a453e74d-2956-4c93-a6f7-4e0e74ad8862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;shodan的中文译名是“撒旦”，不断的在爬取整个互联网的信息，进而分析接入网络的这些设备。&lt;/p&gt;
&lt;h3 id=&quot;zoomeye&quot;&gt;zoomeye&lt;/h3&gt;
&lt;p&gt;借鉴于shodan的思路，国内的知道创宇公司也做了一个类似的产品：&lt;code&gt;钟馗之眼&lt;/code&gt;，英文名称&lt;code&gt;zoomeye&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/26896e4a-2265-4607-add1-c24bcd6f35fd.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在zoomeye，你可以搜索任意一个IP地址，网址或者别的信息，它将告诉你这个IP背后的信息：这个IP在世界上哪个地方？拥有这个IP的是一台什么样的主机？&lt;/p&gt;
&lt;p&gt;我们拿Github举例，看看GitHub服务器的分布情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a1de283f-a9d9-4c69-b120-f0b0ecbbca23.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看得出来，服务器主要是在美国，选择第一个点进去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/b6841eb3-f49f-4471-9ae9-140ba2c0eb6f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;地理位置、开放的端口服务都告诉你了。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;工具都是好工具，但是切不可用于不正当用途，尤其是现在网络安全法的出台，再也不能像以前随随便便拿起工具就东扫西扫，一不小心就是面向监狱编程了。&lt;/p&gt;
&lt;h2 id=&quot;往期热门回顾&quot;&gt;往期热门回顾&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/h0FqX9AZByfpgUZrsRVTWg&quot;&gt;哈希表哪家强？几大编程语言吵起来了！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/v6nc9aIBY_R1S6ToPzj5Qg&quot;&gt;内核地址空间大冒险4:线程切换&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XrtH9-Eo7pzJu-Fzt89voQ&quot;&gt;震撼！全网第一张源码分析全景图揭秘Nginx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/gZPxqZzY2rnngxvvzexWTw&quot;&gt;一个整数＋1引发的灾难&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/V7wBdl-5W4ehTAnACQFjGQ&quot;&gt;一网打尽！每个程序猿都该了解的黑客技术大汇总&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Bb2ugXYPR6r11QaGKbNBSw&quot;&gt;看过无数Java GC文章，这5个问题你也未必知道！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/xp2S4_3UQTZ0TOIlVqM8uw&quot;&gt;一个Java对象的回忆录：垃圾回收&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/lxpHhHVIh6DktoHzrRLaKA&quot;&gt;谁动了你的HTTPS流量？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/7gM31s4-hTJTprJnxsHgEA&quot;&gt;路由器里的广告秘密&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/suzicCzb2g5b8NN71S5Ngw&quot;&gt;一个HTTP数据包的奇幻之旅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/-ggUa3aWkjjHjr9VwQL9TQ&quot;&gt;我是一个流氓软件线程&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;
&lt;h3 id=&quot;扫码关注，更多精彩&quot;&gt;扫码关注，更多精彩&lt;/h3&gt;
&lt;/center&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/5de7751a-9e38-4718-994a-6136f7804ae5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Apr 2020 00:40:00 +0000</pubDate>
<dc:creator>轩辕之风</dc:creator>
<og:description>`郑重声明：本文仅限技术交流，不得用于从事非法活动` 在不少电影电视剧中，主角的身边都有这么一位电脑高手：他们分分钟可以黑进反派的网络，攻破安全防线，破解口令密码，拿到重要文件。他们的电脑屏幕上都是一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuanyuan/p/12799773.html</dc:identifier>
</item>
<item>
<title>五分钟学会Python装饰器，看完面试不再慌 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12799742.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12799742.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;Python专题的第12篇&lt;/strong&gt;文章，我们来看看Python装饰器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;一段囧事&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;差不多五年前面试的时候，我就领教过它的重要性。那时候我Python刚刚初学乍练，看完了&lt;strong&gt;廖雪峰大神&lt;/strong&gt;的博客，就去面试了。我应聘的并不是一个Python的开发岗位，但是JD当中写到了需要熟悉Python。我看网上的面经说到Python经常会问装饰器，我当时想的是装饰器我已经看过了，应该问题不大……&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没想到面试的时候还真的问到了，面试官问我Python当中的装饰器是什么。由于紧张和遗忘，我支支吾吾了半天也没答上来。我隐约听到了电话那头的一声叹息……&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时隔多年，我已经不记得那是一家什么公司了（估计规模也不大），但&lt;strong&gt;装饰器很重要&lt;/strong&gt;这个事情给我深深打下了烙印。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;装饰器本质&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如今如果再有面试官问我Python中的装饰器是什么，我一句话就能给回答了，倒不是我装逼，实际上也的确只需要一句话。Python中的装饰器，&lt;strong&gt;本质上就是一个高阶函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能不太清楚高阶函数的定义，没关系，我们可以类比一下。在数学当中高阶导数，比如二次导数，表示导数的导数。那么这里高阶函数自然就是&lt;strong&gt;函数的函数&lt;/strong&gt;，结合我们之前介绍过的函数式编程，也就是说是一个返回值是函数的函数。但是这个定义是充分不必要的，也就是说装饰器是高阶函数，但是&lt;strong&gt;高阶函数并不都是装饰器&lt;/strong&gt;。装饰器是高阶函数一种特殊的用法。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;任意参数&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍装饰器的具体使用之前，我们先来了解和熟悉一下Python当中的任意参数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python当中支持任意参数，它写成*args, **kw。表示的含义是接受&lt;strong&gt;任何形式的参数&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，比如我们定义一个函数：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a, b, c=&lt;span class=&quot;hljs-string&quot;&gt;'3'&lt;/span&gt;, d=&lt;span class=&quot;hljs-string&quot;&gt;'f'&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;print(a, b, c, d)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以这样调用：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;args = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;br/&gt;dt = {&lt;span class=&quot;hljs-string&quot;&gt;'c'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'d'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;}&lt;p&gt;exp(*args, **dt)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后输出的结果是1， 3， 4， 5。也就是说我们用一个list和dict可以表示任何参数。因为Python当中规定&lt;strong&gt;必选参数一定写在可选参数的前面&lt;/strong&gt;，而必选参数是可以不用加上名称标识的，也就是可以不用写a=1，直接传入1即可。那么这些没有名称标识的必选参数就可以用一个list来表示，而可选参数是必须要加上名称标识的，这些参数可以用dict来表示，这两者相加可以表示任何形式的参数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意我们传入list和dict的时候前面加上了*和**，它表示&lt;strong&gt;将list和dict当中的所有值展开&lt;/strong&gt;。如果不加的话，list和dict会被当成是整体传入。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果一个函数写成这样，它表示可以接受任何形式的参数。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*args, **kw)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;pass&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;定义装饰器&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明白了任意参数的写法之后，装饰器就不难了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然我们可以用*args, **kw接受任何参数。并且Python当中支持一个函数作为参数传入另外一个函数，如果我们把函数和这个函数的所有参数全部传入另外一个函数，那么不就可以实现&lt;strong&gt;代理&lt;/strong&gt;了吗？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是刚才的例子，我们额外增加一个函数：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;9&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a, b, c=&lt;span class=&quot;hljs-string&quot;&gt;'3'&lt;/span&gt;, d=&lt;span class=&quot;hljs-string&quot;&gt;'f'&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;print(a, b, c, d)&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;agent&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func, *args, **kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;func(*args, **kwargs)&lt;/p&gt;&lt;p&gt;args = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;]&lt;br/&gt;dt = {&lt;span class=&quot;hljs-string&quot;&gt;'b'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'c'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'d'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;agent(exp, *args, **dt)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装饰器的本质其实就是这样一个&lt;strong&gt;agent函数&lt;/strong&gt;，但是如果使用的时候需要手动传入会非常麻烦，使用起来不太方便。所以Python当中提供了特定的库，我们可以让装饰器&lt;strong&gt;以注解的方式使用&lt;/strong&gt;，大大简化操作：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;11.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;17&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; wraps&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapexp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*args, **kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'this is a wrapper'&lt;/span&gt;)&lt;br/&gt;func(*args, **kwargs)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; wrapper&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@wrapexp&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a, b, c=&lt;span class=&quot;hljs-string&quot;&gt;'3'&lt;/span&gt;, d=&lt;span class=&quot;hljs-string&quot;&gt;'f'&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;print(a, b, c, d)&lt;/p&gt;&lt;p&gt;args = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;br/&gt;dt = {&lt;span class=&quot;hljs-string&quot;&gt;'c'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'d'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;exp(*args, **dt)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子当中，我们定义了一个wrapexp的装饰器。我们在其中的wrapper方法当中实现了装饰器的逻辑，&lt;strong&gt;wrapexp当中传入的参数func是一个函数&lt;/strong&gt;，wrapper当中的参数则是func的参数。所以我们在wrapper当中调用func(*args, **kw)，就是调用打上了这个注解的函数本身。比如在这个例子当中，我们没有做任何事情，只是在原样调用之前多输出了一行’this is a wrapper'，表示我们的装饰器调用成功了。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;装饰器用途&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们理解了装饰器的基本使用方法之后，自然而然地会问一个天然的问题，学会了它&lt;strong&gt;究竟有什么用呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你从上面的例子当中没有领会到装饰器的强大，不如让我用一个例子再来暗示一下。比如说你是一个程序员，辛辛苦苦做出了一个功能，写了好几千行代码，&lt;strong&gt;上百个函数&lt;/strong&gt;，终于通过了审核上线了。这个时候，你的产品经理找到了你说，经过分析我们发现上线的功能运行速度不达标，经常有请求超时，你能不能计算一下每个函数运行的耗时，方便我们找到需要优化的地方？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个非常合理的请求，但想想看你写了上百个函数，如果每一个函数都要手动添加时间计算，这要写多少代码？万一哪个函数不小心改错了，你又得一一检查，并且如果要求严格的话你还得为每一个函数专门写一个单元测试……&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想，正常的程序员应该都会抗拒这个需求。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是有了装饰器就很简单了，我们可以实现一个计算函数耗时的装饰器，然后我们只需要给每一个函数加上注解就好了。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; wraps&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;timethis&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*args, **kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;start = time.time()&lt;br/&gt;result = func(*args, **kwargs)&lt;br/&gt;end = time.time()&lt;br/&gt;print(func.__name__, end-start)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; wrapper&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是装饰器最大的用途，可以&lt;strong&gt;在不修改函数内部代码的前提下，为它包装一些额外的功能。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;元信息&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们之前说过装饰器的本质是高阶函数，所以我们也可以和高阶函数一样来调用装饰器，比如下面这样：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;7&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;exp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(a, b, c=&lt;span class=&quot;hljs-string&quot;&gt;'3'&lt;/span&gt;, d=&lt;span class=&quot;hljs-string&quot;&gt;'f'&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;print(a, b, c, d)&lt;p&gt;args = [&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;br/&gt;dt = {&lt;span class=&quot;hljs-string&quot;&gt;'c'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;'d'&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;}&lt;/p&gt;&lt;p&gt;f = wrapexp(exp)&lt;br/&gt;f(*args, **dt)&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的方式得到的结果&lt;strong&gt;和使用注解是一样的&lt;/strong&gt;，也就是说我们加上注解的本质其实就是调用装饰器返回一个新的函数。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然和高阶函数是一样的，那么就带来了一个问题，我们使用的其实已经不再是原函数了，而是一个由装饰器返回的新函数，虽然这个函数的功能和原函数一样，但是&lt;strong&gt;一些基础的信息其实已经丢失了。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们可以打印出函数的name来做个实验：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/29/171c3511becf0f41?w=1066&amp;amp;h=320&amp;amp;f=jpeg&amp;amp;s=17721&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常的函数调用__name__返回的都是函数的名称，但是当我们加上了装饰器的注解之后，就会发生变化，同样，我们输出加上了装饰器注解之后的结果：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/29/171c3511e294dbcc?w=996&amp;amp;h=340&amp;amp;f=jpeg&amp;amp;s=18297&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们会发现输出的结果变成了wrapper，这是因为我们实现的装饰器内部的函数叫做wrapper。不仅仅是__name__，函数内部还有很多其他的基本信息，比如记录函数内描述的__doc__，__annotations__等等，这些基本信息被称为是&lt;strong&gt;元信息&lt;/strong&gt;，这些元信息由于我们使用注解发生了丢失。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有什么办法可以保留这些函数的元信息呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实很简单，Python当中为我们&lt;strong&gt;提供了一个专门的装饰器&lt;/strong&gt;用来保留函数的元信息，我们只需要在实现装饰器的wrapper函数当中加上一个注解wraps即可。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapexp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(func)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;    @wraps(func)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(*args, **kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;'this is a wrapper'&lt;/span&gt;)&lt;br/&gt;func(*args, **kwargs)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; wrapper&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加上了这个注解之后，我们再来检查函数的元信息，会发现它和我们预期一致了。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/29/171c3511f288f8f4?w=972&amp;amp;h=334&amp;amp;f=jpeg&amp;amp;s=18025&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了Python中的装饰器之后，再来看之前我们用过的@property, @staticmethod等注解，想必都能明白，它们背后的实现其实也是装饰器。灵活使用装饰器可以大大简化我们的代码，让我们的代码更加规范简洁，还能灵活地实现一些特殊的功能。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装饰器的用法很多，今天介绍的只是其中最基本的，在后续的文章当中，还会继续和大家分享它更多其他的用法。在文章开始的时候我也说了，&lt;strong&gt;装饰器是Python进阶必学的技能之一&lt;/strong&gt;。想要熟练掌握这门语言，灵活运用，看懂大佬的源码，装饰器是必须会的东西。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望大家都能有所收获，原创不易，厚颜求个赞和关注~&lt;/p&gt;
</description>
<pubDate>Wed, 29 Apr 2020 00:27:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是Python专题的第12篇文章，我们来看看Python装饰器。 一段囧事 差不多五年前面试的时候，我就领教过它的重要性。那时候我P</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12799742.html</dc:identifier>
</item>
<item>
<title>非常简单的string驻留池，你对它真的了解吗 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/12799736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/12799736.html</guid>
<description>&lt;p&gt;昨天看群里在讨论C#中的string驻留池，炒的火热，几轮下来理论一堆堆，但是在证据提供上都比较尴尬。虽然这东西很基础，但比较好的回答也不是那么容易，这篇我就以我能力范围之内跟大家分享一下&lt;/p&gt;

&lt;p&gt;开发这么多年，相信大家对‘池’ 这个概念都耳熟能详了，连接池，线程池，对象池，还有这里的驻留池，池的存在就是为了复用为了共享，独乐乐不如众乐乐，毕竟一个字符串的生成和销毁既浪费空间又浪费时间，还不如先养着。&lt;/p&gt;
&lt;h2 id=&quot;1-说说现象&quot;&gt;1. 说说现象&lt;/h2&gt;
&lt;p&gt;通常我们臆想中是这么认为的，定义几个字符串变量，堆上就会分配几个string对象，其实这底层有一种叫驻留池技术可以做到如果两个字符串内容相同，那就在堆上只分配一个string对象，然后将引用地址分配给两个字符串变量，这样就可以大大降低了内存使用，如果用代码表示就是下面这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
        {
            var str1 = &quot;nihao&quot;;
            var str2 = &quot;nihao&quot;;

            var b = string.ReferenceEquals(str1, str2);
            Console.WriteLine(b);
        }

----------- output -----------
True
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2-实现原理&quot;&gt;2. 实现原理&lt;/h2&gt;
&lt;p&gt;那怎么做到的呢？ 其实CLR在运行时调用JIT把你的MSIL代码转成机器代码的时候会发现你的元数据中定义了相同内容的字符串对象，CLR就会把你的字符串放入它私有的的内部字典中，其中key就是字符串内容，value就是分配在堆上的字符串引用地址，这个字典就是所谓的驻留池，如果不是很明白，我来画一张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202004/214741-20200429082439477-100867154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-windbg验证&quot;&gt;3. windbg验证&lt;/h2&gt;
&lt;p&gt;可以用windbg看一下栈中的str1和str2是否都指向了堆上对象的地址。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;~0s -&amp;gt; !clrstack -l 在主线程的线程栈上找到变量str1和str2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; ~0s
ntdll!ZwReadFile+0x14:
00007ff8`fea4aa64 c3              ret
0:000&amp;gt; !clrstack -l
OS Thread Id: 0x1c1c (0)
        Child SP               IP Call Site

000000ac0b7fed00 00007ff889e608e9 *** WARNING: Unable to verify checksum for ConsoleApp2.exe
ConsoleApp2.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp2\Program.cs @ 30]
    LOCALS:
        0x000000ac0b7fed38 = 0x0000024a21f22d48
        0x000000ac0b7fed30 = 0x0000024a21f22d48

000000ac0b7fef48 00007ff8e9396c93 [GCFrame: 000000ac0b7fef48] 

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面代码的 LOCALS 的 &lt;code&gt;0x000000ac0b7fed38 = 0x0000024a21f22d48&lt;/code&gt; 和 &lt;code&gt;0x000000ac0b7fed30 = 0x0000024a21f22d48&lt;/code&gt;可以看到两个局部变量的引用地址都是 &lt;code&gt;0x0000024a21f22d48&lt;/code&gt;，说明指向的都是一个堆对象，接下来再把堆上的内容打出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
0:000&amp;gt; !do 0x0000024a21f22d48
Name:        System.String
MethodTable: 00007ff8e7a959c0
EEClass:     00007ff8e7a72ec0
Size:        36(0x24) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
String:      nihao
Fields:
              MT    Field   Offset                 Type VT     Attr            Value Name
00007ff8e7a985a0  4000281        8         System.Int32  1 instance                5 m_stringLength
00007ff8e7a96838  4000282        c          System.Char  1 instance               6e m_firstChar
00007ff8e7a959c0  4000286       d8        System.String  0   shared           static Empty
                                 &amp;gt;&amp;gt; Domain:Value  0000024a203d41c0:NotInit  &amp;lt;&amp;lt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，果然是System.String对象，这就和我的图是相符的。&lt;/p&gt;
&lt;h2 id=&quot;二-驻留池的验证&quot;&gt;二 驻留池的验证&lt;/h2&gt;
&lt;h3 id=&quot;1-string下的驻留池验证方法&quot;&gt;1. String下的驻留池验证方法&lt;/h3&gt;
&lt;p&gt;很遗憾的是水平有限，由于驻留池既不在堆中也不在栈上，目前还不知道怎么用windbg去打印CLR中驻留池字典内容，不过也可以通过 &lt;code&gt;string.Intern&lt;/code&gt; 去验证。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;        //
        // Summary:
        //     Retrieves the system's reference to the specified System.String.
        //
        // Parameters:
        //   str:
        //     A string to search for in the intern pool.
        //
        // Returns:
        //     The system's reference to str, if it is interned; otherwise, a new reference
        //     to a string with the value of str.
        //
        // Exceptions:
        //   T:System.ArgumentNullException:
        //     str is null.
        [SecuritySafeCritical]
        public static String Intern(String str);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从注释中可以看到，这个方法的意思就是：如果你定义的str在驻留池中存在，那么就返回驻留池中命中内容的堆上引用地址，如果不存在，将新字符串插入驻留池中再返回堆上引用，先上一下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
        {
            var str1 = &quot;nihao&quot;;
            var str2 = &quot;nihao&quot;;

            //验证nihao是否在驻留池中，如果存在那么str3 和 str1，str2一样的引用
            var str3 = string.Intern(&quot;nihao&quot;);

            //验证新的字符串内容是否进入驻留池中
            var str4 = string.Intern(&quot;cnblogs&quot;);
            var str5 = string.Intern(&quot;cnblogs&quot;);

            Console.ReadLine();
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来分别验证一下str3是否也是和str1和str2一样的引用，以及str5是否存在驻留池中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
ConsoleApp2.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp2\Program.cs @ 37]
    LOCALS:
        0x00000047105fea58 = 0x0000018537312d48
        0x00000047105fea50 = 0x0000018537312d48
        0x00000047105fea48 = 0x0000018537312d48
        0x00000047105fea40 = 0x0000018537312d70
        0x00000047105fea38 = 0x0000018537312d70

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从五个变量地址中可以看到，nihao已经被str1，str2，str3共享，cnblogs也进入了驻留池中实现了共享。&lt;/p&gt;
&lt;h3 id=&quot;2-运行期相同string是否进入驻留池&quot;&gt;2. 运行期相同string是否进入驻留池&lt;/h3&gt;
&lt;p&gt;这里面有一个坑，前面讨论的相同字符串都是在编译期就知道的，但运行时中的相同字符串是否也会进入驻留池呢？ 这是一个让人充满好奇的话题，可以试一下，在程序运行时接受IO输入内容hello，看看是否和str1，str2共享引用地址。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
       {
           var str1 = &quot;nihao&quot;;
           var str2 = &quot;nihao&quot;;

           var str3 = Console.ReadLine();

           Console.WriteLine(&quot;输入完成！&quot;);
           Console.ReadLine();
       }

0:000&amp;gt; !clrstack -l
000000f6d35fee50 00007ff889e7090d *** WARNING: Unable to verify checksum for ConsoleApp2.exe
ConsoleApp2.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp2\Program.cs @ 33]
   LOCALS:
       0x000000f6d35fee98 = 0x000002cb1a552d48
       0x000000f6d35fee90 = 0x000002cb1a552d48
       0x000000f6d35fee88 = 0x000002cb1a555f28
0:000&amp;gt; !do 0x000002cb1a555f28
Name:        System.String
MethodTable: 00007ff8e7a959c0
EEClass:     00007ff8e7a72ec0
Size:        36(0x24) bytes
File:        C:\WINDOWS\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll
String:      nihao
Fields:
             MT    Field   Offset                 Type VT     Attr            Value Name
00007ff8e7a985a0  4000281        8         System.Int32  1 instance                5 m_stringLength
00007ff8e7a96838  4000282        c          System.Char  1 instance               6e m_firstChar
00007ff8e7a959c0  4000286       d8        System.String  0   shared           static Empty
                                &amp;gt;&amp;gt; Domain:Value  000002cb18ad39f0:NotInit  &amp;lt;&amp;lt;


&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面内容可以看到，从&lt;code&gt;Console.ReadLine&lt;/code&gt;接收到的引用地址是 &lt;code&gt;0x000002cb1a555f28&lt;/code&gt; ，虽然是相同内容，但却没有使用驻留池，这是因为驻留池在JIT静态解析期就已经解析完成了，也就无法享受复用之优，如果还想复用的话，在 &lt;code&gt;Console.ReadLine()&lt;/code&gt; 包一层 &lt;code&gt;string.Intern&lt;/code&gt;即可，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;
        public static void Main(string[] args)
        {
            var str1 = &quot;nihao&quot;;
            var str2 = &quot;nihao&quot;;

            var str3 = string.Intern(Console.ReadLine());

            Console.WriteLine(&quot;输入完成！&quot;);
            Console.ReadLine();
        }

ConsoleApp2.Program.Main(System.String[]) [C:\dream\Csharp\ConsoleApp1\ConsoleApp2\Program.cs @ 33]
    LOCALS:
        0x0000008fac1fe9c8 = 0x000001ff46582d48
        0x0000008fac1fe9c0 = 0x000001ff46582d48
        0x0000008fac1fe9b8 = 0x000001ff46582d48
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这个时候str1，str2，str3共享一个内存地址 &lt;code&gt;0x000001ff46582d48&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;驻留池技术是个很🐮👃的东西，很好的解决字符串在堆上的重复分配问题，大大减小了堆的内存占用，但也要明白运行期的IO输入无法共享驻留池的解决方案。&lt;/p&gt;
&lt;p&gt;好了，本篇就说到这里，希望对你有帮助！&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_200414062434170x170.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/huangxincheng/345039/o_200414065053baijiahao.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Apr 2020 00:23:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>昨天看群里在讨论C 中的string驻留池，炒的火热，几轮下来理论一堆堆，但是在证据提供上都比较尴尬。虽然这东西很基础，但比较好的回答也不是那么容易，这篇我就以我能力范围之内跟大家分享一下 一：无处不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/12799736.html</dc:identifier>
</item>
<item>
<title>C# 基础知识系列- 14 IO篇之入门IO - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/12799728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/12799728.html</guid>
<description>&lt;p&gt;在之前的章节中，大致介绍了C#中的一些基本概念。这篇我们将介绍一下C#的I/O操作，这将也是一个小连续剧。这是第一集，我们先来简单了解一下C#中的I/O框架。&lt;/p&gt;

&lt;p&gt;I/O 的全称是input/output，翻译过来就是输入/输出。对于一个系统或者计算机来说，键盘、U盘、网络接口、显示器、音响、摄像头等都是IO设备。那么，对于一个程序I/O又是什么呢？&lt;/p&gt;
&lt;p&gt;对于程序而言，I/O就是与外界进行数据交换的方式。借用一句广告词，程序不生产数据，只是数据的搬用工。当然，正如XX还需要对水进行过滤、消毒等工序一样，程序也要对数据进行运算，所以也不完全算是搬用工，严格来讲是加工厂。那么，I/O就是工厂的原料提供商和成品销售商。&lt;/p&gt;
&lt;p&gt;在C# 中，I/O体系整体分为三个部分，后台存储流、装饰器流、流适配器，具体划分如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200429081636754-64303664.png&quot; alt=&quot;image-20200428213627235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在流与流之间，都是采用字节数据进行交换，所以可以得到一个简单的结论，I/O在程序中表现为字节流，换句话说I/O就是将各种数据转成字节的工具。&lt;/p&gt;

&lt;p&gt;C#中，所有流都是继承自Stream类，Stream类定义了流应该具有的行为和属性，使得开发人员可以忽略底层的操作系统和基础设备的具体细节。C#对流的处理忽略了读流和写流的区别，使其更像是一个管道，方便数据通信。流涉及到三个基本操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取 - 将数据从流中传输到数据结构中&lt;/li&gt;
&lt;li&gt;写入 - 将数据从数据源写入流中&lt;/li&gt;
&lt;li&gt;查找 - 对流中操作的当前位置进行查找和修改&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为流的特性，可能并不是所有的流都支持这三种操作，所以Stream提供了三个属性，以方便确认流是否支持这三种操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public abstract bool CanRead { get; } // 获取指示当前流是否支持读取的值
public abstract bool CanWrite { get; } // 获取指示当前流是否支持写入功能的值
public abstract bool CanSeek { get; } // 获取指示当前流是否支持查找功能的值
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上这三个属性均由子类根据自身特性确认是否支持读取、写入、查找，可能三个属性不会都为true，但绝对不会都为false。&lt;/p&gt;
&lt;p&gt;下面是一些常见的流：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileStream 用来操作文件的流&lt;/li&gt;
&lt;li&gt;MemoryStream 操作内存的流&lt;/li&gt;
&lt;li&gt;BufferedStream 缓存流，用来增强其他流的操作性能&lt;/li&gt;
&lt;li&gt;NetworkStream 使用网络套接字进行操作的流&lt;/li&gt;
&lt;li&gt;PipeStream 通过匿名和命名管道进行读取和写入&lt;/li&gt;
&lt;li&gt;CryptoStream 用于将数据流链接到加密转换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C# 中I/O的操作都属于&lt;code&gt;System.IO&lt;/code&gt;这个命名空间，在这个命名空间中C# 定义了文件相关的类、各种流、装饰器流、适配器以及其他一些相关的结构体。在以&lt;code&gt;System.IO&lt;/code&gt;开头的命名空间中，C#对IO进一步扩展，并提供了流压缩和解压缩（&lt;code&gt;System.IO.Compression&lt;/code&gt;），搜索和枚举文件系统元素（&lt;code&gt;System.IO.Enumeration&lt;/code&gt;），提供用于使用内存映射文件的类（&lt;code&gt;System.IO.MemoryMappedFiles&lt;/code&gt;）等内容。&lt;/p&gt;
&lt;p&gt;我们先略过之后篇幅会介绍的内容不提，先来看一下Stream类里重要的属性和方法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 流里数据的长度&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public abstract long Length { get; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当Stream对象的CanSeek为true时，也就是流支持搜索的时候，可以通过这个属性确认流的长度，也就是有多少个字节的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 流的位置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public abstract long Position { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同长度的前提条件一致，当Stream对象支持搜索的时候，可以通过该属性确认流的位置或者修改流的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 读取流里的数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public abstract int Read (byte[] buffer, int offset, int count);
public virtual int ReadByte ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是两种不同的读取方式，第一种是每次读取多个字节的数据，第二个是每次只读一个字节的数据。这里来细细讲解一下区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public abstract int Read (byte[] buffer, int offset, int count);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示流每次最多读取count个字节的数据，然后将数据放到buffer中，位置从下标为offset开始，并返回实际读取的字节数，如果流已经读完了，则返回0。这个过程中，Position会后移实际读取长度，如果流支持搜索，程序中可以调用这个属性。&lt;/p&gt;
&lt;p&gt;所以这里就有会这样的一个限制：&lt;code&gt;offset + count &amp;lt;= buffer.Length&lt;/code&gt;，换句话说，偏移量 + 最大读取数目不能大于缓存数组的长度。&lt;/p&gt;
&lt;p&gt;因为这个方法返回一个实际读取长度，可能有人会这样判断是否读完：根据返回的结果与count比，如果返回的长度小于count则认为流已经读完；否则流还没读完。&lt;/p&gt;
&lt;p&gt;有一些流可能会达成这样的效果，但是很多流并不能以此为依据来判断流是否读完，也许某一次读取长度小于count，然后再读一次发现又有数据了。这是因为IO在系统中属于高耗时操作，大部分情况下IO的性能和程序的运算速度相差甚远。所以经常会出现这样的情景：流的长度是100，给了长度为100的缓存字节数组，然后第一次读取了10个字节，第二次读取了5个字节，这样一点一点的把这100个字节读取到。&lt;/p&gt;
&lt;p&gt;所以，必须以返回值为0作为流的读完判断依据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual int ReadByte ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法很简单，每次从流里读取一个字节的数据，如果读取完成返回-1。可能有人会疑惑了，这个方法明明是读取一个字节，也就是个byte，那为什么返回类型是int呢？很简单，因为byte没有负数，而int有。所以，当返回值不等于-1的时候，可以放心的类型转换为byte。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 把数据写入流&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public abstract void Write (byte[] buffer, int offset, int count);
public virtual void WriteByte (byte value);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;流的写入与读取相比就简单多了，至少我们不用判断流的位置。现在简单分析一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public abstract void Write (byte[] buffer, int offset, int count);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示从buffer的offset下标开始，取count个字节写入流里。所以，对offset、count的限制依旧，和不能大于数组的长度。写入成功，流的位置会移动,否则将保持现有位置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual void WriteByte (byte value);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法就更简单了，直接写一个字节给流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 关闭或销毁流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流在操作完成之后，需要将其关闭以释放流所持有的文件或IO设备等资源。很多人在使用电脑的时候，不能用QQ发送在本地已经打开的excel文件，它会提示文件被占用无法传输。这就是因为Excel打开了这个文件，就持有一个文件相关的流，所以QQ无法发送。解决办法很简单，关掉excel软件即可。回到当前，也就是我们在使用完成之后必须关闭流。&lt;/p&gt;
&lt;p&gt;那么我们该如何关闭流呢？调用以下方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public virtual void Close ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;C#虽然设置了Close方法，但是并不支持开发者在编写程序的时候手动调用Close方法，更推荐使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public void Dispose ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法会将释放流所持有使用的资源，并关闭流。&lt;/p&gt;
&lt;p&gt;当前需要注意的一个地方是，在把流关闭或释放之前把流里的数据推送到基础设备，即调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public abstract void Flush ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一些流设置了自动推送功能，如果遇到这种流则不需要手动调用该方法。&lt;/p&gt;
&lt;p&gt;对于流来说，一旦销毁或关闭，这个流就无法二次使用了，所以调用了Close、Dispose之后再次尝试读取/写入流都会报错&lt;/p&gt;

&lt;p&gt;本篇内容大概介绍了一下C#的IO体系以及一些基本操作，下一篇将介绍如何操作文件。&lt;/p&gt;
&lt;blockquote readability=&quot;3.3333333333333&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://blogs.attachie.club&quot;&gt;我的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202004/1266612-20200429081637193-1882280014.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Apr 2020 00:17:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0. 前言 在之前的章节中，大致介绍了C 中的一些基本概念。这篇我们将介绍一下C 的I/O操作，这将也是一个小连续剧。这是第一集，我们先来简单了解一下C 中的I/O框架。 1. 什么是I/O I/O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/12799728.html</dc:identifier>
</item>
<item>
<title>负载均衡服务之HAProxy基础配置（五） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/12797913.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/12797913.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200419164356haproxy.png&quot; class=&quot;desc_img&quot;/&gt; errorloc和errorloc302都是同样的效果，都是以临时重定向到指定的url上；这里还需要注意一点，这两种方式都是跳转前请求的方法是什么，跳转对应url也是同样的方法；这样一来对于其他非GET方法请求出现403错误码的时候，对应的错误页就无法正常处理（通常只允许GET方法去请求别的URL）；比如跳转前用PUT方法，出现错误403后，按照上面的配置，对应指定的错误页的url也会用PUT方法去请求；为了解决这样的问题，我们这里需要用到errorloc303来指定；该指令的意思是返回303响应码；如果请求前非GET方法，而出现对应错误后，用GET方法去请求对应错误状态码指定的URL；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;143.38886050077&quot;&gt;
&lt;p&gt;　　前文我们聊了下haproxy的修改报文首部的配置、压缩功能以及haproxy基于http协议自定义健康状态检测机制；回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12789175.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12789175.html&lt;/a&gt;；今天这篇博客主要来说一下haproxy的错误页面定义，日志相关配置；&lt;/p&gt;
&lt;p&gt;　　首先来说说错误页面的配置吧；haproxy同nginx是一样可自定义错误页面；在nginx里我们用error_page 指令来指定对应错误状态码加location，根据错误状态码指定的location来指定对应错误状态码的状态页面文件；haproxy自定义错误页面的思想类似，不同的是nginx作为web服务器可以自定义404错误页面，而haproxy通常作为代理服务器，对于404错误页面通常不会由haproxy自己指定，因为haproxy作为代理服务器对于后端server的资源是否能够找到，它不知道；即便我们在配置中指定了404错误对应的响应页面，在haproxy重启后是不会生效的；haproxy指定错误页面的方式两种，第一种是指定本地文件系统文件作为对应错误状态码的错误页；第二种是指定对应错误状态码跳转的URL；&lt;/p&gt;
&lt;p&gt;　　errorfile &amp;lt;code&amp;gt; &amp;lt;file&amp;gt;：指定对应错误状态码对应文件系统上的文件作为该状态码响应的页面&lt;/p&gt;
&lt;p&gt;　　示例：自定义错误403的错误页面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200428220022067-1207203006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：为了能够模仿出403错误，上面使用了acl来拒绝源地址为192.168.0.232的访问；后面我们会说acl的用法；上图红框中的内容就是表示对于错误403响应页面上/etc/haproxy/error403.html；&lt;/p&gt;
&lt;p&gt;　　测试：在192.168.0.232主机上用浏览器访问haproxy对外提供服务端接口，看看是否响应我们自定义的页面？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200428220704803-2029530139.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的测试结果看，haproxy是能够把我们指定错误状态码对应文件内容响应给我们；这里挺奇怪的在消息头里只看得到请求报文，没有响应报文；&lt;/p&gt;
&lt;p&gt;　　示例：指定403错误页面跳转至nginx.org/aaa.html&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200428221640346-104960563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：红框中的配置就表示对于403错误就跳转到指定http://nginx.org/aaa.html&lt;/p&gt;
&lt;p&gt;　　测试：在232主机上访问192.168.0.22看看是否跳转到nginx.org/aaa.html?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200428221931802-1463631852.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：errorloc和errorloc302都是同样的效果，都是以临时重定向到指定的url上；这里还需要注意一点，这两种方式都是跳转前请求的方法是什么，跳转对应url也是同样的方法；这样一来对于其他非GET方法请求出现403错误码的时候，对应的错误页就无法正常处理（通常只允许GET方法去请求别的URL）；比如跳转前用PUT方法，出现错误403后，按照上面的配置，对应指定的错误页的url也会用PUT方法去请求；为了解决这样的问题，我们这里需要用到errorloc303来指定；该指令的意思是返回303响应码；如果请求前非GET方法，而出现对应错误后，用GET方法去请求对应错误状态码指定的URL；&lt;/p&gt;
&lt;p&gt;　　示例：非GET方法错误页面重定向到其他URL上&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200428225813023-1489977788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置就表示如果我们用非GET方法请求某资源，出现403错误后，返回303状态码；303表示请求重定向页面的方法要总是使用GET方法；&lt;/p&gt;
&lt;p&gt;　　测试：先使用errorloc302指定url跳转，然后在浏览器上跳转前使用PUT方法请求，看看跳转后到指定URL看看使用的什么方法？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200428235125834-428476065.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当我们用PUT方法请求192.168.0.22时，跳转到指定的URL也是用的PUT方法；&lt;/p&gt;
&lt;p&gt;　　测试：用errorloc303指定跳转url，然后用PUT方法请求192.168.0.22看看跳转URL使用什么方法?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200428235649508-1503336788.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到用errorloc303指定错误url后，跳转指定URL不是跳转前的PUT方法请求，而是GET；&lt;/p&gt;
&lt;p&gt;　　以上就是haproxy关于错误页面的定义的配置，更多说明请参考官方文档&lt;a href=&quot;http://cbonte.github.io/haproxy-dconv/&quot; target=&quot;_blank&quot;&gt;http://cbonte.github.io/haproxy-dconv/&lt;/a&gt;；说了haproxy的错误页面配置后，接下来在来了解下haproxy的日志；&lt;/p&gt;
&lt;p&gt;　　log：启用事件和流量的每个实例日志记录。&lt;/p&gt;
&lt;p&gt;　　no log：关闭日志记录；&lt;/p&gt;
&lt;p&gt;　　log global：调用全局配置段中日志的定义；&lt;/p&gt;
&lt;p&gt;　　log&amp;lt;address&amp;gt; [len &amp;lt;length&amp;gt;] &amp;lt;facility&amp;gt; [&amp;lt;level&amp;gt; [&amp;lt;minlevel&amp;gt;]]：定义一个用于接收haproxy日志的rsyslog服务器地址，facility；默认是发往本机的rsyslog服务器上的local2上；有关rsyslog的相关说明请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/12091118.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/12091118.html&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;　　log-format &amp;lt;string&amp;gt;：设定日志格式；日志格式的设定变量表请参照下表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
  +---+------+-----------------------------------------------+-------------+
  | R | var  | field name (8.2.2 and 8.2.3 for description)  | type        |
  +---+------+-----------------------------------------------+-------------+
  |   | %o   | special variable, apply flags on all next var |             |
  +---+------+-----------------------------------------------+-------------+
  |   | %B   | bytes_read           (from server to client)  | numeric     |
  | H | %CC  | captured_request_cookie                       | string      |
  | H | %CS  | captured_response_cookie                      | string      |
  |   | %H   | hostname                                      | string      |
  |   | %ID  | unique-id                                     | string      |
  |   | %ST  | status_code                                   | numeric     |
  |   | %T   | gmt_date_time                                 | date        |
  |   | %Tc  | Tc                                            | numeric     |
  |   | %Tl  | local_date_time                               | date        |
  | H | %Tq  | Tq                                            | numeric     |
  | H | %Tr  | Tr                                            | numeric     |
  |   | %Ts  | timestamp                                     | numeric     |
  |   | %Tt  | Tt                                            | numeric     |
  |   | %Tw  | Tw                                            | numeric     |
  |   | %U   | bytes_uploaded       (from client to server)  | numeric     |
  |   | %ac  | actconn                                       | numeric     |
  |   | %b   | backend_name                                  | string      |
  |   | %bc  | beconn      (backend concurrent connections)  | numeric     |
  |   | %bi  | backend_source_ip       (connecting address)  | IP          |
  |   | %bp  | backend_source_port     (connecting address)  | numeric     |
  |   | %bq  | backend_queue                                 | numeric     |
  |   | %ci  | client_ip                 (accepted address)  | IP          |
  |   | %cp  | client_port               (accepted address)  | numeric     |
  |   | %f   | frontend_name                                 | string      |
  |   | %fc  | feconn     (frontend concurrent connections)  | numeric     |
  |   | %fi  | frontend_ip              (accepting address)  | IP          |
  |   | %fp  | frontend_port            (accepting address)  | numeric     |
  |   | %ft  | frontend_name_transport ('~' suffix for SSL)  | string      |
  |   | %hr  | captured_request_headers default style        | string      |
  |   | %hrl | captured_request_headers CLF style            | string list |
  |   | %hs  | captured_response_headers default style       | string      |
  |   | %hsl | captured_response_headers CLF style           | string list |
  |   | %ms  | accept date milliseconds (left-padded with 0) | numeric     |
  |   | %pid | PID                                           | numeric     |
  | H | %r   | http_request                                  | string      |
  |   | %rc  | retries                                       | numeric     |
  |   | %rt  | request_counter (HTTP req or TCP session)     | numeric     |
  |   | %s   | server_name                                   | string      |
  |   | %sc  | srv_conn     (server concurrent connections)  | numeric     |
  |   | %si  | server_IP                   (target address)  | IP          |
  |   | %sp  | server_port                 (target address)  | numeric     |
  |   | %sq  | srv_queue                                     | numeric     |
  | S | %sslc| ssl_ciphers (ex: AES-SHA)                     | string      |
  | S | %sslv| ssl_version (ex: TLSv1)                       | string      |
  |   | %t   | date_time      (with millisecond resolution)  | date        |
  |   | %ts  | termination_state                             | string      |
  | H | %tsc | termination_state with cookie status          | string      |
  +---+------+-----------------------------------------------+-------------+
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　capture cookie &amp;lt;name&amp;gt; len &amp;lt;length&amp;gt;：捕获并记录请求报文和响应报文中的cookie信息&lt;/p&gt;
&lt;p&gt;　　capture request header &amp;lt;name&amp;gt; len &amp;lt;length&amp;gt;：捕获并记录指定请求标头的最后一次出现&lt;/p&gt;
&lt;p&gt;　　capture response header &amp;lt;name&amp;gt; len &amp;lt;length&amp;gt;：捕获并记录指定响应标头的最后一次出现&lt;/p&gt;
&lt;p&gt;　　结合上面的内容，我们就可以自定义访问日志了；通常我们通过capture去捕获对应首部的信息，然后通过上面的变量定义成日志格式&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200429013039192-1814472708.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　测试：用浏览器访问对应haproxy的前端，看看日志格式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202004/1503305-20200429013151977-373977741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们访问对应haproxy的前端，日志就和默认的日志不一样了；日志格式中的变来可参照上边的表去找对应表示什么；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 28 Apr 2020 17:49:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊了下haproxy的修改报文首部的配置、压缩功能以及haproxy基于http协议自定义健康状态检测机制；回顾请参考https://www.cnblogs.com/qiuhom-1874/p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/12797913.html</dc:identifier>
</item>
<item>
<title>使用docker安装codimd，搭建你自己的在线协作markdown编辑器 - 黄钰朝</title>
<link>http://www.cnblogs.com/misterchaos/p/12799168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/misterchaos/p/12799168.html</guid>
<description>&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;最近笔者需要频繁更新和发布文档，因此有了寻找一个在线&lt;a href=&quot;https://www.runoob.com/markdown/md-tutorial.html&quot;&gt;markdown&lt;/a&gt;文档平台的想法。我最终在作业部落，gitbook，codimd之中选择了codimd，并且将其部署到了自己的服务器以便提高访问速度，因此写下这篇博客记录自己&lt;strong&gt;部署和使用的心得&lt;/strong&gt;，供大家参考借鉴。&lt;/p&gt;
&lt;h2 id=&quot;二、codimd是什么？&quot;&gt;二、codimd是什么？&lt;/h2&gt;
&lt;h3 id=&quot;21-源于hackmd的超好用markdown编辑器&quot;&gt;2.1 源于hackmd的超好用markdown编辑器&lt;/h3&gt;
&lt;p&gt;hackmd是一款著名的在线协作markdown编辑器产品&lt;/p&gt;
&lt;p&gt;CodiMD是HackMD的&lt;strong&gt;免费开源版本&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-codimd的作用&quot;&gt;2.2 codimd的作用&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在线编辑markdown文档&lt;/li&gt;
&lt;li&gt;在线发布markdown文档&lt;/li&gt;
&lt;li&gt;和别人在线协作编辑markdown文档&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你可以使用&lt;strong&gt;官方&lt;/strong&gt;提供的&lt;a href=&quot;https://demo.codimd.org/&quot;&gt;codimd服务&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nextcloud.noerror.xyz/index.php/s/iAmc2MKDebkcjyK/preview&quot; alt=&quot;image-20200428232732142&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、安装和使用&quot;&gt;三、安装和使用&lt;/h2&gt;
&lt;h3 id=&quot;31-安装前需要知道的&quot;&gt;3.1 安装前需要知道的&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;安装之后你可以使用的功能和&lt;a href=&quot;https://demo.codimd.org/&quot;&gt;官方&lt;/a&gt;是一样的&lt;/li&gt;
&lt;li&gt;安装的好处是，codimd官方的服务器在美国，在国内访问速度慢，部署到自己的服务器可以提高访问速度，也便于自己掌控数据库&lt;/li&gt;
&lt;li&gt;目前codimd是开放系统，所有人都可以注册和使用你服务器上的codimd服务&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;32-安装步骤&quot;&gt;3.2 安装步骤&lt;/h3&gt;
&lt;p&gt;笔者是参考&lt;a href=&quot;https://hackmd.io/c/codimd-documentation/%2Fs%2Fcodimd-docker-deployment&quot;&gt;官方文档&lt;/a&gt;进行安装的&lt;/p&gt;
&lt;p&gt;总共需要以下步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在MySQL建立codimd使用的数据库&lt;/li&gt;
&lt;li&gt;安装git&lt;/li&gt;
&lt;li&gt;安装docker&lt;/li&gt;
&lt;li&gt;安装docker-compose&lt;/li&gt;
&lt;li&gt;安装codimd&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;321-创建数据库&quot;&gt;3.2.1 创建数据库&lt;/h4&gt;
&lt;p&gt;笔者使用宝塔面板，因此直接如图添加一个数据库&lt;/p&gt;
&lt;p&gt;请注意&lt;strong&gt;允许所有ip访问该数据库&lt;/strong&gt;，因为docker容器访问不属于本地ip访问，可以看&lt;a href=&quot;https://jingsam.github.io/2018/10/16/host-in-docker.html&quot;&gt;详细解释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nextcloud.noerror.xyz/index.php/s/azffKaWNFiiHR4k/preview&quot; alt=&quot;image-20200428231026983&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;322-安装git&quot;&gt;3.2.2 安装git&lt;/h4&gt;
&lt;p&gt;笔者直接使用yum进行安装，执行以下指令即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install git
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;323-安装docker&quot;&gt;3.2.3 安装docker&lt;/h4&gt;
&lt;p&gt;同样使用yum进行安装，执行以下指令即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install docker
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;324-安装docker-compose&quot;&gt;3.2.4 安装docker compose&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;yum install docker-compose
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;325-安装codimd&quot;&gt;3.2.5 安装codimd&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;version: &quot;3&quot;
services:
  codimd:
    image: nabo.codimd.dev/hackmdio/hackmd:2.0.1
    environment:
      - CMD_DB_URL=postgres://codimd:change_password@database/codimd
      - CMD_USECDN=false
    ports:
      - &quot;3000:3000&quot;
    volumes:
      - upload-data:/home/hackmd/app/public/uploads
    restart: always
volumes:
  upload-data: {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你需要执行以下步骤完成codimd的安装：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在一个目录下创建 &lt;code&gt;docker-compose.yml&lt;/code&gt;，向其中粘贴以上内容&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改其中的配置信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在该目录下执行&lt;code&gt;docker-compose up -d&lt;/code&gt;即可完成安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;配置信息说明:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres://codimd:change_password@database/codimd
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一行中各个参数的含义分别是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 数据库连接协议://用户名:密码@数据库主机:数据库端口/数据库名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我使用的是MySQL，数据库名和用户名都是codimd，因此改成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql://codimd:密码@172.18.0.1:3306/codimd
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我的MySQL是在docker的宿主机本地安装的，但是主机ip没有写localhost，因为localhost在docker容器里面会解释成容器本身的ip，这样就连不上安装在宿主机的MySQL，所以我使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ip addr show docker0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看了宿主机的ip为172.18.0.1，然后使用宿主机ip代替localhost，就达到容器内部访问外部的MySQL数据库的目的，可以看&lt;a href=&quot;https://jingsam.github.io/2018/10/16/host-in-docker.html&quot;&gt;其他解决方案和详细解释&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;326-检查是否安装成功&quot;&gt;3.2.6 检查是否安装成功&lt;/h4&gt;
&lt;p&gt;安装完成后可以使用&lt;code&gt;docker ps&lt;/code&gt;命令查看codimd是否已经运行&lt;/p&gt;
&lt;p&gt;查看运行日志：执行以下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker logs -f -t --tail 行数 容器名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的&lt;code&gt;docker ps&lt;/code&gt;命令中看到容器名为codimd_codimd_1&lt;/p&gt;
&lt;p&gt;所以我执行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker logs -f -t --tail 10  codimd_codimd_1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HTTP Server listening at 0.0.0.0:3000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的日志就表示安装成功了&lt;/p&gt;
&lt;h4 id=&quot;327-放行端口&quot;&gt;3.2.7 放行端口&lt;/h4&gt;
&lt;p&gt;codimd默认是运行在3000端口的，因此需要防火墙放行&lt;/p&gt;
&lt;p&gt;你可以使用&lt;a href=&quot;https://tool.chinaz.com/port&quot;&gt;端口扫描工具&lt;/a&gt;确认端口已经正确放行&lt;/p&gt;
&lt;h4 id=&quot;328-测试使用&quot;&gt;3.2.8 测试使用&lt;/h4&gt;
&lt;p&gt;访问你的服务器主机ip的3000端口，即可看到codimd的主页&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nextcloud.noerror.xyz/index.php/s/ooDWExFiaZQdHob/preview&quot; alt=&quot;image-20200428232641617&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-开始写作&quot;&gt;3.3 开始写作&lt;/h3&gt;
&lt;p&gt;有了codimd之后你就可以在线编辑你的markdown文档了，还可以邀请别人一起编辑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://nextcloud.noerror.xyz/index.php/s/akLgfH5aafWZE6j/preview&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;笔者在整个codimd的安装过程还是比较顺利，使用docker-compose安装十分便捷，主要遇到的问题是第一次安装之后查看日志发现访问不了数据库，后来查了资料才知道docker容器内访问localhost会被解释成docker容器本身的ip而不是常规的127.0.0.1，而且，使用docker容器访问数据库，也不属于本地服务器访问数据库。安装完成之后使用起来还是比较方便的，编辑器的页面比较美观，终于可以摆脱离线编辑文档还要写各种版本号更新记录的日子了。&lt;/p&gt;
&lt;h2 id=&quot;五、参考资料&quot;&gt;五、参考资料&lt;/h2&gt;
</description>
<pubDate>Tue, 28 Apr 2020 15:55:00 +0000</pubDate>
<dc:creator>黄钰朝</dc:creator>
<og:description>[TOC] 一、前言 最近笔者需要频繁更新和发布文档，因此有了寻找一个在线 &amp;quot;markdown&amp;quot; 文档平台的想法。我最终在作业部落，gitbook，codimd之中选择了codim</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/misterchaos/p/12799168.html</dc:identifier>
</item>
<item>
<title>MySQL如何创建一个好索引？创建索引的5条建议【宇哥带你玩转MySQL 索引篇(三)】 - 宇的季节</title>
<link>http://www.cnblogs.com/chenkeyu/p/12799207.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenkeyu/p/12799207.html</guid>
<description>&lt;h3&gt;&lt;span&gt;过滤效率高的放前面&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;29&quot;&gt;&lt;span&gt;对于一个多列索引，它的存储顺序是先按第一列进行比较，然后是第二列，第三列&lt;/span&gt;...这样。查询时，如果第一列能够排除的越多，那么后面列需要判断的行数就越少，效率越高。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于如何判断哪个列的过滤效率更高，可以通过选择性计算来决定。例如我们要在&lt;/span&gt;books表创建一个name列和author列的索引，可以计算这两列各自的选择性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;distinct&lt;/span&gt; name) &lt;span&gt;/&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; name, &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;distinct&lt;/span&gt; author) &lt;span&gt;/&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;(&lt;span&gt;*&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; author &lt;span&gt;from&lt;/span&gt; books;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;29&quot;&gt;最后得出结果如下：&lt;/p&gt;
&lt;table class=&quot;32&quot; border=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;bottom&quot;&gt;
&lt;p class=&quot;26&quot;&gt;Name&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;bottom&quot;&gt;
&lt;p class=&quot;26&quot;&gt;author&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p class=&quot;26&quot;&gt;0.95&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p class=&quot;26&quot;&gt;0.9&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;显然&lt;/span&gt;name字段的选择性更高，那么如果把name放第一列，在name条件过滤时就可以排除更多的列，减少接下来 author的过滤。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;使用频率高的放前面&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;29&quot;&gt;其实该建议比上一个建议优先级更高&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如一个商品管理页面，一般都是基于该店家的上架或已下架的商品，再添加其他的查询条件等等。由于所有的查询都需要带有&lt;/span&gt;shopid和status条件，此时应该优先将这两个条件作为基本前缀，这样就可以方便复用索引。&lt;/p&gt;
&lt;p&gt;例如一个(shopid, status, createdat)的索引，当查询条件只有shopid和status时，也可以使用该索引。如果完全根据字段的过滤效率来决定索引，就需要创建很多不同的索引。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;避免排序&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;29&quot;&gt;索引的值都是有序排列的，在创建索引时还可以显式指定每个列的排序方式，例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; idx_books_author_created_at &lt;span&gt;on&lt;/span&gt; books (author, created_at &lt;span&gt;DESC&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;29&quot;&gt;此时，如果执行下面的的查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; books &lt;span&gt;where&lt;/span&gt; author &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; created_at &lt;span&gt;DESC&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;29&quot;&gt;&lt;span&gt;由于满足&lt;/span&gt;auhtor的索引的created_at列都是有序排列的，所以不需要再进行额外的排序操作。&lt;/p&gt;
&lt;p class=&quot;24&quot;&gt;&lt;em&gt; &lt;/em&gt;&lt;em&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1003414/202004/1003414-20200428234319117-212065691.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当结果数据集很大时，&lt;/span&gt;应该尽可能的通过索引来避免查询的额外排序，因为当内存排序空间(&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_sort_buffer_size&quot;&gt;sort_buffer_size&lt;/a&gt;)不够用时，就需要把一部分内容放到硬盘中，此时会很影响性能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如一个分页查询每页显示100条，按从大到小的顺序显示&lt;/span&gt;，当浏览到第100页时，如果查询是file sort的，数据库需要使用堆排序先计算出这个表里面前100 * 100 = 10000条最大的数据，然后取9900 - 10000之间的数据返回给客户端，在计算的过程中，这个最大堆如果放不下就需要保存到磁盘中，但是又需要频繁比较和替换。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;减少随机&lt;/span&gt;IO&lt;/h3&gt;
&lt;p class=&quot;29&quot;&gt;&lt;span&gt;在之前对硬盘知识了解后可以知道，一次随机读会有&lt;/span&gt;10ms的寻址延迟，如果一次查询涉及达到多次的随机读，会很大程度的限制查询性能。常见的sql查询造成随机IO的包括回表和join&lt;/p&gt;
&lt;p&gt;例如下面的查询&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; books &lt;span&gt;where&lt;/span&gt; author &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;author1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;29&quot;&gt;&lt;span&gt;如果&lt;/span&gt;author1有100本书，但是这100本书并不是连续录入的，也就是说这100本书在硬盘中的存储是分离的。那么在有二级索引(author, created_at)的情况下，MySQL先通过二级索引找到满足author1的所有books的id，然后再通过id在聚簇索引中找到具体数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这一过程中，二级索引的存储可以认为是连续的，那么二级索引耗时就是&lt;/span&gt;10ms + 100 * 0.01 = 11ms，包含一次寻址以及接下来的顺序读。而主键索引回表造成的随机IO最差情况是10ms * 100 = 1000ms。那么一共就需要11ms + 1000ms = 1011ms&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常减少随机&lt;/span&gt;IO的一种方式就使用覆盖索引。例如上面的查询中，如果我们只是想要该作者的书名，可以将(author, created&lt;em&gt;at)扩展为(author, created&lt;/em&gt;at,name)，然后将sql修改如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; name &lt;span&gt;from&lt;/span&gt; books &lt;span&gt;where&lt;/span&gt; author &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;author1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;29&quot;&gt;&lt;span&gt;由于索引中已经有&lt;/span&gt;name的信息，此时就不会再次回表，查询耗时就变成了10ms + 100 * 0.01 = 11ms&lt;/p&gt;
&lt;p class=&quot;29&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;值得一提的是&lt;/span&gt;mysql5.6新增一个叫做&lt;span&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/index-condition-pushdown-optimization.html&quot;&gt;&lt;span&gt;索引条件下推&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;的优化&lt;/strong&gt;，例如在有索引&lt;/span&gt;(author, created_at,name)的情况下，进行下面的查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; name &lt;span&gt;from&lt;/span&gt; books &lt;span&gt;where&lt;/span&gt; author &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;author1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; name &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%name%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; created_at &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-01-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;根据最左匹配原则，这个查询只能用到索引的&lt;/span&gt;author字段，如果没有索引条件下推优化，数据库需要在二级索引找到满足author条件的所有列id，然后回表找到剩余信息后，再过滤name和created_at条件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了索引条件下推，在找到满足&lt;/span&gt;author条件的所有索引后，会再用索引的name字段进行普通过滤，尽量减少回表的次数，减少随机IO&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;避免重复索引&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;29&quot;&gt;以&lt;strong&gt;&lt;span&gt;减少随机&lt;/span&gt;IO&lt;/strong&gt;&lt;span&gt;中的查询为例，我们最终是把&lt;/span&gt;(author, created&lt;em&gt;at)扩展&lt;/em&gt;为(author, createdat,name)，而不是创建一个新的(author, name)的索引。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实际应用场景中也有类似的情况，例如创建一个&lt;/span&gt;userid的外键索引，然后又创建(userid, xxx)的索引。由于索引存储的顺序性，其实可以将这两个索引进行合并，如果我们先创建(userid, xxx)的索引，然后再添加userid的外键，mysql会自动使用前面创建索引。&lt;/p&gt;
&lt;p&gt;索引是否越多越好呢？&lt;/p&gt;
&lt;p&gt;显然不是，因为索引是对原表的数据冗余，那么他就必须要保证数据的一致性。如果原表增加了一条数据，索引也需要增加。如果原表修改了一条数据，那么对应的索引可能也要修改内容以及排序的位置，这可能会造成页分裂或页合并。一个表如果索引过多，那么维护索引与表的数据一致性也是不小的压力。通常建议在满足需求前提下，索引越少越好。&lt;/p&gt;

</description>
<pubDate>Tue, 28 Apr 2020 15:49:00 +0000</pubDate>
<dc:creator>宇的季节</dc:creator>
<og:description>MySQL如何创建一个好索引？创建索引的5条建议 过滤效率高的放前面 对于一个多列索引，它的存储顺序是先按第一列进行比较，然后是第二列，第三列...这样。查询时，如果第一列能够排除的越多，那么后面列需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenkeyu/p/12799207.html</dc:identifier>
</item>
<item>
<title>浮点数精度上误差 - 喜欢兰花山丘</title>
<link>http://www.cnblogs.com/life2refuel/p/12732873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/life2refuel/p/12732873.html</guid>
<description>&lt;p&gt;　　在我刚接触编程的时候, 那时候面试小题目很喜欢问下面这几类问题 &lt;/p&gt;
&lt;p&gt;               1'  浮点数如何和零比较大小?&lt;/p&gt;
&lt;p&gt;               2'  浮点数如何转为整型?&lt;/p&gt;
&lt;p&gt;然后过了七八年后这类问题应该很少出现在面试中了吧.  刚好最近我遇到线上 bug,  同大家交流科普下&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题最小现场&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; a = &lt;span&gt;2.01f&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; b = &lt;span&gt;2.01&lt;/span&gt;&lt;span&gt;;

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a1 : 2.01 * 1000 = %f\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, a * &lt;span&gt;1000&lt;/span&gt;);             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a1 : 2.01 * 1000      = 2010.000000&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a2 : int(2.01 * 1000) = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;)(a * &lt;span&gt;1000&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a2 : int(2.01 * 1000) = 2010&lt;/span&gt;
&lt;span&gt;
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b1 : 2.01 * 1000 = %lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b * &lt;span&gt;1000&lt;/span&gt;);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b1 : 2.01 * 1000      = 2010.000000&lt;/span&gt;
    printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b2 : int(2.01 * 1000) = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;)(b * &lt;span&gt;1000&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b2 : int(2.01 * 1000) = 2009&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(用 Go Java 效果是一样的, 绝大部分实现都是严格遵循 IEEE754 标准&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题解答&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中 a1 和 b1 在 C 中 等价于下面的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;float&lt;/span&gt; a = &lt;span&gt;2.01f&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; b = &lt;span&gt;2.01&lt;/span&gt;&lt;span&gt;;

printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a1 : 2.01 * 1000 = %f\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;double&lt;/span&gt;)(a * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;));

printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b1 : 2.01 * 1000 = %f\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, b * &lt;span&gt;1000&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中 printf float 其实相当于 printf (double) 去处理的. 具体可以看这类源码 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#define&lt;/span&gt; PARSE_FLOAT_VA_ARG(INFO)                          \
  &lt;span&gt;do&lt;/span&gt;&lt;span&gt;                                          \
    {                                          \
      INFO.is_binary128 &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;                              \
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (is_long_double)                              \
    the_arg.pa_long_double &lt;/span&gt;= va_arg (ap, &lt;span&gt;long&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt;);              \
      &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;                                      \
    the_arg.pa_double &lt;/span&gt;= va_arg (ap, &lt;span&gt;double&lt;/span&gt;&lt;span&gt;);                  \
    }                                          \
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;0&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其次二者输出打印的数据内容一样. 本质原因是, double 尾数的高23位和float的尾数23位一样.&lt;/p&gt;
&lt;p&gt;如果你用 %.8f 可能就不一样了.  &lt;/p&gt;
&lt;p&gt;(float : 1 + 8 +23, 小数点后精度 6-7)&lt;/p&gt;
&lt;p&gt;(double : 1 + 11 + 52, 小数点后精度 15-16)&lt;/p&gt;
&lt;p&gt;简单的, 我们可以用下面代码去验证 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print_byte(unsigned &lt;span&gt;char&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d%d%d%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        , ((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;7&lt;/span&gt;) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) 
        , ((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;6&lt;/span&gt;) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        , ((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;5&lt;/span&gt;) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        , ((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;4&lt;/span&gt;) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        , ((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;3&lt;/span&gt;) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        , ((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;2&lt;/span&gt;) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        , ((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        , ((&lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; &amp;gt;&amp;gt; &lt;span&gt;0&lt;/span&gt;) &amp;amp; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    );
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print_number(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; *&lt;span&gt; data, size_t n) {
    &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; unsigned &lt;span&gt;char&lt;/span&gt; * bytes =&lt;span&gt; data;

# &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __BYTE_ORDER__ ==&lt;span&gt; __ORDER_LITTLE_ENDIAN__
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (size_t i = n; i &amp;gt; &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;) {
        print_byte(bytes[i&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]);
    }
# &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (size_t i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++&lt;span&gt;) {
        print_byte(bytes[i]);
    }
# endif
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print_float(&lt;span&gt;float&lt;/span&gt;&lt;span&gt; num) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; float = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    print_number(&lt;/span&gt;&amp;amp;num, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; num);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; print_double(&lt;span&gt;double&lt;/span&gt;&lt;span&gt; num) {
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;double = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    print_number(&lt;/span&gt;&amp;amp;num, &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt; num);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; a = &lt;span&gt;2.01f&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; b = &lt;span&gt;2.01&lt;/span&gt;&lt;span&gt;;

    print_float(a);
    print_double(b);

    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; float 2.01f + %%.%df = %.*f\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,  &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;, a);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;double 2.01  + %%.%df = %.*lf\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;&lt;span&gt;, b);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在 window 和 ubuntu 得到的测试数据如下 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  float = 01000000000000001010001111010111
 double = 0100000000000000000101000111101011100001010001111010111000010100

 float  2.01f = 0 10000000    00000001010001111010111
 double 2.01  = 0 10000000000 00000001010001111010111 00001010001111010111000010100

  float 2.01f + %.6f = 2.010000
 double 2.01  + %.6f = 2.010000

 float 2.01f + %.7f = 2.0100000
double 2.01  + %.7f = 2.0100000

 float 2.01f + %.8f = 2.00999999
double 2.01  + %.8f = 2.01000000

 float 2.01f + %.10f = 2.0099999905
double 2.01  + %.10f = 2.0100000000

 float 2.01f + %.15f = 2.009999990463257
double 2.01  + %.15f = 2.010000000000000

 float 2.01f + %.16f = 2.0099999904632568
double 2.01  + %.16f = 2.0099999999999998

 float 2.01f + %.17f = 2.00999999046325684
double 2.01  + %.17f = 2.00999999999999979
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;明显可以看出来 a = 2.01f 和 b = 2.01 在内存中二者是不一样的. 即 a != b, a * 1000 != b * 1000. 有兴趣的可以自行去实验. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题解答继续&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里说说 a2 和 b2 case 造成的原因.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a2 : int(2.01 * 1000) = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;)(a * &lt;span&gt;1000&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; a2 : int(2.01 * 1000) = 2010&lt;/span&gt;
&lt;span&gt;
printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b2 : int(2.01 * 1000) = %d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, (&lt;span&gt;int&lt;/span&gt;)(b * &lt;span&gt;1000&lt;/span&gt;)); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; b2 : int(2.01 * 1000) = 2009&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们首先获取其内存布局 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;float&lt;/span&gt; &lt;span&gt;2010.0f&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10001001&lt;/span&gt;    &lt;span&gt;11110110100000000000000&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt; &lt;span&gt;2010.0&lt;/span&gt;  = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;10000001001&lt;/span&gt; &lt;span&gt;1111011001111111111111111111111111111111111111111111&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;随后借助场外信息, 引述 &amp;lt;&amp;lt;深入理解计算机系统-第三版&amp;gt;&amp;gt; 部分舍入概念&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/532523/202004/532523-20200428230119241-179937489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 误差来自浮点数无法精确表示和转换过程中舍入起的效果. &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;问题反思&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这类问题, 或多或少遇到过, 希望我们这里对这类问题做个了结 ~  &lt;/p&gt;
&lt;p&gt;此刻不知道有心人会不会着急下结论,&lt;/p&gt;
&lt;p&gt;那以后的业务中还是别用 float 了, 或者直接用 double, 或者定点小数, 或者整数替代 float 等等 ...&lt;/p&gt;
&lt;p&gt;这么考虑很不错, 在大多数领域是完全没有问题的. 也是值得推荐的. &lt;/p&gt;
&lt;p&gt;补充下, 也有些领域例如嵌入式, 他们还是会用 float, 因为对他们而言 double 有的时候太浪费内存了,&lt;/p&gt;
&lt;p&gt;还存在着地址对齐等问题. &lt;/p&gt;
&lt;p&gt;虽然不同领域(场景)会有不同方式方法,  但有一点需要大家一块遵守, &lt;strong&gt;没有特殊情况别混着用&lt;/strong&gt; ~ &lt;/p&gt;
&lt;p&gt;希望以上能帮助朋友们对这类问题知其所以然 ~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后记 - 再见, 祝好运 ~&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　错误是难免的, 欢迎交流指正, 当找个乐子 ~ 哈哈哈 ~&lt;/p&gt;


</description>
<pubDate>Tue, 28 Apr 2020 15:34:00 +0000</pubDate>
<dc:creator>喜欢兰花山丘</dc:creator>
<og:description>IEEE754 浮点数精度问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/life2refuel/p/12732873.html</dc:identifier>
</item>
</channel>
</rss>