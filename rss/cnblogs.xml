<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一文带你认识Java8中接口的默认方法 - sum41丶</title>
<link>http://www.cnblogs.com/sum-41/p/10878807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sum-41/p/10878807.html</guid>
<description>&lt;p&gt;Java8是Oracle于2014年3月发布的一个重要版本，其API在现存的接口上引入了非常多的新方法。&lt;/p&gt;
&lt;p&gt;例如，Java8的List接口新增了sort方法。在Java8之前，则每个实现了List接口的类必须定义sort方法的实现，或者从父类中继承它的实现。想象一下，如果List接口的继承体系非常庞杂，那么整个集合框架的维护量有多么大！&lt;/p&gt;
&lt;p&gt;为此，在Java8中引入了一种新的机制：接口支持申明带实现的方法。&lt;/p&gt;
&lt;h4 id=&quot;默认方法&quot;&gt;默认方法&lt;/h4&gt;
&lt;p&gt;前文提到了Java8中List接口新增了sort方法，其源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface List&amp;lt;E&amp;gt; extends Collection&amp;lt;E&amp;gt; {
    
    // ...其他成员
        
    default void sort(Comparator&amp;lt;? super E&amp;gt; c) {
      ...
      ...
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这个新增的sort方法有方法体，由default修饰符修饰，这就是接口的默认方法。&lt;/p&gt;
&lt;p&gt;很显然，默认方法不是static的，所以必须由接口的实现类的实例来调用这些默认方法。&lt;/p&gt;
&lt;p&gt;下面自定义一个接口，练习使用默认方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Sized {
    // 普通抽象方法，默认是public abstract修饰的，没有方法体
    int size();

    /*
     * 默认方法，有方法体
     * 任何一个实现了Sized接口的类都会向动继承isEmpty的实现
     */
    default boolean isEmpty() {
        return this.size() == 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实，随着JDK版本的不断升级，API在不断演进，默认方法在Java8的API中已经大量地使用了，上面List接口中的sort方法就是其中一个。&lt;/p&gt;
&lt;h4 id=&quot;和抽象类的区别&quot;&gt;和抽象类的区别&lt;/h4&gt;
&lt;p&gt;有同学可能发现了，Java8中加入了默认方法的接口，这不就是以前的抽象类吗？其实，两者还是有区别的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个类只能继承一个抽象类；但是一个类可以实现多个接口。&lt;/li&gt;
&lt;li&gt;抽象类有实例变量，而接口只能有类变量&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;解决冲突&quot;&gt;解决冲突&lt;/h4&gt;
&lt;p&gt;我们知道Java语言中一个类只能继承一个父类，但是一个类可以实现多个接口。随着默认方法在Java8中的引入，有可能出现一个类继承了多个签名一样的方法。这种情况下，类会选择使用哪一个函数呢？&lt;/p&gt;
&lt;p&gt;为解决这种多继承关系，Java8提供了下面三条规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;类中的方法优先级最高，类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。&lt;/li&gt;
&lt;li&gt;如果第一条无法判断，那么子接口的优先级更高：方法签名相同时，优先选择拥有最具体实现的默认方法的接口， 即如果B继承了A，那么B就比A更加具体。&lt;/li&gt;
&lt;li&gt;最后，如果还是无法判断，继承了多个接口的类必须通过显式覆盖和调用期望的方法， 显式地选择使用哪一个默认方法的实现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;让我们一起看几个例子 。&lt;/p&gt;
&lt;h5 id=&quot;场景1&quot;&gt;场景1：&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface A {
    default void hello() {
        System.out.println(&quot;hello from A&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface B extends A {
    default void hello() {
        System.out.println(&quot;hello from B&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C implements A, B {
    public static void main(String[] args) {
        new C().hello();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/16/Ebu7fe.png&quot; alt=&quot;类图1&quot;/&gt;&lt;br/&gt;如图1，是这个场景的UML图。&lt;/p&gt;
&lt;p&gt;我们对照上面三条规则来看，类C中main()方法会输出什么？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;规则(1))不满足。&lt;/li&gt;
&lt;li&gt;因为B继承了A，所以B比A更具体，所以应该选择B的hello()方法。所以，程序会打印输出&quot;hello from B&quot;。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;场景2&quot;&gt;场景2：&lt;/h5&gt;
&lt;p&gt;如果C像下面这样继承了D，会怎么样？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class D implements A {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C extends D implements A, B {
    public static void main(String[] args) {
        new C().hello();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/16/EbM5GD.png&quot; alt=&quot;类图2&quot;/&gt;&lt;br/&gt;如图2，是这个场景的UML图。&lt;/p&gt;
&lt;p&gt;同样，我们对照着三条规则来看：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;C虽然继承了D，但D中未覆盖A的默认方法。&lt;/li&gt;
&lt;li&gt;接着，编译器会在A和B中做选择，由于B更具体，所以，程序会打印输出&quot;hello from B&quot;。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;场景3&quot;&gt;场景3：&lt;/h5&gt;
&lt;p&gt;将上面的D稍作修改：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class D implements A {
    public void hello() {
        System.out.println(&quot;hello from D&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果又如何？&lt;/p&gt;
&lt;p&gt;由于依据规则(1)，父类中声明的方法具有更高的优先级，所以程序会打印输出&quot;hello from D&quot;。&lt;/p&gt;
&lt;h5 id=&quot;场景4&quot;&gt;场景4：&lt;/h5&gt;
&lt;p&gt;假设现在B不在继承A：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface A {
    default void hello() {
        System.out.println(&quot;hello from A&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface B {
    default void hello() {
        System.out.println(&quot;hello from B&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C implements A, B {
    public static void main(String[] args) {
        new C().hello();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/16/Eb3nSS.png&quot; alt=&quot;类图3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图3，是这个场景的UML图。&lt;/p&gt;
&lt;p&gt;此时，由于编译器无法识别A还是B的实现更加具体，所以会抛出编译错误：”C inherits unrelated defaults for hello() from types A and B“。&lt;/p&gt;
&lt;p&gt;像这种场景要解决冲突，可以在C中覆盖hello()方法并在方法内显示的选择调用A还是B的方法。&lt;/p&gt;
&lt;p&gt;调用方式如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class C extends D implements A, B {
    public void hello() {
        // 显式地选择调用接口B中的方法
        // 同理，要调用接口A中的方法，可以这样：A.super.hello()
        B.super.hello();
    }

    public static void main(String[] args) {
        // 输出 hello from B
        new C().hello();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;场景5&quot;&gt;场景5：&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface A {
    default void hello() {
        System.out.println(&quot;hello from A&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface B extends A{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface C extends A{

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class D implements B, C {
    public void hello() {
        new D().hello();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/05/16/EbGdaR.png&quot; alt=&quot;类图4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，只有一个方法申明可以选择，所以程序会输出&quot;hello from A&quot;。&lt;/p&gt;
&lt;p&gt;END&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1666949/201905/1666949-20190516233041245-1352127791.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 15:32:00 +0000</pubDate>
<dc:creator>sum41丶</dc:creator>
<og:description>Java8接口中的默认方法，了解一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sum-41/p/10878807.html</dc:identifier>
</item>
<item>
<title>弹出层layer 完整步骤以及在编写弹出层时遇到的错误 - 创奇</title>
<link>http://www.cnblogs.com/chuangqi/p/10878788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chuangqi/p/10878788.html</guid>
<description>&lt;p&gt;实现的功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1593813/201905/1593813-20190516225755603-479605927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先第一步&lt;/p&gt;
&lt;p&gt;　　在官方下载layer的文件。layUI官网：&lt;a href=&quot;http://layer.layui.com/&quot;&gt;http://layer.layui.com/&lt;/a&gt;     &lt;a href=&quot;http://layer.layui.com/&quot;&gt;http://layer.layui.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　layer文件的下载步骤如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1593813/201905/1593813-20190516213111922-782478763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1593813/201905/1593813-20190516204544297-815521646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后将完整的layer文件复制在你当前的项目。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1593813/201905/1593813-20190516230254511-1944910644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引入jquery.js和layer.js，&lt;span&gt;注意：jQuery.js必须在layer.js前面而且jquery.js必须是1.8版本或者以上的&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;http://apps.bdimg.com/libs/jquery/2.0.0/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;      //我的jquery.js不是项目内的&lt;br/&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;&amp;lt;%=path %&amp;gt;/layer/layer.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如你的浏览器的控制台出现：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;layer.js:2 Uncaught TypeError: i is not a function&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at Object.o.run (layer.js:2)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at layer.js:2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at layer.js:2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at layer.js:2&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;leaveExamine_list.jsp:92 Uncaught TypeError: layer.open is not a function&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at Eject (XXX.jsp:92)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;at HTMLButtonElement.onclick&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Uncaught SyntaxError: Invalid or unexpected token&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;XXX.jsp:65 Uncaught ReferenceError: test is not defined&lt;br/&gt;at HTMLButtonElement.onclick (leaveExamine_list.jsp:65)&lt;br/&gt;onclick @ leaveExamine_list.jsp:65&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;说明内的jquery.js不是1.8版本或者以上的，或者是在layer.js的后面，或者是你触发按钮的js方法和layer的js文件或者css文件有重名；&lt;/p&gt;
&lt;p&gt;按钮弹出层代码：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&amp;lt;button id =&quot;test&quot; class=&quot;button border-main&quot; type=&quot;button&quot; onclick = &quot;Eject()&quot;&amp;gt;预览&amp;lt;/button&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;js的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; Eject() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        layer.open({
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         type: 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;          title: '请假详情'&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         shadeClose: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         shade: 0.8&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         area: ['60%', '90%'],   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;宽高&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         ontent: 'leave_preview1.jsp?leaveID=  &amp;lt;%=leaveID%&amp;gt;' &lt;span&gt;//&lt;/span&gt;&lt;span&gt;iframe的url&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }); 
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 15:26:00 +0000</pubDate>
<dc:creator>创奇</dc:creator>
<og:description>实现的功能： 首先第一步 在官方下载layer的文件。layUI官网：http://layer.layui.com/ http://layer.layui.com/ layer文件的下载步骤如下： 然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chuangqi/p/10878788.html</dc:identifier>
</item>
<item>
<title>asp.net core 自定义中间件【以dapper为例】 - 天府三街第一帅</title>
<link>http://www.cnblogs.com/feimaoicoding/p/10878721.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feimaoicoding/p/10878721.html</guid>
<description>&lt;p&gt;在asp.net core开发中。按照国际案例开始。都是先在Nuget安装XXX包。比如我们今天要用到的Dapper&lt;/p&gt;
&lt;p&gt;nuget里面安装Dapper&lt;/p&gt;
&lt;p&gt;1.然后新建一个类文件DapperExtensions.cs&lt;/p&gt;
&lt;p&gt;因为Dapper是IDbConnection扩展出来的，所以我们必须给IDbConnection一个默认的实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 注入服务
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;typeparam name=&quot;T&quot;&amp;gt;&amp;lt;/typeparam&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;service&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IServiceCollection AddDapper&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; IServiceCollection service) &lt;span&gt;where&lt;/span&gt; T:&lt;span&gt;class&lt;/span&gt;&lt;span&gt;,IDbConnection
        {
            service.AddScoped&lt;/span&gt;&amp;lt;IDbConnection, T&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; service;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如何使用呢？在Startup里面加入&lt;/p&gt;
&lt;p&gt;services.AddDapper();&lt;/p&gt;
&lt;p&gt;理论上到这里，就已经可以勉强使用了。但是本文是记录中间件的学习，所以我们还是得在后面学习一下中间件的写法&lt;/p&gt;
&lt;p&gt;2.新建一个DapperMiddleWareExtensions.cs和DapperMiddleWare.cs文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DapperMiddleWare
    {

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DapperOption _option;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DapperMiddleWare(RequestDelegate next, DapperOption option)
        {
            _next &lt;/span&gt;=&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._option =&lt;span&gt; option;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context)
        {

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; conn = context.RequestServices.GetService&amp;lt;IDbConnection&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_option != &lt;span&gt;default&lt;/span&gt;&lt;span&gt;(DapperOption))
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_option.connStr.IsNull())
                {
                    conn.ConnectionString &lt;/span&gt;=&lt;span&gt; _option.connStr;
                }
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Call the next delegate/middleware in the pipeline&lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(context);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DapperMiddleWareExtensions
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IApplicationBuilder UseDapper(&lt;span&gt;this&lt;/span&gt; IApplicationBuilder builder, Action&amp;lt;DapperOption&amp;gt; option = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            DapperOption opt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DapperOption();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (option != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                option(opt);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; builder.UseMiddleware&amp;lt;DapperMiddleWare&amp;gt;&lt;span&gt;(opt);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div id=&quot;content&quot; class=&quot;post-single-content box mark-links&quot; readability=&quot;63&quot;&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
app.UseDapper(opt =&amp;gt;&lt;span&gt;
{
opt.connStr &lt;/span&gt;=&lt;span&gt; Configuration[“db:mysqlmaster”];
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这两段代码非常简单。就是编写一个IApplicationBuilder的扩展方法，然后再扩展方法里面获取到注入的IDbconnection的接口，然后把委托方法传递进来的默认配置参数赋值进去，就可以了。&lt;/p&gt;
&lt;p&gt;实际上，也可以在AddService的时候就可以把委托配置给赋值进去，很多第三方的库就是这么做的。&lt;/p&gt;

&lt;/div&gt;

</description>
<pubDate>Thu, 16 May 2019 15:13:00 +0000</pubDate>
<dc:creator>天府三街第一帅</dc:creator>
<og:description>在asp.net core开发中。按照国际案例开始。都是先在Nuget安装XXX包。比如我们今天要用到的Dapper nuget里面安装Dapper 1.然后新建一个类文件DapperExtensio</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feimaoicoding/p/10878721.html</dc:identifier>
</item>
<item>
<title>用Java实现在【520,1314】之间生成随机整数的故事 - 阿飞云</title>
<link>http://www.cnblogs.com/aflyun/p/10878652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aflyun/p/10878652.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;做一个积极的人&lt;/p&gt;
&lt;p&gt;编码、改bug、提升自己&lt;/p&gt;
&lt;p&gt;我有一个乐园，面向编程，春暖花开！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在未来城市工作的的程序员小木，做了一个梦，梦到自己在塔鲁姆的街道上看到一个姑娘，这个姑娘从远处走向他，脸上带着微笑。让小木很是着迷，小木呆呆的望着姑娘从他身边走过，当他回过神来，发现姑娘已经走远，小木赶忙去追这位姑娘，突然天空中飘下一张字条，上面写着：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我一眼就看出你是Java程序员了，当你能用代码实现 520~1314 之间的随机整数，那么我会主动来找你的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;小木还很纳闷，为什么这个姑娘知道自己是一个程序员，姑娘难道是上天专门派来的吗 ？&lt;/p&gt;
&lt;p&gt;小木同学，见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://dufyun.gitee.io/images_bed/images/techy/random01.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小木很兴奋啊，终于我学的Java编程有用武之处了，这个比写CRUD和看项目留下的烂代码好很多啊，我写好了，姑娘就来找我了。小木大脑开始快速运转，脑神经之间相互发送消息，收集储存起来的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://dufyun.gitee.io/images_bed/images/techy/JVM11-03.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;几秒之后，小木想到了一个方法，在刚开始学习Java的时候学过一个 &lt;code&gt;Math&lt;/code&gt; 类，它里面有一个生成随机数的方法&lt;code&gt;random()&lt;/code&gt;。但是通过&lt;code&gt;Math.random()&lt;/code&gt; 获取的随机数是[0,1）之间的double值。注：包含0，但1不包含！&lt;/p&gt;
&lt;p&gt;那要获取整数，则需要将上面的结果转行成int类型即可。获取[0, 1)之间的int整数。方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;Java language-Java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;double d = Math.random();
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;简单思考：要让值落在520~1314，那么&lt;/p&gt;
&lt;p&gt;MAX ： 1314&lt;/p&gt;
&lt;p&gt;MIN： 520&lt;/p&gt;
&lt;p&gt;因为 &lt;code&gt;Math.random()&lt;/code&gt; 获取[0, 1)，换算公式： （Math.random() * （MAX - MIN）） + MIN&lt;/p&gt;
&lt;p&gt;根据公式照葫芦画瓢，小木很快就实现随机 520~1314 的代码了！&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;double d = Math.random();
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写完上面的代码后，小木想还是要检查检查，不能马虎大意，毕竟这关乎姑娘会不会来找自己。代码运行N多遍之后，520是包含了，但是1314 怎么也出现不了！小木很快意识到这问题很严重。没有1314 姑娘找他这件事肯定就泡汤了。重新看上面的换算公式， 小木发现公式有点问题，少了个 1 啊！&lt;/p&gt;
&lt;p&gt;正确的公式是 ： (Math.random() * （MAX - MIN + 1)) + MIN&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;double d = Math.random();
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就完美一点了，随机数就可以包含1314，这样就可以[520,1314]了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注： 为了方便阅读，括号内就没有直接写出运算后的值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大脑还处在高速运转的小木，实现了上面的功能后，心想这么容易就能约到姑娘了，这是不是有点太简单了。于是又想还有没有其他办法还能实现此功能呢？又想到了有&lt;code&gt;Math.random()&lt;/code&gt;。不是还有一个&lt;code&gt;Random类&lt;/code&gt;嘛，和&lt;code&gt;Random类&lt;/code&gt;一起的还有一个&lt;code&gt;ThreadLocalRandom类&lt;/code&gt;。不管咋，我在用一种方法实现以下，好好表现一下自己也好！&lt;/p&gt;
&lt;p&gt;使用Random获取[520, 1314]之间的int整数，Random 对象的&lt;code&gt;nextInt(int)&lt;/code&gt; 方法，将生成 [0, int)之间随机取值的整数。根据上面的思路，实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Random random = &lt;span class=&quot;hljs-keyword&quot;&gt;new Random();
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小木在上面代码下面备注了如下内容：&lt;/p&gt;
&lt;p&gt;1、Random类采用AtomicLong实现，保证多线程的线程安全性，但是多线程并发获取随机数时性能较差。&lt;/p&gt;
&lt;p&gt;2、ThreadLocalRandom就实现了，ThreadLocalRandom继承了Random。多线程环境中可以使用ThreadLocalRandom作为随机数生成器，ThreadLocalRandom采用了线程局部变量来改善性能。&lt;/p&gt;
&lt;p&gt;最后当小木写完代码后，听到早晨的闹钟响了，美梦就这样被闹钟无情的敲碎了，醒来后，小木久久不能忘记梦中的姑娘，想着什么时候能够再次偶遇！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://dufyun.gitee.io/images_bed/images/techy/random02.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你期待小木和梦中姑娘的的再次相遇嘛，我真的还期待，说不定一段美妙的爱情火花就会擦出。&lt;/p&gt;


&lt;p&gt;最后帮欢哥打波广告： &lt;strong&gt;阿里口碑，杭州，Java工程师&lt;/strong&gt;，感兴趣的伙伴可以私聊！&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 15:01:00 +0000</pubDate>
<dc:creator>阿飞云</dc:creator>
<og:description>与梦中姑娘的不期而遇.....</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aflyun/p/10878652.html</dc:identifier>
</item>
<item>
<title>分布式 - 分布式系统的特点 - 土豆的奥特之父</title>
<link>http://www.cnblogs.com/xguo/p/10878615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xguo/p/10878615.html</guid>
<description>&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-view&quot; data-width=&quot;999&quot; data-height=&quot;749&quot;&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201905/57355-20190516225118324-1562166101.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;20世纪60年代，IBM研发了System 360架构大型机，与同时期的波音707、福特汽车誉为商业三大成就，凭借其卓越的性能和良好的稳定性，开启了大型机的时代，诞生了非常多的集中式系统，采用单机架构，有非常好的单机处理能力。&lt;/p&gt;
&lt;p&gt;然而，大型机的高性能也伴随着高成本，包括购买成本和运维成本，对运维人员的要求非常之高，需要掌握大型机紧密设计的技术细节。&lt;br/&gt;并且购买成本也是极其昂贵，起步几百万刀，甚至更高，只有政府和金融等机构才有能力采购。&lt;/p&gt;
&lt;p&gt;另一个问题，是当今大家都比较关注的单点故障，大型机设计在精良，也不代表它永不宕机，而一台大型机上面往往安装一个甚至多个重要的系统，一旦宕机，后果很严重。&lt;/p&gt;
&lt;p&gt;美国国防部认为，如果仅有一个集中的军事指挥中心，万一被摧毁，全国军事指挥将处于瘫痪状态，因此，设计一个分散的，网络化的指挥通信系统十分有必要，1969年组建了第一个分组交换实验网ARPANET，1980年，TCP/IP（Transmission Control Protocol/Internet Protocol）研制成功，从此，奠定了分布式系统的基石 -- 网络和通信协议！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;看起来，分布式最早出现的目地首先是解决单点问题，避免单点故障，然后解决了性能问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;随着PC机性能的提升和普及，很多企业开始尝试将系统运行在PC服务器上，搭建基于分布式架构的系统，系统之间通过网络连接和通信，分布式系统严重依赖于网络。&lt;/p&gt;
&lt;p&gt;一句话总结单机集中式系统和分布式系统的核心差异：单机系统运行于一台计算机上，而分布式系统是运行于网络之上！&lt;/p&gt;
&lt;p&gt;而在前几年，Hadoop生态倡导基于普通PC构建大型分布式计算系统，并大获成功，加速了分布式架构快速普及和应用。&lt;/p&gt;
&lt;h2&gt;分布式的特点&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;分布式系统是一个各组件分布在不同计算机上，彼此通过网络通信和协调的系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是来自《分布式系统概念与设计》一书中的定义，我给简化了一下，但核心就是上面提到的，分布式，顾名思义，系统的特定部分是分布在不同的计算机上，甚至是完全不在一个机房，或者一个地区的计算机上，各部分通过网络通信，使得整体看起来还是一个系统，对用户透明。&lt;/p&gt;
&lt;h3&gt;资源冗余&lt;/h3&gt;
&lt;p&gt;网络中的计算机本身都是对等的，没有主从之分，但是，分布式系统为了本身的健壮和可靠性考虑，会设计一些冗余来化解分布式系统本身存在的一些必然性。&lt;br/&gt;冗余包括数据的冗余和服务的冗余，数据通常会有一主和多个副本，主数据丢失，系统会读取副本数据，继续对外提供服务；&lt;br/&gt;而服务的冗余是同样一个服务，会运行在多个计算机节点上，每一个服务都有能力对外提供完整或部分服务。&lt;/p&gt;
&lt;h3&gt;并发问题&lt;/h3&gt;
&lt;p&gt;如上所述，一个系统服务可能存在多个运行实例，由于是同时运行，就可能会并发的操作一些共享资源，诸如数据库，分布式文件系统等，如何准确高效的协调并发操作，避免阻塞，保证一致性，是分布式架构设计中最大的挑战之一！&lt;/p&gt;
&lt;h3&gt;全局时钟&lt;/h3&gt;
&lt;p&gt;请参考论文：《&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Flamport.azurewebsites.net%2Fpubs%2Ftime-clocks.pdf&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Time and clocks and ordering of events in a distributed system&lt;/a&gt;》或者 &lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fmedium.com%2Fcoinmonks%2Ftime-and-clocks-and-ordering-of-events-in-a-distributed-system-cdd3f6075e73&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;time-and-clocks-and-ordering-of-events-in-a-distributed-system&lt;/a&gt;&lt;br/&gt;，深刻的剖析了分布式系统多节点之间缺乏全局时钟序列控制的问题，如何保证事件发生的精确的先后顺序。&lt;/p&gt;
&lt;h3&gt;环境问题&lt;/h3&gt;
&lt;p&gt;分布式系统的优势是网络化，为系统的扩展提供了可能性，然而，分布式最大的问题也是网络化带来的各种不确定因素，从工业的角度来说，网络问题是分布式系统的原罪，给分布式系统的设计和实现都带来了极大的难题和挑战。&lt;/p&gt;
&lt;h4&gt;网络的不可靠性&lt;/h4&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;777&quot; data-height=&quot;477&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201905/57355-20190516225106800-207329257.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1524&quot; data-height=&quot;1534&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201905/57355-20190516225054728-1418570573.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;假如CPU一次计算需要1s，那么，一次从旧金山到纽约的网络请求，大约需要5年，到香港需要11年&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，网络的俩个问题，1，不能保证信息的完整性和必达性，存在数据丢包的问题；2，延迟，在整个系统当中，网络延迟是最耗时的部分，各部分性能对比请参考：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.prowesscorp.com%2Fcomputer-latency-at-a-human-scale%2F&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Computer Latency at a Human Scale&lt;/a&gt;。&lt;/p&gt;
&lt;h4&gt;网络分区&lt;/h4&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;4208&quot; data-height=&quot;2644&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201905/57355-20190516225030627-274425777.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当网络通信出现异常，导致分布式系统中部分节点之间的网络延时不断增大，最终，只有部分节点之间的通信是正常的，整个分布式系统变成几个小组，这个现象称为网络分区，也会形成脑裂。&lt;/p&gt;
&lt;p&gt;因此，分布式系统被强行分为几个局部的小集群，并且都会按照一致性算法选举出自己的master，这个有点像战国时期的中国，这就是网络分区，也是脑裂。&lt;br/&gt;可怕的是，每个小集群都可以正常对外服务，出现数据严重不一致的情况，因此，网络分区，数据一致性，再加上可用性（就是出现前面两种情况你怎么办？），被称为传说中的CAP定理，&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-container-fill&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201905/57355-20190516225015391-866197988.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;CAP&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;这些情况对分布式系统的设计，工程实践提出了非常大的挑战。&lt;/p&gt;

&lt;h4&gt;三态&lt;/h4&gt;
&lt;p&gt;在集中式的系统中，模块之间的调用状态只有俩种状态，就是成功和失败，而在分布式系统中，模块之间可能是通过网络通信的，所以就多了一种超时的状态。&lt;br/&gt;超时状态通常会出现在一下俩种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于网络原因，请求并没有被成功的发送到接收方，在过程中丢失；&lt;/li&gt;
&lt;li&gt;请求被成功的发送到接收方，并进行了处理，但是，接收方在响应给发送方的过程中，数据丢失了，发送方没有收到反馈。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，成功、失败、超时是分布式系统通信的三种状态，称为三态。&lt;/p&gt;
&lt;h3&gt;节点故障&lt;/h3&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-container-fill&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/57355/201905/57355-20190516224954742-816325322.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;节点故障是分布式系统中另一个很常见的问题，指的是分布式组成的节点当中，有的节点因为宕机、或者进程退出，出现的节点故障。&lt;br/&gt;根据经验，每个节点都有可能出现故障，并且每天都有可能发生，所以，分布式设计，除了要考虑网络问题，另一个重要的考虑因素是节点故障。&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;本文主要讨论了一下集中式系统的过去，和分布式系统盛行的当下和缘由，以及分布式系统的特点、困境，后面会继续出一些关于分布式系统的相关内容，讨论分布式系统的方方面面。&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 14:53:00 +0000</pubDate>
<dc:creator>土豆的奥特之父</dc:creator>
<og:description>20世纪60年代，IBM研发了System 360架构大型机，与同时期的波音707、福特汽车誉为商业三大成就，凭借其卓越的性能和良好的稳定性，开启了大型机的时代，诞生了非常多的集中式系统，采用单机架构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xguo/p/10878615.html</dc:identifier>
</item>
<item>
<title>Spring Cloud体系实现标签路由 - 每当变幻时</title>
<link>http://www.cnblogs.com/killbug/p/10878482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/killbug/p/10878482.html</guid>
<description>&lt;p&gt;如果你正在使用Spring Cloud体系，在实际使用过程中正遇到以下问题，可以阅读本文章的内容作为后续你解决这些问题的参考，文章内容不保证无错，请务必仔细思考之后再进行实践。&lt;/p&gt;
&lt;h5 id=&quot;问题&quot;&gt;问题：&lt;/h5&gt;
&lt;p&gt;1，本地连上开发或测试环境的集群连调，正常测试请求可能会请求到本地，被自己的debug阻塞。&lt;br/&gt;2，测试环境维护时，多项目并发提测，维护多个相同的集群进行测试是否必要，是否有更好的方案。&lt;/p&gt;
&lt;p&gt;一般，我们在使用Spring Cloud全家桶的时候，会选择zuul作为网关，Ribbon作为负载均衡器，Feign作为远程服务调用模版。使用过Spring Cloud的同学对这些组件的作用必然非常熟悉。这里就拿这些组件组合成的微服务集群来实现标签路由的功能。&lt;/p&gt;
&lt;p&gt;实现的效果如图所示，在头上带上标签的请求会在经过网关和各个应用时进行标签判断流量应该打到哪一个去，而每一个应用自己本身的标签是通过eureka上的matedate实现的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367180/201905/367180-20190516222203145-765550596.png&quot; height=&quot;550&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下图可以构想动态修改标签控制应用所能承接的请求，这里暂时不描述mq部分的功能：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367180/201905/367180-20190516222247913-2008459715.png&quot; height=&quot;550&quot; width=&quot;650&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;答案&quot;&gt;答案：&lt;/h5&gt;
&lt;p&gt;实现一个ZoneAvoidanceRule的继承类，重写getPredicate方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public AbstractServerPredicate getPredicate() {
    OfflineEnvMetadataAwarePredicate offlineEnvMetadataAwarePredicate = new OfflineEnvMetadataAwarePredicate();
    offlineEnvMetadataAwarePredicate.setEnv(env);
    return offlineEnvMetadataAwarePredicate;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Predicate的实现屏蔽了开发测试环境中非这个环境网段启动的应用，并且比对请求的标签和本地的标签，来控制路由给哪一个服务器。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * 线下环境路由策略具体逻辑
 */
public class OfflineEnvMetadataAwarePredicate extends AbstractServerPredicate {


    private String env;


    public void setEnv(String env) {
        this.env = env;
    }


    @Override
    public boolean apply(PredicateKey predicateKey) {
        if(predicateKey == null || !(predicateKey.getServer() instanceof DiscoveryEnabledServer)){
            return true;
        }
        DiscoveryEnabledServer server = (DiscoveryEnabledServer) predicateKey.getServer();
        String serverZone = server.getInstanceInfo().getMetadata().get(&quot;zone&quot;);
        String requestZone = RequestZoneLabelContext.getRequestZone();
        // dev || sit 环境 本地不允许直接连调
        if(env.equals(&quot;sit&quot;) || env.equals(&quot;dev&quot;)){
            if(StringUtils.isBlank(requestZone) &amp;amp;&amp;amp; !server.getHost().startsWith(&quot;10.0&quot;)){
                return false;
            }
        }


        if(StringUtils.isNotBlank(serverZone)) {
            return serverZone.equals(requestZone);
        }else if(StringUtils.isNotBlank(requestZone)){
            return requestZone.equals(serverZone);
        }


        return true;


    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们注意到请求头上的标签要在初始时就拿到，所以需要一个ServletRequestListener，将拿到的zone放入RequestZoneLabelContext。我们知道在一个请求中如果是一个io线程执行到底，我们只需要利用threadlocal来存储线程变量，可是如果一个请求中会产生不定的子线程完成，数据在线程间的传递就成为问题，这里使用了InheritableThreadLocal来决解，在RequestZoneLabelContext中可以看到。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RequestZoneLabelContextListener implements ServletRequestListener {


    private static final String ZONE_LABEL_NAME = &quot;zone&quot;;


    @Override
    public void requestDestroyed(ServletRequestEvent sre) {
        RequestZoneLabelContext.remove();
    }


    @Override
    public void requestInitialized(ServletRequestEvent requestEvent) {
        HttpServletRequest request = (HttpServletRequest)requestEvent.getServletRequest();
        String lbZone = request.getHeader(ZONE_LABEL_NAME);
        if(StringUtils.isNotBlank(lbZone)){
            RequestZoneLabelContext.setZone(lbZone);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 从request header上传递label到feign请求
 */
public class RequestZoneLabelContext {


    private static InheritableThreadLocal&amp;lt;String&amp;gt; zoneLabelThreadLocal = new InheritableThreadLocal&amp;lt;&amp;gt;();


    public static void setZone(String zone){
        zoneLabelThreadLocal.set(zone);
    }


    public static String getRequestZone(){
        return zoneLabelThreadLocal.get();
    }


    public static void remove(){
        zoneLabelThreadLocal.remove();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么在应用之间调用的feign中我们是需要继续把这个zone通过header传递下去的，所以又扩展了RequestInterceptor：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FeignZoneHeaderInterceptor implements RequestInterceptor {


    @Override
    public void apply(RequestTemplate template) {
        String requestZone = RequestZoneLabelContext.getRequestZone();
        if(StringUtils.isNotBlank(requestZone)){
            template.header(&quot;zone&quot;, requestZone);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此就基本实现了最初的想法。&lt;/p&gt;
&lt;p&gt;这个实现方式仅供参考，如有跟好的方式，多多指教哈～&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 14:31:00 +0000</pubDate>
<dc:creator>每当变幻时</dc:creator>
<og:description>如果你正在使用Spring Cloud体系，在实际使用过程中正遇到以下问题，可以阅读本文章的内容作为后续你解决这些问题的参考，文章内容不保证无错，请务必仔细思考之后再进行实践。 问题： 1，本地连上开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/killbug/p/10878482.html</dc:identifier>
</item>
<item>
<title>【带着canvas去流浪（10）】文字烟花 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10878409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10878409.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190516221015382-1369905060.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2041884816754&quot;&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;https://github.com/dashnowords/blogs/tree/master/Demo/canvas-echarts/10.text-fire&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为云社区地址：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/8ae7e6420a4611e9bd5a7ca23e93a891&quot;&gt;【你要的前端打怪升级指南】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一.-文字烟花&quot;&gt;一. 文字烟花&lt;/h2&gt;
&lt;p&gt;文字烟花的小控件是下面这样的效果，你或许在很多个人博客中见过：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190516221039851-1456481492.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一节我们就来讲述一下这个小动画的实现方法。&lt;/p&gt;
&lt;h2 id=&quot;二.-动画原理&quot;&gt;二. 动画原理&lt;/h2&gt;
&lt;p&gt;首先动画的主框架仍然是我们反复使用的逐帧动画框架，烟花生成以后的部分也不难理解，我们之前已经对物理碰撞进行过仿真，这里实际上就是模拟了带有初速度的自由落体。所以这个小动画里唯一的难点，就是如何根据文字生成烟花，只要做到这一步，其他的部分都比较容易实现。&lt;/p&gt;
&lt;h3 id=&quot;像素操作&quot;&gt;2.1 像素操作&lt;/h3&gt;
&lt;p&gt;这里就要用到canvas像素操作的API——&lt;code&gt;context.getImageData( )&lt;/code&gt;了，它可以将画布上指定矩形区域以像素点的形式返回回来，像素数据挂载在返回对象的&lt;code&gt;data&lt;/code&gt;属性上，它是一个一维的&lt;code&gt;Uint8ClampedArray&lt;/code&gt;定型数组，每个值只能取0-255之间的整数，如果赋值超过这个范围，则自动修改为&lt;code&gt;[0,255]&lt;/code&gt;而不会报错。这个一维数组是矩形区域的像素点数据逐行拼接在一起的，每4个点代表一个像素点的&lt;strong&gt;RGBA&lt;/strong&gt;的颜色数据，最后一个通道是透明度数据，例如一个红色的像素点的数据就是[...,255,0,0,0....]。比如你截取了一个长为200像素高为10像素的矩形区域的数据点，那么就会得到一个&lt;code&gt;200*10*4=8000&lt;/code&gt;个数据点的数组。&lt;/p&gt;
&lt;p&gt;这是&lt;code&gt;canvas&lt;/code&gt;非常重要的一个API，它的应用场景非常多，例如结合&lt;code&gt;WebRTC&lt;/code&gt;输入的流数据来做视频弹幕，或者使用算法对像素数据进行加工实现各种各样的图片滤镜等，还可以使用离屏&lt;code&gt;canvas&lt;/code&gt;来进行性能提升，具体的应用就留给你自己去探索喽。&lt;/p&gt;
&lt;h3 id=&quot;烟花生成算法&quot;&gt;2.2 烟花生成算法&lt;/h3&gt;
&lt;p&gt;获取到像素数据后，我们就可以对其进行分析，分析算法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201905/1354575-20190516221051295-1115805333.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将要获取像素的部分分成大小适中的网格，网格太小则渲染压力大，网格太大动画效果不好。&lt;/li&gt;
&lt;li&gt;遍历每一个网格，取出小方块区域内所有像素点，也可以一次性读取整个区域的像素点然后按小区域来取用，然后统计其中&lt;code&gt;dirty&lt;/code&gt;的像素点数量（判断其对应的颜色值是否都为255，如果不是则判定为&lt;code&gt;dirty&lt;/code&gt;），如果区域内脏点的比例超过一定阈值（示例中为&lt;code&gt;60%&lt;/code&gt;）则判定该区域需要被烟花点替换。&lt;/li&gt;
&lt;li&gt;在需要生成烟花的区域以随机大小和颜色生成一个小球，并根据其位置指定水平初速度的方向，小球均受到竖直向下的重力影响。&lt;/li&gt;
&lt;li&gt;在帧动画中更新小球状态。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;计时器&quot;&gt;2.3 计时器&lt;/h3&gt;
&lt;p&gt;最后，我们还需要一个新的&lt;code&gt;timer&lt;/code&gt;对象，之前我们接触到的精灵动画大都是连续的，每一帧都需要进行状态更新，而本节中时间文字的更新是离散的，一秒钟才更新一次，烟花由于有动画过程，也不太适合每秒都生成。所以我们需要在&lt;code&gt;timer&lt;/code&gt;中实现一个内部计时器，每1秒更新一次渲染文字，每2秒触发一次。如果对时间精度要求较高，可以记录时间戳进行比对，如果精度要求不高，可以在&lt;code&gt;update&lt;/code&gt;方法中递增直接对更新周期进行取模即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Timer&lt;/code&gt;类的定义如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//计时器类
class Timer{
    constructor(){
        this.lastTime = Date.now(); //初始化的时候记录一次时间
        this.label = new Date(this.lastTime).Format('hh:mm:ss');//Format是自定义的格式化方法
        this.step = 0;//标记是否刷新时间文字
        this.shouldAnim = 0;//标记是否需要生成新的烟花
    }

    update(){
       this.step = (this.step + 1) % 60;//时间文字每60帧刷新一次
       this.shouldAnim = (this.shouldAnim + 1) % 120;//烟花每120帧生成一次
       if (!this.step) {
          this.lastTime = Date.now();
          this.label = new Date(this.lastTime).Format('hh:mm:ss');
       }
    }

    paint(ctx){
        context.fillStyle = &quot;#353535&quot;;
        ctx.fillText(this.label, 200, 100);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主框架部分的代码已经讲过非常多次，本文不再赘述。&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 14:11:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>示例代码托管在： 'http://www.github.com/dashnowords/blogs' 博客园地址： '《大史住在大前端》原创博文目录' 华为云社区地址： '【你要的前端打怪升级指南】'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10878409.html</dc:identifier>
</item>
<item>
<title>对C++11中的`移动语义`与`右值引用`的介绍与讨论 - 张浮生</title>
<link>http://www.cnblogs.com/neooelric/p/10878394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/neooelric/p/10878394.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;本文主要介绍了C++11中的&lt;code&gt;移动语义&lt;/code&gt;与&lt;code&gt;右值引用&lt;/code&gt;, 并且对其中的一些坑做了深入的讨论. 在正式介绍这部分内容之前, 我们先介绍一下&lt;code&gt;rule of three/five&lt;/code&gt;原则, 与&lt;code&gt;copy-and-swap idiom&lt;/code&gt;最佳实践.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文参考了stackoverflow上的一些回答. 不能算是完全原创&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;rule of three&lt;/code&gt;是自从C++98标准问世以来, 大家总结的一条最佳实践. 这个实践其实很简单, 用一句话就能说明白:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;析构函数&lt;/code&gt;, &lt;code&gt;拷贝构造函数&lt;/code&gt;, &lt;code&gt;=操作符重载&lt;/code&gt;应当同时出现, 或同时不出现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么, 这背后的缘由是什么呢? 这里就来说道说道.&lt;/p&gt;
&lt;p&gt;C++中, 所有变量都是值类型变量, 这意味着在C++代码中, 隐式的拷贝是非常常见的, 最常见的一个隐式拷贝就是参数传递: 非引用类型的参数传递时, 实质上发生的是一次拷贝, 首先我们要明白, 所谓的&lt;code&gt;发生了一次拷贝&lt;/code&gt;, 所谓的&lt;code&gt;拷贝&lt;/code&gt;, 到底是指什么.&lt;/p&gt;
&lt;p&gt;我们从一段短的代码片断开始:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class person
{
    std::string name;
    int age;

public:

    person(const std::string&amp;amp; name, int age) : name(name), age(age)
    {
    }
};

int main()
{
    person a(&quot;Bjarne Stroustrup&quot;, 60);  // Line 1: 这里显然是调用了构造函数
    person b(a);                        // Line 2: 这里发生了什么?
    b = a;                              // Line 3: 这里又发生了什么?
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是一个简单的类, 仅实现了一个构造函数.&lt;/p&gt;
&lt;p&gt;到底什么是&lt;code&gt;拷贝&lt;/code&gt;的本质? 在上面代码片断中, Line 1显然不是拷贝, 这是一个非常显然的初始化, 它调用的也很显然是我们定义的唯一的那个构造函数: &lt;code&gt;person(const std::string&amp;amp; name, int age)&lt;/code&gt;. Line 2和Line 3呢?&lt;/p&gt;
&lt;p&gt;Line 2: 也是一个初始化: 初始化了对象b. 它调用的是类&lt;code&gt;person&lt;/code&gt;的&lt;code&gt;拷贝构造函数&lt;/code&gt;.&lt;br/&gt;Line 3: 是一个赋值操作. 它调用的是&lt;code&gt;person&lt;/code&gt;的&lt;code&gt;=操作符&lt;/code&gt;重载&lt;/p&gt;
&lt;p&gt;但问题是, 在Line 2中, 我们并没有定义某个构造函数符合&lt;code&gt;person b(a)&lt;/code&gt;的调用. 在Line 3中, 我们也并没有实现&lt;code&gt;=操作符&lt;/code&gt;的重载. 但上面那段代码, 是可以被正常编译执行的. 所以, 谁在背后搞鬼?&lt;/p&gt;
&lt;p&gt;答案是编译器, 编译器在背后给你偷偷实现了&lt;code&gt;拷贝构造函数&lt;/code&gt;(&lt;code&gt;person(const person &amp;amp; p)&lt;/code&gt;)与&lt;code&gt;=操作符重载&lt;/code&gt;(&lt;code&gt;person&amp;amp; operator =(const person &amp;amp; p)&lt;/code&gt;). 根据C++98的标准:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;拷贝构造函数(copy constructor)&lt;/code&gt;, &lt;code&gt;=操作符(copy assignment operator)&lt;/code&gt;, &lt;code&gt;析构函数(destructor)&lt;/code&gt;是 &lt;code&gt;特殊的成员函数(special member functions&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当用户没有显式的声明&lt;code&gt;特殊的成员函数&lt;/code&gt;的时候, 编译器应当隐式的声明它们.&lt;/li&gt;
&lt;li&gt;当用户没有显式的声明&lt;code&gt;特殊的成员函数&lt;/code&gt;(显然也并没有实现它们)的时候, 如果代码中使用了这些&lt;code&gt;特殊的成员函数&lt;/code&gt;, 编译器应当为被使用到的&lt;code&gt;特殊的成员函数&lt;/code&gt;提供一个默认的实现&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;并且, 根据C++98标准, 编译器提供的默认实现遵循下面的准则:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;拷贝构造函数&lt;/code&gt;的默认实现, 是对所有类成员的&lt;code&gt;拷贝&lt;/code&gt;. 所谓&lt;code&gt;拷贝&lt;/code&gt;, 就是对类成员&lt;code&gt;拷贝构造函数&lt;/code&gt;的调用.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=操作符重载&lt;/code&gt;的默认实现, 是对所有类成员的&lt;code&gt;=调用&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;析构函数&lt;/code&gt;默认情况下什么也不做&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也就是说, 编译器为&lt;code&gt;person&lt;/code&gt;类偷偷实现的&lt;code&gt;拷贝构造函数&lt;/code&gt;和&lt;code&gt;=操作符&lt;/code&gt;大概长这样:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 拷贝构造函数
person(const person&amp;amp; that) : name(that.name), age(that.age)
{
}

// =操作符
person&amp;amp; operator=(const person&amp;amp; that)
{
    name = that.name;
    age = that.age;
    return *this;
}

// 析构函数
~person()
{
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问题来了: 我们需要在什么情况下显式的声明且实现&lt;code&gt;特殊的成员函数&lt;/code&gt;呢? 答案是: 当你的类&lt;code&gt;管理资源&lt;/code&gt;的时候, 即类的对象持有一个&lt;code&gt;外部资源&lt;/code&gt;的时候. 这通常也意味着:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;资源是在对象构造的时候, 交给对象的. 换句话说, 对象是在构造函数被调用的时候获取到资源的&lt;/li&gt;
&lt;li&gt;资源是在对象析构的时候被释放的.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为了形象的说明管理资源的类与普通的POD类之间的区别, 我们把时光倒退到C++98之前, 那时没有什么标准库, 也没有什么&lt;code&gt;std::string&lt;/code&gt;, C++仅是C的一个超集, 在那个旧时光, &lt;code&gt;person&lt;/code&gt;类可能会被写成下面这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class person
{
    char* name;
    int age;

public:

    // 构造函数获取到了一个资源: 即是C风格的字符串
    // 本例中, 是将资源数据拷贝一份, 对象以持有资源的副本: 存储在动态分配的内存中
    // 对象所持有的资源, 即是动态分配的这段内存(资源的副本)
    person(const char* the_name, int the_age)
    {
        name = new char[strlen(the_name) + 1];
        strcpy(name, the_name);
        age = the_age;
    }

    // 析构的时候需要释放资源, 在本例中, 就是要释放资源副本占用的内存
    ~person()
    {
        delete[] name;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种上古风格的代码, 其实直到今天都还在有人这样写, 并且在将这种残缺的类套进&lt;code&gt;std::vector&lt;/code&gt;, 并且调用&lt;code&gt;push_back&lt;/code&gt;后发出痛苦的嚎叫: &quot;MMP为什么代码一跑起来一大堆内存错误?&quot;, 就像下面这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int main(void ) {
    std::vector&amp;lt;person&amp;gt; vec;

    vec.push_back(person(&quot;allen&quot;, 27));
    
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为: 你并没有提供&lt;code&gt;拷贝构造函数&lt;/code&gt;, 所以编译器给你实现了一个. 你调用&lt;code&gt;vec.push_back(person(&quot;allen&quot;, 27))&lt;/code&gt;的时候, 调用了编译器的默认实现版本. 编译器的默认实现版本仅是简单的复制了值, 意味着同一段内存被两个对象同时持有着. 然后这两个对象在析构的时候都会去试图&lt;code&gt;delete[]&lt;/code&gt;同一段内存, 所以就炸了.&lt;/p&gt;
&lt;p&gt;这就是为什么, 如果你写了&lt;code&gt;析构函数&lt;/code&gt;的话, 就应当再写&lt;code&gt;复制构造函数&lt;/code&gt;与&lt;code&gt;=操作符重载&lt;/code&gt;, 它的逻辑是这样的:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你自行实现了析构函数, 说明这个类并不是简单的POD类, 它有一些资源需要在析构的时候进行释放, 或者是内存, 或者是其它句柄&lt;/li&gt;
&lt;li&gt;为了避免上面示例中的资源重复释放问题, 你需要自行实现对象的&lt;code&gt;拷贝&lt;/code&gt;语义, 根据资源是否能被安全的重复释放, 或者资源是否能被安全的多个对象持有多份拷贝, 来决定&lt;code&gt;拷贝&lt;/code&gt;的语义&lt;/li&gt;
&lt;li&gt;为了实现&lt;code&gt;拷贝&lt;/code&gt;的语义, 你需要自行实现&lt;code&gt;拷贝构造函数&lt;/code&gt;与&lt;code&gt;=操作符重载&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以一个安全的&lt;code&gt;person&lt;/code&gt;类应当实现如下的&lt;code&gt;拷贝构造函数&lt;/code&gt;和&lt;code&gt;=操作符重载&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 拷贝构造函数
person(const person&amp;amp; that)
{
    name = new char[strlen(that.name) + 1];
    strcpy(name, that.name);
    age = that.age;
}

// =操作符重载
person&amp;amp; operator=(const person&amp;amp; that)
{
    if (this != &amp;amp;that)
    {
        delete[] name;
        // 这其实是一个很危险的写法, 但如何正确的写一个=操作符重载并不属于本节所要讨论的范畴
        // 所以暂时先可以凑合这样写着
        name = new char[strlen(that.name) + 1];
        strcpy(name, that.name);
        age = that.age;
    }
    return *this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意上面的&lt;code&gt;=操作符重载&lt;/code&gt;的实现是很不安全的, 但如何正确的写一个&lt;code&gt;=操作符重载&lt;/code&gt;并不是本节所要讨论的内容(下一节&quot;copy-and-swap idiom&quot;中再进行讨论). 这里只要明白为什么&lt;code&gt;析构函数&lt;/code&gt;, &lt;code&gt;拷贝构造函数&lt;/code&gt;, &lt;code&gt;=操作符重载&lt;/code&gt;应当同生共死就行了.&lt;/p&gt;
&lt;p&gt;某些场合中, 对象所持有的资源是不允许被拷贝的, 比如文件句柄或互斥量. 在这种场合, 与其费尽心机的去研究如何让多个对象同时持有同一个资源, 不如直接禁止这种行为: 禁止对象的拷贝与赋值. 要实现这种功能, 在C++03标准之前, 有一个很简单的方式, 即是把&lt;code&gt;拷贝构造函数&lt;/code&gt;和&lt;code&gt;=操作符&lt;/code&gt;在类内声明为&lt;code&gt;private&lt;/code&gt;, 并且不去实现它们, 如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private:

    person(const person&amp;amp; that);
    person&amp;amp; operator=(const person&amp;amp; that);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在C++11标准下, 你可以使用&lt;code&gt;delete&lt;/code&gt;关键字显式的说明, 不允许拷贝操作, 如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;person(const person&amp;amp; that) = delete;
person&amp;amp; operator=(const person&amp;amp; that) = delete;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以, 至此, 就基本说明白了为什么&lt;code&gt;rule of three&lt;/code&gt;是大家自从C++98以来, 总结出来的一个最佳实践. 比较遗憾的是, 在语言层面, C++并没有强制要求所有程序员都必须这样写, 不然不给编译通过. 所以说呀, C++这门语言还真是危险呢.&lt;/p&gt;
&lt;p&gt;而自C++11以来, 类内的&lt;code&gt;特殊的成员函数&lt;/code&gt;由三个, 扩充到了五个. 由于&lt;code&gt;移动语义&lt;/code&gt;的引入, &lt;code&gt;拷贝构造函数&lt;/code&gt;和&lt;code&gt;=操作符重载&lt;/code&gt;都可以有其&lt;code&gt;右值引用参数&lt;/code&gt;版本以支持&lt;code&gt;移动语义&lt;/code&gt;, 所以&lt;code&gt;rule of three&lt;/code&gt;就自然而然的被扩充成了&lt;code&gt;rule of five&lt;/code&gt;, 下面是例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class person
{
    std::string name;
    int age;

public:
    person(const std::string&amp;amp; name, int age);        // 构造函数
    
    person(const person &amp;amp;) = default;                // 拷贝构造函数
    person(person &amp;amp;&amp;amp;) noexcept = default;            // 拷贝构造函数: 右值引用版. 也被称为移动构造函数
    person&amp;amp; operator=(const person &amp;amp;) = default;     // =操作符重载
    person&amp;amp; operator=(person &amp;amp;&amp;amp;) noexcept = default; // =操作符重载: 右值引用版
    ~person() noexcept = default;                    // 析构函数
};&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;rule of three/five&lt;/code&gt;小节, 我们已经讨论了, 任何一个管理资源的类, 都应当实现&lt;code&gt;拷贝构造函数&lt;/code&gt;, &lt;code&gt;析构函数&lt;/code&gt;与&lt;code&gt;=操作符重载&lt;/code&gt;. 这三者中, 实现&lt;code&gt;拷贝构造函数&lt;/code&gt;和&lt;code&gt;析构函数&lt;/code&gt;的目的是很显而易见的, 但&lt;code&gt;=操作符重载&lt;/code&gt;的实现目的, 以及实现手段在很长一段时间内都是有争论的, 人们在实践中发现, 要实现一个完善的&lt;code&gt;=操作符重载&lt;/code&gt;, 其实并不像表面上想象的那么简单, 那么, 到底应当如何去写一个完美的&lt;code&gt;=操作符重载&lt;/code&gt;呢? 这其中又有哪些坑呢? 这一节我们将进行深入讨论.&lt;/p&gt;
&lt;p&gt;简单来说, &lt;code&gt;copy-and-swap&lt;/code&gt;就是一种实现&lt;code&gt;=操作符重载&lt;/code&gt;的最佳实践, 它主要解决(或者说避免了)两个坑:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;避免了重复代码的书写&lt;/li&gt;
&lt;li&gt;提供了强异常安全的保证&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;逻辑上来讲, &lt;code&gt;copy-and-swap&lt;/code&gt;在内部复用了&lt;code&gt;拷贝构造函数&lt;/code&gt;去拷贝资源, 然后将拷贝好的资源副本, 通过一个&lt;code&gt;swap&lt;/code&gt;函数(注意, 这不是标准库的&lt;code&gt;std::swap&lt;/code&gt;模板函数), 将旧资源与拷贝好的资源副本进行交换. 然后复用析构函数将旧资源进行析构. 最终仅保留拷贝后的资源副本.&lt;/p&gt;
&lt;p&gt;上面这段话你看起来可能很头晕, 这不要紧, 后面会进行详细说明.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;copy-and-swap&lt;/code&gt;套路的核心有三:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个实现良好的&lt;code&gt;拷贝构造函数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个实现良好的&lt;code&gt;析构函数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个实现良好的&lt;code&gt;swap&lt;/code&gt;函数.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所谓的&lt;code&gt;swap&lt;/code&gt;函数, 是指这样的函数:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不抛异常&lt;/li&gt;
&lt;li&gt;交换两个对象的所有成员&lt;/li&gt;
&lt;li&gt;不使用&lt;code&gt;std::swap&lt;/code&gt;去实现这个&lt;code&gt;swap&lt;/code&gt;函数. 因为&lt;code&gt;std::swap&lt;/code&gt;内部调用了&lt;code&gt;=&lt;/code&gt;操作符, 而我们要写的这个&lt;code&gt;swap&lt;/code&gt;函数, 正是为了实现&lt;code&gt;=操作符重载&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面说了那么多, 可能看的你脑壳越来越痛, 不要紧, 现在我们用代码来阐述. 比如下面这个&lt;code&gt;dump_array&lt;/code&gt;类, 内部持有堆区的资源(也就是一个通过&lt;code&gt;new&lt;/code&gt;分配的数组), 我们先给它把&lt;code&gt;拷贝构造函数&lt;/code&gt;和&lt;code&gt;析构函数&lt;/code&gt;实现掉.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;algorithm&amp;gt;    // std::copy
#include &amp;lt;cstddef&amp;gt;      // std::size_t

class dumb_array
{
public:
    // 构造函数
    dumb_array(std::size_t size = 0)
        : mSize(size),
          mArray(mSize ? new int[mSize]() : nullptr)
    {
    }

    // 拷贝构造函数
    dumb_array(const dumb_array&amp;amp; other)
        : mSize(other.mSize),
          mArray(mSize ? new int[mSize] : nullptr),
    {
        std::copy(other.mArray, other.mArray + mSize, mArray);
    }

    // 析构函数
    ~dumb_array()
    {
        delete [] mArray;
    }

private:
    std::size_t mSize;
    int* mArray;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先来看一个失败的&lt;code&gt;=操作符重载&lt;/code&gt;实现&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// the hard part
dumb_array&amp;amp; operator=(const dumb_array&amp;amp; other)
{
    if (this != &amp;amp;other)         // (1)
    {
        delete [] mArray;       // (2)
        mArray = nullptr;       // (2) *(see footnote for rationale)

        mSize = other.mSize;                                    // (3)
        mArray = mSize ? new int[mSize] : nullptr;              // (3)
        std::copy(other.mArray, other.mArray + mSize, mArray);  // (3)
    }

    return *this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表面上看这个实现好像也没什么大问题, 但实际上它有三个缺陷:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在&lt;code&gt;(1)&lt;/code&gt;处, 需要首先判断&lt;code&gt;=&lt;/code&gt;操作符左右是不是同一个对象. 这个逻辑上来讲其实没什么问题. 但实际应用中, &lt;code&gt;=&lt;/code&gt;左右两边都是同一个对象的可能性非常低, 几乎为0. 但这种判断你又不得不做, 你做了就是拖慢了代码运行速度. 但坦白讲这并不是一个什么大问题.&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;(2)&lt;/code&gt;处, 先是把旧资源释放掉, 然后再在&lt;code&gt;(3)&lt;/code&gt;处进行新资源内存的再申请与数据拷贝. 但如果第&lt;code&gt;(3)&lt;/code&gt;步, 申请内存的时候抛异常失败了呢? 整个就垮掉了.一个改进的实现是先申请内存与数据拷贝, 成功了再做旧资源的释放, 如下&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;dumb_array&amp;amp; operator=(const dumb_array&amp;amp; other)
{
    if (this != &amp;amp;other)
    {
        std::size_t newSize = other.mSize;
        int* newArray = newSize ? new int[newSize]() : nullptr;
        std::copy(other.mArray, other.mArray + newSize, newArray);

        delete [] mArray;
        mSize = newSize;
        mArray = newArray;
    }

    return *this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;整个&lt;code&gt;=重载&lt;/code&gt;的实现, 几乎就是抄了&lt;code&gt;拷贝构造函数&lt;/code&gt;中的代码(虽然在本例中不是很明显: 因为&lt;code&gt;拷贝构造函数&lt;/code&gt;中使用了成员初始化列表).&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看到这里你可能觉得我在吹毛求疵, 但你稍微想一下, 如果我们要管理的资源的非常复杂的初始化步骤的话, 上面的写法其实就很恶心了. 首先是异常安全的保证就需要非常小心, 其次就是抄代码的情况就会非常明显: 同样的逻辑, 你要在&lt;code&gt;拷贝构造函数&lt;/code&gt;和&lt;code&gt;=操作符重载&lt;/code&gt;里, 写两遍!&lt;/p&gt;
&lt;p&gt;那么一个正确的实现应当怎么写呢? 我们上面说过, &lt;code&gt;copy-and-swap&lt;/code&gt;套路能规避掉上面的三个缺陷, 但在继续讨论之前, 我们首先要实现一个&lt;code&gt;swap&lt;/code&gt;函数. 这个&lt;code&gt;swap&lt;/code&gt;函数是如此的重要与核心, 我甚至愿意为此, 将所谓的&lt;code&gt;rule of three&lt;/code&gt;改名叫成&lt;code&gt;rule of three and a half&lt;/code&gt;, 其中的&lt;code&gt;a half&lt;/code&gt;就是指这个&lt;code&gt;swap&lt;/code&gt;函数. 多说无益, 我们来看&lt;code&gt;swap&lt;/code&gt;的实现, 如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class dumb_array
{
public:
    // ...

    // 首先, 这是一个函数, 只是声明与实现都放在了类定义中, 而不是一个成员函数
    // 其次, 这个函数不抛异常
    friend void swap(dumb_array&amp;amp; first, dumb_array&amp;amp; second)
    {
        // 通过这条指令, 在找不到合适的swap函数时, 去调用std::swap
        using std::swap;

        // 由于两个成员都是基础类型, 它们没有自己的 swap 函数
        // 所以这里调用的是两次 std::swap 
        swap(first.mSize, second.mSize);
        swap(first.mArray, second.mArray);
    }

    // ...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;swap&lt;/code&gt;的实现初看起来很平平无奇, 其目的也十分显而易见(交换两个对象中的所有成员), 但实际上, 上面这个写法里也是有一些门道的, 限于篇幅关系, 这里不会掰开揉碎细细讲, 你最好仔细琢磨一下这个&lt;code&gt;swap&lt;/code&gt;的写法, 比如:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为什么它非要写成&lt;code&gt;friend void swap&lt;/code&gt;, 而不是写成一个普通函数&lt;/li&gt;
&lt;li&gt;里面那句&lt;code&gt;using std::swap&lt;/code&gt;有什么玄机? 想一想, 如果&lt;code&gt;dumb_array&lt;/code&gt;的成员变量不是基础类型, 而是一个类类型, 并且这个类类型也完整的实现了&lt;code&gt;rule of three and a half&lt;/code&gt;, 会发生什么?&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总之, 现在先不关心&lt;code&gt;swap&lt;/code&gt;实现上的一些细节, 仅仅只需要关注它的功能即可: 它是一个函数, 它能完成两个&lt;code&gt;dumb_array&lt;/code&gt;对象的交换, 而所谓的交换, 是交换两个对象的成员的值.&lt;/p&gt;
&lt;p&gt;在此基础上, 我们的&lt;code&gt;=操作符重载&lt;/code&gt;可以实现成下面这样:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;dumb_array&amp;amp; operator=(dumb_array other) // (1)
{
    swap(*this, other); // (2)

    return *this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是的, 就这是么简洁. 你没有看错, 就是这么有魔力! 那么, 为什么说它规避了我们先前提到的三个缺陷呢? 它又是如何规避的呢?&lt;/p&gt;
&lt;p&gt;首先再回顾一下, 我们实现&lt;code&gt;=操作符重载&lt;/code&gt;的逻辑思路:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在&lt;code&gt;fuck = shit&lt;/code&gt;的内部, 我们先将&lt;code&gt;shit&lt;/code&gt;拷贝一份, 称其为&lt;code&gt;shit2&lt;/code&gt;好了&lt;/li&gt;
&lt;li&gt;然后使用一个&lt;code&gt;swap&lt;/code&gt;函数, 将&lt;code&gt;fuck&lt;/code&gt;与&lt;code&gt;shit2&lt;/code&gt;进行交换: 即交换两个对象的所有成员变量的值. 这样就达到了&quot;把&lt;code&gt;shit&lt;/code&gt;的值赋给&lt;code&gt;fuck&lt;/code&gt;&quot;的目的&lt;/li&gt;
&lt;li&gt;第三步, 在&lt;code&gt;=&lt;/code&gt;操作符实现的内部退栈的时候, &lt;code&gt;shit2&lt;/code&gt;会自动由于退栈而被析构.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整个过程没有风险, 没有异常, 很是流畅.&lt;/p&gt;
&lt;p&gt;这里有几个点也需要额外说明一下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先, 这个&lt;code&gt;=操作符重载&lt;/code&gt;的实现, 其参数是值类型, 而不是&lt;code&gt;const dumb_array &amp;amp; other&lt;/code&gt;. 这里面是有门道的, 如果采用引用类型, 如下所示:&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;dumb_array&amp;amp; operator=(const dumb_array&amp;amp; other)
{
    dumb_array temp(other);
    swap(*this, temp);

    return *this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从功能上看, 和先前的值引用版本没什么区别. 但内在上, 你实质上放弃了一个&quot;让编译器自动优化代码&quot;的契机. 这个细节展开来说也比较复杂, 具体缘由在&lt;a href=&quot;https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/&quot;&gt;这里&lt;/a&gt; 有详细解释, 但总结起来就是: 在C++中, 普通的拷贝操作(调用拷贝构造函数), 比起在函数传参时, 编译器在背后执行的拷贝操作(虽然从表面看它也是在调用拷贝构造函数), 效率要低, 并且还低得多!&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用值传递来自动使编译器在背后调用&lt;code&gt;拷贝构造函数&lt;/code&gt;(实质上编译器会做一些优化, 但你可以这样理解), 保证了只要执行流程进入到了&lt;code&gt;=操作符&lt;/code&gt;的内部, 数据拷贝就已经完成了. 这暗地里还复用了&lt;code&gt;拷贝构造函数&lt;/code&gt;的代码. 所以, 代码重复的问题解决了.&lt;/li&gt;
&lt;li&gt;并且由于这样的写法, 只要函数调用这个动作被成功发起了, 就代表着数据拷贝已经成功: 这意味着拷贝过程中发生的内存分配等其它高危操作已经完成, 如果有异常, 应当在函数调用之前被扔出来, 而一旦代码执行进调用内部, 就不可能再抛异常了. 这解决了异常安全的问题&lt;/li&gt;
&lt;li&gt;我们也规避了用以检查&lt;code&gt;=&lt;/code&gt;左右两边是否为同一个对象的逻辑. 虽然如果这种情况发生, 这种写法会导致一次额外的数据拷贝与析构, 但这也是可以接受的, 毕竟, 如果出现了这种情况, 你应当反思的是为什么出现了&lt;code&gt;自己 = 自己&lt;/code&gt;这种奇怪的逻辑, 而不是去苛责&lt;code&gt;自己 = 自己&lt;/code&gt;执行的不够快.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此, 就是&lt;code&gt;copy-and-swap&lt;/code&gt;套路的所有内容.&lt;/p&gt;
&lt;p&gt;那么, 在C++11中, 事情发生了任何变化了吗? 我们在&lt;code&gt;rule of three/five&lt;/code&gt;这一小节说过, 由于C++11引入了&lt;code&gt;右值引用&lt;/code&gt;和&lt;code&gt;移动语义&lt;/code&gt;, 所以&lt;code&gt;three&lt;/code&gt;变&lt;code&gt;five&lt;/code&gt;: 你要新增一个&lt;code&gt;移动构造函数&lt;/code&gt;, 与&lt;code&gt;右值引用版的=操作符重载&lt;/code&gt;. 但实质上, 使用&lt;code&gt;copy-and-swap&lt;/code&gt;套路的话, 你并不需要为&lt;code&gt;=操作符&lt;/code&gt;再写一个&lt;code&gt;右值引用&lt;/code&gt;版本的重载, 你只需要像下面这样, 添加一个&lt;code&gt;移动构造函数&lt;/code&gt;就可以了:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class dumb_array
{
public:
    // ...

    // 移动构造函数
    dumb_array(dumb_array&amp;amp;&amp;amp; other)
        : dumb_array() // 调用默认构造函数, 这在本例中不是必须的.
    {
        swap(*this, other);
    }

    // ...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于为什么不需要再写一个&lt;code&gt;右值引用版的=操作符重载&lt;/code&gt;, 这个, 你可以先了解一下下一节的内容: &lt;code&gt;移动语义&lt;/code&gt;后, 再来看这里. 总之, 就是, 使用&lt;code&gt;copy-and-swap&lt;/code&gt;套路, 在C++11中, 可以将所谓的&lt;code&gt;rule of five&lt;/code&gt;变成&lt;code&gt;rule of four and a half&lt;/code&gt;, 分别是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.      析构函数
2.      移动构造函数
3.      拷贝构造函数
4.      `=`操作符重载 
4.5.    `swap`函数&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;要理解移动语义, 其实用代码说话更容易让人理解. 我们就从下面的代码片断开始: 这是一个非常简单简陋的&lt;code&gt;string&lt;/code&gt;的实现(注意它不是标准库中的&lt;code&gt;std::string&lt;/code&gt;, 这里仅是我们自己实现的一个非常简陋的字符串类), 它内部使用一个指针成员持有着数据:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;

class string
{
    char* data;

public:

    string(const char* p)
    {
        size_t size = strlen(p) + 1;
        data = new char[size];
        memcpy(data, p, size);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们在这个简陋的实现里选择使用指针来管理数据, 即是作为类的设计者, 我们需要手动管理具体数据占用的内存的分配与释放, 所以按C++03标准的最佳实践, 我们应当遵循&lt;code&gt;rule of three&lt;/code&gt;. 即是: &lt;code&gt;析构函数&lt;/code&gt;, &lt;code&gt;拷贝构造函数&lt;/code&gt;, &lt;code&gt;=操作符的重载&lt;/code&gt;三者必须同时在场. 我们先在这里把&lt;code&gt;析构函数&lt;/code&gt;和&lt;code&gt;拷贝构造函数&lt;/code&gt;补上, 关于&lt;code&gt;=的重载&lt;/code&gt;, 后面一点再谈&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    ~string()
    {
        delete[] data;
    }

    string(const string&amp;amp; that)
    {
        size_t size = strlen(that.data) + 1;
        data = new char[size];
        memcpy(data, that.data, size);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;拷贝构造函数&lt;/code&gt;实现了拷贝的语义, 参数&lt;code&gt;const string &amp;amp; that&lt;/code&gt;是&lt;code&gt;const引用&lt;/code&gt;, 这代表着它可以指向C++03标准中的右值, 即是一个表达式的值的最终类型是为上面这个简陋的&lt;code&gt;string&lt;/code&gt;, 都可以作为拷贝构造函数的参数使用. 所以, 在假定我们还实现了类似于标准库中&lt;code&gt;std::string&lt;/code&gt;对&lt;code&gt;+的重载&lt;/code&gt;的话, 我们可以以如下三种方式调用拷贝构造函数:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;...
// x和y是两个string类型的变量
string a(x);                                    // Line 1
string b(x + y);                                // Line 2, 这里假设我们实现了+的重载, 使得表达式 x + y 的类型也是 string
string c(some_function_returning_a_string());   // Line 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在就到了理解移动语义的关键点:&lt;/p&gt;
&lt;p&gt;注意在第一行, 我们使用&lt;code&gt;x&lt;/code&gt;作为参数去调用拷贝构造函数初始化&lt;code&gt;a&lt;/code&gt;, 拷贝构造函数内部实现了深拷贝: 即完整的把&lt;code&gt;x&lt;/code&gt;底层持有的数据拷贝了一份. 这没有任何毛病, 因为这就是我们想要的, 完成初始化&lt;code&gt;a&lt;/code&gt;之后, &lt;code&gt;a&lt;/code&gt;和&lt;code&gt;x&lt;/code&gt;分别持有两份数据, 后续再对&lt;code&gt;x&lt;/code&gt;做一些数据修改的操作, 不会影响到&lt;code&gt;a&lt;/code&gt;, 反之亦然. &lt;code&gt;x&lt;/code&gt;显然也是C++03标准中的左值.&lt;/p&gt;
&lt;p&gt;而第二行和第三行的参数, 无论是&lt;code&gt;x + y&lt;/code&gt;还是&lt;code&gt;some_function_returning_a_string()&lt;/code&gt;, 显然都不能算是C++03中的左值, 显然它们都是右值. 因为这两个表达式的运算结果虽然确实是一个&lt;code&gt;string&lt;/code&gt;的实例, 但没有一个变量名去持有这些实例, 这些实例都是临时性的实例: 阅后即焚. 即在这个表达式之后, 你没有任何办法再去访问先前表达式指代的那个&lt;code&gt;string&lt;/code&gt;实例. 按照C++03的规范, 这种临时量占用的内存在下一个分号之后就可以被扔掉了(更精确一点的说: 在整个包含着这个右值的表达式单元执行完毕之后. 再精确一点: 编译器的实现是不确定的, 你应当假定在表达式执行完毕后这个对象就被析构了, 但编译器多数情况下只会在遇到下个}的时候才析构这种临时对象).&lt;/p&gt;
&lt;p&gt;这就给了我们一个灵感: 既然在下个分号之后, 再也无法访问&lt;code&gt;x + y&lt;/code&gt;与&lt;code&gt;some_function_returning_a_string()&lt;/code&gt;这两个表达式指向的临时&lt;code&gt;string&lt;/code&gt;对象, 意味着我们可以在下个分号之前(换句话说, 在初始化&lt;code&gt;b&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt;的过程中: 在拷贝构造函数中), 随意蹂躏这两个临时量! 反正蹂躏完了也不会产生任何额外副作用.&lt;/p&gt;
&lt;p&gt;基于这种思路, C++11标准中引入了一种新的机制叫&lt;code&gt;右值引用&lt;/code&gt;, &lt;code&gt;右值引用&lt;/code&gt;一般用于函数重载(的参数列表)中, 它的目的是探测调用者传入的参数是否是C++03中的临时量. 一旦探测到调用者传入的是一个临时量的话, 重载调用机制就会匹配到有&lt;code&gt;右值引用&lt;/code&gt;参数的重载中. 在这种函数内部, 你通过&lt;code&gt;右值引用&lt;/code&gt;可以去访问这个临时量, 并在内部随意蹂躏这个临时量.&lt;/p&gt;
&lt;p&gt;说起来有一点绕, 我们直接使用&lt;code&gt;右值引用&lt;/code&gt;这个机制去写一个拷贝构造函数的重载, 如下所示:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    string(string&amp;amp;&amp;amp; that)   // string&amp;amp;&amp;amp; is an rvalue reference to a string
    {
        data = that.data;
        that.data = nullptr;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在向&lt;code&gt;string&lt;/code&gt;的内部添加了这个拷贝构造函数后, &lt;code&gt;string&lt;/code&gt;类内部目前就有了两个拷贝构造函数: &lt;code&gt;string(const string&amp;amp; that)&lt;/code&gt;与&lt;code&gt;string(string&amp;amp;&amp;amp; that)&lt;/code&gt;. 我们再回到上面的&lt;code&gt;a, b, c&lt;/code&gt;三个初始化语句上. 这时, 由于&lt;code&gt;x&lt;/code&gt;是一个左值, 所以&lt;code&gt;a&lt;/code&gt;的初始化会匹配至&lt;code&gt;string(const string&amp;amp; that)&lt;/code&gt;. 而由于&lt;code&gt;x + y&lt;/code&gt;与&lt;code&gt;some_function_returning_a_string()&lt;/code&gt;是两个显然的临时量右值, 所以对于&lt;code&gt;b&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt;的初始化, 就会匹配到&lt;code&gt;string(string&amp;amp;&amp;amp; that)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;那么&lt;code&gt;string(string&amp;amp;&amp;amp; that)&lt;/code&gt;内部到底做了什么事情呢? 看上面的代码就很显然, 它并没有像&lt;code&gt;string(const string&amp;amp; that)&lt;/code&gt;那样去真正的拷贝一份数据, 而仅仅是把临时量内部持有的数据偷了过来, 用读书人的说法, 就叫&lt;code&gt;移动&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;这里需要注意, 在&lt;code&gt;string(string&amp;amp;&amp;amp; that)&lt;/code&gt;执行结束之后, 临时量&lt;code&gt;x + y&lt;/code&gt;与&lt;code&gt;some_function_returning_a_string()&lt;/code&gt;还是会和C++03一样, 阅后即焚. 这两个临时对象依然会被析构. 临时量始终都是临时量, 从C++03到C++11, 这个行为没有变化. 只不过, 在析构之前, 我们已经通过&lt;code&gt;string(string&amp;amp;&amp;amp; that)&lt;/code&gt;把它内部的数据偷掉了! 真正这两个临时量被析构的时候, 执行的只不过是&lt;code&gt;delete nullptr&lt;/code&gt;罢了.&lt;/p&gt;
&lt;p&gt;恭喜你, 到目前为止, 理解了C++11中&lt;code&gt;移动语义&lt;/code&gt;的基本概念.&lt;/p&gt;
&lt;p&gt;现在, 在进一步讨论之前, 让我们先把&lt;code&gt;string&lt;/code&gt;类的&lt;code&gt;=操作符重载&lt;/code&gt;再补上. 根据C++03的最佳实践之&lt;code&gt;copy and swap idiom&lt;/code&gt;, 一个行为正确异常安全的&lt;code&gt;=操作符&lt;/code&gt;重载应当被实现成下面这样:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    string&amp;amp; operator=(string that)
    {
        std::swap(data, that.data);
        return *this;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到上面这个代码你是不是准备问我, &quot;&lt;code&gt;右值引用&lt;/code&gt;哪去了? &quot;. 我的回答是: &quot;这里并不需要右值引用&quot;, 至于为什么, 我们再来看下面三行代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// x, y, a, b, c 均是string类型的变量

a = x;                                      // Line 4
b = x + y;                                  // Line 5
c = some_function_returning_a_string();     // Line 6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先来分析第四行(Line 4).&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于&lt;code&gt;string&amp;amp; operator=(string that)&lt;/code&gt;是值类型参数, 所以在调用发生时, 参数的传递会使用&lt;code&gt;x&lt;/code&gt;先去初始化&lt;code&gt;that&lt;/code&gt;, 你可以理解为&lt;code&gt;string that(x)&lt;/code&gt;这种. 由于&lt;code&gt;x&lt;/code&gt;是一个左值. 所以&lt;code&gt;that&lt;/code&gt;的初始化使用的是&lt;code&gt;string(const string&amp;amp; that)&lt;/code&gt;这个构造函数: 即&lt;code&gt;that&lt;/code&gt;是&lt;code&gt;x&lt;/code&gt;的一个完整副本, 深度拷贝了&lt;code&gt;x&lt;/code&gt;的数据&lt;/li&gt;
&lt;li&gt;在执行&lt;code&gt;std::swap(data, that.data)&lt;/code&gt;的过程中, &lt;code&gt;a&lt;/code&gt;持有的数据与&lt;code&gt;that&lt;/code&gt;持有的数据相互交换. 至此, &lt;code&gt;a&lt;/code&gt;持有的数据其实就是&lt;code&gt;x&lt;/code&gt;数据的一个完整副本.&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;return *this&lt;/code&gt;执行之后, &lt;code&gt;that&lt;/code&gt;由于函数退栈, 被析构. &lt;code&gt;that&lt;/code&gt;中持有的数据(其实是原&lt;code&gt;a&lt;/code&gt;持有的数据)被析构函数安全释放&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总结起来: &lt;code&gt;a = x&lt;/code&gt;内部, 将&lt;code&gt;x&lt;/code&gt;的数据完整的复制了一份给&lt;code&gt;a&lt;/code&gt;, 再把&lt;code&gt;a&lt;/code&gt;原持有的数据安全析构掉了.&lt;/p&gt;
&lt;p&gt;我们再来分析第五行(Line 5)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于&lt;code&gt;string&amp;amp; operator=(string that)&lt;/code&gt;是值类型参数, 所以在调用发生时, 参数的传递会使用&lt;code&gt;x + y&lt;/code&gt;先去初始化&lt;code&gt;that&lt;/code&gt;, 你可以理解为&lt;code&gt;string that(x)&lt;/code&gt;这种. 由于&lt;code&gt;x + y&lt;/code&gt;是一个临时量右值, 所以&lt;code&gt;that&lt;/code&gt;的初始化使用的是&lt;code&gt;string(string&amp;amp;&amp;amp; that)&lt;/code&gt;这个构造函数, 在这个构造函数内部, &lt;code&gt;that&lt;/code&gt;偷掉了&lt;code&gt;x + y&lt;/code&gt;内部持有的数据, 并没有发生数据拷贝.&lt;/li&gt;
&lt;li&gt;在执行&lt;code&gt;std::swap(data, that.data)&lt;/code&gt;的过程中, &lt;code&gt;b&lt;/code&gt;持有的数据与&lt;code&gt;that&lt;/code&gt;持有的数据相互交换. 至此, &lt;code&gt;x + y&lt;/code&gt;原持有的数据经过二次转手, 来到了&lt;code&gt;b&lt;/code&gt;的手上. 而&lt;code&gt;b&lt;/code&gt;原持有的数据, 则交换给了&lt;code&gt;that&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;return *this&lt;/code&gt;执行之后, &lt;code&gt;that&lt;/code&gt;由于函数退栈, 被析构. &lt;code&gt;that&lt;/code&gt;中持有的数据(其实是原&lt;code&gt;b&lt;/code&gt;持有的数据)被析构函数安全释放&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总结起来: &lt;code&gt;b = x + y&lt;/code&gt;内部, 经过两次转手, 将&lt;code&gt;x + y&lt;/code&gt;持有的数据转交给了&lt;code&gt;b&lt;/code&gt;, 而&lt;code&gt;b&lt;/code&gt;原持有的数据被完全的析构掉了.&lt;/p&gt;
&lt;p&gt;第六行和第五行类似.&lt;/p&gt;
&lt;p&gt;至此, 你可算是基本明白了C++11中的移动语义. 现在, 请回头再看&lt;code&gt;copy-and-swap&lt;/code&gt;小节的末尾, 你就会明白, 为什么&lt;code&gt;copy-and-swap + rule of three + C++11 == rule of four and a half&lt;/code&gt;了&lt;/p&gt;

&lt;p&gt;我们在这里, 再对&lt;code&gt;移动语义&lt;/code&gt;, &lt;code&gt;右值引用&lt;/code&gt;等内容做一些补充&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;概览&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;移动语义&lt;/code&gt;允许一个对象, 在一些受限的上下文中, 去夺取另外一个同类型对象的内部资源. 这有两个点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它将C++03标准中, 代价昂贵的&lt;code&gt;拷贝&lt;/code&gt;操作进行了优化. 但如果一个类类型, 内部并不掌管任何外部资源的话(无论是直接掌管, 还是由成员对象间接掌管), &lt;code&gt;移动语义&lt;/code&gt;是没有任何卵用的: 它实质上就是拷贝! 也就是说, 在这种情况下, &lt;code&gt;移动&lt;/code&gt;和&lt;code&gt;拷贝&lt;/code&gt;, 指的是同一件事. 比如下面这个POD类:&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class cannot_benefit_from_move_semantics
{
    int a;        // 移动一个int, 其实就是拷贝
    float b;      // 移动一个float, 其实也是拷贝
    double c;     // 移动一个double, 其实还是拷贝
    char d[64];   // 移动一个字节数组, 其实还他妈是拷贝

    // ...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;移动语义&lt;/code&gt;的引入可以让程序员写出这样一种类: 它的对象仅能&lt;code&gt;移动&lt;/code&gt;, 而不能被&lt;code&gt;拷贝&lt;/code&gt;. 这种对象中或许掌管着诸如锁, 文件句柄, 智能指针这样的全局或局部单例资源.&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;移动的本质是什么&quot;&gt;移动的本质是什么?&lt;/h2&gt;
&lt;p&gt;C++98中的标准库提供了一个智能指针模板类, 其语义是唯一性的指向一个对象. 即是大家熟悉的&lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. 如果你不熟悉&lt;code&gt;auto_ptr&lt;/code&gt;, 可以将它理解为一个&quot;保证new出来的对象一定会妥善析构(甚至在有异常抛出的场合里)而不需要程序员手动&lt;code&gt;delete&lt;/code&gt;&quot;的小工具, 比如下面这种用法:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;{
    std::auto_ptr&amp;lt;Shape&amp;gt; a (new Triangle);
}   // &amp;lt;- 当代码执行流程跳出这个作用域的时候, 对象a就会被自动析构&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实, &lt;code&gt;auto_ptr&lt;/code&gt;中值得称道的就是它的&quot;拷贝&quot;操作, 下面用一个简略的ASCII图来说明:&lt;/p&gt;
&lt;pre class=&quot;ascii&quot;&gt;
&lt;code&gt;auto_ptr&amp;lt;Shape&amp;gt; a(new Triangle);            // 智能指针a指向一个新创建和Triangle对象

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        |
        |
  +-----|---+
  |   +-|-+ |
a | p | | | |
  |   +---+ |
  +---------+

auto_ptr&amp;lt;Shape&amp;gt; b(a);                       // 使用a去初始化另外一个智能指针b, 其实a与b均指向了同一个Triangle对象

      +---------------+
      | triangle data |
      +---------------+
        ^
        |
        +----------------------+
                               |
  +---------+            +-----|---+
  |   +---+ |            |   +-|-+ |
a | p |   | |          b | p | | | |
  |   +---+ |            |   +---+ |
  +---------+            +---------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键点在于, 用&lt;code&gt;a&lt;/code&gt;去初始化&lt;code&gt;b&lt;/code&gt;的时候, 在&lt;code&gt;智能指针对象&lt;/code&gt;这一层, 确实新建了一个&lt;code&gt;智能指针对象&lt;/code&gt;, 也就是&lt;code&gt;auto_ptr&amp;lt;Shape&amp;gt;&lt;/code&gt;类的实例. 但在内部, 并没有新建一个&lt;code&gt;Triangle&lt;/code&gt;对象, 两个&lt;code&gt;智能指针对象&lt;/code&gt;指向的是同一个&lt;code&gt;Triangle&lt;/code&gt;对象. 这就是&lt;code&gt;移动语义&lt;/code&gt;的最初发源, 所以, 正确理解&lt;code&gt;移动语义&lt;/code&gt;需要理解下面两句话:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当我们讲, 将&lt;code&gt;a&lt;/code&gt;移动到&lt;code&gt;b&lt;/code&gt;的时候. &lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;其实还是相互独立的两个实例, 各自在内存中占用着各自的空间.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;移动语义&lt;/code&gt;中的&lt;code&gt;移动&lt;/code&gt;, 其实说的是&lt;code&gt;a&lt;/code&gt;将它&quot;持有的资源&quot;交给了&lt;code&gt;b&lt;/code&gt;, 这种&lt;code&gt;资源&lt;/code&gt;一般都是以&lt;code&gt;指针&lt;/code&gt;形式指向的动态资源.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;移动&lt;/code&gt;并不是说, 内存中的&lt;code&gt;a&lt;/code&gt;对象本身改名叫&lt;code&gt;b&lt;/code&gt;了, 并不是. &lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;还是各自独立的两个对象, 分别有自己的内存. 这一点一定要正确理解.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto_ptr&lt;/code&gt;之所以能实现这种功能, 其实是&lt;code&gt;auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;的&lt;code&gt;拷贝构造函数&lt;/code&gt;使用了如下的实现方式(就说这么个意思, 但并不是真的是这样写的代码):&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto_ptr(auto_ptr &amp;amp; source) {
    p = source.p;
    source.p = 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对移动语义的错误理解导致的误用&quot;&gt;对&lt;code&gt;移动语义&lt;/code&gt;的错误理解导致的误用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;auto_ptr&lt;/code&gt;时至今日已经被抛弃, 其缘由就是, 它的行为看起来让程序员以为是&quot;拷贝&quot;, 但实际上是&quot;移动&quot;. 比如下面的例子:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto_ptr&amp;lt;Shape&amp;gt; a(new Triangle);
auto_ptr&amp;lt;Shape&amp;gt; b(a);           // a的资源, 也就是实际的&quot;Triangle对象&quot;, 已经交由b了
double area = a-&amp;gt;area();        // 完犊子&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面进行到&lt;code&gt;b(a)&lt;/code&gt;这一步的时候, 其实&lt;code&gt;a&lt;/code&gt;已经丢失了对&lt;code&gt;Triangle&lt;/code&gt;对象的所有权, 其所有权转交给了&lt;code&gt;b&lt;/code&gt;. 之后, &lt;code&gt;a&lt;/code&gt;其实已经不持有任何对象了. 再往后&lt;code&gt;a-&amp;gt;area()&lt;/code&gt;显然就是做无米之炊.&lt;/p&gt;
&lt;p&gt;当然, &lt;code&gt;auto_ptr&lt;/code&gt;虽然来说比较危险, 但也有它自己适合的应用场合. 工厂函数就是一个特别适合&lt;code&gt;auto_ptr&lt;/code&gt;发光发热的地方, 如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto_ptr&amp;lt;Shape&amp;gt; make_triangle() {
    return auto_ptr&amp;lt;Shape&amp;gt;(new Triangle);
}

auto_ptr&amp;lt;Shape&amp;gt; c(make_triangle());     // c指向的是一个工厂生产的全新的Triangle对象
double area = make_triangle()-&amp;gt;area();  // area是另外一个全新Triangle对象算出来的面积&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就是一个安全的例子: 确实有两个&lt;code&gt;Triangle&lt;/code&gt;对象. 其实这个安全的例子, 和上面那个完犊子的例子, 其实都有同样的代码书写方式:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto_ptr&amp;lt;Shape&amp;gt; var(狗);
double area = 狗-&amp;gt;area();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你心里明白, 同样的写法, 完犊子的例子之所以完犊子, 是因为&lt;code&gt;狗&lt;/code&gt;把自己的资源在第一步交给了&lt;code&gt;var&lt;/code&gt;, 自己一无所有了. 而工厂例子中, 每次狗都持有一个全新的资源.&lt;/p&gt;
&lt;p&gt;但从另外一个角度来看问题: 两个例子中, &lt;code&gt;a&lt;/code&gt;和&lt;code&gt;make_triangle()&lt;/code&gt;这两个表达式还有什么其它区别吗? 表面上看, 它们都是同一类型的表达式(&lt;code&gt;auto_ptr&amp;lt;Shape&amp;gt;&lt;/code&gt;), 那为什么二者表现不一致呢? 这是因为二者的&lt;code&gt;值类别(value categories)&lt;/code&gt;不同: &lt;code&gt;a&lt;/code&gt;是一个左值(&lt;code&gt;lvalue&lt;/code&gt;), &lt;code&gt;make_triangle()&lt;/code&gt;是一个右值(&lt;code&gt;rvalue&lt;/code&gt;).&lt;/p&gt;
&lt;h2 id=&quot;值类别-value-categories&quot;&gt;值类别, &lt;code&gt;value categories&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;我们依然从C++98与C++03的标准来一步一步的看这个问题. 在C++98与C++03中, 值类别是如此的不言自明(注意, 当我们讨论值类别的时候, 讨论的是表达式, 而不是变量), 以至于很长一段时间里, 大家都不去关心这个事情, 值类别只有两种选择: &lt;code&gt;左值(lvalue)&lt;/code&gt;和&lt;code&gt;右值(rvalue)&lt;/code&gt;. 所谓左值, 就是可以出现在赋值操作符左侧的表达式. 所谓右值, 是指仅可以出现在赋值操作符右侧的表达式.&lt;/p&gt;
&lt;p&gt;上面的例子中, 表达式&lt;code&gt;a&lt;/code&gt;是一个&lt;code&gt;auto_ptr&amp;lt;Shape&amp;gt;&lt;/code&gt;类型的变量, 这显然是一个&lt;code&gt;左值&lt;/code&gt;, 因为&lt;code&gt;a&lt;/code&gt;是一个变量, 可以被&lt;code&gt;赋值&lt;/code&gt;. 而&lt;code&gt;make_triangle()&lt;/code&gt;这个表达式是一个函数调用表达式, 其值是为其返回的对象(按值返回的对象), 每次调用它都会在内部创建一个新的&lt;code&gt;auto_ptr&amp;lt;Shape&amp;gt;&lt;/code&gt;然后通过值返回的方式返回回来. 这显然是一个&lt;code&gt;右值&lt;/code&gt;表达式.&lt;/p&gt;
&lt;p&gt;我们从值类型的角度来看&lt;code&gt;auto_ptr&lt;/code&gt;中的移动语义, 结合上面提到的&quot;完犊子&quot;与&quot;工厂&quot;两个鲜活的例子, 可以得出一个例子:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;移动&lt;code&gt;左值&lt;/code&gt;是一种危险的行为. 因为&lt;code&gt;移动&lt;/code&gt;代表着&lt;code&gt;剥夺&lt;/code&gt;, 但左值可能在内部资源被&lt;code&gt;剥夺&lt;/code&gt;之后, 错误的再去尝试使用内部资源&lt;/li&gt;
&lt;li&gt;移动诸如&lt;code&gt;make_triangle()&lt;/code&gt;这样的&lt;code&gt;右值&lt;/code&gt;则是一种安全的行为. 因为这种&lt;code&gt;右值&lt;/code&gt;本身就是一次性的, 阅后即焚的, 即便你不&lt;code&gt;剥夺&lt;/code&gt;它的内部资源, 它也会在下个&lt;code&gt;;&lt;/code&gt;后被析构.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;或者形象一点, &lt;code&gt;左值&lt;/code&gt;就像是一个正常的人, 能活到90岁(所属作用域终止), 你不能随便就把一个正常人的肾挖掉. 但&lt;code&gt;右值&lt;/code&gt;就像是一个被判决死刑立即执行的人一样, 我们可以心安理得的将死刑犯的肾挖掉. 反正下午就嗝屁了, 不如死前给和谐社会做一点贡献.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto_ptr&amp;lt;Shape&amp;gt; c(make_triangle());
                                  ^ make_triangle()表达式的值所指向的Triangle对象, 活不过这个分号&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实&lt;code&gt;左值&lt;/code&gt;与&lt;code&gt;右值&lt;/code&gt;这个概念是从C语言一脉相承继承过来的. &lt;code&gt;左值可以出现在=左边, 右值只能出现在=右边&lt;/code&gt;这句话在C语言范畴中, 是绝对正确的. 但在C++98或C++03中, 并不完全正确, 这里举几个反例:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数组变量, 或删除了&lt;code&gt;=操作符&lt;/code&gt;的类变量, 是没法出现在&lt;code&gt;=&lt;/code&gt;左边的, 但它们都是货真价实的&lt;code&gt;左值&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果一个类, 实现了&lt;code&gt;=操作符&lt;/code&gt;, 但它的语义并不是赋值的话, 这种类的变量也有可能出现了&lt;code&gt;=&lt;/code&gt;的左边(这确实有点抬杠了, 但你不能说这不是一个反例)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在C++98与C++03中, 或许我们这样定义&lt;code&gt;左值&lt;/code&gt;和&lt;code&gt;右值&lt;/code&gt;可能会更精确一点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无论&lt;code&gt;左值&lt;/code&gt;还是&lt;code&gt;右值&lt;/code&gt;, 本质都是&lt;code&gt;值&lt;/code&gt;, 都是&lt;code&gt;对象&lt;/code&gt;, 都在内存中占用一块区域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;左值&lt;/code&gt;是有名字的&lt;code&gt;值&lt;/code&gt;, 像变量就是典型的左值(变量名, 或者引用名就是名字), 意味着这块内存区域在它的作用域范围内, 可以通过&lt;code&gt;名字&lt;/code&gt;被多次访问. 它的生命周期一般与作用域一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;右值&lt;/code&gt;则是没有名字的&lt;code&gt;值&lt;/code&gt;, 一般仅在&lt;code&gt;表达式求值&lt;/code&gt;的那一个时刻可以访问这块内存区域, 之后就没有办法再去访问这块内存了.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意, 我们当前的讨论, 还没有超出C++03的范畴.&lt;/p&gt;
&lt;h2 id=&quot;右值引用&quot;&gt;　右值引用&lt;/h2&gt;
&lt;p&gt;从&lt;code&gt;auto_ptr&lt;/code&gt;的例子我们可以看出&lt;code&gt;移动语义&lt;/code&gt;本身的性能潜力, 但也看到了潜在的安全风险. 那么, 有没有一种机制, 能自动判断表达式的值类别, 如果是&lt;code&gt;左值&lt;/code&gt;, 就对其执行&lt;code&gt;拷贝&lt;/code&gt;, 如果是右值, 就对其执行&lt;code&gt;移动&lt;/code&gt;呢?&lt;/p&gt;
&lt;p&gt;在C++11中, 这个问题的答案就是&lt;code&gt;右值引用&lt;/code&gt;. &lt;code&gt;右值引用&lt;/code&gt;是一种新的引用类型, 但它仅能绑定在&lt;code&gt;右值&lt;/code&gt;上, 语法是&lt;code&gt;T &amp;amp;&amp;amp;&lt;/code&gt;, 我们将原来C++03/98中的引用类型&lt;code&gt;T &amp;amp;&lt;/code&gt;称为&lt;code&gt;左值引用&lt;/code&gt;. (注意, &lt;code&gt;T &amp;amp;&amp;amp;&lt;/code&gt;不是&quot;对引用的引用&quot;, 就是&lt;code&gt;右值引用&lt;/code&gt;, C++中没有&quot;引用的引用&quot;这种东西).&lt;/p&gt;
&lt;p&gt;现在, 我们有两种引用: &lt;code&gt;左值引用&lt;/code&gt;与&lt;code&gt;右值引用&lt;/code&gt;, 如果再加上&lt;code&gt;const&lt;/code&gt;修饰符, 我们能得到四种引用类型, 下图是一个表格, 展示了何种表达式能绑定到何种引用上:&lt;/p&gt;
&lt;pre class=&quot;ascii&quot;&gt;
&lt;code&gt;            lvalue   const lvalue   rvalue   const rvalue
---------------------------------------------------------              
X&amp;amp;          yes
const X&amp;amp;    yes      yes            yes      yes
X&amp;amp;&amp;amp;                                 yes
const X&amp;amp;&amp;amp;                           yes      yes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是有点蛋疼呢? 其实实践中, 你完全可以把上表中的最后一行抹掉, &lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt;代表了一种对右值的, 不可更改其值的引用, 这种类型你告诉我有什么用?&lt;/p&gt;
&lt;p&gt;所以, &lt;code&gt;右值引用&lt;/code&gt;其实就是一种&lt;code&gt;引用类型&lt;/code&gt;, 但它仅能绑定在&lt;code&gt;右值&lt;/code&gt;上&lt;/p&gt;
&lt;p&gt;注意, 此时我们对值类别的讨论依然没有超出C++03的范畴, 我们仅是介绍了一种新的引用类型: &lt;code&gt;右值引用&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;隐式转换&quot;&gt;隐式转换&lt;/h2&gt;
&lt;p&gt;C++在进行函数调用的时候, 默认会执行一步类型转换, 比如下面就是一个生动的例子:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Fuck {
friend std::ostream &amp;amp; operator &amp;lt;&amp;lt; (std::ostream &amp;amp; out, const Fuck &amp;amp; fuck) {
    return out &amp;lt;&amp;lt; &quot;Fuck[&quot; &amp;lt;&amp;lt; fuck._name &amp;lt;&amp;lt; &quot;]&quot;;
}
private:
    std::string _name;
public:
    Fuck(const std::string &amp;amp; name) {        // 该构造函数可以在函数调用时, 将std::string隐式的转换成Fuck对象
        _name = name;
    }

};

// 这个函数接受右值引用参数
void Jesus(Fuck &amp;amp;&amp;amp; fuck) {
    std::cout &amp;lt;&amp;lt; fuck &amp;lt;&amp;lt; std::endl;
}

int main(void) {

    // 我们传递给Jesus的参数其实是 std::string 类型
    // 在函数调用时会被转换成 Fuck 类型
    // 并且由于表达式 std::string(&quot;shit&quot;) 是一个右值
    // 所以转换后的 Fuck 对象也是一个右值
    // 故能匹配调用Jesus成功
    Jesus(std::string(&quot;shit&quot;));

    // 这里的fuck是一个左值, 所以调用Jesus会失败, 因为Jesus仅接受右值引用参数
    // 左值是不能匹配函数参数表的
    Fuck fuck(&quot;you&quot;);
    Jesus(fuck);

    
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上例中的&lt;code&gt;Jesus&lt;/code&gt;函数接受右值引用参数, 但实际调用的时候我们传递的是&lt;code&gt;std::string(&quot;shit&quot;)&lt;/code&gt;, 这是一个类型为&lt;code&gt;std::string&lt;/code&gt;的右值, 但经过类型转换被转换成&lt;code&gt;Fuck&lt;/code&gt;类型, 这个过程中相当创建了两个临时对象:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;std::string(&quot;shit&quot;)&lt;/code&gt;创建了一个临时的&lt;code&gt;std::string&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Jesus&lt;/code&gt;函数的调用, 由于参数的自动类型转换, 相当于再创建了一个临时的&lt;code&gt;Fuck&lt;/code&gt;对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最终在函数内部, 右值引用参数绑定的是&lt;code&gt;2&lt;/code&gt;中创建的那个临时的&lt;code&gt;Fuck&lt;/code&gt;对象.&lt;/p&gt;
&lt;p&gt;上例中&lt;code&gt;Jesus(fuck)&lt;/code&gt;的调用是失败的, 并且无法成功编译, 原因在于&lt;code&gt;fuck&lt;/code&gt;是一个左值, 不匹配函数参数表.&lt;/p&gt;
&lt;h2 id=&quot;移动构造函数&quot;&gt;移动构造函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;右值引用&lt;/code&gt;一个很重要的应用场合就是作为构造函数的参数, 即所谓的&lt;code&gt;移动构造函数&lt;/code&gt;. 其目的是从右值中夺取资源初始化当前对象, 以节省拷贝开销.&lt;/p&gt;
&lt;p&gt;在C++11中, &lt;code&gt;std::auto_ptr&amp;lt;T&amp;gt;&lt;/code&gt;这个模板类被正式盖上了&lt;code&gt;废弃&lt;/code&gt;的章, 取而代之的是&lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt;, 上位的手段就是&lt;code&gt;右值引用&lt;/code&gt;. 下面我们会写一个简化版的&lt;code&gt;unique_ptr&lt;/code&gt;的实现, 首先, 我们需要将指针类型包裹起来, 并且重载&lt;code&gt;-&amp;gt;&lt;/code&gt;与&lt;code&gt;*&lt;/code&gt;操作符以提供更好的使用体验:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;typename T&amp;gt;
class unique_ptr{
private:
    T * _ptr;

public:
    T* operator-&amp;gt;() const {
        return _ptr;
    }
    
    T&amp;amp; operator*() const {
        return *_ptr;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后给它加上一个构造函数与析构函数, 构造函数的目的是接管对象, 析构函数用以释放对象:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    explicit unique_ptr(T * p = nullptr) {
        _ptr = p;
    }
    
    ~unique_ptr() {
        delete _ptr;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是有意思的地方: 我们来写一个移动构造函数:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    unique_ptr(unique_ptr &amp;amp;&amp;amp; source) {
        _ptr = source.ptr;
        source._ptr = nullptr;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;移动构造函数&lt;/code&gt;所做的事情, 其实就是上面我们说的&lt;code&gt;auto_ptr&lt;/code&gt;中的&lt;code&gt;拷贝构造函数&lt;/code&gt;做的事情, 但是: 这个&lt;code&gt;移动构造函数&lt;/code&gt;仅能通过&lt;code&gt;右值&lt;/code&gt;去调用. 这样就避免了像&lt;code&gt;auto_ptr&lt;/code&gt;那样, 掠夺左值内部资源的危险操作.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;unique_ptr&amp;lt;Shape&amp;gt; a(new Triangle);
unique_ptr&amp;lt;Shape&amp;gt; b(a);                 // 这一步调用不能成功, 因为a是一个左值, 并且我们没有定义任何拷贝构造函数
unique_ptr&amp;lt;Shape&amp;gt; c(make_triangle());   // 没有毛病, 因为表达式 `make_triangle()`的值是右值, c其实内部掠夺了`make_triangle()`表达式值的资源&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;b(a)&lt;/code&gt;是不能通过编译的, 这是因为:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于我们已经显式的定义了一个&lt;code&gt;移动构造函数&lt;/code&gt;, 所以编译器不再提供默认的&lt;code&gt;拷贝构造函数&lt;/code&gt;的实现&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt;是一个左值, 并不能匹配&lt;code&gt;移动构造函数&lt;/code&gt;. 而它想匹配的&lt;code&gt;拷贝构造函数&lt;/code&gt;, 没有实现&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这种行为就避免了像&lt;code&gt;auto_ptr&lt;/code&gt;那样, 对左值资源的错误掠夺&lt;/p&gt;
&lt;h2 id=&quot;移动赋值操作符&quot;&gt;移动赋值操作符&lt;/h2&gt;
&lt;p&gt;我在先前的陈述中一直避免使用&lt;code&gt;移动赋值操作符&lt;/code&gt;这个术语, 这是我个人的习惯, 因为我更习惯将其称之为&lt;code&gt;使用右值引用作为参数的=操作符重载&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;移动赋值操作符&lt;/code&gt;的目的是释放旧资源, 并从&lt;code&gt;=&lt;/code&gt;右边获取(夺取)新的资源. 下面我们给&lt;code&gt;unique_ptr&lt;/code&gt;实现一个&lt;code&gt;移动赋值操作符&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    unique_ptr &amp;amp; operator = (unique_ptr &amp;amp;&amp;amp; source) {
        if (this != &amp;amp;source) {
            delete ptr;
            ptr = source.ptr;
            source.ptr = nullptr;
        }
        return *this;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;copy-and-swap idiom&lt;/code&gt;中已经讲过了这种写法的缺陷, 上面的写法有两个特点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它仅能实现资源的移动, 真是&lt;code&gt;移动赋值操作符&lt;/code&gt;, 但并不能实现&lt;code&gt;拷贝赋值&lt;/code&gt;的语义. 即如果&lt;code&gt;=&lt;/code&gt;右边是一个左值, 会编译失败&lt;/li&gt;
&lt;li&gt;这个实现只是很直观的在向你展示&lt;code&gt;移动赋值操作符&lt;/code&gt;的语义&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;真正的良好实践, 如我们在&lt;code&gt;copy-and-swap idiom&lt;/code&gt;中讲的那样, 应当如下写:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;    unique_ptr &amp;amp; operator = (unique_ptr source) {
        std::swap(_ptr, source.ptr);
        return *this;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个写法有两个特点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;是否需要实现&lt;code&gt;拷贝&lt;/code&gt;语义, 要看&lt;code&gt;拷贝构造函数&lt;/code&gt;是否存在&lt;/li&gt;
&lt;li&gt;避免了代码重复, 异常不安全等缺陷.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这些内容在&lt;code&gt;copy-and-swap&lt;/code&gt;我们已经讲过了, 这里就不再重复陈述了.&lt;/p&gt;
&lt;h2 id=&quot;在左值上实施移动-掠夺左值的内部资源&quot;&gt;在左值上实施移动: 掠夺左值的内部资源&lt;/h2&gt;
&lt;p&gt;有时候我们确实想掠夺一个左值的资源, 并且我们确实明白这样做风险的话, C++11也为我们提供了一个途径: &lt;code&gt;std::move&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在继续讲之前我实再是忍不住要吐槽一下, 这就是C++吸引人的地方, 也是C++ Fucked up的地方: 真他妈是给你自由过了火, 你想怎么整都行, C++恨不得把挖祖坟的能力给你.&lt;/p&gt;
&lt;p&gt;在头文件&lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;中, C++11新提供了一个标准库设计:模板函数&lt;code&gt;std::move&lt;/code&gt;. 坦白讲这个模板函数的名字取的非常有误导性, 其实&lt;code&gt;std::move&lt;/code&gt;并不实施任何与&lt;code&gt;移动&lt;/code&gt;有关的操作, 它的功能仅是把一个&lt;code&gt;左值&lt;/code&gt;, 转换成一个&lt;code&gt;右值&lt;/code&gt;, 从而使得可以调用仅接受&lt;code&gt;右值引用&lt;/code&gt;的函数. 其实讲道理这个模板函数应该把名字取成&lt;code&gt;std::cast_to_rvalue&lt;/code&gt;或&lt;code&gt;std::enable_move&lt;/code&gt;, 但标准已经是这样了, 咱就少吐槽乖乖接受算了.&lt;/p&gt;
&lt;p&gt;下面是如何使用它的示例:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;unique_ptr&amp;lt;std::string&amp;gt; a(new string(&quot;fuck&quot;));
unique_ptr&amp;lt;std::string&amp;gt; b(a);                   // 按先前的讲解, 我们知道这一句会编译错误, 因为unique_ptr并没有实现拷贝构造函数, 而a是一个左传
unique_ptr&amp;lt;std::string&amp;gt; c(std::move(a));        // 这样就可以通过编译了, 但这是一个危险操作: a中的资源被掠夺了, 像我们在讨论auto_ptr的实现时那样&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;将亡值xvalue&quot;&gt;将亡值(&lt;code&gt;xvalue&lt;/code&gt;)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;std::move&lt;/code&gt;最神奇的一点就是, 虽然&lt;code&gt;std::move&lt;/code&gt;从表面上把一个&lt;code&gt;左值&lt;/code&gt;改成了一个&lt;code&gt;右值&lt;/code&gt;, 但&lt;code&gt;std::move&lt;/code&gt;本身并没有创建一个新的临时对象. 是的, &lt;code&gt;std::move&lt;/code&gt;的求值结果, 本质上还是指向之前的那个对象, 那么, &lt;code&gt;std::move&lt;/code&gt;的运算结果, 到底算是&lt;code&gt;左值&lt;/code&gt;, 还是&lt;code&gt;右值&lt;/code&gt;呢?&lt;/p&gt;
&lt;p&gt;在C++11中, &lt;code&gt;std::move&lt;/code&gt;的运算结果, 是一种全新的值类别, 叫&lt;code&gt;将亡值(xvalue,(eXpiring value))&lt;/code&gt;. , 所以让人头大的事情就来了: 先来看下面这张图:&lt;/p&gt;
&lt;pre class=&quot;ascii&quot;&gt;
&lt;code&gt;        expressions
          /     \
         /       \
        /         \
    glvalues   rvalues
      /  \       /  \
     /    \     /    \
    /      \   /      \
lvalues   xvalues   prvalues&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最底层的三种值类型, 是C++11中每个表达式的值类别: 你要么是一个&lt;code&gt;lvalue(左值)&lt;/code&gt;, 要么是一个&lt;code&gt;xvalue(将亡值)&lt;/code&gt;, 要么是一个&lt;code&gt;prvalue(纯右值)&lt;/code&gt;. 其中&lt;code&gt;lvalue&lt;/code&gt;就是C++03中的&lt;code&gt;左值&lt;/code&gt;, 而&lt;code&gt;prvalue&lt;/code&gt;就是C++03中的&lt;code&gt;右值&lt;/code&gt;. 而&lt;code&gt;xvalue&lt;/code&gt;, 则是一个全新的概念: 你可以暂时将它理解为, &lt;code&gt;std::move&lt;/code&gt;的值类别.&lt;/p&gt;
&lt;h2 id=&quot;函数返回值的移动大坑&quot;&gt;函数返回值的移动(大坑)&lt;/h2&gt;
&lt;p&gt;截止目前, 我们对&lt;code&gt;移动语义&lt;/code&gt;的讨论还未涉及函数返回, 下面是一个函数返回时移动资源的例子:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;unique_ptr&amp;lt;Shape&amp;gt; make_triangle()
{
    return unique_ptr&amp;lt;Shape&amp;gt;(new Triangle);
}          \-----------------------------/
                  |
                  | return 语句中创建的临时对象中的资源, 被移动到了c中
                  | 这个过程和移动构造函数无关, 是编译器的优化行为
                  v
unique_ptr&amp;lt;Shape&amp;gt; c(make_triangle());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数返回的过程中, &lt;code&gt;make_triangle&lt;/code&gt;返回的是一个临时量, 用这个临时量去初始化&lt;code&gt;c&lt;/code&gt;时, 编译器会自动将临时量的资源移动给&lt;code&gt;c&lt;/code&gt;, 特别吊诡的事情是: 这个移动操作的过程, 移动构造函数并没有参与, 拷贝构造函数也没有参与!&lt;/p&gt;
&lt;p&gt;函数按值返回时, 发生的诡异的&lt;code&gt;移动&lt;/code&gt;行为, 与&lt;code&gt;右值引用&lt;/code&gt;无关, 和C++11甚至都没有关系, 这就是一个编译器的优化行为, 这个优化行为诡异的点在于:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按C++98或03标准的眼光去看, &lt;code&gt;c&lt;/code&gt;的初始化应当调用拷贝构造函数. 但实际上, 并没有&lt;/li&gt;
&lt;li&gt;按C++11标准的眼光去看, &lt;code&gt;c&lt;/code&gt;的初始化应当调用移动构造函数. 但实际上, 也没有&lt;/li&gt;
&lt;li&gt;既然既没调用拷贝构造函数, 也没调用移动构造函数, 好吧你编译器要搞黑魔法你去搞, 那我把拷贝构造函数和移动构造函数都声明为&lt;code&gt;delete&lt;/code&gt;行不行呢? 不行, 编译器(至少是&lt;code&gt;gcc&lt;/code&gt;)会提示你: 类缺乏拷贝构造函数, 故函数无法返回.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;编译器看起来让你以为, 它在调用拷贝构造函数或者移动构造函数, 但实际上并没有. 它内部实现了一个很诡异的移动操作: 是的, 这个临时量持有的资源, 被转交给了&lt;code&gt;c&lt;/code&gt;. 而不是拷贝.&lt;/p&gt;
&lt;p&gt;更诡异的事情在下面: 你按值将一个函数内部的自动变量返回的时候, 编译器都会进行资源的&lt;code&gt;移动&lt;/code&gt;操作!!!&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;unique_ptr&amp;lt;Shape&amp;gt; make_square()
{
    unique_ptr&amp;lt;Shape&amp;gt; result(new Square);
    return result;
}          \----/
              |
              |    编译器将result的资源交给了d, 是移动
              |    是的, 是那种既不调移动构造函数, 也不调拷贝构造函数的, 诡异的移动
              v
unique_ptr&amp;lt;Shape&amp;gt; d(make_square());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个编译器的鬼逻辑是这样的: 虽然从函数内部看, &lt;code&gt;result&lt;/code&gt;是一个变量, 一个左值, 但从函数外部调用来看, &lt;code&gt;result&lt;/code&gt;的生命周期也是短暂的, 函数调用结束后, 它就不存在了. 这和临时量很像, 所以, 我将这个&lt;code&gt;result&lt;/code&gt;中的资源剥夺出来, 是一种安全的行为.&lt;/p&gt;
&lt;p&gt;从下面这个简单而又完整的例子你就会看到: 函数返回时, 返回值本身就是按&lt;code&gt;移动&lt;/code&gt;返回的, 这种&lt;code&gt;移动&lt;/code&gt;甚至更高级: 被返回的变量, 无论是自动变量还是临时变量, 其实并没有在函数退栈的时候被析构, 这种被返回的变量, 是真真切切的存在于内存中, 只是把其&lt;code&gt;名字&lt;/code&gt;改成了返回值的接收者! 这个点并不容易被人理解, 特别是对函数调用在汇编层面上的原理不熟悉的人来说, 显得特别诡异.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

struct POD{
    int _f1;
    int _f2;
};

class Foo {
public:
    POD* _pod;

public:
    // 默认构造函数
    Foo() {
        _pod = new POD{1,2};
        std::cout &amp;lt;&amp;lt; &quot;constructor: _pod == &quot; &amp;lt;&amp;lt; _pod &amp;lt;&amp;lt; std::endl;
    }

    // 拷贝构造函数
    Foo(const Foo &amp;amp; foo) {
        std::cout &amp;lt;&amp;lt; &quot;copy constructor&quot; &amp;lt;&amp;lt; std::endl;
        _pod = new POD{
            foo._pod-&amp;gt;_f1,
            foo._pod-&amp;gt;_f2,
        };
    }

    // 移动构造函数
    Foo(Foo &amp;amp;&amp;amp; foo) {
        std::cout &amp;lt;&amp;lt; &quot;move constructor&quot; &amp;lt;&amp;lt; std::endl;
        _pod = foo._pod;
        foo._pod = nullptr;
    }

    // 拷贝赋值操作符
    Foo&amp;amp; operator = (const Foo &amp;amp; foo) {
        if(this != &amp;amp;foo) {
            _pod = new POD{
                foo._pod-&amp;gt;_f1,
                foo._pod-&amp;gt;_f2,
            };
        }

        return *this;
    }

    // 移动赋值操作符
    Foo&amp;amp; operator =(Foo &amp;amp;&amp;amp; foo) {
        _pod = foo._pod;
        foo._pod = nullptr;
        return *this;
    }

    // 析构函数
    ~Foo() {
        std::cout &amp;lt;&amp;lt; &quot;destructor: _pod == &quot; &amp;lt;&amp;lt; _pod &amp;lt;&amp;lt; std::endl;
        delete _pod;
        _pod = nullptr;
    }
};

Foo ReturnAutoVariableFooFromFunc() {
    std::cout &amp;lt;&amp;lt; &quot;create auto variable inside func then return it&quot; &amp;lt;&amp;lt; std::endl;
    Foo foo;    // 调用默认构造函数
    return foo; // &amp;lt;- 这里并没有对foo这个内部变量的析构操作
}

Foo ReturnTempVariableFooFromFunc() {
    std::cout &amp;lt;&amp;lt; &quot;create temp variable inside func then return it&quot; &amp;lt;&amp;lt; std::endl;
    return Foo(); // &amp;lt;- 这里也并没有对Foo()表达式创建的临时变量的析构操作
}

int main(void) {
    Foo foo = ReturnAutoVariableFooFromFunc();
    std::cout &amp;lt;&amp;lt; &quot;foo._pod outside function == &quot; &amp;lt;&amp;lt; foo._pod &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;--------------------&quot; &amp;lt;&amp;lt; std::endl;

    Foo foo2(ReturnAutoVariableFooFromFunc());
    std::cout &amp;lt;&amp;lt; &quot;foo2._pod outside function == &quot; &amp;lt;&amp;lt; foo2._pod &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;--------------------&quot; &amp;lt;&amp;lt; std::endl;

    Foo foo3 = ReturnTempVariableFooFromFunc();
    std::cout &amp;lt;&amp;lt; &quot;foo3._pod outside function == &quot; &amp;lt;&amp;lt; foo3._pod &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;--------------------&quot; &amp;lt;&amp;lt; std::endl;

    Foo foo4(ReturnTempVariableFooFromFunc());
    std::cout &amp;lt;&amp;lt; &quot;foo4._pod outside function == &quot; &amp;lt;&amp;lt; foo4._pod &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;--------------------&quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的输出长下面这样:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;create auto variable inside func then return it
constructor: _pod == 0x1ae9010
foo._pod outside function == 0x1ae9010              &amp;lt;- 观察这里, 并没有对析构函数的调用, 并没有对拷贝构造函数或移动构造函数的调用
--------------------
create auto variable inside func then return it
constructor: _pod == 0x1ae9030
foo2._pod outside function == 0x1ae9030             &amp;lt;- 观察这里, 并没有对析构函数的调用, 并没有对拷贝构造函数或移动构造函数的调用
--------------------
create temp variable inside func then return it
constructor: _pod == 0x1ae9050
foo3._pod outside function == 0x1ae9050             &amp;lt;- 观察这里, 并没有对析构函数的调用, 并没有对拷贝构造函数或移动构造函数的调用
--------------------
create temp variable inside func then return it
constructor: _pod == 0x1ae9070  
foo4._pod outside function == 0x1ae9070             &amp;lt;- 观察这里, 并没有对析构函数的调用, 并没有对拷贝构造函数或移动构造函数的调用
--------------------
destructor: _pod == 0x1ae9070
destructor: _pod == 0x1ae9050
destructor: _pod == 0x1ae9030
destructor: _pod == 0x1ae9010                       &amp;lt;- 这里倒是有四个次析构, 不过这是由于main函数退栈而对 foo/foo2/foo3/foo4 的析构
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而, 更大的坑在这里: C++11引入了右值引用, 我能不能手动的, 显式的返回一个右值引用, 将函数内部的临时量, 或自动变量的资源, 交给调用者呢? 答案是: 不行.&lt;/p&gt;
&lt;p&gt;我们在上面那个小例子的基础上, 写这样的一个函数, 然后试图去调用它:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Foo &amp;amp;&amp;amp; TryToReturnAnRvalueReference() {
    std::cout &amp;lt;&amp;lt; &quot;create auto variable inside func then return std::move(it)&quot; &amp;lt;&amp;lt; std::endl;
    Foo foo;
    return std::move(foo);
}

int main(void) {
    Foo foo5 = TryToReturnAnRvalueReference();
    std::cout &amp;lt;&amp;lt; &quot;foo5._pod outside function == &quot; &amp;lt;&amp;lt; foo5._pod &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;--------------------&quot; &amp;lt;&amp;lt; std::endl;

    Foo foo6(TryToReturnAnRvalueReference());
    std::cout &amp;lt;&amp;lt; &quot;foo6._pod outside function == &quot; &amp;lt;&amp;lt; foo6._pod &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; &quot;--------------------&quot; &amp;lt;&amp;lt; std::endl;

    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的输出在不同的编译器下面还有点不一样, 在clang++ 3.4.2编译后, 长下面这样:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;create auto variable inside func then return std::move(it)
constructor: _pod == 0x1b0a010
destructor: _pod == 0x1b0a010                               &amp;lt;- 观察这里, 函数内的自动变量在返回之前就析构了
move constructor                                            &amp;lt;- 完事在这里调用了移动构造函数. 将一个已经不存在(已被析构)的对象中的已被释放(被析构函数释放)的资源进行移动
foo5._pod outside function == 0x7ffd16ec8a60                &amp;lt;- 导致main中的foo5已经放飞自我了
--------------------
create auto variable inside func then return std::move(it)
constructor: _pod == 0x1b0a010
destructor: _pod == 0x1b0a010                               &amp;lt;- 和foo5的症状基本一样
move constructor
foo6._pod outside function == 0x7ffd16ec8a48
--------------------
destructor: _pod == 0x7ffd16ec8a48
*** Error in `./bin/hello': free(): invalid pointer: 0x00007ffd16ec8a48 ***
======= Backtrace: =========
//.... 输出了错误发生时的调用栈
======= Memory map: ========
//.... 输出了错误发生时的进程内存表&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;clang++的编译二进制在运行后, 通过&lt;code&gt;echo $?&lt;/code&gt;查看二进制的最终返回值, 会发现进程临死前发出的呻吟错误码不为0, 也就是说, clang认为这是一段导致进程crash掉的代码.&lt;/p&gt;
&lt;p&gt;而上面这段代码经过g++ 4.8.5编译后, 输出长下面这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;create auto variable inside func then return std::move(it)
constructor: _pod == 0x9c6010
destructor: _pod == 0x9c6010                                &amp;lt;- 观察这里, 函数内的自动变量在返回之前就析构了
move constructor
foo5._pod outside function == 0                             &amp;lt;- main中的foo5没有放飞自我, 而是其资源句柄_pod字段的值, 被移动构造函数置为了0. 
--------------------                                           合理的解释就是, 函数内的自动变量在析构之后, 内存置0了而已
create auto variable inside func then return std::move(it)
constructor: _pod == 0x9c6010
destructor: _pod == 0x9c6010
move constructor
foo6._pod outside function == 0
--------------------
destructor: _pod == 0
destructor: _pod == 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;g++编译的二进制在运行后, 通过&lt;code&gt;echo $?&lt;/code&gt;查看二进制的最终返回值, 是0, 也就是说, g++暂且不认为进程崩掉了. 但这也并不代码你用g++来做开发工作就能写这样的代码!!&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上面的编译过程中, 编译参数中的 &lt;code&gt;-O&lt;/code&gt;均被设置为&lt;code&gt;-O0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下, 截止目前为止, C++11提供的所谓的&lt;code&gt;右值引用&lt;/code&gt;+&lt;code&gt;移动语义&lt;/code&gt;, 只能用在两个场合:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;函数调用时的参数传递(通过&lt;code&gt;移动构造函数&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;对象之间的相互拷贝(通过&lt;code&gt;移动赋值操作符&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而关于函数返回这里, 从C语言一路沿袭下来的内存模型(函数退栈返回的时候, 返回值对象在内存或寄存器中, 是直接改名&quot;移动&quot;的, 而不是进行拷贝, 这是编译器的成果: 汇编层面的行为, 与程序员写的任何构造函数都没关系)决定了, 这和C++11中的&lt;code&gt;右值引用&lt;/code&gt;或&lt;code&gt;移动语义&lt;/code&gt;没有任何卵关系. 当然, 右值引用在一些很特殊的条件下, 可以作为函数的返回值, 但最佳实践的建议是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不要这样做&lt;/li&gt;
&lt;li&gt;如果你非要这样做, 不要用&lt;code&gt;std::move(函数中的自动变量或临时变量)&lt;/code&gt;这种方式去返回&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;将资源移动给类成员小坑&quot;&gt;将资源移动给类成员(小坑)&lt;/h2&gt;
&lt;p&gt;我们来看下面这段代码, 然后你猜一猜它能不能编译通过, 为了你阅读方便, 我把完整的&lt;code&gt;unique_ptr&lt;/code&gt;的定义都附带上了:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;utility&amp;gt;

template&amp;lt;typename T&amp;gt;
class unique_ptr{
private:
    T * _ptr;

public:
    // 解引用操作符重载
    T* operator-&amp;gt;() const { return _ptr; }
    
    // 取地址操作符重载
    T&amp;amp; operator*() const { return *_ptr; }

    // 构造函数(默认构造函数)
    explicit unique_ptr(T * p = nullptr) { _ptr = p; }

    // 拷贝构造函数被显式删除
    unique_ptr(const unique_ptr &amp;amp; other) = delete;
    
    // 析构函数
    ~unique_ptr() { delete _ptr; }

    // 移动构造函数
    unique_ptr(unique_ptr &amp;amp;&amp;amp; source) { _ptr = source._ptr; source._ptr = nullptr; }

    // 移动赋值操作符, 使用了 copy-and-swap idiom
    unique_ptr &amp;amp; operator = (unique_ptr source) { std::swap(_ptr, source.ptr); return *this; }
};

class Foo {
private:
    unique_ptr&amp;lt;int&amp;gt; _member;

public:
    // 构造函数
    Foo(unique_ptr&amp;lt;int&amp;gt; &amp;amp;&amp;amp; param) :
        _member(param)                  // &amp;lt;-- 关键在这里, 编译错误在这里
    {
        
    }
};

int main(void) {
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果是不能编译通过的, 编译器(g++ 4.8.5)给出的错误提示大致如下:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;main.cpp: In constructor ‘Foo::Foo(unique_ptr&amp;lt;int&amp;gt;&amp;amp;&amp;amp;)’:
main.cpp:39:22: error: use of deleted function ‘unique_ptr&amp;lt;T&amp;gt;::unique_ptr(const unique_ptr&amp;lt;T&amp;gt;&amp;amp;) [with T = int]’
         _member(param)
                      ^
main.cpp:20:5: error: declared here
     unique_ptr(const unique_ptr &amp;amp; other) = delete;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来看看&lt;code&gt;clang++ 3.4.2&lt;/code&gt;给出的错误提示信息吧:&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;main.cpp:39:9: error: call to deleted constructor of 'unique_ptr&amp;lt;int&amp;gt;'
        _member(param)
        ^       ~~~~~
main.cpp:20:5: note: function has been explicitly marked deleted here
    unique_ptr(const unique_ptr &amp;amp; other) = delete;
    ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看来这次gcc与clang算是达成一致了.&lt;/p&gt;
&lt;p&gt;编译器的意思是说, 你试图在&lt;code&gt;_member(param)&lt;/code&gt;这一行调用一个已经被删除的拷贝构造函数. 但是这很不符合我们的直觉: 我们认为&lt;code&gt;param&lt;/code&gt;是一个右值引用啊, 我们试图调用的是&lt;code&gt;移动构造函数&lt;/code&gt;, 而不是被显式删除的&lt;code&gt;拷贝构造函数&lt;/code&gt;, 这是怎么回事呢?&lt;/p&gt;
&lt;p&gt;原因在于, 编译器认为, &lt;code&gt;param&lt;/code&gt;是一个左值...其内在逻辑是这样的:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;param&lt;/code&gt;作为一个形参, 被声明为&lt;code&gt;右值引用&lt;/code&gt;类型, 这包含了两个意思:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你只能用一个&lt;code&gt;右值引用&lt;/code&gt;去初始化&lt;code&gt;param&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;param&lt;/code&gt;本身并不是一个&lt;code&gt;右值引用&lt;/code&gt;. 相反, 它是一个普通的&lt;code&gt;左值&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以, 上面代码编译失败的原因在于: 你试图用一个&lt;code&gt;左值&lt;/code&gt;(&lt;code&gt;param&lt;/code&gt;)去初始化&lt;code&gt;_member&lt;/code&gt;成员, 但&lt;code&gt;_member&lt;/code&gt;成员所属的类, 并没有实现拷贝构造函数!&lt;/p&gt;
&lt;p&gt;有点想骂人是吧? 所以, 核心逻辑在于, 我再换个说法再说一遍: &lt;strong&gt;&lt;code&gt;右值引用参数&lt;/code&gt;限定了只能通过&lt;code&gt;右值引用&lt;/code&gt;去初始化这个参数, 但这个参数其实是个&lt;code&gt;左值&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显然这种逻辑有点不合理, 那么如何才能把我们上面的代码改正确呢? 这时候就要祭出&lt;code&gt;std::move&lt;/code&gt;了, 如下修改即可:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Foo {
private:
    unique_ptr&amp;lt;int&amp;gt; _member;

public:
    // 构造函数
    Foo(unique_ptr&amp;lt;int&amp;gt; &amp;amp;&amp;amp; param) :
        _member(std::move(param))                  // &amp;lt;-- 你说你是左值是吧? 我把你强转成xvalue
    {
        
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;特殊的成员函数&quot;&gt;特殊的成员函数&lt;/h2&gt;
&lt;p&gt;C++98标准定义了三个特殊的类内成员函数, 并且一直沿用至C++03标准, 这三个特殊的成员函数分别是:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;X::X(const X&amp;amp;);&lt;/code&gt; 拷贝构造函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&amp;amp; X::operator=(const X&amp;amp;);&lt;/code&gt; 拷贝赋值操作符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X::~X();&lt;/code&gt; 析构函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;C++11标准由于&lt;code&gt;右值引用&lt;/code&gt;与&lt;code&gt;移动语义&lt;/code&gt;的引入, 追加了两个特殊的类内成员函数:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;X::X(X&amp;amp;&amp;amp;);&lt;/code&gt; 移动构造函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&amp;amp; X::operator=(X&amp;amp;&amp;amp;);&lt;/code&gt; 移动赋值操作符&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于特殊成员函数, 编译器在某些情况下会提供默认实现, 规则如下:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编译器仅在&lt;em&gt;以上五个特殊的成员函数都没有声明实现的时候&lt;/em&gt;, 才会去默认给你生成一个&lt;code&gt;默认的移动构造函数&lt;/code&gt;与&lt;code&gt;默认的移动赋值操作符&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;一旦你自己实现了&lt;code&gt;移动构造函数&lt;/code&gt;, 或&lt;code&gt;移动赋值操作符&lt;/code&gt;. 编译器就不会给你生成&lt;code&gt;拷贝构造函数&lt;/code&gt;与&lt;code&gt;拷贝赋值操作符&lt;/code&gt;的默认实现&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么, 在日常实践中, 应当怎么做呢? 很简单:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;if(类内没有掌管任何资源) {
    五个特殊成员函数一个都不用实现, 编译器自动提供的默认实现就完全够用
    并且你能从其提供的默认移动构造函数与默认移动赋值操作符中获得性能提升
} else if(类掌管了资源){
    if (拷贝资源的开销 &amp;gt; 移动资源的开销) {
        五个特殊成员函数都实现一遍, 当然具体实践的时候可以采用 rule of four and a half的方式, 不实现移动赋值操作符
    } else {
        仅实现三个古典的特殊成员函数. 不需要实现移动构造函数和移动赋值操作符
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在&lt;code&gt;copy-and-swap idom&lt;/code&gt;中说过, &lt;code&gt;rule of five&lt;/code&gt;可以被简化为&lt;code&gt;rule of four and a half&lt;/code&gt;, 这里再重温一遍, 这种最佳实践下, 你无需显式实现&lt;code&gt;移动赋值操作符&lt;/code&gt;, 仅需要如下实现一个&lt;code&gt;赋值操作符的重载&lt;/code&gt;即可:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;X&amp;amp; X::operator=(X source)
{
    swap(source);
    return *this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;引用转发&quot;&gt;引用转发&lt;/h2&gt;
&lt;p&gt;来看下面这个模板函数的签名:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;typename T&amp;gt;
void foo(T&amp;amp;&amp;amp;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一眼看上去, 你可以会认为, 这个模板函数的形式参数类型是为&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, 这显然是一个右值引用嘛, 所以你会认为: 要调用这个模板函数, 必须使用&lt;code&gt;右值引用&lt;/code&gt;作为参数.&lt;/p&gt;
&lt;p&gt;但实际情况是: 你竟然可以使用&lt;code&gt;左值&lt;/code&gt;去调用这个模板函数..&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
void foo(T&amp;amp;&amp;amp; t) {
    std::cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; std::endl;
}

int main(void) {
    foo(23);

    foo(&quot;i love you&quot;);

    int a = 2333;

    foo(a);         // &amp;lt;-- 可以使用一个左值去调用foo模板函数!
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这他妈的....先骂会娘..&lt;/p&gt;
&lt;p&gt;那么到底是哪个环节出了问题呢? 明明我形参的类型写的是&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, 是显而易见的&lt;code&gt;右值引用&lt;/code&gt;类型的形参啊!! 问题出在模板函数的类型推导上了..这里的逻辑是这样的:&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;foo(23)&lt;/code&gt;的调用中, 参数是&lt;code&gt;int&lt;/code&gt;的左值, 所以模板类型&lt;code&gt;T&lt;/code&gt;被推导为&lt;code&gt;int&lt;/code&gt;, 所以整个模板函数会被实例化为&lt;code&gt;void foo(int&amp;amp;&amp;amp; t)&lt;/code&gt;, 没有任何毛病, 这个模板函数的实例确实是个&lt;code&gt;接受右值引用类型参数&lt;/code&gt;的函数&lt;/p&gt;
&lt;p&gt;但在&lt;code&gt;foo(a)&lt;/code&gt;的调用中, 参数是&lt;code&gt;int&lt;/code&gt;类型的左值, 这里由于模板函数类型推导的一个特殊规则, 模板函数的类型参数&lt;code&gt;T&lt;/code&gt;实质上会被推导为&lt;code&gt;int &amp;amp;&lt;/code&gt;类型, 而不是&lt;code&gt;int&lt;/code&gt;. 现在问题来了: 如果&lt;code&gt;T&lt;/code&gt;被推导成了&lt;code&gt;int &amp;amp;&lt;/code&gt;, 那么, &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;的意思难道是&lt;code&gt;int&amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;吗? 这是什么鬼玩意?&lt;/p&gt;
&lt;p&gt;C++中并不存在一种类型, 可以后面带三个&lt;code&gt;&amp;amp;&lt;/code&gt;, 真实的&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;被降格为&lt;code&gt;int &amp;amp;&lt;/code&gt;, 换句话说, &lt;code&gt;foo(a)&lt;/code&gt;调用的那个实例函数, 它其实长这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void foo(int &amp;amp; t) {
    std::cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; std::endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种从&lt;code&gt;int &amp;amp; &amp;amp;&amp;amp;&lt;/code&gt;降格到&lt;code&gt;int &amp;amp;&lt;/code&gt;的类型推导过程, 被称为&lt;code&gt;collapsed&lt;/code&gt;. 这个类型推导过程中的特殊逻辑, 是C++11中另外一个新特性: &lt;code&gt;完美转发(perfect forwarding)&lt;/code&gt;的基石.&lt;/p&gt;
&lt;p&gt;那么如果你真的想写一个函数模板, 让它的参数仅接受&lt;code&gt;右值引用&lt;/code&gt;, 正确的写法应该怎么写呢? 正确的写法如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;type_traits&amp;gt;

template&amp;lt;typename T&amp;gt;
typename std::enable_if&amp;lt;std::is_rvalue_reference&amp;lt;T&amp;amp;&amp;amp;&amp;gt;::value, void&amp;gt;::type
foo(T&amp;amp;&amp;amp;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面就是生动的例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;type_traits&amp;gt;

template&amp;lt;typename T&amp;gt;
typename std::enable_if&amp;lt;std::is_rvalue_reference&amp;lt;T&amp;amp;&amp;amp;&amp;gt;::value, void&amp;gt;::type
foo(T&amp;amp;&amp;amp; t) {
    std::cout &amp;lt;&amp;lt; t &amp;lt;&amp;lt; std::endl;
}

int main(void) {
    foo(23);

    int a = 2333;
    foo(a);         // &amp;lt;-- 编译失败

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译失败的信息如下(clang 3.4.2):&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;main.cpp:14:5: error: no matching function for call to 'foo'
    foo(a);         // &amp;lt;-- 编译失败
    ^~~
main.cpp:5:25: note: candidate template ignored: disabled by 'enable_if' [with T = int &amp;amp;]
typename std::enable_if&amp;lt;std::is_rvalue_reference&amp;lt;T&amp;amp;&amp;amp;&amp;gt;::value, void&amp;gt;::type
                        ^&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个写法为什么会生效, 是一个比较复杂的问题, 有兴趣的话可以去研究一下头文件&lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt;中的内容. 这里就不展开了.&lt;/p&gt;
&lt;h2 id=&quot;stdmove的实现&quot;&gt;&lt;code&gt;std::move&lt;/code&gt;的实现&lt;/h2&gt;
&lt;p&gt;通过上面的陈述, 你明白了在模板参数的类型推导中, 有一个特殊逻辑叫&lt;code&gt;collapsed&lt;/code&gt;, 而其实&lt;code&gt;std::move&lt;/code&gt;的实现就与这个特性有关, 下面就是&lt;code&gt;std::move&lt;/code&gt;的源代码:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;typename _Tp&amp;gt;
    constexpr typename std::remove_reference&amp;lt;_Tp&amp;gt;::type&amp;amp;&amp;amp;
    move(_Tp&amp;amp;&amp;amp; __t) noexcept
    { return static_cast&amp;lt;typename std::remove_reference&amp;lt;_Tp&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(__t); }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是原样复制自&lt;code&gt;libstdc++ 4.8.5&lt;/code&gt;中的源代码, 将它稍微修整一下, 长这样:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;typename T&amp;gt;
typename std::remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;
move(T&amp;amp;&amp;amp; t)
{
    return static_cast&amp;lt;typename std::remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来解读一波:&lt;/p&gt;
&lt;p&gt;首先, 由于&lt;code&gt;(T&amp;amp;&amp;amp; t)&lt;/code&gt;的参数类型声明, 与&lt;code&gt;collapsed&lt;/code&gt;的推断规则, 我们可以知道, &lt;code&gt;move&lt;/code&gt;其实可以接受任何类型的参数.&lt;/p&gt;
&lt;p&gt;其次, 它的返回值类型是为 &lt;code&gt;typename std::remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&lt;/code&gt;, 其中&lt;code&gt;std::remove_reference&amp;lt;T&amp;gt;::type&lt;/code&gt;保证了在入参为&lt;code&gt;int &amp;amp;&lt;/code&gt;类型的情况下, 返回值类型是&lt;code&gt;int&amp;amp;&amp;amp;&lt;/code&gt;, 即始终保证返回值是&lt;code&gt;右值引用&lt;/code&gt;类型&lt;/p&gt;
&lt;p&gt;最后, 函数内部的具体实现, 其实就是调用&lt;code&gt;static_cast&lt;/code&gt;将入参强转为&lt;code&gt;右值引用&lt;/code&gt;. 由于在函数内部, 形参&lt;code&gt;t&lt;/code&gt;已经被初始化为一个左值引用, 根据&lt;code&gt;collapsed&lt;/code&gt;可知, 它在函数内部是一个左值(如果引发类型推断的实参是&lt;code&gt;int&lt;/code&gt;类型, 则形参会被推导为&lt;code&gt;int &amp;amp;&amp;amp; t&lt;/code&gt;, 但在被初始化后, t就是一个左值引用. 如果引发类型推断的实参是&lt;code&gt;int &amp;amp;&lt;/code&gt;类型, 则形参由于&lt;code&gt;collapsed&lt;/code&gt;会被推断为&lt;code&gt;int &amp;amp; t&lt;/code&gt;, 在被初始化后, t还是一个左值引用). 所以, 这里先用&lt;code&gt;std::remove_reference&lt;/code&gt;脱掉引用, 再用&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;将其强转为右值引用.&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 14:09:00 +0000</pubDate>
<dc:creator>张浮生</dc:creator>
<og:description>本文主要介绍了C++11中的 与`右值引用 rule of three/five copy and swap idiom`最佳实践. 本文参考了stackoverflow上的一些回答. 不能算是完全原</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/neooelric/p/10878394.html</dc:identifier>
</item>
<item>
<title>TestNg之XMl形式实现多线程测试 - Refain</title>
<link>http://www.cnblogs.com/longronglang/p/10878262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longronglang/p/10878262.html</guid>
<description>&lt;h3&gt;为什么要使用多线程测试？&lt;/h3&gt;
&lt;p&gt;在实际测试中，为了节省测试时间，提高测试效率，在实际测试场景中经常会采用多线程的方式去执行，比如爬虫爬数据，多浏览器并行测试。&lt;/p&gt;
&lt;h3&gt;关于多线程并行测试&lt;/h3&gt;
&lt;p&gt;TestNG中实现多线程并行执行，可以通过以下几种方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Test注解的形式&lt;/li&gt;
&lt;li&gt;Xml文件的配置的形式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文着重介绍下以xml形式实现多线程测试的方法，来让我们开始吧&lt;/p&gt;
&lt;h3&gt;如何实现？&lt;/h3&gt;
&lt;h4&gt;1、编写测试类&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.testng.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.testng.annotations.Test;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MultiThreadedByXml {

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1() {
        System.out.println(&lt;/span&gt;&quot;Thread id is &quot; +&lt;span&gt; Thread.currentThread().getId());
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
        System.out.println(&lt;/span&gt;&quot;Thread id is &quot; +&lt;span&gt; Thread.currentThread().getId());
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3() {

        System.out.println(&lt;/span&gt;&quot;Thread id is &quot; +&lt;span&gt; Thread.currentThread().getId());

    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test4() {
        System.out.println(&lt;/span&gt;&quot;Thread id is &quot; +&lt;span&gt; Thread.currentThread().getId());
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test5() {
        System.out.println(&lt;/span&gt;&quot;Thread id is &quot; +&lt;span&gt; Thread.currentThread().getId());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2、编写testng.xml文件&lt;/h4&gt;
&lt;p&gt;在&amp;lt;suite&amp;gt;标签中用parallel和thread-count两个属性声明多线程：parallel代表级别，thread-count代表最大并发线程数。&lt;/p&gt;
&lt;h4&gt;3、tests级别测试&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;不同的test标签(tag)下的用例可以在不同的线程下执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;suite &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sml多线程测试&quot;&lt;/span&gt;&lt;span&gt; parallel&lt;/span&gt;&lt;span&gt;=&quot;tests&quot;&lt;/span&gt;&lt;span&gt; thread-count&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;test &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;threadTest1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.testng.demo.MultiThreadedByXml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;suite&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过xml运行效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190516212550043-625982859.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;相同的test标签(tag)下的用例只能在同一个线程中去执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;suite &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sml多线程测试&quot;&lt;/span&gt;&lt;span&gt; parallel&lt;/span&gt;&lt;span&gt;=&quot;tests&quot;&lt;/span&gt;&lt;span&gt; thread-count&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;test &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;threadTest1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.testng.demo.MultiThreadedByXml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.testng.demo.MultiThreadedByXml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;suite&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过xml运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190516212949785-671323657.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;4、methods级别测试&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;所有用例在不同的线程下去执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;suite &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sml多线程测试&quot;&lt;/span&gt;&lt;span&gt; parallel&lt;/span&gt;&lt;span&gt;=&quot;methods&quot;&lt;/span&gt;&lt;span&gt; thread-count&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;test &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;threadTest1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.testng.demo.MultiThreadedByXml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;suite&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过xml运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190516213219429-435314786.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5、classs级别测试&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;相同的classes标签下的用例在同一个线程中执行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置文件如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;suite &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sml多线程测试&quot;&lt;/span&gt;&lt;span&gt; parallel&lt;/span&gt;&lt;span&gt;=&quot;classes&quot;&lt;/span&gt;&lt;span&gt; thread-count&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;test &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;threadTest1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.testng.demo.MultiThreadedByXml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;suite&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过xml运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190516213641686-2055573288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不同的classes标签下的用例可以在不同的线程下执行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot; &lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;suite &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sml多线程测试&quot;&lt;/span&gt;&lt;span&gt; parallel&lt;/span&gt;&lt;span&gt;=&quot;classes&quot;&lt;/span&gt;&lt;span&gt; thread-count&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;test &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;threadTest1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.testng.demo.MultiThreadedByXml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;test &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;threadTest2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;class &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;com.testng.demo.MultiThreadedByXml2&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;classes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;suite&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过xml运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190516214245635-727570573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意：&lt;em&gt;thread-count: 代表了最大并发线程数，xml文件配置这种方式不能指定线程池，只有方法上才可以指定线程池&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;本文完，还不动手试一试········&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 13:46:00 +0000</pubDate>
<dc:creator>Refain</dc:creator>
<og:description>为什么要使用多线程测试？ 在实际测试中，为了节省测试时间，提高测试效率，在实际测试场景中经常会采用多线程的方式去执行，比如爬虫爬数据，多浏览器并行测试。 关于多线程并行测试 TestNG中实现多线程并</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longronglang/p/10878262.html</dc:identifier>
</item>
<item>
<title>Dubbo 2.7.1 踩坑记 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/10878186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/10878186.html</guid>
<description>&lt;p&gt;Dubbo 2.7 版本增加新特性，新系统开始使用 Dubbo 2.7.1 尝鲜新功能。使用过程中不慎踩到这个版本的 Bug。&lt;/p&gt;
&lt;h2 id=&quot;系统架构&quot;&gt;系统架构&lt;/h2&gt;
&lt;p&gt;Spring Boot 2.14-Release + Dubbo 2.7.1&lt;/p&gt;
&lt;h2 id=&quot;现象&quot;&gt;现象&lt;/h2&gt;
&lt;p&gt;Dubbo 服务者启动成功，正常提供服务，消费者调用偶现失败的情况。错误如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac09949e67d7d3?w=1549&amp;amp;h=714&amp;amp;f=png&amp;amp;s=700059&quot; alt=&quot;调用失败&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，主要原因为 &lt;strong&gt;cause: message can not send, because channel is closed&lt;/strong&gt;。 但是检查提供者，却发现服务进程正常。&lt;/p&gt;
&lt;p&gt;登陆 &lt;strong&gt;Dubbo admin&lt;/strong&gt; 查看提供者服务，发现这个服务存在两个节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac09949fc89412?w=1025&amp;amp;h=545&amp;amp;f=png&amp;amp;s=17047&quot; alt=&quot;Dubbo admin&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;192.168.164.77&lt;/strong&gt; 为测试服务器的 ip，提供者位于这台机器，而另一个 &lt;strong&gt;10.20.80.67&lt;/strong&gt; 却是本地电脑的 IP，但是此时本地并未运行这个服务。&lt;/p&gt;
&lt;p&gt;再次查看服务报错的原因，可以看到提供者调用l本地提供 RPC 的服务。由于本地服务已停止，导致调用失败。&lt;/p&gt;
&lt;p&gt;这个问题在之前版本从未碰到，刚开始隐约记得 Dubbo 服务提供者注册使用 ZooKeeper 临时节点，服务断开，会删除该节点。&lt;/p&gt;
&lt;h2 id=&quot;问题原因&quot;&gt;问题原因&lt;/h2&gt;
&lt;p&gt;在 Dubbo 主页搜索相关 issue，看到同样的问题 &lt;a href=&quot;https://github.com/apache/incubator-Dubbo/issues/3785&quot;&gt;Dubbo-2.7.1 providers 重复注册&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;查看相关回复，可以看到问题主要由于 &lt;strong&gt;dynamic&lt;/strong&gt; 默认值变成 false ,而 2.7.1 之前版本默认不赋值，初始值为 null。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac09949f72f564?w=767&amp;amp;h=192&amp;amp;f=png&amp;amp;s=10790&quot; alt=&quot;问题原因&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后续 PR 中已修复该问题 &lt;a href=&quot;https://github.com/apache/incubator-Dubbo/pull/3824&quot;&gt;Fix issue 3785&lt;/a&gt;，修复代码将 &lt;strong&gt;dynamic&lt;/strong&gt; 默认设置成 true。但是截止 &lt;strong&gt;20190515&lt;/strong&gt; 该版本暂未发布。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;知道问题原因，这里我们从源码分析一下，为什么 &lt;strong&gt;dynamic&lt;/strong&gt; 设置成 &lt;strong&gt;false&lt;/strong&gt; 会导致该问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：下面分析的是 Dubbo 2.7.1 的源码&lt;/strong&gt;&lt;br/&gt;下面我们使用 Dubbo xml 配置相关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 xml 配置中，可以在以下两个地方设置 &lt;strong&gt;dynamic&lt;/strong&gt; 属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac09949f96b994?w=1400&amp;amp;h=820&amp;amp;f=png&amp;amp;s=152899&quot; alt=&quot;xml 配置&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务启动时将会使用 &lt;strong&gt;DubboNamespaceHandler&lt;/strong&gt; 解析，注入 Spring 容器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac0994a4804af8?w=1529&amp;amp;h=667&amp;amp;f=png&amp;amp;s=546030&quot; alt=&quot;DubboNamespaceHandler 解析过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中会将 &lt;strong&gt;provider&lt;/strong&gt; 标签解析成 &lt;strong&gt;ProviderConfig&lt;/strong&gt; 对象，&lt;strong&gt;service&lt;/strong&gt; 标签解析成 &lt;strong&gt;ServiceBean&lt;/strong&gt; 对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac0994a43fe629?w=704&amp;amp;h=229&amp;amp;f=png&amp;amp;s=88589&quot; alt=&quot;继承关系&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看继承关系，可以看到以上两个类都继承 &lt;strong&gt;AbstractServiceConfig&lt;/strong&gt; , &lt;strong&gt;dynamic&lt;/strong&gt; 位于这个父对象中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac0994ed04ec18?w=1250&amp;amp;h=171&amp;amp;f=png&amp;amp;s=115139&quot; alt=&quot;dynamic 默认值&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到该字段默认值为 &lt;strong&gt;false&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接着查看 Dubbo 服务导出过程，位于 &lt;strong&gt;ServiceBean#export&lt;/strong&gt;,略过其他代码，我们直接跳到关键 &lt;strong&gt;ServiceConfig#doExportUrlsFor1Protocol&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac09953f3574f6?w=1133&amp;amp;h=357&amp;amp;f=png&amp;amp;s=228062&quot; alt=&quot;doExportUrlsFor1Protocol&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里调用了多次 &lt;strong&gt;appendParameters&lt;/strong&gt; 方法。 这个方法将利用反射，获取对象的中所有字段信息，然后添加到 map 中。其中字段名字为键值，字段实际值为内容。此时 map 键值内容为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac099543a0ea4a?w=624&amp;amp;h=485&amp;amp;f=png&amp;amp;s=33518&quot; alt=&quot;map 内容&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以看到 map 中还有一个 default.dynamic，大家翻看代码自己思考一下，为什么会出现这个？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着我们跳到后面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac09956393acf6?w=1159&amp;amp;h=231&amp;amp;f=png&amp;amp;s=173892&quot; alt=&quot;url&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里会将上面得到 map 组装到 URL 对象中，然后再注册到注册中心。。&lt;/p&gt;
&lt;p&gt;由于注册中心使用的是 ZooKeeper，所以这里将会使用 &lt;strong&gt;ZookeeperRegistry&lt;/strong&gt; 实现类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac0995651cdfaa?w=1292&amp;amp;h=196&amp;amp;f=png&amp;amp;s=115474&quot; alt=&quot;doRegister&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先查看 &lt;strong&gt;url##getParameter&lt;/strong&gt; 方法，这里 &lt;strong&gt;Constants.DYNAMIC_KEY&lt;/strong&gt; 值为 dynamic。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac09956b0c6936?w=765&amp;amp;h=369&amp;amp;f=png&amp;amp;s=178277&quot; alt=&quot;url##getParameter&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该方法会先从 &lt;strong&gt;parameters&lt;/strong&gt; 中根据键值取值。若不存在，会再根据 default 作为前缀拼接再次取值。若还不存在则使用传入的默认值。&lt;/p&gt;
&lt;p&gt;查看此时的 &lt;strong&gt;parameters&lt;/strong&gt; 对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac09958b5cbb4e?w=624&amp;amp;h=485&amp;amp;f=png&amp;amp;s=36422&quot; alt=&quot;parameters&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;url.getParameter(Constants.DYNAMIC_KEY, true)&lt;/strong&gt; 返回为 false。&lt;/p&gt;
&lt;p&gt;然后分析 &lt;strong&gt;zkClient#create&lt;/strong&gt; 方法，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/5/16/16ac0995917801c2?w=863&amp;amp;h=438&amp;amp;f=png&amp;amp;s=224357&quot; alt=&quot;zkClient#create&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于 ephemeral 为 false，所以这个服务注册到 ZooKeeper 的节点为持久节点。&lt;/p&gt;
&lt;blockquote readability=&quot;5.5690607734807&quot;&gt;
&lt;p&gt;临时节点，客户端断开，会话超时后，ZooKeeper 将会自动删除这个节点。&lt;a href=&quot;http://jm.taobao.org/2013/10/07/zookeeper-faq/&quot;&gt;zookeeper-faq&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;面试题：服务提供者能实现失效踢出是什么原理(高频题)&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;服务宕机的时候，该节点由于是持久节点会永远存在，而且当服务再次重启的时候会将重新注册一个新节点。这样就导致 ZooKeeper 中存在额外失效的节点，且该节点还无法自然消除（除非手动调用 ZooKeeper 删除节点方法）。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;由于 Dubbo 2.7.2 暂未发布，所以建议若想使用 Dubbo 2.7 新功能的同学，使用 2.7.0 版本。若现在正在使用 2.7.2 版本，也不要慌张。只要服务不是异常宕机或者使用 kill -9 强制杀死进程，以上的现象将不会碰到。正常服务关闭的时候，Dubbo 服务会主动去 ZooKeeper 注销该服务，并删除这个节点。&lt;/p&gt;
&lt;p&gt;还未使用该版本的同学们，建议使用 2.7.0 或者等 2.7.2 发布以后，再使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/5/169ee025eadf161e?w=1250&amp;amp;h=607&amp;amp;f=png&amp;amp;s=130649&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 13:33:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>Dubbo 2.7 版本增加新特性，新系统开始使用 Dubbo 2.7.1 尝鲜新功能。使用过程中不慎踩到这个版本的 Bug。 系统架构 Spring Boot 2.14 Release + Dubb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/goodAndyxublog/p/10878186.html</dc:identifier>
</item>
</channel>
</rss>