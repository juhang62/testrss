<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>apt 和 apt-get 之间有什么区别？ - 一口Linux</title>
<link>http://www.cnblogs.com/yikoulinux/p/14401487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yikoulinux/p/14401487.html</guid>
<description>&lt;p&gt;使用ubuntu的朋友一定会接触一个命令就是apt-get 。&lt;br/&gt;使用该工具安装各种应用程序那叫一个爽。&lt;br/&gt;在 Ubuntu 16.04 发行后，apt使用渐渐频繁起来。&lt;/p&gt;
&lt;p&gt;那么，apt-get 与 apt 命令之间到底有什么区别呢？&lt;/p&gt;
&lt;p&gt;如果它们有类似的命令结构，为什么还需要新的 apt 命令呢？&lt;/p&gt;
&lt;p&gt;是否 apt 真的比 apt-get 更好？&lt;/p&gt;
&lt;p&gt;普通用户应该使用新的 apt 命令还是坚持旧有习惯继续使用 apt-get 呢？&lt;/p&gt;
&lt;p&gt;彭老师将在本文中解释所有这些问题，我们希望本文结束时，你将会有一个更清晰的了解。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201231175218555.png&quot; alt=&quot;apt 和 apt-get 之间的区别&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-apt-get&quot;&gt;1. Apt-get&lt;/h2&gt;
&lt;p&gt;Advanced Package Tool，又名apt-get，是一款适用于Unix和Linux系统的应用程序管理器。&lt;/p&gt;
&lt;p&gt;最初于1998年发布，用于检索应用程序并将其加载到Debian Linux系统。主要用于自动从互联网的软件仓库中搜索、安装、升级、卸载软件或操作系统。&lt;/p&gt;
&lt;p&gt;Apt-get成名的原因之一在于其出色的解决软件依赖关系的能力。其通常使用.deb-formatted文件，但经过修改后可以使用apt-rpm处理红帽的Package Manager（RPM）文件。&lt;/p&gt;
&lt;p&gt;Apt-get在Linux社区得到广泛使用，成为用来管理桌面、笔记本和网络的重要工具。随着Linux在企业中的普及，Windows和Mac用户了解如何使用apt-get加载应用程序有一定的好处。&lt;/p&gt;
&lt;p&gt;另外，随着单片机设备如Raspberry Pi的热度增加，apt-get在这些平台上是比较便捷的应用加载方式。如果你想要加载的应用需要程序库或另一个应用程序才能正常工作，apt-get会帮你找到并加载所需的程序库或应用代码。&lt;/p&gt;
&lt;p&gt;apt-get当前的稳定版本是1.0.9.2，在2014年10月发布。&lt;/p&gt;
&lt;p&gt;使用apt-get的主流Linux系统包括Debian和Ubuntu变异版本。大多数情况下，从命令行运行该工具。桌面上有几个图形前端可以使用，包括Synaptic Package Manager、Ubuntu Software Center、Aptitude和Kpackage。&lt;/p&gt;
&lt;p&gt;Raspberry Pi和Beaglebone Black nanoLinux版用户可以很容易地使用apt-get加载程序，因为这些系统通常来自Ubuntu或Debian代码。是debian，ubuntu发行版的包管理工具，与红帽中的&lt;strong&gt;yum&lt;/strong&gt;工具非常类似。&lt;/p&gt;
&lt;p&gt;apt-get命令一般需要&lt;strong&gt;root权限&lt;/strong&gt;执行，所以一般跟着sudo命令。&lt;/p&gt;
&lt;h2 id=&quot;2-apt&quot;&gt;2. Apt&lt;/h2&gt;
&lt;p&gt;apt 命令行实用程序于2014年推出第一个稳定版本，用于 Debian 发行版 .deb 软件包安装。它最初在不稳定的Debian版本中使用，然后在Debian 8中成为标准。&lt;/p&gt;
&lt;p&gt;在 Ubuntu 16.04 发行后，apt 开始流行，并以某种方式取代了 apt-get 。&lt;/p&gt;
&lt;p&gt;随着 apt install package 命令的使用频率和普遍性逐步超过 apt-get install package，越来越多的其它 Linux 发行版也开始遵循 Ubuntu 的脚步，开始鼓励用户使用 apt 而不是 apt-get。&lt;/p&gt;
&lt;p&gt;大多数人不了解 apt 和 apt-get 之间的区别，并且经常在使用一个或另一个时感到困惑。&lt;/p&gt;
&lt;p&gt;两者都是开源命令行工具，用于管理软件包，例如安装，更新，升级和删除。&lt;/p&gt;
&lt;p&gt;但是，它们之间仍然存在一些差异。&lt;/p&gt;
&lt;p&gt;让我们看一些替代 apt-get 的 apt 命令，要查看这些命令，可以键入 apt help 或通过在终端中键入 apt man 来访问apt 手册页。它将显示与apt 相关的所有信息。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210104220630137.png&quot; alt=&quot;apt help &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;apt 和 apt-get 之间的第一个区别是命令本身。&lt;br/&gt;例如，如果要使用 apt-get update 更新系统存储库索引，则可以运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#apt-get update
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210104220455946.png&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 apt 则输入命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#apt update
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210104220529622.png&quot; alt=&quot; &quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;apt update 命令不仅更新存储库索引，还告知存储库中是否可用软件以及有多少新版本可用。&lt;/p&gt;
&lt;h2 id=&quot;1-命令对比&quot;&gt;1. 命令对比&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;apt-get&lt;/th&gt;
&lt;th&gt;apt&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt;apt-get&lt;/td&gt;
&lt;td&gt;apt&lt;/td&gt;
&lt;td&gt;安装软件包&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;apt-get remove&lt;/td&gt;
&lt;td&gt;apt remove&lt;/td&gt;
&lt;td&gt;删除软件包&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;apt-get remove&lt;/td&gt;
&lt;td&gt;apt remove&lt;/td&gt;
&lt;td&gt;更换所有包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;apt-get purge&lt;/td&gt;
&lt;td&gt;aptpurge&lt;/td&gt;
&lt;td&gt;移除软件包及配置文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;apt-get upgrade&lt;/td&gt;
&lt;td&gt;apt upgrade&lt;/td&gt;
&lt;td&gt;更新所有软件包（自动处理依赖项）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;apt-get autoremove&lt;/td&gt;
&lt;td&gt;apt autoremove&lt;/td&gt;
&lt;td&gt;自动删除不需要的包&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;apt-get dist-upgrade&lt;/td&gt;
&lt;td&gt;apt full-upgrade&lt;/td&gt;
&lt;td&gt;在升级软件包时自动处理依赖关系&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;apt-cache search&lt;/td&gt;
&lt;td&gt;apt search&lt;/td&gt;
&lt;td&gt;搜索应用程序&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;apt-cache show&lt;/td&gt;
&lt;td&gt;apt show&lt;/td&gt;
&lt;td&gt;显示装细节&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;删除不必要的依赖apt-get autoremoveapt autoremove删除具有相关配置的软件包apt-get purgeapt purge&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在上表中，如果将 apt-get 替换为 apt，则所有命令都相同，除了 apt upgrade 命令。&lt;br/&gt;旧的 apt-get upgrade 命令更新系统中当前存在的所有软件包，它不会在系统上安装或删除现有软件包。&lt;br/&gt;新的 apt upgrade 命令将安装作为可升级软件包的依赖项添加的软件包。尽管类似于 apt-get 升级，但它也不会删除以前安装的软件包。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;apt show 命令以字母顺序打印输出，并隐藏 apt-cache show命令显示的不太重要的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;apt 和 apt-get 之间的区别不仅限于命令，新的 apt 命令中已添加了另一个视觉功能，以使最终用户满意。每当在使用 apt 升级，apt 完全升级或 apt dist升级时更新软件包时，都会看到一个进度条，通知该过程的进度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210104221909389.png&quot; alt=&quot;apt install&quot; loading=&quot;lazy&quot;/&gt;* 当使用 apt remove 或 apt purge 删除软件包时，它也会出现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;此外，如果我们运行 &lt;strong&gt;apt list --upgradeable&lt;/strong&gt;，它还会显示一些颜色，以提供有关存储库提供最新版本的软件包的清晰概述。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210104222140516.png&quot; alt=&quot;apt list --upgradeable&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2-两个新命令&quot;&gt;2. 两个新命令&lt;/h2&gt;
&lt;p&gt;除了替换命令外，apt 引入了两个新命令：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;新的apt命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;apt list&lt;/td&gt;
&lt;td&gt;列出包含条件的包（已安装，可升级等）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;apt edit-sources&lt;/td&gt;
&lt;td&gt;编辑源列表&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ol&gt;&lt;li&gt;apt list&lt;br/&gt;–当 apt list 命令与–installed或–upgradeable一起使用时，它将列出已安装，可安装或需要升级的软件包。&lt;/li&gt;
&lt;li&gt;apt edit-sources&lt;br/&gt;–使用此命令时，它将在编辑器中打开sources.list文件进行编辑。&lt;br/&gt;apt-get 仍然不能完全被 apt 取代，而且我认为它永远不会被完全终止。你可能正在考虑应该选择什么：apt 或 apt-get。在我看来，选择apt 是值得的，因为它提供了软件包管理的所有必需功能，并且更快，更友好且易于使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前还没有任何 Linux 发行版官方放出 apt-get 将被停用的消息，至少它还有比 apt 更多、更细化的操作功能。对于低级操作，仍然需要 apt-get。&lt;/p&gt;
&lt;p&gt;既然两个命令都有用，那么我该使用 apt 还是 apt-get 呢？&lt;/p&gt;
&lt;p&gt;作为一个常规 Linux 用户，系统极客建议大家尽快适应并开始首先使用 apt。&lt;br/&gt;不仅因为广大 Linux 发行商都在推荐 apt，更主要的还是它提供了 Linux 包管理的必要选项。&lt;/p&gt;
&lt;p&gt;最重要的是，apt 命令选项更少更易记，因此也更易用，所以没理由继续坚持 apt-get。&lt;/p&gt;
&lt;p&gt;最后给大家提供两点使用上的建议：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;apt 可以看作 apt-get 和 apt-cache 命令的子集, 可以为包管理提供必要的命令选项。&lt;/li&gt;
&lt;li&gt;apt-get 虽然没被弃用，但作为普通用户，还是应该首先使用 apt。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;更多Linux知识请关注 公众号：一口Linux&lt;/p&gt;
</description>
<pubDate>Sun, 14 Feb 2021 00:43:00 +0000</pubDate>
<dc:creator>一口Linux</dc:creator>
<og:description>使用ubuntu的朋友一定会接触一个命令就是apt-get 。 使用该工具安装各种应用程序那叫一个爽。 在 Ubuntu 16.04 发行后，apt使用渐渐频繁起来。 那么，apt-get 与 apt</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yikoulinux/p/14401487.html</dc:identifier>
</item>
<item>
<title>Redis五大类型及底层实现原理 - xuxh120</title>
<link>http://www.cnblogs.com/xuxh120/p/14400980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuxh120/p/14400980.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#2522-1613193635074&quot;&gt;简单动态字符串&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#MkTP-1612868405200&quot;&gt;链表&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#vGJC-1612868407374&quot;&gt;字典&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#uNjE-1612875348386&quot;&gt;跳跃表&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#hSCq-1612936238018&quot;&gt;整数集合&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#3800-1612972201514&quot;&gt;压缩列表&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#7tqe-1612936238865&quot;&gt;对象&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.048192771084337&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#2544-1613124813349&quot;&gt;对象的类型与编码&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#AXoT-1612937116652&quot;&gt;字符串对象&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#GwBX-1612937116668&quot;&gt;列表对象&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#5698-1613190018395&quot;&gt;哈希对象&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#3030-1613190564781&quot;&gt;集合对象&lt;br/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#3846-1613190999897&quot;&gt;有序集合对象&lt;br/&gt;&lt;/a&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#2475-1613191810629&quot;&gt;类型检查与命令多态&lt;br/&gt;&lt;/a&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#1986-1613191812298&quot;&gt;内存回收&lt;br/&gt;&lt;/a&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#2328-1613191812726&quot;&gt;对象共享&lt;br/&gt;&lt;/a&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/xuxh120/p/14400980.html#1557-1613192960461&quot;&gt;对象的空转时长&lt;/a&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;


&lt;h2&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Redis 只会使用 C 字符串作为字面量， 在大多数情况下， Redis 使用 SDS （Simple Dynamic String，简单动态字符串）作为字符串表示。&lt;/li&gt;
&lt;li&gt;比起 C 字符串， SDS 具有以下优点：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;常数复杂度获取字符串长度。&lt;/li&gt;
&lt;li&gt;杜绝缓冲区溢出。&lt;/li&gt;
&lt;li&gt;减少修改字符串长度时所需的内存重分配次数。&lt;/li&gt;
&lt;li&gt;二进制安全。&lt;/li&gt;
&lt;li&gt;兼容部分 C 字符串函数。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;&lt;strong&gt;简单动态字符串&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Redis 没有直接使用 C 语言传统的字符串表示（以空字符结尾的字符数组，以下简称 C 字符串）， 而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型， 并将 SDS 用作 Redis 的默认字符串表示。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;SDS 的定义&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;每个 sds.h/sdshdr 结构表示一个 SDS 值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sdshdr {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录 buf 数组中已使用字节的数量
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 等于 SDS 所保存字符串的长度&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; len;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 记录 buf 数组中未使用字节的数量&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; free;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 字节数组，用于保存字符串&lt;/span&gt;
    &lt;span&gt;char&lt;/span&gt;&lt;span&gt; buf[];

};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;SDS vs C字符串&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表 2-1 C 字符串和 SDS 之间的区别&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;C 字符串&lt;/td&gt;
&lt;td&gt;SDS&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;获取字符串长度的复杂度为O(N)。&lt;/td&gt;
&lt;td&gt;获取字符串长度的复杂度为O(1)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;API 是不安全的，可能会造成缓冲区溢出。&lt;/td&gt;
&lt;td&gt;API 是安全的，不会造成缓冲区溢出。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;修改字符串长度N次必然需要执行N次内存重分配。&lt;/td&gt;
&lt;td&gt;修改字符串长度N次最多需要执行N次内存重分配。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;只能保存文本数据。&lt;/td&gt;
&lt;td&gt;可以保存文本或者二进制数据。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;可以使用所有&amp;lt;string.h&amp;gt;库中的函数。&lt;/td&gt;
&lt;td&gt;可以使用一部分&amp;lt;string.h&amp;gt;库中的函数。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;&lt;strong&gt;常数复杂度获取字符串长度&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;通过使用 SDS 而不是 C 字符串， Redis 将获取字符串长度所需的复杂度从 O(N) 降低到了 O(1) ， 这确保了获取字符串长度的工作不会成为 Redis 的性能瓶颈。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;杜绝缓冲区溢出&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;strong&gt;减少修改字符串时带来的内存重分配次数：通过未使用空间， SDS 实现了空间预分配和惰性空间释放两种优化策略。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;空间预分配 - 通过这种策略， SDS 将连续增长 N 次字符串所需的内存重分配次数从必定 N 次降低为最多 N 次。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;空间预分配用于优化 SDS 的字符串增长操作： 当 SDS 的 API 对一个 SDS 进行修改， 并且需要对 SDS 进行空间扩展的时候， 程序不仅会为 SDS 分配修改所必须要的空间， 还会为 SDS 分配额外的未使用空间。&lt;/p&gt;
&lt;p&gt;其中， 额外分配的未使用空间数量由以下公式决定：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配 13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。&lt;/li&gt;
&lt;li&gt;如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;惰性空间释放 - 通过这种策略， SDS 避免了缩短字符串时所需的内存重分配操作， 并为将来可能有的增长操作提供了优化。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;惰性空间释放用于优化 SDS 的字符串缩短操作： 当 SDS 的 API 需要缩短 SDS 保存的字符串时， 程序并不立即使用内存重分配来回收缩短后多出来的字节， 而是使用 free 属性将这些字节的数量记录起来， 并等待将来使用。&lt;/p&gt;
&lt;p&gt;与此同时， SDS 也提供了相应的 API ， 让我们可以在有需要时， 真正地释放 SDS 里面的未使用空间， 所以不用担心惰性空间释放策略会造成内存浪费。 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;二进制安全&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;所有 SDS API 都会以处理二进制的方式来处理 SDS 存放在 buf 数组里的数据， 程序不会对其中的数据做任何限制、过滤、或者假设 —— 数据在写入时是什么样的， 它被读取时就是什么样。这也是我们将 SDS 的 buf 属性称为字节数组的原因 —— Redis 不是用这个数组来保存字符， 而是用它来保存一系列二进制数据。&lt;/li&gt;
&lt;li&gt;SDS 使用 len 属性的值而不是空字符来判断字符串是否结束。&lt;/li&gt;
&lt;li&gt;通过使用二进制安全的 SDS ， 而不是 C 字符串， 使得 Redis 不仅可以保存文本数据， 还可以保存任意格式的二进制数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;兼容部分 C 字符串函数&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;虽然 SDS 的 API 都是二进制安全的， 但它们一样遵循 C 字符串以空字符结尾的惯例： 这些 API 总会将 SDS 保存的数据的末尾设置为空字符， 并且总会在为 buf 数组分配空间时多分配一个字节来容纳这个空字符， 这是为了让那些保存文本数据的 SDS 可以重用一部分 &amp;lt;string.h&amp;gt; 库定义的函数。这样 Redis 就不用自己专门去实现一套函数。&lt;/p&gt;
&lt;p&gt;表 2-2 SDS 的主要操作 API&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;25.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;函数&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;td&gt;时间复杂度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdsnew&lt;/td&gt;
&lt;td&gt;创建一个包含给定 C 字符串的 SDS 。&lt;/td&gt;
&lt;td&gt;O(N)，N为给定 C 字符串的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;sdsempty&lt;/td&gt;
&lt;td&gt;创建一个不包含任何内容的空 SDS 。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;sdsfree&lt;/td&gt;
&lt;td&gt;释放给定的 SDS 。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdslen&lt;/td&gt;
&lt;td&gt;返回 SDS 的已使用空间字节数。&lt;/td&gt;
&lt;td&gt;这个值可以通过读取 SDS 的len属性来直接获得， 复杂度为O(1)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;sdsavail&lt;/td&gt;
&lt;td&gt;返回 SDS 的未使用空间字节数。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;这个值可以通过读取 SDS 的free属性来直接获得， 复杂度为&lt;/p&gt;
&lt;p&gt;O(1)。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdsdup&lt;/td&gt;
&lt;td&gt;创建一个给定 SDS 的副本（copy）。&lt;/td&gt;
&lt;td&gt;O(N)，N为给定 SDS 的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdsclear&lt;/td&gt;
&lt;td&gt;清空 SDS 保存的字符串内容。&lt;/td&gt;
&lt;td&gt;因为惰性空间释放策略，复杂度为O(1)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdscat&lt;/td&gt;
&lt;td&gt;将给定 C 字符串拼接到 SDS 字符串的末尾。&lt;/td&gt;
&lt;td&gt;O(N)，N为被拼接 C 字符串的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdscatsds&lt;/td&gt;
&lt;td&gt;将给定 SDS 字符串拼接到另一个 SDS 字符串的末尾。&lt;/td&gt;
&lt;td&gt;O(N)，N为被拼接 SDS 字符串的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdscpy&lt;/td&gt;
&lt;td&gt;将给定的 C 字符串复制到 SDS 里面， 覆盖 SDS 原有的字符串。&lt;/td&gt;
&lt;td&gt;O(N)，N为被复制 C 字符串的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdsgrowzero&lt;/td&gt;
&lt;td&gt;用空字符将 SDS 扩展至给定长度。&lt;/td&gt;
&lt;td&gt;O(N)，N为扩展新增的字节数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdsrange&lt;/td&gt;
&lt;td&gt;保留 SDS 给定区间内的数据， 不在区间内的数据会被覆盖或清除。&lt;/td&gt;
&lt;td&gt;O(N)，N为被保留数据的字节数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;sdstrim&lt;/td&gt;
&lt;td&gt;接受一个 SDS 和一个 C 字符串作为参数， 从 SDS 左右两端分别移除所有在 C 字符串中出现过的字符。&lt;/td&gt;
&lt;td&gt;O(M*N)，M为 SDS 的长度，N为给定 C 字符串的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;sdscmp&lt;/td&gt;
&lt;td&gt;对比两个 SDS 字符串是否相同。&lt;/td&gt;
&lt;td&gt;O(N)，N为两个 SDS 中较短的那个 SDS 的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;hr/&gt;

&lt;h2&gt;&lt;span id=&quot;Y6vG-1612871452035&quot; class=&quot;anchor&quot;&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;链表提供了高效的节点重排能力， 以及顺序性的节点访问方式， 并且可以通过增删节点来灵活地调整链表的长度。因为 Redis 使用的 C 语言并没有内置这种数据结构， 所以 Redis 构建了自己的链表实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;链表被广泛用于实现 Redis 的各种功能， 比如列表键， 发布与订阅， 慢查询， 监视器， 等等。&lt;/li&gt;
&lt;li&gt;每个链表节点由一个 listNode 结构来表示， 每个节点都有一个指向前置节点和后置节点的指针， 所以 Redis 的链表实现是双端链表。&lt;/li&gt;
&lt;li&gt;每个链表使用一个 list 结构来表示， 这个结构带有表头节点指针、表尾节点指针、以及链表长度等信息。&lt;/li&gt;
&lt;li&gt;因为链表表头节点的前置节点和表尾节点的后置节点都指向 NULL ， 所以 Redis 的链表实现是无环链表。&lt;/li&gt;
&lt;li&gt;通过为链表设置不同的类型特定函数， Redis 的链表可以用于保存各种不同类型的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;链表和链表节点的实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;每个链表节点使用一个 adlist.h/listNode 结构来表示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; listNode {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前置节点&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; listNode *&lt;span&gt;prev;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后置节点&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; listNode *&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点的值&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;value;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; } listNode;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;多个 listNode 可以通过 prev 和 next 指针组成双端链表， 如图 3-1 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213200006802-2083291887.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;虽然仅仅使用多个 listNode 结构就可以组成链表， 但使用 adlist.h/list 来持有链表的话， 操作起来会更方便：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; list {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表头节点&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     listNode *&lt;span&gt;head;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表尾节点&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     listNode *&lt;span&gt;tail;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 链表所包含的节点数量&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; len;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点值复制函数&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *(*dup)(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;ptr);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点值释放函数&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; (*free)(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;ptr);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 节点值对比函数&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; (*match)(&lt;span&gt;void&lt;/span&gt; *ptr, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;key);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; } list;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;list 结构为链表提供了表头指针 head 、表尾指针 tail ， 以及链表长度计数器 len ， 而 dup 、 free 和 match 成员则是用于实现多态链表所需的类型特定函数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;dup 函数用于复制链表节点所保存的值；&lt;/li&gt;
&lt;li&gt;free 函数用于释放链表节点所保存的值；&lt;/li&gt;
&lt;li&gt;match 函数则用于对比链表节点所保存的值和另一个输入值是否相等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图 3-2 是由一个 list 结构和三个 listNode 结构组成的链表：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213200117107-1518159670.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;&lt;strong&gt;链表和链表节点的 API&lt;/strong&gt;&lt;/h2&gt;
&lt;table&gt;&lt;tbody readability=&quot;35.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;函数&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;td&gt;时间复杂度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;listSetDupMethod&lt;/td&gt;
&lt;td&gt;将给定的函数设置为链表的节点值复制函数。&lt;/td&gt;
&lt;td&gt;O(1)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;listGetDupMethod&lt;/td&gt;
&lt;td&gt;返回链表当前正在使用的节点值复制函数。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;复制函数可以通过链表的dup属性直接获得，&lt;/p&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;listSetFreeMethod&lt;/td&gt;
&lt;td&gt;将给定的函数设置为链表的节点值释放函数。&lt;/td&gt;
&lt;td&gt;O(1)。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;listGetFree&lt;/td&gt;
&lt;td&gt;返回链表当前正在使用的节点值释放函数。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;释放函数可以通过链表的free属性直接获得，&lt;/p&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;listSetMatchMethod&lt;/td&gt;
&lt;td&gt;将给定的函数设置为链表的节点值对比函数。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;listGetMatchMethod&lt;/td&gt;
&lt;td&gt;返回链表当前正在使用的节点值对比函数。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;对比函数可以通过链表的match&lt;/p&gt;
&lt;p&gt;属性直接获得，&lt;/p&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;listLength&lt;/td&gt;
&lt;td&gt;返回链表的长度（包含了多少个节点）。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;链表长度可以通过链表的len属性直接获得，&lt;/p&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;p&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;listFirst&lt;/td&gt;
&lt;td&gt;返回链表的表头节点。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;表头节点可以通过链表的head属性直接获得，&lt;/p&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;p&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;listLast&lt;/td&gt;
&lt;td&gt;返回链表的表尾节点。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;表尾节点可以通过链表的tail属性直接获得，&lt;/p&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;p&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;listPrevNode&lt;/td&gt;
&lt;td&gt;返回给定节点的前置节点。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;前置节点可以通过节点的prev属性直接获得，&lt;/p&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;p&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;listNextNode&lt;/td&gt;
&lt;td&gt;返回给定节点的后置节点。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;后置节点可以通过节点的next属性直接获得，&lt;/p&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;p&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;listNodeValue&lt;/td&gt;
&lt;td&gt;返回给定节点目前正在保存的值。&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;节点值可以通过节点的value属性直接获得，&lt;/p&gt;
&lt;p&gt;O(1)&lt;/p&gt;
&lt;p&gt;。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;listCreate&lt;/td&gt;
&lt;td&gt;创建一个不包含任何节点的新链表。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;listAddNodeHead&lt;/td&gt;
&lt;td&gt;将一个包含给定值的新节点添加到给定链表的表头。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;listAddNodeTail&lt;/td&gt;
&lt;td&gt;将一个包含给定值的新节点添加到给定链表的表尾。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;listInsertNode&lt;/td&gt;
&lt;td&gt;将一个包含给定值的新节点添加到给定节点的之前或者之后。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;listSearchKey&lt;/td&gt;
&lt;td&gt;查找并返回链表中包含给定值的节点。&lt;/td&gt;
&lt;td&gt;O(N)，N为链表长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;listIndex&lt;/td&gt;
&lt;td&gt;返回链表在给定索引上的节点。&lt;/td&gt;
&lt;td&gt;O(N)，N为链表长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;listDelNode&lt;/td&gt;
&lt;td&gt;从链表中删除给定节点。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;listRotate&lt;/td&gt;
&lt;td&gt;将链表的表尾节点弹出，然后将被弹出的节点插入到链表的表头， 成为新的表头节点。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;listDup&lt;/td&gt;
&lt;td&gt;复制一个给定链表的副本。&lt;/td&gt;
&lt;td&gt;O(N)，N为链表长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;listRelease&lt;/td&gt;
&lt;td&gt;释放给定链表，以及链表中的所有节点。&lt;/td&gt;
&lt;td&gt;O(N)，N为链表长度。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;hr/&gt;

&lt;p&gt;Redis 所使用的 C 语言并没有内置这种数据结构， 因此 Redis 构建了自己的字典实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字典， 又称符号表（symbol table）、关联数组（associative array）或者映射（map）， 是一种用于保存键值对（key-value pair）的抽象数据结构。&lt;/li&gt;
&lt;li&gt;在字典中， 一个键（key）可以和一个值（value）进行关联（或者说将键映射为值）， 这些关联的键和值就被称为键值对。&lt;/li&gt;
&lt;li&gt;字典中的每个键都是独一无二的， 程序可以在字典中根据键查找与之关联的值， 或者通过键来更新值， 又或者根据键来删除整个键值对， 等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;字典被广泛用于实现 Redis 的各种功能， 其中包括数据库和哈希键。&lt;/li&gt;
&lt;li&gt;Redis 中的字典使用哈希表作为底层实现， 每个字典带有两个哈希表， 一个用于平时使用， 另一个仅在进行 rehash 时使用。&lt;/li&gt;
&lt;li&gt;当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 MurmurHash2 算法来计算键的哈希值。&lt;/li&gt;
&lt;li&gt;哈希表使用链地址法来解决键冲突， 被分配到同一个索引上的多个键值对会连接成一个单向链表。&lt;/li&gt;
&lt;li&gt;在对哈希表进行扩展或者收缩操作时， 程序需要将现有哈希表包含的所有键值对 rehash 到新哈希表里面， 并且这个 rehash 过程并不是一次性地完成的， 而是渐进式地完成的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;字典的实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Redis 的&lt;span&gt;字典&lt;/span&gt;使用&lt;span&gt;哈希表&lt;/span&gt;作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个&lt;span&gt;键值对&lt;/span&gt;。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;字典&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Redis 中的字典由 dict.h/dict 结构表示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; dict {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型特定函数&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     dictType *&lt;span&gt;type;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 私有数据&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;privdata;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希表&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     dictht ht[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; rehash 索引
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当 rehash 不在进行时，值为 -1&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; rehashidx; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; rehashing not in progress if rehashidx == -1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;} dict;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;type 属性和 privdata 属性是针对不同类型的键值对， 为创建多态字典而设置的：&lt;/li&gt;
&lt;li&gt;type 属性是一个指向 dictType 结构的指针， 每个 dictType 结构保存了一簇用于操作特定类型键值对的函数， Redis 会为用途不同的字典设置不同的类型特定函数。&lt;/li&gt;
&lt;li&gt;而 privdata 属性则保存了需要传给那些类型特定函数的可选参数。&lt;/li&gt;
&lt;li&gt;ht 属性是一个包含两个项的数组， 数组中的每个项都是一个 dictht 哈希表， 一般情况下， 字典只使用 ht[0] 哈希表， &lt;span&gt;ht[1] 哈希表只会在对 ht[0] 哈希表进行 rehash 时使用。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;除了 ht[1] 之外， 另一个和 rehash 有关的属性就是 rehashidx ： 它记录了 rehash 目前的进度， 如果目前没有在进行 rehash ， 那么它的值为 -1 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;哈希表&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Redis 字典所使用的哈希表由 dict.h/dictht 结构定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; dictht {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希表数组&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     dictEntry **&lt;span&gt;table;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希表大小&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 哈希表大小掩码，用于计算索引值
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 总是等于 size - 1&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; sizemask;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该哈希表已有节点的数量&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; used;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;} dictht;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h/dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。&lt;/li&gt;
&lt;li&gt;size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。&lt;/li&gt;
&lt;li&gt;sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图 4-1 展示了一个大小为 4 的空哈希表 （没有包含任何键值对）。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213200721205-1168892779.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;&lt;strong&gt;哈希表节点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; dictEntry {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 键&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;key;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    union {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;val;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        uint64_t u64;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        int64_t s64;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    } v;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指向下个哈希表节点，形成链表&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; dictEntry *&lt;span&gt;next;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;} dictEntry;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;key 属性保存着键值对中的键。&lt;/li&gt;
&lt;li&gt;v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。&lt;/li&gt;
&lt;li&gt;next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;图 4-3 展示了一个普通状态下（没有进行 rehash）的字典：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213200929586-318083919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;h2&gt;&lt;strong&gt;哈希算法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;当要将一个新的键值对添加到字典里面时， 程序需要先根据键值对的键计算出哈希值和索引值， 然后再根据索引值， 将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。&lt;/p&gt;
&lt;p&gt;Redis 计算哈希值和索引值的方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;# 使用字典设置的哈希函数，计算键 key 的哈希值
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; hash = dict-&amp;gt;type-&amp;gt;&lt;span&gt;hashFunction(key);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;# 使用哈希表的 sizemask 属性和哈希值，计算出索引值
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; # 根据情况不同， ht[x] 可以是 ht[&lt;span&gt;0&lt;/span&gt;] 或者 ht[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; index = hash &amp;amp; dict-&amp;gt;ht[x].sizemask;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213201026959-902774640.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;举个例子， 对于图 4-4 所示的字典来说， 如果我们要将一个键值对 k0 和 v0 添加到字典里面， 那么程序会先使用语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hash = dict-&amp;gt;type-&amp;gt;hashFunction(k0);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;计算键 k0 的哈希值。&lt;/p&gt;
&lt;p&gt;假设计算得出的哈希值为 8 ， 那么程序会继续使用语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
index = hash &amp;amp; dict-&amp;gt;ht[&lt;span&gt;0&lt;/span&gt;].sizemask = &lt;span&gt;8&lt;/span&gt; &amp;amp; &lt;span&gt;3&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;计算出键 k0 的索引值 0 ， 这表示包含键值对 k0 和 v0 的节点应该被放置到哈希表数组的索引 0 位置上， 如图 4-5 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213201108883-798189607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;当字典被用作数据库的底层实现， 或者哈希键的底层实现时， Redis 使用 &lt;span&gt;MurmurHash2&lt;/span&gt; 算法来计算键的哈希值。&lt;/p&gt;
&lt;p&gt;MurmurHash 算法最初由 Austin Appleby 于 2008 年发明， &lt;span&gt;这种算法的优点在于， 即使输入的键是有规律的， 算法仍能给出一个很好的随机分布性， 并且算法的计算速度也非常快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MurmurHash 算法目前的最新版本为 MurmurHash3 ， 而 Redis 使用的是 MurmurHash2 ， 关于 MurmurHash 算法的更多信息可以参考该算法的主页： &lt;a href=&quot;http://code.google.com/p/smhasher/&quot;&gt;http://code.google.com/p/smhasher/&lt;/a&gt; 。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;解决键冲突&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;哈希表节点的next 属性是用来解决键冲突（collision）的问题&lt;/span&gt;，它指向另一个哈希表节点的指针。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时， 我们称这些键发生了冲突（collision）。&lt;/li&gt;
&lt;li&gt;Redis 的哈希表使用链地址法（separate chaining）来解决键冲突： 每个哈希表节点都有一个 next 指针， 多个哈希表节点可以用 next 指针构成一个单向链表， 被分配到同一个索引上的多个节点可以用这个单向链表连接起来， 这就解决了键冲突的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213201158593-1813749637.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为 dictEntry 节点组成的链表没有指向链表表尾的指针， 所以为了速度考虑， 程序总是将新节点添加到链表的表头位置（复杂度为 O(1)）， 排在其他已有节点的前面。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;rehash&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。&lt;/p&gt;
&lt;p&gt;扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是 ht[0].used 属性的值）：&lt;br/&gt;   如果执行的是&lt;span&gt;扩展&lt;/span&gt;操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；&lt;br/&gt;   如果执行的是&lt;span&gt;收缩&lt;/span&gt;操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。&lt;/li&gt;
&lt;li&gt;将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。&lt;/li&gt;
&lt;li&gt;当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个例子， 假设程序要对含有5个键值对字典的 ht[0] 进行扩展操作， 那么程序将执行以下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ht[0].used 当前的值为 5 ， 5 * 2 = 10 ， 而 第一个大于等于10的且2 的 n 次方的数是16， 所以程序会将 ht[1] 哈希表的大小设置为 16 。&lt;/li&gt;
&lt;li&gt;将 ht[0] 包含的5个键值对都 rehash 到 ht[1]。&lt;/li&gt;
&lt;li&gt;释放 ht[0] ，并将 ht[1] 设置为 ht[0] ，然后为 ht[1] 分配一个空白哈希表。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;哈希表的扩展与收缩&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;当哈希表的负载因子小于 0.1 时， 程序自动开始对哈希表执行收缩操作。&lt;/li&gt;
&lt;li&gt;当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；&lt;/li&gt;
&lt;li&gt;服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中哈希表的负载因子可以通过公式计算得出：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; # 负载因子 = 哈希表已保存节点数量 /&lt;span&gt; 哈希表大小
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; load_factor = ht[&lt;span&gt;0&lt;/span&gt;].used / ht[&lt;span&gt;0&lt;/span&gt;].size
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据 BGSAVE 命令或 BGREWRITEAOF 命令是否正在执行， 服务器执行扩展操作所需的负载因子并不相同， 这是因为在执行 BGSAVE 命令或 BGREWRITEAOF 命令的过程中， Redis 需要创建当前服务器进程的子进程， 而大多数操作系统都采用写时复制（&lt;a href=&quot;http://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;copy-on-write&lt;/a&gt;）技术来优化子进程的使用效率， 所以在子进程存在期间， 服务器会提高执行扩展操作所需的负载因子， 从而&lt;span&gt;尽可能地避免在子进程存在期间进行哈希表扩展操作， 这可以避免不必要的内存写入操作， 最大限度地节约内存&lt;/span&gt;。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;渐进式 rehash&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;上一节说过， 扩展或收缩哈希表需要将 ht[0] 里面的所有键值对 rehash 到 ht[1] 里面， 但是， 这个 rehash 动作并不是一次性、集中式地完成的， 而是分多次、渐进式地完成的。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;原因&lt;/span&gt;在于， 如果哈希表里保存的键值对数量巨大， 有四百万、四千万甚至四亿个键值对， 那么要一次性将这些键值对全部 rehash 到 ht[1] 的话， 庞大的计算量可能会导致服务器在一段时间内停止服务。&lt;/li&gt;
&lt;li&gt;因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。&lt;/li&gt;
&lt;li&gt;渐进式 rehash 的&lt;span&gt;好处&lt;/span&gt;在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;哈希表渐进式 rehash 的详细步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。&lt;/li&gt;
&lt;li&gt;在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。&lt;/li&gt;
&lt;li&gt;在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。&lt;/li&gt;
&lt;li&gt;随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;问题：如果渐进式rehash过程中，键值对数量迅速增大，最终在还没有rehash完，又需要扩容情况怎么办？&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;字典 API&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表 4-1 字典的主要操作 API&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;函数&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;td&gt;时间复杂度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dictCreate&lt;/td&gt;
&lt;td&gt;创建一个新的字典。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dictAdd&lt;/td&gt;
&lt;td&gt;将给定的键值对添加到字典里面。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;dictReplace&lt;/td&gt;
&lt;td&gt;将给定的键值对添加到字典里面， 如果键已经存在于字典，那么用新值取代原有的值。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;dictFetchValue&lt;/td&gt;
&lt;td&gt;返回给定键的值。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dictGetRandomKey&lt;/td&gt;
&lt;td&gt;从字典中随机返回一个键值对。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;dictDelete&lt;/td&gt;
&lt;td&gt;从字典中删除给定键所对应的键值对。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;dictRelease&lt;/td&gt;
&lt;td&gt;释放给定字典，以及字典中包含的所有键值对。&lt;/td&gt;
&lt;td&gt;O(N)，N为字典包含的键值对数量。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;hr/&gt;


&lt;h2&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;跳跃表是&lt;span&gt;有序集合&lt;/span&gt;的底层实现之一， 除此之外它在 Redis 中没有其他应用。&lt;/li&gt;
&lt;li&gt;Redis 的跳跃表实现由 &lt;span&gt;zskiplist&lt;/span&gt; 和 &lt;span&gt;zskiplistNode&lt;/span&gt; 两个结构组成， 其中 zskiplist 用于保存跳跃表信息（比如表头节点、表尾节点、长度）， 而 zskiplistNode 则用于表示跳跃表节点。&lt;/li&gt;
&lt;li&gt;每个跳跃表节点的&lt;span&gt;层高&lt;/span&gt;都是 1 至 32 之间的随机数。&lt;/li&gt;
&lt;li&gt;在同一个跳跃表中， 多个节点可以包含相同的分值， 但每个节点的成员对象必须是&lt;span&gt;唯一的&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;跳跃表中的节点按照分值大小进行&lt;span&gt;排序&lt;/span&gt;， 当分值相同时， 节点按照成员对象的大小进行排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;跳跃表的实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Redis 的跳跃表由 redis.h/zskiplistNode 和 redis.h/zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist 结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213201733089-1490815062.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 图 5-1 展示了一个跳跃表示例， 位于图片最左边的是 zskiplist 结构， 该结构包含以下属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;header ：指向跳跃表的表头节点。&lt;/li&gt;
&lt;li&gt;tail ：指向跳跃表的表尾节点。&lt;/li&gt;
&lt;li&gt;level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。&lt;/li&gt;
&lt;li&gt;length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。&lt;/li&gt;
&lt;li&gt;后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。&lt;/li&gt;
&lt;li&gt;分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。&lt;/li&gt;
&lt;li&gt;成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意表头节点和其他节点的构造是一样的： &lt;span&gt;表头节点也有后退指针、分值和成员对象&lt;/span&gt;， 不过表头节点的这些属性都不会被用到， 所以图中省略了这些部分， 只显示了表头节点的各个层。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;跳跃表节点 zskiplistNode&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;跳跃表节点的实现由 redis.h/zskiplistNode 结构定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zskiplistNode {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后退指针&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; zskiplistNode *&lt;span&gt;backward;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分值&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;double&lt;/span&gt;&lt;span&gt; score;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成员对象&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     robj *&lt;span&gt;obj;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 层&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zskiplistLevel {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前进指针&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;struct&lt;/span&gt; zskiplistNode *&lt;span&gt;forward;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跨度&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; span;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    } level[];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; } zskiplistNode;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;strong&gt;层&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;跳跃表节点的 level 数组可以包含多个元素， 每个元素都包含一个指向其他节点的指针， 程序可以通过这些层来&lt;span&gt;加快访问其他节点的速度&lt;/span&gt;， 一般来说， 层的数量越多， 访问其他节点的速度就越快。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;每次创建一个新跳跃表节点的时候， 程序都根据&lt;strong&gt;幂次定律&lt;/strong&gt; （&lt;a href=&quot;http://en.wikipedia.org/wiki/Power_law&quot;&gt;power law&lt;/a&gt;，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度&lt;/span&gt;”。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图 5-2 分别展示了三个高度为 1 层、 3 层和 5 层的节点， 因为 C 语言的数组索引总是从 0 开始的， 所以节点的第一层是 level[0] ， 而第二层是 level[1] ， 以此类推。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213201838639-805210660.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;&lt;strong&gt;前进指针&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;每个层都有一个指向表尾方向的前进指针（level[i].forward 属性）， 用于从表头向表尾方向访问节点。&lt;/p&gt;
&lt;p&gt;图 5-3 用虚线表示出了程序从表头向表尾方向， 遍历跳跃表中所有节点的路径：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;迭代程序首先访问跳跃表的第一个节点（表头）， 然后从第四层的前进指针移动到表中的第二个节点。&lt;/li&gt;
&lt;li&gt;在第二个节点时， 程序沿着第二层的前进指针移动到表中的第三个节点。&lt;/li&gt;
&lt;li&gt;在第三个节点时， 程序同样沿着第二层的前进指针移动到表中的第四个节点。&lt;/li&gt;
&lt;li&gt;当程序再次沿着第四个节点的前进指针移动时， 它碰到一个 NULL ， 程序知道这时已经到达了跳跃表的表尾， 于是结束这次遍历。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213201927518-2086782247.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;跨度&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;层的跨度（level[i].span 属性）用于记录两个节点之间的距离：
&lt;ul&gt;&lt;li&gt;   两个节点之间的跨度越大， 它们相距得就越远。&lt;/li&gt;
&lt;li&gt;   指向 NULL 的所有前进指针的跨度都为 0 ， 因为它们没有连向任何节点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;初看上去， 很容易以为跨度和遍历操作有关， 但实际上并不是这样 —— &lt;span&gt;遍历操作只使用前进指针就可以完成了， 跨度实际上是用来计算排位（rank）的&lt;/span&gt;： 在查找某个节点的过程中， 将沿途访问过的所有层的跨度累计起来， 得到的结果就是目标节点在跳跃表中的排位。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子， 图 5-4 用虚线标记了在跳跃表中查找分值为 3.0 、 成员对象为 o3 的节点时， 沿途经历的层： 查找的过程只经过了一个层， 并且层的跨度为 3 ， 所以目标节点在跳跃表中的排位为 3 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213202024590-570344443.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再举个例子， 图 5-5 用虚线标记了在跳跃表中查找分值为 2.0 、 成员对象为 o2 的节点时， 沿途经历的层： 在查找节点的过程中， 程序经过了两个跨度为 1 的节点， 因此可以计算出， 目标节点在跳跃表中的排位为 2 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213202038671-1204788410.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;后退指针&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;节点的后退指针（backward 属性）用于从表尾向表头方向访问节点： 跟可以一次跳过多个节点的前进指针不同， 因为&lt;span&gt;每个节点只有一个后退指针&lt;/span&gt;， 所以&lt;span&gt;每次只能后退至前一个节点&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图 5-6 用虚线展示了如果从表尾向表头遍历跳跃表中的所有节点： 程序首先通过跳跃表的 tail 指针访问表尾节点， 然后通过后退指针访问倒数第二个节点， 之后再沿着后退指针访问倒数第三个节点， 再之后遇到指向 NULL 的后退指针， 于是访问结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213202122053-915674055.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;&lt;strong&gt;分值和成员&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;节点的分值（score 属性）是一个 double 类型的浮点数， 跳跃表中的&lt;span&gt;所有节点都按&lt;strong&gt;分值&lt;/strong&gt;从小到大来排序&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;节点的成员对象（obj 属性）是一个指针， 它指向一个字符串对象， 而字符串对象则保存着一个 SDS 值。&lt;/li&gt;
&lt;li&gt;在同一个跳跃表中， 各个节点保存的成员对象必须是&lt;span&gt;唯一的&lt;/span&gt;， 但是多个节点保存的分值却可以是相同的： &lt;span&gt;分值相同的节点将按照成员对象在字典序中的大小来进行排序&lt;/span&gt;， 成员对象较小的节点会排在前面（靠近表头的方向）， 而成员对象较大的节点则会排在后面（靠近表尾的方向）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子， 在图 5-7 所示的跳跃表中， 三个跳跃表节点都保存了相同的分值 10086.0 ， 但保存成员对象 o1 的节点却排在保存成员对象 o2 和 o3 的节点之前， 而保存成员对象 o2 的节点又排在保存成员对象 o3 的节点之前， 由此可见， o1 、 o2 、 o3 三个成员对象在字典中的排序为 o1 &amp;lt;= o2 &amp;lt;= o3 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213202144716-2013979073.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;h2&gt;&lt;strong&gt;跳跃表 zskiplist&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;虽然仅靠多个跳跃表节点就可以组成一个跳跃表， 但通过使用一个 zskiplist 结构来持有这些节点， 程序可以更方便地对整个跳跃表进行处理， 比如快速访问跳跃表的表头节点和表尾节点， 又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息， 如图 5-9 所示。&lt;/p&gt;
&lt;p&gt;zskiplist 结构的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zskiplist {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表头节点和表尾节点&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; zskiplistNode *header, *&lt;span&gt;tail;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表中节点的数量&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; length;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表中层数最大的节点的层数&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; level;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;} zskiplist;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(&lt;span&gt;1&lt;/span&gt;) 。
&lt;/pre&gt;&lt;/div&gt;

&lt;div&gt;
&lt;ul&gt;&lt;li&gt;header 和 tail 指针分别指向跳跃表的表头和表尾节点， 通过这两个指针， 程序定位表头节点和表尾节点的复杂度为 O(1) 。&lt;/li&gt;
&lt;li&gt;length 属性用来记录节点的数量， 程序可以在 O(1) 复杂度内返回跳跃表的长度。&lt;/li&gt;
&lt;li&gt;level 属性则用于在 O(1) 复杂度内获取跳跃表中层高最大的那个节点的层数量， 注意表头节点的层高并不计算在&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213202308806-23936195.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;hr/&gt;


&lt;p&gt;整数集合（intset）是集合键的底层实现之一： &lt;span&gt;当一个集合只包含整数值元素， 并且这个集合的元素数量不多时&lt;/span&gt;， Redis 就会使用整数集合作为集合键的底层实现。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;整数集合是&lt;span&gt;集合键&lt;/span&gt;的底层实现之一。&lt;/li&gt;
&lt;li&gt;整数集合的&lt;span&gt;底层实现为数组&lt;/span&gt;， 这个数组以&lt;span&gt;有序&lt;/span&gt;、&lt;span&gt;无重复&lt;/span&gt;的方式保存集合元素， 在有需要时， 程序会根据新添加元素的类型， 改变这个数组的类型。&lt;/li&gt;
&lt;li&gt;升级操作为整数集合带来了操作上的灵活性， 并且尽可能地节约了内存。&lt;/li&gt;
&lt;li&gt;整数集合只支持升级操作， 不支持降级操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;整数集合的实现&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 &lt;strong&gt;int16_t&lt;/strong&gt; 、 int32_t 或者 &lt;strong&gt;int64_t&lt;/strong&gt; 的整数值， 并且保证集合中不会出现重复元素。&lt;/p&gt;
&lt;p&gt;每个 intset.h/intset 结构表示一个整数集合：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; intset {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编码方式&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    uint32_t encoding;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 集合包含的元素数量&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    uint32_t length;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存元素的数组&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    int8_t contents[];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;} intset;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。&lt;/li&gt;
&lt;li&gt;length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 encoding 属性的值为 INTSET_ENC_INT16 ， 那么 contents 就是一个 &lt;strong&gt;int16_t&lt;/strong&gt; 类型的数组， 数组里的每个项都是一个 int16_t 类型的整数值 （最小值为 -32,768 ，最大值为 32,767 ）。&lt;/li&gt;
&lt;li&gt;如果 encoding 属性的值为 INTSET_ENC_INT32 ， 那么 contents 就是一个 &lt;strong&gt;int32_t&lt;/strong&gt; 类型的数组， 数组里的每个项都是一个 int32_t 类型的整数值 （最小值为 -2,147,483,648 ，最大值为 2,147,483,647 ）。&lt;/li&gt;
&lt;li&gt;如果 encoding 属性的值为 INTSET_ENC_INT64 ， 那么 contents 就是一个 &lt;strong&gt;int64_t&lt;/strong&gt; 类型的数组， 数组里的每个项都是一个 int64_t 类型的整数值 （最小值为 -9,223,372,036,854,775,808 ，最大值为 9,223,372,036,854,775,807 ）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;升级&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。&lt;/p&gt;
&lt;p&gt;升级整数集合并添加新元素共分为三步进行：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。&lt;/li&gt;
&lt;li&gt;将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。&lt;/li&gt;
&lt;li&gt;将新元素添加到底层数组里面。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因为每次向整数集合添加新元素都可能会引起升级， 而每次升级都需要对底层数组中已有的所有元素进行类型转换， 所以向整数集合添加新元素的时间复杂度为 O(N) 。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;升级之后新元素的摆放位置&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;因为引发升级的新元素的长度总是比整数集合现有所有元素的长度都大， 所以这个新元素的值要么就大于所有现有元素， 要么就小于所有现有元素：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在新元素小于所有现有元素的情况下， 新元素会被放置在底层数组的最开头（索引 0 ）；&lt;/li&gt;
&lt;li&gt;在新元素大于所有现有元素的情况下， 新元素会被放置在底层数组的最末尾（索引 length-1 ）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;升级的好处&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;整数集合的升级策略有两个好处， 一个是提升整数集合的灵活性， 另一个是尽可能地节约内存。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;提升灵活性&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。&lt;/li&gt;
&lt;li&gt;整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;节约内存&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;要让一个数组可以同时保存 int16_t 、 int32_t 、 int64_t 三种类型的值， 最简单的做法就是直接使用 int64_t 类型的数组作为整数集合的底层实现。不过这样一来，就会出现浪费内存的情况。&lt;/li&gt;
&lt;li&gt;整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;降级&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;整数集合&lt;span&gt;不支持降级操作&lt;/span&gt;， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。&lt;/li&gt;
&lt;li&gt;举个例子， 对于一个整数集合来说， 即使我们将集合里唯一一个真正需要使用 int64_t 类型来保存的元素 4294967295 删除了， 整数集合的编码仍然会维持 INTSET_ENC_INT64 ， 底层数组也仍然会是 int64_t 类型的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;整数集合 API&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表 6-1 列出了整数集合的操作 API 。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;函数&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;td&gt;时间复杂度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;intsetNew&lt;/td&gt;
&lt;td&gt;创建一个新的整数集合。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;intsetAdd&lt;/td&gt;
&lt;td&gt;将给定元素添加到整数集合里面。&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;intsetRemove&lt;/td&gt;
&lt;td&gt;从整数集合中移除给定元素。&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;intsetFind&lt;/td&gt;
&lt;td&gt;检查给定值是否存在于集合。&lt;/td&gt;
&lt;td&gt;因为底层数组有序，查找可以通过二分查找法来进行， 所以复杂度为 O(\log N) 。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;intsetRandom&lt;/td&gt;
&lt;td&gt;从整数集合中随机返回一个元素。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;intsetGet&lt;/td&gt;
&lt;td&gt;取出底层数组在给定索引上的元素。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;intsetLen&lt;/td&gt;
&lt;td&gt;返回整数集合包含的元素个数。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;intsetBlobLen&lt;/td&gt;
&lt;td&gt;返回整数集合占用的内存字节数。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;hr/&gt;

&lt;h2&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;压缩列表是一种&lt;span&gt;为节约内存&lt;/span&gt;而开发的&lt;span&gt;顺序型&lt;/span&gt;数据结构。&lt;/li&gt;
&lt;li&gt;压缩列表被用作&lt;span&gt;列表键&lt;/span&gt;和&lt;span&gt;哈希键&lt;/span&gt;的底层实现之一。&lt;/li&gt;
&lt;li&gt;压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。&lt;/li&gt;
&lt;li&gt;添加新节点到压缩列表， 或者从压缩列表中删除节点， 可能会引发&lt;span&gt;连锁更新&lt;/span&gt;操作， 但这种操作出现的几率并不高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;压缩列表的构成&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。&lt;/li&gt;
&lt;li&gt;一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213202815430-1631295388.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;表 7-1 压缩列表各个组成部分的详细说明&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;属性&lt;/td&gt;
&lt;td&gt;类型&lt;/td&gt;
&lt;td&gt;长度&lt;/td&gt;
&lt;td&gt;用途&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;zlbytes&lt;/td&gt;
&lt;td&gt;uint32_t&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;记录整个压缩列表&lt;span&gt;占用的内存字节数&lt;/span&gt;：在对压缩列表进行内存重分配， 或者计算 zlend 的位置时使用。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;zltail&lt;/td&gt;
&lt;td&gt;uint32_t&lt;/td&gt;
&lt;td&gt;4 字节&lt;/td&gt;
&lt;td&gt;记录压缩列表&lt;span&gt;表尾节点距离压缩列表的起始地址有多少字节&lt;/span&gt;： 通过这个偏移量，程序无须遍历整个压缩列表就可以确定表尾节点的地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;zllen&lt;/td&gt;
&lt;td&gt;uint16_t&lt;/td&gt;
&lt;td&gt;2 字节&lt;/td&gt;
&lt;td&gt;记录了压缩列表包含的节点数量： 当这个属性的值小于 UINT16_MAX （65535）时， 这个属性的值就是压缩列表包含节点的数量； 当这个值等于 UINT16_MAX 时， 节点的真实数量需要遍历整个压缩列表才能计算得出。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;entryX&lt;/td&gt;
&lt;td&gt;列表节点&lt;/td&gt;
&lt;td&gt;不定&lt;/td&gt;
&lt;td&gt;压缩列表&lt;span&gt;包含的各个节点&lt;/span&gt;，节点的长度由节点保存的内容决定。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;zlend&lt;/td&gt;
&lt;td&gt;uint8_t&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;&lt;span&gt;特殊值 0xFF （十进制 255 &lt;/span&gt;），用于标记压缩列表的末端。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;strong&gt;压缩列表节点的构成&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成， 如图 7-4 所示。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213202833355-989740956.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;每个压缩列表节点可以保存一个字节数组或者一个整数值， 其中， 字节数组可以是以下三种长度的其中一种：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;长度小于等于 63 （2^{6}-1）字节的字节数组；&lt;/li&gt;
&lt;li&gt;长度小于等于 16383 （2^{14}-1） 字节的字节数组；&lt;/li&gt;
&lt;li&gt;长度小于等于 4294967295 （2^{32}-1）字节的字节数组；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;而整数值则可以是以下六种长度的其中一种：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;4 位长，介于 0 至 12 之间的无符号整数；&lt;/li&gt;
&lt;li&gt;1 字节长的有符号整数；&lt;/li&gt;
&lt;li&gt;3 字节长的有符号整数；&lt;/li&gt;
&lt;li&gt;int16_t 类型整数；&lt;/li&gt;
&lt;li&gt;int32_t 类型整数；&lt;/li&gt;
&lt;li&gt;int64_t 类型整数。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;previous_entry_length&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;节点的 previous_entry_length 属性&lt;span&gt;以字节为单位&lt;/span&gt;， 记录了压缩列表中前一个节点的长度。&lt;/li&gt;
&lt;li&gt;previous_entry_length 属性的长度可以是 1 字节或者 5 字节：&lt;/li&gt;
&lt;li&gt;如果前一节点的&lt;span&gt;长度小于 254 字节&lt;/span&gt;， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。&lt;/li&gt;
&lt;li&gt;如果前一节点的&lt;span&gt;长度大于等于 254 字节&lt;/span&gt;， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。&lt;/li&gt;
&lt;li&gt;因为节点的 previous_entry_length 属性记录了前一个节点的长度， 所以程序可以通过指针运算， 根据当前节点的起始地址来计算出前一个节点的起始地址。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图 7-5 展示了一个包含一字节长 previous_entry_length 属性的压缩列表节点， 属性的值为 0x05 ， 表示前一节点的长度为 5 字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213203008977-1502390622.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 7-6 展示了一个包含五字节长 previous_entry_length 属性的压缩节点， 属性的值为 0xFE00002766 ， 其中值的最高位字节 0xFE 表示这是一个五字节长的 previous_entry_length 属性， 而之后的四字节 0x00002766 （十进制值 10086 ）才是前一节点的实际长度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213203020920-2084519213.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;encoding&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;节点的 encoding 属性记录了节点的 content 属性所保存数据的&lt;strong&gt;&lt;span&gt;类型&lt;/span&gt;&lt;/strong&gt;以及&lt;strong&gt;&lt;span&gt;长度&lt;/span&gt;&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一字节、两字节或者五字节长&lt;/span&gt;， 值的&lt;span&gt;最高位为 00 、 01 或者 10 的是字节数组编码&lt;/span&gt;： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一字节长&lt;/span&gt;， 值的&lt;span&gt;最高位以 11 开头的是整数编码&lt;/span&gt;： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表 7-2 记录了所有可用的字节数组编码， 而表 7-3 则记录了所有可用的整数编码。 表格中的下划线 _ 表示留空， 而 b 、 x 等变量则代表实际的二进制数据， 为了方便阅读， 多个字节之间用空格隔开。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;编码&lt;/td&gt;
&lt;td&gt;编码长度&lt;/td&gt;
&lt;td&gt;content 属性保存的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;00bbbbbb&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;长度小于等于 63 字节的字节数组。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;01bbbbbb xxxxxxxx&lt;/td&gt;
&lt;td&gt;2 字节&lt;/td&gt;
&lt;td&gt;长度小于等于 16383 字节的字节数组。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;10______ aaaaaaaa bbbbbbbb cccccccc dddddddd&lt;/td&gt;
&lt;td&gt;5 字节&lt;/td&gt;
&lt;td&gt;长度小于等于 4294967295 的字节数组。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;表 7-3 整数编码&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;编码&lt;/td&gt;
&lt;td&gt;编码长度&lt;/td&gt;
&lt;td&gt;content 属性保存的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;11000000&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;int16_t 类型的整数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;11010000&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;int32_t 类型的整数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;11100000&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;int64_t 类型的整数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;11110000&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;24 位有符号整数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;11111110&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;8 位有符号整数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;1111xxxx&lt;/td&gt;
&lt;td&gt;1 字节&lt;/td&gt;
&lt;td&gt;使用这一编码的节点没有相应的 content 属性， 因为编码本身的 xxxx 四个位已经保存了一个介于 0 和 12 之间的值， 所以它无须 content 属性。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;&lt;strong&gt;content&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， &lt;span&gt;值的类型和长度由节点的 encoding 属性决定&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;图 7-9 展示了一个保存字节数组的节点示例：&lt;/li&gt;
&lt;li&gt;编码的最高两位 00 表示节点保存的是一个字节数组；&lt;/li&gt;
&lt;li&gt;编码的后六位 001011 记录了字节数组的长度 11 ；&lt;/li&gt;
&lt;li&gt;content 属性保存着节点的值 &quot;hello world&quot; 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213203134620-1320264021.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图 7-10 展示了一个保存整数值的节点示例：&lt;/li&gt;
&lt;li&gt;编码 11000000 表示节点保存的是一个 int16_t 类型的整数值；&lt;/li&gt;
&lt;li&gt;content 属性保存着节点的值 10086 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213203148358-292350211.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;连锁更新&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;添加&lt;/span&gt;&lt;/strong&gt;新节点可能会引发连锁更新之外，&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;删除&lt;/span&gt;&lt;/strong&gt;节点也可能会引发连锁更新。&lt;/li&gt;
&lt;li&gt;因为连锁更新在最坏情况下需要对压缩列表执行 N 次空间重分配操作， 而每次空间重分配的最坏复杂度为 O(N) ， 所以连锁更新的&lt;span&gt;最坏复杂度为 O(N^2) &lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;要注意的是， 尽管连锁更新的复杂度较高， 但它&lt;span&gt;真正造成性能问题的几率是很低&lt;/span&gt;的：&lt;/li&gt;
&lt;li&gt;首先， 压缩列表里要恰好有多个连续的、长度介于 250 字节至 253 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见；&lt;/li&gt;
&lt;li&gt;其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响： 比如说， 对三五个节点进行连锁更新是绝对不会影响性能的；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为以上原因， ziplistPush 等命令的平均复杂度仅为 O(N) ， 在实际中， 我们可以放心地使用这些函数， 而不必担心连锁更新会影响压缩列表的性能。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;压缩列表 API&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;表 7-4 列出了所有用于操作压缩列表的 API 。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;函数&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;td&gt;算法复杂度&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ziplistNew&lt;/td&gt;
&lt;td&gt;创建一个新的压缩列表。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;ziplistPush&lt;/td&gt;
&lt;td&gt;创建一个包含给定值的新节点， 并将这个新节点添加到压缩列表的表头或者表尾。&lt;/td&gt;
&lt;td&gt;平均 O(N) ，最坏 O(N^2) 。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ziplistInsert&lt;/td&gt;
&lt;td&gt;将包含给定值的新节点插入到给定节点之后。&lt;/td&gt;
&lt;td&gt;平均 O(N) ，最坏 O(N^2) 。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ziplistIndex&lt;/td&gt;
&lt;td&gt;返回压缩列表给定索引上的节点。&lt;/td&gt;
&lt;td&gt;O(N)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;ziplistFind&lt;/td&gt;
&lt;td&gt;在压缩列表中查找并返回包含了给定值的节点。&lt;/td&gt;
&lt;td&gt;因为节点的值可能是一个字节数组， 所以检查节点值和给定值是否相同的复杂度为 O(N) ， 而查找整个列表的复杂度则为 O(N^2) 。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ziplistNext&lt;/td&gt;
&lt;td&gt;返回给定节点的下一个节点。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ziplistPrev&lt;/td&gt;
&lt;td&gt;返回给定节点的前一个节点。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ziplistGet&lt;/td&gt;
&lt;td&gt;获取给定节点所保存的值。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ziplistDelete&lt;/td&gt;
&lt;td&gt;从压缩列表中删除给定的节点。&lt;/td&gt;
&lt;td&gt;平均 O(N) ，最坏 O(N^2) 。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ziplistDeleteRange&lt;/td&gt;
&lt;td&gt;删除压缩列表在给定索引上的连续多个节点。&lt;/td&gt;
&lt;td&gt;平均 O(N) ，最坏 O(N^2) 。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ziplistBlobLen&lt;/td&gt;
&lt;td&gt;返回压缩列表目前占用的内存字节数。&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ziplistLen&lt;/td&gt;
&lt;td&gt;返回压缩列表目前包含的节点数量。&lt;/td&gt;
&lt;td&gt;节点数量小于 65535 时 O(1) ， 大于 65535 时 O(N) 。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;因为 ziplistPush 、 ziplistInsert 、 ziplistDelete 和 ziplistDeleteRange 四个函数都有可能会引发连锁更新， 所以它们的最坏复杂度都是 O(N^2) 。&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;在前面的数个章节里， 我们陆续介绍了 Redis 用到的所有主要数据结构， 比如简单动态字符串（SDS）、双端链表、字典、压缩列表、整数集合， 等等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Redis 并没有直接使用这些数据结构来实现键值对数据库， 而是&lt;strong&gt;基于这些数据结构创建了一个对象系统&lt;/strong&gt;， 这个系统包含&lt;strong&gt;字符串对象&lt;/strong&gt;、&lt;strong&gt;列表对象&lt;/strong&gt;、&lt;strong&gt;哈希对象&lt;/strong&gt;、&lt;strong&gt;集合对象&lt;/strong&gt;和&lt;strong&gt;有序集合对象&lt;/strong&gt;这五种类型的对象， &lt;span&gt;每种对象都用到了至少一种我们前面所介绍的数据结构&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;通过这五种不同类型的对象，（1）Redis 可以在执行命令之前， 根据对象的类型来判断一个对象是否可以执行给定的命令。 （2）可以针对不同的使用场景， 为对象设置多种不同的数据结构实现， 从而优化对象在不同场景下的使用效率。&lt;/li&gt;
&lt;li&gt;Redis 的对象系统还实现了基于&lt;strong&gt;引用计数技术&lt;/strong&gt;的&lt;span&gt;内存回收机制&lt;/span&gt;： 当程序不再使用某个对象的时候， 这个对象所占用的内存就会被自动释放； 另外， Redis 还通过引用计数技术实现了&lt;span&gt;对象共享机制&lt;/span&gt;， 这一机制可以在适当的条件下， 通过让多个数据库键共享同一个对象来节约内存。&lt;/li&gt;
&lt;li&gt;最后， Redis 的对象带有&lt;span&gt;访问时间记录信息&lt;/span&gt;， 该信息可以用于计算数据库键的空转时长， 在服务器启用了 maxmemory 功能的情况下， 空转时长较大的那些键可能会优先被服务器删除。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Redis 数据库中的每个键值对的键和值都是一个对象。&lt;/li&gt;
&lt;li&gt;Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象， 每种类型的对象至少都有两种或以上的编码方式， 不同的编码可以在不同的使用场景上优化对象的使用效率。&lt;/li&gt;
&lt;li&gt;服务器在执行某些命令之前， 会先检查给定键的类型能否执行指定的命令， 而检查一个键的类型就是检查键的值对象的类型。&lt;/li&gt;
&lt;li&gt;Redis 的对象系统带有引用计数实现的内存回收机制， 当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。&lt;/li&gt;
&lt;li&gt;Redis 会共享值为 0 到 9999 的字符串对象。&lt;/li&gt;
&lt;li&gt;对象会记录自己的最后一次被访问的时间， 这个时间可以用于计算对象的空转时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;对象的类型与编码&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。&lt;/li&gt;
&lt;li&gt;Redis 中的每个对象都由一个 redisObject 结构表示， 该结构中和保存数据有关的三个属性分别是 type 属性、 encoding 属性和 ptr 属性：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; redisObject {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类型&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     unsigned type:&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编码&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     unsigned encoding:&lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指向底层实现数据结构的指针&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;ptr;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; } robj;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;举个例子， 以下 SET 命令在数据库中创建了一个新的键值对， 其中键值对的键是一个包含了字符串值 &quot;msg&quot; 的对象， 而键值对的值则是一个包含了字符串值 &quot;hello world&quot; 的对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; SET msg &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; OK
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对象的 type 属性记录了对象的类型， 这个属性的值可以是以下常量的其中一个。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表 8-1 对象的类型&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;类型常量&lt;/td&gt;
&lt;td&gt;对象的名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;字符串对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;REDIS_LIST&lt;/td&gt;
&lt;td&gt;列表对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;REDIS_HASH&lt;/td&gt;
&lt;td&gt;哈希对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;REDIS_SET&lt;/td&gt;
&lt;td&gt;集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;REDIS_ZSET&lt;/td&gt;
&lt;td&gt;有序集合对象&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;对于 Redis 数据库保存的键值对来说， &lt;span&gt;键总是一个字符串对象， 而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种&lt;/span&gt;， 因此：&lt;/li&gt;
&lt;li&gt;当我们称呼一个数据库键为“字符串键”时， 我们指的是“这个数据库键所对应的值为字符串对象”；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当我们称呼一个键为“列表键”时， 我们指的是“这个数据库键所对应的值为列表对象”，&lt;/span&gt;诸如此类。&lt;/li&gt;
&lt;li&gt;TYPE 命令的实现方式也与此类似， 当我们对一个数据库键执行 TYPE 命令时， 命令返回的结果为数据库键对应的值对象的类型， 而不是键对象的类型：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;# 键为字符串对象，值为列表对象
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; redis&amp;gt; RPUSH numbers &lt;span&gt;1&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; (integer) &lt;span&gt;6&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; redis&amp;gt;&lt;span&gt; TYPE numbers
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; list
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;表 8-2 列出了 TYPE 命令在面对不同类型的值对象时所产生的输出。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;对象&lt;/td&gt;
&lt;td&gt;对象 type 属性的值&lt;/td&gt;
&lt;td&gt;TYPE 命令的输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;字符串对象&lt;/td&gt;
&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;&quot;string&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;列表对象&lt;/td&gt;
&lt;td&gt;REDIS_LIST&lt;/td&gt;
&lt;td&gt;&quot;list&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;哈希对象&lt;/td&gt;
&lt;td&gt;REDIS_HASH&lt;/td&gt;
&lt;td&gt;&quot;hash&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;集合对象&lt;/td&gt;
&lt;td&gt;REDIS_SET&lt;/td&gt;
&lt;td&gt;&quot;set&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;有序集合对象&lt;/td&gt;
&lt;td&gt;REDIS_ZSET&lt;/td&gt;
&lt;td&gt;&quot;zset&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;&lt;strong&gt;编码和底层实现&lt;/strong&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;encoding 属性记录了对象所使用的编码， 也即是说这个对象使用了什么数据结构作为对象的底层实现， 这个属性的值可以是表 8-3 列出的常量的其中一个。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;编码常量&lt;/td&gt;
&lt;td&gt;编码所对应的底层数据结构&lt;/td&gt;
&lt;td&gt;OBJECT ENCODING 命令输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;REDIS_ENCODING_INT&lt;/td&gt;
&lt;td&gt;long 类型的整数&lt;/td&gt;
&lt;td&gt;&quot;int&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_ENCODING_EMBSTR&lt;/td&gt;
&lt;td&gt;embstr 编码的简单动态字符串&lt;/td&gt;
&lt;td&gt;&quot;embstr&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;REDIS_ENCODING_RAW&lt;/td&gt;
&lt;td&gt;简单动态字符串&lt;/td&gt;
&lt;td&gt;&quot;raw&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;REDIS_ENCODING_HT&lt;/td&gt;
&lt;td&gt;字典&lt;/td&gt;
&lt;td&gt;&quot;hashtable&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_ENCODING_LINKEDLIST&lt;/td&gt;
&lt;td&gt;双端链表&lt;/td&gt;
&lt;td&gt;&quot;linkedlist&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;REDIS_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td&gt;压缩列表&lt;/td&gt;
&lt;td&gt;&quot;ziplist&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;REDIS_ENCODING_INTSET&lt;/td&gt;
&lt;td&gt;整数集合&lt;/td&gt;
&lt;td&gt;&quot;intset&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;REDIS_ENCODING_SKIPLIST&lt;/td&gt;
&lt;td&gt;跳跃表和字典&lt;/td&gt;
&lt;td&gt;&quot;skiplist&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ol&gt;&lt;li&gt;其中，每种type类型的对象都至少使用了两种不同的编码， 表 8-4 不同类型和编码的对象&lt;/li&gt;
&lt;/ol&gt;&lt;table&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;类型常量&lt;/td&gt;
&lt;td&gt;编码&lt;/td&gt;
&lt;td&gt;对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_INT&lt;/td&gt;
&lt;td&gt;使用整数值实现的字符串对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_EMBSTR&lt;/td&gt;
&lt;td&gt;使用 embstr 编码的简单动态字符串实现的字符串对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_STRING&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_RAW&lt;/td&gt;
&lt;td&gt;使用简单动态字符串实现的字符串对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_LIST&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td&gt;使用压缩列表实现的列表对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;REDIS_LIST&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_LINKEDLIST&lt;/td&gt;
&lt;td&gt;使用双端链表实现的列表对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_HASH&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td&gt;使用压缩列表实现的哈希对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_HASH&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_HT&lt;/td&gt;
&lt;td&gt;使用字典实现的哈希对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_SET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_INTSET&lt;/td&gt;
&lt;td&gt;使用整数集合实现的集合对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_SET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_HT&lt;/td&gt;
&lt;td&gt;使用字典实现的集合对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_ZSET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_ZIPLIST&lt;/td&gt;
&lt;td&gt;使用压缩列表实现的有序集合对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REDIS_ZSET&lt;/td&gt;
&lt;td&gt;REDIS_ENCODING_SKIPLIST&lt;/td&gt;
&lt;td&gt;使用跳跃表和字典实现的有序集合对象。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用 OBJECT ENCODING 命令可以查看一个数据库键的值对象的编码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; redis&amp;gt; SET msg &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello wrold&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT ENCODING msg
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;embstr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; redis&amp;gt; SET story &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;long long long long long long ago ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT ENCODING story
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;raw&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; redis&amp;gt; SADD numbers &lt;span&gt;1&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; (integer) &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT ENCODING numbers
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;intset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; redis&amp;gt; SADD numbers &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seven&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; (integer) &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT ENCODING numbers
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hashtable&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ol&gt;&lt;li&gt;通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个例子， 在列表对象包含的元素比较少时， Redis 使用压缩列表作为列表对象的底层实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为压缩列表比双端链表更节约内存， 并且在元素数量较少时， 在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；&lt;/li&gt;
&lt;li&gt;随着列表对象包含的元素越来越多， 使用压缩列表来保存元素的优势逐渐消失时， 对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他类型的对象也会通过使用多种不同的编码来进行类似的优化。&lt;/p&gt;
&lt;p&gt;在接下来的内容中， 我们将分别介绍 Redis 中的五种不同类型的对象， 说明这些对象底层所使用的编码方式， 列出对象从一种编码转换成另一种编码所需的条件， 以及同一个命令在多种不同编码上的实现方法。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;字符串对象&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;字符串对象的编码可以是 int 、 raw 或者 embstr 。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;如果一个字符串对象保存的是整数值， 并且这个整数值可以用 long 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 ptr 属性里面（将 void* 转换成 long ）， 并将字符串对象的编码设置为 int 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子， 如果我们执行以下 SET 命令， 那么服务器将创建一个如图 8-1 所示的 int 编码的字符串对象作为 number 键的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; SET number &lt;span&gt;10086&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT ENCODING number
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213204534536-2117455381.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 39 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 raw 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子， 如果我们执行以下命令， 那么服务器将创建一个如图 8-2 所示的 raw 编码的字符串对象作为 story 键的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; SET story &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Long, long, long ago there lived a king ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; redis&amp;gt;&lt;span&gt; STRLEN story
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; (integer) &lt;span&gt;43&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT ENCODING story
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;raw&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213204612336-472902472.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 39 字节， 那么字符串对象将使用 embstr 编码的方式来保存这个字符串值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;embstr 编码是专门用于保存短字符串的一种优化编码方式， 这种编码和 raw 编码一样， 都使用 redisObject 结构和 sdshdr 结构来表示字符串对象， 但 raw 编码会调用两次内存分配函数来分别创建 redisObject 结构和 sdshdr 结构， 而 &lt;span&gt;embstr 编码则通过调用一次内存分配函数来分配一块连续的空间， 空间中依次包含 redisObject 和 sdshdr 两个结构&lt;/span&gt;， 如图 8-3 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213204638487-1449394337.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;embstr 编码的字符串对象在执行命令时， 产生的效果和 raw 编码的字符串对象执行命令时产生的效果是相同的， 但使用 embstr 编码的字符串对象来保存短字符串值有以下好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;embstr 编码将创建字符串对象所需的内存分配次数从 raw 编码的两次降低为一次。&lt;/li&gt;
&lt;li&gt;释放 embstr 编码的字符串对象只需要调用一次内存释放函数， 而释放 raw 编码的字符串对象需要调用两次内存释放函数。&lt;/li&gt;
&lt;li&gt;因为 embstr 编码的字符串对象的所有数据都保存在一块连续的内存里面， 所以这种编码的字符串对象比起 raw 编码的字符串对象能够更好地利用缓存带来的优势。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;作为例子， 以下命令创建了一个 embstr 编码的字符串对象作为 msg 键的值， 值对象的样子如图 8-4 所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; SET msg &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT ENCODING msg
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;embstr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213204742276-945928816.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;最后要说的是， 可以用 long double 类型表示的浮点数在 Redis 中也是作为字符串值来保存的： 如果我们要保存一个浮点数到字符串对象里面， 那么程序会先将这个浮点数转换成字符串值， 然后再保存起转换所得的字符串值。在有需要的时候， 程序会将保存在字符串对象里面的字符串值转换回浮点数值， 执行某些操作， 然后再将执行操作所得的浮点数值转换回字符串值， 并继续保存在字符串对象里面。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;表 8-6 字符串对象保存各类型值的编码方式&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;值&lt;/td&gt;
&lt;td&gt;编码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;可以用 long 类型保存的整数。&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;可以用 long double 类型保存的浮点数。&lt;/td&gt;
&lt;td&gt;embstr 或者 raw&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;字符串值， 或者因为长度太大而没办法用 long 类型表示的整数， 又或者因为长度太大而没办法用 long double 类型表示的浮点数。&lt;/td&gt;
&lt;td&gt;embstr 或者 raw&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h3&gt;&lt;strong&gt;编码的转换&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;int 编码的字符串对象和 embstr 编码的字符串对象在条件满足的情况下， 会被转换为 raw 编码的字符串对象。&lt;/li&gt;
&lt;li&gt;对于 int 编码的字符串对象来说， 如果我们向对象执行了一些命令， 使得这个对象保存的不再是整数值， 而是一个字符串值， 那么字符串对象的编码将从 int 变为 raw 。比如APPEND 命令&lt;/li&gt;
&lt;li&gt;另外， 因为 Redis 没有为 embstr 编码的字符串对象编写任何相应的修改程序 （只有 int 编码的字符串对象和 raw 编码的字符串对象有这些程序）， 所以 embstr 编码的字符串对象实际上是只读的： 当我们对 embstr 编码的字符串对象执行任何修改命令时， 程序会先将对象的编码从 embstr 转换成 raw ， 然后再执行修改命令； 因为这个原因， embstr 编码的字符串对象在执行修改命令之后， 总会变成一个 raw 编码的字符串对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;字符串命令的实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为字符串键的值为字符串对象， 所以用于字符串键的所有命令都是针对字符串对象来构建的， 表 8-7 列举了其中一部分字符串命令， 以及这些命令在不同编码的字符串对象下的实现方法。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;33&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;命令&lt;/td&gt;
&lt;td&gt;int 编码的实现方法&lt;/td&gt;
&lt;td&gt;embstr 编码的实现方法&lt;/td&gt;
&lt;td&gt;raw 编码的实现方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;SET&lt;/td&gt;
&lt;td&gt;使用 int 编码保存值。&lt;/td&gt;
&lt;td&gt;使用 embstr 编码保存值。&lt;/td&gt;
&lt;td&gt;使用 raw 编码保存值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;GET&lt;/td&gt;
&lt;td&gt;拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后向客户端返回这个字符串值。&lt;/td&gt;
&lt;td&gt;直接向客户端返回字符串值。&lt;/td&gt;
&lt;td&gt;直接向客户端返回字符串值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;APPEND&lt;/td&gt;
&lt;td&gt;将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。&lt;/td&gt;
&lt;td&gt;将对象转换成 raw 编码， 然后按 raw 编码的方式执行此操作。&lt;/td&gt;
&lt;td&gt;调用 sdscatlen 函数， 将给定字符串追加到现有字符串的末尾。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;11&quot;&gt;&lt;td&gt;INCRBYFLOAT&lt;/td&gt;
&lt;td&gt;取出整数值并将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。&lt;/td&gt;
&lt;td&gt;取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。&lt;/td&gt;
&lt;td&gt;取出字符串值并尝试将其转换成 long double 类型的浮点数， 对这个浮点数进行加法计算， 然后将得出的浮点数结果保存起来。 如果字符串值不能被转换成浮点数， 那么向客户端返回一个错误。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;INCRBY&lt;/td&gt;
&lt;td&gt;对整数值进行加法计算， 得出的计算结果会作为整数被保存起来。&lt;/td&gt;
&lt;td&gt;embstr 编码不能执行此命令， 向客户端返回一个错误。&lt;/td&gt;
&lt;td&gt;raw 编码不能执行此命令， 向客户端返回一个错误。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;DECRBY&lt;/td&gt;
&lt;td&gt;对整数值进行减法计算， 得出的计算结果会作为整数被保存起来。&lt;/td&gt;
&lt;td&gt;embstr 编码不能执行此命令， 向客户端返回一个错误。&lt;/td&gt;
&lt;td&gt;raw 编码不能执行此命令， 向客户端返回一个错误。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;7&quot;&gt;&lt;td&gt;STRLEN&lt;/td&gt;
&lt;td&gt;拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 计算并返回这个字符串值的长度。&lt;/td&gt;
&lt;td&gt;调用 sdslen 函数， 返回字符串的长度。&lt;/td&gt;
&lt;td&gt;调用 sdslen 函数， 返回字符串的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;SETRANGE&lt;/td&gt;
&lt;td&gt;将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。&lt;/td&gt;
&lt;td&gt;将对象转换成 raw 编码， 然后按 raw 编码的方式执行此命令。&lt;/td&gt;
&lt;td&gt;将字符串特定索引上的值设置为给定的字符。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;GETRANGE&lt;/td&gt;
&lt;td&gt;拷贝对象所保存的整数值， 将这个拷贝转换成字符串值， 然后取出并返回字符串指定索引上的字符。&lt;/td&gt;
&lt;td&gt;直接取出并返回字符串指定索引上的字符。&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;strong&gt;列表对象&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;列表对象的编码可以是 ziplist 或者 linkedlist 。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;ziplist 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。&lt;/li&gt;
&lt;li&gt;另一方面， linkedlist 编码的列表对象使用双端链表作为底层实现， 每个双端链表节点（node）都保存了一个字符串对象， 而每个字符串对象都保存了一个列表元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子， 如果我们执行以下 RPUSH 命令， 那么服务器将创建一个列表对象作为 numbers 键的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; RPUSH numbers &lt;span&gt;1&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;three&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; (integer) &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213235939440-1789943620.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210213235947178-1664743356.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 注意， linkedlist 编码的列表对象在底层的双端链表结构中包含了多个字符串对象， 这种嵌套字符串对象的行为在稍后介绍的哈希对象、集合对象和有序集合对象中都会出现， 字符串对象是 Redis 五种类型的对象中唯一一种会被其他四种类型对象嵌套的对象。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了简化字符串对象的表示， 我们在图 8-6 使用了一个带有 StringObject 字样的格子来表示一个字符串对象， 而 StringObject 字样下面的是字符串对象所保存的值。&lt;/p&gt;
&lt;p&gt;比如说， 图 8-7 代表的就是一个包含了字符串值 &quot;three&quot; 的字符串对象， 它是 8-8 的简化表示。&lt;/p&gt;
&lt;p&gt;本书接下来的内容将继续沿用这一简化表示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214000043794-329550398.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214000145383-1120703495.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;编码转换&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;列表对象保存的所有字符串&lt;span&gt;元素的长度都小于 64 字节&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;列表对象保存的元素&lt;span&gt;数量小于 512 个&lt;/span&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不能满足这两个条件的列表对象需要使用 linkedlist 编码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有列表元素都会被转移并保存到双端链表里面， 对象的编码也会从 ziplist 变为 linkedlist 。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;列表命令的实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为列表键的值为列表对象， 所以用于列表键的所有命令都是针对列表对象来构建的，&lt;/p&gt;
&lt;p&gt;表 8-8 列出了其中一部分列表键命令， 以及这些命令在不同编码的列表对象下的实现方法。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;27.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;命令&lt;/td&gt;
&lt;td&gt;ziplist 编码的实现方法&lt;/td&gt;
&lt;td&gt;linkedlist 编码的实现方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;LPUSH&lt;/td&gt;
&lt;td&gt;调用 ziplistPush 函数， 将新元素推入到压缩列表的表头。&lt;/td&gt;
&lt;td&gt;调用 listAddNodeHead 函数， 将新元素推入到双端链表的表头。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;RPUSH&lt;/td&gt;
&lt;td&gt;调用 ziplistPush 函数， 将新元素推入到压缩列表的表尾。&lt;/td&gt;
&lt;td&gt;调用 listAddNodeTail 函数， 将新元素推入到双端链表的表尾。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;LPOP&lt;/td&gt;
&lt;td&gt;调用 ziplistIndex 函数定位压缩列表的表头节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表头节点。&lt;/td&gt;
&lt;td&gt;调用 listFirst 函数定位双端链表的表头节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表头节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;RPOP&lt;/td&gt;
&lt;td&gt;调用 ziplistIndex 函数定位压缩列表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 ziplistDelete 函数删除表尾节点。&lt;/td&gt;
&lt;td&gt;调用 listLast 函数定位双端链表的表尾节点， 在向用户返回节点所保存的元素之后， 调用 listDelNode 函数删除表尾节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;LINDEX&lt;/td&gt;
&lt;td&gt;调用 ziplistIndex 函数定位压缩列表中的指定节点， 然后返回节点所保存的元素。&lt;/td&gt;
&lt;td&gt;调用 listIndex 函数定位双端链表中的指定节点， 然后返回节点所保存的元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;LLEN&lt;/td&gt;
&lt;td&gt;调用 ziplistLen 函数返回压缩列表的长度。&lt;/td&gt;
&lt;td&gt;调用 listLength 函数返回双端链表的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;LINSERT&lt;/td&gt;
&lt;td&gt;插入新节点到压缩列表的表头或者表尾时， 使用 ziplistPush 函数； 插入新节点到压缩列表的其他位置时， 使用 ziplistInsert 函数。&lt;/td&gt;
&lt;td&gt;调用 listInsertNode 函数， 将新节点插入到双端链表的指定位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;LREM&lt;/td&gt;
&lt;td&gt;遍历压缩列表节点， 并调用 ziplistDelete 函数删除包含了给定元素的节点。&lt;/td&gt;
&lt;td&gt;遍历双端链表节点， 并调用 listDelNode 函数删除包含了给定元素的节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;LTRIM&lt;/td&gt;
&lt;td&gt;调用 ziplistDeleteRange 函数， 删除压缩列表中所有不在指定索引范围内的节点。&lt;/td&gt;
&lt;td&gt;遍历双端链表节点， 并调用 listDelNode 函数删除链表中所有不在指定索引范围内的节点。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;LSET&lt;/td&gt;
&lt;td&gt;调用 ziplistDelete 函数， 先删除压缩列表指定索引上的现有节点， 然后调用 ziplistInsert 函数， 将一个包含给定元素的新节点插入到相同索引上面。&lt;/td&gt;
&lt;td&gt;调用 listIndex 函数， 定位到双端链表指定索引上的节点， 然后通过赋值操作更新节点的值。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;strong&gt;哈希对象&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;哈希对象的编码可以是 &lt;strong&gt;ziplist&lt;/strong&gt; 或者 &lt;strong&gt;hashtable&lt;/strong&gt; &lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;ziplist 编码的哈希对象使用&lt;span&gt;压缩列表&lt;/span&gt;作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：
&lt;ul&gt;&lt;li&gt;保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；&lt;/li&gt;
&lt;li&gt;先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;另一方面， hashtable 编码的哈希对象使用&lt;span&gt;字典&lt;/span&gt;作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存：
&lt;ul&gt;&lt;li&gt;字典的每个键都是一个字符串对象， 对象中保存了键值对的键；&lt;/li&gt;
&lt;li&gt;字典的每个值都是一个字符串对象， 对象中保存了键值对的值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子， 如果我们执行以下 HSET 命令， 那么服务器将创建一个列表对象作为 profile 键的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; HSET profile name &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; (integer) &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; redis&amp;gt; HSET profile age &lt;span&gt;25&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; (integer) &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; redis&amp;gt; HSET profile career &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Programmer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; (integer) &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/xuxh120/p/media/image31.png&quot; alt=&quot;graphviz-d2524c9fe90fb5d91b5875107b257e0053794a2a.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/xuxh120/p/media/image32.png&quot; alt=&quot;graphviz-7ba8b1f3af17e2e62cdf43608914333bf14d8e91.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/xuxh120/p/media/image33.png&quot; alt=&quot;graphviz-68cb863d265a1cd1ccfb038d44ce6b856ebbbe3a.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214000425922-1403247462.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214000438453-516245244.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214000447525-217673372.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;编码转换&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;哈希对象保存的所有键值对的&lt;span&gt;键和值的字符串长度都小于 64 字节&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;哈希对象保存的键值对&lt;span&gt;数量小于 512 个&lt;/span&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不能满足这两个条件的哈希对象需要使用 hashtable 编码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于使用 ziplist 编码的列表对象来说， 当使用 ziplist 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在压缩列表里的所有键值对都会被转移并保存到字典里面， 对象的编码也会从 ziplist 变为 hashtable 。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;哈希命令的实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为哈希键的值为哈希对象， 所以用于哈希键的所有命令都是针对哈希对象来构建的， 表 8-9 列出了其中一部分哈希键命令， 以及这些命令在不同编码的哈希对象下的实现方法。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;19&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;命令&lt;/td&gt;
&lt;td&gt;ziplist 编码实现方法&lt;/td&gt;
&lt;td&gt;hashtable 编码的实现方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;HSET&lt;/td&gt;
&lt;td&gt;首先调用 ziplistPush 函数， 将键推入到压缩列表的表尾， 然后再次调用 ziplistPush 函数， 将值推入到压缩列表的表尾。&lt;/td&gt;
&lt;td&gt;调用 dictAdd 函数， 将新节点添加到字典里面。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;HGET&lt;/td&gt;
&lt;td&gt;首先调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后调用 ziplistNext 函数， 将指针移动到键节点旁边的值节点， 最后返回值节点。&lt;/td&gt;
&lt;td&gt;调用 dictFind 函数， 在字典中查找给定键， 然后调用 dictGetVal 函数， 返回该键所对应的值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;HEXISTS&lt;/td&gt;
&lt;td&gt;调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。&lt;/td&gt;
&lt;td&gt;调用 dictFind 函数， 在字典中查找给定键， 如果找到的话说明键值对存在， 没找到的话就说明键值对不存在。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;HDEL&lt;/td&gt;
&lt;td&gt;调用 ziplistFind 函数， 在压缩列表中查找指定键所对应的节点， 然后将相应的键节点、 以及键节点旁边的值节点都删除掉。&lt;/td&gt;
&lt;td&gt;调用 dictDelete 函数， 将指定键所对应的键值对从字典中删除掉。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;HLEN&lt;/td&gt;
&lt;td&gt;调用 ziplistLen 函数， 取得压缩列表包含节点的总数量， 将这个数量除以 2 ， 得出的结果就是压缩列表保存的键值对的数量。&lt;/td&gt;
&lt;td&gt;调用 dictSize 函数， 返回字典包含的键值对数量， 这个数量就是哈希对象包含的键值对数量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;HGETALL&lt;/td&gt;
&lt;td&gt;遍历整个压缩列表， 用 ziplistGet 函数返回所有键和值（都是节点）。&lt;/td&gt;
&lt;td&gt;遍历整个字典， 用 dictGetKey 函数返回字典的键， 用 dictGetVal 函数返回字典的值。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;strong&gt;集合对象&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;集合对象的编码可以是 &lt;span&gt;&lt;strong&gt;intset&lt;/strong&gt;&lt;/span&gt; 或者 &lt;span&gt;&lt;strong&gt;hashtable&lt;/strong&gt;&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;intset 编码的集合对象使用&lt;span&gt;整数集合&lt;/span&gt;作为底层实现， 集合对象包含的所有元素都被保存在整数集合里面。&lt;/li&gt;
&lt;li&gt;另一方面， hashtable 编码的集合对象使用&lt;span&gt;字典&lt;/span&gt;作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子， 以下代码将创建一个如图 8-12 所示的 intset 编码集合对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; SADD numbers &lt;span&gt;1&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; (integer) &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214000654460-1415949616.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;以下代码将创建一个如图 8-13 所示的 hashtable 编码集合对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; SADD fruits &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;banana&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cherry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; (integer) &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214000726815-2082256162.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;h3&gt;&lt;strong&gt;编码的转换&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;集合对象保存的所有元素都是整数值；&lt;/li&gt;
&lt;li&gt;集合对象保存的元素数量不超过 512 个；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不能满足这两个条件的集合对象需要使用 hashtable 编码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于使用 intset 编码的集合对象来说， 当使用 intset 编码所需的两个条件的任意一个不能被满足时， 对象的编码转换操作就会被执行： 原本保存在整数集合中的所有元素都会被转移并保存到字典里面， 并且对象的编码也会从 intset 变为 hashtable 。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二个条件的上限值是可以修改的， 具体请看配置文件中关于 set-max-intset-entries 选项的说明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;集合命令的实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为集合键的值为集合对象， 所以用于集合键的所有命令都是针对集合对象来构建的， 表 8-10 列出了其中一部分集合键命令， 以及这些命令在不同编码的集合对象下的实现方法。&lt;/p&gt;
&lt;p&gt;表 8-10 集合命令的实现方法&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;20&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;命令&lt;/td&gt;
&lt;td&gt;intset 编码的实现方法&lt;/td&gt;
&lt;td&gt;hashtable 编码的实现方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SADD&lt;/td&gt;
&lt;td&gt;调用 intsetAdd 函数， 将所有新元素添加到整数集合里面。&lt;/td&gt;
&lt;td&gt;调用 dictAdd ， 以新元素为键， NULL 为值， 将键值对添加到字典里面。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;SCARD&lt;/td&gt;
&lt;td&gt;调用 intsetLen 函数， 返回整数集合所包含的元素数量， 这个数量就是集合对象所包含的元素数量。&lt;/td&gt;
&lt;td&gt;调用 dictSize 函数， 返回字典所包含的键值对数量， 这个数量就是集合对象所包含的元素数量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;SISMEMBER&lt;/td&gt;
&lt;td&gt;调用 intsetFind 函数， 在整数集合中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。&lt;/td&gt;
&lt;td&gt;调用 dictFind 函数， 在字典的键中查找给定的元素， 如果找到了说明元素存在于集合， 没找到则说明元素不存在于集合。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SMEMBERS&lt;/td&gt;
&lt;td&gt;遍历整个整数集合， 使用 intsetGet 函数返回集合元素。&lt;/td&gt;
&lt;td&gt;遍历整个字典， 使用 dictGetKey 函数返回字典的键作为集合元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SRANDMEMBER&lt;/td&gt;
&lt;td&gt;调用 intsetRandom 函数， 从整数集合中随机返回一个元素。&lt;/td&gt;
&lt;td&gt;调用 dictGetRandomKey 函数， 从字典中随机返回一个字典键。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;8&quot;&gt;&lt;td&gt;SPOP&lt;/td&gt;
&lt;td&gt;调用 intsetRandom 函数， 从整数集合中随机取出一个元素， 在将这个随机元素返回给客户端之后， 调用 intsetRemove 函数， 将随机元素从整数集合中删除掉。&lt;/td&gt;
&lt;td&gt;调用 dictGetRandomKey 函数， 从字典中随机取出一个字典键， 在将这个随机字典键的值返回给客户端之后， 调用 dictDelete 函数， 从字典中删除随机字典键所对应的键值对。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SREM&lt;/td&gt;
&lt;td&gt;调用 intsetRemove 函数， 从整数集合中删除所有给定的元素。&lt;/td&gt;
&lt;td&gt;调用 dictDelete 函数， 从字典中删除所有键为给定元素的键值对。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;strong&gt;有序集合对象&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;有序集合的编码可以是 &lt;span&gt;&lt;strong&gt;ziplist&lt;/strong&gt;&lt;/span&gt; 或者 &lt;span&gt;&lt;strong&gt;skiplist&lt;/strong&gt;&lt;/span&gt; 。&lt;/li&gt;
&lt;li&gt;ziplist 编码的有序集合对象使用&lt;span&gt;压缩列表&lt;/span&gt;作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。&lt;/li&gt;
&lt;li&gt;压缩列表内的集合元素&lt;span&gt;按分值从小到大进行排序&lt;/span&gt;， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。&lt;/li&gt;
&lt;li&gt;skiplist 编码的有序集合对象使用 zset 结构作为底层实现， 一个 zset 结构同时包含一个字典和一个跳跃表：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zset {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     
&lt;span&gt;3&lt;/span&gt;     zskiplist *&lt;span&gt;zsl;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     dict *&lt;span&gt;dict;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     
&lt;span&gt;6&lt;/span&gt; } zset;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。 通过这个跳跃表， 程序可以对有序集合进行范围型操作， 比如 ZRANK 、 ZRANGE 等命令就是基于跳跃表 API 来实现的。&lt;/li&gt;
&lt;li&gt;zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射， 字典中的每个键值对都保存了一个集合元素： 字典的键保存了元素的成员， 而字典的值则保存了元素的分值。 通过这个字典， 程序可以用 O(1) 复杂度查找给定成员的分值， ZSCORE 命令就是根据这一特性实现的， 而很多其他有序集合命令都在实现的内部用到了这一特性。&lt;/li&gt;
&lt;li&gt;值得一提的是， 虽然 zset 结构同时使用跳跃表和字典来保存有序集合元素， 但这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;有序集合每个元素的成员都是一个字符串对象， 而每个元素的分值都是一个 double 类型的浮点数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子， 如果我们执行以下 ZADD 命令， 那么服务器将创建一个有序集合对象作为 price 键的值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; ZADD price &lt;span&gt;8.5&lt;/span&gt; apple &lt;span&gt;5.0&lt;/span&gt; banana &lt;span&gt;6.0&lt;/span&gt;&lt;span&gt; cherry
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; (integer) &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;如果 price 键的值对象使用的是 ziplist 编码， 那么这个值对象将会是图 8-14 所示的样子， 而对象所使用的压缩列表则会是 8-15 所示的样子。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214000951021-2004790439.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214000959153-1971840268.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果前面 price 键创建的不是 ziplist 编码的有序集合对象， 而是 skiplist 编码的有序集合对象， 那么这个有序集合对象将会是图 8-16 所示的样子， 而对象所使用的 zset 结构将会是图 8-17 所示的样子。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/xuxh120/p/media/image38.png&quot; alt=&quot;graphviz-122e7ebdcd23e888fae17c21813be048c2d3f0a8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/xuxh120/p/media/image39.png&quot; alt=&quot;graphviz-75ee561bcc63f8ea960d0339768aec97b1f570f0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214001035176-1463690112.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214001044414-945460939.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt; &lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了展示方便， 图 8-17 在字典和跳跃表中重复展示了各个元素的成员和分值， 但在实际中， 字典和跳跃表会共享元素的成员和分值， 所以并不会造成任何数据重复， 也不会因此而浪费任何内存。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;为什么有序集合需要同时使用跳跃表和字典来实现？&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在理论上来说， 有序集合可以单独使用字典或者跳跃表的其中一种数据结构来实现， 但无论单独使用字典还是跳跃表， 在性能上对比起同时使用字典和跳跃表都会有所降低。&lt;/li&gt;
&lt;li&gt;举个例子， 如果我们只使用字典来实现有序集合， 那么虽然以 O(1) 复杂度查找成员的分值这一特性会被保留， 但是， 因为字典以无序的方式来保存集合元素， 所以每次在执行范围型操作 —— 比如 ZRANK 、 ZRANGE 等命令时， 程序都需要对字典保存的所有元素进行排序， 完成这种排序需要至少 O(N \log N) 时间复杂度， 以及额外的 O(N) 内存空间 （因为要创建一个数组来保存排序后的元素）。&lt;/li&gt;
&lt;li&gt;另一方面， 如果我们只使用跳跃表来实现有序集合， 那么跳跃表执行范围型操作的所有优点都会被保留， 但因为没有了字典， 所以根据成员查找分值这一操作的复杂度将从 O(1) 上升为 O(\log N) 。&lt;/li&gt;
&lt;li&gt;因为以上原因， &lt;span&gt;为了让有序集合的查找和范围型操作都尽可能快地执行&lt;/span&gt;， Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;编码的转换&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;有序集合保存的元素数量小于 128 个；&lt;/li&gt;
&lt;li&gt;有序集合保存的所有元素成员的长度都小于 64 字节；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不能满足以上两个条件的有序集合对象将使用 skiplist 编码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于使用 ziplist 编码的有序集合对象来说， 当使用 ziplist 编码所需的两个条件中的任意一个不能被满足时， 程序就会执行编码转换操作， 将原本储存在压缩列表里面的所有集合元素转移到 zset 结构里面， 并将对象的编码从 ziplist 改为 skiplist 。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 zset-max-ziplist-entries 选项和 zset-max-ziplist-value 选项的说明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;strong&gt;有序集合命令的实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;因为有序集合键的值为有序集合对象， 所以用于有序集合键的所有命令都是针对有序集合对象来构建的， 表 8-11 列出了其中一部分有序集合键命令， 以及这些命令在不同编码的有序集合对象下的实现方法。&lt;/p&gt;
&lt;table&gt;&lt;tbody readability=&quot;24.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;命令&lt;/td&gt;
&lt;td&gt;ziplist 编码的实现方法&lt;/td&gt;
&lt;td&gt;zset 编码的实现方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;ZADD&lt;/td&gt;
&lt;td&gt;调用 ziplistInsert 函数， 将成员和分值作为两个节点分别插入到压缩列表。&lt;/td&gt;
&lt;td&gt;先调用 zslInsert 函数， 将新元素添加到跳跃表， 然后调用 dictAdd 函数， 将新元素关联到字典。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;ZCARD&lt;/td&gt;
&lt;td&gt;调用 ziplistLen 函数， 获得压缩列表包含节点的数量， 将这个数量除以 2 得出集合元素的数量。&lt;/td&gt;
&lt;td&gt;访问跳跃表数据结构的 length 属性， 直接返回集合元素的数量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ZCOUNT&lt;/td&gt;
&lt;td&gt;遍历压缩列表， 统计分值在给定范围内的节点的数量。&lt;/td&gt;
&lt;td&gt;遍历跳跃表， 统计分值在给定范围内的节点的数量。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ZRANGE&lt;/td&gt;
&lt;td&gt;从表头向表尾遍历压缩列表， 返回给定索引范围内的所有元素。&lt;/td&gt;
&lt;td&gt;从表头向表尾遍历跳跃表， 返回给定索引范围内的所有元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;ZREVRANGE&lt;/td&gt;
&lt;td&gt;从表尾向表头遍历压缩列表， 返回给定索引范围内的所有元素。&lt;/td&gt;
&lt;td&gt;从表尾向表头遍历跳跃表， 返回给定索引范围内的所有元素。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;ZRANK&lt;/td&gt;
&lt;td&gt;从表头向表尾遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。&lt;/td&gt;
&lt;td&gt;从表头向表尾遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;ZREVRANK&lt;/td&gt;
&lt;td&gt;从表尾向表头遍历压缩列表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。&lt;/td&gt;
&lt;td&gt;从表尾向表头遍历跳跃表， 查找给定的成员， 沿途记录经过节点的数量， 当找到给定成员之后， 途经节点的数量就是该成员所对应元素的排名。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;ZREM&lt;/td&gt;
&lt;td&gt;遍历压缩列表， 删除所有包含给定成员的节点， 以及被删除成员节点旁边的分值节点。&lt;/td&gt;
&lt;td&gt;遍历跳跃表， 删除所有包含了给定成员的跳跃表节点。 并在字典中解除被删除元素的成员和分值的关联。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;ZSCORE&lt;/td&gt;
&lt;td&gt;遍历压缩列表， 查找包含了给定成员的节点， 然后取出成员节点旁边的分值节点保存的元素分值。&lt;/td&gt;
&lt;td&gt;直接从字典中取出给定成员的分值。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;&lt;strong&gt;类型检查与命令多态&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Redis 中用于操作键的命令基本上可以分为两种类型。&lt;/li&gt;
&lt;li&gt;其中一种命令可以对任何类型的键执行， 比如说 DEL 命令、 EXPIRE 命令、 RENAME 命令、 TYPE 命令、 OBJECT 命令， 等等。&lt;/li&gt;
&lt;li&gt;而另一种命令只能对特定类型的键执行， 比如说：
&lt;ul&gt;&lt;li&gt;SET 、 GET 、 APPEND 、 STRLEN 等命令只能对字符串键执行；&lt;/li&gt;
&lt;li&gt;HDEL 、 HSET 、 HGET 、 HLEN 等命令只能对哈希键执行；&lt;/li&gt;
&lt;li&gt;RPUSH 、 LPOP 、 LINSERT 、 LLEN 等命令只能对列表键执行；&lt;/li&gt;
&lt;li&gt;SADD 、 SPOP 、 SINTER 、 SCARD 等命令只能对集合键执行；&lt;/li&gt;
&lt;li&gt;ZADD 、 ZCARD 、 ZRANK 、 ZSCORE 等命令只能对有序集合键执行；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子1， 以下代码就展示了使用 DEL 命令来删除三种不同类型的键：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# 字符串键
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; redis&amp;gt; SET msg &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;# 列表键
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; redis&amp;gt; RPUSH numbers &lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; (integer) &lt;span&gt;3&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;# 集合键
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; redis&amp;gt;&lt;span&gt; SADD fruits apple banana cherry
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; (integer) &lt;span&gt;3&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; redis&amp;gt;&lt;span&gt; DEL msg
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; (integer) &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; redis&amp;gt;&lt;span&gt; DEL numbers
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; (integer) &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; redis&amp;gt;&lt;span&gt; DEL fruits
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; (integer) &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;例子2， 我们可以用 SET 命令创建一个字符串键， 然后用 GET 命令和 APPEND 命令操作这个键， 但如果我们试图对这个字符串键执行只有列表键才能执行的 LLEN 命令， 那么 Redis 将向我们返回一个类型错误：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; redis&amp;gt; SET msg &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; redis&amp;gt;&lt;span&gt; GET msg
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; redis&amp;gt; APPEND msg &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; again!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; (integer) &lt;span&gt;18&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; redis&amp;gt;&lt;span&gt; GET msg
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world again!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; redis&amp;gt;&lt;span&gt; LLEN msg
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; (error) WRONGTYPE Operation against a key holding the wrong kind of value
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;strong&gt;类型检查的实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;从上面发生类型错误的代码示例可以看出， 为了确保只有指定类型的键可以执行某些特定的命令， 在执行一个类型特定的命令之前， Redis 会先检查输入键的类型是否正确， 然后再决定是否执行给定的命令。&lt;/p&gt;
&lt;p&gt;类型特定命令所进行的类型检查是通过&lt;span&gt; redisObject 结构的 type 属性&lt;/span&gt;来实现的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在执行一个类型特定命令之前， 服务器会先检查输入数据库键的值对象是否为执行命令所需的类型， 如果是的话， 服务器就对键执行指定的命令；&lt;/li&gt;
&lt;li&gt;否则， 服务器将拒绝执行命令， 并向客户端返回一个类型错误。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个例子， 对于 LLEN 命令来说：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在执行 LLEN 命令之前， 服务器会先检查输入数据库键的值对象是否为列表类型， 也即是， 检查值对象 redisObject 结构 type 属性的值是否为 REDIS_LIST ， 如果是的话， 服务器就对键执行 LLEN 命令；&lt;/li&gt;
&lt;li&gt;否则的话， 服务器就拒绝执行命令并向客户端返回一个类型错误；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214001334697-1478997231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 其他类型特定命令的类型检查过程也和这里展示的 LLEN 命令的类型检查过程类似。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;多态命令的实现&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Redis 除了会根据值&lt;span&gt;对象的类型&lt;/span&gt;来判断键是否能够执行指定命令之外， 还会根据值&lt;span&gt;对象的编码方式&lt;/span&gt;， 选择正确的命令实现代码来执行命令。&lt;/li&gt;
&lt;li&gt;举个例子， 在前面介绍列表对象的编码时我们说过， 列表对象有 ziplist 和 linkedlist 两种编码可用， 其中前者使用压缩列表 API 来实现列表命令， 而后者则使用双端链表 API 来实现列表命令。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在， 考虑这样一个情况， 如果我们对一个键执行 LLEN 命令， 那么服务器除了要确保执行命令的是列表键之外， 还需要根据键的值对象所使用的编码来选择正确的 LLEN 命令实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果列表对象的编码为 ziplist ， 那么说明列表对象的实现为压缩列表， 程序将使用 ziplistLen 函数来返回列表的长度；&lt;/li&gt;
&lt;li&gt;如果列表对象的编码为 linkedlist ， 那么说明列表对象的实现为双端链表， 程序将使用 listLength 函数来返回双端链表的长度；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;借用面向对象方面的术语来说， 我们可以认为 LLEN 命令是多态（&lt;a href=&quot;http://en.wikipedia.org/wiki/Polymorphism_(computer_science)&quot;&gt;polymorphism&lt;/a&gt;）的： 只要执行 LLEN 命令的是列表键， 那么无论值对象使用的是 ziplist 编码还是 linkedlist 编码， 命令都可以正常执行。&lt;/p&gt;
&lt;p&gt;图 8-19 其他类型特定命令的执行过程也是类似的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214001432761-600335775.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 实际上， 我们可以将 DEL 、 EXPIRE 、 TYPE 等命令也称为多态命令， 因为无论输入的键是什么类型， 这些命令都可以正确地执行。他们和 LLEN 等命令的区别在于， &lt;span&gt;前者是基于类型的多态&lt;/span&gt; —— 一个命令可以同时用于处理多种不同类型的键， 而&lt;span&gt;后者是基于编码的多态&lt;/span&gt; —— 一个命令可以同时用于处理多种不同编码。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;内存回收&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;因为 C 语言并不具备自动的内存回收功能， 所以 Redis 在自己的对象系统中构建了一个&lt;strong&gt;引用计数&lt;/strong&gt;（&lt;a href=&quot;http://en.wikipedia.org/wiki/Reference_counting&quot;&gt;reference counting&lt;/a&gt;）技术实现的内存回收机制， 通过这一机制， 程序可以通过跟踪对象的引用计数信息， 在适当的时候自动释放对象并进行内存回收。&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;每个对象的引用计数信息由 redisObject 结构的 &lt;span&gt;refcount&lt;/span&gt; 属性记录：&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; redisObject {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引用计数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; refcount;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; } robj;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;对象的引用计数信息会随着对象的使用状态而不断变化：
&lt;ul&gt;&lt;li&gt;在创建一个新对象时， 引用计数的值会被初始化为 1 ；&lt;/li&gt;
&lt;li&gt;当对象被一个新程序使用时， 它的引用计数值会被增一；&lt;/li&gt;
&lt;li&gt;当对象不再被一个程序使用时， 它的引用计数值会被减一；&lt;/li&gt;
&lt;li&gt;当对象的引用计数值变为 0 时， 对象所占用的内存会被释放。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;表 8-12 列出了修改对象引用计数的 API ， 这些 API 分别用于增加、减少、重置对象的引用计数。&lt;/li&gt;
&lt;/ul&gt;&lt;table&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;函数&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;incrRefCount&lt;/td&gt;
&lt;td&gt;将对象的引用计数值增一。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;decrRefCount&lt;/td&gt;
&lt;td&gt;将对象的引用计数值减一， 当对象的引用计数值等于 0 时， 释放对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;resetRefCount&lt;/td&gt;
&lt;td&gt;将对象的引用计数值设置为 0 ， 但并不释放对象， 这个函数通常在需要重新设置对象的引用计数值时使用。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;对象的整个生命周期可以划分为创建对象、操作对象、释放对象三个阶段。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作为例子， 以下代码展示了一个字符串对象从创建到释放的整个过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建一个字符串对象 s ，对象的引用计数为 1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; robj *s =&lt;span&gt; createStringObject(...)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对象 s 执行各种操作 ...
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将对象 s 的引用计数减一，使得对象的引用计数变为 0
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 导致对象 s 被释放&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; decrRefCount(s)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他不同类型的对象也会经历类似的过程。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;对象共享&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;除了用于实现内存回收机制之外， 对象的引用计数属性还带有对象共享的作用。&lt;/li&gt;
&lt;li&gt;在 Redis 中， 让多个键共享同一个值对象需要执行以下两个步骤：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;将数据库键的值指针指向一个现有的值对象；&lt;/li&gt;
&lt;li&gt;将被共享的值对象的引用计数增一。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个例子， 图 8-21 就展示了包含整数值 100 的字符串对象同时被键 A 和键 B 共享之后的样子， 可以看到， 除了对象的引用计数从之前的 1 变成了 2 之外， 其他属性都没有变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214001653384-1824217402.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;共享对象机制对于节约内存非常有帮助， 数据库中保存的相同值对象越多， 对象共享机制就能节约越多的内存。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如说， 假设数据库中保存了整数值 100 的键不只有键 A 和键 B 两个， 而是有一百个， 那么服务器只需要用一个字符串对象的内存就可以保存原本需要使用一百个字符串对象的内存才能保存的数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;目前来说， Redis 会在初始化服务器时， 创建一万个字符串对象， 这些对象包含了从 0 到 9999 的所有整数值， 当服务器需要用到值为 0 到 9999 的字符串对象时， 服务器就会使用这些共享对象， 而不是新创建对象。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建共享字符串对象的数量可以通过修改 redis.h/REDIS_SHARED_INTEGERS 常量来修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举个例子， 如果我们创建一个值为 100 的键 A ， 并使用 OBJECT REFCOUNT 命令查看键 A 的值对象的引用计数， 我们会发现值对象的引用计数为 2 ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; redis&amp;gt; SET A &lt;span&gt;100&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT REFCOUNT A
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; (integer) &lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;引用这个值对象的两个程序分别是持有这个值对象的服务器程序， 以及共享这个值对象的键 A ， 如图 8-22 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1238581/202102/1238581-20210214001807452-174452563.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;另外， 这些共享对象不单单只有字符串键可以使用， 那些在数据结构中嵌套了字符串对象的对象（linkedlist 编码的列表对象、 hashtable 编码的哈希对象、 hashtable 编码的集合对象、以及 zset 编码的有序集合对象）都可以使用这些共享对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;strong&gt;为什么 Redis 不共享包含字符串的对象？&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当服务器考虑将一个共享对象设置为键的值对象时， 程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同， 只有在共享对象和目标对象完全相同的情况下， 程序才会将共享对象用作键的值对象， 而一个共享对象保存的值越复杂， 验证共享对象和目标对象是否相同所需的复杂度就会越高， 消耗的 CPU 时间也会越多：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果共享对象是保存整数值的字符串对象， 那么验证操作的复杂度为 O(1) ；&lt;/li&gt;
&lt;li&gt;如果共享对象是保存字符串值的字符串对象， 那么验证操作的复杂度为 O(N) ；&lt;/li&gt;
&lt;li&gt;如果共享对象是包含了多个值（或者对象的）对象， 比如列表对象或者哈希对象， 那么验证操作的复杂度将会是 O(N^2) 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此， &lt;span&gt;尽管共享更复杂的对象可以节约更多的内存， 但受到 CPU 时间的限制， Redis 只对包含整数值的字符串对象进行共享。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;对象的空转时长&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;除了前面介绍过的 type 、 encoding 、 ptr 和 refcount 四个属性之外， redisObject 结构包含的最后一个属性为 lru 属性， 该属性记录了对象最后一次被命令程序访问的时间：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; redisObject {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... &lt;/span&gt;
   unsigned lru:&lt;span&gt;22&lt;/span&gt;&lt;span&gt;; 
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ... &lt;/span&gt;
} robj;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;OBJECT IDLETIME 命令可以打印出给定键的空转时长， 这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的.&lt;/li&gt;
&lt;li&gt;除了可以被 OBJECT IDLETIME 命令打印出来之外， 键的空转时长还有另外一项作用： 如果服务器打开了 maxmemory 选项， 并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru ， 那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时， 空转时长较高的那部分键会优先被服务器释放， 从而回收内存。
&lt;ul&gt;&lt;li&gt;配置文件的 maxmemory 选项和 maxmemory-policy 选项的说明介绍了关于这方面的更多信息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; redis&amp;gt; SET msg &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;OK
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;# 等待一小段时间
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT IDLETIME msg
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; (integer) &lt;span&gt;20&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;# 等待一阵子
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT IDLETIME msg
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; (integer) &lt;span&gt;180&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;# 访问 msg 键的值
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; redis&amp;gt;&lt;span&gt; GET msg
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; # 键处于活跃状态，空转时长为 &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; redis&amp;gt;&lt;span&gt; OBJECT IDLETIME msg
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; (integer) &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Redis五种类型的键的介绍到这里就结束了，欢迎和大家讨论、交流。 &lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;内容参考自: 《Redis设计与实现》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; ========== 码字不易，转载请注明出处 ==========&lt;/p&gt;

</description>
<pubDate>Sun, 14 Feb 2021 00:35:00 +0000</pubDate>
<dc:creator>xuxh120</dc:creator>
<og:description>目录 简单动态字符串链表字典跳跃表整数集合压缩列表对象 对象的类型与编码字符串对象列表对象哈希对象 集合对象有序集合对象类型检查与命令多态内存回收对象共享对象的空转时长 简单动态字符串 导读 Redi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xuxh120/p/14400980.html</dc:identifier>
</item>
<item>
<title>痞子衡嵌入式：超级下载算法(RT-UFL)开发笔记（3） - 统一FlexSPI驱动访问 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/14401262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/14401262.html</guid>
<description>&lt;p&gt;本篇是开发笔记第三篇，咱们就重点聊聊如何为超级下载算法设计一套统一的FlexSPI驱动接口及其访问方式。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;187.56865261228&quot;&gt;
&lt;hr/&gt;&lt;p&gt;　　大家好，我是痞子衡，是正经搞技术的痞子。今天痞子衡给大家介绍的是&lt;strong&gt;超级下载算法开发笔记(3)之统一FlexSPI驱动访问&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　文接上篇 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13971756.html&quot; target=&quot;_blank&quot;&gt;《超级下载算法(RT-UFL)开发笔记（2） - 识别当前i.MXRT型号》&lt;/a&gt;，现在超级算法已经能够识别到当前i.MXRT型号了，下一步就是找到一套统一的底层Flash驱动函数来实现外接串行NOR Flash的基本擦写操作，这套统一的底层Flash驱动至少要在API层面做到与i.MXRT型号无关，并且调用方式统一，这样就相当方便后续的上层算法层面的逻辑设计了。&lt;/p&gt;
&lt;p&gt;　　本篇是开发笔记第三篇，咱们就重点聊聊如何为超级下载算法设计一套统一的FlexSPI驱动接口及其访问方式。&lt;/p&gt;
&lt;h3 id=&quot;一、找到统一的flexspi驱动&quot;&gt;一、找到统一的FlexSPI驱动&lt;/h3&gt;
&lt;p&gt;　　我们知道i.MXRT系列内部用于连接NOR Flash的外设名字叫FlexSPI，这个外设在不同i.MXRT型号上差异很小，这对于设计通用Flash驱动函数来说方便了很多，这也是痞子衡做i.MXRT超级算法的最初动机。&lt;/p&gt;
&lt;p&gt;　　说到FlexSPI这个外设，其实就是Kinetis系列的QuadSPI外设的升级，在恩智浦MCUX SDK包里提供了一套标准的FlexSPI驱动，这个驱动写得还挺完善的，但是痞子衡并没有选择SDK标准驱动作为超级下载算法的底层Flash驱动。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;\SDK_2.x.x\devices\MIMXRTxxxx\drivers\fsl_flexspi.c
\SDK_2.x.x\devices\MIMXRTxxxx\drivers\fsl_flexspi.h
\SDK_2.x.x\components\flash\nor\flexspi\fsl_flexspi_nor_flash.c
\SDK_2.x.x\components\flash\nor\flexspi\fsl_flexspi_nor_flash.h
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　我们知道i.MXRT系列都是包含BootROM的，BootROM都支持从外部串行NOR Flash启动，这意味着BootROM中也是集成了FlexSPI驱动的（驱动源码也开源在SDK里了），BootROM里这套驱动与MCUX SDK里的驱动大体上差不多，但是细节上有差异，痞子衡最终选择了BootROM里的FlexSPI驱动作为超级算法的底层Flash驱动，原因下一节会讲。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;\SDK_2.x.x\middleware\mcu-boot\src\drivers\flexspi\bl_flexspi.c
\SDK_2.x.x\middleware\mcu-boot\src\drivers\flexspi\bl_flexspi.h
\SDK_2.x.x\middleware\mcu-boot\src\drivers\flexspi_nor\flexspi_nor_flash.c
\SDK_2.x.x\middleware\mcu-boot\src\drivers\flexspi_nor\flexspi_nor_flash.h
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二、统一flexspi驱动访问方式&quot;&gt;二、统一FlexSPI驱动访问方式&lt;/h3&gt;
&lt;p&gt;　　现在我们虽然找到了一套看似统一的FlexSPI驱动，但事情远不是这么简单。BootROM版本的FlexSPI驱动从API接口本身而言是几乎一致的，痞子衡之前也为此写过文章 &lt;a href=&quot;https://www.cnblogs.com/henjay724/p/13202824.html&quot; target=&quot;_blank&quot;&gt;《利用i.MXRT系列ROM提供的FlexSPI driver API可轻松IAP》&lt;/a&gt;，但是在不同i.MXRT型号上调用方式不统一（在开放API的i.MXRT型号上API函数地址不一，在不开放API的i.MXRT型号上需要手动移植mcu-boot里的源代码），因此我们需要对所有i.MXRT型号下的BootROM FlexSPI驱动调用方式做一个统一。&lt;/p&gt;
&lt;h4 id=&quot;21-rom-api接口方式&quot;&gt;2.1 ROM API接口方式&lt;/h4&gt;
&lt;p&gt;　　首先讲开放ROM API的几款i.MXRT型号（RT500/RT600/RT1060/RT1064/RT1170），这里顺便先解释一下上一节的遗留问题，为何选择BootROM版本FlexSPI驱动而不是SDK标准驱动？当然是因为有这个ROM API的存在，毕竟超级下载算法最终可执行文件越小越好，能调用ROM API可以极大地减小超级下载算法的最终代码长度。&lt;/p&gt;
&lt;p&gt;　　关于ROM API的细节，痞子衡不予赘述，我们按照如下格式准备好全部的g_bootloaderTree_imxrt宏待用（代码仅示例了i.MXRT1060）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;#define RT106X_ROM_API_TREE_ADDR (0x0020001cu)

typedef struct _bootloader_tree_imxrt106x
{
    const uint32_t version;
    const char *copyright;
    void (*runBootloader)(void *arg);
    const uint32_t reserved0;
    const flexspi_nor_flash_driver_imxrt106x_t *flexspiNorDriver;
} bootloader_tree_imxrt106x_t;

#define g_bootloaderTree_imxrt106x (*(bootloader_tree_imxrt106x_t **)(RT106X_ROM_API_TREE_ADDR))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;22-源代码库接口方式&quot;&gt;2.2 源代码(库)接口方式&lt;/h4&gt;
&lt;p&gt;　　对于没有开放ROM API的几款i.MXRT型号（RT1010/1015/1020/1024/1050），咱们就必须一一移植mcu-boot里的FlexSPI相关代码了，需移植的代码包含两部分：FlexSPI外设本身驱动，FlexSPI BSP驱动。前者移植起来倒是比较简单（直接找一个最完善的版本即可），但是后者涉及到了clock和pinmux配置，因i.MXRT型号而异，这部分代码差异较大，移植起来比较麻烦。&lt;/p&gt;
&lt;p&gt;　　FlexSPI外设本身驱动就是最终提供如下几个通用的函数即可，这部分是共用的源代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;status_t flexspi_nor_drv_flash_init(uint32_t instance, flexspi_nor_config_t *config);
status_t flexspi_nor_drv_flash_page_program(uint32_t instance,
                                        flexspi_nor_config_t *config,
                                        uint32_t dstAddr,
                                        const uint32_t *src);
status_t flexspi_nor_drv_flash_erase_all(uint32_t instance, flexspi_nor_config_t *config);
status_t flexspi_nor_drv_flash_erase(uint32_t instance, flexspi_nor_config_t *config, uint32_t start, uint32_t length);
status_t flexspi_nor_drv_flash_read(
    uint32_t instance, flexspi_nor_config_t *config, uint32_t *dst, uint32_t start, uint32_t bytes);
status_t flexspi_nor_drv_get_config(uint32_t instance, flexspi_nor_config_t *config, serial_nor_config_option_t *option);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　在移植FlexSPI BSP驱动过程中遇到了一个最头疼的事情，就是clock和pinmux代码需使用SDK里的基础驱动，而SDK驱动依赖i.MXRT芯片头文件，但是最终超级下载算法只有一个工程，这个工程几乎无法同时包含多个i.MXRT头文件。如果不用i.MXRT头文件，clock和pinmux代码全部改为裸写寄存器地址，工作量又太大，也不利于后期维护，最终想到的解决方案就是为每个i.MXRT型号的FlexSPI BSP驱动制作一个库工程，在库工程里各自使用自己的头文件，然后生成一个库文件作为超级下载算法工程的源文件。&lt;/p&gt;
&lt;p&gt;　　下面是示例的i.MXRT1050库文件里需提供的BSP函数列表，这也是综合多个型号SDK包里mcu-boot代码后提炼出来的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;void flexspi_iomux_config_rt1050(uint32_t instance, flexspi_mem_config_t *config);
void flexspi_update_padsetting_rt1050(flexspi_mem_config_t *config, uint32_t driveStrength);
void flexspi_clock_config_rt1050(uint32_t instance, uint32_t freq, uint32_t sampleClkMode);
status_t flexspi_set_failsafe_setting_rt1050(flexspi_mem_config_t *config);
status_t flexspi_get_max_supported_freq_rt1050(uint32_t instance, uint32_t *freq, uint32_t clkMode);
uint32_t CLOCK_GetCPUFreq_RT1050(void);
status_t flexspi_get_clock_rt1050(uint32_t instance, flexspi_clock_type_t type, uint32_t *freq);
void flexspi_clock_gate_enable_rt1050(uint32_t instance);
void flexspi_clock_gate_disable_rt1050(uint32_t instance);
status_t flexspi_nor_write_persistent_rt1050(const uint32_t data);
status_t flexspi_nor_read_persistent_rt1050(uint32_t *data);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;23-两种不同方式的驱动统一&quot;&gt;2.3 两种不同方式的驱动统一&lt;/h4&gt;
&lt;p&gt;　　现在无论是ROM API接口方式，还是源代码(库)接口方式，所有的i.MXRT型号下基础FlexSPI驱动已经准备完毕了，到了最关键的统一阶段了，我们首先可以定义一个如下ufl_target_desc_t结构体及其全局变量g_uflTargetDesc，这个结构体由FlexSPI擦写API函数指针（flexspi_nor_flash_driver_t）以及BSP函数指针（flexspi_bsp_driver_t）组成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;typedef struct _target_desc
{
    uint32_t imxrtChipId;
    flexspi_nor_flash_driver_t flashDriver;
    flexspi_bsp_driver_t flexspiBsp;
} ufl_target_desc_t;

ufl_target_desc_t g_uflTargetDesc;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　然后我们定义一个ufl_fill_flash_api()函数，该函数的功能就是根据识别出来的i.MXRT型号来具体填充ufl_target_desc_t型全局结构体变量里的成员值。如果是源代码接口方式，则填入对应函数名；如果是ROM API接口方式，则根据g_bootloaderTree_imxrt宏找到对应函数地址，最终我们在g_uflTargetDesc全局变量里统一了FlexSPI驱动访问方式（下述代码仅示例了RT1050和RT1060）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;static void ufl_fill_flash_api(void)
{
    rt_chip_id_t chipId = (rt_chip_id_t)g_uflTargetDesc.imxrtChipId;
    ufl_target_desc_t *uflTargetDesc = (ufl_target_desc_t *)&amp;amp;g_uflTargetDesc;
    switch (chipId)
    {
        case kChipId_RT105x:
            uflTargetDesc-&amp;gt;flashDriver.init             = flexspi_nor_drv_flash_init;
            uflTargetDesc-&amp;gt;flashDriver.page_program     = flexspi_nor_drv_flash_page_program;
            uflTargetDesc-&amp;gt;flashDriver.erase_all        = flexspi_nor_drv_flash_erase_all;
            uflTargetDesc-&amp;gt;flashDriver.erase            = flexspi_nor_drv_flash_erase;
            uflTargetDesc-&amp;gt;flashDriver.read             = flexspi_nor_drv_flash_read;
            uflTargetDesc-&amp;gt;flashDriver.set_clock_source = NULL;
            uflTargetDesc-&amp;gt;flashDriver.get_config       = flexspi_nor_drv_get_config;

            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_iomux_config         = flexspi_iomux_config_rt1050;
            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_update_padsetting    = flexspi_update_padsetting_rt1050;
            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_clock_config         = flexspi_clock_config_rt1050;
            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_set_failsafe_setting = flexspi_set_failsafe_setting_rt1050;
            uflTargetDesc-&amp;gt;flexspiBsp.CLOCK_GetCPUFreq             = CLOCK_GetCPUFreq_RT1050;
            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_get_max_supported_freq = flexspi_get_max_supported_freq_rt1050;
            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_clock_gate_enable    = flexspi_clock_gate_enable_rt1050;
            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_clock_gate_disable   = flexspi_clock_gate_disable_rt1050;
            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_nor_write_persistent = flexspi_nor_write_persistent_rt1050;
            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_get_clock            = flexspi_get_clock_rt1050;
            uflTargetDesc-&amp;gt;flexspiBsp.flexspi_nor_read_persistent  = flexspi_nor_read_persistent_rt1050;
            break;

        case kChipId_RT106x:
            uflTargetDesc-&amp;gt;flashDriver.init             = g_bootloaderTree_imxrt106x-&amp;gt;flexspiNorDriver-&amp;gt;init;
            uflTargetDesc-&amp;gt;flashDriver.page_program     = g_bootloaderTree_imxrt106x-&amp;gt;flexspiNorDriver-&amp;gt;program;
            uflTargetDesc-&amp;gt;flashDriver.erase_all        = g_bootloaderTree_imxrt106x-&amp;gt;flexspiNorDriver-&amp;gt;erase_all;
            uflTargetDesc-&amp;gt;flashDriver.erase            = g_bootloaderTree_imxrt106x-&amp;gt;flexspiNorDriver-&amp;gt;erase;
            uflTargetDesc-&amp;gt;flashDriver.read             = g_bootloaderTree_imxrt106x-&amp;gt;flexspiNorDriver-&amp;gt;read;
            uflTargetDesc-&amp;gt;flashDriver.set_clock_source = NULL;
            uflTargetDesc-&amp;gt;flashDriver.get_config       = g_bootloaderTree_imxrt106x-&amp;gt;flexspiNorDriver-&amp;gt;get_config;
            break;

        case kChipId_Invalid:
        default:
            break;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　有了g_uflTargetDesc全局变量，此时再包一层API驱动给最终下载算法上层逻辑调用就非常简单了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;status_t flexspi_nor_flash_init(uint32_t instance, flexspi_nor_config_t *config)
{
    return g_uflTargetDesc.flashDriver.init(instance, config);
}

void flexspi_iomux_config(uint32_t instance, flexspi_mem_config_t *config)
{
    g_uflTargetDesc.flexspiBsp.flexspi_iomux_config(instance, config);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　至此，超级下载算法开发笔记(3)之统一FlexSPI驱动访问痞子衡便介绍完毕了，掌声在哪里~~~&lt;/p&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot; target=&quot;_blank&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/henjay724&quot; target=&quot;_blank&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;https://www.zhihu.com/people/henjay724&quot; target=&quot;_blank&quot;&gt;知乎主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot; target=&quot;_blank&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 13 Feb 2021 15:04:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>本篇是开发笔记第三篇，咱们就重点聊聊如何为超级下载算法设计一套统一的FlexSPI驱动接口及其访问方式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/14401262.html</dc:identifier>
</item>
<item>
<title>只要代码足够乱，老板就不可能开了我 - lts8989</title>
<link>http://www.cnblogs.com/lts8989/p/14382091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lts8989/p/14382091.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img.exciting.net.cn/f1d0-fypyuva7868755.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文标题党，酸奶爸爸是反对这种观点的，特此声明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一开始拥护啥（因为什么）让你把代码写的这么复杂？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;新产品需要快速上线&quot;&gt;新产品需要快速上线&lt;/h3&gt;
&lt;p&gt;产品经理：竞对出了新产品，我们也要马上跟进，新立的项目，我不管你们技术怎么实现，总之老板就是要尽快上线。&lt;/p&gt;
&lt;p&gt;程序猿：尽快是多快呢，这都快下班了。&lt;/p&gt;
&lt;p&gt;产品经理：今晚加班，明早上线。&lt;/p&gt;
&lt;p&gt;于是乎，命名规则里夹杂着拼音。前台后台一套代码。别说服务化了，MVC根本都没有，界面业务数据库逻辑都混合在一个函数里了。更别提什么服务化，未来业务扩展了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.exciting.net.cn/photo-1504384308090-c894fdcc538d&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;矛盾爆发&quot;&gt;矛盾爆发&lt;/h4&gt;
&lt;p&gt;项目上线后，如果业绩不理想。那么最终关停新项目，回收服务器，代码被丢在git仓库的角落无人问津。如果业绩炸裂了，那么程序猿们的悲惨命运就要开始了，大概率这个阶段业务需求会源源不断的提来，根本没有时间来重构代码，于是只能在现有的小平房上加盖摩天大楼。&lt;/p&gt;
&lt;h4 id=&quot;破解之法&quot;&gt;破解之法&lt;/h4&gt;
&lt;p&gt;功能需求，新立的项目不要做的大而全，只做最核心的功能。如若不然，竞争对手死没死不知道，自己先把自己搞死了。程序架构不要太先进，微服务等架构是用户日活百万千万阶段需要做的架构。立项初期只要能够应对日活过万的需求变更就可以了。好的规范要从项目的第一行代码就要实施，命名规范、核心业务的文档、单元测试等等。&lt;/p&gt;
&lt;h3 id=&quot;职场小萌新，看不到长远的未来&quot;&gt;职场小萌新，看不到长远的未来&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img.exciting.net.cn/20210206164436.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微信公众号比较火，我们公司也要以公众号的形态呈现，新事物年轻人接收比较快，于是这个需求就交给了组内的职场萌新来做。过一段时间小程序也火了，再过一段时间又要上马企业微信。大概率这些后续的腾讯系需求都会由这位职场萌新来做。&lt;/p&gt;
&lt;h4 id=&quot;矛盾爆发-1&quot;&gt;矛盾爆发&lt;/h4&gt;
&lt;p&gt;由于职场萌新经验不足，开发公众号需求只关注当下业务与公众号的接口，不会考虑未来的小程序和企业微信的扩展。所以代码里充斥了各种switch-case，数据库表里充斥了各种type。加班与延期是不可避免，工作日常也大概率被各种bug缠身而无暇新功能开发。如果这位职场萌新扛不住离职了，那就是悲剧的开始。&lt;/p&gt;
&lt;h4 id=&quot;破解之法-1&quot;&gt;破解之法&lt;/h4&gt;
&lt;p&gt;技术经理与组内老鸟有不可推卸的责任，如果能够及时codereview，至少能保证职场萌新所搭建的楼不会歪。公司要上一个市面上流行的技术或业务，未来肯定要大规模上新需求，这里就需要老鸟们的技术经验与业务远见。毕竟如果职场萌新的楼歪了，恰巧又离职跑路了，那么这座歪了的楼大概率会由组内老鸟接手，因为市场已经爆发，大老板已经感受到职场萌新开发周期delay的痛了。&lt;/p&gt;
&lt;h3 id=&quot;程序猿老油条，我的代码无人可以接手&quot;&gt;程序猿老油条，我的代码无人可以接手&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img.exciting.net.cn/u=3201802790,2808624354&amp;amp;fm=26&amp;amp;gp=0.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公司业务平稳，日常新增需求也很常规，但就是有这种老油条型程序员将代码写的无比复杂，不同业务之间耦合度很高。&lt;/p&gt;
&lt;h4 id=&quot;矛盾爆发-2&quot;&gt;矛盾爆发&lt;/h4&gt;
&lt;p&gt;别人计划开发一周的需要，因为涉及老油条的代码，看代码就要看3天。这种乱麻型的代码，不知道哪些需求线上在用，哪些需求线上已经下线，搞得测试同学都得跑一遍，都很痛苦。上线之后往往是按下葫芦浮起瓢，好不容易开发2周上线，后续2~3天各种线上bug报出来，各种补丁文件上线，搞得OP同学也很痛苦。&lt;/p&gt;
&lt;p&gt;但是在老板眼里却是另外一番景象，老油条每天加班，每天帮助同事解决bug，每天上线补丁解决线上问题，办公室一派欣欣向荣的景象。于是老板疯狂招人。&lt;/p&gt;
&lt;p&gt;直到某天，代码实在改不下去了，线上天天出bug，公司业务高度依赖线上操作，老油条跑路。公司，卒。&lt;/p&gt;
&lt;h4 id=&quot;破解之法-2&quot;&gt;破解之法&lt;/h4&gt;
&lt;p&gt;这种老油条是公司的毒瘤，它不同于新项目的赶工期，也不同于职场萌新的经验不足，而是主观要将代码写烂。这样做短期会保住自己的饭碗，长期看是逆势而为。老油条把青春与经历都花在了办公室厚黑上，而没有精进技术，违背客观规律的行为终将被时代淘汰。&lt;/p&gt;
&lt;p&gt;解决之法：开掉。&lt;/p&gt;
&lt;h3 id=&quot;写在最后&quot;&gt;写在最后&lt;/h3&gt;
&lt;p&gt;好的代码是为了提高未来的效率，这里的效率不只是编码的效率，还有沟通的效率。接收人不问原作者就能快速读懂业务逻辑，新需求开发能够尽量少的修改现有业务逻辑。开发规范，设计模式等这些前人大牛留下的精华不是在无病呻吟的。用同样的人力支撑更大的业务规模才是王道，该重构就重构，痛一阵是必要的。&lt;/p&gt;
&lt;p&gt;我一直深信：加班能解决的问题，一定有其他方式解决。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.exciting.net.cn/20210206164854.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.exciting.net.cn/20210206170548.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Feb 2021 14:49:00 +0000</pubDate>
<dc:creator>lts8989</dc:creator>
<og:description>本文标题党，酸奶爸爸是反对这种观点的，特此声明。 一开始拥护啥（因为什么）让你把代码写的这么复杂？ 新产品需要快速上线 产品经理：竞对出了新产品，我们也要马上跟进，新立的项目，我不管你们技术怎么实现，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lts8989/p/14382091.html</dc:identifier>
</item>
<item>
<title>JPG学习笔记2（附完整代码）  - 哇哩顾得</title>
<link>http://www.cnblogs.com/robsann/p/14399323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/robsann/p/14399323.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　我们已经从BMP图中拿到了需要压缩RGB的数据，我们需要对原数据从RGB域转变YCbCr域，之后对YCbCr数据进行下采样（down sampling）。对于不需要看文章的同学，这边直接给出源代码。&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/Cheemion/JPEG_COMPRESS&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/Cheemion/JPEG_COMPRESS&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1068716/202102/1068716-20210212211211450-1606050880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                图片引用&quot;Compressed Image File Formats JPEG, PNG, GIF, XBM, BMP - John Miano&quot;[1]&lt;/p&gt;
&lt;h2&gt;1.RGB域和YCbCr域&lt;/h2&gt;
&lt;p&gt;RGB代表红绿蓝，通过3种颜色的叠加来得到我们看到的颜色。0-到255分别代表颜色从浅到深。&lt;/p&gt;
&lt;p&gt;Y   =  0.299   * red + 0.587  *  green + 0.114  *  blue;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;p&gt;Cb = -0.1687 * red - 0.3313 * green + 0.5    *    blue + 128;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;Cr  =  0.5       * red - 0.4187 * green -  0.0813 * blue + 128;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Y是RGB的加权平均值，称之为亮度(luminance)&lt;/p&gt;
&lt;p&gt;Cb是B分量和亮度的差值, 称为Chrominance(Cb)&lt;/p&gt;
&lt;p&gt;Cr是R分量和亮度的差值,称为Chrominance(Cr)&lt;/p&gt;
&lt;p&gt;以下代码将RGB转为YCbCr。为什么将RGB转为YCbCr? 因为人眼对亮度(Y)的变化更敏感，所以我可以对Cr和Cb进行下采样(压缩,比如本来1个字节代表一个pixel的数据，压缩后用1个字节代表4个pixels的数据)，尽可能保留完整的Y分量。通过这样子我们可以进一步的压缩数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; JPG::convertToYCbCr() {
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;) {
            YCbCr temp &lt;/span&gt;= BMPData[i * width +&lt;span&gt; j];
            BMPData[i &lt;/span&gt;* width + j].Y  =  &lt;span&gt;0.299&lt;/span&gt;  * temp.red + &lt;span&gt;0.587&lt;/span&gt; * temp.green  + &lt;span&gt;0.114&lt;/span&gt;  *&lt;span&gt; temp.blue;
            BMPData[i &lt;/span&gt;* width + j].Cb = -&lt;span&gt;0.1687&lt;/span&gt; * temp.red - &lt;span&gt;0.3313&lt;/span&gt; * temp.green + &lt;span&gt;0.5&lt;/span&gt;    * temp.blue + &lt;span&gt;128&lt;/span&gt;&lt;span&gt;;
            BMPData[i &lt;/span&gt;* width + j].Cr =  &lt;span&gt;0.5&lt;/span&gt;    * temp.red - &lt;span&gt;0.4187&lt;/span&gt; * temp.green - &lt;span&gt;0.0813&lt;/span&gt; * temp.blue + &lt;span&gt;128&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.sampling(采样)&lt;/h2&gt;
&lt;p&gt; 采样通常是对连续信号进行采样，比如下图蓝色是连续信号x(t)，红色是对信号进行采样后得到的信号x[n]=x(T*n), T是采样间隔，1/T是采样频率。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1068716/202102/1068716-20210213131959500-330212257.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;270&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 而在JPEG中，我们是对已经离散的数据进行采样，并且JPEG中的采样数值是相对采样数值。相对于最高采样频率的采样数值。&lt;/p&gt;
&lt;p&gt;如下左图&lt;/p&gt;
&lt;p&gt;Y（luminance）分量的水平采样频率(H, Horizantal sampling frequency)和垂直采样频率(V, vertical sampling frequency)都是4，是最高的采样频率。最高的采样频率就相当于保留原图的Y分量，不进行下采样。&lt;/p&gt;
&lt;p&gt;Cb分量的水平和垂直的采样频率都是2，等于最高采样频率的一半。所以水平每2个点采样一次，垂直每2个点采样一次。&lt;/p&gt;
&lt;p&gt;Cr分量的水平和垂直采样频率都是1，等于最高采样频率的1/4。所以水平和垂直每4个点采样一个点。&lt;/p&gt;
&lt;p&gt;3个分量的量叠加就得到了我们的像素的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1068716/202102/1068716-20210213203728772-1826594470.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图片引用&quot;Compressed Image File Formats JPEG, PNG, GIF, XBM, BMP - John Miano&quot;[1]&lt;/p&gt;
&lt;h2&gt;2.YCbCr数据在JPEG中的存储&lt;/h2&gt;
&lt;p&gt;JPEG规定所有的数据都是以8*8的一个block(data unit)的形式进行离散余弦变化和存储的.可以把这8*8的block看成是最小存储单元。&lt;/p&gt;
&lt;p&gt;MCU是Y,Cb,Cr的完整的block组成的能够完整还原一个范围的色彩的最小单元。啥意思？&lt;/p&gt;
&lt;p&gt;假设我们的图片是10*10的大小&lt;img src=&quot;https://img2020.cnblogs.com/blog/1068716/202102/1068716-20210213210811064-2137959475.png&quot; alt=&quot;&quot; width=&quot;126&quot; height=&quot;124&quot; loading=&quot;lazy&quot;/&gt;.&lt;/p&gt;
&lt;p&gt;若Y,Cb,Cr的水平和垂直的采样频率都为1，则原图由4个mcu(4种颜色分别代表一个MCU)组成（每个mcu包含1个y的block，一个cb的block，一个cr的block, 每个mcu的大小为8*8),边缘空白的地方可用0替代，也可以重复边缘的值。&lt;/p&gt;
&lt;p&gt;左上角那块4*4的小block的值分别&lt;/p&gt;
&lt;p&gt;pixel[0,0] = y[0,0] + cb[0,0] + cr[0,0]&lt;/p&gt;
&lt;p&gt;pixel[0,1] = y[0,1] + cb[0,1] + cr[0,1]&lt;/p&gt;
&lt;p&gt;pixel[1,0] = y[1,0] + cb[1,0] + cr[1,0]&lt;/p&gt;
&lt;p&gt;pixel[1,1] = y[1,1] + cb[1,1] + cr[1,1]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1068716/202102/1068716-20210213214415618-429243302.png&quot; alt=&quot;&quot; width=&quot;1182&quot; height=&quot;256&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若Y的水平和垂直采样频率为2， cb和cr的采样频率为1， 则原图由1个mcu组成(大小为16*16)。mcu中包含4个y的block(2*2)，一个cb，一个cr。总共6个block，大小只占原来block的一半。&lt;/p&gt;
&lt;p&gt;左上角那块4*4的小block的值分别&lt;/p&gt;
&lt;p&gt;pixel[0,0] = y[0,0] + cb[0,0] + cr[0,0]&lt;/p&gt;
&lt;p&gt;pixel[0,1] = y[0,1] + cb[0,0] + cr[0,0]&lt;/p&gt;
&lt;p&gt;pixel[1,0] = y[1,0] + cb[0,0] + cr[0,0]&lt;/p&gt;
&lt;p&gt;pixel[1,1] = y[1,1] + cb[0,0] + cr[0,0]&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1068716/202102/1068716-20210213213358933-892538211.png&quot; alt=&quot;&quot; width=&quot;1170&quot; height=&quot;331&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结：mcu大小= 垂直最大采样值 * 水平最大采样值, 一个mcu包含y的水平采样值*y的垂直采样值个的y个block(y的水平采样为2，垂直为2，则一个muc有4个yblock)。其他分量同理&lt;/p&gt;
&lt;h2&gt;1.3定义JPG class代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//定义Block&lt;br/&gt;using&lt;/span&gt; Block = &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;64&lt;/span&gt;&lt;span&gt;];&lt;br/&gt;//定义YCbCr，同时这个结构用来展示存放rgb数据
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; YCbCr {
    union
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; Y;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; red;
    };
    union 
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; Cb;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; green;
    };
    union {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; Cr;
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; blue;
    };
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;&lt;p&gt;struct&lt;/p&gt;&lt;/span&gt;&lt;span&gt; MCU {
    Block&lt;/span&gt;*&lt;span&gt; y;
    Block&lt;/span&gt;*&lt;span&gt; cb;
    Block&lt;/span&gt;*&lt;span&gt; cr;&lt;/span&gt;&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;//定义JPG类，用于压缩图片
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; JPG
{
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:&lt;br/&gt;//rgb转到YCbCr
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; convertToYCbCr();&lt;br/&gt;　　 //下采样
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; subsampling();&lt;br/&gt;//变化
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; discreteCosineTransform();    &lt;br/&gt;//量化
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; quantization();&lt;br/&gt;//哈夫曼
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; huffmanCoding();&lt;br/&gt;//输出
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; output(std::&lt;span&gt;string&lt;/span&gt;&lt;span&gt; path);
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:&lt;br/&gt;MCU&lt;/span&gt;*&lt;span&gt; data;&lt;br/&gt;Block&lt;/span&gt;*&lt;span&gt; blocks;&lt;br/&gt;//BMPData存放的是bmp图片的RGB数据
    YCbCr&lt;/span&gt;*&lt;span&gt; BMPData;
    &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; blockNum;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原图的像素&lt;/span&gt;
    &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; width;
    &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; height;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mcu 有多少个 长度是多少&lt;/span&gt;
    &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; mcuWidth;
    &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; mcuHeight;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个完整的muc的水平和垂直像素个数&lt;/span&gt;
    &lt;span&gt;uint&lt;/span&gt;&lt;span&gt; mcuVerticalPixelNum;
    &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt;&lt;span&gt; mcuHorizontalPixelNum;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于subsampling
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; only support 1 or 2&lt;/span&gt;
    &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; YVerticalSamplingFrequency;
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; YHorizontalSamplingFrequency;
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; CbVerticalSamplingFrequency;
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; CbHorizontalSamplingFrequency;
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; CrVerticalSamplingFrequency;
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; CrHorizontalSamplingFrequency;
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; maxVerticalSamplingFrequency;
    &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; maxHorizontalSamplingFrequency;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:&lt;br/&gt;&lt;/span&gt;&lt;span&gt;
    JPG(&lt;/span&gt;&lt;span&gt;uint&lt;/span&gt; width, &lt;span&gt;uint&lt;/span&gt; height,&lt;span&gt;const&lt;/span&gt; RGB* &lt;span&gt;const&lt;/span&gt;&lt;span&gt; rgbs,
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; YVerticalSamplingFrequency, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; YHorizontalSamplingFrequency, 
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; CbVerticalSamplingFrequency, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; CbHorizontalSamplingFrequency,
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt; CrVerticalSamplingFrequency, &lt;span&gt;byte&lt;/span&gt;&lt;span&gt; CrHorizontalSamplingFrequency
       )
        :width(width), height(height),
         YVerticalSamplingFrequency(YVerticalSamplingFrequency), YHorizontalSamplingFrequency(YHorizontalSamplingFrequency),
         CbVerticalSamplingFrequency(CbVerticalSamplingFrequency), CbHorizontalSamplingFrequency(CbHorizontalSamplingFrequency),
         CrVerticalSamplingFrequency(CrVerticalSamplingFrequency), CrHorizontalSamplingFrequency(CrHorizontalSamplingFrequency)
        {   
            maxHorizontalSamplingFrequency &lt;/span&gt;=&lt;span&gt; std::max({YHorizontalSamplingFrequency, CbHorizontalSamplingFrequency, CrHorizontalSamplingFrequency});
            maxVerticalSamplingFrequency &lt;/span&gt;=&lt;span&gt; std::max({YVerticalSamplingFrequency, CbVerticalSamplingFrequency, CrVerticalSamplingFrequency});
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mcu的个数&lt;/span&gt;
            mcuWidth = (width + (maxHorizontalSamplingFrequency * &lt;span&gt;8&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;)) / (maxHorizontalSamplingFrequency * &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);       
            mcuHeight &lt;/span&gt;= (height + (maxVerticalSamplingFrequency * &lt;span&gt;8&lt;/span&gt; - &lt;span&gt;1&lt;/span&gt;)) / (maxVerticalSamplingFrequency * &lt;span&gt;8&lt;/span&gt;&lt;span&gt;);   
            
            mcuVerticalPixelNum &lt;/span&gt;= maxVerticalSamplingFrequency * &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
            mcuHorizontalPixelNum &lt;/span&gt;= maxHorizontalSamplingFrequency * &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;总共多少个MCU    &lt;/span&gt;
            data = &lt;span&gt;new&lt;/span&gt; MCU[mcuWidth *&lt;span&gt; mcuHeight];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;一个MCU有多少个Block&lt;/span&gt;
            blockNum = (YVerticalSamplingFrequency * YHorizontalSamplingFrequency + CbVerticalSamplingFrequency * CbHorizontalSamplingFrequency + CrHorizontalSamplingFrequency *&lt;span&gt; CrVerticalSamplingFrequency);
           
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分配block内存空间&lt;/span&gt;
            blocks = &lt;span&gt;new&lt;/span&gt; Block[mcuHeight * mcuHeight *&lt;span&gt; blockNum];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把内存映射到对于的结构中&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; mcuHeight; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; mcuWidth; j++&lt;span&gt;) {&lt;br/&gt;data[i &lt;/span&gt;* mcuWidth + j].y = &amp;amp;blocks[(i * mcuWidth + j) *&lt;span&gt; blockNum]; 
                    data[i &lt;/span&gt;* mcuWidth + j].cb = data[i * mcuWidth + j].y + YVerticalSamplingFrequency *&lt;span&gt; YHorizontalSamplingFrequency;
                    data[i &lt;/span&gt;* mcuWidth + j].cr = data[i * mcuWidth + j].cb + CbVerticalSamplingFrequency *&lt;span&gt; CbHorizontalSamplingFrequency;
                }
            }
            //BMP数据用于存放,bmp的原图的数据
            BMPData &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; YCbCr[width *&lt;span&gt; height];&lt;br/&gt;//把bmp数据暂时存放在BMPdata中
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height; i++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; width; j++&lt;span&gt;) {
                    BMPData[i &lt;/span&gt;* width + j].red = static_cast&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;(rgbs[i * width +&lt;span&gt; j].red);
                    BMPData[i &lt;/span&gt;* width + j].blue = static_cast&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;(rgbs[i * width +&lt;span&gt; j].blue);
                    BMPData[i &lt;/span&gt;* width + j].green = static_cast&amp;lt;&lt;span&gt;double&lt;/span&gt;&amp;gt;(rgbs[i * width +&lt;span&gt; j].green);
                }
            }  
        }
    &lt;/span&gt;~&lt;span&gt;JPG() {
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] data;
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] blocks;
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;[] BMPData;
    }

};&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;1.6下采样代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里直接把左上的点 当作subsampling的点了
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以取平均值&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; JPG::subsampling() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历mcu&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; mcuHeight; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; mcuWidth; j++&lt;span&gt;) {&lt;br/&gt;//拿到mcu
            MCU&lt;/span&gt;&amp;amp; currentMCU = data[i * mcuWidth +&lt;span&gt; j];&lt;br/&gt;//每个mcu起始的坐标点
            &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt; heightOffset = i * maxVerticalSamplingFrequency * &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt; widthOffset = j * maxHorizontalSamplingFrequency * &lt;span&gt;8&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;iterate over 每一个component Y, cb cr&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;uint&lt;/span&gt; componentID = &lt;span&gt;1&lt;/span&gt;; componentID &amp;lt;= &lt;span&gt;3&lt;/span&gt;; componentID++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历block, 从muc中拿block&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; ii = &lt;span&gt;0&lt;/span&gt;, yOffSet = heightOffset; ii &amp;lt; getVerticalSamplingFrequency(componentID); ii++, yOffSet = yOffSet + &lt;span&gt;8&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; jj = &lt;span&gt;0&lt;/span&gt;, xOffset = widthOffset; jj &amp;lt; getHorizontalSamplingFrequency(componentID); jj++, xOffset = xOffset + &lt;span&gt;8&lt;/span&gt;&lt;span&gt;) {&lt;br/&gt;//拿到具体的block对象
                        Block&lt;/span&gt;&amp;amp; currentBlock = currentMCU[componentID][ii * getHorizontalSamplingFrequency(componentID) +&lt;span&gt; jj];
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历Block every pixels 像素, 并且采样赋值&lt;/span&gt;
                        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;; y &amp;lt; &lt;span&gt;8&lt;/span&gt;; y++&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;uint&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;; x &amp;lt; &lt;span&gt;8&lt;/span&gt;; x++&lt;span&gt;) {&lt;br/&gt;//得到被采样的那个点的坐标
                                &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt; sampledY = yOffSet + y *  maxVerticalSamplingFrequency /&lt;span&gt; getVerticalSamplingFrequency(componentID);
                                &lt;/span&gt;&lt;span&gt;uint&lt;/span&gt; sampledX = xOffset + x * maxHorizontalSamplingFrequency /&lt;span&gt; getHorizontalSamplingFrequency(componentID);
                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cannot find in original pictures;&lt;/span&gt;
                                &lt;span&gt;if&lt;/span&gt;(sampledX &amp;gt;= width || sampledY &amp;gt;=&lt;span&gt; height) {
                                    currentBlock[y &lt;/span&gt;* &lt;span&gt;8&lt;/span&gt; + x] = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
                                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                                    currentBlock[y &lt;/span&gt;* &lt;span&gt;8&lt;/span&gt; + x] = BMPData[sampledY * width +&lt;span&gt; sampledX][componentID];
                                }
                            }
                        }
                    }
                }             
            }
        }
    }  
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整代码  &lt;span&gt;&lt;a href=&quot;https://github.com/Cheemion/JPEG_COMPRESS/tree/main/Day2&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/Cheemion/JPEG_COMPRESS/tree/main/Day2&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;完结&lt;/h2&gt;
&lt;p&gt;祝你开心每一天。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;p&gt;[1]&lt;a href=&quot;https://github.com/Cheemion/JPEG_COMPRESS/blob/main/resource/Compressed%20Image%20File%20Formats%20JPEG%2C%20PNG%2C%20GIF%2C%20XBM%2C%20BMP%20-%20John%20Miano.pdf&quot; target=&quot;_blank&quot;&gt;https://github.com/Cheemion/JPEG_COMPRESS/blob/main/resource/Compressed%20Image%20File%20Formats%20JPEG%2C%20PNG%2C%20GIF%2C%20XBM%2C%20BMP%20-%20John%20Miano.pdf&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 13 Feb 2021 14:29:00 +0000</pubDate>
<dc:creator>哇哩顾得</dc:creator>
<og:description>我们已经从BMP图中拿到了需要压缩RGB的数据，我们需要对原数据从RGB域转变YCbCr域，之后对YCbCr数据进行下采样（down sampling）。对于不需要看文章的同学，这边直接给出源代码。h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/robsann/p/14399323.html</dc:identifier>
</item>
<item>
<title>WSL2+Terminal+VScode配置调试 - _清风拂山岗</title>
<link>http://www.cnblogs.com/zmk-c/p/14401191.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zmk-c/p/14401191.html</guid>
<description>&lt;p&gt;最近几天一直想找个方法把VMware虚拟机和远程连接工具MobaXterm这一组配合替换掉，因为每次开启虚拟机操作Ubuntu都需要占用很大的内存，而且要等好久好久才能开启！！！后面还要使用MobaXterm或者Xshell在远程连接进行操作总觉得好麻烦，这两天发现了了WSL2这个好东西，设置完成利用微软Terminal直接操作ubuntu和cmd,powershell以及微软的Azure云。而其打开极其迅速，内存占用少，不用再那么操心了😄。因此特此记录一下~&lt;/p&gt;
&lt;p&gt;先放一张我设置好的图哈哈~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222054816-1217347105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;什么是wsl2&quot;&gt;什么是WSL2?&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;WSL 2(Windows Subsystem for Linux) 是适用于&lt;strong&gt;Windows下Linux 子系统&lt;/strong&gt;体系结构的一个新版本，它支持适用于 Linux 的 Windows 子系统在 Windows 上运行 ELF64 Linux 二进制文件。 它的主要目标是&lt;strong&gt;提高文件系统性能&lt;/strong&gt;，以及添加&lt;strong&gt;完全的系统调用兼容性&lt;/strong&gt;。相对于WSL1的一些缺点进行了改进，有了很大的提升。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;开始操作吧&quot;&gt;开始操作吧&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;步骤-1---启用适用于-linux-的-windows-子系统&quot;&gt;步骤 1 - 启用适用于 Linux 的 Windows 子系统&lt;/h4&gt;
&lt;p&gt;需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。&lt;/p&gt;
&lt;p&gt;以管理员身份打开 PowerShell 并运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面需要更新到 WSL 2，等待重新启动计算机，然后继续执行下一步。&lt;/p&gt;
&lt;h4 id=&quot;步骤-2---检查运行-wsl-2-的要求&quot;&gt;步骤 2 - 检查运行 WSL 2 的要求&lt;/h4&gt;
&lt;p&gt;若要更新到 WSL 2，需要运行 Windows 10。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于 x64 系统：&lt;strong&gt;版本 1903&lt;/strong&gt; 或更高版本，采用 &lt;strong&gt;内部版本 18362&lt;/strong&gt; 或更高版本。&lt;/li&gt;
&lt;li&gt;对于 ARM64 系统：&lt;strong&gt;版本 2004&lt;/strong&gt; 或更高版本，采用 &lt;strong&gt;内部版本 19041&lt;/strong&gt; 或更高版本。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;若要检查 Windows 版本及内部版本号，选择 Windows 徽标键 + R，然后键入“winver”，选择“确定”。 （或者在 Windows 命令提示符下输入 &lt;code&gt;ver&lt;/code&gt; 命令）。&lt;/p&gt;
&lt;h4 id=&quot;步骤-3---启用虚拟机功能&quot;&gt;步骤 3 - 启用虚拟机功能&lt;/h4&gt;
&lt;p&gt;安装 WSL 2 之前，必须启用“虚拟机平台”可选功能。 计算机需要虚拟化功能才能使用此功能。&lt;/p&gt;
&lt;p&gt;以管理员身份打开 PowerShell 并运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;重新启动&lt;/strong&gt; 计算机，以完成 WSL 安装并更新到 WSL 2。&lt;/p&gt;
&lt;h4 id=&quot;步骤-4---下载-linux-内核更新包&quot;&gt;步骤 4 - 下载 Linux 内核更新包&lt;/h4&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;下载最新包：&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;备注:&lt;/mark&gt;如果使用的是 ARM64 计算机，请下载 &lt;a href=&quot;https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_arm64.msi&quot; target=&quot;_blank&quot;&gt;ARM64 包&lt;/a&gt;。 如果不确定自己计算机的类型，请打开命令提示符或 PowerShell，并输入：&lt;code&gt;systeminfo | find &quot;System Type&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;运行上一步中下载的更新包。 （双击以运行 - 系统将提示你提供提升的权限，选择“是”以批准此安装。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;安装完成后，请继续执行下一步 - 在安装新的 Linux 分发时，将 WSL 2 设置为默认版本。&lt;/p&gt;
&lt;h4 id=&quot;步骤-5---将-wsl-2-设置为默认版本&quot;&gt;步骤 5 - 将 WSL 2 设置为默认版本&lt;/h4&gt;
&lt;p&gt;打开 PowerShell，然后在安装新的 Linux 发行版时运行以下命令，将 WSL 2 设置为默认版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;wsl --set-default-version 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;步骤-6---安装所选的-linux-分发&quot;&gt;步骤 6 - 安装所选的 Linux 分发&lt;/h4&gt;
&lt;ol readability=&quot;0.46636771300448&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;打开 &lt;a href=&quot;https://aka.ms/wslstore&quot; target=&quot;_blank&quot;&gt;Microsoft Store&lt;/a&gt;，并选择你偏好的 Linux 分发版(这里我选择的是Ubuntu18.04 LTS)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下载安装&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;为新的Linux分发版创建用户账户和密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222124501-904067515.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.可以在开始栏打开Ubuntu18.04啦，进行操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222152050-337521673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;祝贺你！现已成功安装并设置了与 Windows 操作系统完全集成的 Linux 分发！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想看更详细操作的见下面官方链接&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/wsl/install-win10&quot; target=&quot;_blank&quot;&gt;在 Windows 10 上安装适用于 Linux 的 Windows 子系统 (WSL) | Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;一体化它不香吗&quot;&gt;一体化它不香吗&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据上述操作，我们已经完成了WSL2的安装操作，可以在本地直接打开ubuntu进行操作，但是平时使用过程中可能我们还需要开多个ubuntu操作窗口，还可能用到cmd命令或者powershell命令(一般用powershell，因为powershell是cmd的增强版)。这时候咱们就要开多个窗口，那岂不是烦死啦，这时候Terminal（Windows终端）出来了！！！&lt;/p&gt;
&lt;p&gt;Windows 终端可启用多个选项卡（在多个 Linux 命令行、Windows 命令提示符、PowerShell 和 Azure CLI 等之间快速切换）、创建键绑定（用于打开或关闭选项卡、复制粘贴等的快捷方式键）、使用搜索功能，以及使用自定义主题（配色方案、字体样式和大小、背景图像/模糊/透明度）。&lt;/p&gt;
&lt;p&gt;安装Terminal很简单，打开 &lt;a href=&quot;https://aka.ms/wslstore&quot; target=&quot;_blank&quot;&gt;Microsoft Store&lt;/a&gt;搜索Terminal安装即可(推荐固定在开始栏，方便打开)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222224792-1658283406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面说几个常用的Terminal配置：&lt;/p&gt;
&lt;p&gt;注意：Terminal的配置都是在窗口向下的箭头&lt;code&gt;设置&lt;/code&gt;进行配置，格式是json&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222244104-878429865.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;/&gt;&lt;ol readability=&quot;8.2405523255814&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;每次打开Termial都可以发现默认的是powershell，若我们想要默认打开ubuntu界面，则可以在设置文件中进行更改，打开设置文件可以看到&lt;code&gt;list&lt;/code&gt;字段，里面对应的就是各个命令集。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222259059-654144684.png&quot; width=&quot;50%&quot; height=&quot;50%&quot;/&gt;&lt;p&gt;每一个都有唯一的&lt;code&gt;guid&lt;/code&gt;，我们可以复制ubuntu的guid到&lt;code&gt;defaultProfile&lt;/code&gt;字段中，下次打开就是默认ubuntu了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222314960-268714019.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.3023255813953&quot;&gt;
&lt;p&gt;Termianl的黑窗口大家相比已经看烦了，我们可以在&lt;code&gt;schemes&lt;/code&gt;字段内更换Terminal的界面颜色配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222435736-875842421.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给大家推荐一个网站，进行界面颜色主题的配置：&lt;a href=&quot;https://terminalsplash.com/&quot; target=&quot;_blank&quot;&gt;&amp;gt;_TerminalSplash - Windows Terminal Themes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;defaults&lt;/code&gt;字段中可以配置Termial的背景图及透明度。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222410548-2086145454.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;可以在 Windows 终端中创建新的垂直或水平窗格。 垂直拆分将在焦点窗格的右侧打开一个新窗格，而水平拆分将在焦点窗格下方打开一个新窗格。 若要创建默认配置文件的新垂直窗格，可以键入 alt+shift+&lt;code&gt;+&lt;/code&gt;。 若要创建默认配置文件的新水平窗格，可以键入 alt+shift+&lt;code&gt;-&lt;/code&gt;。注意这里新建的窗口都是一个命令集的窗口，如果想要创建不同的命令集还有上述效果，可以按住&lt;code&gt;alt&lt;/code&gt;+鼠标点击窗口上方向下的箭头选择需要的命令集。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2293300/202102/2293300-20210213222449726-1310984471.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后注意一点，WSL2将你本地的c盘，d盘等window内置驱动盘都挂载在/mnt目录下，可以在ubuntu中直接操作，需要谨慎操作！！！&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;想看更详细的操作可以看下面的官方文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/terminal/get-started&quot; target=&quot;_blank&quot;&gt;Windows 终端安装 | Microsoft Docs&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;目前就介绍到这啦~&lt;/p&gt;
</description>
<pubDate>Sat, 13 Feb 2021 14:28:00 +0000</pubDate>
<dc:creator>_清风拂山岗</dc:creator>
<og:description>最近几天一直想找个方法把VMware虚拟机和远程连接工具MobaXterm这一组配合替换掉，因为每次开启虚拟机操作Ubuntu都需要占用很大的内存，而且要等好久好久才能开启！！！后面还要使用MobaX</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zmk-c/p/14401191.html</dc:identifier>
</item>
<item>
<title>Redis 集合统计（HyperLogLog） - buttercup</title>
<link>http://www.cnblogs.com/buttercup/p/14099176.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/buttercup/p/14099176.html</guid>
<description>&lt;p&gt;统计功能是一类极为常见的需求，比如下面这个场景：&lt;/p&gt;
&lt;p&gt;为了决定某个功能是否在下个迭代版本中保留，产品会要求统计页面在上新前后的 UV 作为决策依据。&lt;br/&gt;简单来说就是统计一天内，某个页面的访问用户量，如果相同的用户再次访问，也只算记为一次访问。&lt;/p&gt;
下面我们将从这个场景出发，讨论如何选择的合适的 Redis 数据结构实现统计功能。

&lt;h2 id=&quot;聚合统计&quot;&gt;聚合统计&lt;/h2&gt;
&lt;p&gt;要完成这个统计任务，最直观的方式是使用一个&lt;code&gt;SET&lt;/code&gt;保存页面在某天的访问用户 ID，然后通过对集合求差&lt;code&gt;SDIFF&lt;/code&gt;和求交&lt;code&gt;SINTER&lt;/code&gt;完成统计：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;# 2020-01-01 当日的 UV
SADD page:uv:20200101 &quot;Alice&quot; &quot;Bob&quot; &quot;Tom&quot; &quot;Jerry&quot;

# 2020-01-02 当日的 UV
SADD page:uv:20200102 &quot;Alice&quot; &quot;Bob&quot; &quot;Jerry&quot; &quot;Nancy&quot;

# 2020-01-02 新增用户
SDIFFSTORE page:new:20200102 page:uv:20200102 page:uv:20200101

# 2020-01-02 新增用户数量
SCARD page:new:20200102

# 2020-01-02 留存用户
SINTERSTORE page:rem:20200102 page:uv:20200102 page:uv:20200101

# 2020-01-02 留存用户数量
SCARD page:rem:20200102
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;操作直观易理解，可以复用现有的数据集合&lt;/li&gt;
&lt;li&gt;保留了用户的访问细节，可以做更细粒度的统计&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存开销大，假设每个用户ID长度均小于 44 字节（使用 embstr 编码），记录 1 亿用户也至少需要 6G 的内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SUNION&lt;/code&gt;、&lt;code&gt;SINTER&lt;/code&gt;、&lt;code&gt;SDIFF&lt;/code&gt;计算复杂度高，大数据量情况下会导致 Redis 实例阻塞，可选的优化方式有：
&lt;ul&gt;&lt;li&gt;从集群中选择一个从库专门负责聚合计算&lt;/li&gt;
&lt;li&gt;把数据读取到客户端，在客户端来完成聚合统计&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;二值统计&quot;&gt;二值统计&lt;/h2&gt;
&lt;p&gt;当用户 ID 是连续的整数时，可以使用&lt;code&gt;BITMAP&lt;/code&gt;实现二值统计：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;
# 2020-01-01 当日的 UV
SETBIT page:uv:20200101 0 1 # &quot;Alice&quot;
SETBIT page:uv:20200101 1 1 # &quot;Bob&quot;
SETBIT page:uv:20200101 2 1 # &quot;Tom&quot;
SETBIT page:uv:20200101 3 1 # &quot;Jerry&quot;

# 2020-01-02 当日的 UV
SETBIT page:uv:20200102 0 1 # &quot;Alice&quot;
SETBIT page:uv:20200102 1 1 # &quot;Bob&quot;
SETBIT page:uv:20200102 3 1 # &quot;Jerry&quot;
SETBIT page:uv:20200102 4 1 # &quot;Nancy&quot;

# 2020-01-02 新增用户
BITOP NOT page:not:20200101 page:uv:20200101
BITOP AND page:new:20200102 page:uv:20200102 page:not:20200101 

# 2020-01-02 新增用户数量
BITCOUNT page:new:20200102

# 2020-01-02 留存用户
BITOP AND page:rem:20200102 page:uv:20200102 page:uv:20200101

# 2020-01-02 留存用户数量
BITCOUNT page:new:20200102
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内存开销低，记录 1 亿个用户只需要 12MB 内存&lt;/li&gt;
&lt;li&gt;统计速度快，计算机对比特位的异或运算十分高效&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对数据类型有要求，只能处理整数集合&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h2 id=&quot;基数统计&quot;&gt;基数统计&lt;/h2&gt;
&lt;p&gt;前面两种方式都能提供准确的统计结果，但是也存在以下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当统计集合变大时，所需的存储内存也会线性增长&lt;/li&gt;
&lt;li&gt;当集合变大时，判断其是否包含新加入元素的成本变大&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考虑下面这一场景：&lt;/p&gt;
&lt;p&gt;产品可能只关心 UV 增量，此时我们最终要的结果是访问用户集合的数量，并不关心访问集合里面包含哪些访问用户&lt;br/&gt;只统计一个集合中&lt;strong&gt;不重复的元素个数&lt;/strong&gt;，而并不关心集合元素内容的统计方式，我们将其称为&lt;strong&gt;基数计数&lt;/strong&gt;&lt;code&gt;cardinality counting&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;针对这一特定的统计场景，Redis 提供了&lt;code&gt;HyperLogLog&lt;/code&gt;类型支持基数统计：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;# 2020-01-01 当日的 UV
PFADD page:uv:20200101 &quot;Alice&quot; &quot;Bob&quot; &quot;Tom&quot; &quot;Jerry&quot;
PFCOUNT page:uv:20200101

# 2020-01-02 当日的 UV
PFADD page:uv:20200102 &quot;Alice&quot; &quot;Bob&quot; &quot;Tom&quot; &quot;Jerry&quot; &quot;Nancy&quot;
PFCOUNT page:uv:20200102

# 2020-01-01 与 2020-01-02 的 UV 总和
PFMERGE page:uv:union page:uv:20200101 page:uv:20200102
PFCOUNT page:uv:union
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;HyperLogLog&lt;/code&gt;计算基数所需的空间是固定的。只需要 12KB 内存就可以计算接近 &lt;span class=&quot;math inline&quot;&gt;\(2^{64}\)&lt;/span&gt; 个元素的基数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;HyperLogLog&lt;/code&gt;的统计是基于概率完成的，其统计结果是有一定误差。不适用于精确统计的场景。&lt;/p&gt;

&lt;h2 id=&quot;概率估计&quot;&gt;概率估计&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HyperLogLog&lt;/code&gt;是一种基于概率的统计方式，该如何理解？&lt;/p&gt;
&lt;p&gt;我们来做一个实验：&lt;strong&gt;不停地抛一个均匀的双面硬币，直到结果是正面为止&lt;/strong&gt;。&lt;br/&gt;用 0 和 1 分别表示正面与反面，则实验结果可以表示为如下二进制串：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;                +-+
第 1 次抛到正面   |1|
                +-+
                +--+
第 2 次抛到正面   |01|
                +--+
                +---+
第 3 次抛到正面   |001|
                +---+
                +---------+
第 k 次抛到正面   |000...001|  (总共 k-1 个 0)
                +---------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;paper&quot; readability=&quot;17&quot;&gt;由于每次抛硬币得到正面的概率均为$\frac{1}{2}$，因此实验在第 k 次结束的可能性为 $(\frac{1}{2})^k$（二进制串中首个 1 出现在第 k 位的概率）。&lt;p&gt;进行 n 实验后，将每次实验抛硬币的次数记为 &lt;span class=&quot;math inline&quot;&gt;\(k_1, k_3,\cdots,k_n\)&lt;/span&gt;，其中的最大值记为 &lt;span class=&quot;math inline&quot;&gt;\(k_{max}\)&lt;/span&gt;。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;理想情况下有 &lt;span class=&quot;math inline&quot;&gt;\(k_{max} = log_2(n)\)&lt;/span&gt;，反过来也可以通过 &lt;span class=&quot;math inline&quot;&gt;\(k_{max}\)&lt;/span&gt; 来估计总的实验次数 &lt;span class=&quot;math inline&quot;&gt;\(n = 2^{k_{max}}\)&lt;/span&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;h3 id=&quot;处理极端情况&quot;&gt;处理极端情况&lt;/h3&gt;
&lt;p&gt;实际进行实验时，极端情况总会出现，比如在第 1 次实验时就连续抛出了 10 次反面。&lt;br/&gt;如果按照前面的公式进行估计，会认为已经进行了 1000 次实验，这显然与事实不符。&lt;/p&gt;
&lt;p&gt;为了提高估计的准确性，可以同时使用 m 枚硬币进行 &lt;strong&gt;分组实验&lt;/strong&gt;。&lt;br/&gt;然后计算这 m 组实验的平均值 &lt;span class=&quot;math inline&quot;&gt;\(\hat{k}_{max} = \frac{\sum_{i=0}^{m}{k_{max}}}{m}\)&lt;/span&gt;，此时能更准确的估计实际的实验次数 &lt;span class=&quot;math inline&quot;&gt;\(\hat{n}=2^{\hat{k}_{max}}\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;基数统计-1&quot;&gt;基数统计&lt;/h2&gt;
&lt;p&gt;通过前面的分析，我们可以总结出以下经验：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可以通过二进制串中首个 1 出现的位置 &lt;span class=&quot;math inline&quot;&gt;\(k_{max}\)&lt;/span&gt; 来估计实际实验发生的次数 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;HyperLogLog&lt;/code&gt;借鉴上述思想来统计集合中不重复元素的个数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 hash 函数集合中的每个元素映射为定长二进制串&lt;/li&gt;
&lt;li&gt;利用 &lt;strong&gt;分组统计&lt;/strong&gt; 的方式提高准确性，将二进制串分到 &lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个不同的桶&lt;code&gt;bucket&lt;/code&gt;中分别统计
&lt;ul&gt;&lt;li&gt;二进制串的前 &lt;span class=&quot;math inline&quot;&gt;\(log_2{m}\)&lt;/span&gt; 位用于计算该元素所属的桶&lt;/li&gt;
&lt;li&gt;剩余二进制位中，首个 1 出现的比特位记为 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;，每个桶中的只保存最大值 &lt;span class=&quot;math inline&quot;&gt;\(k_{max}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当需要估计集合中包含的元素个数时，使用公式 &lt;span class=&quot;math inline&quot;&gt;\(\hat{n}=2^{\hat{k}_{max}}\)&lt;/span&gt; 计算即可&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;下面来看一个例子：
&lt;p&gt;某个&lt;code&gt;HyperLogLog&lt;/code&gt;实现，使用&lt;strong&gt;8bit 输出的 hash 函数&lt;/strong&gt;并以 &lt;strong&gt;4 个桶&lt;/strong&gt;进行分组统计&lt;br/&gt;使用该 HLL 统计 Alice，Bob，Tom，Jerry，Nancy 这 5 个用户访问页后的 UV&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;                 映射为二进制串     分组    计算k
                      |            |       |
                      V            V       V
                 +---------+
hash(&quot;Alice&quot;) =&amp;gt; |01|101000| =&amp;gt; bucket=1, k=1
                 +---------+                                           分组统计 k_max
                 +---------+                 
hash(&quot;Bob&quot;)   =&amp;gt; |11|010010| =&amp;gt; bucket=3, k=2           +----------+----------+----------+----------+
                 +---------+                            | bucket_0 | bucket_1 | bucket_2 | bucket_3 |
                 +---------+                     ==&amp;gt;    +----------+----------+----------+----------+
hash(&quot;Tom&quot;)   =&amp;gt; |10|001000| =&amp;gt; bucket=2, k=3           | k_max= 1 | k_max= 2 | k_max= 3 | k_max= 2 |
                 +---------+                            +----------+----------+----------+----------+
                 +---------+                                         
hash(&quot;Jerry&quot;) =&amp;gt; |00|111010| =&amp;gt; bucket=0, k=1                
                 +---------+                                            
                 +---------+                               
hash(&quot;Nancy&quot;) =&amp;gt; |01|010001| =&amp;gt; bucket=1, k=2
                 +---------+                 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分组计数完成后，用之前的公式估计集合基数为 &lt;span class=&quot;math inline&quot;&gt;\(2^{\hat{k}_{max}}= 2^{(\frac{1+2+3+2}{4})} = 4\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;误差分析&quot;&gt;误差分析&lt;/h2&gt;
&lt;p&gt;在 Redis 的实现中，对于一个输入的字符串，首先得到 64 位的 hash 值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前 14 位来定位桶的位置（共有16384个桶）&lt;/li&gt;
&lt;li&gt;后 50 位用作元素对应的二进制串（用于更新首次出现 1 的比特位的最大值 &lt;span class=&quot;math inline&quot;&gt;\(k_{max}\)&lt;/span&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于使用了 64 位输出的 hash 函数，因此可以计数的集合的基数没有实际限制。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HyperLogLog&lt;/code&gt;的标准误差计算公式为 &lt;span class=&quot;math inline&quot;&gt;\(\frac{1.04}{\sqrt{m}}\)&lt;/span&gt;（&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 为分组数量），据此计算 Redis 实现的标准误差为 &lt;span class=&quot;math inline&quot;&gt;\(0.81\%\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;下面这幅图展示了统计误差与基数大小的关系：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/buttercup/1776821/o_201208142802hll_1.png&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;红线和绿线分别代表两个不同分布的数据集&lt;/li&gt;
&lt;li&gt;x 轴表示集合实际基数&lt;/li&gt;
&lt;li&gt;y 轴表示相对误差（百分比）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分析该图可以得出以下结论：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;统计误差与数据本身的分布特征无关&lt;/li&gt;
&lt;li&gt;集合基数越小，误差越小（小基数时精度高）&lt;/li&gt;
&lt;li&gt;集合基数越大，误差越大（大基数时省资源）&lt;/li&gt;
&lt;/ul&gt;&lt;br/&gt;&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
</description>
<pubDate>Sat, 13 Feb 2021 14:27:00 +0000</pubDate>
<dc:creator>buttercup</dc:creator>
<og:description>统计功能是一类极为常见的需求，比如下面这个场景： 为了决定某个功能是否在下个迭代版本中保留，产品会要求统计页面在上新前后的 UV 作为决策依据。 简单来说就是统计一天内，某个页面的访问用户量，如果相同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/buttercup/p/14099176.html</dc:identifier>
</item>
<item>
<title>Java RMI 实现一个简单的GFS（谷歌文件系统）——演示与实现篇 - 晨星1032</title>
<link>http://www.cnblogs.com/maogen/p/gfs_2.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maogen/p/gfs_2.html</guid>
<description>&lt;p&gt;本系列主要是使用Java RMI 实现一个简单的GFS（谷歌文件系统，google file system）。首先进行整体介绍，然后对背景进行描述以及对系统进行设计，同时实现系统，提供演示视频和源代码，望多多支持！&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;213.20712491436&quot;&gt;

&lt;p&gt;本文主要是使用Java RMI 实现一个简单的GFS（谷歌文件系统，google file system），这里提供演示运行视频、系统实现以及源代码相关。&lt;/p&gt;
&lt;blockquote readability=&quot;3.6756756756757&quot;&gt;
&lt;p&gt;[为了更好的阅读以及查看其他篇章，请查看原文：&lt;a href=&quot;https://www.cnblogs.com/maogen/p/gfs_2.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/p/gfs_2.html&lt;/a&gt;]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;🧨 大年初二，走亲访友🏮 🧧&lt;/p&gt;
&lt;p&gt;🏮祝大家新年快乐！🏮&lt;br/&gt;ʰᵅᵖᵖʸ ⁿeᵚ ʸᵉᵅʳ&lt;/p&gt;
&lt;p&gt;家人闲坐 灯火可亲&lt;br/&gt;辞旧迎新 新年可期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;系统整体介绍、背景以及设计信息：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;介绍篇：&lt;/code&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/maogen/p/gfs_0.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/p/gfs_0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;背景与设计篇：&lt;/code&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/maogen/p/gfs_1.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/p/gfs_1.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.5396825396825&quot;&gt;
&lt;p&gt;作者：晨星1032-博客园：&lt;a href=&quot;https://www.cnblogs.com/maogen/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;[MyGFS演示--Java RMI 实现一个简单的GFS_腾讯视频]：&lt;a href=&quot;https://v.qq.com/x/page/h3226nudkk0.html&quot; target=&quot;_blank&quot;&gt;https://v.qq.com/x/page/h3226nudkk0.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/3_gfs_1.png&quot; alt=&quot;3_gfs_1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，整个MyGFS分布式文件系统由SPI、Common API，Master，ChunkServer和Client五个模块组成：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;SPI&lt;/code&gt;：定义Master与ChunkServer需要实现的接口，并实现存放Chunk及其信息的抽象类。MasterApi与ChunkServerApi均继承自Remote接口，标识着这是一个远程接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;Master&lt;/code&gt;：实现远程接口实现类MasterEngine，继承自UnicastRemoteObject类并实现MasterApi接口，负责与Client的通信与对ChunkServer的管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ChunkServer&lt;/code&gt;：实现远程接口实现类ChunkServerEngine，继承自UnicastRemoteObject类并实现ChunkServerApi接口，接收Master的调度并负责对Chunk的管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;：使用分布式文件系统的本地端，通过与Master直接通信来间接地对文件系统进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;Common&lt;/code&gt;：该模块负责实现工具类与配置文件，例如生成UUID，将文件读入内存等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其具体的三方通讯流程如下图所示：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/3_gfs_2.png&quot;/&gt;
&lt;h2 id=&quot;21-心跳机制&quot;&gt;2.1 心跳机制&lt;/h2&gt;
&lt;p&gt;​ 使用Java RMI方式，在Master端检测每个ChunkServer是否在线。具体操作如下：&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过RMI方式来检测Chunk服务器的心跳，直接以try-catch方式判断。若服务器宕机则加入failedChunkServerList中。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;检查正常ChunkServer上的所有Chunk的Hash值，若不一致则加入到Chunk失败列表中。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后进行错误处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public synchronized void heartbeatScan() {
        System.out.println(&quot;heartbeat checking...&quot;);
        // 错误Chunk列表
        Map&amp;lt;String, List&amp;lt;ChunkInfo&amp;gt;&amp;gt; failedChunkMap = new LinkedHashMap&amp;lt;&amp;gt;();
        // 错误Server列表
        List&amp;lt;String&amp;gt; failedChunkServerList = new ArrayList&amp;lt;&amp;gt;();

        ChunkServerApi chunkServerApi;
        Map&amp;lt;Long, String&amp;gt; hashMap;
        int index = 0;
        for(String chunkServer : chunkServerList) {
            // 使用RMI检测心跳
            try{
                chunkServerApi = (ChunkServerApi) Naming.lookup(&quot;rmi://&quot; + chunkServer + &quot;/chunkServer&quot;);
                // 获取Hash，用来检测Chunk错误
                hashMap = chunkServerApi.getHashMap();
            } catch (Exception e) {
                // 服务器宕机
                System.out.println(&quot;ChunkServer: &quot; + chunkServer + &quot; is down!&quot;);
                failedChunkServerList.add(chunkServer);
            }

             try {
                 List&amp;lt;ChunkInfo&amp;gt; failedList = new ArrayList&amp;lt;&amp;gt;();
                 for (ChunkInfo chunkInfo : serverInfoMap.get(chunkServer)) {
                     String hash = hashMap.get(chunkInfo.getChunk().getChunkId());

                     if (hash == null || !hash.equals(chunkInfo.getHash())) {
                         System.out.println(&quot;chunk:&quot; + chunkInfo.getChunk().getChunkFileName() + &quot; ERROR!&quot;);
                         chunkInfo.removeReplicaServerName(chunkServer);
                         int idx = nameNodeList.indexOf(chunkInfo.getNameNode());

                         nameNodeList.get(idx).setChunkInfo(chunkInfo, chunkInfo.getSeq());
                         serverInfoMap.get(chunkServer).set(index, chunkInfo);

                         failedList.add(chunkInfo);
                     }
                     index++;
                 }
                 failedChunkMap.put(chunkServer, failedList);
             }catch (Exception e) {
                 System.out.println(&quot;检测chunk失败...&quot;);
             }
        }//for

        // 错误处理
        handleFaults(failedChunkMap, failedChunkServerList);
        System.out.println(&quot;heartbeat check end...&quot;);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;22-故障恢复和容错机制&quot;&gt;2.2 故障恢复和容错机制&lt;/h2&gt;
&lt;p&gt;​ 若ChunkServer掉线，则需分配新的服务器负载均衡，并将取出该ChunkServer上对应的Chunk文件，对其进行复制。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;System.out.println(&quot;正在处理宕机的服务器：&quot; + serverName + &quot;...&quot;);
// 当宕机服务器没有Chunk时，直接去除
if(serverInfoMap.get(serverName).size() == 0) {
    // 去除此服务器
    chunkServerList.remove(serverName);
    System.out.println(&quot;处理宕机服务器成功&quot;);
}

for(ChunkInfo chunkInfo : serverInfoMap.get(serverName)) {
    System.out.println(&quot;备份failed chunkServer&quot; + serverName + &quot;中的Chunk &quot;
                       + chunkInfo.getChunk().getChunkFileName());
    try {
        chunkServerList.remove(serverName);
        chunkInfo.removeReplicaServerName(serverName);
        // 服务器节点分配
        allocateNode(chunkInfo, chunkInfo.getFirstReplicaServerName());
        // 处理NameNode
        int idx = nameNodeList.indexOf(chunkInfo.getNameNode());
        nameNodeList.get(idx).setChunkInfo(chunkInfo, chunkInfo.getSeq());

        if(chunkInfo.getFirstReplicaServerName() == null) {
            continue;
        }

        chunkServerApi = (ChunkServerApi) Naming.lookup(
            &quot;rmi://&quot; + chunkInfo.getFirstReplicaServerName() + &quot;/chunkServer&quot;);
        chunkServerApi.backupChunk(chunkInfo.getChunk(), chunkInfo.getLastReplicaServerName());
        System.out.println(&quot;处理宕机服务器成功&quot;);
    }catch (Exception e) {
        System.out.println(&quot;处理宕机服务器失败！&quot;);
        e.printStackTrace();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 若该ChunkServer上的Chunk文件的Hash数据与Master上不一致则使用该Chunk文件的副本对其进行替换。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// chunk failed! 本地文件恢复
for(Map.Entry&amp;lt;String, List&amp;lt;ChunkInfo&amp;gt;&amp;gt; failedChunk : failedChunkMap.entrySet()) {
    String serverName = failedChunk.getKey();
    List&amp;lt;ChunkInfo&amp;gt; chunkInfos = failedChunk.getValue();
    for(ChunkInfo chunkInfo : chunkInfos) {
        System.out.println(&quot;从服务器&quot; + serverName + &quot;上正在恢复错误的Chunk:&quot; + chunkInfo.getChunk().getChunkFileName());
        try {
            if(chunkInfo.getFirstReplicaServerName() == null || 
               chunkInfo.getFirstReplicaServerName().equals(serverName)){
                System.out.println(&quot;没有备份，恢复失败！&quot;);
                continue;
            }

            chunkInfo.setLastReplicaServerName(serverName);
            int idx = nameNodeList.indexOf(chunkInfo.getNameNode());
            nameNodeList.get(idx).setChunkInfo(chunkInfo, chunkInfo.getSeq());

            chunkServerApi = (ChunkServerApi) Naming.lookup(
                &quot;rmi://&quot; + chunkInfo.getFirstReplicaServerName() + &quot;/chunkServer&quot;);
            chunkServerApi.backupChunk(chunkInfo.getChunk(), serverName);
            System.out.println(chunkInfo.getChunk().getChunkFileName() + &quot;恢复成功！&quot;);
        }catch (Exception e) {
            System.out.println(&quot;恢复失败！&quot;);
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 运行截图如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/3_gfs_3.png&quot; alt=&quot;3_gfs_3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;31-内存命中机制&quot;&gt;3.1 内存命中机制&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ChunkServerMemory {
   private final LinkedList&amp;lt;ChunkMemory&amp;gt; memoryList;
   private final int maxContain;

   public ChunkServerMemory(int maxContain) {
       this.memoryList = new LinkedList&amp;lt;&amp;gt;();
       this.maxContain = maxContain;
   }

   public void push(Chunk chunk,byte[] data) {
       if(memoryList.size()&amp;gt;maxContain){
           memoryList.removeLast();
       }
       memoryList.push(new ChunkMemory(chunk,data));
   }

   public ChunkMemory search(Chunk chunk){
       ChunkMemory res=null;
       for (int i = 0; i &amp;lt; memoryList.size(); i++) {
           if(memoryList.get(i).isMatch(chunk)){
               res=memoryList.get(i);
               moveToHead(i);
               System.out.println(chunk.getChunkFileName()+&quot;内存命中&quot;);
           }
       }
       return res;
   }

   private void moveToHead(int i){
       ChunkMemory tmp=memoryList.get(i);
       memoryList.remove(i);
       memoryList.push(tmp);
   }

   public void remove(long chunkId){
       for (int i = 0; i &amp;lt; memoryList.size(); i++) {
           if(memoryList.get(i).isMatch(chunkId)){
               memoryList.remove(i);
               return;
           }
       }
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32-状态维护&quot;&gt;3.2 状态维护&lt;/h2&gt;
&lt;p&gt;​ 一分钟更新一次本地Chunk的Hash值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;try{
   Thread.sleep(60000);
   System.out.println(&quot;开始检查Chunk信息&quot;);
   for(Long chunkId : chunkIdList) {
       String md5Str = SecurityUtil.getMd5(filePath + getChunkName(chunkId));
       if(md5Str == null) {
           md5Str = &quot;check error: no file!&quot;;
       }
       chunkHash.put(chunkId, md5Str);
   }
   System.out.println(&quot;检查Chunk信息结束&quot;);
} catch (Exception e) {
   e.printStackTrace();
   break;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;33副本管理&quot;&gt;3.3副本管理&lt;/h2&gt;
&lt;p&gt;​ GFS默认Chunk主副本三个，但为了实际演示方便，这里设置为主副本各一个，下图为windows服务器和Linux服务器上的存储。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/3_gfs_4.png&quot; alt=&quot;3_gfs_4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;41-上传&quot;&gt;4.1 上传&lt;/h2&gt;
&lt;p&gt;​ 在Client端上传文件时，会先将文件相关信息添加到Master中，同时Master会分配服务器到各个Chunk文件，然后Client通过分配的信息向指定的ChunkServer进行传送数据流。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void upLoadFile(String fileAddr) {
   System.out.println(&quot;文件正在上传...&quot;);
   try{
       int length, seq = 0;
       byte[] buffer = new byte[CHUNK_SIZE];

       File file = new File(fileAddr);
       // 向Master添加该Name结点
       masterApi.addNameNode(file.getName());

       InputStream input = new FileInputStream(file);
       input.skip(0);
       while ((length = input.read(buffer, 0, CHUNK_SIZE)) &amp;gt; 0) {
           byte[] upLoadBytes = new byte[length];
           System.arraycopy(buffer, 0, upLoadBytes, 0, length);
           String hash = SecurityUtil.getMd5(upLoadBytes);
           uploadChunk(file.getName(), seq, length, upLoadBytes, hash);
           seq++;
       }
       input.close();
       System.out.println(&quot;文件已上传！&quot;);
   } catch (Exception e) {
       System.out.println(&quot;文件上传失败&quot;);
       System.out.println(e.getLocalizedMessage());
   }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 演示效果如图所示，分别为Client端和ChunkServer端的情况。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/maogen_ymg/img-host/raw/master/3_gfs_5.png&quot;/&gt;&lt;h2 id=&quot;42-下载&quot;&gt;4.2 下载&lt;/h2&gt;
&lt;p&gt;​ 用户在Client端下载文件时，会先向Master请求所下载文件的信息，然后通过Master返回的Chunk所在ChunkServer信息进行数据请求获取。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String downloadFile(String fileName) throws Exception {
   System.out.println(&quot;文件正在下载...&quot;);
   String fileAddr = prefixPath + &quot;new_&quot; + fileName;
   File localFile = new File(fileAddr);
   OutputStream output = new FileOutputStream(localFile);

   List&amp;lt;ChunkInfo&amp;gt; chunkInfoList = masterApi.getChunkInfos(fileName);
   for(ChunkInfo chunkInfo : chunkInfoList) {
       output.write(downloadChunk(chunkInfo.getChunk(), chunkInfo.getFirstReplicaServerName()));
   }
   output.close();

   return fileAddr;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;43-追加&quot;&gt;4.3 追加&lt;/h2&gt;
&lt;p&gt;​ 每一个Chunk默认最大为64Mb，追加操作需要对最后一个Chunk的剩余空间进行判断：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若最后一个Chunk剩余空间 &amp;gt; 所追加文件大小，则直接添加最后一个即可。&lt;/li&gt;
&lt;li&gt;若最后一个Chunk剩余空间 &amp;lt; 所追加文件大小，则首先将最后一个Chunk空间加满，然后再新建Chunk直到 &amp;gt; 所追加文件大小&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void appendFile(String fileName, String appendFileAddr) throws Exception {
    List&amp;lt;ChunkInfo&amp;gt; chunkInfoList = masterApi.getChunkInfos(fileName);
    if(chunkInfoList.isEmpty()) {
        System.out.println(&quot;Master找不到该文件！&quot;);
        return;
    }
    System.out.println(&quot;文件正在进行修改...&quot;);

    byte[] bytes = ConvertUtil.file2Byte(appendFileAddr);

    // 获取最后一个Chunk信息
    int num = chunkInfoList.size();
    ChunkInfo chunkInfo = chunkInfoList.get(num-1);
    int chunkLen = (int)chunkInfo.getChunk().getByteSize();
    int appendLen = bytes.length;

    int len = CHUNK_SIZE - chunkLen;
    // 可以继续追加
    if(len &amp;gt;= appendLen) {
        byte[] newBytes = new byte[appendLen];
        System.arraycopy(bytes, 0, newBytes, 0, appendLen);
        chunkServerApi = (ChunkServerApi) Naming.lookup(&quot;rmi://&quot; + chunkInfo.getFirstReplicaServerName() + &quot;/chunkServer&quot;);
        chunkServerApi.appendChunk(chunkInfo.getChunk(), newBytes, chunkInfo.getLastReplicaServerName());
        masterApi.updateNameNode(fileName, chunkLen + appendLen);
    }else {
        // 需要新建Chunk
        // 最后一个Chunk剩余大小-&amp;gt;加满
        byte[] leftBytes = new byte[len];
        System.arraycopy(bytes, 0, leftBytes, 0, len);
        // 更新chunkServer
        chunkServerApi = (ChunkServerApi) Naming.lookup(&quot;rmi://&quot; + chunkInfo.getFirstReplicaServerName() + &quot;/chunkServer&quot;);
        chunkServerApi.appendChunk(chunkInfo.getChunk(), leftBytes, chunkInfo.getLastReplicaServerName());
        // Master更新
        masterApi.updateNameNode(fileName, CHUNK_SIZE);

        // 其余处理
        String hash;
        while (len + CHUNK_SIZE &amp;lt;= appendLen) {
            leftBytes = new byte[CHUNK_SIZE];
            System.arraycopy(bytes, len, leftBytes, 0, CHUNK_SIZE);
            hash = SecurityUtil.getMd5(leftBytes);
            uploadChunk(fileName, num, CHUNK_SIZE, leftBytes, hash);
            len += CHUNK_SIZE;
            num++;
        }
        if (len &amp;lt; appendLen) {
            int lastSize = appendLen - len;
            leftBytes = new byte[lastSize];
            System.arraycopy(bytes, len, leftBytes, 0, lastSize);
            hash = SecurityUtil.getMd5(leftBytes);
            uploadChunk(fileName, num, lastSize, leftBytes, hash);
        }
    }
    System.out.println(&quot;文件已修改！&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;44-删除&quot;&gt;4.4 删除&lt;/h2&gt;
&lt;p&gt;​ 删除文件仅将Master上的信息进行删除，ChunkServer本地上的文件未删除（软删除）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void deleteFile(String fileName) throws Exception {
    masterApi.deleteNameNode(fileName);
    System.out.println(&quot;文件删除成功!&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;45-文件列表&quot;&gt;4.5 文件列表&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void getFileList() throws Exception {
    List&amp;lt;String&amp;gt; fileList = masterApi.getFileList();
    if(fileList.size() == 0) {
        System.out.println(&quot;空&quot;);
    }
    for(String fileName : fileList) {
        System.out.println(fileName);
    }
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;​ 具体详情请查看源代码&lt;/p&gt;
&lt;p&gt;​ daisy-RMI实现GFS：&lt;a href=&quot;https://gitee.com/maogen_ymg/daisy&quot; target=&quot;_blank&quot;&gt;https://gitee.com/maogen_ymg/daisy&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;系统整体介绍、背景以及设计信息，尽在其他篇章：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;介绍篇：&lt;/code&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/maogen/p/gfs_0.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/p/gfs_0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;背景与设计篇：&lt;/code&gt;&lt;/strong&gt;&lt;a href=&quot;https://www.cnblogs.com/maogen/p/gfs_1.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/p/gfs_1.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.5396825396825&quot;&gt;
&lt;p&gt;作者：晨星1032-博客园：&lt;a href=&quot;https://www.cnblogs.com/maogen/&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/maogen/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 13 Feb 2021 13:18:00 +0000</pubDate>
<dc:creator>晨星1032</dc:creator>
<og:description>本系列主要是使用Java RMI 实现一个简单的GFS（谷歌文件系统，google file system）。首先进行整体介绍，然后对背景进行描述以及对系统进行设计，同时实现系统，提供演示视频和源代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/maogen/p/gfs_2.html</dc:identifier>
</item>
<item>
<title>银河麒麟V10安装ASP.NET Core并配置Supervisor让网站开机自动运行 - 踏平扶桑</title>
<link>http://www.cnblogs.com/wdw984/p/14401021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wdw984/p/14401021.html</guid>
<description>&lt;p&gt;银河麒麟高级服务器操作系统V10是针对企业级关键业务，适应虚拟化、云计算、大数据、工业互联网时代对主机系统可靠性、安全性、性能、扩展性和实时性的需求，依据CMMI 5级标准研制的提供内生安全、云原生支持、国产平台深入优化、高性能、易管理的新一代自主服务器操作系统；同源支持飞腾、龙芯、申威、兆芯、海光、鲲鹏等自主CPU及x86平台；可支撑构建大型数据中心服务器高可用集群、负载均衡集群、分布式集群文件系统、虚拟化应用和容器云平台等，可部署在物理服务器和虚拟化环境、私有云、公有云和混合云环境；应用于政府、国防、金融、教育、财税、公安、审计、交通、医疗、制造等领域。--来自官网介绍（http://www.kylinos.cn/scheme/server/1.html）&lt;/p&gt;
&lt;p&gt;在产品试用页面填写完申请后，可以下载试用版银河麒麟服务器版操作系统（试用期一年，试用地址http://www.kylinos.cn/support/trial.html）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文章采用的是x86架构的银河麒麟操作系统。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装完成后，银河麒麟自带GUI图形桌面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/97122/202102/97122-20210213191346632-680339987.png&quot; alt=&quot;&quot; width=&quot;756&quot; height=&quot;475&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安装时设置好密码后，会自动启动SSH管理，使用SSH管理工具即可远程连接管理。&lt;/p&gt;
&lt;p&gt;按管理，我们先安装libgdiplus，因为网站登录需要显示验证码，显示验证码调用System.Draw时需要libgdiplus支持。&lt;/p&gt;
&lt;p&gt;我们可以直接用CentOS的包管理工具yum来进行安装，&lt;strong&gt;需要注意的是银河麒麟不支持第三方的软件源（国内阿里、163等镜像源都不可用）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
yum install autoconf automake libtool
yum install libjpeg-turbo-devel libpng-devel giflib-devel libtiff-devel libexif-devel
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装完成后需要在/etc/ld.so.conf.d下建立一个文件（如local.conf）,内容填写上/usr/local/lib，然后用root权限执行ldconfig。这样调用相应的so文件就会在/usr/local/lib中搜索了。&lt;/p&gt;
&lt;p&gt;在根目录下建立一个文件夹upload，把&lt;/p&gt;
&lt;p&gt;aspnetcore-runtime-3.1.11-linux-x64.tar.gz（https://dotnet.microsoft.com/download/dotnet-core/3.1）&lt;/p&gt;
&lt;p&gt;setuptools-53.0.0.tar.gz（&lt;span&gt;https://pypi.org/project/setuptools/&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;supervisor-4.2.1.tar.gz（https://pypi.org/project/supervisor/#files）&lt;/p&gt;
&lt;p&gt;libgdiplus-6.0.5.tar.gz（http://download.mono-project.com/sources/libgdiplus/libgdiplus0-6.0.4.tar.gz）&lt;/p&gt;
&lt;p&gt;上传到此目录&lt;/p&gt;
&lt;p&gt;解压缩setuptools-53.0.0.tar.gz和supervisor-4.2.1.tar.gz&lt;/p&gt;
&lt;p&gt;先安装setuptools-53.0.0（&lt;strong&gt;需要Python3.6支持，银河麒麟默认是3.7可以直接安装&lt;/strong&gt;） &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cd setuptools-53.0.0
python3 setup.py install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后安装supervisor-4.2.1&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cd ../supervisor-4.2.1/
python3 setup.py install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 安装完成后，进入到后/etc/lib64/python3.7目录，执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
echo_supervisord_conf  &amp;gt; /etc/supervisord.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就会在/etc/目录下生成&lt;span&gt;supervisord.conf配置文件。然后建立一个目录/var/&lt;/span&gt;&lt;span&gt;&lt;span&gt;supervisord，用来保存&lt;/span&gt;&lt;/span&gt;&lt;span&gt;supervisord运行时生成的三个文件保存路径，建立一个&lt;/span&gt;&lt;span&gt;&lt;span&gt;/var/supervisord.d目录，用来保存要守护的程序的配置文件&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;然后分别执行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
touch /var/supervisord/supervisor.sock
touch /var/supervisord/supervisor.log
touch /var/supervisord/supervisor.pid
chmod 777 /var/supervisord/supervisor.sock
chmod 777 /var/supervisord/supervisor.log
chmod 777 /var/supervisord/supervisor.pid
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后vim &lt;span&gt;/etc/supervisord.conf 把配置文件中的&lt;/span&gt;&lt;span&gt;supervisor.sock、&lt;/span&gt;&lt;span&gt;supervisor.log、&lt;/span&gt;&lt;span&gt;supervisor.pid三个文件的保存位置改为刚建立的三个文件位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/97122/202102/97122-20210213195725248-2082299673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/97122/202102/97122-20210213200907329-897319448.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/97122/202102/97122-20210213200940951-960708989.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;





&lt;p&gt;&lt;strong&gt; 在文件最后打开守护程序配置所在目录&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/97122/202102/97122-20210213201202256-902612492.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 完成后保存退出。然后建立一个Supervisor的启动脚本（&lt;span&gt;vim /lib/systemd/system/&lt;/span&gt;&lt;span&gt;supervisord.service&lt;/span&gt;）然后填入以下内容保存退出。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[Unit]
Description=Process Monitoring and Control Daemon
After=rc-local.service

[Service]
Type=forking
ExecStart=supervisord -c /etc/supervisord.conf
SysVStartPriority=99

[Install]
WantedBy=multi-user.target
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后执行systemctl enable supervisord.service来设置开机自动启动服务，接着重启服务器，然后我们运行ps -ef |grep supervisord即可看到supervisor已经开机自动启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/97122/202102/97122-20210213201749833-2040388393.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着我们安装libgdiplus，进入到libgdiplus解压缩后的目录，然后执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./autogen.sh --prefix=/usr/local/lib
./configure --prefix=/usr/local/lib
make
make install&lt;br/&gt;ldconfig
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接着我们按照微软官网上的教程安装ASP.NET Core3.1运行时（本次上传路径在/upload下）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
mkdir -p &quot;$HOME/dotnet&quot; &amp;amp;&amp;amp; tar zxf aspnetcore-runtime-3.1.11-linux-x64.tar.gz -C &quot;$HOME/dotnet&quot;
export DOTNET_ROOT=$HOME/dotnet
export PATH=$PATH:$HOME/dotnet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着我们运行dotnet --version就可以看到当前ASP.NET Core的版本是3.1&lt;/p&gt;
&lt;p&gt;此时我们就可以把我们编译后的网站上传到服务器上（本次使用的目录是/usr/src/wwww/whitelist），然后在/var/supervisord.d/目录下建一个网站的ini配置文件，内容如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[program:bmd.Site]
command=dotnet WhiteList.dll
directory=/usr/src/wwww/whitelist
environment=ASPNETCORE__ENVIRONMENT=Production
user=root
stopsignal=INT
autostart=true
autorestart=true
startsecs=3
stderr_logfile=/var/log/whitelist.err.log    
stdout_logfile=/var/log/whitelist.out.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;随后我们运行&lt;span&gt;supervisorctl reload或者&lt;/span&gt;&lt;span&gt;&lt;span&gt;systemctl restart supervisord.service重新启动&lt;/span&gt;&lt;/span&gt;&lt;span&gt;supervisord，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;因为我们使用的是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Kestrel来作为web服务，所以我们需要把5000端口打开（&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;firewall-cmd --zone=public --add-port=5000/tcp --permanent &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;firewall-cmd --reload&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;）同时需要在&lt;/span&gt;&lt;span&gt;&lt;span&gt;appsettings.json&lt;/span&gt;&lt;/span&gt;&lt;span&gt;中启用配置&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
&quot;Kestrel&quot;: {
    &quot;EndPoints&quot;: {
      &quot;Http&quot;: {
        &quot;Url&quot;: &quot;http://0.0.0.0:5000&quot;
      }
    }
  },
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;随后我们就可以看到我们的网站已经运行成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/97122/202102/97122-20210213210213698-821501449.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/97122/202102/97122-20210213210928315-1479693566.png&quot; alt=&quot;&quot; width=&quot;714&quot; height=&quot;394&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/97122/202102/97122-20210213191551861-1641550718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 13 Feb 2021 13:11:00 +0000</pubDate>
<dc:creator>踏平扶桑</dc:creator>
<og:description>银河麒麟高级服务器操作系统V10是针对企业级关键业务，适应虚拟化、云计算、大数据、工业互联网时代对主机系统可靠性、安全性、性能、扩展性和实时性的需求，依据CMMI 5级标准研制的提供内生安全、云原生支</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wdw984/p/14401021.html</dc:identifier>
</item>
<item>
<title>SpringBoot进阶教程(七十)SkyWalking - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/SpringBoot_Skywalking.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/SpringBoot_Skywalking.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img class=&quot;desc_img zhaiyaoImage&quot; src=&quot;https://www.cnblogs.com/images/cnblogs_com/toutou/699740/o_spring.png&quot; alt=&quot;请叫我头头哥&quot;/&gt;流行的APM(Application Performance Management工具有很多，比如Cat、Zipkin、Pinpoint、SkyWalking，优秀的监控工具还有很多，其它比如还有zabbix、prometheus、Arthas、Grafana之类的。这里主要介绍SkyWalking，它是一款优秀的国产APM工具，包括了分布式追踪、性能指标分析、应用和服务依赖分析等。Skywalking是一个分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。SkyWalking 是观察性分析平台和应用性能管理系统。提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;152.27494345313&quot;&gt;
&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;37.029485570891&quot;&gt;
&lt;blockquote readability=&quot;17.774153074028&quot;&gt;
&lt;p&gt;流行的APM(Application Performance Management工具有很多，比如Cat、Zipkin、Pinpoint、SkyWalking。优秀的监控工具还有很多，其它比如还有zabbix、prometheus、Arthas、Grafana之类的。这里主要介绍&lt;a title=&quot;SpringBoot进阶教程(七十)SkyWalking&quot; href=&quot;https://skywalking.apache.org/&quot; target=&quot;_blank&quot;&gt;SkyWalking&lt;/a&gt;，它是一款优秀的国产APM工具，包括了分布式追踪、性能指标分析、应用和服务依赖分析等。&lt;/p&gt;
&lt;p&gt;Skywalking是一个分布式系统的应用程序性能监视工具，专为微服务、云原生架构和基于容器（Docker、K8s、Mesos）架构而设计。SkyWalking 是观察性分析平台和应用性能管理系统。提供分布式追踪、服务网格遥测分析、度量聚合和可视化一体化解决方案。支持Java, .Net Core, PHP, NodeJS, Golang, LUA语言探针，支持Envoy + Istio构建的Service Mesh。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;介绍&lt;/h2&gt;
&lt;p&gt;1.1 SkyWalking 在逻辑上分为四部分：探针、平台后端、存储和用户界面。其架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202012/506684-20201231193014416-2052492904.png&quot; alt=&quot;SpringBoot进阶教程(七十)SkyWalking&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片来源于网络，侵删。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;探针：&lt;/span&gt;基于不同的来源探针可能是不一样的，但作用都是收集数据，将数据格式化为SkyWalking适用的格式。例如在Java中则是做字节码植入，无侵入式的收集，并通过HTTP或者GRPC方式发送数据到平台后端.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;平台后端：&lt;/span&gt;是一个支持集群模式运行的后台，用于数据聚合、数据分析以及驱动数据流从探针到用户界面的流程。平台后端还提供了各种可插拔的能力，如不同来源数据（如来自 Zipkin）格式化，不同存储系统以及集群管理。你甚至还可以使用观测分析语言来进行自定义聚合分析。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;存储：&lt;/span&gt;是开放式的，可以选择一个既有的存储系统，如ElasticSearch、H2 或 MySQL 集群（Sharding-Sphere 管理），也可以选择自己实现一个存储系统。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;用户界面：&lt;/span&gt;SkyWalking的可视化界面，UI非常炫酷且强大，同样它也是可定制以匹配你已存在的后端的。&lt;/p&gt;
&lt;p&gt;1.2 在SkyWalking中也存在服务、服务实例及端点概念，因为SkyWalking就是提供了这些概念的观测能力：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务（Service）：&lt;/span&gt;表示对请求提供相同行为的一系列或一组工作负载。在使用打点代理或 SDK 的时候，你可以定义服务的名字。如果不定义的话，SkyWalking 将会使用你在平台上定义的名字，如 Istio。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务实例（Service Instance）：&lt;/span&gt;上述的一组工作负载中的每一个工作负载称为一个实例。就像 Kubernetes 中的 pods 一样，服务实例未必就是操作系统上的一个进程。但当你在使用打点代理的时候， 一个服务实例实际就是操作系统上的一个真实进程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;端点（Endpoint）：&lt;/span&gt;对于特定服务所接收的请求路径，如 HTTP 的 URI 路径和 gRPC 服务的类名 + 方法签名&lt;/p&gt;
&lt;p&gt;1.3 SkyWalking的优势如下：&lt;/p&gt;
&lt;p&gt;1.多种监控手段，语言探针和服务网格（Service Mesh）&lt;/p&gt;
&lt;p&gt;2.模块化，UI、存储、集群管理多种机制可选&lt;/p&gt;
&lt;p&gt;3.支持告警(告警可以推送到钉钉)&lt;/p&gt;
&lt;p&gt;4.优秀的可视化方案&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;环境准备&lt;/h2&gt;
&lt;p&gt;2.1 拉取镜像&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker pull elasticsearch:7.5.1&lt;span&gt;
docker pull apache&lt;/span&gt;/skywalking-oap-server:8.3.0-&lt;span&gt;es7
docker pull apache&lt;/span&gt;/skywalking-ui:8.3.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.2 创建&amp;amp;启动elasticsearch&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
docker run -d --name=&lt;span&gt;es7 \
&lt;/span&gt;-p 9200:9200 -p 9300:9300&lt;span&gt; \
&lt;/span&gt;-e &quot;discovery.type=single-node&quot; elasticsearch:7.5.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意：若创建es持久化目录，则按下面的命令执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mkdir -p /data/&lt;span&gt;elasticsearch
docker cp es7:&lt;/span&gt;/usr/share/elasticsearch/data /data/elasticsearch/&lt;span&gt;
docker cp es7:&lt;/span&gt;/usr/share/elasticsearch/logs /data/elasticsearch/&lt;span&gt;
docker rm &lt;/span&gt;-&lt;span&gt;f es7
docker run &lt;/span&gt;-d --name=&lt;span&gt;es7 \
  &lt;/span&gt;--restart=&lt;span&gt;always \
  &lt;/span&gt;-p 9200:9200 -p 9300:9300&lt;span&gt; \
  &lt;/span&gt;-e &quot;discovery.type=single-node&quot;&lt;span&gt; \
  &lt;/span&gt;-v /data/elasticsearch/data:/usr/share/elasticsearch/&lt;span&gt;data \
  &lt;/span&gt;-v /data/elasticsearch/logs:/usr/share/elasticsearch/&lt;span&gt;logs \
elasticsearch:&lt;/span&gt;7.5.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.3 创建&amp;amp;启动OAP&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
docker run --name oap --restart always -&lt;span&gt;d \
&lt;/span&gt;--restart=&lt;span&gt;always \
&lt;/span&gt;-e TZ=Asia/&lt;span&gt;Shanghai \
&lt;/span&gt;-p 12800:12800&lt;span&gt; \
&lt;/span&gt;-p 11800:11800&lt;span&gt; \
&lt;/span&gt;--&lt;span&gt;link es7:es7 \
&lt;/span&gt;-e SW_STORAGE=&lt;span&gt;elasticsearch7 \
&lt;/span&gt;-e SW_STORAGE_ES_CLUSTER_NODES=es7:9200&lt;span&gt; \
apache&lt;/span&gt;/skywalking-oap-server:8.3.0-es7
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SW_STORAGE：表示选择elasticsearch7作为存储组件&lt;/p&gt;
&lt;p&gt;SW_STORAGE_ES_CLUSTER_NODES：elasticsearch的节点，多个用逗号隔开&lt;/p&gt;
&lt;p&gt;以上参数均为application.yml文件中的参数。&lt;/p&gt;
&lt;p&gt;application.yml详细信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_a9940489-3e19-406f-a087-5d69361f5350&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_a9940489-3e19-406f-a087-5d69361f5350&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a9940489-3e19-406f-a087-5d69361f5350&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;132&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Licensed to the Apache Software Foundation (ASF) under one or more
# contributor license agreements.  See the NOTICE file distributed with
# this work for additional information regarding copyright ownership.
# The ASF licenses this file to You under the Apache License, Version 2.0
# (the &quot;License&quot;); you may not use this file except in compliance with
# the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cluster:
  selector: ${SW_CLUSTER:standalone}
  standalone:
  # Please check your ZooKeeper is 3.5+, However, it is also compatible with ZooKeeper 3.4.x. Replace the ZooKeeper 3.5+
  # library the oap-libs folder with your ZooKeeper 3.4.x library.
  zookeeper:
    nameSpace: ${SW_NAMESPACE:&quot;&quot;}
    hostPort: ${SW_CLUSTER_ZK_HOST_PORT:localhost:2181}
    # Retry Policy
    baseSleepTimeMs: ${SW_CLUSTER_ZK_SLEEP_TIME:1000} # initial amount of time to wait between retries
    maxRetries: ${SW_CLUSTER_ZK_MAX_RETRIES:3} # max number of times to retry
    # Enable ACL
    enableACL: ${SW_ZK_ENABLE_ACL:false} # disable ACL in default
    schema: ${SW_ZK_SCHEMA:digest} # only support digest schema
    expression: ${SW_ZK_EXPRESSION:skywalking:skywalking}
  kubernetes:
    namespace: ${SW_CLUSTER_K8S_NAMESPACE:default}
    labelSelector: ${SW_CLUSTER_K8S_LABEL:app=collector,release=skywalking}
    uidEnvName: ${SW_CLUSTER_K8S_UID:SKYWALKING_COLLECTOR_UID}
  consul:
    serviceName: ${SW_SERVICE_NAME:&quot;SkyWalking_OAP_Cluster&quot;}
    # Consul cluster nodes, example: 10.0.0.1:8500,10.0.0.2:8500,10.0.0.3:8500
    hostPort: ${SW_CLUSTER_CONSUL_HOST_PORT:localhost:8500}
    aclToken: ${SW_CLUSTER_CONSUL_ACLTOKEN:&quot;&quot;}
  etcd:
    serviceName: ${SW_SERVICE_NAME:&quot;SkyWalking_OAP_Cluster&quot;}
    # etcd cluster nodes, example: 10.0.0.1:2379,10.0.0.2:2379,10.0.0.3:2379
    hostPort: ${SW_CLUSTER_ETCD_HOST_PORT:localhost:2379}
  nacos:
    serviceName: ${SW_SERVICE_NAME:&quot;SkyWalking_OAP_Cluster&quot;}
    hostPort: ${SW_CLUSTER_NACOS_HOST_PORT:localhost:8848}
    # Nacos Configuration namespace
    namespace: ${SW_CLUSTER_NACOS_NAMESPACE:&quot;public&quot;}
    # Nacos auth username
    username: ${SW_CLUSTER_NACOS_USERNAME:&quot;&quot;}
    password: ${SW_CLUSTER_NACOS_PASSWORD:&quot;&quot;}
    # Nacos auth accessKey
    accessKey: ${SW_CLUSTER_NACOS_ACCESSKEY:&quot;&quot;}
    secretKey: ${SW_CLUSTER_NACOS_SECRETKEY:&quot;&quot;}
core:
  selector: ${SW_CORE:default}
  default:
    # Mixed: Receive agent data, Level 1 aggregate, Level 2 aggregate
    # Receiver: Receive agent data, Level 1 aggregate
    # Aggregator: Level 2 aggregate
    role: ${SW_CORE_ROLE:Mixed} # Mixed/Receiver/Aggregator
    restHost: ${SW_CORE_REST_HOST:0.0.0.0}
    restPort: ${SW_CORE_REST_PORT:12800}
    restContextPath: ${SW_CORE_REST_CONTEXT_PATH:/}
    restMinThreads: ${SW_CORE_REST_JETTY_MIN_THREADS:1}
    restMaxThreads: ${SW_CORE_REST_JETTY_MAX_THREADS:200}
    restIdleTimeOut: ${SW_CORE_REST_JETTY_IDLE_TIMEOUT:30000}
    restAcceptorPriorityDelta: ${SW_CORE_REST_JETTY_DELTA:0}
    restAcceptQueueSize: ${SW_CORE_REST_JETTY_QUEUE_SIZE:0}
    gRPCHost: ${SW_CORE_GRPC_HOST:0.0.0.0}
    gRPCPort: ${SW_CORE_GRPC_PORT:11800}
    maxConcurrentCallsPerConnection: ${SW_CORE_GRPC_MAX_CONCURRENT_CALL:0}
    maxMessageSize: ${SW_CORE_GRPC_MAX_MESSAGE_SIZE:0}
    gRPCThreadPoolQueueSize: ${SW_CORE_GRPC_POOL_QUEUE_SIZE:-1}
    gRPCThreadPoolSize: ${SW_CORE_GRPC_THREAD_POOL_SIZE:-1}
    gRPCSslEnabled: ${SW_CORE_GRPC_SSL_ENABLED:false}
    gRPCSslKeyPath: ${SW_CORE_GRPC_SSL_KEY_PATH:&quot;&quot;}
    gRPCSslCertChainPath: ${SW_CORE_GRPC_SSL_CERT_CHAIN_PATH:&quot;&quot;}
    gRPCSslTrustedCAPath: ${SW_CORE_GRPC_SSL_TRUSTED_CA_PATH:&quot;&quot;}
    downsampling:
      - Hour
      - Day
    # Set a timeout on metrics data. After the timeout has expired, the metrics data will automatically be deleted.
    enableDataKeeperExecutor: ${SW_CORE_ENABLE_DATA_KEEPER_EXECUTOR:true} # Turn it off then automatically metrics data delete will be close.
    dataKeeperExecutePeriod: ${SW_CORE_DATA_KEEPER_EXECUTE_PERIOD:5} # How often the data keeper executor runs periodically, unit is minute
    recordDataTTL: ${SW_CORE_RECORD_DATA_TTL:3} # Unit is day
    metricsDataTTL: ${SW_CORE_METRICS_DATA_TTL:7} # Unit is day
    # Cache metrics data for 1 minute to reduce database queries, and if the OAP cluster changes within that minute,
    # the metrics may not be accurate within that minute.
    enableDatabaseSession: ${SW_CORE_ENABLE_DATABASE_SESSION:true}
    topNReportPeriod: ${SW_CORE_TOPN_REPORT_PERIOD:10} # top_n record worker report cycle, unit is minute
    # Extra model column are the column defined by in the codes, These columns of model are not required logically in aggregation or further query,
    # and it will cause more load for memory, network of OAP and storage.
    # But, being activated, user could see the name in the storage entities, which make users easier to use 3rd party tool, such as Kibana-&amp;gt;ES, to query the data by themselves.
    activeExtraModelColumns: ${SW_CORE_ACTIVE_EXTRA_MODEL_COLUMNS:false}
    # The max length of service + instance names should be less than 200
    serviceNameMaxLength: ${SW_SERVICE_NAME_MAX_LENGTH:70}
    instanceNameMaxLength: ${SW_INSTANCE_NAME_MAX_LENGTH:70}
    # The max length of service + endpoint names should be less than 240
    endpointNameMaxLength: ${SW_ENDPOINT_NAME_MAX_LENGTH:150}
    # Define the set of span tag keys, which should be searchable through the GraphQL.
    searchableTracesTags: ${SW_SEARCHABLE_TAG_KEYS:http.method,status_code,db.type,db.instance,mq.queue,mq.topic,mq.broker}
storage:
  selector: ${SW_STORAGE:h2}
  elasticsearch:
    nameSpace: ${SW_NAMESPACE:&quot;&quot;}
    clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:localhost:9200}
    protocol: ${SW_STORAGE_ES_HTTP_PROTOCOL:&quot;http&quot;}
    user: ${SW_ES_USER:&quot;&quot;}
    password: ${SW_ES_PASSWORD:&quot;&quot;}
    trustStorePath: ${SW_STORAGE_ES_SSL_JKS_PATH:&quot;&quot;}
    trustStorePass: ${SW_STORAGE_ES_SSL_JKS_PASS:&quot;&quot;}
    secretsManagementFile: ${SW_ES_SECRETS_MANAGEMENT_FILE:&quot;&quot;} # Secrets management file in the properties format includes the username, password, which are managed by 3rd party tool.
    dayStep: ${SW_STORAGE_DAY_STEP:1} # Represent the number of days in the one minute/hour/day index.
    indexShardsNumber: ${SW_STORAGE_ES_INDEX_SHARDS_NUMBER:1} # Shard number of new indexes
    indexReplicasNumber: ${SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:1} # Replicas number of new indexes
    # Super data set has been defined in the codes, such as trace segments.The following 3 config would be improve es performance when storage super size data in es.
    superDatasetDayStep: ${SW_SUPERDATASET_STORAGE_DAY_STEP:-1} # Represent the number of days in the super size dataset record index, the default value is the same as dayStep when the value is less than 0
    superDatasetIndexShardsFactor: ${SW_STORAGE_ES_SUPER_DATASET_INDEX_SHARDS_FACTOR:5} #  This factor provides more shards for the super data set, shards number = indexShardsNumber * superDatasetIndexShardsFactor. Also, this factor effects Zipkin and Jaeger traces.
    superDatasetIndexReplicasNumber: ${SW_STORAGE_ES_SUPER_DATASET_INDEX_REPLICAS_NUMBER:0} # Represent the replicas number in the super size dataset record index, the default value is 0.
    bulkActions: ${SW_STORAGE_ES_BULK_ACTIONS:1000} # Execute the async bulk record data every ${SW_STORAGE_ES_BULK_ACTIONS} requests
    syncBulkActions: ${SW_STORAGE_ES_SYNC_BULK_ACTIONS:50000} # Execute the sync bulk metrics data every ${SW_STORAGE_ES_SYNC_BULK_ACTIONS} requests
    flushInterval: ${SW_STORAGE_ES_FLUSH_INTERVAL:10} # flush the bulk every 10 seconds whatever the number of requests
    concurrentRequests: ${SW_STORAGE_ES_CONCURRENT_REQUESTS:2} # the number of concurrent requests
    resultWindowMaxSize: ${SW_STORAGE_ES_QUERY_MAX_WINDOW_SIZE:10000}
    metadataQueryMaxSize: ${SW_STORAGE_ES_QUERY_MAX_SIZE:5000}
    segmentQueryMaxSize: ${SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200}
    profileTaskQueryMaxSize: ${SW_STORAGE_ES_QUERY_PROFILE_TASK_SIZE:200}
    advanced: ${SW_STORAGE_ES_ADVANCED:&quot;&quot;}
  elasticsearch7:
    nameSpace: ${SW_NAMESPACE:&quot;&quot;}
    clusterNodes: ${SW_STORAGE_ES_CLUSTER_NODES:localhost:9200}
    protocol: ${SW_STORAGE_ES_HTTP_PROTOCOL:&quot;http&quot;}
    trustStorePath: ${SW_STORAGE_ES_SSL_JKS_PATH:&quot;&quot;}
    trustStorePass: ${SW_STORAGE_ES_SSL_JKS_PASS:&quot;&quot;}
    dayStep: ${SW_STORAGE_DAY_STEP:1} # Represent the number of days in the one minute/hour/day index.
    indexShardsNumber: ${SW_STORAGE_ES_INDEX_SHARDS_NUMBER:1} # Shard number of new indexes
    indexReplicasNumber: ${SW_STORAGE_ES_INDEX_REPLICAS_NUMBER:1} # Replicas number of new indexes
    # Super data set has been defined in the codes, such as trace segments.The following 3 config would be improve es performance when storage super size data in es.
    superDatasetDayStep: ${SW_SUPERDATASET_STORAGE_DAY_STEP:-1} # Represent the number of days in the super size dataset record index, the default value is the same as dayStep when the value is less than 0
    superDatasetIndexShardsFactor: ${SW_STORAGE_ES_SUPER_DATASET_INDEX_SHARDS_FACTOR:5} #  This factor provides more shards for the super data set, shards number = indexShardsNumber * superDatasetIndexShardsFactor. Also, this factor effects Zipkin and Jaeger traces.
    superDatasetIndexReplicasNumber: ${SW_STORAGE_ES_SUPER_DATASET_INDEX_REPLICAS_NUMBER:0} # Represent the replicas number in the super size dataset record index, the default value is 0.
    user: ${SW_ES_USER:&quot;&quot;}
    password: ${SW_ES_PASSWORD:&quot;&quot;}
    secretsManagementFile: ${SW_ES_SECRETS_MANAGEMENT_FILE:&quot;&quot;} # Secrets management file in the properties format includes the username, password, which are managed by 3rd party tool.
    bulkActions: ${SW_STORAGE_ES_BULK_ACTIONS:1000} # Execute the async bulk record data every ${SW_STORAGE_ES_BULK_ACTIONS} requests
    syncBulkActions: ${SW_STORAGE_ES_SYNC_BULK_ACTIONS:50000} # Execute the sync bulk metrics data every ${SW_STORAGE_ES_SYNC_BULK_ACTIONS} requests
    flushInterval: ${SW_STORAGE_ES_FLUSH_INTERVAL:10} # flush the bulk every 10 seconds whatever the number of requests
    concurrentRequests: ${SW_STORAGE_ES_CONCURRENT_REQUESTS:2} # the number of concurrent requests
    resultWindowMaxSize: ${SW_STORAGE_ES_QUERY_MAX_WINDOW_SIZE:10000}
    metadataQueryMaxSize: ${SW_STORAGE_ES_QUERY_MAX_SIZE:5000}
    segmentQueryMaxSize: ${SW_STORAGE_ES_QUERY_SEGMENT_SIZE:200}
    profileTaskQueryMaxSize: ${SW_STORAGE_ES_QUERY_PROFILE_TASK_SIZE:200}
    advanced: ${SW_STORAGE_ES_ADVANCED:&quot;&quot;}
  h2:
    driver: ${SW_STORAGE_H2_DRIVER:org.h2.jdbcx.JdbcDataSource}
    url: ${SW_STORAGE_H2_URL:jdbc:h2:mem:skywalking-oap-db}
    user: ${SW_STORAGE_H2_USER:sa}
    metadataQueryMaxSize: ${SW_STORAGE_H2_QUERY_MAX_SIZE:5000}
    maxSizeOfArrayColumn: ${SW_STORAGE_MAX_SIZE_OF_ARRAY_COLUMN:20}
    numOfSearchableValuesPerTag: ${SW_STORAGE_NUM_OF_SEARCHABLE_VALUES_PER_TAG:2}
  mysql:
    properties:
      jdbcUrl: ${SW_JDBC_URL:&quot;jdbc:mysql://localhost:3306/swtest&quot;}
      dataSource.user: ${SW_DATA_SOURCE_USER:root}
      dataSource.password: ${SW_DATA_SOURCE_PASSWORD:root@1234}
      dataSource.cachePrepStmts: ${SW_DATA_SOURCE_CACHE_PREP_STMTS:true}
      dataSource.prepStmtCacheSize: ${SW_DATA_SOURCE_PREP_STMT_CACHE_SQL_SIZE:250}
      dataSource.prepStmtCacheSqlLimit: ${SW_DATA_SOURCE_PREP_STMT_CACHE_SQL_LIMIT:2048}
      dataSource.useServerPrepStmts: ${SW_DATA_SOURCE_USE_SERVER_PREP_STMTS:true}
    metadataQueryMaxSize: ${SW_STORAGE_MYSQL_QUERY_MAX_SIZE:5000}
    maxSizeOfArrayColumn: ${SW_STORAGE_MAX_SIZE_OF_ARRAY_COLUMN:20}
    numOfSearchableValuesPerTag: ${SW_STORAGE_NUM_OF_SEARCHABLE_VALUES_PER_TAG:2}
  tidb:
    properties:
      jdbcUrl: ${SW_JDBC_URL:&quot;jdbc:mysql://localhost:4000/tidbswtest&quot;}
      dataSource.user: ${SW_DATA_SOURCE_USER:root}
      dataSource.password: ${SW_DATA_SOURCE_PASSWORD:&quot;&quot;}
      dataSource.cachePrepStmts: ${SW_DATA_SOURCE_CACHE_PREP_STMTS:true}
      dataSource.prepStmtCacheSize: ${SW_DATA_SOURCE_PREP_STMT_CACHE_SQL_SIZE:250}
      dataSource.prepStmtCacheSqlLimit: ${SW_DATA_SOURCE_PREP_STMT_CACHE_SQL_LIMIT:2048}
      dataSource.useServerPrepStmts: ${SW_DATA_SOURCE_USE_SERVER_PREP_STMTS:true}
      dataSource.useAffectedRows: ${SW_DATA_SOURCE_USE_AFFECTED_ROWS:true}
    metadataQueryMaxSize: ${SW_STORAGE_MYSQL_QUERY_MAX_SIZE:5000}
    maxSizeOfArrayColumn: ${SW_STORAGE_MAX_SIZE_OF_ARRAY_COLUMN:20}
    numOfSearchableValuesPerTag: ${SW_STORAGE_NUM_OF_SEARCHABLE_VALUES_PER_TAG:2}
  influxdb:
    # InfluxDB configuration
    url: ${SW_STORAGE_INFLUXDB_URL:http://localhost:8086}
    user: ${SW_STORAGE_INFLUXDB_USER:root}
    password: ${SW_STORAGE_INFLUXDB_PASSWORD:}
    database: ${SW_STORAGE_INFLUXDB_DATABASE:skywalking}
    actions: ${SW_STORAGE_INFLUXDB_ACTIONS:1000} # the number of actions to collect
    duration: ${SW_STORAGE_INFLUXDB_DURATION:1000} # the time to wait at most (milliseconds)
    batchEnabled: ${SW_STORAGE_INFLUXDB_BATCH_ENABLED:true}
    fetchTaskLogMaxSize: ${SW_STORAGE_INFLUXDB_FETCH_TASK_LOG_MAX_SIZE:5000} # the max number of fetch task log in a request

agent-analyzer:
  selector: ${SW_AGENT_ANALYZER:default}
  default:
    sampleRate: ${SW_TRACE_SAMPLE_RATE:10000} # The sample rate precision is 1/10000. 10000 means 100% sample in default.
    slowDBAccessThreshold: ${SW_SLOW_DB_THRESHOLD:default:200,mongodb:100} # The slow database access thresholds. Unit ms.
    forceSampleErrorSegment: ${SW_FORCE_SAMPLE_ERROR_SEGMENT:true} # When sampling mechanism active, this config can open(true) force save some error segment. true is default.
    segmentStatusAnalysisStrategy: ${SW_SEGMENT_STATUS_ANALYSIS_STRATEGY:FROM_SPAN_STATUS} # Determine the final segment status from the status of spans. Available values are `FROM_SPAN_STATUS` , `FROM_ENTRY_SPAN` and `FROM_FIRST_SPAN`. `FROM_SPAN_STATUS` represents the segment status would be error if any span is in error status. `FROM_ENTRY_SPAN` means the segment status would be determined by the status of entry spans only. `FROM_FIRST_SPAN` means the segment status would be determined by the status of the first span only.
    # Nginx and Envoy agents can't get the real remote address.
    # Exit spans with the component in the list would not generate the client-side instance relation metrics.
    noUpstreamRealAddressAgents: ${SW_NO_UPSTREAM_REAL_ADDRESS:6000,9000}
    slowTraceSegmentThreshold: ${SW_SLOW_TRACE_SEGMENT_THRESHOLD:-1} # Setting this threshold about the latency would make the slow trace segments sampled if they cost more time, even the sampling mechanism activated. The default value is `-1`, which means would not sample slow traces. Unit, millisecond.
    meterAnalyzerActiveFiles: ${SW_METER_ANALYZER_ACTIVE_FILES:} # Which files could be meter analyzed, files split by &quot;,&quot;

receiver-sharing-server:
  selector: ${SW_RECEIVER_SHARING_SERVER:default}
  default:
    # For Jetty server
    restHost: ${SW_RECEIVER_SHARING_REST_HOST:0.0.0.0}
    restPort: ${SW_RECEIVER_SHARING_REST_PORT:0}
    contextPath: ${SW_RECEIVER_SHARING_REST_CONTEXT_PATH:/}
    restMinThreads: ${SW_RECEIVER_SHARING_JETTY_MIN_THREADS:1}
    restMaxThreads: ${SW_RECEIVER_SHARING_JETTY_MAX_THREADS:200}
    restIdleTimeOut: ${SW_RECEIVER_SHARING_JETTY_IDLE_TIMEOUT:30000}
    restAcceptorPriorityDelta: ${SW_RECEIVER_SHARING_JETTY_DELTA:0}
    restAcceptQueueSize: ${SW_RECEIVER_SHARING_JETTY_QUEUE_SIZE:0}
    # For gRPC server
    gRPCHost: ${SW_RECEIVER_GRPC_HOST:0.0.0.0}
    gRPCPort: ${SW_RECEIVER_GRPC_PORT:0}
    maxConcurrentCallsPerConnection: ${SW_RECEIVER_GRPC_MAX_CONCURRENT_CALL:0}
    maxMessageSize: ${SW_RECEIVER_GRPC_MAX_MESSAGE_SIZE:0}
    gRPCThreadPoolQueueSize: ${SW_RECEIVER_GRPC_POOL_QUEUE_SIZE:0}
    gRPCThreadPoolSize: ${SW_RECEIVER_GRPC_THREAD_POOL_SIZE:0}
    gRPCSslEnabled: ${SW_RECEIVER_GRPC_SSL_ENABLED:false}
    gRPCSslKeyPath: ${SW_RECEIVER_GRPC_SSL_KEY_PATH:&quot;&quot;}
    gRPCSslCertChainPath: ${SW_RECEIVER_GRPC_SSL_CERT_CHAIN_PATH:&quot;&quot;}
    authentication: ${SW_AUTHENTICATION:&quot;&quot;}
receiver-register:
  selector: ${SW_RECEIVER_REGISTER:default}
  default:

receiver-trace:
  selector: ${SW_RECEIVER_TRACE:default}
  default:

receiver-jvm:
  selector: ${SW_RECEIVER_JVM:default}
  default:

receiver-clr:
  selector: ${SW_RECEIVER_CLR:default}
  default:

receiver-profile:
  selector: ${SW_RECEIVER_PROFILE:default}
  default:

service-mesh:
  selector: ${SW_SERVICE_MESH:default}
  default:

envoy-metric:
  selector: ${SW_ENVOY_METRIC:default}
  default:
    acceptMetricsService: ${SW_ENVOY_METRIC_SERVICE:true}
    alsHTTPAnalysis: ${SW_ENVOY_METRIC_ALS_HTTP_ANALYSIS:&quot;&quot;}
    # `k8sServiceNameRule` allows you to customize the service name in ALS via Kubernetes metadata,
    # the available variables are `pod`, `service`, f.e., you can use `${service.metadata.name}-${pod.metadata.labels.version}`
    # to append the version number to the service name.
    # Be careful, when using environment variables to pass this configuration, use single quotes(`''`) to avoid it being evaluated by the shell.
    k8sServiceNameRule: ${K8S_SERVICE_NAME_RULE:&quot;${service.metadata.name}&quot;}

prometheus-fetcher:
  selector: ${SW_PROMETHEUS_FETCHER:-}
  default:
    enabledRules: ${SW_PROMETHEUS_FETCHER_ENABLED_RULES:&quot;self&quot;}

kafka-fetcher:
  selector: ${SW_KAFKA_FETCHER:-}
  default:
    bootstrapServers: ${SW_KAFKA_FETCHER_SERVERS:localhost:9092}
    partitions: ${SW_KAFKA_FETCHER_PARTITIONS:3}
    replicationFactor: ${SW_KAFKA_FETCHER_PARTITIONS_FACTOR:2}
    enableMeterSystem: ${SW_KAFKA_FETCHER_ENABLE_METER_SYSTEM:false}
    isSharding: ${SW_KAFKA_FETCHER_IS_SHARDING:false}
    consumePartitions: ${SW_KAFKA_FETCHER_CONSUME_PARTITIONS:&quot;&quot;}
    kafkaHandlerThreadPoolSize: ${SW_KAFKA_HANDLER_THREAD_POOL_SIZE:-1}
    kafkaHandlerThreadPoolQueueSize: ${SW_KAFKA_HANDLER_THREAD_POOL_QUEUE_SIZE:-1}

receiver-meter:
  selector: ${SW_RECEIVER_METER:default}
  default:

receiver-otel:
  selector: ${SW_OTEL_RECEIVER:-}
  default:
    enabledHandlers: ${SW_OTEL_RECEIVER_ENABLED_HANDLERS:&quot;oc&quot;}
    enabledOcRules: ${SW_OTEL_RECEIVER_ENABLED_OC_RULES:&quot;istio-controlplane&quot;}

receiver_zipkin:
  selector: ${SW_RECEIVER_ZIPKIN:-}
  default:
    host: ${SW_RECEIVER_ZIPKIN_HOST:0.0.0.0}
    port: ${SW_RECEIVER_ZIPKIN_PORT:9411}
    contextPath: ${SW_RECEIVER_ZIPKIN_CONTEXT_PATH:/}
    jettyMinThreads: ${SW_RECEIVER_ZIPKIN_JETTY_MIN_THREADS:1}
    jettyMaxThreads: ${SW_RECEIVER_ZIPKIN_JETTY_MAX_THREADS:200}
    jettyIdleTimeOut: ${SW_RECEIVER_ZIPKIN_JETTY_IDLE_TIMEOUT:30000}
    jettyAcceptorPriorityDelta: ${SW_RECEIVER_ZIPKIN_JETTY_DELTA:0}
    jettyAcceptQueueSize: ${SW_RECEIVER_ZIPKIN_QUEUE_SIZE:0}

receiver_jaeger:
  selector: ${SW_RECEIVER_JAEGER:-}
  default:
    gRPCHost: ${SW_RECEIVER_JAEGER_HOST:0.0.0.0}
    gRPCPort: ${SW_RECEIVER_JAEGER_PORT:14250}

receiver-browser:
  selector: ${SW_RECEIVER_BROWSER:default}
  default:
    # The sample rate precision is 1/10000. 10000 means 100% sample in default.
    sampleRate: ${SW_RECEIVER_BROWSER_SAMPLE_RATE:10000}

query:
  selector: ${SW_QUERY:graphql}
  graphql:
    path: ${SW_QUERY_GRAPHQL_PATH:/graphql}

alarm:
  selector: ${SW_ALARM:default}
  default:

telemetry:
  selector: ${SW_TELEMETRY:none}
  none:
  prometheus:
    host: ${SW_TELEMETRY_PROMETHEUS_HOST:0.0.0.0}
    port: ${SW_TELEMETRY_PROMETHEUS_PORT:1234}
    sslEnabled: ${SW_TELEMETRY_PROMETHEUS_SSL_ENABLED:false}
    sslKeyPath: ${SW_TELEMETRY_PROMETHEUS_SSL_KEY_PATH:&quot;&quot;}
    sslCertChainPath: ${SW_TELEMETRY_PROMETHEUS_SSL_CERT_CHAIN_PATH:&quot;&quot;}

configuration:
  selector: ${SW_CONFIGURATION:none}
  none:
  grpc:
    host: ${SW_DCS_SERVER_HOST:&quot;&quot;}
    port: ${SW_DCS_SERVER_PORT:80}
    clusterName: ${SW_DCS_CLUSTER_NAME:SkyWalking}
    period: ${SW_DCS_PERIOD:20}
  apollo:
    apolloMeta: ${SW_CONFIG_APOLLO:http://localhost:8080}
    apolloCluster: ${SW_CONFIG_APOLLO_CLUSTER:default}
    apolloEnv: ${SW_CONFIG_APOLLO_ENV:&quot;&quot;}
    appId: ${SW_CONFIG_APOLLO_APP_ID:skywalking}
    period: ${SW_CONFIG_APOLLO_PERIOD:5}
  zookeeper:
    period: ${SW_CONFIG_ZK_PERIOD:60} # Unit seconds, sync period. Default fetch every 60 seconds.
    nameSpace: ${SW_CONFIG_ZK_NAMESPACE:/default}
    hostPort: ${SW_CONFIG_ZK_HOST_PORT:localhost:2181}
    # Retry Policy
    baseSleepTimeMs: ${SW_CONFIG_ZK_BASE_SLEEP_TIME_MS:1000} # initial amount of time to wait between retries
    maxRetries: ${SW_CONFIG_ZK_MAX_RETRIES:3} # max number of times to retry
  etcd:
    period: ${SW_CONFIG_ETCD_PERIOD:60} # Unit seconds, sync period. Default fetch every 60 seconds.
    group: ${SW_CONFIG_ETCD_GROUP:skywalking}
    serverAddr: ${SW_CONFIG_ETCD_SERVER_ADDR:localhost:2379}
    clusterName: ${SW_CONFIG_ETCD_CLUSTER_NAME:default}
  consul:
    # Consul host and ports, separated by comma, e.g. 1.2.3.4:8500,2.3.4.5:8500
    hostAndPorts: ${SW_CONFIG_CONSUL_HOST_AND_PORTS:1.2.3.4:8500}
    # Sync period in seconds. Defaults to 60 seconds.
    period: ${SW_CONFIG_CONSUL_PERIOD:60}
    # Consul aclToken
    aclToken: ${SW_CONFIG_CONSUL_ACL_TOKEN:&quot;&quot;}
  k8s-configmap:
    period: ${SW_CONFIG_CONFIGMAP_PERIOD:60}
    namespace: ${SW_CLUSTER_K8S_NAMESPACE:default}
    labelSelector: ${SW_CLUSTER_K8S_LABEL:app=collector,release=skywalking}
  nacos:
    # Nacos Server Host
    serverAddr: ${SW_CONFIG_NACOS_SERVER_ADDR:127.0.0.1}
    # Nacos Server Port
    port: ${SW_CONFIG_NACOS_SERVER_PORT:8848}
    # Nacos Configuration Group
    group: ${SW_CONFIG_NACOS_SERVER_GROUP:skywalking}
    # Nacos Configuration namespace
    namespace: ${SW_CONFIG_NACOS_SERVER_NAMESPACE:}
    # Unit seconds, sync period. Default fetch every 60 seconds.
    period: ${SW_CONFIG_NACOS_PERIOD:60}
    # Nacos auth username
    username: ${SW_CONFIG_NACOS_USERNAME:&quot;&quot;}
    password: ${SW_CONFIG_NACOS_PASSWORD:&quot;&quot;}
    # Nacos auth accessKey
    accessKey: ${SW_CONFIG_NACOS_ACCESSKEY:&quot;&quot;}
    secretKey: ${SW_CONFIG_NACOS_SECRETKEY:&quot;&quot;}

exporter:
  selector: ${SW_EXPORTER:-}
  grpc:
    targetHost: ${SW_EXPORTER_GRPC_HOST:127.0.0.1}
    targetPort: ${SW_EXPORTER_GRPC_PORT:9870}

health-checker:
  selector: ${SW_HEALTH_CHECKER:-}
  default:
    checkIntervalSeconds: ${SW_HEALTH_CHECKER_INTERVAL_SECONDS:5}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2.4 创建&amp;amp;启动UI&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker run -d --name skywalking-ui \
--restart=always \
-e TZ=Asia/Shanghai \
-p 8101:8080 \
--link oap:oap \
-e SW_OAP_ADDRESS=oap:12800 \
apache/skywalking-ui:8.3.0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.5 下载源码包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wget https://mirrors.tuna.tsinghua.edu.cn/apache/skywalking/8.3.0/apache-skywalking-apm-8.3.0.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;官网的源码包下载比较慢，就换成tuna的了。下载好了之后，解压在/opt目录下，暂时不用管，这个在后面会用到agent。&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;部署/接入SkyWalking&lt;/h2&gt;
&lt;p&gt;3.1 生成springboot JAR包&lt;/p&gt;
&lt;p&gt;若生成springbootJAR包有疑惑的，可以看看这篇文章。&lt;a title=&quot;SpringBoot入门教程(二)CentOS部署SpringBoot项目从0到1&quot; href=&quot;https://www.cnblogs.com/toutou/p/9675218.html&quot; target=&quot;_blank&quot;&gt;SpringBoot入门教程(二)CentOS部署SpringBoot项目从0到1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.2 启动JAR包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
nohup java -javaagent:/opt/apache-skywalking-apm-bin/agent/skywalking-agent.jar -Dskywalking.agent.service_name=toutou_blog -Dskywalking.collector.backend_service=127.0.0.1:11800 -jar /data/&lt;span&gt;package&lt;/span&gt;/learn-web-0.0.1-SNAPSHOT.jar -d --server.port=8100 &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-javaagent：用于指定探针路径。指定agent包位置。在上面的步骤中已经将apache-skywalking-apm-8.3.0.tar.gz解压到/opt目录了，因此路径为：/opt/apache-skywalking-apm-bin/agent/skywalking-agent.jar&lt;/p&gt;
&lt;p&gt;-Dskywalking.agent.service_name：用于重写 agent/config/agent.config 配置文件中的服务名&lt;/p&gt;
&lt;p&gt;-Dskywalking.collector.backend_service：用于重写agent/config/agent.config 配置文件中的服务地址&lt;/p&gt;
&lt;p&gt;3.3 访问UI&lt;/p&gt;
&lt;p&gt;第一次访问时，需要先调用springboot中的接口后，SkyWalking UI中即会load对应的信息，效果如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202012/506684-20201231193245210-482329573.png&quot; alt=&quot;SpringBoot进阶教程(七十)SkyWalking&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;拓扑图/topology：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202012/506684-20201231193252730-880353878.png&quot; alt=&quot;SpringBoot进阶教程(七十)SkyWalking&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;追踪/trace：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202012/506684-20201231193259994-1006023415.png&quot; alt=&quot;SpringBoot进阶教程(七十)SkyWalking&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于更多SkyWalking UI介绍，可以看看&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/apache/skywalking/blob/master/docs/en/ui/README.md&quot; target=&quot;_blank&quot;&gt;官方介绍&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;其他参考/学习资料：&lt;/p&gt;
&lt;h2 id=&quot;_nav_3&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/toutouge/javademosecond/tree/master/hellolearn&quot; target=&quot;_blank&quot;&gt;https://github.com/toutouge/javademosecond/tree/master/hellolearn&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a title=&quot;SpringBoot进阶教程(七十)SkyWalking&quot; href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 13 Feb 2021 13:11:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>流行的APM(Application Performance Management工具有很多，比如Cat、Zipkin、Pinpoint、SkyWalking。优秀的监控工具还有很多，其它比如还有za</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toutou/p/SpringBoot_Skywalking.html</dc:identifier>
</item>
</channel>
</rss>