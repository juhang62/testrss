<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>rabbitmq系列（三）消息幂等性处理 - 执偕</title>
<link>http://www.cnblogs.com/zhixie/p/12204095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhixie/p/12204095.html</guid>
<description>&lt;h2 id=&quot;一springboot整合rabbitmq&quot;&gt;一、springboot整合rabbitmq&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;我们需要新建两个工程，一个作为生产者，另一个作为消费者。在pom.xml中添加amqp依赖：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在application.yml文件中添加rabbitmq的相关信息：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;spring:
  rabbitmq:
    # 连接地址
    host: 127.0.0.1
    # 端口
    port: 5672
    # 登录账号
    username: guest
    # 登录密码
    password: guest
    # 虚拟主机
    virtual-host: /&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在生产者工程中新建配置项rabbitmqConfig.java，申明名称为”byte-zb“直连交换机和队列，使用”byte-zb“的routing-key将队列和交换机绑定，代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class RabbitConfig {

    public static final String QUEUE_NAME = &quot;byte-zb&quot;;

    public static final String EXCHANGE_NAME = &quot;byte-zb&quot;;

    public static final String ROUTING_KEY = &quot;byte-zb&quot;;

    // 队列申明
    @Bean
    public Queue queue(){
        return new Queue(QUEUE_NAME);
    }

    // 申明交换机
    @Bean
    public DirectExchange directExchange(){

        return new DirectExchange(EXCHANGE_NAME);
    }

    // 数据绑定申明
    @Bean
    public Binding directBinding(){

        return BindingBuilder.bind(queue()).to(directExchange()).with(ROUTING_KEY);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;创建生产者发送一条消息，代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class Producer {
    public static final String QUEUE_NAME = &quot;byte-zb&quot;;

    public static final String EXCHANGE_NAME = &quot;byte-zb&quot;;

    @Autowired
    private AmqpTemplate amqpTemplate;

    @RequestMapping(&quot;/send&quot;)
    public void sendMessage(){

        JSONObject jsonObject = new JSONObject();
        jsonObject.put(&quot;email&quot;,&quot;11111111111&quot;);
        jsonObject.put(&quot;timestamp&quot;,System.currentTimeMillis());
        String json = jsonObject.toJSONString();
        System.out.println(json);
        amqpTemplate.convertAndSend(EXCHANGE_NAME,QUEUE_NAME,json);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;在消费者工程里创建消费者消费消息，代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class Consumer throws Exception{

    public static final String QUEUE_NAME = &quot;byte-zb&quot;;

    @RabbitListener(queues = QUEUE_NAME)
    public void receiveMessage(String message){

        System.out.println(&quot;接收到的消息为&quot;+message);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们启动生产者，然后请求send接口，然后打开rabbitmq控制台发现多了一个名为”byte-zb“的交换机和队列，并且队列中出现了一个未消费的消息，然后启动消费者，我们会在控制台上发现打印了一条消息，同时rabbitmq控制台中”byte-zb“的队列中消息没有了。&lt;/p&gt;
&lt;h2 id=&quot;二自动补偿机制&quot;&gt;二、自动补偿机制&lt;/h2&gt;
&lt;p&gt;如果消费者消息消费不成功的话，会出现什么情况呢？我们修改一下消费者代码，然后看看。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class Consumer {

    public static final String QUEUE_NAME = &quot;byte-zb&quot;;

    @RabbitListener(queues = QUEUE_NAME)
    public void receiveMessage(String message) throws Exception {

        System.out.println(&quot;接收到的消息为&quot;+message);
        int i = 1 / 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们会看到消费者工程控制台一直在刷新报错，&lt;strong&gt;当消费者配出异常，也就是说当消息消费不成功的话，该消息会存放在rabbitmq的服务端，一直进行重试，直到不抛出异常为止。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果一直抛异常，我们的服务很容易挂掉，那有没有办法控制重试几次不成功就不再重试了呢？答案是有的。我们在消费者application.yml中增加一段配置。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;spring:
  rabbitmq:
    # 连接地址
    host: 127.0.0.1
    # 端口
    port: 5672
    # 登录账号
    username: guest
    # 登录密码
    password: guest
    # 虚拟主机
    virtual-host: /
    listener:
      simple:
        retry:
          enabled: true # 开启消费者进行重试
          max-attempts: 5 # 最大重试次数
          initial-interval: 3000 # 重试时间间隔&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面配置的意思是消费异常后，重试五次，每次隔3s。继续启动消费者看看效果，我们发现重试五次以后，就不再重试了。&lt;/p&gt;
&lt;h2 id=&quot;三结合实际案例来使用消息补偿机制&quot;&gt;三、结合实际案例来使用消息补偿机制&lt;/h2&gt;
&lt;p&gt;像上面那种情况出现的异常其实不管怎么重试都不会成功，实际上用到消息补偿的就是调用第三方接口的这种。&lt;/p&gt;
&lt;p&gt;案例：生者往队列中扔一条消息，包含邮箱和发送内容。消费者拿到消息后将调用邮件接口发送邮件。有时候可能邮件接口由于网络等原因不通，这时候就需要去重试了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在调用接口的工具类中，如果出现异常我们直接返回null&lt;/strong&gt;，工具类具体代码就不贴了，如果返回null之后怎么处理呢？我们只需要抛出异常，rabbitListener捕获到异常后就会自动重试。&lt;/p&gt;
&lt;p&gt;我们改造一下消费者代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class Consumer {

    public static final String QUEUE_NAME = &quot;byte-zb&quot;;

    @RabbitListener(queues = QUEUE_NAME)
    public void receiveMessage(String message) throws Exception {

        System.out.println(&quot;接收到的消息为&quot;+message);
        JSONObject jsonObject = JSONObject.parseObject(message);
        String email = jsonObject.getString(&quot;email&quot;);
        String content = jsonObject.getString(&quot;timestamp&quot;);

        String httpUrl = &quot;http://127.0.0.1:8080/email?email&quot;+email+&quot;&amp;amp;content=&quot;+content;
        // 如果发生异常则返回null
        String body = HttpUtils.httpGet(httpUrl, &quot;utf-8&quot;);
        //
        if(body == null){
            throw new Exception();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然我们可以自定义异常抛出。具体怎么试验呢，&lt;strong&gt;第一步启动生产者和消费者，这时候我们发现消费者在重试，第二步我们启动邮件服务，这时候我们会发现邮件发送成功了，消费者不再重试了&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;四解决消息幂等性问题&quot;&gt;四、解决消息幂等性问题&lt;/h2&gt;
&lt;p&gt;一些刚接触java的同学可能对幂等性不太清楚。幂等性就是重复消费造成结果不一致。为了保证幂等性，因此消费者消费消息只能消费一次消息。我么可以是用全局的消息id来控制幂等性。当消息被消费了之后我们可以选择缓存保存这个消息id，然后当再次消费的时候，我们可以查询缓存，如果存在这个消息id，我们就不错处理直接return即可。先改造生产者代码，在消息中添加消息id：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/send&quot;)
    public void sendMessage(){

        JSONObject jsonObject = new JSONObject();
        jsonObject.put(&quot;email&quot;,&quot;11111111111&quot;);
        jsonObject.put(&quot;timestamp&quot;,System.currentTimeMillis());
        String json = jsonObject.toJSONString();
        System.out.println(json);

            Message message = MessageBuilder.withBody(json.getBytes()).setContentType(MessageProperties.CONTENT_TYPE_JSON)
                .setContentEncoding(&quot;UTF-8&quot;).setMessageId(UUID.randomUUID()+&quot;&quot;).build();
        amqpTemplate.convertAndSend(EXCHANGE_NAME,QUEUE_NAME,message);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费者代码改造：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class Consumer {

    public static final String QUEUE_NAME = &quot;byte-zb&quot;;

    @RabbitListener(queues = QUEUE_NAME)
    public void receiveMessage(Message message) throws Exception {

        Jedis jedis = new Jedis(&quot;localhost&quot;, 6379);

        String messageId = message.getMessageProperties().getMessageId();
        String msg = new String(message.getBody(),&quot;UTF-8&quot;);
        System.out.println(&quot;接收导的消息为：&quot;+msg+&quot;==消息id为：&quot;+messageId);

        String messageIdRedis = jedis.get(&quot;messageId&quot;);

        if(messageId == messageIdRedis){
            return;
        }
        JSONObject jsonObject = JSONObject.parseObject(msg);
        String email = jsonObject.getString(&quot;email&quot;);
        String content = jsonObject.getString(&quot;timestamp&quot;);

        String httpUrl = &quot;http://127.0.0.1:8080/email?email&quot;+email+&quot;&amp;amp;content=&quot;+content;
        // 如果发生异常则返回null
        String body = HttpUtils.httpGet(httpUrl, &quot;utf-8&quot;);
        //
        if(body == null){
            throw new Exception();
        }
        jedis.set(&quot;messageId&quot;,messageId);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在消费者端使用redis存储消息id，只做演示，具体项目请根据实际情况选择相应的工具进行存储。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果文章对您有帮助，请记得点赞关注哟~&lt;br/&gt;欢迎大家关注我的公众号：字节传说，每日推送技术文章供大家学习参考。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 17 Jan 2020 00:34:00 +0000</pubDate>
<dc:creator>执偕</dc:creator>
<og:description>一、springboot整合rabbitmq 1. 我们需要新建两个工程，一个作为生产者，另一个作为消费者。在pom.xml中添加amqp依赖： 2. 在application.yml文件中添加rab</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhixie/p/12204095.html</dc:identifier>
</item>
<item>
<title>自己动手实现智能家居之温湿度数码管展示（四位共阳数码管） - 7tiny</title>
<link>http://www.cnblogs.com/7tiny/p/12196486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/7tiny/p/12196486.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;【前言】&lt;/h2&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;一个热爱技术的人一定向往有一个科技感十足的环境吧，那何不亲自实践一下属于技术人的座右铭：“技术改变世界”。&lt;/p&gt;
&lt;p&gt;就让我们一步步动手搭建一个属于自己的“智能家居平台”吧（不要对这个名词抬杠啦，技术在手，怎么设计实现因人而异），本文只做抛砖引玉，各路大神如果有更好的想法可以各显神通，当然能在评论区留下更好的想法让大家共同学习是再好不过啦。&lt;/p&gt;
&lt;p&gt;在文章最后附有所有源代码，有需要的可以自行下载，感谢Star~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;系列目录&quot;&gt;【系列目录】&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11420102.html&quot;&gt;树莓派GPIO简介（Python版）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/11636462.html&quot;&gt;温湿度数据采集存储（DHT11，MySql）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;温湿度数码管展示（四位共阳数码管）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/12196486.html#&quot;&gt;构建App展示温湿度报表（ApiCloud，Python Flask）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/12196486.html#&quot;&gt;普通家用排插集成继电器手工改造&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/12196486.html#&quot;&gt;App远程控制“自制智能”排插&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/12196486.html#&quot;&gt;使用花生棒内网穿透实现外网访问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/7tiny/p/12196486.html#&quot;&gt;App远程监控（摄像头模块集成）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;本节概要&quot;&gt;【本节概要】&lt;/h2&gt;
&lt;p&gt;上一节我们介绍了基于树莓派基于DHT11采集温湿度并将记录存储到mysql数据库中，这一节我们将分享四位共阳数码管的使用以及将我们的温湿度数据在数码管展示。&lt;/p&gt;
&lt;p&gt;效果图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008220229990-678946534.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么接下来我们就一步步讲解这个&quot;穷且益艰&quot;的过程...&lt;/p&gt;
&lt;h2 id=&quot;硬件采购&quot;&gt;【硬件采购】&lt;/h2&gt;
&lt;p&gt;”某宝“购买一个四路共阳数码管模块，不贵，一两瓶饮料的价格。下图很明显有四个显示位，并且是公用阳极，而用阴极控制显示与否，因此叫四路共阳。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/202001/998608-20200115151108582-727729364.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明书有一张图就够了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/202001/998608-20200115142732482-1809721327.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1，2，3，4 高电平控制显示的位置 ABCDEFG/DP 对应显示右面各个部位（低电平）&lt;/p&gt;
&lt;h2 id=&quot;四路共阳数码管的控制&quot;&gt;【四路共阳数码管的控制】&lt;/h2&gt;
&lt;p&gt;四路共阳数码管的控制我没有找到好用的现成包，因此我这里直接自行封装了一个，涵盖了能显示的数字和字母小数点，类如下，可直接复制调用：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
import sys
sys.path.append('..')

import time
import RPi.GPIO as GPIO

# 共阳4位数字管
class Yang4():
    # 显示位数
    p1 = 1
    p2 = 2
    p3 = 3
    p4 = 4
    # 显示状态
    a = 5
    b = 6
    c = 7
    d = 8
    e = 9
    f = 10
    g = 11
    dp = 12
    positionPoints = []
    numberPoints = []

    # 初始化并设置控制针脚
    # 针脚连接顺序：位置1-4，数字a-dp
    def __init__(self, p1, p2, p3, p4, a, b, c, d, e, f, g, dp):
        self.p1 = p1
        self.p2 = p2
        self.p3 = p3
        self.p4 = p4
        self.a = a
        self.b = b
        self.c = c
        self.d = d
        self.e = e
        self.f = f
        self.g = g
        self.dp = dp
        self.positionPoints = [p1, p2, p3, p4]
        self.numberPoints = [a, b, c, d, e, f, g, dp]

        # Board模式
        GPIO.setmode(GPIO.BOARD)
        # 关闭提示
        GPIO.setwarnings(False)

        for item in self.positionPoints+self.numberPoints:
            GPIO.setup(item, GPIO.OUT)

    # 输入一个字符串
    def Display(self, str8bit):
        self.__DisplayCode(str8bit)

    # 筛选并控制显示各位置
    def __DisplayCode(self, str8bit):
        # 当前位置
        index = -1
        for i in range(0, len(str8bit)):
            if index &amp;gt; 8:
                return

            arg = str(str8bit[i])
            if arg == '.' and index % 2 != 0:
                index = index + 1
            elif arg != '.' and index % 2 != 1:
                index = index + 1
            
            index = index + 1

            self.__ResetPosition()
            self.__ResetNumber()
            self.__DisplayNumberSwitch(arg)
            GPIO.output(self.positionPoints[index//2], 1)
            time.sleep(0.002)


    def __ResetPosition(self):
        for item in self.positionPoints:
            GPIO.output(item, 0)

    def __ResetNumber(self):
        for item in self.numberPoints:
            GPIO.output(item, 1)

    def __DisplayNumberSwitch(self, arg):
        # print('arg='+str(arg))
        if arg == '.':
            self.__Display_DOT()
        # 上方小圈用小o，下方小圈用中文句号
        elif arg == 'o':
            self.__Display_TopCircle()
        elif arg == '。':
            self.__Display_DownCircle()
        # -----------------------------
        elif arg == '0':
            self.__Display_0()
        elif arg == '1':
            self.__Display_1()
        elif arg == '2':
            self.__Display_2()
        elif arg == '3':
            self.__Display_3()
        elif arg == '4':
            self.__Display_4()
        elif arg == '5':
            self.__Display_5()
        elif arg == '6':
            self.__Display_6()
        elif arg == '7':
            self.__Display_7()
        elif arg == '8':
            self.__Display_8()
        elif arg == '9':
            self.__Display_9()
        # -----------------------------
        elif arg == 'A':
            self.__Display_A()
        elif arg == 'B':
            self.__Display_B()
        elif arg == 'C':
            self.__Display_C()
        elif arg == 'D':
            self.__Display_D()
        elif arg == 'd':
            self.__Display_d()
        elif arg == 'E':
            self.__Display_E()
        elif arg == 'F':
            self.__Display_F()
        elif arg == 'G':
            self.__Display_G()
        elif arg == 'H':
            self.__Display_H()
        elif arg == 'I':
            self.__Display_I()
        elif arg == 'J':
            self.__Display_J()
        elif arg == 'L':
            self.__Display_L()
        elif arg == 'O':
            self.__Display_O()
        elif arg == 'P':
            self.__Display_P()
        elif arg == 'S':
            self.__Display_S()
        elif arg == 'U':
            self.__Display_U()
        elif arg == 'V':
            self.__Display_V()
        else:
            None

    def __Display_DOT(self):
        GPIO.output(self.dp, 0)

    def __Display_TopCircle(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.g, 0)
        GPIO.output(self.f, 0)

    def __Display_DownCircle(self):
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.g, 0)

    # -----------------------------
    def __Display_0(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)

    def __Display_1(self):
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)

    def __Display_2(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.g, 0)

    def __Display_3(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.g, 0)

    def __Display_4(self):
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    def __Display_5(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    def __Display_6(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    def __Display_7(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)

    def __Display_8(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    def __Display_9(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    # -----------------------------
    def __Display_A(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    def __Display_B(self):
        self.__Display_8()

    def __Display_C(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)

    def __Display_d(self):
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.g, 0)

    def __Display_D(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)

    def __Display_E(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    def __Display_F(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    def __Display_G(self):
        self.__Display_6()

    def __Display_H(self):
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    def __Display_I(self):
        self.__Display_1()

    def __Display_J(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)

    def __Display_L(self):
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)

    def __Display_O(self):
        self.__Display_0()

    def __Display_P(self):
        GPIO.output(self.a, 0)
        GPIO.output(self.b, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)
        GPIO.output(self.g, 0)

    def __Display_S(self):
        self.__Display_5()

    def __Display_U(self):
        GPIO.output(self.b, 0)
        GPIO.output(self.c, 0)
        GPIO.output(self.d, 0)
        GPIO.output(self.e, 0)
        GPIO.output(self.f, 0)

    def __Display_V(self):
        self.__Display_U()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然使用的demo也得拱手献上：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
from GPIO.NixieTube import 

# 需要的针脚对应的树莓派GPIO针脚
# 针脚连接顺序：位置1-4，数字a-dp
# 可以参考参数顺序，对应数码管定义的各个引脚 __init__(self, p1, p2, p3, p4, a, b, c, d, e, f, g, dp):
y4 = Yang4(35, 16, 22, 32, 31, 36, 38, 33, 37, 12, 18, 40)
delay = 600

# 显示时间
while(True):
    # time
    timenow = datetime.datetime.now()

    for i in range(0, delay):
        y4.Display(str(timenow.year))
        time.sleep(0.005)

    for i in range(0, delay):
        y4.Display(str(timenow.month).zfill(
            2)+'.'+str(timenow.day).zfill(2))
        time.sleep(0.005)

    for i in range(0, delay):
        y4.Display(str(timenow.hour).zfill(
            2)+'.'+str(timenow.minute).zfill(2))
        time.sleep(0.005)

    y4.Display('....')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码的功能为：按一定的间隔循环显示年月日时分。&lt;/p&gt;
&lt;p&gt;因为数码管实际上是无限循环展示各个需要显示的位置，肉眼无法捕捉时间间隔很短的显隐变化。也就是看起来显示的年月日时分秒，真实应该是数码管的各个小节循环在显示，这样就可以用几个引脚显示较为复杂的图像。&lt;/p&gt;
&lt;h2 id=&quot;集成温湿度数据获取存储和显示&quot;&gt;【集成温湿度数据获取存储和显示】&lt;/h2&gt;
&lt;p&gt;可以操作数码管显示之后，我们将之前的温湿度的数据和数码管的显示集成在一起（可以参考前面博文）&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
from Utility.MySqlHelper import MySqlHelper
import _thread
import Adafruit_DHT
from GPIO.NixieTube import Yang4
import time
import datetime
import RPi.GPIO as GPIO
import sys
sys.path.append('..')


def WriteToDb(timenow, year, month, day, hour, temp, humi):
    smartHomeDb = MySqlHelper(&quot;SmartHome&quot;)
    smartHomeDb.executeSql(&quot;INSERT INTO DailyMonitor (DateTime,Year,Month,Day,Hour,Temperature,Humidity) VALUES ('{0}',{1},{2},{3},{4},{5},{6})&quot;.format(
        timenow, year, month, day, hour, temp, humi))


y4 = Yang4(35, 16, 22, 32, 31, 36, 38, 33, 37, 12, 18, 40)
delay = 600

# 已经写入数据库的小时标识，插入数据的同时，修改为下一个小时，用于比较是否需要写入
hasWriteToDbHour = datetime.datetime.now().hour

while(True):
    # time
    timenow = datetime.datetime.now()

    for i in range(0, delay):
        y4.Display(str(timenow.year))
        time.sleep(0.005)

    for i in range(0, delay):
        y4.Display(str(timenow.month).zfill(
            2)+'.'+str(timenow.day).zfill(2))
        time.sleep(0.005)

    for i in range(0, delay):
        y4.Display(str(timenow.hour).zfill(
            2)+'.'+str(timenow.minute).zfill(2))
        time.sleep(0.005)

    y4.Display('....')

    # Use read_retry method. This will retry up to 15 times to
    # get a sensor reading (waiting 2 seconds between each retry).
    # this is bcm code
    humidity, temperature = Adafruit_DHT.read_retry(Adafruit_DHT.DHT11, 4)
    print('time:{0},humidity:{1}%,temperature:{2}*C'.format(
        datetime.datetime.now(), humidity, temperature))

    # 异步将数据写入mysql
    if hasWriteToDbHour == timenow.hour:
        _thread.start_new_thread(WriteToDb, (timenow, timenow.year,
                                             timenow.month, timenow.day, timenow.hour, temperature, humidity))
        if hasWriteToDbHour == 23:
            hasWriteToDbHour = 0
        else:
            hasWriteToDbHour = hasWriteToDbHour + 1

    if temperature is not None:
        for i in range(0, delay):
            y4.Display('{0:0.1f}C'.format(temperature))
            time.sleep(0.005)

    if humidity is not None:
        for i in range(0, delay):
            y4.Display('H{0:0.1f}'.format(humidity))
            time.sleep(0.005)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码的功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;循环获取温湿度，判断一小时写入数据库一次&lt;/li&gt;
&lt;li&gt;数码管循环展示年/月日/时分/温度/湿度&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;树莓派运行&quot;&gt;【树莓派运行】&lt;/h2&gt;
&lt;p&gt;我们通过SSH远程连接到树莓派的终端&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008215011776-883090988.png&quot; alt=&quot;PI&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过FTP将我们的项目上传到树莓派服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008215235430-232761352.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用后台进程的方式运行我们的主脚本(关闭终端进程不会退出）&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;nohup python SmartHomeScreen.py&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008215342568-1506271846.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样我们的信息采集脚本就一直在工作中了，每小时会采集一次温湿度，并存储到数据库表中。隔几秒采集的数据同时实时显示在数码管上，我们抬头便可以看到当前温湿度。&lt;/p&gt;
&lt;p&gt;效果图（一张图用到底）:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008220229990-678946534.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;【总结】&lt;/h2&gt;
&lt;p&gt;通过本节内容，我们实现了利用树莓派的GPIO控制共阳数码管展示温湿度，并已经实现了我们开始规划好的温湿度面板。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;后续章节我们会介绍利用我们采集的24小时温湿度数据制作温湿度报表... 效果预热：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/998608/201910/998608-20191008215717234-1461627393.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;源码地址&quot;&gt;【源码地址】&lt;/h2&gt;
&lt;p&gt;Github：&lt;a href=&quot;https://github.com/sevenTiny/SevenTiny.SmartHome&quot;&gt;&lt;span&gt;https://github.com/sevenTiny/SevenTiny.SmartHome&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 00:32:00 +0000</pubDate>
<dc:creator>7tiny</dc:creator>
<og:description>【前言】 一个热爱技术的人一定向往有一个科技感十足的环境吧，那何不亲自实践一下属于技术人的座右铭：“技术改变世界”。 就让我们一步步动手搭建一个属于自己的“智能家居平台”吧（不要对这个名词抬杠啦，技术</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/7tiny/p/12196486.html</dc:identifier>
</item>
<item>
<title>【一起学源码-微服务】Hystrix 源码三：Hystrix核心流程：Hystix降级、熔断等原理剖析 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12204064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12204064.html</guid>
<description>&lt;h3 id=&quot;说明&quot;&gt;说明&lt;/h3&gt;
&lt;p&gt;原创不易，如若转载 请标明来源！&lt;/p&gt;
&lt;p&gt;欢迎关注本人微信公众号：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;壹枝花算不算浪漫&lt;/a&gt;&lt;br/&gt;更多内容也可查看本人博客：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;一枝花算不算浪漫&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;h4 id=&quot;前情回顾&quot;&gt;前情回顾&lt;/h4&gt;
&lt;p&gt;上一讲我们讲解了Hystrix在配合feign的过程中，一个正常的请求逻辑该怎样处理，这里涉及到线程池的创建、HystrixCommand的执行等逻辑。&lt;/p&gt;
&lt;p&gt;如图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200117072350431-1003598632.png&quot; alt=&quot;Hystrix线程池创建过程及线程调用原理.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高清大图：https://www.processon.com/view/link/5e1c128ce4b0169fb51ce77e&lt;/p&gt;
&lt;h4 id=&quot;本讲目录&quot;&gt;本讲目录&lt;/h4&gt;
&lt;p&gt;这一讲开始讲解Hystrix的看家本领：熔断+降级。&lt;br/&gt;熔断功能是Hystrix最核心的组件，当然也是最复杂的一块。&lt;br/&gt;源码中细节太多，本讲我们主要还是专注于它的设计思想去学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;HystrixCircuitBreaker初始化过程&lt;/li&gt;
&lt;li&gt;Hystrix熔断机制(CLOSED/OPEN/HALF_OPEN)&lt;/li&gt;
&lt;li&gt;fallback降级机制&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;h4 id=&quot;hystrixcircuitbreaker初始化过程&quot;&gt;HystrixCircuitBreaker初始化过程&lt;/h4&gt;
&lt;p&gt;我们还是会以&lt;code&gt;AbstractCommand&lt;/code&gt;为突破口，这里继续看它的构造函数，其中里面有初始化熔断器&lt;code&gt;initCircuitBreaker()&lt;/code&gt;的过程，具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {

    private static HystrixCircuitBreaker initCircuitBreaker(boolean enabled, HystrixCircuitBreaker fromConstructor,
                                                            HystrixCommandGroupKey groupKey, HystrixCommandKey commandKey,
                                                            HystrixCommandProperties properties, HystrixCommandMetrics metrics) {
        if (enabled) {
            if (fromConstructor == null) {
                // 构建默认的HystrixCircuitBreaker
                return HystrixCircuitBreaker.Factory.getInstance(commandKey, groupKey, properties, metrics);
            } else {
                return fromConstructor;
            }
        } else {
            return new NoOpCircuitBreaker();
        }
    }
}


public interface HystrixCircuitBreaker {
    public static HystrixCircuitBreaker getInstance(HystrixCommandKey key, HystrixCommandGroupKey group, HystrixCommandProperties properties, HystrixCommandMetrics metrics) {
        // circuitBreakersByCommand是一个map，key为commandKey，也就是FeignClient中定义的方法名
        // 类似于ServiceAFeignClient.sayHello(String)
        HystrixCircuitBreaker previouslyCached = circuitBreakersByCommand.get(key.name());
        if (previouslyCached != null) {
            return previouslyCached;
        }

        // 每个commandKey都对应着自己的熔断器，如果没有则会构造一个HystrixCircuitBreaker
        HystrixCircuitBreaker cbForCommand = circuitBreakersByCommand.putIfAbsent(key.name(), new HystrixCircuitBreakerImpl(key, group, properties, metrics));
        if (cbForCommand == null) {
            return circuitBreakersByCommand.get(key.name());
        } else {
            return cbForCommand;
        }
    }

    class HystrixCircuitBreakerImpl implements HystrixCircuitBreaker {
        private final HystrixCommandProperties properties;
        private final HystrixCommandMetrics metrics;

        private Subscription subscribeToStream() {
            // 对HealthCounts进行订阅
            // HealthCounts中包含 总请求次数、总失败次数、失败率
            // HealthCounts 统计数据有变化则会回调到这里来
            return metrics.getHealthCountsStream()
                    .observe()
                    .subscribe(new Subscriber&amp;lt;HealthCounts&amp;gt;() {
                        @Override
                        public void onCompleted() {

                        }

                        @Override
                        public void onError(Throwable e) {

                        }

                        // 判断是否要降级的核心逻辑
                        @Override
                        public void onNext(HealthCounts hc) {
                            // 一个时间窗口(默认10s钟)总请求次数是否大于circuitBreakerRequestVolumeThreshold 默认为20s
                            if (hc.getTotalRequests() &amp;lt; properties.circuitBreakerRequestVolumeThreshold().get()) {
                                
                            } else {
                                // 错误率(总错误次数/总请求次数)小于circuitBreakerErrorThresholdPercentage(默认50%)
                                if (hc.getErrorPercentage() &amp;lt; properties.circuitBreakerErrorThresholdPercentage().get()) {

                                } else {
                                    // 反之，熔断状态将从CLOSED变为OPEN，且circuitOpened==&amp;gt;当前时间戳
                                    if (status.compareAndSet(Status.CLOSED, Status.OPEN)) {
                                        circuitOpened.set(System.currentTimeMillis());
                                    }
                                }
                            }
                        }
                    });
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就是熔断器初始化过程，这里面做了几件事：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每个commandKey都有自己的一个熔断器&lt;br/&gt;commandKey表现形式为：ServiceAFeignClient#sayHello(String)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果commandKey不存在熔断器，则构建默认熔断器&lt;br/&gt;默认熔断器会对HealthCounts进行订阅。HealthCounts中包含时间窗口内(默认10s钟)请求的总次数、失败次数、失败率&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;HealthCounts中统计数据有变化则会回调subscribe.onNext()方法进行熔断开启判断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;熔断开启条件：&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;时间窗口内(默认10s钟)总请求次数大于20次&lt;/li&gt;
&lt;li&gt;时间窗口内(默认10s钟)失败率大于50%&lt;/li&gt;
&lt;li&gt;满足上述两个条件后熔断器状态从CLOSED变成OPEN&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;熔断器在第一次请求时会初始化&lt;code&gt;AbtractCommand&lt;/code&gt;，同时也会创建对应commandKey的熔断器 ，熔断器默认都是关闭的(可配置为强制开启)，只有满足触发条件才会被开启。下面就一起来看下熔断、半开等状态是如何触发的吧。&lt;/p&gt;
&lt;h4 id=&quot;hystrix熔断机制closedopenhalf_open&quot;&gt;Hystrix熔断机制(CLOSED/OPEN/HALF_OPEN)&lt;/h4&gt;
&lt;p&gt;这里我们以&lt;code&gt;AbstractCommand.applyHystrixSemantics()&lt;/code&gt; 为入口，一步步往下探究，这个方法在上一讲已经提到过，一个正常的Feign请求都会调用此方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    private Observable&amp;lt;R&amp;gt; applyHystrixSemantics(final AbstractCommand&amp;lt;R&amp;gt; _cmd) {
        // 如果熔断了，这这里返回为false
        // 这里也包含HALF_OPEN逻辑
        if (circuitBreaker.attemptExecution()) {
            final Action1&amp;lt;Throwable&amp;gt; markExceptionThrown = new Action1&amp;lt;Throwable&amp;gt;() {
                @Override
                public void call(Throwable t) {
                    eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);
                }
            };

            if (executionSemaphore.tryAcquire()) {
                try {
                    executionResult = executionResult.setInvocationStartTime(System.currentTimeMillis());
                    return executeCommandAndObserve(_cmd)
                            .doOnError(markExceptionThrown)
                            .doOnTerminate(singleSemaphoreRelease)
                            .doOnUnsubscribe(singleSemaphoreRelease);
                } catch (RuntimeException e) {
                    return Observable.error(e);
                }
            } else {
                return handleSemaphoreRejectionViaFallback();
            }
        } else {
            return handleShortCircuitViaFallback();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;circuitBreaker.attemptExecution()&lt;/code&gt; 这个逻辑就是判断，如果熔断了，那么返回false。而且这里还包含&lt;code&gt;HALF_OPEN&lt;/code&gt;的逻辑，我们先看如何触发熔断的，这个后面再接着看。&lt;/p&gt;
&lt;p&gt;接着往下跟进&lt;code&gt;executeCommandAndObserve()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    private Observable&amp;lt;R&amp;gt; executeCommandAndObserve(final AbstractCommand&amp;lt;R&amp;gt; _cmd) {
        final HystrixRequestContext currentRequestContext = HystrixRequestContext.getContextForCurrentThread();

        // 省略部分代码...

        // 运行过程中，出现异常等都会进入此回调函数
        final Func1&amp;lt;Throwable, Observable&amp;lt;R&amp;gt;&amp;gt; handleFallback = new Func1&amp;lt;Throwable, Observable&amp;lt;R&amp;gt;&amp;gt;() {
            @Override
            public Observable&amp;lt;R&amp;gt; call(Throwable t) {
                circuitBreaker.markNonSuccess();
                Exception e = getExceptionFromThrowable(t);
                executionResult = executionResult.setExecutionException(e);
                if (e instanceof RejectedExecutionException) {
                    return handleThreadPoolRejectionViaFallback(e);
                } else if (t instanceof HystrixTimeoutException) {
                    return handleTimeoutViaFallback();
                } else if (t instanceof HystrixBadRequestException) {
                    return handleBadRequestByEmittingError(e);
                } else {
                    /*
                     * Treat HystrixBadRequestException from ExecutionHook like a plain HystrixBadRequestException.
                     */
                    if (e instanceof HystrixBadRequestException) {
                        eventNotifier.markEvent(HystrixEventType.BAD_REQUEST, commandKey);
                        return Observable.error(e);
                    }

                    return handleFailureViaFallback(e);
                }
            }
        };

        Observable&amp;lt;R&amp;gt; execution;
        if (properties.executionTimeoutEnabled().get()) {
            // 这里创建一个 HystrixObservableTimeoutOperator
            execution = executeCommandWithSpecifiedIsolation(_cmd)
                    .lift(new HystrixObservableTimeoutOperator&amp;lt;R&amp;gt;(_cmd));
        } else {
            execution = executeCommandWithSpecifiedIsolation(_cmd);
        }

        return execution.doOnNext(markEmits)
                .doOnCompleted(markOnCompleted)
                .onErrorResumeNext(handleFallback)
                .doOnEach(setRequestContext);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们服务调用中出现异常都会进入&lt;code&gt;handleFallback()&lt;/code&gt;中，里面的方法我们就不继续跟入了，猜测里面会有更新&lt;code&gt;HealthCounts&lt;/code&gt;中的属性，然后触发 &lt;code&gt;HystrixCircuitBreaker&lt;/code&gt;中的&lt;code&gt;onNext()&lt;/code&gt;方法，当满足熔断条件时 则会将熔断状态从&lt;code&gt;CLOSED&lt;/code&gt;变成&lt;code&gt;OPEN&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里我们会跟进下&lt;code&gt;HystrixObservableTimeoutOperator&lt;/code&gt; 代码，这个是对我们执行过程中判断是否超时。&lt;br/&gt;上面代码中，执行&lt;code&gt;executeCommandWithSpecifiedIsolation()&lt;/code&gt; 方法时也会创建一个超时监视器：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static class HystrixObservableTimeoutOperator&amp;lt;R&amp;gt; implements Operator&amp;lt;R, R&amp;gt; {

    final AbstractCommand&amp;lt;R&amp;gt; originalCommand;

    public HystrixObservableTimeoutOperator(final AbstractCommand&amp;lt;R&amp;gt; originalCommand) {
        this.originalCommand = originalCommand;
    }

    @Override
    public Subscriber&amp;lt;? super R&amp;gt; call(final Subscriber&amp;lt;? super R&amp;gt; child) {
        TimerListener listener = new TimerListener() {

            @Override
            public void tick() {
                // 判断command的timeOut状态，如果是未执行状态，则更新为已超时
                if (originalCommand.isCommandTimedOut.compareAndSet(TimedOutStatus.NOT_EXECUTED, TimedOutStatus.TIMED_OUT)) {
                    originalCommand.eventNotifier.markEvent(HystrixEventType.TIMEOUT, originalCommand.commandKey);
                    s.unsubscribe();

                    final HystrixContextRunnable timeoutRunnable = new HystrixContextRunnable(originalCommand.concurrencyStrategy, hystrixRequestContext, new Runnable() {
                        @Override
                        public void run() {
                            child.onError(new HystrixTimeoutException());
                        }
                    });


                    timeoutRunnable.run();
                }
            }

            @Override
            public int getIntervalTimeInMilliseconds() {
                return originalCommand.properties.executionTimeoutInMilliseconds().get();
            }
        };

        final Reference&amp;lt;TimerListener&amp;gt; tl = HystrixTimer.getInstance().addTimerListener(listener);
        originalCommand.timeoutTimer.set(tl);

        // 省略部分代码...
        s.add(parent);

        return parent;
    }
}

public class HystrixTimer {
    public Reference&amp;lt;TimerListener&amp;gt; addTimerListener(final TimerListener listener) {
        startThreadIfNeeded();
        Runnable r = new Runnable() {
            @Override
            public void run() {
                try {
                    // 执行上面的tick方法，改变command timeout状态
                    listener.tick();
                } catch (Exception e) {
                    logger.error(&quot;Failed while ticking TimerListener&quot;, e);
                }
            }
        };

        // 执行调度任务，延迟加载，延迟时间和调度时间默认都为1s钟
        // 这里使用线程池，coreSize=cpu核心数 maxSize为Integer.Max
        ScheduledFuture&amp;lt;?&amp;gt; f = executor.get().getThreadPool().scheduleAtFixedRate(r, listener.getIntervalTimeInMilliseconds(), listener.getIntervalTimeInMilliseconds(), TimeUnit.MILLISECONDS);
        return new TimerReference(listener, f);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面核心业务是起一个调度任务，默认每秒钟执行一次，然后调用&lt;code&gt;tick()&lt;/code&gt;方法，如果当前command状态还是&lt;code&gt;NOT_EXECUTED&lt;/code&gt;状态，那么将command状态改为&lt;code&gt;TIMED_OUT&lt;/code&gt; 。此时会进入到之前的&lt;code&gt;handleFallback&lt;/code&gt;回调函数中，这里又会更新&lt;code&gt;HealthCounts&lt;/code&gt;中的数据，对应的触发之前熔断的判断条件：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected HystrixCircuitBreakerImpl(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, final HystrixCommandProperties properties, HystrixCommandMetrics metrics) {
  this.properties = properties;
  this.metrics = metrics;

  //On a timer, this will set the circuit between OPEN/CLOSED as command executions occur
  Subscription s = subscribeToStream();
  activeSubscription.set(s);
}

private Subscription subscribeToStream() {
  //这里会在每次执行onNext()事件的时候来评估是否需要打开或者关闭断路器
  return metrics.getHealthCountsStream()
    .observe()
    .subscribe(new Subscriber&amp;lt;HealthCounts&amp;gt;() {
      @Override
      public void onCompleted() {

      }

      @Override
      public void onError(Throwable e) {

      }

      @Override
      public void onNext(HealthCounts hc) {
        //首先校验的时在时间窗范围内的请求次数，如果低于阈值（默认是20），不做处理，如果高于阈值，则去判断接口请求的错误率
        if (hc.getTotalRequests() &amp;lt; properties.circuitBreakerRequestVolumeThreshold().get()) {           // 如果没有超过统计阈值的最低窗口值，就没有必要去改变断路器的状态
          // 当前如果断路器是关闭的，那么就保持关闭状态无需更改;
          // 如果断路器状态为半开状态，需要等待直到有成功的命令执行；
          // 如果断路器是打开状态,需要等待休眠窗口过期。
        } else {
          //判断接口请求的错误率（阈值默认是50），如果高于这个值，则断路器打开
          if (hc.getErrorPercentage() &amp;lt; properties.circuitBreakerErrorThresholdPercentage().get()) {
    
            // 如果当前请求的错误率小于断路器设置的容错率百分比，也不会拦截请求
          } else {
            // 如果当前错误率太高则打开断路器
            if (status.compareAndSet(Status.CLOSED, Status.OPEN)) {
              circuitOpened.set(System.currentTimeMillis());
            }
          }
        }
      }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果符合熔断条件，那么command熔断状态就会变为&lt;code&gt;OPEN&lt;/code&gt;，此时熔断器打开。&lt;/p&gt;
&lt;p&gt;如果我们command执行成功，那么就会清理掉这个timeout timer schedule任务。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    private void handleCommandEnd(boolean commandExecutionStarted) {
        Reference&amp;lt;TimerListener&amp;gt; tl = timeoutTimer.get();
        // 如果timeOutTimer不为空，这里则clear一下
        // clear会关闭启动的调度任务
        if (tl != null) {
            tl.clear();
        }

        long userThreadLatency = System.currentTimeMillis() - commandStartTimestamp;
        executionResult = executionResult.markUserThreadCompletion((int) userThreadLatency);
        if (executionResultAtTimeOfCancellation == null) {
            // metrics统计数据
            metrics.markCommandDone(executionResult, commandKey, threadPoolKey, commandExecutionStarted);
        } else {
            metrics.markCommandDone(executionResultAtTimeOfCancellation, commandKey, threadPoolKey, commandExecutionStarted);
        }

        if (endCurrentThreadExecutingCommand != null) {
            endCurrentThreadExecutingCommand.call();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上所属，我们已经知道了熔断开启的触发时机，那么如果一个commandKey开启了熔断，下次的请求是该如何直接降级呢？我们来看下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;abstract class AbstractCommand&amp;lt;R&amp;gt; implements HystrixInvokableInfo&amp;lt;R&amp;gt;, HystrixObservable&amp;lt;R&amp;gt; {
    private Observable&amp;lt;R&amp;gt; applyHystrixSemantics(final AbstractCommand&amp;lt;R&amp;gt; _cmd) {

        // 这个if条件就代表是否开启熔断
        if (circuitBreaker.attemptExecution()) {
            // 执行业务逻辑代码...
        } else {
            return handleShortCircuitViaFallback();
        }
    }
}

class HystrixCircuitBreakerImpl implements HystrixCircuitBreaker {
    public boolean attemptExecution() {
            // 如果熔断配置的为强制开启，那么直接返回false执行熔断逻辑
            if (properties.circuitBreakerForceOpen().get()) {
                return false;
            }
            // 如果熔断配置为强制关闭，那么永远不走熔断逻辑
            if (properties.circuitBreakerForceClosed().get()) {
                return true;
            }
            // 熔断开启时 circuitOpened设置为当前时间戳
            if (circuitOpened.get() == -1) {
                return true;
            } else {
                // 如果当前时间距离熔断小于5s钟，那么将熔断状态从OPEN改为HALF_OPEN
                if (isAfterSleepWindow()) {
                    if (status.compareAndSet(Status.OPEN, Status.HALF_OPEN)) {
                        //only the first request after sleep window should execute
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    return false;
                }
            }
        }
    }

    private boolean isAfterSleepWindow() {
        final long circuitOpenTime = circuitOpened.get();
        final long currentTime = System.currentTimeMillis();
        // circuitBreakerSleepWindowInMilliseconds 默认为5s钟
        final long sleepWindowTime = properties.circuitBreakerSleepWindowInMilliseconds().get();
        // 当前熔断距离熔断是否超过5s钟
        return currentTime &amp;gt; circuitOpenTime + sleepWindowTime;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，在&lt;code&gt;applyHystrixSemantics()&lt;/code&gt;这个核心的方法中，先判断是否熔断，如果熔断则直接走fallback逻辑。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;attemptExecution()&lt;/code&gt;判断条件中还涉及到&lt;code&gt;HALF_OPEN&lt;/code&gt;的逻辑，如果熔断开启，下一次请求的时候，会判断当前时间距离上一次时间是否超过了5s钟，如果没有超过，则会将熔断状态从&lt;code&gt;OPEN&lt;/code&gt;变为&lt;code&gt;HALF_OPEN&lt;/code&gt;，此时会放一个请求按照正常逻辑去执行：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;执行失败，熔断状态又会从&lt;code&gt;HALF_OPEN&lt;/code&gt;变成&lt;code&gt;OPEN&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;执行成功，熔断状态从&lt;code&gt;HALF_OPEN&lt;/code&gt;变成&lt;code&gt;CLOSED&lt;/code&gt;，并清除熔断相关设置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;执行成功后代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class HystrixCircuitBreakerImpl implements HystrixCircuitBreaker {
    public void markSuccess() {
        if (status.compareAndSet(Status.HALF_OPEN, Status.CLOSED)) {
            //This thread wins the race to close the circuit - it resets the stream to start it over from 0
            metrics.resetStream();
            Subscription previousSubscription = activeSubscription.get();
            if (previousSubscription != null) {
                previousSubscription.unsubscribe();
            }
            Subscription newSubscription = subscribeToStream();
            activeSubscription.set(newSubscription);
            circuitOpened.set(-1L);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面对整个熔断的状态：CLOSED、OPEN、HALF_OPEN梳理的已经很清楚了，下面看看降级是该如何处理的吧。&lt;/p&gt;
&lt;h4 id=&quot;fallback降级机制&quot;&gt;fallback降级机制&lt;/h4&gt;
&lt;p&gt;上面已经讲解了Hystrix 熔断开启的机制等内容，这里主要是说如果一个请求失败(线程池拒绝、超时、badRequest等)，那么Hystrix是如何执行降级的呢？&lt;/p&gt;
&lt;p&gt;还是回到我们最初的代码 &lt;code&gt;HystrixInvocationHandler&lt;/code&gt;类中，看看其&lt;code&gt;invoke()&lt;/code&gt;方法中的&lt;code&gt;getFallback&lt;/code&gt;回调函数：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected Object getFallback() {
    if (fallbackFactory == null) {
      return super.getFallback();
    }
    try {
      // 通过我们配置好的fallbackFactory找到对应的FeignClient，这里是获取ServiceAFeignClient
      Object fallback = fallbackFactory.create(getExecutionException());
      // fallbackMap中key为ServiceAFeignClient.sayHello(Integer)
      // 获取具体的降级method方法
      Object result = fallbackMethodMap.get(method).invoke(fallback, args);
      if (isReturnsHystrixCommand(method)) {
        return ((HystrixCommand) result).execute();
      } else if (isReturnsObservable(method)) {
        // Create a cold Observable
        return ((Observable) result).toBlocking().first();
      } else if (isReturnsSingle(method)) {
        // Create a cold Observable as a Single
        return ((Single) result).toObservable().toBlocking().first();
      } else if (isReturnsCompletable(method)) {
        ((Completable) result).await();
        return null;
      } else {
        return result;
      }
    } catch (IllegalAccessException e) {
      // shouldn't happen as method is public due to being an interface
      throw new AssertionError(e);
    } catch (InvocationTargetException e) {
      // Exceptions on fallback are tossed by Hystrix
      throw new AssertionError(e.getCause());
    }
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里很简单，其实就是先获取到我们自己在FallbackFactory中配置的的降级方法，然后执行降级逻辑。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这一讲核心逻辑主要是Hystrix熔断状态的变化，主要是CLOSED、OPEN、HALF_OPEN几种状态触发的时间，互相转变的流程，以及执行降级逻辑的原理。&lt;/p&gt;
&lt;p&gt;我们仍然是用一个流程图来总结一下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200117072352795-509644251.png&quot; alt=&quot;Hystrix熔断_降级机制原理.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高清大图链接：&lt;br/&gt;https://www.processon.com/view/link/5e1ee0afe4b0c62462aae684&lt;/p&gt;
&lt;p&gt;(点击原文可以直接查看大图哦😄)&lt;/p&gt;
&lt;h3 id=&quot;申明&quot;&gt;申明&lt;/h3&gt;
&lt;p&gt;本文章首发自本人博客：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;https://www.cnblogs.com/wang-meng&lt;/a&gt; 和公众号：&lt;strong&gt;壹枝花算不算浪漫&lt;/strong&gt;，如若转载请标明来源!&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴可关注个人公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200117072353440-905552655.jpg&quot; alt=&quot;WechatIMG33.jpeg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jan 2020 23:24:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>说明 原创不易，如若转载 请标明来源！ 欢迎关注本人微信公众号：[壹枝花算不算浪漫][1] 更多内容也可查看本人博客：[一枝花算不算浪漫][2] 前言 前情回顾 上一讲我们讲解了Hystrix在配合f</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12204064.html</dc:identifier>
</item>
<item>
<title>Spring Boot 入门（十一）：集成 WebSocket, 实时显示系统日志 - 光头才能强</title>
<link>http://www.cnblogs.com/dz-boss/p/12203735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dz-boss/p/12203735.html</guid>
<description>&lt;p&gt;以前面的博客为基础，最近一篇为&lt;a class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/dz-boss/p/12190065.html&quot;&gt;Spring Boot 入门（十）：集成Redis哨兵模式，实现Mybatis二级缓存&lt;/a&gt;。本篇博客主要介绍了Spring Boot集成 Web Socket进行日志的推送，并实时显示在页面上。&lt;/p&gt;

&lt;p&gt;第一个jar包是websocket的，第二个jar包是关于环形队列的jar包，本案例是通过本地队列存储日志。有条件的话，最好通过中间件存储（eg：redis，mq……）。通过本地队列存储日志会存在日志丢失的情况，且日志量太大，会把页面卡死。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;begin web socket&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-websocket&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.lmax&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;disruptor&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3.4.2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;end web socket&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;（1）.在logback中增加监听器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1147108/202001/1147108-20200116230129759-23658074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并根据logback编写相应的监听器ProcessLogFilter&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProcessLogFilter &lt;span&gt;extends&lt;/span&gt; Filter&amp;lt;ILoggingEvent&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; FilterReply decide(ILoggingEvent event) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         LoggerMessage loggerMessage = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerMessage(
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                event.getMessage()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 , DateFormat.getDateTimeInstance().format(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date(event.getTimeStamp())),
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                event.getThreadName(),
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                event.getLoggerName(),
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                event.getLevel().levelStr
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        LoggerDisruptorQueue.publishEvent(loggerMessage);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; FilterReply.ACCEPT;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; } 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该监听器将监听的日志消息推送到本地消息队列中，然后页面通过 Web Socket 去此队列获取日志信息，从而在页面显示&lt;/p&gt;
&lt;p&gt;（2）.编写日志处理器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进程日志事件内容载体&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;@NoArgsConstructor
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;@AllArgsConstructor
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggerEvent {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; LoggerMessage log;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt; * Content :进程日志事件工厂类
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoggerEventFactory &lt;span&gt;implements&lt;/span&gt; EventFactory&amp;lt;LoggerEvent&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; LoggerEvent newInstance() {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerEvent();
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt; * Content :进程日志事件处理器
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoggerEventHandler &lt;span&gt;implements&lt;/span&gt; EventHandler&amp;lt;LoggerEvent&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpMessagingTemplate messagingTemplate;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onEvent(LoggerEvent stringEvent, &lt;span&gt;long&lt;/span&gt; l, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; b) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         messagingTemplate.convertAndSend(&quot;/topic/pullLogger&quot;&lt;span&gt;, stringEvent.getLog());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;日志事件处理器的作用是监听本地环形队列中的消息，如果有消息，就会将这些消息推送到 Socket 管道中&lt;/p&gt;
&lt;p&gt;（3）.编写页面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;http-equiv&lt;/span&gt;&lt;span&gt;=&quot;X-UA-Compatible&quot;&lt;/span&gt;&lt;span&gt; content&lt;/span&gt;&lt;span&gt;=&quot;IE=edge&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;欢迎页&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&lt;/span&gt;&lt;span&gt; name&lt;/span&gt;&lt;span&gt;=&quot;viewport&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;plugins/jQuery/jquery-2.2.3.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/websocket/sockjs.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/websocket/stomp.min.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;panel panel-default&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jvm进程内的日志&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;h1&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;openSocket()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;开启日志&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;button &lt;/span&gt;&lt;span&gt;onclick&lt;/span&gt;&lt;span&gt;=&quot;closeSocket()&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;关闭日志&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;button&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;log-container&quot;&lt;/span&gt;&lt;span&gt; style&lt;/span&gt;&lt;span&gt;=&quot;height: 600px; overflow-y: scroll; background: #333; color: #aaa; padding: 10px;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; stompClient &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    $(document).ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        openSocket();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    });
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; openSocket() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stompClient &lt;/span&gt;&lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; socket &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SockJS(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:8080/websocket?token=kl&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            stompClient &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; Stomp.over(socket);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            stompClient.connect({token: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (frame) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                stompClient.subscribe(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/topic/pullLogger&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; content &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; JSON.parse(event.body);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#log-container div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;font color='red'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; content.timestamp &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/font&amp;gt;|&amp;lt;font color='highlight'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; content.level &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/font&amp;gt; |&amp;lt;font color='green'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; content.threadName &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/font&amp;gt;| &amp;lt;font color='boldMagenta'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; content.className &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/font&amp;gt;|&amp;lt;font color='cyan'&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt; content.body &lt;/span&gt;&lt;span&gt;+&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/font&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).append(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#log-container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).scrollTop($(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#log-container div&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height() &lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt; $(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#log-container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).height());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                }, {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    token: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kltoen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                });
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; closeSocket() {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (stompClient &lt;/span&gt;&lt;span&gt;!=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            stompClient.disconnect();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            stompClient &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;页面链接web Socket服务器，如果有消息，就能获取&lt;/p&gt;
&lt;p&gt;（4）.其他辅助类&lt;/p&gt;
&lt;p&gt;环形本地队列类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.learn.hello.system.common.queue;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learn.hello.modules.entity.LoggerMessage;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learn.hello.system.common.event.LoggerEvent;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learn.hello.system.common.event.LoggerEventFactory;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.learn.hello.system.common.event.LoggerEventHandler;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lmax.disruptor.RingBuffer;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.lmax.disruptor.dsl.Disruptor;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executor;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.Executors;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt; * Content :Disruptor 环形队列
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggerDisruptorQueue {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Executor executor =&lt;span&gt; Executors.newCachedThreadPool();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The factory for the event&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LoggerEventFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoggerEventFactory();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Specify the size of the ring buffer, must be power of 2.&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; bufferSize = 2 * 1024&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Construct the Disruptor&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; Disruptor&amp;lt;LoggerEvent&amp;gt; disruptor = &lt;span&gt;new&lt;/span&gt; Disruptor&amp;lt;&amp;gt;&lt;span&gt;(factory, bufferSize, executor);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    ;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; RingBuffer&amp;lt;LoggerEvent&amp;gt;&lt;span&gt; ringBuffer;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    LoggerDisruptorQueue(LoggerEventHandler eventHandler) {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        disruptor.handleEventsWith(eventHandler);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.ringBuffer =&lt;span&gt; disruptor.getRingBuffer();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;        disruptor.start();
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; publishEvent(LoggerMessage log) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; sequence = ringBuffer.next();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Grab the next sequence&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             LoggerEvent event = ringBuffer.get(sequence); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get the entry in the Disruptor
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for the sequence&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;             event.setLog(log);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Fill with data&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            ringBuffer.publish(sequence);
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;消息实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.learn.hello.modules.entity;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.AllArgsConstructor;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.Data;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.NoArgsConstructor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 日志实体类&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@Data
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@AllArgsConstructor
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;@NoArgsConstructor
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LoggerMessage {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String body;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String timestamp;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String threadName;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String className;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String level;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1147108/202001/1147108-20200116231331668-51352122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 页面中的颜色可以自行设置&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jan 2020 15:19:00 +0000</pubDate>
<dc:creator>光头才能强</dc:creator>
<og:description>以前面的博客为基础，最近一篇为Spring Boot 入门（十）：集成Redis哨兵模式，实现Mybatis二级缓存。本篇博客主要介绍了Spring Boot集成 Web Socket进行日志的推送，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dz-boss/p/12203735.html</dc:identifier>
</item>
<item>
<title>.net Core 使用IHttpClientFactory请求 - 晨曦001</title>
<link>http://www.cnblogs.com/chenxi001/p/12203731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenxi001/p/12203731.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;       &lt;/strong&gt;&lt;/span&gt; 导读：本文已添加在&lt;span&gt;晨曦微服务之旅&lt;/span&gt;，现在自己在尝试微服务架构，一边学边做项目快速的进入状态。当然在学习的过程中会将自己学到的知识进行分享。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、为什么不用HttpClient&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; &lt;/strong&gt;  1.HttPClient使用完之后不会立即关闭开启网络连接时会占用底层socket资源，但在HttpClient调用其本身的Dispose方法时，并不能立刻释放该资源&lt;/p&gt;
&lt;p&gt;         2.如果频繁的使用HttpClient,频繁的打开链接，关闭链接消耗就会很大。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/span&gt; &lt;strong&gt; &lt;/strong&gt; &lt;span&gt;1.我们可以延长HttpClient的生命周期，比如对其建一个静态的对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HttpClient Client = &lt;span&gt;new&lt;/span&gt; HttpClient();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;          2.或者使用单例模式，至于你使用哪一种单例模式就看你自己了，这里就不细将了。因为这样感觉起来不是很舒服&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、HttpClientFactory&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/span&gt; &lt;strong&gt; &lt;/strong&gt;1.在.NET Core 2.1版本之后引入的 HttpClientFactory解决了HttpClient的所有痛点。有了 HttpClientFactory，我们不需要关心如何创建HttpClient，又如何释放它。通过它可以创建具有特定业务的HttpClient，而且可以很友好的和 DI 容器结合使用，更为灵活。&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;　　  2.HttpClientFactory 创建的HttpClient，也即是HttpClientHandler，只是这些个HttpClient被放到了“池子”中，工厂每次在create的时候会自动判断是新建还是复用。(默认生命周期为2min，默认的生命周期可以修改）
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   //修改默认的生命周期&lt;br/&gt;services.AddHttpClient()
  .SetHandlerLifetime(TimeSpan.FromMinutes(&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、HttpClientFactory的使用 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    一、第一种使用方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-2&quot;&gt;在Startup.cs中进行注册
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册http请求服务&lt;/span&gt;
            services.AddHttpClient();
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;         2.Httphelper请求辅助类中使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 注入http请求
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHttpClientFactory httpClientFactory;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpHelp(IHttpClientFactory _httpClientFactory)
        {
            httpClientFactory &lt;/span&gt;=&lt;span&gt; _httpClientFactory;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;summary&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get请求数据
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;para&amp;gt;最终以url参数的方式提交&amp;lt;/para&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;/summary&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;param name=&quot;parameters&quot;&amp;gt;参数字典,可为空&amp;lt;/param&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;param name=&quot;requestUri&quot;&amp;gt;例如/api/Files/UploadFile&amp;lt;/param&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Get(Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; parameters, &lt;span&gt;string&lt;/span&gt; requestUri, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; token)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从工厂获取请求对象&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; client =&lt;span&gt; httpClientFactory.CreateClient();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加请求头&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(token))
            {
                client.DefaultRequestHeaders.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; token);
            }
            client.DefaultRequestHeaders.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接地址&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (parameters != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; strParam = &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, parameters.Select(o =&amp;gt; o.Key + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; o.Value));
                requestUri &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Concat(requestUri, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, strParam);
            }
            client.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uri(requestUri);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; client.GetStringAsync(requestUri).Result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;             3.然后我们在Startup.cs对相对的类进行注册就可以了使用了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      二、使用命名客户端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　  1.在Startup.cs中进行注册，&lt;span&gt;&lt;span&gt;&lt;span&gt;这个注册可以存在多个&lt;/span&gt;。以创建名字区分&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
services.AddHttpClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, c =&amp;gt;&lt;span&gt;
{
    c.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://xxxxxxx.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Github API versioning&lt;/span&gt;
    c.DefaultRequestHeaders.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Github requires a user-agent&lt;/span&gt;
    c.DefaultRequestHeaders.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;asfasfasdsgdsfsdfsdafasfas&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;           2.使用方式和上面的一样只要&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 注入http请求
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHttpClientFactory httpClientFactory;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpHelp(IHttpClientFactory _httpClientFactory)
        {
            httpClientFactory &lt;/span&gt;=&lt;span&gt; _httpClientFactory;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;summary&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Get请求数据
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;para&amp;gt;最终以url参数的方式提交&amp;lt;/para&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;/summary&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;param name=&quot;parameters&quot;&amp;gt;参数字典,可为空&amp;lt;/param&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;param name=&quot;requestUri&quot;&amp;gt;例如/api/Files/UploadFile&amp;lt;/param&amp;gt;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Get(Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; parameters, &lt;span&gt;string&lt;/span&gt; requestUri, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; token)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从工厂获取请求对象   声明自己创建哪一个httpClient客户端&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; client = httpClientFactory.CreateClient(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;github&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加请求头&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(token))
            {
                client.DefaultRequestHeaders.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; token);
            }
            client.DefaultRequestHeaders.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拼接地址&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (parameters != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; strParam = &lt;span&gt;string&lt;/span&gt;.Join(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, parameters.Select(o =&amp;gt; o.Key + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; o.Value));
                requestUri &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Concat(requestUri, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;?&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, strParam);
            }
            client.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uri(requestUri);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; client.GetStringAsync(requestUri).Result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        &lt;span&gt;&lt;strong&gt; 三、类型化客户端&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;           &lt;/strong&gt;&lt;/span&gt;1.创建一个类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpClienService
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HttpClient Client { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpClienService(HttpClient client)
    {
        client.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://xxxx.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GitHub API versioning&lt;/span&gt;
        client.DefaultRequestHeaders.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxxxxxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; GitHub requires a user-agent&lt;/span&gt;
        client.DefaultRequestHeaders.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json; charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Client &lt;/span&gt;=&lt;span readability=&quot;2&quot;&gt; client;
    }&lt;p&gt;//这个下面就是编写自己方法，进行调用
}&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;             2.在Startup.cs中进行注册，&lt;span&gt;这个注册可以存在多个。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
services.AddHttpClient&amp;lt;classHttp&amp;gt;();&lt;br/&gt;//注册之后，使用依赖注入的方式进行注入，进行使用。
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 16 Jan 2020 15:17:00 +0000</pubDate>
<dc:creator>晨曦001</dc:creator>
<og:description>导读：本文已添加在晨曦微服务之旅，现在自己在尝试微服务架构，一边学边做项目快速的进入状态。当然在学习的过程中会将自己学到的知识进行分享。 一、为什么不用HttpClient 1.HttPClient使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenxi001/p/12203731.html</dc:identifier>
</item>
<item>
<title>基于Netty和SpringBoot实现一个轻量级RPC框架-Client篇 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/12203684.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/12203684.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;前置文章：&lt;/p&gt;
&lt;p&gt;前一篇文章相对简略地介绍了&lt;code&gt;RPC&lt;/code&gt;服务端的编写，而这篇博文最要介绍服务端（&lt;code&gt;Client&lt;/code&gt;）的实现。&lt;code&gt;RPC&lt;/code&gt;调用一般是面向契约编程的，而&lt;code&gt;Client&lt;/code&gt;的核心功能就是：把契约接口方法的调用抽象为使用&lt;code&gt;Netty&lt;/code&gt;向&lt;code&gt;RPC&lt;/code&gt;服务端通过私有协议发送一个请求。这里最底层的实现依赖于动态代理，因此动态代理是动态实现接口的最简单方式（如果字节码研究得比较深入，可以通过字节码编程实现接口）。需要的依赖如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;JDK1.8+&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Netty:4.1.44.Final&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SpringBoot:2.2.2.RELEASE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;动态代理的简单使用&quot;&gt;动态代理的简单使用&lt;/h2&gt;
&lt;p&gt;一般可以通过&lt;code&gt;JDK&lt;/code&gt;动态代理或者&lt;code&gt;Cglib&lt;/code&gt;的字节码增强来实现此功能，为了简单起见，不引入额外的依赖，这里选用&lt;code&gt;JDK&lt;/code&gt;动态代理。这里重新搬出前面提到的契约接口&lt;code&gt;HelloService&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface HelloService {

    String sayHello(String name);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来需要通过动态代理为此接口添加一个实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestDynamicProxy {

    public static void main(String[] args) throws Exception {
        Class&amp;lt;HelloService&amp;gt; interfaceKlass = HelloService.class;
        InvocationHandler handler = new HelloServiceImpl(interfaceKlass);
        HelloService helloService = (HelloService)
                Proxy.newProxyInstance(interfaceKlass.getClassLoader(), new Class[]{interfaceKlass}, handler);
        System.out.println(helloService.sayHello(&quot;throwable&quot;));
    }

    @RequiredArgsConstructor
    private static class HelloServiceImpl implements InvocationHandler {

        private final Class&amp;lt;?&amp;gt; interfaceKlass;

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            // 这里应该根据方法的返回值类型去决定返回结果
            return String.format(&quot;[%s#%s]方法被调用,参数列表:%s&quot;, interfaceKlass.getName(), method.getName(),
                    JSON.toJSONString(args));
        }
    }
}
// 控制台输出结果
[club.throwable.contract.HelloService#sayHello]方法被调用,参数列表:[&quot;throwable&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以确认两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;InvocationHandler&lt;/code&gt;实现后会对被代理接口生成一个动态实现类。&lt;/li&gt;
&lt;li&gt;动态实现类（接口）方法被调用的时候，实际上是调用&lt;code&gt;InvocationHandler&lt;/code&gt;对应实例的&lt;code&gt;invoke()&lt;/code&gt;方法，传入的参数就是当前方法调用的元数据。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;client端代码实现&quot;&gt;Client端代码实现&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;端需要通过动态代理为契约接口生成一个动态实现类，然后提取契约接口调用方法时候所能提供的元数据，通过这些元数据和&lt;code&gt;Netty&lt;/code&gt;客户端的支持（例如&lt;code&gt;Netty&lt;/code&gt;的&lt;code&gt;Channel&lt;/code&gt;）基于私有&lt;code&gt;RPC&lt;/code&gt;协议组装请求信息并且发送请求。这里先定义一个请求参数提取器接口&lt;code&gt;RequestArgumentExtractor&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class RequestArgumentExtractInput {

    private Class&amp;lt;?&amp;gt; interfaceKlass;

    private Method method;
}

@Data
public class RequestArgumentExtractOutput {

    private String interfaceName;

    private String methodName;

    private List&amp;lt;String&amp;gt; methodArgumentSignatures;
}

// 接口
public interface RequestArgumentExtractor {

    RequestArgumentExtractOutput extract(RequestArgumentExtractInput input);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单实现一下，解析结果添加到缓存中，实现类&lt;code&gt;DefaultRequestArgumentExtractor&lt;/code&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DefaultRequestArgumentExtractor implements RequestArgumentExtractor {

    private final ConcurrentMap&amp;lt;CacheKey, RequestArgumentExtractOutput&amp;gt; cache = Maps.newConcurrentMap();

    @Override

    public RequestArgumentExtractOutput extract(RequestArgumentExtractInput input) {
        Class&amp;lt;?&amp;gt; interfaceKlass = input.getInterfaceKlass();
        Method method = input.getMethod();
        String methodName = method.getName();
        Class&amp;lt;?&amp;gt;[] parameterTypes = method.getParameterTypes();
        return cache.computeIfAbsent(new CacheKey(interfaceKlass.getName(), methodName,
                Lists.newArrayList(parameterTypes)), x -&amp;gt; {
            RequestArgumentExtractOutput output = new RequestArgumentExtractOutput();
            output.setInterfaceName(interfaceKlass.getName());
            List&amp;lt;String&amp;gt; methodArgumentSignatures = Lists.newArrayList();
            for (Class&amp;lt;?&amp;gt; klass : parameterTypes) {
                methodArgumentSignatures.add(klass.getName());
            }
            output.setMethodArgumentSignatures(methodArgumentSignatures);
            output.setMethodName(methodName);
            return output;
        });
    }

    @RequiredArgsConstructor
    private static class CacheKey {

        private final String interfaceName;
        private final String methodName;
        private final List&amp;lt;Class&amp;lt;?&amp;gt;&amp;gt; parameterTypes;

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            CacheKey cacheKey = (CacheKey) o;
            return Objects.equals(interfaceName, cacheKey.interfaceName) &amp;amp;&amp;amp;
                    Objects.equals(methodName, cacheKey.methodName) &amp;amp;&amp;amp;
                    Objects.equals(parameterTypes, cacheKey.parameterTypes);
        }

        @Override
        public int hashCode() {
            return Objects.hash(interfaceName, methodName, parameterTypes);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在不考虑重连、断连等情况下，新增一个类&lt;code&gt;ClientChannelHolder&lt;/code&gt;用于保存&lt;code&gt;Netty&lt;/code&gt;客户端的&lt;code&gt;Channel&lt;/code&gt;实例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ClientChannelHolder {

    public static final AtomicReference&amp;lt;Channel&amp;gt; CHANNEL_REFERENCE = new AtomicReference&amp;lt;&amp;gt;();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着新增一个契约动态代理工厂（工具类）&lt;code&gt;ContractProxyFactory&lt;/code&gt;，用于为契约接口生成代理类实例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ContractProxyFactory {

    private static final RequestArgumentExtractor EXTRACTOR = new DefaultRequestArgumentExtractor();
    private static final ConcurrentMap&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; CACHE = Maps.newConcurrentMap();

    @SuppressWarnings(&quot;unchecked&quot;)
    public static &amp;lt;T&amp;gt; T ofProxy(Class&amp;lt;T&amp;gt; interfaceKlass) {
        // 缓存契约接口的代理类实例
        return (T) CACHE.computeIfAbsent(interfaceKlass, x -&amp;gt;
                Proxy.newProxyInstance(interfaceKlass.getClassLoader(), new Class[]{interfaceKlass}, (target, method, args) -&amp;gt; {
                    RequestArgumentExtractInput input = new RequestArgumentExtractInput();
                    input.setInterfaceKlass(interfaceKlass);
                    input.setMethod(method);
                    RequestArgumentExtractOutput output = EXTRACTOR.extract(input);
                    // 封装请求参数
                    RequestMessagePacket packet = new RequestMessagePacket();
                    packet.setMagicNumber(ProtocolConstant.MAGIC_NUMBER);
                    packet.setVersion(ProtocolConstant.VERSION);
                    packet.setSerialNumber(SerialNumberUtils.X.generateSerialNumber());
                    packet.setMessageType(MessageType.REQUEST);
                    packet.setInterfaceName(output.getInterfaceName());
                    packet.setMethodName(output.getMethodName());
                    packet.setMethodArgumentSignatures(output.getMethodArgumentSignatures().toArray(new String[0]));
                    packet.setMethodArguments(args);
                    Channel channel = ClientChannelHolder.CHANNEL_REFERENCE.get();
                    // 发起请求
                    channel.writeAndFlush(packet);
                    // 这里方法返回值需要进行同步处理,相对复杂,后面专门开一篇文章讲解,暂时统一返回字符串
                    // 如果契约接口的返回值类型不是字符串,这里方法返回后会抛出异常
                    return String.format(&quot;[%s#%s]调用成功,发送了[%s]到NettyServer[%s]&quot;, output.getInterfaceName(),
                            output.getMethodName(), JSON.toJSONString(packet), channel.remoteAddress());
                }));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后编写客户端&lt;code&gt;ClientApplication&lt;/code&gt;的代码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
public class ClientApplication {

    public static void main(String[] args) throws Exception {
        int port = 9092;
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        Bootstrap bootstrap = new Bootstrap();
        try {
            bootstrap.group(workerGroup);
            bootstrap.channel(NioSocketChannel.class);
            bootstrap.option(ChannelOption.SO_KEEPALIVE, Boolean.TRUE);
            bootstrap.option(ChannelOption.TCP_NODELAY, Boolean.TRUE);
            bootstrap.handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {

                @Override
                protected void initChannel(SocketChannel ch) throws Exception {
                    ch.pipeline().addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));
                    ch.pipeline().addLast(new LengthFieldPrepender(4));
                    ch.pipeline().addLast(new LoggingHandler(LogLevel.DEBUG));
                    ch.pipeline().addLast(new RequestMessagePacketEncoder(FastJsonSerializer.X));
                    ch.pipeline().addLast(new ResponseMessagePacketDecoder());
                    ch.pipeline().addLast(new SimpleChannelInboundHandler&amp;lt;ResponseMessagePacket&amp;gt;() {
                        @Override
                        protected void channelRead0(ChannelHandlerContext ctx, ResponseMessagePacket packet) throws Exception {
                            Object targetPayload = packet.getPayload();
                            if (targetPayload instanceof ByteBuf) {
                                ByteBuf byteBuf = (ByteBuf) targetPayload;
                                int readableByteLength = byteBuf.readableBytes();
                                byte[] bytes = new byte[readableByteLength];
                                byteBuf.readBytes(bytes);
                                targetPayload = FastJsonSerializer.X.decode(bytes, String.class);
                                byteBuf.release();
                            }
                            packet.setPayload(targetPayload);
                            log.info(&quot;接收到来自服务端的响应消息,消息内容:{}&quot;, JSON.toJSONString(packet));
                        }
                    });
                }
            });
            ChannelFuture future = bootstrap.connect(&quot;localhost&quot;, port).sync();
            // 保存Channel实例,暂时不考虑断连重连
            ClientChannelHolder.CHANNEL_REFERENCE.set(future.channel());
            // 构造契约接口代理类实例
            HelloService helloService = ContractProxyFactory.ofProxy(HelloService.class);
            String result = helloService.sayHello(&quot;throwable&quot;);
            log.info(result);
            future.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先启动&lt;a href=&quot;http://www.throwable.club/2020/01/15/netty-custom-rpc-framework-server&quot;&gt;《基于Netty和SpringBoot实现一个轻量级RPC框架-Server篇》&lt;/a&gt;一文中的&lt;code&gt;ServerApplication&lt;/code&gt;，再启动&lt;code&gt;ClientApplication&lt;/code&gt;，控制台输出如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;// 服务端日志
2020-01-16 22:34:51 [main] INFO  c.throwable.server.ServerApplication - 启动NettyServer[9092]成功...
2020-01-16 22:36:35 [nioEventLoopGroup-3-1] INFO  club.throwable.server.ServerHandler - 服务端接收到:RequestMessagePacket(interfaceName=club.throwable.contract.HelloService, methodName=sayHello, methodArgumentSignatures=[java.lang.String], methodArguments=[PooledUnsafeDirectByteBuf(ridx: 0, widx: 11, cap: 11/144)])
2020-01-16 22:36:35 [nioEventLoopGroup-3-1] INFO  club.throwable.server.ServerHandler - 查找目标实现方法成功,目标类:club.throwable.server.contract.DefaultHelloService,宿主类:club.throwable.server.contract.DefaultHelloService,宿主方法:sayHello
2020-01-16 22:36:35 [nioEventLoopGroup-3-1] INFO  club.throwable.server.ServerHandler - 服务端输出:{&quot;attachments&quot;:{},&quot;errorCode&quot;:200,&quot;magicNumber&quot;:10086,&quot;message&quot;:&quot;Success&quot;,&quot;messageType&quot;:&quot;RESPONSE&quot;,&quot;payload&quot;:&quot;\&quot;throwable say hello!\&quot;&quot;,&quot;serialNumber&quot;:&quot;63d386214d30410c9e5f04de03d8b2da&quot;,&quot;version&quot;:1}

// 客户端日志
2020-01-16 22:36:35 [main] INFO  c.throwable.client.ClientApplication - [club.throwable.contract.HelloService#sayHello]调用成功,发送了[{&quot;attachments&quot;:{},&quot;interfaceName&quot;:&quot;club.throwable.contract.HelloService&quot;,&quot;magicNumber&quot;:10086,&quot;messageType&quot;:&quot;REQUEST&quot;,&quot;methodArgumentSignatures&quot;:[&quot;java.lang.String&quot;],&quot;methodArguments&quot;:[&quot;throwable&quot;],&quot;methodName&quot;:&quot;sayHello&quot;,&quot;serialNumber&quot;:&quot;63d386214d30410c9e5f04de03d8b2da&quot;,&quot;version&quot;:1}]到NettyServer[localhost/127.0.0.1:9092]
2020-01-16 22:36:35 [nioEventLoopGroup-2-1] INFO  c.throwable.client.ClientApplication - 接收到来自服务端的响应消息,消息内容:{&quot;attachments&quot;:{},&quot;errorCode&quot;:200,&quot;magicNumber&quot;:10086,&quot;message&quot;:&quot;Success&quot;,&quot;messageType&quot;:&quot;RESPONSE&quot;,&quot;payload&quot;:&quot;\&quot;throwable say hello!\&quot;&quot;,&quot;serialNumber&quot;:&quot;63d386214d30410c9e5f04de03d8b2da&quot;,&quot;version&quot;:1}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Client&lt;/code&gt;端主要负责契约接口调用转换为发送&lt;code&gt;RPC&lt;/code&gt;协议请求这一步，核心技术就是动态代理，在不进行模块封装优化的前提下实现是相对简单的。这里其实&lt;code&gt;Client&lt;/code&gt;端还有一个比较大的技术难题没有解决，上面例子中客户端日志输出如果眼尖的伙伴会发现，&lt;code&gt;Client&lt;/code&gt;端发送&lt;code&gt;RPC&lt;/code&gt;请求的线程（&lt;code&gt;main&lt;/code&gt;线程）和&lt;code&gt;Client&lt;/code&gt;端接收&lt;code&gt;Server&lt;/code&gt;端&lt;code&gt;RPC&lt;/code&gt;响应处理的线程（&lt;code&gt;nioEventLoopGroup-2-1&lt;/code&gt;线程）并不相同，这一点是&lt;code&gt;Netty&lt;/code&gt;处理网络请求之所以能够如此高效的根源（简单来说就是请求和响应是异步的，两个流程本来是互不感知的）。但是更多情况下，我们希望外部请求是同步的，希望发送&lt;code&gt;RPC&lt;/code&gt;请求的线程得到响应结果再返回（这里请求和响应有可能依然是异步流程）。下一篇文章会详细分析一下如果对请求-响应做同步化处理。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Demo&lt;/code&gt;项目地址：&lt;/p&gt;
&lt;p&gt;（c-2-d e-a-20200116）&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jan 2020 15:00:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 前置文章： &amp;quot;《基于Netty和SpringBoot实现一个轻量级RPC框架 协议篇》&amp;quot; &amp;quot;《基于Netty和SpringBoot实现一个轻量级RPC框架 Serv</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/12203684.html</dc:identifier>
</item>
<item>
<title>都2020年了，听说你还不会归并排序？手把手教你手写归并排序算法 - 超悦人生</title>
<link>http://www.cnblogs.com/exzlc/p/12203681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/exzlc/p/12203681.html</guid>
<description>&lt;p&gt;本文介绍了归并排序的基本思想，递归方法的一般写法，最后一步步手写归并排序，并对其性能进行了分析。&lt;/p&gt;
&lt;h4 id=&quot;基本思想&quot;&gt;基本思想&lt;/h4&gt;
&lt;p&gt;归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。即先使每个子序列有序，再将已有序的子序列合并，得到完全有序的序列。这里给出一种递归形式的归并排序实现。&lt;/p&gt;
&lt;h4 id=&quot;递归方法的一般写法&quot;&gt;递归方法的一般写法&lt;/h4&gt;
&lt;p&gt;递归方法的书写主要有三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;明确递归方法的功能边界；&lt;/li&gt;
&lt;li&gt;得到递归的递推关系；&lt;/li&gt;
&lt;li&gt;给定递归的终止条件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;递归方法均可按照这三步进行，切忌不要陷入递归实现的细节中。下面以归并排序算法的书写为例，来谈一下递归方法的具体写法。&lt;/p&gt;
&lt;h4 id=&quot;手写归并排序&quot;&gt;手写归并排序&lt;/h4&gt;
&lt;p&gt;首先，明确递归方法的功能，这里我们定义方法的功能为，给定一个数组及左右边界，方法完成数组边界内元素的排序，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static void mergeSort(int[] arr,int left,int right)；&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先假设我们已经有了这么一个方法，不用管具体的实现。&lt;br/&gt;接着，寻找递推关系，什么是递推关系呢？就是如何由子问题的求解，来得到原问题的求解，还是举例说明，有如下的数组&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1LmV4emxjLnh5ei9ibG9nL3NvcnQtMS5wbmc?x-oss-process=image/format,png&quot; alt=&quot;原始数组&quot;/&gt;&lt;br/&gt;我们将其拆分为左右两部分，如下&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1LmV4emxjLnh5ei9ibG9nLzE1NzkxNzI5MjE3MjUucG5n?x-oss-process=image/format,png&quot; alt=&quot;拆分数组&quot;/&gt;&lt;br/&gt;递推关系就是，假如左右两部分都已经有序了，如何使整个数组有序？这个问题其实就是给定了一个数组，数组的左半部分有序，右半部分也有序，如何使整个数组有序？&lt;br/&gt;首先，定义两个指针，分别指向左侧部分起始位置和右侧部分起始位置，同时创建一个辅助数组和指向其初始位置的辅助指针&lt;br/&gt;&lt;img src=&quot;http://qiniu.exzlc.xyz/blog/sort-3.png&quot; alt=&quot;定义指针及辅助数组&quot;/&gt;&lt;br/&gt;接着比较，左指针和右指针所对应的元素的大小，较小的元素填充至辅助数组，同时其对应的指针和辅助指针均加1，如下：&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1LmV4emxjLnh5ei9ibG9nL3NvcnQtNC5wbmc?x-oss-process=image/format,png&quot; alt=&quot;比较并填充辅助数组&quot;/&gt;&lt;br/&gt;依次进行，直至某左指针指向中间位置或者右指针指向数组的末尾，此时要将将剩余的元素填充至辅助数组。所有的元素填充完成后，再将辅助数组中的元素填充回原数组即可。具体的代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
     *
     * @param arr 要合并的数组
     * @param left 左边界
     * @param mid 中间的分界
     * @param right 右边界
     */
    private static void merge(int[] arr,int left,int mid,int right){
        int[] helpArr = new int[right - left + 1];//首先定义一个辅助数组
        int lPoint = left;//左指针
        int rPoint = mid  + 1;//右指针
        int i = 0;//辅助指针
        while(lPoint &amp;lt;= mid &amp;amp;&amp;amp; rPoint &amp;lt;= right){//比较并填充辅助数组
            if(arr[lPoint] &amp;lt;=  arr[rPoint])
                helpArr[i++] =  arr[lPoint++];
            else
                helpArr[i++] =  arr[rPoint++];
        }
        while(lPoint &amp;lt;= mid){//将剩余元素填充至辅助数组
            helpArr[i++] =  arr[lPoint++];
        }
        while(rPoint &amp;lt;= right){
            helpArr[i++] =  arr[rPoint++];
        }
        for(int j = 0;j &amp;lt; helpArr.length;j ++){//将辅助数组中的元素回填至原数组
            arr[left + j] = helpArr[j];
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，确定终止条件，一般是数组为空或者数组中只有一个元素，返回即可。&lt;br/&gt;现在我们可以写出整个归并排序的代码了，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static void mergeSort(int[] arr,int left,int right){
        if(arr == null || right == left)//终止条件
            return ;
        int mid = left + (right - left) / 2;//确定分割的边界
        mergeSort(arr,left,mid);//对左半部分调用递归方法，使其有序
        mergeSort(arr,mid + 1,right);//对右半部分调用递归方法，使其有序
        merge(arr,left,mid,right);//合并左右两部分，使整个数组有序
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了保证形式的统一，再对函数进行一下封装，如下，这就是我们的归并排序了。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * 归并排序算法
     * @param arr
     */
    public static void mergeSort(int[] arr){
        mergeSort(arr,0,arr.length - 1);//调用写好的递归版归并排序方法
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们便完成了归并排序算法的代码实现。&lt;/p&gt;
&lt;h4 id=&quot;性能分析&quot;&gt;性能分析&lt;/h4&gt;
&lt;p&gt;在分析归并排序算法性能之前，先介绍几个基础的概念。&lt;br/&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：一个算法执行所消耗的时间；&lt;br/&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;：运行完一个算法所需的内存大小；&lt;br/&gt;&lt;strong&gt;原地排序&lt;/strong&gt;：在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。&lt;br/&gt;&lt;strong&gt;非原地排序&lt;/strong&gt;：需要利用额外的数组来辅助排序。&lt;br/&gt;&lt;strong&gt;稳定排序&lt;/strong&gt;：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。&lt;br/&gt;&lt;strong&gt;非稳定排序&lt;/strong&gt;：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序。&lt;br/&gt;下面我们分析下归并排序算法的性能。&lt;br/&gt;首先是&lt;strong&gt;时间复杂度&lt;/strong&gt;。归并排序算法在排序时首先将问题进行分解，然后解决子问题，再合并，所以总时间=分解时间+解决子问题时间+合并时间。分解时间就是把一个数组分解为左右两部分，时间为一常数，即O(1)；解决子问题时间是两个递归方法，把一个规模为n的问题分成两个规模分别为n/2的子问题，时间为2T(n/2)；合并时间复杂度为O(n)。所以总时间T(n)=2T(n/2)+O(n)。这个递归问题的时间复杂度可以用下面的公式来计算&lt;br/&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1LmV4emxjLnh5ei9ibG9nL3NvcnQtNS5wbmc?x-oss-process=image/format,png&quot; alt=&quot;递归函数的时间复杂度计算公式&quot;/&gt;&lt;br/&gt;这个公式可针对形如：T(n) = aT(n/b) + f(n)的递归方程进行时间复杂度求解。带入可知，归并排序的时间复杂度为&lt;strong&gt;O(nlogn)&lt;/strong&gt;。此外在最坏、最佳、平均情况下归并排序时间复杂度均为O(nlogn)。&lt;br/&gt;&lt;strong&gt;空间复杂度分析&lt;/strong&gt;：在排序过程中使用了一个与原数组等长的辅助数组，估空间复杂度为O(n)。&lt;br/&gt;&lt;strong&gt;稳定性分析&lt;/strong&gt;：由排序过程可以知道，归并排序是一种稳定排序。&lt;br/&gt;&lt;strong&gt;是否原地排序&lt;/strong&gt;：排序过程中用到了辅助数组，所以是非原地排序。&lt;br/&gt;本文源码已同步至github，地址：https://github.com/zhanglianchao/AllForJava/tree/master/src/algorithm/sort&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;觉得文章有用的话，&lt;strong&gt;点赞&lt;/strong&gt;+&lt;strong&gt;关注&lt;/strong&gt;呗，好让更多的人看到这篇文章，也激励博主写出更多的好文章。&lt;br/&gt;更多关于&lt;strong&gt;算法、数据结构和计算机基础知识&lt;/strong&gt;的内容，欢迎扫码关注我的原创公众号「&lt;span&gt;&lt;strong&gt;超悦编程&lt;/strong&gt;&lt;/span&gt;」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL3Fpbml1LmV4emxjLnh5ei9ibG9nL3R1aWd1YW5nLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;超悦编程&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jan 2020 14:58:00 +0000</pubDate>
<dc:creator>超悦人生</dc:creator>
<og:description>本文介绍了归并排序的基本思想，递归方法的一般写法，最后一步步手写归并排序，并对其性能进行了分析。 基本思想 归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法的一个非常典型的应用。即先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/exzlc/p/12203681.html</dc:identifier>
</item>
<item>
<title>Linux常用命令总结 - 不懒人</title>
<link>http://www.cnblogs.com/wuwuyong/p/12203482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuwuyong/p/12203482.html</guid>
<description>&lt;p&gt;常见目录说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/bin： 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里；&lt;/li&gt;
&lt;li&gt;/etc： 存放系统管理和配置文件；&lt;/li&gt;
&lt;li&gt;/home： 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；&lt;/li&gt;
&lt;li&gt;/usr ： 用于存放系统应用程序；&lt;/li&gt;
&lt;li&gt;/opt： 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；&lt;/li&gt;
&lt;li&gt;/proc： 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；&lt;/li&gt;
&lt;li&gt;/root： 超级用户（系统管理员）的主目录（特权阶级^o^）；&lt;/li&gt;
&lt;li&gt;/sbin: 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；&lt;/li&gt;
&lt;li&gt;/dev： 用于存放设备文件；&lt;/li&gt;
&lt;li&gt;/mnt： 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；&lt;/li&gt;
&lt;li&gt;/boot： 存放用于系统引导时使用的各种文件；&lt;/li&gt;
&lt;li&gt;/lib ： 存放着和系统运行相关的库文件 ；&lt;/li&gt;
&lt;li&gt;/tmp： 用于存放各种临时文件，是公用的临时文件存储点；&lt;/li&gt;
&lt;li&gt;/var： 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；&lt;/li&gt;
&lt;li&gt;/lost+found： 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;一 Linux基本命令&lt;/h2&gt;
&lt;p&gt;下面只是给出了一些比较常用的命令。推荐一个Linux命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。&lt;/p&gt;
&lt;p&gt;Linux命令大全：&lt;a href=&quot;http://man.linuxde.net/&quot;&gt;http://man.linuxde.net/&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;1.1 目录切换命令&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cd usr&lt;/code&gt;： 切换到该目录下usr目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd ..（或cd../）&lt;/code&gt;： 切换到上一层目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd /&lt;/code&gt;： 切换到系统根目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd ~&lt;/code&gt;： 切换到用户主目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cd -&lt;/code&gt;： 切换到上一个操作所在目录&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.2 目录的操作命令(增删改查)&lt;/h3&gt;
&lt;ol readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;mkdir 目录名称&lt;/code&gt;： 增加目录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;ls或者ll&lt;/code&gt;（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;find 目录 参数&lt;/code&gt;： 寻找目录（查）&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;列出当前目录及子目录下所有文件和文件夹: &lt;code&gt;find .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;/home&lt;/code&gt;目录下查找以.txt结尾的文件名:&lt;code&gt;find /home -name &quot;*.txt&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同上，但忽略大小写: &lt;code&gt;find /home -iname &quot;*.txt&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当前目录及子目录下查找所有以.txt和.pdf结尾的文件:&lt;code&gt;find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)&lt;/code&gt;或&lt;code&gt;find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;mv 目录名称 新目录名称&lt;/code&gt;： 修改目录的名称（改）&lt;/p&gt;
&lt;p&gt;注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;mv 目录名称 目录的新位置&lt;/code&gt;： 移动目录的位置---剪切（改）&lt;/p&gt;
&lt;p&gt;注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;cp -r 目录名称 目录拷贝的目标位置&lt;/code&gt;： 拷贝目录（改），-r代表递归拷贝&lt;/p&gt;
&lt;p&gt;注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;rm [-rf] 目录&lt;/code&gt;: 删除目录（删）&lt;/p&gt;
&lt;p&gt;注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用&lt;code&gt;rm -rf&lt;/code&gt; 目录/文件/压缩包&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;1.3 文件的操作命令(增删改查)&lt;/h3&gt;
&lt;ol readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;touch 文件名称&lt;/code&gt;: 文件的创建（增）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;cat/more/less/tail 文件名称&lt;/code&gt; 文件的查看（查）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cat&lt;/code&gt;： 查看显示文件内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;more&lt;/code&gt;： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看&lt;/li&gt;
&lt;li&gt;&lt;code&gt;less&lt;/code&gt;： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tail-10&lt;/code&gt; ： 查看文件的后10行，Ctrl+C结束&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;code&gt;vim 文件&lt;/code&gt;： 修改文件的内容（改）&lt;/p&gt;
&lt;p&gt;vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。&lt;/p&gt;
&lt;p&gt;在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：&lt;/p&gt;
&lt;p&gt;vim 文件------&amp;gt;进入文件-----&amp;gt;命令模式------&amp;gt;按i进入编辑模式-----&amp;gt;编辑文件 -------&amp;gt;按Esc进入底行模式-----&amp;gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;rm -rf 文件&lt;/code&gt;： 删除文件（删）&lt;/p&gt;
&lt;p&gt;同目录删除：熟记 &lt;code&gt;rm -rf&lt;/code&gt; 文件 即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;1.4 压缩文件的操作命令&lt;/h3&gt;
&lt;p&gt;1）打包并压缩文件：&lt;/p&gt;
&lt;p&gt;Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。&lt;/p&gt;
&lt;p&gt;而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：&lt;code&gt;tar -zcvf 打包压缩后的文件名 要打包压缩的文件&lt;/code&gt; 其中：&lt;/p&gt;
&lt;p&gt;z：调用gzip压缩命令进行压缩&lt;/p&gt;
&lt;p&gt;c：打包文件&lt;/p&gt;
&lt;p&gt;v：显示运行过程&lt;/p&gt;
&lt;p&gt;f：指定文件名&lt;/p&gt;
&lt;p&gt;比如：假如test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：&lt;code&gt;tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt&lt;/code&gt;或：&lt;code&gt;tar -zcvf test.tar.gz /test/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2）解压压缩包：&lt;/p&gt;
&lt;p&gt;命令：tar [-xvf] 压缩文件&lt;/p&gt;
&lt;p&gt;其中：x：代表解压&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;1 将/test下的test.tar.gz解压到当前目录下可以使用命令：&lt;code&gt;tar -xvf test.tar.gz&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2 将/test下的test.tar.gz解压到根目录/usr下:&lt;code&gt;tar -xvf test.tar.gz -C /usr&lt;/code&gt;（- C代表指定解压的位置）&lt;/p&gt;
&lt;h3&gt;1.5 Linux的权限命令&lt;/h3&gt;
&lt;p&gt;操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 &lt;code&gt;ls -l&lt;/code&gt; 命令我们可以 查看某个目录下的文件或目录的权限&lt;/p&gt;
&lt;p&gt;示例：在随意某个目录下&lt;code&gt;ls -l&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/5/1646955be781daaa?w=589&amp;amp;h=228&amp;amp;f=png&amp;amp;s=16360&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一列的内容的信息解释如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/5/16469565b6951791?w=489&amp;amp;h=209&amp;amp;f=png&amp;amp;s=39791&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件的类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;d： 代表目录&lt;/li&gt;
&lt;li&gt;-： 代表文件&lt;/li&gt;
&lt;li&gt;l： 代表软链接（可以认为是window中的快捷方式）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Linux中权限分为以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;r：代表权限是可读，r也可以用数字4表示&lt;/li&gt;
&lt;li&gt;w：代表权限是可写，w也可以用数字2表示&lt;/li&gt;
&lt;li&gt;x：代表权限是可执行，x也可以用数字1表示&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;文件和目录权限的区别：&lt;/p&gt;
&lt;p&gt;对文件和目录而言，读写执行表示不同的意义。&lt;/p&gt;
&lt;p&gt;对于文件：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;权限名称&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;可执行操作&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;r&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;可以使用cat查看文件的内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;w&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;可以修改文件的内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;x&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;可以将其运行为二进制文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;对于目录：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;权限名称&lt;/th&gt;
&lt;th align=&quot;right&quot;&gt;可执行操作&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;r&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;可以查看目录下列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;w&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;可以创建和删除目录下文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td align=&quot;left&quot;&gt;x&lt;/td&gt;
&lt;td align=&quot;right&quot;&gt;可以使用cd进入目录&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;所有者&lt;/p&gt;
&lt;p&gt;一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;文件所在组&lt;/p&gt;
&lt;p&gt;当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其它组&lt;/p&gt;
&lt;p&gt;除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我们再来看看如何修改文件/目录的权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改文件/目录的权限的命令：&lt;code&gt;chmod&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限， 其他用户只有读的权限&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chmod u=rwx,g=rw,o=r aaa.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/7/5/164697447dc6ecac?w=525&amp;amp;h=246&amp;amp;f=png&amp;amp;s=12362&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述示例还可以使用数字表示：&lt;/p&gt;
&lt;p&gt;chmod 764 aaa.txt&lt;/p&gt;
&lt;p&gt;补充一个比较常用的东西:&lt;/p&gt;
&lt;p&gt;假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新建一个脚本zookeeper&lt;/li&gt;
&lt;li&gt;为新建的脚本zookeeper添加可执行权限，命令是:&lt;code&gt;chmod +x zookeeper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;把zookeeper这个脚本添加到开机启动项里面，命令是：&lt;code&gt; chkconfig --add zookeeper&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果想看看是否添加成功，命令是：&lt;code&gt;chkconfig --list&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;1.6 Linux 用户管理&lt;/h3&gt;
&lt;p&gt;Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。&lt;/p&gt;
&lt;p&gt;用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。&lt;/p&gt;
&lt;p&gt;Linux用户管理相关命令:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;useradd 选项 用户名&lt;/code&gt;:添加用户账号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;userdel 选项 用户名&lt;/code&gt;:删除用户帐号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;usermod 选项 用户名&lt;/code&gt;:修改帐号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;passwd 用户名&lt;/code&gt;:更改或创建用户的密码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;passwd -S 用户名&lt;/code&gt; :显示用户账号密码信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;passwd -d 用户名&lt;/code&gt;: 清除用户密码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。&lt;/p&gt;
&lt;p&gt;passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。&lt;/p&gt;
&lt;h3&gt;1.7 Linux系统用户组的管理&lt;/h3&gt;
&lt;p&gt;每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。&lt;/p&gt;
&lt;p&gt;用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。&lt;/p&gt;
&lt;p&gt;Linux系统用户组的管理相关命令:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;groupadd 选项 用户组&lt;/code&gt; :增加一个新的用户组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;groupdel 用户组&lt;/code&gt;:要删除一个已有的用户组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;groupmod 选项 用户组&lt;/code&gt; : 修改用户组的属性&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;1.8 其他常用命令&lt;/h3&gt;
&lt;ul readability=&quot;11.230363423212&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;pwd&lt;/code&gt;： 显示当前所在位置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;sudo + 其他命令&lt;/code&gt;：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;grep 要搜索的字符串 要搜索的文件 --color&lt;/code&gt;： 搜索命令，--color代表高亮显示&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;ps -ef&lt;/code&gt;/&lt;code&gt;ps -aux&lt;/code&gt;： 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：&lt;code&gt;ps aux|grep redis&lt;/code&gt; （查看包括redis字符串的进程），也可使用 &lt;code&gt;pgrep redis -a&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;kill -9 进程的pid&lt;/code&gt;： 杀死进程（-9 表示强制终止。）&lt;/p&gt;
&lt;p&gt;先用ps查找进程，然后用kill杀掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络通信命令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看当前系统的网卡信息：ifconfig&lt;/li&gt;
&lt;li&gt;查看与某台机器的连接情况：ping&lt;/li&gt;
&lt;li&gt;查看当前系统的端口使用：netstat -an&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;1.8194130925508&quot;&gt;
&lt;p&gt;net-tools 和 iproute2 ： &lt;code&gt;net-tools&lt;/code&gt;起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持&lt;code&gt;iproute2&lt;/code&gt;。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读&lt;a href=&quot;https://linoxide.com/linux-command/use-ip-command-linux&quot;&gt;如何在Linux中使用IP命令和示例&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;shutdown&lt;/code&gt;： &lt;code&gt;shutdown -h now&lt;/code&gt;： 指定现在立即关机；&lt;code&gt;shutdown +5 &quot;System will shutdown after 5 minutes&quot;&lt;/code&gt;：指定5分钟后关机，同时送出警告信息给登入用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;reboot&lt;/code&gt;： &lt;code&gt;reboot&lt;/code&gt;： 重开机。&lt;code&gt;reboot -w&lt;/code&gt;： 做个重开机的模拟（只有纪录并不会真的重开机）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 16 Jan 2020 14:01:00 +0000</pubDate>
<dc:creator>不懒人</dc:creator>
<og:description>常见目录说明： /bin：&amp;#160;存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里； /etc：&amp;#160;存放系统管理和配置文件； /home：&amp;#160;存放所有用户文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wuwuyong/p/12203482.html</dc:identifier>
</item>
<item>
<title>.net core 实现基于 JSON 的多语言 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/json-based-localization-in-aspnetcore.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/json-based-localization-in-aspnetcore.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;上次我们提到了，微软默认提供基于资源文件的多语言本地化，个人感觉使用起来不是太方便，没有 json 看起来直观，于是动手造了一个轮子， dotnet core 基于 json 的本地化组件&lt;/p&gt;
&lt;h2 id=&quot;getstarted&quot;&gt;GetStarted&lt;/h2&gt;
&lt;p&gt;需要引用 nuget 包 WeihanLi.Extensions.Localization.Json &lt;a href=&quot;https://www.nuget.org/packages/WeihanLi.Extensions.Localization.Json/&quot;&gt;&lt;img src=&quot;https://img.shields.io/nuget/v/WeihanLi.Extensions.Localization.Json.svg&quot; alt=&quot;WeihanLi.Extensions.Localization.Json&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注册服务：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;services.AddJsonLocalization(options =&amp;gt;
    {
        options.ResourcesPath = Configuration.GetAppSetting(&quot;ResourcesPath&quot;);
        options.ResourcesPathType = ResourcesPathType.TypeBased; // 默认方式和微软找资源的方式类似
        // options.ResourcesPathType = ResourcesPathType.CultureBased; // 在对应的 culture 子目录下寻找资源文件，可以参考后面的示例
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;中间件配置(如果是asp.net core，和之前一样):&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;app.UseRequestLocalization();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;That's it~&lt;/p&gt;
&lt;h2 id=&quot;添加你的资源文件&quot;&gt;添加你的资源文件&lt;/h2&gt;
&lt;h3 id=&quot;typebased-资源文件的路径&quot;&gt;TypeBased 资源文件的路径&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;For Types:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Home/Index&lt;/code&gt; =&amp;gt; Controllers/HomeController&lt;/p&gt;
&lt;p&gt;资源路径：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[ResourcesPath]/Controllers/HomeController.[cultureName].json&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Resources/Controllers/HomeController.en.json&lt;/li&gt;
&lt;li&gt;Resources/Controllers/HomeController.zh.json&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;For Razor 视图:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Resources/Views/Home/Index.en.json&lt;/li&gt;
&lt;li&gt;Resources/Views/Home/Index.zh.json&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;culturebased-资源文件路径&quot;&gt;CultureBased 资源文件路径&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;For Types:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Home/Index&lt;/code&gt; =&amp;gt; Controllers/HomeController&lt;/p&gt;
&lt;p&gt;资源路径:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[ResourcesPath]/[cultureName]/Controllers/HomeController.json&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Resources/en/Controllers/HomeController.json&lt;/li&gt;
&lt;li&gt;Resources/zh/Controllers/HomeController.json&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;For Razor 视图:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Resources/en/Views/Home/Index.json&lt;/li&gt;
&lt;li&gt;Resources/zh/Views/Home/Index.json&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Copy your resource files to output:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;需要设置将资源文件拷贝到输出目录，否则会找不到资源文件，可以在启动项目项目文件中加入以下示例代码：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;ItemGroup&amp;gt;
&amp;lt;Content Update=&quot;Resources\**\*.json&quot;&amp;gt;
    &amp;lt;CopyToOutputDirectory&amp;gt;Always&amp;lt;/CopyToOutputDirectory&amp;gt;
&amp;lt;/Content&amp;gt;
&amp;lt;/ItemGroup&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的配置会将 &lt;code&gt;Resources&lt;/code&gt; 目录下的所有 json 文件拷贝到输出目录下，可以根据自己的需要进行修改&lt;/p&gt;
&lt;h2 id=&quot;use&quot;&gt;Use&lt;/h2&gt;
&lt;p&gt;用法和之前是一样的&lt;/p&gt;
&lt;p&gt;Controller 示例：&lt;/p&gt;
&lt;pre class=&quot;chsarp&quot;&gt;
&lt;code&gt;public class ValuesController : Controller
{
    private readonly IStringLocalizer&amp;lt;ValuesController&amp;gt; _localizer;

    public ValuesController(IStringLocalizer&amp;lt;ValuesController&amp;gt; localizer)
    {
        _localizer = localizer;
    }

    // GET: api/&amp;lt;controller&amp;gt;
    [HttpGet]
    public string Get()
    {
        return _localizer[&quot;Culture&quot;];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Razor 视图示例：&lt;/p&gt;
&lt;pre class=&quot;razor&quot;&gt;
&lt;code&gt;@using Microsoft.AspNetCore.Mvc.Localization
@using Microsoft.Extensions.Localization
@using WeihanLi.Extensions.Localization.Json.Sample.Controllers
@inject IHtmlLocalizer&amp;lt;HomeController&amp;gt; HtmlLocalizer
@inject IStringLocalizer&amp;lt;HomeController&amp;gt; StringLocalizer
@inject IViewLocalizer ViewLocalizer
@{
    ViewData[&quot;Title&quot;] = &quot;Index&quot;;
}

&amp;lt;h2&amp;gt;Index&amp;lt;/h2&amp;gt;

&amp;lt;div&amp;gt;string: @StringLocalizer[&quot;Hello&quot;]&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;html: @HtmlLocalizer[&quot;Hello&quot;]&amp;lt;/div&amp;gt;

&amp;lt;div&amp;gt;view: @ViewLocalizer[&quot;Hello&quot;]&amp;lt;/div&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;资源文件示例：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;Culture&quot;: &quot;中文&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;samples&quot;&gt;Samples&lt;/h2&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;扩展增加了 &lt;code&gt;CultureBased&lt;/code&gt; 方式，这样就方便将某一种语言的语言包打包，也方便了扩展&lt;/p&gt;
</description>
<pubDate>Thu, 16 Jan 2020 13:49:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>上次我们提到了，微软默认提供基于资源文件的多语言本地化，个人感觉使用起来不是太方便，没有 json 看起来直观，于是动手造了一个轮子， dotnet core 基于 json 的本地化组件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/json-based-localization-in-aspnetcore.html</dc:identifier>
</item>
<item>
<title>记录我的 python 学习历程-Day13 匿名函数、内置函数 II、闭包 - Dylan_Yu</title>
<link>http://www.cnblogs.com/guanshou/p/12203415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guanshou/p/12203415.html</guid>
<description>&lt;h3 id=&quot;一匿名函数&quot;&gt;一、匿名函数&lt;/h3&gt;
&lt;p&gt;以后面试或者工作中经常用匿名函数 lambda，也叫一句话函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;课上练习：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 正常函数：
def func(a, b):
    return a + b

print(func(4, 6))   # 10

# 匿名函数：
func = lambda a, b: a + b

print(func(11, 33)) # 44

# 写匿名函数：接收一个可切片的数据，返回索引为0与2的对应的元素（元组形式）。
func = lambda x: (x[0], x[2])
print(func('Dylan'))    # ('D', 'l')

# 写匿名函数：接收两个int参数，将较大的数据返回。
func1 = lambda a, b: a if a &amp;gt; b else b
print(func1(11, 88))    # 88&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt;&lt;br/&gt;&lt;em&gt;函数名 = lambda 参数:返回值&lt;/em&gt;&lt;/p&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;此函数不是没有名字，他是有名字的，他的名字就是你给其设置的变量，比如func.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;lambda 是定义匿名函数的关键字，相当于函数的def.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;lambda 后面直接加形参，形参加多少都可以，只要用逗号隔开就行。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;func = lambda a,b,*args,sex= 'alex',c,**kwargs: kwargs
print(func(3, 4,c=666,name='alex'))  # {'name': 'alex'}
# 所有类型的形参都可以加，但是一般使用匿名函数只是加位置参数，其他的用不到。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;返回值在冒号之后设置，返回值和正常的函数一样,可以是任意数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;匿名函数不管多复杂.只能写一行.且逻辑结束后直接返回数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二、内置函数 ii&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;红色重点讲解&lt;/strong&gt;：abs() enumerate() filter() map() max() min() open() range() print() len() list() dict() str() reversed() set() sorted() sum() tuple() type() zip() dir()&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# python 提供了68个内置函数。
# eval()    剥去字符串的外衣，运算里面的代码，有返回值。**
s = '1 + 3'
print(s)    # 1 + 3
print(eval(s))  # 4


s1 = &quot;{'name': 'Dylan'}&quot;
print(s1, type(s1))     # {'name': 'Dylan'} &amp;lt;class 'str'&amp;gt;
# print(dict(s1))     # 不能转换成字典，报错。
print(eval(s1), type(eval(s1))) # {'name': 'Dylan'} &amp;lt;class 'dict'&amp;gt; 转换成字典了。
# 网络传输的 str input 输入的时候，sql 注入等，绝对不能使用 eval()。

# exec()与 eval()几科一样，代码流。
msg = '''
for i in range(10):
    print(i)
'''
# print(msg)
exec(msg)

# hash() 获取一个对象（可哈希对象：int，str，Bool，tuple）的哈希值。
print(hash('Dylan'))    # -2239819904114377323

# help() 帮助 **
s2 = 'Dylan'
print(help(str.upper))
s1 = s2.upper()
print(s1)

# callable()：用于检查一个对象是否是可调用的。***
s1 = 'Dylan'
def func():
    pass


print(callable(s1))     # False
print(callable(func))   # True

# int() 用于将一个字符串或数字转换为整型。
print(int())        # 0
print(int('12'))    # 12
print(int(3.6))     # 3
print(int('0100', base=2))  # 将2进制的 0100 转化成十进制。结果为 4

# float() 用于将整数和字符串转换成浮点数。
print(float(3)) # 3.0
print(float())  # 0.0
print(float(&quot;12.33&quot;))   # 12.33

# complex() 用于创建一个值为 real + imag * j 的复数或者转化一个字符串或数为复数。
# 如果第一个参数为字符串，则不需要指定第二个参数。
print(complex(1, 2))    # (1+2j)

# bin：将十进制转换成二进制并返回。**
# oct：将十进制转化成八进制字符串并返回。**
# hex：将十进制转化成十六进制字符串并返回。**
print(bin(10), type(bin(10)))   # 0b1010 &amp;lt;class 'str'&amp;gt;
print(oct(10), type(oct(10)))   # 0o12 &amp;lt;class 'str'&amp;gt;
print(hex(10), type(hex(10)))   # 0xa &amp;lt;class 'str'&amp;gt;

# divmod() 计算除数与被除数的结果，返回一个包含商和余数的元组(a // b, a % b)。**
# round() 保留浮点数的小数位数，默认保留整数。**
# pow() 求x**y次幂。（三个参数为x**y的结果对z取余）**
print(divmod(8, 3))     # (2, 2)
print(round(7/3, 2))    # 2.33
print(round(7/3))       # 2
print(round(3.32353, 3))    # 3.323
print(pow(2, 3))    # 两个参数为2**3次幂
print(pow(2, 3, 3)) # 三个参数为2**3次幂，对3取余。结果 2。

# bytes() 用于不同编码之间的转化。***
s = 'Dylan'
bs = s.encode('utf-8')
print(bs)   # b'Dylan'

bs = bytes(s, encoding='utf-8')
print(bs)   # b'Dylan'

# ord:输入字符找该字符编码的位置
# chr:输入位置数字找出其对应的字符
print(ord('a'))     # 97
print(ord('中'))    # 20013

print(chr(97))      # a
print(chr(20013))   # 中

# repr:返回一个对象的string形式（原形毕露）。
print(repr('Dylan'))    # 'Dylan'
print('Dylan')  # Dylan

name = 'Dylan'
print('我叫%r' % name)    # 我叫'Dylan'

# all：可迭代对象中，全都是True才是True
# any：可迭代对象中，有一个True 就是True
print(all([1, 2, True, 0])) # False
print(any([1, '', 0]))      # True

# #################### 非常重要 ######################## #
# print() 屏幕输出。
# 源码分析
# def print(self, *args, sep=' ', end='\n', file=None): # known special case of print
#
#     print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)
#     file:  默认是输出到屏幕，如果设置为文件句柄，输出到文件
#     sep:   打印多个值之间的分隔符，默认为空格
#     end:   每一次打印的结尾，默认为换行符
#     flush: 立即把内容输出到流文件，不作缓存
#
print(11, 22, 33, sep='|')  # 11|22|33
print(111, end='')
print(222)  # 两行结果为 111222

# list() 将一个可迭代对象转换成列表
# tuple() 将一个可迭代对象转换成元组
# dict() 通过相应的方式创建字典。

l1 = list('Dylang')
print(l1)   # ['D', 'y', 'l', 'a', 'n', 'g']
tu = tuple('Dylan')
print(tu)   # ('D', 'y', 'l', 'a', 'n')
# dict 创建字典的几种方式
# 直接创建
# 元组的解构
dic = dict([(1, 'one'), (2, 'two'), (3, 'three')])
print(dic)  # {1: 'one', 2: 'two', 3: 'three'}
dic1 = dict(one=1, two=2)
print(dic1) # {'one': 1, 'two': 2}
# fromkeys
# update
# 字典的推导式

# abs() 返回绝对值
i = -88
print(abs(i))   # 88

# sum() 求和
l1 = [i for i in range(11)]
s1 = '12345'
print(sum(l1))  # 55
print(sum(l1, 100))     # 设置初始数为100 # 结果：155
# print(sum(s1))   # 报错   TypeError: unsupported operand type(s) for +: 'int' and 'str'

# reversed() 将一个序列翻转, 返回翻转序列的迭代器 reversed
l = reversed('你好')  # 获取到的是一个生成器
print(list(l))  # 将生成器中的元素转换为列表 ['好', '你']
ret = reversed([1, 4, 6, 5, 8, 7])  # 获取到的是一个生成器
print(list(ret))    # [7, 8, 5, 6, 4, 1]

# zip() 拉链方法。函数用于将可迭代的对象作为参数,将对象中对应的元素打包成一个个元组,
# 然后返回由这些元祖组成的内容,如果各个迭代器的元素个数不一致,则按照长度最短的返回
s = 'abcde'
tu = ('Dylan', 'xiaobai', 'niaoren')
l1 = [1, 2, 3, 4]
obj = zip(s, tu, l1)
for i in obj:
    print(i)
print(list(obj))

# ################# 以下方法最最最最最重要 ##############
# min() 求最小值
# max() 最大值与最小值用法相同。
print(min([1, 2, 3, 4]))  # 返回此序列最小值
ret = min([1, 2, -3], key=abs)  # 按照绝对值的大小，返回此序列的最小值
print(ret)
# 加 key 是可以加函数名的，min 会自动获取传入函数中的参数的每个元素，
# 然后通过你设定的返回值比较大小，返回最小的传入的那个参数。
print(min(1, 2, -5, 6, -3, key=lambda x: abs(x)))  # 可以设置很多参数比较大小
dic = {'a': 3, 'b': 2, 'c': 1}
print(min(dic, key=lambda x: dic[x]))
# x为dic的key，lambda的返回值（即dic的值进行比较）返回最小的值对应的键
l2 = [('太白', 18), ('alex', 73), ('wusir', 35), ('口天吴', 41)]
print(min(l2))  # ('alex', 73)
print(min(l2, key=lambda x: x[1]))  # ('太白', 18)

# sorted()排序函数
# 语法:sorted(iterable,key=None,reverse=False)
# iterable : 可迭代对象
# key: 排序规则(排序函数),在sorted内部会将可迭代对象中的每一个元素传递给这个函数的参数.根据函数运算的结果进行排序
# reverse :是否是倒序,True 倒序 False 正序
l1 = [22, 33, 1, 2, 8, 7, 6, 5]
l2 = sorted(l1)
print(l1)  # [22, 33, 1, 2, 8, 7, 6, 5]
print(l2)  # [1, 2, 5, 6, 7, 8, 22, 33]

l3 = [('大壮', 76), ('雪飞', 70), ('纳钦', 94), ('张珵', 98), ('b哥', 96)]
print(sorted(l3))  # [('b哥', 96), ('大壮', 76), ('张珵', 98), ('纳钦', 94), ('雪飞', 70)]
print(sorted(l3, key=lambda x: x[1]))  # 返回的是一个列表，默认从低到高。
print(sorted(l3, key=lambda x: x[1], reverse=True))  # # 返回的是一个列表，从高到低

# filter()筛选过滤
# 语法: filter(function,iterable)
# function: 用来筛选的函数,在filter中会自动的把iterable中的元素传递给function,
# 然后根据function返回的True或者False来判断是否保留此项数据
# iterable:可迭代对象
l1 = [2, 3, 4, 1, 6, 7, 8]
print([i for i in l1 if i &amp;gt; 3])  # [4, 6, 7, 8] 返回的是列表
ret = filter(lambda x: x &amp;gt; 3, l1)  # 返回的是个迭代器
print(ret)  # &amp;lt;filter object at 0x10601db70&amp;gt;
print(list(ret))  # [4, 6, 7, 8]

# map() 映射函数
# 语法: map(function,iterable) 可以对可迭代对象中的每一个元素进映射,分别取执行function
# 计算列表中每个元素的平方,返回新列表
lst = [1, 2, 3, 4, 5]


def func(s):
    return s * s


mp = map(func, lst)
print(mp)  # &amp;lt;map object at 0x10581dd30&amp;gt;
print(list(mp))  # [1, 4, 9, 16, 25]

# 改写成lambda
print(list(map(lambda s: s * s, lst)))  # [1, 4, 9, 16, 25]

# 计算两个列表中相同位置的数据的和
lst1 = [1, 2, 3, 4, 5]
lst2 = [2, 4, 6, 8, 10]
print(list(map(lambda x, y: x + y, lst1, lst2)))  # [3, 6, 9, 12, 15]

# reduce()
from functools import reduce


def func(x, y):
    return x + y


# reduce 的使用方式:
# reduce(函数名,可迭代对象)  # 这两个参数必须都要有,缺一个不行
ret = reduce(func, [3, 4, 5, 6, 7])
print(ret)  # 结果 25

# reduce的作用是先把列表中的前俩个元素取出计算出一个值然后临时保存着,
# 接下来用这个临时保存的值和列表中第三个元素进行计算,求出一个新的值将最开始
# 临时保存的值覆盖掉,然后在用这个新的临时值和列表中第四个元素计算.依次类推

# 注意:我们放进去的可迭代对象没有更改
# 以上这个例子我们使用sum就可以完全的实现了.我现在有[1,2,3,4]想让列表中的数变成1234,就要用到reduce了.
# 普通函数版

from functools import reduce


def func(x, y):
    return x * 10 + y
    # 第一次的时候 x是1 y是2  x乘以10就是10,然后加上y也就是2最终结果是12然后临时存储起来了
    # 第二次的时候x是临时存储的值12 x乘以10就是 120 然后加上y也就是3最终结果是123临时存储起来了
    # 第三次的时候x是临时存储的值123 x乘以10就是 1230 然后加上y也就是4最终结果是1234然后返回了


l = reduce(func, [1, 2, 3, 4])
print(l)

# 匿名函数版
l = reduce(lambda x, y: x * 10 + y, [1, 2, 3, 4])
print(l)

# 在Python2.x版本中recude是直接 import就可以的, Python3.x版本中需要从functools这个包中导入
# 龟叔本打算将 lambda 和 reduce 都从全局名字空间都移除, 舆论说龟叔不喜欢lambda 和 reduce
# 最后lambda没删除是因为和一个人写信写了好多封,进行交流然后把lambda保住了.&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三闭包&quot;&gt;三、闭包&lt;/h3&gt;
&lt;p&gt;由于闭包这个概念比较难以理解，尤其是初学者来说，相对难以掌握，所以我们通过示例去理解学习闭包。&lt;/p&gt;
&lt;p&gt;给大家提个需求，然后用函数去实现：完成一个计算不断增加的系列值的平均值的需求。&lt;/p&gt;
&lt;p&gt;例如：整个历史中的某个商品的平均收盘价。什么叫平局收盘价呢？就是从这个商品一出现开始，每天记录当天价格，然后计算他的平均值：平均值要考虑直至目前为止所有的价格。&lt;/p&gt;
&lt;p&gt;比如大众推出了一款新车：小白轿车。&lt;/p&gt;
&lt;p&gt;第一天价格为：100000元，平均收盘价：100000元&lt;/p&gt;
&lt;p&gt;第二天价格为：110000元，平均收盘价：（100000 + 110000）/2 元&lt;/p&gt;
&lt;p&gt;第三天价格为：120000元，平均收盘价：（100000 + 110000 + 120000）/3 元&lt;/p&gt;
&lt;p&gt;........&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;series = []
def make_averager(new_value):
    series.append(new_value)
    total = sum(series)
    return total / len(series)
    
print(make_averager(100000))
print(make_averager(110000))
print(make_averager(120000))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的例子可以看出，基本上完成了我们的要求，但是这个代码相对来说是不安全的，因为你的这个series列表是一个全局变量，只要是全局作用域的任何地方，都可能对这个列表进行改变。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;series = []
def make_averager(new_value):
    series.append(new_value)
    total = sum(series)
    return total / len(series)
    
print(make_averager(100000))
print(make_averager(110000))
series.append(666)  # 如果对数据进行相应改变，那么你的平均收盘价就会出现很大的问题。
print(make_averager(120000))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;def make_averager(new_value):
    series = []
    series.append(new_value)
    total = sum(series)
    return total / len(series)


print(make_averager(100000))  # 100000.0
print(make_averager(110000))  # 110000.0
print(make_averager(120000))  # 120000.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样计算的结果是不正确的,那是因为执行函数，会开启一个临时的名称空间，随着函数的结束而消失，所以你每次执行函数的时候，都是重新创建这个列表，那么这怎么做呢？这种情况下，就需要用到我们讲的闭包了，我们用闭包的思想改一下这个代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def make_averager():
    
    series = []
    def averager(new_value):
        series.append(new_value)
        total = sum(series)
        return total/len(series)

    return averager

avg = make_averager()
print(avg(100000))
print(avg(110000))
print(avg(120000))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;大家仔细看一下这个代码，我是在函数中嵌套了一个函数。那么avg 这个变量接收的实际是averager函数名，也就是其对应的内存地址，我执行了三次avg 也就是执行了三次averager这个函数。那么此时你们有什么问题？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;肯定有学生就会问，那么我的make_averager这个函数只是执行了一次，为什么series这个列表没有消失？反而还可以被调用三次呢？这个就是最关键的地方，也是闭包的精华所在。我给大家说一下这个原理，以图为证：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://crm.pythonav.com/media/uploads/2019/04/12/IMAGE.PNG&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面被红色方框框起来的区域就是闭包，被蓝色圈起来的那个变量应该是make_averager()函数的局部变量，它应该是随着make_averager()函数的执行结束之后而消失。但是他没有，是因为此区域形成了闭包，series变量就变成了一个叫自由变量的东西，averager函数的作用域会延伸到包含自由变量series的绑定。也就是说，每次我调用avg对应的averager函数 时，都可以引用到这个自用变量series，这个就是闭包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包的定义：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;闭包是嵌套在函数中的函数。&lt;/li&gt;
&lt;li&gt;闭包必须是内层函数对外层函数的变量（非全局变量）的引用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如何判断判断闭包？举例让同学回答：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 例一：
def wrapper():
    a = 1
    def inner():
        print(a)
    return inner
ret = wrapper()

# 例二：
a = 2
def wrapper():
    def inner():
        print(a)
    return inner
ret = wrapper()


# 例三：

def wrapper(a,b):
    def inner():
        print(a)
        print(b)
    return inner
a = 2
b = 3
ret = wrapper(a,b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上三个例子，最难判断的是第三个，其实第三个也是闭包，如果我们每次去研究代码判断其是不是闭包，有一些不科学，或者过于麻烦了，那么有一些函数的属性是可以获取到此函数是否拥有自由变量的，如果此函数拥有自由变量，那么就可以侧面证明其是否是闭包函数了（&lt;strong&gt;了解&lt;/strong&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def make_averager():

    series = []
    def averager(new_value):
        series.append(new_value)
        total = sum(series)
        return total/len(series)

    return averager
avg = make_averager()
# 函数名.__code__.co_freevars 查看函数的自由变量
print(avg.__code__.co_freevars)  # ('series',)
当然还有一些参数，仅供了解：

# 函数名.__code__.co_freevars 查看函数的自由变量
print(avg.__code__.co_freevars)  # ('series',)
# 函数名.__code__.co_varnames 查看函数的局部变量
print(avg.__code__.co_varnames)  # ('new_value', 'total')
# 函数名.__closure__ 获取具体的自由变量对象，也就是cell对象。
# (&amp;lt;cell at 0x0000020070CB7618: int object at 0x000000005CA08090&amp;gt;,)
# cell_contents 自由变量具体的值
print(avg.__closure__[0].cell_contents)  # []&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;闭包的作用&lt;/strong&gt;：保存局部信息不被销毁，保证数据的安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闭包的应用&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以保存一些非全局变量但是不易被销毁、改变的数据。&lt;/li&gt;
&lt;li&gt;装饰器。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 16 Jan 2020 13:46:00 +0000</pubDate>
<dc:creator>Dylan_Yu</dc:creator>
<og:description>一、匿名函数 以后面试或者工作中经常用匿名函数 lambda，也叫一句话函数。 课上练习： 语法: 函数名 = lambda 参数:返回值 + 此函数不是没有名字，他是有名字的，他的名字就是你给其设置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guanshou/p/12203415.html</dc:identifier>
</item>
</channel>
</rss>