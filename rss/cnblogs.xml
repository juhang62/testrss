<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>图解--队列、并发队列 - K战神</title>
<link>http://www.cnblogs.com/sunchong/p/10105939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunchong/p/10105939.html</guid>
<description>&lt;p&gt;&lt;span&gt;提到队列，我们会在很多地方听到或者看到，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那我们来看一下这位不太说话的老朋友，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从栈很容易联想到队列的实现&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;栈是先进后出的数据结构，队列而言它是先进先出。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对栈而言，在栈顶有一个指针即可。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;队列是需要两个指针，一个在队头，一个在队尾。对应着入队操作和出队操作。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;基于数组实现的是顺序队列，基于链表实现的是链式队列。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个数组实现的顺序队列，在 入队了 AA 、BB 、CC 后，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;队头指针 head=0，队尾指针 tail=3。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181213232134723-2077365176.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;紧接着，又有两次出队，同样，对于出队head指针往后移动两个：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181213232658525-1360317574.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上两个图对应的如队出队操作，也是很容易看出问题所在：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着入队出队一波操作，tail指针很容易移动到最后的位置，表面上不能再入队了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是极有可能如图二一样，头指针head前面有大片空地。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么办？搬！我在出队之后，后面的数据往前挪，我们可以称之为移动补位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是每一次出队操作都去搬数据，时间复杂度想想就会很高 O(n)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;怎么优化？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tail指针抵达末尾，同时head指针不在队头。也就是tail到了最后，且head前面有空。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时触发数据搬移，过程如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181214000024252-1186826924.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;人的思想不断进步，并且思考如何做得更加轻巧灵活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们会思考，可不可以不用搬移数据呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以，接下来轮到循环队列登场了。。。。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;循环队列，顾名思义。首尾相连形成环。哝，就是这个样子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181215160934305-1149283432.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;长得这么好看，一定要对得起我们对它的期望。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过一番出队入队，头部索引=2，尾部指针指向最后一个位置，即将接受FF入队，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181214002917632-1585426194.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时看上去又到了挪动数组的时候了？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;环形的存在就是为了避免队列的数据搬移，我想你已经想到了它的灵巧之处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对，就是将数据FF填充到索引=5处，tail指针移动到下一个，也就是索引=0处，就成了这样：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181214003640478-1409868484.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;队列在平时工作时用的机会场景比较少，但是在一些偏底层系统中确实应用比较广泛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：阻塞队列、并发队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阻塞队列，就是在队空时，取数据会被直接拒绝。直到有数据才会允许被访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种模型类似于 生产-消费关系，对的，这也是很多的消息队列的思想和应用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种阻塞队列可以协调生产和消费的关系。当然，也可以生产的i消息被多个消费。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这又产生了一个线程并发问题，我们如何保证线程安全呢？这就需要并发队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于数组的循环队列+CAS原子操作，可以很好的实现无锁并发队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于以上，微软给我们所提供的这些源码：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;队列 Queue ;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;泛型队列 Queue&amp;lt;T&amp;gt;;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;阻塞泛型集合 BlockingCollection&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;以及微软强大的并行库中的并发泛型队列 ConcurrentQueue&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt; 我们着重看一下泛型队列和并发泛型队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;队列 Queue 、泛型队列 Queue&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们直接看一下泛型版本的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;0、注释说明：这是一个基于数组实现的环形队列，也就是循环队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181215215153522-1546756951.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、初始定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181215161616037-242119640.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、重要的私有变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181215163341337-372841160.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、入队：分为两块主逻辑，一个是队满，一个是正常插入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181215163043625-1152121799.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 第0步已经注释说明这是一个循环队列，所以我们借此机会分析一下这个循环队列。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;　　　_tail = (_tail + 1) % _array.Length; 下面我们来看看这句话怎么来的。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt; 对于非循环队列，头尾指针和数组的关系好确认。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 而循环队列，因为是一个环，所以怎样定位移动后的指针位置才是关键的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181214003640478-1409868484.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组长度=6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我入队FF，原来尾部指针=5，当前尾部指针=0；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接着入队GG,  原来尾部指针=0，当前尾部指针=1；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我入队HH，原来尾部指针=1，当前尾部指针=2；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;规律：当前指针 = （原来指针 +1） % 数组长度 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、出队同3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConcurrentQueue&amp;lt;T&amp;gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注释说的很明白，这是一个无锁并发队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在看源码之前先来了解一些定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于现在的多CPU、以及超线程概念的操作系统来说，CPU和内存之前存在处理速度上的差距，所以中间加了寄存器和高速缓存来缓冲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;多线程并发情况下，多核计算机，一个CPU读取的是在寄存器中的值，另一个CPU读取的是内存中的值，这就造成了数据不同步。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于产生的并发问题，我们来看看并发队列对这些的处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先来理解接下代码中涉及到的名词：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、易失结构 volatile : 告诉编译器和CLR不需要优化代码顺序，使得代码可控。不用将字段缓存到寄存器，缓存早内存中就行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、互锁结构  Interlocked : CAS保证原子性读取操作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、自旋锁 ：原地打转，直到达到条件才离开。对于线程来讲，一直持有资源不撒手。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、线程类提供了几个方法：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;Thread.Sleep(0)：挂起自身，让出剩余的时间片，强迫系统调度其他同级或者更高级的线程。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Thread.Sleep(1)：强迫进行一次上下文切换&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Thread.Ylied()：提前结束剩余的时间片，使得同级或者低级线程可能被调度。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Thread.SpinWait()：超线程CPU模式下，强迫自身暂停，允许CPU调度其他线程。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;5、CAS理论：&lt;strong&gt;compare and swap 比较并交换。该操作通过将内存中的值与指定数据进行比较，当数值一样时将内存中的数据替换为新的值。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;天也不早了，人也不少了，让我们干点正事。简单看看入队和出队操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;入队：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需求是怎样保证入队的原子性？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过 Interlocked 声明同步块，只允许一个线程抢占资源进行入队，其他线程使用自旋锁进行原地等待。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等当前线程释放同步块，其他线程再次抢占同步块，然后入队。直到队满跳出。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;下面这是声明了自旋锁，线程进行入队抢占。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181215235915525-656490919.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;m_high =-1 &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181220001741178-74675661.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;m_high 通过 Interlicked CAS原子操作，递增。进行入队或者队满判断。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181217121319484-953681233.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出队：也是类似，通过自旋锁，抢占同步块进行原子性出队操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后我们再来悄悄看看 自旋锁自旋逻辑：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181220003848511-225771916.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自旋至少10次，然后进行相应的自旋等待，并且相应的让出自己的时间片，让其他低级别线程可以得到调度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/201812/406456-20181220004528303-2115160333.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;总体来说，并发队列通过CAS进行原子性入队和出队，并结合自旋锁进行抢占资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是很多的线程并发入队或者出队，同一时刻只有一个可以进行原子性入队出队。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Dec 2018 16:57:00 +0000</pubDate>
<dc:creator>K战神</dc:creator>
<og:description>提到队列，我们会在很多地方听到或者看到， 那我们来看一下这位不太说话的老朋友， 从栈很容易联想到队列的实现 栈是先进后出的数据结构，队列而言它是先进先出。 对栈而言，在栈顶有一个指针即可。 队列是需要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunchong/p/10105939.html</dc:identifier>
</item>
<item>
<title>JS HTTP请求库(Axios、Request、Superagent、Fetch、Supertest)的优缺点 - pycmsj</title>
<link>http://www.cnblogs.com/pycmsj/p/10147073.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pycmsj/p/10147073.html</guid>
<description>&lt;p data-anchor=&quot;Axios&quot;&gt;Web 开发中客户端与服务器间的交互非常重要，它有利于客户端应用高度动态化。用户通过单击按钮的交互方式向服务器发送请求，服务器检索数据并返回，页面无需重新加载，直接使用返回的数据重新渲染其部分/整体内容，或者对数据进行操作。这其中的技术原理是 AJAX，通过 XMLHttpRequest 实例实现。 为了提升 AJAX 及 XMLHttpRequest 的使用体验，社区开发了一些无需处理 AJAX 和 XMLHttpRequest 就直接发出 HTTP 请求的库。本文将带你研究 5 个最流行的 HTTP 库，了解它们是如何实现的。&lt;/p&gt;
&lt;h2 data-anchor=&quot;Axios&quot;&gt;Axios&lt;/h2&gt;
&lt;p&gt;Axios 是一个基于 Promise 的 HTTP 库，可用在 Node.js 和浏览器上发起 HTTP 请求，支持所有现代浏览器，甚至包括 IE8+！&lt;/p&gt;

&lt;h3 data-anchor=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;p&gt;1、无序列表同时支持 Node.js 和浏览器&lt;/p&gt;
&lt;p&gt;2、支持 Promise API&lt;/p&gt;
&lt;p&gt;3、可以配置或取消请求&lt;/p&gt;
&lt;p&gt;4、可以设置响应超时&lt;/p&gt;
&lt;p&gt;5、支持防止跨站点请求伪造（XSRF）攻击&lt;/p&gt;
&lt;p&gt;6、可以拦截未执行的请求或响应&lt;/p&gt;
&lt;p&gt;7、支持显示上传进度&lt;/p&gt;
&lt;p&gt;8、广泛用于 React 和 Vue 项目&lt;/p&gt;
&lt;h3 data-anchor=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;p&gt;1、用起来比较麻烦&lt;/p&gt;

&lt;h2 data-anchor=&quot;Superagent&quot;&gt;Superagent&lt;/h2&gt;
&lt;p&gt;Superagent 是一个基于 Promise 的轻量级渐进式 AJAX API，非常适合发送 HTTP 请求以及接收服务器响应。 与 Axios 相同，它既适用于 Node，也适用于所有现代浏览器。&lt;/p&gt;

&lt;h3 data-anchor=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;p&gt;1、它有一个插件生态，通过构建插件可以实现更多功能&lt;/p&gt;
&lt;p&gt;2、表可配置&lt;/p&gt;
&lt;p&gt;3、HTTP 请求发送接口友好&lt;/p&gt;
&lt;p&gt;4、可以为请求链式添加方法&lt;/p&gt;
&lt;p&gt;5、适用于浏览器和 Node&lt;/p&gt;
&lt;p&gt;6、支持显示上传和下载进度&lt;/p&gt;
&lt;p&gt;7、表支持分块传输编码&lt;/p&gt;
&lt;p&gt;8、支持旧风格的回调&lt;/p&gt;
&lt;p&gt;9、繁荣的插件生态，支持众多常见功能&lt;/p&gt;
&lt;h3 data-anchor=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;p&gt;1、其 API 不符合任何标准&lt;/p&gt;

&lt;h2 data-anchor=&quot;Request&quot;&gt;Request&lt;/h2&gt;
&lt;p&gt;Request 提供了一种简化的 HTTP 请求方式。 你可以使用比其他 HTTP 库更少的代码来发起 HTTP 请求。 它不是基于 Promise 的，但如果你需要 Promise，你可以引入request-promise 库，将请求封装为 Promise 并返回。&lt;/p&gt;

&lt;h3 data-anchor=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;p&gt;1、API 简单易用&lt;/p&gt;
&lt;h3 data-anchor=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;p&gt;1、不基于 Promise&lt;/p&gt;

&lt;h2 data-anchor=&quot;Fetch&quot;&gt;Fetch&lt;/h2&gt;
&lt;p&gt;Fetch 是浏览器自带的用于发送请求的 API，旨在替代 XMLHttpRequest。&lt;/p&gt;

&lt;h3 data-anchor=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;p&gt;1、无序列表灵活易用&lt;/p&gt;
&lt;p&gt;2、无序列表使用 Promise 避免回调地狱&lt;/p&gt;
&lt;p&gt;3、无序列表支持所有现代浏览器&lt;/p&gt;
&lt;p&gt;4、无序列表遵循 request-response 方案&lt;/p&gt;
&lt;p&gt;5、无序列表语法简单清晰&lt;/p&gt;
&lt;p&gt;6、无序列表支持 React Native&lt;/p&gt;
&lt;h3 data-anchor=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;p&gt;1、无序列表不支持服务器端使用&lt;/p&gt;
&lt;p&gt;2、无序列表缺乏开发库的亮点功能，比如取消请求&lt;br/&gt;3、没有内置默认值，如请求模式，请求头，请求凭据。&lt;/p&gt;

&lt;h2 data-anchor=&quot;Supertest&quot;&gt;Supertest&lt;/h2&gt;
&lt;p&gt;Supertest 用于测试 Node.js HTTP 服务器。 该库由 SuperAgent 提供支持，它把自身的 API 和 SuperAgent 的底层 API 相结合，提供简洁的 HTTP 测试接口。&lt;/p&gt;

&lt;h3 data-anchor=&quot;优点&quot;&gt;优点&lt;/h3&gt;
&lt;p&gt;1、流畅的 API&lt;/p&gt;
&lt;p&gt;2、简单的 HTTP 断言&lt;/p&gt;
&lt;p&gt;3、可以与 Chai.js 和 Mocha 等不同的测试套件混用&lt;/p&gt;
&lt;h3 data-anchor=&quot;缺点&quot;&gt;缺点&lt;/h3&gt;
&lt;p&gt;1、不支持浏览器&lt;/p&gt;

&lt;h2 data-anchor=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;选择哪个库取决于你的项目、规模和目标用户，每个选择都有好有坏。 如果你为误判规格选择了错误的库，那就得考虑下这个问题，重新选择合适的工具。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Dec 2018 16:14:00 +0000</pubDate>
<dc:creator>pycmsj</dc:creator>
<og:description>Web 开发中客户端与服务器间的交互非常重要，它有利于客户端应用高度动态化。用户通过单击按钮的交互方式向服务器发送请求，服务器检索数据并返回，页面无需重新加载，直接使用返回的数据重新渲染其部分/整体内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pycmsj/p/10147073.html</dc:identifier>
</item>
<item>
<title>CSS3 的box-shadow进阶之 - 动画篇 - 制作辐射动画 - daisy,gogogo</title>
<link>http://www.cnblogs.com/daisygogogo/p/10147007.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daisygogogo/p/10147007.html</guid>
<description>&lt;p&gt;本篇文章是上一篇讲box-shadow基础知识的延伸，建议先花几分钟阅读那篇文章，&lt;a href=&quot;https://www.cnblogs.com/daisygogogo/p/10134320.html&quot; target=&quot;_blank&quot;&gt;点击阅读&lt;/a&gt;，再来看这篇。&lt;/p&gt;
&lt;p&gt;除了box-shadow属性知识外，制作动画，还需要对CSS3的animation, @keyframes制作动画有所了解。&lt;/p&gt;
&lt;p&gt;接下来，还是那张图。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312697/201812/1312697-20181219230803433-407500810.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;基本思路如下：&lt;/p&gt;
&lt;p&gt;1.写好一个div，&amp;lt;div class=&quot;circle&quot;&amp;gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;2.利用border-radius，把它变成一个圆&lt;/p&gt;
&lt;p&gt;3.给它添加after伪类，伪类也是一个一样大小的圆(不设置背景色)，跟当前的圆重叠在一起&lt;/p&gt;
&lt;p&gt;4.鼠标移入的时候，给伪类添加animation动画&lt;/p&gt;
&lt;p&gt;5.动画包括，opacity的变化，&lt;strong&gt;添加层叠阴影（关键）&lt;/strong&gt;，伪类放大2倍，就做好了我们要的效果了。&lt;/p&gt;
&lt;p&gt;感叹一下，CSS的伪类真是厉害~~好多情况下可以使用&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;div class=&quot;circle&quot;&amp;gt;&amp;lt;/div&amp;gt;　
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;body &lt;/span&gt;{&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;
    padding&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt;black&lt;/span&gt;;
 }&lt;span&gt;
.circle&lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt;50px&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt;50px&lt;/span&gt;;&lt;span&gt;
    border-radius&lt;/span&gt;:&lt;span&gt;50%&lt;/span&gt;;&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt;#f50ad5&lt;/span&gt;;&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt;80px&lt;/span&gt;;
  }&lt;span&gt;
  .circle:after&lt;/span&gt;{&lt;span&gt;
    content&lt;/span&gt;:&lt;span&gt;''&lt;/span&gt;;&lt;span&gt;
    display&lt;/span&gt;:&lt;span&gt;block&lt;/span&gt;;&lt;span&gt;
    left&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;
    top&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt;50px&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt;50px&lt;/span&gt;;&lt;span&gt;
    border-radius&lt;/span&gt;:&lt;span&gt;50%&lt;/span&gt;;
  }&lt;span&gt;

  .circle:hover:after&lt;/span&gt;{ /*鼠标入的时候，伪类元素的动画开始，动画名称就是下面@keyframes定义的circle*/&lt;span&gt;
    animation&lt;/span&gt;:&lt;span&gt; circle 1.3s  ease-out 75ms&lt;/span&gt;;
  }&lt;span&gt;

  @keyframes circle&lt;/span&gt;{&lt;span&gt;
    0% {
        opacity&lt;/span&gt;:&lt;span&gt; 0.4&lt;/span&gt;;
    }&lt;span&gt;
    40% &lt;/span&gt;{&lt;span&gt;
        opacity&lt;/span&gt;:&lt;span&gt; 0.7&lt;/span&gt;;&lt;span&gt;
        box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 2px rgba(255,255,255,0.3), 0 0 10px 10px black, 0 0 0 10px rgba(255,255,255,0.8)&lt;/span&gt;; /*三层阴影*/
    }&lt;span&gt;
    100% &lt;/span&gt;{&lt;span&gt;
        box-shadow&lt;/span&gt;:&lt;span&gt; 0 0 0 2px rgba(255,255,255,0.3), 0 0 10px 10px black, 0 0 0 10px rgba(255,255,255,0.8)&lt;/span&gt;;&lt;span&gt;
        transform&lt;/span&gt;:&lt;span&gt; scale(2)&lt;/span&gt;; /*放大两倍*/&lt;span&gt;
        opacity&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;
    }&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二张图实现起来就更简单了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312697/201812/1312697-20181219232544165-273492353.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接添加添加动画，放大阴影尺寸即可，代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
&amp;lt;button class=&quot;button&quot;&amp;gt;点击&amp;lt;/button&amp;gt;　
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  body &lt;/span&gt;{&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;
    padding&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;
    background&lt;/span&gt;:&lt;span&gt;black&lt;/span&gt;;
  }&lt;span&gt;
  .button&lt;/span&gt;{&lt;span&gt;
    width&lt;/span&gt;:&lt;span&gt;50px&lt;/span&gt;;&lt;span&gt;
    height&lt;/span&gt;:&lt;span&gt;35px&lt;/span&gt;;&lt;span&gt;
    color&lt;/span&gt;:&lt;span&gt;#f50ad5&lt;/span&gt;;&lt;span&gt;
    border&lt;/span&gt;:&lt;span&gt;2px solid #f50ad5&lt;/span&gt;;&lt;span&gt;
    background-color&lt;/span&gt;:&lt;span&gt;black&lt;/span&gt;;&lt;span&gt;
    margin&lt;/span&gt;:&lt;span&gt;80px&lt;/span&gt;;
  }&lt;span&gt;
  .button:hover&lt;/span&gt;{ /*鼠标移入的时候，动画开始*/&lt;span&gt;
        animation&lt;/span&gt;:&lt;span&gt; shine 0.4s linear&lt;/span&gt;;
  }&lt;span&gt;
  @keyframes shine&lt;/span&gt;{&lt;span&gt;
    0%{
        box-shadow&lt;/span&gt;:&lt;span&gt;0 0 0px 0px rgba(245, 10, 213,0.9)&lt;/span&gt;;
    }&lt;span&gt;
    100%&lt;/span&gt;{&lt;span&gt;
        box-shadow&lt;/span&gt;:&lt;span&gt;0 0 0px 25px rgba(245, 10, 213,0)&lt;/span&gt;; 
    }&lt;span&gt;
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;看似炫酷的动画，就这么简单做出来了，发挥想象力，还可以做出更有趣的动画哦。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;码字不易，觉得有帮助，请给个赞吧~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，文章为原创，如需转载，请注明出处，谢谢！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Dec 2018 15:43:00 +0000</pubDate>
<dc:creator>daisy,gogogo</dc:creator>
<og:description>本篇文章是上一篇讲box-shadow基础知识的延伸，建议先花几分钟阅读那篇文章，点击阅读，再来看这篇。 除了box-shadow属性知识外，制作动画，还需要对CSS3的animation, @key</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daisygogogo/p/10147007.html</dc:identifier>
</item>
<item>
<title>使用node.js的开发框架express创建一个web应用 - 木人子韦一日尘</title>
<link>http://www.cnblogs.com/murenziwei/p/10140950.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/murenziwei/p/10140950.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1.1：搭建环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    1.安装Express&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;         &lt;/strong&gt; 按键：Windows+R=&amp;gt;输入cmd，打开命令行，输入&lt;/p&gt;
&lt;pre&gt;
　　　　&lt;strong&gt;&lt;span&gt;npm install -g express@3&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;          我们需要用全局模式安装Express,因为只有这样，我们才能在命令行中使用它&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;         注意：这里我只选用Express 3.x版本，要是你对Express3x版本熟悉了的话，你只需看一下Migrating from 3.x to 4.x 的文档即可过渡到Express 4.x&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    2.新建一个工程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;         &lt;/strong&gt; 继续打开命令行，输入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;               &lt;span&gt;express -e murenziwei&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;           &lt;em&gt;&lt;strong&gt;注意：Express 3.x中使用ejs时不再是-t ejs,而是-e,可以输入express -h查看&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;            继续输入：（路径切换到文件夹murenziwei）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;               &lt;span&gt;cd murenziwei &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;           &lt;/strong&gt; 继续输入：（安装所需模块）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;               &lt;span&gt;npm install&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;             &lt;/strong&gt;如图所示&lt;/p&gt;
&lt;p&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181219000413363-209995927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;           &lt;/strong&gt; 安装成功后输入：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;               &lt;span&gt;node app&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181219000621152-1605855391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;            在浏览器上访问ocalhost:3000，如图以下：&lt;/p&gt;
&lt;p&gt;             &lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181219001053015-636262515.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.项目结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们回头看看生成的项目目录里面都有什么，打开我们的murenziwei文件夹，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181219220748047-50978693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;node_modules：存放package.json中安装的模块，当你在package.json中添加依赖的模块并安装后，该模块会存放在这个文件夹&lt;/li&gt;
&lt;li&gt;public：存放图片/样式/脚本等文件&lt;/li&gt;
&lt;li&gt;routes：存放路由文件&lt;/li&gt;
&lt;li&gt;views：存放视图文件，或者说是模板文件&lt;/li&gt;
&lt;li&gt;app.js：启动文件，或者说入口文件&lt;/li&gt;
&lt;li&gt;package.json：存储项目的信息及模块依赖，当在dependencies中添加依赖的模块时，运行npm install，npm会检查当前目录下的package.json，并自动安装所有指定的模块&lt;/li&gt;
&lt;li&gt;package-lock.json：记录整个node_modules文件夹的树状结构，加快安装模块的速度&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;让我们来看一看，打开app.js，究竟是什么代码组成？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/*
  Module dependencies.
 */

var express = require('express');
var routes = require('./routes');
var user = require('./routes/user');
var http = require('http');
var path = require('path');

var app = express();

// all environments
app.set('port', process.env.PORT || 3000);
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');
app.use(express.favicon());
app.use(express.logger('dev'));
app.use(express.json());
app.use(express.urlencoded());
app.use(express.methodOverride());
app.use(app.router);
app.use(express.static(path.join(__dirname, 'public')));

// development only
if ('development' == app.get('env')) {
  app.use(express.errorHandler());
}

app.get('/', routes.index);
app.get('/users', user.list);

http.createServer(app).listen(app.get('port'), function(){
  console.log('Express server listening on port ' + app.get('port'));
});　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们通过require()加载了express，http，path模块，还有routes文件夹下的index.js和user.js&lt;/p&gt;
&lt;p&gt;app.set('port', process.env.PORT || 3000):设置端口为process.env.PORT或者3000；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;app.set('port', process.env.PORT || 3000)：设置端口为process.env.PORT或者3000；&lt;/li&gt;
&lt;li&gt;app.set('views', path.join(__dirname, 'views'))：设置views文件夹为存放视图文件的目录，即存放模板文件的地方，__dirname为全局变量，存储当前正在执行的js所在的目录；&lt;/li&gt;
&lt;li&gt;app.set('view engine','ejs')：设置视图模块引擎为ejs&lt;/li&gt;
&lt;li&gt;app.use(express.favicon())：connect内建的中间件，使用默认的favicon图标，如果想使用自己的图标，需改为app.use(express.favicon(__dirname+&quot;/public/images/favicon.ico&quot;))，这里我们把自定义的favicon.icon放到/public/images文件夹下&lt;/li&gt;
&lt;li&gt;app.use(express.logger('dev'))：connect内建的中间件，在开发环境下使用，在终端显示简单的日志，例如在启动app.js后访问localhost:3000，终端会输出：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181219225247873-1420593890.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         如果没有这一行代码，不管你怎么刷新页面，终端都只有一行Express sever listening on port 3000&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181219225406917-29406967.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;         6.app.use(express.json());&lt;/p&gt;
&lt;p&gt;            app.use(urlencoded());&lt;/p&gt;
&lt;p&gt;            用来解析请求体，支持application/json，application/x-www-form-urlencoded&lt;/p&gt;
&lt;p&gt;         7.app.use(express.methodOverride())：connect内建的中间件，可以协助处理POST请求，伪装成 PUT，DELETE和其它HTTP方法&lt;/p&gt;
&lt;p&gt;         8.app.use(app.router)：调用路由解析的规则&lt;/p&gt;
&lt;p&gt;         9.app.use(express.static(path.join(__dirname, 'public')))：connect内创建的中间件，将根目录下的public文件夹设置为存放images，css，js等静态文件的目录    &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; ('development' == app.get('env'&lt;span&gt;)) {
  app.use(express.errorHandler());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此段代码可理解为：配置开发环境下的错误处理，输出错误信息&lt;/p&gt;
&lt;p&gt;         10.app.get('/', routes.index)：路由控制器，如果用户访问/（主页），则由routes.index来处理，routes/index.js的内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
exports.index = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(req, res){
  res.render(&lt;/span&gt;'index', { title: 'Express'&lt;span&gt; });
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 通过exports.index导出index函数接口，app.get('/',routes.index)相当于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
app.get(&quot;/&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(res,rep){

res.render(&lt;/span&gt;&quot;index&quot;,{title:&quot;Express&quot;&lt;span&gt;});

})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 解释一下上行的res.render(&quot;index&quot;,{title:&quot;Express&quot;})：使用ejs模板引擎解析views/index.ejs（因为我们之前通过app.set(&quot;views&quot;,__dirname+&quot;/views&quot;)设置了模板文件默认存储在views文件夹下），并传入一个对象，这个对象只有一个title属新，它的值为字符串Express，即用字符串Express替换views/index.ejs中所有的title变量，这就是我们所说的渲染视图，或者说渲染模板。&lt;/p&gt;
&lt;p&gt;       11.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
http.createServer(app).listen(app.get('port'), &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
  console.log(&lt;/span&gt;'Express server listening on port ' + app.get('port'&lt;span&gt;));
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码可以这样理解：创建http服务器并监听3000端口，创建成功后，终端显示如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181219233424580-1515847802.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们就可以在浏览器中访问localhost:3000了&lt;/p&gt;

&lt;p&gt;&lt;span&gt;最后总结一下我所讲的知识点：如何创建一个node项目并启动它，了解了项目的大体结构。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Dec 2018 15:39:00 +0000</pubDate>
<dc:creator>木人子韦一日尘</dc:creator>
<og:description>1.1.1：搭建环境 1.安装Express 按键：Windows+R=&gt;输入cmd，打开命令行，输入 我们需要用全局模式安装Express,因为只有这样，我们才能在命令行中使用它 注意：这里我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/murenziwei/p/10140950.html</dc:identifier>
</item>
<item>
<title>我为什么放弃MySQL？最终选择了MongoDB - 初一丶</title>
<link>http://www.cnblogs.com/wyl-0120/p/10146895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyl-0120/p/10146895.html</guid>
<description>&lt;p&gt;最近有个项目的功能模块，为了处理方便，需要操作集合类型的数据以及其他原因。考虑再三最终决定放弃使用MySQL，而选择MongoDB。&lt;/p&gt;
&lt;p&gt;两个数据库，大家应该都不陌生。他们最大的区别就是MySQL为关系型数据库，而MongoDB为非关系型数据库。常见的关系型数据库有：MySQL、Oracle、DB2、SQL Server、Postgre SQL等，非关系型数据库有MongoDB、Redis、Memcached、HBse等等。&lt;/p&gt;
&lt;h2 id=&quot;h1&quot;&gt;1、关系型数据库？ 非关系型数据库？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关系型数据库&lt;/strong&gt;可以理解为依赖一个模型来创建的数据库，比如我们使用的MySQL中的表是由横列和纵列组成的一个二维表格。关系型数据库可以通过关系模型使多个表的数据关联起来，比如我们平时说的 一对一、一对多、多对一。由于是建立在数据模型的基础上，所以我们可以通过SQL语句很方便的在多个表之间做复杂的查询操作。关系型数据库相对安全，因为直接存储在硬盘中所以突然的宕机、停电等意外不会导致数据丢失。MySQL的存储方式是由自身的引擎决定的,常用的引擎有Innodb和MyISAM。他们主要的区别就是MyISAM 不支持事务，强调的是性能，执行速度比Innodb要快，Innodb提供支持事务等高级数据库功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非关系型数据库&lt;/strong&gt;即我们常说的NoSQL数据库，部署起来都比较简单，没有关系型数据库那么复杂。Mongo的存储方式为虚拟内存+持久化存储，Mongo将数据写入内存中，再由虚拟内存管理器将其持久化到硬盘中，因此写操作会比关系型数据库快很多。NOSQL的存储格式是key-value形式，可以像关系型数据库那样存储基础数据类型的数据，也可以存储集合、对象等等。NoSQL虽然性能比较高，但是并不支持事物，也不能进行联表查询，一般用于较大规模数据的存储。&lt;/p&gt;
&lt;h2 id=&quot;h2&quot;&gt;2、他们的优点、缺点有哪些&lt;/h2&gt;
&lt;p&gt;关系型数据库发展了很长一段时间，拥有非常成熟的体系。所占份额也在逐渐增加。而且支持事物的操作，保证数据的一致性，可以通过SQL语句完成复杂的操作。但是使用过程中当数据量到达一定程度时，关系型数据库的效率会有明显的下降。一个复杂的查询操作，一系列的组合索引都会消耗非常多的内存空间，此时我们需要对数据库进行读写分离操作，或者将数据库结构进行拆分(水平拆分、垂直拆分)将请求压力分担在不同的库中。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;垂直拆分是指将一张表拆分成多个表，表之间通过主键进行关联。&lt;br/&gt;水平拆分是按照某种规则拆分成多个表，比如通过用户角色进行拆分&lt;br/&gt;读写分离：所谓读写分离就是讲读操作(查询数据)和写操作(插入&amp;amp;更新)指向不同的数据库节点，他们中间通过某种机制实现数据的同步，如binlog。实际的应用中大部分压力还是来自读操作，所以主要是一主多从的架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;非关系型数据库发展的这几年，深受人们的喜爱。免费开源、成本低、部署简单、非结构化存储等等明显的优势。而且它对海量数据处理能力非常强，内存级数据库，查询速度也非常快。存储的数据格式比较丰富，易于扩展，虽然不能使用sql进行复杂的查询，但是MongoDB支持JavaScript，所以可以通过js脚本进行复杂的数据库管理操作。关于NoSQL的缺点个人感觉目前就是不支持事物了吧，其他方面那都不是事儿。&lt;/p&gt;
&lt;h2 id=&quot;h3mongo&quot;&gt;3、什么时候用mongo&lt;/h2&gt;
&lt;p&gt;Mongo是用c++编写的，支持多种语言如：Java、Python、Ruby、PHP、C++、C# 等，有时候针对不同的业务需求，选择Mongo能够避免浪费很多不必要的资源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志系统&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;系统运行过程中产生的日志信息，一般种类较多、范围较大、内容也比较杂乱。通过MongoDB可以将这些杂乱的日志进行收集管理。不仅方便了管理，查找或者导出也会变得非常容易&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地理位置存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MongoDB支持地理位置、二维空间索引，可以存储经纬度，因此可以很快的计算出两点之间的距离，等位置信息。如查询附近的人、或者订餐系统、配送系统等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据规模增长很快&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面提到过关系型数据库数据量过大时，需要进行分库分表，这样真正操作起来可能会比较麻烦。如果选择mongo进行分库分表操作时，就会变得很简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保证高可用的环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Mongo本身就拥有高可用及分区的解决方案，设置主从服务器非常方便，除此之外Mongo还可以快速并且安全的实现故障节点的转移。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件存储需求&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;GridFS是MongoDB规范，用于存储和检索图片、音频、视频等大文件。GridFS虽然是文件存储的一种方式，可以存储超过16M的文件。但是它本身又是存储在MongoDB集合中的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其他场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如游戏开发中我们可以通过MongoDB存储用户信息、装备、积分等，除此之外物流系统、社交系统、甚至物联网系统，Mongo都能提供完美的数据存储服务。&lt;/p&gt;
&lt;h2 id=&quot;h4mysqlmongodb&quot;&gt;4.MySQL、MongoDB简单的性能测试&lt;/h2&gt;
&lt;p&gt;关于两个数据的性能，最有力的的说话还是通过实践来进行测试，网上看到一组测试数据，分享给大家。&lt;/p&gt;
&lt;p&gt;测试环境：Windows 10、内存8G、CPU i5 3.30GHZ。均无索引&lt;/p&gt;
&lt;p&gt;测试语言：Python&lt;/p&gt;
&lt;p&gt;链接工具：pymysql、pymongo&lt;/p&gt;
&lt;p&gt;MySQL &amp;amp;&amp;amp; Mongo 测试数据统计&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;
&lt;th&gt;提交次数&lt;/th&gt;
&lt;th&gt;单次提交个数&lt;/th&gt;
&lt;th&gt;MySQL运行时间（s）&lt;/th&gt;
&lt;th&gt;Mongo运行时间（s）&lt;/th&gt;
&lt;th&gt;数据量&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1000&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;3912&lt;/td&gt;
&lt;td&gt;1622.02&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;30&lt;/td&gt;
&lt;td&gt;1.61&lt;/td&gt;
&lt;td&gt;1000万&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;5.77&lt;/td&gt;
&lt;td&gt;1.60&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;2.35&lt;/td&gt;
&lt;td&gt;1.56&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;7.42&lt;/td&gt;
&lt;td&gt;1.60&lt;/td&gt;
&lt;td&gt;1000万&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;298.07&lt;/td&gt;
&lt;td&gt;5.29&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;496.18&lt;/td&gt;
&lt;td&gt;5.29&lt;/td&gt;
&lt;td&gt;1000万&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;欢迎关注我的个人公众号：【程序员共成长】&lt;/p&gt;
&lt;h5&gt;一个专门面向程序员群体的圈子，专注分享日常学习总结、业内资讯、优质学习视频资源， 这里不光有技术、还有诗和远方…给新加入的小伙伴准备了见面礼，包括但不限于Java、Python、Linux、数据库、大数据、架构以及各方向电子书。公众号内回复[礼包]即可领取。&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1457234/201812/1457234-20181219230641519-1517531011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Dec 2018 15:07:00 +0000</pubDate>
<dc:creator>初一丶</dc:creator>
<og:description>最近有个项目的功能模块，为了处理方便，需要操作集合类型的数据以及其他原因。考虑再三最终决定放弃使用MySQL，而选择MongoDB。 两个数据库，大家应该都不陌生。他们最大的区别就是MySQL为关系型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyl-0120/p/10146895.html</dc:identifier>
</item>
<item>
<title>【Netty】(7）---搭建websocket服务器 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10145083.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10145083.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;code&gt;说明&lt;/code&gt;:本篇博客是基于学习某网有关视频教学。&lt;br/&gt;&lt;code&gt;目的&lt;/code&gt;:创建一个websocket服务器,获取客户端传来的数据,同时向客户端发送数据&lt;/p&gt;
&lt;h2 id=&quot;一服务端&quot;&gt;&lt;span&gt;一、服务端&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;main主类&quot;&gt;&lt;span&gt;1、Main主类&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WSServer {
    public static void main(String[] args) throws Exception {

        // 定义一对线程组
        // 主线程组, 用于接受客户端的连接，
        EventLoopGroup mainGroup = new NioEventLoopGroup();
        // 从线程组, 负责IO交互工作
        EventLoopGroup subGroup = new NioEventLoopGroup();
        try {
            //netty服务器的创建, 辅助工具类，用于服务器通道的一系列配置
            ServerBootstrap server = new ServerBootstrap();
            //绑定两个线程组
            server.group(mainGroup, subGroup)
                    //指定NIO的模式
                    .channel(NioServerSocketChannel.class)
                    //子处理器，用于处理workerGroup
                    .childHandler(new WSServerInitialzer());

            // 启动server，并且设置8088为启动的端口号，同时启动方式为同步
            ChannelFuture future = server.bind(8088).sync();
            // 监听关闭的channel，设置位同步方式
            future.channel().closeFuture().sync();
        } finally {
            //退出线程组
            mainGroup.shutdownGracefully();
            subGroup.shutdownGracefully();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;wsserverinitialzer类子处理器&quot;&gt;&lt;span&gt;2、WSServerInitialzer类(子处理器)&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WSServerInitialzer extends ChannelInitializer&amp;lt;SocketChannel&amp;gt; {

    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline pipeline = ch.pipeline();

        // websocket 基于http协议，所以要有http编解码器 服务端用HttpServerCodec
        pipeline.addLast(new HttpServerCodec());
        // 对写大数据流的支持
        pipeline.addLast(new ChunkedWriteHandler());

      /**
         * 我们通常接收到的是一个http片段，如果要想完整接受一次请求的所有数据，我们需要绑定HttpObjectAggregator，然后我们
         * 就可以收到一个FullHttpRequest-是一个完整的请求信息。
         *对httpMessage进行聚合，聚合成FullHttpRequest或FullHttpResponse
         * 几乎在netty中的编程，都会使用到此hanler
         */
        pipeline.addLast(new HttpObjectAggregator(1024*64));

        // ====================== 以上是用于支持http协议 , 以下是支持httpWebsocket   ======================

        /**
         * websocket 服务器处理的协议，用于指定给客户端连接访问的路由 : /ws
         * 本handler会帮你处理一些繁重的复杂的事
         * 会帮你处理握手动作： handshaking（close, ping, pong） ping + pong = 心跳
         * 对于websocket来讲，都是以frames进行传输的，不同的数据类型对应的frames也不同
         */
        pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/ws&quot;));

        // 自定义的handler
        pipeline.addLast(new ChatHandler());
    }

}&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;chathandler助手类&quot;&gt;&lt;span&gt;3、ChatHandler(助手类)&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @Description: 处理消息的handler
 * TextWebSocketFrame： 在netty中，是用于为websocket专门处理文本的对象，frame是消息的载体
 *  这里已经指定了类型 如果这里是Object 那么下面还需判断是不是TextWebSocketFrame类型
 */
public class ChatHandler extends SimpleChannelInboundHandler&amp;lt;TextWebSocketFrame&amp;gt; {

    // 用于记录和管理所有客户端的channle
    private static ChannelGroup clients = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg)
            throws Exception {
        // 获取客户端传输过来的消息
        String content = msg.text();
        System.out.println(&quot;接受到的数据：&quot; + content);

//      for (Channel channel: clients) {
//          channel.writeAndFlush(
//              new TextWebSocketFrame(
//                      &quot;[服务器在]&quot; + LocalDateTime.now()
//                      + &quot;接受到消息, 消息为：&quot; + content));
//      }
        // 下面这个方法，和上面的for循环，一致   向客户端发送数据
        clients.writeAndFlush(new TextWebSocketFrame(&quot;我是服务器,我收到你的消息为:&quot; + content));

    }

    /**
     * 当客户端连接服务端之后（打开连接）
     * 获取客户端的channle，并且放到ChannelGroup中去进行管理
     */
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {
        clients.add(ctx.channel());
    }

    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        // 当触发handlerRemoved，ChannelGroup会自动移除对应客户端的channel,所以下面的remove不用我们再手写
//      clients.remove(ctx.channel());
        System.out.println(&quot;客户端断开，channle对应的长id为：&quot; + ctx.channel().id().asLongText());
        System.out.println(&quot;客户端断开，channle对应的短id为：&quot; + ctx.channel().id().asShortText());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里服务端已经写好了,和之前搭建的服务器大致没什么区别，主要区别在于ChannelPipeline添加了不同的Handel,助手类对websocket做了些处理工作。&lt;/p&gt;

&lt;h2 id=&quot;二客户端&quot;&gt;&lt;span&gt;二、客户端&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;客户端这边是采用Hbuilderx工具创建的前端项目，代码如下&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        
        &amp;lt;div&amp;gt;发送消息:&amp;lt;/div&amp;gt;
        &amp;lt;input type=&quot;text&quot; id=&quot;msgContent&quot;/&amp;gt;
        &amp;lt;input type=&quot;button&quot; value=&quot;点我发送&quot; onclick=&quot;CHAT.chat()&quot;/&amp;gt;
        
        &amp;lt;div&amp;gt;接受消息：&amp;lt;/div&amp;gt;
        &amp;lt;div id=&quot;receiveMsg&quot; style=&quot;background-color: gainsboro;&quot;&amp;gt;&amp;lt;/div&amp;gt;
        
        &amp;lt;script type=&quot;application/javascript&quot;&amp;gt;
            
            window.CHAT = {
                socket: null,
                init: function() {
                    &amp;lt;!--判断浏览器是否支持 websocket--&amp;gt;
                    if (window.WebSocket) {
                        &amp;lt;!--连接服务器websocket IP+端口号 ／ws是服务器WebSocketServerProtocolHandler添加的--&amp;gt;
                        CHAT.socket = new WebSocket(&quot;ws://127.0.0.1:8088/ws&quot;);
                        CHAT.socket.onopen = function() {
                            console.log(&quot;连接建立成功...&quot;);
                        },
                        CHAT.socket.onclose = function() {
                            console.log(&quot;连接关闭...&quot;);
                        },
                        CHAT.socket.onerror = function() {
                            console.log(&quot;发生错误...&quot;);
                        },
                        CHAT.socket.onmessage = function(e) {
                            console.log(&quot;接受到消息：&quot; + e.data);
                            var receiveMsg = document.getElementById(&quot;receiveMsg&quot;);
                            var html = receiveMsg.innerHTML;
                            receiveMsg.innerHTML = html + &quot;&amp;lt;br/&amp;gt;&quot; + e.data;
                        }
                    } else {
                        alert(&quot;浏览器不支持websocket协议...&quot;);
                    }
                },
                &amp;lt;!--onclick事件触发--&amp;gt;
                chat: function() {
                    
                    &amp;lt;!--获取消息,发送消息--&amp;gt;
                    var msg = document.getElementById(&quot;msgContent&quot;);
                    CHAT.socket.send(msg.value);
                }
            };
            
            &amp;lt;!--初始化方法--&amp;gt;
            CHAT.init();
            
        &amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;三测试&quot;&gt;&lt;span&gt;三、测试&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181219185500596-1330585977.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过测试可以总结&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、页面初始化的时候就已经成功和服务端websocket建立连接成功。
2、服务端收到客户端数据,并向客户端发送数据。
3、当关闭页面的时候,既相当于关闭了该websocket连接,服务端会自动移除。&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 19 Dec 2018 14:57:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>【Netty】(7） 搭建websocket服务器 :本篇博客是基于学习某网有关视频教学。 :创建一个websocket服务器,获取客户端传来的数据,同时向客户端发送数据 一、服务端 1、Main主类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10145083.html</dc:identifier>
</item>
<item>
<title>.Net core2.0+Mysql5.7部署到CentOS7.5完整实践经验 - jomz</title>
<link>http://www.cnblogs.com/jomzhang/p/10139798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jomzhang/p/10139798.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　　　本文为本人最近学习将.Net Core部署到Linux的一些经验总结，也提供点也和我一样对Linux接触不多的.Net Core开发者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一.部署用到的环境和工具&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;1.Linux采用最新的CentOS7.5版本，开发使用VS2017搭配的.Net Core 为2.0的SDK版本号2.1.202(可到微软官方下载：https://dotnet.microsoft.com/download/dotnet-core/2.0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;2.数据库为Mysql 5.7版本，同CentOS系统一样部署在同一个腾讯云服务器上（配置为1C2G1M）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3.Linux的SSH2客户端使用XShell6，文件传输使用WinScp,可以自行下载，我这打包一份网上收集的（https://pan.baidu.com/s/1_tKLCcRQQYjDIpZ49fUEiQ 提取码: v9uu ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　4.在CentOS上用Git代码管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　5.反向代理工具使用jexus&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.CentOS发布环境搭建&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218203043348-1271249650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;1.从0开始，重装了云服系统。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218203457298-66938738.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;　2.使用XShell连接到云服。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.安装Mysql5.7&lt;/strong&gt;,本文参考的《Centos7安装mysql5.7》：https://www.jianshu.com/p/c76dc730a800&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第1步：下载mysql的rmp package&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# wget https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　完成截图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218204350741-1505873232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第2步：安装repo&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# rpm -ivh mysql57-community-release-el7-&lt;span&gt;9&lt;/span&gt;.noarch.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　完成截图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218204625991-2014448474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;第3步：安装mysql-server&lt;/strong&gt;,安装过程中出现2次选择一律按y回车，大概3到5分钟就安装完成了。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# yum install mysql-server
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　    &lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218205340800-1785086101.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　完成截图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218205245802-1547512134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;strong&gt;第4步：配置mysql密码和默认字符集&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# vim /etc/my.cnf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这时候要是不会用vi的人就有点懵了（我也是），我在这大概讲下操作，vi打开了my.cnf，无法使用鼠标，编辑前按i才能编辑，编辑完成后按Esc退出编辑状态，最后按:x回车保存退出。如果输错请不要用Ctrl+z来撤销用Ctrl+s保存，因为没用，文件写的混乱了可以用:q!不保存退出,注意有个英文冒号:不能漏了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;默认字符集一定要修改了，不然EF生成的数据库字符集编码不支持中文导致发布到Linux上程序出错&lt;/p&gt;
&lt;p&gt;　　在[mysqld]最下面添加字符集&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
character-&lt;span&gt;set&lt;/span&gt;-server =&lt;span&gt; utf8mb4
collation&lt;/span&gt;-server = utf8mb4_general_ci
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再添加权限过滤代码（后面改完密码要删除）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
character-&lt;span&gt;set&lt;/span&gt;-server =&lt;span&gt; utf8mb4
collation&lt;/span&gt;-server = utf8mb4_general_ci
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后在下面添加[client]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[client]
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;-character-&lt;span&gt;set&lt;/span&gt; = utf8mb4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后编辑样子为：&lt;strong&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218210350712-166154194.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　然后启动mysql:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service mysqld start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218211810216-1219498639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　匿名登录mysql&lt;/p&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218211921762-16202477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　更改mysql密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; update mysql.user &lt;span&gt;set&lt;/span&gt; authentication_string=PASSWORD(&lt;span&gt;'mima&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;where&lt;/span&gt; user=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; and hosst=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　更新权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
flush privileges;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218212138142-1393466017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在输入quit退出mysql,打开之前编辑的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
vim /etc/my.cnf 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　把之前标记的跳过权限的代码删除后保存退出&lt;/p&gt;
&lt;p&gt; 　　重启myql（重启：service mysqld restart；开启：service mysql start;关闭 service mysqld stop）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service mysqld restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218212625287-1027455560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　使用mysql -u root -p登录mysql&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218212743788-1297564267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　再一次修改密码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ALTER USER &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;你的密码&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218213124821-884807831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后配置远程连接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql&amp;gt; GRANT ALL PRIVILEGES ON *.* TO &lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; IDENTIFIED BY &lt;span&gt;'&lt;/span&gt;&lt;span&gt;mima&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; WITH GRANT OPTION;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218213647388-719576923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　这样myslq环境就算是配置好了&lt;/p&gt;

&lt;p&gt; 　　&lt;strong&gt;4.安装DotCore 2.0 SDK&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这里安装DotCore SDK和安装jexus都是完全参考《.Net Core部署到CentOS》地址：https://www.cnblogs.com/CKExp/p/8409563.html&lt;/p&gt;
&lt;p&gt;　　4.1.配置dotnet产品Feed&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
sudo rpm --import https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc&lt;/span&gt;
sudo sh -c &lt;span&gt;'&lt;/span&gt;&lt;span&gt;echo -e &quot;[packages-microsoft-com-prod]&lt;/span&gt;
name=packages-microsoft-com-&lt;span&gt;prod 
baseurl&lt;/span&gt;= https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/yumrepos/microsoft-rhel7.3-prod&lt;/span&gt;
enabled=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgcheck&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
gpgkey&lt;/span&gt;=https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;packages.microsoft.com/keys/microsoft.asc&quot; &amp;gt; /etc/yum.repos.d/dotnetdev.repo'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4.2.安装SDK，注意版本！！！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo yum update
sudo yum &lt;/span&gt;-&lt;span&gt;y install libunwind libicu
sudo yum install dotnet&lt;/span&gt;-sdk-&lt;span&gt;2.1&lt;/span&gt;.&lt;span&gt;202&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也是1路按y,这回等待时间有点长，15分钟差不多搞定。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218220130985-1497226667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5.安装jexus&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
curl https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jexus.org/release/x64/install.sh|sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218220316607-1336063470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　6&lt;strong&gt;.安装git&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　　参考yolo_bean的《linux（centos)下安装git并上传代码》：https://www.cnblogs.com/yolo-bean/p/7808767.html，本人只安装没做其他配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv ~]# yum  install  git
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218220826481-632723189.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　7&lt;strong&gt;.将代码库中代码用git下载到CentOS并发布&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
git clone 你项目的SSH地址
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218221243629-353996057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里会要求输入用户名和密码，输入密码时候是看不到的输完直接回车就完事。&lt;/p&gt;
&lt;p&gt;　　至此，我们看到root文件夹下有了一个项目，一个mysql的安装文件&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218221408144-1267324434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　现在cd到启动的web项目中去执行dotnet build&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218221743832-1919955131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　然后发布项目到/var/www/自定义文件夹&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@instance-93h418iv Ator.Site]# dotnet publish -o /var/www/Ae
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218222057982-1130218714.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这样项目就发布完成了，最后只要使用jexus代理&lt;/p&gt;
&lt;p&gt; 　　8&lt;strong&gt;.使用jexus代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 　   参考自https://www.cnblogs.com/CKExp/p/8409563.html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 1、切换到Jexus配置文件目录&lt;/span&gt;
cd /usr/jexus/&lt;span&gt;siteconf
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 2、复制默认的配置文件为Ae&lt;/span&gt;
cp &lt;span&gt;default&lt;/span&gt;&lt;span&gt; Ae
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 3、编辑配置文件，这里端口为8080，若用80请把defualt中默认的80改为其他端口,Ator.Site.dll为Web项目生成的dll为主入口文件&lt;/span&gt;
&lt;span&gt;vi Ae

######################
# Web Site: Ae
########################################
port&lt;/span&gt;=&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
root&lt;/span&gt;=/ /&lt;span&gt;var&lt;/span&gt;/www/&lt;span&gt;Ae
hosts&lt;/span&gt;= *    #OR your.com,*&lt;span&gt;.your.com

AppHost&lt;/span&gt;={CmdLine=dotnet /&lt;span&gt;var&lt;/span&gt;/www/Ae/Ator.Site.dll;AppRoot=/&lt;span&gt;var&lt;/span&gt;/www/Ae/;Port=&lt;span&gt;5000&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1159596/201812/1159596-20181218223056489-662778966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后重启下jexus&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 如果已启动 Jexus：&lt;/span&gt;
sh /usr/jexus/&lt;span&gt;jws restart

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 如果未启动 Jexus：&lt;/span&gt;
sh /usr/jexus/jws start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　然后就可以正常根据Ip地址和端口进行访问了。&lt;/p&gt;
&lt;p&gt;　完结&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 　　参考博文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　https://www.cnblogs.com/CKExp/p/8409563.html&lt;/p&gt;
&lt;p&gt;　　https://www.jianshu.com/p/c76dc730a800&lt;/p&gt;
&lt;p&gt;　　https://www.cnblogs.com/yolo-bean/p/7808767.html&lt;/p&gt;

</description>
<pubDate>Wed, 19 Dec 2018 14:55:00 +0000</pubDate>
<dc:creator>jomz</dc:creator>
<og:description>本文为本人最近学习将.Net Core部署到Linux的一些经验总结，也提供点也和我一样对Linux接触不多的.Net Core开发者。 一.部署用到的环境和工具 1.Linux采用最新的CentOS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jomzhang/p/10139798.html</dc:identifier>
</item>
<item>
<title>asp.net core mcroservices 机构之 分布式日志（一） - 一夜寒江</title>
<link>http://www.cnblogs.com/ck0074451665/p/10146838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ck0074451665/p/10146838.html</guid>
<description>&lt;p&gt;&lt;span&gt;  &lt;span&gt;    一 简介                                                                                                                                                        &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;             &lt;span&gt;无论是微服务还是其他任何分布式系统，都需要一个统一处理日志的系统，这个系统必须有收集，索引，分析查询的功能。asp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;.net core自己的日志是同步方式的，正如文档所言：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;file:///C:/Users/Administrator/AppData/Local/Temp/OpenLiveWriter-1290802399/supfiles2468BF15/image%5B3%5D.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;file:///C:/Users/Administrator/AppData/Local/Temp/OpenLiveWriter-1290802399/supfiles2468BF15/image_thumb%5B1%5D.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;184&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以必须自己提供一个日志提供程序，那正如文档所言，还有什么比kafka更合适的呢。从kafka往后那就是elasticsearch kibana，那是自然而然的事情。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    二 asp.net core 日志详解                                                                                                                             &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;span&gt;   &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         概念：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                   类别：类别是以使用的用途进行分类的，比如var log= LoggerFac.CreateLogger&amp;lt;Startup&amp;gt;();这一句，以StartUp类的全名作为一个分类，还有一些内置的system，Microsoft，主要是为了更细粒度控制日志。如果StartUp类出现了问题，打印日志就可以控制在StartUp这一类别下，为这个类别设置debug，仅仅打印这个类别这个级别的日志信息，使用filter功能可以很容易控制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                  日志级别：Trace，debug，info，warning，error等&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;                                                                              &lt;span&gt;   &lt;span&gt;Trace：这个级别开发一般不会用，是组件或者平台提供商为调试错误用的【windows专用】，因为可以看到组件内部运行状况，而且会有很大安全隐患，所以不建议在生产开启这个功能，比如mysql lib库的trace可以打印出数据库连接字符串的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;                  日志提供程序：日志提供程序可以看作日志信息的的io重定向。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                             控制台：这个不用说了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                             调试：就是debug，在 Linux 中，此提供程序将日志写入 /var/log/message。在windows中就是经典的&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/api/system.diagnostics.debug&quot;&gt;System.Diagnostics.Debug&lt;/a&gt;功能，这是.net提供的调试功能，非常详细，在开发中非常有用。下面是vs中最常见的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;file:///C:/Users/Administrator/AppData/Local/Temp/OpenLiveWriter-1290802399/supfiles2468BF15/image%5B8%5D.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;file:///C:/Users/Administrator/AppData/Local/Temp/OpenLiveWriter-1290802399/supfiles2468BF15/image_thumb%5B4%5D.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;362&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;                                                                                     &lt;span&gt;EventSource 提供程序在windows下可用，在linux下没可用但是没有相关事件，所以和没用一样。&lt;/span&gt;&lt;/h5&gt;
&lt;p&gt;                                                                                    &lt;span&gt;Windows EventLog 提供程序和TraceSource 提供程序都是在windows环境下是使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     三 开发                                                                                                                                               &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        &lt;span&gt;添加各种事件提供程序：因为是windows下所以EventSource事件是可以用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 var host = new WebHostBuilder().ConfigureAppConfiguration((webHostBuild,configBuild) =&amp;gt;
            {
                var env = webHostBuild.HostingEnvironment;

                configBuild.AddJsonFile(&quot;appsettings.json&quot;)
                .AddJsonFile($&quot;appsettings.{env.EnvironmentName}.json&quot;
                ,optional:true,reloadOnChange:true)
                .SetBasePath(Directory.GetCurrentDirectory());
            }).ConfigureLogging((hostingContext, logging) =&amp;gt; {
                logging.AddConfiguration(hostingContext.Configuration.GetSection(&quot;Logging&quot;))
                .AddConsole()
                .AddDebug()
                .AddEventSourceLogger();
            }).UseKestrel()
            .UseStartup&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;();
             host.Start();
            Console.ReadKey();
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Debug&quot;,
      &quot;System&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Information&quot;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;日志配置：默认日志debug,system分类info级别，Microsoft分类是info级别。这个LogLevel下的节点就是日志筛选功能。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Debug&quot;,
      &quot;System&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Information&quot;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181219225318663-430974659.png&quot;&gt;&lt;img title=&quot;image_thumb&quot; src=&quot;https://img2018.cnblogs.com/blog/46403/201812/46403-20181219225319266-294033489.png&quot; alt=&quot;image_thumb&quot; width=&quot;244&quot; height=&quot;102&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印出来的框起来的都是EventSource的事件，我自定义的就是那些汉字部分，而debug的没有打印出来，因为debug使用net的trace日志系统，需要去配置Trace，而且只支持windows环境。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;            &lt;span&gt;总结：asp.net core中集成了很多以前.net的功能，虽然部分可以用上，部分用不上，比如debug模式，vs开发一直再用。而trace和debug技术体系一致，但是trace只能在.net freamwork平台上跑.一切应该都是为了兼容开发平台和运行环境吧。下一章我们一起来看看自定义日志提供以及与kafka的集成&lt;span&gt;&lt;span&gt;           &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 19 Dec 2018 14:53:00 +0000</pubDate>
<dc:creator>一夜寒江</dc:creator>
<og:description>一 简介 无论是微服务还是其他任何分布式系统，都需要一个统一处理日志的系统，这个系统必须有收集，索引，分析查询的功能。asp .net core自己的日志是同步方式的，正如文档所言： 所以必须自己提供</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ck0074451665/p/10146838.html</dc:identifier>
</item>
<item>
<title>【分分钟内搭建一个带用户系统的博客程序（一）用户系统】asp.net core的Identity真香，EF真香！ - 不咬人的蚊子</title>
<link>http://www.cnblogs.com/oukichi/p/10134346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/oukichi/p/10134346.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;不用不知道，一用香到爆。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老哥是个屌丝前端，但也想写点web应用耍一耍。之前弄过了NodeJs，也弄过JAVA，最近由于写游戏的原因用C#，索性上手一波asp.net core。&lt;/p&gt;
&lt;p&gt;这篇博客记录的是，&lt;span&gt;&lt;strong&gt;如何在分分钟内搭建一个博客程序。&lt;/strong&gt;&lt;/span&gt;包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;发博客&lt;/li&gt;
&lt;li&gt;看博客&lt;/li&gt;
&lt;li&gt;用户注册登录&lt;/li&gt;
&lt;li&gt;用户权限设置。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中用的就是微软提供的EntityFrame和Identity类库。简直他妈爽出翔。&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;反正增删改查就那么回事儿，快速生成一个项目模板才是主要的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217222547468-689529780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217222704260-519566749.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我不想创建一个带Razor页面的项目。因为我只需要API。&lt;span&gt;老夫可是个前端！&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217223022824-18884904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这个时候按F5运行网站，然后就可以用Postman向 http://localhost:55536/api/values发送请求了。如果有过开发经验的人一眼就能看明白这是怎么回事儿。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;添加用户系统的意思是，允许用户注册和登录。&lt;/p&gt;
&lt;p&gt;如果我用NodeJs或者Java，我就要开始写数据库了，甚至设计数据表。可是微软已经把好用的东西给准备好了，那就是：Identity类库。这个类库老JB好了。我只需要轻轻点几下，一套完备的用户系统就能生成到我的代码上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217233821874-11452736.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217233854809-650225880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217234451436-597206520.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt; 我现在来解释一波我进行了什么操作。&lt;/p&gt;
&lt;p&gt;1.刚才我加的一大堆东西，其实就是最开始创建项目的时候，“身份验证”那一部分帮我们做的事。当时我没选，现在我手动加上。&lt;/p&gt;
&lt;p&gt;2.上面这个图，“替代所有文件”这部分如果选中，框架会帮我们生成相应的业务逻辑和Html模板（当然是Razor模板）。&lt;/p&gt;
&lt;p&gt;3.因为注册登录需要和数据库交互，所以“新建数据库上下文类”帮我们新生成了一个和数据库交互的上下文类。这个类是EntityFramework提供的。巨牛逼巨方便。&lt;/p&gt;
&lt;p&gt;4.“新建用户类”，这没什么好说的吧？这个用户类用于和数据库的用户表进行对应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 这下我们牛逼了。然后你会发现项目目录里多了一些文件，这些都是asp.net core帮我们生成的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181217235716768-456355879.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以随便探索一下。那个Readme.txt文件可以读一下。是一个指导手册，告诉你接下来要怎么做。&lt;/p&gt;

&lt;p&gt;如readme文件所说，一步一步来。我还是贴出来readme文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Support &lt;span&gt;for&lt;/span&gt;&lt;span&gt; ASP.NET Core Identity was added to your project
&lt;/span&gt;- The code &lt;span&gt;for&lt;/span&gt; adding Identity to your project was generated under Areas/&lt;span&gt;Identity.

Configuration of the Identity related services can be found &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; the Areas/Identity/&lt;span&gt;IdentityHostingStartup.cs file.

If your app was previously configured to use Identity, then you should remove the call to the AddIdentity method &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; your ConfigureServices method.
&lt;span&gt;//生成的UI需要静态文件支持，用下面这段代码使你的app支持静态文件&lt;/span&gt;
The generated UI requires support &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; files. To add &lt;span&gt;static&lt;/span&gt;&lt;span&gt; files to your app:
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. Call app.UseStaticFiles() &lt;span&gt;from&lt;/span&gt;&lt;span&gt; your Configure method
&lt;span&gt;//用下面这段代码开启身份认证功能&lt;/span&gt;
To use ASP.NET Core Identity you also need to enable authentication. To authentication to your app:
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. Call app.UseAuthentication() &lt;span&gt;from&lt;/span&gt; your Configure method (after &lt;span&gt;static&lt;/span&gt;&lt;span&gt; files)
&lt;span&gt;//生成的UI需要MVC支持，用这面这段代码开启MVC功能&lt;/span&gt;
The generated UI requires MVC. To add MVC to your app:
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. Call services.AddMvc() &lt;span&gt;from&lt;/span&gt;&lt;span&gt; your ConfigureServices method
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;. Call app.UseMvc() &lt;span&gt;from&lt;/span&gt;&lt;span&gt; your Configure method (after authentication)
&lt;span&gt;//生成的数据库结构需要你执行Migration来同步数据库&lt;/span&gt;
The generated database code requires Entity Framework Core Migrations. Run the following commands:&lt;br/&gt;&lt;span&gt;//在cmd中执行下面两个命令
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. dotnet ef migrations add CreateIdentitySchema
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. dotnet ef database update&lt;br/&gt;&lt;span&gt;//或者 在包管理命令行执行下面两个命令&lt;/span&gt;
 Or &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; the Visual Studio Package Manager Console:
&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;. Add-&lt;span&gt;Migration CreateIdentitySchema
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;. Update-&lt;span&gt;Database

Apps that use ASP.NET Core Identity should also use HTTPS. To enable HTTPS see https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;go.microsoft.com/fwlink/?linkid=848054.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt; 按照上面的操作来撸好app以后。框架就搭成了。牛逼到爆。一行代码都没写，一个非常完备的基础架子已经OK了。&lt;/p&gt;
&lt;p&gt;需要注意的是，你要额外安装EntityFramework类库。这个百度教程太多了。我就不说了。&lt;/p&gt;
&lt;p&gt;当你执行完那两个命令后，你会发现你的数据库里多了一些表。酷！成功了。&lt;/p&gt;
&lt;p&gt;注：在这里执行命令的时候可能会说EntityFramework没安装什么的这时候不要虚，仔细看输出，会说你装了EF6和EFCore，你要指定一下用哪个EF来运行命令，asp.net core的话就用 &lt;span&gt;EntityFrameworkCore\Update-Database&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实注册的业务逻辑已经生成好了，直接拿来用就可以。去Areas/Identity/Pages/Account/Register.cshtml里面，可以看到这段代码。稍微改动一下就可以拿来用了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;首先是，我打算用Postman模拟用户前端的输入，后端在注册的时候接收3个值，邮箱，用户名，密码。于是俺创建一个类代表这个数据格式。强类型语言就是爽。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserRegisterInput
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; UserName { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Email { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Password { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; RememberMe { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在开始写controller。新建一个APIController，这个简直不用再描述了。最后Controller代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Identity;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TinyBlog2.Areas.Identity.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TinyBlog2.DTO;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TinyBlog2.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; UserManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; _userManager;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserController(UserManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; userManager)
        {
            _userManager &lt;/span&gt;=&lt;span&gt; userManager;
        }
        [HttpPost]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Reg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)] &lt;span&gt;//这里是你的路由地址 post发往 https://localhost:55683/api/user/reg
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Post([FromBody] UserRegisterInput Input)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt; TinyBlog2User { UserName = Input.UserName, Email =&lt;span&gt; Input.Email };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.CreateAsync(user, Input.Password);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Succeeded)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;注册成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }
        }

        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我用Postman发一波请求试试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181218235707230-1404476952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 注册的最后，查看数据库，你的用户显然已经存在数据库里了。这些数据表都是asp.net core + EntityFramework给我们建立好的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219000059476-2012861077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;接下来我要做的是，给某个Action增加权限校验，说句白话就是，有的接口我希望登录用户才能访问，有的接口我希望管理员才能访问，或者有的接口我希望只有付费Vip才能访问。怎么做呢？&lt;/p&gt;
&lt;p&gt;这里用已经存在的ViewController来举例子。目前为止，ValueController的数据是谁都可以访问的。但是我来加一行代码，就一行！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
        &lt;span&gt;[Authorize(Policy &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &quot;VipOnly&quot;)]//很明显，从此这个Action只能是Vip才能访问。
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;显然我定制了一个策略，这个策略名字叫做VipOnly。那么接下来我要定义这个策略。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;span&gt;services.AddAuthorization(options &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&amp;gt;
            {
                options.AddPolicy(&quot;VipOnly&quot;, policy =&amp;gt; policy.RequireClaim(&quot;Role&quot;, &quot;VipUser&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;));
            });&lt;/span&gt;
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我在startup.cs里面加入这一行代码，应该显而易见。意思是：增加一个名为VipOnly的策略，这个策略的要求是，如果用户有一个属性Role，这个Role的值是VipUser，那么就符合这个策略。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Claim就是用户的一个属性。这个属性可以在任何时候创建。这个Claim也是Asp.net core提供给我们的工具！很方便。来看一波代码吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;5.1 如何给用户添加一个Claim&lt;/h2&gt;
&lt;p&gt;我更改了一下注册流程，每一个注册用户都被默认设置为VipUser&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpPost]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Reg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Post([FromBody] UserRegisterInput Input)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt; TinyBlog2User { UserName = Input.UserName, Email =&lt;span&gt; Input.Email };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.CreateAsync(user, Input.Password);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给用户增加一个Claim&lt;/span&gt;
            &lt;span&gt;var addClaimResult = await _userManager.AddClaimAsync(user, new System.Security.Claims.Claim(&quot;Role&quot;, &quot;VipUser&quot;));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Succeeded)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;注册成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简单到爆炸不是吗？我现在注册一个用户，就会看到这个用户被添加了一个Claim，Role=VipUser&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219212612167-354450656.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219212742905-396616178.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219212819688-1444194035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt; 用户登录的原理是JWT。是一个独立知识点。这里我只提供代码。教程网上一堆。需要我写的话请留言，我再补充。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_d26259c8-c992-4ebf-bbe3-38092aa42ac9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d26259c8-c992-4ebf-bbe3-38092aa42ac9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d26259c8-c992-4ebf-bbe3-38092aa42ac9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.IdentityModel.Tokens.Jwt;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Security.Claims;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Http;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Identity;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.IdentityModel.Tokens;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TinyBlog2.Areas.Identity.Data;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; TinyBlog2.DTO;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TinyBlog2.Controllers
{
    [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; UserManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; _userManager;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IConfiguration _config;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; SignInManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; _signInManager;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; UserController(UserManager&amp;lt;TinyBlog2User&amp;gt; userManager, IConfiguration configuration, SignInManager&amp;lt;TinyBlog2User&amp;gt;&lt;span&gt; signInManager)
        {
            _config &lt;/span&gt;=&lt;span&gt; configuration;
            _signInManager &lt;/span&gt;=&lt;span&gt; signInManager;
            _userManager &lt;/span&gt;=&lt;span&gt; userManager;
        }
        [HttpPost]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Reg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Post([FromBody] UserRegisterInput Input)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = &lt;span&gt;new&lt;/span&gt; TinyBlog2User { UserName = Input.UserName, Email =&lt;span&gt; Input.Email };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.CreateAsync(user, Input.Password);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;给用户增加一个Claim&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; addClaimResult = &lt;span&gt;await&lt;/span&gt; _userManager.AddClaimAsync(user, &lt;span&gt;new&lt;/span&gt; System.Security.Claims.Claim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VipUser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result.Succeeded &amp;amp;&amp;amp;&lt;span&gt; addClaimResult.Succeeded)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将加密后的密码用JWT指定算法进行加密&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; creds = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到当前登录用户&lt;/span&gt;
                TinyBlog2User currentUser = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.FindByEmailAsync(Input.Email);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前用户的Claims&lt;/span&gt;
                IList&amp;lt;Claim&amp;gt; claimsList = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.GetClaimsAsync(currentUser);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; unSecruityToken = &lt;span&gt;new&lt;/span&gt; JwtSecurityToken(_config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], _config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], claimsList, expires: DateTime.Now.AddMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;), signingCredentials: creds);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler().WriteToken(unSecruityToken);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt; { user = user, token =&lt;span&gt; token });
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 前后端分离，前端的登录请求发送到这里。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回200或者401，代表登录成功和失败，如果登录成功，返回一个token。
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;inputUser&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; {&quot;token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6IjFAMS5jb20iLCJqdGkiOiI0ZDNiZGFjMC1hNjYzLTQwNTMtYjU1Yy02Njg2YjAyNjk0MmIiLCJFbWFpbCI6IjFAMS5jb20iLCJleHAiOjE1NDQxODgwMDcsImlzcyI6Imh0dHA6Ly9sb2NhbGhvc3Q6NjM5MzkvIiwiYXVkIjoiaHR0cDovL2xvY2FsaG9zdDo2MzkzOS8ifQ.GTFmUKiAfLTaOuv7rZ-g4Cns033RWehB8u3iFB59rFM&quot;}
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        [Route(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Login([FromBody]UserLoginInput inputUser)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到用户名和密码，用asp.net Core 自带的Identity来进行登录&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; _signInManager.PasswordSignInAsync(inputUser.UserName, inputUser.Password, inputUser.RememberMe, lockoutOnFailure: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (result.Succeeded)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把你自己的密码进行对称加密&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将加密后的密码用JWT指定算法进行加密，这个加密算法有很多，可以去JWT官网上看&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; creds = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到当前登录用户&lt;/span&gt;
                TinyBlog2User user = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.FindByEmailAsync(inputUser.Email);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前用户的Claims&lt;/span&gt;
                IList&amp;lt;Claim&amp;gt; claimsList = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _userManager.GetClaimsAsync(user);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用各种信息组成一个JWT&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; unSecruityToken = &lt;span&gt;new&lt;/span&gt; JwtSecurityToken(_config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], _config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], claimsList, expires: DateTime.Now.AddMinutes(&lt;span&gt;30&lt;/span&gt;&lt;span&gt;), signingCredentials: creds);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把JWT加密一下返回给客户端&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler().WriteToken(unSecruityToken);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Ok(&lt;span&gt;new&lt;/span&gt; { token =&lt;span&gt; token });
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Unauthorized();
            }
        }



        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ActionResult&amp;lt;IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;UserController.cs&lt;/span&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;&lt;img id=&quot;code_img_closed_32c05d50-2136-47ea-b75e-0479cd853f74&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_32c05d50-2136-47ea-b75e-0479cd853f74&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_32c05d50-2136-47ea-b75e-0479cd853f74&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Authentication.JwtBearer;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Builder;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Hosting;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.HttpsPolicy;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.AspNetCore.Mvc;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Configuration;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.DependencyInjection;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Logging;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Options;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Microsoft.IdentityModel.Tokens;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TinyBlog2
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
        {
            Configuration &lt;/span&gt;=&lt;span&gt; configuration;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to add services to the container.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.TokenValidationParameters &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
                {
                    ValidateIssuer &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidateAudience &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidateLifetime &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidateIssuerSigningKey &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    ValidIssuer &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                    ValidAudience &lt;/span&gt;= Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Issuer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                    IssuerSigningKey &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt:Key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
                };
            });

            services.AddAuthorization(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                options.AddPolicy(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VipOnly&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, policy =&amp;gt; policy.RequireClaim(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Role&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;VipUser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
            });
            services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                app.UseHsts();
            }
            app.UseStaticFiles();
            app.UseAuthentication();
            app.UseHttpsRedirection();
            app.UseMvc();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;Startup.cs&lt;/span&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;现在用户登录以后就会得到一串JWT。以后每次发请求的时候在头部附带JWT，浏览器就会认出用户的身份，并且方便的做权限验证了。这里附上PostMan设置。美滋滋。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219214106602-1125374063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219214444986-1873308762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219215449441-1003162976.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;用户注册默认是依靠UserName来注册的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实用户系统才是最大的门槛。至于帖子的增删改查。可以用很简单的一篇博客就能搞定了。祝你开心。&lt;/p&gt;

&lt;p&gt;编程学习大篷车-不限技术栈 QQ群(516766232) 新建群，大家一起来交流嘛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/845737/201812/845737-20181219220705165-1908530434.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Dec 2018 14:10:00 +0000</pubDate>
<dc:creator>不咬人的蚊子</dc:creator>
<og:description>一个前端的asp.net core上手笔记。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/oukichi/p/10134346.html</dc:identifier>
</item>
<item>
<title>自己动手实现java数据结构（四）双端队列 - 小熊餐馆</title>
<link>http://www.cnblogs.com/xiaoxiongcanguan/p/10087910.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoxiongcanguan/p/10087910.html</guid>
<description>&lt;p&gt;　　在介绍双端队列之前，我们需要先介绍队列的概念。和栈相对应，在许多算法设计中，需要一种&quot;&lt;strong&gt;先进先出(First Input First Output)&lt;/strong&gt;&quot;的数据结构，因而一种被称为&quot;&lt;strong&gt;队列(Queue)&lt;/strong&gt;&quot;的数据结构被抽象了出来(因为现实中的队列,就是先进先出的)。&lt;/p&gt;
&lt;p&gt;　　队列是一种线性表，将线性表的一端作为队列的头部，而另一端作为队列的尾部。队列元素从尾部入队，从头部出队(&lt;strong&gt;尾进头出，先进先出&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;双端队列(Double end Queue)&lt;/strong&gt;是一种&lt;strong&gt;特殊的队列结构&lt;/strong&gt;，和普通队列不同的是，双端队列的线性表两端都可以进行出队和入队操作。当只允许使用一端进行出队、入队操作时，双端队列等价于一个栈；当限制一端只能出队，另一端只能入队时，双端队列等价于一个普通队列。&lt;/p&gt;
&lt;p&gt;　　简洁起见，下述内容的&quot;&lt;strong&gt;队列&lt;/strong&gt;&quot;默认代表的就是&quot;&lt;strong&gt;双端队列&lt;/strong&gt;&quot;。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 双端队列 ADT接口
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Deque&amp;lt;E&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 头部元素插入
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addHead(E e);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尾部元素插入
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addTail(E e);

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 头部元素删除
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E removeHead();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 尾部元素删除
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E removeTail();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 窥视头部元素(不删除)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E peekHead();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 窥视尾部元素(不删除)
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    E peekTail();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 返回当前队列中元素的个数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 判断当前队列是否为空
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 如果当前队列中元素个数为0，返回true；否则，返回false
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 清除队列中所有元素
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获得迭代器
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Iterator&lt;/span&gt;&amp;lt;E&amp;gt;&lt;span&gt; iterator();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3.1 双端队列基于数组的实现（ArrayDeque）&lt;/h2&gt;
&lt;p&gt;　　双端队列作为一个线性表，一开始也许会考虑能否像栈一样，使用向量作为双端队列的底层实现。&lt;/p&gt;
&lt;p&gt;　　但是仔细思考就会发现：在向量中，头部元素的插入、删除会导致内部元素的整体批量的移动，效率很差。而队列具有&quot;先进先出&quot;的特性，对于频繁入队，出队的队列容器来说，O(n)时间复杂度的单位操作效率是无法容忍的。因此我们必须更进一步，从更为基础的数组结构出发，实现我们的双端队列。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1.1 数组双端队列实现思路：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在进行代码细节的展开之前，让我们先来理解以下基本思路：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.&lt;/strong&gt;和向量一样，双端队列在内部数组容量不足时，能和向量一样动态的扩容。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.&lt;/strong&gt;双端队列内部维护着&quot;头部下标&quot;、&quot;尾部下标&quot;。&lt;strong&gt;头部下标&lt;/strong&gt;指向的是&lt;strong&gt;队列中第一位元素&lt;/strong&gt;，&lt;strong&gt;尾部下标&lt;/strong&gt;指向的是&lt;strong&gt;下一个尾部元素插入的位置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　   &lt;strong&gt;从头部下标起始，到尾部下标截止(左闭右开区间)，连续保存着队列中的全部元素&lt;/strong&gt;。在元素出队，入队时，通过移动头尾下标，进行队列中元素的插入、删除，从而避免了类似向量中大量内部元素的整体移动。&lt;/p&gt;
&lt;p&gt;　　   当&lt;strong&gt;头部元素入队时，头部下标向左移动一位&lt;/strong&gt;；&lt;strong&gt;头部元素出队时，头部下标向右移动一位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　   当&lt;strong&gt;尾部元素入队时，尾部下标向右移动一位&lt;/strong&gt;；&lt;strong&gt;尾部元素出队时，尾部下标向左移动一位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.&lt;/strong&gt;当元素下标的移动达到了边界时，需要将数组从逻辑上看成一个环，其头尾是相邻的：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;下标从数组第0位时，向左移动一位，会跳转到数组的最后一位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;下标从数组最后一位时，向右移动一位，会跳转到数组的第0位。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　下标越界时的跳转操作，在细节上是通过下标&lt;/strong&gt;取模实现的。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181215122915929-644470376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1.2 队列的基本属性：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　只有当队列为空时，头部节点和尾部节点的下标才会相等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 基于数组的 双端队列
 * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ArrayDeque&amp;lt;E&amp;gt; &lt;span&gt;implements&lt;/span&gt; Deque&amp;lt;E&amp;gt;&lt;span&gt;{

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部封装的数组
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object[] elements;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 队列默认的容量大小
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = 16&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 扩容翻倍的基数
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXPAND_BASE = 2&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 队列头部下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; head;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 队列尾部下标
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; tail;


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 默认构造方法
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ArrayDeque() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置数组大小为默认&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object[DEFAULT_CAPACITY];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::初始化队列 头部,尾部下标&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.head = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tail = 0&lt;span&gt;;
    }
｝&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.1.3 取模计算：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　在jdk基于数组的双端队列实现中，强制保持内部数组容量为2的平方(初始化时容量为2的平方，每次自动扩容容量 * 2)，因此其取模运算可以通过按位与(&amp;amp;)运算来加快计算速度。&lt;/p&gt;
&lt;p&gt;　　取模运算在双端队列的基本接口实现中无处不在，相比jdk的双端队列实现，我们实现的双端队列实现更加原始，效率也较差。但相对的，我们的双端队列实现也较为简洁和易于理解。在理解了基础的实现思路之后，可以在这个初始版本的基础上进一步优化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 取模运算
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; getMod(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; logicIndex){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; innerArrayLength = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements.length;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::由于队列下标逻辑上是循环的

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当逻辑下标小于零时&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(logicIndex &amp;lt; 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::加上当前数组长度&lt;/span&gt;
            logicIndex +=&lt;span&gt; innerArrayLength;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当逻辑下标大于数组长度时&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(logicIndex &amp;gt;=&lt;span&gt; innerArrayLength){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::减去当前数组长度&lt;/span&gt;
            logicIndex -=&lt;span&gt; innerArrayLength;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得真实下标&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; logicIndex;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　取模运算时间复杂度：&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;取模运算中只是进行了简单的整数运算，时间复杂度为O(1)，而在jdk的双端队列实现中，使用位运算的取模效率还要更高。&lt;/p&gt;
&lt;h3&gt;3.1.4 基于数组的双端&lt;strong&gt;队列常用操作接口实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　结合代码，我们再来回顾一下前面提到的基本思路：&lt;/p&gt;
&lt;p&gt;　　1. &lt;strong&gt;头部下标&lt;/strong&gt;指向的是&lt;strong&gt;队列中第一位元素&lt;/strong&gt;，&lt;strong&gt;尾部下标&lt;/strong&gt;指向的是&lt;strong&gt;下一个尾部元素插入的位置&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　2. &lt;strong&gt;头部插入元素时，head下标左移一位&lt;/strong&gt;；&lt;strong&gt;头部删除元素时，head下标右移一位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　    &lt;strong&gt;尾部插入元素时，tail下标右移一位&lt;/strong&gt;；&lt;strong&gt;尾部删除元素时，tail下标左移一位&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　3. &lt;strong&gt;内部数组被看成是一个环&lt;/strong&gt;，下标移动到边界临界点时，通过&lt;strong&gt;取模运算&lt;/strong&gt;来计算逻辑下标对应的真实下标。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addHead(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::头部插入元素 head下标左移一位&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.head = getMod(&lt;span&gt;this&lt;/span&gt;.head - 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::存放新插入的元素&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;.head] =&lt;span&gt; e;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前队列大小 是否到达临界点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(head ==&lt;span&gt; tail){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组扩容&lt;/span&gt;
&lt;span&gt;            expand();
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addTail(E e) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::存放新插入的元素&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;.tail] =&lt;span&gt; e;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::尾部插入元素 tail下标右移一位&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.tail = getMod(&lt;span&gt;this&lt;/span&gt;.tail + 1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断当前队列大小 是否到达临界点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(head ==&lt;span&gt; tail){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组扩容&lt;/span&gt;
&lt;span&gt;            expand();
        }
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E removeHead() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::暂存需要被删除的数据&lt;/span&gt;
        E dataNeedRemove = (E)&lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将当前头部元素引用释放&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;.head] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::头部下标 右移一位&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.head = getMod(&lt;span&gt;this&lt;/span&gt;.head + 1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataNeedRemove;
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E removeTail() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得尾部元素下标(左移一位)&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex = getMod(&lt;span&gt;this&lt;/span&gt;.tail - 1&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::暂存需要被删除的数据&lt;/span&gt;
        E dataNeedRemove = (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[lastIndex];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::设置尾部下标&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.tail =&lt;span&gt; lastIndex;

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dataNeedRemove;
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peekHead() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E)&lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head];
    }

    @Override
    @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peekTail() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::获得尾部元素下标(左移一位)&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; lastIndex = getMod(&lt;span&gt;this&lt;/span&gt;.tail - 1&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (E)&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[lastIndex];
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　队列常用接口时间复杂度：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;基于数组的队列在访问头尾元素时，进行了一次取模运算获得真实下标，由于数组的随机访问是常数时间复杂度(O(1))，因此队列常用接口的&lt;strong&gt;时间复杂度都为O(1)&lt;/strong&gt;，效率很高。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1.5 扩容操作：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;可以看到，在入队插入操作结束后，会判断当前队列容量是否已经到达了临界点。&lt;/p&gt;
&lt;p&gt;　　前面提到，只有在队列为空时，头部下标才会和尾部下标重合；而当插入新的入队元素之后，使得头部下标等于尾部下标时，说明内部数组的容量已经达到了极限，需要进行扩容才能容纳更多的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们举一个简单的例子来理解扩容操作：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　尾部下标为2.头部下标为3，队列内的元素为头部下标到尾部下标(左闭右开)中的元素排布为(1，2，3，4，5，6)。&lt;/p&gt;
&lt;p&gt;　　目前队列刚刚在下标为2处的尾部入队元素&quot;7&quot;。尾部下标从2向右移动一位和头部下标重合，此时队列中元素排布为(1，2，3，4，5，6，7)，此时需要进行一次扩容操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　在扩容完成之后，我们希望让队列的元素在内部数组中排列的更加自然：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1. 队列中元素的顺序不变，依然是(1，2，3，4，5，6，7)，内部数组扩容一定的倍数(两倍)&lt;/p&gt;
&lt;p&gt;　　　　2. 队列中第一个元素将位于内部数组的第0位，队列中的元素按照头尾顺序依次排列下去&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;扩容的大概思路：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1. 将&quot;头部下标&quot;直至&quot;当前内部数组尾部&quot;的元素按照顺序整体复制到新扩容数组的起始位置(&lt;strong&gt;红色背景的元素&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;　　　　2. 将&quot;当前内部数组头部&quot;直至&quot;尾部下标&quot;的元素按照顺序整体复制到新扩容数组中(位于第一步操作复制的数据区间之后)(&lt;strong&gt;蓝色背景的元素&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩容前：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181218165731641-1927015579.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩容后：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181215230150746-765088169.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;扩容代码的实现：　　&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 内部数组扩容
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; expand(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组 扩容两倍&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; elementsLength = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements.length;
        Object[] newElements &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Object[elementsLength *&lt;span&gt; EXPAND_BASE];

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将&quot;head -&amp;gt; 数组尾部&quot;的元素 复制在新数组的前面 (tips：使用System.arraycopy效率更高)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;this&lt;/span&gt;.head, j=0; i&amp;lt;elementsLength; i++,j++&lt;span&gt;){
            newElements[j] &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[i];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将&quot;0 -&amp;gt; head&quot;的元素 复制在新数组的后面 (tips：使用System.arraycopy效率更高)&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0, j=elementsLength-&lt;span&gt;this&lt;/span&gt;.head; i&amp;lt;&lt;span&gt;this&lt;/span&gt;.head; i++,j++&lt;span&gt;){
            newElements[j] &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements[i];
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::初始化head,tail下标&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.head = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tail = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements.length;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::内部数组指向 新扩容的数组&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.elements =&lt;span&gt; newElements;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;strong&gt;　扩容操作时间复杂度：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　动态扩容的操作由于需要进行内部数组的整体copy，&lt;strong&gt;其时间复杂度是O(n)。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;但是站在全局的角度，动态扩容只会在入队操作导致空间不足时&lt;strong&gt;偶尔&lt;/strong&gt;的被触发，&lt;strong&gt;整体来看，动态扩容的时间复杂度为O(1)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;3.1.6 其它接口实现：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getMod(tail -&lt;span&gt; head);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isEmpty() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当且仅当 头尾下标相等时 队列为空&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; (head ==&lt;span&gt; tail);
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; clear() {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; head = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tail = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail;

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(head !=&lt;span&gt; tail){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.elements[head] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            head &lt;/span&gt;= getMod(head + 1&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.head = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tail = 0&lt;span&gt;;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Itr();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;strong&gt;3.1.7 基于数组的双端队列——迭代器实现：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　迭代器从头部元素开始迭代，直至尾部元素终止。&lt;/p&gt;
&lt;p&gt;　　值得一提的是，虽然队列的api接口中没有提供直接删除队列中间(非头部、尾部)的元素，但是迭代器的remove接口却依然允许这种操作。由于必须要时刻保持队列内元素排布的连续性，因此在删除队列中间的元素后，需要整体的移动其他元素。&lt;/p&gt;
&lt;p&gt;　　此时，有两种选择：&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;方案一&lt;/strong&gt;：将&quot;头部下标&quot;到&quot;被删除元素下标&quot;之间的元素整体向右平移一位&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;方案二&lt;/strong&gt;：将&quot;被删除元素下标&quot;到&quot;尾部下标&quot;之间的元素整体向左平移一位&lt;/p&gt;
&lt;p&gt;　　我们可以根据被删除元素所处的位置，计算出两种方案各自需要平移元素的数量，选择平移元素数量较少的方案，进行一定程度的优化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;队列迭代器的remove操作中存在一些细节值得注意，我们使用一个简单的例子来帮助理解：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;1. 当前队列在迭代时需要删除元素&quot;7&quot;(红色元素)，采用方案一需要整体平移(1，2，3，4，5，6)六个元素，而方案二只需要整体平移(8，9，10，11，12)五个元素。因此采用平移元素更少的方案二，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;2. 这时由于(8，9，10，11，12)五个元素被物理上截断了，所以主要分三个步骤进行平移。&lt;/p&gt;
&lt;p&gt;　　　　第一步： 先将靠近尾部的 (8，9)两个元素整体向左平移一位(蓝色元素)&lt;/p&gt;
&lt;p&gt;　　　　第二步： 将内部数组头部的元素(10)，复制到内部数组的尾部(粉色元素)&lt;/p&gt;
&lt;p&gt;　　　　第三部 :  将剩下的元素(11，12)，整体向左平移一位(绿色元素)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;remove操作执行前：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181218170424746-508873537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;remove操作执行后：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1506329/201812/1506329-20181216203219856-70700302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;迭代器代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在remove操作中有多种可能的情况，由于思路相通，可以通过上面的举例说明帮助理解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   /**&lt;/span&gt;&lt;span&gt;
     * 双端队列 迭代器实现
     * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private class&lt;/span&gt; Itr &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 当前迭代下标 = head
         * 代表遍历从头部开始
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; currentIndex = ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 目标终点下标 = tail
         * 代表遍历至尾部结束
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; targetIndex = ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail;

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 上一次返回的位置下标
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lastReturned;

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前迭代下标未到达终点，还存在下一个元素&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.currentIndex != &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.targetIndex;
        }

        @Override
        @SuppressWarnings(&lt;/span&gt;&quot;unchecked&quot;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; E next() {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::先暂存需要返回的元素&lt;/span&gt;
            E value = (E)ArrayDeque.&lt;span&gt;this&lt;/span&gt;.elements[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::最近一次返回元素下标 = 当前迭代下标&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.lastReturned = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前迭代下标 向后移动一位(需要取模)&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.currentIndex = getMod(&lt;span&gt;this&lt;/span&gt;.currentIndex + 1&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;
        }

        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.lastReturned == -1&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IteratorStateErrorException(&quot;迭代器状态异常: 可能在一次迭代中进行了多次remove操作&quot;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::删除当前迭代下标的元素&lt;/span&gt;
            &lt;span&gt;boolean&lt;/span&gt; deleteFromTail = delete(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.currentIndex);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::如果从尾部进行收缩&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(deleteFromTail){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前迭代下标前移一位&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.currentIndex = getMod(&lt;span&gt;this&lt;/span&gt;.currentIndex - 1&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::为了防止用户在一次迭代(next调用)中多次使用remove方法，将lastReturned设置为-1&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.lastReturned = -1&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
         * 删除队列内部数组特定下标处的元素
         * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; currentIndex 指定的下标
         * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; true 被删除的元素靠近尾部
         *         false 被删除的元素靠近头部
         * &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; delete(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; currentIndex){
            Object[] elements &lt;/span&gt;= ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.elements;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; head = ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.head;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tail = ArrayDeque.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.tail;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前下标 之前的元素个数&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; beforeCount = getMod(currentIndex -&lt;span&gt; head);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::当前下标 之后的元素个数&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; afterCount = getMod(tail -&lt;span&gt; currentIndex);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断哪一端的元素个数较少&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(beforeCount &amp;lt;&lt;span&gt; afterCount){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::距离头部元素较少，整体移动前半段元素

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断头部下标 是否小于 当前下标&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(head &amp;lt;&lt;span&gt; currentIndex){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::小于，正常状态  仅需要复制一批数据

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将当前数组从&quot;头部下标&quot;开始，整体向右平移一位，移动的元素个数为&quot;当前下标 之前的元素个数&quot;&lt;/span&gt;
                    System.arraycopy(elements,head,elements,head+1&lt;span&gt;,beforeCount);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不小于，说明存在溢出环  需要复制两批数据

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组从&quot;0下标处&quot;的元素整体向右平移一位，移动的元素个数为&quot;从0到当前下标之间的元素个数&quot;&lt;/span&gt;
                    System.arraycopy(elements,0,elements,1&lt;span&gt;,currentIndex);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组最尾部的数据设置到头部，防止被覆盖&lt;/span&gt;
                    elements[0] = elements[(elements.length-1&lt;span&gt;)];
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组尾部的数据整体向右平移一位&lt;/span&gt;
                    System.arraycopy(elements,head,elements,head+1,(elements.length-head-1&lt;span&gt;));
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::释放被删除元素的引用&lt;/span&gt;
                elements[currentIndex] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::头部下标 向右移动一位&lt;/span&gt;
                ArrayDeque.&lt;span&gt;this&lt;/span&gt;.head = getMod(ArrayDeque.&lt;span&gt;this&lt;/span&gt;.head + 1&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::没有删除尾部元素 返回false&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::距离尾部元素较少，整体移动后半段元素

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::判断尾部下标 是否小于 当前下标&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt;(currentIndex &amp;lt;&lt;span&gt; tail){
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::小于，正常状态  仅需要复制一批数据

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将当前数组从&quot;当前&quot;开始，整体向左平移一位，移动的元素个数为&quot;当前下标 之后的元素个数&quot;&lt;/span&gt;
                    System.arraycopy(elements,currentIndex+1&lt;span&gt;,elements,currentIndex,afterCount);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::不小于，说明存在溢出环  需要复制两批数据

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组从&quot;当前下标处&quot;的元素整体向左平移一位，移动的元素个数为&quot;从当前下标到数组末尾的元素个数-1 ps：因为要去除掉被删除的元素&quot;&lt;/span&gt;
                    System.arraycopy(elements,currentIndex+1,elements,currentIndex,(elements.length-currentIndex-1&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组头部的元素设置到末尾&lt;/span&gt;
                    elements[elements.length-1] = elements[0&lt;span&gt;];
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::将数组头部的数据整体向左平移一位，移动的元素个数为&quot;从0到尾部下标之间的元素个数&quot;&lt;/span&gt;
                    System.arraycopy(elements,1,elements,0&lt;span&gt;,tail);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::尾部下标 向左移动一位&lt;/span&gt;
                ArrayDeque.&lt;span&gt;this&lt;/span&gt;.tail = getMod(ArrayDeque.&lt;span&gt;this&lt;/span&gt;.tail - 1&lt;span&gt;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;:::删除了尾部元素 返回true&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2 基于链表的链式双端队列&lt;/h2&gt;
&lt;p&gt;　　和向量不同，双向链表在头尾部进行插入、删除操作时，不需要额外的操作，效率极高。&lt;/p&gt;
&lt;p&gt;　　因此，我们可以使用之前已经封装好的的双向链表作为基础，轻松的实现一个链式结构的双端队列。限于篇幅，就不继续展开了，有兴趣的读者可以尝试自己完成这个任务。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;空间效率：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;基于数组的双端队列：&lt;/strong&gt;数组空间结构非常紧凑，效率很高。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;基于链表的双端队列：&lt;/strong&gt;由于链式结构的节点存储了相关联的引用，空间效率比数组结构稍低。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;时间效率:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　对于双端队列常用的&lt;strong&gt;出队&lt;/strong&gt;、&lt;strong&gt;入队&lt;/strong&gt;操作，由于都是在头尾处进行操作，数组队列和链表队列的执行效率都非常高(&lt;strong&gt;时间复杂度(O(1))&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;　　　　需要注意的是，由于双端队列的迭代器&lt;strong&gt;remove&lt;/strong&gt;接口允许删除队列中间部位的元素，而删除中间队列元素的效率很低(&lt;strong&gt;时间复杂度O(n)&lt;/strong&gt;)，所以在使用迭代器&lt;strong&gt;remove&lt;/strong&gt;接口时需要谨慎。&lt;/p&gt;

&lt;p&gt;　　至此，我们实现了一个基础的、基于数组的双端队列。要想更近一步的学习双端队列，可以尝试着阅读jdk的java.util.ArrayDeque类并且按照自己的思路尝试着动手实现一个双端队列。我个人认为，如果事先没有一个明确的思路，直接去硬看源代码，很容易就陷入细节之中无法自拔，&quot;不识庐山真面目，只缘生在此山中&quot;。&lt;/p&gt;
&lt;p&gt;　　希望这篇博客能够让读者更好的理解双端队列，更好的理解自己所使用的数据结构，写出更高效，易维护的程序。&lt;/p&gt;
&lt;p&gt;　　博客的完整代码在我的 github上：&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt;https://github.com/1399852153/DataStructures&lt;/a&gt;&lt;a href=&quot;https://github.com/1399852153/DataStructures&quot; target=&quot;_blank&quot;&gt; &lt;/a&gt;，存在许多不足之处，请多多指教。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Dec 2018 14:09:00 +0000</pubDate>
<dc:creator>小熊餐馆</dc:creator>
<og:description>1.双端队列介绍 在介绍双端队列之前，我们需要先介绍队列的概念。和栈相对应，在许多算法设计中，需要一种&quot;先进先出(First Input First Output)&quot;的数据结构，因</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaoxiongcanguan/p/10087910.html</dc:identifier>
</item>
</channel>
</rss>