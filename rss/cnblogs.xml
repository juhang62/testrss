<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>WinForm下开发插件DevExpress安装及使用 - #非同寻常#</title>
<link>http://www.cnblogs.com/sdxlz666/p/10802512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdxlz666/p/10802512.html</guid>
<description>&lt;p&gt;WinForm下开发插件DevExpress安装及使用&lt;br/&gt;在Visual Studio中安装DevExpress开发插件&lt;br/&gt;插件的使用方法&lt;br/&gt;简单的Demo介绍&lt;br/&gt;下载链接：https://pan.baidu.com/s/1smeXRWkUpb–VA0XjsM4tQ&lt;br/&gt;-首先给大家介绍一下DevExpress安装包内容&lt;br/&gt;【DevExpressUniversalTrialComplete】是程序安装包，&lt;br/&gt;双击该安装包就可以安装DevExpress；&lt;br/&gt;【DevExpress.Patch 7.0-by dimaster】用来破解EevExpress；&lt;br/&gt;【Dev破解后去除提示框】用来去掉DevExpress在运行时的试用提示信息&lt;/p&gt;
&lt;p&gt;第一步：选择几个常用的进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1624416/201905/1624416-20190502155424922-596739781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步：傻瓜式下一步（关闭VS）&lt;/p&gt;
&lt;p&gt;第三步：破解，点击Apply patch【DevExpress.Patch 7.0-by dimaster】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1624416/201905/1624416-20190502155416139-1738281860.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;第四步：消除提示框&lt;br/&gt;---------------------&lt;br/&gt;作者：abstract_js&lt;br/&gt;来源：CSDN&lt;br/&gt;原文：https://blog.csdn.net/abstract_js/article/details/80657997&lt;br/&gt;版权声明：本文为博主原创文章，转载请附上博文链接！&lt;/p&gt;
</description>
<pubDate>Thu, 02 May 2019 07:55:00 +0000</pubDate>
<dc:creator>#非同寻常#</dc:creator>
<og:description>WinForm下开发插件DevExpress安装及使用在Visual Studio中安装DevExpress开发插件插件的使用方法简单的Demo介绍下载链接：https://pan.baidu.com</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sdxlz666/p/10802512.html</dc:identifier>
</item>
<item>
<title>windows 中如何定位恶意软件的藏身位置 - mysgk</title>
<link>http://www.cnblogs.com/mysgk/p/10802345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mysgk/p/10802345.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;前言: 在使用windows的过程中经常会碰到一些莫名其妙的问题，比如我明明没有安装金山系列的软件，为什么要给我来个弹窗？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502143034901-1833849384.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，直接进入正题。&lt;/p&gt;

&lt;p&gt;我这边安装了 vs2017 ，可以在 工具--spy++ 中打开。&lt;/p&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502143358174-2004504370.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;打开后-点击-搜索下面的查找窗口altf3&quot;&gt;打开后 点击 搜索下面的查找窗口（Alt+F3）&lt;/h2&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502143534677-565886203.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;点击-查找程序工具-右侧的-靶子一样的图标鼠标左键按住不放拖放到-弹窗上面弹窗周围会出现-黑框&quot;&gt;点击 查找程序工具 右侧的 靶子一样的图标，鼠标左键按住不放，拖放到 弹窗上面，弹窗周围会出现 黑框。&lt;/h2&gt;
&lt;p&gt;如图：&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502143955173-1662997088.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502144000769-1962100607.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;然后-我们点击确定-spy-会定位到对应的窗口&quot;&gt;然后 我们点击确定, spy++ 会定位到对应的窗口。&lt;/h2&gt;
&lt;p&gt;如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502144214311-93429571.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;我们右键选择属性查看进程栏&quot;&gt;我们右键选择属性，查看进程栏。&lt;/h2&gt;
&lt;p&gt;如图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502144405347-771286491.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502144411112-1415859758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记录下此时的 进程ID &quot;00045E68&quot;&lt;/p&gt;

&lt;h2 id=&quot;将刚才得到的进程id-转换成10进程记下此时的数值-286312&quot;&gt;将刚才得到的进程ID 转换成10进程,记下此时的数值 ”286312“&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502144719519-1435839194.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;打开cmd-输入-tasklist-findstr-286312&quot;&gt;打开cmd 输入 tasklist | findstr &quot;286312&quot;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502144852159-240235661.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到该进程的进程名称。此处的进程名称为 kwhcommonpop.exe&lt;/p&gt;
&lt;h2 id=&quot;我们现在可以打开-everything-输入-kwhcommonpop.exe-即可看到此文件的位置&quot;&gt;我们现在可以打开 everything ，输入 kwhcommonpop.exe ，即可看到此文件的位置。&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502145055700-150323628.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/695883/201905/695883-20190502145615133-364710038.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们可以点击最下面的uninstall.exe 进行卸载。&lt;/p&gt;
</description>
<pubDate>Thu, 02 May 2019 06:54:00 +0000</pubDate>
<dc:creator>mysgk</dc:creator>
<og:description>[TOC] 前言: 在使用windows的过程中经常会碰到一些莫名其妙的问题，比如我明明没有安装金山系列的软件，为什么要给我来个弹窗？ 好了，直接进入正题。 一: 下载spy++ 我这边安装了 vs2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mysgk/p/10802345.html</dc:identifier>
</item>
<item>
<title>我是怎么整理自己的知识(非技术)体系的 - hchengmx</title>
<link>http://www.cnblogs.com/hchengmx/p/10802336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hchengmx/p/10802336.html</guid>
<description>&lt;p&gt;本文地址: &lt;a href=&quot;https://www.cnblogs.com/hchengmx/p/10802298.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/hchengmx/p/10802298.html&lt;/a&gt;&lt;br/&gt;本文笔记地址: &lt;a href=&quot;https://www.kancloud.cn/hchengmx/life-handbook/content&quot; class=&quot;uri&quot;&gt;https://www.kancloud.cn/hchengmx/life-handbook/content&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很久之前看到一个贴子，说是各种网站的收藏夹很多，但是却很少看。等到真正需要看文章的时候，才一个一个收藏夹找。因为有很多网站嘛，就可能比较费时费力。所以很多人会遇到这样的问题，诶我是放在哪里了呢？我是在哪里看过呢？我是在哪里收藏的呢？&lt;/p&gt;
&lt;p&gt;通过自己的不断摸索，我也对知识体系整理有一些小心得，这篇文章就来说明一次我是怎么处理自己的知识体系的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一阶段: &quot;All in OneNote&quot;。&lt;/strong&gt;&lt;br/&gt;想到使用OneNote是因为各种网站平台都有收藏夹嘛，知乎/微博/微信公众号，那我们怎么把各种收藏夹汇集到一个平台呢? 我想到的途径是OneNote，把所有收藏的东西都汇集到一个OneNote笔记中里面，这一步，我称之为&quot;All in OneNote&quot;。在微信端: 可以关注微软云笔记公众号，把文章推送到OneNote里面。 在网页端: 可以装上插件Clip To OneNote；至于在微博端，可以通过ifttt把微博保存到OneNote端。&lt;/p&gt;
&lt;p&gt;这样做的好处是，可以基本舍弃都有的收藏夹，所有的东西都放到了一个平台上阅读。&lt;br/&gt;但是有几个明显的缺点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;OneNote的客户端对用户非常不友好，加载的非常的慢，而且还占空间；&lt;/li&gt;
&lt;li&gt;要是暂存还好，但要是对于大量的文章，就有可能一个分区里面有好多个文章这种情况，很乱，从人的心理上来说，这么多东西可能就是负担了，也就懒得读；&lt;/li&gt;
&lt;li&gt;如何做笔记做输出? 是个大问题，要在当前裁剪的页面记笔记呢? 还是在另外的空白页记笔记呢? 都有缺点，不能成为一个体系；&lt;/li&gt;
&lt;li&gt;对于有些笔记，刚读完可能还记得点，但又非常知道自己未来可能会用到，怎么找原文呢? 保存把文章会越来越多，不保存把以后想重新找回来又很麻烦；&lt;/li&gt;
&lt;li&gt;对于有些笔记，现在可能用不到，以后可能在五年/十年才用到，那是到底保存不保存呢? 保存了现在确实用不到还占地方，不保存把但以后可能用得到；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第二阶段: 引入markdown。&lt;/strong&gt;&lt;br/&gt;以上的第二个到第五个的缺点 ，概括起来就是，移动端不友好，不可标记，难以追溯，难以整理。后来由于我会看github上的程序员笔记，发现他们是用的是markdown，我就在想能不能通过markdown对笔记系统进行补充? 让markdown负责目录结构/标记等工作。&lt;/p&gt;
&lt;p&gt;具体就变成了这样:&lt;br/&gt;不用markdown进行记录，用markdown进行标记，书签，链接工作，将标题以及自己的笔记整理成md文件。后期查看的时候，在手机端直接阅读.md文件了，这样在移动端也可以阅读了。&lt;/p&gt;
&lt;p&gt;几个使用关键技巧:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;要选择适合自己的目录结构，先想好要几个文件，哪个文件里面都包括什么内容；&lt;/li&gt;
&lt;li&gt;每个文件都有 目录 + 详情，目录有链接直接导览至详情；&lt;/li&gt;
&lt;li&gt;在目录部分，对于读过的文章加粗，对于没读过的文章不加粗以区分；&lt;/li&gt;
&lt;li&gt;详情也是一个链接，用来说明文章的源出处；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个例子:&lt;br/&gt;下面是我整理的一个文件。&lt;br/&gt;目录部分，左边是markdown，右边是markdown preview(读过的文章加粗)。&lt;br/&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6ac80d2egy1g2my30p1i7j220w17t4ho.jpg&quot; alt=&quot;目录部分&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内容部分，就是自己读文章的笔记了，标题是一个链接，点进去是文章的源地址，这样只保存一个链接省空间也方便回溯。&lt;br/&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6ac80d2egy1g2my6ztatkj21xy17hncr.jpg&quot; alt=&quot;详情部分&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样OneNote就轻松多了，OneNote在这里的角色转换成一个简单的阅读器，不再负责笔记的部分。平时找文章都可以通过md输出的html文件来找。&lt;/p&gt;
&lt;p&gt;所以现在看到一篇文章的流程是这样的:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在琐碎时间看到，觉得还挺重要的文章，一律保存在OneNote(浏览器插件+微信微软云笔记)，等有时间了再读。&lt;/li&gt;
&lt;li&gt;有空读一读OneNote，并定期保存的条目(一周一次整理,一月一次大整理)，要是觉得有用能学到东西，在markdown文件新增条目；&lt;/li&gt;
&lt;li&gt;把这个文章放到响应的OneNote笔记本组里面；&lt;/li&gt;
&lt;li&gt;定期整理markdown文件，把记住的知识点删除，释放空间；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;第三阶段: 托管到看云kancloud&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一阶段就是共享了，由于gitbook在国内用的不是很顺利，所以我把我整理的生活笔记放到了看云kancloud上。&lt;br/&gt;&lt;a href=&quot;https://www.kancloud.cn/hchengmx/life-handbook/content&quot; class=&quot;uri&quot;&gt;https://www.kancloud.cn/hchengmx/life-handbook/content&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这样还有几个额外的好处:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;kancloud是有客户端的，不大也很方便；&lt;/li&gt;
&lt;li&gt;只要能打开网页，在哪里都可以阅读；&lt;/li&gt;
&lt;li&gt;可以支持多人编辑；&lt;/li&gt;
&lt;li&gt;kancloud是支持git的, 所以我们所有更新可以在本地进行，删除的段落也可以在git上找到；&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;本文希望对您有所帮助，欢迎关注我的微信公众号和个人微信。&lt;br/&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/thumbnail/6ac80d2egy1g2jtz1olx5j2076076t96.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/thumbnail/6ac80d2egy1g2jtyd5u5cj20hg0hih9q.jpg&quot; alt=&quot;个人号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 May 2019 06:51:00 +0000</pubDate>
<dc:creator>hchengmx</dc:creator>
<og:description>本文地址: https://www.cnblogs.com/hchengmx/p/10802298.html 本文笔记地址: https://www.kancloud.cn/hchengmx/life</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hchengmx/p/10802336.html</dc:identifier>
</item>
<item>
<title>TCP协议原理与格式初探 - 王鑫文</title>
<link>http://www.cnblogs.com/wangxinwen/p/10802318.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangxinwen/p/10802318.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如何在一条不可靠的信道上得到可靠的传输？&lt;br/&gt;不可靠的原因：可能出现比特差错、丢包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;停等传输下的情况&quot;&gt;停等传输下的情况&lt;/h2&gt;
&lt;p&gt;从简单到难的情况一步步分析：&lt;/p&gt;
&lt;h3 id=&quot;经过完全可靠信道的可靠数据传输&quot;&gt;1.经过完全可靠信道的可靠数据传输&lt;/h3&gt;
&lt;p&gt;这时只需要一发一收，值得注意的是：发送端的发送动作是由上层（应用层）触发，接收端的接收动作是由下层（网络层）触发&lt;/p&gt;
&lt;h3 id=&quot;经具有比特差错信道的可靠数据传输&quot;&gt;2.经具有比特差错信道的可靠数据传输&lt;/h3&gt;
&lt;p&gt;既然可能出现比特差错，那首先要能检测出比特差错，这可以用校验和的方法&lt;br/&gt;当接收端检测到比特差错，应该向发送端反馈出错了（NAK），发送端再重新发送直到没有错误（即使无错误也要反馈接受无误（ACK）），注意反馈时也要用到校验和&lt;br/&gt;这里又出现了问题，没有办法保证发送端反馈的信息无差错传输（反馈信息也可能出现错误，表现为校验和错误，不过错误背后的信息即可能是NAK也可能是ACK），因此发送端为了保证万无一失，只要收到的反馈有错误，就重新发送该分组&lt;br/&gt;然然然而，数据运输是许多个分组，一个接着一个，然后想到如果是ACK分组受损，发送端重传分组，会导致接收端错把重传分组当成新分组，所以必须区分一前一后两个分组，这可以通过在分组前增加0/1来解决（0/1对应一前一后）&lt;/p&gt;
&lt;h3 id=&quot;经具有比特差错的丢包信道的可靠数据传输&quot;&gt;3.经具有比特差错的丢包信道的可靠数据传输&lt;/h3&gt;
&lt;p&gt;先考虑丢包的后果，丢包会导致接收端无回应，因此发送端可以选定一个时长，当发送分组在经过此时长后就判定发生丢包，随后重传分组，具体操作是设定一个定时器&lt;/p&gt;
&lt;h2 id=&quot;流水线传输&quot;&gt;流水线传输&lt;/h2&gt;
&lt;p&gt;上面讨论的传输都是停等传输，即发送端收到一个确定，发送一个分组，要想提高效率，可以允许发送端发送多个分组而无需等待确认，一回合发送多个分组后必须要做的工作有：增加序号范围，缓存多个分组，此外对于如何处理丢失、损坏和超时，有两种方法：&lt;/p&gt;
&lt;h3 id=&quot;回退n步go-back-ngbn协议&quot;&gt;1.回退N步（Go-Back-N，GBN）协议&lt;/h3&gt;
&lt;p&gt;发送端：维护一个发送窗口，[Send Base，SendBase+N-1]，窗口已满时拒绝上层调用，累计确认ACK（序号n），定时器&lt;br/&gt;接收端：按序接受，累计确认，丢弃乱序包并反馈&lt;br/&gt;丢弃一个正确接受的分组的缺点是最后对该分组的重传也许会丢失或出错，因此需要更多的重传&lt;/p&gt;
&lt;h3 id=&quot;选择重传selective-repeatsr&quot;&gt;2.选择重传（Selective Repeat，SR）&lt;/h3&gt;
&lt;p&gt;发送端：每个分组一个单独一个定时器，采用单个确认&lt;br/&gt;接收端：维护一个接收窗口，[rcv_base，rcv_base+N-1]，用来缓存失序的分组&lt;br/&gt;收到序号在小于现在 一个窗口大小范围内 的分组，必须产生一个ACK&lt;br/&gt;发送端和接收端的窗口并不总是一致，最大错位一个窗口，所以序号范围有限时，为了避免对一个序号的含义混淆（重传/新分组），窗口长度必须小于或等于序号空间大小的一半&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;特点：面向连接的（connection-oriented），全双工服务，点对点的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;tcp报文段结构&quot;&gt;TCP报文段结构：&lt;/h3&gt;
&lt;p&gt;首部一般20字节：源端口号（16bits），目的端口号（16bits），检验和字段（16bits），序号（32bits），确认号（32bits），接收窗口（16bits），首部长度（4bits，以32bits的字为单位），选项（可变长），标志（ACK确认，（RST，SYN，FIN）连接建立与拆除，（CWR，ECE）拥塞报告，PSH（表明应立即将数据交给上层），URG（紧急报文）），紧急数据指针（16bits，配合URG标志使用）&lt;br/&gt;序号和确认号：序号对数据流中的字节编号，确认号表示下一次接收时期望的序号&lt;/p&gt;
&lt;h3 id=&quot;往返时间round-trip-timertt&quot;&gt;往返时间（Round-Trip Time，RTT）&lt;/h3&gt;
&lt;p&gt;往返时间的估计：某个时刻的值SampleRTT，其均值为EstimateRTT&lt;br/&gt;计算公式：EstimateRTT=（1-α）EstimateRTT+α&lt;em&gt;SampleRTT，α的推荐值为0.125&lt;br/&gt;（指数加权移动平均）&lt;br/&gt;偏差的估计：DevRTT=（1-β）DevRTT+β&lt;/em&gt;|SampleRTT-EstimateRTT|&lt;br/&gt;设置和管理重传时间间隔：重传超时间隔TimeoutInterval=EstimateRTT+4*DevRTT，初始值为1s&lt;/p&gt;
&lt;h3 id=&quot;tcp可靠数据传输&quot;&gt;TCP可靠数据传输&lt;/h3&gt;
&lt;p&gt;这里指出上节可靠数据传输技术的缺点：定时器的管理需要相当大的开销&lt;br/&gt;拥塞控制的简单方法：超时间隔加倍，初始0.75s&lt;br/&gt;快速重传：3个冗余ACK---&amp;gt;重传&lt;br/&gt;累计确认，缓存失序分组&lt;/p&gt;
&lt;h3 id=&quot;流量控制区别于拥塞控制&quot;&gt;流量控制（区别于拥塞控制）&lt;/h3&gt;
&lt;p&gt;为了消除发送方发送太快，使接收方缓存溢出的可能性&lt;br/&gt;方法：维护一个接收窗口变量，表明接收方还有多少可用的缓存空间&lt;/p&gt;
&lt;h2 id=&quot;tcp连接管理&quot;&gt;TCP连接管理：&lt;/h2&gt;
&lt;h3 id=&quot;三次握手客户发起&quot;&gt;三次握手（客户发起）：&lt;/h3&gt;
&lt;p&gt;1.客户主机随机生成序号，SYN标志置为1，发送连接请求&lt;br/&gt;2.服务器随机生成序号，SYN标志置为1，确认号置为客户序号+1，允许连接&lt;br/&gt;3.客户回复序号+1，SYN置为0，确认号为服务器序号+1，连接建立&lt;/p&gt;
&lt;h3 id=&quot;四次挥手双方都可发起&quot;&gt;四次挥手（双方都可发起）：&lt;/h3&gt;
&lt;p&gt;1.一方将FIN标志置为1，请求关闭连接，这一方进入FIN_WAIT_1状态&lt;br/&gt;2.另一方回复ACK，进入CLOSE_WAIT，（发起方收到ACK，进入FIN_WAIT_2）&lt;br/&gt;3.并接着回复FIN=1，进入LAST_ACK&lt;br/&gt;4.初始方收到FIN，回复ACK，进入TIME_WAIT，定时（30s/1min/2min）关闭，（另一方收到ACK，进入CLOSED）&lt;/p&gt;
&lt;h3 id=&quot;syn洪泛攻击的应对&quot;&gt;SYN洪泛攻击的应对：&lt;/h3&gt;
&lt;p&gt;服务器以请求连接方的IP和Port为参数使用一个私密的散列函数计算出一个值，使其作为服务器初始序号，并发送SYNACK给请求方，这时并不建立半开连接&lt;br/&gt;如果用户回复ACK，且ACK-1=f（IP，Port），那么说明用户合法，允许建立连接&lt;br/&gt;如果回复的ACK错误，说明此用户并没有较早的SYN请求，是非法的&lt;br/&gt;如果没有回复，也不会产生危害，因为服务器并没有给它分配资源&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1447810/201905/1447810-20190502144104457-1285091398.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加性增，乘性减（Additive-Increase，Multiplicative-Decrease，AIMD）&lt;/p&gt;
&lt;h3 id=&quot;tcp吞吐量&quot;&gt;TCP吞吐量&lt;/h3&gt;
&lt;p&gt;一条连接的平均吞吐量=0.75W/RTT，W为丢包发生时的窗口长度&lt;br/&gt;经高带宽路径的平均吞吐量=1.22MSS/（RTT*根号L），L为丢包率&lt;/p&gt;
&lt;h3 id=&quot;aimd算法公平吗&quot;&gt;AIMD算法公平吗&lt;/h3&gt;
&lt;p&gt;公平，因为拥塞发生时，原本占带宽大的减少较多的窗口长度，原本占带宽少的减少较少的窗口长度，拥塞避免状态又是以同样速度增加窗口长度，数次拥塞发生后，各连接的窗口长度接近相等，带宽占用趋于平均&lt;/p&gt;
</description>
<pubDate>Thu, 02 May 2019 06:45:00 +0000</pubDate>
<dc:creator>王鑫文</dc:creator>
<og:description>[TOC] 可靠数据传输原理 如何在一条不可靠的信道上得到可靠的传输？ 不可靠的原因：可能出现比特差错、丢包 停等传输下的情况 从简单到难的情况一步步分析： 1.经过完全可靠信道的可靠数据传输 这时只</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangxinwen/p/10802318.html</dc:identifier>
</item>
<item>
<title>Go语言goroutine调度器概述(11) - 爱写程序的阿波张</title>
<link>http://www.cnblogs.com/abozhang/p/10802319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abozhang/p/10802319.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文是《go调度器源代码情景分析》系列的第11篇，也是第二章的第1小节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;goroutine简介&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;goroutine是Go语言实现的用户态线程&lt;/strong&gt;，主要用来解决操作系统线程太“重”的问题，所谓的太重，主要表现在以下两个方面：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;创建和切换太重&lt;/strong&gt;&lt;/span&gt;：操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;内存使用太重&lt;/strong&gt;&lt;/span&gt;：一方面，为了尽量避免极端情况下操作系统线程栈的溢出，内核在创建操作系统线程时默认会为其分配一个较大的栈内存（虚拟地址空间，内核并不会一开始就分配这么多的物理内存），然而在绝大多数情况下，系统线程远远用不了这么多内存，这导致了浪费；另一方面，栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出的风险。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;而相对的，用户态的goroutine则轻量得多：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;goroutine启动时默认栈大小只有2k，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;正是因为Go语言中实现了如此轻量级的线程，才使得我们在Go程序中，可以轻易的创建成千上万甚至上百万的goroutine出来并发的执行任务而不用太担心性能和内存等问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：为了避免混淆，从现在开始，后面出现的所有的线程一词均是指操作系统线程，而goroutine我们不再称之为什么什么线程而是直接使用goroutine这个词。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;线程模型与调度器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一章讨论操作系统线程调度的时候我们曾经提到过，goroutine建立在操作系统线程基础之上，它与操作系统线程之间实现了一个&lt;span&gt;多对多(M:N)的两级线程模型&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里的 &lt;span&gt;M:N&lt;/span&gt; 是指M个goroutine运行在N个操作系统线程之上，内核负责对这N个操作系统线程进行调度，而这N个系统线程又负责对这M个goroutine进行调度和运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓的对goroutine的调度，是指程序代码按照一定的算法在适当的时候挑选出合适的goroutine并放到CPU上去运行的过程，这些负责对goroutine进行调度的程序代码我们称之为&lt;strong&gt;&lt;span&gt;goroutine调度器&lt;/span&gt;&lt;/strong&gt;。用极度简化了的伪代码来描述goroutine调度器的工作流程大概是下面这个样子：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:false;&quot;&gt;
// 程序启动时的初始化代码
......
for i := 0; i &amp;lt; N; i++ { // 创建N个操作系统线程执行schedule函数
    create_os_thread(schedule) // 创建一个操作系统线程执行schedule函数
}

//schedule函数实现调度逻辑
func schedule() {
   for { //调度循环
         // 根据某种算法从M个goroutine中找出一个需要运行的goroutine
         g := find_a_runnable_goroutine_from_M_goroutines()
         run_g(g) // CPU运行该goroutine，直到需要调度其它goroutine才返回
         save_status_of_g(g) // 保存goroutine的状态，主要是寄存器的值
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这段伪代码表达的意思是，程序运行起来之后创建了N个由内核调度的操作系统线程（为了方便描述，我们称这些系统线程为&lt;strong&gt;&lt;span&gt;工作线程&lt;/span&gt;&lt;/strong&gt;）去执行shedule函数，而schedule函数在一个调度循环中反复从M个goroutine中挑选出一个需要运行的goroutine并跳转到该goroutine去运行，直到需要调度其它goroutine时才返回到schedule函数中通过save_status_of_g保存刚刚正在运行的goroutine的状态然后再次去寻找下一个goroutine。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要强调的是，这段伪代码对goroutine的调度代码做了高度的抽象、修改和简化处理，放在这里只是为了帮助我们从宏观上了解goroutine的两级调度模型，具体的实现原理和细节将从本章开始进行全面介绍。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;调度器数据结构概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一章我们讨论操作系统线程及其调度时还说过，可以把内核对系统线程的调度简单的归纳为：&lt;strong&gt;&lt;span&gt;在执行操作系统代码时，内核调度器按照一定的算法挑选出一个线程并把该线程保存在内存之中的寄存器的值放入CPU对应的寄存器从而恢复该线程的运行。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;万变不离其宗，系统线程对goroutine的调度与内核对系统线程的调度原理是一样的，实质都是&lt;strong&gt;&lt;span&gt;通过保存和修改CPU寄存器的值来达到切换线程/goroutine的目的&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此，为了实现对goroutine的调度，需要引入一个数据结构来保存CPU寄存器的值以及goroutine的其它一些状态信息，在Go语言调度器源代码中，这个数据结构是一个名叫&lt;span&gt;&lt;strong&gt;g的结构体&lt;/strong&gt;&lt;/span&gt;，它保存了goroutine的所有信息，该结构体的每一个实例对象都代表了一个goroutine，调度器代码可以通过g对象来对goroutine进行调度，当goroutine被调离CPU时，调度器代码负责把CPU寄存器的值保存在g对象的成员变量之中，当goroutine被调度起来运行时，调度器代码又负责把g对象的成员变量所保存的寄存器的值恢复到CPU的寄存器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;要实现对goroutine的调度，仅仅有g结构体对象是不够的，至少还需要一个存放所有（可运行）goroutine的容器，便于工作线程寻找需要被调度起来运行的goroutine，于是Go调度器又引入了&lt;span&gt;&lt;strong&gt;schedt结构体&lt;/strong&gt;&lt;/span&gt;，一方面用来保存调度器自身的状态信息，另一方面它还拥有一个用来保存goroutine的运行队列。因为每个Go程序只有一个调度器，所以在每个Go程序中schedt结构体只有一个实例对象，该实例对象在源代码中被定义成了一个共享的全局变量，这样每个工作线程都可以访问它以及它所拥有的goroutine运行队列，我们称这个运行队列为&lt;span&gt;&lt;strong&gt;全局运行队列&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;既然说到全局运行队列，读者可能猜想到应该还有一个局部运行队列。确实如此，因为全局运行队列是每个工作线程都可以读写的，因此访问它需要加锁，然而在一个繁忙的系统中，加锁会导致严重的性能问题。于是，调度器又为每个工作线程引入了一个&lt;span&gt;&lt;strong&gt;私有的局部goroutine运行队列&lt;/strong&gt;&lt;/span&gt;，工作线程优先使用自己的局部运行队列，只有必要时才会去访问全局运行队列，这大大减少了锁冲突，提高了工作线程的并发性。在Go调度器源代码中，局部运行队列被包含在&lt;span&gt;&lt;strong&gt;p结构体&lt;/strong&gt;&lt;/span&gt;的实例对象之中，每一个运行着go代码的工作线程都会与一个&lt;span&gt;&lt;strong&gt;p结构体&lt;/strong&gt;&lt;/span&gt;的实例对象关联在一起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了上面介绍的g、schedt和p结构体，Go调度器源代码中还有一个用来代表工作线程的&lt;span&gt;&lt;strong&gt;m结构体&lt;/strong&gt;&lt;/span&gt;，每个工作线程都有唯一的一个m结构体的实例对象与之对应，m结构体对象除了记录着工作线程的诸如栈的起止位置、当前正在执行的goroutine以及是否空闲等等状态信息之外，还通过指针维持着与p结构体的实例对象之间的绑定关系。于是，通过m既可以找到与之对应的工作线程正在运行的goroutine，又可以找到工作线程的局部运行队列等资源。下面是g、p、m和schedt之间的关系图：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1671650/201905/1671650-20190502142738667-1586396708.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图中圆形图案代表g结构体的实例对象，三角形代表m结构体的实例对象，正方形代表p结构体的实例对象，其中红色的g表示m对应的工作线程正在运行的goroutine，而灰色的g表示处于运行队列之中正在等待被调度起来运行的goroutine。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从上图可以看出，每个m都绑定了一个p，每个p都有一个私有的本地goroutine队列，m对应的线程从本地和全局goroutine队列中获取goroutine并运行之。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;前面我们说每个工作线程都有一个m结构体对象与之对应，但并未详细说明它们之间是如何对应起来的，工作线程执行的代码是如何找到属于自己的那个m结构体实例对象的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只有一个工作线程，那么就只会有一个m结构体对象，问题就很简单，定义一个全局的m结构体变量就行了。可是我们有多个工作线程和多个m需要一一对应，怎么办呢？还记得第一章我们讨论过的&lt;span&gt;&lt;strong&gt;线程本地存储&lt;/strong&gt;&lt;/span&gt;吗？当时我们说过，线程本地存储其实就是线程私有的全局变量，这不正是我们所需要的吗？！只要每个工作线程拥有了各自私有的m结构体全局变量，我们就能在不同的工作线程中使用相同的全局变量名来访问不同的m结构体对象，这完美的解决我们的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体到goroutine调度器代码，每个工作线程在刚刚被创建出来进入调度循环之前就利用线程本地存储机制为该工作线程实现了一个指向m结构体实例对象的私有全局变量，这样在之后的代码中就使用该全局变量来访问自己的m结构体对象以及与m相关联的p和g对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了上述数据结构以及工作线程与数据结构之间的映射机制，我们可以把前面的调度伪代码写得更丰满一点：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// 程序启动时的初始化代码
......
for i := 0; i &amp;lt; N; i++ { // 创建N个操作系统线程执行schedule函数
     create_os_thread(schedule) // 创建一个操作系统线程执行schedule函数
}


// 定义一个线程私有全局变量，注意它是一个指向m结构体对象的指针
// ThreadLocal用来定义线程私有全局变量
ThreadLocal self *m
//schedule函数实现调度逻辑
func schedule() {
    // 创建和初始化m结构体对象，并赋值给私有全局变量self
   self = initm()   
    for { //调度循环
          if(self.p.runqueueisempty) {
                 // 根据某种算法从全局运行队列中找出一个需要运行的goroutine
                 g = find_a_runnable_goroutine_from_global_runqueue()
          } else {
                 // 根据某种算法从私有的局部运行队列中找出一个需要运行的goroutine
                 g = find_a_runnable_goroutine_from_local_runqueue()
          }
          run_g(g) // CPU运行该goroutine，直到需要调度其它goroutine才返回
          save_status_of_g(g) // 保存goroutine的状态，主要是寄存器的值
     }
} 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;仅仅从上面这个伪代码来看，我们完全不需要线程私有全局变量，只需在schedule函数中定义一个局部变量就行了。但真实的调度代码错综复杂，不光是这个schedule函数会需要访问m，其它很多地方还需要访问它，所以需要使用全局变量来方便其它地方对m的以及与m相关的g和p的访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在简单的介绍了Go语言调度器以及它所需要的数据结构之后，下面我们来看一下Go的调度代码中对上述的几个结构体的定义。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;重要的结构体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面介绍的这些结构体中的字段非常多，牵涉到的细节也很庞杂，光是看这些结构体的定义我们没有必要也无法真正理解它们的用途，所以在这里我们只需要大概了解一下就行了，看不懂记不住都没有关系，随着后面对代码逐步深入的分析，我们也必将会对这些结构体有越来越清晰的认识。为了节省篇幅，下面各结构体的定义略去了跟调度器无关的成员。另外，这些结构体的定义全部位于Go语言的源代码路径下的runtime/runtime2.go文件之中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;stack结构体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;stack结构体主要用来记录goroutine所使用的栈的信息，包括栈顶和栈底位置：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// Stack describes a Go execution stack.
// The bounds of the stack are exactly [lo, hi),
// with no implicit data structures on either side.
//用于记录goroutine使用的栈的起始和结束位置
type stack struct{  
    lo uintptr   // 栈顶，指向内存低地址
    hi uintptr   // 栈底，指向内存高地址
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;gobuf结构体&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;gobuf结构体用于保存goroutine的调度信息，主要包括CPU的几个寄存器的值：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type gobuf struct {
    // The offsets of sp, pc, and g are known to (hard-coded in) libmach.
    //
    // ctxt is unusual with respect to GC: it may be a
    // heap-allocated funcval, so GC needs to track it, but it
    // needs to be set and cleared from assembly, where it's
    // difficult to have write barriers. However, ctxt is really a
    // saved, live register, and we only ever exchange it between
    // the real register and the gobuf. Hence, we treat it as a
    // root during stack scanning, which means assembly that saves
    // and restores it doesn't need write barriers. It's still
    // typed as a pointer so that any other writes from Go get
    // write barriers.
    sp  uintptr  // 保存CPU的rsp寄存器的值
    pc  uintptr  // 保存CPU的rip寄存器的值
    g   guintptr // 记录当前这个gobuf对象属于哪个goroutine
    ctxt unsafe.Pointer
 
   // 保存系统调用的返回值，因为从系统调用返回之后如果p被其它工作线程抢占，
   // 则这个goroutine会被放入全局运行队列被其它工作线程调度，其它线程需要知道系统调用的返回值。
    ret sys.Uintreg 
    lr  uintptr
 
    // 保存CPU的rip寄存器的值
    bp  uintptr// for GOEXPERIMENT=framepointer
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;g结构体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;g结构体用于代表一个goroutine，该结构体保存了goroutine的所有信息，包括栈，gobuf结构体和其它的一些状态信息：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// 前文所说的g结构体，它代表了一个goroutine
type g struct {
    // Stack parameters.
    // stack describes the actual stack memory: [stack.lo, stack.hi).
    // stackguard0 is the stack pointer compared in the Go stack growth prologue.
    // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
    // stackguard1 is the stack pointer compared in the C stack growth prologue.
    // It is stack.lo+StackGuard on g0 and gsignal stacks.
    // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
 
   // 记录该goroutine使用的栈
    stack      stack  // offset known to runtime/cgo
    // 下面两个成员用于栈溢出检查，实现栈的自动伸缩，抢占调度也会用到stackguard0
    stackguard0 uintptr// offset known to liblink
    stackguard1 uintptr// offset known to liblink

    ......
 
    // 此goroutine正在被哪个工作线程执行
    m             *m // current m; offset known to arm liblink
    // 保存调度信息，主要是几个寄存器的值
    sched         gobuf
 
    ......
    // schedlink字段指向全局运行队列中的下一个g，
    //所有位于全局运行队列中的g形成一个链表
    schedlink     guintptr

    ......
    // 抢占调度标志，如果需要抢占调度，设置preempt为true
    preempt  bool // preemption signal, duplicates stackguard0 = stackpreempt

   ......
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;m结构体&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;m结构体用来代表工作线程，它保存了m自身使用的栈信息，当前正在运行的goroutine以及与m绑定的p等信息，详见下面定义中的注释：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type m struct{
    // g0主要用来记录工作线程使用的栈信息，在执行调度代码时需要使用这个栈
    // 执行用户goroutine代码时，使用用户goroutine自己的栈，调度时会发生栈的切换
    g0     *g    // goroutine with scheduling stack

    // 通过TLS实现m结构体对象与工作线程之间的绑定
    tls      [6]uintptr  // thread-local storage (for x86 extern register)
    mstartfn func()
    // 指向工作线程正在运行的goroutine的g结构体对象
    curg     *g      // current running goroutine
 
    // 记录与当前工作线程绑定的p结构体对象
    p      puintptr// attached p for executing go code (nil if not executing go code)
    nextp  puintptr
    oldp   puintptr// the p that was attached before executing a syscall
   
    // spinning状态：表示当前工作线程正在试图从其它工作线程的本地运行队列偷取goroutine
    spinning  bool// m is out of work and is actively looking for work
    blocked   bool// m is blocked on a note
   
    // 没有goroutine需要运行时，工作线程睡眠在这个park成员上，
    // 其它线程通过这个park唤醒该工作线程
    park         note
    // 记录所有工作线程的一个链表
    alllink      *m// on allm
    schedlink    muintptr

    // Linux平台thread的值就是操作系统线程ID
    thread       uintptr// thread handle
    freelink     *m     // on sched.freem

    ......
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;p结构体&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;p结构体用于保存工作线程执行go代码时所必需的资源，比如goroutine的运行队列，内存分配用到的缓存等等。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type p struct {
    lock mutex

    status      uint32// one of pidle/prunning/...
    link        puintptr
    schedtick   uint32    // incremented on every scheduler call
    syscalltick uint32    // incremented on every system call
    sysmontick  sysmontick// last tick observed by sysmon
    m           muintptr  // back-link to associated m (nil if idle)

    ......

    // Queue of runnable goroutines. Accessed without lock.
    //本地goroutine运行队列
    runqhead uint32 // 队列头
    runqtail uint32    // 队列尾
    runq    [256]guintptr //使用数组实现的循环队列
    // runnext, if non-nil, is a runnable G that was ready'd by
    // the current G and should be run next instead of what's in
    // runq if there's time remaining in the running G's time
    // slice. It will inherit the time left in the current time
    // slice. If a set of goroutines is locked in a
    // communicate-and-wait pattern, this schedules that set as a
    // unit and eliminates the (potentially large) scheduling
    // latency that otherwise arises from adding the ready'd
    // goroutines to the end of the run queue.
    runnextg uintptr

    // Available G's (status == Gdead)
    gFree struct{
        gList
        nint32
    }

    ......
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;schedt结构体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;schedt结构体用来保存调度器的状态信息和goroutine的全局运行队列：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
type schedt struct {
    // accessed atomically. keep at top to ensure alignment on 32-bit systems.
    goidgen   uint64
    lastpoll  uint64

    lock mutex

    // When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
    // sure to call checkdead().

   // 由空闲的工作线程组成链表
    midle       muintptr // idle m's waiting for work
   // 空闲的工作线程的数量
    nmidle        int32 // number of idle m's waiting for work
    nmidlelocked  int32 // number of locked m's waiting for work
    mnext         int64 // number of m's that have been created and next M ID
   // 最多只能创建maxmcount个工作线程
    maxmcount    int32 // maximum number of m's allowed (or die)
    nmsys        int32 // number of system m's not counted for deadlock
    nmfreed      int64 // cumulative number of freed m's

    ngsys        uint32 // number of system goroutines; updated atomically

    // 由空闲的p结构体对象组成的链表
    pidle     puintptr // idle p's
   // 空闲的p结构体对象的数量
    npidle     uint32
    nmspinning uint32 // See &quot;Worker thread parking/unparking&quot; comment in proc.go.

    // Global runnable queue.
   // goroutine全局运行队列
    runq       gQueue
    runqsize   int32

    ......

    // Global cache of dead G's.
   // gFree是所有已经退出的goroutine对应的g结构体对象组成的链表
   // 用于缓存g结构体对象，避免每次创建goroutine时都重新分配内存
    gFree struct{
        lock        mutex
        stack       gList // Gs with stacks
        noStack     gList // Gs without stacks
        n           int32
    }
 
    ......
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;重要的全局变量&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:false;&quot;&gt;
allgs    []*g   // 保存所有的g
allm     *m     // 所有的m构成的一个链表，包括下面的m0
allp     []*p  // 保存所有的p，len(allp) == gomaxprocs

ncpu         int32  // 系统中cpu核的数量，程序启动时由runtime代码初始化
gomaxprocs   int32  // p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改

sched     schedt    // 调度器结构体对象，记录了调度器的工作状态

m0 m        // 代表进程的主线程
g0  g       // m0的g0，也就是m0.g0 = &amp;amp;g0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在程序初始化时，这些全变量都会被初始化为0值，指针会被初始化为nil指针，切片初始化为nil切片，int被初始化为数字0，结构体的所有成员变量按其本类型初始化为其类型的0值。所以程序刚启动时allgs，allm和allp都不包含任何g,m和p。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 May 2019 06:43:00 +0000</pubDate>
<dc:creator>爱写程序的阿波张</dc:creator>
<og:description>本节主要介绍goroutine调度器工作原理及所涉及到的重要结构体与全局变量。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abozhang/p/10802319.html</dc:identifier>
</item>
<item>
<title>Oracle性能调优之虚拟索引用法简介 - smileNicky</title>
<link>http://www.cnblogs.com/mzq123/p/10802259.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10802259.html</guid>
<description>&lt;p&gt;本博客记录一下Oracle虚拟索引的用法，虚拟索引是定义在数据字典中的伪索引，可以说是伪列，没有修改的索引字段的。虚拟索引的目的模拟索引，不会增加存储空间的使用，有了虚拟索引，开发者使用执行计划的时候也不需要等索引完全创建好才可以看到效果&lt;/p&gt;
&lt;p&gt;ok，这里找张用户表来测试一下虚拟索引&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//设置执行计划
SQL&amp;gt; set autotrace traceonly

//查询用户，因为没加索引，所以是全表扫描
SQL&amp;gt; select * from sys_user where username='admin';

//创建虚拟索引，记得加关键字nosegment
SQL&amp;gt;create index idx_username on sys_user(username) nosegment;

//先关了执行计划自动打印
SQL&amp;gt;set autotrace off

//查一下索引表里有对应索引字段？这里没查到，说明虚拟索引并没有创建索引列
SQL&amp;gt;  select index_name from dba_indexes where table_name='sys_user' and index_n
ame='IDX_USERNAME';
未选定行

//再查一下索引对象里有数据？这里可以查到，说明虚拟索引还是有创建索引对象的
SQL&amp;gt; select object_name,object_type from dba_objects where object_name='IDX_USER
NAME';
OBJECT_NAME          OBJECT_TYPE
--------------------              -------------------
IDX_USERNAME           INDEX

//再开启执行计划自动打印
SQL&amp;gt; set autotrace traceonly

//查询一下，发现还是TABLE ACCESS FULL，并没有走索引，不是创建了虚拟索引了？
SQL&amp;gt; select * from sys_user where username='admin';
执行计划
----------------------------------------------------------
Plan hash value: 4234589240
------------------------------------------------------------------------------
| Id  | Operation         | Name     | Rows  | Bytes | Cost (%CPU)| Time     |
------------------------------------------------------------------------------
|   0 | SELECT STATEMENT  |          |     1 |   272 |     3   (0)| 00:00:01 |
|*  1 |  TABLE ACCESS FULL| SYS_USER |     1 |   272 |     3   (0)| 00:00:01 |
------------------------------------------------------------------------------
...//省略执行计划信息

//注意：虚拟索引使用，需要设置一下，改为true才可以
SQL&amp;gt; alter session set &quot;_USE_NOSEGMENT_INDEXES&quot; = true;
会话已更改。

//再次查询，可以看到走虚拟索引了，TABLE ACCESS BY INDEX ROWID，虚拟索引使用成功
SQL&amp;gt; select * from sys_user where username='admin';
执行计划
----------------------------------------------------------
Plan hash value: 1796849462
--------------------------------------------------------------------------------
| Id  | Operation                   | Name         | Rows  | Bytes | Cost (%CPU)
| Time     |
--------------------------------------------------------------------------------
------------
|   0 | SELECT STATEMENT            |              |     1 |   272 |     2   (0)
| 00:00:01 |
|   1 |  TABLE ACCESS BY INDEX ROWID| SYS_USER     |     1 |   272 |     2   (0)
| 00:00:01 |
|*  2 |   INDEX RANGE SCAN          | IDX_USERNAME |     1 |       |     1   (0)
| 00:00:01 |
...//省略执行计划信息
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;综上分析，虚拟索引创建关键的步骤是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter session set &quot;_use_nosegment_indexes&quot;=true;

create index index_name on table_name(col_name) nosegment;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虚拟索引也可以删除，用法和删索引一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;drop index [索引名称] on [表格名称]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就是虚拟索引的简要介绍，假如在生产环境，怕加了索引影响系统性能，或许可以加虚拟索引，怕占太多存储空间，也可以加上虚拟索引，虚拟索引有时候常被用于SQL调优，虚拟索引关键字是nosegment&lt;/p&gt;
</description>
<pubDate>Thu, 02 May 2019 06:22:00 +0000</pubDate>
<dc:creator>smileNicky</dc:creator>
<og:description>本博客记录一下Oracle虚拟索引的用法，虚拟索引是定义在数据字典中的伪索引，可以说是伪列，没有修改的索引字段的。虚拟索引的目的模拟索引，不会增加存储空间的使用，有了虚拟索引，开发者使用执行计划的时候</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10802259.html</dc:identifier>
</item>
<item>
<title>我司使用了六年的分布式锁 - 踩刀诗人</title>
<link>http://www.cnblogs.com/chopper-poet/p/10802242.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chopper-poet/p/10802242.html</guid>
<description>&lt;p&gt;&lt;span&gt;导读：不管是在单体应用时代还是分布式应用时代，一些保障我们数据安全的手段从来都未过时，只是底层实现发生了一些变化，今天我就来分享一下我司使用了六年的分布式锁方案，希望对一些同学有一些帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关键词：分布式，并发，原子性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;提到数据一致性、操作原子性，诸如此类的一些与并发有关的词汇时不知道你第一时间会联想到什么呢？我相信大多数人可能会想到“锁”，为什么是锁呢，这个我不多说，大家心里应该都明白。在单体应用时代，我们使用jvm提供的锁就可以很好的工作，但是到了分布式应用时代，jvm提供的锁就行不通了，那么势必要借助一些跨jvm的临界资源来支持锁的相关语义，比如redis，zookeeper等。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;步入正题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我今天就来分享下我司基于redis来实现的分布式锁，2013年投入使用，也算是久经沙场。但是也存在一些设计上的缺陷，这个我后面也会提到，希望大家秉着互相学习的态度文明交流，别一上来就说这不行那不行，还是那句话“适合自己的才是最好的”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;加锁过程分析&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846817/201905/846817-20190502115442517-111829811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我第一次读代码的时候，有这么几个疑惑：&lt;/p&gt;
&lt;p&gt;Q1：为什么不使用 SET key value [expiration EX seconds|PX milliseconds] [NX|XX]  这个指令来实现key的自动过期呢，反而放到应用代码判断key是否过期？&lt;/p&gt;
&lt;p&gt;A1：我们的分布式锁开发的时候SET命令还不支持NX、PX，所以才想出这种办法来实现key过期，NX、PX在2.6.12以后开始支持；&lt;/p&gt;
&lt;p&gt;Q2：已经判断了当前key对应的时间戳已经过期了，为什么还要使用getset再获取一次呢，直接使用set指令覆盖不可以吗？&lt;/p&gt;
&lt;p&gt;A2：这里其实牵扯到并发的一些事情，如果直接使用set，那有可能多个客户端会同时获取到锁，如果使用getset然后判断旧值是否过期就不会有这个问题，设想一下如下场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C1加锁成功，不巧的是，这时C1意外的奔溃了，自然就不会释放锁；&lt;/li&gt;
&lt;li&gt;C2，C3尝试加锁，这时key已存在，所以C2，C3去判断key是否已过期，这里假设key已经过期了，所以C2，C3使用set指令去设置值，那两个都会加锁成功，这就闯大祸了；如果使用getset指令，然后判断下返回值是否过期就可以避免这种问题，假如C2跑的快，那C3判断返回的时间戳已经过期，自然就加锁失败；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;释放锁过程分析&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846817/201905/846817-20190502132646160-1002663690.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; Q1：为什么释放锁时还需要判断key是否过期呢，直接del不是性能更高吗？&lt;/p&gt;
&lt;p&gt;A1：考虑这样一种场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C1获取锁成功，开始执行自己的操作，不幸的是C1这时被阻塞了；&lt;/li&gt;
&lt;li&gt;C2这时来获取锁，由于C1被阻塞了很长时间，所以key对应的value已经过期了，这时C2通过getset加锁成功；&lt;/li&gt;
&lt;li&gt;C1尘封了太久终于被再次唤醒，对于释放锁这件事它可是认真的，伴随着一波del操作，悲剧即将发生；&lt;/li&gt;
&lt;li&gt;C3来获取锁，好家伙，居然一下就成功了，接着就是一波操作猛如虎，接着就是一堆的客诉过来了；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么会这样呢？回想C1被唤醒以后的事情，居然敢直接del，C2活都没干完呢，锁就被C1给释放了，这时C3来直接就加锁成功，所以为了安全起见C3释放锁时得分成两步：1.判断value是否已经过期 2.如果已过期直接忽略，如果没过期就执行del。这样就真的安全了吗？安全了吗？安全了吗？假如第一步和第二步之间相隔了很久是不是也会出现锁被其他人释放的问题呢？是吧？是的！有没有别的解决办法呢？听说借助lua就可以解决这个问题了，感兴趣的直接给你&lt;a href=&quot;https://redis.io/commands/set&quot; target=&quot;_blank&quot;&gt;传送&lt;/a&gt;过去可好。&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;正视自己的缺点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Q1：Redis锁的过期时间小于业务的执行时间该如何续期？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A1：这个暂时没有实现，据说有一个叫Redisson的家伙解决了这个问题，我们也有部分业务在使用，未来有可能会切换到Redisson。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Q2：怎么实现的高可用？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;A2：我们采用Failover机制，初始化redis锁的时候会维护一个redis连接池，加锁或者释放锁的时候采用多写的方式来保障一致性，如果某个节点不可用的时候会自动切换到其他节点，但是这种机制可能会导致多个客户端同时获取到锁的情况，考虑这种情况：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;C1去redis1加锁，加锁成功后会写到redis2，redis3；&lt;/li&gt;
&lt;li&gt;C2也去redis1加锁，但是此时C2到redis1的网络出现问题，这时C2切换到redis2去加锁，由于第一步中的redis多写并不是原子的，所有就有可能导致C2也获取锁成功；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对这种情况，目前有些业务方是通过数据库唯一索引的方式来规避的，未来会修复这个bug，具体方案目前还没有。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;五一假期抽一点时间来做一个简单的分享，希望对有些同学能起到帮助，不喜勿喷。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 02 May 2019 06:11:00 +0000</pubDate>
<dc:creator>踩刀诗人</dc:creator>
<og:description>导读：不管是在单体应用时代还是分布式应用时代，一些保障我们数据安全的手段从来都未过时，只是底层实现发生了一些变化，今天我就来分享一下我司使用了六年的分布式锁方案，希望对一些同学有一些帮助。 关键词：分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chopper-poet/p/10802242.html</dc:identifier>
</item>
<item>
<title>import与from...import... - 咸鱼Chen</title>
<link>http://www.cnblogs.com/nickchen121/p/10802052.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickchen121/p/10802052.html</guid>
<description>&lt;p&gt;一般使用import和from...import...导入模块。&lt;/p&gt;
&lt;p&gt;以下述spam.py内的文件代码为例。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# spam.py
print('from the spam.py')

money = 1000


def read1():
    print('spam模块：', money)


def read2():
    print('spam模块')
    read1()


def change():
    global money
    money = 0&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# run.py
import spam  # from the spam.py
import spam&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;import首次导入模块发生了3件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;以模块为准创造一个模块的名称空间&lt;/li&gt;
&lt;li&gt;执行模块对应的文件，将执行过程中产生的名字都丢到模块的名称空间&lt;/li&gt;
&lt;li&gt;在当前执行文件中拿到一个模块名&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;模块的重复导入会直接饮用之前创造好的结果，不会重复执行模块的文件，即重复导入会发生：spam=spam=模块名称空间的内存地址&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# run.py
import spam as sm


money = 111111

sm.money
sm.read1()  # 'spam模块：1000'
sm.read2
sm.change()

print(money)  # 1000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导入多个模块&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import spam, time, os

# 推荐使用下述方式
import spam
import time
import os&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# run.py

from spam import money

money = 10

print(money)  # 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;from...import...首次导入模块发生了3件事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;以模块为准创造一个模块的名称空间&lt;/li&gt;
&lt;li&gt;执行模块对应的文件，将执行过程中产生的名字都丢到模块的名称空间&lt;/li&gt;
&lt;li&gt;在当前执行文件的名称空间中拿到一个名字，该名字直接指向模块中的某一个名字，意味着可以不用加任何前缀而直接使用&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;优点：不用加前缀，代码更加精简&lt;/li&gt;
&lt;li&gt;缺点：容易与当前执行文件中名称空间中的名字冲突&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;导入文件内所有的功能：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# spam.py

__all__ = ['money', 'read1']  # 只允许导入'money'和'read1'&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# run.py
from spam import *  # 导入spam.py内的所有功能，但会受限制于__all__&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;相同点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;两者都会执行模块对应的文件，两者都会产生模块的名称空间&lt;/li&gt;
&lt;li&gt;两者调用功能时，需要跑到定义时寻找作用域关系，与调用位置无关&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不同点&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;import需要加前缀；from...import...不需要加前缀&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 02 May 2019 04:36:00 +0000</pubDate>
<dc:creator>咸鱼Chen</dc:creator>
<og:description>Python之import与from...import...</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nickchen121/p/10802052.html</dc:identifier>
</item>
<item>
<title>【剑指Offer】斐波那契数列 - 坏坏也童鞋</title>
<link>http://www.cnblogs.com/iwiniwin/p/10798884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iwiniwin/p/10798884.html</guid>
<description>&lt;p&gt;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。&lt;br/&gt;n&amp;lt;=39&lt;/p&gt;
&lt;h2 id=&quot;解法1-递归&quot;&gt;解法1 递归&lt;/h2&gt;
&lt;p&gt;解题前先简单说明一下斐波那契数列，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……，因数学家列昂纳多·斐波那契以兔子繁殖为例子而引入，故又称为兔子数列。可以表示为&lt;code&gt;F(n) = F(n-1) + F(n-2)&lt;/code&gt;。这道题在不考虑效率的情况下，最直接的解法是用递归，代码如下&lt;/p&gt;
&lt;h3 id=&quot;实现代码&quot;&gt;实现代码&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public int Fibonacci(int n)
{
    if (n == 0)
    {
        return 0;
    }
    else if (n == 1 || n == 2)
    {
        return 1;
    }else
    {
        return Fibonacci(n - 1) + Fibonacci(n - 2);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解法2-动态规划&quot;&gt;解法2 动态规划&lt;/h2&gt;
&lt;p&gt;解法1使用递归虽然很直观，简单，但是效率太低。在n &amp;lt;= 39的情况下，运行时间为1277ms，究其原因还是算法中存在大量重复运算。以求解斐波那契数列第6项的过程来说明，如下图，在求解F6的过程中，F4会被重复计算2次，F3会被重复计算3次，这都导致了多余的消耗，且随着n越来越大冗余计算的增长是爆炸性的。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190418224254995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZpZ2h0TGVp,size_16,color_FFFFFF,t_70&quot; alt=&quot;斐波那契数列第6项&quot;/&gt;&lt;br/&gt;递归的思想是自顶向下的，Fn的求解基于Fn-1和Fn-2，Fn-1的求解又基于Fn-2和Fn-3等等依次类推。而现在我们可以反过来，自底向上，在已知F1 = 1，F2 = 1的情况下求解F3，再利用F3和F2求解F4直到求出Fn。即不使用递归，使用循环迭代的方式。相比于解法1，优化后的算法运行时间只有39ms。&lt;/p&gt;
&lt;h3 id=&quot;实现代码-1&quot;&gt;实现代码&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public int FibonacciOptimize(int n)
{
    if (n == 0)
    {
        return 0;
    }
    int fibl = 1, fibn = 1;
    for(int i = 2; i &amp;lt; n; i++)
    {
        fibn = fibl + fibn;
        fibl = fibn - fibl;
    }
    return fibn;
}

//或者是更简洁一点的写法

public int FibonacciOptimize2(int n)
{
    int f = 0, g = 1;
    while(n -- &amp;gt; 0)
    {
        g += f;
        f = g - f;
    }
    return f;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;动态规划&quot;&gt;动态规划&lt;/h2&gt;
&lt;p&gt;上面不使用递归，而使用循环的方式，我们可以给它起一个高大上的名字，动态规划。什么叫做动态规划呢，其实和它本身字面上的意思并没有太大关系。&lt;br/&gt;对于递归算法，编译器常常都只能做很低效的处理，递归算法如此慢的原因在于，编译器模拟的递归不能保留预先算出来的值，对已经求解过的子问题仍在递归的进行调用，导致了大量的冗余计算，比如上面的斐波那契递归算法。当我们想要改善这种情况时，可以将递归算法改成非递归算法，让后者把那些子问题的答案系统地记录下来，利用这种方法的一种技巧就叫做动态规划。比如上面的代码，我们都是用了两个变量把上一次的计算结果记录了下来，避免了重复计算。&lt;br/&gt;可能上面的算法对动态规划的体现并不是那么直观，可以看下面这段代码。我们用一个数组，将每次求解出来的Fn都记录了下来，当一个子问题被求解过以后，下一次就可以直接通过索引访问数组得到，而避免了再次求解。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public int FibonacciOptimize3(int n)
{
    if (n == 0)
    {
        return 0;
    }
    int[] array = new int[n + 1];
    array[0] = 1;
    array[1] = 1;
    for(int i = 2; i &amp;lt; n; i++)
    {
        array[i] = array[i - 1] + array[i - 2];
    }
    return array[n - 1];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解法3&quot;&gt;解法3&lt;/h2&gt;
&lt;p&gt;除了使用递归和动态规划外，我们还可以使用矩阵来求解斐波那契数列。对于矩阵这里不再进行扩展，只介绍本算法会用到的基本概念。如下所示的M就是一个2x2的矩阵，2行2列。&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[M = \left[ \begin{matrix} 1 &amp;amp; 2\\ 3 &amp;amp; 4\\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;矩阵和矩阵之间可以相乘，一个rxn的矩阵M和一个nxc的矩阵N相乘，它们的结果MN将会是一个rxc大小的矩阵。注意如果两个矩阵的行列不满足上面的规定，则这两个矩阵就不能相乘。怎样计算新的矩阵MN呢，可以用一个简单的方式描述：对于每个元素c~ij~，我们找到M中的第i行和N中的第j列，然后把它们对应元素相乘后再加起来，这个和就是c~ij~，对于有矩阵M，N如下&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[M = \left[ \begin{matrix} a &amp;amp; b\\ c &amp;amp; d\\ \end{matrix} \right] N = \left[ \begin{matrix} e &amp;amp; f\\ g &amp;amp; i\\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;则MN为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[MN = \left[ \begin{matrix} ae + bg &amp;amp; af + bi\\ ce + dg &amp;amp; cf + di\\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;那么斐波那契数列和矩阵有什么关系呢？&lt;br/&gt;我们已知斐波那契第n项，Fn = F(n - 1) + F(n - 2)，可以将它们转换成如下所示的矩阵形式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left[ \begin{matrix} F(n)\\ F(n-1)\\ \end{matrix} \right] = \left[ \begin{matrix} F(n-1) + F(n-2)\\ F(n-1)\\ \end{matrix} \right]= \left[ \begin{matrix} F(n-1) * 1 + F(n-2) * 1\\ F(n-1) * 1 + F(n-2) * 0\\ \end{matrix} \right]= \left[ \begin{matrix} 1 &amp;amp; 1\\ 1 &amp;amp; 0\\ \end{matrix} \right] \left[ \begin{matrix} F(n-1)\\ F(n-2)\\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left[ \begin{matrix} F(n)\\ F(n-1)\\ \end{matrix} \right] = \left[ \begin{matrix} 1 &amp;amp; 1\\ 1 &amp;amp; 0\\ \end{matrix} \right] \left[ \begin{matrix} F(n-1)\\ F(n-2)\\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left[ \begin{matrix} F(n-1)\\ F(n-2)\\ \end{matrix} \right] = \left[ \begin{matrix} 1 &amp;amp; 1\\ 1 &amp;amp; 0\\ \end{matrix} \right] \left[ \begin{matrix} F(n-2)\\ F(n-3)\\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left[ \begin{matrix} F(n)\\ F(n-1)\\ \end{matrix} \right] = \left[ \begin{matrix} 1 &amp;amp; 1\\ 1 &amp;amp; 0\\ \end{matrix} \right] ^2 \left[ \begin{matrix} F(n-2)\\ F(n-3)\\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;以此类推&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left[ \begin{matrix} F(n)\\ F(n-1)\\ \end{matrix} \right] = \left[ \begin{matrix} 1 &amp;amp; 1\\ 1 &amp;amp; 0\\ \end{matrix} \right] ^{n-1} \left[ \begin{matrix} F(1)\\ F(0)\\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;所以要求斐波那契的第n项，我们只需要求得F1和F0构成的矩阵与特定矩阵的n-1次方相乘后的矩阵，然后取该矩阵的第一行第一列的元素值就是Fn&lt;br/&gt;现在引入了一个新的问题，怎样求特定矩阵的n-1次方，即矩阵的快速幂&lt;/p&gt;
&lt;h2 id=&quot;矩阵的快速幂&quot;&gt;矩阵的快速幂&lt;/h2&gt;
&lt;p&gt;在了解矩阵的快速幂之前，我们先看普通整数的快速幂&lt;br/&gt;求解整数m的n次方，一般是m^n^ = m * m * m .....，连乘n次，算法复杂度是O(n)，这样的算法效率太低，我们可以通过减少相乘的次数来提高算法效率，即快速幂&lt;br/&gt;对于n我们可以用二进制表示，以14为例，14 = 1110&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ m^{14} = m^{1110} = m^{2^{3} * 1 + 2^{2} * 1 + 2^{1} * 1 + 2^{0} * 1} = m^{2^{3} * 1} * m^{2^{2} * 1} * m^{2^{1} * 1} * m^{2^{0} * 0} \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ = m^{8} * m^{4} * m^{2} * m^{0} = m^{8} * m^{4} * m^{2} * 1 \]&lt;/span&gt;&lt;br/&gt;可以发现这样的规律，指数n的二进制从低位到高位依次对应底数m的1次方，2次方，4次方，8次方...，当该二进制位是1的时候，则乘以底数对应的次方数，如果该二进制位是0，则表示乘以1。使用快速幂后，原本需要14次连乘，现在只需要4次连乘。&lt;br/&gt;那么怎样得到一个整数的二进制位呢，又怎样判断该二进制位是0还是1呢&lt;br/&gt;可以使用与运算和右移运算，例如对于14 = 1110&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;和1按位与得到0，即第一个二进制位是0&lt;/li&gt;
&lt;li&gt;1110右移一位，得到0111，和1按位与得到1，即第二个二进制位是1&lt;/li&gt;
&lt;li&gt;0111右移一位，得到0011，和1按位与得到1，即第三个二进制位是1&lt;/li&gt;
&lt;li&gt;0011右移一位，得到0001，和1按位与得到1，即第四个二进制位是1&lt;/li&gt;
&lt;li&gt;0001右移一位，得到0000，等于0则，算法结束&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应的代码如下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public int pow(int m, int n)
{
    int ret = 1;
    while(n &amp;gt; 0)
    {
        if ((n &amp;amp; 1) &amp;gt; 0)
        {
            ret = ret * m;
        }
        m *= m;
        n &amp;gt;&amp;gt;= 1;
    }
    return ret;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应矩阵的快速幂就是&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 简单实现了2*2矩阵的乘法
public int[,] matrixMul(int[,] m, int[,] n)
{
    int[,] ret = {
        { m[0,0] * n[0,0] + m[0,1] * n[1,0],  m[0,0] * n[0,1] + m[0,1] * n[1,1]} ,
        { m[1,0] * n[0,0] + m[1,1] * n[1,0],  m[1,0] * n[0,1] + m[1,1] * n[1,1]}
    };
    return ret;
}
// 矩阵的快速幂
public int[,] matrixPow(int[,] m, int n)
{
    // 单位矩阵，作用相当于整数乘法中的1
    int[,] ret = { { 1, 0 }, { 0, 1 } };
    while(n &amp;gt; 0)
    {
        if ((n &amp;amp; 1) &amp;gt; 0)
        {
            ret = matrixMul(m, ret);
        }
        m = matrixMul(m, m);
        n &amp;gt;&amp;gt;= 1;
    }
    return ret;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现代码-2&quot;&gt;实现代码&lt;/h3&gt;
&lt;p&gt;在已经知道矩阵的快速幂之后，求解Fn就可以直接代入公式&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \left[ \begin{matrix} F(n)\\ F(n-1)\\ \end{matrix} \right] = \left[ \begin{matrix} 1 &amp;amp; 1\\ 1 &amp;amp; 0\\ \end{matrix} \right] ^{n-1} \left[ \begin{matrix} F(1)\\ F(0)\\ \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;实现代码如下&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public int FibonacciOptimize4(int n)
{
    if (n == 0)
    {
        return 0;
    }
    int[,] matrix = { { 1, 1 }, { 1, 0 } };
    // 这里的F1和F0矩阵多加了一列0,0，不会影响最终结果，是因为matrixMul只实现了2*2矩阵的乘法
    int[,] unit = { { 1, 0 }, { 0, 0 } };
    // 调用前面代码的矩阵乘法和矩阵快速幂
    int[,] ret = matrixMul(matrixPow(matrix, n - 1), unit);
    return ret[0, 0];
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 02 May 2019 04:00:00 +0000</pubDate>
<dc:creator>坏坏也童鞋</dc:creator>
<og:description>分享斐波那契数列的动态规划，矩阵快速幂，递归多种求解方法。大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/iwiniwin/p/10798884.html</dc:identifier>
</item>
<item>
<title>为什么我的对象被 IntelliJ IDEA 悄悄的修改了？ - ocean.wen</title>
<link>http://www.cnblogs.com/ocean234/p/10779784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ocean234/p/10779784.html</guid>
<description>&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;    最近，在复习JUC的时候调试了一把ConcurrentLinkedQueue的&lt;code&gt;offer&lt;/code&gt;方法，意外的发现Idea在debug模式下竟然会 “自动修改” 已经创建的Java对象，当时觉得这个现象很是奇怪，现在把问题的原因以及解决过程记录下来，希望你在调试的时候不要踩坑。&lt;/p&gt;
&lt;h3 id=&quot;调试代码&quot;&gt;调试代码&lt;/h3&gt;
&lt;p&gt;    调试的代码很简单，就是多次调用&lt;code&gt;offer&lt;/code&gt;方法，然后观察ConcurrentLinkedQueue的&lt;code&gt;head&lt;/code&gt;和&lt;code&gt;tail&lt;/code&gt;属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.lang.reflect.Field;
import java.util.concurrent.ConcurrentLinkedQueue;

public class ConcurrentLinkedQueueTest {

    public static void main(String[] args) {
        ConcurrentLinkedQueue&amp;lt;String&amp;gt; queue = new ConcurrentLinkedQueue&amp;lt;&amp;gt;();
        print(queue);
        queue.offer(&quot;aaa&quot;);
        print(queue);
        queue.offer(&quot;bbb&quot;);
        print(queue);
        queue.offer(&quot;ccc&quot;);
        print(queue);
    }

    /**
     * 打印并发队列head属性的identityHashCode
     * @param queue
     */
    private static void print(ConcurrentLinkedQueue queue) {
        Field field = null;
        boolean isAccessible = false;
        try {
            field = ConcurrentLinkedQueue.class.getDeclaredField(&quot;head&quot;);
            isAccessible = field.isAccessible();
            if (!isAccessible) {
                field.setAccessible(true);
            }
            System.out.println(&quot;head: &quot; + System.identityHashCode(field.get(queue)));
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            field.setAccessible(isAccessible);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;调试过程&quot;&gt;调试过程&lt;/h3&gt;
&lt;p&gt;    上述代码在Idea中debug模式下head属性会无缘无故的被修改（run模式下正常，debug模式下关闭所有断点也正常），检查ConcurrentLinkedQueue的源码发现，head属性只有在构造器和反序列化的&lt;code&gt;readObject&lt;/code&gt;共3处地方才会被直接赋值（不是cas修改），我也仔细检查了offer方法，确实没有修改head的地方。而Idea在debug时，把head属性修改为第一次&lt;code&gt;offer&lt;/code&gt;的Node节点，这个现象就很奇怪了。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在run模式下的输出结果，多次调用offer方法，head属性都是同一个对象（debug模式下关闭所有断点也是同样的效果）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631355/201904/631355-20190427214601211-248515275.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在offer方法中断点，然后debug并单步调试（Step over）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631355/201904/631355-20190427215410065-205556538.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在offer方法中断点，然后debug并直接运行到下一个断点（Resume program）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631355/201904/631355-20190427215449861-1463261224.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;    由上可见，在debug进入offer方法之后head属性确实被修改了（对象已经不是同一个），而且这不是偶尔出现，而是一直可以复现的，Step over和Resume program也表现出了修改head属性不同的时机，这让人很费解。 更费解的是就算不在offer方法体里断点，在main方法中断点也会出现head被修改的现象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;转战到Eclipse，同样的环境，同样的操作，在run和debug模式下都不会出现head被修改的情况&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631355/201904/631355-20190427221353433-1352527588.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;    了解到Idea在debug模式下默认开启了&lt;code&gt;toString&lt;/code&gt;预览特性（Settings&amp;gt;&amp;gt;Build,Execution,Deployment&amp;gt;&amp;gt;Debugger&amp;gt;&amp;gt;Data Views&amp;gt;&amp;gt;Java&amp;gt;&amp;gt;Enable 'toString()' object view），可是调用toString方法也不至于把对象本身都修改了啊，也专门看了下ConcurrentLinkedQueue的内部类Node，并没有复写toString方法（事后回顾，当时在这里疏忽了，下文会再介绍），但还是关掉特性再测试一遍，然而还是同样的结果，head属性任然被悄悄的修改了。第二天来到公司在同事的环境（IntelliJ IDEA 2019.1）上验证了下，还是同样的问题，排除Idea版本的因素。&lt;/p&gt;
&lt;p&gt;    郁闷了一会儿，就向&quot;网友&quot;提问了&lt;a href=&quot;https://stackoverflow.com/questions/55889152/why-my-object-has-been-changed-by-intellij-ideas-debugger-soundlessly&quot;&gt;链接&lt;/a&gt;，不久就得到了IntelliJ IDEA的产品经理yole的回复，他的意思还是Idea 的 Data Views 的 toString 在作怪，上文已经说过关掉toString特性还是有这个问题，但是他给了我一个重要的思路就是：在debug模式下，ConcurrentLinkedQueue的对象也会被调用toString方法的，在队列的toString方法中会获取队列的迭代器，而创建迭代器时会调用&lt;code&gt;first&lt;/code&gt;方法，first方法里就会cas修改head属性。（之前确实没考虑到队列本身的toString方法，而是去看Node是否重写了toString，手动哭脸😭）&lt;br/&gt;    这里需要注意的是，尽管关掉toString特性上面问题还是存在，原因就在于ConcurrentLinkedQueue是一个Collection，Data Views 还有一个选项“Enable alternative view for Collections classes” （平时没注意...）所以也会在debug时造成队列迭代器的遍历。把这个特性也一并关掉，则上面的问题就不会再出现了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/631355/201904/631355-20190429141045413-173558177.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;    之前看到有网友在调试低版本的fastjson的反序列化时也遇到过Idea toString的问题，虽然这可能不会影响程序的正常执行，但是作为开发人员，在debug时完全可能会遇到这种被Idea挖坑的情况。对于Data views特性我目前也持保留态度，如果不是特别依赖就直接关掉吧。&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/dajiangqingzhou/article/details/78676459&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/dajiangqingzhou/article/details/78676459&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/oldtrafford/p/8612089.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/oldtrafford/p/8612089.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 May 2019 03:58:00 +0000</pubDate>
<dc:creator>ocean.wen</dc:creator>
<og:description>背景     最近，在复习JUC的时候调试了一把ConcurrentLinkedQueue的 方法，意外的发现Idea在debug模式下竟然会 “自动修改” 已</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ocean234/p/10779784.html</dc:identifier>
</item>
</channel>
</rss>