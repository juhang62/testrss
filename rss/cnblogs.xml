<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用Linux感觉低效吗？来看看这几个技巧！ - 银河使者</title>
<link>http://www.cnblogs.com/nokiaguy/p/12978153.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nokiaguy/p/12978153.html</guid>
<description>&lt;p&gt;Linux已经成为目前最火的操作系统之一，尽管现在的Linux用户很多，但很多使用Linux的同学发现，他们在Linux下的工作效率并不高，那么这是为什么呢？其实使用Linux也可以很舒适，通过一些技巧，也可以让工作效率大大提升。本文将介绍一些有助于提高Linux工作效率的技巧，让我们的工作变得变得更为舒适、优雅。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;130.52219112355&quot;&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202005/32818-20200528080553414-1737827957.jpg&quot; alt=&quot;&quot; width=&quot;632&quot; height=&quot;269&quot;/&gt;&lt;/div&gt;

&lt;p&gt;Linux已经成为目前最火的操作系统之一，尽管现在的Linux用户很多，但很多使用Linux的同学发现，他们在Linux下的工作效率并不高，那么这是为什么呢？其实使用Linux也可以很舒适，通过一些技巧，也可以让工作效率大大提升。本文将介绍一些有助于提高Linux工作效率的技巧，让我们的工作变得变得更为舒适、优雅。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 跳转目录随心所欲&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（1）bd 命令&lt;/p&gt;

&lt;p&gt;如果当前目录很深，那么要往上跳转多层目录，就需要执行“cd ../../../..”这样的命令，而且不小心还容易弄错层数，显得有点傻。不过使用bd命令，一切都会有所不同。&lt;/p&gt;

&lt;p&gt;bd是第三方命令，需要使用下面的命令安装。&lt;/p&gt;
&lt;div id=&quot;9442-1586702405230&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
sudo wget --no-check-certificate -O /usr/bin/bd https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;raw.githubusercontent.com/vigneshwaranr/bd/master/bd&lt;/span&gt;
sudo chmod &lt;span&gt;777&lt;/span&gt; /usr/bin/&lt;span&gt;bd
echo &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;alias bd=&quot;. bd -si&quot;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;gt;&amp;gt; ~/&lt;span&gt;.bashrc
source &lt;/span&gt;~/.bashrc
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;注意，在安装完bd命令后，需要使用chmod命令设置bd的可执行权限，否则bd默认是没有执行权限的。如果想忽略大小写，可以使用-si命令行参数，本例为bd -si起一个别名，也就是说，只要输入了bd，就相当于bd -si。修改.bashrc文件后的样式如下图所示。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202005/32818-20200528080313951-1095709251.png&quot; alt=&quot;&quot; width=&quot;959&quot; height=&quot;439&quot;/&gt;

&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/src/FFB1B431034B4639B43C3AD8DC08C083&quot; alt=&quot;&quot; data-media-type=&quot;image&quot;/&gt;&lt;/div&gt;
&lt;p&gt; 最后使用source命令执行.bashrc文件，让配置生效。&lt;/p&gt;

&lt;p&gt;现在来看一下bd命令如何用。如果只是执行bd命令，那么会一层一层往上退，相当于执行“cd ..”命令。&lt;/p&gt;

&lt;p&gt;现在假设当前的目录如下：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/root/software/person/slib/test/your
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;如果要立刻回到slib目录，只需要输入“bd slib”，bd会自动匹配到slib，并且立刻跳转到该目录。如果有多个匹配，则回到最近一个slib目录。除此之外，还可以进行头部匹配，例如，输入“bd s”，bd会匹配所有以s开头的目录，这里有2个：software和slib，根据最近匹配原则，bd会跳转到slib目录，当然，如果在slib目录下再次输入“bd s”，那么则跳转到software目录。&lt;/p&gt;



&lt;p&gt; （2）cd命令的常用技巧&lt;/p&gt;

&lt;p&gt;cd命令后面不跟任何参数，可以回到home目录，相当于cd ~。&lt;/p&gt;

&lt;p&gt;cd 后面不跟任何参数，回用户主目录，等同：cd ~。&lt;/p&gt;


&lt;p&gt;cd - 回退，返回之前目录：&lt;/p&gt;



&lt;p&gt;(3). 自定义目录跳转命令&lt;/p&gt;

&lt;p&gt;在Linux中可以使用alias命令自定义命令，为了方便调整目录，可以将经常要跳转的目录做成自定义命令。例如，要跳转到/software/nginx/conf目录，可以使用下面的命令自定义跳转命令。&lt;/p&gt;

&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
alias nc=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cd /software/nginx/conf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;然后只要执行nc，就会从任何目录跳转到/software/nginx/conf目录。为了让开机时自动起作用，可以将上面的命令加到profile文件或其他启动文件中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 终端也可以分屏&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在很多场景下需要同时执行多个命令，而且需要同时观看执行结果，这就需要同时显示多个窗口。按传统的做法就是启动多个终端，不过一不小心将终端最小化，还需要一个一个重新切换到前台，很麻烦。为了解决这个问题，可以使用一个第三方的工具，这就是terminator。&lt;/p&gt;

&lt;p&gt;如果读者使用的是centos，需要使用下面的命令安装terminator：&lt;/p&gt;

&lt;div id=&quot;1390-1590328213740&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yum install terminator
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;如果读者使用的是ubuntu，需要使用下面的命令安装terminator：&lt;/p&gt;
&lt;div id=&quot;9137-1590328217194&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
apt-&lt;span&gt;get&lt;/span&gt; install terminator
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;要注意的是，使用terminator必须安装图像接口，如果只安装了命令行接口，是无法使用terminator的，所以这里使用ubuntu演示terminator的使用。&lt;/p&gt;

&lt;p&gt;安装完terminator后，在终端中输入下面的命令就可以启动terminator ：&lt;/p&gt;

&lt;div id=&quot;5135-1590328305072&quot; data-theme=&quot;default&quot; data-language=&quot;javascript&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
terminator &amp;amp;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;启动后，在右键菜单中会有常用的功能，如水平分割屏幕，垂直分割屏幕等，如下图所示：&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202005/32818-20200528080404912-1849593113.png&quot; alt=&quot;&quot; width=&quot;878&quot; height=&quot;477&quot;/&gt;
&lt;p&gt; 分屏后的效果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/32818/202005/32818-20200528080446114-285801158.png&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;553&quot;/&gt;&lt;/p&gt;

&lt;p&gt; terminator可以分别对每一个分屏单独进行设置，如设置不同的字体尺寸等。在右键菜单中单击“配置文件首选项”菜单，会弹出如下图的设置菜单，里面有很多设置，包括快捷键等便捷操作方式。大家可以根据需要自行探索。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 3. 选一个好的Markdown编辑器，就和选一个好的伴侣一样非常重要&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经常写博客的同学肯定非常熟悉Markdown，这是一种文件格式，可以插入文本、图像、HTML等元素，非常适合编辑一般格式的文档。在Linux下挑选一款合适的Markdown编辑器尤为重要，这回对文档编辑工作起到事半功倍的效果，这里推荐使用Tpyora。读者可以使用下面的命令安装Tpyora。&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt; 
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
wget -qO - https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;typora.io/linux/public-key.asc | sudo apt-key add -&lt;/span&gt;&lt;span&gt;
sudo add&lt;/span&gt;-apt-repository &lt;span&gt;'&lt;/span&gt;&lt;span&gt;deb https://typora.io/linux ./&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt;&lt;span&gt; update
sudo apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt; install typora
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;




&lt;/div&gt;</description>
<pubDate>Thu, 28 May 2020 00:07:00 +0000</pubDate>
<dc:creator>银河使者</dc:creator>
<og:description>Linux已经成为目前最火的操作系统之一，尽管现在的Linux用户很多，但很多使用Linux的同学发现，他们在Linux下的工作效率并不高，那么这是为什么呢？其实使用Linux也可以很舒适，通过一些技</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nokiaguy/p/12978153.html</dc:identifier>
</item>
<item>
<title>在 Linux 系统中如何管理 systemd 服务 - JF Zhu</title>
<link>http://www.cnblogs.com/jfzhu/p/12978109.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jfzhu/p/12978109.html</guid>
<description>&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;在上一篇文章&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12961694.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux的运行级别与目标》&lt;/a&gt;中，我介绍过 Linux 用 systemd 来取代 init 作为系统的初始化进程。尽管这一改变引来了很多争议，但大多数发行版，包括 RedHat、Fedora、CentOS、Debian、Ubuntu、openSUSE、Arch 等等都已经做出了调整。不管是哪一个发行版本，systemd 都用标准的 systemctl 工具来进行管理，本文将对如何使用 systemctl 做出详细讲解。&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;br/&gt;           &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）查看你的系统有没有使用 systemd&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你不确定你的 Linux 版本有没有使用 systemd，可以用下面的命令来检查一下&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#systemctl --version&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200528072150501-569199809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如我的系统返回结果是 systemd 219。如果系统没有使用 systemd 的话，应该找不到 systemctl 命令。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）验证一下系统进程的层级关系&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;systemd 是系统的初始化进程，所以它应该是所有其他进程的父进程，我们用 pstree 命令来验证一下&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#pstree&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200528072157308-1168094152.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3）分析系统启动性能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查看系统启动时间可以使用 system-analyze 命令，默认是查看内核、initrd 和用户空间的启动时间。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#system-analyze&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200528072506017-573538722.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果查看每个服务的&lt;/span&gt;&lt;span&gt;启动耗时可以用 system-analyze blame&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#system-analyze blame&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200528072512975-923519399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回结果是按照耗时长短来排序的，最上面的就是耗时最长的服务。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（4）查看单元（unit）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;systemd 是通过单元来实现系统管理的。单元又分成很多种，比如服务单元（Service Unit）、挂载单元（Mount Unit）、设备单元（Device Unit）、套接字单元等（Socket Unit）。每一个单元都有相应的配置文件，主要存放在 /usr/lib/systemd/system 和 /etc/systemd/system 目录中。我们用 systemctl 命令来管理这些单元。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;查看系统中所有的单元可以用&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#systemctl list-unit-files&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200528072519900-1877820854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到里边有很多停用的单元，如果只想看正在运行的单元可以使用命令&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#systemctl list-units&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200528072531782-594823008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;（5）管理服务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前版本的 Linux 是通过 service 和 chkconfig 来管理服务。现在我们应该主要用 systemctl 来对服务进行管理。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果想查看系统当前所有的服务，包括所有状态的服务，可以用命令&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#systemctl list-unit-files --type=service&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200528072541931-1670447831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果想查看某个服务的当前状态，可以用&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#systemctl status 服务名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200528072550441-193675143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如我们想看一下当前 sshd 服务的状态，结果显示：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Loaded: loaded (/usr/lib/systemd/system/sshd.service 表示服务被加载，以及它的单元配置文件路径&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;enabled 表示该服务开机会自动启动&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;vendor preset: enabled 表示该服务在系统中默认预设就是开机自动启动&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;Active: active (running) since 三 2020-05-27 08:50:15 CST; 8h ago 表示该服务当前正在运行，以及它的运行时间&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Main PID: 1005 (sshd) 主要给出了 PID 的信息&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;如果想启动/停止/重启/重新加载某个服务，可以用&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#systemctl start/stop/restart/reload 服务名&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果想&lt;/span&gt;&lt;span&gt;查看服务是否被设为开机自动启用&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#systemctl is-enabled 服务名  &lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置服务设为开机自动启用&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;#systemctl enable 服务名     &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设置服务设开机不自动启用&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;#systemctl disable 服务名    &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;除了以上这些，systemd 还有很多其他管理功能，比如关机、重启、休眠等功能，你也可以通过编写你自己的单元文件来创建新的服务，在我之前的文章&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12961694.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux的运行等级与目标》&lt;/a&gt;中还介绍过通过目标（target）来管理系统运行级别。systemd 主要是通过 systemctl 来进行管理，它集之前的 service 和 chkconfig 工具于一体，功能非常强大，感兴趣的同学可以通过手册来再更深入地学习。&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12961694.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux的运行级别与目标》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12945358.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《软链接 vs. 硬链接》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12940175.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux 目录详解》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12928138.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《虚拟机安装 Linux 最完整攻略》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12907248.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Xshell 与 Xftp 的安装与使用》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12895692.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux，Unix，GNU 到底有什么样的渊源？》&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;



&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202005/442200-20200528072717798-1387218446.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;span&gt;- The End -&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 27 May 2020 23:28:00 +0000</pubDate>
<dc:creator>JF Zhu</dc:creator>
<og:description>在上一篇文章《Linux的运行级别与目标》中，我介绍过 Linux 用 systemd 来取代 init 作为系统的初始化进程。尽管这一改变引来了很多争议，但大多数发行版，包括 RedHat、Fedo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jfzhu/p/12978109.html</dc:identifier>
</item>
<item>
<title>阿里巴巴编码规范（Java）证明 - 编程一生</title>
<link>http://www.cnblogs.com/xiexj/p/12970031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/12970031.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;阿里云上有个阿里巴巴编码规范认证，我估算一下时间成本很低，多个认证也没什么坏处，就花了1分钱报了个名。这个认证报名后就可以下载链接下的编码规范，然后参加个考试应该就OK了。 &lt;/p&gt;
&lt;p&gt;共48页的规范实际上每读一遍都是要花一些时间的，因为每读一遍就会发现上面有些东西我不信。我需要去证明。过去证明过的因为JDK版本升级迭代有可能需要继续证明。下面是其中的一些证明过程。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;案例1&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规范原文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作需要对Iterator对象加锁。&lt;/p&gt;
&lt;p&gt;正例：&lt;/p&gt;
&lt;p&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;/p&gt;
&lt;p&gt;list.add(&quot;1&quot;);&lt;/p&gt;
&lt;p&gt;list.add(&quot;2&quot;);&lt;/p&gt;
&lt;p&gt;Iterator&amp;lt;String&amp;gt; iteraot = list.interator();&lt;/p&gt;
&lt;p&gt;while(iterator.hasNext()){&lt;/p&gt;
&lt;p&gt;    String item = iterator.next();&lt;/p&gt;
&lt;p&gt;    if(删除元素的条件) {&lt;/p&gt;
&lt;p&gt;          iterator.remove();&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;反例：&lt;/p&gt;
&lt;p&gt;for(String item : list) {&lt;/p&gt;
&lt;p&gt;      if(&quot;1&quot;.equals(item)) {&lt;/p&gt;
&lt;p&gt;             list.remove(item);&lt;/p&gt;
&lt;p&gt;      }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把&quot;1&quot;换成&quot;2&quot;，会是同样的结果吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.先按照反例例文运行测试（test1）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005423206-372237513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;list里两个元素，remove掉一个，剩下1个。这应该是符合大多数人预期的。&lt;/p&gt;
&lt;p&gt;2.按照说明把&quot;1&quot;换成&quot;2&quot;运行测试（test2）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005442337-1622596988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里没有按照预期remove掉&quot;2&quot;，而是抛出了并发修改异常。点击到异常的地方&lt;/p&gt;
&lt;p&gt;3.根据异常提示。找到抛出异常代码的地方查看是哪个方法抛出异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005534886-596043570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.对源码做一个解析：&lt;/p&gt;
&lt;p&gt;抛出并发修改异常的条件是modCount!=expectedModCount。&lt;/p&gt;
&lt;p&gt;5.根据这个条件，我做一个推测：在一个操作里把这两者的值改的不一样了，因为这里调用了remove修改方法。我自然就推测是remove方法做的修改，来看remove方法的源码：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.4928909952606635&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9PvFLCDMkYzxhaHZNq6tPpibGRAodVquab28pg4Y8cdnLYYjiaLaRlic17ttD1wx8Pkvkj7ia0oyQdgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005617848-661894801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.果然，源码中将modCount++，但是expectedModCount并没有修改。证明了推测。运行完remove后需要判断for(String item : list) ，这时候调用了迭代器的next方法。这样我理解了上面test2里为什么会抛出异常。那么再来思考下test1为什么不抛出异常呢？&lt;/p&gt;
&lt;p&gt;7.我们来debug一下test1的情况1&lt;/p&gt;
&lt;p&gt;运行完remove方法后，可看到这时候modCount!=expectedModCount，但是这时候只执行了hasNext()，判断了cursor != size，这时候不会执行next方法，所以不会产生异常。而下面再用到list时迭代器是新的迭代器，会把modCount=expectedModCount；&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.2202970297029703&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9PvFLCDMkYzxhaHZNq6tPpuBiayb1zWul3v9fibxx6v40UKIENMw4xU31tS2zzNAmUmZ4aHWOeWnwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005645327-1179469962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果list在for循环里调用remove方法是会抛出并发修改异常的，但是如果只修改了第1个就返回的情况是个例外，因为这时候不会调用next方法判断modCount和expectedModCount是否相等。&lt;/p&gt;
&lt;p&gt;使用代码规范推荐的迭代器，底层remove方法会将modCount和expectedModCount一起修改，所以单线程不会有并发问题，作为类的成员变量，多线程情况下被修改就不确定了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面代码的执行结果是多少？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005706176-1857543352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例2&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规范原文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【强制】在JDK7版本及以上，Comparotor实现类要满足如下三个条件，不然Arrays.sort、Collections.sort会抛IllegalArgumentException异常。&lt;/p&gt;
&lt;p&gt;说明：三个条件如下&lt;/p&gt;
&lt;p&gt;1)x、y的比较结果和y、x的比较结果相反。&lt;/p&gt;
&lt;p&gt;2)x&amp;gt;y, y&amp;gt;z，则x&amp;gt;z。&lt;/p&gt;
&lt;p&gt;3)x=y，则x,z比较结果和y,z比较结果相同。&lt;/p&gt;
&lt;p&gt;反例：下例中没有处理相等的情况，交换两个对象判断结果并不互反，不符合第一个条件，在实际使用中可能会出现异常。&lt;/p&gt;
&lt;p&gt;new Comparotor&amp;lt;Student&amp;gt;() {&lt;/p&gt;
&lt;p&gt;    @Override&lt;/p&gt;
&lt;p&gt;    public int compare(Student o1, Student o2) {&lt;/p&gt;
&lt;p&gt;           return o1.getId()&amp;gt;o2.getId()?1:-1;&lt;/p&gt;
&lt;p&gt;    }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.我们先来看看反例在实际使用中会抛出什么异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005740110-936768277.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005815745-617402803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.测试发现不论是Collections.sort还是Arrays.sort都抛出错误说必须实现Comparable接口而不是Comparator接口。而Comparable接口是不需要满足规范里所说的自反性、传递性和对称性的。&lt;/p&gt;
&lt;p&gt;那为什么规范里会这么说呢？&lt;/p&gt;
&lt;p&gt;3.我查了Collections类的源码，确实有几个方法用到了Comparator类。包括反转、二分查找、最大值、最小值和几个sort等。后面的原来sort是可以后面接Comparator参数的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005919062-1625431069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 然而我用源码的两个参数形式传入后，运行了几个例子并没有抛出非法参数异常。于是我又在源码中找线索。&lt;/p&gt;
&lt;p&gt;Collections.sort底层用了Arrays.sort，Arrays.sort底层用了TimSort，TimSort有两处会抛出这个异常，看源码是在二分查找merge结果的时候。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.34210526315789475&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9PvFLCDMkYzxhaHZNq6tPpVYjFY8tamJcD5CvRsB0nMmdzITn2SMlGTE7wEiaF9cqoXG45VxKLG9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527005949674-2102412337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.使用这个sort果然是发生了非法参数异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010039956-1749583504.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.具体为什么会发生异常，我打了断点，使用debug跟了一下TimSort源码，大体是有部分排序使用了if(x&amp;lt;y) else 判断，又一些方法里使用了if(x&amp;lt;=y)来判断。这两个结果对于等于的情况是冲突的。这时候会发生异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现Comparator的compare方法要满足自反性、对称性、传递性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例3&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规范原文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010146401-1271654041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.4730617608409987&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicw3TMmJ8GibpXxiapQCbDH12TXfDXANdtloDqjbWgS718NE2uBoCTk5Ly1k2CicEKu1LC92xDW9icWfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1522&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.从上面总结来看线程安全的Map的key和value都不能为null。线程不安全的可以为null。大家都知道map的key要进行hash。对null进行hash不会空指针吗？&lt;/p&gt;
&lt;p&gt;带着这个疑问，打开HashMap的源码看到hash方法有对null做判断，如果null则hash值为0。所以不会NPE&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages img_loading&quot; src=&quot;data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==&quot; alt=&quot;&quot; data-ratio=&quot;0.41687979539641945&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicw3TMmJ8GibpXxiapQCbDH12C7RNmnCiciap6Ok9rQe6rOgZMxXlnYYtVpI2qW5MdS6mMu2hDyunDPIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1564&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010213441-1982694639.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.TreeMap的put方法没有对key做任何的判断，然后会调用compare方法，这里会抛出NPE&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010244706-156614850.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.那么对于key如果不做特殊处理，肯定是要抛出NPE的，应该没有什么疑问了。为什么有的value为空也会NPE呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010307985-1155960039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面源码可知道ConcurrentHashMap就是这么处理的，算是强制。&lt;/p&gt;

&lt;p&gt;4.而Hashtable也是强制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010330407-1769045939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5.为什么线程安全的容器要设计成key和value不能为null呢?在网上找到了类设计者Lea的原话，主要表达的意思是因为map需要实现containsKey和containsValue方法。这个方法对于null的情况实际上是用get(XX)来实现的，如果为null就不好区分到底是因为不存在还是值就是null。&lt;/p&gt;
&lt;p&gt;6.而线程不安全的就是按单线程处理，下面是TreeMap里containsValue的处理，如果为输入为null，并且有个对象值为null就是true了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;四种常用map中线程安全的Map的key和value都不能为null。线程不安全的value都可以为null。TreeMap的key不能为null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例4&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规范原文&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获 抛出的异常，其它任务便会自动终止运行，如果在处理定时任务时使用ScheduledExecutorService 则没有这个问题。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.先让Timer 运行多个 TimeTask，让其中之一没有捕获 抛出的异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010507625-438691878.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这段代码的意思是在10秒内运行两个定时任务，其中一个定时任何每10ms做前后打印。另外一个抛出异常，结果抛出异常后两个都停止了。&lt;/p&gt;
&lt;p&gt;2.从Timer源代码可知，本质上多个任务通过一个队列来维护。处理的时候整个过程整体try catch。那么一个出异常整个过程都停止了。&lt;/p&gt;
&lt;p&gt;3.再验证使用ScheduledExecutorService的情况， 可看到抛出异常的线程运行了一次之后就停止了，另外一个线程一直继续运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010538617-950037663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4. 从源码可知如果一个工作线程出现了问题会直接从工作队列里移除，不影响其他的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010604856-54803163.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ScheduledExecutorService相比Timer能避免多个任务之间的出现问题时的副作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例5&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;规范原文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方 法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。说明:asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适 配器模式，只是转换接口，后台的数据仍是数组。&lt;/p&gt;
&lt;p&gt;String[] str = new String[] { &quot;yang&quot;, &quot;hao&quot; };&lt;/p&gt;
&lt;p&gt;List list = Arrays.asList(str);第一种情况:list.add(&quot;yangguanbao&quot;); 运行时异常。第二种情况:str[0] = &quot;changed&quot;; 也会随之修改，反之亦然。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.Arrays.asList()把数组转换成集合后添加元素，测试运行，果然抛出异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010659493-1868465420.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟踪源码可知道虽然asList生成的是ArrayList，但它并不是java.util.ArrayList，而是Arrays里自定义的。这个类不支持这些更新操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010721697-339161057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小心集合类中返回一个子集或者转换类型的操作，可能返回的是内部定义的类，不是我们平时用的类，这些类中对一些操作做了限制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面测试类体现了规范的哪一条？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200527010741049-825517578.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
</description>
<pubDate>Wed, 27 May 2020 21:32:00 +0000</pubDate>
<dc:creator>编程一生</dc:creator>
<og:description>背景 阿里云上有个阿里巴巴编码规范认证，我估算一下时间成本很低，多个认证也没什么坏处，就花了1分钱报了个名。这个认证报名后就可以下载链接下的编码规范，然后参加个考试应该就OK了。 共48页的规范实际上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiexj/p/12970031.html</dc:identifier>
</item>
<item>
<title>DQN（Deep Q-learning）入门教程（三）之蒙特卡罗法算法与Q-learning算法 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12977830.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12977830.html</guid>
<description>&lt;h2 id=&quot;蒙特卡罗法&quot;&gt;蒙特卡罗法&lt;/h2&gt;
&lt;p&gt;在介绍Q-learing算法之前，我们还是对蒙特卡罗法（MC）进行一些介绍。MC方法是一种无模型（model-free）的强化学习方法，目标是得到最优的行为价值函数&lt;span class=&quot;math inline&quot;&gt;\(q_*\)&lt;/span&gt;。在前面一篇&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12973303.html&quot;&gt;博客&lt;/a&gt;中，我们所介绍的动态规划算法则是一种有模型的算法。那么问题来了，什么是模型（model）？模型其实就是我们在第一篇博客：&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12945449.html&quot;&gt;DQN（Deep Q-learning）入门教程（一）之强化学习介绍&lt;/a&gt;种所介绍的状态转化模型： &lt;span class=&quot;math inline&quot;&gt;\(P_{ss'}^a\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在动态规划解决问题的时候，我们是已知&lt;span class=&quot;math inline&quot;&gt;\(P_{ss'}^a\)&lt;/span&gt;，但是实际上我们也可能对于&lt;span class=&quot;math inline&quot;&gt;\(P_{ss'}^a\)&lt;/span&gt;我们是未知的。那么怎么办呢？此时，我们使用经验平均来解决这个问题。其中的思想有点类似大数定理，尽管我不知道模型概率是什么，但是我可以使用无数次的实验来逼近这个概率。&lt;/p&gt;
&lt;p&gt;任然是分为两个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;策略评估&lt;/li&gt;
&lt;li&gt;策略控制
&lt;ul&gt;&lt;li&gt;探索性&lt;/li&gt;
&lt;li&gt;无探索性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;策略评估&quot;&gt;策略评估&lt;/h3&gt;
&lt;p&gt;前面我们说了，我们使用多次实验来解决model-free，因此我们将历史实验数据称之为&lt;strong&gt;经验&lt;/strong&gt;，然后进行&lt;strong&gt;平均&lt;/strong&gt;求得的价值函数当成价值函数当作结果。&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;经验：我们使用策略做很多次实验，每次实验都是从最初状态到终止状态。假如一次实验所得得到的数据如下：&lt;span class=&quot;math inline&quot;&gt;\(S_1,A_1,R_2,S_2,A_2,...S_t,A_t,R_{t+1},...R_T, S_T\)&lt;/span&gt;，则在状态&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;处获得的回报是：&lt;span class=&quot;math inline&quot;&gt;\(G_{t}(s)=R_{t+1}+\gamma R_{t+2}+\cdots+\gamma^{T-1} R_{T}\)&lt;/span&gt;。而我们就可以进行多次实验，就可以得到多份数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;平均：平均有两种方式，&lt;strong&gt;第一次访问蒙特卡罗&lt;/strong&gt;方法和&lt;strong&gt;每次访问蒙特卡罗&lt;/strong&gt;方法。假如我们做实验的到的数据如下，现在需要来计算&lt;span class=&quot;math inline&quot;&gt;\(G(s)\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200528023549551-371860578.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;第一次访问蒙特卡罗方法：只是使用&lt;strong&gt;每次实验&lt;/strong&gt;第一次出现状态&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;的放回值。比如说上图中&lt;span class=&quot;math inline&quot;&gt;\(G_{11},G_{21}\)&lt;/span&gt;，但是&lt;strong&gt;不使用&lt;/strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(G_{12}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;\[\begin{equation}v(s)=\frac{G_{11}(s)+G_{21}(s)+\cdots}{N(s)}\end{equation} \\ N(s)代表出现的次数 \]&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;每次访问蒙特卡罗方法：则就是只要出现过，就使用，比如说上图中的&lt;span class=&quot;math inline&quot;&gt;\(G_{11},G_{12},G_{21}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;\[\begin{equation}v(s)=\frac{G_{11}(s)+G_{12}(s)+\cdots+G_{21}(s)+\cdots}{N(s)}\end{equation} \]&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不过我们可以想一想，这样计算平均值会有什么问题？浪费内存空间，因为我们需要储存该状态&lt;strong&gt;所有历史实验数据&lt;/strong&gt;然后再取平均。因此我们对取平均值的方法进行改进，改进的原理如下：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\mu_{k}=\frac{1}{k} \sum_{j=1}^{k} x_{j}=\frac{1}{k}\left(x_{k}+\sum_{j=1}^{k-1} x_{j}\right)=\frac{1}{k}\left(x_{k}+(k-1) \mu_{k-1}\right)=\mu_{k-1}+\frac{1}{k}\left(x_{k}-\mu_{k-1}\right)\end{equation} \]&lt;/p&gt;
&lt;p&gt;也就是说，状态价值公式可以改写为：&lt;/p&gt;
&lt;p&gt;\[\begin{equation}\begin{array}{c} N\left(s\right)=N\left(s\right)+1 \\ V_{k+1}\left(s\right)=V_{k}\left(S\right)+\frac{1}{N\left(S\right)}\left(G_{t}-V_{k}\left(S\right)\right) \end{array}\end{equation} \]&lt;/p&gt;
&lt;p&gt;这样我们存储上一步的状态价值函数就🆗了。若&lt;span class=&quot;math inline&quot;&gt;\(N(s)\)&lt;/span&gt;越大，则&lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{N(s)}\)&lt;/span&gt;越小，则新样本对总体均值的影响小，反之亦然。实际上，我们也可以使用一个学习率&lt;span class=&quot;math inline&quot;&gt;\(\alpha\)&lt;/span&gt;代替&lt;span class=&quot;math inline&quot;&gt;\(V\left(s\right)=V\left(S\right)+\alpha\left(G_{t}-V\left(S\right)\right)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3 id=&quot;探索性初始化mc控制&quot;&gt;探索性初始化MC控制&lt;/h3&gt;
&lt;p&gt;探索性初始是指&lt;strong&gt;每个状态&lt;/strong&gt;都有一定几率作为初始状态。因此这里有一个前提就是对于所有的状态我们都是已知的，这样我们才能够从状态集中随机的选取&lt;span class=&quot;math inline&quot;&gt;\(s \in \mathcal{S}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;算法的流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200528023550078-563183158.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;无探索性初始化mc控制&quot;&gt;无探索性初始化MC控制&lt;/h3&gt;
&lt;p&gt;ES的方法有一点问题，因为有时候agent是不可能在任意状态开始的，比如说你玩电游，初始状态是确定的，只有一个或者几个，ES方法是一个不现实的假设，同时我们也不知道所有的状态集&lt;span class=&quot;math inline&quot;&gt;\(\mathcal{S}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;无探索性初始是指初始状态是固定的，然后我们在里面加入探索率 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; （随着试验次数的增加而逐渐减小）来对&lt;span class=&quot;math inline&quot;&gt;\(action\)&lt;/span&gt;选择：使用&lt;span class=&quot;math inline&quot;&gt;\(1 - \epsilon\)&lt;/span&gt;的概率贪婪地选择目前认为是最大行为价值的行为，而使用 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;的概率随机的从所有&lt;span class=&quot;math inline&quot;&gt;\(m\)&lt;/span&gt; 个可选的行为中随机选择行为。该方法称之为&lt;span class=&quot;math inline&quot;&gt;\(\epsilon-greedy\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用公式可以表示为：&lt;/p&gt;
&lt;p&gt;\[\pi(a|s)= \begin{cases} \epsilon/m + 1- \epsilon &amp;amp; {if\; a_{*} = \arg\max_{a \in A}Q(s,a)}\\ \epsilon/m &amp;amp; {else} \end{cases} \]&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200528023550732-1904036.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而方法又可以分为两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;On-Policy：直接对我们的策略进行估值和改进&lt;/li&gt;
&lt;li&gt;Off-Policy：结合一个其他的策略，来对我们的决策策略进行估值和改进。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;On-Policy的算法如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;38&quot;&gt;
&lt;p&gt;输入：状态集 &lt;span class=&quot;math inline&quot;&gt;\(S,\)&lt;/span&gt; 动作集 &lt;span class=&quot;math inline&quot;&gt;\(A,\)&lt;/span&gt; 即时奖励 &lt;span class=&quot;math inline&quot;&gt;\(R,\)&lt;/span&gt; 哀減因子 &lt;span class=&quot;math inline&quot;&gt;\(\gamma,\)&lt;/span&gt; 探索率 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;&lt;br/&gt;输出：最优的动作价值函数 &lt;span class=&quot;math inline&quot;&gt;\(q_{*}\)&lt;/span&gt; 和最优策略 &lt;span class=&quot;math inline&quot;&gt;\(\pi_{*}\)&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;初始化所有的动作价值Q &lt;span class=&quot;math inline&quot;&gt;\((s, a)=0,\)&lt;/span&gt; 状态次数 &lt;span class=&quot;math inline&quot;&gt;\(N(s, a)=0,\)&lt;/span&gt; 采样次数 &lt;span class=&quot;math inline&quot;&gt;\(k=0,\)&lt;/span&gt; 随机初始化一个策略 &lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(k=k+1\)&lt;/span&gt;, 基于策略 &lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt; 进行第k次蒙特卡罗采样，得到一个完整的状态序列：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[S_{1}, A_{1}, R_{2}, S_{2}, A_{2}, \ldots S_{t}, A_{t}, R_{t+1}, \ldots R_{T}, S_{T} \]&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;对于该状态序列里出现的每一状态行为对 &lt;span class=&quot;math inline&quot;&gt;\(\left(S_{t}, A_{t}\right),\)&lt;/span&gt; 计算其收获 &lt;span class=&quot;math inline&quot;&gt;\(G_{t},\)&lt;/span&gt; 更新其计数 &lt;span class=&quot;math inline&quot;&gt;\(N(s, a)\)&lt;/span&gt; 和行为价值函数 &lt;span class=&quot;math inline&quot;&gt;\(Q(s, a)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[\begin{array}{c} G_{t}=R_{t+1}+\gamma R_{t+2}+\gamma^{2} R_{t+3}+\ldots \gamma^{T-t-1} R_{T} \\ N\left(S_{t}, A_{t}\right)=N\left(S_{t}, A_{t}\right)+1 \\ Q\left(S_{t}, A_{t}\right)=Q\left(S_{t}, A_{t}\right)+\frac{1}{N\left(S_{t}, A_{t}\right)}\left(G_{t}-Q\left(S_{t}, A_{t}\right)\right) \end{array} \]&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;基于新计算出的动作价值, 更新当前的 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon-贪婪\)&lt;/span&gt;策略:&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;\[\epsilon=\frac{1}{k} \]&lt;/p&gt;
&lt;p&gt;\[\pi(a | s)=\left\{\begin{array}{ll} \epsilon / m+1-\epsilon &amp;amp; \text { if } a^{*}=\arg \max _{a \in A} Q(s, a) \\ \epsilon / m &amp;amp; \text { else } \end{array}\right. \]&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;如果所有的Q &lt;span class=&quot;math inline&quot;&gt;\((s, a)\)&lt;/span&gt; 收敛, 则对应的所有 &lt;span class=&quot;math inline&quot;&gt;\(Q(s, a)\)&lt;/span&gt; 即为最优的动作价值函数 &lt;span class=&quot;math inline&quot;&gt;\(q_{* \circ}\)&lt;/span&gt; 对应的策略 &lt;span class=&quot;math inline&quot;&gt;\(\pi(a | s)\)&lt;/span&gt; 即为最优策略 &lt;span class=&quot;math inline&quot;&gt;\(\pi_{* \circ}\)&lt;/span&gt; 否则转到第二步。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;Off-Policy的介绍可以看&lt;a href=&quot;https://people.cs.umass.edu/~barto/courses/cs687/Chapter%205.pdf&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;蒙特卡罗方法解决了状态转移模型&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;未知的问题，但是其有一个特点，算法需要一个完整的&lt;span class=&quot;math inline&quot;&gt;\(episode\)&lt;/span&gt;才能够进行策略更新。&lt;/p&gt;
&lt;h2 id=&quot;q-learning简介&quot;&gt;Q-learning简介&lt;/h2&gt;
&lt;p&gt;下面是维基百科上面关于Q-learning的介绍。&lt;/p&gt;
&lt;blockquote readability=&quot;9.0123456790123&quot;&gt;
&lt;p&gt;&lt;strong&gt;Q-learning&lt;/strong&gt; is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Model-free_(reinforcement_learning)&quot;&gt;model-free&lt;/a&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Reinforcement_learning&quot;&gt;reinforcement learning&lt;/a&gt; algorithm to learn a policy telling an agent what action to take under what circumstances. It does not require a model (hence the connotation &quot;model-free&quot;) of the environment, and it can handle problems with stochastic transitions and rewards, without requiring adaptations.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Q-learning和MC方法都是model-free的方法。与MC方法类似的是，它两都是使用价值迭代来更新价值函数，最后更新策略。不过与MC方法不同的是：MC方法需要完整的&lt;span class=&quot;math inline&quot;&gt;\(episode\)&lt;/span&gt;才能进行更新，而Q-learning则不需要。&lt;/p&gt;
&lt;h3 id=&quot;q说明&quot;&gt;Q说明&lt;/h3&gt;
&lt;p&gt;首先先说一下Q-learning 中的Q，Q代表这动作价值函数&lt;span class=&quot;math inline&quot;&gt;\(q(a,s)\)&lt;/span&gt;，Q的更新公式如下：&lt;/p&gt;
&lt;p&gt;\[{\displaystyle Q^{new}(s_{t},a_{t})\leftarrow \underbrace {Q(s_{t},a_{t})} _{\text{旧的值}}+\underbrace {\alpha } _{\text{学习率}}\cdot \overbrace {{\bigg (}\underbrace {\underbrace {r_{t}} _{\text{奖励}}+\underbrace {\gamma } _{\text{奖励衰减因子}}\cdot \underbrace {\max _{a}Q(s_{t+1},a)} _{\text{estimate of optimal future value}}} _{\text{new value (temporal difference target)}}-\underbrace {Q(s_{t},a_{t})} _{\text{旧的值}}{\bigg )}} ^{\text{temporal difference}}} \]&lt;/p&gt;
&lt;p&gt;这里借助&lt;a href=&quot;https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/2-1-A-q-learning/&quot;&gt;莫烦教程&lt;/a&gt;里面的一些图来进行说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Q现实：表示我们执行Action得到的动作价值&lt;/li&gt;
&lt;li&gt;Q估计：表示这个值是由我们进行迭代估计的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202005/1439869-20200528023551127-311737401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;算法步骤&quot;&gt;算法步骤&lt;/h3&gt;
&lt;p&gt;算法的步骤如下：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;算法输入：迭代轮数T，状态集S, 动作集 &lt;span class=&quot;math inline&quot;&gt;\(A,\)&lt;/span&gt; 步长 &lt;span class=&quot;math inline&quot;&gt;\(\alpha,\)&lt;/span&gt; 哀減因子 &lt;span class=&quot;math inline&quot;&gt;\(\gamma,\)&lt;/span&gt; 探索率 &lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;&lt;br/&gt;输出：所有的状态和动作对应的价值 &lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;随机初始化所有的状态和动作对应的价值Q，对于终止状态其Q值初始化为0.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;for i in range(0,T), 进行迭代：&lt;br/&gt;a) 初始化S为当前状态序列的第一个状态。&lt;br/&gt;b) 用&lt;span class=&quot;math inline&quot;&gt;\(\epsilon-贪婪法\)&lt;/span&gt;在当前状态&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;选择出动作 &lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;&lt;br/&gt;c) 在状态&lt;span class=&quot;math inline&quot;&gt;\(S\)&lt;/span&gt;执行当前动作 &lt;span class=&quot;math inline&quot;&gt;\(A,\)&lt;/span&gt; 得到新状态 &lt;span class=&quot;math inline&quot;&gt;\(S^{\prime}\)&lt;/span&gt; 和奖励 &lt;span class=&quot;math inline&quot;&gt;\(R\)&lt;/span&gt;&lt;br/&gt;d) 更新价值函数:&lt;span class=&quot;math inline&quot;&gt;\(Q(S, A)+\alpha\left(R+\gamma \max _{a} Q\left(S^{\prime}, a\right)-Q(S, A)\right)\)&lt;/span&gt;&lt;br/&gt;e) &lt;span class=&quot;math inline&quot;&gt;\(S=S^{\prime}\)&lt;/span&gt;&lt;br/&gt;f) 如果S'是终止状态, 当前轮迭代完毕，否则转到步骤b&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇博客主要是介绍了无模型下的问题求解方式：蒙特卡罗法和Q-learning法。在下篇博客中，将使用q-learning算法具体进行实践。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
</description>
<pubDate>Wed, 27 May 2020 18:37:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>蒙特卡罗法 在介绍Q-learing算法之前，我们还是对蒙特卡罗法（MC）进行一些介绍。MC方法是一种无模型（model-free）的强化学习方法，目标是得到最优的行为价值函数$q_*$。在前面一篇博</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12977830.html</dc:identifier>
</item>
<item>
<title>.NET Core 反射获取所有控制器及方法上特定标签 - 、天上有木月OvO</title>
<link>http://www.cnblogs.com/igeekfan/p/12977793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/igeekfan/p/12977793.html</guid>
<description>&lt;h2 id=&quot;net-core-反射获取所有控制器及方法上特定标签&quot;&gt;.NET Core 反射获取所有控制器及方法上特定标签&lt;/h2&gt;
&lt;p&gt;有个需求，就是在. NET Core中，我们想在项目 启动时，获取LinCmsAuthorizeAttribute这个特性标签所有出现的地方，把他的参数，放入一个集合并缓存起来，以便后面使用此数据用于权限验证。&lt;/p&gt;
&lt;p&gt;我们通过反射获取所有控制器下及方法的Attribute。&lt;/p&gt;
&lt;h2 id=&quot;lincmsauthorizeattribute是什么&quot;&gt;LinCmsAuthorizeAttribute是什么&lt;/h2&gt;
&lt;p&gt;其代码非常简单，用于自定义权限验证，通过重写OnAuthorizationAsync方法，实现固定权限可分配给动态角色（也能分配给动态用户）。主要就&lt;strong&gt;基于权限的授权&lt;/strong&gt;的实现进行研究，实现方法级别的权限验证。&lt;/p&gt;
&lt;p&gt;当然，这个只是部分代码，完整代码请查看最下方开源地址，其中LinCmsAuthorizeAttribute继承AuthorizeAttribute，拥有指定角色权限控制，当Permission未指定时，当过滤器与Authorize功能相同。Module是指模块，即多个权限，属于同一个模块，方便前台展示为树型结构。Permission属性的值不可重复。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = true)]
public class LinCmsAuthorizeAttribute : AuthorizeAttribute, IAsyncAuthorizationFilter
{
    public string Permission { get; set; }
    public string Module { get; set; }

    public LinCmsAuthorizeAttribute()
    {

    }

    public LinCmsAuthorizeAttribute(string permission,string module)
    {
        Permission = permission;
        Module = module;
    }

    public LinCmsAuthorizeAttribute(string permission,string module, string policy) : base(policy)
    {
        Permission = permission;
        Module = module;
    }

    public async Task OnAuthorizationAsync(AuthorizationFilterContext context)
    {
        if (Permission == null) return;
        var authorizationService = (IAuthorizationService)context.HttpContext.RequestServices.GetService(typeof(IAuthorizationService));
        var authorizationResult = await authorizationService.AuthorizeAsync(context.HttpContext.User, null, new OperationAuthorizationRequirement() { Name = Permission });
        if (!authorizationResult.Succeeded)
        {
            context.Result = new ForbidResult();
        }
    }

    public override string ToString()
    {
        return $&quot;\&quot;{base.ToString()}\&quot;,\&quot;Permission:{Permission}\&quot;,\&quot;Module:{Module}\&quot;,\&quot;Roles:{Roles}\&quot;,\&quot;Policy:{Policy}\&quot;,\&quot;AuthenticationSchemes:{AuthenticationSchemes}\&quot;&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;controller&quot;&gt;Controller&lt;/h2&gt;
&lt;p&gt;在 LinCms.Web中的Controller，至于为什么Permission为中文，目前的主要原因，此项目用于适配 &lt;a href=&quot;https://github.com/TaleLin/lin-cms-vue&quot;&gt;Lin-CMS-VUE&lt;/a&gt;项目,所以于平常我们以某个字符串作为权限名不同，但不须大精小怪，道理相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Route(&quot;cms/log&quot;)]
[ApiController]
public class LogController : ControllerBase
{
    private readonly ILogService _logService;

    public LogController(ILogService logService)
    {
        _logService = logService;
    }

    [HttpGet(&quot;users&quot;)]
    [LinCmsAuthorize(&quot;查询日志记录的用户&quot;, &quot;日志&quot;)]
    public List&amp;lt;string&amp;gt; GetLoggedUsers([FromQuery]PageDto pageDto)
    {
        return _logService.GetLoggedUsers(pageDto);
    }

 
    [HttpGet]
    [LinCmsAuthorize(&quot;查询所有日志&quot;, &quot;日志&quot;)]
    public PagedResultDto&amp;lt;LinLog&amp;gt; GetLogs([FromQuery]LogSearchDto searchDto)
    {
        return _logService.GetLogUsers(searchDto);
    }

    [HttpGet(&quot;search&quot;)]
    [LinCmsAuthorize(&quot;搜索日志&quot;, &quot;日志&quot;)]
    public PagedResultDto&amp;lt;LinLog&amp;gt; SearchLogs([FromQuery]LogSearchDto searchDto)
    {
        return _logService.GetLogUsers(searchDto);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试类获取方法上的特定标签&quot;&gt;测试类获取方法上的特定标签&lt;/h2&gt;
&lt;p&gt;in xunit test 项目工程中，开始我们的测试&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Fact]
public void GetAssemblyMethodsAttributes()
{
    var assembly = typeof(Startup).Assembly.GetTypes().AsEnumerable()
        .Where(type =&amp;gt; typeof(ControllerBase).IsAssignableFrom(type)).ToList();

    assembly.ForEach(r =&amp;gt;
    {
        foreach (var methodInfo in r.GetMethods())
        {
            foreach (Attribute attribute in methodInfo.GetCustomAttributes())
            {
                if (attribute is LinCmsAuthorizeAttribute linCmsAuthorize)
                {
                    _testOutputHelper.WriteLine(linCmsAuthorize.ToString());
                }
            }
        }
    });
}    
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;方法结果&quot;&gt;方法结果&lt;/h2&gt;
&lt;p&gt;可在输出文本中查看，正是我们想要的东西，最后一行，是其他Controller中的内容，而且我们重写了ToString(),所以我们能看到其属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;LinCms.Zero.Authorization.LinCmsAuthorizeAttribute&quot;,&quot;Permission:查询日志记录的用户&quot;,&quot;Module:日志&quot;,&quot;Roles:&quot;,&quot;Policy:&quot;,&quot;AuthenticationSchemes:&quot;
&quot;LinCms.Zero.Authorization.LinCmsAuthorizeAttribute&quot;,&quot;Permission:查询所有日志&quot;,&quot;Module:日志&quot;,&quot;Roles:&quot;,&quot;Policy:&quot;,&quot;AuthenticationSchemes:&quot;
&quot;LinCms.Zero.Authorization.LinCmsAuthorizeAttribute&quot;,&quot;Permission:搜索日志&quot;,&quot;Module:日志&quot;,&quot;Roles:&quot;,&quot;Policy:&quot;,&quot;AuthenticationSchemes:&quot;
&quot;LinCms.Zero.Authorization.LinCmsAuthorizeAttribute&quot;,&quot;Permission:查看lin的信息&quot;,&quot;Module:信息&quot;,&quot;Roles:&quot;,&quot;Policy:&quot;,&quot;AuthenticationSchemes:&quot;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;获取控制器上特性标签&quot;&gt;获取控制器上特性标签&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 获取控制器上的LinCmsAuthorizeAttribute
/// &amp;lt;/summary&amp;gt;
/// &quot;LinCms.Zero.Authorization.LinCmsAuthorizeAttribute&quot;,&quot;Permission:&quot;,&quot;Module:&quot;,&quot;Roles:Administrator&quot;,&quot;Policy:&quot;,&quot;AuthenticationSchemes:&quot;
[Fact]
public void GetControllerAttributes()
{
    var assembly = typeof(Startup).Assembly.GetTypes().AsEnumerable()
        .Where(type =&amp;gt; typeof(ControllerBase).IsAssignableFrom(type)).ToList();

    assembly.ForEach(d =&amp;gt;
    {
        var linCmsAuthorize = d.GetCustomAttribute&amp;lt;LinCmsAuthorizeAttribute&amp;gt;();
        if (linCmsAuthorize != null)
        {
            _testOutputHelper.WriteLine(linCmsAuthorize.ToString());
        }
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;controller结果&quot;&gt;Controller结果&lt;/h2&gt;
&lt;p&gt;只有AdminController加了此标签，所以只有一行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;LinCms.Zero.Authorization.LinCmsAuthorizeAttribute&quot;,&quot;Permission:&quot;,&quot;Module:&quot;,&quot;Roles:Administrator&quot;,&quot;Policy:&quot;,&quot;AuthenticationSchemes:&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时Roles为Administrator，Permission及Module都是null，&lt;br/&gt;这是因为只有AdminController中加了LinGroup.Administrator=&quot;Administrator&quot;字符串，在登录过程中，已经给当前登录用户设置了 new Claim(ClaimTypes.Role,user.IsAdmin()?LinGroup.Administrator:user.GroupId.ToString())，即&quot;Administrator,当用户访问AdminController中的方法时，LinCmsAuthorize并没有做相关验证，都是AuthorizeAttribute，实现了固定角色权限的判断及登录的判断。LinCmsAuthorize完成了固定权限设置为不同的动态角色后，判断用户是否拥有此权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[LinCmsAuthorize(Roles = LinGroup.Administrator)]
public class AdminController : ControllerBase
{
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;h2 id=&quot;开源地址&quot;&gt;开源地址&lt;/h2&gt;
</description>
<pubDate>Wed, 27 May 2020 17:29:00 +0000</pubDate>
<dc:creator>、天上有木月OvO</dc:creator>
<og:description>.NET Core 反射获取所有控制器及方法上特定标签 有个需求，就是在. NET Core中，我们想在项目 启动时，获取LinCmsAuthorizeAttribute这个特性标签所有出现的地方，把</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/igeekfan/p/12977793.html</dc:identifier>
</item>
<item>
<title>G1 垃圾回收器简单调优 - WindWant</title>
<link>http://www.cnblogs.com/niejunlei/p/12969622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niejunlei/p/12969622.html</guid>
<description>&lt;p&gt;G1: Garbage First 低延迟、服务侧分代垃圾回收器。&lt;/p&gt;
&lt;p&gt;详细介绍参见：&lt;a href=&quot;https://www.cnblogs.com/niejunlei/p/5989814.html&quot; target=&quot;_blank&quot;&gt;JVM之G1收集器&lt;/a&gt;，这里不再赘述。&lt;/p&gt;
&lt;p&gt;关于调优目标：延迟、吞吐量&lt;/p&gt;
&lt;h3&gt;一、延迟，单次的延迟&lt;/h3&gt;
&lt;p&gt;单次的延迟关系到服务的响应时延，比如，在要求接口响应不超过100ms的服务里，单次的延迟目标必然不能超过100ms。&lt;/p&gt;
&lt;p&gt;服务的响应时间目标，不应该是指100%时间的服务响应。服务不可能是100%可用的，通常，我们对于服务的响应延迟目标也不是100%可用时间内的。&lt;/p&gt;
&lt;p&gt;实际应用中，我们可能会以99.9%时间内，延迟不超过100ms为目标。&lt;/p&gt;
&lt;p&gt;对于G1，会有一些默认设置，以使应用者在不做任何调整的情况下，依然能高效的运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-XX:MaxGCPauseMillis&lt;/strong&gt;=200：目标最大gc暂停时间，默认为200ms，这只是期望的目标延迟。我们知道G1有相应的收集算法，会根据收集的信息及检测的垃圾量动态的调整年轻代与老年代的大小以尽力达到这个目标。&lt;/p&gt;
&lt;p&gt;使用此配置需要注意的一点是，不要和 Xmn 年轻代同时设置，我们上面提到过，G1会为了最大gc暂停时间目标而动态的调整年轻代大小，因此，如果设定了 Xmn，那么固定了年轻代的大小就会影响G1的智能调整适应。&lt;/p&gt;
&lt;h3&gt;二、吞吐量，有多少总的延迟&lt;/h3&gt;
&lt;p&gt;总的延迟关系到服务的可用时间率、吞吐量，比如，100分钟内总的gc延迟1分钟，那么服务的可用率就是99%。如果既定的目标是99.9%，那么总的延迟就不能超过6秒钟。&lt;/p&gt;
&lt;p&gt;总的延迟=单次延迟*gc次数。&lt;/p&gt;
&lt;p&gt;单次延迟我们在一.1中已经论述，那么现在就需要通过降低gc次数来达到降低总延迟的目标，&lt;/p&gt;
&lt;p&gt;gc触发于应用内存占用达到一定比例阈值，因此想要降低gc频次，那么就需要适当调大应用可使用堆大小：Xmx。&lt;/p&gt;
&lt;p&gt;应用到底需要使用多大的应用内存，这个需要根据实际的需求确定，可以通过压测，不断的微调来找到最适合的Xmx设置，过大或者过小都会影响服务的服务能力。&lt;/p&gt;
&lt;h3&gt;三、gc日志&lt;/h3&gt;
&lt;p&gt;配置输出gc日志：-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps。&lt;/p&gt;
&lt;p&gt;下面是一段实际应用中的yong GC日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  [GC pause (G1 Evacuation Pause) (young), 0.1006389&lt;span&gt; secs]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    [Parallel Time: 45.6 ms, GC Workers: 38&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       [GC Worker Start (ms): Min: 4053175.2, Avg: 4053184.8, Max: 4053215.7, Diff: 40.5&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       [Ext Root Scanning (ms): Min: 0.0, Avg: 1.2, Max: 8.6, Diff: 8.6, Sum: 47.1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;       [Update RS (ms): Min: 0.0, Avg: 8.4, Max: 41.3, Diff: 41.3, Sum: 317.3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;          [Processed Buffers: Min: 0, Avg: 13.3, Max: 39, Diff: 39, Sum: 505&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       [Scan RS (ms): Min: 0.0, Avg: 0.2, Max: 0.4, Diff: 0.4, Sum: 7.7&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.3&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;       [Object Copy (ms): Min: 0.0, Avg: 20.6, Max: 32.6, Diff: 32.5, Sum: 783.9&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       [Termination (ms): Min: 0.0, Avg: 4.5, Max: 5.2, Diff: 5.2, Sum: 171.5&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       [GC Worker Other (ms): Min: 0.0, Avg: 0.2, Max: 0.6, Diff: 0.6, Sum: 5.9&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       [GC Worker Total (ms): Min: 4.1, Avg: 35.1, Max: 44.6, Diff: 40.5, Sum: 1333.8&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       [GC Worker End (ms): Min: 4053219.7, Avg: 4053219.9, Max: 4053220.4, Diff: 0.8&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;    [Code Root Fixup: 0.3&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;    [Code Root Purge: 0.0&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;    [Clear CT: 1.5&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;    [Other: 53.2&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       [Choose CSet: 0.0&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;       [Ref Proc: 39.2&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       [Ref Enq: 8.6&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       [Redirty Cards: 1.3&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       [Humongous Reclaim: 0.0&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       [Free CSet: 2.0&lt;span&gt; ms]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;    [Eden: 4708.0M(4708.0M)-&amp;gt;0.0B(4724.0M) Survivors: 204.0M-&amp;gt;188.0M Heap: 5528.0M(8192.0M)-&amp;gt;804.9M(8192&lt;span&gt;.0M)]
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;  [Times: user=1.37 sys=0.02, real=0.10 secs] 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一行：指明GC类型，一次GC的总耗时 0.1006389 secs，即100ms。&lt;/p&gt;
&lt;p&gt;第二行：并行阶段STW时间汇，GC工作线程数（配置：-XX:ParallelGCThreads。CPU数量小于8时，值取CPU个数，最大为8，CPU数量大于8时，值取（CPU个数*5/8））。&lt;/p&gt;
&lt;p&gt;第三行：GC线程开始工作时间，Min最小值、Avg平均值、Max最大值、Diff偏移平均的值（Max-Min）&lt;/p&gt;
&lt;p&gt;第四行：外部根区扫描，包括堆外区、JNI引用、JVM系统目录、Classloaders等。Sum总耗时。&lt;/p&gt;
&lt;p&gt;第五行：RSets（Remembered Sets ）时间信息更新，G1依据-XX:MaxGCPauseMillis参数来设定目标暂停时间，RSet更新的时间耗时应小于目标暂停时间的10%。可以通过修改配置 XX:G1RSetUpdatingPauseTimePercent 设预期定耗时占用比。&lt;/p&gt;
&lt;p&gt;第六行：已处理缓冲区：即在优化线程中处理dirty card分区扫描时记录的日志缓冲区。&lt;/p&gt;
&lt;p&gt;第七行：RSets扫描。&lt;/p&gt;
&lt;p&gt;第八行：代码Root扫描，经过JIT编译后的代码里引用了heap中的对象，引用关系保存在RSet中。&lt;/p&gt;
&lt;p&gt;第九行：拷贝存活对象到新的Region耗时。&lt;/p&gt;
&lt;p&gt;第十行：GC线程完成任务之后尝试结束到真正结束的耗时。GC线程结束前会检查其它线程是否有未完成的任务，如果有则会协助完成之后再结束。&lt;/p&gt;
&lt;p&gt;第十一行：线程花费在其他工作上的时间，&lt;/p&gt;
&lt;p&gt;第十二行：并行阶段的GC时间总和，包含GC以及GC Worker Other时间（47.1+317.3+7.7+0.3+783.9+171.5+5.9）。&lt;/p&gt;
&lt;p&gt;第十三行：GC线程结束时间，Min最小值、Avg平均值、Max最大值、Diff偏移平均的值（Max-Min）&lt;/p&gt;
&lt;p&gt;第十四行：修复GC期间code root指针改变的耗时。&lt;/p&gt;
&lt;p&gt;第十五行：清除code root耗时，root中已经失效，不再指向Region中对象的引用。&lt;/p&gt;
&lt;p&gt;第十六行：清除card tables 中的dirty card的耗时。&lt;/p&gt;
&lt;p&gt;第十七行：其它GC活动耗时。&lt;/p&gt;
&lt;p&gt;第十八行：选择要进行回收的分区放入CSet（G1选择的标准是垃圾最多的分区优先，也就是存活对象率最低的分区优先）&lt;/p&gt;
&lt;p&gt;第十九行：处理各种引用——soft、weak、final、phantom、JNI等。&lt;/p&gt;
&lt;p&gt;第二十行：遍历所有的引用，将不能回收的放入pending列表。&lt;/p&gt;
&lt;p&gt;第二十一行：在回收过程中被修改的card将会被重置为dirty。&lt;/p&gt;
&lt;p&gt;第二十二行：JDK8特性，巨型对象可以在新生代收集的时候被回收，可以通过G1ReclaimDeadHumongousObjectsAtYoungGC进行配置，默认为true。&lt;/p&gt;
&lt;p&gt;第二十三行：释放CSet，将要释放的分区还回到free列表。&lt;/p&gt;
&lt;p&gt;第二十四行：年轻代回收状态，Eden区满，执行回收，回收后占用为0，且Eden区大小重新调整（G1根据预测算法动态调整）；Survivors变小说明有提升；Heap收集前内存占用及最大值，GC收集后内存占用及最大值。最大值由Xmx配置，保持不变。&lt;/p&gt;
&lt;p&gt;第二十五行：user：垃圾收集线程在新生代垃圾收集过程中消耗的CPU时间，这个时间跟垃圾收集线程的个数有关，可能会比real time大很多；sys：内核态线程消耗的CPU时间；real：本次垃圾收集真正消耗的时间。&lt;/p&gt;
&lt;h3&gt;四、分析工具&lt;/h3&gt;
&lt;p&gt; 1、个人推荐gcviewer，图形化展示各个收集指标，另附Summary、Memory及Pause等明细统计，可以查看gc次数，总的GC耗时，最大、最小耗时、吞吐量等等：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200528002109600-1942513954.png&quot; alt=&quot;&quot; width=&quot;749&quot; height=&quot;463&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、在线工具：https://gceasy.io/，可以上传GC日志生成GC报告，下图为报告中的关于GC耗时分布统计：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200528003018726-1277624825.png&quot; alt=&quot;&quot; width=&quot;327&quot; height=&quot;278&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 27 May 2020 16:37:00 +0000</pubDate>
<dc:creator>WindWant</dc:creator>
<og:description>G1 垃圾回收器简单调优，yong GC日志解析，GC日志分析工具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niejunlei/p/12969622.html</dc:identifier>
</item>
<item>
<title>[推荐]大量 Blazor 学习资源（二） - 开发者精选资讯</title>
<link>http://www.cnblogs.com/MrHuo/p/12977703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHuo/p/12977703.html</guid>
<description>&lt;p&gt;继上一篇《&lt;a href=&quot;https://mp.weixin.qq.com/s/9cnBKj_y2IDNeZtJctdmAA&quot;&gt;[推荐]大量 Blazor 学习资源（一）&lt;/a&gt;》之后，社区反应不错，但因个人原因导致这篇文章姗姗来迟，不过最终还是来了！这篇文章主要收集一些常用组件、书籍和电子书。&lt;/p&gt;
&lt;blockquote readability=&quot;1.2096774193548&quot;&gt;
&lt;p&gt;资料来源：&lt;a href=&quot;https://github.com/AdrienTorris/awesome-blazor/&quot;&gt;https://github.com/AdrienTorris/awesome-blazor/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;并非完全翻译原文，会从所有资源里提取一些我认为好一点的资源，如有需要，从上面 Github 链接获取最新内容。&lt;/p&gt;
&lt;h2 id=&quot;组件--components&quot;&gt;组件 / Components&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;（推荐）&lt;strong&gt;Ant Design Blazor&lt;/strong&gt; - 一套企业级的UI组件基于Ant的设计和Blazor WebAssembly。 (⭐1177)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ant-design-blazor/ant-design-blazor&quot;&gt;https://github.com/ant-design-blazor/ant-design-blazor&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://ant-design-blazor.github.io/&quot;&gt;https://ant-design-blazor.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/f29300b4-a2e5-43da-a83f-076edbac48a3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Bootstrap Blazor Component&lt;/strong&gt; - Bootstrap 样式的 Blazor UI 组件库。 (⭐575)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/LongbowEnterprise/BootstrapBlazor&quot;&gt;https://gitee.com/LongbowEnterprise/BootstrapBlazor&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a81a5190-ad2c-4fe7-93f4-b1dfa542c7e9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MatBlazor - Material Design 样式的 Blazor UI 组件库。 (⭐1600)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/0c246a78-30b5-4689-98a5-0d8082b433cd.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazorise - Blazorise 基于 Blazor 和一些 CSS 框架（Bootstrap, Bulma, AntDesign 和 Material）的 Blazor UI 组件库。 (⭐924)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/stsrki/Blazorise&quot;&gt;https://github.com/stsrki/Blazorise&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Blazorise 有两个原则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;保持简单&lt;/li&gt;
&lt;li&gt;可扩展&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Demo 演示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Bootstrap Demo &lt;code&gt;https://bootstrapdemo.blazorise.com/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Bulma Demo &lt;code&gt;https://bulmademo.blazorise.com/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;AntDesign Demo &lt;code&gt;https://antdesigndemo.blazorise.com/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Material Demo &lt;code&gt;https://materialdemo.blazorise.com/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;eFrolic Demo &lt;code&gt;https://efrolicdemo.blazorise.com/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;BlazorStrap - Bootstrap 4 样式的 Blazor UI 组件库。 (⭐521)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/chanan/BlazorStrap&quot;&gt;https://github.com/chanan/BlazorStrap&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blazorstrap.io/&quot;&gt;https://blazorstrap.io/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/5fe5eeff-1afd-4473-b9c3-5cd44b881571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Radzen.Blazor - 原生 UI 样式的 Blazor UI 组件库，Blazor. DataGrid, DataList, Tabs, Dialog 等等。 (⭐362)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/akorchev/blazor.radzen.com&quot;&gt;https://github.com/akorchev/blazor.radzen.com&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blazor.radzen.com/&quot;&gt;https://blazor.radzen.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/d972d58b-45f3-4e20-a1d5-c2a7564b621e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Canvas - HTML5 Canvas API 的 Blazor 实现 (⭐215)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BlazorExtensions/Canvas&quot;&gt;https://github.com/BlazorExtensions/Canvas&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;ChartJs.Blazor - Blazor 实现的 ChartJs (⭐231)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mariusmuntean/ChartJs.Blazor&quot;&gt;https://github.com/mariusmuntean/ChartJs.Blazor&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.iheartblazor.com/welcome&quot;&gt;https://www.iheartblazor.com/welcome&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/8d724da3-3156-4570-9902-50b3a88cae02.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DevExpress Blazor UI Components - DevExpress 的 Blazor UI 组件库 (⭐191)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DevExpress/RazorComponents&quot;&gt;https://github.com/DevExpress/RazorComponents&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://demos.devexpress.com/blazor/&quot;&gt;https://demos.devexpress.com/blazor/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/39cffb8d-1e25-4e7d-bc6d-767aad120229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BlazorContextMenu - Material Design 样式的 Blazor ContextMenu 组件 (⭐181)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/stavroskasidis/BlazorContextMenu&quot;&gt;https://github.com/stavroskasidis/BlazorContextMenu&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blazor-context-menu-demo.azurewebsites.net/&quot;&gt;https://blazor-context-menu-demo.azurewebsites.net/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/53ffa328-0e5b-4b27-a7c9-079d9e79a260.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazored.Modal - Blazor 模态框组件 (⭐181)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Blazored/Modal&quot;&gt;https://github.com/Blazored/Modal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a4120c5c-a9f4-4a86-80ef-d560852dd72b.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazor.FlexGrid - Blazor GridView 组件 (⭐181)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Mewriick/Blazor.FlexGrid&quot;&gt;https://github.com/Mewriick/Blazor.FlexGrid&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/ac73c5bc-0945-4f6e-bb68-2809f3bff8f2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Grid.Blazor - 适用于 ASP.NET MVC Blazor 的 CRUD 表格组件，支持筛选、排序、搜索、分页、嵌套表格和其他 (⭐177)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/gustavnavar/Grid.Blazor&quot;&gt;https://github.com/gustavnavar/Grid.Blazor&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://gridblazor.azurewebsites.net/&quot;&gt;https://gridblazor.azurewebsites.net/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/61c46faf-39a6-481d-a35b-0af0f020fee6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BlazorMaterial - Material 风格的 Blazor UI 组件库 (⭐131)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BlazorExtensions/BlazorMaterial&quot;&gt;https://github.com/BlazorExtensions/BlazorMaterial&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;BlazorWebFormsComponents - WebForms 可用的 Blazor UI 组件库 (⭐142)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/FritzAndFriends/BlazorWebFormsComponents&quot;&gt;https://github.com/FritzAndFriends/BlazorWebFormsComponents&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;语法类似这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;asp:Button
    AccessKey=&quot;string&quot;
    BackColor=&quot;color name|#dddddd&quot;
    BorderColor=&quot;color name|#dddddd&quot;
    BorderStyle=&quot;NotSet|None|Dotted|Dashed|Solid|Double|Groove|Ridge|Inset|Outset&quot;
    BorderWidth=&quot;size&quot;
    CausesValidation=&quot;True|False&quot;
    CommandArgument=&quot;string&quot;
    CommandName=&quot;string&quot;
    CssClass=&quot;string&quot;
    Enabled=&quot;True|False&quot;
    EnableTheming=&quot;True|False&quot;
    EnableViewState=&quot;True|False&quot;
    Font-Bold=&quot;True|False&quot;
    Font-Italic=&quot;True|False&quot;
    Font-Names=&quot;string&quot;
    Font-Overline=&quot;True|False&quot;
    Font-Size=&quot;string|Smaller|Larger|XX-Small|X-Small|Small|Medium|Large|X-Large|XX-Large&quot;
    Font-Strikeout=&quot;True|False&quot;
    Font-Underline=&quot;True|False&quot;
    ForeColor=&quot;color name|#dddddd&quot;
    Height=&quot;size&quot;
    ID=&quot;string&quot;
    OnClick=&quot;Click event handler&quot;
    OnClientClick=&quot;string&quot;
    OnCommand=&quot;Command event handler&quot;
    OnDataBinding=&quot;DataBinding event handler&quot;
    OnDisposed=&quot;Disposed event handler&quot;
    OnInit=&quot;Init event handler&quot;
    OnLoad=&quot;Load event handler&quot;
    OnPreRender=&quot;PreRender event handler&quot;
    OnUnload=&quot;Unload event handler&quot;
    PostBackUrl=&quot;uri&quot;
    runat=&quot;server&quot;
    SkinID=&quot;string&quot;
    Style=&quot;string&quot;
    TabIndex=&quot;integer&quot;
    Text=&quot;string&quot;
    ToolTip=&quot;string&quot;
    UseSubmitBehavior=&quot;True|False&quot;
    ValidationGroup=&quot;string&quot;
    Visible=&quot;True|False&quot;
    Width=&quot;size&quot;
/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;bUnit - Blazor 组件测试 (⭐181)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/egil/bunit&quot;&gt;https://github.com/egil/bunit&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例，想要测试 Counter 组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;h1&amp;gt;Counter&amp;lt;/h1&amp;gt;

&amp;lt;p&amp;gt;
    Current count: @currentCount
&amp;lt;/p&amp;gt;

&amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;IncrementCount&quot;&amp;gt;Click me&amp;lt;/button&amp;gt;

@code {
  int currentCount = 0;

  void IncrementCount()
  {
    currentCount++;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下，使用 bUnit 和 xUnit：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Fact]
public void CounterShouldIncrementWhenClicked()
{
  // Arrange: render the Counter.razor component
  var cut = RenderComponent&amp;lt;Counter&amp;gt;();

  // Act: find and click the &amp;lt;button&amp;gt; element to increment
  // the counter in the &amp;lt;p&amp;gt; element
  cut.Find(&quot;button&quot;).Click();

  // Assert: first find the &amp;lt;p&amp;gt; element, then verify its content
  cut.Find(&quot;p&quot;).MarkupMatches(&quot;&amp;lt;p&amp;gt;Current count: 1&amp;lt;/p&amp;gt;&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Blazored.Toast - Toast 提示组件，Blazor 应用和组件均可使用 (⭐147)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Blazored/Toast&quot;&gt;https://github.com/Blazored/Toast&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/379ed6d8-fc50-4632-a30d-abcaea247387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BlazorInputFile - Blazor 文件上传组件 (⭐140)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/SteveSandersonMS/BlazorInputFile&quot;&gt;https://github.com/SteveSandersonMS/BlazorInputFile&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/298e8ecb-b85c-48b7-8e54-378076472a07.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/0fb17278-1f14-41b7-b8a6-58b4959c2a9a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/e75c0aa4-d0bd-4503-805a-0301a0831530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Syncfusion Blazor UI Components - Syncfusion UI 组件库 (⭐105)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/syncfusion/ej2-aspnet-core-blazor-samples&quot;&gt;https://github.com/syncfusion/ej2-aspnet-core-blazor-samples&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blazor.syncfusion.com/&quot;&gt;https://blazor.syncfusion.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/ef717903-7edb-4160-bbbe-75536d63d0fe.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazored.Typeahead - 自动完成提示的文本框，支持本地和远程数据，client-side 和 server-side 都支持 (⭐120)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Blazored/Typeahead&quot;&gt;https://github.com/Blazored/Typeahead&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/eeb816d6-2af5-4535-8c78-07ba02907423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Sotsera.Blazor.Toaster - Toast 提示框组件 (⭐90)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sotsera/sotsera.blazor.toaster&quot;&gt;https://github.com/sotsera/sotsera.blazor.toaster&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blazor-toaster.sotsera.com/&quot;&gt;https://blazor-toaster.sotsera.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/7dc03675-2329-4847-8647-1792783a34c6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazored.Menu - 菜单组件 (⭐67)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Blazored/Menu&quot;&gt;https://github.com/Blazored/Menu&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a064eae1-adef-423a-bd95-c9013e08bd31.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazor-DragDrop - 拖放组件 (⭐79)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Postlagerkarte/blazor-dragdrop&quot;&gt;https://github.com/Postlagerkarte/blazor-dragdrop&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blazordragdrop.azurewebsites.net/&quot;&gt;https://blazordragdrop.azurewebsites.net/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/44cdf47f-0378-42be-b4e3-f16356e5353c.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BlazorTable - 带有排序、分页、筛选的表格组件 (⭐84)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/IvanJosipovic/BlazorTable&quot;&gt;https://github.com/IvanJosipovic/BlazorTable&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blazortable.netlify.app/&quot;&gt;https://blazortable.netlify.app/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/8180b2cf-d859-4b39-a20b-3d79b965b376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazor-Charts - SVG 表格组件 (⭐45)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Misfits-Rebels-Outcasts/Blazor-Charts&quot;&gt;https://github.com/Misfits-Rebels-Outcasts/Blazor-Charts&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.webassemblyman.com/blazor/blazorcharts.html&quot;&gt;https://www.webassemblyman.com/blazor/blazorcharts.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/7670e233-3aa2-4846-a811-499e37941dd0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NodaTimePicker - 时间选择器组件 (⭐39)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nheath99/NodaTimePicker&quot;&gt;https://github.com/nheath99/NodaTimePicker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://nodatimepicker.z13.web.core.windows.net/&quot;&gt;https://nodatimepicker.z13.web.core.windows.net/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/47a99b09-85fb-485f-8011-34b10e3cdccd.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BlazorDateRangePicker - 范围日期选择组件 (⭐41)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jdtcn/BlazorDateRangePicker&quot;&gt;https://github.com/jdtcn/BlazorDateRangePicker&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blazordaterangepicker.azurewebsites.net/&quot;&gt;https://blazordaterangepicker.azurewebsites.net/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/91974f3f-50ac-4c8f-a78b-ddd27f3cd6f6.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BlazorGoogleMaps - 谷歌地图组件 (⭐43)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rungwiroon/BlazorGoogleMaps&quot;&gt;https://github.com/rungwiroon/BlazorGoogleMaps&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Blazor.SignaturePad - 签名面板（画图） (⭐22)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Mobsites/Blazor.SignaturePad&quot;&gt;https://github.com/Mobsites/Blazor.SignaturePad&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://signaturepad.mobsites.com/&quot;&gt;https://signaturepad.mobsites.com/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/13fd24dd-c121-425d-98c1-a81e8f05644d.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BlazorQuery - Blazor 版 jQuery (⭐40)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kevinjpetersen/BlazorQuery&quot;&gt;https://github.com/kevinjpetersen/BlazorQuery&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用 jQuery 的方式操作 DOM，ajax 请求等等。&lt;strong&gt;该项目还在紧急开发中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/&quot;
@inject BlazorQueryDOM DOM

&amp;lt;h1&amp;gt;Hello, DOM!&amp;lt;/h1&amp;gt;
&amp;lt;h1&amp;gt;Hello, Blazor!&amp;lt;/h1&amp;gt;

@code {
    protected override async Task OnAfterRenderAsync()
    {
      await DOM.Select(&quot;h1&quot;).CSS(&quot;background-color&quot;, &quot;red&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/&quot;
@inject BlazorQueryDOM DOM

&amp;lt;h1&amp;gt;Hello, DOM!&amp;lt;/h1&amp;gt;
&amp;lt;h1&amp;gt;Hello, Blazor!&amp;lt;/h1&amp;gt;

@code {
    protected override async Task OnAfterRenderAsync()
    {
      await DOM.Select(&quot;h1&quot;).Text(&quot;Now this text is changed&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Blazor-Dom-Confetti - 扔五彩纸屑 (⭐40)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ctrl-alt-d/blazor-dom-confetti&quot;&gt;https://github.com/ctrl-alt-d/blazor-dom-confetti&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/55d64b0f-e845-4a2d-861a-0d2f31b64a24.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Telerik UI for Blazor - Telerik UI 组件库 (&lt;em&gt;收费&lt;/em&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.telerik.com/blazor-ui&quot;&gt;https://www.telerik.com/blazor-ui&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;TwitterShareButton - Twitter 分享按钮 (⭐2)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jsakamoto/Toolbelt.Blazor.TwitterShareButton&quot;&gt;https://github.com/jsakamoto/Toolbelt.Blazor.TwitterShareButton&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a7aec208-cf5f-481c-80c1-76af31340f39.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazor.LoadingIndicator - 加载指示器 (⭐44)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/h3x4d3c1m4l/BlazorProgressIndicator&quot;&gt;https://github.com/h3x4d3c1m4l/BlazorProgressIndicator&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/2c2d4aab-5d36-4725-b3df-3bdae468fb0f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BlazorMonaco - 微软 Monaco Editor （VSCode 核心）组件 (⭐10)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/serdarciplak/BlazorMonaco&quot;&gt;https://github.com/serdarciplak/BlazorMonaco&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Demo 演示&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://serdarciplak.github.io/BlazorMonaco/&quot;&gt;https://serdarciplak.github.io/BlazorMonaco/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;书籍--books&quot;&gt;书籍 / Books&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Blazor Revealed （Blazor 揭秘）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Blazor Revealed, Building Web Applications in .NET(Published February, 2019).&lt;/p&gt;
&lt;blockquote readability=&quot;0.84905660377358&quot;&gt;
&lt;p&gt;国外：&lt;a href=&quot;https://www.apress.com/gp/book/9781484243428&quot;&gt;https://www.apress.com/gp/book/9781484243428&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1&quot;&gt;
&lt;p&gt;京东：&lt;a href=&quot;https://item.jd.com/41737176374.html&quot;&gt;https://item.jd.com/41737176374.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.68181818181818&quot;&gt;
&lt;p&gt;当当：&lt;a href=&quot;http://search.dangdang.com/?key=Blazor%20Revealed&amp;amp;act=input&quot;&gt;http://search.dangdang.com/?key=Blazor Revealed&amp;amp;act=input&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;电子书：&lt;/p&gt;
&lt;blockquote readability=&quot;0.48387096774194&quot;&gt;
&lt;p&gt;PDF：&lt;a href=&quot;http://file.allitebooks.com/20190205/Blazor%20Revealed.pdf&quot;&gt;http://file.allitebooks.com/20190205/Blazor Revealed.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.546875&quot;&gt;
&lt;p&gt;ePub：&lt;a href=&quot;http://file.allitebooks.com/20190205/Blazor%20Revealed.epub&quot;&gt;http://file.allitebooks.com/20190205/Blazor Revealed.epub&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Blazor Quick Start Guide: Build web applications using Blazor, EF Core, and SQL Server （Blazor 快速入门指南：使用Blazor、EF Core和SQL Server构建web应用程序）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0.81081081081081&quot;&gt;
&lt;p&gt;亚马逊：&lt;a href=&quot;https://www.amazon.in/gp/product/178934414X/ref=awesome_blazor&quot;&gt;https://www.amazon.in/gp/product/178934414X/ref=awesome_blazor&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1&quot;&gt;
&lt;p&gt;京东：&lt;a href=&quot;https://item.jd.com/41499035732.html&quot;&gt;https://item.jd.com/41499035732.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;电子书：&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://e.jd.com/30506217.html&quot;&gt;https://e.jd.com/30506217.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;电子书--e-books&quot;&gt;电子书 / E-Books&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Blazor Succinctly - 免费的从0开始学习 Blazor 框架的电子书。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.syncfusion.com/ebooks/blazor-succinctly&quot;&gt;https://www.syncfusion.com/ebooks/blazor-succinctly&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Blazor, A Beginners Guide - Blazor 初学者指南。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.telerik.com/campaigns/blazor/wp-beginners-guide-ebook&quot;&gt;https://www.telerik.com/campaigns/blazor/wp-beginners-guide-ebook&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Blazor for ASP.NET Web Forms developers&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一本来自微软的免费电子书。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://dotnet.microsoft.com/learn/aspnet/architecture#blazor-for-web-forms-devs-ebook-swim&quot;&gt;https://dotnet.microsoft.com/learn/aspnet/architecture#blazor-for-web-forms-devs-ebook-swim&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;Using CSLA 5: Blazor and WebAssembly&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本书介绍了新的Blazor UI框架，包括如何创建服务器端和客户端WebAssembly项目，如何实现身份验证和授权，以及如何使用数据绑定。然后介绍CSLA.NET如何支持Blazor，包括浏览完整的示例应用程序。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://store.lhotka.net/using-csla-5-blazor-and-webassembly&quot;&gt;https://store.lhotka.net/using-csla-5-blazor-and-webassembly&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;An Introduction to Building Applications with Blazor&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如何开始使用这个令人兴奋的易于使用的 Microsoft C# 框架创建应用程序&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.amazon.com/Introduction-Building-Applications-Blazor-applications-ebook/dp/B07WPQTT6H&quot;&gt;https://www.amazon.com/Introduction-Building-Applications-Blazor-applications-ebook/dp/B07WPQTT6H&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/316520/202005/316520-20200522031918924-278182228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;扫码关注微信公众号《开发者精选资讯》&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 27 May 2020 16:32:00 +0000</pubDate>
<dc:creator>开发者精选资讯</dc:creator>
<og:description>继上一篇《[推荐]大量 Blazor 学习资源（一）》之后，社区反应不错，但因个人原因导致这篇文章姗姗来迟，不过最终还是来了！这篇文章主要收集一些常用组件、书籍和电子书。 资料来源：https://g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MrHuo/p/12977703.html</dc:identifier>
</item>
<item>
<title>Golang源码学习：调度逻辑（四）系统调用 - 虾敏四把刀</title>
<link>http://www.cnblogs.com/flhs/p/12709962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flhs/p/12709962.html</guid>
<description>&lt;h2 id=&quot;linux系统调用&quot;&gt;Linux系统调用&lt;/h2&gt;
&lt;p&gt;概念：系统调用为用户态进程提供了硬件的抽象接口。并且是用户空间访问内核的唯一手段，除异常和陷入外，它们是内核唯一的合法入口。保证系统的安全和稳定。&lt;/p&gt;
&lt;p&gt;调用号：在Linux中，每个系统调用被赋予一个独一无二的系统调用号。当用户空间的进程执行一个系统调用时，会使用调用号指明系统调用。&lt;/p&gt;
&lt;p&gt;syscall指令：因为用户代码特权级较低，无权访问需要最高特权级才能访问的内核地址空间的代码和数据。所以需要特殊指令，在golang中是syscall。&lt;/p&gt;
&lt;h3 id=&quot;参数设置&quot;&gt;参数设置&lt;/h3&gt;
&lt;p&gt;x86-64中通过syscall指令执行系统调用的参数设置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;rax存放系统调用号，调用返回值也会放在rax中&lt;/li&gt;
&lt;li&gt;当系统调用参数小于等于6个时，参数则须按顺序放到寄存器 rdi，rsi，rdx，r10，r8，r9中。&lt;/li&gt;
&lt;li&gt;如果系统调用的参数数量大于6个，需将参数保存在一块连续的内存中，并将地址存入rbx中。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;golang中调用系统调用&quot;&gt;Golang中调用系统调用&lt;/h2&gt;
&lt;p&gt;给个简单的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package main

import (
        &quot;fmt&quot;
        &quot;os&quot;
)

func main() {
        f, _ := os.Open(&quot;read.go&quot;)
        buf := make([]byte, 1000)
        f.Read(buf)
        fmt.Printf(&quot;%s&quot;, buf)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 IDE 跟踪得到调用路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;os/file.go：(*File).Read() -&amp;gt; os/file_unix.go：(*File).read() -&amp;gt; internal/poll/fd_unix.go：(*File).pfd.Read()

-&amp;gt;syscall/syscall_unix.go：Read() -&amp;gt; syscall/zsyscall_linux_amd64.go：read() -&amp;gt; syscall/syscall_unix.go：Syscall()

// syscall/zsyscall_linux_amd64.go
func read(fd int, p []byte) (n int, err error) {
        ......
        r0, _, e1 := Syscall(SYS_READ, uintptr(fd), uintptr(_p0), uintptr(len(p)))
        ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 f.Read(buf) 最终调用了 syscall/syscall_unix.go 文件中的 Syscall 函数。我们忽略中间的具体执行逻辑。&lt;/p&gt;
&lt;p&gt;SYS_READ 定义的是 read 的系统调用号，定义在 syscall/zsysnum_linux_amd64.go。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package syscall

const (
        SYS_READ                   = 0
        SYS_WRITE                  = 1
        SYS_OPEN                   = 2
        SYS_CLOSE                  = 3
        SYS_STAT                   = 4
        SYS_FSTAT                  = 5
        ......
）
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;syscall系列函数&quot;&gt;Syscall系列函数&lt;/h2&gt;
&lt;p&gt;虽然在上面看到了 Syscall 函数，但执行系统调用的防止并不知道它一个。它们的定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// src/syscall/syscall_unix.go

func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)
func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno)
func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err Errno)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Syscall 与 Syscall6 的区别&lt;/strong&gt;：只是参数个数的不同，其他都相同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Syscall 与 RawSyscall 的区别&lt;/strong&gt;：Syscall 开始会调用 runtime·entersyscall ，结束时会调用 runtime·exitsyscall；而 RawSyscall 没有。这意味着 Syscall 是受调度器控制的，RawSyscall不受。因此 RawSyscall 可能会造成阻塞。&lt;/p&gt;
&lt;p&gt;下面来看一下源代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// src/syscall/asm_linux_amd64.s
// func Syscall(trap int64, a1, a2, a3 uintptr) (r1, r2, err uintptr);
// Trap # in AX, args in DI SI DX R10 R8 R9, return in AX DX
// Note that this differs from &quot;standard&quot; ABI convention, which
// would pass 4th arg in CX, not R10.

TEXT ·Syscall(SB),NOSPLIT,$0-56
        CALL    runtime·entersyscall(SB)        // 进入系统调用
        // 准备参数，执行系统调用
        MOVQ    a1+8(FP), DI
        MOVQ    a2+16(FP), SI
        MOVQ    a3+24(FP), DX
        MOVQ    trap+0(FP), AX                  // syscall entry
        SYSCALL
        CMPQ    AX, $0xfffffffffffff001         // 对比返回结果
        JLS     ok
        MOVQ    $-1, r1+32(FP)
        MOVQ    $0, r2+40(FP)
        NEGQ    AX
        MOVQ    AX, err+48(FP)
        CALL    runtime·exitsyscall(SB)         // 退出系统调用
        RET
ok:
        MOVQ    AX, r1+32(FP)
        MOVQ    DX, r2+40(FP)
        MOVQ    $0, err+48(FP)
        CALL    runtime·exitsyscall(SB)         // 退出系统调用
        RET

// func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
TEXT ·Syscall6(SB),NOSPLIT,$0-80
        CALL    runtime·entersyscall(SB)
        MOVQ    a1+8(FP), DI
        MOVQ    a2+16(FP), SI
        MOVQ    a3+24(FP), DX
        MOVQ    a4+32(FP), R10
        MOVQ    a5+40(FP), R8
        MOVQ    a6+48(FP), R9
        MOVQ    trap+0(FP), AX  // syscall entry
        SYSCALL
        CMPQ    AX, $0xfffffffffffff001
        JLS     ok6
        MOVQ    $-1, r1+56(FP)
        MOVQ    $0, r2+64(FP)
        NEGQ    AX
        MOVQ    AX, err+72(FP)
        CALL    runtime·exitsyscall(SB)
        RET
ok6:
        MOVQ    AX, r1+56(FP)
        MOVQ    DX, r2+64(FP)
        MOVQ    $0, err+72(FP)
        CALL    runtime·exitsyscall(SB)
        RET

// func RawSyscall(trap, a1, a2, a3 uintptr) (r1, r2, err uintptr)
TEXT ·RawSyscall(SB),NOSPLIT,$0-56
        MOVQ    a1+8(FP), DI
        MOVQ    a2+16(FP), SI
        MOVQ    a3+24(FP), DX
        MOVQ    trap+0(FP), AX  // syscall entry
        SYSCALL
        CMPQ    AX, $0xfffffffffffff001
        JLS     ok1
        MOVQ    $-1, r1+32(FP)
        MOVQ    $0, r2+40(FP)
        NEGQ    AX
        MOVQ    AX, err+48(FP)
        RET
ok1:
        MOVQ    AX, r1+32(FP)
        MOVQ    DX, r2+40(FP)
        MOVQ    $0, err+48(FP)
        RET

// func RawSyscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr)
TEXT ·RawSyscall6(SB),NOSPLIT,$0-80
        ......
        RET
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;系统调用前函数（entersyscall---reentersyscall）&quot;&gt;系统调用前函数（entersyscall -&amp;gt; reentersyscall）&lt;/h2&gt;
&lt;p&gt;在执行系统调用前调用 entersyscall 和 reentersyscall，reentersyscall的主要功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;因为要开始系统调用，所以当前G和和P的状态分别变为了 _Gsyscall 和 _Psyscall&lt;/li&gt;
&lt;li&gt;而P不会等待M，所以P和M相互解绑&lt;/li&gt;
&lt;li&gt;但是M会保留P到 m.oldp 中，在系统调用结束后尝试与P重新绑定。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本节及后面会涉及到一些之前分析过的函数，这里给出链接，就不重复分析了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func entersyscall() {
        reentersyscall(getcallerpc(), getcallersp())
}
func reentersyscall(pc, sp uintptr) {
        _g_ := getg()
        _g_.m.locks++
        _g_.stackguard0 = stackPreempt
        _g_.throwsplit = true

        // Leave SP around for GC and traceback.
        save(pc, sp)
        _g_.syscallsp = sp
        _g_.syscallpc = pc
        casgstatus(_g_, _Grunning, _Gsyscall)   // 当前g的状态由 _Grunning 改为 _Gsyscall
        ......
        _g_.m.syscalltick = _g_.m.p.ptr().syscalltick
        _g_.sysblocktraced = true
        _g_.m.mcache = nil
        pp := _g_.m.p.ptr()
        pp.m = 0                                // 当前 p 解绑 m
        _g_.m.oldp.set(pp)                      // 将当前 p 赋值给 m.oldp。会在 exitsyscall 中用到。
        _g_.m.p = 0                             // 当前 m 解绑 p
        atomic.Store(&amp;amp;pp.status, _Psyscall) // 将当前 p 的状态改为 _Psyscall
        ......
        _g_.m.locks--
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;系统调用退出后函数（exitsyscall）&quot;&gt;系统调用退出后函数（exitsyscall）&lt;/h2&gt;
&lt;p&gt;主要功能是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先尝试绑定oldp，如果不允许，则绑定任意空闲P&lt;/li&gt;
&lt;li&gt;未能绑定P，则解绑G和M；睡眠工作线程；重新调度。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;func exitsyscall() {
        _g_ := getg()
        ......
        _g_.waitsince = 0
        oldp := _g_.m.oldp.ptr()        // reentersyscall 函数中存储的P
        _g_.m.oldp = 0
        if exitsyscallfast(oldp) {      // 尝试给当前M绑定个P，下有分析。绑定成功后执行 if 中的语句。
                _g_.m.p.ptr().syscalltick++
                casgstatus(_g_, _Gsyscall, _Grunning) // 更改G的状态
                _g_.syscallsp = 0
                _g_.m.locks--
                if _g_.preempt {
                        _g_.stackguard0 = stackPreempt
                } else {
                        _g_.stackguard0 = _g_.stack.lo + _StackGuard
                }
                _g_.throwsplit = false
                return
        }
        ......
        mcall(exitsyscall0)     // 下有分析
        ......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;尝试为当前m绑定p（exitsyscallfast）&quot;&gt;尝试为当前M绑定P（exitsyscallfast）&lt;/h3&gt;
&lt;p&gt;该函数的主要目的是尝试为当前M绑定一个P，分为两种情况。&lt;/p&gt;
&lt;p&gt;第一：如果oldp（也就是当前M的元配）存在，并且状态可以从 _Psyscall 变更到 _Pidle，则此P与M相互绑定，返回true。&lt;/p&gt;
&lt;p&gt;第二：oldp条件不允许，则尝试获取任何空闲的P并与当前M绑定。具体实现是：exitsyscallfast_pidle 调用 pidleget，不为nil，则调用 acquirep。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func exitsyscallfast(oldp *p) bool {
        _g_ := getg()
        // 尝试与oldp绑定
        if oldp != nil &amp;amp;&amp;amp; oldp.status == _Psyscall &amp;amp;&amp;amp; atomic.Cas(&amp;amp;oldp.status, _Psyscall, _Pidle) {
                // There's a cpu for us, so we can run.
                wirep(oldp)
                exitsyscallfast_reacquired()
                return true
        }
        // 尝试获取任何空闲的P
        if sched.pidle != 0 {
                var ok bool
                systemstack(func() {
                        ok = exitsyscallfast_pidle()
                         ......
                })
                if ok {
                        return true
                }
        }
        return false
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;m解绑g，重新调度（mcallexitsyscall0）&quot;&gt;M解绑G，重新调度（mcall(exitsyscall0)）&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;func exitsyscall0(gp *g) {
        _g_ := getg()   // g0
        casgstatus(gp, _Gsyscall, _Grunnable)
        dropg() // 解绑 gp 与 M
        lock(&amp;amp;sched.lock)
        var _p_ *p
        if schedEnabled(_g_) {
                _p_ = pidleget()
        }
        if _p_ == nil {
                globrunqput(gp) // 未获取到空闲P，将gp放入sched.runq
        } else if atomic.Load(&amp;amp;sched.sysmonwait) != 0 {
                atomic.Store(&amp;amp;sched.sysmonwait, 0)
                notewakeup(&amp;amp;sched.sysmonnote)
        }
        unlock(&amp;amp;sched.lock)
        if _p_ != nil {
                acquirep(_p_)
                execute(gp, false) // 有P，与当前M绑定，执行gp，进入调度循环。
        }
        if _g_.m.lockedg != 0 {
                // Wait until another thread schedules gp and so m again.
                stoplockedm()
                execute(gp, false) // Never returns.
        }
        stopm()         // 没有新工作之前停止M的执行。睡眠工作线程。在获得P并且唤醒之后会继续执行
        schedule()      // 能走到这里说明M以获得P，并且被唤醒，可以寻找一个G，继续调度了。
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;exitsyscall0---stopm&quot;&gt;exitsyscall0 -&amp;gt; stopm&lt;/h3&gt;
&lt;p&gt;主要内容是将 M 放回 sched.midle，并通过futex系统调用挂起线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;func stopm() {
        _g_ := getg()

        if _g_.m.locks != 0 {
                throw(&quot;stopm holding locks&quot;)
        }
        if _g_.m.p != 0 {
                throw(&quot;stopm holding p&quot;)
        }
        if _g_.m.spinning {
                throw(&quot;stopm spinning&quot;)
        }

        lock(&amp;amp;sched.lock)
        mput(_g_.m)             // M 放回 sched.midle
        unlock(&amp;amp;sched.lock)
        notesleep(&amp;amp;_g_.m.park)      // notesleep-&amp;gt;futexsleep-&amp;gt;runtime.futex-&amp;gt;futex系统调用。
        noteclear(&amp;amp;_g_.m.park)
        acquirep(_g_.m.nextp.ptr())
        _g_.m.nextp = 0
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在系统调用之前调用：&lt;strong&gt;entersyscall&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;更改P和G的状态为_Psyscall和_Gsyscall&lt;/li&gt;
&lt;li&gt;解绑P和M&lt;/li&gt;
&lt;li&gt;将P存入m.oldp&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在系统调用之后调用：&lt;strong&gt;exitsyscall&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;不太恰当的比喻&quot;&gt;不太恰当的比喻&lt;/h2&gt;
&lt;h3 id=&quot;背景设定&quot;&gt;背景设定&lt;/h3&gt;
&lt;p&gt;角色：家长（M）与房子（P）和孩子们（G）。&lt;br/&gt;规则：家长必须要在房子里才能抚养孩子们（运行）。但房子并不固定属于某个家长，孩子也并不固定属于某个家长。&lt;/p&gt;
&lt;h3 id=&quot;出门打猎：&quot;&gt;出门打猎：&lt;/h3&gt;
&lt;p&gt;家长张三要带着一个孩子（m.curg）小明出去打猎（syscall），他们就离家出走（_Gsyscall/_Psyscall）了，家长和房子就互相断了归属，但是他们还留着（m.oldp）房子的地址（天字一号房）。&lt;/p&gt;
&lt;h3 id=&quot;打猎期间：&quot;&gt;打猎期间：&lt;/h3&gt;
&lt;p&gt;这期间其他没有房子的家长（李四）看到天字一号没有家长，可能会占据这个房子，并且抚养房子里的孩子。&lt;/p&gt;
&lt;h3 id=&quot;打完回家：&quot;&gt;打完回家：&lt;/h3&gt;
&lt;p&gt;家长带小明打猎回来后，如果天字一号没有被其他家长占据，那么继续原来的生活（P和M绑定，P/G变为_Prunning/_Grunning）。&lt;br/&gt;如果天字一号被李四占据，那么张三会寻找任何一个空闲房子（可能李四也是这么丢的房子吧）。继续原来的生活。&lt;br/&gt;但是，如果张三没有找到任何一个房子，那么张三就要和小明分离了（dropg），小明被放到孤儿院（globrunqput）等待领养，张三被放在养老院（mput）睡觉（futex系统调用）。&lt;/p&gt;
&lt;h3 id=&quot;张三的命运：&quot;&gt;张三的命运：&lt;/h3&gt;
&lt;p&gt;可能有一天有房子空出来了，张三被放在房子里，然后唤醒，继续抚养孩子（schedule）。&lt;/p&gt;
</description>
<pubDate>Wed, 27 May 2020 15:57:00 +0000</pubDate>
<dc:creator>虾敏四把刀</dc:creator>
<og:description>Linux系统调用 概念：系统调用为用户态进程提供了硬件的抽象接口。并且是用户空间访问内核的唯一手段，除异常和陷入外，它们是内核唯一的合法入口。保证系统的安全和稳定。 调用号：在Linux中，每个系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flhs/p/12709962.html</dc:identifier>
</item>
<item>
<title>如何理解Java中的自动拆箱和自动装箱？ - niceyoo</title>
<link>http://www.cnblogs.com/niceyoo/p/12977541.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niceyoo/p/12977541.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伟刚毕业时面的第一家公司就被面试官给问住了...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如何理解Java中的自动拆箱和自动装箱？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自动拆箱？自动装箱？什么鬼，听都没听过啊，这...这..知识盲区...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到家后小伟赶紧查资料，我透，这不就是问基本类型跟封装类型吗，面试官整啥名词呢...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别问结果，问就是没过。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;1、&lt;/strong&gt; 什么是自动装箱，自动拆箱&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义：基本数据类型和包装类之间可以自动地相互转换&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解：装箱就是自动将基本数据类型转换为封装类型，拆箱就是自动将封装类型转换为基本数据类型。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，Java中提供了四大类基本数据类型，分别是：整数、浮点数、字符型和布尔型，其中：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;整数包含：byte、int、short、long&lt;/li&gt;
&lt;li&gt;浮点数包含：float、double&lt;/li&gt;
&lt;li&gt;字符类型：char&lt;/li&gt;
&lt;li&gt;布尔类型：boolean&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本数据类型相信大家一定很熟悉了吧，来来来，说说他们的取值范围~&lt;/p&gt;
&lt;table data-tool=&quot;mdnice编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;取值范围&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;-128 ~ 127&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;-32786 ~ 32767&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;-4294967296 ~ 4294967295&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;-2^64^ ~ 2^64^ -1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;3.4e-038 ~ 3.4e+038&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;1.7e-308 ~ 1.7e+308&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;\u0000 ~ \uffff&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;true 、false&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发中，靠这些&lt;code&gt;基本数据类型&lt;/code&gt;几乎能够满足我们的需求，但是基本类型终究不是对象，往重了说不满足面向对象的开发思想，往轻了说就是使用不方便。怎么讲？例如做一些数据类型转换，获取int数据类型的取值范围等等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，类的优点在于它可以定义成员变量、成员方法，提供丰富便利的功能，因此Java在JDK1.0的时候就设计了基本数据类型的包装类，而在JDK1.5中引入了新特性：自动装箱和拆箱。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下基本类型跟封装类型之间的对应关系：&lt;/p&gt;
&lt;table data-tool=&quot;mdnice编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;封装类&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;2、&lt;/strong&gt; 使用包装类型后的便捷&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以上边提到的&lt;code&gt;数据类型转换&lt;/code&gt;为例，看看使用包装类型后的便捷性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伟在数据库中存放商品库存用的是 &lt;code&gt;varchar&lt;/code&gt; 类型来存储的，所以在代码中的实体与之对应的是 &lt;code&gt;String&lt;/code&gt;，那么问题来了，既然是库存，那么势必就要用到加减乘除之类的运算，所以就需要先转换成 &lt;strong&gt;数值类型&lt;/strong&gt;(int\long\float等)来运算，我们看一下通过包装类是如何快速转换的「int\long\float」：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{
        
        String number = &lt;span class=&quot;hljs-string&quot;&gt;&quot;666&quot;&lt;/span&gt;;
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; intVal = Integer.valueOf(number);
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;float&lt;/span&gt; floatVal = Float.valueOf(number);
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; longVal = Long.valueOf(number);
        
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;int=&quot;&lt;/span&gt;+intVal);
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;floatVal=&quot;&lt;/span&gt;+floatVal);
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;longVal=&quot;&lt;/span&gt;+longVal);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;3、&lt;/strong&gt; 落实自动装箱、拆箱&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完了包装类型的便捷性后，我们再来落实到自动装箱、自动拆箱上...&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;怎么就自动装箱，自动拆箱了呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一段代码，看看哪是自动装箱跟自动拆箱：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;
&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;. Integer a = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;

&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;. &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; b = a;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自动装箱，相当于Java编译器替我们执行了 &lt;code&gt;Integer.valueOf(XXX);&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自动拆箱，相当于Java编译器替我们执行了&lt;code&gt;Integer.intValue(XXX);&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们证实一下，首先通过 javac 编译得到 class 文件，接着反编译看看：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指令为：&lt;code&gt;javap -c class文件名&lt;/code&gt;，得到下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20200527210824925.png&quot; alt=&quot;&quot; width=&quot;1086&quot; height=&quot;681&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完编译器替我们做的，接下来我们再通过源码看看，首先是自动装箱 &lt;code&gt;valueOf()&lt;/code&gt; 方法:&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Integer &lt;span class=&quot;hljs-title&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{
 &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; IntegerCache.cache[i + (-IntegerCache.low)];
 &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Integer(i);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，首先是&lt;code&gt;if&lt;/code&gt;方法， 对传入的&lt;code&gt;int&lt;/code&gt; 数值进行判断，如果 &lt;code&gt;i &amp;gt;= -128&lt;/code&gt; 且&lt;code&gt;i &amp;lt;= 127&lt;/code&gt; 那么就会从&lt;code&gt;IntegerCache&lt;/code&gt;缓存中获取指定数字的封装类，如果不存在则 &lt;strong&gt;new&lt;/strong&gt; 出一个新的封装类，关于 &lt;code&gt;IntegerCache&lt;/code&gt; ，其内部实现了一个&lt;code&gt;Integer&lt;/code&gt;的静态常量数组，在类加载的时候，执行&lt;code&gt;static&lt;/code&gt;静态块进行初始化&lt;code&gt;-128~127&lt;/code&gt;之间的&lt;code&gt;Integer&lt;/code&gt;对象，存放到&lt;code&gt;cache&lt;/code&gt;数组中，&lt;code&gt;cache&lt;/code&gt;属于常量，存放在java的方法区中，对方法区不太了解的小伙伴可以先留空，后面我会单独水一篇的~&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;额外补充一下：上边我们只看了Integer封装类的自动装箱方法，从方法中我们了解了在&lt;code&gt;-128~127&lt;/code&gt;之间使用了缓存，那么是不是意味着别的封装类也是这样呢？其实不是的，首先Integer使用缓存原因是该区间会被经常使用到，且数量个数比较确定，就256个值，所以为了提高效率，防止每次自动装箱都创建一次对象实例，然后就你懂得~，而double、float浮点型是没有使用缓存的，因为小数点的原因，所以在这个区间范围内个数是比较泛的，即不适合缓存，没有意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过一段代码看看这个缓存的效果吧：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test2&lt;/span&gt; &lt;/span&gt;{
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{
        Integer a = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;
        Integer b = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;
        Integer c = &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;;
        Integer d = &lt;span class=&quot;hljs-number&quot;&gt;200&lt;/span&gt;;
        System.out.println(a==b); 
        System.out.println(a==b); 
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着再来看自动拆箱 &lt;code&gt;intValue()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; value;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;intValue&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
 &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; value;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法就比较简单了，调用时直接返回了基本数据类型的 value 值。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此我们看完了自动装箱、自动拆箱，以Integer为例我们知道了使用 valueOf() 方法实现装箱，使用 intValue() 方法实现拆箱，接下来我们再结合几行代码重新回顾一下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;. Integer a = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Integer(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;);
&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;. Integer b = &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;
&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;. b+=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot; readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第一行代码：new 了一个 Integer 对象实例，将 int 类型的数据传入包装成了 Integer 类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第二行代码：首先我们知道 100 是 int 类型的，但是等待复制的 b 是 Integer 类型，此时就用到了自动装箱，&lt;code&gt;b = Integer.valueOf(100)&lt;/code&gt;，将100包装成包装类了「通过反编译验证」&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第三行代码：用到了自动装箱+自动拆箱，&lt;code&gt;b = b + 100 = Integer.intValye(b) + 100&lt;/code&gt; 此时计算结果得到的应该是 int 类型的 b，但是 b 又被限定了是 Integer 类型，所以就又要用到 &lt;code&gt;Integet.valueOf()&lt;/code&gt; 自动装箱。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;4、&lt;/strong&gt; 上才艺&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;才艺一：如何理解Java中的自动拆箱和自动装箱？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：自动装箱就是将基本数据类型自动转换为封装类型，自动拆箱是将封装类型自动转换为基本数据类型。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;才艺二：能说一下是通过哪些方法实现自动拆箱、装箱的吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：以Integer为例，使用&lt;code&gt;Integer.valueOf()&lt;/code&gt;方法实现装箱，使用&lt;code&gt;Integer.intValue()&lt;/code&gt;方法实现拆箱。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/2020_05_16/1590559114224_55b6eb64-6ffb-4232-89e4-3a9c4e8741ba.png&quot; alt=&quot;&quot; width=&quot;677&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjA0NDE3OQ==&amp;amp;mid=2247483818&amp;amp;idx=1&amp;amp;sn=edba8c69efbf9f68273c5ec8d4431b7f&amp;amp;chksm=cf5dfdd6f82a74c06e1b9dffc07158aced0608575a6972d56d24a9279b845d105ea353d779d8&amp;amp;token=1326451047&amp;amp;lang=zh_CN#rd&quot;&gt;跟小伟一起学习类加载机制&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MjA0NDE3OQ==&amp;amp;mid=2247483780&amp;amp;idx=1&amp;amp;sn=8932cb9a62e3d1b97a1b1f869a21f0eb&amp;amp;chksm=cf5dfdf8f82a74ee43b6942b1c0cdc9b4a59ee1a18ebf74b7f03127e7cc95d542cafa8d27f19&amp;amp;scene=21#wechat_redirect&quot;&gt;为什么有这么多领优惠劵的群？&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4MjA0NDE3OQ==&amp;amp;mid=2247483851&amp;amp;idx=1&amp;amp;sn=bd024c439ac495e6df1414c9f895fe2d&amp;amp;chksm=cf5dfdb7f82a74a1d65bcf053c56a30fb253c996bb99e14a7fdcd5413f8e3cb0d1e8fa224c85#rd&quot;&gt;单招计算机类哪个专业比较好&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 May 2020 15:45:00 +0000</pubDate>
<dc:creator>niceyoo</dc:creator>
<og:description>小伟刚毕业时面的第一家公司就被面试官给问住了... 如何理解Java中的自动拆箱和自动装箱？ 自动拆箱？自动装箱？什么鬼，听都没听过啊，这...这..知识盲区... 回到家后小伟赶紧查资料，我透，这不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niceyoo/p/12977541.html</dc:identifier>
</item>
<item>
<title>使用websocket开发智能聊天机器人 - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/12977422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/12977422.html</guid>
<description>&lt;p&gt;前面我们学习了异步web框架（sanic）和http异步调用库httpx，今天我们学习websocket技术。&lt;/p&gt;
&lt;h2 id=&quot;websocket简介&quot;&gt;websocket简介&lt;/h2&gt;
&lt;p&gt;我们知道HTTP协议是：请求-&amp;gt;响应，如果没有响应就一直等着，直到超时；但是有时候后台的处理需要很长时间才能给到结果，比如30分钟，那HTTP的请求不可能等这么久，所以，可以通过 Ajax 轮询来解决。那就是每间隔一段时间就请求一次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202005/311516-20200527232150811-1418372604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。&lt;/p&gt;
&lt;p&gt;HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202005/311516-20200527232207001-1802404090.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。&lt;/p&gt;
&lt;p&gt;好了，WebSocket就是为了解决这个问题的，感兴趣去看其他资料！&lt;/p&gt;
&lt;h2 id=&quot;智能聊天机器人&quot;&gt;智能聊天机器人&lt;/h2&gt;
&lt;p&gt;我一开始只是为了学习WebSocket找个例子，不少例子使用了聊天功能。我稍加改进就变成了智能聊天功能了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/311516/202005/311516-20200527232225345-59516780.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过异步sanic异步框架实现Web功能。官方文档里面给个WebSocket使用的例子。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sanic.readthedocs.io/en/latest/sanic/websocket.html&quot;&gt;https://sanic.readthedocs.io/en/latest/sanic/websocket.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;snaic部分核心代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import sanic
import httpx
from sanic import Sanic
from sanic.response import json
from sanic.websocket import WebSocketProtocol
from sanic.exceptions import NotFound
from sanic.response import html
from jinja2 import Environment, PackageLoader


env = Environment(loader=PackageLoader('app', 'templates'))

app = Sanic(__name__)


@app.route('/')
async def index(request):
    &quot;&quot;&quot;
    聊天页面
    &quot;&quot;&quot;
    template = env.get_template('index.html')
    html_content = template.render(title='聊天机器人')
    return html(html_content)


@app.websocket('/chat')
async def chat(request, ws):
    &quot;&quot;&quot;
    处理聊天信息，并返回消息
    &quot;&quot;&quot;
    while True:
        user_msg = await ws.recv()
        print('Received: ' + user_msg)
        intelligence_data = {&quot;key&quot;: &quot;free&quot;, &quot;appid&quot;: 0, &quot;msg&quot;: user_msg}
        r = httpx.get(&quot;http://api.qingyunke.com/api.php&quot;, params=intelligence_data)
        chat_msg = r.json()[&quot;content&quot;]
        print('Sending: ' + chat_msg)
        await ws.send(chat_msg)


if __name__ == &quot;__main__&quot;:
    app.error_handler.add(
        NotFound,
        lambda r, e: sanic.response.empty(status=404)
    )
    app.run(host=&quot;192.168.0.7&quot;, port=8000, protocol=WebSocketProtocol, debug=True)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;index() 函数，返回聊天页面。这里用到了jinja2 模板渲染库。&lt;/li&gt;
&lt;li&gt;chat() 函数，通过webSocket实现消息的接收、处理和返回。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;智能聊天是怎么做到的，这里要感谢 青云客网络，他们提供了免费的接口。（我当时也只是抱着试试看的态度，没想到，duang~! ）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user_msg = &quot;你好！&quot;
intelligence_data = {&quot;key&quot;: &quot;free&quot;, &quot;appid&quot;: 0, &quot;msg&quot;: user_msg}
r = httpx.get(&quot;http://api.qingyunke.com/api.php&quot;, params=intelligence_data)
chat_msg = r.json()[&quot;content&quot;]
print(chat_msg)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是超简单。&lt;/p&gt;
&lt;p&gt;再来看前端代码，主要部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-HTML&quot;&gt;  &amp;lt;div class=&quot;container theme-showcase&quot; role=&quot;main&quot; style=&quot;margin-top: 80px;&quot;&amp;gt;
      &amp;lt;div id=&quot;contents&quot; style=&quot;height: 600px; background-color:#eee;&quot;&amp;gt;&amp;lt;/div&amp;gt;
      &amp;lt;div&amp;gt;
          &amp;lt;textarea class=&quot;form-control&quot; id=&quot;msg&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
          &amp;lt;button class=&quot;btn btn-lg btn-info&quot; onclick=&quot;sendMsg()&quot; style=&quot;float: right;&quot;&amp;gt;发送&amp;lt;/button&amp;gt;
      &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;script src=&quot;http://code.jquery.com/jquery-2.1.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;

          var ws = new WebSocket(&quot;ws://192.168.0.7:8000/chat&quot;);
          ws.onmessage = function(e) {
              $(&quot;#contents&quot;).append('&amp;lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot; style=&quot;float: left;&quot;&amp;gt;' + &quot;机器人: &quot; + e.data + &quot;&amp;lt;/div&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;);
          }
          function sendMsg() {
              var msg = $(&quot;#msg&quot;).val();
              $(&quot;#contents&quot;).append('&amp;lt;div class=&quot;alert alert-info&quot; role=&quot;alert&quot; style=&quot;float:right&quot;&amp;gt;' + msg + &quot;&amp;lt;/div&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;);
              ws.send(msg);
              $(&quot;#msg&quot;).val(&quot;&quot;);
          }

  &amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里使用到了 bootstrap 前端框架，主要 调用部分在：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var Socket = new WebSocket(url, [protocol] );
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Socket.send(msg): 使用连接发送数据。&lt;/li&gt;
&lt;li&gt;Socket.onmessage: 客户端接收服务端数据时触发。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我知道，你迫不及待想要完整的代码了：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/defnngj/learning-API-test&quot;&gt;https://github.com/defnngj/learning-API-test&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 May 2020 15:25:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>使用websocket开发智能聊天机器人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fnng/p/12977422.html</dc:identifier>
</item>
</channel>
</rss>