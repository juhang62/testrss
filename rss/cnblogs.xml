<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JMH-大厂是如何使用JMH进行Java代码性能测试的？必须掌握！ - 未读代码</title>
<link>http://www.cnblogs.com/niumoo/p/13557754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/13557754.html</guid>
<description>&lt;h2 id=&quot;java-性能测试难题&quot;&gt;Java 性能测试难题&lt;/h2&gt;
&lt;p&gt;现在的 JVM 已经越来越为智能，它可以在编译阶段、加载阶段、运行阶段对代码进行优化。比如你写了一段不怎么聪明的代码，到了 JVM 这里，它发现几处可以优化的地方，就顺手帮你优化了一把。这对程序的运行固然美妙，却让开发者不能准确了解程序的运行情况。在需要进行性能测试时，如果不知道 JVM 优化细节，可能会导致你的测试结果差之毫厘，失之千里，同样的，Java 诞生之初就有一次编译、随处运行的口号，JVM 提供了底层支持，也提供了内存管理机制，这些机制都会对我们的性能测试结果造成不可预测的影响。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;long start = System.currentTimeMillis();
// ....
long end = System.currentTimeMillis();
System.out.println(end - start);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面可能就是你最常见的性能测试了，这样的测试结果真的准确吗？答案是否定的，它有下面几个问题。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;时间精度问题，本身获取到的时间戳就是存在&lt;strong&gt;误差&lt;/strong&gt;的，它和操作系统有关。&lt;/li&gt;
&lt;li&gt;JVM 在运行时会进行&lt;strong&gt;代码预热&lt;/strong&gt;，说白了就是&lt;strong&gt;越跑越快&lt;/strong&gt;。因为类需要装载、需要准备操作。&lt;/li&gt;
&lt;li&gt;JVM 会在各个阶段都有可能对你的代码进行&lt;strong&gt;优化处理&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源回收&lt;/strong&gt;的不确定性，可能运行很快，回收很慢。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;带着这些问题，突然发现进行一次严格的基准测试的难度大大增加。那么如何才能进行一次严格的基准测试呢？&lt;/p&gt;
&lt;h2 id=&quot;jmh-介绍&quot;&gt;JMH 介绍&lt;/h2&gt;
&lt;p&gt;那么如何对 Java 程序进行一次精准的性能测试呢？难道需要掌握很多 JVM 优化细节吗？难道要研究如何避免，并进行正确编码才能进行严格的性能测试吗？显然不是，如果是这样的话，未免过于困难了，好在有一款一款官方的微基准测试工具 - &lt;strong&gt;JMH&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JMH&lt;/strong&gt; 的全名是 Java Microbenchmark Harness，它是由 &lt;strong&gt;Java 虚拟机团队&lt;/strong&gt;开发的一款用于 Java &lt;strong&gt;微基准测试工具&lt;/strong&gt;。用自己开发的工具测试自己开发的另一款工具，以子之矛，攻子之盾果真手到擒来，如臂使指。使用 &lt;strong&gt;JMH&lt;/strong&gt; 可以让你方便快速的进行一次严格的代码基准测试，并且有多种测试模式，多种测试维度可供选择；而且使用简单、增加注解便可启动测试。&lt;/p&gt;
&lt;h2 id=&quot;jmh-使用&quot;&gt;JMH 使用&lt;/h2&gt;
&lt;p&gt;JMH 的使用首先引入 maven 所需依赖，当前最新版 为 1.23 版本。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--jmh 基准测试 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jmh-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.23&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.openjdk.jmh&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jmh-generator-annprocess&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.23&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;快速测试&quot;&gt;快速测试&lt;/h3&gt;
&lt;p&gt;下面使用注解的方式指定测试参数，通过一个例子展示 JMH 基准测试的具体用法，先看一次运行效果，然后再了解每个注解的具体含义。&lt;/p&gt;
&lt;p&gt;这个例子是使用 JMH 测试，使用加号拼接字符串和使用 &lt;code&gt;StringBuilder&lt;/code&gt; 的 &lt;code&gt;append&lt;/code&gt; 方法拼接字符串时的速度如何，每次拼接1000个数字进行平均速度比较。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.TimeUnit;
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

/**
 * &amp;lt;p&amp;gt;
 * JMH 基准测试入门
 *
 * @author niujinpeng
 * @Date 2020/8/21 1:13
 */
@BenchmarkMode(Mode.AverageTime)
@State(Scope.Thread)
@Fork(1)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@Warmup(iterations = 3)
@Measurement(iterations = 5)
public class JmhHello {

    String string = &quot;&quot;;
    StringBuilder stringBuilder = new StringBuilder();

    @Benchmark
    public String stringAdd() {
        for (int i = 0; i &amp;lt; 1000; i++) {
            string = string + i;
        }
        return string;
    }

    @Benchmark
    public String stringBuilderAppend() {
        for (int i = 0; i &amp;lt; 1000; i++) {
            stringBuilder.append(i);
        }
        return stringBuilder.toString();
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
            .include(JmhHello.class.getSimpleName())
            .build();
        new Runner(opt).run();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很简单，不做解释，&lt;code&gt;stringAdd&lt;/code&gt; 使用加号拼接字符串 1000次，&lt;code&gt;stringBuilderAppend&lt;/code&gt; 使用 &lt;code&gt;append&lt;/code&gt; 拼接字符串 1000次。直接运行 main 方法，稍等片刻后可以得到详细的运行输出结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-log&quot;&gt;// 开始测试 stringAdd 方法
# JMH version: 1.23
# VM version: JDK 1.8.0_181, Java HotSpot(TM) 64-Bit Server VM, 25.181-b13
# VM invoker: D:\develop\Java\jdk8_181\jre\bin\java.exe
# VM options: -javaagent:C:\ideaIU-2020.1.3.win\lib\idea_rt.jar=50363:C:\ideaIU-2020.1.3.win\bin -Dfile.encoding=UTF-8
# Warmup: 3 iterations, 10 s each  // 预热运行三次
# Measurement: 5 iterations, 10 s each // 性能测试5次 
# Timeout: 10 min per iteration  // 超时时间10分钟
# Threads: 1 thread, will synchronize iterations  // 线程数量为1
# Benchmark mode: Average time, time/op  // 统计方法调用一次的平均时间
# Benchmark: net.codingme.jmh.JmhHello.stringAdd // 本次执行的方法

# Run progress: 0.00% complete, ETA 00:02:40
# Fork: 1 of 1
# Warmup Iteration   1: 95.153 ms/op  // 第一次预热，耗时95ms
# Warmup Iteration   2: 108.927 ms/op // 第二次预热，耗时108ms
# Warmup Iteration   3: 167.760 ms/op // 第三次预热，耗时167ms
Iteration   1: 198.897 ms/op  // 执行五次耗时度量
Iteration   2: 243.437 ms/op
Iteration   3: 271.171 ms/op
Iteration   4: 295.636 ms/op
Iteration   5: 327.822 ms/op


Result &quot;net.codingme.jmh.JmhHello.stringAdd&quot;:
  267.393 ±(99.9%) 189.907 ms/op [Average]
  (min, avg, max) = (198.897, 267.393, 327.822), stdev = 49.318  // 执行的最小、平均、最大、误差值
  CI (99.9%): [77.486, 457.299] (assumes normal distribution)
  
// 开始测试 stringBuilderAppend 方法
# Benchmark: net.codingme.jmh.JmhHello.stringBuilderAppend

# Run progress: 50.00% complete, ETA 00:01:21
# Fork: 1 of 1
# Warmup Iteration   1: 1.872 ms/op
# Warmup Iteration   2: 4.491 ms/op
# Warmup Iteration   3: 5.866 ms/op
Iteration   1: 6.936 ms/op
Iteration   2: 8.465 ms/op
Iteration   3: 8.925 ms/op
Iteration   4: 9.766 ms/op
Iteration   5: 10.143 ms/op


Result &quot;net.codingme.jmh.JmhHello.stringBuilderAppend&quot;:
  8.847 ±(99.9%) 4.844 ms/op [Average]
  (min, avg, max) = (6.936, 8.847, 10.143), stdev = 1.258
  CI (99.9%): [4.003, 13.691] (assumes normal distribution)


# Run complete. Total time: 00:02:42

REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up on
why the numbers are the way they are. Use profilers (see -prof, -lprof), design factorial
experiments, perform baseline and negative tests that provide experimental control, make sure
the benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.
Do not assume the numbers tell you what you want them to tell.
// 测试结果对比
Benchmark                     Mode  Cnt    Score     Error  Units
JmhHello.stringAdd            avgt    5  267.393 ± 189.907  ms/op
JmhHello.stringBuilderAppend  avgt    5    8.847 ±   4.844  ms/op

Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面日志里的 &lt;code&gt;//&lt;/code&gt; 注释是我手动增加上去的，其实我们只需要看下面的最终结果就可以了，可以看到 &lt;code&gt;stringAdd&lt;/code&gt; 方法平均耗时 267.393ms，而 &lt;code&gt;stringBuilderAppend&lt;/code&gt; 方法平均耗时只有 8.847ms，可见 &lt;code&gt;StringBuilder&lt;/code&gt; 的 &lt;code&gt;append&lt;/code&gt; 方法进行字符串拼接速度快的多，这也是我们推荐使用 &lt;code&gt;append&lt;/code&gt; 进行字符串拼接的原因。&lt;/p&gt;
&lt;h3 id=&quot;注解说明&quot;&gt;注解说明&lt;/h3&gt;
&lt;p&gt;经过上面的示例，想必你也可以快速的使用 JMH 进行基准测试了，不过上面的诸多注解你可能还有疑惑，下面一一介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类上&lt;/strong&gt;使用了六个注解。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@BenchmarkMode(Mode.AverageTime)
@State(Scope.Thread)
@Fork(1)
@OutputTimeUnit(TimeUnit.MILLISECONDS)
@Warmup(iterations = 3)
@Measurement(iterations = 5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;@BenchmarkMode(Mode.AverageTime)&lt;/strong&gt; 表示统计平均响应时间，不仅可以用在类上，也可用在&lt;strong&gt;测试方法&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;除此之外还可以取值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Throughput：统计单位时间内可以对方法测试多少次。&lt;/li&gt;
&lt;li&gt;SampleTime：统计每个响应时间范围内的响应次数，比如 0-1ms，3次；1-2ms，5次。&lt;/li&gt;
&lt;li&gt;SingleShotTime：跳过预热阶段，直接进行&lt;strong&gt;一次****微基准&lt;/strong&gt;测试。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;@State(Scope.Thread)&lt;/strong&gt;：每个进行基准测试的线程都会独享一个对象示例。&lt;/p&gt;
&lt;p&gt;除此之外还能取值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Benchmark：多线程共享一个示例。&lt;/li&gt;
&lt;li&gt;Group：线程组共享一个示例，在测试方法上使用 @Group 设置线程组。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;@Fork(1)&lt;/strong&gt;：表示开启一个线程进行测试。&lt;/p&gt;
&lt;p&gt;**OutputTimeUnit(TimeUnit.MILLISECONDS)：输出的时间单位，这里写的是毫秒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Warmup(iterations = 3)&lt;/strong&gt;：微基准测试前进行三次预热执行，也可用在&lt;strong&gt;测试方法&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;@Measurement(iterations = 5)&lt;/strong&gt;：进行 5 次微基准测试，也可用在&lt;strong&gt;测试方法&lt;/strong&gt;上。&lt;/p&gt;
&lt;p&gt;在两个测试方法上只使用了一个注解 &lt;strong&gt;@Benchmark&lt;/strong&gt;，这个注解表示这个方法是要进行基准测试的方法，它类似于 Junit 中的 &lt;strong&gt;@Test&lt;/strong&gt; 注解。上面还提到某些注解还可以用到测试方法上，也就是使用了 &lt;strong&gt;@Benchmark&lt;/strong&gt; 的方法之上，如果类上和测试方法同时存在注解，会以&lt;strong&gt;方法上的注解&lt;/strong&gt;为准。&lt;/p&gt;
&lt;p&gt;其实 JMH 也可以把这些参数直接在 main 方法中指定，这时 main 方法中指定的级别最高。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) throws RunnerException {
    Options opt = new OptionsBuilder()
            .include(JmhHello.class.getSimpleName())
            .forks(1)
            .warmupIterations(5)
            .measurementIterations(10)
            .build();
    new Runner(opt).run();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;正确的微基准测试&quot;&gt;正确的微基准测试&lt;/h2&gt;
&lt;p&gt;如果编写的代码本身就存在着诸多问题，那么即使使用正确的测试方法，也不可能得到正确的测试结果。这些测试代码中的问题应该由我们进行主动避免，那么有哪些常见问题呢？下面介绍两种最常见的情况。&lt;/p&gt;
&lt;h3 id=&quot;无用代码消除-（-dead-code-elimination-）&quot;&gt;无用代码消除 （ Dead Code Elimination ）&lt;/h3&gt;
&lt;p&gt;也有网友形象的翻译成&lt;strong&gt;死代码&lt;/strong&gt;，死代码是指那些 JVM 经过检查发现的根本不会使用到的代码。比如下面这个代码片段。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.TimeUnit;
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

/**
 * &amp;lt;p&amp;gt;
 * 测试死代码消除
 *
 * @author niujinpeng
 * @Date 2020/8/21 8:04
 */
@BenchmarkMode(Mode.AverageTime)
@State(Scope.Thread)
@Fork(1)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@Warmup(iterations = 3, time = 3)
@Measurement(iterations = 5, time = 3)
public class JmhDCE {

    @Benchmark
    public double test1() {
        return Math.log(Math.PI);
    }
    @Benchmark
    public void test2() {
        double result = Math.log(Math.PI);
        result = Math.log(result);
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder()
                .include(JmhDCE.class.getSimpleName())
                .build();
        new Runner(opt).run();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个代码片段里里，&lt;code&gt;test1&lt;/code&gt; 方法对圆周率进行对数计算，并返回计算结果；而 &lt;code&gt;test2&lt;/code&gt; 中不仅对圆周率进行对数计算，还对计算的结果再次对数计算，看起来复杂一些，但是因为没有用到计算结果，所以 JVM 会自动消除这段代码， 因为它没有任何意义。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Benchmark     Mode  Cnt   Score    Error  Units
JmhDCE.test1  avgt    5   0.002 ±  0.001  us/op
JmhDCE.test2  avgt    5  ≈ 10⁻⁴           us/op
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果里也可以看到 &lt;code&gt;test&lt;/code&gt; 平均耗时 0.0004 微秒，而 &lt;code&gt;test1&lt;/code&gt; 平均耗时 0.002 微秒。&lt;/p&gt;
&lt;h3 id=&quot;常量折叠-（constant-folding）&quot;&gt;常量折叠 （Constant Folding）&lt;/h3&gt;
&lt;p&gt;在对 Java 源文件编译的过程中，编译器通过语法分析，可以发现某些能直接得到计算结果而不会再次更改的代码，然后会将计算结果记录下来，这样在执行的过程中就不需要再次运算了。比如这段代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import java.util.concurrent.TimeUnit;
import org.openjdk.jmh.annotations.*;
import org.openjdk.jmh.runner.Runner;
import org.openjdk.jmh.runner.RunnerException;
import org.openjdk.jmh.runner.options.Options;
import org.openjdk.jmh.runner.options.OptionsBuilder;

/**
 * &amp;lt;p&amp;gt;
 * 测试常量折叠
 * 
 * @author niujinpeng
 * @Date 2020/8/21 8:23
 */
@BenchmarkMode(Mode.AverageTime)
@State(Scope.Thread)
@Fork(1)
@OutputTimeUnit(TimeUnit.MICROSECONDS)
@Warmup(iterations = 3, time = 3)
@Measurement(iterations = 5, time = 3)
public class JmhConstantFolding {

    final double PI1 = 3.14159265358979323846;
    double PI2 = 3.14159265358979323846;

    @Benchmark
    public double test1() {
        return Math.log(PI1) * Math.log(PI1);
    }

    @Benchmark
    public double test2() {
        return Math.log(PI2) * Math.log(PI2);
    }

    public static void main(String[] args) throws RunnerException {
        Options opt = new OptionsBuilder().include(JmhConstantFolding.class.getSimpleName()).build();
        new Runner(opt).run();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;test&lt;/code&gt;1 中使用 &lt;code&gt;final&lt;/code&gt; 修饰的 PI1 进行对象计算，因为 PI1 不能再次更改，所以 &lt;code&gt;test1&lt;/code&gt; 的计算结果必定是不会更改的，所以 JVM 会进行常量折叠优化，而 &lt;code&gt;test2&lt;/code&gt; 使用的 &lt;code&gt;PI2&lt;/code&gt; 可能会被修改，所以只能每次进行计算。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;Benchmark                 Mode  Cnt  Score    Error  Units
JmhConstantFolding.test1  avgt    5  0.002 ±  0.001  us/op
JmhConstantFolding.test2  avgt    5  0.019 ±  0.001  us/op
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到 &lt;code&gt;test2&lt;/code&gt; 耗时要多的多，达到了 0.019 微秒。&lt;/p&gt;
&lt;p&gt;其实 JVM 做的优化操作远不止上面这些，还有比如常量传播（Constant Propagation）、循环展开（Loop Unwinding）、循环表达式外提（Loop Expression Hoisting）、消除公共子表达式（Common Subexpression Elimination）、本块重排序（Basic Block Reordering）、范围检查消除（Range Check Elimination）等。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;JMH 进行基准测试的使用过程并不复杂，同为 Java 虚拟机团队开发，准确性毋容置疑。但是在进行基准测试时还是要注意自己的代码问题，如果编写的要进行测试的代码本身存在问题，那么测试的结果必定是不准的。掌握了 JMH 基准测试之后，可以尝试测试一些常用的工具或者框架的性能如何，看看哪个工具的性能最好，比如 FastJSON 真的比 GSON 在进行 JSON 转换时更 Fast 吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后的话&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6.2348178137652&quot;&gt;
&lt;p&gt;文章已经收录在 &lt;a href=&quot;https://github.com/niumoo/JavaNotes&quot;&gt;Github.com/niumoo/JavaNotes&lt;/a&gt; ，欢迎Star和指教。更有一线大厂面试点，Java程序员需要掌握的核心知识等文章，也整理了很多我的文字，欢迎 &lt;strong&gt;Star&lt;/strong&gt; 和完善，希望我们一起变得优秀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文章有帮助可以点个「&lt;strong&gt;赞&lt;/strong&gt;」或「&lt;strong&gt;分享&lt;/strong&gt;」，都是支持，我都喜欢！&lt;br/&gt;文章每周持续更新，要实时关注我更新的文章以及分享的干货，可以关注「 &lt;strong&gt;未读代码&lt;/strong&gt; 」公众号或者&lt;a href=&quot;https://www.wdbyte.com/&quot;&gt;我的博客&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/niumoo/cdn-assets@439f6a5f6bd130e2aec56f3527656d6edb487b91/webinfo/weixin-public.jpg&quot; alt=&quot;公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Aug 2020 00:48:00 +0000</pubDate>
<dc:creator>未读代码</dc:creator>
<og:description>Java 性能测试难题 现在的 JVM 已经越来越为智能，它可以在编译阶段、加载阶段、运行阶段对代码进行优化。比如你写了一段不怎么聪明的代码，到了 JVM 这里，它发现几处可以优化的地方，就顺手帮你优</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niumoo/p/13557754.html</dc:identifier>
</item>
<item>
<title>Http请求-okhttp3基本用法 - 谁主沉浮oo7</title>
<link>http://www.cnblogs.com/feifuzeng/p/13554288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feifuzeng/p/13554288.html</guid>
<description>&lt;p&gt;HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持HTTP/2，允许所有同一个主机地址的请求共享同一个socket连接&lt;/li&gt;
&lt;li&gt;连接池减少请求延时&lt;/li&gt;
&lt;li&gt;透明的GZIP压缩减少响应数据的大小&lt;/li&gt;
&lt;li&gt;缓存响应内容，避免一些完全重复的请求&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;源码：&lt;a href=&quot;https://github.com/square/okhttp&quot;&gt;https://github.com/square/okhttp&lt;/a&gt;&lt;br/&gt;说明：OkHttp支持Android 2.3及以上版本Android平台,对于Java, JDK1.7及以上。&lt;br/&gt;当网络出现问题的时候OkHttp依然坚守自己的职责，它会自动恢复一般的连接问题，如果你的服务有多个IP地址，当第一个IP请求失败时，OkHttp会交替尝试你配置的其他IP，OkHttp使用现代TLS技术(SNI, ALPN)初始化新的连接，当握手失败时会回退到TLS 1.0。&lt;/p&gt;

&lt;p&gt;引入maven依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;com.squareup.okhttp3&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;okhttp&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;4.0.0-RC1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;请求方法&quot;&gt;请求方法&lt;/h2&gt;
&lt;h3 id=&quot;同步请求&quot;&gt;同步请求&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;就是执行请求的操作是阻塞式，直到 HTTP 响应返回。它对应 OKHTTP 中的 execute 方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;get请求&quot;&gt;GET请求&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 同步get方式请求
     *
     * @param url
     * @return
     * @throws IOException
     */
    public static String doGet(String url) throws IOException {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                .url(url)
                .build();
        try (Response response = client.newCall(request).execute()) {
            if (response.isSuccessful()) {
                return response.body().string();
            } else {
                throw new IOException(&quot;Unexpected code &quot; + response);
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;post请求&quot;&gt;POST请求&lt;/h4&gt;
&lt;h4 id=&quot;json提交参数&quot;&gt;Json提交参数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
     * 同步post方式请求-json提交参数
     *
     * @param url
     * @param json
     * @return
     * @throws IOException
     */
    public static String doPost(String url, final String json) throws IOException {
        OkHttpClient client = new OkHttpClient();
        RequestBody body = RequestBody.create(JSON, json);
        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();
        try (Response response = client.newCall(request).execute()) {
            if (response.isSuccessful()) {
                return response.body().string();
            } else {
                throw new IOException(&quot;Unexpected code &quot; + response);
            }
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;form表单提交参数&quot;&gt;form表单提交参数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 同步post方式请求-form表单提交参数
     *
     * @param url
     * @param paramsMap
     * @return
     * @throws IOException
     */
    public static String doPost(String url, Map&amp;lt;String, String&amp;gt; paramsMap) throws IOException {
        OkHttpClient client = new OkHttpClient();
        FormBody.Builder builder = new FormBody.Builder();
        for (String key : paramsMap.keySet()) {
            builder.add(key, paramsMap.get(key));
        }
        RequestBody formBody = builder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(formBody)
                .build();
        try (Response response = client.newCall(request).execute()) {
            if (response.isSuccessful()) {
                return response.body().string();
            } else {
                throw new IOException(&quot;Unexpected code &quot; + response);
            }
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;异步请求&quot;&gt;异步请求&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;就是类似于非阻塞式的请求，它的执行结果一般都是通过接口回调的方式告知调用者。它对应 OKHTTP 中的 enqueue 方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是异步请求，所以调用enqueue则无需再开启子线程，enqueue方法会自动将网络请求部分放入子线程中执行。enqueue回调方法onResponse与onFailure都执行在子线程中。&lt;br/&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;回调接口的onFailure方法和onResponse执行在子线程。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;Response.code是http响应行中的code，如果访问成功则返回200.这个不是服务器设置的，而是http协议中自带的。res中的code才是服务器设置的。注意二者的区别。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;response.body().string()本质是输入流的读操作，所以它还是网络请求的一部分，所以这行代码必须放在子线程。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;response.body().string()只能调用一次，在第一次时有返回值，第二次再调用时将会返回null。原因是：response.body().string()的本质是输入流的读操作，必须有服务器的输出流的写操作时客户端的读操作才能得到数据。而服务器的写操作只执行一次，所以客户端的读操作也只能执行一次，第二次将返回null。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;再次强调，response.body().string()方法必须放在子线程中。当执行这行代码得到结果后，再跳转到UI线程修改UI。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;异步请求自定义回调函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
     * okhttp 异步调用回调函数
     */
    static class OkHttpCallback implements Callback {
        @Override
        public void onFailure(@NotNull Call call, @NotNull IOException e) {
            log.error(e);
        }

        @Override
        public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
            if (response.isSuccessful()) {
                log.info(&quot;Successful data acquisition . . . &quot;);
                log.info(&quot;response.code()==&quot; + response.code());
                log.info(&quot;response.body().string()==&quot; + response.body().string());
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;get请求-2&quot;&gt;GET请求&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 异步get方式请求
     *
     * @param url
     * @return
     * @throws IOException
     */
    public static void doSyncGet(String url) {
        OkHttpClient okHttpClient = new OkHttpClient();
        final Request request = new Request.Builder()
                .url(url)
                .get()
                .build();
        Call call = okHttpClient.newCall(request);
        call.enqueue(new OkHttpCallback());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;post请求-2&quot;&gt;POST请求&lt;/h4&gt;
&lt;h4 id=&quot;json提交参数-2&quot;&gt;Json提交参数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    /**
     * 异步post方式请求-json提交参数
     *
     * @param url
     * @param json
     * @return
     * @throws IOException
     */
    public static void doSyncPost(String url, final String json) {
        OkHttpClient client = new OkHttpClient();
        RequestBody body = RequestBody.create(JSON, json);
        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();
        client.newCall(request).enqueue(new OkHttpCallback());

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;form表单提交参数-2&quot;&gt;form表单提交参数&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; /**
     * 异步post方式请求-form表单提交参数
     *
     * @param url
     * @param paramsMap
     * @return
     * @throws IOException
     */
    public static void doSyncPost(String url, Map&amp;lt;String, String&amp;gt; paramsMap) {
        OkHttpClient client = new OkHttpClient();
        FormBody.Builder builder = new FormBody.Builder();
        for (String key : paramsMap.keySet()) {
            builder.add(key, paramsMap.get(key));
        }
        RequestBody formBody = builder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(formBody)
                .build();
        client.newCall(request).enqueue(new OkHttpCallback());

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ohaotian.feifz.style.study.utils;

import lombok.extern.log4j.Log4j2;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.FormBody;
import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import org.jetbrains.annotations.NotNull;

import java.io.IOException;
import java.util.Map;

/**
 * @author feifz
 * @version 1.0.0
 * @Description http工具类，基于okhttp3
 * @createTime 2019年06月06日 09:30:00
 */
@Log4j2
public class HttpUtil {

    public static final MediaType JSON = MediaType.get(&quot;application/json; charset=utf-8&quot;);


    /**
     * 同步get方式请求
     *
     * @param url
     * @return
     * @throws IOException
     */
    public static String doGet(String url) throws IOException {
        OkHttpClient client = new OkHttpClient();
        Request request = new Request.Builder()
                .url(url)
                .build();
        try (Response response = client.newCall(request).execute()) {
            if (response.isSuccessful()) {
                return response.body().string();
            } else {
                throw new IOException(&quot;Unexpected code &quot; + response);
            }
        }
    }

    /**
     * 异步get方式请求
     *
     * @param url
     * @return
     * @throws IOException
     */
    public static void doSyncGet(String url) {
        OkHttpClient okHttpClient = new OkHttpClient();
        final Request request = new Request.Builder()
                .url(url)
                .get()
                .build();
        Call call = okHttpClient.newCall(request);
        call.enqueue(new OkHttpCallback());
    }

    /**
     * 同步post方式请求-json提交参数
     *
     * @param url
     * @param json
     * @return
     * @throws IOException
     */
    public static String doPost(String url, final String json) throws IOException {
        OkHttpClient client = new OkHttpClient();
        RequestBody body = RequestBody.create(JSON, json);
        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();
        try (Response response = client.newCall(request).execute()) {
            if (response.isSuccessful()) {
                return response.body().string();
            } else {
                throw new IOException(&quot;Unexpected code &quot; + response);
            }
        }

    }

    /**
     * 异步post方式请求-json提交参数
     *
     * @param url
     * @param json
     * @return
     * @throws IOException
     */
    public static void doSyncPost(String url, final String json) {
        OkHttpClient client = new OkHttpClient();
        RequestBody body = RequestBody.create(JSON, json);
        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();
        client.newCall(request).enqueue(new OkHttpCallback());

    }

    /**
     * 同步post方式请求-form表单提交参数
     *
     * @param url
     * @param paramsMap
     * @return
     * @throws IOException
     */
    public static String doPost(String url, Map&amp;lt;String, String&amp;gt; paramsMap) throws IOException {
        OkHttpClient client = new OkHttpClient();
        FormBody.Builder builder = new FormBody.Builder();
        for (String key : paramsMap.keySet()) {
            builder.add(key, paramsMap.get(key));
        }
        RequestBody formBody = builder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(formBody)
                .build();
        try (Response response = client.newCall(request).execute()) {
            if (response.isSuccessful()) {
                return response.body().string();
            } else {
                throw new IOException(&quot;Unexpected code &quot; + response);
            }
        }

    }

    /**
     * 异步post方式请求-form表单提交参数
     *
     * @param url
     * @param paramsMap
     * @return
     * @throws IOException
     */
    public static void doSyncPost(String url, Map&amp;lt;String, String&amp;gt; paramsMap) {
        OkHttpClient client = new OkHttpClient();
        FormBody.Builder builder = new FormBody.Builder();
        for (String key : paramsMap.keySet()) {
            builder.add(key, paramsMap.get(key));
        }
        RequestBody formBody = builder.build();
        Request request = new Request.Builder()
                .url(url)
                .post(formBody)
                .build();
        client.newCall(request).enqueue(new OkHttpCallback());

    }

    /**
     * okhttp 异步调用回调函数
     */
    static class OkHttpCallback implements Callback {
        @Override
        public void onFailure(@NotNull Call call, @NotNull IOException e) {
            log.error(e);
        }

        @Override
        public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
            if (response.isSuccessful()) {
                log.info(&quot;Successful data acquisition . . . &quot;);
                log.info(&quot;response.code()==&quot; + response.code());
                log.info(&quot;response.body().string()==&quot; + response.body().string());
            }
        }
    }


}


&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;欢迎关注微信公众号『码仔zonE』，专注于分享Java、云计算相关内容，包括SpringBoot、SpringCloud、微服务、Docker、Kubernetes、Python等领域相关技术干货，期待与您相遇！&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/908629/202008/908629-20200824100239333-1750093094.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Aug 2020 00:48:00 +0000</pubDate>
<dc:creator>谁主沉浮oo7</dc:creator>
<og:description>简介 HTTP是现代应用常用的一种交换数据和媒体的网络方式，高效地使用HTTP能让资源加载更快，节省带宽。OkHttp是一个高效的HTTP客户端，它有以下默认特性： 支持HTTP/2，允许所有同一个主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feifuzeng/p/13554288.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.34：亚马逊、微软开源项目带你学硬核技术 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13557070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13557070.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230332585-1697508771.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：站在巨人的肩膀上才能看得更远，本周上榜的 computervision-recipes 便是典型代表，这个由微软开源的计算机视觉最佳实践项目，多次上 GitHub Trending，它本身并非是一个从零开始的项目它从现有的最先进的库中提取程序，可谓是计算机视觉的集大成者，而亚马逊则更直接，以 MLU——机器学习大学为名在 aws-machine-learning-university-accelerated-nlp 中收录了大量的自然语言处理资源，既然前人种树，我们这些“后辈”莫辜负了这一份&lt;del&gt;凉&lt;/del&gt; 暖意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周特推&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 计算机视觉最佳实践：computervision-recipes&lt;/li&gt;
&lt;li&gt;1.2 东半球最酷的学习项目：hello-algorithm&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;GitHub Trending 周榜&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 前端代码自动迁移：ts-migrate&lt;/li&gt;
&lt;li&gt;2.2 万物皆可 RSS：RSSHub&lt;/li&gt;
&lt;li&gt;2.3 “人肉”工具：sherlock&lt;/li&gt;
&lt;li&gt;2.4 爬虫工具：InfoSpider&lt;/li&gt;
&lt;li&gt;2.5 日历小插件：fullcalendar&lt;/li&gt;
&lt;li&gt;2.6 机器学习大学：aws-machine-learning-university-accelerated-nlp&lt;/li&gt;
&lt;li&gt;2.7 视频下载器：annie&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Emoji Time&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-本周特推&quot;&gt;1. 本周特推&lt;/h2&gt;
&lt;h3 id=&quot;11-计算机视觉最佳实践：computervision-recipes&quot;&gt;1.1 计算机视觉最佳实践：computervision-recipes&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1540+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;computervision-recipes 是微软开源的计算机视觉最佳实践，它利用最先进的计算机视觉算法、神经系统搭建了一套全面的计算机视觉工具和代码示例，如果你想了解计算机视觉，不妨站在这个“巨人”的肩膀上学习图像加载、优化和评估模型以及上云的相关内容。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/microsoft/computervision-recipes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230345008-1652582319.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-东半球最酷的学习项目：hello-algorithm&quot;&gt;1.2 东半球最酷的学习项目：hello-algorithm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：3900+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;hello-algorithm 这个和 HelloGitHub 同构异名的项目是一个号称“东半球最酷的学习项目”，包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;项目作者小浩写的三十万字图解算法题典&lt;/li&gt;
&lt;li&gt;100 张各语言思维导图和 1000 本编程电子&lt;/li&gt;
&lt;li&gt;100 篇大厂面经&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;可以算是比较全面的计算机资料整合项目了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/geekxh/hello-algorithm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230354200-1118407397.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-github-trending-周榜&quot;&gt;2. GitHub Trending 周榜&lt;/h2&gt;
&lt;h3 id=&quot;21-前端代码自动迁移：ts-migrate&quot;&gt;2.1 前端代码自动迁移：ts-migrate&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; ts-migrate 是一个可以将 JavaScript 代码快速转为 TypeScript 代码的工具。它接受一个 JavaScript 或部分 TypeScript 项目，并给出一个编译的 TypeScript 项目。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/airbnb/ts-migrate&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230401460-566855034.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本周 star 增长数：700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RSS 是一种小鱼干很喜欢的内容形式，而 RSSHub 是国人开源的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/DIYgod/RSSHub&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230408881-365106892.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-人肉工具：sherlock&quot;&gt;2.3 “人肉”工具：sherlock&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;sherlock 是一个可通过社交网络上的用户名跨平台搜寻社交平台帐户的工具，一旦你安装了 sherlock 之后你可以通过浏览器直接使用它。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/sherlock-project/sherlock&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230414981-33186099.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-爬虫工具：infospider&quot;&gt;2.4 爬虫工具：InfoSpider&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：600+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; InfoSpider 是一个集众多数据源于一身的爬虫工具箱，旨在安全快捷地帮助用户拿回自己的数据，工具代码开源，流程透明。支持数据源包括 GitHub、QQ 邮箱、网易邮箱、阿里邮箱、新浪邮箱、Hotmail 邮箱、Outlook 邮箱、京东、淘宝、支付宝、中国移动、中国联通、中国电信、知乎、哔哩哔哩、网易云音乐、QQ 好友、QQ 群、生成朋友圈相册、浏览器浏览历史、12306、博客园、CSDN 博客、开源中国博客、简书。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/kangvcar/InfoSpider&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230421541-372849563.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;25-日历小插件：fullcalendar&quot;&gt;2.5 日历小插件：fullcalendar&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：750+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fullcalendar 是一款用来管理日程安排、工作计划的日历工具，它提供了丰富的属性设置和方法调用，开发者可以根据提供的 API 快速完成一个日历日程的开发。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/fullcalendar/fullcalendar&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230427855-1821566570.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-机器学习大学：aws-machine-learning-university-accelerated-nlp&quot;&gt;2.6 机器学习大学：aws-machine-learning-university-accelerated-nlp&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：750+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; aws-machine-learning-university-accelerated-nlp 收录了机器学习大学（MLU）加速自然语言处理课程的幻灯片、笔记本和数据集。本课程旨在帮助你开始学习自然语言处理（NLP），学习广泛使用的技术并将其应用于实际问题。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/aws-samples/aws-machine-learning-university-accelerated-nlp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230433732-2052880046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;27-视频下载器：annie&quot;&gt;2.7 视频下载器：annie&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;annie 一款用 Go 编写的快速，简单，干净的下载器，可下载视频、图片、播放列表等等，支持 MacOS、Windows、Linux 等操作系统，无压力下载抖音、B 站、优酷、油管等视频。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/iawia002/annie&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;3-ttime&quot;&gt;3. TTime&lt;/h2&gt;
&lt;p&gt;Talk Time (&lt;sup&gt;o&lt;/sup&gt;)/ 来说说 #说到大厂开源，你第一个想到的项目#是什么吧 🌚 &lt;code&gt;React&lt;/code&gt; 算不算是大厂开源项呢？&lt;/p&gt;
&lt;h2 id=&quot;4-推荐阅读&quot;&gt;4. 推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 34 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub&quot;&gt;HelloGitHub&lt;/a&gt; issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200824230442707-1043516024.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Aug 2020 00:33:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub-小鱼干 摘要：站在巨人的肩膀上才能看得更远，本周上榜的 computervision-recipes 便是典型代表，这个由微软开源的计算机视觉最佳实践项目，多次上 Git</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13557070.html</dc:identifier>
</item>
<item>
<title>七夕也要学起来，哈希哈希哈希！ - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/13557670.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/13557670.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072509837-1766043783.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;4.0625&quot;&gt;
&lt;p&gt;本文收录于专辑：&lt;a href=&quot;http://dwz.win/HjK&quot;&gt;http://dwz.win/HjK&lt;/a&gt;，点击解锁更多数据结构与算法的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是彤哥。&lt;/p&gt;
&lt;p&gt;上一节，我们一起学习了，在Java中如何构建高性能队列，里面牵涉到很多底层的知识，不知道你有Get到多少呢？！&lt;/p&gt;
&lt;p&gt;本节，我想跟着大家一起重新学习下关于哈希的一切——哈希、哈希函数、哈希表。&lt;/p&gt;
&lt;p&gt;这三者有什么样的爱恨情仇？&lt;/p&gt;
&lt;p&gt;为什么Object类中需要有一个hashCode()方法？它跟equals()方法有什么关系？&lt;/p&gt;
&lt;p&gt;如何编写一个高性能的哈希表？&lt;/p&gt;
&lt;p&gt;Java中的HashMap中的红黑树可以使用其它数据结构替换吗？&lt;/p&gt;

&lt;p&gt;Hash，是指把任意长度的输入通过一定的算法变成&lt;strong&gt;固定长度的输出&lt;/strong&gt;的过程，这个输出称作Hash值，或者Hash码，这个算法叫做Hash算法，或者Hash函数，这个过程我们一般就称作Hash，或者计算Hash，Hash翻译为中文有哈希、散列、杂凑等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072510315-622554911.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然是固定长度的输出，那就意味着输入是无限多的，输出是有限的，必然会出现不同的输入可能会得到相同的输出的情况，所以，Hash算法一般来说也是不可逆的。&lt;/p&gt;
&lt;p&gt;那么，Hash算法有哪些用途呢？&lt;/p&gt;

&lt;p&gt;哈希算法，是一种广义的算法，或者说是一种思想，它没有一个固定的公式，只要满足上面定义的算法，都可以称作Hash算法。&lt;/p&gt;
&lt;p&gt;通常来说，它具有以下用途：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加密密码，比如，使用MD5+盐的方式来加密密码；&lt;/li&gt;
&lt;li&gt;快速查询，比如，哈希表的使用，通过哈希表能够快速查询元素；&lt;/li&gt;
&lt;li&gt;数字签名，比如，系统间调用加上签名，可以防止篡改数据；&lt;/li&gt;
&lt;li&gt;文件检验，比如，下载腾讯游戏的时候通常都有有一个MD5值，安装包下载下来之后计算出来一个MD5值与官方的MD5值进行对比，就可知道下载过程中有没有文件损坏，有没有被篡改等；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，说起Hash算法，或者Hash函数，在Java中，所有对象的父类Object都有一个Hash函数，即hashCode()方法，为什么Object类中需要定义这么一个方法呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;严格来说，Hash算法和Hash函数还是有点区别的，相信你能根据语境进行区分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们来看看JDK源码的注释怎么说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072510847-97453556.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请看红框的部分，翻译一下大致为：为这个对象返回一个Hash值，它是为了更好地支持哈希表而存在的，比如HashMap。简单点说，这个方法就是给HashMap等哈希表使用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 默认返回的是对象的内部地址
public native int hashCode();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，我们不得不提起Object类中的另一个方法——equals()。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 默认是直接比较两个对象的地址是否相等
public boolean equals(Object obj) {
    return (this == obj);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hashCode()和equals又有怎样的纠缠呢？&lt;/p&gt;
&lt;p&gt;通常来说，hashCode()可以看作是一种弱比较，回归Hash的本质，将不同的输入映射到固定长度的输出，那么，就会出现以下几种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入相同，输出必然相同；&lt;/li&gt;
&lt;li&gt;输入不同，输出可能相同，也可能不同；&lt;/li&gt;
&lt;li&gt;输出相同，输入可能相同，也可能不同；&lt;/li&gt;
&lt;li&gt;输出不同，输入必然不同；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;而equals()是严格比较两个对象是否相等的方法，所以，如果两个对象equals()为true，那么，它们的hashCode()一定要相等，如果不相等会怎样呢？&lt;/p&gt;
&lt;p&gt;如果equals()返回true，而hashCode()不相等，那么，试想将这两个对象作为HashMap的key，它们很大可能会定位到HashMap不同的槽中，此时就会出现一个HashMap中插入了两个相等的对象，这是不允许的，这也是为什么重写了equals()方法一定要重写hashCode()方法的原因。&lt;/p&gt;
&lt;p&gt;比如，String这个类，我们都知道它的equals()方法是比较两个字符串的内容是否相等，而不是两个字符串的地址，下面是它的equals()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，对于下面这两个字符串对象，使用equals()比较它们是相等的，而它们的内存地址并不相同：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String a = new String(&quot;123&quot;);
String b = new String(&quot;123&quot;);
System.out.println(a.equals(b)); // true
System.out.println(a == b); // false
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，如果不重写hashCode()方法，那么，a和b将返回不同的hash码，对于我们常常使用String作为HashMap的key将造成巨大的干扰，所以，String重写的hashCode()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int hashCode() {
    int h = hash;
    if (h == 0 &amp;amp;&amp;amp; value.length &amp;gt; 0) {
        char val[] = value;

        for (int i = 0; i &amp;lt; value.length; i++) {
            h = 31 * h + val[i];
        }
        hash = h;
    }
    return h;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个算法也很简单，用公式来表示为：s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]。&lt;/p&gt;
&lt;p&gt;好了，既然这里屡次提到哈希表，那我们就来看看哈希表是如何一步步进化的。&lt;/p&gt;

&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;
&lt;p&gt;讲哈希表之前，我们先来看看数据结构的鼻祖——数组。&lt;/p&gt;
&lt;p&gt;数组比较简单，我就不多说了，大家都会都懂，见下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072511275-602576671.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数组的下标一般从0开始，依次往后存储元素，查找指定元素也是一样，只能从头（或从尾）依次查找元素。&lt;/p&gt;
&lt;p&gt;比如，要查找4这个元素，从头开始查找的话需要查找3次。&lt;/p&gt;
&lt;h2 id=&quot;早期的哈希表&quot;&gt;早期的哈希表&lt;/h2&gt;
&lt;p&gt;上面讲了数组的缺点，查找某个元素只能从头或者从尾依次查找元素，直到匹配为止，它的均衡时间复杂是O(n)。&lt;/p&gt;
&lt;p&gt;那么，利用数组有没有什么方法可以快速的查找元素呢？&lt;/p&gt;
&lt;p&gt;聪明的程序员哥哥们想到一种方法，通过哈希函数计算元素的值，用这个值确定元素在数组中的位置，这样时间复杂度就能缩短到O(1)了。&lt;/p&gt;
&lt;p&gt;比如，有5个元素分别为3、5、4、1，把它们放入到数组之前先通过哈希函数计算位置，精确放置，而不是像简单数组那样依次放置元素（基于索引而不是元素值来查找位置）。&lt;/p&gt;
&lt;p&gt;假如，这里申请的数组长度为8，我们可以造这么一个哈希函数为hash(x) = x % 8，那么最后的元素就变成了下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072511600-46408959.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候我们再查找4这个元素，先算一下它的hash值为hash(4) = 4 % 8 = 4，所以直接返回4号位置的元素就可以了。&lt;/p&gt;
&lt;h2 id=&quot;进化的哈希表&quot;&gt;进化的哈希表&lt;/h2&gt;
&lt;p&gt;事情看着挺完美，但是，来了一个元素13，要插入的哈希表中，算了一下它的hash值为hash(13) = 13 % 8 = 5，纳尼，它计算的位置也是5，可是5号已经被人先一步占领了，怎么办呢？&lt;/p&gt;
&lt;p&gt;这就是&lt;strong&gt;哈希冲突&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;为什么会出现哈希冲突呢？&quot;&gt;为什么会出现哈希冲突呢？&lt;/h3&gt;
&lt;p&gt;因为我们申请的数组是有限长度的，把无限的数字映射到有限的数组上早晚会出现冲突，即多个元素映射到同一个位置上。&lt;/p&gt;
&lt;p&gt;好吧，既然出现了哈希冲突，那么我们就要解决它，必须干！&lt;/p&gt;
&lt;p&gt;How to？&lt;/p&gt;
&lt;h3 id=&quot;线性探测法&quot;&gt;线性探测法&lt;/h3&gt;
&lt;p&gt;既然5号位置已经有主了，那我元素13认怂，我往后挪一位，我到6号位置去，这就是线性探测法，当出现冲突的时候依次往后挪直到找到空位置为止。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072511947-496591055.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然鹅，又来了个新元素12，算得其hash值为hash(12) = 12 % 8 = 4，What？按照这种方式，要往后移3次到7号位置才有空位置，这就导致了插入元素的效率很低，查找也是一样的道理，先定位的4号位置，发现不是我要找的人，再接着往后移，直到找到7号位置为止。&lt;/p&gt;
&lt;h3 id=&quot;二次探测法&quot;&gt;二次探测法&lt;/h3&gt;
&lt;p&gt;使用线性探测法有个很大的弊端，冲突的元素往往会堆积在一起，比如，12号放到7号位置，再来个14号一样冲突，接着往后再数组结尾了，再从头开始放到0号位置，你会发现冲突的元素有聚集现象，这就很不利于查找了，同样不利于插入新的元素。&lt;/p&gt;
&lt;p&gt;这时候又有聪明的程序员哥哥提出了新的想法——二次探测法，当出现冲突时，我不是往后一位一位这样来找空位置，而是使用原来的hash值加上i的二次方来寻找，i依次从1，2，3...这样，直到找到空位置为止。&lt;/p&gt;
&lt;p&gt;还是以上面的为例，插入12号元素，过程是这样的，本文来源于公主号彤哥读源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072512341-325567299.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就能很快地找到空位置放置新元素，而且不会出现冲突元素堆积的现象。&lt;/p&gt;
&lt;p&gt;然鹅，又来了新元素20，你瞅瞅放哪？&lt;/p&gt;
&lt;p&gt;发现放哪都放不进去了。&lt;/p&gt;
&lt;p&gt;研究表明，使用二次探测法的哈希表，当放置的元素超过一半时，就会出现新元素找不到位置的情况。&lt;/p&gt;
&lt;p&gt;所以又引出一个新的概念——扩容。&lt;/p&gt;
&lt;h3 id=&quot;什么是扩容？&quot;&gt;什么是扩容？&lt;/h3&gt;
&lt;p&gt;已放置元素达到总容量的x%时，就需要扩容了，这个x%时又叫作&lt;strong&gt;扩容因子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很显然，扩容因子越大越好，表明哈希表的空间利用率越高。&lt;/p&gt;
&lt;p&gt;所以，很遗憾，二次探测法无法满足我们的目标，扩容因子太小了，只有0.5，一半的空间都是浪费的。&lt;/p&gt;
&lt;p&gt;这时候又到了程序员哥哥们发挥他们聪明特性的时候了，经过996头脑风暴后，又想出了一种新的哈希表实现方式——链表法。&lt;/p&gt;
&lt;h2 id=&quot;链表法&quot;&gt;链表法&lt;/h2&gt;
&lt;p&gt;不就是解决冲突嘛！出现冲突我就不往数组中去放了，我用一个链表把同一个数组下标位置的元素连接起来，这样不就可以充分利用空间了嘛，啊哈哈哈哈~~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072512656-1692749405.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嘿嘿嘿嘿，完美△△。&lt;/p&gt;
&lt;p&gt;真的完美嘛，我是一名黑客，我一直往里面放*%8=4的元素，然后你就会发现几乎所有的元素都跑到同一个链表中去了，呵呵，最后的结果就是你的哈希表退化成了链表，查询插入元素的效率都变成了O(n)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072513012-1448295764.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时，当然有办法，扩容因子干啥滴？&lt;/p&gt;
&lt;p&gt;比如扩容因子设置为1，当元素个数达到8个时，扩容成两倍，一半的元素还在4号位置，一半的元素去到了12号位置，能缓解哈希表的压力。&lt;/p&gt;
&lt;p&gt;然鹅，依旧不是很完美，也只是从一个链表变成两个链表，本文来源于公主号彤哥读源码。&lt;/p&gt;
&lt;p&gt;聪明的程序员哥哥们这次开启了一次长大9127的头脑风暴，终于搞出了一种新的结构——链表树法。&lt;/p&gt;
&lt;h2 id=&quot;链表树法&quot;&gt;链表树法&lt;/h2&gt;
&lt;p&gt;虽然上面的扩容在元素个数比较少的时候能解决一部分问题，整体的查找插入效率也不会太低，因为元素个数少嘛。&lt;/p&gt;
&lt;p&gt;但是，黑客还在攻击，元素个数还在持续增加，当增加到一定程度的时候，总会导致查找插入效率特别低。&lt;/p&gt;
&lt;p&gt;所以，换个思路，既然链表的效率低，我把它升级一下，当链表长的时候升级成红黑树怎么样？&lt;/p&gt;
&lt;p&gt;嗯，我看行，说干就干。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072513361-985213595.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，不错不错，妈妈再也不怕我遭到黑客攻击了，红黑树的查询效率为O(log n)，比链表的O(n)要高不少。&lt;/p&gt;
&lt;p&gt;所以，到这就结束了吗？&lt;/p&gt;
&lt;p&gt;你想多了，每次扩容还是要移动一半的元素好么，一颗树分化成两颗树，这样真的好么好么好么？&lt;/p&gt;
&lt;p&gt;程序员哥哥们太难了，这次经过了12127的头脑风暴，终于想出个新玩意——一致性Hash。&lt;/p&gt;
&lt;h2 id=&quot;一致性hash&quot;&gt;一致性Hash&lt;/h2&gt;
&lt;p&gt;一致性Hash更多地是运用在分布式系统中，比如说Redis集群部署了四个节点，我们把所有的hash值定义为0~2^32个，每个节点上放置四分之一的元素。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此处只为举例，实际Redis集群的原理是这样的，具体数值不是这样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;此时，假设需要给Redis增加一个节点，比如node5，放在node3和node4中间，这样只需要把node3到node4中间的元素从node4移动到node5上面就行了，其它的元素保持不变。&lt;/p&gt;
&lt;p&gt;这样，就增加了扩容的速度，而且影响的元素比较少，大部分请求几乎无感知。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200825072513846-364600782.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，到这里关于哈希表的进化历史就讲到这里了，你有没有Get到呢？&lt;/p&gt;

&lt;p&gt;本节，我们一起重新学习了关于哈希、哈希函数、哈希表相关的知识，在Java中，HashMap的终极形态是以数组+链表+红黑树的形式呈现的。&lt;/p&gt;
&lt;p&gt;据说，这个红黑树还可以换成其它的数据结构，比如跳表，你造吗？&lt;/p&gt;
&lt;p&gt;下一节，我们就来聊聊&lt;strong&gt;跳表&lt;/strong&gt;这个数据结构，并使用它来改写HashMap，欲获取最新推广，快点来关注我吧！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注公号主“彤哥读源码”，解锁更多源码、基础、架构知识。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 24 Aug 2020 23:25:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>前言 本文收录于专辑：http://dwz.win/HjK，点击解锁更多数据结构与算法的知识。 你好，我是彤哥。 上一节，我们一起学习了，在Java中如何构建高性能队列，里面牵涉到很多底层的知识，不知</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/13557670.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】动画序列、共享动画、路由动画 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13557663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13557663.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071144652-1508025987.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;老孟导读：此篇文章是 Flutter 动画系列文章第四篇，本文介绍动画序列、共享动画、路由动画。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;动画序列&quot;&gt;动画序列&lt;/h2&gt;
&lt;p&gt;Flutter中组合动画使用&lt;code&gt;Interval&lt;/code&gt;，&lt;code&gt;Interval&lt;/code&gt;继承自&lt;code&gt;Curve&lt;/code&gt;，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Animation _sizeAnimation = Tween(begin: 100.0, end: 300.0).animate(CurvedAnimation(
    parent: _animationController, curve: Interval(0.5, 1.0)));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示&lt;code&gt;_sizeAnimation&lt;/code&gt;动画从0.5（一半）开始到结束，如果动画时长为6秒，&lt;code&gt;_sizeAnimation&lt;/code&gt;则从第3秒开始。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Interval&lt;/code&gt;中&lt;code&gt;begin&lt;/code&gt; 和&lt;code&gt;end&lt;/code&gt;参数值的范围是0.0到1.0。&lt;/p&gt;
&lt;p&gt;下面实现一个先执行颜色变化，在执行大小变化，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class AnimationDemo extends StatefulWidget {
  @override
  State&amp;lt;StatefulWidget&amp;gt; createState() =&amp;gt; _AnimationDemo();
}

class _AnimationDemo extends State&amp;lt;AnimationDemo&amp;gt;
    with SingleTickerProviderStateMixin {
  AnimationController _animationController;
  Animation _colorAnimation;
  Animation _sizeAnimation;

  @override
  void initState() {
    _animationController =
        AnimationController(duration: Duration(seconds: 5), vsync: this)
    ..addListener((){setState(() {
      
    });});

    _colorAnimation = ColorTween(begin: Colors.red, end: Colors.blue).animate(
        CurvedAnimation(
            parent: _animationController, curve: Interval(0.0, 0.5)));

    _sizeAnimation = Tween(begin: 100.0, end: 300.0).animate(CurvedAnimation(
        parent: _animationController, curve: Interval(0.5, 1.0)));

    //开始动画
    _animationController.forward();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: &amp;lt;Widget&amp;gt;[
          Container(
              height: _sizeAnimation.value,
              width: _sizeAnimation.value,
              color: _colorAnimation.value),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071145209-386192354.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们也可以设置同时动画，只需将2个&lt;code&gt;Interval&lt;/code&gt;的值都改为&lt;code&gt;Interval(0.0, 1.0)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;想象下面的场景，一个红色的盒子，动画时长为6秒，前40%的时间大小从100-&amp;gt;200，然后保持200不变20%的时间，最后40%的时间大小从200-&amp;gt;300，这种效果通过TweenSequence实现，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;_animation = TweenSequence([
  TweenSequenceItem(
      tween: Tween(begin: 100.0, end: 200.0)
          .chain(CurveTween(curve: Curves.easeIn)),
      weight: 40),
  TweenSequenceItem(tween: ConstantTween&amp;lt;double&amp;gt;(200.0), weight: 20),
  TweenSequenceItem(tween: Tween(begin: 200.0, end: 300.0), weight: 40),
]).animate(_animationController);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;weight&lt;/code&gt;表示每一个Tween的权重。&lt;/p&gt;
&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071146255-1549193890.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;共享动画&quot;&gt;共享动画&lt;/h2&gt;
&lt;p&gt;Hero是我们常用的过渡动画，当用户点击一张图片，切换到另一个页面时，这个页面也有此图，那么使用Hero组件就在合适不过了，先看下Hero的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071148436-323685068.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面效果实现的列表页面代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class HeroDemo extends StatefulWidget {
  @override
  State&amp;lt;StatefulWidget&amp;gt; createState() =&amp;gt; _HeroDemo();
}

class _HeroDemo extends State&amp;lt;HeroDemo&amp;gt; {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: GridView(
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: 3, crossAxisSpacing: 5, mainAxisSpacing: 3),
        children: List.generate(10, (index) {
          if (index == 6) {
            return InkWell(
              onTap: () {
                Navigator.push(
                    context,
                    new MaterialPageRoute(
                        builder: (context) =&amp;gt; new _Hero1Demo()));
              },
              child: Hero(
                tag: 'hero',
                child: Container(
                  child: Image.asset(
                    'images/bird.png',
                    fit: BoxFit.fitWidth,
                  ),
                ),
              ),
            );
          }
          return Container(
            color: Colors.red,
          );
        }),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个页面代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class _Hero1Demo extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Container(
          alignment: Alignment.topCenter,
          child: Hero(
            tag: 'hero',
            child: Container(
              child: Image.asset(
                'images/bird.png',
              ),
            ),
          )),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2个页面都有Hero控件，且&lt;code&gt;tag&lt;/code&gt;参数一致。&lt;/p&gt;
&lt;h2 id=&quot;路由动画&quot;&gt;路由动画&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;转场&lt;/strong&gt; 就是从当前页面跳转到另一个页面，跳转页面在 Flutter 中通过 Navigator，跳转到新页面如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Navigator.push(context, MaterialPageRoute(builder: (context) {
  return _TwoPage();
}));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回退到前一个页面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Navigator.pop(context);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Flutter 提供了两个转场动画，分别为 &lt;strong&gt;MaterialPageRoute&lt;/strong&gt; 和 &lt;strong&gt;CupertinoPageRoute&lt;/strong&gt;，MaterialPageRoute 根据不同的平台显示不同的效果，Android效果为从下到上，iOS效果为从左到右。CupertinoPageRoute 不分平台，都是从左到右。&lt;/p&gt;
&lt;p&gt;使用 MaterialPageRoute 案例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class NavigationAnimation extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Center(
        child: OutlineButton(
          child: Text('跳转'),
          onPressed: () {
            Navigator.push(context, CupertinoPageRoute(builder: (context) {
              return _TwoPage();
            }));
          },
        ),
      ),
    );
  }
}

class _TwoPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Container(
        color: Colors.blue,
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;iOS效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071149056-1018134331.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要自定义转场动画如何做？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义任何组件都是一样的，如果系统有类似的，直接看源代码是如何实现的，然后按照它的模版自定义组件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回到正题，看 MaterialPageRoute 的继承关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071149446-1782814440.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PageRoute 的继承关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071149597-1296153496.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MaterialPageRoute 和 CupertinoPageRoute 都是继承PageRoute，所以重点是 PageRoute，PageRoute 是一个抽象类，其子类还有一个 PageRouteBuilder，看其名字就知道这是一个可以自定义动画效果，PageRouteBuilder源代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071149835-1955910718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pageBuilder&lt;/code&gt; 表示跳转的页面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;transitionsBuilder&lt;/code&gt; 表示页面的动画效果，默认值代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Widget _defaultTransitionsBuilder(BuildContext context, Animation&amp;lt;double&amp;gt; animation, Animation&amp;lt;double&amp;gt; secondaryAnimation, Widget child) {
  return child;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源代码发现，默认情况下没有动画效果。&lt;/p&gt;
&lt;p&gt;自定义转场动画只需修改&lt;code&gt;transitionsBuilder&lt;/code&gt;即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Navigator.push(
    context,
    PageRouteBuilder(pageBuilder: (
      BuildContext context,
      Animation&amp;lt;double&amp;gt; animation,
      Animation&amp;lt;double&amp;gt; secondaryAnimation,
    ) {
      return _TwoPage();
    }, transitionsBuilder: (BuildContext context,
        Animation&amp;lt;double&amp;gt; animation,
        Animation&amp;lt;double&amp;gt; secondaryAnimation,
        Widget child) {
      return SlideTransition(
        position: Tween(begin: Offset(-1, 0), end: Offset(0, 0))
            .animate(animation),
        child: child,
      );
    }));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071150161-522688008.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将其封装，方便使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class LeftToRightPageRoute extends PageRouteBuilder {
  final Widget newPage;

  LeftToRightPageRoute(this.newPage)
      : super(
          pageBuilder: (
            BuildContext context,
            Animation&amp;lt;double&amp;gt; animation,
            Animation&amp;lt;double&amp;gt; secondaryAnimation,
          ) =&amp;gt;
              newPage,
          transitionsBuilder: (
            BuildContext context,
            Animation&amp;lt;double&amp;gt; animation,
            Animation&amp;lt;double&amp;gt; secondaryAnimation,
            Widget child,
          ) =&amp;gt;
              SlideTransition(
            position: Tween(begin: Offset(-1, 0), end: Offset(0, 0))
                .animate(animation),
            child: child,
          ),
        );
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Navigator.push(context, LeftToRightPageRoute(_TwoPage()));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不仅是这些平移动画，前面所学的旋转、缩放等动画直接替换 SlideTransition 即可。&lt;/p&gt;
&lt;p&gt;上面的动画只对新的页面进行了动画，如果想实现当前页面被新页面从顶部顶出的效果，实现方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class CustomPageRoute extends PageRouteBuilder {
  final Widget currentPage;
  final Widget newPage;

  CustomPageRoute(this.currentPage, this.newPage)
      : super(
          pageBuilder: (
            BuildContext context,
            Animation&amp;lt;double&amp;gt; animation,
            Animation&amp;lt;double&amp;gt; secondaryAnimation,
          ) =&amp;gt;
              currentPage,
          transitionsBuilder: (
            BuildContext context,
            Animation&amp;lt;double&amp;gt; animation,
            Animation&amp;lt;double&amp;gt; secondaryAnimation,
            Widget child,
          ) =&amp;gt;
              Stack(
            children: &amp;lt;Widget&amp;gt;[
              SlideTransition(
                position: new Tween&amp;lt;Offset&amp;gt;(
                  begin: const Offset(0, 0),
                  end: const Offset(0, -1),
                ).animate(animation),
                child: currentPage,
              ),
              SlideTransition(
                position: new Tween&amp;lt;Offset&amp;gt;(
                  begin: const Offset(0, 1),
                  end: Offset(0, 0),
                ).animate(animation),
                child: newPage,
              )
            ],
          ),
        );
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本质就是对两个页面做动画处理，使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Navigator.push(context, CustomPageRoute(this, _TwoPage()));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071150717-1812373299.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了自定义路由动画，在 Flutter 1.17 发布大会上，Flutter 团队还发布了新的 Animations 软件包，该软件包提供了实现新的 Material motion 规范的预构建动画。&lt;/p&gt;
&lt;p&gt;里面提供了一系列动画，部分效果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071151541-599668591.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071152479-1788130857.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详情：&lt;a href=&quot;https://juejin.im/post/6847902223909781511&quot;&gt;https://juejin.im/post/6847902223909781511&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071153666-1076309963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202008/467322-20200825071153890-28326395.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Mon, 24 Aug 2020 23:12:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：此篇文章是 Flutter 动画系列文章第四篇，本文介绍动画序列、共享动画、路由动画。 动画序列 Flutter中组合动画使用Interval，Interval继承自Curve，用法如下：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13557663.html</dc:identifier>
</item>
<item>
<title>完美解决方案-雪花算法ID到前端之后精度丢失问题 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13557662.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13557662.html</guid>
<description>&lt;p&gt;最近公司的一个项目组要把以前的单体应用进行为服务拆分，表的ID主键使用Mybatis plus默认 的雪花算法来生成。&lt;/p&gt;
&lt;p&gt;快下班的时候，小伙伴跑过来找我，：“快给我看看这问题，卡这卡了小半天了！”。连拉带拽，连哄带骗的把我拉到他的电脑前面。这位小伙伴在我看来技术不算是大牛，但经验也很丰富了。他都卡了半天的问题，应该不是小问题，如果我一时半会搞不定，真的是耽误我下班了，所以我很不情愿的在他的位置坐了下来。&lt;/p&gt;
&lt;h2 id=&quot;一、现象是这样的&quot;&gt;一、现象是这样的&lt;/h2&gt;
&lt;p&gt;下面我把异常的现象给大家描述一下，小伙伴建了一张表，表的主键是id BigINT，用来存储雪花算法生成的ID，嗯，这个没有问题！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE user
(
        id BIGINT(20) NOT NULL COMMENT '主键ID',
        #其他字段省略
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Long 类型对应数据库ID数据。嗯，也没有问题，雪花算法生成的就是一串数字，Long类型属于标准答案！&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Data
public class User {
    private Long id;
//其他成员变量省略
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在后端下断点。看到数据响应以JSON响应给前端，正常&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
id：1297873308628307970,
//其他属性省略
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，这条数据返回给前端，前端接收到之后，修改这条数据，后端再次接收回来。奇怪的问题出现了：&lt;strong&gt;后端重新接收回来的id变成了：12978733086283000000，不再是1297873308628307970&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、分析问题&quot;&gt;二、分析问题&lt;/h2&gt;
&lt;p&gt;我的第一感觉是，开发小伙伴把数据给搞混了，张冠李戴了，把XXX的对象ID放到了YYY对象的ID上。所以，就按照代码从前端到后端、从后端到前端调试跟踪了一遍。&lt;/p&gt;
&lt;p&gt;从代码的逻辑角度上没有任何问题。这时，我有点烦躁了，真的是耽误我下班了！但开工没有回头箭，既然坐下来了就得帮他解决，不然以后这队伍怎么带？想到这我又静下心来，开始思考。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1297873308628300000 ---&amp;gt; 1297873308628307970
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个数长得还挺像的，似乎是被四舍五入了。此时脑袋里面冒出一个想法，是精度丢失了么？哪里能导致精度丢失？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务端都是Long类型的id，不可能丢失&lt;/li&gt;
&lt;li&gt;前端是什么类型，JSON字符串转js对象，接收Long类型的是number&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上网查了一下Number精度是16位（雪花ID是19位的），So：JS的Number数据类型导致的精度丢失。问题是找到了！&lt;br/&gt;小伙伴投来敬佩的眼光，5分钟就把这问题发现了。可是发现了有什么用？得解决问题啊！&lt;/p&gt;
&lt;h2 id=&quot;三、解决问题&quot;&gt;三、解决问题&lt;/h2&gt;
&lt;p&gt;开发小伙伴说：那我把所有的数据库表设计，id字段由Long类型改成String类型吧。我问他你有多少张表？他说100多张吧。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;100多张表还有100多个实体类需要改&lt;/li&gt;
&lt;li&gt;还有各种使用到实体类的Service层要改&lt;/li&gt;
&lt;li&gt;Service等改完Controller层要改&lt;/li&gt;
&lt;li&gt;关键的是String和Long都是常用类型，他还不敢批量替换&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;小伙伴拿起电话打算订餐，说今晚的加班是无法避免了。我想了想说：你最好别改，&lt;strong&gt;String做ID查询性能会下降&lt;/strong&gt;，我再想想！后端A到前端B出现精度丢失，要么改前端，要么改后端，要么…… 。“哎哎，你等等先别订餐，后端A到前端B你用的什么做的序列化？” 小伙伴告诉我说使用的是Jackson，这就好办了，Jackson我熟悉啊！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;解决思路：后端的ID(Long) ==&amp;gt; Jackson(Long转String) ==&amp;gt; 前端使用String类型的ID,前端使用js string精度就不会丢失了。&lt;/strong&gt; 那前端再把String类型的19位数字传回服务端的时候，可以用Long接收么？当然可以，这是Spring反序列化参数接收默认支持的行为。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;最终方案就是：&lt;strong&gt;前端用String类型的雪花ID保持精度，后端及数据库继续使用Long(BigINT)类型不影响数据库查询执行效率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;剩下的问题就是：在Spring Boot应用中，使用Jackson进行JSON序列化的时候怎么将Long类型ID转成String响应给前端。方案如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class JacksonConfig {

  @Bean
  @Primary
  @ConditionalOnMissingBean(ObjectMapper.class)
  public ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder)
  {
    ObjectMapper objectMapper = builder.createXmlMapper(false).build();

    // 全局配置序列化返回 JSON 处理
    SimpleModule simpleModule = new SimpleModule();
    //JSON Long ==&amp;gt; String
    simpleModule.addSerializer(Long.class, ToStringSerializer.instance);
    objectMapper.registerModule(simpleModule);
    return objectMapper;
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小伙伴放下电话， 再次投来敬佩眼光。“走吧，一起下班！”我和小伙伴说，小伙伴一路上一直问我你是怎么学习的？我冠冕堂皇的说了一些多想多学多问之类的话。&lt;br/&gt;其实我心里在想：我是一个懒人，但我不能说。能躺着绝不坐着，能自动绝不手动，能打车绝不自己开车。第一次就把事情做对，才是省时省力做好的方法！这么多年的“懒”，决定了我需要去思考更多的“捷径”，思考“捷径”的过程是我不断进阶的诀窍！&lt;br/&gt;&lt;strong&gt;勤奋的人是社会的生产力，而懒人是社会的创造力！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Mon, 24 Aug 2020 23:11:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>最近公司的一个项目组要把以前的单体应用进行为服务拆分，表的ID主键使用Mybatis plus默认 的雪花算法来生成。 快下班的时候，小伙伴跑过来找我，：“快给我看看这问题，卡这卡了小半天了！”。连拉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13557662.html</dc:identifier>
</item>
<item>
<title>数据结构和算法躬行记（1）——链表 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13344157.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13344157.html</guid>
<description>&lt;p&gt;　　链表（Linked List）是不同于数组的另一种数据结构，它的存储单元（即结点或元素）除了包含任意类型的数据之外，还需要包含指向另一个结点的引用，后文会用术语链接表示对结点的引用。&lt;/p&gt;
&lt;p&gt;　　下面会列出链表与数组的具体不同：&lt;/p&gt;
&lt;p&gt;　　（1）数组需要一块连续的内存空间来存储；而链表则恰恰相反，通过指针将零散的内存串联在一起。&lt;/p&gt;
&lt;p&gt;　　（2）数组在插入和删除时，会做数据搬移，其时间复杂度是 O(n)；而链表只需考虑相邻结点的指针变化，因此时间复杂度是 O(1)。&lt;/p&gt;
&lt;p&gt;　　（3）当随机访问第 K 个元素时，数据可根据首地址和索引计算出对应的内存地址，其时间复杂度为 O(1)；而链表则需要让指针依次遍历链接的结点，因此时间复杂度是 O(n)。&lt;/p&gt;
&lt;p&gt;　　本系列中面试例题来源于&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problemset/all/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;LeetCode&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;、《&lt;span&gt;&lt;a href=&quot;https://book.douban.com/subject/27008702/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;剑指Offer&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》等渠道。像下面这样以“面试题”为前缀的题目，其解法大都来源于《剑指Offer》一书。&lt;/p&gt;
&lt;p&gt;　　面试题5 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;替换空格&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。合并数组，从后往前合并，减少数字移动次数。&lt;/p&gt;

&lt;p&gt;　　链表包含三种最常见的链表结构：单链表、双向链表和循环链表。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）单链表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　单链表的结点结构如下所示，其中next是后继指针，可链接下一个结点。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Node {
  constructor(key&lt;/span&gt;=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　而单链表又可以细分为有头结点的单链表和无头结点的单链表，其中头结点不存储任何数据，如下图1所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200720130315179-1666548122.png&quot; width=&quot;500&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图 1&lt;/p&gt;
&lt;p&gt;　　下面以有头结点的&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/GRoYevm&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;单链表为例&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，演示单链表的插入、遍历和删除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class List {
  constructor() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.header = &lt;span&gt;new&lt;/span&gt; Node();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头结点&lt;/span&gt;
&lt;span&gt;  }
  add(node) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header.next) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.header.next =&lt;span&gt; node;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    let current &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (current.next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      current &lt;/span&gt;=&lt;span&gt; current.next;
    }
    current.next &lt;/span&gt;=&lt;span&gt; node;
  }
  traverse() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历&lt;/span&gt;
    let current = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header.next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (current) {
      console.log(current.key);
      current &lt;/span&gt;=&lt;span&gt; current.next;
    }
  }
  del(node) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
    let current = &lt;span&gt;this&lt;/span&gt;.header.next,     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前结点&lt;/span&gt;
      prev = &lt;span&gt;this&lt;/span&gt;.header;               &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前驱结点&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (current !=&lt;span&gt; node) {
      current &lt;/span&gt;=&lt;span&gt; current.next;
      prev &lt;/span&gt;=&lt;span&gt; prev.next;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (current) {
      prev.next &lt;/span&gt;=&lt;span&gt; current.next;
      current.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　尽管删除操作的时间复杂度是 O(1)，但遍历查找是主要的耗时点，复杂度为 O(n)。因为在删除时需要知道前驱结点，而单链表不能直接读取，只能从头开始遍历。&lt;/p&gt;
&lt;p&gt;　　面试题6 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;从尾到头打印链表&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。每经过一个结点，就放到栈中。当遍历完后，从栈顶输出。&lt;/p&gt;
&lt;p&gt;　　面试题18 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;删除链表的结点&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。将结点 j 覆盖结点 i，结点 i 的next指针指向 j 的下一个结点，这样能避免获取结点 i 的前置结点。&lt;/p&gt;
&lt;p&gt;　　面试题52 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;两个链表的第一个公共结点&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。分别把两个链接的结点放入两个栈中，尾结点就是两个栈的顶部，如果相同就接着比较下一个栈顶，直至找到最后一个相同结点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）双向链表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　双向链表顾名思义包含两个方向的指针：前驱和后继，结点结构如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Node {
  constructor(key &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.prev = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.key =&lt;span&gt; key;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.next = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　双向链表比单链表要占更多的内存空间，依托用空间换时间的设计思想，双向链表要比单链表更加的高效。&lt;/p&gt;
&lt;p&gt;　　例如之前的删除，由于已经保存了前驱结点，也就避免了多余的遍历（&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/ExPdMLx&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;）。当希望在某个结点之前插入结点，双向链表的优势也很明显。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class List {
  add(node) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header.next) {
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.header.next =&lt;span&gt; node;
      node.prev &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    let current &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (current.next != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      current &lt;/span&gt;=&lt;span&gt; current.next;
    }
    current.next &lt;/span&gt;=&lt;span&gt; node;
    node.prev &lt;/span&gt;=&lt;span&gt; current;
  }
  del(node) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除&lt;/span&gt;
    let current = &lt;span&gt;this&lt;/span&gt;.header.next;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前结点&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (current !=&lt;span&gt; node) {
      current &lt;/span&gt;=&lt;span&gt; current.next;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (current) {
      current.prev.next &lt;/span&gt;=&lt;span&gt; current.next;
      current.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）循环链表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　循环链表是一种特殊的单链表，它的尾结点的后继结点是头结点，适合处理具有环形结构的问题，例如约瑟夫环。&lt;/p&gt;
&lt;p&gt;　　面试题62 &lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;圆圈中最后剩下的数字&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。用环形链表模拟圆圈，每删除一个数字需要 m 步运算，共有 n 个数字，时间复杂度O(mn)。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）单链表逆序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　从链表的第二个结点开始，把遍历到的结点插入到头结点的后面，直至结束，例如head→1→2→3变为 head→2→1→3。&lt;/p&gt;
&lt;p&gt;　　采用递归的方式完成单链表的逆序，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/WNrammY&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。例题：LeetCode的&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;206. 反转链表&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class List {
  reverse() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逆序&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.recursive(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header.next);
  }
  recursive(node) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!node) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    const current &lt;/span&gt;=&lt;span&gt; node,
      next &lt;/span&gt;=&lt;span&gt; current.next;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;next) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;头结点指向逆序后链表的第一个结点&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.header.next =&lt;span&gt; current;
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.recursive(next);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;***********************************
    * 移动结点
    * 例如Node(2).next.next就是Node(3)
    * 巧妙的将Node(3).next链接为Node(2)
    ***********************************&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    current.next.next &lt;/span&gt;=&lt;span&gt; current;
    current.next &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）链表中环的检测&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第一种思路是缓存每个经过的结点，每到一个新结点，就判断当前序列中是否存在，如果存在，就说明访问过了。&lt;/p&gt;
&lt;p&gt;　　第二种思路是使用两个指针，快指针每次前移两步，慢指针每次前移一步，当两个指针指向相同结点时，就证明有环，否则就没有环，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/VweENWQ&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。例题：LeetCode的&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;141. 环形链表&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class List {
  isLoop() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测环&lt;/span&gt;
    let fast = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header.next,
      slow &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header.next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (fast &amp;amp;&amp;amp;&lt;span&gt; fast.next) {
      slow &lt;/span&gt;=&lt;span&gt; slow.next;
      fast &lt;/span&gt;=&lt;span&gt; fast.next.next;
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slow == fast) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）合并两个有序链表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用两个指针遍历两个链表，如果head1指向的数据小于head2的，则将head1指向的结点归入合并后的链表中，否则用head2的，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/bGEmJMP&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。例题：LeetCode的&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/merge-two-sorted-lists/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;21. 合并两个有序链表&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; merge(head1, head2) {
  let cur1 &lt;/span&gt;=&lt;span&gt; head1.next,
    cur2 &lt;/span&gt;=&lt;span&gt; head2.next,
    cur &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;,         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并后的尾结点&lt;/span&gt;
    head = &lt;span&gt;null&lt;/span&gt;;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并后的头结点&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;合并后链表的头结点为第一个结点元素最小的那个链表的头结点&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (cur1.key &amp;gt;&lt;span&gt; cur2.key) {
    head &lt;/span&gt;=&lt;span&gt; head2;
    cur &lt;/span&gt;=&lt;span&gt; cur2;
    cur2 &lt;/span&gt;=&lt;span&gt; cur2.next;
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    head &lt;/span&gt;=&lt;span&gt; head1;
    cur &lt;/span&gt;=&lt;span&gt; cur1;
    cur1 &lt;/span&gt;=&lt;span&gt; cur1.next;
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每次找链表剩余结点的最小值对应的结点连接到合并后链表的尾部&lt;/span&gt;
  &lt;span&gt;while&lt;/span&gt; (cur1 &amp;amp;&amp;amp;&lt;span&gt; cur2) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cur1.key &amp;gt;&lt;span&gt; cur2.key) {
      cur.next &lt;/span&gt;=&lt;span&gt; cur2;
      cur &lt;/span&gt;=&lt;span&gt; cur2;
      cur2 &lt;/span&gt;=&lt;span&gt; cur2.next;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      cur.next &lt;/span&gt;=&lt;span&gt; cur1;
      cur &lt;/span&gt;=&lt;span&gt; cur1;
      cur1 &lt;/span&gt;=&lt;span&gt; cur1.next;
    }
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当遍历完一个链表后把另外一个链表剩余的结点链接到合并后的链表后面&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (cur1 != &lt;span&gt;null&lt;/span&gt;) cur.next =&lt;span&gt; cur1;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cur2 != &lt;span&gt;null&lt;/span&gt;) cur.next =&lt;span&gt; cur2;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; head;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）找出链表倒数第 n 个结点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　使用两个指针，快指针比慢指针先前移 n 步，然后两个指针同时移动。当快指针到底后，慢指针的位置就是所要找的结点，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/xxZmxWv&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。例题：LeetCode的&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;剑指 Offer 22. 链表中倒数第k个节点&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class List {
  findLast(n) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除链表倒数第 n 个结点&lt;/span&gt;
    let slow = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
      fast &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    slow &lt;/span&gt;= fast = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header.next;
    let i &lt;/span&gt;= 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前移 n 步&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (i &amp;lt; n &amp;amp;&amp;amp;&lt;span&gt; fast) {
      fast &lt;/span&gt;=&lt;span&gt; fast.next;
      i&lt;/span&gt;++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (fast) {
      fast &lt;/span&gt;=&lt;span&gt; fast.next;
      slow &lt;/span&gt;=&lt;span&gt; slow.next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; slow;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）求链表的中间结点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　使用两个指针一起遍历链表。慢指针每次走一步，快指针每次走两步。那么当快指针到达链表的末尾时，慢指针必然处于中间位置，&lt;span&gt;&lt;a href=&quot;https://codepen.io/strick/pen/GRoPRPm&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;如下所示&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。例题：LeetCode的&lt;span&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/middle-of-the-linked-list/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;876. 链表的中间结点&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class List {
  middle() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;求链表的中间结点&lt;/span&gt;
    let slow = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header.next,
      fast &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.header.next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (slow &amp;amp;&amp;amp; fast &amp;amp;&amp;amp;&lt;span&gt; fast.next) {
      slow &lt;/span&gt;=&lt;span&gt; slow.next;
      fast &lt;/span&gt;=&lt;span&gt; fast.next.next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; slow;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 24 Aug 2020 22:45:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>链表（Linked List）是不同于数组的另一种数据结构，它的存储单元（即结点或元素）除了包含任意类型的数据之外，还需要包含指向另一个结点的引用，后文会用术语链接表示对结点的引用。 下面会列出链表与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13344157.html</dc:identifier>
</item>
<item>
<title>Netty之旅二：口口相传的高性能Netty到底是什么？ - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/13557635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/13557635.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-5cc3f85b621388a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;d0iosx.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高清思维导图原件(&lt;code&gt;xmind/pdf/jpg&lt;/code&gt;)可以关注公众号：&lt;code&gt;一枝花算不算浪漫&lt;/code&gt; 回复&lt;code&gt;netty01&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;上一篇文章讲了&lt;code&gt;NIO&lt;/code&gt;相关的知识点，相比于传统&lt;code&gt;IO&lt;/code&gt;，&lt;code&gt;NIO&lt;/code&gt;已经做得很优雅了，为什么我们还要使用&lt;code&gt;Netty&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;上篇文章最后留了很多坑，讲了&lt;code&gt;NIO&lt;/code&gt;使用的弊端，也是为了引出&lt;code&gt;Netty&lt;/code&gt;而设立的，这篇文章我们就来好好揭开&lt;code&gt;Netty&lt;/code&gt;的神秘面纱。&lt;/p&gt;
&lt;p&gt;本篇文章的目的很简单，希望看过后你能看懂&lt;code&gt;Netty&lt;/code&gt;的示例代码，针对于简单的网络通信，自己也能用&lt;code&gt;Netty&lt;/code&gt;手写一个开发应用出来！&lt;/p&gt;
&lt;h2 id=&quot;一个简单的netty示例&quot;&gt;一个简单的Netty示例&lt;/h2&gt;
&lt;p&gt;以下是一个简单聊天室Server端的程序，代码参考自：&lt;code&gt;http://www.imooc.com/read/82/article/2166&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;代码有点长，主要核心代码是在&lt;code&gt;main()&lt;/code&gt;方法中，这里代码也希望大家看懂，后面也会一步步剖析。&lt;/p&gt;
&lt;p&gt;PS：我是用&lt;code&gt;mac&lt;/code&gt;系统，直接在终端输入&lt;code&gt;telnet 127.0.0.1 8007&lt;/code&gt; 即可启动一个聊天框，如果提示找不到&lt;code&gt;telnet&lt;/code&gt;命令，可以通过&lt;code&gt;brew&lt;/code&gt;进行安装，具体步骤请自行百度。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @Description netty简易聊天室
 *
 * @Author 一枝花算不算浪漫
 * @Date 2020/8/10 6:52 上午
 */
public final class NettyChatServer {

    static final int PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, &quot;8007&quot;));

    public static void main(String[] args) throws Exception {
        // 1. EventLoopGroup
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            // 2. 服务端引导器
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            // 3. 设置线bootStrap信息
            serverBootstrap.group(bossGroup, workerGroup)
                    // 4. 设置ServerSocketChannel的类型
                    .channel(NioServerSocketChannel.class)
                    // 5. 设置参数
                    .option(ChannelOption.SO_BACKLOG, 100)
                    // 6. 设置ServerSocketChannel对应的Handler，只能设置一个
                    .handler(new LoggingHandler(LogLevel.INFO))
                    // 7. 设置SocketChannel对应的Handler
                    .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ChannelPipeline p = ch.pipeline();
                            // 可以添加多个子Handler
                            p.addLast(new LoggingHandler(LogLevel.INFO));
                            p.addLast(new ChatNettyHandler());
                        }
                    });

            // 8. 绑定端口
            ChannelFuture f = serverBootstrap.bind(PORT).sync();
            // 9. 等待服务端监听端口关闭，这里会阻塞主线程
            f.channel().closeFuture().sync();
        } finally {
            // 10. 优雅地关闭两个线程池
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }

    private static class ChatNettyHandler extends SimpleChannelInboundHandler&amp;lt;ByteBuf&amp;gt; {
        @Override
        public void channelActive(ChannelHandlerContext ctx) {
            System.out.println(&quot;one conn active: &quot; + ctx.channel());
            // channel是在ServerBootstrapAcceptor中放到EventLoopGroup中的
            ChatHolder.join((SocketChannel) ctx.channel());
        }

        @Override
        protected void channelRead0(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception {
            byte[] bytes = new byte[byteBuf.readableBytes()];
            byteBuf.readBytes(bytes);
            String content = new String(bytes, StandardCharsets.UTF_8);
            System.out.println(content);

            if (content.equals(&quot;quit\r\n&quot;)) {
                ctx.channel().close();
            } else {
                ChatHolder.propagate((SocketChannel) ctx.channel(), content);
            }
        }

        @Override
        public void channelInactive(ChannelHandlerContext ctx) {
            System.out.println(&quot;one conn inactive: &quot; + ctx.channel());
            ChatHolder.quit((SocketChannel) ctx.channel());
        }
    }

    private static class ChatHolder {
        static final Map&amp;lt;SocketChannel, String&amp;gt; USER_MAP = new ConcurrentHashMap&amp;lt;&amp;gt;();

        /**
         * 加入群聊
         */
        static void join(SocketChannel socketChannel) {
            // 有人加入就给他分配一个id
            String userId = &quot;用户&quot;+ ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE);
            send(socketChannel, &quot;您的id为：&quot; + userId + &quot;\n\r&quot;);

            for (SocketChannel channel : USER_MAP.keySet()) {
                send(channel, userId + &quot; 加入了群聊&quot; + &quot;\n\r&quot;);
            }

            // 将当前用户加入到map中
            USER_MAP.put(socketChannel, userId);
        }

        /**
         * 退出群聊
         */
        static void quit(SocketChannel socketChannel) {
            String userId = USER_MAP.get(socketChannel);
            send(socketChannel, &quot;您退出了群聊&quot; + &quot;\n\r&quot;);
            USER_MAP.remove(socketChannel);

            for (SocketChannel channel : USER_MAP.keySet()) {
                if (channel != socketChannel) {
                    send(channel, userId + &quot; 退出了群聊&quot; + &quot;\n\r&quot;);
                }
            }
        }

        /**
         * 扩散说话的内容
         */
        public static void propagate(SocketChannel socketChannel, String content) {
            String userId = USER_MAP.get(socketChannel);
            for (SocketChannel channel : USER_MAP.keySet()) {
                if (channel != socketChannel) {
                    send(channel, userId + &quot;: &quot; + content);
                }
            }
        }

        /**
         * 发送消息
         */
        static void send(SocketChannel socketChannel, String msg) {
            try {
                ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;
                ByteBuf writeBuffer = allocator.buffer(msg.getBytes().length);
                writeBuffer.writeCharSequence(msg, Charset.defaultCharset());
                socketChannel.writeAndFlush(writeBuffer);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-dcb49953adad8127.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dkeb0s.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码有点长，执行完的效果如上图所示，下面所有内容都是围绕着&lt;code&gt;如何看懂&lt;/code&gt;以及&lt;code&gt;如何写出&lt;/code&gt;这样的代码来展开的，希望你看完 也能轻松手写&lt;code&gt;Netty&lt;/code&gt;服务端代码~。通过简单demo开发让大家体验了&lt;code&gt;Netty&lt;/code&gt;实现相比&lt;code&gt;NIO&lt;/code&gt;确实要简单的多，但优点不限于此，只需要知道选择Netty就对了。&lt;/p&gt;
&lt;h2 id=&quot;netty核心组件&quot;&gt;Netty核心组件&lt;/h2&gt;
&lt;p&gt;对应着文章开头的思维导图，我们知道&lt;code&gt;Netty&lt;/code&gt;的核心组件主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Bootstrap &amp;amp;&amp;amp; ServerBootstrap&lt;/li&gt;
&lt;li&gt;EventLoopGroup&lt;/li&gt;
&lt;li&gt;EventLoop&lt;/li&gt;
&lt;li&gt;ByteBuf&lt;/li&gt;
&lt;li&gt;Channel&lt;/li&gt;
&lt;li&gt;ChannelHandler&lt;/li&gt;
&lt;li&gt;ChannelFuture&lt;/li&gt;
&lt;li&gt;ChannelPipeline&lt;/li&gt;
&lt;li&gt;ChannelHandlerContext&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-dcf6d0f8af600df7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dk8ZC9.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;bootstrap--serverbootstrap&quot;&gt;Bootstrap &amp;amp; ServerBootstrap&lt;/h3&gt;
&lt;p&gt;一看到&lt;code&gt;BootStrap&lt;/code&gt;大家就应该想到&lt;strong&gt;启动类、引导类&lt;/strong&gt;这样的词汇，之前分析过&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/12089911.html&quot;&gt;EurekaServer项目启动类时&lt;/a&gt;介绍过&lt;code&gt;EurekaBootstrap&lt;/code&gt;， 他的作用就是上下文初始化、配置初始化。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Netty&lt;/code&gt;中我们也有类似的类，&lt;code&gt;Bootstrap&lt;/code&gt;和&lt;code&gt;ServerBootstrap&lt;/code&gt;它们都是&lt;code&gt;Netty&lt;/code&gt;程序的引导类，主要用于配置各种参数，并启动整个&lt;code&gt;Netty&lt;/code&gt;服务，我们看下文章开头的示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ServerBootstrap serverBootstrap = new ServerBootstrap();
serverBootstrap.group(bossGroup, workerGroup)      
        .channel(NioServerSocketChannel.class)
        .option(ChannelOption.SO_BACKLOG, 100)
        .handler(new LoggingHandler(LogLevel.INFO))
        .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
            @Override
            public void initChannel(SocketChannel ch) throws Exception {
                ChannelPipeline p = ch.pipeline();
                p.addLast(new LoggingHandler(LogLevel.INFO));
                p.addLast(new ChatNettyHandler());
            }
        });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Bootstrap&lt;/code&gt;和&lt;code&gt;ServerBootstrap&lt;/code&gt;是针对于&lt;code&gt;Client&lt;/code&gt;和&lt;code&gt;Server&lt;/code&gt;端定义的两套启动类，区别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Bootstrap&lt;/code&gt;是客户端引导类，而&lt;code&gt;ServerBootstrap&lt;/code&gt;是服务端引导类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bootstrap&lt;/code&gt;通常使用&lt;code&gt;connect()&lt;/code&gt;方法连接到远程的主机和端口，作为一个&lt;code&gt;TCP客户端&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServerBootstrap&lt;/code&gt;通常使用&lt;code&gt;bind()&lt;/code&gt;方法绑定本地的端口，等待客户端来连接。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ServerBootstrap&lt;/code&gt;可以处理&lt;code&gt;Accept&lt;/code&gt;事件，这里面&lt;code&gt;childHandler&lt;/code&gt;是用来处理&lt;code&gt;Channel&lt;/code&gt;请求的，我们可以查看&lt;code&gt;chaildHandler()&lt;/code&gt;方法的注解：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/08/15/dk884H.png&quot; alt=&quot;dk884H.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Bootstrap&lt;/code&gt;客户端引导只需要一个&lt;code&gt;EventLoopGroup&lt;/code&gt;，但是一个&lt;code&gt;ServerBootstrap&lt;/code&gt;通常需要两个(上面的&lt;code&gt;boosGroup&lt;/code&gt;和&lt;code&gt;workerGroup&lt;/code&gt;)。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;eventloopgroup--eventloop&quot;&gt;EventLoopGroup &amp;amp;&amp;amp; EventLoop&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;EventLoopGroup&lt;/code&gt;及&lt;code&gt;EventLoop&lt;/code&gt;这两个类名称定义的很奇怪，对于初学者来说往往无法通过名称来了解其中的含义，包括我也是这样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EventLoopGroup&lt;/code&gt; 可以理解为一个线程池，对于服务端程序，我们一般会绑定两个线程池，一个用于处理 &lt;code&gt;Accept&lt;/code&gt; 事件，一个用于处理读写事件，看下&lt;code&gt;EventLoop&lt;/code&gt;系列的类目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-20c7c39cb233e867.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dU4Roj.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的类图，我们才恍然大悟，我的亲娘咧，这不就是一个线程池嘛？(名字气的犄角拐弯的真是难认)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EventLoopGroup&lt;/code&gt;是&lt;code&gt;EventLoop&lt;/code&gt;的集合，一个&lt;code&gt;EventLoopGroup&lt;/code&gt; 包含一个或者多个&lt;code&gt;EventLoop&lt;/code&gt;。我们可以将&lt;code&gt;EventLoop&lt;/code&gt;看做&lt;code&gt;EventLoopGroup&lt;/code&gt;线程池中的一个个工作线程。&lt;/p&gt;
&lt;p&gt;至于这里为什么要用到两个线程池，具体的其实可以参考&lt;code&gt;Reactor&lt;/code&gt;设计模式，这里暂时不做过多的讲解。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个 EventLoopGroup 包含一个或多个 EventLoop ，即 EventLoopGroup : EventLoop = 1 : n&lt;/li&gt;
&lt;li&gt;一个 EventLoop 在它的生命周期内，只能与一个 Thread 绑定，即 EventLoop : Thread = 1 : 1&lt;/li&gt;
&lt;li&gt;所有有 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理，从而保证线程安全，即 Thread : EventLoop = 1 : 1&lt;/li&gt;
&lt;li&gt;一个 Channel 在它的生命周期内只能注册到一个 EventLoop 上，即 Channel : EventLoop = n : 1&lt;/li&gt;
&lt;li&gt;一个 EventLoop 可被分配至一个或多个 Channel ，即 EventLoop : Channel = 1 : n&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当一个连接到达时，&lt;code&gt;Netty&lt;/code&gt; 就会创建一个 &lt;code&gt;Channel&lt;/code&gt;，然后从 &lt;code&gt;EventLoopGroup&lt;/code&gt; 中分配一个 &lt;code&gt;EventLoop&lt;/code&gt; 来给这个 &lt;code&gt;Channel&lt;/code&gt; 绑定上，在该 &lt;code&gt;Channel&lt;/code&gt; 的整个生命周期中都是有这个绑定的 &lt;code&gt;EventLoop&lt;/code&gt; 来服务的。&lt;/p&gt;
&lt;h3 id=&quot;bytebuf&quot;&gt;ByteBuf&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;Java NIO&lt;/code&gt;中我们有 &lt;code&gt;ByteBuffer&lt;/code&gt;缓冲池，对于它的操作我们应该印象深刻，往&lt;code&gt;Buffer&lt;/code&gt;中写数据时我们需要关注写入的位置，切换成读模式时我们还要切换读写状态，不然将会出现大问题。&lt;/p&gt;
&lt;p&gt;针对于&lt;code&gt;NIO&lt;/code&gt;中超级难用的&lt;code&gt;Buffer&lt;/code&gt;类， &lt;code&gt;Netty&lt;/code&gt; 提供了&lt;code&gt;ByteBuf&lt;/code&gt;来替代。&lt;code&gt;ByteBuf&lt;/code&gt;声明了两个指针：一个读指针，一个写指针，使得读写操作进行分离，简化&lt;code&gt;buffer&lt;/code&gt;的操作流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-b10ced8238b3b66e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dkQocV.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外&lt;code&gt;Netty&lt;/code&gt;提供了发几种&lt;code&gt;ByteBuf&lt;/code&gt;的实现以供我们选择，&lt;code&gt;ByteBuf&lt;/code&gt;可以分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Pooled&lt;/code&gt;和&lt;code&gt;Unpooled&lt;/code&gt; 池化和非池化&lt;/li&gt;
&lt;li&gt;Heap 和 Direct，堆内存和堆外内存，NIO中创建Buffer也可以指定&lt;/li&gt;
&lt;li&gt;Safe 和 Unsafe，安全和非安全&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-fed9e32fd4a0cdf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dkJ9TU.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于这么多种创建&lt;code&gt;Buffer&lt;/code&gt;的方式该怎么选择呢？&lt;code&gt;Netty&lt;/code&gt;也为我们处理好了，我们可以直接使用（真是暖男&lt;code&gt;Ntetty&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ByteBufAllocator allocator = ByteBufAllocator.DEFAULT;
ByteBuf buffer = allocator.buffer(length);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种方式，Netty将最大努力的使用池化、Unsafe、对外内存的方式为我们创建buffer。&lt;/p&gt;
&lt;h3 id=&quot;channel&quot;&gt;Channel&lt;/h3&gt;
&lt;p&gt;提起&lt;code&gt;Channel&lt;/code&gt;并不陌生，上一篇讲&lt;code&gt;NIO&lt;/code&gt;的三大组件提到过，最常见的就是&lt;code&gt;java.nio.SocketChannel&lt;/code&gt;和&lt;code&gt;java.nio.ServerSocketChannel&lt;/code&gt;，他们用于非阻塞的I/0操作。类似于&lt;code&gt;NIO&lt;/code&gt;的&lt;code&gt;Channel&lt;/code&gt;，Netty提供了自己的&lt;code&gt;Channel&lt;/code&gt;和其子类实现，用于异步I/0操作和其他相关的操作。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Netty&lt;/code&gt; 中, &lt;code&gt;Channel&lt;/code&gt; 是一个 &lt;code&gt;Socket&lt;/code&gt; 连接的抽象, 它为用户提供了关于底层 &lt;code&gt;Socket&lt;/code&gt; 状态(是否是连接还是断开) 以及对 &lt;code&gt;Socket&lt;/code&gt; 的读写等操作。每当 &lt;code&gt;Netty&lt;/code&gt; 建立了一个连接后, 都会有一个对应的 &lt;code&gt;Channel&lt;/code&gt; 实例。并且，有父子&lt;code&gt;channel&lt;/code&gt;的概念。 服务器连接监听的&lt;code&gt;channel&lt;/code&gt; ，也叫 &lt;code&gt;parent channel&lt;/code&gt;。 对应于每一个 &lt;code&gt;Socket&lt;/code&gt; 连接的&lt;code&gt;channel&lt;/code&gt;，也叫 &lt;code&gt;child channel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;既然&lt;code&gt;channel&lt;/code&gt; 是 Netty 抽象出来的网络 I/O 读写相关的接口，为什么不使用 &lt;code&gt;JDK NIO&lt;/code&gt; 原生的 &lt;code&gt;Channel&lt;/code&gt; 而要另起炉灶呢，主要原因如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;JDK&lt;/code&gt; 的 &lt;code&gt;SocketChannel&lt;/code&gt; 和 &lt;code&gt;ServersocketChannel&lt;/code&gt; 没有统一的 &lt;code&gt;Channel&lt;/code&gt; 接口供业务开发者使用，对一于用户而言，没有统一的操作视图，使用起来并不方便。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JDK&lt;/code&gt; 的 &lt;code&gt;SocketChannel&lt;/code&gt; 和 &lt;code&gt;ScrversockctChannel&lt;/code&gt; 的主要职责就是网络 I/O 操作，由于他们是 &lt;code&gt;SPI&lt;/code&gt; 类接口，由具体的虚拟机厂家来提供，所以通过继承 SPI 功能直接实现 &lt;code&gt;ServersocketChannel&lt;/code&gt; 和 &lt;code&gt;SocketChannel&lt;/code&gt; 来扩展其工作量和重新 &lt;code&gt;Channel&lt;/code&gt; 功类是差不多的。&lt;/li&gt;
&lt;li&gt;Netty 的 &lt;code&gt;ChannelPipeline Channel&lt;/code&gt; 需要够跟 Netty 的整体架构融合在一起，例如 I/O 模型、基的定制模型，以及基于元数据描述配置化的 TCP 参数等，这些 &lt;code&gt;JDK SocketChannel&lt;/code&gt; 和&lt;code&gt;ServersocketChannel&lt;/code&gt;都没有提供，需要重新封装。&lt;/li&gt;
&lt;li&gt;自定义的 &lt;code&gt;Channel&lt;/code&gt; ，功实现更加灵活。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于上述 4 原因，它的设计原理比较简单， Netty 重新设计了 &lt;code&gt;Channel&lt;/code&gt; 接口，并且给予了很多不同的实现。但是功能却比较繁杂，主要的设计理念如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Channel&lt;/code&gt; 接口层，相关联的其他操作封装起来，采用 &lt;code&gt;Facade&lt;/code&gt; 模式进行统一封装，将网络 I/O 操作、网络 I/O 统一对外提供。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Channel&lt;/code&gt; 接口的定义尽量大而全，统一的视图，由不同子类实现不同的功能，公共功能在抽象父类中实现，最大程度上实现接口的重用。&lt;/li&gt;
&lt;li&gt;具体实现采用聚合而非包含的方式，将相关的功类聚合在 &lt;code&gt;Channel&lt;/code&gt; 中，由 &lt;code&gt;Channel&lt;/code&gt; 统一负责分配和调度，功能实现更加灵活。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;Channel&lt;/code&gt; 的实现类非常多，继承关系复杂，从学习的角度我们抽取最重要的两个 &lt;code&gt;NioServerSocketChannel&lt;/code&gt; 和 &lt;code&gt;NioSocketChannel&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;服务端 &lt;code&gt;NioServerSocketChannel&lt;/code&gt; 的继承关系类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-a82b11a120a58c85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUn8G4.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;客户端 &lt;code&gt;NioSocketChannel&lt;/code&gt; 的继承关系类图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-321c8b4f8e0dda6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUnJz9.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后面文章源码系列会具体分析，这里就不进一步阐述分析了。&lt;/p&gt;
&lt;h3 id=&quot;channelhandler&quot;&gt;ChannelHandler&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ChannelHandler&lt;/code&gt; 是&lt;code&gt;Netty&lt;/code&gt;中最常用的组件。&lt;code&gt;ChannelHandler&lt;/code&gt; 主要用来处理各种事件，这里的事件很广泛，比如可以是连接、数据接收、异常、数据转换等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ChannelHandler&lt;/code&gt; 有两个核心子类 &lt;code&gt;ChannelInboundHandler&lt;/code&gt; 和 &lt;code&gt;ChannelOutboundHandler&lt;/code&gt;，其中 &lt;code&gt;ChannelInboundHandler&lt;/code&gt; 用于接收、处理入站( &lt;code&gt;Inbound&lt;/code&gt; )的数据和事件，而 &lt;code&gt;ChannelOutboundHandler&lt;/code&gt; 则相反，用于接收、处理出站( &lt;code&gt;Outbound&lt;/code&gt; )的数据和事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-b76bf9284af32276.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dkJAp9.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;channelinboundhandler&quot;&gt;ChannelInboundHandler&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ChannelInboundHandler&lt;/code&gt;处理入站数据以及各种状态变化,当&lt;code&gt;Channel&lt;/code&gt;状态发生改变会调用&lt;code&gt;ChannelInboundHandler&lt;/code&gt;中的一些生命周期方法.这些方法与&lt;code&gt;Channel&lt;/code&gt;的生命密切相关。&lt;/p&gt;
&lt;p&gt;入站数据,就是进入&lt;code&gt;socket&lt;/code&gt;的数据。下面展示一些该接口的生命周期&lt;code&gt;API&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-016fadc9b5211ee0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUntMR.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当某个 &lt;code&gt;ChannelInboundHandler&lt;/code&gt;的实现重写 &lt;code&gt;channelRead()&lt;/code&gt;方法时，它将负责显式地释放与池化的 &lt;code&gt;ByteBuf&lt;/code&gt; 实例相关的内存。 Netty 为此提供了一个实用方法&lt;code&gt;ReferenceCountUtil.release()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Sharable
public class DiscardHandler extends ChannelInboundHandlerAdapter {
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) {
                ReferenceCountUtil.release(msg);
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式还挺繁琐的,Netty提供了一个&lt;code&gt;SimpleChannelInboundHandler&lt;/code&gt;,重写&lt;code&gt;channelRead0()&lt;/code&gt;方法,就可以在调用过程中会自动释放资源.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SimpleDiscardHandler
        extends SimpleChannelInboundHandler&amp;lt;Object&amp;gt; {
        @Override
        public void channelRead0(ChannelHandlerContext ctx,
                                                                        Object msg) {
                        // 不用调用ReferenceCountUtil.release(msg)也会释放资源
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;channeloutboundhandler&quot;&gt;ChannelOutboundHandler&lt;/h4&gt;
&lt;p&gt;出站操作和数据将由 &lt;code&gt;ChannelOutboundHandler&lt;/code&gt; 处理。它的方法将被 &lt;code&gt;Channel&lt;/code&gt;、 &lt;code&gt;ChannelPipeline&lt;/code&gt; 以及 &lt;code&gt;ChannelHandlerContext&lt;/code&gt; 调用。&lt;br/&gt;&lt;code&gt;ChannelOutboundHandler&lt;/code&gt; 的一个强大的功能是可以按需推迟操作或者事件，这使得可以通过一些复杂的方法来处理请求。例如， 如果到远程节点的写入被暂停了， 那么你可以推迟冲刷操作并在稍后继续。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-fe7e906d4f138340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;d0PxbT.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ChannelPromise&lt;/code&gt;与&lt;code&gt;ChannelFuture&lt;/code&gt;: &lt;code&gt;ChannelOutboundHandler&lt;/code&gt;中的大部分方法都需要一个&lt;code&gt;ChannelPromise&lt;/code&gt;参数， 以便在操作完成时得到通知。 &lt;code&gt;ChannelPromise&lt;/code&gt;是&lt;code&gt;ChannelFuture&lt;/code&gt;的一个子类，其定义了一些可写的方法，如&lt;code&gt;setSuccess()&lt;/code&gt;和&lt;code&gt;setFailure()&lt;/code&gt;，从而使&lt;code&gt;ChannelFuture&lt;/code&gt;不可变。&lt;/p&gt;
&lt;h4 id=&quot;channelhandleradapter&quot;&gt;ChannelHandlerAdapter&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ChannelHandlerAdapter&lt;/code&gt;顾名思义,就是&lt;code&gt;handler&lt;/code&gt;的适配器。你需要知道什么是适配器模式，假设有一个A接口，我们需要A的&lt;code&gt;subclass&lt;/code&gt;实现功能,但是B类中正好有我们需要的功能，不想复制粘贴B中的方法和属性了，那么可以写一个适配器类&lt;code&gt;Adpter&lt;/code&gt;继承B实现A，这样一来&lt;code&gt;Adapter&lt;/code&gt;是A的子类并且能直接使用B中的方法，这种模式就是适配器模式。&lt;/p&gt;
&lt;p&gt;就比如Netty中的&lt;code&gt;SslHandler&lt;/code&gt;类，想使用&lt;code&gt;ByteToMessageDecoder&lt;/code&gt;中的方法进行解码，但是必须是&lt;code&gt;ChannelHandler&lt;/code&gt;子类对象才能加入到&lt;code&gt;ChannelPipeline&lt;/code&gt;中，通过如下签名和其实现细节(&lt;code&gt;SslHandler&lt;/code&gt;实现细节就不贴了)就能够作为一个&lt;code&gt;handler&lt;/code&gt;去处理消息了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SslHandler extends ByteToMessageDecoder implements ChannelOutboundHandler
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ChannelHandlerAdapter&lt;/code&gt;提供了一些实用方法&lt;code&gt;isSharable()&lt;/code&gt;如果其对应的实现被标注为 &lt;code&gt;Sharable&lt;/code&gt;， 那么这个方法将返回 &lt;code&gt;true&lt;/code&gt;， 表示它可以被添加到多个 &lt;code&gt;ChannelPipeline&lt;/code&gt;中 。如果想在自己的&lt;code&gt;ChannelHandler&lt;/code&gt;中使用这些适配器类，只需要扩展他们，重写那些想要自定义的方法即可。&lt;/p&gt;
&lt;h3 id=&quot;channelpipeline&quot;&gt;ChannelPipeline&lt;/h3&gt;
&lt;p&gt;每一个新创建的 &lt;code&gt;Channel&lt;/code&gt; 都将会被分配一个新的 &lt;code&gt;ChannelPipeline&lt;/code&gt;。这项关联是永久性的； &lt;code&gt;Channel&lt;/code&gt; 既不能附加另外一个 &lt;code&gt;ChannelPipeline&lt;/code&gt;，也不能分离其当前的。在 Netty 组件的生命周期中，这是一项固定的操作，不需要开发人员的任何干预。&lt;/p&gt;
&lt;p&gt;Netty 的 &lt;code&gt;ChannelHandler&lt;/code&gt; 为处理器提供了基本的抽象， 目前你可以认为每个 &lt;code&gt;ChannelHandler&lt;/code&gt; 的实例都类似于一种为了响应特定事件而被执行的回调。从应用程序开发人员的角度来看， 它充当了所有处理入站和出站数据的应用程序逻辑的拦截载体。&lt;code&gt;ChannelPipeline&lt;/code&gt;提供了 &lt;code&gt;ChannelHandler&lt;/code&gt; 链的容器，并定义了用于在该链上传播入站和出站事件流的 &lt;code&gt;API&lt;/code&gt;。当 &lt;code&gt;Channel&lt;/code&gt; 被创建时，它会被自动地分配到它专属的 &lt;code&gt;ChannelPipeline&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ChannelHandler&lt;/code&gt; 安装到 &lt;code&gt;ChannelPipeline&lt;/code&gt; 中的过程如下所示:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个&lt;code&gt;ChannelInitializer&lt;/code&gt;的实现被注册到了&lt;code&gt;ServerBootstrap&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当 &lt;code&gt;ChannelInitializer.initChannel()&lt;/code&gt;方法被调用时，&lt;code&gt;ChannelInitializer&lt;/code&gt;将在 &lt;code&gt;ChannelPipeline&lt;/code&gt; 中安装一组自定义的 &lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ChannelInitializer&lt;/code&gt; 将它自己从 &lt;code&gt;ChannelPipeline&lt;/code&gt; 中移除&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-6ba27f803a58bd1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dkJuTO.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示：这是一个同时具有入站和出站 &lt;code&gt;ChannelHandler&lt;/code&gt; 的 &lt;code&gt;ChannelPipeline&lt;/code&gt;的布局，并且印证了我们之前的关于 &lt;code&gt;ChannelPipeline&lt;/code&gt; 主要由一系列的 &lt;code&gt;ChannelHandler&lt;/code&gt; 所组成的说法。 &lt;code&gt;ChannelPipeline&lt;/code&gt;还提供了通过 &lt;code&gt;ChannelPipeline&lt;/code&gt; 本身传播事件的方法。如果一个入站事件被触发，它将被从 &lt;code&gt;ChannelPipeline&lt;/code&gt;的头部开始一直被传播到 Channel Pipeline 的尾端。&lt;/p&gt;
&lt;p&gt;你可能会说， 从事件途经 &lt;code&gt;ChannelPipeline&lt;/code&gt;的角度来看， &lt;code&gt;ChannelPipeline&lt;/code&gt; 的头部和尾端取决于该事件是入站的还是出站的。然而 Netty 总是将 &lt;code&gt;ChannelPipeline&lt;/code&gt;的入站口（图 的左侧）作为头部，而将出站口（该图的右侧）作为尾端。&lt;br/&gt;当你完成了通过调用 &lt;code&gt;ChannelPipeline.add*()&lt;/code&gt;方法将入站处理器（ &lt;code&gt;ChannelInboundHandler&lt;/code&gt;）和 出 站 处 理 器 （ &lt;code&gt;ChannelOutboundHandler&lt;/code&gt; ） 混 合 添 加 到 &lt;code&gt;ChannelPipeline&lt;/code&gt;之 后 ， 每 一 个&lt;code&gt;ChannelHandler&lt;/code&gt; 从头部到尾端的顺序位置正如同我们方才所定义它们的一样。因此，如果你将图 6-3 中的处理器（ &lt;code&gt;ChannelHandler&lt;/code&gt;）从左到右进行编号，那么第一个被入站事件看到的 &lt;code&gt;ChannelHandler&lt;/code&gt; 将是1，而第一个被出站事件看到的 &lt;code&gt;ChannelHandler&lt;/code&gt; 将是 5。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;ChannelPipeline&lt;/code&gt; 传播事件时，它会测试 &lt;code&gt;ChannelPipeline&lt;/code&gt; 中的下一个 ChannelHandler 的类型是否和事件的运动方向相匹配。如果不匹配， &lt;code&gt;ChannelPipeline&lt;/code&gt; 将跳过该&lt;code&gt;ChannelHandler&lt;/code&gt; 并前进到下一个，直到它找到和该事件所期望的方向相匹配的为止。 （当然， &lt;code&gt;ChannelHandler&lt;/code&gt; 也可以同时实现&lt;code&gt;ChannelInboundHandler&lt;/code&gt; 接口和 &lt;code&gt;ChannelOutboundHandler&lt;/code&gt; 接口。）&lt;/p&gt;
&lt;h4 id=&quot;修改channelpipeline&quot;&gt;修改&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;修改指的是添加或删除&lt;code&gt;ChannelHandler&lt;/code&gt;,见代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ChannelPipeline pipeline = ..;
FirstHandler firstHandler = new FirstHandler();
// 先添加一个Handler到ChannelPipeline中
pipeline.addLast(&quot;handler1&quot;, firstHandler);
// 这个Handler放在了first,意味着放在了handler1之前
pipeline.addFirst(&quot;handler2&quot;, new SecondHandler());
// 这个Handler被放到了last,意味着在handler1之后
pipeline.addLast(&quot;handler3&quot;, new ThirdHandler());
...
// 通过名称删除
pipeline.remove(&quot;handler3&quot;);
// 通过对象删除
pipeline.remove(firstHandler);
// 名称&quot;handler2&quot;替换成名称&quot;handler4&quot;,并切handler2的实例替换成了handler4的实例
pipeline.replace(&quot;handler2&quot;, &quot;handler4&quot;, new ForthHandler());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;channelpipeline的出入站api&quot;&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt;的出入站&lt;code&gt;API&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;入站&lt;code&gt;API&lt;/code&gt;所示：&lt;/p&gt;
&lt;p&gt;[图片上传失败...(image-6037f5-1598167949595)]&lt;/p&gt;
&lt;p&gt;出站&lt;code&gt;API&lt;/code&gt;所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-93cd407346b35afe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUndZ6.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt; 这个组件上面所讲的大致只需要记住这三点即可：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt; 保存了与 &lt;code&gt;Channel&lt;/code&gt; 相关联的 &lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt; 可以根据需要，通过添加或者删除 &lt;code&gt;ChannelHandler&lt;/code&gt; 来动态地修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ChannelPipeline&lt;/code&gt; 有着丰富的&lt;code&gt;API&lt;/code&gt;用以被调用，以响应入站和出站事件&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;channelhandlercontext&quot;&gt;ChannelHandlerContext&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;ChannelHandler&lt;/code&gt; 被添加到 &lt;code&gt;ChannelPipeline&lt;/code&gt; 时，它将会被分配一个 &lt;code&gt;ChannelHandlerContext&lt;/code&gt; ，它代表了 &lt;code&gt;ChannelHandler&lt;/code&gt; 和 &lt;code&gt;ChannelPipeline&lt;/code&gt; 之间的绑定。&lt;code&gt;ChannelHandlerContext&lt;/code&gt; 的主要功能是管理它所关联的&lt;code&gt;ChannelHandler&lt;/code&gt;和在同一个 &lt;code&gt;ChannelPipeline&lt;/code&gt; 中的其他&lt;code&gt;ChannelHandler&lt;/code&gt;之间的交互。&lt;/p&gt;
&lt;p&gt;如果调用&lt;code&gt;Channel&lt;/code&gt;或&lt;code&gt;ChannelPipeline&lt;/code&gt;上的方法,会沿着整个&lt;code&gt;ChannelPipeline&lt;/code&gt;传播,如果调用&lt;code&gt;ChannelHandlerContext&lt;/code&gt;上的相同方法,则会从对应的当前&lt;code&gt;ChannelHandler&lt;/code&gt;进行传播。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ChannelHandlerContext API&lt;/code&gt;如下表所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-c08b22d37f156254.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUn0IO.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ChannelHandlerContext&lt;/code&gt; 和 &lt;code&gt;ChannelHandler&lt;/code&gt;之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的；&lt;/li&gt;
&lt;li&gt;如同在本节开头所解释的一样，相对于其他类的同名方法，&lt;code&gt;ChannelHandlerContext&lt;/code&gt;的方法将产生更短的事件流， 应该尽可能地利用这个特性来获得最大的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;与channelhandler、channelpipeline的关联使用&quot;&gt;与&lt;code&gt;ChannelHandler&lt;/code&gt;、&lt;code&gt;ChannelPipeline&lt;/code&gt;的关联使用&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-7fb2ed78ee2f7ce6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUnDiD.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从&lt;code&gt;ChannelHandlerContext&lt;/code&gt;访问&lt;code&gt;channel&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ChannelHandlerContext ctx = ..;
// 获取channel引用
Channel channel = ctx.channel();
// 通过channel写入缓冲区
channel.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;,
CharsetUtil.UTF_8));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从&lt;code&gt;ChannelHandlerContext&lt;/code&gt;访问&lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ChannelHandlerContext ctx = ..;
// 获取ChannelHandlerContext
ChannelPipeline pipeline = ctx.pipeline();
// 通过ChannelPipeline写入缓冲区
pipeline.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;,
CharsetUtil.UTF_8));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-2342628bdea772bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUnrJe.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有时候我们不想从头传递数据,想跳过几个&lt;code&gt;handler&lt;/code&gt;,从某个&lt;code&gt;handler&lt;/code&gt;开始传递数据.我们必须获取目标&lt;code&gt;handler&lt;/code&gt;之前的&lt;code&gt;handler&lt;/code&gt;关联的&lt;code&gt;ChannelHandlerContext&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ChannelHandlerContext ctx = ..;
// 直接通过ChannelHandlerContext写数据,发送到下一个handler
ctx.write(Unpooled.copiedBuffer(&quot;Netty in Action&quot;, CharsetUtil.UTF_8));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-19b0ce78062e2ddf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUnyzd.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，&lt;code&gt;ChannelHandlerContext&lt;/code&gt;的基本使用应该掌握了,但是你真的理解&lt;code&gt;ChannelHandlerContext&lt;/code&gt;,&lt;code&gt;ChannelPipeline&lt;/code&gt;和&lt;code&gt;Channelhandler&lt;/code&gt;之间的关系了吗?不理解也没关系，因为源码以后会帮你理解的更为深刻。&lt;/p&gt;
&lt;h3 id=&quot;核心组件之间的关系&quot;&gt;核心组件之间的关系&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;一个 &lt;code&gt;Channel&lt;/code&gt; 对应一个 &lt;code&gt;ChannelPipeline&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;ChannelPipeline&lt;/code&gt; 包含一条双向的 &lt;code&gt;ChannelHandlerContext&lt;/code&gt; 链&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;ChannelHandlerContext&lt;/code&gt; 中包含一个 &lt;code&gt;ChannelHandler&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;Channel&lt;/code&gt; 会绑定到一个&lt;code&gt;EventLoop&lt;/code&gt;上&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;NioEventLoop&lt;/code&gt; 维护了一个 &lt;code&gt;Selector（&lt;/code&gt;使用的是 Java 原生的 Selector）&lt;/li&gt;
&lt;li&gt;一个 &lt;code&gt;NioEventLoop&lt;/code&gt; 相当于一个线程&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;粘包拆包问题&quot;&gt;粘包拆包问题&lt;/h2&gt;
&lt;p&gt;粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于&lt;code&gt;UDP&lt;/code&gt;有消息保护边界，不会发生粘包拆包问题，而因此粘包拆包问题只发生在&lt;code&gt;TCP&lt;/code&gt;协议中。具体讲&lt;code&gt;TCP&lt;/code&gt;是个”流&quot;协议，只有流的概念，没有包的概念，对于业务上层数据的具体含义和边界并不了解，它只会根据&lt;code&gt;TCP&lt;/code&gt;缓冲区的实际情况进行包的划分。所以在业务上认为，一个完整的包可能会被&lt;code&gt;TCP&lt;/code&gt;拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的&lt;code&gt;TCP&lt;/code&gt;粘包和拆包问题。&lt;/p&gt;
&lt;h3 id=&quot;问题举例说明&quot;&gt;问题举例说明&lt;/h3&gt;
&lt;p&gt;下面针对客户端分别发送了两个数据表&lt;code&gt;Packet1&lt;/code&gt;和&lt;code&gt;Packet2&lt;/code&gt;给服务端的时候，&lt;code&gt;TCP&lt;/code&gt;粘包和拆包会出现的情况进行列举说明：&lt;/p&gt;
&lt;p&gt;（1）第一种情况，服务端分两次正常收到两个独立数据包，即没有发生拆包和粘包的现象；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-4d4679515945c3e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUncQA.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）第二种情况，接收端只收到一个数据包，由于&lt;code&gt;TCP&lt;/code&gt;是不会出现丢包的，所以这一个数据包中包含了客户端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于服务接收端来说很难处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-e28e48f4d54a9c17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUn2Lt.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）第三种情况，服务端分两次读取到了两个数据包，第一次读取到了完整的&lt;code&gt;Packet1&lt;/code&gt;和&lt;code&gt;Packet2&lt;/code&gt;包的部分内容，第二次读取到了&lt;code&gt;Packet2&lt;/code&gt;的剩余内容，这被称为TCP拆包；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-462747fa5bac0cff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;d0Pq8s.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）第四种情况，服务端分两次读取到了两个数据包，第一次读取到了部分的&lt;code&gt;Packet1&lt;/code&gt;内容，第二次读取到了&lt;code&gt;Packet1&lt;/code&gt;剩余内容和&lt;code&gt;Packet2&lt;/code&gt;的整包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-839f6b6f14a91b4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dUn5FS.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果此时服务端TCP接收滑窗非常小，而数据包&lt;code&gt;Packet1&lt;/code&gt;和&lt;code&gt;Packet2&lt;/code&gt;比较大，很有可能服务端需要分多次才能将两个包接收完全，期间发生多次拆包。以上列举情况的背后原因分别如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。&lt;/li&gt;
&lt;li&gt;应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。&lt;/li&gt;
&lt;li&gt;进行&lt;code&gt;MSS&lt;/code&gt;（最大报文长度）大小的&lt;code&gt;TCP&lt;/code&gt;分段，当&lt;code&gt;TCP&lt;/code&gt;报文长度-&lt;code&gt;TCP&lt;/code&gt;头部长度&amp;gt;&lt;code&gt;MSS&lt;/code&gt;的时候将发生拆包。&lt;/li&gt;
&lt;li&gt;接收方法不及时读取套接字缓冲区数据，这将发生粘包。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;如何基于netty处理粘包、拆包问题&quot;&gt;&lt;strong&gt;如何基于Netty处理粘包、拆包问题&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;由于底层的&lt;code&gt;TCP&lt;/code&gt;无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；&lt;/li&gt;
&lt;li&gt;在包尾增加回车换行符进行分割，例如&lt;code&gt;FTP&lt;/code&gt;协议；&lt;/li&gt;
&lt;li&gt;将消息分为消息头和消息体，消息头中包含表示消息总长度的字段，通常设计思路为消息头的第一个字段使用&lt;code&gt;int32&lt;/code&gt;来表示消息的总长度；&lt;/li&gt;
&lt;li&gt;更复杂的应用层协议。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;之前Netty示例中其实并没有考虑读半包问题，这在功能测试往往没有问题，但是一旦请求数过多或者发送大报文之后，就会存在该问题。如果代码没有考虑，往往就会出现解码错位或者错误，导致程序不能正常工作，下面看看Netty是如何根据主流的解决方案进行抽象实现来帮忙解决这一问题的。&lt;/p&gt;
&lt;p&gt;如下表所示，Netty为了找出消息的边界，采用封帧方式：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;解码&lt;/th&gt;
&lt;th&gt;编码&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;固定长度&lt;/td&gt;
&lt;td&gt;&lt;code&gt;FixedLengthFrameDecoder&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;分隔符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;DelimiterBasedFrameDecoder&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;专门的 length 字段&lt;/td&gt;
&lt;td&gt;&lt;code&gt;LengthFieldBasedFrameDecoder&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;LengthFieldPrepender&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;注意到，Netty提供了对应的解码器来解决对应的问题，有了这些解码器，用户不需要自己对读取的报文进行人工解码，也不需要考虑TCP的粘包和半包问题。为什么这么说呢？下面列举一个包尾增加分隔符的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandler;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.CharsetUtil;

import java.util.concurrent.atomic.AtomicInteger;

/**
 * @Author: wuxiaofei
 * @Date: 2020/8/15 0015 19:15
 * @Version: 1.0
 * @Description:入站处理器
 */
@ChannelHandler.Sharable
public class DelimiterServerHandler extends ChannelInboundHandlerAdapter {

    private AtomicInteger counter = new AtomicInteger(0);
    private AtomicInteger completeCounter = new AtomicInteger(0);

    /*** 服务端读取到网络数据后的处理*/
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf in = (ByteBuf)msg;
        String request = in.toString(CharsetUtil.UTF_8);
        System.out.println(&quot;Server Accept[&quot;+request
                +&quot;] and the counter is:&quot;+counter.incrementAndGet());
        String resp = &quot;Hello,&quot;+request+&quot;. Welcome to Netty World!&quot;
                + DelimiterEchoServer.DELIMITER_SYMBOL;
        ctx.writeAndFlush(Unpooled.copiedBuffer(resp.getBytes()));
    }

    /*** 服务端读取完成网络数据后的处理*/
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx)
            throws Exception {
        ctx.fireChannelReadComplete();
        System.out.println(&quot;the ReadComplete count is &quot;
                +completeCounter.incrementAndGet());
    }

    /*** 发生异常后的处理*/
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import io.netty.bootstrap.ServerBootstrap;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.DelimiterBasedFrameDecoder;

import java.net.InetSocketAddress;

/**
 * @Author: wuxiaofei
 * @Date: 2020/8/15 0015 19:17
 * @Version: 1.0
 * @Description:服务端
 */
public class DelimiterEchoServer {

    public static final String DELIMITER_SYMBOL = &quot;@~&quot;;
    public static final int PORT = 9997;

    public static void main(String[] args) throws InterruptedException {
        DelimiterEchoServer delimiterEchoServer = new DelimiterEchoServer();
        System.out.println(&quot;服务器即将启动&quot;);
        delimiterEchoServer.start();
    }

    public void start() throws InterruptedException {
        final DelimiterServerHandler serverHandler = new DelimiterServerHandler();
        EventLoopGroup group = new NioEventLoopGroup();/*线程组*/
        try {
            ServerBootstrap b = new ServerBootstrap();/*服务端启动必须*/
            b.group(group)/*将线程组传入*/
                .channel(NioServerSocketChannel.class)/*指定使用NIO进行网络传输*/
                .localAddress(new InetSocketAddress(PORT))/*指定服务器监听端口*/
                /*服务端每接收到一个连接请求，就会新启一个socket通信，也就是channel，
                所以下面这段代码的作用就是为这个子channel增加handle*/
                .childHandler(new ChannelInitializerImp());
            ChannelFuture f = b.bind().sync();/*异步绑定到服务器，sync()会阻塞直到完成*/
            System.out.println(&quot;服务器启动完成，等待客户端的连接和数据.....&quot;);
            f.channel().closeFuture().sync();/*阻塞直到服务器的channel关闭*/
        } finally {
            group.shutdownGracefully().sync();/*优雅关闭线程组*/
        }
    }

    private static class ChannelInitializerImp extends ChannelInitializer&amp;lt;Channel&amp;gt; {

        @Override
        protected void initChannel(Channel ch) throws Exception {
            ByteBuf delimiter = Unpooled.copiedBuffer(DELIMITER_SYMBOL
                    .getBytes());
            //服务端收到数据包后经过DelimiterBasedFrameDecoder即分隔符基础框架解码器解码为一个个带有分隔符的数据包。
            ch.pipeline().addLast( new DelimiterBasedFrameDecoder(1024,
                    delimiter));
            ch.pipeline().addLast(new DelimiterServerHandler());
        }
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加到&lt;code&gt;ChannelPipeline&lt;/code&gt;的&lt;code&gt;DelimiterBasedFrameDecoder&lt;/code&gt;用于对使用分隔符结尾的消息进行自动解码，当然还有没有用到的&lt;code&gt;FixedLengthFrameDecoder&lt;/code&gt;用于对固定长度的消息进行自动解码等解码器。正如上门的代码使用案例，有了Netty提供的几码器可以轻松地完成对很多消息的自动解码，而且不需要考虑TCP粘包/拆包导致的读半包问题，极大地提升了开发效率。&lt;/p&gt;
&lt;h2 id=&quot;netty示例代码详解&quot;&gt;Netty示例代码详解&lt;/h2&gt;
&lt;p&gt;相信看完上面的铺垫，你对Netty编码有了一定的了解了，下面再来整体梳理一遍吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5660078-d23f9bba3522c20b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;dVp7yn.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、设置&lt;code&gt;EventLoopGroup&lt;/code&gt;线程组(&lt;code&gt;Reactor&lt;/code&gt;线程组)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;EventLoopGroup bossGroup = new NioEventLoopGroup(1);
EventLoopGroup workerGroup = new NioEventLoopGroup();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们说过&lt;code&gt;Netty&lt;/code&gt;中使用&lt;code&gt;Reactor&lt;/code&gt;模式，&lt;code&gt;bossGroup&lt;/code&gt;表示服务器连接监听线程组，专门接受 &lt;code&gt;Accept&lt;/code&gt; 新的客户端&lt;code&gt;client&lt;/code&gt; 连接。另一个&lt;code&gt;workerGroup&lt;/code&gt;表示处理每一连接的数据收发的线程组，来处理消息的读写事件。&lt;/p&gt;
&lt;p&gt;2、服务端引导器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ServerBootstrap serverBootstrap = new ServerBootstrap();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;集成所有配置，用来启动&lt;code&gt;Netty&lt;/code&gt;服务端。&lt;/p&gt;
&lt;p&gt;3、设置&lt;code&gt;ServerBootstrap&lt;/code&gt;信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;serverBootstrap.group(bossGroup, workerGroup);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将两个线程组设置到&lt;code&gt;ServerBootstrap&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;4、设置&lt;code&gt;ServerSocketChannel&lt;/code&gt;类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;serverBootstrap.channel(NioServerSocketChannel.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置通道的&lt;code&gt;IO&lt;/code&gt;类型，&lt;code&gt;Netty&lt;/code&gt;不止支持&lt;code&gt;Java NIO&lt;/code&gt;，也支持阻塞式&lt;code&gt;IO&lt;/code&gt;，例如&lt;code&gt;OIO&lt;/code&gt;&lt;strong&gt;OioServerSocketChannel.class)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5、设置参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;serverBootstrap.option(ChannelOption.SO_BACKLOG, 100);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;option()&lt;/code&gt;方法可以设置很多参数，这里&lt;code&gt;SO_BACKLOG&lt;/code&gt;标识服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，&lt;code&gt;Windows&lt;/code&gt;为200，其他为128，这里设置的是100。&lt;/p&gt;
&lt;p&gt;6、设置&lt;code&gt;Handler&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;serverBootstrap.handler(new LoggingHandler(LogLevel.INFO));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置 &lt;code&gt;ServerSocketChannel&lt;/code&gt;对应的&lt;code&gt;Handler&lt;/code&gt;，这里只能设置一个，它会在&lt;code&gt;SocketChannel&lt;/code&gt;建立起来之前执行。&lt;/p&gt;
&lt;p&gt;7、设置子Handler&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;serverBootstrap.childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
    @Override
    public void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline p = ch.pipeline();
        p.addLast(new LoggingHandler(LogLevel.INFO));
        p.addLast(new ChatNettyHandler());
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Netty&lt;/code&gt;中提供了一种可以设置多个&lt;code&gt;Handler&lt;/code&gt;的途径，即使用&lt;code&gt;ChannelInitializer&lt;/code&gt;方式。&lt;code&gt;ChannelPipeline&lt;/code&gt;是&lt;code&gt;Netty&lt;/code&gt;处理请求的责任链，这是一个&lt;code&gt;ChannelHandler&lt;/code&gt;的链表，而&lt;code&gt;ChannelHandler&lt;/code&gt;就是用来处理网络请求的内容的。&lt;/p&gt;
&lt;p&gt;每一个&lt;code&gt;channel&lt;/code&gt;，都有一个处理器流水线。装配&lt;code&gt;child channel&lt;/code&gt;流水线，调用&lt;code&gt;childHandler()&lt;/code&gt;方法，传递一个&lt;code&gt;ChannelInitializer&lt;/code&gt; 的实例。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;child channel&lt;/code&gt; 创建成功，开始通道初始化的时候，在bootstrap启动器中配置的&lt;code&gt;ChannelInitializer&lt;/code&gt; 实例就会被调用。&lt;/p&gt;
&lt;p&gt;这个时候，才真正的执行去执行 &lt;code&gt;initChannel&lt;/code&gt; 初始化方法，开始通道流水线装配。&lt;/p&gt;
&lt;p&gt;流水线装配，主要是在流水线&lt;code&gt;pipeline&lt;/code&gt;的后面，增加负责数据读写、处理业务逻辑的&lt;code&gt;handler&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;处理器 &lt;code&gt;ChannelHandler&lt;/code&gt; 用来处理网络请求内容，有&lt;code&gt;ChannelInboundHandler&lt;/code&gt;和&lt;code&gt;ChannelOutboundHandler&lt;/code&gt;两种，&lt;code&gt;ChannlPipeline&lt;/code&gt;会从头到尾顺序调用&lt;code&gt;ChannelInboundHandler&lt;/code&gt;处理网络请求内容，从尾到头调用&lt;code&gt;ChannelOutboundHandler&lt;/code&gt;处理网络请求内容&lt;/p&gt;
&lt;p&gt;8、绑定端口号&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ChannelFuture f = serverBootstrap.bind(PORT).sync();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;绑定端口号&lt;/p&gt;
&lt;p&gt;9、等待服务端端口号关闭&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;f.channel().closeFuture().sync();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等待服务端监听端口关闭，&lt;code&gt;sync()&lt;/code&gt;会阻塞主线程，内部调用的是 &lt;code&gt;Object&lt;/code&gt; 的 &lt;code&gt;wait()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;10、关闭EventLoopGroup线程组&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;bossGroup.shutdownGracefully();
workerGroup.shutdownGracefully();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章主要是从一个&lt;code&gt;demo&lt;/code&gt;作为引子，然后介绍了&lt;code&gt;Netty&lt;/code&gt;的包结构、&lt;code&gt;Reactor&lt;/code&gt;模型、编程规范等等，目的很简单，希望你能够读懂这段&lt;code&gt;demo&lt;/code&gt;并写出来。&lt;/p&gt;
&lt;p&gt;后面开始继续&lt;code&gt;Netty&lt;/code&gt;源码解析部分，敬请期待。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;《Netty in Action》书籍&lt;/li&gt;
&lt;li&gt;慕课Netty专栏&lt;/li&gt;
&lt;li&gt;掘金闪电侠Netty小册&lt;/li&gt;
&lt;li&gt;芋道源码Netty专栏&lt;/li&gt;
&lt;li&gt;Github[fork from krcys]&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;感谢Netty专栏作者们优秀的文章内容~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/22/172d9428e6afd974?w=900&amp;amp;h=383&amp;amp;f=png&amp;amp;s=100094&quot; alt=&quot;原创干货分享.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Aug 2020 22:27:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>高清思维导图原件(xmind/pdf/jpg)可以关注公众号：一枝花算不算浪漫 回复netty01即可。 前言 上一篇文章讲了NIO相关的知识点，相比于传统IO，NIO已经做得很优雅了，为什么我们还要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/13557635.html</dc:identifier>
</item>
<item>
<title>Springboot中登录后关于cookie和session拦截案例 - 幸子在神奈川</title>
<link>http://www.cnblogs.com/tenghw/p/13557327.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tenghw/p/13557327.html</guid>
<description>&lt;h3 id=&quot;一、前言&quot;&gt;一、前言&lt;/h3&gt;
&lt;p&gt;1、简单的登录验证可以通过Session或者Cookie实现。&lt;br/&gt;2、每次登录的时候都要进数据库校验下账户名和密码，只是加了cookie 或session验证后；比如登录页面A，登录成功后进入页面B，若此时cookie过期，在页面B中新的请求url到页面c,系统会让它回到初始的登录页面。（类似单点登录sso（single sign on））。&lt;br/&gt;3、另外，无论基于Session还是Cookie的登录验证，都需要对HandlerInteceptor进行配置，增加对URL的拦截过滤机制。&lt;/p&gt;
&lt;h3 id=&quot;二、利用cookie进行登录验证&quot;&gt;二、利用Cookie进行登录验证&lt;/h3&gt;
&lt;p&gt;1、配置拦截器代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-@Slf4j&quot;&gt;public class CookiendSessionInterceptor implements HandlerInterceptor {     

@Override     
public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {         
      log.debug(&quot;进入拦截器&quot;);         
      Cookie[] cookies = request.getCookies();         
      if(cookies!=null &amp;amp;&amp;amp; cookies.length&amp;gt;0){             
            for(Cookie cookie:cookies) {                
                  log.debug(&quot;cookie===for遍历&quot;+cookie.getName());                 
                  if (StringUtils.equalsIgnoreCase(cookie.getName(), &quot;isLogin&quot;)) {                     
                        log.debug(&quot;有cookie ---isLogin，并且cookie还没过期...&quot;);                     
                       //遍历cookie如果找到登录状态则返回true继续执行原来请求url到controller中的方法                     
                        return true;                 
                              }             
                        }         
                  }         
            log.debug(&quot;没有cookie-----cookie时间可能到期，重定向到登录页面后请重新登录。。。&quot;);         
            response.sendRedirect(&quot;index.html&quot;);         
            //返回false，不执行原来controller的方法         
            return false;     }     

  @Override     
  public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {   
     }     
  @Override   
  public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    
      }  

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在Springboot中拦截的请求不管是配置监听器(定义一个类实现一个接口HttpSessionListener )、过滤器、拦截器,都要配置如下此类实现一个接口中的两个方法。&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration 
public class WebConfig implements WebMvcConfigurer {     
// 这个方法是用来配置静态资源的，比如html，js，css，等等     
@Override     
public void addResourceHandlers(ResourceHandlerRegistry registry) {   
  }    

 // 这个方法用来注册拦截器，我们自己写好的拦截器需要通过这里添加注册才能生效    
@Override     
public void addInterceptors(InterceptorRegistry registry) {         
//addPathPatterns(&quot;/**&quot;) 表示拦截所有的请求         
//excludePathPatterns(&quot;/firstLogin&quot;,&quot;/zhuce&quot;);设置白名单，就是拦截器不拦截。首次输入账号密码登录和注册不用拦截！       
//登录页面在拦截器配置中配置的是排除路径，可以看到即使放行了，还是会进入prehandle，但是不会执行任何操作。         
registry.addInterceptor(new CookiendSessionInterceptor()).addPathPatterns(&quot;/**&quot;).excludePathPatterns(&quot;/&quot;,                                      
                                                                                                     &quot;/**/login&quot;,                                     
                                                                                                     &quot;/**/*.html&quot;,                                     
                                                                                                     &quot;/**/*.js&quot;,                                     
                                                                                                     &quot;/**/*.css&quot;,                                      
                                                                                                     &quot;/**/*.jpg&quot;);   
   } 

 }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.前台登录页面index.html（我把这个html放在静态资源了，也让拦截器放行了此路由url）&lt;br/&gt;前端测试就是一个简单的form表单提交&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--测试cookie和sessionid--&amp;gt; 
&amp;lt;form action=&quot;/login&quot; method=&quot;post&quot;&amp;gt;     
  账号：&amp;lt;input type=&quot;text&quot; name=&quot;name1&quot; placeholder=&quot;请输入账号&quot;&amp;gt;&amp;lt;br&amp;gt;     
  密码：&amp;lt;input type=&quot;password&quot; name=&quot;pass1&quot; placeholder=&quot;请输入密码&quot;&amp;gt;&amp;lt;br&amp;gt;     
  &amp;lt;input type=&quot;submit&quot; value=&quot;登录&quot;&amp;gt; 
&amp;lt;/form&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、后台控制层Controller业务逻辑：登录页面index.html，登录成功后 loginSuccess.html。&lt;br/&gt;在loginSuccess.html中可提交表单进入次页demo.html，也可点击“退出登录”后台清除没有超时的cookie，并且回到初始登录页面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Controller 
@Slf4j 
@RequestMapping(value = &quot;/&quot;) 
public class TestCookieAndSessionController {     
@Autowired     JdbcTemplate jdbcTemplate;     
/**      * 首次登录，输入账号和密码，数据库验证无误后，响应返回你设置的cookie。再次输入账号密码登录或者首次登录后再请求下一个页面，就会在请求头中携带cookie,      * 前提是cookie没有过期。      * 此url请求方法不管是首次登录还是第n次登录，拦截器都不会拦截。      * 但是每次（首次或者第N次）登录都要进行，数据库查询验证账号和密码。      * 做这个目的是如果登录页面A，登录成功后进页面B，页面B有链接进页面C，如果cookie超时，重新回到登录页面A。（类似单点登录）      */     

@PostMapping(value = &quot;login&quot;)     
public String test(HttpServletRequest request, HttpServletResponse response, @RequestParam(&quot;name1&quot;)String name,@RequestParam(&quot;pass1&quot;)String pass) throws Exception{         
  try {             
    Map&amp;lt;String, Object&amp;gt; result= jdbcTemplate.queryForMap(&quot;select * from userinfo where name=? and password=?&quot;, new Object[]{name, pass});             
      if(result==null || result.size()==0){                 
         log.debug(&quot;账号或者密码不正确或者此人账号没有注册&quot;);                 
         throw new Exception(&quot;账号或者密码不正确或者此人账号没有注册！&quot;);             
      }else{                 
         log.debug(&quot;查询满足条数----&quot;+result);                 
         Cookie cookie = new Cookie(&quot;isLogin&quot;, &quot;success&quot;);                 
         cookie.setMaxAge(30);                 
         cookie.setPath(&quot;/&quot;);                
         response.addCookie(cookie);                 
         request.setAttribute(&quot;isLogin&quot;, name);                 
         log.debug(&quot;首次登录，查询数据库用户名和密码无误，登录成功，设置cookie成功&quot;);                 
         return &quot;loginSuccess&quot;;             }         
  } catch (DataAccessException e) {             
         e.printStackTrace();             
         return &quot;error1&quot;;         
      }    
  } 
    
/**测试登录成功后页面loginSuccess ，进入次页demo.html*/     
@PostMapping(value = &quot;sub&quot;)     
public String test() throws Exception{        
  return  &quot;demo&quot;;     
 }     
/** 能进到此方法中，cookie一定没有过期。因为拦截器在前面已经判断力。过期，拦截器重定向到登录页面。过期退出登录，清空cookie。*/    
@RequestMapping(value = &quot;exit&quot;,method = RequestMethod.POST)     
public String exit(HttpServletRequest request,HttpServletResponse response) throws Exception{         
  Cookie[] cookies = request.getCookies();         
  for(Cookie cookie:cookies){            
    if(&quot;isLogin&quot;.equalsIgnoreCase(cookie.getName())){                
      log.debug(&quot;退出登录时,cookie还没过期，清空cookie&quot;);                 
      cookie.setMaxAge(0);                 
      cookie.setValue(null);                 
      cookie.setPath(&quot;/&quot;);                
      response.addCookie(cookie);                
      break;             
       }         
     }         
  //重定向到登录页面         
   return  &quot;redirect:index.html&quot;;     
     } 

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、效果演示：&lt;br/&gt;①在登录“localhost:8082”输入账号登录页面登录：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825004359025-1999872610.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②拦截器我设置了放行/login，所以请求直接进Controller相应的方法中：&lt;br/&gt;日志信息如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825004617255-1307204884.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;下图可以看出，浏览器有些自带的不止一个cookie，这里不要管它们。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825004718359-1784740669.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③在loginSuccess.html，进入次页demo.html。cookie没有过期顺利进入demo.html，并且/sub方法经过拦截器（此请求请求头中携带cookie）。&lt;br/&gt;过期的话直接回到登录页面（这里不展示了）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825004824554-167947810.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;④在loginSuccess.html点击“退出登录”，后台清除我设置的没过期的cookie=isLogin,回到登录页面。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;三、利用session进行登录验证&quot;&gt;三、利用Session进行登录验证&lt;/h3&gt;
&lt;p&gt;1、修改拦截器配置略微修改下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825004927153-668778034.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Interceptor也略微修改下：还是上面的preHandle方法中：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825004952391-842816912.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.核心&lt;br/&gt;前端我就不展示了，就是一个form表单action=&quot;login1&quot;&lt;br/&gt;后台代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**利用session进行登录验证*/    
@RequestMapping(value = &quot;login1&quot;,method = RequestMethod.POST)     
public String testSession(HttpServletRequest request,
                          HttpServletResponse response,
                          @RequestParam(&quot;name1&quot;)String name,                        
                          @RequestParam(&quot;pass1&quot;)String pass) throws Exception{         
  try {            
    Map&amp;lt;String, Object&amp;gt; result= jdbcTemplate.queryForMap(&quot;select * from userinfo where name=? and password=?&quot;, new Object[]{name, pass});             
      if(result!=null &amp;amp;&amp;amp; result.size()&amp;gt;0){                 
        String requestURI = request.getRequestURI();                 
        log.debug(&quot;此次请求的url:{}&quot;,requestURI);                 
        HttpSession session = request.getSession();                 
        log.debug(&quot;session=&quot;+session+&quot;session.getId()=&quot;+session.getId()+&quot;session.getMaxInactiveInterval()=&quot;+session.getMaxInactiveInterval());                 
        session.setAttribute(&quot;isLogin1&quot;, &quot;true1&quot;);             
     }         
   } catch (DataAccessException e) {             
       e.printStackTrace();            
       return &quot;error1&quot;;        
 }      
    return  &quot;loginSuccess&quot;;    
  }    

 //登出，移除登录状态并重定向的登录页     
@RequestMapping(value = &quot;/exit1&quot;, method = RequestMethod.POST)     
public String loginOut(HttpServletRequest request) {         
  request.getSession().removeAttribute(&quot;isLogin1&quot;);         
  log.debug(&quot;进入exit1方法，移除isLogin1&quot;);         
  return &quot;redirect:index.html&quot;;     
  }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志如下：可以看见springboot内置的tomcat中sessionid就是请求头中的jsessionid，而且默认时间1800秒（30分钟）。&lt;br/&gt;我也不清楚什么进入拦截器2次，因为我login1设置放行了，肯定不会进入拦截器。可能是什么静态别的什么资源吧。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825005439075-141673961.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;session.getId()=F88CF6850CD575DFB3560C3AA7BEC89F==下图的JSESSIONID&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825005600367-1179138658.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;//点击退出登录，请求退出url的请求头还是携带JSESSIONID,除非浏览器关掉才消失。（该session设置的属性isLogin1移除了，session在不关浏览器情况下或者超过默认时间30分钟后，session才会自动清除！）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825005653973-489899796.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825005744557-532701420.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;四、完结&quot;&gt;四、完结&lt;/h3&gt;
&lt;p&gt;文章如有错误的地方，还请指教一下！&lt;br/&gt;我是码农小伟，谢谢小伙伴观看，给我关注点个赞，谢谢大家！&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048038/202008/2048038-20200825010143240-221408760.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Aug 2020 17:03:00 +0000</pubDate>
<dc:creator>幸子在神奈川</dc:creator>
<og:description>一、前言 1、简单的登录验证可以通过Session或者Cookie实现。 2、每次登录的时候都要进数据库校验下账户名和密码，只是加了cookie 或session验证后；比如登录页面A，登录成功后进入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tenghw/p/13557327.html</dc:identifier>
</item>
<item>
<title>NET Core Kestrel部署HTTPS 一个服务器绑一个证书 一个服务器绑多个证书 - FreeTimeWorker</title>
<link>http://www.cnblogs.com/zzfstudy/p/13557309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzfstudy/p/13557309.html</guid>
<description>&lt;p&gt;&lt;span&gt; .net core 3.0 网站发布到centos后，绑定ssl证书，一个服务器绑一个证书，一个服务器绑多个证书&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;开始之前：对于windows服务器不存在这个问题，在iis中绑定证书是非常简单的一件事，不是本篇博客讨论的范围，绑定多个证书一样&lt;/p&gt;
&lt;p&gt;3.0中指定url的方式可以通过在配置文件中加urls:&quot;http://*:5000&quot;这种方式来指定&lt;/p&gt;
&lt;p&gt;发布到centos的.net core网站我是用 Kestrel托管的。这里也只针对这一种情况进行描述&lt;/p&gt;
&lt;p&gt;1,在program.cs中CreateHostBuilder 替换成如下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;()
                    .UseKestrel((context, options) =&amp;gt;
                    {
                        options.Configure(context.Configuration.GetSection(&quot;Kestrel&quot;));
                    });
                });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这段代码描述的是Kestrel服务的option从配置文件中读取&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;紧接着在startup中增加 app.UseHttpsRedirection(); app.UseHsts();//默认是开启的，如果是，就不用管它&lt;/p&gt;
&lt;p&gt;2，在配置文件appsettings.json中增加，这是单独的配置节点 ，其中path，是pfx文件的位置，password是证书的密码，在阿里云申请的证书，下载iis版的就有这两&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Kestrel&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Limits&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MaxRequestBodySize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9223372036854775807&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MaxRequestBufferSize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9223372036854775807&lt;/span&gt;&lt;span&gt;,
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MaxRequestLineSize&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9223372036854775807&lt;/span&gt;&lt;span&gt;
    },
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Endpoints&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Https&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://*:443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Certificate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/home/cert/www.xxxx.pfx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Password&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        }
      }
    }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;这里的配置项可以参考微软的文档,基本上大多数需要代码显式指定的配置在&lt;/strong&gt;appsettings.json&lt;strong&gt;中都是可以直接配置的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考文档地址：&lt;/strong&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.1#endpoint-configuration&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/servers/kestrel?view=aspnetcore-3.1#endpoint-configuration&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果一台服务器里边只有一个需要ssl证书的网站，那么到这里，问题就解决了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很不幸，我的目标是在一台服务器里边使用两个ssl证书，分别对两个网站做ssl传输加密，在查过微软的部分文档后，没有找到相关的解决方案，反而是找到了nginx。在linux用nginx可以解决一台服务器绑定两个ssl的问题&lt;/p&gt;
&lt;p&gt;首先是安装：yum install nginx,一路y,安装完毕后，nginx的主配置文件是   &lt;strong&gt;/etc/nginx/nginx.conf &lt;/strong&gt;直接修改这个文件，分别对N个需要ssl的站点进行配置,如下，监听端口都是443，区别是server_name ,根据需要配置的域名，分别写对应的server_name,&lt;/p&gt;
&lt;p&gt;加粗部分是需要特别关注的，pem，和key这两 如果是在阿里云申请的ssl，下载的时候选择 nginx版的，就包含下边需要的两文件，可以放到任意位置，这里填写的是这两文件的路径，location里边的内容是转发的本地端口对应的就是域名对应的子网站。子网站必须是发布了的，可访问的站点，另外需要特别注意一下&lt;strong&gt;子网站不需要任何证书，只需要可以访问即可&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
       listen &lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt;;
       server_name &lt;strong&gt;serverName1.com&lt;/strong&gt;;
       ssl on;
       root &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
       ssl_certificate &lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxx.pem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;;
       ssl_certificate_key &lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxx.key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;;
       ssl_session_cache shared:SSL:1m;
       ssl_session_timeout  10m;
       ssl_ciphers PROFILE&lt;/span&gt;=&lt;span&gt;SYSTEM;
       ssl_prefer_server_ciphers on;
       include &lt;/span&gt;/etc/nginx/&lt;span&gt;default&lt;/span&gt;.d&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf;
       location / {
            &lt;strong&gt;proxy_pass &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;http://127.0.0.1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;:5000;&lt;/strong&gt;
       }
       error_page 404 /404.html;
           location = /40x.html {
       }

       error_page 500 502 503 504 /50x.html;
           location = /50x.html {
       }
   }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;server {
       listen &lt;/span&gt;&lt;span&gt;443&lt;/span&gt;&lt;span&gt;;
       server_name &lt;strong&gt;serverName2.com&lt;/strong&gt;;
       ssl on;
       root &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
       ssl_certificate &lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxx.pem&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;;
       ssl_certificate_key &lt;/span&gt;&lt;strong&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxxx.key&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;;
       ssl_session_cache shared:SSL:1m;
       ssl_session_timeout  10m;
       ssl_ciphers PROFILE&lt;/span&gt;=&lt;span&gt;SYSTEM;
       ssl_prefer_server_ciphers on;
       include &lt;/span&gt;/etc/nginx/&lt;span&gt;default&lt;/span&gt;.d&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;.conf;
       location / {
            &lt;strong&gt;proxy_pass &lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;http://127.0.0.1&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;:5001;&lt;/strong&gt;
       }
       error_page 404 /404.html;
           location = /40x.html {
       }

       error_page 500 502 503 504 /50x.html;
           location = /50x.html {
       }
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后启动nginx服务  systemctl restart nginx.service .如果配置文件写的有问题，服务会启动失败，错误日志位置在nginx.conf中可以找到&lt;/p&gt;
&lt;p&gt;服务启动完毕后，就可以看到效果了&lt;/p&gt;
</description>
<pubDate>Mon, 24 Aug 2020 16:00:00 +0000</pubDate>
<dc:creator>FreeTimeWorker</dc:creator>
<og:description>.net core 3.0 网站发布到centos后，绑定ssl证书，一个服务器绑一个证书，一个服务器绑多个证书 开始之前：对于windows服务器不存在这个问题，在iis中绑定证书是非常简单的一件事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzfstudy/p/13557309.html</dc:identifier>
</item>
</channel>
</rss>