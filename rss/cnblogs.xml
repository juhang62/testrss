<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>es6 扩展运算符 ... - 风吹De麦浪</title>
<link>http://www.cnblogs.com/CandyManPing/p/10520533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CandyManPing/p/10520533.html</guid>
<description>&lt;p&gt;es6 新增了很多特性，其中包括扩展运算符 ...，扩展运算符使用场景比较多，而且使用在不同的场景所表达的意思是不一样的。总结如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;rest 参数&lt;/li&gt;
&lt;li&gt;数组的扩展运算符&lt;/li&gt;
&lt;li&gt;对象的扩展运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&lt;span&gt;我们都知道arguments对象不是一个真正的数组，所以es6 推出了一种新的写法 如下：&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; say(...name) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     name.forEach(item =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;        console.log(item)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     }) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;joel,vue,js&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     console.log(name &lt;span&gt;instanceof&lt;/span&gt; Array) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; say('joel','vue','js')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种在function形参中使用三个点 &lt;span&gt;&lt;span&gt;&lt;strong&gt;...&lt;/strong&gt; &lt;/span&gt; &lt;span&gt;表示&lt;/span&gt;&lt;/span&gt;用于获取函数的多余参数（把多余的参数序列转为一个数组），这样就不需要使用&lt;code&gt;arguments&lt;/code&gt;对象了。rest 参数的变量是一个数组，该变量将一组参数放入数组中。&lt;/p&gt;
&lt;p&gt;rest 参数只能是最后一个形参，而且函数的&lt;code&gt;length&lt;/code&gt;属性，不包括 rest 参数。&lt;/p&gt;

&lt;p&gt;在数组中使用 ... 扩展运算符，就好像是rest 参数的反运算  如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; let array = [123,211,332,412,125,236,237,787&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; console.log(Math.max(...array))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把一个数组转为用逗号分隔的参数序列。&lt;/p&gt;

&lt;p&gt;对象的扩展运算符分为两种，一种是在解构赋值中，如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4&lt;span&gt; };
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; console.log(z) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {a:3,b:4}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;相当于把目标对象自身的所有可遍历、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。&lt;/p&gt;
&lt;p&gt;由于解构赋值要求等号右边是一个对象，所以如果等号右边是&lt;code&gt;undefined&lt;/code&gt;或&lt;code&gt;null&lt;/code&gt;，就会报错，因为它们无法转为对象。&lt;/p&gt;
&lt;p&gt;解构赋值必须是最后一个参数，否则会报错。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; let { x, ...z, y } = { x: 1, y: 2, a: 3, b: 4 }; // 语法错误
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外一种是非解构赋值中，如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let obj =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     name: 'joel'&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     age: '20'&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    tempObj: {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         name: 'tempJoel'
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; let temp =&lt;span&gt; {...obj}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; temp.tempObj = 'joel29'
&lt;span&gt;10&lt;/span&gt; console.log(temp) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {name: &quot;joel&quot;, age: &quot;20&quot;, tempObj: &quot;joel29&quot;}&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; console.log(obj.tempObj) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {name: &quot;tempJoel&quot;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;取出参数对象的所有可遍历属性，拷贝到当前对象之中。 如上代码，这种拷贝不是浅拷贝，只有在解构赋值的拷贝是浅拷贝， 如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; let obj =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     name: 'joel'&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     age: '20'&lt;span&gt;, 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    tempObj: {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         name: 'tempJoel'
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; let temp =&lt;span&gt; {...obj}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; temp.tempObj.name='tempJoel修改'
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;console.log(temp)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; console.log(obj)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/825196/201903/825196-20190312234522583-603423350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们是修改temp 对象的tempObj，但是obj对象中的tempObj中的name也同步修改了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;在对象的扩展运算符中都是把目标的对象的属性拷贝到对象中，如果是解构是存在浅拷贝 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在es6 中统一了遍历的接口 Iterator，Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即&lt;code&gt;for...of&lt;/code&gt;循环。&lt;/p&gt;
&lt;p&gt;扩展运算符（...）内部其实是调用了 Iterator 接口。&lt;/p&gt;

&lt;p&gt;rest 参数&lt;/p&gt;
&lt;p&gt;数组的扩展运算符&lt;/p&gt;
&lt;p&gt;对象的扩展运算符&lt;/p&gt;

</description>
<pubDate>Tue, 12 Mar 2019 22:55:00 +0000</pubDate>
<dc:creator>风吹De麦浪</dc:creator>
<og:description>es6 新增了很多特性，其中包括扩展运算符 ...，扩展运算符使用场景比较多，而且使用在不同的场景所表达的意思是不一样的。总结如下 rest 参数 数组的扩展运算符 对象的扩展运算符 rest 参数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CandyManPing/p/10520533.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]功能设置 - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_setting.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_setting.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 652+）&lt;/p&gt;


&lt;p&gt;XCode支持SqlServer、SQLite、MySql、Oracle、PostgreSQL、Access、SqlCe等多种数据库，常用连接字符串模板如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;SQLite&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=test.db;&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;Sqlite&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;MySql&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Server=.;Port=3306;Database=mysql;Uid=root;Pwd=;&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;MySql.Data.MySqlClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;MSSQL&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Server=.;User ID=sa;Password=sa;Database=Test;datapath=~\App_Data&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.SqlClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Oracle&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=Tcp://127.0.0.1/ORC;User ID=sys;Password=admin;Owner=mis&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.OracleClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;PostgreSQL&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Server=.;Database=master;Uid=root;Pwd=root;&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;PostgreSQL.Data.PostgreSQLClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;MSSQL&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Server=.;Integrated Security=SSPI;Database=Test&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.SqlClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Oracle&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=orc;User ID=sys;Password=admin;&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;System.Data.OracleClient&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;OLE DB Services=-1表示打开连接池&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;Access&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Provider=Microsoft.Jet.OLEDB.4.0; Data Source=~\App_Data\Test.mdb;Persist Security Info=False;OLE DB Services=-1&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;Access&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;add &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;SqlCe&quot;&lt;/span&gt;&lt;span&gt; connectionString&lt;/span&gt;&lt;span&gt;=&quot;Data Source=test.sdf;&quot;&lt;/span&gt;&lt;span&gt; providerName&lt;/span&gt;&lt;span&gt;=&quot;SqlCe&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;连接字符串最常见的地方就是app.config/web.config中的connectionStrings段。&lt;/p&gt;
&lt;p&gt;这里特别注意name，正是数据模型中讲到的&lt;span&gt;&lt;strong&gt;连接名ConnName&lt;/strong&gt;&lt;/span&gt;！这个name一般取业务模块名字，上面的名字仅仅是为了表示这是哪一种数据库，实际项目中有用户自己起名字。&lt;/p&gt;
&lt;p&gt;每个数据模型生成的实体类都有一个ConnName设置，表明该实体类需要使用哪一个连接，后面是连接字符串和数据库类型。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意！！！划重点！！！XCode实体类支持任意切换数据库，完全由连接字符串和providerName决定所要使用的数据库！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在这里，强烈推荐开发环境使用SQLite，生产环境再更换SqlServer/MySql/Oracle的连接字符串。&lt;/p&gt;

&lt;p&gt;验证连接的办法也很简单，&lt;span&gt;var dal=DAL.Create(ConnName)&lt;/span&gt;即可！&lt;/p&gt;
&lt;p&gt;DAL是XCode数据层总入口，针对数据库的任何操作都通过该类桥接。&lt;/p&gt;
&lt;p&gt;其中&lt;span&gt;DAL.ConnStrs&lt;/span&gt;管理着所有的连接名以及对应的连接字符串，DAL.Create(connName)时从中查找并针对连接名创建单一实例（每个连接名一个DAL实例）。&lt;/p&gt;
&lt;p&gt;也可以通过&lt;span&gt;&lt;strong&gt;DAL.AddConnStr(&quot;school&quot;, &quot;Data Source=school.db;&quot;, null, &quot;MySql&quot;)&lt;/strong&gt;&lt;/span&gt;来动态添加连接名以及连接字符串，最后一个参数写数据库名。&lt;/p&gt;

&lt;p&gt;连接字符串的第三种使用方式，也是最高级的一种，支持&lt;span&gt;DAL.OnResolve&lt;/span&gt;委托，当配置文件或动态配置中找不到相应连接名时，执行该委托。&lt;/p&gt;
&lt;p&gt;为了&lt;strong&gt;&lt;span&gt;集成配置中心&lt;/span&gt;&lt;/strong&gt;（例如新生命团队的开源项目星尘Stardust），一般在应用初始化时注册DAL.OnResolve到外部配置中心。&lt;/p&gt;

&lt;p&gt;最后，如果没有任何地方设置某个连接名，并且配置中心也没有找到，XCode将会自动创建一个SQLite连接字符串。&lt;/p&gt;
&lt;p&gt;因此，XCode实体类永远不会提示找不到连接字符串，而是会自动为了创建SQLite连接，并且建库建表。&lt;/p&gt;


&lt;p&gt;标准配置文件位于Config/XCode.config，首次使用时自动创建，也可以通过XCode.Setting.Current来读写&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;XCode设置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Setting&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;调试&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Debug&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;输出SQL。是否输出SQL语句，默认启用&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ShowSQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;true&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ShowSQL&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;SQL目录。设置SQL输出的单独目录，默认为空，SQL输出到当前日志中。生产环境建议输出到站点外单独的SqlLog目录&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SQLPath&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SQLPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;SQL执行时间。跟踪SQL执行时间，大于该阀值将输出日志，默认1000毫秒&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TraceSQLTime&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1000&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TraceSQLTime&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;连接映射。连接名映射#，表名映射@，把实体类中的Test2和Test3连接名映射到Test去&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ConnMaps&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ConnMaps&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;参数化添删改查。默认关闭&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;UseParameter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;UseParameter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;SQLite默认目录。没有设置连接字符串的连接默认创建SQLite连接，数据库放在该目录&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SQLiteDbPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;..\Data&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SQLiteDbPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;备份目录。备份数据库时存放的目录&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;BackupPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;..\Backup&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;BackupPath&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;命令超时。查询执行超时时间，默认0秒不限制&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CommandTimeout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;CommandTimeout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;数据层缓存。默认0秒&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;DataCacheExpire&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;DataCacheExpire&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;实体缓存过期。整表缓存实体列表，默认10秒&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EntityCacheExpire&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;EntityCacheExpire&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;单对象缓存过期。按主键缓存实体，默认10秒&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;SingleCacheExpire&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;SingleCacheExpire&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;扩展属性过期。扩展属性Extends缓存，默认10秒&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ExtendExpire&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;10&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ExtendExpire&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;反向工程。Off 关闭；ReadOnly 只读不执行；On 打开，仅新建；Full 完全，修改删除&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Migration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;On&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Migration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Setting&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;各配置项解释：&lt;/p&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li&gt;Debug。顾名思义，这是XCode的调试开关，打开后，日志中会多写一些东西，告诉你它正在做什么事情，分析问题的时候可以打开，如果嫌日志太少也可以打开，咱们日志性能很好不用担心；&lt;/li&gt;
&lt;li&gt;ShowSQL。显示每一个执行的SQL语句，可能是配置中最常用的一个配置项，可以在日志中明明白白看到应用在执行啥数据库操作，每分钟执行超过30次的中大型应用务必关闭，否则光日志就能写爆磁盘；&lt;/li&gt;
&lt;li&gt;SQLPath。SQL日志默认跟普通日志放在一起，设置该相对路径后，可以独立存放；&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;TraceSQLTime。慢日志跟踪时间，默认1000ms，执行时间超过此值的SQL将输出在日志中（常规日志，非SQL日志），对于中大型系统分析问题非常有用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;UseParameter。使用参数名查询，默认false，设置为true时执行的添删改查将使用参数化操作。该参数也可以写在连接字符串中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SQLiteDbPath。没有给连接名设置任何连接字符串时，默认生成SQLite数据库，该设置是存放这些默认SQLite数据库的目录；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CommandTimeout。命令执行超时时间，默认0不限制，可根据应用需要设为15秒或30秒；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;DataCacheExpire。数据层缓存（一级缓存）有效期，以select语句为key缓存结果数据集，任何添删改操作或过期时清空缓存。默认0秒，web前台网站建议设为10秒；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;EntityCacheExpire。实体缓存（二级缓存）有效期，上一章有提到Meta.Cache对应实体缓存，默认10秒，过期后继续返回旧数据并异步更新，添删改操作清空；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SingleCacheExpire。对象缓存（三级缓存）有效期，上一章有提到Meta.SingleCache，默认10秒，过期后继续返回旧数据并异步更新，添删改操作清空；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ExtendExpire。扩展属性有效期，上一章扩展属性部分有提到Extends带有的缓存效果，默认10秒；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Migration。反向工程，自动建库建表加字段改字段等，就靠它设置。Off 关闭；ReadOnly 只读不执行；On 打开，仅新建；Full 完全，修改删除。默认On仅新建，经验表明最合理；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上面的设置对整个应用全局有效，而需要针对具体某个连接进行控制，可以把设置项写在连接字符串中，该功能最常用的场景就是配置中心。&lt;/p&gt;
&lt;p&gt;高级设置如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ShowSQL。用法同上，针对性打开SQL日志&lt;/li&gt;
&lt;li&gt;UseParameter。用法同上，针对性打开参数化&lt;/li&gt;
&lt;li&gt;Migration。用法同上，可针对连接控制是否打开反向工程，某些只读连接可以设置Off&lt;/li&gt;
&lt;li&gt;DataCache。用法同上DataCacheExpire，针对性设置当前连接&lt;/li&gt;
&lt;li&gt;Readonly。该连接是否只读，只读连接在数据层禁止执行Insert/Update/Delete&lt;/li&gt;
&lt;li&gt;TablePrefix。该连接下所有表名增加前缀，适用于多个系统共用一个库，避免不同系统的表名重名&lt;/li&gt;
&lt;li&gt;Owner。拥有者，数据表所在Schema和登录用户不一致时，需要设置数据表所在Schema（Oracle中所属用户）&lt;/li&gt;
&lt;li&gt;Provider。提供者，数据库类型，特用于配置中心，便于在连接字符串中指定数据库类型&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;SQLite数据库的连接字符串有特殊支持，外部没有设置时，自动配置WAL等以极大提高性能。（提升效果可参考飞仙 http://feixian.newlifex.com ）&lt;/p&gt;
&lt;p&gt;此外，MySql和Oracle的数据源还支持 Data Source=tcp://10.0.0.3:1234/racdb 的简写用法。&lt;/p&gt;
&lt;p&gt;XCode配置Debug为true时，日志会输出调整好的最终连接字符串，可用于学习。&lt;/p&gt;


&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;高级增删改。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;脏数据。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;增量累加。高并发统计&lt;/li&gt;
&lt;li&gt;事务处理。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;扩展属性。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;高级查询。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;数据层缓存。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;实体缓存。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;对象缓存。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;百亿级性能。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;实体工厂。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;角色权限。Membership&lt;/li&gt;
&lt;li&gt;导入导出。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;分表分库。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;高级统计。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;批量写入。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;实体队列。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;备份同步。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;数据服务。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;大数据分析。ETL抽取，调度计算处理，结果持久化&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Tue, 12 Mar 2019 16:05:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>新生命团队的数据中间件NewLife.XCode，有其独特的配置方式，支持集成配置中心，代表作有百亿级大数据实时计算项目！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/xcode_setting.html</dc:identifier>
</item>
<item>
<title>lvs dr 模型配置详解 - 陈扬天</title>
<link>http://www.cnblogs.com/fengwenzhee/p/10520517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengwenzhee/p/10520517.html</guid>
<description>&lt;p&gt;前期准备：&lt;/p&gt;
&lt;p&gt;两台服务器 note01(lvs服务器) note02(real sever)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1 首先在note01配置子网卡：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ifconfig eth0:&lt;span&gt;2&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.100&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   :2意思是eth0的子接口，随便一个数字就可以，/24意为 255.255.255.0的另一种写法 也可以写成netmask 255.255.255.0&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2 配置note01 转发方式：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
echo &lt;span&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/ip_forward
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   默认为0 意思为如果没有对应请求的IP，会将数据包丢弃，1为不会丢弃，而是通过路由来去转发请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3 配置note02(real sever) 的响应，通告级别，禁止响应对VIP的ARP广播请求&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
echo &lt;span&gt;1&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/eth0/&lt;span&gt;arp_ignore

echo &lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &amp;gt; /proc/sys/net/ipv4/conf/eth0/arp_announce
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;4 配置note02 的环回IP:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ifconfig lo:&lt;span&gt;5&lt;/span&gt; &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.100&lt;/span&gt; netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  注意，这里:5与上边一样，可以随便写，但是后边必须写成netmask 255.255.255.255&lt;/p&gt;
&lt;p&gt;这里为什么是4个255？  因为网关192.168.64.0 是通过IP和 这个掩码进行云算计算出来的，如果这里也写成3个255，就会出现两个192.168.64.0，而lo环回接口要比eth0接口更为接近os内核，所以请求不会返回，而是直接进入环回接口，所以客户端可以发送请求，但是不会收到响应。&lt;/p&gt;
&lt;p&gt;第3 4 步顺序一定一定一定不能颠倒，否则还没有配置好接口就已经通告出去了，就不会起作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5 为了检验lvs,我使用httpd服务进行一个简单验证，真实情况肯定就是在realsever上开启项目啦！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在note02 上执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yum install httpd -y
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;安装httpd服务&lt;/p&gt;
&lt;p&gt;进入目录/var/www/html&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
cd /&lt;span&gt;var&lt;/span&gt;/www/&lt;span&gt;html

vi index.html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在index.html中写入from 192.168.64.134(note02的真实IP)进行验证&lt;/p&gt;
&lt;p&gt;执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service httpd start
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;客户端验证：rip:80 可以正常显示&lt;/p&gt;
&lt;p&gt;　　　　　　vip:80不能正常显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234028131-1557164132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234037854-727469018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置lvs vip note01&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yum install ipvsadm -y
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ipvsadm -A -t &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.100&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; -s rr 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;// rr为轮询机制 如果配置多台realsever 则请求平均分配 -t 基于tcp协议&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ipvsadm -a -t &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.100&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; -r &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;64.134&lt;/span&gt; -g
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; //-g ：dr 模型 -t基于tcp协议&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ipvsadm -ln
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234126375-2029236889.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浏览器刷新，访问vip:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234139340-1017605179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
ipvsadm -lnc
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; //查看note01 会有很多记录  （偷窥）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
netstat -natp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; //查看note01 没有记录 （说明请求直接跳过lvs 之后客户端会直接与realserver建立连接）&lt;/p&gt;
&lt;p&gt;如果能正常访问 则说明配置lvs成功，其实lvs就相当于一个路由的功能&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1167306/201903/1167306-20190312234150573-1926365741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 15:53:00 +0000</pubDate>
<dc:creator>陈扬天</dc:creator>
<og:description>前期准备： 两台服务器 note01(lvs服务器) note02(real sever) 1 首先在note01配置子网卡： :2意思是eth0的子接口，随便一个数字就可以，/24意为 255.25</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengwenzhee/p/10520517.html</dc:identifier>
</item>
<item>
<title>react复习总结（2）--react生命周期和组件通信 - 海瑞菌·博客</title>
<link>http://www.cnblogs.com/wuhairui/p/10515918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuhairui/p/10515918.html</guid>
<description>&lt;p&gt;这是&lt;span&gt;react&lt;/span&gt;项目复习总结&lt;span&gt;第二讲&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;第一讲：&lt;a href=&quot;https://www.cnblogs.com/wuhairui/p/10367620.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wuhairui/p/10367620.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先我们来学习下react的&lt;span&gt;生命周期（钩子）&lt;/span&gt;函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是react生命周期呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就是指react组件执行时在某个特定的时间点自动调用执行的函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ES5&lt;/strong&gt;传统&lt;strong&gt;创建&lt;/strong&gt;组件方式是这样的：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getDefaultProps&lt;/span&gt;：设置组件默认的&lt;span&gt;props（属性）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;getInitialState&lt;/span&gt;：设置组件默认的&lt;span&gt;state（状态）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312155223186-1380607036.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行顺序是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312162230252-2020946111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，&lt;span&gt;getDefaultProps&lt;/span&gt;函数组件未创建实例时就会被执行。&lt;/p&gt;

&lt;p&gt;除了上面的ES5，还有现在大多数被使用的是&lt;strong&gt;ES6模式&lt;/strong&gt;创建组件。&lt;/p&gt;
&lt;p&gt;以类的方式作为组件，使用的组件就是这个组件类的对象。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;static defaultProps&lt;/span&gt;：设置默认属性&lt;/p&gt;
&lt;p&gt;&lt;span&gt;constructor&lt;/span&gt;：用于设置默认状态 初始化。必须使用&lt;strong&gt;super&lt;/strong&gt;，之后才能使用&lt;strong&gt;this&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312163156768-1687404338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行顺序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312163535247-155035023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;componentWillMount&lt;/span&gt;、&lt;span&gt;componentDidMount &lt;/span&gt;这2个生命周期是首次进入页面&lt;span&gt;render&lt;/span&gt;前执行的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312190906852-103698274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312191001455-381118559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;componentWillReceiveProps&lt;/span&gt; 是组件的传入&lt;strong&gt;属性&lt;/strong&gt;被&lt;strong&gt;父组件&lt;/strong&gt;修改后执行的：&lt;/p&gt;
&lt;p&gt;接收到父组件传入的新&lt;strong&gt;props&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312191710502-2046286892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父组件&lt;/strong&gt;修改传入&lt;span&gt;属性&lt;/span&gt;的方式：&lt;/p&gt;
&lt;p&gt;传入的值是个&lt;span&gt;state&lt;/span&gt;就可以。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312191833717-892779925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（这是&lt;span&gt;组件通信&lt;/span&gt;的一种方式，属于&lt;span&gt;父子&lt;/span&gt;组件关系的通信，这是&lt;span&gt;父传子&lt;/span&gt;）&lt;/p&gt;

&lt;p&gt;要实现&lt;span&gt;子传父&lt;/span&gt;的话，那&lt;span&gt;父组件&lt;/span&gt;调用&lt;span&gt;子组件&lt;/span&gt;时传个&lt;span&gt;回调函数&lt;/span&gt;获取就可以了&lt;/p&gt;
&lt;p&gt;如：&lt;/p&gt;
&lt;p&gt;这是&lt;strong&gt;父组件render&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312192729831-881714016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;父组件回调函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312192751958-1274986605.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是&lt;strong&gt;子组件属性被修改&lt;/strong&gt;函数，执行这个回调函数即可执行父组件函数&lt;/p&gt;
&lt;p&gt;这里这么用，父组件传值给子组件后，子组件能立即回调父组件，形成有来有回。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312192817755-1017461993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击按钮，这里输出111。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;直接子传父的方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;父：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312234845452-558568961.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/883015/201903/883015-20190312234916807-364290298.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;父组件传个&lt;span&gt;回调&lt;/span&gt;给子组件，子组件通过&lt;span&gt;this.props&lt;/span&gt;可调用到这个函数，&lt;strong&gt;子就可以传值给父组件&lt;/strong&gt;了。&lt;/p&gt;

</description>
<pubDate>Tue, 12 Mar 2019 15:53:00 +0000</pubDate>
<dc:creator>海瑞菌&amp;#183;博客</dc:creator>
<og:description>这是react项目复习总结第二讲， 第一讲：https://www.cnblogs.com/wuhairui/p/10367620.html 首先我们来学习下react的生命周期（钩子）函数。 什么是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuhairui/p/10515918.html</dc:identifier>
</item>
<item>
<title>[精华]springMVC环境搭建基础入门总汇! - 吸光地球氧气第一天</title>
<link>http://www.cnblogs.com/wsfighting1218/p/10520439.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wsfighting1218/p/10520439.html</guid>
<description>&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;1.SpringMVC概述&lt;/h3&gt;
&lt;p&gt;             SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring       FrameWork 的后续产品，已经融合在 Spring Web Flow 里面。Spring 框架提供了构建 Web 应用程序的全功 能 MVC 模块。使用 Spring 可插入的 MVC 架构，从而在使用 Spring 进行 WEB 开发时，可以选择使用 Spring 的 Spring MVC 框架或集成其他 MVC 开发框架，如 Struts1(现在一般不用)，Struts2 等。 SpringMVC 已经成为目前最主流的 MVC 框架之一，并且随着 Spring3.0 的发布，全面超越 Struts2，成 为最优秀的 MVC 框架。 它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。同时它还支持 RESTful 编程风格的请求。&lt;/p&gt;
&lt;p&gt;      我们的开发架构一般都是基于两种形式，一种是 C/S 架构，也就是客户端/服务器，另一种是 B/S 架构，也就 是浏览器服务器。在 JavaEE 开发中，几乎全都是基于 B/S架构的开发。那么在 B/S架构中，系统标准的三层架构 包括：表现层、业务层、持久层。三层架构在我们的实际开发中使用的非常多，所以我们课程中的案例也都是基于三层架构设计的。 三层架构中，每一层各司其职，接下来我们就说说每层都负责哪些方面： 表现层：  也就是我们常说的web层。它负责接收客户端请求，向客户端响应结果，通常客户端使用http协议请求 web 层，web 需要接收 http 请求，完成 http 响应。  表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。  表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。  表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系） 业务层：  也就是我们常说的 service 层。它负责业务逻辑处理，和我们开发项目的需求息息相关。web 层依赖业 务层，但是业务层不依赖 web 层。  业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的， 事务应该放到业务层来控制） 持久层：  也就是我们是常说的 dao 层。负责数据持久化，包括数据层即数据库和数据访问层，数据库是对数据进 行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库&lt;br/&gt;中。通俗的讲，持久层就是和数据库交互，对数据库表进行曾删改查的。&lt;/p&gt;
&lt;p&gt;MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写， 是一种用于设计创建 Web 应用程序表现层的模式。MVC 中每个部分各司其职：  Model（模型）：   通常指的就是我们的数据模型。作用一般情况下用于封装数据。  View（视图）：   通常指的就是我们的 jsp 或者 html。作用一般就是展示数据的。   通常视图是依据模型数据创建的。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt; Controller（控制器）：   是应用程序中处理用户交互的部分。作用一般就是处理程序逻辑的。   它相对于前两个不是很好理解，这里举个例子：   例如：    我们要保存一个用户的信息，该用户信息中包含了姓名，性别，年龄等等。    这时候表单输入要求年龄必须是 1~100 之间的整数。姓名和性别不能为空。并且把数据填充 到模型之中。    此时除了 js 的校验之外，服务器端也应该有数据准确性的校验，那么校验就是控制器的该做 的。    当校验失败后，由控制器负责把错误页面展示给使用者。    如果校验成功，也是控制器负责把数据填充到模型，并且调用业务层实现完整的业务需求。&lt;/p&gt;

&lt;h3&gt;2.SpringMVC的环境搭建&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;楼主喜欢用idea ,此文中是在idea工程中创建maven项目 ,在创建页面中选择webapp 点击next即可!如图....&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;工程创建好了以后需要导入在pom.xml依赖  代码如下   ....导包过程中可能出现一些小问题  把maven仓库里面相关的jar包文件夹缓存删了就行 idea在联网中会自动重新下载.&lt;br/&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-&lt;span&gt;8&lt;/span&gt;&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;maven.compiler.source&amp;gt;&lt;span&gt;1.8&lt;/span&gt;&amp;lt;/maven.compiler.source&amp;gt;
        &amp;lt;maven.compiler.target&amp;gt;&lt;span&gt;1.8&lt;/span&gt;&amp;lt;/maven.compiler.target&amp;gt;
        &amp;lt;spring.version&amp;gt;&lt;span&gt;5.0&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;.RELEASE&amp;lt;/spring.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;4.11&lt;/span&gt;&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;servlet-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;2.5&lt;/span&gt;&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;&lt;span&gt;2.0&lt;/span&gt;&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;


    &amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;依赖弄好了以后  ,我们需要在webapp文件下的web.xml中配置 springMVC的核心容器DispatcherServlet 代码如下
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;web-app xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://xmlns.jcp.org/xml/ns/javaee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
         version&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;!--配置核心控制器DispatcherServlet--&amp;gt;
  &amp;lt;servlet&amp;gt;
      &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
      &amp;lt;servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-&lt;span&gt;class&lt;/span&gt;&amp;gt;

      &amp;lt;!--配置servlet初始化参数  读取springmvc配置文件   创建spring容器--&amp;gt;
      &amp;lt;init-param&amp;gt;
          &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
          &amp;lt;param-value&amp;gt;classpath:springmvc.xml&amp;lt;/param-value&amp;gt;
      &amp;lt;/init-param&amp;gt;

      &amp;lt;!--配置 servlet启动时的加载对象   --&amp;gt;
      &amp;lt;load-on-startup&amp;gt;&lt;span&gt;1&lt;/span&gt;&amp;lt;/load-on-startup&amp;gt;
  &amp;lt;/servlet&amp;gt;


        &amp;lt;!--配置servlet映射信息--&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;dispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;

      &amp;lt;!--配置过滤器  解决中文乱码的问题 --&amp;gt;
      &amp;lt;filter&amp;gt;
          &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt;
          &amp;lt;filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-&lt;span&gt;class&lt;/span&gt;&amp;gt;

          &amp;lt;!--指定字符集--&amp;gt;
          &amp;lt;init-param&amp;gt;
              &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
              &amp;lt;param-value&amp;gt;UTF-&lt;span&gt;8&lt;/span&gt;&amp;lt;/param-value&amp;gt;
          &amp;lt;/init-param&amp;gt;
      &amp;lt;/filter&amp;gt;
    &amp;lt;!--配置filter映射信息--&amp;gt;
  &amp;lt;filter-mapping&amp;gt;
      &amp;lt;filter-name&amp;gt;characterEncodingFilter&amp;lt;/filter-name&amp;gt;
      &amp;lt;url-pattern&amp;gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;


&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;接下来你需要在项目文件夹src/main/创建java ,resources 两个文件夹分别标记为类文件 资源文件, 加上自带的webapp总共三个  是标准的maven项目  在resources文件下新建springMVC.xml文件添加以下代码
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;beans xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/beans&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:mvc&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/mvc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:context&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.springframework.org/schema/context&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;=&lt;span&gt;&quot;
&lt;/span&gt;        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/beans/spring-beans.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/mvc/spring-mvc.xsd&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context&lt;/span&gt;
        http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;&lt;/span&gt;

       &amp;lt;!--&lt;span&gt;1&lt;/span&gt;.配置spring创建容器时要扫描的包--&amp;gt;
    &amp;lt;context:component-scan &lt;span&gt;base&lt;/span&gt;-package=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.ws&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/context:component-scan&amp;gt;

       &amp;lt;!--&lt;span&gt;2&lt;/span&gt;.配置视图解析器--&amp;gt;
    &amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewResolver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.springframework.web.servlet.view.InternalResourceViewResolver&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
         &amp;lt;!--配置路径--&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;prefix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/WEB-INF/pages/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;!--目标文件格式--&amp;gt;
        &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;suffix&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jsp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;


    &amp;lt;!--&lt;span&gt;3&lt;/span&gt;.配置spring开启注解mvc 的支持--&amp;gt;
    &amp;lt;mvc:annotation-driven&amp;gt;&amp;lt;/mvc:annotation-driven&amp;gt;





&amp;lt;/beans&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;到这里环境配置就ok了  你需要在index.jsp页面中 引入一个Controller控制器类就大功告成了!&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;入门案例的执行过程分析 1. 入门案例的执行流程 1. 当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象， 就会加载springmvc.xml配置文件 2. 开启了注解扫描，那么HelloController对象就会被创建 3. 从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解 找到执行的具体方法 4. 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 5. Tomcat服务器渲染页面，做出响应 2. SpringMVC官方提供图形&lt;/p&gt;&lt;p&gt;入门案例中的组件分析 1. 前端控制器（DispatcherServlet） 2. 处理器映射器（HandlerMapping） 3. 处理器（Handler） 4. 处理器适配器（HandlAdapter） 5. 视图解析器（View Resolver） 6. 视图（View）&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1615889/201903/1615889-20190312231046387-1567482334.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 15:34:00 +0000</pubDate>
<dc:creator>吸光地球氧气第一天</dc:creator>
<og:description>1.SpringMVC概述 SpringMVC 是一种基于 Java 的实现 MVC 设计模型的请求驱动类型的轻量级 Web 框架，属于 Spring FrameWork 的后续产品，已经融合在 Sp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wsfighting1218/p/10520439.html</dc:identifier>
</item>
<item>
<title>Sketch webView方式插件开发技术总结 - jingwhale</title>
<link>http://www.cnblogs.com/jingwhale/p/10520149.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jingwhale/p/10520149.html</guid>
<description>&lt;p&gt;相信大家都对Sketch有一定的了解和认识。除了基础的矢量设计功能以外，插件更是让Sketch保持强大的独门秘籍。Sketch开放了第三方插件接口，设计师可以在几百种的插件中轻松找到适合自己工作方式的插件，并且他们都非常容易获得和安装。这里主要介绍使用Javascript API for Sketch开发Sketch插件。&lt;/p&gt;

&lt;p&gt;Sketch成为梦想中的“设计师工具箱”。但是每个人都有不同的需求，也许你需要一个我们还没有实现的功能。不要担心：插件已经可以满足您的需求，或者你可以轻松创建一个插件。&lt;/p&gt;

&lt;h3 id=&quot;d3638727&quot;&gt;一、Sketch插件可以做什么？&lt;/h3&gt;
&lt;p&gt;Sketch中的插件可以做任何用户可以做的事情（甚至更多！）。例如：&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;e9bb7231&quot;&gt;二、插件简介&lt;/h3&gt;
&lt;p&gt;Sketch 插件都是 *.sketchplugin 的形式，其实就是一个文件夹，通过右键显示包内容，可以看到最普通的内部结构式是这样的：&lt;/p&gt;


&lt;p&gt;manifest.json用来声明插件配置信息，commands 定义所有可执行命令，每条 command 有唯一标志符，identifier，menu 定义插件菜单，通过 identifier 关联到执行命令。&lt;/p&gt;
&lt;p&gt;my-commond.js是插件逻辑的实现代码实现文件。&lt;/p&gt;

&lt;h3 id=&quot;a147a6d2&quot;&gt;三、Javascript API for Sketch&lt;/h3&gt;
&lt;p&gt;这是Sketch的原型Javascript API。 原生Javascript，Sketch的完整内部结构的一个易于理解的子集。它仍然是一项正在进行中的工作。&lt;/p&gt;

&lt;p&gt;Javascript API for Sketch 原理：&lt;/p&gt;


&lt;h3 id=&quot;ec057dbf&quot;&gt;四、&lt;a href=&quot;https://developer.sketchapp.com/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;开发文档&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;7c591767&quot;&gt;1、开发文档&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.sketchapp.com/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://developer.sketchapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;84df8b40&quot;&gt;2、API&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.sketchapp.com/reference/api/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://developer.sketchapp.com/reference/api/&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;cab71bc4&quot;&gt;3、Demo&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/BohemianCoding/SketchAPI/tree/develop/examples&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://github.com/BohemianCoding/SketchAPI/tree/develop/examples&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;e3f38545&quot;&gt;五、&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Sketch webView&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sketch模块，用于使用webview创建复杂的UI。有别于一般的插件页面，可以使用webview模块加载一个复杂的Web应用，使其与Sketch进行交互。&lt;/p&gt;
&lt;h4 id=&quot;516364d7&quot;&gt;&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view/blob/master/docs/browser-window.md&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;1、BrowserWindow&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;在浏览器窗口中创建和控制Sketch：&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20In%20the%20plugin.%5Cnconst%20BrowserWindow%20%3D%20require('sketch-module-web-view')%5Cn%5Cnlet%20win%20%3D%20new%20BrowserWindow(%7B%20width%3A%20800%2C%20height%3A%20600%20%7D)%5Cnwin.on('closed'%2C%20()%20%3D%3E%20%7B%5Cn%20%20win%20%3D%20null%5Cn%7D)%5Cn%5Cn%2F%2F%20Load%20a%20remote%20URL%5Cnwin.loadURL('https%3A%2F%2Fgithub.com')%5Cn%5Cn%2F%2F%20Or%20load%20a%20local%20HTML%20file%5Cnwin.loadURL(require('.%2Findex.html'))%22%7D&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; In the plugin.&lt;/span&gt;
const BrowserWindow = require('sketch-module-web-view'&lt;span&gt;)

let win &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BrowserWindow({ width: 800, height: 600&lt;span&gt; })
win.on(&lt;/span&gt;'closed', () =&amp;gt;&lt;span&gt; {
  win &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load a remote URL&lt;/span&gt;
win.loadURL('https://github.com'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Or load a local HTML file&lt;/span&gt;
win.loadURL(require('./index.html'))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;57175759&quot;&gt;&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view/blob/master/docs/web-contents.md&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;2、webContents&lt;/a&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
const BrowserWindow = require('sketch-module-web-view'&lt;span&gt;)

let win &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BrowserWindow({ width: 800, height: 1500&lt;span&gt; })
win.loadURL(&lt;/span&gt;'http://github.com'&lt;span&gt;)

let contents &lt;/span&gt;=&lt;span&gt; win.webContents
console.log(contents)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&quot;5e90c6bb&quot;&gt;&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view/blob/master/docs/communication-plugin-webview.md&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;3、skech与webview的通信&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;1）Sending a message to the WebView from your plugin command&lt;/p&gt;
&lt;p&gt;On the WebView:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
window.someGlobalFunctionDefinedInTheWebview = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(arg) {
  console.log(arg)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;On the plugin:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;browserWindow.webContents
  .executeJavaScript(&lt;/span&gt;'someGlobalFunctionDefinedInTheWebview(&quot;hello&quot;)'&lt;span&gt;)
  .then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; do something with the result&lt;/span&gt;
  })
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2）Sending a message to the plugin from the WebView&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;On the plugin:&lt;/span&gt;&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20sketch%20%3D%20require('sketch')%5Cn%5CnbrowserWindow.webContents.on('nativeLog'%2C%20function(s)%20%7B%5Cn%20%20sketch.UI.message(s)%5Cn%7D)%22%7D&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; sketch = require('sketch'&lt;span&gt;)

browserWindow.webContents.on(&lt;/span&gt;'nativeLog', &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(s) {
  sketch.UI.message(s)
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-12&quot;&gt;On the webview:&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
window.postMessage('nativeLog', 'Called from the webview'&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; you can pass any argument that can be stringified&lt;/span&gt;
window.postMessage('nativeLog'&lt;span&gt;, {
  a: b,
})

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; you can also pass multiple arguments&lt;/span&gt;
window.postMessage('nativeLog', 1, 2, 3)
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;ce9b1845&quot;&gt;&lt;a href=&quot;https://github.com/jingwhale/sketch-webview-kit&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;六、构建开发工程&lt;/a&gt;&lt;/h3&gt;
&lt;h4 id=&quot;cd461fda&quot;&gt;1、确立技术栈&lt;/h4&gt;
&lt;p&gt;使用&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Sketch webView&lt;/a&gt;的方式开发插件。用户通过操作插件界面，webview与Sketch通信解决用户的问题。这样插件界面可以使用现今所有的前端框架与组件库。&lt;/p&gt;
&lt;p&gt;1）&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;webView&lt;/a&gt;框架选择&lt;a href=&quot;https://umijs.org/zh/guide/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Umi &lt;/a&gt;+ &lt;a href=&quot;https://ant.design/index-cn&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Ant Design&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：WebView框架也可以单独的工程与部署。&lt;/p&gt;

&lt;p&gt;2）使用Sketch 官方skpm穿件插件工程&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/skpm/sketch-dev-tools&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;3）调试工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;A、使用官方的&lt;a href=&quot;https://github.com/skpm/sketch-dev-tools&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;sketch-dev-tools&lt;/a&gt; sketch内作为调试工具&lt;/p&gt;
&lt;p&gt;下载代码，代码运行安装插件即可：&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22npm%20install%5Cnnpm%20run%20build%22%7D&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm install
npm run build&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;B、使用浏览器的开发者模式调试&lt;a href=&quot;https://github.com/skpm/sketch-module-web-view&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;webView&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在sketch webView中右击显示调试器即可：&lt;/p&gt;


&lt;h4 id=&quot;4b61ba56&quot;&gt;2、构建工程&lt;/h4&gt;
&lt;p&gt;1)创建Sketch插件基础工程&lt;/p&gt;
&lt;p&gt;首先，创建sketch-webview-kit插件工程：&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22npm%20install%20-g%20skpm%5Cnskpm%20create%20sketch-webview-kit%20%2F%2F%E5%88%9B%E5%BB%BAsketch-webview-kit%E6%8F%92%E4%BB%B6%E5%B7%A5%E7%A8%8B%22%7D&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install -&lt;span&gt;g skpm
skpm create sketch&lt;/span&gt;-webview-kit &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建sketch-webview-kit插件工程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;其次，依赖sketch-module-web-view：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install sketch-module-web-view
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2）创建webView工程（&lt;a href=&quot;https://umijs.org/zh/guide/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Umi &lt;/a&gt;+ &lt;a href=&quot;https://ant.design/index-cn&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Ant Design&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;首先，创建webView工程目录，&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22%24%20mkdir%20webapp%20%26%26%20cd%20webapp%22%7D&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ mkdir webapp &amp;amp;&amp;amp; cd webapp
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;然后，创建webView工程&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22yarn%20create%20umi%22%7D&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
yarn create umi
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;依次：&lt;/p&gt;
&lt;p&gt;选择 app, 然后回车确认；&lt;/p&gt;
&lt;p&gt;选上 antd 和 dva，然后回车确认；&lt;/p&gt;

&lt;p&gt;最后，安装依赖：&lt;/p&gt;

&lt;p&gt;3）配置webView工程&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://umijs.org/zh/guide/deploy.html#%E9%9D%99%E6%80%81%E5%8C%96&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;A.部署打包配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.umirc.js文件中，添加：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
outputPath:'../src/dist', &lt;span&gt;//&lt;/span&gt;&lt;span&gt;打包后的目录&lt;/span&gt;
&lt;span&gt;exportStatic: {
  dynamicRoot: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;静态自由部署&lt;/span&gt;
},
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://umijs.org/zh/guide/html-template.html&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;B.HTML 模板&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于Umi生成没有Html文件，可以自己配置。新建 src/pages/document.ejs，umi 约定如果这个文件存在，会作为默认模板，内容上需要保证有 &amp;lt;div id=&quot;root&quot;&amp;gt;&amp;lt;/div&amp;gt;，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;doctype html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Your App&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;root&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;0d10ca43&quot;&gt;3、sketch加载webView工程与联调&lt;/h4&gt;
&lt;p&gt;1）sketch加载webView&lt;/p&gt;
&lt;p&gt;第一种方法：&lt;/p&gt;
&lt;p&gt;直接部署webView工程，通过Url加载：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
win.loadURL('https://github.com')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;第二种方法：&lt;/p&gt;
&lt;p&gt;加载webView工程打包后的文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
win.loadURL(require('./dist/index.html'))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;此方法，由umi打包后的静态资源（css、js）需要拷贝到&lt;/p&gt;
&lt;p&gt;pannel3/pannel3.sketchplugin/Contents/Resources/_webpack_resources下。&lt;/p&gt;

&lt;p&gt;2）联调加载方法：&lt;/p&gt;
&lt;p&gt;本地启动webView工程，本地webView工程会在8000端口起一个服务，加载此服务即可：&lt;/p&gt;
&lt;div data-card-type=&quot;block&quot; data-lake-card=&quot;codeblock&quot; data-card-value=&quot;data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20Panel%20%3D%20%60http%3A%2F%2Flocalhost%3A8000%23%24%7BMath.random()%7D%60%3B%5Cnwin.loadURL(Panel)%22%7D&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const Panel = `http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8000#${Math.random()}`;&lt;/span&gt;
win.loadURL(Panel)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&quot;2116864a&quot;&gt;&lt;a href=&quot;https://github.com/jingwhale/sketch-webview-kit&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;4、项目成果&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;文件目录如下：&lt;/p&gt;

&lt;h3 id=&quot;97c045b5&quot;&gt;七、拓展&lt;/h3&gt;
&lt;h4 id=&quot;ac71f360&quot;&gt;&lt;a href=&quot;https://www.yuque.com/jingwhale/blog/rt5aci&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;1、&lt;/a&gt;&lt;a href=&quot;https://github.com/airbnb/react-sketchapp&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;React - SketchApp &lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;是一个开源库，为设计系统量身定制。它通过将 React 元素渲染到 Sketch 来连接设计和开发之间的鸿沟。&lt;/p&gt;
&lt;p&gt;Sketch Javascript API 是源生代码，React - SketchApp 使用react对Javascript API 进行了二次封装。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://airbnb.io/react-sketchapp/docs/API.html&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;1)API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://airbnb.io/react-sketchapp/docs/API.html&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;http://airbnb.io/react-sketchapp/docs/API.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/jingwhale/blog/do37mc&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;2)Demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.yuque.com/jingwhale/blog/do37mc&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;https://www.yuque.com/jingwhale/blog/do37mc&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 15:33:00 +0000</pubDate>
<dc:creator>jingwhale</dc:creator>
<og:description>首发：https://www.yuque.com/jingwhale/blog/rt5aci 相信大家都对Sketch有一定的了解和认识。除了基础的矢量设计功能以外，插件更是让Sketch保持强大的独</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jingwhale/p/10520149.html</dc:identifier>
</item>
<item>
<title>逻辑回归损失函数推导 - shayue111</title>
<link>http://www.cnblogs.com/shayue/p/10520414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shayue/p/10520414.html</guid>
<description>&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;假设今天希望将机器学习应用到医院中去，比如对于某一个患了心脏病的病人，求他3个月之后病危的概率。那么我们该选择哪一个模型，或者可以尝试已经学过的线性回归？&lt;/p&gt;
&lt;p&gt;但是很遗憾的是，如果我们要利用线性回归，我们收集到的资料中应当包含病人3个月后病危的概率。这在实际中是很难得到的，因为对于一个患病的病人，你只能知道他3个月后到底是病危或者存活。所以线性回归并不适用这种场景。&lt;/p&gt;
&lt;h2 id=&quot;logistic函数&quot;&gt;logistic函数&lt;/h2&gt;
&lt;p&gt;上面提到我们最终的目标是一个概率值&lt;span class=&quot;math inline&quot;&gt;\(P(y|x)\)&lt;/span&gt;，这里&lt;span class=&quot;math inline&quot;&gt;\(y=+1\)&lt;/span&gt;指代病人3个月后病危这个事件;&lt;span class=&quot;math inline&quot;&gt;\(y=-1\)&lt;/span&gt;指代病人3个月后存活这个事件。显然&lt;span class=&quot;math inline&quot;&gt;\(P(-1|x) = 1 - P(1|x)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;我们先前学过线性回归，知道可以通过加权的方式求出各项特征的'分数'，那这个分数怎么转换为一个概率值？这里就需要引入一个logistic函数。它的表达式为：&lt;span class=&quot;math display&quot;&gt;\[ \theta(s)=\frac{1}{1+e^{-s}} \]&lt;/span&gt;&lt;br/&gt;它的图像如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201903/1531067-20190312232659084-1342501547.png&quot; height=&quot;50%&quot; width=&quot;50%&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这个函数有十分不错的性质：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(\theta(-∞)=0, \ \theta(+∞)=1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(1-\theta(s)=\theta(-s)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也就是说我们可以把加权得到的'分数'通过logistic函数转化为一个概率值，并且加权得到的'分数'越大，这个概率值也越大。这真的还蛮有道理的。&lt;/p&gt;
&lt;p&gt;好了，我们的模型已经定义完毕了，称它为逻辑回归模型：&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} h(x) = \frac{1}{1+e^{-w^Tx}} \ \ \ \ \ w,x都是向量 \end{equation} \]&lt;/span&gt;&lt;br/&gt;也就是说，我们获取到一个病人的特征&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，将它输入模型，就能知晓这个病人3个月后病危的概率。但是，还有最重要的一步，这个模型的参数&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;如何确定？不同的参数&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;会带来不同的模型&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;.经验告诉我们可以从已获得的资料中找到一些端倪获取最合适的&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;损失函数&quot;&gt;损失函数&lt;/h2&gt;
&lt;p&gt;线性回归中，我们定义了一个平方损失函数，通过对损失函数求导数得到最后的参数。那依样画葫芦，我们也为逻辑回归定义一个损失函数，然后试着对损失函数求梯度，是不是能解出最后的参数了。那么想一下，逻辑回归的损失函数如何定义？还用最小二乘法么？这显然不符合场景，毕竟已有的资料只告诉我们每一组数据对应的结果是哪一类的。&lt;/p&gt;
&lt;p&gt;我们还是从数据的产生来分析，现在已有的数据是这些：&lt;span class=&quot;math display&quot;&gt;\[ D = {(x_1, 1), (x_2, 1), (x_3, 1), ... , (x_n, -1)} \]&lt;/span&gt;&lt;br/&gt;当然，这些数据的产生是相互独立的，所以获得&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;这笔资料的概率就是&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} P(x_1, 1) * P(x_2, 1) * P(x_3, 1) * ... * P(x_n, -1) \end{equation}\]&lt;/span&gt;&lt;br/&gt;再将(2)式写为条件概率分布&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} P(x_1)P(1|x_1) * P(x_2)P(1|x_2) * P(x_3)P(1|x_3) * ... * P(x_n)P(-1|x_n) \end{equation}\]&lt;/span&gt;&lt;br/&gt;再者，假设每一笔数据的产生服从0-1分布。&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} P(y|x_i) = \left \{ \begin{array}{lr} f(x_i) \ \ \ \ \ \ \ \ \ \ y=+1 \\ 1 - f(x_i) \ \ \ \ \ y=-1 \end{array} \right. \end{equation}\]&lt;/span&gt;&lt;br/&gt;所以最后写成的形式：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} P(x_1)f(x_1) * P(x_2)f(x_2) * P(x_3)f(x_3) * ... * P(x_n)(1-f(x_n)) \end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就说这笔资料&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;由真正的模型&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;产生的话，概率是(5)这么大。但是我们不知道真正的模型f(x)长什么样子，我们现在只知道我们自己定义了一个模型&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;，它长成(1)这个样子。所以现在的任务就是从很多的&lt;span class=&quot;math inline&quot;&gt;\(h(x)_1, h(x)_2, h(x)_3, ..., h(x)_m\)&lt;/span&gt;中找到其中一个最接近真正的模型&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;并将它作为我们最后的&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以如何衡量&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;的接近程度？如果我们现在用&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;代替&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;去产生这组数据集&lt;span class=&quot;math inline&quot;&gt;\(D\)&lt;/span&gt;也能得到一个概率(6).&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} P(x_1)h(x_1) * P(x_2)h(x_2) * P(x_3)h(x_3) * ... * P(x_n)(1-h(x_n)) \end{equation}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;使得(6)式的概率最大的那个&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;我们会认为它与&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;最相似，这就是最大似然的思想。&lt;/strong&gt;&lt;/span&gt;又因为对于所有的&lt;span class=&quot;math inline&quot;&gt;\(h(x)_i\)&lt;/span&gt;产生的概率：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} P(x_1) * P(x_2) * P(x_3) * ... * P(x_n) \end{equation}\]&lt;/span&gt;&lt;br/&gt;这部分都是相同的，所以我们认为最接近&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;的&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;能使(8)最大即可&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} h(x_1) * h(x_2) * h(x_3) * ... * (1-h(x_n)) \end{equation}\]&lt;/span&gt;&lt;br/&gt;再由于logistic函数的第2个性质，可以将(8)变形：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} h(x_1) * h(x_2) * h(x_3) * ... * h(-x_n) \end{equation}\]&lt;/span&gt;&lt;br/&gt;最终的目标是解出下面这个优化问题：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{max}\limits_{w} \ \ \prod_{i=1}^{n}h(y_ix_i) \end{equation}\]&lt;/span&gt;&lt;br/&gt;再次变形，求一个式子的最大值，相当于求它相反数的最小：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{min}\limits_{w} \ \ -\prod_{i=1}^{n}h(y_ix_i) \end{equation}\]&lt;/span&gt;&lt;br/&gt;接下来我们要对(11)式取对数，一方面原因是因为对数函数的单调特性，另一方面是能将原来的连乘简化到连加，所以取对数后：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{min}\limits_{w} \ \ -\sum_{i=1}^{n}\ln{h(y_ix_i)} \end{equation}\]&lt;/span&gt;&lt;br/&gt;将&lt;span class=&quot;math inline&quot;&gt;\(h(x)\)&lt;/span&gt;展开，能得到&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{min}\limits_{w} \ \ -\sum_{i=1}^{n}\ln{\frac{1}{1+e^{-y_iw^Tx_i}}} \ \ \ \ \ \ \ \ \ \ w与x_i都是向量,x_i表示第i笔数据 \end{equation}\]&lt;/span&gt;&lt;br/&gt;再一次&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \mathop{min}\limits_{w} \ \ \sum_{i=1}^{n}\ln{(1+e^{-y_iw^Tx_i})} \ \ \ \ \ \ \ \ \ \ w与x_i都是向量,x_i表示第i笔数据 \end{equation}\]&lt;/span&gt;&lt;br/&gt;大功告成，我们得到了逻辑回归的损失函数,它长成(15)式这个样子&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} J(w)= \sum_{i=1}^{n}\ln{(1+e^{-y_iw^Tx_i})} \ \ \ \ \ \ \ \ \ \ w与x_i都是向量,x_i表示第i笔数据 \end{equation}\]&lt;/span&gt;&lt;br/&gt;我们的目标就是找到最小化&lt;span class=&quot;math inline&quot;&gt;\(J(w)\)&lt;/span&gt;的那个&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;.就像在线性回归中做的那样，接下来我们要利用链式法则对它求导：&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \frac{\partial J(w)}{\partial w_j} = \sum_{i=1}^{n}\frac{\partial \ln{(1+e^{-y_iw^Tx_i})}}{\partial (-y_iw^Tx_i)} * \frac{\partial (-y_iw^Tx_i)}{\partial w_j} \end{equation}\]&lt;/span&gt;&lt;br/&gt;化解得到&lt;span class=&quot;math display&quot;&gt;\[\begin{equation} \frac{\partial J(w)}{\partial w_j} = \sum_{i=1}^{n}\frac{e^{-y_iw^Tx_i}}{1+e^{-y_iw^Tx_i}} * (-y_ix_{i,j}) \ \ \ \ x_{i,j}是个标量，是第i笔数据中第j个分量 \end{equation}\]&lt;/span&gt;&lt;br/&gt;所以对于整个向量&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;的梯度为&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \frac{\partial J(w)}{\partial w} = \sum_{i=1}^{n}\frac{e^{-y_iw^Tx_i}}{1+e^{-y_iw^Tx_i}} * (-y_ix_i) \ \ \ \ 想象将对单个w_i的结果笔直堆成一个向量 \end{equation}\]&lt;/span&gt;&lt;br/&gt;而&lt;span class=&quot;math inline&quot;&gt;\(\frac{e^{-y_iww^Tx_i}}{1+e^{-y_iww^Tx_i}}\)&lt;/span&gt;正好是逻辑回归函数，所以最终对&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;的梯度写成下面这个样子&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} \frac{\partial J(w)}{\partial w} = \sum_{i=1}^{n}h(-y_iw^Tx_i)(-y_ix_i) \end{equation}\]&lt;/span&gt;&lt;br/&gt;很遗憾，我们令(19)等于0的话，很难求解出&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;。为此，我们需要用额外的方法求解这个问题。&lt;/p&gt;
&lt;h2 id=&quot;梯度下降&quot;&gt;梯度下降&lt;/h2&gt;
&lt;p&gt;这个可学习的资料太多了，思想就是假设函数上有一个点，它沿着各个方向都有它的方向导数，那么总是沿着方向导数最大的反方向走，也就是梯度的反方向走，这个点总是能走到最低点。每一次移动的距离用一个系数lr来表示，每次更新&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;，数次迭代之后，&lt;span class=&quot;math inline&quot;&gt;\(w\)&lt;/span&gt;趋近于最优解：&lt;span class=&quot;math display&quot;&gt;\[ \begin{equation} w_{i+1} := w_{i} - lr * \sum_{i=1}^{n}\frac{e^{-y_iw^Tx_i}}{1+e^{-y_iw^Tx_i}} * (-y_ix_i) \ \ \ \ \ lr是大于0的系数 \end{equation}\]&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 12 Mar 2019 15:28:00 +0000</pubDate>
<dc:creator>shayue111</dc:creator>
<og:description>引言 假设今天希望将机器学习应用到医院中去，比如对于某一个患了心脏病的病人，求他3个月之后病危的概率。那么我们该选择哪一个模型，或者可以尝试已经学过的线性回归？ 但是很遗憾的是，如果我们要利用线性回归</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shayue/p/10520414.html</dc:identifier>
</item>
<item>
<title>连载《一个程序猿的生命周期》-《发展篇》- 26.且听风吟，静待花开，慢慢走向人生赢家 - 一个程序猿的生命周期</title>
<link>http://www.cnblogs.com/blog470130547/p/10520408.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/blog470130547/p/10520408.html</guid>
<description>&lt;p&gt;&lt;span&gt;       昨天一早感觉天气很好，完全没有上班的意愿。上午赶到公司处理一些无关紧要的事儿，于是乎下午带着大宝去八大处爬山，在感受自然风光的同时想到一句话：且听风吟，静待花开。&lt;strong&gt;在人生过程中所做出的努力，也需要静静等待开花结果，不过等待是一件很痛苦的事&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/691334/201903/691334-20190312232349127-460146250.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;       从去年9月份开始很少在公司，基本上一直处于出差状态，一般是周五晚上回京、周日晚上出差，关键时期周末搭进去了。正值项目推进困难、攻坚克难的时候，老婆怀二宝已经有27周了。&lt;strong&gt;如果说用户和公司层面都认为你是项目具体负责执行的最佳人选，请问还有其他的选择余地吗？&lt;/strong&gt;已经执行两个多月的项目，半路接手后给我的感觉是别人都在退缩，为有牺牲多壮志，鬼才知道日月能否换新天。正式上岗见用户执行负责人时，用户说：你来了呀（大意），我调侃道：我只是来陪葬的。见大领导的时候，让我介绍自己的履历。据听说他们不止一次辞去乙方项目经理了，所以不管是对公司还是对个人来讲都是极大的挑战。这个项目，陆续在外面漂了将近三个月，项目基本上走向正轨，受用户和公司的恩赐，现在安心在家陪护待产。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       在很多公司和家庭的事情都需要你处理的时候，感觉到莫名的烦躁，甚至不想说一句话。由于项目执行的困难，技术的问题、做事合理性的问题、思维方式的问题等等，很严厉的批评过团队的人员，但是都是以事实为依据。人生要适时做出改变，不仅我要改变，他们也必须改变。就像上篇文章写的：&lt;strong&gt;生活中有很多角色，平民、老公、父亲、员工、部门经理、项目经理......，一个人成熟的标准是在众多角色之间平滑转换，就像开车换档没有顿挫感。但是，很难界定众多角色中哪个是主角，而每个角色又要尽可能到位&lt;/strong&gt;。有的人甚至连一个孩子都不要，理由是有困难、没条件......等等，&lt;strong&gt;人无法主动改变自己是内心对自己的恐惧，你怎么知道别人就没有困难、别人就比自己的条件好呢。改变自己而做事，基本上都属于能力不所及，这样人生经历才有很大收获&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       今天用户发来信息：&lt;strong&gt;到底是你带出来的兵，就是不一样&lt;/strong&gt;！人的能力有多大差别呢，首先就是思想问题，其次就是发展方向问题，解决好这两个问题，都有用武之地。我始终相信人是可以改造的，否则革命怎么才能成功呢！我也承认有很多问题需要解决，但是本着惩前毖后、治病救人的原则，实在救治不了癌症，也只能相互放弃了。总体气氛比较和谐，他们有时候也在批评我：情商太低、也不写代码、也不帮着解决问题......，也在调侃：每个开完会落脚点都强调找对象的事......！我感觉和谐的趋势是好的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      从八大处下来的时候，看属相时运：今年犯小人、身体不佳......。从去年底开始，确实身体不太好，但是现在有所好转。二宝降临后，更要求有一个强健的身体。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/691334/201903/691334-20190312232446614-460773808.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;hr/&gt;&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div readability=&quot;6.241134751773&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一个程序猿的生命周期 微信平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;口   号：职业交流，职业规划；面对现实，用心去交流、感悟。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;公众号：iterlifetime&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;strong&gt;百木-ITer职业交流奋斗 群：141588103&lt;/strong&gt;   &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二维码：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/691334/201606/691334-20160618075950167-974887453.jpg&quot; alt=&quot;&quot; width=&quot;120&quot; height=&quot;120&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/div&gt;

</description>
<pubDate>Tue, 12 Mar 2019 15:27:00 +0000</pubDate>
<dc:creator>一个程序猿的生命周期</dc:creator>
<og:description>昨天一早感觉天气很好，完全没有上班的意愿。上午赶到公司处理一些无关紧要的事儿，于是乎下午带着大宝去八大处爬山，在感受自然风光的同时想到一句话：且听风吟，静待花开。在人生过程中所做出的努力，也需要静静等</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/blog470130547/p/10520408.html</dc:identifier>
</item>
<item>
<title>C++_类和对象 - 鲸90830</title>
<link>http://www.cnblogs.com/whale90830/p/10520364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whale90830/p/10520364.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;OOP第二课&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;1 类的构成
&lt;ul&gt;&lt;li&gt;1.1 从结构到类&lt;/li&gt;
&lt;li&gt;1.2 类的构成&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2 成员函数的声明
&lt;ul&gt;&lt;li&gt;2.1 普通成员函数形式&lt;/li&gt;
&lt;li&gt;2.2 将成员函数以内联函数的形式进行说明&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3 对象的定义和使用
&lt;ul&gt;&lt;li&gt;3.1 对象的定义&lt;/li&gt;
&lt;li&gt;3.2 对象中成员的访问&lt;/li&gt;
&lt;li&gt;3.3 类成员的访问属性&lt;/li&gt;
&lt;li&gt;3.4 类中成员的访问方式&lt;/li&gt;
&lt;li&gt;3.5 对象赋值语句&lt;/li&gt;
&lt;li&gt;3.6 类的作用域&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类（class）是面向对象程序设计的最基本的概念，是C++最强有力的特征，是进行封装和数据隐藏的工具，它将一个数据结构与一个操作集紧密地结合起来。类对象是类的实例，用类对象模拟现实世界中的事物比用数据对象更确切。&lt;/p&gt;
&lt;h2 id=&quot;类的构成&quot;&gt;1. 类的构成&lt;/h2&gt;
&lt;h3 id=&quot;从结构到类&quot;&gt;1.1 从结构到类&lt;/h3&gt;
&lt;p&gt;结构是C的一种自定义的数据类型，它把相关联的数据元素组成一个单独的统一体。&lt;/p&gt;
&lt;h5 id=&quot;例2.1有关日期结构的例子&quot;&gt;例2.1有关日期结构的例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
struct Date {
    int year;
    int month;
    int day;
};
int main()
{
    Date date1;
    date1.year=2003;
    date1.month=8;
    date1.day=25;
    cout&amp;lt;&amp;lt;date1.year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date1.month&amp;lt;&amp;lt;&quot;.&quot;
    &amp;lt;&amp;lt;date1.day&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;class与struct的比较&quot;&gt;⭐class与struct的比较&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;类是C++对C中结构的扩展。&lt;/li&gt;
&lt;li&gt;C语言中的struct是数据成员集合，而C++中的类，则是&lt;strong&gt;数据成员&lt;/strong&gt;和&lt;strong&gt;成员函数&lt;/strong&gt;的集合。&lt;/li&gt;
&lt;li&gt;struct是用户定义的数据类型，是一种构造数据类型。类和struct一样，也是一种用户定义的数据类型，是一种&lt;strong&gt;构造数据类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;C结构无法对数据&lt;strong&gt;进行保护和权限控制&lt;/strong&gt;，所以结构中的数据是不安全的。C++中的类将数据和与之相关联的数据封装在一起，形成一个整体，具有良好的外部接口可以防止数据未经授权的访问，提供了模块间的独立性。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类的构成-1&quot;&gt;1.2 类的构成&lt;/h3&gt;
&lt;p&gt;类的成员分两部分：一部分对应数据的状态，称为&lt;strong&gt;数据成员&lt;/strong&gt;，另一部分为作用于该数据状态的函数，称为&lt;strong&gt;成员函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;类声明的一般格式如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class 类名 {
public:
    公有数据成员;
    公有成员函数;
protected:
    保护数据成员;
    保护成员函数;
private:
    私有数据成员;
    私有成员函数;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3个关键字： &lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;和&lt;code&gt;public&lt;/code&gt;,称为访问权限关键字。每个关键字下面又都可以有数据成员和成员函数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;private&lt;/code&gt;部分称为类的私有部分，这一部分的数据成员和成员函数称为类的私有成员。私有成员只能由本类的成员函数访问，而类外部的任何访问都是非法的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public&lt;/code&gt;部分称为类的公有部分，这部分的数据成员和成员函数称为类的公有成员。公有成员可以由程序中的函数访问，它对外是完全开放的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;protected&lt;/code&gt;部分称为类的保护部分，这部分的数据成员和成员函数称为类的保护成员。保护成员可以由本类的成员函数访问，也可以由本类的派生类的成员函数访问，而类外的任何访问都是非法的。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;注意&quot;&gt;注意：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) 类声明格式中的3个部分并非一定要全有，但至少要有其中的一个部分。
&lt;ul&gt;&lt;li&gt;一般一个类的&lt;strong&gt;数据&lt;/strong&gt;成员应该声明为&lt;strong&gt;私有&lt;/strong&gt;成员，成员&lt;strong&gt;函数&lt;/strong&gt;声明为&lt;strong&gt;公有&lt;/strong&gt;成员。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;(2) 类声明中的&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;和&lt;code&gt;public&lt;/code&gt;三个关键字可以按任意顺序出现任意次。但是，如果把所有的私有成员、保护成员和公有成员归类放在一起，程序将更加清晰。&lt;/li&gt;
&lt;li&gt;(3) &lt;code&gt;private&lt;/code&gt;处于&lt;strong&gt;类体中第一部分&lt;/strong&gt;时， 关键字&lt;code&gt;private&lt;/code&gt;可以&lt;strong&gt;省略&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;(4) 数据成员可以是任何数据类型，但不能用自动(auto)、寄存器(register)或外部(extern)进行声明。&lt;/li&gt;
&lt;li&gt;(5) &lt;strong&gt;不能在类声明中给数据成员赋值&lt;/strong&gt;。C++规定，只有在类对象定义之后才能给数据成员赋初值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用一个类来描述日期,其形式如下:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Date {
public:
    void setDate(int y,int m,int d);
    void showDate();
private:
    int m_year;
    int m_month;
    int m_day;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;成员函数的声明&quot;&gt;2. 成员函数的声明&lt;/h2&gt;
&lt;p&gt;成员函数的声明通常采用以下两种方式:&lt;/p&gt;
&lt;h3 id=&quot;普通成员函数形式&quot;&gt;2.1 普通成员函数形式&lt;/h3&gt;
&lt;p&gt;即在类的声明中只给出成员函数的原型，而成员函数体写在类的外部。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回类型 成员函数 (参数列表);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类外定义的一般形式是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;返回类型 类名∷成员函数名(参数表)&lt;br/&gt;{&lt;br/&gt;// 函数体&lt;br/&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如, 以下是表示坐标点的类Coord的声明&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord {
public:
    void setCoord (int,int); // 设置坐标点
    int getx(); // 取x坐标点
    int gety(); // 取y坐标点
private:
    int x,y;
};
void Coord∷setCoord(int a,int b){ x=a; y=b;}
int Coord::getx(){ return x;}
int Coord::gety(){ return y;}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;内联函数和外联函数&quot;&gt;内联函数和外联函数&lt;/h4&gt;
&lt;p&gt;类的成员函数可以分为内联函数和外联函数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;内联函数&lt;/strong&gt;是指那些定义在类体内的成员函数，即该函数的函数体放在类体内。而说明在类体内，定义在类体外的成员函数叫&lt;strong&gt;外联函数&lt;/strong&gt;。外联函数的函数体在类的实现部分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内联函数&lt;/strong&gt;在调用时不是像一般函数那样要转去执行被调用函数的函数体，执行完成后再转回调用函数中，执行其后语句，而是在调用函数处用内联函数体的代码来替换，这样将会节省调用开销，提高运行速度。&lt;/li&gt;
&lt;li&gt;内联函数与带参数的宏定义进行一下比较，它们的代码效率是一样的，但是内联函数要优于宏定义，因为内联函数遵循函数的类型和作用域规则，它与一般函数更相近，在一些编译器中，一旦关上内联扩展，将与一般函数一样进行调用，调试比较方便。&lt;/li&gt;
&lt;li&gt;外联函数变成内联函数的方法很简单，只要在函&lt;br/&gt;数头前面加上关键字inline就可以了。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;将成员函数以内联函数的形式进行说明&quot;&gt;2.2 将成员函数以内联函数的形式进行说明&lt;/h3&gt;
&lt;p&gt;有两种格式将成员函数声明为类的内联函数:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）&lt;strong&gt;隐式声明&lt;/strong&gt; 直接将函数声明在类内部。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord{
public:
    void setCoord(int a,int b)
    { x=a; y=b;}
    int getx()
    { return x;}
    int gety()
    { retrun y;}
private:
    int x,y;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;（2）&lt;strong&gt;显式声明&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在类声明中只给出成员函数的原型，而成员函数体写在类的外部。为了使它起内联函数的作用，在成员函数返回类型前冠以关键字“inline”。&lt;/p&gt;
&lt;p&gt;这种成员函数在类外定义的一般形式是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;inline 返回类型 类名::成员函数名(参数表)&lt;br/&gt;{&lt;br/&gt;// 函数体&lt;br/&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord{
public:
    void setCoord(int,int);
    int getx();
    int gety();
private:
    int x,y;
};
inline void Coord::setCoord(int a,int b)
{ x=a; y=b;}
inline int Coord::getx(){ return x;}
inline int Coord::gety(){ return y; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明&quot;&gt;说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1)使用inline说明内联函数时，&lt;strong&gt;必须使函数体和inline说明结合在一起&lt;/strong&gt;，否则编译器将它作为普通函数处理。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline void Coord:: setCoord(int ,int);
// 不能说明这是一个内联函数&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;(2) 通常只有较短的成员函数才定义为内联函数，对较长的成员函数最好作为一般函数处理。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Date{
public:
    void showDate();
private:
    int year;
    int month;
    int day;
};
inline void Date::showDate()
{cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;'.';&amp;lt;&amp;lt;month&amp;lt;&amp;lt;'.'&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl;}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对象的定义和使用&quot;&gt;3. 对象的定义和使用&lt;/h2&gt;
&lt;h4 id=&quot;类与对象的关系&quot;&gt;类与对象的关系&lt;/h4&gt;
&lt;p&gt;通常我们把具有&lt;strong&gt;共同属性和行为&lt;/strong&gt;的事物所构成的集合叫做&lt;strong&gt;类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在C++中,可以把&lt;strong&gt;相同数据结构&lt;/strong&gt;和&lt;strong&gt;相同操作集&lt;/strong&gt;的&lt;strong&gt;对象&lt;/strong&gt;看成属于同一类。&lt;/p&gt;
&lt;p&gt;在C++中，类也是一种用户自定义数据类型，类的对象可以看成是该类类型的一个实例，定义一个对象和定义一个变量相似。类与对象间的关系，可以用数据类型int和整型变量i之间的关系类比。&lt;/p&gt;
&lt;p&gt;C++把类的变量叫做类的对象，对象也称为类的实例。&lt;/p&gt;
&lt;h3 id=&quot;对象的定义&quot;&gt;3.1 对象的定义&lt;/h3&gt;
&lt;p&gt;对象的定义， 也称对象的创建&lt;/p&gt;
&lt;p&gt;在C++中可以用以下两种方法定义对象：&lt;/p&gt;
&lt;h4 id=&quot;在声明类的同时直接定义对象&quot;&gt;(1) 在声明类的同时,直接定义对象。&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord {
public:
    void setCoord(int,int);
    int getx();
    int gety();
private:
    int x,y;
} op1,op2;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;声明了类之后在使用时再定义对象&quot;&gt;(2) 声明了类之后,在使用时再定义对象&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Coord {
    //…
};
// …
main()
{
    Coord op1,op2;
    // …
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明-1&quot;&gt;说明：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在声明类的&lt;strong&gt;同时定义&lt;/strong&gt;的对象是一种&lt;strong&gt;全局对象&lt;/strong&gt;，在它的生存期内任何函数都可以使用它。&lt;/li&gt;
&lt;li&gt;声明了一个类便声明了一种&lt;strong&gt;类型&lt;/strong&gt;，它并不接收和存储具体的值，只作为生成具体对象的一种“样板”，只有定义了对象后，系统才为对象分配存储空间。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;对象中成员的访问&quot;&gt;3.2 对象中成员的访问&lt;/h3&gt;
&lt;p&gt;当定义了一个类的对象后，就可以访问对象的成员了。在类的外部可以通过类的对象对&lt;strong&gt;公有成员&lt;/strong&gt;进行访问,访问对象成员要使用操作符“.”。&lt;/p&gt;
&lt;p&gt;访问的一般形式是:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对象名.数据成员名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对象名.成员函数名(参数表)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中“.”叫做&lt;strong&gt;对象选择符&lt;/strong&gt;,简称&lt;strong&gt;点运算符&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;例2.2-使用类coord的完整程序&quot;&gt;例2.2 使用类Coord的完整程序&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class Coord {
public：
    void setCoord(int a,int b)
    { x=a; y=b; }
    int getx()
    { return x; }
    int gety()
    { return y; }
private：
    int x,y;
};
void main()
{
    Coord op1,op2;
    int i,j;
    op1.setCoord(5,6); // 调用op1的setCoord()，初始化对象op1
    op2.setCoord(7,8); // 调用op2的setCoord()，初始化对象op2
    i=op1.getx(); // 调用op1的getx()，取op1的x值
    j=op1.gety(); // 调用op1的gety()，取op1的y值
    cout&amp;lt;&amp;lt;&quot;op1 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op1 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
    i=op2.getx(); // 调用op2的getx()，取op2的x值
    j=op2.gety(); // 调用op2的gety()，取op2的y值
    cout&amp;lt;&amp;lt;&quot;op2 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op2 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明-2&quot;&gt;说明：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;对象名.成员名实际上是一种缩写形式，它表&lt;br/&gt;达的意义是:&lt;strong&gt;对象名.类名::成员名&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void main( )
{
    Date date1;
    date1.setDate(2006,9,21);
    //……
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在类的内部所有成员之间都可以通过成员函数直接访问，但是&lt;strong&gt;类的外部不能访问对象的私有成员&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;例2.3-一个存在错误的程序&quot;&gt;例2.3 一个存在错误的程序&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date {
public:
    void setDate(int y,int m,int d);
    void showDate();
private:
    int year;
    int month;
    int day;
};
void Date∷setDate(int y,int m,int d)
{
    year=y;
    month=m;
    day=d;
}
inline void Date∷showDate()
{
    cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl;
}
void main()
{
    Date date1,date2;
    cout&amp;lt;&amp;lt;&quot;Date1 set and output:&quot;&amp;lt;&amp;lt;endl;
    date1.setDate(1998,4,28);
    cout&amp;lt;&amp;lt;date1.year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date1.month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date1.day&amp;lt;&amp;lt;endl; //错误
    date1.showDate();
    cout&amp;lt;&amp;lt;&quot;Date2 set and output： &quot;&amp;lt;&amp;lt;endl;
    date2.setDate(2002,11,14);
    cout&amp;lt;&amp;lt;date2.year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date2.month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;date2.day&amp;lt;&amp;lt;endl; //错误
    date2.showDate();•
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在定义对象时，若定义的是指向对象的&lt;strong&gt;指针&lt;/strong&gt;，则访问此对象的成员时，要用“-&amp;gt;”操作符。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void main( )
{
    Date *date3;
    date3-&amp;gt;setDate(2001,8,15);
    //……
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类成员的访问属性&quot;&gt;3.3 类成员的访问属性&lt;/h3&gt;
&lt;p&gt;类成员有三种访问属性:&lt;strong&gt;公有（public）&lt;/strong&gt;、 &lt;strong&gt;私有（private）&lt;/strong&gt; 和&lt;strong&gt;保护（protected）&lt;/strong&gt; 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;说明为公有的成员不但可以被类中成员函数访问;&lt;br/&gt;还可在类的外部,通过类的对象进行访问。&lt;/li&gt;
&lt;li&gt;说明为私有的成员只能被类中成员函数访问,不能&lt;br/&gt;在类的外部,通过类的对象进行访问。&lt;/li&gt;
&lt;li&gt;说明为保护的成员除了类本身的成员函数可以访&lt;br/&gt;问外,该类的派生类的成员也可以访问,但不能在类的&lt;br/&gt;外部,通过类的对象进行访问。类成员的访问属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类的成员对&lt;strong&gt;类对象&lt;/strong&gt;的可见性和对&lt;strong&gt;类的成员函数&lt;/strong&gt;的可见性是不同的。&lt;/p&gt;
&lt;p&gt;类的&lt;strong&gt;成员函数&lt;/strong&gt;可以访问类的&lt;strong&gt;所有成员&lt;/strong&gt;，而&lt;strong&gt;类的对象&lt;/strong&gt;对类的成员的访问是受类成员的&lt;strong&gt;访问属性的制约&lt;/strong&gt;的。&lt;/p&gt;
&lt;h3 id=&quot;类中成员的访问方式&quot;&gt;3.4 类中成员的访问方式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;类中成员互访：直接使用成员名&lt;/li&gt;
&lt;li&gt;类外访问：使用“&lt;strong&gt;对象名.成员名&lt;/strong&gt;”方式访问 public 属性的成员&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Sample{
public:
    int k;
    int geti(){return i;}
    int getj(){return j;}int getk(){return k;}
private:
    int i;
protected:
    int j;
};
//……
Sample a; //定义类Sample的对象a
a.i; //非法，类Sample的对象a不能访问类的私有成员i
a.j; //非法，类Sample的对象a不能访问类的保护成员j
a.k; //合法，类Sample的对象a能访问类的公有成员k
//……&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，公有成员是类的对外接口，而私有成员和保护成员是类的内部数据和内部实现，不希望外界访问。&lt;/p&gt;
&lt;p&gt;将类的成员划分为不同的访问级别有两个好处：一是&lt;strong&gt;信息隐蔽&lt;/strong&gt;，即实现封装；二是&lt;strong&gt;数据保护&lt;/strong&gt;，即将类的重要信息保护起来，以免其它程序不恰当地修改。&lt;/p&gt;
&lt;h3 id=&quot;对象赋值语句&quot;&gt;3.5 对象赋值语句&lt;/h3&gt;
&lt;p&gt;两个同类型的变量之间可以相互赋值。同类型的对象间也可以进行赋值，当一个对象赋值给另一个对象时，所有的数据成员都会&lt;strong&gt;逐位拷贝&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;例2.5&quot;&gt;例2.5&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class abc{
public:
    void init(int i,int j) { a=i; b=j; }
    void show(){ cout&amp;lt;&amp;lt;a&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;b&amp;lt;&amp;lt;endl; }
private:
    int a,b;
};
main()
{
    abc o1,o2;
    o1.init(12,34);
    o2=o1; // 将对象o1数据成员的值赋给对象o2
    o1.show();
    o2.show();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明-3&quot;&gt;说明：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在使用对象赋值语句进行对象赋值时，两个对象的&lt;strong&gt;类型必须相同&lt;/strong&gt;，如果对象的类型不同，编译时将出错。&lt;/li&gt;
&lt;li&gt;两个对象之间的赋值，仅仅使这些对象中&lt;strong&gt;数据成员相同&lt;/strong&gt;，而两个对象仍是分离的。&lt;/li&gt;
&lt;li&gt;例2.5的对象赋值是通过缺省的&lt;strong&gt;赋值运算符函数&lt;/strong&gt;实现的。&lt;/li&gt;
&lt;li&gt;当类中存在指针时，使用缺省的赋值运算符进行对象赋值，可能会&lt;strong&gt;产生错误&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类的作用域&quot;&gt;3.6 类的作用域&lt;/h3&gt;
&lt;p&gt;所谓类的作用域就是指在类声明中的一对花括号所形成的作用域。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个类的所有成员都在该类的作用域内,&lt;strong&gt;一个类的任何成员可以访问该类的其他成员&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个类的成员函数可以不受限制地访问类的成员&lt;/strong&gt;，而在类的外部，对该类的数据成员和成员函数的访问则要受到一定的限制，有时甚至是不允许的,这体现了类的封装功能。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;例2.6-理解类的作用域&quot;&gt;例2.6 理解类的作用域&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;# include&amp;lt;iostream.h&amp;gt;
class myclass{
public:
    int i;
    void init(int);
    void show(){ cout&amp;lt;&amp;lt;“i=” &amp;lt;&amp;lt;i&amp;lt;&amp;lt;endl;} // 可以访问类中的数据成员i
};
void myclass::init(int si){ i=si;} // 可以访问类中的数据成员i
int fun(){ return i; } // 非法,不能直接访问类中的i
void main()
{
    myclass ob;
    ob.init(5); // 给数据成员i赋初值5
    ob.show();
    i=8; // 非法,不能直接访问类中的i,可改写成ob.i=8
    ob.show();
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 12 Mar 2019 15:18:00 +0000</pubDate>
<dc:creator>鲸90830</dc:creator>
<og:description>类和对象 OOP第二课 1 类的构成 1.1 从结构到类 1.2 类的构成 2 成员函数的声明 2.1 普通成员函数形式 2.2 将成员函数以内联函数的形式进行说明 3 对象的定义和使用 3.1 对象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whale90830/p/10520364.html</dc:identifier>
</item>
<item>
<title>C++_构造函数与析构函数 - 鲸90830</title>
<link>http://www.cnblogs.com/whale90830/p/10520316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/whale90830/p/10520316.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;OOP第二课&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;1 构造函数
&lt;ul&gt;&lt;li&gt;1.1 构造函数具有一些特殊的性质&lt;/li&gt;
&lt;li&gt;1.2 定义构造函数的一般形式&lt;/li&gt;
&lt;li&gt;1.3 利用构造函数创建对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2 成员初始化表&lt;/li&gt;
&lt;li&gt;3 缺省参数的构造函数&lt;/li&gt;
&lt;li&gt;4 重载构造函数&lt;/li&gt;
&lt;li&gt;5 拷贝构造函数
&lt;ul&gt;&lt;li&gt;5.1 自定义拷贝构造函数&lt;/li&gt;
&lt;li&gt;5.2 缺省的拷贝构造函数&lt;/li&gt;
&lt;li&gt;5.3 调用拷贝构造函数的三种情况&lt;/li&gt;
&lt;li&gt;5.4 浅拷贝和深拷贝&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;6 析构函数&lt;/li&gt;
&lt;li&gt;7 调用构造函数和析构函数的顺序&lt;/li&gt;
&lt;li&gt;8 对象的生存期&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;构造函数和析构函数都是类的成员函数,但它们都是特殊的成员函数,执行特殊的功能,不用调用便&lt;strong&gt;自动执行&lt;/strong&gt;,而且这些&lt;strong&gt;函数的名字&lt;/strong&gt;与&lt;strong&gt;类的名字&lt;/strong&gt;有关。&lt;/p&gt;
&lt;p&gt;C++语言中有一些成员函数性质是特殊的，这些成员函数负责&lt;strong&gt;对象的建立、删除&lt;/strong&gt;。这些函数的特殊性在于可以由编译器&lt;strong&gt;自动地隐含调用&lt;/strong&gt;，其中一些函数调用格式采用运算符函数重载的语法。&lt;/p&gt;
&lt;p&gt;C++引进一个自动完成对象初始化过程的机制，这就是类的构造函数。&lt;/p&gt;
&lt;h4 id=&quot;对象的初始化&quot;&gt;对象的初始化&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;数据成员是不能在声明类时初始化&lt;/li&gt;
&lt;li&gt;类型对象的初始化方法：&lt;br/&gt;1) 调用对外接口（public成员函数）实现：声明类→定义对象→调用接口给成员赋值&lt;br/&gt;2) 应用构造函数（constructor） 实现：声明类→定义对象→同时给成员赋值&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;构造函数&quot;&gt;1. 构造函数&lt;/h2&gt;
&lt;p&gt;构造函数是&lt;strong&gt;一种特殊的成员函数&lt;/strong&gt;,它主要用于&lt;strong&gt;为对象分配空间&lt;/strong&gt;,进行初始化。&lt;/p&gt;
&lt;h4 id=&quot;构造函数具有一些特殊的性质&quot;&gt;1.1 构造函数具有一些特殊的性质:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) 构造函数的名字必须&lt;strong&gt;与类名相同&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;(2) 构造函数可以有任意类型的参数,但&lt;strong&gt;不能指定返回类型&lt;/strong&gt;。 它有隐含的返回值,该值由系统内部使用。&lt;/li&gt;
&lt;li&gt;(3) 构造函数是特殊的成员函数,函数体可写在类体内,也可写在类体外。&lt;/li&gt;
&lt;li&gt;(4) 构造函数&lt;strong&gt;可以重载&lt;/strong&gt;,即一个类中可以定义多个参数个数或参数类型不同的构造函数。构造函数是不能继承&lt;/li&gt;
&lt;li&gt;(5) 构造函数被声明为&lt;strong&gt;公有函数&lt;/strong&gt;,但它不能像其他成员函数那样被显式地调用,它是在定义对象的同时被调用的。&lt;/li&gt;
&lt;li&gt;(6) 在声明类时如果没有定义类的构造函数，编译系统就会在编译时自动生成一个默认形式的构造函数，&lt;/li&gt;
&lt;li&gt;(7) &lt;strong&gt;默认构造函数&lt;/strong&gt;是构造对象时不提供参数的构造函数。&lt;/li&gt;
&lt;li&gt;(8) 除了无参数构造函数是默认构造函数外，带有全部默认参数值的构造函数也是默认构造函数。&lt;/li&gt;
&lt;li&gt;(9) &lt;strong&gt;自动调用&lt;/strong&gt;：构造函数在定义类对象时自动调用， 不需用户调用，也不能被用户调用。在对象使用前调用。&lt;/li&gt;
&lt;li&gt;(10) &lt;strong&gt;调用顺序&lt;/strong&gt;：在对象进入其作用域时（对象使用前） 调用构造函数。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;定义构造函数的一般形式&quot;&gt;1.2 定义构造函数的一般形式&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class 类名
{
public:
    类名（形参表） ; //构造函数的原型
    //类的其它成员
};
类名::类名（形参表） //构造函数的实现
{
    //函数体
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;利用构造函数创建对象&quot;&gt;1.3 利用构造函数创建对象&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) 利用构造函数直接创建对象.其一般形式为：&lt;strong&gt;类名 对象名[(实参表)];&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里的“类名”与构造函数名相同,“实参表”是为构造函数提供的实际参数。&lt;/p&gt;
&lt;h5 id=&quot;例2.7-为类date建立一个构造函数&quot;&gt;例2.7 为类Date建立一个构造函数&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date {
public:
    Date(int y,int m,int d); // 构造函数
    void setDate(int y,int m,int d);
    void showDate();
private:
    int year, month, day;
};
Date::Date(int y,int m,int d) // 构造函数的实现
{ year=y; month=m; day=d; }
void Date::setDate(int y,int m,int d)
{ year=y; month=m; day=d; }
inline void Date::showDate()
{ cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl; }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;例2.8-利用构造函数直接创建对象&quot;&gt;例2.8 利用构造函数直接创建对象&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date {
// 省略， 同例2.7
};
// 省略， 同例2.7
void main()
{
    Date date1(1998,4,28); // 定义类Date的对象date1,
    // 自动调用date1的构造函数,初始化对象date1
    cout&amp;lt;&amp;lt;&quot;Date1 output1:&quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate(),显示date1的数据
    date1.SetDate(2002,11,14); // 调用date1的setDate(),
    // 重新设置date1的数据
    cout&amp;lt;&amp;lt;&quot;Date1 output2:&quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate(),显示date1的数据
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;constructing...
Date1 output1:
1998.4.28
Date1 output2:
2002.11.14&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;(2) 利用构造函数创建对象时,通过指针和new来实现。其一般语法形式为:&lt;br/&gt;&lt;strong&gt;类名 *指针变量 = new 类名[(实参表)];&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void main()
{
    Date *date1;
    date1=new Date(1998,4,28);
    //可合写成:Date *date1=new Date(1998,4,28);
    cout&amp;lt;&amp;lt;&quot;Date1 output1:&quot;&amp;lt;&amp;lt;endl;
    date1-&amp;gt;showDate();
    date1-&amp;gt;setDate(2002,11,14);
    cout&amp;lt;&amp;lt;&quot;Date1 output2:&quot;&amp;lt;&amp;lt;endl;
    date1-&amp;gt;showDate();
    delete date1;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明&quot;&gt;说明：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;构造函数的名字必须与类名相同，否则编译器将把它当作一般的成员函数来处理。&lt;/li&gt;
&lt;li&gt;构造函数是不能说明它的返回值类型的，甚至说明为void类型也不行。&lt;/li&gt;
&lt;li&gt;构造函数可以是不带参数的。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class A{
public:
    A();
    //…
private:
    int x;
};
A∷A()
{
    cout&amp;lt;&amp;lt;&quot;initialized \n&quot;;
    x=50;
}
main()
{
    A a;
    …
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;例&quot;&gt;例&lt;/h5&gt;
&lt;p&gt;有两个长方柱，其长、宽、高分别为：(1)12,25,30；(2)15,30,21。求它们的体积。要求：编一个基于对象的程序，在类中用带参数的构造函数。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Box{
public:
    Box(int,int,int);
    int volume( );
private:
    int height;
    int width;
    int length;
};
Box::Box(int h,int w,int len)
{
    height = h;
    width = w;
    length = len;
}
int Box::volume( )
{
    return height*width*length;
}
int main( )
{
    Box box1(12,25,30);
    cout &amp;lt;&amp;lt; box1.volume( ) &amp;lt;&amp;lt; endl;
    Box box2(15,30,21);
    cout &amp;lt;&amp;lt; box2.volume( ) &amp;lt;&amp;lt; endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;成员初始化表&quot;&gt;2. 成员初始化表&lt;/h2&gt;
&lt;p&gt;对于&lt;strong&gt;常量类型&lt;/strong&gt;和&lt;strong&gt;引用类型&lt;/strong&gt;的数据成员,不能在构造函数中用&lt;strong&gt;赋值语句&lt;/strong&gt;直接赋值,C++提供初始化表进行置初值。&lt;/p&gt;
&lt;p&gt;带有成员初始化表的构造函数的一般形式如下:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类名::构造函数名([参数表])[:(成员初始化表)]&lt;br/&gt;{&lt;br/&gt;// 构造函数体&lt;br/&gt;}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;成员初始化表的一般形式为:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据成员名1(初始值1),数据成员名2(初始值2),……&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;例2.9-成员初始化表的使用&quot;&gt;例2.9 成员初始化表的使用&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class A{
public:
    A(int x1):x(x1),rx(x),pi(3.14) // rx(x)相当于rx=x, pi(3.14)相当于pi=3.14
    { }
    void print()
    {cout&amp;lt;&amp;lt;&quot;x=&quot;&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;&quot;rx=&quot;&amp;lt;&amp;lt;rx&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;&quot;pi=&quot;&amp;lt;&amp;lt;pi;}
private:
    int x; int&amp;amp; rx; const float pi;
};
main()
{
    A a(10);
    a.print();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;构造函数采用成员初始化表对数据成员进行初始化，是一些程序员喜欢使用的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class B{
    int i;
    char j;
    float f;
public：
    B(int I， char J， float F)
    { i=I; j=J; f=F; };
};&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class B{
public：
    B(int I,char J,float F):i(I),j(J),f(F)
    { }
private:
    int i;
    char j;
    float f;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明-1&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;如果需要将数据成员存放在堆中或数组中，则应在构造函数中使用赋值语句，即使构造函数有成员初始化表也应如此。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class C{
public:
    C(int I,char Ch,float F,char N[]):i(I),ch(Ch),f(F)
    { strcpy (name,N);}
private:
    int i;
    char ch;
    float f;
    char name[25];
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;类成员是按照它们&lt;strong&gt;在类里被声明的顺序&lt;/strong&gt;初始化的,与它们在初始化表中列出的顺序无关。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;例2.10&quot;&gt;【例2.10】&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class D {
public:
    D(int i):mem2(i),mem1(mem2+1)
    {
        cout&amp;lt;&amp;lt;&quot;mem1: &quot;&amp;lt;&amp;lt;mem1&amp;lt;&amp;lt;endl;
        cout&amp;lt;&amp;lt;&quot;mem2: &quot;&amp;lt;&amp;lt;mem2&amp;lt;&amp;lt;endl;
    }
private:
    int mem1;
    int mem2;
};
void main()
{
    D d(15);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;mem1: -858993459
mem2: 15&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;缺省参数的构造函数&quot;&gt;3. 缺省参数的构造函数&lt;/h2&gt;
&lt;h5 id=&quot;例2.11&quot;&gt;例2.11&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class Coord {
public:
    Coord(int a=0,int b=0){ x=a; y=b;} // 带有缺省参数的构造函数
    int getx(){ return x; }
    int gety(){ return y; }
private:
    int x,y;
};
void main()
{
    Coord op1(5,6); Coord op2(5); Coord op3;
    int i,j;
    i=op1.getx();j=op1.gety();
    cout&amp;lt;&amp;lt;&quot;op1 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op1 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
    i=op2.getx();j=op2.gety();
    cout&amp;lt;&amp;lt;&quot;op2 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op2 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
    i=op3.getx();j=op3.gety();
    cout&amp;lt;&amp;lt;&quot;op3 i= &quot;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&quot; op3 j= &quot;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Box{
public:
    Box(int h=10,int w=10,int l=10); //在声明构造函数时指定默认参数
    int volume( ){ return(height*width*length); }
private:
    int height;
    int width;
    int length;
};
Box:: Box(int h,int w,int l) //在定义函数时可以不指定默认参数
{
    height=h;
    width=w;
    length=l;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重载构造函数&quot;&gt;4. 重载构造函数&lt;/h2&gt;
&lt;h4 id=&quot;构造函数的重载&quot;&gt;构造函数的重载&lt;/h4&gt;
&lt;p&gt;在一个类中可以定义多个构造函数，以便对类对象提供不同的初始化的方法，供用户选用。这些构造函数具有相同的名字，而参数的个数或参数的类&lt;br/&gt;型不相同（这称为构造函数的重载）&lt;/p&gt;
&lt;h4 id=&quot;关于构造函数重载的说明&quot;&gt;关于构造函数重载的说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) &lt;strong&gt;默认构造函数&lt;/strong&gt;：一个调用构造函数时不必给出实参的构造函数。 显然，无参的构造函数属于默认构造函数。一个类只能有一个默认构造函数。&lt;/li&gt;
&lt;li&gt;(2) 尽管在一个类中可以包含多个构造函数，但是对于每一个对象来说，&lt;strong&gt;建立对象时只执行其中一个构造函数&lt;/strong&gt;，并非每个构造函数都被执行。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class Box{
public:
    Box(int h, int w, int l): height(h),width(w),length(l) { }
    Box();
    int volume( );
private:
    int height;
    int width;
    int length;
};
Box::Box()
{
    height = 10;
    width = 10;
    lenght = 10;
}
int Box::volume( )
{
    return height*width*length;
}
int main( )
{
    Box box1; // 书上为 box1();
    cout &amp;lt;&amp;lt; box1.volume( ) &amp;lt;&amp;lt; endl;
    Box box2(15,30,25);
    cout &amp;lt;&amp;lt; box2.volume( ) &amp;lt;&amp;lt; endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;例2.17-重载构造函数应用例程&quot;&gt;例2.17 重载构造函数应用例程。&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date{
public:
    Date(); // 无参数的构造函数
    Date(int y,int m,int d); // 带有参数的构造函数
    void showDate();
private:
    int year, month, day;
};
Date::Date()
{ year=1998; month=4; day=28; }
Date::Date( int y, int m, int d)
{ year=y; month=m; day=d; }
inline void Date::showDate()
{ cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl; }
void main()
{
    Date date1; // 声明类Date的对象date1，
    // 调用无参数的构造函数
    cout&amp;lt;&amp;lt;&quot;Date1 output： &quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate()，显示date1的数据
    Date date2(2002， 11， 14); // 定义类Date的对象date2，
    // 调用带参数的构造函数
    cout&amp;lt;&amp;lt;&quot;Date2 output： &quot;&amp;lt;&amp;lt;endl;
    date2.showDate(); // 调用date2的showDate()，显示date2的数据
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Date1 output：
1998.4.28
Date2 output：
2002.11.14&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;例2.18-关于计时器的例子&quot;&gt;例2.18 关于计时器的例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
class timer{
public:
    timer() // 无参数构造函数,给seconds清0
    { seconds=0; }
    timer(char* t) // 含一个数字串参数的构造函数
    { seconds=atoi(t); }
    timer(int t) // 含一个整型参数的构造函数
    { seconds=t; }
    timer(int min,int sec) // 含两个整型参数的构造函数
    { seconds=min*60+sec; }
    int gettime()
    { return seconds; }
private：
    int seconds;
};
main()
{
    timer a,b(10),c(&quot;20&quot;),d(1,10);
    cout&amp;lt;&amp;lt;&quot;seconds1=&quot;&amp;lt;&amp;lt;a.gettime()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&quot;seconds2=&quot;&amp;lt;&amp;lt;b.gettime()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&quot;seconds3=&quot;&amp;lt;&amp;lt;c.gettime()&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&quot;seconds4=&quot;&amp;lt;&amp;lt;d.gettime()&amp;lt;&amp;lt;endl;
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;class x {
public:
    x(); // 没有参数的构造函数
    x(int i=0); // 带缺省参数的构造函数
};
//…
void main()
{
    x one(10); // 正确,调用x(int i=0)
    x two; // 存在二义性
    //…
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;拷贝构造函数&quot;&gt;5. 拷贝构造函数&lt;/h2&gt;
&lt;p&gt;拷贝构造函数是一种&lt;strong&gt;特殊的构造函数&lt;/strong&gt;,其形参是&lt;strong&gt;本类对象的引用&lt;/strong&gt;。其作用是使用一个已经存在的对象去初始化另一个同类的对象。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过等于号复制对象时，系统会自动调用拷贝构造函数。&lt;/li&gt;
&lt;li&gt;拷贝构造函数与原来的构造函数实现了函数的重载。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;拷贝构造函数具有以下特点&quot;&gt;拷贝构造函数具有以下特点:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;(1) 因为该函数也是一种构造函数,所以其函数名与类名相同,并且该函数也没有返回值类型。&lt;/li&gt;
&lt;li&gt;(2) 该函数&lt;strong&gt;只有一个参数&lt;/strong&gt;,并且是&lt;strong&gt;同类对象的引用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;(3) 每个类都&lt;strong&gt;必须有&lt;/strong&gt;一个拷贝构造函数。程序员可以根据需要定义特定的拷贝构造函数,以实现同类对象之间数据成员的传递。如果程序员没有定义类的拷贝构造函数,系统就会自动生成产生一个缺省的拷贝构造函数。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;自定义拷贝构造函数&quot;&gt;5.1 自定义拷贝构造函数&lt;/h3&gt;
&lt;p&gt;自定义拷贝构造函数的一般形式如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class 类名{
public :
    类名（形参）； //构造函数
    类名（类名 &amp;amp;对象名）； //拷贝构造函数
...
}；
类名:: 类名（类名 &amp;amp;对象名） //拷贝构造函数的实现
{ 函数体 }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;用户自定义拷贝构造函数&quot;&gt;用户自定义拷贝构造函数&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;class Coord{
    int x,y;
public:
    Coord(int a， int b) // 构造函数
    {
        x=a;
        y=b;
        cout&amp;lt;&amp;lt;&quot;Using normal constructor\n&quot;;
    }
    Coord(const Coord&amp;amp; p) // 拷贝构造函数
    {
        x=2*p.x;
        y=2*p.y;
        cout&amp;lt;&amp;lt;&quot;Using copy constructor\n&quot;;
    }
    //…
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果p1、 p2为类Coord的两个对象，p1已经存在，则coord p2(p1)调用拷贝构造函数来初始化p2&lt;/p&gt;
&lt;h5 id=&quot;例2.19-自定义拷贝构造函数的使用&quot;&gt;例2.19 自定义拷贝构造函数的使用&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class Coord {
public:
    Coord(int a,int b) // 构造函数
    { x=a; y=b; cout&amp;lt;&amp;lt;&quot;Using normal constructor\n&quot;;}
    Coord(const Coord&amp;amp; p) // 拷贝构造函数
    { x=2*p.x; y=2*p.y; cout&amp;lt;&amp;lt;&quot;Using copy constructor\n&quot;;}
    void print(){ cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl; }
private:
    int x,y;
};
main()
{
    Coord p1(30,40); // 定义对象p1,调用了普通的构造函数
    Coord p2(p1); // 以“代入” 法调用拷贝构造函数,用对象p1初始化对象p2
    p1.print();
    p2.print();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了用&lt;strong&gt;代入法&lt;/strong&gt;调用拷贝构造函数外，还可以采用&lt;strong&gt;赋值法&lt;/strong&gt;调用拷贝构造函数，如：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;main()
{
    Coord p1(30,40);
    Coord p2=p1; //以&quot;赋值&quot;法调用拷贝构造函数，
    用对象p1初始化对象p2
    //…
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;缺省的拷贝构造函数&quot;&gt;5.2 缺省的拷贝构造函数&lt;/h3&gt;
&lt;p&gt;如果没有编写自定义的拷贝构造函数,C++会自动地将一个已存在的对象复制给新对象,这种&lt;strong&gt;按成员逐一复制&lt;/strong&gt;的过程由是缺省拷贝构造函数自动完成的。&lt;/p&gt;
&lt;h5 id=&quot;例2.20-调用缺省的拷贝构造函数&quot;&gt;例2.20 调用缺省的拷贝构造函数&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
class Coord{
public:
    Coord(int a,int b)
    { x=a; y=b; cout&amp;lt;&amp;lt;&quot;Using normal constructor\n&quot;; }
    void print(){ cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;y&amp;lt;&amp;lt;endl;}
private:
    int x,y;
};
main()
{
    Coord p1(30,40); // 定义类Coord的对象p1,
    // 调用了普通构造函数初始化对象p1
    Coord p2(p1); // 以“代入”法调用缺省的拷贝构造函数,
    // 用对象p1初始化对象p2
    Coord p3=p1; // 以“赋值”法调用缺省的拷贝构造函数,
    // 用对象p1初始化对象p3
    p1.print(); p2.print(); p3.print();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;调用拷贝构造函数的三种情况&quot;&gt;5.3 调用拷贝构造函数的三种情况&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;(1) 当用类的一个对象去初始化该类的另一个对象时。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Coord p2(p1); // 用对象p1初始化对象p2, 拷贝构造函数被调用(代入法)
Coord p3=p1; // 用对象p1初始化对象p3, 拷贝构造函数被调用(赋值法)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;(2) 当函数的形参是类的对象,调用函数,进行形参和实参结合时。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;//…
fun1(Coord p) // 函数的形参是类的对象
{
    p.print();
}
main()
{
    Coord p1(10,20);
    fun1(p1); // 当调用函数,进行形参和实参结合时,
    调用拷贝构造函数
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;(3) 当函数的返回值是对象,函数执行完成,返回调用者时。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// …
Coord fun2()
{
    Coord p1(10,30);
    return p1;
} // 函数的返回值是对象
main()
{
    Coord p2;
    P2=fun2(); // 函数执行完成,返回调用者时,调用拷贝构造函数
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;浅拷贝和深拷贝&quot;&gt;5.4 浅拷贝和深拷贝&lt;/h3&gt;
&lt;p&gt;所谓&lt;strong&gt;浅拷贝&lt;/strong&gt;，就是由缺省的拷贝构造函数所实现的数据成员逐一赋值，&lt;strong&gt;若类中含有指针类型数据， 则会产生错误&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为了解决浅拷贝出现的错误，必须显示地定义一个自己的拷贝构造函数，使之不但拷贝数据成员，而且为对象1和对象2分配各自的内存空间，这就是所谓的&lt;strong&gt;深拷贝&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;例2.23-浅拷贝例子&quot;&gt;例2.23 浅拷贝例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
class Student {
public:
    Student(char *name1,float score1);
    ~Student();
private:
    char *name; // 学生姓名
    float score; // 学生成绩
};
Student∷Student(char *name1,float score1)
{
    cout&amp;lt;&amp;lt;&quot;Constructing...&quot;&amp;lt;&amp;lt;name1&amp;lt;&amp;lt;endl;
    name=new char[strlen(name1)+1];
    if (name !=0)
    {
        strcpy(name,name1);
        score=score1;
    }
}
Student∷~Student()
{
    cout&amp;lt;&amp;lt;&quot;Destructing...&quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;endl;
    name[0]='\0';
    delete name;
}
void main()
{
    Student stu1(&quot;liming&quot;,90); // 定义类Student的对象stu1
    Student stu2=stu1; // 调用缺省的拷贝构造函数
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Constructing... liming
Destructing... liming
Destructing...&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;浅拷贝示意图&quot;&gt;浅拷贝示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/12/AitNi6.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;例2.24-深拷贝例子&quot;&gt;例2.24 深拷贝例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
class Student {
private:
    char *name; // 学生姓名
    float score; // 学生成绩
public:
    Student(char *name1,float score1);
    Student(Student&amp;amp; stu);
    ~Student();
};
Student∷Student(char *name1,float score1)
{
    cout&amp;lt;&amp;lt;&quot;constructing...&quot;&amp;lt;&amp;lt;name1&amp;lt;&amp;lt;endl;
    name=new char[strlen(name1)+1];
    if (name !=0)
    {
        strcpy(name,name1);
        score=score1;
    }
}
Student∷Student(Student&amp;amp; stu)
{
    cout&amp;lt;&amp;lt;&quot;Copy constructing...&quot;&amp;lt;&amp;lt;stu.name&amp;lt;&amp;lt;endl;
    name=new char[strlen(stu.name)+1];
    if (name !=0)
    {
        strcpy(name,stu.name);
        score=stu.score;
    }
}
Student∷~Student()
{
    cout&amp;lt;&amp;lt;&quot;Destructing...&quot;&amp;lt;&amp;lt;name&amp;lt;&amp;lt;endl;
    name[0]='\0';
    delete name;
}
void main()
{
    Student stu1(&quot;liming&quot;， 90); // 定义类Student的对象stu1，
    Student stu2=stu1; // 调用自定义的拷贝构造函数
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;Constructing…liming
Copy constructing…liming
Destructing…liming
Destructing…liming&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;深拷贝示意图&quot;&gt;深拷贝示意图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/12/AitgFP.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;析构函数&quot;&gt;6. 析构函数&lt;/h2&gt;
&lt;p&gt;析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作,通常用于&lt;strong&gt;撤消对象时的一些清理任务&lt;/strong&gt;,如释放分配给对象的内存空间等。&lt;/p&gt;
&lt;h4 id=&quot;析构函数有以下一些特点&quot;&gt;析构函数有以下一些特点:&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;① 析构函数与构造函数&lt;strong&gt;名字&lt;/strong&gt;相同,但它前面必须加一个&lt;strong&gt;波浪号(~)&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;② 析构函数&lt;strong&gt;没有参数,也没有返回值&lt;/strong&gt;,而且&lt;strong&gt;不能重载&lt;/strong&gt;。因此在一个类中只能有&lt;strong&gt;一个&lt;/strong&gt;析构函数;&lt;/li&gt;
&lt;li&gt;③ 当撤消对象时,编译系统会自动地调用析构函数。 如果程序员没有定义析构函数，系统将自动生成和调用一个默认析构函数，默认析构函数只能释放对象的数据成员所占用的空间，但不包括堆内存空间。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;例2.25-重新说明类date&quot;&gt;例2.25 重新说明类Date&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream.h&amp;gt;
class Date{
public:
    Date(int y,int m,int d); // 构造函数
    ~Date(); // 析构函数
    void setDate(int y,int m,int d);
    void showDate();
private:
    int year, month, day;
};
Date::Date(int y,int m,int d) // 构造函数的实现
{
    cout&amp;lt;&amp;lt;&quot;constructing...&quot;&amp;lt;&amp;lt;endl;
    year=y;month=m; day=d;
}
Date::~Date() // 析构函数的实现
{ cout&amp;lt;&amp;lt;&quot;destruting...&quot;&amp;lt;&amp;lt;endl; }
void Date::setDate(int y,int m,int d)
{ year=y;month=m;day=d; }
inline void Date::showDate()
{ cout&amp;lt;&amp;lt;year&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;month&amp;lt;&amp;lt;&quot;.&quot;&amp;lt;&amp;lt;day&amp;lt;&amp;lt;endl; }
void main()
{
    Date date1(1998,4,28); // 定义类Date的对象date1,
    // 调用date1的构造函数,初始化对象date1
    cout&amp;lt;&amp;lt;&quot;Date1 output1:&quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate(),显示date1的数据
    date1.setDate(2002,11,14); // 调用date1的setDate(),
    // 重新设置date1的数据
    cout&amp;lt;&amp;lt;&quot;Date1 output2:&quot;&amp;lt;&amp;lt;endl;
    date1.showDate(); // 调用date1的showDate(),显示date1的数据
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;析构函数被调用的两种情况&quot;&gt;析构函数被调用的两种情况&lt;/h4&gt;
&lt;p&gt;1) 若一个对象被定义在一个函数体内，当这个函数结束时，析构函数被自动调用。&lt;br/&gt;2) 若一个对象是使用new运算符动态创建，在使用delete释放时，自动调用析构函数。&lt;/p&gt;
&lt;h5 id=&quot;例2.13-较完整的学生类例子&quot;&gt;【例2.13】 较完整的学生类例子&lt;/h5&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include&amp;lt;iostream.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
class Student {
public:
    Student(char *name1,char *stu_no1,float score1); // 构造
    函数
    ~Student(); // 析构函数
    void modify(float score1); // 修改数据
    void show(); // 显示数据
private:
    char *name; // 学生姓名
    char *stu_no; // 学生学号
    float score; // 学生成绩
};
Student∷Student(char *name1,char *stu_no1,float score1)
{
    name=new char[strlen(name1)+1];
    strcpy(name,name1);
    stu_no=new char[strlen(stu_no1)+1];
    strcpy(stu_no,stu_no1);
    score=score1;
}
Student∷~Student()
{
    delete []name;
    delete []stu_no;
}
void Student∷modify(float score1)
{ score=score1; }
void Student∷show()
{
    cout&amp;lt;&amp;lt;&quot;\n name: &quot;&amp;lt;&amp;lt;name;
    cout&amp;lt;&amp;lt;&quot;\n stu_no: &quot;&amp;lt;&amp;lt;stu_no;
    cout&amp;lt;&amp;lt;&quot;\n score: &quot;&amp;lt;&amp;lt;score;
}
void main()
{
    Student stu1(&quot;Liming&quot;,&quot;990201&quot;,90); // 定义类Student的对象stu1,
    // 调用stu1的构造函数,初始化对象stu1
    stu1.show(); // 调用stu1的show(),显示stu1的数据
    stu1.modify(88); // 调用stu1的modify(),修改stu1的数据
    stu1.show(); // 调用stu1的show(),显示stu1修改后的数据
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;name:Liming
stu_no:990201
score:90
name:Liming
stu_no:990201
score:88&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;缺省的析构函数&quot;&gt;缺省的析构函数&lt;/h4&gt;
&lt;p&gt;每个类必须有一个析构函数。&lt;/p&gt;
&lt;p&gt;若没有显式地为一个类定义析构函数，编译系统会自动地生成一个缺省的析构函数&lt;/p&gt;
&lt;p&gt;其格式如下：&lt;strong&gt;类名::析构函数名( ){ }&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class string_data {
public:
    string_data(char *)
    { str=new char[max_len];}
    ~string_data()
    { delete []str;}
    void get_info(char *);
    void sent_info(char *);
private:
    char *str;
    int max_len;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;调用构造函数和析构函数的顺序&quot;&gt;7. 调用构造函数和析构函数的顺序&lt;/h2&gt;
&lt;h4 id=&quot;一般顺序&quot;&gt;1) 一般顺序&lt;/h4&gt;
&lt;p&gt;调用析构函数的次序正好与调用构造函数的次序相反：最先被调用的构造函数，其对应的（同一对象中的）析构函数最后被调用，而最后被调用的构造函数，其对应的析构函数最先被调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s2.ax1x.com/2019/03/12/AiNASO.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;全局对象&quot;&gt;2) 全局对象&lt;/h4&gt;
&lt;p&gt;在全局范围中定义的对象(即在所有函数之外定义的对象)，它的构造函数在所有函数(包括main函数)执行之前调用。在程序的流程离开其作用域时(如main函数结束或调用exit函数)时，调用该全局对象的析构函数。&lt;/p&gt;
&lt;h4 id=&quot;auto局部对象&quot;&gt;3) auto局部对象&lt;/h4&gt;
&lt;p&gt;局部自动对象(例如在函数中定义的对象)，则在建立对象时调用其构造函数。如果函数被多次调用，则在每次建立对象时都要调用构造函数。在函数调用结束、对象释放时先调用析构函数。&lt;/p&gt;
&lt;h4 id=&quot;static局部对象&quot;&gt;4) static局部对象&lt;/h4&gt;
&lt;p&gt;如果在函数中定义静态局部对象，则只在程序第一次调用此函数建立对象时调用构造函数一次，在调用结束时对象并不释放，因此也不调用析构函数，只在main函数结束或调用exit函数结束程序时，才调用析构函数。&lt;/p&gt;
&lt;h2 id=&quot;对象的生存期&quot;&gt;8. 对象的生存期&lt;/h2&gt;
&lt;h4 id=&quot;对象按生存期的不同分为如下几种&quot;&gt;对象按生存期的不同分为如下几种：&lt;/h4&gt;
&lt;h5 id=&quot;局部对象&quot;&gt;(1) 局部对象&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;当对象被定义时，调用构造函数，该对象被创建；当程序退出该对象所在的函数体或程序块时，调用析构函数，对象被释放。&lt;/li&gt;
&lt;li&gt;局部对象是被&lt;strong&gt;定义在一个函数体或程序块内&lt;/strong&gt;的，它的作用域限定在函数体或程序块内，生存期较短。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;全局对象-1&quot;&gt;(2) 全局对象&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;当程序开始运行时，调用构造函数，该对象被创建；当程序结束时，调用析构函数，该对象被释放。&lt;/li&gt;
&lt;li&gt;静态对象是被&lt;strong&gt;定义在一个文件中&lt;/strong&gt;，它的作用域从定义是起到文件结束时为止。生存期较长。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;静态对象&quot;&gt;(3) 静态对象&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;当程序中定义静态对象时，调用构造函数，该对象被创建；当整个程序结束时，调用析构函数，对象被释放。&lt;/li&gt;
&lt;li&gt;全局对象是被&lt;strong&gt;定义在某个文件中&lt;/strong&gt;，它的作用域包含在该文件的整个程序中，生存期是最长的。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;动态对象&quot;&gt;(4) 动态对象&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;执行new运算符调用构造函数，动态对象被创建；用delete释放对象时，调用析构函数。&lt;/li&gt;
&lt;li&gt;动态对象是&lt;strong&gt;由程序员掌握&lt;/strong&gt;的，它的作用域和生存期是由new和delete之间的间隔决定的。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;类的应用举例例&quot;&gt;类的应用举例(例)&lt;/h5&gt;
&lt;p&gt;一圆形游泳池如图所示，现在需在其周围建一圆形过道，并在其四周围上栅栏。栅栏价格为35元/米，过道造价为20元/平方米。过道宽度为3米，游泳池半径由键盘输入。要求编程计算并输出过道和栅栏的造价。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
const float PI = 3.14159;
const float FencePrice = 35;
const float ConcretePrice = 20;
//声明类Circle 及其数据和方法
class Circle{
private:
    float radius;
public:
    Circle(float r); //构造函数
    float Circumference() const; //圆周长
    /*函数后的修饰符const表示该成员函数的执行不会改变类的状态，也就是说不会修改类的数据成员。 */
    float Area() const; //圆面积
};// 类的实现
// 构造函数初始化数据成员radius
Circle::Circle(float r)
{
    radius=r;
}
// 计算圆的周长
float Circle::Circumference() const
{
    return 2 * PI * radius;
}
// 计算圆的面积
float Circle::Area() const
{
    return PI * radius * radius;
}
void main ()
{
    float radius;
    float FenceCost, ConcreteCost;
    
    // 提示用户输入半径
    cout&amp;lt;&amp;lt;&quot;Enter the radius of the pool: &quot;;
    cin&amp;gt;&amp;gt;radius;
    
    // 声明 Circle 对象
    Circle Pool(radius);
    Circle PoolRim(radius + 3);
    
    //计算栅栏造价并输出
    FenceCost=PoolRim.Circumference()*FencePrice;
    cout&amp;lt;&amp;lt;&quot;Fencing Cost is ￥&quot;&amp;lt;&amp;lt;FenceCost&amp;lt;&amp;lt;endl;
    
    //计算过道造价并输出
    ConcreteCost=(PoolRim.Area()-
    Pool.Area())*ConcretePrice;
    cout&amp;lt;&amp;lt;&quot;Concrete Cost is ￥&quot;&amp;lt;&amp;lt;ConcreteCost&amp;lt;&amp;lt;endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Enter the radius of the pool: 10
Fencing Cost is ￥2858.85
Concrete Cost is ￥4335.39&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 12 Mar 2019 15:08:00 +0000</pubDate>
<dc:creator>鲸90830</dc:creator>
<og:description>构造函数与析构函数 OOP第二课 1 构造函数 1.1 构造函数具有一些特殊的性质 1.2 定义构造函数的一般形式 1.3 利用构造函数创建对象 2 成员初始化表 3 缺省参数的构造函数 4 重载构造</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/whale90830/p/10520316.html</dc:identifier>
</item>
</channel>
</rss>