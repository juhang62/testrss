<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Django之使用redis缓存session，历史浏览记录，首页数据实现性能优化 - YifChan</title>
<link>http://www.cnblogs.com/yifchan/p/python-1-38.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yifchan/p/python-1-38.html</guid>
<description>&lt;h2&gt;Redis缓存session&lt;/h2&gt;
&lt;p&gt;配置Django缓存数据到redis中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; diango的缓存配置&lt;/span&gt;
CACHES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BACKEND&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;django_redis.cache.RedisCache&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户的session信息，历史浏览记录存储在redis数据库9中&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LOCATION&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis://127.0.0.1:6379/9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OPTIONS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CLIENT_CLASS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;django_redis.client.DefaultClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置session信息缓存在redis中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# 配置session存储在前面配置的redis数据库中
SESSION_ENGINE = &quot;django.contrib.sessions.backends.cache&quot;&lt;span&gt;
SESSION_CACHE_ALIAS = &quot;default&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 保存用户cookie，session信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 与数据库的数据进行校验用户密码正确性&lt;/span&gt;
user = authenticate(request, username=username, password=&lt;span&gt;password)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 业务处理：用户登录&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 返回应答&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; user &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户名密码正确&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; user.is_active:
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户已激活&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录用户的登录状态&lt;/span&gt;
&lt;span&gt;        login(request, user)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取接下来要访问的地址，默认访问主页&lt;/span&gt;
        next_url = request.GET.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;next&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, reverse(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;goods:index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
        response &lt;/span&gt;=&lt;span&gt; redirect(next_url)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 判断是否记住用户名&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; remember == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
            response.set_cookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, username, max_age=7*24*3600&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            response.delete_cookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; response
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Redis缓存历史浏览记录 &lt;/h2&gt;
&lt;h3&gt;链接Redis数据库&lt;/h3&gt;
&lt;p&gt;链接redis数据库有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.使用redis默认的StrictRedis链接&lt;/li&gt;
&lt;li&gt;2.使用redis提供的get_redis_connection方法链接default配置；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方式一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用redis默认的方式与django链接&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; from redis import StrictRedis&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; sr = StrictRedis(host=&quot;localhost&quot;, port=6379, db=9)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django_redis &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_redis_connection
con &lt;/span&gt;= get_redis_connection(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的default指的是settings配置中CACHE的default配置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;缓存历史浏览记录&lt;/h3&gt;
&lt;p&gt;首先确定我们的需求，是一个用户保存一个浏览商品id集合，然后确定是以redis的hash格式存储，存储类似于&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
history_userid:[goods1, goods2, goods3]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们要考虑情况，比如我们原来浏览过一条商品，现在再浏览一遍，那么就要把这个商品的位置提到最前面去，怎么处理？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在这里我们选择的是如果存在该商品，就先删除，再往最左边插入这条数据，可以使用redis提供的 lrem 方法。&lt;/li&gt;
&lt;li&gt;将最新浏览的记录放在最前面，当我们获取缓存中的浏览商品id集合数据，应该是根据id集合的顺序来确定商品顺序的，这里我们可以规定最新的浏览记录放在集合的最左边，使用的是redis的lpush方法。&lt;/li&gt;
&lt;li&gt;还有只保存固定条数的浏览记录，过期的就不保存，使用redis的ltrim方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同时下面也例举了如何获取历史浏览记录id集合。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django_redis &lt;span&gt;import&lt;/span&gt;&lt;span&gt; get_redis_connection

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; user.is_authenticated():
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户已登录&lt;/span&gt;
    conn = get_redis_connection(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    cart_key &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cart_%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; user.id
    cart_count &lt;/span&gt;=&lt;span&gt; conn.hlen(cart_key)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加历史浏览记录&lt;/span&gt;
    conn = get_redis_connection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    history_key &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;history_%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; user.id
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 移除相同的记录&lt;/span&gt;
&lt;span&gt;    conn.lrem(history_key, 0, goods_id)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从左侧添加历史浏览记录&lt;/span&gt;
&lt;span&gt;    conn.lpush(history_key, goods_id)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 只保留最新的五个历史浏览记录&lt;/span&gt;
    conn.ltrim(history_key, 0, 4&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取历史浏览记录的商品id表&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; sku_ids = conn.lrange(history_key, 0, 4)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;goods.view，历史浏览记录商品id表&quot;, sku_ids)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;获取历史浏览记录&lt;/h3&gt;
&lt;p&gt;获取用户历史浏览商品id可以使用redis的lrange加上始终索引来获取指定数量数据，&lt;br/&gt;获取历史浏览商品id后，因为需要根据redis中的顺序来确定商品显示顺序，可以用两种方式来获取商品具体信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.循环从redis获取的商品id列表，根据id获取对应的商品；&lt;/li&gt;
&lt;li&gt;2.根据商品id列表获取商品列表，循环从redis获取的商品id列表，在循环中再次循环商品列表，判断如果商品id等于循环的商品列表的id，就添加入商品表中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;方式一：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从数据库查询用户浏览商品的具体信息&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; goods_li = GoodsSKU.objects.filter(id__in=sku_ids)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; goods_res = []&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; for a_id in sku_ids:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     for goods in goods_li:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         if a_id == goods.id:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;             goods_res.append(goods)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方式二：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历获取用户浏览的商品信息&lt;/span&gt;
goods_li =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; id &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sku_ids:
    goods &lt;/span&gt;= GoodsSKU.objects.filter(id=&lt;span&gt;id)
    goods_li.append(goods)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;获取用户历史浏览记录代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; UserInfoView(LoginRequiredMixin, View):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;用户中心-信息页&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, request):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;返回用户中心信息页面&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        user &lt;/span&gt;=&lt;span&gt; request.user
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取用户的历史浏览记录&lt;/span&gt;
        con = get_redis_connection(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的default指的是settings配置中CACHE的default配置&lt;/span&gt;
        history_key = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;history_%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; user.id
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取用户最新浏览的5个历史记录&lt;/span&gt;
        sku_ids = con.lrange(history_key, 0, 4&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从数据库查询用户浏览商品的具体信息&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; goods_li = GoodsSKU.objects.filter(id__in=sku_ids)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; goods_res = []&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for a_id in sku_ids:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     for goods in goods_li:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;         if a_id == goods.id:&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;             goods_res.append(goods)&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 遍历获取用户浏览的商品信息&lt;/span&gt;
        goods_li =&lt;span&gt; []
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; sku_id &lt;span&gt;in&lt;/span&gt;&lt;span&gt; sku_ids:
            goods &lt;/span&gt;= GoodsSKU.objects.get(id=&lt;span&gt;sku_id)
            goods.image &lt;/span&gt;= settings.MEDIA_PATH +&lt;span&gt; str(goods.image)
            goods_li.append(goods)
        context &lt;/span&gt;=&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;page&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;address&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: address,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;goods_li&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: goods_li
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;user_center_info.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, context)
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Redis缓存网站首页数据&lt;/h2&gt;
&lt;p&gt;Django缓存相关文档：&lt;a href=&quot;https://yiyibooks.cn/xx/django_182/topics/cache.html&quot; target=&quot;_blank&quot;&gt;https://yiyibooks.cn/xx/django_182/topics/cache.html&lt;/a&gt;&lt;br/&gt;缓存文档中，提供有三种缓存方式，站点级缓存，单个view缓存，模板片段缓存，但都不适合我们，这里我们是直接操作底层缓存api。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首页数据的缓存&lt;/strong&gt;：把页面使用的数据存放在缓存中，当要使用这些数据时，就先从缓存中获取，如果获取不到，就再去数据库中获取，减少数据库的查询次数。&lt;/p&gt;

&lt;p&gt;缓存首页数据，使用的还是redis进行缓存，如果你没看前面是独立做这一步的话，要进行如下配置，前面已经配置过的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; diango的缓存配置&lt;/span&gt;
CACHES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BACKEND&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;django_redis.cache.RedisCache&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户的session信息，历史浏览记录存储在redis数据库9中&lt;/span&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LOCATION&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis://127.0.0.1:6379/9&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OPTIONS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CLIENT_CLASS&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;django_redis.client.DefaultClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;缓存首页数据&lt;/h3&gt;
&lt;p&gt;缓存数据，我们在这里用的是django自带的cache函数，它会帮我们将数据缓存到一定的地方，我们这里配置的是将数据缓存到redis中，即cache函数会帮我们将数据缓存到redis中。&lt;/p&gt;
&lt;p&gt;cache函数需要三个参数，第一个是缓存的key，即你要给缓存的数据起一个名字，我们可以理解为python中的字典，第二个参数是要缓存的数据，第三个参数是缓存数据过期时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用cache函数缓存首页数据代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexView(View):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get(self, request):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从缓存中获取数据&lt;/span&gt;
        context = cache.get(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index_page_data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果缓存中没有数据，就去数据库中获取数据&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; context &lt;span&gt;is&lt;/span&gt;&lt;span&gt; None:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;缓存数据ing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取商品的种类信息&lt;/span&gt;
            types =&lt;span&gt; GoodsType.objects.all()
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取首页轮播商品信息&lt;/span&gt;
            goods_banners = IndexGoodsBanner.objects.all().order_by(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取首页促销活动信息&lt;/span&gt;
            promotions_banners = IndexPromotionBanner.objects.all().order_by(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取首页分类商品展示信息&lt;/span&gt;
            &lt;span&gt;for&lt;/span&gt; type &lt;span&gt;in&lt;/span&gt;&lt;span&gt; types:
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取type分类首页分类商品的图片展示对象信息&lt;/span&gt;
                image_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=1&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取type分类首页分类商品的文字展示对象信息&lt;/span&gt;
                title_banners = IndexTypeGoodsBanner.objects.filter(type=type, display_type=&lt;span&gt;0)
                &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 动态给type增加属性，分别保存首页分类商品的图片展示信息和文字展示信息&lt;/span&gt;
                type.image_banners =&lt;span&gt; image_banners
                type.title_banners &lt;/span&gt;=&lt;span&gt; title_banners
            context &lt;/span&gt;=&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;types&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: types,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;goods_banners&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: goods_banners,
                &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;promotions_banners&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: promotions_banners,
            }
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置缓存&lt;/span&gt;
            cache.set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index_page_data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, context, 3600&lt;span&gt;)

        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取用户购物车中商品的数目&lt;/span&gt;
        user =&lt;span&gt; request.user
        cart_count &lt;/span&gt;=&lt;span&gt; 0
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; user.is_authenticated:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用户已登录&lt;/span&gt;
            conn = get_redis_connection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            cart_key &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cart_%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; user.id
            cart_count &lt;/span&gt;=&lt;span&gt; conn.hlen(cart_key)
        context.update(cart_count&lt;/span&gt;=&lt;span&gt;cart_count)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回应答&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; render(request, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, context)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时在这里提醒一下，如果你对Redis不够熟悉的话，不用去拘泥于使用redis的哪种格式缓存首页数据，我们只需要知道redis是一种内存数据库即可，django配置了将缓存放入redis即内容中，在这里django的cache已经帮我们做好了怎么缓存，我们只需要调用即可。&lt;/p&gt;

&lt;h3&gt;首页缓存数据的更新&lt;/h3&gt;
&lt;p&gt;当管理员在后台修改首页信息对应的数据表中的数据时，我们就需要更新首页的缓存数据了。&lt;/p&gt;
&lt;p&gt;在这里我们实现的方式是直接清空缓存中的首页数据，这样当下一个用户去访问首页时，因为没有从缓存中查到数据，就会从数据库获取数据并且重新存储到缓存中了，清除缓存使用cache.delete()方法。&lt;/p&gt;
&lt;p&gt;下面直接贴代码，置于实现原理，可以参考  &lt;a href=&quot;https://www.cnblogs.com/yifchan/p/python-1-37.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yifchan/p/python-1-37.html&lt;/a&gt; 最后一节&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('d5c58bc2-ee27-4f62-a1e9-4955c16a7ed4')&quot; readability=&quot;42.5&quot;&gt;&lt;img id=&quot;code_img_closed_d5c58bc2-ee27-4f62-a1e9-4955c16a7ed4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d5c58bc2-ee27-4f62-a1e9-4955c16a7ed4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('d5c58bc2-ee27-4f62-a1e9-4955c16a7ed4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d5c58bc2-ee27-4f62-a1e9-4955c16a7ed4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;80&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; django.contrib &lt;span&gt;import&lt;/span&gt;&lt;span&gt; admin
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; django.core.cache &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cache
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; goods.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; GoodsType, GoodsSKU, Goods, GoodsImage, IndexGoodsBanner, IndexTypeGoodsBanner, IndexPromotionBanner


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseModelAdmin(admin.ModelAdmin):
    &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;当后台数据库数据改动时清空缓存使重新缓存首页数据&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; save_model(self, request, obj, form, change):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;当更新或者新增数据时调用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        super().save_model(request, obj, form, change)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 清除首页的缓存数据&lt;/span&gt;
        cache.delete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index_page_data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; delete_model(self, request, obj):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;当删除数据时调用&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        super().delete_model(request, obj)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 清除首页的缓存数据&lt;/span&gt;
        cache.delete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;index_page_data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; GoodsTypeAdmin(BaseModelAdmin):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexGoodsBannerAdmin(BaseModelAdmin):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexTypeGoodsBannerAdmin(BaseModelAdmin):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; IndexPromotionBannerAdmin(BaseModelAdmin):
    &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;&lt;span&gt;


admin.site.register(GoodsType, GoodsTypeAdmin)
admin.site.register(GoodsSKU)
admin.site.register(Goods)
admin.site.register(GoodsImage)
admin.site.register(IndexGoodsBanner, IndexGoodsBannerAdmin)
admin.site.register(IndexTypeGoodsBanner, IndexTypeGoodsBannerAdmin)
admin.site.register(IndexPromotionBanner, IndexPromotionBannerAdmin)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;app-goods/admin.py&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 08 Oct 2019 00:49:00 +0000</pubDate>
<dc:creator>YifChan</dc:creator>
<og:description>Django之使用redis缓存session，历史浏览记录，首页数据实现性能优化，内容包括 redis缓存session；redis缓存历史浏览记录，链接redis数据库，缓存历史浏览记录，获取历史</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yifchan/p/python-1-38.html</dc:identifier>
</item>
<item>
<title>设计模式 - 单例模式（详解）看看和你理解的是否一样？ - EamonZzz</title>
<link>http://www.cnblogs.com/eamonzzz/p/11633482.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eamonzzz/p/11633482.html</guid>
<description>&lt;p&gt;单例模式是设计模式中相对简单且非常常见的一种设计模式，但是同时也是非常经典的&lt;strong&gt;高频&lt;/strong&gt;面试题，相信还是有很多人在面试时会挂在这里。本篇文章主要针对单例模式做一个回顾，记录单例模式的应用场景、常见写法、针对线程安全进行调试（看得见的线程）以及总结。相信大家看完这篇文章之后，对单例模式有一个非常深刻的认识。&lt;/p&gt;
&lt;p&gt;文章中按照常见的单例模式的写法，由浅入深进行讲解记录；以及指出该写法的不足，从而进行演进改造。&lt;/p&gt;
&lt;p&gt;秉承废话少说的原则，我们下面快速开始&lt;/p&gt;

&lt;p&gt;单例模式(Singleton Pattern)是指确保一个类在任何情况下都绝对只有一个实例，并提供一个全局访问点。&lt;/p&gt;
&lt;p&gt;单例模式是创建型模式。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;生活中的单例：例如，国家主席、公司 CEO、部门经理等。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Java&lt;/code&gt;世界中：&lt;code&gt;ServletContext&lt;/code&gt;、 &lt;code&gt;ServletContextConfig&lt;/code&gt; 等;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;Spring&lt;/code&gt; 框架应用中：&lt;code&gt;ApplicationContext&lt;/code&gt;、数据库的连接池也都是单例形式。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;单例模式主要有：饿汉式单例、懒汉式单例（线程不安全型、线程安全型、双重检查锁类型、静态内部类类型）、注册式（登记式）单例（枚举式单例、容器式单例）、&lt;code&gt;ThreadLocal&lt;/code&gt;线程单例&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面我们来看看各种模式的写法。&lt;/p&gt;
&lt;h2 id=&quot;饿汉式单例&quot;&gt;1、饿汉式单例&lt;/h2&gt;
&lt;p&gt;饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线程还没出现以前就是实例化了，不可能存在访问安全问题。&lt;/p&gt;
&lt;p&gt;Spring 中 IOC 容器 ApplicationContext 就是典型的饿汉式单例&lt;/p&gt;
&lt;h3 id=&quot;优缺点&quot;&gt;优缺点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：类加载的时候就初始化，不管用与不用都占着空间，浪费了内存，有可能占着茅坑不拉屎。&lt;/p&gt;
&lt;h3 id=&quot;写法&quot;&gt;写法&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 上午9:26
 */
public class HungrySingleton {
    // 1.私有化构造器
    private HungrySingleton (){}
    // 2.在类的内部创建自行实例
    private static final HungrySingleton instance = new HungrySingleton();
    // 3.提供获取唯一实例的方法（全局访问点）
    public static HungrySingleton getInstance(){
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有另外一种写法，利用静态代码块的机制：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 上午10:46
 */
public class HungryStaticSingleton {
    // 1. 私有化构造器
    private HungryStaticSingleton(){}

    // 2. 实例变量
    private static final HungryStaticSingleton instance;

    // 3. 在静态代码块中实例化
    static {
        instance = new HungryStaticSingleton();
    }

    // 4. 提供获取实例方法
    public static HungryStaticSingleton getInstance(){
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码,我们创建 10 个线程（具体线程发令枪 ConcurrentExecutor 在文末源码中获取）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 上午11:17
 */
public class HungrySingletonTest {
    @Test
    public void test() {
        try {
            ConcurrentExecutor.execute(() -&amp;gt; {
                HungrySingleton instance = HungrySingleton.getInstance();
                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + instance);
            }, 10, 10);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pool-1-thread-6 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
pool-1-thread-9 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
pool-1-thread-10 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
pool-1-thread-2 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
pool-1-thread-7 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
pool-1-thread-5 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
pool-1-thread-3 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
pool-1-thread-4 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
pool-1-thread-8 : com.eamon.javadesignpatterns.singleton.hungry.HungrySingleton@5e37cce6
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，饿汉式每次获取实例都是同一个。&lt;/p&gt;
&lt;h3 id=&quot;使用场景&quot;&gt;使用场景&lt;/h3&gt;
&lt;p&gt;这两种写法都非常的简单，也非常好理解，饿汉式适用在单例对象较少的情况。&lt;/p&gt;
&lt;p&gt;下面我们来看性能更优的写法——懒汉式单例。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;懒汉式单例&quot;&gt;2、懒汉式单例&lt;/h2&gt;
&lt;p&gt;懒汉式单例的特点是:被外部类调用的时候内部类才会加载。&lt;/p&gt;
&lt;p&gt;懒汉式单例可以分为下面这几种写法来。&lt;/p&gt;
&lt;h3 id=&quot;简单懒汉式线程不安全&quot;&gt;简单懒汉式（线程不安全）&lt;/h3&gt;
&lt;p&gt;这是懒汉式单例的简单写法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 上午10:55
 */
public class LazySimpleSingleton {
    private LazySimpleSingleton(){}
    private static LazySimpleSingleton instance = null;

    public static LazySimpleSingleton getInstance(){
        if (instance == null) {
            instance = new LazySimpleSingleton();
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们创建一个多线程来测试一下，是否线程安全：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 上午11:12
 */
public class LazySimpleSingletonTest {

    @Test
    public void test() {
        try {
            ConcurrentExecutor.execute(() -&amp;gt; {
                LazySimpleSingleton instance = LazySimpleSingleton.getInstance();
                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + instance);
            }, 5, 5);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;pool-1-thread-3 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@abe194f
pool-1-thread-5 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@abe194f
pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@748e48d0
pool-1-thread-2 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@abe194f
pool-1-thread-4 : com.eamon.javadesignpatterns.singleton.lazy.LazySimpleSingleton@abe194f&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从测试结果来看，一定几率出现创建两个不同结果的情况，意味着上面的单例存在线程安全隐患。&lt;/p&gt;
&lt;p&gt;至于为什么？由于篇幅问题，我们在后面一篇文章中利用测试工具进行详细的分析（这可能也是面试中面试官会问到的问题）。大家现在只需要知道简单的懒汉式会存在这么一个问题就行了。&lt;/p&gt;
&lt;h3 id=&quot;简单懒汉式线程安全&quot;&gt;简单懒汉式（线程安全）&lt;/h3&gt;
&lt;p&gt;通过对上面简单懒汉式单例的测试，我们知道存在线程安全隐患，那么，如何来避免或者解决呢？&lt;/p&gt;
&lt;p&gt;我们都知道 java 中有一个&lt;code&gt;synchronized&lt;/code&gt;可以来对共享资源进行加锁，保证在同一时刻只能有一个线程拿到该资源，其他线程只能等待。所以，我们对上面的简单懒汉式进行改造，给&lt;code&gt;getInstance()&lt;/code&gt; 方法加上&lt;code&gt;synchronized&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 上午10:55
 */
public class LazySimpleSyncSingleton {
    private LazySimpleSyncSingleton() {
    }

    private static LazySimpleSyncSingleton instance = null;

    public synchronized static LazySimpleSyncSingleton getInstance() {
        if (instance == null) {
            instance = new LazySimpleSyncSingleton();
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用发令枪进行测试：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void testSync(){
    try {
        ConcurrentExecutor.execute(() -&amp;gt; {
            LazySimpleSyncSingleton instance = LazySimpleSyncSingleton.getInstance();
            System.out.println(Thread.currentThread().getName() + &quot; : &quot; + instance);
        }, 5, 5);
    } catch (Exception e) {
        e.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进行多轮测试，并观察结果，发现能够获取同一个示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;pool-1-thread-3 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de
pool-1-thread-2 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de
pool-1-thread-5 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de
pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de
pool-1-thread-4 : com.eamon.javadesignpatterns.singleton.lazy.simple.LazySimpleSyncSingleton@1a7e99de&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程安全问题是解决了，但是，用&lt;code&gt;synchronized&lt;/code&gt;加锁，在线程数量比较多情况下，如果&lt;code&gt;CPU&lt;/code&gt;分配压力上升，会导致大批量线程出现阻塞，从而导致程序运行性能大幅下降。&lt;/p&gt;
&lt;p&gt;那么，有没有一种更好的方式，既兼顾线程安全又提升程序性能呢？答案是肯定的。&lt;/p&gt;
&lt;p&gt;我们来看双重检查锁的单例模式。&lt;/p&gt;
&lt;h3 id=&quot;双重检查锁懒汉式&quot;&gt;双重检查锁懒汉式&lt;/h3&gt;
&lt;p&gt;上面的线程安全方式的写法，&lt;code&gt;synchronized&lt;/code&gt;锁是锁在 &lt;code&gt;getInstance()&lt;/code&gt; 方法上，当多个线程过来拿资源的时候，其实需要拿的不是&lt;code&gt;getInstance()&lt;/code&gt;这个方法，而是&lt;code&gt;getInstance()&lt;/code&gt;方法里面的&lt;code&gt;instance&lt;/code&gt; 实例对象，而如果这个实例对象一旦被初始化之后，多个线程到达时，就可以利用方法中的 &lt;code&gt;if (instance == null)&lt;/code&gt; 去判断是否实例化，如果已经实例化了就直接返回，就没有必要再进行实例化一遍。所以对上面的代码进行改造：&lt;/p&gt;
&lt;p&gt;第一次改造：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 下午2:03
 */
public class LazyDoubleCheckSingleton {
    private LazyDoubleCheckSingleton() {
    }

    private static LazyDoubleCheckSingleton instance = null;

    public static LazyDoubleCheckSingleton getInstance() {
        // 这里判断是为了过滤不必要的同步加锁，因为如果已经实例化了，就可以直接返回了
        if (instance == null) {
            // 如果未初始化，则对资源进行上锁保护，待实例化完成之后进行释放
            synchronized (LazyDoubleCheckSingleton.class) {
                instance = new LazyDoubleCheckSingleton();
            }
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法行不行？答案肯定是不行，代码中虽然是将同步锁添加到了实例化操作中，解决了每个线程由于同步锁的原因引起的阻塞，提高了性能；但是，这里会存在一个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;线程X&lt;/code&gt;和&lt;code&gt;线程Y&lt;/code&gt;同时调用&lt;code&gt;getInstance()&lt;/code&gt;方法，他们同时判断&lt;code&gt;instance == null&lt;/code&gt;，得出的结果都是为&lt;code&gt;null&lt;/code&gt;，所以进入了&lt;code&gt;if&lt;/code&gt;代码块了&lt;/li&gt;
&lt;li&gt;此时&lt;code&gt;线程X&lt;/code&gt;得到&lt;code&gt;CPU&lt;/code&gt;的控制权 -&amp;gt; 进入同步代码块 -&amp;gt; 创建对象 -&amp;gt; 返回对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;线程X&lt;/code&gt;执行完成了以后，释放了锁，然后&lt;code&gt;线程Y&lt;/code&gt;得到了&lt;code&gt;CPU&lt;/code&gt;的控制权。同样是 -&amp;gt; 进入同步代码块 -&amp;gt; 创建对象 -&amp;gt; 返回对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以我们明显可以分析出来：&lt;code&gt;LazyDoubleCheckSingleton&lt;/code&gt; 类返回了不止一个实例！所以上面的代码是不行的！大家可以自行测试，我这里就不进行测试了！&lt;/p&gt;
&lt;p&gt;我们再进行改造，经过分析，由于&lt;code&gt;线程X&lt;/code&gt;已经实例化了对象，在&lt;code&gt;线程Y&lt;/code&gt;再次进入的时候，我们再加一层判断不就可以解决 &lt;strong&gt;“这个”&lt;/strong&gt; 问题吗？确实如此，来看代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 下午2:03
 */
public class LazyDoubleCheckSingleton {
    private LazyDoubleCheckSingleton() {
    }
    private static LazyDoubleCheckSingleton instance = null;
    public static LazyDoubleCheckSingleton getInstance() {
        // 这里判断是为了过滤不必要的同步加锁，因为如果已经实例化了，就可以直接返回了
        if (instance == null) {
            // 如果未初始化，则对资源进行上锁保护，待实例化完成之后进行释放（注意，可能多个线程会同时进入）
            synchronized (LazyDoubleCheckSingleton.class) {
                // 这里的if作用是：如果后面的进程在前面一个线程实例化完成之后拿到锁，进入这个代码块，
                // 显然，资源已经被实例化过了，所以需要进行判断过滤
                if (instance == null) {
                    instance = new LazyDoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大家觉得经过这样改造是不是就完美了呢？在我们习惯性的“讲道理”的思维模式看来，好像确实没什么问题，但是，程序是计算机在执行；什么意思呢？&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;instance = new LazyDoubleCheckSingleton();&lt;/code&gt; 这段代码执行的时候，计算机内部并非简单的一步操作，也就是非原子操作，在&lt;code&gt;JVM&lt;/code&gt;中，这一行代码大概做了这么几件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;给 &lt;code&gt;instance&lt;/code&gt; 分配内存&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;LazyDoubleCheckSingleton&lt;/code&gt; 的构造函数来初始化成员变量&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;instance&lt;/code&gt;对象指向分配的内存空间（执行完这步 &lt;code&gt;instance&lt;/code&gt; 就为非 null 了）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是在 &lt;code&gt;JVM&lt;/code&gt; 中的即时编译器中存在指令重排序的优化；通俗的来说就是，上面的第二步和第三步的顺序是不能保证的，如果执行顺序是 &lt;code&gt;1 -&amp;gt; 3 -&amp;gt; 2&lt;/code&gt; 那么在 3 执行完毕、2 未执行之前，被另外一个线程 A 抢占了，这时 &lt;code&gt;instance&lt;/code&gt; 已经是非 null 了（但却没有初始化），所以线程 A 会直接返回 &lt;code&gt;instance&lt;/code&gt;，然后被程序调用，就会报错。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当然，这种情况是很难测试出来的，但是确实会存在这么一个问题，所以我们必须解决它，解决方式也很简单，就是 j 将 &lt;code&gt;instance&lt;/code&gt; 加上 &lt;code&gt;volatile&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以相对较完美的实现方式是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 下午2:03
 */
public class LazyDoubleCheckSingleton {
    private LazyDoubleCheckSingleton() {
    }

    private static volatile LazyDoubleCheckSingleton instance = null;

    public static LazyDoubleCheckSingleton getInstance() {
        // 这里判断是为了过滤不必要的同步加锁，因为如果已经实例化了，就可以直接返回了
        if (instance == null) {
            // 如果未初始化，则对资源进行上锁保护，待实例化完成之后进行释放（注意，可能多个线程会同时进入）
            synchronized (LazyDoubleCheckSingleton.class) {
                // 这里的if作用是：如果后面的进程在前面一个线程实例化完成之后拿到锁，进入这个代码块，
                // 显然，资源已经被实例化过了，所以需要进行判断过滤
                if (instance == null) {
                    instance = new LazyDoubleCheckSingleton();
                }
            }
        }
        return instance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码见文末说明&lt;/p&gt;
&lt;h3 id=&quot;静态内部类懒汉式&quot;&gt;静态内部类懒汉式&lt;/h3&gt;
&lt;p&gt;上面的双重锁检查形式的单例，对于日常开发来说，确实够用了，但是在代码中使用&lt;code&gt;synchronized&lt;/code&gt;关键字 ，总归是要上锁，上锁就会存在一个性能问题。难道就没有更好的方案吗？别说，还真有，我们从类初始化的角度来考虑，这就是这里所要说到的静态内部类的方式。&lt;/p&gt;
&lt;p&gt;废话不多说，直接看代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 *
 * @author eamon.zhang
 * @date 2019-09-30 下午2:55
 */
public class LazyInnerClassSingleton {

    private LazyInnerClassSingleton() {
    }

    // 注意关键字final，保证方法不被重写和重载
    public static final LazyInnerClassSingleton getInstance() {
        return LazyHolder.INSTANCE;
    }

    private static class LazyHolder {
        // 注意 final 关键字（保证不被修改）
        private static final LazyInnerClassSingleton INSTANCE = new LazyInnerClassSingleton();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进行多线程测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pool-1-thread-9 : com.eamon.javadesignpatterns.singleton.lazy.inner.LazyInnerClassSingleton@88b7fa2
pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.lazy.inner.LazyInnerClassSingleton@88b7fa2
pool-1-thread-6 : com.eamon.javadesignpatterns.singleton.lazy.inner.LazyInnerClassSingleton@88b7fa2
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果都是同一个对象实例。&lt;/p&gt;
&lt;h4 id=&quot;结论&quot;&gt;结论&lt;/h4&gt;
&lt;p&gt;这种方式即解决了饿汉式的内存浪费问题，也解决了&lt;code&gt;synchronized&lt;/code&gt; 所带来的性能问题&lt;/p&gt;
&lt;h4 id=&quot;原理&quot;&gt;原理&lt;/h4&gt;
&lt;p&gt;利用的原理就是类的加载初始化顺序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当类不被调用的时候，类的静态内部类是不会进行初始化的，这就避免了内存浪费问题；&lt;/li&gt;
&lt;li&gt;当有方法调用 &lt;code&gt;getInstance()&lt;/code&gt;方法时，会先初始化静态内部类，而静态内部类中的成员变量是 &lt;code&gt;final&lt;/code&gt; 的，所以即便是多线程，其成员变量是不会被修改的，所以就解决了添加 &lt;code&gt;synchronized&lt;/code&gt; 所带来的性能问题&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;首先感谢也恭喜大家能够看到这里，因为我想告诉你，上面所有的单例模式似乎还存在一点小问题 —— 暴力破坏。解决这一问题的方式就是下面提到的枚举类型单例。&lt;/p&gt;
&lt;p&gt;至于缘由和为何枚举能够解决这个问题，同样，篇幅原因，我将在后面单独开一篇文章来说明。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面我们先来讲讲注册式单例。&lt;/p&gt;
&lt;h2 id=&quot;注册式登记式单例&quot;&gt;3、注册式（登记式）单例&lt;/h2&gt;
&lt;p&gt;注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标识获取实例。&lt;/p&gt;
&lt;p&gt;注册式单例有两种写法:一种为容器缓存，一种为枚举登记。&lt;/p&gt;
&lt;p&gt;先来看枚举式单例的写法。&lt;/p&gt;
&lt;h3 id=&quot;枚举单例&quot;&gt;枚举单例&lt;/h3&gt;
&lt;p&gt;废话少说，直接看代码，我们先创建&lt;code&gt;EnumSingleton&lt;/code&gt; 类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 下午3:42
 */
public enum EnumSingleton {
    INSTANCE;

    private Object instance;

    EnumSingleton() {
        instance = new EnumResource();
    }

    public Object getInstance() {
        return instance;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;来看测试代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author eamon.zhang
 * @date 2019-09-30 下午3:47
 */
public class EnumSingletonTest {

    @Test
    public void test() {
        try {
            ConcurrentExecutor.execute(() -&amp;gt; {
                EnumSingleton instance = EnumSingleton.INSTANCE;
                System.out.println(instance.getInstance());
            }, 10, 10);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7
com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7
com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7
com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7
com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7
com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7
com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7
com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7
com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7
com.eamon.javadesignpatterns.singleton.enums.EnumResource@3eadb1e7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果都一样，说明枚举类单例是线程安全的，且是不可破坏的；在 JDK 枚举的语法特殊性，以及反射也为枚举保驾护航，让枚举式单例成为一种比较优雅的实现。&lt;/p&gt;
&lt;p&gt;枚举类单例也是《Effective Java》中所建议使用的。&lt;/p&gt;
&lt;h3 id=&quot;容器式单例&quot;&gt;容器式单例&lt;/h3&gt;
&lt;p&gt;注册式单例还有另外一种写法，利用容器缓存，直接来看代码：&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;ContainerSingleton&lt;/code&gt;类:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author EamonZzz
 * @date 2019-10-06 18:28
 */
public class ContainerSingleton {
    private ContainerSingleton() {
    }

    private static Map&amp;lt;String, Object&amp;gt; ioc = new ConcurrentHashMap&amp;lt;String, Object&amp;gt;();

    public static Object getBean(String className) {
        synchronized (ioc) {
            if (!ioc.containsKey(className)) {
                Object object = null;
                try {
                    object = Class.forName(className).newInstance();
                    ioc.put(className, object);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                return object;
            } else {
                return ioc.get(className);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
    public void test() {
        try {
            ConcurrentExecutor.execute(() -&amp;gt; {
                Object bean = ContainerSingleton
                        .getBean(&quot;com.eamon.javadesignpatterns.singleton.container.Resource&quot;);
                System.out.println(bean);
            }, 5, 5);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f
com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f
com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f
com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f
com.eamon.javadesignpatterns.singleton.container.Resource@42e7420f&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;容器式写法适用于创建实例非常多的情况，便于管理。但是，是非线程安全的。&lt;/p&gt;
&lt;p&gt;其实 Spring 中也有相关容器史丹利的实现代码，比如 &lt;code&gt;AbstractAutowireCapableBeanFactory&lt;/code&gt; 接口&lt;/p&gt;
&lt;p&gt;至此，注册式单例介绍完毕。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;threadlocal-线程单例&quot;&gt;ThreadLocal 线程单例&lt;/h2&gt;
&lt;p&gt;ThreadLocal 不能保证其创建的对象是唯一的，但是能保证在单个线程中是唯一的，并且在单个线程中是天生的线程安全。&lt;/p&gt;
&lt;p&gt;看代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * @author EamonZzz
 * @date 2019-10-06 21:40
 */
public class ThreadLocalSingleton {
    private ThreadLocalSingleton() {
    }

    private static final ThreadLocal&amp;lt;ThreadLocalSingleton&amp;gt; instance = ThreadLocal.withInitial(ThreadLocalSingleton::new);

    public static ThreadLocalSingleton getInstance() {
        return instance.get();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试程序：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Test
public void test() {
    System.out.println(&quot;-------------- 单线程 start ---------&quot;);
    System.out.println(ThreadLocalSingleton.getInstance());
    System.out.println(ThreadLocalSingleton.getInstance());
    System.out.println(ThreadLocalSingleton.getInstance());
    System.out.println(ThreadLocalSingleton.getInstance());
    System.out.println(ThreadLocalSingleton.getInstance());
    System.out.println(&quot;-------------- 单线程 end ---------&quot;);
    System.out.println(&quot;-------------- 多线程 start ---------&quot;);
    try {
        ConcurrentExecutor.execute(() -&amp;gt; {
            ThreadLocalSingleton singleton = ThreadLocalSingleton.getInstance();
            System.out.println(Thread.currentThread().getName() + &quot; : &quot; + singleton);

        }, 5, 5);
    } catch (Exception e) {
        e.printStackTrace();
    }
    System.out.println(&quot;-------------- 多线程 end ---------&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;-------------- 单线程 start ---------
com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda
com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda
com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda
com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda
com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@1374fbda
-------------- 单线程 end ---------
-------------- 多线程 start ---------
pool-1-thread-5 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@2f540d92
pool-1-thread-1 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@3ef7ab4e
pool-1-thread-2 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@604ffe2a
pool-1-thread-3 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@50f41c9f
pool-1-thread-4 : com.eamon.javadesignpatterns.singleton.threadlocal.ThreadLocalSingleton@40821a7a
-------------- 多线程 end ---------&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从测试结果来看，我们不难发现，在主线程中无论调用多少次，获得到的实例都是同一个；在多线程环境下，每个线程获取到了不同的实例。&lt;/p&gt;
&lt;p&gt;所以，在单线程环境中，ThreadLocal 可以达到单例的目的。这实际上是以空间换时间来实现线程间隔离的。&lt;/p&gt;

&lt;p&gt;单例模式可以保证内存里只有一个实例，减少了内存的开销；可避免对资源的浪费。&lt;/p&gt;
&lt;p&gt;单例模式看起来非常简单，实现起来也不难，但是在面试中却是一个高频的面试题。希望大家能够彻底理解。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本篇文章所涉及的源代码：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/eamonzzz/java-advanced/tree/master/01.DesignPatterns/design-patterns/src/main/java/com/eamon/javadesignpatterns/singleton&quot;&gt;github.com/eamonzzz&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Oct 2019 00:48:00 +0000</pubDate>
<dc:creator>EamonZzz</dc:creator>
<og:description>一、概述 单例模式是设计模式中相对简单且非常常见的一种设计模式，但是同时也是非常经典的 高频 面试题，相信还是有很多人在面试时会挂在这里。本篇文章主要针对单例模式做一个回顾，记录单例模式的应用场景、常</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/eamonzzz/p/11633482.html</dc:identifier>
</item>
<item>
<title>除了Web和Node，JavaScript还能做什么 - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/11633475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/11633475.html</guid>
<description>&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;2ien4-0-0&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;416eu-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;416eu-0-0&quot;&gt;提起JavaScript，我们也许经常会想到的是，可以用来写Web页面嘛，又或者，会想起Node.js 这个服务端环境，搞前后端同构。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;52cn2-0-0&quot;&gt;那么，除此之外， JavaScript还可以做什么？&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;75klq-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;75klq-0-0&quot;&gt;JavaScript可以&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;4tmja-0-0&quot; readability=&quot;7&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;4tmja-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4tmja-0-0&quot;&gt;通过electron.js建设跨平台电脑桌面应用&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;1kqbc-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1kqbc-0-0&quot;&gt;通过树莓派和Node.js，沟通硬件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;215di-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;215di-0-0&quot;&gt;做电视机机顶盒应用，例如借助ntv.js&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;9espt-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9espt-0-0&quot;&gt;从Hybird到React-Native，编写跨平台的混合APP，或者原生APP&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;bgcoa-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bgcoa-0-0&quot;&gt;通过Cocos2d-x 框架或白鹭引擎，JS可以开发流行游戏&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;cefqj-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cefqj-0-0&quot;&gt;JS进行三维处理: WebGL和three.js&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;dmrfv-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dmrfv-0-0&quot;&gt;做浏览器插件开发，例如Chrome插件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;4hpgm-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4hpgm-0-0&quot;&gt;做IDE插件开发，例如VScode编辑器的插件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;aa7i2-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aa7i2-0-0&quot;&gt;用JS写一个操作系统？：NodeOS&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;dnvbo-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dnvbo-0-0&quot;&gt;微软开发的Node.js 多线程库 Napa.js，让JS也能拥抱多线程&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;879o3-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;879o3-0-0&quot;&gt;（本文仅仅只是简单介绍，不会介绍具体用法）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;a588d-0-0&quot;&gt;&lt;span data-offset-key=&quot;a588d-0-0&quot;&gt;S1.通过electron.js建设跨平台电脑桌面应用&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;5scea-0-0&quot;&gt;

&lt;/blockquote&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;6kqgr-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6kqgr-0-0&quot;&gt;如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/v2-9a402a874474bff4f184940866516821_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1110&quot; data-rawheight=&quot;494&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-9a402a874474bff4f184940866516821_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-e94d33fb60fb48730b48f4e81c14c78d_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;f9r1c-0-0&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;f9r1c-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f9r1c-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;electron的实现基于Chromium 和 Node.js，并可以调用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;1kfp2-0-0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1kfp2-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;编码完毕后，可以一键生成Mac,windows,Linux三个不同平台的应用程序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;aegs7-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aegs7-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;electron可以直接调用Node.js的API，以及沟通桌面应用程序的内置模块&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;ag6rk-0-0&quot;&gt;&lt;span data-offset-key=&quot;ag6rk-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;S2.可以通过JS调用树莓派接口，控制硬件&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;4130r-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4130r-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这里首先要介绍下树莓派， 树莓派（Raspberry Pi ）是一种只有信用卡大小的微型计算机，别看它小，但它“麻雀虽小，五脏俱全”，计算机有的许多基本功能，树莓派也都有&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/v2-f1ae9d1eb88e4ff655cd97c00902ec46_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;350&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic3.zhimg.com/v2-f1ae9d1eb88e4ff655cd97c00902ec46_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-2f2c09c7350c1169ddc5f44c23dc656d_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;347ll-0-0&quot; readability=&quot;7&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;347ll-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;学习硬件的同学可能对树莓派有一些了解。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;6mq9t-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6mq9t-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;树莓派上有大量的GIPO接口，即输入输出接口，通过GIPO口，用户可以和硬件进行数据交互，或控制硬件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;fsbv1-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fsbv1-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;树莓派允许许多编程语言对GIPO接口进行控制，而JavaScript也是其中之一，也就是说，我们可以通过Node.js环境和树莓派，从而控制硬件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;bp820-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bp820-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这样的话，也许就能做一个好玩的智能小车玩一玩&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/v2-040410c5734a45081b8da38113c54eef_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;345&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-040410c5734a45081b8da38113c54eef_b.jpg&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-e4dd11532761d736aa117faf57e1e2cf_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;6tpn2-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6tpn2-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;参考资料&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;4t03o-0-0&quot;&gt;&lt;span data-offset-key=&quot;4t03o-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;S3.做电视机机顶盒应用，例如借助ntv.js&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;1ub90-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;1ub90-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;（注意：我搜索到的这方面的资料其实非常有限，可能有错误和纰漏，还请指正! ）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;fi1s3-0-0&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fi1s3-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;当你打开电视机机顶盒的时候，你看到的可能还是熟悉的HTML和JS，而它们被运行在一个看起来很不一样的“浏览器”上，当然，为了兼容电视机的接口，开发上可能存在很多细节上的不同，也正因如此，有积极热心的人开发了一个框架，叫ntv.js, 用来兼容不同牌子数字电视的中间件接口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/v2-79f8d55eb845e351f79b9d702bbe2e97_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;550&quot; data-rawheight=&quot;309&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-79f8d55eb845e351f79b9d702bbe2e97_b.jpg&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-719892e171a4c4fbc83e9d3570b02c9b_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;dm7pr-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dm7pr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;本人其实对电视机这一块不是很了解，但是通过阅读文档和相关资料，大概总结出以下内容&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;5v28p-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5v28p-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们平时观看的电视软件，有 东方有线网，电信IPTV网等 不同电视软件公司， 这些电视软件呢，又有不同的二级厂商提供给它们“中间件浏览器” （终于看到一个我看得懂的词了！ 哭）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;b6cs4-0-0&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;b6cs4-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b6cs4-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;电信下提供中间件浏览器的厂商主要是 iPanel、天柏，中间件规范为“IPTV2.0/3.0规范”&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;f56tu-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f56tu-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;东方有线 下提供中间件的厂商主要是 iPanel、SHDV、联彤&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;5oaji-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5oaji-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Ntv.js根据这些中间间浏览器提供的规范，实现了兼容统一的JavaScript接口&lt;span data-offset-key=&quot;5oaji-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;，大概是这么个意思&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;f3k1v-0-0&quot;&gt;&lt;span data-offset-key=&quot;f3k1v-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;S4.通过Hybird开发混合APP，到后来通过React-Native编写原生APP&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;292ef-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;292ef-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;（这件事情其实不用讲也可以，因为大家肯定都比较了解了，但还是陈述以下）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;besi2-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;besi2-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Hybird是一种混合开发应用，基于webview实现，通过ios/android下不同的接口，可以实现JavaScript和Java/Object-C代码的互通。单纯使用ios/android原生实现，开发进度和成本受不了，而单纯使用h5/js开发，页面体验更加受不了。Hybird的目的是实现H5和Naive两者之间的权衡。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;fusnm-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fusnm-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Hybird开发中能看到许多H5的影子，影响其体验，所以到后来，就出现了React-Native。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;4alnc-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4alnc-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;React-Native所编写开发的并不是Hybird那样的混合应用，它编写的是真正的原生应用。通过JavaScript和React框架的语法进行开发。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/v2-40342f942838db49734449422b801887_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1920&quot; data-rawheight=&quot;1080&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-40342f942838db49734449422b801887_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-acc8e47934c0c182acecd54d47c2ed15_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;596k5-0-0&quot; readability=&quot;6.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;596k5-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;“从使用感受上和用Objective-C或Java编写的应用相比几乎是无法区分的。 React Native所使用的基础UI组件和原生应用完全一致。” —— React-Native官网。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;cr6hh-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cr6hh-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;所以相比起Hybird, React-Native在降低开发成本的同时，尽量优化了用户的体验。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;31cub-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;31cub-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;当然了，RN也有许多缺点，这些就有劳诸位自己去查了，这里不作赘述&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;5v2lt-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5v2lt-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;其他资料&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;fr9sh-0-0&quot;&gt;&lt;span data-offset-key=&quot;fr9sh-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;S5.JS语通过Cocos2d-x 框架或白鹭引擎，可以开发流行游戏&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;cn9m1-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Cocos2d-js&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;22plu-0-0&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;22plu-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;22plu-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Cocos2d-x是一套开源跨平台的游戏开发框架，适配ios/android/html5/Mac/windows多端，但功能侧重于原生移动平台&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;bborm-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bborm-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;提供了图形渲染、网络、用户、音频、GUI 等功能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;fgc2q-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fgc2q-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;核心采用C++编写，支持JavaScript等语言进行开发&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/v2-cfcf77bd4c3f6732b735d257ae46e3bb_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;268&quot; data-rawheight=&quot;190&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-cfcf77bd4c3f6732b735d257ae46e3bb_b.jpg&quot; data-watermark-src=&quot;https://pic1.zhimg.com/v2-460a4ef09b1a6882076cc2f7765dd4c8_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;e8d3l-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;白鹭引擎（Egret）&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ol class=&quot;public-DraftStyleDefault-ol&quot; data-offset-key=&quot;4ciac-0-0&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;4ciac-0-0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4ciac-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;白鹭为开发者提供移动端游戏开发一站式解决方案，并建立包含核心渲染引擎2D/3D、游戏开发工具、创意动画工具、资源工具、原生打包方案等全球首个HTML5完整工作流&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-orderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;4vfmd-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4vfmd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Egret中包含多个工具以及项目。而Egret Engine是一个基于TypeScript语言开发的HTML5游戏引擎&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/v2-919fae9092261c88a49b39056d676d5f_b.png&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1404&quot; data-rawheight=&quot;470&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-919fae9092261c88a49b39056d676d5f_b.jpg&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-6868d81c26fe309087a98fcf9a3b0c63_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;f7bmt-0-0&quot;&gt;&lt;span data-offset-key=&quot;f7bmt-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;S6.JS可以进行三维处理: WebGL和three.js&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;35qb-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;35qb-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;WebGL (Web图形库) 是一种JavaScript API，也属于HTML5的范畴。它可以用于在任何兼容的Web浏览器中呈现交互式3D和2D图形，而无需使用插件。WebGL通过引入一个与OpenGL ES 2.0紧密相符合的API，&lt;span data-offset-key=&quot;35qb-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;可以在HTML5 &amp;lt;canvas&amp;gt; 元素中使用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;68fal-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;68fal-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;而Three.js是基于WebGL封装的一个框架，能写出在浏览器上流畅运行的3D程序&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;3hvhk-0-0&quot;&gt;

&lt;/blockquote&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/v2-9a9fd1f8ab79ad541342baa6672ec5d2_b.gif&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;923&quot; data-rawheight=&quot;607&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;c536m-0-0&quot;&gt;&lt;span data-offset-key=&quot;c536m-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;S7.做浏览器插件开发，例如Chrome插件&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;small&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;small&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic4.zhimg.com/v2-7e5d88d07be1ec345576eea71f4c5f6f_b.png&quot; alt=&quot;&quot; width=&quot;512&quot; height=&quot;742&quot; data-size=&quot;small&quot; data-rawwidth=&quot;628&quot; data-rawheight=&quot;910&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic4.zhimg.com/v2-7e5d88d07be1ec345576eea71f4c5f6f_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-8d3776d2fcac4be5c69d8e3e437b7c65_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;fnts0-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fnts0-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;有的时候，为了辅助开发，你可能会下载Chrome插件，Chrome插件下载完后呢，往往会在Chrome的右上角上有个自己的小图标，点击后会弹出菜单，然后通过对菜单进行操作就可以使用相关功能，就像上面那个默认的小图标的操作一样=&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;812gd-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;812gd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;其实Chrome插件里的菜单的UI和交互也还是HTML和JS实现的，我们完全可以按照规范，定制自己的自定义Chrome插件，具体的做法参考以下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;so6i-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;so6i-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;参考资料&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;bsvlk-0-0&quot;&gt;&lt;span data-offset-key=&quot;bsvlk-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;S8.做IDE插件开发,例如VScode&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;bm332-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bm332-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们在使用VScode的时候，我们发现，许多好用的插件大大加速了我们的开发过程，那我们能不能自己写一个自己的插件呢？ 这当然也是可以的，道理和第5点是类似的，这里不多阐述，参考&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;1n4ua-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1n4ua-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;参考资料&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;an3bf-0-0&quot;&gt;&lt;span data-offset-key=&quot;an3bf-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;S9.NodeOS: 属于JS的操作系统&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;ap0ki-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ap0ki-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;(当然了，JS写操作系统，相对其他语言来说肯定是被动的，但是我觉得吧，阅读其源码有利于前端工程师去了解操作系统的组成和构造，就是一个学习的窗口吧)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;67t6s-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;67t6s-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;NodeOS是一个由Node.js设计的操作系统，发布于2015年。NodeOS的主要特点是：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;6j15e-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6j15e-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;参考资料&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;5jnn5-0-0&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5jnn5-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Github地址&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;span&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic1.zhimg.com/v2-f40f813954d895c696e1607ffe900200_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;612&quot; data-rawheight=&quot;251&quot; data-watermark=&quot;watermark&quot; data-original-src=&quot;https://pic1.zhimg.com/v2-f40f813954d895c696e1607ffe900200_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/v2-625ed1be9282a27d29eef962d3a230a9_b.jpg&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;4bccs-0-0&quot;&gt;&lt;span data-offset-key=&quot;4bccs-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;S10.微软开发的Node.js 多线程库 Napa.js，让JS也能拥抱多线程&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;91idn-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;91idn-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;我们都知道，理论上node.js是单线程的，适合处理IO密集型的任务，但也许不适合处理计算密集型的任务。而微软提供了一个node的多线程的实现：Napa.js，让JS也能够涉略计算密集型的任务。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;pslb-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;pslb-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Napa.js的作用&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;4chdv-0-0&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;4chdv-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4chdv-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;支持多线程，拥抱计算密集型的任务&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;4b3oi-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4b3oi-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;支持JavaScript线程上的对象传输，对象共享功能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;bofgn-0-0&quot; readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bofgn-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;提供了内存分配的API&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;bita6-0-0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bita6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;参考资料&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;du1u2-0-0&quot;&gt;&lt;span data-offset-key=&quot;du1u2-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;5qp2h-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;5qp2h-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这篇文章，说了些东西，也什么都没说。 &lt;strong&gt;但我认为，相对于知道具体怎么做一件事情，&lt;span data-offset-key=&quot;5qp2h-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;知道能做哪些事情，也许也同样重要。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;2g79u&quot; data-offset-key=&quot;3eg3b-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;3eg3b-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;最后，欢迎大家多多补充&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 08 Oct 2019 00:47:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<og:description>本文介绍了除了Web和Node.js以外，JavaScript的10种工业运用，包括构建PC桌面应用，沟通硬件，构建原生应用，做游戏开发，插件开发，甚至涉略操作系统和多线程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/penghuwan/p/11633475.html</dc:identifier>
</item>
<item>
<title>Spring Boot （八）： Mybatis 增强工具 MyBatis-Plus - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11633476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11633476.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191008084546290-797334911.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;https://www.geekdigging.com/2019/09/28/3684964092/&quot;&gt;《Spring Boot （七）： Mybatis极简配置》&lt;/a&gt; 中我们介绍了在 Spring Boot 中 Mybatis 的基础使用方式，其中有一部分美中不足的是 Mybatis 本身并未提供分页功能，还需要我们自己手动添加 &lt;code&gt;PageHelper&lt;/code&gt; 插件或者自己实现分页的工具类，并且对单表的操作并不友好，简单的 insert 、 update 、 delete 还需我们添加 SQL 语句，在目前微服务的架构模式下，每个服务拥有自己的单独的数据库，单表的使用场景会越来越多， Mybatis 的使用无疑会产生很多重复劳动。&lt;/p&gt;
&lt;p&gt;Mybatis Plus 在这样的背景下应运而生了，MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。而开源团队对这个开源项目的愿景如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;愿景&lt;br/&gt;我们的愿景是成为 MyBatis 最好的搭档，就像 魂斗罗 中的 1P、2P，基友搭配，效率翻倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;特性&quot;&gt;2. 特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;无侵入：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑&lt;/li&gt;
&lt;li&gt;损耗小：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作&lt;/li&gt;
&lt;li&gt;强大的 CRUD 操作：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求&lt;/li&gt;
&lt;li&gt;支持 Lambda 形式调用：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错&lt;/li&gt;
&lt;li&gt;支持主键自动生成：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题&lt;/li&gt;
&lt;li&gt;支持 ActiveRecord 模式：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作&lt;/li&gt;
&lt;li&gt;支持自定义全局通用操作：支持全局通用方法注入（ Write once, use anywhere ）&lt;/li&gt;
&lt;li&gt;内置代码生成器：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用&lt;/li&gt;
&lt;li&gt;内置分页插件：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询&lt;/li&gt;
&lt;li&gt;分页插件支持多种数据库：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库&lt;/li&gt;
&lt;li&gt;内置性能分析插件：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询&lt;/li&gt;
&lt;li&gt;内置全局拦截插件：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Mybatis-Plus 相比较 Mybatis 更好的支持了单表的相关操作，并且直接支持分页功能，还加入了一系列有助于开发的插件，相关详细内容推荐各位读者访问官方网站获得：https://mybatis.plus/guide/ 。下面将会介绍 Mybatis-Plus 的单表操作和引入 SQL 分析插件。&lt;/p&gt;
&lt;h2 id=&quot;工程实战&quot;&gt;3. 工程实战&lt;/h2&gt;
&lt;h3 id=&quot;工程依赖-pom.xml-如下&quot;&gt;3.1 工程依赖 pom.xml 如下：&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-mybatis-plus/pom.xml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.2.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- https://mvnrepository.com/artifact/p6spy/p6spy --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;p6spy&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;p6spy&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.8.6&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;mybatis-plus-boot-starter 为 mybatis-plus 所需依赖&lt;/li&gt;
&lt;li&gt;p6spy 为 SQL 分析打印依赖，如不需要，可以单独引入 mybatis-plus-boot-starter 。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置&quot;&gt;3.2 配置&lt;/h3&gt;
&lt;p&gt;配置文件 application.yml 如下：&lt;/p&gt;
&lt;p&gt;代码清单：spring-boot-mybatis-plus/src/main/resources/application.yml&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 8080
spring:
  application:
    name: spring-boot-mybatis-xml
  datasource:
    url: jdbc:p6spy:mysql://172.16.96.112:3306/test?serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false
    username: root
    password: 123456
    driver-class-name: com.p6spy.engine.spy.P6SpyDriver
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      auto-commit: true
      minimum-idle: 2
      idle-timeout: 60000
      connection-timeout: 30000
      max-lifetime: 1800000
      pool-name: DatebookHikariCP
      maximum-pool-size: 5
# 配置slq打印日志
mybatis-plus:
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：开启 mybatis-plus 的 SQL 分析打印&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要配置 &lt;code&gt;mybatis-plus.configuration.log-impl&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;修改配置 &lt;code&gt;spring.datasource.driver-class-name&lt;/code&gt; 为 &lt;code&gt;com.p6spy.engine.spy.P6SpyDriver&lt;/code&gt; ,这个配置是使用 p6spy 提供的驱动类。&lt;/li&gt;
&lt;li&gt;url 前缀为 jdbc:p6spy 跟着冒号为对应数据库连接地址。&lt;/li&gt;
&lt;li&gt;该插件有性能损耗，不建议生产环境使用。&lt;/li&gt;
&lt;li&gt;还需增加 spy.properties ，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码清单：spring-boot-mybatis-plus/src/main/resources/spy.properties&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.log=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory
# 自定义日志打印
logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger
#日志输出到控制台
appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger
# 使用日志系统记录 sql
#appender=com.p6spy.engine.spy.appender.Slf4JLogger
# 设置 p6spy driver 代理
deregisterdrivers=true
# 取消JDBC URL前缀
useprefix=true
# 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.
excludecategories=info,debug,result,batch,resultset
# 日期格式
dateformat=yyyy-MM-dd HH:mm:ss
# 实际驱动可多个
#driverlist=org.h2.Driver
# 是否开启慢SQL记录
outagedetection=true
# 慢SQL记录标准 2 秒
outagedetectioninterval=2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mapper-类&quot;&gt;3.3 Mapper 类&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-mybatis-plus/src/main/java/com/springboot/springbootmybatisplus/mapper/UserMapper.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface UserMapper extends BaseMapper&amp;lt;User&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只需要继承 BaseMapper 即可， BaseMapper 为我们提供了丰富的单表操作，具体的操作可以查看源码 &lt;code&gt;com.baomidou.mybatisplus.core.mapper.BaseMapper&amp;lt;T&amp;gt;&lt;/code&gt; ，其中的注释非常详尽。&lt;/p&gt;
&lt;h3 id=&quot;service-类&quot;&gt;3.4 Service 类&lt;/h3&gt;
&lt;p&gt;Mybatis-Plus 除了为我们提供了基础的 Mapper 类以外，还为我们提供了 IService ，通用 Service CRUD 封装IService接口，进一步封装 CRUD 采用 get 查询单行 remove 删除 list 查询集合 page 分页 前缀命名方式区分 Mapper 层避免混淆。并且官方建议我们如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类。&lt;/p&gt;
&lt;p&gt;UserService.java 代码如下：&lt;/p&gt;
&lt;p&gt;代码清单：spring-boot-mybatis-plus/src/main/java/com/springboot/springbootmybatisplus/service/UserService.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface UserService extends IService&amp;lt;User&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UserServiceImpl.java 代码如下;&lt;/p&gt;
&lt;p&gt;代码清单：spring-boot-mybatis-plus/src/main/java/com/springboot/springbootmybatisplus/service/impl/UserServiceImpl.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Service
public class UserServiceImpl extends ServiceImpl&amp;lt;UserMapper, User&amp;gt; implements UserService {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关测试代码已经创建测试 controller ，这里就不列出了，有需要的读者可以访问 Github 代码仓库自行取用。&lt;/p&gt;
&lt;h3 id=&quot;分页配置类&quot;&gt;3.5 分页配置类&lt;/h3&gt;
&lt;p&gt;代码清单：spring-boot-mybatis-plus/src/main/java/com/springboot/springbootmybatisplus/config/MybatisPlusConfig.java&lt;br/&gt;***&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class MybatisPlusConfig {

    /**
     * 注册分页插件
     * @return
     */
    @Bean
    public PaginationInterceptor paginationInterceptor(){
        return  new PaginationInterceptor();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试&quot;&gt;4. 测试&lt;/h2&gt;
&lt;p&gt;启动工程后，打开浏览器访问：http://localhost:8080/findPage ，可以看到 json 正常返回，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;records&quot;:[
        {
            &quot;id&quot;:&quot;a0ac692d-e1f1-11e9-9a69-0242ac110002&quot;,
            &quot;nickName&quot;:&quot;geekdigging.com&quot;,
            &quot;age&quot;:108,
            &quot;createDate&quot;:&quot;2019-09-28T13:12:31.000+0000&quot;
        },
        {
            &quot;id&quot;:&quot;b9168576-e1f1-11e9-9a69-0242ac110002&quot;,
            &quot;nickName&quot;:&quot;www.geekdigging.com&quot;,
            &quot;age&quot;:18,
            &quot;createDate&quot;:&quot;2019-09-28T13:13:12.000+0000&quot;
        }
    ],
    &quot;total&quot;:2,
    &quot;size&quot;:5,
    &quot;current&quot;:1,
    &quot;orders&quot;:[

    ],
    &quot;searchCount&quot;:true,
    &quot;pages&quot;:1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时我们查看控制台的日志，可以看到 SQL 分析的相关日志，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201910/908359-20191008084546527-142674692.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从日志中，我们可以清楚的看到当前日志执行的过程，先执行了什么后执行了什么，并且耗时是多少，有助于我们的进行 SQL 的性能分析，知道具体是哪些 SQL 耗时会比较长。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;5. 小结&lt;/h2&gt;
&lt;p&gt;Mybatis-Plus 整体使用都比较简单，Mybatis 支持的使用方式 Mybatis-Plus 都支持，只是原本配置文件 application.yml 中的 &lt;code&gt;mybatis.***&lt;/code&gt; 需要替换成为 &lt;code&gt;mybatis-plus.***&lt;/code&gt; ，并且增强了 Mybatis 原本单表操作的不足之处，对于官方的宣言：只做增强不做改变，为简化开发、提高效率而生。笔者认为是十分贴切的。本文仅介绍了 Mybatis-Plus 的一些基础使用方式，官方除了增强了单表操作、分页、 SQL 分析等功能外，还提供了很多实用的插件，例如：热加载、逻辑删除、SQL 注入器、攻击 SQL 阻断解析器等功能，如有需要的读者朋友可以访问官方文档自取。&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;5. 示例代码&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/meteor1993/spring-boot-examples/tree/master/spring-boot-mybatis-plus&quot; title=&quot;示例代码-Github&quot;&gt;示例代码-Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/inwsy/spring-boot-examples/tree/master/spring-boot-mybatis-plus&quot; title=&quot;示例代码-Gitee&quot;&gt;示例代码-Gitee&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;6. 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mybatis.plus/guide/&quot;&gt;《Mybatis-Plus官方文档》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Oct 2019 00:46:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1. 简介 在上一篇文章 '《Spring Boot （七）： Mybatis极简配置》' 中我们介绍了在 Spring Boot 中 Mybatis 的基础使用方式，其中有一部分美中不足的是 Myb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11633476.html</dc:identifier>
</item>
<item>
<title>每天3分钟操作系统修炼秘籍（2）：并行的假象和分时系统 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/11633451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/11633451.html</guid>
<description>&lt;h2 id=&quot;假象并行运行多个进程&quot;&gt;假象：“并行”运行多个进程&lt;/h2&gt;
&lt;p&gt;现代操作系统都支持多任务同时执行。在这里，操作系统对我们用户“营造了一种假象”，让CPU看上去是用不完的，能够不断地添加新的程序使它们同时运行。&lt;/p&gt;
&lt;p&gt;但每核CPU在某一时刻都只能执行一个进程。使用操作系统的人是不会去关注CPU是单核还是多核的，每个人都希望操作系统能同时运行多个程序，比如可以同时看网页、发邮件、聊QQ、听音乐等。&lt;/p&gt;
&lt;p&gt;所以操作系统提供的多程序同时运行是“伪并行”。要想实现真正的并行运行多个进程，只能使用多核CPU来实现。&lt;/p&gt;
&lt;p&gt;OS营造这种假象的技术是“&lt;strong&gt;CPU时间共享&lt;/strong&gt;（time sharing）”，也称为“&lt;strong&gt;分时系统&lt;/strong&gt;”，即CPU执行一会进程A，然后停下来去执行一会进程B，再停下来执行一会进程A。即，每个进程都只执行一会，然后CPU切换去执行其它进程，每一段执行和切换的时间很短（每秒能执行很多个进程），使得用户以为进程根本未停过，从而形成了假象。&lt;/p&gt;
&lt;p&gt;例如，下图描述了分时系统的进程切换方式。进程A执行一会后切换到进程B，B执行一会后又切换到C，C执行一会后又切换到B，再切换回C、A、C、D。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201910/733013-20191008082919746-2084700531.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种不断切换进程的机制，其关键技术是CPU从一个进程切换到另一个进程，这是通过“&lt;strong&gt;上下文切换&lt;/strong&gt;（context switch）”实现的。上下文切换可以直接理解为进程的切换，之所以使用“上下文”这个术语，是因为CPU要从进程A切换到进程B时，必然要保存进程A的执行环境，比如进入切换时进程A执行到了哪个地方，以便下次切换回进程A的时候能够从这里恢复继续执行，此外，既然要切换到进程B，必然还要恢复之前已保存好的进程B的执行环境，才能知道从哪里开始继续执行进程B。而在计算机世界中，“环境”和“上下文”通常是可以互换的概念，所以CPU的上下文切换正是两个前后进程执行环境的切换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201910/733013-20191008083040315-1649136120.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CPU时间共享的好处是提升了交互性，因为每个进程都可以尽快地执行起来，都能够更快地被响应，使得每个进程都像是被公平对待，这是非常感人的。但是时间共享却带来了另外一个问题，站在进程的角度上看，每个进程从启动开始到执行完成，中间需要花费更长时间，而且很多时间处于等待状态。&lt;/p&gt;
&lt;p&gt;再考虑另外一个问题，既然要不断的切换进程，操作系统如何选择下一个要执行的进程？例如下图中，当进程D开始进程切换时，下一个要执行的是哪个进程呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201910/733013-20191008083120511-883571236.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择下一个要执行的进程，是通过操作系统的进程调度程序（也称为&lt;strong&gt;调度器&lt;/strong&gt;或&lt;strong&gt;调度类&lt;/strong&gt;）来决定的，调度器根据一些调度算法策略决定哪个进程将幸运地被选中（即，被调度到）作为下一个要执行的进程。&lt;/p&gt;
&lt;p&gt;而进程调度算法策略的两个关键性指标正是&lt;strong&gt;响应时间和周转时间&lt;/strong&gt;。响应时间体现的是交互性和公平性，响应时间越短，表示交互时能更快得到响应，比如当敲下键盘时，用户肯定不希望还要等一段时间才显示字符。周转时间体现的是何时完成任务的问题，周转时间越短，表示从启动开始到执行结束所花的时间更短，也就是更快完成任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201907/733013-20190710014312939-1512504434.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外，虽然在分时系统下，通过为每个进程分配固定的时间片能保证每个进程都有机会执行，但总会有一些进程是比较重要的，它们的优先级比较高，它们可以从当前正在执行的进程处抢占CPU，这称为“&lt;strong&gt;抢占式多任务处理&lt;/strong&gt;”。当然，这里的抢占并不是真的无条件抢到CPU，CPU给谁是由操作系统的调度策略决定的，“抢占”只是表明某进程比较重要，应当优待，比如让该进程尽快执行或让它多执行一会。&lt;/p&gt;
&lt;p&gt;进程调度是非常重要的概念，在后面还会专门花费一些篇幅介绍进程的调度。&lt;/p&gt;
</description>
<pubDate>Tue, 08 Oct 2019 00:41:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>'每天3分钟操作系统修炼秘籍（1）：秘籍简介' '每天3分钟操作系统修炼秘籍（2）：并行的假象和分时系统' （本文） 假象：“并行”运行多个进程 现代操作系统都支持多任务同时执行。在这里，操作系统对我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/f-ck-need-u/p/11633451.html</dc:identifier>
</item>
<item>
<title>(三)分布式数据库tidb-隔离级别详解 - 咸鱼也要有梦想</title>
<link>http://www.cnblogs.com/hang-on/p/11606094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hang-on/p/11606094.html</guid>
<description>&lt;div readability=&quot;32&quot;&gt;
&lt;p&gt;&lt;strong&gt;tidb隔离级别详解:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1766027/201909/1766027-20190906213844470-2093711522.png&quot; alt=&quot;&quot; width=&quot;641&quot; height=&quot;368&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.TiDB 支持的隔离级别是 &lt;strong&gt;Snapshot Isolation（SI）&lt;/strong&gt;，它和 Repeatable Read（RR） 隔离级别基本等价，详细情况如下：&lt;/p&gt;
&lt;p&gt;　　● TiDB 的 SI 隔离级别可以克服幻读异常（Phantom Reads），但 ANSI/ISO SQL 标准中的 RR 不能。&lt;/p&gt;
&lt;p&gt;　　所谓幻读是指：事务 A 首先根据条件查询得到 n 条记录，然后事务 B 改变了这 n 条记录之的 m 条记录或者增添了 m 条符合事务 A 查询条件的记录，导致事务 A 再次发起请求时发现有 n+m 条符合条件记录，就产生了幻读。&lt;/p&gt;
&lt;p&gt;　　● TiDB 的 SI 隔离级别不能克服写偏斜异常（Write Skew），需要使用 Select for update语法来克服写偏斜异常。写偏斜异常是指两个并发的事务读取了两行不同但相关的记录，接着这两个事务各自更新了自己读到的那行数据，并最终都提交了事务，如果这两行相关的记录之间存在着某种约束，那么最终结果可能是违反约束的。&lt;/p&gt;
&lt;p&gt;　　例如，值班表有两列，姓名以及值班状态，0 代表不值班，1 代表值班 &lt;/p&gt;
&lt;div&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;姓名&lt;/td&gt;
&lt;td&gt;值班状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;张三&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;李四&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;王五&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;　　有这样一个事务，它的逻辑是判断当前无人值班，则分配一个值班人。当该程序顺序执行时，只会分配一个值班人。但当它并行执行时，就可能出现多人同时为值班状态的错误。&lt;/p&gt;
&lt;p&gt;　　● TiDB 在默认配置下（tidb_disable_txn_auto_retry=0）不能克服丢失更新异常（LostUpdates）。&lt;/p&gt;
&lt;p&gt;　　所谓丢失更新是指：两个事务 A，B 读取相同记录并更新同一列的值，若 A 先于 B 提交事务，当 B 事务提交后 A 再次查询时发现自己的更新丢失了。&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;14&quot;&gt;　　 2. 显式事务中 DML 语句返回的 affected rows 不可信与所有使用了乐观锁机制的分布式数据库（PXC, MGC, MGR 等）一样，在显式执行的事务中（设置为非自动提交 autocommit=0，或使用 begin 语句显式声明事务开始），DML操作所返回的 affected rows 并不保证与最终提交事务时所影响的数据行数一致。
&lt;p&gt;　　　　如下案例，事务 B 在并发中丢失了它的更新: &lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1766027/201909/1766027-20190906215008997-2052787493.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;76.5&quot;&gt;
&lt;p&gt;　　这是由于在显式执行的事务中 DML 操作与提交操作分开被执行，在事务提交过程中，如果由于事务冲突，找不到 TiKV，网络不稳定等原因而发生了重试，TiDB 将获取新的时间戳&lt;/p&gt;
&lt;p&gt;重新执行本事务中的 DML 操作，原本的 SI 隔离级别在重试后会产生类似 RC 隔离级别的不可重复读与幻读异常现象。 由于重试机制在内部完成，如果最终本事务提交成功，用户一般是无法感知到是否发 生了重试的，因此不能通过 affected rows 来作为程序执行逻辑的判断条件。 而隐式事务中（以单条 SQL 为单位进行提交），语句的返回是提交之后的结果，因此 隐式事务中的 affected rows 是可信的。&lt;/p&gt;
&lt;p&gt;　　3. 避开丢失更新影响的应用开发方法 TiDB 使用了乐观锁机制，乐观锁仅在提交时才会进行冲突检测和数据上锁。在使用了 非 select for update 的 SQL 语句时，TiDB 会对提交时遇到冲突而发生退避的事务进行自动重 试（由 tidb_disable_txn_auto_retry 变量控制，默认行为是自动重试），当事务达到退避次数限 制（默认 10 次）依然不能成功提交时，事务会被回滚。 发生了退避的事务会重新获取时间戳，重新执行事务中的增删改语句，这样设计是为 了规避上一次造成提交失败的原因（包括但不限于锁冲突），但也因此导致了并发事务可能出 现丢失更新异常。 可以通过妥善的应用实现方式来避免丢失更新造成的影响。&lt;/p&gt;
&lt;p&gt;　　场景一，在不做余额检查的类似转账交易场景中，一般通过账号筛选出需要修改余额 的记录，然后直接在数据库中进行数学运算的 SQL 来实现对账户余额的更新，诸如此类写法 的事务即使在并发执行时遇到了丢失更新异常，也可以正确的完成转账操作，并不会被用户感 知到：&lt;/p&gt;
&lt;p&gt;update account set realtimeremain = realtimeremain-100 where cuno='A';&lt;/p&gt;
&lt;p&gt;update account set realtimeremain = realtimeremain+100 where cuno='B';&lt;/p&gt;
&lt;p&gt;commit;&lt;/p&gt;
&lt;p&gt;　　同上转账场景，如果实现方式是应用获取了当前转入转出账户的余额后，在应用中计 算出转账后两账户的余额，使用常值写入余额字段，这样的实现方式在事务并发执行时将会导 致错误：&lt;/p&gt;
&lt;p&gt;　　select realtimeremain from account where cuno='A';&lt;/p&gt;
&lt;p&gt;　　--返回 1000&lt;/p&gt;
&lt;p&gt;　　select realtimeremain from account where cuno='B';&lt;/p&gt;
&lt;p&gt;　　--返回 1000&lt;/p&gt;
&lt;p&gt;　　--应用中计算出两账户转账后的余额分别为 900 和 1100&lt;/p&gt;
&lt;p&gt;　　update account set realtimeremain = 900 where cuno='A'; update account set realtimeremain = 1100 where cuno='B';&lt;/p&gt;
&lt;p&gt;　　commit;&lt;/p&gt;
&lt;p&gt;　　4. 计数器，秒杀场景的处理方法 如上一段所讲，TiDB 采用了乐观锁机制，在事务的并发处理中，TiDB 会自动重试提 交时遇到冲突而发生退避的事务；而在使用了 select for update 或关闭 tidb_disable_txn_auto_retry 变量时，这种退避机制会失效，后提交的事务会被回滚。 select for update 被使用于计数器，秒杀，公用账户、理财产品、国债的余额扣减等场 景，技术特点是并发的对同一行数据进行修改。传统的单机 DBMS 多使用悲观锁来实现 select for update，在事务开始的时候即进行锁检查，如果事务所需要的锁和数据上当前的锁不 兼容，就会发生锁等待，等当前的锁释放后本事务才能执行。TiDB 在执行 select for update 时 相当于悲观锁系统中将锁等待时间设置为 0，遇到锁冲突的事务会执行失败。 综上，TiDB 不适合用于处理高并发的对同一行数据进行修改，事务使用了 select for update 语句，可以保证数据的一致性，但并发执行的事务中，只有最先提交的事务会成功，其 余的并发请求都会被回滚。 处理计数器场景的最佳实践是将计数器功能转移到缓存（redis，codis 等）中实现，如 购买国债产品场景中，将国债余额读取到缓存中，在缓存中根据余额与购买额度对请求队列进 行控制，向合格的请求发放访问数据库的令牌，向购买额度超过余额的请求返回余额不足的错 误，拿到令牌的请求可以并发去修改数据库中的产品余额。 在应用了悲观锁的 DBMS 中，并发的 select for update 事务实际上是被排成队列以串行 的方式执行的，因此性能不高，而使用缓存来处理计数器场景也有着较大的性能优势。&lt;/p&gt;
&lt;p&gt;　　5. “嵌套事务” 遵照 ACID 理论，并发事务间应彼此相互隔离，避免互相干扰。即事务不能“嵌套”。 在 Read Committed 隔离级别下，同一事务中如果存在多次读取，每次读到的都是当 时已经提交的数据，在多个事务并发执行时，一个事务内多次读取的结果可能千差万别，这种 现象被称为“不可重复读（Non-repeatable Reads）”。应用于传统金融行业的 RDBMS 产品中，默认隔离级别为 RC 的产品占有绝大部分市 场份额，而应用开发中也很少有人注意到隔离级别的设置，因此“不可重复读”往往被应用开发 人员认为是一种功能，甚至据此开发了基于“嵌套事务”的应用。 下图中的案例描述了一个典型的“嵌套事务”的执行逻辑（红色箭头）。session 1 和 session 2 是该程序开启的两个会话，左侧的 T1 ~ T8 是时间轴。程序在 T1 的时候开启了一 个会话 session 1，然后执行了一个查询（注意，在 MySQL 协议中，begin 的下一条有数据 访问的语句被视为事务的开始）。之后的 T3 ~ T5，程序开启了另一个会话 session 2，写入 了一行数据后提交。然后程序继续操作 session 1，在 T6 时它试图更新这行刚刚写入的数据 ，并在 T7 时提交了 T2 时开启的本事务。 T8 时，session 1 执行了一条查询语句，来检查最初在 T4 时由 session 2 写入的 k=1 对应行的 val 值。&lt;/p&gt;

&lt;div readability=&quot;56&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1766027/201909/1766027-20190906215409307-2041632817.png&quot; alt=&quot;&quot;/&gt;

&lt;p&gt;在 RC 隔离级别下，T8 时查询的返回值为 102，看上去似乎满足了“嵌套事务”的功能 需求。但实际上这是错误的，案例中仅使用单线程模拟了“嵌套事务”的场景，在实际业务的并 发请求下，多个事务在时间轴上交错执行，交错提交，将使“嵌套事务”的执行结果变得不可预 知。 在 SI 或 RR 隔离级别下，直到提交或回滚之前的任何读取（不限于 tab1 表）所返回 的结果都对应事务开始的那个瞬间的一致性状态。也就是说，在 T2 时，session 1 中的事务所能读取到的数据就已经确定了，它就像是给数据库在 T2 时的留下了一个快照，即使之后的 T3 ~ T5 开启了新的 session 2，写入数据并提交，也不会影响 T6 时 session 1 所读取到的数 据，T6 未读取到 k=1 的行，因此更新了 0 行。在 T8 时，查询的返回值为 2。在 SI 或 RR 隔 离级别下，事务间的隔离度更高了，在并发请求下，其结果也是可预期的。 在这个案例中，如果只是想实现 session 1 能够更新到 session 2 写入的数据的需求， 只需要控制程序逻辑，在 T2 时的查询语句之后添加 commit 步骤，及时提交这个查询事务， 再执行后续步骤即可。&lt;/p&gt;
&lt;p&gt;　　6. 不支持 Spring 框架的 PROPAGATION_NESTED 传播行为 （依赖 savepoint 机制） Spring 支持的 PROPAGATION_NESTED 传播行为会启动一个嵌套的事务，它是当前事 务之上独立启动的一个子事务。嵌套事务开始时会记录一个 savepoint， 如果嵌套事务执行失 败，事务将会回滚到 savepoint 的状态，嵌套事务是外层事务的一部分，它将会在外层事务提 交时一起被提交。下面案例展示了 savepoint 机制：&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; BEGIN; mysql&amp;gt; INSERT INTO T2 VALUES(100);&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; SAVEPOINT svp1;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; INSERT INTO T2 VALUES(200);&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; ROLLBACK TO SAVEPOINT svp1;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; RELEASE SAVEPOINT svp1;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; COMMIT;&lt;/p&gt;
&lt;p&gt;mysql&amp;gt; SELECT * FROM T2; +------+ | ID | +------+ | 100 | +------+ TiDB&lt;/p&gt;
&lt;p&gt;不支持 savepoint 机制，因此也不支持 PROPAGATION_NESTED 传播行为，基于 Java Spring 框架的应用如果使用了 PROPAGATION_NESTED 传播行为，需要在应用端做出调 整，将嵌套事务的逻辑移除。&lt;/p&gt;
&lt;p&gt;　　7. 大事务 基于日志的数据库在面对大事务时，需要手动调大可用日志的容量，以避免日志被单 一事务占满。 TiDB 中对于事务量有着硬限制，由于 TiDB 分布式两阶段提交的要求，修改数据的大 事务可能会出现一些问题。因此，TiDB 对事务大小设置了一些限制以减少这种影响（一行数据是一个键值对，一行索引也是一个键值对，当一张表只有 2 个索引时，每 insert 一行数据 会写入 3 个键值对）：&lt;/p&gt;
&lt;p&gt;● 每个键值对不超过 6MB&lt;/p&gt;
&lt;p&gt;● 键值对的总数不超过 300,000&lt;/p&gt;
&lt;p&gt;● 键值对的总大小不超过 100MB 据此，涉及大量数据增删改的事务（如批量的对账事务等），需要进行缩减事务量的 改造，最佳实践是将大事务改写为分页 SQL，分段提交，TiDB 中可以利用 order by 配合 limit 的 offset 实现分页功能，写法如下：&lt;/p&gt;
&lt;p&gt;update tab set value=’new_value’ where id in (select id from tab order by id limit 0,10000); commit;&lt;/p&gt;
&lt;p&gt;update tab set value=’new_value’ where id in (select id from tab order by id limit 10000,10000); commit;&lt;/p&gt;
&lt;p&gt;update tab set value=’new_value’ where id in (select id from tab order by id limit 20000,10000); commit;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 08 Oct 2019 00:41:00 +0000</pubDate>
<dc:creator>咸鱼也要有梦想</dc:creator>
<og:description>tidb隔离级别详解: 1.TiDB 支持的隔离级别是&amp;#160;Snapshot Isolation（SI），它和 Repeatable Read（RR） 隔离级别基本等价，详细情况如下： ● Ti</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hang-on/p/11606094.html</dc:identifier>
</item>
<item>
<title>AOP框架Dora.Interception 3.0 [1]: 编程体验 - Artech</title>
<link>http://www.cnblogs.com/artech/p/dora-interception-3-01.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/dora-interception-3-01.html</guid>
<description>&lt;p&gt;.NET Core正式发布之后，我为.NET Core度身定制的AOP框架&lt;a href=&quot;https://github.com/jiangjinnan/Dora&quot;&gt;Dora.Interception&lt;/a&gt;也升级到3.0。这个版本除了升级底层类库（.NET Standard 2.1）之外，我还对它进行大范围的重构甚至重新设计。这次重构大部分是在做减法，其目的在于使设计和使用更加简单和灵活，接下来我们就来体验一下在一个ASP.NET Core应用程序下如何使用Dora.Interception。&lt;/p&gt;
&lt;p&gt;源代码下载&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/Dora.App1.7z&quot;&gt;实例1&lt;/a&gt;（Console）&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/Dora.App2.7z&quot;&gt;实例2&lt;/a&gt;（ASP.NET Core MVC + 注册可拦截服务）&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/Dora.App3.7z&quot;&gt;实例3&lt;/a&gt;（ASP.NET Core MVC + 注册InterceptableServiceProviderFactory）&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/Dora.App4.7z&quot;&gt;实例4&lt;/a&gt;（ASP.NET Core MVC + 拦截策略）&lt;br/&gt;&lt;a href=&quot;https://files.cnblogs.com/files/artech/Dora.App5.7z&quot;&gt;实例5&lt;/a&gt;（ASP.NET Core MVC + 策略脚本化）&lt;/p&gt;

&lt;p&gt;我们依然沿用“缓存”这个应用场景：我们创建一个缓存拦截器，并将其应用到某个方法上。缓存拦截器会将目标方法的返回值缓存起来。在缓存过期之前，提供相同参数列表的方法调用会直接返回缓存的数据，而无需执行目标方法。如下所示是作为缓存键类型的CacheKey的定义，可以看出缓存时针对”&lt;strong&gt;方法+参数列表&lt;/strong&gt;”实施缓存的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Cachekey
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MethodBase Method { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] InputArguments { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Cachekey(MethodBase method, &lt;span&gt;object&lt;/span&gt;&lt;span&gt;[] arguments)
    {
        Method &lt;/span&gt;=&lt;span&gt; method;
        InputArguments &lt;/span&gt;=&lt;span&gt; arguments;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Equals(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(obj &lt;span&gt;is&lt;/span&gt;&lt;span&gt; Cachekey another))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Method.Equals(another.Method))
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;; index &amp;lt; InputArguments.Length; index++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; argument1 =&lt;span&gt; InputArguments[index];
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; argument2 =&lt;span&gt; another.InputArguments[index];
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (argument1 == &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; argument2 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (argument1 == &lt;span&gt;null&lt;/span&gt; || argument2 == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;argument2.Equals(argument2))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetHashCode()
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; hashCode =&lt;span&gt; Method.GetHashCode();
        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; argument &lt;span&gt;in&lt;/span&gt;&lt;span&gt; InputArguments)
        {
            hashCode &lt;/span&gt;= hashCode ^&lt;span&gt; argument.GetHashCode();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; hashCode;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;作为Dora.Interception区别于其他AOP框架的最大特性，我们注册的拦截器类型无需实现某个预定义的接口，因为我们采用基于“&lt;strong&gt;约定&lt;/strong&gt;”的拦截器定义方式。基于约定方式定义的缓存拦截器类型CacheInterceptor定义如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheInterceptor
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IMemoryCache _cache;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; MemoryCacheEntryOptions _options;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CacheInterceptor(IMemoryCache cache, IOptions&amp;lt;MemoryCacheEntryOptions&amp;gt;&lt;span&gt; optionsAccessor)
    {
        _cache &lt;/span&gt;=&lt;span&gt; cache;
        _options &lt;/span&gt;=&lt;span&gt; optionsAccessor.Value;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task InvokeAsync(InvocationContext context)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cachekey(context.Method, context.Arguments);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_cache.TryGetValue(key, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value))
        {
            context.ReturnValue &lt;/span&gt;=&lt;span&gt; value;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.ProceedAsync();
            _cache.Set(key, context.ReturnValue, _options);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照约定，拦截器类型只需要定义成一个普通的“&lt;strong&gt;公共、实例&lt;/strong&gt;”类型即可。拦截操作需要定义在约定的&lt;strong&gt;InvokeAsync&lt;/strong&gt;方法中，该方法的返回类型为&lt;strong&gt;Task&lt;/strong&gt;，并且包含一个&lt;strong&gt;InvocationContext&lt;/strong&gt;类型的参数。InvocationContext类型封装了当前方法的调用上下文，我们可以利用它获取当前的方法和输入参数等信息。InvocationContext的&lt;strong&gt;ReturnValue&lt;/strong&gt; 属性表示方法调用的返回结果，CacheInterceptor正式通过设置该属性从而实现将方法返回值进行缓存的目的。&lt;/p&gt;
&lt;p&gt;如上面的代码片段所示，在InvokeAsync方法中，我们先判断针对当前的参数参数列表是否具有缓存的结果，如果有的话我们直接将它作为InvocationContext上下文的ReturnValue属性。如果从缓存中找不到对应的结果，在通过调用InvocationContext上下文的&lt;strong&gt;ProceedAsync&lt;/strong&gt;方法执行目标方法（也可能是后续拦截器），并将新的结果缓存起来。&lt;/p&gt;

&lt;p&gt;Dora.Interception是为.NET Core度身定制的轻量级AOP框架。由于依赖注入已经成为了.NET Core基本的编程方式，所以Dora.Interception和.NET Core的依赖注入框架进行了无缝整合。正因为如此，当我们在定义拦截器的时候可以&lt;strong&gt;将依赖服务直接注入到构造函数&lt;/strong&gt;中。对于上面定义的CacheInterceptor来说，由于我们直接使用的是.NET Core提供的基于内存的缓存框架，所以我们直接将所需的IMemoryCache 服务和提供配置选项的IOptions&amp;lt;MemoryCacheEntryOptions&amp;gt; &lt;span&gt;服务注入到构造函数中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了构造函数注入，我们还支持针对InvokeAsync方法的“&lt;strong&gt;方法注入&lt;/strong&gt;”。也就是说我们可以将上述的两个依赖服务以如下的方式注入到InvokeAsync方法中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheInterceptor
{            
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task InvokeAsync(InvocationContext context, IMemoryCache cache, IOptions&amp;lt;MemoryCacheEntryOptions&amp;gt;&lt;span&gt; optionsAccessor)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cachekey(context.Method, context.Arguments);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cache.TryGetValue(key, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value))
        {
            context.ReturnValue &lt;/span&gt;=&lt;span&gt; value;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.ProceedAsync();
            cache.Set(key, context.ReturnValue, optionsAccessor.Value);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对拦截器类型的两种依赖注入方式并不是等效的，它们之间的差异体现在服务实例的&lt;strong&gt;生命周期&lt;/strong&gt;上。由于拦截器对象自身属于一个&lt;strong&gt;Singleton&lt;/strong&gt;服务，所以我们不能在它的构造函数中注入一个&lt;strong&gt;Scoped&lt;/strong&gt;服务，否则依赖服务将不能按照期望的方式被释放。&lt;strong&gt;Scoped服务只能注入到InvokeAsync方法中&lt;/strong&gt;，因为该方法注入的服务实例是根据当前Scope的IServiceProvider提供的（对于ASP.NET Core应用来说，就是当前HttpContext上下文的RequestServices）。&lt;/p&gt;

&lt;p&gt;AOP的本质对方法调用进行拦截，并在调用目标方法之前执行应用的拦截器，所以我们定义的拦截器最终需要注册到一个或者多个方法上。Dora.Interception刻意将“拦截器”和“拦截器注册”分离开来，因为拦截器具有不同的注册方式。&lt;/p&gt;
&lt;p&gt;在类型或者方法上标注特性是我们常用的拦截器注册方式，为此我们为CacheInterceptor定义了如下这个CacheReturnValueAttribute。CacheReturnValueAttribute继承自抽象类型&lt;strong&gt;InterceptorAttribute&lt;/strong&gt;，在重写的&lt;strong&gt;Use&lt;/strong&gt;方法中，我们只需要调用作为参数的IInterceptorChainBuilder对象的&lt;strong&gt;Use&amp;lt;TInterceptor&amp;gt;&lt;/strong&gt;方法将指定的拦截器添加到拦截器链条（同一个方法上可能同时应用多个拦截器）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[AttributeUsage(AttributeTargets.Method)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheReturnValueAttribute : InterceptorAttribute
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Use(IInterceptorChainBuilder builder)
    {
        builder.Use&lt;/span&gt;&amp;lt;CacheInterceptor&amp;gt;&lt;span&gt;(Order);
    }   
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Use&amp;lt;TInterceptor&amp;gt;方法的泛型参数表示对应拦截器的类型，它的第一个参数表示指定的拦截器在整个链条上的位置。这个值就是InterceptorAttribute的&lt;strong&gt;Order&lt;/strong&gt;属性值。如果拦截器类型构造函数中定义了一些无法通过依赖注入框架提供的参数，我们在调用Use&amp;lt;TInterceptor&amp;gt;方法时可以利用后面的params参数来指定。&lt;/p&gt;
&lt;p&gt;如果你觉得将拦截器类型和对应的特性分开定义比较烦，也可以将两者合二为一，我们只需要将InvokeAsync方法按照如下的方式转移到InterceptorAttribute类型中就可以了。由于它自身就是一个拦截器，我们在Use方法中会调用IInterceptorChainBuilder对象非泛型Use方法，并将自身作为第一个参数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[AttributeUsage(AttributeTargets.Method)]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CacheReturnValueAttribute : InterceptorAttribute
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task InvokeAsync(InvocationContext context, IMemoryCache cache, IOptions&amp;lt;MemoryCacheEntryOptions&amp;gt;&lt;span&gt; optionsAccessor)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cachekey(context.Method, context.Arguments);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cache.TryGetValue(key, &lt;span&gt;out&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value))
        {
            context.ReturnValue &lt;/span&gt;=&lt;span&gt; value;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.ProceedAsync();
            cache.Set(key, context.ReturnValue, optionsAccessor.Value);
        }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Use(IInterceptorChainBuilder builder)
    {
        builder.Use(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, Order);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了能够很直观地看到针对方法返回值的缓存，我们定义了如下这个表示系统时钟的ISystemClock的服务接口。该接口具有唯一的GetCurrentTime方法返回当前的时间，方法参数用于控制行为方法的时间类型（UTC或者Local）。实现类型SystemClock标注了我们定义的InterceptorAttribute特性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ISystemClock
{
    DateTime GetCurrentTime(DateTimeKind dateTimeKind);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SystemClock : ISystemClock
{
&lt;strong&gt;&lt;span&gt;    [CacheReturnValue(Order = 1)]&lt;/span&gt;&lt;/strong&gt;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DateTime GetCurrentTime(DateTimeKind dateTimeKind)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; dateTimeKind &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;
        {
            DateTimeKind.Local &lt;/span&gt;=&amp;gt;&lt;span&gt; DateTime.UtcNow.ToLocalTime(),
            DateTimeKind.Unspecified &lt;/span&gt;=&amp;gt;&lt;span&gt; DateTime.Now,
            _ &lt;/span&gt;=&amp;gt;&lt;span&gt; DateTime.UtcNow,
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;接下来我们在一个ASP.NET Core MVC应用中演示针对ISystemClock服务提供时间的缓存。如下所示的是应用承载程序和注册Startup类型的定义。为了让依赖注入框架提供的ISystemClock服务是可以被拦截的，我们调用了IServiceCollection接口的&lt;strong&gt;AddSingletonInterceptable&amp;lt;TService, TImplementation&amp;gt;&lt;/strong&gt;扩展方法。由于CacheInterceptor利用.NET Core内存缓存框架来存储方法返回值，所以我们还调用了AddMemoryCache扩展方法注册了相关服务。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        Host.CreateDefaultBuilder()
                .ConfigureWebHostDefaults(buider &lt;/span&gt;=&amp;gt; buider.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
                .Build()
                .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        services
            .AddMemoryCache()
            .AddInterception()
            .AddSingletonInterceptable&lt;/span&gt;&amp;lt;ISystemClock, SystemClock&amp;gt;&lt;span&gt;()
            .AddRouting()
            .AddControllers();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app)
    {
        app
            .UseRouting()
            .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们定义了如下这个HomeController，并在其构造函数中注入了ISystemClock服务。在Action方法Index中，我们利用ISystemClock服务在1秒时间间隔内两次提供当前时间，并将这两个时间呈现在浏览器上。调用ISystemClock的GetCurrentTime方法指定的时间类型（UTC或者Local）是利用查询字符串提供的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ISystemClock _clock;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HomeController(ISystemClock clock)
    {
        _clock &lt;/span&gt;= clock ?? &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArgumentNullException(nameof(clock));
    }

    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{kind?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Index(&lt;span&gt;string&lt;/span&gt; kind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;local&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    {
        DateTimeKind dateTimeKind &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Compare(kind, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;
            ?&lt;span&gt; DateTimeKind.Utc
            : DateTimeKind.Local;

        Response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;ul&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Response.WriteAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;li&amp;gt;{_clock.GetCurrentTime(dateTimeKind)}&amp;lt;/li&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
        }  
        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;/ul&amp;gt;&amp;lt;body&amp;gt;&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行程序后，我们利用浏览器对定义在HomeController中的Action方法Index发起请求。如下图所示，由于缓存的存在，只要指定的时间类型一样，返回的时间就是一样的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191008084141439-555115383.png&quot;&gt;&lt;img width=&quot;517&quot; height=&quot;345&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201910/19327-20191008084141911-1054669895.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在上面的示例演示中，为了让依赖注入框架提供的ISystemClock服务能够被拦截，我们不得不调用自定义的&lt;strong&gt;AddSingletonInterceptable&amp;lt;TService, TImplementation&amp;gt;&lt;/strong&gt;扩展方法扩展方法来注册服务。如果你不喜欢这种方式，我们还提供了另一种解决方案，那就是按照如下的方式调用IHostBuilder的&lt;strong&gt;UseInterceptableServiceProvider&lt;/strong&gt;扩展方法注册我们自定义的&lt;strong&gt;InterceptableServiceProviderFactory&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        Host.CreateDefaultBuilder()
               &lt;strong&gt;&lt;span&gt; .UseInterceptableServiceProvider()&lt;/span&gt;&lt;/strong&gt;
                .ConfigureWebHostDefaults(buider &lt;/span&gt;=&amp;gt; buider.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
                .Build()
                .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一旦我们按照上面的当时完成了针对InterceptableServiceProviderFactory的注册之后，我们将可以将针对ISystemClock服务的注册还原成我们熟悉的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        services
            .AddMemoryCache()
            .AddInterception()
           &lt;/span&gt;&lt;span&gt;&lt;strong&gt; .AddSingleton&lt;/strong&gt;&lt;strong&gt;&amp;lt;ISystemClock, SystemClock&amp;gt;&lt;/strong&gt;&lt;strong&gt;()&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
            .AddRouting()
            .AddControllers();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app)
    {
        app
            .UseRouting()
            .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Dora.Interception提供了扩展点使我们可以实现任意的拦截器注册方式。除了默认提供的针对“特性标注”的方式之外，我们还提供了一种针对策略的注册方式。这里的策略旨在提供这样的表达：将某种类型的拦截器应用到某个类型的某个方法或者属性上。如果我们没有将CacheReturnValueAttribute特性标注到SystemClock的GetCurrentTime方法上，我们可以将承载程序修改成如下的形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        Host.CreateDefaultBuilder()
            &lt;strong&gt;&lt;span&gt;.UseInterceptableServiceProvider(configure: Configure)&lt;/span&gt;&lt;/strong&gt;
            .ConfigureWebHostDefaults(buider &lt;/span&gt;=&amp;gt; buider.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
            .Build()
            .Run();

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(InterceptionBuilder interceptionBuilder)
        {
            interceptionBuilder.AddPolicy(policyBuilder &lt;/span&gt;=&amp;gt;&lt;span&gt; policyBuilder
                .For&lt;/span&gt;&amp;lt;&lt;strong&gt;&lt;span&gt;CacheReturnValueAttribute&lt;/span&gt;&lt;/strong&gt;&amp;gt;(order: &lt;span&gt;1&lt;/span&gt;, cache =&amp;gt;&lt;span&gt; cache
                    .To&lt;/span&gt;&amp;lt;&lt;span&gt;&lt;strong&gt;SystemClock&lt;/strong&gt;&lt;/span&gt;&amp;gt;(target =&amp;gt;&lt;span&gt; target
                        .IncludeMethod(clock &lt;/span&gt;=&amp;gt; clock.&lt;span&gt;&lt;strong&gt;GetCurrentTime&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;default&lt;/span&gt;&lt;span&gt;)))));
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，我们在调用IHostBuilder的UseInterceptableServiceProvider扩展方法的时候指定了一个Action&amp;lt;InterceptionBuilder&amp;gt;对象，它通过调用InterceptionBuilder 对象的AddPolicy扩展方法通过明确的语义将CacheReturnValueAttribute应用到SystemClock的GetCurrentTime方法上。由于不论是指定类型还是方法都是采用“&lt;strong&gt;强类型&lt;/strong&gt;”的方式，所以有效避免了出错的可能性。&lt;/p&gt;

&lt;p&gt;如果希望在不修改现有程序代码的前提下自由的修改拦截策略，我们可以将策略脚本化。在这里我们使用的脚本语言就是C#，所以我们可以将上面提供的策略代码放在一个C#脚本中。比如我们在根目录下创建一个interception.dora文件，并在其中定义如下的策略。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;policyBuilder
    .For&lt;/span&gt;&amp;lt;CacheReturnValueAttribute&amp;gt;(&lt;span&gt;1&lt;/span&gt;, cache =&amp;gt;&lt;span&gt; cache
        .To&lt;/span&gt;&amp;lt;SystemClock&amp;gt;(clock =&amp;gt;&lt;span&gt; clock
            .IncludeMethod(it &lt;/span&gt;=&amp;gt; it.GetCurrentTime(&lt;span&gt;default&lt;/span&gt;))));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了使用这个策略脚本，我们需要对承载程序作相应修改。如下面的代码片段所示，我们同样调用了InterceptionBuilder 的AddPolicy方法，但是这次我们指定的是策略脚本文件名。为了能够识别脚本文件中的类型，我们提供了一个Action&amp;lt;PolicyFileBuilder&amp;gt;对象，并调用PolicyFileBuilder的AddReferences方法添加了程序集引用，调用AddImports方法导入了命名空间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        Host.CreateDefaultBuilder()
            &lt;span&gt;&lt;strong&gt;.UseInterceptableServiceProvider(configure: Configure)&lt;/strong&gt;&lt;/span&gt;
                .ConfigureWebHostDefaults(buider &lt;/span&gt;=&amp;gt; buider.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
                .Build()
                .Run();

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(InterceptionBuilder interceptionBuilder)
        {
            &lt;/span&gt;&lt;span&gt;&lt;strong&gt;interceptionBuilder.AddPolicy(&lt;/strong&gt;&lt;strong&gt;&quot;Interception.dora&quot;, script =&amp;gt; script
                .AddReferences(Assembly.GetExecutingAssembly())
                .AddImports(&quot;App&quot;&lt;/strong&gt;&lt;strong&gt;));&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 08 Oct 2019 00:41:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>.NET Core正式发布之后，我为.NET Core度身定制的AOP框架Dora.Interception也升级到3.0。这个版本除了升级底层类库（.NET Standard 2.1）之外，我还对它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/dora-interception-3-01.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL 的垃圾分类系统 - HT学习笔记</title>
<link>http://www.cnblogs.com/htdaydayup/p/11620061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htdaydayup/p/11620061.html</guid>
<description>&lt;p&gt;垃圾分类，一般是指按一定规定或标准将垃圾分类储存、分类投放和分类搬运，从而转变成公共资源的一系列活动的总称。分类的目的是提高垃圾的资源价值和经济价值，力争物尽其用。垃圾在分类储存阶段属于公众的私有品，垃圾经公众分类投放后成为公众所在小区或社区的区域性准公共资源，垃圾分类搬运到垃圾集中点或转运站后成为没有排除性的公共资源。从国内外各城市对生活垃圾分类的方法来看，大致都是根据垃圾的成分、产生量，结合本地垃圾的资源利用和处理方式来进行分类的。到2019年6月25日，生活垃圾分类制度将入法。一套应用于工业物联网的智能一体化的垃圾分类机械臂将随之而来，由此，我应用 &lt;a href=&quot;http://www.hightopo.com/cn-index.html&quot; target=&quot;_blank&quot;&gt;HT for Web&lt;/a&gt;  的图型化编辑工具打造了一款形象生动的例子：&lt;a href=&quot;http://www.hightopo.com/demo/garbage-classification/&quot; target=&quot;_blank&quot;&gt;Garbage classification&lt;/a&gt;，也借此机会与大家一起分享和学习。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201910/1496396-20191007142121636-79685654.gif&quot; alt=&quot;&quot; width=&quot;812&quot; height=&quot;431&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（注：gif 的上传大小有限，实际效果与还请参考 demo 链接）&lt;/p&gt;
&lt;p&gt;首先，我应用已经精心布置好的 3D 场景，为了有更好的操作体验感，我们要从它的基本设置开始：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
gv.setMovableFunc(() =&amp;gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt; }) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 禁止拖动&lt;/span&gt;
gv.getWireframe = (d) =&amp;gt; { d.s('wf.visible', &lt;span&gt;false&lt;/span&gt;) }  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 隐藏选中边框&lt;/span&gt;
gv.setEye([583, -212, -789]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置眼睛&lt;/span&gt;
gv.setCenter([-76, -654, -133]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置中心点&lt;/span&gt;
gv.setFar(100000) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置远端位置&lt;/span&gt;
gv.setNear(10) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置近端位置&lt;/span&gt;
gv.setInteractors([ &lt;span&gt;new&lt;/span&gt; ht.graph3d.MapInteractor(gv) ]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置交互限制&lt;/span&gt;
gv.setSkyBox(dm.getDataByTag('skyBox')) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置天空球&lt;/span&gt;
window.document.oncontextmenu = () =&amp;gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt; } &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 全局设置右键菜单禁用&lt;/span&gt;
gv.scene = { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 复制初始位置&lt;/span&gt;
&lt;span&gt;    eye: ht.Default.clone(gv.getEye()),
    center: ht.Default.clone(gv.getCenter()),
    far: ht.Default.clone(gv.getFar()),
    near: ht.Default.clone(gv.getNear()),
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我复制了一下整个场景的初始视角情况方便我做稍后的处理，我监听了部分鼠标事件来形成自己的操作风格（比如双击背景还原视角以及双击模型拉近视角）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
gv.mi(e =&amp;gt;&lt;span&gt; {
    let data &lt;/span&gt;=&lt;span&gt; e.data
    let kind &lt;/span&gt;=&lt;span&gt; e.kind
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (kind === 'doubleClickBackground') { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双击背景&lt;/span&gt;
        gv.moveCamera(&lt;span&gt;this&lt;/span&gt;.gv.scene.eye, &lt;span&gt;this&lt;/span&gt;.gv.scene.center, {duration : 1000}) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 恢复视角&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (kind === 'doubleClickData') { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 双击模型&lt;/span&gt;
        gv.flyTo(data, {animation : {duration : 500}, distance : 800}) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拉近视角&lt;/span&gt;
&lt;span&gt;    }
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201910/1496396-20191007142227760-1060023949.gif&quot; alt=&quot;&quot; width=&quot;815&quot; height=&quot;433&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，准备工作做好了，下面来实现动画部分，除了了解 &lt;a href=&quot;https://baike.baidu.com/item/%E5%9E%83%E5%9C%BE%E5%88%86%E7%B1%BB/2904193?fr=aladdin&quot; target=&quot;_blank&quot;&gt;垃圾分类&lt;/a&gt; 的方式外我还参考了网上很多机械臂的视频，学习它的运动模式和动作细节，对每个结构和部位的动画进行步骤的排序和构思。这里我挑选几处动画的实现方式来展示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;85&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mechanicalArmAnim1() {
　　ht.Default.startAnim({
　　　　duration: &lt;/span&gt;1000&lt;span&gt;,
　　　　easing: (t) &lt;/span&gt;=&amp;gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t },
　　　　action: (v, t) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
　　　　　　postbrachium.r3(degrees(&lt;/span&gt;0) + (degrees(20) - degrees(0)) * v, postbrachium.r3()[1], postbrachium.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后臂向下移&lt;/span&gt;
&lt;span&gt;　　　　},
　　　　finishFunc: () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
　　　　　　setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
　　　　　　　　mechanicalArmAnim2()
　　　　　　}, &lt;/span&gt;300&lt;span&gt;)
　　　　}
　　})
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mechanicalArmAnim2() {
　　ht.Default.startAnim({
　　　　duration: &lt;/span&gt;1000&lt;span&gt;,
　　　　easing: (t) &lt;/span&gt;=&amp;gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t },
　　　　action: (v, t) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
　　　　　　postbrachium.p3(&lt;/span&gt;-208 + (-184 + 208) * v, postbrachium.p3()[1], postbrachium.p3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后臂前伸&lt;/span&gt;
　　　　　　hydraulicRod1.r3(degrees(0) + (degrees(8) - degrees(0)) * v, hydraulicRod1.r3()[1], hydraulicRod1.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 液压杆1倾斜&lt;/span&gt;
　　　　　　extensionRod1.r3(degrees(0) + (degrees(8) - degrees(0)) * v, extensionRod1.r3()[1], extensionRod1.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伸长杆1倾斜&lt;/span&gt;
　　　　　　extensionRod1.p3(-169 + (-185 + 169) * v, -516 + (-511 + 516) * v, extensionRod1.p3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伸长杆1伸长&lt;/span&gt;
　　　　　　hydraulicRod2.r3(degrees(0) + (degrees(-8) - degrees(0)) * v, hydraulicRod2.r3()[1], hydraulicRod2.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 液压杆2倾斜&lt;/span&gt;
　　　　　　extensionRod2.r3(degrees(0) + (degrees(-8) - degrees(0)) * v, extensionRod2.r3()[1], extensionRod2.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伸长杆2倾斜&lt;/span&gt;
　　　　　　extensionRod2.p3(-169 + (-185 + 169) * v, -516 + (-511 + 516) * v, extensionRod2.p3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伸长杆2伸长&lt;/span&gt;
&lt;span&gt;　　　　},
　　　　finishFunc: () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
　　　　　　setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
　　　　　　　　mechanicalArmAnim3()
　　　　　　}, &lt;/span&gt;300&lt;span&gt;)
　　　　}
　　})
}
&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; mechanicalArmAnim3() {
　　let oldValue &lt;/span&gt;= antebrachium.r3()[0&lt;span&gt;]
　　ht.Default.startAnim({
　　　　duration: &lt;/span&gt;1000&lt;span&gt;,
　　　　easing: (t) &lt;/span&gt;=&amp;gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; t },
　　　　action: (v, t) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
　　　　　　hydraulicRod1.r3(degrees(&lt;/span&gt;8) + (degrees(7) - degrees(8)) * v, hydraulicRod1.r3()[1], hydraulicRod1.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 液压杆1倾斜&lt;/span&gt;
　　　　　　extensionRod1.r3(degrees(8) + (degrees(7) - degrees(8)) * v, extensionRod1.r3()[1], extensionRod1.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伸长杆1倾斜&lt;/span&gt;
　　　　　　extensionRod1.p3(-185 + (-186 + 185) * v, -511 + (-507 + 511) * v, extensionRod1.p3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伸长杆1伸长&lt;/span&gt;
　　　　　　hydraulicRod2.r3(degrees(-8) + (degrees(-7) - degrees(-8)) * v, hydraulicRod2.r3()[1], hydraulicRod2.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 液压杆2倾斜&lt;/span&gt;
　　　　　　extensionRod2.r3(degrees(-8) + (degrees(-7) - degrees(-8)) * v, extensionRod2.r3()[1], extensionRod2.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伸长杆2倾斜&lt;/span&gt;
　　　　　　extensionRod2.p3(-185 + (-186 + 185) * v, -511 + (-507 + 511) * v, extensionRod2.p3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 伸长杆2伸长&lt;/span&gt;
　　　　　　postbrachium.r3(degrees(20) + (degrees(25) - degrees(20)) * v, postbrachium.r3()[1], postbrachium.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 后臂向下移&lt;/span&gt;
　　　　　　antebrachium.r3(oldValue + (degrees(-40) - oldValue) * v, antebrachium.r3()[1], antebrachium.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前臂向下移&lt;/span&gt;
　　　　　　claw1.r3(degrees(-20) + (degrees(-60) - degrees(-20)) * v, claw1.r3()[1], claw1.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上爪抓取&lt;/span&gt;
　　　　　　claw2.r3(degrees(-60) + (degrees(-30) - degrees(-60)) * v, claw2.r3()[1], claw2.r3()[2]) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下爪抓取&lt;/span&gt;
&lt;span&gt;　　　　},
　　　　finishFunc: () &lt;/span&gt;=&amp;gt;&lt;span&gt; {
　　　　　　mechanicalArmAnim4()
　　　　}
　　})
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201910/1496396-20191007142718584-177708730.gif&quot; alt=&quot;&quot; width=&quot;800&quot; height=&quot;425&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这一段动画是机械臂从初始化状态到向下抓取的一个过程，我将每段动画分成函数来写比较方便后续管理，每一处也代表了一个步骤。这其中最复杂且细微的步骤要数液压杆的运动了，为了让动画看起来更加真实，我除了将手臂单独运动的过程中加入了延时执行下一段动画以体现机器运动的特点外，也把液压杆的部分也做了动画，如果不做处理，那么机械臂在上下移动的时候就会有不科学的效果出现。&lt;a href=&quot;http://www.hightopo.com/guide/guide/core/beginners/ht-beginners-guide.html#ref_animation&quot; target=&quot;_blank&quot;&gt;动画函数&lt;/a&gt; 在这种 demo 中应用的最广，而且里面也包含了一些缓动函数，有兴趣的博友们可以 &lt;a href=&quot;https://hightopo.com/codeeditor/index.html?url=http://www.hightopo.com/guide/guide/core/beginners/examples/example_animation.html&quot; target=&quot;_blank&quot;&gt;点此处&lt;/a&gt; 自己亲自动手玩一玩~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201910/1496396-20191007143357259-223945465.png&quot; alt=&quot;&quot; width=&quot;505&quot; height=&quot;246&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201910/1496396-20191007143404360-207440718.png&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;247&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里面的拾取垃圾步骤还应用了我过去介绍过的 &lt;a href=&quot;https://www.cnblogs.com/htdaydayup/p/9778453.html&quot; target=&quot;_blank&quot;&gt;吸附&lt;/a&gt; 功能，这个方法非常的适合抓取物体的动作，通过 &lt;strong&gt;&lt;span&gt;setHost&lt;/span&gt; &lt;/strong&gt;使&lt;span&gt;节点吸附于宿主，这样就相当于子节点跟随父节点移动，此时只需要对机械臂进行偏移和旋转的操作，垃圾便会随之一起运动了，大大减少了工作量！&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201910/1496396-20191007142549421-479570086.gif&quot; alt=&quot;&quot; width=&quot;786&quot; height=&quot;417&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一部分更酷的属性设置给大家展示一下，可以让 3D 场景整体有更真实的阴影处理效果。&lt;/span&gt;&lt;span&gt;首先我们要注意将无关的节点阴影通过 &lt;span&gt;&lt;strong&gt;node.s('shadow.cast', false)&lt;/strong&gt;&lt;/span&gt; 关闭&lt;/span&gt;，比如编组用的box，背景，地板和面板等。&lt;/p&gt;
&lt;p&gt;最后我们就把阴影的细节做下调整，达到比较好的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
gv.enableShadow(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, {
　　degreeX : &lt;/span&gt;0,       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 投影 x 轴角度&lt;/span&gt;
　　degreeZ : -25,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 投影 z 轴角度&lt;/span&gt;
　　intensity : 0.3,    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阴影强度， 1 为黑色&lt;/span&gt;
　　quality : 'high',  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; low / medium / high / ultra / 4096数值, 质量&lt;/span&gt;
　　type : 'soft',     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; none / hard / soft&lt;/span&gt;
　　radius : 0.2,      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; type 为 hard / soft 时，补充的边缘厚度，用来提供更柔和的边缘&lt;/span&gt;
　　bias : -0.003     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 深度浮点偏差补足&lt;/span&gt;
})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;更多动画 demo 以及工业化领域的文章请继续关注我的博客，感谢大家的支持！&lt;/p&gt;
&lt;p&gt;医疗站（&lt;a href=&quot;https://www.cnblogs.com/htdaydayup/p/11558748.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/htdaydayup/p/11558748.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201909/1496396-20190920135025781-2114795492.gif&quot; alt=&quot;&quot; width=&quot;783&quot; height=&quot;387&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在工业物联网从婴儿走到青年的成熟道路上，一定会有更多的潜力和挑战在等着我们，等待我们去开发，等待我们去创造！相信我们的技术成为国际水准会指日可待！同时在十一国庆后的第一个工作日祝大家精神饱满，工作顺利！&lt;/p&gt;
</description>
<pubDate>Tue, 08 Oct 2019 00:31:00 +0000</pubDate>
<dc:creator>HT学习笔记</dc:creator>
<og:description>前言 垃圾分类，一般是指按一定规定或标准将垃圾分类储存、分类投放和分类搬运，从而转变成公共资源的一系列活动的总称。分类的目的是提高垃圾的资源价值和经济价值，力争物尽其用。垃圾在分类储存阶段属于公众的私</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/htdaydayup/p/11620061.html</dc:identifier>
</item>
<item>
<title>【算法随记五】使用FFT变换自动去除图像中严重的网纹。 - Imageshop</title>
<link>http://www.cnblogs.com/Imageshop/p/11625895.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Imageshop/p/11625895.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　这个课题在很久以前就已经有所接触，不过一直没有用代码去实现过。最近买了一本《机器视觉算法与应用第二版》书，书中再次提到该方法：使用傅里叶变换进行滤波处理的真正好处是可以通过使用定制的滤波器来消除图像中某些特定频率，例如这些特定频率可能代表着图像中重复出现的纹理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在网络上很多的PS教程中，也有提到使用FFT来进行去网纹的操作，其中最为广泛的是使用PS小插件FOURIER TRANSFORM，使用过程为：打开图像--进行FFT RGB操作，然后定位到红色通道，选取通道中除了最中心处的之外的白点区域，然后填充黑色，在返回综合通道，点击IFFT RGB，就OK了， &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005214709115-161039229.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005214807692-953227498.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　　　　　　　　　　　　　　　原图    　　　　　　　　　　　　　　　　　　　　　　　　FFR RGB  频谱图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005214911244-209830604.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005214947097-467360546.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        　　　用于消除与纹理对应的频率的滤波器　　　　　　　　　　　　　　　　     　IFFT RGB处理的结果图　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　针对这一幅，我曾尝试在PS中用其他的方法来去背景纹理，可是一般去网的同时也把相片模糊了，只有FFT去网纹插件能完美去掉相片的网纹而且不损伤画质。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这个插件有个特性，他要求输入必须是3通道或者4通道的图，但是用他处理完成后的图虽然表面上看还是3通道还是4通道的，但是他已经失去了彩色信息了，我们注意到他在进行FFT RGB操作后，RGB三个通道中，R通道保存了频谱图，G通道了保存了相位图，B通道为固定值128，频谱和相位组合在一起，只能回复一个通道的信息，因此处理后的图也只能是一个颜色了，这是这个插件的缺陷或者说作为插件的必然性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　按照这个思路，如果用户提供了用于消除与纹理对应的频率的滤波器，则该过程的一个大概算法流程如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;int&lt;/span&gt; IM_TextureRemoval(unsigned &lt;span&gt;char&lt;/span&gt; *Src, unsigned &lt;span&gt;char&lt;/span&gt; *Mask, unsigned &lt;span&gt;char&lt;/span&gt; *Dest, &lt;span&gt;int&lt;/span&gt; Width, &lt;span&gt;int&lt;/span&gt; Height, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Stride)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Channel = Stride /&lt;span&gt; Width;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Src == NULL) || (Dest == NULL))                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_NULLREFRENCE;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Width &amp;lt;= &lt;span&gt;0&lt;/span&gt;) || (Height &amp;lt;= &lt;span&gt;0&lt;/span&gt;))                            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_INVALIDPARAMETER;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Channel != &lt;span&gt;1&lt;/span&gt;) &amp;amp;&amp;amp; (Channel != &lt;span&gt;3&lt;/span&gt;))                        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_INVALIDPARAMETER;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Channel == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    {
        Complex    &lt;/span&gt;*Data = (Complex*)malloc(Width * Height * &lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(Complex));

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Data == NULL)     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_OUTOFMEMORY;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++&lt;span&gt;)
        {
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *LinePS = Src + Y * Stride;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    填充FFT变换的复数数据&lt;/span&gt;
            Complex *LinePD = Data + Y *&lt;span&gt; Width;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
            {
                LinePD[X].Real &lt;/span&gt;=&lt;span&gt; LinePS[X];
                LinePD[X].Imag &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            }
        }
        IM_FFT2D(Data, Data, Width, Height, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    FFT变换&lt;/span&gt;
        IM_FFTShift(Data, Data, Width, Height);                      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    平移中心到图像的中心    &lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++)                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    FFT变换的结果乘以用于消除与纹理对应的频率的滤波器                    &lt;/span&gt;
&lt;span&gt;        {
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *LinePS = Mask + Y *&lt;span&gt; Stride;
            Complex &lt;/span&gt;*LinePD = Data + Y *&lt;span&gt; Width;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
            {
                LinePD[X].Real &lt;/span&gt;*= LinePS[X] *&lt;span&gt; IM_INV255;
                LinePD[X].Imag &lt;/span&gt;*= LinePS[X] *&lt;span&gt; IM_INV255;
            }
        }
        IM_IFFTShift(Data, Data, Width, Height);                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    在反中心化&lt;/span&gt;
        IM_FFT2D(Data, Data, Width, Height, &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    FFT逆变换&lt;/span&gt;

        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; Y = &lt;span&gt;0&lt;/span&gt;; Y &amp;lt; Height; Y++)                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    转换成图像&lt;/span&gt;
&lt;span&gt;        {
            Complex &lt;/span&gt;*LinePS = Data + Y *&lt;span&gt; Width;
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *LinePD = Dest + Y *&lt;span&gt; Stride;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; X = &lt;span&gt;0&lt;/span&gt;; X &amp;lt; Width; X++&lt;span&gt;)
            {
                LinePD[X] &lt;/span&gt;=&lt;span&gt; IM_ClampToByte(LinePS[X].Real);
            }
        }
        free(Data);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {

    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_OK;

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　这个过程也是非常简单的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于彩色的图像，可以把他们先劈成3个独立的通道，然后调用上述单通道的处理方法，然后在合成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　不过这个方法还是有限制的，他能处理的对象是有非常严重网纹的图像，我们测试过对于普通的身份证照片、摩尔纹等是起不到去除作用的，从频谱上来说，就是要在频谱上能看到分布在四周处有一些很明显的独立的亮点。这些亮点就对应着纹理的频率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面的过程需要人工的参与，我们这里进行一下扩展，尝试下对这类图像进行自动的纹理去除。这里的核心是找到纹理的频率，也就是那些白色独立的亮点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们看上面的FFT频谱图，这种显示基本上都是对直接进行FFT变换后的浮点数据进行对数变换后，在线性映射到0到255范围内的，有进行了log操作，数据压缩了很多，导致频谱图的对比度不是很强，也不利于我们分隔出那些亮点，如果我们不记性这种操作，而是直接绝对值Clamp显示，大概能得到下面的效果： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005214709115-161039229.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005221733803-1582670924.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这种效果的FFT图很明显更有利于纹理特征的提取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　下面的步骤就是：OSTU二值化 -- 》膨胀  --》 腐蚀 -- 》 反色  ---》中心核保留  -- 》中值  得到纹理频率的滤波器。整个效果如下图：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005222354307-1885129133.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005222414911-1452128243.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005222442008-1735962588.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　二值化　　　　　　　　　　　　　　　　　　　　　膨胀（半径2）　　　　　　　　　　　　　　  腐蚀（半径2）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005222502544-642972804.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005222516902-1326482212.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005222548951-167940899.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          　　　　　　反色　　　　　　　　　　　　　　　　　　　　保留中心区域　　　　　　　　　　　　　　  中值（半径1）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　稍微分析下原理吧（也不一定科学）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先二值化，没啥好说的。 二值后，我们看到白色部分有很多零碎的部分，特别是图像的中心区域的零碎化对最后的效果有非常不好的影响（我们必须保持中心部分没啥变化），所以后续使用了开操作来改善效果，先膨胀后腐蚀。 接着我们反色一下，因为后续的滤波器是非中心区域的白色部分是要变为黑色的，第五步，也是比较核心的步骤，我们需要把中心部分的黑色部分变为白色，因为这部分保留着图像的大部分信息， 这里我们可以采用基于4领域的区域生长法，因为在频谱中的中心点，这一点二值后肯定是白色的，在反色后就是白色，就以这一点为种子点，向四周进行区域生长，这样就可以把中心处的黑色反色过来，而其他地方的黑色保持不变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　第五步的中值，或者可以用其他模糊来代替，也是有点必要的，对于有些图像，经过前面的处理后，有些核心的线（垂直或者水平方向）也被标记为黑色的了，正在处理完成的图像中会带来原本没有的新条纹。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005224423740-80453715.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005224512383-1891706773.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　原图　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　频谱图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005224545453-514433583.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005224600173-598833437.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;　　　　　　   　去除中值滤波后的滤波器　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　对应的结果（有瑕疵）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005224654058-1481068192.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005224722792-873634589.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　增加中值后的滤波器　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　对应的结果&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上述过程先关的函数如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    根据频谱图预估纹理的频谱蒙版区域，支持InPlace操作&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; IM_GetTextureMask(unsigned &lt;span&gt;char&lt;/span&gt; *Src, unsigned &lt;span&gt;char&lt;/span&gt; *Dest, &lt;span&gt;int&lt;/span&gt; Width, &lt;span&gt;int&lt;/span&gt; Height, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Stride)
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Channel = Stride /&lt;span&gt; Width;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Src == NULL) || (Dest == NULL))                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_NULLREFRENCE;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((Width &amp;lt;= &lt;span&gt;0&lt;/span&gt;) || (Height &amp;lt;= &lt;span&gt;0&lt;/span&gt;))                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_INVALIDPARAMETER;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Channel != &lt;span&gt;1&lt;/span&gt;)                                    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; IM_STATUS_INVALIDPARAMETER;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Status =&lt;span&gt; IM_STATUS_OK;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *Temp = (unsigned &lt;span&gt;char&lt;/span&gt; *)malloc(Height * Stride * &lt;span&gt;sizeof&lt;/span&gt;(unsigned &lt;span&gt;char&lt;/span&gt;&lt;span&gt;));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Temp == NULL){ Status = IM_STATUS_OUTOFMEMORY;        &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; FreeMemory; }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; Threshold = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    Status &lt;/span&gt;= IM_GetOSTUThreshold(Src, Width, Height, Stride, Threshold);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    使用OSTU方法二值化&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Status != IM_STATUS_OK)        &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; FreeMemory;
    Status &lt;/span&gt;= IM_Threshold(Src, Temp, Width, Height, Stride, Threshold);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    二值化&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Status != IM_STATUS_OK)        &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; FreeMemory;
    Status &lt;/span&gt;= IM_Dilate(Temp, Dest, Width, Height, Stride, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    先膨胀下（最大值），注意膨胀和腐蚀函数不支持InPlace操作&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Status != IM_STATUS_OK)        &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; FreeMemory;
    Status &lt;/span&gt;= IM_Erode(Dest, Temp, Width, Height, Stride, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    然后在腐蚀（最小值），恢复原来的差不多大小，但是这样中心区域不相邻的点就少了很多&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Status != IM_STATUS_OK)        &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; FreeMemory;
    Status &lt;/span&gt;= IM_Invert(Temp, Dest, Width, Height, Stride);                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    这个时候的图，纹理的频谱和其他核心能量区域都还是白色，为后续的处理需要先反色&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Status != IM_STATUS_OK)        &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; FreeMemory;
    Status &lt;/span&gt;= IM_InvertCenter(Dest, Temp, Width, Height, Stride);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    把中心的能量区域保留（白色），其他的纹理的频谱删除（黑色）&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Status != IM_STATUS_OK)        &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; FreeMemory;
    Status &lt;/span&gt;= IM_MedianBlur(Temp, Dest, Width, Height, Stride, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;    执行半径为1的中值，这样可能可以减少部分垂直或者水平的核心能力被删除&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (Status != IM_STATUS_OK)        &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; FreeMemory;

FreeMemory:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Temp !=&lt;span&gt; NULL)    free(Temp);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　我们注意到，上面的操作对纹理处频率处对应的滤波器系数都为0了，也就是这一块的信息全部被消除了，当然实际操作时也可以稍微羽化一下，对最后的结果影响不大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;strong&gt;&lt;span&gt;《任何未通知的转载或转发，都是猪狗不如的作为》。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　根据上述的步骤，有选择性的处理了几幅图，结果如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005225304854-2055227221.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005225255178-103513224.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005225320564-1980289379.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005225355404-1298089781.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005225413162-1944384114.jpg&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005225424725-855450067.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　可以看出，虽然能再一定程度上去除网纹，但是也就有一些去除的不完全，这主要还是因为自动提取的滤波器还是不够准确，要想获取更为理想的结果，必须手动的予以修缮。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于常规的图片，或者说纹理信息不明显的图，及时执行了上面的去纹理，图片也基本上没有什么变化，因为按照上述方法得到的滤波器基本都为白色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　本文算法的测试例程见 : &lt;a href=&quot;http://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&quot; target=&quot;_blank&quot;&gt;http://files.cnblogs.com/files/Imageshop/SSE_Optimization_Demo.rar&lt;/a&gt;，位于菜单FFT--&amp;gt;TextureRemoval下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/349293/201910/349293-20191005230021823-556464841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 08 Oct 2019 00:30:00 +0000</pubDate>
<dc:creator>Imageshop</dc:creator>
<og:description>这个课题在很久以前就已经有所接触，不过一直没有用代码去实现过，最近抽空加以理解并尝试着对这类图像进行自动的处理和优化。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Imageshop/p/11625895.html</dc:identifier>
</item>
<item>
<title>详解Java多线程锁之synchronized - 全菜工程师小辉</title>
<link>http://www.cnblogs.com/mseddl/p/11633405.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mseddl/p/11633405.html</guid>
<description>&lt;p&gt;synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。&lt;/p&gt;

&lt;ol readability=&quot;0&quot;&gt;&lt;li&gt;修饰代码块：被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用于调用对象&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;修饰方法：被修饰的方法称为同步方法，其作用的范围是整个方法，作用于调用对象&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：synchronized修饰方法时必须是显式调用，如果没有显式调用，例如子类重写该方法时没有显式加上synchronized，则不会有加锁效果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;修饰静态方法：其作用的范围是整个静态方法，作用于所有对象&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;修饰类：其作用的范围是synchronized后面括号括起来的部分（例如：test.class），作用于所有对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;对象锁和类锁是否会互相影响么&quot;&gt;对象锁和类锁是否会互相影响么？&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;对象锁：Java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;类锁：对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;类锁和对象锁不是同1个东西，一个是类的Class对象的锁，一个是类的实例的锁。也就是说：1个线程访问静态synchronized的时候，允许另一个线程访问对象的实例synchronized方法。反过来也是成立的，因为他们需要的锁是不同的。&lt;/p&gt;
&lt;p&gt;对应的实验代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Slf4j
public class SynchronizedExample {

    // 修饰一个代码块
    public void test1(int j) {
        synchronized (this) {
            for (int i = 0; i &amp;lt; 10; i++) {
                log.info(&quot;test1 {} - {}&quot;, j, i);
            }
        }
    }

    // 修饰一个方法
    public synchronized void test2(int j) {
        for (int i = 0; i &amp;lt; 10; i++) {
            log.info(&quot;test2 {} - {}&quot;, j, i);
        }
    }

    // 修饰一个类
    public static void test3(int j) {
        synchronized (SynchronizedExample.class) {
            for (int i = 0; i &amp;lt; 10; i++) {
                log.info(&quot;test3 {} - {}&quot;, j, i);
            }
        }
    }

    // 修饰一个静态方法
    public static synchronized void test4(int j) {
        for (int i = 0; i &amp;lt; 10; i++) {
            log.info(&quot;test4 {} - {}&quot;, j, i);
        }
    }

    public static void main(String[] args) {
        SynchronizedExample example1 = new SynchronizedExample();
        SynchronizedExample example2 = new SynchronizedExample();
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.execute(() -&amp;gt; {
            example1.test2(1);
        });
        executorService.execute(() -&amp;gt; {
            example2.test2(2);
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在JDK1.6之前，synchronized一直被称呼为重量级锁（重量级锁就是采用互斥量来控制对资源的访问）。通过反编译成字节码指令可以看到，synchronized会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计算器减1，当计数器为0时，锁就被释放，然后notify通知所有等待的线程。&lt;br/&gt;Java的线程是映射到操作系统的原生线程上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要用户态和内核态切换，大量的状态转换需要耗费很多处理器的时间。&lt;/p&gt;

&lt;p&gt;在JDK1.6中对锁的实现引入了大量的优化：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;锁粗化（Lock Coarsening）：将多个连续的锁扩展成一个范围更大的锁，用以减少频繁互斥同步导致的性能损耗。&lt;/li&gt;
&lt;li&gt;锁消除（Lock Elimination）：JVM即时编译器在运行时，通过逃逸分析，如果判断一段代码中，堆上的所有数据不会逃逸出去从来被其他线程访问到，就可以去除这个锁。&lt;/li&gt;
&lt;li&gt;偏向锁（Biased Locking）：目的是消除数据无竞争情况下的同步原语。使用CAS记录获取它的线程。下一次同一个线程进入则偏向该线程，无需任何同步操作。&lt;/li&gt;
&lt;li&gt;适应性自旋（Adaptive Spinning）：为了避免线程频繁挂起、恢复的状态切换消耗。线程会进入自旋状态。JDK1.6引入了自适应自旋。自旋时间根据之前锁自旋时间和线程状态，动态变化，可以能减少自旋的时间。&lt;/li&gt;
&lt;li&gt;轻量级锁（Lightweight Locking）：在没有多线程竞争的情况下避免重量级互斥锁，只需要依靠一条CAS原子指令就可以完成锁的获取及释放。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在JDK1.6之后，synchronized不再是重量级锁，锁的状态变成以下四种状态：&lt;br/&gt;无锁-&amp;gt;偏向锁-&amp;gt;轻量级锁-&amp;gt;重量级锁&lt;/p&gt;

&lt;h2 id=&quot;自适应自旋锁&quot;&gt;自适应自旋锁&lt;/h2&gt;
&lt;p&gt;大部分时候，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。这项技术就是所谓的自旋锁。&lt;br/&gt;自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有获取到锁，则该线程应该被挂起。在JDK1.6中引入了自适应的自旋锁，自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;所谓自旋，不是获取不到就阻塞，而是在原地等待一会儿，再次尝试（当然次数或者时长有限），他是以牺牲CPU为代价来换取内核状态切换带来的开销。借助于适应性自旋，可以在CPU时间片的损耗和内核状态的切换开销之间相对的找到一个平衡，进而能够提高性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;偏向锁&quot;&gt;偏向锁&lt;/h2&gt;
&lt;p&gt;大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的MarkWord里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下MarkWord中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程，如果失败则进行轻量锁的升级。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201910/1327889-20191008082507650-1252817295.png&quot; alt=&quot;偏向锁&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;轻量级锁&quot;&gt;轻量级锁&lt;/h2&gt;
&lt;p&gt;如果说偏向锁是只允许一个线程获得锁，那么轻量级锁就是允许多个线程获得锁，但是只允许他们顺序拿锁，不允许出现竞争，也就是拿锁失败的情况，轻量级锁的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程1在执行同步代码块之前，JVM会先在当前线程的栈帧中创建一个空间用来存储锁记录，然后再把对象头中的MarkWord复制到该锁记录中，官方称之为DisplacedMarkWord。然后线程尝试使用CAS将对象头中的MarkWord替换为指向锁记录的指针。如果成功，则获得锁，进入步骤3）。如果失败执行步骤2）&lt;/li&gt;
&lt;li&gt;线程自旋，自旋成功则获得锁，进入步骤3）。自旋失败，则膨胀成为重量级锁，并把锁标志位变为10，线程阻塞进入步骤3）&lt;/li&gt;
&lt;li&gt;锁的持有线程执行同步代码，执行完CAS替换MarkWord成功释放锁，如果CAS成功则流程结束，CAS失败执行步骤4）&lt;/li&gt;
&lt;li&gt;CAS执行失败说明期间有线程尝试获得锁并自旋失败，轻量级锁升级为了重量级锁，此时释放锁之后，还要唤醒等待的线程&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201910/1327889-20191008082508738-1517788010.png&quot; alt=&quot;轻量级锁&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;重量级锁&quot;&gt;重量级锁&lt;/h2&gt;
&lt;p&gt;自旋的线程在自旋过程中，成功获得资源(即之前获的资源的线程执行完成并释放了共享资源)，则整个状态依然处于轻量级锁的状态，如果自旋失败则进入重量级锁的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己，需要从用户态切换到内核态实现。（当竞争竞争激烈时，线程直接进入阻塞状态。不过在高版本的JVM中不会立刻进入阻塞状态而是会自旋一小会儿看是否能获取锁如果不能则进入阻塞状态。）&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;可以简单总结是如下场景：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只有一个线程进入加锁区，锁状态是偏向锁&lt;/li&gt;
&lt;li&gt;多个线程交替进入加锁区，锁状态可能是轻量级锁&lt;/li&gt;
&lt;li&gt;多线程同时进入加锁区，锁状态可能是重量级锁&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后，限于笔者经验水平有限，欢迎读者就文中的观点提出宝贵的建议和意见。如果想获得更多的学习资源或者想和更多的技术爱好者一起交流，可以关注我的公众号『全菜工程师小辉』后台回复关键词领取学习资料、进入后端技术交流群和程序员副业群。同时也可以加入程序员副业群Q群：735764906 一起交流。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1327889/201910/1327889-20191008082508998-1775771817.gif&quot; alt=&quot;哎呀，如果我的名片丢了。微信搜索“全菜工程师小辉”，依然可以找到我&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 08 Oct 2019 00:25:00 +0000</pubDate>
<dc:creator>全菜工程师小辉</dc:creator>
<og:description>synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。 synchronized的四种使用方式 1. 修饰代码块：被修饰的代码块称为同步语句块，其作用的范围是大括号</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mseddl/p/11633405.html</dc:identifier>
</item>
</channel>
</rss>