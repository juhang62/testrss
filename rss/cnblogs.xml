<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>AppBoxFuture: 大数据表分区的3种策略 - 白菜园</title>
<link>http://www.cnblogs.com/BaiCai/p/11112112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BaiCai/p/11112112.html</guid>
<description>&lt;p&gt;  之前的文章“分而治之”在介绍大表分区时，作者尚未实现不同的分区策略，即只能按指定的分区键进行分区。这次作者完善了一下分区策略，在规划大表分区时可以按Hash或者时间范围进行分区，所以本篇介绍不同的分区策略适用的场景，同时介绍一下表扫描时如何指定从特定分区查询数据。&lt;/p&gt;

&lt;p&gt;  在新建实体模型时，根据数据是否动态增长以及预估数据规模后确定合适的分区策略，另外根据作者虚拟机的配置单分区的记录数在100万内比较合适：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：实体成员作为分区键时是只读的，实体保存后不能修改分区键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;指定键值分区&quot;&gt;1. 指定键值分区&lt;/h2&gt;
&lt;p&gt;添加分区键时指定某个实体成员作为分区键，适用于：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SaaS类应用按租户进行数据分区；&lt;/li&gt;
&lt;li&gt;基础数据如商品按不同类型进行数据分区；&lt;/li&gt;
&lt;li&gt;动态数据如结算单按不同账期进行数据分区。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201907/4928-20190701083022727-1492748768.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;键值hash分区&quot;&gt;2. 键值Hash分区&lt;/h2&gt;
&lt;p&gt;添加分区键时指定成员并指定Hash数量作为分区键，适用于基础数据需要分区，且分区的总数可以确定在一定范围内。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：Hash分区在查询数据指定分区谓词时只能进行相等判断&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201907/4928-20190701083037295-221341540.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;时间范围分区&quot;&gt;3. 时间范围分区&lt;/h2&gt;
&lt;p&gt;添加分区键时指定时间类型的成员并指定按年、月、日作为分区键，适用于动态增长的数据按时间范围进行分区，最简单的例子是订单按年分区存储。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201907/4928-20190701083053549-1872965698.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;组合分区&quot;&gt;4. 组合分区&lt;/h2&gt;
&lt;p&gt;可以添加多个分区键组合分区，如SaaS应用按租户然后按年进行分区。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201907/4928-20190701083104940-780683030.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  之前实现的TableScan在扫描表数据时，如果是分区表会依次扫描各个分区，这次作者完善了一下TableScan的实现，在明确知道数据在哪个分区或分区范围内时，可以指定分区谓词，从而从指定的表分区内扫描数据。示例代码如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var q = new TableScan&amp;lt;Entities.VehicleState&amp;gt;();
            q.Partitions.Equal(t =&amp;gt; t.VehicleId, 1); //指定分区谓词1
            q.Partitions.Equal(t =&amp;gt; t.CreateTime, new DateTime(2019, 6, 29)); //指定分区谓词2
            return await q.ToListAsync(); //从指定分区扫描数据&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;注意：目前仅实现谓词的相等判断且必须指定全部分区键谓词(即目前只能从确定分区内扫描)，&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=, Between尚未实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  本篇主要介绍了大表分区的策略及其适用场景，Github上的运行时已经更新可测试，如果您有问题或Bug报告，请留言或提交Issue。另外您的关注与点赞将是作者最大的动力，以驱动作者全力以赴完成这个框架。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jul 2019 00:33:00 +0000</pubDate>
<dc:creator>白菜园</dc:creator>
<og:description>  之前的文章“分而治之”在介绍大表分区时，作者尚未实现不同的分区策略，即只能按指定的分区键进行分区。这次作者完善了一下分区策略，在规划大表分区时可以按Hash或者时间范围进行分区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/BaiCai/p/11112112.html</dc:identifier>
</item>
<item>
<title>kubernetes实战篇之创建密钥自动拉取私服镜像 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11112086.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11112086.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11100649.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面我们讲解了如何搭建nexus服务器,以及如何使用nexus搭建docker私有镜像仓库,示例中我们都是手动&lt;code&gt;docker login&lt;/code&gt;登陆私服,然后通过命令拉取镜像然后运行容器.然而这种做法在kubernetes集群中是不可行的.第一,项目规模不同,每天产生的镜像数量也不同,如果每天产生大量仓库都要手动执行&lt;code&gt;docker pull&lt;/code&gt;来拉取,非常麻烦也非常容易出错.第二,集群规模不同,节点数量也不同,少则三五个,多则成百上千甚至更多.我们一台台拉取显然非常麻烦,即便使用ansible脚本批量执行命令也同样存在问题:因为不同的容器分布在不同的节点上.把所有镜像都用批量脚本拉到所有服务器上显然会浪费非常多的资源,并且集群扩容或者缩容器都需要更改脚本,很容易出现错误.这时候我们更倾向使用kubernetes自身的强大管理功能.其实kubernetes可以把docker的登陆信息做成secrets,在容器编排时显式指定要用到的secret,kubernetes就会自动去拉取私服上编排时指定的镜像.大大方便我们自动化的流程.下面我们就讲解如何如何制作docker私仓拉取secrets以及如何在拉取镜像时使用.&lt;/p&gt;
&lt;p&gt;我们在拉取公仓镜像的时候,是不需要输入账户密码的.但是私仓往往都是要登陆以后才能拉取里面的镜像.前面讲解nexus docker私服的时候我们也讲到过,所有操作的前提就是使用&lt;code&gt;docker login -u 用户名 -p 密码 服务器&lt;/code&gt;首先登陆私服.我们登陆过一次后下次再次登陆其实不用指定用户名和密码,比如,我可以使用以下命令直接登陆:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@k8s-node1 ~]# docker login 192.168.124.43:8002
Authenticating with existing credentials...
WARNING! Your password will be stored unencrypted in /root/.docker/config.json.
Configure a credential helper to remove this warning. See
https://docs.docker.com/engine/reference/commandline/login/#credentials-store

Login Succeeded
[root@k8s-node1 ~]#
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到没有指定用户名和密码我们也同样登陆了.实际上,我们首次登陆成功后,docker便把登陆信息存在了&lt;code&gt;~/.docker/config.json&lt;/code&gt;这个文件里,我们可以看一下&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;[root@k8s-node1 ~]# .
{
        &quot;auths&quot;: {
                &quot;192.168.124.43:8002&quot;: {
                        &quot;auth&quot;: &quot;YWRtaW46YWRtaW4xMjM=&quot;
                }
        },
        &quot;HttpHeaders&quot;: {
                &quot;User-Agent&quot;: &quot;Docker-Client/18.09.4 (linux)&quot;
        }
}[root@k8s-node1 ~]#
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;基于现有docker登陆信息创建kubernetes密钥&quot;&gt;基于现有docker登陆信息创建kubernetes密钥&lt;/h2&gt;
&lt;p&gt;命令如下&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create secret generic regcred \
    --from-file=.dockerconfigjson= ~/.docker/config.json \
    --type=kubernetes.io/dockerconfigjson&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法同其它创建kubernetes密钥的方法并没有区别,这里的关键是.docker目录下的config.json文件.&lt;/p&gt;
&lt;p&gt;当然,如果你想对生成出来的secrets有更多的控制,比如指定这个secrets的名称空间,可以使用yml文件来声明式创建.步骤与上面略有不同,如下&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;data字段的名称必须设置为&lt;code&gt;.dockerconfigjson&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对config.json文件进行base64编码,然后把编码后的内容复制到&lt;code&gt;.dockerconfigjson&lt;/code&gt;字段&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类型设置为&lt;code&gt;kubernetes.io/dockerconfigjson&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例:&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Secret
metadata:
  name: myregistrykey
  namespace: awesomeapps
data:
  .dockerconfigjson: UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==
type: kubernetes.io/dockerconfigjson&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用报错解析:&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;error: no objects passed to create&lt;/code&gt;这意味着base64编码信息无效&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;Secret &quot;myregistrykey&quot; is invalid: data[.dockerconfigjson]: invalid value ...&lt;/code&gt; 这意味着base64编码成功,但是不能解码为&lt;code&gt;.docker/config.json&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;直接从命令行创建secret&quot;&gt;直接从命令行创建secret&lt;/h2&gt;
&lt;p&gt;上面是使用docker存储的已经登陆的信息创建的secret,如果没有使用docker登陆,也可以直接通过命令行来创建secret,命令格式如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl create secret docker-registry regcred --docker-server=&amp;lt;your-registry-server&amp;gt; --docker-username=&amp;lt;your-name&amp;gt; --docker-password=&amp;lt;your-pword&amp;gt; --docker-email=&amp;lt;your-email&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面对上面字段做简要描述:&lt;/p&gt;
&lt;p&gt;这里仍然基于前面搭建的nexus docker私仓为例:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl create secret docker-registry regcred --docker-server=192.168.124.43:8002 --docker-username=admin --docker-password=admin123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;便可以创建secret了.&lt;/p&gt;
&lt;h2 id=&quot;查看密钥信息&quot;&gt;查看密钥信息&lt;/h2&gt;
&lt;p&gt;可以使用以下命令查看刚创建的密钥:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl get secret regcred --output=yaml&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master trackingapi]$ kubectl get secret regcred --output=yaml
apiVersion: v1
data:
  .dockerconfigjson: eyJhdXRocyI6eyIxOTIuMTY4LjEyNC40Mzo4MDAyIjp7IlVzZXJuYW1lIjoiYWRtaW4iLCJQYXNzd29yZCI6ImFkbWluMTIzIiwiRW1haWwiOiIifX19
kind: Secret
metadata:
  creationTimestamp: &quot;2019-04-12T05:53:19Z&quot;
  name: regcred
  namespace: default
  resourceVersion: &quot;3763835&quot;
  selfLink: /api/v1/namespaces/default/secrets/regcred
  uid: 46028dd4-5ce7-11e9-bc12-0050568417a2
type: kubernetes.io/dockerconfigjson
[centos@k8s-master trackingapi]$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;.dockerconfigjson&lt;/code&gt;字段为docker的登陆信息,我们可以通过base64解码来查看它:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get secret regcred --output=&quot;jsonpath={.data.\.dockerconfigjson}&quot; | base64 --decode&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master trackingapi]$ kubectl get secret regcred --output=&quot;jsonpath={.data.\.dockerconfigjson}&quot; | base64 --decode
{&quot;auths&quot;:{&quot;192.168.124.43:8002&quot;:{&quot;Username&quot;:&quot;admin&quot;,&quot;Password&quot;:&quot;admin123&quot;,&quot;Email&quot;:&quot;&quot;}}}[centos@k8s-master trackingapi]$
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到以上正信息与我们创建密码时输入的信息吻合&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;注 以上是我们通过命令行生成的,如果是通过config.json生成的则解码后的信息与以上略有不同.通过config.json生成的密钥解码后有 个&lt;code&gt;auth&lt;/code&gt;字段,它仍然是base64编码形式存在的,我们需要再次对其解码才能查看到信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master trackingapi]$ echo &quot;YWRtaW46YWRtaW4xMjM=&quot;|base64 --decode
admin:admin123
[centos@k8s-master trackingapi]$&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建pod使用密钥拉取私仓镜像&quot;&gt;创建pod使用密钥拉取私仓镜像&lt;/h2&gt;
&lt;p&gt;编排文件示例如下:&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;apiVersion: v1
kind: Pod
metadata:
  name: ubuntu-demo
spec:
  restartPolicy: Never
  containers:
  - name: u-demo
    image: 192.168.124.43:8002/ubuntu
    imagePullPolicy: IfNotPresent
    command: [&quot;printenv&quot;]
    args: [&quot;HOSTNAME&quot;]
  imagePullSecrets:
  - name: regcred&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上示例我们使用了预先上传到私服里的一个ubuntu镜像来创建一个pod,由于以上镜像创建完成后马上就结束了.因此我们让打印一个环境变量信息,然后再使用log命令来查看,以证明操作是成功的.&lt;/p&gt;
&lt;p&gt;镜像创建完成以后,我们查看pod的状态&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master trackingapi]$ kubectl get po
NAME                          READY   STATUS      RESTARTS   AGE
busybox                       1/1     Running     552        23d
consul-0                      1/1     Running     2          28h
consul-1                      1/1     Running     3          28h
consul-2                      1/1     Running     2          28h
helloworld-7fdc8d9855-ncfdz   1/1     Running     3          30d
hostaliases-pod               1/1     Running     0          3h42m
ubuntu-demo                   0/1     Completed   0          50m&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到pod已处于完成状态,我们使用&lt;code&gt;kubectl logs&lt;/code&gt;来查看它是否打印了信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master trackingapi]$ kubectl logs ubuntu-demo
ubuntu-demo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到,输出了host的名称.&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jul 2019 00:04:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 前面我们讲解了如何搭建nexus服务器,以及如何使用nexus搭建docker私有镜像仓库,示例中我们都是手动 登陆私服,然后通过命令拉取镜像然后运行容器.然而这种做法在kubernet</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11112086.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core中GetService（）和GetRequiredService（）之间的区别 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/11107648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/11107648.html</guid>
<description>&lt;p&gt;上篇文章《&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/11099358.html&quot;&gt;在.NET Core 3.0中的WPF中使用IOC图文教程&lt;/a&gt;》中，我们尝试在WPF中应用&lt;code&gt;.NET Core&lt;/code&gt;内置的IOC进行编程，在解析&lt;code&gt;MainWindow&lt;/code&gt;的时候我用了&lt;code&gt;GetRequiredService&amp;lt;T&amp;gt;()&lt;/code&gt;方法，当时就在想这个&lt;code&gt;GetRequiredService&amp;lt;T&amp;gt;()&lt;/code&gt;方法跟&lt;code&gt;GetService&amp;lt;T&amp;gt;()&lt;/code&gt;到底有什么区别呢，于是乎，谷歌了一把，就发现了一篇文章来介绍他们区别的，于是乎尝试翻译一把，希望对大家有所帮助。文章最后会给出原文链接，以下就是翻译内容：&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/11107648.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/11107648.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;本文将介绍&lt;em&gt;&lt;code&gt;Microsoft.Extensions.DependencyInjection&lt;/code&gt;&lt;/em&gt;中提供的默认/内置ASP.NET Core DI容器的方法&lt;code&gt;GetService&amp;lt;T&amp;gt;()&lt;/code&gt;和&lt;code&gt;GetRequiredService&amp;lt;T&amp;gt;()&lt;/code&gt;方法。我将描述它们之间的差异以及您应该使用哪种方法。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果服务不存在则&lt;code&gt;GetService()&lt;/code&gt;返回&lt;code&gt;null&lt;/code&gt;，&lt;code&gt;GetRequiredService()&lt;/code&gt;而是抛出异常。如果您正在使用第三方容器，请尽可能使用&lt;code&gt;GetRequiredService&lt;/code&gt;- 如果发生异常，第三方容器可能就会根据异常信息提供相应的诊断信息，以便您可以找出未注册预期服务的&lt;strong&gt;原因&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;容器的核心---iserviceprovider接口&quot;&gt;容器的核心 - IServiceProvider接口&lt;/h2&gt;
&lt;p&gt;ASP.NET Core依赖注入抽象的核心是&lt;code&gt;IServiceProvider&lt;/code&gt;接口。该接口实际上是&lt;code&gt;System&lt;/code&gt;命名空间中基类库的一部分。接口本身很简单：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public interface IServiceProvider
{
    object GetService(Type serviceType);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一旦您使用DI容器（使用&lt;code&gt;IServiceCollection&lt;/code&gt;）注册了所有类，几乎所有DI容器&lt;em&gt;需要&lt;/em&gt;做的就是允许您使用&lt;code&gt;GetService()&lt;/code&gt;查找对象的实例。&lt;/p&gt;
&lt;p&gt;当然，您通常根本不应该直接在代码中使用&lt;code&gt;IServiceProvider&lt;/code&gt;。相反，您应该使用标准的构造函数注入，并让&lt;em&gt;框架&lt;/em&gt;来承载并在幕后使用&lt;code&gt;IServiceProvider&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;4.8591549295775&quot;&gt;
&lt;p&gt;直接使用&lt;code&gt;IServiceProvider&lt;/code&gt;是服务定位器模式的一个示例。这&lt;a href=&quot;http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/&quot;&gt;通常被认为是反模式&lt;/a&gt;，因为它隐藏了类的依赖关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然而，有些时候你没有选择的余地。例如，如果您试图&lt;a href=&quot;https://andrewlock.net/injecting-services-into-validationattributes-in-asp-net-core/&quot;&gt;将服务注入到属性&lt;/a&gt;，或者&lt;a href=&quot;http://disq.us/p/1cedzyz&quot;&gt;在配置DI容器时使用“转发”类型&lt;/a&gt;，则需要直接使用&lt;code&gt;IServiceProvider&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;比较getservice-和getrequiredservice&quot;&gt;比较GetService （）和GetRequiredService （）&lt;/h2&gt;
&lt;p&gt;鉴于我们不再使用.NET 1.0，如果你想从&lt;code&gt;IServiceProvider&lt;/code&gt;中检索服务，你可能使用了通用的泛型&lt;code&gt;GetService&amp;lt;T&amp;gt;()&lt;/code&gt;扩展方法，而不是&lt;code&gt;GetService(Type)&lt;/code&gt;接口方法。但是你可能也注意到了类似的&lt;code&gt;GetRequiredService&amp;lt;T&amp;gt;()&lt;/code&gt;扩展方法 - 问题是，它们之间有什么区别呢，您应该使用哪种方法？&lt;/p&gt;
&lt;p&gt;在我们研究任何代码之前，让我们先讨论一下这些方法的预期行为。首先，从&lt;code&gt;GetService()&lt;/code&gt;方法的文档开始：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;GetService()&lt;/code&gt;返回一个&lt;code&gt;serviceType&lt;/code&gt;类型的服务对象。如果返回的是一个没有类型的服务对象&lt;code&gt;serviceType&lt;/code&gt;则返回&lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;与&lt;code&gt;GetRequiredService()&lt;/code&gt;的文档内容进行对比：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;GetRequiredService()&lt;/code&gt;返回一个&lt;code&gt;serviceType&lt;/code&gt;类型的服务对象。如果没有&lt;code&gt;serviceType&lt;/code&gt;类型的服务，则抛出一个&lt;code&gt;InvalidOperationException&lt;/code&gt;异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，当请求的实例&lt;code&gt;serviceType&lt;/code&gt;可用时，两种方法的行为都相同。不同之处在于&lt;code&gt;serviceType&lt;/code&gt;未注册时的行为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;GetService&lt;/code&gt;- 如果服务未注册，则返回&lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetRequiredService&lt;/code&gt;- 如果服务未注册，则抛出一个&lt;code&gt;Exception&lt;/code&gt;异常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在我们已经清楚了，让我们看看一些代码。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.nuget.org/packages/Microsoft.Extensions.DependencyInjection.Abstractions&quot;&gt;&lt;code&gt;ServiceProviderServiceExtensions&lt;/code&gt;班上&lt;em&gt;Microsoft.Extensions.DependencyInjection.Abstractions&lt;/em&gt;库中&lt;/a&gt;同时实现了通用版&lt;code&gt;GetService&amp;lt;T&amp;gt;()&lt;/code&gt;和&lt;code&gt;GetRequiredService&amp;lt;T&amp;gt;()&lt;/code&gt;方法，如下所示：&lt;/p&gt;
&lt;blockquote readability=&quot;4.992&quot;&gt;
&lt;p&gt;我已经从本文的代码中删除了一些前提条件检查; 如果你想看到完整的代码，&lt;a href=&quot;https://github.com/aspnet/DependencyInjection/blob/94b9cc9ace032f838e068702cc70ce57cc883bc7/src/DI.Abstractions/ServiceProviderServiceExtensions.cs&quot;&gt;请在GitHub上查看&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class ServiceProviderServiceExtensions
{
    public static T GetService&amp;lt;T&amp;gt;(this IServiceProvider provider)
    {
        return (T)provider.GetService(typeof(T));
    }

    public static T GetRequiredService&amp;lt;T&amp;gt;(this IServiceProvider provider)
    {
        return (T)provider.GetRequiredService(typeof(T));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种方法实际上都是相同的 - 通用扩展方法委托给非泛型版本的&lt;code&gt;GetService()&lt;/code&gt;和&lt;code&gt;GetRequiredService()&lt;/code&gt;。它们只是一种便利，因此您在自己的代码中不需要使用更多的&lt;code&gt;typeof()&lt;/code&gt;和类型转换。&lt;/p&gt;
&lt;p&gt;非泛型版本的&lt;code&gt;GetService()&lt;/code&gt;是&lt;code&gt;IServiceProvider&lt;/code&gt;接口的一部分，但非泛型&lt;code&gt;GetRequiredService()&lt;/code&gt;实现是同一类中的扩展方法：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static class ServiceProviderServiceExtensions
{
    public static object GetRequiredService(this IServiceProvider provider, Type serviceType)
    {
        var requiredServiceSupportingProvider = provider as ISupportRequiredService;
        if (requiredServiceSupportingProvider != null)
        {
            return requiredServiceSupportingProvider.GetRequiredService(serviceType);
        }

        var service = provider.GetService(serviceType);
        if (service == null)
        {
            throw new InvalidOperationException(Resources.FormatNoServiceRegistered(serviceType));
        }

        return service;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法的第一步是检查提供的&lt;code&gt;IServiceProvider&lt;/code&gt; 是否&lt;em&gt;也&lt;/em&gt;实现了&lt;code&gt;ISupportRequiredService&lt;/code&gt;。此接口提供底层的非泛型&lt;code&gt;GetRequiredService&lt;/code&gt;实现，因此如果服务提供者实现它，&lt;code&gt;GetRequiredService()&lt;/code&gt;则可以直接调用。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ASP.NET Core内置的DI容器&lt;strong&gt;并没有&lt;/strong&gt;实现&lt;code&gt;ISupportRequiredService&lt;/code&gt;- 只有第三方容器实现了&lt;code&gt;GetRequiredService()&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果&lt;code&gt;IServiceProvider&lt;/code&gt;没有实现&lt;code&gt;ISupportRequiredService&lt;/code&gt;，则执行所需的异常抛出行为，如您所料：&lt;code&gt;GetService()&lt;/code&gt;调用，如果返回&lt;code&gt;null&lt;/code&gt;则抛出异常。&lt;/p&gt;
&lt;h2 id=&quot;那你应该使用哪种方法&quot;&gt;那你应该使用哪种方法？&lt;/h2&gt;
&lt;p&gt;正如我之前所说，理想情况下，两者都可以！&lt;/p&gt;
&lt;p&gt;在您自己的代码使用&lt;code&gt;ISeviceProvider&lt;/code&gt;通常是你正在使用&lt;a href=&quot;http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/&quot;&gt;服务定位器反模式&lt;/a&gt;的一个标志，所以一般应避免使用&lt;code&gt;ISeviceProvider&lt;/code&gt;。但是，如果由于设计限制而需要（例如，&lt;a href=&quot;https://andrewlock.net/injecting-services-into-validationattributes-in-asp-net-core/&quot;&gt;您不能在属性中使用DI&lt;/a&gt;），或者&lt;a href=&quot;http://disq.us/p/1cedzyz&quot;&gt;作为DI容器配置本身的一部分&lt;/a&gt;的情况下，您应该使用哪一种呢？&lt;/p&gt;
&lt;p&gt;基于&lt;a href=&quot;https://github.com/aspnet/DependencyInjection/issues/378&quot;&gt;GitHub&lt;/a&gt;中要求添加&lt;code&gt;GetRequiredService()&lt;/code&gt;&lt;a href=&quot;https://github.com/aspnet/DependencyInjection/issues/378&quot;&gt;的原始问题&lt;/a&gt;，以及&lt;a href=&quot;https://jeremydmiller.com/&quot;&gt;Jeremy D. Miller&lt;/a&gt;&lt;a href=&quot;https://github.com/aspnet/DependencyInjection/issues/238&quot;&gt;先前提出的问题&lt;/a&gt; ，我认为几乎所有情况下的规则是：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;GetRequiredService()&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;减少重复&lt;/em&gt;。如果服务不可用，则使用&lt;code&gt;GetRequiredService()&lt;/code&gt;会立即抛出异常。如果您使用&lt;code&gt;GetService()&lt;/code&gt;，那么您需要在调用代码中检查是否为&lt;code&gt;null&lt;/code&gt;，并且通常需要抛出异常。那个空检查代码需要在任何地方重复。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;失败很快&lt;/em&gt;。如果您在使用&lt;code&gt;GetService()&lt;/code&gt;时忘记检查是否为&lt;code&gt;null&lt;/code&gt;，那么稍后您的程序可能会以&lt;code&gt;NullReferenceException&lt;/code&gt;结束。找出导致异常的原因总是比显式的告诉你的&lt;code&gt;InvalidOperationException&lt;/code&gt;更困难，需要做更多的工作。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;允许对第三方容器进行高级诊断&lt;/em&gt;。StructureMap和其他一些第三方容器的一大好处是，它们能够提供详细的异常消息，&lt;em&gt;说明为什么&lt;/em&gt;找不到服务。如果您正在使用&lt;code&gt;GetRequiredService()&lt;/code&gt;，则第三方容器本身会生成异常，因此可以提供其他特定于容器的信息。只返回&lt;code&gt;null&lt;/code&gt;（带&lt;code&gt;GetService()&lt;/code&gt;）不会给你进一步的详细的信息。&lt;a href=&quot;https://github.com/aspnet/DependencyInjection/issues/378&quot;&gt;这是引入&lt;code&gt;GetRequiredService()&lt;/code&gt;的主要原因&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，我已经看到了一些反对GetRequiredService()`的观点，但我认为其中任何一个都不会受到审查：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;“我没有使用第三方容器”&lt;/em&gt;。如果您正在使用内置容器（未实现&lt;code&gt;ISupportRequiredService&lt;/code&gt;），那么您将无法通过使用任何其他诊断获益&lt;code&gt;GetRequiredService()&lt;/code&gt;。但是，我认为前两个优势仍然存在，并使&lt;code&gt;GetRequiredService&lt;/code&gt;值得使用。此外，如果您以后添加第三方容器，您已经在使用最佳实践了。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;“我有可选服务，有时只在DI容器中注册。”&lt;/em&gt; 。这可能是使用&lt;code&gt;GetService()&lt;/code&gt;唯一有效的理由。如果您的代码只有在注册了给定服务时才能运行，那么您可能需要使用&lt;code&gt;GetService()&lt;/code&gt;。但是，如果&lt;code&gt;GetService()&lt;/code&gt;返回NULL，我也看到它在使用回退服务时使用。在我看来，这很少是&lt;em&gt;应用程序&lt;/em&gt;代码的好模式。回退的编排应该是DI容器配置的一部分，而不是使用服务的位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以,现在你有了 - &lt;code&gt;GetService()&lt;/code&gt;与&lt;code&gt;GetRequiredService()&lt;/code&gt;之间的对比了。在我进一步挖掘它之前，当我选择一个而不是另一个时，我有点武断，但现在我会确保我总是理所当然的使用&lt;code&gt;GetRequiredService()&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GetService()&lt;/code&gt;是&lt;code&gt;IServiceProvider&lt;/code&gt;上的唯一方法，&lt;code&gt;ISeviceProvider&lt;/code&gt;是ASP.NET核心DI抽象中的中央接口。第三方容器还可以实现可选接口&lt;code&gt;ISupportRequiredService&lt;/code&gt;，该接口提供&lt;code&gt;GetRequiredService()&lt;/code&gt;方法。当请求的类型&lt;code&gt;serviceType&lt;/code&gt;可用时，这些方法的行为相同。如果服务不可用（即它没有注册），则&lt;code&gt;GetService()&lt;/code&gt;返回&lt;code&gt;null&lt;/code&gt;，而&lt;code&gt;GetRequiredService()&lt;/code&gt;抛出一个&lt;code&gt;InvalidOperationException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GetRequiredService()&lt;/code&gt;相对于&lt;code&gt;GetService()&lt;/code&gt;的主要好处是当服务不可用时，它允许第三方容器提供额外的诊断信息。因此，在使用第三方容器时最好使用&lt;code&gt;GetRequiredService()&lt;/code&gt;。就个人而言，我会在任何地方使用它，即使我只使用内置的DI容器。&lt;/p&gt;
&lt;p&gt;原英文链接：&lt;a href=&quot;https://andrewlock.net/the-difference-between-getservice-and-getrquiredservice-in-asp-net-core/&quot; class=&quot;uri&quot;&gt;https://andrewlock.net/the-difference-between-getservice-and-getrquiredservice-in-asp-net-core/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Jun 2019 23:53:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>上篇文章《 '在.NET Core 3.0中的WPF中使用IOC图文教程' 》中，我们尝试在WPF中应用 内置的IOC进行编程，在解析 的时候我用了 方法，当时就在想这个 方法跟 到底有什么区别呢，于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yilezhu/p/11107648.html</dc:identifier>
</item>
<item>
<title>ZooKeeper 系列（二）—— Zookeeper单机环境和集群环境搭建 - 单人影</title>
<link>http://www.cnblogs.com/danrenying/p/11112070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/danrenying/p/11112070.html</guid>
<description>&lt;nav&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#一单机环境搭建&quot;&gt;一、单机环境搭建&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#11-下载&quot;&gt;1.1 下载&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#12-解压&quot;&gt;1.2 解压&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#13-配置环境变量&quot;&gt;1.3 配置环境变量&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#14-修改配置&quot;&gt;1.4 修改配置&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#15-启动&quot;&gt;1.5 启动&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#16-验证&quot;&gt;1.6 验证&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#二集群环境搭建&quot;&gt;二、集群环境搭建&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#21-修改配置&quot;&gt;2.1 修改配置&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#22-标识节点&quot;&gt;2.2 标识节点&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#23-启动集群&quot;&gt;2.3 启动集群&lt;/a&gt;&lt;br/&gt;        &lt;a href=&quot;https://www.cnblogs.com/danrenying/p/11112070.html#24-集群验证&quot;&gt;2.4 集群验证&lt;/a&gt;&lt;br/&gt;&lt;/nav&gt;&lt;h2 id=&quot;一单机环境搭建&quot;&gt;一、单机环境搭建&lt;/h2&gt;
&lt;h3 id=&quot;下载&quot;&gt;1.1 下载&lt;/h3&gt;
&lt;p&gt;下载对应版本Zookeeper，这里我下载的版本&lt;code&gt;3.4.14&lt;/code&gt;。官方下载地址：https://archive.apache.org/dist/zookeeper/&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# wget https://archive.apache.org/dist/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解压&quot;&gt;1.2 解压&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# tar -zxvf zookeeper-3.4.14.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置环境变量&quot;&gt;1.3 配置环境变量&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# vim /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加环境变量：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;export ZOOKEEPER_HOME=/usr/app/zookeeper-3.4.14
export PATH=$ZOOKEEPER_HOME/bin:$PATH&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使得配置的环境变量生效：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# source /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改配置&quot;&gt;1.4 修改配置&lt;/h3&gt;
&lt;p&gt;进入安装目录的&lt;code&gt;conf/&lt;/code&gt;目录下，拷贝配置样本并进行修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cp zoo_sample.cfg  zoo.cfg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指定数据存储目录和日志文件目录（目录不用预先创建，程序会自动创建），修改后完整配置如下：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial
# synchronization phase can take
initLimit=10
# The number of ticks that can pass between
# sending a request and getting an acknowledgement
syncLimit=5
# the directory where the snapshot is stored.
# do not use /tmp for storage, /tmp here is just
# example sakes.
dataDir=/usr/local/zookeeper/data
dataLogDir=/usr/local/zookeeper/log
# the port at which the clients will connect
clientPort=2181
# the maximum number of client connections.
# increase this if you need to handle more clients
#maxClientCnxns=60
#
# Be sure to read the maintenance section of the
# administrator guide before turning on autopurge.
#
# http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance
#
# The number of snapshots to retain in dataDir
#autopurge.snapRetainCount=3
# Purge task interval in hours
# Set to &quot;0&quot; to disable auto purge feature
#autopurge.purgeInterval=1&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;配置参数说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;tickTime&lt;/strong&gt;：用于计算的基础时间单元。比如session超时：N*tickTime；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;initLimit&lt;/strong&gt;：用于集群，允许从节点连接并同步到 master节点的初始化连接时间，以tickTime的倍数来表示；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;syncLimit&lt;/strong&gt;：用于集群， master主节点与从节点之间发送消息，请求和应答时间长度（心跳机制）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dataDir&lt;/strong&gt;：数据存储位置；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dataLogDir&lt;/strong&gt;：日志目录；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;clientPort&lt;/strong&gt;：用于客户端连接的端口，默认2181&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;启动&quot;&gt;1.5 启动&lt;/h3&gt;
&lt;p&gt;由于已经配置过环境变量，直接使用下面命令启动即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;zkServer.sh start&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;验证&quot;&gt;1.6 验证&lt;/h3&gt;
&lt;p&gt;使用JPS验证进程是否已经启动，出现&lt;code&gt;QuorumPeerMain&lt;/code&gt;则代表启动成功。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@hadoop001 bin]# jps
3814 QuorumPeerMain&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二集群环境搭建&quot;&gt;二、集群环境搭建&lt;/h2&gt;
&lt;p&gt;为保证集群高可用，Zookeeper集群的节点数最好是奇数，最少有三个节点，所以这里演示搭建一个三个节点的集群。这里我使用三台主机进行搭建，主机名分别为hadoop001，hadoop002，hadoop003。&lt;/p&gt;
&lt;h3 id=&quot;修改配置-1&quot;&gt;2.1 修改配置&lt;/h3&gt;
&lt;p&gt;解压一份zookeeper安装包，修改其配置文件&lt;code&gt;zoo.cfg&lt;/code&gt;，内容如下。之后使用scp命令将安装包分发到三台服务器上：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;tickTime=2000
initLimit=10
syncLimit=5
dataDir=/usr/local/zookeeper-cluster/data/
dataLogDir=/usr/local/zookeeper-cluster/log/
clientPort=2181

# server.1 这个1是服务器的标识，可以是任意有效数字，标识这是第几个服务器节点，这个标识要写到dataDir目录下面myid文件里
# 指名集群间通讯端口和选举端口
server.1=hadoop001:2287:3387
server.2=hadoop002:2287:3387
server.3=hadoop003:2287:3387&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;标识节点&quot;&gt;2.2 标识节点&lt;/h3&gt;
&lt;p&gt;分别在三台主机的&lt;code&gt;dataDir&lt;/code&gt;目录下新建&lt;code&gt;myid&lt;/code&gt;文件,并写入对应的节点标识。Zookeeper集群通过&lt;code&gt;myid&lt;/code&gt;文件识别集群节点，并通过上文配置的节点通信端口和选举端口来进行节点通信，选举出Leader节点。&lt;/p&gt;
&lt;p&gt;创建存储目录：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 三台主机均执行该命令
mkdir -vp  /usr/local/zookeeper-cluster/data/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建并写入节点标识到&lt;code&gt;myid&lt;/code&gt;文件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# hadoop001主机
echo &quot;1&quot; &amp;gt; /usr/local/zookeeper-cluster/data/myid
# hadoop002主机
echo &quot;2&quot; &amp;gt; /usr/local/zookeeper-cluster/data/myid
# hadoop003主机
echo &quot;3&quot; &amp;gt; /usr/local/zookeeper-cluster/data/myid&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动集群&quot;&gt;2.3 启动集群&lt;/h3&gt;
&lt;p&gt;分别在三台主机上，执行如下命令启动服务：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;/usr/app/zookeeper-cluster/zookeeper/bin/zkServer.sh start&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集群验证&quot;&gt;2.4 集群验证&lt;/h3&gt;
&lt;p&gt;启动后使用&lt;code&gt;zkServer.sh status&lt;/code&gt;查看集群各个节点状态。如图所示：三个节点进程均启动成功，并且hadoop002为leader节点，hadoop001和hadoop003为follower节点。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures//zookeeper-hadoop001.png&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures//zookeeper-hadoop002.png&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures//zookeeper-hadoop003.png&quot;/&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;3.8333333333333&quot;&gt;
&lt;p&gt;更多大数据系列文章可以参见个人 GitHub 开源项目： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;大数据入门指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 30 Jun 2019 23:40:00 +0000</pubDate>
<dc:creator>单人影</dc:creator>
<og:description>一、单机环境搭建         1.1 下载       </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/danrenying/p/11112070.html</dc:identifier>
</item>
<item>
<title>机器学习经典算法之KNN - 程序员姜小白</title>
<link>http://www.cnblogs.com/jpcflyer/p/11111817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jpcflyer/p/11111817.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、前言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KNN 的英文叫 K-Nearest Neighbor，应该算是数据挖掘算法中最简单的一种。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先用一个例子体会下。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;/*请尊重作者劳动成果，转载请标明原文链接：*/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;/* https://www.cnblogs.com/jpcflyer/p/11111817.html * /&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;假设，我们想对电影的类型进行分类，统计了电影中打斗次数、接吻次数，当然还有其他的指标也可以被统计到，如下表所示。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/6d/87/6dac3a9961e69aa86d80de32bdc00987.png&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;190&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们很容易理解《战狼》《红海行动》《碟中谍 6》是动作片，《前任 3》《春娇救志明》《泰坦尼克号》是爱情片，但是有没有一种方法让机器也可以掌握这个分类的规则，当有一部新电影的时候，也可以对它的类型自动分类呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以把打斗次数看成 X 轴，接吻次数看成 Y 轴，然后在二维的坐标轴上，对这几部电影进行标记，如下图所示。对于未知的电影 A，坐标为 (x,y)，我们需要看下离电影 A 最近的都有哪些电影，这些电影中的大多数属于哪个分类，那么电影 A 就属于哪个分类。实际操作中，我们还需要确定一个 K 值，也就是我们要观察离电影 A 最近的电影有多少个。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/fa/cc/fa0aa02dae219b21de5984371950c3cc.png&quot; alt=&quot;&quot; width=&quot;471&quot; height=&quot;271&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、KNN 的工作原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“近朱者赤，近墨者黑”可以说是 KNN 的工作原理。整个计算过程分为三步：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 计算待分类物体与其他物体之间的距离；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 统计距离最近的 K 个邻居；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.对于 K 个最近的邻居，它们属于哪个分类最多，待分类物体就属于哪一类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;K 值如何选择&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你能看出整个 KNN 的分类过程，K 值的选择还是很重要的。那么问题来了，K 值选择多少是适合的呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果 K 值比较小，就相当于未分类物体与它的邻居非常接近才行。这样产生的一个问题就是，如果邻居点是个噪声点，那么未分类物体的分类也会产生误差，这样 KNN 分类就会产生过拟合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果 K 值比较大，相当于距离过远的点也会对未知物体的分类产生影响，虽然这种情况的好处是鲁棒性强，但是不足也很明显，会产生欠拟合情况，也就是没有把未分类物体真正分类出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以 K 值应该是个实践出来的结果，并不是我们事先而定的。在工程上，我们一般采用交叉验证的方式选取 K 值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;交叉验证的思路就是，把样本集中的大部分样本作为训练集，剩余的小部分样本用于预测，来验证分类模型的准确性。所以在 KNN 算法中，我们一般会把 K 值选取在较小的范围内，同时在验证集上准确率最高的那一个最终确定作为 K 值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;距离如何计算&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 KNN 算法中，还有一个重要的计算就是关于距离的度量。两个样本点之间的距离代表了这两个样本之间的相似度。距离越大，差异性越大；距离越小，相似度越大。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于距离的计算方式有下面五种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;欧氏距离；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;曼哈顿距离；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;闵可夫斯基距离；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;切比雪夫距离；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;余弦距离。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中前三种距离是 KNN 中最常用的距离，现在分别讲解下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;欧氏距离&lt;/strong&gt;是我们最常用的距离公式，也叫做欧几里得距离。在二维空间中，两点的欧式距离就是：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/f8/80/f8d4fe58ec9580a4ffad5cee263b1b80.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;同理，我们也可以求得两点在 n 维空间中的距离：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/40/6a/40efe7cb4a2571e55438b55f8d37366a.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;曼哈顿距离&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在几何空间中用的比较多。曼哈顿距离等于两个点在坐标系上绝对轴距总和。用公式表示就是：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/bd/aa/bda520e8ee34ea19df8dbad3da85faaa.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;闵可夫斯基距离&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不是一个距离，而是一组距离的定义。对于 n 维空间中的两个点 x(x1,x2,…,xn) 和 y(y1,y2,…,yn) ， x 和 y 两点之间的闵可夫斯基距离为：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/4d/c5/4d614c3d6722c02e4ea03cb1e6653dc5.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;其中 p 代表空间的维数，当 p=1 时，就是曼哈顿距离；当 p=2 时，就是欧氏距离；当 p→∞时，就是切比雪夫距离。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么切比雪夫距离 怎么计算呢？二个点之间的切比雪夫距离就是这两个点坐标数值差的绝对值的最大值，用数学表示就是：max(|x1-y1|,|x2-y2|)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;余弦距离 实际上计算的是两个向量的夹角，是在方向上计算两者之间的差异，对绝对数值不敏感。在兴趣相关性比较上，角度关系比距离的绝对值更重要，因此余弦距离可以用于衡量用户对内容兴趣的区分度。比如我们用搜索引擎搜索某个关键词，它还会给你推荐其他的相关搜索，这些推荐的关键词就是采用余弦距离计算得出的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;KD 树&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实从上文你也能看出来，KNN 的计算过程是大量计算样本点之间的距离。为了减少计算距离次数，提升 KNN 的搜索效率，人们提出了 KD 树（K-Dimensional 的缩写）。KD 树是对数据点在 K 维空间中划分的一种数据结构。在 KD 树的构造中，每个节点都是 k 维数值点的二叉树。既然是二叉树，就可以采用二叉树的增删改查操作，这样就大大提升了搜索效率。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里，我们不需要对 KD 树的数学原理了解太多，你只需要知道它是一个二叉树的数据结构，方便存储 K 维空间的数据就可以了。而且在 sklearn 中，我们直接可以调用 KD 树，很方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;用 KNN 做回归&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KNN 不仅可以做分类，还可以做回归。首先讲下什么是回归。在开头电影这个案例中，如果想要对未知电影进行类型划分，这是一个分类问题。首先看一下要分类的未知电影，离它最近的 K 部电影大多数属于哪个分类，这部电影就属于哪个分类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是一部新电影，已知它是爱情片，想要知道它的打斗次数、接吻次数可能是多少，这就是一个回归问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么 KNN 如何做回归呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个新点，我们需要找出这个点的 K 个最近邻居，然后将这些邻居的属性的平均值赋给该点，就可以得到该点的属性。当然不同邻居的影响力权重可以设置成不同的。举个例子，比如一部电影 A，已知它是动作片，当 K=3 时，最近的 3 部电影是《战狼》，《红海行动》和《碟中谍 6》，那么它的打斗次数和接吻次数的预估值分别为 (100+95+105)/3=100 次、(5+3+31)/3=13 次。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、 如何在 sklearn 中使用 KNN&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下来，我们先看下如何在 sklearn 中使用 KNN 算法，然后通过 sklearn 中自带的手写数字数据集来进行实战。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在 Python 的 sklearn 工具包中有 KNN 算法。KNN 既可以做分类器，也可以做回归。如果是做分类，你需要引用：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.neighbors &lt;span&gt;import&lt;/span&gt; KNeighborsClassifier
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果是做回归，你需要引用：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.neighbors &lt;span&gt;import&lt;/span&gt; KNeighborsRegressor
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;从名字上你也能看出来 Classifier 对应的是分类，Regressor 对应的是回归。一般来说如果一个算法有 Classifier 类，都能找到相应的 Regressor 类。比如在决策树分类中，你可以使用 DecisionTreeClassifier，也可以使用决策树来做回归 DecisionTreeRegressor。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，我们看下如何在 sklearn 中创建 KNN 分类器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里，我们使用构造函数 KNeighborsClassifier(n_neighbors=5, weights=‘uniform’, algorithm=‘auto’, leaf_size=30)，这里有几个比较主要的参数，我分别来讲解下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.n_neighbors：即 KNN 中的 K 值，代表的是邻居的数量。K 值如果比较小，会造成过拟合。如果 K 值比较大，无法将未知物体分类出来。一般我们使用默认值 5。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.weights：是用来确定邻居的权重，有三种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;weights=uniform，代表所有邻居的权重相同；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;weights=distance，代表权重是距离的倒数，即与距离成反比；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自定义函数，你可以自定义不同距离所对应的权重。大部分情况下不需要自己定义函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.algorithm：用来规定计算邻居的方法，它有四种方式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;algorithm=auto，根据数据的情况自动选择适合的算法，默认情况选择 auto；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;algorithm=kd_tree，也叫作 KD 树，是多维空间的数据结构，方便对关键数据进行检索，不过 KD 树适用于维度少的情况，一般维数不超过 20，如果维数大于 20 之后，效率反而会下降；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;algorithm=ball_tree，也叫作球树，它和 KD 树一样都是多维空间的数据结果，不同于 KD 树，球树更适用于维度大的情况；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;algorithm=brute，也叫作暴力搜索，它和 KD 树不同的地方是在于采用的是线性扫描，而不是通过构造树结构进行快速检索。当训练集大的时候，效率很低。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.leaf_size：代表构造 KD 树或球树时的叶子数，默认是 30，调整 leaf_size 会影响到树的构造和搜索速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建完 KNN 分类器之后，我们就可以输入训练集对它进行训练，这里我们使用 fit() 函数，传入训练集中的样本特征矩阵和分类标识，会自动得到训练好的 KNN 分类器。然后可以使用 predict() 函数来对结果进行预测，这里传入测试集的特征矩阵，可以得到测试集的预测分类结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、 如何用 KNN 对手写数字进行识别分类&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;手写数字数据集是个非常有名的用于图像识别的数据集。数字识别的过程就是将这些图片与分类结果 0-9 一一对应起来。完整的手写数字数据集 MNIST 里面包括了 60000 个训练样本，以及 10000 个测试样本。如果你学习深度学习的话，MNIST 基本上是你接触的第一个数据集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天我们用 sklearn 自带的手写数字数据集做 KNN 分类，你可以把这个数据集理解成一个简版的 MNIST 数据集，它只包括了 1797 幅数字图像，每幅图像大小是 8*8 像素。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们先来规划下整个 KNN 分类的流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据加载：我们可以直接从 sklearn 中加载自带的手写数字数据集；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;准备阶段：在这个阶段中，我们需要对数据集有个初步的了解，比如样本的个数、图像长什么样、识别结果是怎样的。你可以通过可视化的方式来查看图像的呈现。通过数据规范化可以让数据都在同一个数量级的维度。另外，因为训练集是图像，每幅图像是个 8*8 的矩阵，我们不需要对它进行特征选择，将全部的图像数据作为特征值矩阵即可；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分类阶段：通过训练可以得到分类器，然后用测试集进行准确率的计算。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;好了，按照上面的步骤，我们一起来实现下这个项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先是加载数据和对数据的探索：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 加载数据&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; digits =&lt;span&gt; load_digits()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; data =&lt;span&gt; digits.data
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 数据探索&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(data.shape)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看第一幅图像&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(digits.images[0])
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 第一幅图像代表的数字含义&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(digits.target[0])
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将第一幅图像显示出来&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;plt.gray()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;plt.imshow(digits.images[0])
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; plt.show()
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; (1797, 64&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; [[ 0.  0.  5. 13.  9.  1&lt;span&gt;.  0.  0.]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; [ 0.  0. 13. 15. 10. 15.  5&lt;span&gt;.  0.]
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; [ 0.  3. 15.  2.  0. 11.  8&lt;span&gt;.  0.]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; [ 0.  4. 12.  0.  0.  8.  8&lt;span&gt;.  0.]
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; [ 0.  5.  8.  0.  0.  9.  8&lt;span&gt;.  0.]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; [ 0.  4. 11.  0.  1. 12.  7&lt;span&gt;.  0.]
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; [ 0.  2. 14.  5. 10. 12&lt;span&gt;.  0.  0.]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; [ 0.  0.  6. 13. 10&lt;span&gt;.  0.  0.  0.]]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 0
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/62/3c/625b7e95a22c025efa545d7144ec5f3c.png&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;470&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们对原始数据集中的第一幅进行数据可视化，可以看到图像是个 8*8 的像素矩阵，上面这幅图像是一个“0”，从训练集的分类标注中我们也可以看到分类标注为“0”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;sklearn 自带的手写数字数据集一共包括了 1797 个样本，每幅图像都是 8*8 像素的矩阵。因为并没有专门的测试集，所以我们需要对数据集做划分，划分成训练集和测试集。因为 KNN 算法和距离定义相关，我们需要对数据进行规范化处理，采用 Z-Score 规范化，代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 分割数据，将 25% 的数据作为测试集，其余作为训练集（你也可以指定其他比例的数据作为训练集）&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; train_x, test_x, train_y, test_y = train_test_split(data, digits.target, test_size=0.25, random_state=33&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采用 Z-Score 规范化&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; ss =&lt;span&gt; preprocessing.StandardScaler()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; train_ss_x =&lt;span&gt; ss.fit_transform(train_x)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; test_ss_x =&lt;span&gt; ss.transform(test_x)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;然后我们构造一个 KNN 分类器 knn，把训练集的数据传入构造好的 knn，并通过测试集进行结果预测，与测试集的结果进行对比，得到 KNN 分类器准确率，代码如下：
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建 KNN 分类器&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; knn =&lt;span&gt; KNeighborsClassifier()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;knn.fit(train_ss_x, train_y)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; predict_y =&lt;span&gt; knn.predict(test_ss_x)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;KNN 准确率: %.4lf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % accuracy_score(predict_y, test_y))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; KNN 准确率: 0.975
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;好了，这样我们就构造好了一个 KNN 分类器。之前我们还讲过 SVM、朴素贝叶斯和决策树分类。我们用手写数字数据集一起来训练下这些分类器，然后对比下哪个分类器的效果更好。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建 SVM 分类器&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; svm =&lt;span&gt; SVC()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;svm.fit(train_ss_x, train_y)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; predict_y=&lt;span&gt;svm.predict(test_ss_x)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SVM 准确率: %0.4lf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; accuracy_score(predict_y, test_y))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采用 Min-Max 规范化&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; mm =&lt;span&gt; preprocessing.MinMaxScaler()
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; train_mm_x =&lt;span&gt; mm.fit_transform(train_x)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; test_mm_x =&lt;span&gt; mm.transform(test_x)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建 Naive Bayes 分类器&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; mnb =&lt;span&gt; MultinomialNB()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;mnb.fit(train_mm_x, train_y)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; predict_y =&lt;span&gt; mnb.predict(test_mm_x)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 多项式朴素贝叶斯准确率: %.4lf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; accuracy_score(predict_y, test_y))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建 CART 决策树分类器&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; dtc =&lt;span&gt; DecisionTreeClassifier()
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;dtc.fit(train_mm_x, train_y)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; predict_y =&lt;span&gt; dtc.predict(test_mm_x)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CART 决策树准确率: %.4lf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % accuracy_score(predict_y, test_y))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;运行结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; SVM 准确率: 0.9867
&lt;span&gt;2&lt;/span&gt; 多项式朴素贝叶斯准确率: 0.8844
&lt;span&gt;3&lt;/span&gt; CART 决策树准确率: 0.8556
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里需要注意的是，我们在做多项式朴素贝叶斯分类的时候，传入的数据不能有负数。因为 Z-Score 会将数值规范化为一个标准的正态分布，即均值为 0，方差为 1，数值会包含负数。因此我们需要采用 Min-Max 规范化，将数据规范化到 [0,1] 范围内。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，我们整理下这 4 个分类器的结果。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/0f/e8/0f498e0197935bfe15d9b1209bad8fe8.png&quot; alt=&quot;&quot; width=&quot;502&quot; height=&quot;172&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;你能看出来 KNN 的准确率还是不错的，和 SVM 不相上下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以自己跑一遍整个代码，在运行前还需要 import 相关的工具包（下面的这些工具包你都会用到，所以都需要引用）：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; preprocessing
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; accuracy_score
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; load_digits
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.neighbors &lt;span&gt;import&lt;/span&gt;&lt;span&gt; KNeighborsClassifier
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.svm &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SVC
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.naive_bayes &lt;span&gt;import&lt;/span&gt;&lt;span&gt; MultinomialNB
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; sklearn.tree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DecisionTreeClassifier
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; matplotlib.pyplot as plt
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;代码中，我使用了 train_test_split 做数据集的拆分，使用 matplotlib.pyplot 工具包显示图像，使用 accuracy_score 进行分类器准确率的计算，使用 preprocessing 中的 StandardScaler 和 MinMaxScaler 做数据的规范化。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Jun 2019 15:47:00 +0000</pubDate>
<dc:creator>程序员姜小白</dc:creator>
<og:description>一、前言 KNN 的英文叫 K-Nearest Neighbor，应该算是数据挖掘算法中最简单的一种。 先用一个例子体会下。 /*请尊重作者劳动成果，转载请标明原文链接：*/ /* https://w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jpcflyer/p/11111817.html</dc:identifier>
</item>
<item>
<title>把VSCode配置成C/C++开发IDE - LanzSachs</title>
<link>http://www.cnblogs.com/xiaochujie/p/11111818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaochujie/p/11111818.html</guid>
<description>&lt;p&gt;    工作一年多了，大学学的数据结构和算法都忘得差不多了。于是想补补数据结构知识，并且刷一下剑指offer的一些面试题。首要问题就是装个C语言的运行环境，大学学C语言和C++的时候都是用的VC++6.0或者CodeBlocks，优点是不需要配置环境，但是缺点也很明显，就是代码没智能提示，编辑器UI风格还是零几年的。现在的好用又好看的编辑器有很多，比如Vscode，Sublime，atom。只要装上C语言的windows运行环境（&lt;em&gt;  1.MinGw&lt;/em&gt;&lt;em&gt;  2.cygwin&lt;/em&gt;），再在编辑器上装上C/C++插件，然后再按照网上的对应编辑器的配置文件设置改改路径就能用了，还要啥自行车？\（手动滑稽）。于是说干就干，感觉可能会常用到，于是放到博客上分享给大家。&lt;/p&gt;
&lt;p&gt;   参考了网上相关的博客，我决定以minGw+VSCode（微软出品，必属精品）来举例。安装分3步，&lt;/p&gt;
&lt;p&gt;一、安装minGw（windows上的GNU GCC &lt;a href=&quot;https://zhidao.baidu.com/question/323618893.html&quot;&gt;https://zhidao.baidu.com/question/323618893.html&lt;/a&gt;），可以理解成包含多种编译环境的可自由选择安装的其中的部分的软件&lt;/p&gt;
&lt;p&gt;二、安装VSCode并下载插件C/C++（主要是代码补全和错误提醒的功能）&lt;/p&gt;
&lt;p&gt;三、按VSCode调整配置文件内容（主要是把minGw的运行目录配置成编辑器的默认运行路径以及引入必要的包）&lt;/p&gt;
&lt;p&gt;首先，下载minGw  &lt;a href=&quot;https://sourceforge.net/&quot;&gt;https://sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630223747683-2123205859.png&quot; alt=&quot;&quot; width=&quot;1915&quot; height=&quot;724&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630223933696-517571082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载后安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630224130619-754926716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完成界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630224650260-950732156.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我的出现了这个错误，但好像暂时没什么影响&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630224810265-61501987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来这步比较关键&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要打开minGw，并且勾选四个编译器软件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mingw32-gcc.bin, mingw32-gcc-g++.bin, 以及mingw32-gdb.bin 第一个是c语言文件的编译器，第二个是c++的，第三个是用来调试编译后文件的。网上的教程好像都是选择这3个 ，但是我安装的时候就报了找不到mingw32-libiconv的库的错误，于是重新勾选上&lt;/strong&gt;mingw32-libiconv.bin的库，尤其要勾选上.dll文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630225355479-2085630142.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630225820866-614820311.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择完后，点击&lt;strong&gt;Installation &amp;gt; applychange&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630225947628-994118906.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;然后等安装完成就OK了&lt;/p&gt;
&lt;p&gt;然后安装好编译器，下面设置环境变量，让系统能够自动找到gcc命令，我的电脑右击-&amp;gt;属性-&amp;gt;高级系统设置-&amp;gt;环境变量，在系统变量里面找到path，这个path和linux里面那个path是一样的，命令行界面下系统就根据这个path变量里面存的路径，寻找命令。我们把MinGW的二进制可执行文件的文件夹添加进去。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630230231195-1779497601.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加后记得依次点击三个确认，确保环境变量生效。（安装Java的时候也是一样）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630230407769-1907720284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后重启cmd，运行gcc命令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630230632169-213643688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后可以到指定目录写个Hello，World！测试一下&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630231449850-1929655329.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完成后，再打开VSCode C/C++和CLang Command adapter插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1257437/201906/1257437-20190630231619260-1207332087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完vscode及插件后就来到了第三步，也是最容易出现问题的一步。就是如何在vscode写c/c++文件，并搭建起IDE。&lt;/p&gt;
&lt;p&gt;今天时间有点晚了，下次再补充。&lt;/p&gt;

</description>
<pubDate>Sun, 30 Jun 2019 15:44:00 +0000</pubDate>
<dc:creator>LanzSachs</dc:creator>
<og:description>工作一年多了，大学学的数据结构和算法都忘得差不多了。于是想补补数据结构知识，并且刷一下剑指offer的一些面试题。首要问题就是装个C语言的运行环境，大学学C语言和C++的时候都是用的VC++6.0或者</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaochujie/p/11111818.html</dc:identifier>
</item>
<item>
<title>Vue.js 是如何实现 MVVM 的？ - dora_zc</title>
<link>http://www.cnblogs.com/dora-zc/p/11111813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dora-zc/p/11111813.html</guid>
<description>&lt;h2 id=&quot;框架到底为我们做了什么&quot;&gt;框架到底为我们做了什么？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据和视图分离，解耦(开放封闭原则)
&lt;ul&gt;&lt;li&gt;所有数据和视图不分离的，都会命中开放封闭原则&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vue&lt;/code&gt; 数据独立在 &lt;code&gt;data&lt;/code&gt; 里面，视图在 &lt;code&gt;template&lt;/code&gt; 中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;以数据驱动视图，只关心数据变化，&lt;code&gt;dom&lt;/code&gt; 操作被封装
&lt;ul&gt;&lt;li&gt;使用原生js是直接通过操作&lt;code&gt;dom&lt;/code&gt;来修改视图，例如 &lt;code&gt;ducument.getElementById('xx').innerHTML=&quot;xxx&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;以数据驱动视图就是，我们只管修改数据，视图的部分由框架去帮我们修改，符合开放封闭模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何理解-mvvm&quot;&gt;如何理解 MVVM ？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;MVC
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Model&lt;/code&gt; 数据 → &lt;code&gt;View&lt;/code&gt; 视图 → &lt;code&gt;Controller&lt;/code&gt; 控制器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;MVVM
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MVVM&lt;/code&gt;不算是一种创新&lt;/li&gt;
&lt;li&gt;但是其中的 &lt;code&gt;ViewModel&lt;/code&gt; 是一种创新&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ViewModel&lt;/code&gt; 是真正结合前端应用场景的实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;如何理解MVVM
&lt;ul&gt;&lt;li&gt;&lt;code&gt;MVVM - Model View ViewModel&lt;/code&gt;，数据，视图，视图模型&lt;/li&gt;
&lt;li&gt;三者与 &lt;code&gt;Vue&lt;/code&gt; 的对应：&lt;code&gt;view&lt;/code&gt; 对应 &lt;code&gt;template&lt;/code&gt;，&lt;code&gt;vm&lt;/code&gt; 对应 &lt;code&gt;new Vue({…})&lt;/code&gt;，&lt;code&gt;model&lt;/code&gt; 对应 &lt;code&gt;data&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;三者的关系：&lt;code&gt;view&lt;/code&gt; 可以通过事件绑定的方式影响 &lt;code&gt;model&lt;/code&gt;，&lt;code&gt;model&lt;/code&gt; 可以通过数据绑定的形式影响到&lt;code&gt;view&lt;/code&gt;，&lt;code&gt;viewModel&lt;/code&gt;是把 &lt;code&gt;model&lt;/code&gt; 和 &lt;code&gt;view&lt;/code&gt; 连起来的连接器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;如何实现-mvvm---以-vue.js-为例&quot;&gt;如何实现 MVVM - 以 Vue.js 为例&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MVVM&lt;/code&gt; 框架的三大要素&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;响应式：&lt;code&gt;Vue&lt;/code&gt; 如何监听到 &lt;code&gt;data&lt;/code&gt; 的每个属性变化&lt;/li&gt;
&lt;li&gt;模板引擎：&lt;code&gt;Vue&lt;/code&gt; 的模板如何被解析，指令如何处理&lt;/li&gt;
&lt;li&gt;渲染：&lt;code&gt;Vue&lt;/code&gt; 的模板如何被渲染成 &lt;code&gt;html&lt;/code&gt;，渲染过程是怎样的&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;vue-如何实现响应式&quot;&gt;Vue 如何实现响应式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;什么是响应式
&lt;ul&gt;&lt;li&gt;修改 &lt;code&gt;data&lt;/code&gt; 属性之后，&lt;code&gt;Vue&lt;/code&gt; 立刻监听到，立刻渲染页面&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; 属性被代理到 &lt;code&gt;vm&lt;/code&gt; 上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Object.defineProperty
&lt;ul&gt;&lt;li&gt;将对象属性的值的设置和访问 (get，set) 都变成函数，可以在当中加入我们自己的逻辑(进行监听)&lt;/li&gt;
&lt;li&gt;普通的 &lt;code&gt;JavaScript&lt;/code&gt; 对象，做属性修改，我们监听不到，所以需要用到 &lt;code&gt;Object.defineProperty&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;既能get，又能set，才是双向数据绑定&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;vue-如何解析模板&quot;&gt;Vue 如何解析模板&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;模板是什么
&lt;ul&gt;&lt;li&gt;本质：模板就是字符串&lt;/li&gt;
&lt;li&gt;与html格式很像，但是模板中是有逻辑的，可以嵌入JS变量，如v-if, v-for等&lt;/li&gt;
&lt;li&gt;视图最终还是需要由模板生成 &lt;code&gt;html&lt;/code&gt; 来显示&lt;/li&gt;
&lt;li&gt;模板必须先要转换成JS代码
&lt;ul&gt;&lt;li&gt;有逻辑(v-if, v-for)，必须用JS才能实现(图灵完备)&lt;/li&gt;
&lt;li&gt;转换为html渲染页面，必须用JS才能实现&lt;/li&gt;
&lt;li&gt;因此，模板要转换成render函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;render函数
&lt;ul&gt;&lt;li&gt;render函数包含了模板中所有的信息，返回 &lt;code&gt;vnode&lt;/code&gt;，解决了模板中的逻辑(v-if, v-for)问题&lt;/li&gt;
&lt;li&gt;如何找到最终生成的render函数
&lt;ul&gt;&lt;li&gt;找到vue源码，搜索&lt;code&gt;code.render&lt;/code&gt;，将code打印出来，就是生成的render函数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;render函数与vdom
&lt;ul&gt;&lt;li&gt;模板生成 &lt;code&gt;html&lt;/code&gt;：&lt;code&gt;vm._c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vm._c&lt;/code&gt; 和 &lt;code&gt;snabbdom&lt;/code&gt; 中的 &lt;code&gt;h&lt;/code&gt; 函数的实现很像，都是传入标签，属性，子元素作为参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vue.js&lt;/code&gt; 的 &lt;code&gt;vdom&lt;/code&gt; 实现借鉴了 &lt;code&gt;snabbdom&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;updateComponent&lt;/code&gt; 中实现了 &lt;code&gt;vdom&lt;/code&gt; 的 &lt;code&gt;patch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;页面首次渲染执行 &lt;code&gt;updateComponent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; 中每次修改属性，都会执行 &lt;code&gt;updateComponent&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;vue.js-运行机制&quot;&gt;Vue.js 运行机制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1449188/201906/1449188-20190630234249553-1929355900.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步：解析模板成 &lt;code&gt;render&lt;/code&gt; 函数
&lt;ul&gt;&lt;li&gt;因为在打包的时候就已经生成了render函数，所以编译是第一步；响应式监听是在代码执行的时候才开始监听。&lt;/li&gt;
&lt;li&gt;模板中的所有信息都被render函数包含&lt;/li&gt;
&lt;li&gt;模板中用到的data中的属性，都变成了js变量&lt;/li&gt;
&lt;li&gt;模板中的 v-model v-for v-on都变成了js逻辑&lt;/li&gt;
&lt;li&gt;render函数返回vnode&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第二步：响应式开始监听
&lt;ul&gt;&lt;li&gt;通过Object.definedProperty监听到对象属性的get和set&lt;/li&gt;
&lt;li&gt;将data的属性代理到vm上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三步：首次渲染，显示页面，且绑定依赖
&lt;ul&gt;&lt;li&gt;初次渲染，执行 &lt;code&gt;updateComponent&lt;/code&gt;，执行 &lt;code&gt;vm._render()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;render&lt;/code&gt; 函数，会访问到 &lt;code&gt;data&lt;/code&gt; 中的值，访问时会被响应式的 &lt;code&gt;get&lt;/code&gt; 方法监听到&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;updateComponent&lt;/code&gt;，会走到 &lt;code&gt;vdom&lt;/code&gt; 的 &lt;code&gt;patch&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;patch&lt;/code&gt; 将 &lt;code&gt;vnode&lt;/code&gt; 渲染成 &lt;code&gt;dom&lt;/code&gt;，初次渲染完成&lt;/li&gt;
&lt;li&gt;疑问：为何要监听 &lt;code&gt;get&lt;/code&gt;，而不是直接监听 &lt;code&gt;set&lt;/code&gt; ？
&lt;ul&gt;&lt;li&gt;因为 &lt;code&gt;data&lt;/code&gt; 中有很多属性，有些被用到，有些可能不被用到&lt;/li&gt;
&lt;li&gt;只有被用到的才会走 &lt;code&gt;get&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;没有走到 &lt;code&gt;get&lt;/code&gt; 中的属性，&lt;code&gt;set&lt;/code&gt; 的时候我们也无需关心&lt;/li&gt;
&lt;li&gt;避免不必要的重新渲染&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第四步：&lt;code&gt;data&lt;/code&gt; 属性变化，触发 &lt;code&gt;re-render&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;修改属性，被响应式的 &lt;code&gt;set&lt;/code&gt; 监听到&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt; 中执行 &lt;code&gt;updateComponent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;updateComponent&lt;/code&gt; 重新执行 &lt;code&gt;vm._render()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成的 &lt;code&gt;vnode&lt;/code&gt; 和 &lt;code&gt;prevVnode&lt;/code&gt;，通过 &lt;code&gt;patch&lt;/code&gt; 进行对比&lt;/li&gt;
&lt;li&gt;渲染到 &lt;code&gt;html&lt;/code&gt; 中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;手写一个-vue.js&quot;&gt;手写一个 Vue.js&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1449188/201906/1449188-20190630234304268-90804904.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;index.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是最终的测试代码，我们自己实现的 Vue 在 &lt;code&gt;XVue.js&lt;/code&gt; 和 &lt;code&gt;compile.js&lt;/code&gt;两个文件中，加起来大概200行代码左右，主要包括功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据响应式：页面中能直接引用data中的变量 test，我们给data.test重新赋值时，页面能随test值改变&lt;/li&gt;
&lt;li&gt;双向数据绑定：v-model&lt;/li&gt;
&lt;li&gt;模板解析，处理指令和事件绑定：v-text v-model @click&lt;/li&gt;
&lt;li&gt;渲染页面：将模板转化为 html&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&quot;app&quot;&amp;gt;
      {{test}}
      &amp;lt;div v-text=&quot;test&quot;&amp;gt;&amp;lt;/div&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;input type=&quot;text&quot; v-model=&quot;test&quot; /&amp;gt;
      &amp;lt;/p&amp;gt;
      &amp;lt;p v-html=&quot;html&quot;&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;p&amp;gt;
        &amp;lt;button @click=&quot;onClick&quot;&amp;gt;按钮&amp;lt;/button&amp;gt;
      &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script src=&quot;./compile.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;./XVue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script&amp;gt;
      const o = new XVue({
        el: '#app',
        data: {
          test: '123',
          foo: { bar: 'bar' },
          html: '&amp;lt;button&amp;gt;html test&amp;lt;/button&amp;gt;'
        },
        methods: {
          onClick() {
            alert('按钮点击了')
          }
        }
      })
      console.log(o.$data.test) //123
      o.$data.test = 'hello, Xvue!'
      console.log(o.$data.test) //hello, Xvue!
    &amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Mini Vue 的组成部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监听器 observe ：数据劫持，实现响应式；属性代理&lt;/li&gt;
&lt;li&gt;依赖管理器 Dep ：负责将视图中所有依赖收集管理，包括依赖添加和通知更新&lt;/li&gt;
&lt;li&gt;监听器 Watcher ：具体更新的执行者&lt;/li&gt;
&lt;li&gt;编译器 Compile ：扫描模板中所有依赖（指令、插值、绑定、事件等），创建更新函数和监听器( Watcher )&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;XVue.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;class XVue {
  constructor(options) {
    this.$data = options.data;
    this.observe(this.$data);
    // 执行编译
    new Compile(options.el, this);
  }

  observe(value) {
    if (!value || typeof value !== 'object') {
      return;
    }
    Object.keys(value).forEach(key =&amp;gt; {
      this.defineReactive(value, key, value[key]);
      // 为vue的data做属性代理
      this.proxyData(key);
    });
  }

  defineReactive(obj, key, val) {
    // 递归查找嵌套属性
    this.observe(val);

    // 创建Dep
    const dep = new Dep();

    Object.defineProperty(obj, key, {
      enumerable: true,
      configurable: true,
      get() {
        // 收集依赖
        Dep.target &amp;amp;&amp;amp; dep.addDep(Dep.target);
        // console.log(dep.deps);
        return val;
      },
      set(newVal) {
        if (newVal === val) {
          return;
        }
        val = newVal;
        dep.notify();
      },
    });
  }

  proxyData(key) {
    Object.defineProperty(this, key, {
      get() {
        return this.$data[key];
      },
      set(newVal) {
        this.$data[key] = newVal;
      },
    });
  }
}

// 依赖管理器：负责将视图中所有依赖收集管理，包括依赖添加和通知
class Dep {
  constructor() {
    // deps里面存放的是Watcher的实例
    this.deps = [];
  }
  addDep(dep) {
    this.deps.push(dep);
  }
  // 通知所有watcher执行更新
  notify() {
    this.deps.forEach(dep =&amp;gt; {
      dep.update();
    });
  }
}

// Watcher: 具体的更新执行者
class Watcher {
  constructor(vm, key, cb) {
    this.vm = vm;
    this.key = key;
    this.cb = cb;
    // 将来 new 一个监听器时，将当前 Watcher 实例附加到 Dep.target
    // 将来通过 Dep.target 就能拿到当时创建的 Watcher 实例
    Dep.target = this;
    // 读取操作，主动触发 get，当前 Watcher 实例被添加到依赖管理器中 
    this.vm[this.key];
    // 清空操作，避免不必要的重复添加（再次触发 get 就不需要再添加 watcher 了）
    Dep.target = null;
  }
  update() {
    // console.log('from Watcher update: 视图更新啦！！！');
    // 通知页面做更新
    this.cb.call(this.vm, this.vm[this.key]);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;compile.js&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 扫描模板中所有依赖（指令、插值、绑定、事件等）创建更新函数和watcher
class Compile {
  // el是宿主元素或其选择器
  // vm当前Vue实例
  constructor(el, vm) {
    this.$el = document.querySelector(el);
    this.$vm = vm;
    if (this.$el) {
      // 将dom节点转换为Fragment提高执行效率
      this.$fragment = this.node2Fragment(this.$el);
      // 执行编译，编译完成以后所有的依赖已经替换成真正的值
      this.compile(this.$fragment);
      // 将生成的结果追加至宿主元素
      this.$el.appendChild(this.$fragment);
    }
  }
  node2Fragment(el) {
    // 创建一个新的Fragment
    const fragment = document.createDocumentFragment();
    let child;
    // 将原生节点移动至fragment
    while ((child = el.firstChild)) {
      // appendChild 是移动操作，移动一个节点，child 就会少一个，最终结束循环
      fragment.appendChild(child);
    }
    return fragment;
  }
  // 编译指定片段
  compile(el) {
    let childNodes = el.childNodes;
    Array.from(childNodes).forEach(node =&amp;gt; {
      // 判断node类型，做相应处理
      if (this.isElementNode(node)) {
        // 元素节点要识别v-xx或@xx
        this.compileElement(node);
      } else if (
        this.isTextNode(node) &amp;amp;&amp;amp;
        /\{\{(.*)\}\}/.test(node.textContent)
      ) {
        // 文本节点，只关心{{msg}}格式
        this.compileText(node, RegExp.$1); // RegExp.$1匹配{{}}之中的内容
      }
      // 遍历可能存在的子节点
      if (node.childNodes &amp;amp;&amp;amp; node.childNodes.length) {
        this.compile(node);
      }
    });
  }

  compileElement(node) {
    // console.log('编译元素节点');
    // &amp;lt;div v-text=&quot;test&quot; @click=&quot;onClick&quot;&amp;gt;&amp;lt;/div&amp;gt;
    const attrs = node.attributes;
    Array.from(attrs).forEach(attr =&amp;gt; {
      const attrName = attr.name; // 获取属性名 v-text
      const exp = attr.value; // 获取属性值 test
      if (this.isDirective(attrName)) {
        // 指令
        const dir = attrName.substr(2); // text
        this[dir] &amp;amp;&amp;amp; this[dir](node, this.$vm, exp);
      } else if (this.isEventDirective(attrName)) {
        // 事件
        const dir = attrName.substr(1); // click
        this.eventHandler(node, this.$vm, exp, dir);
      }
    });
  }

  compileText(node, exp) {
    // console.log('编译文本节点');
    this.text(node, this.$vm, exp);
  }

  isElementNode(node) {
    return node.nodeType == 1; //元素节点
  }

  isTextNode(node) {
    return node.nodeType == 3; //元素节点
  }

  isDirective(attr) {
    return attr.indexOf('v-') == 0;
  }

  isEventDirective(dir) {
    return dir.indexOf('@') == 0;
  }

  // 文本更新
  text(node, vm, exp) {
    this.update(node, vm, exp, 'text');
  }

  // 处理html
  html(node, vm, exp) {
    this.update(node, vm, exp, 'html');
  }

  // 双向绑定
  model(node, vm, exp) {
    this.update(node, vm, exp, 'model');

    let val = vm.exp;
    // 双绑还要处理视图对模型的更新
    node.addEventListener('input', e =&amp;gt; {
      vm[exp] = e.target.value; // 这里相当于执行了 set
    });
  }

  // 更新
  // 能够触发这个 update 方法的时机有两个：1-编译器初始化视图时触发；2-Watcher更新视图时触发
  update(node, vm, exp, dir) {
    let updaterFn = this[dir + 'Updater'];
    updaterFn &amp;amp;&amp;amp; updaterFn(node, vm[exp]); // 立即执行更新；这里的 vm[exp] 相当于执行了 get
    new Watcher(vm, exp, function (value) {
      // 每次创建 Watcher 实例，都会传入一个回调函数，使函数和 Watcher 实例之间形成一对一的挂钩关系
      // 将来数据发生变化时， Watcher 就能知道它更新的时候要执行哪个函数
      updaterFn &amp;amp;&amp;amp; updaterFn(node, value);
    });
  }

  textUpdater(node, value) {
    node.textContent = value;
  }

  htmlUpdater(node, value) {
    node.innerHTML = value;
  }

  modelUpdater(node, value) {
    node.value = value;
  }

  eventHandler(node, vm, exp, dir) {
    let fn = vm.$options.methods &amp;amp;&amp;amp; vm.$options.methods[exp];
    if (dir &amp;amp;&amp;amp; fn) {
      node.addEventListener(dir, fn.bind(vm), false);
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 30 Jun 2019 15:43:00 +0000</pubDate>
<dc:creator>dora_zc</dc:creator>
<og:description>[TOC] 框架到底为我们做了什么？ 数据和视图分离，解耦(开放封闭原则) 所有数据和视图不分离的，都会命中开放封闭原则 数据独立在 里面，视图在 中 以数据驱动视图，只关心数据变化， 操作被封装 使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dora-zc/p/11111813.html</dc:identifier>
</item>
<item>
<title>多线程与高并发(二)线程安全 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/11111788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/11111788.html</guid>
<description>&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上一篇学习了多线程的一些基础知识：多线程的基本概念，及创建和操作多线程。内容相对简单，但多线程的知识肯定不会这么简单，否则我们也不需要花这么多心思去学习，因为多线程中容易出现线程安全问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;那么什么是线程安全呢，定义如下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;简单的理解就是在多线程情况下代码的运行结果与预期的正确结果不一致，而产生线程安全的问题一般是由是&lt;span&gt;&lt;strong&gt;主内存和工作内存数据不一致性&lt;/strong&gt;&lt;span&gt;和&lt;span&gt;&lt;strong&gt;重排序&lt;/strong&gt;&lt;span&gt;导致的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;要理解这些的必须先理解java的内存模型。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;一 Java内存模型&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在并发编程领域，有两个关键问题：线程之间的&lt;span&gt;&lt;strong&gt;通信&lt;/strong&gt;&lt;span&gt;和&lt;span&gt;&lt;strong&gt;同步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.1 通信与同步&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;线程通信&lt;/strong&gt;&lt;span&gt;是指线程之间以何种机制来交换信息，在命令式编程中，线程之间的通信机制有两种&lt;span&gt;&lt;strong&gt;共享内存&lt;/strong&gt;&lt;span&gt;和&lt;span&gt;&lt;strong&gt;消息传递&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信，典型的共享内存通信方式就是通过共享对象进行通信。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行通信，在java中典型的消息传递方式就是wait()和notify()。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;线程同步&lt;/strong&gt;&lt;span&gt;是指程序用于控制不同线程之间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;java内存模型是&lt;span&gt;&lt;strong&gt;共享内存的并发模型&lt;/strong&gt;&lt;span&gt;，线程之间主要通过读-写共享变量来完成隐式通信。如果不能理解Java的共享内存模型在编写并发程序时一定会遇到各种各样关于内存可见性的问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.2 java内存模型（JMM）&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;CPU的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个CPU都会有缓存。因此，共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把位于主存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。JMM就从抽象层次定义了这种方式，并且JMM决定了一个线程对共享变量的写入何时对其他线程是可见的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201906/1113901-20190630232919704-896257540.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如图为JMM抽象示意图，线程A和线程B之间要完成通信的话，要经历如下两步：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程B从主存中读取最新的共享变量&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;java的内存模型内容还有很多，推荐看这篇文章：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/suifeng3051/article/details/52611310&quot;&gt;https://blog.csdn.net/suifeng3051/article/details/52611310&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;1.3 可见性和竞争现象&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当对象和变量存储到计算机的各个内存区域时，必然会面临一些问题，其中最主要的两个问题是：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; start=&quot;&quot; readability=&quot;-1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;共享对象对各个线程的可见性&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;共享对象的竞争现象&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;共享对象的可见性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当多个线程同时操作同一个共享对象时，如果没有合理的使用volatile和synchronization关键字，一个线程对共享对象的更新有可能导致其它线程不可见。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;一个CPU中的线程读取主存数据到CPU缓存，然后对共享对象做了更改，但CPU缓存中的更改后的对象还没有flush到主存，此时线程对共享对象的更改对其它CPU中的线程是不可见的。最终就是每个线程最终都会拷贝共享对象，而且拷贝的对象位于不同的CPU缓存中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;要解决共享对象可见性这个问题，我们可以使用volatile关键字，volatile 关键字可以保证变量会直接从主存读取，而对变量的更新也会直接写到主存，这个后面会详讲。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;竞争现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果多个线程共享一个对象，如果它们同时修改这个共享对象，这就产生了竞争现象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程A和线程B共享一个对象obj。假设线程A从主存读取Obj.count变量到自己的CPU缓存，同时，线程B也读取了Obj.count变量到它的CPU缓存，并且这两个线程都对Obj.count做了加1操作。此时，Obj.count加1操作被执行了两次，不过都在不同的CPU缓存中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;要解决竞争现象我们可以使用synchronized代码块。synchronized代码块可以保证同一个时刻只能有一个线程进入代码竞争区，synchronized代码块也能保证代码块中所有变量都将会从主存中读，当线程退出代码块时，对所有变量的更新将会flush到主存，不管这些变量是不是volatile类型的。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;二 重排序&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;指令重排序是指编译器和处理器为了提高性能对指令进行重新排序，重排序一般有以下三种：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201906/1113901-20190630232946009-1795951258.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;1.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;编译器优化重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;指令级并行的重排序：如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;内存系统的重排序：处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题，JMM确保在不同的编译器和不同的处理器平台之上，通过插入特定类型的&lt;span&gt;&lt;code&gt;Memory Barrier&lt;/code&gt;&lt;span&gt;来禁止特定类型的编译器重排序和处理器重排序，为上层提供一致的内存可见性保证。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;那么什么情况下一定不会重排序呢？&lt;span&gt;&lt;strong&gt;编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序，即不会重排序&lt;/strong&gt;&lt;span&gt;，这里有个数据依赖性概念是什么意思呢？看如下代码：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt; a = 1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; b = 2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; c = a + b;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这段代码中A和B没有任何关系，改变A和B的执行顺序，不会对结果产生影响，这里就可以对A和B进行指令重排序，因为不管是先执行A或者B都对结果没有影响，这个时候就说这两个操作不存在&lt;span&gt;&lt;strong&gt;数据依赖性&lt;/strong&gt;&lt;span&gt;，数据依赖性是指&lt;span&gt;&lt;strong&gt;如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性&lt;/strong&gt;&lt;span&gt;，如果我们对变量a进行了写操作，后又进行了读取操作，那么这两个操作就是有数据依赖性，这个时候就不能进行指令重排序，这个很好理解，因为如果重排序的话会影响结果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里还有一个概念要理解：&lt;span&gt;&lt;strong&gt;as-if-serial&lt;/strong&gt;&lt;span&gt;：不管怎么重排序，单线程下的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里也比较好理解，就是在单线程情况下，重排序不能影响执行结果，这样程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;三 happens-before规则&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们知道处理器和编译器会对指令进行重排序，但是如果要我们去了解底层的规则，那对我们来说负担太大了，因此，JMM为程序员在上层提供了规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.1 happens-before&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们无法就所有场景来规定某个线程修改的变量何时对其他线程可见，但是我们可以指定某些规则，这规则就是happens-before。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证（如果A线程的写操作a与B线程的读操作b之间存在happens-before关系，尽管a操作和b操作在不同的线程中执行，但JMM向程序员保证a操作将对b操作可见）。具体的定义为：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。&lt;/span&gt;&lt;/li&gt;
&lt;li class=&quot;md-end-block&quot;&gt;&lt;span&gt;两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3.2 具体规则&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;具体的规则有8条：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;8.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-list-item md-focus-container&quot;&gt;&lt;span&gt;参考文章：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-list-item md-focus-container&quot;&gt;&lt;span&gt;&lt;a href=&quot;https://blog.csdn.net/suifeng3051/article/details/52611310&quot;&gt;https://blog.csdn.net/suifeng3051/article/details/52611310&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Jun 2019 15:36:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>上一篇学习了多线程的一些基础知识：多线程的基本概念，及创建和操作多线程。内容相对简单，但多线程的知识肯定不会这么简单，否则我们也不需要花这么多心思去学习，因为多线程中容易出现线程安全问题。 那么什么是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yuanqinnan/p/11111788.html</dc:identifier>
</item>
<item>
<title>微服务SpringCloud之服务注册与发现 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/11111621.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/11111621.html</guid>
<description>&lt;p&gt;   在找.net core 微服务框架时发现了Steeltoe开源项目，它可以基于Spring Cloud实现.net core和.net  Framework的微服务。正好之前也有学习过SpringBoot，而Spring Cloud是基于SpringBoot的，有了SpringBoot基础上手入门SpringCloud应该也不难，正好我的第一本书&amp;lt;&amp;lt;Spring快速入门&amp;gt;&amp;gt;即将上架，感兴趣的朋友可以多多支持。本篇主要学习服务注册与发现组件Eureka。&lt;/p&gt;
&lt;p&gt;   在学习之前首先聊一聊为什么会有微服务，它的优缺点是什么。&lt;/p&gt;
&lt;p&gt;   在微服务之前主要是单体应用，单体应用常见的就是一个war文件包含所有功能的应用程序包，每次迭代更新哪怕是更新一行代码都需要重新打包部署，同样每次迭代可能都要进行测试，模块与模块之间耦合度也比较高，导致可能需要对整个war包进行的测试，如果出现一个bug导致内存溢出，死循环，可能导致整个应用崩溃。二八原则在日常生活中普遍存在，在软件领域也一样，我们平时浏览网页一般读的多，写的少，例如逛博客园，我们可能浏览的比较多，提交数据的频率比较少，在单体应用中如果要增加浏览接口的部署，同样也会将提交数据的接口部署上去会造成资源浪费，单体应用往往使用统一的技术平台或方案解决所有的问题，开发语言和框架固定之后后续想引入新框架和技术也比较困难。&lt;/p&gt;
&lt;p&gt;   在单体应用中主要是面对单个应用的编程，而在微服务中主要是面对单个功能点的编程，将提供的功能点对外发布，这样其他地方可以不用关心具体用什么语言什么技术实现的，直接调用即可。而且每个功能点可以独立部署，是解耦的。假如某个接口调用增多，可以单独部署该接口应用，扩展性比较好。某个节点出现故障可以迅速让其他节点顶上，不至于整个应用不可用，容错性好，某个服务访问超出服务器承载时也可以进行限流，后续的CI、CD容器化也比较方便。同样有优点也有缺点，微服务会导致对外提供的接口增多，部署数量增多，服务治理带来新的挑战，A服务会调用B服务，B服务会调用C服务，如果A服务报错了，那是A服务导致的还是B、C服务导致的呢，而且对外提供服务的节点可能会有很多，那是哪个服务的哪个节点导致的呢？所以还需要微服务的链路追踪与排查。前面也提到微服务方便扩展，那什么情况下需要扩展，哪些服务节点需要扩展，这需要用数据说话，那就需要对服务进行监控，而且监控的参数指标和维度也是不一样的。&lt;/p&gt;
&lt;p&gt;  前面算是导语，下面切回正题，来学习服务注册与发现组件Eureka。每个站点都对外提供某些服务，有点类似家里赶集一样，有的卖家说卖衣服的，提供卖衣服的接口，有的卖家是卖拖拉机的，提供卖拖拉机的接口，每个卖家都是独立分散的，假如每个卖家都不在一个集市上，那买家可能需要先找到每个卖家住在什么地方，哪个村的叫什么名字，一般逛一家可能还没选到合适的，还要多逛几家，这样买家就要来回跑，那有了集市之后就不一样了，每个卖家都在集市上提供不同的服务，买家只要到固定的集市上找需要的服务即可，就和在没出现淘宝之前买东西需要到实体商店，有了淘宝之后只要输入淘宝网址就能找到不同商家提供的不同服务。Eureka就是有点类似淘宝的功能，它为服务提供者(卖家)提供了一个集中的平台，只要注册一下说明提供什么服务，服务消费者(买家)不用关心服务提供者在什么地方，直接调用就好了，是一个中心化的过程。&lt;/p&gt;
&lt;p&gt;一、创建Eureka Server&lt;/p&gt;
&lt;p&gt;1.引入依赖&lt;/p&gt;
&lt;p&gt;   SpringCloud使用Eureka也比较容易，创建SpringBoot项目时选中Eureka Server即可，它会在pom.xml中自动引入下面两个依赖，也可以自己添加。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('67aa0406-e1ec-4c5d-a7af-540ba2c5492e')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_67aa0406-e1ec-4c5d-a7af-540ba2c5492e&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_67aa0406-e1ec-4c5d-a7af-540ba2c5492e&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('67aa0406-e1ec-4c5d-a7af-540ba2c5492e',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_67aa0406-e1ec-4c5d-a7af-540ba2c5492e&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-netflix-eureka-server --&amp;gt;&lt;/span&gt;
    &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;2、启动代码中添加@EnableEurekaServer注解&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('010ad73b-2d1b-4d2e-8752-972bda0ce356')&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_010ad73b-2d1b-4d2e-8752-972bda0ce356&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_010ad73b-2d1b-4d2e-8752-972bda0ce356&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('010ad73b-2d1b-4d2e-8752-972bda0ce356',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_010ad73b-2d1b-4d2e-8752-972bda0ce356&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@EnableEurekaServer
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EurekaServerApplication {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(EurekaServerApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;3、配置文件&lt;/p&gt;
&lt;p&gt;在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，在application.properties添加以下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
spring.application.name=spring-cloud-&lt;span&gt;eureka
eureka.client.register&lt;/span&gt;-with-eureka=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
eureka.client.fetch&lt;/span&gt;-registry=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
eureka.client.serviceUrl.defaultZone&lt;/span&gt;=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:${server.port}/eureka/&lt;/span&gt;
server.port=8088
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;eureka.client.register-with-eureka ：表示是否将自己注册到Eureka Server，默认为true。&lt;br/&gt;eureka.client.fetch-registry ：表示是否从Eureka Server获取注册信息，默认为true。&lt;br/&gt;eureka.client.serviceUrl.defaultZone ：设置与Eureka Server交互的地址，查询服务和注册服务都需要依赖这个地址。默认是http://localhost:8761/eureka ；多个地址可使用 , 分隔。&lt;/p&gt;
&lt;p&gt;4.启动应用&lt;/p&gt;
&lt;p&gt;在浏览器输入&lt;a href=&quot;http://localhost:8088/&quot;&gt;http://localhost:8088/&lt;/a&gt;，即可看到下面页面，暂时还未有注册的实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201906/733213-20190630222922271-1573225393.png&quot; alt=&quot;&quot; width=&quot;724&quot; height=&quot;493&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、Eureka集群&lt;/p&gt;
&lt;p&gt;这里使用两个节点来构建Eureka注册中心，首先添加两个配置文件application-peer1.properties、application-peer2.properties.分别启动了8000、8001端口。同时&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;eureka.client.serviceUrl.defaultZone为对方的地址。&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;application-peer1.properties：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
spring.application.name=spring-cloud-&lt;span&gt;eureka
server.port&lt;/span&gt;=8000&lt;span&gt;
eureka.client.serviceUrl.defaultZone&lt;/span&gt;=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8001/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;application-peer2.properties：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
spring.application.name=spring-cloud-&lt;span&gt;eureka
server.port&lt;/span&gt;=8001&lt;span&gt;
eureka.client.serviceUrl.defaultZone&lt;/span&gt;=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8000/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;application.properties：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
spring.application.name=spring-cloud-&lt;span&gt;eureka
eureka.client.register&lt;/span&gt;-with-eureka=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
eureka.client.fetch&lt;/span&gt;-registry=&lt;span&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将Eureka Server项目打包，mvn clean package，会生成EurekaServer-0.0.1-SNAPSHOT.jar包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201906/733213-20190630223913528-1329813741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在EurekaServer-0.0.1-SNAPSHOT.jar的目录下，分别执行下面两句命令，启动两个EurekaServer实例。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
java -jar EurekaServer-0.0.1-SNAPSHOT.jar --spring.profiles.active=&lt;span&gt;peer1
java &lt;/span&gt;-jar EurekaServer-0.0.1-SNAPSHOT.jar --spring.profiles.active=peer2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201906/733213-20190630224443533-2022455442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在浏览器中输入&lt;a href=&quot;http://localhost:8001/&quot;&gt;http://localhost:8001/&lt;/a&gt;和&lt;a href=&quot;http://localhost:8000/&quot;&gt;http://localhost:8000/&lt;/a&gt;就会发现你中有我我中有你。这里也都是参考纯洁的微笑大神的：http://www.ityouknow.com/springcloud/2017/05/10/springcloud-eureka.html。在里面介绍说注册中心会出现在available-replicas中，但我这边的测试并未在available-replicas中，看它的评论里也有一些也是未出现在available-replicas中，这个地方可能还要再留意一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201906/733213-20190630224619157-118191326.png&quot; alt=&quot;&quot; width=&quot;710&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201906/733213-20190630224700303-805251659.png&quot; alt=&quot;&quot; width=&quot;703&quot; height=&quot;344&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、创建Eureka Client&lt;/p&gt;
&lt;p&gt;1、引入依赖&lt;/p&gt;
&lt;p&gt;这里先创建个服务提供者，也就是生产者。在创建时选中Eureka Client，项目会自动引入下面的spring-cloud-starter-netflix-eureka-client依赖。由于要提供服务，所以这里又引入了spring-boot-starter-web。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、启动代码中添加@EnableDiscoveryClient注解&lt;/p&gt;
&lt;p&gt;与上面添加@EnableEurekaServer类似，这里添加@EnableDiscoveryClient注解。&lt;/p&gt;
&lt;p&gt;3.配置文件&lt;/p&gt;
&lt;p&gt;这里提供配置了eureka交互地址，这里为两个，将服务注册到eureka两个实例中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
spring.application.name=spring-cloud-&lt;span&gt;producer
server.port&lt;/span&gt;=9000&lt;span&gt;
eureka.client.serviceUrl.defaultZone&lt;/span&gt;=http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:8000/eureka/,&lt;/span&gt;&lt;span&gt;http://localhost&lt;/span&gt;&lt;span&gt;:8001/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.增加服务HelloController&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4d91c7fb-5330-4bc0-a2c8-ef7ec7b0f0bf')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_4d91c7fb-5330-4bc0-a2c8-ef7ec7b0f0bf&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4d91c7fb-5330-4bc0-a2c8-ef7ec7b0f0bf&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4d91c7fb-5330-4bc0-a2c8-ef7ec7b0f0bf',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4d91c7fb-5330-4bc0-a2c8-ef7ec7b0f0bf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.demo;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestParam;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HelloController {
    @RequestMapping(&lt;/span&gt;&quot;/hello&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String index(@RequestParam String name) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;hello &quot;+name+&quot;，this is first messge&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;5.启动应用就可在&lt;a href=&quot;http://localhost:8000/&quot;&gt;http://localhost:8000/&lt;/a&gt;和&lt;a href=&quot;http://localhost:8001/&quot;&gt;http://localhost:8001/&lt;/a&gt;中看到最近注册到Eureka的实例spring-cloud-producer。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201906/733213-20190630230748259-1630538608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201906/733213-20190630230715088-17237993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 四、小结&lt;/p&gt;
&lt;p&gt;本篇主要了解了下什么是Eureka，它的作用，以及如何使用。主要学习Eureka服务端的配置和双节点配置，将Eureka client注册到Eureka server中，后续就是要学习如何调用生产者提供的服务了。&lt;/p&gt;
&lt;p&gt;最后再推荐下我的新书&amp;lt;&amp;lt;spring 快速入门&amp;gt;&amp;gt;，个人认为对与Spring初学者来说还是值得一读的，虽然之前也没有过Java的工作经验，写这本书的过程也是我二次复习巩固Spring的过程，我也是以初学者的角度来完成这本书的。本书目录在前面的博客中，&lt;a href=&quot;https://www.cnblogs.com/5ishare/p/10411976.html&quot; target=&quot;_blank&quot;&gt;可以点击查看&lt;/a&gt;。&lt;/p&gt;

</description>
<pubDate>Sun, 30 Jun 2019 15:24:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>在找.net core 微服务框架时发现了Steeltoe开源项目，它可以基于Spring Cloud实现.net core和.net Framework的微服务。正好之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/5ishare/p/11111621.html</dc:identifier>
</item>
<item>
<title>Electron构建一个文件浏览器应用(二) - 龙恩0707</title>
<link>http://www.cnblogs.com/tugenhua0707/p/11111747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tugenhua0707/p/11111747.html</guid>
<description>&lt;p&gt;在前一篇文章我们已经学习到了使用Electron来构建我们的文件浏览器了基础东西了，我们之前已经完成了界面功能和显示文件或文件夹的功能了，想看之前文章，请点击这个&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/11080473.html&quot; target=&quot;_blank&quot;&gt;链接&lt;/a&gt;  。现在我们需要在之前的基础上来继续完成余下的功能，我们之前的只完成了界面和显示文件夹或文件。那么这篇文章我们需要完成如下功能：&lt;/p&gt;
&lt;p&gt;1. 如果它是一个文件夹，我们可以对该文件夹进行双击，然后打开该文件夹。&lt;br/&gt;2. 当前文件夹就是刚刚我们双击的那个文件夹。&lt;br/&gt;3. 如果它内部有子文件夹的时候，我们也可以双击，然后重复第一步的操作步骤。&lt;/p&gt;
&lt;p&gt;那么在完成这些功能之前，我们先来整理一下我们的js文件，那么在整理之前，我们先来看看我们项目的整个目录架构是一个什么样，这样使我们更加的清晰。并且了解下我们各个文件的代码及作用，哪些文件具体做哪些事情的。这有助于我们更进一步来讲解其他方面的知识，使下面讲解的内容更通俗易解。&lt;/p&gt;
&lt;p&gt;下面是我们的整个目录架构的结构如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
|-----&lt;span&gt; 项目的根目录
&lt;/span&gt;|  |---&lt;span&gt; image                # 存放文件夹或文件图标
&lt;/span&gt;|  |---&lt;span&gt; node_modules         # 所有的依赖包
&lt;/span&gt;|  |---&lt;span&gt; .gitignore           # github排除文件
&lt;/span&gt;|  |---&lt;span&gt; app.css              # css文件
&lt;/span&gt;|  |---&lt;span&gt; app.js               # 功能实现代码的文件
&lt;/span&gt;|  |---&lt;span&gt; index.html           # html页面
&lt;/span&gt;|  |---&lt;span&gt; main.js              # electron界面启动代码
&lt;/span&gt;|  |--- package.json         
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上就是我们在&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/11080473.html&quot; target=&quot;_blank&quot;&gt;第一篇文章&lt;/a&gt;中项目目录结构，我们首先来看下我们的main.js 代码，该js文件最主要的是 启动electron桌面应用的程序，我们在package.json已经默认指定了该js文件就是我们默认要加载的文件。&lt;/p&gt;
&lt;p&gt;package.json 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;name&quot;: &quot;electron-filebrowser&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;version&quot;: &quot;1.0.0&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;description&quot;: &quot;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;main&quot;: &quot;main.js&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;scripts&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;&lt;span&gt;
  },
  &lt;/span&gt;&quot;author&quot;: &quot;&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;license&quot;: &quot;ISC&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;dependencies&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;async&quot;: &quot;^3.1.0&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;fs&quot;: &quot;0.0.1-security&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;osenv&quot;: &quot;^0.1.5&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;path&quot;: &quot;^0.12.7&quot;&lt;span&gt;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们来看下我们的main.js 文件代码，该文件的代码最主要的是 处理electron界面的启动，如下代码所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 全局模块的 electron模块&lt;/span&gt;
const electron = require('electron'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 electron应用对象的引用&lt;/span&gt;
&lt;span&gt;
const app &lt;/span&gt;=&lt;span&gt; electron.app;
const BrowserWindow &lt;/span&gt;=&lt;span&gt; electron.BrowserWindow;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定义变量 对应用视窗的引用 &lt;/span&gt;
let mainWindow = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听视窗关闭的事件（在Mac OS 系统下是不会触发该事件的）&lt;/span&gt;
app.on('window-all-closed', () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (process.platform !== 'darwin'&lt;span&gt;) {
    app.quit();
  }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将index.html 载入应用视窗中&lt;/span&gt;
app.on('ready', () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
   创建一个新的应用窗口，并将它赋值给 mainWindow变量。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  mainWindow &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BrowserWindow({
    webPreferences: {
      nodeIntegration: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
    }
  });

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加如下代码 可以调试&lt;/span&gt;
&lt;span&gt;  mainWindow.webContents.openDevTools();

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 载入 index.html 文件&lt;/span&gt;
  mainWindow.loadURL(`file:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${__dirname}/index.html`);&lt;/span&gt;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当应用被关闭的时候，释放 mainWindow变量的引用&lt;/span&gt;
  mainWindow.on('closed', () =&amp;gt;&lt;span&gt; {
    mainWindow &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;app.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在应用中加载node模块&lt;/span&gt;
const fs = require('fs'&lt;span&gt;);
const osenv &lt;/span&gt;= require('osenv'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 aysnc模块&lt;/span&gt;
const async = require('async'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入path模块&lt;/span&gt;
const path = require('path'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getUsersHomeFolder() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; osenv.home();
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 fs.readdir 来获取文件列表&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getFilesInFolder(folderPath, cb) {
  fs.readdir(folderPath, cb);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; inspectAndDescribeFile(filePath, cb) {
  let result &lt;/span&gt;=&lt;span&gt; {
    file: path.basename(filePath),
    path: filePath,
    type: &lt;/span&gt;''&lt;span&gt;
  };
  fs.stat(filePath, (err, stat) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      cb(err);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stat.isFile()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否是文件&lt;/span&gt;
        result.type = 'file'&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stat.isDirectory()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否是目录&lt;/span&gt;
        result.type = 'directory'&lt;span&gt;;
      }
      cb(err, result);
    }
  });
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; inspectAndDescribeFiles(folderPath, files, cb) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 async 模块调用异步函数并收集结果&lt;/span&gt;
  async.map(files, (file, asyncCB) =&amp;gt;&lt;span&gt; {
    const resolveFilePath &lt;/span&gt;=&lt;span&gt; path.resolve(folderPath, file);
    inspectAndDescribeFile(resolveFilePath, asyncCB);
  }, cb);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFile(file) {
  const mainArea &lt;/span&gt;= document.getElementById('main-area'&lt;span&gt;);
  const template &lt;/span&gt;= document.querySelector('#item-template'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建模板实列的副本&lt;/span&gt;
  let clone = document.importNode(template.content, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
  
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入文件名及对应的图标&lt;/span&gt;
  clone.querySelector('img').src = `images/${file.type}.svg`;
  clone.querySelector('.filename').innerText =&lt;span&gt; file.file;

  mainArea.appendChild(clone);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该函数的作用是显示文件列表信息&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFiles(err, files) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; alert('sorry, we could not display your files'&lt;span&gt;);
  }
  files.forEach(displayFile);
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 该函数的作用是：获取到用户个人文件夹的路径，并获取到该文件夹下的文件列表信息
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; main() {
  const folderPath &lt;/span&gt;=&lt;span&gt; getUsersHomeFolder();

  getFilesInFolder(folderPath, (err, files) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      console.log(&lt;/span&gt;'对不起，您没有加载您的home folder'&lt;span&gt;);
    }
    console.log(files);
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    files.forEach((file) =&amp;gt; {
      console.log(`${folderPath}/${file}`);
    });
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    inspectAndDescribeFiles(folderPath, files, displayFiles);
  });
}

window.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  main();
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上app.js 代码就是我们页面的功能代码，代码看起来有点混乱，因此我们需要把该文件中的代码分离出来。也就是说之前我们所有功能性的代码都放在我们的app.js代码里面，这样以后业务越来越复杂的时候，js代码将来会越来越臃肿，因此现在我们需要把该文件的功能性代码逻辑拆分开来。因此我们需要把它分成三个js文件，app.js, fileSystem.js, userInterface.js.&lt;/p&gt;
&lt;p&gt;app.js 还是负责入口文件。&lt;br/&gt;fileSystem.js 负责处理对用户计算机中的文件或文件夹进行操作。&lt;br/&gt;userInterface.js 负责处理界面上的交互。&lt;/p&gt;
&lt;p&gt;因此 fileSystem.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

const fs &lt;/span&gt;= require('fs'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 aysnc模块&lt;/span&gt;
const async = require('async'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入path模块&lt;/span&gt;
const path = require('path'&lt;span&gt;);
const osenv &lt;/span&gt;= require('osenv'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getUsersHomeFolder() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; osenv.home();
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 fs.readdir 来获取文件列表&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getFilesInFolder(folderPath, cb) {
  fs.readdir(folderPath, cb);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; inspectAndDescribeFile(filePath, cb) {
  let result &lt;/span&gt;=&lt;span&gt; {
    file: path.basename(filePath),
    path: filePath,
    type: &lt;/span&gt;''&lt;span&gt;
  };
  fs.stat(filePath, (err, stat) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      cb(err);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stat.isFile()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否是文件&lt;/span&gt;
        result.type = 'file'&lt;span&gt;;
      }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (stat.isDirectory()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断是否是目录&lt;/span&gt;
        result.type = 'directory'&lt;span&gt;;
      }
      cb(err, result);
    }
  });
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; inspectAndDescribeFiles(folderPath, files, cb) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用 async 模块调用异步函数并收集结果&lt;/span&gt;
  async.map(files, (file, asyncCB) =&amp;gt;&lt;span&gt; {
    const resolveFilePath &lt;/span&gt;=&lt;span&gt; path.resolve(folderPath, file);
    inspectAndDescribeFile(resolveFilePath, asyncCB);
  }, cb);
}

module.exports &lt;/span&gt;=&lt;span&gt; {
  getUsersHomeFolder,
  getFilesInFolder,
  inspectAndDescribeFiles
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;fileSystem.js文件把我们之前的app.js中的 getUsersHomeFolder(), getFilesInFolder(), inspectAndDescribeFile(),&lt;br/&gt;及 inspectAndDescribeFiles() 函数分离出来了，并且使用 module.exports 对暴露了 getUsersHomeFolder(), getFilesInFolder(), inspectAndDescribeFiles() 这三个函数。&lt;/p&gt;
&lt;p&gt;userInterface.js 文件中的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

let document;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFile(file) {
  const mainArea &lt;/span&gt;= document.getElementById('main-area'&lt;span&gt;);
  const template &lt;/span&gt;= document.querySelector('#item-template'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建模板实列的副本&lt;/span&gt;
  let clone = document.importNode(template.content, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
  
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入文件名及对应的图标&lt;/span&gt;
  clone.querySelector('img').src = `images/${file.type}.svg`;
  clone.querySelector('.filename').innerText =&lt;span&gt; file.file;

  mainArea.appendChild(clone);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该函数的作用是显示文件列表信息&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFiles(err, files) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; alert('sorry, we could not display your files'&lt;span&gt;);
  }
  files.forEach(displayFile);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bindDocument (window) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;document) {
    document &lt;/span&gt;=&lt;span&gt; window.document;
  }
}

module.exports &lt;/span&gt;=&lt;span&gt; {
  bindDocument,
  displayFiles
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在userInterface.js中我们暴露了 bindDocument 和 displayFiles 两个函数，bindDocument该函数的作用是将window.document 上下文传递进去，displayFiles函数的作用是将所有的文件显示出来。&lt;/p&gt;
&lt;p&gt;接下来就是我们的app.js 代码了，该文件需要引入我们刚刚 fileSystem.js 和 userInterface.js 的两个文件，因此我们的app.js 文件代码被简化成如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

const fileSystem &lt;/span&gt;= require('./fileSystem'&lt;span&gt;);
const userInterface &lt;/span&gt;= require('./userInterface'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 该函数的作用是：获取到用户个人文件夹的路径，并获取到该文件夹下的文件列表信息
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; main() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把window上下文传递进去&lt;/span&gt;
&lt;span&gt;  userInterface.bindDocument(window);

  const folderPath &lt;/span&gt;=&lt;span&gt; fileSystem.getUsersHomeFolder();

  fileSystem.getFilesInFolder(folderPath, (err, files) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
      console.log(&lt;/span&gt;'对不起，您没有加载您的home folder'&lt;span&gt;);
    }
    fileSystem.inspectAndDescribeFiles(folderPath, files, userInterface.displayFiles);
  });
}

window.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  main();
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;index.html 代码和之前一样不变，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;FileBrowser&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;link &lt;/span&gt;&lt;span&gt;rel&lt;/span&gt;&lt;span&gt;=&quot;stylesheet&quot;&lt;/span&gt;&lt;span&gt; href&lt;/span&gt;&lt;span&gt;=&quot;./app.css&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;template &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;item-template&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;item&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;img &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;='icon' &lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;filename&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;toolbar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;current-folder&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
      &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 该div元素是用来放置要显示的文件列表信息&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;main-area&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;./app.js&quot;&lt;/span&gt;&lt;span&gt; type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后我们在我们的项目根目录中运行 electron . 一样也可以看到之前一样的界面，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630230029659-1256305192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一：实现文件夹双击功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么我们如上代码重构完成后，我们现在需要实现我们对文件夹双击的功能了，那么需要实现该功能的话，我们需要在 userInterface.js 中添加如下几个函数来处理这些事情。&lt;/p&gt;
&lt;p&gt;1. 首先新增一个 displayFolderPath 函数，该函数的作用是更新界面中的当前文件夹路径。&lt;br/&gt;2. 还需要新增 clearView 函数，该函数的作用是：显示在主区域中的当前文件夹中的文件和清除文件夹。&lt;br/&gt;3. 还需要新增一个 loadDirectory函数，该函数的作用是：根据指定文件夹的路径，获取计算机中该路径下的文件或文件夹信息，&lt;br/&gt;并将其显示在应用界面的主区域中。&lt;br/&gt;4. 修改displayFiles函数，该函数的作用是：在文件夹图标上监听事件来触发加载该文件夹中的内容。&lt;/p&gt;
&lt;p&gt;因此我们的 userInterface.js 代码就变成如下了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

let document;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 fileSystem.js 中的模块代码&lt;/span&gt;
const fileSystem = require('./fileSystem'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新当前文件夹路径的函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFolderPath(folderPath) {
  document.getElementById(&lt;/span&gt;'current-folder').innerText =&lt;span&gt; folderPath;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移除 main-area div元素中的内容&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; clearView() {
  const mainArea &lt;/span&gt;= document.getElementById('main-area'&lt;span&gt;);
  let firstChild &lt;/span&gt;=&lt;span&gt; mainArea.firstChild;
  &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (firstChild) {
    mainArea.removeChild(firstChild);
    firstChild &lt;/span&gt;=&lt;span&gt; mainArea.firstChild;
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新文本框中文件夹路径，并且更新主区域中的内容&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; loadDirectory(folderPath) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (window) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;document) {
      document &lt;/span&gt;=&lt;span&gt; window.document;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新最上面的文本框中的文件夹路径&lt;/span&gt;
&lt;span&gt;    displayFolderPath(folderPath);
    fileSystem.getFilesInFolder(folderPath, (err, files) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先清除主区域中的内容&lt;/span&gt;
&lt;span&gt;      clearView();
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('sorry, you could not load your folder'&lt;span&gt;);
      }
      fileSystem.inspectAndDescribeFiles(folderPath, files, displayFiles);
    });
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFile(file) {
  const mainArea &lt;/span&gt;= document.getElementById('main-area'&lt;span&gt;);
  const template &lt;/span&gt;= document.querySelector('#item-template'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建模板实列的副本&lt;/span&gt;
  let clone = document.importNode(template.content, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
  
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入文件名及对应的图标&lt;/span&gt;
  clone.querySelector('img').src = `images/${file.type}.svg`;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要判断如果该文件是目录的话，需要对目录图片绑定双击事件&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (file.type === 'directory'&lt;span&gt;) {
    clone.querySelector(&lt;/span&gt;'img').addEventListener('dblclick', () =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们双击完成后，就需要加载该文件夹下所有目录的文件&lt;/span&gt;
&lt;span&gt;      loadDirectory(file.path)();
    }, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
  }

  clone.querySelector(&lt;/span&gt;'.filename').innerText =&lt;span&gt; file.file;

  mainArea.appendChild(clone);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 该函数的作用是显示文件列表信息&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFiles(err, files) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; alert('sorry, we could not display your files'&lt;span&gt;);
  }
  files.forEach(displayFile);
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bindDocument (window) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;document) {
    document &lt;/span&gt;=&lt;span&gt; window.document;
  }
}

module.exports &lt;/span&gt;=&lt;span&gt; {
  bindDocument,
  displayFiles,
  loadDirectory
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上就是我们的 userInterface函数添加的代码，我们仔细看下也是非常简单的代码，我相信大家都能够理解掉了，首先 displayFolderPath 这个函数，该函数的作用是显示我们 左上角文本框的路径，比如如下所示的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630230124099-1238389179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们 clearView 这个函数，该函数的作用是：清除主区域中所有的文件或文件夹。&lt;/p&gt;
&lt;p&gt;最后就是 loadDirectory 这个函数，该函数首先会调用displayFolderPath函数，来更新我们的左上角输入框文件路径。期次就是调用 fileSystem.inspectAndDescribeFiles 函数来重新渲染主区域中的所有文件。&lt;/p&gt;
&lt;p&gt;给这个 displayFile 函数，判断当前目录是不是文件夹，如果是文件夹的话，对该文件夹图标绑定了双击事件，双击后我们又调用了 loadDirectory 函数，重新更新左上角输入框文件夹路径，并且重新渲染主区域中的内容。&lt;/p&gt;
&lt;p&gt;现在我们需要修改app.js 中的代码了，让他调用 userInterface.js 文件中的loadDirectory函数。重新初始化主区域内容，且更新左上角的输入框的文件夹路径。因此我们的app.js 代码更改成如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

const fileSystem &lt;/span&gt;= require('./fileSystem'&lt;span&gt;);
const userInterface &lt;/span&gt;= require('./userInterface'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 该函数的作用是：获取到用户个人文件夹的路径，并获取到该文件夹下的文件列表信息
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; main() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把window上下文传递进去&lt;/span&gt;
&lt;span&gt;  userInterface.bindDocument(window);

  const folderPath &lt;/span&gt;=&lt;span&gt; fileSystem.getUsersHomeFolder();

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
  fileSystem.getFilesInFolder(folderPath, (err, files) =&amp;gt; {
    if (err) {
      console.log('对不起，您没有加载您的home folder');
    }
    fileSystem.inspectAndDescribeFiles(folderPath, files, userInterface.displayFiles);
  });
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  userInterface.loadDirectory(folderPath)(window);
}

window.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  main();
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上所有的文件更改完成后，我们现在再来重启我们的应用程序，在项目中的根目录 运行 electron . 命运后即可重启，当我们双击应用中的某个文件夹时，就能看到工具条中当前文件夹路径发送改变了，并且该文件夹下所有子目录也会更新了。&lt;br/&gt;首先我们看下我们页面初始化的时候，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630230232458-1331692287.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后当我们点击我 工作文档 文件夹时候，会看到会更新工具条中的路径，并且子目录也会得到更新了。如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630230250811-1691009921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二：实现快速搜索&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们目录中有很多很多文件及文件夹，但是当我们想要找某个文件夹的时候，我们很不方便，因此我们现在需要一个搜索框，我们只要搜索下我们目录下的某个文件就能找到，因此我们现在需要这么一个功能，因此第一步我们需要在我们应用项目中的右上角添加一个搜索框。我们需要实现如下功能：&lt;/p&gt;
&lt;p&gt;1. 在我们的工具条的右上角添加一个搜索框。&lt;br/&gt;2. 引入一个内存搜索库来对文件或文件夹进行搜索。&lt;br/&gt;3. 将当前文件夹中的文件和文件夹信息加入搜索索引。&lt;br/&gt;4. 用户开始搜索时，会对主区域显示的文件进行过滤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1 在工具条中增加搜索框&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们需要在 index.html 中的 current-folder div元素后面插入如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;search&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;search&quot;&lt;/span&gt;&lt;span&gt; results&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;Search&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因此html部分代码变成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;toolbar&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;current-folder&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;input &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;search&quot;&lt;/span&gt;&lt;span&gt; id&lt;/span&gt;&lt;span&gt;=&quot;search&quot;&lt;/span&gt;&lt;span&gt; results&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; placeholder&lt;/span&gt;&lt;span&gt;=&quot;Search&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们在我们的 app.css 代码中加入如下样式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#search &lt;/span&gt;{&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; right&lt;/span&gt;;&lt;span&gt;
  padding&lt;/span&gt;:&lt;span&gt; 0.5em&lt;/span&gt;;&lt;span&gt;
  min-width&lt;/span&gt;:&lt;span&gt; 10em&lt;/span&gt;;&lt;span&gt;
  border-radius&lt;/span&gt;:&lt;span&gt; 3em&lt;/span&gt;;&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt; 2em 1em&lt;/span&gt;;&lt;span&gt;
  border&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;&lt;span&gt;
  outline&lt;/span&gt;:&lt;span&gt; none&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入后，我们再来运行下我们的应用程序，使用命令 electron . ，会看到如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630230434552-1046793742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2 引入一个内存搜索库&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;上面我们已经通过html+css在我们的工具条右侧添加了一个搜索框，现在我们要做的事情就是通过一个搜索库来对文件或文件夹列表进行搜索。值得幸运的是，网上已经有一款叫 Iunr.js 客户端搜索库了，它支持对文件或文件夹列表进行索引，我们可以通过索引进行搜索。因此我们需要在我们项目中根目录命令行中来安装该模块了，如下npm命令安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm i lunr --save
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们需要在我们的项目根目录下新建一个叫 search.js 文件，该文件最主要的作用是处理搜索。&lt;/p&gt;
&lt;p&gt;因此我们再来看下我们整个目录架构变成如下这个样子了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
|-----&lt;span&gt; 项目的根目录
&lt;/span&gt;|  |---&lt;span&gt; image                # 存放文件夹或文件图标
&lt;/span&gt;|  |---&lt;span&gt; node_modules         # 所有的依赖包
&lt;/span&gt;|  |---&lt;span&gt; .gitignore           # github排除文件
&lt;/span&gt;|  |---&lt;span&gt; app.css              # css文件
&lt;/span&gt;|  |---&lt;span&gt; app.js               # 功能实现代码的文件的入口
&lt;/span&gt;|  |---&lt;span&gt; index.html           # html页面
&lt;/span&gt;|  |---&lt;span&gt; main.js              # electron界面启动代码
&lt;/span&gt;|  |---&lt;span&gt; fileSystem.js        # 处理文件操作的js
&lt;/span&gt;|  |---&lt;span&gt; userInterface.js     # 处理应用程序界面的js
&lt;/span&gt;|  |---&lt;span&gt; search.js            # 处理文件搜索的js
&lt;/span&gt;|  |--- package.json      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;想要了解 lunr 库的使用方法，请看这篇文章（&lt;a href=&quot;http://www.uedsc.com/lunr-js.html&quot; target=&quot;_blank&quot;&gt;http://www.uedsc.com/lunr-js.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;因此我们的search.js 代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入 lunr 包进来&lt;/span&gt;
const lunr = require('lunr'&lt;span&gt;);

let index;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 重置搜索的索引函数&lt;/span&gt;

&lt;span&gt;function&lt;/span&gt;&lt;span&gt; resetIndex() {
  index &lt;/span&gt;= lunr(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.field('file'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.field('type'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ref('path'&lt;span&gt;);
  });
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加对文件的索引，用于后续的搜索&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; addToIndex(file) {
  index.add(file);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对一个指定的文件进行查询&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; find(query, cb) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;index) {
    resetIndex();
  }
  const results &lt;/span&gt;=&lt;span&gt; index.search(query);
  cb(results);
}

module.exports &lt;/span&gt;=&lt;span&gt; {
  addToIndex,
  find,
  resetIndex
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们搜索库已经引入了，并且代码也编写完成后，我们现在要做的事情就是如何来监听我们的搜索框的事件了，那么需要使用的'keyup' 事件来监听，因此我们需要在 userInterface.js 文件中添加如下一个函数，并且把该函数暴露出去。如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听搜索函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bindSearchField(cb) {
  document.getElementById(&lt;/span&gt;'search').addEventListener('keyup', cb, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
}

module.exports &lt;/span&gt;=&lt;span&gt; {
  bindDocument,
  displayFiles,
  loadDirectory,
  bindSearchField
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码就是监听搜索框 的keyup的事件了，当我们每次搜索的时候，鼠标keyup的时候，就会触发一个cb函数，那么触发cb函数的时候，我们需要获取输入框的值，然后把该值传递进去查询。如果没有值的话，那么不进行文件搜索，如果有值的话，我们需要进行文件搜索，现在要实现这个搜索，我们需要完成如下事情：&lt;/p&gt;
&lt;p&gt;1. 当我们的搜索框没有值的时候，确保所有的文件都显示在主区域中。&lt;br/&gt;2. 当搜索框中有值的时候，我们需要根据该值进行查询及过滤且显示出来。&lt;br/&gt;3. 当搜索到某个文件夹的时候，我们需要将该文件夹的所有的内容显示在主区域中，并且重置该索引值。&lt;br/&gt;4. 当有新文件要显示在主区域中，需要将它添加到索引中。&lt;/p&gt;
&lt;p&gt;因此首先我们需要在我们的 userInterface.js 文件中需要引入我们的search.js ，引入后我们就可以访问search模块了。&lt;/p&gt;
&lt;p&gt;引入完成后，我们需要改js中的 loadDirectory 函数，该函数的作用我们之前也讲解过，就是更新左侧文本框的文件路径，并且更新主区域中的内容，因此在该函数内部，我们每次调用该函数的时候都需要重置搜索索引，这样做的目的是能实现只针对当前文件夹内容进行搜索。因此loadDirectory函数代码改成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入search模块&lt;/span&gt;
const search = require('search'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新文本框中文件夹路径，并且更新主区域中的内容&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; loadDirectory(folderPath) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (window) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;document) {
      document &lt;/span&gt;=&lt;span&gt; window.document;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加重置搜索索引的函数调用&lt;/span&gt;
&lt;span&gt;    search.resetIndex();

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新最上面的文本框中的文件夹路径&lt;/span&gt;
&lt;span&gt;    displayFolderPath(folderPath);
    fileSystem.getFilesInFolder(folderPath, (err, files) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先清除主区域中的内容&lt;/span&gt;
&lt;span&gt;      clearView();
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('sorry, you could not load your folder'&lt;span&gt;);
      }
      fileSystem.inspectAndDescribeFiles(folderPath, files, displayFiles);
    });
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上更改完成后，我们需要更改下 displayFile 函数，在该函数中添加如下功能：&lt;/p&gt;
&lt;p&gt;1. 把文件添加到搜索索引中的代码。&lt;br/&gt;2. 将文件路径保存在图片元素的data-filePath属性中，这样的话，在文件过滤的时候，我们可以根据该属性值来过滤或显示元素。&lt;/p&gt;
&lt;p&gt;因此 displayFile 函数代码变成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFile(file) {
  const mainArea &lt;/span&gt;= document.getElementById('main-area'&lt;span&gt;);
  const template &lt;/span&gt;= document.querySelector('#item-template'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建模板实列的副本&lt;/span&gt;
  let clone = document.importNode(template.content, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
  
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将文件添加到搜索索引中&lt;/span&gt;
&lt;span&gt;  search.addToIndex(file);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将文件路径保存在图片元素的data-filePath属性中&lt;/span&gt;
  clone.querySelector('img').setAttribute('data-filePath'&lt;span&gt;, file.path);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入文件名及对应的图标&lt;/span&gt;
  clone.querySelector('img').src = `images/${file.type}.svg`;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要判断如果该文件是目录的话，需要对目录图片绑定双击事件&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (file.type === 'directory'&lt;span&gt;) {
    clone.querySelector(&lt;/span&gt;'img').addEventListener('dblclick', () =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们双击完成后，就需要加载该文件夹下所有目录的文件&lt;/span&gt;
&lt;span&gt;      loadDirectory(file.path)();
    }, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
  }

  clone.querySelector(&lt;/span&gt;'.filename').innerText =&lt;span&gt; file.file;

  mainArea.appendChild(clone);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上displayFile函数的作用是把所有的文件夹显示在主区域中，并且绑定了文件夹的双击事件，并且我们把文件添加到索引中了，并且将文件路径保存到图片元素的 data-filePath属性中。&lt;/p&gt;
&lt;p&gt;现在我们需要新增一个函数用于处理在界面上显示搜索的结果的函数，该函数首先要获取到主区域中显示的文件或文件夹的路径，然后判断该路径是否满足用户在搜索框中条件，如果满足的话，直接过滤掉不满足的条件，显示出来，因此我们在 userInterface.js文件中后面新增一个函数，比如叫 filterResults函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; filterResults(results) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取搜索结果中的文件路径用于对比&lt;/span&gt;
  const validFilePaths = results.map((result) =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result.ref;
  });
  const items &lt;/span&gt;= document.getElementsByClassName('item'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; items.length; i++&lt;span&gt;) {
    let item &lt;/span&gt;=&lt;span&gt; items[i];
    let filePath &lt;/span&gt;= item.getElementsByTagName('img')[0].getAttribute('data-filePath'&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 文件路径匹配搜索结果&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (validFilePaths.indexOf(filePath) !== -1&lt;span&gt;) {
      item.style &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      item.style &lt;/span&gt;= 'display:none;'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果没有匹配到，则将其掩藏掉 &lt;/span&gt;
&lt;span&gt;    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面函数编写完成后，我们还需要编写一个函数用于处理重置过滤结果的情况，当我们搜索框值为空的时候，我们需要调用该函数来显示文件出来。我们可以把该函数名叫 resetFilter函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; resetFilter() {
  const items &lt;/span&gt;= document.getElementsByClassName('item'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let i = 0; i &amp;lt; items.length; i++&lt;span&gt;) {
    items[i].style &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数编写完成后，我们还需要将该两个函数暴露出去，因此代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  bindDocument,
  displayFiles,
  loadDirectory,
  bindSearchField,
  filterResults,
  resetFilter
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;userInterface.js 代码已经完成后，我们现在需要在我们的app.js上更新代码，现在我们的app.js文件需要做如下事情：&lt;/p&gt;
&lt;p&gt;1. 在界面上需要监听搜索框。&lt;br/&gt;2. 将搜索关键词传给Iunr搜索工具。&lt;br/&gt;3. 将搜索工具处理完的结果显示到界面上。&lt;/p&gt;
&lt;p&gt;因此app.js 代码变成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
'use strict'&lt;span&gt;;

const fileSystem &lt;/span&gt;= require('./fileSystem'&lt;span&gt;);
const userInterface &lt;/span&gt;= require('./userInterface'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 引入search模块&lt;/span&gt;
const search = require('./search'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 该函数的作用是：获取到用户个人文件夹的路径，并获取到该文件夹下的文件列表信息
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; main() {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把window上下文传递进去&lt;/span&gt;
&lt;span&gt;  userInterface.bindDocument(window);

  const folderPath &lt;/span&gt;=&lt;span&gt; fileSystem.getUsersHomeFolder();

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新文本框中文件夹路径，并且更新主区域中的内容, 并且重置搜索索引的函数调用&lt;/span&gt;
&lt;span&gt;  userInterface.loadDirectory(folderPath)(window);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听搜索框值的变化&lt;/span&gt;
  userInterface.bindSearchField((event) =&amp;gt;&lt;span&gt; {
    const val &lt;/span&gt;=&lt;span&gt; event.target.value;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (val === ''&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果搜索框中的值为空的情况下, 重置过滤结果&lt;/span&gt;
&lt;span&gt;      userInterface.resetFilter();
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
       如果搜索框中有值的话，将该值传递到搜索模块的find函数处理并过滤结果显示在界面上
      &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      search.find(val, userInterface.filterResults);
    }
  });
}

window.onload &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
  main();
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们在我们文件的根目录搜索 tuge 的内容的话，可以看到如下所示的过滤：如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630231030633-40444558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后现在我们把搜索条件清空的话，我们又可以看到所有的目录了，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630231046980-1449373292.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们再继续点击 工作文档，进入该目录后，我们在该目录下继续搜索 18 这样的时候，我们可以看到如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630231100630-660848621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们接着清空内容后，我们就可以看到 工作文档 目录下的所有内容了，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630231113441-529254796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三：添加后退功能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如上我们已经实现了文件或文件夹搜索功能及显示用户文件夹的详细路径，并且还可以双击文件夹进入内部的功能，现在我们还需要实现后退功能，我们双击完成后进入文件夹内部，我们这个时候想后退的话不能后退，因此我们现在要实现这样的功能。&lt;/p&gt;
&lt;p&gt;想实现回退功能，我们又没有和浏览器那样有后退按钮，因此我们这边想实现后退功能，我们可以点击文件夹路径后退即可，也就是说我们需要实现每个文件夹路径可点击功能。比如如下图对应的路径点击即可：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630231152219-1755169252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现当前文件夹路径可单击&lt;/p&gt;
&lt;p&gt;如上图一串路径，我们希望点击某一个路径的时候，希望切换到对应的文件夹那个地方，并且显示文件夹下的所有内容，就像网页链接一样的。我们看下我们左侧的路径的源码可以看到，它是一个div元素显示路径的，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630231205730-1259786373.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们来看下我们的工具条上显示当前文件夹路径的代码，在我们的userInterface.js中，有个函数，如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新当前文件夹路径的函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFolderPath(folderPath) {
  document.getElementById(&lt;/span&gt;'current-folder').innerText =&lt;span&gt; folderPath;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把路径赋值给id为current-folder元素上，现在我们需要做的是，不再是把路径赋值该div元素上，而是希望把该路径传递给另一个函数去，然后该函数使用split分隔符分割('/')这样的变成一个数组，然后遍历这个数组，把它对应的文件名使用span标签，也就是每个文件夹路径使用span标签包围起来，并且在该span标签上设置一个属性，比如叫 data-path 这样的，该属性值就是该文件夹的具体路径，现在我们需要做这些事情了。&lt;/p&gt;
&lt;p&gt;我们需要接受folderPath路径字符串的函数，比如我们现在叫 convertFolderPathIntoLinks 这个函数，把它放到我们的 userInterface.js 中，该函数最主要做的事情就是分割路径，并且把各个路径使用span标签包围起来，因此我们需要引用path模块进来，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const path = require('path');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Mac OS 和 linux中，路径分隔符是斜杠(/), 但是在windows中，它是反斜杠(\), 因此我们需要使用path模块的 path.sep 来获取分隔符。&lt;/p&gt;
&lt;p&gt;convertFolderPathIntoLinks函数代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; convertFolderPathIntoLinks(folderPath) {
  const folders &lt;/span&gt;=&lt;span&gt; folderPath.split(path.sep);
  const contents &lt;/span&gt;=&lt;span&gt; [];
  let pathAtFolder &lt;/span&gt;= ''&lt;span&gt;;
  folders.forEach((folder) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    pathAtFolder &lt;/span&gt;+= folder +&lt;span&gt; path.sep;
    const str &lt;/span&gt;= `&amp;lt;span class=&quot;path&quot; data-path=&quot;${pathAtFolder.slice(0, -1)}&quot;&amp;gt;${folder}&amp;lt;/span&amp;gt;`;
&lt;span&gt;    contents.push(str);
  });
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; contents.join(path.sep).toString();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上函数接收 文件夹的路径作为参数，我们会根据该路径上的分隔符将其变为一个包含路径上文件名的列表，有该列表，我们就可以对其中每个文件夹名创建一个span标签。每个span标签包含一个名为path的类名以及一个data-path属性保存当前文件夹的路径。最后文件夹的名字以文本的形式包含在span标签中。我们把所有的span标签存入一个数组 contents中，最后使用 分隔符分割，把数组的内容以字符串的形式返回回来。&lt;/p&gt;
&lt;p&gt;我们之前的 displayFolderPath 函数的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新当前文件夹路径的函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFolderPath(folderPath) {
  document.getElementById(&lt;/span&gt;'current-folder').innerText =&lt;span&gt; folderPath;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们要把代码改成如下了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新当前文件夹路径的函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFolderPath(folderPath) {
  document.getElementById(&lt;/span&gt;'current-folder').innerHTML =&lt;span&gt; convertFolderPathIntoLinks(folderPath);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么这样的话，我们的 div中的id为 current-folder 元素就包含span标签了，并且每个span标签上都有 data-path 这个属性，我们再来运行下我们的代码可以看到如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630231446965-1661231230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;span标签我们已经弄好了，我们现在需要的是再增加一个函数，该函数的作用是用于监听单击文件夹名的操作，并将单击的文件夹路径传递给回调函数，回调函数接收到我们单击的文件夹路径后，将其传递给负责显示文件夹内容的函数。我们把该函数名取为：bindCurrentFolderPath. 因此代码添加如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bindCurrentFolderPath() {
  const load &lt;/span&gt;= (event) =&amp;gt;&lt;span&gt; {
    const folderPath &lt;/span&gt;= event.target.getAttribute('data-path'&lt;span&gt;);
    loadDirectory(folderPath)();
  }
  const paths &lt;/span&gt;= document.getElementsByClassName('path'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i &amp;lt; paths.length; i++&lt;span&gt;) {
    paths[i].addEventListener(&lt;/span&gt;'click', load, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
  }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新当前文件夹路径的函数&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFolderPath(folderPath) {
  document.getElementById(&lt;/span&gt;'current-folder').innerHTML =&lt;span&gt; convertFolderPathIntoLinks(folderPath);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用绑定事件&lt;/span&gt;
&lt;span&gt;  bindCurrentFolderPath();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码实现完成后，我们再来重新下我们的运用程序，就可以看到效果了，我们点击某一个文件夹进去的时候，再点击路径上的某一个文件夹即可返回到上一个页面，就可以看到效果了。&lt;/p&gt;
&lt;p&gt;我们需要添加一个简单的样式，就是说就是当我们鼠标光标悬停到span元素上的时候，将鼠标光标显示为手状形式。我们需要在我们的app.css 添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;span.path:hover {
  opacity: &lt;/span&gt;0.7&lt;span&gt;;
  cursor: pointer;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;四：实现打开其他的文件(比如文本文件，视频及文档等)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们之前所有的功能是针对文件夹来做的，现在我们还要针对文件，图片，视频，文档等这些类型的文件实现点击功能，要实现这些，我们需要实现单击文件的功能。&lt;br/&gt;因此我们需要在我们的 userInterface.js 文件中，在displayFile函数中，添加else代码；如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; displayFile(file) {
  const mainArea &lt;/span&gt;= document.getElementById('main-area'&lt;span&gt;);
  const template &lt;/span&gt;= document.querySelector('#item-template'&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建模板实列的副本&lt;/span&gt;
  let clone = document.importNode(template.content, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
  
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将文件添加到搜索索引中&lt;/span&gt;
&lt;span&gt;  search.addToIndex(file);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将文件路径保存在图片元素的data-filePath属性中&lt;/span&gt;
  clone.querySelector('img').setAttribute('data-filePath'&lt;span&gt;, file.path);

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加入文件名及对应的图标&lt;/span&gt;
  clone.querySelector('img').src = `images/${file.type}.svg`;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 需要判断如果该文件是目录的话，需要对目录图片绑定双击事件&lt;/span&gt;
  &lt;span&gt;if&lt;/span&gt; (file.type === 'directory'&lt;span&gt;) {
    clone.querySelector(&lt;/span&gt;'img').addEventListener('dblclick', () =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 我们双击完成后，就需要加载该文件夹下所有目录的文件&lt;/span&gt;
&lt;span&gt;      loadDirectory(file.path)();
    }, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不属于文件夹以外的文件，比如文本文件，文档等&lt;/span&gt;
    clone.querySelector('img').addEventListener('dblclick', () =&amp;gt;&lt;span&gt; {
      fileSystem.openFile(file.path);
    })
  }

  clone.querySelector(&lt;/span&gt;'.filename').innerText =&lt;span&gt; file.file;

  mainArea.appendChild(clone);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上代码，我们的else里面实现了除了文件夹以外的文件也可以进行双击操作，并且在回调函数中我们调用了 fileSystem.js 模块中的openFile函数，因此我们需要实现 openFile函数的代码。那么该函数需要调用 shell API。shell API 能够使用系统默认的应用打开URL，文件以及其他类型的文档。因此在fileSystem.js 文件中，我们需要添加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const shell = require('electron'&lt;span&gt;).shell;

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; openFile(filePath) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用shell API的openItem函数&lt;/span&gt;
&lt;span&gt;  shell.openItem(filePath);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;并且导出函数中需要添加 openFile ，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
module.exports =&lt;span&gt; {
  getUsersHomeFolder,
  getFilesInFolder,
  inspectAndDescribeFiles,
  openFile
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们基本功能已经完成了，我们现在还需要当我们鼠标移动到文件或文件夹的时候，我们需要让他变成鼠标的形式，因此我们需要在我们的app.css中加如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;img:hover &lt;/span&gt;{&lt;span&gt;
  opacity&lt;/span&gt;:&lt;span&gt; 0.7&lt;/span&gt;;&lt;span&gt;
  cursor&lt;/span&gt;:&lt;span&gt; pointer&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在我们所有的代码已经完成了，我们接下来重新启动下我们的应用程序，在项目的根目录中使用命令 electron . 即可打开我们的应用程序了。我们可以双击点击不属于文件夹的文件，也可以使用我们的shell默认方式打开文件了。如下所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/561794/201906/561794-20190630231758315-1418098804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tugenhua0707/electron-demo/tree/master/electron-fileBrowser2&quot; target=&quot;_blank&quot;&gt;github源码查看&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 30 Jun 2019 15:19:00 +0000</pubDate>
<dc:creator>龙恩0707</dc:creator>
<og:description>Electron构建一个文件浏览器应用(二)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tugenhua0707/p/11111747.html</dc:identifier>
</item>
</channel>
</rss>