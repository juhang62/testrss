<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入SQL Server 日期和时间的内部存储 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/10208322.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/10208322.html</guid>
<description>&lt;p&gt;在SQL Server的内部存储中，日期和时间不是以字符串的形式存储的，而是使用整数来存储的。使用特定的格式来区分日期部分和时间部分的偏移量，并通过基准日期和基准时间来还原真实的数据。&lt;/p&gt;
&lt;h2&gt;一，DateTime的内部存储&lt;/h2&gt;
&lt;p&gt;SQL Server存储引擎把DateTime类型存储为2个int32类型，共8个字节，第一个int32 整数（前4个字节）存储的是日期相对于基准日期（1900-01-01）的偏移量。基准日期是1900-01-01，当前4 字节为0 时，表示的日期是1900 年1 月1 日。第二个int32整数（后4个字节）存储的是午夜（00:00:00.000）之后的时钟滴答数，每个滴答为1⁄300秒，精确度为3.33毫秒（0.00333秒，3.33ms），因此，DateTime能够表示的时间，可能会存在一个滴答的时间误差。&lt;/p&gt;
&lt;p&gt;DateTime的内部存储格式，用十六进制表示是：DDDDTTTT&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DDDD：占用2个字节，表示对基准日期的偏移量&lt;/li&gt;
&lt;li&gt;TTTT：占用两个字节，表示对午夜之后的始终滴答数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子，对于如下的日期和时间，把DateTime类型转换为大小为8个字节的16进制，每两个数字对应1个字节：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@dt&lt;/span&gt; &lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2015-05-07 10:05:23.187&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; date_time_binary
&lt;/span&gt;&lt;span&gt;--output &lt;/span&gt;&lt;span&gt;0x0000A49100A6463C&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1，拆分出date和time&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把时间的二进制格式中的字节拆分成两部分：前4个字节表示date，后4个字节表示time，得出的结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@dt&lt;/span&gt; &lt;span&gt;datetime&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2015-05-07 10:05:23.187&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;select&lt;/span&gt; &lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; date_binary,
   &lt;/span&gt;&lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; date_int,
   &lt;/span&gt;&lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt&lt;/span&gt;), &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; time_binary,
   &lt;/span&gt;&lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt&lt;/span&gt;), &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; time_int;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201912/628084-20191203174427924-345542742.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 2，通过偏移量还原日期和时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过基准时间和偏移量，把整数还原为原始的日期和时间：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@Time&lt;/span&gt; time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;00:00:00.000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@Date&lt;/span&gt; date&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1900-01-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;select&lt;/span&gt; &lt;span&gt;dateadd&lt;/span&gt;(&lt;span&gt;day&lt;/span&gt;, &lt;span&gt;42129&lt;/span&gt;, &lt;span&gt;@Date&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; originl_date
    , &lt;/span&gt;&lt;span&gt;dateadd&lt;/span&gt;(ms,&lt;span&gt;10896956&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;@Time&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; original_time
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201912/628084-20191203180355497-2007150988.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二，DateTime2的内部存储&lt;/h2&gt;
&lt;p&gt;DateTime2(n)数据类型存储日期和时间，它是DateTime的升级版本，由于小数秒n的精度可以自主设置，其存储大小（Storage Size）不固定，DateTime2(n)占用的存储空间和小数秒的精度之间的关系是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DateTime2(n)内部存储的第一个字节存储精度n，后续的字节用于存储日期和时间的值。&lt;/li&gt;
&lt;li&gt;当小数秒的精度 n &amp;lt; 3 时，总的存储空间是1B（精度）+6 B（数据）；&lt;/li&gt;
&lt;li&gt;当小数秒的精度 n 是 3 - 4 时，总的存储空间是1B（精度）+ 7B（数据）；&lt;/li&gt;
&lt;li&gt;当小数秒的精度 n 是 5 - 7 时，总的存储空间是1B（精度）+ 8B（数据），最大的小数秒精度是7，默认值是7；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1，二进制逆序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在探索DateTime2(n)的内部存储之前，先了解一下字节存储的“小端”格式和“大端”格式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;大端格式：&lt;/strong&gt;是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;小端格式：&lt;/strong&gt;是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个例子，假如内存地址左边是地位，右边是高位，对于数字275，使用两个字节来存储：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果采用大端格式：字节序列是0x0113&lt;/li&gt;
&lt;li&gt;如果采用小端格式：字节序列是0x1301&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;DateTime2(n)的内部存储格式使用的是小端格式，这种格式适合CPU的运算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，DateTime2的存储格式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DateTime2(n)的内部存储格式是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一字节存储的精度n，&lt;/li&gt;
&lt;li&gt;后三个字节记录从基准日期0001-01-01之后的多少天，采用小端格式。&lt;/li&gt;
&lt;li&gt;中间余下的字节记录子夜之后经过的时间单位间隔（time unit interval，TUI）的数量，采用小端格式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;TUI是由精度来控制的，每一个TUI是10的n次方之一秒，也就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于 DateTime2(7)，TUI是100ns；&lt;/li&gt;
&lt;li&gt;对于 DateTime2(6)，TUI是1微秒（=1000ns）；&lt;/li&gt;
&lt;li&gt;对于 DateTime2(5)，TUI是10微秒；&lt;/li&gt;
&lt;li&gt;对于 DateTime2(4)，TUI是100微秒；&lt;/li&gt;
&lt;li&gt;对于 DateTime2(3)，TUI是1ms（1毫秒=1000微秒）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为了便于运算，把DateTime2(n) 的字节流逆序排列：前3个字节表示的是天数，最后一个字节表示的是精度，中间余下的字节表示的TUI的数量。例如，对于 DateTime2(7)按照字节流逆序处理之后，存储空间是9个字节：前三个字节是存储的从基准日期0001-01-01之后的多少天，最后一位是精度n，中间的5个字节表示从子夜开始有多少个TUI。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2，把DateTime2转换为二进制存储&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把DateTime2转换为二进制存储，并作逆序处理，DateTime2(3)的精度为3，存储空间是8个字节，后三个字节记录从基准日期0001-01-01之后的多少天，前3个字节表示从子夜开始有多少个TUI。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@dt&lt;/span&gt; datetime2(&lt;span&gt;3&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2015-05-07 10:05:23.187&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@dt_bi&lt;/span&gt; &lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;), &lt;span&gt;@dt&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@dt_bi&lt;/span&gt; &lt;span&gt;as&lt;/span&gt;&lt;span&gt; date_time_binary
    ,&lt;/span&gt;&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;),&lt;span&gt;reverse&lt;/span&gt;(&lt;span&gt;@dt_bi&lt;/span&gt;)) &lt;span&gt;as&lt;/span&gt; reverse_binary
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201912/628084-20191203230119305-744097797.png&quot; alt=&quot;&quot; width=&quot;283&quot; height=&quot;46&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把二进制值拆分成DateTime2(3)的各个组成成分：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@dt&lt;/span&gt; datetime2(&lt;span&gt;3&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2015-05-07 10:05:23.187&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@dt_bi&lt;/span&gt; &lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;), &lt;span&gt;@dt&lt;/span&gt;&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@dt_bi_littleEnd&lt;/span&gt; &lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;@dt_bi_littleEnd&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;max&lt;/span&gt;),&lt;span&gt;reverse&lt;/span&gt;(&lt;span&gt;@dt_bi&lt;/span&gt;&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt_bi_littleEnd&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; date_binary,
   &lt;/span&gt;&lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt_bi_littleEnd&lt;/span&gt;), &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; date_int,
   &lt;/span&gt;&lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt_bi_littleEnd&lt;/span&gt;), &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; time_binary,
   &lt;/span&gt;&lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt_bi_littleEnd&lt;/span&gt;), &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; time_int,
   &lt;/span&gt;&lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt_bi_littleEnd&lt;/span&gt;), &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; precision_binary,
   &lt;/span&gt;&lt;span&gt;cast&lt;/span&gt;(&lt;span&gt;substring&lt;/span&gt;(&lt;span&gt;convert&lt;/span&gt;(&lt;span&gt;varbinary&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;), &lt;span&gt;@dt_bi_littleEnd&lt;/span&gt;), &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; precision_int;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201912/628084-20191203230545250-770052364.png&quot; alt=&quot;&quot; width=&quot;406&quot; height=&quot;40&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，利用偏移量和基准还原原始值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了偏移量，就可以在基准日期和时间之上加上偏移量来获得原始值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@Time&lt;/span&gt; time&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;00:00:00.000&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;declare&lt;/span&gt; &lt;span&gt;@Date&lt;/span&gt; date&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0001-01-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&lt;span&gt;select&lt;/span&gt; &lt;span&gt;dateadd&lt;/span&gt;(&lt;span&gt;day&lt;/span&gt;, &lt;span&gt;735724&lt;/span&gt;, &lt;span&gt;@Date&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; originl_date
    , &lt;/span&gt;&lt;span&gt;dateadd&lt;/span&gt;(ms,&lt;span&gt;36323187&lt;/span&gt;, &lt;span&gt;@Time&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; original_time
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/628084/201912/628084-20191203230831000-2135515828.png&quot; alt=&quot;&quot; width=&quot;171&quot; height=&quot;37&quot;/&gt; &lt;/p&gt;


&lt;p&gt;参考文档：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sqlfascination.com/2009/10/11/what-is-the-sql-server-2008-datetime2-internal-structure/&quot; target=&quot;_blank&quot;&gt;What is the SQL Server 2008 DateTime2 Internal Structure?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.red-gate.com/simple-talk/sql/t-sql-programming/how-to-get-sql-server-dates-and-times-horribly-wrong/&quot; target=&quot;_blank&quot;&gt;How to Get SQL Server Dates and Times Horribly Wrong&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Dec 2019 00:38:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>在SQL Server的内部存储中，日期和时间不是以字符串的形式存储的，而是使用整数来存储的。使用特定的格式来区分日期部分和时间部分的偏移量，并通过基准日期和基准时间来还原真实的数据。 一，DateT</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ljhdo/p/10208322.html</dc:identifier>
</item>
<item>
<title>你真的知道聊天室架构设计这两个问题吗？ - 后台开发拾遗</title>
<link>http://www.cnblogs.com/htkfsy/p/11980655.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htkfsy/p/11980655.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1144246/201912/1144246-20191204082405237-966577909.jpg&quot; alt=&quot;&quot; width=&quot;464&quot; height=&quot;290&quot;/&gt; &lt;/p&gt;
&lt;p&gt;上篇我们介绍了下面这个简单的语音聊天室的架构，遗留了两个问题。首先，&lt;strong&gt;语音服务器是怎么转发语音数据的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1144246/201912/1144246-20191204082248898-1178546524.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们直接上图。图中虚线框表示连接到同一台语音服务器。当A说话的时候，客户端将语音数据上传到A所连接的语音服务器；语音服务器向房间服务器查询A所在房间的其他用户（B-E）所在的语音服务器IP，分几种情况：对于同服务器用户B只需要下发语音数据，对于其他服务器上的用户（C-E）需要转发给相应的语音服务器，其他语音服务器收到转发数据后，根据房间信息，下发给同房间的用户。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1144246/201912/1144246-20191204082308472-1325440993.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;有一个细节需要注意，&lt;strong&gt;房间服务器是主动给语音服务器同步房间架构的&lt;/strong&gt;。因为语音服务请求量非常大，如果每次转发的时候都查询房间架构信息，那么房间服务器/数据库将成为瓶颈。因此语音服务器本地缓存了房间架构信息（当然缓存也会导致其他的问题，以后会专门讨论）。缓存的同步机制采用用户进退房主动触发房间服务器广播和房间服务器定期推送相结合，这样可以有效&lt;strong&gt;保证网络丢包情况下的数据一致性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外一个问题是&lt;strong&gt;目录服务器是否有点多余？&lt;/strong&gt;答案自然是否定的。当同一房间用户量还比较少的情况下，目录服务器的确可以省略，客户端可以通过DNS解析域名得到语音服务器的IP地址进行连接。&lt;/p&gt;
&lt;p&gt;但是，当用户量非常大的时候，DNS缓慢的刷新机制不能满足快速扩容和缩容。目录服务器还有一个重要的作用是&lt;strong&gt;负载均衡&lt;/strong&gt;，相比DNS手工配置的简单的负载均衡策略，增加目录服务器可以实现更加高效的复杂均衡策略。例如下面要介绍的分SET部署。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1144246/201912/1144246-20191204082323107-590411697.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图展示了同一房间的用户连接语音服务器的两种分布：对于A-E用户散落在5台语音服务器，而A’-E’则连接到2台语音服务器。我们觉得，第二种分布更好。为什么？因为服务器数量更少，语音服务器之间的转发数据量更少。要知道在百万级甚至千万级别的语音服务系统中，&lt;strong&gt;机器成本和带宽成本是主要的成本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如何实现第二种分布呢？这就有赖于目录服务器的负载均衡策略。其中一条策略是&lt;strong&gt;同一房间的用户优先分配到相同的语音服务器&lt;/strong&gt;。当然还有其他的一些策略，我们先不展开。&lt;/p&gt;
&lt;p&gt;除了通过负载均衡策略实现更聚集的分布以外，还有一种更常用的手段——&lt;strong&gt;分SET部署&lt;/strong&gt;。如图所示，其实就是增加了一个虚拟SET的概念，一个SET是一个小的服务器集群。SET之间互相隔离，对于小房间（大房间后面再讨论），一个房间只能分布在一个SET内。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1144246/201912/1144246-20191204082335703-1909195268.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;这样做有什么好处呢？首先，分SET部署天然可以实现同一房间用户的&lt;strong&gt;聚集分布&lt;/strong&gt;。一个SET一般是10台语音服务器，如果按照单台能承载2万用户来计算，对于房间容量在20万以下的小房间，同一房间的用户都分布到一个SET上。其次，分SET部署更&lt;strong&gt;便于版本发布和日常运维&lt;/strong&gt;。试想一下，同样是有几百台机器的语音服务器集群，分SET发布更新和不分SET发布更新哪个更容易？&lt;/p&gt;
&lt;p&gt;增加SET以后，房间的架构信息增加了SET和房间的映射关系：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1144246/201912/1144246-20191204082347898-2133067546.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;SET被赋予一组房间的概念，同一个SET内的房间类型可以多种多样，但是一般还是把同类型的房间放在一个SET，因为这样便于管理，发布更新也会比较简单。通常新扩容一个SET的时候，我们会设置SET的一些属性，例如这个SET只支持游戏开黑，那后续游戏开黑的新房间就会分配到这个SET。SET的扩容缩容和房间的新建和销毁我们将在后面的文章中具体介绍。&lt;/p&gt;
&lt;p&gt;简单总结一下，本篇主要解答了上篇文章提到的两个问题：&lt;strong&gt;语音服务器之间是平行转发数据的；目录服务器除了有路由的功能还可以实现复杂高效的负载均衡策略&lt;/strong&gt;。而从目录服务器的功能又引出了业界常用的分SET部署的概念。本文介绍的都是一些比较基础的概念，主要为后面的内容做铺垫。&lt;/p&gt;

</description>
<pubDate>Wed, 04 Dec 2019 00:25:00 +0000</pubDate>
<dc:creator>后台开发拾遗</dc:creator>
<og:description>上篇我们介绍了下面这个简单的语音聊天室的架构，遗留了两个问题。首先，语音服务器是怎么转发语音数据的？ 我们直接上图。图中虚线框表示连接到同一台语音服务器。当A说话的时候，客户端将语音数据上传到A所连接</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/htkfsy/p/11980655.html</dc:identifier>
</item>
<item>
<title>国内开源C# WPF控件库Panuon.UI.Silver强力推荐 - 沙漠之狐耶</title>
<link>http://www.cnblogs.com/lsq6/p/11980648.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lsq6/p/11980648.html</guid>
<description>&lt;div readability=&quot;33&quot;&gt;
&lt;p&gt;国内优秀的WPF开源控件库，Panuon.UI的优化版本。一个漂亮的、使用样式与附加属性的WPF UI控件库，值得向大家推荐使用与学习。&lt;/p&gt;
&lt;/div&gt;&lt;div readability=&quot;144.59266205603&quot;&gt;
&lt;p&gt;今天站长(&lt;a href=&quot;https://dotnet9.com/&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;Dotnet9&lt;/a&gt;，站长网址：&lt;a href=&quot;https://dotnet9.com/&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;https://dotnet9.com&lt;/a&gt;, 微信公众号：dotnet9_com)推荐另一款开源的WPF控件库(&lt;a href=&quot;https://github.com/Panuon/PanuonUI.Silver&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;PanuonUI.Silver&lt;/a&gt;，github链接： &lt;a href=&quot;https://github.com/Panuon/PanuonUI.Silver&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/Panuon/PanuonUI.Silver&lt;/a&gt; )，一个 年轻有为的国内小伙做的，非常优秀哦，值得向大家推荐。&lt;/p&gt;
&lt;p&gt;本文介绍分两部分：第一部分，先介绍此控件库Case案例 &lt;a href=&quot;http://www.huanghunxiao.com/&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;Morin 魔音&lt;/a&gt; ，通过此案例，大家对此控件应该有个更深刻的印象；第二部分，详细介绍此控件库的特色控件，方便大家学习使用。&lt;/p&gt;
&lt;p&gt;文中使用录制的gif展示相关界面，更形象的将此控件库、案例展示给大家，希望大家能够接受。&lt;/p&gt;
&lt;p&gt;本文导航目录：&lt;/p&gt;
&lt;p&gt;一、&lt;a href=&quot;https://dotnet9.com/?p=2285#p100&quot;&gt;Case案例： Morin 魔音&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dotnet9.com/?p=2285#p200&quot;&gt;二、Panuon.UI.Silver特色控件介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dotnet9.com/?p=2285#p300&quot;&gt;三、写在最后的话&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;一、Case案例： Morin 魔音&lt;/h2&gt;
&lt;p&gt;说一千道一万，先展示该控件库的Case案例：&lt;a href=&quot;http://www.huanghunxiao.com/&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;Morin 魔音&lt;/a&gt;。一款非常不错的音乐播放软件，C# WPF做的哦，网址： &lt;a href=&quot;http://www.huanghunxiao.com/&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;http://www.huanghunxiao.com/&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;下面展示该软件几个特色页面，大家可以通过上面的网址下载使用哦，真的很不错，站长已使用该软件几天，该软件作者（又一个年轻有为的国内IT星星）也在不断的优化更新中，希望大家多多支持。&lt;/p&gt;
&lt;h3&gt;1.1 Morin 魔音 关于页面&lt;/h3&gt;
&lt;p&gt;魔音Morin v2.3.7.0版，听歌用一个软件就够了，是不是很霸气！&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_26-1024x566.png&quot; data-group=&quot;nogroup&quot; data-id=&quot;0&quot; data-index=&quot;0&quot;&gt;&lt;img class=&quot;wp-image-2303 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_26-1024x566.png&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_26-1024x566.png&quot;/&gt;&lt;/a&gt;Morin 魔音 关于页面&lt;/div&gt;
&lt;h3&gt;1.2 Morin 魔音 默认页面&lt;/h3&gt;
&lt;p&gt;默认页面展示热门歌曲，图片+文字介绍，方便用户选择、播放，目前歌曲库来自QQ音乐、网易云音乐、酷我音乐、酷狗音乐等。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_22.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;1&quot; data-index=&quot;1&quot;&gt;&lt;img class=&quot;wp-image-2304 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_22.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_22.gif&quot;/&gt;&lt;/a&gt;Morin 魔音 默认页面&lt;/div&gt;
&lt;h3&gt;1.3 Morin 魔音 歌曲搜索&lt;/h3&gt;
&lt;p&gt;Morin 魔音提供方便的歌曲搜索功能，站长尝试搜索最近比较火的，陈伟霆的《野狼disco》，下面列出了相关的搜索结果，有无损mp3、mp4 MV供播放、下载选择。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_23-1024x562.png&quot; data-group=&quot;nogroup&quot; data-id=&quot;2&quot; data-index=&quot;2&quot;&gt;&lt;img class=&quot;wp-image-2305 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_23-1024x562.png&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_23-1024x562.png&quot;/&gt;&lt;/a&gt;Morin 魔音 歌曲搜索&lt;/div&gt;
&lt;h3&gt;1.4 Morin 魔音 MV播放页面&lt;/h3&gt;
&lt;p&gt;Morin 魔音 MV播放页面，不错吧。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_24.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;3&quot; data-index=&quot;3&quot;&gt;&lt;img class=&quot;wp-image-2293 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_24.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MORIN_24.gif&quot;/&gt;&lt;/a&gt;Morin 魔音 MV播放页面&lt;/div&gt;
&lt;h2&gt;二、Panuon.UI.Silver特色控件介绍&lt;/h2&gt;
&lt;p&gt;Panuon.UI.Silver控件库的前身是&lt;a href=&quot;https://github.com/Panuon/PanuonUI&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;Panuon.UI&lt;/a&gt;（ 一个好看精致、开源无限制使用的WPF控件库，github链接： &lt;a href=&quot;https://github.com/Panuon/PanuonUI&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/Panuon/PanuonUI&lt;/a&gt; ），作者已停止维护，下图是作者声明：&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/PanuonUI.png&quot; data-group=&quot;nogroup&quot; data-id=&quot;4&quot; data-index=&quot;4&quot;&gt;&lt;img class=&quot;wp-image-2308 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/PanuonUI.png&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/PanuonUI.png&quot;/&gt;&lt;/a&gt;Panuon.UI停止维护声明&lt;/div&gt;
&lt;p&gt;所以本文主要介绍PanuonUI.Silver控件库，下面截图将近20张，用手机的朋友注意流量哦，希望不会浪费大家的流量，谢谢大家支持开源作者：&lt;a href=&quot;https://github.com/Panuon/PanuonUI&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;PanuonUI.Silver&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;2.1 控件库概览&lt;/h3&gt;
&lt;p&gt;控件库概览，只展示部分控件，后面将对部分特色控件再详细说明，更多控件还请大家访问 &lt;a href=&quot;https://github.com/Panuon/PanuonUI&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;PanuonUI.Silver&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/main_1.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;5&quot; data-index=&quot;5&quot;&gt;&lt;img class=&quot;wp-image-2310 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/main_1.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/main_1.gif&quot;/&gt;&lt;/a&gt;控件库概览&lt;/div&gt;
&lt;h3&gt;2.2 按钮(Button)&lt;/h3&gt;
&lt;p&gt;老生常谈的，首先还是按钮，以动画展示。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/button_2.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;6&quot; data-index=&quot;6&quot;&gt;&lt;img class=&quot;wp-image-2311 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/button_2.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/button_2.gif&quot;/&gt;&lt;/a&gt;按钮（Button)&lt;/div&gt;
&lt;h3&gt;2.3 密码框（PasswordBox)&lt;/h3&gt;
&lt;p&gt;TextBox与PasswordBox类似，站长就只录制了密码框PasswordBox，支持输入时查看，有常用的图标、水印支持。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/PasswordBox_3.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;7&quot; data-index=&quot;7&quot;&gt;&lt;img class=&quot;wp-image-2312 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/PasswordBox_3.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/PasswordBox_3.gif&quot;/&gt;&lt;/a&gt;密码框（PasswordBox)&lt;/div&gt;
&lt;h3&gt;2.4 复选框（CheckBox)&lt;/h3&gt;
&lt;p&gt;复选框CheckBox与RadioBox类似，动图展示比较形象，基础样式中的Switch，应该是大家比较喜欢的样式了，站长项目中也经常用。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/CheckBox_4.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;8&quot; data-index=&quot;8&quot;&gt;&lt;img class=&quot;wp-image-2313 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/CheckBox_4.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/CheckBox_4.gif&quot;/&gt;&lt;/a&gt;复选框(CheckBox)&lt;/div&gt;
&lt;h3&gt;2.5 下拉框（ComboBox）及多选下拉框（MultiComboBox)&lt;/h3&gt;
&lt;p&gt;下拉框ComboBox，支持图标及文本搜索，很是方便。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/ComboBox_5.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;9&quot; data-index=&quot;9&quot;&gt;&lt;img class=&quot;wp-image-2314 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/ComboBox_5.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/ComboBox_5.gif&quot;/&gt;&lt;/a&gt;下拉框（ComboBox)&lt;/div&gt;
&lt;p&gt;多选下拉框（MultiComboBox），这个在特殊业务场景下是很有用的，值得借鉴使用。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MultiComboBox_17.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;10&quot; data-index=&quot;10&quot;&gt;&lt;img class=&quot;wp-image-2315 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MultiComboBox_17.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/MultiComboBox_17.gif&quot;/&gt;&lt;/a&gt;多选下拉框(MultiComboBox)&lt;/div&gt;
&lt;h3&gt;2.6 进度条(ProgressBar)&lt;/h3&gt;
&lt;p&gt;进度条ProgressBar，提供两种样式，其中Ring样式非常实用，用户体验提升一个档次有木有？&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/7ProgressBar_6.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;11&quot; data-index=&quot;11&quot;&gt;&lt;img class=&quot;wp-image-2316 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/7ProgressBar_6.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/7ProgressBar_6.gif&quot;/&gt;&lt;/a&gt;进度条(ProgressBar)&lt;/div&gt;
&lt;h3&gt;2.7 滑块(Slider)&lt;/h3&gt;
&lt;p&gt;滑块Slider，看着很爽吧，加上标尺很形象哦。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/8Slider_9.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;12&quot; data-index=&quot;12&quot;&gt;&lt;img class=&quot;wp-image-2317 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/8Slider_9.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/8Slider_9.gif&quot;/&gt;&lt;/a&gt;滑块Slider&lt;/div&gt;
&lt;h3&gt;2.8 分组框(GroupBox)&lt;/h3&gt;
&lt;p&gt;分组框GroupBox，附加控件常见吧，极大的减少个人封装了。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/9GroupBox_12.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;13&quot; data-index=&quot;13&quot;&gt;&lt;img class=&quot;wp-image-2318 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/9GroupBox_12.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/9GroupBox_12.gif&quot;/&gt;&lt;/a&gt;分组框GroupBox&lt;/div&gt;
&lt;h3&gt;2.9 TabControl&lt;/h3&gt;
&lt;p&gt;TabControl，提供三种基础样式选择，设置很灵活。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/10TabControl_7.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;14&quot; data-index=&quot;14&quot;&gt;&lt;img class=&quot;wp-image-2319 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/10TabControl_7.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/10TabControl_7.gif&quot;/&gt;&lt;/a&gt;TabControl&lt;/div&gt;
&lt;h2&gt;2.10 Expander&lt;/h2&gt;
&lt;p&gt;Expander，增加了图标扩展。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/11Expander_13.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;15&quot; data-index=&quot;15&quot;&gt;&lt;img class=&quot;wp-image-2320 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/11Expander_13.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/11Expander_13.gif&quot;/&gt;&lt;/a&gt;Expander&lt;/div&gt;
&lt;h3&gt;2.11 上下文菜单(ContextMenu)&lt;/h3&gt;
&lt;p&gt;上下文菜单ContextMenu，强大不？原生实现其实也不难，但使用此控件库可以大量缩短开发时间，再费点功夫可以实现360安全卫士的托盘右键菜单样式哦，强大吧？&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/12ContextMenu_11.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;16&quot; data-index=&quot;16&quot;&gt;&lt;img class=&quot;wp-image-2321 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/12ContextMenu_11.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/12ContextMenu_11.gif&quot;/&gt;&lt;/a&gt;上下文菜单ContextMenu&lt;/div&gt;
&lt;h3&gt;2.12 树状视图(TreeView)&lt;/h3&gt;
&lt;p&gt;树形视图TreeView，开发中也是经常用的一种控件 ，提供4种基础样式，也是非常不错的。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/13TreeView_8.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;17&quot; data-index=&quot;17&quot;&gt;&lt;img class=&quot;wp-image-2322 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/13TreeView_8.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/13TreeView_8.gif&quot;/&gt;&lt;/a&gt;树形视图TreeView&lt;/div&gt;
&lt;h2&gt;2.13 表格控件(DataGrid)&lt;/h2&gt;
&lt;p&gt;表格控件DataGrid，提供了简单的调整功能，一般数据展示也够用了。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/14DataGrid_10.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;18&quot; data-index=&quot;18&quot;&gt;&lt;img class=&quot;wp-image-2323 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/14DataGrid_10.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/14DataGrid_10.gif&quot;/&gt;&lt;/a&gt;表格控件DataGrid&lt;/div&gt;
&lt;h3&gt;2.14 分页控件（Pagination)&lt;/h3&gt;
&lt;p&gt;分页控件Pagination，使用表格时常用分页控件，但一般都是自己封装的，此控件封装的比较好，也提供了3种基础样式选择，也是十分够用了。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/15Pagination_20.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;19&quot; data-index=&quot;19&quot;&gt;&lt;img class=&quot;wp-image-2324 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/15Pagination_20.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/15Pagination_20.gif&quot;/&gt;&lt;/a&gt;分页控件Pagination&lt;/div&gt;
&lt;h3&gt;2.15 等待提示框（PendingBox)&lt;/h3&gt;
&lt;p&gt;等待提示框PendingBox，费时操作比较实用，可提供取消操作，使用了遮罩，很酷吧，网页常用这种效果，桌面不常见，站长原来的项目也使用过类似的效果，但必须承认，该控件作者做的更顺畅。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/16PendingBox_16.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;20&quot; data-index=&quot;20&quot;&gt;&lt;img class=&quot;wp-image-2325 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/16PendingBox_16.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/16PendingBox_16.gif&quot;/&gt;&lt;/a&gt;等待提示框PendingBox&lt;/div&gt;
&lt;h3&gt;2.16 提示框（MessageBox)&lt;/h3&gt;
&lt;p&gt;提示框（MessageBox)，作者提供的选择比较多，有10多种，够用了，常见的Info、Error、Warning等提示都有。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/17MessageBoxX_15.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;21&quot; data-index=&quot;21&quot;&gt;&lt;img class=&quot;wp-image-2326 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/17MessageBoxX_15.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/17MessageBoxX_15.gif&quot;/&gt;&lt;/a&gt;提示框（MessageBox)&lt;/div&gt;
&lt;h2&gt;2.17 升级版气泡提示框(Notice)&lt;/h2&gt;
&lt;p&gt;升级版气泡提示框Notice，放弃使用Windows自带的气泡提示吧，即使是Windows 10自带的右下脚提示框，推荐使用这种方式。该效果在大多数软件中也常见，很流行呀。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/18Notice_18.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;22&quot; data-index=&quot;22&quot;&gt;&lt;img class=&quot;wp-image-2327 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/18Notice_18.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/18Notice_18.gif&quot;/&gt;&lt;/a&gt;升级版气泡提示框Notice&lt;/div&gt;
&lt;h3&gt;2.18 动画帮助类（AnimationHelper）&lt;/h3&gt;
&lt;p&gt;动画帮助类AnimationHelper，这不应该算是控件，算是扩展控件的帮助类，实用的很哟。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/19AnimationHelper_21.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;23&quot; data-index=&quot;23&quot;&gt;&lt;img class=&quot;wp-image-2328 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/19AnimationHelper_21.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/19AnimationHelper_21.gif&quot;/&gt;&lt;/a&gt;动画帮助类AnimationHelper&lt;/div&gt;
&lt;h3&gt;2.19 轮播(Carousel)&lt;/h3&gt;
&lt;p&gt;轮播Carousel，常见网站首页Header主题介绍这样使用，站长首页也是类似的效果，朋友们可点击查看（&lt;a href=&quot;https://dotnet9.com/&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;网站首页&lt;/a&gt;），可用于广告展示，或者数据页面切换，其中的自动播放很有用。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/20Carousel_19.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;24&quot; data-index=&quot;24&quot;&gt;&lt;img class=&quot;wp-image-2329 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/20Carousel_19.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/20Carousel_19.gif&quot;/&gt;&lt;/a&gt;轮播Carousel&lt;/div&gt;
&lt;h3&gt;2.20 自定义窗体(WindowsX)&lt;/h3&gt;
&lt;p&gt;自定义窗体WindowsX，重点的都放在最后啦，哈哈，这个直接把整个软件提升一档有木有？&lt;/p&gt;
&lt;p&gt;作者也是十分用心了，提供的样式都很酷，特别是最后一个播放器的界面，是不是和Case案例&lt;a href=&quot;http://www.huanghunxiao.com/&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;魔音MORIN&lt;/a&gt;很像？&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/21WindowsX_14.gif&quot; data-group=&quot;nogroup&quot; data-id=&quot;25&quot; data-index=&quot;25&quot;&gt;&lt;img class=&quot;wp-image-2330 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/21WindowsX_14.gif&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/21WindowsX_14.gif&quot;/&gt;&lt;/a&gt;自定义窗体WindowsX&lt;/div&gt;
&lt;h2&gt;三、写在最后的话&lt;/h2&gt;
&lt;p&gt;感谢作者提供这么优秀的控件库，站长也提倡开源、支持开源，本站热衷于互联网分享精神，站长也厚着脸皮，推销下自己的网站Dotnet9：&lt;a href=&quot;https://dotnet9.com/&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;https://dotnet9.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;再次给大家推荐两位作者的项目：&lt;/p&gt;
&lt;p&gt;再次谢谢两位作者（ &lt;a href=&quot;https://github.com/Panuon/PanuonUI.Silver&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;PanuonUI.Silver&lt;/a&gt; ， &lt;a href=&quot;http://www.huanghunxiao.com/&quot;&gt;魔音MORIN&lt;/a&gt; ），希望大家多多支持，前往github、官网下载、加星、使用，多多推广两位年轻有为的IT星星。&lt;/p&gt;
&lt;p&gt;忘了说了， &lt;a href=&quot;https://github.com/Panuon/PanuonUI.Silver&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;PanuonUI.Silver&lt;/a&gt; 控件库作者在本月底将会出第二版，非常大的改动哦，比如PanuonUI中有的控件，而PanuonUI.Silver中没有的控件，第二版都会增加哦，比如下面的聊天界面，大家期待吗？不管你期不期待，反正我是期待的，哈哈。&lt;/p&gt;
&lt;div class=&quot;wp-block-image&quot; readability=&quot;7&quot;&gt;&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/chat-1024x688.png&quot; data-group=&quot;nogroup&quot; data-id=&quot;26&quot; data-index=&quot;26&quot;&gt;&lt;img class=&quot;wp-image-2343 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/chat-1024x688.png&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/chat-1024x688.png&quot;/&gt;&lt;/a&gt;PanuonUI 中的聊天界面&lt;/div&gt;
&lt;p&gt;站长会将优质文章在各大平台同步更新、推送，欢迎大家访问、订阅：&lt;/p&gt;
&lt;p&gt;博客园： &lt;a href=&quot;https://www.cnblogs.com/lsq6/&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lsq6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今日头条： &lt;a href=&quot;https://www.toutiao.com/c/user/98075192460/#mid=1651788205627396&quot; rel=&quot;noreferrer noopener&quot; target=&quot;_blank&quot;&gt;https://www.toutiao.com/c/user/98075192460/#mid=1651788205627396&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;微信公众号：dotnet9_com&lt;/p&gt;
&lt;a class=&quot;j-wpcom-lightbox&quot; href=&quot;https://dotnet9.com/wp-content/uploads/2019/12/WeChat-public-address.jpg&quot; data-group=&quot;nogroup&quot; data-id=&quot;27&quot; data-index=&quot;27&quot;&gt;&lt;img class=&quot;wp-image-2283 j-lazy&quot; src=&quot;https://dotnet9.com/wp-content/uploads/2019/12/WeChat-public-address.jpg&quot; alt=&quot;国内开源C# WPF控件库Panuon.UI.Silver推荐&quot; data-original=&quot;https://dotnet9.com/wp-content/uploads/2019/12/WeChat-public-address.jpg&quot;/&gt;&lt;/a&gt;
&lt;div class=&quot;entry-copyright&quot; readability=&quot;24.825396825397&quot;&gt;
&lt;p&gt;除非注明，文章均由 &lt;span&gt;&lt;a href=&quot;https://dotnet9.com/&quot; target=&quot;_blank&quot;&gt;Dotnet9&lt;/a&gt;&lt;/span&gt; 整理发布，欢迎转载。&lt;/p&gt;
&lt;p&gt;转载请注明本文地址：&lt;span&gt;&lt;a href=&quot;https://dotnet9.com/?p=2285&quot; target=&quot;_blank&quot;&gt;https://dotnet9.com/?p=2285&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 04 Dec 2019 00:22:00 +0000</pubDate>
<dc:creator>沙漠之狐耶</dc:creator>
<og:description>国内优秀的WPF开源控件库，Panuon.UI的优化版本。一个漂亮的、使用样式与附加属性的WPF UI控件库，值得向大家推荐使用与学习。 今天站长(Dotnet9，站长网址：https://dotne</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lsq6/p/11980648.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 中的 ObjectPool 对象重用（二） - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/11980645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/11980645.html</guid>
<description>&lt;blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇文章主要介绍了ObjectPool的理论知识，再来介绍一下Microsoft.Extensions.ObjectPool是如何实现的.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019113011254075.png&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;核心组件&quot;&gt;核心组件&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;objectpool&quot;&gt;ObjectPool&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ObjectPool&lt;/strong&gt;是一个泛型抽象接口，他抽象了两个方法Get和Return&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Get方法用于从对象池获取到可用对象，如果对象不可用则创建对象并返回出来&lt;/li&gt;
&lt;li&gt;Return方法用户将对象返回到对象池&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    /// &amp;lt;summary&amp;gt;
    /// A pool of objects.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;The type of objects to pool.&amp;lt;/typeparam&amp;gt;
    public abstract class ObjectPool&amp;lt;T&amp;gt; where T : class
    {
        /// &amp;lt;summary&amp;gt;
        /// Gets an object from the pool if one is available, otherwise creates one.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;A &amp;lt;typeparamref name=&quot;T&quot;/&amp;gt;.&amp;lt;/returns&amp;gt;
        public abstract T Get();

        /// &amp;lt;summary&amp;gt;
        /// Return an object to the pool.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;obj&quot;&amp;gt;The object to add to the pool.&amp;lt;/param&amp;gt;
        public abstract void Return(T obj);
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;objectpoolprovider&quot;&gt;ObjectPoolProvider&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ObjectPoolProvider&lt;/strong&gt;是一个抽象接口他内置了Create的泛型方法和Create的泛型抽象方法，他是一个基于默认策略的。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    /// &amp;lt;summary&amp;gt;
    /// A provider of &amp;lt;see cref=&quot;ObjectPool{T}&quot;/&amp;gt; instances.
    /// &amp;lt;/summary&amp;gt;
    public abstract class ObjectPoolProvider
    {
        /// &amp;lt;summary&amp;gt;
        /// Creates an &amp;lt;see cref=&quot;ObjectPool&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;The type to create a pool for.&amp;lt;/typeparam&amp;gt;
        public ObjectPool&amp;lt;T&amp;gt; Create&amp;lt;T&amp;gt;() where T : class, new()
        {
            return Create&amp;lt;T&amp;gt;(new DefaultPooledObjectPolicy&amp;lt;T&amp;gt;());
        }

        /// &amp;lt;summary&amp;gt;
        /// Creates an &amp;lt;see cref=&quot;ObjectPool&quot;/&amp;gt; with the given &amp;lt;see cref=&quot;IPooledObjectPolicy{T}&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;The type to create a pool for.&amp;lt;/typeparam&amp;gt;
        public abstract ObjectPool&amp;lt;T&amp;gt; Create&amp;lt;T&amp;gt;(IPooledObjectPolicy&amp;lt;T&amp;gt; policy) where T : class;
    }
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ipooledobjectpolicy&quot;&gt;IPooledObjectPolicy&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;IPooledObjectPolicy&lt;/strong&gt;是一个泛型接口，提供策略管理对象池，该类也定义了两个方法&lt;strong&gt;Create&lt;/strong&gt;和&lt;strong&gt;Return&lt;/strong&gt;以提供策略实现&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Create用于创建相关的类实例&lt;/li&gt;
&lt;li&gt;Return用于将已经使用完的对象放回到池中，包括重置对象状态以及是否能够放回到池中&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;chsarp&quot;&gt;
&lt;code&gt;
    /// &amp;lt;summary&amp;gt;
    /// Represents a policy for managing pooled objects.
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;typeparam name=&quot;T&quot;&amp;gt;The type of object which is being pooled.&amp;lt;/typeparam&amp;gt;
    public interface IPooledObjectPolicy&amp;lt;T&amp;gt;
    {
        /// &amp;lt;summary&amp;gt;
        /// Create a &amp;lt;typeparamref name=&quot;T&quot;/&amp;gt;.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;The &amp;lt;typeparamref name=&quot;T&quot;/&amp;gt; which was created.&amp;lt;/returns&amp;gt;
        T Create();

        /// &amp;lt;summary&amp;gt;
        /// Runs some processing when an object was returned to the pool. Can be used to reset the state of an object and indicate if the object should be returned to the pool.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;obj&quot;&amp;gt;The object to return to the pool.&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;code&amp;gt;true&amp;lt;/code&amp;gt; if the object should be returned to the pool. &amp;lt;code&amp;gt;false&amp;lt;/code&amp;gt; if it's not possible/desirable for the pool to keep the object.&amp;lt;/returns&amp;gt;
        bool Return(T obj);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;PooledObjectPolicy&lt;/strong&gt;是一个泛型抽象类，并且实现了IPooledObjectPolicy，对外提供了两个抽象方法&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    public abstract class PooledObjectPolicy&amp;lt;T&amp;gt; : IPooledObjectPolicy&amp;lt;T&amp;gt;
    {
        public abstract T Create();

        public abstract bool Return(T obj);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;实现机制&quot;&gt;实现机制&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;defaultobjectpool&quot;&gt;DefaultObjectPool&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;DefaultObjectPool&lt;/strong&gt;实现了ObjectPool，Interlocked.CompareExchange(ref _firstItem, null, item)将_firstItem的值和item的值比较，相等则用null替换_firstItem，否则不操作,不管替换还是不替换返回的都是原来保存在_firstItem的值。&lt;/p&gt;
&lt;p&gt;Interlocked可以为多个线程共享的变量提供原子操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Interlocked.Increment：以原子操作的形式递增指定变量的值并存储结果。&lt;/li&gt;
&lt;li&gt;Interlocked.Decrement以原子操作的形式递减指定变量的值并存储结果。&lt;/li&gt;
&lt;li&gt;Interlocked.Add以原子操作的形式，添加两个整数并用两者的和替换第一个整数&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        public override T Get()
        {
            var item = _firstItem;
            if (item == null || Interlocked.CompareExchange(ref _firstItem, null, item) != item)
            {
                var items = _items;
                for (var i = 0; i &amp;lt; items.Length; i++)
                {
                    item = items[i].Element;
                    if (item != null &amp;amp;&amp;amp; Interlocked.CompareExchange(ref items[i].Element, null, item) == item)
                    {
                        return item;
                    }
                }

                item = Create();
            }

            return item;
        }

        public override void Return(T obj)
        {
            if (_isDefaultPolicy || (_fastPolicy?.Return(obj) ?? _policy.Return(obj)))
            {
                if (_firstItem != null || Interlocked.CompareExchange(ref _firstItem, obj, null) != null)
                {
                    var items = _items;
                    for (var i = 0; i &amp;lt; items.Length &amp;amp;&amp;amp; Interlocked.CompareExchange(ref items[i].Element, obj, null) != null; ++i)
                    {
                    }
                }
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;defaultobjectpoolprovider&quot;&gt;DefaultObjectPoolProvider&lt;/h3&gt;
&lt;p&gt;DefaultObjectPoolProvider重写了ObjectPoolProvider中Crearte方法，&lt;br/&gt;设置了默认的对象最大数量只能用的是默认的Environment.ProcessorCount * 2(CPU处理器的两倍)&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    /// &amp;lt;summary&amp;gt;
    /// The default &amp;lt;see cref=&quot;ObjectPoolProvider&quot;/&amp;gt;.
    /// &amp;lt;/summary&amp;gt;
    public class DefaultObjectPoolProvider : ObjectPoolProvider
    {
        /// &amp;lt;summary&amp;gt;
        /// The maximum number of objects to retain in the pool.
        /// &amp;lt;/summary&amp;gt;
        public int MaximumRetained { get; set; } = Environment.ProcessorCount * 2;

        /// &amp;lt;inheritdoc/&amp;gt;
        public override ObjectPool&amp;lt;T&amp;gt; Create&amp;lt;T&amp;gt;(IPooledObjectPolicy&amp;lt;T&amp;gt; policy)
        {
            if (policy == null)
            {
                throw new ArgumentNullException(nameof(policy));
            }

            if (typeof(IDisposable).IsAssignableFrom(typeof(T)))
            {
                return new DisposableObjectPool&amp;lt;T&amp;gt;(policy, MaximumRetained);
            }

            return new DefaultObjectPool&amp;lt;T&amp;gt;(policy, MaximumRetained);
        }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;disposableobjectpool&quot;&gt;DisposableObjectPool&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;DisposableObjectPool&lt;/strong&gt;继承了DefaultObjectPool以及实现了IDisposable用于手动的回收对象&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
      public void Dispose()
        {
            _isDisposed = true;

            DisposeItem(_firstItem);
            _firstItem = null;

            ObjectWrapper[] items = _items;
            for (var i = 0; i &amp;lt; items.Length; i++)
            {
                DisposeItem(items[i].Element);
                items[i].Element = null;
            }
        }

        private void DisposeItem(T item)
        {
            if (item is IDisposable disposable)
            {
                disposable.Dispose();
            }
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;leaktrackingobjectpool&quot;&gt;LeakTrackingObjectPool&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;LeakTrackingObjectPool&lt;/strong&gt;实现了ObjectPool，它定义了ConditionalWeakTable他是一个弱引用字典，ConditionalWeakTable&amp;lt;TKey,TValue&amp;gt; 中的所有 Key 和所有的 Value 都是弱引用的，并且会在其 Key 被回收或者 Key 和 Value 都被回收之后自动从集合中消失。这意味着当你使用它来为一个类型附加一些字段或者属性的时候完全不用担心内存泄漏的问题&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    public class LeakTrackingObjectPool&amp;lt;T&amp;gt; : ObjectPool&amp;lt;T&amp;gt; where T : class
    {
        private readonly ConditionalWeakTable&amp;lt;T, Tracker&amp;gt; _trackers = new ConditionalWeakTable&amp;lt;T, Tracker&amp;gt;();
        private readonly ObjectPool&amp;lt;T&amp;gt; _inner;

        public LeakTrackingObjectPool(ObjectPool&amp;lt;T&amp;gt; inner)
        {
            if (inner == null)
            {
                throw new ArgumentNullException(nameof(inner));
            }

            _inner = inner;
        }

        public override T Get()
        {
            var value = _inner.Get();
            _trackers.Add(value, new Tracker());
            return value;
        }

        public override void Return(T obj)
        {
            Tracker tracker;
            if (_trackers.TryGetValue(obj, out tracker))
            {
                _trackers.Remove(obj);
                tracker.Dispose();
            }

            _inner.Return(obj);
        }

        private class Tracker : IDisposable
        {
            private readonly string _stack;
            private bool _disposed;

            public Tracker()
            {
                _stack = Environment.StackTrace;
            }

            public void Dispose()
            {
                _disposed = true;
                GC.SuppressFinalize(this);
            }

            ~Tracker()
            {
                if (!_disposed &amp;amp;&amp;amp; !Environment.HasShutdownStarted)
                {
                    Debug.Fail($&quot;{typeof(T).Name} was leaked. Created at: {Environment.NewLine}{_stack}&quot;);
                }
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.walterlv.com/post/conditional-weak-table.html&quot; class=&quot;uri&quot;&gt;https://blog.walterlv.com/post/conditional-weak-table.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/edison0621/p/11747912.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/edison0621/p/11747912.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Dec 2019 00:21:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>前言 上一篇文章主要介绍了ObjectPool的理论知识，再来介绍一下Microsoft.Extensions.ObjectPool是如何实现的. 核心组件 ObjectPool ObjectPool</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/11980645.html</dc:identifier>
</item>
<item>
<title>EntityFramework Core 3多次Include导致查询性能低之解决方案 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/11980476.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/11980476.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;上述我们简单讲解了几个小问题，这节我们再来看看如标题EF Core中多次Include导致出现性能的问题，废话少说，直接开门见山。&lt;/p&gt;
&lt;h2&gt;EntityFramework Core 3多次Include查询问题&lt;/h2&gt;
&lt;p&gt;不要嫌弃我啰嗦，我们凡事从头开始讲解起，首先依然给出我们上一节的示例类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EFCoreDbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EFCoreDbContext()
        {

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        &lt;/span&gt;=&amp;gt; optionsBuilder.UseSqlServer(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Server=.;Database=EFTest;Trusted_Connection=True;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们在控制台进行如下查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog = context.Blogs.FirstOrDefault(d =&amp;gt; d.Id == &lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191204002634453-959754979.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，生成的SQL语句一点毛病都么有，对吧，接下来我们来查询导航属性Posts，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog =&lt;span&gt; context.Blogs.AsNoTracking()
       .Include(d &lt;/span&gt;=&amp;gt; d.Posts).FirstOrDefault(d =&amp;gt; d.Id == &lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191204002848143-1115687066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咦，不应该是INNER JOIN吗，但最终生成的SQL语句我们可以看到居然是LEFT JOIN，关键是我们对Post类中的BlogId并未设置为可空，对吧，是不是很有意思。同时通过ORDER BY对两个表的主键都进行了排序。这就是问题的引发点，接下来我们再引入两个类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 博客标签
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Tag
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 标签名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 博客分类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Category
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 分类名称
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述我们声明了分类和标签，我们知道博客有分类和标签，所以博客类中有对分类和标签的导航属性（这里我们先不关心关系到底是一对一还是一对多等关系），然后修改博客类，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Tag&amp;gt; Tags { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Category&amp;gt; Categories { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们再来进行如下查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blogs = context.Blogs.AsNoTracking().Include(d =&amp;gt;&lt;span&gt; d.Posts)
                 .Include(d &lt;/span&gt;=&amp;gt;&lt;span&gt; d.Tags)
                 .Include(d &lt;/span&gt;=&amp;gt; d.Categories).FirstOrDefault(d =&amp;gt; d.Id == &lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191204003603138-398193032.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
SELECT [t].[Id], [t].[Name], [p].[Id], [p].[BlogId], [p].[Content], [p].[Title], [t0].[Id], [t0].[BlogId], [t0].[Name], [c].[Id], [c].[BlogId], [c].[Name]
FROM (
    SELECT TOP(&lt;span&gt;1&lt;/span&gt;) [b].[Id], [b].[Name]
    FROM [Blogs] AS [b]
    WHERE [b].[Id] = &lt;span&gt;1&lt;/span&gt;
) AS [t]
LEFT JOIN [Posts] AS [p] ON [t].[Id] = [p].[BlogId]
LEFT JOIN [Tags] AS [t0] ON [t].[Id] = [t0].[BlogId]
LEFT JOIN [Categories] AS [c] ON [t].[Id] = [c].[BlogId]
ORDER BY [t].[Id], [p].[Id], [t0].[Id], [c].[Id]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时和变更追踪没有半毛钱关系，我们看看最终生成的SQL语句，是不是很惊讶，假设单个类中对应多个导航属性，最终生成的SQL语句就是继续LEFT JOIN和ORDER BY，可想其性能将是多么的低下。那么我们应该如何解决这样的问题呢？既然是和Include有关系，每增加一个导航属性即增加一个Include将会增加一个LEFT JOIN和ORDER BY，那么我们何不分开单独查询呢，说完就开干。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog = context.Blogs.AsNoTracking().FirstOrDefault(d =&amp;gt; d.Id == &lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们进行如上查询显然不可取，因为直接就到数据库进行SQL查询了，我们需要返回IQueryable才行，同时根据主键查询只能返回一条，所以我们改造成如下查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog = context.Blogs.Where(d =&amp;gt; d.Id == &lt;span&gt;1&lt;/span&gt;).Take(&lt;span&gt;1&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为接下来还需要从上下文中加载导航属性，所以这里我们需要去掉AsNoTracking，通过上下文加载指定实体导航属性，我们可通过Load方法来加载，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; blog = context.Blogs.Where(d =&amp;gt; d.Id == &lt;span&gt;1&lt;/span&gt;).Take(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

            blog.Include(p &lt;/span&gt;=&amp;gt; p.Posts).SelectMany(d =&amp;gt;&lt;span&gt; d.Posts).Load();

            blog.Include(t &lt;/span&gt;=&amp;gt; t.Tags).SelectMany(d =&amp;gt;&lt;span&gt; d.Tags).Load();

            blog.Include(c &lt;/span&gt;=&amp;gt; c.Categories).SelectMany(d =&amp;gt; d.Categories).Load();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191204005619339-1483843841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191204005736008-737841648.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT [p].[Id], [p].[BlogId], [p].[Content], [p].[Title]
FROM (
    SELECT TOP(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) [b].[Id], [b].[Name]
    FROM [Blogs] AS [b]
    WHERE [b].[Id] &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
) AS [t]
INNER JOIN [Posts] AS [p] ON [t].[Id] &lt;/span&gt;=&lt;span&gt; [p].[BlogId]


SELECT [t0].[Id], [t0].[BlogId], [t0].[Name]
FROM (
    SELECT TOP(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) [b].[Id], [b].[Name]
    FROM [Blogs] AS [b]
    WHERE [b].[Id] &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
) AS [t]
INNER JOIN [Tags] AS [t0] ON [t].[Id] &lt;/span&gt;=&lt;span&gt; [t0].[BlogId]


SELECT [c].[Id], [c].[BlogId], [c].[Name]
FROM (
    SELECT TOP(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) [b].[Id], [b].[Name]
    FROM [Blogs] AS [b]
    WHERE [b].[Id] &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
) AS [t]
INNER JOIN [Categories] AS [c] ON [t].[Id] &lt;/span&gt;= [c].[BlogId]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过上述生成的SQL语句，我们知道这才是我们想要的结果，上述代码看起来有点不是那么好看，似乎没有更加优美的写法了，当然这里我只是在控制台中进行演示，为了吞吐，将上述修改为异步查询则是最佳可行方式。 比生成一大堆LEFT JOIN和ORDER BY性能好太多太多。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;注意：上述博主采用的是稳定版本3.0.1，其他版本未经测试哦。其实对于查询而言，还是建议采用Dapper或者走底层connection写原生SQL才是最佳，对于单表，用EF Core无可厚非，对于复杂查询还是建议不要用EF Core，生成的SQL很不可控，为了图方便，结果换来的将是CPU飙到飞起。好了，本节我们就到这里，感谢您的阅读，我们下节见。&lt;/p&gt;
</description>
<pubDate>Tue, 03 Dec 2019 23:49:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 上述我们简单讲解了几个小问题，这节我们再来看看如标题EF Core中多次Include导致出现性能的问题，废话少说，直接开门见山。 EntityFramework Core 3多次Include</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/11980476.html</dc:identifier>
</item>
<item>
<title>.net反编译原理 - 杰哥很忙</title>
<link>http://www.cnblogs.com/Jack-Blog/p/11978817.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack-Blog/p/11978817.html</guid>
<description>&lt;hr/&gt;&lt;hr/&gt;&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/10117218.html&quot;&gt;NLog日志框架使用探究-1&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/11972400.html&quot;&gt;NLog日志框架使用探究-2&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/11972400.html&quot;&gt;科学使用Log4View2&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;本来没有想写反编译相关的文章，但是写着写着就扯到反编译破解了。更何况上一篇&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/11972400.html&quot;&gt;《科学使用Log4View2》&lt;/a&gt;文章还被管理员移出了首页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203150818405-921203152.png&quot; alt=&quot;20191203150818.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;花了几个小时写的文章被移除首页的感受你们了解吗？终于凭借我的三寸不烂之舌终于打动管理大大恢复到了首页。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203154406525-1924936449.png&quot; alt=&quot;20191203154406.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了更加合规合法，因此有了该篇文章。&lt;/p&gt;
&lt;p&gt;上一篇文章我们使用DnSpy可以非常方便的反编译甚至可以直接修改IL并生成新的程序集。本篇文章我们就来讲讲在DnSpy出现之前，我们是如何修改程序集的。&lt;/p&gt;
&lt;h2 id=&quot;ildasm&quot;&gt;ILdasm&lt;/h2&gt;
&lt;p&gt;在没有DnSpy这等强大的反编译工具之前，若需要修改程序集，一般都需要使用微软官方提供的ILDasm反编译，ILAsm编译IL。&lt;/p&gt;
&lt;blockquote readability=&quot;4.5086705202312&quot;&gt;
&lt;p&gt;本篇文章的重点不是谈论IL的语法，IL如何阅读，想要了解这些，网上一搜一大把。推荐一篇吧：&lt;a href=&quot;https://www.cnblogs.com/zery/p/3366175.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zery/p/3366175.html&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;IL拆解器是IL汇编器（Ilasm.exe）的配套工具。ILDasm.exe采用包含中间语言（IL）代码的可移植可执行（PE）文件，并创建适合作为ILasm.exe 输入的文本文件。&lt;/p&gt;
&lt;p&gt;这是官方的解释，说白了就是它可以将.Net程序集反编译为IL语言文件，同时该文件可以被ILasm读取并处理(编译)。&lt;/p&gt;
&lt;p&gt;ILdasm的路径在&lt;code&gt;C:\Program Files (x86)\Microsoft SDKs\Windows\vXXA\bin&lt;/code&gt;下可以找到。&lt;/p&gt;
&lt;p&gt;上一篇文章主要因为涉及到破解被移除了首页，虽然我死不承认，一直说我是在科学使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203154728864-1835704456.png&quot; alt=&quot;20191203154729.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是为了不惹麻烦，这次我学聪明了。我只会科学使用别人的软件，但是我会破解自己的软件。&lt;/p&gt;
&lt;p&gt;为此我特意编写了一个非常牛逼的产品我称之为NiubilityProduct。&lt;br/&gt;它的功能是当输入参数为&lt;code&gt;Niubility&lt;/code&gt;时，它会展示这个产品有多牛逼。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203154034234-1442761846.png&quot; alt=&quot;20191203154033.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般人没办法看到它有多牛逼，为此我们需要&lt;strong&gt;破解&lt;/strong&gt;它。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    string key;
    if (args.Length == 1)
    {
        key = args[0];
    }
    else
    {
        key = Console.ReadLine();
    }

    if (key == &quot;Niubility&quot;)
    {
        Console.WriteLine(&quot;This is a Niubility Product&quot;);
    }
    else
    {
        Console.WriteLine(&quot;Bye !&quot;);
    }
    Console.ReadKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和DnSpy一样，我们可以将dll或exe文件直接拖入到ILdsam。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203155014771-156407317.png&quot; alt=&quot;20191203155014.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;界面比较清爽简洁。双击Main方法就能显示出IL语言&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203155133210-986559846.png&quot; alt=&quot;20191203155133.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是ILdsam不能编辑IL，前面说了它可以将程序集反编译为IL文件。在菜单栏中选择文件然后点击转储，将其保存包含IL的il后缀的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203155633823-380304043.png&quot; alt=&quot;20191203155634.png&quot;/&gt;&lt;br/&gt;他会生成一个il后缀的文件以及一个res后缀的文件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IL文件就是包含IL语言的文件&lt;/li&gt;
&lt;li&gt;res文件包含了托管资源的元数据的资源名称。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203155734096-1057475401.png&quot; alt=&quot;20191203155734.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;IL文件可以使用文本打开&lt;/p&gt;
&lt;pre class=&quot;il&quot;&gt;
&lt;code&gt;.class private auto ansi beforefieldinit NiubilityProduct.Program
       extends [mscorlib]System.Object
{
.method private hidebysig static void  Main(string[] args) cil managed
  {
    .entrypoint
    // 代码大小       77 (0x4d)
    .maxstack  2
    .locals init ([0] string key,
             [1] bool CS$4$0000)
    ...

    IL_0016:  nop
    IL_0017:  call       string [mscorlib]System.Console::ReadLine()
    IL_001c:  stloc.0
    IL_001d:  nop
    IL_001e:  ldloc.0
    IL_001f:  ldstr      &quot;Niubility&quot;
    IL_0024:  call       bool [mscorlib]System.String::op_Equality(string,
                                                                   string)
    IL_0029:  ldc.i4.0
    IL_002a:  ceq
    IL_002c:  stloc.1
    IL_002d:  ldloc.1
    IL_002e:  brtrue.s   IL_003f

    IL_0030:  nop
    IL_0031:  ldstr      &quot;this is a Niubility Product&quot;
    IL_0036:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_003b:  nop
    IL_003c:  nop
    IL_003d:  br.s       IL_004c

    IL_003f:  nop
    IL_0040:  ldstr      &quot;Bye !&quot;
    IL_0045:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_004a:  nop
    IL_004b:  nop
    IL_004c:  ret
  } // end of method Program::Main&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以不管输入什么值, 无需判断直接调用if里面的指令，调用完后会跳转到&lt;code&gt;IL_004C&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;il&quot;&gt;
&lt;code&gt;    IL_0017:  call       string [mscorlib]System.Console::ReadLine()
    IL_001c:  stloc.0
    IL_001d:  nop
    IL_001e:  nop
    IL_001f:  nop
    IL_0024:  nop
    IL_0029:  nop
    IL_002a:  nop
    IL_002c:  nop
    IL_002d:  nop
    IL_002e:  nop
    IL_0031:  ldstr      &quot;this is a Niubility Product&quot;
    IL_0036:  call       void [mscorlib]System.Console::WriteLine(string)
    IL_003b:  nop
    IL_003c:  nop
    IL_003d:  br.s       IL_004c&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改完成我们需要将IL重新进行编译&lt;/p&gt;
&lt;h2 id=&quot;ilasm&quot;&gt;ILasm&lt;/h2&gt;
&lt;p&gt;ILasm在win10下可以直接搜索到。或者在.net 4.0及以上在&lt;code&gt;C:\Windows\Microsoft.NET\Framework64\v4.0.30319&lt;/code&gt;目录可以找到，.net 3.5在&lt;code&gt;C:\Windows\Microsoft.NET\Framework64\v2.0.50727&lt;/code&gt;目录可以找到。&lt;br/&gt;通过命令&lt;code&gt;ilasm /exe /output=输出文件完整路径 /Resource=资源路径 IL文件路径&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
F:\Study\Demo\NiubilityProduct&amp;gt;ilasm /exe /output=NiubilityProduct.exe /Resource=NiubilityProduct.res NiubilityProduct.il

Microsoft (R) .NET Framework IL Assembler.  Version 4.8.3752.0
Copyright (c) Microsoft Corporation.  All rights reserved.
Assembling 'NiubilityProduct.il'  to EXE --&amp;gt; 'NiubilityProduct.exe'
Source file is UTF-8

Assembled method NiubilityProduct.Program::Main
Assembled method NiubilityProduct.Program::.ctor
Creating PE file

Emitting classes:
Class 1:        NiubilityProduct.Program

Emitting fields and methods:
Global
Class 1 Methods: 2;

Emitting events and properties:
Global
Class 1
Writing PE file
Operation completed successfully

F:\Study\Demo\NiubilityProduct&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在调用随便输入什么都能看到这个产品的牛逼之处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203175400550-1228731799.png&quot; alt=&quot;20191203175400.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201912/580757-20191203154041708-111430650.png&quot; alt=&quot;20191203154040.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;本篇文章涉及到使用ILDasm和ILasm进行反编译和编译。掌握了本篇的技能之后你会发现...&lt;span&gt;还是DnSpy好用&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;推荐文献&quot;&gt;推荐文献&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/zery/p/3366175.html&quot;&gt;读懂IL代码就这么简单 (一)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/yangmingming/archive/2010/02/03/1662307.html&quot;&gt;初识Ildasm.exe——IL反编译的实用工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/caokai520/p/4921706.html&quot;&gt;C# IL DASM 使用&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;5.594262295082&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201911/580757-20191127212135806-961496201.png&quot; alt=&quot;20191127212134.png&quot;/&gt;&lt;br/&gt;微信扫一扫二维码关注订阅号杰哥技术分享&lt;br/&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/11978817.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/Jack-Blog/p/11978817.html&lt;/a&gt;&lt;br/&gt;作者：杰哥很忙&lt;br/&gt;本文使用「CC BY 4.0」创作共享协议。欢迎转载，请在明显位置给出出处及链接。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 03 Dec 2019 22:58:00 +0000</pubDate>
<dc:creator>杰哥很忙</dc:creator>
<og:description>本篇文章涉及到使用ILDasm和ILasm进行反编译和编译。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jack-Blog/p/11978817.html</dc:identifier>
</item>
<item>
<title>SpringMVC请求参数接收总结(一) - throwable</title>
<link>http://www.cnblogs.com/throwable/p/11980555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/11980555.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;在日常使用&lt;code&gt;SpringMVC&lt;/code&gt;进行开发的时候，有可能遇到前端各种类型的请求参数，这里做一次相对全面的总结。&lt;code&gt;SpringMVC&lt;/code&gt;中处理控制器参数的接口是&lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt;，此接口有众多子类，分别处理不同(注解类型)的参数，下面只列举几个子类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RequestParamMethodArgumentResolver&lt;/code&gt;：解析处理使用了&lt;code&gt;@RequestParam&lt;/code&gt;注解的参数、&lt;code&gt;MultipartFile&lt;/code&gt;类型参数和&lt;code&gt;Simple&lt;/code&gt;类型(如&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;等类型)参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RequestResponseBodyMethodProcessor&lt;/code&gt;：解析处理&lt;code&gt;@RequestBody&lt;/code&gt;注解的参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PathVariableMapMethodArgumentResolver&lt;/code&gt;：解析处理&lt;code&gt;@PathVariable&lt;/code&gt;注解的参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际上，一般在解析一个控制器的请求参数的时候，用到的是&lt;code&gt;HandlerMethodArgumentResolverComposite&lt;/code&gt;，里面装载了所有启用的&lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt;子类。而&lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt;子类在解析参数的时候使用到&lt;code&gt;HttpMessageConverter&lt;/code&gt;（实际上也是一个列表，进行遍历匹配解析）子类进行匹配解析，常见的如&lt;code&gt;MappingJackson2HttpMessageConverter&lt;/code&gt;（使用&lt;code&gt;Jackson&lt;/code&gt;进行序列化和反序列化）。而&lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt;子类到底依赖什么&lt;code&gt;HttpMessageConverter&lt;/code&gt;实例实际上是由请求头中的&lt;code&gt;Content-Type&lt;/code&gt;（在&lt;code&gt;SpringMVC&lt;/code&gt;中统一命名为&lt;code&gt;MediaType&lt;/code&gt;，见&lt;code&gt;org.springframework.http.MediaType&lt;/code&gt;）决定的，因此我们在处理控制器的请求参数之前必须要明确外部请求的&lt;code&gt;Content-Type&lt;/code&gt;到底是什么。上面的逻辑可以直接看源码&lt;code&gt;AbstractMessageConverterMethodArgumentResolver#readWithMessageConverters&lt;/code&gt;，思路是比较清晰的。在&lt;code&gt;@RequestMapping&lt;/code&gt;注解中，&lt;code&gt;produces&lt;/code&gt;和&lt;code&gt;consumes&lt;/code&gt;属性就是和请求或者响应的&lt;code&gt;Content-Type&lt;/code&gt;相关的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;consumes&lt;/code&gt;属性：指定处理请求的提交内容类型（&lt;code&gt;Content-Type&lt;/code&gt;），例如&lt;code&gt;application/json&lt;/code&gt;、&lt;code&gt;text/html&lt;/code&gt;等等，只有命中了对应的&lt;code&gt;Content-Type&lt;/code&gt;的值才会接受该请求。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;produces&lt;/code&gt;属性：指定返回的内容类型，仅当某个请求的请求头中的（&lt;code&gt;Accept&lt;/code&gt;）类型中包含该指定类型才返回，如果返回的是JSON数据一般考虑使用&lt;code&gt;application/json;charset=UTF-8&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外提一点，&lt;code&gt;SpringMVC&lt;/code&gt;中默认使用&lt;code&gt;Jackson&lt;/code&gt;作为JSON的工具包，如果不是完全理解透整套源码的运作，一般不是十分建议修改默认使用的&lt;code&gt;MappingJackson2HttpMessageConverter&lt;/code&gt;（例如有些人喜欢使用&lt;code&gt;FastJson&lt;/code&gt;，实现&lt;code&gt;HttpMessageConverter&lt;/code&gt;引入&lt;code&gt;FastJson&lt;/code&gt;做HTTP消息转换器，这种做法并不推荐）。&lt;/p&gt;
&lt;h2 id=&quot;springmvc请求参数接收&quot;&gt;SpringMVC请求参数接收&lt;/h2&gt;
&lt;p&gt;其实一般的表单或者JSON数据的请求都是相对简单的，一些复杂的处理主要包括URL路径参数、文件上传、数组或者列表类型数据等。另外，关于参数类型中存在日期类型属性（例如&lt;code&gt;java.util.Date&lt;/code&gt;、&lt;code&gt;java.sql.Date&lt;/code&gt;、&lt;code&gt;java.time.LocalDate&lt;/code&gt;、&lt;code&gt;java.time.LocalDateTime&lt;/code&gt;、&lt;code&gt;java.time.ZonedDateTime&lt;/code&gt;等等），解析的时候一般需要自定义实现的逻辑实现&lt;code&gt;String--&amp;gt;日期类型&lt;/code&gt;的转换。其实道理很简单，日期相关的类型对于每个国家、每个时区甚至每个使用者来说认知都不一定相同，所以&lt;code&gt;SpringMVC&lt;/code&gt;并没有对于日期时间类型的解析提供一个通用的解决方案。在演示一些例子可能用到下面的模特类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class User {

    private String name;
    private Integer age;
    private List&amp;lt;Contact&amp;gt; contacts;
}

@Data
public class Contact {

    private String name;
    private String phone;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面主要以&lt;code&gt;HTTP&lt;/code&gt;的&lt;code&gt;GET&lt;/code&gt;方法和&lt;code&gt;POST&lt;/code&gt;方法提交在&lt;code&gt;SpringMVC&lt;/code&gt;体系中正确处理参数的例子进行分析，还会花精力整理&lt;code&gt;SpringMVC&lt;/code&gt;体系中&lt;strong&gt;独有的&lt;code&gt;URL&lt;/code&gt;路径参数&lt;/strong&gt;处理的一些技巧以及最常见的&lt;strong&gt;日期参数&lt;/strong&gt;处理的合理实践（对于&lt;code&gt;GET&lt;/code&gt;方法和&lt;code&gt;POST&lt;/code&gt;方法提交的参数处理，基本囊括了其他如&lt;code&gt;DELETE&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;等方法的参数处理，随机应变即可）。&lt;/p&gt;
&lt;h3 id=&quot;get方法请求参数处理&quot;&gt;GET方法请求参数处理&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HTTP(s)&lt;/code&gt;协议使用&lt;code&gt;GET&lt;/code&gt;方法进行请求的时候，提交的参数位于&lt;code&gt;URL&lt;/code&gt;模式的&lt;code&gt;Query&lt;/code&gt;部分，也就是&lt;code&gt;URL&lt;/code&gt;的&lt;code&gt;?&lt;/code&gt;之后的参数，格式是&lt;code&gt;key1=value1&amp;amp;key2=value2&lt;/code&gt;。&lt;code&gt;GET&lt;/code&gt;方法请求参数可以有多种方法获取：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;@RequestParam&lt;/code&gt;注解处理。&lt;/li&gt;
&lt;li&gt;使用对象接收，注意对象的属性名称要和&lt;code&gt;Query&lt;/code&gt;中的参数名称一致。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;HttpServletRequest&lt;/code&gt;实例提供的方法（不推荐，存在硬编码）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;假设请求的&lt;code&gt;URL&lt;/code&gt;为&lt;code&gt;http://localhost:8080/get?name=doge&amp;amp;age=26&lt;/code&gt;，那么控制器如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@RestController
public class SampleController {

    @GetMapping(path = &quot;/get1&quot;)
    public void get1(@RequestParam(name = &quot;name&quot;) String name,
                     @RequestParam(name = &quot;age&quot;) Integer age) {
        log.info(&quot;name:{},age:{}&quot;, name, age);
    }

    @GetMapping(path = &quot;/get2&quot;)
    public void get2(UserVo vo) {
        log.info(&quot;name:{},age:{}&quot;, vo.getName(), vo.getAge());
    }

    @GetMapping(path = &quot;/get3&quot;)
    public void get3(HttpServletRequest request) {
        String name = request.getParameter(&quot;name&quot;);
        String age = request.getParameter(&quot;age&quot;);
        log.info(&quot;name:{},age:{}&quot;, name, age);
    }

    @Data
    public static class UserVo {

        private String name;
        private Integer age;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;表单参数&quot;&gt;表单参数&lt;/h3&gt;
&lt;p&gt;表单参数，一般对应于页面上&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;标签内的所有&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;标签的&lt;code&gt;name-value&lt;/code&gt;聚合而成的参数，一般&lt;code&gt;Content-Type&lt;/code&gt;指定为&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，也就是会进行&lt;code&gt;URL&lt;/code&gt;编码。下面介绍几种常见的表单参数提交的参数形式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;【非对象】- 非对象类型单个参数接收。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-1.png&quot; alt=&quot;spmvc-p-1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应的控制器如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/post&quot;)
public String post(@RequestParam(name = &quot;name&quot;) String name,
                   @RequestParam(name = &quot;age&quot;) Integer age) {
    String content = String.format(&quot;name = %s,age = %d&quot;, name, age);
    log.info(content);
    return content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说实话，如果有毅力的话，所有的复杂参数的提交最终都可以转化为多个单参数接收，不过这样做会产生十分多冗余的代码，而且可维护性比较低。这种情况下，用到的参数处理器是&lt;code&gt;RequestParamMapMethodArgumentResolver&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;【对象】 - 对象类型参数接收。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们接着写一个接口用于提交用户信息，用到的是上面提到的模特类，主要包括用户姓名、年龄和联系人信息列表，这个时候，我们目标的控制器最终编码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/user&quot;)
public User saveUser(User user) {
    log.info(user.toString());
    return user;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还是指定&lt;code&gt;Content-Type&lt;/code&gt;为&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;，接着我们需要构造请求参数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-2.png&quot; alt=&quot;spmvc-p-2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为没有使用注解，最终的参数处理器为&lt;code&gt;ServletModelAttributeMethodProcessor&lt;/code&gt;，主要是把&lt;code&gt;HttpServletRequest&lt;/code&gt;中的表单参数封装到&lt;code&gt;MutablePropertyValues&lt;/code&gt;实例中，再通过参数类型实例化(通过构造反射创建&lt;code&gt;User&lt;/code&gt;实例)，反射匹配属性进行值的填充。另外，请求复杂参数里面的列表属性请求参数看起来比较奇葩，实际上和在&lt;code&gt;.properties&lt;/code&gt;文件中添加最终映射到&lt;code&gt;Map&lt;/code&gt;类型的参数的写法是一致的。那么，能不能把整个请求参数塞在一个字段中提交呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-3.png&quot; alt=&quot;spmvc-p-3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接这样做是不行的，因为实际提交的&lt;code&gt;Form&lt;/code&gt;表单，&lt;code&gt;key&lt;/code&gt;是&lt;code&gt;user&lt;/code&gt;字符串，&lt;code&gt;value&lt;/code&gt;实际上也是一个字符串，缺少一个&lt;code&gt;String-&amp;gt;User&lt;/code&gt;类型的转换器，实际上&lt;code&gt;RequestParamMethodArgumentResolver&lt;/code&gt;依赖&lt;code&gt;WebConversionService&lt;/code&gt;中&lt;code&gt;Converter&lt;/code&gt;实例列表进行参数转换：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-4.png&quot; alt=&quot;spmvc-p-4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解决办法还是有的，添加一个&lt;code&gt;org.springframework.core.convert.converter.Converter&lt;/code&gt;实现即可：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class StringUserConverter implements Converter&amp;lt;String, User&amp;gt; {

    @Autowaired
    private ObjectMapper objectMapper;

    @Override
    public User convert(String source) {
        try {
               return objectMapper.readValue(source, User.class);
            } catch (IOException e) {
               throw new IllegalArgumentException(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这种做法属于曲线救国的做法，不推荐使用在生产环境，但是如果有些第三方接口的对接无法避免这种参数，可以选择这种实现方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;【数组】 - 列表或者数组类型参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;极度不推荐使用在&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;这种媒体类型的表单提交的形式下强行使用列表或者数组类型参数，除非是为了兼容处理历史遗留系统的参数提交处理。例如提交的参数形式是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;list = [&quot;string-1&quot;, &quot;string-2&quot;, &quot;string-3&quot;]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么表单参数的形式要写成：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;list[0]&lt;/td&gt;
&lt;td&gt;string-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;list[1]&lt;/td&gt;
&lt;td&gt;string-2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;list[2]&lt;/td&gt;
&lt;td&gt;string-3&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;控制器的代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(path = &quot;/list&quot;)
public void list(@RequestParam(name=&quot;list&quot;) List&amp;lt;String&amp;gt; list) {
    log.info(list);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个更加复杂的例子如下，假设想要提交的报文格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user = [{&quot;name&quot;:&quot;doge-1&quot;,&quot;age&quot;: 21},{&quot;name&quot;:&quot;doge-2&quot;,&quot;age&quot;: 22}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么表单参数的形式要写成：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;user[0].name&lt;/td&gt;
&lt;td&gt;doge-1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;user[0].age&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;user[1].name&lt;/td&gt;
&lt;td&gt;doge-2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;user[1].age&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;控制器的代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(path = &quot;/user&quot;)
public void saveUsers(@RequestParam(name=&quot;user&quot;) List&amp;lt;UserVo&amp;gt; users) {
    log.info(users);
}

@Data
public class UserVo{

    private String name;
    private Integer age;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;json参数&quot;&gt;JSON参数&lt;/h3&gt;
&lt;p&gt;一般来说，直接在&lt;code&gt;POST&lt;/code&gt;请求中的请求体提交一个JSON字符串这种方式对于&lt;code&gt;SpringMVC&lt;/code&gt;来说是比较友好的，只需要把&lt;code&gt;Content-Type&lt;/code&gt;设置为&lt;code&gt;application/json&lt;/code&gt;，提交一个原始的JSON字符串即可，控制器方法参数使用&lt;code&gt;@RequestBody&lt;/code&gt;注解处理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-5.png&quot; alt=&quot;spmvc-p-5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后端控制器的代码也比较简单：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/user-2&quot;)
public User saveUser2(@RequestBody User user) {
    log.info(user.toString());
    return user;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为使用了&lt;code&gt;@RequestBody&lt;/code&gt;注解，最终使用到的参数处理器为&lt;code&gt;RequestResponseBodyMethodProcessor&lt;/code&gt;，实际上会用到&lt;code&gt;MappingJackson2HttpMessageConverter&lt;/code&gt;进行参数类型的转换，底层依赖到&lt;code&gt;Jackson&lt;/code&gt;相关的包。推荐使用这种方式，这是最常用也是最稳健的&lt;code&gt;JSON&lt;/code&gt;参数处理方式。&lt;/p&gt;
&lt;h2 id=&quot;url路径参数&quot;&gt;URL路径参数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;URL&lt;/code&gt;路径参数，或者叫请求路径参数是基于URL模板获取到的参数，例如&lt;code&gt;/user/{userId}&lt;/code&gt;是一个&lt;code&gt;URL&lt;/code&gt;模板(&lt;code&gt;URL&lt;/code&gt;模板中的参数占位符是{})，实际请求的&lt;code&gt;URL&lt;/code&gt;为&lt;code&gt;/user/1&lt;/code&gt;，那么通过匹配实际请求的&lt;code&gt;URL&lt;/code&gt;和&lt;code&gt;URL&lt;/code&gt;模板就能提取到&lt;code&gt;userId&lt;/code&gt;为1。在&lt;code&gt;SpringMVC&lt;/code&gt;中，&lt;code&gt;URL&lt;/code&gt;模板中的路径参数叫做&lt;code&gt;PathVariable&lt;/code&gt;，对应注解&lt;code&gt;@PathVariable&lt;/code&gt;，对应的参数处理器为&lt;code&gt;PathVariableMethodArgumentResolver&lt;/code&gt;。&lt;strong&gt;注意一点是，@PathVariable的解析是按照value(name)属性进行匹配，和URL参数的顺序是无关的&lt;/strong&gt;。举个简单的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-6.png&quot; alt=&quot;spmvc-p-6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后台的控制器如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/user/{name}/{age}&quot;)
public String findUser1(@PathVariable(value = &quot;age&quot;) Integer age,
                        @PathVariable(value = &quot;name&quot;) String name) {
    String content = String.format(&quot;name = %s,age = %d&quot;, name, age);
    log.info(content);
    return content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种用法被广泛使用于&lt;code&gt;Representational State Transfer(REST)&lt;/code&gt;的软件架构风格，个人觉得这种风格是比较灵活和清晰的(从URL和请求方法就能完全理解接口的意义和功能)。下面再介绍两种相对特殊的使用方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;带条件的&lt;code&gt;URL&lt;/code&gt;参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实路径参数支持正则表达式，例如我们在使用&lt;code&gt;/sex/{sex}&lt;/code&gt;接口的时候，要求&lt;code&gt;sex&lt;/code&gt;必须是&lt;code&gt;F(Female)&lt;/code&gt;或者&lt;code&gt;M(Male)&lt;/code&gt;，那么我们的URL模板可以定义为&lt;code&gt;/sex/{sex:M|F}&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/sex/{sex:M|F}&quot;)
public String findUser2(@PathVariable(value = &quot;sex&quot;) String sex){
    log.info(sex);
    return sex;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有&lt;code&gt;/sex/F&lt;/code&gt;或者&lt;code&gt;/sex/M&lt;/code&gt;的请求才会进入&lt;code&gt;findUser2()&lt;/code&gt;控制器方法，其他该路径前缀的请求都是非法的，会返回404状态码。这里仅仅是介绍了一个最简单的&lt;code&gt;URL&lt;/code&gt;参数正则表达式的使用方式，更强大的用法可以自行摸索。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@MatrixVariable&lt;/code&gt;的使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;MatrixVariable&lt;/code&gt;也是&lt;code&gt;URL&lt;/code&gt;参数的一种，对应注解&lt;code&gt;@MatrixVariable&lt;/code&gt;，不过它并不是&lt;code&gt;URL&lt;/code&gt;中的一个值(这里的值指定是两个&quot;/&quot;之间的部分)，而是值的一部分，它通过&quot;;&quot;进行分隔，通过&quot;=&quot;进行K-V设置。说起来有点抽象，举个例子：假如我们需要打电话给一个名字为doge，性别是男，分组是码畜的程序员，&lt;code&gt;GET&lt;/code&gt;请求的&lt;code&gt;URL&lt;/code&gt;可以表示为：&lt;code&gt;/call/doge;gender=male;group=programmer&lt;/code&gt;，我们设计的控制器方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/call/{name}&quot;)
public String find(@PathVariable(value = &quot;name&quot;) String name,
                   @MatrixVariable(value = &quot;gender&quot;) String gender,
                   @MatrixVariable(value = &quot;group&quot;) String group) {
    String content = String.format(&quot;name = %s,gender = %s,group = %s&quot;, name, gender, group);
    log.info(content);
    return content;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，如果你按照上面的例子写好代码，尝试请求一下该接口发现是报错的：&lt;code&gt;400 Bad Request - Missing matrix variable 'gender' for method parameter of type String&lt;/code&gt;。这是因为&lt;code&gt;@MatrixVariable&lt;/code&gt;注解的使用是不安全的，在&lt;code&gt;SpringMVC&lt;/code&gt;中默认是关闭对其支持。要开启对&lt;code&gt;@MatrixVariable&lt;/code&gt;的支持，需要设置&lt;code&gt;RequestMappingHandlerMapping#setRemoveSemicolonContent&lt;/code&gt;方法为&lt;code&gt;false&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class CustomMvcConfiguration implements InitializingBean {

    @Autowired
    private RequestMappingHandlerMapping requestMappingHandlerMapping;

    @Override
    public void afterPropertiesSet() throws Exception {
        requestMappingHandlerMapping.setRemoveSemicolonContent(false);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除非有很特殊的需要，否则不建议使用&lt;code&gt;@MatrixVariable&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;文件上传&quot;&gt;文件上传&lt;/h2&gt;
&lt;p&gt;文件上传在使用&lt;code&gt;POSTMAN&lt;/code&gt;模拟请求的时候需要选择&lt;code&gt;form-data&lt;/code&gt;，&lt;code&gt;POST&lt;/code&gt;方式进行提交：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-8.png&quot; alt=&quot;spmvc-p-8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设我们在D盘有一个图片文件叫doge.jpg，现在要通过本地服务接口把文件上传，控制器的代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/file1&quot;)
public String file1(@RequestPart(name = &quot;file1&quot;) MultipartFile multipartFile) {
    String content = String.format(&quot;name = %s,originName = %s,size = %d&quot;,
    multipartFile.getName(), multipartFile.getOriginalFilename(), multipartFile.getSize());
    log.info(content);
    return content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;控制台输出是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;name = file1,originName = doge.jpg,size = 68727&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可能有点疑惑，参数是怎么来的，我们可以用&lt;code&gt;Fildder&lt;/code&gt;软件抓个包看下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-7.png&quot; alt=&quot;spmvc-p-7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可知&lt;code&gt;MultipartFile&lt;/code&gt;实例的主要属性分别来自&lt;code&gt;Content-Disposition&lt;/code&gt;、&lt;code&gt;Content-Type&lt;/code&gt;和&lt;code&gt;Content-Length&lt;/code&gt;，另外，&lt;code&gt;InputStream&lt;/code&gt;用于读取请求体的最后部分(文件的字节序列)。参数处理器用到的是&lt;code&gt;RequestPartMethodArgumentResolver&lt;/code&gt;(记住一点，使用了&lt;code&gt;@RequestPart&lt;/code&gt;和&lt;code&gt;MultipartFile&lt;/code&gt;一定是使用此参数处理器)。在其他情况下，使用&lt;code&gt;@RequestParam&lt;/code&gt;和&lt;code&gt;MultipartFile&lt;/code&gt;或者仅仅使用&lt;code&gt;MultipartFile&lt;/code&gt;(参数的名字必须和&lt;code&gt;POST&lt;/code&gt;表单中的&lt;code&gt;Content-Disposition&lt;/code&gt;描述的&lt;code&gt;name&lt;/code&gt;一致)也可以接收上传的文件数据，主要是通过&lt;code&gt;RequestParamMethodArgumentResolver&lt;/code&gt;进行解析处理的，它的功能比较强大，具体可以看其&lt;code&gt;supportsParameter&lt;/code&gt;方法，这两种情况的控制器方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/file2&quot;)
public String file2(MultipartFile file1) {
    String content = String.format(&quot;name = %s,originName = %s,size = %d&quot;,
                file1.getName(), file1.getOriginalFilename(), file1.getSize());
    log.info(content);
    return content;
}

@PostMapping(value = &quot;/file3&quot;)
public String file3(@RequestParam(name = &quot;file1&quot;) MultipartFile multipartFile) {
    String content = String.format(&quot;name = %s,originName = %s,size = %d&quot;,
            multipartFile.getName(), multipartFile.getOriginalFilename(), multipartFile.getSize());
    log.info(content);
    return content;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他参数&quot;&gt;其他参数&lt;/h2&gt;
&lt;p&gt;其他参数主要包括请求头、&lt;code&gt;Cookie&lt;/code&gt;、&lt;code&gt;Model&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt;等相关参数，还有一些并不是很常用或者一些相对原生的属性值获取(例如&lt;code&gt;HttpServletRequest&lt;/code&gt;、&lt;code&gt;HttpServletResponse&lt;/code&gt;等)不做讨论。&lt;/p&gt;
&lt;h3 id=&quot;请求头&quot;&gt;请求头&lt;/h3&gt;
&lt;p&gt;请求头的值主要通过&lt;code&gt;@RequestHeader&lt;/code&gt;注解的参数获取，参数处理器是&lt;code&gt;RequestHeaderMethodArgumentResolver&lt;/code&gt;，需要在注解中指定请求头的&lt;code&gt;Key&lt;/code&gt;。简单实用如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-9.png&quot; alt=&quot;spmvc-p-9&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制器方法代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/header&quot;)
public String header(@RequestHeader(name = &quot;Content-Type&quot;) String Content-Type) {
    return Content-Type;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cookie&quot;&gt;Cookie&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Cookie&lt;/code&gt;的值主要通过&lt;code&gt;@CookieValue&lt;/code&gt;注解的参数获取，参数处理器为&lt;code&gt;ServletCookieValueMethodArgumentResolver&lt;/code&gt;，需要在注解中指定&lt;code&gt;Cookie&lt;/code&gt;的&lt;code&gt;Key&lt;/code&gt;。控制器方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/cookie&quot;)
public String cookie(@CookieValue(name = &quot;JSESSIONID&quot;) String sessionId) {
    return sessionId;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;model类型参数&quot;&gt;Model类型参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Model&lt;/code&gt;类型参数的处理器是&lt;code&gt;ModelMethodProcessor&lt;/code&gt;，实际上处理此参数是直接返回&lt;code&gt;ModelAndViewContainer&lt;/code&gt;实例中的&lt;code&gt;Model&lt;/code&gt;(&lt;code&gt;ModelMap&lt;/code&gt;类型)，因为要桥接不同的接口和类的功能，因此回调的实例是&lt;code&gt;BindingAwareModelMap&lt;/code&gt;类型，此类型继承自&lt;code&gt;ModelMap&lt;/code&gt;同时实现了&lt;code&gt;Model&lt;/code&gt;接口。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/model&quot;)
public String model(Model model, ModelMap modelMap) {
    log.info(&quot;{}&quot;, model == modelMap);
    return &quot;success&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意调用此接口，控制台输出INFO日志内容为：true。还要注意一点：&lt;code&gt;ModelMap&lt;/code&gt;或者&lt;code&gt;Model&lt;/code&gt;中添加的属性项会附加到&lt;code&gt;HttpRequestServlet&lt;/code&gt;实例中带到页面中进行渲染。&lt;/p&gt;
&lt;h3 id=&quot;modelattribute参数&quot;&gt;@ModelAttribute参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@ModelAttribute&lt;/code&gt;注解处理的参数处理器为&lt;code&gt;ModelAttributeMethodProcessor&lt;/code&gt;，&lt;code&gt;@ModelAttribute&lt;/code&gt;的功能源码的注释如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Annotation that binds a method parameter or method return value to a named model attribute, exposed to a web view.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来说，就是通过&lt;code&gt;key-value&lt;/code&gt;形式绑定方法参数或者方法返回值到&lt;code&gt;Model(Map)&lt;/code&gt;中，区别下面三种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;@ModelAttribute&lt;/code&gt;使用在方法(返回值)上，方法没有返回值(&lt;code&gt;void&lt;/code&gt;类型)， &lt;code&gt;Model(Map)&lt;/code&gt;参数需要自行设置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ModelAttribute&lt;/code&gt;使用在方法(返回值)上，方法有返回值(非&lt;code&gt;void&lt;/code&gt;类型)，返回值会添加到&lt;code&gt;Model(Map)&lt;/code&gt;参数，&lt;code&gt;key&lt;/code&gt;由&lt;code&gt;@ModelAttribute&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;指定，否则会使用返回值类型字符串(首写字母变为小写，如返回值类型为&lt;code&gt;Integer&lt;/code&gt;，则&lt;code&gt;key&lt;/code&gt;为&lt;code&gt;integer&lt;/code&gt;)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@ModelAttribute&lt;/code&gt;使用在方法参数中，则可以获取同一个控制器中的已经设置的&lt;code&gt;@ModelAttribute&lt;/code&gt;对应的值。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在一个控制器(使用了&lt;code&gt;@Controller&lt;/code&gt;)中，如果存在一到多个使用了&lt;code&gt;@ModelAttribute&lt;/code&gt;的方法，这些方法总是在进入控制器方法之前执行，并且执行顺序是由加载顺序决定的(具体的顺序是带参数的优先，并且按照方法首字母升序排序)，举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Slf4j
@RestController
public class ModelAttributeController {

    @ModelAttribute
    public void before(Model model) {
        log.info(&quot;before..........&quot;);
        model.addAttribute(&quot;before&quot;, &quot;beforeValue&quot;);
    }

    @ModelAttribute(value = &quot;beforeArg&quot;)
    public String beforeArg() {
        log.info(&quot;beforeArg..........&quot;);
        return &quot;beforeArgValue&quot;;
    }

    @GetMapping(value = &quot;/modelAttribute&quot;)
    public String modelAttribute(Model model, @ModelAttribute(value = &quot;beforeArg&quot;) String beforeArg) {
        log.info(&quot;modelAttribute..........&quot;);
        log.info(&quot;beforeArg..........{}&quot;, beforeArg);
        log.info(&quot;{}&quot;, model);
        return &quot;success&quot;;
    }

    @ModelAttribute
    public void after(Model model) {
        log.info(&quot;after..........&quot;);
        model.addAttribute(&quot;after&quot;, &quot;afterValue&quot;);
    }

    @ModelAttribute(value = &quot;afterArg&quot;)
    public String afterArg() {
        log.info(&quot;afterArg..........&quot;);
        return &quot;afterArgValue&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用此接口，控制台输出日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;after..........
before..........
afterArg..........
beforeArg..........
modelAttribute..........
beforeArg..........beforeArgValue
{after=afterValue, before=beforeValue, afterArg=afterArgValue, beforeArg=beforeArgValue}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以印证排序规则和参数设置、获取的结果和前面的分析是一致的。&lt;/p&gt;
&lt;h3 id=&quot;errors或者bindingresult参数&quot;&gt;Errors或者BindingResult参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Errors&lt;/code&gt;其实是&lt;code&gt;BindingResult&lt;/code&gt;的父接口，&lt;code&gt;BindingResult&lt;/code&gt;主要用于回调JSR参数校验异常的属性项，如果JSR校验异常，一般会抛出&lt;code&gt;MethodArgumentNotValidException&lt;/code&gt;异常，并且会返回400(Bad Request)，见全局异常处理器&lt;code&gt;DefaultHandlerExceptionResolver&lt;/code&gt;。&lt;code&gt;Errors&lt;/code&gt;类型的参数处理器为&lt;code&gt;ErrorsMethodArgumentResolver&lt;/code&gt;。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/errors&quot;)
public String errors(@RequestBody @Validated ErrorsModel errors, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        for (ObjectError objectError : bindingResult.getAllErrors()) {
            log.warn(&quot;name={},message={}&quot;, objectError.getObjectName(), objectError.getDefaultMessage());
        }
    }
    return errors.toString();
}

//ErrorsModel
@Data
@NoArgsConstructor
public class ErrorsModel {
    @NotNull(message = &quot;id must not be null!&quot;)
    private Integer id;
    @NotEmpty(message = &quot;errors name must not be empty!&quot;)
    private String name;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用接口控制台Warn日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;name=errors,message=errors name must not be empty!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般情况下，不建议用这种方式处理JSR校验异常的属性项，因为会涉及到大量的重复的硬编码工作，建议：方式一直接继承&lt;code&gt;ResponseEntityExceptionHandler&lt;/code&gt;覆盖对应的方法或者方式二同时使用&lt;code&gt;@ExceptionHandler&lt;/code&gt;和&lt;code&gt;@(Rest)ControllerAdvice&lt;/code&gt;注解进行异常处理。例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestControllerAdvice
public class ApplicationRestControllerAdvice{

    @ExceptionHandler(BusinessException.class)
    public Response handleBusinessException(BusinessException e, HttpServletRequest request){
           // 这里处理异常和返回值
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;value参数&quot;&gt;@Value参数&lt;/h3&gt;
&lt;p&gt;控制器方法的参数可以是&lt;code&gt;@Value&lt;/code&gt;注解修饰的参数，会从&lt;code&gt;Environment&lt;/code&gt;实例中装配和转换属性值到对应的参数中(也就是参数的来源并不是请求体)，参数处理器为&lt;code&gt;ExpressionValueMethodArgumentResolver&lt;/code&gt;。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/value&quot;)
public String value(@Value(value = &quot;${spring.application.name}&quot;) String name) {
    log.info(&quot;spring.application.name={}&quot;, name);
    return name;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;spring.application.name&lt;/code&gt;属性一般在配置文件中指定，在加载配置文件属性的时候添加到全局的&lt;code&gt;Environment&lt;/code&gt;中。&lt;/p&gt;
&lt;h3 id=&quot;map类型参数&quot;&gt;Map类型参数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;类型参数的范围相对比较广，对应一系列的参数处理器，注意区别使用了上面提到的部分注解的&lt;code&gt;Map&lt;/code&gt;类型和完全不使用注解的&lt;code&gt;Map&lt;/code&gt;类型参数，两者的处理方式不相同。下面列举几个相对典型的&lt;code&gt;Map&lt;/code&gt;类型参数处理例子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不使用任何注解的Map&amp;lt;String,Object&amp;gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况下参数实际上直接回调&lt;code&gt;ModelAndViewContainer&lt;/code&gt;中的&lt;code&gt;ModelMap&lt;/code&gt;实例，参数处理器为&lt;code&gt;MapMethodProcessor&lt;/code&gt;，往&lt;code&gt;Map&lt;/code&gt;参数中添加的属性将会带到页面中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用@RequestParam注解的Map&amp;lt;String,Object&amp;gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况下的参数处理器为&lt;code&gt;RequestParamMapMethodArgumentResolver&lt;/code&gt;，使用的请求方式需要指定&lt;code&gt;Content-Type&lt;/code&gt;为&lt;code&gt;x-www-form-urlencoded&lt;/code&gt;，不能使用&lt;code&gt;application/json&lt;/code&gt;的方式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-10.png&quot; alt=&quot;spmvc-p-10&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制器代码为：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/map&quot;)
public String mapArgs(@RequestParam Map&amp;lt;String, Object&amp;gt; map) {
    log.info(&quot;{}&quot;, map);
    return map.toString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用@RequestHeader注解的Map&amp;lt;String,Object&amp;gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况下的参数处理器为&lt;code&gt;RequestHeaderMapMethodArgumentResolver&lt;/code&gt;，作用是获取请求的所有请求头的&lt;code&gt;Key-Value&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用@PathVariable注解的Map&amp;lt;String,Object&amp;gt;参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种情况下的参数处理器为&lt;code&gt;PathVariableMapMethodArgumentResolver&lt;/code&gt;，作用是获取所有路径参数封装为&lt;code&gt;Key-Value&lt;/code&gt;结构。&lt;/p&gt;
&lt;h3 id=&quot;multipartfile集合-批量文件上传&quot;&gt;MultipartFile集合-批量文件上传&lt;/h3&gt;
&lt;p&gt;批量文件上传的时候，我们一般需要接收一个&lt;code&gt;MultipartFile&lt;/code&gt;集合，可以有两种选择：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;MultipartHttpServletRequest&lt;/code&gt;参数，直接调用&lt;code&gt;getFiles&lt;/code&gt;方法获取&lt;code&gt;MultipartFile&lt;/code&gt;列表。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;@RequestParam&lt;/code&gt;注解修饰&lt;code&gt;MultipartFile&lt;/code&gt;列表，参数处理器是&lt;code&gt;RequestParamMethodArgumentResolver&lt;/code&gt;，其实就是第1种方式的封装而已。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-11.png&quot; alt=&quot;spmvc-p-11&quot;/&gt;&lt;/p&gt;
&lt;p&gt;控制器方法代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/parts&quot;)
public String partArgs(@RequestParam(name = &quot;file&quot;) List&amp;lt;MultipartFile&amp;gt; parts) {
    log.info(&quot;{}&quot;, parts);
    return parts.toString();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;日期类型参数处理&quot;&gt;日期类型参数处理&lt;/h2&gt;
&lt;p&gt;日期参数处理个人认为是请求参数处理中最复杂的，因为一般日期处理的逻辑不是通用的，过多的定制化处理导致很难有一个统一的标准处理逻辑去处理和转换日期类型的参数。不过，这里介绍几个通用的方法，以应对各种奇葩的日期格式。下面介绍的例子中全部使用Jdk8中引入的日期时间API，围绕&lt;code&gt;java.util.Date&lt;/code&gt;为核心的日期时间API的使用方式类同。&lt;/p&gt;
&lt;h3 id=&quot;一统一以字符串形式接收&quot;&gt;一、统一以字符串形式接收&lt;/h3&gt;
&lt;p&gt;这种是最原始但是最奏效的方式，统一以字符串形式接收，然后自行处理类型转换，下面给个小例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/date1&quot;)
public String date1(@RequestBody UserDto userDto) {
    UserEntity userEntity = new UserEntity();
    userEntity.setUserId(userDto.getUserId());
    userEntity.setBirthdayTime(LocalDateTime.parse(userDto.getBirthdayTime(), FORMATTER));
    userEntity.setGraduationTime(LocalDateTime.parse(userDto.getGraduationTime(), FORMATTER));
    log.info(userEntity.toString());
    return &quot;success&quot;;
}

@Data
public class UserDto {

    private String userId;
    private String birthdayTime;
    private String graduationTime;
}

@Data
public class UserEntity {

    private String userId;
    private LocalDateTime birthdayTime;
    private LocalDateTime graduationTime;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-12.png&quot; alt=&quot;spmvc-p-12&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用字符串接收后再转换的缺点就是模板代码太多，编码风格不够简洁，重复性工作太多。&lt;/p&gt;
&lt;h3 id=&quot;二使用注解datetimeformat或者jsonformat&quot;&gt;二、使用注解@DateTimeFormat或者@JsonFormat&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;@DateTimeFormat&lt;/code&gt;注解配合&lt;code&gt;@RequestBody&lt;/code&gt;的参数使用的时候，会发现抛出&lt;code&gt;InvalidFormatException&lt;/code&gt;异常，提示转换失败，这是因为在处理此注解的时候，只支持&lt;code&gt;Form&lt;/code&gt;表单提交(&lt;code&gt;Content-Type&lt;/code&gt;为&lt;code&gt;x-www-form-urlencoded&lt;/code&gt;)，例子如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://throwable-blog-1256189093.cos.ap-guangzhou.myqcloud.com/201912/spmvc-p-13.png&quot; alt=&quot;spmvc-p-13&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Data
public class UserDto2 {

    private String userId;
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime birthdayTime;
    @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
    private LocalDateTime graduationTime;
}


@PostMapping(value = &quot;/date2&quot;)
public String date2(UserDto2 userDto2) {
    log.info(userDto2.toString());
    return &quot;success&quot;;
}

//或者像下面这样
@PostMapping(value = &quot;/date2&quot;)
public String date2(@RequestParam(&quot;name&quot;=&quot;userId&quot;)String userId,
                    @RequestParam(&quot;name&quot;=&quot;birthdayTime&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) LocalDateTime birthdayTime,
                    @RequestParam(&quot;name&quot;=&quot;graduationTime&quot;) @DateTimeFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;) LocalDateTime graduationTime) {
    return &quot;success&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而&lt;code&gt;@JsonFormat&lt;/code&gt;注解可使用在Form表单或者JSON请求参数的场景，因此更推荐使用&lt;code&gt;@JsonFormat&lt;/code&gt;注解，不过注意需要指定时区(&lt;code&gt;timezone&lt;/code&gt;属性，例如在中国是东八区&lt;code&gt;GMT+8&lt;/code&gt;)，否则有可能导致出现&lt;strong&gt;时差&lt;/strong&gt;，举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/date2&quot;)
public String date2(@RequestBody UserDto2 userDto2) {
    log.info(userDto2.toString());
    return &quot;success&quot;;
}

@Data
public class UserDto2 {

    private String userId;
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)
    private LocalDateTime birthdayTime;
    @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)
    private LocalDateTime graduationTime;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;三jackson序列化和反序列化定制&quot;&gt;三、Jackson序列化和反序列化定制&lt;/h3&gt;
&lt;p&gt;因为&lt;code&gt;SpringMVC&lt;/code&gt;默认使用&lt;code&gt;Jackson&lt;/code&gt;处理&lt;code&gt;@RequestBody&lt;/code&gt;的参数转换，因此可以通过定制序列化器和反序列化器来实现日期类型的转换，这样我们就可以使用&lt;code&gt;application/json&lt;/code&gt;的形式提交请求参数。这里的例子是转换请求Json参数中的字符串为&lt;code&gt;LocalDateTime&lt;/code&gt;类型，属于Json反序列化，因此需要定制反序列化器：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostMapping(value = &quot;/date3&quot;)
public String date3(@RequestBody UserDto3 userDto3) {
    log.info(userDto3.toString());
    return &quot;success&quot;;
}

@Data
public class UserDto3 {

    private String userId;
    @JsonDeserialize(using = CustomLocalDateTimeDeserializer.class)
    private LocalDateTime birthdayTime;
    @JsonDeserialize(using = CustomLocalDateTimeDeserializer.class)
    private LocalDateTime graduationTime;
}

public class CustomLocalDateTimeDeserializer extends LocalDateTimeDeserializer {

    public CustomLocalDateTimeDeserializer() {
        super(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;四最佳实践&quot;&gt;四、最佳实践&lt;/h3&gt;
&lt;p&gt;前面三种方式都存在硬编码等问题，其实最佳实践是直接修改&lt;code&gt;MappingJackson2HttpMessageConverter&lt;/code&gt;中的&lt;code&gt;ObjectMapper&lt;/code&gt;对于日期类型处理默认的序列化器和反序列化器，这样就能全局生效，不需要再使用其他注解或者定制序列化方案(当然，有些时候需要特殊处理定制)，或者说，在需要特殊处理的场景才使用其他注解或者定制序列化方案。使用钩子接口&lt;code&gt;Jackson2ObjectMapperBuilderCustomizer&lt;/code&gt;可以实现对容器中的&lt;code&gt;ObjectMapper&lt;/code&gt;单例中的属性定制：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer(){
    return customizer-&amp;gt;{
        customizer.serializerByType(LocalDateTime.class,new LocalDateTimeSerializer(
                DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));
        customizer.deserializerByType(LocalDateTime.class,new LocalDateTimeDeserializer(
                DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;)));
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就能定制化&lt;code&gt;MappingJackson2HttpMessageConverter&lt;/code&gt;中持有的&lt;code&gt;ObjectMapper&lt;/code&gt;，上面的&lt;code&gt;LocalDateTime&lt;/code&gt;序列化和反序列化器对全局生效。&lt;/p&gt;
&lt;h2 id=&quot;请求url匹配&quot;&gt;请求URL匹配&lt;/h2&gt;
&lt;p&gt;前面基本介绍完了主流的请求参数处理，其实&lt;code&gt;SpringMVC&lt;/code&gt;中还会按照&lt;code&gt;URL&lt;/code&gt;的模式进行匹配，使用的是&lt;code&gt;Ant&lt;/code&gt;路径风格，处理工具类为&lt;code&gt;org.springframework.util.AntPathMatcher&lt;/code&gt;，从此类的注释来看，匹配规则主要包括下面四点&lt;br/&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;?&lt;/code&gt;匹配1个字符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt;匹配0个或者多个&lt;strong&gt;字符&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;**&lt;/code&gt;匹配路径中0个或者多个&lt;strong&gt;目录&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;正则支持，如&lt;code&gt;{spring:[a-z]+}&lt;/code&gt;将正则表达式[a-z]+匹配到的值，赋值给名为&lt;strong&gt;spring&lt;/strong&gt;的路径变量。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举些例子：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;'?'形式的URL&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern?&quot;)
public String pattern() {
    return &quot;success&quot;;
}

/pattern  404 Not Found
/patternd  200 OK
/patterndd  404 Not Found
/pattern/  404 Not Found
/patternd/s  404 Not Found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;'*'形式的URL&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern*&quot;)
public String pattern() {
    return &quot;success&quot;;
}

/pattern  200 OK
/pattern/  200 OK
/patternd  200 OK
/pattern/a  404 Not Found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;'**'形式的URL&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern/**/p&quot;)
public String pattern() {
    return &quot;success&quot;;
}

/pattern/p  200 OK
/pattern/x/p  200 OK
/pattern/x/y/p  200 OK&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;{spring:[a-z]+}形式的URL&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern/{key:[a-c]+}&quot;)
public String pattern(@PathVariable(name = &quot;key&quot;) String key) {
    return &quot;success&quot;;
}

/pattern/a  200 OK
/pattern/ab  200 OK
/pattern/abc  200 OK
/pattern  404 Not Found
/pattern/abcd  404 Not Found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的四种URL模式可以组合使用，千变万化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;URL&lt;/code&gt;匹配还遵循&lt;strong&gt;精确匹配原则&lt;/strong&gt;，也就是存在两个模式对同一个&lt;code&gt;URL&lt;/code&gt;都能够匹配成功，则&lt;strong&gt;选取最精确的&lt;code&gt;URL&lt;/code&gt;匹配&lt;/strong&gt;，进入对应的控制器方法，举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(value = &quot;/pattern/**/p&quot;)
public String pattern1() {
    return &quot;success&quot;;
}

@GetMapping(value = &quot;/pattern/p&quot;)
public String pattern2() {
    return &quot;success&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面两个控制器，如果请求&lt;code&gt;URL&lt;/code&gt;为&lt;code&gt;/pattern/p&lt;/code&gt;，最终进入的方法为&lt;code&gt;pattern2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，&lt;code&gt;org.springframework.util.AntPathMatcher&lt;/code&gt;作为一个工具类，可以单独使用，不仅仅可以用于匹配&lt;code&gt;URL&lt;/code&gt;，也可以用于匹配系统文件路径，不过需要使用其带参数构造改变内部的&lt;code&gt;pathSeparator&lt;/code&gt;变量，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;AntPathMatcher antPathMatcher = new AntPathMatcher(File.separator);&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;笔者在前一段时间曾经花大量时间梳理和分析过&lt;code&gt;Spring&lt;/code&gt;、&lt;code&gt;SpringMVC&lt;/code&gt;的源码，但是后面一段很长的时间需要进行业务开发，对架构方面的东西有点生疏了，毕竟东西不用就会生疏，这个是常理。这篇文章基于一些&lt;code&gt;SpringMVC&lt;/code&gt;的源码经验总结了请求参数的处理相关的一些知识，希望帮到自己和大家。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring-boot-web-starter:2.0.3.RELEASE源码。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;原文链接&quot;&gt;原文链接&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Github Page：http://throwable.club/2019/12/04/spring-mvc-param-handle-summary-1&lt;/li&gt;
&lt;li&gt;Coding Page：http://throwable.coding.me/2019/12/04/spring-mvc-param-handle-summary-1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（本文完 c-7-d e-a-20180512 旧文重发）&lt;/p&gt;
</description>
<pubDate>Tue, 03 Dec 2019 17:27:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 在日常使用 进行开发的时候，有可能遇到前端各种类型的请求参数，这里做一次相对全面的总结。 中处理控制器参数的接口是 ，此接口有众多子类，分别处理不同(注解类型)的参数，下面只列举几个子类： ：解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/11980555.html</dc:identifier>
</item>
<item>
<title>预分配——fallocate的前世今生 - OnlyTime_唯有时光</title>
<link>http://www.cnblogs.com/Dreaming-in-Gottingen/p/11980542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dreaming-in-Gottingen/p/11980542.html</guid>
<description>&lt;p&gt;       最近比较懒，还是加班写点东西吧，不然过段时间又把这些整理的东西弄丢了。&lt;/p&gt;
&lt;p&gt;       写什么呢？写一些跟工作相关的吧！因为笔者从事多媒体录像相关的开发工作，因此常常涉及到优化写卡策略、提升写卡性能相关的方面的事情。此话怎讲呢？如行车记录仪类的录像产品，录像可能持续多日，越往后写卡速度会越来越慢，直观感受是取出视频文件进行回放时，时间约往后的视频文件卡顿越来越严重。&lt;/p&gt;
&lt;p&gt;　　怎样解决呢？一种方案从硬件解决，换一张好卡！但是这不能一劳永逸解决问题，因为录着录着写卡速度又掉下来了。另外一种方案从软件层面解决，就是卡速变慢了后，将卡格式化，但是这种方案对于用户来讲不太友好（有些用户可能不知道这个功能，或者文件删除前备份不方便）。还有一种方案，也是从软件层面解决问题，就是优化写卡策略。优化写卡策略，有一些可行的方案，例如文件预分配、待写数据进行缓冲写、编码与封装解耦，直写（DirectIO）。下面内容介绍预分配的内容。&lt;/p&gt;
&lt;h2&gt;1． fallocate介绍&lt;/h2&gt;
&lt;p&gt;　　linux man手册说明：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1770222/201912/1770222-20191204001209637-463325718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　fallocate即预分配，英文为preallocate。什么意思呢？还往文件中没写数据，但是已经给文件分配了足额的物理空间来存储数据。创建了文件，再调用这个接口预分配了一定量的空间后，后续就可以往这个文件中写数据了。&lt;/p&gt;
&lt;p&gt;　　另外一点需要注意，这个接口需要文件系统的支持。常用TF卡录像，而卡的文件系统类型一般为fat32，就需要fat32文件系统相关的实现才能使用该功能。&lt;/p&gt;
&lt;p&gt;　　再有，这是一个不可移植的linux专用系统调用，用于确保文件空间被提前分配，成功执行后，可以确保写卡速度较快，也能保证不会因为磁盘空间不足而出现写失败。&lt;/p&gt;
&lt;h2&gt;2 .   接口声明&lt;/h2&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;函数原型&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;444&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;int fallocate(int fd, int mode, off_t offset, off_t len);&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;fd&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;444&quot;&gt;
&lt;p&gt;文件句柄&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;mode&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;444&quot;&gt;
&lt;p&gt;创建模式&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;offset&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;444&quot;&gt;
&lt;p&gt;偏移&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;100&quot;&gt;
&lt;p&gt;len&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;444&quot;&gt;
&lt;p&gt;文件大小&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　其中，在创建了文件后和写数据前，需要调用该接口进行预分配，第二个参数mode一般设置为1，第三个参数设置为0，第四个参数填上期望预分配值。&lt;/p&gt;
&lt;h2&gt;3． 应用场景及目标&lt;/h2&gt;
&lt;p&gt;　　应用场景：持续写卡场景，例如行车记录仪、运动相机。&lt;/p&gt;
&lt;p&gt;　　目标：减少磁盘碎片化，提高写卡速度。&lt;/p&gt;
&lt;p&gt;　　其他说明：录像设备的瓶颈常常是写卡，因为要随时将视频文件记录下来。并且，对持续写卡速度要求较高，因为录像设备工作周期可能是以day为单位，不仅要求录像刚启动时写卡正常，而且要求工作了几天写卡速度也不能掉太多。至于每秒钟写入的数据量，视编码器输出码率和几路录像而定，对于单路1080p录制，视频码率设置为10mbps，那么卡速至少要保证2MB/s，这里面还不包括写log以及录像中拍照所用的。&lt;/p&gt;
&lt;p&gt;　　虽然目前时间节点上(2019年末)，市面上卡都是C10（10MB/s）及其以上，但是如果写策略不合理或卡中太多零碎文件，写速度可能很低。很常见的一个例子，拷贝一个视频文件到T卡的速度，要远远大于拷贝同样大小的源文件包。另一个例子是，一个刚格式化的T卡与一个内部已经存在了很多文件的T卡（卡品牌、容量、速度等参数都一样），拷贝同样大小的文件，刚格式化的那张卡速度更快。&lt;/p&gt;
&lt;h2&gt;4． 实现原理&lt;/h2&gt;
&lt;p&gt;　　TF卡(TransCard)和SSD(SolidStateDisk)作为常见的存储设备，内部组成非常类似，都主要由controler和nand flash组成。对于任何存储设备，我们都最关心三个参数：容量、读/写速度、寿命。&lt;/p&gt;
&lt;p&gt;　　“容量”这个参数勿用介绍，“读速度”也不介绍，下面主要说下“寿命”和“写速度”这两个参数。介绍这两个参数后，再来介绍预分配。&lt;/p&gt;
&lt;h3&gt;4.1  寿命相关：&lt;/h3&gt;
&lt;p&gt;　　寿命主要由存储介质决定，即nand flash这种介质的可擦写次数，nand flash介质类型的发展经历了slc、mlc、tlc、qlc(目前市面上还较少)几个阶段，单位面积的容量也越来越大，因为介质类型反映了存储密度。小小的TF卡，就目前2019年末的这个时间节点上，市面上已经出现了512GB容量的TF卡，存储多个图书馆书籍的文字信息应该毫无压力！但是，凡事有利有弊，随着容量的提升，TF内部的最小存储单元的可擦写次数也越来越少。&lt;/p&gt;
&lt;p&gt;　　SLC(SingleLevelCell)出现最早，可擦写次数10多万次；后来出现的MLC(MultiLevelCell)可擦写次数3000-10000次左右，目前主流的TLC的可擦写次数在500-1000次左右。在某东上随便查看了lexar的某款500GB 容量的SSD，其参数如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1770222/201912/1770222-20191204003948630-299921615.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从中看到闪存类型为TLC，还有TBW=250T这个参数，这个是什么以及怎么得来的呢？&lt;/p&gt;
&lt;p&gt;　　TBW，即TeraBytesWritten，以TB为单位的写入的数据量。这个值这样算：总容量*可写次数，即500GB*500 = 250TB。其中的500代表平均可写次数为500，是根据闪存类型TLC来估算的。一般企业级的用的sdd，价格较民用的高不少，例如编译/数据库服务器，相同容量的TBW值通常是以PBW(=1024TBW)为单位的，不太追求读写速度，但非常看重寿命和可靠性，毕竟数据是无价的。&lt;/p&gt;
&lt;h3&gt;4.2  速度相关：&lt;/h3&gt;
&lt;p&gt;　　写速度是个比较玄乎的东西，由许多因素综合导致，例如，闪存类型、主控算法(固件磨损平衡算法)、文件系统写策略、卡的碎片化程度、卡的文件系统类型和block大小、内部是否带Cache以及其大小，等等诸多因素。&lt;/p&gt;
&lt;p&gt;　　但是，针对确定下来的一张卡，我们需要找到一些方法，来提高写卡速度。其中一种方法就是预分配——fallocate。&lt;/p&gt;
&lt;p&gt;　　接下来先介绍文件存储相关的内容后，再来介绍这个预分配接口的作用。&lt;/p&gt;
&lt;p&gt;　　对于fat32的文件系统，存储设备中的某文件，其内容主要包括两部分：一部分是属性信息metadata（创建/修改时间、文件名称、文件大小等），另一部分是真正的数据内容。常用的fdatasync操作只会强制将真正的数据内容刷新到存储设备中，而fsync会将两部分内容都刷新到设备中。对于真正的数据内容那部分，有一个链表来管理各个块内容所在的SectorId，即以sector链表的形式来完整表述数据内容。因此，某文件的存储物理地址可能是某连续sector区所在的一整片区域，也可能分布于多个不连续的物理区域。&lt;/p&gt;
&lt;p&gt;　　存储设备的碎片化与内存碎片化非常类似，即某文件希望尽可能利用连续的物理存储空间来存储数据，但是由于卡已处于高度碎片化状态，当真正写入完这个文件时，这个文件在物理空间上是“支离破碎”的。即使是一个刚刚格式化的卡，当两个线程同时分别写两个不同文件时，在物理空间上（内部连续的物理block或sector），这两个文件可能处于交织状态（交错），英文为interleave。做过音频开发的同事也可以回想一下alsa-lib在打开设备进行参数配置时，针对双声道pcm数据采集，有interleave和non-interleave的配置，这个选择决定了左右声道pcm数据在一个period内如何排列，类似对比，卡中存储的多个文件，对于物理block就是这个意思。&lt;/p&gt;
&lt;p&gt;　　设想一种写文件场景，使用正常fopen-fwrite-fclose的操作流程，只写一路，当每次将kernel cache中的数据刷到卡中前，需要现场去找（类似于写磁盘时的寻道）哪个物理sector是available的，当发现某个block中的某个sector是可用的，但是其他sector是其他文件占用的，那么接下来的策略就是copy-modify-write，即出现了“写放大”（WriteAmplification）。&lt;/p&gt;
&lt;p&gt;　　为什么出现这个状况，需要了解闪存的基本组成：页page(也称sector，大小4KB) -&amp;gt; 块block(通常64或128个page组成一个block) -&amp;gt; 面plane(多个block组成) –&amp;gt; die(plane就是一个die) -&amp;gt; 闪存片(多个die组成) –&amp;gt; SSD或TF(多颗闪存片组成)。&lt;/p&gt;
&lt;p&gt;　　下面描述下写放大过程：先把整个block中的数据完全拷贝到ddr，再将某个sector中的数据修改为期望写入的数据，擦掉ssd中这个block的内容，然后再整体将ddr中的已修改好的数据写入到ssd中这个block位置。为什么要这样做？因为写入是按block为最基本单位进行的。所以写入一笔数据，涉及了多次基本操作，不仅减慢了写速度，而且减少了寿命。然而，当进行了预分配后，提前为某文件划分了“势力范围”，标定某些位置已经被占用，可以减少后续的写放大和寻找可用空间的过程。&lt;/p&gt;
&lt;h3&gt;4.3  预分配原理：&lt;/h3&gt;
&lt;p&gt;　　介绍了文件存储结构的相关内容后，对于预分配的功能我们就有了大致的猜测！fallocate这个接口，其要实现的目的，就是在数据内容还未写入到设备前，提前为文件分配好若干大小的空间，并且使这个空间尽可能是物理连续的，这样可以减少后续写放大的出现频率，以及不需在写入过程中寻找可用空间，更不会出现写数据时磁盘空间不足的问题！&lt;/p&gt;
&lt;h2&gt;5． 其他问题&lt;/h2&gt;
&lt;p&gt;　　使用预分配一个最大的问题是——磁盘空间利用率不高！这个如何说起？文件刚创建还未写入数据，我们就抢先为文件设置了文件的大小并占用了固定大小的物理空间，但通常可能未写入那么大size的数据量就fclose了这个文件，那么这个文件内未写入的空间就不能被其他文件利用了。一个文件预分配了100MB，即使只写入1MB就关闭，那么就有99MB的空间浪费。但是，使用预分配对于行车记录仪类产品是个较优的选择，因为文件切换是定时切换的，如果编码器输出码率是相对稳定的，就可以预估最终文件大小，预分配的大小再留些余量就可以了。&lt;/p&gt;
</description>
<pubDate>Tue, 03 Dec 2019 17:03:00 +0000</pubDate>
<dc:creator>OnlyTime_唯有时光</dc:creator>
<og:description>最近比较懒，还是加班写点东西吧，不然过段时间又把这些整理的东西弄丢了。 写什么呢？写一些跟工作相关的吧！因为笔者从事多媒体录像相关的开发工作，因此常常涉及到优化写卡策略、提升写卡性能相关的方面的事情。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dreaming-in-Gottingen/p/11980542.html</dc:identifier>
</item>
<item>
<title>Wordpress未授权查看私密内容漏洞 分析（CVE-2019-17671） - ka1n4t</title>
<link>http://www.cnblogs.com/litlife/p/11980530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/litlife/p/11980530.html</guid>
<description>&lt;h3 id=&quot;x00-前言&quot;&gt;0x00 前言&lt;/h3&gt;
&lt;p&gt;没有&lt;/p&gt;
&lt;h3 id=&quot;x01-分析&quot;&gt;0x01 分析&lt;/h3&gt;
&lt;p&gt;这个漏洞被描述为“匿名用户可访问私密page”，由此推断是权限判断出了问题。如果想搞懂哪里出问题，必然要先知道wp获取page(页面)/post(文章)的原理，摸清其中权限判断的逻辑，才能知道逻辑哪里会有问题。&lt;/p&gt;
&lt;p&gt;这里我们直接从wp的核心处理流程main函数开始看，/wp-includes/class-wp.php:main()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function main( $query_args = '' ) {
    $this-&amp;gt;init();//获取当前用户信息
    $this-&amp;gt;parse_request( $query_args );//解析路由，匹配路由模式，取出匹配的路由中的用户输入参数（比如year,month等）赋值给$this-&amp;gt;query_vars。（并将部分用户参数绑定到$this-&amp;gt;query_vars中）。然后进行一些过滤操作。
    $this-&amp;gt;send_headers();//设置HTTP响应头，比如Content-Type等
    $this-&amp;gt;query_posts();//根据$this-&amp;gt;query_vars等参数，获取posts/pages
    $this-&amp;gt;handle_404();
    $this-&amp;gt;register_globals();

    do_action_ref_array( 'wp', array( &amp;amp;$this ) );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;$this-&amp;gt;init()底层直接调用wp_get_current_user()获取全局变量$current_user，这是一个WP_User类，里面存储当前用户的元信息，未登录时$current_user-&amp;gt;ID===0。&lt;/p&gt;
&lt;p&gt;然后进入$this-&amp;gt;parse_request，这个函数主要用于处理路由，初始化$this-&amp;gt;query_vars。主要分为两部分来看，第一部分是处理路由，匹配rewrite路由模式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function parse_request( $extra_query_vars = '' ) {
    global $wp_rewrite;
    
    ...

    // Fetch the rewrite rules.
    $rewrite = $wp_rewrite-&amp;gt;wp_rewrite_rules();//加载所有路由重写规则，用于与当前请求路径进行匹配

    if ( ! empty( $rewrite ) ) {
        ...
        if ( empty( $request_match ) ) {
            ...
        } else {
            foreach ( (array) $rewrite as $match =&amp;gt; $query ) {//匹配路由规则
                ...
                if ( preg_match( &quot;#^$match#&quot;, $request_match, $matches ) || preg_match( &quot;#^$match#&quot;, urldecode( $request_match ), $matches ) ) {
                    ...
                    // Got a match.
                    $this-&amp;gt;matched_rule = $match;//找到匹配成功的rewrite规则，立即break
                    break;
                }
            }
        }
        if ( isset( $this-&amp;gt;matched_rule ) ) {
            ...
            $query = addslashes( WP_MatchesMapRegex::apply( $query, $matches ) );//规则化用户请求url，以与路由进行完美对应

            $this-&amp;gt;matched_query = $query;

            // Parse the query.
            parse_str( $query, $perma_query_vars );

            ...
        }

        ...
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二部分，解析用户参数，配置$this-&amp;gt;query_vars的值&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class WP{
    ...
    
    public $public_query_vars = array( 'm', 'p', 'posts', 'w', 'cat', 
'withcomments', 'withoutcomments', 's', 'search', 'exact', 'sentence', 
'calendar', 'page', 'paged', 'more', 'tb', 'pb', 'author', 'order', 
'orderby', 'year', 'monthnum', 'day', 'hour', 'minute', 'second', 
'name', 'category_name', 'tag', 'feed', 'author_name', 'static', 
'pagename', 'page_id', 'error', 'attachment', 'attachment_id', 
'subpost', 'subpost_id', 'preview', 'robots', 'taxonomy', 'term', 
'cpage', 'post_type', 'embed' );

    ...
public function parse_request( $extra_query_vars = '' ) {
    ...
    ...
    
    &amp;lt;接上第一部分&amp;gt;
    
    foreach ( $this-&amp;gt;public_query_vars as $wpvar ) {
        if ( isset( $this-&amp;gt;extra_query_vars[ $wpvar ] ) ) {
            $this-&amp;gt;query_vars[ $wpvar ] = $this-&amp;gt;extra_query_vars[ $wpvar ];
        } elseif ( isset( $_GET[ $wpvar ] ) &amp;amp;&amp;amp; isset( $_POST[ $wpvar ] ) &amp;amp;&amp;amp; $_GET[ $wpvar ] !== $_POST[ $wpvar ] ) {
            wp_die( __( 'A variable mismatch has been detected.' ), __( 'Sorry, you are not allowed to view this item.' ), 400 );
        } elseif ( isset( $_POST[ $wpvar ] ) ) {
            $this-&amp;gt;query_vars[ $wpvar ] = $_POST[ $wpvar ];
        } elseif ( isset( $_GET[ $wpvar ] ) ) {
            $this-&amp;gt;query_vars[ $wpvar ] = $_GET[ $wpvar ];
        } elseif ( isset( $perma_query_vars[ $wpvar ] ) ) {
            $this-&amp;gt;query_vars[ $wpvar ] = $perma_query_vars[ $wpvar ];
        }
        ...
    }
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里遍历$this-&amp;gt;public_query_vars成员变量，如果用户传来了与键名相同的参数，则直接赋值给$this-&amp;gt;query_vars。这里也就是说，我们只能控制$this-&amp;gt;query_vars中在$this-&amp;gt;public_query_vars中的键名的值，也就是只能控制这些键：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array( 'm', 'p', 'posts', 'w', 'cat', 
'withcomments', 'withoutcomments', 's', 'search', 'exact', 'sentence', 
'calendar', 'page', 'paged', 'more', 'tb', 'pb', 'author', 'order', 
'orderby', 'year', 'monthnum', 'day', 'hour', 'minute', 'second', 
'name', 'category_name', 'tag', 'feed', 'author_name', 'static', 
'pagename', 'page_id', 'error', 'attachment', 'attachment_id', 
'subpost', 'subpost_id', 'preview', 'robots', 'taxonomy', 'term', 
'cpage', 'post_type', 'embed' );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回到最开始的main()函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public function main( $query_args = '' ) {
    $this-&amp;gt;init();//获取当前用户信息
    $this-&amp;gt;parse_request( $query_args );//解析路由，匹配路由模式，取出匹配的路由中的用户输入参数（比如year,month等）赋值给$this-&amp;gt;query_vars。（并将部分用户参数绑定到$this-&amp;gt;query_vars中）。然后进行一些过滤操作。
    $this-&amp;gt;send_headers();//设置HTTP响应头，比如Content-Type等
    $this-&amp;gt;query_posts();//根据$this-&amp;gt;query_vars等参数，获取posts/pages
    $this-&amp;gt;handle_404();
    $this-&amp;gt;register_globals();

    do_action_ref_array( 'wp', array( &amp;amp;$this ) );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来的$this-&amp;gt;send_headers()用于设置一些HTTP响应头，这里不再跟进，直接跟进到下面一行的$this-&amp;gt;query_posts()，这里就是用于显示一些post/page的地方，也就是本次分析的重点。&lt;/p&gt;
&lt;p&gt;query_posts()先经过一些设置成员变量的初始化之后进入到/wp-includes/class-wp-query.php:get_posts()。由于这里代码太多，以及本文是针对“未授权查看私密page”漏洞的，所以这里主要盘一下显示post/page以及鉴权的逻辑，其他的细节不再跟入。&lt;/p&gt;
&lt;p&gt;这里先是构造SQL语句查询post/page，然后将查询出的结果赋值给$this-&amp;gt;posts。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$split_the_query = apply_filters( 'split_the_query', $split_the_query, $this );

if ( $split_the_query ) {
    $this-&amp;gt;request = &quot;SELECT $found_rows $distinct {$wpdb-&amp;gt;posts}.ID FROM {$wpdb-&amp;gt;posts} $join WHERE 1=1 $where $groupby $orderby $limits&quot;;
    ...
    $ids = $wpdb-&amp;gt;get_col( $this-&amp;gt;request );//查询数据库，获取post/page的id
    if ( $ids ) {
        $this-&amp;gt;posts = $ids;
        $this-&amp;gt;set_found_posts( $q, $limits );//通过id获取page/post
        _prime_post_caches( $ids, $q['update_post_term_cache'], $q['update_post_meta_cache'] );
    } else {
        $this-&amp;gt;posts = array();
    }
} else {
    $this-&amp;gt;posts = $wpdb-&amp;gt;get_results( $this-&amp;gt;request );//获取post的内容
    $this-&amp;gt;set_found_posts( $q, $limits );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里有两种方法获取，由$split_the_query决定使用哪种方法。目前来看两种方法没有什么区别因此先不跟进split_the_query。&lt;/p&gt;
&lt;p&gt;第一次我未登录，并请求url&lt;code&gt;wordpress-5.2.3/index.php&lt;/code&gt;，我们来看一下这里构造成的SQL语句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SQL_CALC_FOUND_ROWS  wp_posts.ID FROM wp_posts  WHERE 1=1  AND wp_posts.post_type = 'post' AND (wp_posts.post_status = 'publish')  ORDER BY wp_posts.post_date DESC LIMIT 0, 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里通过&lt;code&gt;wp_posts.post_status = 'publish'&lt;/code&gt;限制我们只能看到public状态的post_type='post'的记录，也就是post。&lt;/p&gt;
&lt;p&gt;第二次登陆为管理员，访问同样的url，SQL语句变成如下这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT SQL_CALC_FOUND_ROWS  wp_posts.ID FROM wp_posts  WHERE 1=1  AND wp_posts.post_type = 'post' AND (wp_posts.post_status = 'publish' OR wp_posts.post_status = 'private')  ORDER BY wp_posts.post_date DESC LIMIT 0, 10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了多了一个&lt;code&gt;OR wp_posts.post_status = 'private'&lt;/code&gt;其他部分都一模一样，也就是说管理员账号可以看到状态为private的post（废话），因此这里猜测，构造&lt;code&gt;wp_posts.post_status=?&lt;/code&gt;的附近可能做了鉴权操作。&lt;/p&gt;
&lt;p&gt;往上找，找到了构建where post_status语句的地方&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$q_status = array();
if ( ! empty( $q['post_status'] ) ) {//由于本路由中无法设置post_status的值，因此第一个if语句块不看
    $statuswheres = array();
    $q_status     = $q['post_status'];
    
    ...//根据$q_status构造where子句
    
} elseif ( ! $this-&amp;gt;is_singular ) {
    $where .= &quot; AND ({$wpdb-&amp;gt;posts}.post_status = 'publish'&quot;;

    ...

    if ( $this-&amp;gt;is_admin ) {
        // Add protected states that should show in the admin all list.
        $admin_all_states = get_post_stati(
            array(
                'protected'              =&amp;gt; true,
                'show_in_admin_all_list' =&amp;gt; true,
            )
        );
        foreach ( (array) $admin_all_states as $state ) {
            $where .= &quot; OR {$wpdb-&amp;gt;posts}.post_status = '$state'&quot;;
        }
    }

    if ( is_user_logged_in() ) {
        // Add private states that are limited to viewing by the author of a post or someone who has caps to read private states.
        $private_states = get_post_stati( array( 'private' =&amp;gt; true ) );
        foreach ( (array) $private_states as $state ) {
            $where .= current_user_can( $read_private_cap ) ? &quot; OR {$wpdb-&amp;gt;posts}.post_status = '$state'&quot; : &quot; OR {$wpdb-&amp;gt;posts}.post_author = $user_id AND {$wpdb-&amp;gt;posts}.post_status = '$state'&quot;;
        }
    }

    $where .= ')';
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们只需要看elseif()语句块，里面显示拼接一个public，然后根据is_admin和is_user_logged_in()来添加一些其他的post_status比如private。由于我们的目标是‘未登录用户访问private内容’，这里暂且不考虑是否能绕过is_admin或者is_user_logged_in()底层的缺陷（当然也不太可能），仅从逻辑上看，如果我们不进入这个elseif语句块，不构建这个where岂不是能读到所有的page/post了？&lt;/p&gt;
&lt;p&gt;这个elseif的条件是(!$this-&amp;gt;is_singular)，我们的目标是让$this-&amp;gt;is_singular为正逻辑即可（比如true）。回溯这个变量，找到一处&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$this-&amp;gt;is_singular = $this-&amp;gt;is_single || $this-&amp;gt;is_page || $this-&amp;gt;is_attachment;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只要让这三个变量的任何一个值为true即可，向上找，比较明显的是这处：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if ( ( '' != $qv['attachment'] ) || ! empty( $qv['attachment_id'] ) ) {
    $this-&amp;gt;is_single     = true;
    $this-&amp;gt;is_attachment = true;
} elseif ( '' != $qv['name'] ) {//wp_posts.post_name
    $this-&amp;gt;is_single = true;
} elseif ( $qv['p'] ) {//wp_posts.ID
    $this-&amp;gt;is_single = true;
} elseif ( ( '' !== $qv['hour'] ) &amp;amp;&amp;amp; ( '' !== $qv['minute'] ) &amp;amp;&amp;amp; ( '' !== $qv['second'] ) &amp;amp;&amp;amp; ( '' != $qv['year'] ) &amp;amp;&amp;amp; ( '' != $qv['monthnum'] ) &amp;amp;&amp;amp; ( '' != $qv['day'] ) ) {
    $this-&amp;gt;is_single = true;
} elseif ( '' != $qv['static'] || '' != $qv['pagename'] || ! empty( $qv['page_id'] ) ) {
    $this-&amp;gt;is_page   = true;
    $this-&amp;gt;is_single = false;
} else {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见我们只要设置$qv的几个键就好了，比如：attachment、name、p、static等。通过回溯$qv，发现&lt;code&gt;$qv=&amp;amp;$this-&amp;gt;query_vars;&lt;/code&gt;。query_vars中我们能控制的键只有上文中的$this-&amp;gt;public_query_vars里的那些也就是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;array( 'm', 'p', 'posts', 'w', 'cat', 
'withcomments', 'withoutcomments', 's', 'search', 'exact', 'sentence', 
'calendar', 'page', 'paged', 'more', 'tb', 'pb', 'author', 'order', 
'orderby', 'year', 'monthnum', 'day', 'hour', 'minute', 'second', 
'name', 'category_name', 'tag', 'feed', 'author_name', 'static', 
'pagename', 'page_id', 'error', 'attachment', 'attachment_id', 
'subpost', 'subpost_id', 'preview', 'robots', 'taxonomy', 'term', 
'cpage', 'post_type', 'embed' );&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到：attachment、name、p、static这几个键我们都能控制，只要在url参数中直接传就好了。可是通过对比可以很明显的发现，除了最后一个elseif语句块里的is_single为false，其余都为true，也就是只取一条post/page/attachment，通过参数名也可以看出来，如果传递p参数，则只在数据库中找wp_posts.ID匹配的数据，传递name参数则只匹配wp_posts.post_name相同的数据。因此经过对比，这里只有传入static=xxx时，既能绕过后面的where private的限制，也能取出所有数据。&lt;/p&gt;
&lt;p&gt;下面开始限制请求的数据类型，page/post/attachment。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if ( 'any' == $post_type ) {
    $in_search_post_types = get_post_types( array( 'exclude_from_search' =&amp;gt; false ) );
    if ( empty( $in_search_post_types ) ) {
        $where .= ' AND 1=0 ';
    } else {
        $where .= &quot; AND {$wpdb-&amp;gt;posts}.post_type IN ('&quot; . join( &quot;', '&quot;, array_map( 'esc_sql', $in_search_post_types ) ) . &quot;')&quot;;
    }
} elseif ( ! empty( $post_type ) &amp;amp;&amp;amp; is_array( $post_type ) ) {
    $where .= &quot; AND {$wpdb-&amp;gt;posts}.post_type IN ('&quot; . join( &quot;', '&quot;, esc_sql( $post_type ) ) . &quot;')&quot;;
} elseif ( ! empty( $post_type ) ) {
    $where .= $wpdb-&amp;gt;prepare( &quot; AND {$wpdb-&amp;gt;posts}.post_type = %s&quot;, $post_type );
    $post_type_object = get_post_type_object( $post_type );
} elseif ( $this-&amp;gt;is_attachment ) {
    $where .= &quot; AND {$wpdb-&amp;gt;posts}.post_type = 'attachment'&quot;;
    $post_type_object = get_post_type_object( 'attachment' );
} elseif ( $this-&amp;gt;is_page ) {
        $where .= &quot; AND {$wpdb-&amp;gt;posts}.post_type = 'page'&quot;;
    $post_type_object = get_post_type_object( 'page' );
} else {
    $where .= &quot; AND {$wpdb-&amp;gt;posts}.post_type = 'post'&quot;;
    $post_type_object = get_post_type_object( 'post' );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到post_type为空时，如果is_page为true则设置post_type为page，因此只能获取page类型的数据。&lt;/p&gt;
&lt;p&gt;通过设置static=xxx，调试之后可以看到最终的SQL语句如下，已经没有了post_status是public还是private的限制：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT   wp_posts.* FROM wp_posts  WHERE 1=1  AND wp_posts.post_type = 'page'  ORDER BY wp_posts.post_date DESC &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201912/1077935-20191204004907362-763237650.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1077935/201912/1077935-20191204004914967-131108044.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时所有的page已经全部存储到$this-&amp;gt;posts中，下面要看看这些posts是否会渲染出来。以下是相关代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
// Check post status to determine if post should be displayed.
if ( ! empty( $this-&amp;gt;posts ) &amp;amp;&amp;amp; ( $this-&amp;gt;is_single || $this-&amp;gt;is_page ) ) {
    $status = get_post_status( $this-&amp;gt;posts[0] );//获取$this-&amp;gt;posts中的第一个元素的post_status
    ...
    $post_status_obj = get_post_status_object( $status );

    // If the post_status was specifically requested, let it pass through.
    if ( ! $post_status_obj-&amp;gt;public &amp;amp;&amp;amp; ! in_array( $status, $q_status ) ) {//如果post_status_obj的public属性为true或post_status在$q_status中，则不进入此if。由于本文前面已经分析$q_status不可控且为空，因此主要看第一个条件。

        if ( ! is_user_logged_in() ) {
            // User must be logged in to view unpublished posts.
            $this-&amp;gt;posts = array();//无权限查看
        } else {
            if ( $post_status_obj-&amp;gt;protected ) {
                ...更细的鉴权
            } elseif ( $post_status_obj-&amp;gt;private ) {
                if ( ! current_user_can( $read_cap, $this-&amp;gt;posts[0]-&amp;gt;ID ) ) {
                    $this-&amp;gt;posts = array();//无权限查看
                }
            } else {
                $this-&amp;gt;posts = array();//无权限查看
            }
        }
    }

    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于$this-&amp;gt;posts是我们要读的pages，且is_page为true，因此第一个if判断是必进的。接下来就是有意思的地方了，下面获取了$this-&amp;gt;posts中的第一篇文章，如果其是public就可以不进入第二个if语句，从而就直接绕过了“回显鉴权”这一部分。所以我们只要保证$this-&amp;gt;posts的第一篇文章为public状态的即可。通过order by我们可以把最旧的文章放在最上面，也就是正序asc查询，因为一般来说旧的文章权限为public的可能性大一些。&lt;/p&gt;
&lt;p&gt;之前的SQL语句为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT   wp_posts.* FROM wp_posts  WHERE 1=1  AND wp_posts.post_type = 'page'  ORDER BY wp_posts.post_date DESC &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过回溯发现可以通过$this-&amp;gt;query_vars['order']来控制升序还是降序，因此我们只要在url中加上order=asc即可。&lt;/p&gt;
&lt;p&gt;回顾上面的分析整理一下逻辑，传入static=xxx -&amp;gt; is_page===true -&amp;gt; is_singular===true -&amp;gt; 不使用where子句限定private/public/... -&amp;gt; 获取所有page -&amp;gt; 最后显示前鉴权时仅检查第一个page的权限。&lt;/p&gt;
&lt;p&gt;把这个逻辑抽象出来可以知道，在只取得一个page/post时是没问题的，因为最后display之前会进行一次鉴权。我们的主要关注点是获得多条数据，因为这样会绕过最后display之前只验证第一条数据的鉴权操作。保证获得多条数据的同时又要保证$this-&amp;gt;is_single，$this-&amp;gt;is_page，$this-&amp;gt;is_attachment其中一个是true才能绕过where子句的限制。&lt;/p&gt;
&lt;p&gt;逻辑出来了，官方补丁是删除了static变量，是否可以绕过这个补丁？首先回顾一下初始化这几个成员变量的地方：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if ( ( '' != $qv['attachment'] ) || ! empty( $qv['attachment_id'] ) ) {
    $this-&amp;gt;is_single     = true;
    $this-&amp;gt;is_attachment = true;
} elseif ( '' != $qv['name'] ) {//wp_posts.post_name
    $this-&amp;gt;is_single = true;
} elseif ( $qv['p'] ) {//wp_posts.ID
    $this-&amp;gt;is_single = true;
} elseif ( ( '' !== $qv['hour'] ) &amp;amp;&amp;amp; ( '' !== $qv['minute'] ) &amp;amp;&amp;amp; ( '' !== $qv['second'] ) &amp;amp;&amp;amp; ( '' != $qv['year'] ) &amp;amp;&amp;amp; ( '' != $qv['monthnum'] ) &amp;amp;&amp;amp; ( '' != $qv['day'] ) ) {
-$this-&amp;gt;is_single = true;
} elseif ( '' != $qv['static'] || '' != $qv['pagename'] || ! empty( $qv['page_id'] ) ) {
    $this-&amp;gt;is_page   = true;
    $this-&amp;gt;is_single = false;
} else {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把这几个if条件都带入程序中走一遍发现，除了static这个语句块，其之前的所有if条件都将查询的结果限制到了&amp;lt;=1条，从而不会存在逻辑问题，这也是is_single的含义。官方修复的补丁是将这个static参数去掉，变成了&lt;code&gt;elseif(''!=$qv['pagename'] || !empty($qv['page_id']))&lt;/code&gt;，而这个条件也限制了只能取得一页，但是is_single这里是false不知道是什么原因。似乎是安全的？&lt;/p&gt;
&lt;h3 id=&quot;x02-思考&quot;&gt;0x02 思考&lt;/h3&gt;
&lt;p&gt;经过一番思考之后感觉这个补丁并没有从根本上解决问题，如果可以获得多条数据并且没有where子句的限制仍然可以触发漏洞。刚刚说了，那几个if条件都将查询的结果限制到了&amp;lt;=1条，但是这样真的就安全了？如果程序将这些参数拼接到类似于&lt;code&gt;where ... wp_posts.post_name like $qv['name']&lt;/code&gt;还是会出现问题，这里就不展开说了。我大概找了一下，明显的地方没有看到这样的用法，但是还有一些稍微底层的函数没有跟，这里先留了一个坑。&lt;/p&gt;
&lt;h3 id=&quot;x03-总结&quot;&gt;0x03 总结&lt;/h3&gt;
&lt;p&gt;在分析漏洞时一直在尝试逆推作者的挖洞思路，可是由于我之前分析SQL注入、反序列化这类漏洞比较多，对于这种逻辑漏洞的挖掘还是有些陌生的。对于逻辑漏洞，我认为分析时不适合SQL注入、XSS那种通过漏洞点反推的方式，不够‘自然’，而是应该先通过了解出现逻辑错误的功能模块的实现，然后结合官方diff来做会好一些。&lt;/p&gt;
&lt;h3 id=&quot;x04-参考&quot;&gt;0x04 参考&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-17671&quot;&gt;CVE-2019-17671&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://wpvulndb.com/vulnerabilities/9909&quot;&gt;受影响版本&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://xz.aliyun.com/t/6768#toc-0&quot;&gt;Wordpress 5.2.3 未授权页面查看漏洞（CVE-2019-17671）分析&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Dec 2019 16:52:00 +0000</pubDate>
<dc:creator>ka1n4t</dc:creator>
<og:description>[TOC] 0x00 前言 没有 0x01 分析 这个漏洞被描述为“匿名用户可访问私密page”，由此推断是权限判断出了问题。如果想搞懂哪里出问题，必然要先知道wp获取page(页面)/post(文章</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/litlife/p/11980530.html</dc:identifier>
</item>
<item>
<title>Activiti工作流框架学习（一）之通用数据表详细介绍 - 朱季谦</title>
<link>http://www.cnblogs.com/zhujiqian/p/11966455.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhujiqian/p/11966455.html</guid>
<description>&lt;p&gt;&lt;span&gt;文/朱季谦&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Activiti工作流引擎自带了一套数据库表，这里面有一个需要注意的地方：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;低于5.6.4的MySQL版本不支持时间戳或毫秒级的日期。更糟糕的是，某些版本在尝试创建此类列时将引发异常，而其他版本则不会。执行自动创建/升级时，引擎将在执行DDL时更改它。使用DDL文件方法时，既可以使用常规版本也可以使用其中带有&lt;span&gt;mysql55&lt;span&gt;的特殊文件（这适用于低于5.6.4的任何版本）。后一个文件将具有没有毫秒精度的列类型。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;笔者曾经在5.6.0版本做过试验，发现是无法自动生成23张表的，但在5.6.4版本以上便可，因此，最好保证mysql版本在5.6.4以上。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一.数据库表名称说明&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Activiti的数据库表分5大部分，名称以ACT开头，第二部分是表用例的两个字符的标志，该用例与服务API的大致匹配：&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201160140989-1306179669.png&quot; alt=&quot;&quot; width=&quot;704&quot; height=&quot;362&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二.ACT_GE_ *通用数据表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;通用数据表用于存放一些通用的数据，这些表本身不关心特定的流程或者业务，只用于存放这些业务或者流程所使用的资源。通用数据表有两个，分别是ACT_GE_BYTEARRAY与ACT_GE_PROPERTY,它们都是以ACT_GE_*开头的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1 ACT_GE_BYTEARRAY资源表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表ACT_GE_BYTEARRAY资源表用于保存于流程引擎相关的资源，流程文件进行部署时，流程定义的图片以及XML文件等数据，都会转换成byte数组保存到这个表中。该表设计了一个byte字段，用来保存资源的内容，该表包含以下字段：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201164709551-735077018.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;313&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 注：Activiti为了保证整个流程引擎表中所产生的数据主键在整个流程引擎中是唯一的，使用了一个DbIdGenerator类生成主键，该类中保存了下一条数据的ID值和当前ID块最后一个ID值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 ACT_GE_PROPERTY属性表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Activiti将全部的属性抽象为key-value对，每个属性都有名称和值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201165837789-1757944209.png&quot; alt=&quot;&quot; width=&quot;694&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 注：在初始化流程数据库时，会默认加入3条属性数据：next.dbid、schema.history和schema.version。&lt;/p&gt;
&lt;p&gt;next.dbid:属性值为1时，表示Activiti数据库表ID生成时，当前ID块最大值为1（即数据库里还没有任何数据）。前面也提到，流程引擎是使用一个DbIdGenerator类来生成主键的，该类保存了下一条数据的ID值和当前ID块的最后一个ID值，所谓ID块就是Activiti数据产生时ID值时，就会从1开始到101进行取值作为数据ID，那么该ID块的最大值为101。DbIdGenerator在产生数据ID时，会判断当前ID值是否大于101（ID块最大值）。如果大于，则请求重新生成一个ID块，那么此时属性中的next.dbid属性值将会为201。&lt;/p&gt;
&lt;p&gt;schema.history：属性表示数据表结构的更新历史，例如——&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201170619240-1353968867.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; create(5.22.0.0)即表示使用了5.22版本的初始化脚本创建。&lt;/p&gt;
&lt;p&gt;schema.version：表示当前Activiti数据结构的版本。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;三.ACT_RE_ *流程存储表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储表名称以ACT_RE开头，RE是repository单词的前两个字母，流程使用存储表来保存流程定义和部署信息相关的数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1.ACT_RE_DEPLOYMENT部署数据表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在流程引擎中，一次部署可以添加多个资源，即可以有图片与XML之类的资源，这些资源数据会保存到资源表（ACT_GE_BTYEARRAY），剩余部署信息，则保存到部署表中，部署名为ACT_RE_DEPLOYMENT，包含以下三个字段：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201171725379-2108806692.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;185&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;strong&gt;&lt;span&gt;3.2.ACT_RE_PROCDEF流程定义表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Activiti在部署流程文件时（.bpmn或者.bpmn20.xml），其除了会将内容保存到资源表外，还会解析流程文件的内容，形成特定的流程定义数据，写入到流程定义表（ACT_RE_PROCDEF）中，该表包含了以下的字段：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201173040238-1152884681.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;670&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 注：该表的主键与其他数据表不同的是，ACT_RE_PROCDEF表的主键是组合主键，其值为流程定义的KEY_字段值加流程定义的VERSION_字段值再加ID生成器生成的ID值，其中这三个值以冒号为分隔符。例如，KEY_值为baoxiaoProcess，VERSION_值为1，ID生成器生成的ID值为722504，则该主键为baoxiaoProcess:1:722504，如以下截图所示：&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201173304333-26320898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;四.ACT_ID_ *身份数据表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Activiti的整个身份证数据模块，可以独立于流程引擎而存在，身份数据表并没有保存流程相关的数据以及关联，身份表名称使用ACT_ID关联，ID是单词identity的前两个字母。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.1.ACD_ID_USER用户表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;流程引擎用户的信息被保存在ACT_ID_USER表中，该表有以下字段：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201174633242-1564530902.png&quot; alt=&quot;&quot; width=&quot;794&quot; height=&quot;430&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; &lt;strong&gt;&lt;span&gt;4.2.ACD_ID_GROUP用户组表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用ACT_ID_GROUP表来保存用户组的数据，该表有以下几个字段：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201175123416-1451890509.png&quot; alt=&quot;&quot; width=&quot;860&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;&lt;span&gt;4.3.ACD_ID_MEMBERSHIP关系表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关系表用来描述用户表与用户组表的对应关系：&lt;/span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201175513743-23285089.png&quot; alt=&quot;&quot; width=&quot;750&quot; height=&quot;164&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 注：该表的两个字段均做了外键约束，写入该表的数据时，必须要有用户和用户组数据与之关联。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;五.ACT_RU_ *运行时数据表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行时数据表用来保存流程在运行过程中所产生的数据，例如流程实例、执行流和任务等，以ACT_RU开头，RU是单词runtime的前两个字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.1.ACT_RU_EXECUTION流程实例表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 流程启动后，会产生一个流程实例，同时产生相应的执行流，流程实例和执行流数据均被保存在ACT_RU_EXECUTION表中。如果一个流程实例只要一条执行流，那么该表中只产生一条数据，该数据既表示执行流，也表示流程实例。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201181457688-1411278495.png&quot; alt=&quot;&quot; width=&quot;1110&quot; height=&quot;997&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt;5.2.ACT_RU_TASK流程任务表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流程在运行过程中所产生的任务数据保存在ACT_RU_TASK，字段如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201182918589-1386656616.png&quot; alt=&quot;&quot; width=&quot;1114&quot; height=&quot;1134&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;5.3.ACT_RU_VARIABLE流程参数表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流程引擎提供了ACT_RU_VARIABLE表来存放流程中的参数，这类参数包括流程实例参数、执行流参数和任务参数，各参数可以有多种类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201184611378-2012921398.png&quot; alt=&quot;&quot; width=&quot;1094&quot; height=&quot;954&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  &lt;strong&gt;5.4.ACT_RU_IDENTITYLINK流程与身份关系表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户组与用户之间存在的关系，使用ACT_ID_MEMBERSHIP表保存。用户或者用户组与流程数据之间的关系，则使用ACT_RU_IDENTITYLINK表进行保存。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201185549251-65492885.png&quot; alt=&quot;&quot; width=&quot;1099&quot; height=&quot;580&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   &lt;strong&gt;5.5.ACT_RU_JOB工作数据表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在流程执行的过程中，会有一些工作需要定时或者重复执行，这类工作数据被保存到ACT_RU_JOB表中。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191201190740220-1858366245.png&quot; alt=&quot;&quot; width=&quot;1061&quot; height=&quot;1077&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;5.6.ACT_RU_EVENT_SUBSCR事件描述表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果流程到达某类事件节点，Activiti会往ACT_RU_EVENT_SUBSCR表中加入事件描述数据，这些事件描述数据将会决定流程事件的触发。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191202235231833-1615830233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 六.ACT_HI_ *历史数据表&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;历史数据表就像流程引擎的日志表。被操作过的流程元素，将会被记录到李四表中。历史表名称以ACT_HI开头，HI是单词history的前两个字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.1.ACT_HI_PROCINST流程实例表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流程实例的历史数据会被保存到ACT_HI_PROCINST表中，只要流程启动，Activiti就会将流程实例的数据写入ACT_HI_PROCINST表中。除了基本的流程字段外，与运行时数据表不同的是，历史流程实例表还会记录流程的开始活动ID的、活动结束ID等信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191203000112526-485955046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 6.2.ACT_HI_ACTINST历史行为表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;历史行为表会记录每一个流程活动的实例，一个 流程活动将会被记录成一条数据，例如，流程中有开始事件，用户任务，结束事件各一个，当流程结束后，该表就会产生3条历史行为数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191204001752164-1975030294.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 6.3.附件表ACT_HI_ATTACHMENT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用任务服务（TaskService）的API，可以添加附件，这些附件数据将会保存到ACT_HI_ATTACHMENT表中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191204002014865-1939152494.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;strong&gt; 6.4.评论表ACT_HI_COMMENT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以专门存放审批过程中的评论数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1545382/201912/1545382-20191204002234787-1241731442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 03 Dec 2019 16:27:00 +0000</pubDate>
<dc:creator>朱季谦</dc:creator>
<og:description>文/朱季谦 Activiti工作流引擎自带了一套数据库表，这里面有一个需要注意的地方： 低于5.6.4的MySQL版本不支持时间戳或毫秒级的日期。更糟糕的是，某些版本在尝试创建此类列时将引发异常，而其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhujiqian/p/11966455.html</dc:identifier>
</item>
</channel>
</rss>