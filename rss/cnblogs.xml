<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>对象的创建  - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/13500050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/13500050.html</guid>
<description>&lt;p&gt;Java对象创建的流程大概如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查对象所属类是否已经被加载解析；&lt;/li&gt;
&lt;li&gt;为对象分配内存空间；&lt;/li&gt;
&lt;li&gt;将分配给对象的内存初始化为零值；&lt;/li&gt;
&lt;li&gt;执行对象的&amp;lt;init&amp;gt;方法进行初始化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;举个例子如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
public class Test {
    public static void main(String[] args) {
        Test obj = new Test();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法main()对应的Class文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #1                  // class com/test/Test
         3: dup
         4: invokespecial #16                 // Method &quot;&amp;lt;init&amp;gt;&quot;:()V
         7: astore_1
         8: return
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用new指令来创建Test对象，下面详细介绍一下HotSpot对new指令的处理。&lt;/p&gt;
&lt;p&gt;如果当前是解释执行，那么执行new指令其实会执行/hotspot/src/cpu/x86/vm/templateTable_x86_64.cpp文件中定义的TemplateTable::_new()方法生成的一段机器码，不过我们后面可以以源代码和汇编的形式来分析执行的逻辑。&lt;/p&gt;
&lt;p&gt;方法首先调用InterpreterMacroAssembler::get_unsigned_2_byte_index_at_bcp()方法加载new指令后的操作数，对于如上实例来说，这个值就是常量池的下标索引1。方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void InterpreterMacroAssembler::get_unsigned_2_byte_index_at_bcp(Register reg,int bcp_offset) {
  assert(bcp_offset &amp;gt;= 0, &quot;bcp is still pointing to start of bytecode&quot;);
  load_unsigned_short(reg, Address(r13, bcp_offset));
  bswapl(reg);
  shrl(reg, 16);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的汇编代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// %r13保存当前解释器的字节码指令地址，将此地址偏移1个字节后获取2个字节的内容并加载到%edx中
0x00007fffe1022b10: movzwl 0x1(%r13),%edx  
// bswap会让32位寄存器%edx中存储的内容进行字节次序反转
0x00007fffe1022b15: bswap  %edx
// shr会将%edx中的内容右移16位
0x00007fffe1022b17: shr    $0x10,%edx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用get_cpool_and_tags()方法获取常量池首地址放入rcx寄存器，获取常量池中元素类型数组_tags首地址，放入rax中，方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void get_cpool_and_tags(Register cpool, Register tags) {
    get_constant_pool(cpool);
    movptr(tags, Address(cpool, ConstantPool::tags_offset_in_bytes()));
}

void get_constant_pool(Register reg) {
    get_const(reg);
    movptr(reg, Address(reg, ConstMethod::constants_offset()));
}

void get_const(Register reg) {
    get_method(reg);
    movptr(reg, Address(reg, Method::const_offset()));
}

void get_method(Register reg) {
    movptr(reg, Address(rbp, frame::interpreter_frame_method_offset * wordSize));
}　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的汇编如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// %rbp-0x18后指向Method*，存储到%rsi中
0x00007fffe1022b1a: mov    -0x18(%rbp),%rsi 
// %rsi偏移0x10后就是ConstMethod*，存储到%rsi中
0x00007fffe1022b1e: mov    0x10(%rsi),%rsi 
// %rsi偏移0x8后就是ConstantPool*，存储到%rsi中
0x00007fffe1022b22: mov    0x8(%rsi),%rsi  
// %rsi偏移0x10后就是tags属性的地址，存储到%rax中
0x00007fffe1022b26: mov    0x10(%rsi),%rax  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回到TemplateTable::_new()方法，继续执行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
  // 判断_tags数组中对应元素类型是否为JVM_CONSTANT_Class，不是则跳往slow_case处
  const int tags_offset = Array&amp;lt;u1&amp;gt;::base_offset_in_bytes();
  __ cmpb(Address(rax, rdx, Address::times_1, tags_offset),JVM_CONSTANT_Class);
  __ jcc(Assembler::notEqual, slow_case);

  // get InstanceKlass
  // 获取创建对象所属类地址，放入rcx中，即类的运行时数据结构InstanceKlass，并将其入栈
  __ movptr(rsi, Address(rsi, rdx,Address::times_8, sizeof(ConstantPool)));

  // make sure klass is initialized &amp;amp; doesn't have finalizer
  // make sure klass is fully initialized
  //  判断类是否已经被初始化过，没有初始化过的话直接跳往slow_close进行慢速分配，
  //  如果对象所属类已经被初始化过，则会进入快速分配
  __ cmpb(
          Address(rsi,InstanceKlass::init_state_offset()),
          InstanceKlass::fully_initialized);
  __ jcc(Assembler::notEqual, slow_case);

  // get instance_size in InstanceKlass (scaled to a count of bytes)
  // 此时rcx寄存器中存放的是类InstanceKlass的内存地址，利用偏移获取类对象大小并存入rdx寄存器
  __ movl( rdx,
           Address(rsi,Klass::layout_helper_offset()) );
  // test to see if it has a finalizer or is malformed in some way
  __ testl(rdx, Klass::_lh_instance_slow_path_bit);
  __ jcc(Assembler::notZero, slow_case);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的汇编代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// %rax中存储的是_tags数组的首地址&lt;br/&gt;// %rdx中存储的就是new指令后操作数，既常量池索引
// 判断常量池索引处的类型是否为JVM_CONSTANT_Class
0x00007fffe1022b2a: cmpb   $0x7,0x4(%rax,%rdx,1)
// 不是则跳往slow_case处
0x00007fffe1022b2f: jne    0x00007fffe1022b35&lt;br/&gt;// %rsi中存储的是常量池首地址
// %rdx中存储的是new指令后的操作数，即常量池索引
// 获取要创建对象所属的类地址，即InstanceKlass地址，放入%rsi中
0x00007fffe1022b35: mov    0x58(%rsi,%rdx,8),%rsi&lt;br/&gt;// 判断类是否已经被初始化，没有初始化就跳转到slow_case处执行慢速分配
0x00007fffe1022b3a: cmpb   $0x4,0x16a(%rsi)
0x00007fffe1022b41: jne    0x00007fffe1022b47&lt;br/&gt;// 当执行如下代码时，表示类已经被初始化过
// %rsi中存放的是InstanceKlass地址，利用偏移获取此类创建的对象大小（也就是Java类创建的Java对象的大小），存入%edx中
0x00007fffe1022b47: mov    0xc(%rsi),%edx
// 判断一下类是否有finalize()方法，如果有，跳往slow_case处执行慢速分配 
0x00007fffe1022b4a: test $0x1,%edx 
0x00007fffe1022b50: jne 0x00007fffe1022b56
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当计算出了创建对象的大小后就可以执行内存分配了，回到TemplateTable::_new()方法，继续执行如下代码：　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
if (UseTLAB) { // 默认UseTLAB的值为true
    // 获取TLAB区剩余空间首地址，放入%rax中
    __ movptr(rax, Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())));

    // %rdx保存对象大小，根据TLAB空闲区首地址可计算出对象分配后的尾地址，然后放入%rbx中
    __ lea(rbx, Address(rax, rdx, Address::times_1));

    // 将%rbx中对象尾地址与TLAB空闲区尾地址进行比较
    __ cmpptr(rbx, Address(r15_thread, in_bytes(JavaThread::tlab_end_offset())));

    // 如果%rbx大小TLAB空闲区结束地址，表明TLAB区空闲区大小不足以分配该对象，
    // 在allow_shared_alloc（允许在Eden区分配）情况下，跳转到allocate_shared，否则跳转到slow_case处
    __ jcc(Assembler::above, allow_shared_alloc ? allocate_shared : slow_case);

    // 执行到这里，说明TLAB区有足够的空间分配对象
    // 对象分配后，更新TLAB空闲区首地址为分配对象后的尾地址
    __ movptr(Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())), rbx);

    // 如果TLAB区默认会对回收的空闲区清零，那么就不需要在为对象变量进行清零操作了，
    // 直接跳往对象头初始化处运行
    if (ZeroTLAB) {
      // the fields have been already cleared
      __ jmp(initialize_header);
    } else {
      // initialize both the header and fields
      __ jmp(initialize_object);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中allocate_shared变量值的计算如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
const bool allow_shared_alloc = Universe::heap()-&amp;gt;supports_inline_contig_alloc() &amp;amp;&amp;amp; !CMSIncrementalMode;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;尝试在TLAB区为对象分配内存，TLAB即ThreadLocalAllocationBuffers（线程局部分配缓存）。每个线程都有自己的一块内存区域，用于分配对象，这块内存区域便为TLAB区。这样的好处是在分配内存时，无需对一整块内存进行加锁。TLAB只是在分配对象时的操作属于线程私有，分配的对象对于其他线程仍是可读的。&lt;/p&gt;
&lt;p&gt;生成的汇编代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// 获取TLAB区剩余空间首地址，放入%rax
0x00007fffe1022b56: mov    0x70(%r15),%rax
// %rdx已经记录了对象大小，根据TLAB空闲区首地址计算出对象分配后的尾地址，放入rbx中
0x00007fffe1022b5a: lea    (%rax,%rdx,1),%rbx
// 将rbx中内容与TLAB空闲区尾地址进行比较
0x00007fffe1022b5e: cmp    0x80(%r15),%rbx
// 如果比较结果表明rbx &amp;gt; TLAB空闲区尾地址，则表明TLAB区空闲区大小不足以分配该对象，
// 在allow_shared_alloc（允许在Eden区分配）情况下，就直接跳往Eden区分配内存标号处运行
0x00007fffe1022b65: ja     0x00007fffe1022b6b
// 因为对象分配后，TLAB区空间变小，所以需要更新TLAB空闲区首地址为分配对象后的尾地址
0x00007fffe1022b6b: mov    %rbx,0x70(%r15)
// TLAB区默认不会对回收的空闲区清零，跳往initialize_object
0x00007fffe1022b6f: jmpq 0x00007fffe1022b74
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果在TLAB区分配失败，会直接在Eden区进行分配，回到TemplateTable::_new()方法继续执行如下代码：　　 &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// Allocation in the shared Eden, if allowed.
// rdx: instance size in bytes
if (allow_shared_alloc) { 
    // TLAB区分配失败会跳到这里
    __ bind(allocate_shared);

    // 获取Eden区剩余空间的首地址和结束地址
    ExternalAddress top((address)Universe::heap()-&amp;gt;top_addr());
    ExternalAddress end((address)Universe::heap()-&amp;gt;end_addr());

    const Register RtopAddr = rscratch1;
    const Register RendAddr = rscratch2;

    __ lea(RtopAddr, top);
    __ lea(RendAddr, end);
    // 将Eden空闲区首地址放入rax寄存器中
    __ movptr(rax, Address(RtopAddr, 0));

    // For retries rax gets set by cmpxchgq
    Label retry;
    __ bind(retry);
    // 计算对象尾地址，与空闲区尾地址进行比较，内存不足则跳往慢速分配。
    __ lea(rbx, Address(rax, rdx, Address::times_1));
    __ cmpptr(rbx, Address(RendAddr, 0));
    __ jcc(Assembler::above, slow_case);

    // Compare rax with the top addr, and if still equal, store the new
    // top addr in rbx at the address of the top addr pointer. Sets ZF if was
    // equal, and clears it otherwise. Use lock prefix for atomicity on MPs.
    //
    // rax: object begin rax此时记录了对象分配的内存首地址
    // rbx: object end   rbx此时记录了对象分配的内存尾地址
    // rdx: instance size in bytes  rdx记录了对象大小
    if (os::is_MP()) {
      __ lock();
    }
    // 利用CAS操作，更新Eden空闲区首地址为对象尾地址，因为Eden区是线程共用的，所以需要加锁。
    __ cmpxchgptr(rbx, Address(RtopAddr, 0));

    // if someone beat us on the allocation, try again, otherwise continue
    __ jcc(Assembler::notEqual, retry);

    __ incr_allocated_bytes(r15_thread, rdx, 0);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的汇编代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
-- allocate_shared --
// 获取Eden区剩余空间的首地址和结束地址并分别存储到%r10和%r11中
0x00007fffe1022b74: movabs $0x7ffff0020580,%r10
0x00007fffe1022b7e: movabs $0x7ffff0020558,%r11
// 将Eden空闲区首地址放入%rax
0x00007fffe1022b88: mov    (%r10),%rax
// 计算对象尾地址，与Eden空闲区结束地址进行比较，内存不足则跳往慢速分配slow_case
0x00007fffe1022b8b: lea    (%rax,%rdx,1),%rbx
0x00007fffe1022b8f: cmp    (%r11),%rbx
0x00007fffe1022b92: ja     0x00007fffe1022b98
// 利用CAS操作，更新Eden空闲区首地址为对象尾地址，因为Eden区是线程共用的，所以需要加锁
0x00007fffe1022b98: lock   cmpxchg %rbx,(%r10)
0x00007fffe1022b9d: jne    0x00007fffe1022b8b
0x00007fffe1022b9f: add    %rdx,0xd0(%r15)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;回到TemplateTable::_new()方法，对象所需内存已经分配好后，就会进行对象的初始化了，先初始化对象实例数据。继续执行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
if (UseTLAB || Universe::heap()-&amp;gt;supports_inline_contig_alloc()) {
    // The object is initialized before the header.  If the object size is
    // zero, go directly to the header initialization.
    __ bind(initialize_object);
    // 如果rdx和sizeof(oopDesc)大小一样，即对象所需大小和对象头大小一样，
    // 则表明对象真正的实例数据内存为0，不需要进行对象实例数据的初始化，
    // 直接跳往对象头初始化处即可。Hotspot中虽然对象头在内存中排在对象实例数据前，
    // 但是会先初始化对象实例数据，再初始化对象头。
    __ decrementl(rdx, sizeof(oopDesc));
    __ jcc(Assembler::zero, initialize_header);

    // Initialize object fields
    // 执行异或，使得rcx为0，为之后给对象变量赋零值做准备
    __ xorl(rcx, rcx); // use zero reg to clear memory (shorter code)
    __ shrl(rdx, LogBytesPerLong);  // divide by oopSize to simplify the loop
    {
      // 此处以rdx（对象大小）递减，按字节进行循环遍历对内存，初始化对象实例内存为零值
      // rax中保存的是对象的首地址
      Label loop;
      __ bind(loop);
      __ movq(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - oopSize ), rcx);
      __ decrementl(rdx);
      __ jcc(Assembler::notZero, loop);
    }

    // initialize object header only.
    // 对象实例数据初始化好后，开始初始化对象头（就是初始化oop中的mark和metadata属性的初始化）
    __ bind(initialize_header);
    // 是否使用偏向锁，大多时一个对象只会被同一个线程访问，所以在对象头中记录获取锁的线程id，
    // 下次线程获取锁时就不需要加锁了。
    if (UseBiasedLocking) {
      // 将类的偏向锁相关数据移动到对象头部
      // rax中保存的是对象的首地址
      __ movptr(rscratch1, Address(rsi, Klass::prototype_header_offset()));
      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()), rscratch1);
    } else {
      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),
               (intptr_t) markOopDesc::prototype()); // header (address 0x1)
    }
    // 此时rcx保存了InstanceKlass，rax保存了对象首地址，此处保存对象所属的类数据InstanceKlass放入对象头中，
    // 对象oop中的_metadata属性存储对象所属的类InstanceKlass的指针
    __ xorl(rcx, rcx);             // use zero reg to clear memory (shorter code)
    __ store_klass_gap(rax, rcx);  // zero klass gap for compressed oops
    __ store_klass(rax, rsi);      // store klass last

    // ...
    __ jmp(done);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为虚拟机添加参数 -XX:-UseCompressedOops，表示不进行指针压缩，则生成的汇编代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
-- initialize_object --
// %edx减去对象头大小0x10后，将结果存储到%edx
0x00007fffe1022ba6: sub    $0x10,%edx
// 如果%edx等于0,则跳转到initialize_header
0x00007fffe1022ba9: je     0x00007fffe1022bbd
// 执行异或，使得%ecx为0，为之后给对象变量赋零值做准备
0x00007fffe1022baf: xor    %ecx,%ecx
0x00007fffe1022bb1: shr    $0x3,%edx

-- loop --
// 此处以%rdx（对象大小）递减，按字节进行循环遍历对内存，初始化对象实例内存为零值
// %rax中保存的是对象首地址
0x00007fffe1022bb4: mov    %rcx,0x8(%rax,%rdx,8)
0x00007fffe1022bb9: dec    %edx
// 如果不相等，跳转到loop
0x00007fffe1022bbb: jne    0x00007fffe1022bb4

-- initialize_header --
// 对象实例数据初始化好后，就开始初始化对象头
// 是否使用偏向锁，大多时一个对象只会被同一个线程访问，所以在对象头中记录获取锁的线程id，
// 下次线程获取锁时就不需要加锁了
0x00007fffe1022bbd: mov    0xb0(%rsi),%r10
0x00007fffe1022bc4: mov    %r10,(%rax)
// rax保存了对象首地址，
0x00007fffe1022bc7: xor    %ecx,%ecx
// %rsi中保存的就是InstanceKlass对象的地址，%rax保存了对象首地址，偏移0x08后就是metadata
// 将InstanceKlass对象保存到对象oop中的_metadata属性中
0x00007fffe1022bc9: mov    %rsi,0x8(%rax)
// ...
// 跳转到done处执行
0x00007fffe1022c02: jmpq   0x00007fffe1022c07
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的store_klass_gap()函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void MacroAssembler::store_klass_gap(Register dst, Register src) {
  if (UseCompressedClassPointers) {
    // Store to klass gap in destination
    movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void MacroAssembler::store_klass(Register dst, Register src) {
#ifdef _LP64
  if (UseCompressedClassPointers) {
    encode_klass_not_null(src);
    movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);
  } else
#endif
    movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;UseCompressedClassPointers在设置了-XX:-UseCompressedOops命令后值都为false。&lt;/p&gt;
&lt;p&gt;回到TemplateTable::_new()方法，继续执行如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// 慢速分配，如果类没有被初始化过，会跳到此处执行
__ bind(slow_case);
// 获取常量池首地址，存入rarg1寄存器
__ get_constant_pool(c_rarg1);
// 获取new指令后操作数，即类在常量池中的索引，存入rarg2寄存器
__ get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);

// 调用InterpreterRuntime::_new()函数进行对象内存分配
call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);

__ bind(done);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生成的汇编代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
-- slow_case --
// 慢速分配，如果类没有被初始化过，会跳到此处执行
// 获取常量池地址并保存到%rsi中
0x00007fffe1022c07: mov    -0x18(%rbp),%rsi
0x00007fffe1022c0b: mov    0x10(%rsi),%rsi
0x00007fffe1022c0f: mov    0x8(%rsi),%rsi

// 获取new指令后操作数，即类在常量池中的索引，存入%edx中
0x00007fffe1022c13: movzwl 0x1(%r13),%edx
0x00007fffe1022c18: bswap  %edx
0x00007fffe1022c1a: shr    $0x10,%edx

// 如下的汇编代码调用了InterpreterRuntime::_new()函数，不过在调用函数前后，需要进行一些准备，如
// 为调用的函数准备参数等工作，后面在介绍方法执行引擎时会详细分析
0x00007fffe1022c1d: callq  0x00007fffe1022c27
0x00007fffe1022c22: jmpq   0x00007fffe1022cba
0x00007fffe1022c27: lea    0x8(%rsp),%rax
0x00007fffe1022c2c: mov    %r13,-0x38(%rbp)
0x00007fffe1022c30: mov    %r15,%rdi
0x00007fffe1022c33: mov    %rbp,0x200(%r15)
0x00007fffe1022c3a: mov    %rax,0x1f0(%r15)
0x00007fffe1022c41: test   $0xf,%esp
0x00007fffe1022c47: je     0x00007fffe1022c5f
0x00007fffe1022c4d: sub    $0x8,%rsp
0x00007fffe1022c51: callq  0x00007ffff66b302e
0x00007fffe1022c56: add    $0x8,%rsp
0x00007fffe1022c5a: jmpq   0x00007fffe1022c64
0x00007fffe1022c5f: callq  0x00007ffff66b302e
0x00007fffe1022c64: movabs $0x0,%r10
0x00007fffe1022c6e: mov    %r10,0x1f0(%r15)
0x00007fffe1022c75: movabs $0x0,%r10
0x00007fffe1022c7f: mov    %r10,0x200(%r15)
0x00007fffe1022c86: cmpq   $0x0,0x8(%r15)
0x00007fffe1022c8e: je     0x00007fffe1022c99
0x00007fffe1022c94: jmpq   0x00007fffe1000420
0x00007fffe1022c99: mov    0x250(%r15),%rax
0x00007fffe1022ca0: movabs $0x0,%r10
0x00007fffe1022caa: mov    %r10,0x250(%r15)
0x00007fffe1022cb1: mov    -0x38(%rbp),%r13
0x00007fffe1022cb5: mov    -0x30(%rbp),%r14
0x00007fffe1022cb9: retq   

-- done --
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在汇编代码中调用的InterpreterRuntime::_new()函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
源代码位置：share/vm/interpreter/inpterpreterRuntime.cpp

IRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))
  Klass* k_oop = pool-&amp;gt;klass_at(index, CHECK);
  instanceKlassHandle klass (THREAD, k_oop);

  // Make sure we are not instantiating an abstract klass
  klass-&amp;gt;check_valid_for_instantiation(true, CHECK);

  // Make sure klass is initialized
  klass-&amp;gt;initialize(CHECK);

  // At this point the class may not be fully initialized
  // because of recursive initialization. If it is fully
  // initialized &amp;amp; has_finalized is not set, we rewrite
  // it into its fast version (Note: no locking is needed
  // here since this is an atomic byte write and can be
  // done more than once).
  //
  // Note: In case of classes with has_finalized we don't
  //       rewrite since that saves us an extra check in
  //       the fast version which then would call the
  //       slow version anyway (and do a call back into
  //       Java).
  //       If we have a breakpoint, then we don't rewrite
  //       because the _breakpoint bytecode would be lost.
  oop obj = klass-&amp;gt;allocate_instance(CHECK);
  thread-&amp;gt;set_vm_result(obj);
IRT_END 
 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上方法进行类的加载和对象分配，并将分配的对象地址返回，存入rax寄存器中。调用的klass-&amp;gt;allocate_instance()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
instanceOop instanceKlass::allocate_instance(TRAPS) {
  assert(!oop_is_instanceMirror(), &quot;wrong allocation path&quot;);
  //是否重写finalize()方法
  bool has_finalizer_flag = has_finalizer(); // Query before possible GC
  //分配的对象的大小
  int size = size_helper();  // Query before forming handle.

  KlassHandle h_k(THREAD, as_klassOop());

  instanceOop i;

  //分配对象
  i = (instanceOop)CollectedHeap::obj_allocate(h_k, size, CHECK_NULL);
  if (has_finalizer_flag &amp;amp;&amp;amp; !RegisterFinalizersAtInit) {
    i = register_finalizer(i, CHECK_NULL);
  }
  return i;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用size_helper()方法获取实例对象需要的空间大小。然后调用CollectedHeap::obj_allocate(KlassHandle klass, int size, TRAPS)来为对象分配内存。此方法还需要判断类是否重写了finalize()方法，重写finalize()方法的类会让实例对象会加入finalize队列，队列里面的对象在GC前会调用finalize()方法。&lt;/p&gt;
&lt;p&gt;调用的obj_allocate()方法的实现涉及到的逻辑比较多，这里暂不介绍，后面在介绍垃圾回收时会详细介绍。　　&lt;/p&gt;
&lt;p&gt;总结一下如上的内存分配大概流程：&lt;/p&gt;
&lt;p&gt;（1）首先在TLAB区分配；&lt;/p&gt;
&lt;p&gt;（2）如果在TLAB区分配失败，则在Eden区分配；&lt;/p&gt;
&lt;p&gt;（3）如果无法在TLAB和Eden区分配，那么会调用InterpreterRuntime::_new()函数进行分配。&lt;/p&gt;
&lt;p&gt;对象的内存分配，往大方向讲，就是在堆上分配，对象主要分配在新生代的Eden区上。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关参数的设置。后面我们在介绍具体的垃圾收集器时再细化一下这个对象分配的过程。&lt;/p&gt;
&lt;p&gt;相关文章的链接如下：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13215548.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;2、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13217159.html&quot; target=&quot;_blank&quot;&gt;调试HotSpot源代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot; target=&quot;_blank&quot;&gt;HotSpot项目结构&lt;/a&gt;　&lt;/p&gt;
&lt;p&gt;4、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13228157.html&quot; target=&quot;_blank&quot;&gt;HotSpot的启动过程&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;5、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13233607.html&quot; target=&quot;_blank&quot;&gt;HotSpot二分模型（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13237631.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（2）&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;7、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13252983.html&quot; target=&quot;_blank&quot;&gt;HotSpot的类模型（3） &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;8、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13272865.html&quot;&gt;HotSpot的类模型（4）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13289686.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（5） &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;10、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13291427.html&quot; target=&quot;_blank&quot;&gt;HotSpot的对象模型（6）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;11、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13297034.html&quot; target=&quot;_blank&quot;&gt;操作句柄Handle（7）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;12、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13303505.html&quot; target=&quot;_blank&quot;&gt;句柄Handle的释放（8）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;13、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13320889.html&quot; target=&quot;_blank&quot;&gt;类加载器&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;14、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13338549.html&quot; target=&quot;_blank&quot;&gt;类的双亲委派机制&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;15、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13343296.html&quot; target=&quot;_blank&quot;&gt;核心类的预装载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;16、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13353233.html&quot; target=&quot;_blank&quot;&gt;Java主类的装载 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;17、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13354961.html&quot; target=&quot;_blank&quot;&gt;触发类的装载 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;18、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13356636.html&quot; target=&quot;_blank&quot;&gt;类文件介绍&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;19、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13358460.html&quot; target=&quot;_blank&quot;&gt;文件流&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;20、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13407609.html&quot; target=&quot;_blank&quot;&gt;解析Class文件&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;21、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13407690.html&quot; target=&quot;_blank&quot;&gt;常量池解析（1）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;22、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13408261.html&quot; target=&quot;_blank&quot;&gt;常量池解析（2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;23、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13409707.html&quot; target=&quot;_blank&quot;&gt;字段解析（1）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;24、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13409953.html&quot; target=&quot;_blank&quot;&gt;字段解析之伪共享（2）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;25、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13413170.html&quot; target=&quot;_blank&quot;&gt;字段解析（3） &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;26、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13413207.html&quot; target=&quot;_blank&quot;&gt;字段解析之OopMapBlock（4）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;27、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13436627.html&quot; target=&quot;_blank&quot;&gt;方法解析之Method与ConstMethod介绍 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;28、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13436632.html&quot; target=&quot;_blank&quot;&gt;方法解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;29、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13456515.html&quot; target=&quot;_blank&quot;&gt;klassVtable与klassItable类的介绍&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;30、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13461949.html&quot; target=&quot;_blank&quot;&gt;计算vtable的大小&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;31、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13462910.html&quot; target=&quot;_blank&quot;&gt;计算itable的大小 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;32、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13467751.html&quot; target=&quot;_blank&quot;&gt;解析Class文件之创建InstanceKlass对象&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;33、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13469745.html&quot; target=&quot;_blank&quot;&gt;字段解析之字段注入&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;34、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13470515.html&quot; target=&quot;_blank&quot;&gt;类的连接 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;35、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13473410.html&quot; target=&quot;_blank&quot;&gt;类的连接之验证&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;36、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13474567.html&quot; target=&quot;_blank&quot;&gt;类的连接之重写（1）&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;37、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13474577.html&quot; target=&quot;_blank&quot;&gt;类的连接之重写（2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;38、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13488845.html&quot; target=&quot;_blank&quot;&gt;方法的连接 &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;39、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13494714.html&quot; target=&quot;_blank&quot;&gt;初始化vtable&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;40、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13495636.html&quot; target=&quot;_blank&quot;&gt;初始化itable &lt;/a&gt; &lt;/p&gt;
&lt;p&gt;41、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13495639.html&quot; target=&quot;_blank&quot;&gt;类的初始化 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作者持续维护的个人博客  &lt;a href=&quot;http://classloading.com/&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;classloading.com&lt;/strong&gt;&lt;/a&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号，有HotSpot源码剖析系列文章！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202006/1236123-20200630200021532-955264784.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;  &lt;/p&gt;
&lt;p&gt;参考文章：&lt;/p&gt;
&lt;p&gt;（1）&lt;a href=&quot;https://www.jianshu.com/p/36c4de5ed199&quot; target=&quot;_blank&quot;&gt;new背后的故事&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;（2）&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/simoncook/p/11141256.html&quot;&gt;虚拟机解释器与bytecode对接&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;（3）&lt;a href=&quot;https://www.cnblogs.com/simoncook/p/11194057.html&quot; target=&quot;_blank&quot;&gt;对象创建&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;（4）&lt;a id=&quot;lnkBlogTitle&quot; href=&quot;https://www.cnblogs.com/simoncook/&quot;&gt;Chen.Simon的博客&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;（5）&lt;a href=&quot;https://www.jianshu.com/p/0009aaac16ed&quot; target=&quot;_blank&quot;&gt;JVM源码分析之Java对象的创建过程&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;（6）&lt;a href=&quot;https://www.jianshu.com/p/cd85098cca39&quot; target=&quot;_blank&quot;&gt;JVM源码分析之线程局部缓存TLAB&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;（7）&lt;a href=&quot;https://www.jianshu.com/p/2343f2c0ecc4&quot; target=&quot;_blank&quot;&gt;RednaxelaFX、你假笨关于TLAB的一些分析总结&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;（8）&lt;a href=&quot;https://zhuanlan.zhihu.com/p/34213112&quot; target=&quot;_blank&quot;&gt;JVM之创建对象源码分析&lt;/a&gt; &lt;/p&gt;


</description>
<pubDate>Sat, 15 Aug 2020 00:45:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>Java对象创建的流程大概如下： 检查对象所属类是否已经被加载解析； 为对象分配内存空间； 将分配给对象的内存初始化为零值； 执行对象的&amp;lt;init&amp;gt;方法进行初始化。 举个例子如下： pub</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/13500050.html</dc:identifier>
</item>
<item>
<title>Alink漫谈(十八) ：源码解析 之 多列字符串编码MultiStringIndexer - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13429876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13429876.html</guid>
<description>&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文将带领大家来分析Alink中 MultiStringIndexer 的实现。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;347.35243429556&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文将带领大家来分析Alink中 MultiStringIndexer 的实现。&lt;/p&gt;
&lt;p&gt;因为Alink的公开资料太少，所以以下均为自行揣测，肯定会有疏漏错误，希望大家指出，我会随时更新。&lt;/p&gt;
&lt;p&gt;本文缘由是想分析GBDT，发现GBDT涉及到MultiStringIndexer的使用，所以只能先分析MultiStringIndexer 。&lt;/p&gt;
&lt;h2 id=&quot;0x01-概念&quot;&gt;0x01 概念&lt;/h2&gt;
&lt;p&gt;Alink的官方介绍是：MultiStringIndexer训练组件的作用是训练一个模型用于将多列字符串映射为整数。&lt;/p&gt;
&lt;p&gt;具体来说，StringIndexer（字符串-索引变换）将标签的&quot;字符串列&quot;编码为&quot;标签索引的列&quot;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标签索引序列的取值范围是[0，numLabels（字符串中所有出现的单词去掉重复的词后的总和）]，按照标签出现频率排序，出现最多的标签索引为0（具体为升序降序是可以配置的）。&lt;/li&gt;
&lt;li&gt;如果输入是数值型，我们先将数值映射到字符串，再对字符串进行索引化。&lt;/li&gt;
&lt;li&gt;如果下游的pipeline（例如：Estimator或者Transformer）需要用到索引化后的标签序列，则需要将这个pipeline的输入列名字指定为索引化序列的名字。大部分情况下，通过setSelectedCols设置输入的列名。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以这些输入为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;(&quot;football&quot;, &quot;can&quot;),
(&quot;football&quot;, &quot;hhh&quot;),
(&quot;football&quot;, &quot;zzz&quot;),
(&quot;basketball&quot;, &quot;zzz&quot;),
(&quot;basketball&quot;, &quot;can&quot;),
(&quot;tennis&quot;, &quot;can&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于第一列，MultiStringIndexer 对数据集的label进行重新编号。按label出现的频次，转换成0 ～ numOfLabels - 1(分类个数)。如果是按照从高到低排序，则频次最高的转换为0，以此类推，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;football，出现次数最多，出现了3次，转换（编号）为0&lt;/li&gt;
&lt;li&gt;其次是basketball，出现了2次，编号为1，以此类推。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在应用StringIndexer对labels进行重新编号后，带着这些编号后的label对数据进行了训练，并接着对其他数据进行了预测，得到预测结果，预测结果的label也是重新编号过的，因此需要转换回来。&lt;/p&gt;
&lt;h2 id=&quot;0x02-示例代码&quot;&gt;0x02 示例代码&lt;/h2&gt;
&lt;p&gt;示例代码如下，本示例代码中，是按照升序排列，即football总数为3，则其idx为3，tennis个数为1，其idx为0：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MultiStringIndexerExample {
    static AlgoOperator getData(boolean isBatch) {
        Row[] array = new Row[] {
                Row.of(&quot;football&quot;, &quot;can&quot;),
                Row.of(&quot;football&quot;, &quot;hhh&quot;),
                Row.of(&quot;football&quot;, &quot;zzz&quot;),
                Row.of(&quot;basketball&quot;, &quot;zzz&quot;),
                Row.of(&quot;basketball&quot;, &quot;can&quot;),
                Row.of(&quot;tennis&quot;, &quot;can&quot;)
        };

        if (isBatch) {
            return new MemSourceBatchOp(
                    Arrays.asList(array), new String[] {&quot;a&quot;, &quot;b&quot;});
        } else {
            return new MemSourceStreamOp(
                    Arrays.asList(array), new String[] {&quot;a&quot;, &quot;b&quot;});
        }
    }

    public static void main(String[] args) throws Exception {
        BatchOperator data = (BatchOperator)getData(true);
        MultiStringIndexer stringindexer = new MultiStringIndexer()
                .setSelectedCols(&quot;a&quot;, &quot;b&quot;)
                .setOutputCols(&quot;a_indexed&quot;, &quot;b_indexed&quot;)
                .setStringOrderType(&quot;frequency_asc&quot;);
        stringindexer.fit(data).transform(data).print();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;a|b|a_indexed|b_indexed
-|-|---------|---------
football|can|2|2
football|hhh|2|0
football|zzz|2|1
basketball|zzz|1|1
basketball|can|1|2
tennis|can|0|2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;转换成表格看的更清楚。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a_indexed&lt;/th&gt;
&lt;th&gt;b_indexed&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;football&lt;/td&gt;
&lt;td&gt;can&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;football&lt;/td&gt;
&lt;td&gt;hhh&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;football&lt;/td&gt;
&lt;td&gt;zzz&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;basketball&lt;/td&gt;
&lt;td&gt;zzz&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;basketball&lt;/td&gt;
&lt;td&gt;can&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tennis&lt;/td&gt;
&lt;td&gt;can&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;0x03-总体逻辑&quot;&gt;0x03 总体逻辑&lt;/h2&gt;
&lt;p&gt;我们先给出一个流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202008/1850883-20200815074945552-187376175.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;老套路，我们从 MultiStringIndexerTrainBatchOp.linkFrom开始挖掘。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public MultiStringIndexerTrainBatchOp linkFrom(BatchOperator&amp;lt;?&amp;gt;... inputs) {
    BatchOperator&amp;lt;?&amp;gt; in = checkAndGetFirst(inputs);

    // 示例中有 .setSelectedCols(&quot;a&quot;, &quot;b&quot;)，这里是取出具体列名字
    final String[] selectedColNames = getSelectedCols();
    // 获取列的类型
    final String[] selectedColSqlType = new String[selectedColNames.length];
    for (int i = 0; i &amp;lt; selectedColNames.length; i++) {
        selectedColSqlType[i] = FlinkTypeConverter.getTypeString(
            TableUtil.findColTypeWithAssertAndHint(in.getSchema(), selectedColNames[i]));
    }

// runtime打印数据
selectedColNames = {String[2]@2536} 
 0 = &quot;a&quot;
 1 = &quot;b&quot;
selectedColSqlType = {String[2]@2537} 
 0 = &quot;VARCHAR&quot;
 1 = &quot;VARCHAR&quot;
  
    // 获取选取列对应的数据
    DataSet&amp;lt;Row&amp;gt; inputRows = in.select(selectedColNames).getDataSet();
    // 
    DataSet&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt; indexedToken =
        StringIndexerUtil.indexTokens(inputRows, getStringOrderType(), 0L, true);

    DataSet&amp;lt;Row&amp;gt; values = indexedToken
        .mapPartition(new RichMapPartitionFunction&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;, Row&amp;gt;() {
            @Override
            public void mapPartition(Iterable&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt; values, Collector&amp;lt;Row&amp;gt; out)
                throws Exception {
                Params meta = null;
                if (getRuntimeContext().getIndexOfThisSubtask() == 0) {           
                    // 第一个task会做这个计算，就是把列名，列类型作为元数据传送
                    meta = new Params().set(HasSelectedCols.SELECTED_COLS, selectedColNames)
                        .set(HasSelectedColTypes.SELECTED_COL_TYPES, selectedColSqlType);
                }
 
// runtime打印数据              
meta = {Params@9311} &quot;Params {selectedCols=[&quot;a&quot;,&quot;b&quot;], selectedColTypes=[&quot;VARCHAR&quot;,&quot;VARCHAR&quot;]}&quot;
 params = {HashMap@9316}  size = 2              
              
                new MultiStringIndexerModelDataConverter().save(Tuple2.of(meta, values), out);
            }
        })
        .name(&quot;build_model&quot;);

    this.setOutput(values, new MultiStringIndexerModelDataConverter().getModelSchema());
    return this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练过程总体逻辑总结如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;取出具体列名字，列的类型；&lt;/li&gt;
&lt;li&gt;获取&quot;选取列&quot;对应的数据；&lt;/li&gt;
&lt;li&gt;把列名，列类型作为元数据传送；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StringIndexerUtil.indexTokens&lt;/code&gt; 给各个列的不同字串赋予连续的indices。每列的 indices 彼此不相关；
&lt;ul&gt;&lt;li&gt;调用到 &lt;code&gt;indexSortedByFreq(data, startIndex, ignoreNull, true)&lt;/code&gt;，作用是给各个列的不同字串赋予连续的indices，indices是按照字符串出现的频率排序；
&lt;ul&gt;&lt;li&gt;调用到 countTokens的作用是按照 &quot;列idx&quot;，&quot;word&quot; 来合并计算单词个数，得到&amp;lt;&quot;列idx&quot;，&quot;word&quot;，单词个数&amp;gt;，比如第一列中，football这个单词的个数是3，则返回三元组是 &amp;lt;0,football,3&amp;gt;，其中列的idx从0开始计算。
&lt;ul&gt;&lt;li&gt;调用 flattenTokens 把输入数据 Row 给打散，返回 A DataSet of tuples of column index and token，即&amp;lt;&quot;列idx&quot;，&quot;word&quot;&amp;gt;。比如对于 Row.of(&quot;football&quot;, &quot;can&quot;) 这个输入，flattenTokens 输出两个Tuple2 ，&amp;lt;0, &quot;football&quot;&amp;gt; 和 &amp;lt;1, &quot;can&quot;&amp;gt;。&lt;/li&gt;
&lt;li&gt;对上面结构进行map操作，输出&amp;lt;column idx, word, 1L&amp;gt;，比如 &amp;lt;0, &quot;football&quot;, 1L&amp;gt; ;&lt;/li&gt;
&lt;li&gt;按照 &quot;列idx&quot;，&quot;word&quot; 来分组;&lt;/li&gt;
&lt;li&gt;按照 &quot;列idx&quot;，&quot;word&quot; 来合并计算单词个数;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;indexSortedByFreq会对countTokens返回的结果&amp;lt;&quot;列idx&quot;，&quot;word&quot;，词频&amp;gt;处理；
&lt;ul&gt;&lt;li&gt;首先按照 列idx 做分组；&lt;/li&gt;
&lt;li&gt;然后在上面结果基础上，按照单词个数排序；&lt;/li&gt;
&lt;li&gt;排序的index是以输入参数startIndex开始，startIndex在这里是0；&lt;/li&gt;
&lt;li&gt;最后得到 第一列的 (0,football,0)，(0,basketball,1)，(0,football,2)；第二列的数据 (1,hhh,0)，(1,zzz,1)，(1,can,2)；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;把indexTokens的结果存储为模型，其中使用之前提到的 &quot;把列名，列类型作为元数据&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面具体剖析后两个阶段。&lt;/p&gt;
&lt;h2 id=&quot;0x04-add-index-to-token&quot;&gt;0x04 Add Index to Token&lt;/h2&gt;
&lt;p&gt;这部分就是给各个列的不同字串赋予连续的indices。每列的 indices 彼此不相关。&lt;/p&gt;
&lt;p&gt;具体是由StringIndexerUtil.indexTokens 做到的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static DataSet&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt; indexTokens(
    DataSet&amp;lt;Row&amp;gt; data, HasStringOrderTypeDefaultAsRandom.StringOrderType orderType,
    final long startIndex, final boolean ignoreNull) {
                case FREQUENCY_ASC:
                return indexSortedByFreq(data, startIndex, ignoreNull, true);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;41-合并计算单词个数&quot;&gt;4.1 合并计算单词个数&lt;/h3&gt;
&lt;p&gt;indexSortedByFreq会调用countTokens来计算单词个数，所以我们先看countTokens。&lt;/p&gt;
&lt;p&gt;countTokens的作用是按照 &quot;列idx&quot;，&quot;word&quot; 来合并计算单词个数，比如第一列中，football这个单词的个数是3，则返回三元组是 &amp;lt;0,football,3&amp;gt;，其中列的idx从0开始计算。&lt;/p&gt;
&lt;p&gt;具体逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用 flattenTokens 把输入数据 Row 给打散，返回 A DataSet of tuples of column index and token，即&amp;lt;&quot;列idx&quot;，&quot;word&quot;&amp;gt;。比如对于 Row.of(&quot;football&quot;, &quot;can&quot;) 这个输入，flattenTokens 输出两个Tuple2 ，&amp;lt;0, &quot;football&quot;&amp;gt; 和 &amp;lt;1, &quot;can&quot;&amp;gt;。&lt;/li&gt;
&lt;li&gt;对上面结果进行map操作，输出&amp;lt;column idx, word, 1L&amp;gt;，比如 &amp;lt;0, &quot;football&quot;, 1L&amp;gt; ，这个是计数的常规操作。&lt;/li&gt;
&lt;li&gt;按照 &quot;列idx&quot;，&quot;word&quot; 来分组;&lt;/li&gt;
&lt;li&gt;按照 &quot;列idx&quot;，&quot;word&quot; 来合并计算单词个数，就是不停归并上面的 1L。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;411-打散输入数据&quot;&gt;4.1.1 打散输入数据&lt;/h4&gt;
&lt;p&gt;其中 flattenTokens 的作用是把输入数据 Row 给打散，返回 A DataSet of tuples of column index and token.。&lt;/p&gt;
&lt;p&gt;比如对于 Row.of(&quot;football&quot;, &quot;can&quot;) 这个输入，flattenTokens 使用 &lt;code&gt;out.collect(Tuple2.of(i, String.valueOf(o)));&lt;/code&gt; 输出两个Tuple2。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;value = {Row@9212} &quot;football,can&quot;
 fields = {Object[2]@9215} 
  0 = &quot;football&quot;
  1 = &quot;can&quot;
  
输出 &amp;lt;0, &quot;football&quot;&amp;gt; 和 &amp;lt;1, &quot;can&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;412-分组计算个数&quot;&gt;4.1.2 分组计算个数&lt;/h4&gt;
&lt;p&gt;这是通过flattenTokens的结果进行 map，groupBy，reduce的一系列操作完成的。&lt;/p&gt;
&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static DataSet&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt; countTokens(DataSet&amp;lt;Row&amp;gt; data, final boolean ignoreNull) {
    return flattenTokens(data, ignoreNull) // 把输入数据 Row 给打散
        .map(new MapFunction&amp;lt;Tuple2&amp;lt;Integer, String&amp;gt;, Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt;() {
            @Override
            public Tuple3&amp;lt;Integer, String, Long&amp;gt; map(Tuple2&amp;lt;Integer, String&amp;gt; value) throws Exception {
                return Tuple3.of(value.f0, value.f1, 1L); // 输出&amp;lt;column idx, word, 1L&amp;gt;，比如 &amp;lt;0, &quot;football&quot;, 1L&amp;gt; 
            }
        })
        .groupBy(0, 1) // 按照 &quot;列idx&quot;，&quot;word&quot; 来分组
        .reduce(new ReduceFunction&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt;() {
            @Override
            public Tuple3&amp;lt;Integer, String, Long&amp;gt; reduce(Tuple3&amp;lt;Integer, String, Long&amp;gt; value1, Tuple3&amp;lt;Integer, String, Long&amp;gt; value2) throws Exception {
                value1.f2 += value2.f2;
                return value1; // 按照 &quot;列idx&quot;，&quot;word&quot; 来合并计算单词个数
            }
        })
        .name(&quot;count_tokens&quot;);
}

// reduce之后发出
value1 = {Tuple3@9284} &quot;(0,football,3)&quot;
 f0 = {Integer@9226} 0
 f1 = &quot;football&quot;
 f2 = {Long@9295} 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-合并计算单词个数&quot;&gt;4.2 合并计算单词个数&lt;/h3&gt;
&lt;p&gt;前面 countTokens的 返回三元组是 &amp;lt;列idx&quot;，&quot;word&quot; ，词频&amp;gt;，其中列的idx从0开始计算。&lt;/p&gt;
&lt;p&gt;indexSortedByFreq会对countTokens返回的结果&amp;lt;&quot;列idx&quot;，&quot;word&quot;，词频&amp;gt;处理；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先按照 列idx 做分组；&lt;/li&gt;
&lt;li&gt;然后在上面结果基础上，按照单词个数排序；&lt;/li&gt;
&lt;li&gt;排序的index是以输入参数startIndex开始，startIndex在这里是0；&lt;/li&gt;
&lt;li&gt;最后得到 第一列的 (0,tennis,0)，(0,basketball,1)，(0,football,2)；第二列的数据 (1,hhh,0)，(1,zzz,1)，(1,can,2)；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static DataSet&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt; indexSortedByFreq(
    DataSet&amp;lt;Row&amp;gt; data, final long startIndex, final boolean ignoreNull, final boolean isAscending) {
    return countTokens(data, ignoreNull)
        .groupBy(0) //按照 列idx 做分组
        .sortGroup(2, isAscending ? Order.ASCENDING : Order.DESCENDING) //按照单词个数排序
        .reduceGroup(new GroupReduceFunction&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;, Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt;() {
            @Override
            public void reduce(Iterable&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt; values,
                               Collector&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt; out) {
                long id = startIndex;
                for (Tuple3&amp;lt;Integer, String, Long&amp;gt; value : values) {
                    out.collect(Tuple3.of(value.f0, value.f1, id++)); // 归并
                }
            }
        });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x05-输出模型&quot;&gt;0x05 输出模型&lt;/h2&gt;
&lt;p&gt;这部分分为两部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输出元数据，就是之前得到的 &quot;把列名，列类型作为元数据&quot;。&lt;/li&gt;
&lt;li&gt;输出具体每一列的每一个单词信息，比如 第一列的 (0,tennis,0)，(0,basketball,1)，(0,football,2)；第二列的数据 (1,hhh,0)，(1,zzz,1)，(1,can,2)；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MultiStringIndexerModelDataConverter implements
    ModelDataConverter&amp;lt;Tuple2&amp;lt;Params, Iterable&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt;&amp;gt;, MultiStringIndexerModelData&amp;gt; {
    @Override
    public void save(Tuple2&amp;lt;Params, Iterable&amp;lt;Tuple3&amp;lt;Integer, String, Long&amp;gt;&amp;gt;&amp;gt; modelData, Collector&amp;lt;Row&amp;gt; collector) {
        if (modelData.f0 != null) {
            collector.collect(Row.of(-1L, modelData.f0.toJson(), null));
        }
        modelData.f1.forEach(tuple -&amp;gt; {
            collector.collect(Row.of(tuple.f0.longValue(), tuple.f1, tuple.f2));
        });
    }  
}

tuple = {Tuple3@9405} &quot;(0,tennis,0)&quot;
 f0 = {Integer@9406} 0
 f1 = &quot;tennis&quot;
 f2 = {Long@9408} 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x06-预测&quot;&gt;0x06 预测&lt;/h2&gt;
&lt;p&gt;预测功能是在 ModelMapperAdapter 完成的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ModelMapperAdapter extends RichMapFunction&amp;lt;Row, Row&amp;gt; implements Serializable {
    private final ModelMapper mapper;
    private final ModelSource modelSource;

    @Override
    public void open(Configuration parameters) throws Exception {
        List&amp;lt;Row&amp;gt; modelRows = this.modelSource.getModelRows(getRuntimeContext());
        this.mapper.loadModel(modelRows); //加载模型
    }

    @Override
    public Row map(Row row) throws Exception {
        return this.mapper.map(row); //预测
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;61-加载模型&quot;&gt;6.1 加载模型&lt;/h3&gt;
&lt;p&gt;MultiStringIndexerModelDataConverter中我们会进行模型加载。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先会加载元信息&lt;/li&gt;
&lt;li&gt;其次会逐条加载模型信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public MultiStringIndexerModelData load(List&amp;lt;Row&amp;gt; rows) {
    MultiStringIndexerModelData modelData = new MultiStringIndexerModelData();
    modelData.tokenAndIndex = new ArrayList&amp;lt;&amp;gt;();
    modelData.tokenNumber = new HashMap&amp;lt;&amp;gt;();
    for (Row row : rows) {
        long colIndex = (Long) row.getField(0);
        if (colIndex &amp;lt; 0L) { // 元数据
            modelData.meta = Params.fromJson((String) row.getField(1));
        } else { // 具体模型信息
            int columnIndex = ((Long) row.getField(0)).intValue();
            Long tokenIndex = Long.valueOf(String.valueOf(row.getField(2)));
            modelData.tokenAndIndex.add(Tuple3.of(columnIndex, (String) row.getField(1), tokenIndex));
            modelData.tokenNumber.merge(columnIndex, 1L, Long::sum); // 合并列数据个数
        }
    }

    // To ensure that every columns has token number.
    int numFields = 0;
    if (modelData.meta != null) {
        numFields = modelData.meta.get(HasSelectedCols.SELECTED_COLS).length;
    }
    for (int i = 0; i &amp;lt; numFields; i++) {
        modelData.tokenNumber.merge(i, 0L, Long::sum);
    }
    return modelData;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后模型内容如下，其中 tokenNumber 表示每列的数据有几个，tokenAndIndex表示具体信息，比如(0,tennis,0)，(0,basketball,1)，(0,football,2) 就表示他们都是第一列的，basketball转换后的数据是 1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;modelData = {MultiStringIndexerModelData@9348} 
 meta = {Params@9440} &quot;Params {selectedCols=[&quot;a&quot;,&quot;b&quot;], selectedColTypes=[&quot;VARCHAR&quot;,&quot;VARCHAR&quot;]}&quot;
 tokenAndIndex = {ArrayList@9360}  size = 6
  0 = {Tuple3@9472} &quot;(0,football,2)&quot;
  1 = {Tuple3@9511} &quot;(0,tennis,0)&quot;
  2 = {Tuple3@9512} &quot;(1,zzz,1)&quot;
  3 = {Tuple3@9513} &quot;(1,hhh,0)&quot;
  4 = {Tuple3@9514} &quot;(0,basketball,1)&quot;
  5 = {Tuple3@9515} &quot;(1,can,2)&quot;
 tokenNumber = {HashMap@9385}  size = 2
  {Integer@9507} 0 -&amp;gt; {Long@9508} 3
  {Integer@9509} 1 -&amp;gt; {Long@9508} 3
numFields = 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;62-预测&quot;&gt;6.2 预测&lt;/h3&gt;
&lt;p&gt;预测是在 MultiStringIndexerModelMapper 完成的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 假设输入是：row = {Row@9309} &quot;football,can&quot;
// 选择的列是：selectedColNames = {String[2]@9314}  0 = &quot;a&quot; 1 = &quot;b&quot;
// 模型映射器是：
this = {MultiStringIndexerModelMapper@9309} 
 indexMapper = {HashMap@9318}  size = 2
  {Integer@9357} 0 -&amp;gt; {HashMap@9314}  size = 3
   key = {Integer@9357} 0
    value = 0
   value = {HashMap@9314}  size = 3
    &quot;basketball&quot; -&amp;gt; {Long@9386} 1
    &quot;football&quot; -&amp;gt; {Long@9332} 2
    &quot;tennis&quot; -&amp;gt; {Long@9384} 0
  {Integer@9352} 1 -&amp;gt; {HashMap@9358}  size = 3
   key = {Integer@9352} 1
    value = 1
   value = {HashMap@9358}  size = 3
    &quot;can&quot; -&amp;gt; {Long@9332} 2
    &quot;hhh&quot; -&amp;gt; {Long@9384} 0
    &quot;zzz&quot; -&amp;gt; {Long@9386} 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;则经历过下列代码，最后就可以进行预测&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Row map(Row row) throws Exception {
    Row result = new Row(selectedColNames.length);
    for (int i = 0; i &amp;lt; selectedColNames.length; i++) {
        Map&amp;lt;String, Long&amp;gt; mapper = indexMapper.get(i);
        int colIdxInData = selectedColIndicesInData[i];
        Object val = row.getField(colIdxInData);
        String key = val == null ? null : String.valueOf(val);
        Long index = mapper.get(key);
        if (index != null) {
            result.setField(i, index); // 我们主要执行在这里
        } else {
        }
    }
  
// 最后预测结果是：
row = {Row@9308} &quot;football,can&quot;
result = {Row@9313} &quot;2,2&quot;
    
    return outputColsHelper.getResultRow(row, result);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_735f29100102wrz0.html&quot;&gt;Spark之特征预处理&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 14 Aug 2020 23:51:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文将带领大家来分析Alink中 MultiStringIndex</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13429876.html</dc:identifier>
</item>
<item>
<title>聊聊MySQL主从复制的几种复制方式 - itbsl</title>
<link>http://www.cnblogs.com/itbsl/p/13507401.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itbsl/p/13507401.html</guid>
<description>&lt;h3 id=&quot;异步复制&quot;&gt;异步复制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MySQL的复制默认是异步的&lt;/strong&gt;，主从复制至少需要两个MYSQL服务，这些MySQL服务可以分布在不同的服务器上，也可以在同一台服务器上。&lt;/p&gt;
&lt;p&gt;MySQL主从异步复制是最常见的复制场景。数据的完整性依赖于主库BINLOG的不丢失，只要主库的BINLOG不丢失，那么就算主库宕机了，我们还可以通过BINLOG把丢失的部分数据通过手工同步到从库上去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：主库宕机的情况下，DBA可以通过mysqlbinlog工具手工访问主库binlog，抽取缺失的日志并同步到从库上去；也可以通过配置高可用MHA架构来自动抽取缺失的数据补全从库，或者启用Global Transaction Identifiers（GTID)来自动抽取缺失binlog到从库。&lt;/p&gt;
&lt;p&gt;MySQL在BINLOG中记录事务(或SQL语句),也就是说对于支持事务的的引擎(例如InnoDB)来说，每个事务提交时都需要写BINLOG；对于不支持事务的引擎(例如MyISAM)来说，每个SQL语句执行完成时，都需要些BINLOG。为了保证Binlog的安全，MySQL引入sync_binlog参数来控制BINLOG刷新到磁盘的频率。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;show variables like 'sync_binlog';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/720430/202008/720430-20200815072934885-1067524860.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在默认情况下，sync_binlog=1，表示事务提交之前，MySQL都需要先把BINLOG刷新到磁盘，这样的话，即使出现数据库主机操作系统崩溃或者主机突然掉电的情况，系统最多损失prepared状态的事务；设置sync_binlog=1，尽可能保证数据安全。&lt;/li&gt;
&lt;li&gt;sync_binlog=0,表示MySQL不控制binlog的刷新，由文件系统自己控制文件缓存的刷新。&lt;/li&gt;
&lt;li&gt;sync_binlog=N,如果N不等于0或者1，刷新方式同sync_binlog=1类似，只不过此时会延长刷新频率至N次binlog提交组之后。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上是传统的异步复制，在MySQL5.7的并行复制技术(也称多线程复制)到来之前，为人诟病最多的还是效率问题，slave延迟是一个顽疾，虽然之前已经出现了schema级别的并行复制，但实际效果并不好。&lt;/p&gt;
&lt;h3 id=&quot;多线程复制&quot;&gt;多线程复制&lt;/h3&gt;
&lt;p&gt;在MySQL5.7中，带来了全新的&lt;strong&gt;多线程复制&lt;/strong&gt;技术，解决了当master同一个schema下的数据发生了变更，从库不能并发应用的问题，同事也真正将binlog组提交的优势充分发挥出来，保障了从库并发应用Relay Log的能力。&lt;/p&gt;
&lt;p&gt;在MySQL8.0中，多线程复制又进行了技术更新，引入了writeset的概念，而在之前的版本中，如果主库的同一个会话顺序执行多个不同相关对象的事务，例如，先执行了Update A表的数据，又执行了Update B表的数据，那么BINLOG在复制到从库后，这两个事务是不能并行执行的，writeset的到来，突破了这个限制。&lt;/p&gt;
&lt;h3 id=&quot;增强半同步复制&quot;&gt;增强半同步复制&lt;/h3&gt;
&lt;p&gt;前面介绍的复制是异步操作，主库和从库的数据之间难免会存在一定的延迟，这样存在一个隐患：当在主库上写入一个事务并提交成功，而从库尚未得到主库的BINLOG日志时，主库由于磁盘损坏、内存故障、断电等原因意外宕机，导致主库上该事务BINLOG丢失，此时从库就会损失这个事务，从而造成主从不一致。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，从MySQL5.5开始，引入了半同步复制，此时的技术暂且称之为传统的半同步复制，因该技术发展到MySQL5.7后，已经演变为增强半同步复制(也成为无损复制)。在异步复制时，主库执行Commit提交操作并写入BINLOG日志后即可成功返回客户端，无需等待BINLOG日志传送给从库，如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/720430/202008/720430-20200815072948109-708709675.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而半同步复制时，为了保证主库上的每一个BINLOG事务都能够被可靠地复制到从库上，主库在每次事务成功提交时，并不及时反馈给前端应用用户，而是等待至少一个从库(详见参数rpl_semi_sync_master_wait_for_slave_count)也接收到BINLOG事务并成功写入中继日志后，主库才返回Commit操作成功给客户端(不管是传统的半同步复制，还是增强的半同步复制，目的都是一样的，只不过两种方式有一个席位地方不同，将在下面说明)&lt;/p&gt;
&lt;p&gt;半同步复制保证了事务成功提交后，至少有两份日志记录，一份在主库的BINLOG日志上，另一份在至少一个从库的中继日志Relay Log上，从而更进一步保证了数据的完整性。&lt;/p&gt;
&lt;p&gt;在传统的半同步复制中，主库写数据到BINLOG，且执行Commit操作后，会一直等待从库的ACK，即从库写入Relay Log后，并将数据落盘，返回给主库消息，通知主库可以返回前端应用操作成功，这样会出现一个问题，就是实际上主库已经将该事务Commit到了事务引擎层，应用已经可以可以看到数据发生了变化，只是在等待返回而已，如果此时主库宕机，有可能从库还没能写入Relay Log，就会发生主从库不一致。增强半同步复制就是为了解决这个问题，做了微调，即主库写数据到BINLOG后，就开始等待从库的应答ACK，直到至少一个从库写入Relay Log后，并将数据落盘，然后返回给主库消息，通知主库可以执行Commit操作，然后主库开始提交到事务引擎层，应用此时可以看到数据发生了变化。增强半同步复制的大致流程如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/720430/202008/720430-20200815072956490-939217837.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;半同步复制模式下，假如在传送BINLOG日志到从库时，从库宕机或者网络延迟，导致BINLOG并没有即使地传送到从库上，此时主库上的事务会等待一段时间(时间长短由参数rpl_semi_sync_master_timeout设置的毫秒数决定)，如果BINLOG在这段时间内都无法成功发送到从库上，则MySQL自动调整复制为异步模式，事务正常返回提交结果给客户端。&lt;/p&gt;
&lt;p&gt;半同步复制很大程度上取决于主从库之间的网络情况，往返时延RTT越小决定了从库的实时性越好。通俗地说，主从库之间的网络越快，从库约实时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：往返时延RTT(Round-Trip Time)在计算机网络中是一个重要的性能指标，它表示从发送端发送数据开始到发送端接收到接收端的确认，总共经历的时长(这里可能有点拗口，我们可以理解为三次握手的前两次握手)。&lt;/p&gt;
&lt;p&gt;转载请注明原文链接：&lt;a href=&quot;https://www.cnblogs.com/itbsl/p/13507401.html&quot;&gt;https://www.cnblogs.com/itbsl/p/13507401.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果该文章对您有帮助，请您点击&lt;strong&gt;推荐&lt;/strong&gt;，感谢。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 14 Aug 2020 23:31:00 +0000</pubDate>
<dc:creator>itbsl</dc:creator>
<og:description>异步复制 MySQL的复制默认是异步的，主从复制至少需要两个MYSQL服务，这些MySQL服务可以分布在不同的服务器上，也可以在同一台服务器上。 MySQL主从异步复制是最常见的复制场景。数据的完整性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itbsl/p/13507401.html</dc:identifier>
</item>
<item>
<title>设计模式之解释器模式 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/interpreter-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/interpreter-pattern.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;解释器模式，给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。&lt;/p&gt;
&lt;p&gt;这和解释型编程语言的解释器有点类似，要根据一段输入转换成一段输出，将不易读的文本转换为易读的文本，将机器不能识别的输入转成二进制机器可读的输出&lt;/p&gt;
&lt;p&gt;当有一个语言需要解释执行，并且你可以将该语言中的句子表示为一个抽象语法树时，可以使用解释器模式。&lt;/p&gt;
&lt;h2 id=&quot;prototype&quot;&gt;Prototype&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Context: 解释器上下文&lt;/li&gt;
&lt;li&gt;AbstractExpression: 解释表达式抽象，定义解释操作&lt;/li&gt;
&lt;li&gt;ConcreteExpression: 解释表达式实现类，实现具体的解释逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Context
{
    public string Input { get; set; }
    public string Output { get; set; }
}

public abstract class AbstractExpression
{
    public abstract void Interpret(Context context);
}
public class TerminalExpression : AbstractExpression
{
    public override void Interpret(Context context)
    {
        Console.WriteLine(&quot;TerminalExpressionInterpreter&quot;);
    }
}
public class NoneTerminalExpression : AbstractExpression
{
    public override void Interpret(Context context)
    {
        Console.WriteLine(&quot;NonTerminalExpressionInterpreter&quot;);
    }
}


var context = new Context();
ICollection&amp;lt;AbstractExpression&amp;gt; expressions = new List&amp;lt;AbstractExpression&amp;gt;();

expressions.Add(new TerminalExpression());
expressions.Add(new TerminalExpression());
expressions.Add(new NoneTerminalExpression());

foreach (var expression in expressions)
{
    expression.Interpret(context);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。&lt;/p&gt;
&lt;p&gt;要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。&lt;/p&gt;
&lt;p&gt;解释器模式的代码实现比较灵活，没有固定的模板。&lt;/p&gt;
&lt;p&gt;应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。&lt;/p&gt;
&lt;p&gt;一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。&lt;/p&gt;
&lt;p&gt;解释器模式可能小众，只在一些特定的领域或情境下会被用到，比如编译器、规则引擎、正则表达式等。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 14 Aug 2020 23:17:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>解释器模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/interpreter-pattern.html</dc:identifier>
</item>
<item>
<title>CSS动画实例：跳跃的字符 - aTeacher</title>
<link>http://www.cnblogs.com/cs-whut/p/13507388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-whut/p/13507388.html</guid>
<description>&lt;h3&gt;1．翻转的字符&lt;/h3&gt;
&lt;p&gt;      在页面中放置一个类名为container的层作为容器，在该层中放置5个字符区域，HTML代码描述如下：&lt;/p&gt;
&lt;p&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;span&amp;gt;H&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;span&amp;gt;E&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;span&amp;gt;L&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;span&amp;gt;L&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;    &amp;lt;span&amp;gt;O&amp;lt;/span&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;      为container和span定义CSS样式规则，并定义实现5个字符翻转的动画关键帧。完整的HTML文件内容如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('b5326d61-d865-4368-aa5b-2e4bd4e7ba9b')&quot; readability=&quot;34.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_b5326d61-d865-4368-aa5b-2e4bd4e7ba9b&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_b5326d61-d865-4368-aa5b-2e4bd4e7ba9b&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b5326d61-d865-4368-aa5b-2e4bd4e7ba9b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;字符翻转&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   .container
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 500px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 300px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;flex&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      align-items&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      justify-content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 4px solid rgba(255, 0, 0, 0.9)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#d8d8d8&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   .container&amp;gt;span
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 130px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    font-family&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &quot;Impact&quot;,sans-serif&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    animation&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;flip 2s infinite linear&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    transform-origin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;0 70%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    transform-style&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;preserve-3d&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   @keyframes flip
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    50%   { transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rotateX(360deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    100%  &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rotateX(360deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   }
   .container&amp;gt;span:nth-child(1n+0) 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
        color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;var(--color)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
        animation-delay&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; var(--delay)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0s;--color:#f00&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;H&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.4s;--color:#f0f&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;E&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.8s;--color:#ff0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;L&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:1.2s;--color:#0ff&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;L&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:1.6s;--color:#800080&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;O&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以呈现出如图1所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200815061441101-540772471.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1  字符绕X轴翻转&lt;/p&gt;
&lt;p&gt;      若将上面的关键帧设置中的两个属性值“rotateX”均改成“rotateY”，则呈现如图2所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200815061456901-1965272729.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2  字符绕Y轴翻转&lt;/p&gt;
&lt;p&gt;      若将上面的关键帧设置中的两个属性值“rotateX”均改成“rotateZ”，则呈现如图3所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200815061510710-1589716968.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3  字符绕Y轴翻转&lt;/p&gt;
&lt;h3&gt;2．跳跃的字符&lt;/h3&gt;
&lt;p&gt;      我们可以通过修改字符区span的top属性的属性值让字符上下移动，同时设置文本的阴影，形成字符的跳跃动画效果。&lt;/p&gt;
&lt;p&gt;      编写的完整HTML文件如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('aecad9bc-c532-4938-a5ff-895f8c39b987')&quot; readability=&quot;46.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_aecad9bc-c532-4938-a5ff-895f8c39b987&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_aecad9bc-c532-4938-a5ff-895f8c39b987&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_aecad9bc-c532-4938-a5ff-895f8c39b987&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;88&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE HTML&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;跳跃的字符&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   .container
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 600px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;flex&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      align-items&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      justify-content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 4px solid rgba(255, 0, 0, 0.9)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#f5f5f5&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   .container&amp;gt;span 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; bounce .3s ease infinite alternate&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      font-family&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &quot;Impact&quot;,sans-serif&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 80px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      text-shadow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 1px 0 #CCC,
                   0 2px 0 #CCC,
                   0 3px 0 #CCC,
                   0 4px 0 #CCC,
                   0 5px 0 #CCC,
                   0 6px 0 transparent,
                   0 7px 0 transparent,
                   0 8px 0 transparent,
                   0 9px 0 transparent,
                   0 10px 10px rgba(0, 0, 0, .4)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   .container&amp;gt;span:nth-child(1n+0) 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;var(--color)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-delay&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; var(--delay)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   @keyframes bounce 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      100% 
      {
         top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; -20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
         text-shadow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 1px 0 #CCC,
                      0 2px 0 #CCC,
                      0 3px 0 #CCC,
                      0 4px 0 #CCC,
                      0 5px 0 #CCC,
                      0 6px 0 #CCC,
                      0 7px 0 #CCC,
                      0 8px 0 #CCC,
                      0 9px 0 #CCC,
                      0 50px 25px rgba(0, 0, 0, .2)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
      &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0s;--color:#f00&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;H&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.1s;--color:#f0f&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;a&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.2s;--color:#ff0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;p&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.3s;--color:#0f0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;p&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.4s;--color:#0ff&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;y&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.5s;--color:#00f&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;N&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.6s;--color:#800080&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;e&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.7s;--color:#008080&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;w&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.8s;--color:#ff6347&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Y&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:0.9s;--color:#ee82ee&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;e&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:1.0s;--color:#8b4513&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;a&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span &lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;=&quot;--delay:1.1s;--color:#fa8072&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;r&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以呈现出如图4所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200815061545310-1759933058.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4  跳跃的字符&lt;/p&gt;
&lt;h3&gt;3．霓虹字符&lt;/h3&gt;
&lt;p&gt;      通过滤镜的方式让文字发光，形成霓虹文字效果。编写HTML文件内容如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3ce6acb5-11b6-431c-b62d-2b626ed80eaf')&quot; readability=&quot;37.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_3ce6acb5-11b6-431c-b62d-2b626ed80eaf&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_3ce6acb5-11b6-431c-b62d-2b626ed80eaf&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3ce6acb5-11b6-431c-b62d-2b626ed80eaf&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;霓虹字符&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
   .container
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 500px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 300px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; relative&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;flex&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      align-items&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      justify-content&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 4px solid rgba(255, 0, 0, 0.9)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;#000000&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      border-radius&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10%&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
    .container&amp;gt;span 
    &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      margin-right&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;  
      display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; inline-block&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      font-size&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 100px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt; 
      font-family&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; &quot;Impact&quot;,sans-serif&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;  
      color&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; white&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      text-shadow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #e60073, 0 0 40px #e60073, 0 0 50px #e60073, 0 0 60px #e60073, 0 0 70px #e60073&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-name&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; anim&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-timing-function&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; linear&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-direction&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; alternate-reverse&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-iteration-count&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; infinite&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   .container&amp;gt;span:nth-child(1) 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      animation-delay&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0.2s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-duration&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0.5s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   .container&amp;gt;span:nth-child(2) 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      animation-delay&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0.4s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-duration&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   .container&amp;gt;span:nth-child(3) 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      animation-delay&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0.6s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-duration&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1.5s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   .container&amp;gt;span:nth-child(4) 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      animation-delay&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0.8s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-duration&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 2s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .container&amp;gt;span:nth-child(5) 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      animation-delay&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
      animation-duration&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 2.5s&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
   &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   @keyframes anim 
   &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
      0% 
      {
         opacity&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; .1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
         background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
            filter&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hue-rotate(0deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
      &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      10% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 5px 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      20% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; -5px 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      30% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 15px 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      40% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; -5px 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      50% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; -25px 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      60% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; -50px 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      70% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 -20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      80% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; -60px -20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      81% &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt; background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
      100% 
      &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
         opacity&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
         background-position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 0 0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
         filter&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hue-rotate(360deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
      &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
   }
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;W&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;U&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;H&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;A&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;N&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;       在浏览器中打开包含这段HTML代码的html文件，可以呈现出如图5所示的动画效果。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202008/1485495-20200815061614367-1091714512.gif&quot; alt=&quot;&quot; width=&quot;407&quot; height=&quot;258&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5  霓虹文字&lt;/p&gt;
</description>
<pubDate>Fri, 14 Aug 2020 22:17:00 +0000</pubDate>
<dc:creator>aTeacher</dc:creator>
<og:description>1．翻转的字符 在页面中放置一个类名为container的层作为容器，在该层中放置5个字符区域，HTML代码描述如下： &amp;lt;div class=&amp;quot;container&amp;quot;&amp;gt;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-whut/p/13507388.html</dc:identifier>
</item>
<item>
<title>二叉搜索树 [四边形不等式优化区间dp] - Vocanda</title>
<link>http://www.cnblogs.com/Vocanda/p/13504578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Vocanda/p/13504578.html</guid>
<description>&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;有 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个结点，第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个结点的权值为 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 。&lt;/p&gt;
&lt;p&gt;你需要对它们进行一些操作并维护一些信息，因此，你需要对它们建立一棵二叉搜索树。在整个操作过程中，第i个点需要被操作 &lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt; 次，每次你需要从根结点一路走到第 &lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt; 个点，耗时为经过的结点数。最小化你的总耗时。&lt;/p&gt;
&lt;h2 id=&quot;输入格式&quot;&gt;输入格式&lt;/h2&gt;
&lt;p&gt;第一行一个整数 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; ，第二行 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 个整数 &lt;span class=&quot;math inline&quot;&gt;\(x_1\to x_n\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;输出格式&quot;&gt;输出格式&lt;/h2&gt;
&lt;p&gt;一行一个整数表示答案。&lt;/p&gt;
&lt;h2 id=&quot;样例&quot;&gt;样例&lt;/h2&gt;
&lt;h3 id=&quot;样例输入&quot;&gt;样例输入&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;5
8 2 1 4 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;样例输出&quot;&gt;样例输出&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;35
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数据范围与提示&quot;&gt;数据范围与提示&lt;/h2&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(10\%\)&lt;/span&gt; 的数据，&lt;span class=&quot;math inline&quot;&gt;\(n\leqslant 10\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(40\%\)&lt;/span&gt; 的数据，&lt;span class=&quot;math inline&quot;&gt;\(n\leqslant 300\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(70\%\)&lt;/span&gt; 的数据，&lt;span class=&quot;math inline&quot;&gt;\(n\leqslant 2000\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对于 &lt;span class=&quot;math inline&quot;&gt;\(100\%\)&lt;/span&gt; 的数据，&lt;span class=&quot;math inline&quot;&gt;\(n\leqslant 5000，1\leqslant x_i\leqslant 10^9\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;提示：二叉搜索树或者是一棵空树，或者是具有下列性质的二叉树：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别为二叉搜索树。&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;第一眼看上去发现自己不会建二叉排序树了，直接写暴力……，仔细想一想，二叉排序树的性质就是左子树都比根小，右子树都比根大，那么就可以把大区间 &lt;span class=&quot;math inline&quot;&gt;\([L,R]\)&lt;/span&gt; 通过根节点 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 分成两部分，然后这里就是一个几乎是裸的区间 &lt;span class=&quot;math inline&quot;&gt;\(dp\)&lt;/span&gt; 的板子了。&lt;/p&gt;
&lt;p&gt;在更新 &lt;span class=&quot;math inline&quot;&gt;\(f[i][j]\)&lt;/span&gt; 的时候，因为 &lt;span class=&quot;math inline&quot;&gt;\([i,j]\)&lt;/span&gt; 这一段之间的每个节点都要多经过一个节点，所以要加上整棵树的值，而这用前缀和就可以维护。完结！&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define re register
using namespace std;
#define ll long long
const int maxn = 5e3+10;
ll f[maxn][maxn];
int g[maxn][maxn];
ll sum[maxn];
int a[maxn];
inline ll read(){//快读
        ll s = 0,f = 1;
        char ch = getchar();
        while(!isdigit(ch)){if(ch == '-')f = -1;ch = getchar();}
        while(isdigit(ch)){s=s*10+ch-'0';ch = getchar();}
        return s * f;
}
int main(){
        freopen(&quot;D.in&quot;,&quot;r&quot;,stdin);
        freopen(&quot;D.out&quot;,&quot;w&quot;,stdout);
        ll n = read();
        for(re int i = 1;i&amp;lt;=n;++i){//预处理
                a[i] = read();
                f[i][i] = a[i];//记录值
                g[i][i] = i;//记录决策点（四边形不等式优化）
                sum[i] = sum[i-1] + a[i];//前缀和
        }
        //以下是区间dp
        for(re int l = n-1;l &amp;gt;= 1;--l){
                for(re int r = l+1;r &amp;lt;= n;++r){
                        f[l][r] = 0x3f3f3f3f3f3f3f3f;//初始化极大值
                        for(int k=g[l][r-1];k&amp;lt;=g[l+1][r];++k){
                                if(f[l][r] &amp;gt; f[l][k-1] + f[k+1][r] + sum[r]-sum[l-1]){
                                        f[l][r] = f[l][k-1] + f[k+1][r] + sum[r]-sum[l-1];//向上更新答案
                                        g[l][r] = k;//记录决策点
                                }
                        }
                }
        }
        printf(&quot;%lld\n&quot;,f[1][n]);//输出最后的答案
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 14 Aug 2020 21:55:00 +0000</pubDate>
<dc:creator>Vocanda</dc:creator>
<og:description>二叉搜索树 [四边形不等式优化区间dp] 题目描述 有 \(n\) 个结点，第 \(i\) 个结点的权值为 \(i\) 。 你需要对它们进行一些操作并维护一些信息，因此，你需要对它们建立一棵二叉搜索树</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Vocanda/p/13504578.html</dc:identifier>
</item>
<item>
<title>go语言gRPC系列(二) - 为gRPC添加证书 - 宝树呐</title>
<link>http://www.cnblogs.com/baoshu/p/13507260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baoshu/p/13507260.html</guid>
<description>&lt;h2 id=&quot;1-前言&quot;&gt;&lt;span id=&quot;head1&quot;&gt;1. 前言&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;前情回顾&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/baoshu/p/13488106.html&quot;&gt;go语言gRPC系列(一) - gRPC入门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前我们演示的客户端和服务端之间是没有使用证书的，不是很安全。下面演示一下，服务调用之间加入自签的证书验证。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;生产环境以网上购买的证书为准&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-生成自签证书&quot;&gt;&lt;span id=&quot;head2&quot;&gt;2. 生成自签证书&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;21-mac生成自签证书的教程链接&quot;&gt;&lt;span id=&quot;head3&quot;&gt;2.1 MAC生成自签证书的教程链接:&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/4cdd29ce424d&quot;&gt;https://www.jianshu.com/p/4cdd29ce424d&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;22-windows生成自签证书的教程&quot;&gt;&lt;span id=&quot;head4&quot;&gt;2.2 Windows生成自签证书的教程&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;登录如下链接&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://slproweb.com/products/Win32OpenSSL.html&quot;&gt;http://slproweb.com/products/Win32OpenSSL.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;下载如下的openssl工具&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200814233140.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;安装到某个目录&lt;/li&gt;
&lt;li&gt;进入安装目录的bin文件夹下&lt;/li&gt;
&lt;li&gt;在所在的文件夹打开cmd,并输入&lt;code&gt;openssl&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200814235229.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;然后再执行如下的操作, 生成私钥文件&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;会生成一个&lt;code&gt;server.key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;genrsa -des3 -out server.key 2048
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200814235804.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;创建证书请求&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;会生成一个&lt;code&gt;server.csr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;genrsa -des3 -out server.key 2048
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200815000400.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;为了演示简单，删除私钥中的密码&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;会生成一个&lt;code&gt;server_no_password.key&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;rsa -in server.key -out server_no_password.key
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200815000657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;生成公钥文件&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;会生成&lt;code&gt;server.crt&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;x509 -req -days 365 -in server.csr -signkey server_no_password.key -out server.crt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200815000942.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;3-改造服务端使用自签证书&quot;&gt;&lt;span id=&quot;head5&quot;&gt;3. 改造服务端使用自签证书&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;31-复制证书至代码下&quot;&gt;&lt;span id=&quot;head6&quot;&gt;3.1 复制证书至代码下&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在服务端的目录下新建一个keys文件夹，并且上之前生成的&lt;code&gt;server_no_password.key&lt;/code&gt;和&lt;code&gt;server.crt&lt;/code&gt;复制到目录下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200815002727.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-改造代码添加证书认证&quot;&gt;&lt;span id=&quot;head7&quot;&gt;3.2 改造代码添加证书认证&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;改造之前上一节的服务端代码，具体改造的部分如下标红的部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200815002915.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的服务端代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;gomicro-quickstart/grpc_server/service&quot;
        &quot;google.golang.org/grpc&quot;
        &quot;google.golang.org/grpc/credentials&quot;
        &quot;log&quot;
        &quot;net&quot;
)

func main() {
// 1. 引用证书
tls, err := credentials.NewServerTLSFromFile(&quot;grpc_server/keys/server.crt&quot;, &quot;grpc_server/keys/server_no_password.key&quot;)
if err != nil {
        log.Fatal(&quot;服务端获取证书失败: &quot;, err)
}

// 2. new一个grpc的server，并且加入证书
rpcServer := grpc.NewServer(grpc.Creds(tls))

// 3. 将刚刚我们新建的ProdService注册进去
service.RegisterProdServiceServer(rpcServer, new(service.ProdService))

// 4. 新建一个listener，以tcp方式监听8082端口
listener, err := net.Listen(&quot;tcp&quot;, &quot;:8082&quot;)
if err != nil {
        log.Fatal(&quot;服务监听端口失败&quot;, err)
}

// 5. 运行rpcServer，传入listener
_ = rpcServer.Serve(listener)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;31-运行代码并查看客户端的访问错误&quot;&gt;&lt;span id=&quot;head8&quot;&gt;3.1 运行代码并查看客户端的访问错误&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;运行&lt;code&gt;server&lt;/code&gt;服务端&lt;/p&gt;
&lt;p&gt;这时候我们同样运行起来&lt;code&gt;client&lt;/code&gt;，发现会报如下的错，因为我们的服务端使用证书加密了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200815002334.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-改造客户端代码单向认证&quot;&gt;&lt;span id=&quot;head9&quot;&gt;4. 改造客户端代码(单向认证)&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;41-复制公钥给客户端&quot;&gt;&lt;span id=&quot;head10&quot;&gt;4.1 复制公钥给客户端&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;这里为了刚入门演示方便，采用了单向认证。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在客户端代码下新建keys文件夹&lt;/li&gt;
&lt;li&gt;将server.crt复制到keys文件夹下&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200815003547.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;42-改造客户端代码&quot;&gt;&lt;span id=&quot;head11&quot;&gt;4.2 改造客户端代码&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;较上一章的代码的改动如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200815005304.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的客户端代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;context&quot;
        &quot;fmt&quot;
        &quot;gomicro-quickstart/grpc_client/service&quot;
        &quot;google.golang.org/grpc&quot;
        &quot;google.golang.org/grpc/credentials&quot;
        &quot;log&quot;
)

func main() {
        // 1. 添加公钥证书的引用， codepie.fun是之前生成证书的时候填写的common name
        tls, err := credentials.NewClientTLSFromFile(&quot;grpc_client/keys/server.crt&quot;, &quot;codepie.fun&quot;)

        if err != nil {
                log.Fatal(&quot;客户端获取证书失败: &quot;, err)
        }

        // 2. 新建连接，端口是服务端开放的8082端口
        conn, err := grpc.Dial(&quot;:8082&quot;, grpc.WithTransportCredentials(tls))
        if err != nil {
                log.Fatal(err)
        }

        // 退出时关闭链接
        defer conn.Close()

        // 3. 调用Product.pb.go中的NewProdServiceClient方法
        productServiceClient := service.NewProdServiceClient(conn)

        // 4. 直接像调用本地方法一样调用GetProductStock方法
        resp, err := productServiceClient.GetProductStock(context.Background(), &amp;amp;service.ProductRequest{ProdId: 233})
        if err != nil {
                log.Fatal(&quot;调用gRPC方法错误: &quot;, err)
        }

        fmt.Println(&quot;调用gRPC方法成功，ProdStock = &quot;, resp.ProdStock)
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;43-运行客户端查看结果&quot;&gt;&lt;span id=&quot;head12&quot;&gt;4.3 运行客户端查看结果&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;单向认证成功，服务调用成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pic.codepie.fun/picgo/20200815005436.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Aug 2020 17:02:00 +0000</pubDate>
<dc:creator>宝树呐</dc:creator>
<og:description>1. 前言 2. 生成自签证书 2.1 MAC生成自签证书的教程链接: 2.2 Windows生成自签证书的教程 3. 改造服务端使用自签证书 3.1 复制证书至代码下 3.2 改造代码添加证书认证</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/baoshu/p/13507260.html</dc:identifier>
</item>
<item>
<title>构建高性能队列，你不得不知道的底层知识！ - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/13507206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/13507206.html</guid>
<description>&lt;blockquote readability=&quot;4.0625&quot;&gt;
&lt;p&gt;本文收录于专辑：&lt;a href=&quot;http://dwz.win/HjK&quot;&gt;http://dwz.win/HjK&lt;/a&gt;，点击解锁更多数据结构与算法的知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你好，我是彤哥。&lt;/p&gt;
&lt;p&gt;上一节，我们一起学习了如何将递归改写为非递归，其中，用到的数据结构主要是栈。&lt;/p&gt;
&lt;p&gt;栈和队列，可以说是除了数组和链表之外最基础的数据结构了，在很多场景中都有用到，后面我们也会陆陆续续的看到。&lt;/p&gt;
&lt;p&gt;今天，我想介绍一下，在Java中，如何构建一个高性能的队列，以及我们需要掌握的底层知识。&lt;/p&gt;
&lt;p&gt;学习其他语言的同学，也可以看看，在你的语言中，是如何构建高性能队列的。&lt;/p&gt;

&lt;p&gt;队列，是一种先进先出（First In First Out，FIFO）的数据结构，类似于实际生活场景中的排队，先到的人先得。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003343497-1055162834.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用数组和链表实现简单的队列，我们前面都介绍过了，这里就不再赘述了，有兴趣的同学可以点击以下链接查看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2ODA0ODM0Nw==&amp;amp;mid=2247484609&amp;amp;idx=1&amp;amp;sn=63038ee772f3959c51cae7b2e22bebd8&amp;amp;chksm=ceb30875f9c4816323cf95f5ee19de613bfd1c5ba58bdd3f9d451b0fcef3f945c55f9c42ec11&amp;amp;token=1022961976&amp;amp;lang=zh_CN#rd&quot;&gt;重温四大基础数据结构：数组、链表、队列和栈&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;今天我们主要来学习如何实现高性能的队列。&lt;/p&gt;
&lt;p&gt;说起高性能的队列，当然是说在高并发环境下也能够工作得很好的队列，这里的很好主要是指两个方面：并发安全、性能好。&lt;/p&gt;

&lt;p&gt;在Java中，默认地，也自带了一些并发安全的队列：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;队列&lt;/th&gt;
&lt;th&gt;有界性&lt;/th&gt;
&lt;th&gt;锁&lt;/th&gt;
&lt;th&gt;数据结构&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ArrayBlockingQueue&lt;/td&gt;
&lt;td&gt;有界&lt;/td&gt;
&lt;td&gt;加锁&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LinkedBlockingQueue&lt;/td&gt;
&lt;td&gt;可选有界&lt;/td&gt;
&lt;td&gt;加锁&lt;/td&gt;
&lt;td&gt;链表&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ConcurrentLinkedQueue&lt;/td&gt;
&lt;td&gt;无界&lt;/td&gt;
&lt;td&gt;无锁&lt;/td&gt;
&lt;td&gt;链表&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SynchronousQueue&lt;/td&gt;
&lt;td&gt;无界&lt;/td&gt;
&lt;td&gt;无锁&lt;/td&gt;
&lt;td&gt;队列或栈&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;LinkedTransferQueue&lt;/td&gt;
&lt;td&gt;无界&lt;/td&gt;
&lt;td&gt;无锁&lt;/td&gt;
&lt;td&gt;链表&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;s&gt;PriorityBlockingQueue&lt;/s&gt;&lt;/td&gt;
&lt;td&gt;无界&lt;/td&gt;
&lt;td&gt;加锁&lt;/td&gt;
&lt;td&gt;堆&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;s&gt;DelayQueue&lt;/s&gt;&lt;/td&gt;
&lt;td&gt;无界&lt;/td&gt;
&lt;td&gt;加锁&lt;/td&gt;
&lt;td&gt;堆&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;2.7272727272727&quot;&gt;
&lt;p&gt;这些队列的源码解析快捷入口：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODA0ODM0Nw==&amp;amp;mid=2247484111&amp;amp;idx=5&amp;amp;sn=00458d141ba1dbfa6cc8ec4933e084db&amp;amp;chksm=ceb30e7bf9c4876d343cabd85a7fa1cd7c99245ee64e06648c49509fe62b8b78d2172b5c10ef&amp;amp;scene=158#rd&quot;&gt;死磕 Java并发集合之终结篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结起来，实现并发安全队列的数据结构主要有：数组、链表和堆，堆主要用于实现优先级队列，不具备通用性，暂且不讨论。&lt;/p&gt;
&lt;p&gt;从有界性来看，只有ArrayBlockingQueue和LinkedBlockingQueue可以实现有界队列，其它的都是无界队列。&lt;/p&gt;
&lt;p&gt;从加锁来看，ArrayBlockingQueue和LinkedBlockingQueue都采用了加锁的方式，其它的都是采用的CAS这种无锁的技术实现的。&lt;/p&gt;
&lt;p&gt;从安全性的角度来说，我们一般都要选择有界队列，防止生产者速度过快导致内存溢出。&lt;/p&gt;
&lt;p&gt;从性能的角度来说，我们一般要考虑无锁的方式，减少线程上下文切换带来的性能损耗。&lt;/p&gt;
&lt;p&gt;从JVM的角度来说，我们一般选择数组的实现方式，因为链表会频繁的增删节点，导致频繁的垃圾回收，这也是一种性能损耗。&lt;/p&gt;
&lt;p&gt;所以，最佳的选择就是：数组 + 有界 + 无锁。&lt;/p&gt;
&lt;p&gt;而JDK并没有提供这样的队列，因此，很多开源框架都自己实现了高性能的队列，比如Disruptor，以及Netty中使用的jctools。&lt;/p&gt;

&lt;p&gt;我们这里不讨论具体的某一个框架，只介绍实现高性能队列的通用技术，并自己实现一个。&lt;/p&gt;
&lt;h2 id=&quot;环形数组&quot;&gt;环形数组&lt;/h2&gt;
&lt;p&gt;通过上面的讨论，我们知道实现高性能队列使用的数据结构只能是数组，而数组实现队列，必然要使用到环形数组。&lt;/p&gt;
&lt;p&gt;环形数组，一般通过设置两个指针实现：putIndex和takeIndex，或者叫writeIndex和readIndex，一个用于写，一个用于读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003343745-742031525.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当写指针到达数组尾端时，会从头开始，当然，不能越过读指针，同理，读指针到达数组尾端时，也会从头开始，当然，不能读取未写入的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003343982-263413818.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而为了防止写指针和读指针重叠的时候，无法分清队列到底是满了还是空的状态，一般会再添加一个size字段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003344172-362460191.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003344385-1180975488.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，使用环形数组实现队列的数据结构一般为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ArrayQueue&amp;lt;T&amp;gt; {
    private T[] array;
    private long wrtieIndex;
    private long readIndex;
    private long size;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在单线程的情况下，这样不会有任何问题，但是，在多线程环境中，这样会带来严重的伪共享问题。&lt;/p&gt;
&lt;h2 id=&quot;伪共享&quot;&gt;伪共享&lt;/h2&gt;
&lt;h3 id=&quot;什么是共享？&quot;&gt;什么是共享？&lt;/h3&gt;
&lt;p&gt;在计算机中，有很多存储单元，我们接触最多的就是内存，又叫做主内存，此外，CPU还有三级缓存：L1、L2、L3，L1最贴近CPU，当然，它的存储空间也很小，L2比L1稍大一些，L3最大，可以同时缓存多个核心的数据。CPU取数据的时候，先从L1缓存中读取，如果没有再从L2缓存中读取，如果没有再从L3中读取，如果三级缓存都没有，最后会从内存中读取。离CPU核心越远，则相对的耗时就越长，所以，如果要做一些很频繁的操作，要尽量保证数据缓存在L1中，这样能极大地提高性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003344638-944106468.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;缓存行&quot;&gt;缓存行&lt;/h3&gt;
&lt;p&gt;而数据在三级缓存中，也不是说来一个数据缓存一下，而是一次缓存一批数据，这一批数据又称作缓存行（Cache Line），通常为64字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003344851-1540760935.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每一次，当CPU去内存中拿数据的时候，都会把它后面的数据一并拿过来（组成64字节），我们以long型数组为例，当CPU取数组中一个long的时候，同时会把后续的7个long一起取到缓存行中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003345080-1573654864.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这在一定程度上能够加快数据的处理，因为，此时在处理下标为0的数据，下一个时刻可能就要处理下标为1的数据了，直接从缓存中取要快很多。&lt;/p&gt;
&lt;p&gt;但是，这样又带来了一个新的问题——伪共享。&lt;/p&gt;
&lt;h3 id=&quot;伪共享-2&quot;&gt;伪共享&lt;/h3&gt;
&lt;p&gt;试想一下，两个线程（CPU）同时在处理这个数组中的数据，两个CPU都缓存了，一个CPU在对array[0]的数据加1，另一个CPU在对array[1]的数据加1，那么，回写到主内存的时候，到底以哪个缓存行的数据为准（写回主内存的时候也是以缓存行的形式写回），所以，此时，就需要对这两个缓存行“加锁”了，一个CPU先修改数据，写回主内存，另一个CPU才能读取数据并修改数据，再写回主内存，这样势必会带来性能的损耗，出现的这种现象就叫做&lt;strong&gt;伪共享&lt;/strong&gt;，这种“加锁”的方式叫做内存屏障，关于内存屏障的知识我们就不展开叙述了。&lt;/p&gt;
&lt;p&gt;那么，怎么解决伪共享带来的问题呢？&lt;/p&gt;
&lt;p&gt;以环形数组实现的队列为例，writeIndex、readIndex、size现在是这样处理的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003345376-506497583.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，我们只需要在writeIndex和readIndex之间加7个long就可以把它们隔离开，同理，readIndex和size之间也是一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1648938/202008/1648938-20200815003345593-2147117625.jpg&quot; alt=&quot;file&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样就消除了writeIndex和readIndex之间的伪共享问题，因为writeIndex和readIndex肯定是在两个不同的线程中更新，所以，消除伪共享之后带来的性能提升是很明显的。&lt;/p&gt;
&lt;p&gt;假如有多个生产者，writeIndex是肯定会被争用的，此时，要怎么友好地修改writeIndex呢？即一个生产者线程修改了writeIndex，另一个生产者线程要立马可见。&lt;/p&gt;
&lt;p&gt;你第一时间想到的肯定是&lt;code&gt;volatile&lt;/code&gt;，没错，可是光volatile还不行哦，volatile只能保证可见性和有序性，不能保证原子性，所以，还需要加上原子指令CAS，CAS是谁提供的？原子类AtomicInteger和AtomicLong都具有CAS的功能，那我们直接使用他们吗？肯定不是，仔细观察，发现他们最终都是调用Unsafe实现的。&lt;/p&gt;
&lt;p&gt;OK，下面就轮到最牛逼的底层杀手登场了——Unsafe。&lt;/p&gt;
&lt;h3 id=&quot;unsafe&quot;&gt;Unsafe&lt;/h3&gt;
&lt;p&gt;Unsafe不仅提供了CAS的指令，还提供很多其它操作底层的方法，比如操作直接内存、修改私有变量的值、实例化一个类、阻塞/唤醒线程、带有内存屏障的方法等。&lt;/p&gt;
&lt;blockquote readability=&quot;2.6351351351351&quot;&gt;
&lt;p&gt;关于Unsafe，可以看这篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODA0ODM0Nw==&amp;amp;mid=2247483866&amp;amp;idx=1&amp;amp;sn=941ef04260f8afea009761f108726211&amp;amp;chksm=ceb30d6ef9c4847827b45366bbfe69c3676edb3c3a7991cebf4b2814c3452d592f28732dfaf8&amp;amp;token=692301514&amp;amp;lang=zh_CN#rd&quot;&gt;死磕 java魔法类之Unsafe解析&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，构建高性能队列，主要使用的是Unsafe的CAS指令以及带有内存屏障的方法等：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 原子指令
public final native boolean compareAndSwapLong(Object var1, long var2, long var4, long var6);
// 以volatile的形式获取值，相当于给变量加了volatile关键字
public native long getLongVolatile(Object var1, long var2);
// 延迟更新，对变量的修改不会立即写回到主内存，也就是说，另一个线程不会立即可见
public native void putOrderedLong(Object var1, long var2, long var4);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，底层知识介绍的差不多了，是时候展现真正的技术了——手写高性能队列。&lt;/p&gt;

&lt;p&gt;我们假设这样一种场景：有多个生产者（Multiple Producer），却只有一个消费者（Single Consumer），这是Netty中的经典场景，这样一种队列该怎么实现？&lt;/p&gt;
&lt;p&gt;直接上代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 多生产者单消费者队列
 *
 * @param &amp;lt;T&amp;gt;
 */
public class MpscArrayQueue&amp;lt;T&amp;gt; {

    long p01, p02, p03, p04, p05, p06, p07;
    // 存放元素的地方
    private T[] array;
    long p1, p2, p3, p4, p5, p6, p7;
    // 写指针，多个生产者，所以声明为volatile
    private volatile long writeIndex;
    long p11, p12, p13, p14, p15, p16, p17;
    // 读指针，只有一个消费者，所以不用声明为volatile
    private long readIndex;
    long p21, p22, p23, p24, p25, p26, p27;
    // 元素个数，生产者和消费者都可能修改，所以声明为volatile
    private volatile long size;
    long p31, p32, p33, p34, p35, p36, p37;

    // Unsafe变量
    private static final Unsafe UNSAFE;
    // 数组基础偏移量
    private static final long ARRAY_BASE_OFFSET;
    // 数组元素偏移量
    private static final long ARRAY_ELEMENT_SHIFT;
    // writeIndex的偏移量
    private static final long WRITE_INDEX_OFFSET;
    // readIndex的偏移量
    private static final long READ_INDEX_OFFSET;
    // size的偏移量
    private static final long SIZE_OFFSET;

    static {
        Field f = null;
        try {
            // 获取Unsafe的实例
            f = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);
            f.setAccessible(true);
            UNSAFE = (Unsafe) f.get(null);

            // 计算数组基础偏移量
            ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(Object[].class);
            // 计算数组中元素偏移量
            // 简单点理解，64位系统中有压缩指针占用4个字节，没有压缩指针占用8个字节
            int scale = UNSAFE.arrayIndexScale(Object[].class);
            if (4 == scale) {
                ARRAY_ELEMENT_SHIFT = 2;
            } else if (8 == scale) {
                ARRAY_ELEMENT_SHIFT = 3;
            } else {
                throw new IllegalStateException(&quot;未知指针的大小&quot;);
            }

            // 计算writeIndex的偏移量
            WRITE_INDEX_OFFSET = UNSAFE
                    .objectFieldOffset(MpscArrayQueue.class.getDeclaredField(&quot;writeIndex&quot;));
            // 计算readIndex的偏移量
            READ_INDEX_OFFSET = UNSAFE
                    .objectFieldOffset(MpscArrayQueue.class.getDeclaredField(&quot;readIndex&quot;));
            // 计算size的偏移量
            SIZE_OFFSET = UNSAFE
                    .objectFieldOffset(MpscArrayQueue.class.getDeclaredField(&quot;size&quot;));
        } catch (Exception e) {
            throw new RuntimeException();
        }
    }

    // 构造方法
    public MpscArrayQueue(int capacity) {
        // 取整到2的N次方（未考虑越界）
        capacity = 1 &amp;lt;&amp;lt; (32 - Integer.numberOfLeadingZeros(capacity - 1));
        // 实例化数组
        this.array = (T[]) new Object[capacity];
    }

    // 生产元素
    public boolean put(T t) {
        if (t == null) {
            return false;
        }
        long size;
        long writeIndex;
        do {
            // 每次循环都重新获取size的大小
            size = this.size;
            // 队列满了直接返回
            if (size &amp;gt;= this.array.length) {
                return false;
            }

            // 每次循环都重新获取writeIndex的值
            writeIndex = this.writeIndex;

            // while循环中原子更新writeIndex的值
            // 如果失败了重新走上面的过程
        } while (!UNSAFE.compareAndSwapLong(this, WRITE_INDEX_OFFSET, writeIndex, writeIndex + 1));

        // 到这里，说明上述原子更新成功了
        // 那么，就把元素的值放到writeIndex的位置
        // 且更新size
        long eleOffset = calcElementOffset(writeIndex, this.array.length-1);
        // 延迟更新到主内存，读取的时候才更新
        UNSAFE.putOrderedObject(this.array, eleOffset, t);

        // 往死里更新直到成功
        do {
            size = this.size;
        } while (!UNSAFE.compareAndSwapLong(this, SIZE_OFFSET, size, size + 1));

        return true;
    }

    // 消费元素
    public T take() {
        long size = this.size;
        // 如果size为0，表示队列为空，直接返回
        if (size &amp;lt;= 0) {
            return null;
        }
        // size大于0，肯定有值
        // 只有一个消费者，不用考虑线程安全的问题
        long readIndex = this.readIndex;
        // 计算读指针处元素的偏移量
        long offset = calcElementOffset(readIndex, this.array.length-1);
            // 获取读指针处的元素，使用volatile语法，强制更新生产者的数据到主内存
        T e = (T) UNSAFE.getObjectVolatile(this.array, offset);

        // 增加读指针
        UNSAFE.putOrderedLong(this, READ_INDEX_OFFSET, readIndex+1);
        // 减小size
        do {
            size = this.size;
        } while (!UNSAFE.compareAndSwapLong(this, SIZE_OFFSET, size, size-1));

        return e;
    }

    private long calcElementOffset(long index, long mask) {
        // index &amp;amp; mask 相当于取余数，表示index到达数组尾端了从头开始
        return ARRAY_BASE_OFFSET + ((index &amp;amp; mask) &amp;lt;&amp;lt; ARRAY_ELEMENT_SHIFT);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是看不懂？那就对了，多看几遍吧，面试又能吹一波了。&lt;/p&gt;
&lt;p&gt;这里使用的是每两个变量之间加7个long类型的变量来消除伪共享，有的开源框架你可能会看到通过继承的方式实现的，还有的是加15个long类型，另外，JDK8中也提供了一个注解&lt;code&gt;@Contended&lt;/code&gt;来消除伪共享。&lt;/p&gt;
&lt;p&gt;本例其实还有优化的空间，比如，size的使用，能不能不使用size？不使用size又该如何实现？&lt;/p&gt;

&lt;p&gt;本节，我们一起学习了在Java中如何构建高性能的队列，并学习了一些底层的知识，毫不夸张地讲，学会了这些底层知识，面试的时候光队列就能跟面试官吹一个小时。&lt;/p&gt;
&lt;p&gt;另外，最近收到一些同学的反馈，说哈希、哈希表、哈希函数他们之间有关系吗？有怎样的关系？为什么Object中要放一个hash()方法？跟equals()方法怎么又扯上关系了呢？&lt;/p&gt;
&lt;p&gt;下一节，我们就来看看关于哈希的一切，想及时获取最新推文吗？还不快点来关注我！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关注公号主“彤哥读源码”，解锁更多源码、基础、架构知识。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 14 Aug 2020 16:34:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>前言 本文收录于专辑：http://dwz.win/HjK，点击解锁更多数据结构与算法的知识。 你好，我是彤哥。 上一节，我们一起学习了如何将递归改写为非递归，其中，用到的数据结构主要是栈。 栈和队列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tong-yuan/p/13507206.html</dc:identifier>
</item>
<item>
<title>编写高质量代码的50条黄金守则-Day 02(首选readonly而不是const) - 比特飞</title>
<link>http://www.cnblogs.com/byteflying/p/13507076.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/byteflying/p/13507076.html</guid>
<description>&lt;p&gt;众所周知，.net 包含 2 种类型的常量，运行时常量和编译时常量，它们的表现行为不同，使用不当，会使你陷入困境。虽然编译时常量在执行上速度略快，但我依然强烈建议大家使用运行时常量（readonly），而不是编译时常量（const）。在继续深入了解之前，我们先要知道 .net 中两种常量各自的特点。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;149.99121996303&quot;&gt;
&lt;p&gt;编写高质量代码的50条黄金守则-Day 02(首选readonly而不是const)，本文由比特飞原创发布，转载务必在文章开头附带链接：&lt;a href=&quot;https://www.byteflying.com/archives/6549&quot; rel=&quot;nofollow&quot;&gt;https://www.byteflying.com/archives/6549&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该系列文章由比特飞原创发布，计划用半年时间写完全50篇文章，为大家提供编写高质量代码的一般准则。&lt;/p&gt;
&lt;h3&gt;1、概述&lt;/h3&gt;
&lt;p&gt;众所周知，.net 包含 2 种类型的常量，运行时常量和编译时常量，它们的表现行为不同，使用不当，会使你陷入困境。虽然编译时常量在执行上速度略快，但我依然强烈建议大家使用运行时常量（readonly），而不是编译时常量（const）。在继续深入了解之前，我们先要知道 .net 中两种常量各自的特点。&lt;/p&gt;
&lt;h3&gt;2、.net中两种常量的基本特点&lt;/h3&gt;
&lt;p&gt;我们看看以下代码片段：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cdn.jsdelivr.net/gh/byteflying/blogimage/image/2020-08-14-22-24-45.png&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2J5dGVmbHlpbmcvYmxvZ2ltYWdlL2ltYWdlLzIwMjAtMDgtMTQtMjItMjQtNDUucG5n?x-oss-process=image/format,png&quot; alt=&quot;编写高质量代码的50条黄金守则-Day 02(首选readonly而不是const)&quot; width=&quot;562&quot; height=&quot;298&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;两种常量的代码片段&lt;/p&gt;
&lt;p&gt;我们很容易总结出它们各自的特点：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、运行时常量 readonly 要么在定义的时候赋初始值，要么在构造函数中赋初始值；&lt;/p&gt;
&lt;p&gt;2、编译时常量 const 必须在定义的时候赋初始值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那我为什么建议大家使用运行时常量呢？因为编译时常量可能会使你已发行程序的表现的和你测试时不同，这是为什么呢？为了清楚的了解个中原委，我们要明白编译器为运行时常量和编译时常量都做了什么？&lt;/p&gt;
&lt;h3&gt;3、编译器为readonly和const关键字做了什么？&lt;/h3&gt;
&lt;p&gt;使用readonly修饰的常量为运行时常量，使用const修饰的常量为编译时常量，我们先来看两段示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ViewCount1 = &lt;span&gt;100&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ViewCount2 = &lt;span&gt;100&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们再来看一下两段代码的IL：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cdn.jsdelivr.net/gh/byteflying/blogimage/image/2020-08-13-22-43-27.png&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2J5dGVmbHlpbmcvYmxvZ2ltYWdlL2ltYWdlLzIwMjAtMDgtMTMtMjItNDMtMjcucG5n?x-oss-process=image/format,png&quot; alt=&quot;编写高质量代码的50条黄金守则-Day 02(首选readonly而不是const)&quot; width=&quot;995&quot; height=&quot;562&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 DnSpy 解密的 IL 1&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cdn.jsdelivr.net/gh/byteflying/blogimage/image/2020-08-13-22-43-38.png&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2J5dGVmbHlpbmcvYmxvZ2ltYWdlL2ltYWdlLzIwMjAtMDgtMTMtMjItNDMtMzgucG5n?x-oss-process=image/format,png&quot; alt=&quot;编写高质量代码的50条黄金守则-Day 02(首选readonly而不是const)&quot; width=&quot;970&quot; height=&quot;480&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 DnSpy 解密的 IL 2&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cdn.jsdelivr.net/gh/byteflying/blogimage/image/2020-08-13-22-33-41.png&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2J5dGVmbHlpbmcvYmxvZ2ltYWdlL2ltYWdlLzIwMjAtMDgtMTMtMjItMzMtNDEucG5n?x-oss-process=image/format,png&quot; alt=&quot;编写高质量代码的50条黄金守则-Day 02(首选readonly而不是const)&quot; width=&quot;724&quot; height=&quot;359&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DnSpy 的反编译结果&lt;/p&gt;
&lt;p&gt;从上面的反编译结果，可以明显的看出 const 为编译时常量，在编译期间已经被写到IL中。而 readonly 为运行时常量。Microsoft 技术支持文档中相关 IL 的解释也可以印证这一点。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cdn.jsdelivr.net/gh/byteflying/blogimage/image/2020-08-13-21-57-00.png&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2J5dGVmbHlpbmcvYmxvZ2ltYWdlL2ltYWdlLzIwMjAtMDgtMTMtMjEtNTctMDAucG5n?x-oss-process=image/format,png&quot; alt=&quot;编写高质量代码的50条黄金守则-Day 02(首选readonly而不是const)&quot; width=&quot;983&quot; height=&quot;904&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Microsoft 技术支持文档中 ldsfld 的解释&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cdn.jsdelivr.net/gh/byteflying/blogimage/image/2020-08-13-22-01-23.png&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2J5dGVmbHlpbmcvYmxvZ2ltYWdlL2ltYWdlLzIwMjAtMDgtMTMtMjItMDEtMjMucG5n?x-oss-process=image/format,png&quot; alt=&quot;编写高质量代码的50条黄金守则-Day 02(首选readonly而不是const)&quot; width=&quot;973&quot; height=&quot;864&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Microsoft 技术支持文档中 Ldc_I4_S 的解释&lt;/p&gt;
&lt;p&gt;当然，对于这个案例，输出的结果是一致的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cdn.jsdelivr.net/gh/byteflying/blogimage/image/2020-08-13-22-01-30.png&quot; rel=&quot;nofollow&quot;&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL2J5dGVmbHlpbmcvYmxvZ2ltYWdlL2ltYWdlLzIwMjAtMDgtMTMtMjItMDEtMzAucG5n?x-oss-process=image/format,png&quot; alt=&quot;编写高质量代码的50条黄金守则-Day 02(首选readonly而不是const)&quot; width=&quot;564&quot; height=&quot;756&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ViewCount1 和 ViewCount2 的输出结果&lt;/p&gt;
&lt;p&gt;于是，我们得到以下重要结论：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;1、const 和 readonly 在初始化一次后，不能再赋值；&lt;/p&gt;
&lt;p&gt;2、const 在编译时被编译器所替换，而 readonly 在编译时只做校验，不作替换处理，运行时表现如同一般变量。&lt;/p&gt;
&lt;p&gt;3、const 在 .net 中只能用于 数值型、字符型和 null，没有例外。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们再看一个简单的示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Birthday= &lt;span&gt;1986&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt;(DateTime.UtcNow.Year == &lt;span&gt;1986&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(DateTime.UtcNow.Year == Birthday)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由我们之前的分析可以得知，它们是完全相同的。然而，并不是所有的情况下，你都能得到你所期望的结果，这又是为什么呢？&lt;/p&gt;
&lt;h3&gt;4、运行时所给出的结果，并不是你所期望的结果&lt;/h3&gt;
&lt;p&gt;某些情况下，运行时给出的结果与你所期望的结果大相径庭。现在我们有以下场景，你有一个已交付的软件，软件包含一个可执行主程序 EffectiveCoding02.exe ，一个被主程序所引用的类库 EffectiveCoding02.dll，主程序中包含以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SomeClass{

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; StartValue = &lt;span&gt;100&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EndValue = &lt;span&gt;105&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类库中包含以下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = SomeClass.StartValue; i &amp;lt; SomeClass.EndValue; i++&lt;span&gt;){

console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;value = {i}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当初次交付程序给客户的时候，以上代码完全按照你的预期运行。后来由于软件迭代，你修改了主程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SomeClass{

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; StartValue = &lt;span&gt;110&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EndValue = &lt;span&gt;115&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重新编译后，因为你只更改了这个主程序，所以你将这个主程序交付给客户，然而你却得不到任何输出内容，程序没有按照你所预期的那样工作，于是你会说出那句开发人员的至理名言，“我这里是正常的啊！”。&lt;/p&gt;
&lt;p&gt;产生这个问题的原因在于，由于编译时常量 const 是在编译时被编译器所替换的，所以虽然你进行了编译操作，然而用户计算机中的类库由于没有被编译器重新编译，所以用户计算机中的类库中的 EndValue 还是上一次编译时的结果，即105。然而运行时常量却以正常的方式运作，所以它的值变成了110，自然，你得不到任何的输出结果。因为循环初始值大于结束值。&lt;/p&gt;
&lt;h3&gt;5、总结&lt;/h3&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;1、运行时常量 readonly 要么在定义的时候赋初始值，要么在构造函数中赋初始值；&lt;/p&gt;
&lt;p&gt;2、编译时常量 const 必须在定义的时候赋初始值；&lt;/p&gt;
&lt;p&gt;3、const 和 readonly 在初始化一次后，不能再赋值；&lt;/p&gt;
&lt;p&gt;4、const 在编译时被编译器所替换，而 readonly 在编译时只做校验，不作替换处理，运行时表现如同一般变量；&lt;/p&gt;
&lt;p&gt;5、const 在 .net 中只能用于 数值型、字符型和 null，没有例外；&lt;/p&gt;
&lt;p&gt;6、尽量使用 readonly 常量，避免遇到已发行软件无法按预期运行的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开发人员应牢记以上开发守则，否则，&lt;span&gt;人民群众会仇恨你，你的朋友和家人也会嘲笑你、唾弃你&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;该系列文章由比特飞原创发布，计划用半年时间写完全50篇文章，为大家提供编写高质量代码的一般准则。&lt;/p&gt;
&lt;blockquote readability=&quot;4.5144927536232&quot;&gt;
&lt;p&gt;本文由 &lt;span&gt;&lt;a href=&quot;https://www.byteflying.com/&quot; rel=&quot;nofollow&quot;&gt;比特飞&lt;/a&gt;&lt;/span&gt; 原创发布，欢迎大家踊跃转载。&lt;/p&gt;
&lt;p&gt;转载请注明本文地址：&lt;span&gt;&lt;a href=&quot;https://www.byteflying.com/archives/6549&quot; rel=&quot;nofollow&quot;&gt;https://www.byteflying.com/archives/6549&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 14 Aug 2020 15:43:00 +0000</pubDate>
<dc:creator>比特飞</dc:creator>
<og:description>众所周知，.net 包含 2 种类型的常量，运行时常量和编译时常量，它们的表现行为不同，使用不当，会使你陷入困境。虽然编译时常量在执行上速度略快，但我依然强烈建议大家使用运行时常量（readonly）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/byteflying/p/13507076.html</dc:identifier>
</item>
<item>
<title>LDA线性判别分析原理及python应用（葡萄酒案例分析） - Charzueus</title>
<link>http://www.cnblogs.com/chenzhenhong/p/13504526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenzhenhong/p/13504526.html</guid>
<description>&lt;p id=&quot;main-toc&quot;&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90%EF%BC%88LDA%EF%BC%89%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4%E5%8F%8A%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98-toc&quot;&gt;&lt;span&gt;线性判别分析（LDA）数据降维及案例实战&lt;/span&gt;&lt;/h3&gt;
&lt;p id=&quot;%E4%B8%80%E3%80%81LDA%E6%98%AF%E4%BB%80%E4%B9%88-toc&quot;&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chenzhenhong/p/13504526.html#l1&quot;&gt;一、LDA是什么&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%95%A3%E5%B8%83%E7%9F%A9%E9%98%B5-toc&quot;&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chenzhenhong/p/13504526.html#l2&quot;&gt;二、计算散布矩阵&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;%E4%B8%89%E3%80%81%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%BC%8F%E5%8F%8A%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9-toc&quot;&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chenzhenhong/p/13504526.html#l3&quot;&gt;三、线性判别式及特征选择&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;%E5%9B%9B%E3%80%81%E6%A0%B7%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4%E6%8A%95%E5%BD%B1-toc&quot;&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chenzhenhong/p/13504526.html#l4&quot;&gt;四、样本数据降维投影&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;%E4%BA%94%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc&quot;&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chenzhenhong/p/13504526.html#l5&quot;&gt;五、完整代码&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;%E7%BB%93%E8%AF%AD-toc&quot;&gt;&lt;span&gt;　　&lt;a href=&quot;https://www.cnblogs.com/chenzhenhong/p/13504526.html#l5&quot;&gt;结语&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;%E4%B8%80%E3%80%81LDA%E6%98%AF%E4%BB%80%E4%B9%88&quot;&gt;&lt;span&gt;一、LDA是什么&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;LDA概念及与PCA区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;LDA线性判别分析（Linear Discriminant Analysis）也是一种特征提取、数据压缩技术。在模型训练时候进行LDA数据处理可以提高计算效率以及避免过拟合。它是一种有监督学习算法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;与PCA主成分分析（Principal Component Analysis）相比，LDA是有监督数据压缩方法，而PCA是有监督数据压缩及特征提取方法。PCA目标是寻找数据集最大方差方向作为主成分，LDA目标是寻找和优化具有可分性特征子空间。其实两者各有优势，更深入详细的区分和应用等待之后的学习，这里我仍然以葡萄酒数据集分类为案例记录原理知识的学习和具体实现步骤。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对比我之前记录的PCA请看：&lt;a href=&quot;https://www.cnblogs.com/chenzhenhong/p/13472460.html&quot; target=&quot;_blank&quot;&gt;PCA数据降维原理及python应用（葡萄酒案例分析）&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;LDA内部逻辑实现步骤&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;&lt;span&gt;标准化d维数据集。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;计算每个类别的d维均值向量。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;计算跨类散布矩阵 &lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20S_%7BB%7D&quot; alt=&quot;\large S_{B}&quot; class=&quot;mathcode&quot;/&gt; 和类内散布矩阵 &lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20S_%7BW%7D&quot; alt=&quot;\large S_{W}&quot; class=&quot;mathcode&quot;/&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;线性判别式及特征计算。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;按特征值降序排列，与对应的特征向量成对排序。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;选择最具线性判别性的前k个特征，构建变换矩阵&lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20W_%7Bd%5Ctimes%20k%7D&quot; alt=&quot;\large W_{d\times k}&quot; class=&quot;mathcode&quot;/&gt;.&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过变换矩阵将原数据投影至k维子空间。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;%E4%BA%8C%E3%80%81%E8%AE%A1%E7%AE%97%E6%95%A3%E5%B8%83%E7%9F%A9%E9%98%B5&quot;&gt;&lt;span&gt;二、计算散布矩阵&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、数据集下载&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载葡萄酒数据集&lt;a href=&quot;https://download.csdn.net/download/Charzous/12702120&quot;&gt;wine.data&lt;/a&gt;到本地，或者到时在加载数据代码是从远程服务器获取，为了避免加载超时推荐下载本地数据集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载之后用记事本打开wine.data可见得，第一列为葡萄酒数据类别标签，共有3类，往后的13列为特征值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200814173359787.gif&quot; alt=&quot;&quot; width=&quot;549&quot; height=&quot;328&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据加载以及标准化数据处理与PCA技术一样，具体可以翻看&lt;a href=&quot;https://www.cnblogs.com/chenzhenhong/p/13472460.html&quot; target=&quot;_blank&quot;&gt;PCA数据降维原理及python应用（葡萄酒案例分析）&lt;/a&gt;，或者本文第五部分完整代码有具体实现代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、计算散布矩阵第一步，先计算每个类别每个样本的均值向量。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公式： &lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20m_%7Bi%7D%3D%5Cfrac%7B1%7D%7Bn_%7Bi%7D%7D%5Csum_%7Bx%20%5Cin%20D%7D%5E%7Bc%7Dx_%7Bm%7D&quot; alt=&quot;\large m_{i}=\frac{1}{n_{i}}\sum_{x \in D}^{c}x_{m}&quot; class=&quot;mathcode&quot;/&gt;, i =1,2,3 表示类别，每个特征取平均值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得到三个均值向量为： &lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20m_%7Bi%7D%3D%5Cbegin%7Bbmatrix%7D%20%5C%5C%20m_%7Bi%2C1%7D%20%5C%5C%20m_%7Bi%2C2%7D%20%5C%5C%20m_%7Bi%2C3%7D%20%5C%5C%20.%20%5C%5C%20.%20%5C%5C%20.%20%5C%5C%20%5C%5C%20m_%7Bi%2C13%7D%20%5Cend%7Bbmatrix%7D&quot; alt=&quot;\large m_{i}=\begin{bmatrix} \\ m_{i,1} \\ m_{i,2} \\ m_{i,3} \\ . \\ . \\ . \\ \\ m_{i,13} \end{bmatrix}&quot; class=&quot;mathcode&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算均值向量&lt;/span&gt;
np.set_printoptions(precision=4&lt;span&gt;)
mean_vecs &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; label &lt;span&gt;in&lt;/span&gt; range(1, 4&lt;span&gt;):
    mean_vecs.append(np.mean(x_train_std[y_train &lt;/span&gt;== label], axis=0))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;打印查看结果：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200814174958862.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJ6b3Vz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;925&quot; height=&quot;194&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、计算类内散布矩阵。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个样本 i 的散布矩阵：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20S_%7Bi%7D%3D%5Csum_%7Bx%5Cin%20D%7D%28x-m_i%29%28x-m_i%29%5E%7BT%7D&quot; alt=&quot;\large S_{i}=\sum_{x\in D}(x-m_i)(x-m_i)^{T}&quot; class=&quot;mathcode&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;类内散布矩阵即每个样本的累加：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20S_%7BW%7D%3D%5Csum_%7Bi%3D1%7D%5E%7B13%7DS_i&quot; alt=&quot;\large S_{W}=\sum_{i=1}^{13}S_i&quot; class=&quot;mathcode&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算类内散布矩阵&lt;/span&gt;
k = 13&lt;span&gt;
Sw &lt;/span&gt;=&lt;span&gt; np.zeros((k, k))
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; label, mv &lt;span&gt;in&lt;/span&gt; zip(range(1, 4&lt;span&gt;), mean_vecs):
    Si &lt;/span&gt;=&lt;span&gt; np.zeros((k, k))
    Si &lt;/span&gt;= np.cov(x_train_std[y_train ==&lt;span&gt; label].T)  
    Sw &lt;/span&gt;+=&lt;span&gt; Si
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;类内散布矩阵：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Sw.shape[0],&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Sw.shape[1])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;矩阵规模：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200814175737877.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;41&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、计算跨类散布矩阵。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公式：&lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20S_%7BB%7D%3D%5Csum_%7B1%7D%5E%7B13%7Dn_i%28m_i-m%29%28m_i-m%29%5E%7BT%7D&quot; alt=&quot;\large S_{B}=\sum_{1}^{13}n_i(m_i-m)(m_i-m)^{T}&quot; class=&quot;mathcode&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公式中，m是所有样本总均值向量，也就是不分类的情况下计算特征平均值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算跨类散布矩阵&lt;/span&gt;
mean_all = np.mean(x_train_std, axis=&lt;span&gt;0)
Sb &lt;/span&gt;=&lt;span&gt; np.zeros((k, k))
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i, col_mv &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(mean_vecs):
    n &lt;/span&gt;= x_train[y_train == i + 1&lt;span&gt;, :].shape[0]
    col_mv &lt;/span&gt;= col_mv.reshape(k, 1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列均值向量&lt;/span&gt;
    mean_all = mean_all.reshape(k, 1&lt;span&gt;)
    Sb &lt;/span&gt;+= n * (col_mv - mean_all).dot((col_mv - mean_all).T)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;%E4%B8%89%E3%80%81%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%BC%8F%E5%8F%8A%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9&quot;&gt;&lt;span&gt;三、线性判别式及特征选择&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;LDA其他步骤与PCA相似，但是，PCA是分解协方差矩阵提取特征值，LDA则是求解矩阵 &lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20S_%7BW%7D%5E%7B-1%7DS_B&quot; alt=&quot;\large S_{W}^{-1}S_B&quot; class=&quot;mathcode&quot;/&gt; 得到广义特征值，实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算广义特征值&lt;/span&gt;
eigen_vals, eigen_vecs =&lt;span&gt; np.linalg.eig(np.linalg.inv(Sw).dot(Sb))
eigen_pairs &lt;/span&gt;= [(np.abs(eigen_vals[i]), eigen_vecs[:, i]) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(eigen_vals))]
eigen_pairs &lt;/span&gt;= sorted(eigen_pairs, key=&lt;span&gt;lambda&lt;/span&gt; k: k[0], reverse=True)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;对特征值降序排列之后，打印看看：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;特征值降序排列：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; eigen_val &lt;span&gt;in&lt;/span&gt;&lt;span&gt; eigen_pairs:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(eigen_val[0])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;%E2%80%8B&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200814193226372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJ6b3Vz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;486&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;从捕捉到的特征值发现，前两个可以占据大部分数据集特征了，接下来可视化表示更加直观地观察：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 线性判别捕捉，计算辨识力&lt;/span&gt;
tot =&lt;span&gt; sum(eigen_vals.real)
discr &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; discr=[(i/tot) for i in sorted(eigen_vals.real,reverse=True)]&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; sorted(eigen_vals.real, reverse=&lt;span&gt;True):
    discr.append(i &lt;/span&gt;/&lt;span&gt; tot)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(discr)&lt;/span&gt;
cum_discr = np.cumsum(discr)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算累加方差&lt;/span&gt;
plt.rcParams[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;font.sans-serif&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;SimHei&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 显示中文&lt;/span&gt;
plt.bar(range(1,14),discr,alpha=0.5,align=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;独立辨识力&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.step(range(&lt;/span&gt;1,14),cum_discr,where=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;mid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,label=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;累加辨识力&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&quot;辨识力&quot;比&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;线性判别&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylim([&lt;/span&gt;-0.1,1.1&lt;span&gt;])
plt.legend(loc&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;best&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200814203325783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJ6b3Vz,size_16,color_000000,t_70&quot; alt=&quot;&quot; width=&quot;761&quot; height=&quot;591&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;很明显，最具线性判别的前两个特征捕捉了100%的信息，下面以此构建变换矩阵 W.&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E5%9B%9B%E3%80%81%E6%A0%B7%E6%9C%AC%E6%95%B0%E6%8D%AE%E9%99%8D%E7%BB%B4%E6%8A%95%E5%BD%B1&quot;&gt;&lt;span&gt;四、样本数据降维投影&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;构建变换矩阵：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 变换矩阵&lt;/span&gt;
w = np.hstack((eigen_pairs[0][1][:, np.newaxis].real, eigen_pairs[1][1&lt;span&gt;][:, np.newaxis].real))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(w)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;来瞅瞅，这就是前两个特征向量的矩阵表示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200814203809616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJ6b3Vz,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;366&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在有了变换矩阵，就可以将样本训练数据投影到降维特征空间了：&lt;img src=&quot;https://private.codecogs.com/gif.latex?%5Cdpi%7B100%7D%20%5Clarge%20X%5E%7B%27%7D%3DXW&quot; alt=&quot;\large X^{'}=XW&quot; class=&quot;mathcode&quot;/&gt;. 并展示分类结果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 样本数据投影到低维空间&lt;/span&gt;
x_train_lda =&lt;span&gt; x_train_std.dot(w)
colors &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
marks &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; l, c, m &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(np.unique(y_train), colors, marks):
    plt.scatter(x_train_lda[y_train &lt;/span&gt;==&lt;span&gt; l, 0],
                x_train_lda[y_train &lt;/span&gt;== l, 1] * -1&lt;span&gt;,
                c&lt;/span&gt;=c, label=l, marker=&lt;span&gt;m)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LD 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LD 2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.legend(loc&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lower right&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200814204411367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoYXJ6b3Vz,size_16,color_000000,t_70&quot; alt=&quot;&quot; width=&quot;602&quot; height=&quot;459&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很明显，三个类别线性可分，效果也不错，相比较&lt;a href=&quot;https://blog.csdn.net/Charzous/article/details/107883679&quot;&gt;PCA方法&lt;/a&gt;，我感觉LDA分类结果更好，我们知道，LDA是有监督的方法，有利用到数据集的标签。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;%E4%BA%94%E3%80%81%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81&quot;&gt;&lt;span&gt;五、完整代码&lt;/span&gt;&lt;/h2&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('210f5528-20f2-4f55-aff4-6a0bf09fee79')&quot; readability=&quot;69&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_210f5528-20f2-4f55-aff4-6a0bf09fee79&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_210f5528-20f2-4f55-aff4-6a0bf09fee79&quot; class=&quot;code_img_opened&quot;/&gt;&lt;/span&gt;
&lt;div id=&quot;cnblogs_code_open_210f5528-20f2-4f55-aff4-6a0bf09fee79&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;133&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.preprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; StandardScaler
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.model_selection &lt;span&gt;import&lt;/span&gt;&lt;span&gt; train_test_split
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; load data&lt;/span&gt;
df_wine = pd.read_csv(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;D:\\PyCharm_Project\\maching_learning\\wine_data\\wine.data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, header=None)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 本地加载&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; df_wine=pd.read_csv('https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data',header=None)#服务器加载&lt;/span&gt;
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; split the data，train：test=7:3&lt;/span&gt;
x, y = df_wine.iloc[:, 1&lt;span&gt;:].values, df_wine.iloc[:, 0].values
x_train, x_test, y_train, y_test &lt;/span&gt;= train_test_split(x, y, test_size=0.3, stratify=y, random_state=&lt;span&gt;0)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; standardize the feature 标准化单位方差&lt;/span&gt;
sc =&lt;span&gt; StandardScaler()
x_train_std &lt;/span&gt;=&lt;span&gt; sc.fit_transform(x_train)
x_test_std &lt;/span&gt;=&lt;span&gt; sc.fit_transform(x_test)
 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算均值向量&lt;/span&gt;
np.set_printoptions(precision=4&lt;span&gt;)
mean_vecs &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; label &lt;span&gt;in&lt;/span&gt; range(1, 4&lt;span&gt;):
    mean_vecs.append(np.mean(x_train_std[y_train &lt;/span&gt;== label], axis=&lt;span&gt;0))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;Mean Vectors %s:&quot; % label,mean_vecs[label-1])&lt;/span&gt;
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算类内散布矩阵&lt;/span&gt;
k = 13&lt;span&gt;
Sw &lt;/span&gt;=&lt;span&gt; np.zeros((k, k))
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; label, mv &lt;span&gt;in&lt;/span&gt; zip(range(1, 4&lt;span&gt;), mean_vecs):
    Si &lt;/span&gt;=&lt;span&gt; np.zeros((k, k))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; for row in x_train_std[y_train==label]:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     row,mv=row.reshape(n,1),mv.reshape(n,1)&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     Si+=(row-mv).dot((row-mv).T)&lt;/span&gt;
    Si = np.cov(x_train_std[y_train ==&lt;span&gt; label].T)
    Sw &lt;/span&gt;+=&lt;span&gt; Si
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;类内散布矩阵：&quot;,Sw.shape[0],&quot;*&quot;,Sw.shape[1])&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(&quot;类内标签分布：&quot;,np.bincount(y_train)[1:])&lt;/span&gt;
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算跨类散布矩阵&lt;/span&gt;
mean_all = np.mean(x_train_std, axis=&lt;span&gt;0)
Sb &lt;/span&gt;=&lt;span&gt; np.zeros((k, k))
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i, col_mv &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(mean_vecs):
    n &lt;/span&gt;= x_train[y_train == i + 1&lt;span&gt;, :].shape[0]
    col_mv &lt;/span&gt;= col_mv.reshape(k, 1)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列均值向量&lt;/span&gt;
    mean_all = mean_all.reshape(k, 1&lt;span&gt;)
    Sb &lt;/span&gt;+= n * (col_mv - mean_all).dot((col_mv -&lt;span&gt; mean_all).T)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;跨类散布矩阵：&quot;, Sb.shape[0], &quot;*&quot;, Sb.shape[1])&lt;/span&gt;
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算广义特征值&lt;/span&gt;
eigen_vals, eigen_vecs =&lt;span&gt; np.linalg.eig(np.linalg.inv(Sw).dot(Sb))
eigen_pairs &lt;/span&gt;= [(np.abs(eigen_vals[i]), eigen_vecs[:, i]) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(eigen_vals))]
eigen_pairs &lt;/span&gt;= sorted(eigen_pairs, key=&lt;span&gt;lambda&lt;/span&gt; k: k[0], reverse=&lt;span&gt;True)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(eigen_pairs[0][1][:,np.newaxis].real) # 第一特征向量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; print(&quot;特征值降序排列：&quot;)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; for eigen_val in eigen_pairs:&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print(eigen_val[0])&lt;/span&gt;
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 线性判别捕捉，计算辨识力&lt;/span&gt;
tot =&lt;span&gt; sum(eigen_vals.real)
discr &lt;/span&gt;=&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; discr=[(i/tot) for i in sorted(eigen_vals.real,reverse=True)]&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; sorted(eigen_vals.real, reverse=&lt;span&gt;True):
    discr.append(i &lt;/span&gt;/&lt;span&gt; tot)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(discr)&lt;/span&gt;
cum_discr = np.cumsum(discr)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算累加方差&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.rcParams['font.sans-serif'] = ['SimHei']  # 显示中文&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.bar(range(1,14),discr,alpha=0.5,align='center',label='独立辨识力')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.step(range(1,14),cum_discr,where='mid',label='累加辨识力')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.ylabel('&quot;辨识力&quot;比')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.xlabel('线性判别')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.ylim([-0.1,1.1])&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.legend(loc='best')&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; plt.show()&lt;/span&gt;
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 转换矩阵&lt;/span&gt;
w = np.hstack((eigen_pairs[0][1][:, np.newaxis].real, eigen_pairs[1][1&lt;span&gt;][:, np.newaxis].real))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(w)&lt;/span&gt;
 
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 样本数据投影到低维空间&lt;/span&gt;
x_train_lda =&lt;span&gt; x_train_std.dot(w)
colors &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;g&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
marks &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; l, c, m &lt;span&gt;in&lt;/span&gt;&lt;span&gt; zip(np.unique(y_train), colors, marks):
    plt.scatter(x_train_lda[y_train &lt;/span&gt;==&lt;span&gt; l, 0],
                x_train_lda[y_train &lt;/span&gt;== l, 1] * -1&lt;span&gt;,
                c&lt;/span&gt;=c, label=l, marker=&lt;span&gt;m)
plt.xlabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LD 1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.ylabel(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;LD 2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.legend(loc&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;lower right&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
plt.show()&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;h2 id=&quot;%E7%BB%93%E8%AF%AD&quot;&gt;&lt;span&gt;结语&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这篇记录了这几天学习的LDA实现数据降维的方法，仍然以葡萄酒数据集为案例，在上面一步步的拆分中，我们更加清楚线性判别分析LDA方法的内部实现，在这个过程，对于初步学习的我感觉能够认识和理解更深刻，当然以后数据处理使用LDA方法时候会用到一些第三方库的类，实现起来更加方便，加油学习，期待下一篇LDA实现更简洁的方法！&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;span&gt;我的博客园：&lt;a href=&quot;https://www.cnblogs.com/chenzhenhong/p/13504526.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/chenzhenhong/p/13504526.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的CSDN博客：&lt;a href=&quot;https://blog.csdn.net/Charzous/article/details/108007441&quot; target=&quot;_blank&quot;&gt;&lt;span class=&quot;article-type type-1 float-none&quot;&gt;原创 LDA数据压缩原理及python应用（葡萄酒案例分析）&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;div class=&quot;creativecommons&quot;&gt;&lt;span&gt;版权声明：本文为博主原创文章，遵循&lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt; CC 4.0 BY-SA &lt;/a&gt;版权协议，转载请附上原文出处链接和本声明。&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;article-source-link&quot;&gt;&lt;span&gt;本文链接：&lt;a href=&quot;https://blog.csdn.net/Charzous/article/details/108007441&quot;&gt;https://blog.csdn.net/Charzous/article/details/108007441&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 14 Aug 2020 14:43:00 +0000</pubDate>
<dc:creator>Charzueus</dc:creator>
<og:description>目录 线性判别分析（LDA）数据降维及案例实战 一、LDA是什么 二、计算散布矩阵 三、线性判别式及特征选择 四、样本数据降维投影 五、完整代码 结语 一、LDA是什么 LDA概念及与PCA区别 LD</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenzhenhong/p/13504526.html</dc:identifier>
</item>
</channel>
</rss>