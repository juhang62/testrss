<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从SpringBoot构建十万博文聊聊高并发文章浏览量设计 - 小柒2012</title>
<link>http://www.cnblogs.com/smallSevens/p/11374237.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smallSevens/p/11374237.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/109211/201908/109211-20190818221721062-1829611281.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在经历了，缓存、限流、布隆穿透等等一系列加强功能，十万博客基本算是成型，网站上线以后也加入了百度统计来见证十万+ 的整个过程。&lt;/p&gt;
&lt;p&gt;但是百度统计并不能对每篇博文进行详细的浏览量统计，如果做一些热点博文排行、48小时排行之类统计，还需要引入浏览量统计功能。&lt;/p&gt;
&lt;h2 id=&quot;设计&quot;&gt;设计&lt;/h2&gt;
&lt;p&gt;通常情况下，我们只需要每次请求浏览量+1，但是这样真的好吗？或者更直白的讲，真实浏览数准确吗？&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;UPDATE blog SET views = views+1 WHERE id=?&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考了多个社区博客的设计，因为并不十分清楚其后端实现过程，只能从前端得出以下结论。&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;慕课网手记：无论是用户登录模式还是用户状态，每次刷新页面浏览数都会 +1。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;51CTO博客：无论是用户登录模式还是用户状态，每次刷新页面浏览数都会 +1。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;简书：用户登录模式下，无论如何刷新浏览数都不会新增，但是游客状态下每次刷新浏览数都会+1。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;博客园：无论是用户登录模式还是用户状态，每次刷新页面浏览数都不变，即使隔天访问，也不变，没细测。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;微信公众号：只能是用户登录状态，每次刷新浏览数基本不变，有时候会出现由多变少的情况，不知道大家有没有发现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CSDN博客：无论是用户登录模式还是用户状态，每次刷新页面浏览数都不变，但是隔天访问，浏览数会+1，没细测。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于以上社区的数据，直接 Pass 掉前两位，总结了以下几种方案，都是基于缓存标识实现。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果游客或者登录用户访问，按照 IP + 文章 ID 维度增加浏览数，那局域网中怎么算？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果是游客访问，按照 IP + 浏览器SessionId + 文章 ID 维度增加浏览数，可能解决局域网问题，那么关闭浏览器，重新打开又怎么算？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果是登录用户，用户ID + 文章 ID 维度增加浏览数，那么游客在登录后算不算一个浏览数，或者是用户换个 IP 登录算不算 ？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以说，怎么算都不准确，浏览数本身就是一个不需要太精确的功能，不要想太多，直接使用 IP + 文章ID 维度即可。&lt;/p&gt;
&lt;h2 id=&quot;方案&quot;&gt;方案&lt;/h2&gt;
&lt;h4 id=&quot;方案一&quot;&gt;方案一&lt;/h4&gt;
&lt;p&gt;得到 GET 请求，在限流之后，缓存之前，判断缓存中是否存在 IP+ 文章ID是否存在 Key。&lt;/p&gt;
&lt;p&gt;如果存在，说明之前浏览过，就什么也不做。如果没有，就加上这个 Key，根据业务设置缓存失效时间，然后更新数据库浏览量+1，下面是代码实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//获取 Key
String key = IPUtils.getIpAddr()+&quot;:blog:&quot;+id;
//判断是否存在
boolean flag =  redisUtil.hasKey(key);
if(!flag){
    //设置缓存标识并更新数据库
    redisUtil.set(key,&quot;true&quot;,36000);
    String nativeSql = &quot;UPDATE blog SET views = views+1 WHERE id=?&quot;;
    dynamicQuery.nativeExecuteUpdate(nativeSql,new Object[]{id});
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方案二&quot;&gt;方案二&lt;/h4&gt;
&lt;p&gt;这样基本能保证真实的博文浏览量，你以为就这么结束了吗？我们做的可是一个高并发的博客，直接落库，显得不是逼格太 Low 了！&lt;/p&gt;
&lt;p&gt;为了进一步提升性能力，来做下一步优化，判断不存在之后，先不急于更新数据库，先在 Redis 里给这篇文章的浏览量+1，Key 为 viewCount:articleId，value 为缓存的浏览量。然后设置一个定时任务，定时更新 Redis 缓存数据到数据库。&lt;/p&gt;
&lt;p&gt;这样，是不是逼格一下子提升了好几个档次！！！下面来介绍一款更有逼格的第三方计数工具。&lt;/p&gt;
&lt;h4 id=&quot;方案三&quot;&gt;方案三&lt;/h4&gt;
&lt;p&gt;一款高并发计数神器 Redis HyperLogLog，她是用来做基数统计的算法，优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。&lt;/p&gt;
&lt;p&gt;在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。&lt;/p&gt;
&lt;p&gt;什么是基数？比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。&lt;/p&gt;
&lt;p&gt;为了校验准确性，博主特意测试了一下，分别测试了，20000 和 100000 的数据量，基本上用了 12KB。&lt;/p&gt;
&lt;p&gt;在测试之前 info 查询一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;used_memory_human:910.14K&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试之后，可以说基本差不多：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;used_memory_human:922.27K&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们通过代码来实现，引入 redis starter：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;spring-boot-starter-data-redis&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们只需要两个API即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 计数
 * @param key
 * @param value
 */
public void add(String key, Object... value) {
    redisTemplate.opsForHyperLogLog().add(key,valu);
}
/**
  * 获取总数
  * @param key
  */
public Long size(String key) {
    return redisTemplate.opsForHyperLogLog().size(key);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后写个AOP：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Around(&quot;ServiceAspect()&quot;)
public  Object around(ProceedingJoinPoint joinPoint) {
     Object[] object = joinPoint.getArgs();
     Object blogId = object[0];
     Object obj = null;
     try {
         String value = IPUtils.getIpAddr();
         String key = &quot;viewCount:&quot; + blogId;
         // key 为 文章ID，Value 为请求IP地址
         redisUtil.add(key,value);
         obj = joinPoint.proceed();
     } catch (Throwable e) {
         e.printStackTrace();
     }
     return obj;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;博文请求：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
  * 博文
  */
@RequestMapping(&quot;{id}.shtml&quot;)
public String page(@PathVariable(&quot;id&quot;) Long id, ModelMap model) {
     try{
         Blog blog = blogService.getById(id);
         String key = &quot;viewCount:&quot;+id;
         Long views = redisUtil.size(key);
         //直接从缓存中获取并与之前的数量相加
         blog.setViews(views+blog.getViews());
         model.addAttribute(&quot;blog&quot;,blog);
     } catch (Throwable e) {
         return  &quot;error/404&quot;;
     }
     return  &quot;article&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;业务代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
  * 执行顺序
  * 1）限流
  * 2）布隆
  * 3）计数
  * 4) 缓存
  * @param id
  * @return
  */
@Override
@ServiceLimit(limitType= ServiceLimit.LimitType.IP)
@BloomLimit
@HyperLogLimit
@Cacheable(cacheNames =&quot;blog&quot;)
public Blog getById(Long id) {
     String nativeSql = &quot;SELECT * FROM blog WHERE id=?&quot;;
     return dynamicQuery.nativeQuerySingleResult(Blog.class,nativeSql,new Object[]{id});
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，写个定时任务，夜间入库：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Scheduled(cron = &quot;0 30 23 * * ?&quot;)
public void createHyperLog() {
     logger.info(&quot;计数落库开始&quot;);
     String nativeSql = &quot;SELECT id FROM blog&quot;;
     List&amp;lt;Object&amp;gt; list = dynamicQuery.query(nativeSql,new Object[]{});
     list.forEach(blogId -&amp;gt;{
         String key  = &quot;viewCount:&quot;+blogId;
         Long views = redisUtil.size(key);
         if(views&amp;gt;0){
             String updateSql = &quot;UPDATE blog SET views=views+? WHERE id=?&quot;;
                dynamicQuery.nativeExecuteUpdate(updateSql,new Object[]{views,blogId});
                redisUtil.del(key);
         }
     });
     logger.info(&quot;计数落库结束&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;撸完计数功能，作为一个个人博客基本上差不多了已经，前后端框架、连接池、限流、缓存、计数、动静分离，HTTPS安全认证、百度收录等等，后面会追加后台管理，模板、插件等等一系列功能，有兴趣的小伙伴可以一起参与进来啊啊啊啊啊啊......&lt;/p&gt;
&lt;h2 id=&quot;案例&quot;&gt;案例&lt;/h2&gt;
&lt;p&gt;源码：&lt;a href=&quot;https://gitee.com/52itstyle/spring-boot-blog&quot; class=&quot;uri&quot; title=&quot;https://gitee.com/52itstyle/spring-boot-blog&quot;&gt;https://gitee.com/52itstyle/spring-boot-blog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;列表：&lt;a href=&quot;https://blog.52itstyle.top/index&quot; class=&quot;uri&quot; title=&quot;https://blog.52itstyle.top/index&quot;&gt;https://blog.52itstyle.top/index&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博文：&lt;a href=&quot;https://blog.52itstyle.top/51.html&quot; class=&quot;uri&quot; title=&quot;https://blog.52itstyle.top/51.html&quot;&gt;https://blog.52itstyle.top/51.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/redis/redis-hyperloglog.html&quot; title=&quot;Redis HyperLogLog&quot;&gt;Redis HyperLogLog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html&quot; title=&quot;神奇的HyperLogLog算法&quot;&gt;神奇的HyperLogLog算法&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 19 Aug 2019 00:45:00 +0000</pubDate>
<dc:creator>小柒2012</dc:creator>
<og:description>前言 在经历了，缓存、限流、布隆穿透等等一系列加强功能，十万博客基本算是成型，网站上线以后也加入了百度统计来见证十万+ 的整个过程。 但是百度统计并不能对每篇博文进行详细的浏览量统计，如果做一些热点博</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/smallSevens/p/11374237.html</dc:identifier>
</item>
<item>
<title>浅谈神经网络中的激活函数 - Kalafinaian</title>
<link>http://www.cnblogs.com/Kalafinaian/p/11375163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kalafinaian/p/11375163.html</guid>
<description>&lt;p&gt;       激活函数是神经网络中一个重要的环节，本文将介绍为什么神经网络网络要利用激活函数，几种常用的激活函数(逻辑函数Sigmoid、双曲正切函数tanh、线性整流函数(ReLU)，神经网络中的梯度消失问题和ReLU如何避免梯度消失。&lt;/p&gt;

&lt;p&gt;       如果神经网络没有进行可以提取非线性特征的卷积操作，而且该神经网络也不用激活函数，那么这个神经网络第i层输出只有Wxi+b。这样此神经网络不论有多少层，第i层的输出都是一个关于第i层输入xi的线性组合，相当于此时多层神经网络退化为一个多层的线性回归模型，难以学习如图像、音频、文本等复杂数据的特征。&lt;/p&gt;
&lt;p&gt;       正因为这个原因，神经网络要引入激活函数来给神经网络增加一些非线性的特性，所以目前常见的激活函数大多是非线性函数。这样神经网络中下一层得到的输入不再是线性组合了。&lt;/p&gt;

&lt;h2 id=&quot;逻辑函数sigmoid-1&quot;&gt;2.1 逻辑函数Sigmoid [1]&lt;/h2&gt;
&lt;p&gt;       逻辑函数（logistic function）或逻辑曲线（logistic curve）是一种常见的S函数，它是皮埃尔·弗朗索瓦·韦吕勒在1844或1845年在研究它与人口增长的关系时命名的。&lt;/p&gt;
&lt;p&gt;       一个简单的Logistic函数表达式为:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ f\left( x \right) = \frac{1}{{1 + {e^{ - x}}}} \]&lt;/span&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190819084349786-867823424.jpg&quot;/&gt;&lt;br/&gt;图1 标准逻辑函数的图像&lt;/center&gt;
&lt;p&gt;       逻辑函数形如S，所以通常也叫做S形函数。&lt;/p&gt;
&lt;p&gt;       从函数图像易知f(x)的定义域为[-∞, +∞]， 值域是(0,1)&lt;/p&gt;
&lt;p&gt;       对f(x)求导数，易得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f'\left( x \right) = {\left( {\frac{1}{{1 + {e^{ - x}}}}} \right)^\prime } = \frac{{{e^{ - x}}}}{{{{\left( {1 + {e^{ - x}}} \right)}^2}}}\;\; = f\left( x \right)\left( {1 - f\left( x \right)} \right)\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;双曲正切函数tanh-2&quot;&gt;2.2 双曲正切函数tanh [2]&lt;/h2&gt;
&lt;p&gt;       双曲正切函数是双曲函数的一种。在数学中，双曲函数是一类与常见的三角函数类似的函数。双曲正切函数的定义为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f\left( x \right) = \tanh \left( x \right) = \frac{{{e^x} - {e^{ - x}}}}{{{e^x} + {e^{ - x}}}}\]&lt;/span&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190819084408058-200181905.jpg&quot;/&gt;&lt;br/&gt;图2 双曲正切函数的图像（同逻辑函数类似）&lt;/center&gt;
&lt;p&gt;       从函数图像易知f(x)的定义域为[-∞, +∞]， 值域是(-1,1)&lt;/p&gt;
&lt;p&gt;       对f(x)求导数，易得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f'\left( x \right) = {\left( {\frac{{{e^x} - {e^{ - x}}}}{{{e^x} + {e^{ - x}}}}} \right)^\prime } = \frac{4}{{{{\left( {{e^x} + {e^{ - x}}} \right)}^2}}}\;\; = 1 - f{\left( x \right)^2}\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;线性整流函数relu-3&quot;&gt;2.3 线性整流函数ReLU [3]&lt;/h2&gt;
&lt;p&gt;       线性整流函数（Rectified Linear Unit, ReLU）,又称修正线性单元, 是一种人工神经网络中常用的激活函数，通常指代以斜坡函数及其变种为代表的非线性函数。&lt;/p&gt;
&lt;p&gt;       通常意义下，线性整流函数指代数学中的斜坡函数，即&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f\left( x \right) = \left\{ \begin{array}{l} x\quad \quad x \ge 0 \\ 0\quad \quad x &amp;lt; 0 \\ \end{array} \right.\]&lt;/span&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190819084423993-1732278271.jpg&quot;/&gt;&lt;br/&gt;图3 ReLU函数图像&lt;/center&gt;
&lt;p&gt;       从函数图像易知f(x)的定义域为[-∞, +∞]， 值域是[0, +∞)&lt;/p&gt;
&lt;p&gt;       对f(x)求导数，易得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f'\left( x \right) = \left\{ \begin{array}{l} 1\quad \quad x \ge 0 \\ 0\quad \quad x &amp;lt; 0 \\ \end{array} \right.\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;       使用S形函数作为激活的神经网络中，随着神经网络的层数增加，神经网络后面层在梯度下降中求导的梯度几乎为0，从而导致神经网络网络后面层的权值矩阵几乎无法更新。表现为随着隐藏层数目的增加，分类准确率反而下降了。这种现象叫做消失的梯度问题。&lt;/p&gt;
&lt;p&gt;       假设神经网络只有三层，用S型函数作为激活函数&lt;/p&gt;
&lt;p&gt;       第一层输入为x, 输出为S(W1x+b1)&lt;/p&gt;
&lt;p&gt;       第二层输入为S(W1x+b1)，输出为S(W2S(W1x+b1)+b2)&lt;/p&gt;
&lt;p&gt;       第三层输入为S(W2S(W1x+b1)+b2)，输出为S(W3S(W2S(W1x+b1)+b2)+b3)&lt;/p&gt;
&lt;p&gt;       同时简记住每层在激活函数处理前的值为ai, 输出为fi&lt;/p&gt;
&lt;p&gt;       假设最后损失函数为L，L是一个关于f3的函数，那么求导易得&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{array}{l} \frac{{\partial L}}{{\partial {W_1}}} = \frac{{\partial L}}{{\partial {f_3}}} \cdot \frac{{\partial S\left( {{W_3}S\left( {{W_2}S\left( {{W_1}x + {b_1}} \right) + {b_2}} \right) + {b_3}} \right)}}{{\partial {W_1}}} \\ \quad \quad = \frac{{\partial L}}{{\partial {f_3}}} \cdot \frac{{\partial S}}{{\partial {a_3}}} \cdot \frac{{\partial {W_3}S\left( {{W_2}S\left( {{W_1}x + {b_1}} \right) + {b_2}} \right) + {b_3}}}{{\partial {W_1}}} \\ \quad \quad = \frac{{\partial L}}{{\partial {f_3}}} \cdot \frac{{\partial S}}{{\partial {a_3}}} \cdot {W_3} \cdot \frac{{\partial S\left( {{W_2}S\left( {{W_1}x + {b_1}} \right) + {b_2}} \right)}}{{\partial {W_1}}} \\ \quad \quad = \cdots \\ \quad \quad = \frac{{\partial L}}{{\partial {f_3}}} \cdot \frac{{\partial S}}{{\partial {a_3}}} \cdot {W_3} \cdot \frac{{\partial S}}{{\partial {a_2}}} \cdot {W_2} \cdot \frac{{\partial S}}{{\partial {a_1}}} \cdot \frac{{\partial {a_1}}}{{\partial {W_1}}} \\ \end{array}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       其中偏导数∂S/ ∂ai是造成梯度消失的原因，因为S函数的导数阈值为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f'\left( x \right) = \frac{{{e^{ - x}}}}{{{{\left( {1 + {e^{ - x}}} \right)}^2}}}\;\; \in \left( {0,\left. {\frac{1}{4}} \right]} \right.\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       即有0&amp;lt;∂S/ ∂a1≤0.25， 0&amp;lt;∂S/ ∂a2≤0.25， 0&amp;lt;∂S/ ∂3≤0.25, 在损失函数偏导表达式中三个偏导数相乘有:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[0 &amp;lt; \frac{{\partial S}}{{\partial {a_3}}}\frac{{\partial S}}{{\partial {a_2}}}\frac{{\partial S}}{{\partial {a_1}}} \le 0.015625\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       这样会减小损失函数的数值，如果神经网络是20层，则有&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[0 &amp;lt; \frac{{\partial S}}{{\partial {a_{20}}}}\frac{{\partial S}}{{\partial {a_{19}}}} \cdots \frac{{\partial S}}{{\partial {a_1}}} \le {0.25^{20}} = {\rm{9}}.0{\rm{94}} \times {10^{ - 13}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       这是一个更小的数，所以神经网络后几层求第一层参数W1的梯度就非常小。而ReLU函数就是为了避免梯度消失问题，因为ReLU求导只有两个值1或0，这样的话只要神经网络梯度中一条路径上的导数都是1，那么无论网络有多少层，网络后几层的梯度都可以传播到网络前几层。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_function&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Logistic_function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperbolic_function&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Hyperbolic_function&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Rectifier_(neural_networks)&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Rectifier_(neural_networks)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 19 Aug 2019 00:45:00 +0000</pubDate>
<dc:creator>Kalafinaian</dc:creator>
<og:description>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;激活函数是神经网络中一个重要的环节，本文将介绍为什么神经网络网络要利用激活函数，几种常用的激活函数(逻辑函数Sigm</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Kalafinaian/p/11375163.html</dc:identifier>
</item>
<item>
<title>.netcore持续集成测试篇之 .net core 2.1项目集成测试 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11375098.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11375098.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从.net到.net core以后,微软非常努力,以每年一到两个大版本的频率在演进.net core,去年相继发布了.net core 2.1和2.2,其中2.1是长期支持版,不断的快速更新一方面快速弥补了相比.net framework缺失的api,同时也带来了不少激进性的改变,导致很多api,尤其是较传统framework相比新增的api不断调整,有些api在上一个版本还能用,结果到下一个版本就不支持了.升级到2.1以后,微软就更改了集成测试服务器的包名并改变了2.0的接口,进行了更高层次的封装,降低了使用配置难度.但是截至写本文时VisualStudio工具支持仍然不是太好,需要手动修改csproj文件.但是这个工作也是一次性的.配置好了就ok啦.&lt;/p&gt;
&lt;p&gt;看到这里可能有些同志会担心接口变化很大以前学的东西都白瞎了,其实不然,只是创建TestServer的方式变了,我们实际测试中用到的最多的是HttpClient这个对象,它并没有变.&lt;/p&gt;
&lt;p&gt;下面就介绍一下.net core 2.1下如何搭建一个内存集成测试服务器.&lt;br/&gt;首先我们新建一个.net core 2.1的mvc项目,并创建一个Xunit单元测试项目,引用刚创建的这个mvc项目,关于创建跟前面一样,这里不再赘述.&lt;/p&gt;
&lt;p&gt;下载以下两个包:&lt;code&gt;Microsoft.AspNetCore.App和Microsoft.AspNetCore.Mvc.Testing&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们创建一个名为&lt;code&gt;netcoremvc21&lt;/code&gt;的测试类,它的代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;  public class netcoremvc21: IClassFixture&amp;lt;WebApplicationFactory&amp;lt;CoreMvc21.Startup&amp;gt;&amp;gt;
    {
        //private readonly WebApplicationFactory&amp;lt;CoreMvc21.Startup&amp;gt; _factory;
        private HttpClient client;
        public netcoremvc21(WebApplicationFactory&amp;lt;CoreMvc21.Startup&amp;gt; factory)
        {
            this.client = factory.CreateClient();
        }
        [Fact]
        public async Task GetTest()
        {
            var response = await client.GetAsync(&quot;/Home/Hello&quot;);
            response.EnsureSuccessStatusCode();
            var responseStr = await response.Content.ReadAsStringAsync();
            Assert.Equal(&quot;Hello,world&quot;, responseStr);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们创建的项目实现了IClassFixture泛型接口,前面我们讲了这个接口的作用了,这里不再赘述,它里面的泛型参数是一个&lt;code&gt;WebApplicationFactory&lt;/code&gt;泛型对象,这个对象是微软提供好的,不需要我们自己创建,这个泛型对象的参数是一个TEntryPoint对象,其实就是指定程序的startup文件(这里我们提供的是mvc项目的startup文件,这个项目名为CoreMvc21).它其实是把创建内存测试服务器的方法给封装了,类似我们前面的封装,减少了手写代码量,并且提供了最佳实践,我们前面说到过,如果对Xunit不熟悉在构造函数里创建非托管对象非造成严重性能问题.&lt;/p&gt;
&lt;p&gt;下面的测试代码和前面的并没太大区别,都是通过httpclient对象构造请求.&lt;/p&gt;
&lt;p&gt;测试接口数据没问题,我们再来看看这次是没有配置ContentRoot的,程序能不能正常找到页面&lt;/p&gt;
&lt;p&gt;测试代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Fact]
        public async Task GetTest()
        {
            var response = await client.GetAsync(&quot;/Home/index&quot;);
            response.EnsureSuccessStatusCode();
            var responseStr = await response.Content.ReadAsStringAsync();
            Assert.Contains(&quot;myCarousel&quot;, responseStr);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码测试也是通过的,也就是我们不需要额外的配置,基本功能都能正常运行了.当前以上能正常运行的前提是项目是按惯例配置的,如果你的资源文件和项目不在同一个目录下,则以上就不能正常工作了,此时我们可以继承&lt;code&gt;WebApplicationFactory&amp;lt;TEntryPoint&amp;gt;&lt;/code&gt;来自定义配置,和前面.net core 2.0的配置基本类似.&lt;/p&gt;
&lt;p&gt;可能有些同事会有疑问,这里的工作环境也没有配置,它是不是Development环境呢,答案是的.&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;截至到发文时,.net core已经到 3.0 preview 7了.由于工作比较忙,加之对新技术新框架不像以前那样有激情了,笔者并没有试用过.net core 3.0.以上的方法仅适用于.net core 2.1和2.2两个版本(不适用于2.0版本,关于2.0版本的集成测试本系列也有介绍,感兴趣的朋友可以翻阅一下).&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 19 Aug 2019 00:18:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 从.net到.net core以后,微软非常努力,以每年一到两个大版本的频率在演进.net core,去年相继发布了.net core 2.1和2.2,其中2.1是长期支持版,不断的快速</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11375098.html</dc:identifier>
</item>
<item>
<title>【Node.js】 bodyparser实现原理解析 - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/11374268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/11374268.html</guid>
<description>&lt;p&gt;&lt;span data-offset-key=&quot;38jvt-0-0&quot;&gt;于是这时候又打算从Node文档里找找request对象有没有可以提供查询请求报文的属性，结&lt;strong&gt;果自然是Node文档自然会告诉你结果&lt;/strong&gt;——&lt;/span&gt;&lt;/p&gt;&lt;div data-offset-key=&quot;38jvt-0-0&quot; readability=&quot;99.046477850399&quot;&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1gbn7&quot; data-offset-key=&quot;4d2rt-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4d2rt-0-0&quot;&gt;bodyparser是一类处理request的body的中间件函数，例如Koa-bodyparser就是和Koa框架搭配使用的中间件，帮助没有内置处理该功能的Koa框架提供解析request.body的方法，通过app.use加载Koa-bodyparser后，在Koa中就可以通过ctx.request.body访问到请求报文的报文实体啦!&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;span data-offset-key=&quot;41b9p-0-0&quot;&gt;body-parser代码逻辑&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9nvvr-0-0&quot;&gt;无论是Node的哪一款body-parser，其原理都是类似的今天我们就编写一个getRequestBody的函数，解析出request.body，以尽管中窥豹之理。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;1gbn7&quot; data-offset-key=&quot;1tdr8-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1tdr8-0-0&quot;&gt;要编写body-parser的代码，首先要了解两个方面的逻辑：请求相关事件和数据处理流程&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;5dquj-0-0&quot;&gt;请求相关事件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;public-DraftStyleDefault-ul&quot; data-offset-key=&quot;ec1j7-0-0&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-reset public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;1gbn7&quot; data-offset-key=&quot;ec1j7-0-0&quot; readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ec1j7-0-0&quot;&gt;data事件：当request接收到数据的时候触发，在数据传输结束前可能会触发多次，在事件回调里可以接收到Buffer类型的数据参数，我们可以将Buffer数据对象收集到数组里&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;Editable-styled public-DraftStyleDefault-unorderedListItem public-DraftStyleDefault-depth0 public-DraftStyleDefault-listLTR&quot; data-block=&quot;true&quot; data-editor=&quot;1gbn7&quot; data-offset-key=&quot;ap3iu-0-0&quot; readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ap3iu-0-0&quot;&gt;end事件：请求数据接收结束时候触发，不提供参数，我们可以在这里将之前收集的Buffer数组集中处理，最后输出将request.body输出。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据处理流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在request的data事件触发时候,收集Buffer对象，将其放到一个命名为chunks的数组中&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在request的end事件触发时，通过Buffer.concat(chunks)将Buffer数组整合成单一的大的Buffer对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解析请求首部的Content-Encoding，根据类型，如gzip,deflate等调用相应的解压缩函数如Zlib.gunzip,将2中得到的Buffer解压，返回的是解压后的Buffer对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;解析请求的charset字符编码，根据其类型，如gbk或者utf-8,调用iconv库提供的decode(buffer, charset)方法，根据字符编码将3中的Buffer转换成字符串&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;最后,根据Content-Type,如application/json或'application/x-www-form-urlencoded'对4中得到的字符串做相应的解析处理，得到最后的对象，作为request.body返回&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;下面展示下相关的代码&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;整体代码结构&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据Content-Encoding判断是否解压，如需则调用相应解压函数&lt;/span&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; transformEncode(buffer, encode) {
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; charset转码&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; transformCharset(buffer, charset) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据content-type做最后的数据格式化&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; formatData(str, contentType) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回Promise&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getRequestBody(req, res) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(async (resolve, reject) =&amp;gt;&lt;span&gt; {
        const chunks &lt;/span&gt;=&lt;span&gt; [];
        req.on(&lt;/span&gt;'data', buf =&amp;gt;&lt;span&gt; {
            chunks.push(buf);
        })
        req.on(&lt;/span&gt;'end', async () =&amp;gt;&lt;span&gt; {
            let buffer &lt;/span&gt;=&lt;span&gt; Buffer.concat(chunks);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取content-encoding&lt;/span&gt;
            const encode = req.headers['content-encoding'&lt;span&gt;];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取content-type&lt;/span&gt;
            const { type, parameters } =&lt;span&gt; contentType.parse(req);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取charset&lt;/span&gt;
            const charset =&lt;span&gt; parameters.charset;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解压缩&lt;/span&gt;
            buffer =&lt;span&gt; await transformEncode(buffer, encode);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换字符编码&lt;/span&gt;
            const str =&lt;span&gt; transformCharset(buffer, charset);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据类型输出不同格式的数据，如字符串或JSON对象&lt;/span&gt;
            const result =&lt;span&gt; formatData(str, type);
            resolve(result);
        })
    }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(err =&amp;gt; { &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; err; })
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;Step0.Promise&lt;span&gt;的编程风格&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; getRequestBody(req, res) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(async (resolve, reject) =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;Step1.data&lt;span&gt;事件的处理&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const chunks =&lt;span&gt; [];
req.on(&lt;/span&gt;'data', buf =&amp;gt;&lt;span&gt; {
  chunks.push(buf);
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;Step2.end&lt;span&gt;事件的处理&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const contentType = require('content-type'&lt;span&gt;);
const iconv &lt;/span&gt;= require('iconv-lite'&lt;span&gt;);

req.on(&lt;/span&gt;'end', async () =&amp;gt;&lt;span&gt; {
 let buffer &lt;/span&gt;=&lt;span&gt; Buffer.concat(chunks);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取content-encoding&lt;/span&gt;
 const encode = req.headers['content-encoding'&lt;span&gt;];
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取content-type&lt;/span&gt;
 const { type, parameters } =&lt;span&gt; contentType.parse(req);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取charset&lt;/span&gt;
 const charset =&lt;span&gt; parameters.charset;
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解压缩&lt;/span&gt;
 buffer =&lt;span&gt; await transformEncode(buffer, encode);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转换字符编码&lt;/span&gt;
 const str =&lt;span&gt; transformCharset(buffer, charset);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据类型输出不同格式的数据，如字符串或JSON对象&lt;/span&gt;
 const result =&lt;span&gt; formatData(str, type);
  resolve(result);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;Step3.&lt;span&gt;根据&lt;/span&gt;Content-Encoding&lt;span&gt;进行解压处理&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;Content-Encoding可分为四种值：gzip，compress，deflate，br，identity&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;identity表示数据保持原样，没有经过压缩&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;compress已经被大多数浏览器废弃，Node没有提供解压的方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;所以我们需要处理解压的一共有三种数据类型&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;gzip：采用zlib.gunzip方法解压&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;deflate: 采用zlib.inflate方法解压&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;br:采用zlib.brotliDecompress方法解压&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;（注意！zlib.brotliDecompress方法在Node11.7以上版本才会支持，而且不要看到名字里有compress就误以为它是用来解压compress压缩的数据的，实际上它是用来处理br的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码如下，我们对zlib.gunzip等回调类方法通过promisify转成Promise编码风格&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const promisify =&lt;span&gt; util.promisify;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; node 11.7版本以上才支持此方法&lt;/span&gt;
const brotliDecompress = zlib.brotliDecompress &amp;amp;&amp;amp;&lt;span&gt; promisify(zlib.brotliDecompress);

const gunzip &lt;/span&gt;=&lt;span&gt; promisify(zlib.gunzip);
const inflate &lt;/span&gt;=&lt;span&gt; promisify(zlib.inflate);

const querystring &lt;/span&gt;= require('querystring'&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据Content-Encoding判断是否解压，如需则调用相应解压函数&lt;/span&gt;
async &lt;span&gt;function&lt;/span&gt;&lt;span&gt; transformEncode(buffer, encode) {
    let resultBuf &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;debugger&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (encode) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'br'&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;brotliDecompress) {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('Node版本过低！ 11.6版本以上才支持brotliDecompress方法'&lt;span&gt;)
            }
            resultBuf &lt;/span&gt;=&lt;span&gt; await brotliDecompress(buffer);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'gzip'&lt;span&gt;:
            resultBuf &lt;/span&gt;=&lt;span&gt; await gunzip(buffer);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'deflate'&lt;span&gt;:
            resultBuf &lt;/span&gt;=&lt;span&gt; await inflate(buffer);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            resultBuf &lt;/span&gt;=&lt;span&gt; buffer;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultBuf;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;Step4.&lt;span&gt;根据&lt;/span&gt;charset&lt;span&gt;进行转码处理&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们采用iconv-lite对charset进行转码，代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const iconv = require('iconv-lite'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; charset转码&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; transformCharset(buffer, charset) {
    charset &lt;/span&gt;= charset || 'UTF-8'&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; iconv将Buffer转化为对应charset编码的String&lt;/span&gt;
    const result =&lt;span&gt; iconv.decode(buffer, charset);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;来！传送门&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/iconv-lite&quot;&gt;https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/iconv-lite&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Step5.&lt;span&gt;根据&lt;/span&gt;contentType&lt;span&gt;将4中得到的字符串数据进行格式化&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;具体的处理方式分三种情况：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;对text/plain 保持原样，不做处理，仍然是字符串&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对application/x-www-form-urlencoded，得到的是类似于key1=val1&amp;amp;key2=val2的数据，通过querystring模块的parse方法转成{ key:val }结构的对象&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;对于application/json，通过JSON.parse(str）一波带走&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;代码如下&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
const querystring = require('querystring'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据content-type做最后的数据格式化&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; formatData(str, contentType) {
    let result &lt;/span&gt;= ''&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (contentType) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'text/plain'&lt;span&gt;:
            result &lt;/span&gt;=&lt;span&gt; str;
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'application/json'&lt;span&gt;:
            result &lt;/span&gt;=&lt;span&gt; JSON.parse(str);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'application/x-www-form-urlencoded'&lt;span&gt;:
            result &lt;/span&gt;=&lt;span&gt; querystring.parse(str);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;测试代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面的代码你肯定知道要放在哪里了&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 省略其他代码&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; (pathname === '/post'&lt;span&gt;) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用getRequestBody,通过await修饰等待结果返回&lt;/span&gt;
  const body =&lt;span&gt; await getRequestBody(req, res);
  console.log(body);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
 }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;前端采用fetch进行测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在下面的代码中，我们连续三次发出不同的POST请求，携带不同类型的body数据，看看服务端会输出什么&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; iconv = require('iconv-lite'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; querystring = require('querystring'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; gbkBody =&lt;span&gt; {
    data: &lt;/span&gt;&quot;我是彭湖湾&quot;&lt;span&gt;,
    contentType: &lt;/span&gt;'application/json'&lt;span&gt;,
    charset: &lt;/span&gt;'gbk'&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转化为JSON数据&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; gbkJson =&lt;span&gt; JSON.stringify(gbkBody);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 转为gbk编码&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; gbkData = iconv.encode(gbkJson, &quot;gbk&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; isoData = iconv.encode(&quot;我是彭湖湾，这句话采用UTF-8格式编码，content-type为text/plain&quot;, &quot;UTF-8&quot;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试内容类型为application/json和charset=gbk的情况&lt;/span&gt;
fetch('/post'&lt;span&gt;, {
    method: &lt;/span&gt;'POST'&lt;span&gt;,
    headers: {
        &lt;/span&gt;&quot;Content-Type&quot;: 'application/json; charset=gbk'&lt;span&gt;
    },
    body: gbkData
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试内容类型为application/x-www-form-urlencoded和charset=UTF-8的情况&lt;/span&gt;
fetch('/post'&lt;span&gt;, {
    method: &lt;/span&gt;'POST'&lt;span&gt;,
    headers: {
        &lt;/span&gt;&quot;Content-Type&quot;: 'application/x-www-form-urlencoded; charset=UTF-8'&lt;span&gt;
    },
    body: querystring.stringify({
        data: &lt;/span&gt;&quot;我是彭湖湾&quot;&lt;span&gt;,
        contentType: &lt;/span&gt;'application/x-www-form-urlencoded'&lt;span&gt;,
        charset: &lt;/span&gt;'UTF-8'&lt;span&gt;
    })
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试内容类型为text/plain的情况&lt;/span&gt;
fetch('/post'&lt;span&gt;, {
    method: &lt;/span&gt;'POST'&lt;span&gt;,
    headers: {
        &lt;/span&gt;&quot;Content-Type&quot;: 'text/plain; charset=UTF-8'&lt;span&gt;
    },
    body: isoData
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;服务端输出结果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{ 
  data: &lt;/span&gt;'我是彭湖湾'&lt;span&gt;,
  contentType: &lt;/span&gt;'application/json'&lt;span&gt;,
  charset: &lt;/span&gt;'gbk'&lt;span&gt; 
 }
 {
  data: &lt;/span&gt;'我是彭湖湾'&lt;span&gt;,
  contentType: &lt;/span&gt;'application/x-www-form-urlencoded'&lt;span&gt;,
  charset: &lt;/span&gt;'UTF-8'&lt;span&gt; 
  }
  我是彭湖湾，这句话采用UTF&lt;/span&gt;-8格式编码，content-type为text/plain
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;问题和后记&lt;/span&gt;&lt;/h2&gt;

&lt;h3&gt;&lt;span&gt;Q1.为什么要对charset进行处理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;其实本质上来说，charset前端一般都是固定为utf-8的， 甚至在JQuery的AJAX请求中，前端请求charset甚至是不可更改，只能是charset，但是在使用fetch等API的时候，的确是可以更改charset的，这个工作尝试满足一些比较偏僻的更改charset需求。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Q2：为什么要对content-encoding做处理呢？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一般情况下我们认为，考虑到前端发的AJAX之类的请求的数据量，是不需要做Gzip压缩的。但是向服务器发起请求的不一定只有前端，还可能是Node的客户端。这些Node客户端可能会向Node服务端传送压缩过后的数据流。 例如下面的代码所示&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
const zlib = require('zlib'&lt;span&gt;);
const request &lt;/span&gt;= require('request'&lt;span&gt;);
const data &lt;/span&gt;= zlib.gzipSync(Buffer.from(&quot;我是一个被Gzip压缩后的数据&quot;&lt;span&gt;));
request({
    method: &lt;/span&gt;'POST'&lt;span&gt;,
    url: &lt;/span&gt;'http://127.0.0.1:3000/post'&lt;span&gt;,
    headers: {&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置请求头&lt;/span&gt;
        &quot;Content-Type&quot;: &quot;text/plain&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Content-Encoding&quot;: &quot;gzip&quot;&lt;span&gt;
    },
    body: data
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;项目的github和npm地址&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/penghuwan/body-parser-promise&quot;&gt;https://github.com/penghuwan/body-parser-promise&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.npmjs.com/package/body-parser-promise&quot;&gt;https://www.npmjs.com/package/body-parser-promise&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Koa-bodyparser &lt;a href=&quot;https://github.com/koajs/bodyparser&quot;&gt;https://github.com/koajs/bodyparser&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;上一篇文章&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/penghuwan/p/11366446.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;span&gt;如何用JavaScript测网速&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【完】&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 19 Aug 2019 00:17:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<og:description>bodyparser是一类处理request的body的中间件函数，例如Koa-bodyparser就是和Koa框架搭配使用的中间件。本文介绍了一个 Promise风格的bodyparser，接收re</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/penghuwan/p/11374268.html</dc:identifier>
</item>
<item>
<title>聊一聊数据库中的锁 - 码农阿宇</title>
<link>http://www.cnblogs.com/CoderAyu/p/11375088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoderAyu/p/11375088.html</guid>
<description>&lt;p&gt;数据库中有一张叫&lt;code&gt;后宫佳丽&lt;/code&gt;的表,每天都有几百万新的小姐姐插到表中,光阴荏苒,夜以继日,日久生情,时间长了,表中就有了几十亿的&lt;code&gt;小姐姐&lt;/code&gt;数据,看到几十亿的小姐姐,每到晚上,我可愁死了,这么多小姐姐,我翻张牌呢?&lt;br/&gt;办法当然是精兵简政,删除那些&lt;code&gt;age&amp;gt;18&lt;/code&gt;的,给年轻的小姐姐们留位置...&lt;br/&gt;于是我在数据库中添加了一个定时执行的小程序,每到周日,就自动运行如下的脚本&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;delete from `后宫佳丽` where age&amp;gt;18&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一开始还自我感觉良好,后面我就发现不对了,每到周日,这个脚本一执行就是一整天,运行的时间有点长是小事,重点是这大好周日,我再想读这张表的数据,怎么也读不出来了,怎是一句空虚了得,我好难啊!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/iBlogsRepository/Blogs/pic/%E9%9A%BE.gif&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;

&lt;p&gt;编不下去了,真实背景是公司中遇到的一张有海量数据表,每次一旦执行历史数据的清理,我们的程序就因为读不到这张表的数据,疯狂地报错,后面一查了解到,原来是因为定时删除的语句设计不合理,导致数据库中数据由行锁(&lt;code&gt;Row lock&lt;/code&gt;)升级为表锁(&lt;code&gt;Table lock&lt;/code&gt;)了😂.&lt;br/&gt;解决这个问题的过程中把数据库锁相关的学习了一下,这里把学习成果,分享给大家,希望对大家有所帮助.&lt;br/&gt;我将讨论SQL Server锁机制以及如何使用SQL Server标准动态管理视图监视SQL Server 中的锁,相信其他数据的锁也大同小异,具有一定参考意义.&lt;/p&gt;

&lt;p&gt;在我开始解释SQL Server锁定体系结构之前，让我们花点时间来描述ACID（原子性，一致性，隔离性和持久性）是什么。ACID是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）。&lt;/p&gt;
&lt;h2 id=&quot;acid&quot;&gt;ACID&lt;/h2&gt;
&lt;h3 id=&quot;原子性atomicity&quot;&gt;原子性(Atomicity)&lt;/h3&gt;
&lt;p&gt;一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。&lt;/p&gt;
&lt;h3 id=&quot;一致性consistency&quot;&gt;一致性(Consistency)&lt;/h3&gt;
&lt;p&gt;在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。&lt;/p&gt;
&lt;h3 id=&quot;隔离性isolation&quot;&gt;隔离性(Isolation)&lt;/h3&gt;
&lt;p&gt;数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。&lt;/p&gt;
&lt;h3 id=&quot;持久性durability&quot;&gt;持久性(Durability)&lt;/h3&gt;
&lt;p&gt;事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。&lt;/p&gt;
&lt;p&gt;来源:维基百科 https://zh.wikipedia.org/wiki/ACID&lt;/p&gt;
&lt;h2 id=&quot;事务-transaction&quot;&gt;事务 (Transaction:)&lt;/h2&gt;
&lt;p&gt;事务是进程中最小的堆栈，不能分成更小的部分。此外，某些事务处理组可以按顺序执行，但正如我们在原子性原则中所解释的那样，即使其中一个事务失败，所有事务块也将失败。&lt;/p&gt;
&lt;h2 id=&quot;锁定-lock&quot;&gt;锁定 (Lock)&lt;/h2&gt;
&lt;p&gt;锁定是一种确保数据一致性的机制。SQL Server在事务启动时锁定对象。事务完成后，SQL Server将释放锁定的对象。可以根据SQL Server进程类型和隔离级别更改此锁定模式。这些锁定模式是：&lt;/p&gt;
&lt;h3 id=&quot;锁定层次结构&quot;&gt;锁定层次结构&lt;/h3&gt;
&lt;p&gt;SQL Server具有锁定层次结构，用于获取此层次结构中的锁定对象。数据库位于层次结构的顶部，行位于底部。下图说明了SQL Server的锁层次结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/iBlogsRepository/Blogs/pic/hierarchy.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;共享s锁-shared-s-locks&quot;&gt;共享（S）锁 (Shared (S) Locks)&lt;/h3&gt;
&lt;p&gt;当需要读取对象时，会发生此锁定类型。这种锁定类型不会造成太大问题。&lt;/p&gt;
&lt;h3 id=&quot;独占x锁定-exclusive-x-locks&quot;&gt;独占（X）锁定 (Exclusive (X) Locks)&lt;/h3&gt;
&lt;p&gt;发生此锁定类型时，会发生以防止其他事务修改或访问锁定对象。&lt;/p&gt;
&lt;h3 id=&quot;更新u锁-update-u-locks&quot;&gt;更新（U）锁 (Update (U) Locks)&lt;/h3&gt;
&lt;p&gt;此锁类型与独占锁类似，但它有一些差异。我们可以将更新操作划分为不同的阶段：读取阶段和写入阶段。在读取阶段，SQL Server不希望其他事务有权访问此对象以进行更改,因此，SQL Server使用更新锁。&lt;/p&gt;
&lt;h3 id=&quot;意图锁定-intent-locks&quot;&gt;意图锁定 (Intent Locks)&lt;/h3&gt;
&lt;p&gt;当SQL Server想要在锁定层次结构中较低的某些资源上获取共享（S）锁定或独占（X）锁定时，会发生意图锁定。实际上，当SQL Server获取页面或行上的锁时，表中需要设置意图锁。&lt;/p&gt;

&lt;p&gt;了解了这些背景知识后，我们尝试再SQL Server找到这些锁。SQL Server提供了许多动态管理视图来访问指标。要识别SQL Server锁，我们可以使用sys.dm_tran_locks视图。在此视图中，我们可以找到有关当前活动锁管理的大量信息。&lt;/p&gt;
&lt;p&gt;在第一个示例中，我们将创建一个不包含任何索引的演示表，并尝试更新此演示表。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE TestBlock
(Id INT ,
Nm VARCHAR(100))

INSERT INTO TestBlock
values(1,'CodingSight')
In this step, we will create an open transaction and analyze the locked resources.
BEGIN TRAN
UPDATE TestBlock SET   Nm='NewValue_CodingSight' where Id=1
select @@SPID&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/iBlogsRepository/Blogs/pic/update-demo-table.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再获取到了SPID后，我们来看看&lt;code&gt;sys.dm_tran_lock&lt;/code&gt;视图里有什么。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select * from sys.dm_tran_locks  WHERE request_session_id=74&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/iBlogsRepository/Blogs/pic/sys.dm_tran_lock-view-1.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此视图返回有关活动锁资源的大量信息,但是是一些我们难以理解的一些数据。因此，我们必须将&lt;code&gt;sys.dm_tran_locks&lt;/code&gt; join 一些其他表。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT dm_tran_locks.request_session_id,
       dm_tran_locks.resource_database_id,
       DB_NAME(dm_tran_locks.resource_database_id) AS dbname,
       CASE
           WHEN resource_type = 'OBJECT'
               THEN OBJECT_NAME(dm_tran_locks.resource_associated_entity_id)
           ELSE OBJECT_NAME(partitions.OBJECT_ID)
       END AS ObjectName,
       partitions.index_id,
       indexes.name AS index_name,
       dm_tran_locks.resource_type,
       dm_tran_locks.resource_description,
       dm_tran_locks.resource_associated_entity_id,
       dm_tran_locks.request_mode,
       dm_tran_locks.request_status
FROM sys.dm_tran_locks
LEFT JOIN sys.partitions ON partitions.hobt_id = dm_tran_locks.resource_associated_entity_id
LEFT JOIN sys.indexes ON indexes.OBJECT_ID = partitions.OBJECT_ID AND indexes.index_id = partitions.index_id
WHERE resource_associated_entity_id &amp;gt; 0
  AND resource_database_id = DB_ID()
 and request_session_id=74
ORDER BY request_session_id, resource_associated_entity_id&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/iBlogsRepository/Blogs/pic/join-sys.dm_tran_locks-view-to-other-views-1.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，您可以看到锁定的资源。SQL Server获取该行中的独占锁。（RID：用于锁定堆中单个行的行标识符）同时，SQL Server获取页中的独占锁和TestBlock表意向锁。这意味着在SQL Server释放锁之前，任何其他进程都无法读取此资源,这是SQL Server中的基本锁定机制。&lt;/p&gt;
&lt;p&gt;现在，我们将在测试表上填充一些合成数据。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;TRUNCATE TABLE    TestBlock
DECLARE @K AS INT=0
WHILE @K &amp;lt;8000
BEGIN
INSERT TestBlock VALUES(@K, CAST(@K AS varchar(10)) + ' Value' )
SET @K=@K+1
 END
--After completing this step, we will run two queries and check the sys.dm_tran_locks view.
BEGIN TRAN
 UPDATE TestBlock  set Nm ='New_Value' where Id&amp;lt;5000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/iBlogsRepository/Blogs/pic/check-sys.dm_tran_locks-view-2.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的查询中，SQL Server获取每一行的独占锁。现在，我们将运行另一个查询。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;BEGIN TRAN
 UPDATE TestBlock  set Nm ='New_Value' where Id&amp;lt;7000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/iBlogsRepository/Blogs/pic/run-another-query-1.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的查询中，SQL Server在表上创建了独占锁，因为SQL Server尝试为这些将要更新的行获取大量RID锁,这种情况会导致数据库引擎中的大量资源消耗,因此，SQL Server会自动将此独占锁定移动到锁定层次结构中的上级对象(Table)。我们将此机制定义为Lock Escalation, 这就是我开篇所说的锁升级,它由行锁升级成了表锁。&lt;/p&gt;
&lt;p&gt;根据官方文档的描述存在以下任一条件，则会触发锁定升级：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;单个Transact-SQL语句在单个非分区表或索引上获取至少5,000个锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;单个Transact-SQL语句在分区表的单个分区上获取至少5,000个锁，并且ALTER TABLE SET LOCK_ESCALATION选项设置为AUTO。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;数据库引擎实例中的锁数超过了内存或配置阈值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008-r2/ms184286(v=sql.105)&lt;/p&gt;

&lt;p&gt;防止锁升级的最简单，最安全的方法是保持事务的简短，并减少昂贵查询的锁占用空间，以便不超过锁升级阈值,有几种方法可以实现这一目标.&lt;/p&gt;
&lt;h2 id=&quot;将大批量操作分解为几个较小的操作&quot;&gt;将大批量操作分解为几个较小的操作&lt;/h2&gt;
&lt;p&gt;例如，在我开篇所说的在几十亿条数据中删除小姐姐的数据：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;delete from `后宫佳丽` where age&amp;gt;18&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以不要这么心急,一次只删除500个，可以显着减少每个事务累积的锁定数量并防止锁定升级。例如：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SET ROWCOUNT 500
delete_more:
     delete from `后宫佳丽` where age&amp;gt;18
IF @@ROWCOUNT &amp;gt; 0 GOTO delete_more
SET ROWCOUNT 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建索引使查询尽可能高效来减少查询的锁定占用空间&quot;&gt;创建索引使查询尽可能高效来减少查询的锁定占用空间&lt;/h2&gt;
&lt;p&gt;如果没有索引会造成表扫描可能会增加锁定升级的可能性, 更可怕的是，它增加了死锁的可能性，并且通常会对并发性和性能产生负面影响。&lt;br/&gt;根据查询条件创建合适的索引,最大化提升索引查找的效率,此优化的一个目标是使索引查找返回尽可能少的行，以最小化查询的的成本。&lt;/p&gt;
&lt;h2 id=&quot;如果其他spid当前持有不兼容的表锁则不会发生锁升级&quot;&gt;如果其他SPID当前持有不兼容的表锁，则不会发生锁升级&lt;/h2&gt;
&lt;p&gt;锁定升级始总是升级成表锁，而不会升级到页面锁定。如果另一个SPID持有与升级的表锁冲突的IX（intent exclusive）锁定，则它会获取更细粒度的级别（行，key或页面）锁定，定期进行额外的升级尝试。表级别的IX（intent exclusive）锁定不会锁定任何行或页面，但它仍然与升级的S（共享）或X（独占）TAB锁定不兼容。&lt;br/&gt;如下所示,如果有个操作始终在不到一小时内完成，您可以创建包含以下代码的sql，并安排在操作的前执行&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;BEGIN TRAN
SELECT * FROM mytable (UPDLOCK, HOLDLOCK) WHERE 1=0
WAITFOR DELAY '1:00:00'
COMMIT TRAN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此查询在mytable上获取并保持IX锁定一小时，这可防止在此期间对表进行锁定升级。&lt;/p&gt;

&lt;p&gt;好了,不说了,小姐姐们因为不想离我开又打起来了(死锁).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/liuzhenyulive/iBlogsRepository/Blogs/pic/ending.png&quot; alt=&quot;Alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考文献:&lt;br/&gt;SQL Server Transaction Locking and Row Versioning Guide https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-guides/jj856598(v=sql.110)&lt;br/&gt;SQL Server, Locks Object https://docs.microsoft.com/en-us/sql/relational-databases/performance-monitor/sql-server-locks-object?view=sql-server-2017&lt;br/&gt;How to resolve blocking problems that are caused by lock escalation in SQL Server https://support.microsoft.com/es-ve/help/323630/how-to-resolve-blocking-problems-that-are-caused-by-lock-escalation-in&lt;br/&gt;Main concept of SQL Server locking https://codingsight.com/main-concept-of-sql-server-locking/&lt;/p&gt;
</description>
<pubDate>Mon, 19 Aug 2019 00:14:00 +0000</pubDate>
<dc:creator>码农阿宇</dc:creator>
<og:description>背景 数据库中有一张叫 的表,每天都有几百万新的小姐姐插到表中,光阴荏苒,夜以继日,日久生情,时间长了,表中就有了几十亿的 数据,看到几十亿的小姐姐,每到晚上,我可愁死了,这么多小姐姐,我翻张牌呢?</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CoderAyu/p/11375088.html</dc:identifier>
</item>
<item>
<title>看遍天下程序，心中自然有码 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/11375077.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/11375077.html</guid>
<description>&lt;p&gt;上次玩数独（&lt;a href=&quot;https://blog.csdn.net/moonhmilyms/article/details/98711840&quot;&gt;旁友数独会伐啦？python秒解数独了解下伐啦？&lt;/a&gt;）的事情给老王气的……这次我直接掏出了照片，看看他的反应。&lt;/p&gt;
&lt;p&gt;小胖这次要人码结合，看看他闹哪样。&lt;/p&gt;
&lt;p&gt;那作为一名合格的程序员，怎么能不懂二维码是如何生成，如何解析，如何玩耍的呢？废话不多说，咱们今天就用Python来玩玩这个人码合一。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;操作系统：windows10&lt;/li&gt;
&lt;li&gt;python版本：python 3.7&lt;/li&gt;
&lt;li&gt;代码编辑器：pycharm 2018.2&lt;/li&gt;
&lt;li&gt;使用模块：zxing,myqr,qrcode&lt;/li&gt;
&lt;li&gt;tips: 上面的模块都使用pip安装，它们依赖的模块也会自动安装，相信会Python的你对pip不会太陌生。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;pip install qrcode
pip install myqr
pip install zxing&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;首先我们来生成一个 “Hello World”。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import qrcode

def first_demo():
    # 存储的字符串
    qr = qrcode.make('Hello World')
    qr.get_image().show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的步骤就完成了这个经典入门，拿出你的手机，用微信、QQ扫码，就会出现“Hello World”字眼，有没有勾起你初学Python的回忆呢。&lt;/p&gt;
&lt;p&gt;刚才只是小试牛刀，我们来一个进阶，把生成的二维码保存到本地。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import qrcode

def second_demo():
    text = 'Python专栏'
    img = qrcode.make(text)
    # 需要传一个参数 文件名
    img.save('qr.png')
    img.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190819080611771-404487670.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我公众号二维码大家应该很熟悉了吧，上面步骤生成的都是纯二维码，不符合我们的气质。接下来我要使用qrcode库生成带有内嵌图片的二维码。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from PIL import Image
import qrcode

def create_icon_qrcode():
    qr = qrcode.QRCode(
        # 二维码size尺寸大小。官方称为version
        version=1,
        # 二维码错误处理级别，有四种方式，稍后给出解释
        error_correction=qrcode.constants.ERROR_CORRECT_H,
        # 二维码图片的大小
        box_size=10,
        # 二维码白色边框的大小
        border=2
    )

    # 添加数据
    qr.add_data('小可爱你好，我是波多野结衣老湿')
    # 填充数据
    qr.make(fit=True)
    # 生成二维码图片        指定填充颜色        指定背景颜色
    img = qr.make_image(fill_color='grey',back_color='white')

    # 得到生成的二维码图片的宽，高
    img_w,img_h = img.size

    # 添加图片到二维码中
    # 使用pillow的Image打开图片
    icon = Image.open('girl.jpg')

    # 设置icon的大小,为二维码图片大小的6分之一
    factor = 3
    size_w = img_w // factor
    size_h = img_h // factor

    # 得到icon图片的大小
    icon_w,icon_h = icon.size

    # 只有当我们icon图片的大小超过了二维码图片的3分之一的时候，才对icon图片大小重新定义大小。
    if icon_w &amp;gt; size_w:
        icon_w = size_w
    if icon_h &amp;gt; size_h:
        icon_h = size_h

    # 重新设置icon的尺寸
    icon = icon.resize((icon_w,icon_h),Image.ANTIALIAS)
    # 得到在二维码中显示的位置，坐标。
    w =  (img_w - icon_w) // 2
    h =  (img_h - icon_h) // 2

    img.paste(icon,(w,h),mask=None)
    img.save('girl.png')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说一下version参数和error_correction参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;version: 就是二维码图片的size，官方称作为version。version为1的时候，二维码就是2121组成的正方形，version为2的话就是2525，version为3的话就是2929。最大为40。所以说最大的尺寸为(40 - 1) * 4 + 21 = 177. 也就是177177 正方形。&lt;/li&gt;
&lt;li&gt;error_correction: 纠错级别，级别越高，纠错能力越强。这也就是为什么我们的二维码残缺了一点点，也能够正确的读取到信息的原因。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;L水平: 7%的字码可被修正&lt;/li&gt;
&lt;li&gt;M水平: 15%的字码可被修正&lt;/li&gt;
&lt;li&gt;Q水平: 25%的字码可被修正&lt;/li&gt;
&lt;li&gt;H水平: 30%的字码可被修正&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过上面的步骤，就生成了一张灰色背景填充的二维码，最最核心的中间部分……她是谁？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190819080625085-1468453799.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;github地址： https://github.com/lincolnloop/python-qrcode&lt;/p&gt;
&lt;p&gt;上面就是qrcode库的基本使用。接下来再介绍一下MyQr库。这个库就相当强大，强大到可以使用图片作为二维码的背景，甚至是动态图。&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import os
from MyQR import myqr

def myqr_demo():
    # 注意，这里的字符串不能出现中文，只能以下这些
    # supported_chars = r&quot;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ··,.:;+-*/\~!@#$%^&amp;amp;`'=&amp;lt;&amp;gt;[]()?_{}|&quot;
    words = 'hello world'
    # 调用myqr.run方法，就能够生成图片了。返回三个值，二维码的version，纠错级别，二维码的完整路径
    version, level, qr_name = myqr.run(
        # 存放的数据
        words=words,
        # 二维码size
        version=10,
        # 选取的背景图片
        picture='girl.jpg',
        # 是否为彩色。如果为False，那么就是黑白的
        colorized=True,
        # 保存到本地的名字
        save_name='girl_img.png',
        # 保存二维码的目录,这里就是当前目录。默认就是这个
        save_dir=os.getcwd()
    )
    print(version,level,qr_name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行以上代码，我们就可以生成一张以我们图片作为背景的二维码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190819080654510-152265763.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果需要将动态图作为背景图，其实也和正常的背景图类似，只需要写入背景图的文件名就行了，然后保存图片的时候，将二维码的后缀名改成gif即可.&lt;/p&gt;
&lt;p&gt;github地址: https://github.com/sylnsfar/qrcode&lt;/p&gt;
&lt;p&gt;这里简单的比较一下这两个库吧&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;qrcode支持中文数据，而myqr不支持中文等字符。&lt;/li&gt;
&lt;li&gt;qrcode不能设置背景图，但是能将图片放在二维码中间。&lt;/li&gt;
&lt;li&gt;myqr可以将背景设置为图片，并且允许为动态图。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面我们只说了如何生成二维码图片。接下来介绍下如何解析二维码中的信息。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import zxing

def parse_qrcode(filename):
    reader = zxing.BarCodeReader()
    barcode = reader.decode(filename)
    print(barcode.parsed)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;短短的几行代码，就能解析出复杂而又简单的二维码，并且得到里面的详细数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果二维码中的数据包含中文，那么应该会报这样的错误。UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc0 in position 0: invalid start byte 这个时候只需要修改一下这个库的源码就行了。&lt;/p&gt;
&lt;p&gt;修改位置在zxing包下面的 &lt;code&gt;__init__.py&lt;/code&gt; 文件中第81行代码处。&lt;/p&gt;
&lt;p&gt;原来是这样的&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;raw = raw[:-1].decode()
parsed = parsed[:-1].decode()
return cls(format, type, raw, parsed, points)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要修改为下面这样&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;raw = raw[:-1].decode(encoding='gbk')
parsed = parsed[:-1].decode(encoding='gbk')
return cls(format, type, raw, parsed, points)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就不会出错了。&lt;/p&gt;
&lt;p&gt;这样，我们就成功的对二维码进行解析了。&lt;/p&gt;
&lt;p&gt;本文全套代码已上传至Github：https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/App/QRcode&lt;/p&gt;
&lt;p&gt;更多好玩有趣的Python内容，关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」&lt;/p&gt;
</description>
<pubDate>Mon, 19 Aug 2019 00:07:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>上次玩数独（[旁友数独会伐啦？python秒解数独了解下伐啦？](https://blog.csdn.net/moonhmilyms/article/details/98711840)）的事情给老王气</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moonhmily/p/11375077.html</dc:identifier>
</item>
<item>
<title>服务注册组件——Eureka高可用集群搭建 - noneplus</title>
<link>http://www.cnblogs.com/noneplus/p/11374883.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noneplus/p/11374883.html</guid>
<description>&lt;h2 id=&quot;什么是eureka&quot;&gt;什么是Eureka？&lt;/h2&gt;
&lt;p&gt;服务注册组件：将微服务注册到Eureka中。&lt;/p&gt;

&lt;h2 id=&quot;为什么需要服务注册&quot;&gt;为什么需要服务注册？&lt;/h2&gt;
&lt;p&gt;微服务开发重点在一个&quot;微&quot;字，大型应用拆分成微型服务，意味着服务的数量不可能少。&lt;/p&gt;

&lt;p&gt;服务之间存在调用关系，假设没有服务注册，微服务之间的调用关系就会是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015950822-1280141830.png&quot; alt=&quot;1566142251076&quot;/&gt;&lt;/p&gt;
&lt;p&gt;微服务的部署可能不会在同一台服务器上，而是需要通过远程调用，然后就涉及到IP地址了。理论上来说，直接通过IP地址直接通信也没有什么问题。 但是如果服务出问题，需要换一台服务器部署，ip地址就需要更改了。同时如果该服务被多个其他服务依赖，那么每一个IP地址都需要重置。&lt;/p&gt;

&lt;p&gt;服务注册可以形象的理解为一张表，表的左边写着服务名称，而右侧对应的是IP地址。服务的调用使用名称来替代IP地址，那么当IP地址发生改变，直接修改服务注册中心的名称与IP的映射关系。其他服务由于是用名称来远程调用，所以并不需要更改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015944783-1802757026.png&quot; alt=&quot;1566142633779&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;eureka与zookeeper的区别&quot;&gt;Eureka与Zookeeper的区别&lt;/h2&gt;
&lt;p&gt;Eureka满足Ap原则，而Zookeeper满足CP原则。&lt;/p&gt;
&lt;p&gt;（CAP定理，指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者最多同时满足俩）&lt;/p&gt;

&lt;h2 id=&quot;eureka三个角色&quot;&gt;Eureka三个角色&lt;/h2&gt;
&lt;p&gt;Eureka Server 提供服务注册和发现&lt;/p&gt;
&lt;p&gt;Service Provider服务提供方将自身服务注册到Eureka，从而使服务消费方能够找到&lt;/p&gt;
&lt;p&gt;Service Consumer服务消费方从Eureka获取注册服务列表，从而能够消费服务&lt;/p&gt;

&lt;p&gt;消费方与提供方：调用另一个服务称为消费。被另一个服务调用称为提供。&lt;/p&gt;
&lt;p&gt;所以，同一个服务可能既是消费方也是提供方。&lt;/p&gt;
&lt;p&gt;【注】：Eureka隐藏IP地址的功能体现在整个微服务的内部。&lt;/p&gt;



&lt;h2 id=&quot;创建工程&quot;&gt;创建工程&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;创建文件夹Eureka Cluster，用IDEA打开：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015937962-947440146.png&quot; alt=&quot;1566144926784&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;创建msc-eureka-6001，msc-eureka-6002，msc-eureka-6003工程【jdk1.8】，&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015932116-1373589257.png&quot; alt=&quot;1566145227822&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015920714-991091724.png&quot; alt=&quot;1566145305544&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015914731-1406483163.png&quot; alt=&quot;1566145472114&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;导入pom依赖&quot;&gt;导入pom依赖&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Greenwich.SR2&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;配置application.yaml&quot;&gt;配置application.yaml&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;配置地址映射&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;C:\Windows\System32\drivers\etc&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015909115-1168659341.png&quot; alt=&quot;1566147466705&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015901562-1860411129.png&quot; alt=&quot;1566147557267&quot;/&gt;&lt;/p&gt;

&lt;p&gt;msc-eureka-6001，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 6001

eureka:
  instance:
    hostname: eureka6001.com  #eureka服务端的实例名称
  client:
    register-with-eureka: false   #false表示不向注册中心注册自己。
    fetch-registry: false      #false表示自己是注册中心，职责是维护服务，而不是调用服务
    service-url:
      defaultZone: http://eureka6003.com:6003/eureka/,http://eureka6002.com:6002/eureka/ # 注册到eureka6003和eureka6002里&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;msc-eureka-6002，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 6002

eureka:
  instance:
    hostname: eureka6002.com  #eureka服务端的实例名称
  client:
    register-with-eureka: false   #false表示不向注册中心注册自己。
    fetch-registry: false      #false表示自己是注册中心，职责是维护服务，而不是调用服务
    service-url:
      defaultZone: http://eureka6001.com:6001/eureka/,http://eureka6003.com:6003/eureka/&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;msc-eureka-6003&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;server:
  port: 6003

eureka:
  instance:
    hostname: eureka6003.com  #eureka服务端的实例名称
  client:
    register-with-eureka: false   #false表示不向注册中心注册自己。
    fetch-registry: false      #false表示自己是注册中心，职责是维护服务，而不是调用服务
    service-url:
      defaultZone: http://eureka6001.com:6001/eureka/,http://eureka6002.com:6002/eureka/&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;创建主启动类并添加注解enableeurekaserver&quot;&gt;创建主启动类并添加注解@EnableEurekaServer&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;package zkrun.top;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;

@EnableEurekaServer // EurekaServer服务器端启动类,接受其它微服务注册进来
@SpringBootApplication
public class App_msc_eureka_6001
{
    public static void main(String[] args)
    {
        SpringApplication.run(App_msc_eureka_6001.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;启动eureka集群&quot;&gt;启动Eureka集群&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015855179-125132088.png&quot; alt=&quot;1566148589864&quot;/&gt;&lt;/p&gt;

&lt;p&gt;访问任意一个端口，都会显示另外两个Eureka服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015849217-468052850.png&quot; alt=&quot;1566148651864&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;创建注册服务测试eureka集群的高可用性&quot;&gt;创建注册服务测试Eureka集群的高可用性&lt;/h2&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;新建工程msc-provider-5001&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;导入pom依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.7.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;spring-cloud.version&amp;gt;Greenwich.SR2&amp;lt;/spring-cloud.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&amp;lt;!--        Eureka客户端启动需要依赖web模块--&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-dependencies&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${spring-cloud.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;scope&amp;gt;import&amp;lt;/scope&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;配置application.yaml&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;server:
  port: 5001
spring:
  application:
    name: msc-provider  #应用名称
eureka:
  client:
    service-url:
      defaultZone: http://eureka6001.com:6001/eureka/,http://eureka6002.com:6002/eureka/,http://eureka6003.com:6003/eureka/
  instance:
    instance-id: msc-provider-5001
    prefer-ip-address: true     #访问路径可以显示IP地址&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;创建主启动类添加注解@EnableEurekaClient&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;package zkrun.top;


import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;

@SpringBootApplication
@EnableEurekaClient
public class App_msc_provider_5001
{
    public static void main(String[] args)
    {
        SpringApplication.run(App_msc_provider_5001.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015843069-1326907586.png&quot; alt=&quot;1566150379362&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;测试Eureka集群高可用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;手动停掉eureka6001，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015834295-1441147906.png&quot; alt=&quot;1566150405399&quot;/&gt;&lt;/p&gt;

&lt;p&gt;eureka6001无法访问：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015828313-1595587255.png&quot; alt=&quot;1566150455835&quot;/&gt;&lt;/p&gt;

&lt;p&gt;6002和6003仍然提供注册服务：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015822136-2096885113.png&quot; alt=&quot;1566150489889&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1401585/201908/1401585-20190819015811191-1115807439.png&quot; alt=&quot;1566150527456&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;ul&gt;&lt;li&gt;三个Eureka和注册服务都没有继承父工程，其pom依赖都是独立的。其中注册服务依赖spring-boot-starter-web。今后在设计父工程的pom时，应该考虑到每个子工程的依赖。&lt;/li&gt;
&lt;li&gt;与Eureka同级别的服务注册组件还有Zookeeper，Consul等。根据具体的应用场景和组件的优势来决定技术选取是软件开发更应该注意的。（除了Eureka之外，同级别的其他组件也需要了解）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码参考：https://github.com/HCJ-shadow/Eureka-Cluster&lt;/p&gt;
</description>
<pubDate>Sun, 18 Aug 2019 18:17:00 +0000</pubDate>
<dc:creator>noneplus</dc:creator>
<og:description>﻿ 什么是Eureka？ 服务注册组件：将微服务注册到Eureka中。 为什么需要服务注册？ 微服务开发重点在一个'微'字，大型应用拆分成微型服务，意味着服务的数量不可能少。 服务之间存在调用关系，假</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/noneplus/p/11374883.html</dc:identifier>
</item>
<item>
<title>JS数据结构第五篇 --- 二叉树和二叉查找树 - TDX</title>
<link>http://www.cnblogs.com/tandaxia/p/11234454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tandaxia/p/11234454.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、二叉树的基本概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从逻辑结构角度来看，前面说的链表、栈、队列都是线性结构；而今天要了解的“二叉树”属于树形结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454511/201907/454511-20190723195810865-133799092.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1 多叉树的基本概念，以上图中“多叉树”为例说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;节点&lt;/strong&gt;：多叉树中的每一个点都叫&lt;strong&gt;节点&lt;/strong&gt;；其中最上面的那个节点叫“&lt;strong&gt;根节点&lt;/strong&gt;”；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;父节点&lt;/strong&gt;：节点1是节点2/3/4/5/6的&lt;strong&gt;父节点&lt;/strong&gt;，然后节点2/3/4/5/6是节点1的&lt;strong&gt;子节点&lt;/strong&gt;；节点2/3/4/5/6又是互为&lt;strong&gt;兄弟节点&lt;/strong&gt;，因为它们有父节点为同一个节点；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;空树&lt;/strong&gt;：一个没有任何节点的树叫&lt;strong&gt;空树&lt;/strong&gt;；一棵树可以只有一个节点，也就是只有根节点；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;子树&lt;/strong&gt;：子节点及子节点的后台节点形成的一个节点集合叫子树；对于只有两个子节点的节点，其左边的子节点叫左子树，右边的叫右子树；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;叶子节点（leaf）&lt;/strong&gt;：子树为0的节点；其他子树不为0的节点叫“&lt;strong&gt;非叶子节点&lt;/strong&gt;”；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;层数（level）&lt;/strong&gt;：根节点在第1层，根节点的子节点在第2层，以此类推（有些说法也从第0层开始结算）；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;节点的深度(depth)&lt;/strong&gt;：从根节点到当前节点的唯一路径上的节点总数；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;节点的高度(height)&lt;/strong&gt;：从当前节点到最远叶子节点的路径上的节点总数；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;树的深度&lt;/strong&gt;：所有节点深度中的最大值；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;树的高度&lt;/strong&gt;：所以节点高度中的最大值；&lt;strong&gt;数的深度等于数的高度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;有序树&lt;/strong&gt;：树中任意节点的子节点之间有顺序关系；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;无序树&lt;/strong&gt;：树中任意节点的子节点之间没有顺序关系，也叫“自由树”；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;森林&lt;/strong&gt;：由n(n &amp;gt;= 0) 颗不相交的树组成的集合；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 二叉树的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个节点的度最大为2(最多拥有2颗子树)；&lt;/li&gt;
&lt;li&gt;左子树和右子树是有顺序的。即使某节点只有一颗子树，也要区分左右子树；&lt;/li&gt;
&lt;li&gt;非空二叉树的第i层，最多有2^(i-1)个节点（i &amp;gt;= 1)&lt;/li&gt;
&lt;li&gt;在高度为h的二叉树上最多有2^h - 1个节点（h &amp;gt;= 1);&lt;/li&gt;
&lt;li&gt;对于任何一颗非空二叉树，如果叶子节点个数为n0, 度为2的节点个数为n2, 则有n0 = n2 + 1。（这个好理解，假如这个二叉树除了第一级节点有2个子节点，后面的节点都是只有一个子节点，则不管这颗二叉树如何往下延伸，永远度为2的节点个数是1个，叶子节点为2个；然后如果在这个二叉树的中间节点，每加一个节点，相当于度为2的节点加一个，叶子节点也加一个，则度为2的节点和叶子节点的增加是同步同数量的，所以对于二叉树，叶子节点个数 = 度为2的节点个数 + 1 公式是永远成立的）&lt;/li&gt;
&lt;li&gt;假设度为1的节点个数为n1, 那么二叉树的节点总数 n = n0 + n1 + n2。则二叉树的边数T = n1 + 2 * n2 = n -1 = n0 + n1 + n2 -1  --&amp;gt; n2 + 1 = n0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1.3 真二叉树/满二叉树/完全二叉树&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;真二叉树：所有节点的度都要么为2，要么为0；&lt;/li&gt;
&lt;li&gt;满二叉树：所有节点的度都要么为2，要么为0，且所有的叶子节点都在最后一层；
&lt;ul&gt;&lt;li&gt;假设满二叉树的高度为h (h&amp;gt;=1)，那么第i层的节点数量：2^(i-1), 叶子节点数量：2(^h-1), 总节点数量n = 2^h -1 = 2^0 + 2^1 + 2^2 + ... + 2^(h-1)&lt;/li&gt;
&lt;li&gt;等比数列公式：a1=1, 公比q=2, 则an = a1*q^(n-1)=2^(n-1), 前n项之和Sn = a1+a2+...+an = 2^0 + 2^1 + 2^2 + ... + 2^(n-1) = a1(1-q^n)/(1-q)=2^n-1&lt;/li&gt;
&lt;li&gt;在同样高度的二叉树中，满二叉树的叶子节点数量最多、总节点数量最多；&lt;/li&gt;
&lt;li&gt;满二叉树一定是真二叉树，真二叉树不一定是满二叉树；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;完全二叉树：叶子节点只会出现在最后两层，且最后一层的叶子节点都靠左对齐；
&lt;ul&gt;&lt;li&gt;完全二叉树从根节点到倒数第二层是一颗满二叉树；满二叉一定是完全二叉树，完全二叉树不一定是满二叉树；&lt;/li&gt;
&lt;li&gt;度为1的节点只有左子树；度为1的节点要么是1个，要么是0个；&lt;/li&gt;
&lt;li&gt;假设完全二叉树的高度为h(h&amp;gt;=1), 那么至少有2^(h-1) 个节点(2^0 + 2^1 + 2^2 + ... + 2^(h-2) + 1), 最多有2^h - 1个节点(2^0 + 2^1 + 2^2 + ...+ 2^(h-1), 满二叉树)；总节点数量为n, 则有2^(h-1) &amp;lt;= n &amp;lt; 2^h  --&amp;gt;  h-1 &amp;lt;= log(2)(n) &amp;lt; h --&amp;gt; h = floor(log(2)(n)) + 1  (floor是向下取整，ceiling是向上取整)&lt;/li&gt;
&lt;li&gt;一颗有n个节点的完全二叉树(n &amp;gt; 0），从上到下，从左到右对节点从1开始进行编号，对任意第i个节点
&lt;ul&gt;&lt;li&gt;如果i = 1, 它是根节点&lt;/li&gt;
&lt;li&gt;如果i &amp;gt; 1, 它的父节点编号为floor(i/2)&lt;/li&gt;
&lt;li&gt;如果2i &amp;lt;= n, 它的左子节点编号为2i&lt;/li&gt;
&lt;li&gt;如果2i &amp;gt; n, 它无左子节点&lt;/li&gt;
&lt;li&gt;如果2i + 1 &amp;lt;= n, 它的右子节点编号为2i + 1&lt;/li&gt;
&lt;li&gt;如果2i + 1 &amp;gt; n , 它无右子节点　　&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454511/201908/454511-20190818154615666-1727272705.jpg&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/454511/201908/454511-20190818154623670-1388754390.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;面试题：如果一颗完全二叉树有768个节点，求叶子节点的个数？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;分析：假设叶子节点个数为n0，度为1的节点个数为n1，度为2的节点个数为n2。&lt;/p&gt;
&lt;p&gt;　　则总节点个数n = n0  +  n1 +  n2，而且n0 = n2 + 1 ;&lt;/p&gt;
&lt;p&gt;　　则n = 2n0 + n1 -1&lt;/p&gt;
&lt;p&gt;　　根据完全二叉树的定义我们知道，n1要么为0，要么为1：&lt;/p&gt;
&lt;p&gt;　　当n1为1时， n = 2n0,  n必然为偶数。叶子节点个数n0 = n / 2，非叶子节点个数 n1 + n2 = n / 2 ；&lt;/p&gt;
&lt;p&gt;　　当n1为0，n = 2n0 - 1，n必然为奇数。叶子节点个数n0 = (n + 1) / 2， 非叶子节点个数 n1 + n2 = (n - 1) / 2&lt;/p&gt;
&lt;p&gt;　　因此可以判断出来当这个完全二叉树有768个节点时，它的叶子节点个数为：384&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、二叉查找树&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二叉查找树是一种特殊的二叉树，较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得查找的效率很高，对于数值型和非数值型的数据，如单词和字符串，都是如此。&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 127&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;22.327201285944&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;39.692802286123&quot;&gt;
&lt;p&gt;&lt;strong&gt;2.1 二叉查找树的插入逻辑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2.1.1 设根节点为当前节点&lt;/p&gt;
&lt;p&gt;　　2.1.2 如果待插入节点保存的数据小于当前节点，则设新的当前节点为原节点的左节点；反之，执行第2.1.4步&lt;/p&gt;
&lt;p&gt;　　2.1.3 如果当前节点的左节点为null, 就将新的节点插入这个位置，退出循环；反之，继续执行下一次循环&lt;/p&gt;
&lt;p&gt;　　2.1.4 设新的当前节点为原节点的右节点&lt;/p&gt;
&lt;p&gt;　　2.1.5 如果当前节点的右节点为null, 就将新的节点插入这个位置，退出循环；反之，继续执行下一次循环&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('78f5462a-4c8d-424b-a992-acdec4a6fe4d')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_78f5462a-4c8d-424b-a992-acdec4a6fe4d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_78f5462a-4c8d-424b-a992-acdec4a6fe4d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('78f5462a-4c8d-424b-a992-acdec4a6fe4d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_78f5462a-4c8d-424b-a992-acdec4a6fe4d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;插入元素&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; insertBST(element){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; node = &lt;span&gt;new&lt;/span&gt; Node(element, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根节点判断&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (root == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            root &lt;/span&gt;=&lt;span&gt; node;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;非根节点&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; current =&lt;span&gt; root;
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;lt; current.element){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;往左节点方向放&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (current.left == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                        current.left &lt;/span&gt;=&lt;span&gt; node;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    current &lt;/span&gt;=&lt;span&gt; current.left;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;gt; current.element){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;往右节点方向放&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (current.right == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                        current.right &lt;/span&gt;=&lt;span&gt; node;
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                    current &lt;/span&gt;=&lt;span&gt; current.right;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;相等，替换&lt;/span&gt;
                    current.element =&lt;span&gt; element;
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
        size&lt;/span&gt;++&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2.2 二叉查找树的遍历，遍历有三种方式：中序、前序、后序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;中序&lt;/strong&gt;指以升序的方式遍历所有节点；&lt;strong&gt;前序是&lt;/strong&gt;指先访问根节点，再以同样的方式访问左子树和右子树；&lt;strong&gt;后序&lt;/strong&gt;指的是先访问叶子节点，再从左子树到右子树，最后到根节点。&lt;/p&gt;
&lt;p&gt;先看个效果图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454511/201908/454511-20190819004022418-1917382450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;遍历走势分析图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454511/201908/454511-20190819004103445-1948997958.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454511/201908/454511-20190819004110351-1034198894.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/454511/201908/454511-20190819004117658-756540937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;遍历代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4c180005-c349-4bba-af3c-46e4919c5b09')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_4c180005-c349-4bba-af3c-46e4919c5b09&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4c180005-c349-4bba-af3c-46e4919c5b09&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4c180005-c349-4bba-af3c-46e4919c5b09',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4c180005-c349-4bba-af3c-46e4919c5b09&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;二叉树中序遍历：以升序方式访问二叉树中所有节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; inOrder(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inOrderByNode(root);
    }
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; inOrderByNode(node){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = &quot;&quot;&lt;span&gt;;
            str &lt;/span&gt;+=&lt;span&gt; inOrderByNode(node.left);
            str &lt;/span&gt;+= node.element + &quot;, &quot;&lt;span&gt;;
            str &lt;/span&gt;+=&lt;span&gt; inOrderByNode(node.right);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前序遍历：先访问根节点，再访问左子树和右子树&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; preOrder(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; preOrderByNode(root);
    }
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; preOrderByNode(node){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = ''&lt;span&gt;;
            str &lt;/span&gt;+= node.element + &quot;, &quot;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先访问根节点&lt;/span&gt;
            str += preOrderByNode(node.left); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再访问左子树&lt;/span&gt;
            str += preOrderByNode(node.right); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;再访问右子树&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后序遍历：先访问叶子节点，再左子树，再右子树，再到根节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; postOrder(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; postOrderByNode(root);
    }
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; postOrderByNode(node){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (node){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; str = &quot;&quot;&lt;span&gt;;
            str &lt;/span&gt;+=&lt;span&gt; postOrderByNode(node.left);
            str &lt;/span&gt;+=&lt;span&gt; postOrderByNode(node.right);
            str &lt;/span&gt;+= node.element + &quot;, &quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; str;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.3 查找二叉查找树的最大值、最小值、是否存在某个值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最大值：因为较大的值都是在右子树上，则最大值一定是在右子树的最后一个节点上；&lt;/p&gt;
&lt;p&gt;最小值：较小的值都是在左子树上，则最小值一定在左子树的最后一个节点上；&lt;/p&gt;
&lt;p&gt;是否存在某个值，则是遍历查找&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('206c357c-3de4-48d5-b6a8-2242eb68a4c4')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_206c357c-3de4-48d5-b6a8-2242eb68a4c4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_206c357c-3de4-48d5-b6a8-2242eb68a4c4&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('206c357c-3de4-48d5-b6a8-2242eb68a4c4',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_206c357c-3de4-48d5-b6a8-2242eb68a4c4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找最小值：因为较小的值都在左边，所以最小值一定是左子树的最后一个节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getMin(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; minNode =&lt;span&gt; getMinNode(root);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (minNode) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; minNode.element;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找最小节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getMinNode(node){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; current =&lt;span&gt; node;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(current){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current.left == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; current;
            }
            current &lt;/span&gt;=&lt;span&gt; current.left;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找最大值：因为较大的值都在右边，所以最大值一定是在右子树的最后一个节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getMax(){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; maxNode =&lt;span&gt; getMaxNode(root);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (maxNode){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; maxNode.element;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找最大节点&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getMaxNode(node){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; current =&lt;span&gt; node;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(current){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (current.right == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; current;
            }
            current &lt;/span&gt;=&lt;span&gt; current.right;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找指定值，是否存在这个元素&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; isExist(element){
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; current =&lt;span&gt; root;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(current){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (element &amp;lt; current.element){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子树寻找&lt;/span&gt;
                current =&lt;span&gt; current.left;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (element &amp;gt; current.element){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子树寻找&lt;/span&gt;
                current =&lt;span&gt; current.right;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;{ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存在&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.4 删除二叉查找树中的指定元素&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;page&quot; title=&quot;Page 134&quot;&gt;
&lt;div class=&quot;layoutArea&quot; readability=&quot;8.2742433600988&quot;&gt;
&lt;div class=&quot;column&quot; readability=&quot;11.681284743669&quot;&gt;
&lt;p&gt;从二叉查找树上删除节点的操作最复杂，其复杂程度取决于删除哪个节点。如果删除没有子节点 的节点，那么非常简单。如果节点只有一个子节点，不管是左子节点还是右子节点，就变 得稍微有点复杂了。删除包含两个子节点的节点最复杂。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5bb3548c-e252-457f-8231-045dbe09128d')&quot; readability=&quot;36.5&quot;&gt;&lt;img id=&quot;code_img_closed_5bb3548c-e252-457f-8231-045dbe09128d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5bb3548c-e252-457f-8231-045dbe09128d&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5bb3548c-e252-457f-8231-045dbe09128d',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5bb3548c-e252-457f-8231-045dbe09128d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除元素&lt;/span&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; remove(element){
        root &lt;/span&gt;=&lt;span&gt; removeNode(root, element);
    }
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; removeNode(node, element){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.element ==&lt;span&gt; element){
            size&lt;/span&gt;--&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;node没有左子树&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (node.left == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.right;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (node.right == &lt;span&gt;null&lt;/span&gt;){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;node没有右子树&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node.left;
            }
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
             * node有左子树和右子树，这个时候要找出最接近node节点值的节点
             * 1、如果找出比node节点的element稍大的节点，则从node右节点的最小节点
             * 2、如果找出比node节点的element稍小的节点，则从node左节点的最大节点
             &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一种方式,找出比node的element稍微大点的节点&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; minNode =&lt;span&gt; getMinNode(node.right);
            node.element &lt;/span&gt;=&lt;span&gt; minNode.element;
            node.right &lt;/span&gt;=&lt;span&gt; removeNode(node.right, minNode.element);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; //第二种方式, 找出比node的element稍微小点的节点&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; var maxNode = getMaxNode(node.left);&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; node.element = maxNode.element;&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; node.left = removeNode(node.left, maxNode.element);&lt;/span&gt;

            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(element &amp;lt; node.element){ &lt;span&gt;//&lt;/span&gt;&lt;span&gt;往左子树方向继续找&lt;/span&gt;
            node.left =&lt;span&gt; removeNode(node.left, element);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;往右子树方向继续找&lt;/span&gt;
            node.right =&lt;span&gt; removeNode(node.right, element);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; node;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;完整demo见：&lt;a href=&quot;https://github.com/xiaotanit/Tan_DataStruct/blob/master/js/BinaryTree/BinarySearchTree.js&quot; target=&quot;_blank&quot;&gt;https://github.com/xiaotanit/Tan_DataStruct&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Sun, 18 Aug 2019 16:51:00 +0000</pubDate>
<dc:creator>TDX</dc:creator>
<og:description>一、二叉树的基本概念 从逻辑结构角度来看，前面说的链表、栈、队列都是线性结构；而今天要了解的“二叉树”属于树形结构。 1.1 多叉树的基本概念，以上图中“多叉树”为例说明 节点：多叉树中的每一个点都叫</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tandaxia/p/11234454.html</dc:identifier>
</item>
<item>
<title>.Net Core in Docker - 使用阿里云Codepipeline及阿里云容器镜像服务实现持续交付/部署（CD） - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/core_in_docker_cd.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/core_in_docker_cd.html</guid>
<description>&lt;p&gt;上一次演示了如何&lt;a href=&quot;https://www.cnblogs.com/kklldog/p/core_in_docker_ci.html&quot;&gt;使用阿里云Codepipeline,阿里云容器镜像服务实现CI&lt;/a&gt;，讲到这里我们push一下代码后就自动编译、自动跑单元测试、自动构建镜像、自动推送镜像到私仓。那么离我们最初设定的目标只差那么一小步了，那就是自动部署到测试/生产环境，这一步就是持续交付/部署(CD)。&lt;/p&gt;
&lt;h2 id=&quot;cd其实是两个意思&quot;&gt;CD其实是两个意思&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;（1）Continuous delivery （持续交付）  
    指的是，频繁地将软件的新版本，交付给质量团队或者用户，以供评审。如果评审通过，代码就进入生产阶段。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;（2）continuous deployment（持续部署）   
    指的是代码通过评审以后，自动部署到生产环境。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html&quot;&gt;摘自阮一峰大神的blog&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;之前我一直以为CD只是持续部署的意思，最近仔细查资料才发其实是有两层意思。虽然是两层意思，但是其实也差不多，都是部署到某个可以运行起来的环境中，把程序跑起来。持续交付一般是部署到测试环境，供测试团队评审；持续部署是指通过测试评审后把程序部署到生产环境。既然差不多这里我就不细分了，因为都是部署，只是部署的位置不一样。&lt;/p&gt;
&lt;h3 id=&quot;流程&quot;&gt;流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_QQ%E6%88%AA%E5%9B%BE20190816011741.png&quot;/&gt;&lt;br/&gt;上次的流程到把镜像推送到私仓（阿里云容器镜像服务）后就结束了，后面的流程需要手动跑shell脚本来完成。我们要把后面的流程串起来，让shell脚本自动运行起来，需要一个触发机制，比如webhook。幸好，阿里云容器镜像服务有这么一个功能，可以让我们把流程串起来，那就是触发器功能。这个触发器功能跟webhook其实差不多，当容器镜像服务收到新镜像后会对外发送一个HTTP POST请求。那么我们只需要在服务器上部署一个web服务，当接收到POST请求的时候就运行服务器端的shell脚本，拉取镜像，运行容器，这样程序就部署起来了。&lt;/p&gt;
&lt;h3 id=&quot;新建publishhook服务&quot;&gt;新建PublishHook服务&lt;/h3&gt;
&lt;p&gt;上面已经说了为了接收容器镜像服务发出的POST请求，需要一个web服务来接收处理请求。这个服务很简单，使用ASP.NET MVC都是杀鸡用牛刀，仅仅是监控一个请求而已。这里我使用另外一个轮子AServer&lt;a href=&quot;https://github.com/kklldog/AServer&quot; class=&quot;uri&quot;&gt;https://github.com/kklldog/AServer&lt;/a&gt; 。&lt;/p&gt;
&lt;h4 id=&quot;新建一个控制台程序取名publishhook&quot;&gt;1. 新建一个控制台程序，取名PublishHook&lt;/h4&gt;
&lt;h4 id=&quot;使用nuget安装aserver&quot;&gt;2. 使用nuget安装AServer&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_TIM%E6%88%AA%E5%9B%BE20190805162235.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;修改program的main函数&quot;&gt;3. 修改Program的main函数&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;using Agile.FrameworkNetCore.Log;
using System;
using System.Diagnostics;

namespace PublishHook
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine(&quot;PublishHook is running now !&quot;);

            var server = new Agile.AServer.Server();
            server.AddHandler(new Agile.AServer.HttpHandler()
            {
                Method = &quot;POST&quot;,
                Path = &quot;/api/hook&quot;,
                Handler = (req, resp) =&amp;gt;
                {
                    string shell_name = req.Query.shell;
                    if (!string.IsNullOrEmpty(shell_name))
                    {
                        RunShell(shell_name);
                    }
                    return resp.Write(&quot;ok&quot;);
                }
            });

            server
                .SetIP(&quot;0.0.0.0&quot;)
                .SetPort(9000)
                .Run();

            Console.Read();
        }

        static void RunShell(string fileName)
        {
            var processStartInfo = new ProcessStartInfo(fileName) { RedirectStandardOutput = true };
            var process = Process.Start(processStartInfo);
            if (process == null)
            {
                Console.WriteLine(&quot;Can not run shell .&quot;);
            }
            else
            {
                using (var sr = process.StandardOutput)
                {
                    while (!sr.EndOfStream)
                    {
                        var str = sr.ReadLine();
                        Console.WriteLine(str);
                        Logger.Info(str);
                    }

                    if (!process.HasExited)
                    {
                        process.Kill();
                    }
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;启动一个http Server监听9000端口,添加一个http handler，接收请求，解析QueryString获取脚本名称，然后运行脚本&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;运行publish_hook&quot;&gt;运行publish_hook&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;sudo dotnet restore
sudo dotnet publish&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;使用dotnet publish命令发布这个程序，然后复制到服务器上。&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sudo dotnet PublishHook.dll&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_TIM%E6%88%AA%E5%9B%BE20190805162619.jpg&quot;/&gt;&lt;br/&gt;&lt;em&gt;使用dotnet命令在服务器上运行这个服务。注意：这个服务不能使用docker运行，因为它要运行shell脚本来操作宿主机的docker。如果这个服务跑在容器内，那么它执行的shell是相对于它的容器来说的，无法操作宿主机的docker环境。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;复制上次新建的publish_cicd_test.sh脚本文件到publishhook程序目录并赋予权限&quot;&gt;复制上次新建的publish_cicd_test.sh脚本文件到PublishHook程序目录并赋予权限&lt;/h4&gt;
&lt;p&gt;复制上次新建的publish_cicd_test.sh脚本文件到PublishHook程序目录，一遍程序能够从根目录读取。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;chmod +x publish_cicd_test.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;使用chmod +x给shell脚本赋值可执行权限&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;在容器镜像服务新建触发器&quot;&gt;在容器镜像服务新建触发器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_QQ%E5%9B%BE%E7%89%8720190816013327.png&quot;/&gt;&lt;br/&gt;&lt;em&gt;点击创建触发器&lt;/em&gt;&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_TIM%E6%88%AA%E5%9B%BE20190805160113.jpg&quot;/&gt;&lt;br/&gt;&lt;em&gt;在新建界面填写触发器名称，触发器url。这个url就是PublishHook监听的地址&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试一下&quot;&gt;测试一下&lt;/h3&gt;
&lt;p&gt;配置好容器镜像服务的触发器后，我们的配置工作基本都完成了。让我们修改一下CoreCICDTest项目，然后push到Gitee上，看push后能不能全自动的部署成功。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@{
    ViewData[&quot;Title&quot;] = &quot;Home Page&quot;;
}


&amp;lt;h3&amp;gt;
    .NET CORE CICD TEST -- V 3.0
&amp;lt;/h3&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;修改home/index首页，从V2.0改为V3.0，然后使用git push命令推送代码。等待一会后，访问一下CoreCICDTest的网址。&lt;/em&gt;&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_QQ%E6%88%AA%E5%9B%BE20190816213343.png&quot;/&gt;&lt;br/&gt;Wow！可以看到我们的网址已经自动部署成功了，终于完成了我们一开始设定的目标。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;回顾整个过程，我们可以发现各个服务之间虽然是彼此独立，但是我们可以通过WebHook功能串联起来。甚至最后我们自己定义了一个WebHook的监听程序来替我们执行对应的脚步。其实通过这种思想我们可以把更多的流程串联起来，实现更多自动化流程。&lt;br/&gt;这次我们顺利的使用阿里云的Codepipeline、容器镜像服务，实现了最基本的CICD。现在各大云服务厂商基本都提供了很多基础功能，而且大部分是免费的，有效的利用这些服务可以节省宝贵的时间，开发者可以更专注在核心业务上面。&lt;/p&gt;
</description>
<pubDate>Sun, 18 Aug 2019 16:51:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>上一次演示了如何 '使用阿里云Codepipeline,阿里云容器镜像服务实现CI' ，讲到这里我们push一下代码后就自动编译、自动跑单元测试、自动构建镜像、自动推送镜像到私仓。那么离我们最初设定的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/core_in_docker_cd.html</dc:identifier>
</item>
<item>
<title>深入剖析PHP7内核源码（一）- PHP架构与生命周期 - defmain</title>
<link>http://www.cnblogs.com/jaychan/p/11218047.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jaychan/p/11218047.html</guid>
<description>&lt;h2 id=&quot;php7-为什么这么快&quot;&gt;PHP7 为什么这么快？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;全新的zval 更节约的空间，栈上分配内存&lt;/li&gt;
&lt;li&gt;zend_string 存储字符串的Hash值,数组查询的时候不需要进行Hash计算&lt;/li&gt;
&lt;li&gt;在HashTable桶内直接存数据,减少了内存的申请次数,提升了cache命中率和内存访问速度&lt;/li&gt;
&lt;li&gt;zend_parse_parameters改为了宏实现,性能提升5%&lt;/li&gt;
&lt;li&gt;增加opcode指令 call_user_function,is_init/string/array,strlen,defined函数变成opcode指令,速度更快&lt;/li&gt;
&lt;li&gt;排序算法的改进&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;php7-架构&quot;&gt;PHP7 架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/456913/201907/456913-20190720170520772-2012479341.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Zend 引擎：Zend引擎为PHP提供了基础服务，包括词法分析 语法分析 ，AST抽象语法树编译 opcodes执行，PHP的变量设计、内存管理、进程管理。&lt;/li&gt;
&lt;li&gt;PHP层：绑定了SAPI层并处理与它的通信，它同时对safe_mode和open_basedir的检测提供一致的控制层，将fopen()、fread()和fwrite()等用户空间的函数与文件和网络I/O联系起来。&lt;/li&gt;
&lt;li&gt;SAPI：包括了cli fpm等，把接口对外接口都抽象出来，只要遵守SAPI协议便可以实现一个server。&lt;/li&gt;
&lt;li&gt;拓展：zend 引擎提供了核心能力和接口规范，在此基础上可以开发拓展&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;这里的拓展分为了两种，通常在php.ini中，通过extension=&lt;em&gt;加载的扩展我们称为PHP扩展，通过zend_extension=&lt;/em&gt;加载的扩展我们称为Zend扩展，但从源码的角度来讲，PHP扩展应该称为“模块”（源码中以module命名），而Zend扩展称为“扩展”（源码中以extension命名）。两者最大的区别在于向引擎注册的钩子，向用户层面提供一些C实现的PHP函数，需要用到zend_module_entry（即作为PHP扩展），而需要hook到Zend引擎的话，就得用到zend_extension（即作为Zend扩展）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;php7执行流程&quot;&gt;PHP7执行流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/456913/201907/456913-20190720174852094-526303663.jpg&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;词法分析，把源代码切割成多个字符串单元（Token）&lt;/li&gt;
&lt;li&gt;语法分析器把Token转换成AST抽象语法树&lt;/li&gt;
&lt;li&gt;抽象语法树转换成opcodes(opcode指令集合)&lt;/li&gt;
&lt;li&gt;虚拟机解释执行执行opcodes(opcode是一组指令标识，对应handler处理函数)&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;执行实例&quot;&gt;执行实例&lt;/h4&gt;
&lt;h5 id=&quot;词法分析&quot;&gt;词法分析&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php 
echo &quot;Hello world&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切割成了4部分&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php  =&amp;gt; #define T_OPEN_TAG 379

echo =&amp;gt; #define T_ECHO 328

空格 =&amp;gt;  #define T_WHITESPACE 382

&quot;hello world&quot; =&amp;gt; #define T_CONSTANT_ENCAPSED_STRING 323
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;语法分析&quot;&gt;语法分析&lt;/h5&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;单独存在的词块不能完整表达语义，还需要语法分析器，它会检查语法，匹配Token，对Token进行关联，组织串联后的产物就是AST.AST 分为多种类型,对应PHP语法，比如赋值语句，生成的抽象语法树节点是ZEND_AST_ASSIGN，赋值语句的左右会被作为ZEND_AST_ASSIGN类型节点的孩子（AST是PHP7才加入的，解耦了编译器和解释器）.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;opcodes&quot;&gt;opcodes&lt;/h5&gt;
&lt;p&gt;opcode是PHP执行过程中的中间代码，生成后由虚拟机执行，生成的opcode是类似下面的样子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;line     op
1        ECHO
2        RETURN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码中对应的opcode及handler&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ZEND_ECHO // handler:ZEND_ECHO_SPEC_CONST_HANDLER 实现的功能是输出&quot;hello world&quot;
ZEND_RETURN  // handler:ZEND_RETURN_SPEC_CONST_HANDLER&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;php-生命周期&quot;&gt;PHP 生命周期&lt;/h2&gt;
&lt;h3 id=&quot;cli生命周期&quot;&gt;CLI生命周期&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/456913/201907/456913-20190721174426703-192589801.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;php_module_startup:注册全局变量GPC等，加载内部拓展和外部拓展。&lt;/li&gt;
&lt;li&gt;php_request_startup:重置垃圾回收器，初始化执行器，初始化扫描器，设置超时时间等。&lt;/li&gt;
&lt;li&gt;php_execute_script&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;=&amp;gt; compile_file
=&amp;gt; open_file_for_scanning(读取PHP代码内容,并使词法分析指针指向第一个位置) 
=&amp;gt; zendparse(词法分析语法分析后生成AST) =&amp;gt; init_op_array(初始化op_array) 
=&amp;gt; zend_compile_top_stmt(把AST转为op_array) 
=&amp;gt; pass_two(设置op_array对应的zend虚拟机handler) 
=&amp;gt; 生成op_array
=&amp;gt; zend_execute(zend虚拟机中执行op_array)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;php_request_shutdown:调用所有关闭函数,调用所有析构函数，输出缓冲区内容,重置最大执行时间,关闭输出层(HTTP头等),释放所有request的全局变量&lt;/li&gt;
&lt;li&gt;php_module_shutdown:调用module对应的flush函数,清理持久化的符号表,销毁全局变量,关闭所有拓展,关闭内存管理,关闭输出output,析构垃圾回收&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;fpm模式的生命周期&quot;&gt;FPM模式的生命周期&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/456913/201907/456913-20190721182654100-781612031.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FPM跟CLI模式不同的是，FPM是常驻内存的，所以php_module_startup只在启动进程的时候做一次初始化，对应的php_module_shutdown也只做一次。&lt;/li&gt;
&lt;li&gt;进入循环,调用fcgi_accept_request(accept) 阻塞等待，如果请求进来，则进入php_request_startup，初始化请求，同时加了锁来防止惊群效应&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;fcgi.c 
...
FCGI_LOCK(req-&amp;gt;listen_socket); 
req-&amp;gt;fd = accept(listen_socket, (struct sockaddr *)&amp;amp;sa, &amp;amp;len);
FCGI_UNLOCK(req-&amp;gt;listen_socket);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引用&lt;/p&gt;
</description>
<pubDate>Sun, 18 Aug 2019 15:53:00 +0000</pubDate>
<dc:creator>defmain</dc:creator>
<og:description>PHP7 为什么这么快？ 全新的zval 更节约的空间，栈上分配内存 zend_string 存储字符串的Hash值,数组查询的时候不需要进行Hash计算 在HashTable桶内直接存数据,减少了内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jaychan/p/11218047.html</dc:identifier>
</item>
</channel>
</rss>