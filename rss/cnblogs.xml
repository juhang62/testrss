<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深度学习-常见神经网络 - 雪山飞猪</title>
<link>http://www.cnblogs.com/chenqionghe/p/12688780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenqionghe/p/12688780.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413014330352-1843488054.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2006年，“神经网络之父”Geoffrey Hinton祭出神器深度信念网络，一举解决了深层神经网络的训练问题，推动了深度学习的快速发展。&lt;br/&gt;深度信念网络（Deep Belief Nets），是一种概率生成模型，能够建立输入数据和输出类别的联合概率分布。&lt;br/&gt;深度信念网络通过采用逐层训练的方式，解决了深层次神经网络的优化问题，通过逐层训练为整个网络赋予了较好的初始权值，使得网络只要经过微调就可以达到最优解。&lt;br/&gt;深度信念网络的每个隐藏层都扮演着双重角色：它既作为之前神经元的隐藏层，也作为之后神经元的可见层。&lt;br/&gt;在逐层训练的时候起到最重要作用的是“受限玻尔兹曼机”&lt;br/&gt;结构上看，深度信念网络可以看成&lt;code&gt;受限玻尔兹曼机&lt;/code&gt;组成的整体&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235305746-623543173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;玻尔兹曼机（bm）&quot;&gt;玻尔兹曼机（BM）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235320619-659976165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;玻尔兹曼机，（Boltzmann Machines，简称BM），1986年由大神Hinton提出，是一种根植于统计力学的随机神经网络，这种网络中神经元只有两种状态（未激活、激活），用二进制0、1表示，状态的取值根据概率统计法则决定。&lt;br/&gt;由于这种概率统计法则的表达形式与著名统计力学家L.E.Boltzmann提出的玻尔兹曼分布类似，故将这种网络取名为“玻尔兹曼机”。&lt;br/&gt;在物理学上，玻尔兹曼分布是描述理想气体在受保守外力的作用时，处于热平衡态下的气体分子按能量的分布规律。&lt;br/&gt;在统计学习中，如果我们将需要学习的模型看成高温物体，将学习的过程看成一个降温达到热平衡的过程。能量收敛到最小后，热平衡趋于稳定，也就是说，在能量最少的时候，网络最稳定，此时网络最优。&lt;/p&gt;
&lt;p&gt;玻尔兹曼机（BM）可以用在监督学习和无监督学习中。&lt;br/&gt;在无监督学习中，隐变量可以看做是可见变量的内部特征表示，能够学习数据中复杂的规则。玻尔兹曼机代价是训练时间很长很长很长。&lt;/p&gt;
&lt;h2 id=&quot;受限玻尔兹曼机（rbm）&quot;&gt;受限玻尔兹曼机（RBM）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235330786-1767732720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;受限玻尔兹曼机（Restricted Boltzmann Machines，简称RBM）&lt;br/&gt;将“玻尔兹曼机”（BM）的层内连接去掉，对连接进行限制，就变成了“受限玻尔兹曼机”（RBM）&lt;br/&gt;一个两层的神经网络，一个可见层和一个隐藏层。&lt;br/&gt;可见层接收数据，隐藏层处理数据，两层以全连接的方式相连，同层之前不相连。&lt;br/&gt;受限玻尔兹曼机需要将输出结果反馈给可见层，通过让重构误差在可见层和隐藏层之间循环往复地传播，从而重构出误差最小化的一组权重系数。&lt;/p&gt;
&lt;p&gt;传统的反向传播方法应用于深度结构在原则上是可行的，可实际操作中却无法解决梯度弥散的问题&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;梯度弥散（gradient vanishing），当误差反向传播时，传播的距离越远，梯度值就变得越小，参数更新的也就越慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这会导致在输出层附近，隐藏层的参数已经收敛；而在输入层附近，隐藏层的参数几乎没有变化，还是随机选择的初始值。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413013142711-1596066017.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GAN（Generative Adversarial Network）是由Goodfellow等人于2014年设计的生成模型，受博弈论中的零和博弈启发，将生成问题视作生成器和判别器这两个网络的对抗和博弈。&lt;/p&gt;
&lt;p&gt;该方法由是由Goodfellow等人于2014年提出，生成对抗网络由一个生成器与一个判别器组成，&lt;br/&gt;生成网器从潜在空间中随机取样作为输入，其输出结果需要尽量模仿训练集中的真实样本。&lt;br/&gt;判别器的输入为真实样本或生成器的输出，其目的是将生成器的输出从真实样本中尽可能分辨出来。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235927048-1392247125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;GAN主要优点是超越了传统神经网络分类和特征提取的功能，能够按照真实数据的特点生成新的数据。&lt;br/&gt;两个网络在对抗中进步，在进步后继续对抗，由生成式网络得的数据也就越来越完美，逼近真实数据，从而可以生成想要得到的数据（图片、序列、视频等）。&lt;/p&gt;
&lt;h2 id=&quot;生成器（generator）&quot;&gt;生成器（generator）&lt;/h2&gt;
&lt;p&gt;生成器从给定噪声中（一般是指均匀分布或者正态分布）产生合成数据。试图产生更接近真实的数据。&lt;br/&gt;生成器像是白骨精，想方设法从随机噪声中模拟真实数据样本的潜在分布，以生成以假乱真的数据样本&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235934598-1222703904.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;判别器（discriminator）&quot;&gt;判别器（discriminator）&lt;/h2&gt;
&lt;p&gt;判别器分辨生成器的的输出和真实数据。试图更完美地分辨真实数据与生成数据。&lt;/p&gt;
&lt;p&gt;判别器是孙悟空，用火眼金睛来判断是人畜无害的真实数据还是生成器假扮的伪装者&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235950435-1283964056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;生成器和判别器都可以采用深度神经网络实现，建立数据的生成模型，使生成器尽可能精确你有没出数据样本的分布，从学习方式上对抗性学习属于无监督学习，&lt;/p&gt;
&lt;p&gt;网络训练可以等效为目录函数的极大-极小问题&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;极大：让判别器区分真实数据和伪造数据的准确率最大化&lt;/li&gt;
&lt;li&gt;极小：让生成器生成的数据被判别器发现的概率最小化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;传统生成模型定义了模型的分布，进而求解参数。比如在已知数据满足正态分布的前提下，生成模型会通过极大似然估计等方法根据样本来求解正态的均值和方差。&lt;/p&gt;
&lt;p&gt;生成对抗网络摆脱了对模型分布的依赖，也不限制生成的维度，大大拓宽了生成数据样本的范围，还能融合不同的损失函数，增加了设计的自由度。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413011718260-1943887431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413011349125-757319865.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;循环神经网络（Recurrent Neural Network），也可以表示递归神经网络（Recursive Neural Network）。循环神经网络可以看成是递归神经网络的特例，递归神经网络可以看成是循环神经网络的推广。&lt;br/&gt;卷积神经网络具有空间上的参数共享的特性，可以让同样的核函数应用在图像的不同区域。&lt;br/&gt;把参数共享调整到时间维度上，让神经网络使用相同权重系数来处理具有先后顺序的数据，得到的就是循环神经网络。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413000107678-902554618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;时间&lt;br/&gt;循环神经网络引入了”时间“的维度，适用于处理时间序列类型的数据。&lt;br/&gt;循环神经网络就是将长度不定的输入分割为等长的小块，再使用相同的权重系统进行处理，从而实现对变长输入的计算与处理。&lt;br/&gt;比方说妈妈在厨房里突然喊你：“菜炒好了，赶紧来......”，即使后面的话没有听清楚，也能猜到十有八九是让你赶紧吃饭。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;记忆&lt;br/&gt;循环神经网络t时刻的输出取决于当前时刻的输入，也取决于网络前一时刻t-1甚至更早的输出。&lt;br/&gt;从这个意义上来讲，循环神经网络引入引入了反馈机制，因而具有了记忆功能。记忆功能使循环神经网络能够提取来自序列自身的信息，&lt;br/&gt;输入序列的内部信息存储在神经网络的隐藏层中，并随着时间的推移在隐藏层中流转。循环网络的记忆特性可以用公式表示为&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(h_t=f(Wx_t+Uh_{t-1})\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;解释：将时刻的输入&lt;span class=&quot;math inline&quot;&gt;\(x_t\)&lt;/span&gt;的加权结果和时刻&lt;span class=&quot;math inline&quot;&gt;\(t-1\)&lt;/span&gt;的隐藏层状态&lt;span class=&quot;math inline&quot;&gt;\(h_{t-1}\)&lt;/span&gt;的加权结果共同作为传递函数&lt;br/&gt;的输入，得到的是隐藏层在时刻&lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt;的输出&lt;span class=&quot;math inline&quot;&gt;\(h_t\)&lt;/span&gt;。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;表示从输入到状态的权重矩阵，&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;表示从状态到状态的转移矩阵。&lt;br/&gt;对循环神经网络的训练就是根据输出结果和真实结果之间的误差不断调整参数&lt;span class=&quot;math inline&quot;&gt;\(W\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;，直到达到预设要求的过程，训练方法也是基于梯度的反向传播算法。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;前馈神经网络某种程序上也具有记忆特性，只要神经网络参数经过最优化，优化的参数就会包含以往数据的踪迹，但是优化的记忆只局限于训练数据集上，当训练的醋应用到新的测试数据集上时，其参数并不会根据测试数据的表现做出进一步调整。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;双向rnn&quot;&gt;双向RNN&lt;/h2&gt;
&lt;p&gt;比如有一部电视剧，在第三集的时候才出现的人物，现在让预测一下在第三集中出现的人物名字，你用前面两集的内容是预测不出来的，所以你需要用到第四，第五集的内容来预测第三集的内容，这就是双向RNN的想法&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413000120272-967065588.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果想让循环神经网络利用来自未来的信息，就要让当前的状态和以后时刻的状态建立直联系，就是双向循环神经网络。&lt;br/&gt;双向循环网络包括正向计算和反向计算两个环节&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;正向计算中，时刻t的隐藏层状态&lt;span class=&quot;math inline&quot;&gt;\(h_t\)&lt;/span&gt;和过去&lt;span class=&quot;math inline&quot;&gt;\(h_{t-1}\)&lt;/span&gt;相关&lt;/li&gt;
&lt;li&gt;反向计算中，时间t的隐藏层状态&lt;span class=&quot;math inline&quot;&gt;\(h_t\)&lt;/span&gt;和未来的&lt;span class=&quot;math inline&quot;&gt;\(h_{t+1}\)&lt;/span&gt;相关&lt;br/&gt;双向循环网络需要分别计算正向和反向的结果，并将两者作为隐藏层的最终参数。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;深度rnn&quot;&gt;深度RNN&lt;/h2&gt;
&lt;p&gt;将深度结构引入循环神经网络就可以得到深度循环网络。&lt;br/&gt;比如你学习英语的时候，背英语单词一定不会就看一次就记住了所有要考的单词，一般是带着先前几次背过的单词，然后选择那些背过但不熟的内容或者没背过的单词来背&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413000132628-533941131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;深层双向RNN 与双向RNN相比，多了几个隐藏层，因为他的想法是很多信息记一次记不下来，&lt;br/&gt;深层双向RNN就是基于这么一个想法，每个隐藏层状态&lt;span class=&quot;math inline&quot;&gt;\(h_t^i\)&lt;/span&gt;既取决于同一时刻前一隐藏层的状态&lt;span class=&quot;math inline&quot;&gt;\(h_t^{i-1}\)&lt;/span&gt;，也取决于同一隐藏层的状态h_{t-1}^{i}$&lt;br/&gt;深度结构的作用在于建立更清晰的表示。用“完形填空”来说，需要根据上下文，来选择合适的词语。有些填空只需要根据它所在的句子便可以推断出来，这对应着单个隐藏层在时间维度上的依赖性；有些填空则可能要通读整段或全文才能确定，这对应了时间维度和空间维度共有的依赖性。&lt;/p&gt;
&lt;h2 id=&quot;递归rnn&quot;&gt;递归RNN&lt;/h2&gt;
&lt;p&gt;递归神经网络能够处理具有层次化结构的数据，可以看成循环网络的推广&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413000156613-1683646365.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;循环神经网络特点是在时间维度上共享参数，从而展开处理序列，如果展开成树状态结构，用到的就是递归神经网络。递归神经网络首先将输入数据转化为某种拓扑结构，再在相同的结构上递归使用相同的权重系数，通过遍历方式得到结构化的预测。&lt;/p&gt;
&lt;p&gt;例如，“两个大学的老师”有歧义，如果单纯拆分为词序列无法消除歧义。&lt;br/&gt;递归神经网络通过树状结构将一个完整的句子打散为若干分量的组合，生成的向量不是树结构的根节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413011531520-118241263.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413012821308-574938421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;长短期记忆网络（LSTM，Long Short-Term Memory）是一种时间循环神经网络，为了解决一般的RNN（循环神经网络）存在的长期依赖问题而专门设计出来的，论文首次发表于1997年。由于独特的设计结构，LSTM适合于处理和预测时间序列中间隔和延迟非常长的重要事件。&lt;/p&gt;
&lt;p&gt;RNN通过在时间共享参数引入了记特性，从而可以将先前的信息应用在当前的任务上，可是这种记忆通常只有有限的深度。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;例如龙珠超或者火影每周更新一集，即使经历了一周的空档期，我们还是能将前一集的内容和新一集的情节无缝衔接起来。但是RNN的记忆就没有这么强的延续性，别说一个星期，5分钟估计都已经歇菜了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LSTM可以像人的记忆中选择性地记住一些时间间隔更久远的信息，它会根据组成元素的特性，来判断不同信息是被遗忘或被记住继续传递下去。&lt;br/&gt;LSTM就是实现长期记忆用的，实现任意长度的记忆。要求模型具备对信息价值的判断能力，结合自身确定哪些信息应该保存，哪些信息该舍弃，元还要能决定哪一部分记忆需要立刻使用。&lt;/p&gt;
&lt;h2 id=&quot;4种组成&quot;&gt;4种组成&lt;/h2&gt;
&lt;p&gt;LSTM通常由下面4个模块组成&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413000345829-369695868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;记忆细胞（memory cell）&lt;br/&gt;作用是存储数值或状态，存储的时限可以是长期也可以是短期&lt;/li&gt;
&lt;li&gt;输入门（input gate）&lt;br/&gt;决定哪些信息在记忆细胞中存储&lt;/li&gt;
&lt;li&gt;遗忘门（forget gate）&lt;br/&gt;决定哪些信息从记忆细胞中丢弃&lt;/li&gt;
&lt;li&gt;输出门（output gate）&lt;br/&gt;决定哪些信息从记忆细胞中输出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413013610992-116690543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;卷积神经网络（convolutional neural network）指至少某一导中用了卷积运算（convolution）来代替矩阵乘法的神经网络。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235357701-291957930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;卷积是什么&quot;&gt;卷积是什么&lt;/h2&gt;
&lt;p&gt;卷积是对两个函数进行的一种数学运算，我们称&lt;span class=&quot;math inline&quot;&gt;\((f*g)(n)\)&lt;/span&gt;为f,g的卷积&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连续定义&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\((f*g)(n) = \int_{-\infty }^{\infty}f(τ)g(n-τ)dτ\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;离散定义&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\((f*g)(n) = \sum_{τ=-\infty }^{\infty}f(τ)g(n-τ)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们令&lt;span class=&quot;math inline&quot;&gt;\(x=τ\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(y=n-τ\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(x+y=n\)&lt;/span&gt;，相当于下面的直线&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/50/v2-8be52f6bada3f7a21cebfc210d2e7ea0_hd.webp&quot; alt=&quot;conv_ops&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果遍历这些直线，就像毛巾卷起来一样，顾名思义“卷积”&lt;br/&gt;&lt;img src=&quot;https://pic1.zhimg.com/50/v2-1d0c819fc7ca6f8da25435da070a2715_hd.webp&quot; alt=&quot;conv_ops&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在卷积网络中，卷积本质就是以&lt;code&gt;核函数g&lt;/code&gt;作为权重系数，对&lt;code&gt;输入函数f&lt;/code&gt;进行加权求和的过程。&lt;br/&gt;其实把二元函数&lt;span class=&quot;math inline&quot;&gt;\(U(x,y) = f(x)g(y)\)&lt;/span&gt;卷成一元函数&lt;span class=&quot;math inline&quot;&gt;\(V(t)\)&lt;/span&gt;，俗称降维打击&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(V(t)=\int_{x+y=t}U(x,y)d_x\)&lt;/span&gt;，函数 f 和 g 应该地位平等，或者说变量 x 和 y 应该地位平等，一种可取的办法就是沿直线 x+y = t 卷起来；&lt;/p&gt;
&lt;h3 id=&quot;掷骰子&quot;&gt;掷骰子&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235600629-737019924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;求两枚骰子点数加起来为4的概率，这正是卷积的应用场景。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一枚骰子概率为为f(1)、f(2)、...f(6)&lt;/li&gt;
&lt;li&gt;第二八骰子概率为g(1)、g(2)、...g(m)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两枚骰子加起来为4的概率为：&lt;span class=&quot;math inline&quot;&gt;\(f(1)g(3)+f(2)g(2)+f(3)g(1)\)&lt;/span&gt;&lt;br/&gt;标准形式是：&lt;span class=&quot;math inline&quot;&gt;\((f*g)(4)=\sum_{m=1}^3f(4-m)g(m)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;做馒头&quot;&gt;做馒头&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235604637-1310315057.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;机器不断的生产馒头，假设馒头生产速度是f(t)，&lt;br/&gt;那么一天生产出来的馒头总量为&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\int_{0 }^{24}f(t)dt\)&lt;/span&gt;&lt;br/&gt;生产出来后会逐渐腐败，腐败函数为g(t)，比如10个馒头，24小时会腐败&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(10*g(t)\)&lt;/span&gt;&lt;br/&gt;一天生产出来的馒头就是&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\int_{0 }^{24}f(t)g(24-t)dt\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;做鱼&quot;&gt;做鱼&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235612460-1021298399.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;卷积看做做菜，输入函数是原料，核函数是菜谱，对于同一输入函数鲤鱼来说&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;核函数中的酱油权重较大，输出红烧鱼&lt;/li&gt;
&lt;li&gt;核函数中的糖和醋权重大较大，输出西湖醋鱼&lt;/li&gt;
&lt;li&gt;核函数中的辣椒权重较大，输出朝鲜辣鱼&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;图像处理&quot;&gt;图像处理&lt;/h3&gt;
&lt;p&gt;假设一幅图有噪点，要将它进行平滑处理，可以把图像转为一个矩阵&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235623607-66242384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要平滑&lt;span class=&quot;math inline&quot;&gt;\(a_{1,1}\)&lt;/span&gt;点，就把&lt;span class=&quot;math inline&quot;&gt;\(a_{1,1}\)&lt;/span&gt;点附近的组成矩阵&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;，和&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;进行卷积运算，再填充回去&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200412235628415-689197948.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(f\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;的计算如下，其实就是以相反的方向进行计算，像卷毛巾一样&lt;br/&gt;&lt;img src=&quot;https://pic3.zhimg.com/50/v2-c658110eafe027eded16864fb6a28f46_hd.webp&quot; alt=&quot;conv_ops&quot;/&gt;&lt;br/&gt;计算&lt;span class=&quot;math inline&quot;&gt;\(c_{1,1}\)&lt;/span&gt;写成公式为&lt;span class=&quot;math inline&quot;&gt;\((f*g)(1,1)=\sum_{k=0}^2\sum_{h=0}^2f(h,k)g(1-h,1-k)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体参考 ：&lt;/p&gt;
&lt;h2 id=&quot;卷积神经网络特性&quot;&gt;卷积神经网络特性&lt;/h2&gt;
&lt;p&gt;卷积运算的特性决定了神经网络适用于处理具有网络状结构的数据。&lt;br/&gt;典型的网络型数据就是数字图像，无论是灰度还是彩色图像，都是定义在二维像素网络上的一组标题或向量。&lt;br/&gt;卷积神经网络广泛地应用于图像与文本识别之中，并逐渐扩展到自然语言处理等其他领域。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;稀疏感知性&lt;br/&gt;卷积层核函数的大小通常远远小于图像的大小。&lt;br/&gt;图像可能在两个维度上都有几千个像素，但核函数最大不会超过几十个像素。&lt;br/&gt;选择较小的核函数有助于发现图像中细微的局部细节，提升算法的存储效率和运行效率。&lt;/li&gt;
&lt;li&gt;参数共享性&lt;br/&gt;一个模型中使用相同的参数。每一轮训练中用单个核函数去和图像的所有分块来做卷积。&lt;/li&gt;
&lt;li&gt;平移不变性&lt;br/&gt;当卷积的输入产生平衡时，其输出等于原始输出相同数量的平移，说明平移操作和核函数的作用是可以交换的。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;卷积神经网络分层&quot;&gt;卷积神经网络分层&lt;/h2&gt;
&lt;p&gt;当输入图像被送入卷积神经网络后，先后要循环通过卷积层、激活层和池化层，最后从全连接层输出分类结果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入层&lt;br/&gt;输入数据，通常会做一些数据处理，例如去均值、归一化、 PCA/白化等&lt;/li&gt;
&lt;li&gt;卷积层&lt;br/&gt;卷积层是卷积神经网络的核心部分，参数是一个或多个随机初始化的核函数，核函数就像按照灯一样，逐行逐列扫描输入图像。扫描完毕后计算出的所有卷积结果可以构成一个矩阵，这个新的矩阵叫特征映射（feature map）。卷积层得到的特征一般会送到激励层处理&lt;/li&gt;
&lt;li&gt;激励层&lt;br/&gt;主要作用是将卷积层的结果做非线性映射。常见的激励层函数有sigmoid、tanh、Relu、Leaky Relu、ELU、Maxout&lt;/li&gt;
&lt;li&gt;池化层&lt;br/&gt;在连续的卷基层和激励层中间，用于压缩数据和参数的量，用于减少过拟合。&lt;br/&gt;简而言之，如果输入是图像的话，那么池化层的最主要作用就是压缩图像。&lt;br/&gt;常见的最大池化做法就是将特征映射划分为若干个矩形区域，挑选每个区域中的最大值。&lt;/li&gt;
&lt;li&gt;全连接层&lt;br/&gt;两层之间所有神经元都有权重连接，通常全连接层在卷积神经网络尾部，输出分类结果。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在卷积神经网络的训练里，待训练的参数是卷积核。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;卷积核：也就是用来做卷积的核函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;卷积神经网络的作用是逐层提取输入对象的特征，训练采用的也是反向传播的方法，参数的不断更新能够提升图像特征提取的精度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/662544/202004/662544-20200413012301910-1137012617.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;学海无涯，且行且珍惜，以上由chenqionghe整理，如有雷同，纯属巧合&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 00:58:00 +0000</pubDate>
<dc:creator>雪山飞猪</dc:creator>
<og:description>[toc] 一、深度信念网络（DBN） 2006年，“神经网络之父”Geoffrey Hinton祭出神器深度信念网络，一举解决了深层神经网络的训练问题，推动了深度学习的快速发展。 深度信念网络（De</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenqionghe/p/12688780.html</dc:identifier>
</item>
<item>
<title>上周热点回顾（4.6-4.12） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/12689281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/12689281.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · 【高并发】高并发秒杀系统架构解密，不是所有的秒杀都是秒杀！ (冰河团队)· Java是未来的第一编程语言吗？ (黄钰朝)· .Net 微服务架构技术栈的那些事 (Jlion)· [一起读源码]走进C#并发队列ConcurrentQueue的内部世界 (balahoho)· 30岁开始</description>
<pubDate>Mon, 13 Apr 2020 00:48:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>热点随笔： &amp;#183;&amp;#160;【高并发】高并发秒杀系统架构解密，不是所有的秒杀都是秒杀！&amp;#160;(冰河团队)&amp;#183;&amp;#160;Java是未来的第一编程语言吗？&amp;#160;(黄钰朝)&amp;#</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/12689281.html</dc:identifier>
</item>
<item>
<title>千亿级互联网平台技术架构及背后那些事 - 码大叔</title>
<link>http://www.cnblogs.com/madashu/p/12689276.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/madashu/p/12689276.html</guid>
<description>&lt;p&gt;以挑剔的眼光、现在的能力、现在的经验回过头来回顾这个产品，回顾这个项目，回顾整个系统的技术架构设计，甚至是回顾到某一个案例下现在的代码应该是什么样子。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;135&quot;&gt;

&lt;p&gt;&lt;strong&gt;这是一个从0到3000亿的故事！&lt;/strong&gt;&lt;br/&gt;故事里的那群人架海擎天，俱怀逸兴壮思飞，欲上青天揽明月。那时的码大叔也正风华正茂，意气风发！我们浩浩荡荡地碾压过肆意的年华，在代码的世界里千骑卷平冈。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200412182649372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70#pic_left&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;p&gt;窗外，正淅淅小雨，很适合用来回忆。正如普鲁斯特在《追忆似水年华》里说的：当岁月流逝，所有的东西都消失殆尽的时候，唯有空中飘荡的气味还恋恋不散，让往事历历在目。&lt;/p&gt;
&lt;p&gt;X项目，刚开始只有一个高层业务模型，但产品具体应该怎么设计怎么呈现谁也没有想清楚。一群人就那么挤在南京奥体中心的公寓里，人紧挨着人坐着，连服务器都只能架设在卫生间的盥洗台上。产品需求经过一轮又一轮的调整，代码经过一遍又一遍的推翻重写，上线时间也一再地推迟。夏天的时候过了17点整栋楼的空调就自动关了，我们啪嗒啪嗒地敲着代码，汗水啪嗒啪嗒地敲打着桌面，经过了大半年的折腾和准备后终于接到通知真的要上线了。那时的心情反倒是很平静，只是觉得该来的终于来了。&lt;/p&gt;
&lt;p&gt;由于涉及到在线资金交易且单笔支付金额较大，系统接入了某银行的银企直联接口，支持单笔高达300万的支付金额。所以资金安全问题成了当时唯一的担心，团队做了很多的风险预案，包括系统对账审计人工核算等等。上线前2天郭局长又把程序的事务控制临时调整为SERIERLIZED最高隔离级别，那是我从业以来唯一一次使用到这个级别。就这样项目终于悄悄低调地迈出了第一步，接着媒体开始铺天盖地报道：国家队进场，行业将面临新一轮的洗牌。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200412182731471.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和很多互联网项目一样，系统架构刚开始是单一的，交易和资金耦合在一起。每一次需求调整都战战兢兢，如履薄冰，生怕影响到了资金模块。后来公司招来了一位支付宝的资深大佬，花名“湿手”，支付系统开始独立出来，我也从那个时候开始了5年的支付生涯。&lt;/p&gt;
&lt;p&gt;有一个关于程序员的笑话就是做飞机系统开发的人不敢坐飞机，做高铁系统开发的人也一定不敢坐高铁，因为大家都深知没有0Bug的系统，不知道什么时候一个隐藏的Bug就爆炸了，措手不及。做支付的这些年来每一个需求我们都脑洞大开，穷尽所有可能，包括“&lt;em&gt;你身边的朋友知道你的卡里有巨额资金找了一个和你一模一样的人去银行以你的名义办理了一张银行卡，有一天你在常用的电脑上登录了网站忘了退出，偏偏又拉肚子去上厕所，情况紧急你还忘了带手机，手机没有锁就摆在桌子上，此时如何保证账户安全？&lt;/em&gt;”等等。去年的时候还有一位企划部的同事找我聊到了网站安全和项目效率如何平衡的问题，问我你们做了这些有意义吗？产线实际发生过账户或者资金安全问题吗？我说正因为有了产品运营、安全、研发、数据中心等一道又一道的防护屏障，因为我们所采取的一系列安全措施，所以系统累计资金处理超过3000亿依然没有出过一次资金损失，0差错。我们要确保的是不要出系统性资金风险，而不是出现资金风险后考虑怎么挽回。&lt;/p&gt;
&lt;p&gt;公司也开始高速发展，一路披荆斩棘，历经千磨万击，进入了行业前3名。我个人也跟随着公司一起成长，由一名开发人员成长为资深项目经理，到助理项目总监，负责支付、大数据、供应链等几个产品线的项目研发管理工作。&lt;/p&gt;

&lt;p&gt;上个月我看到一篇关于腾讯保险的文章，里面讲到了保险系统上线的事情。微保团队秣马厉兵半年，经过各种测试后，终于准备“核武器发射”，启动微保第一单：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020041218284363.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;CTO Jackie 伸出大拇指，像发射核弹的将军一样，把指纹贴向手机按钮。 &amp;gt;“错误！”&lt;br/&gt;几十个老司机忙活了小半年，居然在众目睽睽之下直接翻车，大家脸上都有点发烫。Jackie赶紧让同学们检查原因。忙活了半天，自己的软件逻辑没有找到问题，仔细一看，系统卡在了微信支付这边。和微信同学一确认，才知道，微信支付有个“支付额度上限”，是5000块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于错误，Jackie账户短时间被系统锁定了，于是换成了数据中心负责人Lorry，保险金额2822.99！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;核武器准备，二次发射！&lt;br/&gt;“错误！”&lt;br/&gt;保险公司系统给出来的提示居然是：缴费不足。&lt;br/&gt;两千多都已经扣出去了，你说我缴费不足？？”Lorry 哭笑不得&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;仔细检查，原来是微保的用户业务系统算出金额出错，2822.68元，少算了1分钱。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;架构中心负责人 Hoky 突然想到，这很有可能是因为两种系统使用的编程语言不同。一般 Java 保险系统设计的时候，价格会使用货币类型数值计算，单位是元。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就这样团队又花了四天时间把货币基本单位换成分，才终于成功。&lt;/p&gt;
&lt;p&gt;当时看到这段我是比较惊讶的，腾讯这样一个高手如云的团队居然连犯两个支付系统最基本的常识性错误，而且是在系统上线前的最后一刻碰运气被发现的，就像文章里说的“幸亏当时我们触发了这个 Bug，要是 Jackie 出手没那么大方，真的让普通用户遇到了这个问题，那问题可就大啦！”。&lt;/p&gt;
&lt;p&gt;那时候就想到了X项目，相对于大型互联网动不动就千万级、亿级的流量，X项目或许是微不足道的。但细细回顾，这个项目从0走到现在以来，我们经历了国家政策多次调整，产品规划变更与渐进明细，项目上百次的迭代发布，开发上也踩过无数的坑，这里面还是有很多可以拿出来细细品味的地方。项目上有很多先进的技术和尝试，也有一些历史包袱原因导致依然采用着与现代技术不符的设计在艰难负重前行。《月亮与六便士》的作者毛姆有一句很有名的话:“即使剃刀里也有哲学。项目上也是如此，这个项目里也有着系统设计的哲学，程序员的禅，我们自己理解的禅。&lt;/p&gt;
&lt;p&gt;那些我们习以为常的，其实只是因为我们恰巧经历过而已。&lt;strong&gt;有些人把经历过的坑铺平走过之后，远远地抛在了身后；有些人把坑的深度逆转为自己的高度；&lt;/strong&gt;&lt;br/&gt;千锤万凿，始出深山，烈火焚烧若等闲。挑柴运水无非道，行住坐卧皆是禅。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200412182910278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0phNW9u,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;在我的书架上有一本书摆放了很多年，《禅与摩托车维修艺术》，我时不时会拿出来翻一翻。里面有一句话：“如果一直向前看，或者只看到目前的状况，对你并没有任何意义。一旦你回顾以往，就会看到一种模式隐隐出现。如果你由这个模式出发，那么很可能会迸发出一些东西”。所以，这不是一个故事，这是一个关于项目的重新复盘。&lt;/p&gt;
&lt;p&gt;我有做工作规划的习惯，做月计划、周计划，到每一天具体的工作，从14年至今在我的印象笔记里记录着我每一天的工作。我支付生涯的导师“湿手”在2015年11月06日和我说过一句话：当我们变得挑剔，我们才有提升的空间。接下来的一段时间我将&lt;strong&gt;以挑剔的眼光、现在的能力、现在的经验回过头来回顾这个产品，回顾这个项目，回顾整个系统的技术架构设计，甚至是回顾到某一个案例下现在的代码应该是什么样子。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;让我们在这条路上慢慢地走着，收拾这时光，眉目生欢！&lt;/strong&gt;&lt;br/&gt;下一期，再见。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;架构师，十年戎【码】，老【叔】开花。个人微信号：qiaojs，注明CSDN，一起学习交流。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200412182950207.jpg&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 13 Apr 2020 00:47:00 +0000</pubDate>
<dc:creator>码大叔</dc:creator>
<og:description>以挑剔的眼光、现在的能力、现在的经验回过头来回顾这个产品，回顾这个项目，回顾整个系统的技术架构设计，甚至是回顾到某一个案例下现在的代码应该是什么样子。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/madashu/p/12689276.html</dc:identifier>
</item>
<item>
<title>time_wait 详解和解决方案 - 蘑菇先生</title>
<link>http://www.cnblogs.com/mushroom/p/12686537.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mushroom/p/12686537.html</guid>
<description>&lt;h2 id=&quot;产生原因&quot;&gt;产生原因&lt;/h2&gt;
&lt;img src=&quot;https://github.com/mushroomsir/blog/raw/master/img/tcp-close.png&quot; alt=&quot;image&quot;/&gt;&lt;p&gt;TCP 连接关闭时，会有 4 次通讯（四次挥手），来确认双方都停止收发数据了。如上图，主动关闭方，最后发送 ACK 时，会进入 TIME_WAIT 状态，要等 2MSL 时间后，这条连接才真正消失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要进入 TIME_WAIT 状态？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TCP 的可靠传输机制要求，被动关闭方（简称 S）要确保最后发送的 FIN K 对方能收到。比如网络中的某个路由器出现异常，主动关闭方（简称 C）回复的 ACK K+1 没有及时到达，S 就会重发 FIN K 给 C。如果此时 C 不进入 TIME_WAIT 状态，立马关闭连接，会有 2 种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;C 机器上，有可能新起的连接会重用旧连接的端口，此时新连接就会收到 S 端重发的 FIN K 消息，导致新连接传输出现错误。&lt;/li&gt;
&lt;li&gt;C 机器上，并没有用旧连接端口，此时会回复给 S 端一个 RST 类型的消息，应用程序报 connect reset by peer 异常。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为避免上面情况， TCP 会等待 2 MSL 时间，让 S 发的 FIN K 和 C 回复的 ACK K+1 在网络上消失，才真正清除掉连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么等待 2 MSL 时间？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MSL是 Maximum Segment Lifetime的英文缩写，可译为“最长报文段寿命”，是 TCP 协议规定报文段在网络中最长生存时间，超出后报文段就会被丢弃。RFC793 定义 MSL 为 2 分钟，一般 Linux 会默认设置个更小的值 30 秒。&lt;/p&gt;
&lt;p&gt;MSL 时间，是从 C 回复 ACK 后开始 TIME_WAIT 计时，如果这期间收到 S 重发的 FIN 在回复 ACK 后，重新开始计时。这块代码是 Linux tcp_timewait_state_process 函数处理的。&lt;/p&gt;
&lt;p&gt;而 2 MSL 是为了确保 C 和 S 两端发送的数据都在网络中消失，不会影响后续的新连接，该如何理解？&lt;/p&gt;
&lt;p&gt;假设 C 回复 ACK ，S 经过 t 时间后收到，则有 0 &amp;lt; t &amp;lt;= MSL，因为 C 并不知道 S 多久收到，所以 C 至少要维持 MSL 时间的 TIME_WAIT 状态，才确保回复的 ACK 从网络中消失。 如果 S 在 MSL 时间收到 ACK， 而收到前一瞬间， 因为超时又重传一个 FIN ，这个包又要 MSL 时间才会从网络中消失。&lt;/p&gt;
&lt;p&gt;回复需要 MSL 消失 + 发送需要 MSL 消失 = 2 MSL。&lt;/p&gt;
&lt;h2 id=&quot;导致问题&quot;&gt;导致问题&lt;/h2&gt;
&lt;p&gt;从前面的分析来看，出现 TIME_WAIT 属于正常行为。但在实际生产环境中，大量的 TIME_WAIT 会导致系统异常。&lt;/p&gt;
&lt;p&gt;假设前面的 C 是 Client，S 是 Server，如果 C 或 出现大量的 TIME_WAIT，会导致新连接无端口可以用，出现&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cannot assign requested address&lt;/code&gt; 错误。这是因为端口被占完了，Linux 一般默认端口范围是：32768-61000，可以通过 &lt;code&gt;cat /proc/sys/net/ipv4/ip_local_port_range&lt;/code&gt; 来查看。根据 TCP 连接四元组计算，C 连接 S 最多有 28232 可以用，也就是说最多同时有 28232 个连接保持。&lt;/p&gt;
&lt;p&gt;看着挺多，但如果用短连接的话很快就会出现上面错误，因为每个连接关闭后，需要保持 2 MSL 时间，也就是 4分钟。这意味着 4 分钟内最多建立 28232 个连接，每秒钟 117 个，在高并发系统下一般不够用的。&lt;/p&gt;
&lt;h2 id=&quot;nginx&quot;&gt;Nginx&lt;/h2&gt;
&lt;p&gt;连接主动关闭方会进入 TIME_WAIT，如果 C 先关闭，C 会出现上面错误。如果是客户端时真正的客户（浏览器），一般不会触发上面的错误。&lt;/p&gt;
&lt;p&gt;如果 C 是应用程序或代理，比如 Nginx，此时链路是：浏览器 -&amp;gt; Nginx -&amp;gt; 应用。 因为 Nginx 是转发请求，自身也是客户端，所以如果 Nginx 到应用是短连接，每次转发完请求都主动关闭连接，那很快会触发到端口不够用的错误。&lt;/p&gt;
&lt;p&gt;Nginx 默认配置连接到后端是 HTTP/1.0 不支持 HTTP keep-alive，所以每次后端应用都会主动关闭连接，这样后端出现 TIME_WAIT，而 Nginx 不会出现。&lt;/p&gt;
&lt;p&gt;后端出现大量的 TIME_WAIT 一般问题不明显，但需要注意的点是：&lt;/p&gt;
&lt;p&gt;查看服务器上&lt;code&gt;/var/log/messages&lt;/code&gt; 有没有 &lt;code&gt;TCP: time wait bucket table overflow&lt;/code&gt; 的日志，有的话是超出最大 TIME_WAIT 的数量了，超出后系统会把多余的 TIME_WAIT 删除掉，会导致前面章节介绍的 2 种情况。&lt;/p&gt;
&lt;p&gt;这个错误可以调大内核参数 &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; 中 &lt;code&gt;tcp_max_tw_buckets&lt;/code&gt; 来解决。&lt;/p&gt;
&lt;h3 id=&quot;长连接&quot;&gt;长连接&lt;/h3&gt;
&lt;p&gt;另外个解决方案是 Nginx 与后端调用，启用 HTTP/1.1 开启 keep-alive ，保持长连接。配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-nginx&quot;&gt;http{
    upstream www{
        keepalive 500;  # 与后端最多保持的长连接数量
    }
    proxy_set_header X-Real-IP $remote_addr; ## 不会生效
    server {
        location / {
        proxy_http_version 1.1;  # 启用 HTTP/1.1
        proxy_set_header Connection &quot;&quot;;   
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;proxy_set_header Connection &quot;&quot;;&lt;/code&gt; 这个配置是设置 Nginx 请求后端的 Connection header 的值为空。目的是防止客户端传值 &lt;code&gt;close&lt;/code&gt; 给 Nginx，Nginx 又转发给后端，导致无法保持长连接。&lt;/p&gt;
&lt;p&gt;在 Nginx 配置中有个注意的点是：当前配置 location 中如果定义了 proxy_set_header ，则不会从上级继承&lt;code&gt;proxy_set_header&lt;/code&gt; 了，如上面配置的 &lt;code&gt;proxy_set_header X-Real-IP $remote_addr&lt;/code&gt; 则不会生效。&lt;/p&gt;
&lt;p&gt;没有显示定义的 header，Nginx 默认只带下面 2 个 header：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;proxy_set_header Host $proxy_host;
proxy_set_header Connection close; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;除保持长连接外，调整系统参数也可以解决大量 TIME_WAIT 的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;加快回收&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tcp_tw_timeout = 30：表示连接在 TIME_WAIT 状态下的过期时间。这里配置 30 秒后回收，如前面计算调整后 28232 / 30 = 936， 每秒钟可建立连接 936 个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;增加端口数量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ip_local_port_range = 1024 65535: 调整后最大端口数量 64511，64511 / 30 = 2150，每秒钟可建立连接 2150 个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复用 TIME_WAIT 连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tcp_tw_reuse = 1： 1 表示开启复用 TIME_WAIT 状态的连接，这个参数在 Linux tcp_twsk_unique 函数中读取的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;  int reuse = sock_net(sk)-&amp;gt;ipv4.sysctl_tcp_tw_reuse;
        // tcptw-&amp;gt;tw_ts_recent_stamp 为 1 表示旧的 TIME_WAIT 连接是携带时间戳的，需要开启 tcp_timestamps (已默认开启)。
    // tcp_tw_reuse  reuse 开启复用
   // time_after32 表示旧的 TIME_WAIT 连接，最后收到数据已超过 1 秒。
        if (tcptw-&amp;gt;tw_ts_recent_stamp &amp;amp;&amp;amp;
            (!twp || (reuse &amp;amp;&amp;amp; time_after32(ktime_get_seconds(),
                                            tcptw-&amp;gt;tw_ts_recent_stamp)))) {
                if (likely(!tp-&amp;gt;repair)) {
                        u32 seq = tcptw-&amp;gt;tw_snd_nxt + 65535 + 2;

                        if (!seq)
                                seq = 1;
                        WRITE_ONCE(tp-&amp;gt;write_seq, seq);
                        tp-&amp;gt;rx_opt.ts_recent    = tcptw-&amp;gt;tw_ts_recent;
                        tp-&amp;gt;rx_opt.ts_recent_stamp = tcptw-&amp;gt;tw_ts_recent_stamp;
                }
                sock_hold(sktw);
                return 1;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其他&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;tcp_tw_recycle 也有效果，但不建议调整，Linux 4.12 后已经移除这个参数了，这里不做介绍了。&lt;/p&gt;
&lt;p&gt;调整命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;// 临时生效
sysctl -w net.ipv4.tcp_tw_reuse = 1
sysctl -p

// 长久生效
vi /etc/sysctl.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header&quot;&gt;http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/torvalds/linux&quot;&gt;https://github.com/torvalds/linux&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&quot;&gt;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 00:45:00 +0000</pubDate>
<dc:creator>蘑菇先生</dc:creator>
<og:description>&amp;quot;1. 产生原因&amp;quot; &amp;quot;2. 导致问题&amp;quot; &amp;quot;3. Nginx&amp;quot; &amp;quot;3.1 长连接&amp;quot; &amp;quot;4. 解决方案&amp;quot;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mushroom/p/12686537.html</dc:identifier>
</item>
<item>
<title>曹工说Redis源码（3）-- redis server 启动过程完整解析（中） - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/12685918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/12685918.html</guid>
<description>&lt;p&gt;Redis源码系列的初衷，是帮助我们更好地理解Redis，更懂Redis，而怎么才能懂，光看是不够的，建议跟着下面的这一篇，把环境搭建起来，后续可以自己阅读源码，或者跟着我这边一起阅读。由于我用c也是好几年以前了，些许错误在所难免，希望读者能不吝指出。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12637730.html&quot;&gt;曹工说Redis源码（1）-- redis debug环境搭建，使用clion，达到和调试java一样的效果&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/grey-wolf/p/12682760.html&quot;&gt;曹工说Redis源码（2）-- redis server 启动过程解析及简单c语言基础知识补充&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;首先，会再补充一点c语言中，指针的相关知识；接下来，开始接着昨天的那篇，讲redis的启动过程，由大到小来讲，避免迅速陷入到细节中。&lt;/p&gt;

&lt;p&gt;指针，其实就是指向一个内存地址，在知道这个地址前后存储的内容的前提下，这个指针可以被你任意解释。我举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct Test_Struct{
    int a;
    int b;
}Test_Struct;

int main() {
    // 1
    void *pVoid = malloc(4);
    // 2
    memset(pVoid,0x01,4);

    // 3
    int *pInt = pVoid;
    // 4
    char *pChar = pVoid;
    // 5
    short *pShort = pVoid;
    // 6
    Test_Struct *pTestStruct = pVoid;

    // 7
    printf(&quot;address:%p, point to %d\n&quot;, pChar, *pChar);
    printf(&quot;address:%p, point to %d\n&quot;, pShort, *pShort);
    printf(&quot;address:%p, point to %d\n&quot;, pInt, *pInt);
    printf(&quot;address:%p, point to %d\n&quot;, pTestStruct, pTestStruct-&amp;gt;a);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;12.996710526316&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;1处，分配一片内存，4个字节，32位；返回一个指针，指向这片内存区域，准确地说，指向第一个字节，因为分配的内存是连续的，你可以理解为数组。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;The malloc() function allocates size bytes and returns a pointer to the allocated memory.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;10.91296625222&quot;&gt;
&lt;p&gt;2处，调用memset，将这个pVoid 指向的内存开始的4个字节，设置为0x01，其实就是把每个字节设置为00000001。&lt;/p&gt;
&lt;p&gt;这个memset的注释如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;NAME
       memset - fill memory with a constant byte

SYNOPSIS
       #include &amp;lt;string.h&amp;gt;

       void *memset(void *s, int c, size_t n);

DESCRIPTION
       The memset() function fills the first n bytes of the memory area pointed to by s with the constant byte c.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料： &lt;a href=&quot;https://www.cnblogs.com/yhlboke-1992/p/9292877.html&quot;&gt;https://www.cnblogs.com/yhlboke-1992/p/9292877.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里我们把每个字节，设为0x01，最终的二进制，其实就是如下这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202004/519126-20200412112625206-1670770591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;3处，定义int类型的指针，将pVoid赋值给它，int占4字节&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;4处，定义char类型的指针，将pVoid赋值给它，char占1字节&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;5处，定义short类型的指针，将pVoid赋值给它，short占2字节&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;6处，定义Test_Struct类型的指针，这是个结构体，类似于高级语言的类，这个结构体的结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct Test_Struct{
    int a;
    int b;
}Test_Struct;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，我们将pVoid赋值给它。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;7处，分别打印各类指针的地址，和对其解引用后的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202004/519126-20200412113008295-1687253269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;257的二进制就是：0000 0001 0000 0001&lt;/p&gt;
&lt;p&gt;16843009的二进制就是：0000 0001 0000 0001 0000 0001 0000 0001&lt;/p&gt;
&lt;p&gt;结构体那个，也好理解，因为这个结构体，第一个属性a，就是int类型的，占4个字节。&lt;/p&gt;
&lt;p&gt;另外，大家要注意，上面输出的指针地址都是一模一样的。&lt;/p&gt;
&lt;p&gt;如果大家能理解这个demo，再看看这个链接，相信会更加理解指针：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.runoob.com/cprogramming/c-pointer-arithmetic.html&quot;&gt;C 指针的算术运算&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int main(int argc, char **argv) {
    struct timeval tv;

    /**
     * 1 设置时区等等
     */
    setlocale(LC_COLLATE,&quot;&quot;);
    ...

    // 2 检查服务器是否以 Sentinel 模式启动
    server.sentinel_mode = checkForSentinelMode(argc,argv);

    // 3 初始化服务器配置
    initServerConfig();

        // 4
    if (server.sentinel_mode) {
        initSentinelConfig();
        initSentinel();
    }

    // 5 检查用户是否指定了配置文件，或者配置选项
    if (argc &amp;gt;= 2) {
        ...
        // 载入配置文件， options 是前面分析出的给定选项
        loadServerConfig(configfile,options);
        sdsfree(options);
    }

    // 6 将服务器设置为守护进程
    if (server.daemonize) daemonize();

    // 7 创建并初始化服务器数据结构
    initServer();

    // 8 如果服务器是守护进程，那么创建 PID 文件
    if (server.daemonize) createPidFile();

    // 9 为服务器进程设置名字
    redisSetProcTitle(argv[0]);

    // 10 打印 ASCII LOGO
    redisAsciiArt();

    // 11 如果服务器不是运行在 SENTINEL 模式，那么执行以下代码
    if (!server.sentinel_mode) {
        // 从 AOF 文件或者 RDB 文件中载入数据
        loadDataFromDisk();
        // 启动集群
        if (server.cluster_enabled) {
            if (verifyClusterConfigWithData() == REDIS_ERR) {
                redisLog(REDIS_WARNING,
                    &quot;You can't have keys in a DB different than DB 0 when in &quot;
                    &quot;Cluster mode. Exiting.&quot;);
                exit(1);
            }
        }
        // 打印 TCP 端口
        if (server.ipfd_count &amp;gt; 0)
            redisLog(REDIS_NOTICE,&quot;The server is now ready to accept connections on port %d&quot;, server.port);
    } else {
        sentinelIsRunning();
    }

    // 12 运行事件处理器，一直到服务器关闭为止
    aeSetBeforeSleepProc(server.el,beforeSleep);
    aeMain(server.el);

    // 13 服务器关闭，停止事件循环
    aeDeleteEventLoop(server.el);

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;1，2，3处，在前面那篇中已经讲过，主要是初始化各种配置参数，比如socket相关的；redis.conf中涉及的，aof，rdb，replication，sentinel等；redis server自己内部的数据结构等，如runid，配置文件地址，服务器的相关信息（32位还是64位，因为redis直接运行在操作系统上，而不是像高级语言有虚拟机，32位和64位下，不同数据的长度是不同的），日志级别，最大客户端数量，客户端最大idle时间等等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;4处，因为sentinel和普通的redis server其实是共用同一份代码，所以这里启动时，要看是启动sentinel，还是启动普通的redis server，如果是启动sentinel，则进行sentinel相关配置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;5处，检查启动时的命令行参数中，是否指定了配置文件，如果指定了，要使用配置文件的配置为准&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;6处，设置为守护进程&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;7处，根据前面的配置，初始化redis server&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;8处，创建pid文件，一般默认路径：/var/run/redis.pid，这个可以在redis.conf进行配置，如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pidfile &quot;/var/run/redis_6379.pid&quot;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;9处，为服务器进程设置名字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;10处，打印logo&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;11处，如果不是sentinel模式启动的话，加载aof或rdb文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;12处，跳入死循环，开始等待接收连接，处理客户端的请求；同时，周期执行后台任务，比如删除过期key等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;13处，服务器关闭，一般来说，走不到这里，一般都是陷入在12处的死循环中；只有在某些场景下，将一个全局变量stop修改为true后，程序会从12处跳出死循环，然后走到这里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一节，主要是细化前面的第7步操作，即初始化redis server。这一个函数,位于redis.c中，名为initServer，做的事情很多，接下来会顺序讲解。&lt;/p&gt;
&lt;h2 id=&quot;设置全局的信号处理函数&quot;&gt;设置全局的信号处理函数&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    // 设置信号处理函数
    signal(SIGHUP, SIG_IGN);
    signal(SIGPIPE, SIG_IGN);
    setupSignalHandlers();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最重要的是最后一行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void setupSignalHandlers(void) {
    // 1
    struct sigaction act;

    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction is used.
     * Otherwise, sa_handler is used. */
    sigemptyset(&amp;amp;act.sa_mask);
    act.sa_flags = 0;
    // 2
    act.sa_handler = sigtermHandler;
    // 3
    sigaction(SIGTERM, &amp;amp;act, NULL);

    return;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3处，设置了：接收到SIGTERM信号时，使用&lt;code&gt;act&lt;/code&gt;来处理信号，act在1处定义，是一个局部变量，它有一个字段，在2处被赋值，这是一个函数指针。函数指针类似于java中的一个static方法的引用，为什么是static，因为执行这类方法不需要new一个对象；在c语言中，所有的方法都是最顶级的，调用时，不需要new一个对象；所以，从这点来说，c语言的函数指针类似java中的static方法的引用。&lt;/p&gt;
&lt;p&gt;我们可以看看2处，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    act.sa_handler = sigtermHandler;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个sigtermHandler，应该就是一个全局函数了，看看其怎么被定义的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// SIGTERM 信号的处理器
static void sigtermHandler(int sig) {
    REDIS_NOTUSED(sig);

    redisLogFromHandler(REDIS_WARNING,&quot;Received SIGTERM, scheduling shutdown...&quot;);
    
    // 打开关闭标识
    server.shutdown_asap = 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数就是打开server这个全局变量的shutdown_asap。这个字段在以下地方被使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;serverCron in redis.c
    
        /* We received a SIGTERM, shutting down here in a safe way, as it is
     * not ok doing so inside the signal handler. */
    // 服务器进程收到 SIGTERM 信号，关闭服务器
    if (server.shutdown_asap) {

        // 尝试关闭服务器
        if (prepareForShutdown(0) == REDIS_OK) exit(0);

        // 如果关闭失败，那么打印 LOG ，并移除关闭标识
        redisLog(REDIS_WARNING,&quot;SIGTERM received but errors trying to shut down the server, check the logs for more information&quot;);
        server.shutdown_asap = 0;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上这段代码的第一行，标识了这段代码所处的位置，为redis.c中的serverCron函数，这个函数，就是redis server的周期执行函数，类似于java中的ScheduledThreadPoolExecutor，当这个周期任务，检测到server.shutdown_asap打开后，就会去关闭服务器。&lt;/p&gt;
&lt;p&gt;那，上面这个接收到信号，要执行的动作说完了，那么，什么是信号，信号其实是linux下进程间通讯的一种手段，比如kill -9 ，就会给对应的pid，发送一个SIGKILL 命令；在redis前台运行时，你按下ctrl + c，其实也是发送了一个信号，信号为SIGINT，值为2。大家可以看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202004/519126-20200412132646813-242498138.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，前面我们注册的信号是哪个呢，是：SIGTERM，15。也就是我们按下kill -15时，会触发这个信号。&lt;/p&gt;
&lt;p&gt;关于kill 9 和kill 15的差别，可以看这篇博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_33468857/article/details/86672803&quot;&gt;Linux kill -9 和 kill -15 的区别&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;开启syslog&quot;&gt;开启syslog&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 设置 syslog
if (server.syslog_enabled) {
    openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,
        server.syslog_facility);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个就是发送日志到linux系统的syslog，可以看看openlog函数的说明：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;send messages to the system logger&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个感觉用得不多，可以查阅：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/thjwsw/article/details/104287387&quot;&gt;redis 的syslog日志没有打印出来的探索过程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;初始化当前redisserver的部分属性&quot;&gt;初始化当前redisServer的部分属性&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;  // 初始化并创建数据结构
    server.current_client = NULL;
        // 1
    server.clients = listCreate();
    server.clients_to_close = listCreate();
    server.slaves = listCreate();
    server.monitors = listCreate();
    server.slaveseldb = -1; /* Force to emit the first SELECT command. */
    server.unblocked_clients = listCreate();
    server.ready_keys = listCreate();
    server.clients_waiting_acks = listCreate();
    server.get_ack_from_slaves = 0;
    server.clients_paused = 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个其实没啥说的，大家看到，比如1处，这个server.clients，server是一个全局变量，维护当前redis server的各种状态，clients呢，是用来保存当前连接到redis server的客户端，类型为链表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    // 一个链表，保存了所有客户端状态结构
    list *clients;              /* List of active clients */
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，这里其实就是调用&lt;code&gt;listCreate()&lt;/code&gt;，创建了一个空链表，然后赋值给clients。&lt;/p&gt;
&lt;p&gt;其他属性，类似。&lt;/p&gt;
&lt;h2 id=&quot;创建常量字符串池，供复用&quot;&gt;创建常量字符串池，供复用&lt;/h2&gt;
&lt;p&gt;大家知道，redis在返回响应的时候，通常就是一句：&quot;+OK&quot;之类的。这个字符串，如果每次响应的时候，再去new一个，也太浪费了，所以，干脆，redis自己把这些常用的字符串，缓存了起来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void createSharedObjects(void) {
    int j;

    // 常用回复
    shared.crlf = createObject(REDIS_STRING,sdsnew(&quot;\r\n&quot;));
    shared.ok = createObject(REDIS_STRING,sdsnew(&quot;+OK\r\n&quot;));
    shared.err = createObject(REDIS_STRING,sdsnew(&quot;-ERR\r\n&quot;));
    ...
    // 常用错误回复
    shared.wrongtypeerr = createObject(REDIS_STRING,sdsnew(
        &quot;-WRONGTYPE Operation against a key holding the wrong kind of value\r\n&quot;));
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个和java中，把字符串字面量缓存起来，是一样的，都是为了提高性能；java里，不是还把128以内的整数也缓存了吗，对吧。&lt;/p&gt;
&lt;h2 id=&quot;调整进程可以打开的最大文件数&quot;&gt;调整进程可以打开的最大文件数&lt;/h2&gt;
&lt;p&gt;服务器一般在真实线上环境，如果是需要应对高并发的话，可能会有几十上百万的客户端，和服务器上的某个进程，建立tcp连接，而这时候，一般就需要调整进程可以打开的最大文件数（socket也是文件）。&lt;/p&gt;
&lt;p&gt;在阅读redis源码之前，我知道的，修改进程可以打开的最大文件数的方式是通过ulimit，具体的，大家可以看下面这两个链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.iteye.com/blog/jameswxx-2096461&quot;&gt;linux最大文件句柄数量总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zlslch/p/6478773.html&quot;&gt;Elasticsearch之优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，在这个源码中，发现了另外一种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取当前的指定资源的限制值的api&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#define RLIMIT_NOFILE     5               /* max number of open files */
    
struct rlimit {
        rlim_t  rlim_cur;
        rlim_t  rlim_max;
};
struct rlimit limit;

getrlimit(RLIMIT_NOFILE,&amp;amp;limit)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这个代码，获取当前系统中，NOFILE（进程最大文件数）这个值的资源限制大小。&lt;/p&gt;
&lt;p&gt;通过man getrlimit（需要先安装，安装方式:&lt;code&gt;yum install man-pages.noarch&lt;/code&gt;），可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/519126/202004/519126-20200412152655816-1836272354.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;setrlimit则可以设置资源的相关限制&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;limit.rlim_cur = f;
limit.rlim_max = f;
setrlimit(RLIMIT_NOFILE,&amp;amp;limit)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;创建事件循环相关数据结构&quot;&gt;创建事件循环相关数据结构&lt;/h2&gt;
&lt;p&gt;事件循环器的结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;/* 
 * State of an event based program 
 *
 * 事件处理器的状态
 */
typedef struct aeEventLoop {

    // 目前已注册的最大描述符
    int maxfd;   /* highest file descriptor currently registered */

    // 目前已追踪的最大描述符
    int setsize; /* max number of file descriptors tracked */

    // 用于生成时间事件 id
    long long timeEventNextId;

    // 最后一次执行时间事件的时间
    time_t lastTime;     /* Used to detect system clock skew */

    // 已注册的文件事件
    aeFileEvent *events; /* Registered events */

    // 已就绪的文件事件
    aeFiredEvent *fired; /* Fired events */

    // 时间事件
    aeTimeEvent *timeEventHead;

    // 事件处理器的开关
    int stop;

    // 多路复用库的私有数据
    void *apidata; /* This is used for polling API specific data */

    // 在处理事件前要执行的函数
    aeBeforeSleepProc *beforesleep;

} aeEventLoop;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;初始化上面这个数据结构的代码在：aeCreateEventLoop in redis.c&lt;/p&gt;
&lt;p&gt;上面这个结构中，主要就是：&lt;/p&gt;
&lt;ol readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;apidata中，主要用于存储多路复用库的相关数据，每次调用多路复用库，去进行select时，如果发现有就绪的io事件发生，就会存放到 fired 属性中。&lt;/p&gt;
&lt;p&gt;比如，select就是linux下，老版本的linux内核中，多路复用的一种实现，redis中，其代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {
        ...
        // 1
    retval = select(eventLoop-&amp;gt;maxfd+1,
                &amp;amp;state-&amp;gt;_rfds,&amp;amp;state-&amp;gt;_wfds,NULL,tvp);
    if (retval &amp;gt; 0) {
        for (j = 0; j &amp;lt;= eventLoop-&amp;gt;maxfd; j++) {
                        ...
            // 2
            eventLoop-&amp;gt;fired[numevents].fd = j;
            eventLoop-&amp;gt;fired[numevents].mask = mask;
            numevents++;
        }
    }
    return numevents;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;省略了部分代码，其中，1处，进行select，这一步类似于java中nio的select操作；2处，将select返回的，已就绪的文件描述符，填充到fired 属性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;另外，我们提到过，redis有一些后台任务，比如清理过期key，这个不是一蹴而就的；每次周期运行后台任务时，就会去清理一部分，而这里的后台任务，其实就是上面这个数据结构中的时间事件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    // 时间事件
    aeTimeEvent *timeEventHead;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;分配16个数据库的内存空间&quot;&gt;分配16个数据库的内存空间&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;server.db = zmalloc(sizeof(redisDb) * server.dbnum);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;打开listen端口，监听请求&quot;&gt;打开listen端口，监听请求&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    /* Open the TCP listening socket for the user commands. */
    // 打开 TCP 监听端口，用于等待客户端的命令请求
    listenToPort(server.port, server.ipfd, &amp;amp;server.ipfd_count)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里就是打开平时的6379端口的地方。&lt;/p&gt;
&lt;h2 id=&quot;初始化16个数据库对应的数据结构&quot;&gt;初始化16个数据库对应的数据结构&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    /* Create the Redis databases, and initialize other internal state. */
    // 创建并初始化数据库结构
    for (j = 0; j &amp;lt; server.dbnum; j++) {
        server.db[j].dict = dictCreate(&amp;amp;dbDictType, NULL);
        server.db[j].expires = dictCreate(&amp;amp;keyptrDictType, NULL);
        server.db[j].blocking_keys = dictCreate(&amp;amp;keylistDictType, NULL);
        server.db[j].ready_keys = dictCreate(&amp;amp;setDictType, NULL);
        server.db[j].watched_keys = dictCreate(&amp;amp;keylistDictType, NULL);
        server.db[j].eviction_pool = evictionPoolAlloc();
        server.db[j].id = j;
        server.db[j].avg_ttl = 0;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;db的数据结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct redisDb {

    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;                 /* The keyspace for this DB */

    // 键的过期时间，字典的键为键，字典的值为过期事件 UNIX 时间戳
    dict *expires;              /* Timeout of keys with a timeout set */

    // 正处于阻塞状态的键
    dict *blocking_keys;        /* Keys with clients waiting for data (BLPOP) */

    // 可以解除阻塞的键
    dict *ready_keys;           /* Blocked keys that received a PUSH */

    // 正在被 WATCH 命令监视的键
    dict *watched_keys;         /* WATCHED keys for MULTI/EXEC CAS */

    struct evictionPoolEntry *eviction_pool;    /* Eviction pool of keys */

    // 数据库号码
    int id;                     /* Database ID */

    // 数据库的键的平均 TTL ，统计信息
    long long avg_ttl;          /* Average TTL, just for stats */

} redisDb;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里可以看到，设置了过期时间的key，除了会在 dict 属性存储，还会新增一条记录到 expires 字典。&lt;/p&gt;
&lt;p&gt;expires字典的key：执行键的指针；value：过期时间。&lt;/p&gt;
&lt;h2 id=&quot;创建pubsub相关数据结构并初始化&quot;&gt;创建pub/sub相关数据结构并初始化&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    // 创建 PUBSUB 相关结构
    server.pubsub_channels = dictCreate(&amp;amp;keylistDictType, NULL);
    server.pubsub_patterns = listCreate();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;初始化部分统计属性&quot;&gt;初始化部分统计属性&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;  // serverCron() 函数的运行次数计数器
    server.cronloops = 0;
    // 负责执行 BGSAVE 的子进程的 ID
    server.rdb_child_pid = -1;
    // 负责进行 AOF 重写的子进程 ID
    server.aof_child_pid = -1;
    aofRewriteBufferReset();
    // AOF 缓冲区
    server.aof_buf = sdsempty();
    // 最后一次完成 SAVE 的时间
    server.lastsave = time(NULL); /* At startup we consider the DB saved. */
    // 最后一次尝试执行 BGSAVE 的时间
    server.lastbgsave_try = 0;    /* At startup we never tried to BGSAVE. */
    server.rdb_save_time_last = -1;
    server.rdb_save_time_start = -1;
    server.dirty = 0;
    resetServerStats();
    /* A few stats we don't want to reset: server startup time, and peak mem. */
    //  服务器启动时间
    server.stat_starttime = time(NULL);
    //  已使用内存峰值
    server.stat_peak_memory = 0;
    server.resident_set_size = 0;
    // 最后一次执行 SAVE 的状态
    server.lastbgsave_status = REDIS_OK;
    server.aof_last_write_status = REDIS_OK;
    server.aof_last_write_errno = 0;
    server.repl_good_slaves_count = 0;
    updateCachedTime();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设置时间事件对应的函数指针&quot;&gt;设置时间事件对应的函数指针&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    /* Create the serverCron() time event, that's our main way to process
     * background operations. */    
        // 为 serverCron() 创建时间事件
    if (aeCreateTimeEvent(server.el, 1, serverCron, NULL, NULL) == AE_ERR) {
        redisPanic(&quot;Can't create the serverCron time event.&quot;);
        exit(1);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的serverCron就是一个函数，后续每次周期触发时间事件时，就会运行这个serverCron。&lt;/p&gt;
&lt;p&gt;可以看这里的英文注释，作者也提到，这是主要的处理后台任务的方式。&lt;/p&gt;
&lt;p&gt;这块以后也会重点分析。&lt;/p&gt;
&lt;h2 id=&quot;设置connect事件对应的连接处理器&quot;&gt;设置connect事件对应的连接处理器&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler, NULL)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的acceptTcpHandler就是处理新连接的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {
    int cport, cfd, max = MAX_ACCEPTS_PER_CALL;
    char cip[REDIS_IP_STR_LEN];
    REDIS_NOTUSED(el);
    REDIS_NOTUSED(mask);
    REDIS_NOTUSED(privdata);

    while (max--) {
        // accept 客户端连接
        cfd = anetTcpAccept(server.neterr, fd, cip, sizeof(cip), &amp;amp;cport);
        if (cfd == ANET_ERR) {
            if (errno != EWOULDBLOCK)
                redisLog(REDIS_WARNING,
                         &quot;Accepting client connection: %s&quot;, server.neterr);
            return;
        }
        // 为客户端创建客户端状态（redisClient）
        acceptCommonHandler(cfd, 0);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建aof文件&quot;&gt;创建aof文件&lt;/h2&gt;
&lt;p&gt;如果aof打开了，就需要创建aof文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    if (server.aof_state == REDIS_AOF_ON) {
        server.aof_fd = open(server.aof_filename,
                             O_WRONLY | O_APPEND | O_CREAT, 0644);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;剩下的几个，暂时不涉及的任务&quot;&gt;剩下的几个，暂时不涉及的任务&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;    // 如果服务器以 cluster 模式打开，那么初始化 cluster
    if (server.cluster_enabled) clusterInit();

    // 初始化复制功能有关的脚本缓存
    replicationScriptCacheInit();

    // 初始化脚本系统
    scriptingInit();

    // 初始化慢查询功能
    slowlogInit();

    // 初始化 BIO 系统
    bioInit();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的几个，我们暂时还讲解不到，先看看就行。&lt;/p&gt;
&lt;p&gt;到此，初始化redis server，就基本结束了。&lt;/p&gt;

&lt;p&gt;本讲内容较多，主要是redis启动过程中，要做的事，也太多了。希望我已经大致讲清楚了，其中，连接处理器那些都只是大致讲了，后面会继续。谢谢大家。&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 00:33:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>文章导航 Redis源码系列的初衷，是帮助我们更好地理解Redis，更懂Redis，而怎么才能懂，光看是不够的，建议跟着下面的这一篇，把环境搭建起来，后续可以自己阅读源码，或者跟着我这边一起阅读。由于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/grey-wolf/p/12685918.html</dc:identifier>
</item>
<item>
<title>从一个慢查询到MySQL字符集编码 - bush2582</title>
<link>http://www.cnblogs.com/bush2582/p/12688451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bush2582/p/12688451.html</guid>
<description>&lt;h2 id=&quot;1-问题起源&quot;&gt;1. 问题起源&lt;/h2&gt;
&lt;p&gt;最近在完成一个线上日志修复工作的过程中遇到了一个意想不到的慢查询。当时使用的SQL以及表结构其实都很简单，而且在关键的字段上也有索引，但是MySQL的执行计划就是跑出来了Range checked for each record (index map: 0x1)。如下为问题中的表结构定义和执行计划（删减了其他字段，留下了关键的部分）:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;Create Table: CREATE TABLE `Order1` (
  `orderid` varchar(255) COLLATE latin1_bin DEFAULT NULL,
  `productid` varchar(255) COLLATE latin1_bin DEFAULT NULL,
  KEY `productid` (`productid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1 COLLATE=latin1_bin
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;Create Table: CREATE TABLE `Product` (
  `productid` varchar(255) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  KEY (`productid`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; explain select * from  Order1 left join Product using (productid ) ;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+------------------------------------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                          |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+------------------------------------------------+
|  1 | SIMPLE      | Order1  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL                                           |
|  1 | SIMPLE      | Product | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |    1 |   100.00 | Range checked for each record (index map: 0x1) |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+------------------------------------------------+
2 rows in set, 2 warnings (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常情况下我们希望MySQL使用到表中定义的索引productid，并且执行计划应该是如下的情形：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; explain select * from  Order1 left join Product using (productid ) ;
+----+-------------+---------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------+
| id | select_type | table   | partitions | type   | possible_keys | key     | key_len | ref                  | rows | filtered | Extra |
+----+-------------+---------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------+
|  1 | SIMPLE      | Order1  | NULL       | ALL    | NULL          | NULL    | NULL    | NULL                 |    1 |   100.00 | NULL  |
|  1 | SIMPLE      | Product | NULL       | eq_ref | PRIMARY       | PRIMARY | 257     | Order1.productid |    1 |   100.00 | NULL  |
+----+-------------+---------+------------+--------+---------------+---------+---------+----------------------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是最后MySQL的执行过程就是没有使用索引，甚至于强制索引force index 也没有用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; explain select * from  Order1 left  join Product force index (productid) on Order1.productid = Product.productid ;
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+------------------------------------------------+
| id | select_type | table   | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                          |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+------------------------------------------------+
|  1 | SIMPLE      | Order1  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    1 |   100.00 | NULL                                           |
|  1 | SIMPLE      | Product | NULL       | ALL  | productid     | NULL | NULL    | NULL |    1 |   100.00 | Range checked for each record (index map: 0x1) |
+----+-------------+---------+------------+------+---------------+------+---------+------+------+----------+------------------------------------------------+
2 rows in set, 2 warnings (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当时有些懵逼没太明白是因为什么。后面经过一顿GOOGLE之后，明白了其实是字符集排序规则导致的。观察可以发现两张表的字符集排序规则其实是不一样的。Product默认字符集是latin1 ，在MySQL中默认字符集的排序规则是latin1_swedish_ci，而Order1表中的productid 的排序规则是latin1_bin。因此对于MySQL来说没法使用索引进行join，只能使用Range checked for each record的方式来完成查询。由此可见在SQL执行的过程中，字符集和字符集排序规则对于执行计划也是相当重要的。而在MySQL数据库的字符集设置相当灵活和复杂，因此经常容易导致各种问题（例如索引失效，乱码，字符集转换损失性能等），因此本文专门整理和介绍下MySQL字符集相关的内容，为DBA同学和开发同学在实际工作中提供一些参考信息。&lt;/p&gt;
&lt;h2 id=&quot;2-mysql字符集和字符集排序规则&quot;&gt;2. MySQL字符集和字符集排序规则&lt;/h2&gt;
&lt;h3 id=&quot;21-字符集相关概念&quot;&gt;2.1 字符集相关概念&lt;/h3&gt;
&lt;p&gt;在谈起数据库的字符集之前，首先需要了解下字符，字符集和字符编码的概念。相信很多人在一开始的时候也对这些概念比较混乱。（以下的概念说明摘自维基百科和百度百科）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;字符&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6&quot;&gt;电脑&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9B%BB%E4%BF%A1&quot;&gt;电信&lt;/a&gt;领域中，&lt;strong&gt;字符&lt;/strong&gt;（Character）是一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%B3%87%E8%A8%8A&quot;&gt;信息&lt;/a&gt;单位。对使用&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AD%97%E6%AF%8D%E7%B3%BB%E7%B5%B1&quot;&gt;字母系统&lt;/a&gt;或&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9F%B3%E7%AF%80%E6%96%87%E5%AD%97&quot;&gt;音节文字&lt;/a&gt;等&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E8%AA%9E%E8%A8%80&quot;&gt;自然语言&lt;/a&gt;，它大约对应为一个&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E9%9F%B3%E4%BD%8D&quot;&gt;音位&lt;/a&gt;、类音位的单位或符号。简单来讲就是一个汉字、假名、韩文字……，或是一个英文、其他西方语言的字母&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&quot;&gt;[1]&lt;/a&gt;。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;字符集&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;字符集（Character set）是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86/946585?fr=aladdin&quot;&gt;[2]&lt;/a&gt;。同时字符集还为每个集合中的字符规定了一套编码规则，将每个字符与一个编码做映射。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;字符编码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;字符编码（英语：Character encoding）也称字集码，是把&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86&quot;&gt;字符集&lt;/a&gt;中的&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6/4768913&quot;&gt;字符&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E7%BC%96%E7%A0%81&quot;&gt;编码&lt;/a&gt;为指定&lt;a href=&quot;https://baike.baidu.com/item/%E9%9B%86%E5%90%88&quot;&gt;集合&lt;/a&gt;中某一&lt;a href=&quot;https://baike.baidu.com/item/%E5%AF%B9%E8%B1%A1/17158&quot;&gt;对象&lt;/a&gt;（例如：&lt;a href=&quot;https://baike.baidu.com/item/%E6%AF%94%E7%89%B9/3431582&quot;&gt;比特&lt;/a&gt;模式、&lt;a href=&quot;https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394&quot;&gt;自然数&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%BA%8F%E5%88%97/1302588&quot;&gt;序列&lt;/a&gt;、8位组或者&lt;a href=&quot;https://baike.baidu.com/item/%E7%94%B5%E8%84%89%E5%86%B2/10706490&quot;&gt;电脉冲&lt;/a&gt;），以便&lt;a href=&quot;https://baike.baidu.com/item/%E6%96%87%E6%9C%AC/5443630&quot;&gt;文本&lt;/a&gt;在&lt;a href=&quot;https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338&quot;&gt;计算机&lt;/a&gt;中存储和通过&lt;a href=&quot;https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1&quot;&gt;通信&lt;/a&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C&quot;&gt;网络&lt;/a&gt;的传递&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/8446880&quot;&gt;[3]&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;由上面的概念可以见得，字符集就是一组字符的抽象集合，也可以称为字符集合，例如所有的汉字可以算成一个字符集，所有的英文字母也可以算成一个字符集。字符集只是逻辑上的概念，如何将字符集映射到计算机世界中具体的表现呢？就是靠字符编码。在计算机中信息是以一个个0和1表示的，因此字符集最后也是需要在计算机世界中表现成二进制的形式存储。字符集编码就给出了从逻辑上的字符集到二进制编码的映射。例如我们经常在工作中听到unicode 和utf-8，unicode就是一个字符集，而utf-8是unicode 字符集在计算机中具体的实现方式。换句话说，字符集规定了有多少的字符，每个字符的编码是多少(例如ASCII码表中，01000011这个二进制对应的十进制是67，代表的是C)，而字符集编码将字符集中规定的编码转换成最终的二进制格式(比如ASCII码表中C的编码是67，可以使用单字节0x43表示这种编码方案表示，也可以使用多个字节，例如0x0043来表示)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB9b0b346a794fb4da28c5ad9d6470b24f?method=download&amp;amp;shareKey=0c9a98cfef162f5b70332f8b4cd052d7&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ps:关于字符集相关的更多介绍可以参见如下的参考文献：&lt;/p&gt;
&lt;p&gt;[1].&lt;a href=&quot;https://www.cnblogs.com/kerrycode/p/11170266.html,2019-07-11&quot;&gt;字符集与排序规则概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2].&lt;a href=&quot;https://www.cnblogs.com/benbenalin/p/6882293.html,2017-05-20&quot;&gt;刨根究底字符编码之一——关键术语解释(上)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3].&lt;a href=&quot;https://www.huaijiujia.com/2018/09/11/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81-%E6%95%99%E7%A8%8B1-%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/,2018-09-11&quot;&gt;字符编码-教程(1)-概述与基本知识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4].&lt;a href=&quot;https://zhuanlan.zhihu.com/p/46216008,2018-10-08&quot;&gt;程序员必备：彻底弄懂常见的7种中文字符编码&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-mysql中的字符集和字符集排序规则&quot;&gt;2.2 MySQL中的字符集和字符集排序规则&lt;/h3&gt;
&lt;h4 id=&quot;221-字符集和字符集排序基本概念&quot;&gt;2.2.1 字符集和字符集排序基本概念&lt;/h4&gt;
&lt;p&gt;上一节简单介绍了字符集相关的概念，本节开始讲介绍MySQL的字符集以及字符集排序规则相关内容。一般而言MySQL中的字符集和前文介绍的字符集没有任何的区别。包括了工作中常用的字符集例如Latin1、GBK、GB2312、BIG5、UTF8、UTF8MB4、UTF16、UTF32等等。通过命令SHOW CHARACTER SET，可以看到MySQL支持的所有字符集：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;+----------+---------------------------------+---------------------+--------+
| Charset  | Description                     | Default collation   | Maxlen |
+----------+---------------------------------+---------------------+--------+
| big5     | Big5 Traditional Chinese        | big5_chinese_ci     |      2 |
| dec8     | DEC West European               | dec8_swedish_ci     |      1 |
| cp850    | DOS West European               | cp850_general_ci    |      1 |
| hp8      | HP West European                | hp8_english_ci      |      1 |
| koi8r    | KOI8-R Relcom Russian           | koi8r_general_ci    |      1 |
| latin1   | cp1252 West European            | latin1_swedish_ci   |      1 |
| latin2   | ISO 8859-2 Central European     | latin2_general_ci   |      1 |
| swe7     | 7bit Swedish                    | swe7_swedish_ci     |      1 |
| ascii    | US ASCII                        | ascii_general_ci    |      1 |
| ujis     | EUC-JP Japanese                 | ujis_japanese_ci    |      3 |
| sjis     | Shift-JIS Japanese              | sjis_japanese_ci    |      2 |
| hebrew   | ISO 8859-8 Hebrew               | hebrew_general_ci   |      1 |
| tis620   | TIS620 Thai                     | tis620_thai_ci      |      1 |
| euckr    | EUC-KR Korean                   | euckr_korean_ci     |      2 |
| koi8u    | KOI8-U Ukrainian                | koi8u_general_ci    |      1 |
| gb2312   | GB2312 Simplified Chinese       | gb2312_chinese_ci   |      2 |
| greek    | ISO 8859-7 Greek                | greek_general_ci    |      1 |
| cp1250   | Windows Central European        | cp1250_general_ci   |      1 |
| gbk      | GBK Simplified Chinese          | gbk_chinese_ci      |      2 |
| latin5   | ISO 8859-9 Turkish              | latin5_turkish_ci   |      1 |
| armscii8 | ARMSCII-8 Armenian              | armscii8_general_ci |      1 |
| utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 |
| ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 |
| cp866    | DOS Russian                     | cp866_general_ci    |      1 |
| keybcs2  | DOS Kamenicky Czech-Slovak      | keybcs2_general_ci  |      1 |
| macce    | Mac Central European            | macce_general_ci    |      1 |
| macroman | Mac West European               | macroman_general_ci |      1 |
| cp852    | DOS Central European            | cp852_general_ci    |      1 |
| latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 |
| utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 |
| cp1251   | Windows Cyrillic                | cp1251_general_ci   |      1 |
| utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 |
| utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 |
| cp1256   | Windows Arabic                  | cp1256_general_ci   |      1 |
| cp1257   | Windows Baltic                  | cp1257_general_ci   |      1 |
| utf32    | UTF-32 Unicode                  | utf32_general_ci    |      4 |
| binary   | Binary pseudo charset           | binary              |      1 |
| geostd8  | GEOSTD8 Georgian                | geostd8_general_ci  |      1 |
| cp932    | SJIS for Windows Japanese       | cp932_japanese_ci   |      2 |
| eucjpms  | UJIS for Windows Japanese       | eucjpms_japanese_ci |      3 |
| gb18030  | China National Standard GB18030 | gb18030_chinese_ci  |      4 |
+----------+---------------------------------+---------------------+--------+
41 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出的第一列是字符集名称，第二列是字符集的描述，第三列是字符集默认的排序规则，第四列表示一个字符集的一个字符最大的字节数。这在里着重介绍下字符集的排序规则。首先在MySQL的官网文档中，排序规则(collations，下文都称之为collation)的定义是：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;A character set is a set of symbols and encodings. A collation is a set of rules for comparing characters in a character set. Let's make the distinction clear with an example of an imaginary character set.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译过来就是collation就是一套规则，用来比较字符集中的字符。那么怎么理解这个比较字符集中的字符呢？文档给出了一个例子，例如有一个简单的字符集包括了如下的几个字符：a b A B。为了能够比较每个字符，我们给每个字符都附上一个编码，比如a=0，b=1，A=2，B=3。那么在排序比如order by 或者比较 两个字符是否相等的时候，自然可以使用这个编码来进行，例如order by 的时候就应该是 a&amp;lt;b&amp;lt;A&amp;lt;B ，而比较大小的时候是a&amp;lt;A 。这个规则就算做是一个collation，也是最简单的规则。但是如果今天不需要大小写敏感，那么a就是等于A ，所以这个规则就需要做下改变，例如a 和 A 的编码都变成0 ，然后order by的时候a和A不分先后，这样子的规则可以称之为大小不敏感。再比如世界上有些语言例如德语，会有口音敏感或者不敏感之分(MySQL文档上给出的原文是accent-sensitive ，我是直译过来的，如果有更好的翻译请大家告诉我)，那么会可能存在Ö&lt;code&gt;=&lt;/code&gt;OE这样子的情况，因此会有collation是口音敏感或者不敏感&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-general.html&quot;&gt;[5]&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;39&quot;&gt;
&lt;p&gt;Suppose that we have an alphabet with four letters: &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;. We give each letter a number: &lt;code&gt;A&lt;/code&gt; = 0, &lt;code&gt;B&lt;/code&gt; = 1, &lt;code&gt;a&lt;/code&gt; = 2, &lt;code&gt;b&lt;/code&gt; = 3. The letter &lt;code&gt;A&lt;/code&gt; is a symbol, the number 0 is the &lt;em&gt;encoding&lt;/em&gt; for &lt;code&gt;A&lt;/code&gt;, and the combination of all four letters and their encodings is a &lt;em&gt;character set&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Suppose that we want to compare two string values, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;. The simplest way to do this is to look at the encodings: 0 for &lt;code&gt;A&lt;/code&gt; and 1 for &lt;code&gt;B&lt;/code&gt;. Because 0 is less than 1, we say &lt;code&gt;A&lt;/code&gt; is less than &lt;code&gt;B&lt;/code&gt;. What we've just done is apply a collation to our character set. The collation is a set of rules (only one rule in this case): “compare the encodings.” We call this simplest of all possible collations a binary collation.&lt;/p&gt;
&lt;p&gt;But what if we want to say that the lowercase and uppercase letters are equivalent? Then we would have at least two rules: (1) treat the lowercase letters &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; as equivalent to &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt;; (2) then compare the encodings. We call this a case-insensitive collation. It is a little more complex than a binary collation.&lt;/p&gt;
&lt;p&gt;In real life, most character sets have many characters: not just &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; but whole alphabets, sometimes multiple alphabets or eastern writing systems with thousands of characters, along with many special symbols and punctuation marks. Also in real life, most collations have many rules, not just for whether to distinguish lettercase, but also for whether to distinguish accents (an “accent” is a mark attached to a character as in German &lt;code&gt;Ö&lt;/code&gt;), and for multiple-character mappings (such as the rule that &lt;code&gt;Ö&lt;/code&gt; = &lt;code&gt;OE&lt;/code&gt; in one of the two German collations).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这么看来collation其实就是定义了字符集中的字符需要怎么被比较以及如何排序的问题。那么在MySQL中有多少中collation呢?通过 SHOW COLLATION 命令可以看到(全部内容就不贴出来了，请大家自行执行命令)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;+--------------------------+----------+-----+---------+----------+---------+
| Collation                | Charset  | Id  | Default | Compiled | Sortlen |
+--------------------------+----------+-----+---------+----------+---------+
| big5_chinese_ci          | big5     |   1 | Yes     | Yes      |       1 |
| big5_bin                 | big5     |  84 |         | Yes      |       1 |
| dec8_swedish_ci          | dec8     |   3 | Yes     | Yes      |       1 |
| dec8_bin                 | dec8     |  69 |         | Yes      |       1 |
| cp850_general_ci         | cp850    |   4 | Yes     | Yes      |       1 |
| cp850_bin                | cp850    |  80 |         | Yes      |       1 |
... ...
| geostd8_general_ci       | geostd8  |  92 | Yes     | Yes      |       1 |
| geostd8_bin              | geostd8  |  93 |         | Yes      |       1 |
| cp932_japanese_ci        | cp932    |  95 | Yes     | Yes      |       1 |
| cp932_bin                | cp932    |  96 |         | Yes      |       1 |
| eucjpms_japanese_ci      | eucjpms  |  97 | Yes     | Yes      |       1 |
| eucjpms_bin              | eucjpms  |  98 |         | Yes      |       1 |
| gb18030_chinese_ci       | gb18030  | 248 | Yes     | Yes      |       2 |
| gb18030_bin              | gb18030  | 249 |         | Yes      |       1 |
| gb18030_unicode_520_ci   | gb18030  | 250 |         | Yes      |       8 |
+--------------------------+----------+-----+---------+----------+---------+
222 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这些collation都有一种统一的格式：字符集+语言名称+后缀。前面两个部分好理解，来看下最后一个部分所代表的含义：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_ai&lt;/td&gt;
&lt;td&gt;Accent-insensitive 口音不敏感&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_as&lt;/td&gt;
&lt;td&gt;Accent-sensitive 口音敏感&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_ci&lt;/td&gt;
&lt;td&gt;Case-insensitive 大小写不敏感&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_cs&lt;/td&gt;
&lt;td&gt;Case-sensitive 大小写敏感&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;_bin&lt;/td&gt;
&lt;td&gt;Binary 二进制排序&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在这里MySQL给出了一些解释：对于是ci后缀的collation(大小写不敏感)也意味着Accent-insensitive(口音不敏感)。同理对于是cs后缀的collation(大小写敏感)也意味着Accent-sensitive(口音敏感)&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-collation-names.html&quot;&gt;[6]&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;For nonbinary collation names that do not specify accent sensitivity, it is determined by case sensitivity. If a collation name does not contain &lt;code&gt;_ai&lt;/code&gt; or &lt;code&gt;_as&lt;/code&gt;, &lt;code&gt;_ci&lt;/code&gt; in the name implies &lt;code&gt;_ai&lt;/code&gt; and &lt;code&gt;_cs&lt;/code&gt; in the name implies &lt;code&gt;_as&lt;/code&gt;. For example, &lt;code&gt;latin1_general_ci&lt;/code&gt; is explicitly case-insensitive and implicitly accent-insensitive, and &lt;code&gt;latin1_general_cs&lt;/code&gt; is explicitly case-sensitive and implicitly accent-sensitive.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里举一个实际的例子说明下这个collation的cs和ci后缀的作用(一般在工作中经常遇到的是这两个collation)。假设当前有这么一张表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; show create table test_collation \G
*************************** 1. row ***************************
       Table: test_collation
Create Table: CREATE TABLE `test_collation` (
  `c` varchar(255) CHARACTER SET latin1 COLLATE latin1_general_cs DEFAULT NULL,
  `c1` varchar(255) CHARACTER SET latin1 COLLATE latin1_general_ci DEFAULT NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的数据是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; select * from test_collation ;
+------+------+
| c    | c1   |
+------+------+
| a    | A    |
| b    | B    |
| B    | b    |
+------+------+
3 rows in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么我们分别执行如下的几个SQL：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;1. select * from test_collation where c = 'b';
2. select * from test_collation where c1 = 'b';
3. select c from test_collation group by c;
4. select c1 from test_collation group by c1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别得到如下的几个结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;1. select * from test_collation where c = 'b';
+------+------+
| c    | c1   |
+------+------+
| b    | B    |
+------+------+
1 row in set (0.00 sec)

2. select * from test_collation where c1 = 'b';
+------+------+
| c    | c1   |
+------+------+
| b    | B    |
| B    | b    |
+------+------+
2 rows in set (0.00 sec)

3. select c from test_collation group by c;
+------+
| c    |
+------+
| a    |
| B    |
| b    |
+------+
3 rows in set (0.00 sec)

4. select c1 from test_collation group by c1;
+------+
| c1   |
+------+
| A    |
| B    |
+------+
2 rows in set (0.00 sec)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;c 是大小写敏感的列，cs 是大小写不敏感的列。通过实验结果可以可以得到如下几个结论：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;大小写敏感的情况下，b和B(大小和小写是不等的)。&lt;/li&gt;
&lt;li&gt;大小写不敏感的话，查询b会得到B和b的结果(相信很多DBA在工作中也遇到个这个问题，明明应该一条记录，怎么就查出了两条)。&lt;/li&gt;
&lt;li&gt;对于group by，cs会区分b和B，ci则会把两个字符当做一个，这点从上面1-2可以推测出。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ps 关于collation的问题，还可以参考这篇文章:&lt;/p&gt;
&lt;p&gt;[1].&lt;a href=&quot;https://jibai31.wordpress.com/2017/05/04/how-to-choose-your-mysql-encoding-and-collation/&quot;&gt;How to choose your MySQL encoding and collation&lt;/a&gt;。&lt;/p&gt;
&lt;h4 id=&quot;222-collation-bin和binary-strings的不同&quot;&gt;2.2.2 collation bin和Binary strings的不同&lt;/h4&gt;
&lt;p&gt;在前文的介绍中，我们忽略了一种类型的collation: _bin。这种排序规则是按照字符串的二进制值进行排序和比较&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-binary-collations.html&quot;&gt;[7]&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;For the &lt;code&gt;binary&lt;/code&gt; collation of the &lt;code&gt;binary&lt;/code&gt; character set, comparisons are based on numeric byte values. For the &lt;code&gt;_bin&lt;/code&gt; collation of a nonbinary character set, comparisons are based on numeric character code values, which differ from byte values for multibyte characters. For information about the differences between the &lt;code&gt;binary&lt;/code&gt; collation of the &lt;code&gt;binary&lt;/code&gt; character set and the &lt;code&gt;_bin&lt;/code&gt; collations of nonbinary character&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可能会想起在MySQL中有另外的一种数据类型叫做Binary strings (as stored using the &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html&quot;&gt;&lt;code&gt;BINARY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/binary-varbinary.html&quot;&gt;&lt;code&gt;VARBINARY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/blob.html&quot;&gt;&lt;code&gt;BLOB&lt;/code&gt;&lt;/a&gt; data types)，那么这个Binary strings 和 collation 中的_bin 又有什么区别呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从用于排序比较的数据单元(The Unit for Comparison and Sorting)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Binary strings是一连串字节序，比较和排序是基于字节值的。而collation 中的_bin对应的字符串一般而言是多字节的(每个字符由N个字节组成，因此是多个字节)，排序和比较的规则是基于每个字符的字节值。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;字符集的转换(Character Set Conversion)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于具有_bin 后缀的collation的字符集，可以在多种情况下自动转换成其他的字符集。对于Binary strings而言，只能 copied byte-wise按照字节的值一个个复制。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;大小写转换(Lettercase Conversion)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于具有_bin 后缀的collation的字符集可以进行字符的大小写转换，而Binary strings会直接忽略这个事情，除非先把它转成某一个字符集。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; SET NAMES utf8mb4 COLLATE utf8mb4_bin;
mysql&amp;gt; SELECT LOWER('aA'), UPPER('zZ');
+-------------+-------------+
| LOWER('aA') | UPPER('zZ') |
+-------------+-------------+
| aa          | ZZ          |
+-------------+-------------+
mysql&amp;gt; SET NAMES binary;
mysql&amp;gt; SELECT LOWER('aA'), LOWER(CONVERT('aA' USING utf8mb4));
+-------------+------------------------------------+
| LOWER('aA') | LOWER(CONVERT('aA' USING utf8mb4)) |
+-------------+------------------------------------+
| aA          | aa                                 |
+-------------+------------------------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;对于字符串最后的空格的处理(Trailing Space Handling in Comparisons)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对于具有_bin 后缀的collation的字符集，字符串最后的一个空格，在比较字符串是否相等的时候不会被计入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; SET NAMES utf8 COLLATE utf8_bin;
Query OK, 0 rows affected (0.00 sec)
mysql&amp;gt;  SELECT 'a a ' = 'a a';
+----------------+
| 'a a ' = 'a a' |
+----------------+
|              1 |
+----------------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而对于Binary strings空格会被计入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; SET NAMES binary;
mysql&amp;gt; SELECT 'a ' = 'a';
+------------+
| 'a ' = 'a' |
+------------+
|          0 |
+------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而在插入数据的时候，_bin 后缀的collation的字符集会忽略空格，但是Binary strings不会：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; CREATE TABLE t1 (
         a CHAR(10) CHARACTER SET utf8 COLLATE utf8_bin,
         b BINARY(10)
       );
mysql&amp;gt; INSERT INTO t1 VALUES ('x','x');
mysql&amp;gt; INSERT INTO t1 VALUES ('x ','x ');
mysql&amp;gt; SELECT a, b, HEX(a), HEX(b) FROM t1;
+------+------------+--------+----------------------+
| a    | b          | HEX(a) | HEX(b)               |
+------+------------+--------+----------------------+
| x    | x          | 78     | 78000000000000000000 |
| x    | x          | 78     | 78200000000000000000 |
+------+------------+--------+----------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-字符集配置以及转换规则&quot;&gt;2.3 字符集配置以及转换规则&lt;/h3&gt;
&lt;p&gt;前文我们介绍了字符集与字符集排序规则，本节开始介绍下MySQL中字符集配置相关的内容。在MySQL中字符集设置相当灵活和复杂，使用命令可以看到相关的几个配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;+--------------------------+------------------------------------------+
| Variable_name            | Value                                    |
+--------------------------+------------------------------------------+
| character_set_client     | utf8                                     |
| character_set_connection | utf8                                     |
| character_set_database   | latin1                                   |
| character_set_filesystem | binary                                   |
| character_set_results    | utf8                                     |
| character_set_server     | latin1                                   |
| character_set_system     | utf8                                     |
| character_sets_dir       | /home/mysql/mysql-5.7.18/share/charsets/ |
+--------------------------+------------------------------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来介绍下每个配置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;character_set_client : 客户端发送SQL语句给MySQL所使用的编码。这个值随每个客户端设置的不同而变化。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;11.40031152648&quot;&gt;
&lt;p&gt;The character set for statements that arrive from the client. The session value of this variable is set using the character set requested by the client when the client connects to the server. (Many clients support a &lt;code&gt;--default-character-set&lt;/code&gt; option to enable this character set to be specified explicitly. See also &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-connection.html&quot;&gt;Section 10.4, “Connection Character Sets and Collations”&lt;/a&gt;.) The global value of the variable is used to set the session value in cases when the client-requested value is unknown or not available, or the server is configured to ignore client requests:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The client requests a character set not known to the server. For example, a Japanese-enabled client requests &lt;code&gt;sjis&lt;/code&gt; when connecting to a server not configured with &lt;code&gt;sjis&lt;/code&gt; support.&lt;/li&gt;
&lt;li&gt;The client is from a version of MySQL older than MySQL 4.1, and thus does not request a character set.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/mysqld.html&quot;&gt;&lt;strong&gt;mysqld&lt;/strong&gt;&lt;/a&gt; was started with the &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/server-options.html#option_mysqld_character-set-client-handshake&quot;&gt;&lt;code&gt;--skip-character-set-client-handshake&lt;/code&gt;&lt;/a&gt; option, which causes it to ignore client character set configuration. This reproduces MySQL 4.0 behavior and is useful should you wish to upgrade the server without upgrading all the clients.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Some character sets cannot be used as the client character set. Attempting to use them as the &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_character_set_client&quot;&gt;&lt;code&gt;character_set_client&lt;/code&gt;&lt;/a&gt; value produces an error. See &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-connection.html#charset-connection-impermissible-client-charset&quot;&gt;Impermissible Client Character Sets&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;character_set_connection : MySQL连接字符集。其实一开始接触到这个配置的时候，我也是一脸懵逼为什么要有一个这样子的配置。客户端已经有字符集配置了，为什么还要在进入内部字符集之前设置一个这样子的字符集进行转换。后面我查了下发现不单单是我，国内外很多人都有这个疑问，比如这个贴子下[&lt;a href=&quot;https://stackoverflow.com/questions/16082480/what-is-the-purpose-of-character-set-connection&quot;&gt;What is the purpose of character_set_connection?&lt;/a&gt;] 就对这个问题进行了讨论。后续我也仔细阅读了MySQL的问题，根据我自己的理解之所以设置这个参数，应该是针对于这种情况的：&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;13.270072992701&quot;&gt;
&lt;p&gt;假设MySQL当前没有character_set_connection这个参数，SQL语句在server端通过character_set_client参数解码之后变进入内部字符集进行比较，那么例如这样子的SQL中的字符串(&quot;ABC&quot;)的编码也会是character_set_client的编码值：select * from order where orderid =&quot;ABC&quot;。那么如果开发者想让&quot;ABC&quot;拥有其他编码怎么办，MySQL提供了一个叫做Character Set Introducers的&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-introducer.html&quot;&gt;[8]&lt;/a&gt;方法，可以这么指定 select * from order where orderid = _utf8 &quot;ABC&quot;。后面发现每个语句都写一个Character Set Introducers来指定编码太累了，于是提供了character_set_connection参数，对于没有Character Set Introducers的字符串，都编码成character_set_connection所指定的编码。&lt;/p&gt;
&lt;p&gt;The character set used for literals specified without a character set introducer and for number-to-string conversion. For information about introducers, see &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-introducer.html&quot;&gt;Section 10.3.8, “Character Set Introducers”&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ ps 关于character_set_connection参数的其他讨论，可以参见如下的几篇文章：&lt;/p&gt;
&lt;p&gt;​ [1].&lt;a href=&quot;https://www.cnblogs.com/lazyno/p/4278544.html&quot;&gt;mysql中character_set_connection的作用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ [2].&lt;a href=&quot;https://mingshan.fun/2020/01/07/mysql-charset/&quot;&gt;理解MySQL字符集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ [3].&lt;a href=&quot;https://stackoverflow.com/questions/16082480/what-is-the-purpose-of-character-set-connection&quot;&gt;What is the purpose of character_set_connection?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;​ [4].&lt;a href=&quot;https://mp.weixin.qq.com/s/58Y11c8cLN1uDfHn_6lyAg&quot;&gt;彻底解决MySQL中的乱码问题&lt;/a&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;character_set_database : 这个好理解，就是数据库的字符集。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The character set used by the default database. The server sets this variable whenever the default database changes. If there is no default database, the variable has the same value as character_set_server.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;character_set_filesystem : 文件系统字符集。 该变量用于解释引用文件名的字符串文字，例如在LOAD DATA INFILE和SELECT ... INTO OUTFILE语句和LOAD_FILE（）函数中。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;10.586956521739&quot;&gt;
&lt;p&gt;The file system character set. This variable is used to interpret string literals that refer to file names, such as in the &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/load-data.html&quot;&gt;&lt;code&gt;LOAD DATA&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/select-into.html&quot;&gt;&lt;code&gt;SELECT ... INTO OUTFILE&lt;/code&gt;&lt;/a&gt; statements and the &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_load-file&quot;&gt;&lt;code&gt;LOAD_FILE()&lt;/code&gt;&lt;/a&gt; function. Such file names are converted from &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_character_set_client&quot;&gt;&lt;code&gt;character_set_client&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_character_set_filesystem&quot;&gt;&lt;code&gt;character_set_filesystem&lt;/code&gt;&lt;/a&gt; before the file opening attempt occurs. The default value is &lt;code&gt;binary&lt;/code&gt;, which means that no conversion occurs. For systems on which multibyte file names are permitted, a different value may be more appropriate. For example, if the system represents file names using UTF-8, set &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_character_set_filesystem&quot;&gt;&lt;code&gt;character_set_filesystem&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;'utf8mb4'&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;character_set_results : SQL语句执行的结果集字符集。当查询执行完毕之后，返回给客户端的结果使用这个字符集编码。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The character set used for returning query results to the client. This includes result data such as column values, result metadata such as column names, and error messages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;character_set_server : 整个服务器基本的字符集配置。如果创建数据库的时候不指定字符集就使用这个配置。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5.427135678392&quot;&gt;
&lt;p&gt;The servers default character set. See &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-configuration.html&quot;&gt;Section 10.15, “Character Set Configuration”&lt;/a&gt;. If you set this variable, you should also set &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_collation_server&quot;&gt;&lt;code&gt;collation_server&lt;/code&gt;&lt;/a&gt; to specify the collation for the character set.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;character_set_system : 系统元数据字符集，系统元数据(表名、字段名等)存储时使用的编码字符集，该字段和具体存储的数据无关。总是固定不变的UTF8字符集。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;The character set used by the server for storing identifiers. The value is always &lt;code&gt;utf8&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面介绍了很多的关于字符集的配置，这些字符集配置之间也有一定的转换关系&lt;a href=&quot;https://www.cnblogs.com/kerrycode/p/11170266.html&quot;&gt;[9]&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/api/personal/file/WEB43d53aee902a4d57181b811c779a4b15?method=download&amp;amp;shareKey=36d65eccdb69ef1f94f3bb56c1fba565&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于Client发起的SQL，会使用 character_set_client进行编码。当SQL到了MySQL Server的时候，会使用character_set_client进行解码。之后如果character_set_client的编码与character_set_connection编码不一致的时候，会将请求的数据转换成character_set_connection的编码。在进行内部操作前会判断内部编码是否与character_set_connection一致，如果不一致则将character_set_connection的编码进行转换：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用每个数据字段的CHARACTER SET设定值；&lt;/li&gt;
&lt;li&gt;若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)；&lt;/li&gt;
&lt;li&gt;若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值；&lt;/li&gt;
&lt;li&gt;若上述值不存在，则使用character_set_server设定值。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3-mysql字符集的一些问题&quot;&gt;3. MySQL字符集的一些问题&lt;/h2&gt;
&lt;h3 id=&quot;31-字符集配置对于innodb引擎存储数据所带来的一点影响&quot;&gt;3.1 字符集配置对于Innodb引擎存储数据所带来的一点影响&lt;/h3&gt;
&lt;p&gt;MySQL对于一条记录的长度是有限制而且这个限制分为两层，在server层一条记录最大不能超过65535个字节；在Innodb引擎层因为记录都必须按照B树的格式组织，因此如果在一个page是16KB的配置下，最大的记录长度不能大于16KB/2=8K(如果一个page里面就只有一条记录，那么B树就退化成链表也就失去了B树的意义)。此外还要扣除page中的一些元数据的长度，最后实际一个记录的最大长度会小于8K(实际应该是8126 B)。如果一个记录的行大于8K怎么办，比如有一个字段用于存储文章的内容定义为varchar(3000)，然后是utf8mb4字符集(utf8mb4 是4个字节的，然后3000个字符最大就是12000个字节大约12K)。对于这种大字段Innodb会将其存储在溢出页(page overflow)中。不同的行格式对于溢出页的实现还有一定的区别：&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;compact 格式: 如果字段长度小于768 Bytes则不会发生page overflow。而如果超过了768 Bytes，那么前768 Bytes 依然在数据页中，剩余的部分放在溢出页(off-page)中。同时当前页中增加一个 20 个字节的指针（即 SPACEID + PAGEID + OFFSET）和本地长度信息（2 个字节），共计 768 + 20 + 2 = 790 个字节存储在当前记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;compressed或dynamic格式: 这种格式下数据库会尽可能的存放数据在数据页中，只有当一个页没法存放2条数据的时候，会将最长的一列的所有数据放入溢出页，同时在原来的记录上保留20个字节的指针，而对text的数据类型会存放前40byte 在 数据页中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根据上面的分析可以看出，字符集的设置对于表能够定义的列和记录的最大长度都有影响。例如文献&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html&quot;&gt;[12]&lt;/a&gt;给出的一个例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),
       c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),
       f VARCHAR(10000), g VARCHAR(6000)) ENGINE=InnoDB CHARACTER SET latin1;
ERROR 1118 (42000): Row size too large. The maximum row size for the used 
table type, not counting BLOBs, is 65535. This includes storage overhead, 
check the manual. You have to change some columns to TEXT or BLOBs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了的66000个字符并且是latin1的字符集，因此超过了65535个字节的限制。如果把这个表的字段减少一个就可以创建成功:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),        c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),        f VARCHAR(10000)) ENGINE=InnoDB CHARACTER SET latin1;
Query OK, 0 rows affected (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么换一个字符集比如utf8，那么创建就会失败：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; CREATE TABLE t (a VARCHAR(10000), b VARCHAR(10000),        c VARCHAR(10000), d VARCHAR(10000), e VARCHAR(10000),        f VARCHAR(10000)) ENGINE=InnoDB CHARACTER SET utf8;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
mysql&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面演示的例子都是server层面的限制，接下来看看引擎层面的限制:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; create table t (a varchar(1000),a1 varchar(1000),a2 varchar(1000),a3 varchar(1000),a4 varchar(1000),a5 varchar(1000),a6 varchar(1000),a7 varchar(1000),a8 varchar(1000),a9 varchar(1000),a10 varchar(1000),a11 varchar(1000),a12 varchar(1000)) ENGINE=InnoDB   ROW_FORMAT=COMPACT CHARACTER SET latin1;
Query OK, 0 rows affected (0.01 sec)

mysql&amp;gt; insert into t select repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000),repeat(&quot;a&quot;,1000);
ERROR 1118 (42000): Row size too large (&amp;gt; 8126). Changing some columns to TEXT or BLOB or using ROW_FORMAT=DYNAMIC or ROW_FORMAT=COMPRESSED may help. In current row format, BLOB prefix of 768 bytes is stored inline.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子中，建表的语句中构建了12个1000个字符的列，因为12*1000&amp;lt;65533所以在server层检查通过。但是因为定义的行格式是COMPACT，当列的数据超过768字节的时候会将前768字节放在数据页中，剩余的数据才放入溢出页中，所以整个插入的数据行是大于8126K的，在引擎层就被拒绝了。&lt;/p&gt;
&lt;p&gt;ps 关于MySQL记录长度限制的讨论可以参见如下的几篇文字:&lt;/p&gt;
&lt;p&gt;[1].&lt;a href=&quot;https://cloud.tencent.com/developer/article/1375498&quot;&gt;【MySQL经典案例分析】关于数据行溢出由浅至深的探讨&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]. &lt;a href=&quot;https://opensource.actionsky.com/20200226-mysql/&quot;&gt;技术分析 | MySQL TEXT 字段的限制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]. &lt;a href=&quot;https://opensource.actionsky.com/20200227-mysql/&quot;&gt;技术分享 | MySQL 字段长度限制的计算方法&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-mysql中的utf8和latin1&quot;&gt;3.2 MySQL中的UTF8和Latin1&lt;/h3&gt;
&lt;p&gt;为了能够支持中文以及一些其他的非英文文字，开发者经常使用utf8字符集。但是在MySQL中的utf8字符集存在一个问题，它最大的长度是三字节最大能编码的 Unicode 字符是 0xffff，仅仅只能支持Unicode 中的基本多文种平面（BMP）&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84&quot;&gt;[11]&lt;/a&gt;。如果字符不在BMP里面，则会被截断并且造成乱码。例如当前有下面这样一张表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE `test_user` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name` char(3) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;字符集设定的是utf8，然后插入字符&quot;𡋾&quot;(编码是F0A18BBE)，则最后会发现warning 以及数据乱码:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;set names utf8;
mysql&amp;gt; INSERT INTO test_user(name) VALUES(&quot;𡋾&quot;);
Query OK, 1 row affected, 1 warning (0.00 sec)
mysql&amp;gt; select *  from test_user ;
+----+------+
| id | name |
+----+------+
|  1 | �  |
+----+------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此如果使用UTF8字符集存一些比较特殊的字符就会出现乱码。至于MySQL为啥会有这个bug，可以参见如下这两篇文章:&lt;/p&gt;
&lt;p&gt;[1].&lt;a href=&quot;https://blog.liexing.me/2018/07/27/mysql-utf8/&quot;&gt;MySQL utf8之坑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2].&lt;a href=&quot;https://mp.weixin.qq.com/s/rQruQLkOrqjTGFbIkuo7-g&quot;&gt;记住：永远不要在MySQL中使用UTF-8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么要存一些特殊的字符并且不能出现乱码的问题怎么办？MySQL后面推出了utf8mb4字符集解决这个问题。因此如果需要支持全部的Unicode编码，建议使用utf8mb4字符集。关于utf8mb4的介绍可以参见如下的两篇文字：&lt;/p&gt;
&lt;p&gt;[1].&lt;a href=&quot;https://my.oschina.net/xsh1208/blog/1052781&quot;&gt;全面了解mysql中utf8和utf8mb4的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2].&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-unicode-utf8mb4.html&quot;&gt;10.9.1 The utf8mb4 Character Set (4-Byte UTF-8 Unicode Encoding)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说完UTF8字符集，再来谈谈Latin1字符集的问题。以前经常遇到这样一个问题: Latin1字符集是否支持中文? 为了说明这个问题，本文来做如下的测试:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设置终端字符集为utf8。&lt;/li&gt;
&lt;li&gt;mysql的所有字符集配置都改成latin1。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; set names latin1;
Query OK, 0 rows affected (0.00 sec)
mysql&amp;gt; show variables like '%char%';
+--------------------------+------------------------------------------+
| Variable_name            | Value                                    |
+--------------------------+------------------------------------------+
| character_set_client     | latin1                                   |
| character_set_connection | latin1                                   |
| character_set_database   | latin1                                   |
| character_set_filesystem | binary                                   |
| character_set_results    | latin1                                   |
| character_set_server     | latin1                                   |
| character_set_system     | utf8                                     |
| character_sets_dir       | /home/mysql/mysql-5.7.20/share/charsets/ |
+--------------------------+------------------------------------------+
8 rows in set (0.01 sec)

&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;然后创建一个latin字符集的表，并插入数据:&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; show create table test_user \G
*************************** 1. row ***************************
       Table: test_user
Create Table: CREATE TABLE `test_user` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name` char(3) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
mysql&amp;gt; insert into test_user select &quot;1&quot;,&quot;一&quot;;
Query OK, 1 row affected (0.00 sec)
mysql&amp;gt; select * from test_user;
+----+------+
| id | name |
+----+------+
|  1 | 一  |
+----+------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以见得，在MySQL表和字段里面的字符集是Latin1，通过终端插入中文正常插入并且正常显示了没有乱码。那么什么情况下会有乱码出现？比如将name这个列改成2个字符长度:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;mysql&amp;gt; show create table test_user \G
*************************** 1. row ***************************
       Table: test_user
Create Table: CREATE TABLE `test_user` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `name` char(2) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=latin1
1 row in set (0.00 sec)
mysql&amp;gt; insert into test_user select &quot;1&quot;,&quot;一&quot;;
Query OK, 1 row affected (0.00 sec)
mysql&amp;gt; select * from test_user;
+----+------+
| id | name |
+----+------+
|  1 | �   |
+----+------+
1 row in set (0.00 sec)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到了这里我们应该可以得出结论了。其实对于Latin1字符集而言它存的数据是单个字节，对于UTF8这种多个字节组成的字符集，Latin1编码的列会将每个字节都存入。因此在插入数据和读取数据的时候，其实都是把Latin1编码中的每个字节读出来，之后在终端会被转换成UTF8编码显示。所以显示的数据也是正确的没有乱码。那么什么情况下有乱码，答案就是当列的长度不够包含多个字节的时候。比如本文前面的例子，name列的长度变成了2个字符(此时编码是latin1 ，那么2个字符就是2个字节的长度)，而终端编码是UTF8，插入的数据自然是3个字节的，因此到了数据库层面就会被截断，因此也产生了乱码。所以要说 Latin1支持中文这个说法，其实也对也不对，要根据当前系统的配置才能最后确认Latin1编码下是否支持中文。&lt;/p&gt;
&lt;p&gt;ps 关于这个问题的更多讨论可以参见如下的文章:&lt;/p&gt;
&lt;p&gt;[1]. &lt;a href=&quot;https://www.cnblogs.com/lazycat-cz/p/4213570.html&quot;&gt;mysql中文乱码的一点理解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;此外在此文形成的过程中，还发现了对于字符集利用进行SQL注入的一些讨论，本文没有去做测试，仅仅将查阅到的资料放在这里感兴趣的读者可以自行查阅:&lt;/p&gt;
&lt;p&gt;[1].&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html&quot;&gt;Mysql字符编码利用技巧&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2].&lt;a href=&quot;https://www.freebuf.com/column/165567.html&quot;&gt;/&lt;em&gt;Team:红日安全团队团队成员：CPRTitle：宽字节注入&lt;/em&gt;/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-collation和字符集对于执行计划的影响&quot;&gt;3.3 collation和字符集对于执行计划的影响&lt;/h3&gt;
&lt;p&gt;最后回到本文开头的时候提到的慢查询问题。在这个例子中explain 输出了提示信息为Range checked for each record (index map: 0x1)。并且通过show warnings命令会提示如下的信息:&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;| Warning | 1739 | Cannot use ref access on index 'productid' due to type or collation conversion on field 'productid' |&lt;br/&gt;| Note | 1003 | /* select#1 */ select &lt;code&gt;djx&lt;/code&gt;.&lt;code&gt;Order1&lt;/code&gt;.&lt;code&gt;productid&lt;/code&gt; AS &lt;code&gt;productid&lt;/code&gt;,&lt;code&gt;djx&lt;/code&gt;.&lt;code&gt;Order1&lt;/code&gt;.&lt;code&gt;orderid&lt;/code&gt; AS &lt;code&gt;orderid&lt;/code&gt;,&lt;code&gt;djx&lt;/code&gt;.&lt;code&gt;Product&lt;/code&gt;.&lt;code&gt;name&lt;/code&gt; AS &lt;code&gt;name&lt;/code&gt; from &lt;code&gt;djx&lt;/code&gt;.&lt;code&gt;Order1&lt;/code&gt; left join &lt;code&gt;djx&lt;/code&gt;.&lt;code&gt;Product&lt;/code&gt; on((&lt;code&gt;djx&lt;/code&gt;.&lt;code&gt;Order1&lt;/code&gt;.&lt;code&gt;productid&lt;/code&gt; = &lt;code&gt;djx&lt;/code&gt;.&lt;code&gt;Product&lt;/code&gt;.&lt;code&gt;productid&lt;/code&gt;)) where 1 |&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以见得执行优化器认为Order1表的索引productid 和 Product表的索引productid因为类型或者collation不一致，所以无法通过索引进行join。此外通过MySQL开发团队的博客了解到在Range checked for each record的提示信息下，SQL的执行有如下的2种办法&lt;a href=&quot;https://mysqlserverteam.com/dynamic-range-access-and-recent-changes/&quot;&gt;[12]&lt;/a&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Read all rows in the table through a table scan : 对于驱动表的每一行记录进行全表扫描&lt;/li&gt;
&lt;li&gt;read all rows which were sent using the &lt;a href=&quot;http://dev.mysql.com/doc/refman/5.7/en/explain-output.html&quot;&gt;dynamic range access method on index ‘0x2’&lt;/a&gt;.:对于驱动表的每一行记录，通过可能的索引在另外的一个表把所有数据扫出来&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此根据show warnings命令提示的信息和文献&lt;a href=&quot;https://mysqlserverteam.com/dynamic-range-access-and-recent-changes/&quot;&gt;[12]&lt;/a&gt;的信息，可以推断本文开头的那个慢查询SQL执行的过程是对于驱动表的每一行记录都去被驱动表里面全表扫描匹配一次，所以整个查询变得非常的慢。(ps : 不过这里我一直有一个疑问，两个表的productid的索引的字符集其实是一样的，不同的只是排序规则和比较的规则(是否大小写敏感)不一样。个人认为其实还是可以通过被驱动表的索引进行join的。至于为什么SQL优化器最后没有选择这么做，如果大家有答案希望告诉我下。)&lt;/p&gt;
&lt;p&gt;通过本文开头的问题可以看出collation 对于执行计划是有影响的，同样字符集也会对整个SQL的执行计划有影响。因为这个问题还挺常见的，在这里就不继续做相关的讨论和叙述，感兴趣的读者可以阅读如下的几篇文章：&lt;/p&gt;
&lt;p&gt;[1].&lt;a href=&quot;https://mp.weixin.qq.com/s/ns9eRxjXZfUPNSpfgGA7UA&quot;&gt;MySQL表字段字符集不同导致的索引失效问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2].&lt;a href=&quot;%5Bhttp://redmapleren.com/2019/04/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9B%B4%E6%94%B9%E5%AD%97%E7%AC%A6%E9%9B%86%E8%B8%A9%E7%9A%84%E5%9D%91/%5D(http://redmapleren.com/2019/04/19/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9B%B4%E6%94%B9%E5%AD%97%E7%AC%A6%E9%9B%86%E8%B8%A9%E7%9A%84%E5%9D%91/)&quot;&gt;记一次数据库更改字符集踩的坑&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;4-总结&quot;&gt;4. 总结&lt;/h2&gt;
&lt;p&gt;本文介绍了关于MySQL字符集和字符集排序规则的相关内容，同时对于字符集设置可能带来的一些影响做了讨论。限于本人水平有限，如有错误之处还望大家指正。&lt;/p&gt;
&lt;h2 id=&quot;5-参考文献&quot;&gt;5. 参考文献&lt;/h2&gt;
&lt;p&gt;[1].字符_(计算机科学).&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&quot;&gt;https://zh.wikipedia.org/wiki/字符_(计算机科学)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2].字符集.&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86/946585?fr=aladdin&quot;&gt;https://baike.baidu.com/item/字符集/946585?fr=aladdin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3].字符编码.&lt;a href=&quot;https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/8446880&quot;&gt;https://baike.baidu.com/item/字符编码/8446880&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[4].10.2 Character Sets and Collations in MySQL.&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-mysql.html&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/charset-mysql.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[5].10.1 Character Sets and Collations in General.&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-general.html&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/charset-general.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[6].10.3.1 Collation Naming Convention.,&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-collation-names.html&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/charset-collation-names.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[7].10.8.5 The binary Collation Compared to _bin Collations.&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-binary-collations.html&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/charset-binary-collations.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[8].10.3.8 Character Set Introducers .&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/charset-introducer.html&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/charset-introducer.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[9].字符集与排序规则概念.&lt;a href=&quot;https://www.cnblogs.com/kerrycode/p/11170266.html,2019-07-11&quot;&gt;https://www.cnblogs.com/kerrycode/p/11170266.html,2019-07-11&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[10].谈谈性能优化：Mysql 的字符集以及带来的一点存储影响.&lt;a href=&quot;https://zhuanlan.zhihu.com/p/110790115&quot;&gt;https://zhuanlan.zhihu.com/p/110790115&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[11].Unicode字符平面映射.&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84&quot;&gt;https://zh.wikipedia.org/wiki/Unicode字符平面映射&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;[12].Dynamic range access (and recent changes).&lt;a href=&quot;https://mysqlserverteam.com/dynamic-range-access-and-recent-changes/&quot;&gt;https://mysqlserverteam.com/dynamic-range-access-and-recent-changes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[13].8.4.7 Limits on Table Column Count and Row Size.&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/column-count-limit.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 00:24:00 +0000</pubDate>
<dc:creator>bush2582</dc:creator>
<og:description>从一个慢查询到MySQL字符集编码 [TOC] 1. 问题起源 最近在完成一个线上日志修复工作的过程中遇到了一个意想不到的慢查询。当时使用的SQL以及表结构其实都很简单，而且在关键的字段上也有索引，但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bush2582/p/12688451.html</dc:identifier>
</item>
<item>
<title>「给产品经理讲JVM」：垃圾收集算法 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/12689226.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/12689226.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;纠结的我，给我的JVM系列终于起了第三个名字，害，我真是太难了。从 JVM 到 每日五分钟，玩转 JVM 再到现在的给产品经理讲 JVM ，虽然内容为王，但是标题可以让更多的人看到我的文章，所以，历经了三个选题，最终定下来了这个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个名字的由来，且听我给你慢慢道来，从学习知识的角度上来说，最深入的方法就是把知识讲给别人听，那么为什么我要讲给程序员的天敌——产品经理呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题的答案很简单，因为我&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;老婆&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;就是一个&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;产品经理&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;哈哈哈哈哈哈哈（听说现在流行这样玩？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;认识的时候她是 Java 开发来着，谁知道领了证就变成了产品。。小 朋 友 你 是 否 有 很 多 ？？？（手动摊手&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-18-123921.jpg&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说了，下面开始进入我们的正文～&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;背景&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故事发生在一个明媚的午后，我刚看完《深入理解Java虚拟机》第三章的第三节——垃圾收集算法，我的产品大人开始了例行盘问&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：你天天学的什么啊，我看着好像很眼熟？？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：？？？你难道忘了你曾经是一个 Java 程序员，JVM 都忘了？&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-22-030352.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：JVM 啊，基本上忘的差不多了，要不你给我讲讲，省的我们&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;开发天天忽悠我&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，我就这么做了程序员的叛徒&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：行吧，那我就来给你讲一讲这一节中我的收获吧。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;接上集&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：在开始之前，我们先来回顾一下上次讲的东西，上次我们说到了如何判定一个对象是不是垃圾对象（已死），通常来说有两种算法——&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;引用计数法和可达性分析法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，目前市面上的虚拟机大多数采用的是第二种——可达性分析法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么这两种方法是不是对应了两个类型的垃圾收集算法呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：真聪明，果然&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;不是一家人，不进一家门&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，这两种分别对应了Reference Counting GC（引用计数垃圾收集）和 Tracing GC（追踪垃圾收集），而我们今天讲的垃圾收集算法都属于追踪垃圾收集的范畴。不过在介绍垃圾收集算法之前，我首先需要向你介绍一个很关键的理论——分代收集理论。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：好嘞&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;分代收集理论&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：所谓分代收集理论从某种意义上来说，是一种约定俗称的规范和经验的总结，并不是一个非常严格的规则。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：嗯嗯，约定大于配置，现在这样的思想在很多地方都有体现，那么到底什么是分代收集呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：且听我慢慢道来，分代收集建立在三个假说之上：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;绝大多数对象都是朝生夕死的。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;熬过越多次的GC的对象越难以消亡。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;跨代饮用相对于同代引用仅占极少一部分。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：这三个我好像在哪见过，但是记不太清楚了，能不能说的更详细一点&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：由于绝大多数对象都是朝生夕死的，而熬过越多次GC的对象越难消灭掉，这样自然而然的就会把对象分成两个派别，一种是极易发生GC的，一种是极难发生GC的，极易发生GC的生命周期较短，所以也被称之为&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;新生代&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，极难发生GC的对象生命周期较长，所以也可以叫他们&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;老年代&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：这么一说，我好像有点明白了，但是为什么要分代呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：如果我们把他们进行分代后，可以对区域进行划分，一部分用于存储新生代，新生代的对象我们只需要去关注那些不被回收的对象就可以，而不用去标注绝大多数需要回收的对象；一部分用于存储老年代，老年代发生GC的频率较低。这两个区域的GC频率是不同的，所以分开进行GC的话可以节省很多时间和存储这些对象的空间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：原来是这样，那么为什么会有第三个假说呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：如果出现新生代中存在老年代对象的引用，或者老年代对象中存在新生代对象的引用，这样的现象被我们称之为跨代引用，而我们为了确保可达性分析法的准确性，还需要去遍历老年代中的对象，这样就会造成很大的性能压力和负担。这时第三条结论就应运而生，为什么会有这条结论呢？你想一想，如果一个新生代对象在进行了几次GC后，因为跨代引用的原因，仍然没有被回收掉，那么这个新生代对象就会晋升到老年代中。于是就解决了这个跨代的问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么第三个假设对应的措施是什么呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：文字未免太过苍白，这个适合用图来表达，看好咯&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-18-132414.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：这样的话，会不会很清晰（得意脸&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：明白了，那我们继续吧，是不是要进入正题了&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：嗯哼，下面我就来介绍最基础的一种算法——标记清除算法&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;标记-清除&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：这个我知道，就像它名字那样，标记，然后清除，见名知意嘛哈哈哈哈。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：厉害了，不愧是技术出身的产品，佩服佩服，确实像你所说的那样，就很简单的两步，标记——清除。&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-18-133332.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：但是这样的方式由于过于简陋，虽然在对象较少的时候，效率比较快，但是当对象一多起来的话，标记和清除的效率都会有所下降，而且这样的方式会造成一个问题——产生内存碎片，如果剩下的空白格无法放下一个较大的对象时，就会提前触发另外一个GC。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：说到这里，好像还漏了点东西，GC针对不同的分代是不是有不同的GC叫法来着？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：对的，我疏忽了，针对新生代的GC一般称之为（Young GC），针对老年代的GC一般称之为（Old GC），如果是堆和方法区全部回收的话，则被称之为Full GC。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：这样倒也算好记，OK，我们来进入下一个算法吧。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：下一个算法，可以看作是第一个算法的升级版本，叫做&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;标记——复制算法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;标记-复制&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：标记复制算法，最开始形态是&lt;em&gt;半区复制&lt;/em&gt;，就是把之前的内容按照容量划分成等量的两部分，一部分用完之后，就把剩余存活的对象丢到另一半，然后把这一半进行清除，变成预留的另一块。如果是绝大多数对象需要回收（例如新生代）的情况下，这样的方法就会很便捷高效，但是这是一种牺牲空间来换取时间的做法，我们仅仅有效利用了一半的空间，有一半的空间被浪费掉了。&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-18-135828.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：所以后来一定会有所改进的，对吗？（期盼脸&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：没错，新的复制算法不能称之为半区复制了，因为新生代内存范围被分割成了三个部分，一个Eden区和两个Survivor区，他们之间的比例是8：1：1。在进行GC的时候，使用一个Eden和一个Survivor区，然后把剩余的存活对象放到另一个Survior区域中，清理掉剩下的区域，就可以完成一次收集的过程，这样仅仅有百分之十的空间被浪费，相对于优点来说，这样的缺点，我们是完全可以接受的，&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那如果剩下的Survivor不足以放下剩下存活的对象该怎么办呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：问的好，这个时候就要谈到一个新的概念——&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;内存担保&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;了，如果不够，就会去找老年代，如果老年代的&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;连续空间&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;大于新生代对象总大小或历次晋升的平均值，就可以借给Survivor区使用，至于为什么是这样，且待我卖个关子（其实是我也不知道哈哈哈哈哈&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么这种算法听起来好像没有什么缺点的亚子？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：并不然，复制的操作会降低回收的效率，而且，如果是老年代进行回收的话，你向谁去借呢？所以又出现了第三种算法——标记整理算法。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;标记-整理&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么什么是标记整理呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：标记-整理算法是一种移动型的算法，通过将存活对象向一边移动，然后直接清除掉边界外的内存以达到不会产生内存碎片的回收算法。&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-20-134542.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：那么这个算法的优点就是在于它不会产生内存碎片，减少了回收的次数，那么它和标记-整理相比孰优孰劣呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：对的，虽然在它移动对象的时候会花费不少的时间和资源，但是相对于标记-清除算法来说，频繁的GC所消耗的时间会更多，当然在实际的使用过程中，这三种算法会在不同的应用场景下结合去使用，比如先使用标记-清除算法，当内存碎片达到一定程度后，再使用标记-整理算法去清除，不同的组合会有不同的效果，具体什么效果，我会在给你介绍一些常见的垃圾收集器时进行讲解（下一节哟&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品大大：好的～ 那今天就先到这里吧，讲的差不多够我吸收个三五天的了，过两天你再给我讲吧～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：好哒。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;最后的最后&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咳咳，如果知识无法让你吃饱，那你可以多吃点狗粮哈哈哈哈哈哈（太皮会不会挨打嘻嘻&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;晒一张产品大大给我的备注。&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-16-135927.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面又是&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;精彩&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的恰🍋环节，如果真的有什么想给我说的，上图中有我的微信号，可以加我的微信，我们来进一步的交流，当然，如果你觉得我的文章写的还算有趣，能学到不少东西的话，请给我一个&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;关注+在看&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，让我们和产品大大一起去学习。如果能顺手关注一波公众号「Vi的技术博客」，那我更是感激涕零，对于&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;原创作者&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;来说，关注和阅读就是对我最大的支持和帮助！&lt;/p&gt;
&lt;img src=&quot;https://viyoungblog.oss-cn-beijing.aliyuncs.com/image_20200413080920.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后悄悄摸摸附上一张产品大大偷看我学习的萌照不会挨打吧？&lt;/p&gt;
&lt;img src=&quot;http://viyoungblog.oss-cn-beijing.aliyuncs.com/viyoung/2020-03-16-135710.png&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后提醒大家一点，&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;给产品经理可以讲道理可以皮&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，给老婆不可以，别问我为什么知道，我去&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;跪键盘&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;了，未完待续，我们下期再见（挥挥&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 00:23:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>纠结的我，给我的JVM系列终于起了第三个名字，害，我真是太难了。从 JVM 到 每日五分钟，玩转 JVM 再到现在的给产品经理讲 JVM ，虽然内容为王，但是标题可以让更多的人看到我的文章，所以，历经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viyoung/p/12689226.html</dc:identifier>
</item>
<item>
<title> GitHub 热点速览 Vol.15：Background-Matting 让你秒变专业抠图师 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12687908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12687908.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200412214251851-918625344.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：如果要选一个词来概述上周的热点，春风拂过，应该是一个不错的词。新项目像春天冒出的枝芽，朝气蓬勃，虽然获得的 star 不如之前三维 Vim 抢眼，但胜在多姿多彩，比如周获近 1k star 的抠图项目——Background-Matting，手把手教你炒大头菜的 ac-nh-turnip-prices 都充满了开源乐趣。老项目方面，优雅赚零花钱：howto-make-more-money 和云盘加速：rclone 本周也获得了超 1k star，说到 star，表现最赞的还是本周的#面试三部曲#主题的项目，三个项目一周获得的 star 近 10k。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自上周微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间超过 30 天的项目一律称之为成熟稳重老项目，由于文章篇幅问题还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;可怕 GitHub 新生&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 自动快照库：playbook-ios&lt;/li&gt;
&lt;li&gt;1.2 博客项目：nodejs-backend-architecture-typescript&lt;/li&gt;
&lt;li&gt;1.3 30 天吃掉 TensorFlow2.0：eat_tensorflow2_in_30_days&lt;/li&gt;
&lt;li&gt;1.4 人人都是抠图师：Background-Matting&lt;/li&gt;
&lt;li&gt;1.5 手把手教你炒大头菜：ac-nh-turnip-prices&lt;/li&gt;
&lt;li&gt;1.6 高分辨率压缩神器：SReC&lt;/li&gt;
&lt;li&gt;1.7 可视化学 web：web-skills&lt;/li&gt;
&lt;li&gt;1.8 了不起的 Docker Compose：awesome-compose&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;尚能星否 GitHub 老项目&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 云盘加速：rclone&lt;/li&gt;
&lt;li&gt;2.2 优雅赚零花钱：howto-make-more-money&lt;/li&gt;
&lt;li&gt;2.3 又见 Spring：spring-analysis&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本周 GitHub Trending #面试三部曲#主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 手把手撕 LeetCode 题目：fucking-algorithm&lt;/li&gt;
&lt;li&gt;3.2 免费小书：free-programming-books&lt;/li&gt;
&lt;li&gt;3.3 前人经验：interview_internal_reference&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-可怕-github-新生&quot;&gt;1. 可怕 GitHub 新生&lt;/h2&gt;
&lt;h3 id=&quot;11-自动快照库：playbook-ios&quot;&gt;1.1 自动快照库：playbook-ios&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Playbook 是用 Swift 开发的可用于独立开发 UI 组件和自动快照的库。它提供了一个用于构建 UI 组件的沙箱，而无需担心特定于应用程序的依赖关系。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/playbook-ui/playbook-ios&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200412214306129-2140321112.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-博客项目：nodejs-backend-architecture-typescript&quot;&gt;1.2 博客项目：nodejs-backend-architecture-typescript&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nodejs-backend-architecture-typescript 是 AfterAcademy 开源的可用来学习建立一个像 Medium、MindOrks 和 FreeCodeCamp 这样的博客平台的项目，它使用 Typescript 和 MongoDB 来开发，具有可维护且高度可测试的体系结构。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/afteracademy/nodejs-backend-architecture-typescript&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200412214322614-1295878562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;13-30-天吃掉-tensorflow20：eat_tensorflow2_in_30_days&quot;&gt;1.3 30 天吃掉 TensorFlow2.0：eat_tensorflow2_in_30_days&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2900+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;eat_tensorflow2_in_30_days 是一本极其友善的 TensorFlow2.0 入门工具书，不刻意恶心读者是本书的底限要求，Don't let me think 是该书的最高追求。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/lyhue1991/eat_tensorflow2_in_30_days&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200412214330706-1224472045.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;14-人人都是抠图师：background-matting&quot;&gt;1.4 人人都是抠图师：Background-Matting&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：950+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;图片背景处理器：Background-Matting 是一个基于背景抠图的工具，正如它的 slogan：The World is Your Green Screen 所说，只要你用 Background-Matting 即使你不会 ps 抠图，推理代码可以帮你更换图片中的背景。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/senguptaumd/Background-Matting&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200412214338244-1734136482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;15-手把手教你炒大头菜：ac-nh-turnip-prices&quot;&gt;1.5 手把手教你炒大头菜：ac-nh-turnip-prices&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：250+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;动森大头菜价格预测：ac-nh-turnip-prices，它是一个大头菜价格的价格计算器 / 预测器。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/mikebryant/ac-nh-turnip-prices&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;16-高分辨率压缩神器：srec&quot;&gt;1.6 高分辨率压缩神器：SReC&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：650+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SReC 是一个使用 PyTorch 实现的高分辨率图片无损压缩，它将神经网络应用于图像压缩。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/caoscott/SReC&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200412214347415-493734125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;17-可视化学-web：web-skills&quot;&gt;1.7 可视化学 web：web-skills&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：950+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;web-skills 收录了有用的 web 开发技巧，它采用了可视化界面方便你查看到所有收录的 web 开发技能。它分为基础篇、Web 组件篇、Webapp 篇、 Accessibility 篇，每个篇章有单独的章节，包括最佳实践。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/andreasbm/web-skills&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200412214401734-1194647494.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;18-了不起的-docker-compose：awesome-compose&quot;&gt;1.8 了不起的 Docker Compose：awesome-compose&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：950+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;awesome-compose 收录了 Docker Compose 的示例，这些示例演示了如何使用组合文件集成到不同的服务，包括 Prometheus、Grafana 等服务，以及如何使用 Docker 组合管理它们的部署。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/docker/awesome-compose&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-尚能星否-github-老项目&quot;&gt;2. 尚能星否 GitHub 老项目&lt;/h2&gt;
&lt;h3 id=&quot;21-云盘加速：rclone&quot;&gt;2.1 云盘加速：rclone&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1150+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rclone 是一个支持多个云盘与云存储的命令行工具，可同步来自不同云存储提供商的文件和目录，例如：Amazon S3，Backblaze B2，Box，Dropbox，FTP，Google Cloud Storage，Google Drive 等。rclone 支持上传、下载、删除、新建等常用操作，甚至支持将云盘挂载到本地。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/rclone/rclone&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;22-优雅赚零花钱：howto-make-more-money&quot;&gt;2.2 优雅赚零花钱：howto-make-more-money&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1150+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;howto-make-more-money 是一个程序员@Easy 现身讲述优雅的挣零花钱的项目，虽然是一个教你如何赚零花钱的项目，但是通过阅读本赚零花钱小书你可理清自己的核心资源，以及如何创造资产。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→hhttps://github.com/easychen/howto-make-more-money&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200412214422689-1640224146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-又见-spring：spring-analysis&quot;&gt;2.3 又见 Spring：spring-analysis&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：350+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;spring-analysis 是一个 Spring 源码阅读项目，分为 spring-core、spring-aop、spring-context、spring-task、spring-transaction、spring-mvc 和 guava-cache。&lt;/p&gt;
&lt;p&gt;如果你在尝试或者打算阅读 Spring 源码不妨和这个项目作者一块阅读源码。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/seaswalker/spring-analysis&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;3-本周-github-trending-面试三部曲主题的主力军&quot;&gt;3. 本周 GitHub Trending #面试三部曲#主题的主力军&lt;/h2&gt;
&lt;p&gt;找一份工作需要什么呢？扎实的基础，而基础的事情不是一朝一夕习得，free-programming-books 和 fucking-algorithm 这两个项目可帮你打好基础为面试打好地基，那么上层建筑就需要 interview_internal_reference 这个前人总结的大厂面试经验项目来帮忙了，希望本周小鱼干 Pick 的三个项目可以让你过关斩获一百分 offter ~~&lt;/p&gt;
&lt;h3 id=&quot;31-手把手撕-leetcode-题目：fucking-algorithm&quot;&gt;3.1 手把手撕 LeetCode 题目：fucking-algorithm&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：6400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;fucking-algorithm 仓库总共 60 多篇原创文章，基本上都是基于 LeetCode 的题目，涵盖了所有题型和技巧，而且一定要做到举一反三，通俗易懂，绝不是简单的代码堆砌，后面有目录。项目作者有云：刷题刷题，刷的是题，培养的是思维，本仓库的目的就是传递这种算法思维。我要是只写一个包含 LeetCode 题目代码的仓库，有个锤子用？没有思路解释，没有思维框架，顶多写个时间复杂度，那玩意一眼就能看出来。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/labuladong/fucking-algorithm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;32-免费小书：free-programming-books&quot;&gt;3.2 免费小书：free-programming-books&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2000+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;free-programming-books 收录了可免费阅读的编程书籍。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/EbookFoundation/free-programming-books&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;33-前人经验：interview_internal_reference&quot;&gt;3.3 前人经验：interview_internal_reference&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：600+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;interview_internal_reference 收录了 2019 年最新总结，阿里，腾讯，百度，美团，头条等技术面试题目，以及答案，专家出题人分析汇总。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/0voice/interview_internal_reference&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 15 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202004/759200-20200406212426655-796625417.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 13 Apr 2020 00:14:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub 小鱼干 摘要：如果要选一个词来概述上周的热点，春风拂过，应该是一个不错的词。新项目像春天冒出的枝芽，朝气蓬勃，虽然获得的 star 不如之前三维 Vim 抢眼，但胜在多姿</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12687908.html</dc:identifier>
</item>
<item>
<title>CSS躬行记（4）——浮动形状 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12468308.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12468308.html</guid>
<description>&lt;p&gt;　　CSS规范新增了一个模块：CSS Shapes，shape-outside属性属于该模块，它能影响浮动元素周边内容流的形状（即浮动形状），可接收三类值：形状盒子、函数和图像。&lt;/p&gt;

&lt;p&gt;　　形状盒子（shape box）会指定形状的边界，既能单独使用，也能与另外两类值组合使用，可选的关键字如下所列，其中margin-box是shape-outside属性的默认值。&lt;/p&gt;
&lt;p&gt;　　（1）margin-box：以外边距为界。&lt;/p&gt;
&lt;p&gt;　　（2）border-box：以边框为界。&lt;/p&gt;
&lt;p&gt;　　（3）padding-box：以内边距为界。&lt;/p&gt;
&lt;p&gt;　　（4）content-box：以内容为界。&lt;/p&gt;
&lt;p&gt;　　下图演示了四种形状盒子的效果，外边距、边框和内边距都设为了10px，代码中只列出了关键样式，并只举了其中的一种情况。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .container &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; hidden&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  div &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    float&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; left&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    padding&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    margin&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    border&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px solid #FC0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #F60&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    background-clip&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; content-box&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .border-box &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    shape-outside&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; border-box&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;container&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;border-box&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;border-box&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My name is Strick.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My name is Strick.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My name is Strick.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My name is Strick.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My name is Strick.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312115706175-1561086630.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　有4个形状函数可供选择，分别是circle()、ellipse()、inset()以及polygon()。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）circle()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第一种是圆形，可定义半径和圆点位置，例如浮动元素的宽高都为100px，圆的半径为50px，样式如下所示，效果如下图所示，其中白色边框的圆就是计算出的浮动形状。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; circle(50px)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312115941382-1445678867.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接下来指定圆点的位置，需要使用at关键字将半径和位置分隔。在下面的样式中，圆点处在元素的右上角，注意观察下图中的浮动形状，它超出了元素的边界，超出部分默认会被裁剪掉。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; circle(50px at right top)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120103735-1867570989.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当用百分数指定半径时，需要有个参照值，该值得通过下面的公式计算得到，其中width是形状盒子的宽，height是其高。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120143618-1649819759.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　假设半径为10%，浮动元素的上下外边距为10px，因为默认是以外边距为界限，所以此处形状盒子的高度为120px，宽度仍然是100px，那么通过计算后得到的参照值约等于110px，半径就是11px，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt; 10px 0&lt;/span&gt;;&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; circle(10%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120312868-1223745965.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）ellipse()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第二种是椭圆，与圆形类似，也需要定义半径和圆点位置。只是它需要两个半径，第一个是横轴半径，第二个是纵轴半径。在下面的示例中，浮动元素的宽为100px，高为60px，将浮动形状声明为椭圆，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; ellipse(50px 30px)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120400982-1403731837.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　横轴上的百分数半径参照形状盒子的宽度，纵轴上的百分数半径参照形状盒子的高度，下面定义的百分数半径经过计算后得到的值为50px和40px，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt; 10px 0&lt;/span&gt;;&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; ellipse(50% 50%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120458748-29903837.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）inset()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第三种是嵌入在形状盒子中的内部矩形，它能接收一组值，分别表示上右下左向内偏移的距离，还能接收一个可选的圆角，以round关键字分隔。&lt;/p&gt;
&lt;p&gt;　　在下面的示例中，虽然只提供了两个值，但CSS会根据现有的值确定其余值，内部矩形距离形状盒子的顶端和底端是20px，左右边界是10px，形状盒子的宽为100px，高为80px，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 60px&lt;/span&gt;;&lt;span&gt;
  margin&lt;/span&gt;:&lt;span&gt; 10px 0&lt;/span&gt;;&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; inset(20px 10px)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120612051-17530499.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面的样式为内部矩形添加了20px的圆角，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; inset(20px 10px round 20px)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120659981-2010406102.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当内部矩形的偏移值是百分数时，左右偏移参照的是形状盒子的宽，上下偏移参照的是其高。例如参数值为20%，那么计算出的左右偏移值是20px，上下偏移值是16px，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; inset(20%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120750505-243189261.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）polygon()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　第四种是多边形，它能接收一系列坐标对，相对于形状盒子的左上角计算，将所有的点连接起来就是最终的形状。根据下面的polygon()函数中的四组坐标可描绘出一个直角梯形，如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 80px&lt;/span&gt;;&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; polygon(10px 10px, 20px 10px, 40px 50px, 10px 50px)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120855764-1954405201.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当坐标是百分数时，横坐标参照形状盒子的宽，纵坐标参照其高，下面定义的坐标，效果与上图一致。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; polygon(10% 12.5%, 20% 12.5%, 40% 62.5%, 10% 62.5%)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有一种简便的方式创建多边形，那就是使用Chrome的浏览器插件：CSS Shapes Editor，用拖拽鼠标的方式得到想要的多边形，再将参数复制到样式表中，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312120955836-1035643944.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　当形状很复杂时，直接画多边形会非常麻烦，不过shape-outside属性可基于图像的透明度（alpha值）来绘制形状，即形状轮廓会沿着非透明区域的边缘生成。&lt;/p&gt;
&lt;p&gt;　　例如有一个五角星，如果边以外的地方都是透明的，那么周围的内容就会贴着五角星的边，如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  float&lt;/span&gt;:&lt;span&gt; left&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  shape-outside&lt;/span&gt;:&lt;span&gt; url(./star.png)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312121104716-842436743.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，url()函数中的图像不能直接从本地加载，必须从Web服务器中读取，如此引用的图像会有HTTP首部信息，用于判断是否跨域。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）shape-image-threshold&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　该属性可指定透明度阈值，修改形状边界，其取值范围是0~1，值越小透明度越高。对于透明度低于该值的部分，会包含在浮动形状中，而高于的则不包含。&lt;/p&gt;
&lt;p&gt;　　例如将该值设为1时，就表示没有浮动形状，即整张图像都不在浮动形状中，如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  shape-image-threshold&lt;/span&gt;:&lt;span&gt; 1&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312121220462-442589670.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）shape-margin&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　该属性可指定浮动形状的外边距。在下面的示例中会添加10px的外边距，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  shape-margin&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312121319689-1118650633.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，shape-margin属性的百分数的计算方式与普通的外边距相同，参照的也是包含块的宽度。假设div元素的包含块的宽度为220px，那么10%的外边距经过计算后得到的值为22px，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  shape-margin&lt;/span&gt;:&lt;span&gt; 10%&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200312121359755-1086437769.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 12 Apr 2020 23:30:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>CSS规范新增了一个模块：CSS Shapes，shape-outside属性属于该模块，它能影响浮动元素周边内容流的形状（即浮动形状），可接收三类值：形状盒子、函数和图像。 一、形状盒子 形状盒子（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12468308.html</dc:identifier>
</item>
<item>
<title>Python操作Oracle数据库：cx_Oracle - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/12689163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/12689163.html</guid>
<description>&lt;p&gt;千万注意，包名称cx_Oracle中，字母“O”是大写的，写成小写将会导入失败。&lt;br/&gt;这里再附带多说一点，我在安装好cx_Oracle第一次使用时，出现这个异常：DatabaseError: DPI-1047,可以按照官方的思路解决：&lt;a href=&quot;https://oracle.github.io/odpi/doc/installation.html#linux&quot;&gt;https://oracle.github.io/odpi/doc/installation.html#linux&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;cx_Oracle提供了两种方式连接Oracle数据库，分别是创建独立的单一连接以及创建连接池。&lt;/p&gt;

&lt;p&gt;创建单一连接主要是通过cx_Oracle模块中提供的connect()方法实现，虽然也可以直接通过Connection()类实现，但是不推荐。connect()方法参数有很多，说说其中最常用的四个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;user：用户名&lt;/li&gt;
&lt;li&gt;password：密码&lt;/li&gt;
&lt;li&gt;dsn：数据库地址和服务名&lt;/li&gt;
&lt;li&gt;encoding：编码，合适的编码可以避免出现乱码&lt;br/&gt;这里要重点说一下dsn，dsn是data source name的缩写，用于描述数据源的详细地址，一般由数据库所在主机地址、端口和服务名组成。在默认情况下，Oracle数据库对应1521端口，在这种情况下，dsn中可以省略端口：&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 12 Apr 2020 23:10:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>在前面的博客中已经介绍过如何使用Python来操作MySQL数据库，最近需要将一批数据从csv文件中迁移到Oracle数据库中，也打算用Python来实现，趁着这个机会，也写一篇博客学习总结一些如何使</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/12689163.html</dc:identifier>
</item>
</channel>
</rss>