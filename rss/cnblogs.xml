<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>「MoreThanJava」一文了解二进制和CPU工作原理 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/13029117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/13029117.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/def6144e-d6a2-4f06-9d6c-7f2c0acf6cc9.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;「MoreThanJava」&lt;/strong&gt; 宣扬的是 &lt;strong&gt;「学习，不止 CODE」&lt;/strong&gt;，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 &lt;strong&gt;「帮助新朋友快速高质量的学习」&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;当然 &lt;strong&gt;不论新老朋友&lt;/strong&gt; 我相信您都可以 &lt;strong&gt;从中获益&lt;/strong&gt;。如果觉得 &lt;strong&gt;「不错」&lt;/strong&gt; 的朋友，欢迎 &lt;strong&gt;「关注 + 留言 + 分享」&lt;/strong&gt;，文末有完整的获取链接，您的支持是我前进的最大的动力！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/83f0e7c4-541d-4eaf-9cc0-b14456176188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.3333333333333&quot;&gt;
&lt;p&gt;本节内容节选自下方 &lt;a href=&quot;https://www.jianshu.com/p/58844323e4fb&quot;&gt;参考资料 1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在讨论「二进制」和「CPU 如何工作」之前，我们先来讨论一下我们生活中最稀疏平常的 &lt;strong&gt;数字&lt;/strong&gt;，我们与之频繁地打交道：一个约定的时间、一件商品的价格、一个人的身高....却很少有人细细想过，这些数字是如何表达出来的？为什么你理所当然地把 &lt;code&gt;1024&lt;/code&gt; 理解为「一千零二十四」而不是别的含义？&lt;/p&gt;
&lt;p&gt;也许你从未想过，在这简单的记数中，沉淀着人类的大智慧。&lt;/p&gt;
&lt;h2 id=&quot;一进制计数法&quot;&gt;一进制计数法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/f5e44afe-03d7-4d2c-831e-35e736168d8e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;早在数字的概念产生之前，人类就学会了使用树枝、石子、贝壳等自然界随处可见的小物件表示猎物的、果实的、部落人口的数量。比如在某个角落堆上一堆石子，每打到 1 只猎物，就扔 1 颗石子进去，每吃掉 2 只猎物，就从中取走 2 颗石子。他们并不在意石子的总数，只是时不时地瞅一眼，心底大致有数。&lt;/p&gt;
&lt;p&gt;其实这是一种最朴素的记数方式，数学家称之为 &lt;strong&gt;一进制记数法&lt;/strong&gt;（unary numeral system）。我们把它符号化一下，比如用斜杠 &lt;code&gt;/&lt;/code&gt; 来表示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 就是 &lt;code&gt;/&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;2&lt;/code&gt; 就是 &lt;code&gt;//&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;4&lt;/code&gt; 就是 &lt;code&gt;////&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好像没毛病，我们平时掰手指用的就是这种记数法，但数字一大，场面就要失控了。&lt;/p&gt;
&lt;h2 id=&quot;符值相加记数法&quot;&gt;符值相加记数法&lt;/h2&gt;
&lt;p&gt;为了解决记录大数的问题，于是我们得发明一些其他符号来表示更大的数值，比如用横杠 &lt;code&gt;-&lt;/code&gt; 表示 &lt;code&gt;10&lt;/code&gt;，用十字 &lt;code&gt;+&lt;/code&gt; 表示 &lt;code&gt;100&lt;/code&gt;。那么：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;16&lt;/code&gt; 就是 &lt;code&gt;-//////&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;32&lt;/code&gt; 就是 &lt;code&gt;---//&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;128&lt;/code&gt; 就是 &lt;code&gt;+--////////&lt;/code&gt;;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;漂亮....这种靠符号类型和符号数量表示数字的方法被称为 &lt;strong&gt;符值相加记数法&lt;/strong&gt;（sign-value notation），古埃及和古罗马用的都是它，只不过符号各不相同。&lt;/p&gt;
&lt;p&gt;古埃及的记数符号：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1024&lt;/code&gt; 在古埃及就写作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/1d9cc9a9-8c9c-41ca-bf64-ff47cab8e2cb.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你会发现，符值相加记数法的一大优点是，符号的顺序可以任意打乱，数字含义不受影响&lt;/strong&gt;。我国藏族曾用石子表示 &lt;code&gt;1&lt;/code&gt;、木棍表示 &lt;code&gt;10&lt;/code&gt;、果核表示 &lt;code&gt;100&lt;/code&gt;、蚕豆表示 &lt;code&gt;1000&lt;/code&gt;、瓦片表示 &lt;code&gt;10000&lt;/code&gt;，那么，当你把 &lt;code&gt;1&lt;/code&gt; 颗蚕豆、&lt;code&gt;2&lt;/code&gt; 根木棍和 &lt;code&gt;4&lt;/code&gt; 颗石子胡乱地攥在手里，别人依然知道它们是 &lt;code&gt;1024&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;古罗马的做法略有不同，他们对五进制情有独钟：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;50&lt;/th&gt;
&lt;th&gt;100&lt;/th&gt;
&lt;th&gt;500&lt;/th&gt;
&lt;th&gt;1000&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;V&lt;/td&gt;
&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这些符号沿用至今，想必大家（至少对前 &lt;code&gt;3&lt;/code&gt; 个）都比较熟悉，许多钟表仍保留着使用罗马数字的习惯，&lt;code&gt;1~12&lt;/code&gt; 分别表示为：&lt;code&gt;I&lt;/code&gt;、&lt;code&gt;II&lt;/code&gt;、&lt;code&gt;III&lt;/code&gt;、&lt;code&gt;IV&lt;/code&gt;、&lt;code&gt;V&lt;/code&gt;、&lt;code&gt;VI&lt;/code&gt;、&lt;code&gt;VII&lt;/code&gt;、&lt;code&gt;VIII&lt;/code&gt;、&lt;code&gt;IX&lt;/code&gt;、&lt;code&gt;X&lt;/code&gt;、&lt;code&gt;XI&lt;/code&gt;、&lt;code&gt;XII&lt;/code&gt;。你会发现，罗马记数法是符值相加记数法的变种，因为它不光「相加」，还「相减」。这种方式就不允许符号乱序了，&lt;code&gt;IV&lt;/code&gt; 和 &lt;code&gt;VI&lt;/code&gt; 表示的是不同的数字。&lt;/p&gt;
&lt;p&gt;那罗马人何苦要使用这种更复杂的记数法呢？无非是为了读写方便。同样表示 &lt;code&gt;9&lt;/code&gt;，&lt;code&gt;IX&lt;/code&gt; 比 &lt;code&gt;VIIII&lt;/code&gt; 更简洁。&lt;/p&gt;
&lt;p&gt;其实有一种更好使的方法——用另外一些列符号来表示符号的数量。比如用 &lt;code&gt;A&lt;/code&gt; 表示 &lt;code&gt;1&lt;/code&gt; 个符号，用 &lt;code&gt;B&lt;/code&gt; 表示 &lt;code&gt;2&lt;/code&gt; 个符号，以此类推，用 &lt;code&gt;I&lt;/code&gt; 表示 &lt;code&gt;9&lt;/code&gt; 个符号。&lt;/p&gt;
&lt;p&gt;如此，上文表示 &lt;code&gt;256&lt;/code&gt; 的 &lt;code&gt;++-----//////&lt;/code&gt; 就可以写作 &lt;code&gt;B+E-F/&lt;/code&gt;。你一定感觉莫名其妙，这种写法哪里方便了。其实中文的数字表示就是这种形式，只不过我们用得太习惯了，以至于没有发现。&lt;/p&gt;
&lt;p&gt;在中文中，&lt;code&gt;个&lt;/code&gt;、&lt;code&gt;十&lt;/code&gt;、&lt;code&gt;百&lt;/code&gt; 代替了 &lt;code&gt;/&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt;，而 &lt;code&gt;一&lt;/code&gt;、&lt;code&gt;二&lt;/code&gt;、&lt;code&gt;三&lt;/code&gt; 代替了 &lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;C&lt;/code&gt;。&lt;code&gt;256&lt;/code&gt; 就写作 &lt;code&gt;二百五十六个&lt;/code&gt;，&lt;code&gt;个&lt;/code&gt; 比较累赘，我们通常把它省略了。&lt;/p&gt;
&lt;p&gt;其实像日语、英语用的也同样是这种记数法，简洁、优雅。&lt;/p&gt;
&lt;p&gt;美中不足的是，这种形式虽便于读写，却不便于计算。中国古人为算筹和算盘这类经典算具搭建起广阔的舞台，却没给笔算留出一席之地。想象一下，如果让你把这些汉字写在草稿纸上，列个竖式，你的内心一定非常别扭。&lt;/p&gt;
&lt;h2 id=&quot;位值制记数法&quot;&gt;位值制记数法&lt;/h2&gt;
&lt;p&gt;公元5世纪，印度数学家阿耶波多（Aryabhata 476–550）创立了现在广泛使用的 &lt;strong&gt;位值制记数法&lt;/strong&gt;（positional notation/place-value notation），该记数法使用的主要符号，是同为印度人发明的阿拉伯数字：&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt;、&lt;code&gt;4&lt;/code&gt;、&lt;code&gt;5&lt;/code&gt;、&lt;code&gt;6&lt;/code&gt;、&lt;code&gt;7&lt;/code&gt;、&lt;code&gt;8&lt;/code&gt;、&lt;code&gt;9&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;与符值相加记数法类比，位值制中的 &lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;、&lt;code&gt;3&lt;/code&gt; 代替的是 &lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;、&lt;code&gt;C&lt;/code&gt;，那 &lt;code&gt;/&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;、&lt;code&gt;+&lt;/code&gt; 呢？是 &lt;strong&gt;靠阿拉伯数字的位置来表示的&lt;/strong&gt;。众所周知，最右位相当于 &lt;code&gt;/&lt;/code&gt;，次右位相当于 &lt;code&gt;-&lt;/code&gt;。&lt;strong&gt;靠每个位置上的数值来表示数字，故名位值制。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;严谨的数学家用一种多项式高度概括了位值制记数法的本质，在十进制中，这个多项式是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a2505d07-0f69-4e2c-bd4d-22a5c804ee08.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/51f19109-4b4c-4d64-8c3a-a06f83c5409b.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个 &lt;code&gt;n&lt;/code&gt; 位十进制数，a&lt;sub&gt;i&lt;/sub&gt; 就是第 i 位上的数值。为便于直观理解，举个 &lt;code&gt;1024&lt;/code&gt; 的例子吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a50973c7-92e6-4e83-a0fa-eb83b9b2f729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于我们熟悉了十进制，这样费心费力的展开可能会让你觉得好笑，但当我们把它推广到其他进制时，这个多项式的价值就体现了出来。&lt;strong&gt;n 位 b 进制数的位值制表示：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/1fa1b1a0-cdfc-4754-904c-970f285c2817.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/7020f1e3-3bc5-4731-ad1a-32dada7d995e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1024&lt;/code&gt; 用二进制怎么表示？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/1b267d5e-54bb-4042-9b41-b560640b8291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此，&lt;code&gt;1024&lt;/code&gt; 的二进制写作 &lt;code&gt;10000000000&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;除了最普遍的十进制和计算机中的二进制，常见的还有七进制（如 &lt;code&gt;1&lt;/code&gt; 周 &lt;code&gt;7&lt;/code&gt; 天）、十二进制（如 &lt;code&gt;1&lt;/code&gt; 年 &lt;code&gt;12&lt;/code&gt; 个月）、十六进制（如古代 &lt;code&gt;1&lt;/code&gt; 斤 &lt;code&gt;16&lt;/code&gt; 两）、六十进制（如六十甲子）等等，只要有意义，任何进制都可以为你所用。&lt;/p&gt;
&lt;h2 id=&quot;非标准位值制&quot;&gt;非标准位值制&lt;/h2&gt;
&lt;p&gt;在上述的多项式中，如果 a&lt;sub&gt;i&lt;/sub&gt; 或 b 的取值奇葩一点，就形成了 &lt;strong&gt;非标准位值制&lt;/strong&gt;（non-standard positional numeral systems），这类记数法往往应用于专业领域，很难在日常生活中见到。比如标准位值制中的三进制 a&lt;sub&gt;i&lt;/sub&gt; 的取值为 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;、&lt;code&gt;2&lt;/code&gt;，但在一种名为平衡三进制（balanced ternary）的非标准位值制中，a&lt;sub&gt;i&lt;/sub&gt; 取 &lt;code&gt;-1&lt;/code&gt;、&lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt;，苏联曾使用这种进制研发电子计算机。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/d5bff8fa-f4a7-4f96-8ef9-1ea4cb8e66ed.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，你对「二进制」应该会感觉亲切了些，它只是一种数制而已，本质上与我们熟悉的十进制没有很大的差别，我们这一 Part 来稍微理解一下二进制。（至于电脑为什么使用二进制我们在下一 Part 中介绍）&lt;/p&gt;
&lt;h2 id=&quot;二进制的基本运算&quot;&gt;二进制的基本运算&lt;/h2&gt;
&lt;p&gt;十进制中的那些基本运算原则，二进制中同样适用，只不过需要稍加变幻而已，下面我们分别就加、减、乘、除四则运算来介绍。&lt;/p&gt;
&lt;h3 id=&quot;二级制加法&quot;&gt;二级制加法&lt;/h3&gt;
&lt;p&gt;根据「逢二进一」规则，二进制数加法的法则为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;0＋0＝0
0＋1＝1＋0＝1
1＋1＝0　（进位为1） 
1＋1＋1＝1 （进位为1）
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;code&gt;1101&lt;/code&gt; 和 &lt;code&gt;1011&lt;/code&gt; 相加过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/6074fc2f-1723-4559-a083-503c8ad1e0ac.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二进制数的减法&quot;&gt;二进制数的减法&lt;/h3&gt;
&lt;p&gt;根据「借一有二」的规则，二进制数减法的法则为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;0－0＝0
1－1＝0
1－0＝1
0－1＝1 （借位为1）
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;code&gt;1101&lt;/code&gt; 减去 &lt;code&gt;1011&lt;/code&gt; 的过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/7671d357-2c8d-48a6-9d16-934c3a63f253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二进制的乘法&quot;&gt;二进制的乘法&lt;/h3&gt;
&lt;p&gt;二进制数乘法过程可仿照十进制数乘法进行。但由于二进制数只有 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 两种可能的乘数位，导致二进制乘法更为简单。二进制数乘法的法则为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;0×0＝0
0×1＝1×0＝0
1×1＝1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：&lt;code&gt;1001&lt;/code&gt; 和 &lt;code&gt;1010&lt;/code&gt; 相乘的过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/3391b16e-8ca0-4934-b09a-03268868ac19.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二进制的除法&quot;&gt;二进制的除法&lt;/h3&gt;
&lt;p&gt;二进制数除法与十进制数除法很类似。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;100110&lt;/code&gt; ÷ &lt;code&gt;110&lt;/code&gt; 的过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/974fb531-d1b1-494e-b640-f4d665003143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二进制为什么能表示所有的数据&quot;&gt;二进制为什么能表示所有的数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;因为编码规定。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之前我们有说到，所有保存的程序和数据在计算机中都被描述为 &lt;strong&gt;文件&lt;/strong&gt;，也就是说我们能够知道当前的数据集合被期望的用途是什么，也就能够找到对应的 &lt;strong&gt;处理器&lt;/strong&gt; 来正确处理当前的数据。&lt;/p&gt;
&lt;h3 id=&quot;例如保存文字&quot;&gt;例如保存文字&lt;/h3&gt;
&lt;p&gt;拿文字举例，为了让一串 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt; 能够代表特定的文字，人们规定使用一个字节中的七位来表达特定的文字， 这就是大名鼎鼎 &lt;strong&gt;ASCII&lt;/strong&gt; &lt;em&gt;(American Standard Code for Information Interchange)&lt;/em&gt; 码，ASCll 码能够表达 &lt;strong&gt;2&lt;sup&gt;7&lt;/sup&gt;=128&lt;/strong&gt; 种字符(编码从 &lt;code&gt;0~127&lt;/code&gt;)，对于 &lt;code&gt;26&lt;/code&gt; 个英文字母和一些常用的可打印字符，这完全足够了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/f0258468-a7d8-4512-9de6-d960770269d3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可是，世界文化是多元的，面对类似汉字这样的象形文字，ASCll码表用起来自然是捉襟见肘。&lt;/p&gt;
&lt;p&gt;穷则思变，一个字节不行，那就两个字节，这就是大名鼎鼎的 &lt;strong&gt;Unicode&lt;/strong&gt; 码，不难看出，Unicode 码有 &lt;strong&gt;2&lt;sup&gt;16&lt;/sup&gt;=65536&lt;/strong&gt; 种表示方式，这样就足以表达一些常用的字符了，值得一提的是，Unicode 码算是在 ASCll 码上的一种扩充,其第 &lt;code&gt;0~127&lt;/code&gt; 个编码字符与 ASCll 码表一模一样。&lt;/p&gt;
&lt;h3 id=&quot;再比如图片&quot;&gt;再比如图片&lt;/h3&gt;
&lt;p&gt;这里涉及一点点物理知识，话说很久以前，牛顿通过三棱镜把白色的光分解成七种不同颜色的光，后来又通过各种实验发现红、绿、蓝三种颜色的光是无法被分解的，因此我们就称为红蓝绿为光的三原色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/036a4ca5-f491-41dd-ad7f-ed1ce4bc1d6f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此人类已经知道了：&lt;strong&gt;可以通过组合不同比例的红、绿、蓝三种颜色来获得各种各样的颜色&lt;/strong&gt;，那么我们就可以在计算机上模拟了。现在的计算机，一般使用 &lt;code&gt;32&lt;/code&gt; 位来表示颜色，&lt;code&gt;32&lt;/code&gt; 位平分给四个分量，也就是每个分量 &lt;code&gt;8&lt;/code&gt; 位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为啥是四个颜色分量?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为颜色模型中有一个 alpha 值，用来表示透明度，这一点我们先不考虑。总之三种颜色，每个使用 &lt;code&gt;8&lt;/code&gt; 位来表示的话，我们就能够表示 &lt;code&gt;256 * 256 * 256 = 16777216&lt;/code&gt; 种颜色了，已经足够基础的使用了。&lt;/p&gt;
&lt;p&gt;先来看一张图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/f69cfd26-cac6-40b9-b2d7-cccc47a5a941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图像的尺寸是 &lt;code&gt;600px * 664px&lt;/code&gt;（px 是一种图片单位，中文名称为像素，你可以暂时理解为一个点）。我们把它放大一下，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/83d476cf-c8bd-4884-873f-520324241a10.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看见了吗？实际上，大部分图像（你拍摄的照片、你扫描的图片、你使用 iPad 画的图片等等...）都是位图文件，位图就是由像素点构成的，它就像是一个网格一样，每个格子里面填一个颜色。（除了位图外，还有一种图是矢量图，它描述的是形状而非网格）&lt;/p&gt;
&lt;p&gt;OK，我想你已经能理解图像是由像素点组成的了（事实上我们的显示器也是），我们只需要在编码中附带上一些额外的信息，例如图像有多大的尺寸、时间、作者、颜色深度、是否支持透明度之类的就能够对图像进行正确表示了。（视频可以简单理解成一张张连续不断的图片）&lt;/p&gt;
&lt;p&gt;要让显示器正确显示图片或者视频，只需要让显示器上每个像素显示特定的颜色就好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/b6369f63-1301-4351-8b5a-54baaddd3796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/d73490ba-d000-460e-9d55-ab7fb1efdfb8.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可为什么一定是二进制呢？使用人类习惯的十进制不好吗？&lt;/p&gt;
&lt;h2 id=&quot;理由一：物理上易于实现&quot;&gt;理由一：物理上易于实现&lt;/h2&gt;
&lt;p&gt;计算机依靠电力工作，这也就意味着需要将数字信号映射到电信号，实现这种映射最简单的方法是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0 - 没有电（0 V）&lt;/li&gt;
&lt;li&gt;1 - 有点（5 V）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;二进制在技术上最容易实现。这是因为具有两种 &lt;strong&gt;稳定状态&lt;/strong&gt; 的物理器件很多，如门电路的导通与截止、电压的高与低等，而它们恰好可以对应表示 “1” 和 “0” 这两个数码。假如采用十进制，那么就要制造具有 &lt;code&gt;10&lt;/code&gt; 种 &lt;strong&gt;稳定状态&lt;/strong&gt; 的物理电路，而这是非常困难的。&lt;/p&gt;
&lt;h2 id=&quot;理由二：机器可靠性高&quot;&gt;理由二：机器可靠性高&lt;/h2&gt;
&lt;p&gt;为什么使用更复杂的数字系统是一个问题？&lt;/p&gt;
&lt;p&gt;假设我们使用三元（3 位数字）数字系统涉及计算机，如果我们具有从 &lt;code&gt;0 V&lt;/code&gt; 到 &lt;code&gt;5 V&lt;/code&gt; 的电压，那么我们可以进行以下的映射：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0 - 0 V;&lt;/li&gt;
&lt;li&gt;1 - 2.5 V;&lt;/li&gt;
&lt;li&gt;2 - 5 V;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a710c884-6400-422f-92e0-bd8798bbd589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看起来合理吧？但是，想象一下，我以 &lt;code&gt;2.5 V&lt;/code&gt; 的电压发送了一个数字。但是由于电路中的一些噪声，我在输出端得到 &lt;code&gt;2.3 V&lt;/code&gt; 的电压，因此将其视为 &lt;code&gt;0&lt;/code&gt;。结果是？&lt;/p&gt;
&lt;p&gt;有人给我发送了 &lt;code&gt;1&lt;/code&gt;，但我将其视为 &lt;code&gt;0&lt;/code&gt;。数据丢失可是一个非常严重的问题。&lt;/p&gt;
&lt;p&gt;使用二进制则可靠得多，由于电压的高和低、电流的有和无等都是一种 &lt;strong&gt;质的变化&lt;/strong&gt;，两种物理状态稳定、分明，因此，二进制码传输的抗干扰能力强，鉴别信息的可靠性高。&lt;/p&gt;
&lt;h3 id=&quot;为什么计算机系统必须有时钟&quot;&gt;为什么计算机系统必须有时钟&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/f759123c-c615-4c79-ae65-b1a58ac5827f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;建立数字系统的目的是 &lt;strong&gt;仅在某些时间点测试开/关（二进制）值&lt;/strong&gt;，这使电线（或其他设备）有时间更换。&lt;strong&gt;这就是计算机系统有时钟的原因。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时钟会周期性地进行信号的测量，图中所示的 T1 和 T2 就是可以测量信号的时间点。&lt;/p&gt;
&lt;p&gt;时钟利用所有这些时间点来保持同步。更快的时钟意味着每秒可以对电线进行更多次测试，并且整个系统运行得更快。&lt;code&gt;2 GHz&lt;/code&gt; 处理器每秒检查二进制值 &lt;code&gt;20&lt;/code&gt; 亿次。在这些时间之间，允许值改变并稳定下来。处理器芯片速度越快，每秒可以测试的次数就越多，每秒可以做出的决策就越多。&lt;/p&gt;
&lt;h2 id=&quot;理由三：运算规则简单&quot;&gt;理由三：运算规则简单&lt;/h2&gt;
&lt;p&gt;数学推导已经证明，对 &lt;code&gt;N&lt;/code&gt; 进制数进行算术求和或求积运算，其运算规则各有 &lt;code&gt;N(N+1)/2&lt;/code&gt; 种。如采用十进制，则 &lt;code&gt;N=10&lt;/code&gt;，就有 &lt;code&gt;55&lt;/code&gt; 种求和或求积的运算规则；而采用二进制，则 &lt;code&gt;N=2&lt;/code&gt;，仅有 &lt;code&gt;3&lt;/code&gt; 种求和或求积的运算规则，以上面提到的加法为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;0+0=0，0+1=1 (1+0=1)，1+1=10
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因而可以大大简化运算器等物理器件的设计。&lt;/p&gt;
&lt;h2 id=&quot;理由四：逻辑判断方便&quot;&gt;理由四：逻辑判断方便&lt;/h2&gt;
&lt;p&gt;采用二进制后，仅有的两个符号 “1” 和 “0” 正好可以与逻辑命题的两个值 “真” 和 “假” 相对应，能够方便地使用逻辑代数这一有力工具来分析和设计计算机的逻辑电路。&lt;/p&gt;
&lt;p&gt;虽然在 1950 年代就造出了更加高效的三元计算机，但在效率和复杂度的取舍上，始终抵不过二进制。二进制仍然在当今世界中长期存在。&lt;/p&gt;

&lt;p&gt;上面我们了解到计算机以二进制的形式运行，它们只有两种状态：开（1）和关（0），为了执行二进制计算，我们需要采用一种特殊的电子元器件，称为 &lt;strong&gt;「晶体管」&lt;/strong&gt;。暂时我们把它理解为一种开关吧，通电就打开，没电流通过就关闭。&lt;/p&gt;
&lt;h2 id=&quot;利用开关搭建逻辑电路&quot;&gt;利用&quot;开关&quot;搭建逻辑电路&lt;/h2&gt;
&lt;p&gt;我们知道，给电灯通上电，它就会亮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/0f4e3c78-41a3-4703-9cd1-01b081012ca3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，结合上开关，我们就能搭建出最基础的 &lt;strong&gt;与门&lt;/strong&gt; 和 &lt;strong&gt;或门&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;与门&quot;&gt;与门&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/0fe9a48c-20d6-4725-ae77-5ca6925b9116.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该电路的逻辑是：&lt;strong&gt;只有当 A 和 B 同时开启时，LED 灯才会亮&lt;/strong&gt;，也就是认为输出 1，我们可以利用电信号来简单模拟一下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;Y&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;或门&quot;&gt;或门&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/dee70872-6f4f-4a29-b2e2-d69a5d371e29.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该电路的逻辑是：&lt;strong&gt;当 A 或者 B 开启时，LED 灯就会亮&lt;/strong&gt;，也就是认为输出 1，我们可以利用电信号来简单模拟一下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;B&lt;/th&gt;
&lt;th&gt;Y&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;其他门&quot;&gt;其他门&lt;/h4&gt;
&lt;p&gt;类似地，我们可以借助更多的电子元器件来创造出基础的 &lt;code&gt;7&lt;/code&gt; 种逻辑门电路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/889969e5-c76e-4932-a90e-3d55c917c9c3.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要特别提一下 &lt;strong&gt;异或门&lt;/strong&gt;，我们需要先知道有一种电子元器件可以利用电气特性对 &lt;strong&gt;输入取反&lt;/strong&gt;，也就是说输入 &lt;code&gt;1&lt;/code&gt; 则输出 &lt;code&gt;0&lt;/code&gt;，输入 &lt;code&gt;0&lt;/code&gt; 则输出 &lt;code&gt;1&lt;/code&gt;，那么我们就可以 &lt;strong&gt;简单模拟&lt;/strong&gt; 出异或门逻辑电路（实际会更复杂些，这里仅展示出异或的意思）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/14532d29-f949-4b9a-9e36-bc5065718269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A'&lt;/code&gt; 和 &lt;code&gt;B'&lt;/code&gt; 分别表示 &lt;code&gt;A&lt;/code&gt; 和 &lt;code&gt;B&lt;/code&gt; 开关的反值，从图中我们很容易知道只有当 &lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt; 只存在一个输入 &lt;code&gt;1&lt;/code&gt; 时，整个电路才会输出 &lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;利用逻辑门简单计算加法&quot;&gt;利用逻辑门简单计算加法&lt;/h2&gt;
&lt;p&gt;OK，上面我们了解到我们能够利用 &quot;开关&quot; 来模拟逻辑的运算，我们接下来试着还原一个简单的加法运算器是如何实现的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/aacd0c7c-de35-4f98-8b5d-318603173491.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仅需两个门，就可以完成基本的二进制加法运算。上图是利用 &lt;code&gt;logic.ly&lt;/code&gt; 创建的半加法器，&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt; 相当于使我们计算的两个数，最后一块相当于是我们的数显芯片，它的功能是根据输入显示数字，从上到下的引脚（也就是图中输入的地方，通常我们这样称呼）分别对应了 &lt;strong&gt;2&lt;sup&gt;0&lt;/sup&gt;=1&lt;/strong&gt;、&lt;strong&gt;2&lt;sup&gt;1&lt;/sup&gt;=2&lt;/strong&gt;、&lt;strong&gt;2&lt;sup&gt;2&lt;/sup&gt;=4&lt;/strong&gt;、&lt;strong&gt;2&lt;sup&gt;3&lt;/sup&gt;=8&lt;/strong&gt; 的输入，没有任何输入时显示为 &lt;code&gt;0&lt;/code&gt;，如果 &lt;code&gt;引脚 1&lt;/code&gt;（对应 &lt;strong&gt;2&lt;sup&gt;0&lt;/sup&gt;=1&lt;/strong&gt;）像上图一样有输入，则显示 &lt;code&gt;0 + 1 = 1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们来理解一下上方的电路：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果仅打开一个输入，但不同时打开两个输入，则此处的 XOR 门（异或门）将打开，此时对应输入 &lt;code&gt;引脚 1&lt;/code&gt;，显示 &lt;code&gt;数字 1&lt;/code&gt;（类似于 &lt;code&gt;1 + 0 和 0 + 1&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;如果两个输入均打开，则 AND 门(与门)将打开，此时对应输入 &lt;code&gt;引脚 2&lt;/code&gt;，显示 &lt;code&gt;数字 2&lt;/code&gt;（类似于 &lt;code&gt;1 + 1&lt;/code&gt;）；&lt;/li&gt;
&lt;li&gt;如果没有输入，则 AND 门和 XOR 门都保持关闭，此时显示 &lt;code&gt;数字 0&lt;/code&gt;（类似于 &lt;code&gt;0 + 0&lt;/code&gt;）；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此，如果两个都打开，则 XOR 保持关闭，并且 AND 门打开，得出正确的答案为 &lt;code&gt;2&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/0e9af4ae-e1ab-4e20-be70-937d0b31ece4.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但这只是最基础的半加法运算器，不是太有用，因为它只能解决最简单的数学问题之一。但如果我们把它们两个与另一个输入连接，就会得到一个完整的加法器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/7e3ac4f0-f7f8-4d89-9c7c-004b2b6ef477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细思考几遍，你就会得知这个三个输入的加法器已经可以计算 &lt;code&gt;3&lt;/code&gt; 个二进制数字的加法运算了，我们如法炮制，可以通过连接更多的&quot;进位&quot;来使这个加法器能够运算更多的数，这当然也意味着这个计算链条更长。&lt;/p&gt;
&lt;p&gt;大多数其他数学运算都可以加法完成。乘法只是重复加法，减法可以通过一些奇特的位反转来完成，而除法只是重复减法。并且，尽管所有现代计算机都具有基于硬件的解决方案以加快更复杂的操作，但从技术上讲，您可以使用完整的加法器来完成全部操作。&lt;/p&gt;
&lt;h2 id=&quot;总线和内存&quot;&gt;总线和内存&lt;/h2&gt;
&lt;p&gt;现在，我们的计算机只不过是一个计算器，它记不住任何内容也对输出没有任何操作，上述电路只是接了一个显示单元而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/c4aefa87-3291-4158-a5e4-bf4e5e36d82b.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面展示的是一个存储单元。它使用了大量的 NAND 门，并且在实际生产中，根据存储技术的不同，它们可能会大不相同，但其功能是相同的。&lt;/p&gt;
&lt;p&gt;您给它一些输入，并打开“写”位（&lt;code&gt;Write&lt;/code&gt; 输入 &lt;code&gt;1&lt;/code&gt;），它将把输入存储在单元内。这不仅是一个存储单元，因为我们还需要一种从中读取信息的方法。这是通过一个使能器完成的，该使能器是「存储器」中每个位的“与”门的集合，所有位都与另一个输入（即“读取”位）绑定在一起。写入和读取位通常也称为“设置”(&lt;code&gt;set&lt;/code&gt;)和“启用”(&lt;code&gt;enable&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;上面整个存储单元都包裹在所谓的寄存器中。这些寄存器连接到 &lt;strong&gt;总线&lt;/strong&gt;，总线是围绕整个系统运行的一束电线，并连接到每个组件。即使现代计算机也具有总线，尽管它们可能具有多个总线以提高多任务处理性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/30885f0a-ca29-4942-96bb-4d1b6727e651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个寄存器仍有一个读写位，但是在这种设置下，输入和输出是一样的。这实际上很好。例如：如果要将 R1 的内容复制到 R2，则应打开 R1 的读取位，这会将 R1 的内容压入总线。当读取位打开时，您将打开 R2 的写入位，这会将总线内容复制到 R2 中。&lt;/p&gt;
&lt;p&gt;寄存器也用于制作 RAM。RAM 通常布置在网格中，并且导线有两个方向：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/9a164cca-3268-4cf4-b9ea-e89d1798f14f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解码器采用二进制输入并打开相应的编号线。例如，&lt;code&gt;11&lt;/code&gt; 在二进制数中是 &lt;code&gt;3&lt;/code&gt;，即最高的 &lt;code&gt;2&lt;/code&gt; 位数字，因此解码器将打开最高的线路。每个路口都有一个寄存器。所有这些都连接到中央总线以及中央写入和读取输入。只有跨寄存器的两条导线也都打开时，读和写输入才会打开，从而有效地允许您选择要从中进行读写的寄存器。同样，现代 RAM 要复杂得多，但是此设置仍然有效。&lt;/p&gt;
&lt;h2 id=&quot;时钟，步进器和解码器&quot;&gt;时钟，步进器和解码器&lt;/h2&gt;
&lt;p&gt;寄存器无处不在，是在 CPU 中移动数据并将信息存储在 CPU 中的基本工具。那么，是什么告诉他们移动数据的呢？&lt;/p&gt;
&lt;p&gt;时钟是 CPU 核心中的第一个组件，它将按设置的时间间隔（以赫兹或每秒周期为单位）关闭和打开。这就是您看到的最直观的 CPU 速度指标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/64edfb0a-8965-4922-8a16-05fe368125d0.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时钟具有三种不同的状态：基本时钟，使能时钟和设置时钟。基本时钟将打开半个周期，另一半关闭。使能时钟用于打开寄存器，并且需要更长的时间才能确保数据被使能。设置时钟必须始终与使能时钟同时打开，否则可能会写入错误的数据。&lt;/p&gt;
&lt;p&gt;时钟连接到步进器，步进器将从 &lt;code&gt;1&lt;/code&gt; 到最大步数进行计数，并在完成后将自身重置为 &lt;code&gt;1&lt;/code&gt;。时钟还连接到 CPU 可以写入的每个寄存器的 AND 门：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/23ee10b5-2222-4bdd-b9bf-f9e132165b9e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些 “与” 门还连接到另一个组件的输出，即指令解码器。指令解码器接受 &lt;code&gt;SET R2 TO R1&lt;/code&gt; 之类的指令，并将其解码为 CPU 可以理解的内容。它有自己的内部寄存器，称为“指令寄存器”，该寄存器存储了当前操作。它的精确程度取决于您正在运行的系统，但是一旦解码，它将打开正确的设置并启用正确寄存器的位，这些寄存器将根据时钟触发。&lt;/p&gt;
&lt;p&gt;程序指令存储在 RAM（或现代系统中的 L1 高速缓存，更靠近 CPU）中。由于程序数据与其他所有变量一样都存储在寄存器中，因此可以随时对其进行操作以在程序中跳转。这就是程序通过循环和 &lt;code&gt;if&lt;/code&gt; 语句获取结构的方式。跳转指令将指令解码器正在读取的存储器中的当前位置设置到其他位置。&lt;/p&gt;
&lt;h2 id=&quot;一切如何配合&quot;&gt;一切如何配合&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/68f6b4f3-0a10-4598-9194-64c39159cdff.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，我们对 CPU 工作原理的有了一些基本的了解。主总线跨越整个系统，并连接到所有寄存器。完整的加法器以及其他一系列运算都打包在算术逻辑单元或 ALU 中。该 ALU 将与总线建立连接，并且还将具有自己的寄存器来存储正在操作的第二个数字。&lt;/p&gt;
&lt;p&gt;为了执行计算，将程序数据从系统 RAM 加载到控制部分。控制部分从 RAM 中读取两个数字，将第一个数字加载到 ALU 的指令寄存器中，然后将第二个数字加载到总线上。同时，它向 ALU 发送指令代码，告知其操作方法。然后，ALU 执行所有计算，并将结果存储在另一个寄存器中，CPU 可以从该寄存器中读取该值，然后继续该过程。&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;原来，我们是这样记数的 - &lt;a href=&quot;https://www.jianshu.com/p/58844323e4fb&quot;&gt;https://www.jianshu.com/p/58844323e4fb&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;二进制数的运算方法 - &lt;a href=&quot;https://www.jianshu.com/p/560aba49c9a4&quot;&gt;https://www.jianshu.com/p/560aba49c9a4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;文字,图片,视频,音频的二进制表示 - &lt;a href=&quot;https://blog.csdn.net/c46550/article/details/91040925&quot;&gt;https://blog.csdn.net/c46550/article/details/91040925&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;知乎 - 计算机只认识0和1但是怎么表示图像和影视等等众多应用的？ | @kross - &lt;a href=&quot;https://www.zhihu.com/question/36269548&quot;&gt;https://www.zhihu.com/question/36269548&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Introduction to binary numbers - &lt;a href=&quot;https://pmihaylov.com/intro-binary-numbers/&quot;&gt;https://pmihaylov.com/intro-binary-numbers/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;What is Binary, and Why Do Computers Use It? - &lt;a href=&quot;https://www.howtogeek.com/367621/what-is-binary-and-why-do-computers-use-it/&quot;&gt;https://www.howtogeek.com/367621/what-is-binary-and-why-do-computers-use-it/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CPU 是怎样认识代码的？ | 知乎 - &lt;a href=&quot;https://www.zhihu.com/question/348237008/answer/843382847&quot;&gt;https://www.zhihu.com/question/348237008/answer/843382847&lt;/a&gt; | @Zign&lt;/li&gt;
&lt;li&gt;HTG Explains: How Does a CPU Actually Work? - &lt;a href=&quot;https://www.howtogeek.com/367931/htg-explains-how-does-a-cpu-actually-work/&quot;&gt;https://www.howtogeek.com/367931/htg-explains-how-does-a-cpu-actually-work/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.wmyskxz.com/2020/04/02/morethanjava-dang-da-xue-xuan-ze-liao-ji-suan-ji-zhi-hou-ying-gai-zhi-dao-de/&quot;&gt;「MoreThanJava」当大学选择了计算机之后应该知道的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.wmyskxz.com/2020/04/07/morethanjava-ji-suan-ji-fa-zhan-shi-cong-zhi-bu-ji-dao-ibm/&quot;&gt;「MoreThanJava」计算机发展史—从织布机到IBM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.wmyskxz.com/2020/06/01/morethanjava-ji-suan-ji-xi-tong-gai-shu/&quot;&gt;「MoreThanJava」计算机系统概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.wmyskxz.com/2020/03/25/dong-yi-dian-python-xi-lie-kuai-su-ru-men-1/&quot;&gt;妈妈再也不担心我面试被Redis问得脸都绿了&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;本文已收录至我的 Github 程序员成长系列 &lt;strong&gt;【More Than Java】，学习，不止 Code，欢迎 star：&lt;a href=&quot;https://github.com/wmyskxz/MoreThanJava&quot;&gt;https://github.com/wmyskxz/MoreThanJava&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;个人公众号&lt;/strong&gt; ：wmyskxz，&lt;strong&gt;个人独立域名博客&lt;/strong&gt;：wmyskxz.com，坚持原创输出，下方扫码关注，2020，与您共同成长！&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/ace97ed9-3cfd-425f-85e5-c1a1e5ca7d3f.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;非常感谢各位人才能 &lt;strong&gt;看到这里&lt;/strong&gt;，如果觉得本篇文章写得不错，觉得 &lt;strong&gt;「我没有三颗心脏」有点东西&lt;/strong&gt; 的话，&lt;strong&gt;求点赞，求关注，求分享，求留言！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
</description>
<pubDate>Tue, 02 Jun 2020 00:37:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<og:description>「MoreThanJava」 宣扬的是 「学习，不止 CODE」，本系列 Java 基础教程是自己在结合各方面的知识之后，对 Java 基础的一个总回顾，旨在 「帮助新朋友快速高质量的学习」。 当然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wmyskxz/p/13029117.html</dc:identifier>
</item>
<item>
<title>读懂操作系统之虚拟内存地址翻译原理分析篇（二） - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/12989991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/12989991.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;上一节我们整体概括通过MMU将虚拟地址翻译为物理地址的转换，这个过程都是按序就班的进行，一切都是基于已提前创建、分配虚拟页、物理页以及命中的前提，只是给和我一样没怎么系统学习操作系统的童鞋首先在脑海里有个大概的印象，本节我们从源头开始分析为程序创建进程到映射到主存上整个详细过程，本文将通过大量图解来分析原理，以便让各位能够完全理解地址翻译原理。若有叙述不当之处，还请批评指正。 &lt;/p&gt;
&lt;h2&gt;虚拟内存原理分析&lt;/h2&gt;
&lt;p&gt;如果没有系统学习现代操作系统，理论上我们会认为用户程序会将内存视为单个连续的内存空间，实际上可以将用户程序在内存中分布可以分散在页面的整个物理内存中。&lt;span&gt;分页是一种内存管理方案，它允许进程的物理地址空间不连续。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;物理内存划分：将物理内存划分为称为帧的固定大小的块（大小为2的幂，介于512字节和16 MB之间，必须跟踪所有空闲帧）&lt;/p&gt;
&lt;p&gt;虚拟（逻辑）内存划分：将逻辑内存分成大小相同的块（称为页，每一块也是分为相同大小的页面）&lt;/p&gt;
&lt;p&gt;若要运行大小为N页的程序，需要找到N个空闲帧并加载程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;地址翻译方案&lt;/h3&gt;
&lt;p&gt;通过常驻内存中的页表将虚拟地址翻译为物理地址， CPU生成的虚拟地址被划分为虚拟页号（用作页表索引，该页表包含物理内存中每个页的基地址）和虚拟页偏移量（与基址结合找到存储单元的物理存储地址）。对于给定的逻辑地址空间2&lt;sup&gt;m&lt;/sup&gt;和页面大小2&lt;sup&gt;n&lt;/sup&gt;，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200530115043881-723365561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分页内存管理方案本质就是通过MMU将CPU产生的虚拟地址通过中间媒介（页表）进行地址翻译，如下为简单翻译版本，一目了然。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200530121713953-1926792230.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述我们学习了将逻辑地址（虚拟地址）划分为页号（注意：页号并不属于页表的一部分，页号不储存在主存）和页偏移量，到底是怎样借助页号和页偏移量进行翻译的呢？我们举个例子：假设如下一个32字节的物理内存，逻辑地址空间为16字节，说明逻辑地址有4位，而页帧偏移量为4个字节，因页帧偏移量和虚拟页偏移量相等，所以虚拟页偏移量也为4个字节即2位，所以页号为（4-2）= 2位即逻辑地址共有4页，如此假设和实际理论计算对等。地址翻译如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200530132612198-1057677651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若CPU要找出逻辑地址为4的物理地址，通过上述我们知道逻辑地址为4在第1页且偏移量为0，然后去查找页表索引等于1的页帧号为6，因为物理地址 = （frame * pageSize）+ offset，所以逻辑地址4的物理地址=（6 * 4 bytes）+ 0 byte offset = 24。同理，比如如上逻辑地址为7在第1页，偏移量为3对应页表上的帧6，所以其物理地址为：（6 * 4 bytes）+ 3 byte offset = 27，这里需要注意的是物理地址的偏移量是相对这页的起始位置偏移。通过上述图解，我们反推根据逻辑地址和每页字节大小计算出其所在页和偏移量（下面根据虚拟地址计算虚拟页号和偏移量会用到），比如逻辑地址为7，因每页大小为4个字节，则所在页为（7 / 4） = 1，偏移量（7 mod / 4） = 3。&lt;/p&gt;
&lt;h3&gt;扩展页表条目（PTE）信息&lt;/h3&gt;
&lt;p&gt;现代计算机页表上的条目除了包含将虚拟地址翻译为虚拟地址的主要信息（有效位、页号）外，其中还包含如下其他信息（下面讲解页面置换算法会用到）：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;保护位（Protection）：控制对指定虚拟页的访问是否可读、可写、可执行&lt;/p&gt;
&lt;p&gt;引用位（Refrence）：为了近似实现LRU算法，帮助操作系统估算最近最少使用的页，当一页被访问时该位将被置位，操作系统定期将引用位清零，然后重新记录，这样就可以判定在这段特定时间内哪些页被访问过，通过检查引用位是否关闭，操作系统就可以从那些最近最少访问的页中选择一页&lt;/p&gt;
&lt;p&gt;脏位（Modify）：当某一页被替换时，操作系统需要知道该页是否需要被复制写回，为了追踪读入主存中的页是否被写过，增加一个脏位，当页中任何字被写时就将这一位置位。如果操作系统选择替换某一页，脏位指明了把该页所占用的主存让给另一页之前，是否需要将该页写回磁盘，因此，一个被修改的页通常被称为脏页。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200530212303894-615297386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;TLB缓存页表&lt;/h3&gt;
&lt;p&gt;上一节我们讲过CPU产生逻辑地址后通过MMU转换为物理地址时，每次都要访问页表，访问缓存和主存的时间相差上百个时钟周期，所以为了提高查找性能则使用TLB，我们可认为TLB是实现页表最好的方式，本质上是缓存页表。在没有TLB作为缓存时，我们使用页号（VPN）作为索引去页表上查找物理页号，引入TLB后，将页号划分为TLBT（TLB标记）和TLBI（TLB索引）只是做了一下转换而已，TLBI占2位，剩余的位就是TLBT。下面会通过一个实际例子来讲解如何结合TLBT和TLBI在TLB上查找。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531123440070-1952227667.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TLB作为页表的缓存，用于存放映射到页帧中的那些项，TLB包含了页表中虚拟页到页帧映射的一个子集，因为将其作为缓存，所以额外还存在如上一个标记区域（TLBT），换句话说页表不同于TLB并不是作为缓存，所以并不需要标记区域，再加上如上额外的PTE扩展信息，所以TLB的存储结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531124921508-1932020257.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;TLB缺失&lt;/h3&gt;
&lt;p&gt;接下来我们开始进入TLB缺失环节，我们假设虚拟地址有14位，物理地址有16位，每页大小有64个字节，那么虚拟地址空间和物理地址空间如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531125602896-774586892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为每页大小为64字节即（2&lt;sup&gt;6&lt;/sup&gt;），同时虚拟页偏移量和页帧偏移量相等，所以虚拟页偏移量和页帧偏移量都为6位，那么将虚拟地址空间和物理地址空间划分为对应的页号和页偏移量则如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531125830435-599470109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来则是将虚拟页号划分为TLBT和TLBI，因为TLB包含16个条目且4路关联，那么说明有S =（16 / 4）= 4组，那么TLBI占位 =  log&lt;sub&gt;2&lt;sup&gt;S = 2&lt;/sup&gt;&lt;/sub&gt;，剩余的则是TLBT = （8 - 2） = 6位，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531130615150-322033478.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在我们对虚拟地址和物理地址都有了完整的划分，现在假设TLB和页表状态存储结构分别如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531130804909-1601798012.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531130908226-455639995.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设现在CPU产生一个虚拟地址（0x0334），首先我们需要将其转换为虚拟页号（VPN），因每个页面大小为64字节，所以计算方式如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; xvpn = Convert.ToInt32(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0x334&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;16&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; vpn = xvpn / &lt;span&gt;64&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;vpn = 12&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; vpo = xvpn % &lt;span&gt;64&lt;/span&gt;; &lt;span&gt;//vpo&lt;/span&gt;&lt;span&gt; = 52&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述计算出VPN等于12，然后将其对应虚拟地址上的VPN和VPO用二进制表示，分别如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531132010961-777281098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而存储在TLB和页表上的状态都是16进制，所以上述VPN = 12&lt;sub&gt;10&lt;/sub&gt; = 0x0C&lt;sub&gt;16&lt;/sub&gt;和VPO = 52&lt;sub&gt;10&lt;/sub&gt; = 0x34&lt;sub&gt;16&lt;/sub&gt;，到此已经划分完VPN和VPO，接下来则是将VPN划分为TLBT和TLBI，由上述我们已经知道TLBT和TLBI在VPN中所占位数，所以如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531132645432-702663181.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上我们可得出TLBT = 3&lt;sub&gt;10&lt;/sub&gt; = 0x03&lt;sub&gt;16&lt;/sub&gt;，而TLBI = 0，有了TLBT（0x03）和TLBI（0）再去查找TLB状态表，如下红色标记&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531132901965-1370539413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图我们发现此时标志无效而且物理页号也没有，此时发生TLB缺失，于是通过MMU将虚拟地址得到的VPN去页表中查找&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531133114098-1040743488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们看到在页表中也缺失，所以这里将发生缺页异常。TLB缺失分为如下两种情况&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;页在主存（页表）中，只需要创建缺失的TLB表项&lt;/p&gt;
&lt;p&gt;页不在主存（页表）中，需要将控制权交给操作系统来解决缺页 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;TLB缺失既可以通过软件处理也可以通过硬件处理，比如MIPS、Alpha通过软件处理TLB缺失，x86、ARM通过硬件处理TLB缺失，两种处理方式在性能差别上很小，无论哪一种方式需要执行的基本操作都是一样的&lt;/span&gt;。理论上来讲，在进程分配页帧时会将对应页帧更新到页表上，但是上述情况并未在主存页表中说明在页帧列表中没有空闲的页帧，所以这是TLB缺失中真正的缺页情况，此时将触发缺页异常，控制权交给操作系统内核中的缺页异常处理程序，操作系统知道了引起缺页的虚拟地址，操作系统必须完成以下3个步骤：【1】&lt;span&gt;使用虚拟地址查找页表项，并在磁盘上找到被访问的页的位置&lt;/span&gt;【2】&lt;span&gt;选择替换一个物理页&lt;/span&gt;&lt;span&gt;，如果该选中的页被修改过，需要在把新的虚拟页装入之前将这个物理页写回磁盘，这一过程称为页面置换&lt;span&gt;【3】&lt;span&gt;启动读操作，将被访问的页从磁盘上取回到所选择的物理页的位置上&lt;/span&gt;【4】&lt;span&gt;重新执行引发缺页的那条指令。&lt;span&gt;因为第3个步骤需要耗费数百万个时钟周期，如果第2个步骤中被替换的物理页已被重写过，那么同样也会花费这么长时间，因此操作系统会选择另外一个进程在处理器上执行直到磁盘访问结束，所以前3个步骤执行所耗费的时间比较长，最后重新执行缺页指令。&lt;/span&gt;&lt;/span&gt;若在页表中找到了页帧号（即页在主存中），那说明TLB缺失只是一次转换缺失，在这种情况下，CPU只需要将页表项装载到TLB并且重新访问来进行缺失处理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;页面置换算法&lt;/h2&gt;
&lt;p&gt;为了解决缺页情况，所以必须实现页面置换作为请求调页的基础，这里我们介绍常见的几种置换算法，分别是Optional or MIN algorithm、FIFO(First-In-First-Out)、Clock、LRU(Least Recently Used)，针对各个算法，现假设有（1、2、3、4、1、2、5、1、2、3、4、5）12个引用串，4个空闲页帧。&lt;/p&gt;
&lt;h3&gt;FIFO（先进先出）&lt;/h3&gt;
&lt;p&gt;该算法记录了每个页面记录调到内存的时间，当必须置换页面时，将选择最旧的页面，请注意，并不需要记录调入页面的确切时间，可以通过创建一个队列实现此目的。具体过程太过简单，这里就不再细讲，此时将发生10次缺页错误，我们可计算出缺页率为（10/12）= 83%。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531171602124-741312736.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h3&gt;OPT or MIN(最优)&lt;/h3&gt;
&lt;p&gt;最优置换算法找出最长时间没有使用的页，具有最低缺页率，可以用作离线分析方法，但是难以实现。此时将发生6次缺页错误，我们可计算出缺页率为（6/12）= 50%。如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531174354014-1130137955.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;LRU（最近最少使用）&lt;/h3&gt;
&lt;p&gt;FIFO算法使用的是页面调入内存的时间，OPT算法使用的是页面将来使用的时间，而LRU算法采用置换最长时间没有的页，该算法将每个页面与它上次使用的时间关联起来，当需要置换页面时，LRU选择最长时间没有使用的页面，该算法很难实现。此时将发生8次缺页错误，我们可计算出缺页率为（8/12）= 67%。如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200531173138775-656017140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;启动和切换进程&lt;/h2&gt;
&lt;p&gt;上述我们只是从已经将程序加载到内存中所创建的进程角度来分析如何将虚拟地址翻译为物理地址，由于操作系统负责管理内存，因此必须了解物理内存的分配详细信息，分配了哪些页帧、每个页帧分配个哪个进程的哪个页面，哪些页帧可用，总共有多少帧，对此我们还一无所知。将用户程序加载到虚拟内存中的进程后为其划分对应的虚拟页，假设如下划分了4个虚拟页，操作系统在跟踪的页帧列表找出空闲（操作系统分配帧算法，这里暂不讨论）的页帧分配给虚拟页，然后操作系统再启动进程。如下图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202005/589642-20200530154025174-1053388024.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上节所述页表保存在主存中，当调度进程时通过页表基址寄存器（PTBR）指向激活的指定进程页表， 当然也会加载另外一个寄存器（程序计数器，PC），所以每个数据或指令访问需要进行两次主存访问，一次是页表，另一次则是用于数据或指令。&lt;/p&gt;

&lt;p&gt;当进程希望以受限的方式共享信息时，操作系统必须对其进行协助，这是因为访问另外一个进程的信息需要改变访问进程的页表，写访问位可以用来把共享限制为只读，并且和页表中其他位一样，该位只能被操作系统所修改。为了允许另一进程，设为P1，去读属于进程P2的一页，P2就要请求操作系统在P1地址空间中为一个虚拟页生成页表项，指向P2想要共享的物理页。如果P2要求操作系统可以使用写保护位以防止P1对数据进行改写，由于只有TLB缺失才会访问页表，任何决定页对的访问权限不仅要包含在页表中，还要包含在TLB中。当操作系统决定从进程P1切换到P2时，我们称之为上下文切换，它必须保证P2不能P1的页表，否则不利于数据保护，若没有TLB，只需要把页表基址寄存器指向P2的页表而不是P1就够了，如果有TLB，我们必须在其中清除属于P1的表项，不仅仅是为了保护P1的数据，而且是为了迫使TLB装入P2的表项。如果进程切换的频率很高，那么这一举措效率将会很低。例如，在操作系统切回P1之前，P2可能只装入了很少的TLB表项，但是，P1随后发现它所有的表项都不见了，因此不得不通过TLB缺失来重新加载这些表项，产生这个问题的原因在于进程P1和P2使用同一虚拟地址空间，并且我们必须清除TLB以防止地址混淆。另一种常见的方法则是增加进程标识符和任务标识符来扩展虚拟地址空间，比如FastMATH就有8位地址空间标识域（ASID），这个标识域标识了当前正在运行的进程，当进程切换时，它保存在由操作系统装入的寄存器中，进程标识符与TLB的标记部分相连接，因此只有在页号和进程标识符相匹配时，TLB才会发生命中，如此一来，除非特殊情况，我们就不需要清除TLB。 说了怎么多除了保护机制外，当我们切换进程时主要需要做哪些工作呢（即从一个进程控制块（Process Control Block，PCB）切换到另一个进程块，后续会深入讲解操作系统线程和进程）？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;切换页表到当前PCB&lt;/p&gt;
&lt;p&gt;页表基址寄存器指向当前页表&lt;/p&gt;
&lt;p&gt;清除TLB，并将当前页表项装载到TLB（按需加载，进程访问哪些页才将对应页表项加载到TLB）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;留个作业&lt;/h2&gt;
&lt;p&gt;若TLB中的PTE条目达到上限即满时，不难想象理论上会替换现有条目，那么采取替换的策略或机制是怎样的呢？&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;基于上一节内容我们详细讲解了将虚拟地址翻译为物理地址的具体过程、进程页帧分配、页面置换算法，在讲解TLB缺失时并未涉及高速缓存，TLB和高速缓存将在下一节作为详解。关于虚拟内存内容通过一两篇文章根本讲解不清楚，比如还有减少页表容量方式、TLB和高速缓存关系、Intel和Linux虚拟内存系统等等。我尽量通过图解方式来带给大家较好的理解体验，能够更好的消化和吸收虚拟内存。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Jun 2020 00:28:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 上一节我们整体概括通过MMU将虚拟地址翻译为物理地址的转换，这个过程都是按序就班的进行，一切都是基于已提前创建、分配虚拟页、物理页以及命中的前提，只是给和我一样没怎么系统学习操作系统的童鞋首先在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/12989991.html</dc:identifier>
</item>
<item>
<title>【asp.net core 系列】2 控制器与路由的恩怨情仇 - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/13029067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/13029067.html</guid>
<description>&lt;p&gt;在上一篇文章中，我们初步介绍了asp.net core，以及如何创建一个mvc项目。从这一篇开始，我将为大家展示asp.net core 的各种内容，并且尝试带领大家来挖掘其中的内在逻辑。&lt;/p&gt;
&lt;p&gt;当然，那是以后的事情。这一篇将通过自定义一个控制器来为大家介绍asp.net core mvc 中控制器和路由的相关知识。&lt;/p&gt;

&lt;p&gt;先在Controllers目录下添加一个类，名叫：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class DemoController
{
    public string Index()
    {
        return &quot;你好&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:5006/demo/index
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不出意外的话，你应该能看到网页上的&lt;strong&gt;&quot;你好&quot;&lt;/strong&gt;两个字。&lt;/p&gt;
&lt;p&gt;再新建一个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;using Microsoft.AspNetCore.Mvc;
public class NoContrl : Controller
{
    public IActionResult Index()
    {
        return Content(&quot;Test&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合两个不常规的控制器类，让我们初窥asp.net core MVC是如何识别控制器的。这正是我之前说的，约定优于配置最好的体现。这个哲学最早也是为MVC提出来的，后来被.net framework引申到各个方面。&lt;/p&gt;
&lt;p&gt;asp.net core mvc识别控制器，会在项目中发现 以Controller结尾的公开类或者继承自Controller的公开类，并将这些类标记为控制器。当接到用户或者界面转交的请求时，程序从请求路径中解析出控制器名称，然后寻找 &amp;lt;控制器&amp;gt;Controller 或者 &amp;lt;控制器&amp;gt; : Controller 的类。&lt;/p&gt;
&lt;p&gt;在默认情况下，一个访问URL会在程序中解析成如下格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://&amp;lt;HOST&amp;gt;:&amp;lt;PORT&amp;gt;/&amp;lt;Controller&amp;gt;/&amp;lt;Action&amp;gt;[其他参数]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上文中，我们知道了控制器的解析规则，那么现在看一下Action的解析规则：&lt;/p&gt;
&lt;p&gt;在DemoController中添加如下方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public int TestInt()
{
    return 10;
}

public object TestObject()
{
    return new
    {
        Name = &quot;TestObject&quot;,
        Age = 1
    };
}

public string TestPublic()
{
    return &quot;成功访问 TestPublic&quot;;
}

    protected string TestProtect()
{
    return &quot;成功访问 TestProtect&quot;;
}

private string TestPrivate()
{
    return &quot;成功访问 TestPrivate&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新启动，后依次访问如下地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:5006/Demo/TestInt
http://localhost:5006/Demo/TestObject
http://localhost:5006/Demo/TestPublic
http://localhost:5006/Demo/TestProtect
http://localhost:5006/Demo/TestPrivate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后可以看到，TestInt、TestObject以及TestPublic均能正常访问，但TestProtect和TestPrivate都提示找不到网页或无法访问。&lt;/p&gt;
&lt;p&gt;可以看到，对于程序而言，Action就是控制器类里的公开类方法，与方法的返回值无关。也就是说，程序会找到 XXXController 或者名为XXX但继承了Controller的类作为XXX的控制器，然后继续在这个类里寻找到Action，如果没有找到就会返回404的请求。&lt;/p&gt;

&lt;p&gt;在第一节中，我们介绍了一下asp.net core mvc如何寻找控制器和Action，那这一节将介绍程序如何从请求链接中解析出控制器和Action的名称，也就是路由映射。&lt;/p&gt;
&lt;p&gt;路由（Routing）负责匹配传入的HTTP请求，然后将这些请求发送给应用的可执行终结点。终结点是应用的可执行请求处理代码单元，也就是我们控制器里的方法（Action）。&lt;/p&gt;
&lt;h2 id=&quot;21-路由的配置&quot;&gt;2.1 路由的配置&lt;/h2&gt;
&lt;p&gt;对于&lt;strong&gt;所有&lt;/strong&gt;的asp.net core模板都包括生成在代码中的路由。通常，我们要求路由在&lt;code&gt;Startup.Configure&lt;/code&gt;方法中进行配置。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意，Startup类里有且只有一个Configure方法，不能出现其重载版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该方法的声明一般情况如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要设置路由，需要先注明项目启用路由：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;app.UseRouting();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用如下方法配置路由：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;app.UseEndpoints(endpoints =&amp;gt;
{
    // 配置路由
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常对于mvc项目而言，我们一般使用如下方式配置路由：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;endpoints.MapControllerRoute(
    name: &quot;default&quot;,
    pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这行代码的意思是：创建一个名字为 default 的映射控制器的路由，映射规则为 {controller}/{action}/{id?}，也就是第一个为控制器，第二个为Action，第三个是ID，其中ID可以不存在，当Action无法从请求地址中解析出来时默认为Index，控制器默认为Home。&lt;/p&gt;
&lt;p&gt;通过这个解析，我们可以得知 我们之前访问的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:5000/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是哪个控制器里的什么方法来处理了——HomeController.Index。&lt;/p&gt;
&lt;p&gt;那么我们修改一下HomeController.Index来验证一下，我们理解是否有误：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public IActionResult Index()
{
    return View();
}
//  修改为
public IActionResult Index()
{
    return Content(&quot;测试&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新运行程序，访问&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:5000/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后看到页面出现：&lt;strong&gt;测试&lt;/strong&gt;字样，可以看到路由系统自动为我们补全了控制器名和action名。如果方法中出现参数，则自动按照参数名1=值1&amp;amp;参数名2=值2这种形式查看参数。Id为特殊的，会自动按照目录其映射。所以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:5000/控制器1/方法1/id值
http://localhost:5000/控制器1/方法1?id=id值
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是一个请求链接。&lt;/p&gt;
&lt;h2 id=&quot;22-添加路由配置&quot;&gt;2.2 添加路由配置&lt;/h2&gt;
&lt;p&gt;那么，我们回过头来看一下声明路由的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static ControllerActionEndpointConventionBuilder MapControllerRoute(this IEndpointRouteBuilder endpoints, string name, string pattern, object defaults = null, object constraints = null, object dataTokens = null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，我们不会设置 defaults、constraints、dataTokens，这三个参数都有含义，这里不对后两个做介绍，简单介绍一下第一个：&lt;/p&gt;
&lt;p&gt;在路由配置的方法里，添加以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;endpoints.MapControllerRoute(
                    name : &quot;test&quot;,
                    pattern: &quot;DemoTest/{action=Index}/{id?}&quot;,
                    defaults : new 
                    {
                        Controller = &quot;Demo&quot;,

                    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们没有创建名为DemoTest的控制器，但是我们在访问：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;http://localhost:5006/DemoTest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仍然能得到响应，而且控制器被解析为Demo。&lt;/p&gt;
&lt;p&gt;这就是defaults的意义，路由在解析的时候，系统会把defaults中的值自动填充到路由连接中没有设置的值里。&lt;/p&gt;
&lt;p&gt;当我们设置多个路由的时候，路由系统会优先尝试匹配最容易解析的配置。比如说，当我们访问：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:5000/DemoTest/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;的时候，路由系统会优先从名为test的配置表中解析，只有当无法从这里找到时才会从其他路由中解析。&lt;/p&gt;

&lt;p&gt;这一篇我们简单介绍了控制器与路由映射，可以访问我们自己添加的路由。在开发中，通常情况下，创建的控制器都是以Controller结尾并继承Controller类。这是因为Controller类有很多有用的属性和方法供我们使用，以Controller结尾是为了统一规则，可以让我们一眼看出哪些是控制器。&lt;/p&gt;
&lt;blockquote readability=&quot;2.1052631578947&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://www.attachie.club&quot;&gt;我的博客《高先生小屋》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202006/1266612-20200602082208245-970327057.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 02 Jun 2020 00:22:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0. 前言 在上一篇文章中，我们初步介绍了asp.net core，以及如何创建一个mvc项目。从这一篇开始，我将为大家展示asp.net core 的各种内容，并且尝试带领大家来挖掘其中的内在逻辑。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/13029067.html</dc:identifier>
</item>
<item>
<title>MySql轻松入门系列——第一站 从源码角度轻松认识mysql整体框架图 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/13029069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/13029069.html</guid>
<description>&lt;h2 id=&quot;一：背景&quot;&gt;一：背景&lt;/h2&gt;
&lt;h3 id=&quot;1-讲故事&quot;&gt;1. 讲故事&lt;/h3&gt;
&lt;p&gt;最近看各大技术社区，不管是知乎，掘金，博客园，csdn基本上看不到有小伙伴分享sqlserver类的文章，看样子这些年sqlserver没落了，已经后继无人了，再写sqlserver是不可能再写了，这辈子都不会写了，只能靠技术输出mysql维持生活这样子。&lt;/p&gt;
&lt;h2 id=&quot;二：了解架构图&quot;&gt;二：了解架构图&lt;/h2&gt;
&lt;p&gt;mysql最大的好处就是开源， 手握百万源码，有什么问题搞不定呢？ 这一点要比sqlserver爽多了，不用再dbcc捣来捣去。&lt;/p&gt;
&lt;h3 id=&quot;1-从架构图入手&quot;&gt;1. 从架构图入手&lt;/h3&gt;
&lt;p&gt;大家都知道做/装修房子都要有一张图纸，其实软件也是一样，只要有了这么一张图纸，大方向就定下来了，再深入到细节也不会乱了方向，然后给大家看一下我自己画的架构图，画的不对请轻拍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200602082219657-1021694047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实SqlServer，Oracle，MySql架构都大同小异，MySql的鲜明特点就是存储引擎做成了插拔式，这就牛逼了，现行最常用的是InnoDB，这就让我有了一个想法，有一套业务准备用 InMemory 模式跑一下，厉害了~~~&lt;/p&gt;
&lt;h3 id=&quot;2-功能点介绍&quot;&gt;2. 功能点介绍&lt;/h3&gt;
&lt;p&gt;MySql其实就两大块，一块是MySql Server层，一块就是Storage Engines层。&lt;/p&gt;
&lt;h4 id=&quot;1-client&quot;&gt;&amp;lt;1&amp;gt; Client&lt;/h4&gt;
&lt;p&gt;不同语言的sdk遵守mysql协议就可以与mysqld进行互通。&lt;/p&gt;
&lt;h4 id=&quot;2-connectionthread-pool&quot;&gt;&amp;lt;2&amp;gt; Connection/Thread Pool&lt;/h4&gt;
&lt;p&gt;MySql使用C++编写，Connection是非常宝贵的，在初始化的时候维护一个池。&lt;/p&gt;
&lt;h4 id=&quot;3-sqlinterfaceparseoptimizercache&quot;&gt;&amp;lt;3&amp;gt; SqlInterface,Parse,Optimizer,Cache&lt;/h4&gt;
&lt;p&gt;对sql处理，解析，优化，缓存等处理和过滤模块，了解了解即可。&lt;/p&gt;
&lt;h4 id=&quot;4-storage-engines&quot;&gt;&amp;lt;4&amp;gt; Storage Engines&lt;/h4&gt;
&lt;p&gt;负责存储的模块，官方，第三方，甚至是你自己都可以自定义实现这个数据存储，这就把生态做起来了，🐮👃。&lt;/p&gt;
&lt;h2 id=&quot;三：-源码分析&quot;&gt;三： 源码分析&lt;/h2&gt;
&lt;p&gt;关于怎么去下载mysql源码，这里就不说了，大家自己去官网捣鼓捣鼓哈，本系列使用经典的 &lt;code&gt;mysql 5.7.14&lt;/code&gt;版本。&lt;/p&gt;
&lt;h2 id=&quot;1-了解mysql是如何启动监听的&quot;&gt;1. 了解mysql是如何启动监听的&lt;/h2&gt;
&lt;p&gt;手握百万行源码，怎么找入口函数呢？？？ 😁😁😁，其实很简单，在mysqld进程上生成一个dump文件，然后看它的托管堆不就好啦。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200602082219920-1775596169.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看到，入口函数就是 &lt;code&gt;mysqld!mysqld_main+0x227&lt;/code&gt; 中的 &lt;code&gt;mysqld_main&lt;/code&gt;, 接下来就可以在源码中全文检索下。&lt;/p&gt;
&lt;h3 id=&quot;1-mysqld_main-入口函数---sqlmaincc&quot;&gt;&amp;lt;1&amp;gt; mysqld_main 入口函数 =&amp;gt; sql/main.cc&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;
extern int mysqld_main(int argc, char **argv);

int main(int argc, char **argv)
{
  return mysqld_main(argc, argv);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里大家可以用visualstudio打开C++源码，使用查看定义功能，非常好用。&lt;/p&gt;
&lt;h3 id=&quot;2--创建监听&quot;&gt;&amp;lt;2&amp;gt; 创建监听&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;
int mysqld_main(int argc, char **argv)
{
    //创建服务监听线程
    handle_connections_sockets();
}

void handle_connections_sockets()
{
     //监听连接
     new_sock= mysql_socket_accept(key_socket_client_connection, sock,
                                    (struct sockaddr *)(&amp;amp;cAddr), &amp;amp;length);

    if (mysql_socket_getfd(sock) == mysql_socket_getfd(unix_sock))
      thd-&amp;gt;security_ctx-&amp;gt;set_host((char*) my_localhost);

    //创建连接
    create_new_thread(thd);
}

//创建新线程处理处理用户连接
static void create_new_thread(THD *thd){
   
   thd-&amp;gt;thread_id= thd-&amp;gt;variables.pseudo_thread_id= thread_id++;
   
   //线程进了线程调度器
   MYSQL_CALLBACK(thread_scheduler, add_connection, (thd));   
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此mysql就开启了一个线程对 &lt;code&gt;3306&lt;/code&gt; 端口进行监控，等待客户端请求触发 &lt;code&gt;add_connection&lt;/code&gt; 回调。&lt;/p&gt;
&lt;h2 id=&quot;2-理解mysql是如何处理sql请求&quot;&gt;2. 理解mysql是如何处理sql请求&lt;/h2&gt;
&lt;p&gt;这里我以Insert操作为例稍微解剖下处理流程：&lt;/p&gt;
&lt;p&gt;当用户有请求sql过来之后，就会触发 &lt;code&gt;thread_scheduler&lt;/code&gt;的回调函数&lt;code&gt;add_connection&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;
static scheduler_functions one_thread_per_connection_scheduler_functions=
{
  0,                                     // max_threads
  NULL,                                  // init
  init_new_connection_handler_thread,    // init_new_connection_thread
  create_thread_to_handle_connection,    // add_connection
  NULL,                                  // thd_wait_begin
  NULL,                                  // thd_wait_end
  NULL,                                  // post_kill_notification
  one_thread_per_connection_end,         // end_thread
  NULL,                                  // end
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从 &lt;code&gt;scheduler_functions&lt;/code&gt; 中可以看到，add_connection 对应了 &lt;code&gt;create_thread_to_handle_connection&lt;/code&gt;，也就是请求来了会触发这个函数，从名字也可以看出，用一个线程处理一个用户连接。&lt;/p&gt;
&lt;h3 id=&quot;1-客户端请求被-create_thread_to_handle_connection-接管及调用栈追踪&quot;&gt;&amp;lt;1&amp;gt; 客户端请求被 create_thread_to_handle_connection 接管及调用栈追踪&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;
void create_thread_to_handle_connection(THD *thd)
{
     if ((error= mysql_thread_create(key_thread_one_connection, &amp;amp;thd-&amp;gt;real_id, &amp;amp;connection_attrib,
                                     handle_one_connection,(void*) thd))){}
}
//触发回调函数  handle_one_connection
pthread_handler_t handle_one_connection(void *arg)
{
     do_handle_one_connection(thd);
}
//继续处理
void do_handle_one_connection(THD *thd_arg){
    while (thd_is_connection_alive(thd))
    {
      mysql_audit_release(thd);
      if (do_command(thd))  break;  //这里的 do_command 继续处理
    }
}
//继续分发
bool do_command(THD *thd)
{
    return_value= dispatch_command(command, thd, packet+1, (uint) (packet_length-1));
}
bool dispatch_command(enum enum_server_command command, THD *thd, char* packet, uint packet_length)
{
      switch (command) {
         case COM_INIT_DB: ....  break;
         ...
         case COM_QUERY:   //查询语句：  insert xxxx
             mysql_parse(thd, thd-&amp;gt;query(), thd-&amp;gt;query_length(), &amp;amp;parser_state);  //sql解析
           break;
      }
}
//sql解析模块
void mysql_parse(THD *thd, char *rawbuf, uint length, Parser_state *parser_state)
{
      error= mysql_execute_command(thd);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2-到这里它的parse，optimizer，cache都追完了，接下来看sql的curd类型，继续追。。。&quot;&gt;&amp;lt;2&amp;gt; 到这里它的Parse，Optimizer，Cache都追完了，接下来看sql的CURD类型，继续追。。。&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;
//继续执行
int mysql_execute_command(THD *thd)
{
  switch (lex-&amp;gt;sql_command) 
  {
      case SQLCOM_SELECT:  res= execute_sqlcom_select(thd, all_tables);  break;

      //这个 insert 就是我要追的
      case SQLCOM_INSERT:   res= mysql_insert(thd, all_tables, lex-&amp;gt;field_list, lex-&amp;gt;many_values,
                                                      lex-&amp;gt;update_list, lex-&amp;gt;value_list,
                                              lex-&amp;gt;duplicates, lex-&amp;gt;ignore);
  }
}
//insert插入操作处理
bool mysql_insert(THD *thd,TABLE_LIST *table_list,List&amp;lt;Item&amp;gt; &amp;amp;fields, List&amp;lt;List_item&amp;gt; &amp;amp;values_list,
                  List&amp;lt;Item&amp;gt; &amp;amp;update_fields, List&amp;lt;Item&amp;gt; &amp;amp;update_values, 
                  enum_duplicates duplic, bool ignore)
{
      while ((values= its++))
      {
           error= write_record(thd, table, &amp;amp;info, &amp;amp;update);
      }
}
//写入记录
int write_record(THD *thd, TABLE *table, COPY_INFO *info, COPY_INFO *update)
{
    if (duplicate_handling == DUP_REPLACE || duplicate_handling == DUP_UPDATE)
    {
         // ha_write_row  重点是这个函数
         while ((error=table-&amp;gt;file-&amp;gt;ha_write_row(table-&amp;gt;record[0])))
         {
             ....
         }
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，调用链还是挺深的，追到 &lt;code&gt;ha_write_row&lt;/code&gt; 方法基本上算是追到头了，再往下的话就是 &lt;code&gt;MySql Server&lt;/code&gt; 给 &lt;code&gt;Storage Engine&lt;/code&gt;提供的接口实现了，不信的话继续看呗。。。&lt;/p&gt;
&lt;h4 id=&quot;3-继续挖-ha_write_row&quot;&gt;&amp;lt;3&amp;gt; 继续挖 ha_write_row&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;
int handler::ha_write_row(uchar *buf)
{
    MYSQL_TABLE_IO_WAIT(m_psi, PSI_TABLE_WRITE_ROW, MAX_KEY, 0,{ error= write_row(buf); })
}

//这是一个虚方法
virtual int write_row(uchar *buf __attribute__((unused)))
{
    return HA_ERR_WRONG_COMMAND;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到没有，&lt;code&gt;write_row&lt;/code&gt;是个虚方法，也就是给底层方法实现的，在这里就是给各大&lt;code&gt;Storage Engines&lt;/code&gt;的哈。😁😁😁&lt;/p&gt;
&lt;h3 id=&quot;3-调用链图&quot;&gt;3. 调用链图&lt;/h3&gt;
&lt;p&gt;这么多方法，看起来有点懵懵的吧，我来画一张图，帮助大家理解下这个调用堆栈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/214741/202006/214741-20200602082220362-1443514241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三：总结&quot;&gt;三：总结&lt;/h2&gt;
&lt;p&gt;大家一定要熟读架构图，有了架构图从源码中找信息就方便多了，总之学习mysql成就感还是满满的😁。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;如您有更多问题与我互动，扫描下方进来吧&quot;&gt;如您有更多问题与我互动，扫描下方进来吧~&lt;/h3&gt;
&lt;hr/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/214741/202005/214741-20200522143723695-575216767.png&quot; width=&quot;600&quot; height=&quot;200&quot; alt=&quot;图片名称&quot; align=&quot;center&quot;/&gt;</description>
<pubDate>Tue, 02 Jun 2020 00:22:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>一：背景 1. 讲故事 最近看各大技术社区，不管是知乎，掘金，博客园，csdn基本上看不到有小伙伴分享sqlserver类的文章，看样子这些年sqlserver没落了，已经后继无人了，再写sqlser</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangxincheng/p/13029069.html</dc:identifier>
</item>
<item>
<title>一篇文章看清楚 Linux 的职业发展方向 - Coding十日谈</title>
<link>http://www.cnblogs.com/jfzhu/p/13029026.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jfzhu/p/13029026.html</guid>
<description>&lt;p&gt;&lt;strong&gt;手机、汽车、甚至宇宙飞船，在今天的科技世界中，你几乎到处都能看到 Linux 的身影。前两天 SpaceX 成功将宇航员送入太空的猎鹰9号火箭与龙飞船用的也是 Linux的操作系统。身处与 Linux 相关行业的同学还是非常幸运的，行业前景光明、人才需求量大、薪资待遇也水涨船高。当然我们做 Linux 系统维护与开发的同学也是非常辛苦的，正在忙着写命令或者敲代码的同学可以把手中的工作先放一下，和我一起对 Linux 的职业发展前景做一个展望吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200602080605126-1779236198.jpg&quot; alt=&quot;&quot; width=&quot;435&quot; height=&quot;185&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;Linux 的几大职业发展方向&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;按照工作内容，和 Linux 相关的工作主要有以下几个方向：系统运维、应用开发、嵌入式开发、和底层开发。各个方向的工作内容、任职要求、和薪资水平差异都比较大。这里提供的是比较通用的信息，具体的岗位信息和待遇各个公司的情况肯定会有所不同，这里仅供大家参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200602081638609-1402957751.png&quot; alt=&quot;&quot; width=&quot;769&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1、系统运维工程师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）工作职责：主要负责日常 Linux 系统的搭建、部署与运维，排查系统问题、解决系统故障等。系统运维工程师最主要的工作就是保障服务器系统能够正常运行，这里边的系统不单单指 Linux，还包括数据库、Web应用、电子邮件应用、网络应用、J2EE等等。&lt;/p&gt;

&lt;p&gt;2）任职要求：能够熟练掌握 Linux 系统，比如磁盘管理、文件系统管理、权限管理等。熟悉网络，比如 HTTP、TCP/IP 协议、路由、防火墙等。熟练掌握常用软件的安装，比如Nginx、Memcached、Tomcat、Redis等。了解集群、高可用的架构。会写Shell及Python脚本。初入职场的同学也可以考虑考一个红帽 RHCE 的认证。&lt;/p&gt;

&lt;p&gt;3）薪资待遇：一、二线城市，工作 5-10 年的经验，大概是 16-48 万年薪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200602082018116-1735716207.png&quot; alt=&quot;&quot; width=&quot;1148&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、应用软件开发工程师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）工作职责：主要负责公司产品设计、框架制定与研发等。和运维工作相比，对 Linux 系统的要求没有那么高，主要侧重于代码和产品架构。运维工程师需要为软件工程师提供一个可靠的开发、测试和生产环境。Linux系统上的软件开发有很多种，使用的编程语言包括 Java、Python、C++、SQL等（&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12992830.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《2020年你最需要掌握的11种编程语言》&lt;/a&gt;），按应用类别又可分为企业服务应用、大数据应用、桌面应用等等。&lt;/p&gt;

&lt;p&gt;2）任职要求：精通某种编程语言，有开发经验，熟悉 Linux 环境，懂设计模式，熟悉常用的开发框架，了解数据库，能熟练使用应用服务。&lt;/p&gt;

&lt;p&gt;3）薪资待遇：一、二线城市，工作 5-10 年的经验，大概是 12-36 万年薪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200602082038191-1132704229.png&quot; alt=&quot;&quot; width=&quot;1147&quot; height=&quot;397&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Linux嵌入式开发工程师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）工作职责：主要也是负责产品设计、制定框架、和产品代码编写等工作，但主要应用在嵌入式的产品中，比如本文开头提到的手机、汽车、甚至飞船，这里边应用到的都是嵌入式的Linux系统。&lt;/p&gt;

&lt;p&gt;2）任职要求：熟悉 Linux 的 API，比如 IO 操作、进程间通讯、网络通讯等等。精通 Linux内核的配置与编译，精通 C/C++，熟悉主流的嵌入式开发平台，比如 UCOS、FreeRTOS等。&lt;/p&gt;

&lt;p&gt;3）薪资待遇：一、二线城市，工作 5-10 年的经验，大概是 18-46 万年薪。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200602082058063-1954494114.png&quot; alt=&quot;&quot; width=&quot;1159&quot; height=&quot;401&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、Linux底层开发工程师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）工作职责：主要包括 Linux 系统内核以及驱动的开发。岗位难度系数高，但是薪资待遇通常比较好。另外岗位需求量较少，一般大型的硬件企业比如芯片制造商才会有这个岗位。&lt;/p&gt;

&lt;p&gt;2）任职要求：对 Linux 内核源码非常熟悉，精通 C 语言（Linux 内核是用 C 语言编写的 &lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12895692.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux，Unix，GNU 到底有什么样的渊源？》&lt;/a&gt;），精通驱动的开发/移植，懂基本的电路原理与设计。&lt;/p&gt;


&lt;h3&gt;&lt;span&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;通过上面的介绍希望大家都能对自己的职业发展有一个比较清楚的规划，欠缺的知识和技术可以想办法去补足。薪资水平只作为参考，每个人的从业时间长短，和具体岗位的不同对薪资水平的影响都会比较大。关于技术岗位再给几点建议：在某个领域要做深做精，争取成为这个领域的专家；在大的平台、大公司还是可以学到更全面的知识和更新的技术；要多学习、多实践、多尝试新的技术，这样才能慢慢走到别人的前面。&lt;/p&gt;


&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12992830.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《2020年你最需要掌握的11种编程语言》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12992996.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《微软：悬赏10万美金破解 Linux 系统》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12986863.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《安卓到底是不是Linux》&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12978109.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《在 Linux 系统中如何管理 systemd 服务》&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12961694.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《Linux的运行级别与目标》&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/jfzhu/p/12945358.html&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;《软链接 vs. 硬链接》&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;欢迎大家关注我的微信公众号，阅读更多文章，获取更多知识&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/442200/202006/442200-20200602080833500-1464544070.jpg&quot; alt=&quot;&quot; width=&quot;100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;- The End -&lt;/p&gt;

</description>
<pubDate>Tue, 02 Jun 2020 00:10:00 +0000</pubDate>
<dc:creator>Coding十日谈</dc:creator>
<og:description>手机、汽车、甚至宇宙飞船，在今天的科技世界中，你几乎到处都能看到 Linux 的身影。前两天 SpaceX 成功将宇航员送入太空的猎鹰9号火箭与龙飞船用的也是 Linux的操作系统。身处与 Linux</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jfzhu/p/13029026.html</dc:identifier>
</item>
<item>
<title>汉字不能编程？只是看着有点豪横！容易被开除！ - 小傅哥</title>
<link>http://www.cnblogs.com/xiaofuge/p/13029031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofuge/p/13029031.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200505132255596.jpg&quot; alt=&quot;&quot;/&gt;作者：小傅哥&lt;br/&gt;博客：&lt;a href=&quot;https://bugstack.cn&quot;&gt;https://bugstack.cn&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;在编程的路上你是否想过，用汉字写一写代码？&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最近有初学编程的小伙伴问&lt;a href=&quot;https://bugstack.cn&quot;&gt;&lt;code&gt;小傅哥&lt;/code&gt;&lt;/a&gt;，汉字可以写代码吗。自己英文不好，要是汉字可以写代码就好了。难道你要的是&lt;strong&gt;易语言&lt;/strong&gt;？其实并不是，小伙伴也是学习 &lt;code&gt;Java&lt;/code&gt; 的初学者，刚刚学习到 &lt;code&gt;Spring&lt;/code&gt; 看着一片没有注释的代码实在不好理解，要是都是汉字写的，那不和读作文一样了吗！&lt;/p&gt;
&lt;p&gt;说道注释，我想到大部分程序员讨厌的&lt;strong&gt;两件事&lt;/strong&gt;；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不喜欢写注释&lt;/li&gt;
&lt;li&gt;不喜欢别人不写注释&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实对于学习编程来说，初学时写写案例，完成简单的功能，反复练习夯实基础。数学和英文都还并不是你的绊脚石，因为你不需要做复杂的逻辑处理，比如算法。也不需要查阅大量的资料，比如原版的英文资料以及国内没有翻译的技术书籍等。所以这个时候对你来说，只是需要不断的学，不断的写。并逐步强加自己的数学和英文能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回到我们的说的&lt;/strong&gt;，既然你问汉字可以写代码吗。其实在 &lt;code&gt;java&lt;/code&gt; 里，原则上你可以写汉字的&lt;code&gt;类&lt;/code&gt;、&lt;code&gt;属性&lt;/code&gt;、&lt;code&gt;方法&lt;/code&gt;，&lt;code&gt;JVM虚拟机&lt;/code&gt;也是可以通过编译执行的。只是这样的代码并不能很好的维护，甚至说乱码了也很麻烦。再者，有人写方言怎么办！&lt;/p&gt;
&lt;p&gt;好！那么我们接下来就使用汉字的方式来编写一段关于 &lt;code&gt;SpringAop&lt;/code&gt; 的案例！&lt;/p&gt;
&lt;h2 id=&quot;二、开发环境&quot;&gt;二、开发环境&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;JDK 1.8.0&lt;/li&gt;
&lt;li&gt;Spring 4.3.24.RELEASE&lt;/li&gt;
&lt;li&gt;本篇涉及的源码下载，可以关注&lt;strong&gt;公众号&lt;/strong&gt;：&lt;a href=&quot;https://bugstack.cn/assets/images/qrcode.png&quot;&gt;&lt;code&gt;bugstack虫洞栈&lt;/code&gt;&lt;/a&gt; 获取，并且还可以获取更多原创案例。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三、技术实现&quot;&gt;三、技术实现&lt;/h2&gt;
&lt;p&gt;为了这个案例更加真实，我们模拟&lt;code&gt;电影清朝韦小宝时期&lt;/code&gt;，太监入宫的过程。说白了也就是 &lt;code&gt;Spring&lt;/code&gt; 的 &lt;code&gt;AOP&lt;/code&gt; 面向切面，&lt;code&gt;切&lt;/code&gt;的编程。&lt;/p&gt;
&lt;p&gt;在做案例之前，我们先了解一下 &lt;code&gt;AOP&lt;/code&gt; 的基本概念；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;@Aspect&lt;/code&gt;，定义切面的注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut&lt;/code&gt;，切入点，一般会在方法上设定通配符表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Around&lt;/code&gt;，环绕，也就是你原本的方法会在这里处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Before&lt;/code&gt;，前置处理&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@After&lt;/code&gt;，后置处理&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;1-定义切面&quot;&gt;1. 定义切面&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;紫禁城.内务府.敬事房.膑.太监膑.净身监管.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Aspect
@Component
public class 净身监管 {

    @Pointcut(&quot;execution(public * 紫禁城.内务府.敬事房.利器库..*.军刺切(..))&quot;)
    public void 监管员(){

    }

    @Before(&quot;监管员()&quot;)
    public void 敬事前(){
        System.out.println(&quot;敬事前:---------准备下刀... ...&quot;);
    }

    @After(&quot;监管员()&quot;)
    public void 敬事后(){
        System.out.println(&quot;敬事后:---------切面完成... ...&quot;);
    }

    @Around(&quot;监管员()&quot;)
    public Object aroundMethod(ProceedingJoinPoint pjp) throws Throwable {

        System.out.println(&quot;待切身份：&quot;+pjp.getArgs()[0]);
        System.out.println(&quot;执行工具：&quot;+pjp.getSignature().getName());

        //获得传递对象，并做处理
        太监膑 太监 = (太监膑) pjp.getArgs()[0];
        SimpleDateFormat timeFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        太监.set敬事日期(timeFormat.format(new Date()));

        //此处可以传递更改后的参数
        Object obj = pjp.proceed(new Object[]{太监});

        return obj;

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Aspect&lt;/code&gt;，定义切面类，用于处理程序中的切面编程操作。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Pointcut(&quot;execution(public * 紫禁城.内务府.敬事房.利器库..*.军刺切(..))&quot;)&lt;/code&gt;，定义切点处，对那些方法进行执行切面操作。除了这样的操作外，还可以定义成自定义注解。那么后续只要把某个你需要的方法上面添加这样的自定义注解，就可以被 &lt;code&gt;AOP&lt;/code&gt; 拦截。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Before(&quot;监管员()&quot;)&lt;/code&gt;、&lt;code&gt;@After(&quot;监管员()&quot;)&lt;/code&gt;，记录切面执行前后的记录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Around(&quot;监管员()&quot;)&lt;/code&gt;，用于环绕方法增强，可以这里去处理方法中的一些属性信息，比如添加给某个字段添加时间。&lt;em&gt;太监.set敬事日期(timeFormat.format(new Date()));&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2-设置切面可执行方法&quot;&gt;2. 设置切面可执行方法&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;紫禁城.内务府.敬事房.利器库.切除器具.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component(&quot;切除&quot;)
public class 切除器具 {

    public 太监膑 军刺切(太监膑 太监){
        太监.set性别(宦官.太监.name());
        System.out.println(&quot;... 啊 ... ...老子被切面了！&quot;+太监.get姓名());
        return 太监;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这里类的方法就是上面定义的切点，&lt;code&gt;Pointcut&lt;/code&gt;，也就是会被切面处理的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3-执行切面操作类&quot;&gt;3. 执行切面操作类&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;紫禁城.内务府.敬事房.执刀人.张三丰执刀.java&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class 张三丰执刀 {

    public static void main(String[] args) {

        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;皇太极.xml&quot;);

        太监刑 太监行刑 = ctx.getBean(&quot;太监刑&quot;,太监刑.class);

        太监膑 太监 = new 太监膑();
        太监.set姓名(&quot;小德张&quot;);
        太监.set年龄(&quot;9&quot;);
        太监.set性别(宦官.男.name());

        太监 = 太监行刑.执行切除(太监);

        System.out.println(&quot;\r\n切除状态：&quot;+太监);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先这里定义了获取 &lt;code&gt;Spring&lt;/code&gt; 注解的 &lt;code&gt;Application&lt;/code&gt;，用于我们获取 &lt;code&gt;Bean&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;接下来定义一个对象类，主要传递具体参数信息交给执行切面的方法，进行操作。&lt;/li&gt;
&lt;li&gt;最后输出结果信息，也就是我们可以看到具体被切面操作的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四、测试结果&quot;&gt;四、测试结果&lt;/h2&gt;
&lt;h3 id=&quot;1-执行内容&quot;&gt;1. 执行内容&lt;/h3&gt;
&lt;p&gt;启动方法；&lt;code&gt;紫禁城.内务府.敬事房.执刀人.张三丰执刀.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;待切身份：太监膑 [姓名=小德张, 年龄=9, 性别=男, 敬事日期=]
执行工具：军刺切
敬事前:---------准备下刀... ...
... 啊 ... ...老子被切面了！小德张
敬事后:---------切面完成... ...

切除状态：太监膑 [姓名=小德张, 年龄=9, 性别=太监, 敬事日期=2020-05-05]

Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-效果图&quot;&gt;2. 效果图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9idWdzdGFjay5jbi9hc3NldHMvaW1hZ2VzLzIwMjAvQ29kZUd1aWRlLTAxLTEucG5n?x-oss-process=image/format,png&quot; alt=&quot;切面运行效果图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五、总结&quot;&gt;五、总结&lt;/h2&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;汉字编程，好奇可以试试，但别真的用到项目里。本文也只是通过这样的例子，向你展示学习过程的乐趣，建立一些学习过程的好感。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;最近加了很多刚入门学习编程的小伙伴，有很多小问号。比如；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9idWdzdGFjay5jbi9hc3NldHMvaW1hZ2VzLzIwMjAvQ29kZUd1aWRlLTAxLTIucG5n?x-oss-process=image/format,png&quot; alt=&quot;切面运行效果图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我是非常建议先跑起来，多写代码后再慢慢的去探究原理!&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;最近听到一首诗，不错；&lt;code&gt;廿四桥边廿四风，凭栏犹忆旧江东。夕阳返照桃花渡，柳絮飞来片片红。&lt;/code&gt;，白色的柳絮在夕阳桃花的映衬下就是成了&lt;code&gt;片片红&lt;/code&gt;。只要你敢学识渊博，就敢让你拥有翻江倒海之力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;六、彩蛋&quot;&gt;六、彩蛋&lt;/h2&gt;
&lt;blockquote readability=&quot;7.9561128526646&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fuzhengwei/CodeGuide/wiki&quot;&gt;&lt;code&gt;CodeGuide | 程序员编码指南 Go!&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;本代码库是作者小傅哥多年从事一线互联网 Java 开发的学习历程技术汇总，旨在为大家提供一个清晰详细的学习教程，侧重点更倾向编写Java核心内容。如果本仓库能为您提供帮助，请给予支持(关注、点赞、分享)！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200505214424670.png&quot; alt=&quot;CodeGuide | 程序员编码指南&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;七、推荐阅读&quot;&gt;七、推荐阅读&lt;/h2&gt;
</description>
<pubDate>Mon, 01 Jun 2020 23:57:00 +0000</pubDate>
<dc:creator>小傅哥</dc:creator>
<og:description>作者：小傅哥 博客：https://bugstack.cn 沉淀、分享、成长，让自己和他人都能有所收获！&amp;amp;#128540; 一、前言 在编程的路上你是否想过，用汉字写一写代码？ 最近有初学编程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofuge/p/13029031.html</dc:identifier>
</item>
<item>
<title>稳定性五件套-限流的原理和实现 - 编程一生</title>
<link>http://www.cnblogs.com/xiexj/p/13021294.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiexj/p/13021294.html</guid>
<description>&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最近了解到很多朋友对限流、熔断、降级、隔离、超时重试的概念和应用场景理解的不是很到位，所以想用五篇的篇幅稍微系统的介绍一下。&lt;/p&gt;

&lt;p&gt;本篇是第一篇，是限流做详解，如果反馈好的话，我会继续写下面四篇。不好的话就算了，算我理解不够，再自己总结总结。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;限流的概念&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;有朋友问我限流和熔断有什么区别，我的理解很简单。限流作用是&lt;strong&gt;防御上游&lt;/strong&gt;流量超过处理能力的手段，熔断作用是&lt;strong&gt;容错下游&lt;/strong&gt;的快速失败手段。&lt;/p&gt;

&lt;p&gt;举个生活中的限流例子：&lt;/p&gt;

&lt;p&gt;小A最近打算找个女朋友，他拜托了很多朋友帮自己介绍，朋友们也很给力，很多姑娘都愿意和小A聊一聊。小A发现时间忙不开了，他就制定了一个计划，一天见2个。这就是限流。&lt;/p&gt;

&lt;p&gt;举个生活中的熔断例子：&lt;/p&gt;

&lt;p&gt;小A在见这些姑娘的时候，如果有的姑娘不守时，超过约定时间半小时还没有出现，那小A就会离开。不然会耽误见下一位姑娘，这是一种熔断手段。另外，如果有的姑娘特别能说，聊天超过了3小时，小A也会打断姑娘，把姑娘先送走，不然也会耽误见下一位姑娘。这也是需要的熔断措施。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;限流的原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;不管任何编程语言的实现，目前主流的底层就是基于令牌桶算法和漏斗算法。这两种算法达到的效果有所不同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;令牌桶算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;令牌桶算法是先有个固定容量的桶，一个任务会以固定的速率往桶里放token，请求来了会去取token。如果桶满了，token就溢出了。多出来的token就不要了。如果请求太快，token生产速度跟不上消费速率，桶空了，有的请求取不到token，这时候就会直接返回错误而不继续处理。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;p&gt;比如小A最后找到了心仪的女朋友小C。他俩相处融洽，一起包饺子吃。小A负责擀皮，小C负责包。小A会把擀好的皮放到一块案板上。这个案板可以放20张皮。如果皮擀多了，就放不下，这时候小A就会停下来等。如果皮擀的慢，小C没的包，也就只能停下来。这里的皮就相当于是token，包饺子就相当于是处理业务的请求。用图表示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200531203131018-599143080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;漏斗算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;漏斗算法也是先有个固定容量的桶，请求来了先经过桶，从桶里出去的速率是一定的。如果请求量让桶满了，多出来的请求就不处理了。如果桶是空的，新来的请求就能马上处理。&lt;/p&gt;

&lt;p&gt;事实上，各种MQ比如kafka就是典型漏斗算法。broker就是这个固定容量的桶，生产者会不断的将数据写到broker里，消费者是采用的拉取模式，总是以固定的速率来消费。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;令牌桶算法和漏洞算法的比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200531203152538-907077818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;限流的实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;基础实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Java中业界用的比较多的是Google出品的Guava RateLimiter和另外的一款resilience4j-ratelimiter来实现限流。原理差不多。&lt;/p&gt;

&lt;p&gt;下面以RateLimiter为例进行讲解。要实现一个限流总共需要用到RateLimiter的两个方法:&lt;/p&gt;

&lt;p&gt;1&amp;gt;RateLimiter.create() 静态方法创建对象，初始化桶容量&lt;/p&gt;

&lt;p&gt;2&amp;gt;acquire()或者tryAcquire()  获取请求token，两者使用一个即可。acquire方法是阻塞式的，用来实现漏斗算法；tryAcquire是非阻塞式的，用来实现令牌桶算法。&lt;/p&gt;

&lt;p&gt;阻塞式是如果到达指定条件前一直不返回结果，通过下面的源码可看到内部实际上是用sleep来实现的阻塞。因为所有的请求获取权限时都会sleep固定的时间才返回，就达到了匀速的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200531203212960-150740204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;非阻塞是立即返回是否获取到权限(token)。这时候请求如果获取权限成功就处理请求，获取权限失败就直接返回一个自定义的快速失败处理方式。平时请求速率小于token产生速率，桶渐渐满了。一旦有突发流量，因为桶里有存量token，也可以直接获取到权限，就是为什么令牌桶算法可以应对突发流量的原理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;高阶实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面实现里讲的是工具组件，如果只使用工具组件有个问题。限流实际上需要定期进行容量评估，是一个动态的过程，如果只使用工具组件就需要每次修改代码。当然也可以将每个值写到一个统一配置里，比如zookeeper来进行管理。&lt;/p&gt;

&lt;p&gt;如果规模大的情况下更好的一个解决方法是使用专门的平台。这个平台可以支撑更多维度的配置，比如集群维度的限流。集群维度和单机维度的区别是如果设置了一个总的阈值，系统可以根据机器资源情况自动计算出每台机器的限流情况。&lt;/p&gt;

&lt;p&gt;在业界，阿里有个sentinel，有人称为微服务哨兵。它是一套更完整的生态，除了我上面提到的功能之外，还提供了动态系统保护、热点限流等功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1112728/202005/1112728-20200531203234090-1835362656.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 01 Jun 2020 23:57:00 +0000</pubDate>
<dc:creator>编程一生</dc:creator>
<og:description>背景 最近了解到很多朋友对限流、熔断、降级、隔离、超时重试的概念和应用场景理解的不是很到位，所以想用五篇的篇幅稍微系统的介绍一下。 本篇是第一篇，是限流做详解，如果反馈好的话，我会继续写下面四篇。不好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiexj/p/13021294.html</dc:identifier>
</item>
<item>
<title>【Java8新特性】关于Java8中的日期时间API，你需要掌握这些！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13028868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13028868.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Java8之前的日期和时间API，存在一些问题，比如：线程安全的问题，跨年的问题等等。这些问题都在Hava8中的日期和时间API中得到了解决，而且Java8中的日期和时间API更加强大。立志成为架构师的你，必须掌握Java8中的日期和时间API。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;本地时间和时间戳&quot;&gt;本地时间和时间戳&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主要方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;now：静态方法，根据当前时间创建对象&lt;/li&gt;
&lt;li&gt;of：静态方法，根据指定日期/时间创建对象&lt;/li&gt;
&lt;li&gt;plusDays,plusWeeks,plusMonths,plusYears：向当前LocalDate 对象添加几天、几周、几个月、几年&lt;/li&gt;
&lt;li&gt;minusDays,minusWeeks,minusMonths,minusYears：从当前LocalDate 对象减去几天、几周、几个月、几年&lt;/li&gt;
&lt;li&gt;plus,minus：添加或减少一个Duration 或Period&lt;/li&gt;
&lt;li&gt;withDayOfMonth,withDayOfYear,withMonth,withYear：将月份天数、年份天数、月份、年份修改为指定的值并返回新的LocalDate 对象&lt;/li&gt;
&lt;li&gt;getDayOfYear：获得年份天数(1~366)&lt;/li&gt;
&lt;li&gt;getDayOfWeek：获得星期几(返回一个DayOfWeek枚举值)&lt;/li&gt;
&lt;li&gt;getMonth：获得月份, 返回一个Month 枚举值&lt;/li&gt;
&lt;li&gt;getMonthValue：获得月份(1~12)&lt;/li&gt;
&lt;li&gt;getYear：获得年份&lt;/li&gt;
&lt;li&gt;until：获得两个日期之间的Period 对象，或者指定ChronoUnits 的数字&lt;/li&gt;
&lt;li&gt;isBefore,isAfter：比较两个LocalDate&lt;/li&gt;
&lt;li&gt;isLeapYear：判断是否是闰年&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用-localdate、-localtime、-localdatetime&quot;&gt;使用 LocalDate、 LocalTime、 LocalDateTime&lt;/h2&gt;
&lt;p&gt;LocalDate、 LocalTime、 LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注： ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;26&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;now()&lt;/td&gt;
&lt;td&gt;静态方法，根据当前时间创建对象&lt;/td&gt;
&lt;td&gt;LocalDate localDate = LocalDate.now(); LocalTime localTime = LocalTime.now(); LocalDateTime localDateTime = LocalDateTime.now();&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;14&quot;&gt;&lt;td&gt;of()&lt;/td&gt;
&lt;td&gt;静态方法，根据指定日期/时间创建 对象&lt;/td&gt;
&lt;td&gt;LocalDate localDate = LocalDate.of(2016, 10, 26); LocalTime localTime = LocalTime.of(02, 22, 56); LocalDateTime localDateTime = LocalDateTime.of(2016, 10, 26, 12, 10, 55);&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;plusDays, plusWeeks, plusMonths, plusYears&lt;/td&gt;
&lt;td&gt;向当前 LocalDate 对象添加几天、 几周、 几个月、 几年&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;minusDays, minusWeeks, minusMonths, minusYears&lt;/td&gt;
&lt;td&gt;从当前 LocalDate 对象减去几天、 几周、 几个月、 几年&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;plus, minus&lt;/td&gt;
&lt;td&gt;添加或减少一个 Duration 或 Period&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;withDayOfMonth, withDayOfYear, withMonth, withYear&lt;/td&gt;
&lt;td&gt;将月份天数、 年份天数、 月份、 年 份 修 改 为 指 定 的 值 并 返 回 新 的 LocalDate 对象&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getDayOfMonth&lt;/td&gt;
&lt;td&gt;获得月份天数(1-31)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getDayOfYear&lt;/td&gt;
&lt;td&gt;获得年份天数(1-366)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;getDayOfWeek&lt;/td&gt;
&lt;td&gt;获得星期几(返回一个 DayOfWeek 枚举值)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;getMonth&lt;/td&gt;
&lt;td&gt;获得月份, 返回一个 Month 枚举值&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getMonthValue&lt;/td&gt;
&lt;td&gt;获得月份(1-12)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;getYear&lt;/td&gt;
&lt;td&gt;获得年份&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;until&lt;/td&gt;
&lt;td&gt;获得两个日期之间的 Period 对象， 或者指定 ChronoUnits 的数字&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;isBefore, isAfter&lt;/td&gt;
&lt;td&gt;比较两个 LocalDate&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;isLeapYear&lt;/td&gt;
&lt;td&gt;判断是否是闰年&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;示例代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 获取当前系统时间
LocalDateTime localDateTime1 = LocalDateTime.now();
System.out.println(localDateTime1);
// 运行结果：2019-10-27T13:49:09.483

// 指定日期时间
LocalDateTime localDateTime2 = LocalDateTime.of(2019, 10, 27, 13, 45,10);
System.out.println(localDateTime2);
// 运行结果：2019-10-27T13:45:10

LocalDateTime localDateTime3 = localDateTime1
        // 加三年
        .plusYears(3)
        // 减三个月
        .minusMonths(3);
System.out.println(localDateTime3);
// 运行结果：2022-07-27T13:49:09.483

System.out.println(localDateTime1.getYear());       // 运行结果：2019
System.out.println(localDateTime1.getMonthValue()); // 运行结果：10
System.out.println(localDateTime1.getDayOfMonth()); // 运行结果：27
System.out.println(localDateTime1.getHour());       // 运行结果：13
System.out.println(localDateTime1.getMinute());     // 运行结果：52
System.out.println(localDateTime1.getSecond());     // 运行结果：6

LocalDateTime localDateTime4 = LocalDateTime.now();
System.out.println(localDateTime4);     // 2019-10-27T14:19:56.884
LocalDateTime localDateTime5 = localDateTime4.withDayOfMonth(10);
System.out.println(localDateTime5);     // 2019-10-10T14:19:56.884
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;instant-时间戳&quot;&gt;Instant 时间戳&lt;/h2&gt;
&lt;p&gt;用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算 。&lt;/p&gt;
&lt;p&gt;示例代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Instant instant1 = Instant.now();    // 默认获取UTC时区
System.out.println(instant1);
// 运行结果：2019-10-27T05:59:58.221Z

// 偏移量运算
OffsetDateTime offsetDateTime = instant1.atOffset(ZoneOffset.ofHours(8));
System.out.println(offsetDateTime);
// 运行结果：2019-10-27T13:59:58.221+08:00

// 获取时间戳
System.out.println(instant1.toEpochMilli());
// 运行结果：1572156145000

// 以Unix元年为起点，进行偏移量运算
Instant instant2 = Instant.ofEpochSecond(60);
System.out.println(instant2);
// 运行结果：1970-01-01T00:01:00Z
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;duration-和-period&quot;&gt;Duration 和 Period&lt;/h2&gt;
&lt;p&gt;Duration:用于计算两个“时间”间隔。&lt;/p&gt;
&lt;p&gt;Period:用于计算两个“日期”间隔 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Instant instant_1 = Instant.now();
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
Instant instant_2 = Instant.now();

Duration duration = Duration.between(instant_1, instant_2);
System.out.println(duration.toMillis());
// 运行结果：1000

LocalTime localTime_1 = LocalTime.now();
try {
    Thread.sleep(1000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
LocalTime localTime_2 = LocalTime.now();

System.out.println(Duration.between(localTime_1, localTime_2).toMillis());
// 运行结果：1000
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;LocalDate localDate_1 = LocalDate.of(2018,9, 9);
LocalDate localDate_2 = LocalDate.now();

Period period = Period.between(localDate_1, localDate_2);
System.out.println(period.getYears());      // 运行结果：1
System.out.println(period.getMonths());     // 运行结果：1
System.out.println(period.getDays());       // 运行结果：18
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;日期的操纵&quot;&gt;日期的操纵&lt;/h2&gt;
&lt;p&gt;TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。&lt;/p&gt;
&lt;p&gt;TemporalAdjusters : 该类通过静态方法提供了大量的常用 TemporalAdjuster 的实现。&lt;/p&gt;
&lt;p&gt;例如获取下个周日，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;LocalDate nextSunday = LocalDate.now().with(TemporalAdjusters.next(DayOfWeek.SUNDAY));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整的示例代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;LocalDateTime localDateTime1 = LocalDateTime.now();
System.out.println(localDateTime1);     // 2019-10-27T14:19:56.884

// 获取这个第一天的日期
System.out.println(localDateTime1.with(TemporalAdjusters.firstDayOfMonth()));            // 2019-10-01T14:22:58.574
// 获取下个周末的日期
System.out.println(localDateTime1.with(TemporalAdjusters.next(DayOfWeek.SUNDAY)));       // 2019-11-03T14:22:58.574

// 自定义：下一个工作日
LocalDateTime localDateTime2 = localDateTime1.with(l -&amp;gt; {
    LocalDateTime localDateTime = (LocalDateTime) l;
    DayOfWeek dayOfWeek =  localDateTime.getDayOfWeek();

    if (dayOfWeek.equals(DayOfWeek.FRIDAY)) {
       return localDateTime.plusDays(3);
    } else if (dayOfWeek.equals(DayOfWeek.SATURDAY)) {
       return localDateTime.plusDays(2);
    } else {
       return localDateTime.plusDays(1);
    }
});
System.out.println(localDateTime2);
// 运行结果：2019-10-28T14:30:17.400
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解析与格式化&quot;&gt;解析与格式化&lt;/h2&gt;
&lt;p&gt;java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;预定义的标准格式&lt;/li&gt;
&lt;li&gt;语言环境相关的格式&lt;/li&gt;
&lt;li&gt;自定义的格式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ISO_DATE;
LocalDateTime localDateTime = LocalDateTime.now();
String strDate1 = localDateTime.format(dateTimeFormatter1);
System.out.println(strDate1);
// 运行结果：2019-10-27

// Date -&amp;gt; String
DateTimeFormatter dateTimeFormatter2 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd  HH:mm:ss&quot;);
String strDate2 = dateTimeFormatter2.format(localDateTime);
System.out.println(strDate2);
// 运行结果：2019-10-27  14:36:11

// String -&amp;gt; Date
LocalDateTime localDateTime1 = localDateTime.parse(strDate2, dateTimeFormatter2);
System.out.println(localDateTime1);
// 运行结果：2019-10-27T14:37:39
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;时区的处理&quot;&gt;时区的处理&lt;/h2&gt;
&lt;p&gt;Java8 中加入了对时区的支持，带时区的时间为分别为：ZonedDate、 ZonedTime、 ZonedDateTime。&lt;/p&gt;
&lt;p&gt;其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式，例如 ： Asia/Shanghai 等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ZoneId：该类中包含了所有的时区信息&lt;/li&gt;
&lt;li&gt;getAvailableZoneIds() : 可以获取所有时区时区信息&lt;/li&gt;
&lt;li&gt;of(id) : 用指定的时区信息获取 ZoneId 对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例代码如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 获取所有的时区
Set&amp;lt;String&amp;gt; set = ZoneId.getAvailableZoneIds();
System.out.println(set);
// [Asia/Aden, America/Cuiaba, Etc/GMT+9, Etc/GMT+8, Africa/Nairobi, America/Marigot, Asia/Aqtau, Pacific/Kwajalein, America/El_Salvador, Asia/Pontianak, Africa/Cairo, Pacific/Pago_Pago, Africa/Mbabane, Asia/Kuching, Pacific/Honolulu, Pacific/Rarotonga, America/Guatemala, Australia/Hobart, Europe/London, America/Belize, America/Panama, Asia/Chungking, America/Managua, America/Indiana/Petersburg, Asia/Yerevan, Europe/Brussels, GMT, Europe/Warsaw, America/Chicago, Asia/Kashgar, Chile/Continental, Pacific/Yap, CET, Etc/GMT-1, Etc/GMT-0, Europe/Jersey, America/Tegucigalpa, Etc/GMT-5, Europe/Istanbul, America/Eirunepe, Etc/GMT-4, America/Miquelon, Etc/GMT-3, Europe/Luxembourg, Etc/GMT-2, Etc/GMT-9, America/Argentina/Catamarca, Etc/GMT-8, Etc/GMT-7, Etc/GMT-6, Europe/Zaporozhye, Canada/Yukon, Canada/Atlantic, Atlantic/St_Helena, Australia/Tasmania, Libya, Europe/Guernsey, America/Grand_Turk, US/Pacific-New, Asia/Samarkand, America/Argentina/Cordoba, Asia/Phnom_Penh, Africa/Kigali, Asia/Almaty, US/Alaska, Asia/Dubai, Europe/Isle_of_Man, America/Araguaina, Cuba, Asia/Novosibirsk, America/Argentina/Salta, Etc/GMT+3, Africa/Tunis, Etc/GMT+2, Etc/GMT+1, Pacific/Fakaofo, Africa/Tripoli, Etc/GMT+0, Israel, Africa/Banjul, Etc/GMT+7, Indian/Comoro, Etc/GMT+6, Etc/GMT+5, Etc/GMT+4, Pacific/Port_Moresby, US/Arizona, Antarctica/Syowa, Indian/Reunion, Pacific/Palau, Europe/Kaliningrad, America/Montevideo, Africa/Windhoek, Asia/Karachi, Africa/Mogadishu, Australia/Perth, Brazil/East, Etc/GMT, Asia/Chita, Pacific/Easter, Antarctica/Davis, Antarctica/McMurdo, Asia/Macao, America/Manaus, Africa/Freetown, Europe/Bucharest, Asia/Tomsk, America/Argentina/Mendoza, Asia/Macau, Europe/Malta, Mexico/BajaSur, Pacific/Tahiti, Africa/Asmera, Europe/Busingen, America/Argentina/Rio_Gallegos, Africa/Malabo, Europe/Skopje, America/Catamarca, America/Godthab, Europe/Sarajevo, Australia/ACT, GB-Eire, Africa/Lagos, America/Cordoba, Europe/Rome, Asia/Dacca, Indian/Mauritius, Pacific/Samoa, America/Regina, America/Fort_Wayne, America/Dawson_Creek, Africa/Algiers, Europe/Mariehamn, America/St_Johns, America/St_Thomas, Europe/Zurich, America/Anguilla, Asia/Dili, America/Denver, Africa/Bamako, Europe/Saratov, GB, Mexico/General, Pacific/Wallis, Europe/Gibraltar, Africa/Conakry, Africa/Lubumbashi, Asia/Istanbul, America/Havana, NZ-CHAT, Asia/Choibalsan, America/Porto_Acre, Asia/Omsk, Europe/Vaduz, US/Michigan, Asia/Dhaka, America/Barbados, Europe/Tiraspol, Atlantic/Cape_Verde, Asia/Yekaterinburg, America/Louisville, Pacific/Johnston, Pacific/Chatham, Europe/Ljubljana, America/Sao_Paulo, Asia/Jayapura, America/Curacao, Asia/Dushanbe, America/Guyana, America/Guayaquil, America/Martinique, Portugal, Europe/Berlin, Europe/Moscow, Europe/Chisinau, America/Puerto_Rico, America/Rankin_Inlet, Pacific/Ponape, Europe/Stockholm, Europe/Budapest, America/Argentina/Jujuy, Australia/Eucla, Asia/Shanghai, Universal, Europe/Zagreb, America/Port_of_Spain, Europe/Helsinki, Asia/Beirut, Asia/Tel_Aviv, Pacific/Bougainville, US/Central, Africa/Sao_Tome, Indian/Chagos, America/Cayenne, Asia/Yakutsk, Pacific/Galapagos, Australia/North, Europe/Paris, Africa/Ndjamena, Pacific/Fiji, America/Rainy_River, Indian/Maldives, Australia/Yancowinna, SystemV/AST4, Asia/Oral, America/Yellowknife, Pacific/Enderbury, America/Juneau, Australia/Victoria, America/Indiana/Vevay, Asia/Tashkent, Asia/Jakarta, Africa/Ceuta, Asia/Barnaul, America/Recife, America/Buenos_Aires, America/Noronha, America/Swift_Current, Australia/Adelaide, America/Metlakatla, Africa/Djibouti, America/Paramaribo, Europe/Simferopol, Europe/Sofia, Africa/Nouakchott, Europe/Prague, America/Indiana/Vincennes, Antarctica/Mawson, America/Kralendijk, Antarctica/Troll, Europe/Samara, Indian/Christmas, America/Antigua, Pacific/Gambier, America/Indianapolis, America/Inuvik, America/Iqaluit, Pacific/Funafuti, UTC, Antarctica/Macquarie, Canada/Pacific, America/Moncton, Africa/Gaborone, Pacific/Chuuk, Asia/Pyongyang, America/St_Vincent, Asia/Gaza, Etc/Universal, PST8PDT, Atlantic/Faeroe, Asia/Qyzylorda, Canada/Newfoundland, America/Kentucky/Louisville, America/Yakutat, Asia/Ho_Chi_Minh, Antarctica/Casey, Europe/Copenhagen, Africa/Asmara, Atlantic/Azores, Europe/Vienna, ROK, Pacific/Pitcairn, America/Mazatlan, Australia/Queensland, Pacific/Nauru, Europe/Tirane, Asia/Kolkata, SystemV/MST7, Australia/Canberra, MET, Australia/Broken_Hill, Europe/Riga, America/Dominica, Africa/Abidjan, America/Mendoza, America/Santarem, Kwajalein, America/Asuncion, Asia/Ulan_Bator, NZ, America/Boise, Australia/Currie, EST5EDT, Pacific/Guam, Pacific/Wake, Atlantic/Bermuda, America/Costa_Rica, America/Dawson, Asia/Chongqing, Eire, Europe/Amsterdam, America/Indiana/Knox, America/North_Dakota/Beulah, Africa/Accra, Atlantic/Faroe, Mexico/BajaNorte, America/Maceio, Etc/UCT, Pacific/Apia, GMT0, America/Atka, Pacific/Niue, Australia/Lord_Howe, Europe/Dublin, Pacific/Truk, MST7MDT, America/Monterrey, America/Nassau, America/Jamaica, Asia/Bishkek, America/Atikokan, Atlantic/Stanley, Australia/NSW, US/Hawaii, SystemV/CST6, Indian/Mahe, Asia/Aqtobe, America/Sitka, Asia/Vladivostok, Africa/Libreville, Africa/Maputo, Zulu, America/Kentucky/Monticello, Africa/El_Aaiun, Africa/Ouagadougou, America/Coral_Harbour, Pacific/Marquesas, Brazil/West, America/Aruba, America/North_Dakota/Center, America/Cayman, Asia/Ulaanbaatar, Asia/Baghdad, Europe/San_Marino, America/Indiana/Tell_City, America/Tijuana, Pacific/Saipan, SystemV/YST9, Africa/Douala, America/Chihuahua, America/Ojinaga, Asia/Hovd, America/Anchorage, Chile/EasterIsland, America/Halifax, Antarctica/Rothera, America/Indiana/Indianapolis, US/Mountain, Asia/Damascus, America/Argentina/San_Luis, America/Santiago, Asia/Baku, America/Argentina/Ushuaia, Atlantic/Reykjavik, Africa/Brazzaville, Africa/Porto-Novo, America/La_Paz, Antarctica/DumontDUrville, Asia/Taipei, Antarctica/South_Pole, Asia/Manila, Asia/Bangkok, Africa/Dar_es_Salaam, Poland, Atlantic/Madeira, Antarctica/Palmer, America/Thunder_Bay, Africa/Addis_Ababa, Asia/Yangon, Europe/Uzhgorod, Brazil/DeNoronha, Asia/Ashkhabad, Etc/Zulu, America/Indiana/Marengo, America/Creston, America/Punta_Arenas, America/Mexico_City, Antarctica/Vostok, Asia/Jerusalem, Europe/Andorra, US/Samoa, PRC, Asia/Vientiane, Pacific/Kiritimati, America/Matamoros, America/Blanc-Sablon, Asia/Riyadh, Iceland, Pacific/Pohnpei, Asia/Ujung_Pandang, Atlantic/South_Georgia, Europe/Lisbon, Asia/Harbin, Europe/Oslo, Asia/Novokuznetsk, CST6CDT, Atlantic/Canary, America/Knox_IN, Asia/Kuwait, SystemV/HST10, Pacific/Efate, Africa/Lome, America/Bogota, America/Menominee, America/Adak, Pacific/Norfolk, Europe/Kirov, America/Resolute, Pacific/Tarawa, Africa/Kampala, Asia/Krasnoyarsk, Greenwich, SystemV/EST5, America/Edmonton, Europe/Podgorica, Australia/South, Canada/Central, Africa/Bujumbura, America/Santo_Domingo, US/Eastern, Europe/Minsk, Pacific/Auckland, Africa/Casablanca, America/Glace_Bay, Canada/Eastern, Asia/Qatar, Europe/Kiev, Singapore, Asia/Magadan, SystemV/PST8, America/Port-au-Prince, Europe/Belfast, America/St_Barthelemy, Asia/Ashgabat, Africa/Luanda, America/Nipigon, Atlantic/Jan_Mayen, Brazil/Acre, Asia/Muscat, Asia/Bahrain, Europe/Vilnius, America/Fortaleza, Etc/GMT0, US/East-Indiana, America/Hermosillo, America/Cancun, Africa/Maseru, Pacific/Kosrae, Africa/Kinshasa, Asia/Kathmandu, Asia/Seoul, Australia/Sydney, America/Lima, Australia/LHI, America/St_Lucia, Europe/Madrid, America/Bahia_Banderas, America/Montserrat, Asia/Brunei, America/Santa_Isabel, Canada/Mountain, America/Cambridge_Bay, Asia/Colombo, Australia/West, Indian/Antananarivo, Australia/Brisbane, Indian/Mayotte, US/Indiana-Starke, Asia/Urumqi, US/Aleutian, Europe/Volgograd, America/Lower_Princes, America/Vancouver, Africa/Blantyre, America/Rio_Branco, America/Danmarkshavn, America/Detroit, America/Thule, Africa/Lusaka, Asia/Hong_Kong, Iran, America/Argentina/La_Rioja, Africa/Dakar, SystemV/CST6CDT, America/Tortola, America/Porto_Velho, Asia/Sakhalin, Etc/GMT+10, America/Scoresbysund, Asia/Kamchatka, Asia/Thimbu, Africa/Harare, Etc/GMT+12, Etc/GMT+11, Navajo, America/Nome, Europe/Tallinn, Turkey, Africa/Khartoum, Africa/Johannesburg, Africa/Bangui, Europe/Belgrade, Jamaica, Africa/Bissau, Asia/Tehran, WET, Europe/Astrakhan, Africa/Juba, America/Campo_Grande, America/Belem, Etc/Greenwich, Asia/Saigon, America/Ensenada, Pacific/Midway, America/Jujuy, Africa/Timbuktu, America/Bahia, America/Goose_Bay, America/Virgin, America/Pangnirtung, Asia/Katmandu, America/Phoenix, Africa/Niamey, America/Whitehorse, Pacific/Noumea, Asia/Tbilisi, America/Montreal, Asia/Makassar, America/Argentina/San_Juan, Hongkong, UCT, Asia/Nicosia, America/Indiana/Winamac, SystemV/MST7MDT, America/Argentina/ComodRivadavia, America/Boa_Vista, America/Grenada, Asia/Atyrau, Australia/Darwin, Asia/Khandyga, Asia/Kuala_Lumpur, Asia/Famagusta, Asia/Thimphu, Asia/Rangoon, Europe/Bratislava, Asia/Calcutta, America/Argentina/Tucuman, Asia/Kabul, Indian/Cocos, Japan, Pacific/Tongatapu, America/New_York, Etc/GMT-12, Etc/GMT-11, Etc/GMT-10, SystemV/YST9YDT, Europe/Ulyanovsk, Etc/GMT-14, Etc/GMT-13, W-SU, America/Merida, EET, America/Rosario, Canada/Saskatchewan, America/St_Kitts, Arctic/Longyearbyen, America/Fort_Nelson, America/Caracas, America/Guadeloupe, Asia/Hebron, Indian/Kerguelen, SystemV/PST8PDT, Africa/Monrovia, Asia/Ust-Nera, Egypt, Asia/Srednekolymsk, America/North_Dakota/New_Salem, Asia/Anadyr, Australia/Melbourne, Asia/Irkutsk, America/Shiprock, America/Winnipeg, Europe/Vatican, Asia/Amman, Etc/UTC, SystemV/AST4ADT, Asia/Tokyo, America/Toronto, Asia/Singapore, Australia/Lindeman, America/Los_Angeles, SystemV/EST5EDT, Pacific/Majuro, America/Argentina/Buenos_Aires, Europe/Nicosia, Pacific/Guadalcanal, Europe/Athens, US/Pacific, Europe/Monaco]

// 通过时区构建LocalDateTime
LocalDateTime localDateTime1 = LocalDateTime.now(ZoneId.of(&quot;America/El_Salvador&quot;));
System.out.println(localDateTime1);
// 2019-10-27T00:46:21.268

// 以时区格式显示时间
LocalDateTime localDateTime2 = LocalDateTime.now();
ZonedDateTime zonedDateTime1 = localDateTime2.atZone(ZoneId.of(&quot;Africa/Nairobi&quot;));
System.out.println(zonedDateTime1);
// 2019-10-27T14:46:21.273+03:00[Africa/Nairobi]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;与传统日期处理的转换&quot;&gt;与传统日期处理的转换&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1729473/202006/1729473-20200602005734255-82158138.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习Java8新特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，附上Java8新特性核心知识图，祝大家在学习Java8新特性时少走弯路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200520003727787.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jun 2020 17:00:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 Java8之前的日期和时间API，存在一些问题，比如：线程安全的问题，跨年的问题等等。这些问题都在Hava8中的日期和时间API中得到了解决，而且Java8中的日期和时间API更加强大。立志</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13028868.html</dc:identifier>
</item>
<item>
<title>Hystrix微服务容错处理及回调方法源码分析 - 后青春期的Keats</title>
<link>http://www.cnblogs.com/keatsCoder/p/13028727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keatsCoder/p/13028727.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在 SpringCloud 微服务项目中，我们有了 Eureka 做服务的注册中心，进行服务的注册于发现和服务治理。使得我们可以摒弃硬编码式的 ip:端口 + 映射路径 来发送请求。我们有了 Feign 作为声明式服务调用组件，可以像调用本地服务一样来调用远程服务。基于 Ribbon 我们又实现了客户端负载均衡，轻松的在集群环境下选取合适的服务提供者。这样看来我们的微服务貌似很完善了。是这样的吗？&lt;/p&gt;
&lt;p&gt;并非如此，想想我们在编码过程中进行的健壮性检查。类比一下服务与服务调用是否也应该更加健壮一些呢？我们目前的微服务在正常运行的时候是没有问题的，但若是某个偏下游的服务提供者不可用，造成服务积压，接连引起上游的服务消费者宕机，引法雪崩效应。是不是就显得我们的微服务不堪一击呢？因此我们需要一个组件来解决这样的问题，前辈们参考生活中保险丝的原理做出了微服务中的保险丝-Hystrix熔断器。下面让我们来一起使用一下&lt;/p&gt;
&lt;p&gt;&lt;span&gt;声明：本文首发于博客园，作者：后青春期的Keats；地址：&lt;a href=&quot;https://www.cnblogs.com/keatsCoder/&quot;&gt;https://www.cnblogs.com/keatsCoder/&lt;/a&gt; 转载请注明，谢谢！&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;hystrix简介&quot;&gt;Hystrix简介&lt;/h2&gt;
&lt;p&gt;Hystrix主要实现了下面的功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;包裹请求：使用 HystrixCommand(或 HystrixObservableCommand) 包裹对依赖的调用逻辑。每个命令在独立的线程中执行，使用了设计模式中的‘命令模式’&lt;/li&gt;
&lt;li&gt;跳闸机制：当某微服务的错误率超过一定阈值时，可以自动跳闸，停止请求该服务一段时间&lt;/li&gt;
&lt;li&gt;资源隔离：Hystrix 为每个微服务都维护了一个小型的线程池(或信号量)如果该线程池已满，发往该依赖的请求就会被立即拒绝&lt;/li&gt;
&lt;li&gt;监控：Hystrix 可以近乎实时的监控运行指标和配置的变化，例如成功、失败、超时和被拒绝的请求等&lt;/li&gt;
&lt;li&gt;回退机制：当请求成功、失败、超时和被拒绝或者断路器打开时，执行回退逻辑。回退逻辑可由开发人员自行提供&lt;/li&gt;
&lt;li&gt;自我修复：断路器打开一段时间后，会进入‘半开’状态，允许一个请求访问服务提供方，如果成功。则关闭断路器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用-hystrix&quot;&gt;使用 Hystrix&lt;/h2&gt;
&lt;h3 id=&quot;引入依赖&quot;&gt;引入依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;!-- 熔断器 hystrix --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-hystrix&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在启动类上添加-enablehystrix&quot;&gt;在启动类上添加 @EnableHystrix&lt;/h3&gt;
&lt;h3 id=&quot;两种情况下的回退方法&quot;&gt;两种情况下的回退方法&lt;/h3&gt;
&lt;h4 id=&quot;非-feign-调用下的回退方法&quot;&gt;非 Feign 调用下的回退方法&lt;/h4&gt;
&lt;h5 id=&quot;编写回退方法&quot;&gt;编写回退方法&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * getUserByAge 方法 Hystrix 回退方法
 * @param age
 * @return
 */
public User getUserByAgeFallBack(Integer age){
    User user = new User();
    user.setName(&quot;默认用户&quot;);
    user.setAge(age);
    return user;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;在客户端的方法上声明&quot;&gt;在客户端的方法上声明&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@HystrixCommand(fallbackMethod = &quot;getUserByAgeFallBack&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：将服务提供方的代码打断点。调用服务消费方，会发现返回了默认用户&lt;/p&gt;
&lt;p&gt;需要注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;回退方法的返回值类型需要和原来方法返回值类型相同(否则会报 FallbackDefinitionException: Incompatible return types)&lt;/li&gt;
&lt;li&gt;回退方法的参数列表也要和原来方法相同(否则会报 FallbackDefinitionException: fallback method wasn't found: getUserByAgeFallBack([class java.lang.Integer]))&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当我写下第二句时，发现书中下一节介绍说可以通过在回退方法中添加第二个参数：ThrowEable 来捕获异常，分析调用失败的原因，我就知道我错了。&lt;/strong&gt;为了避免继续得到错误的结论，我决定读一读 Hystrix 处理回退方法的源码&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;加点料：hystrix-对回退方法的封装的源码如下：&quot;&gt;加点料：Hystrix 对回退方法的封装的源码如下：&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;com.netflix.hystrix.contrib.javanica.utils.MethodProvider
public FallbackMethod find(Class&amp;lt;?&amp;gt; enclosingType, Method commandMethod, boolean extended) {
        // 首先判断该方法的 HystrixCommand 注解上有没有 defaultFallback / fallbackMethod 配置回退方法名称
    if (this.canHandle(enclosingType, commandMethod)) {
        // 调用 doFind 方法
        return this.doFind(enclosingType, commandMethod, extended);
    } else {
        // 没有配置的化就接着下一个判断
        return this.next != null ? this.next.find(enclosingType, commandMethod, extended) : FallbackMethod.ABSENT;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;find 方法在用户所请求的方法的 HystrixCommand 注解上有用 defaultFallback / fallbackMethod 配置回退方法名称的时候，会调用 doFind 方法来寻找回退方法。该方法的参数有两个，enclosingType 是用户所请求的方法的类字节码文件，commandMethod 是用户所请求的方法&lt;/p&gt;
&lt;p&gt;首先通过 this.getFallbackName 获取回退方法名称，接着通过获取 commandMethod 的参数类型们&lt;/p&gt;
&lt;p&gt;接着分两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;回调方法继承于 commandMethod 且最后一个参数类型是 Throwable，则去掉回退方法参数列表中的 Throwable 类型进行匹配&lt;/li&gt;
&lt;li&gt;回调方法不继承于 commandMethod ，则存在两个可能的参数类型列表： fallbackParameterTypes 和 extendedFallbackParameterTypes 前者是 commandMethod 是参数列表，后者是前者 + Throwable。然后两个都进行匹配。接着使用 Java8 Optional API，按顺序选取前者匹配到的方法 / 后者 / 空返回&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private FallbackMethod doFind(Class&amp;lt;?&amp;gt; enclosingType, Method commandMethod, boolean extended) {
    String name = this.getFallbackName(enclosingType, commandMethod);
    Class&amp;lt;?&amp;gt;[] fallbackParameterTypes = null;
    if (this.isDefault()) {
        fallbackParameterTypes = new Class[0];
    } else {
        fallbackParameterTypes = commandMethod.getParameterTypes();
    }

    if (extended &amp;amp;&amp;amp; fallbackParameterTypes[fallbackParameterTypes.length - 1] == Throwable.class) {
        fallbackParameterTypes = (Class[])ArrayUtils.remove(fallbackParameterTypes, fallbackParameterTypes.length - 1);
    }

    Class&amp;lt;?&amp;gt;[] extendedFallbackParameterTypes = (Class[])Arrays.copyOf(fallbackParameterTypes, fallbackParameterTypes.length + 1);
    extendedFallbackParameterTypes[fallbackParameterTypes.length] = Throwable.class;
    Optional&amp;lt;Method&amp;gt; exFallbackMethod = MethodProvider.getMethod(enclosingType, name, extendedFallbackParameterTypes);
    Optional&amp;lt;Method&amp;gt; fMethod = MethodProvider.getMethod(enclosingType, name, fallbackParameterTypes);
    Method method = (Method)exFallbackMethod.or(fMethod).orNull();
    if (method == null) {
        throw new FallbackDefinitionException(&quot;fallback method wasn't found: &quot; + name + &quot;(&quot; + Arrays.toString(fallbackParameterTypes) + &quot;)&quot;);
    } else {
        return new FallbackMethod(method, exFallbackMethod.isPresent(), this.isDefault());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;由源码可以得到结论：回退方法要么参数列表和原始方法相同，要么加且仅加一个类型为 Throwable 的参数。其他的都不行&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;feign-客户端下的回退方法&quot;&gt;Feign 客户端下的回退方法&lt;/h4&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设置：feign.hystrix.enabled: true&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Feign 客户端接口上的 @FeignClient 添加 fallback 属性，指向回退类&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;回退类实现客户端接口&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;# feign的配置
feign:
  hystrix:
    enabled: true # 打开 feign 的 hystrix 支持
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意回退类加上 @Component 接口，避免因为 Spring 容器找不到该类而启动报错&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// Feign 客户端接口上的 @FeignClient 添加 fallback 属性，指向回退类
@FeignClient(name = &quot;SERVICE-PROVIDER&quot;, fallback = UserServiceFeignClientFallBack.class)
public interface UserServiceFeignClient {

    @GetMapping(&quot;/api/v1/user/{age}&quot;)
    User getUser(@PathVariable(&quot;age&quot;) Integer age);

    /**
     * 用户列表
     * @return
     */
    @GetMapping(&quot;/api/v1/users&quot;)
    List&amp;lt;User&amp;gt; getUsers();
}
// 回退类实现客户端接口
@Component 
public class UserServiceFeignClientFallBack implements UserServiceFeignClient {
    @Override
    public User getUser(Integer age) {
        return null;
    }

    @Override
    public List&amp;lt;User&amp;gt; getUsers() {
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当采用 Feign 客户端来实现回退的时候，前面的捕捉异常方法就不起作用了，那我们应该如何来处理异常呢？可以使用 @FeignClient 的 fallbackFactory 属性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FeignClient(name = &quot;SERVICE-PROVIDER&quot;, fallbackFactory = UserServiceFallbackFactory.class)

@Component
@Slf4j
public class UserServiceFallbackFactory implements FallbackFactory&amp;lt;UserServiceFeignClient&amp;gt; {
    @Override
    public UserServiceFeignClient create(Throwable t) {
        // 日志最好写在各个 fallback 方法中，而不要直接卸载 create方法中
        // 否则引用启动时就会打印该日志

        return new UserServiceFeignClient() {
            @Override
            public User getUser(Integer age) {
                log.info(&quot;调用User服务提供者失败&quot;, t);
                User user = new User();
                user.setName(&quot;默认用户&quot;);
                user.setAge(age);
                return user;
            }

            @Override
            public List&amp;lt;User&amp;gt; getUsers() {
                return null;
            }
        };
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意： **fallback 和 fallbackFactory 属性同时存在时，fallback 的优先级更高。因此开发中如果需要处理异常，只需配置 fallbackFactory 属性即可 **&lt;/p&gt;
&lt;h3 id=&quot;避免业务异常走进回退方法&quot;&gt;避免业务异常走进回退方法&lt;/h3&gt;
&lt;p&gt;在某些场景下，当发生业务异常时，我们并不想触发 fallback。例如业务中判断年龄 age 不能小于 1，否则抛出异常&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if(age &amp;lt; 1){
    throw new KeatsException(ExceptionEnum.NUM_LESS_THAN_MIN);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时 Hystrix 会捕捉到异常然后执行 fallback 方法，我们可以通过下面两个方法来避免：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;继承 HystrixBadRequestException 该类继承自 RunntimeException&lt;/li&gt;
&lt;li&gt;在 @HystrixCommand 添加属性 ignoreExceptions = {KeatsException.class}&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;为-feign-禁用-hystrix&quot;&gt;为 Feign 禁用 Hystrix&lt;/h2&gt;
&lt;p&gt;只要打开 feign 的 hystrix 支持开关，feign 就会使用断路器包裹 feign 客户端的所有方法，但很多场景并不需要这样。该如何禁用呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为指定客户端禁用。需要借助 Feign 的自定义配置。首先添加一个自定义配置类，然后配置到 @FeignClient 的 configuration 属性中&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class FeignDisableHystrixConfiguration {
    @Bean
    @Scope(&quot;prototype&quot;)
    public Feign.Builder feignBuilder(){
        return Feign.builder();
    }
}

@FeignClient(name = &quot;SERVICE-PROVIDER&quot;, configuration = {FeignDisableHystrixConfiguration.class})
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;全局禁用： feign.hystrix.enabled: false&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本博客中所有示例代码都已上传至 github仓库： &lt;a href=&quot;https://github.com/keatsCoder/cloud-cli&quot;&gt;https://github.com/keatsCoder/cloud-cli&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考文献：《Spring Cloud与Docker 微服务架构实战》 --- 周立&lt;/p&gt;
&lt;p&gt;&lt;span&gt;码字不易，如果你觉得读完以后有收获，不妨点个推荐让更多的人看到吧！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Jun 2020 16:15:00 +0000</pubDate>
<dc:creator>后青春期的Keats</dc:creator>
<og:description>前言 在 SpringCloud 微服务项目中，我们有了 Eureka 做服务的注册中心，进行服务的注册于发现和服务治理。使得我们可以摒弃硬编码式的 ip:端口 + 映射路径 来发送请求。我们有了 F</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/keatsCoder/p/13028727.html</dc:identifier>
</item>
<item>
<title>SpringAOP使用及源码分析（SpringBoot下） - 女友在高考</title>
<link>http://www.cnblogs.com/javammc/p/13028129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/javammc/p/13028129.html</guid>
<description>&lt;h2 id=&quot;一、springaop应用&quot;&gt;一、SpringAOP应用&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;先搭建一个SpringBoot项目&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
        &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
        &amp;lt;parent&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.1.7.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
        &amp;lt;/parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.mmc&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;springboot-study&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;name&amp;gt;springboot-study&amp;lt;/name&amp;gt;
        &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

        &amp;lt;properties&amp;gt;
                &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;/properties&amp;gt;

        &amp;lt;dependencies&amp;gt;
                &amp;lt;dependency&amp;gt;
                        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
                &amp;lt;/dependency&amp;gt;
                
        &amp;lt;/dependencies&amp;gt;
        
        &amp;lt;build&amp;gt;
                &amp;lt;plugins&amp;gt;
                        &amp;lt;plugin&amp;gt;
                                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                        &amp;lt;/plugin&amp;gt;
                &amp;lt;/plugins&amp;gt;
        &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;定义一个业务逻辑类，作为切面&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public interface CalculationService {

    /**
     * 加法运算
     * @param x
     * @param y
     * @return
     */
    public Integer add(Integer x,Integer y);
}

/**
 * @description:
 * @author: mmc
 * @create: 2020-06-01 14:22
 **/
@Service
public class CalculationServiceImpl implements CalculationService {

    @Override
    public Integer add(Integer x, Integer y) {
        if(x==null||y==null){
            throw  new NullPointerException(&quot;参数不能为空&quot;);
        }
        return x+y;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;定义一个切面类，添加通知方法&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;前置通知(@Before)：logStart：在目标方法(div)运行之前运行&lt;/li&gt;
&lt;li&gt;后置通知(@After)：logEnd：在目标方法(add)运行结束之后运行（无论方法正常结束还是异常结束）&lt;/li&gt;
&lt;li&gt;返回通知(@AfterReturning)：logReturn：在目标方法(add)正常返回之后运行&lt;/li&gt;
&lt;li&gt;异常通知(@AfterThrowing)：logException：在目标方法(add)出现异常以后运行&lt;/li&gt;
&lt;li&gt;环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;
/**
 * @description:  切面类
 * @author: mmc
 * @create: 2020-06-01 14:24
 **/
@Aspect
@Component
public class LogAspects {

    //抽取公共的切入点表达式
    //1、本类引用
    //2、其他的切面引用
    @Pointcut(&quot;execution(public Integer com.mmc.springbootstudy.service.CalculationService.*(..))&quot;)
    public void pointCut(){};

    @Before(&quot;pointCut()&quot;)
    public void logStart(JoinPoint joinPoint){
        Object[] args = joinPoint.getArgs();
        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;运行。。。@Before:参数列表是：{&quot;+Arrays.asList(args)+&quot;}&quot;);
    }

    @After(&quot;pointCut()&quot;)
    public void logEnd(JoinPoint joinPoint){
        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;结束。。。@After&quot;);
    }


    //JoinPoint一定要出现在参数表的第一位
    @AfterReturning(value=&quot;pointCut()&quot;,returning=&quot;result&quot;)
    public void logReturn(JoinPoint joinPoint,Object result){
        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;正常返回。。。@AfterReturning:运行结果：{&quot;+result+&quot;}&quot;);
    }

    @AfterThrowing(value=&quot;pointCut()&quot;,throwing=&quot;exception&quot;)
    public void logException(JoinPoint joinPoint,Exception exception){
        System.out.println(&quot;&quot;+joinPoint.getSignature().getName()+&quot;异常。。。异常信息：{&quot;+exception+&quot;}&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;写一个controller测试&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;@RequestMapping(&quot;/testaop&quot;)
   @ResponseBody
    public Integer testaop(Integer x,Integer y){
       Integer result = calculationService.add(x, y);
       return result;
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;add运行。。。@Before:参数列表是：{[2, 3]}&lt;br/&gt;add结束。。。@After&lt;br/&gt;add正常返回。。。@AfterReturning:运行结果：{5}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二、源码分析&quot;&gt;二、源码分析&lt;/h2&gt;
&lt;p&gt;主线流程图：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1178991/202006/1178991-20200601225130559-1898808695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;spring.factories文件里引入了AopAutoConfiguration类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;@Configuration
@ConditionalOnClass({ EnableAspectJAutoProxy.class, Aspect.class, Advice.class, AnnotatedElement.class })
@ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;auto&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)
public class AopAutoConfiguration {

        @Configuration
        @EnableAspectJAutoProxy(proxyTargetClass = false)
        //看配置文件，如果配置的spring.aop.proxy-target-class为false则引入JdkDynamicAutoProxyConfiguration
        @ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;false&quot;,
                        matchIfMissing = false)
        public static class JdkDynamicAutoProxyConfiguration {

        }

        @Configuration
        //开启AspectJAutoProxy
        @EnableAspectJAutoProxy(proxyTargetClass = true)
        //看配置文件，如果配置的spring.aop.proxy-target-class为true则引入CglibAutoProxyConfiguration 
        @ConditionalOnProperty(prefix = &quot;spring.aop&quot;, name = &quot;proxy-target-class&quot;, havingValue = &quot;true&quot;,
                        matchIfMissing = true)
        public static class CglibAutoProxyConfiguration {

        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在包目录下找到配置文件，并且发现他的值为true&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1178991/202006/1178991-20200601215002020-477866118.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面的方法上有EnableAspectJAutoProxy注解，并传入了proxyTargetClass=true&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;进入@EnableAspectJAutoProxy注解&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
//引入了AspectJAutoProxyRegistrar
@Import({AspectJAutoProxyRegistrar.class})
public @interface EnableAspectJAutoProxy {
    boolean proxyTargetClass() default false;

    boolean exposeProxy() default false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;进入AspectJAutoProxyRegistrar类&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {
    AspectJAutoProxyRegistrar() {
    }

    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        //注册了自动自动代理类
        AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);
        AnnotationAttributes enableAspectJAutoProxy = AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
        if (enableAspectJAutoProxy != null) {
            if (enableAspectJAutoProxy.getBoolean(&quot;proxyTargetClass&quot;)) {
                AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
            }

            if (enableAspectJAutoProxy.getBoolean(&quot;exposeProxy&quot;)) {
                AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
            }
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;进入registerAspectJAnnotationAutoProxyCreatorIfNecessary方法里面&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, @Nullable Object source) {
        return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到返回了一个BeanDefinition，里面的BeanClass类型是AnnotationAwareAspectJAutoProxyCreator，这个类看名字是一个AOP的动态代理创建类，里面没有啥可疑的方法。在IDEA里按Ctrl+H看他的继承结构。有一个父类AbstractAutoProxyCreator，这个类实现了BeanPostProcessor接口。这个接口是Bean的扩展接口，在bean初始化完成后会调用到他的postProcessAfterInitialization(Object bean, String beanName)方法。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1178991/202006/1178991-20200601215909344-484837677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;方法内容如下&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {
        if (bean != null) {
            Object cacheKey = this.getCacheKey(bean.getClass(), beanName);
            if (this.earlyProxyReferences.remove(cacheKey) != bean) {
                //如果有必要，进行包装  
                return this.wrapIfNecessary(bean, beanName, cacheKey);
            }
        }

        return bean;
    }
    
    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
        if (StringUtils.hasLength(beanName) &amp;amp;&amp;amp; this.targetSourcedBeans.contains(beanName)) {
            return bean;
        } else if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
            return bean;
        } else if (!this.isInfrastructureClass(bean.getClass()) &amp;amp;&amp;amp; !this.shouldSkip(bean.getClass(), beanName)) {
        //获取切面的方法，第9点那里展开讨论
            Object[] specificInterceptors = this.getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, (TargetSource)null);
            if (specificInterceptors != DO_NOT_PROXY) {
                this.advisedBeans.put(cacheKey, Boolean.TRUE);
                //创建动态代理
                Object proxy = this.createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
                this.proxyTypes.put(cacheKey, proxy.getClass());
                return proxy;
            } else {
                this.advisedBeans.put(cacheKey, Boolean.FALSE);
                return bean;
            }
        } else {
            this.advisedBeans.put(cacheKey, Boolean.FALSE);
            return bean;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;可以看出这里已经在开始创建动态代理了&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;  protected Object createProxy(Class&amp;lt;?&amp;gt; beanClass, @Nullable String beanName, @Nullable Object[] specificInterceptors, TargetSource targetSource) {
        if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
            AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory)this.beanFactory, beanName, beanClass);
        }
        //动态代理工厂
        ProxyFactory proxyFactory = new ProxyFactory();
        proxyFactory.copyFrom(this);
        if (!proxyFactory.isProxyTargetClass()) {
            if (this.shouldProxyTargetClass(beanClass, beanName)) {
                proxyFactory.setProxyTargetClass(true);
            } else {
                this.evaluateProxyInterfaces(beanClass, proxyFactory);
            }
        }

        Advisor[] advisors = this.buildAdvisors(beanName, specificInterceptors);
        //切面那里的方法
        proxyFactory.addAdvisors(advisors);
        proxyFactory.setTargetSource(targetSource);
        this.customizeProxyFactory(proxyFactory);
        proxyFactory.setFrozen(this.freezeProxy);
        if (this.advisorsPreFiltered()) {
            proxyFactory.setPreFiltered(true);
        }
        //获取动态代理类
        return proxyFactory.getProxy(this.getProxyClassLoader());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;学过AOP的人都知道动态代理的方式有两种，一种JDK代理，一种CGLIB动态代理。那么Spring里面是怎么选择的呢？答案就在这里：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
   // 1.config.isOptimize()是否使用优化的代理策略，目前使用与CGLIB
        // config.isProxyTargetClass() 是否目标类本身被代理而不是目标类的接口
        // hasNoUserSuppliedProxyInterfaces()是否存在代理接口

        if (!config.isOptimize() &amp;amp;&amp;amp; !config.isProxyTargetClass() &amp;amp;&amp;amp; !this.hasNoUserSuppliedProxyInterfaces(config)) {
            return new JdkDynamicAopProxy(config);
        } else {
            Class&amp;lt;?&amp;gt; targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException(&quot;TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.&quot;);
            } else {
                //目标类不是接口或不是代理类就使用cglib代理
                return (AopProxy)(!targetClass.isInterface() &amp;amp;&amp;amp; !Proxy.isProxyClass(targetClass) ? new ObjenesisCglibAopProxy(config) : new JdkDynamicAopProxy(config));
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;Cglib的代理类是CglibAopProxy、ObjenesisCglibAopProxy，JDK的代理类是JdkDynamicAopProxy。在这些类里面对目标类进行了代理，在执行方法的时候就是执行的代理类的方法，而实现了切面编程的效果。&lt;/li&gt;
&lt;li&gt;主线流程就是这些了，还有一个没说的就是我们如何获取的切面方法，@Before(&quot;pointCut()&quot;)这些注解又是如何生效的？再回到AbstractAutoProxyCreator的wrapIfNecessary()方法&lt;br/&gt;里面有这句代码：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt; Object[] specificInterceptors = this.getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, (TargetSource)null);
 
 
  @Nullable
    protected Object[] getAdvicesAndAdvisorsForBean(Class&amp;lt;?&amp;gt; beanClass, String beanName, @Nullable TargetSource targetSource) {
        List&amp;lt;Advisor&amp;gt; advisors = this.findEligibleAdvisors(beanClass, beanName);
        return advisors.isEmpty() ? DO_NOT_PROXY : advisors.toArray();
    }
    
    protected List&amp;lt;Advisor&amp;gt; findEligibleAdvisors(Class&amp;lt;?&amp;gt; beanClass, String beanName) {
        //查找候选的要切面附加的方法，这里加进去的
        List&amp;lt;Advisor&amp;gt; candidateAdvisors = this.findCandidateAdvisors();
        List&amp;lt;Advisor&amp;gt; eligibleAdvisors = this.findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
        this.extendAdvisors(eligibleAdvisors);
        if (!eligibleAdvisors.isEmpty()) {
            eligibleAdvisors = this.sortAdvisors(eligibleAdvisors);
        }

        return eligibleAdvisors;
    }
    
    
    
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;他会找到Aspect类，然后遍历里面的方法，并获取Pointcut，然后构造出Advisor，加入到集合List advisors里，供动态代理时使用&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 01 Jun 2020 14:55:00 +0000</pubDate>
<dc:creator>女友在高考</dc:creator>
<og:description>一、SpringAOP应用 先搭建一个SpringBoot项目 &amp;amp;lt;?xml version=&amp;amp;quot;1.0&amp;amp;quot; encoding=&amp;amp;quot;UTF-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/javammc/p/13028129.html</dc:identifier>
</item>
</channel>
</rss>