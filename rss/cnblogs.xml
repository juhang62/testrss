<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>你说一下对Java中的volatile的理解吧 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/13934720.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/13934720.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;相关的知识其实自己一直都是有掌握的，能大概讲出一些知识，例如：它可以保证&lt;strong&gt;可见性&lt;/strong&gt;；&lt;strong&gt;禁止指令重排&lt;/strong&gt;。这两个特性张口就来，但要再往深了问，具体是如何实现这两个特性的，以及在什么场景下使用&lt;code&gt;volatile&lt;/code&gt;，为什么不直接用&lt;code&gt;synchronized&lt;/code&gt;这种深入和扩展相关的问题，就回答的不好了。因为&lt;code&gt;volatile&lt;/code&gt;是面试必问的知识，所以这次准备把这部分知识也给啃掉。&lt;/p&gt;
&lt;h2 id=&quot;系统处理效率与java内存模型&quot;&gt;系统处理效率与Java内存模型&lt;/h2&gt;
&lt;p&gt;在计算机中，每条程序指令都是在CPU中执行的，而CPU执行指令的数据都是临时存储在内存中的，但是CPU的执行速度远超内存的读取速度，如果所有的CPU指令都是通过内存来读取数据的话那么将大大的降低了系统的处理效率，所以&lt;strong&gt;现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后，在从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。&lt;/p&gt;
&lt;p&gt;虽然说增加了高速缓存提高了CPU的处理效率，但是也带来了新的问题 ：&lt;/p&gt;
&lt;p&gt;现代计算机都是多核CPU，一开始，内存中的变量A的值是1，第一个CPU读取了数据，第二个CPU也将数据读取到了自己的高速缓存当中，当第一个CPU对变量A进行加1操作时，变量A的值变成了2，然后将将变量A的值写回内存中，这时第二个CPU也对变量A进行加1操作时，由于第二个CPU中高速缓存中的值还是1，所以加1操作后的结果为2，然后第二个CPU又将变量A的值同步回内存中，这样就导致执行了两次加1操作后，变量A的值最终是2，而不是3。&lt;br/&gt;&lt;strong&gt;这种被多个CPU访问的变量，通常称为共享变量。&lt;/strong&gt;&lt;br/&gt;而产生的上面的问题，就是引入了高速缓存后的，主内存和缓存内容不一致的问题。&lt;br/&gt;因为每个处理器有自己的高速缓存，但是它们又共享同一块主内存，所以必然会出现主内存不知该以哪个高速缓存中的变量为准的情况。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201104072342653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,,size_50,color_c8cae6,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;上面这个缓存不一致的问题，我们先记下来，继续来看Java内存模型，其实Java内存模型描述的上面讲的计算机系统高速缓存和内存之间的关系类似。&lt;/p&gt;
&lt;p&gt;Java内存模型描述了，&lt;strong&gt;各种变量的访问规则，以及将变量存储到内存和从内存读取变量的这种底层细节。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Java内存模型中关注的变量都是共享变量（实例变量、类变量）。&lt;br/&gt;所有的共享变量都是存储在&lt;strong&gt;主内存&lt;/strong&gt;中的，但是每个线程在访问变量的时候也都会在自己的&lt;strong&gt;工作内存&lt;/strong&gt;（&lt;strong&gt;处理器高速缓存&lt;/strong&gt;）中保留一份共享变量的副本。&lt;/p&gt;
&lt;h4 id=&quot;java内存模型（java-memory-model，简称jmm）规定&quot;&gt;Java内存模型（Java Memory Model，简称JMM）规定:&lt;/h4&gt;
&lt;p&gt;线程对变量的所有操作（读，写）都必须在工作内存中进行，不能直接操作主内存中的数据。&lt;br/&gt;不同线程之间 也不能直接访问对方工作内存中的变量，线程间的变量值传递必须通过主内存进行中转传递。&lt;br/&gt;在JMM中工作内存和主内存的关系如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201104074414741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_50,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;volatile的可见性（保证立即可见）&quot;&gt;Volatile的可见性（保证立即可见）&lt;/h2&gt;
&lt;p&gt;继续我们上面的缓存一致性的问题，这个问题，在Java内存模型中，就是可见性的问题，即一个线程修改了共享变量的值，对另一个线程来说是不是立即可见的。如果不是立即可见的，那么就会出现缓存一致性的问题，如果是立即可见的，那么另一个线程在进行操作的时候，拿到的变量值就是最新的。就可以解决可见性的问题。&lt;/p&gt;
&lt;h4 id=&quot;那么怎么解决可见性问题呢？&quot;&gt;那么怎么解决可见性问题呢？&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;方案一：加锁&quot;&gt;方案一：&lt;strong&gt;加锁&lt;/strong&gt;&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将共享变量加锁，无论是&lt;code&gt;synchronized&lt;/code&gt;还是&lt;code&gt;Lock&lt;/code&gt;都可以，加锁达到的目的是在同一时间内只能有一个线程能对共享变量进行操作，就是说，共享变量从读取到工作内存到更新值后，同步回主内存的过程中，其他线程是操作不了这个变量的。这样自然就解决了可见性的问题了，但是这样的效率比较低，操作不了共享变量的线程就只能阻塞。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;方案二：volatile修饰修饰共享变量&quot;&gt;方案二：&lt;strong&gt;volatile修饰修饰共享变量&lt;/strong&gt;&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当一个共享变量被&lt;code&gt;volatile&lt;/code&gt;修饰后，会保证每个线程将变量修改后的值立即同步回主内存中，当其他线程有需要读取变量时会读取到最新的变量值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么volatile做了些什么操作就能解决可见性的问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;被volatile修饰的变量，在被线程操作时，会有这样的机制：
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是线程对变量操作时会从主内存中读取到自己的工作内存中，当线程对变量进行了修改后，那么其他已经读取了此变量的线程中的变量副本就会失效，这样其他线程在使用变量的时候，发现已经失效，那么就会去主内存中重新获取，这样获取到的就只最新的值了。&lt;/p&gt;
&lt;h5 id=&quot;那么volatile这个关键字是如何实现这套机制的呢？&quot;&gt;那么&lt;code&gt;volatile&lt;/code&gt;这个关键字是如何实现这套机制的呢？&lt;/h5&gt;
&lt;p&gt;因为一台计算机有多台CPU，同一个变量，在多个CPU中缓存的值有可能不一样，那么以谁缓存的值为准呢？&lt;/p&gt;
&lt;p&gt;既然大家都有自己的值，那么各个CPU间就产生了一种协议，来保证按照一定的规律为准，来确定共享变量的准确值，这样各个CPU在读写共享变量时都按照协议来操作。&lt;/p&gt;
&lt;p&gt;这就是缓存一致性协议。&lt;/p&gt;
&lt;p&gt;最著名的缓存一致性协议就是Intel的&lt;code&gt;MESI&lt;/code&gt;了，说MESI时，先解释一下，缓存行：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;缓存行（cache line）：CPU高速缓存的中可以分配的最小存储单位，高速缓存中的变量都是存在缓存行中的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;MESI的核心思想就是，当CPU对变量进行写操作时发现，变量是共享变量，那么就会通知其他CPU中将该变量的缓存行设置为无效状态。当其他CPU在操作变量时发现此变量在的缓存行已经无效，那么就会去主内存中重新读取最新的变量。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;那么其他CPU是如何发现变量被修改了的呢？&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为CPU和其他部件的进行通信是通过总线来进行的，所以每个CPU通过嗅探总线上的传播数据，来检查自己缓存的值是不是过期了，当处理器发现自己换成行对应的内存地址被修改后，就会将自己工作内存中的缓存行设置成无须状态，当CPU对此变量进行修改时会重新从系统主内存中读取变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201104231209224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_50,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;volatile的有序性（禁止指令重排）&quot;&gt;Volatile的有序性（禁止指令重排）&lt;/h2&gt;
&lt;p&gt;一般来说，我们写程序的时候，都是要把先代码从上往下写，默认的认为程序是自顶向下顺序执行的，但是CPU为了提高效率，在保证最终结果准确的情况下，是会对指令进行重新排序的。就是说写在前的代码不一定先执行，在后面的也不一定晚执行。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int a = 5; // 代码1
int b = 8; // 代码2
a = a + 4;      // 代码3
int c = a + b;  // 代码4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面四行代码的执行顺序有可能是&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201104232604437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;JMM在是允许指令重排序的，在保证最后结果正确的情况下，处理器可以尽情的发挥，提高执行效率。&lt;/p&gt;
&lt;p&gt;当多个线程执行代码的时候重排序的情况就更为突出了，各个CPU为了提高自己的效率，有可能会产生竞争情况，这样就有可能导致最终执行的正确性。&lt;/p&gt;
&lt;p&gt;所以为了保证在多个线程下最终执行的正确性，将变量用&lt;code&gt;volatile&lt;/code&gt;进行修饰，这样就会达到禁止指令重排序的效果（其实也可以通过加锁，还有一些其他已知规则来实现禁止指令重排序，但是我们这里只讨论&lt;code&gt;volatile&lt;/code&gt;的实现方式）。&lt;/p&gt;
&lt;h5 id=&quot;那么volatile是如何实现指令重排序的呢？&quot;&gt;那么&lt;code&gt;volatile&lt;/code&gt;是如何实现指令重排序的呢？&lt;/h5&gt;
&lt;p&gt;答案是：&lt;strong&gt;内存屏障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存屏障&lt;/strong&gt;是一组CPU指令，用于实现对内存操作的顺序限制。&lt;br/&gt;Java编译器，会在生成指令系列时，在适当的位置会插入内存屏障来禁止处理器对指令的重新排序。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;会在变量写操作的前后加入两个内存屏障，来保证前面的写指令和后面的读指令是有序的。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201105225515776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_50,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;在变量的读操作后面插入两个指令，禁止后面的读指令和写指令重排序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201105225600589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_50,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;有序性，不仅只有volatile能保证，其他的实现方式也能保证，但是如果每一种实现方式都要了解那对于开发人员来说就比较困难了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以从JDK5就出现了happen-before原则，也叫先行发生原则。&lt;/strong&gt;&lt;br/&gt;先行发生原则总结起来就是：&lt;strong&gt;如果一个操作A的产生的影响能被另一个操作B观察到，那么可以说，这个操作A先行发生与操作B。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里所说的影响包括内存中的变量的修改，调用了方法，发送量消息等。&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;&lt;strong&gt;volatile中的先行发生原则是，对一个&lt;code&gt;volatile&lt;/code&gt;变量的写操作，先行发生于后面任何地方对这个变量的读操作。&lt;/strong&gt;&lt;/mark&gt;&lt;/p&gt;
&lt;h2 id=&quot;volatile无法保证原子性&quot;&gt;Volatile无法保证原子性&lt;/h2&gt;
&lt;p&gt;原子性，是指一个操作过程要么都成功，要么都失败，是一个独立的完整的。&lt;/p&gt;
&lt;p&gt;就像上面说的，如果多个线程对一个变量进行累加，那么肯定得不到想要的结果，因为累加就不是一个原子操作。&lt;/p&gt;
&lt;p&gt;要保证累加最终结果正确，要么对累加变量加锁，要么就用&lt;code&gt;AotomicInteger&lt;/code&gt;这样的变量。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 双重检查加锁式单例
 */
public class DoubleCheckLockSingleton implements Serializable{

    /**
     * 静态变量，用来存放实例。
     */
    private volatile static DoubleCheckLockSingleton doubleCheckLockSingleton = null;

    /**
     * 私有化构造方法，禁止外部创建实例。
     */
    private DoubleCheckLockSingleton(){}

    /**
     * 双重检查加锁的方式保证线程安全又能获得到唯一实例
     * @return
     */
    public static DoubleCheckLockSingleton getInstance(){
        //第一次检查实例是否已经存在，不存在则进入代码块
        if(null == doubleCheckLockSingleton){
            synchronized (DoubleCheckLockSingleton.class){
                //第二次检查
                if(null==doubleCheckLockSingleton){
                    doubleCheckLockSingleton = new DoubleCheckLockSingleton();
                }
            }
        }

        return doubleCheckLockSingleton;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么要进行双重检查呢？&lt;br/&gt;当第一个线程走到第一次检查时发现对象为空，然后进入锁，第二次就检查时也为空，那么就去创建对象，但是这个时候又来了一个线程来到了第一次检查，发现为空，但是这个时候因为锁被占用，所以就只能阻塞等待，然后第一个线程创建对象成功了，由于对象是被volatile修饰的能够立即反馈到其他线程上，所以在第一个线程释放锁之后，第二个线程进入了锁，然后进行第二次检查时，发现对象已经被创建了，那么就不在创建对象了。从而保证的单例。&lt;/p&gt;
&lt;p&gt;还有就是如果创建对象，步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;分配内存空间。&lt;/li&gt;
&lt;li&gt;调用构造器，实例化。&lt;/li&gt;
&lt;li&gt;返回内存地址给引用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果这三个指令顺序被重排了，那么当多线程来获取对象的时候就会造成对象虽然实例化了，但是没有分配内存空间，会有空指针的风险。&lt;br/&gt;所以加上了&lt;code&gt;volatile&lt;/code&gt;的对象，也保证了在第二次检查时不会被已经在创建过程中的对象有被检测为空的风险。&lt;/p&gt;
&lt;h2 id=&quot;总结一下&quot;&gt;总结一下&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;其实可以看作是轻量级的&lt;code&gt;synchronized&lt;/code&gt;，虽然说&lt;code&gt;volatile&lt;/code&gt;不能保证原子性，但是如果在多线程下的操作本身就是原子性操作（例如赋值操作），那么使用volatile会由于&lt;code&gt;synchronized&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;可以适用于，某个标识flag，一旦被修改了就需要被其他线程立即可见的情况。也可以修饰作为触发器的变量，一旦变量被任何一个线程修改了，就去触发执行某个操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;的变量写操作happen-before，后面任何对此volatile变量的读操作。&lt;/p&gt;
</description>
<pubDate>Fri, 06 Nov 2020 00:26:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 volatile相关的知识其实自己一直都是有掌握的，能大概讲出一些知识，例如：它可以保证可见性；禁止指令重排。这两个特性张口就来，但要再往深了问，具体是如何实现这两个特性的，以及在什么场景下使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/13934720.html</dc:identifier>
</item>
<item>
<title>Flink的DataSource三部曲之二:内置connector - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/13934988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/13934988.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;p&gt;本文是《Flink的DataSource三部曲》系列的第二篇，上一篇&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105467076&quot;&gt;《Flink的DataSource三部曲之一：直接API》&lt;/a&gt;学习了StreamExecutionEnvironment的API创建DataSource，今天要练习的是Flink内置的connector，即下图的红框位置，这些connector可以通过StreamExecutionEnvironment的addSource方法使用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201106082247363-2084181324.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;今天的实战选择Kafka作为数据源来操作，先尝试接收和处理String型的消息，再接收JSON类型的消息，将JSON反序列化成bean实例；&lt;/p&gt;
&lt;h3 id=&quot;flink的datasource三部曲文章链接&quot;&gt;Flink的DataSource三部曲文章链接&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105467076&quot;&gt;《Flink的DataSource三部曲之一：直接API》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105471798&quot;&gt;《Flink的DataSource三部曲之二:内置connector》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105472218&quot;&gt;《Flink的DataSource三部曲之三:自定义》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;p&gt;如果您不想写代码，整个系列的源码可在GitHub下载到，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/p&gt;
&lt;p&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;flinkdatasourcedemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201106082248153-1248283035.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;环境和版本&quot;&gt;环境和版本&lt;/h3&gt;
&lt;p&gt;本次实战的环境和版本如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JDK：1.8.0_211&lt;/li&gt;
&lt;li&gt;Flink：1.9.2&lt;/li&gt;
&lt;li&gt;Maven：3.6.0&lt;/li&gt;
&lt;li&gt;操作系统：macOS Catalina 10.15.3 （MacBook Pro 13-inch, 2018）&lt;/li&gt;
&lt;li&gt;IDEA：2018.3.5 (Ultimate Edition)&lt;/li&gt;
&lt;li&gt;Kafka：2.4.0&lt;/li&gt;
&lt;li&gt;Zookeeper：3.5.5&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;请确保上述内容都已经准备就绪，才能继续后面的实战；&lt;/p&gt;
&lt;h3 id=&quot;flink与kafka版本匹配&quot;&gt;Flink与Kafka版本匹配&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;Flink官方对匹配Kafka版本做了详细说明，地址是：&lt;a href=&quot;https://ci.apache.org/projects/flink/flink-docs-stable/dev/connectors/kafka.html&quot;&gt;https://ci.apache.org/projects/flink/flink-docs-stable/dev/connectors/kafka.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;要重点关注的是官方提到的通用版(universal Kafka connector )，这是从Flink1.7开始推出的，对于Kafka1.0.0或者更高版本都可以使用：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201106082249348-92704373.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 下图红框中是我的工程中要依赖的库，蓝框中是连接Kafka用到的类，读者您可以根据自己的Kafka版本在表格中找到适合的库和类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201106082250311-1478286851.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实战字符串消息处理&quot;&gt;实战字符串消息处理&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在kafka上创建名为test001的topic，参考命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./kafka-topics.sh \
--create \
--zookeeper 192.168.50.43:2181 \
--replication-factor 1 \
--partitions 2 \
--topic test001
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;继续使用上一章创建的flinkdatasourcedemo工程，打开pom.xml文件增加以下依赖：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.apache.flink&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;flink-connector-kafka_2.11&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.10.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;新增类Kafka240String.java，作用是连接broker，对收到的字符串消息做WordCount操作：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.connector;

import com.bolingcavalry.Splitter;
import org.apache.flink.api.common.serialization.SimpleStringSchema;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import java.util.Properties;
import static com.sun.tools.doclint.Entity.para;

public class Kafka240String {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        //设置并行度
        env.setParallelism(2);

        Properties properties = new Properties();
        //broker地址
        properties.setProperty(&quot;bootstrap.servers&quot;, &quot;192.168.50.43:9092&quot;);
        //zookeeper地址
        properties.setProperty(&quot;zookeeper.connect&quot;, &quot;192.168.50.43:2181&quot;);
        //消费者的groupId
        properties.setProperty(&quot;group.id&quot;, &quot;flink-connector&quot;);
        //实例化Consumer类
        FlinkKafkaConsumer&amp;lt;String&amp;gt; flinkKafkaConsumer = new FlinkKafkaConsumer&amp;lt;&amp;gt;(
                &quot;test001&quot;,
                new SimpleStringSchema(),
                properties
        );
        //指定从最新位置开始消费，相当于放弃历史消息
        flinkKafkaConsumer.setStartFromLatest();

        //通过addSource方法得到DataSource
        DataStream&amp;lt;String&amp;gt; dataStream = env.addSource(flinkKafkaConsumer);

        //从kafka取得字符串消息后，分割成单词，统计数量，窗口是5秒
        dataStream
                .flatMap(new Splitter())
                .keyBy(0)
                .timeWindow(Time.seconds(5))
                .sum(1)
                .print();

        env.execute(&quot;Connector DataSource demo : kafka&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;确保kafka的topic已经创建，将Kafka240运行起来，可见消费消息并进行单词统计的功能是正常的：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201106082250865-1311849714.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 接收kafka字符串消息的实战已经完成，接下来试试JSON格式的消息；&lt;/p&gt;
&lt;h3 id=&quot;实战json消息处理&quot;&gt;实战JSON消息处理&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;接下来要接受的JSON格式消息，可以被反序列化成bean实例，会用到JSON库，我选择的是gson；&lt;/li&gt;
&lt;li&gt;在pom.xml增加gson依赖：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;com.google.code.gson&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;gson&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;2.8.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;增加类Student.java，这是个普通的Bean，只有id和name两个字段：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry;

public class Student {

    private int id;

    private String name;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;增加类StudentSchema.java，该类是DeserializationSchema接口的实现，将JSON反序列化成Student实例时用到：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ackage com.bolingcavalry.connector;

import com.bolingcavalry.Student;
import com.google.gson.Gson;
import org.apache.flink.api.common.serialization.DeserializationSchema;
import org.apache.flink.api.common.serialization.SerializationSchema;
import org.apache.flink.api.common.typeinfo.TypeInformation;
import java.io.IOException;

public class StudentSchema implements DeserializationSchema&amp;lt;Student&amp;gt;, SerializationSchema&amp;lt;Student&amp;gt; {

    private static final Gson gson = new Gson();

    /**
     * 反序列化，将byte数组转成Student实例
     * @param bytes
     * @return
     * @throws IOException
     */
    @Override
    public Student deserialize(byte[] bytes) throws IOException {
        return gson.fromJson(new String(bytes), Student.class);
    }

    @Override
    public boolean isEndOfStream(Student student) {
        return false;
    }

    /**
     * 序列化，将Student实例转成byte数组
     * @param student
     * @return
     */
    @Override
    public byte[] serialize(Student student) {
        return new byte[0];
    }

    @Override
    public TypeInformation&amp;lt;Student&amp;gt; getProducedType() {
        return TypeInformation.of(Student.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;新增类Kafka240Bean.java，作用是连接broker，对收到的JSON消息转成Student实例，统计每个名字出现的数量，窗口依旧是5秒：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.connector;

import com.bolingcavalry.Splitter;
import com.bolingcavalry.Student;
import org.apache.flink.api.common.functions.MapFunction;
import org.apache.flink.api.common.serialization.SimpleStringSchema;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.streaming.api.datastream.DataStream;
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
import org.apache.flink.streaming.api.windowing.time.Time;
import org.apache.flink.streaming.connectors.kafka.FlinkKafkaConsumer;
import java.util.Properties;

public class Kafka240Bean {
    public static void main(String[] args) throws Exception {
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        //设置并行度
        env.setParallelism(2);

        Properties properties = new Properties();
        //broker地址
        properties.setProperty(&quot;bootstrap.servers&quot;, &quot;192.168.50.43:9092&quot;);
        //zookeeper地址
        properties.setProperty(&quot;zookeeper.connect&quot;, &quot;192.168.50.43:2181&quot;);
        //消费者的groupId
        properties.setProperty(&quot;group.id&quot;, &quot;flink-connector&quot;);
        //实例化Consumer类
        FlinkKafkaConsumer&amp;lt;Student&amp;gt; flinkKafkaConsumer = new FlinkKafkaConsumer&amp;lt;&amp;gt;(
                &quot;test001&quot;,
                new StudentSchema(),
                properties
        );
        //指定从最新位置开始消费，相当于放弃历史消息
        flinkKafkaConsumer.setStartFromLatest();

        //通过addSource方法得到DataSource
        DataStream&amp;lt;Student&amp;gt; dataStream = env.addSource(flinkKafkaConsumer);

        //从kafka取得的JSON被反序列化成Student实例，统计每个name的数量，窗口是5秒
        dataStream.map(new MapFunction&amp;lt;Student, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;() {
            @Override
            public Tuple2&amp;lt;String, Integer&amp;gt; map(Student student) throws Exception {
                return new Tuple2&amp;lt;&amp;gt;(student.getName(), 1);
            }
        })
                .keyBy(0)
                .timeWindow(Time.seconds(5))
                .sum(1)
                .print();

        env.execute(&quot;Connector DataSource demo : kafka bean&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;在测试的时候，要向kafka发送JSON格式字符串，flink这边就会给统计出每个name的数量：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202011/485422-20201106082251551-647056365.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，内置connector的实战就完成了，接下来的章节，我们将要一起实战自定义DataSource；&lt;/p&gt;
&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 06 Nov 2020 00:23:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/13934988.html</dc:identifier>
</item>
<item>
<title>Java才是世界上最好的语言，Java在高频交易中替代C++ - 王泽宾</title>
<link>http://www.cnblogs.com/wanghao72214/p/13934471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanghao72214/p/13934471.html</guid>
<description>&lt;p&gt;Java在享受简单性和面向业务的特性同时，仍然可以实现高性能和低延迟。虽然C++ 仍然可用于特定的底层组件，如驱动程序、数据库、编译器和操作系统，但大多数现实中都可以用Java来开发，包括象高频交易这样要求苛刻的应用。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;169.53419930992&quot;&gt;
&lt;h2 id=&quot;高频交易&quot;&gt;&lt;strong&gt;高频交易&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;高频交易是指从那些人们无法利用的极为短暂的市场变化中寻求获利的计算机化交易，比如，某种证券买入价和卖出价差价的微小变化，或者某只股票在不同交易所之间的微小价差。在高频交易中，自动化应用程序每天处理几亿个市场信号，在全球各地的交易所发送上千万个订单。为了保持业务竞争力，响应时间必须始终保持在微秒级，尤其是在黑天鹅异常事件等高峰期。&lt;/p&gt;
&lt;p&gt;高频交易系统的典型系统结构一般是这样：金融交易信号将转换成内部市场数据格式(交易使用TCP、UDP等各种协议)和多种格式(如二进制、SBE、JSON、FIX等)。然后，这些标准化的消息被发送到算法服务器、统计引擎、UI、Log Server和各种数据库(缓存、文件或分布式数据库)。任何延迟都会带来都会带来高成本的结果。例如，根据根据旧的价格进行决策或下单太迟。为了获得微秒级的优势，大部分交易参与者都会投入高价硬件：一个超频液冷CPU的服务器池（2020年可以买56核、5.6GHz、1TB内存的服务器），组装在主交换数据中心、高端纳秒级网络交换机、专用跨洋线，甚至是微波网络。&lt;/p&gt;
&lt;p&gt;常见的高频交易系统使用高度定制的Linux内核，并且带有操作系统旁路，这样数据就可以直接从网卡 &quot;跳转&quot; 到应用程序、基于IPC 进程间通信，甚至使用FPGA（可编程单用途芯片）。至于编程语言，一般首先想到的就是C++，事实上也确实是这个领域的天然选择。C++的最大优势就是运行速度快，最接近机器代码，而且是直接根据目标平台进行编译，具有高效稳定的特点。&lt;/p&gt;
&lt;h2 id=&quot;使用java代替c&quot;&gt;使用Java代替C++&lt;/h2&gt;
&lt;p&gt;我们做了一个不同的选择。在过去14年里，我们在外汇算法交易领域用Java进行开发，并使用廉价的硬件代替昂贵的高端设备。&lt;br/&gt;在一个团队小，资源有限以及熟练开发人员欠缺的工作环境，Java意味着我们可以快速进行软件迭代，因为Java生态系统比C系列具有更快的开发效率。可以在早上讨论改进措施，并在下午在生产中实施、测试和发布。&lt;/p&gt;
&lt;p&gt;与需要几周甚至几个月软件更新时间的大型公司相比，这是一个关键优势。在这个领域，一个错误可以在几秒钟内抹去一整年的利润，因此不能在质量上妥协。我们使用了许多开源库和项目，实现了严格的敏捷开发环境，包括使用Jenkins、Maven、单元测试、夜间构建和Jira。通过Java，开发人员可以专注于业务逻辑，而不是像C++那样调试内存Coredump或跟指针打交道。而且，由于Java强大的内存管理，初级程序员也可以立即参与开发代码，并且风险可控。&lt;/p&gt;
&lt;p&gt;只要有良好的设计模式和干净的编码习惯，就可以用Java达到C++的延迟。我们都知道，使Java成为软件开发强大和方便语言的原因，同时也是它的缺点的最主要的原因，那就是Java虚拟机（JVM）。&lt;/p&gt;
&lt;p&gt;Java即时编译代码（Just in Time 编译器），意味着第一次遇到一些代码时，也可能产生编译延迟。Java管理内存的方式是通过在堆空间中分配内存块。每隔一段时间，它就会清理这个空间，删除旧的对象，为新的对象腾出空间。主要问题是，为了进行准确的统计，应用程序线程需要被瞬间 &quot;冻结&quot;。这个过程被称为垃圾收集（GC）。GC是低延迟应用程序开发人员放弃 Java 的主要原因。&lt;/p&gt;
&lt;p&gt;市场上Java 虚拟机最常见和标准的是 Oracle Hotspot JVM，它在 Java 社区中被广泛使用，主要是出于历史原因。对于要求非常高的应用程序，Azul Systems 提供了一个很棒的替代方案，称为 Zing。&lt;strong&gt;Zing是Oracle Hotspot JVM一个强大的替代品。Zing解决了GC暂停和JIT编译问题。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;让我们来研究使用Java的固有问题和可能的解决方案。&lt;/p&gt;
&lt;h2 id=&quot;理解java即时编译器&quot;&gt;&lt;strong&gt;理解Java即时编译器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;像C++这样的语言被称为编译语言，因为交付的代码完全是二进制的，可以直接在CPU上执行。PHP或Perl 被称为解释语言，因为解释器（安装在目标机器上）会边运行边编译每一行代码。&lt;/p&gt;
&lt;p&gt;Java介于两者之间；它将代码编译成所谓的 Java 字节码，而字节码又可以在它认为合适的时候被编译成二进制。Java之所以不在启动时编译代码，与长期的性能优化有关。通过观察应用程序的运行情况，分析实时的方法调用和类的初始化，Java 会编译经常调用的部分代码。它甚至可能会根据经验做出一些假设（这部分代码永远不会被调用，或者这个对象永远是一个 String）。&lt;/p&gt;
&lt;p&gt;因此，实际编译后的代码速度非常快，但依然有3个缺点。&lt;/p&gt;
&lt;p&gt;1、一个方法需要被调用一定的次数来达到编译阈值，然后才能被优化和编译（这个限制是可以配置，但通常是10000 次左右的调用）。在此之前，未经优化的代码并没有以 &quot;全速&quot; 运行。Java在更快的编译和高质量的编译之间做了一个取舍（如果假设不对，会有重新编译的代价）。&lt;/p&gt;
&lt;p&gt;2、当Java应用程序重启时，又回到了原点，必须等待再次达到这个阈值。&lt;/p&gt;
&lt;p&gt;3、有些应用程序（比如我们的场景）有一些不频繁但很关键的方法，这些方法只会被调用少数几次，但当它们被调用时，需要极快的速度（想想看，一个风险或止损函数只有在紧急情况下才会被调用）。&lt;/p&gt;
&lt;p&gt;Azul Zing通过让其JVM将编译后的方法和类的状态 &quot;保存&quot; 在它所谓的配置文件中来解决这些问题。这种名为 ReadyNow！® 的独特功能，意味着Java应用程序始终以最佳速度运行，即使在重新启动后也是如此。当使用现有的配置文件重新启动应用程序时，Azul JVM会立即调用其先前的结果并直接编译标注的的方法，从而解决了 Java 预热问题。&lt;/p&gt;
&lt;p&gt;此外，可以在开发环境中建立一个配置文件，以模拟生产行为。然后，优化后的配置文件可以部署在生产环境中，因为所有的关键路径都被编译和优化了。Zing的延迟随着时间的推移保持相当稳定。百分位数分布表明，1%的时间里，Hotspot JVM产生的延迟是 Zing JVM的16倍。&lt;/p&gt;
&lt;h2 id=&quot;解决垃圾收集（gc）暂停的问题&quot;&gt;解决垃圾收集（GC）暂停的问题&lt;/h2&gt;
&lt;p&gt;在垃圾收集过程中，整个应用程序可能会冻结几毫秒到几秒不等（延迟随着代码复杂度和堆大小而增加），更糟糕的是，你无法控制这种情况何时发生。虽然暂停一个应用程序几毫秒甚至几秒钟对于许多Java应用程序来说可能是可以接受的，但对于低延迟应用程序来说却是一场灾难，无论是汽车、航空航天、医疗还是金融领域。&lt;/p&gt;
&lt;p&gt;GC的影响在Java开发者中是一个很大的话题；一个完整的垃圾收集通常被称为 &quot;stop-the-world&quot;，因为它会冻结整个应用程序。&lt;br/&gt;多年来，许多GC算法都试图在吞吐量（多少CPU用于实际的应用逻辑而不是垃圾收集）与 GC暂停之间做一个取舍。&lt;/p&gt;
&lt;p&gt;自Java 9以来，G1 收集器一直是默认 GC，其主要思想是根据用户提供的时间目标来划分GC暂停时间。它通常提供较短的暂停时间，但代价是较低的吞吐量。此外，暂停时间会随着堆的大小而增加。Java提供了大量的设置来调整其垃圾收集（以及 JVM），从堆大小到收集算法，以及分配给GC的线程数。所以，看到Java应用程序配置了大量的自定义选项是很常见的。&lt;/p&gt;
&lt;p&gt;很多开发者已经转向各种技术来完全避免GC。主要思路是，如果创建的对象少了，需要清除的对象就会变少。一个古老的技术是使用可重用对象的对象池。例如，一个数据库连接池将持有10个已打开的连接的引用，准备在需要时使用。&lt;/p&gt;
&lt;p&gt;多线程通常需要锁，这会导致同步延迟和暂停（特别是当它们共享资源时）。一个流行的设计是一个环形缓冲队列系统，在一个无锁的设置中，有许多线程写和读。一些专家甚至选择完全自己实现 Java 内存管理，自己管理内存分配，虽然解决了一个问题，但却带来了更多的复杂性和风险。在这种情况下，显然应该考虑其他 JVM，于是我们决定尝试 Azul Zing JVM。很快，我们就实现了非常高的吞吐量，停顿可以忽略不计。&lt;/p&gt;
&lt;p&gt;这是因为Zing使用了一个独特的收集器，叫做C4（Continuurrentously Concurrent Compacting Collector），它允许无暂停地收集垃圾，而不关心Java堆的大小（最高可达8TB）。这是通过在应用程序仍在运行时，并发映射和压缩内存来实现。此外，它不需要修改任何代码，延迟和速度的提升都是开箱即见，无需冗长的配置。在这种情况下，Java程序员可以享受到两全其美的好处，既可以享受到 Java 的简单性（无需偏执于创建新对象），又可以享受到Zing的底层性能，使整个系统的延迟高度可预测。&lt;/p&gt;
&lt;p&gt;多亏了GC easy，一个通用的GC日志分析器，我们可以在真实的自动交易应用中（在模拟环境中）快速比较两种JVM。在高频交易的应用中，使用Zing的GC比使用标准的 Oracle Hotspot JVM 小 180 倍左右。更令人印象深刻的是，GC暂停通常与实际应用暂停时间相对应，而Zing智能GC通常是在最小或没有实际暂停的情况下平行发生的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Java在享受简单性和面向业务的特性同时，仍然可以实现高性能和低延迟。虽然C++ 仍然可用于特定的底层组件，如驱动程序、数据库、编译器和操作系统，但大多数现实中都可以用Java来开发，包括象高频交易这样要求苛刻的应用。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.sousou88.com/album/javajdkquanji.html&quot;&gt;java jdk 下载&lt;/a&gt; 来自 &lt;a href=&quot;http://www.sousou88.com&quot;&gt;嗖嗖下载&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 05 Nov 2020 23:56:00 +0000</pubDate>
<dc:creator>王泽宾</dc:creator>
<og:description>Java在享受简单性和面向业务的特性同时，仍然可以实现高性能和低延迟。虽然C++ 仍然可用于特定的底层组件，如驱动程序、数据库、编译器和操作系统，但大多数现实中都可以用Java来开发，包括象高频交易这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wanghao72214/p/13934471.html</dc:identifier>
</item>
<item>
<title>我倒在了美团面试算法题：字符串大数相加 - 测试老树</title>
<link>http://www.cnblogs.com/df888/p/13933920.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/13933920.html</guid>
<description>&lt;p&gt;话说之前换工作的时候，我经历了一次美团的视频面试。&lt;/p&gt;
&lt;p&gt;不像腾讯面试有自家软件，美团面试是在第三方网页上进行的，长这样：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201105205655646-1477160665.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;看见中间的代码编辑区，我笑了，难道？真的？算法？&lt;/p&gt;
&lt;p&gt;我的算法，有点差呀。而且没怎么刷过题。&lt;/p&gt;
&lt;p&gt;默默祈祷不要考算法。&lt;/p&gt;
&lt;p&gt;可就在我以为面试要结束的时候，该来的还是来了。&lt;/p&gt;
&lt;p&gt;题目：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;给定两个字符串形式的非负整数 num1 和 num2，计算它们的和。
注意，不能把 string 转换为 int 后直接相加。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;面试官笑了，我也笑了，好，我写一下。&lt;/p&gt;
&lt;p&gt;我隐约记得是模拟人工手算：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201105205656181-1672906390.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;一位一位来加，有进位就在左边那位加个 1。&lt;/p&gt;
&lt;p&gt;因为没有刷过题，只能按我自己的思路去写，越写越乱，最后还是没能写出来。&lt;/p&gt;
&lt;p&gt;面完后，我不禁陷入了沉思。&lt;/p&gt;
&lt;p&gt;测试需要学算法？部分需要。&lt;/p&gt;
&lt;p&gt;哪些需要？大厂、高级职位、测试开发。&lt;/p&gt;
&lt;p&gt;怎么练？刷题。&lt;/p&gt;
&lt;p&gt;哪里刷？力扣。&lt;/p&gt;
&lt;p&gt;本文就跟大家讲一下字符串大数相加的算法。希望在面试时被问到了，能自信的写出来。&lt;/p&gt;
&lt;p&gt;对这个算法，首先要考虑的是，怎么来遍历这 2 个数，可以用 2 个指针，分别指向这 2 个数的尾部，边计算边向左移动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数的长度可能会不一样&lt;/strong&gt;，短的那个数的指针就会先到达最左边的头部，为了能够继续计算，可以给缺失的位补 0。&lt;/p&gt;
&lt;p&gt;加数长度不一致的问题就解决了。&lt;/p&gt;
&lt;p&gt;指针的数相加后，可以通过&lt;strong&gt;除以 10 的余数&lt;/strong&gt;，来算出当前位的结果。&lt;/p&gt;
&lt;p&gt;进位，则可以通过&lt;strong&gt;对 10 的整除数&lt;/strong&gt;，来算。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201105205656429-1763396329.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;指针指向的 2 个数是 5 和 6。&lt;/p&gt;
&lt;p&gt;5 + 6 = 11，用 tmp 变量来存，tmp = n1 + n2 + carry，因为有可能右边有进位，需要加上。&lt;/p&gt;
&lt;p&gt;11 对 10 的整除数是 1，用 carry 来存进位。&lt;/p&gt;
&lt;p&gt;11 除以 10 的余数是 1，用 res 来存结果，需要在 res 最左边添加 &quot;1&quot;，把 “9084” 变为 “19084”。&lt;/p&gt;
&lt;p&gt;最后分析代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    # 加法函数，入参num1和num2，返回计算结果，str类型
    def addStrings(self, num1: str, num2: str) -&amp;gt; str:
        res = &quot;&quot;
        # 定义i,j两个指针，分别指向两个数的尾部
        # 定义进位，默认0
        i, j, carry = len(num1) - 1, len(num2) - 1, 0
        # 循环，直到2个指针都到达头部
        while i &amp;gt;= 0 or j &amp;gt;= 0:
            # 如果没有到达头部，就通过-'0'转为int
            # 如果到达头部了，就补0
            n1 = num1[i] - '0' if i &amp;gt;= 0 else 0
            n2 = num2[j] - '0' if j &amp;gt;= 0 else 0
            # n1 + n2 + carry
            tmp = n1 + n2 + carry
            # 进位 = 对10的整除数
            carry = tmp // 10
            # 结果左边添加除以10的余数
            res = str(tmp % 10) + res
            # 每次计算后向左移动1位
            i, j = i - 1, j - 1
        # 2个指针都到达了头部，如果还有进位，就在res左边添加&quot;1&quot;
        # 否则直接返回res
        return &quot;1&quot; + res if carry else res
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考资料：力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/add-strings/&quot;&gt;415. 字符串相加&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后的最后，希望大家都能找到满意的工作，拿到超高的薪资。我也会继续向大厂努力。&lt;/p&gt;
</description>
<pubDate>Thu, 05 Nov 2020 23:50:00 +0000</pubDate>
<dc:creator>测试老树</dc:creator>
<og:description>字符串大数相加算法。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/13933920.html</dc:identifier>
</item>
<item>
<title>对于技术岗位而言，开发岗累还是算法岗累呢？ - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/13934940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/13934940.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近由于校招如火如荼，一些小伙伴在后台以及知乎上问我，在开发和算法之间犹豫，不知道如何抉择，想要问问究竟哪一个岗位更好？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恰好我之前在知乎上回答过“&lt;strong&gt;对于技术岗位而言，开发岗累还是算法岗累呢&lt;/strong&gt;？”的问题，于是将它搬运了过来，希望能给大家一点启发和帮助。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解我的朋友可能都知道，2015年的时候我在阿里妈妈的算法岗位实习，然而找工作的时候我阴差阳错地去了某公司的开发岗位。做了一年之后，由于各种原因，有点后悔当初的选择于是又想办法转回到了算法岗位上。所以说这两个岗位我都待过，所以就各自来谈谈它们的缺点。有的时候我们不知道我们想要什么，但往往清楚我们不能接受什么。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个岗位虽然说起来都是工程师、技术岗，但是两者的工作内容和性质差得真不是一点半点。从业当中，也都有心力交瘁的时候，但是体验和触发条件都不太一样。简单说一说。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先说开发，我个人在做开发的时候，蛋疼点主要有以下几个。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;开发篇&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;on call&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;on call可以理解成&lt;strong&gt;随时等待召唤&lt;/strong&gt;的意思，一般来说重要项目的开发人员都是7 x 24小时on call的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要线上有问题，一定会有电话打进来。凌晨两三点也不是没有可能，而且很多时候，这些问题未必是你的锅，很有可能只是因为某某项目的负责人上有你的名字。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这点我想应该大小公司都有，之前和蚂蚁的同事聊天，他给我吐槽说他&lt;strong&gt;凌晨起夜已经成了习惯&lt;/strong&gt;。因为好像蚂蚁到了晚上还有很大的流量，经常hbase抖动，每次抖动都会有电话打过来。还有什么烧烤吃了一半突然线上GG了，狂奔回公司查问题的，都不算是事。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不仅工作日如此，周末、假期都必须响应。所以基本上&lt;strong&gt;电脑随身携带是肯定的&lt;/strong&gt;，哪怕是过年回家、出国旅游基本上也都要带着电脑。而且根据墨菲定律，千万不要有侥幸，我侥幸过两次，都中招了。最夸张的一次，在香港太平山上拿着手机看代码。。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么？线上故障的时候，你睡得太死了没听到电话？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Emmmm，轻则被leader说上几句，重则，可能你需要准备一下简历了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;大促熬夜&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**只要是电商公司，没有不大促的，只要大促，没有不要熬夜的。**所以可以简单理解成只要是电商公司，那么一定会有熬夜。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大促意味着巨大的流量，自然对系统的稳定性是一个顶级的考验。就拿双十一举例，你以为只要在双十一当天多准备几台机器就好了？too young，在真正大促到来之前我们&lt;strong&gt;需要做很多轮的模拟流量检测&lt;/strong&gt;，怎么模拟呢？就是搞一堆虚假的请求过来发送到服务器，看看服务器能不能抗住。这种模拟测试在行内称为压测，也叫压力测试。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说每次大促至少两轮压测，由于压测可能导致系统问题，所以不能放在流量高峰期，也就是白天，只能晚上夜深人静的时候搞压测。那么你想嘛，熬夜就是必不可少的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就算两次压测好了，两次压测加上大促当天的值班，至少每次大促都需要熬三天夜。每次熬夜，至少要两三点才能睡觉。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来来来，你告诉我，这样的大促一年有几次？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;光数的出来的大促就有四次，321， 618， 11.11， 12.12……而且现在这个大促的次数还有明显地增加的趋势。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;并发工作&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作当中最令人感受不好的就是并发工作，也就是一件事情你还没忙完，甚至刚刚做出一点眉目，立刻就被其他更加紧急的事情打断。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你在查一个bug，刚刚锁定了大概导致bug的代码区域，还没有具体检查出来，突然测试就告诉你她发现了新的bug。或者是产品过来跟你聊一个新的需求，或者是有人找你问一些关于你们系统的问题。&lt;strong&gt;这种连轴转的感觉是最痛苦的，只要很短的时间就会让人心力交瘁&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这个问题并不只是在开发岗位出现，其实任何岗位都有可能出现这个问题。但是相对来说，开发岗位出现这种情况的概率更高。因为开发往往负责的是一个或者多个系统，系统大了可能出现的各种各样的问题就很多。并且还会有很多使用系统的人问你问题，很容易出现这种情况。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;其他问题&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面三点之外，其他蛋疼的点也很多。不过相比之下没有那么严重，所以我就放在一起说了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如大多数公司&lt;strong&gt;文档都不健全&lt;/strong&gt;，对于开发来说接收陈年项目非常容易踩坑。而且很多时候需要直接去读源码，如果碰到之前的工程师代码能力不行的话，会导致代码非常难读，就跟眼睛被针扎了似的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有就是&lt;strong&gt;肝deadline的现象非常严重&lt;/strong&gt;，每一个产品提的需求总会给你设一个deadline。有时候总会有各种各样的意外发生，导致你需要爆肝才能赶得上进度。比如线上出了故障排查了两天，或者是临时加了一个紧急的需求等等，无休无止地爆肝真的会让人崩溃。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一点是&lt;strong&gt;经常重复性工作&lt;/strong&gt;，今天增删改查，明天改查增删。面试的时候高并发、分布式，进去工作之后curd。经年累月没有成长，如果是大公司的话，很多人干几年也没有过从0开始真正搭建项目的经验。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候产品或者运营或者是老板不好沟通也是一个问题。要么是不懂技术沟通成本很高，要么就是无脑强势，不懂装懂，我不管你觉得，我要我觉得。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;算法篇&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;SQL boy&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人被算法岗吸引，就是觉得算法岗高大上，机器学习，人工智能。但其实真正从事之后，会发现根本不是那么回事。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在小公司，整天为数据发愁，不是这个数据没有，就是平台或者工具稀烂。如果在大公司，数据、平台、工具都有了，但是每天当&lt;strong&gt;SQL boy&lt;/strong&gt;。你和业务谈算法，业务说明天上线，先统计上一版。老板整天告诉你，我想看这个、这个和那个，你去帮我跑一下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想说抽空能把某个模型优化一下，结果发现手上排的SQL根本写不完。机器学习、深度学习的模型我明明会一堆，但是眼下的事情永远只有SQL和数据。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;问题难定位&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做算法的过程，很多时候是一个和自己较劲的过程。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为模型和开发的代码不同，开发用代码实现的功能结果是明确的，原因是可追溯的。但是模型不是，经常在别人场景下效果好的方法到你这里一团稀烂。特别是你老板报以期望的方法，你很难解释……&lt;strong&gt;太多的可能性导致模型性能不好了&lt;/strong&gt;，可能是训练数据有问题，可能是特征有问题，有可能是流程有bug，但是老板不管这些，他们需要的是确定的结果。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且很多人觉得查问题很简单嘛，你找几笔数据来看一下不就知道了？还有一些不懂装懂的路人，哎呀你用这样这样不就可以了？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;大数据时代，只有相关性，没有因果性&lt;/strong&gt;。几笔数据能够代表全部吗？我抽了几笔看了没问题，就能代表全部数据没问题吗？换句话说几笔数据有点小问题，就能代表这个是导致模型不行的原因吗？千万别信，信了就是大坑等着你。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我最头疼的就是老板让我去查某个问题，简直是玄学，如果是明显的问题还好，如果不是，你可能跑一堆SQL，看一堆数据还是一无所获。更蛋疼的是，可能一切都没问题，但就是效果不好，你也不知道为什么，毕竟神经网络是个黑盒。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;忽悠和大忽悠&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;算法行业的忽悠很多&lt;/strong&gt;，心态不好的人很有可能会扛不住。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也是因为现在算法太火了，很多不明就里的人会用仰望的目光来审视。某些时候这个是好事，比如当和投资人聊钱的时候。但大部分情况下，则未必。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如某些决策者会有错觉，会有幻想，比如&lt;strong&gt;会提出一些他们自己都不信的口号&lt;/strong&gt;。喊口号不是问题，但问题是口号里的指标要你去落实。你会发现你很有可能忍不住想要打人的冲动，其实老板也不是白痴，他们心里也门清，可能也是为了应付更高层的老板或者是投资人而已。有点像是晚晴鸦片战争时期的官员，从上到下都知道打不过英国人，但是总得想出点办法来去写篇“捷报”，不然怎么升官发财？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前遇到过这么一档子事，说是公司的日活用户一直在降低，公司希望用机器学习的模型来筛选一批贪财的用户，给他们发5块钱红包。这样他们为了贪这5块钱就会一直活跃，也就带来了日活的增长，这样就可以和更高层的老板交差了。看起来这个逻辑非常清晰，毫无破绽。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但问题是，当时的日活有三百万，每天发多少红包呢？只有几万个。你说应该怎么办，即使算法选出来的每个用户都不流失了，那难道就能增长了？入不敷出的成语学过没有？老板才不管，&lt;strong&gt;你只管去做，做不好就是你能力不行&lt;/strong&gt;。这种情况怎么办？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，这行吹逼的情况非常严重，简直章口就来。反正别人不知道你到底怎么做的，面试的时候有些人吹得那叫一个天花乱坠。当很多人都这么做获得好处，而你坚持底线，一直默默无闻的时候。你很难不对你的信念产生怀疑，究竟错的是你呢，还是这个世界？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上，只是我一家之言，如果言中，请勿对号入座。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，&lt;strong&gt;世上没有完美的职业，总要有所得有所失。如果你能明白可以忍受什么，不能接受什么&lt;/strong&gt;， 我想，你一定可以做出不后悔的选择。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就到这里，衷心祝愿大家都能找到称心如意的工作。如果还喜欢今天的内容的话，请来一个&lt;strong&gt;三连支持&lt;/strong&gt;吧~（&lt;strong&gt;点赞、关注、转发&lt;/strong&gt;）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;amp;mid=2247487971&amp;amp;idx=1&amp;amp;sn=19dda02c232633294f4c98eca44dbdd0&amp;amp;chksm=f9daecc8cead65dec6c5e3fd33ff6574d24fbd948ca744dfb3529aee59568e159114214c2839&amp;amp;token=1644976477&amp;amp;lang=zh_CN#rd&quot;&gt;原文链接，求个关注&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;nice-suffix-juejin-container&quot; class=&quot;nice-suffix-juejin-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;本文使用 &lt;a href=&quot;https://mdnice.com/?from=juejin&quot;&gt;mdnice&lt;/a&gt; 排版&lt;/p&gt;
</description>
<pubDate>Thu, 05 Nov 2020 23:33:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>最近由于校招如火如荼，一些小伙伴在后台以及知乎上问我，在开发和算法之间犹豫，不知道如何抉择，想要问问究竟哪一个岗位更好？ 恰好我之前在知乎上回答过“对于技术岗位而言，开发岗累还是算法岗累呢？”的问题，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/13934940.html</dc:identifier>
</item>
<item>
<title>理解内存对齐 - orlion</title>
<link>http://www.cnblogs.com/orlion/p/13934929.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/orlion/p/13934929.html</guid>
<description>&lt;p&gt;原文地址: &lt;a href=&quot;https://blog.fanscore.cn/p/24/&quot;&gt;https://blog.fanscore.cn/p/24/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相信大家都听说过内存对齐的概念，不过这里还是通过一个现象来引出本篇话题。&lt;/p&gt;

&lt;p&gt;猜下下面这个结构体会占用多少字节&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type S struct {
    B byte  // Go中一个byte占1字节，int32占4个字节，int64占8个字节
    I64 int64
    I32 int32
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是以为是1+8+4 = 13个字节？写段代码验证下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type S struct {
        B   byte
        I64 int64
        I32 int32
}

func main() {
        s := S{}
        fmt.Printf(&quot;s size:%d\n&quot;, unsafe.Sizeof(s))
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s size:24
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与预想显然不同，这是为什么呢？答案是编译器替我们做了内存对齐。&lt;/p&gt;

&lt;p&gt;要理解这个问题需要先了解一下字长的概念以及内存的物理结构&lt;/p&gt;
&lt;h2 id=&quot;21-字长&quot;&gt;2.1 字长&lt;/h2&gt;
&lt;p&gt;在计算器领域，对于某种特定的计算机设计而言，字（word）是用于表示其自然的数据单位的术语。在这个特定计算机中，字是其用来一次性处理事务的一个固定长度的位（bit）组。一个字的位数即为&lt;strong&gt;字长&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;字长在计算机结构和操作的多个方面均有体现，&lt;strong&gt;计算机中大多数寄存器（这里应该是指通用寄存器）的大小是一个字长&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;上面这段话可能太过于概念化不太好理解，那么请看下面的这段64位机器上的GUN汇编器语法的汇编代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;movq (%ecx) %eax
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段汇编代码是将eax这个寄存器中的数据作为地址访问内存，并将内存中的数据加载到eax寄存器中。&lt;/p&gt;
&lt;p&gt;我们可以看到mov指令的后缀是&lt;code&gt;q&lt;/code&gt;，意味着该指令将加载一个64位的数据到eax寄存器中，这样一条指令可以操作一个64位的数据，说明该机器的字长为64位，同时这段代码能够执行则说明我们机器上的CPU中的&lt;strong&gt;eax寄存器必定是64位&lt;/strong&gt;的，而一条指令能够从内存中加载一个64位的数据也说明了&lt;strong&gt;数据总线的位宽也为64位&lt;/strong&gt;，说明了我们的CPU可以一次从内存中加载8个字节的数据。&lt;/p&gt;
&lt;h2 id=&quot;22-64位内存物理结构&quot;&gt;2.2 64位内存物理结构&lt;/h2&gt;
&lt;p&gt;内存是由若干个黑色颗粒组成的，每个内存颗粒叫做一个chip，每个chip是由8个bank组成，每个bank是二维平面上的矩阵，矩阵中的每个元素保存1个字节也就是8个bit。&lt;/p&gt;
&lt;p&gt;对于内存中连续的8个字节比如0x0000-0x0007，并非位于一个bank上，而是位于8个bank上，每个bank保存一个字节，8个bank像是垂直叠在一起，物理上它们并不是连续的。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/11/03/4dyxMRwqVcH69Ns.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;之所以这样设计是基于电路工作效率考虑，这样的设计可以并行取8个字节的数据，如果想取址0x0000-0x0007，每个bank只需要工作一次就可以取到，IO效率比较高，如果这8个字节在同一个bank上则需要串行读取该bank8次才能取到。&lt;/p&gt;
&lt;p&gt;结合上面的结构图可以看到0x0000-0x0007是一列，0x0008-0x000F是另外一列，如果从内存中取8-15字节的数据也可以一次取出来，但如果我们要取1-9的数据就需要先取0-7的数据，再取8-15的数据然后拼起来，这样的话就会产生两次内存IO。所以基于性能的考虑某些CPU会强制只能读取8的倍数的内存，而这也导致了编译器再此类平台上编译时&lt;strong&gt;必须&lt;/strong&gt;做内存对齐。&lt;/p&gt;
&lt;h2 id=&quot;23-再来看结构体size的问题&quot;&gt;2.3 再来看结构体size的问题&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以下均以64位平台，即：64位宽内存以及64位cpu(数据总线64位，寄存器64位)为前提&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;type S struct {
    B byte
    I64 int64
    I32 int32
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在不了解内存对齐前我们可能会简单以为结构体在内存中可能是这样排列的：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/11/03/2xRWIuOD5ty9lrU.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;总共占用13个字节。我们可以看到 &lt;code&gt;I64&lt;/code&gt; 这个字段的内存地址是1-8，而在64位平台上为了将这个字段加载到寄存器中，CPU需要两次内存IO。&lt;br/&gt;但做内存对齐后：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/11/03/HvkXfw5BC9xP487.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;总共占用20个字节，&lt;code&gt;I64&lt;/code&gt;这个字段的内存地址是8-15，为了将这个字段加载到寄存器中，只需要一次内存IO即可。&lt;br/&gt;我们写段代码验证下是否真的占用了20个字节：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type S struct {
        B   byte
        I64 int64
        I32 int32
}

func main() {
        s := S{}
        fmt.Printf(&quot;s size: %d, align: %d\n&quot;, unsafe.Sizeof(s), unsafe.Alignof(s))
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s size: 24, align: 8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出了24，而非上面我们以为的20，这是怎么回事呢？原因是&lt;strong&gt;结构体本身也必须要做对齐&lt;/strong&gt;，它必须在后面再额外占用4个字节以使自己的size为8的倍数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;上面的结构体如果后面跟一个4字节的变量的话理论上说不用对齐也能保证一次内存IO就可加载，所以结构体对齐的根本原因目前我还不是特别能理解，可能为编译器做的优化，了解的同学欢迎在评论区指点一下
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再调整下结构体的声明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type S struct {
    B byte
    I32 int32
    I64 int64
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再做内存对齐的话该结构体在内存中应该就是下面这个样子了：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/11/03/MYlvnj31zAo7dTZ.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这时总共占用16个字节，相比较上面我们节省了8个字节。&lt;br/&gt;写段代码验证下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;type S struct {
        B   byte
        I32 int32
        I64 int64
}
func main() {
        s := S{}
        fmt.Printf(&quot;s size:%v, s.B地址:%v, s.I32地址:%v, s.I64地址:%v\n&quot;, unsafe.Sizeof(s), &amp;amp;s.B, &amp;amp;s.I32, &amp;amp;s.I64)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s size:16, s.B地址:0xc0000b4010, s.I32地址:0xc0000b4014, s.I64地址:0xc0000b4018
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;确实占用了16字节，但貌似&lt;code&gt;I32&lt;/code&gt;这个字段跟我们预想的不太一样，它被对齐到了4的倍数地址上，而非紧跟在&lt;code&gt;B&lt;/code&gt;后边，这大概是编译器考虑到用户可能使用32位cpu/内存而导致的，目前没有查到相关资料姑且这么认为吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%AD%97_(%E8%AE%A1%E7%AE%97%E6%9C%BA)&quot;&gt;字 (计算机)&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/83449008&quot;&gt;带你深入理解内存对齐最底层原理&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Nov 2020 23:23:00 +0000</pubDate>
<dc:creator>orlion</dc:creator>
<og:description>原文地址: https://blog.fanscore.cn/p/24/ 相信大家都听说过内存对齐的概念，不过这里还是通过一个现象来引出本篇话题。 一、求一个结构体的size 猜下下面这个结构体会占用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/orlion/p/13934929.html</dc:identifier>
</item>
<item>
<title>技术总监7年总结——程序员进阶高管的三次跃升 - pointersss</title>
<link>http://www.cnblogs.com/pointers/p/13934925.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pointers/p/13934925.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4XQ0RVoHjpx5goZfBeXlEAXKs4NWzw4NicUh9cibYTkicNGvnKxDEic4tgm0CVlGYj9ib9o9FW4LGcpR7q3lEeA3yVA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;成长&amp;amp;认知&lt;/strong&gt; 丨 作者 / 袁吴范&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这是&lt;strong&gt;pointers公众号&lt;/strong&gt;分享的第&lt;strong&gt;15&lt;/strong&gt;篇原创文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的粉丝中很多人都跟我谈过他们的职业困惑，其中有一些刚刚毕业，有些人已经工作超过10年。&lt;/p&gt;
&lt;p&gt;基本上是围绕着怎样持续提升，怎样晋升为高级管理者。&lt;/p&gt;
&lt;p&gt;那么这篇文章，我就来谈一谈程序员到高管的跃升之路。&lt;/p&gt;
&lt;p&gt;从象牙塔毕业跨入社会大染缸，经过3年5年之后，在成长的历程中，有三次极其重要的跃升。如果跨不上去，你的高度也就到此为止了。&lt;/p&gt;
&lt;hr/&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;em&gt;所谓技术跃升就是：&lt;strong&gt;从个人初做者，到个人贡献者&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;第一跃升是从个人初做者，到个人贡献者。这个跃升，是从门外汉，变为能力者。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这次的跃升，是你真正叩开了把事情做正确的大门。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当你还是初做者时，你的能力是这样的：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpzmALGYxKsKBVVhDxzVoFDDkxImiafPgPtpkUB6r3cz0XIRArueDMwhnMe58sCZwrE5oF8CvF3FECA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;而一旦你成为了个人贡献者时，你的能力已经得到了提升：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpzmALGYxKsKBVVhDxzVoFDDficAX41PFficX30ia93lcaN5eibpfgDOmM6XiaolqicXkIvTiaMtRFsOMlJuQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;那么如何能够能力跃升，下面是几个方面你要达成。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一个就是目标升级。&quot;&gt;&lt;em&gt;&lt;strong&gt;第一个就是目标升级。&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;就是对自己有严格的要求，从之前的无目标、无清晰目标变为有清晰可达成的目标。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;很多同学在学校中，踌躇满志，充满着抱负，心怀梦想，渴望成功。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;但进入到企业中之后，一下子没了目标，也没有及时调整好自己的心态，就会进入一种故步自封，不思进取的状态。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;所以一定要有自己的目标，需要升级的自己目标。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;那应该怎样设置目标呢？&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一定是满足smart原则，不要给自己设置不可达成的目标。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这种目标一旦完不成，反而成为你释放罪恶感的理由。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;给自己定好阶段目标。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;1年内要完成什么学习&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2年内要熟悉什么系统&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3年内要提升什么能力&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;…&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;目标升级是能力跃升最基本的要求。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果一个人连目标都没有，跟咸鱼有何区别。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第二个就是学习升级。&quot;&gt;&lt;em&gt;&lt;strong&gt;第二个就是学习升级。&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;在学生时代，我们学习新知识&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这种学习方式是系统学习。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;但进入企业，显然没有大把的时间系统化的学习。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;企业是要实现商业目的，这是他的唯一目的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;那如何高效的学习呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;就需要从系统学习法，升级为多维学习法。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;什么意思？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;就是以点带面的方式为主，系统学习法为辅的方式。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;在工作中，往往只需要集中全力解决一个具体的问题。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;但这些问题点背后一定有一个较完整和深入的知识结构。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;所以，工作做完后，还需要继续学习背后的知识结构。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;以网络编程为例，我15年时候做了一个工具，设备发现的工具，利用的udp多播的技术，很快就顺利的开发完了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;但是学习还刚刚开始，&lt;strong&gt;里面有很多可以深挖的技术：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从udp扩展开，可以延伸到网络技术的各个角落，从用户态到内核态，从API到具体实现方法，从数据结构到算法，这是一套完整的知识体系。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第三个是思考升级&quot;&gt;&lt;em&gt;&lt;strong&gt;第三个是思考升级&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;你要从&lt;strong&gt;简单的思考模式，升级到深度思考&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;什么意思？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;工作中我们会面临着诸多疑难问题，你可以凭借经验，把问题解决，但如果新的问题出现时，你却显得束手无策。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这是为什么呢？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;因为你缺少思考能力，尤其是深度思考的能力。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;深度思考不是天生就有，可以后天培养的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;通过熟练掌握方法论，来习得深度思考。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其一，&lt;strong&gt;5why分析法，&lt;/strong&gt;又称“5问法”，也就是对一个问题点连续以5个“为什么”来自问，以追究其根本原因。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其二，&lt;strong&gt;逆向思维，&lt;/strong&gt;所谓的逆向思维，就是当你不知道怎么做？你就要以大众日常思维相反的方向去思考事情。也就是，不是按照【原因】-&amp;gt;【结果】，而是【结果】-&amp;gt;【原因】。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;其三，&lt;strong&gt;刻意联系，学以致用&lt;/strong&gt;，深度思考是一种习惯，既然是一种习惯，就需要去练习。而且需要大量的刻意练习。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第四个是毅力升级&quot;&gt;&lt;em&gt;&lt;strong&gt;第四个是毅力升级&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;你要从遇到问题就放弃的状态，升级为打破砂锅问到底，持之以恒的状态。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你一定要学会坚持，但我们都是天生就有惰性，惰性很容易把我们打败。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们也经常发现，设立目标很容易，但要实现却很难。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们回过头来看看，因为我们缺乏长期性的坚持，缺少了持之以恒而导至的失败是不是非常地多？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;正所谓&quot;念念不忘，必有回响&quot;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;你认准的是目标，通过不断地努力，不要轻易放弃，最后我们就会发现，这个赛道只会剩你一个人&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这上面4个升级，&lt;strong&gt;目标、学习、思考、毅力&lt;/strong&gt;能够循序渐进，全部完成。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我相信你的能力能够得到跃升。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;center&gt;

&lt;/center&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;em&gt;第二次跃升，是从个人贡献者，到基层管理者。这个跃升，是单枪匹马，变为团队作战。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这次的跃升，是你真正叩开了管理的大门。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;虽然只是叩开了大门，但这对你来说，是整个能力系统的改变。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当你还是个人贡献者时，你的能力是这样的：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpzmALGYxKsKBVVhDxzVoFDDficAX41PFficX30ia93lcaN5eibpfgDOmM6XiaolqicXkIvTiaMtRFsOMlJuQ/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;而你是基层管理者时，你的能力要求，完全发生了变化：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4XQ0RVoHjpzmALGYxKsKBVVhDxzVoFDDtSibAwJMAXib3HqhKicgvKZyxmTybZAFYqUyr1lq4Xow8GQ13EcEh49PA/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;自己的工作发生了彻底的变化，要求变成了&lt;strong&gt;协调、组织、反馈&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;所以下面这4个升级一定要做到。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一个升级，叫责任升级&quot;&gt;&lt;em&gt;&lt;strong&gt;第一个升级，叫责任升级&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;在个人贡献者的时候，你是对任务负责，交给你一件事情，把任务的细节告诉你，deadline告知你，&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你只需要在deadline之前，把这件事干好，就OK了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;而现在你需要对这个事情的结果负责。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;也就是，同样是一样事情，不是由你亲自去干，而是由你分配任务给到下属，教练指导下属去完成这个任务，&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;这个任务的结果好坏都是由你来承担&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;假如你的领导交给你一个艰巨的任务，命令你的1周之内完成，最后搞砸了，没有按时完成，老板问道是为啥会这样？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你可千万不要推卸责任，就算是下属没有完成任务，也是你的责任。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;切记中间多坎坷，作为基层管理者，你需要想方设法的达成目标&lt;/strong&gt;，因为这是你的责任。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第二个升级，叫做行动升级&quot;&gt;&lt;em&gt;&lt;strong&gt;第二个升级，叫做行动升级&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;你现在从单打独斗，成为了一个团队的管理者。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;可能因为你的技术能力突出，被提拔为组长，经理（基层管理者）。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;作为一个新经理，总是会犯的一个错误，就是“总是觉得别人做的不好，自己亲自来”。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这个想法是非常愚蠢的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一个人能力再强，也干不过一个有组织的团队。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当你是个人贡献者的时候，你的工作也比较纯粹，用你的脑和手，把这件事情干好，就行了&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当你已经是一位基层管理者时，你需要从用脑和手直接行动，升级为用脑指导行动，这是一个彻底行动升级。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;遇到疑难问题需要攻克时，你需要展现你的组织能力，安排好计划，定好合适的责任人，下达你的任务命令。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;要让你的下属了解你的想法，理解的你方式，并且最终顺利完成问题的攻克。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;记住，千万不要替代他们解决问题。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第三个升级，叫做协作升级&quot;&gt;&lt;em&gt;&lt;strong&gt;第三个升级，叫做协作升级&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;在个人贡献者时，你的工作关系，比较简单，组内同事和领导。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当你成为管理者时，你的工作关系，会变得复杂，领导、下属、兄弟同事、外部客户等。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这时候的协作方式就需要发生大的变化，你不仅仅需要考虑下属和领导，还需要考虑其他外部关系。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;关系变得复杂，工作的协作方式也需要升级。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从单纯的组内同事之间的技术协作，升级为组间的配合协作和技术协作的混合模式。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从封闭的协作范围，升级为开发的协作范围。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当你需要开展的一个项目时，你关注的不仅仅是组内的工作，还需要考虑组间的工作情况。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;正如数学概念中的面升级到立体三维空间，协作方式也需要进行全新的升级&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第四个升级，叫做成就升级&quot;&gt;&lt;em&gt;&lt;strong&gt;第四个升级，叫做成就升级&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;现在的你需要从个人成就，升级到团队成就。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;什么意思？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;人的马斯洛需求模型中，从生理需求、安全需求、社会需求、尊重需求、自我实现层层递进。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;人的追求也是一样，通过自身的努力实现自我追求，这是最基本的追求。这也是个人成就。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;通过你的管理，你的下属持续成长，团队能力越来越强，这就是团队成就。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;作为基层管理者，只是单单做到个人成就，不注重成就下属，我们的团队是很难做强的。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;假如：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;当你有一个下属的影响力越来越大，被越来越多人认可的时候，你会怎么想？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果你感觉被威胁，你觉得你的位置不保了。那你也只能做基层管理者了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你要知道，你代表的就是你的整个团队。你下属的成功，就是你的成功；你下属受到的认可，就是你的认可。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一个团队的不强，想想你还能晋升吗？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;作为一个团队的老大，你需要有成就下属的胸怀，才能走的更远。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;如果你 能够完成&lt;strong&gt;责任升级，行动升级，协作升级，成就升级&lt;/strong&gt;，那么你就完成了管理跃升，成为了一名真正的管理者。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;

&lt;center&gt;

&lt;/center&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;em&gt;这次跃升，是从基层管理者，跃升到团队的领导者。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你要成为领导者需要从局部把控，变为对全局的掌握，领导团队运筹帷幄，披荆斩棘，以弱胜强，最终走向胜利。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;要完成这个跃升，需要做到下面2个升级。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一个就是战略升级。&quot;&gt;&lt;em&gt;&lt;strong&gt;第一个就是战略升级。&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;战略（strategy）一词最早是军事方面的概念。是一种从全局考虑谋划实现全局目标的规划。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;是一种长远的规划，是远大的目标，往往规划战略、制定战略、用于实现战略的目标的时间是比较长的。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;而战术只为实现战略的手段之一，基层管理者做的就是战术。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;争一时之长短，用战术就可以达到！如果是“争一世之雌雄”，就需要从全局出发去规划，这就是战略！&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;什么意思？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;运用到企业上就是要”&lt;strong&gt;做正确的事情&lt;/strong&gt;“&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从基层管理的战术层面，把事情做正确，升级为战略层面“做正确的事情”。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;基层管理者最重要的职责，就是带领下属更快、更好地达成公司的战略目标。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;而团队领导者，最重要的职责，是制定公司的战略目标。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;要完成什么目标，怎么和供应商合作？规划未来3到5年做什么。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第二个就是影响力升级&quot;&gt;&lt;em&gt;&lt;strong&gt;第二个就是影响力升级&lt;/strong&gt;&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;影响力是用一种别人所乐于接受的方式，改变他人的思想和行动的能力。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;影响力来源于很多地方，可能是你在公司等级地位，你的技术能力影响，你的个人魅力影响，你的性格特征影响。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;影响力，是一个非常重要的武器。一旦你有了影响力，无论是观点的陈述，障碍的扫除，还是矛盾的化解，这些事情都会轻松搞定。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你还可以建立公司内的价值观，愿景，并且以身作则，激励团队，可以产生巨大的凝聚力。&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;

&lt;center&gt;

&lt;/center&gt;

&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;&lt;em&gt;从程序员到高管的跃升，需要完成三大跃升。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从个人初做者，到个人贡献者。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从个人贡献者，到基层管理者。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;从基层管理者，到团队领导者。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;第一次跃升，是人力到汽车的跃升。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;第二次跃升，是汽车到飞机的跃升。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;第三次跃升，是飞机到飞船的跃升。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;每一次跃升都是脱胎换骨的改变，对能力系统的重构。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;道阻且长，希望大家能够完成三次跃升，笑傲江湖！&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;em&gt;推荐阅读（干货）&lt;/em&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484011&amp;amp;idx=1&amp;amp;sn=e52d915760314e3300c145039ede831b&amp;amp;chksm=cf209779f8571e6f81be5951b70607c2a2518fd0fc94c80c8f96c3331f82bdd6e07807179ce4&amp;amp;scene=21#wechat_redirect&quot;&gt;技术总监7年总结，如何进行正确的沟通？&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483962&amp;amp;idx=1&amp;amp;sn=cc73b3d2124fc23d89ccc4c5c612d18c&amp;amp;chksm=cf209728f8571e3e4345d4737029960d1e5c3f7b005fd4c8545a1ac283c086a73e4ca914ede0&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员如何打造个人品牌？&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483954&amp;amp;idx=1&amp;amp;sn=4d122f3d2330254f5a5ecca3876c46a8&amp;amp;chksm=cf209720f8571e368d1123e185b30e930c83463496b0a9d8b76aec9ebcffeeb1c3f5155cb1dc&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员你应该勇敢说不&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483946&amp;amp;idx=1&amp;amp;sn=7629654c4acf6bd1c5f53639707a9c61&amp;amp;chksm=cf209738f8571e2e66764576dfa494bec92059058c9f2609391ede8c40bc010c167b2d535820&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;聊一聊 软件系统中的“热力学第二定律”&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=a170a555f571d4cbd2c4136b8ed57eff&amp;amp;chksm=cf209711f8571e07d674b4582488fe61e4e64d7179be7cb5ca5574edeee36f207d0cf7b0ea52&amp;amp;scene=21#wechat_redirect&quot;&gt;谈一谈程序员的职业发展路线&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483891&amp;amp;idx=1&amp;amp;sn=24cd8a6abf3b0681179dc5e5e846e0ba&amp;amp;chksm=cf2094e1f8571df70c1e37be4f3a3a81df0165e5e3359006a16ed64730fe9e5cc7fe97c37289&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员进阶必备能力——晋升之道&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483792&amp;amp;idx=1&amp;amp;sn=f30fe58e4ea99d647b1853eca6bd5a6a&amp;amp;chksm=cf209482f8571d94e7dd372851397f98a838e84a9fbea9299337e5ee2301084228a4f57d315c&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;送给刚毕业的程序员——7点建议&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483826&amp;amp;idx=1&amp;amp;sn=c82601363825ba261b88c0198ee3a91d&amp;amp;chksm=cf2094a0f8571db6b69603ba66b1ac62ef588fc3668ffdcddd4ca2fa62713eb8c614e279290b&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员进阶技术专家必备能力——深度思考&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;觉得不错，记得关注、转发和在看！多年经验分享，实属不易，感谢支持！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;br/&gt;博主是一位物联网大厂技术总监，从业7年。从软件开发、高级软件开发、技术经理再到技术总监，分享职业发展、技术管理、职场晋升、技术成长等个人多年经验和心得。一起成长！有问题可以加我微信交流：**pointersss**
&lt;p&gt;&lt;strong&gt;如果你有技术成长的瓶颈、对未来迷茫、也可以关注我公众号，帮你答疑解惑！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4XQ0RVoHjpx4fJoOHia8o9pebg6ffoYJ3SueWibyfyfUpyBqtcmMwSUg5DrJ3bXLPnhrJya3Xjk0JHkJ9uJu7IrA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Nov 2020 23:15:00 +0000</pubDate>
<dc:creator>pointersss</dc:creator>
<og:description>成长&amp;amp;amp;认知 丨 作者 / 袁吴范 这是pointers公众号分享的第15篇原创文章 我的粉丝中很多人都跟我谈过他们的职业困惑，其中有一些刚刚毕业，有些人已经工作超过10年。 基本上是围</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pointers/p/13934925.html</dc:identifier>
</item>
<item>
<title>01 . Go语言实现SSH远程终端及WebSocket - you-men</title>
<link>http://www.cnblogs.com/you-men/p/13934845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/13934845.html</guid>
<description>&lt;h4 id=&quot;cryptossh简介&quot;&gt;Crypto/ssh简介&lt;/h4&gt;
&lt;h4 id=&quot;使用&quot;&gt;使用&lt;/h4&gt;
&lt;h5 id=&quot;下载&quot;&gt;下载&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt; go get &quot;github.com/mitchellh/go-homedir&quot;
 go get &quot;golang.org/x/crypto/ssh&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用密码认证连接&quot;&gt;使用密码认证连接&lt;/h5&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;连接包含了认证,可以使用password或者sshkey 两种方式认证,下面采用密码认证方式完成连接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Example&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;golang.org/x/crypto/ssh&quot;
        &quot;log&quot;
        &quot;time&quot;
)

func main()  {
        sshHost := &quot;39.108.140.0&quot;
        sshUser := &quot;root&quot;
        sshPasswrod := &quot;youmen&quot;
        sshType := &quot;password&quot;  // password或者key
        //sshKeyPath := &quot;&quot; // ssh id_rsa.id路径
        sshPort := 22

        // 创建ssh登录配置
        config := &amp;amp;ssh.ClientConfig{
                Timeout: time.Second, // ssh连接time out时间一秒钟,如果ssh验证错误会在一秒钟返回
                User: sshUser,
                HostKeyCallback: ssh.InsecureIgnoreHostKey(),  // 这个可以,但是不够安全
                //HostKeyCallback: hostKeyCallBackFunc(h.Host),
        }
        if sshType == &quot;password&quot; {
                config.Auth = []ssh.AuthMethod{ssh.Password(sshPasswrod)}
        } else {
                //config.Auth = []ssh.AuthMethod(publicKeyAuthFunc(sshKeyPath))
                return
        }

        // dial 获取ssh client
        addr := fmt.Sprintf(&quot;%s:%d&quot;,sshHost,sshPort)
        sshClient,err := ssh.Dial(&quot;tcp&quot;,addr,config)
        if err != nil {
                log.Fatal(&quot;创建ssh client 失败&quot;,err)
        }
        defer sshClient.Close()

        // 创建ssh-session
        session,err := sshClient.NewSession()
        if err != nil {
                log.Fatal(&quot;创建ssh session失败&quot;,err)
        }

        defer session.Close()

        // 执行远程命令
        combo,err := session.CombinedOutput(&quot;whoami; cd /; ls -al;&quot;)
        if err != nil {
                log.Fatal(&quot;远程执行cmd失败&quot;,err)
        }
        log.Println(&quot;命令输出:&quot;,string(combo))
}

//func publicKeyAuthFunc(kPath string) ssh.AuthMethod  {
//      keyPath ,err := homedir.Expand(kPath)
//      if err != nil {
//              log.Fatal(&quot;find key's home dir failed&quot;,err)
//      }
//
//      key,err := ioutil.ReadFile(keyPath)
//      if err != nil {
//              log.Fatal(&quot;ssh key file read failed&quot;,err)
//      }
//
//      signer,err := ssh.ParsePrivateKey(key)
//      if err != nil {
//              log.Fatal(&quot;ssh key signer failed&quot;,err)
//      }
//      return ssh.PublicKeys(signer)
//}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;代码解读&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 配置ssh.ClientConfig
/*
                建议TimeOut自定义一个比较端的时间
                自定义HostKeyCallback如果像简便就使用ssh.InsecureIgnoreHostKey会带哦,这种方式不是很安全
                publicKeyAuthFunc 如果使用key登录就需要用哪个这个函数量读取id_rsa私钥, 当然也可以自定义这个访问让他支持字符串.
*/

// ssh.Dial创建ssh客户端
/*
                拼接字符串得到ssh链接地址,同时不要忘记defer client.Close()
*/

// sshClient.NewSession创建会话
/*
                可以自定义stdin,stdout
                可以创建pty
                可以SetEnv
*/

// 执行命令CombinnedOutput run...
go run main.go
2020/11/06 00:07:31 命令输出: root
total 84
dr-xr-xr-x. 20 root  root   4096 Sep 28 09:38 .
dr-xr-xr-x. 20 root  root   4096 Sep 28 09:38 ..
-rw-r--r--   1 root  root      0 Aug 18  2017 .autorelabel
lrwxrwxrwx.  1 root  root      7 Aug 18  2017 bin -&amp;gt; usr/bin
dr-xr-xr-x.  4 root  root   4096 Sep 12  2017 boot
drwxrwxr-x   2 rsync rsync  4096 Jul 29 23:37 data
drwxr-xr-x  19 root  root   2980 Jul 28 13:29 dev
drwxr-xr-x. 95 root  root  12288 Nov  5 23:46 etc
drwxr-xr-x.  5 root  root   4096 Nov  3 16:11 home
lrwxrwxrwx.  1 root  root      7 Aug 18  2017 lib -&amp;gt; usr/lib
lrwxrwxrwx.  1 root  root      9 Aug 18  2017 lib64 -&amp;gt; usr/lib64
drwx------.  2 root  root  16384 Aug 18  2017 lost+found
drwxr-xr-x.  2 root  root   4096 Nov  5  2016 media
drwxr-xr-x.  3 root  root   4096 Jul 28 21:01 mnt
drwxr-xr-x   4 root  root   4096 Sep 28 09:38 nginx_test
drwxr-xr-x.  8 root  root   4096 Nov  3 16:10 opt
dr-xr-xr-x  87 root  root      0 Jul 28 13:26 proc
dr-xr-x---. 18 root  root   4096 Nov  4 00:38 root
drwxr-xr-x  27 root  root    860 Nov  4 21:57 run
lrwxrwxrwx.  1 root  root      8 Aug 18  2017 sbin -&amp;gt; usr/sbin
drwxr-xr-x.  2 root  root   4096 Nov  5  2016 srv
dr-xr-xr-x  13 root  root      0 Jul 28 21:26 sys
drwxrwxrwt.  8 root  root   4096 Nov  5 03:09 tmp
drwxr-xr-x. 13 root  root   4096 Aug 18  2017 usr
drwxr-xr-x. 21 root  root   4096 Nov  3 16:10 var

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上内容摘自&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mojotv.cn/2019/05/22/golang-ssh-session&quot;&gt;https://mojotv.cn/2019/05/22/golang-ssh-session&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;websocket简介&quot;&gt;WebSocket简介&lt;/h4&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;HTML5开始提供的一种浏览器与服务器进行双工通讯的网络技术,属于应用层协议,它基于TCP传输协议,并复用HTTP的握手通道:&lt;/p&gt;
&lt;p&gt;对大部分web开发者来说,上面描述有点枯燥,只需要几下以下三点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                1. WebSocket可以在浏览器里使用
                2. 支持双向通信
                3. 使用很简单
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;优点&quot;&gt;优点&lt;/h5&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;对比HTTP协议的话,概括的说就是: 支持双向通信,更灵活,更高效,可扩展性更好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                1. 支持双向通信,实时性更强
                2. 更好的二进制支持
                3. 较少的控制开销,连接创建后,客户端和服务端进行数据交换时,协议控制的数据包头部较小,在不包含头部的情况下,
                                服务端到客户端的包头只有2-10字节(取决于数据包长度), 客户端到服务端的话,需要加上额外4字节的掩码,
                                而HTTP每次同年高新都需要携带完整的头部
                4. 支持扩展,ws协议定义了扩展, 用户可以扩展协议, 或者实现自定义的子协议
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;基于web的terminal终端控制台&quot;&gt;基于Web的Terminal终端控制台&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;完成这样一个Web Terminal的目的主要是解决几个问题:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                1. 一定程度上取代xshell，secureRT，putty等ssh终端
                2. 可以方便身份认证, 访问控制
                3. 方便使用, 不受电脑环境的影响
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;要实现远程登录的功能,其数据流向大概为&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                浏览器 &amp;lt;--&amp;gt;  WebSocket  &amp;lt;---&amp;gt; SSH &amp;lt;---&amp;gt; Linux OS
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;实现流程&quot;&gt;实现流程&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;浏览器将主机的信息(ip, 用户名, 密码, 请求的终端大小等)进行加密, 传给后台, 并通过HTTP请求与后台协商升级协议. 协议升级完成后, 后续的数据交换则遵照web Socket的协议.&lt;/li&gt;
&lt;li&gt;后台将HTTP请求升级为web Socket协议, 得到一个和浏览器数据交换的连接通道&lt;/li&gt;
&lt;li&gt;后台将数据进行解密拿到主机信息, 创建一个SSH 客户端, 与远程主机的SSH 服务端协商加密, 互相认证, 然后建立一个SSH Channel&lt;/li&gt;
&lt;li&gt;后台和远程主机有了通讯的信道, 然后后台将终端的大小等信息通过SSH Channel请求远程主机创建一个 pty(伪终端), 并请求启动当前用户的默认 shell&lt;/li&gt;
&lt;li&gt;后台通过 Socket连接通道拿到用户输入, 再通过SSH Channel将输入传给pty, pty将这些数据交给远程主机处理后按照前面指定的终端标准输出到SSH Channel中, 同时键盘输入也会发送给SSH Channel&lt;/li&gt;
&lt;li&gt;后台从SSH Channel中拿到按照终端大小的标准输出后又通过Socket连接将输出返回给浏览器, 由此变实现了Web Terminal&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201106012131675-593947667.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202011/1871335-20201106012120681-1133815447.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;按照上面的使用流程基于代码解释如何实现&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;升级http协议为websocket&quot;&gt;升级HTTP协议为WebSocket&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var upgrader = websocket.Upgrader{
        ReadBufferSize:  1024,
        WriteBufferSize: 1024,
        CheckOrigin: func(r *http.Request) bool {
                return true
        },
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;升级协议并获得socket连接&quot;&gt;升级协议并获得socket连接&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;conn, err := upgrader.Upgrade(c.Writer, c.Request, nil)
if err != nil {
    c.Error(err)
    return
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;conn就是socket连接通道, 接下来后台和浏览器之间的通讯都将基于这个通道&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;后台拿到主机信息建立ssh客户端&quot;&gt;后台拿到主机信息,建立ssh客户端&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;ssh客户端结构体&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;type SSHClient struct {
        Username  string `json:&quot;username&quot;`
        Password  string `json:&quot;password&quot;`
        IpAddress string `json:&quot;ipaddress&quot;`
        Port      int    `json:&quot;port&quot;`
        Session   *ssh.Session
        Client    *ssh.Client
        channel   ssh.Channel
}

//创建新的ssh客户端时, 默认用户名为root, 端口为22
func NewSSHClient() SSHClient {
        client := SSHClient{}
        client.Username = &quot;root&quot;
        client.Port = 22
        return client
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;初始化的时候我们只有主机的信息, 而Session, client, channel都是空的, 现在先生成真正的client:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (this *SSHClient) GenerateClient() error {
        var (
                auth         []ssh.AuthMethod
                addr         string
                clientConfig *ssh.ClientConfig
                client       *ssh.Client
                config       ssh.Config
                err          error
        )
        auth = make([]ssh.AuthMethod, 0)
        auth = append(auth, ssh.Password(this.Password))
        config = ssh.Config{
                Ciphers: []string{&quot;aes128-ctr&quot;, &quot;aes192-ctr&quot;, &quot;aes256-ctr&quot;, &quot;aes128-gcm@openssh.com&quot;, &quot;arcfour256&quot;, &quot;arcfour128&quot;, &quot;aes128-cbc&quot;, &quot;3des-cbc&quot;, &quot;aes192-cbc&quot;, &quot;aes256-cbc&quot;},
        }
        clientConfig = &amp;amp;ssh.ClientConfig{
                User:    this.Username,
                Auth:    auth,
                Timeout: 5 * time.Second,
                Config:  config,
                HostKeyCallback: func(hostname string, remote net.Addr, key ssh.PublicKey) error {
                        return nil
                },
        }
        addr = fmt.Sprintf(&quot;%s:%d&quot;, this.IpAddress, this.Port)
        if client, err = ssh.Dial(&quot;tcp&quot;, addr, clientConfig); err != nil {
                return err
        }
        this.Client = client
        return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ssh.Dial(“tcp”, addr, clientConfig)创建连接并返回客户端, 如果主机信息不对或其它问题这里将直接失败&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;通过ssh客户端创建ssh-channel并请求一个pty伪终端请求用户的默认会话&quot;&gt;通过ssh客户端创建ssh channel,并请求一个pty伪终端,请求用户的默认会话&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;如果主机信息验证通过, 可以通过ssh client创建一个通道:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;channel, inRequests, err := this.Client.OpenChannel(&quot;session&quot;, nil)
if err != nil {
    log.Println(err)
    return nil
}
this.channel = channel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ssh通道创建完成后, 请求一个标准输出的终端, 并开启用户的默认shell:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;ok, err := channel.SendRequest(&quot;pty-req&quot;, true, ssh.Marshal(&amp;amp;req))
if !ok || err != nil {
    log.Println(err)
    return nil
}
ok, err = channel.SendRequest(&quot;shell&quot;, true, nil)
if !ok || err != nil {
    log.Println(err)
    return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;远程主机与浏览器实时数据交换&quot;&gt;远程主机与浏览器实时数据交换&lt;/h5&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;现在为止建立了两个通道, 一个是websocket, 一个是ssh channel, 后台将起两个主要的协程, 一个不停的从websocket通道里读取用户的输入, 并通过ssh channel传给远程主机:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;//这里第一个协程获取用户的输入
go func() {
    for {
        // p为用户输入
        _, p, err := ws.ReadMessage()
        if err != nil {
            return
        }
        _, err = this.channel.Write(p)
        if err != nil {
            return
        }
    }
}()
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;第二个主协程将远程主机的数据传递给浏览器, 在这个协程里还将起一个协程, 不断获取ssh channel里的数据并传给后台内部创建的一个通道, 主协程则有一个死循环, 每隔一段时间从内部通道里读取数据, 并将其通过websocket传给浏览器, 所以数据传输并不是真正实时的,而是有一个间隔在, 我写的默认为100微秒, 这样基本感受不到延迟, 而且减少了消耗, 有时浏览器输入一个命令获取大量数据时, 会感觉数据出现会一顿一顿的便是因为设置了一个间隔:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;//第二个协程将远程主机的返回结果返回给用户
go func() {
    br := bufio.NewReader(this.channel)
    buf := []byte{}
    t := time.NewTimer(time.Microsecond * 100)
    defer t.Stop()
    // 构建一个信道, 一端将数据远程主机的数据写入, 一段读取数据写入ws
    r := make(chan rune)

    // 另起一个协程, 一个死循环不断的读取ssh channel的数据, 并传给r信道直到连接断开
    go func() {
        defer this.Client.Close()
        defer this.Session.Close()

        for {
            x, size, err := br.ReadRune()
            if err != nil {
                log.Println(err)
                ws.WriteMessage(1, []byte(&quot;\033[31m已经关闭连接!\033[0m&quot;))
                ws.Close()
                return
            }
            if size &amp;gt; 0 {
                r &amp;lt;- x
            }
        }
    }()

    // 主循环
    for {
        select {
        // 每隔100微秒, 只要buf的长度不为0就将数据写入ws, 并重置时间和buf
        case &amp;lt;-t.C:
            if len(buf) != 0 {
                err := ws.WriteMessage(websocket.TextMessage, buf)
                buf = []byte{}
                if err != nil {
                    log.Println(err)
                    return
                }
            }
            t.Reset(time.Microsecond * 100)
        // 前面已经将ssh channel里读取的数据写入创建的通道r, 这里读取数据, 不断增加buf的长度, 在设定的 100 microsecond后由上面判定长度是否返送数据
        case d := &amp;lt;-r:
            if d != utf8.RuneError {
                p := make([]byte, utf8.RuneLen(d))
                utf8.EncodeRune(p, d)
                buf = append(buf, p...)
            } else {
                buf = append(buf, []byte(&quot;@&quot;)...)
            }
        }
    }
}()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;web terminal的后台建好了&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&quot;前端&quot;&gt;前端&lt;/h5&gt;
&lt;blockquote readability=&quot;8.1473684210526&quot;&gt;
&lt;p&gt;前端我选择用了vue框架(其实这么小的项目完全不用vue), 终端工具用的是xterm, vscode内置的终端也是采用的xterm.这里贴一段关键代码, &lt;strong&gt;&lt;a href=&quot;https://github.com/chengjoey/web-terminal-client&quot;&gt;前端项目地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;mounted () {
    var containerWidth = window.screen.height;
    var containerHeight = window.screen.width;
    var cols = Math.floor((containerWidth - 30) / 9);
    var rows = Math.floor(window.innerHeight/17) - 2;
    if (this.username === undefined){
        var url = (location.protocol === &quot;http:&quot; ? &quot;ws&quot; : &quot;wss&quot;) + &quot;://&quot; + location.hostname + &quot;:5001&quot; + &quot;/ws&quot;+ &quot;?&quot; + &quot;msg=&quot; + this.msg + &quot;&amp;amp;rows=&quot; + rows + &quot;&amp;amp;cols=&quot; + cols;
    }else{
        var url = (location.protocol === &quot;http:&quot; ? &quot;ws&quot; : &quot;wss&quot;) + &quot;://&quot; + location.hostname + &quot;:5001&quot; + &quot;/ws&quot;+ &quot;?&quot; + &quot;msg=&quot; + this.msg + &quot;&amp;amp;rows=&quot; + rows + &quot;&amp;amp;cols=&quot; + cols + &quot;&amp;amp;username=&quot; + this.username + &quot;&amp;amp;password=&quot; + this.password;
    }
    let terminalContainer = document.getElementById('terminal')
    this.term = new Terminal()
    this.term.open(terminalContainer)
    // open websocket
    this.terminalSocket = new WebSocket(url)
    this.terminalSocket.onopen = this.runRealTerminal
    this.terminalSocket.onclose = this.closeRealTerminal
    this.terminalSocket.onerror = this.errorRealTerminal
    this.term.attach(this.terminalSocket)
    this.term._initialized = true
    console.log('mounted is going on')
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/chengjoey/web-terminal&quot;&gt;后端项目地址&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Nov 2020 17:22:00 +0000</pubDate>
<dc:creator>you-men</dc:creator>
<og:description>Crypto/ssh简介 使用 下载 go get &amp;quot;github.com/mitchellh/go-homedir&amp;quot; go get &amp;quot;golang.org/x/cryp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/13934845.html</dc:identifier>
</item>
<item>
<title>Elasticsearch数据库 | Elasticsearch-7.5.0应用搭建实战 - PivotalCloud</title>
<link>http://www.cnblogs.com/mazhilin/p/13934765.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhilin/p/13934765.html</guid>
<description>&lt;blockquote readability=&quot;5.0551181102362&quot;&gt;
&lt;p&gt;Elasticsearch 是一个可用于分布式以及符合RESTful 风格的搜索和数据分析引擎。—— &lt;a href=&quot;https://www.elastic.co/cn/elasticsearch/&quot;&gt;Elastic Stack 官网&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001902407-830351038.png&quot; alt=&quot;0FNnW8.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;搭建elasticsearch的那些事儿&quot;&gt;搭建Elasticsearch的“那些事儿&quot;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001902852-1934985561.jpg&quot; alt=&quot;BW1nxS.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一天，在黄金梅丽号的甲板上，韦柏告诉萨博，需要在接下来的项目开发过程中，运用到Elasticsearch数据库，主要用于黄金梅丽号上的各种设备采集数据实时查询，或许后期还会运用于分布式日志系统的搭建运用等，让萨博先做一次技术预研。于是，在萨博查询大量的资料发现，关于Elasticsearch数据库的搭建，网上的资料几乎是千篇一律，或者多数都是没有一个完整的流程。甚至，还发现，对于Elasticsearch数据库实际应用方面，大多数海贼只局限于ELK等这样的情况，就像是大多数海贼提到Redis，就只觉得这个玩意儿，只能用于缓存层面，但是实际上人家的功能强大到超出了海贼的想象空间。甚至于，萨博在一个阿里巴巴的地方，找到了关于Elasticsearch数据库免费试用的资源，但是对于免费的午餐，也许那一天收费之后，那就只能用一首“浪浪”来祭奠这万恶的黄金之恶。于是在萨博精心研究和分析发现，除了传统部署Elasticsearch数据库之外，有个叫Docker 的东西，除了能够稳定运行Elasticsearch数据库之外，还能节省不少的服务器内存。于是呀，萨博就开始了探索在Docker上搭建Elasticsearch之之路......&lt;/p&gt;
&lt;h3 id=&quot;docker部署elasticsearch的那些事儿&quot;&gt;Docker部署Elasticsearch的“那些事儿&quot;&lt;/h3&gt;
&lt;h4 id=&quot;1基础先决条件&quot;&gt;1.基础先决条件&lt;/h4&gt;
&lt;p&gt;阿里云或者虚拟机VM主机一个，并且自行装有Docker容器：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001903168-1847955032.png&quot; alt=&quot;BWUuHU.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2&quot;&gt;
&lt;p&gt;ps[⚠️注意事项]：&lt;br/&gt;对于Docker安装请参考：&lt;a href=&quot;https://blog.csdn.net/u012103898/article/details/102567115&quot;&gt;Linux环境基于CentOS7 搭建部署Docker容器&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;2最大文件打开数&quot;&gt;2.最大文件打开数&lt;/h4&gt;
&lt;p&gt;[2.1]参数优化：ulimit -a |grep open&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;[root@centos-meteor ~]# ulimit -a |grep open
open files   (-n) 65535
[root@centos-meteor ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;[2.2] 修改配置文件： /etc/security/limits.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;#在最下边添加如下两行
* soft nofile 65536
* hard nofile 65536
* soft nproc 2048
* hard nproc 4096
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;[2.3] 确认是否修改： ulimit -a |grep open&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;[root@centos-meteor ~]# ulimit -a |grep open
open files   (-n) 65535
[root@centos-meteor ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3调整系统进程数&quot;&gt;3.调整系统进程数&lt;/h4&gt;
&lt;p&gt;修改方法：vim /etc/security/limits.d/20-nproc.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;#调整成以下配置
*          soft    nproc     4096
root       soft    nproc     unlimited
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4调整虚拟内存和最大并发连接数&quot;&gt;4.调整虚拟内存和最大并发连接数&lt;/h4&gt;
&lt;p&gt;虚拟内存（Virtual memory）-&amp;gt;vm.max_map_count&lt;br/&gt;Elasticsearch默认使用 hybrid mmapfs / niofs 目录来存储索引。默认操作系统对mmap计数的限制太低，可能引发内存不足的异常&lt;/p&gt;
&lt;p&gt;[1]临时解决方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;sysctl –w vm.max_map_count=262144
sysctl –w vm.max_map_count=262144
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不优化会出现启动Elasticsearch的时候会出现如下提示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;max virtual memory areas vm.max_map_count [65535] is too low, increase to at least [262144]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;[2]永久生效方案：更新系统文件/etc/sysctl.conf的vm.max_map_count字段&lt;br/&gt;执行命令：vim /etc/sysctl.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;[root@turbo-master ~]# vim /etc/sysctl.conf
[root@turbo-master ~]#
#Settings Elasticsearch Virtual Memory—&amp;gt;655360
vm.max_map_count=655360
fs.file-max=655360
vm.overcommit_memory=1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加载到系统：sysctl -p --load /etc/sysctl.conf&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;[root@centos-meteor elasticsearch]# sysctl -p --load /etc/sysctl.conf
vm.swappiness = 0
net.ipv4.neigh.default.gc_stale_time = 120
net.ipv4.conf.all.rp_filter = 0
net.ipv4.conf.default.rp_filter = 0
net.ipv4.conf.default.arp_announce = 2
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
net.ipv4.tcp_max_tw_buckets = 5000
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 1024
net.ipv4.tcp_synack_retries = 2
net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
net.ipv6.conf.lo.disable_ipv6 = 1
kernel.sysrq = 1
vm.max_map_count = 655360
fs.file-max = 655360
vm.overcommit_memory = 1
[root@centos-meteor elasticsearch]#
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5关闭elasticsearch自检测&quot;&gt;5.关闭elasticsearch自检测&lt;/h4&gt;
&lt;p&gt;在elasticsearch.yml中添加配置项：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;bootstrap.memory_lock: false
bootstrap.system_call_filter: false
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;ps[⚠️注意事项]：&lt;br/&gt;主要是避免以下问题：&lt;br/&gt;[1]最大文件打开数: max file descriptors [1024] for elasticsearch process is too low, increase to at least [65536]&lt;br/&gt;[2]调整虚拟内存和最大并发连接数: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]&lt;br/&gt;[3]关闭elasticsearch自检测: system call filters failed to install; check the logs and fix your configuration or disable system call filters at your own risk&lt;br/&gt;[4]调整系统进程数: max number of threads [1024] for user [lish] likely too low, increase to at least [2048]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;实战部署elasticsearch服务&quot;&gt;实战部署ElasticSearch服务&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Docker 部署应用服务的基本步骤：Search[查询镜像]-&amp;gt;Pull[拉取镜像]-&amp;gt;Run[部署镜像]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.查询Elasticsearch 镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker search elasticsearch 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001903467-1941132047.webp&quot; alt=&quot;elasticsearch-search&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps[注意事项]：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一般拉取镜像资源都是从Docker官方仓库[&lt;a href=&quot;https://hub.docker.com/&quot;&gt;docker-hub&lt;/a&gt;]拉取，或者自己构建的Docker云仓库&lt;a href=&quot;https://cr.console.aliyun.com/cn-shanghai/instances/repositories&quot;&gt;aliyun-docker&lt;/a&gt; 等&lt;/li&gt;
&lt;li&gt;本教程选取的ELK镜像均是基于ELK官方Docker仓库&lt;a href=&quot;https://www.docker.elastic.co/&quot;&gt;elastic-io&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;2.拉取Elasticsearch 镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull docker.elastic.co/elasticsearch/elasticsearch:7.3.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001903717-827107745.webp&quot; alt=&quot;elasticsearch-pull&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;ps[注意事项]：&lt;br/&gt;1.本教程采用7.3.x版本，目前最新版本7.4.x[主要用7.3.x版本在阿里云搭建过，避免入坑问题]&lt;br/&gt;2.拉取的过程中可能会出现[net/http: TLS handshake timeout]问题,多尝试几次,主要是网络带宽限制问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.修改镜像名称:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker tag docker.elastic.co/elasticsearch/elasticsearch:7.3.1  elasticsearch:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001903987-393108500.webp&quot; alt=&quot;elasticsearch-tag&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;ps[注意事项]：&lt;br/&gt;1.名称过长导致查看些许不便，通过docker tag source-image[来源镜像] target-image[目标镜像]，推荐统一采用[target-image:target-version]格式定义，且不占用空间，相当于重命名镜像&lt;br/&gt;2.对于拉取kibana[docker.elastic.co/kibana/kibana:7.3.1]和logstash[docker.elastic.co/logstash/logstash:7.3.1] 都建议修改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4.部署镜像服务：&lt;br/&gt;部署命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -itd -p 9200:9200 -p 9300:9300 --restart=always --privileged=true --name elasticsearch-server -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms=512m -Xms=512m&quot; elasticsearch:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认配置目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/usr/share/elasticsearch/config
/usr/share/elasticsearch/logs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看容器列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker ps --format &quot;table {{.ID}}\t{{.Names}}\t{{.Ports}}&quot;
![docker ps]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(&lt;a href=&quot;https://ftp.bmp.ovh/imgs/2019/11/d7e09058af3fadbd.png&quot;&gt;https://ftp.bmp.ovh/imgs/2019/11/d7e09058af3fadbd.png&lt;/a&gt;)&lt;br/&gt;ps[注意事项]:&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;1.需要开放端口[9200和9300]-&amp;gt;9200作为Http协议，主要用于外部通讯,9300作为Tcp协议，jar之间就是通过tcp协议通讯,通常部署集群就是通过9300通信。推荐[宿主机自定义端口:9200]&lt;br/&gt;2.--restart=always :配置容器重启策略,当宿主机重启由于配置了开机自启动，不用手动启动&lt;br/&gt;3.--privileged：配置容器操作权限[true-root操作权限，false-当前容器用户操作权限]&lt;br/&gt;4.对于部署网络模式推荐默认桥接模式,也自定义可以host模式等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5.修改配置：&lt;br/&gt;进入容器：docker exec -it container-id[容器id] or container-name[容器名称] /bin/bash&lt;br/&gt;例如：docker exec -it f2d2e97da375 /bin/bash #f2d2e97da375-&amp;gt; container-id&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001904191-1672870077.webp&quot; alt=&quot;docker-exec&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改配置文件:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-linux&quot;&gt;[root@f2d2e97da375 elasticsearch]# ls 
LICENSE.txt  NOTICE.txt  README.textile  bin  config  data  jdk  lib  logs  modules  plugins
[root@f2d2e97da375 elasticsearch]# 
[root@f2d2e97da375 elasticsearch]# cd config  
[root@f2d2e97da375 config]# ls
elasticsearch.keystore  elasticsearch.yml  jvm.options  log4j2.properties  role_mapping.yml  roles.yml  users  users_roles
[root@f2d2e97da375 config]# vi elasticsearch.yml 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加跨域配置：&lt;code&gt;http.cors.enabled: true &amp;amp;&amp;amp; http.cors.allow-origin: &quot;*&quot;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cluster.name: &quot;docker-cluster&quot;
network.host: 0.0.0.0
http.cors.enabled: true
http.cors.allow-origin: &quot;*&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后退出exit容器，在宿主机重启容器：docker restart container-id[容器id] or container-name[容器名称]&lt;br/&gt;docker restart f2d2e97da375&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@f2d2e97da375 config]# exit
exit
[root@centos-meteor ~]# docker restart f2d2e97da375
f2d2e97da375
[root@centos-meteor ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.5648351648352&quot;&gt;
&lt;p&gt;ps[注意事项]：&lt;br/&gt;1.进入容器方式：包括使用 docker attach 命令或 docker exec 命令，&lt;br/&gt;推荐使用 docker exec 命令。原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;docker attach: 使用exit退出容器，会导致容器的停止&lt;/li&gt;
&lt;li&gt;docker exec：使用exit退出容器，不会导致容器的停止&lt;/li&gt;
&lt;li&gt;参考docker进入容器的几种方法博客-&lt;a href=&quot;https://www.cnblogs.com/yanshicheng/p/9452545.html&quot;&gt;docker进入容器的几种方法&lt;/a&gt;&lt;br/&gt;2.如果Docker安装了可视化界面 Portainer，推荐采用这种方式进入容器：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001904454-443242665.webp&quot; alt=&quot;docker-portainer&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;搭建部署elasticsearch-head服务&quot;&gt;搭建部署ElasticSearch-Head服务&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ElasticSearch-Head：弹性搜索集群的Web前端界面，是使用Nodjs构建的，主要用于查看ElasticSearch相关信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.拉取Elasticsearch-Head 镜像：docker pull mobz/elasticsearch-head:5&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@centos-amber ~]# docker pull mobz/elasticsearch-head:5
5: Pulling from mobz/elasticsearch-head
75a822cd7888: Pull complete 
57de64c72267: Pull complete 
4306be1e8943: Pull complete 
871436ab7225: Pull complete 
0110c26a367a: Pull complete 
1f04fe713f1b: Pull complete 
723bac39028e: Pull complete 
7d8cb47f1c60: Pull complete 
7328dcf65c42: Pull complete 
b451f2ccfb9a: Pull complete 
304d5c28a4cf: Pull complete 
4cf804850db1: Pull complete 
Digest: sha256:55a3c82dd4ba776e304b09308411edd85de0dc9719f9d97a2f33baa320223f34
Status: Downloaded newer image for mobz/elasticsearch-head:5
docker.io/mobz/elasticsearch-head:5
[root@centos-amber ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.修改Elasticsearch-Head 镜像名称：docker tag  mobz/elasticsearch-head:5   elasticsearch-head:latest&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@centos-amber ~]# docker tag  mobz/elasticsearch-head:5        elasticsearch-head:latest
[root@centos-amber ~]# docker images
REPOSITORY                                      TAG                 IMAGE ID            CREATED             SIZE
grafana/grafana                                 latest              05d1bcf30d16        7 days ago          207MB
nginx                                           latest              540a289bab6c        3 weeks ago         126MB
prom/prometheus                                 latest              2c8e464e47f4        3 weeks ago         129MB
moxm/sentinel-dashboard                         latest              0ccaac81584e        4 weeks ago         167MB
portainer                                       latest              4cda95efb0e4        4 weeks ago         80.6MB
portainer/portainer                             latest              4cda95efb0e4        4 weeks ago         80.6MB
apache/skywalking-ui                            latest              fa66ca9c9862        2 months ago        123MB
apache/skywalking-oap-server                    latest              376a37cdf65c        2 months ago        190MB
docker.elastic.co/kibana/kibana                 7.3.1               b54865ba6b0b        2 months ago        1.01GB
docker.elastic.co/elasticsearch/elasticsearch   7.3.1               3d3aa92f641f        2 months ago        807MB
elasticsearch                                   latest              3d3aa92f641f        2 months ago        807MB
prom/node-exporter                              latest              e5a616e4b9cf        5 months ago        22.9MB
google/cadvisor                                 latest              eb1210707573        12 months ago       69.6MB
elasticsearch-head                              latest              b19a5c98e43b        2 years ago         824MB
mobz/elasticsearch-head                         5                   b19a5c98e43b        2 years ago         824MB
tutum/influxdb                                  latest              c061e5808198        3 years ago         290MB
[root@centos-amber ~]# 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.部署Elasticsearch-Head 容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -itd --restart=always --privileged=true -p 9100:9100 --name elasticsearch-head-server elasticsearch-head:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看容器服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker ps --format &quot;table {{.ID}}\t{{.Names}}\t{{.Ports}}&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001904725-900215636.webp&quot; alt=&quot;docker-elasticsearch-head&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.浏览器访问：&lt;a href=&quot;http://remote-ip:9100/&quot;&gt;http://remote-ip:9100/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001904927-827429724.webp&quot; alt=&quot;elasticsearch-head&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实战测试elasticsearch-head服务&quot;&gt;实战测试ElasticSearch-Head服务&lt;/h3&gt;
&lt;p&gt;1.准备数据：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001905220-709109735.png&quot; alt=&quot;BW0ZiF.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;companyId&quot;: &quot;ebcb4f99e0cb4ad781278ae636c1031f&quot;,
    &quot;classifyName&quot;: &quot;激素检测&quot;,
    &quot;deviceType&quot;: &quot;激素检测&quot;,
    &quot;data&quot;: {
        &quot;deviceId&quot;: &quot;20000060100000002&quot;,
        &quot;deviceNo&quot;: &quot;QC00020000060100000002&quot;,
        &quot;appid&quot;: &quot;00000000&quot;,
        &quot;sim&quot;: &quot;89860404191792655118&quot;,
        &quot;csq&quot;: &quot;30&quot;,
        &quot;electric&quot;: &quot;98&quot;,
        &quot;voltage&quot;: &quot;13279&quot;,
        &quot;softVer&quot;: &quot;5143000500010601-01020006|5143000500010601-01010003&quot;,
        &quot;hardVer&quot;: &quot;5143000500010601-00000002|5143000500010601-00000002&quot;,
        &quot;status&quot;: &quot;0&quot;,
        &quot;date&quot;: &quot;2020-09-13 11:23:52&quot;,
        &quot;elements&quot;: [
                {
                &quot;key&quot;: &quot;20&quot;,
                &quot;value&quot;: &quot;10&quot;,
                &quot;time&quot;: &quot;2020-09-13 11:23:52&quot;
            },
            {
                &quot;key&quot;: &quot;21&quot;,
                &quot;value&quot;: &quot;11&quot;,
                &quot;time&quot;: &quot;2020-09-13 11:23:52&quot;
            },
            {
                &quot;key&quot;: &quot;22&quot;,
                &quot;value&quot;: &quot;12&quot;,
                &quot;time&quot;: &quot;2020-09-13 11:23:52&quot;
            },
            {
                &quot;key&quot;: &quot;23&quot;,
                &quot;value&quot;: &quot;13&quot;,
                &quot;time&quot;: &quot;2020-09-13 11:23:52&quot;
            }
        ]
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.设置请求头：application/json;charset=UTF-8&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001905485-1567536265.png&quot; alt=&quot;BW0KMR.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.发送PUT请求：&lt;a href=&quot;http://remote-ip/device/deviceData/QC00020000060100000001&quot;&gt;http://remote-ip/device/deviceData/QC00020000060100000001&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001905776-25245578.png&quot; alt=&quot;BW0tRH.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;_index&quot;: &quot;device&quot;,
    &quot;_type&quot;: &quot;deviceData&quot;,
    &quot;_id&quot;: &quot;QC00020000060100000002&quot;,
    &quot;_version&quot;: 1,
    &quot;result&quot;: &quot;created&quot;,
    &quot;_shards&quot;: {
        &quot;total&quot;: 2,
        &quot;successful&quot;: 1,
        &quot;failed&quot;: 0
    },
    &quot;created&quot;: true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.打开浏览器查看结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001906151-344662961.png&quot; alt=&quot;BW0gzj.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实战搭建elasticsearch总结&quot;&gt;实战搭建ElasticSearch总结&lt;/h3&gt;
&lt;p&gt;1.部署基本命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;docker run -itd -p 9200:9200 -p 9300:9300 --restart=always --privileged=true --name elasticsearch-server --network-alias elasticsearch-server --hostname elasticsearch-server -v /docker/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml -v /docker/elasticsearch/data:/usr/share/elasticsearch/data -v /docker/elasticsearch/logs:/usr/share/elasticsearch/logs  -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-server -Xms512m -Xmx512m -Xmn256m -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m -XX:+AlwaysPreTouch -XX:-UseBiasedLocking &quot; -e TZ=&quot;Asia/Shanghai&quot;  elasticsearch:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.配置文件[elasticsearch.yml ]:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;cluster.name: elasticsearch-cluster
node.name: elasticsearch-server
network.host: 0.0.0.0
network.bind_host: 0.0.0.0
network.publish_host: 0.0.0.0
http.cors.enabled: true
http.cors.allow-origin: &quot;*&quot;
bootstrap.memory_lock: false
bootstrap.system_call_filter: false
transport.tcp.port: 9300
transport.tcp.compress: true
http.max_content_length: 128mb
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.分词插件安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.5.0/elasticsearch-analysis-ik-7.5.0.zip
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.Docker 部署 ElasticSearch-Head：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -itd --restart=always --privileged=true -p 9100:9100 --network-alias elasticsearch-head-server --name elasticsearch-head-server --hostname elasticsearch-head-server -v /docker/elasticsearch-head/app:/usr/src/app elasticsearch-head:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.ElasticSearch-Head 使用406错误：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1778572/202011/1778572-20201106001906585-230626174.png&quot; alt=&quot;BWBnk8.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;ajaxSettings部分json配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;    ajaxSettings: {
      url: ajaxLocation,
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      type: &quot;GET&quot;,
      //contentType: &quot;application/x-www-form-urlencoded&quot;,
      contentType: &quot;application/json;charset=UTF-8&quot;,
      processData: true,
      async: true,
      /*
                timeout: 0,
                data: null,
                dataType: null,
                username: null,
                password: null,
                cache: null,
                traditional: false,
                headers: {},
                */

      accepts: {
        xml: &quot;application/xml, text/xml&quot;,
        html: &quot;text/html&quot;,
        text: &quot;text/plain&quot;,
        json: &quot;application/json, text/javascript&quot;,
        &quot;*&quot;: &quot;*/*&quot;,
      },
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;inspectData 部分json配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter(&quot;json jsonp&quot;, function (s, originalSettings, jqXHR) {
    //var inspectData = s.contentType === &quot;application/x-www-form-urlencoded&quot; &amp;amp;&amp;amp;
    var inspectData =
      (s.contentType === &quot;application/x-www-form-urlencoded&quot; &amp;amp;&amp;amp;
        typeof s.data === &quot;string&quot;) ||
      (s.contentType === &quot;application/json;charset=UTF-8&quot; &amp;amp;&amp;amp;
        typeof s.data === &quot;string&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;版权声明：本文为博主原创文章，遵循相关版权协议，如若转载或者分享请附上原文出处链接和链接来源。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 05 Nov 2020 16:19:00 +0000</pubDate>
<dc:creator>PivotalCloud</dc:creator>
<og:description>Elasticsearch 是一个可用于分布式以及符合RESTful 风格的搜索和数据分析引擎。—— Elastic Stack 官网 搭建Elasticsearch的“那些事儿&amp;amp;quot;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhilin/p/13934765.html</dc:identifier>
</item>
<item>
<title>GDB调试基础使用方法 - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/13934583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/13934583.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;尽管目前使用的VS code可以使用插件一键构建和运行程序，但GDB作为调试利器，还是值得花时间去学习的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GDB(GNU Debugger)&lt;/strong&gt; 是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。&lt;/p&gt;
&lt;p&gt;参考: &lt;a href=&quot;https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html&quot;&gt;gdb调试利器&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;进入gdb环境调试&quot;&gt;进入GDB环境调试&lt;/h2&gt;
&lt;h3 id=&quot;加载编译选项-g&quot;&gt;加载编译选项” –g”&lt;/h3&gt;
&lt;p&gt;以便在GDB调试环境中能够显示出具体的错误位置。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;g++ filename.cpp –g –o filename
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在cmake编译中，可以通过可选项 &lt;code&gt;-DCMAKE_VERBOSE_MAKEFILE=1&lt;/code&gt; ,具体显示编译过程，保证-g选项在编译过程中使用。&lt;/p&gt;
&lt;h3 id=&quot;加载可执行文件到gdb中&quot;&gt;加载可执行文件到GDB中&lt;/h3&gt;
&lt;p&gt;在执行文件所在文件夹里，使用 &lt;code&gt;gdb&lt;/code&gt; 命令进入到GDB调试环境中。之后使用 &lt;code&gt;file filename&lt;/code&gt;&lt;br/&gt;或者使用 &lt;code&gt;gdb filename&lt;/code&gt; （filename可执行文件名）。&lt;/p&gt;
&lt;h3 id=&quot;对执行文件进行输入参数的设置&quot;&gt;对执行文件进行输入参数的设置&lt;/h3&gt;
&lt;p&gt;使用命令 &lt;code&gt;set args parameter&lt;/code&gt; (parameter为输入的参数)，加载运行所需的参数。通过 &lt;code&gt;show args&lt;/code&gt; 查看加载参数的情况。&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set args /home/hello.png 2016 12
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用’show args’后:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/home/hello.png 2016 12
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gdb内使用make&quot;&gt;GDB内使用make&lt;/h3&gt;
&lt;p&gt;外部文件有修改的情况下，直接在GDB环境中使用“make”进行编译。&lt;/p&gt;
&lt;h3 id=&quot;文件执行&quot;&gt;文件执行&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;r&lt;/code&gt; 即可对文件进行执行。&lt;/p&gt;
&lt;h3 id=&quot;退出gdb调试环境&quot;&gt;退出GDB调试环境&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;q&lt;/code&gt; 退出调试环境。&lt;/p&gt;
&lt;h2 id=&quot;断点设置&quot;&gt;断点设置&lt;/h2&gt;
&lt;h3 id=&quot;断点设置的方法&quot;&gt;断点设置的方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用行号：&lt;code&gt;b linenumber&lt;/code&gt; 例：“b 2017”&lt;/li&gt;
&lt;li&gt;使用函数名 &lt;code&gt;b function&lt;/code&gt; 例：“b hello”&lt;/li&gt;
&lt;li&gt;使用地址 &lt;code&gt;b *address&lt;/code&gt; 例：“b *0x404”&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;若在不同文件上打断点，在行号或函数名前加上文件名和冒号“filename:”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b hello.cpp:hello 
b hello.cpp:2017
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;条件断点&quot;&gt;条件断点&lt;/h3&gt;
&lt;p&gt;在1小点方法后面加入条件，断点在条件成立时起停止作用。&lt;/p&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;b 12 if x &amp;gt; y  // 在x &amp;gt; y情况下，断点起作用。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;断点条件更改&quot;&gt;断点条件更改&lt;/h3&gt;
&lt;p&gt;将指定断点号的条件进行修改:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;condition breakpointnumber expression
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;condition 12 if x = y
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;condition breakpointnumber&lt;/code&gt; 停止使用条件，断点不受条件限制使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;condition 12
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;断点信息查看&quot;&gt;断点信息查看&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查看所有的断点信息: &lt;code&gt;info b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看指定断点号断点信息: &lt;code&gt;info b number&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;断点的使能&quot;&gt;断点的使能&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;停止该号断点。但未删除: &lt;code&gt;dis breakpointnumber&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使能改号断点: &lt;code&gt;enable breakpointnumber&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;调试的方式&quot;&gt;调试的方式&lt;/h2&gt;
&lt;h3 id=&quot;打印变量-p&quot;&gt;打印变量 &lt;code&gt;p&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;打印变量值：&lt;code&gt;p variable&lt;/code&gt; 例: “p x”&lt;/li&gt;
&lt;li&gt;打印变量地址：&lt;code&gt;p &amp;amp;variable&lt;/code&gt; 例: “p &amp;amp;x”&lt;/li&gt;
&lt;li&gt;打印指针内容：&lt;code&gt;p *point&lt;/code&gt; 例: “p *pData”&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;单步调试-s&quot;&gt;单步调试 &lt;code&gt;s&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;类似于 &lt;strong&gt;step in&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单步执行，遇到函数，进入到函数内部执行。&lt;br/&gt;&lt;code&gt;s number&lt;/code&gt; 进行多步执行&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;单步执行-n&quot;&gt;单步执行 &lt;code&gt;n&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;类似 &lt;strong&gt;step over&lt;/strong&gt; 执行，遇到函数，不进入函数内部，直接执行完函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;n number&lt;/code&gt; 进行多步执行&lt;/p&gt;
&lt;h3 id=&quot;继续执行-c&quot;&gt;继续执行 &lt;code&gt;c&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在程序在执行中遇到断点后，使用 &lt;code&gt;c&lt;/code&gt; 继续执行&lt;/p&gt;
&lt;h3 id=&quot;执行完当前函数并打印出信息-finish&quot;&gt;执行完当前函数并打印出信息 &lt;code&gt;finish&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;在函数内部使用 &lt;code&gt;finish&lt;/code&gt; ，执行完当前整个函数打印返回信息&lt;/p&gt;
&lt;h3 id=&quot;设置变量值调试&quot;&gt;设置变量值调试&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;set var variable = x&lt;/code&gt; 将变量设置为x后进行调试&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set var tmp = 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将变量 tmp 设置为5，var关键词确保不产生冲突&lt;/p&gt;
&lt;h2 id=&quot;段错误的查找&quot;&gt;段错误的查找&lt;/h2&gt;
&lt;h3 id=&quot;段回溯-bt&quot;&gt;段回溯 &lt;code&gt;bt&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在出现 segment fault 时，使用命令进行段错误的查看。&lt;/li&gt;
&lt;li&gt;可以得到错误坐在的函数。像得到某人家庭地址。&lt;/li&gt;
&lt;li&gt;也可使用 &lt;code&gt;where&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;进入错误段&quot;&gt;进入错误段&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;在查看到错误的位置之后，使用 &lt;code&gt;frame number&lt;/code&gt; 进入到该段内部。&lt;/li&gt;
&lt;li&gt;进入内部之后便可以进行局部变量的打印调试。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;frame 5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就进入到段5.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;切换到上一层段: &lt;code&gt;up&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;切换到下一层段: &lt;code&gt;down&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代码显示&quot;&gt;代码显示&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;显示当前代码: &lt;code&gt;l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示当前之前的代码: &lt;code&gt;l -&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示该行周围代码: &lt;code&gt;l number&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;显示该函数周围代码: &lt;code&gt;l function&lt;/code&gt; （C++代码需要在函数名前加类名，重载函数需要在函数内加参数类型）&lt;/li&gt;
&lt;li&gt;显示指定文件指定行周围代码: &lt;code&gt;l filename:linenumber&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;l hello.cpp:1   // 从hello.cpp第一行开始显示
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;显示指定文件指定函数周围代码: &lt;code&gt;l filename:function&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;l hello.cpp:Util::hello    // 显示hello.cpp文件下，Util类的函数hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;显示起始终止行内代码: &lt;code&gt;l fisrt,last&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;l 1,30  // 从第0行显示到第30行的内容
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;关于GDB调试的相关文章：&lt;a href=&quot;https://www.cnblogs.com/acceptedzhs/p/13161213.html&quot;&gt;https://www.cnblogs.com/acceptedzhs/p/13161213.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 05 Nov 2020 15:18:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>尽管目前使用的VS code可以使用插件一键构建和运行程序，但GDB作为调试利器，还是值得花时间去学习的。 概述 GDB(GNU Debugger) 是一个由GNU开源组织发布的、UNIX/LINUX</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/13934583.html</dc:identifier>
</item>
</channel>
</rss>