<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>浏览器运行机制详解 - 前端蔡蔡</title>
<link>http://www.cnblogs.com/caiyy/p/10406934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caiyy/p/10406934.html</guid>
<description>&lt;p&gt; 大家肯定都听说过很多浏览器优化原则吧，例如说减少DOM操作，使用transformX（0）进行硬件优化，避免js文件执行时间过长使得页面卡顿等等。大部分人可能都知道，但也仅限于知道，即知其然，不知其所以然。&lt;/p&gt;
&lt;p&gt; 学习要形成自己的知识体系，否则的话，往往是东一榔头西一榔头地学习知识，这样导致学习到的知识松散，无法形成内在的联系，也就导致了学习地不够深入，只是浮于表面，只是“记住”了知识。&lt;/p&gt;
&lt;p&gt; 所以，接下来，我想来为大家梳理一下浏览器运行过程中需要理解的知识，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前言&lt;/li&gt;
&lt;li&gt;进程与线程&lt;/li&gt;
&lt;li&gt;浏览器进程
&lt;ul&gt;&lt;li&gt;浏览器都有哪些进程&lt;/li&gt;
&lt;li&gt;浏览器内核（renderer进程）&lt;/li&gt;
&lt;li&gt;html解析&lt;/li&gt;
&lt;li&gt;css解析&lt;/li&gt;
&lt;li&gt;render树&lt;/li&gt;
&lt;li&gt;回流与重绘
&lt;ul&gt;&lt;li&gt;什么时候会发生回流与重绘&lt;/li&gt;
&lt;li&gt;具体什么操作会引起回流&lt;/li&gt;
&lt;li&gt;如何减少回流&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;硬件加速
&lt;ul&gt;&lt;li&gt;如何才能使用硬件加速&lt;/li&gt;
&lt;li&gt;硬件加速使用z-index&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;浏览器页面的渲染流程&lt;/li&gt;
&lt;li&gt;DOMContentLoaded和load事件&lt;/li&gt;
&lt;li&gt;css堵塞情况&lt;/li&gt;
&lt;li&gt;js堵塞情况&lt;/li&gt;
&lt;li&gt;css和js文件应当放在html哪个位置&lt;/li&gt;
&lt;li&gt;事件循环机制&lt;/li&gt;
&lt;li&gt;宏任务和微任务&lt;/li&gt;
&lt;li&gt;导致页面无法响应的原因&lt;/li&gt;
&lt;li&gt;html文件解析过程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;参考链接&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt; 可以这样理解：&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;br/&gt; - 进程是一个工厂，每个工厂有其独立的资源。&lt;p&gt; - 线程是工厂中的工人，可能只有一个，可能有好多个。多个工人协同完成工作。工人共享工作资源。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt; 回到硬件上来理解：&lt;/p&gt;
&lt;div readability=&quot;18&quot;&gt;&lt;br/&gt; - 工厂的资源 -&amp;gt; 系统分配的内存。&lt;p&gt; - 工厂之间相互独立 -&amp;gt; 进程之间相互独立，也即进程分配到的内存相互独立，无法读到对方内存中的数据。&lt;/p&gt;&lt;p&gt; - 一个工厂有一个或多个工人 -&amp;gt; 一个线程中有一个或多个线程。&lt;/p&gt;&lt;p&gt; - 多个工人协同完成工作 -&amp;gt; 进程中多个线程协同完成工作。即线程之间能互相发送请求与接收结果。&lt;/p&gt;&lt;p&gt; - 工人共享工作资源 -&amp;gt; 进程中所有线程都能访问到相同一块内存，即信息是互通的。&lt;/p&gt;&lt;/div&gt;
&lt;p&gt; 不过在这里要强调一点：&lt;strong&gt;一个软件不等于一个进程，一个软件可能包含有多个互相独立的进程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 最后，再用官方的术语描述下进程与线程的差别&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;进程是系统资源分配的最小单位（即系统以进程为最小单位分配内存空间，同时进程是能独立运行的最小单位）&lt;/li&gt;
&lt;li&gt;线程是系统调度的最小单位（即系统以线程为单位分配cpu中的核。）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; tips：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;进程之间也能互相通信，不过代价比较大。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;p&gt; 首先，明确的是：&lt;strong&gt;浏览器是多线程的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 以Chrome浏览器为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1564471/201902/1564471-20190219200243787-934131663.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 大家有兴趣的话，也可以打开&lt;span&gt;Chrome的任务管理器&lt;/span&gt;测试。由图可知，Chrome中有多个进程（每个tab页面对应一个进程，以及Browser进程，GPU进程和插件进程）。&lt;/p&gt;

&lt;h2 id=&quot;浏览器都有哪些进程&quot;&gt;浏览器都有哪些进程&lt;/h2&gt;
&lt;p&gt; &lt;strong&gt;浏览器中的进程分别是：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;Browser进程 : 是浏览器的主进程，负责主控，协调，只有一个，可以看做是浏览器的大脑。
&lt;ul&gt;&lt;li&gt;负责下载页面的网络文件&lt;/li&gt;
&lt;li&gt;负责将&lt;span&gt;renderer进程得到的存在内存中的位图&lt;/span&gt;渲染（显示）到页面上&lt;/li&gt;
&lt;li&gt;负责创建和销毁tab进程（renderer进程）&lt;/li&gt;
&lt;li&gt;负责与用户的交互&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;GPU进程 ： 只有一个。
&lt;ul&gt;&lt;li&gt;负责3D绘制，只有当该页面使用了硬件加速才会使用它，来渲染（显示）页面。否则的话，不使用这个进程，而是用Browser进程来渲染（显示）页面&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;renderer进程：又名浏览器内核，每个tab页面对应一个独立的renderer进程，内部有多个线程。
&lt;ul&gt;&lt;li&gt;负责脚本执行，位图绘制，事件触发，任务队列轮询等&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;第三方插件进程：每种类型的插件对应一个进程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 浏览器是多进程的好处非常明显，&lt;strong&gt;如果浏览器是单线程的话，则一个页面，一个插件的崩溃会导致整个浏览器崩溃，用户体验感会非常差。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;浏览器内核renderer进程&quot;&gt;浏览器内核（renderer进程）&lt;/h2&gt;
&lt;p&gt; ，弄懂了这一部分的知识，那么你对一个网页的运行机制也就能有个框架了。&lt;/p&gt;
&lt;p&gt; renderer进程是&lt;span&gt;多线程&lt;/span&gt;的，以下是各个线程的名称及作用（仅列举常驻线程）：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;js引擎线程：
&lt;ul&gt;&lt;li&gt;也称js内核，解析js脚本，执行代码&lt;/li&gt;
&lt;li&gt;与GUI线程互斥，即当js引擎线程运行时，GUI线程会被挂起，当js引擎线程结束运行时，才会继续运行GUI线程&lt;/li&gt;
&lt;li&gt;由一个主线程和多个web worker线程组成，由于web worker是附属于主线程，无法操作dom等，所以js还是单线程语言（在主线程运行js代码）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;GUI渲染线程：
&lt;ul&gt;&lt;li&gt;用于解析html为DOM树，解析css为CSSOM树，布局layout，绘制paint&lt;/li&gt;
&lt;li&gt;当页面需要重排reflow，重绘repaint时，使用该线程&lt;/li&gt;
&lt;li&gt;与js引擎线程互斥&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;事件触发线程
&lt;ul&gt;&lt;li&gt;当对应事件触发（不论是WebAPIs完成事件触发，还是页面交互事件触发）时，该线程会将事件对应的回调函数放入callback queue（任务队列）中，等待js引擎线程的处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;定时触发线程
&lt;ul&gt;&lt;li&gt;对应于setTimeout，setInterval API，由该线程来计时，当计时结束，将事件对应的回调函数放入任务队列中&lt;/li&gt;
&lt;li&gt;当setTimeout的定时的时间小于4ms，一律按4ms来算&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;http请求线程
&lt;ul&gt;&lt;li&gt;每有一个http请求就开一个该线程&lt;/li&gt;
&lt;li&gt;当检测到状态变更的话，就会产生一个状态变更事件，如果该状态变更事件对应有回调函数的话，则放入任务队列中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;任务队列轮询线程
&lt;ul&gt;&lt;li&gt;用于轮询监听任务队列，以知道任务队列是否为空&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 想必大家对renderer进程里的组成及职能有个大概的认知了，接下来，我们会着重于细节来进行研究。&lt;/p&gt;

&lt;h2 id=&quot;html解析&quot;&gt;html解析&lt;/h2&gt;
&lt;p&gt; html解析包含有一系列的步骤，过程为&lt;strong&gt;Bytes -&amp;gt; Characters -&amp;gt; Tokens -&amp;gt; Nodes -&amp;gt; DOM。&lt;/strong&gt;最终将html解析为DOM树。&lt;/p&gt;
&lt;p&gt; 假设有一html页面，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&amp;gt;
    &amp;lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;title&amp;gt;Critical Path&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;Hello &amp;lt;span&amp;gt;web performance&amp;lt;/span&amp;gt; students!&amp;lt;/p&amp;gt;
    &amp;lt;div&amp;gt;&amp;lt;img src=&quot;awesome-photo.jpg&quot;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 处理过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1564471/201902/1564471-20190220012225014-1825620514.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 最终生成的DOM树：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1564471/201902/1564471-20190220012706974-93077384.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;css解析&quot;&gt;css解析&lt;/h2&gt;
&lt;p&gt; 与html解析类似，他解析最终形成CSSOM树，过程为&lt;strong&gt;Bytes -&amp;gt; Characters -&amp;gt; Tokens -&amp;gt; Nodes -&amp;gt; CSSOM。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 假设css代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;body { font-size: 16px }
p { font-weight: bold }
span { color: red }
p span { display: none }
img { float: right }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 得到的CSSOM为：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1564471/201902/1564471-20190220012950494-249734927.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;render树&quot;&gt;render树&lt;/h2&gt;
&lt;p&gt; 由DOM树与CSS树结合形成的渲染树（&lt;span&gt;其中无法显示的元素，如script，head元素或diplay：none的元素，不会在渲染树中，也就最终不会被渲染出来&lt;/span&gt;），&lt;strong&gt;页面的布局，绘制都是以render树为依据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 由以上的DOM树与CSSOM树，最终得到的渲染树如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1564471/201902/1564471-20190220013437595-672673849.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;回流与重绘&quot;&gt;回流与重绘&lt;/h2&gt;
&lt;p&gt; 在此之前，我们先明确另外两个概念：&lt;strong&gt;布局与绘制。&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;9&quot;&gt;&lt;p&gt; - 布局是页面首次加载时进行的操作，重新布局即为回流。&lt;/p&gt;&lt;p&gt; - 绘制是页面首次加载时进行的操作，重新绘制即为重绘。&lt;/p&gt;&lt;/div&gt;
&lt;h3 id=&quot;什么时候会发生回流和重绘呢&quot;&gt;什么时候会发生回流和重绘呢：&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;当页面的某部分元素发生了尺寸、位置、隐藏发生了改变，页面进行回流。&lt;span&gt;得对整个页面重新进行布局计算，将所有尺寸，位置受到影响的元素回流&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;当页面的某部分元素的外观发生了改变，但尺寸、位置、隐藏没有改变，页面进行重绘。（同样，只重绘部分元素，而不是整个页面重绘）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;strong&gt;回流的同时往往会伴随着重绘，重绘不一定导致回流。&lt;/strong&gt;所以回流导致的代价是大于重绘的。&lt;/p&gt;
&lt;p&gt; 如果大家对这两者的差别还不是很清楚的话，我引用这两张图给大家：&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;回流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1564471/201902/1564471-20190220020620465-1583153007.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;重绘&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1564471/201902/1564471-20190220020801600-1575523909.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;那么具体什么操作会引起回流呢&quot;&gt;那么具体什么操作会引起回流呢：&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;页面初始化渲染&lt;/li&gt;
&lt;li&gt;窗口的尺寸变化&lt;/li&gt;
&lt;li&gt;元素的尺寸、位置、隐藏变化&lt;/li&gt;
&lt;li&gt;DOM结构发生变化，如删除节点&lt;/li&gt;
&lt;li&gt;获取某些属性，引发回流
&lt;ul&gt;&lt;li&gt;很多浏览器会对回流进行优化，一定时间段后或数量达到阕值时，做一次批处理回流。&lt;/li&gt;
&lt;li&gt;当获取一些属性时，浏览器为了返回正确的值也会触发回流，导致浏览器优化无效，有：
&lt;ol&gt;&lt;li&gt;offset（top/bottom/left/right）&lt;/li&gt;
&lt;li&gt;client (top/bottom/left/right)&lt;/li&gt;
&lt;li&gt;scroll (top/bottom/left/right)&lt;/li&gt;
&lt;li&gt;getComputedStyle()&lt;/li&gt;
&lt;li&gt;width,height&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;其次，字体大小修改及内容更新也会导致回流&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 频繁的回流与重绘会导致频繁的页面渲染，导致cpu或gpu过量使用，使得页面卡顿。&lt;/p&gt;
&lt;h3 id=&quot;那么如何减少回流呢&quot;&gt;那么如何减少回流呢：&lt;/h3&gt;

&lt;ol&gt;&lt;li&gt;减少逐项更改样式，最好一次性更改style，或是将更改的样式定义在class中并一次性更新&lt;/li&gt;
&lt;li&gt;避免循环操作DOM，而是新建一个节点，在他上面应用所有DOM操作，然后再将他接入到DOM中&lt;/li&gt;
&lt;li&gt;当要频繁得到如offset属性时，只读取一次然后赋值给变量，而不是每次都获取一次&lt;/li&gt;
&lt;li&gt;将复杂的元素绝对定位或固定定位，使他脱离文档流，否则回流代价很高&lt;/li&gt;
&lt;li&gt;使用硬件加速创建一个新的复合图层，当其需要回流时不会影响原始复合图层回流&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;硬件加速&quot;&gt;硬件加速&lt;/h2&gt;
&lt;p&gt; 我们在未开启硬件加速的时候是使用cpu来渲染页面，只有开启了硬件加速了，才会使用到GPU渲染页面。&lt;/p&gt;
&lt;p&gt; 在详细讲解硬件加速前，我们先来讲解一下&lt;strong&gt;简单图层和复合图层&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;DOM中的每个结点对应一个简单图层&lt;/li&gt;
&lt;li&gt;复合图层是各个简单图层的合并，一个页面一般来说只有一个复合图层，无论你创建了多少个元素，都是在这个复合图层中
&lt;ul&gt;&lt;li&gt;其次，absolute、fixed布局，可以使该元素脱离文档流，但还是在这个复合图层中，所以他还是会影响复合图层的绘制，但不会影响重排&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; &lt;strong&gt;当一个元素使用硬件加速后，会生成一个新的复合图层&lt;/strong&gt;，这样不管其如何变化，都不会影响原复合图层。不过不要大量使用硬件加速，会导致资源消耗过度，导致页面也卡。&lt;/p&gt;
&lt;p&gt; 所以，使用了硬件加速后，会有多个复合图层，然后多个复合图层互相独立，单独布局、绘制。&lt;/p&gt;
&lt;h3 id=&quot;如何才能使用硬件加速&quot;&gt;如何才能使用硬件加速；&lt;/h3&gt;

&lt;ol&gt;&lt;li&gt;translate3d,translateZ&lt;/li&gt;
&lt;li&gt;opacity属性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;硬件加速时请使用z-index&quot;&gt;硬件加速时请使用z-index&lt;/h3&gt;
&lt;p&gt; 具体原理是这样的：&lt;/p&gt;
&lt;p&gt; 当一个元素使用了硬件加速，在其后的元素，若z-index比他大或者相同，且absolute或fixed的属性相同，则默认为这些元素也创建各自的复合图层。&lt;/p&gt;
&lt;p&gt; 所以我们人为地为这个元素添加z-index值，从而避免这种情况&lt;/p&gt;

&lt;h2 id=&quot;浏览器页面的渲染流程&quot;&gt;浏览器页面的渲染流程&lt;/h2&gt;
&lt;p&gt; 经过以上的学习，我们可以清楚浏览器的渲染过程了：&lt;br/&gt;&lt;/p&gt;
&lt;div readability=&quot;19&quot;&gt;&lt;br/&gt; 1. 解析html得到DOM树&lt;p&gt; 2. 解析css得到CSS树&lt;/p&gt;&lt;p&gt; 3. 合并得到render树&lt;/p&gt;&lt;p&gt; 4. 布局，当页面有元素的尺寸、大小、隐藏有变化或增加、删除元素时，重新布局计算，并修改页面中所有受影响的部分&lt;/p&gt;&lt;p&gt; 5. 绘制，当页面有元素的外观发生变化时，重新绘制&lt;/p&gt;&lt;p&gt; 6. GUI线程将得到的各层的位图（每个元素对应一个普通图层）发送给Browser进程，由Browser进程将各层合并，渲染在页面上&lt;/p&gt;&lt;/div&gt;

&lt;h2 id=&quot;domcontentloaded和load事件&quot;&gt;DOMContentLoaded和load事件&lt;/h2&gt;
&lt;p&gt; 这两者的差别，由其定义就可知：&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;&lt;br/&gt; - DOMContentLoaded：当DOM加载完成触发&lt;p&gt; - load：当DOM，样式表，脚本都加载完时触发&lt;/p&gt;&lt;/div&gt;
&lt;p&gt; 所以可以知道，&lt;strong&gt;DOMContentLoaded在load之前触发&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;css的堵塞情况&quot;&gt;css的堵塞情况&lt;/h3&gt;
&lt;p&gt; 首先，是在Browser进程中下载css文件，当下载完成后，发送给GUI线程。&lt;/p&gt;
&lt;p&gt; 其次，是在GUI线程中解析html及css，不过这两者是并行的。&lt;/p&gt;
&lt;p&gt; 由于css的下载和解析不会影响DOM树，所以&lt;strong&gt;不会堵塞html文件的解析，但会堵塞页面渲染。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 这样的设计是非常合理的，如果css文件的下载和解析不会堵塞页面渲染，那么在页面渲染的途中或结束后发现元素样式有变化，则又需要回流和重绘。&lt;/p&gt;

&lt;h3 id=&quot;js的堵塞情况&quot;&gt;js的堵塞情况&lt;/h3&gt;
&lt;p&gt; 明确的是，&lt;strong&gt;js文件的下载和解析执行都会堵塞html文件的解析及页面渲染。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 因为js脚本可能会改变DOM结构，若是其不堵塞html文件的解析及页面渲染的话，那么当js脚本改变DOM结构或元素样式时，会引发回流和重绘，会造成不必要的性能浪费，不如等待js执行完，在进行html解析和页面渲染。&lt;/p&gt;
&lt;p&gt; 如果你不想js堵塞的话，则使用async属性，这样就可以异步加载js文件，加载完成后立即执行。&lt;/p&gt;

&lt;h3 id=&quot;css和js文件应当放在html哪个位置&quot;&gt;css和js文件应当放在html哪个位置&lt;/h3&gt;
&lt;p&gt; &lt;strong&gt;js：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;br/&gt; 当需要在DOM树完成之前用js进行初始化操作的话，在head中使用js。  如果是需要在DOM树形成之后，即要操作DOM，则在body元素的末尾。不过也可以使用load事件。  如果js的内容比较小，则推荐使用内部js而不是引用js，这样可以减少http请求。&lt;/div&gt;
&lt;p&gt; &lt;strong&gt;css：&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;&lt;br/&gt; 一般放在head中，因为css的解析不影响html的解析，所以越早引入，越早同时解析。&lt;/div&gt;

&lt;h2 id=&quot;事件循环机制&quot;&gt;事件循环机制&lt;/h2&gt;
&lt;p&gt; 事件循环机制在我的这篇文章有详细的说明：&lt;a href=&quot;https://www.cnblogs.com/caiyy/p/10362247.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/caiyy/p/10362247.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 总结一句话：&lt;/p&gt;
&lt;p&gt; &lt;span&gt;事件循环机制的核心是事件触发线程，由于执行栈产生异步任务，异步任务完成后事件触发线程将其回调函数传入到任务队列中，当执行栈为空，任务队列将队列头的回调函数入执行栈，从而新的一轮循环开始。这就是称为循环的原因。&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&quot;宏任务和微任务&quot;&gt;宏任务和微任务&lt;/h3&gt;
&lt;h4 id=&quot;宏任务macrotask&quot;&gt;宏任务（macrotask）：&lt;/h4&gt;
&lt;div readability=&quot;11&quot;&gt;&lt;br/&gt; - 主代码块和任务队列中的回调函数就是宏任务。&lt;p&gt; - 为了使js内部宏任务和DOM任务能够有序的执行，每次执行完宏任务后，会在下一个宏任务执行之前，对页面重新进行渲染。（宏任务 -&amp;gt; 渲染 -&amp;gt; 宏任务）&lt;/p&gt;&lt;/div&gt;

&lt;h4 id=&quot;微任务microtask&quot;&gt;微任务（microtask）：&lt;/h4&gt;
&lt;div readability=&quot;11&quot;&gt;&lt;br/&gt; - 在宏任务执行过程中，执行到微任务时，将微任务放入微任务队列中。&lt;p&gt; - 在宏任务执行完后，在重新渲染之前执行。&lt;/p&gt;&lt;p&gt; - 当一个宏任务执行完后，他会将产生的所有微任务执行完。&lt;/p&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;分别在什么场景下会产生宏任务或微任务呢：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;宏任务：主代码块，setTimeout，setInterval（任务队列中的所有回调函数都是宏任务）&lt;/li&gt;
&lt;li&gt;微任务：Promise&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;导致页面无法立即响应的原因&quot;&gt;导致页面无法立即响应的原因&lt;/h2&gt;
&lt;p&gt; 导致页面无法响应的原因是执行栈中还有任务未执行完，或者是js引擎线程被GUI线程堵塞。&lt;/p&gt;

&lt;h2 id=&quot;html文件解析过程&quot;&gt;html文件解析过程&lt;/h2&gt;
&lt;p&gt; 这个过程是在下载html文件之后，不包括网络请求过程&lt;/p&gt;
&lt;div readability=&quot;35&quot;&gt; 1. Browser进程下载html文件并将文件发送给renderer进程&lt;p&gt; 2. renderer进程的GUI进程开始解析html文件来构建出DOM&lt;/p&gt;&lt;p&gt; 3. 当遇到外源css时，Browser进程下载该css文件并发送回来，GUI线程再解析该文件，在这同时，html的解析也在进行，但不会渲染（还未形成渲染树）&lt;/p&gt;&lt;p&gt; 4. 当遇到内部css时，html的解析和css的解析同时进行&lt;/p&gt;&lt;p&gt; 5. 继续解析html文件，当遇到外源js时，Browser进程下载该js文件并发送回来，此时，js引擎线程解析并执行js，因为GUI线程和js引擎线程互斥，所以GUI线程被挂起，停止继续解析html。直到js引擎线程空闲，GUI线程继续解析html。&lt;/p&gt;&lt;p&gt; 6. 遇到内部js也是同理&lt;/p&gt;&lt;p&gt; 7. 解析完html文件，形成了完整的DOM树，也解析完了css，形成了完整的CSSOM树，两者结合形成了render树&lt;/p&gt;&lt;p&gt; 8. 根据render树来进行布局，若在布局的过程中发生了元素尺寸、位置、隐藏的变化或增加、删除元素时，则进行回流，修改&lt;/p&gt;&lt;p&gt; 9. 根据render树进行绘制&lt;/p&gt;&lt;p&gt; 10. 将布局、绘制得到的各个简单图层的位图发送给Browser进程，由它来合并简单图层为复合图层，从而显示到页面上&lt;/p&gt;&lt;p&gt; 11. 以上步骤就是html文件解析全过程，完成之后，如若当页面有元素的尺寸、大小、隐藏有变化时，重新布局计算回流，并修改页面中所有受影响的部分，如若当页面有元素的外观发生变化时，重绘&lt;/p&gt;&lt;/div&gt;
&lt;p&gt; (完)&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;1.CSS3硬件加速也有坑&lt;a href=&quot;http://web.jobbole.com/83575/&quot; target=&quot;_blank&quot;&gt;http://web.jobbole.com/83575/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2.浏览器渲染过程、回流、重绘简介&lt;a href=&quot;https://blog.csdn.net/cxl444905143/article/details/42005333&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/cxl444905143/article/details/42005333&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.页面优化，谈谈重绘(repaint)和回流(reflow)&lt;a href=&quot;https://www.cnblogs.com/echolun/p/10105223.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/echolun/p/10105223.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.你真的了解回流和重绘吗&lt;a href=&quot;https://www.cnblogs.com/chenjg/p/10099886.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/chenjg/p/10099886.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5.css加载会造成阻塞吗？&lt;a href=&quot;https://www.cnblogs.com/chenjg/p/7126822.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/chenjg/p/7126822.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6.从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理&lt;a href=&quot;https://segmentfault.com/a/1190000012925872#articleHeader20&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/a/1190000012925872#articleHeader20&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7.从输入URL到页面加载的过程？如何由一道题完善自己的前端知识体系！&lt;a href=&quot;https://segmentfault.com/a/1190000013662126&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/a/1190000013662126&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Feb 2019 07:30:00 +0000</pubDate>
<dc:creator>前端蔡蔡</dc:creator>
<og:description>前言  大家肯定都听说过很多浏览器优化原则吧，例如说减少DOM操作，使用transformX（0）进行硬件优化，避免js文件执行时间过长使得页面卡顿等等。大部分人可能都知道，但也仅限于知道，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caiyy/p/10406934.html</dc:identifier>
</item>
<item>
<title>Dotnet全平台下APM-Trace探索 - Cooper_Liu</title>
<link>http://www.cnblogs.com/yankliu-vip/p/how-to-implement-apm-tracer-on-dotnet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yankliu-vip/p/how-to-implement-apm-tracer-on-dotnet.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;随着支撑的内部业务系统越来越多，向着服务化架构进化，在整个迭代过程中，会逐渐暴露出以下问题。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2.5&quot;&gt;
&lt;p&gt;传统依赖于应用服务器日志等手段的排除故障原因的复杂度越来越高，传统的监控服务已经无法满足需求。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;终端--&amp;gt; Nginx --&amp;gt; IIS --&amp;gt; Asp.net 管道 --&amp;gt; [数据缓存]-&amp;gt;[HTTP调用]-&amp;gt;[DB读写]

在以上调用链路上，我们以往勉强能从 Nginx 日志中分析出 客户端调用时长，Nginx 调用API服务时长。
但是到了应用程序代码，对于[数据缓存]-&amp;gt;[HTTP调用]-&amp;gt;[DB读写]等操作，变成了链路调用黑盒。&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;在出现性能问题定位，也严重依赖高级工程师经验，定位困难，指标不明确。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在分析整个应用调用链路，不能清晰、直观的分析展现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;度量metrics跟踪tracing日志logging&quot;&gt;度量(Metrics),跟踪(Tracing),日志(Logging)&lt;/h2&gt;
&lt;p&gt;Logging，Metrics 和 Tracing 有各自专注的部分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Logging - 用于记录离散的事件。例如，应用程序的调试信息或错误信息。它是我们诊断问题的依据。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Metrics - 用于记录可聚合的数据。例如，队列的当前深度可被定义为一个度量值，在元素入队或出队时被更新；HTTP 请求个数可被定义为一个计数器，新请求到来时进行累加。&lt;/li&gt;
&lt;li&gt;Tracing - 用于记录请求范围内的信息。例如，一次远程方法调用的执行过程和耗时。它是我们排查系统性能问题的利器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/92806aa2426813a4f47e6ba9b01f76f7.png&quot; alt=&quot;Logging&amp;amp;Metrics&amp;amp;Tracing&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细阅读，参考&lt;a href=&quot;http://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html?spm=a2c4e.11153940.blogcont514488.18.716311f4y9HPNA&quot;&gt;度量(Metrics),跟踪(Tracing),日志(Logging)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这三者的交集，才是对于我们分析应用程序运行状态及调用链路分析，有这直观重要的意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;日志（Logging）&lt;/strong&gt;，可以使用ELK技术栈，解决我们的应用程序日志查询分析的大部分需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;度量(Metrics)&lt;/strong&gt;，可以使用&lt;a href=&quot;https://github.com/AppMetrics/AppMetrics&quot;&gt;AppMetrics&lt;/a&gt; 和 &lt;a href=&quot;https://prometheus.io/&quot;&gt;Prometheus&lt;/a&gt; 来满足一部分需求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跟踪(Tracing)&lt;/strong&gt;，全链路的调用分析追踪，目前解决方案大部分也是商业解决方案，如Application Insights、OneAPM、听云、Datadog等，开源方案，如&lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet&quot;&gt;SkyAPM&lt;/a&gt; (.net core适用)&lt;/p&gt;
&lt;p&gt;目前，针对 .net 平台下探针的解决方案进行调研，大部分是付费，开源方案大部分针对 .net core。&lt;/p&gt;
&lt;p&gt;有没有一种可能，我们使用开源技术，搭建自己的全链路调用分析的解决方案，这是本篇博文需要探索的议题。&lt;/p&gt;
&lt;p&gt;我们将带着以下几个问题，进行探索解决方案&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们基于什么标准规范来收集指标？&lt;/li&gt;
&lt;li&gt;出于保护企业现有投资的情况下，我们需要针对Full Framework（.net Framework、.net core）下进行支持，也可以考虑公有云应用监控。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;代码级定位性能问题&lt;/li&gt;
&lt;li&gt;记录应用错误过程&lt;/li&gt;
&lt;li&gt;检测慢SQL语句&lt;/li&gt;
&lt;li&gt;检测外部调用API耗时&lt;/li&gt;
&lt;li&gt;检测调用外部HTTP请求耗时，请求信息记录&lt;/li&gt;
&lt;li&gt;请求/RPC 调用关系拓扑&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;基于什么架构来搭建，有哪些组件可用，能不能达到商业解决方案的相差无几的解决方案？&lt;/li&gt;
&lt;li&gt;用什么的技术来实现？&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;跟踪tracing标准-opentracking&quot;&gt;跟踪（Tracing）标准 OpenTracking&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://opentracing.io/docs/overview/&quot;&gt;OpenTracking&lt;/a&gt; 为监测提供了一组标准的框架无关、厂商无关的标准规范，这意味着开发者能够很方便的添加/切换跟踪系统&lt;/p&gt;
&lt;p&gt;简单说，OpenTracking 提供了一组规范，也是分布式跟踪系统的标准的抽象，来解决不同的分布式追踪系统的API标准的不兼容问题。OpenTracing 是一个轻量级的标准化层，它位于应用程序/类库和追踪或日志分析程序之间。&lt;/p&gt;
&lt;p&gt;更多关于 OpenTracing 数据模型的知识，请参考 &lt;a href=&quot;https://github.com/opentracing-contrib/opentracing-specification-zh/blob/master/specification.md?spm=a2c4e.11153940.blogcont514488.22.716311f4FTTABD&amp;amp;file=specification.md&quot;&gt;OpenTracing语义标准&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;技术探索&quot;&gt;技术探索&lt;/h3&gt;
&lt;p&gt;分布式追踪系统，由追踪器(Tracker)、追踪信息收集代理（Agent）、追踪信息存储分析服务（APM Server）组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;追踪器(Tracker)&lt;/strong&gt;：负责应用程序监控（代码级别执行时间、异常调用）&lt;br/&gt;&lt;strong&gt;追踪信息收集代理（Agent）&lt;/strong&gt;：负责应用程序监控信息上报&lt;br/&gt;&lt;strong&gt;追踪信息存储分析服务（APM Server）&lt;/strong&gt;：负责存储应用程序监控信息存储分析展示等服务&lt;/p&gt;
&lt;h4 id=&quot;追踪器tracker&quot;&gt;追踪器(Tracker)&lt;/h4&gt;
&lt;p&gt;代码埋点是实现Tracker重要一步。&lt;/p&gt;
&lt;p&gt;如果在业务代码中实现追踪埋点，不但工程量大，而且代码入侵严重。&lt;/p&gt;
&lt;pre class=&quot;cshap&quot;&gt;
&lt;code&gt;var tracker = Tracker.Instance;

using(var context = tracker.Begin())
{
    context.SetSpan(&quot;name of span&quot;);
    
    /// some business logic
    
    context.EndSpan();
    
    tracker.Send(context); 
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了实现dotnet全平台下（Framework、dotcore）追踪，我们需要清楚C#代码是如何变成机器可运行的代码。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一步，C# 编译生成中间语言 IL&lt;/li&gt;
&lt;li&gt;第二步，中间语言IL 通过CLR的即时编译JIT，编译成Native Code&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们只能通过，在CLR即时编译 IL之前，&lt;strong&gt;修改已生成的IL&lt;/strong&gt;，来实现&lt;strong&gt;代码埋点&lt;/strong&gt;。这样以来，我们便可以轻松的实现零入侵业务代码。&lt;/p&gt;
&lt;p&gt;如何实现&lt;strong&gt;修改已生成的IL&lt;/strong&gt; ？ 我们通过实现CLR公共语言运行时&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/unmanaged-api/profiling/icorprofilercallback-jitcompilationstarted-method&quot;&gt;ICorProfilerCallback&lt;/a&gt; 中重写JITCompilationStarted 方法即可实现。&lt;/p&gt;
&lt;p&gt;在dotnet core 下通过DiagnosticSource 实现，应用程序性能诊断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DiagnosticSource&lt;/strong&gt; VS &lt;strong&gt;EventSource&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;EventSource，只支持Windows，主要记录可序列化的数据，被进程意外的消费。&lt;/li&gt;
&lt;li&gt;DiagnosticSource，支持 .net core下，主要在进程内处理数据，可以支持非序列化的对象，比如HttpConext，HttpResponse。&lt;/li&gt;
&lt;li&gt;如果在 EventSource 中获取 DiagnosticSource 中的事件数据，可以通过 DiagnosticSourceEventSource 这个对象来进行数据桥接。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;/h2&gt;
</description>
<pubDate>Wed, 20 Feb 2019 07:27:00 +0000</pubDate>
<dc:creator>Cooper_Liu</dc:creator>
<og:description>背景 随着支撑的内部业务系统越来越多，向着服务化架构进化，在整个迭代过程中，会逐渐暴露出以下问题。 1. 传统依赖于应用服务器日志等手段的排除故障原因的复杂度越来越高，传统的监控服务已经无法满足需求。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yankliu-vip/p/how-to-implement-apm-tracer-on-dotnet.html</dc:identifier>
</item>
<item>
<title>使用Git过程中经常会遇到的问题 - 悠悠i</title>
<link>http://www.cnblogs.com/youyoui/p/10406712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youyoui/p/10406712.html</guid>
<description>&lt;h2 id=&quot;git-pull如何强制覆盖本地文件&quot;&gt;&lt;code&gt;git pull&lt;/code&gt;如何强制覆盖本地文件&lt;/h2&gt;
&lt;p&gt;error: Untracked working tree file 'public/images/icon.gif' would be overwritten by merge.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;code&gt;git reset&lt;/code&gt;命令&lt;/strong&gt;&lt;br/&gt;重要提示：如果您有任何本地更改，将会丢失。无论是否有--hard选项，任何未被推送的本地提交都将丢失。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 从远程下载最新的，而不尝试合并或rebase任何东西
git fetch -all

# 将主分支重置为您刚刚获取的内容
git reset --hard origin/&amp;lt;branch_name&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在重置之前可以通过从master创建一个分支来维护当前的本地提交：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git checkout master
git branch new-branch-to-save-current-commits
git fetch --all
git reset --hard origin/master&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在此之后，所有旧的提交都将保存在new-branch-to-save-current-commits中。然而，没有提交的更改(即使staged)将会丢失。确保存储和提交任何你需要的东西。&lt;/p&gt;
&lt;h2 id=&quot;git如何同时删除本地分支和远程分支&quot;&gt;Git如何同时删除本地分支和远程分支&lt;/h2&gt;
&lt;p&gt;删除分支使用&lt;code&gt;--delete&lt;/code&gt;(&lt;code&gt;-d&lt;/code&gt;)选项，命令如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git push --delete &amp;lt;remote_name&amp;gt; &amp;lt;branch_name&amp;gt;
git branch -d &amp;lt;branch_name&amp;gt;

# 只删除本地分支
git branch -d branch_name
git branch -D branch_name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;远程分支名称一般是origin，比如：origin/dev&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt;选项的全写是&lt;code&gt;--delete&lt;/code&gt;，当前分支必须从上游分支完全合并才能删除&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-D&lt;/code&gt;选项的全写是&lt;code&gt;--delete --force&lt;/code&gt;，强制删除，无论当前分支的合并状态如何&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另外根据Git版本的不同，还可以选用下面的命令&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# Git v1.7.0以上版本
git push &amp;lt;remote_name&amp;gt; --delete &amp;lt;branch_name&amp;gt;
# 上面的命令可简写
git push &amp;lt;remote_name&amp;gt; :&amp;lt;branch_name&amp;gt;

# Git v2.8.0以上版本可以用 -d`
git push &amp;lt;remote_name&amp;gt; --d &amp;lt;branch_name&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;git如何撤销最近一次提交&quot;&gt;Git如何撤销最近一次提交&lt;/h2&gt;
&lt;h3 id=&quot;git撤销本地的最后一次提交&quot;&gt;Git撤销本地的最后一次提交&lt;/h3&gt;
&lt;p&gt;如果你只是在本地进行提交&lt;code&gt;commit&lt;/code&gt;，还没有推送&lt;code&gt;push&lt;/code&gt;到远程，可以使用&lt;code&gt;git reset HEAD^&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;git reset --soft HEAD^&lt;/code&gt; 保留提交之后的本地文件修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset --hard HEAD^&lt;/code&gt; 不保留提交之后的本地文件修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset --soft HEAD^1&lt;/code&gt; 和 &lt;code&gt;git reset --soft HEAD^&lt;/code&gt; 等效&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 弄错了一次错误提交
git commit -m '错误提交'

# 撤销本地提交
git reset HEAD^

# 修改文件后继续提交
git add ...
git commit -c ORIG_HEAD&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;git reset HEAD~&lt;/code&gt;命令会使工作树（磁盘上文件的状态）保持不变，但会撤销本地提交，并使您提交的更改保持未保存状态（这些更改将显示为“未提交的更改”，您需要在提交之前再次添加它们）。&lt;/p&gt;
&lt;p&gt;另外还需要注意，如果你想保留上次提交之后本地的文件修改，使用&lt;code&gt;--soft&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;git撤销最近一次远程提交&quot;&gt;Git撤销最近一次远程提交&lt;/h3&gt;
&lt;p&gt;如果你已经把提交推送到远程，只能本地回滚然后再次提交。&lt;/p&gt;
&lt;p&gt;回滚到上一次的命令使用&lt;code&gt;git revert HEAD&lt;/code&gt;，对文件重新修改后提交到远程即可。&lt;/p&gt;
&lt;h2 id=&quot;如何修改提交信息和文件&quot;&gt;如何修改提交信息和文件&lt;/h2&gt;
&lt;h3 id=&quot;修改本地提交信息未推送到远程&quot;&gt;修改本地提交信息（未推送到远程）&lt;/h3&gt;
&lt;p&gt;如果你在本地进行了一次提交commit，这个提交还未推送到远程，但是这次提交你忘了写message或者少提交了文件。&lt;/p&gt;
&lt;p&gt;一方面可以使用上面介绍的方法撤销这次提交，修改之后再提交一次。&lt;br/&gt;另一方面你可以使用&lt;code&gt;git commit --amend -m '新的提交信息'&lt;/code&gt;提交一次。&lt;/p&gt;
&lt;h3 id=&quot;修改远程提交信息&quot;&gt;修改远程提交信息&lt;/h3&gt;
&lt;p&gt;如果想要修改的提交信息已经被推送到远程，可以使用&lt;code&gt;git push -f&lt;/code&gt;强制提交覆盖：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt; --force
# Or
git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt; -f&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外也可以使用&lt;code&gt;git rebase&lt;/code&gt;命令，该命令可以修改所有的提交信息（即使不是最后一次提交）。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# X 表示落后于HEAD的提交次数，如果不填默认为1，即上一次提交
git rebase -i HEAD^X&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;git如何在提交之前撤销git-add&quot;&gt;Git如何在提交之前撤销&lt;code&gt;git add&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;如果你不小心把某个配置文件进行&lt;code&gt;git add&lt;/code&gt;，可以使用&lt;code&gt;git reset&lt;/code&gt;进行撤销。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;git reset &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git rm --cached &amp;lt;added_file_to_undo&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# git add错了一个配置文件
git add db.conf

# 撤销上一次git add
git reset db.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;git如何重命令本地分支&quot;&gt;Git如何重命令本地分支&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;git branch -m&lt;/code&gt;即可，其中&lt;code&gt;-m&lt;/code&gt;表示&lt;code&gt;move&lt;/code&gt;(mv)：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 重命名本地分支
git branch -m &amp;lt;oldname&amp;gt; &amp;lt;newname&amp;gt;

# 如果重命名的是当前分支
git branch -m &amp;lt;newname&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何在git中添加一个空文件夹&quot;&gt;如何在Git中添加一个空文件夹&lt;/h2&gt;
&lt;p&gt;在Git中添加空文件夹并不会被提交，如果要提交一个空文件夹该怎么做呢？&lt;/p&gt;
&lt;p&gt;可以在空文件夹中创建一个&lt;code&gt;.gitignorefile&lt;/code&gt;文件或者&lt;code&gt;.gitkeep&lt;/code&gt;文件，并提交即可。&lt;/p&gt;
&lt;h2 id=&quot;如何在git中从远程分支克隆到本地&quot;&gt;如何在Git中从远程分支克隆到本地&lt;/h2&gt;
&lt;p&gt;如果只是克隆Git项目，默认本地是master分支，可以使用&lt;code&gt;git checkout&lt;/code&gt;克隆其他远程分支：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 克隆git项目
git clone &amp;lt;Git_Project&amp;gt;

# 克隆远程分支到本地
git checkout &amp;lt;branch_name&amp;gt;

# 拉取远程分支，创建本地分支并切换到新分支
git checkout -b &amp;lt;local_branch&amp;gt; origin/&amp;lt;remote_branch&amp;gt;

# 只克隆远程分支
git checkout origin/&amp;lt;remote_branch&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;git如何将本地分支推送到远程&quot;&gt;Git如何将本地分支推送到远程&lt;/h2&gt;
&lt;p&gt;在Git 1.7.0版本以后，可以像下面一样操作：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 在本地新建分支
git checkout -b &amp;lt;branch&amp;gt;
# 将本地分支推送到远程
git push -u origin &amp;lt;branch&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何在git中丢弃掉当前工作分支下所有untracked的文件&quot;&gt;如何在Git中丢弃掉当前工作分支下所有untracked的文件&lt;/h2&gt;
&lt;p&gt;untracked的文件即没有&lt;code&gt;git add&lt;/code&gt;的文件，可以按照下面的步骤进行操作，该操作一定要确保这些文件确实不再需要：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 先检查当前的Untracked文件列表
git status

# 丢弃所有 untracked 文件
git checkout -- .

# 只丢弃特定的 untracked 文件 
git checkout - path/to/file

# 另外 git clean 命令也可以用于清理
git clean -df&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;git如何从远程拉取并强制覆盖本地文件&quot;&gt;Git如何从远程拉取并强制覆盖本地文件&lt;/h2&gt;
&lt;p&gt;当我们本地修改了很多测试代码时，需要全部丢弃掉这些修改，或者需要更新到最新的远程分支。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 从远程拉取所有修改
git fetch --all

# 强制重置到远程分支
git reset --hard origin/&amp;lt;branch_name&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们本地因为乱七八糟的修改导致无法提交、合并或者冲突，但是又不关心本地的修改时，可用下面的万能命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;git reset --hard
git pull&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;git提交代码时发生冲突不能合入&quot;&gt;Git提交代码时发生冲突不能合入&lt;/h2&gt;
&lt;p&gt;这种冲突发生在Web端对分支进行了操作，但是本地端没有&lt;code&gt;git pull&lt;/code&gt;同步代码就修改提交，导致两部分代码冲突。按照下面的步骤来，比如当前分支&lt;code&gt;uusama&lt;/code&gt;，推送到远程合并时出现冲突。&lt;/p&gt;
&lt;p&gt;按照下面的步骤来，比如当前分支&lt;code&gt;uusama&lt;/code&gt;，推送到远程合并时出现冲突。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# Step1. 在本地仓库中, 更新并合并代码
git fetch origin
git rebase origin/uusama
# Step2. 依据提示分别打开冲突的文件, 逐一修改冲突代码
# Step3. 所有冲突都修改完毕后, 提交修改的代码
git add -u
git rebase --continue
# Step4. 提交代码到远程分支 uusama
git push origin HEAD:refs/for/uusama&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中使用&lt;code&gt;HEAD:refs/for/uusama&lt;/code&gt;表示代码需要CODE review才可以合入。如果不用CODE review，可直接使用&lt;code&gt;git push origin uusama&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;git两个分支之间出现冲突如何解决&quot;&gt;Git两个分支之间出现冲突如何解决&lt;/h2&gt;
&lt;p&gt;比如当前有一个共有的开发分支&lt;code&gt;dev&lt;/code&gt;（基准分支），个人分支&lt;code&gt;uusama&lt;/code&gt;两个分支出现冲突。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 拉取分支需要解决冲突的分支
git checkout uusama
# 从基准分支合并
git merge --no-ff origin/dev
git add .
git commit -m &quot;合并分支解决冲突&quot;
# 提交代码到远程分支 uusama
git push origin HEAD:refs/for/uusama&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 20 Feb 2019 07:06:00 +0000</pubDate>
<dc:creator>悠悠i</dc:creator>
<og:description>细数那些使用Git过程中遇到的问题：分支冲突怎么解决？怎么撤销commit？怎么撤销 git add？怎么重置？怎么回滚？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youyoui/p/10406712.html</dc:identifier>
</item>
<item>
<title>如何在ASP.NET Core中自定义Azure Storage File Provider - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10406566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10406566.html</guid>
<description>&lt;blockquote readability=&quot;4.0372093023256&quot;&gt;
&lt;p&gt;文章标题：如何在ASP.NET Core中自定义Azure Storage File Provider&lt;br/&gt;作者：Lamond Lu&lt;br/&gt;地址：&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10406566.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lwqlun/p/10406566.html&lt;/a&gt;&lt;br/&gt;项目源代码： &lt;a href=&quot;https://github.com/lamondlu/AzureFileProvider&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/AzureFileProvider&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190220144817172-2108936925.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ASP.NET Core是一个扩展性非常高的框架，开发人员可以根据自己的需求扩展出想要的功能。File Provider是ASP.NET Core中的一个重要组件，通过这个组件，开发人员可以暴露一组文件，并允许应用程序像访问静态文件一样访问暴露的文件。&lt;/p&gt;
&lt;p&gt;ASP.NET Core中内置了3种File Provider&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;PhysicalFileProvider&lt;/code&gt; - 用来访问和应用程序部署在一起的静态文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ManifestEmbeddedFileProvider&lt;/code&gt; - 用来访问程序集中的内嵌文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CompositeFileProvider&lt;/code&gt; - 将多个File Provider合并使用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么如何自定义一个File Provider呢？比如如何将Azure Files Storage中的文件暴露给ASP.NET Core应用程序。今天我们来演示一下，如果通过实现&lt;code&gt;IFileProvider&lt;/code&gt; 接口来实现一个Azure Files Storage Provider。&lt;/p&gt;
&lt;blockquote readability=&quot;4.9787234042553&quot;&gt;
&lt;p&gt;本文中只针对Azure Files Storage, Azure Blob Storage的实现可以参见&lt;a href=&quot;https://www.strathweb.com/2018/08/azure-blob-storage-ifileprovider-for-asp-net-core/&quot;&gt;Filip w的博文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先我们使用Visual Studio 2017，创建一个Class Library项目， 命名为AzureFileProvider&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190220144934920-181506334.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了使用&lt;code&gt;IFileProvider&lt;/code&gt;接口和Azure Storage服务，这里我们需要使用Nuget引入2个库&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Microsoft.AspNetCore.App&lt;/li&gt;
&lt;li&gt;WindowsAzure.Storage&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了创建一个ASP.NET Core支持的File Provider, 我们就需要自己创建一个类，并让它实现&lt;code&gt;IFileProvider&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;这里首先我们创建一个类&lt;code&gt;AzureFileProvider&lt;/code&gt;, 它实现了&lt;code&gt;IFileProvider&lt;/code&gt;接口&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class AzureFileProvider : IFileProvider
    {
        public IDirectoryContents GetDirectoryContents(string subpath)
        {
            throw new NotImplementedException();
        }

        public IFileInfo GetFileInfo(string subpath)
        {
            throw new NotImplementedException();
        }

        public IChangeToken Watch(string filter)
        {
            throw new NotImplementedException();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上代码中，我们可以了解到，&lt;code&gt;IFileProvider&lt;/code&gt;接口定义了3个需要实现方法&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;GetDirectoryContents&lt;/code&gt; - 这个方法是用来获取指定目录下的内容的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetFileInfo&lt;/code&gt; - 这个方法使用来获取指定文件内容的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Watch&lt;/code&gt; - 这个方法是用来监听文件变更的，这个暂时不需要实现它&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实现getdirectorycontents方法&quot;&gt;实现&lt;code&gt;GetDirectoryContents&lt;/code&gt;方法&lt;/h2&gt;
&lt;p&gt;为了实现&lt;code&gt;GetDirectoryContents&lt;/code&gt;方法，我们需要首先创建一个&lt;code&gt;IDirectoryContents&lt;/code&gt;接口的实现类, 因为它是这个方法的返回类型。&lt;/p&gt;
&lt;p&gt;我们创建一个类&lt;code&gt;AzureStorageDirectoryContents&lt;/code&gt;, 它实现了&lt;code&gt;IDirectoryContents&lt;/code&gt;接口。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class AzureStorageDirectoryContents : IDirectoryContents
    {
        private List&amp;lt;IFileInfo&amp;gt; _listInfos;

        public AzureStorageDirectoryContents(List&amp;lt;IFileInfo&amp;gt; listInfos)
        {
            _listInfos = listInfos;
        }

        public bool Exists
        {
            get
            {
                return true;
            }
        }

        public IEnumerator&amp;lt;IFileInfo&amp;gt; GetEnumerator()
        {
            return _listInfos.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return _listInfos.GetEnumerator();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里&lt;code&gt;IDirectoryContents&lt;/code&gt;其实就是为了显示指定目录中的文件结构&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IFileInfo&lt;/code&gt;接口对象既可以表示文件也可以表示子目录，这个接口的2个实现我会在后面说明&lt;/li&gt;
&lt;li&gt;这里我们通过构造函数，将指定文件夹内的文件结构注入到了&lt;code&gt;AzureStorageDirectoryContents&lt;/code&gt;雷中。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;下面我们就可以来添加&lt;code&gt;GetDirectoryContents&lt;/code&gt;方法的实现了&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    private AzureStorageSetting _setting = null;

    public AzureFileProvider(AzureStorageSetting setting)
    {
        _setting = setting;
    }

    public IDirectoryContents GetDirectoryContents(string subpath)
    {
        var rootDirectory = GetRootDirectory();

        var folderName = subpath.Substring(1);
        CloudFileDirectory folder = null;

        if (string.IsNullOrWhiteSpace(folderName))
        {
            folder = rootDirectory;
        }
        else
        {
            folder = rootDirectory.GetDirectoryReference(folderName);
        }

        var files = new List&amp;lt;IFileInfo&amp;gt;();
        foreach (var item in folder
        .ListFilesAndDirectoriesSegmentedAsync(new FileContinuationToken())
        .Result
        .Results)
        {
            if (item is CloudFile)
            {
                var file = item as CloudFile;
                files.Add(new AzureFileInfo(file));
            }
            else if (item is CloudFileDirectory)
            {
                var directory = item as CloudFileDirectory;
                files.Add(new AzureDirectoryInfo(directory));
            }
        }

        return new AzureStorageDirectoryContents(files);
    }

    private CloudFileDirectory GetRootDirectory()
    {
        var shareName = _setting.ShareName;
        var storageAccount = CloudStorageAccount.Parse(_setting.ConnectionString);
        var fileClient = storageAccount.CreateCloudFileClient();
        var share = fileClient.GetShareReference(shareName);
        var rootDir = share.GetRootDirectoryReference();

        return rootDir;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里我们通过构造函数为&lt;code&gt;AzureFileProvider&lt;/code&gt;类注入了一个Azure Files Storage强类型配置类&lt;code&gt;AzureStorageSetting&lt;/code&gt;, 它的数据源是appSettings.json, 后续我们会通过强类型配置将其注入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetRootDirectory&lt;/code&gt;方法是通过Azure Files Storage配置，获得Azure Files Storage中文件集合的根目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GetDirectoryContents&lt;/code&gt;中&lt;code&gt;subpath.Substring(1)&lt;/code&gt;代码的作用是去除subpath带的第一个“/”。如果不去除，会读取不到文件&lt;/li&gt;
&lt;li&gt;这里我们使用了&lt;code&gt;ListFilesAndDirectoriesSegmentedAsync&lt;/code&gt;方法获取了指定目录中所有的文件和目录&lt;/li&gt;
&lt;li&gt;如果是文件，我们会实例化一个&lt;code&gt;AzureFileInfo&lt;/code&gt;对象，如果是一个目录，我们会实例化一个&lt;code&gt;AzureDirectoryInfo&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;最终我们将读取到的所有文件和目录信息通过&lt;code&gt;AzureStorageDirectoryContents&lt;/code&gt;类的构造函数注入。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;创建azurefileinfo和azuredirectoryinfo&quot;&gt;创建&lt;code&gt;AzureFileInfo&lt;/code&gt;和&lt;code&gt;AzureDirectoryInfo&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;为了区分文件和目录，我们创建2个新类&lt;code&gt;AzureFileInfo&lt;/code&gt;和&lt;code&gt;AzureDirectoryInfo&lt;/code&gt;。 他们都实现了&lt;code&gt;IFileInfo&lt;/code&gt;接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AzureFileInfo&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class AzureFileInfo : IFileInfo
    {
        private CloudFile _file = null;
        private MemoryStream _stream = new MemoryStream();

        public AzureFileInfo(CloudFile file)
        {
            _file = file;
            _file.DownloadRangeToStreamAsync(_stream, null, null).Wait();
            _stream.Position = 0;
        }

        public bool Exists
        {
            get
            {
                return true;
            }
        }

        public long Length
        {
            get
            {
                return _stream.Length;
            }
        }

        public string PhysicalPath
        {
            get
            {
                return _file.Uri.AbsolutePath;
            }
        }

        public string Name
        {
            get
            {
                return _file.Name;
            }
        }

        public DateTimeOffset LastModified
        {
            get
            {
                return _file.Properties.LastModified.GetValueOrDefault();
            }
        }

        public bool IsDirectory
        {
            get
            {
                return false;
            }
        }


        public Stream CreateReadStream()
        {
            return _stream;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里我们通过&lt;code&gt;AzureFileInfo&lt;/code&gt;的构造函数传入了一个&lt;code&gt;CloudFile&lt;/code&gt;对象, 这个对象将作为&lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;PhysicalPath&lt;/code&gt;, &lt;code&gt;LastModified&lt;/code&gt;等属性的数据源。&lt;/li&gt;
&lt;li&gt;我们使用&lt;code&gt;CloudFile&lt;/code&gt;对象&lt;code&gt;DownloadRangeToStreamAsync&lt;/code&gt;, 将其对应的文件流下载。注意这里加载文件流之后，需要将文件流的Position置0(即流的头部)&lt;/li&gt;
&lt;li&gt;文件的长度即文件流的长度&lt;/li&gt;
&lt;li&gt;强制设置&lt;code&gt;IsDirectory&lt;/code&gt;属性为false, 因为当前处理的是文件&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;AzureDirectoryInfo&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class AzureDirectoryInfo : IFileInfo
    {
        private CloudFileDirectory _directory = null;

        public AzureDirectoryInfo(CloudFileDirectory directory)
        {
            _directory = directory;
        }

        public bool Exists
        {
            get
            {
                return true;
            }
        }

        public long Length =&amp;gt; throw new NotImplementedException();

        public string PhysicalPath
        {
            get
            {
                return _directory.Uri.AbsolutePath;
            }
        }

        public string Name
        {
            get
            {
                return _directory.Name;
            }
        }

        public DateTimeOffset LastModified
        {
            get
            {
                return _directory.Properties.LastModified.GetValueOrDefault();
            }
        }

        public bool IsDirectory
        {
            get
            {
                return true;
            }
        }

        public Stream CreateReadStream()
        {
            throw new NotImplementedException();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里我们通过&lt;code&gt;AzureDirectoryInfo&lt;/code&gt;的构造函数传入了一个&lt;code&gt;CloudFileDirectory&lt;/code&gt;对象, 这个对象将作为&lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;PhysicalPath&lt;/code&gt;, &lt;code&gt;LastModified&lt;/code&gt;等属性的数据源。&lt;/li&gt;
&lt;li&gt;强制设置&lt;code&gt;IsDirectory&lt;/code&gt;属性为true, 因为当前处理的是目录&lt;/li&gt;
&lt;li&gt;这里我们没有实现&lt;code&gt;Length&lt;/code&gt;属性和&lt;code&gt;CreateReadStream&lt;/code&gt;, 因为我们处理的是目录, 这2个属性没有必要实现。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;实现getfileinfo方法&quot;&gt;实现&lt;code&gt;GetFileInfo&lt;/code&gt;方法&lt;/h2&gt;
&lt;p&gt;相对于&lt;code&gt;GetDirectoryContents&lt;/code&gt;方法的实现，&lt;code&gt;GetFileInfo&lt;/code&gt;方法就简单多了，我们只需要根据当前指定的subpath, 将文件信息返回即可。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public IFileInfo GetFileInfo(string subpath)
    {
        var rootDirectory = GetRootDirectory();
        var file = rootDirectory
        .GetFileReference(subpath.Substring(1));

        return new AzureFileInfo(file);
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;下面我们来试验一下我们编写的AzureFileProvider是否能运行成功。&lt;/p&gt;
&lt;p&gt;首先我们创建一个默认ASP.NET Core Api项目，并引用上一步中编译好的程序集AzureFileProvider.dll。&lt;/p&gt;
&lt;p&gt;appSettings.json中, 我们需要定义Azure Files Storage的配置&lt;/p&gt;
&lt;p&gt;例：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Warning&quot;
    }
  },
  &quot;AzureStorage&quot;: {
    &quot;ConnectionString&quot;: &quot;DefaultEndpointsProtocol=https;AccountName=fdsffsdf;AccountKey=fdsfsdfs;EndpointSuffix=core.windows.net&quot;,
    &quot;ShareName&quot;: &quot;testShare&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步，我们需要修改&lt;code&gt;Startup.cs&lt;/code&gt;文件的&lt;code&gt;Configure&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public void Configure(IApplicationBuilder app, IHostingEnvironment env)
    {
        AzureStorageSetting o = new AzureStorageSetting();
        Configuration.Bind(&quot;AzureStorage&quot;, o);

        app.UseStaticFiles(new StaticFileOptions
        {
            FileProvider = new AzureFileProvider(o),
            RequestPath = &quot;/files&quot;
        });
        
        app.UseDirectoryBrowser(new DirectoryBrowserOptions
        {
            FileProvider = new AzureFileProvider(o),
            RequestPath = &quot;/files&quot;
        });

        app.UseMvc();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码解释&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这里我们使用强类型配置绑定，获取了appSettings.json中的Azure Files Storage的配置&lt;/li&gt;
&lt;li&gt;在配置静态文件中间件部分，我们通过&lt;code&gt;StaticFileOptions&lt;/code&gt;配置对象，指定了当前应用使用AzureFileProvider。&lt;/li&gt;
&lt;li&gt;为了演示效果，我这里也启用了DirectoryBrowser中间件，即可以使用网页查看目录结构。这个功能比较危险，在正式项目很少使用。所以正式使用时，最好将这段代码删掉。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;最终效果&quot;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;现在我们启动当前项目, 访问&quot;/files&quot;, 即可查看到当前指定Azure Files Storage中的所有文件和目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190220144945225-590440286.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/lamondlu/AzureFileProvider&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/AzureFileProvider&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;以上类库，我已经发布到了Nuget上, 如果你不想每次都把前面的代码写一遍，可以直接安装这个程序集来使用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Install-Package LamondLu.AzureFileProvider&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 20 Feb 2019 06:57:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>文章标题：如何在ASP.NET Core中自定义Azure Storage File Provider 作者：Lamond Lu 地址：https://www.cnblogs.com/lwqlun/p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10406566.html</dc:identifier>
</item>
<item>
<title>Spring+SpringMVC+Mybatis整合 - 风沙迷了眼</title>
<link>http://www.cnblogs.com/fsmly/p/10393507.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsmly/p/10393507.html</guid>
<description>&lt;h2&gt;一、简单测试工程搭建&lt;/h2&gt;
&lt;p&gt;1、Mybatis所需要的的jar包（包含数据库驱动包和相关的日志包）、SpringMVC和Spring的jar包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190220142707660-323618486.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、然后构建一个基本的工程，这里我们使用mapper代理的方式进行Mybatis的编写，关于mapper代理请参考&lt;a href=&quot;https://www.cnblogs.com/fsmly/p/10324491.html&quot; target=&quot;_blank&quot;&gt;Mybatis简单入门&lt;/a&gt;中的&lt;strong&gt;Mybatis开发dao方法简介&lt;/strong&gt;中讲到的mapper代理方式，所以在项目中我们不建立dao包，需要建立mapper包用来存放mapper接口和相应的mapper配置文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190220142524107-456641909.png&quot; alt=&quot;&quot; width=&quot;291&quot; height=&quot;459&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、配置Mybatis和Spring整合&lt;/h2&gt;
&lt;p&gt;1、配置Mybatis的核心配置文件，因为是和Spring整合，所以数据库的配置交给Spring管理由Spring进行数据源的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE configuration
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;批量别名定义：Mybatis在定义别名的时候会自动扫描包中的po类，自动的将别名定义为类名（首字母大写或者小写都可以）&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;package &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;cn.test.ssm.mapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;typeAliases&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;configuration&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2、下来是Spring和Mybatis的整合，可以参考前面的&lt;a href=&quot;https://www.cnblogs.com/fsmly/p/10347277.html&quot; target=&quot;_blank&quot;&gt;Mybatis和Spring整合&lt;/a&gt;篇中的mapper代理方式。到这里我们就需要配置Spring整合Mybatis的配置文件了，在Spring和Mybatis的整合文件applicationContext-dao.xml配置文件中我们需要配置数据源（dataSource）、会话工厂（sqlSessionFactory）和Mapper扫描器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;       xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/beans
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/aop
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/aop/spring-aop.xsd
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/context
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/context/spring-context.xsd
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/tx
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;加载数据库信息的配置文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:property-placeholder &lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;=&quot;classpath:db.properties&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context:property-placeholder&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置数据源&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;driverClass&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.driver}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;jdbcUrl&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.url}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;user&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.username}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;password&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;${jdbc.password}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置SqlSessionFactory&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;sqlSessionFactory&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;加载Mybatis的配置文件&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;configLocation&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;classpath:mybatis/sqlMapConfig.xml&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置数据源&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置mapper扫描器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;basePackage&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;cn.test.ssm.mapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;sqlSessionTemplateBeanName&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;sqlSessionFactory&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、接下来我们就开始编写一个简单测mapper测试配置文件，只完成一个小功能（查询一个列表集合） ，在里面使用一些简单的动态sql进行判断避免异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;mapper为根元素，namespace指定了命名空间&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;cn.test.ssm.mapper.ProductDemo&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;实现一个简单的列表查询的功能（使用动态sql和sql片段便于扩展，虽然这只是个小的demo并没有做其他的扩展，但是可以养成一种习惯）&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;sql片段+动态sql&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;sql &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;queryListCondition&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;productExtend != null&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;if &lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;=&quot;productExtend.name != null and productExtend.name != ''&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                    product.pname LIKE '%${productExtend.name}%'
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;sql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;为了便于扩展，使用ProductExtent类作为输出映射，这样除了可以查询Product之外还可以扩展其他的字段&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;findProductListByName&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;cn.test.ssm.po.ProductQueryVo&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;cn.test.ssm.po.ProductExtend&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        SELECT product.* FROM product
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;include &lt;/span&gt;&lt;span&gt;refid&lt;/span&gt;&lt;span&gt;=&quot;queryListCondition&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;include&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;where&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、写完mapper配置文件之后就写一个接单的接口程序，其中只包含一个方法就是查询列表信息。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.test.ssm.mapper;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.po.ProductExtend;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.po.ProductQueryVo;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ProductDemo {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;ProductExtend&amp;gt; findProductListByName(ProductQueryVo productQueryVo) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、配置Spring和Service层整合&lt;/h2&gt;
&lt;p&gt;1、一般情况下都是定义service接口和对应的实现类，这里我们也定义一个简单的ProductService接口和其实现类作为service层的主要类&lt;/p&gt;
&lt;p&gt;①Product Service接口：主要就是要调用mapper接口中定义的那一个查询列表的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.test.ssm.service;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.po.ProductExtend;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.po.ProductQueryVo;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ProductService {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;ProductExtend&amp;gt; findProductListByName(ProductQueryVo productQueryVo) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;②ProductServiceImpl实现类，实现上面接口中的方法，由于要和Mybatis和Spring已经整合（采用mapper代理的方式），并且在applicationContext-dao配置文件中配置了mapper扫描器，所以我们可以使用注解的方式注入Mapper接口然后在service中调用接口中的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.test.ssm.service.impl;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.mapper.ProductDemo;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.po.ProductExtend;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.po.ProductQueryVo;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.service.ProductService;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProductServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ProductService {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; ProductDemo productDemo;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;自动注入mapper接口，然后在实现service的方法中调用mapper接口中的方法&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; List&amp;lt;ProductExtend&amp;gt; findProductListByName(ProductQueryVo productQueryVo) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; productDemo.findProductListByName(productQueryVo);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、上面写好了接口和实现类，然后就是将service交给Spring进行管理，配置applicationContext-service.xml对service进行整合。对service整合主要包括：service本身接口实现类的bean配置、事务控制等&lt;/p&gt;
&lt;p&gt;①管理service本身的接口实现类的bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;       xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/beans
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/aop
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/aop/spring-aop.xsd
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/context
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/context/spring-context.xsd
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/tx
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;对service本身的接口实现类的bean配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;productService&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;cn.test.ssm.service.impl.ProductServiceImpl&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;②进行事务控制的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;       xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/beans
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/beans/spring-beans.xsd
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/aop
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/aop/spring-aop.xsd
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/context
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/context/spring-context.xsd
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/tx
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        事务控制的配置
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        对数据库操作Mybatis的事务控制使用spring的jdbc事务管理控制类
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;事务管理器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;transactionManager&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;添加对数据源的控制&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;dataSource&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;property&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;通知&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:advice &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;txAdvice&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:attributes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置传播行为&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置必须进行事务控制的方法&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;save*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;delete*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:method&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;insert*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:method&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;update*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;REQUIRED&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:method&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置支持事务的方法&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;tx:method &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;find*&quot;&lt;/span&gt;&lt;span&gt; propagation&lt;/span&gt;&lt;span&gt;=&quot;SUPPORTS&quot;&lt;/span&gt;&lt;span&gt; read-only&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:method&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:attributes&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;tx:advice&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置aop去调用通知&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;aop:advisor &lt;/span&gt;&lt;span&gt;advice-ref&lt;/span&gt;&lt;span&gt;=&quot;txAdvice&quot;&lt;/span&gt;&lt;span&gt; pointcut&lt;/span&gt;&lt;span&gt;=&quot;execution(* cn.test.ssm.service.impl.*.*(..))&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:advisor&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;aop:config&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 四、配置整合springmvc和spring&lt;/h2&gt;
&lt;p&gt;1、首先配置springmvc的配置文件，其中包括&lt;span&gt;处理器映射器、处理器适配器、视图解析器的配置和对controller层包自动扫描&lt;/span&gt;的配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt; xmlns:mvc&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/mvc&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;       xmlns:context&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;       xmlns:aop&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/aop&quot;&lt;/span&gt;&lt;span&gt; xmlns:tx&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/tx&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/beans/spring-beans-3.2.xsd
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/mvc
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/context
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/context/spring-context-3.2.xsd
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/aop
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/aop/spring-aop-3.2.xsd
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/tx
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        http://www.springframework.org/schema/tx/spring-tx-3.2.xsd &quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置controller的扫描&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context:component-scan &lt;/span&gt;&lt;span&gt;base-package&lt;/span&gt;&lt;span&gt;=&quot;cn.test.ssm.controller&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context:component-scan&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置mvc:annotation代替基于注解方式的处理器映射器和适配器的配置&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mvc:annotation-driven&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mvc:annotation-driven&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、下来在web.xml中配置springmvc的前端控制器，里面主要包括DispatcherServlet的配置以及springmvc配置文件的路径配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;         xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         version&lt;/span&gt;&lt;span&gt;=&quot;4.0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置前端控制器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringMvc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            org.springframework.web.servlet.DispatcherServlet
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;&amp;lt;!--&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            配饰SpringMVC的配置文件（处理器映射器、适配器等）
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            注明需要这样配置的原因：自己配置contextConfigLocation，就不会自己默认加载/WEB-INF/下面的dispatch-servlet.xml
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;classpath:spring/applicationContext-springmvc.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SpringMvc&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;*.do&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、在controller层写handler程序&lt;/h2&gt;
&lt;p&gt;　　这里实现的功能也比较简单，由于只是为了测试整个整合流程的正确，所以依旧是按照查询列表进行编写，然后从service调用方法，返回模型视图、&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; cn.test.ssm.controller;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.po.ProductExtend;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; cn.test.ssm.service.ProductService;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Controller;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.servlet.ModelAndView;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;@Controller
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProductController {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; ProductService productService;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     @RequestMapping(&quot;/queryList.do&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ModelAndView queryList() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从service层调用方法&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         List&amp;lt;ProductExtend&amp;gt; productExtendList = productService.findProductListByName(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回ModelandView&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         ModelAndView modelAndView = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ModelAndView();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        modelAndView.addObject(productExtendList);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         modelAndView.setViewName(&quot;/WEB-INF/items/itemsList.jsp&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; modelAndView;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;六、配置Spring容器&lt;/h2&gt;
&lt;p&gt;　　到这里，我们还需要配置spring容器的监听和相应配置文件（applicationContext-dao.xml......）的加载。在配置文件中我们需要在IDEA中修改class文件的输出路径（本来默认是自动建立out文件，然后将class文件输出进去），参考&lt;a href=&quot;https://blog.csdn.net/sinat_18538231/article/details/79230202&quot; target=&quot;_blank&quot;&gt;这篇博客&lt;/a&gt;。至此，所有的配置都已经完成，下面就开始测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;配置spring容器的监听器&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/WEB-INF/classes/spring/applicationContext-*.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.context.ContextLoaderListener&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;七、使用简单的jsp视图进行测试&lt;/h2&gt;
&lt;p&gt;1、数据库中的Product表信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_d2c6f92b-b654-454e-8206-24be0549286a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d2c6f92b-b654-454e-8206-24be0549286a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d2c6f92b-b654-454e-8206-24be0549286a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;CREATE TABLE `product` (
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;  `pid` INT(11) NOT NULL AUTO_INCREMENT,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;  `pname` VARCHAR(255) DEFAULT NULL,
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;  `shop_price` DOUBLE DEFAULT NULL,
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;  PRIMARY KEY (`pid`)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; ) ENGINE=INNODB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;product表创建的sql&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190220141810106-182412527.png&quot; alt=&quot;&quot; width=&quot;475&quot; height=&quot;94&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、然后在浏览器中输入http://localhost:8080/TestSSM2/queryList.do测试得到下面的结果信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190220141712259-929311954.png&quot; alt=&quot;&quot; width=&quot;921&quot; height=&quot;143&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 20 Feb 2019 06:28:00 +0000</pubDate>
<dc:creator>风沙迷了眼</dc:creator>
<og:description>一、简单测试工程搭建 1、Mybatis所需要的的jar包（包含数据库驱动包和相关的日志包）、SpringMVC和Spring的jar包 2、然后构建一个基本的工程，这里我们使用mapper代理的方式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsmly/p/10393507.html</dc:identifier>
</item>
<item>
<title>目标检测之YOLO V1 - Brook_icv</title>
<link>http://www.cnblogs.com/wangguchangqing/p/10406367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangguchangqing/p/10406367.html</guid>
<description>&lt;p&gt;前面介绍的R-CNN系的目标检测采用的思路是：首先在图像上提取一系列的候选区域，然后将候选区域输入到网络中修正候选区域的边框以定位目标，对候选区域进行分类以识别。虽然，在Faster R-CNN中利用RPN网络将候选区域的提取以放到了CNN中，实现了end-to-end的训练，但是其本质上仍然是提取&lt;strong&gt;先提取候选区域，然后对候选区域识别，修正候选区域的边框位置。&lt;/strong&gt;这称为&lt;strong&gt;tow-stage&lt;/strong&gt;的方法，虽然在精度已经很高了，但是其速度却不是很好。造成速度不好的主要原因就是候选区域的提取，这就需要一种网络能够直接预测出图像中目标的位置，中间不需要候选区域的计算，这就是&lt;strong&gt;one-stage&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;YOLO系就是&lt;strong&gt;one-stage&lt;/strong&gt;目标检测的一种，其全名&lt;em&gt;You only look once&lt;/em&gt;很形象，只需要将图片输入到网络中就预测中其中目标的bounding box以及bounding box所属的类别。相比R-CNN，YOLO损失了一定的精度，但是其有点就是速度快。&lt;/p&gt;
&lt;h2 id=&quot;yolo-v1&quot;&gt;YOLO V1&lt;/h2&gt;
&lt;p&gt;YOLO V1将目标检测定义为一个回归问题，从图像像素信息直接得到目标的边框以及所属类别的概率，其有以下的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快。其整个网络结构就是解决回归问题，很快。&lt;/li&gt;
&lt;li&gt;在做predict的时候，使用的一整张图像的全局信息。two-stage的方法，每次只是“看到”图像的一块区域，YOLO 一次“看”一整张图像，所以它可以将目标整个的外观信息以及类别进行编码，目前最快最好的Fast R-CNN，较容易误将图像中的 background patches （背景的一个小块）看成是物体，因为它看的范围比较小。YOLO 的 background errors（背景错误） 比 Fast R-CNN 少一半多。&lt;/li&gt;
&lt;li&gt;YOLO得到的目标的特征表示更容易泛化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;YOLO 和R-CNN性能的对比&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190220141813324-761180908.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;YOLO的也有一定的缺点，其准确度落后于Faster R-CNN，并且由于其使用比较粗糙的网格来划分原图，导致其对小目标的检测效果不是很好。&lt;/p&gt;
&lt;h3 id=&quot;主要思路&quot;&gt;主要思路&lt;/h3&gt;
&lt;p&gt;相对于R-CNN系首先从原图中计算出一系列的候选区域，YOLO则使用简单的方法，首先将图像划分为&lt;span class=&quot;math inline&quot;&gt;\(S\times S\)&lt;/span&gt;（论文中&lt;span class=&quot;math inline&quot;&gt;\(S = 7\)&lt;/span&gt;）的网格，如果某个目标的中心位于一个grid cell中，则该grid cell就负责检测这个目标。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在YOLO网络中，目标的坐标信息是通过相对于某个grid cell左上角的偏移来表示的，目标的宽和高是用原图的宽和高占比表示的。 这就是这里为什么会说，&lt;em&gt;如果某个目标的中心位于一个grid cell中，则该grid cell就负责检测这个目标&lt;/em&gt;，在做边框回归的时候，其GT就是该grid cell。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190220141824091-2099728737.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面提到&lt;strong&gt;如果某个目标的中心位于一个grid cell中，则该grid cell就负责检测这个目标&lt;/strong&gt;，也就是说在YOLO中，grid cell设计为可以代表目标，在网络中也是针对grid cell进行处理的。 在每个grid cell中预测出来&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;(&lt;span class=&quot;math inline&quot;&gt;\(B = 2\)&lt;/span&gt;个bounding box，而且要为每个预测出来的bounding box打个分数，来表示该bounding box是否包含目标以及该bbox作为目标边框的可信度，这个分数称为Confidence。Confidence 的定义如下：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ Confidence = Pr(object) \cdot IoU_{pred}^{truth} \]&lt;/span&gt;&lt;br/&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(Pr(object)\)&lt;/span&gt;为bbox包含目标的概率（bbox存在目标则$Pr(object) =1 &lt;span class=&quot;math inline&quot;&gt;\(，不存在目标则\)&lt;/span&gt;Pr(object) = 0&lt;span class=&quot;math inline&quot;&gt;\(；\)&lt;/span&gt;IoU_{pred}^{truth}$表示预测出来的bbox和Ground Truth之间的IoU。 也就是说，如果bbox不含目标则其confidence = 0,包含目标的话Confidence就是bbox和Ground Truth之间的IoU。&lt;/p&gt;
&lt;p&gt;这样，通过每个grid cell预测出来的bbox可由一个五元组表示&lt;span class=&quot;math inline&quot;&gt;\((x,y,w,h,Confidence)\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\((x,y)\)&lt;/span&gt;表示bbox的中心相对该grid cell左上角的偏移量，使用grid cell的长宽为比例，将其值归一化到&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;之间；&lt;span class=&quot;math inline&quot;&gt;\((w,h)\)&lt;/span&gt;为bbox的宽度和长度，以图像的宽度和长度归一化到&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;之间；&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt;就是上面提到的Confidence，其值也是在&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;之间。 这样每个bbox可以使用五元组&lt;span class=&quot;math inline&quot;&gt;\((x,y,w,h,Confidence)\)&lt;/span&gt;表示，并且其值都是在&lt;span class=&quot;math inline&quot;&gt;\([0,1]\)&lt;/span&gt;之间。&lt;/p&gt;
&lt;p&gt;以grid cell为准预测出来的bbox表示了目标的边框信息，并不能判断出来其中包含的目标是属于哪一个类。所以YOLO网络还为每一个grid cell预测出&lt;span class=&quot;math inline&quot;&gt;\(C\)&lt;/span&gt;个conditional class probability（条件类别概率）：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ P(class_i | object) \]&lt;/span&gt;&lt;br/&gt;即在一个grid cell中有一个Object的前提下，它属于某个类的概率。只为每个grid cell预测一组类概率，而不考虑框的数量。&lt;/p&gt;
&lt;p&gt;类别概率&lt;span class=&quot;math inline&quot;&gt;\(P(class_i | object)\)&lt;/span&gt;是对于某个grid cell的，表示该grid cell能够预测一个目标的条件下，其目标的属于某个类的概率；而bbox的confidence表示的是，包含目标的可行性。 将这两个值相乘，就可以得到bbox中包含的目标的的类别的概率了。&lt;br/&gt;所以在测试阶段，将grid cell的&lt;span class=&quot;math inline&quot;&gt;\(P(class_i | object)\)&lt;/span&gt;和以该grid cell为准预测出来bbox的confidence相乘&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ P(class_i | object) \cdot P(object) \cdot IoU_{pred}^{truth} \]&lt;/span&gt;&lt;br/&gt;该值就能反应出bbox包含某一个具体类别的目标的可信度。&lt;/p&gt;
&lt;p&gt;在YOLO论文中，使用VOC的数据集，即有20个类别，将图像划分为&lt;span class=&quot;math inline&quot;&gt;\(7 \times 7\)&lt;/span&gt;的网格，每个grid cell预测出2个bbox，因此最终输出的数据张量尺寸为&lt;span class=&quot;math inline&quot;&gt;\(7 \times 7 \times 30\)&lt;/span&gt;。（&lt;span class=&quot;math inline&quot;&gt;\(S \times S \times (B \times 5 + C)\)&lt;/span&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190220141850714-1726070015.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图表示了YOLO网络针对某个grid cell的输出。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于YOLO的最后输出层是全连接层，所以只能处理固定尺寸的图像&lt;span class=&quot;math inline&quot;&gt;\(448 \times 448 \times 3\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;虽然每个格子可以预测B个bounding box，但是最终只选择只选择IOU最高的bounding box作为物体检测输出，即每个格子最多只预测出一个物体。当物体占画面比例较小，如图像中包含畜群或鸟群时，每个grid&lt;br/&gt;cell 负责多个物体，但却只能检测出其中一个。这是YOLO方法的一个缺陷&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;网络结构&quot;&gt;网络结构&lt;/h3&gt;
&lt;p&gt;YOLO使用CNN来提取图像的特征，最后使用全连接层做回归预测，并且借鉴GooLeNet的思路，使用了&lt;span class=&quot;math inline&quot;&gt;\(1 \times 1\)&lt;/span&gt;卷积核。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190220141908020-318758429.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;YOLO由24个卷积层和2个全连接层组成，最终的输出为&lt;span class=&quot;math inline&quot;&gt;\(7 \times 7 \times 30\)&lt;/span&gt;的张量，也就是针对每一个grid cell YOLO网络都输出了一个30维的向量，这个30维的向量就包括上面提到的各种信息：grid cell为基准预测出来的两个bbox五元组，以及针对grid cell的预测某个类别的条件概率。具体如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190220142004797-1173380195.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;目标函数&quot;&gt;目标函数&lt;/h3&gt;
&lt;p&gt;YOLO网络的输出实际上包含了三部分信息：bbox的位置信息，每个bbox的confidence以及每个grid cell的类别条件概率。 目标函数也就包含的三个部分：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \begin{align*} &amp;amp; \lambda_{coord}\sum_{i=0}^{S^2}\sum_{j=0}^{B}1_{ij}^{obj}\left(x_i - \hat{x_i})^2 + (y_i - \hat{y_i)^2}) \right] + \lambda_{coord}\sum_{i=0}^{S^2}\sum_{j=0}^{B}1_{ij}^{obj} \left[(\sqrt{w_i} - \sqrt{\hat{w_i}})^2 + (\sqrt{h_i} - \sqrt{\hat{h_i}})^2 \right] \\&amp;amp; + \sum_{i=0}^{S^2}\sum_{j=0}^{B}1_{ij}^{obj}(C_i - \hat{C_i})^2 + \lambda_{noobj}\sum_{i=0}^{S^2}\sum_{j=0}^{B}1_{ij}^{noobj}(C_i - \hat{C_i})^2 \\&amp;amp; + \sum_{i=0}^{S^2}1_{i}^{obj}\sum_{c \in classes}(p_i(c) - \hat{p_i)(c))^2}) \end{align*} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;很长的损失函数，首先来看两个超参&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{coord}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{noobj}\)&lt;/span&gt;.&lt;br/&gt;由于要将bbox的位置信息，confidence以及类别的概率放到同一个目标函数中，而且各个分量占的输出数据的多少也相差很多（位置信息只占了8个维度，而类别则占了20个维度）,如果只是简单的使用方差作为损失则很难对三个要优化的目标做好平衡：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;8维的位置损失和20维的分类损失同等重要显然是不合理的&lt;/li&gt;
&lt;li&gt;如果一个grid cell中没有object（一幅图中这种grid cell很多），那么就会将这些grid cell中的box的confidence 置为0，相比于较少的有object的grid cell，这种做法是overpowering的，这会导致网络不稳定甚至发散。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;针对上述问题，损失函数中使用权重来解决。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;为了表示8维的位置损失的重要性，给位置损失前面设置个大的权重，论文中设置的是&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{coord}= 5\)&lt;/span&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为了平衡没有目标的grid cell，给没有目标的损失设较小的权重，论文中设置的是&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{noobj} = 0.5\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;公式中的第一行表示bbox位置损失。关于bbox位置损失有两点，
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(1_{ij}^{obj}\)&lt;/span&gt;第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个grid的第&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;个bbox是否负责该object的检测（与该object的ground truth的IoU最大的bbox负责该object的检测）。如果负责object的检测，则&lt;span class=&quot;math inline&quot;&gt;\(1_{ij}^{obj} = 1\)&lt;/span&gt;，否则为0，不参与位置损失的计算。&lt;/li&gt;
&lt;li&gt;因为目标的大小不同，其位置偏移量也不能同等对待。对于小的物体对偏移量的容忍度则较小，而大的物体其对偏移的容忍则大一些，也是是不同大小的目标，其偏移量的损失也不能一概而论。为了平衡这个问题，YOLO使用了一个比较巧妙的方法，不是直接使用预测目标的宽和高计算损失，而是使用其平方根&lt;span class=&quot;math inline&quot;&gt;\((\sqrt{w_i} - \sqrt{\hat{w_i}})^2 + (\sqrt{h_i} - \sqrt{\hat{h_i}})^2\)&lt;/span&gt;,如下图&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190220142030564-651306068.jpg&quot;/&gt; 相同的位置偏移，反应在小目标的偏移损失比大目标预测的bbox要大。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;公式的第二行是bbox的confidence的损失。 YOLO中一个目标被一个grid cell负责检测，而同一个grid cell生成的&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;个bbox，也是和目标的 ground truth 的IoU负责。这样就会有大量的bbox是不负责检测目标的，也就是&lt;span class=&quot;math inline&quot;&gt;\(1_{ij}^{obj} = 0,1_{ij}^{noobj}=1\)&lt;/span&gt;，而且由于包含目标的bbox较不包含目标的bbox要多很多，这里使用权值&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{noobj}\)&lt;/span&gt;作为平衡，论文中使用&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{noobj}=0.5\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;公式的第三行是grid cell的类别条件概率损失. &lt;span class=&quot;math inline&quot;&gt;\(1_{i}^{obj}\)&lt;/span&gt;表示第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;个grid cell是否负责一个目标的检测。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下图能更好的解释YOLO损失函数的意义&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/439761/201902/439761-20190220141923057-1338687028.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;输入图片，网络会按照与训练时相同的分割方式将测试图片分割成&lt;span class=&quot;math inline&quot;&gt;\(S \times S\)&lt;/span&gt;的网格，因此，划分出来的每个网格预测的class信息和Bounding box预测的confidence信息相乘，就得到了每个Bounding box的class-specific confidence score，即得到了每个Bounding box预测具体物体的概率和Ground Truth重叠的好坏。&lt;/p&gt;
&lt;p&gt;对于论文中，图片划分为&lt;span class=&quot;math inline&quot;&gt;\(7 \times 7\)&lt;/span&gt;的网格，最终会得到98个bbox。要分类的目标有20个类给，这样每个bbox对得到20个分数，表示该bbox在20个对象的得分。根据这20个得分情况，对98个bbox进行最大值抑制NMS，选出每个类别的最终bbox。&lt;br/&gt;NMS的步骤如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 设置一个Score的阈值（0.2），低于该阈值的候选对象排除掉（将该Score设为0）。
2. 遍历20个对象（找到每个对象的最好的bbox）
    2.1 遍历所有的98个bbox
        2.1.1 选择socre最大的bbox添加到输出列表中
        2.1.2 将计算余下的bbox的和score最大的bbox的IoU，如果大于设定的IoU阈值(0.5),则将该bbox的socre 设置为0.
        2.1.3 从余下的bbox中选择score最大的，重复上面的过程，直到所有的bbox要么在输出列表中，要不其socre为0
    2.2 输出列表中bbox即为当前类的预测bbox&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;summary&quot;&gt;summary&lt;/h2&gt;
&lt;p&gt;YOLO是one-stage的目标检测网络，其优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快&lt;/li&gt;
&lt;li&gt;使用整幅图片进行预测，视野大，召回率低，表现为背景误检率低。&lt;/li&gt;
&lt;li&gt;泛化能力强，对其他类的东西，训练后效果也是挺好的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个网格中只预测了两个框，并且只负责一类，YOLO对相互靠的很近的物体，还有很小的群体检测效果不好。&lt;/li&gt;
&lt;li&gt;当同一类物体出现的不常见的长宽比和其他情况时泛化能力偏弱&lt;/li&gt;
&lt;li&gt;大边界框的小误差通常是良性的，但小边界框的小误差对IOU的影响要大得多。但YOLO会同样的对待小边界框与大边界框的误差，虽然做了一定的处理，但是物体的大小对仍有很大的影响。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 20 Feb 2019 06:21:00 +0000</pubDate>
<dc:creator>Brook_icv</dc:creator>
<og:description>前面介绍的R CNN系的目标检测采用的思路是：首先在图像上提取一系列的候选区域，然后将候选区域输入到网络中修正候选区域的边框以定位目标，对候选区域进行分类以识别。虽然，在Faster R CNN中利用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangguchangqing/p/10406367.html</dc:identifier>
</item>
<item>
<title>Linux 文件/文件夹无法删除问题解决方案 - 张凯强</title>
<link>http://www.cnblogs.com/zhangkaiqiang/p/10406357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangkaiqiang/p/10406357.html</guid>
<description>&lt;p&gt;最近我们的服务器被黑客攻击，然后有些文件的属性被修改，导致我们无法删除病毒文件，同时采用 root 用户也无法删除，现在把解决方案记录下来。&lt;/p&gt;
&lt;h2 id=&quot;普通删除&quot;&gt;普通删除&lt;/h2&gt;
&lt;p&gt;如果文件是当前用户的，那么使用 rm 命令就可以删除&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;rm -rf file.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果无法删除，则尝试使用 root 用户删除，如果无法删除那么请看下面的说明。&lt;/p&gt;
&lt;h2 id=&quot;需要了解的命令&quot;&gt;需要了解的命令&lt;/h2&gt;
&lt;p&gt;如果普通的删除方式没有用，那么我们需要了解下面的命令来进行删除&lt;/p&gt;
&lt;h3 id=&quot;lsattr&quot;&gt;lsattr&lt;/h3&gt;
&lt;p&gt;lsattr 命令用于显示文件的属性，使用方式如下&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 列出 file.sh 文件的属性
lsattr file.sh
# 列出当前目录下所有文件以及文件夹的属性
lsattr&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;属性说明&quot;&gt;属性说明&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;i 属性设置之后可使文件不能被删除、改名，设置连接也无法写入或添加数据，只有 root 用户才能设置&lt;/li&gt;
&lt;li&gt;a 属性设置之后，文件只能增加数据，既不能删除也不能修改数据，只有 root 用户才能设置&lt;/li&gt;
&lt;li&gt;A 设置A属性后，若你访问此文件或目录时，它的访问时间 atime 不会被修改，可避免I/O较慢的机器过度访问磁盘。这对速度较慢的计算机有帮助。&lt;/li&gt;
&lt;li&gt;s 属性设置之后，如果文件被删除，将从硬盘彻底删除&lt;/li&gt;
&lt;li&gt;S 属性设置之后，文件将同步写入硬盘（一般为异步）&lt;/li&gt;
&lt;li&gt;u 属性设置之后，文件删除后数据内容还存在磁盘中，可以找回文件&lt;/li&gt;
&lt;li&gt;e 代表该文件为可执行文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;详细说明请参考：&lt;a href=&quot;https://baike.baidu.com/item/chattr/9841067?fr=aladdin&quot; class=&quot;uri&quot;&gt;https://baike.baidu.com/item/chattr/9841067?fr=aladdin&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;chattr&quot;&gt;chattr&lt;/h3&gt;
&lt;p&gt;chattr 用于修改文件属性，该命令请切换至 root 用户下使用，如果是 ubuntu 用户可在命令前加 sudo 进行修改&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 为 file.sh 文件增加 i 标识
chattr +i file.sh
# 为 file.sh 文件去除 i 标识
chattr -i file.sh
# 为 file.sh 增加 i, a 两个标识
chattr +ia file.sh
# 为 file.sh 文件移除 i, a 两个标识
chattr -ia file.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细操作请参考： &lt;a href=&quot;https://baike.baidu.com/item/chattr/9841067?fr=aladdin&quot; class=&quot;uri&quot;&gt;https://baike.baidu.com/item/chattr/9841067?fr=aladdin&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实际操作&quot;&gt;实际操作&lt;/h2&gt;
&lt;p&gt;由上文中得知当文件设置 i 和 a 任意一个属性我们就无法对文件进行删除操作，那么我们首先移除 i, a 属性，然后执行删除：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 移除 i, a 属性
chattr -ia file.sh
# 查看是否移除成功
lsattr file.sh
# 移除文件
rm -rf file.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果文件还未删除成功，则我们需要考虑文件所属的文件夹是否设置了 i 或 a 属性（这一点确实很难发现）&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 退回上一级
cd ..
# 直接使用 lsattr 命令，这样可以列出当前文件夹下所有文件和文件夹的属性
# 不要使用 lsattr 文件夹 这样的语法，这样是列出该文件夹下的文件的属性
lsattr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果文件夹被设置则对文件夹的属性执行移除操作，然后再删除文件夹里面的文件&lt;/p&gt;
&lt;h2 id=&quot;收获&quot;&gt;收获&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;虽然 lsattr 和 chattr 是在这次清除病毒的过程中发现的，但是通过了解文件属性，发现我们在实际的工作中可以通过文件属性来保护重要的文件避免被误删，以及确保误删后能够恢复文件。&lt;/li&gt;
&lt;li&gt;对于文件的操作后如果还是没有效果，我们可以尝试从文件夹入手解决。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 20 Feb 2019 06:20:00 +0000</pubDate>
<dc:creator>张凯强</dc:creator>
<og:description>最近我们的服务器被黑客攻击，然后有些文件的属性被修改，导致我们无法删除病毒文件，同时采用 root 用户也无法删除，现在把解决方案记录下来。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangkaiqiang/p/10406357.html</dc:identifier>
</item>
<item>
<title>部署Chart应用并使用.net core读取Kubernetes中的configMap - 饭勺oO</title>
<link>http://www.cnblogs.com/fanshaoO/p/10406325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanshaoO/p/10406325.html</guid>
<description>&lt;p&gt;上一篇文章讲了 &lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/fanshaoO/p/10401212.html&quot;&gt;k8s使用helm打包chart并上传到腾讯云TencentHub&lt;/a&gt;，今天就讲一下使用Helm部署应用并使用configMap代替asp.net core 中的appsettings.json文件。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把Chart上传到TencentHub之后，我们就可以通过腾讯云的容器服务，直接部署Helm应用了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190220094441802-734665975.png&quot; alt=&quot;&quot; width=&quot;1319&quot; height=&quot;464&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击新建然后选择TencentHub，私有仓库，就可以看到自己上传的Chart了。填写一下应用名称，拉到最下方点击完成即可创建应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190220094810855-135085783.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;注意：&lt;/strong&gt;如果你的yaml文件写的不对，如少个空格，变量参数名称写错或者不存在，都无法创建成功。&lt;/p&gt;
&lt;p&gt; 可以点击新建下方那个查看详情，可以看到Helm应用安装日志，安装失败会提示错误信息，自己跟据错误提示修复自己的错误。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190220095313418-618412803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功安装后点击应用可以查看资源信息和状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190220100013303-2078418923.png&quot; alt=&quot;&quot; width=&quot;1010&quot; height=&quot;609&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;Chart部署成功不代表你的服务已经成功启动了，如果你的服务本身是有问题起不来的话，这里不会有提示，需要自己去查看Pod是否已经正常启动成功。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190220101033800-1852604220.png&quot; alt=&quot;&quot; width=&quot;946&quot; height=&quot;361&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，应用部署完成后，我们来试试如何读取configMap。&lt;/p&gt;

&lt;p&gt;上篇文章没有把config.yaml文件的内容放出来，里面内容如下 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190220104332494-453100760.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中metadata中的name是必选项，namespace不写的话默认是default，labels用于条件过滤筛选。&lt;/p&gt;
&lt;p&gt;data就是我们的配置内容，key-value的形式存在。&lt;/p&gt;
&lt;p&gt;------------------------------------------------分割线-----------------------------------------------------&lt;/p&gt;
&lt;p&gt;.net core调用k8s需要使用KubeClient，这里我使用 https://github.com/tintoy/dotnet-kube-client 来调用k8s的接口。&lt;/p&gt;
&lt;p&gt;直接使用nuget搜索KubeClient即可找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190220101843508-1007105616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;KubeClient支持依赖注入。需要安装&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
KubeClient.Extensions.DependencyInjection
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddKubeClient(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; KubeClientOptions
    {
        ApiEndPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        AuthStrategy &lt;/span&gt;=&lt;span&gt; KubeAuthStrategy.BearerToken,
        AccessToken &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my-access-token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        AllowInsecure &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Don't validate server certificate&lt;/span&gt;
&lt;span&gt;    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最简单的创建一个KubeClient方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
KubeApiClient client = KubeApiClient.Create(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; KubeClientOptions
{
    ApiEndPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
    AuthStrategy &lt;/span&gt;=&lt;span&gt; KubeAuthStrategy.BearerToken,
    AccessToken &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;my-access-token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
    AllowInsecure &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Don't validate server certificate&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我只是简单读取k8s中的configMap，至于用途下面再讲。&lt;/p&gt;
&lt;p&gt;使用console控制台程序编写如下代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190220103030736-1843170807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            KubeApiClient client &lt;/span&gt;= KubeApiClient.Create(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; KubeClientOptions
            {
                ApiEndPoint &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://xxxxxxx.tencent-cloud.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                AuthStrategy &lt;/span&gt;=&lt;span&gt; KubeAuthStrategy.BearerToken,
                AccessToken &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GzxxxxxxxxxxxxxT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                AllowInsecure &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Don't validate server certificate&lt;/span&gt;
&lt;span&gt;            });
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configClient =&lt;span&gt; client.ConfigMapsV1();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configList = &lt;span&gt;await&lt;/span&gt; configClient.List( labelSelector:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configMap=wechat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, kubeNamespace: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dev&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; );
            Console.WriteLine(JsonConvert.SerializeObject(configList));
            Console.ReadKey();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用KubeApiClient获取一个configClient，然后configClient.List()获取k8s中的所有configMap，labelSelector和kubeNamespace都是默认可空参数，用于过滤筛选configMap。&lt;/p&gt;
&lt;p&gt;这里我们通过断点可以看到，已经读取到wechat中的configMap信息，AppMode:Devlopment 就是我们config.yaml中data中的内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201902/1313665-20190220103624692-1351284900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 至此我们已经完成了.net core读取configMap的事情了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;使用nuget安装&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
KubeClient
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
KubeClient.Extensions.Configuration
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Startup.cs中的构造函数添加下面代码即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
var configBuilder = new ConfigurationBuilder();&lt;span&gt;&lt;br/&gt;var&lt;/span&gt; client = KubeApiClient.Create(new KubeClientOptions
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;            {
                ApiEndPoint = new Uri(&quot;https://xxxxxxx.tencent-cloud.com&quot;&lt;span&gt;),
                AuthStrategy =&lt;span&gt; KubeAuthStrategy.BearerToken,
                AccessToken = &quot;GzxxxxxxxxxxxxxT&quot;&lt;span&gt;,
                AllowInsecure = true // Don't validate server certificate
&lt;span&gt;            });&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;
&lt;/pre&gt;
&lt;pre readability=&quot;5&quot;&gt;
&lt;span&gt;) &lt;br/&gt;configuration.AddKubeConfigMap(client, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;extensions-sample&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, reloadOnChange: &lt;span&gt;true&lt;/span&gt;);&lt;p&gt;Configuration = &lt;span class=&quot;pl-smi&quot;&gt;configBuilder.&lt;span class=&quot;pl-en&quot;&gt;Build()&lt;/span&gt;&lt;/span&gt;;
&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;现在asp.net core一般是使用appsettings.json文件来读取项目的配置信息，这样做非常简单易容，但是在生产环境特别是微服务上面我们往往需要一个配置中心来管理应用配置。&lt;/p&gt;
&lt;p&gt;目前充当配置中心的产品有很多，如携程的&lt;a href=&quot;https://github.com/ctripcorp/apollo&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;Apollo&lt;/a&gt;，springCloud中的&lt;a href=&quot;https://springcloud.cc/spring-cloud-config.html#_environment_repository&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;SpringCloudConfig&lt;/a&gt;，&lt;a href=&quot;https://github.com/hashicorp/consul&quot; target=&quot;_blank&quot;&gt;consul&lt;/a&gt;也可以充当配置中心。&lt;/p&gt;
&lt;p&gt;这些都需要额外部署多一个服务，而configMap也可以实现配置中心的功能，何乐而不为呢。至于有不同意见的读者，欢迎评论指点指点。&lt;/p&gt;
&lt;p&gt;k8s中存储配置信息的不只configMap，一些敏感信息，我们可以使用Secret，Secret以密文的方式存储数据，避免了直接在配置文件中保存敏感信息。&lt;/p&gt;
&lt;p&gt;Pod可以通过Volume或者环境变量的方式使用configMap和Secret。&lt;/p&gt;

&lt;p&gt; 由于自己也是刚接触这个不久，很多都还不没有深入理解到，就暂且说说遇到的一些问题吧......&lt;/p&gt;
&lt;p&gt;首先最基本的，yaml格式错误，yaml很好用无需置疑，但是当配置信息以多起来的时候，yaml空格的问题就容易犯了，毕竟谁不会手误呢~~~( ͡° ͜ʖ ͡°)&lt;/p&gt;
&lt;p&gt;一个是yaml的分号: 后面必须加上一个空格。另一个是yaml的对象层级是跟据空格划分的，虽然没有规定几个空格一层，但是要同层次的空格都是必须一致的。在yaml上面慎用TAB......(o≖◡≖)&lt;/p&gt;
&lt;p&gt;然后呢，就是Chart模板的配置信息。&lt;/p&gt;
&lt;p&gt;Chart模板中资源类型是通过kind区分的，然后资源的基本信息是在metadata中描述。&lt;/p&gt;
&lt;p&gt;比如说config.yaml中，kind是ConfigMap。&lt;/p&gt;
&lt;p&gt;metadata中包含资源的name，namespace，labels等，虽然至于name是必须项，但是最好尽量把能写的都写上。&lt;/p&gt;
&lt;p&gt;第一次操作的时候只填写了name，然后再查询的时候怎么都查不出来(ノへ￣、)然后才知道namespace不对......默认namespace是defalut 〒▽〒&lt;/p&gt;
&lt;p&gt;然后，把namespace补上去了，然后再拉一次，出来了，但是是一次性拉取namespace下的所有configMap，没法过滤，然后看了下API才发现可以用label过滤(;´༎ຶД༎ຶ`)&lt;/p&gt;
&lt;p&gt;嗯，然后又补了个labels上去了╮(╯▽╰)╭&lt;/p&gt;
&lt;p&gt;嗯，还有其他很多细节，暂时还没去接触，这就不说了(✿◡‿◡)&lt;/p&gt;

&lt;p&gt;最后呢，期待各位大佬指点指点○( ＾皿＾)っHiahiahia…&lt;/p&gt;

</description>
<pubDate>Wed, 20 Feb 2019 06:17:00 +0000</pubDate>
<dc:creator>饭勺oO</dc:creator>
<og:description>上一篇文章讲了 k8s使用helm打包chart并上传到腾讯云TencentHub，今天就讲一下使用Helm部署应用并使用configMap代替asp.net core 中的appsetti</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanshaoO/p/10406325.html</dc:identifier>
</item>
<item>
<title>FreeSql.Repository 通用仓储层功能 - nicye</title>
<link>http://www.cnblogs.com/kellynic/p/10406319.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kellynic/p/10406319.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;好多年前，DAL 作为数据库访问层，其实是非常流行的命名方式。&lt;/p&gt;
&lt;p&gt;不知道从什么时候开始，仓储层成了新的时尚名词。目前了解到，许多人只要在项目中看见 DAL 就会觉得很 low，但是比较可笑的一点是，多数的仓储层与 DAL 实质在做同样的事情。&lt;/p&gt;
&lt;p&gt;本文正要介绍这种比较 low 的方式，来现实通用的仓储层。&lt;/p&gt;
&lt;h2 id=&quot;参考规范&quot;&gt;参考规范&lt;/h2&gt;
&lt;p&gt;与其他规范标准一样，仓储层也有相应的规范定义。FreeSql.Repository 参考 abp vnext 代码，定义和实现基础的仓储层（CURD），应该算比较通用的方法吧。&lt;/p&gt;
&lt;h3 id=&quot;ibasicrepository.cs-增删改接口&quot;&gt;IBasicRepository.cs 增删改接口&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System.Threading.Tasks;

namespace FreeSql {
    public interface IBasicRepository&amp;lt;TEntity&amp;gt; : IReadOnlyRepository&amp;lt;TEntity&amp;gt;
        where TEntity : class {
        TEntity Insert(TEntity entity);
        Task&amp;lt;TEntity&amp;gt; InsertAsync(TEntity entity);

        void Update(TEntity entity);
        Task UpdateAsync(TEntity entity);
        IUpdate&amp;lt;TEntity&amp;gt; UpdateDiy { get; }

        void Delete(TEntity entity);
        Task DeleteAsync(TEntity entity);
    }

    public interface IBasicRepository&amp;lt;TEntity, TKey&amp;gt; : IBasicRepository&amp;lt;TEntity&amp;gt;, IReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;
        where TEntity : class {
        void Delete(TKey id);
        Task DeleteAsync(TKey id);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ireadonlyrepository.cs-查询接口&quot;&gt;IReadOnlyRepository.cs 查询接口&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System.Threading.Tasks;

namespace FreeSql {
    public interface IReadOnlyRepository&amp;lt;TEntity&amp;gt; : IRepository
        where TEntity : class {
        ISelect&amp;lt;TEntity&amp;gt; Select { get; }
    }

    public interface IReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt; : IReadOnlyRepository&amp;lt;TEntity&amp;gt;
        where TEntity : class {
        TEntity Get(TKey id);
        Task&amp;lt;TEntity&amp;gt; GetAsync(TKey id);

        TEntity Find(TKey id);
        Task&amp;lt;TEntity&amp;gt; FindAsync(TKey id);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;irepository.cs-仓储接口&quot;&gt;IRepository.cs 仓储接口&lt;/h3&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using System.Linq.Expressions;
using System.Threading.Tasks;

namespace FreeSql {

    public interface IRepository {
        //预留
    }

    public interface IRepository&amp;lt;TEntity&amp;gt; : IReadOnlyRepository&amp;lt;TEntity&amp;gt;, IBasicRepository&amp;lt;TEntity&amp;gt;
        where TEntity : class {
        void Delete(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; predicate);
        Task DeleteAsync(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; predicate);
    }

    public interface IRepository&amp;lt;TEntity, TKey&amp;gt; : IRepository&amp;lt;TEntity&amp;gt;, IReadOnlyRepository&amp;lt;TEntity, TKey&amp;gt;, IBasicRepository&amp;lt;TEntity, TKey&amp;gt;
        where TEntity : class {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;现实-baserepository.cs-通用的仓储基类&quot;&gt;现实 BaseRepository.cs 通用的仓储基类&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using System.Linq;
using System.Linq.Expressions;
using System.Threading.Tasks;

namespace FreeSql {
    public abstract class BaseRepository&amp;lt;TEntity&amp;gt; : IRepository&amp;lt;TEntity&amp;gt;
        where TEntity : class {
        protected IFreeSql _fsql;
        public BaseRepository(IFreeSql fsql) : base() {
            _fsql = fsql;
            if (_fsql == null) throw new NullReferenceException(&quot;fsql 参数不可为空&quot;);
        }

        public ISelect&amp;lt;TEntity&amp;gt; Select =&amp;gt; _fsql.Select&amp;lt;TEntity&amp;gt;();
        public IUpdate&amp;lt;TEntity&amp;gt; UpdateDiy =&amp;gt; _fsql.Update&amp;lt;TEntity&amp;gt;();

        public void Delete(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; predicate) =&amp;gt; _fsql.Delete&amp;lt;TEntity&amp;gt;().Where(predicate).ExecuteAffrows();
        public void Delete(TEntity entity) =&amp;gt; _fsql.Delete&amp;lt;TEntity&amp;gt;(entity).ExecuteAffrows();
        public Task DeleteAsync(Expression&amp;lt;Func&amp;lt;TEntity, bool&amp;gt;&amp;gt; predicate) =&amp;gt; _fsql.Delete&amp;lt;TEntity&amp;gt;().Where(predicate).ExecuteAffrowsAsync();
        public Task DeleteAsync(TEntity entity) =&amp;gt; _fsql.Delete&amp;lt;TEntity&amp;gt;(entity).ExecuteAffrowsAsync();

        public TEntity Insert(TEntity entity) =&amp;gt; _fsql.Insert&amp;lt;TEntity&amp;gt;().AppendData(entity).ExecuteInserted().FirstOrDefault();
        async public Task&amp;lt;TEntity&amp;gt; InsertAsync(TEntity entity) =&amp;gt; (await _fsql.Insert&amp;lt;TEntity&amp;gt;().AppendData(entity).ExecuteInsertedAsync()).FirstOrDefault();

        public void Update(TEntity entity) =&amp;gt; _fsql.Update&amp;lt;TEntity&amp;gt;().SetSource(entity).ExecuteAffrows();
        public Task UpdateAsync(TEntity entity) =&amp;gt; _fsql.Update&amp;lt;TEntity&amp;gt;().SetSource(entity).ExecuteAffrowsAsync();
    }

    public abstract class BaseRepository&amp;lt;TEntity, TKey&amp;gt; : BaseRepository&amp;lt;TEntity&amp;gt;, IRepository&amp;lt;TEntity, TKey&amp;gt;
        where TEntity : class {
        public BaseRepository(IFreeSql fsql) : base(fsql) {
        }

        public void Delete(TKey id) =&amp;gt; _fsql.Delete&amp;lt;TEntity&amp;gt;(id).ExecuteAffrows();
        public Task DeleteAsync(TKey id) =&amp;gt; _fsql.Delete&amp;lt;TEntity&amp;gt;(id).ExecuteAffrowsAsync();

        public TEntity Find(TKey id) =&amp;gt; _fsql.Select&amp;lt;TEntity&amp;gt;(id).ToOne();
        public Task&amp;lt;TEntity&amp;gt; FindAsync(TKey id) =&amp;gt; _fsql.Select&amp;lt;TEntity&amp;gt;(id).ToOneAsync();

        public TEntity Get(TKey id) =&amp;gt; Find(id);
        public Task&amp;lt;TEntity&amp;gt; GetAsync(TKey id) =&amp;gt; FindAsync(id);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用？&lt;/h2&gt;
&lt;p&gt;1、安装&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;dotnet add package FreeSql.Repository&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2、声明 FreeSql，为单例&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var fsql = new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.Sqlite, @&quot;Data Source=|DataDirectory|\document.db;Pooling=true;Max Pool Size=10&quot;)
    .UseLogger(loggerFactory.CreateLogger&amp;lt;IFreeSql&amp;gt;())
    .UseAutoSyncStructure(true) //自动迁移实体的结构到数据库
    .Build();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ps: FreeSql 支持 MySql/SqlServer/PostgreSQL/Oracle/Sqlite。&lt;/p&gt;
&lt;p&gt;3、创建实体&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class Song {
    [Column(IsIdentity = true)]
    public int Id { get; set; }
    public string Title { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、创建仓储层&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class SongRepository : BaseRepository&amp;lt;Song, int&amp;gt; {
    public SongRepository(IFreeSql fsql) : base(fsql) {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释：&amp;lt;Song, int&amp;gt; 泛值第一个参数Song是实体类型，第二个参数int为主键类型&lt;/p&gt;
&lt;p&gt;至此，通过继承 BaseRepository 非常方便的实现了仓储层 SongRepository，他包含比较标准的 CURD 现实。&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;FreeSql.Repository 的版本号目前与 FreeSql 同步更新，&lt;a href=&quot;https://github.com/2881099/FreeSql/wiki/%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97&quot;&gt;查看更新说明&lt;/a&gt;；&lt;/p&gt;
&lt;p&gt;FreeSql 特性&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CodeFirst 迁移。&lt;/li&gt;
&lt;li&gt;DbFirst 从数据库导入实体类，支持三种模板生成器。&lt;/li&gt;
&lt;li&gt;采用 ExpressionTree 高性能读取数据。&lt;/li&gt;
&lt;li&gt;类型映射深入支持，比如pgsql的数组类型，匠心制作。&lt;/li&gt;
&lt;li&gt;支持丰富的表达式函数。&lt;/li&gt;
&lt;li&gt;支持导航属性查询，和延时加载。&lt;/li&gt;
&lt;li&gt;支持同步/异步数据库操作方法，丰富多彩的链式查询方法。&lt;/li&gt;
&lt;li&gt;支持事务。&lt;/li&gt;
&lt;li&gt;支持多种数据库，MySql/SqlServer/PostgreSQL/Oracle/Sqlite。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Github：&lt;a href=&quot;https://github.com/2881099/FreeSql&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/FreeSql&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 Feb 2019 06:17:00 +0000</pubDate>
<dc:creator>nicye</dc:creator>
<og:description>前言 好多年前，DAL 作为数据库访问层，其实是非常流行的命名方式。 不知道从什么时候开始，仓储层成了新的时尚名词。目前了解到，许多人只要在项目中看见 DAL 就会觉得很 low，但是比较可笑的一点是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kellynic/p/10406319.html</dc:identifier>
</item>
<item>
<title>8天入门docker系列 —— 第四天 使用aspnetcore小案例熟悉端口映射和挂载目录 - 一线码农</title>
<link>http://www.cnblogs.com/huangxincheng/p/10405856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangxincheng/p/10405856.html</guid>
<description>&lt;p&gt;　　 到目前为止大家应该对镜像和容器有了一个大概认知，而且也用了docker进行了一个简单化的部署，但仔细一看问题还有很多，所以这篇我们继续完善。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;一：如何让外网访问到容器内应用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        我们知道容器内拥有自己的子网，和你的主机ip不在一个网段内，所以宿主之外的机器是无法访问的，要实现的话你只能通过nat转发，在docker上实现起&lt;/p&gt;
&lt;p&gt;来很简单，通过 -p 将容器端口映射到宿主机端口即可。&lt;/p&gt;

&lt;p&gt;1. 在Dockerfile中，容器会自动监听8080端口，而且我的程序也是开启了这个端口号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
FROM microsoft/dotnet:&lt;span&gt;2.2&lt;/span&gt;-aspnetcore-&lt;span&gt;runtime
LABEL author hxc@qq.com
RUN &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /&lt;span&gt;data
COPY .&lt;/span&gt;/ /&lt;span&gt;data
WORKDIR &lt;/span&gt;/&lt;span&gt;data
VOLUME &lt;/span&gt;/data/&lt;span&gt;log
EXPOSE &lt;/span&gt;&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;
CMD [ &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebNotebook.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            CreateWebHostBuilder(args).Build().Run();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                .UseUrls(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://*:8080&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2. 接下来通过 -p 端口映射，将宿主机的8080端口和容器的8080端口进行一个映射，前面是宿主机端口，后面是容器的，你也可以写成 hostip:8080:8080&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# docker run -d --name webnotebook -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; huangxincheng520/&lt;span&gt;webnotebook:v4
82cf45e8fb7281fda7d1b22bf6ef1a5156a75f04b4ef29873d44f161b0238cfb
[root@localhost &lt;/span&gt;~&lt;span&gt;]# 
[root@localhost &lt;/span&gt;~]# docker &lt;span&gt;ps&lt;/span&gt;&lt;span&gt;
CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                    NAMES
82cf45e8fb72        huangxincheng520&lt;/span&gt;/webnotebook:v4   &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet WebNotebook.…&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;   &lt;span&gt;3&lt;/span&gt; seconds ago       Up &lt;span&gt;2&lt;/span&gt; seconds        &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt;-&amp;gt;&lt;span&gt;8080&lt;/span&gt;/tcp   webnotebook
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.  然后我就可以在windows上输入网址访问了，可以看到一点问题都没有。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/214741/201902/214741-20190220111622271-184912905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.  有些人可能会很好奇的去问，这个是怎么做到的呢？ 刚才也说到了是通过nat进行协议头ip地址替换进行转发的，你要是不信的话，可以用centos的&lt;/p&gt;
&lt;p&gt;     iptables nat去查看一下。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# iptables -t nat -L -&lt;span&gt;n
Chain PREROUTING (policy ACCEPT)
target     prot opt source               destination         
DOCKER     all  &lt;/span&gt;--  &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;            ADDRTYPE match dst-&lt;span&gt;type LOCAL

Chain INPUT (policy ACCEPT)
target     prot opt source               destination         

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination         
DOCKER     all  &lt;/span&gt;--  &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;           !&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;8&lt;/span&gt;          ADDRTYPE match dst-&lt;span&gt;type LOCAL

Chain POSTROUTING (policy ACCEPT)
target     prot opt source               destination         
MASQUERADE  all  &lt;/span&gt;--  &lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;16&lt;/span&gt;        &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;           
RETURN     all  &lt;/span&gt;--  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;224.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt;        
RETURN     all  &lt;/span&gt;--  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;&lt;span&gt;     
MASQUERADE  tcp  &lt;/span&gt;--  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;    !&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;     masq ports: &lt;span&gt;1024&lt;/span&gt;-&lt;span&gt;65535&lt;/span&gt;&lt;span&gt;
MASQUERADE  udp  &lt;/span&gt;--  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;    !&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;     masq ports: &lt;span&gt;1024&lt;/span&gt;-&lt;span&gt;65535&lt;/span&gt;&lt;span&gt;
MASQUERADE  all  &lt;/span&gt;--  &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;    !&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.0&lt;/span&gt;/&lt;span&gt;24&lt;/span&gt;&lt;span&gt;    
MASQUERADE  tcp  &lt;/span&gt;--  &lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.2&lt;/span&gt;           &lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;0.2&lt;/span&gt;           tcp dpt:&lt;span&gt;8080&lt;/span&gt;&lt;span&gt;

Chain DOCKER (&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; references)
target     prot opt source               destination         
RETURN     all  &lt;/span&gt;--  &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;            &lt;span&gt;0.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;/&lt;span&gt;0&lt;/span&gt;&lt;span&gt;           
DNAT       tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:8080 to:172.17.0.2:8080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    可以看到，docker在iptables中实现了一个自己的Docker chain，从 hostIP:8080 -&amp;gt; 172.17.0.2:8080中可以看到，当一个请求到了 192.168.23.149:8080&lt;/p&gt;
&lt;p&gt;会自动转发到 172.17.0.2.8080，有些人可能会问，这个明显不是一个网段怎么转发呢？ 那是因为你的宿主机上有一个默认的网桥Docker0，你可以理解成&lt;/p&gt;
&lt;p&gt;他就是一个数据链路层上的路由器，通过这个路由器，可以将不同的网段进行互联，你可以用ipconfig查看docker0的ip地址，这个ip地址就相当于路由器ip，&lt;/p&gt;
&lt;p&gt;也即是子网地址。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
[root@localhost ~]# &lt;span&gt;ifconfig&lt;/span&gt;&lt;span&gt;
docker0: flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;172.17.0.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;  broadcast &lt;span&gt;172.17&lt;/span&gt;.&lt;span&gt;255.255&lt;/span&gt;&lt;span&gt;
        inet6 fe80::&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;:25ff:fe14:8a13  prefixlen &lt;span&gt;64&lt;/span&gt;  scopeid &lt;span&gt;0x20&lt;/span&gt;&amp;lt;link&amp;gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;02&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;:8a:&lt;span&gt;13&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;105061&lt;/span&gt;  bytes &lt;span&gt;8399597&lt;/span&gt; (&lt;span&gt;8.0&lt;/span&gt;&lt;span&gt; MiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;148379&lt;/span&gt;  bytes &lt;span&gt;425576796&lt;/span&gt; (&lt;span&gt;405.8&lt;/span&gt;&lt;span&gt; MiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

ens33: flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.149&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;  broadcast &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.255&lt;/span&gt;&lt;span&gt;
        inet6 fe80::20c:29ff:fe5c:2e32  prefixlen &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;  scopeid &lt;span&gt;0x20&lt;/span&gt;&amp;lt;link&amp;gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;00&lt;/span&gt;:0c:&lt;span&gt;29&lt;/span&gt;:5c:2e:&lt;span&gt;32&lt;/span&gt;  txqueuelen &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;1570930&lt;/span&gt;  bytes &lt;span&gt;2222888854&lt;/span&gt; (&lt;span&gt;2.0&lt;/span&gt;&lt;span&gt; GiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;532628&lt;/span&gt;  bytes &lt;span&gt;56478232&lt;/span&gt; (&lt;span&gt;53.8&lt;/span&gt;&lt;span&gt; MiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

lo: flags&lt;/span&gt;=&lt;span&gt;73&lt;/span&gt;&amp;lt;UP,LOOPBACK,RUNNING&amp;gt;  mtu &lt;span&gt;65536&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;  netmask &lt;span&gt;255.0&lt;/span&gt;.&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;
        inet6 ::&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;  prefixlen &lt;span&gt;128&lt;/span&gt;  scopeid &lt;span&gt;0x10&lt;/span&gt;&amp;lt;host&amp;gt;&lt;span&gt;
        loop  txqueuelen &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Local Loopback)
        RX packets &lt;/span&gt;&lt;span&gt;104&lt;/span&gt;  bytes &lt;span&gt;8816&lt;/span&gt; (&lt;span&gt;8.6&lt;/span&gt;&lt;span&gt; KiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;104&lt;/span&gt;  bytes &lt;span&gt;8816&lt;/span&gt; (&lt;span&gt;8.6&lt;/span&gt;&lt;span&gt; KiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

veth871156e: flags&lt;/span&gt;=&lt;span&gt;4163&lt;/span&gt;&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet6 fe80::3c7f:5fff:fe53:&lt;/span&gt;&lt;span&gt;4542&lt;/span&gt;  prefixlen &lt;span&gt;64&lt;/span&gt;  scopeid &lt;span&gt;0x20&lt;/span&gt;&amp;lt;link&amp;gt;&lt;span&gt;
        ether 3e:7f:5f:&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;:&lt;span&gt;45&lt;/span&gt;:&lt;span&gt;42&lt;/span&gt;  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;99&lt;/span&gt;  bytes &lt;span&gt;726984&lt;/span&gt; (&lt;span&gt;709.9&lt;/span&gt;&lt;span&gt; KiB)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;306&lt;/span&gt;  bytes &lt;span&gt;19235&lt;/span&gt; (&lt;span&gt;18.7&lt;/span&gt;&lt;span&gt; KiB)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;&lt;span&gt;

virbr0: flags&lt;/span&gt;=&lt;span&gt;4099&lt;/span&gt;&amp;lt;UP,BROADCAST,MULTICAST&amp;gt;  mtu &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;
        inet &lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.1&lt;/span&gt;  netmask &lt;span&gt;255.255&lt;/span&gt;.&lt;span&gt;255.0&lt;/span&gt;  broadcast &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;122.255&lt;/span&gt;&lt;span&gt;
        ether &lt;/span&gt;&lt;span&gt;52&lt;/span&gt;:&lt;span&gt;54&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;83&lt;/span&gt;:&lt;span&gt;96&lt;/span&gt;:c2  txqueuelen &lt;span&gt;0&lt;/span&gt;&lt;span&gt;  (Ethernet)
        RX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        RX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt;  overruns &lt;span&gt;0&lt;/span&gt;  frame &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
        TX packets &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  bytes &lt;span&gt;0&lt;/span&gt; (&lt;span&gt;0.0&lt;/span&gt;&lt;span&gt; B)
        TX errors &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  dropped &lt;span&gt;0&lt;/span&gt; overruns &lt;span&gt;0&lt;/span&gt;  carrier &lt;span&gt;0&lt;/span&gt;  collisions &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;二：如何处理容器中的日志数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　   我们的webnotebook运行的时候总会产生一些日志，这时候可以把日志文件夹挂载到宿主机上，方便查看和采集啥的，当然更多的情况是采用集中式&lt;/p&gt;
&lt;p&gt;的日志收集，这个就不是本篇所讨论的了，接下来我要做两件事情，配置nlog日志框架，然后进行docker目录挂载。&lt;/p&gt;

&lt;p&gt;1.  配置nlog框架，在nuget上下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/214741/201902/214741-20190220114519094-1607605222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.  nlog.config 配置如下，{basedir} 就是当前程序的根目录。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;nlog &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.nlog-project.org/schemas/NLog.xsd&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;targets&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;target &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;file_info&quot;&lt;/span&gt;&lt;span&gt; xsi:type&lt;/span&gt;&lt;span&gt;=&quot;File&quot;&lt;/span&gt;&lt;span&gt;
                        fileName&lt;/span&gt;&lt;span&gt;=&quot;${basedir}/log/${shortdate}.txt&quot;&lt;/span&gt;&lt;span&gt; maxArchiveFiles&lt;/span&gt;&lt;span&gt;=&quot;30&quot;&lt;/span&gt;&lt;span&gt;
                        layout&lt;/span&gt;&lt;span&gt;=&quot;${longdate} | ${level:uppercase=false} | ${message} ${onexception:${exception:format=tostring} ${newline} ${stacktrace} ${newline}&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;targets&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;rules&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;logger &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt;&lt;span&gt; writeTo&lt;/span&gt;&lt;span&gt;=&quot;file_info&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;rules&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;nlog&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3.  然后我们的Controller类修改一下，记录下客户端的ip地址。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController : Controller
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LogManager.GetLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SimpleDemo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 读取mongodb数据数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; log = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端：{HttpContext.Connection.RemoteIpAddress} 访问了 Index 页面！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            logger.Info(log);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 4.  接下来你就可以docker build 成镜像啦，在 docker run 中使用-v参数，将宿主机的 /data/log 挂载到容器的 /data/log目录，如下命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@localhost publish]# docker build -t huangxincheng520/webnotebook:v5 -f ./&lt;span&gt;Dockerfile .
[root@localhost publish]# docker run &lt;/span&gt;--name webnotebook5 -d -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; -v /data/log:/data/log huangxincheng520/&lt;span&gt;webnotebook:v5
0e03f54d69ccdf3f88511385fd6fd5fdcafb64c0f971cbadb0b93014cb79e375&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;5. 一切都部署好了，接下来你可以访问8080端口，然后到你的宿主机的/data/log目录下查看一下，你的日志就出来啦。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@localhost log]# &lt;span&gt;pwd&lt;/span&gt;
/data/&lt;span&gt;log
[root@localhost log]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt;&lt;span&gt;.txt
[root@localhost log]# &lt;/span&gt;&lt;span&gt;tail&lt;/span&gt; &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt;&lt;span&gt;.txt
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt;-&lt;span&gt;20&lt;/span&gt; &lt;span&gt;04&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;36.2904&lt;/span&gt; | Info | 客户端：::ffff:&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;23.1&lt;/span&gt;&lt;span&gt; 访问了 Index 页面！ 
[root@localhost log]# &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    细心的你应该会发现到，日志所打印出的时间出了问题，比北京时间少了8个小时，所以你要做的是，把默认的0区时间改成东8区即可，那怎么修改呢？&lt;/p&gt;

&lt;p&gt;《1》 在docker run 中加入 -e 参数，也就是加入环境变量 -e TZ=Asia/Shanghai 即可，不要怕参数多，以后这些都是通过CI工具集成的，不要怕哈。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@localhost publish]# docker run --name webnotebook5 -d -p &lt;span&gt;8080&lt;/span&gt;:&lt;span&gt;8080&lt;/span&gt; -v /data/log:/data/log -e TZ=Asia/Shanghai  huangxincheng520/&lt;span&gt;webnotebook:v5
18cbd284dbd6f6ff498d849eda7652ec63df3c0113c0cdd53ae4a0030abb52f2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;       访问网站之后再看看你的log文件，时区已经调整过来了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@localhost log]# tail 2019-02-20&lt;span&gt;.txt
2019-02-20 04:13:36.2904 | Info | 客户端：::ffff:192.168.23.1&lt;span&gt; 访问了 Index 页面！ 
&lt;span&gt;2019-02-20 12:20:38.3752&lt;/span&gt; | Info | 客户端：::ffff:192.168.23.1 访问了 Index 页面！&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;《2》 在dockerfile中增加环境变量占位符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
FROM microsoft/dotnet:&lt;span&gt;2.2&lt;/span&gt;-aspnetcore-&lt;span&gt;runtime
ENV TZ Asia&lt;/span&gt;/Shanghai
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;好了，本篇就说到这里，希望对你有帮助。&lt;/p&gt;

</description>
<pubDate>Wed, 20 Feb 2019 04:39:00 +0000</pubDate>
<dc:creator>一线码农</dc:creator>
<og:description>到目前为止大家应该对镜像和容器有了一个大概认知，而且也用了docker进行了一个简单化的部署，但仔细一看问题还有很多，所以这篇我们继续完善。 一：如何让外网访问到容器内应用 我们知道容器内拥有自己的子</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangxincheng/p/10405856.html</dc:identifier>
</item>
</channel>
</rss>