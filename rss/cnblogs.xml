<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>又被“过运营商语音认证”虐了一回 - davidtym</title>
<link>http://www.cnblogs.com/talkaudiodev/p/9960723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/talkaudiodev/p/9960723.html</guid>
<description>&lt;p&gt;又被“过运营商语音认证”虐了一回！虐的伤痕累累、疲惫不堪！过程是痛苦的，但结果是美好的，收获也是挺多的！既然用了“又”，那以前肯定被虐过。是的，没错。那是7年多前（2011年底），同样是在秋冬，不过一个是2011年底，一个是2018年底。同样是在芯片公司， 不过一个是老牌外企，一个是本土新秀。当时我们在公司的芯片上做了一个语音通信解决方案（具体怎么做的见我前面的文章：&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl06_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/8283832.html&quot;&gt;如何在嵌入式Linux上开发一个语音通信解决方案&lt;/a&gt;），只有过了中国电信的语音认证客户才会用我们的。老板把这个任务交给了我，我那时是第一次弄这些，一脸懵逼。既然交给了我，我就尽全力把它做好。认证主要有两方面内容：音质相关的MOS（Mean Opinion Score，平均主观意见分）和时延相关的delay。当时MOS的评分标准是PESQ(Perceptual Evaluation of Speech Quality，语音质量的感知评估)，即ITU-T的P.862。经过近几年的发展，如今变成了POLQA（Perceptual Objective Listening Quality Analysis，感知客观语音质量评估），即ITU-T的P.863。P.863标准（POLQA）是对P.862标准（PESQ）的升级，适应范围更广，评价结果更接近主观的MOS。经过近三个月的努力，成功过了认证，心里别提多高兴了。虽然很累，但技术能力提高了不少，也特别有成就感。这次过的是中国移动（CMCC）手机上的EVS音频电学认证。关于EVS，我在前面的文章（&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl08_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/9074554.html&quot;&gt;移动通信最先进的音频编解码器EVS及用好要做的工作&lt;/a&gt;）中讲过。下面就讲讲是怎么过认证的以及怎么被虐的。&lt;/p&gt;

&lt;p&gt;前面的文章（&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/8733968.html&quot;&gt;Android智能手机上的音频浅析&lt;/a&gt;）讲了安卓手机上音频相关的软硬件，文章（&lt;a id=&quot;homepage1_HomePageDays_ctl00_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/8996338.html&quot;&gt;谈谈我开发过的几套语音通信解决方案&lt;/a&gt;）讲了在安卓手机上打传统电话时的方案，知道了通话时主要是CODEC芯片、Audio DSP（ADSP）和CP参与语音数据的传输，具体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201812/1181527-20181201212924702-2038812566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;codec芯片主要负责语音的采集和播放，ADSP上主要是编解码以及语音增强（voice Enhancement，简称VE，包括AEC、ANS、AGC等）等，CP上主要是网络侧及空口的处理。CMCC以前对EVS是可选项，但2018年四月份开始变成了必选项，即要入库的手机一定要支持EVS。我们公司的手机芯片是支持EVS的，这功能是我和CP的同事共同完成的（我负责Audio DSP上EVS codec相关的，CP同事负责网络侧IMS相关的）。那时中国移动关于EVS认证的case还没公布，我们在实网下对EVS做了基本的调测，能用了。到了七八月份具体case公布了，全面调测EVS就提上了日程。CP同事、测试同事和我三人组成了一个小分队，由于EVS codec在Audio DSP上，这件事就由我来牵头向前推进。先在实网下做全面的测试，解决了不少语音质量相关的问题（比如噪声断续等）。这些问题相对都是较难弄的，花了近一个月。实网下测下来基本感觉不到噪声断续等问题了，我们决定开始过移动EVS认证的case。&lt;/p&gt;

&lt;p&gt;CMCC EVS音频电学认证的case也主要分两类：MOS和delay。测试时仪器通过音频线和手机的耳机孔连接进行语音数据的传输，仪器通过射频线和手机上的射频口相连进行空口数据的传输，其框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201812/1181527-20181209194937795-106851320.png&quot; alt=&quot;&quot; width=&quot;391&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MOS有良好网络下的上下行MOS、恶劣网络下的下行MOS、LTE向2/3G切换的切换中和切换后的MOS、数据业务并发时的MOS等。算上行MOS时，仪器把参考音频经音频线送给手机，手机上行处理后经射频线再把码流送给仪器，仪器解码码流得到PCM再基于POLQA（上面说过现在MOS的评分标准用的是POLQA）跟参考音频比较得到MOS分，上图中的uplink方向给出了示意。算下行MOS时，仪器把参考音频的码流经射频线送给手机，手机下行处理后经音频线把语音再送给仪器，仪器基于POLQA把收到的语音跟参考音频比较得到MOS分，上图中的downlink方向给出了示意。Delay同样有良好网路下的delay、恶劣网络下的delay、LTE向2/3G切换的切换前后的delay、数据业务并发时的delay等，这里delay是指单向时延（one-way-delay）,即从发端到收端的延时。算delay的框图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1181527/201812/1181527-20181209195019554-2018793107.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;311&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仪器把参考音频经音频线送给手机，手机上行处理后经射频线再把码流送给仪器，仪器中形成一个loopback(上图中红色粗体处)，把这个码流经射频线送给手机。手机下行处理后把语音数据经音频线送给仪器，仪器把收到手机语音数据的时间和参考音频的发送时间做比较从而得到delay值。不管是MOS还是delay都是测多次（MOS测10次或者20次，delay测50次），然后算平均值作为最终得分。&lt;/p&gt;

&lt;p&gt;测试EVS音频电学的这套仪器非常贵，没有几百万是搞不定的，后面还有每年向仪器厂商缴的维护费用。大厂一般都会买上一套来调试各种音频电学指标。上文说过我现在的公司是本土新秀，老板不是很愿意花这么多钱在这上面。幸好CMCC有仪器设备免费给相关厂商用，要提前预约，通常一星期批一次，一次两三个小时。但是经过两三个星期这样的运作后发现效率太低（手机校准（校准是为了找到最好的灵敏度值和gain值，相同的仪器和手机只需要做一次校准，如果有一个变化了就需要重新做校准）一次要花近两个小时，我们的手机在实网下打EVS电话没什么问题，但是在仪器环境下测时好多case的EVS通话都建立不起来，需要各个领域的同事一起调查，也需要仪器侧技术人员的support，但是仪器侧的support力度很弱，进展太慢），老板决定向仪器厂商租设备来调试（租金也是相当昂贵的），即我们到仪器厂商的实验室去调试。仪器厂商的实验室在北京，这样就有了我和CP同事的北京之行（我们公司北京有office，测试同事就在北京）。在北京呆了一星期，同样遇到了不少问题，由于是在仪器厂商的实验室，遇到问题时他们支持的力度较大，大部分case都能测起来了，进而也就得到了相应的MOS分和delay值。良好网络下的MOS分不仅没有一个达标的，而且有的离达标还很远，良好网络下的delay部分达标了。仪器厂商的技术人员安慰我们说第一次过EVS认证都是这样的。在过EVS认证这件事上他们见多识广，我们就当信以为真，哈哈。&lt;/p&gt;

&lt;p&gt;回到公司后我们简单总结了一下，并制定了后面的策略：每星期由北京测试同事去仪器厂商实验室测试一到两天，一方面验证前面遇到的问题是否fix，修改后MOS分是否有提高，delay值是否有减小，另一方面再继续测未测的case，即采用迭代的方式向前推进。先主攻良好网络下的MOS分。调查MOS分低（即音质差）主要是把各个处理过程后的语音数据dump出来，再辅以我们自己开发的各种工具，最终都变成PCM数据用CoolEdit听，从而得出是哪个处理过程把音质降低了（主要是噪声断续等），然后再在这个处理过程中找到使音质降低的根本原因。在前面文章（&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl04_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/9142192.html&quot;&gt;webRTC中音频相关的netEQ（一）：概述&lt;/a&gt;）中也说过我们语音通信中也用到了netEQ，只不过MCU模块在CP上，DSP模块在ADSP上。下行CP给ADSP发语音包和netEQ的控制命令，上行ADSP 给CP发语音包和netEQ的反馈信息（主要是上一帧的处理模式和时间戳等）。我们主要做了四个工具。一是EVS decoder（基于3GPP EVS reference code），把EVS码流解码成PCM；二是解析下行dump出来的CP发给ADSP的语音码流和netEQ控制命令；三是解析上行ADSP发给CP的语音码流和netEQ反馈信息；四是netEQ DSP模块的simulator(模拟器)，把下行dump出来的CP发给ADSP的语音码流和控制命令作为输入，netEQ中DSP模块处理后的PCM作为输出，就能完全复盘出问题的场景，从而找到根本原因。在这些工具的辅助下发现了一些问题，也都一一解决了。经过几个星期的迭代，良好网络下的MOS分稳步提升，上下行都达到了3.9x，但是不达标（达标是4.0）。讨论下来在传输环节已经没有什么可做的了（依据是用CoolEdit听仪器中的结果音频，已经听不出任何噪声断续了），该负责VE的算法同事上场了。刚开始时算法同事也没什么招，后来听测试同事讲仪器厂商实验室有参考机，可以拿这个参考机测测，如果达标了看仪器上的结果音频是什么样的，好有参考。参考机测下来达标了，上行4.09，下行4.16。把结果音频发给算法同事，研究频谱等特性。算法同事尝试着修改VE里的参数，前三次以失败告终，让人好失望，甚至有点绝望，就差这零点零几分了！第四次尝试后总算达标了（上行4.10，下行4.20），好不容易啊！总结下来就是尽量减少对语音信号的处理，保持原有信号的频谱等特性。改好后又测了良好网络下的其他case的MOS分，全都达标了。后面由于时间不多了，就开始兵分两路，一路负责恶劣网络下的MOS，另外一路负责各种场景下的delay。恶劣网络主要分三个等级（1%丢包10ms jitter/2%丢包20ms jitter/3%丢包40ms jitter），相对OTT语音（比如微信语音，OTT语音经常会出现高于5%的丢包率）不是很恶劣，主要是因为LTE网络处理语音数据的QoS的级别较高，而OTT语音的QoS级别同其他数据业务（比如上网）是一样的，需要做好多补偿措施，具体有FEC、重传等，我在前面的文章（&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl09_DayList_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/talkaudiodev/p/8053062.html&quot;&gt;语音通信中提高音质的方法&lt;/a&gt;）对这些措施做过具体介绍，有兴趣可以看一看。提高恶劣网络下EVS的音质主要是用好丢包补偿、平滑等算法。减少delay先是算出各个环节引入了多少delay，然后看是否能减少以及减少多少，主要是减少语音数据缓的时间。例如下行先有铃声数据进DMA buffer播放出来，语音数据到来后如放在未播放的铃声数据后就会引入delay，这就需要立刻用语音数据去覆盖DMA buffer中未播放的铃声数据从而减少delay。不管是MOS还是delay，要想达标，就在几个核心的点上，比如前面讲的改VE中的参数就是一个很重要的点，改了后就能提高0.2左右的MOS分。点找到了，达标也就不是很难了，往往是找到一个点并解决了需要不少时间，有时候花了很多时间也不一定能找到，需要很强的专业知识，还是以修改VE参数的点为例，需要精通音频算法的专家。&lt;/p&gt;

&lt;p&gt;过EVS音频电学认证前前后后花了四个月左右的时间，遇到了很多问题，参与人数也众多（我们建了一个EVS认证的群，从最初的三四人到最终的近50人，不仅有信令处理、媒体处理的，还有硬件的平台的以及空口的，都是遇到问题涉及到相关人员而拉进群的），可以算是一个不小的项目了。我作为过EVS认证的牵头者，不仅要解决好媒体处理相关的问题，同时还要跟踪项目的状态制定计划等，部分承担了PM（项目经理）的角色，不管是技术上还是项目管理上都收获颇多。&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 23:45:00 +0000</pubDate>
<dc:creator>davidtym</dc:creator>
<og:description>又被“过运营商语音认证”虐了一回！虐的伤痕累累、疲惫不堪！过程是痛苦的，但结果是美好的，收获也是挺多的！既然用了“又”，那以前肯定被虐过。是的，没错。那是7年多前（2011年底），同样是在秋冬，不过一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/talkaudiodev/p/9960723.html</dc:identifier>
</item>
<item>
<title>自己动手用electron+vue开发博客园文章编辑器客户端【二】 - liulun</title>
<link>http://www.cnblogs.com/liulun/p/10123545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liulun/p/10123545.html</guid>
<description>&lt;p&gt;在&lt;a href=&quot;https://www.cnblogs.com/liulun/p/10110507.html&quot; target=&quot;_self&quot;&gt;上一篇文章&lt;/a&gt;中，&lt;/p&gt;
&lt;p&gt;咱们聊了我开发的这个程序是什么样子、为什么要开发这个程序&lt;/p&gt;
&lt;p&gt;electron的工程结构，他是怎么启动和退出的&lt;/p&gt;
&lt;p&gt;以及我们怎么用electron的技术，登录博客园，拿到会话信息；&lt;/p&gt;
&lt;p&gt;这篇文章，我们主要讲怎么拿博客园的数据，以及怎么提交数据给博客园；&lt;/p&gt;
&lt;p&gt;上几张新图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/28932/201901/28932-20190119090850069-421773190.png&quot; alt=&quot;&quot; width=&quot;608&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/28932/201901/28932-20190119090946966-980533863.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;356&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/28932/201901/28932-20190119091017985-1118520364.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;365&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/other/28932/201812/28932-20181213203316267-1452584183.png&quot; alt=&quot;&quot; width=&quot;609&quot; height=&quot;422&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在nwjs里，宿主页面与做过特殊标记的iframe页面（nwdisable nwfaketop和nwUserAgent）通信，并没有什么特别的地方&lt;/p&gt;
&lt;p&gt;就像你在一个普通的页面里访问你自己的iframe子页面一样&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
var frame = document.getElementById('[yourFrameId]').contentWindow;
&lt;/pre&gt;
&lt;p&gt;可以通过上面的代码，轻而易举的得到iframe页面的window对象；&lt;/p&gt;
&lt;p&gt;注意：被标记了nwfaketop的子页面里的代码是访问不到父页面的window对象的；&lt;/p&gt;

&lt;p&gt;然而在electron里，宿主页面要想跟webview页面通信的话，事情就复杂的多了&lt;/p&gt;
&lt;p&gt;你要给webview页面配置preload属性，&lt;/p&gt;
&lt;p&gt;让webview把你一个你自己写的JS文件注入到目标页面里去，如下：&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
&amp;lt;webview preload=&quot;[your js file path]&quot; src=&quot;http://[yourTargetUrl]&quot;&amp;gt;&amp;lt;/webview&amp;gt;
&lt;/pre&gt;
&lt;p&gt;你可以在这个JS文件里访问目标页面上任何东西，就像你自己写了一个JS文件放在目标网站里一样；&lt;/p&gt;
&lt;p&gt;不仅如此，你还可以在这个JS文件里访问electron提供的底层API；&lt;/p&gt;

&lt;p&gt;然而怎么把访问到的东西呈现在自己的画面上呢&lt;/p&gt;
&lt;p&gt;比如，我们在这个JS文件里拿到了博客分类的数据：&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
var temp = $(&quot;#post_categories a[href^='/posts?categoryid=']&quot;);
&lt;/pre&gt;
&lt;p&gt;注：博客园是我们的目标网站，目标网站加载了jquery，我们这个注入的js也可以使用jquery的能力&lt;/p&gt;
&lt;p&gt;再通过如下代码反馈给我们自己的画面&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
const {ipcRenderer} = require('electron')
ipcRenderer.sendToHost('messageFromWeb', temp);
&lt;/pre&gt;
&lt;p&gt;ipcRenderer就是electron里的东西了，&lt;/p&gt;
&lt;p&gt;看这个API就知道，这是在通过消息的方式通信，&lt;/p&gt;
&lt;p&gt;我们需要在自己的画面里监听这个消息&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
var webViewInstance = document.getElementById('[yourWebViewId]');
webViewInstance.addEventListener(&quot;ipc-message&quot;, event=&amp;gt;{
    console.log(event.args[0]);
}
&lt;/pre&gt;
&lt;p&gt;这里event.args[0]就是注入JS里传过来的temp对象，也就是博客分类的数据了&lt;/p&gt;
&lt;p&gt;接下来，就想怎么呈现就怎么呈现。&lt;/p&gt;

&lt;p&gt;如果想把自己画面里的数据传递给注入的JS代码&lt;/p&gt;
&lt;p&gt;需要在自己画面发送消息，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
var webViewInstance = document.getElementById('[yourWebViewId]');
webViewInstance.send(&quot;messageFromHost&quot;,&quot;hookSaveArticle&quot;,{data:'your article data'});
&lt;/pre&gt;
&lt;p&gt;在注入的JS代码里，可以通过下面的代码来获取宿主页面发送过来的消息：&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
const {ipcRenderer} = require('electron')
ipcRenderer.on('messageFromHost', (event, action, obj)=&amp;gt;{
    console.log(action);  //print hookSaveArticle
    console.log(obj);  //print {data:'your article data'}
})
&lt;/pre&gt;
&lt;p&gt;以上，&lt;/p&gt;
&lt;p&gt;我们现在可以自由的在目标页面和宿主页面互相通信，传递数据了；&lt;/p&gt;
&lt;p&gt;但是！&lt;/p&gt;
&lt;p&gt;File类型和Blob类型的数据不能这样传递，&lt;span&gt;这是官网文档里并没有说明的，是我自己踩坑踩出来的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么这样的数据该怎么发送呢？&lt;/p&gt;
&lt;p&gt;我是先在发送方转成base64，再在接收方转回来达到目的的&lt;/p&gt;
&lt;p&gt;虽然有点脱了裤子放屁，但是聊胜于无呀！&lt;/p&gt;
&lt;p&gt;发送方的代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
window.editorUpload = function(file) {
    var reader = newFileReader();
    reader.readAsDataURL(file);
    reader.onload = function() {
        webViewInstance.send(&quot;messageFromHost&quot;,&quot;hookUploadPic&quot;, {base64:reader.result,
            name:file.name});
    };
}
&lt;/pre&gt;
&lt;p&gt;接收方的代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
functiondataURLtoFile(dataurl, filename) {
    var arr = dataurl.split(','),
    mime = arr[0].match(/:(.*?);/)[1],
    bstr = atob(arr[1]),
    n = bstr.length,
    u8arr = newUint8Array(n);
    while(n--) { u8arr[n] = bstr.charCodeAt(n); }
    return newFile([u8arr], filename, {type: mime});
}
ipcRenderer.on('messageFromHost', (event, action, param)=&amp;gt;{
    var file = dataURLtoFile(param.base64, param.name);
})
&lt;/pre&gt;

&lt;p&gt;我们用的是&lt;a href=&quot;https://gitee.com/notadd/neditor&quot; target=&quot;_self&quot;&gt;NEditor编辑器&lt;/a&gt;，前身是百度的&lt;a href=&quot;https://ueditor.baidu.com/website/index.html&quot; target=&quot;_self&quot;&gt;UEditor编辑器&lt;/a&gt;，不过百度的UEditor已经不再维护了&lt;/p&gt;
&lt;p&gt;然而，就算NEditor编辑器，我也修改了里面很多东西&lt;/p&gt;
&lt;p&gt;上传文件，我们上一个章节说过了，不得不修改，&lt;/p&gt;
&lt;p&gt;因为我们要把用户贴过来的图片发送给钩子JS，而不是直接upload到自己的服务器上；&lt;/p&gt;
&lt;p&gt;我大概在neditor.all.js的26616行，加了一行自己的代码，大家可以去看我的&lt;a href=&quot;https://github.com/xland/xiangxuema&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以后打算让这个编辑器方便的兼容base64，这样就不用事先把图片传博客园服务器上去了，不知道这个思路靠谱不靠谱；&lt;/p&gt;

&lt;p&gt;另外，因为编辑器相关的前端文件都是静态资源，我就把他们放到static目录下去了&lt;/p&gt;
&lt;p&gt;这样只要在主页直接把这些静态资源加载过来就可以了&lt;/p&gt;
&lt;pre class=&quot;brush:html;toolbar:false&quot;&gt;
&amp;lt;script src=&quot;static/editor/neditor/neditor.config.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;static/editor/neditor/neditor.all.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;static/editor/neditor/neditor.service.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&quot;static/editor/neditor/i18n/zh-cn/zh-cn.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;
&lt;p&gt;其他的一些样式文件，ueditor自己会自动加载，路径也不会有什么问题&lt;/p&gt;

&lt;p&gt;在我&lt;a href=&quot;https://www.cnblogs.com/liulun/p/7819059.html&quot; target=&quot;_self&quot;&gt;上一个版本的程序里&lt;/a&gt;，一次只能编辑一篇文章&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2017.cnblogs.com/other/28932/201711/28932-20171111161658200-1831766078.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有人反映说，这样不是很方便，于是这个版本做了多标签页的功能；&lt;/p&gt;
&lt;p&gt;首先，我用一个数组存储每个标签页的基础数据&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
tabs: [{text:&quot;文章列表&quot;,
    url:&quot;https://i.cnblogs.com/posts&quot;,
    isHomePage:true,
    pageType:'list',
    data:null
}],
&lt;/pre&gt;
&lt;p&gt;vue的模板代码里呈现这个数组的数据：&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
&amp;lt;div @click=&quot;selectTab(index)&quot; v-for=&quot;(tab,index) in tabs&quot;&amp;gt;
&lt;/pre&gt;
&lt;p&gt;程序刚启动的时候，就这么一个标签页，当用户点了文章列表的某条文章的时候，执行下面的方法&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
articleClick(url, text) {
    var obj = {url,text,&quot;pageType&quot;:&quot;editor&quot;,data:null};
    this.tabs.push(tab);
    this.webViewInstance.loadURL(url);
}
&lt;/pre&gt;
&lt;p&gt;这样就多了一个标签页；&lt;/p&gt;
&lt;p&gt;因为我们这个程序，只有两种类型的画面，不是文章列表，就是编辑文章（添加文章和编辑文章是同样的画面）&lt;/p&gt;
&lt;p&gt;所以，虽然是多个标签页，也不过是在这两种画面间切换&lt;/p&gt;
&lt;p&gt;vue的模板代码如下&lt;/p&gt;
&lt;pre class=&quot;brush:html;toolbar:false&quot;&gt;
&amp;lt;div class=&quot;main&quot;&amp;gt;
    &amp;lt;list v-show=&quot;tabs[tabsSelectedIndex].pageType == 'list'&quot;&amp;gt;&amp;lt;/list&amp;gt;
    &amp;lt;editor v-show=&quot;tabs[tabsSelectedIndex].pageType == 'editor'&quot;&amp;gt;&amp;lt;/editor&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;
&lt;p&gt;根据当前tab页的类型，切换画面；&lt;/p&gt;
&lt;p&gt;每次新tab页的加入，我们就迫使webViewInstanceload一下tab对应的url，以拿到目标页的数据；&lt;/p&gt;
&lt;p&gt;每次tab页的切换，我们就从tab数组元素里拿data数据，其实就相当于我们缓存的数据（&lt;span&gt;并没有存成本地文件或本地数据库呢&lt;/span&gt;）；&lt;/p&gt;
&lt;p&gt;由于UEditor不是一个VUE组件，所以我们在切换页面，新加页面的时候，要通过UEditor的API获取数据，重置数据，代码如下：&lt;/p&gt;
&lt;pre class=&quot;brush:js;toolbar:false&quot;&gt;
UE.instants.ueditorInstant0.getContent();
UE.instants.ueditorInstant0.setContent(content);
&lt;/pre&gt;

&lt;p&gt;写到这里，发现并没有什么特殊的东西需要在博客里解释了&lt;/p&gt;
&lt;p&gt;还有不明白的地方的读者，自己去看&lt;a href=&quot;https://github.com/xland/xiangxuema&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;吧!&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载地址：&lt;a href=&quot;https://gitee.com/xland/cnblogs/releases/6.0.2&quot; target=&quot;_blank&quot;&gt;https://gitee.com/xland/cnblogs/releases/6.0.2&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;谢谢大家的支持；&lt;/p&gt;

&lt;p&gt;接下来我打算为这个程序加入下面这些功能：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;删除文章&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑分类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持CSDN博客&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持开源中国博客&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持简书&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持知乎&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;请大家多多关注：https://github.com/xland/xiangxuema&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 23:16:00 +0000</pubDate>
<dc:creator>liulun</dc:creator>
<og:description>回顾 在上一篇文章中， 咱们聊了我开发的这个程序是什么样子、为什么要开发这个程序 electron的工程结构，他是怎么启动和退出的 以及我们怎么用electron的技术，登录博客园，拿到会话信息； 这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liulun/p/10123545.html</dc:identifier>
</item>
<item>
<title>如何绕过博客园对  的屏蔽 - I.am.Conmajia</title>
<link>http://www.cnblogs.com/conmajia/p/bypass-script-filtering.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/conmajia/p/bypass-script-filtering.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Conmajia&lt;br/&gt;January 19, 2019&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;document.title = &quot;[我是 js 生成的!] &quot; + document.title&lt;br/&gt;&lt;/p&gt;
&lt;div class=&quot;info important&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;警告&lt;/strong&gt; 这是试验性的尝试，不要用它做多余的事。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这篇文章的标题其实是有点问题的，会让人觉得我在搞破坏，找漏洞。NONONO，这是误会，我最多就是想拿 js 改改默认的主题什么的。&lt;/p&gt;
&lt;p&gt;实际上，这种担心是不存在的。&lt;em&gt;博客园本身并没有屏蔽&lt;/em&gt; js 脚本，甚至在后台主动&lt;strong&gt;开放了 HTML 权限&lt;/strong&gt;，对一个博客网站来说，相当良心了。加上现在改成Markdown 编辑器，还支持文章正文内插入 HTML，整个博客的&lt;strong&gt;可玩性&lt;/strong&gt;更高了。&lt;/p&gt;
&lt;div class=&quot;info&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;毕竟它压根儿就没有扩展功能的插件和可编辑的主题，再不开放权限还玩您 &lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190120031212322-492892952.png&quot; width=&quot;16&quot;/&gt; 个蛋呢？&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;只是总有人&lt;em&gt;不小心&lt;/em&gt;搞出一些事来，为了网站安全，不得不&lt;a href=&quot;https://www.cnblogs.com/dudu/archive/2004/08/10/31807.html&quot;&gt;屏蔽掉&lt;/a&gt;文章里的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190119154554237-1035445164.png&quot; width=&quot;80%&quot;/&gt; 当然，这功能早在&lt;strong&gt;十几年前&lt;/strong&gt;就屏蔽了，所以也不关我们鸟事儿
&lt;p&gt;所以现在你如果在文章里写上 js，它没法运行。如果做试验，你写：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;前面的正文

&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    document.title = Math.random()
&amp;lt;/script&amp;gt;

后面的正文&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后把文章发表出来，你会发现这段压根儿就不显示、不执行，烟儿似的就消失了，屁反应没有。&lt;/p&gt;
&lt;p&gt;那怎么办啊，就没招改改默认主题了吗？好些人说，&lt;/p&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;center readability=&quot;2&quot;&gt;
&lt;p lang=&quot;zh-Hant&quot;&gt;&lt;em&gt;&lt;q&gt;默认主题也挺好的啊，还有那么多五颜六色的可以选呢。&lt;/q&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;/blockquote&gt;
&lt;p&gt;您是认真的吗？啊？默认的那些主题&lt;a href=&quot;https://www.cnblogs.com/conmajia/p/customize-blog-theme.html&quot;&gt;实在是太难看&lt;/a&gt;了啊，难道这就是传说中的&lt;strong&gt;程序员的审美观&lt;/strong&gt;么？9021 年了，醒醒，大清已经亡了！村里通网多少年了，Web 都已经 4.0，5.0，6.0 了，老铁！&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190119153002182-410948113.png&quot;/&gt; 好看吗？那您还挺淳朴的呢 ：）
&lt;p&gt;如果某天你意识到了这一点，精通增删改查的你也许会想要给自己的博客整个容？加点料？删点自带的垃圾？在读者打开你每篇文章时都跳出点不同的东西？&lt;/p&gt;
&lt;blockquote readability=&quot;4&quot;&gt;
&lt;center readability=&quot;2&quot;&gt;
&lt;p lang=&quot;zh-Hant&quot;&gt;&lt;em&gt;&lt;q&gt;你知道我在说什么，毕竟你那么聪明。&lt;/q&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;footer class=&quot;cite&quot; lang=&quot;cmn-latn&quot;&gt;—Conmajia&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;都已经开放 HTML 了，你当然可以用各种姿势咯美化界面咯，我这个博客就有很多东西是&lt;em&gt;代码生成的&lt;/em&gt;。还有一个好处是增强了文章的互动性，提高读者参与度。比如你要讲随机数，编了无数代码，写得是天花乱坠，读者看得是晕头转向：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;Math.random()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;吧啦吧啦逼逼半天，能有我一个按钮的效果好？&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;button class=&quot;button button-3d button-pill button-primary&quot; onclick=&quot;$('#random-tag').text(Math.random())&quot;&gt;点一下试试&lt;/button&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&lt;label id=&quot;random-tag&quot;&gt;&amp;lt;随机数&amp;gt;&lt;/label&gt;&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;或者用较小的篇幅展示更多内容？比如点下面的按钮：&lt;/p&gt;
&lt;div id=&quot;flip&quot; readability=&quot;7&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190120123505060-1460813487.png&quot; width=&quot;24&quot; align=&quot;absmiddle&quot;/&gt; 如何评价程序员的审美？&lt;/div&gt;
&lt;div id=&quot;panel&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;q&gt;走进地铁的一瞬间，大家就感受到了前所未有的尴尬，有人说这是程序员下班了……&lt;/q&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190120122044730-1150436723.png&quot; width=&quot;90%&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;$(document).ready(function(){&lt;br/&gt;$(&quot;#flip&quot;).click(function(){&lt;br/&gt;$(&quot;#panel&quot;).slideToggle(&quot;slow&quot;);&lt;br/&gt;});&lt;br/&gt;});&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;所以现在我来说说怎么运行文章正文里的 js 代码。你知道的，js 有一个 &lt;code&gt;eval&lt;/code&gt; 函数专门 evaluate 字符串形式的 js 语句。那么，嘻嘻，look at &lt;q&gt;管理→设置&lt;/q&gt;自定义 HTML 的地方：&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190119155200829-205496495.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190119155216648-2095670898.png&quot;/&gt;&lt;p&gt;非常幸运，&lt;code&gt;eval&lt;/code&gt; 函数可以执行，这就简单至极了。既然正文里的 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 屏蔽了，改从外围执行代码就好啦。&lt;strong&gt;举个例子&lt;/strong&gt;，在正文里用一个标签 &lt;code&gt;&amp;lt;run&amp;gt;&lt;/code&gt; 包住要执行的代码，直接 &lt;code&gt;eval&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!-- 页面底部 HTML 设置 --&amp;gt;
&amp;lt;script&amp;gt;
$(function(){
    $('run').each(function(){eval($(this).text())});
});
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，页面载入完后，就会&lt;em&gt;依次执行&lt;/em&gt;&lt;strong&gt;正文&lt;/strong&gt;里所有 &lt;code&gt;&amp;lt;run&amp;gt;&lt;/code&gt; 标签内的代码了。美观一点，可以把所有 &lt;code&gt;&amp;lt;run&amp;gt;&lt;/code&gt; 都隐藏起来：&lt;/p&gt;
&lt;pre class=&quot;css&quot;&gt;
&lt;code&gt;/* CSS 设置 */
run {
    display: none;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一开始那个例子改改，文章里写上：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;前面的正文

&amp;lt;run&amp;gt;
    document.title = Math.random()
&amp;lt;/run&amp;gt;

后面的正文&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发表文章就能看到效果了（↑↑ &lt;em&gt;你再看看&lt;strong&gt;本文&lt;/strong&gt;的标题栏&lt;/em&gt;？）：&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190119155648484-1923748714.png&quot;/&gt; Safari，macOS 10.14
&lt;p&gt;这不就绕过屏蔽了？&lt;strong&gt;但是&lt;/strong&gt;吧，我给的例子里只单纯使用了 &lt;code&gt;eval&lt;/code&gt;，&lt;em&gt;它有时候是不灵光的&lt;/em&gt;。因为 Markdown 编辑器会把代码里的 &lt;code&gt;$&lt;/code&gt;、&lt;code&gt;*&lt;/code&gt;、&lt;code&gt;_&lt;/code&gt; 这些特殊符号识别成格式开关，然后&lt;em&gt;把代码渲染得面目全非&lt;/em&gt;，根本没法用。所以&lt;em&gt;你需要想办法阻止编辑器解析你的代码&lt;/em&gt;！来看个稍微&lt;strong&gt;复杂点的例子&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;run&amp;gt;
    $('html').attr('lang', 'zh-CN');
    $('title').text(Math.random() * 100 * 99);
&amp;lt;/run&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有两句话的代码，被 Markdown 编辑器解析成了一大堆 HTML 标签：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;run&amp;gt;&amp;lt;br&amp;gt;
  &amp;lt;span class=&quot;MathJax_Preview&quot; style=&quot;color: inherit; display: none;&quot;&amp;gt;&amp;lt;/span&amp;gt;
&amp;lt;span class=&quot;MathJax&quot; id=&quot;MathJax-Element-2-Frame&quot; tabindex=&quot;0&quot; style=&quot;position: relative;&quot; data-mathml=&quot;
&amp;lt;math xmlns=&amp;amp;quot;http://www.w3.org/1998/Math/MathML&amp;amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mo stretchy=&amp;amp;quot;false&amp;amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;
&amp;lt;mo&amp;gt;&amp;amp;amp;#x2032;&amp;lt;/mo&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mi&amp;gt;h&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;t&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;m&amp;lt;/mi&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;amp;#x2032;&amp;lt;/mo&amp;gt;
&amp;lt;/msup&amp;gt;&amp;lt;mo stretchy=&amp;amp;quot;false&amp;amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;.&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;t&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;t&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;r&amp;lt;/mi&amp;gt;&amp;lt;msup&amp;gt;
&amp;lt;mo stretchy=&amp;amp;quot;false&amp;amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;amp;#x2032;&amp;lt;/mo&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mi&amp;gt;l&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;a&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;n&amp;lt;/mi&amp;gt;&amp;lt;msup&amp;gt;
&amp;lt;mi&amp;gt;g&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;amp;#x2032;&amp;lt;/mo&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;amp;#x2032;&amp;lt;/mo&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mi&amp;gt;z&amp;lt;/mi&amp;gt;
&amp;lt;mi&amp;gt;h&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;amp;#x2212;&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;N&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;amp;#x2032;&amp;lt;/mo&amp;gt;&amp;lt;/msup&amp;gt;
&amp;lt;mo stretchy=&amp;amp;quot;false&amp;amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot; role=&quot;presentation&quot;&amp;gt;

&amp;lt;!-- （省略几十行） --&amp;gt;

  &amp;lt;script type=&quot;math/tex&quot; id=&quot;MathJax-Element-2&quot;&amp;gt;('html').attr('lang', 'zh-CN'); 
&amp;lt;/script&amp;gt;('title').text(Math.random() * 100 * 99);&amp;lt;br&amp;gt;
&amp;lt;/run&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大部分是 MathJax 的数学公式解析，因为它用 &lt;code&gt;$&lt;/code&gt; 作为行间公式的识别符，而 jQuery 好死不死几乎全是 &lt;code&gt;$&lt;/code&gt;……&lt;/p&gt;
&lt;p&gt;至于解决方案嘛，你可以在&lt;q&gt;选项&lt;/q&gt;里禁用数学公式，&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190120132232995-1106369296.png&quot;/&gt;&lt;p&gt;或者换一个不支持 Markdown 的编辑器，&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190120132340762-61095285.png&quot;/&gt;&lt;p&gt;或者你可以&lt;em&gt;想点别的招&lt;/em&gt;。有一种&lt;em&gt;临时的&lt;/em&gt;解决方案是把代码放在 &lt;code&gt;&amp;lt;run&amp;gt;&lt;/code&gt; 的某个属性里，&lt;code&gt;eval&lt;/code&gt; 改成从属性中读取，比如：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;run code=&quot;$('html').attr('lang', 'zh-CN');$('title').text(Math.random() * 100 * 99);&quot;&amp;gt;&amp;lt;/run&amp;gt;
&amp;lt;/code&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;$('run').each(function(){eval($(this).attr('code'))});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我觉得，能运行点简单代码已经足够了，所以&lt;em&gt;我&lt;strong&gt;不会&lt;/strong&gt;在这里贴出完整的方案&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;需要说明的是，这篇文章写的东西并不是找出博客园的 bug，最多算&lt;em&gt;留出了非常大的自由度&lt;/em&gt;。至于怎么使用，还是得看&lt;em&gt;个人素质&lt;/em&gt;了。&lt;/p&gt;
&lt;div class=&quot;info&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;我强烈怀疑有些&lt;em&gt;重要的&lt;/em&gt;语句是无法执行的，不过我没有试过，我也不知道事实如何。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;The End. &lt;span class=&quot;math inline&quot;&gt;\(\Box\)&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 22:29:00 +0000</pubDate>
<dc:creator>I.am.Conmajia</dc:creator>
<og:description>做过小试验，主要用于美化界面、增强页面内容交互性，无关安全性讨论，一切全靠自觉.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/conmajia/p/bypass-script-filtering.html</dc:identifier>
</item>
<item>
<title>使用 WeihanLi.Npoi 操作 CSV - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/operate-csv-files-with-weihanli_npoi.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/operate-csv-files-with-weihanli_npoi.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;最近发现 csv 文件在很多情况下都在使用，而且经过大致了解，csv 格式简单，相比 excel 文件要小很多，读取也很是方便，而且也很通用，微软的 &lt;a href=&quot;https://github.com/dotnet/machinelearning&quot;&gt;ml.net&lt;/a&gt; 的&lt;a href=&quot;https://github.com/dotnet/machinelearning-samples&quot;&gt;示例项目&lt;/a&gt; 用来训练模型的数据也是使用的 csv 来保存的，最近又发现使用 jmeter 来测试网站的性能，也可以用 csv 来参数化请求，csv 文件操作的重要性由此可见。&lt;/p&gt;
&lt;p&gt;此前做了一个 NPOI 的扩展 &lt;a href=&quot;https://github.com/WeihanLi/WeihanLi.Npoi&quot;&gt;WeihanLi.Npoi&lt;/a&gt;，支持.net45 以及 .netstandard2.0及以上，主要是对 excel 文件的操作，于是打算再增加一些对csv的操作。&lt;/p&gt;
&lt;h2 id=&quot;csv-操作api&quot;&gt;csv 操作API&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// save to csv file
        /// &amp;lt;/summary&amp;gt;
        public static int ToCsvFile(this DataTable dt, string filePath);
        public static int ToCsvFile(this DataTable dataTable, string filePath, bool includeHeader);

        /// &amp;lt;summary&amp;gt;
        /// to csv bytes
        /// &amp;lt;/summary&amp;gt;
        public static byte[] ToCsvBytes(this DataTable dt);
        public static byte[] ToCsvBytes(this DataTable dataTable, bool includeHeader);

        /// &amp;lt;summary&amp;gt;
        /// convert csv file data to dataTable
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;filePath&quot;&amp;gt;csv file path&amp;lt;/param&amp;gt;
        public static DataTable ToDataTable(string filePath);

        /// &amp;lt;summary&amp;gt;
        /// convert csv file data to entity list
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;filePath&quot;&amp;gt;csv file path&amp;lt;/param&amp;gt;
        public static List&amp;lt;TEntity&amp;gt; ToEntityList&amp;lt;TEntity&amp;gt;(string filePath) where TEntity : new();

        /// &amp;lt;summary&amp;gt;
        /// save to csv file
        /// &amp;lt;/summary&amp;gt;
        public static int ToCsvFile&amp;lt;TEntity&amp;gt;(this IEnumerable&amp;lt;TEntity&amp;gt; entities, string filePath);
        public static int ToCsvFile&amp;lt;TEntity&amp;gt;(this IEnumerable&amp;lt;TEntity&amp;gt; entities, string filePath, bool includeHeader);

        /// &amp;lt;summary&amp;gt;
        /// to csv bytes
        /// &amp;lt;/summary&amp;gt;
        public static byte[] ToCsvBytes&amp;lt;TEntity&amp;gt;(this IEnumerable&amp;lt;TEntity&amp;gt; entities) =&amp;gt; ToCsvBytes(entities, true);
        public static byte[] ToCsvBytes&amp;lt;TEntity&amp;gt;(this IEnumerable&amp;lt;TEntity&amp;gt; entities, bool includeHeader);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的方法，即可方便的将一个 IEnumerable 对象或者是DataTable 导出为 csv 文件或者或者 csv 文件的字节数组，也可将 csv 文件转换为 DataTable 或者 List 对象。&lt;/p&gt;
&lt;p&gt;并且我于昨天优化了 csv 转成 list 对象的操作，并且支持了简单类型（比如int/long等 ）的直接导出&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;            var entities = new List&amp;lt;TestEntity&amp;gt;()
            {
                new TestEntity()
                {
                    PKID = 1,
                    SettingId = Guid.NewGuid(),
                    SettingName = &quot;Setting1&quot;,
                    SettingValue = &quot;Value1&quot;
                },
                new TestEntity()
                {
                    PKID=2,
                    SettingId = Guid.NewGuid(),
                    SettingName = &quot;Setting2&quot;,
                    SettingValue = &quot;Value2&quot;
                },
            };
            var csvFilePath = $@&quot;{Environment.GetEnvironmentVariable(&quot;USERPROFILE&quot;)}\Desktop\temp\test\test.csv&quot;;
            entities.ToCsvFile(csvFilePath);
            var entities1 = CsvHelper.ToEntityList&amp;lt;TestEntity&amp;gt;(csvFilePath);

            entities.ToExcelFile(csvFilePath.Replace(&quot;.csv&quot;, &quot;.xlsx&quot;));

            var vals = new[] { 1, 2, 3, 5, 4 };
            vals.ToCsvFile(csvFilePath);

            var numList = CsvHelper.ToEntityList&amp;lt;int&amp;gt;(csvFilePath);
            Console.WriteLine(numList.StringJoin(&quot;,&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多详情可参考示例：&lt;a href=&quot;https://github.com/WeihanLi/WeihanLi.Npoi/blob/dev/samples/DotNetCoreSample/Program.cs&quot; class=&quot;uri&quot;&gt;https://github.com/WeihanLi/WeihanLi.Npoi/blob/dev/samples/DotNetCoreSample/Program.cs&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;导入导出的时候如果根据需要配置要导出的属性以及顺序，和之前导出 Excel 相似，需要配置一下 ，目前和 Excel 导入导出共享配置，配置方式支持 Attribute 或者 FluentAPI 两种方式（不支持Excel的一些配置如Author，title、subject以及sheet等信息），示例如下：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// Attribute config
public class TestEntity
{
    public string Username { get; set; }

    [Column(IsIgnored = true)]
    public string PasswordHash { get; set; }

    public decimal Amount { get; set; } = 1000M;

    public string WechatOpenId { get; set; }

    public bool IsActive { get; set; }
}


// Fluent API
var setting = ExcelHelper.SettingFor&amp;lt;TestEntity&amp;gt;();
// ExcelSetting
setting.HasAuthor(&quot;WeihanLi&quot;)
    .HasTitle(&quot;WeihanLi.Npoi test&quot;)
    .HasDescription(&quot;&quot;)
    .HasSubject(&quot;&quot;);

setting.Property(_ =&amp;gt; _.SettingId)
    .HasColumnIndex(0);

setting.Property(_ =&amp;gt; _.SettingName)
    .HasColumnIndex(1);

setting.Property(_ =&amp;gt; _.DisplayName)
    .HasColumnIndex(2);

setting.Property(_ =&amp;gt; _.SettingValue)
    .HasColumnIndex(3);

setting.Property(_ =&amp;gt; _.CreatedTime)
    .HasColumnIndex(5);

setting.Property(_ =&amp;gt; _.CreatedBy)
    .HasColumnIndex(4);

setting.Property(_ =&amp;gt; _.UpdatedBy).Ignored();
setting.Property(_ =&amp;gt; _.UpdatedTime).Ignored();
setting.Property(_ =&amp;gt; _.PKID).Ignored();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更多配置详情参考：&lt;a href=&quot;https://github.com/WeihanLi/WeihanLi.Npoi#define-custom-mapping-and-settings&quot; class=&quot;uri&quot;&gt;https://github.com/WeihanLi/WeihanLi.Npoi#define-custom-mapping-and-settings&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt;
&lt;p&gt;如果有 csv 文件操作的需求，可以尝试使用它，如果不能满足你的需求欢迎来给我&lt;a href=&quot;https://github.com/WeihanLi/WeihanLi.Npoi/issues/new&quot;&gt;提 issue&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 16:45:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>最近发现 csv 文件在很多情况下都在使用，而且经过大致了解，csv 格式简单，相比 excel 文件要小很多，读取也很是方便，而且也很通用，微软的 [ml.net](https://github.c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weihanli/p/operate-csv-files-with-weihanli_npoi.html</dc:identifier>
</item>
<item>
<title>复盘一次服务安装失败问题 - 云是风的梦</title>
<link>http://www.cnblogs.com/lijinfeng042/p/10296804.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijinfeng042/p/10296804.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;记录一下本周服务改造过程踩坑经历。近期在做服务改造接入统一配置中心，对一些早期的服务进行升级，由此带来了不少问题，好在都在测试环境解决了，平稳上线。&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;问题描述&lt;/h2&gt;
&lt;p&gt;代码自动构建后，部署服务启动失败。到测试服务器上手动启动服务报错“错误1053：服务没有及时响应启动或控制请求”，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fzc85ljvbtj20hs06dab8.jpg&quot; alt=&quot;错误1053&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修复问题后服务无法重启，希望能找到一个&lt;strong&gt;不重启服务器&lt;/strong&gt;的方法重新安装启动服务。&lt;/p&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;基本套路还是一样的，程序员的法宝：Debug和Log。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;日志分析&quot;&gt;日志分析&lt;/h3&gt;
&lt;p&gt;分析的日志有三个方面可以参考：&lt;strong&gt;服务启动打印的日志，系统自带的事件日志，命令行启动日志。&lt;/strong&gt; 下面逐个分析使用场景和结论。&lt;/p&gt;
&lt;h4 id=&quot;系统自带日志&quot;&gt;系统自带日志&lt;/h4&gt;
&lt;p&gt;一般的程序错误都会在系统日志里面留下痕迹，即使是程序崩溃了，只要系统没有崩溃都会有记录。&lt;/p&gt;
&lt;p&gt;遗憾的是，本次应用程序错误后台只有简单提示“服务没有及时响应启动或控制请求”。&lt;em&gt;无法判断是否环境问题&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;查看安装日志，如图，没有找到太多有价值信息。&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fzc85lh99hj20it0cagm8.jpg&quot; alt=&quot;1053&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;服务启动日志&quot;&gt;服务启动日志&lt;/h4&gt;
&lt;p&gt;如果能走到这步，后台有程序输出的记录日志，一般都是启动服务进入到程序里面才报错的，通过调试可以快速定位问题。&lt;/p&gt;
&lt;p&gt;查询日志中心，本次没有生成新的日志，开启调试开关，本地也没有生成记录日志。&lt;em&gt;可以判断还没有走到程序内部。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;命令行日志&quot;&gt;命令行日志&lt;/h4&gt;
&lt;p&gt;如果是某个没有捕捉到的问题，直接拖到命令行启动倒是一个好方法，可以直接从控制台看到某些错误信息。&lt;/p&gt;
&lt;p&gt;果然，通过这一步看到了错误提示。详细日志略过（敏感内容就不贴了。。。），简单的说就是配置没有更新，某个依赖项服务没有注册导致服务dump。&lt;/p&gt;
&lt;p&gt;进一步使用SC命令可以查询到其实服务是处于star-pending状态。到此终于可以知道为何启动不起来了。&lt;/p&gt;
&lt;h3 id=&quot;重启失败服务&quot;&gt;重启失败服务&lt;/h3&gt;
&lt;p&gt;接下来我们删除这个启动失败的服务，有两种处理方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;InstallUtil.exe /u [FullPath\ServiceName.exe]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SC delete [ServiceName]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;我采用了第一种使用SC命名的方式，得到了如下的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fzcc0w81uyj20lw07twf2.jpg&quot; alt=&quot;执行了SC Delete&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后安装服务，报1058的错误。查看服务列表，这时候&lt;strong&gt;服务还是存在于列表中，只是状态是禁用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fzc85lbpd1j20hs0b4glq.jpg&quot; alt=&quot;安装服务报错1028&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Google了一下,这种情况只需要重启后继续安装就可以。问题来了，服务器能随便重启吗？不说生产的服务器，就是测试的服务器上面也部署了各种服务，几百号人在开发测试呢。。。总不能等到下班后重启服务器吧，找了一下，这种情况就只能删除注册表重新打开服务列表查看：&lt;br/&gt;&lt;em&gt;删除注册表项HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\你的服务名&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;找了一下卸载的原理，园子里这篇&lt;a href=&quot;https://www.cnblogs.com/bmwchampion/archive/2010/08/22/WindowServiceAPI.html&quot;&gt;Windows API 之 Windows Service&lt;/a&gt;让我了解到:&lt;br/&gt;&lt;strong&gt;删除服务的本质是在注册表里面删除该服务的注册表键以及该键的子键。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;标记该服务为可删除的服务&lt;/li&gt;
&lt;li&gt;检查该服务是否已经停止，并且该牵涉到该服务的所有句柄都已经被关闭的时候，再来删除该服务；&lt;/li&gt;
&lt;li&gt;如果该服务一直都在运行状态，那么就等到下次机器重启的时候，来删除该服务&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;关键点在于：&lt;strong&gt;服务所有引用的句柄都已经被关闭。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以下几点需要仔细check：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;配置文件是否正确&lt;/li&gt;
&lt;li&gt;依赖项是否全部打包正确&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这其实是一个典型的研发，测试，运维合作解决问的过程。每个公司的自动化运维构建平台都会有各种不同的规定，例如配置更新问题。&lt;/p&gt;
&lt;p&gt;部署的时候需要按照一定的步骤去检查减少问题。&lt;/p&gt;
&lt;p&gt;推荐使用SC命名行的方式操作安装和卸载服务，可以满足更多的需求而不必重新打包。例如安装不同版本的同一个.exe服务,只是端口和服务名称不一样。&lt;/p&gt;
&lt;p&gt;本文同步发表在公众号文章 &lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMzg5NTAxNQ==&amp;amp;mid=2247483774&amp;amp;idx=1&amp;amp;sn=c4b612acce2a15949f304eeb6dd42aee&amp;amp;scene=0#wechat_redirect&quot;&gt;复盘一次服务安装失败问题&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;博客是我学习过程的输出，希望你有所收获。&lt;/li&gt;
&lt;li&gt;有想法请留言，共同探讨学习。&lt;/li&gt;
&lt;li&gt;由于博主能力有限，文中可能存在描述不正确，欢迎指正、补充！&lt;/li&gt;
&lt;li&gt;你也可以关注我的公众号：&lt;strong&gt;ProgramLife042&lt;/strong&gt;，名称：&lt;strong&gt;风之程序人生&lt;/strong&gt;，方便接收最新内容。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/mw690/66cf5bc0ly1fv6etki980j20760763yz.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 20 Jan 2019 16:18:00 +0000</pubDate>
<dc:creator>云是风的梦</dc:creator>
<og:description>[TOC] 前言 记录一下本周服务改造过程踩坑经历。近期在做服务改造接入统一配置中心，对一些早期的服务进行升级，由此带来了不少问题，好在都在测试环境解决了，平稳上线。 问题描述 代码自动构建后，部署服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijinfeng042/p/10296804.html</dc:identifier>
</item>
<item>
<title>神经网络(一)神经网络基础知识 - ChetTlittlebread</title>
<link>http://www.cnblogs.com/ChetTlittilebread/p/10296752.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ChetTlittilebread/p/10296752.html</guid>
<description>&lt;h3 id=&quot;人工神经元模型&quot;&gt;1.人工神经元模型&lt;/h3&gt;
&lt;h4 id=&quot;神经元信息处理过程的简化概况&quot;&gt;神经元信息处理过程的简化概况：&lt;/h4&gt;
&lt;p&gt;1.每个神经元都是一个多输入单输出的信息处理单元&lt;br/&gt;2.神经元输入分为兴奋性输入和抑制性输入两种类型(即有正负)&lt;br/&gt;3.神经元具有空间整合性和阈值特性&lt;br/&gt;4.神经元输入与输出间有固定的时滞，主要取决于突触延搁&lt;br/&gt;5.忽略时间整合作用和不应期&lt;br/&gt;6.神经元本身是非时变的即突触时延和突触强度是常数&lt;/p&gt;
&lt;h4 id=&quot;神经元的数学模型&quot;&gt;神经元的数学模型&lt;/h4&gt;
&lt;p&gt;令&lt;span class=&quot;math inline&quot;&gt;\(x_i(t)\)&lt;/span&gt;表示t时刻神经元j接受的来自神经元i的输入信息，&lt;span class=&quot;math inline&quot;&gt;\(o_j(t)\)&lt;/span&gt;表示t时刻神经元j的输出信息，则&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(o_j(t)=f\{[\sum_{i+1}^{n}w_{ij}x_i(t-\tau_{ij})]-T_j\}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\tau_{ij}\)&lt;/span&gt;输入输出间的突触时延&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(T_j\)&lt;/span&gt;神经元j的阈值&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(w_{ij}\)&lt;/span&gt;神经元i到j的突触连接系数或权重值&lt;/p&gt;
&lt;p&gt;输入总和常常称为神经元在t时刻的净输入&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(net'_j(t)=\sum_{i=1}^{n}w_{ij}x_{i}(t)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(net'_j(t)=W_j^TX\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W_j=(w_{1j},w_{2j},...,w_{nj})^T\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(X=(x_1,x_2,...,x_n)^T\)&lt;/span&gt;&lt;br/&gt;令&lt;span class=&quot;math inline&quot;&gt;\(x_0=-1,w_{0j}=T_j\)&lt;/span&gt;有&lt;span class=&quot;math inline&quot;&gt;\(net'_j-T_j=net_j=\sum_{i=0}^nw_{ij}x{i}=W^T_jX\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;综上，神经元模型可简化为&lt;span class=&quot;math inline&quot;&gt;\(o_j=f(net_j)=f(W_j^TX)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;人工神经网络模型&quot;&gt;2.人工神经网络模型&lt;/h3&gt;
&lt;h4 id=&quot;hebb学习&quot;&gt;1.Hebb学习&lt;/h4&gt;
&lt;p&gt;是一种&lt;strong&gt;纯前馈&lt;/strong&gt;、&lt;strong&gt;无监督学习&lt;/strong&gt;&lt;br/&gt;学习信号简单地等于神经元的输出&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(r=f(W_j^TX)\)&lt;/span&gt;&lt;br/&gt;权向量调整公式&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\eta f(W_j^TX)X\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij}=\eta f(W_j^TX)X=\eta o_jx_i\)&lt;/span&gt;&lt;br/&gt;Hebb学习规则要求预先设置权饱和值 防止输入输出无约束增长&lt;br/&gt;此外，还要求权值初始化对&lt;span class=&quot;math inline&quot;&gt;\(W_j(0)\)&lt;/span&gt;赋予零附近的小随机数&lt;/p&gt;
&lt;p&gt;例如T=0，&lt;span class=&quot;math inline&quot;&gt;\(\eta=1,X^1=(1,-2,1.5,0)^T,X^2=(1,-0.5,-2,-1.5)^T,X^3=(0,1,-1,1.5)^T,W(0)=(1,-1,0,0.5)\)&lt;/span&gt;转移函数为sgn函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import torch as t

def sgn(x):
    if x[0]&amp;gt;=0: return 1
    else: return -1

w_0 = t.Tensor([[1,-1,0,0.5]])
eta = 1
x = []
x.append(t.Tensor([[1],[-2],[1.5],[0]]))
x.append(t.Tensor([[1],[-0.5],[-2],[-1.5]]))
x.append(t.Tensor([[0],[1],[-1],[1.5]]))

for i in x:
    net = w_0.mm(i)
    print(net)
    w_0 = w_0+eta*sgn(net)*i.t()
    print(w_0)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;tensor([[3.]])
tensor([[ 2.0000, -3.0000,  1.5000,  0.5000]])
tensor([[-0.2500]])
tensor([[ 1.0000, -2.5000,  3.5000,  2.0000]])
tensor([[-3.]])
tensor([[ 1.0000, -3.5000,  4.5000,  0.5000]])&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;percepton学习规则&quot;&gt;2.Percepton学习规则&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(r=d_j-o_j\)&lt;/span&gt;&lt;br/&gt;$o_j=f(W^T_jX)=sgn(W^T_jX)= \begin {cases} 1 &amp;amp; W^T_jX\ge0 \ -1 &amp;amp; W^T_jX&amp;lt;0 \end {cases} $&lt;br/&gt;权值调整公式为&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\eta [d_j-sgn(W_j^TX)]X\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij}=\eta [d_j-sgn(W_j^TX)]x_i\)&lt;/span&gt;&lt;br/&gt;在有误差的情况下由于&lt;span class=&quot;math inline&quot;&gt;\(d_j,sgn\)&lt;/span&gt;取值为{-1,1}，权值调整公式可简化为&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\pm 2 \eta X\)&lt;/span&gt;&lt;br/&gt;只适用于二进制神经元 是一种有监督学习&lt;/p&gt;
&lt;h4 id=&quot;delta学习规则&quot;&gt;3.&lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt;学习规则&lt;/h4&gt;
&lt;p&gt;学习信号规定为&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(r=[d_j-f(W_j^TX)]f'(W_j^TX)=(d_j-o_j)f'(net_j)\)&lt;/span&gt;&lt;br/&gt;要求转移函数可导，只适用于有监督学习中定义的连续转移函数&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\eta (d_j-o_j)f'(net_j)X\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij}=\eta (d_j-o_j)f'(net_j)x_i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如&lt;span class=&quot;math inline&quot;&gt;\(w_0=T,x_0=-1,\eta = 0.1,X^1=(-1,1,-2,0)^T,X^2=(-1,0,1.5,-0.5)^T,X^3=(-1,-1,1,0.5)^T,d^1=-1,d^2=-1,d^3=1,W(0)=(0.5,1,-1,0)^T\)&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import torch as t
import math

def f(x):
    return (1-math.e**(-x))/(1+math.e**(-x))

def f_d(x):
    return (1-f(x)**2)/2

w_0 = t.Tensor([[0.5,1,-1,0]])
eta = 0.1
x = []
x.append(t.Tensor([[-1],[1],[-2],[0]]))
x.append(t.Tensor([[-1],[0],[1.5],[-0.5]]))
x.append(t.Tensor([[-1],[-1],[1],[0.5]]))

d = []
d.append(-1)
d.append(-1)
d.append(1)

for i,j in zip(x,d):
    net = w_0.mm(i)
    o=f(net)
    w_0=w_0+eta*(j-o)*f_d(net)*i.t()
    print(w_0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;tensor([[ 0.5259,  0.9741, -0.9482,  0.0000]])
tensor([[ 0.5314,  0.9741, -0.9563,  0.0027]])
tensor([[ 0.5046,  0.9474, -0.9296,  0.0161]])&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;lms学习规则&quot;&gt;4.LMS学习规则&lt;/h4&gt;
&lt;p&gt;学习信号定义为&lt;span class=&quot;math inline&quot;&gt;\(r=d_j-W_j^TX\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j=\eta (d_j-W_j^TX)X\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij}=\eta (d_j-W_j^TX)x_j\)&lt;/span&gt;&lt;br/&gt;可以看做&lt;span class=&quot;math inline&quot;&gt;\(\delta\)&lt;/span&gt;学习的特例&lt;br/&gt;有监督学习 权值可初始化为任意值&lt;/p&gt;
&lt;h4 id=&quot;correlation学习规则&quot;&gt;5.Correlation学习规则&lt;/h4&gt;
&lt;p&gt;学习信号为&lt;span class=&quot;math inline&quot;&gt;\(r=d_j\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_j = \eta d_jX\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta w_{ij} = \eta d_j x_i\)&lt;/span&gt;&lt;br/&gt;有监督学习 要求权值初始化为0&lt;/p&gt;
&lt;h4 id=&quot;winner-take-all学习规则&quot;&gt;6.Winner-Take-All学习规则&lt;/h4&gt;
&lt;p&gt;只有响应最大的神经元有权利调整权向量&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(W_j^{T_*}X=max(W_i^TX)\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta W_{j^*}=\alpha (X-W_{j^*})\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\alpha \in (0,1]\)&lt;/span&gt;为一个小的学习常数&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;3.小结&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/ChetTlittilebread/1387300/o_1.png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 15:50:00 +0000</pubDate>
<dc:creator>ChetTlittlebread</dc:creator>
<og:description>1.人工神经元模型 神经元信息处理过程的简化概况： 1.每个神经元都是一个多输入单输出的信息处理单元 2.神经元输入分为兴奋性输入和抑制性输入两种类型(即有正负) 3.神经元具有空间整合性和阈值特性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ChetTlittilebread/p/10296752.html</dc:identifier>
</item>
<item>
<title>【原创】《从0开始学RocketMQ》—单机搭建 - 琳茹的技术轮子</title>
<link>http://www.cnblogs.com/mengyi/p/10296620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengyi/p/10296620.html</guid>
<description>&lt;h3 id=&quot;htoc&quot;&gt;内容目录&lt;/h3&gt;
&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;1. RocketMQ是什么？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;2. 下载并解压&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;3. 启动NameServer&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;4. 启动 Broker&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;5. 关闭消息队列&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;toc&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;h1rocketmq&quot;&gt;1. RocketMQ是什么？&lt;/h3&gt;
&lt;p&gt;RocketMQ是一种消息队列。何为消息队列？即数据结构中一种“先进先出”的数据结构。在微服务中，分布式消息队列可以解决什么问题？应用解耦、流量削峰、消息分发、保证最终一致性、方便动态扩容等。&lt;/p&gt;
&lt;p&gt;RocketMQ中不可不知的四个角色：Producer（消息生产者）、Consumer（消息消费者）、Broker（消息暂存者）、NameServer（消息协调者）。由这四个角色的作用可知，启动 RocketMQ 时，应该先启动 NameServer，然后再启动 Broker，后续需要发送消息就用 Producer，需要接收消息就用 Consumer。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;h2&quot;&gt;2. 下载并解压&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
cd /usr/&lt;span&gt;local
wget &lt;/span&gt;-c http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mirrors.shu.edu.cn/apache/rocketmq/4.3.2/rocketmq-all-4.3.2-bin-release.zip&lt;/span&gt;
unzip rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release.zip -&lt;span&gt;d .
cd rocketmq&lt;/span&gt;-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-&lt;span&gt;release
ls
[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-&lt;span&gt;release]# ls
benchmark  bin  conf  lib  LICENSE  NOTICE  README.md&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;h3nameserver&quot;&gt;3. 启动NameServer&lt;/h3&gt;
&lt;p&gt;启动&lt;code&gt;NameServer：nohup sh bin/mqnamesrv &amp;amp;&lt;/code&gt;，然而发现不能正常启动，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup sh bin/mqnamesrv &amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;32673&lt;/span&gt;&lt;span&gt;
[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup: ignoring input and appending output to ‘nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;’

[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]+  Exit &lt;span&gt;1&lt;/span&gt;                  nohup sh bin/mqnamesrv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看nohup.out：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# cat nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt; 
ERROR: Please &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; the JAVA_HOME variable &lt;span&gt;in&lt;/span&gt; your environment, We need java(x64)! !!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可是，本机明明已经安装jdk并且已经配置了 JAVA_HOME 环境变量呀：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# java -&lt;span&gt;version
java version &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.8.0_171&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
Java(TM) SE Runtime Environment (build &lt;/span&gt;&lt;span&gt;1.8&lt;/span&gt;.0_171-&lt;span&gt;b11)
Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM (build &lt;span&gt;25.171&lt;/span&gt;-b11, mixed mode)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;环境变量设置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#####################java env###############
JAVA_HOME&lt;/span&gt;=/opt/jdk1.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.0_171
CLASSPATH&lt;/span&gt;=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/&lt;span&gt;dt.jar 
PATH&lt;/span&gt;=$JAVA_HOME/bin:$HOME/bin:$HOME/.local/bin:$PATH
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看 runserver.sh 脚本，发现有这么三行命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[ ! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=$HOME/jdk/&lt;span&gt;java
[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=/usr/&lt;span&gt;java
[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; error_exit &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please set the JAVA_HOME variable in your environment, We need java(x64)!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将其注释之，继续往下看，发现下面两行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export JAVA_HOME
export JAVA&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;嗯，果断修改 JAVA_HOME 的值如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
export JAVA_HOME=/opt/jdk1.&lt;span&gt;8&lt;/span&gt;.0_171
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次启动 NameServer ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup sh bin/mqnamesrv &amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;31098&lt;/span&gt;&lt;span&gt;
[root@&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup: ignoring input and appending output to ‘nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;’

[root@&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-&lt;span&gt;release]# ls
benchmark  bin  conf  lib  LICENSE  nohup.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;  NOTICE  README.md
[root@&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]#  cat nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt; 
Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: Using the DefNew young collector with the CMS collector &lt;span&gt;is&lt;/span&gt; deprecated and will likely be removed &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a future release
Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: UseCMSCompactAtFullCollection &lt;span&gt;is&lt;/span&gt; deprecated and will likely be removed &lt;span&gt;in&lt;/span&gt;&lt;span&gt; a future release.
The Name Server boot success. serializeType&lt;/span&gt;=JSON
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处可以看到 NameServer 已成功启动，查看 NameServer 日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# tail -f ~/logs/rocketmqlogs/&lt;span&gt;namesrv.log 
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; INFO main - tls.client.certPath = &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; INFO main - tls.client.authServer = &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; INFO main - tls.client.trustCertPath = &lt;span&gt;null&lt;/span&gt;
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;36&lt;/span&gt; INFO main -&lt;span&gt; Using OpenSSL provider
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO main - SSLContext created &lt;span&gt;for&lt;/span&gt;&lt;span&gt; server
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO NettyEventExecutor -&lt;span&gt; NettyEventExecutor service started
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO FileWatchService -&lt;span&gt; FileWatchService service started
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;19&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO main - The Name Server boot success. serializeType=&lt;span&gt;JSON
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO NSScheduledThread1 - --------------------------------------------------------
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;07&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;37&lt;/span&gt; INFO NSScheduledThread1 - configTable SIZE: &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;NameServer 启动成功&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;h4broker&quot;&gt;4. 启动 Broker&lt;/h3&gt;
&lt;p&gt;启动&lt;code&gt;Broker：nohup sh bin/mqbroker -n localhost:9876&amp;amp;&lt;/code&gt;，然而发现不能正常启动，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup sh bin/mqbroker -n localhost:&lt;span&gt;9876&lt;/span&gt;&amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;28571&lt;/span&gt;&lt;span&gt;
[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup: ignoring input and appending output to ‘nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;’

[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]+  Exit &lt;span&gt;1&lt;/span&gt;                  nohup sh bin/mqbroker -n localhost:&lt;span&gt;9876&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看nohup.out，发现里面多了这么几行错误信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Java HotSpot(TM) &lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: INFO: os::commit_memory(&lt;span&gt;0x00000005c0000000&lt;/span&gt;, &lt;span&gt;8589934592&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;) failed; error=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cannot allocate memory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (errno=&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
#
# There &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; insufficient memory &lt;span&gt;for&lt;/span&gt; the Java Runtime Environment to &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;.
# Native memory allocation (mmap) failed to map &lt;/span&gt;&lt;span&gt;8589934592&lt;/span&gt; bytes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; committing reserved memory.
# An error report file with more information &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; saved &lt;span&gt;as&lt;/span&gt;&lt;span&gt;:
# &lt;/span&gt;/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/hs_err_pid28580.log
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遂，查看 hs_err_pid28580.log：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# tail -1000f /usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/&lt;span&gt;hs_err_pid28580.log
#
# There &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; insufficient memory &lt;span&gt;for&lt;/span&gt; the Java Runtime Environment to &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;.
# Native memory allocation (mmap) failed to map &lt;/span&gt;&lt;span&gt;8589934592&lt;/span&gt; bytes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; committing reserved memory.
# Possible reasons:
#   The system &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; &lt;span&gt;out&lt;/span&gt;&lt;span&gt; of physical RAM or swap space
#   In &lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt; bit mode, the process size limit was hit
# Possible solutions:
#   Reduce memory load on the system
#   Increase physical memory or swap space
#   Check &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; swap backing store &lt;span&gt;is&lt;/span&gt;&lt;span&gt; full
#   Use &lt;/span&gt;&lt;span&gt;64&lt;/span&gt; bit Java on a &lt;span&gt;64&lt;/span&gt;&lt;span&gt; bit OS
#   Decrease Java heap size (&lt;/span&gt;-Xmx/-&lt;span&gt;Xms)
#   Decrease number of Java threads
#   Decrease Java thread stack sizes (&lt;/span&gt;-&lt;span&gt;Xss)
#   Set larger code cache with &lt;/span&gt;-XX:ReservedCodeCacheSize=&lt;span&gt;
# This output file may be truncated or incomplete.
#
#  Out of Memory Error (os_linux.cpp:&lt;/span&gt;&lt;span&gt;2640&lt;/span&gt;), pid=&lt;span&gt;28580&lt;/span&gt;, tid=&lt;span&gt;0x00007fbc93a6c700&lt;/span&gt;&lt;span&gt;
#
# JRE version:  (&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;.0_171-&lt;span&gt;b11) (build )
# Java VM: Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM (&lt;span&gt;25.171&lt;/span&gt;-b11 mixed mode linux-&lt;span&gt;amd64 compressed oops)
# Failed to write core dump. Core dumps have been disabled. To enable core dumping, &lt;/span&gt;&lt;span&gt;try&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ulimit -c unlimited&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; before starting Java again
........
VM Arguments:
jvm_args: &lt;/span&gt;-Xms8g -Xmx8g -Xmn4g -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=&lt;span&gt;25&lt;/span&gt; -XX:InitiatingHeapOccupancyPercent=&lt;span&gt;30&lt;/span&gt; -XX:SoftRefLRUPolicyMSPerMB=&lt;span&gt;0&lt;/span&gt; -XX:SurvivorRatio=&lt;span&gt;8&lt;/span&gt; -verbose:gc -Xloggc:/dev/shm/mq_gc_%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=&lt;span&gt;5&lt;/span&gt; -XX:GCLogFileSize=30m -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:MaxDirectMemorySize=15g -XX:-UseLargePages -XX:-UseBiasedLocking -Djava.ext.dirs=/opt/jdk1.&lt;span&gt;8&lt;/span&gt;.0_171/jre/lib/ext:/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/bin/../&lt;span&gt;lib 
java_command: org.apache.rocketmq.broker.BrokerStartup &lt;/span&gt;-n localhost:&lt;span&gt;9876&lt;/span&gt;&lt;span&gt;
java_class_path (initial): .:&lt;/span&gt;/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/bin/../conf:.:/opt/jdk1.&lt;span&gt;8&lt;/span&gt;.0_171/lib/tools.jar:/opt/jdk1.&lt;span&gt;8&lt;/span&gt;.0_171/lib/&lt;span&gt;dt.jar
Launcher Type: SUN_STANDARD
......&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大概意思呢，就是说，启动broker时内存不足，为什么内存不足呢？因为启动时候指定了JVM最大可用内存和最小可用内存均为8G，年轻代大小为2G。&lt;br/&gt;查看Broker启动脚本，发现果然指定了这三个jvm启动参数，然后意外发现对于JAVA_HOME的设置，runbroker.sh与runserver.sh是一样一样的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[ ! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=$HOME/jdk/&lt;span&gt;java
[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=/usr/&lt;span&gt;java
[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; error_exit &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please set the JAVA_HOME variable in your environment, We need java(x64)!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

export JAVA_HOME
export JAVA&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
export BASE_DIR&lt;/span&gt;=$(dirname $&lt;span&gt;0&lt;/span&gt;)/&lt;span&gt;..
export CLASSPATH&lt;/span&gt;=.:${BASE_DIR}/&lt;span&gt;conf:${CLASSPATH}

#&lt;/span&gt;===========================================================================================&lt;span&gt;
# JVM Configuration
#&lt;/span&gt;===========================================================================================&lt;span&gt;
JAVA_OPT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${JAVA_OPT} -server -Xms8g -Xmx8g -Xmn4g&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;遂，修改启动脚本中JAVA_HOME的设置以及JVM启动脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#[ ! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=$HOME/jdk/&lt;span&gt;java
#[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; JAVA_HOME=/usr/&lt;span&gt;java
#[ &lt;/span&gt;! -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; error_exit &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please set the JAVA_HOME variable in your environment, We need java(x64)!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

export JAVA_HOME&lt;/span&gt;=/opt/jdk1.&lt;span&gt;8&lt;/span&gt;&lt;span&gt;.0_171
export JAVA&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$JAVA_HOME/bin/java&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
export BASE_DIR&lt;/span&gt;=$(dirname $&lt;span&gt;0&lt;/span&gt;)/&lt;span&gt;..
export CLASSPATH&lt;/span&gt;=.:${BASE_DIR}/&lt;span&gt;conf:${CLASSPATH}

#&lt;/span&gt;===========================================================================================&lt;span&gt;
# JVM Configuration
#&lt;/span&gt;===========================================================================================&lt;span&gt;
JAVA_OPT&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再次启动Broker：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup sh bin/mqbroker -n localhost:&lt;span&gt;9876&lt;/span&gt;&amp;amp;&lt;span&gt;
[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;29092&lt;/span&gt;&lt;span&gt;
[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# nohup: ignoring input and appending output to ‘nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;’

[root@&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# cat nohup.&lt;span&gt;out&lt;/span&gt;&lt;span&gt; 
Java HotSpot(TM) &lt;/span&gt;&lt;span&gt;64&lt;/span&gt;-Bit Server VM warning: INFO: os::commit_memory(&lt;span&gt;0x00000005c0000000&lt;/span&gt;, &lt;span&gt;8589934592&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;) failed; error=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cannot allocate memory&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; (errno=&lt;span&gt;12&lt;/span&gt;&lt;span&gt;)
#
# There &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; insufficient memory &lt;span&gt;for&lt;/span&gt; the Java Runtime Environment to &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;.
# Native memory allocation (mmap) failed to map &lt;/span&gt;&lt;span&gt;8589934592&lt;/span&gt; bytes &lt;span&gt;for&lt;/span&gt;&lt;span&gt; committing reserved memory.
# An error report file with more information &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; saved &lt;span&gt;as&lt;/span&gt;&lt;span&gt;:
# &lt;/span&gt;/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release/&lt;span&gt;hs_err_pid28580.log
The broker[&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt;, &lt;span&gt;39.107&lt;/span&gt;.&lt;span&gt;153.215&lt;/span&gt;:&lt;span&gt;10911&lt;/span&gt;] boot success. serializeType=JSON and name server &lt;span&gt;is&lt;/span&gt; localhost:&lt;span&gt;9876&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处可以看到Broker已启动成功，查看Broker日志：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# tail -1000f ~/logs/rocketmqlogs/&lt;span&gt;broker.log 
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt; INFO main - rocketmqHome=/usr/local/rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-&lt;span&gt;release
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt; INFO main - namesrvAddr=localhost:&lt;span&gt;9876&lt;/span&gt;&lt;span&gt;
......
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO FileWatchService -&lt;span&gt; FileWatchService service started
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO PullRequestHoldService -&lt;span&gt; PullRequestHoldService service started
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO brokerOutApi_thread_1 - register broker to name server localhost:&lt;span&gt;9876&lt;/span&gt;&lt;span&gt; OK
&lt;/span&gt;&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO main - Start transaction service!
&lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;01&lt;/span&gt;-&lt;span&gt;09&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;13&lt;/span&gt;:&lt;span&gt;09&lt;/span&gt; INFO main - The broker[&lt;span&gt;157&lt;/span&gt;-&lt;span&gt;89&lt;/span&gt;, &lt;span&gt;39.107&lt;/span&gt;.&lt;span&gt;157.89&lt;/span&gt;:&lt;span&gt;10911&lt;/span&gt;] boot success. serializeType=JSON and name server &lt;span&gt;is&lt;/span&gt; localhost:&lt;span&gt;9876&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;h5&quot;&gt;5. 关闭消息队列&lt;/h3&gt;
&lt;p&gt;关闭 Broker：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# sh bin/&lt;span&gt;mqshutdown broker
The mqbroker(&lt;/span&gt;&lt;span&gt;29099&lt;/span&gt;) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; running...
Send shutdown request to mqbroker(&lt;/span&gt;&lt;span&gt;29099&lt;/span&gt;) OK
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关闭 NameServer：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@&lt;span&gt;153&lt;/span&gt;-&lt;span&gt;215&lt;/span&gt; rocketmq-all-&lt;span&gt;4.3&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-bin-release]# sh bin/&lt;span&gt;mqshutdown namesrv
The mqnamesrv(&lt;/span&gt;&lt;span&gt;14283&lt;/span&gt;) &lt;span&gt;is&lt;/span&gt;&lt;span&gt; running...
Send shutdown request to mqnamesrv(&lt;/span&gt;&lt;span&gt;14283&lt;/span&gt;) OK
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 20 Jan 2019 15:45:00 +0000</pubDate>
<dc:creator>琳茹的技术轮子</dc:creator>
<og:description>内容目录 1. RocketMQ是什么？ 2. 下载并解压 3. 启动NameServer 4. 启动 Broker 5. 关闭消息队列 1. RocketMQ是什么？ RocketMQ是一种消息队列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mengyi/p/10296620.html</dc:identifier>
</item>
<item>
<title>【swupdate文档 五】从可信的来源更新镜像 - zqb-all</title>
<link>http://www.cnblogs.com/zqb-all/p/10296719.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zqb-all/p/10296719.html</guid>
<description>&lt;p&gt;现在越来越重要的是，设备不仅要能安全地进行更新操作，&lt;br/&gt;而且要能够验证发送的图像是否来自一个已知的源， 并且没有嵌入恶意软件。&lt;/p&gt;
&lt;p&gt;为了实现这个目标，SWUpdate必须验证传入的镜像。&lt;br/&gt;有几种方法可以做到这一点。&lt;br/&gt;这里有一些问题，完整的复合镜像需要签名吗?还是只是它的某些部分需要?&lt;/p&gt;
&lt;p&gt;不同做法的优缺点将在下一章中描述。&lt;/p&gt;
&lt;h2 id=&quot;对复合镜像进行签名&quot;&gt;对复合镜像进行签名&lt;/h2&gt;
&lt;p&gt;一个直接了当的做法是对整个复合镜像进行签名。但是。这样做有一些严重&lt;br/&gt;的缺点。这会导致无法在加载完整个复合镜像之前对镜像进行验证。&lt;br/&gt;这意味着，校验需要在安装了镜像之后才进行，而不是在实际写入设备&lt;br/&gt;之前就能进行。&lt;br/&gt;这会导致，如果校验失败，需要对已经安装好的镜像做一些取消安装的操作，&lt;br/&gt;这种取消安装的操作，在碰到掉电时，可能会导致一些不希望保留的数据被保留在设备上。&lt;/p&gt;
&lt;h2 id=&quot;对子镜像进行签名&quot;&gt;对子镜像进行签名&lt;/h2&gt;
&lt;p&gt;如果每个子图像都签名了，验证就可以在操作相应的硬件之前完成。&lt;br/&gt;只有签名正确的镜像会被实际安装。&lt;br/&gt;不过这样存在一个问题，子镜像没有跟sw-descrription文件中的发布描述绑定到一起。&lt;br/&gt;即使sw-description也做了签名，即使对sw-description进行了签名，攻击者也可以&lt;br/&gt;将签名子镜像们混合在一起，生成可以安装的新的复合镜像，因为所有子镜像都可通过验证。&lt;/p&gt;
&lt;h2 id=&quot;对sw-description进行签名并与哈希验证相结合&quot;&gt;对sw-description进行签名并与哈希验证相结合&lt;/h2&gt;
&lt;p&gt;为了避免所描述的缺点，SWUpdate将签名的sw-description与每个子镜像的哈希验证结合起来。&lt;br/&gt;这意味着只有经过验证的源代码生成的sw-description才能被安装程序接受。&lt;br/&gt;而sw-description包含每个子镜像的哈希值，可验证每个交付的子镜像确实属于本次发布。&lt;/p&gt;
&lt;h2 id=&quot;算法的选择&quot;&gt;算法的选择&lt;/h2&gt;
&lt;p&gt;可以通过menuconfig选择签名和验证sw-descrription文件的算法。&lt;br/&gt;目前，实现了以下机制:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RSA 公钥/私钥。 私钥属于编译系统，而公钥需要被安装到设备上。&lt;/li&gt;
&lt;li&gt;使用证书的CMS&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;密钥或证书使用&quot;-k&quot;参数传递给SWUpdate。&lt;/p&gt;
&lt;h2 id=&quot;生成密钥证书的工具&quot;&gt;生成密钥/证书的工具&lt;/h2&gt;
&lt;p&gt;openssl 工具用于生成密钥。这是OpenSSL项目的一部分。完整的文档可以 在&lt;br/&gt;&lt;a href=&quot;https://www.openssl.org/docs/manmaster/man1/openssl.html&quot;&gt;openSSL 网站&lt;/a&gt;&lt;br/&gt;上找到&lt;/p&gt;
&lt;h2 id=&quot;使用-rsa-pkcs1.5&quot;&gt;使用 RSA PKCS#1.5&lt;/h2&gt;
&lt;h3 id=&quot;生成私钥和公钥&quot;&gt;生成私钥和公钥&lt;/h3&gt;
&lt;p&gt;首先，需要生成私钥&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl genrsa -aes256 -out priv.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要一个密码。可以从文件中去获取这个密码 - 当然，&lt;br/&gt;这个密码文件必须保护好，防止被入侵。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl genrsa -aes256 -passout file:passout -out priv.pem&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用如下命令，从私钥导出公钥:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl rsa -in priv.pem -out public.pem -outform PEM -pubout&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&quot;public.pem&quot; 包含了适用于swupdate的格式的密钥。&lt;br/&gt;该文件可以通过-k参数在命令行传递给swupdate。&lt;/p&gt;
&lt;h3 id=&quot;如何使用rsa进行签名&quot;&gt;如何使用RSA进行签名&lt;/h3&gt;
&lt;p&gt;对镜像进行签名非常简单:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl dgst -sha256 -sign priv.pem sw-description &amp;gt; sw-description.sig&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;与证书和cms一起使用&quot;&gt;与证书和CMS一起使用&lt;/h2&gt;
&lt;h3 id=&quot;生成自签名证书&quot;&gt;生成自签名证书&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;openssl req -x509 -newkey rsa:4096 -nodes -keyout mycert.key.pem \
    -out mycert.cert.pem -subj &quot;/O=SWUpdate /CN=target&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有关参数的更多信息，请参阅文档。 &quot;mycert.key.pem&quot; 包含了私钥，用于签名。&lt;br/&gt;它 &lt;em&gt;不能&lt;/em&gt; 被部署到目标设备上。&lt;/p&gt;
&lt;p&gt;目标设备上必须安装有 &quot;mycert.cert.pem&quot; - 这将被SWUpdate用于完成校验。&lt;/p&gt;
&lt;h3 id=&quot;使用pki颁发的证书&quot;&gt;使用PKI颁发的证书&lt;/h3&gt;
&lt;p&gt;也可以使用PKI签发的代码签名证书。&lt;br/&gt;不过，SWUpdate是使用OpenSSL库来处理CMS签名的，该库要求在签名证书上设置以下属性:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;keyUsage=digitalSignature
extendedKeyUsage=emailProtection&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不能满足此要求，也可以完全禁用签名证书密钥检查。 这是由&lt;br/&gt;CONFIG_CMS_IGNORE_CERTIFICATE_PURPOSE 配置选项控制的。&lt;/p&gt;
&lt;h3 id=&quot;如何用cms签名&quot;&gt;如何用CMS签名&lt;/h3&gt;
&lt;p&gt;对镜像进行签名，跟前一种情况一样很简单:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;openssl cms -sign -in  sw-description -out sw-description.sig -signer mycert.cert.pem \
        -inkey mycert.key.pem -outform DER -nosmimecap -binary&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构建签名的swu镜像&quot;&gt;构建签名的SWU镜像&lt;/h2&gt;
&lt;p&gt;有两个文件，sw-description和它的签名sw-description.sig。&lt;br/&gt;签名文件必须紧跟在描述文件后面。&lt;/p&gt;
&lt;p&gt;sw-description中的每个图像必须具有 &quot;sha256&quot; 属性，&lt;br/&gt;即镜像的sha256校验和。如果有一个镜像不具有sha256属性，&lt;br/&gt;则整个复合镜像的的校验结果会是未通过，SWUpdate在开始安装之前会停止并报错。&lt;/p&gt;
&lt;p&gt;创建签名镜像的简单脚本可以是:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash

MODE=&quot;RSA&quot;
PRODUCT_NAME=&quot;myproduct&quot;
CONTAINER_VER=&quot;1.0&quot;
IMAGES=&quot;rootfs kernel&quot;
FILES=&quot;sw-description sw-description.sig $IMAGES&quot;

#if you use RSA
if [ x&quot;$MODE&quot; == &quot;xRSA&quot; ]; then
    openssl dgst -sha256 -sign priv.pem sw-description &amp;gt; sw-description.sig
else
    openssl cms -sign -in  sw-description -out sw-description.sig -signer mycert.cert.pem \
        -inkey mycert.key.pem -outform DER -nosmimecap -binary
fi
for i in $FILES;do
        echo $i;done | cpio -ov -H crc &amp;gt;  ${PRODUCT_NAME}_${CONTAINER_VER}.swu&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;签名镜像的sw-description示例&quot;&gt;签名镜像的sw-description示例&lt;/h2&gt;
&lt;p&gt;本例应用于Beaglebone，安装Yocto images:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;software =
{
        version = &quot;0.1.0&quot;;

        hardware-compatibility: [ &quot;revC&quot;];

        images: (
                {
                    filename = &quot;core-image-full-cmdline-beaglebone.ext3&quot;;
                    device = &quot;/dev/mmcblk0p2&quot;;
                    type = &quot;raw&quot;;
                    sha256 = &quot;43cdedde429d1ee379a7d91e3e7c4b0b9ff952543a91a55bb2221e5c72cb342b&quot;;
                }
        );
        scripts: (
                {
                    filename = &quot;test.lua&quot;;
                    type = &quot;lua&quot;;
                    sha256 = &quot;f53e0b271af4c2896f56a6adffa79a1ffa3e373c9ac96e00c4cfc577b9bea5f1&quot;;
                 }
        );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对签名镜像运行swupdate&quot;&gt;对签名镜像运行SWUpdate&lt;/h2&gt;
&lt;p&gt;验证是通过在SWUpdate的配置中设置CONFIG_SIGNED_IMAGES激活的。&lt;br/&gt;一旦激活，SWUpdate将始终检查复合图像。&lt;br/&gt;出于安全原因，不可能在运行时禁用检查。&lt;br/&gt;-k参数(公钥文件)是必须的，如果公钥没有传递，程序将终止运行。&lt;/p&gt;
&lt;p&gt;本文地址 &lt;a href=&quot;https://www.cnblogs.com/zqb-all/p/10296719.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/zqb-all/p/10296719.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;译自 swupdate 文档 &lt;a href=&quot;https://sbabic.github.io/swupdate/signed_images.html&quot; class=&quot;uri&quot;&gt;https://sbabic.github.io/swupdate/signed_images.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有更新会在github上发布 &lt;a href=&quot;https://zqb-all.github.io/swupdate/signed_images.html&quot; class=&quot;uri&quot;&gt;https://zqb-all.github.io/swupdate/signed_images.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 15:42:00 +0000</pubDate>
<dc:creator>zqb-all</dc:creator>
<og:description>从可信的来源更新镜像 ==================== 现在越来越重要的是，设备不仅要能安全地进行更新操作， 而且要能够验证发送的图像是否来自一个已知的源， 并且没有嵌入恶意软件。 为了实现这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zqb-all/p/10296719.html</dc:identifier>
</item>
<item>
<title>两小时入门Docker - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10296717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10296717.html</guid>
<description>&lt;h2&gt;Docker是什么?&lt;/h2&gt;
&lt;p&gt;Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。&lt;br/&gt;Docker 使用 Google 公司推出的 Go 语言 进行开发实现。&lt;br/&gt;docker是linux容器的一种封装，提供简单易用的容器使用接口。它是最流行的Linux容器解决方案。&lt;br/&gt;docker的接口相当简单，用户可以方便的创建、销毁容器。&lt;br/&gt;docker将应用程序与程序的依赖，打包在一个文件里面。运行这个文件就会生成一个虚拟容器。&lt;br/&gt;程序运行在虚拟容器里，如同在真实物理机上运行一样，有了docker，就不用担心环境问题了。&lt;/p&gt;
&lt;h2&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;web应用的自动化打包和发布&lt;/li&gt;
&lt;li&gt;自动化测试和持续集成、发布&lt;/li&gt;
&lt;li&gt;在服务型环境中部署和调整数据库或其他应用&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;区别&lt;/h2&gt;
&lt;p&gt;1，物理机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201901/1392643-20190120201550499-1654279132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二，虚拟机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201901/1392643-20190120201624596-1171496358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三，docker容器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392643/201901/1392643-20190120201703123-269664938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Docker的三大概念及优势&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;镜像　　image&lt;/li&gt;
&lt;li&gt;容器　　container&lt;/li&gt;
&lt;li&gt;仓库　　repository&lt;/li&gt;
&lt;/ol&gt;&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('4db2d003-f404-4e8b-9a17-72f39b281391')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_4db2d003-f404-4e8b-9a17-72f39b281391&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4db2d003-f404-4e8b-9a17-72f39b281391&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('4db2d003-f404-4e8b-9a17-72f39b281391',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4db2d003-f404-4e8b-9a17-72f39b281391&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 更高效的利用系统资源&lt;/span&gt;
&lt;span&gt;由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统 资源的利用率更高。
无论是应用执行速度、内存损耗或者文件存储速度，都要比传 统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运 行更多数量的应用。
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 更快速的启动时间&lt;/span&gt;
&lt;span&gt;传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接 运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启 动时间。大大的节约了开发、测试、部署的时间。
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3. 一致的运行环境&lt;/span&gt;
&lt;span&gt;开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环 境不一致，导致有些 bug 并未在开发过程中被发现。
而 Docker 的镜像提供了除内 核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码 在我机器上没问题啊” 这类问题。
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4. 持续交付和部署&lt;/span&gt;
&lt;span&gt;对开发和运维(DevOps)人员来说，最希望的就是一次创建或配置，可以在任意 地方正常运行。
使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员 可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系 统进行集成测试，
而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery&lt;/span&gt;/&lt;span&gt;Deployment) 系统进行自动部署。
而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环 境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5. 更轻松的迁移&lt;/span&gt;
&lt;span&gt;由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在 很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运 行结果是一致的。
因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一 个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;docker容器的优势&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;系统环境：docker最低支持centos7且在64位平台上，内核版本在3.10以上&lt;/p&gt;
&lt;p&gt;版本：社区版，企业版（包含了一些收费服务）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/#upgrade-docker-after-using-the-convenience-script&quot; target=&quot;_blank&quot;&gt;官方版安装教程（英文）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博主版安装教程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 安装docker&lt;/span&gt;
&lt;span&gt;yum install docker
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 启动docker &lt;/span&gt;
systemctl start/&lt;span&gt;status docker 
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看docker启动状态&lt;/span&gt;
docker version 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;配置加速器&lt;/h3&gt;
&lt;p&gt;简介：&lt;span class=&quot;external-link&quot;&gt;DaoCloud 加速器 是广受欢迎的 Docker 工具，解决了国内用户访问 Docker Hub 缓慢的问题。DaoCloud 加速器结合国内的 CDN 服务与协议层优化，成倍的提升了下载速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.daocloud.io/mirror#accelerator-doc&quot; target=&quot;_blank&quot;&gt;DaoCloud官网&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一条命令加速（记得重启docker）&lt;/span&gt;
curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://95822026.m.daocloud.io
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('5dd6baa8-332c-4440-86f6-c70a2c563c7f')&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_5dd6baa8-332c-4440-86f6-c70a2c563c7f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5dd6baa8-332c-4440-86f6-c70a2c563c7f&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('5dd6baa8-332c-4440-86f6-c70a2c563c7f',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5dd6baa8-332c-4440-86f6-c70a2c563c7f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Usage:
docker [OPTIONS] COMMAND [arg...]

       docker daemon [ &lt;/span&gt;--help |&lt;span&gt; ... ]

       docker [ &lt;/span&gt;--help | -v | --&lt;span&gt;version ]

 

A
self&lt;/span&gt;-sufficient runtime &lt;span&gt;for&lt;/span&gt;&lt;span&gt; containers.

 

Options:

 

  &lt;/span&gt;--config=~/.docker              Location of client config files  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;客户端配置文件的位置&lt;/span&gt;

  -D, --debug=false               Enable debug mode  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;启用Debug调试模式&lt;/span&gt;

  -H, --host=[]                   Daemon socket(s) to connect to  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;守护进程的套接字（Socket）连接&lt;/span&gt;

  -h, --help=false                Print usage  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印使用&lt;/span&gt;

  -l, --log-level=info            Set the logging level  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置日志级别&lt;/span&gt;

  --tls=false                     Use TLS; implied by--tlsverify  &lt;span&gt;#
&lt;/span&gt;
  --tlscacert=~/.docker/ca.pem    Trust certs signed only by this CA  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;信任证书签名CA&lt;/span&gt;

  --tlscert=~/.docker/cert.pem    Path to TLS certificate file  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;TLS证书文件路径&lt;/span&gt;

  --tlskey=~/.docker/key.pem      Path to TLS key file  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;TLS密钥文件路径&lt;/span&gt;

  --tlsverify=false               Use TLS &lt;span&gt;and&lt;/span&gt; verify the remote  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用TLS验证远程&lt;/span&gt;

  -v, --version=false             Print version information &lt;span&gt;and&lt;/span&gt; quit  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;打印版本信息并退出&lt;/span&gt;
&lt;span&gt;
 

Commands:

    attach    Attach to a running container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;当前shell下attach连接指定运行镜像&lt;/span&gt;
&lt;span&gt;
    build     Build an image &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; a Dockerfile  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过Dockerfile定制镜像&lt;/span&gt;
&lt;span&gt;
    commit    Create a new image &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; a container&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s changes  #提交当前容器为新的镜像&lt;/span&gt;
&lt;span&gt;
    cp    Copy files&lt;/span&gt;/folders &lt;span&gt;from&lt;/span&gt; a container to a HOSTDIR &lt;span&gt;or&lt;/span&gt; to STDOUT  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从容器中拷贝指定文件或者目录到宿主机中&lt;/span&gt;
&lt;span&gt;
    create    Create a new container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个新的容器，同run 但不启动容器&lt;/span&gt;
&lt;span&gt;
    diff    Inspect changes on a container&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s filesystem  #查看docker容器变化&lt;/span&gt;
&lt;span&gt;
    events    Get real time events &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; the server&lt;span&gt;#&lt;/span&gt;&lt;span&gt;从docker服务获取容器实时事件&lt;/span&gt;

    &lt;span&gt;exec&lt;/span&gt;    Run a command &lt;span&gt;in&lt;/span&gt; a running container&lt;span&gt;#&lt;/span&gt;&lt;span&gt;在已存在的容器上运行命令&lt;/span&gt;
&lt;span&gt;
    export    Export a container&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s filesystem as a tar archive  #导出容器的内容流作为一个tar归档文件(对应import)&lt;/span&gt;
&lt;span&gt;
    history    Show the history of an image  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;展示一个镜像形成历史&lt;/span&gt;
&lt;span&gt;
    images    List images  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;列出系统当前镜像&lt;/span&gt;

    &lt;span&gt;import&lt;/span&gt;    Import the contents &lt;span&gt;from&lt;/span&gt; a tarball to create a filesystem image  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从tar包中的内容创建一个新的文件系统映像(对应export)&lt;/span&gt;
&lt;span&gt;
    info    Display system&lt;/span&gt;-wide information  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;显示系统相关信息&lt;/span&gt;
&lt;span&gt;
    inspect    Return low&lt;/span&gt;-level information on a container &lt;span&gt;or&lt;/span&gt; image  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看容器详细信息&lt;/span&gt;
&lt;span&gt;
    kill    Kill a running container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;kill指定docker容器&lt;/span&gt;
&lt;span&gt;
    load    Load an image &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; a tar archive &lt;span&gt;or&lt;/span&gt; STDIN  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从一个tar包中加载一个镜像(对应save)&lt;/span&gt;
&lt;span&gt;
    login    Register &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; log &lt;span&gt;in&lt;/span&gt; to a Docker registry&lt;span&gt;#&lt;/span&gt;&lt;span&gt;注册或者登陆一个docker源服务器&lt;/span&gt;
&lt;span&gt;
    logout    Log out &lt;/span&gt;&lt;span&gt;from&lt;/span&gt; a Docker registry  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从当前Docker registry退出&lt;/span&gt;
&lt;span&gt;
    logs    Fetch the logs of a container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出当前容器日志信息&lt;/span&gt;
&lt;span&gt;
    pause    Pause all processes within a container&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;暂停容器&lt;/span&gt;
&lt;span&gt;
    port    List port mappings &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; a specific mapping &lt;span&gt;for&lt;/span&gt; the CONTAINER  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看映射端口对应的容器内部源端口&lt;/span&gt;
&lt;span&gt;
    ps    List containers  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;列出容器列表&lt;/span&gt;
&lt;span&gt;
    pull    Pull an image &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; a repository &lt;span&gt;from&lt;/span&gt; a registry  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;从docker镜像源服务器拉取指定镜像或者库镜像&lt;/span&gt;
&lt;span&gt;
    push    Push an image &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; a repository to a registry  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;推送指定镜像或者库镜像至docker源服务器&lt;/span&gt;
&lt;span&gt;
    rename    Rename a container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重命名容器&lt;/span&gt;
&lt;span&gt;
    restart    Restart a running container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重启运行的容器&lt;/span&gt;
&lt;span&gt;
    rm    Remove one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more containers  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;移除一个或者多个容器&lt;/span&gt;
&lt;span&gt;
    rmi    Remove one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more images  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;移除一个或多个镜像(无容器使用该镜像才可以删除，否则需要删除相关容器才可以继续或者-f强制删除)&lt;/span&gt;
&lt;span&gt;
    run    Run a command &lt;/span&gt;&lt;span&gt;in&lt;/span&gt; a new container  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个新的容器并运行一个命令&lt;/span&gt;
&lt;span&gt;
    save    Save an image(s) to a tar archive&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;保存一个镜像为一个tar包(对应load)&lt;/span&gt;
&lt;span&gt;
    search    Search the Docker Hub &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; images  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;在docker&lt;/span&gt;
&lt;span&gt;hub中搜索镜像

    start    Start one &lt;/span&gt;&lt;span&gt;or&lt;/span&gt; more stopped containers&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动容器&lt;/span&gt;
&lt;span&gt;
    stats    Display a live stream of container(s) resource usage statistics  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;统计容器使用资源&lt;/span&gt;
&lt;span&gt;
    stop    Stop a running container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;停止容器&lt;/span&gt;
&lt;span&gt;
    tag         Tag an image into a repository  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;给源中镜像打标签&lt;/span&gt;
&lt;span&gt;
    top       Display the running processes of a container &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看容器中运行的进程信息&lt;/span&gt;
&lt;span&gt;
    unpause    Unpause all processes within a container  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;取消暂停容器&lt;/span&gt;
&lt;span&gt;
    version    Show the Docker version information&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;查看容器版本号&lt;/span&gt;
&lt;span&gt;
    wait         Block until a container stops, then &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; its exit code  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;截取容器停止时的退出状态值&lt;/span&gt;
&lt;span&gt;
 

Run &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;docker COMMAND --help&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; more information on a command.  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行docker命令在帮助可以获取更多信息&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;docker --help（中文注解）&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker search  hello-docker  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 搜索hello-docker的镜像&lt;/span&gt;
docker search centos &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 搜索centos镜像&lt;/span&gt;
docker pull hello-docker &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取centos镜像&lt;/span&gt;
docker run  hello-world   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;运行一个docker镜像，产生一个容器实例（也可以通过镜像id前三位运行）&lt;/span&gt;
docker image ls  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看本地所有镜像&lt;/span&gt;
docker images  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看docker镜像&lt;/span&gt;
docker image rmi hello-docker &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 删除centos镜像&lt;/span&gt;
docker ps  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;列出正在运行的容器（如果创建容器中没有进程正在运行，容器就会立即停止）&lt;/span&gt;
docker ps -a  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列出所有运行过的容器记录&lt;/span&gt;
docker save centos &amp;gt; /opt/centos.tar.gz  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导出docker镜像至本地&lt;/span&gt;
docker load &amp;lt; /opt/centos.tar.gz   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;导入本地镜像到docker镜像库&lt;/span&gt;
docker stop  `docker ps -aq`  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 停止所有正在运行的容器&lt;/span&gt;
docker  rm `docker ps -aq`    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一次性删除所有容器记录&lt;/span&gt;
docker rmi  `docker images -aq`   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一次性删除所有本地的镜像记录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;启动容器的两种方式&lt;/h2&gt;
&lt;p&gt;容器是运行应用程序的，所以必须得先有一个操作系统为基础&lt;br/&gt;&lt;strong&gt;1. 基于镜像新建一个容器并启动&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 后台运行一个docker&lt;/span&gt;
docker run -d centos /bin/sh -c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;while true;do echo 正在运行; sleep 1;done&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -d  后台运行容器&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; /bin/sh  指定使用centos的bash解释器&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -c 运行一段shell命令&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &quot;while true;do echo 正在运行; sleep 1;done&quot;  在linux后台，每秒中打印一次正在运行&lt;/span&gt;
docker ps  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查容器进程&lt;/span&gt;
docker  logs  -f  容器id/名称  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不间断打印容器的日志信息 &lt;/span&gt;
docker stop centos  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 停止容器&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 启动一个bash终端,允许用户进行交互&lt;/span&gt;
docker run --name mydocker -it centos /bin/&lt;span&gt;bash  
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; --name  给容器定义一个名称&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -i  让容器的标准输入保持打开&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -t 让Docker分配一个伪终端,并绑定到容器的标准输入上&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; /bin/bash 指定docker容器，用shell解释器交互&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当利用docker run来创建容器时，Docker在后台运行的步骤如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e1c74e51-f9f5-4cff-ace3-99a0d66971f0')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_e1c74e51-f9f5-4cff-ace3-99a0d66971f0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e1c74e51-f9f5-4cff-ace3-99a0d66971f0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e1c74e51-f9f5-4cff-ace3-99a0d66971f0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e1c74e51-f9f5-4cff-ace3-99a0d66971f0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1. 检查本地是否存在指定的镜像，不存在就从公有仓库下载&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2. 利用镜像创建并启动一个容器&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3. 分配一个文件系统，并在只读的镜像层外面挂在一层可读写层&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4. 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5. 从地址池配置一个ip地址给容器&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6. 执行用户指定的应用程序&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7. 执行完毕后容器被终止&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;运行步骤&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2. 将一个终止状态(stopped)的容器重新启动&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@localhost ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; docker ps -a  # 先查询记录&lt;/span&gt;
&lt;span&gt;CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                        PORTS                    NAMES
ee92fcf6f32d        centos              &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;              4 days ago          Exited (137) 3&lt;span&gt; days ago                                kickass_raman

[root@localhost &lt;/span&gt;~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; docker start ee9  # 再启动这个容器&lt;/span&gt;
&lt;span&gt;ee9

[root@localhost &lt;/span&gt;~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; docker exec -it  ee9 /bin/bash  # 进入容器交互式界面&lt;/span&gt;
[root@ee92fcf6f32d /]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;   # 注意看用户名，已经变成容器用户名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;提交创建自定义镜像&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.我们进入交互式的centos容器中，发现没有vim命令&lt;/span&gt;
    docker run -&lt;span&gt;it centos
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.在当前容器中，安装一个vim&lt;/span&gt;
    yum install -&lt;span&gt;y vim
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.安装好vim之后，exit退出容器&lt;/span&gt;
&lt;span&gt;    exit
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.查看刚才安装好vim的容器记录&lt;/span&gt;
    docker container ls -&lt;span&gt;a
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.提交这个容器，创建新的image&lt;/span&gt;
    docker commit 059fdea031ba chaoyu/centos-&lt;span&gt;vim
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.查看镜像文件&lt;/span&gt;
&lt;span&gt;    docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
chaoyu&lt;/span&gt;/centos-vim   latest              fd2685ae25fe        5 minutes ago       348MB
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;外部访问容器&lt;/h2&gt;
&lt;p&gt;容器中可以运行网络应用，但是要让外部也可以访问这些应用，可以通过-p或-P参数指定端口映射。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
docker run -d -P training/&lt;span&gt;webapp python app.py
  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; -P 参数会随机映射端口到容器开放的网络端口&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 检查映射的端口&lt;/span&gt;
docker ps -&lt;span&gt;l
CONTAINER ID        IMAGE               COMMAND             CREATED            STATUS              PORTS                     NAMES
cfd632821d7a        training&lt;/span&gt;/webapp     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python app.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;     21 seconds ago      Up 20 seconds       0.0.0.0:32768-&amp;gt;5000/&lt;span&gt;tcp   brave_fermi
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;宿主机ip:32768 映射容器的5000端口&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 查看容器日志信息&lt;/span&gt;
docker logs -f cfd  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; #不间断显示log&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 也可以通过-p参数指定映射端口&lt;/span&gt;
docker run -d -p 9000:5000 training/webapp python app.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打开浏览器访问服务器的9000端口， 内容显示 Hello world！表示正常启动&lt;/p&gt;
&lt;p&gt;(如果访问失败的话，检查自己的防火墙，以及云服务器的安全组)&lt;/p&gt;

&lt;p&gt;镜像是容器的基础，每次执行docker run的时候都会指定哪个镜像作为容器运行的基础。我们之前的例子都是使用来自docker hub的镜像，直接使用这些镜像只能满足一定的需求，当镜像无法满足我们的需求时，就得自定制这些镜像。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 镜像的定制就是定制每一层所添加的配置、文件。如果可以吧每一层修改、安装、构建、操作的命令都写入到一个脚本，用脚本来构建、定制镜像，这个脚本就是dockerfile。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令 构建一层，因此每一条指令的内容，就是描述该层应当如何构建。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('3a37a7d2-e0c8-4721-b67e-8f23b9919ba0')&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_3a37a7d2-e0c8-4721-b67e-8f23b9919ba0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3a37a7d2-e0c8-4721-b67e-8f23b9919ba0&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('3a37a7d2-e0c8-4721-b67e-8f23b9919ba0',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3a37a7d2-e0c8-4721-b67e-8f23b9919ba0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
FROM scratch &lt;span&gt;#&lt;/span&gt;&lt;span&gt;制作base image 基础镜像，尽量使用官方的image作为base image&lt;/span&gt;
FROM centos &lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用base image&lt;/span&gt;
FROM ubuntu:14.04 &lt;span&gt;#&lt;/span&gt;&lt;span&gt;带有tag的base image&lt;/span&gt;
&lt;span&gt;
LABEL version&lt;/span&gt;=“1.0” &lt;span&gt;#&lt;/span&gt;&lt;span&gt;容器元信息，帮助信息，Metadata，类似于代码注释&lt;/span&gt;
LABEL maintainer=“yc_uuu@163.com&lt;span&gt;&quot;
&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对于复杂的RUN命令，避免无用的分层，多条命令用反斜线换行，合成一条命令！&lt;/span&gt;
RUN yum update &amp;amp;&amp;amp; yum install -&lt;span&gt;y vim \
    Python&lt;/span&gt;-dev &lt;span&gt;#&lt;/span&gt;&lt;span&gt;反斜线换行&lt;/span&gt;
RUN /bin/bash -c &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;source $HOME/.bashrc;echo $HOME”&lt;/span&gt;
&lt;span&gt;
WORKDIR &lt;/span&gt;/root &lt;span&gt;#&lt;/span&gt;&lt;span&gt;相当于linux的cd命令，改变目录，尽量使用绝对路径！！！不要用RUN cd&lt;/span&gt;
WORKDIR /test &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果没有就自动创建&lt;/span&gt;
WORKDIR demo &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 再进入demo文件夹&lt;/span&gt;
RUN pwd     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 打印结果应该是/test/demo&lt;/span&gt;
&lt;span&gt;
ADD &lt;/span&gt;&lt;span&gt;and&lt;/span&gt;&lt;span&gt; COPY 
ADD hello &lt;/span&gt;/  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 把本地文件添加到镜像中，吧本地的hello可执行文件拷贝到镜像的/目录&lt;/span&gt;
ADD test.tar.gz /  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 添加到根目录并解压&lt;/span&gt;
&lt;span&gt;
WORKDIR &lt;/span&gt;/&lt;span&gt;root
ADD hello test&lt;/span&gt;/  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进入/root/ 添加hello可执行命令到test目录下，也就是/root/test/hello 一个绝对路径&lt;/span&gt;
COPY hello test/  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 等同于上述ADD效果&lt;/span&gt;
&lt;span&gt;
ADD与COPY
   &lt;/span&gt;-&lt;span&gt; 优先使用COPY命令
    &lt;/span&gt;-&lt;span&gt;ADD除了COPY功能还有解压功能
添加远程文件&lt;/span&gt;/&lt;span&gt;目录使用curl或wget

ENV &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 环境变量，尽可能使用ENV增加可维护性&lt;/span&gt;
ENV MYSQL_VERSION 5.6 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置一个mysql常量&lt;/span&gt;
RUN yum install -y mysql-server=“${MYSQL_VERSION}” 
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;参数详解&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('60016d61-f52d-47a7-ab7b-fc59441f4e38')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_60016d61-f52d-47a7-ab7b-fc59441f4e38&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_60016d61-f52d-47a7-ab7b-fc59441f4e38&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('60016d61-f52d-47a7-ab7b-fc59441f4e38',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_60016d61-f52d-47a7-ab7b-fc59441f4e38&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
VOLUME &lt;span&gt;and&lt;/span&gt;&lt;span&gt; EXPOSE 
存储和网络

RUN &lt;/span&gt;&lt;span&gt;and&lt;/span&gt; CMD &lt;span&gt;and&lt;/span&gt;&lt;span&gt; ENTRYPOINT
RUN：执行命令并创建新的Image Layer
CMD：设置容器启动后默认执行的命令和参数
ENTRYPOINT：设置容器启动时运行的命令

Shell格式和Exec格式
RUN yum install &lt;/span&gt;-&lt;span&gt;y vim
CMD echo ”hello docker”
ENTRYPOINT echo “hello docker”

Exec格式
RUN [“apt&lt;/span&gt;-get”,”install”,”-&lt;span&gt;y”,”vim”]
CMD [“&lt;/span&gt;/bin/&lt;span&gt;echo”,”hello docker”]
ENTRYPOINT [“&lt;/span&gt;/bin/&lt;span&gt;echo”,”hello docker”]


通过shell格式去运行命令，会读取$name指令，而exec格式是仅仅的执行一个命令，而不是shell指令
cat Dockerfile
    FROM centos
    ENV name Docker
    ENTRYPOINT [“&lt;/span&gt;/bin/echo”,”hello $name”]&lt;span&gt;#&lt;/span&gt;&lt;span&gt;这个仅仅是执行echo命令，读取不了shell变量&lt;/span&gt;
    ENTRYPOINT  [“/bin/bash”,”-c”,”echo hello $name&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
&lt;span&gt;
CMD
容器启动时默认执行的命令
如果docker run指定了其他命令(docker run &lt;/span&gt;-it [image] /bin/&lt;span&gt;bash )，CMD命令被忽略
如果定义多个CMD，只有最后一个执行

ENTRYPOINT
让容器以应用程序或服务形式运行
不会被忽略，一定会执行
最佳实践：写一个shell脚本作为entrypoint
COPY docker&lt;/span&gt;-entrypoint.sh /usr/local/&lt;span&gt;bin
ENTRYPOINT [“docker&lt;/span&gt;-&lt;span&gt;entrypoint.sh]
EXPOSE &lt;/span&gt;27017&lt;span&gt;
CMD [“mongod”]

[root@master home]&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; more Dockerfile&lt;/span&gt;
&lt;span&gt;FROm centos
ENV name Docker
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;CMD [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello $name&quot;]&lt;/span&gt;
ENTRYPOINT [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/bin/bash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-c&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;echo hello $name”]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;进阶知识(了解)&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;1，docker hub共有镜像发布&lt;/h2&gt;
&lt;p&gt;docker提供了一个类似于github的仓库docker hub,&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/&quot; target=&quot;_blank&quot;&gt;官方网站&lt;/a&gt;（需注册使用）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注册docker id后，在linux中登录dockerhub&lt;/span&gt;
&lt;span&gt;    docker login

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意要保证image的tag是账户名，如果镜像名字不对，需要改一下tag&lt;/span&gt;
    docker tag chaoyu/centos-vim peng104/centos-&lt;span&gt;vim
&lt;/span&gt;&lt;span&gt;    #&lt;/span&gt;&lt;span&gt; 语法是：  docker tag   仓库名   peng104/仓库名&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 推送docker image到dockerhub&lt;/span&gt;
    docker push peng104/centps-cmd-&lt;span&gt;exec&lt;/span&gt;&lt;span&gt;:latest

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去dockerhub中检查镜像&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 先删除本地镜像，然后再测试下载pull 镜像文件&lt;/span&gt;
    docker pull peng104/centos-entrypoint-&lt;span&gt;exec&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2，私有仓库&lt;/h2&gt;
&lt;p&gt;docker hub 是公开的，其他人也是可以下载，并不安全，因此还可以使用docker registry官方提供的私有仓库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yeasy.gitbooks.io/docker_practice/repository/registry.html&quot; target=&quot;_blank&quot;&gt;用法详解点我&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.下载一个docker官方私有仓库镜像&lt;/span&gt;
&lt;span&gt;    docker pull registry
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.运行一个docker私有容器仓库&lt;/span&gt;
docker run -d -p 5000:5000 -v /opt/data/registry:/var/lib/&lt;span&gt;registry  registry
    &lt;/span&gt;-&lt;span&gt;d 后台运行 
    &lt;/span&gt;-&lt;span&gt;p  端口映射 宿主机的5000:容器内的5000
    &lt;/span&gt;-v  数据卷挂载  宿主机的 /opt/data/registry :/var/lib/&lt;span&gt;registry 
    registry  镜像名
    &lt;/span&gt;/var/lib/&lt;span&gt;registry  存放私有仓库位置
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 3.修改docker的配置文件，让他支持http方式，上传私有镜像&lt;/span&gt;
    vim /etc/docker/&lt;span&gt;daemon.json 
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入如下内容&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;registry-mirrors&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://f1361db2.m.daocloud.io&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;insecure-registries&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.11.37:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
    }
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.修改docker的服务配置文件&lt;/span&gt;
    vim /lib/systemd/system/&lt;span&gt;docker.service
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 找到[service]这一代码区域块，写入如下参数&lt;/span&gt;
&lt;span&gt;    [Service]
    EnvironmentFile&lt;/span&gt;=-/etc/docker/&lt;span&gt;daemon.json
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.重新加载docker服务&lt;/span&gt;
    systemctl daemon-&lt;span&gt;reload
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.重启docker服务&lt;/span&gt;
&lt;span&gt;    systemctl restart docker
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意:重启docker服务，所有的容器都会挂掉&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7.修改本地镜像的tag标记，往自己的私有仓库推送&lt;/span&gt;
    docker tag docker.io/peng104/hello-world-docker 192.168.11.37:5000/peng-&lt;span&gt;hello
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 浏览器访问http://192.168.119.10:5000/v2/_catalog查看仓库&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 8.下载私有仓库的镜像&lt;/span&gt;
    docker pull 192.168.11.37:5000/peng-hello
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;编写dockerfile，构建自己的镜像，运行flask程序。&lt;/p&gt;
&lt;p&gt;确保app.py和dockerfile在同一个目录！&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.准备好app.py的flask程序&lt;/span&gt;
    [root@localhost ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cat app.py&lt;/span&gt;
    &lt;span&gt;from&lt;/span&gt; flask &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Flask
    app&lt;/span&gt;=Flask(&lt;span&gt;__name__&lt;/span&gt;&lt;span&gt;)
    @app.route(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; hello():
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello docker&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        app.run(host&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0.0.0.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,port=8080&lt;span&gt;)
    [root@master home]&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; ls&lt;/span&gt;
&lt;span&gt;    app.py  Dockerfile

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.编写dockerfile&lt;/span&gt;
    [root@localhost ~]&lt;span&gt;#&lt;/span&gt;&lt;span&gt; cat Dockerfile&lt;/span&gt;
    FROM python:2.7&lt;span&gt;
    LABEL maintainer&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;温而新&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    RUN pip install flask
    COPY app.py &lt;/span&gt;/app/&lt;span&gt;
    WORKDIR &lt;/span&gt;/&lt;span&gt;app
    EXPOSE &lt;/span&gt;8080&lt;span&gt;
    CMD [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 3.构建镜像image,找到当前目录的Dockerfile，开始构建&lt;/span&gt;
    docker build -t peng104/flask-hello-&lt;span&gt;docker .

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 4.查看创建好的images&lt;/span&gt;
&lt;span&gt;    docker image ls

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 5.启动此flask-hello-docker容器，映射一个端口供外部访问&lt;/span&gt;
    docker run -d -p 8080:8080 peng104/flask-hello-&lt;span&gt;docker

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 6.检查运行的容器&lt;/span&gt;
&lt;span&gt;    docker container ls

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 7.推送这个镜像到私有仓库&lt;/span&gt;
    docker tag  peng104/flask-hello-docker   192.168.11.37:5000/peng-&lt;span&gt;flaskweb
    docker push &lt;/span&gt;192.168.11.37:5000/peng-flaskweb
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 20 Jan 2019 15:38:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>引入 Docker是什么? Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，于 2013 年 3 月以 Apache 2.0 授权协议</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10296717.html</dc:identifier>
</item>
<item>
<title>EF6学习笔记十五：调试EF框架源码 - 张四海</title>
<link>http://www.cnblogs.com/jinshan-go/p/10296665.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinshan-go/p/10296665.html</guid>
<description>&lt;h3&gt;&lt;span&gt;要专业系统地学习EF推荐《你必须掌握的Entity Framework 6.x与Core 2.0》。这本书作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/CreateMyself/&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;今天继续学习EF，但是看来看去，实在是感觉不爽啊，因为你不知道源码里面到底是什么回事，我只能去猜去想象，要是有源码给我看几个单词也好啊。&lt;/p&gt;
&lt;p&gt;百度吧。还是找到几篇博客，看上去不是很难弄。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/michaellfx/p/3806857.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/michaellfx/p/3806857.html&lt;/a&gt;&lt;/p&gt;


&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120224201840-705678298.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;创建自己的控制台项目，引入两个程序集，并且控制台程序添加对这两个程序集的引用， 把这两个程序集的强签名去掉，重新生成解决方案&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120224329499-1137382309.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120225220939-1824444693.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里要注意，我们只引入了EntityFramework和EntityFramework.SqlServer,如果我们想要用数据迁移是不行的，可能要还要引入其他的程序集，我做了，没有成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们只能自己手动地去创建数据，并且数据模型的配置也要写，并且你要保证你的配置和手写的数据库是完全匹配的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你可以在另一个项目中把数据模型、配置都写好，测试没问题，拿到这个项目中复制。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我的三个model&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_b01bf791-48e3-40d3-b1d9-f141cff7af60&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_b01bf791-48e3-40d3-b1d9-f141cff7af60&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_b01bf791-48e3-40d3-b1d9-f141cff7af60&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  基类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseEntity()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; Guid.NewGuid().ToString();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.AddTime =&lt;span&gt; DateTime.Now;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime AddTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  产品类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Order : BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; OrderNO { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Description { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; ICollection&amp;lt;Product&amp;gt; Products { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  产品类&lt;/span&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product : BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Unit { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FK_OrderId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Order Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;配置如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_7132b832-d74b-4e4a-baa4-64c4f09f4153&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7132b832-d74b-4e4a-baa4-64c4f09f4153&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7132b832-d74b-4e4a-baa4-64c4f09f4153&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EFDbContext:DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EFDbContext():&lt;span&gt;base&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name=ConnectionStr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        {

        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Order&amp;gt; Orders { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Product&amp;gt; Products { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity&lt;/span&gt;&amp;lt;Order&amp;gt;().ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tb_Orders&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .HasKey(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Id)
                .HasMany(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Products)
                .WithRequired(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Order)
                .HasForeignKey(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.FK_OrderId);

            modelBuilder.Entity&lt;/span&gt;&amp;lt;Product&amp;gt;().ToTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tb_Products&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                .HasKey(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x.Id);

            modelBuilder.Conventions.Remove&lt;/span&gt;&amp;lt;PluralizingTableNameConvention&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnModelCreating(modelBuilder);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;查询数据，打印看看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img id=&quot;code_img_closed_6a52ddc9-d5b9-458f-ae30-5adf51abd512&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_6a52ddc9-d5b9-458f-ae30-5adf51abd512&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_6a52ddc9-d5b9-458f-ae30-5adf51abd512&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  忽略循环引用&lt;/span&gt;
            JsonSerializerSettings &lt;span&gt;set&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonSerializerSettings();
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;.ReferenceLoopHandling =&lt;span&gt; ReferenceLoopHandling.Ignore;

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (EFDbContext2 ctx = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFDbContext2())
            {
                ctx.Database.Log &lt;/span&gt;=&lt;span&gt; Console.WriteLine;
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; ctx.Products.ToList();
                Console.WriteLine(JsonConvert.SerializeObject(res,&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;));
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;报错，找不到程序集&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120225515440-128019734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把源码中的这里改成null&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120225717860-421302589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;app.config配置文件中也改一下,pulicKeyToken改成null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img id=&quot;code_img_closed_1624e3c2-fe5d-47e9-96a0-e3716f4a0964&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1624e3c2-fe5d-47e9-96a0-e3716f4a0964&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1624e3c2-fe5d-47e9-96a0-e3716f4a0964&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;!-- For more information on Entity Framework configuration, visit http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;go.microsoft.com/fwlink/?LinkID=237468 --&amp;gt;&lt;/span&gt;
    &amp;lt;section name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;entityFramework&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; requirePermission=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
  &amp;lt;/configSections&amp;gt;
  &amp;lt;connectionStrings&amp;gt;
    &amp;lt;add name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionStr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; connectionString=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Data Source=LAPTOP-G81QJ856\SQLEXPRESS;Initial Catalog=_201901202.EFDbContext;Integrated Security=True&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; providerName=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.Data.SqlClient&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/add&amp;gt;
  &amp;lt;/connectionStrings&amp;gt;
    &amp;lt;startup&amp;gt; 
        &amp;lt;supportedRuntime version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;v4.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; sku=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.NETFramework,Version=v4.6.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; /&amp;gt;
    &amp;lt;/startup&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 然后打印数据，出来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120225940304-1342203888.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里要注意一个问题，EFDbContext中要一次性写好，不能运行了项目，再对EFDbContext进行改动，这样他会说你的文件改动要执行数据迁移，更新数据库。但是我们刚刚就强调了，只是引入了两个程序集，无法提供数据迁移的功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120230218188-239129525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我开始就是这样，EFDbContext中的配置没有写，可能是EF无法匹配到数据库，一直进行它的默认连接，即使我给他指定了连接字符串（我要求他连接到_201901202.EFDbContext这个数据库，但是我的配置和数据不匹配，他就连接默认数据库：命名空间+上下文类名）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120230446815-658022957.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我改好EFDbContext,以为这下终于万无一失，但是他说&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-1&quot;&gt;支持“EFDbContext”上下文的模型发生了更改。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;考虑使用代码优先迁移来更新数据库。可是我迁移用不了啊！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120230733938-384588883.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我又写了一个EFDbContext2,把代码复制过来，这样终于行了，连接到指定的数据源了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/819807/201901/819807-20190120231023508-211198470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 15:20:00 +0000</pubDate>
<dc:creator>张四海</dc:creator>
<og:description>要专业系统地学习EF推荐《你必须掌握的Entity Framework 6.x与Core 2.0》。这本书作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/Creat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinshan-go/p/10296665.html</dc:identifier>
</item>
</channel>
</rss>