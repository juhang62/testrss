<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>消息中间件ActiveMQ使用详解 - 追梦1819</title>
<link>http://www.cnblogs.com/yanfei1819/p/10615605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanfei1819/p/10615605.html</guid>
<description>&lt;h2 id=&quot;一消息中间件的介绍&quot;&gt;一、消息中间件的介绍&lt;/h2&gt;
&lt;h3 id=&quot;介绍&quot;&gt;介绍&lt;/h3&gt;
&lt;p&gt;​ &lt;strong&gt;消息队列&lt;/strong&gt; 是指利用 &lt;strong&gt;高效可靠&lt;/strong&gt; 的 &lt;strong&gt;消息传递机制&lt;/strong&gt; 进行与平台无关的 &lt;strong&gt;数据交流&lt;/strong&gt;，并基于 &lt;strong&gt;数据通信&lt;/strong&gt; 来进行分布式系统的集成。&lt;/p&gt;
&lt;h3 id=&quot;特点作用&quot;&gt;特点(作用)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;应用解耦&lt;/li&gt;
&lt;li&gt;异步通信&lt;/li&gt;
&lt;li&gt;流量削峰&lt;/li&gt;
&lt;li&gt;(海量)日志处理&lt;/li&gt;
&lt;li&gt;消息通讯&lt;/li&gt;
&lt;li&gt;…...&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;应用场景&quot;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;根据消息队列的特点，可以衍生出很多场景，或者说很多场景都能用到。下面举几个例子：&lt;/p&gt;
&lt;p&gt;1）异步通信&lt;/p&gt;
&lt;p&gt;​ 注册时的短信、邮件通知，减少响应时间；&lt;/p&gt;
&lt;p&gt;2）应用解耦&lt;/p&gt;
&lt;p&gt;​ 信息发送者和消息接受者无需耦合，比如调用第三方；&lt;/p&gt;
&lt;p&gt;3）流量削峰&lt;/p&gt;
&lt;p&gt;​ 例如秒杀系统；&lt;/p&gt;
&lt;h2 id=&quot;二消息中间件的对比&quot;&gt;二、消息中间件的对比&lt;/h2&gt;
&lt;h3 id=&quot;activemq&quot;&gt;1.ActiveMQ&lt;/h3&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://link.juejin.im?target=http%3A%2F%2Factivemq.apache.org%2F&quot;&gt;activemq.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现,尽管JMS规范出台已经是很久的事情了,但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持来自Java，C，C ++，C＃，Ruby，Perl，Python，PHP的各种跨语言客户端和协议&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;完全支持JMS客户端和Message Broker中的企业集成模式&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持许多高级功能，如消息组，虚拟目标，通配符和复合目标&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;完全支持&lt;strong&gt;JMS 1.1&lt;/strong&gt;和J2EE 1.4，支持瞬态，持久，事务和XA消息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;Spring支持&lt;/strong&gt;，以便ActiveMQ可以轻松嵌入到Spring应用程序中，并使用Spring的XML配置机制进行配置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;专为高性能集群，客户端 - 服务器，基于对等的通信而设计&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CXF和Axis支持，以便ActiveMQ可以轻松地放入这些Web服务堆栈中以提供可靠的消息传递&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以用作内存JMS提供程序，非常适合单元测试JMS&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持可插拔传输协议，例如in-VM，TCP，SSL，NIO，UDP，多播，JGroups和JXTA传输&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用JDBC和高性能日志支持非常快速的持久性&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;rabbitmq&quot;&gt;2.RabbitMQ&lt;/h3&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://link.juejin.im?target=http%3A%2F%2Fwww.rabbitmq.com%2F&quot;&gt;www.rabbitmq.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。RabbitMQ轻巧且易于部署在云端。 它支持多种消息传递协议。 RabbitMQ可以部署在分布式和联合配置中，以满足高规模，高可用性需求。RabbitMQ可运行在许多操作系统和云环境中，并为大多数流行语言提供广泛的开发工具。（来自官网翻译）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;AMQP （Advanced MessageQueue）&lt;/strong&gt;：高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。&lt;/p&gt;
&lt;p&gt;RabbitMQ最初广泛应用于金融行业，根据官网描述，它具有如下特点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;异步消息传递：支持多种消息协议，消息队列，传送确认，灵活的路由到队列，多种交换类型；&lt;/li&gt;
&lt;li&gt;支持几乎所有最受欢迎的编程语言：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；&lt;/li&gt;
&lt;li&gt;可以部署为高可用性和吞吐量的集群; 跨多个可用区域和区域进行联合；&lt;/li&gt;
&lt;li&gt;可插入的身份验证，授权，支持TLS和LDAP。；&lt;/li&gt;
&lt;li&gt;提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker 的许多方面；&lt;/li&gt;
&lt;li&gt;提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;kafka&quot;&gt;3. Kafka&lt;/h3&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://link.juejin.im?target=http%3A%2F%2Fkafka.apache.org%2F&quot;&gt;kafka.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。 这种动作（网页浏览，搜索和其他用户的行动）是在现代网络上的许多社会功能的一个关键因素。 这些数据通常是由于吞吐量的要求而通过处理日志和日志聚合来解决。 对于像Hadoop的一样的日志数据和离线分析系统，但又要求实时处理的限制，这是一个可行的解决方案。Kafka的目的是通过Hadoop的并行加载机制来统一线上和离线的消息处理，也是为了通过集群来提供实时的消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kafka它主要用于处理活跃的流式数据，因此Kafaka在大数据系统中使用较多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;同时为发布和订阅提供高吞吐量。据了解，Kafka每秒可以生产约25万消息（50 MB），每秒处理55万消息（110 MB）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可进行持久化操作。将消息持久化到磁盘，因此可用于批量消费，例如ETL，以及实时应用程序。通过将数据持久化到硬盘以及replication防止数据丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分布式系统，易于向外扩展。所有的producer、broker和consumer都会有多个，均为分布式的。无需停机即可扩展机器。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;消息被处理的状态是在consumer端维护，而不是由server端维护。当失败时能自动平衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持online和offline的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;rocketmq&quot;&gt;4. RocketMQ&lt;/h3&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://link.juejin.im?target=http%3A%2F%2Frocketmq.apache.org%2F&quot;&gt;rocketmq.apache.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简介：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;RocketMQ是阿里开源的消息中间件，目前在Apache孵化，使用纯Java开发，具有高吞吐量、高可用性、适合大规模分布式系统应用的特点。RocketMQ思路起源于Kafka，但并不是简单的复制，它对消息的可靠传输及事务性做了优化，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binglog分发等场景，支撑了阿里多次双十一活动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;支持发布/订阅（Pub/Sub）和点对点（P2P）消息模型&lt;/li&gt;
&lt;li&gt;在一个队列中可靠的先进先出（FIFO）和严格的顺序传递&lt;/li&gt;
&lt;li&gt;支持拉（pull）和推（push）两种消息模式&lt;/li&gt;
&lt;li&gt;单一队列百万消息的堆积能力&lt;/li&gt;
&lt;li&gt;支持多种消息协议，如 JMS、MQTT 等&lt;/li&gt;
&lt;li&gt;分布式高可用的部署架构,满足至少一次消息传递语义&lt;/li&gt;
&lt;li&gt;提供 docker 镜像用于隔离测试和云集群部署&lt;/li&gt;
&lt;li&gt;提供配置、指标和监控等功能丰富的 Dashboard&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三activemq的安装&quot;&gt;三、ActiveMQ的安装&lt;/h2&gt;
&lt;h3 id=&quot;安装步骤&quot;&gt;1.安装步骤&lt;/h3&gt;
&lt;p&gt;activemq在各个系统下都有对应的安装包。以下来演示Linux系统下安装activemq。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155534750-712113107.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进入apache-activemq-5.15.8/bin目录，启动activemq&lt;code&gt;./activemq start&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155557234-2055497344.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出以上信息，表示启动成功。&lt;/p&gt;
&lt;h3 id=&quot;安装遇到的问题&quot;&gt;2.安装遇到的问题&lt;/h3&gt;
&lt;p&gt;在安装过程中，通过查看activemq的运行状态，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155610449-163365141.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示以上。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;./bin/activemq console&lt;/code&gt; 命令查看运行日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155620766-818332526.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主机名中包含非法字符；&lt;/p&gt;
&lt;p&gt;那么解决办法就很简单了，改主机名：&lt;/p&gt;
&lt;p&gt;1、方法一使用hostnamectl命令&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hostnamectl set-hostname 主机名&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2、方法二：修改配置文件 /etc/hostname 保存退出&lt;/p&gt;
&lt;p&gt;修改完成之后重启即可，这里我使用的是方法一：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hostnamectl set-hostname activemq&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看运行状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155632146-951706469.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五activemq页面介绍&quot;&gt;五、ActiveMQ页面介绍&lt;/h2&gt;
&lt;p&gt;待ActiveMQ安装启动好，访问http://ip:8161/admin，登录名和密码都是admin(在配置文件中可修改)，进入ActiveMQ的主页：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155646461-1952765827.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面来介绍每个菜单的功能：&lt;/p&gt;
&lt;h3 id=&quot;queue消息队列页面&quot;&gt;1.Queue消息队列页面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155655818-625768830.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Name：消息队列的名称。&lt;/p&gt;
&lt;p&gt;Number Of Pending Messages：未被消费的消息数目。&lt;/p&gt;
&lt;p&gt;Number Of Consumers：消费者的数量。&lt;/p&gt;
&lt;p&gt;Messages Enqueued：进入队列的消息 ；进入队列的总消息数目，包括已经被消费的和未被消费的。 这个数量只增不减。&lt;/p&gt;
&lt;p&gt;Messages Dequeued：出了队列的消息，可以理解为是被消费掉的消息数量。在Queues里它和进入队列的总数量相等(因为一个消息只会被成功消费一次),如果暂时不等是因为消费者还没来得及消费。&lt;/p&gt;
&lt;h3 id=&quot;topic主题页面&quot;&gt;2.Topic主题页面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155704889-671197129.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Name：主题名称。&lt;/p&gt;
&lt;p&gt;Number Of Pending Messages：未被消费的消息数目。&lt;/p&gt;
&lt;p&gt;Number Of Consumers：消费者的数量。&lt;/p&gt;
&lt;p&gt;Messages Enqueued：进入队列的消息 ；进入队列的总消息数目，包括已经被消费的和未被消费的。 这个数量只增不减。&lt;/p&gt;
&lt;p&gt;Messages Dequeued：出了队列的消息，可以理解为是被消费掉的消息数量。在Topics里，因为多消费者从而导致数量会比入队列数高。&lt;/p&gt;
&lt;h3 id=&quot;subscribers查看订阅者页面&quot;&gt;3.Subscribers查看订阅者页面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155718228-1736136109.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看订阅者信息，只在Topics消息类型中这个页面才会有数据。&lt;/p&gt;
&lt;h3 id=&quot;connections查看连接数页面&quot;&gt;4.Connections查看连接数页面&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155727007-809373134.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六简单使用&quot;&gt;六、简单使用&lt;/h2&gt;
&lt;p&gt;引入jar包：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;activemq-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.7.0&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;点对点p2p模型&quot;&gt;1.点对点(P2P)模型&lt;/h3&gt;
&lt;p&gt;​ 点对点模型，采用的是队列(Queue)作为消息载体。在该模式中，一条消息只能被一个消费者消费，没有被消费的，只能留在队列中，等待被消费，或者超时。举个例子，如果队列中有10条消息，有两个消费者，就是一个消费者消费5条信息，你一条我一条。以下以代码演示。&lt;/p&gt;
&lt;p&gt;消息发布者：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) throws JMSException {
    /*
     * 实现步骤
     * 1.建立ConnectionFactory工厂对象，需要填入用户名、密码、连接地址（一般使用默认，如果没有修改的话）
     * 2.通过ConnectionFactory对象创建一个Connection连接，并且调用Connection的start方法开启连接，Connection方法默认是关闭的
     * 3.通过Connection对象创建Session会话（上下文环境对象），用于接收消息，参数1是是否启用事物，参数2是签收模式，一般设置为自动签收
     * 4.通过Session对象创建Destination对象，指的是一个客户端用来制定生产消息目标和消费消息来源的对象。在PTP的模式中，Destination被称作队列，在Pub/Sub模式中，Destination被称作主题（Topic）
     * 5.通过Session对象创建消息的发送和接收对象（生产者和消费者）
     * 6.通过MessageProducer的setDeliverMode方法为其设置持久化或者非持久化特性
     * 7.使用JMS规范的TextMessage形式创建数据（通过Session对象），并用MessageProducer的send方法发送数据。客户端同理。记得关闭
     */
    ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,
            ActiveMQConnectionFactory.DEFAULT_PASSWORD,&quot;tcp://94.191.49.192:61616&quot;);
    Connection connection = connectionFactory.createConnection();
    connection.start();
    Session session = connection.createSession(Boolean.FALSE,Session.AUTO_ACKNOWLEDGE);
    Destination destination = session.createQueue(&quot;queue&quot;);
    MessageProducer producer = session.createProducer(destination);
    producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);
    for (int i=0;i&amp;lt;=5;i++) {
        TextMessage textMessage = session.createTextMessage();
        textMessage.setText(&quot;我是第&quot;+i+&quot;消息&quot;);
        producer.send(textMessage);
    }
    if(connection!=null){
        connection.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消息消费者：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) throws JMSException {
        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnectionFactory.DEFAULT_USER,
                ActiveMQConnectionFactory.DEFAULT_PASSWORD,&quot;tcp://94.191.49.192:61616&quot;);
        Connection connection = connectionFactory.createConnection();
        connection.start();
        Session session = connection.createSession(Boolean.FALSE,Session.AUTO_ACKNOWLEDGE);
        Destination destination = session.createQueue(&quot;queue&quot;);
        MessageConsumer consumer = session.createConsumer(destination);
        while (true){
            TextMessage message = (TextMessage) consumer.receive();
            if (message==null){
                break;
            }
            System.out.println(message.getText());
        }
        if(connection!=null){
            connection.close();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先启动两个消费者，在启动发布者：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155749255-798568023.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155756555-2134271312.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;发布订阅pubsub模型&quot;&gt;2.发布/订阅(Pub/Sub)模型&lt;/h3&gt;
&lt;p&gt;发布/订阅模型采用的是主题(Topic)作为消息通讯载体。该模式类似微信公众号的模式。发布者发布一条信息，然后将该信息传递给所有的订阅者。注意：订阅者想要接收到该信息，必须在该信息发布之前订阅。&lt;/p&gt;
&lt;p&gt;发布者发布信息：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     public static void main(String[] args) throws JMSException, IOException {
        // 创建一个ConnectionFactory对象连接MQ服务器
        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://94.191.49.192:61616&quot;);
        // 创建一个连接对象
        Connection connection;
        connection = connectionFactory.createConnection();
        // 开启连接
        connection.start();
        // 使用Connection对象创建一个Session对象
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        // 创建一个Destination对象。topic对象
        Topic topic = session.createTopic(&quot;test-topic&quot;);
        // 使用Session对象创建一个消费者对象。
        MessageConsumer consumer = session.createConsumer(topic);
        // 接收消息
        consumer.setMessageListener(new MessageListener() {

            @Override
            public void onMessage(Message message) {
                // 打印结果
                TextMessage textMessage = (TextMessage) message;
                String text;
                try {
                    text = textMessage.getText();
                    System.out.println(&quot;这是接收到的消息：&quot; + text);
                } catch (JMSException e) {
                    e.printStackTrace();
                }

            }
        });
        System.out.println(&quot;topic消费者启动。。。。&quot;);
        // 等待接收消息
        System.in.read();
        // 关闭资源
        consumer.close();
        session.close();
        connection.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;订阅者订阅信息：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) throws JMSException {
        // 1、创建一个连接工厂对象，需要指定服务的ip及端口。
        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://94.191.49.192:61616&quot;);
        // 2、使用工厂对象创建一个Connection对象。
        Connection connection = connectionFactory.createConnection();
        // 3、开启连接，调用Connection对象的start方法。
        connection.start();
        // 4、创建一个Session对象。
        // 第一个参数：是否开启事务。如果true开启事务，第二个参数无意义。一般不开启事务false。
        // 第二个参数：应答模式。自动应答或者手动应答。一般自动应答。
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        // 5、使用Session对象创建一个Destination对象。两种形式queue、topic，现在应该使用topic
        Topic topic = session.createTopic(&quot;test-topic&quot;);
        // 6、使用Session对象创建一个Producer对象。
        MessageProducer producer = session.createProducer(topic);
        // 7、创建一个Message对象，可以使用TextMessage。
        for (int i = 0; i &amp;lt; 50; i++) {
            TextMessage textMessage = session.createTextMessage(&quot;第&quot; + i + &quot;一个ActiveMQ队列目的地的消息&quot;);
            // 8、发送消息
            producer.send(textMessage);
        }
        // 9、关闭资源
        producer.close();
        session.close();
        connection.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;订阅者要提前订阅，所以先运行订阅者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201903/1183871-20190328155817762-2066507180.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;两种模式对比&quot;&gt;3.两种模式对比&lt;/h3&gt;
&lt;p&gt;1）由以上，我们可以总结出ActiveMQ的实现步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建立ConnectionFactory工厂对象，需要填入用户名、密码、连接地址&lt;/li&gt;
&lt;li&gt;通过ConnectionFactory对象创建一个Connection连接&lt;/li&gt;
&lt;li&gt;通过Connection对象创建Session会话&lt;/li&gt;
&lt;li&gt;通过Session对象创建Destination对象；在P2P的模式中，Destination被称作队列（Queue），在Pub/Sub模式中，Destination被称作主题（Topic）&lt;/li&gt;
&lt;li&gt;通过Session对象创建消息的发送和接收对象&lt;/li&gt;
&lt;li&gt;发送消息&lt;/li&gt;
&lt;li&gt;关闭资源&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2）可以看出，P2P模式和Pub/Sub模式，在实现上的区别是通过Session创建的Destination对象不一样，在P2P的模式中，Destination被称作队列（Queue），在Pub/Sub模式中，Destination被称作主题（Topic）&lt;/p&gt;
&lt;h2 id=&quot;七参考&quot;&gt;七、参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;https://www.jianshu.com/p/0363ac9ff574&lt;/li&gt;
&lt;li&gt;https://juejin.im/post/5adaaae351882567356415eb&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 28 Mar 2019 08:00:00 +0000</pubDate>
<dc:creator>追梦1819</dc:creator>
<og:description>消息中间件ActiveMQ使用详解 一、消息中间件的介绍 介绍 ​ 消息队列 是指利用 高效可靠 的 消息传递机制 进行与平台无关的 数据交流 ，并基于 数据通信 来进行分布式系统的集成。 特点(作用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanfei1819/p/10615605.html</dc:identifier>
</item>
<item>
<title>netty源码解解析(4.0)-15 Channel NIO实现:写数据 - 自带buff</title>
<link>http://www.cnblogs.com/brandonli/p/10314962.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brandonli/p/10314962.html</guid>
<description>&lt;p&gt;　　写数据是NIO Channel实现的另一个比较复杂的功能。每一个channel都有一个outboundBuffer，这是一个输出缓冲区。当调用channel的write方法写数据时，这个数据被一系列ChannelOutboundHandler处理之后，它被放进这个缓冲区中，并没有真正把数据写到socket channel中。然后再调用channel的flush方法，flush会把outboundBuffer中数据真正写到socket channel。正常情况下flush之后，数据已经真正写完了。但使用Selector加非阻塞socket的方式写数据，让写操作变得复杂了。操作系统为每个socket维护了一个数据发送缓冲区，它的长度SO_SNDBUF, 每次发送数据，先把数据写到这个缓冲区中，操作系统负责把这个发送缓冲区中的数据发送出去，并清理这个缓冲区。当向缓冲区写的速率大于系统的发送速率时，它会被填满，在非阻塞模式下的表现为: 调用socket的write方法写入长度为n数据，实际写入的数据长度m的范围是:0=&amp;lt;m&amp;lt;n。这个时候还剩下长度为n-m的数据没有写入到socket，而数据必须以正确的顺序完整地写入到socket中。 outboundBuffer正是为解决这个问题而设计的，没写进socket的剩余数据会以正确的顺序保存在outboundBuffer中，当发送缓冲区中有空间可以写时，可以从outboundBuffer中取出剩余的数据继续写入到socket中。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;Channel write实现: 把数据写到outboundBuffer中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　write调用栈:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannel#write(java.lang.Object)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;io.netty.channel.DefaultChannelPipeline#write(java.lang.Object)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannelHandlerContext#write(java.lang.Object)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannelHandlerContext#write(java.lang.Object, io.netty.channel.ChannelPromise)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; io.netty.channel.AbstractChannelHandlerContext#write(java.lang.Object, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt;, io.netty.channel.ChannelPromise)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannelHandlerContext#invokeWrite
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;io.netty.channel.DefaultChannelPipeline.HeadContext#write
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; io.netty.channel.AbstractChannel.AbstractUnsafe#write
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　write的主要逻辑在io.netty.channel.AbstractChannel.AbstractUnsafe#write中实现，这个方法把要写的数据msg对象放到outboundBuffer中。在执行close时，netty不希望有希望写新的数据，避免引起不可预料的错误，因此会把outboundBuffer置为null。这里在向outboundBuffer写数据之前会把对它进行检查，如果是null就抛出错误。下面是这个write方法的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; write(Object msg, ChannelPromise promise) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    assertEventLoop();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     ChannelOutboundBuffer outboundBuffer = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.outboundBuffer;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (outboundBuffer == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        ReferenceCountUtil.release(msg);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         msg =&lt;span&gt; filterOutboundMessage(msg);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         size =&lt;span&gt; pipeline.estimatorHandle().size(msg);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (size &amp;lt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             size = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        safeSetFailure(promise, t);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        ReferenceCountUtil.release(msg);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    outboundBuffer.addMessage(msg, size, promise);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第5-9行，对outboudBuffer进行检查，如果是null抛出错误。这个里有个小细节，用一个局部变量引用outboundBuffer，避免由其他线程对this.outboundBuffer置空引发错误。&lt;/p&gt;
&lt;p&gt;　　14行，调用filterOutboundMessage对msg进行过滤。这是一个protected方法，默认实现是什么都没做，返回输入的msg参数。子类可以覆盖这个方法，把msg转换成期望的类型。&lt;/p&gt;
&lt;p&gt;　　15行，计算msg的长度。&lt;/p&gt;
&lt;p&gt;　　25行，把放入到outboundBuffer中。&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;Channel flush实现：把数据真正写到channel&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　flush调用栈：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannel#flush
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;io.netty.channel.DefaultChannelPipeline#flush
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannelHandlerContext#flush
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannelHandlerContext#invokeFlush
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;io.netty.channel.DefaultChannelPipeline.HeadContext#flush
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannel.AbstractUnsafe#flush
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannel.AbstractUnsafe#flush0
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;io.netty.channel.socket.nio.NioSocketChannel#doWrite
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;io.netty.channel.nio.AbstractNioByteChannel#doWrite
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; io.netty.channel.socket.nio.NioSocketChannel#doWriteBytes
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　 以上是io.netty.channel.socket.nio.NioSocketChannel的flush调用栈，对于io.netty.channel.socket.nio.NioDatagramChannel来说，从第8行开始变得不同:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannel.AbstractUnsafe#flush0
&lt;/span&gt;8 &lt;span&gt;io.netty.channel.nio.AbstractNioMessageChannel#doWrite
&lt;/span&gt;9 io.netty.channel.socket.nio.NioDatagramChannel#doWriteMessage
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;把Byte数据流写入channel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　io.netty.channel.socket.nio.NioSocketChannel#doWrite是Byte数据流的写逻辑，io.netty.channel.nio.AbstractNioByteChannel#doWrite也是，这两者不同的地方在于前者是在outboundBuffer可以转换成java.nio.ByteBuffer的情况下执行，后者是在outboundBuffer中的msg是ByteBuf或FileRegin类型时执行。除此之外其他逻辑都一样:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;尽量把outboundBuffer中的数据写到channel中。&lt;/li&gt;
&lt;li&gt;如果channel无法写入数据，在channel的SelectionKey上注册OP_WRITE事件，等channel可写的时候再继续写入。&lt;/li&gt;
&lt;li&gt;如写入次数超过限制，把flush操作包装成task放到eventLoop排队，等待再次执行。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　下面来看看io.netty.channel.socket.nio.NioSocketChannel#doWrite的实现代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doWrite(ChannelOutboundBuffer in) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (;;) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; in.size();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (size == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; All written so clear OP_WRITE&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            clearOpWrite();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; writtenBytes = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; done = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;boolean&lt;/span&gt; setOpWrite = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ensure the pending writes are made of ByteBufs only.&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         ByteBuffer[] nioBuffers =&lt;span&gt; in.nioBuffers();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; nioBufferCnt =&lt;span&gt; in.nioBufferCount();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; expectedWrittenBytes =&lt;span&gt; in.nioBufferSize();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         SocketChannel ch =&lt;span&gt; javaChannel();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Always us nioBuffers() to workaround data-corruption.
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/2761&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (nioBufferCnt) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; 0&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We have something else beside ByteBuffers to write so fallback to normal writes.&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.doWrite(in);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;case&lt;/span&gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only one ByteBuf so use non-gathering write&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 ByteBuffer nioBuffer = nioBuffers[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = config().getWriteSpinCount() - 1; i &amp;gt;= 0; i --&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; localWrittenBytes =&lt;span&gt; ch.write(nioBuffer);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (localWrittenBytes == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                         setOpWrite = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     expectedWrittenBytes -=&lt;span&gt; localWrittenBytes;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     writtenBytes +=&lt;span&gt; localWrittenBytes;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (expectedWrittenBytes == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                         done = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             &lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = config().getWriteSpinCount() - 1; i &amp;gt;= 0; i --&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; localWrittenBytes = ch.write(nioBuffers, 0&lt;span&gt;, nioBufferCnt);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (localWrittenBytes == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                         setOpWrite = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                     expectedWrittenBytes -=&lt;span&gt; localWrittenBytes;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                     writtenBytes +=&lt;span&gt; localWrittenBytes;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (expectedWrittenBytes == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                         done = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                         &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Release the fully written buffers, and update the indexes of the partially written buffer.&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        in.removeBytes(writtenBytes);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;done) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Did not write all buffers completely.&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            incompleteWrite(setOpWrite);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　第5-7行，如果outboundBuffer中已经没有数据了，调用clearOpWrite方法清除channel SelectionKey上的OP_WRITE事件。&lt;/p&gt;
&lt;p&gt;　　第15-17行，把outboundBuffer转换成ByteBuffer类型，并得到数据长度。&lt;/p&gt;
&lt;p&gt;　　25行，outboundBuffer不能转换成ByteBuffer, 调用io.netty.channel.nio.AbstractNioByteChannel#doWrite执行写操作。&lt;/p&gt;
&lt;p&gt;　　29-42，45-57的逻辑基本已经，都是尽量把ByteBuffer中的数据写到channel中，满足下列条件中的任意一个时，结束本次写操作:&lt;/p&gt;
&lt;p&gt;　　　　1. ByteBuffer中的数据已经写完，正常结束。&lt;/p&gt;
&lt;p&gt;　　　　2. channel已经不能写入数据，需要在channel可以写是继续执行写操作。&lt;/p&gt;
&lt;p&gt;　　　　3. 者超过channel config中写入次数限制，需要选择合适的实际继续执行写操作。&lt;/p&gt;
&lt;p&gt;　　62行，把已经写入到channel的数据从outboundBuffer中删除。&lt;/p&gt;
&lt;p&gt;　　64-66行， 如果数据没写完，调用incompleteWrite处理没写完的情况。当setOpWrite==true时，在channel的SelectionKey上设置OP_WRITE事件，等eventLoop触发这个事件时再继续执行flush操作。否则，把flush包装成task放到eventLoop中排队执行。&lt;/p&gt;

&lt;p&gt;　　当NioEventLoop检测到OP_WRITE事件时，会调用processSelectedKey方法处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_WRITE) != 0&lt;span&gt;) {
    ch.unsafe().forceFlush();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　forceFlush的调用栈如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#forceFlush
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;io.netty.channel.AbstractChannel.AbstractUnsafe#flush0
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;io.netty.channel.socket.nio.NioSocketChannel#doWrite
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;io.netty.channel.nio.AbstractNioByteChannel#doWrite
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; io.netty.channel.socket.nio.NioSocketChannel#doWriteBytes
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;把数据写入UDP类型的channel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　io.netty.channel.nio.AbstractNioMessageChannel#doWrite是数据报的写逻辑。相较于Byte流类型的数据，数据报的写逻辑简单一些。它只是把outboundBuffer中的数据报依次写入到channel中，如果channel写满了，在channel的SelectionKey上设置OP_WRITE事件随后退出，其后OP_WRITE事件处理逻辑和Byte流写逻辑一样。 真正的写操作在io.netty.channel.socket.nio.NioDatagramChannel#doWriteMessage中实现，这个方法的实现如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; doWriteMessage(Object msg, ChannelOutboundBuffer in) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt;&lt;span&gt; SocketAddress remoteAddress;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ByteBuf data;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (msg &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; AddressedEnvelope) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         @SuppressWarnings(&quot;unchecked&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         AddressedEnvelope&amp;lt;ByteBuf, SocketAddress&amp;gt; envelope = (AddressedEnvelope&amp;lt;ByteBuf, SocketAddress&amp;gt;&lt;span&gt;) msg;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         remoteAddress =&lt;span&gt; envelope.recipient();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         data =&lt;span&gt; envelope.content();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         data =&lt;span&gt; (ByteBuf) msg;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         remoteAddress = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; dataLen =&lt;span&gt; data.readableBytes();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (dataLen == 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; ByteBuffer nioData =&lt;span&gt; data.internalNioBuffer(data.readerIndex(), dataLen);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; writtenBytes;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (remoteAddress != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         writtenBytes =&lt;span&gt; javaChannel().send(nioData, remoteAddress);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         writtenBytes =&lt;span&gt; javaChannel().write(nioData);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; writtenBytes &amp;gt; 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5-9行，处理AddressedEnvelope类型的数据报，得到数据报的远程地址和数据。&lt;/p&gt;
&lt;p&gt;　　10-12行，发送的是一个ByteBuf。没有指定远程地址。这种情况下需要先调用channel的connect方法。&lt;/p&gt;
&lt;p&gt;　　20-26行，分别针对两种情况发送数据报. 23行指定了远程地址，25行没有指定远程地址，但调用过了connect方法。&lt;/p&gt;


</description>
<pubDate>Thu, 28 Mar 2019 07:59:00 +0000</pubDate>
<dc:creator>自带buff</dc:creator>
<og:description>写数据是NIO Channel实现的另一个比较复杂的功能。每一个channel都有一个outboundBuffer，这是一个输出缓冲区。当调用channel的write方法写数据时，这个数据被一系列C</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brandonli/p/10314962.html</dc:identifier>
</item>
<item>
<title>[个人网站搭建]·Django增加评论功能 - 小宋是呢</title>
<link>http://www.cnblogs.com/xiaosongshine/p/10615575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaosongshine/p/10615575.html</guid>
<description>
&lt;p&gt;个人主页--&amp;gt; &lt;a href=&quot;https://xiaosongshine.github.io/&quot; data-cke-saved-href=&quot;https://xiaosongshine.github.io/&quot;&gt;https://xiaosongshine.github.io/&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;个人网站搭建github地址：&lt;a href=&quot;https://github.com/xiaosongshine/djangoWebs&quot; data-cke-saved-href=&quot;https://github.com/xiaosongshine/djangoWebs&quot;&gt;https://github.com/xiaosongshine/djangoWebs&lt;/a&gt; &lt;/p&gt;

&lt;h3&gt;安装django插件&lt;/h3&gt;

&lt;h3&gt;配置settings.py&lt;/h3&gt;

&lt;p&gt;在INSTALLED_APP添加django_comments和django.contrib.sites两个应用。&lt;/p&gt;
&lt;p&gt;在外部添加 SITE_ID=1。&lt;/p&gt;
&lt;p&gt;django的评论库是一个站点，所以需要添加sites的应用并设置当前django工程的站点id=1&lt;/p&gt;
&lt;h3&gt;更新数据库&lt;/h3&gt;

&lt;h3&gt;配置urls.py&lt;/h3&gt;
&lt;p&gt;在 urlpatterns 中添加&lt;/p&gt;

&lt;h3&gt;修改前端页面显示评论列表和评论提交表单&lt;/h3&gt;
&lt;p&gt;接着，修改前端页面显示评论列表和评论提交表单。这些需要使用django_comments的模版标签，在使用标签之前导入加载：&lt;/p&gt;

&lt;p&gt;评论列表可以通过django_comments的get_comment_list模版标签获取，如下代码：&lt;/p&gt;

&lt;p&gt;get_comment_list模版标签的用法是for一个模版对象，as是重命名。变量得到的评论加载即可。&lt;/p&gt;
&lt;p&gt;而评论提交表单，最主要的是提交的url和表单字段。同样也可以通过django_comments的模版标签处理，如下代码：&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;这一步需要注意的有两点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.{% get_comment_form for blog as blog_form %} {% get_comment_list for blog as comments %}中blog就是你的文章内容，我的&lt;a href=&quot;https://xiaosongshine.github.io/%C2%A0&quot; data-cke-saved-href=&quot;https://xiaosongshine.github.io/%C2%A0&quot;&gt;主页&lt;/a&gt;用的是show我就改为了：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;{% get_comment_form for show as blog_form %} {% get_comment_list for show as comments %}&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&amp;lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;{%url 'detailblog' blog.id%}&quot;/&amp;gt;其中的value=&quot;{%url 'detailblog' blog.id%}就是你要刷新的网页url，我的修改为了：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;input type=&quot;hidden&quot; name=&quot;next&quot; value=&quot;/details-{{show.id}}.html&quot;/&amp;gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;还有一个小技巧：可以通过&lt;/strong&gt;&lt;strong&gt;{{ comments|length}}获取评论总数目，便于统计显示，我的实现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;li&amp;gt;&amp;lt;a href=&quot;#&quot; class=&quot;icon fa-comment&quot;&amp;gt;{{ comments|length}}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;​​​​​​​&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;重启Uwsgi和Nginx&lt;/h3&gt;
&lt;p&gt;修改Django文件和其它配置文件之后，一定要重启Uwsgi和Nginx，不然不生效。&lt;/p&gt;
&lt;p&gt;Uwsgi和Nginx重启方法：&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;效果展示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://img-blog.csdnimg.cn/20190328101003403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;480&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20190328101003403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20190328101003403.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;853&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;480&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Please Enjoy Yourself&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎大家访问我的&lt;a href=&quot;https://xiaosongshine.github.io/%C2%A0&quot; data-cke-saved-href=&quot;https://xiaosongshine.github.io/&quot;&gt;主页&lt;/a&gt;尝试一下，觉得有用的话，麻烦小小鼓励一下 &amp;gt;&amp;lt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人网站搭建github地址：&lt;a href=&quot;https://github.com/xiaosongshine/djangoWebs&quot; data-cke-saved-href=&quot;https://github.com/xiaosongshine/djangoWebs&quot;&gt;https://github.com/xiaosongshine/djangoWebs&lt;/a&gt; 欢迎访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;http://yshblog.com/blog/5&quot; data-cke-saved-href=&quot;http://yshblog.com/blog/5&quot;&gt;http://yshblog.com/blog/5&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 07:56:00 +0000</pubDate>
<dc:creator>小宋是呢</dc:creator>
<og:description>[个人网站搭建]·Django增加评论功能 个人主页--&gt; https://xiaosongshine.github.io/ 个人网站搭建github地址：https://g</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaosongshine/p/10615575.html</dc:identifier>
</item>
<item>
<title>Linux - 挂载磁盘 + 通过LVM动态实现磁盘的动态扩容 - 马瘦风</title>
<link>http://www.cnblogs.com/shoufeng/p/10615452.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shoufeng/p/10615452.html</guid>
<description>&lt;h2 id=&quot;概念解释&quot;&gt;1.1 概念解释&lt;/h2&gt;
&lt;p&gt;LVM(Logical Volume Manager), 逻辑卷管理, 是一种将一至多个硬盘的分区在逻辑上进行组合, 当成一个大硬盘来使用.&lt;/p&gt;
&lt;p&gt;当硬盘空间不足时, 可以动态地添加其它硬盘的分区到已有的卷组中 —— 磁盘空间的动态管理.&lt;/p&gt;
&lt;h2 id=&quot;为什么用lvm&quot;&gt;1.2 为什么用LVM&lt;/h2&gt;
&lt;p&gt;LVM通常用于装备大量磁盘的系统, 比如服务器中的磁盘阵列.&lt;/p&gt;
&lt;p&gt;但LVM同样适用于仅有一、两块硬盘的小系统.&lt;/p&gt;
&lt;h3 id=&quot;不使用lvm时的扩容思路&quot;&gt;1.2.1 不使用LVM时的扩容思路&lt;/h3&gt;
&lt;p&gt;传统的文件系统是基于分区的, 一个文件系统对应一个分区, 这种方式比较直观, 但不易改变:&lt;/p&gt;
&lt;blockquote readability=&quot;21.5&quot;&gt;
&lt;p&gt;(1) 不同的分区相互独立, 单独的文件不能跨分区存储, 容易出现硬盘的利用率不均衡;&lt;/p&gt;
&lt;p&gt;(2) 当一个文件系统/分区装满时, 是不能对其进行扩容的, 只能采用重新分区/建立文件系统, 重新分区会丢失数据, 就要:&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;① 做数据的迁移和备份;&lt;br/&gt;② 或者把分区中的数据移到另一个更大的分区中;&lt;br/&gt;③ 或者采用符号连接的方式使用其它分区的空间 —— 都非常麻烦;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(3) 如果要把硬盘上的多个分区合并在一起使用, 只能采用重新分区的方式, —— 需要做好数据的备份与恢复.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用lvm时的扩容思路&quot;&gt;1.2.2 使用LVM时的扩容思路&lt;/h3&gt;
&lt;p&gt;使用LVM时技术时, 情况有所不同:&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;(1) 硬盘的多个分区由LVM统一管理为卷组, 可以很轻松地加入或移走某个分区 —— 也就是扩大或减小卷组的可用容量, 充分利用硬盘空间;&lt;/p&gt;
&lt;p&gt;(2) 文件系统建立在逻辑卷上, 而逻辑卷可以根据需要改变大小(在卷组容量范围内)以满足要求;&lt;/p&gt;
&lt;p&gt;(3) 文件系统建立在LVM上, 可以跨分区存储访问, 更加方便;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;强烈建议对拥有多个磁盘的系统, 使用LVM管理磁盘.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;名词解释&quot;&gt;1.3 名词解释&lt;/h2&gt;
&lt;blockquote readability=&quot;26&quot;&gt;
&lt;p&gt;PV(Physical Volume): 物理卷, 处于LVM最底层, 可以是物理硬盘或者分区;&lt;/p&gt;
&lt;p&gt;PP(Physical Extend): 物理区域, PV中可以用于分配的最小存储单元, 可以在创建PV的时候指定, 如1M, 2M, 4M, 8M…..组成同一VG中所有PV的PE大小应该相同;&lt;/p&gt;
&lt;p&gt;VG(Volume Group): 卷组, 建立在PV之上, 可以含有一个到多个PV;&lt;/p&gt;
&lt;p&gt;LV(Logical Volume): 逻辑卷, 建立在VG之上, 相当于原来分区的概念, 不过大小可以动态改变.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;创建分区的主要操作&quot;&gt;2.1 创建分区的主要操作&lt;/h2&gt;
&lt;p&gt;(1) 查看分区情况 - &lt;kbd&gt;fdisk -l&lt;/kbd&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# fdisk -l

Disk /dev/sda: 299.0 GB, 298999349248 bytes         # 磁盘/dev/sda
255 heads, 63 sectors/track, 36351 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x4d69fe0e

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          26      204800   83  Linux       # 分为2个区, sda1
Partition 1 does not end on cylinder boundary.
/dev/sda2              26       36352   291785728   8e  Linux LVM   # sda2

# 磁盘/dev/sdb没有分区
Disk /dev/sdb: 4000.0 GB, 3999999721472 bytes
255 heads, 63 sectors/track, 486305 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000

......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 查看已有磁盘 - &lt;kbd&gt;lsblk&lt;/kbd&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# lsblk 
NAME                       MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda                          8:0    0 278.5G  0 disk 
├─sda1                       8:1    0   200M  0 part /boot
└─sda2                       8:2    0 278.3G  0 part 
  └─VolGroup-LogVol (dm-0) 253:0    0   1.9T  0 lvm  /      # LVM类型的分区
sdb                          8:32   0   3.7T  0 disk        # 还没有分区的新磁盘&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) 对新磁盘进行分区 - &lt;kbd&gt;fdisk /dev/sdb&lt;/kbd&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# fdisk /dev/sdb 
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel with disk identifier 0xf91f8c4c.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won't be recoverable.

Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

WARNING: The size of this disk is 4.0 TB (4000225165312 bytes).
DOS partition table format can not be used on drives for volumes
larger than (2199023255040 bytes) for 512-byte sectors. Use parted(1) and GUID 
partition table format (GPT).


WARNING: DOS-compatible mode is deprecated. It's strongly recommended to
         switch off the mode (command 'c') and change display units to
         sectors (command 'u').

Command (m for help): n             # n 表示新建分区
Command action
   e   extended
   p   primary partition (1-4)
p                                   # p 表示分区类型为主分区, 主分区只有1-4种选择
Partition number (1-4): 1           # 主分区的编号
First cylinder (1-486333, default 1):   # 开始扇区号, 直接回车, 使用默认值1
Using default value 1

# 结束扇区号, 使用默认值 --- 这里只加载了新磁盘的一半(2T), 所以还需要再次创建分区/dev/sdb2使用剩下的一半.
Last cylinder, +cylinders or +size{K,M,G} (1-267349, default 267349):   
Using default value 267349

Command (m for help):  w            #  将上述设置写入分区表并退出
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(4) 再次查看分区情况 - &lt;kbd&gt;fdisk -l&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;多出来一个/dev/sdb1的区, 这个1就是之前主分区之后指定的分区编号.&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# fdisk -l 

Disk /dev/sda: 299.0 GB, 298999349248 bytes
255 heads, 63 sectors/track, 36351 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x4d69fe0e

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          26      204800   83  Linux
Partition 1 does not end on cylinder boundary.
/dev/sda2              26       36352   291785728   8e  Linux LVM

# /dev/sdb磁盘: 
Disk /dev/sdb: 4000.0 GB, 3999999721472 bytes
255 heads, 63 sectors/track, 486305 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x8f3043b5

# 多出来的分区/dev/sdb1
   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1      267349  2147480811   83  Linux

......&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(5) 查看当前分区表中的分区信息 - &lt;kbd&gt;cat /proc/partitions&lt;/kbd&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# cat /proc/partitions 
major minor  #blocks  name

   8        0   291991552  sda
   8        1      204800  sda1
   8        2   291785728  sda2
   8       32  3906249728  sdb      # 添加的新磁盘
   8       33  2147480811  sdb1     # 创建的新分区
 253        0  2046660608  dm-0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果创建完之后，&lt;code&gt;cat /proc/partitions&lt;/code&gt; 查看不到对应的分区, 使用 &lt;code&gt;parprobe&lt;/code&gt; 刷新命令即可:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# partprobe /dev/sdc&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;格式化新分区&quot;&gt;2.2 格式化新分区&lt;/h2&gt;
&lt;p&gt;(1) 格式化新分区 - &lt;kbd&gt;mkfs -t&lt;/kbd&gt;&lt;/p&gt;
&lt;p&gt;这里建议将新分区格式化为&lt;code&gt;ext4&lt;/code&gt;文件类型, 还有&lt;code&gt;ext2&lt;/code&gt;, &lt;code&gt;ext3&lt;/code&gt;等文件类型, 区别请参考博客 &lt;a href=&quot;https://blog.csdn.net/macrossdzh/article/details/5973639&quot;&gt;ext2、ext3与ext4的区别&lt;/a&gt; .&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# mkfs -t ext4 /dev/sdb1
mke2fs 1.41.12 (17-May-2010)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
134217728 inodes, 536870202 blocks
26843510 blocks (5.00%) reserved for the super user
First data block=0
Maximum filesystem blocks=4294967296
16384 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 
        4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, 
        102400000, 214990848, 512000000

Writing inode tables:  8874/16384&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 等待一小会后, 将出现下述提示, 说明格式化完成:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Writing inode tables: done                            
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information:  done

This filesystem will be automatically checked every 26 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;挂载新分区&quot;&gt;2.3 挂载新分区&lt;/h2&gt;
&lt;p&gt;(1) 创建目录, 并将 &lt;code&gt;/dev/sdb1&lt;/code&gt;挂在到该目录下:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost /]# mkdir data &amp;amp;&amp;amp; cd /data
[root@localhost data]# mount /dev/sdc1 /data1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 查看挂载是否成功:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost data]# df -l
Filesystem                   1K-blocks       Used  Available Use% Mounted on
/dev/mapper/VolGroup-LogVol  286901696   18601728  253726196   7% /
tmpfs                         66020980          0   66020980   0% /dev/shm
/dev/sda1                       495844      33476     436768   8% /boot

# 挂载成功: 
/dev/sdb1                   2113784984     202776 2006208168   1% /data&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设置开机自动挂载&quot;&gt;2.4 设置开机自动挂载&lt;/h2&gt;
&lt;p&gt;编辑文件 &lt;code&gt;/etc/fstab&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost data]# vim /etc/fstab

# 文件内容如下: 
# /etc/fstab
# Created by anaconda on Wed Sep 12 10:41:40 2018
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/VolGroup-LogVol  /                     ext4    defaults        1 1
/dev/sdb1                    /data                 ext4    defaults        1 1
UUID=22b1d425-d050-43c3-a735-06d48bbb9051 /boot    ext4    defaults        1 2 
tmpfs                        /dev/shm              tmpfs   defaults        0 0
devpts                       /dev/pts              devpts  gid=5,mode=620  0 0
sysfs                        /sys                  sysfs   defaults        0 0
proc                         /proc                 proc    defaults        0 0&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;查看磁盘容量信息&quot;&gt;3.1 查看磁盘容量信息&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# df -h
Filesystem               Size  Used  Avail  Use%  Mounted on
/dev/mapper/VG-LogVol    1.9T  1.8T    61G   97%  /          # LVM卷组-逻辑卷
tmpfs                     63G     0    63G    0%  /dev/shm
/dev/sda1                485M   40M   421M    9%  /boot&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看磁盘扇区信息&quot;&gt;3.2 查看磁盘扇区信息&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# fdisk -l

Disk /dev/sda: 299.0 GB, 298999349248 bytes         # 磁盘/dev/sda
255 heads, 63 sectors/track, 36351 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x4d69fe0e

   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1          26      204800   83  Linux       # 分为2个区, sda1
Partition 1 does not end on cylinder boundary.
/dev/sda2              26       36352   291785728   8e  Linux LVM   # LVM类型的sda2

# 新添加的磁盘/dev/sdb, 没有分区
Disk /dev/sdb: 4000.0 GB, 3999999721472 bytes
255 heads, 63 sectors/track, 486305 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000

# LVM格式的卷组信息: 
Disk /dev/mapper/VolGroup-LogVol: 4294 MB, 4294967296 bytes
255 heads, 63 sectors/track, 522 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x00000000&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建分区&quot;&gt;3.3 创建分区&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# fdisk /dev/sdb
Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel
Building a new DOS disklabel with disk identifier 0x5b3d66ba.
Changes will remain in memory only, until you decide to write them.
After that, of course, the previous content won't be recoverable.

Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)

WARNING: The size of this disk is 4.0 TB (3999999721472 bytes).
DOS partition table format can not be used on drives for volumes
larger than (2199023255040 bytes) for 512-byte sectors. Use parted(1) and GUID 
partition table format (GPT).


WARNING: DOS-compatible mode is deprecated. It's strongly recommended to
         switch off the mode (command 'c') and change display units to
         sectors (command 'u').

Command (m for help): n         # 添加分区
Command action
   e   extended
   p   primary partition (1-4)
p                               # 添加主分区
Partition number (1-4): 1       # 1号主分区, 即/dev/sdb1
First cylinder (1-486305, default 1):               
Using default value 1
Last cylinder, +cylinders or +size{K,M,G} (1-267349, default 267349): 486305
Value out of range.
Last cylinder, +cylinders or +size{K,M,G} (1-267349, default 267349): 
Using default value 267349

Command (m for help): n         # 继续添加分区
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 2       # 2号主分区, 即/dev/sdc2
First cylinder (267350-486305, default 267350): 
Using default value 267350
Last cylinder, +cylinders or +size{K,M,G} (267350-486305, default 486305): 
Using default value 486305

Command (m for help): p         # 打印分区信息: 

Disk /dev/sdb: 4000.0 GB, 3999999721472 bytes
255 heads, 63 sectors/track, 486305 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x5b3d66ba

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1      267349  2147480811   83  Linux
/dev/sdb2          267350      486305  1758764070   83  Linux

Command (m for help): t         # 转换类型
Partition number (1-4): 1
Partition number (1-4): 1           # 修改/dev/sdb1为Linux LVM类型: 
Hex code (type L to list codes): L  # 查看可用类型: 

 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        
 1  FAT12           39  Plan 9          82  Linux swap / So c1  DRDOS/sec (FAT-
 2  XENIX root      3c  PartitionMagic  83  Linux           c4  DRDOS/sec (FAT-
 3  XENIX usr       40  Venix 80286     84  OS/2 hidden C:  c6  DRDOS/sec (FAT-
 4  FAT16 &amp;lt;32M      41  PPC PReP Boot   85  Linux extended  c7  Syrinx         
 5  Extended        42  SFS             86  NTFS volume set da  Non-FS data    
 6  FAT16           4d  QNX4.x          87  NTFS volume set db  CP/M / CTOS / .
 7  HPFS/NTFS       4e  QNX4.x 2nd part 88  Linux plaintext de  Dell Utility   
 8  AIX             4f  QNX4.x 3rd part 8e  Linux LVM       df  BootIt         
 9  AIX bootable    50  OnTrack DM      93  Amoeba          e1  DOS access     
 a  OS/2 Boot Manag 51  OnTrack DM6 Aux 94  Amoeba BBT      e3  DOS R/O        
 b  W95 FAT32       52  CP/M            9f  BSD/OS          e4  SpeedStor      
 c  W95 FAT32 (LBA) 53  OnTrack DM6 Aux a0  IBM Thinkpad hi eb  BeOS fs        
 e  W95 FAT16 (LBA) 54  OnTrackDM6      a5  FreeBSD         ee  GPT            
 f  W95 Ext'd (LBA) 55  EZ-Drive        a6  OpenBSD         ef  EFI (FAT-12/16/
10  OPUS            56  Golden Bow      a7  NeXTSTEP        f0  Linux/PA-RISC b
11  Hidden FAT12    5c  Priam Edisk     a8  Darwin UFS      f1  SpeedStor      
12  Compaq diagnost 61  SpeedStor       a9  NetBSD          f4  SpeedStor      
14  Hidden FAT16 &amp;lt;3 63  GNU HURD or Sys ab  Darwin boot     f2  DOS secondary  
16  Hidden FAT16    64  Novell Netware  af  HFS / HFS+      fb  VMware VMFS    
17  Hidden HPFS/NTF 65  Novell Netware  b7  BSDI fs         fc  VMware VMKCORE 
18  AST SmartSleep  70  DiskSecure Mult b8  BSDI swap       fd  Linux raid auto
1b  Hidden W95 FAT3 75  PC/IX           bb  Boot Wizard hid fe  LANstep        
1c  Hidden W95 FAT3 80  Old Minix       be  Solaris boot    ff  BBT            
1e  Hidden W95 FAT1
Hex code (type L to list codes): 8e     # 修改为8e, 即Linux LVM类型
Changed system type of partition 1 to 8e (Linux LVM)

Command (m for help): t
Partition number (1-4): 2               # 修改/dev/sdc2为Linux LVM类型
Hex code (type L to list codes): 8e
Changed system type of partition 2 to 8e (Linux LVM)

Command (m for help): p                 # 再次查看相关信息: 

Disk /dev/sdc: 4000.0 GB, 3999999721472 bytes
255 heads, 63 sectors/track, 486305 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x5b3d66ba

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1               1      267349  2147480811   8e  Linux LVM   # Id已改变
/dev/sdb2          267350      486305  1758764070   8e  Linux LVM

Command (m for help): w                 # 保存并退出
The partition table has been altered!   # 修改成功

Calling ioctl() to re-read partition table.
Syncing disks.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建物理卷&quot;&gt;3.4 创建物理卷&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# pvcreate /dev/sdb1
  Physical volume &quot;/dev/sdb1&quot; successfully created
[root@localhost ~]# pvcreate /dev/sdb2
  Physical volume &quot;/dev/sdb2&quot; successfully created&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;扩展卷组&quot;&gt;3.5 扩展卷组&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 查看已有卷组, 发现该卷组就是需要扩容的卷组, 就不必再次创建卷组, 而是直接扩展卷组即可: 
[root@localhost ~]# vgs
  VG       #PV #LV #SN Attr   VSize VFree
  VolGroup   2   2   0 wz--n- 1.91t    0 

# 扩展卷组: 
[root@localhost ~]# vgextend VolGroup /dev/sdb1
  Volume group &quot;VolGroup&quot; successfully extended
[root@localhost ~]# vgextend VolGroup /dev/sdb2
  Volume group &quot;VolGroup&quot; successfully extended&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明: 如果出现下述无法挂载物理磁盘到卷组中的信息, 说明这块物理磁盘已经挂载了, 需要先卸载, 然后再执行创建分区+卷组的操作:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost /]# vgextend VolGroup /dev/sdb1 
  No physical volume label read from /dev/sdb1
  Physical volume /dev/sdb1 not found
  Can't open /dev/sdb1 exclusively.  Mounted filesystem?
  Unable to add physical volume '/dev/sdb1' to volume group 'VolGroup'.&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;扩展逻辑卷&quot;&gt;3.6 扩展逻辑卷&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 扩展逻辑卷, 即扩容: 
[root@localhost ~]# lvextend -l +100%FREE /dev/mapper/VolGroup-LogVol 
  Extending logical volume lv_root to 5.54 TiB
  Logical volume lv_root successfully resized

# 上述命令是将所有的空闲空间都扩容到逻辑卷中, 也可指定扩容的大小: 
lvextend -l +100G /dev/mapper/VolGroup-LogVol &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看磁盘卷组信息&quot;&gt;3.7 查看磁盘卷组信息&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[root@localhost ~]# lsblk 
NAME                        MAJ:MIN RM   SIZE RO  TYPE  MOUNTPOINT
sda                           8:0    0 278.5G  0  disk  
├─sda1                        8:1    0   500M  0  part  /boot
└─sda2                        8:2    0   278G  0  part  
  ├─VolGroup-LogVol (dm-0)  253:0    0   5.6T  0  lvm   /
sdb                           8:16   0   1.6T  0  disk  
└─sdb1                        8:17   0   1.6T  0  part  
  └─VolGroup-LogVol (dm-0)  253:0    0   5.6T  0  lvm   /
sdc                           8:32   0   3.7T  0  disk  
├─sdc1                        8:33   0     2T  0  part  
│ └─VolGroup-LogVol (dm-0)  253:0    0   5.6T  0  lvm   /
└─sdc2                        8:34   0   1.7T  0  part  
  └─VolGroup-LogVol (dm-0)  253:0    0   5.6T  0  lvm   /&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;调整文件系统的大小&quot;&gt;3.8 调整文件系统的大小&lt;/h2&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# CentOS 7重新读取磁盘大小: 
[root@localhost ~]# xfs_growfs /dev/mapper/VolGroup-LogVol 
xfs_growfs: /dev/mapper/VolGroup-LogVol is not a mounted XFS filesystem

# CentOS 6.5重新读取磁盘大小: 
# ext4格式, resize2fs会遍历整个磁盘, 速度比较慢, 但是不影响读写数据, 可以令其在后台运行. 
[root@localhost ~]# resize2fs /dev/mapper/VolGroup-LogVol 
resize2fs 1.41.12 (17-May-2010)
Filesystem at /dev/mapper/VolGroup-LogVol is mounted on /; on-line resizing required
old desc_blocks = 122, new_desc_blocks = 355
Performing an on-line resize of /dev/mapper/VolGroup-lv_root to 1487098880 (4k) blocks.

# 等了差不多20分钟, 出来了下面这货: 
 The filesystem on /dev/mapper/VolGroup-LogVol is now 1487098880 blocks long.
 
# 赶紧看下扩容成果吧: 
[root@localhost ~]#   df -h
Filesystem                    Size  Used Avail Use%  Mounted on
/dev/mapper/VolGroup-LogVol   5.5T  1.8T  3.5T  34%  /          # 扩容成功
tmpfs                          63G     0   63G   0%  /dev/shm
/dev/sda1                     485M   40M  421M   9%  /boot&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;附录---创建卷组&quot;&gt;3.9 附录 - 创建卷组&lt;/h2&gt;
&lt;p&gt;对应 [3.5] 节的扩展卷组, 如果卷组不存在, 则需要创建之. 下述VolGroup是卷组名称.&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vgcreate VolGroup /dev/sdb1
# 创建逻辑卷, 名称为: mylv. (操作系统中将产生: /dev/VolGroup/mylv目录)
# 将当前卷组中的100G空间分配到逻辑卷中
lvcreate -L 100G VolGroup -n mylv
# 或将当前卷组中的所有空闲空间全都分配到逻辑卷中:  
lvcreate -l +100%FREE VolGroup -n mylv

# 格式化逻辑卷组: 
mkfs -t ext4 /dev/VolGroup/mylv

# 挂载卷组到指定目录下, 如果是挂载到根目录, 则无需向/etc/fstab文件中添加启动项. 
mount -t ext4 /dev/VolGroup/mylv /data&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;1.0285714285714&quot;&gt;

&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/Jerry_1126/article/details/45769565&quot;&gt;Linux的LVM详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/macrossdzh/article/details/5973639&quot;&gt;ext2、ext3与ext4的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/tianlesoftware/article/details/5642883&quot;&gt;Linux 下挂载硬盘的方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/alylee/p/Linux_disk_management_partition_mount.html&quot;&gt;linux磁盘管理、新增磁盘、分区、挂载&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;16.040752351097&quot;&gt;

&lt;p&gt;作者: ma_shoufeng(马瘦风)&lt;/p&gt;
&lt;p&gt;出处: 博客园 &lt;a href=&quot;https://www.cnblogs.com/shoufeng&quot;&gt;马瘦风的博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;您的支持是对博主的极大鼓励, 感谢您的阅读.&lt;/p&gt;
&lt;p&gt;本文版权归博主所有, 欢迎转载, 但请保留此段声明, 并在文章页面明显位置给出原文链接, 否则博主保留追究相关人员法律责任的权利.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 28 Mar 2019 07:41:00 +0000</pubDate>
<dc:creator>马瘦风</dc:creator>
<og:description>Linux系统中如何挂载磁盘? 如何支持磁盘空间的动态扩容? LVM技术是做什么的? 本篇文章手把手教你用两种方式挂载磁盘, 欢迎交流^_^</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shoufeng/p/10615452.html</dc:identifier>
</item>
<item>
<title>Python 线程和进程和协程总结 - banananana</title>
<link>http://www.cnblogs.com/George1994/p/10615435.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/George1994/p/10615435.html</guid>
<description>&lt;h2&gt;&lt;span md-inline=&quot;plain&quot;&gt;线程和进程和协程&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span md-inline=&quot;plain&quot;&gt;进程&lt;/span&gt;&lt;/h3&gt;
&lt;ul cid=&quot;n3&quot; mdtype=&quot;list&quot; data-mark=&quot;*&quot; readability=&quot;2&quot;&gt;&lt;li cid=&quot;n84&quot; mdtype=&quot;list_item&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;进程是程序执行时的一个实例，是担当分配系统资源（CPU时间、内存等）的基本单位；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n88&quot; mdtype=&quot;list_item&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n86&quot; mdtype=&quot;paragraph&quot; md-p=&quot;&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n91&quot; mdtype=&quot;list_item&quot; readability=&quot;-1&quot;&gt;
&lt;p cid=&quot;n89&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;进程间可以通过信号、信号量、共享内存、管道、队列等来进行通信；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n94&quot; mdtype=&quot;list_item&quot; readability=&quot;-1&quot;&gt;
&lt;p cid=&quot;n92&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;进程创建、销毁、上下文切换带来的开销成本都很大；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span md-inline=&quot;plain&quot;&gt;线程&lt;/span&gt;&lt;/h3&gt;
&lt;ul cid=&quot;n4&quot; mdtype=&quot;list&quot; data-mark=&quot;*&quot; readability=&quot;-0.5&quot;&gt;&lt;li cid=&quot;n82&quot; mdtype=&quot;list_item&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;线程只是一个进程中的不同执行路径，没有单独的地址空间，一个线程死掉就会导致整个进程死掉。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n97&quot; mdtype=&quot;list_item&quot; readability=&quot;-1&quot;&gt;
&lt;p cid=&quot;n95&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;线程创建、销毁、上下文切换带来的开销要比进程小得多；&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span md-inline=&quot;plain&quot;&gt;协程&lt;/span&gt;&lt;/h3&gt;

&lt;blockquote cid=&quot;n108&quot; mdtype=&quot;blockquote&quot; readability=&quot;2.4324324324324&quot;&gt;
&lt;p cid=&quot;n196&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;具体使用参考&lt;/span&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;a spellcheck=&quot;false&quot; href=&quot;https://www.cnblogs.com/George1994/p/7352440.html&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Python 协程总结&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span md-inline=&quot;plain&quot;&gt;多线程和多进程&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span md-inline=&quot;plain&quot;&gt;多线程&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span md-inline=&quot;plain&quot;&gt;优点&lt;/span&gt;&lt;/h4&gt;
&lt;ol start=&quot;&quot; cid=&quot;n7&quot; mdtype=&quot;list&quot; readability=&quot;6&quot;&gt;&lt;li cid=&quot;n8&quot; mdtype=&quot;list_item&quot; readability=&quot;2&quot;&gt;
&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;它是一种非常&quot;节俭&quot;的多任务操作方式。我们知道，在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种&quot;昂贵&quot;的多任务工作方式。而运行于一个进程中的多个线程，它们彼此之间使用相同的地址空间，共享大部分数据，启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n10&quot; mdtype=&quot;list_item&quot; readability=&quot;2&quot;&gt;
&lt;p cid=&quot;n11&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;线程间方便的通信机制，对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进程下的线程之间共享数据空间，所以一个线程的数据可以直接为其它线程所用。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n12&quot; mdtype=&quot;list_item&quot; readability=&quot;2&quot;&gt;
&lt;p cid=&quot;n13&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;提高应用程序响应。这对图形界面的程序尤其有意义，当一个操作耗时很长时，整个系统都会等待这个操作，此时程序不会响应键盘、鼠标、菜单的操作，而使用多线程技术，将耗时长的操作（time consuming）置于一个新的线程，可以避免这种尴尬的情况。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li cid=&quot;n14&quot; mdtype=&quot;list_item&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;使多CPU系统更加有效。操作系统会保证当前线程数不大于CPU数目时，不同的线程运行于不同的CPU上。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;&lt;span md-inline=&quot;plain&quot;&gt;GIL&lt;/span&gt;&lt;/h3&gt;
&lt;p cid=&quot;n17&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;全局解释器锁是在实现Python解析器(CPython)时所引入的一个概念。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码。&lt;/span&gt;&lt;/p&gt;

&lt;p cid=&quot;n130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;Q&amp;amp;A&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;： 为什么说GIL对于CPU密集型任务不友好，而对于IO密集型任务比较友好呢？&lt;/span&gt;&lt;/p&gt;
&lt;p cid=&quot;n121&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这是因为GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放。而每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。&lt;/span&gt;&lt;/p&gt;
&lt;p cid=&quot;n126&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;那CPU密集型任务(各种循环处理、计数等等)，在这种情况下，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），但是对于IO密集型任务，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。因此说GIL对于CPU密集型任务不友好，而对于IO密集型任务比较友好。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;span md-inline=&quot;plain&quot;&gt;解决方案&lt;/span&gt;&lt;/h4&gt;
&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;multiprocessing库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷，它完整的复制了一套thread所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。当然multiprocessing也不是万能良药。它的引入会增加程序实现时线程间数据通讯和同步的困难。&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当至少有一个CPU密集型线程存在时，那么多线程效率会由于GIL而大幅下降，这个时候就得使用多进程；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span md-inline=&quot;plain&quot;&gt;多进程&lt;/span&gt;&lt;/h3&gt;
&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Python中的多线程因为GIL的关系并不算是真正的多线程，&lt;/span&gt;&lt;span md-inline=&quot;strong&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果想要充分地使用多核CPU的资源，大部分情况需要使用多进程。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;&gt;multiprocessing支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。&lt;/span&gt;&lt;/p&gt;

&lt;blockquote cid=&quot;n44&quot; mdtype=&quot;blockquote&quot; readability=&quot;0&quot;&gt;
&lt;p cid=&quot;n113&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;link&quot;&gt;&lt;a spellcheck=&quot;false&quot; href=&quot;https://zhuanlan.zhihu.com/p/20953544&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;谈谈python的GIL、多线程、多进程&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 28 Mar 2019 07:40:00 +0000</pubDate>
<dc:creator>banananana</dc:creator>
<og:description>Python 线程和进程和协程总结 线程和进程和协程 进程 进程是程序执行时的一个实例，是担当分配系统资源（CPU时间、内存等）的基本单位；进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/George1994/p/10615435.html</dc:identifier>
</item>
<item>
<title>泥瓦匠进阶：连接池原理设计并不难 - www.bysocket.com</title>
<link>http://www.cnblogs.com/Alandre/p/10615366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/10615366.html</guid>
<description>&lt;p&gt;摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！&lt;/p&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接&lt;/li&gt;
&lt;li&gt;连接池产生原因&lt;/li&gt;
&lt;li&gt;连接池实现原理&lt;/li&gt;
&lt;li&gt;小结&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;TEMPERANCE：Eat not to dullness；drink not to elevation.&lt;br/&gt;节制：食不过饱，饮不过量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;一、连接&lt;/h3&gt;
&lt;p&gt;什么是连接？&lt;br/&gt;连接，代表上游对下游的通信或会话。比如客户端连接服务器、服务器连接数据存储等&lt;/p&gt;
&lt;p&gt;连接其通信的基本步骤，很类似 HTTP 操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上游对下游建立一个连接（客户端与服务器需要建立连接。比如点击某个超级链接）&lt;/li&gt;
&lt;li&gt;上游通过连接，发送请求（建立连接后，客户端发送请求给服务器）&lt;/li&gt;
&lt;li&gt;上游通过连接，收到响应（服务器接到请求后，响应其响应信息）&lt;/li&gt;
&lt;li&gt;上游关闭连接，释放连接资源（客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2019/03/connection.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再深入点，HTTP 持久连接是什么？HTTP 持久连接是指用同一个 HTTP 底层的 TCP 连接来发送/接收多个 HTTP 请求/响应。扩展点，只需要在头部设置:&lt;/p&gt;
&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;Connection: Keep-Alive
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么要有持久连接？每次都是从建立连接开始也可以达到结果，并且最后是关闭连接释放资源。这就是引出连接池产生原因。&lt;/p&gt;
&lt;h3&gt;二、连接池产生原因&lt;/h3&gt;
&lt;p&gt;先看一下常见的 mysql-connector-java 包驱动下面 &lt;code&gt;ConnectionImpl&lt;/code&gt; 源码：&lt;/p&gt;
&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;trackConnection()

execSQL()
commit()

close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对 MySQL 多半是进行连接（connection），增删改查并提交（execSQL、commit），关闭连接（close）操作，然后实现业务相关逻辑。其操作也很清晰：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;建立连接&lt;/li&gt;
&lt;li&gt;发送请求（数据的 CRUD 操作）&lt;/li&gt;
&lt;li&gt;关闭连接&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但，为啥会需要有连接池？&lt;br/&gt;其实在业务量流量不大，并发量也不大的情况下，连接临时建立完全可以。&lt;br/&gt;但并发量起来，达到百级、千级，其中建立连接、关闭连接的操作会造成性能瓶颈，所以得考虑连接池来优化上述 1 和 3 操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;取出连接（业务服务启动时，初始化若干个连接，放在连接存储中）&lt;/li&gt;
&lt;li&gt;发送请求（当有请求，从连接存储中中取出）&lt;/li&gt;
&lt;li&gt;放回连接（执行完毕，连接放回连接存储中）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里对连接存储的数据结构，并维护连接，就是连接池。&lt;/p&gt;
&lt;h3&gt;三、连接池实现原理&lt;/h3&gt;
&lt;p&gt;连接池原理，可以具体看下阿里巴巴 Druid 包的 &lt;code&gt;DruidDataSource&lt;/code&gt; 源码：&lt;/p&gt;
&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;
&lt;code class=&quot;language-java hljs&quot;&gt;DruidConnectionHolder[] connections;

createConnection()
getConnection()
recycle()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接池实现原理也不难，DruidDataSource 即德鲁伊连接池，可以核心设计接口：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;createConnection：服务启动 init ，会创建一批指定数量的连接放入 connections 数组&lt;/li&gt;
&lt;li&gt;getConnection：这样每次请求，不会新建一个连接。而是从 DruidConnectionHolder[] connections 数组中取出一个连接&lt;/li&gt;
&lt;li&gt;recycle：每次请求结束后，不是关闭连接，而是回收连接到 connections 数组&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其中有个重入锁 ReetrantLock，具体作用如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;获取一个连接，锁住&lt;/li&gt;
&lt;li&gt;返回该连接，使用连接&lt;/li&gt;
&lt;li&gt;使用完毕，回收连接，并释放锁&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2019/03/pool.jpeg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;四、小结&lt;/h3&gt;
&lt;p&gt;核心连接池也就这么点东西，具体还需要考虑其他点如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连接池连接设计遵守 LRU 策略，性能的关键点是连接是否 LRU 方式重用。LRU 资料：https://yq.aliyun.com/articles/70456&lt;/li&gt;
&lt;li&gt;通过 Hash 去连接，实现串行化&lt;/li&gt;
&lt;li&gt;可以自动扩容连接数&lt;/li&gt;
&lt;li&gt;连接数过多，可以自动关闭连接，释放资源&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;div readability=&quot;7&quot;&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2017/01/qrcode_for_gh_cd421e7eb7d6_430.jpg&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;224&quot;/&gt; &lt;br/&gt;（关注微信公众号，领取 Java 精选干货学习资料）&lt;/div&gt;
</description>
<pubDate>Thu, 28 Mar 2019 07:35:00 +0000</pubDate>
<dc:creator>www.bysocket.com</dc:creator>
<og:description>摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！ 目录 连接 连接池产生原因 连接池实现原理 小结 TEMPER</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alandre/p/10615366.html</dc:identifier>
</item>
<item>
<title>Spring Boot Web 自定义注解篇（注解很简单很好用） - 我是2货呀</title>
<link>http://www.cnblogs.com/jay-wu/p/10615267.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-wu/p/10615267.html</guid>
<description>&lt;p&gt;自从spring 4.0 开放以后，可以添加很多新特性的注解了。使用系统定义好的注解可以大大方便的提高开发的效率。&lt;/p&gt;
&lt;p&gt;下面我贴一段代码来讲解注解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201903/1531118-20190328145833942-1771433235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过小小的注解我们支持了以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使 &lt;code&gt;spring.jackson.date-format&lt;/code&gt; 属性支持 &lt;code&gt;JDK8&lt;/code&gt; 日期格式化&lt;/li&gt;
&lt;li&gt;解决 &lt;code&gt;request.getInputStream()&lt;/code&gt; 一次读取后失效痛点&lt;/li&gt;
&lt;li&gt;国际化支持&lt;/li&gt;
&lt;li&gt;全局跨域支持&lt;/li&gt;
&lt;li&gt;接口加密/解密&lt;/li&gt;
&lt;li&gt;防XSS攻击&lt;/li&gt;
&lt;li&gt;分布式限流/分布式锁支持&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通过自定义@EnableCorsFilter 来看一下跨域是如何支持的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.battcn.boot.request.annotation;

import com.battcn.boot.request.configuration.cors.CorsFilterAutoConfiguration;
import org.springframework.context.annotation.Import;

import java.lang.annotation.*;

/**
 * 开启跨域支持
 *
 * @author Levin
 * @since 2019-01-01
 */
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import({CorsFilterAutoConfiguration.class})
public @interface EnableCorsFilter {

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。 &lt;br/&gt;如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。　&lt;/p&gt;

&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
CorsFilterAutoConfiguration类（具体实现）
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.battcn.boot.request.configuration.cors;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;

import static com.battcn.boot.request.utils.StringUtils.defaultString;

/**
 * Cors 跨域支持
 *
 * @author Levin
 * @since 2017/12/5 0005
 */
@Configuration
@EnableConfigurationProperties(value = {CorsFilterProperties.class})
public class CorsFilterAutoConfiguration {

    private static final String PATH = &quot;/**&quot;;

    private final CorsFilterProperties properties;

    @Autowired
    public CorsFilterAutoConfiguration(CorsFilterProperties properties) {
        this.properties = properties;
    }


    private CorsConfiguration buildConfig() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        corsConfiguration.addAllowedOrigin(defaultString(properties.getOrigin(), CorsConfiguration.ALL));
        corsConfiguration.addAllowedHeader(defaultString(properties.getAllowedHeader(), CorsConfiguration.ALL));
        corsConfiguration.addAllowedMethod(defaultString(properties.getMethod(), CorsConfiguration.ALL));
        // 是否发送 Cookie 信息
        corsConfiguration.setAllowCredentials(properties.getAllowCredentials());
        if (properties.getMaxAge() != null) {
            corsConfiguration.setMaxAge(properties.getMaxAge());
        }
        if (properties.getExposedHeader() != null) {
            corsConfiguration.addExposedHeader(properties.getExposedHeader());
        }
        return corsConfiguration;
    }

    /**
     * 跨域过滤器
     *
     * @return Cors过滤器
     */
    @Bean
    @ConditionalOnMissingBean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration(defaultString(properties.getPath(), PATH), buildConfig());
        return new CorsFilter(source);
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;br/&gt;@ConditionalOnMissingBean 属性相同，自动生成加载&lt;p&gt;@Configuration   Ioc加载到bean里&lt;/p&gt;&lt;p&gt;&lt;em&gt;@EnableConfigurationProperties   加载class配置项&lt;/em&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;@ConfigurationProperties  加载具体的配置参数&lt;/em&gt;CorsFilterProperties配置类&lt;/em&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
package com.battcn.boot.request.configuration.cors;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.lang.Nullable;

/**
 * Core 跨域相关配置
 *
 * @author Levin
 * @since 2017/12/5 0005
 */
@Data
@ConfigurationProperties(&quot;request.cors&quot;)
public class CorsFilterProperties {

    private Boolean enabled;
    private String path;
    private String origin;
    private String allowedHeader;
    private String method;
    private String exposedHeader;

    @Nullable
    private Boolean allowCredentials;

    @Nullable
    private Long maxAge;

}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; application.properties配置项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531118/201903/1531118-20190328150618844-1565272765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我在类属性里定义的maxAge，但是application里面显示的是max-age，会自动帮做转换，如果使用maxAge属性参数也是可以取到值的（是不是spring帮做了匹配查找）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;完成以上操作，只要在&lt;/em&gt;&lt;em&gt;SpringApplication 启动加上@&lt;/em&gt;EnableCorsFilter  就可以实现跨域了。&lt;/p&gt;

&lt;p&gt;maven调用以下是快速使用方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.battcn&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;request-spring-boot-starter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.0.8-RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;感谢唐亚峰提供的工具类。&lt;/p&gt;

</description>
<pubDate>Thu, 28 Mar 2019 07:23:00 +0000</pubDate>
<dc:creator>我是2货呀</dc:creator>
<og:description>自从spring 4.0 开放以后，可以添加很多新特性的注解了。使用系统定义好的注解可以大大方便的提高开发的效率。 下面我贴一段代码来讲解注解： 通过小小的注解我们支持了以下功能： 使 sp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jay-wu/p/10615267.html</dc:identifier>
</item>
<item>
<title>恢复mysql数据库误删数据 - nikeodong</title>
<link>http://www.cnblogs.com/nikeodong/p/10615058.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nikeodong/p/10615058.html</guid>
<description>&lt;pre&gt;
&lt;code&gt;某一天，天朗气清；突然传来消息：数据库被删库了！这简直不亚于8级大地震呀；一找原因，服务器宕机造成了数据库数据丢失。于是，通过日志恢复数据的救援开始了。&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;在数据库开启binlog功能&quot;&gt;在数据库开启binlog功能&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;找到/etc/my.cnf并编辑（没有my.cnf的时候就找my.ini）；添加
 log-bin=mysql-bin 
 expire_logs_days=7(日志保留天数)
然后重启mysql&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注意log_bin是生成的bin-log的文件名后缀则是6位数字的自增编码从000001开始&quot;&gt;注意：log_bin是生成的bin-log的文件名，后缀则是6位数字的自增编码，从000001开始：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;mysql_bin.000001 
mysql_bin.000002 
...... &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;操作日志&quot;&gt;操作日志&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;1、查看日志文件：
mysql&amp;gt; show master logs;
+------------------+--------------+
| Log_name         | File_size |
+------------------+-----------+
| mysql-bin.000001 | 120 |
| mysql-bin.000002 | 4249 |
| mysql-bin.000003 | 1110 |
+------------------+--------------+

2、查看最后一个binlog日志的编号名称(就是最后一个操作事件的值)：
mysql&amp;gt; show master status;
+------------------+----------+--------------+------------------+-------------------+
| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000003 |      1110 | | | |
+------------------+----------+--------------+------------------+-------------------+

3、产生一个新的日志文件
mysql&amp;gt; flush logs; 
Query OK, 0 rows affected (0.01 sec)
mysql&amp;gt; show master status;
+--------------+---------------+
|  Log_name   | File_size |
+--------------+---------------+
| mysql-bin.000004 |      106 |
+-----------------+------------+
4 rows in set (0.01 sec)

4、删除所有binlog日志,重新记录
mysql&amp;gt; reset master;
Query OK, 0 rows affected (0.01 sec)
mysql&amp;gt; show master status;
+--------------+---------------+
|  Log_name   | File_size |
+--------------+---------------+
| mysql-bin.000001 |      106 |
+-----------------+------------+
1 rows in set (0.01 sec)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;恢复数据&quot;&gt;恢复数据&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;恢复数据的方式有很多种，可以根据自己具体的情况来选择用哪种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;1、如果想全部恢复，先执行之前的备份恢复，再执行自备份后产生的二进制日志文件
    mysql localhost mysql-bin.000001 | mysql -uroot -p( 这样数据库就可以恢复到删除数据前的状态)

2、根据时间点来恢复，如果确认被删的时间点为2019-03-25 09:00:00，那么就可以如下
     mysqlbinlog --stop-date='2019-03-25 8:59:59' mysql-bin.000001 | mysql -uroot -p  然后跳过数据被删的时间点，继续执行后面的binlog  # mysqlbinlog --start-date='2019-03-25 09:01:00' mysql-bin.000001 | mysql -uroot -p  
     其中--stop-date='2019-03-25 08:59:59' 和--start-date='2019-03-25 09:01:00' 

3、如果知道两个时间点，就按如下操作
   mysqlbinlog --start-datetime=&quot;2019-03-25 10:30:30&quot; --stop-datetime=&quot;2019-03-25 11:10:10&quot; mysql-bin.000001 | mysql -u root -p

4、通过查看日志文件信息确认(假如操作点为6200-6300)
    mysqlbinlog --stop-position=6200 mysql-bin.000001 | mysql -uroot -p 
    mysqlbinlog --start-position=6300 mysql-bin.000001 | mysql -uroot -p
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;因为mysql的binlog是二进制文件一定要用mysqlbinlog命令才可以操作&quot;&gt;因为mysql的binlog是二进制文件，一定要用mysqlbinlog命令才可以操作。&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; 举例，导出sql文件：# mysqlbinlog  mysql-bin.000001 &amp;gt;test.sql &lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过这一次经历，知道了以后一定要做好数据库的备份；这很重要！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 28 Mar 2019 07:03:00 +0000</pubDate>
<dc:creator>nikeodong</dc:creator>
<og:description>前言 某一天，天朗气清；突然传来消息：数据库被删库了！这简直不亚于8级大地震呀；一找原因，服务器宕机造成了数据库数据丢失。于是，通过日志恢复数据的救援开始了。 正文 在数据库开启binlog功能 注意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nikeodong/p/10615058.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Config 使用总结 - 常三</title>
<link>http://www.cnblogs.com/DavidCQ/p/10614904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DavidCQ/p/10614904.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/ChangMuChen/Spring-Boot&quot; class=&quot;uri&quot; title=&quot;源码&quot;&gt;https://github.com/ChangMuChen/Spring-Boot&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一介绍&quot;&gt;一、介绍&lt;/h2&gt;
&lt;h3 id=&quot;spring-cloud-config&quot;&gt;Spring Cloud Config&lt;/h3&gt;
&lt;p&gt;Spring Cloud Config为分布式系统中的外部化配置提供服务器和客户端支持。使用Config Server，您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring Environment和PropertySource抽象，因此它们非常适合Spring应用程序，但可以与任何语言运行的任何应用程序一起使用。当应用程序通过部署管道从开发到测试并进入生产时，您可以管理这些环境之间的配置，并确保应用程序具有迁移时需要运行的所有内容。服务器存储后端的默认实现使用git，因此它可以轻松支持配置环境的标签版本，以及可用于管理内容的各种工具。添加替代实现并使用Spring配置插入它们很容易。&lt;/p&gt;
&lt;h3 id=&quot;spring-cloud-config-server功能&quot;&gt;Spring Cloud Config Server功能&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;用于外部配置的HTTP，基于资源的API（名称 值对或等效的YAML内容）&lt;/li&gt;
&lt;li&gt;加密和解密属性值（对称或非对称）&lt;/li&gt;
&lt;li&gt;使用可轻松嵌入Spring Boot应用程序&lt;/li&gt;
&lt;li&gt;可以轻松的结合Eureka实现高可用&lt;/li&gt;
&lt;li&gt;可以轻松的结合Spring Cloud Bus实现自动化持续集成&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;config-client功能适用于spring应用程序&quot;&gt;Config Client功能（适用于Spring应用程序)&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;绑定到Config Server并Environment使用远程属性源初始化Spring&lt;/li&gt;
&lt;li&gt;加密和解密属性值（对称或非对称）&lt;/li&gt;
&lt;li&gt;结合Eureka实现服务发现&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二基础使用&quot;&gt;二、基础使用&lt;/h2&gt;
&lt;h3 id=&quot;搭建服务端&quot;&gt;1. 搭建服务端&lt;/h3&gt;
&lt;p&gt;Step1. 新建Spring Boot项目 &lt;code&gt;configserver&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Step2. 引入主要依赖 &lt;code&gt;spring-cloud-config-server&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-config-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step3. 引入 &lt;code&gt;spring-boot-starter-web&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step4. 主程序添加注释 &lt;code&gt;@EnableConfigServer&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableConfigServer
public class ConfigserverApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigserverApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step5. 设置属性&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里使用 &lt;code&gt;.properties&lt;/code&gt; 的方式进行配置。你可以自行更换为同等效果的 &lt;code&gt;.yml&lt;/code&gt; 方式。配置信息需要放在 &lt;code&gt;bootstrap.properties&lt;/code&gt; 中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1）Git方式存储配置文件示例&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;#配置文件存放在Git的情况
spring.cloud.config.server.git.uri=http://172.16.50.98:9999/changdaohang/demo_configs.git
spring.cloud.config.label=master
spring.cloud.config.server.git.search-paths=/**
spring.cloud.config.server.git.username=username
spring.cloud.config.server.git.password=password&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2）本地存储配置文件&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;#配置文件存放在本地的情况
#注意：文件夹要有访问权限
spring.profiles.active=native
spring.cloud.config.server.native.search-locations=C:/IdeaProjets/demo_configs/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step6. 启动&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;h4 id=&quot;备注&quot;&gt;备注&lt;/h4&gt;
&lt;p&gt;我们可以直接通过restful api 的方式进行访问配置。路由如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#映射说明如下
#/{application}/{profile}[/{label}]
#/{application}-{profile}.yml
#/{label}/{application}-{profile}.yml
#/{application}-{profile}.properties
#/{label}/{application}-{profile}.properties&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：http://localhost:8080/testapp/dev 或 http://localhost:8080/testapp-dev.properties&lt;br/&gt;对应的配置为 &lt;code&gt;/testapp-dev.properties&lt;/code&gt;&lt;br/&gt;当你启动服务端，你可以在Mappings中看到接口开放情况，部分如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ChangMuChen/Spring-Boot/master/%E6%8E%A5%E5%8F%A3%E5%BC%80%E6%94%BE%E6%83%85%E5%86%B5.png&quot; alt=&quot;接口开放情况&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;业务服务配置&quot;&gt;2. 业务服务配置&lt;/h3&gt;
&lt;p&gt;Step1. 新建Spring Boot项目 &lt;code&gt;servera&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Step2. 引入主要依赖 &lt;code&gt;spring-cloud-starter-config&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-config&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step3. 引入 &lt;code&gt;spring-boot-starter-web&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step4. 主程序添加注释 &lt;code&gt;@EnableDiscoveryClient&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableDiscoveryClient
public class ServeraApplication {

    public static void main(String[] args) {
        SpringApplication.run(ServeraApplication.class, args);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step5. 创建配置文件&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以Git为例：&lt;br/&gt;在git项目中创建servera-dev.properties文件，写入以下示例内容：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;name=David&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step6. 配置参数&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里使用 &lt;code&gt;.properties&lt;/code&gt; 的方式进行配置。你可以自行更换为同等效果的 &lt;code&gt;.yml&lt;/code&gt; 方式。配置信息需要放在 &lt;code&gt;bootstrap.properties&lt;/code&gt; 中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;spring.application.name=servera
spring.cloud.config.label=master
spring.cloud.config.profile=dev
spring.cloud.config.uri=http://localhost:8071/&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：配置中 &lt;code&gt;servera&lt;/code&gt;值与 &lt;code&gt;dev&lt;/code&gt; 结合对应到 &lt;code&gt;servera-dev.properties&lt;/code&gt;文件，并且使用 &lt;code&gt;master&lt;/code&gt; 对应到Git中的 &lt;code&gt;master&lt;/code&gt; 分支。&lt;code&gt;http://localhost:8080/&lt;/code&gt; 为 配置中心服务地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Step7. 新建测试api&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;新建 &lt;code&gt;TestController&lt;/code&gt; 控制器，代码如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;api&quot;)
@RefreshScope
public class TestController {
   
    @Value(&quot;${name}&quot;)
    private String confignameValue;

    @GetMapping(&quot;/confignamevalue&quot;)
    @ResponseBody
    public String returnConfignameValue(){
        return confignameValue;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;说明：其中 &lt;code&gt;@RefreshScope&lt;/code&gt; 注解是以后为了自动更新配置用的。这里可以不加。&lt;br/&gt;通过 &lt;code&gt;@Value(&quot;${name}&quot;)&lt;/code&gt; 注解，可以对应到 &lt;code&gt;servera-dev.properties&lt;/code&gt; 中的 &lt;code&gt;name=David&lt;/code&gt; 键值对，并将值 &lt;code&gt;David&lt;/code&gt; 赋给 &lt;code&gt;confignameValue&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Step8. 启动程序&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;访问 &lt;code&gt;http://localhost:8081/api/confignamevalue&lt;/code&gt; 显示结果为：&lt;code&gt;David&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;到这里最基本的使用就完成了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三自动更新&quot;&gt;三、自动更新&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里介绍使用 &lt;em&gt;Monitor + Actuator + Bus + RabbitMQ + GitLab Webhooks&lt;/em&gt; 来实现当提交配置后，通知服务更新配置。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请自行搭建 &lt;code&gt;RabbitMQ&lt;/code&gt; 服务环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;配置中心服务端&quot;&gt;1. 配置中心服务端&lt;/h3&gt;
&lt;p&gt;Step1. 在&lt;code&gt;pom.xml&lt;/code&gt;中添加依赖：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-config-monitor&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;其中 &lt;code&gt;spring-boot-starter-actuator&lt;/code&gt; 整合了一些 &lt;code&gt;/bus-fresh&lt;/code&gt; 的接口，可以用于自主触发刷新服务配置。&lt;br/&gt;&lt;code&gt;spring-cloud-config-monitor&lt;/code&gt; 用于对接 gitlab 的webhooks，用于触发刷新服务配置。&lt;br/&gt;&lt;code&gt;spring-cloud-starter-bus-amqp&lt;/code&gt;用于对接rabbitMQ来广播服务更新事件，通知相关的服务进行配置更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Step2.配置参数&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在 &lt;code&gt;bootstrap.properties&lt;/code&gt; 中加入以下配置：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;#配置消息中心-rabbitmq

spring.rabbitmq.host=192.168.1.119
spring.rabbitmq.port=5672
spring.rabbitmq.username=username
spring.rabbitmq.password=password

#开放actuator下的所有功能api(你也可以选择性开放)
management.endpoints.web.exposure.include=*&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置客户端&quot;&gt;2. 配置客户端&lt;/h3&gt;
&lt;p&gt;Step1. 在&lt;code&gt;pom.xml&lt;/code&gt;中添加依赖：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-bus-amqp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;其中 &lt;code&gt;spring-boot-starter-actuator&lt;/code&gt; 配合服务端，处理服务端关播发来的配置更新事件。也可以用于自主触发刷新服务配置。&lt;br/&gt;&lt;code&gt;spring-cloud-starter-bus-amqp&lt;/code&gt;用于接收rabbitMQ消息，通知相关的服务进行配置更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Step2.配置参数&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在 &lt;code&gt;bootstrap.properties&lt;/code&gt; 中加入以下配置：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;#配置消息中心-rabbitmq

spring.rabbitmq.host=192.168.1.119
spring.rabbitmq.port=5672
spring.rabbitmq.username=username
spring.rabbitmq.password=password
#修复BUG-github webhook 只能刷新config server 无法刷新config client的问题
spring.cloud.bus.id=${vcap.application.name:${spring.application.name:application}}:${vcap.application.instance_index:${spring.cloud.config.profile:${local.server.port:${server.port:0}}}}:${vcap.application.instance_id:${random.value}}


#开放actuator下的所有功能api(你也可以选择性开放)
management.endpoints.web.exposure.include=*&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step3. 在控制器中添加 &lt;code&gt;@RefreshScope&lt;/code&gt; 注解，用于实时刷新&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;api&quot;)
@RefreshScope
public class TestController {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gitlab-webhooks配置&quot;&gt;3. GitLab Webhooks配置&lt;/h3&gt;
&lt;p&gt;Step1. 打开GitLab项目主页，依次进入【设置】-【集成】&lt;br/&gt;Step2. 添加WebHook.设置调用时机和回调地址：&lt;code&gt;http://192.168.1.28:8080/monitor?path=*&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/ChangMuChen/Spring-Boot/master/webhook.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Step3. 保存&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;path用于定位哪些服务应该更新配置。这里使用 * 来通知所有服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;测试&quot;&gt;4. 测试&lt;/h3&gt;
&lt;p&gt;Step1. 依次启动 &lt;code&gt;configserver&lt;/code&gt; 和 &lt;code&gt;servera&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Step2. 访问 &lt;code&gt;http://localhost:8081/api/confignamevalue&lt;/code&gt; 显示结果为：&lt;code&gt;David&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Step3. 修改gitlab 中的 &lt;code&gt;servera-dev.properties&lt;/code&gt; 为 &lt;code&gt;name=David Mu&lt;/code&gt; 并Commit&lt;/p&gt;
&lt;p&gt;Step4. 访问 &lt;code&gt;http://localhost:8081/api/confignamevalue&lt;/code&gt; 显示结果为：&lt;code&gt;David Mu&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这种方式服务有可能不会立马刷新配置，属于正常情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四高可用&quot;&gt;四、高可用&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里介绍使用 &lt;em&gt;Config + Eureka&lt;/em&gt; 来实现高可用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请自行搭建 &lt;code&gt;Eureka&lt;/code&gt; 服务环境。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;服务端配置&quot;&gt;1. 服务端配置&lt;/h3&gt;
&lt;p&gt;Step1. 引入 &lt;code&gt;spring-cloud-starter-netflix-eureka-client&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step2. 配置Eureka相关参数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;#设置程序基础配置
server.port=8080
spring.application.name=configserver

#eureka 配置
eureka.instance.hostname=127.0.0.1
eureka.instance.prefer-ip-address=true
eureka.instance.instance-id=${eureka.instance.hostname}:${server.port}
eureka.client.service-url.defaultZone=http://127.0.0.1:8061/eureka/,http://127.0.0.1:8062/eureka/,http://127.0.0.1:8063/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step3. 添加注解 &lt;code&gt;@EnableEurekaClient&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
@EnableConfigServer
@EnableEurekaClient
public class ConfigserverApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigserverApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;启动程序，在eureka注册中就可以看到服务已注册。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;客户端配置&quot;&gt;2. 客户端配置&lt;/h3&gt;
&lt;p&gt;Step1. 引入 &lt;code&gt;spring-cloud-starter-netflix-eureka-client&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
   &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step2. 配置Eureka相关参数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;#设置程序基础配置
server.port=8080
spring.application.name=configserver

#eureka 配置
eureka.instance.hostname=127.0.0.1
eureka.instance.prefer-ip-address=true
eureka.instance.instance-id=${eureka.instance.hostname}:${server.port}
eureka.client.service-url.defaultZone=http://127.0.0.1:8061/eureka/,http://127.0.0.1:8062/eureka/,http://127.0.0.1:8063/eureka/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Step3. 修改原来的参数，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;spring.cloud.config.label=master
spring.cloud.config.profile=dev
#启用服务发现
spring.cloud.config.discovery.enabled=true
#指定配置服务id
spring.cloud.config.discovery.service-id=CONFIGSERVER
#撤销原来的指向方式
#spring.cloud.config.uri=http://localhost:8071/&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 28 Mar 2019 06:46:00 +0000</pubDate>
<dc:creator>常三</dc:creator>
<og:description>Spring Cloud Config 使用总结 'https://github.com/ChangMuChen/Spring Boot' 一、介绍 Spring Cloud Config Sprin</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DavidCQ/p/10614904.html</dc:identifier>
</item>
<item>
<title>《HelloGitHub》第 36 期 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/10614776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/10614776.html</guid>
<description>&lt;p&gt;本期内容较多。本期共有 41 个项目：C# 项目（1），C++ 项目（1），CSS 项目（2），Go 项目（5），Java 项目（2），JavaScript 项目（5），Objective-C 项目（1），PHP 项目（2），Python 项目（7），Ruby 项目（1），Swift 项目（1），其它（6），开源书籍（2），机器学习（5）&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 就是帮你找到兴趣！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142358479-2095476762.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;分享 GitHub 上有趣、入门级的开源项目。&lt;/p&gt;
&lt;p&gt;这是一个面向&lt;strong&gt;编程新手&lt;/strong&gt;、&lt;strong&gt;热爱编程&lt;/strong&gt;、&lt;strong&gt;对开源社区感兴趣&lt;/strong&gt; 人群的月刊，月刊的内容包括：&lt;strong&gt;各种编程语言的项目&lt;/strong&gt;、&lt;strong&gt;让生活变得更美好的工具&lt;/strong&gt;、&lt;strong&gt;书籍、学习笔记、教程等&lt;/strong&gt;，这些开源项目大多都是非常容易上手，而且非常 Cool。主要是希望大家能动手用起来，加入到&lt;strong&gt;开源社区&lt;/strong&gt;中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;会编程的可以贡献代码&lt;/li&gt;
&lt;li&gt;不会编程的可以反馈使用这些工具中的 Bug&lt;/li&gt;
&lt;li&gt;帮着宣传你觉得优秀的项目&lt;/li&gt;
&lt;li&gt;Star 项目⭐️&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在浏览、参与这些项目的过程中，你将学习到&lt;strong&gt;更多编程知识&lt;/strong&gt;、&lt;strong&gt;提高编程技巧&lt;/strong&gt;、&lt;strong&gt;找到编程的乐趣&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;🎉 最后 &lt;a href=&quot;https://hellogithub.com&quot;&gt;HelloGitHub&lt;/a&gt; 这个项目就诞生了 🎉&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;3.5882352941176&quot;&gt;
&lt;p&gt;&lt;strong&gt;以下为本期内容&lt;/strong&gt;｜每个月 &lt;strong&gt;28&lt;/strong&gt; 号发布最新一期｜&lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub#%E5%86%85%E5%AE%B9&quot;&gt;点击查看往期内容&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;c-项目&quot;&gt;C# 项目&lt;/h4&gt;
&lt;p&gt;1、&lt;a href=&quot;https://github.com/kulics/xs&quot;&gt;xs&lt;/a&gt;：一个专注于简单的开源跨平台编程语言。这门语言的设计目标是改进阅读与编写效率，降低语法负担。让使用者能够把真正的注意力放在解决问题上，只需极少的代码就能优雅地表达逻辑。&lt;a href=&quot;https://github.com/kulics/xs/blob/master/book-zh/introduction.md&quot;&gt;中文手册&lt;/a&gt;，示例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# export namespace
\HelloWorld {
    System # import namespace
}
# package
program -&amp;gt; {
    # main function
    Main() -&amp;gt; () {
        # list
        greetings := {&quot;Hello&quot;, &quot;Hola&quot;, &quot;Bonjour&quot;,
                    &quot;Ciao&quot;, &quot;こんにちは&quot;, &quot;안녕하세요&quot;,
                    &quot;Cześć&quot;, &quot;Olá&quot;, &quot;Здравствуйте&quot;,
                    &quot;Chào bạn&quot;, &quot;您好&quot;}
        # for-each  
        @ item &amp;lt;- greetings {
            # switch
            ? item -&amp;gt; [ 0 &amp;lt;= 8 ] {
                prt(item) # call function
            } _ {
                # lambda
                prt( greetings.filter( {it -&amp;gt; it.len&amp;gt; 4} ) )
                &amp;lt;- @
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;c-项目-1&quot;&gt;C++ 项目&lt;/h4&gt;
&lt;p&gt;2、&lt;a href=&quot;https://github.com/Microsoft/calculator&quot;&gt;calculator&lt;/a&gt;：微软 Windows 系统预装的计算器工具开源了。该工具提供标准、科学、程序员计算器的功能，以及各种度量单位和货币之间的转换功能。实现语言为 C++ 代码并不复杂，快来看看微软工程师编写的代码吧！运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142419094-1433379047.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;css-项目&quot;&gt;CSS 项目&lt;/h4&gt;
&lt;p&gt;3、&lt;a href=&quot;https://github.com/chokcoco/CSS-Inspiration&quot;&gt;CSS-Inspiration&lt;/a&gt;：这里汇集了 CSS 的使用和学习的示例代码，展示不同 CSS 属性或者不同的课题使用 CSS 来解决的各种方法。&lt;a href=&quot;https://chokcoco.github.io/CSS-Inspiration/#/&quot;&gt;在线阅读地址&lt;/a&gt;包含代码实际展示样式&lt;/p&gt;
&lt;p&gt;4、&lt;a href=&quot;https://github.com/wenzhixin/bootstrap-table&quot;&gt;bootstrap-table&lt;/a&gt;：基于 Bootstrap 的 jQuery 表格插件，通过简单的设置就可以拥有强大的单选、多选、排序、分页、编辑、导出、过滤（扩展）等功能。示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;table data-toggle=&quot;table&quot;&amp;gt;
  &amp;lt;thead&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;th&amp;gt;Item ID&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Item Name&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Item Price&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/thead&amp;gt;
  &amp;lt;tbody&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;td&amp;gt;1&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;Item 1&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;$1&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;td&amp;gt;2&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;Item 2&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;$2&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142434178-249755568.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;go-项目&quot;&gt;Go 项目&lt;/h4&gt;
&lt;p&gt;5、&lt;a href=&quot;https://github.com/drone/drone&quot;&gt;drone&lt;/a&gt;：一个基于 Docker 的持续集成平台，使用 Go 语言编写&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142443409-539419790.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a href=&quot;https://github.com/etcd-io/etcd&quot;&gt;etcd&lt;/a&gt;：一个高可用的分布式键值数据库，k8s 全家桶标配的注册与发现服务。它采用 raft 一致性算法，基于 Go 语言实现。可以通过该项目了解、学习 raft 的实际应用场景&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 使用 etcd 的客户端存取键值对
$ etcdctl put mykey &quot;this is awesome&quot;
$ etcdctl get mykey&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、&lt;a href=&quot;https://github.com/google/pprof&quot;&gt;pprof&lt;/a&gt;：Go 语言的性能分析工具，可以用来调试 Go 程序的内存泄露、goroutine 泄露之类的问题。使用方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 安装
$ go get -u github.com/google/pprof
# 生成一个profile文件
$ pprof -top [你的golang程序二进制文件] profile.pb.gz
# 生成火焰图
$ pprof -web [你的golang程序二进制文件] profile.pb.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8、&lt;a href=&quot;https://github.com/quii/learn-go-with-tests&quot;&gt;learn-go-with-tests&lt;/a&gt;：通过单元测试学习 Go 语言。下载仓库源码后，进入对应目录。每一个小文件夹就是一个对应的 Go 项目，在里面&lt;code&gt;go test&lt;/code&gt;即可运行单元测试。由于是测试驱动开发，所以需要在你改动代码之后跑通单元测试才算学会通过。每一个对应的文件夹都有相应 Markdown 文字教程，比较浅显易懂。而且还有&lt;a href=&quot;https://studygolang.gitbook.io/learn-go-with-tests&quot;&gt;中文版&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;9、&lt;a href=&quot;https://github.com/aimerforreimu/AUXPI&quot;&gt;AUXPI&lt;/a&gt;：基于 API 的简单图床应用。整合了主流图床的 API，并且做了一个 GUI 用来管理，&lt;a href=&quot;https://github.com/aimerforreimu/AUXPI/wiki/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85%E8%84%9A%E6%9C%AC&quot;&gt;安装&lt;/a&gt;简单&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142458230-955367612.jpg&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;java-项目&quot;&gt;Java 项目&lt;/h4&gt;
&lt;p&gt;10、&lt;a href=&quot;https://github.com/Curzibn/Luban&quot;&gt;Luban&lt;/a&gt;：图片压缩是常见的问题，那么微信是如何处理图像的压缩？Luban（鲁班）就是通过在微信朋友圈发送近 100 张不同分辨率的图片，对比原图与微信压缩后的图片逆向推算出来的压缩算法。示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 同步调用
Flowable.just(photos)
    .observeOn(Schedulers.io())
    .map(new Function&amp;lt;List&amp;lt;String&amp;gt;, List&amp;lt;File&amp;gt;&amp;gt;() {
      @Override public List&amp;lt;File&amp;gt; apply(@NonNull List&amp;lt;String&amp;gt; list) throws Exception {
        // 同步方法直接返回压缩后的文件
        return Luban.with(MainActivity.this).load(list).get();
      }
    })
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142507751-1495059758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;11、&lt;a href=&quot;https://github.com/yacy/yacy_search_server&quot;&gt;yacy_search_server&lt;/a&gt;：一款采用了新的搜索方法的搜索引擎软件。 它不需要中央服务器，但它搜索的结果来自于独立的分布式网络。在这样的分布式网络中，没有任何一个实体可以决定列出的内容或结果出现的顺序。启动和关闭的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GNU/Linux 系统，启动：&lt;code&gt;./startYACY.sh&lt;/code&gt;、关闭：&lt;code&gt;./stopYACY.sh&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Windows 系统，启动：双击&lt;code&gt;startYACY.bat&lt;/code&gt;、 关闭：双击&lt;code&gt;stopYACY.bat&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Mac OS X 系统，请使用 Mac 应用程序，并像其他 Mac 应用程序那样启动或停止它（双击）&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;javascript-项目&quot;&gt;JavaScript 项目&lt;/h4&gt;
&lt;p&gt;12、&lt;a href=&quot;https://github.com/qianguyihao/Web&quot;&gt;Web&lt;/a&gt;：前端入门的图文教程，从 0-1 的过程。内容详细，对于新入行前端的同学有很多的帮助&lt;/p&gt;
&lt;p&gt;13、&lt;a href=&quot;https://github.com/ncform/ncform&quot;&gt;ncform&lt;/a&gt;：只需要配置相关参数，便可方便生成表单的UI组件，自带校验规则满足日常 90% 的要求。表单是 Web 应用中常见的组件，但是开发表单是一个重体力活，ncform 通过配置便可生成表单，极大的提高了开发效率&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142519927-8488111.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;14、&lt;a href=&quot;https://github.com/jdneo/vscode-leetcode&quot;&gt;vscode-leetcode&lt;/a&gt;：这是一个可以让用户在 VS Code 编辑器中，练习 LeetCode 习题的插件。支持：查看高票解答、提交答案、测试答案等。提高了刷题效率，助你在校招、社招中杀出重围。上班摸鱼刷题利器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142537892-481826054.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;15、&lt;a href=&quot;https://github.com/zhihu/griffith&quot;&gt;griffith&lt;/a&gt;：让流式播放变得简单。无论你视频格式是 &lt;code&gt;mp4&lt;/code&gt; 还是 &lt;code&gt;hls&lt;/code&gt;，Griffith 都能使用媒体源拓展（MSE）来实现分段加载等功能，提供在线视频播放。示例代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// yarn add griffith

import Player from 'griffith'

const sources = {
  hd: {
    play_url: 'https://zhstatic.zhihu.com/cfe/griffith/zhihu2018_hd.mp4',
  },
  sd: {
    play_url: 'https://zhstatic.zhihu.com/cfe/griffith/zhihu2018_sd.mp4',
  },
}

render(&amp;lt;Player sources={sources} &amp;gt;&amp;lt;/Player&amp;gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;16、&lt;a href=&quot;https://github.com/makegirlsmoe/makegirlsmoe_web&quot;&gt;makegirlsmoe_web&lt;/a&gt;：动漫角色图片生成工具。支持：选择发色、发型、眼睛、皮肤、微笑、风格等等特征生成二次元图片。自定义生成可爱的二次元头像，二次元界福音。&lt;a href=&quot;https://make.girls.moe/#/&quot;&gt;在线尝试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142745552-131001703.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;objective-c-项目&quot;&gt;Objective-C 项目&lt;/h4&gt;
&lt;p&gt;17、&lt;a href=&quot;https://github.com/kyleneideck/BackgroundMusic&quot;&gt;BackgroundMusic&lt;/a&gt;：macOS 音频工具，包含功能：自动暂停音乐、设置各个应用程序的音量、录制系统音频&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142756958-874143599.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;php-项目&quot;&gt;PHP 项目&lt;/h4&gt;
&lt;p&gt;18、&lt;a href=&quot;https://github.com/inhere/php-console&quot;&gt;php-console&lt;/a&gt;：使用简单，功能全面的 PHP 命令行应用库。提供控制台参数解析、命令运行、颜色风格输出、 用户信息交互等功能&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328143400231-150744822.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;19、&lt;a href=&quot;https://github.com/LucienShui/PasteMe&quot;&gt;PasteMe&lt;/a&gt;：快速分享文本、代码的网站项目。支持加密、一键复制、永久保存、阅后即焚等功能。&lt;a href=&quot;https://pasteme.cn/&quot;&gt;在线示例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142810691-1154619539.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;python-项目&quot;&gt;Python 项目&lt;/h4&gt;
&lt;p&gt;20、&lt;a href=&quot;https://github.com/FavioVazquez/ds-cheatsheets&quot;&gt;ds-cheatsheets&lt;/a&gt;：Python 在数据科学方面使用库的速查表，包含了 Pandas、Jupyter、SQL、Dask 等。虽然都是些基本的 API 调用，但是用来备忘和速查足以&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142822741-97397445.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;21、&lt;a href=&quot;https://github.com/Qix-/better-exceptions&quot;&gt;better-exceptions&lt;/a&gt;：更加友好、实用、漂亮的输出 Python 异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/521xueweihan/img/master/hellogithub/36/img/better-exceptions.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;22、&lt;a href=&quot;https://github.com/my8100/scrapydweb&quot;&gt;scrapydweb&lt;/a&gt;：Scrapy 爬虫管理平台，支持：Scrapyd 集群管理、日志可视化、定时任务、邮件通知、移动端 UI&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142837770-1111184436.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;23、&lt;a href=&quot;https://github.com/CriseLYJ/awesome-python-login-model&quot;&gt;awesome-python-login-model&lt;/a&gt;：该项目收集了各大网站登陆方式和部分网站的爬虫程序。登陆方式实现包含 selenium 登录、通过抓包直接模拟登录等。有助于新手研究、编写爬虫&lt;/p&gt;
&lt;p&gt;24、&lt;a href=&quot;https://github.com/nosarthur/gita&quot;&gt;gita&lt;/a&gt;：基于 Python 开发的管理 git 工具，使用后可在任何目录下代理执行 git 指令。同时支持同时显示多个 repo 的状态信息、本地分支与远程分支的关系等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142852486-1520336678.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;25、&lt;a href=&quot;https://github.com/plotly/dash&quot;&gt;dash&lt;/a&gt;：一款只用几百行 Python 代码就可以轻易实现数据分析可视化的利器，是目前 Python 社区数据可视化主要的工具之一。具有：使用简单、易于扩展、开发团队活跃等特点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142903954-1982424961.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;26、&lt;a href=&quot;https://github.com/NtesEyes/pylane&quot;&gt;pylane&lt;/a&gt;：一个基于 gdb 的 Python 进程注入和调试工具。通过 gdb trace Python 进程，然后在该进程的 Python vm 中动态地注入一段 Python 代码， 从而对一个运行中的 Python 进程执行一段任意的逻辑。更多 Python 调试经验，可阅读这篇&lt;a href=&quot;https://mp.weixin.qq.com/s/Mlhrp2E390EMD0ZfSaNFKw&quot;&gt;文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142918271-1474636456.gif&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;ruby-项目&quot;&gt;Ruby 项目&lt;/h4&gt;
&lt;p&gt;27、&lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;jekyll&lt;/a&gt;：强大的静态博客网站生成工具。无需数据库，可以通过 Markdown 和 Config 轻松生成一个静态博客。该项目十分成熟、社区活跃、拥有多种主题可供选择。最后可以通过 &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Page&lt;/a&gt; 把生成的博客免费部署上线。快速开始：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 安装 jekll：gem install bundler jekyll
2. 创建项目：jekyll new my-awesome-site
3. 进入新创建的项目：cd my-awesome-site
4. 本地运行：bundle exec jekyll serve
5. 本地访问地址：http://localhost:4000&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;swift-项目&quot;&gt;Swift 项目&lt;/h4&gt;
&lt;p&gt;28、&lt;a href=&quot;https://github.com/yagiz/Bagel&quot;&gt;Bagel&lt;/a&gt;：一个小型、原生的 iOS 网络调试工具。使用过程不需要配置证书、代理之类的东西。只需要 iOS 设备和 Mac 处于同一网络，就可以查看、监控 App 的网络流量等信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142930304-2098114544.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;其它&quot;&gt;其它&lt;/h4&gt;
&lt;p&gt;29、&lt;a href=&quot;https://github.com/easychen/howto-make-more-money&quot;&gt;howto-make-more-money&lt;/a&gt;：该项目介绍了程序员如何挣零花钱的姿势&lt;/p&gt;
&lt;p&gt;30、&lt;a href=&quot;https://github.com/oldratlee/translations&quot;&gt;translations&lt;/a&gt;：一些不错的英文资料、文章翻译项目&lt;/p&gt;
&lt;p&gt;31、&lt;a href=&quot;https://github.com/VincentSit/ChinaMobilePhoneNumberRegex&quot;&gt;ChinaMobilePhoneNumberRegex&lt;/a&gt;：一组匹配中国大陆手机号码的正则表达式&lt;/p&gt;
&lt;p&gt;32、&lt;a href=&quot;https://github.com/the-benchmarker/web-frameworks&quot;&gt;web-frameworks&lt;/a&gt;：该项目展示了不同编程语言的 Web 框架性能对比，持续更新。可以作为挑选 Web 框架的参照信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142942825-1897065710.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;33、&lt;a href=&quot;https://github.com/tonsky/FiraCode&quot;&gt;FiraCode&lt;/a&gt;：高逼格的具有编程连字的等宽字体，最适合在编程编辑器、IDE、终端中使用。十分酷的字体，可以增加写代码的欲望&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/201903/759200-20190328142953358-2061669622.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;34、&lt;a href=&quot;https://github.com/zhaoolee/ChromeAppHeroes&quot;&gt;ChromeAppHeroes&lt;/a&gt;：优秀、实用的 Chrome 插件集合。该项目还包含插件的中文的使用介绍，为的是让好的插件被更多人发现和使用&lt;/p&gt;
&lt;h4 id=&quot;开源书籍&quot;&gt;开源书籍&lt;/h4&gt;
&lt;p&gt;35、&lt;a href=&quot;https://github.com/jakevdp/PythonDataScienceHandbook&quot;&gt;PythonDataScienceHandbook&lt;/a&gt;：英文原版《Python Data Science Handbook》，该书对于希望或已经从事数据科学相关工作的 Python 工程师而言是重要的学习手册。&lt;a href=&quot;https://jakevdp.github.io/PythonDataScienceHandbook/&quot;&gt;在线阅读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;36、&lt;a href=&quot;https://github.com/ffhelicopter/Go42&quot;&gt;Go42&lt;/a&gt;：《Go语言四十二章经》Golang 入门书籍。书中作者总结了自己踩坑的经验总结和思考，&lt;a href=&quot;https://github.com/ffhelicopter/Go42/blob/master/SUMMARY.md&quot;&gt;在线阅读&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;机器学习&quot;&gt;机器学习&lt;/h4&gt;
&lt;p&gt;37、&lt;a href=&quot;https://github.com/ajbrock/BigGAN-PyTorch&quot;&gt;BigGAN-PyTorch&lt;/a&gt;：“Bye Bye TPU”，4 个 GPU 就能训练“史上最强” BigGAN！只需 4-8 个 GPU 即可训练，摆脱了算力束缚&lt;/p&gt;
&lt;p&gt;38、&lt;a href=&quot;https://github.com/clone95/Virgilio&quot;&gt;Virgilio&lt;/a&gt;：本资源库旨在为以下领域提供三种有机完整的学习路径：机器学习、商业智能、云计算。在此你将能够了解相关原理并且在项目实践中予以运用。如果仔细遵循这些学习路径，则可以从零开始构建完整的认识和获得始终可用的技能。事实上，这些学习路径不需要之前有相关知识，但基础编程和简单数学是理解和实践大多数相关概念的必要条件&lt;/p&gt;
&lt;p&gt;39、&lt;a href=&quot;https://github.com/vietnguyen91/QuickDraw&quot;&gt;QuickDraw&lt;/a&gt;：谷歌开发的一个流行的在线游戏，神经网络会猜测你在画什么。神经网络从每幅图画中学习，提高正确猜测涂鸦内容的能力。现在你可以基于这个仓库，用 Python 构建自己的 Quick Draw 游戏&lt;/p&gt;
&lt;p&gt;40、&lt;a href=&quot;https://github.com/thunlp/GNNPapers&quot;&gt;GNNPapers&lt;/a&gt;：自从卷积神级网络面世以来，大部分人将其应用在规则的空间结构数据当中，比如图像。但是现实中存在更多的并不具备规则的空间结构的数据，因此研究人员提出了处理这部分数据的网络模型-GNN。该项目列举了 GNN 方面的论文，较为全面，适合有一定基础的人阅读&lt;/p&gt;
&lt;p&gt;41、&lt;a href=&quot;https://github.com/deepfakes/faceswap&quot;&gt;faceswap&lt;/a&gt;：这个工具可以对图片和视频进行换脸。可以很方便地处理图片和视频，搞些有意思的事情&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;换种方式阅读&quot;&gt;换种方式阅读&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;网站：&lt;/strong&gt; https://hellogithub.com&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GitBook：&lt;/strong&gt; https://gitbook.hellogithub.com&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;声明&quot;&gt;声明&lt;/h2&gt;
&lt;p&gt;如果你发现了好玩、有意义的开源项目 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub/issues/new&quot;&gt;点击这里&lt;/a&gt; 分享你觉得有意思的项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎转载，请注明出处和作者，同时保留声明。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 28 Mar 2019 06:30:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>公告 本期内容较多。本期共有 41 个项目：C 项目（1），C++ 项目（1），CSS 项目（2），Go 项目（5），Java 项目（2），JavaScript 项目（5），Objective C 项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xueweihan/p/10614776.html</dc:identifier>
</item>
</channel>
</rss>