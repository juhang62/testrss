<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>跟我一起学Redis之Redis持久化必知必会 - Code综艺圈</title>
<link>http://www.cnblogs.com/zoe-zyq/p/14083918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zoe-zyq/p/14083918.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;Redis是出了名的速度快，那是因为在内存中进行数据存储和操作；如果仅仅是在内存中进行数据存储，那就会导致以下问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数据随进程退出而消失：当服务器断电或Redis Server进程退出时，内存肯定随之释放，最后数据也会丢失；可能有些小伙伴认为只是作为缓存，数据没有了，重新从数据库中读取放在里面即可，试想，如果是高并发场景，数据库岂不是压力很大；&lt;/li&gt;
&lt;li&gt;重要数据无法恢复：数据丢失之后无法进行恢复，对于一些重要的数据，只是存在Redis中，而没有存在关系型数据库，如果数据丢失便不可恢复；比如刷礼品排行榜，如果数据丢失，用户肯定不愿意的；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于Redis持久化在工作中和面试过程中是一个很重要的技术点，必用必考，接下来详细说说Redis持久化；&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;Redis针对数据持久化有两种方案，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;RDB(Redis DataBase)&lt;/strong&gt;：快照形式，即指定&lt;strong&gt;时间间隔&lt;/strong&gt;将Redis内存中的快照数据保存在物理磁盘上，数据保存在*.rdb文件中，以二进制的形式进行存储，恢复数据直接加载即可；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AOF(Append Only File)&lt;/strong&gt;：日志形式，即将每条&lt;strong&gt;写命令&lt;/strong&gt;以append-only模式记录在*.aof文件中，不能修改文件，只能进行追加；后续恢复数据自动执行日志文件中的命令即可恢复数据；&lt;/li&gt;
&lt;li&gt;混合就是RDB和AOF的结合；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两种方式都可以通过配置文件轻松搞定，来，咱们先从RDB开始；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;fork&lt;/strong&gt;：后续会频繁提到，简单解释一下，fork的作用是复制一个与当前进程一样的子进程，该子进程的所有数据都和原进程一致。&lt;/p&gt;
&lt;h4 id=&quot;rdb持久化&quot;&gt;RDB持久化&lt;/h4&gt;
&lt;p&gt;理论放到后面再说，先来看看实际操作，再来做总结；上次对配置文件简单进行说明，这次就直接找到快照那配置就行啦，先看看默认配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/LVMGQv7ca32F5PN.png&quot; alt=&quot;1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;&lt;/code&gt;进行条件配置，如果触发条件就自动进行RDB持久化操作。默认配置中包含以下三种条件，满足其中一个就自动保存数据到磁盘：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;save 900 1&lt;/code&gt;：900秒内(15分钟)至少有1个key的值进行修改；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;save 300 10&lt;/code&gt;：300秒内(五分钟)至少有10个key的值进行修改；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;save 60 10000&lt;/code&gt;：900秒内(1分钟)至少有10000个key的值进行修改；&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;测试验证&quot;&gt;测试验证&lt;/h5&gt;
&lt;p&gt;为了测试时间方便，将其中一个条件改为1分钟内有3个key的值修改了就进行持久化到磁盘，如下：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;先将原有的dump.rdb文件删除掉，避免影响测试效果；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改配置文件如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/o1L4OGQXpc7YyKw.png&quot; alt=&quot;image-20201202124046958&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用修改之后，指定该配置文件重启redis-server，然后开始测试；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/e8rvzZMAPDwYQ5f.png&quot; alt=&quot;image-20201202125318782&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尝试打开dump.rdb看看，咋一看是看不懂，但其实是有对应关系的，这里就不深究了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/MPEqLAHi15GuB9f.png&quot; alt=&quot;image-20201202181142589&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Redis强大吧，不知不觉的就把数据备份，主要是还不影响正常操作，上图中第四步中就有体现，主进程fork了子进程进行备份，主进程不参与备份持久化操作。既然备份文件有了，如何进行恢复数据呢？ &lt;strong&gt;redis-server在启动的时候自动将当前目录中的备份文件(dump.rdb)数据加载到内存中&lt;/strong&gt;；如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/exCnRarihG2vEp9.png&quot; alt=&quot;image-20201202140710879&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;rdb其他配置项&quot;&gt;RDB其他配置项&lt;/h5&gt;
&lt;p&gt;那为什么是dump.rdb文件？，为什么又是当前目录？，如果rdb备份文件写入失败了怎么办？这些通过配置文件中&lt;strong&gt;SNAPSHOTTING&lt;/strong&gt;部分都有详细的说明，并提供相关配置项进行设置，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;stop-writes-on-bgsave-error&lt;/strong&gt;：默认设置为yes，即当RDB备份数据失败时，Redis会停止接收数据，保证数据的一致性；如果对数据一致性要求不高的，可以将其进行关闭，设置为no，但推荐都开启；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rdbcompression&lt;/strong&gt;：默认设置为yes，开启压缩之后会采用LZF算法对备份文件dump.rdb进行压缩，但会消耗点CPU性能进行处理，但影响并不大，推荐都开启；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rdbchecksum&lt;/strong&gt;：默认设置为yes，即开启之后会对备份文件数据进行校验，但会消耗CPU性能，如果追求性能提高可以将其关闭，但影响也不大，推荐都开启；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dbfilename&lt;/strong&gt;：默认为dump.rdb，即默认的备份文件名为dump.rdb，可以通过这个配置进行修改；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dir&lt;/strong&gt;：默认为当前目录，即备份的文件存放的目录。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;rdb手动触发备份&quot;&gt;RDB手动触发备份&lt;/h5&gt;
&lt;p&gt;上面说到自动触发备份，其实在实际应用场景中，有些需求很急，如果要求等到满足条件备份完成之后才处理问题，间隔时间短还好点，如果间隔时间超过5分钟，估计等待处理问题的人要上房揭瓦啦；Redis同样为大家考虑到了，提供手动备份的方式，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;save&lt;/strong&gt;：直接执行save命令，但会阻塞主进程操作，只能等待备份完成之后才能进行其他处理；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;bgsave&lt;/strong&gt;：直接执行bgsave命令，主进程会fork一个子进程进行备份操作，不阻塞主进程；当数据过大时，可能会在fork的时候有短暂的耗时，但影响不大； 上面的自动备份其实最后也是bgsave这种模式。&lt;/li&gt;
&lt;li&gt;flushall：执行flushall命令会触发RBD备份，但是备份文件是空的，在本地测试一把就行了，没有任何意义，&lt;strong&gt;千万别在生产库上用&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;简单测试一下，删除dump.rdb文件，将配置文件恢复到默认值，然后指定配置文件重启redis-server，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/UHlWsy27SLzIa8v.png&quot; alt=&quot;image-20201202150850388&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;如何停止或禁用rdb快照自动备份&quot;&gt;如何停止或禁用RDB快照自动备份&lt;/h5&gt;
&lt;p&gt;可以通过配置文件的形式配置，也可以通过命令的形式进行关闭，但通过命令的方式，服务器重启之后就失效了，所以一般建议通过配置文件进行配置；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;配置文件方式&lt;/strong&gt;：去除所有关于save的配置，或者配置一个&lt;code&gt;save &quot;&quot;&lt;/code&gt;即可，重启redis-server；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命令方式&lt;/strong&gt;：在客户端中执行&lt;code&gt;config set save &quot;&quot;&lt;/code&gt;即可，但redis-server重启时就恢复默认值了；&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;rdb备份流程&quot;&gt;RDB备份流程&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/4SZleXyjDa39261.png&quot; alt=&quot;image-20201202164228149&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简要说明：&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当触发bgsave持久化时(满足配置条件或手动执行bgsave命令)，主进程fork一个子进程进行持久化操作，主进程不参与任何持久化IO操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为了不影响原有rdb文件的使用，子进程会将快照数据先写入到临时文件;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;当快照数据完全备份到临时文件时，就替换掉原有的rdb文件，从而得到最新数据的rdb文件；&lt;/p&gt;
&lt;p&gt;注：当执行sava命令的时候，会导致阻塞，只有等快照数据持久化完成之后，才能做其他事情；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;rdb持久化优缺点&quot;&gt;RDB持久化优缺点&lt;/h5&gt;
&lt;p&gt;每一项技术在解决已有问题的时候，肯定也会带来新问题，RDB用来解决持久化问题，那它有什么优缺点呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;RDB保存的数据文件比较紧凑，对比AOF来说，相同数据的文件大小比较小；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;大量数据持久化时速度相对AOF比较快；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;RDB中bgsave模式对主进程影响比较小，只有在主进程fork子进程的时候耗费资源，但影响不大；自动备份后台用的就是bgsave模式；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;RDB可能会丢失最后一次没有备份的数据，如果在最后一次没开始备份之前，服务器挂了，那最后一次的数据就没了；&lt;/li&gt;
&lt;li&gt;当数据量巨大时，主进程在fork子进程的时候，可能会导致稍微的卡顿；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;aof持久化&quot;&gt;AOF持久化&lt;/h4&gt;
&lt;p&gt;既然已经有了RDB持久化了，那为什么还得出一个AOF呢？从RDB的缺点来看，很大程度上是因为可能会丢失最后一次备份之前的数据，对于一些重要数据来说，是不能接受的。而AOF的出现，将数据丢失风险极大的降低。先不说那么多，实操一把再慢慢聊。&lt;/p&gt;
&lt;p&gt;AOF默认情况是没开启的，打开配置文件，为了不让RDB备份影响，这里暂时先将RDB备份禁用掉，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;禁用RDB备份：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/S4G8RL9oaVPE1AD.png&quot; alt=&quot;image-20201202175142028&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;开启AOF备份：根据上一篇文章提到的，先找到&lt;strong&gt;APPEND ONLY MODE&lt;/strong&gt;配置块，将AOF备份开启&lt;code&gt;appendonly yes&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/PAk718MEUKpazeB.png&quot; alt=&quot;image-20201202175511758&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;配置好了，指定配置文件重启redis-server，先来看看效果：&lt;/p&gt;
&lt;p&gt;当一启动redis-server的时候，appendonly.aof文件就已经生成了；来，咱们接着敲点命令，如下↓↓↓&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/GbMr8q9RE6yLc4T.png&quot; alt=&quot;image-20201202182017360&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;尝试打开appendonly.aof文件看看，和dump.rdp文件有什么不同；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/16LrpX9jYVyMdqT.png&quot; alt=&quot;image-20201202182417350&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;appendonly.aof只记录写命令，读命令不记录，而且记录方式是以追加的方式，所以速度相对比较快；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;同RDB一样，&lt;strong&gt;在redis-server重启时，自动加载AOF文件命令依次执行，最终将数据进行恢复&lt;/strong&gt;；&lt;/p&gt;
&lt;h5 id=&quot;aof其他配置项&quot;&gt;AOF其他配置项&lt;/h5&gt;
&lt;p&gt;这就是Redis的强大，针对每一个功能都可以通过配置项进行完成，使用非常方便；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;appendonly&lt;/strong&gt;：默认no，不开启AOF持久化；可以通过设置为yes开启；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;appendfilename&lt;/strong&gt;：默认appendonly.aof，代表生成的AOF日志文件名，可以更改；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;appendfsync&lt;/strong&gt;：默认everysec，设置同步命令到磁盘的策略，即默认每秒通过fsync进行一次命令同步到磁盘；有三种命令同步策略可以选择，如下：
&lt;ol&gt;&lt;li&gt;always：只要有写入命令就通过fsync同步到磁盘，数据完整性好，但效率不好；&lt;/li&gt;
&lt;li&gt;everysec：每秒通过fsync进行一次命令同步到磁盘，可能会导致一秒中数据的丢失，因为可能在命令还没同步的时候，机器挂掉等操作，但可接受；综合考虑，推荐使用这种策略；&lt;/li&gt;
&lt;li&gt;no：不同步，由操作系统处理，这种数据不能保证安全；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;auto-aof-rewrite-percentage&lt;/strong&gt;：默认100，搭配auto-aof-rewrite-min-size一起触发AOF文件重写策略，即默认当当前AOF文件大小是上次重写的两倍时才重写，为了避免比率达到触发条件，但文件很小就触发重写的情况，所以搭配auto-aof-rewrite-min-size设置AOF文件的最小重写大小；即当前AOF文件大小达到比率的同时文件大小不低于auto-aof-rewrite-min-size设置的值才触发重写；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;auto-aof-rewrite-min-size&lt;/strong&gt;：默认64mb，搭配auto-aof-rewrite-percentage使用；&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;aof触发重写&quot;&gt;AOF触发重写&lt;/h5&gt;
&lt;p&gt;当执行的写命令过多时，就会导致AOF文件过度增大，而对于一些重复性的命令存在AOF文件中是没有必要的，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/lN8OoKqP4c9G2EJ.png&quot; alt=&quot;image-20201202233318616&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中多次对a1这个Key进行多次写入，最终的值为10，可见如果AOF文件中只记录一条最终值的写命令岂不是最好，从而减少AOF文件的大小；这里文件大小肯定达不到自动触发重写的条件，这里就手动触发，然后再看看AOF文件内容，是否进行了优化，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/YSsi9Xf8wU4cA37.png&quot; alt=&quot;image-20201202234007490&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图可见，重写之后的AOF文件的确是我们自己想要，是不是觉得Redis更加牛X了；触发重写有以下两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自动触发：即当满足设置的&lt;strong&gt;auto-aof-rewrite-percentage&lt;/strong&gt;和&lt;strong&gt;auto-aof-rewrite-min-size&lt;/strong&gt;值会自动触发重写；&lt;/li&gt;
&lt;li&gt;手动触发：在客户端中执行&lt;strong&gt;bgrewriteaof&lt;/strong&gt;命令；&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;aof重写流程&quot;&gt;AOF重写流程&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/3p9MQVe5H48DFJd.png&quot; alt=&quot;image-20201203000648231&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简要说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当触发到重写AOF文件时，主进程fork一个子进程，子进程根据内存中的现有数据进行命令精简化，重写到新的AOF文件中；&lt;/li&gt;
&lt;li&gt;在子进程正在重写AOF文件时，如果有新的写命令，将其存放到重写缓冲区，同时也同步到原来的AOF文件；&lt;/li&gt;
&lt;li&gt;当子进程重写完成之后，通知主进程将重写缓冲区中的新命令写入到新AOF文件中，完成之后，用新的AOF文件将原来的AOF文件替换；&lt;/li&gt;
&lt;li&gt;最后得到优化之后的AOF文件，减少文件大小；&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;aof文件修复&quot;&gt;AOF文件修复&lt;/h5&gt;
&lt;p&gt;对于AOF文件内容的合法性怎么解决呢，有可能由于突然事件，比如宕机，导致AOF文件写入不完整；也有可能有人恶意添加不规范数据，redis会怎么处理呢？这里就模拟手动修改AOF文件，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/kO4hEQswpaRmyi3.png&quot; alt=&quot;image-20201203093037933&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据提示，使用&lt;code&gt;redis-check-aof --fix &amp;lt;filename&amp;gt;&lt;/code&gt;进行修复，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/12/03/1kFaXjr8ultv7AU.png&quot; alt=&quot;image-20201203110008592&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动图就不截了，小伙伴们试试去；还有redis也能对rdb文件修复，文中没有体现，但小伙伴记得去尝试一下，用redis-check-rdb这个工具即可，在windows版本中redis没有提供此工具，去linux用高点的版本实操一把。&lt;/p&gt;
&lt;h5 id=&quot;aof持久化优缺点&quot;&gt;AOF持久化优缺点&lt;/h5&gt;
&lt;p&gt;AOF的出现，是解决了RDB丢失最后一次没保存的数据，极大的降低了数据丢失的风险，但其也带来相关问题；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;降低数据丢失风险，如果丢失，最多一秒数据；&lt;/li&gt;
&lt;li&gt;以追加方式记录日志，速度快；&lt;/li&gt;
&lt;li&gt;自动优化AOF文件，文件过大时进行重写，精简AOF文件；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;相同大数据，AOF文件比RDB文件大，占用磁盘空间；&lt;/li&gt;
&lt;li&gt;对于大数据的恢复，速度没有RDB快；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;混合持久化&quot;&gt;混合持久化&lt;/h4&gt;
&lt;p&gt;在redis4.0之后，提供了混合持久化配置开启功能； 混合持久化就是结合RDB和AOF各自优点进行整合的持久化方案，从而解决使用AOF恢复数据较慢的问题；&lt;/p&gt;
&lt;p&gt;原理就是在AOF文件的前半段加入RDB快照数据，后面才是增量数据的命令记录；在配置文件中进行配置即可：&lt;code&gt;aof-use-rdb-preamble yes&lt;/code&gt;，高版本redis都默认开启这种混合持久化模式；&lt;/p&gt;
&lt;p&gt;优点：解决了单纯AOF恢复数据较慢的问题；&lt;/p&gt;
&lt;p&gt;缺点：不能兼容低版本redis场景；&lt;/p&gt;
&lt;h4 id=&quot;选择哪个持久化比较合适？&quot;&gt;选择哪个持久化比较合适？&lt;/h4&gt;
&lt;p&gt;如果需求对数据完整性要求不是很高，可以接受短时间数据丢失，RDB快照持久化方式是最好不过的选择；&lt;/p&gt;
&lt;p&gt;如果对数据完整性要求比较严格，使用AOF日志形式进行持久化比较合适；&lt;/p&gt;
&lt;p&gt;如果redis版本在4.0以上，可以使用混合持久化的方式，降低纯AOF文件的恢复数据的时间；&lt;/p&gt;
&lt;p&gt;如果仅仅是缓存，缓存数据也不重要，并发也不是很高，可以不用开启持久化；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注： 如果不是使用混合持久化，而是将RDB和AOF同时开启，redis-server恢复数据的时候会优先使用AOF文件进行数据恢复，因为AOF文件相对比较完整；&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;暂时就到这吧，后续遇到相关问题再来记录分享；这个知识点比较重要，所以小伙伴们一定要自己尝试一下哦；使用真的很简单，进行简单的配置就完事了，如果能知道其简单的原理，遇到问题就没那么苦恼；下次我们来聊redis的主从复制；&lt;/p&gt;
&lt;p&gt;一个被程序搞丑的帅小伙，关注&quot;Code综艺圈&quot;，跟我一起学~~~&lt;/p&gt;
</description>
<pubDate>Fri, 04 Dec 2020 00:44:00 +0000</pubDate>
<dc:creator>Code综艺圈</dc:creator>
<og:description>前言 Redis是出了名的速度快，那是因为在内存中进行数据存储和操作；如果仅仅是在内存中进行数据存储，那就会导致以下问题： 数据随进程退出而消失：当服务器断电或Redis Server进程退出时，内存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zoe-zyq/p/14083918.html</dc:identifier>
</item>
<item>
<title>树状数组3种基本操作 - H-K-H</title>
<link>http://www.cnblogs.com/H-K-H/p/14083914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/H-K-H/p/14083914.html</guid>
<description>&lt;p&gt;本博客是由一个蒟蒻编写，内容可能出错，若发现请告诉本蒟蒻，以便大众阅读&lt;br/&gt;&lt;strong&gt;转载请注明原网址：&lt;a href=&quot;https://www.cnblogs.com/H-K-H/p/14083914.html&quot;&gt;https://www.cnblogs.com/H-K-H/p/14083914.html&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;s&gt;众所周知，&lt;/s&gt; 线段树和树状数组是兄弟来的&lt;/p&gt;
&lt;h2 id=&quot;它们之间的关系&quot;&gt;它们之间的关系&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;树状数组可以解的，线段树能解&lt;br/&gt;树状数组不可以解的，线段树还是可以解&lt;/em&gt;&lt;br/&gt;既然这样，那我学会线段树不就搞定了吗，干嘛还学树状数组呀&lt;/p&gt;
&lt;h2 id=&quot;那么，树状数组优在何处呢？&quot;&gt;那么，树状数组优在何处呢？&lt;/h2&gt;
&lt;p&gt;其实呢，就是&lt;mark&gt;码量少，思维清晰&lt;/mark&gt;吧&lt;br/&gt;对比一下&lt;br/&gt;单点修改区间查询&lt;br/&gt;线段树100行起步&lt;br/&gt;树状数组呢，50行左右吧&lt;br/&gt;区间修改区间查询&lt;br/&gt;线段树估计要飙到150了吧&lt;br/&gt;树状数组依旧50行&lt;br/&gt;没有对比就没有伤害呀&lt;br/&gt;这时，有些线段树忠实粉或许会思考人生：&lt;strong&gt;你看我还有机会吗？&lt;/strong&gt;&lt;br/&gt;机会是有的，那就是，打树状数组吧（当然有些题还是要打线段树的啦）&lt;/p&gt;

&lt;h2 id=&quot;树状数组图解&quot;&gt;树状数组图解&lt;/h2&gt;
&lt;p&gt;此章节内容部分引用自&lt;a href=&quot;https://bestsort.cn/2019/04/26/195/&quot;&gt;&lt;strong&gt;bestsort的小站&lt;/strong&gt;&lt;/a&gt;&lt;br/&gt;众所周知，一棵满二叉树长样：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200726201132496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xaWF9seng=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;挪一下位置后，变成了这样&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200726201326208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xaWF9seng=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;上面这个就是树状数组的画法&lt;br/&gt;准确来说，这时求和数组的画法&lt;br/&gt;把原数组&lt;span class=&quot;math inline&quot;&gt;\(a\)&lt;/span&gt;也加进来，成了这样（&lt;span class=&quot;math inline&quot;&gt;\(c\)&lt;/span&gt;是求和数组）&lt;img src=&quot;https://img-blog.csdnimg.cn/202007262017285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xaWF9seng=,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(c[i]\)&lt;/span&gt;表示子树叶子节点的权值&lt;br/&gt;如上图，有&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(c[1]=a[1]\\ c[2]=a[1]+a[2]\\ c[3]=a[3]\\ c[4]=a[1]+a[2]+a[3]+a[4]\\ c[5]=a[5]\\ c[6]=a[5]+a[6]\\ c[7]=a[7]\\ c[8]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8]\)&lt;/span&gt;&lt;br/&gt;转换成二进制再来看一眼&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(c[1]=c[0001]=a[1]\\ c[2]=c[0010]=a[1]+a[2]\\ c[3]=c[0011]=a[3]\\ c[4]=c[0100]=a[1]+a[2]+a[3]+a[4]\\ c[5]=c[0101]=a[5]\\ c[6]=c[0110]=a[5]+a[6]\\ c[7]=c[0111]=a[7]\\ c[8]=c[1000]=a[1]+a[2]+a[3]+a[4]+a[5]+a[6]+a[7]+a[8]\)&lt;/span&gt;&lt;br/&gt;对照式子可以发现，对于一个&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(c[i]=a[i-2^k+1]+a[i-2^k+2]+a[i-2^k+3]……+a[i]\)&lt;/span&gt;（&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;为二进制下&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;最低位的1后面的0的个数,例如8对应的&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;就等于3，因为&lt;span class=&quot;math inline&quot;&gt;\(8_{10}=1000_2\)&lt;/span&gt;，最低位的1后面有3个0）&lt;br/&gt;这时候，问题就来了，&lt;span class=&quot;math inline&quot;&gt;\(2^k\)&lt;/span&gt;怎么求？？？&lt;/p&gt;
&lt;h2 id=&quot;引入&quot;&gt;引入&lt;span class=&quot;math inline&quot;&gt;\(lowbit\)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(lowbit\)&lt;/span&gt;函数就是用来求&lt;span class=&quot;math inline&quot;&gt;\(2^k\)&lt;/span&gt;是多少的&lt;br/&gt;具体操作是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int lowbit(int x) {return x&amp;amp;(-x);}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释&lt;br/&gt;“&amp;amp;”这个符号在C++中指的是&lt;strong&gt;按位与&lt;/strong&gt;运算，具体是说，若在二进制下相同的位置两数都为1，那么&amp;amp;出的答案这一位也为1，否则为0&lt;br/&gt;例如&lt;span class=&quot;math inline&quot;&gt;\(12\&amp;amp;6\)&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(12_{10}=1100_2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(6_{10}=0110_2\)&lt;/span&gt;（空位用0补齐）&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(ans=0100_2=4_{10}\)&lt;/span&gt;&lt;br/&gt;在上面这个数据中，12和6只有第三个位置上才&lt;strong&gt;都是&lt;/strong&gt;1，那么答案也就只有这个位置上是1&lt;br/&gt;&lt;s&gt;（ 不过学树状数组的人应该都不会不知道位运算吧）&lt;/s&gt;&lt;br/&gt;那么&lt;span class=&quot;math inline&quot;&gt;\(x\&amp;amp;(-x)\)&lt;/span&gt;是什么意思呢&lt;br/&gt;首先说明&lt;span class=&quot;math inline&quot;&gt;\(-x\)&lt;/span&gt;在二进制下和&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的关系&lt;br/&gt;在二进制下，&lt;span class=&quot;math inline&quot;&gt;\(-x\)&lt;/span&gt;就是&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;取反后再加1&lt;br/&gt;例如，&lt;span class=&quot;math inline&quot;&gt;\(10_{10}=01010_2\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(-10_{10}=10101_2+1_2=10110_2\)&lt;/span&gt;（第一位是符号位）&lt;br/&gt;进行按位与运算后，答案就是&lt;span class=&quot;math inline&quot;&gt;\(00010_2=2^1=2_{10}\)&lt;/span&gt;（第一位是符号位）&lt;br/&gt;眼睛扫一扫，发现答案就是&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;&lt;br/&gt;神奇吧&lt;br/&gt;具体证明呢，我也不会，嘻嘻（毕竟我只是一个蒟蒻）&lt;/p&gt;

&lt;h2 id=&quot;1单点修改，区间查询&quot;&gt;1.单点修改，区间查询&lt;/h2&gt;
&lt;h3 id=&quot;修改&quot;&gt;修改&lt;/h3&gt;
&lt;p&gt;若要更新当前节点的&lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt;&lt;br/&gt;那么是不是可以直接更新&lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt;的上级，&lt;span class=&quot;math inline&quot;&gt;\(a[i]\)&lt;/span&gt;上级的上级，以此类推&lt;br/&gt;用&lt;span class=&quot;math inline&quot;&gt;\(lowbit\)&lt;/span&gt;到上级所在下标&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void update(int now,int x)
{
        int i;
        for (i=now;i&amp;lt;=n;i+=lowbit(i))
                c[i]+=x;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查询&quot;&gt;查询&lt;/h3&gt;
&lt;p&gt;对于区间查询，我们采取前缀和的求法&lt;br/&gt;对于一个区间&lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt;，我们求出&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;的前缀和，减去&lt;span class=&quot;math inline&quot;&gt;\(l-1\)&lt;/span&gt;的前缀和即为答案&lt;br/&gt;查询的具体过程呢，也很简单&lt;br/&gt;就是从要查的节点以此往下，搜索下级&lt;br/&gt;依旧是用&lt;span class=&quot;math inline&quot;&gt;\(lowbit\)&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;int get(int x)
{
        int i,ans;
        ans=0;
        for (i=x;i&amp;gt;=1;i-=lowbit(i))
                ans+=c[i];
        return ans;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;题目&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://loj.ac/problem/130&quot;&gt;Loj#130 树状数组 1 ：单点修改，区间查询&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;iostream&amp;gt;
using namespace std;
long long n,m,i,x,y,ch,c[1000005];
long long lowbit(long long x)
{
        return x&amp;amp;(-x);
}
void update(long long now,long long x)
{
        long long i;
        for (i=now;i&amp;lt;=n;i+=lowbit(i))
                c[i]+=x;
}
long long get(long long x)
{
        long long i,ans;
        ans=0;
        for (i=x;i&amp;gt;=1;i-=lowbit(i))
                ans+=c[i];
        return ans;
}
int main()
{
        scanf(&quot;%lld%lld&quot;,&amp;amp;n,&amp;amp;m);
        for (i=1;i&amp;lt;=n;i++)
        {
                scanf(&quot;%lld&quot;,&amp;amp;x);   
                update(i,x);
        }
        for (i=1;i&amp;lt;=m;i++)
        {
                scanf(&quot;%lld%lld%lld&quot;,&amp;amp;ch,&amp;amp;x,&amp;amp;y);
                if (ch==2) printf(&quot;%lld\n&quot;,get(y)-get(x-1));
                else update(x,y);
        }
        return 0;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2区间修改，单点查询&quot;&gt;2.区间修改，单点查询&lt;/h2&gt;
&lt;h3 id=&quot;修改-2&quot;&gt;修改&lt;/h3&gt;
&lt;p&gt;引入差分的思想，记录数组里每个元素与前一个元素的差，那么&lt;span class=&quot;math inline&quot;&gt;\(a_i=\sum_{j=1}^i d_j\)&lt;/span&gt;，如果修改区间&lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt;，令其加上&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(l-1\)&lt;/span&gt;的差增加了&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(r+1\)&lt;/span&gt;的差减小了&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，根据差分，就可以给&lt;span class=&quot;math inline&quot;&gt;\(d_{l}\)&lt;/span&gt;加上&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，给&lt;span class=&quot;math inline&quot;&gt;\(d_{r+1}\)&lt;/span&gt;减去&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;查询-2&quot;&gt;查询&lt;/h3&gt;
&lt;p&gt;直接根据&lt;span class=&quot;math inline&quot;&gt;\(a_i=\sum_{j=1}^i d_j\)&lt;/span&gt;，查前缀和就好&lt;/p&gt;
&lt;h3 id=&quot;题目-2&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://loj.ac/p/131&quot;&gt;Loj#131 树状数组2：区间修改，单点查询&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;code-2&quot;&gt;Code&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
using namespace std;
int  n,m,i,l,r,x,bj;
long long a[1000005],c[1000005];
int lowbit(int x)
{
        return x&amp;amp;(-x);
}
void update(int now,int x)
{
        int i;
        for (i=now;i&amp;lt;=n;i+=lowbit(i))
                c[i]+=x;
}
long long get(int x)
{
        int i;
        long long ans;
        ans=0;
        for (i=x;i;i-=lowbit(i))
                ans+=c[i];
        return ans;
}
int main()
{
        scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
        for (i=1;i&amp;lt;=n;i++)
        {
                scanf(&quot;%lld&quot;,&amp;amp;a[i]);
                update(i,a[i]-a[i-1]);
        }
        for (i=1;i&amp;lt;=m;i++)
        {
                scanf(&quot;%d&quot;,&amp;amp;bj);
                if (bj==1)
                {
                        scanf(&quot;%d%d%d&quot;,&amp;amp;l,&amp;amp;r,&amp;amp;x);
                        update(l,x);
                        update(r+1,-x);
                }
                else
                {
                        scanf(&quot;%d&quot;,&amp;amp;x);
                        printf(&quot;%lld\n&quot;,get(x));
                }
        }
        return 0;       
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3区间修改，区间查询&quot;&gt;3.区间修改，区间查询&lt;/h2&gt;
&lt;p&gt;这个也是线段树最麻烦的地方，通常100行起步，但树状数组就不用了，实测50行不到，而且我&lt;strong&gt;不压行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看一下如果按照问题2的方法来求区间前缀和，要怎么求&lt;/p&gt;
&lt;p&gt;位置&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的前缀和=&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^x\sum_{j=1}^id_j\)&lt;/span&gt;，发现在这个式子里，&lt;span class=&quot;math inline&quot;&gt;\(d_1\)&lt;/span&gt;被计算了&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;此，&lt;span class=&quot;math inline&quot;&gt;\(d_2\)&lt;/span&gt;被计算了&lt;span class=&quot;math inline&quot;&gt;\(x-1\)&lt;/span&gt;次……，&lt;span class=&quot;math inline&quot;&gt;\(d_x\)&lt;/span&gt;被计算了1次。那么这个式子就可以转化为&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sum_{i=1}^xd_i\times(x-i+1)=(x+1)\sum_{i=1}^xd_i-\sum_{i=1}^xd_i\times i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(x+1\)&lt;/span&gt;是给出的，那么我们记录&lt;span class=&quot;math inline&quot;&gt;\(d_i\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(d_i\times i\)&lt;/span&gt;就可以了&lt;/p&gt;
&lt;p&gt;维护两个数组&lt;span class=&quot;math inline&quot;&gt;\(sum1\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(sum2\)&lt;/span&gt;，分别记录&lt;span class=&quot;math inline&quot;&gt;\(d_i\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(d_i\times i\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改-3&quot;&gt;修改&lt;/h3&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(sum1\)&lt;/span&gt;同问题2的&lt;span class=&quot;math inline&quot;&gt;\(d\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(sum2\)&lt;/span&gt;也类似，&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;加上&lt;span class=&quot;math inline&quot;&gt;\(l\times x\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(r+1\)&lt;/span&gt;减去&lt;span class=&quot;math inline&quot;&gt;\((r+1)x\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;查询-3&quot;&gt;查询&lt;/h3&gt;
&lt;p&gt;单点&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的前缀和就是&lt;span class=&quot;math inline&quot;&gt;\((x+1)\times sum1\)&lt;/span&gt;中&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的前缀和-&lt;span class=&quot;math inline&quot;&gt;\(sum2\)&lt;/span&gt;中&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;的前缀和，区间&lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt;的值就是&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;的前缀和-&lt;span class=&quot;math inline&quot;&gt;\(l-1\)&lt;/span&gt;的前缀和&lt;/p&gt;
&lt;h3 id=&quot;题目-3&quot;&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://loj.ac/p/132&quot;&gt;Loj#132 树状数组3：区间修改，区间查询&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;code-3&quot;&gt;Code&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
using namespace std;
long long n,m,i,l,r,x,bj,a[1000005],c1[1000005],c2[1000005];
long long lowbit(long long x)
{
        return x&amp;amp;(-x);
}
void update(long long k,long long x)
{
        long long i;
        for (i=k;i&amp;lt;=n;i+=lowbit(i))
        {
                c1[i]+=x;
                c2[i]+=x*k;
        }
}
long long get(long long x)
{
        long long i,ans;
        ans=0;
        for (i=x;i;i-=lowbit(i))
                ans+=((x+1)*c1[i])-c2[i];
        return ans;
}
int main()
{
        scanf(&quot;%lld%lld&quot;,&amp;amp;n,&amp;amp;m);
        for (i=1;i&amp;lt;=n;i++)
        {
                scanf(&quot;%lld&quot;,&amp;amp;a[i]);
                update(i,a[i]-a[i-1]);
        }
        for (i=1;i&amp;lt;=m;i++)
        {
                scanf(&quot;%lld&quot;,&amp;amp;bj);
                if (bj==1)
                {
                        scanf(&quot;%lld%lld%lld&quot;,&amp;amp;l,&amp;amp;r,&amp;amp;x);
                        update(l,x);
                        update(r+1,-x);
                }
                else
                {
                        scanf(&quot;%lld%lld&quot;,&amp;amp;l,&amp;amp;r);
                        printf(&quot;%lld\n&quot;,get(r)-get(l-1));
                }
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;线段树与树状数组有很多相似的地方，但是树状数组很明显的优势就是短，但是线段树可以处理很多种情况，而这里面有些是树状数组做不到的，所以说不论是线段树还是树状数组，我们都应该学习一下，然后选择更好的去解决题目。&lt;/p&gt;
&lt;p&gt;不定时更新高阶操作&lt;/p&gt;
</description>
<pubDate>Fri, 04 Dec 2020 00:39:00 +0000</pubDate>
<dc:creator>H-K-H</dc:creator>
<og:description>告知 本博客是由一个蒟蒻编写，内容可能出错，若发现请告诉本蒟蒻，以便大众阅读 转载请注明原网址：https://www.cnblogs.com/H-K-H/p/14083914.html 树状数组和线</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/H-K-H/p/14083914.html</dc:identifier>
</item>
<item>
<title>SSM之Spring框架---&gt;&gt;墨盒案例 - 卑微小豪</title>
<link>http://www.cnblogs.com/beiweihaohao/p/14083909.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/beiweihaohao/p/14083909.html</guid>
<description>&lt;h2&gt;&lt;span&gt;分析：&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;程序中包括打印机(Printer)、墨盒(Ink)、和纸张(Paper)、三类组件&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;&lt;span&gt;首先创建一个新项目文件Spring_Box&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230891/202012/2230891-20201204081646769-1420041842.png&quot; alt=&quot;&quot; width=&quot;209&quot; height=&quot;407&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;我们来定义墨盒和纸张的接口类&lt;/h3&gt;
&lt;h3&gt;墨盒接口Ink.java文件内容如下：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; entiey;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Ink {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 定义打印采用的颜色的方法
     * r(红色)
     * g(绿色)
     * b(蓝色)
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; String getColor(&lt;span&gt;int&lt;/span&gt; r,&lt;span&gt;int&lt;/span&gt; g,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; b);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;纸张接口Paper.java文件内容如下：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; entiey;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Paper {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 纸张接口
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String newine=&quot;\r\n&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入一个字符到纸张&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putInChar(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到输出到纸张上的内容&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getContent();
    

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;这时候我们创建一个printer包名来写Printer程序：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; printer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; entiey.Ink;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; entiey.Paper;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 打印机程序
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; ASUS
 *
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Printer {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;面向接口编程,而不是具体的实现类&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; Ink ink=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Paper paper=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置注入所需的setter方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setInk(Ink ink) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ink =&lt;span&gt; ink;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setPaper(Paper paper) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.paper =&lt;span&gt; paper;
    }
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 设置打印机打印方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; print(String str) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出颜色标记&lt;/span&gt;
        System.out.println(&quot;使用&quot;+ink.getColor(255, 200, 0)+&quot;颜色打印：\n&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;逐字符输出到纸张&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;str.length();++&lt;span&gt;i) {
            paper.putInChar(str.charAt(i));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将纸张的内容输出&lt;/span&gt;
&lt;span&gt;        System.out.print(paper.getContent());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;然后我们开始实现墨盒(Ink)和纸张(Paper)的接口实现类&lt;/h2&gt;
&lt;h2&gt;ColorInk.java文件内容如下：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; entiey;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.Color;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ColorInk &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Ink{
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印采用彩色&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 彩色墨盒，ColorInk实现Ink接口
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String getColor(&lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt; g, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
        Color color &lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Color(r,g,b);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;#&quot;+Integer.toHexString(color.getRGB()).substring(2&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;GreyInk.java文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; entiey;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.Color;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; GreyInk &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Ink{
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 灰色墨盒，GreyInk实现Ink接口
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String getColor(&lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt; g, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; c=(r+g+b)/3&lt;span&gt;;
        Color color&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Color(c,c,c);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;#&quot;+Integer.toHexString(color.getRGB()).substring(2&lt;span&gt;);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;TextPaper.java文件内容如下：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; entiey;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TextPaper &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Paper{

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每行字符数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; charPerLine=16&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每页行数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; linePerPage=5&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纸张中的内容&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; String content=&quot;&quot;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前横向位置，从0到charPerLine-1&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; posX=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前行数，从0到linePerPage-1&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; posY=0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前页数&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; posP=1&lt;span&gt;;
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; putInChar(&lt;span&gt;char&lt;/span&gt;&lt;span&gt; c) {
        content&lt;/span&gt;+=&lt;span&gt;c;
        &lt;/span&gt;++&lt;span&gt;posX;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否换行&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(posX==&lt;span&gt;charPerLine) {
            content&lt;/span&gt;+=&lt;span&gt;Paper.newine;
            posX&lt;/span&gt;=0&lt;span&gt;;
            &lt;/span&gt;++&lt;span&gt;posY;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断是否翻页&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(posY==&lt;span&gt;linePerPage) {
            content&lt;/span&gt;+=&quot;==第&quot;+posP+&quot;页==&quot;&lt;span&gt;;
            content&lt;/span&gt;+=Paper.newine+&lt;span&gt;Paper.newine;
            posY&lt;/span&gt;=0&lt;span&gt;;
            &lt;/span&gt;++&lt;span&gt;posP;
        }
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getContent() {
        String ret&lt;/span&gt;=&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.content;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;补齐本页空行，并显示页码&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!(posX==0&amp;amp;&amp;amp;posY==0&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; count=linePerPage-&lt;span&gt;posY;
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;count;++&lt;span&gt;i) {
                ret&lt;/span&gt;+=&lt;span&gt;Paper.newine;
            }
            ret&lt;/span&gt;+=&quot;==第&quot;+posP+&quot;页==&quot;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;setter方法&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setCharPerLine(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; charPerLine) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.charPerLine =&lt;span&gt; charPerLine;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setLinePerPage(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; linePerPage) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.linePerPage =&lt;span&gt; linePerPage;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;开始配置XML文件applicationContext.xml文件内容如下：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;beans &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;span&gt;
       xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
       xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-3.2.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义彩色墨盒Bean，id是ColorInk &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;colorInk&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;entiey.ColorInk&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义灰色墨盒Bean，id是GreyInk &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;greyInk&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;entiey.GreyInk&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义A4纸张Bean，id是a4Paper &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 通过setCharPerLine()方法为charPerLine属性注入每行字符数 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 通过setLinePerPage()方法为linePerPage属性注入每页行数 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;a4Paper&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;entiey.TextPaper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;charPerLine&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;linePerPage&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;8&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 定义B5纸张Bean，id是b5Paper &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;b5Paper&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;entiey.TextPaper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;charPerLine&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;6&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;linePerPage&quot;&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 组装打印机，定义打印机Bean该Bean的id是printer.class指定该Bean实例的实现类 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;bean &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;printer&quot;&lt;/span&gt;&lt;span&gt; class&lt;/span&gt;&lt;span&gt;=&quot;printer.Printer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 通过ref属性注入已经定义好的Bean &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入彩色墨盒 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;ink&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;colorInk&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 注入灰色墨盒 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;property &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;paper&quot;&lt;/span&gt;&lt;span&gt; ref&lt;/span&gt;&lt;span&gt;=&quot;b5Paper&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;bean&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;beans&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;最后我们通过测试类测试我们的代码运行结果如何&lt;/h2&gt;
&lt;h2&gt;创建test包&lt;/h2&gt;
&lt;h2&gt;testa.java文件内容如下：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package test;
/**
 * 测试打印机
 * @author ASUS
 *
 */
import org.junit.Test;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

import printer.Printer;

public class testa {
    @Test
    public void m1() {
        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        //通过Printer bean的id来获取Printer实例
        Printer printer=(Printer) context.getBean(&quot;printer&quot;);
        String content=&quot;欸 朋友们好啊&quot; + 
                &quot;我是浑元形意太极门掌门人马保国&quot; + 
                &quot;刚才有个朋友问我&quot; + 
                &quot;马老师发生什么事啦&quot; + 
                &quot;我说怎么回事&quot; + 
                &quot;给我发了几张截图&quot;
                +&quot;我一看&quot; + 
                &quot;哦&quot; + 
                &quot;原来是昨天 &quot;+ 
                &quot;有两个年轻人&quot; + 
                &quot;三十多岁&quot; + 
                &quot;一个体重九十多公斤&quot; + 
                &quot;一个体重八十多公斤&quot; + 
                &quot;他们说&quot; + 
                &quot;欸&quot; + 
                &quot;有一个说是&quot; + 
                &quot;我在健身房练功&quot; + 
                &quot;颈椎练坏了&quot; + 
                &quot;马老师你能不能教教我浑元功法&quot; + 
                &quot;欸&quot; + 
                &quot;帮助治疗一下我的颈椎病&quot; + 
                &quot;我说可以&quot; + 
                &quot;我说你在健身房练死劲儿不好用&quot; + 
                &quot;他不服气&quot; + 
                &quot;欸&quot; + 
                &quot;我说小朋友&quot; + 
                &quot;你两个手来折我一个手指头&quot; + 
                &quot;他折不动&quot; + 
                &quot;他说你这也没用&quot; + 
                &quot;我说我这有用&quot; + 
                &quot;这是化劲儿&quot; + 
                &quot;传统功夫是讲化劲儿的&quot; + 
                &quot;四两拨千斤&quot; + 
                &quot;二百多斤的英国大力士&quot; + 
                &quot;都握不动我这一个手指&quot; + 
                &quot;他说要和我试试&quot; + 
                &quot;我说可以&quot; + 
                &quot;欸&quot; + 
                &quot;我一说他啪一下就站起来了&quot; + 
                &quot;很快啊&quot; + 
                &quot;然后上来就是&quot; + 
                &quot;一个左正蹬&quot; + 
                &quot;一个右鞭腿&quot; + 
                &quot;一个左刺拳&quot; + 
                &quot;我全部防出去了啊&quot; + 
                &quot;防出去以后自然是&quot; + 
                &quot;传统功夫以点到为&quot; + 
                &quot;右拳放在他鼻子上&quot; + 
                &quot;没打他&quot; + 
                &quot;我笑一下&quot; + 
                &quot;准备收拳&quot; + 
                &quot;因为这时间&quot; + 
                &quot;按照传统功夫的点到为止&quot; + 
                &quot;他就输了&quot; + 
                &quot;如果我这一拳发力&quot; + 
                &quot;一拳就把他鼻子打骨&quot; + 
                &quot;放在他鼻子上没用打他&quot; + 
                &quot;他也承认&quot; + 
                &quot;我先打到他面部&quot; + 
                &quot;他不知道拳放在他鼻子上&quot; + 
                &quot;他承认我先打到他面部啊&quot; + 
                &quot;我收拳的时间不打了&quot; + 
                &quot;他突然袭击左刺拳来打我脸&quot; + 
                &quot;啊&quot; + 
                &quot;我大意了啊&quot; + 
                &quot;没有闪&quot; + 
                &quot;欸&quot; + 
                &quot;他的左拳给我眼&quot; + 
                &quot;给我右眼蹭了一下&quot; + 
                &quot;但没关系啊&quot; + 
                &quot;他也说&quot; + 
                &quot;他结束也说了&quot; + 
                &quot;两分多钟以后&quot; + 
                &quot;当时流眼泪了捂着眼&quot; + 
                &quot;我说停停&quot; + 
                &quot;然后两分钟以后&quot; + 
                &quot;两分多钟以后&quot; + 
                &quot;就好了&quot; + 
                &quot;我说小伙子你不讲武德你不懂&quot; + 
                &quot;他说马老师对不起对不起&quot; + 
                &quot;我不懂规矩&quot; + 
                &quot;啊&quot; + 
                &quot;我是&quot; + 
                &quot;他说他是乱打的&quot; + 
                &quot;他可不是乱打的啊&quot; + 
                &quot;正蹬&quot; + 
                &quot;鞭腿&quot; + 
                &quot;左刺拳&quot; + 
                &quot;训练有素&quot; + 
                &quot;后来他说他练过三四年泰拳啊&quot; + 
                &quot;看来是有备而来&quot; + 
                &quot;这两个年轻人&quot; + 
                &quot;不讲武德&quot; + 
                &quot;来&quot; + 
                &quot;骗&quot; + 
                &quot;来&quot; + 
                &quot;偷袭&quot; + 
                &quot;我69岁&quot; + 
                &quot;老同志&quot; + 
                &quot;这好吗&quot; + 
                &quot;这不好&quot; + 
                &quot;我劝&quot; + 
                &quot;这位&quot; + 
                &quot;年轻人&quot; + 
                &quot;好自为之&quot; + 
                &quot;好好反思&quot; + 
                &quot;不要再犯这样的聪明&quot; + 
                &quot;小聪明&quot; + 
                &quot;啊&quot; + 
                &quot;额&quot; + 
                &quot;武林要以和为贵&quot; + 
                &quot;要讲武德&quot; + 
                &quot;不要搞&quot; + 
                &quot;窝里斗&quot; + 
                &quot;谢谢朋友们&quot;;
                printer.print(content);
            }
            
        
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;我们来看看我们的运行结果如下：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230891/202012/2230891-20201204083044513-1727332546.png&quot; alt=&quot;&quot; width=&quot;926&quot; height=&quot;565&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2230891/202012/2230891-20201204083232515-1041155089.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 Dec 2020 00:37:00 +0000</pubDate>
<dc:creator>卑微小豪</dc:creator>
<og:description>分析： 程序中包括打印机(Printer)、墨盒(Ink)、和纸张(Paper)、三类组件 首先创建一个新项目文件Spring_Box 我们来定义墨盒和纸张的接口类 墨盒接口Ink.java文件内容如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/beiweihaohao/p/14083909.html</dc:identifier>
</item>
<item>
<title>再也不担心写出臃肿的Flink流处理程序啦，发现一款将Flink与Spring生态完美融合的脚手架工程-懒松鼠Flink-Boot - 大宅洋</title>
<link>http://www.cnblogs.com/intsmaze/p/14070989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/intsmaze/p/14070989.html</guid>
<description>&lt;p&gt;还在为开发Flink流处理应用程序时无法像开发Spring Boot程序那么优雅的分层以及装配Bean而烦恼吗？&lt;/p&gt;
&lt;h2 id=&quot;你可能面临如下苦恼：&quot;&gt;你可能面临如下苦恼：&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;开发的Flink流处理应用程序，业务逻辑全部写在Flink的操作符中，代码无法服用，无法分层&lt;/li&gt;
&lt;li&gt;要是有一天它可以像开发Spring Boot程序那样可以优雅的分层，优雅的装配Bean，不需要自己new对象好了&lt;/li&gt;
&lt;li&gt;可以使用各种Spring生态的框架，一些琐碎的逻辑不再硬编码到代码中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;GitHub最近超火的一款开源框架，懒松鼠Flink-Boot脚手架，该脚手架简直是Spring开发工程师的福音，完美融合Spring生态体系，再也不需要手动在Java类中创建臃肿的Java对象，简直是开发大型流处理应用程序的必不可少的工具。地址：&lt;a href=&quot;https://github.com/intsmaze/flink-boot&quot;&gt;懒松鼠Flink-Boot 脚手架由《深入理解Flink核心设计与实践原理》作者开发。&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/758427/202012/758427-20201203213155435-1655368684.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;接口缓存&quot;&gt;接口缓存&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;你的现状&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static Map&amp;lt;String,String&amp;gt; cache=new HashMap&amp;lt;String,String&amp;gt;();

public String findUUID(FlowData flowData) {
    String value=cache.get(flowData.getSubTestItem());
    if(value==null)
    {
        String uuid=userMapper.findUUID(flowData);
        cache.put(uuid,value);
        return uuid;
    }
    return value;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;你想要的是这样&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Cacheable(value = &quot;FlowData.findUUID&quot;, key = &quot;#flowData.subTestItem&quot;)
public String findUUID(FlowData flowData) {
    return userMapper.findUUID(flowData);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重试机制&quot;&gt;重试机制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;你的现状&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void insertFlow(FlowData flowData) {
    try{
        userMapper.insertFlow(flowData);
      }Cache(Exception e)
      {
         Thread.sleep(10000);
         userMapper.insertFlow(flowData);
      }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;你想要的是这样&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 2000L, multiplier = 1.5))
    @Override
    public void insertFlow(FlowData flowData) {
        userMapper.insertFlow(flowData);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;bean校验&quot;&gt;Bean校验&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;你的现状&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(flowData.getSubTestItem().length()&amp;lt;2&amp;amp;&amp;amp;flowData.getSubTestItem().length()&amp;gt;7)
{
    return null;
}
if(flowData.getBillNumber()==null)
{
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;你想要的是这样&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Map&amp;lt;String, StringBuffer&amp;gt; validate = ValidatorUtil.validate(flowData);
if (validate != null) {
    System.out.println(validate);
    return null;
}

public class FlowData {

    private String uuid;
    //声明该参数的校验规则字符串长度必须在7到20之间
    @Size(min = 7, max = 20, message = &quot;长度必须在{min}-{max}之间&quot;)
    private String subTestItem;
    //声明该参数的校验规则字符串不能为空
    @NotBlank(message = &quot;billNumber不能为空&quot;)
    private String billNumber;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;等等&quot;&gt;等等......&lt;/h3&gt;
&lt;p&gt;GitHub最近超火的一款开源框架，懒松鼠Flink-Boot脚手架，该脚手架简直是Spring开发工程师的福音，完美融合Spring生态体系，再也不需要手动在Java类中创建臃肿的Java对象，简直是开发大型流处理应用程序的必不可少的工具。&lt;a href=&quot;https://github.com/intsmaze/flink-boot&quot;&gt;懒松鼠Flink-Boot 脚手架由《深入理解Flink核心设计与实践原理》作者开发。&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;它为流计算开发工程师解决了&quot;&gt;它为流计算开发工程师解决了&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;将所有对象的创建和依赖关系的维护工作都交给Spring容器的管理，降低了对象之间的耦合性，使代码变得更简洁，拒绝臃肿。&lt;/li&gt;
&lt;li&gt;消除在工程中对单例的过多使用。&lt;/li&gt;
&lt;li&gt;声明式事务处理，通过配置就可以完成对事物的管理，而无须手动编程。&lt;/li&gt;
&lt;li&gt;声明式注解，可以通过注解定义方法的缓冲功能，无序手动编程。&lt;/li&gt;
&lt;li&gt;注解式定义Bean对象的校验规则，通过注解即可完成对对象的参数校验，无序手动编程。&lt;/li&gt;
&lt;li&gt;集成MyBatis ORM框架，注解式维护实例对象的依赖关系。&lt;/li&gt;
&lt;li&gt;解耦Flink SQL,SQL语句剥离出JAVA文件，以简洁的模式表现在XML文件中。&lt;/li&gt;
&lt;li&gt;封装Flink API，仅提供业务方法去编写，Spring生态融合全部搞定，无需操心。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;有了它你的代码就像这样子：&quot;&gt;有了它你的代码就像这样子：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;/**
* github地址: https://github.com/intsmaze
* 博客地址：https://www.cnblogs.com/intsmaze/
* 出版书籍《深入理解Flink核心设计与实践原理》 随书代码
* RichFlatMapFunction为Flink框架的一个通用型操作符（算子）,开发者一般在该算子的flatMap方法中编写业务逻辑
* @auther: intsmaze(刘洋)
* @date: 2020/10/15 18:33
*/
public class MybatisFlatMap extends RichFlatMapFunction&amp;lt;String, String&amp;gt; {

   private static Gson gson = new GsonBuilder().setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).create();

    protected ApplicationContext beanFactory;
    //mybatis的Service对象，操作数据库的user表
    private UserService userService;

    @Override
    public void open(Configuration parameters) {
        ExecutionConfig.GlobalJobParameters globalJobParameters = getRuntimeContext()
                .getExecutionConfig().getGlobalJobParameters();
        beanFactory = BeanFactory.getBeanFactory((Configuration) globalJobParameters);
        
        userService = beanFactory.getBean(UserServiceImpl.class);
    }

    @Override
    public void flatMap(String value, Collector&amp;lt;String&amp;gt; out){

        FlowData flowData = gson.fromJson(message, new TypeToken&amp;lt;FlowData&amp;gt;() {
        }.getType());
        Map&amp;lt;String, StringBuffer&amp;gt; validate = ValidatorUtil.validate(flowData);
        if (validate != null) {
            System.out.println(validate);
            return null;
        }
        //数据库查询，屏蔽掉获取数据库连接，是否数据库连接，事务的声明等
        String flowUUID = userService.findUUID(flowData);
        if (StringUtils.isBlank(flowUUID)) {
            flowUUID = UUID.randomUUID().toString();
            flowData.setUuid(flowUUID);
            //数据库插入，屏蔽掉获取数据库连接，是否数据库连接，事务的声明等
            userService.insertFlow(flowData);
        }
        out.collect(gson.toJson(flowData));
    }
}


public interface UserService {

    String findUUID(FlowData flowData);

    void insertFlow(FlowData flowData);
}

//通过注解实例化Bean对象。
@Service
//通过注解声明进行事务管理
@Transactional
//通过注解声明方法具有异常重试机制
@EnableRetry
public class UserServiceImpl implements UserService {
   //通过注解进行依赖注入
    @Resource
    private UserMapper userMapper;

    @Cacheable(value = &quot;FlowData.findUUID&quot;, key = &quot;#flowData.subTestItem&quot;)
    @Override
    public String findUUID(FlowData flowData) {
        return userMapper.findUUID(flowData);
    }
    
   //通过注解声明该方法异常后的重试机制，无需手动编程
    @Retryable(value = Exception.class, maxAttempts = 3, backoff = @Backoff(delay = 2000L, multiplier = 1.5))
    @Override
    public void insertFlow(FlowData flowData) {
        userMapper.insertFlow(flowData);
    }
}

public interface UserMapper {

    String findUUID(FlowData flowData);

    void insertFlow(FlowData flowData);
}

//注解式声明参数校验规则
public class FlowData {

    private String uuid;
    //声明该参数的校验规则字符串长度必须在7到20之间
    @Size(min = 7, max = 20, message = &quot;长度必须在{min}-{max}之间&quot;)
    private String subTestItem;
    //声明该参数的校验规则字符串不能为空
    @NotBlank(message = &quot;billNumber不能为空&quot;)
    private String billNumber;

    @NotBlank(message = &quot;barcode不能为空&quot;)
    private String barcode;

    private String flowName;

    private String flowStatus;

    ......
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;仓库地址：&lt;a href=&quot;https://github.com/intsmaze/flink-boot&quot;&gt;懒松鼠Flink-Boot&lt;/a&gt;脚手架由《深入理解Flink核心设计与实践原理》作者开发。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/758427/202012/758427-20201203213448222-135360969.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;该脚手架屏蔽掉组装Flink API细节，让跨界变得简单，使得开发者能以传统Java WEB模式的开发方式开发出具备分布式计算能力的流处理程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;开发者完全不需要理解分布式计算的理论知识和Flink框架的细节，便可以快速编写业务代码实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;为了进一步提升开发者使用该脚手架开发大型项目的敏捷的程度，该脚手架工程默认集成Spring框架进行Bean管理，同时将微服务以及WEB开发领域中经常用到的框架集成进来，进一步提升开发速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;除此之外针对目前流行的各大Java框架，该Flink脚手架工程也进行了集成，加快开发人员的编码速度,比如:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;集成Jbcp-template对Mysql,Oracle,SQLServer等关系型数据库的快速访问。&lt;/li&gt;
&lt;li&gt;集成Hibernate Validator框架进行参数校验。&lt;/li&gt;
&lt;li&gt;集成Spring Retry框架进行重试标志。&lt;/li&gt;
&lt;li&gt;集成Mybatis框架,提高对关系型数据库增，删，改，查的开发速度。&lt;/li&gt;
&lt;li&gt;集成Spring Cache框架,实现注解式定义方法缓存。&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;1-组织结构&quot;&gt;1. 组织结构&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;Flink-Boot
├── Flink-Base -- Flink-Boot工程基础模块
├── Flink-Client -- Flink-Boot 客户端模块
├── flink-annotation -- 注解生效模块
├── flink-mybatis -- mybatis orm模块
├── flink-retry -- 注解重试机制模式
├── flink-validate -- 校验模块
├── flink-sql -- Flink SQL解耦至XML配置模块
├── flink-cache-annotation -- 接口缓冲模块
├── flink-junit -- 单元测试模块
├── flink-apollo -- 阿波罗配置客户端模块
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-技术选项和集成情况&quot;&gt;2. 技术选项和集成情况&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;技术&lt;/th&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt;Spring Framework&lt;/td&gt;
&lt;td&gt;容器&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Spring 基于XML方式配置Bean&lt;/td&gt;
&lt;td&gt;装配Bean&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Spring 基于注解方式配置Bean&lt;/td&gt;
&lt;td&gt;装配Bean&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Spring 基于注解声明方法重试机制&lt;/td&gt;
&lt;td&gt;Retry注解&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Spring 基于注解声明方法缓存&lt;/td&gt;
&lt;td&gt;Cache注解&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Hibernate Validator&lt;/td&gt;
&lt;td&gt;校验框架&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Druid&lt;/td&gt;
&lt;td&gt;数据库连接池&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MyBatis&lt;/td&gt;
&lt;td&gt;ORM框架&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Kafka&lt;/td&gt;
&lt;td&gt;消息队列&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;HDFS&lt;/td&gt;
&lt;td&gt;分布式文件系统&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Log4J&lt;/td&gt;
&lt;td&gt;日志组件&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Junit&lt;/td&gt;
&lt;td&gt;单元测试&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Mybatis-Plus&lt;/td&gt;
&lt;td&gt;MyBatis扩展包&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PageHelper&lt;/td&gt;
&lt;td&gt;MyBatis物理分页插件&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ZooKeeper&lt;/td&gt;
&lt;td&gt;分布式协调服务&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Dubbo&lt;/td&gt;
&lt;td&gt;分布式服务框架&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis&lt;/td&gt;
&lt;td&gt;分布式缓存数据库&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Solr &amp;amp; Elasticsearch&lt;/td&gt;
&lt;td&gt;分布式全文搜索引擎&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Ehcache&lt;/td&gt;
&lt;td&gt;进程内缓存框架&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sequence&lt;/td&gt;
&lt;td&gt;分布式高效ID生产&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Dubbole消费者&lt;/td&gt;
&lt;td&gt;服务消费者&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Spring eurake消费者&lt;/td&gt;
&lt;td&gt;服务消费者&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Apollo配置中心&lt;/td&gt;
&lt;td&gt;携程阿波罗配置中心&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;Spring Config配置中心&lt;/td&gt;
&lt;td&gt;Spring Cloud Config配置中心&lt;/td&gt;
&lt;td&gt;进行中&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;3-快速开始&quot;&gt;3. 快速开始&lt;/h3&gt;
&lt;p&gt;下面是集成Spring生态的基础手册.&lt;/p&gt;
&lt;h4 id=&quot;31-核心基础工程&quot;&gt;3.1 核心基础工程&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;flink-base :基础工程，封装了开发Flink工程的必须参数，同时集成Spring容器，为后续集成Spring各类框架提供了支撑。
&lt;ol&gt;&lt;li&gt;可以在本地开发环境和Flink集群运行环境中随意切换。&lt;/li&gt;
&lt;li&gt;可以在增量检查点和全量检查点之间随意切换。&lt;/li&gt;
&lt;li&gt;内置使用HDFS作为检查点的持久存储介质。&lt;/li&gt;
&lt;li&gt;默认使用Kafka作为数据源&lt;/li&gt;
&lt;li&gt;内置实现了任务的暂停机制-达到任务仍在运行但不再接收Kafka数据源中的数据，代替了停止任务后再重新部署任务这一繁琐流程。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;flink-client：业务工程，该工程依赖flink-base工程，开发任务在该工程中进行业务逻辑的开发。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;32-spring容器&quot;&gt;3.2 Spring容器&lt;/h4&gt;
&lt;p&gt;该容器模式配置了JdbcTemplate实例，数据库连接池采用Druid，在业务方法中只需要获取容器中的JdbcTemplate实例便可以快速与关系型数据库进行交互,dataService实例封装了一些访问数据库表的方法。&lt;/p&gt;
&lt;h5 id=&quot;topology-basexml&quot;&gt;topology-base.xml&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;beans ......
       default-lazy-init=&quot;true&quot; default-init-method=&quot;init&quot;&amp;gt;

    &amp;lt;context:property-placeholder location=&quot;classpath:config.properties&quot;/&amp;gt;

    &amp;lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&amp;gt;
        &amp;lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;url&quot;
                  value=&quot;${jdbc.url}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot;&amp;gt;&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&amp;gt;
        &amp;lt;constructor-arg ref=&quot;druidDataSource&quot;&amp;gt;&amp;lt;/constructor-arg&amp;gt;
    &amp;lt;/bean&amp;gt;
    
    &amp;lt;bean id=&quot;dataService&quot; class=&quot;com.intsmaze.flink.base.service.DataService&quot;&amp;gt;
        &amp;lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;&amp;gt;&amp;lt;/property&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;configproperties&quot;&gt;config.properties&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;jdbc.user = intsmaze
jdbc.password = intsmaze
jdbc.url = jdbc:mysql://127.0.0.1:3306/flink-boot?useUnicode=true&amp;amp;characterEncoding=UTF-8
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;33-启动类示例&quot;&gt;3.3 启动类示例&lt;/h4&gt;
&lt;p&gt;如下是SimpleClient（com.intsmaze.flink.client.SimpleClient）类的示例代码，该类继承了BaseFlink，可以看到对应实现的方法中分别设置如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public String getTopoName()：定义本作业的名称。&lt;/li&gt;
&lt;li&gt;public String getConfigName()：定义本作业需要读取的spring配置文件的名称&lt;/li&gt;
&lt;li&gt;public String getPropertiesName()：定义本作业需要读取的properties配置文件的名称。&lt;/li&gt;
&lt;li&gt;public void createTopology(StreamExecutionEnvironment builder)：构造本作业的拓扑结构。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;/**
 * github地址: https://github.com/intsmaze
 * 博客地址：https://www.cnblogs.com/intsmaze/
 * 出版书籍《深入理解Flink核心设计与实践原理》 随书代码
 *
 * @auther: intsmaze(刘洋)
 * @date: 2020/10/15 18:33
 */
public class SimpleClient extends BaseFlink {

    public static void main(String[] args) throws Exception {
        SimpleClient topo = new SimpleClient();
        topo.run(ParameterTool.fromArgs(args));
    }

    @Override
    public String getTopoName() {
        return &quot;SimpleClient&quot;;
    }

    @Override
    public String getConfigName() {
        return &quot;topology-base.xml&quot;;
    }

    @Override
    public String getPropertiesName() {
        return &quot;config.properties&quot;;
    }

    @Override
    public void createTopology(StreamExecutionEnvironment builder) {

        DataStream&amp;lt;String&amp;gt; inputDataStrem = env.addSource(new SimpleDataSource());

        DataStream&amp;lt;String&amp;gt; processDataStream = inputDataStrem.flatMap(new SimpleFunction());

        processDataStream.print(&quot;输出结果&quot;);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;34-数据源&quot;&gt;3.4 数据源&lt;/h4&gt;
&lt;p&gt;采用自定义数据源，用户需要编写自定义DataSource类，该类需要继承XXX抽象类，实现如下方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public abstract void open(StormBeanFactory beanFactory):获取本作业在Spring配置文件中配置的bean对象。&lt;/li&gt;
&lt;li&gt;public abstract String sendMessage():本作业spout生成数据的方法，在该方法内编写业务逻辑产生源数据，产生的数据以String类型进行返回。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class SimpleDataSource extends CommonDataSource {

    private static Gson gson = new GsonBuilder().setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).create();
        ......

    @Override
    public void open(Configuration parameters) throws Exception {
        super.open(parameters);
        ...//构造读取各类外部系统数据的连接实例
    }

    @Override
    public String sendMess() throws InterruptedException {
        Thread.sleep(1000);
                ......
        MainData mainData = new MainData();
        ......//通过外部系统数据的连接实例读取外部系统数据，封装进MainData对象中，然后返回即可。
        return gson.toJson(mainData);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;35-业务逻辑实现&quot;&gt;3.5 业务逻辑实现&lt;/h4&gt;
&lt;p&gt;本作业计算的业务逻辑在Flink转换操作符中进行实现，一般来说开发者只需要实现flatMap算子即可以满足大部分算子的使用。&lt;/p&gt;
&lt;p&gt;用户编写的自定义类需要继承com.intsmaze.flink.base.transform.CommonFunction抽象类，均需实现如下方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;public abstract String execute(String message)：本作业业务逻辑计算的方法，参数message为Kafka主题中读取过来的参数，默认参数为String类型，如果需要将处理的数据发送给Kakfa主题中，则要通过return将处理的数据返回即可。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;public class SimpleFunction extends CommonFunction {

    private static Gson gson = new GsonBuilder().setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).create();
    
    @Override
    public String execute(String message) throws Exception {
        FlowData flowData = gson.fromJson(message, new TypeToken&amp;lt;FlowData&amp;gt;() {
        }.getType());

        String flowUUID = dataService.findUUID(flowData);
        if (StringUtils.isBlank(flowUUID)) {
            flowUUID = UUID.randomUUID().toString();
            flowData.setUuid(flowUUID);
            dataService.insertFlow(flowData);
        }
        return gson.toJson(flowData);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;commonfunction&quot;&gt;CommonFunction&lt;/h5&gt;
&lt;p&gt;CommonFunction抽象类中默认在open方法中通过BeanFactory对象获取到了Spring容器中对于的dataService实例，对于Spring中的其他实例同理在SimpleFunction类中的open方法中获取即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class CommonFunction extends RichFlatMapFunction&amp;lt;String, String&amp;gt; {

    private IntCounter numLines = new IntCounter();

    protected DataService dataService;

    protected ApplicationContext beanFactory;

    @Override
    public void open(Configuration parameters) {
        getRuntimeContext().addAccumulator(&quot;num-FlatMap&quot;, this.numLines);

        ExecutionConfig.GlobalJobParameters globalJobParameters = getRuntimeContext()
                .getExecutionConfig().getGlobalJobParameters();
        beanFactory = BeanFactory.getBeanFactory((Configuration) globalJobParameters);

        dataService = beanFactory.getBean(DataService.class);
    }

    @Override
    public void flatMap(String value, Collector&amp;lt;String&amp;gt; out) throws Exception {
        this.numLines.add(1);
        String execute = execute(value);
        if (StringUtils.isNotBlank(execute)) {
            out.collect(execute);
        }
    }

    public abstract String execute(String message) throws Exception;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以根据情况选择重写open(Configuration parameters)方法，同时重写的open(Configuration parameters)方法的第一行要调用父类的open(Configuration parameters)方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void open(Configuration parameters){
        super.open(parameters);
        ......
        //获取在Spring配置文件中配置的实例
        XXX xxx=beanFactory.getBean(XXX.class);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;36--集群本地运行&quot;&gt;3.6 集群/本地运行&lt;/h4&gt;
&lt;p&gt;在自定义的Topology类编写Main方法，创建自定义的Topology对象后，调用对象的run(...)方法。&lt;/p&gt;
&lt;p&gt;public class SimpleClient extends BaseFlink {&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 本地启动参数  -isLocal local
 * 集群启动参数  -isIncremental isIncremental
 */
public static void main(String[] args) throws Exception {
    SimpleClient topo = new SimpleClient();
    topo.run(ParameterTool.fromArgs(args));
}

.......&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 04 Dec 2020 00:29:00 +0000</pubDate>
<dc:creator>大宅洋</dc:creator>
<og:description>还在为开发Flink流处理应用程序时无法像开发Spring Boot程序那么优雅的分层以及装配Bean而烦恼吗？ 你可能面临如下苦恼： 开发的Flink流处理应用程序，业务逻辑全部写在Flink的操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/intsmaze/p/14070989.html</dc:identifier>
</item>
<item>
<title>CoProcessFunction实战三部曲之二：状态处理 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14083884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14083884.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;本文是《CoProcessFunction实战三部曲》的第二篇，咱们要实战的是双流连接场景下，处理一号流中的数据时，还要结合该key在二号流中的情况；&lt;/li&gt;
&lt;li&gt;最简单的例子：&lt;span&gt;aaa&lt;/span&gt;在一号流中的value和二号流的value相加，再输出到下游，如下图所示，一号流中的value存入state，在二号流中取出并相加，将结果输出给下游：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201204081248230-449583855.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;本篇的内容就是编码实现上图的功能；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参考文章&quot;&gt;参考文章&lt;/h3&gt;
&lt;p&gt;理解状态：&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/106040312&quot;&gt;《深入了解ProcessFunction的状态操作(Flink-1.10)》&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;p&gt;如果您不想写代码，整个系列的源码可在GitHub下载到，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/p&gt;
&lt;p&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;flinkstudy&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202012/485422-20201204081248701-420602581.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;编码&quot;&gt;编码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;字符串转Tuple2的Map函数，以及抽象类&lt;span&gt;AbstractCoProcessFunctionExecutor&lt;/span&gt;都和上一篇&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/109624375&quot;&gt;《CoProcessFunction实战三部曲之一：基本功能》&lt;/a&gt;一模一样；&lt;/li&gt;
&lt;li&gt;新增AbstractCoProcessFunctionExecutor的子类&lt;span&gt;AddTwoSourceValue.java&lt;/span&gt;，源码如下，稍后会说明几个关键点：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.coprocessfunction;

import org.apache.flink.api.common.state.ValueState;
import org.apache.flink.api.common.state.ValueStateDescriptor;
import org.apache.flink.api.java.tuple.Tuple2;
import org.apache.flink.configuration.Configuration;
import org.apache.flink.streaming.api.functions.co.CoProcessFunction;
import org.apache.flink.util.Collector;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author will
 * @email zq2599@gmail.com
 * @date 2020-11-11 09:48
 * @description 功能介绍
 */
public class AddTwoSourceValue extends AbstractCoProcessFunctionExecutor {

    private static final Logger logger = LoggerFactory.getLogger(AddTwoSourceValue.class);

    @Override
    protected CoProcessFunction&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; getCoProcessFunctionInstance() {
        return new CoProcessFunction&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;() {

            // 某个key在processElement1中存入的状态
            private ValueState&amp;lt;Integer&amp;gt; state1;

            // 某个key在processElement2中存入的状态
            private ValueState&amp;lt;Integer&amp;gt; state2;

            @Override
            public void open(Configuration parameters) throws Exception {
                // 初始化状态
                state1 = getRuntimeContext().getState(new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;myState1&quot;, Integer.class));
                state2 = getRuntimeContext().getState(new ValueStateDescriptor&amp;lt;&amp;gt;(&quot;myState2&quot;, Integer.class));
            }

            @Override
            public void processElement1(Tuple2&amp;lt;String, Integer&amp;gt; value, Context ctx, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; out) throws Exception {
                logger.info(&quot;处理元素1：{}&quot;, value);

                String key = value.f0;

                Integer value2 = state2.value();

                // value2为空，就表示processElement2还没有处理或这个key，
                // 这时候就把value1保存起来
                if(null==value2) {
                    logger.info(&quot;2号流还未收到过[{}]，把1号流收到的值[{}]保存起来&quot;, key, value.f1);
                    state1.update(value.f1);
                } else {
                    logger.info(&quot;2号流收到过[{}]，值是[{}]，现在把两个值相加后输出&quot;, key, value2);

                    // 输出一个新的元素到下游节点
                    out.collect(new Tuple2&amp;lt;&amp;gt;(key, value.f1 + value2));

                    // 把2号流的状态清理掉
                    state2.clear();
                }
            }

            @Override
            public void processElement2(Tuple2&amp;lt;String, Integer&amp;gt; value, Context ctx, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; out) throws Exception {
                logger.info(&quot;处理元素2：{}&quot;, value);

                String key = value.f0;

                Integer value1 = state1.value();

                // value1为空，就表示processElement1还没有处理或这个key，
                // 这时候就把value2保存起来
                if(null==value1) {
                    logger.info(&quot;1号流还未收到过[{}]，把2号流收到的值[{}]保存起来&quot;, key, value.f1);
                    state2.update(value.f1);
                } else {
                    logger.info(&quot;1号流收到过[{}]，值是[{}]，现在把两个值相加后输出&quot;, key, value1);

                    // 输出一个新的元素到下游节点
                    out.collect(new Tuple2&amp;lt;&amp;gt;(key, value.f1 + value1));

                    // 把1号流的状态清理掉
                    state1.clear();
                }
            }
        };
    }

    public static void main(String[] args) throws Exception {
        new AddTwoSourceValue().execute();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;关键点之一：对于&lt;span&gt;aaa&lt;/span&gt;这个key，无法确定会先出现在一号源还是二号源，如果先出现在一号源，就应该在processElement1中将value保存在state1中，这样等到aaa再次出现在二号源时，processElement2就可以从state1中取出一号源的value，相加后输出到下游；&lt;/li&gt;
&lt;li&gt;关键点之二：如果输出到下游，就表示数据已经处理完毕，此时要把保存的状态清理掉；&lt;/li&gt;
&lt;li&gt;如果您想了解低阶函数中的状态存取的更多细节，请参考&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/106040312&quot;&gt;《深入了解ProcessFunction的状态操作(Flink-1.10)》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;分别开启本机的&lt;span&gt;9998&lt;/span&gt;和&lt;span&gt;9999&lt;/span&gt;端口，我这里是MacBook，执行&lt;span&gt;nc -l 9998&lt;/span&gt;和&lt;span&gt;nc -l 9999&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;启动Flink应用，如果您和我一样是Mac电脑，直接运行&lt;span&gt;AddTwoSourceValue.main&lt;/span&gt;方法即可（如果是windows电脑，我这没试过，不过做成jar在线部署也是可以的）；&lt;/li&gt;
&lt;li&gt;在监听9998端口的控制台输入&lt;span&gt;aaa,111&lt;/span&gt;，此时flink控制台输出如下，可见processElement1方法中，读取state2为空，表示aaa在二号流还未出现过，此时的aaa是首次出现，应该放入state中保存：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;22:35:12,135 INFO  AddTwoSourceValue - 处理元素1：(aaa,111)
22:35:12,136 INFO  AddTwoSourceValue - 2号流还未收到过[aaa]，把1号流收到的值[111]保存起来
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;在监听9999端口的控制台输入&lt;span&gt;bbb,123&lt;/span&gt;，flink日志如下所示，表示bbb也是首次出现，把值保存在state中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;22:35:34,473 INFO  AddTwoSourceValue - 处理元素2：(bbb,123)
22:35:34,473 INFO  AddTwoSourceValue - 1号流还未收到过[bbb]，把2号流收到的值[123]保存起来
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;在监听9999端口的控制台输入&lt;span&gt;aaa,222&lt;/span&gt;，flink日志如下，很明显，之前保存在state中的值被取出来了，因此processElement2方法中，aaa在两个数据源的值111和222会被相加后输出到下游，下游是print，直接打印出来了：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;22:35:38,072 INFO  AddTwoSourceValue - 处理元素2：(aaa,222)
22:35:38,072 INFO  AddTwoSourceValue - 1号流收到过[aaa]，值是[111]，现在把两个值相加后输出
(aaa,333)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;至此，双流场景下的状态互通实践咱们已经完成了，接下来的文章，会加上定时器和旁路输出，将双流场景的数据处理考虑得更加全面；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 04 Dec 2020 00:13:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14083884.html</dc:identifier>
</item>
<item>
<title>IdentityServer4系列 | 授权码模式 - 艾三元</title>
<link>http://www.cnblogs.com/i3yuan/p/14064380.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/i3yuan/p/14064380.html</guid>
<description>&lt;p&gt;在上一篇关于&lt;a href=&quot;https://www.cnblogs.com/i3yuan/p/14033016.html&quot;&gt;简化模式&lt;/a&gt;中，通过客户端以浏览器的形式请求&lt;strong&gt;IdentityServer&lt;/strong&gt;服务获取访问令牌，从而请求获取受保护的资源，但由于token携带在url中，安全性方面不能保证。因此，我们可以考虑通过其他方式来解决这个问题。&lt;/p&gt;
&lt;p&gt;我们通过Oauth2.0的&lt;strong&gt;授权码模式&lt;/strong&gt;了解，这种模式不同于简化模式，&lt;strong&gt;在于授权码模式不直接返回token，而是先返回一个授权码，然后再根据这个授权码去请求token&lt;/strong&gt;。这显得更为安全。&lt;/p&gt;
&lt;p&gt;所以在这一篇中，我们将通过多种授权模式中的&lt;strong&gt;授权码&lt;/strong&gt;模式进行说明，主要针对介绍&lt;strong&gt;IdentityServer&lt;/strong&gt;保护API的资源，&lt;strong&gt;授权码&lt;/strong&gt;访问API资源。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202011/1576550-20201130223920101-1776315482.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;(图片来源网络)&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;指的是第三方应用先申请一个授权码，然后再用该码获取令牌，实现与资源服务器的通信。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看一个常见的QQ登陆第三方网站的流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202011/1576550-20201130223940823-1725351879.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;21-适用范围&quot;&gt;2.1 适用范围&lt;/h2&gt;
&lt;p&gt;授权码模式(authorization code)是功能最完整、流程最严密的授权模式。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;授权码模式适用于有后端的应用，因为客户端根据授权码去请求token时是需要把客户端密码转进来的，为了避免客户端密码被暴露，所以请求token这个过程需要放在后台。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;22--授权流程：&quot;&gt;2.2 授权流程：&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt; +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- &amp;amp; Redirection URI ----&amp;gt;|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates ---&amp;gt;|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---&amp;lt;|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |&amp;gt;---(D)-- Authorization Code ---------'      |
     |  Client |          &amp;amp; Redirection URI                  |
     |         |                                             |
     |         |&amp;lt;---(E)----- Access Token -------------------'
     +---------+       (w/ Optional Refresh Token)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;授权码授权流程描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（A）&lt;strong&gt;用户访问第三方应用，第三方应用将用户导向认证服务器&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（B）&lt;strong&gt;用户选择是否给予第三方应用授权&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（C）&lt;strong&gt;假设用户给予授权，认证服务器将用户导向第三方应用事先指定的重定向URI，同时带上一个授权码&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（D）&lt;strong&gt;第三方应用收到授权码，带上上一步时的重定向URI，向认证服务器申请访问令牌。这一步是在第三方应用的后台的服务器上完成的，对用户不可见&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（E）&lt;strong&gt;认证服务器核对了授权码和重定向URI，确认无误后，向第三方应用发送访问令牌(Access Token)和更新令牌(Refresh token)&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;（F）&lt;strong&gt;访问令牌过期后，刷新访问令牌&lt;/strong&gt;；&lt;/p&gt;
&lt;h3 id=&quot;221-过程详解&quot;&gt;2.2.1 过程详解&lt;/h3&gt;
&lt;hr/&gt;&lt;h5 id=&quot;访问令牌请求&quot;&gt;访问令牌请求&lt;/h5&gt;
&lt;h5 id=&quot;（1）用户访问第三方应用，第三方应用将用户导向认证服务器&quot;&gt;&lt;strong&gt;（1）用户访问第三方应用，第三方应用将用户导向认证服务器&lt;/strong&gt;&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;  (用户的操作：用户访问https://client.example.com/cb跳转到登录地址，选择授权服务器方式登录)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在授权开始之前，它首先生成state参数(随机字符串)。client端将需要存储这个（cookie，会话或其他方式），以便在下一步中使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;GET /authorize?response_type=code&amp;amp;client_id=s6BhdRkqt3&amp;amp;state=xyz
        &amp;amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
HTTP/1.1 Host: server.example.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的授权URL如上所述（如上），请求这个地址后重定向访问授权服务器，其中 response_type参数为code,表示授权类型，返回code授权码。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;response_type&lt;/td&gt;
&lt;td&gt;必需&lt;/td&gt;
&lt;td&gt;表示授权类型，此处的值固定为&quot;code&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;client_id&lt;/td&gt;
&lt;td&gt;必需&lt;/td&gt;
&lt;td&gt;客户端ID&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redirect_uri&lt;/td&gt;
&lt;td&gt;可选&lt;/td&gt;
&lt;td&gt;表示重定向的URI&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;scope&lt;/td&gt;
&lt;td&gt;可选&lt;/td&gt;
&lt;td&gt;表示授权范围。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;可选&lt;/td&gt;
&lt;td&gt;表示随机字符串,可指定任意值，认证服务器会返回这个值&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;（2）假设用户给予授权，认证服务器将用户导向第三方应用事先指定的重定向URI，同时带上一个授权码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;HTTP/1.1 302 Found
Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&amp;amp;state=xyz
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;code&lt;/td&gt;
&lt;td&gt;表示授权码，必选项。该码的有效期应该很短，通常设为10分钟，客户端只能使用该码一次，否则会被授权服务器拒绝。该码与客户端ID和重定向URI，是一一对应关系。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;state&lt;/td&gt;
&lt;td&gt;如果客户端的请求中包含这个参数，认证服务器的回应也必须一模一样包含这个参数。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;（3）第三方应用收到授权码，带上上一步时的重定向URI，向认证服务器申请访问令牌。这一步是在第三方应用的后台的服务器上完成的，对用户不可见&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;POST /token HTTP/1.1
Host: server.example.com
Authorization: Bearer czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
grant_type=authorization_code&amp;amp;code=SplxlOBeZQQYbYS6WxSbIA
&amp;amp;redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;grant_type&lt;/td&gt;
&lt;td&gt;表示使用的授权模式，必选项，此处的值固定为&quot;authorization_code&quot;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;code&lt;/td&gt;
&lt;td&gt;表示上一步获得的授权码，必选项。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;redirect_uri&lt;/td&gt;
&lt;td&gt;表示重定向URI，必选项，且必须与步骤1中的该参数值保持一致。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;client_id&lt;/td&gt;
&lt;td&gt;表示客户端ID，必选项。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;（4）认证服务器核对了授权码和重定向URI，确认无误后，向第三方应用发送访问令牌(Access Token)和更新令牌(Refresh token)&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;HTTP/1.1 200 OK
     Content-Type: application/json;charset=UTF-8
     Cache-Control: no-store
     Pragma: no-cache
     {
       &quot;access_token&quot;:&quot;2YotnFZFEjr1zCsicMWpAA&quot;,
       &quot;token_type&quot;:&quot;Bearer&quot;,
       &quot;expires_in&quot;:3600,
       &quot;refresh_token&quot;:&quot;tGzv3JOkF0XG5Qx2TlKWIA&quot;,
       &quot;example_parameter&quot;:&quot;example_value&quot;
     }
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;access_token&lt;/td&gt;
&lt;td&gt;表示访问令牌，必选项。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;token_type&lt;/td&gt;
&lt;td&gt;表示令牌类型，该值大小写不敏感，必选项，可以是Bearer类型或mac类型。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;expires_in&lt;/td&gt;
&lt;td&gt;表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;refresh_token&lt;/td&gt;
&lt;td&gt;表示更新令牌，用来获取下一次的访问令牌，可选项。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;scope&lt;/td&gt;
&lt;td&gt;表示权限范围，如果与客户端申请的范围一致，此项可省略。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;(5) 访问令牌过期后，刷新访问令牌&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-http&quot;&gt;POST /token HTTP/1.1
Host: server.example.com
Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
Content-Type: application/x-www-form-urlencoded
grant_type=refresh_token&amp;amp;refresh_token=tGzv3JOkF0XG5Qx2TlKWIA
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;granttype&lt;/td&gt;
&lt;td&gt;表示使用的授权模式，此处的值固定为&quot;refreshtoken&quot;，必选项。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;refresh_token&lt;/td&gt;
&lt;td&gt;表示早前收到的更新令牌，必选项。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;scope&lt;/td&gt;
&lt;td&gt;表示申请的授权范围，不可以超出上一次申请的范围，如果省略该参数，则表示与上一次一致。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在示例实践中，我们将创建一个授权访问服务，定义一个MVC客户端，MVC客户端通过&lt;strong&gt;IdentityServer&lt;/strong&gt;上请求访问令牌，并使用它来访问API。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;31-搭建-authorization-server-服务&quot;&gt;3.1 搭建 Authorization Server 服务&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;搭建认证授权服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;311-安装nuget包&quot;&gt;3.1.1 安装Nuget包&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;IdentityServer4&lt;/code&gt; 程序包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;312-配置内容&quot;&gt;3.1.2 配置内容&lt;/h3&gt;
&lt;p&gt;建立配置内容文件&lt;code&gt;Config.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static class Config
{
    public static IEnumerable&amp;lt;IdentityResource&amp;gt; IdentityResources =&amp;gt;
        new IdentityResource[]
    {
        new IdentityResources.OpenId(),
        new IdentityResources.Profile(),
    };

    public static IEnumerable&amp;lt;ApiScope&amp;gt; ApiScopes =&amp;gt;
        new ApiScope[]
    {
        new ApiScope(&quot;code_scope1&quot;)
    };

    public static IEnumerable&amp;lt;ApiResource&amp;gt; ApiResources =&amp;gt;
        new ApiResource[]
    {
        new ApiResource(&quot;api1&quot;,&quot;api1&quot;)
        {
            Scopes={ &quot;code_scope1&quot; },
            UserClaims={JwtClaimTypes.Role},  //添加Cliam 角色类型
            ApiSecrets={new Secret(&quot;apipwd&quot;.Sha256())}
        }
    };

    public static IEnumerable&amp;lt;Client&amp;gt; Clients =&amp;gt;
        new Client[]
    {
        new Client
        {
            ClientId = &quot;code_client&quot;,
            ClientName = &quot;code Auth&quot;,

            AllowedGrantTypes = GrantTypes.Code,

            RedirectUris ={
                &quot;http://localhost:5002/signin-oidc&quot;, //跳转登录到的客户端的地址
            },
            // RedirectUris = {&quot;http://localhost:5002/auth.html&quot; }, //跳转登出到的客户端的地址
            PostLogoutRedirectUris ={
                &quot;http://localhost:5002/signout-callback-oidc&quot;,
            },
            ClientSecrets = { new Secret(&quot;511536EF-F270-4058-80CA-1C89C192F69A&quot;.Sha256()) },

            AllowedScopes = {
                IdentityServerConstants.StandardScopes.OpenId,
                IdentityServerConstants.StandardScopes.Profile,
                &quot;code_scope1&quot;
            },
            //允许将token通过浏览器传递
            AllowAccessTokensViaBrowser=true,
            // 是否需要同意授权 （默认是false）
            RequireConsent=true
        }
    };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code&gt;RedirectUris&lt;/code&gt; : 登录成功回调处理的客户端地址，处理回调返回的数据，可以有多个。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PostLogoutRedirectUris&lt;/code&gt; ：跳转登出到的客户端的地址。&lt;/p&gt;
&lt;p&gt;这两个都是配置的客户端的地址，且是identityserver4组件里面封装好的地址，作用分别是登录，注销的回调&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为是&lt;strong&gt;授权码&lt;/strong&gt;授权的方式，所以我们通过代码的方式来创建几个测试用户。&lt;/p&gt;
&lt;p&gt;新建测试用户文件&lt;code&gt;TestUsers.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public class TestUsers
    {
        public static List&amp;lt;TestUser&amp;gt; Users
        {
            get
            {
                var address = new
                {
                    street_address = &quot;One Hacker Way&quot;,
                    locality = &quot;Heidelberg&quot;,
                    postal_code = 69118,
                    country = &quot;Germany&quot;
                };

                return new List&amp;lt;TestUser&amp;gt;
                {
                    new TestUser
                    {
                        SubjectId = &quot;1&quot;,
                        Username = &quot;i3yuan&quot;,
                        Password = &quot;123456&quot;,
                        Claims =
                        {
                            new Claim(JwtClaimTypes.Name, &quot;i3yuan Smith&quot;),
                            new Claim(JwtClaimTypes.GivenName, &quot;i3yuan&quot;),
                            new Claim(JwtClaimTypes.FamilyName, &quot;Smith&quot;),
                            new Claim(JwtClaimTypes.Email, &quot;i3yuan@email.com&quot;),
                            new Claim(JwtClaimTypes.EmailVerified, &quot;true&quot;, ClaimValueTypes.Boolean),
                            new Claim(JwtClaimTypes.WebSite, &quot;http://i3yuan.top&quot;),
                            new Claim(JwtClaimTypes.Address, JsonSerializer.Serialize(address), IdentityServerConstants.ClaimValueTypes.Json)
                        }
                    }
                };
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;返回一个TestUser的集合。&lt;/p&gt;
&lt;p&gt;通过以上添加好配置和测试用户后，我们需要将用户注册到IdentityServer4服务中，接下来继续介绍。&lt;/p&gt;
&lt;h3 id=&quot;313-注册服务&quot;&gt;3.1.3 注册服务&lt;/h3&gt;
&lt;p&gt;在startup.cs中ConfigureServices方法添加如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        public void ConfigureServices(IServiceCollection services)
        {
            var builder = services.AddIdentityServer()
               .AddTestUsers(TestUsers.Users); //添加测试用户

            // in-memory, code config
            builder.AddInMemoryIdentityResources(Config.IdentityResources);
            builder.AddInMemoryApiScopes(Config.ApiScopes);
            builder.AddInMemoryApiResources(Config.ApiResources);
            builder.AddInMemoryClients(Config.Clients);

            // not recommended for production - you need to store your key material somewhere secure
            builder.AddDeveloperSigningCredential();
            services.ConfigureNonBreakingSameSiteCookies();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;314-配置管道&quot;&gt;3.1.4 配置管道&lt;/h3&gt;
&lt;p&gt;在startup.cs中Configure方法添加如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            app.UseStaticFiles();
            app.UseRouting();
            app.UseCookiePolicy();
            app.UseAuthentication();
            app.UseAuthorization();
            app.UseIdentityServer();
            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapDefaultControllerRoute();
            }); 
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上内容是快速搭建简易IdentityServer项目服务的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这搭建 Authorization Server 服务跟上一篇&lt;a href=&quot;https://www.cnblogs.com/i3yuan/p/14033016.html&quot;&gt;简化模式&lt;/a&gt;有何不同之处呢？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;在Config中配置客户端(client)中定义了一个&lt;code&gt;AllowedGrantTypes&lt;/code&gt;的属性，这个属性决定了Client可以被哪种模式被访问，&lt;strong&gt;GrantTypes.Code&lt;/strong&gt;为&lt;strong&gt;授权码模式&lt;/strong&gt;。所以在本文中我们需要添加一个Client用于支持授权码模式(&lt;strong&gt;Authorization Code&lt;/strong&gt;)。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;32-搭建api资源&quot;&gt;3.2 搭建API资源&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实现对API资源进行保护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;321-快速搭建一个api项目&quot;&gt;3.2.1 快速搭建一个API项目&lt;/h3&gt;
&lt;h3 id=&quot;322-安装nuget包&quot;&gt;3.2.2 安装Nuget包&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;IdentityServer4.AccessTokenValidation 包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;323-注册服务&quot;&gt;3.2.3 注册服务&lt;/h3&gt;
&lt;p&gt;在startup.cs中ConfigureServices方法添加如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllersWithViews();
        services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
        services.AddAuthentication(&quot;Bearer&quot;)
          .AddIdentityServerAuthentication(options =&amp;gt;
          {
              options.Authority = &quot;http://localhost:5001&quot;;
              options.RequireHttpsMetadata = false;
              options.ApiName = &quot;api1&quot;;
              options.ApiSecret = &quot;apipwd&quot;; //对应ApiResources中的密钥
          });
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AddAuthentication把Bearer配置成默认模式，将身份认证服务添加到DI中。&lt;/p&gt;
&lt;p&gt;AddIdentityServerAuthentication把IdentityServer的access token添加到DI中，供身份认证服务使用。&lt;/p&gt;
&lt;h3 id=&quot;324-配置管道&quot;&gt;3.2.4 配置管道&lt;/h3&gt;
&lt;p&gt;在startup.cs中Configure方法添加如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }    
            app.UseRouting();
            app.UseAuthentication();
            app.UseAuthorization();
            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapDefaultControllerRoute();
            });
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UseAuthentication将身份验证中间件添加到管道中；&lt;/p&gt;
&lt;p&gt;UseAuthorization 将启动授权中间件添加到管道中，以便在每次调用主机时执行身份验证授权功能。&lt;/p&gt;
&lt;h3 id=&quot;325-添加api资源接口&quot;&gt;3.2.5 添加API资源接口&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;[Route(&quot;api/[Controller]&quot;)]
[ApiController]
public class IdentityController:ControllerBase
{
    [HttpGet(&quot;getUserClaims&quot;)]
    [Authorize]
    public IActionResult GetUserClaims()
    {
        return new JsonResult(from c in User.Claims select new { c.Type, c.Value });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在IdentityController 控制器中添加 [Authorize] , 在进行请求资源的时候，需进行认证授权通过后，才能进行访问。&lt;/p&gt;
&lt;h2 id=&quot;33-搭建mvc-客户端&quot;&gt;3.3 搭建MVC 客户端&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实现对客户端认证授权访问资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;331-快速搭建一个mvc项目&quot;&gt;3.3.1 快速搭建一个MVC项目&lt;/h3&gt;
&lt;h3 id=&quot;332-安装nuget包&quot;&gt;3.3.2 安装Nuget包&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;IdentityServer4.AccessTokenValidation 包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;333-注册服务&quot;&gt;3.3.3 注册服务&lt;/h3&gt;
&lt;p&gt;要将对 OpenID Connect 身份认证的支持添加到MVC应用程序中。&lt;/p&gt;
&lt;p&gt;在startup.cs中ConfigureServices方法添加如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddControllersWithViews();
        services.AddAuthorization();

        services.AddAuthentication(options =&amp;gt;
            {
                options.DefaultScheme = &quot;Cookies&quot;;
                options.DefaultChallengeScheme = &quot;oidc&quot;;
            })
               .AddCookie(&quot;Cookies&quot;)  //使用Cookie作为验证用户的首选方式
              .AddOpenIdConnect(&quot;oidc&quot;, options =&amp;gt;
              {
                  options.Authority = &quot;http://localhost:5001&quot;;  //授权服务器地址
                  options.RequireHttpsMetadata = false;  //暂时不用https
                  options.ClientId = &quot;code_client&quot;;
                  options.ClientSecret = &quot;511536EF-F270-4058-80CA-1C89C192F69A&quot;;
                  options.ResponseType = &quot;code&quot;; //代表Authorization Code
                  options.Scope.Add(&quot;code_scope1&quot;); //添加授权资源
                  options.SaveTokens = true; //表示把获取的Token存到Cookie中
                  options.GetClaimsFromUserInfoEndpoint = true;
              });
         services.ConfigureNonBreakingSameSiteCookies();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;AddAuthentication&lt;/code&gt;注入添加认证授权，当需要用户登录时，使用 &lt;code&gt;cookie&lt;/code&gt; 来本地登录用户（通过“Cookies”作为&lt;code&gt;DefaultScheme&lt;/code&gt;），并将 &lt;code&gt;DefaultChallengeScheme&lt;/code&gt; 设置为“oidc”，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;AddCookie&lt;/code&gt; 添加可以处理 cookie 的处理程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在&lt;code&gt;AddOpenIdConnect&lt;/code&gt;用于配置执行 &lt;code&gt;OpenID Connect&lt;/code&gt; 协议的处理程序和相关参数。&lt;code&gt;Authority&lt;/code&gt;表明之前搭建的 IdentityServer 授权服务地址。然后我们通过&lt;code&gt;ClientId&lt;/code&gt;、&lt;code&gt;ClientSecret&lt;/code&gt;,识别这个客户端。 &lt;code&gt;SaveTokens&lt;/code&gt;用于保存从IdentityServer获取的token至cookie,&lt;strong&gt;ture&lt;/strong&gt;标识ASP.NETCore将会自动存储身份认证session的access和refresh token。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;334-配置管道&quot;&gt;3.3.4 配置管道&lt;/h3&gt;
&lt;p&gt;然后要确保认证服务执行对每个请求的验证，加入&lt;code&gt;UseAuthentication&lt;/code&gt;和&lt;code&gt;UseAuthorization&lt;/code&gt;到&lt;code&gt;Configure&lt;/code&gt;中,在startup.cs中Configure方法添加如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            else
            {
                app.UseExceptionHandler(&quot;/Home/Error&quot;);
            }
            app.UseStaticFiles();
            app.UseRouting();
            app.UseCookiePolicy();
            app.UseAuthentication();
            app.UseAuthorization();
            app.UseEndpoints(endpoints =&amp;gt;
            {
                endpoints.MapControllerRoute(
                    name: &quot;default&quot;,
                    pattern: &quot;{controller=Home}/{action=Index}/{id?}&quot;);
            });
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;UseAuthentication将身份验证中间件添加到管道中；&lt;/p&gt;
&lt;p&gt;UseAuthorization 将启动授权中间件添加到管道中，以便在每次调用主机时执行身份验证授权功能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;335-添加授权&quot;&gt;3.3.5 添加授权&lt;/h3&gt;
&lt;p&gt;在HomeController控制器并添加&lt;code&gt;[Authorize]&lt;/code&gt;特性到其中一个方法。在进行请求的时候，需进行认证授权通过后，才能进行访问。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        [Authorize]
        public IActionResult Privacy()
        {
            ViewData[&quot;Message&quot;] = &quot;Secure page.&quot;;
            return View();
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还要修改主视图以显示用户的Claim以及cookie属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;@using Microsoft.AspNetCore.Authentication

&amp;lt;h2&amp;gt;Claims&amp;lt;/h2&amp;gt;

&amp;lt;dl&amp;gt;
    @foreach (var claim in User.Claims)
    {
        &amp;lt;dt&amp;gt;@claim.Type&amp;lt;/dt&amp;gt;
        &amp;lt;dd&amp;gt;@claim.Value&amp;lt;/dd&amp;gt;
    }
&amp;lt;/dl&amp;gt;

&amp;lt;h2&amp;gt;Properties&amp;lt;/h2&amp;gt;

&amp;lt;dl&amp;gt;
    @foreach (var prop in (await Context.AuthenticateAsync()).Properties.Items)
    {
        &amp;lt;dt&amp;gt;@prop.Key&amp;lt;/dt&amp;gt;
        &amp;lt;dd&amp;gt;@prop.Value&amp;lt;/dd&amp;gt;
    }
&amp;lt;/dl&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 Privacy 页面，跳转到认证服务地址，进行账号密码登录，Logout 用于用户的注销操作。&lt;/p&gt;
&lt;h3 id=&quot;336-添加资源访问&quot;&gt;3.3.6 添加资源访问&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;HomeController&lt;/code&gt;控制器添加对API资源访问的接口方法。在进行请求的时候，访问API受保护资源。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;        /// &amp;lt;summary&amp;gt;
        /// 测试请求API资源(api1)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public async Task&amp;lt;IActionResult&amp;gt; getApi()
        {
            var client = new HttpClient();
            var accessToken = await HttpContext.GetTokenAsync(OpenIdConnectParameterNames.AccessToken);
            if (string.IsNullOrEmpty(accessToken))
            {
                return Json(new { msg = &quot;accesstoken 获取失败&quot; });
            }
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, accessToken);
            var httpResponse = await client.GetAsync(&quot;http://localhost:5003/api/identity/GetUserClaims&quot;); 
            var result = await httpResponse.Content.ReadAsStringAsync();
            if (!httpResponse.IsSuccessStatusCode)
            {
                return Json(new { msg = &quot;请求 api1 失败。&quot;, error = result });
            }
            return Json(new
            {
                msg = &quot;成功&quot;,
                data = JsonConvert.DeserializeObject(result)
            });
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;测试这里通过获取accessToken之后，设置client请求头的认证，访问API资源受保护的地址，获取资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;34-效果&quot;&gt;3.4 效果&lt;/h2&gt;
&lt;h3 id=&quot;341-动图&quot;&gt;3.4.1 动图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202012/1576550-20201203220322160-1921994483.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;342-过程&quot;&gt;3.4.2 过程&lt;/h3&gt;
&lt;p&gt;在用户访问MVC程序时候，将用户导向认证服务器，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202012/1576550-20201203220200085-1969978447.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在客户端向授权服务器&lt;code&gt;Authorization Endpoint&lt;/code&gt;进行验证的时候，我们可以发现，向授权服务器发送的请求附带的那些参数就是我们之前说到的数据(clientid,redirect_url,type等)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202012/1576550-20201203220216934-119764778.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续往下看，发现在用户给予授权完成登录之后，可以看到在登录后，授权服务器向重定向URL地址同时带上一个授权码数据带给MVC程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202012/1576550-20201203220229158-357342996.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随后MVC向授权客户端的Token终结点发送请求，从下图可以看到这次请求包含了client_id，client_secret，code，grant_type和redirect_uri，向授权服务器申请访问令牌token, 并且在响应中可以看到授权服务器核对了授权码和重定向地址URI，确认无误后，向第三方应用发送访问令牌(Access Token)和更新令牌(Refresh token)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202012/1576550-20201203220242385-1188830801.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成获取令牌后，访问受保护资源的时候，带上令牌请求访问，可以成功响应获取用户信息资源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576550/202012/1576550-20201203220253904-1995271225.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;本篇主要阐述以&lt;strong&gt;授权码授权&lt;/strong&gt;，编写一个MVC客户端，并通过客户端以浏览器的形式请求&lt;strong&gt;IdentityServer&lt;/strong&gt;上请求获取访问令牌，从而访问受保护的API资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;授权码模式&lt;/strong&gt;解决了简化模式由于token携带在url中，安全性方面不能保证问题，而通过授权码的模式不直接返回token，而是先返回一个授权码，然后再根据这个授权码去请求token，这个请求token这个过程需要放在后台，这种方式也更为安全。适用于有后端的应用。&lt;/li&gt;
&lt;li&gt;在后续会对这方面进行介绍继续说明，数据库持久化问题，以及如何应用在API资源服务器中和配置在客户端中，会进一步说明。&lt;/li&gt;
&lt;li&gt;如果有不对的或不理解的地方，希望大家可以多多指正，提出问题，一起讨论,不断学习,共同进步。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/i3yuan/Yuan.IdentityServer4.Demo/tree/main/DiffAuthMode/AuthorizationCode&quot;&gt;项目地址&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://identityserver4.readthedocs.io/en/latest/intro/big_picture.html?highlight=OpenID%20Connect#openid-connect-and-oauth-2-0-better-together&quot;&gt;&lt;strong&gt;OpenID Connect&lt;/strong&gt;资料&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://oauth.net/2/grant-types/authorization-code/&quot;&gt;&lt;strong&gt;Authorization Code资料&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.thinktecture.com/en/identity/samesite/prepare-your-identityserver/&quot;&gt;samesite问题解决&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 04 Dec 2020 00:00:00 +0000</pubDate>
<dc:creator>艾三元</dc:creator>
<og:description>一、前言 在上一篇关于简化模式中，通过客户端以浏览器的形式请求IdentityServer服务获取访问令牌，从而请求获取受保护的资源，但由于token携带在url中，安全性方面不能保证。因此，我们可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/i3yuan/p/14064380.html</dc:identifier>
</item>
<item>
<title>Django匆匆一眼却解答了多年疑惑 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14078741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14078741.html</guid>
<description>&lt;p&gt;Django 是 Python 的 一款 Web 开发框架，另外还有 Tornado，Flask，Twisted。为什么我要选择学 Django？原因很简单，上家公司来了个网易的测开，就是用 Django 开发的测试平台。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这位测开没多久就离职去腾讯了，我啥也没学到，看了他的代码，很多是写的 Vue 代码，哭啊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Django 诞生于 2003 年的秋天，由 Lawrence Journal-World 报纸的程序员 Adrian Holovaty 和 Simon Willison 编写而成。新闻编辑室的开发节奏是非常快的，正因如此，Django 相比于其他框架的特点就是短、平、快。这也符合 Python 的风格。时至今日，Django 已经发展到了 3.1.3 版本。本系列将基于这一版本的官方文档，边学习边实践，整理成文，分享给大家。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Django 系列不是教程，而是学习笔记、心得体会、踩坑记录，内容编排上可能会有点乱。需要看教程请阅读官方文档，水平有限，实在抱歉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Django 遵循 MVC 架构模式，所以接下来就看看如何使用 Django 完成 Web 开发。特别注意，本文的内容不具有实操性，看看即可。&lt;/p&gt;

&lt;p&gt;model 是数据模型，定义了数据库的表和字段。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.db import models

class Reporter(models.Model):
    full_name = models.CharField(max_length=70)

    def __str__(self):
        return self.full_name

class Article(models.Model):
    pub_date = models.DateField()
    headline = models.CharField(max_length=200)
    content = models.TextField()
    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)

    def __str__(self):
        return self.headline
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过类和属性，分别定义了 2 张表 Reporter 和 Article，以及它们的字段（Reporter 1 个字段，Article 4 个字段）。&lt;/p&gt;
&lt;p&gt;这其实就是 ORM，即 Object Relational Mapping，对象关系映射，把程序代码中的对象映射到关系型数据库中，不用写 SQL，就可以直接操作数据了。ORM 实现了数据持久化。我们都知道程序是运行在内存中的，跑完就没了。为了把数据保存下来，就需要使用 ORM 技术把内存中的数据（程序对象）存到关系型数据库中，进而转移到磁盘上。Django 自带了一个 ORM，开箱即用。&lt;/p&gt;

&lt;p&gt;使用 2 条命令，就可以把 model 迁移到数据库中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;$ python manage.py makemigrations
$ python manage.py migrate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行完成后，就会在数据库中按照 model 定义的表名、字段名、约束条件等，创建表结构。&lt;/p&gt;

&lt;p&gt;接着就可以在程序中写代码操作数据了。为了直观看到结果，这里以命令行形式进行演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 导入已创建的 models
&amp;gt;&amp;gt;&amp;gt; from news.models import Article, Reporter

# 查询表 Reporter 为空
&amp;gt;&amp;gt;&amp;gt; Reporter.objects.all()
&amp;lt;QuerySet []&amp;gt;

# 实例化对象，创建 1 条数据，表 Reporter 的字段是 full_name
&amp;gt;&amp;gt;&amp;gt; r = Reporter(full_name='John Smith')

# 必须显式调用 save() 函数，才会真正写数据到数据库
&amp;gt;&amp;gt;&amp;gt; r.save()

# 保存后就有 id 了
&amp;gt;&amp;gt;&amp;gt; r.id
1

# 查询表 Reporter 有数据了
&amp;gt;&amp;gt;&amp;gt; Reporter.objects.all()
&amp;lt;QuerySet [&amp;lt;Reporter: John Smith&amp;gt;]&amp;gt;

# 访问对象属性
&amp;gt;&amp;gt;&amp;gt; r.full_name
'John Smith'

# Django 提供了 get() 函数来支持更多查询方式
&amp;gt;&amp;gt;&amp;gt; Reporter.objects.get(id=1)
&amp;lt;Reporter: John Smith&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Reporter.objects.get(full_name__startswith='John')
&amp;lt;Reporter: John Smith&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Reporter.objects.get(full_name__contains='mith')
&amp;lt;Reporter: John Smith&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Reporter.objects.get(id=2)
Traceback (most recent call last):
    ...
DoesNotExist: Reporter matching query does not exist.

# 给表 Article 添加 1 条数据
# 有 4 个字段 pub_date, headline, content, reporter
# reporter=r，用 Reporter 对象赋值
&amp;gt;&amp;gt;&amp;gt; from datetime import date
&amp;gt;&amp;gt;&amp;gt; a = Article(pub_date=date.today(), headline='Django is cool',
...     content='Yeah.', reporter=r)
&amp;gt;&amp;gt;&amp;gt; a.save()

# 表 Article 也有数据了
&amp;gt;&amp;gt;&amp;gt; Article.objects.all()
&amp;lt;QuerySet [&amp;lt;Article: Django is cool&amp;gt;]&amp;gt;

# a.reporter 可以赋值给 r
&amp;gt;&amp;gt;&amp;gt; r = a.reporter
&amp;gt;&amp;gt;&amp;gt; r.full_name
'John Smith'

# r 也可以访问 Article
&amp;gt;&amp;gt;&amp;gt; r.article_set.all()
&amp;lt;QuerySet [&amp;lt;Article: Django is cool&amp;gt;]&amp;gt;

# 可以借助 filter() 函数按条件过滤数据
&amp;gt;&amp;gt;&amp;gt; Article.objects.filter(reporter__full_name__startswith='John')
&amp;lt;QuerySet [&amp;lt;Article: Django is cool&amp;gt;]&amp;gt;

# 赋值后调用 save() 函数更新数据
&amp;gt;&amp;gt;&amp;gt; r.full_name = 'Billy Goat'
&amp;gt;&amp;gt;&amp;gt; r.save()

# 使用 delete() 函数删除对象，数据库这条数据也会被删除
&amp;gt;&amp;gt;&amp;gt; r.delete()
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;一般不会用它。&lt;/p&gt;

&lt;p&gt;我们是通过 URL 发送请求的，服务端程序做处理，处理的函数叫做回调函数。Django 在 urls.py 文件中编写 URL 和回调函数的映射关系。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path

from . import views

urlpatterns = [
    path('articles/&amp;lt;int:year&amp;gt;/', views.year_archive),
    path('articles/&amp;lt;int:year&amp;gt;/&amp;lt;int:month&amp;gt;/', views.month_archive),
    path('articles/&amp;lt;int:year&amp;gt;/&amp;lt;int:month&amp;gt;/&amp;lt;int:pk&amp;gt;/', views.article_detail),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;path()&lt;/code&gt; 的第一参数是 URL，这里使用了 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 参数标签来获取 URL 中的数据，然后传入到回调函数中。第二个参数是回调函数，位于 views 中。&lt;/p&gt;
&lt;p&gt;如果请求 URL “/articles/2005/05/39323/”，Django 就会获取参数值后调用回调函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;news.views.article_detail(request, year=2005, month=5, pk=39323)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Django 在启动加载时就会把这些 path 编译为正则表达式，查找速度飞快。匹配到第一个后就会停止查找，调用回调函数。如果找完了都没有，就会调用 404 这个特殊 view，表示没找到。&lt;/p&gt;

&lt;p&gt;在 views 中编写回调函数。每个回调函数只做 1 件事，要么返回包含响应的 &lt;code&gt;HttpResponse&lt;/code&gt; 对象，要么抛出异常，如 &lt;code&gt;Http404&lt;/code&gt; 。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.shortcuts import render

from .models import Article

def year_archive(request, year):
    a_list = Article.objects.filter(pub_date__year=year)
    context = {'year': year, 'article_list': a_list}
    return render(request, 'news/year_archive.html', context)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;return render() 函数会返回一个 &lt;code&gt;HttpResponse&lt;/code&gt; 对象。&lt;/p&gt;
&lt;p&gt;注意，这个例子用到的是 Django 自带的模板引擎。所谓模板引擎，就是前端的 HTML 模板，里面的数据可以写成变量，从后端动态获取。除了内置的这个，还有其他模板引擎如 Thymeleaf、FreeMarker 等。不过这些使用都很少了。现在流行前后端分离，后端不需要写 HTML，只提供 RESTful 接口就可以了。说到 RESTful，就不得不提另外一个 Django 的衍生框架 DRF（Django REST Framework）。一步一步来，先学好了 Django，才能更好理解 DRF。&lt;/p&gt;

&lt;p&gt;暂时不做介绍。&lt;/p&gt;

&lt;p&gt;本文以 Web 后台为例，讲解了从 model，到 ORM，到数据操作，到 URL 映射，到 views 回调函数的编写链路。实际操作会复杂得多。以前学其他框架有点懵，写这篇文章，倒是让我明白了 MVC 这一套是这么一回事。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.djangoproject.com/en/3.1/intro/overview/&quot;&gt;https://docs.djangoproject.com/en/3.1/intro/overview/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 03 Dec 2020 23:45:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>Django系列开篇。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14078741.html</dc:identifier>
</item>
<item>
<title>MySQL（13）---MYSQL主从复制原理 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/14021773.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/14021773.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;最近在做项目的时候，因为部署了 &lt;strong&gt;MYSQL主从复制&lt;/strong&gt; 所以在这里记录下整个过程。这里一共会分两篇博客来写:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、Mysql主从复制原理
2、docker部署Mysql主从复制实战
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这篇只写MYSQL主从复制原理。&lt;/p&gt;
&lt;h2 id=&quot;一、概述&quot;&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;1、什么是主从复制&quot;&gt;1、什么是主从复制?&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;概念&lt;/code&gt; 主从复制是用来建立一个和 &lt;strong&gt;主数据库完全一样的数据库环境称为从数据库&lt;/strong&gt;；主数据库一般是准实时的业务数据库。&lt;/p&gt;
&lt;h4 id=&quot;2、主从复制作用&quot;&gt;2、主从复制作用&lt;/h4&gt;
&lt;p&gt;我们来思考如果在企业网站中，后端MYSQL数据库只有一台时候，会有以下问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、单点故障服务不可用
2、无法处理大量的并发数据请求
3、数据丢失
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以通过主从复制后，它的优点就很明显&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、如果主节点出现故障，那么我们就直接将服务切到从节点，来保证服务立马可用。
2、如果并发请求特别大的时候，我们可用进行读写分离操作，让主库负责写，从库负责读。
3、如果主库数据丢失，但从库还保存一份，减少数据丢失的风险。
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;二、主从复制原理&quot;&gt;&lt;span&gt;二、主从复制原理&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;1、主从复制原理&quot;&gt;1、主从复制原理&lt;/h4&gt;
&lt;p&gt;这里先放一张图，这张图很好的诠释的主从复制的原理&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/1090617/202011/1090617-20201122215835282-1185896769.jpg&quot; width=&quot;700&quot; height=&quot;420&quot;/&gt;&lt;p&gt;上面主要分成了三步，下面会详细说明。&lt;/p&gt;
&lt;p&gt;(1) Master的更新事件(update、insert、delete)会按照顺序写入&lt;code&gt;bin-log&lt;/code&gt;中。当Slave连接到Master的后,Master机器会为Slave开启&lt;/p&gt;
&lt;p&gt;&lt;code&gt;binlog dump&lt;/code&gt;线程,该线程会去读取bin-log日志&lt;/p&gt;
&lt;p&gt;(2) Slave连接到Master后,Slave库有一个&lt;code&gt;I/O线程&lt;/code&gt; 通过请求binlog dump thread读取bin-log日志,然后写入从库的&lt;code&gt;relay log&lt;/code&gt;日志中。&lt;/p&gt;
&lt;p&gt;(3) Slave还有一个 &lt;code&gt;SQL线程&lt;/code&gt;,实时监控 relay-log日志内容是否有更新,解析文件中的SQL语句,在Slave数据库中去执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;(1) 既然是要把事件记录到bin-log日志，那么对于Master就必须&lt;strong&gt;开启bin-log功能&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;(2) 整个Mysql主从复制一共开启了3个线程。&lt;strong&gt;Master开启 IO线程，Slave开启 IO线程 和 SQL线程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;(3) 这点也很重要那就是Master和Slave交互的时候，记住这里是&lt;code&gt;Slave去请求Master,而不是Master主动推给Slave&lt;/code&gt;。Slave通过IO线程&lt;/p&gt;
&lt;p&gt;连接Master后发起请求,Master服务器收到Slave IO线程发来的日志请求信息，io线程去将bin-log内容返回给slave IO线程。&lt;/p&gt;
&lt;h4 id=&quot;2、mysql主从复制同步方式&quot;&gt;2、MySQL主从复制同步方式&lt;/h4&gt;
&lt;p&gt;(1)&lt;code&gt;异步复制&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL主从同步 默认是异步复制的&lt;/strong&gt;。就是上面三步中,只有第一步是同步的(也就是Mater写入bin log日志),就是主库写入binlog日志后即可成功返回客户端，无须等待binlog&lt;/p&gt;
&lt;p&gt;日志传递给从库的过程。Master 不关心 Slave 的数据有没有写入成功。因此如果Master和Slave之间有网络延迟，就会造成暂时的数据不一致的现象；如果Master出故障，而数据&lt;/p&gt;
&lt;p&gt;还没有复制过去，则会造成数据丢失；但也有好处，效率较其他两种复制方式最高。&lt;/p&gt;
&lt;p&gt;（2)&lt;code&gt;同步复制&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于同步复制而言，Master主机将事件发送给Slave主机后会触发一个等待，直到&lt;code&gt;所有Slave节点&lt;/code&gt;（如果有多个Slave）返回数据复制成功的信息给Master。这种复制方式最安&lt;/p&gt;
&lt;p&gt;全，但是同时，效率也是最差的。&lt;/p&gt;
&lt;p&gt;（3)&lt;code&gt;半同步复制&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于半同步复制而言，Master主机将事件发送给Slave主机后会触发一个等待，直到&lt;code&gt;其中一个Slave节点&lt;/code&gt;（如果有多个Slave）返回数据复制成功的信息给Master。由此增强了&lt;/p&gt;
&lt;p&gt;数据的一致性，但是因为Master主机的确认开销，会损耗一部分的性能；另外，半同步复制除了不需要等待所有Slave主机确认事件的接收外，半同步数据复制并不要求那些事件&lt;/p&gt;
&lt;p&gt;完全地执行，因此，仍有可能看到在Slave主机上数据复制延迟的发生，如果因为网络延迟等原因造成Slave迟迟没有返回复制成功的信息，超过了Master设置的超时时长，半同步&lt;/p&gt;
&lt;p&gt;复制就降级为异步复制方式，而后继续数据复制。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;三、mysql主从同步延时&quot;&gt;&lt;span&gt;三、Mysql主从同步延时&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上面也说了，&lt;strong&gt;Mysql默认采用的异步操作&lt;/strong&gt;，因为它的效率明显是最高的。因为只要写入bin log后事物就结束返回成功了。但由于&lt;strong&gt;从库从主库异步拷贝日志&lt;/strong&gt; 以及&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;串行执行 SQL 的特点&lt;/strong&gt;，所以从库的数据一定会比主库慢一些，是有延时的。所以经常出现，刚写入主库的数据可能是读不到的，要过几十毫秒，甚至几百毫秒才能&lt;/p&gt;
&lt;p&gt;读取到。这就是主从同步延时问题。&lt;/p&gt;
&lt;h4 id=&quot;1、如何查看主从延迟时间&quot;&gt;1、如何查看主从延迟时间&lt;/h4&gt;
&lt;p&gt;通过监控 &lt;code&gt;show slave status&lt;/code&gt; 命令输出的Seconds_Behind_Master参数的值来判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysql&amp;gt; show slave status\G;
    // 状态一
    Seconds_Behind_Master: NULL
    // 状态二
    Seconds_Behind_Master: 0
    // 状态三
    Seconds_Behind_Master: 79
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Seconds_Behind_Master=0&lt;/strong&gt;: 表示主从复制良好；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seconds_Behind_Master=NULL&lt;/strong&gt;: 表示io_thread或是sql_thread有任何一个发生故障；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Seconds_Behind_Master=79&lt;/strong&gt;: 数字越大表示从库延迟越严重。&lt;/p&gt;
&lt;h4 id=&quot;2、影响延迟因素&quot;&gt;2、影响延迟因素&lt;/h4&gt;
&lt;p&gt;这里整理了影响主从复制延迟大致有以下几个原因：&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;主节点如果执行一个很大的事务，那么就会对主从延迟产生较大的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;网络延迟，日志较大，slave数量过多&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;主上多线程写入，从节点只有单线程同步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;机器性能问题，从节点是否使用了“烂机器”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5）&lt;strong&gt;锁冲突问题也可能导致从机的SQL线程执行慢&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;3、优化主从复制延迟&quot;&gt;3、优化主从复制延迟&lt;/h4&gt;
&lt;p&gt;这个没有说去完全解决，要想解决那么就只能采用同步复制策略。不过，一般不建议使用这种同步模式。显而易见，如果写操作必须等待更新同步完成，肯定会&lt;/p&gt;
&lt;p&gt;极大地影响性能，除非你不在乎性能。&lt;/p&gt;
&lt;p&gt;1）&lt;strong&gt;大事务：将大事务分为小事务，分批更新数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2）&lt;strong&gt;减少Slave的数量，不要超过5个，减少单次事务的大小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3）&lt;strong&gt;MySQL 5.7之后，可以使用多线程复制，使用MGR复制架构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;4）&lt;strong&gt;在磁盘、raid卡、调度策略有问题的情况下可能会出现单个IO延迟很高的情况，可用iostat命令查看DB数据盘的IO情况，再进一步判断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5）&lt;strong&gt;针对锁问题可以通过抓去processlist以及查看information_schema下面和锁以及事务相关的表来查看&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;主机与从机之间的物理延迟是无法避免的，既然无法避免就可以考虑尝试通过缓存等方式，降低新修改数据被立即读取的概率。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.jianshu.com/p/55e110bc40cf&quot;&gt;Mysql主从延时&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://database.51cto.com/art/202004/614426.htm&quot;&gt;你知道MySQL主从复制的原理吗&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://segmentfault.com/a/1190000018153974&quot;&gt;MySQL主从同步机制和同步延时问题追查&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;别人骂我胖，我会生气，因为我心里承认了我胖。别人说我矮，我就会觉得好笑，因为我心里知道我不可能矮。这就是我们为什么会对别人的攻击生气。
攻我盾者，乃我内心之矛(32)
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 03 Dec 2020 18:00:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>MYSQL主从复制原理 最近在做项目的时候，因为部署了 MYSQL主从复制 所以在这里记录下整个过程。这里一共会分两篇博客来写: 1、Mysql主从复制原理 2、docker部署Mysql主从复制实战</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/14021773.html</dc:identifier>
</item>
<item>
<title>Spring Boot 项目瘦身指南，瘦到不可思议！129M-&gt;1.3M - niceyoo</title>
<link>http://www.cnblogs.com/niceyoo/p/14083706.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niceyoo/p/14083706.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前在 &lt;a href=&quot;https://www.cnblogs.com/niceyoo/p/14022503.html&quot;&gt;从使用传统Web框架到切换到Spring Boot后的总结&lt;/a&gt; 中提到关于 Spring Boot 编译打包，Spring Boot 应用程序不用额外部署到外部容器中，可以直接通过 Maven 命令将项目编译成可执行的 jar 包，然后通过 java -jar 命令启动即可，非常方便。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近有小伙伴私信我说，打 jar 包方便是方便，就是每次打包出来的 jar 太大了，先不说上传时间的问题，如果只修改了 1 个类就需要重新打包项目，然后重新上传项目到服务器，怎么觉得还不如我之前使用 war 包方便呢，使用 war 包时，虽然要部署到 Tomcat 中，但只需要将修改的 class 替换一下，重启一下 Tomcat 就可以了。。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实到底选择哪种打包方式，主要还是看个人习惯和业务场景需求，毕竟 Spring Boot 也支持打包 war 包的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的重点不是打包方式，而是解决困惑了小伙伴打包的 jar 太大的问题。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;正常打包项目&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给 Spring Boot 打包大家应该很熟了吧，只需要在 pom.xml 文件中配置 &lt;code&gt;spring-boot-maven-plugin&lt;/code&gt; 打包插件：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&amp;lt;build&amp;gt;&lt;br/&gt;&amp;lt;plugins&amp;gt;&lt;br/&gt;&amp;lt;plugin&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/plugin&amp;gt;&lt;br/&gt;&amp;lt;/plugins&amp;gt;&lt;br/&gt;&amp;lt;/build&amp;gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在项目根目录执行 &lt;code&gt;mvn clean pavkage&lt;/code&gt; 就可以完成打包了，如下是我本地的一个项目打包情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201201234832367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到打包出的 jar 应用是相当的大了，如小伙伴说的一样，如果每次修改一个 class 文件或者配置文件，就需要重新打包然后上传服务器的话，那确实是太麻烦了，可能上传就浪费大部分时间。。。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;应用瘦身（分离lib和配置文件）&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 jar 包大的原因在于所有的依赖包全部集成在 jar 包里面，如下是瘦身前的 jar 包内部结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201201235604168.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 classes 就是我们项目的代码，仅仅1.3M，而 129MB 的 lib 目录是项目中所有的依赖（比如spinrg、Hibernate等依赖），如果我们能把这个 lib 目录提取出来，整个项目就会变得特别小了。说干就干。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道 Spring Boot 的打包终究是依赖于 Maven ，所以想到更改打包信息，无非就是指定 Maven 的配置。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 pom.xml 添加如下信息（后文解释）：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;15&quot;&gt;&amp;lt;build&amp;gt;&lt;br/&gt;&amp;lt;finalName&amp;gt;你想要的jar包名称&amp;lt;/finalName&amp;gt;&lt;br/&gt;&amp;lt;plugins&amp;gt;&lt;br/&gt;&amp;lt;!-- 1、编译出不带 lib 文件夹的Jar包 --&amp;gt;&lt;br/&gt;&amp;lt;plugin&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;configuration&amp;gt;&lt;br/&gt;&amp;lt;!--表示编译版本配置有效--&amp;gt;&lt;br/&gt;&amp;lt;fork&amp;gt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&amp;lt;/fork&amp;gt;&lt;br/&gt;&amp;lt;!--引入第三方jar包时,不添加则引入的第三方jar不会被打入jar包中--&amp;gt;&lt;br/&gt;&amp;lt;includeSystemScope&amp;gt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&amp;lt;/includeSystemScope&amp;gt;&lt;br/&gt;&amp;lt;!--排除第三方jar文件--&amp;gt;&lt;br/&gt;&amp;lt;includes&amp;gt;&lt;br/&gt;&amp;lt;include&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;nothing&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;nothing&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/include&amp;gt;&lt;br/&gt;&amp;lt;/includes&amp;gt;&lt;br/&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&amp;lt;executions&amp;gt;&lt;br/&gt;&amp;lt;execution&amp;gt;&lt;br/&gt;&amp;lt;goals&amp;gt;&lt;br/&gt;&amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;&lt;br/&gt;&amp;lt;/goals&amp;gt;&lt;br/&gt;&amp;lt;/execution&amp;gt;&lt;br/&gt;&amp;lt;/executions&amp;gt;&lt;br/&gt;&amp;lt;/plugin&amp;gt;&lt;p&gt;&amp;lt;!-- 2、完成对Java代码的编译，可以指定项目源码的jdk版本，编译后的jdk版本，以及编码 --&amp;gt;&lt;br/&gt;&amp;lt;plugin&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;configuration&amp;gt;&lt;br/&gt;&amp;lt;!-- 源代码使用的JDK版本 --&amp;gt; &lt;br/&gt;&amp;lt;&lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt;&amp;gt;&lt;span class=&quot;hljs-variable&quot;&gt;${java.version}&lt;/span&gt;&amp;lt;/&lt;span class=&quot;hljs-built_in&quot;&gt;source&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;!-- 需要生成的目标class文件的编译版本 --&amp;gt;&lt;br/&gt;&amp;lt;target&amp;gt;&lt;span class=&quot;hljs-variable&quot;&gt;${java.version}&lt;/span&gt;&amp;lt;/target&amp;gt;&lt;br/&gt;&amp;lt;!-- 字符集编码 --&amp;gt;&lt;br/&gt;&amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;&lt;br/&gt;&amp;lt;!-- 用来传递编译器自身不包含但是却支持的参数选项 --&amp;gt;  &lt;br/&gt;&amp;lt;compilerArguments&amp;gt;&lt;br/&gt;&amp;lt;verbose/&amp;gt;&lt;br/&gt;&amp;lt;!-- windwos环境（二选一） --&amp;gt;&lt;br/&gt;&amp;lt;bootclasspath&amp;gt;&lt;span class=&quot;hljs-variable&quot;&gt;${java.home}&lt;/span&gt;/lib/rt.jar:&lt;span class=&quot;hljs-variable&quot;&gt;${java.home}&lt;/span&gt;/lib/jce.jar&amp;lt;/bootclasspath&amp;gt;&lt;br/&gt;&amp;lt;!-- Linux环境（二选一） --&amp;gt;&lt;br/&gt;&amp;lt;bootclasspath&amp;gt;&lt;span class=&quot;hljs-variable&quot;&gt;${java.home}&lt;/span&gt;/lib/rt.jar:&lt;span class=&quot;hljs-variable&quot;&gt;${java.home}&lt;/span&gt;/lib/jce.jar&amp;lt;/bootclasspath&amp;gt;&lt;br/&gt;&amp;lt;/compilerArguments&amp;gt;&lt;br/&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&amp;lt;/plugin&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;!-- 3、将所有依赖的jar文件复制到target/lib目录 --&amp;gt;&lt;br/&gt;&amp;lt;plugin&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;maven-dependency-plugin&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;executions&amp;gt;&lt;br/&gt;&amp;lt;execution&amp;gt;&lt;br/&gt;&amp;lt;id&amp;gt;copy-dependencies&amp;lt;/id&amp;gt;&lt;br/&gt;&amp;lt;phase&amp;gt;prepare-package&amp;lt;/phase&amp;gt;&lt;br/&gt;&amp;lt;goals&amp;gt;&lt;br/&gt;&amp;lt;goal&amp;gt;copy-dependencies&amp;lt;/goal&amp;gt;&lt;br/&gt;&amp;lt;/goals&amp;gt;&lt;br/&gt;&amp;lt;configuration&amp;gt;&lt;br/&gt;&amp;lt;!--复制到哪个路径，&lt;span class=&quot;hljs-variable&quot;&gt;${project.build.directory}&lt;/span&gt; 缺醒为 target，其他内置参数见下面解释--&amp;gt;&lt;br/&gt;&amp;lt;outputDirectory&amp;gt;&lt;span class=&quot;hljs-variable&quot;&gt;${project.build.directory}&lt;/span&gt;/lib&amp;lt;/outputDirectory&amp;gt;&lt;br/&gt;&amp;lt;overWriteReleases&amp;gt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&amp;lt;/overWriteReleases&amp;gt;&lt;br/&gt;&amp;lt;overWriteSnapshots&amp;gt;&lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&amp;lt;/overWriteSnapshots&amp;gt;&lt;br/&gt;&amp;lt;overWriteIfNewer&amp;gt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&amp;lt;/overWriteIfNewer&amp;gt;&lt;br/&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&amp;lt;/execution&amp;gt;&lt;br/&gt;&amp;lt;/executions&amp;gt;&lt;br/&gt;&amp;lt;/plugin&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;!-- 4、指定启动类，指定配置文件，将依赖打成外部jar包 --&amp;gt;&lt;br/&gt;&amp;lt;plugin&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;maven-jar-plugin&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;configuration&amp;gt;&lt;br/&gt;&amp;lt;archive&amp;gt;&lt;br/&gt;&amp;lt;manifest&amp;gt;&lt;br/&gt;&amp;lt;!-- 是否要把第三方jar加入到类构建路径 --&amp;gt;&lt;br/&gt;&amp;lt;addClasspath&amp;gt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&amp;lt;/addClasspath&amp;gt;&lt;br/&gt;&amp;lt;!-- 外部依赖jar包的最终位置 --&amp;gt;&lt;br/&gt;&amp;lt;classpathPrefix&amp;gt;lib/&amp;lt;/classpathPrefix&amp;gt;&lt;br/&gt;&amp;lt;!-- 项目启动类 --&amp;gt;&lt;br/&gt;&amp;lt;mainClass&amp;gt;com.javam4.MyApplication&amp;lt;/mainClass&amp;gt;&lt;br/&gt;&amp;lt;/manifest&amp;gt;&lt;br/&gt;&amp;lt;/archive&amp;gt;&lt;br/&gt;&amp;lt;!--资源文件不打进jar包中，做到配置跟项目分离的效果--&amp;gt;&lt;br/&gt;&amp;lt;excludes&amp;gt;&lt;br/&gt;&amp;lt;!-- 业务jar中过滤application.properties/yml文件，在jar包外控制 --&amp;gt;&lt;br/&gt;&amp;lt;exclude&amp;gt;*.properties&amp;lt;/exclude&amp;gt;&lt;br/&gt;&amp;lt;exclude&amp;gt;*.xml&amp;lt;/exclude&amp;gt;&lt;br/&gt;&amp;lt;exclude&amp;gt;*.yml&amp;lt;/exclude&amp;gt;&lt;br/&gt;&amp;lt;/excludes&amp;gt;&lt;br/&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&amp;lt;/plugin&amp;gt;&lt;/p&gt;&lt;p&gt;&amp;lt;/plugins&amp;gt;&lt;br/&gt;&amp;lt;/build&amp;gt;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下一一细拆如上配置：&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1、spring-boot-maven-plugin&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Springboot 默认使用 &lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt; 来打包，这个插件会将项目所有的依赖打入项目 &lt;strong&gt;jar&lt;/strong&gt; 包里面，正常打包时 &lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt; 结构如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&amp;lt;plugin&amp;gt;  &lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;   &lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;  &lt;br/&gt;&amp;lt;configuration&amp;gt;  &lt;br/&gt;&amp;lt;mainClass&amp;gt;com.javam4.MyApplication&amp;lt;/mainClass&amp;gt;  &lt;br/&gt;&amp;lt;layout&amp;gt;ZIP&amp;lt;/layout&amp;gt;  &lt;br/&gt;&amp;lt;/configuration&amp;gt;  &lt;br/&gt;&amp;lt;executions&amp;gt;  &lt;br/&gt;&amp;lt;execution&amp;gt;  &lt;br/&gt;&amp;lt;goals&amp;gt;  &lt;br/&gt;&amp;lt;goal&amp;gt;repackage&amp;lt;/goal&amp;gt;  &lt;br/&gt;&amp;lt;/goals&amp;gt;  &lt;br/&gt;&amp;lt;/execution&amp;gt;  &lt;br/&gt;&amp;lt;/executions&amp;gt;  &lt;br/&gt;&amp;lt;/plugin&amp;gt;  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下是提取的修改项：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&amp;lt;configuration&amp;gt;&lt;br/&gt;&amp;lt;!--表示编译版本配置有效--&amp;gt;&lt;br/&gt;&amp;lt;fork&amp;gt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&amp;lt;/fork&amp;gt;&lt;br/&gt;&amp;lt;!--引入第三方jar包时,不添加则引入的第三方jar不会被打入jar包中--&amp;gt;&lt;br/&gt;&amp;lt;includeSystemScope&amp;gt;&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;&amp;lt;/includeSystemScope&amp;gt;&lt;br/&gt;&amp;lt;!--排除第三方jar文件--&amp;gt;&lt;br/&gt;&amp;lt;includes&amp;gt;&lt;br/&gt;&amp;lt;include&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;nothing&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;nothing&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/include&amp;gt;&lt;br/&gt;&amp;lt;/includes&amp;gt;&lt;br/&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改的作用：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;includeSystemScope：jar包分两种，一种是spring、mybatis等这种项目依赖的，再就是我们外部手动引入的第三方 jar 依赖，如果该参数不设置为 true 的话是不能被打包进来的~&lt;/li&gt;
&lt;li&gt;includes：这个节点就是排除项目中所有的 jar，那还怎么打包？&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们需要将打包插件替换为 &lt;strong&gt;maven-jar-plugin&lt;/strong&gt;，然后使用该插件拷贝依赖到 &lt;strong&gt;jar&lt;/strong&gt; 到外面的 &lt;strong&gt;lib&lt;/strong&gt; 目录。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2、maven-xxx-plugin&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 2、3、4 你会发现用到了 maven-xxx-plugin 格式的三种插件，简单说一下这三者的作用：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;maven-compiler-plugin：&lt;/p&gt;
&lt;p&gt;完成对Java代码的编译，可以指定项目源码的jdk版本、编译后的jdk版本，以及编码，如果不写这个插件也是没问题的，不写会使用默认的 jdk 版本来处理，只是这样容易出现版本不匹配的问题，比如本地maven环境用的3.3.9版本，默认会使用jdk1.5进行编译，而项目中用的jdk1.8的编译环境，那就会导致打包时编译不通过。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;maven-dependency-plugin：&lt;/p&gt;
&lt;p&gt;作用就是将所有依赖的jar文件复制到指定目录下，其中涉及到的 &lt;code&gt;${project.xx}&lt;/code&gt; 见下文补充。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;maven-jar-plugin：&lt;/p&gt;
&lt;p&gt;主要作用就是将maven工程打包成jar包。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要说一下 maven-jar-plugin 插件的如下配置：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&amp;lt;configuration&amp;gt;&lt;br/&gt;&amp;lt;!--资源文件不打进jar包中，做到配置跟项目分离的效果--&amp;gt;&lt;br/&gt;&amp;lt;excludes&amp;gt;&lt;br/&gt;&amp;lt;!-- 业务jar中过滤application.properties/yml文件，在jar包外控制 --&amp;gt;&lt;br/&gt;&amp;lt;exclude&amp;gt;*.properties&amp;lt;/exclude&amp;gt;&lt;br/&gt;&amp;lt;exclude&amp;gt;*.xml&amp;lt;/exclude&amp;gt;&lt;br/&gt;&amp;lt;exclude&amp;gt;*.yml&amp;lt;/exclude&amp;gt;&lt;br/&gt;&amp;lt;/excludes&amp;gt;&lt;br/&gt;&amp;lt;/configuration&amp;gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打包时排除资源配置文件，如果排除了配置文件那么项目启动是怎么读取呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件有这么一个默认的优先级：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;当前项目config目录下&lt;/code&gt; &amp;gt; &lt;code&gt;当前项目根目录下&lt;/code&gt; &amp;gt; &lt;code&gt;类路径config目录下&lt;/code&gt; &amp;gt; &lt;code&gt;类路径根目录下&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此只需要将配置文件复制一份到与 jar 包平级目录下，或者与jar包平行config目录下，就能优先使用此配置文件，达到了伪分离目的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终的目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201203231241233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Maven 中的内置变量说明：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;&lt;code&gt;${basedir}&lt;/code&gt; 项目根目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${project.build.directory}&lt;/code&gt; 构建目录，缺省为target&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${project.build.outputDirectory}&lt;/code&gt; 构建过程输出目录，缺省为target/classes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${project.build.finalName}&lt;/code&gt; 产出物名称，缺省为{project.artifactId}-${project.version}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${project.packaging}&lt;/code&gt; 打包类型，缺省为jar&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${project.packaging}&lt;/code&gt; 打包类型，缺省为jar&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${project.xxx}&lt;/code&gt; 当前pom文件的任意节点的内容&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;瘦身总结&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot 框架提供了一套自己的打包机制 — &lt;strong&gt;spring-boot-maven-plugin&lt;/strong&gt;，Springboot 默认使用该插件来打包，打包时会将项目所有的依赖打入项目 &lt;strong&gt;jar&lt;/strong&gt; 包里面，如果我们想要抽离依赖的 jar 仅仅使用该插件是不行的，就需要将打包插件替换为 &lt;strong&gt;maven-jar-plugin&lt;/strong&gt;，并拷贝所有的依赖到 &lt;strong&gt;jar&lt;/strong&gt; 外面的 &lt;strong&gt;lib&lt;/strong&gt; 目录。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目打包时，在分离依赖 jar 包基础上，我们又排除了配置文件，因为配置文件有一个默认的读取路径：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;当前项目config目录下&lt;/code&gt; &amp;gt; &lt;code&gt;当前项目根目录下&lt;/code&gt; &amp;gt; &lt;code&gt;类路径config目录下&lt;/code&gt; &amp;gt; &lt;code&gt;类路径根目录下&lt;/code&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只需要在当前项目 jar 包同级目录创建一个 config 文件夹，然后将配置文件复制一份，这样就达到了伪分离目的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后再修改配置文件，比如端口号、数据库连接信息等，就不需要重新打包项目了，直接修改完配置文件重启项目就可以了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而经过分离依赖后的 jar 包从原来的100多兆到现在的1兆，如果后面需要变更业务逻辑，只需要轻量的编译项目，快速的实现项目的上传替换，有效的减少了网络开销，提高项目部署的效率。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;博客地址：&lt;a href=&quot;https://niceyoo.cnblogs.com&quot;&gt;https://niceyoo.cnblogs.com&lt;/a&gt;&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;更多原创内容可以移步我的公众号，回复「&lt;span&gt;&lt;strong&gt;面试&lt;/strong&gt;&lt;/span&gt;」获取我整理的2020面经。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/qrcode_for_gh_cd679214686a_2582.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 03 Dec 2020 16:20:00 +0000</pubDate>
<dc:creator>niceyoo</dc:creator>
<og:description>之前在 从使用传统Web框架到切换到Spring Boot后的总结 中提到关于 Spring Boot 编译打包，Spring Boot 应用程序不用额外部署到外部容器中，可以直接通过 Maven 命</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niceyoo/p/14083706.html</dc:identifier>
</item>
<item>
<title>《高并发下的.NET》第2季 - 故障公告：高并发下全线崩溃 - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/14083631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/14083631.html</guid>
<description>&lt;p&gt;大家好，非常抱歉，在昨天下午（12月3日）的访问高峰，园子迎来更高的并发，在这样的高并发下，突发的数据库连接故障造成博客站点全线崩溃，由此给您带来很大的麻烦，请您谅解。最近，我们一边在忙于AWS合作项目，一边在加快产品的改进速度，一边在统一全园UI，一边在忙于解决高并发下出现的各种问题。园子正处于发展的关键时期，我们正全力应对挑战，迎接园子的新阶段。感谢大家的支持，也请大家谅解这段时间给大家带来的麻烦。 今天下午的故障开始于 14:09 左右，最开始出现的故障是访问博客后台502。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;98.118315680703&quot;&gt;
&lt;p&gt;大家好，非常抱歉，在昨天下午（12月3日）的访问高峰，园子迎来更高的并发，在这样的高并发下，突发的数据库连接故障造成博客站点全线崩溃，由此给您带来很大的麻烦，请您谅解。&lt;/p&gt;
&lt;p&gt;最近，我们一边在忙于&lt;a href=&quot;https://www.cnblogs.com/cmt/p/14003277.html&quot;&gt;AWS合作项目&lt;/a&gt;，一边在加快产品的改进速度，一边在统一全园UI，一边在忙于解决高并发下出现的各种问题。园子正处于发展的关键时期，我们正全力应对挑战，迎接园子的新阶段。感谢大家的支持，也请大家谅解这段时间给大家带来的麻烦。&lt;/p&gt;
&lt;p&gt;今天下午的故障开始于 14:09 左右，最开始出现的故障是访问博客后台502。&lt;/p&gt;
&lt;p&gt;发生故障时博客后台第1条错误日志是 SqlClient 连接 SQL Server 数据库失败（我们用的是阿里云 RDS SQL Server 实例）&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;2020-12-03T14:09:48 ERR [Path:/healthz]/[Action:]/[Version:]&lt;br/&gt;Health check &quot;blogdb&quot; completed after 0.3522ms with status Unhealthy and description 'null'&lt;br/&gt;Microsoft.Data.SqlClient.SqlException (0x80131904): Connection Timeout Expired. The timeout period elapsed while attempting to consume the pre-login handshake acknowledgement. This could be because the pre-login handshake failed or the server was unable to respond back in time. This failure occurred while attempting to connect to the Principle server. The duration spent while attempting to connect to this server was - [Pre-Login] initialization=20025; handshake=3;&lt;br/&gt;---&amp;gt; System.ComponentModel.Win32Exception (258): Unknown error 258&lt;br/&gt;at Microsoft.Data.ProviderBase.DbConnectionPool.TryGetConnection(DbConnection owningObject, UInt32 waitForMultipleObjectsTimeout, Boolean allowCreate, Boolean onlyOneCheckConnection, DbConnectionOptions userOptions, DbConnectionInternal&amp;amp; connection)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3分钟后，博客站点也开始出现故障，表现为访问有时出现500错误。&lt;/p&gt;
&lt;p&gt;发生故障时博客站点第1个错误日志是 SqlClient 解析数据库服务器名称失败&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;2020-12-03 14:12:46.729 [Error] An exception occurred while iterating over the results of a query for context type '&quot;BlogServer.Infrastructure.Data.EfUnitOfWork&quot;'.&quot;&lt;br/&gt;&quot;&quot;Microsoft.Data.SqlClient.SqlException (0x80131904): A network-related or instance-specific error occurred while establishing a connection to SQL Server. The server was not found or was not accessible. Verify that the instance name is correct and that SQL Server is configured to allow remote connections. (provider: TCP Provider, error: 35 - An internal exception was caught)&lt;br/&gt;---&amp;gt; System.Net.Internals.SocketExceptionFactory+ExtendedSocketException (00000005, 0xFFFDFFFF): Name or service not known&lt;br/&gt;at System.Net.Dns.GetHostEntryOrAddressesCore(String hostName, Boolean justAddresses)&lt;br/&gt;at System.Net.Dns.GetHostAddresses(String hostNameOrAddress)&lt;br/&gt;at Microsoft.Data.SqlClient.SNI.SNITCPHandle.Connect(String serverName, Int32 port, TimeSpan timeout, Boolean isInfiniteTimeout, String cachedFQDN, SQLDNSInfo&amp;amp; pendingDNSInfo)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之后就是博客后台一直 502，博客站点访问速度慢，频繁出现500错误。&lt;/p&gt;
&lt;p&gt;在之后的故障处理过程中，我们进行了数据库服务器的主备切换，切换后博客后台恢复了正常。但高并发压力下的博客站点怎么也无法恢复正常，数据库主备切换后，数据库连接数飙升&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/35695/202012/35695-20201203234518459-929342101.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;之后我们使劲浑身解数，也无法让博客站点完全恢复正常，恢复到一定程度后发现，访问有时飞快有时非常缓慢，这与请求落在哪个 pod 有关，后来我们向 k8s 集群添加了更多服务器，scale 更多 pod ，然后强制一个一个停用运行时间最早的一批 pod ，这才有所缓解，但真正恢复是在过了访问高峰之后。&lt;/p&gt;
&lt;p&gt;先发布这篇博文向大家汇报一下故障的大致情况，对于故障的原因，我们需要进一步排查与分析，再次请大家谅解这次故障给您带来的麻烦。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 03 Dec 2020 16:08:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>大家好，非常抱歉，在昨天下午（12月3日）的访问高峰，园子迎来更高的并发，在这样的高并发下，突发的数据库连接故障造成博客站点全线崩溃，由此给您带来很大的麻烦，请您谅解。最近，我们一边在忙于AWS合作项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cmt/p/14083631.html</dc:identifier>
</item>
</channel>
</rss>