<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>物联网环境下数据分析的应用 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/5530633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/5530633.html</guid>
<description>&lt;p&gt;前记：这是我老婆写的一篇文章，结合了她当前的分析工作和物联网，介绍了物联网环境下数据分析的应用。&lt;/p&gt;
&lt;h2&gt;物联网概论及国内外研究现状&lt;/h2&gt;
&lt;p&gt; “物联网概念”是在“互联网概念”的基础上，将其用户端延伸和扩展到任何物品与物品之间，进行信息交换和通信的一种网络概念。&lt;/p&gt;
&lt;p&gt;物联网(Internet of Things)，国内外普遍公认的是MIT Auto-ID中心Ashton教授1999年在研究RFID时最早提出来的。在2005年国际电信联盟（ITU）发布的同名报告中，物联网的定义和范围已经发生了变化，覆盖范围有了较大的拓展，不再只是指基于&lt;a href=&quot;https://baike.baidu.com/item/RFID%E6%8A%80%E6%9C%AF&quot; target=&quot;_blank&quot;&gt;RFID技术&lt;/a&gt;的物联网。&lt;/p&gt;
&lt;p&gt;2009年8月，温家宝总理在无锡视察时提出“感知中国”，无锡市率先建立了“感知中国”研究中心，中国科学院、运营商、多所大学在无锡建立了物联网研究院。物联网被正式列为国家五大新兴战略性产业之一，写入了十一届全国人大三次会议政府工作报告，物联网在中国受到了全社会极大的关注。&lt;/p&gt;
&lt;p&gt;物联网的概念与其说是一个外来概念，不如说它已经是一个“中国制造”的概念，他的覆盖范围与时俱进，已经超越了1999年Ashton教授和2005年ITU报告所指的范围，物联网已被贴上“中国式”标签。&lt;/p&gt;
&lt;h2&gt;中国式物联网定义&lt;/h2&gt;
&lt;p&gt;最简洁明了的定义：物联网(Internet of Things)是一个基于互联网、传统电信网等信息承载体，让所有能够被独立寻址的普通物理对象实现互联互通的网络。它具有普通对象设备化、自治终端互联化和普适服务智能化3个重要特征。&lt;/p&gt;
&lt;p&gt;其它的定义：物联网指的是将无处不在（Ubiquitous）的末端设备&lt;/p&gt;
&lt;p&gt;（Devices）和设施（Facilities），包括具备“内在智能”的传感器、移动终端、工业系统、楼控系统、家庭智能设施、视频监控系统等、和“外在使能”(Enabled)的，如贴上RFID的各种资产（Assets）、携带无线终端的个人与车辆等等“智能化物件或动物”或“智能尘埃”（Mote），通过各种无线和/或有线的长距离和/或短距离通讯网络连接物联网域名实现互联互通（M2M)、应用大集成（Grand Integration)、以及基于云计算的SaaS营运等模式，在内网（Intranet）、专网（Extranet）、和/或互联网（Internet）环境下，采用适当的信息安全保障机制，提供安全可控乃至个性化的实时在线监测、定位追溯、报警联动、调度指挥、预案管理、远程控制、安全防范、远程维保、在线升级、统计报表、决策支持、领导桌面（集中展示的Cockpit Dashboard)等管理和服务功能，实现对“万物”的“高效、节能、安全、环保”的“管、控、营”一体化。&lt;/p&gt;
&lt;p&gt;“一句式”理解物联网：&lt;/p&gt;
&lt;p&gt;把所有物品通过信息传感设备与互联网连接起来，进行信息交换，即物物相息，以实现智能化识别和管理。&lt;/p&gt;
&lt;h2&gt;物联网的关键技术&lt;/h2&gt;
&lt;p&gt;在物联网应用中有三项关键技术&lt;/p&gt;
&lt;p&gt;1、传感器技术：这也是计算机应用中的关键技术。大家都知道，到目前为止绝大部分计算机处理的都是数字信号。自从有计算机以来就需要传感器把模拟信号转换成数字信号计算机才能处理。&lt;/p&gt;
&lt;p&gt;2、RFID标签：也是一种传感器技术，RFID技术是融合了无线射频技术和嵌入式技术为一体的综合技术，RFID在自动识别、物品物流管理有着广阔的应用前景。&lt;/p&gt;
&lt;p&gt;3、嵌入式系统技术：是综合了计算机软硬件、传感器技术、集成电路技术、电子应用技术为一体的复杂技术。经过几十年的演变，以嵌入式系统为特征的智能终端产品随处可见；小到人们身边的MP3,大到航天航空的卫星系统。嵌入式系统正在改变着人们的生活，推动着工业生产以及国防工业的发展。如果把物联网用人体做一个简单比喻，传感器相当于人的眼睛、鼻子、皮肤等感官，网络就是神经系统用来传递信息，嵌入式系统则是人的大脑，在接收到信息后要进行分类处理。这个例子很形象的描述了传感器、嵌入式系统在物联网中的位置与作用。&lt;/p&gt;
&lt;h2&gt;物联网的产业实践的三大方向&lt;/h2&gt;
&lt;p&gt;全球范围内物联网的产业实践主要集中在三大方向。&lt;/p&gt;
&lt;p&gt;何为数据“泛在聚合”意义上的物联网？&lt;/p&gt;
&lt;p&gt;第一个实践方向被称作“智慧尘埃”，主张实现各类传感器设备的互联互通，形成智能化功能的网络。&lt;/p&gt;
&lt;p&gt;第二个实践方向即是广为人知的基于RFID技术的物流网，该方向主张通过物品物件的标识，强化物流及物流信息的管理，同时通过信息整合，形成智能信息挖掘。&lt;/p&gt;
&lt;p&gt;第三个实践方向被称作数据“泛在聚合”意义上的物联网，认为互联网造就了庞大的数据海洋，应通过对其中每个数据进行属性的精确标识，全面实现数据的资源化，这既是互联网深入发展的必然要求，也是物联网的使命所在。&lt;/p&gt;
&lt;p&gt;比较而言，“智慧尘埃”意义上的物联网属于工业总线的泛化。这样的产业实践自从机电一体化和工业信息化以来，实际上在工业生产中从未停止过，只是那时不叫物联网而是叫工业总线。这种意义上的物联网将因传感技术、各类局域网通信技术的发展，依据其内在的科学技术规律，坚实而稳步地向前行进，并不会因为人为的一场运动而加快发展速度。&lt;/p&gt;
&lt;p&gt;RFID意义上的物联网，所依据的EPCglobal标准在推出时，即被定义为未来物联网的核心标准，但是该标准及其惟一的方法手段RFID电子标签所固有的局限性，使它难以真正指向物联网所提倡的智慧星球。原因在于，物和物之间的联系所能告知人们的信息是非常有限的，而物的状态与状态之间的联系，才能使人们真正挖掘事物之间普遍存在的各种联系，从而获取新的认知，获取新的智慧。&lt;/p&gt;
&lt;p&gt;“泛在聚合”即是要实现互联网所造就的无所不在的浩瀚数据海洋，实现彼此相识意义上的聚合。这些数据既代表物，也代表物的状态，甚至代表人工定义的各类概念。数据的“泛在聚合”，将能使人们极为方便的任意检索所需的各类数据，在各种数学分析模型的帮助下，不断挖掘这些数据所代表的事务之间普遍存在的复杂联系，从而实现人类对周边世界认知能力的革命性飞跃。&lt;/p&gt;

&lt;p&gt;数据分析是指用适当的统计分析方法对收集来的大量数据进行分析，提取有用信息和形成结论而对数据加以详细研究和概括总结的过程。这一过程也是质量管理体系的支持过程。在实用中，数据分析可帮助人们作出判断，以便采取适当行动。&lt;/p&gt;
&lt;p&gt;数据分析的数学基础在20世纪早期就已确立，但直到计算机的出现才使得实际操作成为可能，并使得数据分析得以推广。数据分析是数学与计算机科学相结合的产物。&lt;/p&gt;

&lt;p&gt;随着信息化与工业化的深度融合，信息技术渗透到了工业企业产业链的各个环节，条形码、二维码、RFID、工业传感器、工业自动控制系统、工业物联网、ERP、CAD/CAM/CAE/CAI等技术在工业企业中得到广泛应用，尤其是互联网、移动互联网、物联网等新一代信息技术在工业领域的应用，工业企业也进入了互联网工业的新的发展阶段，工业企业所拥有的数据也日益丰富。因此，工业大数据应用所面临的问题和挑战并不比互联网行业的大数据应用少，某些情况下甚至更为复杂。&lt;/p&gt;
&lt;p&gt;工业大数据应用将带来工业企业创新和变革的新时代。通过互联网、移动物联网等带来的低成本感知、高速移动连接、分布式计算和高级分析，信息技术和全球工业系统正在深入融合，给全球工业带来深刻的变革，创新企业的研发、生产、运营、营销和管理方式。这些创新不同行业的工业企业带来了更快的速度、更高的效率和更高的洞察力。&lt;/p&gt;
&lt;p&gt;现代化工业制造生产线安装有数以千计的小型传感器，来探测温度、压力、热能、振动和噪声。因为每隔几秒就收集一次数据，利用这些数据可以实现很多形式的分析，包括设备诊断、用电量分析、能耗分析、质量事故分析等。&lt;/p&gt;
&lt;p&gt;工业企业中生产线处于高速运转，由工业设备所产生、采集和处理的数据量远大于企业中计算机和人工产生的数据，从数据类型看也多是非结构化数据，生产线的高速运转则对数据的实时性要求也更高，大数据分析有以下七大应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.加速产品创新&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客户与工业企业之间的交互和交易行为将产生大量数据，挖掘和分析这些客户动态数据，能够帮助客户参与到产品的需求分析和产品设计等创新活动中，为产品创新作出贡献。福特公司是这方面的表率，他们将大数据技术应用到了福特福克斯电动车的产品创新和优化中，这款车成为了一款名副其实的“大数据电动车”。第一代福特福克斯电动车在驾驶和停车时产生大量数据。在行驶中，司机持续地更新车辆的加速度、刹车、电池充电和位置信息。这对于司机很有用，但数据也传回福特工程师那里，以了解客户的驾驶习惯，包括如何、何时以及何处充电。即使车辆处于静止状态，它也会持续将车辆胎压和电池系统的数据传送给最近的智能电话。&lt;/p&gt;
&lt;p&gt;这种以客户为中心的大数据应用场景具有多方面的好处，因为大数据实现了宝贵的新型产品创新和协作方式。司机获得有用的最新信息，而位于底特律的工程师汇总关于驾驶行为的信息，以了解客户，制订产品改进计划，并实施新产品创新。而且，电力公司和其他第三方供应商也可以分析数百万英里的驾驶数据，以决定在何处建立新的充电站，以及如何防止脆弱的电网超负荷运转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.快速产品故障诊断与精确预测&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这可以被用于产品售后服务与产品改进。无所不在的传感器、互联网技术的引入使得产品故障实时诊断变为现实，大数据应用、建模与仿真技术则使得预测动态性成为可能。在马航MH370失联客机搜寻过程中，波音公司获取的发动机运转数据对于确定飞机的失联路径起到了关键作用。我们就拿波音公司飞机系统作为案例，看看大数据应用在产品故障诊断中如何发挥作用。在波音的飞机上，发动机、燃油系统、液压和电力系统等数以百计的变量组成了在航状态，这些数据不到几微秒就被测量和发送一次。以波音737为例，发动机在飞行中每30分钟就能产生10TB数据。&lt;/p&gt;
&lt;p&gt;这些数据不仅仅是未来某个时间点能够分析的工程遥测数据，而且还促进了实时自适应控制、燃油使用、零件故障预测和飞行员通报，能有效实现故障诊断和预测。再看一个通用电气（GE）的例子，位于美国亚特兰大的GE能源监测和诊断（M&amp;amp;D）中心，收集全球50多个国家上千台GE燃气轮机的数据，每天就能为客户收集10G的数据，通过分析来自系统内的传感器振动和温度信号的恒定大数据流，这些大数据分析将为GE公司对燃气轮机故障诊断和预警提供支撑。风力涡轮机制造商Vestas也通过对天气数据及期涡轮仪表数据进行交叉分析，从而对风力涡轮机布局进行改善，由此增加了风力涡轮机的电力输出水平并延长了服务寿命。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.工业物联网生产线的大数据应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现代化工业制造生产线安装有数以千计的小型传感器，来探测温度、压力、热能、振动和噪声。因为每隔几秒就收集一次数据，利用这些数据可以实现很多形式的分析，包括设备诊断、用电量分析、能耗分析、质量事故分析（包括违反生产规定、零部件故障）等。首先，在生产工艺改进方面，在生产过程中使用这些大数据，就能分析整个生产流程，了解每个环节是如何执行的。一旦有某个流程偏离了标准工艺，就会产生一个报警信号，能更快速地发现错误或者瓶颈所在，也就能更容易解决问题。利用大数据技术，还可以对工业产品的生产过程建立虚拟模型，仿真并优化生产流程，当所有流程和绩效数据都能在系统中重建时，这种透明度将有助于制造商改进其生产流程。再如，在能耗分析方面，在设备生产过程中利用传感器集中监控所有的生产流程，能够发现能耗的异常或峰值情形，由此便可在生产过程中优化能源的消耗，对所有流程进行分析将会大大降低能耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.工业供应链的分析与优化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当前，大数据分析已经是很多电子商务企业提升供应链竞争力的重要手段。例如，电子商务企业京东商城，通过大数据提前分析和预测各地商品需求量，从而提高配送和仓储的效能，保证了次日货到的客户体验。RFID等产品电子标识技术、物联网技术以及移动互联网技术能帮助工业企业获得完整的产品供应链的大数据，利用这些数据进行分析，将带来仓储、配送、销售效率的大幅提升和成本的大幅下降。&lt;/p&gt;
&lt;p&gt;以海尔公司为例，海尔公司供应链体系很完善，它以市场链为纽带，以订单信息流为中心，带动物流和资金流的运动，整合全球供应链资源和全球用户资源。在海尔供应链的各个环节，客户数据、企业内部数据、供应商数据被汇总到供应链体系中，通过供应链上的大数据采集和分析，海尔公司能够持续进行供应链改进和优化，保证了海尔对客户的敏捷响应。美国较大的OEM供应商超过千家，为制造企业提供超过1万种不同的产品，每家厂商都依靠市场预测和其他不同的变量，如销售数据、市场信息、展会、新闻、竞争对手的数据，甚至天气预报等来销售自己的产品。&lt;/p&gt;
&lt;p&gt;利用销售数据、产品的传感器数据和出自供应商数据库的数据，工业制造企业便可准确地预测全球不同区域的需求。由于可以跟踪库存和销售价格，可以在价格下跌时买进，所以制造企业便可节约大量的成本。如果再利用产品中传感器所产生的数据，知道产品出了什么故障，哪里需要配件，他们还可以预测何处以及何时需要零件。这将会极大地减少库存，优化供应链。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.产品销售预测与需求管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过大数据来分析当前需求变化和组合形式。大数据是一个很好的销售分析工具，通过历史数据的多维度组合，可以看出区域性需求占比和变化、产品品类的市场受欢迎程度以及最常见的组合形式、消费者的层次等，以此来调整产品策略和铺货策略。在某些分析中我们可以发现，在开学季高校较多的城市对文具的需求会高很多，这样我们可以加大对这些城市经销商的促销，吸引他们在开学季多订货，同时在开学季之前一两个月开始产能规划，以满足促销需求。对产品开发方面，通过消费人群的关注点进行产品功能、性能的调整，如几年前大家喜欢用音乐手机，而现在大家更倾向于用手机上网、拍照分享等，手机的拍照功能提升就是一个趋势，4G手机也占据更大的市场份额。通过大数据对一些市场细节的分析，可以找到更多的潜在销售机会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.产品计划与排程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;制造业面对多品种小批量的生产模式，数据的精细化自动及时方便的采集（MES/DCS）及多变性导致数据剧烈增大，再加上十几年的信息化的历史数据，对于需要快速响应的APS来说，是一个巨大的挑战。大数据可以给予我们更详细的数据信息，发现历史预测与实际的偏差概率，考虑产能约束、人员技能约束、物料可用约束、工装模具约束，通过智能的优化算法，制定预计划排产，并监控计划与现场实际的偏差，动态的调整计划排产。帮我们规避“画像”的缺陷，直接将群体特征直接强加给个体（工作中心数据直接改变为具体一个设备、人员、模具等数据）。通过数据的关联分析并监控它，我们就能计划未来。虽然，大数据略有瑕疵，只要得到合理的应用，大数据会变成我们强大的武器。当年，福特问大数据的客户需求是什么？而回答是“一匹更快的马”，而不是现在已经普及的汽车。所以，在大数据的世界里，创意、直觉、冒险精神和知识野心尤为重要。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7.产品质量管理与分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传统的制造业正面临着大数据的冲击，在产品研发、工艺设计、质量管理、生产运营等各方面都迫切期待着有创新方法的诞生，来应对工业背景下的大数据挑战。例如在半导体行业，芯片在生产过程中会经历许多次掺杂、增层、光刻和热处理等复杂的工艺制程，每一步都必须达到极其苛刻的物理特性要求，高度自动化的设备在加工产品的同时，也同步生成了庞大的检测结果。这些海量数据究竟是企业的包袱，还是企业的金矿呢？如果说是后者的话，那么又该如何快速地拨云见日，从“金矿”中准确地发现产品良率波动的关键原因呢？这是一个已经困扰半导体工程师们多年的技术难题。&lt;/p&gt;
&lt;p&gt;某半导体科技公司生产的晶圆在经过测试环节后，每天都会产生包含一百多个测试项目、长度达几百万行测试记录的数据集。按照质量管理的基本要求，一个必不可少的工作就是需要针对这些技术规格要求各异的一百多个测试项目分别进行一次过程能力分析。如果按照传统的工作模式，我们需要按部就班地分别计算一百多个过程能力指数，对各项质量特性一一考核。这里暂且不论工作量的庞大与繁琐，哪怕有人能够解决了计算量的问题，但也很难从这一百多个过程能力指数中看出它们之间的关联性，更难对产品的总体质量性能有一个全面的认识与总结。然而，如果我们利用大数据质量管理分析平台，除了可以快速地得到一个长长的传统单一指标的过程能力分析报表之外，更重要的是，还可以从同样的大数据集中得到很多崭新的分析结果&lt;/p&gt;
</description>
<pubDate>Tue, 11 Dec 2018 23:18:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>前记：这是我老婆写的一篇文章，结合了她当前的分析工作和物联网，介绍了物联网环境下数据分析的应用。 物联网概论及国内外研究现状 “物联网概念”是在“互联网概念”的基础上，将其用户端延伸和扩展到任何物品与</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/5530633.html</dc:identifier>
</item>
<item>
<title>消息队列中间件（三）Kafka 入门指南 - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/10106043.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/10106043.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1202902/201812/1202902-20181212001644988-776141680.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;kafka-来源&quot;&gt;Kafka 来源&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Kafka&lt;/code&gt;的前身是由&lt;code&gt;LinkedIn&lt;/code&gt;开源的一款产品，2011年初开始开源，加入了 Apache 基金会，2012年从 Apache Incubator 毕业变成了 Apache 顶级开源项目。同时LinkedIn还有许多著名的开源产品。如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分布式数据同步系统&lt;code&gt;Databus&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;高性能计算引擎&lt;code&gt;Cubert&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Java异步处理框架&lt;code&gt;ParSeq&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Kafka&lt;/code&gt;流处理平台&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;kafka-介绍&quot;&gt;Kafka 介绍&lt;/h2&gt;
&lt;p&gt;Kafka 用于构建实时数据管道和流应用程序。它具有水平可扩展性，容错性，快速性，并在数千家公司的生产环境中运行。&lt;/p&gt;
&lt;p&gt;从官方我们可以知道&lt;code&gt;ApacheKafka&lt;/code&gt;是&lt;em&gt;一个分布式流媒体平台&lt;/em&gt;。这到底是什么意思呢？&lt;/p&gt;
&lt;p&gt;流媒体平台有三个关键功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发布和订阅记录数据流，类似于消息队列或企业消息传递系统。&lt;/li&gt;
&lt;li&gt;有容错能力的可以持久化的存储数据流。&lt;/li&gt;
&lt;li&gt;记录发生时可以进行流处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Kafka 通常用于两大类应用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构建可在系统或应用程序之间可靠获取数据的实时流数据管道&lt;/li&gt;
&lt;li&gt;构建转换或响应数据流的实时流处理&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;kafka-基本概念&quot;&gt;Kafka 基本概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Producer&lt;/strong&gt; - 消息和数据的生产者，向 Kafka 的一个 Topic 发布消息的进程/代码/服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumer&lt;/strong&gt; - 消息和数据的消费者，订阅数据（Topic）并且处理其发布的消息的进程/代码/服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Consumer Group&lt;/strong&gt; - 逻辑概念，对于同一个 Topic，会广播不同的 Group，一个Group中，只有一个consumer 可以消费该消息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Broker&lt;/strong&gt; - 物理概念，Kafka 集群中的每个 Kafka 节点。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Topic&lt;/strong&gt; - 逻辑概念，Kafka消息的类别，对数据进行区分，隔离。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Partition&lt;/strong&gt; - 物理概念，分片，Kafka 下数据存储的基本单元，一个 Topic 数据，会被分散存储到多个Partition，每一个Partition是有序的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replication&lt;/strong&gt; - 副本，同一个 Partition 可能会有多个 Replica ，多个 Replica 之间数据是一样的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Replication Leader&lt;/strong&gt; - 一个 Partition 的多个 Replica 上，需要一个 Leade r负责该 Partition 上与 Produce 和 Consumer 交互&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ReplicaManager&lt;/strong&gt; - 负责管理当前的 broker 所有分区和副本的信息，处理 KafkaController 发起的一些请求，副本状态的切换，添加/读取消息等。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;概念的延伸&quot;&gt;概念的延伸&lt;/h3&gt;
&lt;p&gt;Partition&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每一个Topic被切分为多个Partitions&lt;/li&gt;
&lt;li&gt;消费者数据要小于等于Partition的数量&lt;/li&gt;
&lt;li&gt;Broker Group中的每一个Broker保存Topic的一个或多个Partitions&lt;/li&gt;
&lt;li&gt;Consumer Group中的仅有一个Consumer读取Topic的一个或多个Partions，并且是唯一的Consumer。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Replication&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当集群中有Broker挂掉的时候，系统可以主动的使用Replicas提供服务。&lt;/li&gt;
&lt;li&gt;系统默认设置每一个Topic的Replication的系数为1，可以在创建Topic的时候单独设置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Replication特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Replication的基本单位是Topic的Partition。&lt;/li&gt;
&lt;li&gt;所有的读和写都从Leader进，Followers只是作为备份。&lt;/li&gt;
&lt;li&gt;Follower必须能够及时的复制Leader的数据&lt;/li&gt;
&lt;li&gt;增加容错性与可扩展性。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;kafka-消息结构&quot;&gt;Kafka 消息结构&lt;/h2&gt;
&lt;p&gt;在 Kafka2.0 中的消息结构如下（整理自官网）。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;baseOffset: int64 - 用于记录Kafka这个消息所处的偏移位置&lt;br/&gt;batchLength: int32 - 用于记录整个消息的长度&lt;br/&gt;partitionLeaderEpoch: int32&lt;br/&gt;magic: int8 (current magic value is 2) - 一个固定值，用于快速判断是否是Kafka消息&lt;br/&gt;crc: int32 - 用于校验信息的完整性&lt;br/&gt;attributes: int16 - 当前消息的一些属性&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;bit 0~2:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;0: no compression&lt;br/&gt;1: gzip&lt;br/&gt;2: snappy&lt;br/&gt;3: lz4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;bit 3: timestampType&lt;br/&gt;​ bit 4: isTransactional (0 means not transactional)&lt;br/&gt;​ bit 5: isControlBatch (0 means not a control batch)&lt;br/&gt;​ bit 6~15: unused&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;lastOffsetDelta: int32&lt;br/&gt;firstTimestamp : int64&lt;br/&gt;maxTimestamp: int64&lt;br/&gt;producerId: int64&lt;br/&gt;producerEpoch: int16&lt;br/&gt;baseSequence: int32&lt;br/&gt;records:&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;length: varint&lt;br/&gt;attributes: int8&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;bit 0~7: unused&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;timestampDelta: varint&lt;br/&gt;offsetDelta: varint&lt;br/&gt;keyLength: varint&lt;br/&gt;key: byte[]&lt;br/&gt;valueLen: varint&lt;br/&gt;value: byte[]&lt;br/&gt;Headers =&amp;gt; [Header]&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;headerKeyLength: varint&lt;br/&gt;headerKey: String&lt;br/&gt;headerValueLength: varint&lt;br/&gt;Value: byte[]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于消息结构的一些释义。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Offset -用于记录Kafka这个消息所处的偏移位置&lt;/li&gt;
&lt;li&gt;Length - 用于记录整个消息的长度&lt;/li&gt;
&lt;li&gt;CRC32 - 用于校验信息的完整性&lt;/li&gt;
&lt;li&gt;Magic - 一个固定值，用于快速判断是否是Kafka消息&lt;/li&gt;
&lt;li&gt;Attributes - 当前消息的一些属性&lt;/li&gt;
&lt;li&gt;Timestamp - 消息的时间戳&lt;/li&gt;
&lt;li&gt;Key Length - key的长度&lt;/li&gt;
&lt;li&gt;Key - Key的具体值&lt;/li&gt;
&lt;li&gt;Value Length - 值的长度&lt;/li&gt;
&lt;li&gt;Value - 具体的消息值&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;kafka-优点&quot;&gt;Kafka 优点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;分布式 - Kafka是分布式的，多分区，多副本的和多订阅者的，基于Zookeeper调度。&lt;/li&gt;
&lt;li&gt;持久性和扩展性 - Kafka使用分布式提交日志，这意味着消息会尽可能快地保留在磁盘上，因此它是持久的。同时具有一定的容错性，Kafka支持在线的水平扩展，消息的自平衡。&lt;/li&gt;
&lt;li&gt;高性能 - Kafka对于发布和订阅消息都具有高吞吐量。 即使存储了许多TB的消息，它也保持稳定的性能。且延迟低，适用高并发。时间复杂的为o(1)。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;kafka-应用&quot;&gt;Kafka 应用&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;用于聚合分布式应用程序中的消息。进行操作监控。&lt;/li&gt;
&lt;li&gt;用于跨组织的从多个服务收集日志，然后提供给多个服务器，解决日志聚合问题。&lt;/li&gt;
&lt;li&gt;用于流处理，如Storm和Spark Streaming，从kafka中读取数据，然后处理在写入kafka供应用使用。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;kafka-安装&quot;&gt;Kafka 安装&lt;/h2&gt;
&lt;h3 id=&quot;安装-jdk&quot;&gt;安装 Jdk&lt;/h3&gt;
&lt;p&gt;具体步骤此处不说。&lt;/p&gt;
&lt;h3 id=&quot;安装-kafka&quot;&gt;安装 Kafka&lt;/h3&gt;
&lt;p&gt;直接&lt;a href=&quot;http://kafka.apache.org/downloads&quot;&gt;官方网站&lt;/a&gt;下载对应系统的版本解压即可。&lt;br/&gt;由于Kafka对于windows和Unix平台的控制脚本是不同的，因此如果是windows平台，要使用&lt;code&gt;bin\windows\&lt;/code&gt;而不是&lt;code&gt;bin/&lt;/code&gt;，并将脚本扩展名更改为&lt;code&gt;.bat&lt;/code&gt;。以下命令是基于Unix平台的使用。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;# 解压
tar -xzf kafka_2.11-2.0.0.tgz
# 启动Zookeeper
bin/zookeeper-server-start.sh config/zookeeper.properties
# 启动Kafka
bin/kafka-server-start.sh config/server.properties
# 或者后台启动
bin/kafka-server-start.sh config/server.properties &amp;amp;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们创建一个名为“test”的主题，它只包含一个分区，只有一个副本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`&amp;gt; bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们运行list topic命令，我们现在可以看到该主题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;`&amp;gt; bin/kafka-topics.sh --list --zookeeper localhost:2181 test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，您也可以将代理配置为在发布不存在的主题时自动创建主题，而不是手动创建主题。&lt;/p&gt;
&lt;p&gt;查看Topic的信息&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./kafka-topics.sh --describe --zookeeper localhost:2181 --topic Hello-Kafka&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行生产者，然后在控制台中键入一些消息以发送到服务器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test 
This is a message
This is another message`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行消费者，查看收到的消息&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;&amp;gt; bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning
&amp;gt; This is a message
&amp;gt; This is another message&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;kafka-工程实例&quot;&gt;Kafka 工程实例&lt;/h2&gt;
&lt;h3 id=&quot;pom-依赖&quot;&gt;POM 依赖&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.kafka&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;kafka-clients&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生产者&quot;&gt;生产者&lt;/h3&gt;
&lt;p&gt;编写生产者 Java 代码。关于 Properties 中的值的意思描述可以在官方文档中找到 &lt;a href=&quot;http://kafka.apache.org/documentation.html#producerconfigs&quot;&gt;http://kafka.apache.org/&lt;/a&gt; 。下面的生产者向 Kafka 推送了10条消息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.apache.kafka.clients.producer.KafkaProducer;
import org.apache.kafka.clients.producer.Producer;
import org.apache.kafka.clients.producer.ProducerRecord;
import java.util.Properties;

/**
 * &amp;lt;p&amp;gt;
 * Kafka生产者,发送10个数据
 *
 * @Author niujinpeng
 * @Date 2018/11/16 15:45
 */
public class MyProducer {

    public static void main(String[] args) {
        Properties props = new Properties();
        props.put(&quot;bootstrap.servers&quot;, &quot;192.168.110.132:9092&quot;);
        props.put(&quot;acks&quot;, &quot;all&quot;);
        props.put(&quot;retries&quot;, 0);
        props.put(&quot;batch.size&quot;, 16384);
        props.put(&quot;linger.ms&quot;, 1);
        props.put(&quot;buffer.memory&quot;, 33554432);
        props.put(&quot;key.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);
        props.put(&quot;value.serializer&quot;, &quot;org.apache.kafka.common.serialization.StringSerializer&quot;);

        Producer&amp;lt;String, String&amp;gt; producer = new KafkaProducer&amp;lt;&amp;gt;(props);
        for (int i = 0; i &amp;lt; 10; i++) {
            producer.send(new ProducerRecord&amp;lt;String, String&amp;gt;(&quot;test&quot;, Integer.toString(i), Integer.toString(i)));
        }
        producer.close();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;消费者&quot;&gt;消费者&lt;/h3&gt;
&lt;p&gt;编写消费者 Java 代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;

import java.util.Arrays;
import java.util.Properties;

/**
 * &amp;lt;p&amp;gt;
 * Kafka消费者
 *
 * @Author niujinpeng
 * @Date 2018/11/19 15:01
 */
public class MyConsumer {

    public static void main(String[] args) {

        Properties props = new Properties();
        props.put(&quot;bootstrap.servers&quot;, &quot;192.168.110.132:9092&quot;);
        props.put(&quot;group.id&quot;, &quot;test&quot;);
        props.put(&quot;enable.auto.commit&quot;, &quot;true&quot;);
        props.put(&quot;auto.commit.interval.ms&quot;, &quot;1000&quot;);
        props.put(&quot;key.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
        props.put(&quot;value.deserializer&quot;, &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);
        KafkaConsumer&amp;lt;String, String&amp;gt; consumer = new KafkaConsumer&amp;lt;&amp;gt;(props);
        consumer.subscribe(Arrays.asList(&quot;test&quot;));
        while (true) {
            ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(100);
            for (ConsumerRecord&amp;lt;String, String&amp;gt; record : records) {
                System.out.printf(&quot;offset = %d, key = %s, value = %s%n&quot;, record.offset(), record.key(), record.value());
            }
        }
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以在控制台看到成功运行后的输出，由 offset 可以看到已经消费了10条消息。&lt;/p&gt;
&lt;pre class=&quot;log&quot;&gt;
&lt;code&gt; INFO | Kafka version : 2.0.0
 INFO | Kafka commitId : 3402a8361b734732
 INFO | Cluster ID: 0Xrk5M1CSJet0m1ut3zbiw
 INFO | [Consumer clientId=consumer-1, groupId=test] Discovered group coordinator 192.168.110.132:9092 (id: 2147483647 rack: null)
 INFO | [Consumer clientId=consumer-1, groupId=test] Revoking previously assigned partitions []
 INFO | [Consumer clientId=consumer-1, groupId=test] (Re-)joining group
 INFO | [Consumer clientId=consumer-1, groupId=test] Successfully joined group with generation 4
 INFO | [Consumer clientId=consumer-1, groupId=test] Setting newly assigned partitions [test-0]
offset = 38, key = 0, value = 0
offset = 39, key = 1, value = 1
offset = 40, key = 2, value = 2
offset = 41, key = 3, value = 3
offset = 42, key = 4, value = 4
offset = 43, key = 5, value = 5
offset = 44, key = 6, value = 6
offset = 45, key = 7, value = 7
offset = 46, key = 8, value = 8
offset = 47, key = 9, value = 9&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;如果&lt;code&gt;java.net.InetAddress.getCanonicalHostName&lt;/code&gt; 取到的是主机名。需要修改 Kafka 的配置文件。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;vim server.properties
# x.x.x.x是服务器IP
advertised.listeners=PLAINTEXT://x.x.x.x:9092&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&amp;lt;完&amp;gt;&lt;br/&gt;本文原发于个人博客：&lt;a href=&quot;https://www.codingme.net/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net&lt;/a&gt; 转载请注明出处&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-e1b06fdf782b78e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Dec 2018 16:26:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>Kafka 来源 的前身是由 开源的一款产品，2011年初开始开源，加入了 Apache 基金会，2012年从 Apache Incubator 毕业变成了 Apache 顶级开源项目。同时Linke</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/10106043.html</dc:identifier>
</item>
<item>
<title>产品经理历险记-1-记录一次事故 - Lionel Andrés Messi</title>
<link>http://www.cnblogs.com/LionelMessi/p/10106210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LionelMessi/p/10106210.html</guid>
<description>&lt;p&gt;距离上一次发博客已近10个月了&lt;/p&gt;
&lt;p&gt;在转型产品的路上也探索了半年了&lt;/p&gt;
&lt;p&gt;精彩纷呈，千姿百媚，层出不穷，再也没有其他形容词能记录这半年来的心路历程了 &lt;/p&gt;
&lt;p&gt;今晚，线上环境出现了第一次的不可逆的大规模的数据型错误，记录下来，以警后世&lt;/p&gt;
&lt;p&gt;这是个很长的 Story，简单的说&lt;/p&gt;
&lt;p&gt;现在有个业务系统，主流程如下：&lt;/p&gt;
&lt;p&gt;前方市场业务团队提交 Work Request，后方业务团队接收到 Work Request后，将其拆分为不同的子任务Task，并交付给不同的人员完成，所有的子Task完成后，Work Request则完成。&lt;/p&gt;
&lt;p&gt;现在有个详细逻辑如下，业务部门要求，Work Request 完成后，在第 N 天，Work Request需要被归档，所有Work Request所属文件需要被删除，非指定人员不可查看。&lt;/p&gt;
&lt;p&gt;收到此需求后，我同业务部门进行了详细的需求分析，明确了Work Request完成后的定义，即 Work Request 的所有子Task被完成的时候为Work Request 被完成，同时，最后一个Task完成的时间为此Work Request的完成时间。&lt;/p&gt;
&lt;p&gt;将此需求转给开发人员，开发人员进行了开发。具体的操作是，有一张流水表，用于记录 Work Request的状态变化，从创建，到被操作，等等，最后一条流水是 完成状态流水。此由于需要判断是否是最后一个Task完成才进行记录。故稍微有一点点的逻辑在里面。&lt;/p&gt;
&lt;p&gt;判断N天后需要被设置为归档状态根据流水表中被完成的流水进行判断Work Request 完成时间进而进行推断是否要删除文件操作。&lt;/p&gt;
&lt;p&gt;整个功能由2个开发人员完成，A 同事负责进行Work Request 流水记录，B同事负责N天后的数据处理，经过一个测试人员C测试于11月份上线&lt;/p&gt;
&lt;p&gt;今晚在进行数据检查时发现。无一个WR被正常删除文件操作，马上进行了紧急的问题排查。&lt;/p&gt;
&lt;p&gt;经过一系列排查，我们发现，A同事在Work Request 流水记录的时候，把应该将 Work Request ID记录在流水表中错误的写入了Task ID。导致整个数据混乱。&lt;/p&gt;
&lt;p&gt;询问了一圈，&lt;/p&gt;
&lt;p&gt;A同事表示自己已经在一周前就意识到此bug的存着并寄希望于本次功能上线可以修复数据&lt;/p&gt;
&lt;p&gt;B同事表示自己在开发测试的时候使用的是修改数据库数据，自己造假数据进行开发测试&lt;/p&gt;
&lt;p&gt;C同事表示自己在测试阶段仅通过修改数据库数据进行了测试&lt;/p&gt;
&lt;p&gt;以上是整个Story并且简单的说无力吐槽。&lt;/p&gt;
&lt;p&gt;反思此次重大事故。&lt;/p&gt;
&lt;p&gt;首先是作为此次系统需求负责人，作为此功能，此系统的产品，未对完成的功能进行严格的验收，也只是通过测试人员的反馈以及UAT人员的反馈进行判断应该无问题并且同意了上线，此属于不负责任的表现&lt;/p&gt;
&lt;p&gt;其次是A同事，我们检查了代码，其代码从最初写的时候即存着错误，未正确的获取Work Request ID,而是使用Task ID，这是最基本的需求要求都未达到，再发现此问题后，未及时上报进行紧急修复，任由事态发展，期间其反馈说有和Tech Leader反映此情况，暂无法查证是否属实&lt;/p&gt;
&lt;p&gt;再次是B同事，B同事在开发阶段造数据无问题，没毛病，但在联调阶段依旧通过造数据进行检查判断，此属于不严谨，不负责的表现&lt;/p&gt;
&lt;p&gt;最后是C同事，C同事作为测试工程师，未进行测试用例记录，未进行最基本的正向流程模拟，通过修改数据库进行测试，同时回顾的时候，我们发现即使通过修改数据库也能发现问题，只有在非常粗心大意并且欠缺思考的情况修改数据才能忽略A同事犯的错误。但偏偏也被忽略。作为研发部门的最后一道防线，此属于不严谨，不负责的表现&lt;/p&gt;
&lt;p&gt;综上，整个事件过程中，一共有4次机会我们可以去发现并阻止此次事故的发生，但一次机会我们都没有把握住。有严重的失职，有严重的不严谨，有严重的不负责，作为产品，很自责，同时也在不停的提醒自己，以后不允许这样的事件出现。同时也提醒同事，做事要有责任心。&lt;/p&gt;
&lt;p&gt;最近心力憔悴，每天人肉运维，外有业务部门强敌，内有攻城狮困局。&lt;/p&gt;
&lt;p&gt;产品这条路，回首看到的都是带血的脚印&lt;/p&gt;

</description>
<pubDate>Tue, 11 Dec 2018 16:24:00 +0000</pubDate>
<dc:creator>Lionel Andr&amp;#233;s Messi</dc:creator>
<og:description>距离上一次发博客已近10个月了 在转型产品的路上也探索了半年了 精彩纷呈，千姿百媚，层出不穷，再也没有其他形容词能记录这半年来的心路历程了 今晚，线上环境出现了第一次的不可逆的大规模的数据型错误，记录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LionelMessi/p/10106210.html</dc:identifier>
</item>
<item>
<title>经典排序之归并排序详解 - 辰砂tj</title>
<link>http://www.cnblogs.com/tojian/p/10106152.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tojian/p/10106152.html</guid>
<description>&lt;p&gt;这里归并的含义将两个或两个以上的有序表组合成一个新有序表，本文讲述二路归并排序。&lt;/p&gt;

&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;初始序列看成n个有序子序列，每个子序列长度为1&lt;/li&gt;
&lt;li&gt;两两合并，得到（n/2向下取整数）个长度为2或1的有序子序列&lt;/li&gt;
&lt;li&gt;再两两合并，重复直至得到一个长度为n的有序序列为止&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;二路归并排序主旨是“分解”与“归并”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分解：&lt;/strong&gt;　　&lt;/p&gt;
&lt;p&gt;　1.将一个数组分成两个数组，分别对两个数组进行排序。&lt;/p&gt;
&lt;p&gt;　2.循环第一步，直到划分出来的“小数组”只包含一个元素，只有一个元素的数组默认为已经排好序。&lt;br/&gt;　&lt;br/&gt;&lt;strong&gt;归并：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　1.将两个有序的数组合并到一个大的数组中。&lt;/p&gt;
&lt;p&gt;　2.从最小的只包含一个元素的数组开始两两合并。此时，合并好的数组也是有序的。&lt;br/&gt;　&lt;/p&gt;
&lt;h2 id=&quot;将两个顺序表合并成一个有序表&quot;&gt;1.将两个顺序表合并成一个有序表&lt;/h2&gt;
&lt;p&gt;首先我们来看看两个顺序表是如何变成一个有序表的，实际上做法就是将两个指针指向两个数组，然后进行比较，看那个指针指向的数据小，将小的数据插入新的数组里，然后将这个指针加1.如图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201812/1513801-20181211235853883-1001958588.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int [] mergeSort(int a[] , int b[],){
    int c[a.length + b.length] ;
    int i = 0; 
    int j = 0;
    int k = 0;
    while (i &amp;lt; a.length &amp;amp;&amp;amp; j &amp;lt; b.length){
       if ( a[i] &amp;lt; b [j]){
          c[k ++] = a[i];
          i ++;
       }else{
 
         c[k ++] = b[j];
         j++;
       }  
   }
   while ( i &amp;lt; a.length ){
        c[k] = a [i];
        i ++;
        k ++;
   }
   while ( j &amp;lt;b .length ){
       c[k] = a [j];
       j ++;
       k ++;
   }
 return c;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;过程&quot;&gt;2.过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1513801/201812/1513801-20181211235938923-1110210655.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;可以看出这个过程，每次两两进行比较的时候，都可以表示是两个有序的数组，变成一个有序数组的过程。经过数次的变化，就好变成排序状态的数组。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三.算法分析&quot;&gt;三.算法分析&lt;/h2&gt;
&lt;p&gt;时间效率：$O(nlog_2n) $&lt;br/&gt;空间效率：&lt;span class=&quot;math inline&quot;&gt;\(O（n）\)&lt;/span&gt;&lt;br/&gt;稳 定 性：稳定&lt;/p&gt;
&lt;h2 id=&quot;四.完整代码&quot;&gt;四.完整代码&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MergeSort {

    public static int[] sort(int[] nums, int low, int high) {
        int mid = (low + high) / 2;
        if (low &amp;lt; high) {
            // 左边
            sort(nums, low, mid);
            // 右边
            sort(nums, mid + 1, high);
            // 左右归并
            merge(nums, low, mid, high);

        }
        return nums;
    }

    public static void merge(int[] nums, int low, int mid, int high) {
        int[] temp = new int[high - low + 1];
        int i = low;// 左指针
        int j = mid + 1;// 右指针
        int k = 0;

        // 把较小的数先移到新数组中
        while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= high) {
            if (nums[i] &amp;lt; nums[j]) {
                temp[k++] = nums[i++];

            } else {
                temp[k++] = nums[j++];

            }

        }
        // 把左边剩余的数移入数组
        while (i &amp;lt;= mid) {
            temp[k++] = nums[i++];

        }

        // 把右边边剩余的数移入数组
        while (j &amp;lt;= high) {
            temp[k++] = nums[j++];

        }

        // 把新数组中的数覆盖nums数组
        for (int k2 = 0; k2 &amp;lt; temp.length; k2++) {
            nums[k2 + low] = temp[k2];

        }

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;参考 ：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/horizonice/p/4102553.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/horizonice/p/4102553.html&lt;/a&gt;&lt;br/&gt;《数据结构》 严蔚敏&lt;br/&gt;《算法导论》2.1章节&lt;/p&gt;
</description>
<pubDate>Tue, 11 Dec 2018 16:01:00 +0000</pubDate>
<dc:creator>辰砂tj</dc:creator>
<og:description>归并排序 一.概述 这里归并的含义将两个或两个以上的有序表组合成一个新有序表，本文讲述二路归并排序。 二、排序过程 1. 初始序列看成n个有序子序列，每个子序列长度为1 2. 两两合并，得到（n/2向</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tojian/p/10106152.html</dc:identifier>
</item>
<item>
<title>策略设计模式 - user-chen</title>
<link>http://www.cnblogs.com/czsy/p/10106116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/czsy/p/10106116.html</guid>
<description>&lt;p&gt;策略设计模式定义：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法，称为策略设计模式。策略就是传递进去的参数对象，它包含要执行的代码。&lt;/p&gt;
&lt;p&gt;策略模式应用场景：&lt;/p&gt;
&lt;p&gt;1.如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。&lt;/p&gt;
&lt;p&gt;2.一个系统需要动态地在几种算法中选择一种。&lt;/p&gt;
&lt;p&gt;3.如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现（即使用 if...else）。&lt;/p&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;p&gt;我们首先创建一个定义活动的 &lt;em&gt;Strategy&lt;/em&gt; 接口和实现了 &lt;em&gt;Strategy&lt;/em&gt; 接口的实体策略类，&lt;em&gt;Context&lt;/em&gt; 是一个使用了某种策略的类。&lt;em&gt;Main&lt;/em&gt;，我们的演示类使用 &lt;em&gt;Context&lt;/em&gt; 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。&lt;/p&gt;
&lt;p&gt;UML类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370980/201812/1370980-20181211234151343-1640182880.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;步骤1：创建定义活动的 &lt;em&gt;Strategy&lt;/em&gt; 接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Strategy {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; algorithm (&lt;span&gt;double&lt;/span&gt; numberA,&lt;span&gt;double&lt;/span&gt;&lt;span&gt; numberB);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤2：创建实现了 &lt;em&gt;Strategy&lt;/em&gt; 接口的实体策略类&lt;/p&gt;
&lt;p&gt;algorithmForAdd.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class algorithmForAdd implements Strategy {
        @Override
        public double algorithm(double numberA,double numberB) {
                return numberA+numberB;
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; algorithmForMultiply.java&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class algorithmForMultiply implements Strategy {

        @Override
        public double algorithm(double numberA, double numberB) {
                return numberA * numberB;
        }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;algorithmForSubtract.java&lt;/p&gt;
&lt;p&gt;步骤3：&lt;/p&gt;
&lt;p&gt;创建 &lt;em&gt;Context&lt;/em&gt; 类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class context {
        private Strategy strategy;
        public context(Strategy strategy) {
                this.strategy = strategy;
        }
        public double Contextinterface(double numberA, double numberB) {
                return strategy.algorithm(numberA, numberB);
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;步骤4：&lt;/p&gt;
&lt;p&gt;创建Main类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class Main {

        public static void main(String[] args) {
                System.out.println(&quot;10+20 = &quot;+new context(new algorithmForAdd()).Contextinterface(10, 20));
                System.out.println(&quot;10-20 = &quot;+new context(new algorithmForSubtract()).Contextinterface(10, 20));
                System.out.println(&quot;10*20 = &quot;+new context(new algorithmForMultiply()).Contextinterface(10, 20));
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370980/201812/1370980-20181211235047736-1412648810.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 11 Dec 2018 15:52:00 +0000</pubDate>
<dc:creator>user-chen</dc:creator>
<og:description>策略设计模式定义：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法，称为策略设计模式。策略就是传递进去的参数对象，它包含要执行的代码。 策略模式应用场景： 1.如果在一个系统里面有许多类，它</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/czsy/p/10106116.html</dc:identifier>
</item>
<item>
<title>二分查找 - Tom-shushu</title>
<link>http://www.cnblogs.com/Tom-shushu/p/10067736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Tom-shushu/p/10067736.html</guid>
<description>&lt;div id=&quot;content_views&quot; class=&quot;markdown_views prism-atom-one-dark&quot; readability=&quot;44&quot;&gt;
&lt;p&gt;是将n个元素分成大致相等的两部分，取arr[n/2]与target做比较，如果target=arr[n/2],则找到target,算法中止;如果target&amp;lt;arr[n/2],则只要在数组arr的左半部分继续搜索target,如果target&amp;gt;arr[n/2],则只要在数组arr的右半部搜索target.&lt;br/&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;br/&gt;查找速度快&lt;br/&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;br/&gt;待查表为有序表&lt;br/&gt;&lt;strong&gt;代码实现：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;二分查找法查找有序数组arr中的target元素
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果找到target元素，返回相应的索引index&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; template&amp;lt;typename T&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; binarySearch(T arr[],&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n ,T target){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;arr[l......r]&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; l = &lt;span&gt;0&lt;/span&gt; ,r = n-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;( l &amp;lt;=&lt;span&gt; r ){
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;int mid = (l+r)/2;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; mid = l+(r-l)/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (arr[mid] ==&lt;span&gt; target)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; mid;            
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(target &amp;lt;&lt;span&gt; arr[mid])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             r = mid - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             l = mid +&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;} 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Tue, 11 Dec 2018 15:42:00 +0000</pubDate>
<dc:creator>Tom-shushu</dc:creator>
<og:description>二分查找的基本思想: 是将n个元素分成大致相等的两部分，取arr[n/2]与target做比较，如果target=arr[n/2],则找到target,算法中止;如果target&lt;arr[n/2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Tom-shushu/p/10067736.html</dc:identifier>
</item>
<item>
<title>How to Make a Computer Operating System - AntzUhl</title>
<link>http://www.cnblogs.com/LexMoon/p/How_to_Make_a_Computer_Operating_System.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LexMoon/p/How_to_Make_a_Computer_Operating_System.html</guid>
<description>&lt;p&gt;How to Make a Computer Operating System&lt;/p&gt;
&lt;p&gt;如何制作一个操作系统(翻译版)&lt;/p&gt;
&lt;p&gt;原文地址:&lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System&quot;&gt;Github:How to Make a Computer Operating System&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;翻译地址:&lt;a href=&quot;https://github.com/CasterWx/How-to-Make-a-Computer-Operating-System-ZH-CN&quot;&gt;Github:How to Make a Computer Operating System-ZH-cn&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;hr/&gt;
&lt;p&gt;Online book about how to write a computer operating system in C/C++ from scratch.&lt;/p&gt;
&lt;p&gt;一本关于如何用C/ c++从零开始编写计算机操作系统的在线书籍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Caution&lt;/strong&gt;: This repository is a remake of my old course. It was written several years ago &lt;a href=&quot;https://github.com/SamyPesse/devos&quot;&gt;as one of my first projects when I was in High School&lt;/a&gt;, I'm still refactoring some parts. The original course was in French and I'm not an English native. I'm going to continue and improve this course in my free-time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谨慎&lt;/strong&gt;:这个资源库是我以前课程的翻版。它是几年前写的&lt;a href=&quot;https://github.com/SamyPesse/devos&quot;&gt;作为我高中时的第一个项目之一&lt;/a&gt;，我仍然在重构一些部分。这个课程最初的是用法语，我的母语不是英语。我打算在空闲时间继续改进这门课。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Book&lt;/strong&gt;: An online version is available at &lt;a href=&quot;http://samypesse.gitbooks.io/how-to-create-an-operating-system/&quot; class=&quot;uri&quot;&gt;http://samypesse.gitbooks.io/how-to-create-an-operating-system/&lt;/a&gt; (PDF, Mobi and ePub). It was generated using &lt;a href=&quot;https://www.gitbook.com/&quot;&gt;GitBook&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书籍&lt;/strong&gt;: 网上版本可于&lt;a href=&quot;http://samypesse.gitbooks.io/howtocreateanoperating-system/&quot; class=&quot;uri&quot;&gt;http://samypesse.gitbooks.io/howtocreateanoperating-system/&lt;/a&gt; (PDF, Mobi及ePub)下载。它是使用&lt;a href=&quot;https://www.gitbook.com/&quot;&gt;GitBook&lt;/a&gt;生成的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Source Code&lt;/strong&gt;: All the system source code will be stored in the &lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/tree/master/src&quot;&gt;src&lt;/a&gt; directory. Each step will contain links to the different related files.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源代码&lt;/strong&gt;:所有系统源代码将存储在&lt;a href=&quot;https://github.com/samypesse/howto%20-%20make%20-a-%20computer%20-%20operating-system/tree/master/src&quot;&gt;src&lt;/a&gt;目录中。每个步骤将包含指向不同相关文件的链接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Contributions&lt;/strong&gt;: This course is open to contributions, feel free to signal errors with issues or directly correct the errors with pull-requests.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;投稿&lt;/strong&gt;:本课程开放投稿，有问题可以随时通知错误，也可以直接用pull-request更正错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Questions&lt;/strong&gt;: Feel free to ask any questions by adding issues or commenting sections.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;:可以通过添加问题(issues)或评论(commenting)来提问。&lt;/p&gt;
&lt;p&gt;You can follow me on Twitter &lt;a href=&quot;https://twitter.com/SamyPesse&quot;&gt;@SamyPesse&lt;/a&gt; or &lt;a href=&quot;https://github.com/SamyPesse&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;你可以关注我的推特&lt;a href=&quot;https://twitter.com/SamyPesse&quot;&gt;@SamyPesse&lt;/a&gt;或者&lt;a href=&quot;https://github.com/SamyPesse&quot;&gt;GitHub&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;what-kind-of-os-are-we-building&quot;&gt;What kind of OS are we building?&lt;/h3&gt;
&lt;h3 id=&quot;我们在构建什么样的操作系统&quot;&gt;我们在构建什么样的操作系统?&lt;/h3&gt;
&lt;p&gt;The goal is to build a very simple UNIX-based operating system in C++, not just a &quot;proof-of-concept&quot;. The OS should be able to boot, start a userland shell, and be extensible.&lt;/p&gt;
&lt;p&gt;目标是用c++构建一个非常简单的基于UNIX的操作系统，而不仅仅是“概念验证”。操作系统应该能够引导、启动用户界面shell并具有可扩展性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/raw/master/preview.png&quot; alt=&quot;Screen&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;chapter-1-introduction-to-the-x86-architecture-and-about-our-os&quot;&gt;Chapter 1: Introduction to the x86 architecture and about our OS&lt;/h2&gt;
&lt;h2 id=&quot;第1章介绍x86架构和我们的操作系统&quot;&gt;第1章:介绍x86架构和我们的操作系统&lt;/h2&gt;
&lt;h3 id=&quot;what-is-the-x86-architecture&quot;&gt;What is the x86 architecture?&lt;/h3&gt;
&lt;h3 id=&quot;什么是x86架构&quot;&gt;什么是x86架构?&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The term x86 denotes a family of backward compatible instruction set architectures based on the Intel 8086 CPU.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;x86是指一组基于Intel 8086 CPU的向后兼容指令集架构。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The x86 architecture is the most common instruction set architecture since its introduction in 1981 for the IBM PC. A large amount of software, including operating systems (OS's) such as DOS, Windows, Linux, BSD, Solaris and Mac OS X, function with x86-based hardware.&lt;/p&gt;
&lt;p&gt;x86体系结构是自1981年引入IBM PC以来最常见的指令集体系结构。大量的软件，包括DOS、Windows、Linux、BSD、Solaris和Mac OS X等操作系统，都使用基于x86的硬件。&lt;/p&gt;
&lt;p&gt;In this course we are not going to design an operating system for the x86-64 architecture but for x86-32, thanks to backward compatibility, our OS will be compatible with our newer PCs (but take caution if you want to test it on your real machine).&lt;/p&gt;
&lt;p&gt;在本课程中，我们不打算设计x86-64架构的操作系统，而是设计x86-32的操作系统，由于向后兼容性，我们的操作系统将与我们的新pc兼容(但如果您想在实际机器上测试它，请谨慎)。&lt;/p&gt;
&lt;h3 id=&quot;our-operating-system&quot;&gt;Our Operating System&lt;/h3&gt;
&lt;h3 id=&quot;我们的操作系统&quot;&gt;我们的操作系统&lt;/h3&gt;
&lt;p&gt;The goal is to build a very simple UNIX-based operating system in C++, but the goal is not to just build a &quot;proof-of-concept&quot;. The OS should be able to boot, start a userland shell and be extensible.&lt;/p&gt;
&lt;p&gt;目标是用c++构建一个非常简单的基于unix的操作系统，但目标不仅仅是构建一个“概念验证”。该操作系统应该能够引导、启动用户界面shell并具有可扩展性。&lt;/p&gt;
&lt;p&gt;The OS will be built for the x86 architecture, running on 32 bits, and compatible with IBM PCs.&lt;/p&gt;
&lt;p&gt;该操作系统将为x86架构构建，运行在32位上，并与IBM pc兼容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Specifications(规范):&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Code in C++ | c++代码&lt;/li&gt;
&lt;li&gt;x86, 32 bit architecture | x86, 32位架构&lt;/li&gt;
&lt;li&gt;Boot with Grub | 使用Grub启动&lt;/li&gt;
&lt;li&gt;Kind of modular system for drivers | 驱动程序的模块化系统&lt;/li&gt;
&lt;li&gt;Kind of UNIX style | UNIX风格&lt;/li&gt;
&lt;li&gt;Multitasking | 多任务&lt;/li&gt;
&lt;li&gt;ELF executable in userland&lt;/li&gt;
&lt;li&gt;Modules (accessible in userland using /dev/...) | 模块(可在用户区使用/dev/…访问): :
&lt;ul&gt;&lt;li&gt;IDE disks | IDE磁盘&lt;/li&gt;
&lt;li&gt;DOS partitions | DOS分区&lt;/li&gt;
&lt;li&gt;Clock | 时钟&lt;/li&gt;
&lt;li&gt;EXT2 (read only) | EXT2(只读)&lt;/li&gt;
&lt;li&gt;Boch VBE | 卷VBE&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Userland : | 用户:
&lt;ul&gt;&lt;li&gt;API Posix&lt;/li&gt;
&lt;li&gt;LibC&lt;/li&gt;
&lt;li&gt;&quot;Can&quot; run a shell or some executables (e.g., lua) “可以”运行shell或一些可执行文件(例如lua)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;chapter-2-setup-the-development-environment&quot;&gt;Chapter 2: Setup the development environment&lt;/h2&gt;
&lt;h2 id=&quot;第2章设置开发环境&quot;&gt;第2章:设置开发环境&lt;/h2&gt;
&lt;p&gt;The first step is to setup a good and viable development environment. Using Vagrant and Virtualbox, you'll be able to compile and test your OS from all the OSs (Linux, Windows or Mac).&lt;/p&gt;
&lt;p&gt;第一步是建立一个良好和可行的开发环境。使用Vagrant和Virtualbox，您将能够从很多平台(Linux、Windows或Mac)编译和测试您的操作系统。&lt;/p&gt;
&lt;h3 id=&quot;install-vagrant&quot;&gt;Install Vagrant&lt;/h3&gt;
&lt;h3 id=&quot;安装vagrant&quot;&gt;安装Vagrant&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Vagrant is free and open-source software for creating and configuring virtual development environments. It can be considered a wrapper around VirtualBox.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Vagrant是一款用于创建和配置虚拟开发环境的免费开源软件。它可以看作是VirtualBox的包装器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vagrant will help us create a clean virtual development environment on whatever system you are using.&lt;br/&gt;The first step is to download and install Vagrant for your system at http://www.vagrantup.com/.&lt;/p&gt;
&lt;p&gt;Vagrant将帮助我们在您使用的任何系统上创建一个干净的虚拟开发环境。第一步是在 &lt;a href=&quot;http://www.vagrantup.com/&quot; class=&quot;uri&quot;&gt;http://www.vagrantup.com/&lt;/a&gt; 为您的系统下载并安装Vagrant。&lt;/p&gt;
&lt;h3 id=&quot;install-virtualbox&quot;&gt;Install Virtualbox&lt;/h3&gt;
&lt;h3 id=&quot;安装virtualbox&quot;&gt;安装Virtualbox&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Oracle VM VirtualBox is a virtualization software package for x86 and AMD64/Intel64-based computers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Oracle VM VirtualBox是一个针对x86和AMD64/intel64计算机的虚拟化软件包。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vagrant needs Virtualbox to work, Download and install for your system at https://www.virtualbox.org/wiki/Downloads.&lt;/p&gt;
&lt;p&gt;Vagrant先需要安装Virtualbox，将它下载和安装到您的系统,下载地址:&lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot; class=&quot;uri&quot;&gt;https://www.virtualbox.org/wiki/Downloads&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;start-and-test-your-development-environment&quot;&gt;Start and test your development environment&lt;/h3&gt;
&lt;h3 id=&quot;启动并测试您的开发环境&quot;&gt;启动并测试您的开发环境&lt;/h3&gt;
&lt;p&gt;Once Vagrant and Virtualbox are installed, you need to download the ubuntu lucid32 image for Vagrant:&lt;/p&gt;
&lt;p&gt;安装好Vagrant和Virtualbox后，需要下载ubuntu lucid32的Vagrant:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vagrant box add lucid32 http://files.vagrantup.com/lucid32.box&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Once the lucid32 image is ready, we need to define our development environment using a &lt;em&gt;Vagrantfile&lt;/em&gt;, &lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/Vagrantfile&quot;&gt;create a file named &lt;em&gt;Vagrantfile&lt;/em&gt;&lt;/a&gt;. This file defines what prerequisites our environment needs: nasm, make, build-essential, grub and qemu.&lt;/p&gt;
&lt;p&gt;一但lucid32映像准备好了，我们就可以使用 &lt;em&gt;Vagrantfile&lt;/em&gt; 定义开发环境，&lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/Vagrantfile&quot;&gt;创建一个名为 &lt;em&gt;Vagrantfile&lt;/em&gt; 的文件&lt;/a&gt;。使用这个文件需要先准备以下环境:nasm、make、build-essential、grub和qemu。&lt;/p&gt;
&lt;p&gt;Start your box using:&lt;/p&gt;
&lt;p&gt;启动你的虚拟机&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vagrant up&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;You can now access your box by using ssh to connect to the virtual box using:&lt;/p&gt;
&lt;p&gt;您现在可以使用ssh访问您的虚拟机，使用:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vagrant ssh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The directory containing the &lt;em&gt;Vagrantfile&lt;/em&gt; will be mounted by default in the &lt;em&gt;/vagrant&lt;/em&gt; directory of the guest VM (in this case, Ubuntu Lucid32):&lt;/p&gt;
&lt;p&gt;包含&lt;em&gt;Vagrantfile&lt;/em&gt;的目录将默认挂载在客户VM的 &lt;em&gt;/vagrant&lt;/em&gt; 目录中(本例中为Ubuntu Lucid32):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /vagrant&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;build-and-test-our-operating-system&quot;&gt;Build and test our operating system&lt;/h4&gt;
&lt;h4 id=&quot;构建和测试我们的操作系统&quot;&gt;构建和测试我们的操作系统&lt;/h4&gt;
&lt;p&gt;The file &lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/Makefile&quot;&gt;&lt;strong&gt;Makefile&lt;/strong&gt;&lt;/a&gt; defines some basics rules for building the kernel, the user libc and some userland programs.&lt;/p&gt;
&lt;p&gt;文件&lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/Makefile&quot;&gt;&lt;strong&gt;Makefile&lt;/strong&gt;&lt;/a&gt;定义了一些构建内核、用户libc和一些用户空间程序的基本命令规则。&lt;/p&gt;
&lt;p&gt;Build:&lt;/p&gt;
&lt;p&gt;构建:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make all&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Test our operating system with qemu:&lt;/p&gt;
&lt;p&gt;使用qemu测试我们的操作系统:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;make run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;The documentation for qemu is available at &lt;a href=&quot;http://wiki.qemu.org/download/qemu-doc.html&quot;&gt;QEMU Emulator Documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can exit the emulator using: Ctrl-a.&lt;/p&gt;
&lt;p&gt;qemu的文档可以在&lt;a href=&quot;http://wiki.qemu.org/download/qemu-doc.html&quot;&gt;QEMU Emulator Documentation(qemu模拟器文档)&lt;/a&gt;中找到。&lt;/p&gt;
&lt;p&gt;您可以使用:Ctrl-a退出模拟器。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;chapter-3-first-boot-with-grub&quot;&gt;Chapter 3: First boot with GRUB&lt;/h2&gt;
&lt;h2 id=&quot;第3章grub主引导&quot;&gt;第3章:GRUB主引导&lt;/h2&gt;
&lt;h4 id=&quot;how-the-boot-works&quot;&gt;How the boot works?&lt;/h4&gt;
&lt;p&gt;引导是如何工作的?&lt;/p&gt;
&lt;p&gt;When an x86-based computer is turned on, it begins a complex path to get to the stage where control is transferred to our kernel's &quot;main&quot; routine (&lt;code&gt;kmain()&lt;/code&gt;). For this course, we are only going to consider the BIOS boot method and not it's successor (UEFI).&lt;/p&gt;
&lt;p&gt;当一台基于x86的计算机被启动时，它会经历一段很复杂的路程，以到达将控制权转移到内核“主”例程(“kmain()”)的阶段。对于本课程，我们只考虑BIOS引导方法，而不考虑它的后续方法(UEFI)。&lt;/p&gt;
&lt;p&gt;The BIOS boot sequence is: RAM detection -&amp;gt; Hardware detection/Initialization -&amp;gt; Boot sequence.&lt;/p&gt;
&lt;p&gt;BIOS引导序列为:RAM检测-&amp;gt;硬件检测/初始化-&amp;gt;引导序列。&lt;/p&gt;
&lt;p&gt;The most important step for us is the &quot;Boot sequence&quot;, where the BIOS is done with its initialization and tries to transfer control to the next stage of the bootloader process.&lt;/p&gt;
&lt;p&gt;对我们来说最重要的步骤是“引导序列”，此时BIOS完成了初始化，并试图将控制转移到引导加载程序的下一个阶段。&lt;/p&gt;
&lt;p&gt;During the &quot;Boot sequence&quot;, the BIOS will try to determine a &quot;boot device&quot; (e.g. floppy disk, hard-disk, CD, USB flash memory device or network). Our Operating System will initially boot from the hard-disk (but it will be possible to boot it from a CD or a USB flash memory device in future). A device is considered bootable if the bootsector contains the valid signature bytes &lt;code&gt;0x55&lt;/code&gt; and &lt;code&gt;0xAA&lt;/code&gt; at offsets 511 and 512 respectively (called the magic bytes of the Master Boot Record, also known as the MBR). This signature is represented (in binary) as 0b1010101001010101. The alternating bit pattern was thought to be a protection against certain failures (drive or controller). If this pattern is garbled or 0x00, the device is not considered bootable.&lt;/p&gt;
&lt;p&gt;在“引导顺序”期间，BIOS将尝试确定一个“引导设备”(例如软盘、硬盘、CD、USB闪存设备或网络)。我们的操作系统最初将从硬盘引导(但是将来可以从CD或USB闪存设备引导它)。如果引导扇区在偏移量511和512处分别包含有效的签名字节' 0x55 '和' 0xAA '(称为主引导记录的魔法字节，也称为MBR)，则认为设备是可引导的。此签名(以二进制)表示为0b1010101001010101。交替位模式被认为是对某些故障(驱动或控制器)的保护。如果该模式被打乱或0x00，则认为该设备不可引导。&lt;/p&gt;
&lt;p&gt;BIOS physically searches for a boot device by loading the first 512 bytes from the bootsector of each device into physical memory, starting at the address &lt;code&gt;0x7C00&lt;/code&gt; (1 KiB below the 32 KiB mark). When the valid signature bytes are detected, BIOS transfers control to the &lt;code&gt;0x7C00&lt;/code&gt; memory address (via a jump instruction) in order to execute the bootsector code.&lt;/p&gt;
&lt;p&gt;BIOS从地址“0x7C00”(低于32 KiB标记的1 KiB)开始，通过将每个设备的引导扇区中的前512字节加载到物理内存中来物理搜索引导设备。当检测到有效的签名字节时，BIOS将控制传输到“0x7C00”内存地址(通过跳转指令)，以便执行引导扇区代码。&lt;/p&gt;
&lt;p&gt;Throughout this process the CPU has been running in 16-bit Real Mode, which is the default state for x86 CPUs in order to maintain backwards compatibility. To execute the 32-bit instructions within our kernel, a bootloader is required to switch the CPU into Protected Mode.&lt;/p&gt;
&lt;p&gt;在整个过程中，CPU一直以16位实模式运行，这是x86 CPU为了保持向后兼容性的默认状态。要在内核中执行32位指令，需要一个引导加载程序将CPU切换到保护模式。&lt;/p&gt;
&lt;h4 id=&quot;what-is-grub&quot;&gt;What is GRUB?&lt;/h4&gt;
&lt;h4 id=&quot;什么是grub&quot;&gt;什么是GRUB?&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;GNU GRUB (short for GNU GRand Unified Bootloader) is a boot loader package from the GNU Project. GRUB is the reference implementation of the Free Software Foundation's Multiboot Specification, which provides a user the choice to boot one of multiple operating systems installed on a computer or select a specific kernel configuration available on a particular operating system's partitions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;GNU GRUB (GNU GRand Unified Bootloader的简称)是GNU项目中的一个引导加载程序包。GRUB是自由软件基金会(Free Software Foundation)的多引导规范的参考实现，该规范为用户提供了从安装在计算机上的多个操作系统中引导一个操作系统或选择特定操作系统分区上可用的特定内核配置的选项。&lt;/p&gt;
&lt;p&gt;To make it simple, GRUB is the first thing booted by the machine (a boot-loader) and will simplify the loading of our kernel stored on the hard-disk.&lt;/p&gt;
&lt;p&gt;简单来说，GRUB是机器(引导加载程序)启动的第一件事，它将简化存储在硬盘上的内核的加载&lt;/p&gt;
&lt;h4 id=&quot;why-are-we-using-grub&quot;&gt;Why are we using GRUB?&lt;/h4&gt;
&lt;h4 id=&quot;我们为什么要使用grub&quot;&gt;我们为什么要使用GRUB?&lt;/h4&gt;
&lt;h4 id=&quot;how-to-use-grub&quot;&gt;How to use GRUB?&lt;/h4&gt;
&lt;h4 id=&quot;如何使用grub&quot;&gt;如何使用GRUB?&lt;/h4&gt;
&lt;p&gt;GRUB uses the Multiboot specification, the executable binary should be 32bits and must contain a special header (multiboot header) in its 8192 first bytes. Our kernel will be a ELF executable file (&quot;Executable and Linkable Format&quot;, a common standard file format for executables in most UNIX system).&lt;/p&gt;
&lt;p&gt;GRUB使用多引导规范，可执行二进制文件应该是32位的，并且必须包含一个特殊的头(多引导头)，头8192个字节。我们的内核将是ELF可执行文件(“可执行和可链接格式”，大多数UNIX系统中可执行文件的通用标准文件格式)。&lt;/p&gt;
&lt;p&gt;The first boot sequence of our kernel is written in Assembly: &lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/kernel/arch/x86/start.asm&quot;&gt;start.asm&lt;/a&gt; and we use a linker file to define our executable structure: &lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/kernel/arch/x86/linker.ld&quot;&gt;linker.ld&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;我们内核的第一个引导序列是使用汇编编写的:&lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/kernel/arch/x86/start.asm&quot;&gt;start.asm&lt;/a&gt;，我们使用一个链接器文件来定义我们的可执行结构:&lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/kernel/arch/x86/linker.ld&quot;&gt;linker.ld&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;This boot process also initializes some of our C++ runtime, it will be described in the next chapter.&lt;/p&gt;
&lt;p&gt;这个引导过程还初始化了一些c++运行时，将在下一章中进行描述。&lt;/p&gt;
&lt;p&gt;Multiboot header structure:&lt;/p&gt;
&lt;p&gt;Multiboot头结构:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct multiboot_info {
    u32 flags;
    u32 low_mem;
    u32 high_mem;
    u32 boot_device;
    u32 cmdline;
    u32 mods_count;
    u32 mods_addr;
    struct {
        u32 num;
        u32 size;
        u32 addr;
        u32 shndx;
    } elf_sec;
    unsigned long mmap_length;
    unsigned long mmap_addr;
    unsigned long drives_length;
    unsigned long drives_addr;
    unsigned long config_table;
    unsigned long boot_loader_name;
    unsigned long apm_table;
    unsigned long vbe_control_info;
    unsigned long vbe_mode_info;
    unsigned long vbe_mode;
    unsigned long vbe_interface_seg;
    unsigned long vbe_interface_off;
    unsigned long vbe_interface_len;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;You can use the command &lt;code&gt;mbchk kernel.elf&lt;/code&gt; to validate your kernel.elf file against the multiboot standard. You can also use the command &lt;code&gt;nm -n kernel.elf&lt;/code&gt; to validate the offset of the different objects in the ELF binary.&lt;/p&gt;
&lt;p&gt;您可以使用命令 &lt;code&gt;mbchk kernel.elf&lt;/code&gt;来根据多引导标准验证kernel.elf文件。您还可以使用&lt;code&gt;nm -n kernel.elf&lt;/code&gt;验证elf二进制文件中不同对象的偏移量。&lt;/p&gt;
&lt;h4 id=&quot;create-a-disk-image-for-our-kernel-and-grub&quot;&gt;Create a disk image for our kernel and grub&lt;/h4&gt;
&lt;h4 id=&quot;为内核和grub创建一个磁盘映像&quot;&gt;为内核和grub创建一个磁盘映像&lt;/h4&gt;
&lt;p&gt;The script &lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/sdk/diskimage.sh&quot;&gt;diskimage.sh&lt;/a&gt; will generate a hard disk image that can be used by QEMU.&lt;/p&gt;
&lt;p&gt;脚本&lt;a href=&quot;https://github.com/SamyPesse/How-to-Make-a-Computer-Operating-System/blob/master/src/sdk/diskimage.sh&quot;&gt;diskimage.sh&lt;/a&gt;将生成一个可以使用QEMU启动的硬盘映像。&lt;/p&gt;
&lt;p&gt;The first step is to create a hard-disk image (c.img) using qemu-img:&lt;/p&gt;
&lt;p&gt;第一步是使用qemu-img创建硬盘映像(c.img):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;qemu-img create c.img 2M&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;We need now to partition the disk using fdisk:&lt;/p&gt;
&lt;p&gt;我们现在需要使用fdisk来分区磁盘:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;fdisk ./c.img

# Switch to Expert commands 切换到专家命令
&amp;gt; x

# Change number of cylinders (1-1048576) 修改柱面数量(1-1048576)
&amp;gt; c
&amp;gt; 4

# Change number of heads (1-256, default 16) 改变磁头数量(1-256，默认16)
&amp;gt; h
&amp;gt; 16

# Change number of sectors/track (1-63, default 63) 更改磁道数目(1-63，默认63)
&amp;gt; s
&amp;gt; 63

# Return to main menu 返回主菜单
&amp;gt; r

# Add a new partition 添加一个新分区
&amp;gt; n

# Choose primary partition 选择主分区
&amp;gt; p

# Choose partition number 选择分区号
&amp;gt; 1

# Choose first sector (1-4, default 1) 选择第一个扇区(1-4，默认1)
&amp;gt; 1

# Choose last sector, +cylinders or +size{K,M,G} (1-4, default 4) 选择最后一个扇区，+柱面或+大小{K,M,G}(1-4，默认4)
&amp;gt; 4

# Toggle bootable flag 切换启动的标志
&amp;gt; a

# Choose first partition for bootable flag 为可引导标志选择第一个分区
&amp;gt; 1

# Write table to disk and exit 将表写到磁盘并退出
&amp;gt; w&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;We need now to attach the created partition to the loop-device using losetup. This allows a file to be access like a block device. The offset of the partition is passed as an argument and calculated using: &lt;strong&gt;offset= start_sector * bytes_by_sector&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;现在我们需要使用losetup命令将创建的分区附加到循环设备上。这允许像块设备一样访问文件。分区的偏移量作为参数传递并使用:&lt;strong&gt;offset= start_扇区* bytes_by_扇区&lt;/strong&gt;计算。&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;fdisk -l -u c.img&lt;/code&gt;, you get: 63 * 512 = 32256.&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;fdisk -l -u c.img&lt;/code&gt;, 你将得到: 63 * 512 = 32256.&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;losetup -o 32256 /dev/loop1 ./c.img&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;We create a EXT2 filesystem on this new device using:&lt;/p&gt;
&lt;p&gt;我们使用以下命令在这个新设备上创建EXT2文件系统:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mke2fs /dev/loop1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;We copy our files on a mounted disk:&lt;/p&gt;
&lt;p&gt;我们复制我们的文件在一个挂载磁盘:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mount  /dev/loop1 /mnt/
cp -R bootdisk/* /mnt/
umount /mnt/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Install GRUB on the disk:&lt;/p&gt;
&lt;p&gt;在磁盘上安装GRUB:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;grub --device-map=/dev/null &amp;lt;&amp;lt; EOF
device (hd0) ./c.img
geometry (hd0) 4 16 63
root (hd0,0)
setup (hd0)
quit
EOF&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;And finally we detach the loop device:&lt;/p&gt;
&lt;p&gt;最后我们分离驱动循环:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;losetup -d /dev/loop1&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;see-also&quot;&gt;See Also&lt;/h4&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
</description>
<pubDate>Tue, 11 Dec 2018 15:39:00 +0000</pubDate>
<dc:creator>AntzUhl</dc:creator>
<og:description>How to Make a Computer Operating System 如何制作一个操作系统(翻译版) 原文地址:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LexMoon/p/How_to_Make_a_Computer_Operating_System.html</dc:identifier>
</item>
<item>
<title>异步编程之使用yield from - python学习中</title>
<link>http://www.cnblogs.com/c-x-a/p/10106031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-x-a/p/10106031.html</guid>
<description>&lt;p&gt;异步编程之使用yield from&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;yield from 是 Python3.3 后新加的语言结构。yield from的主要功能是打开双向通道，把最外层的调用方法与最内层的子生成器连接起来。这两者就可以进行发送值和返回值了，yeild from结构的本质是简化嵌套的生产器，不理解这个是什么意思的话,下面我将用几个例子来对其使用方法进行讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;简化for循环中的yeild&quot;&gt;简化for循环中的yeild&lt;/h3&gt;
&lt;p&gt;首先看一个&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def gene():
    for c in 'AB':
        yield c  #遇到yeild程序返回循环，下次从yeild后面开始。
    for i in range(3):
        yield i 
if __name__==&quot;__main__&quot;:
    list(gene())#list内部会预激生成器&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['A','B','0','1', '2']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码可以简写成&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def gene():
     yield from 'ab' 
     yield from range(3)
if __name__==&quot;__main__&quot;:
    list(gene()) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码我们可以知道,yield from 可以简化for循环里的yield表达式。当然yeild from的功能不仅仅是可以简化for循环而已，要是这样的话也就不值得，单独写一篇文章来介绍了。&lt;/p&gt;
&lt;p&gt;我们仔细观察,简化后的式子有两个yeild from,同样的也就是说如果有10个for循环的yeild生成式,我们需要写10个yeild from，此时我们要记得在python中如果重复的代码出现了两次以及以上就该考虑优化了。好了接下来我们看一个优化后的例子。&lt;/p&gt;
&lt;h3 id=&quot;通过yield-from链接可迭代对象&quot;&gt;通过yield from链接可迭代对象&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;def chain(*args):
    for i in args:
        # for m in i:
        #  yield m
        yield from i
p = list(chain(&quot;1234&quot;, &quot;AB&quot;, [1, 2, 3, 4, 5]))
print(p)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['1', '2', '3', '4', 'A', 'B', 1, 2, 3, 4, 5]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里对之前的例子做了个优化处理，通过*args可变参数，配合后面的for循环进行了多个可迭代对象的链接处理。下面来看一个复杂点的例子：(来自Python cookbook 3 ，github源码地址 &lt;a href=&quot;https://github.com/dabeaz/python-cookbook/blob/master/src/4/how_to_flatten_a_nested_sequence/example.py&quot; class=&quot;uri&quot;&gt;https://github.com/dabeaz/python-cookbook/blob/master/src/4/how_to_flatten_a_nested_sequence/example.py&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id=&quot;扁平化处理嵌套型的数据&quot;&gt;扁平化处理嵌套型的数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# Example of flattening a nested sequence using subgenerators

from collections import Iterable

def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

items = [1, 2, [3, 4, [5, 6], 7], 8]

# Produces 1 2 3 4 5 6 7 8
for x in flatten(items):
    print(x)

items = ['Dave', 'Paula', ['Thomas', 'Lewis']]
for x in flatten(items):
    print(x)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来通过说一下开篇提到的子生产器和调用方以及新的词委托生成器。&lt;/p&gt;
&lt;h3 id=&quot;了解几个概念&quot;&gt;了解几个概念&lt;/h3&gt;
&lt;p&gt;yield from x 表达式对x对象做的第一件事是，调用 iter(x)，从中获取一个迭代器。所以x是可迭代对象。上面的例子中的x如果是可迭代对象就会执行,yield from flatten(x).&lt;/p&gt;
&lt;p&gt;PEP380 的标题是 ”syntax for delegating to subgenerator“(把指责委托给子生成.器的句法)。由此我们可以知道，yield from是可以实现嵌套生成器的使用。&lt;/p&gt;
&lt;p&gt;yield from在看接下来的代码之前我们必须知道这几个概念：&lt;/p&gt;
&lt;h4 id=&quot;委派生成器&quot;&gt;委派生成器&lt;/h4&gt;
&lt;p&gt;包含yield from&lt;/p&gt;
&lt;h4 id=&quot;子生成器&quot;&gt;子生成器&lt;/h4&gt;
&lt;p&gt;从yield from&lt;/p&gt;
&lt;h4 id=&quot;调用方&quot;&gt;调用方&lt;/h4&gt;
&lt;p&gt;调用委派生成器的客户端（调用方）代码,也就是运行入口。&lt;/p&gt;
&lt;p&gt;ok,了解了这些我们看接下来的一个例子。&lt;/p&gt;
&lt;h3 id=&quot;使用yeild-from写一个异步爬虫&quot;&gt;使用yeild from写一个异步爬虫&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import requests
from collections import namedtuple  ①

Response = namedtuple(&quot;rs&quot;, 'url status') ②


# 子生产器
def fecth(): ③
    res=[]
    while 1:
        url = yield ④
        if url is None: ⑤
            break
        req = requests.get(url)
        res.append(Response(url=url, status=req.status_code))
    return res

#委派生成器
def url_list(l, key):
    while 1: ⑥
        l[key] = yield from fecth() ⑦

#调用方
def main():
    l = {}
    u = [&quot;http://www.baidu.com&quot;, &quot;http://www.cnblogs.com&quot;]
    for index, url in enumerate(u):
        if index == 0:
            ul = url_list(l, index)
            next(ul) ⑧
        ul.send(url)⑨
    ul.send(None)⑩
    return l


if __name__ == '__main__':
    res = main()
    print(res)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来对上面的标准进行解释:&lt;br/&gt;① 引入一个具名元组,可以后面实现一个简单的类。&lt;br/&gt;② 对请求参数做一个格式化处理，后面通过获取属性即可。&lt;br/&gt;③一个协程，通过requests模块可以发起网络请求。&lt;br/&gt;④main函数的发送的值绑定到这里的url上&lt;br/&gt;⑤ url为None即没有url的时候结束循环的。&lt;br/&gt;⑥这个循环每次都会新建一个fetch 实例，每个实例都是作为协程使用的生成器对象。&lt;br/&gt;⑦ url_list发送的每个值都会经由yield from 处理，然后传给fetch 实例。url_list会在yield from表达式处暂停，等待fetch实例处理客户端发来的值。fetch实例运行完毕后，返回的值绑定到l[key] 上。while 循环会不断创建fetch实例，处理更多的值。&lt;br/&gt;⑧激活url_list生成器&lt;br/&gt;⑨把各个url以及其序列号index，传给url_list传入的值最终到达fetch函数中,url_list并不知道传入的是什么，同时url_list实例在yield from处暂停。直到fetch的一个实例处理完才进行赋值。&lt;br/&gt;⑩关键的一步，ul把None传入url_list，传入的值最终到达fetch函数中，导致当前实例终止。然后继续创建下一个实例。如果没有ul.send(None)，那么fetch子生成器永远不会终止，因为ul.send()发送的值实际是在fetch实例中进行，委派生成器也永远不会在此激活，也就不会为l[key]赋值&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料：&lt;/h3&gt;
&lt;p&gt;流畅的python 第16章&lt;br/&gt;PEP 380-- Syntax for Delegating to a Subgenerator&lt;br/&gt;How Python 3.3 &quot;yield from&quot; construct works&lt;/p&gt;
</description>
<pubDate>Tue, 11 Dec 2018 15:33:00 +0000</pubDate>
<dc:creator>python学习中</dc:creator>
<og:description>异步编程之使用yield from yield from 是 Python3.3 后新加的语言结构。yield from的主要功能是打开双向通道，把最外层的调用方法与最内层的子生成器连接起来。这两者就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-x-a/p/10106031.html</dc:identifier>
</item>
<item>
<title>解决vue移动端适配问题 - 双眸</title>
<link>http://www.cnblogs.com/both-eyes/p/10106021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/both-eyes/p/10106021.html</guid>
<description>&lt;h4 id=&quot;先看看网上关于移动端适配讲解&quot;&gt;1，先看看网上关于移动端适配讲解&lt;/h4&gt;
&lt;h5 id=&quot;再聊移动端页面适配rem和vw适配方案&quot;&gt;再聊移动端页面适配，rem和vw适配方案！&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;基础点&lt;/strong&gt;：rem相对根节点字体的大小。所以不用px;&lt;br/&gt;&lt;strong&gt;根字体&lt;/strong&gt;：字体的大小px;&lt;br/&gt;&lt;strong&gt;px&lt;/strong&gt;：你就当成cm(厘米)这样的东西吧；&lt;br/&gt;&lt;strong&gt;基准&lt;/strong&gt;：750设计稿；&lt;/p&gt;
&lt;p&gt;这是方案的基础理论，在这个基础上，我们还要搞明白，到底要干一件什么事情！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标一&lt;/strong&gt; 、手机适配：就是页面上的尺寸，无论高度，还是宽度，还有字体，随屏幕的宽度变化！这里是屏幕宽度！是不是想到了vw，对，就是这个意思；——最大程度在各个尺寸屏幕上还原设计稿&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标二&lt;/strong&gt;、px转换成rem：一般UI给的设计稿宽度大小是750，所以，我们想直接写上面UI标记的尺寸；——最大程度减少工作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么选择rem?&lt;/strong&gt;&lt;br/&gt;很久之前没有vw，怕vw的兼容问题，就用了rem；也就是：rem的兼容性&amp;gt;vw的兼容性；&lt;br/&gt;还有一种就是自己写百分比很不优雅&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;一理论基础&quot;&gt;一、理论基础！&lt;/h3&gt;
&lt;h4 id=&quot;实现目标一&quot;&gt;实现目标一&lt;/h4&gt;
&lt;p&gt;用rem就可以了吧！因为rem就可以随根字体大小改变而改变，从而实现了自适应的功能。&lt;br/&gt;但是，但是，重点来，如果，根字体的大小默认是16px；那么，我们的1rem；就永远是16px，懂么？也就是如果设计稿是750（放大了一倍，iphone是375pt),我们想要个50%的大小:&lt;br/&gt;50%*357px/16=11.718rem&lt;br/&gt;如果我们写一个11.718rem的宽度，然而这只能在能iphone6还原设计稿，也就是只有在iphone6上这样的宽度才刚好占一半；&lt;br/&gt;那么问题来了，如果在每个屏幕上都是50%呢，直接改变根字体大小（16px)不就完了么！！；11.718rem永远还是那个11.718rem，不用担心；&lt;/p&gt;
&lt;h4 id=&quot;实现目标二&quot;&gt;实现目标二、&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;用工具，webpack，postcss,postcss-pxtorem&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;二准备主要工具&quot;&gt;二、准备主要工具！&lt;/h3&gt;
&lt;p&gt;viewport: 建议自行百度；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;vue-cli&lt;/strong&gt;: 用这个主要是用webpack,这个构建工具大大降低了webpack的使用难度;快速构建出一个前端项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;postcss&lt;/strong&gt;: 官网解释：PostCSS is a tool for transforming styles with JS plugins，就是postcss用js插件帮你转换css样式的一个工具。比如，这里的把你的文件里面16px替换成1rem(根大小默认16px的情况）；这样你就不用自己去算了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;postcss-pxtorem&lt;/strong&gt;: postcss的一个插件，主要是帮你把px转换成对应的rem；&lt;br/&gt;然后：还要用js代码去动态算根目录应该有的字体大小，反正就是一段js代码去动态获取屏幕宽度！&lt;/p&gt;
&lt;h3 id=&quot;三rem开始干&quot;&gt;三、rem——开始干！&lt;/h3&gt;
&lt;p&gt;第一步，先用vue-cli快速构建出一个项目，然后，安装postcss，postcss-pxtorem，postcss-loader，postcss-import，postcss-url；&lt;/p&gt;
&lt;p&gt;第二步，在项目根目录下添加.postcssrc.js文件，在里面写上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = { plugins: { 'postcss-pxtorem': { rootValue: 32, propList: ['*'], minPixelValue: 2 } }};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;rootValue，这里就是根目录的字体大小是32px，这里为啥设置成32呢，因为一般设计稿是750，比iphone6的大一倍，所以设置成16的两倍，就是32px;proplist就是那些属性需要转换成rem，这里是全部的意思；&lt;br/&gt;比如你可选择设置； propList: ['font', 'font-size', 'line-height', 'letter-spacing']&lt;br/&gt;minPixelValue就是最小转换单位，这是最小转换单位是2px的意思；&lt;/p&gt;
&lt;p&gt;第三步，动态设置根字体大小！一段简单的js插入在head里面；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(function() {
    function autoRootFontSize() {
        document.documentElement.style.fontSize =        Math.min(screen.width,document.documentElement.getBoundingClientRect().width)  /  750 * 32 + 'px';
          // 取screen.width和document.documentElement.getBoundingClientRect().width的最小值；除以750，乘以32；懂的起撒，就是原本是750大小的32px;如果屏幕大小变成了375px,那么字体就是16px;也就是根字体fontSize大小和屏幕大小成正比变化！是不是很简单
    }
    window.addEventListener('resize', autoRootFontSize);
    autoRootFontSize();
})();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里，我想说的是完全可以用vw去设置根字体大小，26px/375px=4.267vw;就不用js去算了！&lt;br/&gt;html{font-size:4.267vw}; //因为这个字体大小完全是随屏幕正比变化；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;四、vw——开始干！&lt;br/&gt;vw的方案就简单多了，因为vw本来就相对屏幕的百分比，所以我们不用再去动态的改变根字体大小了，只需要把750上的px大小转换成对应的vw值就完了，这一步交给postcss工具就可以！&lt;br/&gt;所以只需要两步！&lt;br/&gt;第一步，先用vue-cli快速构建出一个项目，然后，安装postcss，postcss-pxtorem，postcss-loader，postcss-import，postcss-url&lt;/p&gt;
&lt;p&gt;第二步，在项目根目录下添加.postcssrc.js文件，在里面写上&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module.exports = { &quot;plugins&quot;: { &quot;postcss-import&quot;: {}, &quot;postcss-url&quot;: {}, &quot;postcss-aspect-ratio-mini&quot;: {}, &quot;postcss-write-svg&quot;: { utf8: false }, &quot;postcss-cssnext&quot;: {}, &quot;postcss-px-to-viewport&quot;: { viewportWidth: 750, unitPrecision: 3, viewportUnit: 'vw', selectorBlackList: ['.ignore', '.hairlines'], minPixelValue: 1, mediaQuery: false }, &quot;postcss-viewport-units&quot;: {}, }}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;viewportWidth是你设计稿的大小750，然后unitPrecision是vw值保留的小数点个数；&lt;/p&gt;
&lt;h3 id=&quot;五总结&quot;&gt;五、总结！&lt;/h3&gt;
&lt;p&gt;首先明白一件事：px就像cm一样，1px永远是1px;1cm永远是1cm；&lt;br/&gt;那么我们从目标再反推一道逻辑：&lt;br/&gt;我们想要的结果很简单: 一个元素的宽度（px) / 屏幕宽度(px) = 定值 （这个定值就是设计稿上面的值比例定值）；&lt;/p&gt;
&lt;p&gt;——所以要做就是：屏幕变宽，要让元素宽度就变宽。&lt;br/&gt;然鹅，我们写的代码里面的px是不可能变的（取的750设计稿上面的尺寸）；那么postcss编译出来的rem值也是不变的；&lt;/p&gt;
&lt;p&gt;我们是怎么把设计稿里面的40px换算成相应rem的呢；你只要记住根字体大小的值（浏览器的默认是16px，现在设置成的32px)就是1rem；这交给工具同一去算；&lt;br/&gt;得到：元素的宽度(px) = 元素的宽度（rem) ✖️32; 所以这个32是你必须要设置在postcss-pxtorem里面的；这样它就可以帮你算；&lt;br/&gt;又因为： 元素的宽度(rem) ✖️ 根字体大小（px) = 元素的宽度（px)&lt;br/&gt;元素的宽度（px) 变大， 元素的宽度(rem) 不变，那就只有改变根字体大小（px) ，变大；具体怎么变，上面的js代码已经解释了；&lt;/p&gt;
&lt;p&gt;——所以我们做的就是：屏幕变宽，让根字体大小（px) 变宽，元素宽度就变宽。&lt;br/&gt;750屏幕下是写的样式大小是1:1, 所以&lt;br/&gt;又因为我们想要：根字体大小（px) / 屏幕宽度(px) = 32 / 750&lt;br/&gt;所以： 根字体大小（px) = 32 / 750 ✖️ 屏幕宽度(px)&lt;/p&gt;
&lt;p&gt;一个元素的宽度（px) / 屏幕宽度(px) = 定值&lt;br/&gt;→ 根字体大小（px) ✖️元素的宽度（rem）/ 屏幕宽度(px)&lt;br/&gt;→ 32 / 750 ✖️ 屏幕宽度(px) ✖️元素的宽度（rem）/ 屏幕宽度(px) 等于什么？？&lt;br/&gt;得到的的是一个与屏幕大小无关的定值！&lt;/p&gt;
&lt;p&gt;化简： 元素的宽度（rem）✖️32 / 750 = 元素的宽度（px) / 750 ——不就是设计稿上面的比例么！！！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;验证以上操作出来的结果是否符合预期也很简单：&lt;br/&gt;比如一个img的宽，高，在iphone6上的尺寸（审查元素的大小！px单位）：&lt;br/&gt;根字体:16px; postcss算出来的rem值是2.5rem; 2.5&lt;em&gt;16=40px; 实际上也是40px;&lt;br/&gt;——得到元素实际大小 40✖️40（px), 屏宽是375；比例是40/375=0.10667;&lt;br/&gt;在iphone5上的尺寸（审查元素的大小！px单位）：&lt;br/&gt;根字体：13.6533px; postcss算出来的rem值是2.5rem; 2.5&lt;/em&gt;13.6533=34.13px; 实际上也是34.13px;&lt;br/&gt;——得到元素实际大小 34.13✖️34.13（px), 屏宽是320；比例是34.13/320=0.10665;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;自己项目适配配置实践&quot;&gt;2，自己项目适配配置(实践)&lt;/h4&gt;
&lt;p&gt;上的文章讲的理论和方法是可行的，自己项目的解决方案和他大同小异（主要用rem）：&lt;br/&gt;1，插件：amfe-flexible + postcss-px2rem&lt;br/&gt;&lt;strong&gt;amfe-flexible&lt;/strong&gt;：自动根据不同设备改变data-dpr的值，这样就可以根据不同的data-dpr设置字体大小不变，仅放大相应倍数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;postcss-px2rem&lt;/strong&gt;：打包的时候把项目里面的px统一转换成rem，转换的基准值根据配置设置的（.postcssrc.js）&lt;br/&gt;/&lt;em&gt;因为我是以750px(iphone6)宽度为基准，所以remUnit为37.5&lt;/em&gt;/&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;经过试验结果&quot;&gt;经过试验结果：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;postcss-px2rem&lt;/strong&gt;：只负责把项目里面的px按照基准值转换成rem，并不负责根节点动态font-size的计算。&lt;/p&gt;
&lt;p&gt;例如，代码里面有个高度固定：180px， 基准值是：37.5， 那最后界面上的rem=180/37.5=4.8rem&lt;br/&gt;不管换不同客户端手机，不同分辨率，界面上都是固定4.8rem【rem的值是固定的，根据根节点的font-size不同，在界面显示的px也不同】，界面上显示的px = 16（没有设置font-size的话默认是16px）* 4.8rem = 76.8px&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181211232541377.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181211232551389.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181211232608265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;【那么这个基准值：37.5怎么来的：&lt;/p&gt;
&lt;p&gt;rem基准值计算&lt;br/&gt;关于rem的基准值,也就是上面那个37.5px其实是根据我们所拿到的视觉稿来决定的,主要有以下几点原因:&lt;br/&gt;1.由于我们所写出的页面是要在不同的屏幕大小设备上运行的,所以我们在写样式的时候必须要先以一个确定的屏幕来作为参考,这个就由我们拿到的视觉稿来定;假如我们拿到的视觉稿是以iphone6的屏幕width=375px为基准:&lt;br/&gt;ar docEl = document.documentElement;&lt;br/&gt;var width = docEl.getBoundingClientRect().width;&lt;br/&gt;var rem = width / 10;&lt;br/&gt;这样计算出来的rem基准值就是37.5(iphone6的视觉稿),这里为什么要除以10呢,其实这个值是随便定义的,因为不想让html的font-size太大,当然也可以选择不除,只要在后面动态js计算时保证一样的值就可以&lt;/p&gt;
&lt;p&gt;】&lt;/p&gt;
&lt;p&gt;上面的组件只负责转换rem，并没有根据不同设备设置font-size，下面再加入这个组件amfe-flexible:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181211232639764.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181211232658292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181211232705646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181211232717578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MzMyNjY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同设备下的font-size不同。&lt;/p&gt;
</description>
<pubDate>Tue, 11 Dec 2018 15:28:00 +0000</pubDate>
<dc:creator>双眸</dc:creator>
<og:description>1，先看看网上关于移动端适配讲解 再聊移动端页面适配，rem和vw适配方案！ 基础点 ：rem相对根节点字体的大小。所以不用px; 根字体 ：字体的大小px; px ：你就当成cm(厘米)这样的东西吧</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/both-eyes/p/10106021.html</dc:identifier>
</item>
<item>
<title>【Netty】（5）源码 Bootstrap - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10105887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10105887.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;上一篇讲了AbstractBootstrap,为这篇做了个铺垫。&lt;/p&gt;
&lt;h2 id=&quot;一概述&quot;&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Bootstrap 是 Netty 提供的一个便利的工厂类, 我们可以通过它来完成 Netty 的客户端或服务器端的 Netty 初始化.&lt;br/&gt;&lt;code&gt;Bootstrap&lt;/code&gt;: 用于客户端，只需要一个单独的Channel，来与服务端进行数据交互，对应server端的子Channel。&lt;br/&gt;&lt;code&gt;作用职责&lt;/code&gt;:EventLoop初始化,channel的注册过程 ,关于pipeline的初始化,handler的添加过程,客户端连接分析。&lt;/p&gt;
&lt;p&gt;Netty客户端源码部分&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  EventLoopGroup group = new NioEventLoopGroup();
         try {
             Bootstrap b = new Bootstrap();
             b.group(group) // 注册线程池
              .channel(NioSocketChannel.class) // 使用NioSocketChannel来作为连接用的channel类
              .handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() { // 绑定连接初始化器
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception {
                                     //这里放入自定义助手类
                                     ch.pipeline().addLast(new EchoClientHandler());
                                 }
                             });
         
             ChannelFuture cf = b.connect(host, port).sync(); // 异步连接服务器
             cf.channel().closeFuture().sync(); // 异步等待关闭连接channel
 
         } finally {
             group.shutdownGracefully().sync(); // 释放线程池资源
         }
     }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的客户端代码虽然简单, 但是却展示了 Netty 客户端初始化时所需的所有内容:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. EventLoopGroup: 不论是服务器端还是客户端, 都必须指定 EventLoopGroup. 在这个例子中, 
   指定了 NioEventLoopGroup, 表示一个 NIO   的EventLoopGroup.
2. ChannelType: 指定 Channel 的类型. 因为是客户端, 因此使用了 NioSocketChannel.
3. Handler: 设置数据的处理器.
4. 这里的option，提供了一系列的TCP参数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们深入代码, 看一下客户端通过 Bootstrap 启动后, 都做了哪些工作.&lt;/p&gt;
&lt;h2 id=&quot;二源码分析&quot;&gt;&lt;span&gt;二、源码分析&lt;/span&gt;&lt;/h2&gt;

&lt;h3 id=&quot;groupgroup&quot;&gt;&lt;span&gt;1、group(group)&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; /**
  * 直接调用父类AbstractBootstrap的方法
  */
public B group(EventLoopGroup group) {
    if (group == null) {
        throw new NullPointerException(&quot;group&quot;);
    }
    if (this.group != null) {
        throw new IllegalStateException(&quot;group set already&quot;);
    }
    this.group = group;
    return self();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接调用父类的方法 ，说明该EventLoopGroup，作为客户端 Connector 线程，负责注册监听连接操作位，用于判断异步连接结果。&lt;/p&gt;

&lt;h3 id=&quot;channelnioserversocketchannel.class&quot;&gt;&lt;span&gt;2、channel(NioServerSocketChannel.class)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在 Netty 中, Channel是一个Socket的抽象, 它为用户提供了关于 Socket 状态(是否是连接还是断开) 以及对 Socket 的读写等操作. 每当 Netty 建立了一个连接后, 都会有一个对应的 Channel 实例。&lt;/p&gt;
&lt;h4 id=&quot;源码&quot;&gt;&lt;span&gt;2.1源码&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 同样也是直接调用父类AbstractBootstrap的方法
 */
    public B channel(Class&amp;lt;? extends C&amp;gt; channelClass) {
        if (channelClass == null) {
            throw new NullPointerException(&quot;channelClass&quot;);
        }
        return channelFactory(new ReflectiveChannelFactory&amp;lt;C&amp;gt;(channelClass));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再来看下ReflectiveChannelFactory类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public class ReflectiveChannelFactory&amp;lt;T extends Channel&amp;gt; implements ChannelFactory&amp;lt;T&amp;gt; {

        private final Class&amp;lt;? extends T&amp;gt; clazz;

        /**
         * 通过构造函数 传入 clazz
         */
        public ReflectiveChannelFactory(Class&amp;lt;? extends T&amp;gt; clazz) {
            if (clazz == null) {
                throw new NullPointerException(&quot;clazz&quot;);
            }
            this.clazz = clazz;
        }

        /**
         * 只用这一个方法 通过传入不同的Channel.class 创建不同的Channel 对象。
         * newChannel() 什么时候调用呢 仔细追源码 发现是在绑定 IP 和 端口的 doResolveAndConnect方法里会调用
         */
        @Override
        public T newChannel() {
            try {
                return clazz.getConstructor().newInstance();
            } catch (Throwable t) {
                throw new ChannelException(&quot;Unable to create Channel from class &quot; + clazz, t);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在看channelFactory(new ReflectiveChannelFactory(channelClass)) 方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   /**
     * 创建好Channel后，返回对象Bootstrap本身
     */
    @Deprecated
    public B channelFactory(ChannelFactory&amp;lt;? extends C&amp;gt; channelFactory) {
        if (channelFactory == null) {
            throw new NullPointerException(&quot;channelFactory&quot;);
        }
        if (this.channelFactory != null) {
            throw new IllegalStateException(&quot;channelFactory set already&quot;);
        }
        this.channelFactory = channelFactory;
        return self();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此对于我们这个例子中的客户端的 Bootstrap 而言, 生成的的 Channel 实例就是 NioSocketChannel。&lt;/p&gt;
&lt;h4 id=&quot;channel-类型&quot;&gt;&lt;span&gt;2.2 Channel 类型&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;除了 TCP 协议以外, Netty 还支持很多其他的连接协议, 并且每种协议还有 NIO(异步 IO) 和 OIO(Old-IO, 即传统的阻塞 IO) 版本的区别. 不同协议不同的阻塞类型的连接都有不同的 Channel 类型与之对应下面是一些常用的 Channel 类型:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;- NioSocketChannel, 代表异步的客户端 TCP Socket 连接.
- NioServerSocketChannel, 异步的服务器端 TCP Socket 连接.
- NioDatagramChannel, 异步的 UDP 连接
- NioSctpChannel, 异步的客户端 Sctp 连接.
- NioSctpServerChannel, 异步的 Sctp 服务器端连接.
- OioSocketChannel, 同步的客户端 TCP Socket 连接.
- OioServerSocketChannel, 同步的服务器端 TCP Socket 连接.
- OioDatagramChannel, 同步的 UDP 连接
- OioSctpChannel, 同步的 Sctp 服务器端连接.
- OioSctpServerChannel, 同步的客户端 TCP Socket 连接.&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;handlerchannelhandler-handler&quot;&gt;&lt;span&gt;3、handler(ChannelHandler handler)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Netty 的一个强大和灵活之处就是基于 Pipeline 的&lt;code&gt;自定义 handler 机制&lt;/code&gt;. 基于此, 我们可以像添加插件一样自由组合各种各样的 handler 来完成业务逻辑. 例如我们需要处理 HTTP 数据, 那么就可以在 pipeline 前添加一个 Http 的编解码的 Handler, 然后接着添加我们自己的业务逻辑的 handler, 这样网络上的数据流就向通过一个管道一样, 从不同的 handler 中流过并进行编解码, 最终在到达我们自定义的 handler 中。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 同样也是 直接调用父类 AbstractBootstrap 的方法
 */
public B handler(ChannelHandler handler) {
    if (handler == null) {
        throw new NullPointerException(&quot;handler&quot;);
    }
    this.handler = handler;
    return self();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不过我们看到代码 一般都是这样写的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;.handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
         @Override
         public void initChannel(SocketChannel ch) throws Exception {
             ChannelPipeline p = ch.pipeline();
             p.addLast(new EchoClientHandler());
        }
     })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那是因为Bootstrap.handler 方法接收一个 ChannelHandler, 而我们传递的是一个 派生于 ChannelInitializer 的匿名类, 它正好也实现了 ChannelHandler 接口. 我们来看一下, ChannelInitializer 类部分代码:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /**
     * ChannelInboundHandlerAdapter 父类的父类 最终会继承 ChannelHandler 
     * 那么ChannelInitializer 也就是 ChannelHandler的 子类
     */
    public abstract class ChannelInitializer&amp;lt;C extends Channel&amp;gt; extends ChannelInboundHandlerAdapter {

        private static final InternalLogger logger
            =InternalLoggerFactory.getInstance(ChannelInitializer.class);

        /**
         * 这里只有这一个抽象类 所以我们只需重写这一个方法就可以了
         */
        protected abstract void initChannel(C ch) throws Exception;

        @Override
        @SuppressWarnings(&quot;unchecked&quot;)
        public final void channelRegistered(ChannelHandlerContext ctx) throws Exception {
            initChannel((C) ctx.channel());
            ctx.pipeline().remove(this);
            ctx.fireChannelRegistered();
        }
   
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ChannelInitializer 是一个抽象类, 它有一个抽象的方法 &lt;code&gt;initChannel&lt;/code&gt;, 我们正是实现了这个方法, 并添加的自定义的 handler 的. 那么 initChannel 是哪里被调用的呢?&lt;br/&gt;答案是 ChannelInitializer.channelRegistered 方法中。&lt;br/&gt;我们来关注一下 channelRegistered 方法. 从上面的源码中, 我们可以看到, 在 channelRegistered 方法中, 会调用 initChannel 方法, 将自定义的 handler 添加到 ChannelPipeline 中, 然后调用 ctx.pipeline().remove(this) 将自己从 ChannelPipeline 中删除. 上面的分析过程, 可以用如下图片展示:&lt;br/&gt;一开始, ChannelPipeline 中只有三个 handler, head, tail 和我们添加的 ChannelInitializer.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181211230706334-842492929.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着 initChannel 方法调用后, 添加了自定义的 handler&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181211230716642-806538917.png&quot;/&gt;&lt;br/&gt;最后将 ChannelInitializer 删除&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201812/1090617-20181211230737357-2072634091.png&quot;/&gt;&lt;/p&gt;

&lt;h3 id=&quot;channelpipeline对象&quot;&gt;&lt;span&gt;4、ChannelPipeline对象&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   /**
     * 我们在initChannel抽象方法的实现方法中 通过 SocketChannel获得 ChannelPipeline对象
     */
    ChannelPipeline p = ch.pipeline();
    p.addLast(newEchoClientHandler());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;在实例化一个 Channel 时, 会伴随着一个 ChannelPipeline 的实例化&lt;/code&gt;, 并且此 Channel 会与这个 ChannelPipeline 相互关联, 这一点可以通过NioSocketChannel 的父类 AbstractChannel 的构造器：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected AbstractChannel(Channel parent) {
    this.parent = parent;
    unsafe = newUnsafe();
    //这个可以看出
    pipeline = new DefaultChannelPipeline(this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当实例化一个 Channel(这里以 EchoClient 为例, 那么 Channel 就是 NioSocketChannel), 其 pipeline 字段就是我们新创建的 DefaultChannelPipeline 对象, 那么我们就来看一下 DefaultChannelPipeline 的构造方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public DefaultChannelPipeline(AbstractChannel channel) {
    if (channel == null) {
        throw new NullPointerException(&quot;channel&quot;);
    }
    this.channel = channel;

    tail = new TailContext(this);
    head = new HeadContext(this);

    head.next = tail;
    tail.prev = head;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们调用 DefaultChannelPipeline 的构造器, 传入了一个 channel, 而这个 channel 其实就是我们实例化的 NioSocketChannel, DefaultChannelPipeline 会将这个 NioSocketChannel 对象保存在channel 字段中。DefaultChannelPipeline 中, 还有两个特殊的字段, 即&lt;code&gt;head&lt;/code&gt; 和&lt;code&gt;tail&lt;/code&gt;, 而这两个字段是一个&lt;code&gt;双向链表的头和尾&lt;/code&gt;. 其实在 DefaultChannelPipeline 中, 维护了一个以 AbstractChannelHandlerContext 为节点的双向链表, 这个链表是 Netty 实现 Pipeline 机制的关键。&lt;/p&gt;
&lt;h3 id=&quot;connecthost-port&quot;&gt;&lt;span&gt;5、.connect(host, port)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;经过上面的各种分析后, 我们大致了解了 Netty 初始化时, 所做的工作, 接下来 分析一下客户端是如何发起 TCP 连接的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;   /**
     * 1、 这里 终于是Bootstrap 自己的方法了。 传入IP 地址 和 端口号
     */
    public ChannelFuture connect(String inetHost, int inetPort) {
        //通过InetSocketAddress 构造函数 绑定 IP地址+端口号
        return connect(InetSocketAddress.createUnresolved(inetHost, inetPort));
    }

   /**
     * 2、上面调用该方法 ，该方法在调用 doResolveAndConnect方法
     */
    public ChannelFuture connect(SocketAddress remoteAddress) {
        if (remoteAddress == null) {
            throw new NullPointerException(&quot;remoteAddress&quot;);
        }
        validate();
        return doResolveAndConnect(remoteAddress, config.localAddress());
    }

   /**
     * 3、这步 实例化 Channer
     */
    private ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) {
      
        //注意 这里 initAndRegister()方法就是实例化 Channer 的方法 上面说过 真正获取Channer 对象 是在这步获取的
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();

           // 这里省略的 很大一部分逻辑判断的代码
            return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());   
    }

    /**
     * 3.1 这里 就开始 调 newChannel() 方法 也就创建了 Channel 对象
     */
    final ChannelFuture initAndRegister() {
        Channel channel = null;
                channel = channelFactory.newChannel();
        return regFuture;
    }

    /**
     * 4、在看doResolveAndConnect0方法
     *    这一步还是对一些 参数数据 进行校验  省略了校验代码
     */
    private ChannelFuture doResolveAndConnect0(final Channel channel, SocketAddress remoteAddress,
                                               final SocketAddress localAddress, final ChannelPromise promise) {
           // 获取 当前 EventLoop线程
            final EventLoop eventLoop = channel.eventLoop();
            final AddressResolver&amp;lt;SocketAddress&amp;gt; resolver = this.resolver.getResolver(eventLoop);
            final Future&amp;lt;SocketAddress&amp;gt; resolveFuture = resolver.resolve(remoteAddress);
                   //这一步 才是 连接的关键
                    doConnect(resolveFuture.getNow(), localAddress, promise);
           
        return promise;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来看重要的方法，在 connect 中, 会进行一些参数检查后, 最终调用的是 &lt;strong&gt;doConnect&lt;/strong&gt; 方法，有关&lt;strong&gt;doConnect&lt;/strong&gt;之后接下来源码，等自己对Netty了解更细致之后 ，再来写吧。&lt;/p&gt;
&lt;p&gt;这里推荐一个博主,有关Netty源码分析的蛮好的：&lt;a href=&quot;https://segmentfault.com/a/1190000007282628&quot;&gt;源码之下无秘密 ── 做最好的 Netty 源码分析教程&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;如果一个人充满快乐，正面的思想，那么好的人事物就会和他共鸣，而且被他吸引过来。同样，一个人老带悲伤，倒霉的事情也会跟过来。

                                                  ——在自己心情低落的时候，告诫自己不要把负能量带给别人。（大校13）
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 11 Dec 2018 15:23:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>【Netty】5 源码 Bootstrap 上一篇讲了AbstractBootstrap,为这篇做了个铺垫。 一、概述 Bootstrap 是 Netty 提供的一个便利的工厂类, 我们可以通过它来完</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10105887.html</dc:identifier>
</item>
</channel>
</rss>