<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java：多态乃幸福本源 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10117431.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10117431.html</guid>
<description>&lt;h3 class=&quot;heading&quot;&gt;01 多态是什么&lt;/h3&gt;
&lt;p&gt;在我刻板的印象里，西游记里的那段孙悟空和二郎神的精彩对战就能很好的解释“多态”这个词：一个孙悟空，能七十二变；一个二郎神，也能七十二变；他们都可以变成不同的形态，但只需要悄悄地喊一声“变”。&lt;/p&gt;
&lt;p&gt;Java的多态是什么呢？其实就是一种能力——同一个行为具有不同的表现形式；换句话说就是，执行一段代码，Java在运行时能根据对象的不同产生不同的结果。和孙悟空和二郎神都只需要喊一声“变”，然后就变了，并且每次变得还不一样；一个道理。&lt;/p&gt;
&lt;p&gt;多态的前提条件有三个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子类继承父类&lt;/li&gt;
&lt;li&gt;子类覆盖父类的方法&lt;/li&gt;
&lt;li&gt;父类引用指向子类对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;多态的一个简单应用，来看程序清单1-1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;h3 class=&quot;heading&quot;&gt;02 多态与后期绑定&lt;/h3&gt;
&lt;p&gt;现在，我们来思考一个问题：程序清单1-1在执行&lt;code&gt;wanger.write()&lt;/code&gt;时，由于编译器只有一个Wanger引用，它怎么知道究竟该调用父类Wanger的&lt;code&gt;write()&lt;/code&gt;方法，还是子类Wangxiaoer的&lt;code&gt;write()&lt;/code&gt;方法呢？&lt;/p&gt;
&lt;p&gt;答案是在运行时根据对象的类型进行后期绑定，编译器在编译阶段并不知道对象的类型，但是Java的方法调用机制能找到正确的方法体，然后执行出正确的结果。&lt;/p&gt;
&lt;p&gt;多态机制提供的一个重要的好处程序具有良好的扩展性。来看程序清单2-1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;在程序清单2-1中，我们在Wanger类中增加了read()方法，在Wangxiaoer类中增加了eat()方法，但这丝毫不会影响到write()方法的调用。write()方法忽略了周围代码发生的变化，依然正常运行。这让我想起了金庸《倚天屠龙记》里九阳真经的口诀：“他强由他强，清风拂山岗；他横由他横，明月照大江。”&lt;/p&gt;
&lt;p&gt;多态的这个优秀的特性，让我们在修改代码的时候不必过于紧张，因为多态是一项让程序员“将改变的与未改变的分离开来”的重要特性。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot;&gt;03 多态与构造器&lt;/h3&gt;
&lt;p&gt;在构造器中调用多态方法，会产生一个奇妙的结果，我们来看程序清单3-1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Wangxiaosan &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Wangsan {
        &lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;int age = &lt;span class=&quot;hljs-number&quot;&gt;3;
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-title&quot;&gt;Wangxiaosan&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int age) {
                &lt;span class=&quot;hljs-keyword&quot;&gt;this.age = age;
                System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;王小三的年龄：&quot; + &lt;span class=&quot;hljs-keyword&quot;&gt;this.age);
        }
        
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;write&lt;span class=&quot;hljs-params&quot;&gt;() { &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出结果上看，是不是有点诧异？明明在创建Wangxiaosan对象的时候，年龄传递的是4，但输出结果既不是“老子上幼儿园的年龄是3岁半”，也不是“我小三上幼儿园的年龄是：4”。&lt;/p&gt;
&lt;p&gt;为什么？&lt;/p&gt;
&lt;p&gt;因为在创建子类对象时，会先去调用父类的构造器，而父类构造器中又调用了被子类覆盖的多态方法，由于父类并不清楚子类对象中的属性值是什么，于是把int类型的属性暂时初始化为0，然后再调用子类的构造器（子类构造器知道王小二的年龄是4）。&lt;/p&gt;
&lt;h3 class=&quot;heading&quot;&gt;04 多态与向下转型&lt;/h3&gt;
&lt;p&gt;向下转型是指将父类引用强转为子类类型；这是不安全的，因为有的时候，父类引用指向的是父类对象，向下转型就会抛出ClassCastException，表示类型转换失败；但如果父类引用指向的是子类对象，那么向下转型就是成功的。&lt;/p&gt;
&lt;p&gt;来看程序清单4-1：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot; lang=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;Wangxiaosi &lt;span class=&quot;hljs-keyword&quot;&gt;extends &lt;span class=&quot;hljs-title&quot;&gt;Wangsi {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;write&lt;span class=&quot;hljs-params&quot;&gt;() {
                System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;记住仇恨，表明我们要奋发图强的心智&quot;);
        }

        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;eat&lt;span class=&quot;hljs-params&quot;&gt;() {
                System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;我不喜欢读书，我就喜欢吃&quot;);
        }

        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;main&lt;span class=&quot;hljs-params&quot;&gt;(String[] args) {
                Wangsi[] wangsis = { &lt;span class=&quot;hljs-keyword&quot;&gt;new Wangsi(), &lt;span class=&quot;hljs-keyword&quot;&gt;new Wangxiaosi() };

                &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 class=&quot;heading&quot;&gt;05 总结&lt;/h3&gt;
&lt;p&gt;我喜欢把复杂的事情尽量简单化，把简单的事情有趣化——多态是Java的三大特性之一，它本来需要长篇大论的介绍，但我觉得实在没有必要，把关键的知识点提炼出来就足够了。更重要的是，你要通过实践去感知多态的优秀之处。&lt;/p&gt;
&lt;p&gt;Java 技术驿站的chenssy对多态下了一个非常经典的结论，我们不妨大声的朗读几遍：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编译时并不确定，而是在程序运行期间才确定；即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 23:36:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>在我刻板的印象里，西游记里的那段孙悟空和二郎神的精彩对战就能很好的解释“多态”这个词：一个孙悟空，能七十二变；一个二郎神，也能七十二变；他们都可以变成不同的形态，但只需要悄悄地喊一声“变”。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10117431.html</dc:identifier>
</item>
<item>
<title>eShopOnContainers 看微服务③：Identity Service - tianyamoon</title>
<link>http://www.cnblogs.com/tianyamoon/p/10111600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianyamoon/p/10111600.html</guid>
<description>&lt;p&gt;通常，服务所公开的资源和 API 必须仅限受信任的特定用户和客户端访问。那进行 API 级别信任决策的第一步就是身份认证——确定用户身份是否可靠。&lt;/p&gt;
&lt;p&gt;在微服务场景中，身份认证通常统一处理。一般有两种实现形式：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于API 网关中心化认证&lt;/strong&gt;：要求客户端必须都通过网关访问微服务。（这就要求提供一种安全机制来认证请求是来自于网关。）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/21899/201812/21899-20181212214523166-366072225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;基于安全令牌服务（STS）认证&lt;/strong&gt;：所有的客户端先从STS获取令牌，然后请求时携带令牌完成认证。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/21899/201812/21899-20181212214534501-1876450853.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Identity Service就是使用第二种身份认证方式。&lt;/p&gt;

&lt;p&gt;Identity microservice 主要用于统一的身份认证和授权，为其他服务提供支撑。&lt;/p&gt;
&lt;p&gt;提到认证，大家最熟悉不过的当属Cookie认证了，它也是目前使用最多的认证方式。但Cookie认证也有其局限性：不支持跨域、移动端不友好等。而从当前的架构来看，需要支持移动端、Web端、微服务间的交叉认证授权，所以传统的基于Cookie的本地认证方案就行不通了。我们就需要使用远程认证的方式来提供统一的认证授权机制。&lt;br/&gt;而远程认证方式当属：OAuth2.0和OpenID Connect了。借助OAuth2.0和OpenID Connect即可实现类似下图的认证体系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/21899/201812/21899-20181212215105314-657918336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而如何实现呢，借助：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ASP.NET Core Identity&lt;/li&gt;
&lt;li&gt;IdentityServer4&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基于Cookie的认证和基于Token的认证的差别如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/21899/201812/21899-20181212215300932-1585726585.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/21899/201812/21899-20181212220242196-1746088474.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要依赖：&lt;/p&gt;
&lt;p&gt;1、HealthCheck 健康检查&lt;/p&gt;
&lt;p&gt;2、WebHost&lt;/p&gt;
&lt;p&gt;3、Entity Framework&lt;/p&gt;
&lt;p&gt;4、Autofac&lt;/p&gt;
&lt;p&gt;5、&lt;a href=&quot;https://github.com/IdentityServer/IdentityServer4&quot;&gt;IdentityServer4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、其中IdentityServer4.AspNetIdentity又用到了&lt;a href=&quot;https://github.com/aspnet/Identity&quot;&gt;ASP.NET Core Identity&lt;/a&gt;&lt;/p&gt;




&lt;p&gt;   Main函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e452ea12-851e-4c37-92e1-589ff77a2baa')&quot; readability=&quot;36&quot;&gt;&lt;img id=&quot;code_img_closed_e452ea12-851e-4c37-92e1-589ff77a2baa&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e452ea12-851e-4c37-92e1-589ff77a2baa&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e452ea12-851e-4c37-92e1-589ff77a2baa',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e452ea12-851e-4c37-92e1-589ff77a2baa&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;            BuildWebHost(args)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 .MigrateDbContext&amp;lt;PersistedGrantDbContext&amp;gt;((_, __) =&amp;gt;&lt;span&gt; { })
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 .MigrateDbContext&amp;lt;ApplicationDbContext&amp;gt;((context, services) =&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; env = services.GetService&amp;lt;IHostingEnvironment&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; logger = services.GetService&amp;lt;ILogger&amp;lt;ApplicationDbContextSeed&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; settings = services.GetService&amp;lt;IOptions&amp;lt;AppSettings&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationDbContextSeed()
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                         .SeedAsync(context, env, logger, settings)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化默认登录用户种子数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                        .Wait();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                })
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 .MigrateDbContext&amp;lt;ConfigurationDbContext&amp;gt;((context, services) =&amp;gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; configuration = services.GetService&amp;lt;IConfiguration&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationDbContextSeed()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                         .SeedAsync(context, configuration)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化identity server种子数据&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                        .Wait();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }).Run();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;pre&gt;
BuildWebHost函数：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHost BuildWebHost(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
            WebHost.CreateDefaultBuilder(args)
                .UseKestrel()&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Kestrel作为的web服务器&lt;/span&gt;
                .UseHealthChecks(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/hc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;健康检查&lt;/span&gt;
                .UseContentRoot(Directory.GetCurrentDirectory())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将当前项目的根目录作为ContentRoot目录&lt;/span&gt;
                .UseIISIntegration()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用IIS&lt;/span&gt;
                .UseStartup&amp;lt;Startup&amp;gt;()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用startup类&lt;/span&gt;
                .ConfigureAppConfiguration((builderContext, config) =&amp;gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; builtConfig =&lt;span&gt; config.Build();

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configurationBuilder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConfigurationBuilder();

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Convert.ToBoolean(builtConfig[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UseVault&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
                    {
                        configurationBuilder.AddAzureKeyVault(
                            $&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://{builtConfig[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;Vault:Name&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]}.vault.azure.net/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                            builtConfig[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vault:ClientId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],
                            builtConfig[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Vault:ClientSecret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
                    }

                    configurationBuilder.AddEnvironmentVariables();

                    config.AddConfiguration(configurationBuilder.Build());
                })
                .ConfigureLogging((hostingContext, builder) &lt;/span&gt;=&amp;gt;&lt;span&gt;
                {
                    builder.AddConfiguration(hostingContext.Configuration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                    builder.AddConsole();
                    builder.AddDebug();
                })
                .UseApplicationInsights()
                .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中有一个UseHealthChecks，这是一个对项目健康的检查。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   健康检查,其实这个名称已经很明确了,它是检查你的应用程序是否健康运行的一种方式。随着当前各类项目越来越多的应用程序正在转向微&lt;br/&gt;服务式架构，健康检查就变得尤为关键。虽然微服务体系结构具有许多好处，但其中一个缺点就是为了确保所有这些服务都正常运行的操作开销&lt;br/&gt;更高。你不在是监视一个庞大的整体项目的健康状况，而是需要监控许多不同服务的状态，甚至这些服务通常只负责一件事情。健康检查(Heatlh&lt;br/&gt;Checks)通常与一些服务发现工具结合使用，如Consul  ，来监控您的微服务器，来观测您的服务是否健康运行。

   健康检查有很多种不同的方法，但最常见的方法是将HTTP端点暴露给专门用于健康检查的应用程序。一般来说,如果一切情况都很好，你的服&lt;br/&gt;务将返回200的状态码,然而任何非200的代码则意味着出现问题。例如，如果发生错误，你可能会返回500以及一些出错的JSON信息。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Startup.cs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('305aeea7-f3c3-4264-a514-1cde75fdad8b')&quot; readability=&quot;44.5&quot;&gt;&lt;img id=&quot;code_img_closed_305aeea7-f3c3-4264-a514-1cde75fdad8b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_305aeea7-f3c3-4264-a514-1cde75fdad8b&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('305aeea7-f3c3-4264-a514-1cde75fdad8b',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_305aeea7-f3c3-4264-a514-1cde75fdad8b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Startup(IConfiguration configuration)
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;             Configuration =&lt;span&gt; configuration;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; 
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 来配置我们应用程序中的各种服务，
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 它通过参数获取一个IServiceCollection 实例 。
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;IServiceProvider&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IServiceProvider ConfigureServices(IServiceCollection services)
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;            RegisterAppInsights(services);
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt; 
&lt;span&gt; 20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add framework services.
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册EF使用的DbContext&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt;             services.AddDbContext&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;
&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用mysql&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;              options.UseSqlServer(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;],&lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库连接字符串&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;                                      sqlServerOptionsAction: sqlOptions =&amp;gt;
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;                                     {
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;                                          sqlOptions.MigrationsAssembly(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Startup).GetTypeInfo().Assembly.GetName().Name);
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;                                          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Configuring Connection Resiliency: &lt;/span&gt;&lt;span&gt;https://docs.microsoft.com/en-us/ef/core/miscellaneous/connection-resiliency&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;                                          sqlOptions.EnableRetryOnFailure(maxRetryCount: &lt;span&gt;15&lt;/span&gt;, maxRetryDelay: TimeSpan.FromSeconds(&lt;span&gt;30&lt;/span&gt;), errorNumbersToAdd: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;                                     }));
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用Microsoft asp.net identity系统&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;             services.AddIdentity&amp;lt;ApplicationUser, IdentityRole&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                 .AddEntityFrameworkStores&amp;lt;ApplicationDbContext&amp;gt;()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用EF&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;                .AddDefaultTokenProviders();
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;             services.Configure&amp;lt;AppSettings&amp;gt;&lt;span&gt;(Configuration);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;             services.AddMvc();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用MVC
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; 
&lt;span&gt; 40&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对集群对配置&lt;/span&gt;
&lt;span&gt; 41&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (Configuration.GetValue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsClusterEnv&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;bool&lt;/span&gt;&lt;span&gt;.TrueString)
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 services.AddDataProtection(opts =&amp;gt;
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在集群环境中，如果不被具体的硬件机器环境所限制，就要排除运行机器的一些差异，
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;就需要抽象出来一些特定的标识，来标识应用程序本身并且使用该标识来区分不同的应用程序。
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个时候，我们可以指定ApplicationDiscriminator。&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;                     opts.ApplicationDiscriminator = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eshop.identity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;集群环境下同一应用程序他们需要设定为相同的值（ApplicationName or ApplicationDiscriminator）。&lt;/span&gt;
&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;                })
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;                 .PersistKeysToRedis(ConnectionMultiplexer.Connect(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DPConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DataProtection-Keys&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册健康检查&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;             services.AddHealthChecks(checks =&amp;gt;
&lt;span&gt; 56&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; minutes = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;.TryParse(Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;HealthCheck:Timeout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], &lt;span&gt;out&lt;/span&gt; &lt;span&gt;var&lt;/span&gt;&lt;span&gt; minutesParsed))
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;                     minutes =&lt;span&gt; minutesParsed;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库健康检查&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;                 checks.AddSqlCheck(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Identity_Db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;], TimeSpan.FromMinutes(minutes));
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册登陆注册的应用服务(ApplicationService)&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;             services.AddTransient&amp;lt;ILoginService&amp;lt;ApplicationUser&amp;gt;, EFLoginService&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;             services.AddTransient&amp;lt;IRedirectService, RedirectService&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; connectionString = Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ConnectionString&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; migrationsAssembly = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Startup).GetTypeInfo().Assembly.GetName().Name;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册 IdentityServer&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;             services.AddIdentityServer(x =&amp;gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 x.IssuerUri = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 x.Authentication.CookieLifetime = TimeSpan.FromHours(&lt;span&gt;2&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cookie有效期两小时&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;             .AddSigningCredential(Certificate.Get())&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置加密证书
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置IdentityServer。IUserClaimsPrincipalFactory、IResourceOwnerPasswordValidator和IProfileService的网络标识实现。&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt;             .AddAspNetIdentity&amp;lt;ApplicationUser&amp;gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;             .AddConfigurationStore(options =&amp;gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用IdentityServer配置IClientStore、IResourceStore和ICorsPolicyService的EF实现。&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                 options.ConfigureDbContext = builder =&amp;gt;&lt;span&gt; builder.UseSqlServer(connectionString,
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                                     sqlServerOptionsAction: sqlOptions =&amp;gt;
&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;                                        sqlOptions.MigrationsAssembly(migrationsAssembly);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Configuring Connection Resiliency: &lt;/span&gt;&lt;span&gt;https://docs.microsoft.com/en-us/ef/core/miscellaneous/connection-resiliency&lt;/span&gt; 
&lt;span&gt; 89&lt;/span&gt;                                         sqlOptions.EnableRetryOnFailure(maxRetryCount: &lt;span&gt;15&lt;/span&gt;, maxRetryDelay: TimeSpan.FromSeconds(&lt;span&gt;30&lt;/span&gt;), errorNumbersToAdd: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;                                    });
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;            })
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册IPersistedGrantStore的实现，用于存储AuthorizationCode和RefreshToken等等，默认实现是存储在内存中，
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果服务重启那么这些数据就会被清空了，因此实现IPersistedGrantStore将这些数据写入到数据库中&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;             .AddOperationalStore(options =&amp;gt;
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt;                     options.ConfigureDbContext = builder =&amp;gt;&lt;span&gt; builder.UseSqlServer(connectionString,
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                                     sqlServerOptionsAction: sqlOptions =&amp;gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                                    {
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;                                        sqlOptions.MigrationsAssembly(migrationsAssembly);
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Configuring Connection Resiliency: &lt;/span&gt;&lt;span&gt;https://docs.microsoft.com/en-us/ef/core/miscellaneous/connection-resiliency&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;                                         sqlOptions.EnableRetryOnFailure(maxRetryCount: &lt;span&gt;15&lt;/span&gt;, maxRetryDelay: TimeSpan.FromSeconds(&lt;span&gt;30&lt;/span&gt;), errorNumbersToAdd: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                                    });
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                })
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册IProfileService，该接口允许IdentityServer连接到用户。&lt;/span&gt;
&lt;span&gt;105&lt;/span&gt;             .Services.AddTransient&amp;lt;IProfileService, ProfileService&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; 
&lt;span&gt;107&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用autofac&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; container = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContainerBuilder();
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;            container.Populate(services);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AutofacServiceProvider(container.Build());
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; 
&lt;span&gt;114&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.&lt;/span&gt;
&lt;span&gt;115&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置日志&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt;             loggerFactory.AddConsole(Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logging&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;            loggerFactory.AddDebug();
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;            loggerFactory.AddAzureWebAppDiagnostics();
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;            loggerFactory.AddApplicationInsights(app.ApplicationServices, LogLevel.Trace);
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;125&lt;/span&gt; &lt;span&gt;                app.UseDeveloperExceptionPage();
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; &lt;span&gt;                app.UseDatabaseErrorPage();
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 app.UseExceptionHandler(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Home/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; 
&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pathBase = Configuration[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PATH_BASE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(pathBase))
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                 loggerFactory.CreateLogger(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).LogDebug($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Using PATH BASE '{pathBase}'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;                app.UsePathBase(pathBase);
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; 
&lt;span&gt;140&lt;/span&gt; 
&lt;span&gt;141&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; warning disable CS1998 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Async method lacks 'await' operators and will run synchronously&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;             app.Map(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/liveness&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lapp =&amp;gt; lapp.Run(&lt;span&gt;async&lt;/span&gt; ctx =&amp;gt; ctx.Response.StatusCode = &lt;span&gt;200&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;#pragma&lt;/span&gt; warning restore CS1998 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Async method lacks 'await' operators and will run synchronously&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用StaticFiles，等于启动了静态文件服务器功能。wwwroot 就是靠这个中间件读取的。
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以不使用wwwroot，并且制定自己对目录。传入参数就可以了。&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt; &lt;span&gt;            app.UseStaticFiles();
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt; 
&lt;span&gt;150&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make work identity server redirections in Edge and lastest versions of browers. WARN: Not valid in a production environment.&lt;/span&gt;
&lt;span&gt;151&lt;/span&gt;             app.Use(&lt;span&gt;async&lt;/span&gt; (context, next) =&amp;gt;
&lt;span&gt;152&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;                 context.Response.Headers.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Security-Policy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;script-src 'unsafe-inline'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                 &lt;span&gt;await&lt;/span&gt;&lt;span&gt; next();
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; 
&lt;span&gt;157&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理代理服务器和负载均衡对解决方案，
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;详情 &lt;/span&gt;&lt;span&gt;https://docs.microsoft.com/zh-cn/aspnet/core/host-and-deploy/proxy-load-balancer?view=aspnetcore-2.1&lt;/span&gt;
&lt;span&gt;159&lt;/span&gt; &lt;span&gt;            app.UseForwardedHeaders();
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用IdentityServer4&lt;/span&gt;
&lt;span&gt;161&lt;/span&gt; &lt;span&gt;            app.UseIdentityServer();
&lt;/span&gt;&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置MVC&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt;             app.UseMvc(routes =&amp;gt;
&lt;span&gt;165&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt; &lt;span&gt;                routes.MapRoute(
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;                     name: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;                     template: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{controller=Home}/{action=Index}/{id?}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt; 
&lt;span&gt;172&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 应用监控
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;175&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;services&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;176&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RegisterAppInsights(IServiceCollection services)
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; &lt;span&gt;            services.AddApplicationInsightsTelemetry(Configuration);
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; orchestratorType = Configuration.GetValue&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrchestratorType&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt; 
&lt;span&gt;181&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (orchestratorType?.ToUpper() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;K8S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Enable K8s telemetry initializer&lt;/span&gt;
&lt;span&gt;184&lt;/span&gt; &lt;span&gt;                services.EnableKubernetes();
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (orchestratorType?.ToUpper() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Enable SF telemetry initializer&lt;/span&gt;
&lt;span&gt;189&lt;/span&gt;                 services.AddSingleton&amp;lt;ITelemetryInitializer&amp;gt;((serviceProvider) =&amp;gt;
&lt;span&gt;190&lt;/span&gt;                     &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FabricTelemetryInitializer());
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;192&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;


&lt;p&gt;ASP.NET Core Identity用于构建ASP.NET Core Web应用程序的成员资格系统，包括成员资格，登录和用户数据（包括登录信息、角色和声明）。&lt;br/&gt;ASP.NET Core Identity封装了User、Role、Claim等身份信息，便于我们快速完成登录功能的实现，并且支持第三方登录（Google、Facebook、QQ、Weixin等，支持开箱即用[&lt;a href=&quot;https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/src&quot;&gt;第三方身份提供商列表&lt;/a&gt;]），以及双重验证，同时内置支持Bearer 认证（令牌认证）。&lt;/p&gt;
&lt;p&gt;虽然ASP.NET Core Identity已经完成了绝大多数的功能，且支持第三方登录（第三方为其用户颁发令牌），但若要为本地用户颁发令牌，则需要自己实现令牌的颁发和验证逻辑。换句话说，我们需要自行实现OpenId Connect协议。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;OpenID Connect 1.0 是基于OAuth 2.0协议之上的简单身份层，它允许客户端根据授权服务器的认证结果最终确认终端用户的身份，以及获取基本的用户信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而IdentityServer4就是为ASP.NET Core量身定制的实现了OpenId Connect和OAuth2.0协议的认证授权中间件。IdentityServer4在ASP.NET Core Identity的基础上，提供令牌的颁发验证等。&lt;/p&gt;
&lt;p&gt;相关知识：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; href=&quot;https://www.cnblogs.com/cgzl/p/9221488.html&quot;&gt;OAuth 2.0 简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cgzl/p/9231219.html&quot;&gt;OpenID Connect 简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cgzl/p/9253667.html&quot;&gt;Identity Server 4&lt;/a&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;在ASP.NET Core中使用的是&lt;/span&gt;&lt;strong&gt;基于申明（Claim）的认证&lt;/strong&gt;&lt;span&gt;，而什么是申明（Cliam）呢？&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Claim 是关于一个人或组织的某个主题的陈述，比如：一个人的名称，角色，个人喜好，种族，特权，社团，能力等等。它本质上就是一个键值对，是一种非常通用的保存用户信息的方式，可以很容易的将认证和授权分离开来，前者用来表示用户是/不是什么，后者用来表示用户能/不能做什么。在认证阶段我们通过用户信息获取到用户的Claims，而授权便是对这些的Claims的验证，如：是否拥有Admin的角色，姓名是否叫XXX等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;认证主要与以下几个核心对象打交道：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Claim（身份信息）&lt;/li&gt;
&lt;li&gt;ClaimsIdentity（身份证）&lt;/li&gt;
&lt;li&gt;ClaimsPrincipal （身份证持有者）&lt;/li&gt;
&lt;li&gt;AuthorizationToken （授权令牌）&lt;/li&gt;
&lt;li&gt;IAuthenticationScheme（认证方案）&lt;/li&gt;
&lt;li&gt;IAuthenticationHandler（与认证方案对应的认证处理器）&lt;/li&gt;
&lt;li&gt;IAuthenticationService （向外提供统一的认证服务接口）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那其认证流程是怎样的呢？&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;1、用户打开登录界面，输入用户名密码先行登录，服务端先行校验用户名密码是否有效，有效则返回用户实例（User）。&lt;/p&gt;
&lt;p&gt;2、这时进入认证准备阶段，根据用户实例携带的身份信息（Claim），创建身份证（ClaimsIdentity），然后将身份证交给身份证持有者（ClaimsPrincipal）持有。&lt;/p&gt;
&lt;p&gt;3、接下来进入真正的认证阶段，根据配置的认证方案（IAuthenticationScheme），使用相对应的认证处理器（IAuthenticationHandler）进行认证 。认证成功后发放授权令牌（AuthorizationToken）。该授权令牌包含后续授权阶段需要的全部信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt; 授权就是对于用户身份信息（Claims）的验证，，授权又分以下几种种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于Role的授权&lt;/li&gt;
&lt;li&gt;基于Scheme的授权&lt;/li&gt;
&lt;li&gt;基于Policy的授权&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;授权主要与以下几个核心对象打交道：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;IAuthorizationRequirement（授权条件）&lt;/li&gt;
&lt;li&gt;IAuthorizationService（授权服务）&lt;/li&gt;
&lt;li&gt;AuthorizationPolicy（授权策略）&lt;/li&gt;
&lt;li&gt;IAuthorizationHandler （授权处理器）&lt;/li&gt;
&lt;li&gt;AuthorizationResult（授权结果）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那授权流程是怎样的呢？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当收到授权请求后，由授权服务（IAuthorizationService）根据资源上指定的授权策略（AuthorizationPolicy）中包含的授权条件（IAuthorizationRequirement），找到相对应的授权处理器（IAuthorizationHandler ）来判断授权令牌中包含的身份信息是否满足授权条件，并返回授权结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/21899/201812/21899-20181212222431536-965440622.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 回过头来我们再来刷一遍startup代码中是怎么集成进Identity service的。&lt;/p&gt;
&lt;h2 id=&quot;autoid-7-0-0&quot;&gt;1. 首先是映射自定义扩展的User和Role&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 映射自定义的User，Role&lt;/span&gt;
services.AddIdentity&amp;lt;ApplicationUser, IdentityRole&amp;gt;&lt;span&gt;()
    .AddEntityFrameworkStores&lt;/span&gt;&amp;lt;ApplicationDbContext&amp;gt;()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置使用EF持久化存储&lt;/span&gt;
    .AddDefaultTokenProviders();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;配置默认的TokenProvider用于变更密码和修改email时生成Token&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. 配置IdentityServer服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
services.AddIdentityServer(x =&amp;gt;&lt;span&gt;
{&lt;br/&gt;　　...&lt;/span&gt;&lt;span&gt;
})
.AddSigningCredential(Certificate.Get())
.AddAspNetIdentity&lt;/span&gt;&amp;lt;ApplicationUser&amp;gt;&lt;span&gt;()
.AddConfigurationStore(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    ...&lt;/span&gt;&lt;span&gt;
})
.AddOperationalStore(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
{
    ...&lt;/span&gt;&lt;span&gt;
})
.Services.AddTransient&lt;/span&gt;&amp;lt;IProfileService, ProfileService&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用&lt;code&gt;AddConfigurationStore&lt;/code&gt;和&lt;code&gt;AddOperationalStore&lt;/code&gt;扩展方法就是用来来指定配置数据和操作数据基于EF进行持久化。&lt;/p&gt;
&lt;h2 id=&quot;autoid-7-2-0&quot;&gt;3. 添加IdentityServer中间件&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt; app.UseIdentityServer();&lt;/span&gt;&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;autoid-7-3-0&quot;&gt;4. 预置种子数据&lt;/h2&gt;
&lt;p&gt;需要预置Client和Resource写在Config.cs文件中，他们又是中main函数中被MigrateDbContext使用的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GetClients&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;Client&amp;gt; GetClients(Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; clientsUrl)
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;Client&amp;gt;&lt;span&gt;
    {&lt;br/&gt;　　　　 //通过不同对ClientId设置不同客户端参数
&lt;/span&gt;        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
        ... ...&lt;/span&gt;        &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;IdentityResources&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;身份资源是用户ID、姓名或电子邮件地址等数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;IdentityResource&amp;gt;&lt;span&gt; GetResources()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;IdentityResource&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.OpenId(),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; IdentityResources.Profile()
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;ApiResources&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IEnumerable&amp;lt;ApiResource&amp;gt;&lt;span&gt; GetApis()
{
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; List&amp;lt;ApiResource&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orders&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Orders Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;basket&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Basket Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;marketing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Marketing Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;locations&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Locations Service&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mobileshoppingagg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mobile Shopping Aggregator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;webshoppingagg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Web Shopping Aggregator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
        &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; ApiResource(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;orders.signalrhub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ordering Signalr Hub&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    };
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;autoid-7-4-0&quot;&gt;5. 迁移数据库上下文&lt;/h2&gt;
&lt;p&gt;IdentityServer为配置数据和操作数据分别定义了&lt;code&gt;DBContext&lt;/code&gt;用于持久化，配置数据对应&lt;code&gt;ConfigurationDbContext&lt;/code&gt;，操作数据对应&lt;code&gt;PersistedGrantDbContext&lt;/code&gt;。详细看main函数。&lt;/p&gt;


&lt;p&gt;这篇文章使用了园子里&lt;a id=&quot;Header1_HeaderTitle&quot; class=&quot;headermaintitle&quot; href=&quot;https://www.cnblogs.com/sheng-jie/&quot;&gt;『___知多少』&lt;/a&gt;文章对不少内容，表示感谢，原文链接&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/sheng-jie/p/9828165.html&quot;&gt;eShopOnContainers 知多少[3]：Identity microservice&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 17:24:00 +0000</pubDate>
<dc:creator>tianyamoon</dc:creator>
<og:description>引言 通常，服务所公开的资源和 API 必须仅限受信任的特定用户和客户端访问。那进行 API 级别信任决策的第一步就是身份认证——确定用户身份是否可靠。 在微服务场景中，身份认证通常统一处理。一般有两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tianyamoon/p/10111600.html</dc:identifier>
</item>
<item>
<title>javascript的event loop事件循环 - 薛小白</title>
<link>http://www.cnblogs.com/yangyangxxb/p/10117063.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyangxxb/p/10117063.html</guid>
<description>&lt;h2&gt;javascript的event loop事件循环&lt;/h2&gt;
&lt;p&gt;这是今天一个朋友发给我的一个面试题，&lt;/p&gt;
&lt;p&gt;感觉还挺有意思的，&lt;/p&gt;
&lt;p&gt;写个博客以供分享&lt;/p&gt;

&lt;p&gt;先看看这个面试题目：&lt;/p&gt;
&lt;p&gt;观察下面的代码，写出输出结果&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;console.log(&lt;span&gt;'0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
setTimeout(function&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; () {
   &lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;span&gt; console&lt;/span&gt;&lt;span&gt;.log(&lt;/span&gt;&lt;span&gt;'1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
});

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Promise(function(resolve,reject){
   &lt;/span&gt;&lt;span&gt; console&lt;/span&gt;&lt;span&gt;.log(&lt;/span&gt;&lt;span&gt;'2&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;    resolve(3)
}).then(function&lt;/span&gt;&lt;span&gt;(val){
&lt;/span&gt;&lt;span&gt;    console.log(&lt;/span&gt;&lt;span&gt;&lt;span&gt;val&lt;/span&gt;&lt;/span&gt;&lt;span&gt;)
})
console.log(4&lt;/span&gt;&lt;span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;br/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果： “0” “2” 4 3 “1”&lt;/p&gt;

&lt;p&gt;今天主要是分析为什么输出结果是这样的？这就和 &lt;code&gt;javascript&lt;/code&gt; 的执行机制密切相关了.&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;Event&lt;/strong&gt; &lt;strong&gt;Queue&lt;/strong&gt; 和 &lt;strong&gt;Event&lt;/strong&gt; &lt;strong&gt;Loop&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript&lt;/code&gt; 是一门单线程的语言, 这就意味着在执行代码的时候, 都只有一个主线程来处理所有的任务.&lt;/p&gt;
&lt;p&gt;我们都知道 &lt;code&gt;javascript&lt;/code&gt; 包括同步代码和异步代码, 那么 &lt;code&gt;javascript&lt;/code&gt; 是怎么处理这两种情况的呢?&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;同步和异步任务分别进入不同的执行 &lt;code&gt;场所&lt;/code&gt;, 同步的进入主线程，异步的进入 &lt;code&gt;Event Table&lt;/code&gt; 并注册函数&lt;/li&gt;
&lt;li&gt;当指定的事情完成时, &lt;code&gt;Event Table&lt;/code&gt; 会将这个函数(回调函数)移入 &lt;code&gt;Event Queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主线程内的任务执行完毕为空, 会去 &lt;code&gt;Event Queue&lt;/code&gt; 读取对应的函数，进入主线程执行&lt;/li&gt;
&lt;li&gt;上述过程会不断重复, 也就是常说的 &lt;code&gt;Event Loop(事件循环)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我们引进了 &lt;code&gt;Event Queue&lt;/code&gt; 事件队列这一概念. 所有异步操作的回调都会进入到这里. 然后等到主线程空闲, 就会从这里调取回调执行.&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;setTimeout&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;setTimeout&lt;/code&gt; 相信大家都有使用过, 可以延时执行并且是异步执行的.&lt;/p&gt;
&lt;p&gt;但是有时候我们得到的结果往往是代码实际执行的时间比我们想要延时执行的时间要久。这又是为什么呢?&lt;/p&gt;
&lt;p&gt;这就和我们之前所说的 &lt;code&gt;Event Loop&lt;/code&gt; 有关了, 我们可以来具体看下 &lt;code&gt;setTimeout&lt;/code&gt; 的执行步骤:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;setTimeout(function () {
    asyncFn()
}, &lt;/span&gt;&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);

syncFn()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;&lt;code&gt;asyncFn&lt;/code&gt; 将异步执行函数放在 &lt;code&gt;Event Table&lt;/code&gt;, 并且开始计时&lt;/li&gt;
&lt;li&gt;开始执行 &lt;code&gt;syncFn&lt;/code&gt;, 但是 &lt;code&gt;syncFn&lt;/code&gt; 可能需要处理的内容很多, 执行时间超过 &lt;code&gt;1&lt;/code&gt; 秒, 但是计时还在继续&lt;/li&gt;
&lt;li&gt;计时到达 &lt;code&gt;1&lt;/code&gt; 秒, &lt;code&gt;setTimeout&lt;/code&gt; 延时完成, &lt;code&gt;asyncFn&lt;/code&gt; 进入 &lt;code&gt;Event Queue&lt;/code&gt; 事件队列, 但是主线程还在执行, 所以只能等待&lt;/li&gt;
&lt;li&gt;&lt;code&gt;syncFn&lt;/code&gt; 执行完成, 此时 &lt;code&gt;asyncFn&lt;/code&gt; 从事件队列中进入主线程执行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以有时候会出现代码实际执行时间比延时时间长的情况。&lt;/p&gt;

&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;宏任务和微任务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;之前我们说过异步任务会进入到事件队列中, 不同类型的任务会进入到不同的队列中, 比如宏任务会进入到宏任务队列中, 微任务会进入到微任务队列中.&lt;/p&gt;

&lt;p&gt;我们只要记住 当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行&lt;/p&gt;
&lt;p&gt;这时候我们就可以解释一开始的代码执行结果了:&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;主线程执行按顺序代码&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;setTimeout&lt;/code&gt;, 回调进入到宏任务队列上&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;Promise&lt;/code&gt;, 立即执行, &lt;code&gt;then&lt;/code&gt; 函数进入到微任务队列&lt;/li&gt;
&lt;li&gt;同步代码执行结束, 主线程检查是否存在微任务, 发现 &lt;code&gt;then&lt;/code&gt;, 执行&lt;/li&gt;
&lt;li&gt;微任务执行完毕, 再去查找宏任务 &lt;code&gt;setTimeout&lt;/code&gt;, 执行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setTimeout&lt;/code&gt; 执行结束, 检查是否存在微任务, 不存在, 结束.&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;以上。&lt;/p&gt;

</description>
<pubDate>Thu, 13 Dec 2018 16:09:00 +0000</pubDate>
<dc:creator>薛小白</dc:creator>
<og:description>javascript的event loop事件循环 这是今天一个朋友发给我的一个面试题， 感觉还挺有意思的， 写个博客以供分享 先看看这个面试题目： 观察下面的代码，写出输出结果 输出结果： “0”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangyangxxb/p/10117063.html</dc:identifier>
</item>
<item>
<title>pom文件信息的解析 - 泽国江山入战图</title>
<link>http://www.cnblogs.com/code12306/p/10117261.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/code12306/p/10117261.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;project &lt;/span&gt;&lt;span&gt;xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;span&gt;
    xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;4.0.0&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;modelVersion&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-parent&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2.1.1.RELEASE&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;relativePath&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt; &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; lookup parent from repository &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;parent&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.forezp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello-world&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;0.0.1-SNAPSHOT&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jar&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;packaging&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;hello-world&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Demo project for Spring Boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;java.version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;properties&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;scope&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugin&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;plugins&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;build&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;


&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pom.xml文件的信息解析：&lt;/p&gt;
&lt;p&gt;1.第一行指定了xml的版本号和编码方式。&lt;/p&gt;
&lt;p&gt;2.project的标签是改文件的根元素，它声明pom相关的命名空间。&lt;/p&gt;
&lt;p&gt;3.modelVersion指定pom的版本。&lt;/p&gt;
&lt;p&gt;4.groupId代表了公司、组织的名称，一般为公司域名的倒写。&lt;/p&gt;
&lt;p&gt;5.artifactId代表了该项目的全局唯一Id。&lt;/p&gt;
&lt;p&gt;6.version代表了该项目的版本号。&lt;/p&gt;
&lt;p&gt;7.parent标签用于指定父pom。&lt;/p&gt;
&lt;p&gt;8.properties标签用于声明一些常量。&lt;/p&gt;
&lt;p&gt;9.dependencies标签为依赖的根元素，里面可以包含多个dependency元素。&lt;/p&gt;
&lt;p&gt;10.build为构建标签，它可以包含plugins（插件）标签，plugins标签中可以包含若干个plugin标签，可以根据项目的需求添加相应的plugin。&lt;/p&gt;

</description>
<pubDate>Thu, 13 Dec 2018 15:54:00 +0000</pubDate>
<dc:creator>泽国江山入战图</dc:creator>
<og:description>pom.xml文件的信息解析： 1.第一行指定了xml的版本号和编码方式。 2.project的标签是改文件的根元素，它声明pom相关的命名空间。 3.modelVersion指定pom的版本。 4.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/code12306/p/10117261.html</dc:identifier>
</item>
<item>
<title>MyBatis开发Dao层的两种方式（Mapper动态代理方式） - 谢亚峰</title>
<link>http://www.cnblogs.com/xyfer1018/p/10117227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xyfer1018/p/10117227.html</guid>
<description>&lt;p&gt;　　MyBatis开发原始Dao层请阅读我的上一篇博客：&lt;a title=&quot;MyBatis开发Dao层的两种方式（原始Dao层开发）&quot; href=&quot;https://www.cnblogs.com/xyfer1018/p/10111817.html%20&quot; target=&quot;_blank&quot;&gt;MyBatis开发Dao层的两种方式（原始Dao层开发）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　接上一篇博客继续介绍MyBatis开发Dao层的第二种方式：&lt;strong&gt;Mapper动态代理方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上一篇博客中Dao接口实现类方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　Mapper&lt;/strong&gt;&lt;strong&gt;接口开发需要遵循以下规范：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（1）Mapper.xml文件中的namespace与mapper接口的类路径相同。&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（2）Mapper接口方法名和Mapper.xml中定义的每个statement的id相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（3）Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（4）Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同&lt;/p&gt;
&lt;p&gt;　　1、定义mapper映射文件UserMapper.xml（内容同User.xml），需要修改namespace的值为 UserMapper接口路径。将UserMapper.xml放在classpath 下sqlmapperr目录下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;=&quot;com.xyfer.mapper.UserMapper&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 根据id查询用户 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;select &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;getUserById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;com.xyfer.po.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select * from user where id = #{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 添加用户 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;insert &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;insertUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.xyfer.po.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;selectKey &lt;/span&gt;&lt;span&gt;keyProperty&lt;/span&gt;&lt;span&gt;=&quot;id&quot;&lt;/span&gt;&lt;span&gt; order&lt;/span&gt;&lt;span&gt;=&quot;AFTER&quot;&lt;/span&gt;&lt;span&gt; resultType&lt;/span&gt;&lt;span&gt;=&quot;java.lang.Integer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        select LAST_INSERT_ID() 
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;selectKey&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
      insert into user(username,birthday,sex,address) 
      values(#{username},#{birthday},#{sex},#{address})
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 修改用户 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;update &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;updateUser&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;com.xyfer.po.User&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        update user set username=#{username},birthday=#{birthday},sex=#{sex},address=#{address}
        where id=#{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 删除用户 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;delete &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;deleteUserById&quot;&lt;/span&gt;&lt;span&gt; parameterType&lt;/span&gt;&lt;span&gt;=&quot;int&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
        delete from user where id=#{id}
    &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mapper&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、UserMapper.java接口文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer.mapper;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xyfer.po.User;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserMapper {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; User getUserById(&lt;span&gt;int&lt;/span&gt; id);   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据id值查询一个用户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; insertUser(User user); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;新增一个用户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; updateUser(User user); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;修改一个用户&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; deleteUser(&lt;span&gt;int&lt;/span&gt; id);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除一个用户&lt;/span&gt;
&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接口定义有如下特点：&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（1）UserMapper接口方法名和Mapper.xml中定义的statement的id相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（2）UserMapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　　　（3） UserMapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同&lt;/p&gt;
&lt;p class=&quot;1&quot;&gt;　　3、在SqlMapConfig.xml文件中加载UserMapper.xml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;mapper &lt;/span&gt;&lt;span&gt;resource&lt;/span&gt;&lt;span&gt;=&quot;UserMapper.xml&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;mappers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.xyfer.mapper;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; org.junit.Assert.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.InputStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.io.Resources;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSession;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactory;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.ibatis.session.SqlSessionFactoryBuilder;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Before;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.junit.Test;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.xyfer.po.User;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; junit.framework.TestCase;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserMapperTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TestCase{

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; SqlSessionFactory sqlSessionFactory;
    
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUp() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        SqlSessionFactoryBuilder sessionFactoryBuilder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SqlSessionFactoryBuilder();
        InputStream inputStream &lt;/span&gt;= Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;&lt;span&gt;);
        sqlSessionFactory &lt;/span&gt;=&lt;span&gt; sessionFactoryBuilder.build(inputStream);
    }


    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testGetUserById() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取sqlsession&lt;/span&gt;
        SqlSession sqlsession =&lt;span&gt; sqlSessionFactory.openSession();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserMapper接口代理对象&lt;/span&gt;
        UserMapper userMapper = sqlsession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理对象方法&lt;/span&gt;
        User user = userMapper.getUserById(10&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印结果&lt;/span&gt;
&lt;span&gt;        System.out.println(user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭sqlsession&lt;/span&gt;
&lt;span&gt;        sqlsession.close();
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testInsertUser() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取sqlsession&lt;/span&gt;
        SqlSession sqlsession =&lt;span&gt; sqlSessionFactory.openSession();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserMapper接口代理对象&lt;/span&gt;
        UserMapper userMapper = sqlsession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个对象&lt;/span&gt;
        User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setUsername(&lt;/span&gt;&quot;小谢&quot;&lt;span&gt;);
        user.setSex(&lt;/span&gt;&quot;男&quot;&lt;span&gt;);
        user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        user.setAddress(&lt;/span&gt;&quot;浙江省杭州市&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理对象方法&lt;/span&gt;
&lt;span&gt;        userMapper.insertUser(user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭sqlsession&lt;/span&gt;
&lt;span&gt;        sqlsession.close();
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testUpdateUser() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取sqlsession&lt;/span&gt;
        SqlSession sqlsession =&lt;span&gt; sqlSessionFactory.openSession();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserMapper接口代理对象&lt;/span&gt;
        UserMapper userMapper = sqlsession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建一个对象&lt;/span&gt;
        User user = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; User();
        user.setUsername(&lt;/span&gt;&quot;小谢&quot;&lt;span&gt;);
        user.setSex(&lt;/span&gt;&quot;男&quot;&lt;span&gt;);
        user.setBirthday(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date());
        user.setAddress(&lt;/span&gt;&quot;上海市&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理对象方法&lt;/span&gt;
&lt;span&gt;        userMapper.updateUser(user);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭sqlsession&lt;/span&gt;
&lt;span&gt;        sqlsession.close();
    }

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDeleteUser() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取sqlsession&lt;/span&gt;
        SqlSession sqlsession =&lt;span&gt; sqlSessionFactory.openSession();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取UserMapper接口代理对象&lt;/span&gt;
        UserMapper userMapper = sqlsession.getMapper(UserMapper.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用代理对象方法&lt;/span&gt;
        userMapper.deleteUser(6&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭sqlsession&lt;/span&gt;
&lt;span&gt;        sqlsession.close();
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上步骤，完成mybatis框架以&lt;strong&gt;Mapper动态代理方式&lt;/strong&gt;开发Dao层，并对数据库进行增删改查操作。&lt;/p&gt;
&lt;p&gt;　　需要注意的是，上文提到的config文件夹和sqlmapper文件夹均为资源文件夹（source folder），默认会加载该路径下的文件。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 15:43:00 +0000</pubDate>
<dc:creator>谢亚峰</dc:creator>
<og:description>MyBatis开发原始Dao层请阅读我的上一篇博客：MyBatis开发Dao层的两种方式（原始Dao层开发） 接上一篇博客继续介绍MyBatis开发Dao层的第二种方式：Mapper动态代理方式 Ma</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xyfer1018/p/10117227.html</dc:identifier>
</item>
<item>
<title>JavaScipt 中的事件循环机制，以及微任务 和宏任务的概念 - daisy,gogogo</title>
<link>http://www.cnblogs.com/daisygogogo/p/10116694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daisygogogo/p/10116694.html</guid>
<description>&lt;p&gt;说事件循环（event loop）之前先要搞清楚几个问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. js为什么是单线程的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　试想一下，如果js不是单线程的，同时有两个方法作用dom，一个删除，一个修改，那么这时候浏览器该听谁的？这就是js被设计成单线程的原因。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.js为什么需要异步？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果js不是异步的话，由于js代码本身是自上而下执行的，那么如果上一行代码需要执行很久，下面的代码就会被阻塞，对用户来说，就是”卡死”，这样的话，会造成很差的用户体验。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3.js是如何实现异步的？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　既然js是单线程的，那么js是如何实现异步的呢，是通过事件循环（event loop），理解了event loop 就理解了js的执行机制。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4.浏览器中的多线程？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　js是单线程的，但是浏览器是多线程的，多个线程相互配合以保持同步，浏览器下的常驻线程有&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;js线程&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;GUI&lt;span&gt;渲染线程，（它与javaScript线程是互斥的）&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;事件线程(onclick,onchange,…)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;定时器线程(setTimeout, setInterval)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;异步http线程(ajax)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;5. javaScript 的事件循环（&lt;span&gt;event loop&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;既然js是单线程的，那么所有的任务就需要排队执行。&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;javaScript 中的任务可以被划分为&lt;strong&gt;宏任务（Macrotask）&lt;/strong&gt;或者&lt;strong&gt;微任务（Microtask）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;像鼠标事件，键盘事件,&quot;ajax&quot;,&quot;setTimeout&quot;等就属于宏任务，需要注意的是，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;主线程的整体代码(script标签)，也是一个宏任务&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;process.nextTick，&lt;span&gt;PromiseA.then()， &lt;span&gt;MutaionObserver 就属于微任务&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;简单概括一下事件循环，就是&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;p&gt;1.执行宏任务队列中第一个任务，执行完后移除它&lt;/p&gt;
&lt;p&gt;2.执行所有的微任务，执行完后移除它们&lt;/p&gt;
&lt;p&gt;3.执行下一轮宏任务（重复步骤2）&lt;/p&gt;
&lt;p&gt;如此循环就形成了event loop，其中，每轮执行&lt;span&gt;一个宏任务&lt;/span&gt;和&lt;span&gt;所有的微任务&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;下图很形象的描述了event loop&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312697/201812/1312697-20181213220454860-1986292692.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;下面我通过分析一个示例来说一下：&lt;/p&gt;
&lt;div readability=&quot;64&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
console.log(1&lt;span&gt;);

setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;2&lt;span&gt;)
},&lt;/span&gt;10&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve){
    console.log(&lt;/span&gt;3&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i=100000 ; i&amp;gt;0 ; i--&lt;span&gt; ){
        i&lt;/span&gt;==1 &amp;amp;&amp;amp;&lt;span&gt; resolve()
    }
    console.log(&lt;/span&gt;4&lt;span&gt;)
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;5&lt;span&gt;)
})&lt;span&gt;.then(&lt;span&gt;function&lt;span&gt;(){ &lt;br/&gt;console.log(6&lt;span&gt;) &lt;br/&gt;})&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;

console.log(&lt;/span&gt;7);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印出来的结果是：1 3 4 7 5 6 2&lt;/p&gt;
&lt;p&gt;我们分析一下整个过程&lt;/p&gt;
&lt;p&gt;1. 首先执行主线程这个宏任务，从上到下执行，遇到console.log(1&lt;span&gt;); 打印1出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 遇到setTimeout，把它丢给定时器线程处理，&lt;span&gt;然后继续往下执行&lt;/span&gt;，并不会阻塞10毫秒，而此处定时器线程会在，&lt;strong&gt;主线程执行完后的10毫秒&lt;/strong&gt;，把回调函数放入&lt;strong&gt;宏任务队列&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 遇到&lt;span&gt;new Promise&lt;/span&gt;，直接执行，先打印 ‘3‘ 出来，然后执行for循环，达到条件之后，把promise的状态改为resolved，继续执行打印 ‘4’ 出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.遇到promise的then， 属于微任务，则把回调函数放入微任务队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.又&lt;span&gt;遇到promise的then， 属于微任务，则把回调函数放入微任务队列&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;6. 遇到&lt;span&gt;console.log(7) 打印 ‘7’ 出来&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;7. 宏任务执行完后会执行所有待执行的微任务，所以会相继打印 ‘6’， ‘7’ 出来。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;至此第一轮循环已经结束了，第一轮循环里的宏任务和微任务都会被移除出任务队列，接下来开启第二轮循环，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1.首先查找是否有宏任务，由于setTimeout 的回调被放入了宏任务队列，这里会执行回调函数的代码，打印了 ‘2’ 出来&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;2. 接着查找是否有微任务，发现没有微任务，则本轮循环结束&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;接下来会重复上面的步骤，整个过程就是 event loop 了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;6. 扩展题目&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的题目扩展一下，大家看一下打印出来的结果是什么？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
console.log(1&lt;span&gt;);

setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve){
    console.log(&lt;/span&gt;'promise in setTimeout1'&lt;span&gt;);
    resolve();
    }).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
        console.log(&lt;/span&gt;'then in setTimeout1'&lt;span&gt;);
    })
},&lt;/span&gt;10&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve){
    console.log(&lt;/span&gt;3&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;( &lt;span&gt;var&lt;/span&gt; i=100000 ; i&amp;gt;0 ; i--&lt;span&gt; ){
        i&lt;/span&gt;==1 &amp;amp;&amp;amp;&lt;span&gt; resolve();
    }
    console.log(&lt;/span&gt;4&lt;span&gt;)
}).then(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;5&lt;span&gt;);
});

setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
    console.log(&lt;/span&gt;'setTimeout2'&lt;span&gt;);
},&lt;/span&gt;10&lt;span&gt;);

console.log(&lt;/span&gt;7);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1312697/201812/1312697-20181213225633417-1595552298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，第二个setTimeout 的回调函数，执行的比第一个setTimeout里面的promise.then()的回调要晚，这是因为每次循环只执行一个宏任务，但是却会执行所有待执行的微任务，而第二个setTimeout在宏任务队列的位置在第一个setTimeout后面。&lt;/p&gt;

&lt;p&gt;这个就是我理解的JavaScipt 事件循环机制，参考了很多文章，也自己做了很多思考写出来的，码字不易，觉得有帮助可以点个赞哦。也欢迎留言交流&lt;/p&gt;
&lt;p&gt;参考文章&lt;/p&gt;
&lt;p&gt;https://segmentfault.com/a/1190000012806637?utm_source=tag-newest&lt;/p&gt;
&lt;p&gt;http://www.ruanyifeng.com/blog/2014/10/event-loop.html&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/33127885&lt;/p&gt;
&lt;p&gt;https://zhuanlan.zhihu.com/p/33136054&lt;/p&gt;
&lt;p&gt;https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context&lt;/p&gt;

&lt;/div&gt;


</description>
<pubDate>Thu, 13 Dec 2018 15:05:00 +0000</pubDate>
<dc:creator>daisy,gogogo</dc:creator>
<og:description>说事件循环（event loop）之前先要搞清楚几个问题。 1. js为什么是单线程的？ 试想一下，如果js不是单线程的，同时有两个方法作用dom，一个删除，一个修改，那么这时候浏览器该听谁的？这就是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/daisygogogo/p/10116694.html</dc:identifier>
</item>
<item>
<title>单页面应用在微信服务号下的登录流程 - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/10116017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/10116017.html</guid>
<description>&lt;p&gt;最近我们的小程序涉及到虚拟支付的问题，在ios端的支付被封掉了😇，所以有了在服务号上搞一套H5版的小程序的需求。由于我们小程序是mpvue写的，为了尽量复用之前的样式和逻辑，选择了前后端分离的模式，于是一段新的踩坑之旅开始了。放下wx的jssdk暂且不表，今天来说说登录时遇到的坑。&lt;/p&gt;
&lt;h3 id=&quot;服务号的登录流程&quot;&gt;服务号的登录流程&lt;/h3&gt;
&lt;p&gt;以前搞过服务号的同学对于它的登录流程应该不陌生，就是当后端检测到当前用户没有授权时，将会重定向到微信的授权页面，当用户点击这个授权的button时，微信会根据Url查询字符串中的重定向URL，重新回到我们的页面。&lt;/p&gt;
&lt;p&gt;下面3幅图展示了整个过程:&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当我们的服务器发现用户没有授权，返回&lt;code&gt;302&lt;/code&gt;状态码，以及微信的授权页面location&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201812/1016471-20181213224427706-1929619708.png&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用户在该页面点击确认登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201812/1016471-20181213194530805-1260660333.png&quot; alt=&quot;uploading-image-28683.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;微信服务器根据location里的redirectURL，返回&lt;code&gt;301&lt;/code&gt;code，重定向回来&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201812/1016471-20181213194940834-1542448116.png&quot; alt=&quot;2.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面三步，经历了两次重定向，第一次从自己的服务器重定向到微信的服务器，微信展示授权页面。第二次重定向是当用户点击之后，微信会带一个code重定向回来，当服务器拿到这个code之后，经历一波获取openId的操作之后，生成一个session，这样用户以后访问时就不需要再次登录。&lt;/p&gt;
&lt;p&gt;这样的模式在传统的前后端不分离，基于模板的情况下，是没有问题的，因为没有json的返回，后端进行逻辑处理后，渲染出html。但是在单页面的情况下，如果思路跑偏会出现一堆问题。&lt;/p&gt;
&lt;h3 id=&quot;单页面遇到的问题&quot;&gt;单页面遇到的问题&lt;/h3&gt;
&lt;p&gt;上面说的思路跑偏是什么意思呢？就是当用户进来时，先将单页面的&lt;code&gt;index.html&lt;/code&gt;发给浏览器。当浏览器执行开始js脚本（app.js）时，就会向服务器发送请求。&lt;/p&gt;
&lt;p&gt;此时如果是一个新用户在访问，由于没有登录，服务器会返回一个302的重定向状态码，然而这次请求是通过ajax发起的。浏览器不会自动重定向到授权页面，导致请求失败。&lt;/p&gt;
&lt;p&gt;此时你会想，浏览器不会重定向，我可以当请求失败时通过设置&lt;code&gt;window.location&lt;/code&gt;自己重定向到微信授权页面，这样解决了第一步的重定向问题，然后当用户点击确定登录时，马上又面临第二个重定向的问题--重定向到哪里。&lt;/p&gt;
&lt;p&gt;由于微信重定向的url是带着code返回的，重定向的Url肯定不能是一个静态页面的Url，必须是一个api，假设还是login。后端在请求中拿到code之后，生成一个新的session，再将原先的html再次返回给浏览器，并带上&lt;code&gt;set-cookie&lt;/code&gt;字段，此后浏览器会带着cookie请求，登录至此完成。&lt;/p&gt;
&lt;p&gt;这样做ok，当时却留下一个很恐怖的URL：&lt;code&gt;https://example.com/login?code=001QLbSQ0Ujc162Sp5UQ0IG6SQ0QLbSD&lt;/code&gt;，此后前端路由开始work，就在前面的基础上加上一个&lt;code&gt;#&lt;/code&gt;号，如果你的业务还涉及支付，那就完蛋了，因为支付需要配置的url应该是稳定的而code这个查询参数是动态变的。&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;我画了一张图解释了重新设计的登录流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1016471/201812/1016471-20181213192838716-507236655.png&quot; alt=&quot;uploading-image-511687.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个新的流程中，当新用户第一次发起请求（login）时，不会返html给浏览器，只会进行重定向：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果用户未登录，重定向到微信的授权页，并设置redirect url，使用户点击授权后可以重定向回来&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;新用户重定向回来之后，login api拿到code，经过生成session操作后，再次重定向到&lt;code&gt;home&lt;/code&gt;url下&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果是老用户，直接重定向到&lt;code&gt;home&lt;/code&gt;url下&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;此时由于访问&lt;code&gt;home&lt;/code&gt;的用户都是已登录状态，api统一返回index.html,所以最终用户看到的是&lt;code&gt;https://example.com/home&lt;/code&gt;下的页面，后面的单页面路由会在这个url下展开。（虽然对服务号用户来说可能没什么区别）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结一下这么做的好处：&lt;/p&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;少传输一次html页面，第一种方式一开始就给未登录的用户传html是没用的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;美观的url（用户感知不到）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;前端无需手动重定向，后端将显示页面和登录逻辑放到两个api中，逻辑更清晰&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;了解到&lt;code&gt;3xx&lt;/code&gt;状态码的博大精深，尽管对普通用户感知不深，没有&lt;code&gt;2xx&lt;/code&gt;受群众欢迎，也没有&lt;code&gt;404&lt;/code&gt;,&lt;code&gt;500&lt;/code&gt;知名度高，属于默默无闻型的。但是在互联网世界里却扮演着重要的角色。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 14:47:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<og:description>最近我们的小程序涉及到虚拟支付的问题，在ios端的支付被封掉了😇，所以有了在服务号上搞一套H5版的小程序的需求。由于我们小程序是mpvue写的，为了尽量复用之前的样式和逻辑，选择了前后端分离的模式，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/10116017.html</dc:identifier>
</item>
<item>
<title>JaveScript 中使用 XSLT转换XML文档 - 西秀岭</title>
<link>http://www.cnblogs.com/xixiuling/p/10116108.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xixiuling/p/10116108.html</guid>
<description>&lt;p&gt;我们经常将数据存储在XML 中，在展示的时候需要转换为其它的形式，这里介绍使用XSLT 对XML数据进行转换。&lt;/p&gt;
&lt;p&gt;要学习XSLT对XML的转换，需要先了解三个文件。&lt;/p&gt;
&lt;p&gt;第一个是存储数据的XML文件:employees.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;employees&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;employee &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Software Engineer&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Nicholas C. Zakas&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;employee&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;employee &lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;=&quot;Salesperson&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Jim Smith&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;employee&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;employees&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第二个是存储XSLT的文件：employees.xslt&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:stylesheet &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsl&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/XSL/Transform&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:output &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;html&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
    
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:apply-templates &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;employee&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;@title&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:stylesheet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第三个是我们进行转换的代码example.htm：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;!&lt;/span&gt;&lt;span&gt;DOCTYPE html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;XSLTProcessor Example&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;   
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;=&quot;text/javascript&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        window.onload &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;use XHR to load&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; xmlhttp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            xmlhttp.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;employees.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            xmlhttp.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; xmldom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xmlhttp.responseXML;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            xmlhttp &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;            xmlhttp.open(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;employees.xslt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            xmlhttp.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; xsltdom &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xmlhttp.responseXML;  
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; processor &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XSLTProcessor();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            processor.importStylesheet(xsltdom);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; result &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; processor.transformToDocument(xmldom);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; div &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; document.getElementById(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;divResult&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             
&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt;&lt;span&gt; xml &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLSerializer()).serializeToString(result);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            alert(xml);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            div.innerHTML &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; xml;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;           
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;This example loads employees.xml and transforms it using employees.xslt. 
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     The resulting code is then displayed.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;=&quot;divResult&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里我们通过 XSLTProcessor 类型使用XSLT转换XML文档，第一步加载两个DOM文档，一个基于XML,另一个基于XSLT,下面的代码在Edge 中可以顺利执行，在Chrome中，因为禁止从本地装载文件随意会会失败，如果从网络服务器上读取数据则没有问题。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;use XHR to load&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; xmlhttp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
xmlhttp.open(&lt;/span&gt;&quot;get&quot;, &quot;employees.xml&quot;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
xmlhttp.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xmldom =&lt;span&gt; xmlhttp.responseXML;
            
xmlhttp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XMLHttpRequest();
xmlhttp.open(&lt;/span&gt;&quot;get&quot;, &quot;employees.xslt&quot;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
xmlhttp.send(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; xsltdom = xmlhttp.responseXML;  
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后创建一个新XSLTProcessor对象，并使用importStylesheet()方法为其指定一个XSLT&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; processor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XSLTProcessor();
processor.importStylesheet(xsltdom);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 最后一步是执行转换，这一步有两种不同的方式，如果想返回一个完整的DOM文档，可以调用transformToDocument().而通过调用transforToFragment()则可以得到一个文档片段对象。一般来说。使用transformToFragment()的唯一理由，就是你想把返回的结果添加到另一个DOM文档中。&lt;/p&gt;
&lt;p&gt;在使用transforToDocument()时，只要传入XML DOM,就可以将结果作为一个完全不同的DOM文档来使用。来看例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; result = processor.transformToDocument(xmldom);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们将result 结果进行序列化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; xml = (&lt;span&gt;new&lt;/span&gt; XMLSerializer()).serializeToString(result);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来看转换后的结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Nicholas C. Zakas, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Software Engineer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Jim Smith, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Salesperson&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们来看一下XSLT中的定义:&lt;/p&gt;
&lt;p&gt;下面的这段代码会让我们将所有的内容都放到&amp;lt;ul&amp;gt;&amp;lt;/ul&amp;gt;之中，之所以会这样是因为我们的选择符指定了全部 select=&quot;*&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:apply-templates &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面这段代码的含义是对 employee 元素进行转换 match=&quot;employee&quot;&lt;/p&gt;
&lt;p&gt;将name 元素放到&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;中  select=&quot;name&quot;&lt;/p&gt;
&lt;p&gt;将title 属性提取出来放到&amp;lt;em&amp;gt;&amp;lt;/em&amp;gt;中  select=&quot;@title&quot;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;employee&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;@title&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;而transformToFragment()方法接收两个参数：要转换的XML DOM 和应该拥有结果片段的文档。换句话说，如果你想将返回的片段插入到页面中，只要将document作为第二个参数即可。&lt;/p&gt;
&lt;p&gt;我们只需要将example.htm中 23 - 28 行代码替换成下面代码就可以了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var fragment = processor.transformToFragment(xmldom, document);
var div = document.getElementById(&quot;divResult&quot;);
            
div.appendChild(fragment);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，处理器创建了一个有document对象拥有的片段。这样，就可以将返回的片段添加到页面中已有的&amp;lt;div&amp;gt;元素中了。&lt;/p&gt;
&lt;p&gt;在XSLT样式表的输出格式为&quot;xml&quot;,&quot;html&quot;的情况下，创建文档或文档片段会非常有用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.使用参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;XSLTProcessor 也支持使用 setParameter()来设置XSLT的参数，这个方法接收三个参数：命名空间URI，参数的内部名称和要设置的值。通常，命名空间URI都是null,而内部名称就是参数的名称。另外必须在调用transformToDocument()或transformToFragment()之前调用这个方法。来看例子&lt;/p&gt;
&lt;p&gt;我们先看XSLT文件 employees2.xslt：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:stylesheet &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;1.0&quot;&lt;/span&gt;&lt;span&gt; xmlns:xsl&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/1999/XSL/Transform&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:output &lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;=&quot;html&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:param &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;message&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
        
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;/&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:apply-templates &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;*&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ul&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Message: &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;$message&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:template &lt;/span&gt;&lt;span&gt;match&lt;/span&gt;&lt;span&gt;=&quot;employee&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;, &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xsl:value-of &lt;/span&gt;&lt;span&gt;select&lt;/span&gt;&lt;span&gt;=&quot;@title&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;em&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;li&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:template&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xsl:stylesheet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对 example.htm的修改&lt;/p&gt;
&lt;p&gt;第16行替换为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
xmlhttp.open(&quot;get&quot;, &quot;employees2.xslt&quot;, false);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第23 - 28替换为下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
processor.setParameter(&lt;span&gt;null&lt;/span&gt;, &quot;message&quot;, &quot;Hello World!&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fragment =&lt;span&gt; processor.transformToFragment(xmldom, document);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; div = document.getElementById(&quot;divResult&quot;&lt;span&gt;);
            
div.appendChild(fragment);            &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看运行后的结果：通过转换将模板中的 &lt;span&gt;&lt;span&gt;$message&lt;/span&gt;&lt;span&gt;变量替换成了我们传入的参数&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;div id=&quot;divResult&quot;&amp;gt;&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Nicholas C. Zakas, &amp;lt;em&amp;gt;Software Engineer&amp;lt;/em&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Jim Smith, &amp;lt;em&amp;gt;Salesperson&amp;lt;/em&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;p&amp;gt;Message: Hello World!&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有两个与参数有关的方法，getParamenter()和removeParamenter(),分别用于取得和一处当前参数的值。这两个方法都要接受命名空间参数和参数内部i名称。例如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;var&lt;/span&gt; processor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XSLTProcessor();
processor.importStylesheet(xsltdom);
processor.setParameter(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;, &quot;message&quot;, &quot;Hello World!&quot;&lt;span&gt;);
&lt;br/&gt;alert(processor.getParaeter(null,&quot;message&quot;));     //输出 “Hello World!&quot;&lt;br/&gt;processor.removeParameter(null,&quot;message&quot;);&lt;br/&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; fragment = processor.transformToFragment(xmldom, document);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两个方法并不常用。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2.重置处理器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每个XSLTProcessor 的实例都可以重用，以便使用不同的XSLT样式表执行不同的转换。重置处理器时要调用reset()方法，这个方法会从处理器中移除所有的参数和样式表。然后，你就可以再次调用importStylesheet(),以加载不同的XSLT样式表，如下面的例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span readability=&quot;1&quot;&gt;&lt;span&gt;var&lt;/span&gt; processor = &lt;span&gt;new&lt;/span&gt;&lt;span readability=&quot;2&quot;&gt; XSLTProcessor();
processor.importStylesheet(xsltdom);&lt;p&gt;//执行转换&lt;/p&gt;&lt;p&gt;processor.reset();&lt;br/&gt;processor.importStylesheet(xsltdom2);&lt;/p&gt;&lt;p&gt;//在执行转换&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在需要基于多个样式表进行转换时，重用一个XSLTProcessor可以节省内存。&lt;/p&gt;

</description>
<pubDate>Thu, 13 Dec 2018 14:47:00 +0000</pubDate>
<dc:creator>西秀岭</dc:creator>
<og:description>我们经常将数据存储在XML 中，在展示的时候需要转换为其它的形式，这里介绍使用XSLT 对XML数据进行转换。 要学习XSLT对XML的转换，需要先了解三个文件。 第一个是存储数据的XML文件:emp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xixiuling/p/10116108.html</dc:identifier>
</item>
<item>
<title>Python异常处理详解 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10116936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10116936.html</guid>
<description>&lt;h2 id=&quot;入门示例&quot;&gt;入门示例&lt;/h2&gt;
&lt;h3 id=&quot;异常处理tryexcept&quot;&gt;异常处理：try/except&lt;/h3&gt;
&lt;p&gt;对于索引查找的操作，在索引越界搜索的时候会报错。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; s=&quot;long&quot;
&amp;gt;&amp;gt;&amp;gt; s[4]
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
IndexError: string index out of range&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所报的错误是IndexError。如果将索引查找放在一个函数里：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; def fetcher(obj,index):
...     return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么调用函数的时候，如果里面的索引越界了，异常将汇报到函数调用者。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; fetcher(s,3)
'g'

&amp;gt;&amp;gt;&amp;gt; fetcher(s,4)
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 2, in fetcher
IndexError: string index out of range&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用try/except来捕获异常。作为入门示例，下面是简单版的格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    statement1
    ...
    statementN
except &amp;lt;ERRORTYPE&amp;gt;:
    ...statementS...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，try中是要监视正确执行与否的语句，ERRORTYPE是要监视的错误类型。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只要try中的任何一条语句抛出了错误，try中该异常语句后面的语句都不会再执行；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果抛出的错误正好是except所监视的错误类型，就会执行statementS部分的语句；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果异常正好被except捕获(匹配)到了，程序在执行完statementS后会继续执行下去，如果没有捕获到，程序将终止；
&lt;ul&gt;&lt;li&gt;换句话说，except捕获到错误后，相当于处理了这个错误，程序不会因为已经被处理过的错误而停止&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如捕获上面的函数调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj, index):
    return obj[index]

s = &quot;long&quot;
try:
    print(fetcher(s, 3) * 4)
    print(fetcher(s, 4) * 4)
except IndexError:
    print(&quot;something wrong&quot;)

print(&quot;after Exception, Continue&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gggg
something wrong
after Exception, Continue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为上面的&lt;code&gt;fetcher(s, 4)&lt;/code&gt;会抛出异常，且正好匹配except监视的异常类型，所以输出&lt;code&gt;something wrong&lt;/code&gt;，异常被处理之后，程序继续执行，即try/except后面的print()。&lt;/p&gt;
&lt;h3 id=&quot;异常处理tryfinally&quot;&gt;异常处理：try/finally&lt;/h3&gt;
&lt;p&gt;finally是try之后一定会执行的语句段落。可以结合except一起使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    statement1
    ...
    statementN
finally:
    ...statementF...&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;try:
    statement1
    ...
    statementN
except &amp;lt;ERRORTYPE&amp;gt;:
    ...statementS...
finally:
    ...statementF...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不论try中的语句是否出现异常，不论except是否捕获到对应的异常，finally都会执行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果异常没有被捕获，则在执行finally之后程序退出&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;如果异常被except捕获，则执行完except的语句之后执行finally的语句，然后程序继续运行下去&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般来说，finally中都会用来做程序善后清理工作。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj, index):
    return obj[index]

s = &quot;long&quot;
try:
    print(fetcher(s, 3) * 4)
    print(fetcher(s, 4) * 4)
except IndexError:
    print(&quot;something wrong&quot;)
finally:
    print(&quot;in finally&quot;)

print(&quot;after Exception, Continue&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gggg
something wrong
in finally
after Exception, Continue&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果把except那段代码删掉，得到的结果将是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gggg
in finally      # 输出了finally的内容
Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 8, in &amp;lt;module&amp;gt;
    print(fetcher(s, 4) * 4)
  File &quot;g:/pycode/list.py&quot;, line 2, in fetcher
    return obj[index]
IndexError: string index out of range&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;产生异常raise和assert&quot;&gt;产生异常：raise和assert&lt;/h3&gt;
&lt;p&gt;使用raise或assert可以主动生成异常情况。其中raise可以直接抛出某个异常，assert需要通过布尔值来判断，然后再抛出给定的错误。&lt;/p&gt;
&lt;p&gt;例如，在函数里做个没什么用的的判断，用来演示raise：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj, index):
    if index &amp;gt;= len(obj):
        raise IndexError
    return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这和直接索引越界是以一样的。上面raise抛出的异常IndexError是一个内置异常，可以直接引用这些内置异常。稍后会演示如何自定义自己的异常。&lt;/p&gt;
&lt;p&gt;抛出异常后，就可以按照前面介绍的try来处理异常。&lt;/p&gt;
&lt;p&gt;assert是一种断言，在计算机语言中表示：如果断言条件为真就跳过，如果为假就抛出异常信息。它可以自定义异常信息。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj, index):
    assert index &amp;lt; len(obj),  &quot;one exception&quot;
    return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很多时候会直接在assert中使用False、True的布尔值进行程序的调试。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;assert True, &quot;assert not hit&quot;
assert False, &quot;assert hit&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义异常&quot;&gt;自定义异常&lt;/h3&gt;
&lt;p&gt;python中的异常是通过类来定义的，而且所有的异常类都继承自Exception类，而Exception又继承自BaseException(这个类不能直接作为其它异常类的父类)。所以自定义异常的时候，也要继承Exception，当然，继承某个中间异常类也可以。&lt;/p&gt;
&lt;p&gt;例如，定义索引越界的异常类，注意这个类中直接pass，但因为继承了Exception，它仍然会有异常信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyIndexError(Exception):
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，判断字母是否是大写，如果是，就抛异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def fetcher(obj,index):
    if index &amp;gt;= len(obj):
        raise MyIndexError
    return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s = &quot;long&quot;

print(fetcher(s, 3) * 4)
print(fetcher(s, 4) * 4)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;gggg
Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 12, in &amp;lt;module&amp;gt;
    print(fetcher(s, 4) * 4)
  File &quot;g:/pycode/list.py&quot;, line 6, in fetcher
    raise MyIndexError
__main__.MyIndexError&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意，因为异常类都继承字Exception，except监视Exception异常的时候，也会匹配其它的异常。更标准地说，&lt;strong&gt;监视异常父类，也会捕获到这个类的子类异常&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;如何看抛出的异常&quot;&gt;如何看抛出的异常&lt;/h3&gt;
&lt;p&gt;看异常信息是最基本的能力。例如，下面的这段代码会报除0错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def a(x, y):
    return x/y

def b(x):
    print(a(x, 0))

b(1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行时，报错信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 7, in &amp;lt;module&amp;gt;
    b(1)
  File &quot;g:/pycode/list.py&quot;, line 5, in b
    print(a(x, 0))
  File &quot;g:/pycode/list.py&quot;, line 2, in a
    return x/y
ZeroDivisionError: division by zero&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个堆栈跟踪信息中已经明确说明了&lt;code&gt;(most recent call last)&lt;/code&gt;，说明最近产生异常的调用在最上面，也就是第7行。上面的整个过程是这样的：第7行出错，它是因为第5行的代码引起的，而第5行之所以错是第2行的源代码引起的。&lt;/p&gt;
&lt;p&gt;所以，从最底部可以看到最终是因为什么而抛出异常，从最顶部可以看到是执行到哪一句出错。&lt;/p&gt;
&lt;h2 id=&quot;深入异常处理&quot;&gt;深入异常处理&lt;/h2&gt;
&lt;h3 id=&quot;tryexceptelsefinally&quot;&gt;try/except/else/finally&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;try:
    &amp;lt;statements&amp;gt;
except &amp;lt;name1&amp;gt;:           # 捕获到名为name1的异常
    &amp;lt;statements&amp;gt;
except (name2, name3):    # 捕获到name2或name3任一异常
    &amp;lt;statements&amp;gt;
except &amp;lt;name4&amp;gt; as &amp;lt;data&amp;gt;: # 捕获name4异常，并获取异常的示例
    &amp;lt;statements&amp;gt;
except:                   # 以上异常都不匹配时
    &amp;lt;statements&amp;gt;
else:                     # 没有产生异常时
    &amp;lt;statements&amp;gt;
finally:                  # 一定会执行的
    &amp;lt;statements&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，当抛出的异常无法被匹配时，将归类于空的&lt;code&gt;except:&lt;/code&gt;，但这是很危险的行为，因为很多时候的异常是必然的，比如某些退出操作、内存不足、Ctrl+C等等，而这些都会被捕获。与之大致等价的是捕获异常类的&quot;伪&quot;祖先类&lt;code&gt;Exception&lt;/code&gt;，即&lt;code&gt;except Exception:&lt;/code&gt;，它和空异常匹配类似，但能解决不少不应该匹配的异常。但使用Exception依然是危险的，能不用尽量不用。&lt;/p&gt;
&lt;p&gt;如果一个异常既能被name1匹配，又能被name2匹配，则先匹配到的处理这个异常。&lt;/p&gt;
&lt;p&gt;通过as关键字可以将except捕获到的异常对象赋值给data变量。用法稍后会解释，现在需要知道的是，在python 3.x中，&lt;strong&gt;变量data只在当前的except块范围内有效，出了范围就会被回收&lt;/strong&gt;。如果想要保留异常对象，可以将data赋值给一个变量。例如下面的b在出了try范围都有效，但是a在这个except之后就无效了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;except Exception as a:
    print(a)
    b=a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过else分句可以知道，这段try代码中没有出现任何异常。否则就不会执行到else分句。&lt;/p&gt;
&lt;h3 id=&quot;raise&quot;&gt;raise&lt;/h3&gt;
&lt;p&gt;raise用于手动触发一个异常。而每一种异常都是一个异常类，所以触发实际上是触发一个异常类的实例对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;raise &amp;lt;instance&amp;gt;  # 直接触发一个异常类的对象
raise &amp;lt;class&amp;gt;     # 构建此处所给类的一个异常对象并触发
raise             # 触发最近触发的异常
raise &amp;lt;2&amp;gt; from &amp;lt;1&amp;gt;  # 将&amp;lt;1&amp;gt;的异常附加在&amp;lt;2&amp;gt;上&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中第二种形式，raise会根据给定类不传递任何参数地自动构建一个异常对象，并触发这个异常对象。第三种直接触发最近触发的异常对象，这在传播异常的时候很有用。&lt;/p&gt;
&lt;p&gt;例如，下面两种方式实际上是等价的，只不过第一种方式传递的是类，raise会隐式地自动创建这个异常类的实例对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;raise IndexError
raise IndexError()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以为异常类构建实例时指定点参数信息，这些参数会保存到名为args的元组。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    raise IndexError(&quot;something wrong&quot;)
except Exception as E:
    print(E.args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;('something wrong',)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不仅如此，只要是异常类或异常对象，不管它们的存在形式如何，都可以放在raise中。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;err = IndexErro()
raise err

errs = [IndexError, TypeError]
raise errs[0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于第三种raise形式，它主要用来传播异常，一般用在except代码段中。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    raise IndexError(&quot;aaaaa&quot;)
except IndexError:
    print(&quot;something wrong&quot;)
    raise&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为异常被except捕获后，就表示这个异常已经处理过了，程序会跳转到finally或整个try块的尾部继续执行下去。但是如果不想让程序继续执行，而是仅仅只是想知道发生了这个异常，并做一番处理，然后继续向上触发异常。这就是异常传播。&lt;/p&gt;
&lt;p&gt;因为实际触发的异常都是类的实例对象，所以它有属性。而且，可以通过在except中使用as来将对象赋值给变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as a:
    print(a)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量a在出了except的范围就失效，所以可以将它保留给一个不会失效的变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as a:
    print(a)
    b=a

print(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在一个except中触发了另一个异常，会造成&lt;strong&gt;异常链&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as E:
    raise TypeError('Bad')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将会报告两个异常，并提示处理异常E的时候，触发了另一个异常TypeError。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 2, in &amp;lt;module&amp;gt;
    1/0
ZeroDivisionError: division by zero

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 4, in &amp;lt;module&amp;gt;
    raise TypeError('Bad')
TypeError: Bad&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用from关键字，可以让关系更加明确。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as E:
    raise TypeError('Bad') from E&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是错误报告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 2, in &amp;lt;module&amp;gt;
    1/0
ZeroDivisionError: division by zero

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 4, in &amp;lt;module&amp;gt;
    raise TypeError('Bad') from E
TypeError: Bad&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，使用from关键字的时候，会将E的异常对象附加到TypeError的&lt;code&gt;__cause__&lt;/code&gt;属性上。&lt;/p&gt;
&lt;p&gt;但无论如何，这里都触发了多个异常。在python 3.3版本，可以使用&lt;code&gt;from None&lt;/code&gt;的方式来掩盖异常的来源，也就是禁止输出异常E，停止异常链：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    1/0
except Exception as E:
    raise TypeError('Bad') from None&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误报告如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Traceback (most recent call last):
  File &quot;g:/pycode/list.py&quot;, line 4, in &amp;lt;module&amp;gt;
    raise TypeError('Bad') from None
TypeError: Bad&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，异常信息中少了很多内容。&lt;/p&gt;
&lt;h3 id=&quot;assert&quot;&gt;assert&lt;/h3&gt;
&lt;p&gt;assert断言常用于调试。用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;assert test, data&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它实际上等价于是条件判断的raise。它等价于下面的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if __debug__:
    if not test:
        raise AssertionError(data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果条件test的测试为真，就跳过，否则就抛出异常。这个异常是通过AssertionError类构造的，构造异常对象的参数是data。data会放进名为args的元组属性中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    assert False,&quot;something wrong&quot;
except Exception as E:
    print(E.args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，assert产生的是名为AssertionError的异常，如果不捕获这个AssertionError异常，程序将会终止。&lt;/p&gt;
&lt;p&gt;除了调试，assert还偶尔用来判断必要的条件，不满足条件就异常，以便让程序更加健壮。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(x):
    assert x &amp;gt;= 0, &quot;x must great or equal than 0&quot;
    return x ** 2

print(f(2))
print(f(0))
print(f(-2))   # 触发AssertionError异常&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，写assert的测试条件时，测试结果为假才触发异常。所以，应该以if not true的角度去考虑条件，或者以unless的角度考虑。或者说，后面触发的异常信息，和测试条件应该是正相关的，例如示例中异常信息的说法是x必须大于等于0，和测试条件&lt;code&gt;x &amp;gt;= 0&lt;/code&gt;是正相关的。&lt;/p&gt;
&lt;p&gt;assert还常用于父类方法的某些方法中，这些方法要求子类必须重写父类的方法。于是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls:
    ...
    def f(self):
        assert False, &quot;you must override method: f&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，assert不应该用来触发那些python早已经定义好的异常。例如索引越界、类型错误等等。这些python已经定义好的异常，我们再去用AssertionError触发，这是完全多余的。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def f(obj,index):
    assert index &amp;gt; len(obj), &quot;IndexError&quot;
    return obj[index]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sys.exc_info&quot;&gt;sys.exc_info()&lt;/h2&gt;
&lt;p&gt;该函数用来收集正在处理的异常的信息。&lt;/p&gt;
&lt;p&gt;它返回一个包含3个值的元组&lt;code&gt;(type, value, traceback)&lt;/code&gt;，它们是当前正在处理的异常的信息。如果没有正在处理的异常，则返回3个None组成的元组。&lt;/p&gt;
&lt;p&gt;其中:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type表示正在处理的异常类&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;value表示正在处理的异常实例&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;traceback表示一个栈空间的回调对象(参考官方手册&lt;a href=&quot;https://docs.python.org/3/library/traceback.html&quot;&gt;traceback object&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看一个示例即可知道。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class General(Exception):pass

def raise0():
    x = General()
    raise x

try:
    raise0()
except Exception:
    import sys
    print(sys.exc_info())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(&amp;lt;class '__main__.General'&amp;gt;, General(), &amp;lt;traceback object at 0x0388F2B0&amp;gt;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果很明显，第一个返回值是异常类General，第二个返回值是抛出的异常类的实例对象，第三个返回值是traceback对象。&lt;/p&gt;
&lt;p&gt;实际上，当需要获取当前处理的异常类时，还可以通过异常对象的&lt;code&gt;__class__&lt;/code&gt;来获取，因为异常对象可以在except/as中赋值给变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class General(Exception):pass

def raise0():
    x = General()
    raise x

try:
    raise0()
except Exception as E:
    import sys
    print(sys.exc_info()[0])
    print(E.__class__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它们的的结果是完全一样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;class '__main__.General'&amp;gt;
&amp;lt;class '__main__.General'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么时候要获取异常类的信息？当except所监视的异常类比较大范围，同时又想知道具体的异常类。比如，&lt;code&gt;except:&lt;/code&gt;或&lt;code&gt;except Exception:&lt;/code&gt;这两种监视的异常范围都非常大，前者会监视BaseException，也就是python的所有异常，后者监视的是Exception，也就是python的所有普通的异常。正因为监视范围太大，导致不知道具体是抛出的是哪个异常。&lt;/p&gt;
&lt;h2 id=&quot;区分异常和错误&quot;&gt;区分异常和错误&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;错误都是异常，但异常并不一定都是错误&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;很常见的，文件结尾的EOF在各种语言中它都定义为异常，是异常就能被触发捕获，但在逻辑上却不认为它是错误。&lt;/p&gt;
&lt;p&gt;除此之外，还有操作系统的异常，比如sys.exit()引发的SystemeExit异常，ctrl+c引发的的中断异常KeyboardInterrupt都属于异常，但它们和普通的异常不一样。而且python中的普通异常都继承字Exception类，但SystemExit却并非它的子类，而是BaseException的子类。所以能通过空的&lt;code&gt;except:&lt;/code&gt;捕获到它，却不能通过&lt;code&gt;except Exception:&lt;/code&gt;来捕获。&lt;/p&gt;
&lt;h2 id=&quot;异常类的继承&quot;&gt;异常类的继承&lt;/h2&gt;
&lt;p&gt;所有异常类都继承自Exception，要编写自定义的异常时，要么直接继承该类，要么继承该类的某个子类。&lt;/p&gt;
&lt;p&gt;例如，下面定义三个异常类，General类继承Exception，另外两个继承General类，表示这两个是特定的、更具体的异常类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class General(Exception):pass
class Specific1(General): pass
class Specific2(General): pass

def raise0():
    x = General()
    raise x

def raise1():
    x = Specific1()
    raise x

def raise2():
    x = Specific2()
    raise x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for func in (raise0, raise1, raise2):
    try:
        func()
    except General as E:
        import sys
        print(&quot;caught: &quot;, E.__class__)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;caught:  &amp;lt;class '__main__.General'&amp;gt;
caught:  &amp;lt;class '__main__.Specific1'&amp;gt;
caught:  &amp;lt;class '__main__.Specific2'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面说过，except监视父类异常的时候，也会捕获该类的子类异常。正如这里监视的是Gereral类，但触发了Specific子类异常也会被捕获。&lt;/p&gt;
&lt;h2 id=&quot;异常类的嵌套&quot;&gt;异常类的嵌套&lt;/h2&gt;
&lt;p&gt;这是非常常见的陷阱。有两种异常嵌套的方式：try的嵌套；代码块的异常嵌套(比如函数嵌套)。无论是哪种嵌套模式，异常都只在最近(或者说是最内层)的代码块中被处理，但是finally块是所有try都会执行的。&lt;/p&gt;
&lt;p&gt;第一种try的嵌套模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    try:
        (1)
    except xxx:
        (2)
    finally:
        (3)
except yyy:
    ...
finally:
    (4)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果在(1)处抛出了异常，无论yyy是否匹配这个异常，只要xxx能匹配这个异常，就会执行(2)。但(3)、(4)这两个finally都会执行。&lt;/p&gt;
&lt;p&gt;第二种代码块嵌套，常见的是函数调用的嵌套，这种情况可能会比较隐式。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def action2():
    print(1 + [])

def action1():
    try:
        action2()
    except TypeError:
        print('inner try')

try:
    action1()
except TypeError:
    print('outer try')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;inner try&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的action2()会抛出一个TypeError的异常。在action1()中用了try包围action2()的调用，于是action2()的异常汇报给action1()层，然后被捕获。&lt;/p&gt;
&lt;p&gt;但是在最外面，使用try包围action1()的调用，看上去异常也会被捕获，但实际上并不会，因为在action2()中就已经通过except处理好了异常，而处理过的异常将不再是异常，不会再触发外层的异常，所以上面不会输出&quot;outer try&quot;。&lt;/p&gt;
&lt;h2 id=&quot;except应该捕获哪些异常&quot;&gt;except应该捕获哪些异常&lt;/h2&gt;
&lt;p&gt;在考虑异常捕获的时候，需要注意几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;except监视的范围别太大了&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;except监视的范围别太小了&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;有些异常本就该让它中断程序的运行，不要去捕获它&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第三点很容易理解，有些异常会导致程序无法进行后续的运行，改中断还是得中断。&lt;/p&gt;
&lt;p&gt;对于第一点，可能常用的大范围异常监视就是下面两种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;except:
except Exception:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种方式监视的范围都太大了，比如有些不想处理的异常也会被它们监视到。更糟糕的可能是本该汇报给上层的异常，结果却被这种大范围捕获了。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def func():
    try:
        ...
    except:
        ...

try:
    func()
except IndexErro:
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本来是想在外层的try中明确捕获func触发的IndexError异常的，但是func()内却使用了空的&lt;code&gt;except:&lt;/code&gt;，使得异常直接在这里被处理，外层的try永远也捕获不到任何该函数的异常。&lt;/p&gt;
&lt;p&gt;关于第二点，不应该监视范围太小的异常。范围小，意味着监视的异常太过具体，太过细致，这种监视方式虽然精确，但却不利于维护。例如E1异常类有2个子异常类E2、E3，在代码中监视了E2、E3，但如果未来又添加了一个E1的子异常类E4，那么又得去改代码让它监视E4。如果代码是写给自己用的倒无所谓，但如果像通用模块一样交给别人用的，这意味着让别的模块使用者也去改代码。&lt;/p&gt;
&lt;h2 id=&quot;自定义异常类&quot;&gt;自定义异常类&lt;/h2&gt;
&lt;p&gt;在前面设计异常类的时候，总是使用pass跳过类代码体。但却仍然能使用这个类作为异常类，因为它继承了Exception，在Exception中有相关代码可以输出异常信息。&lt;/p&gt;
&lt;p&gt;前面说过，在构造异常类的时候可以传递参数，它们会放进异常实例对象的args属性中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;try:
    raise IndexError(&quot;something wrong&quot;)
except Exception as E:
    print(E.args)

try:
    assert False,&quot;something wrong too&quot;
except Exception as E:
    print(E.args)

I = IndexError('text')
print(I.args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于用户自定义的类，也一样如此：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyError(Exception):pass
try:
    raise MyError('something wrong')
except MyError as E:
    print(E.args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不仅如此，虽然异常实例对象是一个对象，但如果直接输出实例对象，那么得到的结果将是给定的异常信息，只不过它不在元组中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;I = IndexError(&quot;index wrong&quot;)
print(I)      # 输出&quot;index wrong&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很容易想到，这是因为Exception类中重写了&lt;code&gt;__str__&lt;/code&gt;或者&lt;code&gt;__repr__&lt;/code&gt;中的某一个或两个都重写了。&lt;/p&gt;
&lt;h3 id=&quot;自定义异常输出&quot;&gt;自定义异常输出&lt;/h3&gt;
&lt;p&gt;于是，自定义异常类的时候，也可以重写这两个中的一个，从而可以定制属于自己的异常类的输出信息。一般来说只重写&lt;code&gt;__str__&lt;/code&gt;，因为Exception中也是重写该类，且它的优先级高于&lt;code&gt;__repr__&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如下面自定义的异常类。当然，这个示例的效果非常简陋，但已足够说明问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyError(Exception):
    def __str__(self):
        return 'output this message for something wrong'

try:
    raise MyError(&quot;hahhaha&quot;)
except MyError as E:
    print(E)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;output this message for something wrong&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提供构造方法&quot;&gt;提供构造方法&lt;/h3&gt;
&lt;p&gt;自定义异常类的时候，可以重写构造方法&lt;code&gt;__init__()&lt;/code&gt;，这样raise异常的时候，可以指定构造的数据。而且更进一步的，还可以重写&lt;code&gt;__str__&lt;/code&gt;来自定义异常输出。&lt;/p&gt;
&lt;p&gt;例如，格式化文件的程序中定义一个异常类，用来提示解析到哪个文件的哪一行出错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyError(Exception):
    def __init__(self,line,file):
        self.line = line
        self.file = file
    def __str__(self):
        return &quot;format failed: %s at %s&quot; % (self.file, self.line)

def format():
    ...
    raise MyError(42, &quot;a.json&quot;)
    ...

try:
    format()
except MyError as E:
    print(E)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提供异常类的其它方法&quot;&gt;提供异常类的其它方法&lt;/h3&gt;
&lt;p&gt;异常类既然是类，说明它可以像普通类一样拿来应用。比如添加其它类方法。&lt;/p&gt;
&lt;p&gt;例如，可以将异常信息写入到文件中。只需提供一个向文件写入的方法，并在except的语句块中调用这个方法即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MyError(Exception):
    def __init__(self, line, file):
        self.line = line
        self.file = file

    def logerr(self):
        with open('Error.log', 'a') as logfile:
            print(self, file=logfile)

    def __str__(self):
        return &quot;format failed: %s at %s&quot; % (self.file, self.line)

def format():
    raise MyError(42, &quot;a.json&quot;)

try:
    format()
except MyError as E:
    E.logerr()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 13 Dec 2018 14:35:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>入门示例 异常处理：try/except 对于索引查找的操作，在索引越界搜索的时候会报错。例如： 所报的错误是IndexError。如果将索引查找放在一个函数里： 那么调用函数的时候，如果里面的索引越</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10116936.html</dc:identifier>
</item>
<item>
<title>自制 COCO api 直接读取类 COCO 的标注数据的压缩文件 - xinet</title>
<link>http://www.cnblogs.com/q735613050/p/10116893.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/q735613050/p/10116893.html</guid>
<description>&lt;p&gt;COCO 数据库是由微软发布的一个大型图像数据集，该数据集专为对象检测、分割、人体关键点检测、语义分割和字幕生成而设计。如果你要了解 COCO 数据库的一些细节，你可以参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MS COCO 数据集主页：http://mscoco.org/&lt;/li&gt;
&lt;li&gt;我改写的 COCO API 网址：https://github.com/Xinering/cocoapi&lt;/li&gt;
&lt;li&gt;数据下载: http://mscoco.org/dataset/#download&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/cocodataset/cocoapi&quot;&gt;COCO API&lt;/a&gt; 提供了 Matlab, Python 和 Lua 的 API 接口。该 API 接口提供完整的图像标签数据的加载，解析和可视化的工作。此外，网站还提供了与数据相关的文章，教程等。&lt;/p&gt;
&lt;p&gt;在使用 COCO 数据库提供的 API 和 demo 之前，我们首先需要下载 COCO 的图像和标签数据：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;图像数据下载到 &lt;code&gt;coco/images/&lt;/code&gt; 文件夹中&lt;/li&gt;
&lt;li&gt;标签数据下载到 &lt;code&gt;coco/annotations/&lt;/code&gt; 文件夹中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本章快报：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;介绍和使用官方 API：详细说明如何在 Linux 和 Windows 系统下使用 cocoapi&lt;/li&gt;
&lt;li&gt;改写官方 API：利用 Python 的特性对 API 进行改写，同时支持直接读取压缩文件&lt;/li&gt;
&lt;li&gt;API 扩展：将 API 推广至其他数据集&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们来探讨一下如何利用 Python 来使用 COCO 数据集？&lt;/p&gt;
&lt;h2 id=&quot;coco-api-的配置与简介&quot;&gt;6.1 COCO API 的配置与简介&lt;/h2&gt;
&lt;p&gt;为了方便操作，我们先 fork 官方 &lt;a href=&quot;https://github.com/cocodataset/cocoapi&quot;&gt;COCO API&lt;/a&gt;，然后下载到本地，并切换到 API 所在目录，如 &lt;code&gt;D:\API\cocoapi\PythonAPI&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;cd D:\API\cocoapi\PythonAPI&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开当前目录下的 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/Makefile&quot;&gt;Makefile&lt;/a&gt; 可以看到 API 的安装和使用说明。&lt;/p&gt;
&lt;h3 id=&quot;windows-的配置&quot;&gt;6.1.1 Windows 的配置&lt;/h3&gt;
&lt;p&gt;在 Windows 下直接运行 &lt;code&gt;python setup.py build_ext --inplace&lt;/code&gt; 会报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201811/685754-20181128171152074-712787406.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Windows 中 （一般需要安装 visual studio）有许多的坑，参考 &lt;a href=&quot;https://www.jianshu.com/p/de455d653301&quot;&gt;Windows 10 编译 Pycocotools 踩坑记&lt;/a&gt; 暴力删掉参数 &lt;code&gt;Wno-cpp&lt;/code&gt; 和 &lt;code&gt;Wno-unused-function&lt;/code&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201811/685754-20181128172018282-613145959.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，我们便可以在 Python 中使用 &lt;code&gt;pycocotools&lt;/code&gt;，不过每次你想要调用 &lt;code&gt;pycocotools&lt;/code&gt; 需要先载入局部环境：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
sys.path.append('D:\API\cocoapi\PythonAPI')   # 将你的 `pycocotools` 所在路径添加到系统环境&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你不想这么麻烦，你可以直接将 &lt;code&gt;pycocotools&lt;/code&gt; 安装在你的主环境下：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;cd D:\API\cocoapi\PythonAPI

python setup.py build_ext install
rd build   # 删除&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是，这样并没有解决根本问题，还有许多 bug 需要你自己调，因而在第 6.2 节 介绍了 cocoapi 对 Windows 系统更加的友好实现。&lt;/p&gt;
&lt;h3 id=&quot;linux-下的配置&quot;&gt;6.1.2 Linux 下的配置&lt;/h3&gt;
&lt;p&gt;在 Linux 下，不需要上面这么多编译步骤，我们直接在终端输入下列命令即可正常使用 COCO API：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;pip3 install -U Cython
pip3 install -U pycocotools&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，你也可以使用和 Windows 系统同样的处理方法，具体操作方法也可以参考 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/Makefile&quot;&gt;Makefile&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;api-简介&quot;&gt;6.1.3 API 简介&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Xinering/cocoapi&quot;&gt;COCO API&lt;/a&gt; 可以帮助你载入、解析和可视化 annotations。 该 API 支持 multiple annotation 格式 (详情见 &lt;a href=&quot;http://cocodataset.org/#format-data&quot;&gt;data format&lt;/a&gt;). 更多关于 API 的细节可参考 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocotools/coco.py&quot;&gt;coco.py&lt;/a&gt;，同时 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocoDemo.ipynb&quot;&gt;Python API demo&lt;/a&gt; 也提供了API 的英文使用说明。&lt;/p&gt;
&lt;p&gt;下面从官方页面截了张 COCO API 的记号说明的图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201811/685754-20181128204835168-782917471.png&quot; alt=&quot;cocoapi&quot;/&gt;&lt;/p&gt;
&lt;p&gt;COCO 还为每个实例对象提供了分割掩码（segmentation masks），但是产生了两个挑战：紧凑地存储掩码和高效地执行掩码计算。 MASK API 使用自定义运行长度编码 (Run Length Encoding, RLE) 方案解决这两个难题。RLE 表示的大小与掩码的边界像素数成正比，并且可以在 RLE 上直接有效地计算操作 (如面积、联合或交集)。具体来说，假设 shapes 相当简单, RLE 表示形式为 &lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;, 其中 &lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt; 是对象中的像素数, 而通常计算量同样是 &lt;span class=&quot;math inline&quot;&gt;\(O(\sqrt{n})\)&lt;/span&gt;。在解码掩码 (存储为阵列) 上进行相同操作的自然的计算量将是 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;Mask API 提供了一个用于操作以 RLE 格式存储的掩码的接口。这个 API 被定义在 &lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocotools/mask.py&quot;&gt;mask.py&lt;/a&gt;。最后, 大多数 ground truth masks 存储为多边形 (相当紧凑), 这些多边形在需要时转换为 RLE。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201811/685754-20181128214541861-1026383433.png&quot; alt=&quot;MASK&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，cocoapi 的介绍便宣告结束了，具体使用细则可以参考&lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocoDemo.ipynb&quot;&gt;pycocoDemo.ipynb&lt;/a&gt; 提供的 cocoapi 的使用 demo，我已经翻译成中文，大家可以查阅：&lt;a href=&quot;https://www.cnblogs.com/q735613050/p/8969452.html&quot;&gt;COCO 数据集的使用&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;改写-coco-api-的初衷&quot;&gt;6.2 改写 COCO API 的初衷&lt;/h2&gt;
&lt;p&gt;前文我一直在说 cocoapi 对 Windows 系统不友好，相信在 Windows 系统下使用过 cocoapi 的朋友一定会十分赞同的。&lt;/p&gt;
&lt;h3 id=&quot;why-api-改写的目的&quot;&gt;6.2.1 Why? API 改写的目的&lt;/h3&gt;
&lt;p&gt;为了在 Windows 系统下更加友好的使用 cocoapi，抛去各种调 bug 的烦恼，我们十分有必要对 cocoapi 进行改写。但是，完全改写源码是有点让人感到恐惧的事情，而 Python 是一个十分强大的语言，我们利用它的继承机制可以无压力改写代码。&lt;/p&gt;
&lt;h3 id=&quot;what-api-可以做什么&quot;&gt;6.2.2 What? API 可以做什么&lt;/h3&gt;
&lt;p&gt;读者朋友是不是感觉改写 API 在做无用功，我们直接在 Linux 系统使用 cocoapi 也没有这么多的烦恼，为什么一定要改写？因为，改写后的 API 除了可以直接在 Windows 系统友好使用之外，它还提供了无需解压（直接跳过解压）直接获取标注信息和图片的功能。&lt;/p&gt;
&lt;h3 id=&quot;how-api-如何设计&quot;&gt;6.2.3 How? API 如何设计&lt;/h3&gt;
&lt;p&gt;我们在 cocoapi 所在目录 &lt;code&gt;D:\API\cocoapi\PythonAPI\pycocotools&lt;/code&gt; 下创建 &lt;code&gt;cocoz.py&lt;/code&gt; 文件。下面我们来一步一步的填充 &lt;code&gt;cocoz.py&lt;/code&gt;。为了方便调试，我们先在 Notebook 模式下设计该 API，设计好之后，我们再封装到 &lt;code&gt;cocoz.py&lt;/code&gt; 文件中。为了令 cocoapi 可以使用，需要先载入环境：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import sys
sys.path.append(r'D:\API\cocoapi\PythonAPI')

from pycocotools.coco import COCO&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们需要直接读取压缩文件，因而我们需要 &lt;code&gt;zipfile&lt;/code&gt;，为了减少代码编写的工作量，我们直接借用 cocoapi 的 &lt;code&gt;COCO&lt;/code&gt; 类。又因为标注信息是以 &lt;code&gt;.json&lt;/code&gt; 形式存储的，所以载入 &lt;code&gt;json&lt;/code&gt; 也是必要的，而 &lt;code&gt;numpy&lt;/code&gt; 和 &lt;code&gt;cv2&lt;/code&gt; 处理图片数据的重要工具当然也需要。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import os
import zipfile
import numpy as np
import cv2
import json
import time&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了更加方便的查看某个函数运行时间，我们需要一个计时器：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def timer(func):
    '''
    Define a timer, pass in one, and
    return another method with the timing feature attached
    '''
    def wrapper(*args):
        start = time.time()
        print('Loading json in memory ...')
        value = func(*args)
        end = time.time()
        print('used time: {0:g} s'.format(end - start))
        return value

    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我将 COCO 的所有数据都下载到了磁盘，我们可以查看如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;root = r'E:\Data\coco'   # COCO 数据根目录

dataDir = os.path.join(root, 'images')  #  图片所在目录
annDir = os.path.join(root, 'annotations')  # 标注信息所在目录

print('images:\n',os.listdir(dataDir))
print('='*50)
print('annotations:\n',os.listdir(dataDir))
print(os.listdir(annDir))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;images:
['test2014.zip', 'test2015.zip', 'test2017.zip', 'train2014.zip', 'train2017.zip', 'unlabeled2017.zip', 'val2014.zip', 'val2017.zip']
==================================================
annotations:
['test2014.zip', 'test2015.zip', 'test2017.zip', 'train2014.zip', 'train2017.zip', 'unlabeled2017.zip', 'val2014.zip', 'val2017.zip']
['annotations_trainval2014.zip', 'annotations_trainval2017.zip', 'image_info_test2014.zip', 'image_info_test2015.zip', 'image_info_test2017.zip', 'image_info_unlabeled2017.zip', 'panoptic_annotations_trainval2017.zip', 'stuff_annotations_trainval2017.zip']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出：所有数据我都没有解压，下面我们将动手设计一个无需解压便可获取数据信息的接口。&lt;/p&gt;
&lt;h2 id=&quot;imagez-的设计和使用&quot;&gt;6.3 ImageZ 的设计和使用&lt;/h2&gt;
&lt;p&gt;我们先设计一个用来处理 &lt;code&gt;coco/images/&lt;/code&gt; 文件夹下的图片数据集的类：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class ImageZ(dict):
    '''
    Working with compressed files under the images
    '''

    def __init__(self, root, dataType, *args, **kwds):
        '''
        root:: root dir
        dataType in ['test2014', 'test2015',
                    'test2017', 'train2014',
                    'train2017', 'unlabeled2017',
                    'val2014', 'val2017']
        '''
        super().__init__(*args, **kwds)
        self.__dict__ = self
        self.shuffle = True if dataType.startswith('train') else False
        self.Z = self.__get_Z(root, dataType)
        self.names = self.__get_names(self.Z)
        self.dataType = self.Z.namelist()[0]

    @staticmethod
    def __get_Z(root, dataType):
        '''
        Get the file name of the compressed file under the images
        '''
        dataType = dataType + '.zip'
        img_root = os.path.join(root, 'images')
        return zipfile.ZipFile(os.path.join(img_root, dataType))

    @staticmethod
    def __get_names(Z):
        names = [
            name.split('/')[1] for name in Z.namelist()
            if not name.endswith('/')
        ]
        return names

    def buffer2array(self, image_name):
        '''
        Get picture data directly without decompression

        Parameters
        ===========
        Z:: Picture data is a ZipFile object
        '''
        image_name = self.dataType + image_name
        buffer = self.Z.read(image_name)
        image = np.frombuffer(buffer, dtype=&quot;B&quot;)  # 将 buffer 转换为 np.uint8 数组
        img_cv = cv2.imdecode(image, cv2.IMREAD_COLOR)  # BGR 格式
        img = cv2.cvtColor(img_cv, cv2.COLOR_BGR2RGB)
        return img&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码这么长看着是不是有点懵，具体细节大家自己琢磨，我们直接看看它有什么神奇之处？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dataDir = r'E:\Data\coco'   # COCO 数据根目录
dataType = 'val2017'
imgZ = ImageZ(dataDir, dataType)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 &lt;code&gt;imgZ&lt;/code&gt; 继承自 &lt;code&gt;dict&lt;/code&gt;，所以它拥有字典的几乎所有属性和功能：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;imgZ.keys()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dict_keys(['shuffle', 'Z', 'names', 'dataType'])&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;names&lt;/code&gt;：存储了 &lt;code&gt;val2017.zip&lt;/code&gt; 的所有图片的文件名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shuffle&lt;/code&gt;：判断是否是训练数据集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Z&lt;/code&gt;：&lt;code&gt;ZipFile&lt;/code&gt; 对象，用来操作整个 &lt;code&gt;val2017.zip&lt;/code&gt; 文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有一个实例方法 &lt;code&gt;buffer2array&lt;/code&gt; 可以直接通过图片的文件名获取其像素级特征。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;fname = imgZ.names[77]  # 一张图片的文件名
img = imgZ.buffer2array(fname)  # 获取像素级特征&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 &lt;code&gt;img&lt;/code&gt; 是 Numpy 数组，这样我们就可以对其进行各种我们熟悉的操作，如图片显示：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt

plt.imshow(img)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222516954-1842373832.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经完成无需解压直接读取图片的工作。&lt;/p&gt;
&lt;h2 id=&quot;annz-的设计和使用&quot;&gt;6.4 AnnZ 的设计和使用&lt;/h2&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class AnnZ(dict):
    '''
    Working with compressed files under annotations
    '''

    def __init__(self, root, annType, *args, **kwds):
        '''
        dataType in [
              'annotations_trainval2014',
              'annotations_trainval2017',
              'image_info_test2014',
              'image_info_test2015',
              'image_info_test2017',
              'image_info_unlabeled2017',
              'panoptic_annotations_trainval2017',
              'stuff_annotations_trainval2017'
        ]
        '''
        super().__init__(*args, **kwds)
        self.__dict__ = self
        self.Z = self.__get_Z(root, annType)
        self.names = self.__get_names(self.Z)

    @staticmethod
    def __get_Z(root, annType):
        '''
        Get the file name of the compressed file under the annotations
        '''
        annType = annType + '.zip'
        annDir = os.path.join(root, 'annotations')
        return zipfile.ZipFile(os.path.join(annDir, annType))

    @staticmethod
    def __get_names(Z):
        names = [name for name in Z.namelist() if not name.endswith('/')]
        return names

    @timer
    def json2dict(self, name):
        with self.Z.open(name) as fp:
            dataset = json.load(fp)
        return dataset&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们直接看看如何使用？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;root = r'E:\Data\coco'   # COCO 数据集所在根目录
annType = 'annotations_trainval2017'   # COCO 标注数据类型

annZ = AnnZ(root, annType)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来查看一下，该标注数据所包含的标注种类：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;annZ.names&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;['annotations/instances_train2017.json',
 'annotations/instances_val2017.json',
 'annotations/captions_train2017.json',
 'annotations/captions_val2017.json',
 'annotations/person_keypoints_train2017.json',
 'annotations/person_keypoints_val2017.json']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面以 &lt;code&gt;dict&lt;/code&gt; 的形式载入 'annotations/instances_train2017.json' 的具体信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;annFile = 'annotations/instances_val2017.json'
dataset = annZ.json2dict(annFile)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Loading json in memory ...
used time: 1.052 s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还可以查看 &lt;code&gt;dataset&lt;/code&gt; 的关键字：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dataset.keys()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dict_keys(['info', 'licenses', 'images', 'annotations', 'categories'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们可以很方便的使用 &lt;code&gt;dict&lt;/code&gt; 的相关操作获取我们想要的一些信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;dataset['images'][7]  # 查看一张图片的一些标注信息&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{'license': 6,
'file_name': '000000480985.jpg',
'coco_url': 'http://images.cocodataset.org/val2017/000000480985.jpg',
'height': 500,
'width': 375,
'date_captured': '2013-11-15 13:09:24',
'flickr_url': 'http://farm3.staticflickr.com/2336/1634911562_703ff01cff_z.jpg',
'id': 480985}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以利用 &lt;code&gt;'coco_url'&lt;/code&gt; 直接从网上获取图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt
import skimage.io as sio

coco_url = dataset['images'][7]['coco_url']
# use url to load image
I = sio.imread(coco_url)
plt.axis('off')
plt.imshow(I)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222535903-113671340.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;借助 ImageZ 从本地读取图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt
imgType = 'val2017'
imgZ = ImageZ(root, imgType)

I = imgZ.buffer2array(dataset['images'][100]['file_name'])

plt.axis('off')
plt.imshow(I)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222613885-1170522480.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cocoz-的设计和使用&quot;&gt;6.5 COCOZ 的设计和使用&lt;/h2&gt;
&lt;p&gt;ImageZ 和 AnnZ 虽然很好用，但是它们的灵活性太大，并且现在的开源代码均是基于 COCO 类进行设计的。为了更加契合 cocoapi 我们需要一个中转类 COCOZ 去实现和 COCO 几乎一样的功能，并且使用方法也尽可能的保留。具体是代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class COCOZ(COCO, dict):
    def __init__(self, annZ, annFile, *args, **kwds):
        '''
        ptint(coco):: View Coco's Instance object Coco's 'info'

        example
        ==========
        annZ = AnnZ(annDir, annType)
        '''
        super().__init__(*args, **kwds)
        self.__dict__ = self
        self.dataset = annZ.json2dict(annFile)
        self.createIndex()

    @timer
    def createIndex(self):
        # create index
        print('creating index...')
        cats, anns, imgs = {}, {}, {}
        imgToAnns, catToImgs = {}, {}
        if 'annotations' in self.dataset:
            for ann in self.dataset['annotations']:
                imgToAnns[ann['image_id']] = imgToAnns.get(
                    ann['image_id'], []) + [ann]
                anns[ann['id']] = ann
        if 'images' in self.dataset:
            for img in self.dataset['images']:
                imgs[img['id']] = img
        if 'categories' in self.dataset:
            for cat in self.dataset['categories']:
                cats[cat['id']] = cat
        if 'annotations' in self.dataset and 'categories' in self.dataset:
            for ann in self.dataset['annotations']:
                catToImgs[ann['category_id']] = catToImgs.get(
                    ann['category_id'], []) + [ann['image_id']]

        print('index created!')

        # create class members
        self.anns = anns
        self.imgToAnns = imgToAnns
        self.catToImgs = catToImgs
        self.imgs = imgs
        self.cats = cats

    def __str__(self):
        &quot;&quot;&quot;
        Print information about the annotation file.
        &quot;&quot;&quot;
        S = [
            '{}: {}'.format(key, value)
            for key, value in self.dataset['info'].items()
        ]
        return '\n'.join(S)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们直接看看如何使用 COCOZ？&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;root = r'E:\Data\coco'   # COCO 数据集所在根目录
annType = 'annotations_trainval2017'   # COCO 标注数据类型
annFile = 'annotations/instances_val2017.json'

annZ = AnnZ(root, annType)
coco = COCOZ(annZ, annFile)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Loading json in memory ...
used time: 1.036 s
Loading json in memory ...
creating index...
index created!
used time: 0.421946 s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你需要预览你载入的 COCO 数据集，可以使用 &lt;code&gt;print()&lt;/code&gt; 来实现：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;print(coco)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;description: COCO 2017 Dataset
url: http://cocodataset.org
version: 1.0
year: 2017
contributor: COCO Consortium
date_created: 2017/09/01&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次查看：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;coco.keys()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dict_keys(['dataset', 'anns', 'imgToAnns', 'catToImgs', 'imgs', 'cats'])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;展示-coco-的类别与超类&quot;&gt;6.5.1 展示 COCO 的类别与超类&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;cats = coco.loadCats(coco.getCatIds())
nms = set([cat['name'] for cat in cats])  # 获取 cat 的 name 信息
print('COCO categories: \n{}\n'.format(' '.join(nms)))
# ============================================================
snms = set([cat['supercategory'] for cat in cats])  # 获取 cat 的 name 信息
print('COCO supercategories: \n{}'.format(' '.join(snms)))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;COCO categories:
kite sports ball horse banana toilet mouse frisbee bed donut clock sheep keyboard tv cup elephant cake potted plant snowboard train zebra fire hydrant handbag cow wine glass bowl sink parking meter umbrella giraffe suitcase skis surfboard stop sign bear cat chair traffic light fork truck orange carrot broccoli couch remote hair drier sandwich laptop tie person tennis racket apple spoon pizza hot dog bird refrigerator microwave scissors backpack airplane knife baseball glove vase toothbrush book bottle motorcycle bicycle car skateboard bus dining table cell phone toaster boat teddy bear dog baseball bat bench oven

COCO supercategories:
animal kitchen food appliance indoor accessory person sports furniture outdoor electronic vehicle&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;通过给定条件获取图片&quot;&gt;6.5.2 通过给定条件获取图片&lt;/h3&gt;
&lt;p&gt;获取包含给定类别的所有图片&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# get all images containing given categories, select one at random
catIds = coco.getCatIds(catNms=['cat', 'dog', 'snowboar'])  # 获取 Cat 的 Ids
imgIds = coco.getImgIds(catIds=catIds )  # 
img = coco.loadImgs(imgIds)
# 随机选择一张图片的信息
img = coco.loadImgs(imgIds[np.random.randint(0,len(imgIds))])[0]

img&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{'license': 3,
'file_name': '000000179392.jpg',
'coco_url': 'http://images.cocodataset.org/val2017/000000179392.jpg',
'height': 640,
'width': 480,
'date_captured': '2013-11-18 04:07:31',
'flickr_url': 'http://farm5.staticflickr.com/4027/4329554124_1ce02506f8_z.jpg',
'id': 179392}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;将图片的-anns-信息标注在图片上&quot;&gt;6.5.3 将图片的 anns 信息标注在图片上&lt;/h3&gt;
&lt;p&gt;先从本地磁盘获取一张图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt
imgType = 'val2017'
imgZ = ImageZ(root, imgType)

I = imgZ.buffer2array(dataset['images'][55]['file_name'])

plt.axis('off')
plt.imshow(I)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222634810-1586403502.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将标注信息加入图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# load and display instance annotations
plt.imshow(I)
plt.axis('off')
annIds = coco.getAnnIds(imgIds=img['id'], catIds=catIds, iscrowd=None)
anns = coco.loadAnns(annIds)
coco.showAnns(anns)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222650232-1068692901.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关键点检测&quot;&gt;6.5.4 关键点检测&lt;/h3&gt;
&lt;p&gt;载入标注信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# initialize COCO api for person keypoints annotations
root = r'E:\Data\coco'   # COCO 数据集所在根目录
annType = 'annotations_trainval2017'   # COCO 标注数据类型
annFile = 'annotations/person_keypoints_val2017.json'

annZ = AnnZ(root, annType)
coco_kps = COCOZ(annZ, annFile)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Loading json in memory ...
used time: 0.924155 s
Loading json in memory ...
creating index...
index created!
used time: 0.378003 s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先选择一张带有 person 的图片：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from matplotlib import pyplot as plt

catIds = coco.getCatIds(catNms=['person'])  # 获取 Cat 的 Ids
imgIds = coco.getImgIds(catIds=catIds)  
img = coco.loadImgs(imgIds)[99]
# use url to load image
I = sio.imread(img['coco_url'])
plt.axis('off')
plt.imshow(I)
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222710248-1937593350.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将标注加到图片上：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# load and display keypoints annotations
plt.imshow(I); plt.axis('off')
ax = plt.gca()
annIds = coco_kps.getAnnIds(imgIds=img['id'], catIds=catIds, iscrowd=None)
anns = coco_kps.loadAnns(annIds)
coco_kps.showAnns(anns)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222723816-567517866.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;看图说话&quot;&gt;6.5.5 看图说话&lt;/h3&gt;
&lt;p&gt;载入标注信息：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# initialize COCO api for person keypoints annotations
root = r'E:\Data\coco'   # COCO 数据集所在根目录
annType = 'annotations_trainval2017'   # COCO 标注数据类型
annFile = 'annotations/captions_val2017.json'

annZ = AnnZ(root, annType)
coco_caps = COCOZ(annZ, annFile)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Loading json in memory ...
used time: 0.0760329 s
Loading json in memory ...
creating index...
index created!
used time: 0.0170002 s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将标注加到图片上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A man riding on a skateboard on the sidewalk.
a kid riding on a skateboard on the cement
There is a skateboarder riding his board on the sidewalk
A skateboarder with one fut on a skateboard raising it up.
A pavement where a person foot are seen having skates.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/685754/201812/685754-20181213222742261-49376028.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，我们已经完成了我们的预期目标。&lt;/p&gt;
&lt;h2 id=&quot;让-api-更加通用&quot;&gt;6.6 让 API 更加通用&lt;/h2&gt;
&lt;p&gt;虽然我们完成了预期目标，但是 &lt;code&gt;cocoz.py&lt;/code&gt; 还有很大的改进余地。比如我们可以令 ImageZ 变得像列表一样，支持索引和切片。为了优化结构，我们可以将其封装为生成器。基于这些想法我们便得到一个改进版的 ImageZ，只需添加几个实例方法即可：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def __getitem__(self, item):
    names = self.names[item]
    if isinstance(item, slice):
        return [self.buffer2array(name) for name in names]
    else:
        return self.buffer2array(names)


def __len__(self):
    return len(self.names)


def __iter__(self):
    for name in self.names:
        yield self.buffer2array(name)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;详细代码被我放在：&lt;a href=&quot;https://github.com/Xinering/cocoapi/blob/master/PythonAPI/pycocotools/cocoz.py&quot;&gt;cocoz.py&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;小节&quot;&gt;6.7 小节&lt;/h2&gt;
&lt;p&gt;本章主要介绍了 COCO 数据及其 API cocoapi ，同时为了更好的使用 cocoapi，又自制了一个可以直接读取 &lt;code&gt;.zip&lt;/code&gt; 数据集的接口 &lt;code&gt;cocoz.py&lt;/code&gt;。同时，&lt;code&gt;cocoz.py&lt;/code&gt; 也可以用来直接读取以 COCO 标注数据形式封装的其他数据集。&lt;/p&gt;
</description>
<pubDate>Thu, 13 Dec 2018 14:28:00 +0000</pubDate>
<dc:creator>xinet</dc:creator>
<og:description>第6章 COCO API 的使用 COCO 数据库是由微软发布的一个大型图像数据集，该数据集专为对象检测、分割、人体关键点检测、语义分割和字幕生成而设计。如果你要了解 COCO 数据库的一些细节，你可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/q735613050/p/10116893.html</dc:identifier>
</item>
</channel>
</rss>