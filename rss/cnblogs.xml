<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《组织行为学》--群体行为及个人感悟 - 超大的雪童子</title>
<link>http://www.cnblogs.com/yangsy0915/p/10389958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangsy0915/p/10389958.html</guid>
<description>&lt;h2&gt;个人感悟&lt;/h2&gt;
&lt;p&gt;　　我们上一节分析了个人维度的不同价值观、行为动机、态度、满意度等相关因素，从而使我们能够更好地理解他人，提高个人认知以及促进不同相关性的人之间达成合作关系。那么从这一章开始，我们将各类的人，根据组织职能的划分的再细分，就形成了特定某一活动或是组织战略分解下的群体，这个群体会专注于已有划分的目标。&lt;/p&gt;
&lt;p&gt;　　那么针对群体，我们可以理解为具有不同的角色。当然，从上一节我们已经观察到一个群体组织会包含 主管（具有实质性权利）、非权力型主导（具备具体事项指挥权）以及各类型的群体成员。那么群体的建立及发展包含着关键性的几个节点。&lt;/p&gt;
&lt;p&gt;　　人员群体建立，该过程其实也决定了人员的甄选。当然，我这里着重说明的是下面是以实际工作中团队的概念来进行分析，那群体和团队区别是什么？团队是一种特殊的工作群体，它通过其成员的共同努力产生积极协同作用，团队成员努力的结果使团队的绩效水平远大于个体成员绩效水平的综合。具体根据团队的分析我们下一章再玩，下面着重分析群体人员，暂时模糊群体和团队的概念。&lt;/p&gt;
&lt;p&gt;　　对于技术人本身来说，会选择那些学历、背景、能力较强的成员。而且技术人员的以技术角度的权威性以及性格特点使得技术人员甄选人才的时候，选择那些与自己相符的成员，当然在群体成员做事的角度也是对的。从人性角度，人也是总是趋近于与自己相似的人。但是作为群体管理者，我们常常会根据群体目标定位中，为了达成目标而需要的各种类型特点的人才。比如说，需要技术专业人员能够有效的落地（优点：直爽而且对技术抱有极大热情）；需要语言组织能力强的人进行多部门需求沟通协作（优点：领域经验使得能快速理解业务需求，同时能以业务视角进行需求整合）；需要产品人员对于系统未来面向市场或用户的产品设计（优点：洞察力极强，视野及知识面广阔）；需要项目经理/架构师（优点：业务、技术、架构、方案整合及各环节人员贯穿）；需要运营人员（优点：影响力、业务思维及问题分析能力强，系统或产品的大力推广）。我们普遍观察到，群体的人数最好控制在一定范围内，能够使效率最大化，太多会导致个人成就感或是责任感下降，因为被分担了，太少又会造成个人负荷巨大，而难以维持长期的高生产率。具体的分配比例，还是要根据群体的目标来定夺。&lt;/p&gt;
&lt;p&gt;　　但是在组织行为学中我们发现，个性、价值观和文化方面也是群体成员甄选的关键要素。因为这些会决定着个人是否易相处合作，个人成就或领导的动机程度、文化程度也意味着是否能够有更多的角度、以及更好地对他人的理解。当然，也会包含着家庭、背景因素，但这些因素会被价值观及长期的相处合作中改变其特有的外在行为，所以这里将其弱化了。&lt;/p&gt;
&lt;p&gt;　　其实领导是非常难做的，别说大到组织的领导（当然组织层面就牵扯到企业文化与企业权利及政策与治理了），那么再到群体领导，需要平衡群体人员各方面之间的关系及包容不同人的性格。那么这里就不得不说群体规范及群体文化。一般来说群体规范与文化是对个性的一种制约作用，并声明了价值规范，目标是提高群体的一致性与生产力。如果说到生产力与一致性，又不得不说到凝聚力与协作。组织行为学中说的很好地一点在于，当群体来自于其他群体或其他外部压力的时候，会造成凝聚力极大的提升。打个比方，如果雇佣双方是甲乙方公司，乙方公司成员的凝聚力会相当高，因为群体统一受到了外部压力。同时，时间维度对凝聚力的影响也相当重要，在一起相处时间越长，群体凝聚力越强。但不一定凝聚力越强，群体的产出及效率就是最大的，因为大家会形成一致的行为或效率，这就需要管理者对高凝聚力的组织进行有效的引导及激励。但是很多情况下会发现，当一个群体持续时间越久，以人的角度，还有关系的影响造成无法再次激发成员热情。那么，现代有一个说法叫做，鲶鱼效应。&lt;/p&gt;
&lt;p&gt;　　鲶鱼效应，就好比一个稳定的群体或组织，突然扔进去一个工作狂，到处做事，各种学习，工作效率极高，责任心极强的成员。通过该成员来正向引导组内成员也活起来，形成成员推动作用。但是该成员也会容易遭到群体成员的联合排斥，需要极强的心理素质，同时把握进退尺度，并逐渐与大家相处融洽。随着时间的推移会发现，整体团队能力及工作效率都会有显著提升。这便是鲶鱼型人才。&lt;/p&gt;
&lt;p&gt;　　同时，管理者还需要把握每个人一段时间的心理活动，因为人随着阅历、经验、阅读等会形成某个阶段的顿悟，甚至达到开悟的状态。能够有效辨别哪些是服从行为，哪些是从众行为。当然，不同场景下从众行为和服从行为都有利弊。对于不服从的成员，就要去找寻他不服从的原因，同时第一手段不要去直接强制命令，而是通过其他方式比如了解背后的原因，引导式使其走向有利于群体目标的态度执行。&lt;/p&gt;
&lt;p&gt;　　当然，一切的前提，也是需要管理者有系统的管理方法论，同时阅人无数，采取有效的措施及人性的把握。&lt;/p&gt;
&lt;p&gt;　　对于决策来说，每个人的独特性（这里只背景、经历、认知、文化水平等）的不同，会产生对同一事物的不同的看法，从不同的成员身上去考虑他所考虑的角度对于整体目标的合理性，多角度的融合甚至会引发，创新。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;一、群体的基本概念&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;（1）定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　群体泛指通过一定的社会关系组合起来进行共同活动的集体。例如，以血缘关系结合起来的集体是氏族、家庭群体；以地缘关系结合起来的是集体是邻里群体；以业缘关系结合起来的则是各种职业群体。关于群体有几种不同观点。&lt;/p&gt;
&lt;p&gt;　　　　第一种观点认为，社会群体是一个广义的概念，包括家庭、乡村、城市、政党、国家乃至人类各种不同类型的社会结合。&lt;/p&gt;
&lt;p&gt;　　　　第二种观点认为，群体仅仅是指人际关系亲密的初级群体或小群体，如家庭、邻里、朋友群体等。&lt;/p&gt;
&lt;p&gt;　　　　第三种观点比较折中，认为社会群体是人们通过一定的社会关系结合起来进行共同活动的集体，是人们社会生活的具体单位。&lt;/p&gt;
&lt;p&gt;　　　　在组织行为学中，我们可以把群体简单地定义为：为了实现某个特定的目标，两个或两个以上相互作用、相互依赖的个体的组合。群体的类型多种多样，依照不同的标准，可以把社会群体划分为不同的类型：按照群体内的人际关系，可分为初级群体和次级群体；按照群体的规模可分为大型群体和小型群体；按照群体成员个人的归属管可以划分为内群体与外群体；按照其他特征还可以分为主要和次要群体，联盟制、会员制和参照群体，正式和非正式群体等等。&lt;/p&gt;
&lt;p&gt;　　　　1、正式群体&lt;/p&gt;
&lt;p&gt;　　　　　　指组织结构确定的、职务分配很明确的群体。一个人的行为是由组织目标规定的，并且指向组织目标的。比如现代组织中财务、市场、生产和人力资源等各种职能部门。&lt;/p&gt;
&lt;p&gt;　　　　2、非正式群体&lt;/p&gt;
&lt;p&gt;　　　　　　是哪些既没有正式结构，也不是由组织确定的联盟。它可能是出于政治、友谊或共同兴趣的原因而形成的。非正式群体对于组织有积极和消极两方面作用。积极作用包括：使组织称为更为有效的完整系统；减少管理者的工作量；弥补管理者的能力缺陷；为雇员的情绪提供一个安全的释放通道；促进沟通等。&lt;/p&gt;
&lt;p&gt;　　　　　　另一方面，它也可能产生一些消极作用，与正式群体目标冲突；限制群体成员的产出；从众行为；阻碍进去；抑制变革等。由于非正式群体总是不可避免的存在的，而且“非正式社会网络具有巨大的影响力”，有时会超过正式组织等级的影响力。它的作用应该被开发出来促进组织目标的实现。&lt;/p&gt;
&lt;p&gt;　　　　3、群体还可以具体细分为以下类型&lt;/p&gt;
&lt;p&gt;　　　　　　命令型群体，组织结构规定的、由直接向某个主管人员报告工作的下属组成的群体。&lt;/p&gt;
&lt;p&gt;　　　　　　任务型群体，为完成一项任务而在一起的工作的人组成的群体，一般也是由组织结构确定的。所有的命令型群体都是任务型群体，但任务型群体却不一定是命令型群体。比如：临时组建的专家小组。&lt;/p&gt;
&lt;p&gt;　　　　　　利益型群体，大家为了某个共同关心的特定目标而走到一起的群体。比如，公司中的一些员工为了与管理房协商工资办法的修改方案二结合在一起组成的群体。比如，工作中跨团队共建的项目。&lt;/p&gt;
&lt;p&gt;　　　　　　友谊型群体，基于成员共同特点而形成的群体，这些共同特点可能是年龄相近，性格相似，同一所学校毕业等等。不过这种群体。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）个体如何加入群体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　是什么动力使个体加入群体呢？对于个人来说，一般可以理解为不同群体为其成员提供了不同的利益，满足了成员个体不同的需要。个体加入群体可以满足这样一些需要：安全需要、地位需要、自尊需要、情感需要、全力需要、实现目标的需要。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;二、群体的形成和发展&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;（1）群体形成的动力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　人们常说，“物以类聚，人以群分”，这又是什么道理呢？&lt;/p&gt;
&lt;p&gt;　　　　1、相近性理论&lt;/p&gt;
&lt;p&gt;　　　　　　在公司里，一个办公室里的同事比办公室相隔较远的同事之间更容易形成群体，班级里座位相邻的同学比不同角落里的同学更容易形成群体。&lt;/p&gt;
&lt;p&gt;　　　　2、Geoge Homans三要素理论&lt;/p&gt;
&lt;p&gt;　　　　　　建立在活动、交往和感情之上。这三个要素互相联系：人们共同进行的活动越多，他们交往的次数就会越多，他们之间的相互情感（喜欢或不喜欢程度）也会越强烈，而相互间喜欢的情感越强烈，又导致他们之间共同活动和交往次数增多。而在一个群体中，相互的交往也是合作和解决问题以实现组织目标的基础。&lt;/p&gt;
&lt;p&gt;　　　　3、平衡理论&lt;/p&gt;
&lt;p&gt;　　　　　　“与之为谋者，同道也”。说明人们组成群体，是由某种共同基础的。人们之间相互吸引是基于他们对双方都相关的共通目标具有的相似态度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190217004238524-673085897.jpg&quot; alt=&quot;&quot; width=&quot;465&quot; height=&quot;290&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　个体X与个体Y交往，并建立关系形成群体，因为他们有共同的态度和价值观Z。一旦这种关系形成，参与者将努力在吸引和共同态度之间保持对称的平衡。如果不平衡出现，将会付出努力回复平衡。如果平衡不能被重建，这个关系将会瓦解。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）群体的发展阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　人的一生有不同的发展阶段，群体的发展没有固定和标准的模式，不同类型群体的发展可能存在一些差异。大家比较熟悉的两个模型：群体发展五阶段模型和最近的研究发现--间断--平衡模型。&lt;/p&gt;
&lt;p&gt;　　　　1、群体发展的五阶段模型&lt;/p&gt;
&lt;p&gt;　　　　　　形成阶段、震荡阶段、规范化阶段、执行任务阶段、中止阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190217004637697-596951459.jpg&quot; alt=&quot;&quot; width=&quot;695&quot; height=&quot;147&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　第一阶段，形成阶段的特点是不确定性，甚至是混乱。当群体成员开始把自己看作是群体的一员时，这个阶段就结束了。&lt;/p&gt;
&lt;p&gt;　　　　　　第二阶段：震荡阶段的特点是冲突和对抗。群体成员接手了群体的存在，但对群体加给他们的约束，仍然予以地址。而且，对于成员的角色、责任、控制、抵制。这个阶段结束时，群体的领导层次就相对明确了。&lt;/p&gt;
&lt;p&gt;　　　　　　第三阶段：规范化，经过震荡期后的调整，规范期群体内部成员之间开始形成亲密的关系，群体表现出一定的凝聚力，并开始进行合作和协作。&lt;/p&gt;
&lt;p&gt;　　　　　　第四阶段：执行任务，群体结构已经开始充分地发挥作用，并已被群体成员完全接收。群体成员的注意力已经从试图相互认识和理解转移到努力高效地完成群体任务。&lt;/p&gt;
&lt;p&gt;　　　　　　第五阶段：中止阶段，在这个阶段中，群体开始准备解散，注意力放到了群体的收尾工作。&lt;/p&gt;
&lt;p&gt;　　　　　　这五个阶段模型的一些补充：&lt;/p&gt;
&lt;p&gt;　　　　　　冲突可能有利于群体绩效。我们一般会认为群体的发展，随着冲突的减少和群体成员关系越来越亲密，会变得越来越有效，但在复杂的因素影响下情况却未必如此。一定水平的冲突有利于群体绩效的提高，比如工作中相关的政治和冲突对于避免错误和提高绩效很有效果。&lt;/p&gt;
&lt;p&gt;　　　　　　各阶段间不一定有明显的界限。事实上，正如我们前面提到的，群体的发展并没有固定的模式，并不总是明确地从一个阶段发展到下一个阶段。有时，几个阶段同时进行。&lt;/p&gt;
&lt;p&gt;　　　　　　群体发展无阶段模型是在不考虑组织环境的条件下的，这里组织环境包括群体完成任务所需要的规则、任务的内容、信息和资源、角色的分配、冲突的解决、规范的建立等。&lt;/p&gt;
&lt;p&gt;　　　　2、间断--平衡模型&lt;/p&gt;
&lt;p&gt;　　　　　　群体的形成和变革运作方式的时间段高度一致，群体成员的第一次会议决定群体的发展方向；第一阶段的群体活动依惯性执行；在第一阶段结束时，群体发生一次转变，这个转变正好发生在群体生命周期的中间阶段；这个转变会激起群体的重大变革；在转变之后，群体的活动又会依惯性进行；尊提的最后一次会议的特点是，活动速度明显加快。&lt;/p&gt;
&lt;p&gt;　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190217012314955-2106810576.jpg&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　第一次会议是群体发展的开始，这时，成员们一起决定群体发展的方向，确定群体的基本规范和未来的行为模式。这些内容成为群体发展方向的大框架，在群体发展的前半阶段会基本保持不变。这里出现一个共同的现象，研究发现每个群体都在其生命周期的同一时间点上发生转变--正好在群体的第一次会议和正式结束的额中间阶段--尽管这些群体完成任务的时间并不相同。存在一个普遍的现象，似乎每个群体在其存在时间的中间阶段都要经历中年危机。这个危机促使群体成员认识到，时间紧任务重，必须迅速行动。成员们认识到必须开始变革，抛弃旧的模式，采纳新的观点。&lt;/p&gt;
&lt;p&gt;　　　　　　如果这种认识转化为实际行动，转变调整后的群体就进入了发展的第二阶段。这一转变对群体来说是一次提升和促进，群体开始在新的水平上发展。这个阶段是一个平衡阶段，或者说又是一个依惯性运行的阶段。在这个阶段中，群体开始实施在其转变时期创造出来的新计划。当群体完成工作任务后，最后一次会议会成为一个总结，标志着群体任务的结束。&lt;/p&gt;
&lt;p&gt;　　　　　　总之，群体的间断--平衡模型强调的是群体发展中期的转折点，群体在其长期的依惯性运行的存在过程中，会有一个短暂的变革时期。主要是由于群体成员意识到它们完成任务的时间期限和紧迫感而引发的。如果能利用好这一特殊时期对群体进行变革提升，就能改善群体绩效，使群体发展上升一个台阶。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（3）群体行为的解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　为什么每个群体会表现出不同的行为方式，会有不同的成绩？因为一个群体在运作过程中受到很多因素的影响，这些因素使不同的群体有了差异。因素大致可以分为三类。&lt;/p&gt;
&lt;p&gt;　　　　1、工作群体不可能孤立存在，它们处在一个更大的环境或群体中，要受到大环境的影响。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（4）群体的外部环境条件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1、组织战略&lt;/p&gt;
&lt;p&gt;　　　　　　群体是生存在一个组织中的， 组织的整体战略会对群体有直接的影响。这些影响可能通过任务、资源、权利等的分配和安排作为群体。所谓战略也就是目标。随后管理人员会根据目标拆分，比如一所学校的战略目标，就包含了社会学院、经济学院、人力资源和劳动关系血缘、公共管理学院等等，学校会了解他们的学科建设计划，和专家一起讨论合理的方案，为他们制定一些工作目标，给予相应的资源和政策的支持，并定期检查保证计划实施。那么，一个学院作为群体，它的发展目标、具体措施、内部资源的分配、成员的相互作用都会受到学校这一系列活动的影响，而群体会采取相应的行动作为回应。&lt;/p&gt;
&lt;p&gt;　　　　2、权利结构&lt;/p&gt;
&lt;p&gt;　　　　　　组织里的权利分配体系，一般是由正式的组织结构决定的。权利表现为组织成员之间的一种组织关系，在组织结构中的上下层关系和横向部门机构中，都包含着权利的分配关系。从权利结构中能看出谁有权做决策，谁有权下命令和分配任务，谁向谁汇报工作。&lt;/p&gt;
&lt;p&gt;　　　　　　权利结构通常决定着一个工作群体在组织中的地位，它影响了一个群体的正式领导与组织的正式关系以及群体领导与他的群体成员的关系。有的群体可能会由群体内的一个非正式领导控制，但作为组织正式任命的领导，群体的正式领导会具有群体内其他成员所没有的权利，这些权利会影响群体的运行情况。&lt;/p&gt;
&lt;p&gt;　　　　3、正式规范&lt;/p&gt;
&lt;p&gt;　　　　　　与组织的非正式的规范相比，正式规范一般是成文的，是大家都必须遵守的明文规定。组织一般会采用规则、程序、说明、政策等形式作为正式规范来使员工的行为标准化。&lt;/p&gt;
&lt;p&gt;　　　　4、组织资源&lt;/p&gt;
&lt;p&gt;　　　　　　组织所拥有的资源也影响着群体的活动。各种资源，比如资金、时间、原材料、设备是由组织分配给群体的，这些资源是富裕还是短缺，对工作群体的行为有着巨大的影响。一个工作群体所能做的申请在很大程度上取决于其资源条件的充足与否。&lt;/p&gt;
&lt;p&gt;　　　　5、人员甄选过程&lt;/p&gt;
&lt;p&gt;　　　　　　工作群体是由成员组成的，而工作群体的成员首先是这个群体所属的组织的成员。一个组织在甄选员工的过程中所使用的标准，将决定这个组织工作群体中成员的类型。这些标准还不仅仅是知识、学历和经验上的，而是包括个性、价值观和文化方面的，这些方面对群体的影响尤为重要。&lt;/p&gt;
&lt;p&gt;　　　　6、组织文化&lt;/p&gt;
&lt;p&gt;　　　　　　组织文化向员工说明了，组织所重视的价值观是什么，提倡的行为方式是什么。工作群体的成员如果正确认识并接受了组织主导文化所蕴含的价值标准，就更容易得到组织的承认，并在组织中发挥作用。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三、群体的内部结构&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;（1）成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　如果一个人具备的能力对于完成任务至关重要，这个人会更愿意参与群体活动，一般来说贡献也会更大的，成为群体性领导的可能性也更大。但群体的业绩不是每个人业绩的简单加和，群体中还有一些重要的因素，如成员间的相互作用也起着重要的作用。&lt;/p&gt;
&lt;p&gt;　　　　从成员个体上看，能影响群体行为和群体业绩的最重要的因素除了个体的能力之外，还有成员的个性特征。有一些人格特质对于群体生产率、群体士气和群体凝聚力有积极的作用。如乐观外向、善于社交、有责任心等。还有一些特质在不同的文化中有所不同，如中国文化中，更接受谦虚、随和、乐于助人的特质，而美国的文化跟接受独立性强、自主、自信的特质。另外一些特质会造成消极作用，如独断专行、统治欲强、孤独悲观等。个性特征能够通过影响群体成员在群体内部相互作用的额方式对群体绩效产生影响。&lt;/p&gt;
&lt;p&gt;　　　　那么如何了解群体成员的能力和个性特征，是否嫩该预测群体绩效呢？还有一个重要的问题---组合搭配。成员在工作能力上互补的群体更容易有高绩效；另外个人能力和个性特征决定了成员在群体中的角色，各种角色的适当搭配也会影响群体绩效；还有价值观相似的成员更容易相互理解，进而密切合作等等。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）角色&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　角色这个词来自于戏剧中，包括人物的行为，语言和一些细节表现等等都需要在舞台上反映出来。生活中和工作中也是由一个个的场景和情绪组成的，每个人都是演员，在每个场景中扮演者一种角色。&lt;/p&gt;
&lt;p&gt;　　　　当我们在工作群体中使用“角色”这个词时，是指人们对社会性单位中处于某个职位的人所应该做出的行为模式的期待。如果我们每个人都只选择一种角色，并可以长期一致地扮演这种角色，那我们的行为只需要按一种角色表现就可以了。但是不幸的是，我们每天的工作生活都要不停地变换情景，我们需要按不同的角色要求来改变自己的行为。&lt;/p&gt;
&lt;p&gt;　　　　人们在不同的群体中扮演不同的角色时，一般都会经历下面几个阶段：&lt;/p&gt;
&lt;p&gt;　　　　1、角色期待，是人们按照社会角色的一般模式对一个人的态度、行为提出合乎身份的要求并寄予期望。当角色期待集中在一般的角色类别上时，就成为角色定式或角色刻板印象了。那么在组织中，雇主与雇员间也存在一种特殊的角色期待，命名为“心理契约”。在雇主和雇员之间，存在一种不成文的规定，它规定了双方的期待，也就是雇主对雇员，以及雇员对雇主的期待和要求。一般来说，雇员期待雇主公正地对待雇员，给他们提供可以接受的工作条件，清楚地表达一天的工作任务。而雇主期待员工工作态度认真，听从指挥，忠于组织。但是当心理契约中蕴含的角色期待没得到满足时，就会出现问题了：如果是雇主没能满足雇员的角色期待，雇员的绩效和工作满意度就会受到消极影响。如果雇员没能满足雇主的角色期待，雇员可能被雇主认为是没有能力或是不努力的，严重时可能还会受到处罚。&lt;/p&gt;
&lt;p&gt;　　　　2、角色知觉，仅仅有角色期望，并不能预测一个人的行为，人们对角色的扮演更大程度上取决于他们对角色的认知、理解--即角色知觉。一个人对自己在某种环境中应该有什么样的行为反应的认识，就是角色知觉。&lt;/p&gt;
&lt;p&gt;　　　　　  由于每个人的知识背景、价值观念、生活经验、道德水平以及所处的环境不同，因而对同一角色的理解可能会有巨大差别。事实上，我们周围的各种刺激都在向我们灌输各种角色的概念。包括我的父母、老师和朋友的观念，学校教育，书本和电影的内容。生活经历是一个人对角色认识的重要来源。&lt;/p&gt;
&lt;p&gt;　　　　3、角色扮演&lt;/p&gt;
&lt;p&gt;　　　　　　对角色的扮演是角色知觉的进一步发展，是人们用实际行动表现出来的角色。比如，一个新上任的厂长，对厂长角色的知觉是大力改革，以全厂的发展为目标，但是在上级领导、下属和员工都不愿面对改革、缺乏信心、胆怯规避的情况下，他就不得不对自己的领导行为做一些改变。&lt;/p&gt;
&lt;p&gt;　　　　4、角色冲突&lt;/p&gt;
&lt;p&gt;　　　　　　当一个人同时扮演多种角色时，他就承担了多种角色期待，如果个体服从一种角色的要求，那么久很难服从另一个角色的要求，这时可能会产生角色冲突。在极端情况下，可能包含这样的情景：个体所面临的两个或多个的角色期待是相互矛盾的。&lt;/p&gt;
&lt;p&gt;　　　　　　那么问题来了，从古至今都存在的问题。“忠孝难两全”就是人们长腰面对的角色冲突。当行孝和尽忠发生冲突时，需要人们做出选择时，人们常常会非常痛苦。&lt;/p&gt;
&lt;p&gt;　　　　5、领导&lt;/p&gt;
&lt;p&gt;　　　　　　一个工作群体一般都会有一个正式领导，比如一个部门的主管、一个研究中心的主任、一个项目组的组长。群体领导对群体绩效具有巨大影响。&lt;/p&gt;
&lt;p&gt;　　　　6、规范&lt;/p&gt;
&lt;p&gt;　　　　　　群体动力学的解释是，社会压力使成员们都服从群体规范。比如，因为产量最高的工人不必面临被解雇的危险，还能够得到较高的工资，那么工人们按道理应该努力工作的。可是群体成员们根据经验发现这样下去会导致大家的恶性竞争，他们的付出越来越多，得到的回报却不一定能上升。所以工人们一致地限制自己的产量，而且对不服从这个不成文规定的成员施加“惩罚”，这些“惩罚”可能是社会排斥、嘲笑、诅咒，甚至是殴打。&lt;/p&gt;
&lt;p&gt;　　　　　　群体压力对于促使工人们服从非正式的群体规范非常有效，甚至比用工资和奖励维持的正式组织的管理规范更有效。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（3）“规范”的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　规范，是指人们共同遵守的一些行为规范。广义的范围包括社会制度、法律、纪律、到的、风俗和信仰等。所有群体都形成了自己的规范。群体通过自己的规范让群体成员知道自己在一定的环境条件下，应该做什么，不应该做什么。群体规范就是在某种情境下群体对他的行为方式的期望。一旦群体规范被群体成员认可并接受以后，它们就成为一种影响群体成员行为的手段了。&lt;/p&gt;
&lt;p&gt;　　　　　　群体规范不是一天两天形成的，它的形成是一个产生--强化--固化的过程，是需要一段时间的。一般来说，群体规范是在群体成员掌握使群体有效运作所必需的行为的过程中逐步形成起来的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（4）地位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　地位指的是人们对群体或群体成员的位置或层次的一种社会性的界定。很多个人的特征都可以成为地位的象征，如职务、薪水、能力、知识、职业、荣誉等等。这些差异通过权力、角色行为、礼仪等方面表现出来。在理解人类行为时，地位是一个重要的因素，如果个体认识到，自己的地位认知与别人对自己地位的认知不一致，就会对个体的行为反应产生巨大影响。&lt;/p&gt;
&lt;p&gt;　　　　　　1、正式地位与非正式地位&lt;/p&gt;
&lt;p&gt;　　　　　　　　正是地位是组织通过任命职务或授予头衔等等使个体获得的地位。地位可以通过非正式地获得。某个特征是否与地位有关，要看这个群体的成员是如何看待它的。在一个群体中，如果行为的命令是由地位高的人向地位低的人发出的，那么他们在一起能够合作得比较愉快；如果某种行为的命令是由地位低的人最先发出的，在正式和非正式地位系统之间就会引起冲突。&lt;/p&gt;
&lt;p&gt;　　　　　　2、地位对群体规范的影响&lt;/p&gt;
&lt;p&gt;　　　　　　　　从众行为，这是一种由于对群体规范的遵从而产生的现象。与群体其他成员对比，一个地位较高的群体成员具有较大的偏离群体规范的自由。他们比地位低的同伴能够更有效地抵制群体规范施加给他们的从众压力。如果一个群体成员很为群体中其他人所看重，而他又不在乎群体给予他的社会性报酬那么在一定程度上，他就可以漠视群体规范的从众规范。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（5）规模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　群体规模能够影响群体的整体行为吗？答案是肯定的。所以我们在很多组织和活动中，会把人数控制在一个合理的范围内。&lt;/p&gt;
&lt;p&gt;　　　　事实表明，小群体完成任务的速度比大群体快。但是，如果需要群体解决复杂的问题或是提出很多丰富的观点，则大群体比小群体表现得好。如果群体的目标是了解事实或收集建议，那么大群体可能更有效。相反，在执行生产任务时，成员在7人左右的小群体会更为有效。&lt;/p&gt;
&lt;p&gt;　　　　但，群体回魔的增大，与个人绩效是负相关。就总的生产力来讲，4人群体的整体生产力大于1人或2人的生产力，但群体规模越大，群体成员个体的生产力却降低了。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;四、群体能举例及其作用&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　指的是群体成员之间的相互吸引力对群体本身的认同程度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　（1）群体凝聚力的影响因素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1、群体成员的交往。人们在一起的时间长短，影响人们之间的凝聚力。群体成员在一起时信息的沟通也影响群体凝聚力。信息越畅通的群体，凝聚力越大。&lt;/p&gt;
&lt;p&gt;　　　　2、加入群体的维度。加入一个群体越困难，这个群体的凝聚力就可能越强。比如，为了加入一所一流的医学院，就要经过激烈的竞争，这种竞争就导致医学院一年级学生班级的凝聚力很强。他们会有一些共同的经历，增强了他们之间的凝聚力。&lt;/p&gt;
&lt;p&gt;　　　　3、群体规模。如果说群体凝聚力随着群体成员在一起的时间的增多而增强，那么群体规模越大，群体凝聚力就越小，因为群体规模越大，群体成员之间相互作用就越难。&lt;/p&gt;
&lt;p&gt;　　　　4、群体成员的性别构成。一半发现，女性的凝聚力要高于男性。：）&lt;/p&gt;
&lt;p&gt;　　　　5、外部威胁。如果群体受到外部攻击，群体的凝聚力会增强。另外，如果群体成员认为外部攻击仅仅是因为群体的存在引起的，只要群体放弃或解体就能终止外部攻击，群体凝聚力就可能降低。&lt;/p&gt;
&lt;p&gt;　　　　6、以前的成功经验。如果群体一贯有成功的表现，它就容易建立起群体合作精神来吸引和团结群体成员。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）凝聚力对群体生产率的影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　凝聚力高的群体比凝聚力低的群体更有效，但凝聚力与群体效率的关系比较复杂，我们不能简单地说凝聚力高就好，还有一个重要的维度，是引导。一个高凝聚力的群体被给予积极的引导，则会产生最高的生产力，但告凝聚的群体如果被给予差的引导，则可能会导致最低的生产力。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190217025117524-1522649608.jpg&quot; alt=&quot;&quot; width=&quot;622&quot; height=&quot;320&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;四、群体互动&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;（1）社会助长作用和社会干扰作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　个体与别人在一起活动或有他人在场时，个体的行为效率提高的现象。但有时，他人在场不但不能促进我们行为效率的提高，反而会影响我们的正常工作，使我们的工作效率降低。这种当他人在场或他人一起从事某项工作时而使个体行为效率下降的现象被称作社会干扰。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）社会惰化作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　他人对个体行为所造成的另一种影响。社会惰化主要指当群体一起完成一件工作时，群体汇总的成员每人所付出的努力会比个体在单独情况下完成任务时偏少的现象，它一般发生在多个个体为了一个共同的目标而合作，自己的工作成绩又不能单独计算的情况下。与个体肚子情况相比，个体的声音强度（鼓掌声和欢呼声）是随着群体规模的增大而减弱的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190217025833982-792955193.jpg&quot; alt=&quot;&quot; width=&quot;658&quot; height=&quot;331&quot;/&gt;　　出现社会惰化的原因可能有三个，第一，社会评价的作用。在群体情况下，个人的工作是不记名的，他们所做的努力是不被测量的；第二，社会认知的作用。在群体中的个体，也许会为其他成员没有努力，没有尽到应尽的职责，所以自己也就开始偷懒以求得心理的公平感。第三，群体责任的扩散作用，成员们会认为群体责任应该由大家一起承担，当群体成员增多时，自己所承担的责任就减少了，个体所付出的努力就降低了。&lt;/p&gt;
&lt;p&gt;　　工作群体中，这种社会惰化效应对于组织行为学来说，意义是重大的。如果管理人员向借助群体的力量，来强化士气和工作团队，他们就必须提供衡量个人努力程度的手段。我们可以采取这样的一些方法：1、不仅公布整个群体的工作成绩，而且还公布每个成员的工作成绩，使大家都感到自己的工作是被监控的，是可评价的。2、帮助群体成员认识他人的工作成绩，使他们不仅了解自己是努力工作的，他人也是努力工作的。3、不要讲一个群体弄得太大，如果是一个大群体，就可以将它分为几个小规模的群体，使得更多的成员能够接受到外在影响力的影响。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（3）从众行为和服从行为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　当我们作为群体成员时，总是希望自己能被群体接受和认同的。你是否会因为这样的想法而赞成群体内大多数人的意见呢？如果有过这种情况，很可能是从众的表现了。事实表明，群体能够给予其他成员巨大压力，使他们能改变自己的行为和态度，与群体标准保持一致。&lt;/p&gt;
&lt;p&gt;　　　　从众行为从心理上可以分为两种不同的形式，一种为表面上顺从，另一种为内心真正的接受。前者只是行为上的顺从，并非发自内心，甚至在心里还会反对自己的从众行为，因此是一种假从众。个体完全放弃了自己原有的态度或行为方式，而是出于自愿地接手了大多数人的助长，因此是一种真正的从众。&lt;/p&gt;
&lt;p&gt;　　　　1、从众有时候对群体具有积极的意义，如果群体中大多数人的观点保持一致，有利于群体正常运转和大家齐心协力实现群体目标。同时，从众也会对群体产生消极的意义，往往放弃自己原来的正确主张，甚至顺从了错误的行为方式，变得人云亦云，没有自己的独立人格，这是不利于个体的健康发展的。研究发现，在下列情境中容易发生从众现象。1、判断作业的难度较高，所呈现的刺激模糊不清时，个体顺从社会压力的倾向就越高。2、群体极具吸引力并有高度的凝聚力时，个体较容易表现从众行为。3、个体感受到群体成员各个能干，自己却无法胜任时，较容易表现从众行为。4、个体的反应将会被群体大众所知道时，个体较容易表现从众行为。5、群体至少有三个成员，并且他们的反应一致时，成员较容易从众。&lt;/p&gt;
&lt;p&gt;　　　　2、服从行为&lt;/p&gt;
&lt;p&gt;　　　　　　按照他人的命令去行动的行为，也是人机交互的基本方式之一。服从与从众有着本质的不同。在服从情况下的个体，则完全是在不自愿的情况下，应别人的要求去行动的。服从包括两方面：对权威人物的命令服从，在有一定组织的群体规范影响下的服从。&lt;/p&gt;
&lt;p&gt;　　　　　　影响服从的因素很多，概括起来主要有三方面：命令发出者，他的权威性，他对执行命令者是否关心，爱护，都会影响到服从；命令的执行者，他的道德水平、人格特征以及文化背景也会影响到他对命令的服从；情境因素，周围人的榜样行为怎样，奖励结构的设置情况，自己拒绝或执行命令的行为反馈情况怎样等，也会影响到个体的服从行为。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;五、群体决策&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;（1）群体决策的优点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　1、信息和知识更完全&lt;/p&gt;
&lt;p&gt;　　　　　　每个人接触的人和事不同，知识背景不同，最终获得的信息当然也就不同。群体决策通过综合大家的信息和知识资源，为正确的决策提供更好地基础，这是个人决策无法做到的。&lt;/p&gt;
&lt;p&gt;　　　　2、每个人思维方式不同、经历不同、对同一件事会有不同的看法，对同一个问题也会提出不同的解决方案。这样，群体有机会更全面地考虑问题。&lt;/p&gt;
&lt;p&gt;　　　　3、决策更容易被接受&lt;/p&gt;
&lt;p&gt;　　　　　　如果决策的时候，哪些会受到决策影响的人和将来要执行政策的人能够参与进来，他们以后就更容易接受决策，而且会鼓励别人也接受政策。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）群体思维&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　由于群体压力所导致的思考能力、事实检测和道德判断的退化。群体思维特别容易发生在高凝聚力的群体中。因为群体思维实际上是源于个体成员从众以及达成一致性的压力。&lt;/p&gt;
&lt;p&gt;六、群体决策技术&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（1）头脑风暴法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　简单地说就是群体成员坐在一起，就需要决策的问题畅所欲言，不允许大家对这些看法加以评论，互动产生的从众压力会导致成员倾向于赞成大多数人的意见，这会妨碍创造性方案的形成。在讨论过程中，任何人都不能对别人的观点加以评价，哪怕某些挂你单是异想天开或者稀奇古怪的。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）名义群体法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　步骤：主持人把问题介绍清楚，确保每位成员都明白-&amp;gt;群体成员每人写下自己对于解决这个问题的看法或观点-&amp;gt;说明自己的观点，一个接一个，所有观点被记录下来-&amp;gt;群体开始讨论每一个人的观点，允许个人对自己的观点进行解释和补充，大家读每个人的观点进行讨论评价-&amp;gt;每一位成员肚子对这些观点进行排序，最终的决策结果是排序最靠前、选择最集中的那个观点。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（3）德尔菲法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　不必见面，第一回合搜集比较广泛意见回复。在对回收意见进行分析与修正后，结果被反馈给专家们。第二回合，针对反馈再提一次意见。这种方法视为“平衡意见”的好工具。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（4）电子会议技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　在计算机前，问题通过大屏幕呈献给参与者，要求他们把自己的意见输入计算机，个人的意见和投票都显示在会议室中的屏幕上。这个方法的主要优势：匿名、可靠、迅速。与会者可以老老实实地表现自己的真实态度。而不用担心受到惩罚。而且这种方法决策迅速，没有闲聊，讨论不会离开主题。&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190217032915877-919103416.jpg&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;319&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Feb 2019 20:35:00 +0000</pubDate>
<dc:creator>超大的雪童子</dc:creator>
<og:description>个人感悟 我们上一节分析了个人维度的不同价值观、行为动机、态度、满意度等相关因素，从而使我们能够更好地理解他人，提高个人认知以及促进不同相关性的人之间达成合作关系。那么从这一章开始，我们将各类的人，根</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangsy0915/p/10389958.html</dc:identifier>
</item>
<item>
<title>用人类社会工程学对C语言中的一些基本概念的剖析与理解 - 巫师笔记</title>
<link>http://www.cnblogs.com/lvfengkun/p/10389994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvfengkun/p/10389994.html</guid>
<description>&lt;p&gt;　　最近在学C语言程序设计时总是遇到一些概念理解上的不清晰与混乱的地方，在一次偶然间想到了以前看过的一部电影《我是谁，没有一个系统是安全的》，里面的主角用社会工程学的想法结合黑客知识化险为夷，给予了很大的震撼与启发。所以我想如果将现实中C语言的一些概念和人类社会联系起来，会不会产生一些奇妙的结果。&lt;/p&gt;
&lt;p&gt;　　首先我们应该先从C语言中最基本的概念开始（如果能将C语言中的基本概念与人类社会中的一些基本的概念联系起来的话，根据图灵计算的原理，那么我的这种想法很有可能也行得通），如果将变量与常量比作住在房子里的人的话，那么地址就可以认为是那个人（常量或变量）所住的房子的门牌号，每一个人（变量与常量）都有一个属于自己的门牌号（地址）。指针就可以理解为一个指路牌，指路牌上有门牌号（地址），通过这个门牌号可以找到住在这个房子里的人。与现实世界不同的是，计算机中的世界上是一维的，也就是说，我们（用户）通过门牌号（地址）就可以准确无误的找到我们要找的那个人（变量或常量）。这就是我们说为什么指针是C语言中最重要的概念的原因（如果你还不明白，可以自己去百度一下图灵机）。还有一个基本概念就是内存，我们可以将它类比成房产局，只有向房产局（内存）申请才能获得住在房子（地址）里的权力&lt;/p&gt;
&lt;p&gt;　　有了以上的概念，那么我们就可以定义一些相对复杂的东西，例如数组，我们知道数组是由许多单一数据类型组成的集合，那么我们就可以将它类比成一个小区，小区里由若干个人（变量），而且门牌号（地址）都按一定的规则排放。特别的，我们知道数组一般在程序中除了初始化外很难直接被整体改变，我们可以理解为一个小区（数组）中的人（变量）太多，当你要对它进行改变时过于麻烦，而若只改变指路牌（指针），那么工作量就会小很多。类似的，对函数我们可以认为它是一个公司，里面有许多不同类型的人（变量）各司其职，通过一些工具（C语言中的基础语句，如if语句，以及库函数）来实现用户的目的。同样，我们可以将结构体看作一个街道，一个街道可能包括一些个体户（变量），一些小区（数组），甚至公司（函数），不过公司（函数）太过庞大，没法全部过来，只能将门牌号（地址）挂在这里，通过指路牌（指针）可以找到它。与现实中的公司类似，如果一个公司（函数）十分庞大，甚至会包含一个或几个街道，这时，如果函数想要使用结构体，只需知道结构体的变量名以及其中的成员名即可。值得注意的是，如果你在声明结构体时只声明了结构体名，那么内存是不会分配内存空间的，可以理解为，你只想房产局（内存）提出了想建立一个街道（结构体）的申请，但是并没有告诉房产局（内存）你的街道（结构体）叫什么名字，所以房产局（内存）自然不可能给你分配房子（地址）。在结构体变量作函数参数时，也需要同时声明结构体名与变量名。&lt;/p&gt;
&lt;p&gt;　　对程序而言，调用变量有两种方法，一种是根据变量名直接调用，一种是根据变量调用。对此，我们可以理解为当程序编译时，房产局（内存）以经记录了每一个人（变量）的门牌号（地址），当我们要求调用某个人（变量）时，可以直接挨家挨户去找，也可以去房产局（内存）要一个指向他家指路牌（指针），毫无疑问，第二种做法跟有效率一些。&lt;/p&gt;
&lt;p&gt;　　通过人类社会工程学，我们可以更好的理解C语言中的一些概念，可以降低初学者的难度，同时也可以反窥C语言的创造者们在编写C语言时的逻辑历程，这对我们以后进行工程作业时可以有更多的启发。本文只是通过人类社会工程学对C语言进行了一个粗糙的刨析，事实上，我们可以基于此对C语言中的一些更加具体的操作进行分析与类比，甚至可以对内存中的储存区进行分析与说明。&lt;/p&gt;
&lt;p&gt;　　另，鉴于本人见识所限，文中如有与事实不符之处，还望指出，万分感谢。&lt;/p&gt;
&lt;p align=&quot;right&quot;&gt;2019年2月17日&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 17:03:00 +0000</pubDate>
<dc:creator>巫师笔记</dc:creator>
<og:description>最近在学C语言程序设计时总是遇到一些概念理解上的不清晰与混乱的地方，在一次偶然间想到了以前看过的一部电影《我是谁，没有一个系统是安全的》，里面的主角用社会工程学的想法结合黑客知识化险为夷，给予了很大的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvfengkun/p/10389994.html</dc:identifier>
</item>
<item>
<title>参观微软Serbia开发中心和Office365 2019-01-31活动感悟 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/Tech-Club-Building-Belgrade-office-365-2019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/Tech-Club-Building-Belgrade-office-365-2019.html</guid>
<description>

&lt;p&gt;活动内容是讲Office 365的Azure SSO登录。&lt;/p&gt;
&lt;p&gt;活动地点在 微软塞尔维亚开发中心。&lt;/p&gt;
&lt;p&gt;以下是活动相关图片。嗯，里面唯一的一个中国听众当然就是我啦。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201902/26286-20190217002831151-865566592.jpg&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201902/26286-20190217002858652-751871182.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201902/26286-20190217002920070-1139273655.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201902/26286-20190217002942734-1155300244.jpg&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201902/26286-20190217003013916-1807859962.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201902/26286-20190217003105199-1788308154.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;活动感悟：&lt;/p&gt;
&lt;ol readability=&quot;1.8255813953488&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;人数坐满微软的会议室。没有人迟到。看来成员都蛮爱学习的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我参观了微软塞尔维亚开发中心，微软的会议室每桌都有电脑，这点微软广州都做不到。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;微软和Oracle都在塞尔维亚有开发中心，并且这里的移动互联网建设和中国不相上下，比如等待公交车信息有专门的App，公交车上提供免费WIFI，看来我们不能妄自菲薄，也不能盲目自信，对自己国家的水平要有个清晰和真实的认识，无论夸大还是缩小都会导致决策上的错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.38416988416988&quot;&gt;

&lt;/li&gt;
&lt;li readability=&quot;-0.42753623188406&quot;&gt;
&lt;div readability=&quot;8.5507246376812&quot;&gt;和成员们详细沟通得知，基本可以得出结论，这些成员主要是服务于塞尔维亚本地客户。而《&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/Tech-Club-Building-Belgrade-Python-2019.html&quot; target=&quot;_blank&quot;&gt;Belgrade Python技术俱乐部&lt;/a&gt;》的成员主要是做西欧的软件外包项目。&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Q&amp;amp;A:&lt;/p&gt;
&lt;p&gt;等待大家提问中&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 16:46:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>这是《国外线下技术俱乐部建设》系列文章之一。我参观了微软塞尔维亚开发中心.活动内容是讲Office 365的Azure SSO登录。活动地点在 微软塞尔维亚开发中心</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adalovelacer/p/Tech-Club-Building-Belgrade-office-365-2019.html</dc:identifier>
</item>
<item>
<title>深入理解Java的三种工厂模式 - 王、晨</title>
<link>http://www.cnblogs.com/w13248223001/p/10389854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/w13248223001/p/10389854.html</guid>
<description>&lt;h3&gt;一、简单工厂模式&lt;/h3&gt;
&lt;p&gt;简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现汽车接口&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    String getName();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;奔驰类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Benz &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;Benz&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;宝马类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMW &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Car {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getName() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &quot;BMW&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;简单工厂，既能生产宝马又能生产奔驰&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleFactory {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar(String name){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (name.equals(&quot;BMW&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMW();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (name.equals(&quot;benz&quot;&lt;span&gt;)){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Benz();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             System.out.println(&quot;不好意思，这个品牌的汽车生产不了&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SimpleFactoryTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         SimpleFactory simpleFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SimpleFactory();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         Car car = simpleFactory.getCar(&quot;BMW&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        System.out.println(car.getName());
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;根据简单工厂的定义，用户只要产品而不在乎产品如何生产，看起来好像很完美的样子。但大家想想，这个世界存在什么都生产的工厂吗？显然是不存在的，每一个汽车品牌都有自己的生产工厂，都有自己生产技术。映射到spring框架中，我们有很多很多种的bean需要生产，如果只依靠一个简单工厂来实现，那么我们得在工厂类中嵌套多少个if..else if啊？而且我们在代码中生产一辆汽车只是new一下就出来了，但实际操作中却不知道需要进行多少操作，加载、注册等操作都将体现在工厂类中，那么这个类就会变得紊乱，管理起来也很不方便，所以说每个品牌应该有自己的生产类。因为专一，所以专业嘛，这个时候工厂方法就出现了。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;二、工厂方法&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;工厂接口&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个工厂接口，功能就是生产汽车&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Factory {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    Car getCar();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;奔驰工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BenzFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Factory {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Benz();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;宝马工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Factory{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMW();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FactoryTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;        Factory bmwFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMWFactory();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;       System.out.println(bmwFactory.getCar().getName());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;        Factory benzFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BenzFactory();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;       System.out.println(benzFactory.getCar().getName());
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;BMW
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Benz
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;根据上述代码可以看出，不同品牌的汽车是由不同的工厂生产的，貌似又是很完美的。但大家看一下测试类，当一个人想要去买一辆宝马汽车的时候（假设没有销售商），那么他就要去找宝马工厂给他生产一辆，过几天又想要买一辆奔驰汽车的时候，又得跑到奔驰工厂请人生产，这无疑就增加了用户的操作复杂性。所以有没有一种方便用户操作的方法呢？这个时候抽象工厂模式就出现了。&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;三、抽象工厂&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;抽象工厂&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbstractFactory {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;      &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt;&lt;span&gt; Car getCar();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这段代码就是动态配置的功能
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;固定模式的委派&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;      &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar(String name){
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(&quot;BMW&quot;&lt;span&gt;.equalsIgnoreCase(name)){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BmwFactory().getCar();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&quot;Benz&quot;&lt;span&gt;.equalsIgnoreCase(name)){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BenzFactory().getCar();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(&quot;Audi&quot;&lt;span&gt;.equalsIgnoreCase(name)){
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AudiFactory().getCar();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         }&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             System.out.println(&quot;这个产品产不出来&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;默认工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractFactory {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; AudiFactory defaultFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AudiFactory();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; defaultFactory.getCar();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;宝马工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BMWFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractFactory {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BMW();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;奔驰工厂&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BenzFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractFactory {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Car getCar() {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Benz();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试类&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AbstractFactoryTest {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         DefaultFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultFactory();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         System.out.println(factory.getCar(&quot;Benz&quot;&lt;span&gt;).getName());
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;根据上述代码可以看出，用户需要一辆汽车，只需要去找默认的工厂提出自己的需求（传入参数），便能得到自己想要产品，而不用根据产品去寻找不同的生产工厂，方便用户操作。注：对于设计模式，有些人嗤之以鼻，有些人敬若神明，但我是认可的。按我粗浅的理解，设计模式的经典之处，就在于解决了编写代码的人和调用代码的人双方的痛楚，不同的设计模式也只适用于不同的场景。至于用或者不用，如何使用，那就需要各位看官着重考虑了。但为了使用而使用是不应该的，细微之处，只有留给大家慢慢品味了。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;a href=&quot;https://my.oschina.net/u/4052893/blog/2995128&quot;&gt;来源：&lt;/a&gt;&lt;a href=&quot;https://my.oschina.net/u/4052893/blog/2995128&quot;&gt;https://my.oschina.net/u/4052893/blog/2995128&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 15:54:00 +0000</pubDate>
<dc:creator>王、晨</dc:creator>
<og:description>一、简单工厂模式 简单工厂的定义：提供一个创建对象实例的功能，而无须关心其具体实现。被创建实例的类型可以是接口、抽象类，也可以是具体的类 实现汽车接口 奔驰类 宝马类 简单工厂，既能生产宝马又能生产奔</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/w13248223001/p/10389854.html</dc:identifier>
</item>
<item>
<title>C++ 单例模式总结与剖析 - 行者孙</title>
<link>http://www.cnblogs.com/sunchaothu/p/10389842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunchaothu/p/10389842.html</guid>
<description>&lt;p&gt;单例可能是最常用的简单的一种设计模式，实现方法多样，根据不同的需求有不同的写法; 同时单例也有其局限性，因此有很多人是反对使用单例的。本文对C++ 单例的常见写法进行了一个总结, 包括懒汉式、线程安全、单例模板等； 按照从简单到复杂，最终回归简单的的方式循序渐进地介绍，并且对各种实现方法的局限进行了简单的阐述，大量用到了C++ 11的特性如智能指针, magic static，线程锁; 从头到尾理解下来，对于学习和巩固C++语言特性还是很有帮助的。本文的全部代码在 g++ 5.4.0 编译器下编译运行通过，可以在&lt;a href=&quot;https://github.com/sunchaothu/AdvancedCpp/tree/master/singleton&quot;&gt;我的github 仓库&lt;/a&gt;中找到。&lt;/p&gt;
&lt;h2 id=&quot;一什么是单例&quot;&gt;一、什么是单例&lt;/h2&gt;
&lt;p&gt;单例 Singleton 是设计模式的一种，其特点是只提供&lt;strong&gt;唯一&lt;/strong&gt;一个类的实例,具有全局变量的特点，在任何位置都可以通过接口获取到那个唯一实例;&lt;br/&gt;具体运用场景如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;设备管理器，系统中可能有多个设备，但是只有一个设备管理器，用于管理设备驱动;&lt;/li&gt;
&lt;li&gt;数据池，用来缓存数据的数据结构，需要在一处写，多处读取或者多处写，多处读取;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二c单例的实现&quot;&gt;二、C++单例的实现&lt;/h2&gt;
&lt;h3 id=&quot;基础要点&quot;&gt;2.1 基础要点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;全局只有一个实例：static 特性，同时禁止用户自己声明并定义实例（把构造函数设为 private）&lt;/li&gt;
&lt;li&gt;线程安全&lt;/li&gt;
&lt;li&gt;禁止赋值和拷贝&lt;/li&gt;
&lt;li&gt;用户通过接口获取实例：使用 static 类成员函数&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;c-实现单例的几种方式&quot;&gt;2.2 C++ 实现单例的几种方式&lt;/h3&gt;
&lt;h4 id=&quot;有缺陷的懒汉式&quot;&gt;2.2.1 有缺陷的懒汉式&lt;/h4&gt;
&lt;p&gt;懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，也就说直到调用get_instance() 方法的时候才 new 一个单例的对象。好处是如果被调用就不会占用内存。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
// version1:
// with problems below:
// 1. thread is not safe
// 2. memory leak

class Singleton{
private:
    Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    Singleton(Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator=(const Singleton&amp;amp;)=delete;
    static Singleton* m_instance_ptr;
public:
    ~Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    static Singleton* get_instance(){
        if(m_instance_ptr==nullptr){
              m_instance_ptr = new Singleton;
        }
        return m_instance_ptr;
    }
    void use() const { std::cout &amp;lt;&amp;lt; &quot;in use&quot; &amp;lt;&amp;lt; std::endl; }
};

Singleton* Singleton::m_instance_ptr = nullptr;

int main(){
    Singleton* instance = Singleton::get_instance();
    Singleton* instance_2 = Singleton::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行的结果是&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;constructor called!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，获取了两次类的实例，却只有一次类的构造函数被调用，表明只生成了唯一实例，这是个最基础版本的单例实现，他有哪些问题呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;线程安全的问题&lt;/strong&gt;,当多线程获取单例时有可能引发竞态条件：第一个线程在if中判断 &lt;code&gt;m_instance_ptr&lt;/code&gt;是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断&lt;code&gt;m_instance_ptr&lt;/code&gt;还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来; &lt;strong&gt;解决办法&lt;/strong&gt;:加锁&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt;. 注意到类中只负责new出对象，却没有负责delete对象，因此只有构造函数被调用，析构函数却没有被调用;因此会导致内存泄漏。&lt;strong&gt;解决办法&lt;/strong&gt;： 使用共享指针;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此，这里提供一个改进的，线程安全的、使用智能指针的实现;&lt;/p&gt;
&lt;h4 id=&quot;线程安全内存安全的懒汉式单例-智能指针锁&quot;&gt;2.2.2 线程安全、内存安全的懒汉式单例 （智能指针，锁）&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;memory&amp;gt; // shared_ptr
#include &amp;lt;mutex&amp;gt;  // mutex

// version 2:
// with problems below fixed:
// 1. thread is safe now
// 2. memory doesn't leak

class Singleton{
public:
    typedef std::shared_ptr&amp;lt;Singleton&amp;gt; Ptr;
    ~Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    Singleton(Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator=(const Singleton&amp;amp;)=delete;
    static Ptr get_instance(){

        // &quot;double checked lock&quot;
        if(m_instance_ptr==nullptr){
            std::lock_guard&amp;lt;std::mutex&amp;gt; lk(m_mutex);
            if(m_instance_ptr == nullptr){
              m_instance_ptr = std::shared_ptr&amp;lt;Singleton&amp;gt;(new Singleton);
            }
            return m_instance_ptr;
        }
    }


private:
    Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    static Ptr m_instance_ptr;
    static std::mutex m_mutex;
};

// initialization static variables out of class
Singleton::Ptr Singleton::m_instance_ptr = nullptr;
std::mutex Singleton::m_mutex;

int main(){
    Singleton::Ptr instance = Singleton::get_instance();
    Singleton::Ptr instance2 = Singleton::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下，发现确实只构造了一次实例，并且发生了析构。&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;constructor called!
destructor called!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;shared_ptr和mutex都是C++11的标准，以上这种方法的优点是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于 shared_ptr, 用了C++比较倡导的 RAII思想，用对象管理资源,当 shared_ptr 析构的时候，new 出来的对象也会被 delete掉。以此避免内存泄漏。&lt;/li&gt;
&lt;li&gt;加了锁，使用互斥量来达到线程安全。这里使用了两个 if判断语句的技术称为&lt;strong&gt;双检锁&lt;/strong&gt;；好处是，只有判断指针为空的时候才加锁，避免每次调用 get_instance的方法都加锁，锁的开销毕竟还是有点大的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不足之处在于： 使用智能指针会要求用户也得使用智能指针，非必要不应该提出这种约束; 使用锁也有开销; 同时代码量也增多了，实现上我们希望越简单越好。&lt;/p&gt;
&lt;p&gt;还有更加严重的问题，在某些平台（与编译器和指令集架构有关），==双检锁会失效==！具体可以看&lt;a href=&quot;http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726&quot;&gt;这篇文章&lt;/a&gt;，解释了为什么会发生这样的事情。&lt;/p&gt;
&lt;p&gt;因此这里还有第三种的基于 Magic Staic的方法达到线程安全&lt;/p&gt;
&lt;h4 id=&quot;最推荐的懒汉式单例magic-static-局部静态变量&quot;&gt;2.2.3 最推荐的懒汉式单例(magic static )——局部静态变量&lt;/h4&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class Singleton
{
public:
    ~Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    Singleton(const Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator=(const Singleton&amp;amp;)=delete;
    static Singleton&amp;amp; get_instance(){
        static Singleton instance;
        return instance;

    }
private:
    Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
};

int main(int argc, char *argv[])
{
    Singleton&amp;amp; instance_1 = Singleton::get_instance();
    Singleton&amp;amp; instance_2 = Singleton::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre class=&quot;txt&quot;&gt;
&lt;code&gt;constructor called!
destructor called!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方法又叫做 Meyers' Singleton&lt;a href=&quot;https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method-is-it-thre/449823#449823&quot;&gt;Meyer's的单例&lt;/a&gt;， 是著名的写出《Effective C++》系列书籍的作者 Meyers 提出的。所用到的特性是在C++11标准中的&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm&quot; title=&quot;Magic Static&quot;&gt;Magic Static&lt;/a&gt;特性：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.&lt;br/&gt;如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样保证了并发线程在获取静态局部变量的时候一定是初始化过的，所以具有线程安全性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function&quot; title=&quot;C++静态变量生存期&quot;&gt;C++静态变量的生存期&lt;/a&gt; 是从声明到程序结束，这也是一种懒汉式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是最推荐的一种单例实现方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过局部静态变量的特性保证了线程安全 (C++11, GCC &amp;gt; 4.3, VS2015支持该特性);&lt;/li&gt;
&lt;li&gt;不需要使用共享指针，代码简洁；&lt;/li&gt;
&lt;li&gt;注意在使用的时候需要声明单例的引用 &lt;code&gt;Single&amp;amp;&lt;/code&gt; 才能获取对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外网上有人的实现返回指针而不是返回引用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static Singleton* get_instance(){
    static Singleton instance;
    return &amp;amp;instance;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样做并不好，理由主要是无法避免用户使用&lt;code&gt;delete instance&lt;/code&gt;导致对象被提前销毁。还是建议大家使用返回引用的方式。&lt;/p&gt;
&lt;h4 id=&quot;函数返回引用&quot;&gt;2.2.4 函数返回引用&lt;/h4&gt;
&lt;p&gt;有人在网上提供了这样一种单例的实现方式；&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class A
{
public:
    A() {
        std::cout&amp;lt;&amp;lt;&quot;constructor&quot; &amp;lt;&amp;lt;std::endl;
    }
    ~A(){
        std::cout&amp;lt;&amp;lt;&quot;destructor&quot;&amp;lt;&amp;lt;std::endl;
    }
};


A&amp;amp; ret_singleton(){
    static A instance;
    return instance;
}

int main(int argc, char *argv[])
{
    A&amp;amp; instance_1 = ret_singleton();
    A&amp;amp; instance_2 = ret_singleton();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;严格来说，这不属于单例了，因为类A只是个寻常的类，可以被定义出多个实例，但是亮点在于提供了&lt;code&gt;ret_singleton&lt;/code&gt;的方法，可以返回一个全局（静态）变量，起到类似单例的效果，这要求用户必须保证想要获取 全局变量A ，只通过ret_singleton()的方法。&lt;/p&gt;
&lt;p&gt;以上是各种方法实现单例的代码和说明，解释了各种技术实现的初衷和原因。这里会&lt;strong&gt;比较推荐 C++11 标准下的 2.2.3 的方式&lt;/strong&gt;，即&lt;strong&gt;使用static local的方法&lt;/strong&gt;，简单的理由来说是因为其足够简单却满足所有需求和顾虑。&lt;/p&gt;
&lt;p&gt;在某些情况下，我们系统中可能有多个单例，如果都按照这种方式的话，实际上是一种重复，有没有什么方法可以只实现一次单例而能够复用其代码从而实现多个单例呢？ 很自然的我们会考虑使用模板技术或者继承的方法，&lt;br/&gt;在我的博客中有介绍过如何使用单例的模板。&lt;/p&gt;
&lt;h3 id=&quot;单例的模板&quot;&gt;2.3 单例的模板&lt;/h3&gt;
&lt;h4 id=&quot;crtp-奇异递归模板模式实现&quot;&gt;2.3.1 CRTP 奇异递归模板模式实现&lt;/h4&gt;
&lt;p&gt;代码示例如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// brief: a singleton base class offering an easy way to create singleton
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
class Singleton{
public:
    static T&amp;amp; get_instance(){
        static T instance;
        return instance;
    }
    virtual ~Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }
    Singleton(const Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator =(const Singleton&amp;amp;)=delete;
protected:
    Singleton(){
        std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
    }

};
/********************************************/
// Example:
// 1.friend class declaration is requiered!
// 2.constructor should be private


class DerivedSingle:public Singleton&amp;lt;DerivedSingle&amp;gt;{
   // !!!! attention!!!
   // needs to be friend in order to
   // access the private constructor/destructor
   friend class Singleton&amp;lt;DerivedSingle&amp;gt;;
public:
   DerivedSingle(const DerivedSingle&amp;amp;)=delete;
   DerivedSingle&amp;amp; operator =(const DerivedSingle&amp;amp;)= delete;
private:
   DerivedSingle()=default;
};

int main(int argc, char* argv[]){
    DerivedSingle&amp;amp; instance1 = DerivedSingle::get_instance();
    DerivedSingle&amp;amp; instance2 = DerivedSingle::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上实现一个单例的模板基类，使用方法如例子所示意，子类需要&lt;strong&gt;将自己作为模板参数T&lt;/strong&gt; 传递给 &lt;code&gt;Singleton&amp;lt;T&amp;gt;&lt;/code&gt; 模板; 同时需要&lt;strong&gt;将基类声明为友元&lt;/strong&gt;，这样才能调用子类的私有构造函数。&lt;/p&gt;
&lt;p&gt;基类模板的实现要点是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造函数需要是 &lt;strong&gt;protected&lt;/strong&gt;，这样子类才能继承；&lt;/li&gt;
&lt;li&gt;使用了&lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern&quot;&gt;奇异递归模板模式&lt;/a&gt;CRTP(Curiously recurring template pattern)&lt;/li&gt;
&lt;li&gt;get instance 方法和 2.2.3 的static local方法一个原理。&lt;/li&gt;
&lt;li&gt;在这里基类的析构函数可以不需要 virtual ，因为子类在应用中只会用 Derived 类型，保证了析构时和构造时的类型一致&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;不需要在子类声明友元的实现方法&quot;&gt;2.3.2 不需要在子类声明友元的实现方法&lt;/h4&gt;
&lt;p&gt;在 &lt;a href=&quot;https://codereview.stackexchange.com/questions/173929/modern-c-singleton-template&quot;&gt;stackoverflow&lt;/a&gt;上， 有大神给出了&lt;strong&gt;不需要在子类中声明友元的方法&lt;/strong&gt;，在这里一并放出;精髓在于使用一个代理类 token，子类构造函数需要传递token类才能构造，但是把 token保护其起来， 然后子类的构造函数就可以是公有的了，这个子类只有 &lt;code&gt;Derived(token)&lt;/code&gt;的这样的构造函数，这样用户就无法自己定义一个类的实例了，起到控制其唯一性的作用。代码如下。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// brief: a singleton base class offering an easy way to create singleton
#include &amp;lt;iostream&amp;gt;

template&amp;lt;typename T&amp;gt;
class Singleton{
public:
    static T&amp;amp; get_instance() noexcept(std::is_nothrow_constructible&amp;lt;T&amp;gt;::value){
        static T instance{token()};
        return instance;
    }
    virtual ~Singleton() =default;
    Singleton(const Singleton&amp;amp;)=delete;
    Singleton&amp;amp; operator =(const Singleton&amp;amp;)=delete;
protected:
    struct token{}; // helper class
    Singleton() noexcept=default;
};


/********************************************/
// Example:
// constructor should be public because protected `token` control the access


class DerivedSingle:public Singleton&amp;lt;DerivedSingle&amp;gt;{
public:
   DerivedSingle(token){
       std::cout&amp;lt;&amp;lt;&quot;destructor called!&quot;&amp;lt;&amp;lt;std::endl;
   }

   ~DerivedSingle(){
       std::cout&amp;lt;&amp;lt;&quot;constructor called!&quot;&amp;lt;&amp;lt;std::endl;
   }
   DerivedSingle(const DerivedSingle&amp;amp;)=delete;
   DerivedSingle&amp;amp; operator =(const DerivedSingle&amp;amp;)= delete;
};

int main(int argc, char* argv[]){
    DerivedSingle&amp;amp; instance1 = DerivedSingle::get_instance();
    DerivedSingle&amp;amp; instance2 = DerivedSingle::get_instance();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数模板返回引用&quot;&gt;2.3.3 函数模板返回引用&lt;/h4&gt;
&lt;p&gt;在 2.2.4 中提供了一种类型的全局变量的方法，可以把一个一般的类，通过这种方式提供一个类似单例的&lt;br/&gt;全局性效果（但是不能阻止用户自己声明定义这样的类的对象）;在这里我们把这个方法变成一个 template 模板函数，然后就可以得到任何一个类的全局变量。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt;

class A
{
public:
    A() {
        std::cout&amp;lt;&amp;lt;&quot;constructor&quot; &amp;lt;&amp;lt;std::endl;
    }
    ~A(){
        std::cout&amp;lt;&amp;lt;&quot;destructor&quot;&amp;lt;&amp;lt;std::endl;
    }
};

template&amp;lt;typename T&amp;gt;
T&amp;amp; get_global(){
    static T instance;
    return instance;
}

int main(int argc, char *argv[])
{
    A&amp;amp; instance_1 = get_global&amp;lt;A&amp;gt;();
    A&amp;amp; instance_2 = get_global&amp;lt;A&amp;gt;();
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这种方式确实非常简洁，同时类仍然具有一般类的特点而不受限制，当然也因此失去了单例那么强的约束（禁止赋值、构造和拷贝构造）。&lt;br/&gt;这里把函数命名为 &lt;code&gt;get_global()&lt;/code&gt; 是为了强调，这里可以通过这种方式获取得到单例最重要的全局变量特性；但是并不是单例的模式。&lt;/p&gt;
&lt;h2 id=&quot;三何时应该使用或者不使用单例&quot;&gt;三、何时应该使用或者不使用单例&lt;/h2&gt;
&lt;p&gt;根据stackoverflow上的一个高票答案 &lt;a href=&quot;https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used&quot;&gt;singleton-how-should-it-be-used&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;You need to have one and only one object of a type in system&lt;br/&gt;==你需要系统中只有&lt;strong&gt;唯一&lt;/strong&gt;一个实例存在的类的&lt;strong&gt;全局&lt;/strong&gt;变量的时候才使用单例==。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;反对单例的理由&quot;&gt;反对单例的理由&lt;/h3&gt;
&lt;p&gt;当然程序员是分流派的，有些是反对单例的，有些人是反对设计模式的，有些人甚至连面向对象都反对 :).&lt;/p&gt;
&lt;p&gt;反对单例的理由有哪些：&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
&lt;p&gt;在本文写作的过程中参考了一些博客和stackoverflow 的回答，以超链接的方式体现在文中。另外还有一些我觉得非常精彩的回答，放在下面供读者拓展阅读&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;高票回答中提供了一系列有益的链接(&lt;a href=&quot;https://stackoverflow.com/questions/1008019/c-singleton-design-pattern/1008289#1008289&quot; class=&quot;uri&quot;&gt;https://stackoverflow.com/questions/1008019/c-singleton-design-pattern/1008289#1008289&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;面试中的单例(&lt;a href=&quot;http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/loveis715/archive/2012/07/18/2598409.html&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;一些观点(&lt;a href=&quot;https://segmentfault.com/q/1010000000593968&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/q/1010000000593968&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 16 Feb 2019 15:35:00 +0000</pubDate>
<dc:creator>行者孙</dc:creator>
<og:description>[toc] C++ 单例模式总结与剖析 单例可能是最常用的简单的一种设计模式，实现方法多样，根据不同的需求有不同的写法; 同时单例也有其局限性，因此有很多人是反对使用单例的。本文对C++ 单例的常见写</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunchaothu/p/10389842.html</dc:identifier>
</item>
<item>
<title>springboot学习之授权Spring Security - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10363504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10363504.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;SpringSecurity核心功能：认证、授权、攻击防护（防止伪造身份）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;涉及的依赖如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;pre readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;新建一个项目，添加如上依赖【添加依赖之后默认开始授权验证】，在控制器controller中测试，指定url，比如&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@Controller
public class UserController {

    @RequestMapping(value=&quot;/hello&quot;)
    @ResponseBody
    public String hello(){return &quot;=======Welcome to HelloWorld==============&quot;;}
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上，原本启动项目后，在地址栏中输入&lt;a href=&quot;http://localhost:8080/hello&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/hello&lt;/a&gt;应该显示返回的内容&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而此次加了安全验证后，不管url中访问的地址是什么，hello还是hello111，均返回login页面，如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190211214606053-1538900330.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时系统都没有连DB，用户名和密码是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制台中有消息，比如Using generated security password: 76dade1c-f190-44f8-915c-7a6b6917fb9a【每次随机生成的密码】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将用户名 &lt;span&gt;&lt;strong&gt;user&lt;/strong&gt;&lt;/span&gt; 和 密码 &lt;span&gt;&lt;strong&gt;76dade1c-f190-44f8-915c-7a6b6917fb9a&lt;/strong&gt;&lt;/span&gt; 填入上面对话框中，点击按钮Sign in&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190211214813673-1064582040.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 若之前访问的页面是控制器中配置的页面&lt;a href=&quot;http://localhost:8080/hello&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/hello&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则此时能成功显示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190211215015743-1523318928.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若之前访问的页面是其他的，控制器中未配置的，则重定向后返回页面不存在。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当前自己的项目中，总不能用系统生成的密码进行登录获得权限，那不要被别人笑死。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;进阶阶段：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;我简单创建了一张表，希望该表的人输入匹配的用户名和密码后，方能登录。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:sql;gutter:true;&quot;&gt;
&lt;span&gt;CREATE TABLE `admin_user`(
`id` int(4) NOT NULL AUTO_INCREMENT,
`username` VARCHAR(100),
`password` VARCHAR(100),
`role` VARCHAR(100),
`realname` VARCHAR(100),
`mobile` VARCHAR(2000),
`state` BIT default 0,
`info` VARCHAR(200),
PRIMARY KEY (`id`)
)ENGINE=InnoDB AUTO_INCREMENT=300;
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　塞了几条数据进去，然后我希望用户在页面上进行登录，那我必须还要创建一个User对象，所谓登录就是传入username和password匹配的场景，只要匹配，就登录成功，跳转到之前的url&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;public class User {

    private int id;
    private String name;
    private String password; 省略 getter and setter｝
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;public interface UserService {

    User login(String name, String password);
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Override
    public User login(String name, String password) {
        String sql =&quot;select * from admin_user where username =? and password = ?&quot;;
        User user =jdbcTemplate.queryForObject(sql,new UserRowMapper(),name,password);
        return user;

    }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;public class UserRowMapper implements RowMapper&amp;lt;User&amp;gt; {
    @Override
    public User mapRow(ResultSet resultSet, int i) throws SQLException {
        //此处要使用表中的字段，不能使用属性
        int id =resultSet.getInt(&quot;id&quot;);
        String username = resultSet.getString(&quot;username&quot;);
        String password = resultSet.getString(&quot;password&quot;);
        //String role = resultSet.getString(&quot;role&quot;);

        User user = new User();
        user.setId(id);
        user.setName(username);
        user.setPassword(password);

        return user;
    }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;登录的方法啪啪啪很快就写好了，我要怎么让系统知道，所有的请求，要先进行登录呢，登录的URL是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看看别人的代码，貌似是实现了UserDetailsService 接口，而点进去发现该接口就一个方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;package org.springframework.security.core.userdetails;

public interface UserDetailsService {
    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　通过一个String类型的变量val1，获取用户的详细信息。。。怎么跟我想的不太一样？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;再点进去发现UserDetails 也是一个接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;package org.springframework.security.core.userdetails;

import java.io.Serializable;
import java.util.Collection;
import org.springframework.security.core.GrantedAuthority;

public interface UserDetails extends Serializable {
    Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities();

    String getPassword();

    String getUsername();

    boolean isAccountNonExpired();

    boolean isAccountNonLocked();

    boolean isCredentialsNonExpired();

    boolean isEnabled();
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　一个集合，收集权限，结合做过的项目，有的权限是超级管理员，有的权限是普通管理员，又或者有的删，有新增，有更新等等权限；两个返回String的方法；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有判断账户是否过期，被锁，验证是否过期，是否开启了。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　看来光看别人的代码，还是丈二和尚摸不着头脑呢，去看看官方文档吧&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://spring.io/projects/spring-security&quot; target=&quot;_blank&quot;&gt;https://spring.io/projects/spring-security&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://spring.io/guides/topicals/spring-security-architecture&quot; target=&quot;_blank&quot;&gt;https://spring.io/guides/topicals/spring-security-architecture&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;英文原文我就不粘贴了，翻译过来，大意就是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;应用程序权限归结于两个独立的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 你是谁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 你有什么样的权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般叫法是权限控制 或者 授权&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面开始讲框架中的源码，通过看源码可以了解设计的思路&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 授权策略中主要的接口是&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;typ&quot;&gt;AuthenticationManager&lt;/span&gt;&lt;/code&gt;，并且只有一个方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;public interface AuthenticationManager {

  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;

}　&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　验证管理员在方法authenticate()可以做三件事&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;a. 输入的信息是有效的当事人，验证通过，返回Authentication &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b. 输入的信息是无效的当事人，验证不通过，返回&lt;code&gt;AuthenticationException&lt;/code&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;c. 无法判断的时候，返回一个null&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看到这儿，就觉得我想通过查询 用户名 = 输入的用户名 且 密码 =输入密码的想法真是异想天开了。&lt;/span&gt;&lt;/p&gt;


&lt;h3 id=&quot;_creating_and_customizing_filter_chains&quot;&gt;&lt;span&gt;Filter Chains，过滤链，默认对所有的范文url进行过滤，意味着打开这个网站的任何链接，都弹出授权页面&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;而如果像如下的例子，则可以在foo下的下url不进行授权验证，说白了，不登录，这个url下也可以访问。 想想日常使用场景，比如总要有个注册页面吧，不能全面链接都要求登录。不注册如何登录呢？&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@Configuration
@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)
public class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.antMatcher(&quot;/foo/**&quot;)
     ...;
  }
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;用户登录了之后，要怎么查看个人信息，传入@AuthenticationPrincipal，当事人对象Principal principal&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@RequestMapping(&quot;/foo&quot;)
public String foo(@AuthenticationPrincipal User user) {
  ... // do stuff with user
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&lt;span&gt;@RequestMapping(&quot;/foo&quot;)
public String foo(Principal principal) {
  Authentication authentication = (Authentication) principal;
  User = (User) authentication.getPrincipal();
  ... // do stuff with user
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　使用规则介绍完了，花了两天把授权一个可用的项目的代码整理出来，贴上github路径&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/JasmineQian/buglist&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/JasmineQian/buglist&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其中用的是springboot 2.1.2 Realease 版本，和以前的版本稍微有一点区别，比如必须对密码加密校验，So存进去的密码处，必须加密之后存入数据库&lt;/p&gt;
&lt;pre readability=&quot;5&quot;&gt;
&amp;lt;parent&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;2.1.2.RELEASE&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;&lt;br/&gt;&amp;lt;/parent&amp;gt;&lt;p&gt;程序中验证的用户名和密码
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190216235659601-1158995310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
自己建一张表，叫做qa_user,添加如下数据&lt;br/&gt;2 admin $2a$10$A4EZrzoXqj4mVyXiw/fsp.mJ.Ne5aVAMWrMK0mAb2zY7lJ/H6Jryi admin ROLE_USER,ROLE_ADMIN
&lt;/pre&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 15:26:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>SpringSecurity核心功能：认证、授权、攻击防护（防止伪造身份） 涉及的依赖如下： 如上，原本启动项目后，在地址栏中输入http://localhost:8080/hello应该显示返回的内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10363504.html</dc:identifier>
</item>
<item>
<title>认识RabbitMQ交换机模型 - JJian</title>
<link>http://www.cnblogs.com/jian0110/p/10389780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jian0110/p/10389780.html</guid>
<description>&lt;blockquote readability=&quot;13.410740203193&quot;&gt;

&lt;p&gt;　　RabbitMQ是消息队列中间件（Message Queue Middleware）中一种，工作虽然有用到，但是却没有形成很好的整体包括，主要是一些基础概念的认识，这里通过阅读《RabbitMQ实战指南》整理笔记并进行代码实践，更好地理解RabbitMQ！&lt;/p&gt;
&lt;p&gt;本文只通过讲解RabbitMQ的一些基础概念，主要是RabbitMQ的“生产者-消费者”模型涉及到的交换器、路由键、绑定键、消息路由规则等，下一篇&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jian0110/p/10389986.html&quot;&gt;RabbitMQ是如何运转的？&lt;/a&gt;会有简单介绍RabbitMQ的运转、RabbitMQ部署，Java代码实践。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;需要电子书PDF版《RabbitMQ实战指南》（高清带标签）可以评论或者联系我&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;

&lt;p&gt;　　讲解RabbitMQ之前先认识下MQ作为消息中间件的作用（优点），使用的时候如果不去思考为什么用MQ，怎样更好地才能达到它的作用的话，那都是毫无意义的使用！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　   &lt;span&gt;1、解耦：&lt;/span&gt;&lt;/strong&gt;可以很好地屏蔽应用程序及平台之间的特性，充当中间者，松散耦合应用程序及平台，它们彼此不需要了解远程过程调用RPC与网络协议的细节；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;2、异步通信：&lt;/span&gt;&lt;/strong&gt;能提供C/S之间同步与异步连接，在任何时刻都可以将消息进行传送或者存储转发；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　   &lt;span&gt;&lt;span&gt;3、可恢复性：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;当消息接收方宕机或网络不通的情况下，消息转储于MQ中，直到网络恢复或接收方恢复再进行转发；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;4、扩展性：&lt;/span&gt;&lt;/strong&gt;提高消息入队列和处理效率是容易的，只需要另外增加处理过程即可，不需要改变代码，也不需要调节参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;5、顺序性：&lt;/span&gt;&lt;/strong&gt;由于大部分MQ支持队列模式，自然也就能保证一定的数据处理顺序；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;&lt;span&gt;6、缓冲&lt;/span&gt;：&lt;/span&gt;&lt;/strong&gt;MQ通过一个缓冲层来帮助任务最高效率执行，写入MQ的处理会尽可能快速。&lt;/p&gt;

&lt;p&gt;　　RabbitMQ整体的模型其实是一种&lt;span&gt;&lt;strong&gt;“生产者-消费者”&lt;/strong&gt;&lt;/span&gt;模型，发送消息的一方称之为生产者，接收消息一方称之为消费者。中间会有交换器、队列、Broker等概念。下图是简单的RabbitMQ的模型图（截图来自于《RabbitMQ实战指南》，以下截图同）&lt;/p&gt;

&lt;p&gt;　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216221233815-2034466708.png&quot; alt=&quot;&quot; width=&quot;767&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;　　1、生产者-消费者与RabbitMQ Broker　&lt;/h2&gt;
&lt;p&gt;　　　　（1）Producer：&lt;/p&gt;
&lt;p&gt;　　　　　　投递消息的一方，创建了消息之后发布到RabbitMQ中，&lt;span&gt;&lt;strong&gt;消息主要包括消息体（Payload）与Label标签&lt;/strong&gt;&lt;/span&gt;，消息体可以通常是业务数据，比如JSON等，Label则用来表述这条消息，比如一个交换机名称和一个路由键。&lt;/p&gt;
&lt;p&gt;生产者把消息交由RabbitMQ，之后会根据标签把消息发送给感兴趣的消费者。&lt;/p&gt;
&lt;p&gt;　　　　（2 Consumer：&lt;/p&gt;
&lt;p&gt;　　　　　　消费者，接收消息的一方，连接到RabbitMQ服务器，并订阅到队列上，&lt;span&gt;&lt;strong&gt;当消费者消费一条消息时只是消费了消息体payload，在消息路由过程中，消息的标签会丢失&lt;/strong&gt;&lt;/span&gt;，存入队列中只有消息体。消费者不需要知道生产者是谁。&lt;/p&gt;
&lt;p&gt;　　　　（3）Broker：&lt;/p&gt;
&lt;p&gt;　　　　　　消息中间件的服务节点，一个RabbitMQ Broker可以简单地看做一个RabbitMQ服务节或者RabbitMQ服务实例（&lt;span&gt;&lt;strong&gt;大多数情况下可以看做是一台RabbitMQ的服务器&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;　　　　由上图可知，消息队列运转过程是这样的：&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;&lt;strong&gt;封装好的消息发送（AMQP命令为Basic.publish）到Broker中，消费者订阅并接收（Basic.Get/Basic.Consume）消息，之后再进行业务逻辑处理（可以再开另外的进程，不需要与接收消息同一个进程）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216221802597-564341280.png&quot; alt=&quot;&quot; width=&quot;781&quot; height=&quot;439&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;　　　2、队列&lt;/h2&gt;
&lt;p&gt;　　　　　　　RabbitMQ中消息都只能存储在队列中，当多个消费者订阅一个队列时，队列中的消息会被平均分摊（Round-Robin），也就是并不是每个消费者都能收到所有的消息并处理。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216222034950-1552099377.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　注意以下几点：&lt;/p&gt;
&lt;p&gt;　　　　　　　　1）&lt;strong&gt;&lt;span&gt;对于生产者生产的消息到队列中，并不是平均分摊&lt;/span&gt;。&lt;/strong&gt;而是通过路由键、绑定键、交换器类型三个决定消息最终被哪个消费者消费，之后会介绍！&lt;/p&gt;
&lt;p&gt;　　　　　　　　2）&lt;span&gt;&lt;strong&gt;生产者与消费者之间的连接，并不只是通过队列那么简单连接&lt;/strong&gt;&lt;/span&gt;，而是外加通过TCP连接与信道Channel，之后也会介绍&lt;/p&gt;
&lt;h2&gt;　　　　3、交换器、路由键、绑定　　　&lt;/h2&gt;
&lt;p&gt;　　　　　　　　（1） &lt;strong&gt;交换器（Exchange, X&lt;/strong&gt;&lt;strong&gt;）：&lt;/strong&gt;由上图交换机模型图中看不到交换器这个东西，但实际上是存在的，生产者将消息投递到队列，然而真实情况是：&lt;strong&gt;&lt;span&gt;生产者将消息发送到Exchange，由Exchange再路由到一个或多个队列中；&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　　　　交换器的类型有fanout、direct、topic、headers这四种类型&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，不同的类型的交换器有其独特的匹配规则，这里的匹配规则其实就是决定消息最终路由到哪的队列的关键，具体请往下看&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216223218301-2069825942.png&quot; alt=&quot;&quot; width=&quot;584&quot; height=&quot;208&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　（2） &lt;strong&gt;路由键（RoutingKey&lt;/strong&gt;）：&lt;span&gt;&lt;strong&gt;生产者将消息发送给交换器的时候，会指定RoutingKey指定路由规则&lt;/strong&gt;&lt;/span&gt;，实际情况是需要将RoutingKey、交换器类型、绑定键联合使用才能最终生效。当交换器类型与BindingKey固定情况下，通过执行RoutingKey来决定消息流向哪里。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　（3）绑定（BindingKey）&lt;/strong&gt;：通过&lt;strong&gt;&lt;span&gt;绑定键将交换器与队列关联起来，这样RabbitMQ就知道如何正确地将消息路由到队列，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;其实绑定键也是一种路由键的一种，不过是用在绑定交换器与队列的时候。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216223437649-1474598574.png&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;225&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　&lt;span&gt;　&lt;strong&gt;总结有以下三点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　　　　　&lt;/strong&gt;（1）&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;strong&gt;生产者将消息发送给哪个Exchange是需要由RoutingKey决定的，生产者需要将Exchange与哪个队列绑定时需要由BindingKey决定的&lt;/strong&gt;&lt;/span&gt;（当然还要看交换器类型，BindingKey不一定会生效，如fanout类型交换器）；&lt;/p&gt;
&lt;p&gt;　　　　　　　   　　（2） 生产者将消息发送给交换器时，需要一个RoutingKey，&lt;span&gt;&lt;strong&gt;当BindingKey和RoutingKey相匹配时，消息会被路由到对象的队列中&lt;/strong&gt;&lt;/span&gt;（当然也要看交换器类型）。&lt;/p&gt;
&lt;p&gt;　　　　　　　   　　（3） &lt;span&gt; &lt;strong&gt;BindingKey其实也属于路由键的一种&lt;/strong&gt;&lt;/span&gt;，在使用邦定的时候，需要的路由键是BingdingKey，在发送消息的时，需要的路由键是RoutingKey&lt;/p&gt;
&lt;h2&gt;　　　　4、交换器类型&lt;/h2&gt;
&lt;p&gt;　　　　　　　　为什么非要介绍交换器类型呢？上文中也提到过交换器类型关系到具体的消息路由途径，处路由键、绑定键之外的还需要关注交换器的类型。不同的交换器会有不同的匹配规则。&lt;/p&gt;
&lt;p&gt;　　　　　　　　RabbitMQ常用的交换器类型有fanout、direct、topic、headers这四种类型&lt;/p&gt;
&lt;p&gt;　　　　　　　　（1）&lt;strong&gt;fanout&lt;/strong&gt;：&lt;span&gt;&lt;strong&gt;它会把所有的交换器上的消息路由到所有与该交换器邦定的队列中，不需要BindingKey生效&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　（2）&lt;strong&gt;direct&lt;/strong&gt;：它会把&lt;span&gt;&lt;strong&gt;消息路由到BindingKey与RoutingKey完全匹配的队列中&lt;/strong&gt;&lt;/span&gt;。比如在发送消息的时候，设置Label中RoutingKey为warning，则消息会路由到Queue1与Queue2上（请看下图）。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216225028044-974382944.png&quot; alt=&quot;&quot; width=&quot;745&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　（3）&lt;strong&gt;topic&lt;/strong&gt;：是direct上的扩展，&lt;span&gt;&lt;strong&gt;同样是利用RoutingKey与BindingKey相匹配，但是匹配规则不一样，支持模糊匹配&lt;/strong&gt;。&lt;/span&gt;有如下的规则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;RoutingKey为一个点号“.”分隔的字符串，每个被隔开的独立字符串即为一个单词，是匹配的单位；&lt;/li&gt;
&lt;li&gt;BindingKey和RoutingKey一样，也是&quot;.&quot;分割的字符串；&lt;/li&gt;
&lt;li&gt;但不同的是BindingKey，可以用“#”，“*”进行类似于占位符的模糊匹配，“#”表示一个单词，&quot;*&quot;表示多个单词（也可以是零个）　　　　　　　　　　　　　　　　　&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　　　　　　　比如:&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　RoutingKey为com.hidden.client的消息只会到队列Queue2中：因为只有Queue2的BindingKey=*.*.client匹配com.hidden.client&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　RoutingKey为com.rabbitmq.client的消息会到队列Queue1-2中: 因为Queue1的BindingKey=*.rabbitmq.*.匹配com.rabbitmq.client，Queue2的BindingKey=*.*.client匹配com.rabbitmq.client&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　RoutingKey为java.rabbitmq.demo的消息只会到队列Queue1中：因为只有Queue1的BindingKey=*.rabbitmq.*.匹配java.rabbitmq.demo&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　RoutingKey为java.util.concurrent的消息会被丢弃或者返回给生产者（需要设置）&lt;/p&gt;
&lt;p&gt; 　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1352849/201902/1352849-20190216225124446-896629330.png&quot; alt=&quot;&quot; width=&quot;732&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　　　　　　　（4）&lt;strong&gt;headers&lt;/strong&gt;：依赖发送消息内容中的hearders属性进行匹配，在绑定队列和交换器时指定一组键值对，这里的也就是headers，当发送消息到交换器时，RabbitMQ会获取到该消息的headers，通过比较会路由到相关队列中，这种交换器性能会很差，一般不会使用。&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;　　　　　&lt;span&gt;以上内容总结起来只是介绍了RabbitMQ的从生产者产生消息到消费者消费消息过程中涉及到的概念。还未介绍具体的RabbitMQ是如何运转的，比如生产者是怎样建立连接生成消息的，消费者又是怎样读取消息的，这将是下一篇&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/jian0110/p/10389986.html&quot;&gt;RabbitMQ是如何运转的？&lt;/a&gt;&lt;span&gt;主要介绍的。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 15:17:00 +0000</pubDate>
<dc:creator>JJian</dc:creator>
<og:description>前言 RabbitMQ是消息队列中间件（Message Queue Middleware）中一种，工作虽然有用到，但是却没有形成很好的整体包括，主要是一些基础概念的认识，这里通过阅读《RabbitMQ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jian0110/p/10389780.html</dc:identifier>
</item>
<item>
<title>观察者模式 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/10389751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/10389751.html</guid>
<description>&lt;p&gt;当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解释：&lt;span&gt;简单来说对象 A 需要关注对象 B 的状态，根据对象 B 的不同状态来做一些调整。比如播放器的 UI 变化，会依赖当前的播放状态，一旦播放状态改变了，就需要调整 UI 的显示。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。&lt;/li&gt;
&lt;/ul&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个对象必须通知其他对象，而并不知道这些对象是谁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;根据上面说的，下面我们来实现一个简单的观察者模式。&lt;/p&gt;
&lt;h2&gt; 观察者&lt;/h2&gt;
&lt;p&gt;先定义一个观察者接口，具体的观察者都需要实现该接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
 * 抽象观察者
 * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Observer {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(String message);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着，就是一个具体的观察者，在 update 中添加数据改变后的操作逻辑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 观察者
 * 实现了update方法
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; User &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Observer {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String message;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; User(String name) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; update(String message) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; message;
        read();
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; read() {
        System.out.println(name &lt;/span&gt;+ &quot; 收到推送消息： &quot; +&lt;span&gt; message);
    }
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt; 被观察者&lt;/h2&gt;
&lt;p&gt;同样的，需要定义一个被观察者接口，所有具体的被观察者对象都需要实现该接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
 * 抽象被观察者接口
 * 声明了添加、删除、通知观察者方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Observerable {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerObserver(Observer o);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeObserver(Observer o);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notifyObserver();
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 定义具体的被观察者对象，实现了 Observerable 接口，对 Observerable 接口的三个方法进行了具体实现，同时有一个 List 集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 被观察者，也就是微信公众号服务
 * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; WechatServer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Observerable {
    
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; List&amp;lt;Observer&amp;gt;&lt;span&gt; list;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String message;
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WechatServer() {
        list &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Observer&amp;gt;&lt;span&gt;();
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; registerObserver(Observer o) {
        
        list.add(o);
    }
    
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; removeObserver(Observer o) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;list.isEmpty())
            list.remove(o);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notifyObserver() {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; list.size(); i++&lt;span&gt;) {
            Observer oserver &lt;/span&gt;=&lt;span&gt; list.get(i);
            oserver.update(message);
        }
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setInfomation(String s) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.message =&lt;span&gt; s;
        System.out.println(&lt;/span&gt;&quot;微信服务更新消息： &quot; +&lt;span&gt; s);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;消息更新，通知所有观察者&lt;/span&gt;
&lt;span&gt;        notifyObserver();
    }

}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;代码测试&lt;/h2&gt;
&lt;p&gt;完成上面的工作之后，咱们就可以测试咱们写的代码了，看看能不能跑起来。具体如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.sjq.observer;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        WechatServer server &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WechatServer();
        
        Observer userZhang &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;ZhangSan&quot;&lt;span&gt;);
        Observer userLi &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;LiSi&quot;&lt;span&gt;);
        Observer userWang &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;WangWu&quot;&lt;span&gt;);
        
        server.registerObserver(userZhang);
        server.registerObserver(userLi);
        server.registerObserver(userWang);
        server.setInfomation(&lt;/span&gt;&quot;PHP是世界上最好用的语言！&quot;&lt;span&gt;);
        
        System.out.println(&lt;/span&gt;&quot;----------------------------------------------&quot;&lt;span&gt;);
        server.removeObserver(userZhang);
        server.setInfomation(&lt;/span&gt;&quot;JAVA是世界上最好用的语言！&quot;&lt;span&gt;);
        
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt; Android 中 Adapter 应用广泛，其实在 adapter 中就存在观察者模式得应用。比如 ListView, 当我们调用 setAdapter() 时候，内部是通过观察者模式来通知数据变化的，当数据发生变化，就会通知 ListView 自身去重新绘制。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;BrocastReceive 广播。有动态注册和静态注册，其实也是观察者模式得一种应用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;另外经常可见一些 addXXXListener 方法，其实这类也可以当做是观察者的一种体现。 &lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1、&lt;a href=&quot;http://www.runoob.com/design-pattern/observer-pattern.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.runoob.com/design-pattern/observer-pattern.html&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2、&lt;/span&gt;&lt;/span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/luohanguo/p/7825656.html&quot;&gt;JAVA设计模式之观察者模式&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Feb 2019 15:13:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>定义 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 解释：简单来说对象 A 需要关注对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huansky/p/10389751.html</dc:identifier>
</item>
<item>
<title>当我们讨论性能测试时，我们在说什么？ - 老_张</title>
<link>http://www.cnblogs.com/imyalost/p/10353954.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imyalost/p/10353954.html</guid>
<description>&lt;p&gt;&lt;span&gt;说起性能测试，大家会想到哪些词？录制脚本、模拟高并发？性能需求分析、业务流程梳理？监控资源耗用、性能瓶颈定位？优化代码处理逻辑、提升服务器配置？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但这真的是性能测试的本质和最终目的么？这篇博客，聊聊我对软件性能的一些看法和思考。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先明确一点：&lt;strong&gt;技术的存在是为了解决实际的业务发展中遇到的问题和痛点！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着互联网时代不断深入生活工作的各方面，绝大多数的软件系统都会面临如下三个挑战：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、日益增长的用户数量；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、日渐复杂的业务场景；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、急剧膨胀的数据冲击；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这对于软件系统而言，就意味着&lt;strong&gt;及时高效的处理能力、更好的服务可用性以及长期运行的稳定性&lt;/strong&gt;等要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从以上几点要求出发，站在性能测试的角度，来谈谈我们需要注意哪些事项。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更及时高效的处理能力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983980/201902/983980-20190216194236769-603424060.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;305&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在互联网最初的年代，有二五八原则一说。意思就是对用户而言，在页面做一个功能操作，如果能在2秒能出现用户期待的内容，那么用户体验就是比较好的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果5秒之内可以返回结果，那么对用户来说就是可以接受的范围，如果超过8秒，绝大多数用户就会选择离开或退出该页面。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然这只是一个笼统的概念，但也能看出用户对软件系统处理能力的容忍性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;近几年随着网络通讯技术的不断发展，以及硬件设施的不断提升，导致用户对软件处理能力越来越低的容忍力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从性能优化角度出发，就需要我们尽力&lt;strong&gt;保持和降低系统的99%RT&lt;/strong&gt;（即一段时间内请求响应时间从低到高排序，低于99%响应时间的上限边界值）的同时，&lt;strong&gt;提高单位时间内的处理能力&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;请求响应时间=请求发送耗时+请求解析耗时+请求处理耗时+处理结果返回耗时&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提高处理能力和降低响应时间，有很多技术方案可以实现，比如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提高网络传输速率、优化请求传输方式（串行→并行→连接复用→管道化）、增加缓存、优化代码处理方式、增加处理请求的机器数量、提升机器配置等方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;更好的服务可用性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983980/201902/983980-20190216194032435-70437758.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是可用性（Usability）？可用性实际上并不是一个具体的东西，也没有明确的定义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个人觉得Jakob Nielsen大师提出的可用性五大属性，就很客观全面的介绍了可用性的特点，它们分别是：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可学习性（Learnability）&lt;/strong&gt;：初次接触这个设计时，用户完成基本任务的难易程度；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;效率 （Efficiency）&lt;/strong&gt;：用户能多快完成任务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;可记忆性（Memorability）&lt;/strong&gt;：当用户一段时间没有使用产品后，是否能马上回到以前的熟练程度；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;出错（Errors）&lt;/strong&gt;：用户能否从错误中恢复（从系统角度出发，可以理解为容错性）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;满意度（Satisfaction）：&lt;/strong&gt;用户对产品的主观满意度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果真要给出一个定义，那么我们可以这样理解：&lt;strong&gt;可用性是指在特定的使用场景下，产品为特定用户用于特定目的时所具有的有效性、效率和主观满意度&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从可用性五大属性出发，站在性能优化角度，就要求我们做如下的一些事情，来不断提升软件服务可用性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可学习性：尽可能减少用户操作的步骤，优化业务逻辑；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;效率：提升响应时间和系统的处理能力（回到上面提到的及时高效的处理能力）；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可记忆性：人性化的提示，导航能力，是否符合特定用户的操作习惯；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出错：提升系统的容错能力和恢复能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;满意度：提高用户体验，做好用户需求调研和场景建模分析；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只讨论技术保障方案，我们需要做好服务治理、服务解耦，通过主从模式、系统集群负载均衡、双机双工、分布式等方式，来保证系统在高可用的同时，降低故障恢复时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;长期运行的稳定性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/983980/201902/983980-20190216194605915-1405873640.png&quot; alt=&quot;&quot; width=&quot;667&quot; height=&quot;374&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说，系统的稳定性指标要求7*24小时或者5*8小时，系统的存活时间越长，意味着系统越稳定，这个要根据系统具体的业务定位来确定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;现在而言，系统的稳定性要求已经不仅仅是存活时间，还要求运行过程中的&lt;strong&gt;保持服务的高可用、及时处理能力、容错能力以及出现故障的及时恢复能力&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么如何保证系统的稳定性呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;容错能力&lt;/strong&gt;：即系统对于自身出现的错误具有一定的屏蔽或处理能力。常见的容错手段包括如下几点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①、失败重试机制；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②、多机备份自动切换；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③、设置合理的TimeOut；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④、服务解耦，微服务模式；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;⑤、权重选举，服务降级；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多阅读：&lt;a href=&quot;https://blog.csdn.net/tanga842428/article/details/79664605&quot; target=&quot;_blank&quot;&gt;亿级web系统的高容错性实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;故障恢复能力&lt;/strong&gt;：即系统能否从出错或故障中及时恢复正常服务水平的能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般来说会根据故障的严重等级和优先级，确定不同等级的故障需要在多久时间内恢复正常提供服务的能力。常见的故障有如下几种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①、硬件及有关设备故障；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②、软件系统故障；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③、数据故障；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;④、网络故障；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了应对如上的几种故障，常见的一些容灾恢复方案有如下几种：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①、系统需要具有自我诊断、故障报告及指示处理方法的能力，以及具备冗余及自动切换能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②、监控到故障发生时，系统需要具备及时隔离、服务降级、服务快速切换的能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;③、主从热备，多机冷备，异地多活等措施；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更多阅读：&lt;a href=&quot;https://blog.csdn.net/xiaokuang513204/article/details/8629415&quot; target=&quot;_blank&quot;&gt;不容忽视的软件可恢复测试&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回到开头提到的内容：&lt;strong&gt;技术的存在是为了解决实际的业务发展中遇到的问题和痛点！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着业务的不断发展，软件系统面临着&lt;strong&gt;日益增长的用户数量、日渐复杂的业务场景以及急剧膨胀的数据冲击&lt;/strong&gt;这几种挑战。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这就要求我们的系统具有&lt;strong&gt;及时高效的处理能力、更好的服务可用性以及长期运行的稳定性&lt;/strong&gt;等要求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了解决这几点挑战，使系统具有所要求的能力，我们需要&lt;strong&gt;通过性能测试来验证系统是否具有我们所期望的能力&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们通过&lt;strong&gt;完善性能测试流程，优化性能测试工具，采用不同性能测试方法，在各种环境和条件下进行测试，全方位监控，定位分析性能瓶颈，针对性的进行优化&lt;/strong&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终的目的是希望系统具有&lt;strong&gt;及时高效的处理能力，更好的服务可用性和长期运行的稳定性&lt;/strong&gt;，来满足系统面临的种种挑战，为业务的发展提供更好的服务保障！&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 16 Feb 2019 15:07:00 +0000</pubDate>
<dc:creator>老_张</dc:creator>
<og:description>说起性能测试，大家会想到哪些词？录制脚本、模拟高并发？性能需求分析、业务流程梳理？监控资源耗用、性能瓶颈定位？优化代码处理逻辑、提升服务器配置？ 但这真的是性能测试的本质和最终目的么？这篇博客，聊聊我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imyalost/p/10353954.html</dc:identifier>
</item>
<item>
<title>从零开始单排学设计模式「装饰模式」黑铁 I - LonelyKeyGuest</title>
<link>http://www.cnblogs.com/gdjk/p/10389642.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gdjk/p/10389642.html</guid>
<description>&lt;p&gt;阅读本文大概需要 3.6 分钟。&lt;/p&gt;

&lt;p&gt;本篇是设计模式系列的第四篇，虽然之前也写过相应的文章，但是因为种种原因后来断掉了，而且发现之前写的内容也很渣，不够系统。&lt;/p&gt;

&lt;p&gt;所以现在打算重写，加上距离现在也有一段时间了，也算是自己的一个回顾吧！&lt;/p&gt;

&lt;p&gt;学而时习之，不亦说乎。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485514&amp;amp;idx=1&amp;amp;sn=dd33498d72c50d7facad6f14957f022a&amp;amp;chksm=fa24f722cd537e342f293ce08831d1e7bd31b412be743a2dfeaa0f8f60414e32b726e3478b90&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485514&amp;amp;idx=1&amp;amp;sn=dd33498d72c50d7facad6f14957f022a&amp;amp;chksm=fa24f722cd537e342f293ce08831d1e7bd31b412be743a2dfeaa0f8f60414e32b726e3478b90&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始单排学设计模式「UML类图」定级赛&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485515&amp;amp;idx=1&amp;amp;sn=ad61fd16a315fa15acca3074a0406dca&amp;amp;chksm=fa24f723cd537e35095ff4a2e7d150f63cfaa46378b588abbb7a4548d86ecc9806cee8f6ab57&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485515&amp;amp;idx=1&amp;amp;sn=ad61fd16a315fa15acca3074a0406dca&amp;amp;chksm=fa24f723cd537e35095ff4a2e7d150f63cfaa46378b588abbb7a4548d86ecc9806cee8f6ab57&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始单排学设计模式「简单工厂设计模式」黑铁 III&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485617&amp;amp;idx=1&amp;amp;sn=f38fd9b9a63ac7ade48391a8a564b7c6&amp;amp;chksm=fa24f7d9cd537ecfa25a3e911be6754b01e8c6a25f96b3a523b3d75f578082d9ed12d800c4be&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485617&amp;amp;idx=1&amp;amp;sn=f38fd9b9a63ac7ade48391a8a564b7c6&amp;amp;chksm=fa24f7d9cd537ecfa25a3e911be6754b01e8c6a25f96b3a523b3d75f578082d9ed12d800c4be&amp;amp;scene=21#wechat_redirect&quot;&gt;从零开始单排学设计模式「策略模式」黑铁 II&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;目前段位：&lt;strong&gt;黑铁 I&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36Ba9cUE7U4f1yJOrEDGA3IthTMOombgIog0M2B8VnxsAw6ggzMbNBrRKbIesUjiaWGX5oet94IU20w/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36Ba9cUE7U4f1yJOrEDGA3IthTMOombgIog0M2B8VnxsAw6ggzMbNBrRKbIesUjiaWGX5oet94IU20w/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36Ba9cUE7U4f1yJOrEDGA3IthTMOombgIog0M2B8VnxsAw6ggzMbNBrRKbIesUjiaWGX5oet94IU20w/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Let's Go！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设计模式不是语法，是一种巧妙的写法，能把程序变的更加灵活。架构模式比设计模式大，架构模式是战略，而设计模式是战术。&lt;/p&gt;

&lt;p&gt;设计模式分为3大类型：创建型，行为型，结构型，总共有23种。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;装饰模式&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;装饰模式（Decorator）指的是在不必改变类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。&lt;/p&gt;

&lt;p&gt;这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;业务需求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;公司接到一个任务，需要为某平台开发一个搭配不同服饰的小项目，比如类似QQ、网络游戏或论坛都有的Avatar系统（为了简化代码，直接使用控制台模拟）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;经过公司的慎重讨论（实际就几秒钟），开发这一个项目的重任，又当仁不让的被产品经理交给了我，我：脸上笑嘻嘻，心里MMP。发一下下的小牢骚，不过还是抓紧干活。&lt;/p&gt;

&lt;p&gt;思索一下，该系统要为不同的人进行装扮，所以定义一个人的类，不用每次装扮其他人时修改该类的代码。&lt;/p&gt;

&lt;p&gt;然后人身上要有很多的服饰，比如：大T恤、垮裤、鞋子等等，然后穿上之后，需要展示出来。所以这里的话，可以抽象出一个服饰的基类，然后各个具体的服饰都继承该基类即可。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;Person类&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;6&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class Person {&lt;p&gt;private String name;&lt;br/&gt;public Person() {&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public Person(String name) {&lt;br/&gt;this.name = name;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public void show() {&lt;br/&gt;System.out.println(&quot;装扮者：&quot; + name);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服装抽象类&lt;/p&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;5&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class Finery extends Person {&lt;p&gt;protected  Person component;&lt;br/&gt;/**&lt;br/&gt;* 打扮&lt;br/&gt;* @param component&lt;br/&gt;*/&lt;br/&gt;public void decorate(Person component){&lt;br/&gt;this.component = component;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;if(null != component){&lt;br/&gt;component.show();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体服饰类&lt;/p&gt;
&lt;pre readability=&quot;14&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;22&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class TShirts extends Finery {&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;大T恤&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class BigTrouser extends Finery {&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;垮裤&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Sneakers extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;破球鞋&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class LeatherShoes extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;皮鞋&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Tie extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;领带&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Suit extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;西装&quot;);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里内部类，只是为了较少代码量，实际开发中可不要偷懒，按实际来创建。&lt;/p&gt;

&lt;p&gt;客户端代码&lt;/p&gt;
&lt;pre readability=&quot;11.5&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;17&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class Main {&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;&lt;p&gt;Person person = new Person(&quot;孤独键客&quot;);&lt;/p&gt;&lt;p&gt;System.out.println(&quot;第一种装扮：&quot;);&lt;/p&gt;&lt;p&gt;Finery tShirts = new TShirts();&lt;br/&gt;Finery bigTrouser = new BigTrouser();&lt;br/&gt;Finery sneakers = new Sneakers();&lt;/p&gt;&lt;p&gt;tShirts.show();&lt;br/&gt;bigTrouser.show();&lt;br/&gt;sneakers.show();&lt;br/&gt;person.show();&lt;/p&gt;&lt;p&gt;System.out.println(&quot;\n第二种装扮：&quot;);&lt;/p&gt;&lt;p&gt;Finery suit = new Suit();&lt;br/&gt;Finery tie = new Tie();&lt;br/&gt;Finery leatherShoes = new LeatherShoes();&lt;/p&gt;&lt;p&gt;suit.show();&lt;br/&gt;tie.show();&lt;br/&gt;leatherShoes.show();&lt;br/&gt;person.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;代码简单搞定，接下来来看一下运行结果&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZTJVD1kIl59pB9Zibrv7ArC9HGuQ3mFgCrJqddCibVUouMseCd8bJU0Aw/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZTJVD1kIl59pB9Zibrv7ArC9HGuQ3mFgCrJqddCibVUouMseCd8bJU0Aw/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZTJVD1kIl59pB9Zibrv7ArC9HGuQ3mFgCrJqddCibVUouMseCd8bJU0Aw/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;搞定收工，审视一下，自我感觉还算不错，如果新装扮只需改变一下调用顺序即可，如果又新人物，只需重新new一个Person类就可以了。&lt;/p&gt;

&lt;p&gt;接下里将项目提交上传，然后告诉leader一声，over，离下班时间还早，好像还可以做点其他的事情~。&lt;/p&gt;

&lt;p&gt;正当你准备打开去干点其他事情，leader回复你了：&lt;/p&gt;

&lt;p&gt;leader：“你仔细看看这段代码，这样写意味着什么？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZr64LHY9x78KzsJOp24BDsSMH1icSTyMYytliaoUr7AHlqlHs5ft0SpLA/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZr64LHY9x78KzsJOp24BDsSMH1icSTyMYytliaoUr7AHlqlHs5ft0SpLA/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZr64LHY9x78KzsJOp24BDsSMH1icSTyMYytliaoUr7AHlqlHs5ft0SpLA/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;你想象一下，是不是把‘大T恤’、‘垮裤’、‘破球鞋’、‘装扮者’一个一个词显示出来，是不是相当于你光着身子，一个一个把这些穿上，这可有点像脱衣舞哦~”。&lt;/p&gt;

&lt;p&gt;我：“你意思是，这些应该都在内部组装完毕，然后在显示出来？”。&lt;/p&gt;

&lt;p&gt;leader：&quot;宾果，而且还要按照正确的顺序串联起来控制，这里有点难度，修改好之后再给我&quot;。&lt;/p&gt;

&lt;p&gt;这似乎和某种设计模式有关，难道是建造者模式吗？不对，建造者模式要求建造的过程必须是稳定的，而这个穿搭的过程是不固定的，一个有个性的人又无数种方案。&lt;/p&gt;

&lt;p&gt;经过一番查找，这恰恰最适合用装饰模式了。&lt;/p&gt;

&lt;p&gt;我们修改一下具体的服饰类&lt;/p&gt;
&lt;pre readability=&quot;14&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;22&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class TShirts extends Finery {&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;大T恤&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class BigTrouser extends Finery {&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;垮裤&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Sneakers extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;破球鞋&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class LeatherShoes extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;皮鞋&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Tie extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;领带&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Suit extends Finery{&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void show() {&lt;br/&gt;System.out.println(&quot;西装&quot;);&lt;br/&gt;super.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再修改一下客户端代码：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;language-html hljs&quot; readability=&quot;7&quot;&gt;/**&lt;br/&gt;* @author: LKP&lt;br/&gt;* @date: 2019/2/16&lt;br/&gt;*/&lt;br/&gt;public class Main {&lt;p&gt;public static void main(String[] args) {&lt;/p&gt;&lt;p&gt;Person person = new Person(&quot;孤独键客&quot;);&lt;br/&gt;System.out.println(&quot;第一种装扮：&quot;);&lt;br/&gt;Sneakers sneakers = new Sneakers();&lt;br/&gt;BigTrouser bigTrouser = new BigTrouser();&lt;br/&gt;TShirts tShirts = new TShirts();&lt;br/&gt;sneakers.decorate(person);&lt;br/&gt;bigTrouser.decorate(sneakers);&lt;br/&gt;tShirts.decorate(bigTrouser);&lt;br/&gt;tShirts.show();&lt;br/&gt;System.out.println(&quot;第二种装扮：&quot;);&lt;br/&gt;LeatherShoes leatherShoes = new LeatherShoes();&lt;br/&gt;Tie tie = new Tie();&lt;br/&gt;Suit suit = new Suit();&lt;br/&gt;leatherShoes.decorate(person);&lt;br/&gt;tie.decorate(leatherShoes);&lt;br/&gt;suit.decorate(tie);&lt;br/&gt;suit.show();&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二版的程序写完了，来测试一下&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZdby1fymmYkqNmF6xtQQX3NwV4OQaKWbbMiaMzcLB9E5JrAyWSFf7hqQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZdby1fymmYkqNmF6xtQQX3NwV4OQaKWbbMiaMzcLB9E5JrAyWSFf7hqQ/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZdby1fymmYkqNmF6xtQQX3NwV4OQaKWbbMiaMzcLB9E5JrAyWSFf7hqQ/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;完美搞定，哈哈，我还可以换种装饰方式&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZzmPVf2vzqQ7RPctCApz2MeDaWBnoJACP4JR85D9SUfeMelHDpvHCwA/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZzmPVf2vzqQ7RPctCApz2MeDaWBnoJACP4JR85D9SUfeMelHDpvHCwA/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZzmPVf2vzqQ7RPctCApz2MeDaWBnoJACP4JR85D9SUfeMelHDpvHCwA/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;看下结果&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZyib6kHfsvQAZmCUQB44dlL951B2MfEzUGqibGDaXI5qRIf2LqLiboXX5A/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZyib6kHfsvQAZmCUQB44dlL951B2MfEzUGqibGDaXI5qRIf2LqLiboXX5A/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZyib6kHfsvQAZmCUQB44dlL951B2MfEzUGqibGDaXI5qRIf2LqLiboXX5A/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;光着膀子、打着领带、下身垮裤、脚上皮鞋，绝对的极具个性。&lt;/p&gt;

&lt;p&gt;最后，完美搞定，提交代码~~~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;装饰模式UML类图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZUYvnT1u9EO3LLjPEnUJ2MGlUELGE9dialQN9fVgpWGYHrE1nZ31tkoA/640?wx_fmt=png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZUYvnT1u9EO3LLjPEnUJ2MGlUELGE9dialQN9fVgpWGYHrE1nZ31tkoA/640?wx_fmt=png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://mmbiz.qpic.cn/mmbiz_png/TeYk478W36AMsMtuwgjHeEjAfsP4zuibZUYvnT1u9EO3LLjPEnUJ2MGlUELGE9dialQN9fVgpWGYHrE1nZ31tkoA/640?wx_fmt=png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;来总结一下装饰模式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主要解决&lt;/strong&gt;：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;何时使用&lt;/strong&gt;：在不想增加很多子类的情况下扩展类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何解决&lt;/strong&gt;：将具体功能职责划分，同时继承装饰者模式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关键代码&lt;/strong&gt;： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应用实例&lt;/strong&gt;： 1、孙悟空有 72 变，当他变成&quot;庙宇&quot;后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：多层装饰比较复杂。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用场景&lt;/strong&gt;： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;：可代替继承。&lt;/p&gt;



&lt;p&gt;往期精彩回顾&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485704&amp;amp;idx=1&amp;amp;sn=dd8dc47d1f3c5de77640173bf84a733d&amp;amp;chksm=fa24f660cd537f764ebc0c0c0f823cde04f1db54be1f199e62a82374e7bfbf4eadf981673dff&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485704&amp;amp;idx=1&amp;amp;sn=dd8dc47d1f3c5de77640173bf84a733d&amp;amp;chksm=fa24f660cd537f764ebc0c0c0f823cde04f1db54be1f199e62a82374e7bfbf4eadf981673dff&amp;amp;scene=21#wechat_redirect&quot;&gt;每秒 570000 的写入，如何实现？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485693&amp;amp;idx=1&amp;amp;sn=993ef5ada4c0872c2e7394d6271bf6d7&amp;amp;chksm=fa24f795cd537e83058c47343ddbea31b4784d24c13fdd31dfdf953e6f76cafb65b284fdc4c7&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485693&amp;amp;idx=1&amp;amp;sn=993ef5ada4c0872c2e7394d6271bf6d7&amp;amp;chksm=fa24f795cd537e83058c47343ddbea31b4784d24c13fdd31dfdf953e6f76cafb65b284fdc4c7&amp;amp;scene=21#wechat_redirect&quot;&gt;这40张图送给单身程序员，情人节请一笑而过！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485672&amp;amp;idx=1&amp;amp;sn=8266c9dd7b0feb9e88f9394b7878ba3f&amp;amp;chksm=fa24f780cd537e96b4636cf22c6e12ddb754754573abf68ce8510989219926644801b3dcb06c&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485672&amp;amp;idx=1&amp;amp;sn=8266c9dd7b0feb9e88f9394b7878ba3f&amp;amp;chksm=fa24f780cd537e96b4636cf22c6e12ddb754754573abf68ce8510989219926644801b3dcb06c&amp;amp;scene=21#wechat_redirect&quot;&gt;IDEA一定要懂的32条快捷键&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485647&amp;amp;idx=1&amp;amp;sn=73f29d6d2f41dcc64dded00bd69ae424&amp;amp;chksm=fa24f7a7cd537eb109fd567a8c51fe5e477be0f1da3ecde7f00a9a66e32798a4969f13004515&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485647&amp;amp;idx=1&amp;amp;sn=73f29d6d2f41dcc64dded00bd69ae424&amp;amp;chksm=fa24f7a7cd537eb109fd567a8c51fe5e477be0f1da3ecde7f00a9a66e32798a4969f13004515&amp;amp;scene=21#wechat_redirect&quot;&gt;世上最污技术解读，我竟然秒懂了。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485600&amp;amp;idx=1&amp;amp;sn=35e8908b04cfcedf94b750c28f3ff3dc&amp;amp;chksm=fa24f7c8cd537edef9bfc9bbca206fc4ea12ac13f38e91b107a939f6a47f9c83182289280081&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485600&amp;amp;idx=1&amp;amp;sn=35e8908b04cfcedf94b750c28f3ff3dc&amp;amp;chksm=fa24f7c8cd537edef9bfc9bbca206fc4ea12ac13f38e91b107a939f6a47f9c83182289280081&amp;amp;scene=21#wechat_redirect&quot;&gt;Bing挂了！百度又“赢了”&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485611&amp;amp;idx=1&amp;amp;sn=ab272b10c23f3b3371dc4b3f276ebe2a&amp;amp;chksm=fa24f7c3cd537ed5cb66b732ee4e25cb690613c5d86b80e28d437954a784cb7827a67213b9ec&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485611&amp;amp;idx=1&amp;amp;sn=ab272b10c23f3b3371dc4b3f276ebe2a&amp;amp;chksm=fa24f7c3cd537ed5cb66b732ee4e25cb690613c5d86b80e28d437954a784cb7827a67213b9ec&amp;amp;scene=21#wechat_redirect&quot;&gt;遇到卖茶女，应该如何优雅的回复她&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485610&amp;amp;idx=1&amp;amp;sn=cbdaac7255fb609635d498bdc4a63ac3&amp;amp;chksm=fa24f7c2cd537ed4dd44af682fc9f3557d3bc8d76b6230aa08597537ec6973a8f556df431862&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485610&amp;amp;idx=1&amp;amp;sn=cbdaac7255fb609635d498bdc4a63ac3&amp;amp;chksm=fa24f7c2cd537ed4dd44af682fc9f3557d3bc8d76b6230aa08597537ec6973a8f556df431862&amp;amp;scene=21#wechat_redirect&quot;&gt;我被程序员坑了600万致公司倒闭，当事人逐条反驳：这锅我不背&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485440&amp;amp;idx=1&amp;amp;sn=068d918afea5b554e5d944a4dc192048&amp;amp;chksm=fa24f768cd537e7e055f1c5d9a2b0868f04449877d7e4a9a2d26137f1201f92a35ddbb362119&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485440&amp;amp;idx=1&amp;amp;sn=068d918afea5b554e5d944a4dc192048&amp;amp;chksm=fa24f768cd537e7e055f1c5d9a2b0868f04449877d7e4a9a2d26137f1201f92a35ddbb362119&amp;amp;scene=21#wechat_redirect&quot;&gt;一千行MySQL详细学习笔记（值得学习与收藏）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485436&amp;amp;idx=1&amp;amp;sn=d95c4c615d4430e23904c9ce66dbb284&amp;amp;chksm=fa24f894cd537182ddb81c28d30dd34523623819eb47625052ba9ac07cdf1ac58cb230c7962b&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyNDkzNzczNQ==&amp;amp;mid=2247485436&amp;amp;idx=1&amp;amp;sn=d95c4c615d4430e23904c9ce66dbb284&amp;amp;chksm=fa24f894cd537182ddb81c28d30dd34523623819eb47625052ba9ac07cdf1ac58cb230c7962b&amp;amp;scene=21#wechat_redirect&quot;&gt;七点建议助您写出优雅的Java代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/16/168f6bf9671adaf3?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27279&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号「程序员的成长之路」，阅读更多精彩！  &lt;/p&gt;
</description>
<pubDate>Sat, 16 Feb 2019 14:49:00 +0000</pubDate>
<dc:creator>LonelyKeyGuest</dc:creator>
<og:description>阅读本文大概需要 3.6 分钟。 本篇是设计模式系列的第四篇，虽然之前也写过相应的文章，但是因为种种原因后来断掉了，而且发现之前写的内容也很渣，不够系统。 所以现在打算重写，加上距离现在也有一段时间了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gdjk/p/10389642.html</dc:identifier>
</item>
</channel>
</rss>