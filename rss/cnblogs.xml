<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>英文 单词 - kurrrr</title>
<link>http://www.cnblogs.com/kurrrr/p/13630272.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kurrrr/p/13630272.html</guid>
<description>&lt;tr readability=&quot;4.8909395973154&quot;&gt;
&lt;td id=&quot;main&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div class=&quot;post&quot;&gt;
&lt;div class=&quot;postTitle&quot;&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/kurrrr/p/13630272.html&quot;&gt;&lt;span&gt;英文 单词&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;
&lt;div class=&quot;postText&quot;&gt;
&lt;p&gt;英文 单词&lt;/p&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body&quot;&gt;
&lt;h2&gt;&lt;span&gt;英文 单词&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;orthogonal 正交的&lt;/li&gt;
&lt;li&gt;momentum 动量    momenta 动量[复数]&lt;/li&gt;
&lt;li&gt;argument 论点&lt;/li&gt;
&lt;li&gt;involve 包含，涉及&lt;/li&gt;
&lt;li&gt;adjust 调整，适应 → 一般用词组 be adjusted to ...&lt;/li&gt;
&lt;li&gt;demonstrate 证明，展示&lt;/li&gt;
&lt;li&gt;axis 轴(单数)  axes 轴(复数)&lt;/li&gt;
&lt;li&gt;behaviour 行为 是可数名词&lt;/li&gt;
&lt;li&gt;isotope 同位素&lt;/li&gt;
&lt;li&gt;isotone 同中子素&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;一些专有名词&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;the potential energy surface 势能面，注意 surface 是没有 s 的&lt;/li&gt;
&lt;li&gt;Fermi surfaces 费米面，注意 F 大写。后面一般接 XXX shell 或者 XXX orbitals&lt;/li&gt;
&lt;li&gt;small energy differences 小的能级差，differences 是复数&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;



&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;



&lt;/td&gt;
&lt;/tr&gt;</description>
<pubDate>Fri, 11 Sep 2020 00:39:00 +0000</pubDate>
<dc:creator>kurrrr</dc:creator>
<og:description>英文 单词</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kurrrr/p/13630272.html</dc:identifier>
</item>
<item>
<title>面经手册 · 第10篇《扫盲java.util.Collections工具包，学习排序、二分、洗牌、旋转算法》 - 小傅哥</title>
<link>http://www.cnblogs.com/xiaofuge/p/13649630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaofuge/p/13649630.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200910235321424.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;作者：小傅哥&lt;br/&gt;博客：&lt;a href=&quot;https://bugstack.cn&quot;&gt;https://bugstack.cn&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;沉淀、分享、成长，让自己和他人都能有所收获！😄&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;算法是数据结构的灵魂！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;好的算法搭配上合适的数据结构，可以让代码功能大大的提升效率。当然，算法学习不只是刷题，还需要落地与应用，否则到了写代码的时候，还是会&lt;code&gt;for循环&lt;/code&gt;+&lt;code&gt;ifelse&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当开发一个稍微复杂点的业务流程时，往往要用到与之契合的数据结构和算法逻辑，在与设计模式结合，这样既能让你的写出具有高性能的代码，也能让这些代码具备良好的扩展性。&lt;/p&gt;
&lt;p&gt;在以往的章节中，我们把Java常用的数据结构基本介绍完了，都已收录到：&lt;a href=&quot;https://bugstack.cn/itstack/interview.html&quot;&gt;跳转 -&amp;gt; 《面经手册》&lt;/a&gt;，章节内容下图；&lt;br/&gt;&lt;img src=&quot;https://img-service.csdnimg.cn/img_convert/05c49f611785cac20ca6cfec7c890125.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么&lt;/strong&gt;，有了这些数据结构的基础，接下来我们再学习一下Java中提供的算法工具类，&lt;code&gt;Collections&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;二、面试题&quot;&gt;二、面试题&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;谢飞机&lt;/code&gt;，今天怎么无精打采的呢，还有黑眼圈？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答&lt;/strong&gt;：好多知识盲区呀，最近一直在努力补短板，还有&lt;a href=&quot;https://bugstack.cn/itstack/interview.html&quot;&gt;面经手册&lt;/a&gt;里的数据结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问&lt;/strong&gt;：那数据结构看的差不多了吧，你有考虑🤔过，数据结构里涉及的排序、二分查找吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答&lt;/strong&gt;：二分查找会一些，巴拉巴拉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问&lt;/strong&gt;：还不错，那你知道这个方法在Java中有提供对应的工具类吗？是哪个！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;答&lt;/strong&gt;：这！？好像没注意过，没用过！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问&lt;/strong&gt;：去吧，回家在看看书，这两天也休息下。&lt;/p&gt;
&lt;p&gt;飞机悄然的出门了，但这次面试题整体回答的还是不错的，面试官决定下次再给他一个机会。&lt;/p&gt;
&lt;h2 id=&quot;三、collections-工具类&quot;&gt;三、Collections 工具类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;java.util.Collections&lt;/code&gt;，是java集合框架的一个工具类，主要用于&lt;code&gt;Collection&lt;/code&gt;提供的通用算法；排序、二分查找、洗牌等算法操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从数据结构到具体实现，再到算法，整体的结构如下图；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-service.csdnimg.cn/img_convert/f238128d3ae304059d8013208151b08a.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-collectionssort-排序&quot;&gt;1. Collections.sort 排序&lt;/h3&gt;
&lt;h4 id=&quot;11-初始化集合&quot;&gt;1.1 初始化集合&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
list.add(&quot;7&quot;);
list.add(&quot;4&quot;);
list.add(&quot;8&quot;);
list.add(&quot;3&quot;);
list.add(&quot;9&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;12-默认排列正序&quot;&gt;1.2 默认排列[正序]&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Collections.sort(list);

// 测试结果：[3, 4, 7, 8, 9]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;13-comparator排序&quot;&gt;1.3 Comparator排序&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Collections.sort(list, new Comparator&amp;lt;String&amp;gt;() {
    @Override
    public int compare(String o1, String o2) {
        return o2.compareTo(o1);
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们使用 &lt;code&gt;o2&lt;/code&gt; 与 &lt;code&gt;o1&lt;/code&gt; 做对比，这样会出来一个倒叙排序。&lt;/li&gt;
&lt;li&gt;同时，&lt;code&gt;Comparator&lt;/code&gt;还可以对对象类按照某个字段进行排序。&lt;/li&gt;
&lt;li&gt;测试结果如下；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[9, 8, 7, 4, 3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;14-reverseorder倒排&quot;&gt;1.4 reverseOrder倒排&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Collections.sort(list, Collections.&amp;lt;String&amp;gt;reverseOrder());

// 测试结果：[9, 8, 7, 4, 3]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Collections.&amp;lt;String&amp;gt;reverseOrder()&lt;/code&gt;的源码部分就和我们上面把两个对比的类调换过来一样。&lt;code&gt;c2.compareTo(c1);&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;15-源码简述&quot;&gt;1.5 源码简述&lt;/h4&gt;
&lt;p&gt;关于排序方面的知识点并不少，而且有点复杂。本文主要介绍 &lt;code&gt;Collections&lt;/code&gt; 集合工具类，后续再深入每一个排序算法进行讲解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collections.sort&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集合排序，最终使用的方法：&lt;em&gt;Arrays.sort((E[]) elementData, 0, size, c);&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static &amp;lt;T&amp;gt; void sort(T[] a, int fromIndex, int toIndex,
                            Comparator&amp;lt;? super T&amp;gt; c) {
    if (c == null) {
        sort(a, fromIndex, toIndex);
    } else {
        rangeCheck(a.length, fromIndex, toIndex);
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a, fromIndex, toIndex, c);
        else
            TimSort.sort(a, fromIndex, toIndex, c, null, 0, 0);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这一部分排序逻辑包括了，旧版的归并排序 &lt;code&gt;legacyMergeSort&lt;/code&gt; 和 &lt;code&gt;TimSort&lt;/code&gt; 排序。&lt;/li&gt;
&lt;li&gt;但因为开关的作用，&lt;code&gt;LegacyMergeSort.userRequested = false&lt;/code&gt;，基本都是走到 &lt;code&gt;TimSort&lt;/code&gt; 排序 。&lt;/li&gt;
&lt;li&gt;同时在排序的过程中还会因为元素的个数是否大于&lt;code&gt;32&lt;/code&gt;，而选择&lt;code&gt;分段排序&lt;/code&gt;和&lt;code&gt;二分插入排序&lt;/code&gt;。&lt;em&gt;这一部分内容我们后续专门在排序内容讲解&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2-collectionsbinarysearch-二分查找&quot;&gt;2. Collections.binarySearch 二分查找&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img-service.csdnimg.cn/img_convert/50ffcc41e5bba5664897f7a5218abf59.png&quot; alt=&quot;小傅哥 &amp;amp; Collections.binarySearch&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;看到这张图熟悉吗，这就是集合元素中通过二分查找定位指定元素5。&lt;/li&gt;
&lt;li&gt;二分查找的前提是集合有序，否则不能满足二分算法的查找过程。&lt;/li&gt;
&lt;li&gt;查找集合元素5，在这个集合中分了三部；
&lt;ul&gt;&lt;li&gt;第一步，&lt;code&gt;(0 + 7) &amp;gt;&amp;gt;&amp;gt; 1 = 3&lt;/code&gt;，定位 &lt;code&gt;list.get(3) = 4&lt;/code&gt;，则继续向右侧二分查找。&lt;/li&gt;
&lt;li&gt;第二步，&lt;code&gt;(4 + 7) &amp;gt;&amp;gt;&amp;gt; 1 = 5&lt;/code&gt;，定位 &lt;code&gt;list.get(5) = 6&lt;/code&gt;，则继续向左侧二分查找。&lt;/li&gt;
&lt;li&gt;第三步，&lt;code&gt;(4 + 4) &amp;gt;&amp;gt;&amp;gt; 1 = 4&lt;/code&gt;，定位 &lt;code&gt;list.get(4) = 5&lt;/code&gt;，找到元素，返回结果。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;21-功能使用&quot;&gt;2.1 功能使用&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test_binarySearch() {
    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
    list.add(&quot;1&quot;);
    list.add(&quot;2&quot;);
    list.add(&quot;3&quot;);
    list.add(&quot;4&quot;);
    list.add(&quot;5&quot;);
    list.add(&quot;6&quot;);
    list.add(&quot;7&quot;);
    list.add(&quot;8&quot;);
    
    int idx = Collections.binarySearch(list, &quot;5&quot;);
    System.out.println(&quot;二分查找：&quot; + idx);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;此功能就是上图中的具体实现效果，通过 &lt;code&gt;Collections.binarySearch&lt;/code&gt; 定位元素。&lt;/li&gt;
&lt;li&gt;测试结果：&lt;code&gt;二分查找：4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;22-源码分析&quot;&gt;2.2 源码分析&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Collections.binarySearch

public static &amp;lt;T&amp;gt; int binarySearch(List&amp;lt;? extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; list, T key) {
    if (list instanceof RandomAccess || list.size()&amp;lt;BINARYSEARCH_THRESHOLD)
        return Collections.indexedBinarySearch(list, key);
    else
        return Collections.iteratorBinarySearch(list, key);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段二分查找的代码还是蛮有意思的，&lt;code&gt;list instanceof RandomAccess&lt;/code&gt; 这是为什么呢？因为 ArrayList 有实现 RandomAccess，但是 LinkedList 并没有实现这个接口。同时还有元素数量阈值的校验 &lt;code&gt;BINARYSEARCH_THRESHOLD = 5000&lt;/code&gt;，小于这个范围的都采用 &lt;code&gt;indexedBinarySearch&lt;/code&gt; 进行查找。那么这里其实使用 LinkedList 存储数据，在元素定位的时候，需要get循环获取元素，就会比 ArrayList 更耗时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collections.indexedBinarySearch(list, key)&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; private static &amp;lt;T&amp;gt; int indexedBinarySearch(List&amp;lt;? extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; list, T key) {
     int low = 0;
     int high = list.size()-1;
     while (low &amp;lt;= high) {
         int mid = (low + high) &amp;gt;&amp;gt;&amp;gt; 1;
         Comparable&amp;lt;? super T&amp;gt; midVal = list.get(mid);
         int cmp = midVal.compareTo(key);
         if (cmp &amp;lt; 0)
             low = mid + 1;
         else if (cmp &amp;gt; 0)
             high = mid - 1;
         else
             return mid; // key found
     }
     return -(low + 1);  // key not found
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上这段代码就是通过每次折半二分定位元素，而上面所说的耗时点就是&lt;code&gt;list.get(mid)&lt;/code&gt;，这在我们分析数据结构时已经讲过。&lt;a href=&quot;https://bugstack.cn/interview/2020/08/30/%E9%9D%A2%E7%BB%8F%E6%89%8B%E5%86%8C-%E7%AC%AC8%E7%AF%87-LinkedList%E6%8F%92%E5%85%A5%E9%80%9F%E5%BA%A6%E6%AF%94ArrayList%E5%BF%AB-%E4%BD%A0%E7%A1%AE%E5%AE%9A%E5%90%97.html&quot;&gt;《LinkedList插入速度比ArrayList快？你确定吗？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collections.iteratorBinarySearch(list, key)&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static &amp;lt;T&amp;gt; int iteratorBinarySearch(List&amp;lt;? extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; list, T key)
{
    int low = 0;
    int high = list.size()-1;
    ListIterator&amp;lt;? extends Comparable&amp;lt;? super T&amp;gt;&amp;gt; i = list.listIterator();
    while (low &amp;lt;= high) {
        int mid = (low + high) &amp;gt;&amp;gt;&amp;gt; 1;
        Comparable&amp;lt;? super T&amp;gt; midVal = get(i, mid);
        int cmp = midVal.compareTo(key);
        if (cmp &amp;lt; 0)
            low = mid + 1;
        else if (cmp &amp;gt; 0)
            high = mid - 1;
        else
            return mid; // key found
    }
    return -(low + 1);  // key not found
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码是元素数量大于5000个，同时是 LinkedList 时会使用迭代器 &lt;code&gt;list.listIterator&lt;/code&gt; 的方式进行二分查找操作。也算是一个优化，但是对于链表的数据结构，仍然没有数组数据结构，二分处理的速度快，主要在获取元素的时间复杂度上O(1) 和 O(n)。&lt;/p&gt;
&lt;h3 id=&quot;3-collectionsshuffle-洗牌算法&quot;&gt;3. Collections.shuffle 洗牌算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;洗牌算法&lt;/strong&gt;，其实就是将 List 集合中的元素进行打乱，一般可以用在抽奖、摇号、洗牌等各个场景中。&lt;/p&gt;
&lt;h4 id=&quot;31-功能使用&quot;&gt;3.1 功能使用&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Collections.shuffle(list);

Collections.shuffle(list, new Random(100));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的使用方式非常简单，主要有这么两种方式，一种直接传入集合、另外一种还可以传入固定的随机种子&lt;em&gt;这种方式可以控制洗牌范围范围&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&quot;32-源码分析&quot;&gt;3.2 源码分析&lt;/h4&gt;
&lt;p&gt;按照洗牌的逻辑，我们来实现下具体的核心逻辑代码，如下；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test_shuffle() {
    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
    list.add(&quot;1&quot;);
    list.add(&quot;2&quot;);
    list.add(&quot;3&quot;);
    list.add(&quot;4&quot;);
    list.add(&quot;5&quot;);
    list.add(&quot;6&quot;);
    list.add(&quot;7&quot;);
    list.add(&quot;8&quot;);
    
    Random random = new Random();
    for (int i = list.size(); i &amp;gt; 1; i--) {
        int ri = random.nextInt(i);  // 随机位置
        int ji = i - 1;              // 顺延
        System.out.println(&quot;ri：&quot; + ri + &quot; ji：&quot; + ji);
        list.set(ji, list.set(ri, list.get(ji)));        // 元素置换
    }
    System.out.println(list);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ri：6 ji：7
ri：4 ji：6
ri：1 ji：5
ri：2 ji：4
ri：0 ji：3
ri：0 ji：2
ri：1 ji：1
[8, 6, 4, 1, 3, 2, 5, 7]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这部分代码逻辑主要是通过随机数从逐步缩小范围的集合中找到对应的元素，与递减的下标位置进行元素替换，整体的执行过程如下；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-service.csdnimg.cn/img_convert/337c2c41a86877e507cd3dc35647a9c6.png&quot; alt=&quot;小傅哥 &amp;amp; 洗牌算法过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;4-collectionsrotate-旋转算法&quot;&gt;4. Collections.rotate 旋转算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;旋转算法&lt;/strong&gt;，可以把ArrayList或者Linkedlist，从指定的某个位置开始，进行正旋或者逆旋操作。有点像把集合理解成圆盘，把要的元素转到自己这，其他的元素顺序跟随。&lt;/p&gt;
&lt;h4 id=&quot;41-功能应用&quot;&gt;4.1 功能应用&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
list.add(&quot;7&quot;);
list.add(&quot;4&quot;);
list.add(&quot;8&quot;);
list.add(&quot;3&quot;);
list.add(&quot;9&quot;);
Collections.rotate(list, 2);
System.out.println(list);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们将集合顺序；&lt;code&gt;7、4、8、3、9&lt;/code&gt;，顺时针旋转2位，测试结果如下；&lt;em&gt;逆时针旋转为负数&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[3, 9, 7, 4, 8]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过测试结果我们可以看到，从元素&lt;code&gt;7&lt;/code&gt;开始，正向旋转了两位，执行效果如下图；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-service.csdnimg.cn/img_convert/69d274d80886f85e05fcb1617b38d561.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;42-源码分析&quot;&gt;4.2 源码分析&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void rotate(List&amp;lt;?&amp;gt; list, int distance) {
    if (list instanceof RandomAccess || list.size() &amp;lt; ROTATE_THRESHOLD)
        rotate1(list, distance);
    else
        rotate2(list, distance);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于旋转算法的实现类分为两部分；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Arraylist 或者元素数量不多时，&lt;code&gt;ROTATE_THRESHOLD = 100&lt;/code&gt;，则通过算法&lt;code&gt;rotate1&lt;/code&gt;实现。&lt;/li&gt;
&lt;li&gt;如果是 LinkedList 元素数量又超过了 ROTATE_THRESHOLD，则需要使用算法&lt;code&gt;rotate2&lt;/code&gt;实现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;那么&lt;/strong&gt;，这两个算法有什么不同呢？&lt;/p&gt;
&lt;h5 id=&quot;421-旋转算法，rotate1&quot;&gt;4.2.1 旋转算法，rotate1&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static &amp;lt;T&amp;gt; void rotate1(List&amp;lt;T&amp;gt; list, int distance) {
    int size = list.size();
    if (size == 0)
        return;
    distance = distance % size;
    if (distance &amp;lt; 0)
        distance += size;
    if (distance == 0)
        return;
    for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
        T displaced = list.get(cycleStart);
        int i = cycleStart;
        do {
            i += distance;
            if (i &amp;gt;= size)
                i -= size;
            displaced = list.set(i, displaced);
            nMoved ++;
        } while (i != cycleStart);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这部分代码看着稍微多一点，但是数组结构的操作起来并不复杂，基本如上面圆圈图操作，主要包括以下步骤；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;distance = distance % size;&lt;/code&gt;，获取旋转的位置。&lt;/li&gt;
&lt;li&gt;for循环和dowhile，配合每次的旋转操作，比如这里第一次会把0位置元素替换到2位置，接着在dowhile中会判断&lt;code&gt;i != cycleStart&lt;/code&gt;，满足条件继续把替换了2位置的元素继续往下替换。直到一轮循环把所有元素都放置到正确位置。&lt;/li&gt;
&lt;li&gt;最终list元素被循环替换完成，也就相当从某个位置开始，正序旋转2个位置的操作。&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;422-旋转算法，rotate2&quot;&gt;4.2.2 旋转算法，rotate2&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static void rotate2(List&amp;lt;?&amp;gt; list, int distance) {
    int size = list.size();
    if (size == 0)
        return;
    int mid =  -distance % size;
    if (mid &amp;lt; 0)
        mid += size;
    if (mid == 0)
        return;
    reverse(list.subList(0, mid));
    reverse(list.subList(mid, size));
    reverse(list);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来这部分源码主要是针对大于&lt;code&gt;100&lt;/code&gt;个元素的LinkedList进行操作，所以整个算法也更加有意思，它的主要操作包括；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;定位拆链位置，-distance % size + size，也就是我们要旋转后找到的元素位置&lt;/li&gt;
&lt;li&gt;第一次翻转，把从位置0到拆链位置&lt;/li&gt;
&lt;li&gt;第二次翻转，把拆链位置到结尾&lt;/li&gt;
&lt;li&gt;第三次翻转，翻转整个链表&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整体执行过程，可以参考下图，更方便理解；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-service.csdnimg.cn/img_convert/ceb2281547fca99bec43e859cea83430.png&quot; alt=&quot;小傅哥 &amp;amp; 旋转算法&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-其他api介绍&quot;&gt;5. 其他API介绍&lt;/h3&gt;
&lt;p&gt;这部分API内容，使用和设计上相对比较简单，平时可能用的时候不多，但有的小伙伴还没用过，就当为你扫盲了。&lt;/p&gt;
&lt;h4 id=&quot;51-最大最小值&quot;&gt;5.1 最大最小值&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String min = Collections.min(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));
String max = Collections.max(Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;));
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Collections&lt;/code&gt; 工具包可以进行最值的获取。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;52-元素替换&quot;&gt;5.2 元素替换&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
 list.add(&quot;7&quot;);
 list.add(&quot;4&quot;);
 list.add(&quot;8&quot;);
 list.add(&quot;8&quot;);
 Collections.replaceAll(list, &quot;8&quot;, &quot;9&quot;);
 
 // 测试结果： [7, 4, 9, 9]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可以把集合中某个元素全部替换成新的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;53-连续集合位置判断&quot;&gt;5.3 连续集合位置判断&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test_indexOfSubList() {
    List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;String&amp;gt;();
    list.add(&quot;7&quot;);
    list.add(&quot;4&quot;);
    list.add(&quot;8&quot;);
    list.add(&quot;3&quot;);
    list.add(&quot;9&quot;);
    int idx = Collections.indexOfSubList(list, Arrays.asList(&quot;8&quot;, &quot;3&quot;));
    System.out.println(idx);
    
    // 测试结果：2
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在使用String操作中，我们知道&lt;code&gt;&quot;74839&quot;.indexOf(&quot;8&quot;);&lt;/code&gt;，可以获取某个元素在什么位置。而在&lt;code&gt;ArrayList&lt;/code&gt;集合操作中，可以获取连续的元素，在集合中的位置。&lt;/p&gt;
&lt;h4 id=&quot;54-synchronized&quot;&gt;5.4 synchronized&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; list = Collections.synchronizedList(new ArrayList&amp;lt;String&amp;gt;());
Map&amp;lt;String, String&amp;gt; map = Collections.synchronizedMap(new HashMap&amp;lt;String, String&amp;gt;());
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这个很熟悉吧，甚至经常使用，但可能会忽略这些线程安全的方法来自于 &lt;code&gt;Collections&lt;/code&gt; 集合工具包。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四、总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本章节基本将&lt;code&gt;java.util.Collections&lt;/code&gt;工具包中的常用方法介绍完了，以及一些算法的讲解。这样在后续需要使用到这些算法逻辑时，就可以直接使用并不需要重复造轮子。&lt;/li&gt;
&lt;li&gt;学习数据结构、算法、设计模式，这三方面的知识，重点还是能落地到日常的业务开发中，否则空、假、虚，只能适合吹吹牛，并不会给项目研发带来实际的价值。&lt;/li&gt;
&lt;li&gt;懂了就是真的懂，别让自己太难受。死记硬背谁也受不了，耗费了大量的时间，知识也没有吸收，学习一个知识点最好就从根本学习，不要心浮气躁。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五、系列推荐&quot;&gt;五、系列推荐&lt;/h2&gt;
</description>
<pubDate>Fri, 11 Sep 2020 00:38:00 +0000</pubDate>
<dc:creator>小傅哥</dc:creator>
<og:description>作者：小傅哥 博客：https://bugstack.cn 沉淀、分享、成长，让自己和他人都能有所收获！&amp;amp;#128516; 一、前言 算法是数据结构的灵魂！ 好的算法搭配上合适的数据结构，可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaofuge/p/13649630.html</dc:identifier>
</item>
<item>
<title>借助FreeHttp任意篡改Websocket报文(Websocket改包) - lulianqi15</title>
<link>http://www.cnblogs.com/lulianqi/p/13641844.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lulianqi/p/13641844.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;作为Web应用中最常见的数据传输协议之一的Websocket，在我们日常工作中也势必会经常使用到，而在调试或测试中我们常常也有直接改变Websocket数据报文以确认其对应用的影响的需求，本文将介绍一种灵活方便的方式篡改Websocket收发的数据。&lt;/p&gt;
&lt;p&gt;之前的文章里已经提到了如何利用FreeHttp修改HTTP的请求/响应报文，其实借助FreeHttp同样可以对Websocket数据报文做任意修改。（事实上burp suite 及 fiddler 的script 等工具也是可以完成的）&lt;/p&gt;
&lt;p&gt;FreeHttp可以提供更容易的方式让您使用提前按需求设置的一组规则对websocket发出及接送的数据进行任意的篡改（同时支持文本及二进制的数据修改）&lt;/p&gt;

&lt;h2&gt;FreeHttp介绍及安装&lt;/h2&gt;
&lt;div readability=&quot;8.8445945945946&quot;&gt;FreeHttp是一个Fiddler插件，借助FreeHttp您可按照您自己的设定任意修改http请求或响应报文（同时支持websocket改包）&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012105472-1053487016.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;p&gt; FreeHttp 安装可以直接查看 &lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html#_label0_1&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html#_label0_1&lt;/a&gt; （内容比较长，您可以仅查看安装部分）&lt;/p&gt;
&lt;/div&gt;

&lt;h2&gt;WebSocket改包实践&lt;/h2&gt;
&lt;p&gt;接下来将向您演示如何借助FreeHttp修改传输中的Websocket报文以满足我们假设的需求！&lt;/p&gt;

&lt;h3&gt;1：WebSocket编辑模式&lt;/h3&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012124281-791212624.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;进入FreeHttp Tab页后默认打开的是HTTP模式，您可以点击左下『HTTP/WS』切换至WebSocket模式（如果您没有看到『HTTP/WS』说明您使用的FreeHttp是1.3及以下版本，请通过上文提到链接升级FreeHttp即可，注意直接替换完成升级，升级也不会影响您已有的历史规则）&lt;/p&gt;

&lt;h3&gt;2：假设我们的场景&lt;/h3&gt;
&lt;p&gt;我们任意找一个使用WebSocket 的站点进行演示，通常Web系统里的即时聊天IM系统大多数直接使用WebSocket。&lt;/p&gt;
&lt;p&gt;我们以京东的Web站为例进行演示（事实上网上是可以找到许多WebSocket在线测试站点可让大家调试使用，这里使用JD做演示完全没有恶意）&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012138724-83549690.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如上图我们直接进入京东首页点击右下角客服的IM聊天系统 （这个时期确保您的Fiddler是打开的）&lt;/p&gt;


&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012151312-1847109113.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;您可以随意与京东客服说几句话（当然这个时候的客服很可能只是机器人）&lt;/p&gt;
&lt;p&gt;假设我们要把客服给我们的回复修改掉，修改为“我东哥发话了，今天全场1折” （纯属玩笑请勿当真）&lt;/p&gt;

&lt;h3&gt;3：创建规则完成改包&lt;/h3&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012209230-1404965177.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如上图我们需要先在Fiddler左侧Session列表里找到刚刚我们聊天的Websocket的Session （事实上Websocket建立链接的握手协商使用的是HTTP，一旦链接建立完成就会一直使用同一条链路传输数据，所以不管这个Websocket链接后面收发了多少次数据包，大部分抓包工具都会将他们显示在同一个Session 即创建链接的那个Session 中），这个Session 通常很容易在Session列表里被找出来，因为Session列表中被标记为Websocket的项通常不会太多（注意Session列表中那些带ws图标的Session）。&lt;/p&gt;
&lt;p&gt;在列表中双击我们刚刚找到的Session就可以打开WS消息列表，我们在这里可以找到客服刚刚回复我们的内容，这也确认我们找到了正确的Websocket Session。&lt;/p&gt;
&lt;p&gt;注意查看回复给我们的报文结构，后面我们将以此创建我们的篡改规则。&lt;/p&gt;


&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012225629-103516398.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如上图现在我们切换到FreeHttp Tab页来创建一个简单的WebSocket篡改规则完成我们刚刚的需求。&lt;/p&gt;
&lt;div readability=&quot;10.489887640449&quot;&gt;您可以直接点击FreeHttp获取图标（上图中“Click here”的位置），FreeHttp会自动为您选择的session创建一个完全匹配规则（同时也会根据您选择的session类型自动切换http/ws模式）。当然如果你熟悉FreeHttp里的Filter您可以手动创建更加符合您自己要求的匹配规则。（&lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html#_label1&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html#_label1&lt;/a&gt; 您在这里可以找到Filter的详细规则）&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012242554-81695081.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;查看客服回复给我们的WebSocket消息我们很容易的可以看到直接修改高亮区域文本即可。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012335380-920552282.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;9.455205811138&quot;&gt;因为我们要修改的是接收数据，如上图我们切换到『Websocket Receive Moditfic』，然后直接在『Payload Modific』区域填写上图中的规则即可（我们使用最简单的文本替换，更复杂的场景我们可以使用正则替换或HEX等其他模式 ， &lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html#_label2_0&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html#_label2_0&lt;/a&gt; 您在这里的2.1.4可以找到其他模式的使用方法）。&lt;/div&gt;
&lt;p&gt;规则填写完成点击右下角确认保存您刚刚创建的篡改规则。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012349993-1022207698.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;保存完成后您可以在右侧『Response Rule』列表中看到您刚刚添加的规则，注意上图中黄色高亮区域按此设置启用您刚刚添加的规则（默认新加入的规则是不启用的）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012359892-556087560.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;完成规则创建后，我们再次对京东客服发送您好，可以看到Web网页上收到的回复已经按我们的规则发生了变化。（您可以在网页的开发者工具或Fiddler的session ws消息列表中同样看到变化）&lt;/p&gt;
&lt;p&gt;注意到右下角的“咨询其他问题”的入口了吗，我们可以按刚刚的操作再添加一个规则，将这个“咨询其他问题”修改为“1折入口”（这里就不重复描述了）&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012411510-2144857511.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;我们再次发送您好可以看到右下角的快速入口也发生了改变&lt;/p&gt;
&lt;p&gt;注意这里有一个细节，因为这里一个session需要匹配多个规则进行修改，如果您发现您的FreeHttp只能匹配其中一个，请在下方打开『Modific Tool』『http tamper setting』，并取消『is only match first tamper rule』&lt;/p&gt;

&lt;h3&gt;4：复杂的场景&lt;/h3&gt;
&lt;p&gt;虽然我们按上文的操作已经完成了我们最初的需求，不过现实场景中的需求往往不是一成不变的，FreeHttp同时提供了许多更精细的功能帮助您创建篡改规则对Websocket报文进行篡改。&lt;/p&gt;
&lt;p&gt;同样是上面提到的例子通常Websocket里的的实时消息会有很多，并不是所有的消息都是客服回复我们的文本消息，我们没有必要对接收的所有消息都进行篡改。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012424902-889861698.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如上图我们创建更加具体的Filter规则，配置仅指定payload开头的返回报文才能通过匹配，并为这条规则创建更容易辨识的别名“修改客服的回复·····”&lt;/p&gt;

&lt;p&gt;有的时候我们需要获取发生或回复消息里的一些数据，把他们变成参数化数据供后面的规则使用，比如我们需要获取我们发送给客服的内容，我们就需要创建一个『Websocket Send Modific』规则并使用『parameter data』获取动态参数&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012440506-17291115.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;通过分析我们发送的payload不难发现我们发送的文本消息都有固定的开头，我们可以如上图创建『Websocket Send Modific』的匹配规则&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012455491-710809022.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;12.485074626866&quot;&gt;因为该规则并不用修改报文只是用来获取动态数据，我们『Payload Modific』什么都不用填写，只需要点击下方parameter图标（红色虚线框中的图标）添加如上图的parameter pick规则即可（参数名称为my content ，使用 string方式拾取，拾取范围是请求或响应实体，以},&quot;content&quot;:&quot;开头并以&quot;,&quot;render&quot;:&quot;user&quot;结尾的数据。更多parameter pick设置细节您可以查看 &lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html#_label8_2&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html#_label8_2&lt;/a&gt; 8.3 动态拾取参数化数据）&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012505075-867660840.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;启用您刚刚添加的规则，并再次在IM聊天框中发送您好，我们刚刚创建的规则就会从我们发送的payload中拾取我们发送的内容，如上图我们通过『Modific Tool』『parameter data manage』打开参数管理器查看我们拾取的内容（注意这个数据是会根据每次拾取动态变化的）&lt;/p&gt;

&lt;p&gt;接下来我们在后面的规则中直接使用我们前面拾取的数据，我们现在双击刚刚创建的Response Rule “修改客服的回复为打折消息”对其进行编辑&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012515187-313222524.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10.272493573265&quot;&gt;如上图我们在需要插入动态参数的地方右键既可以方便的找到我们刚刚拾取的“my content”参数，并将其直接应用到我们的规则中，同时您可以点击下方的闹钟图标为本次session设置延时。（更多 parameter data manage 的使用您可以查看 &lt;a href=&quot;https://www.cnblogs.com/lulianqi/p/10428551.html#_label8&quot;&gt;https://www.cnblogs.com/lulianqi/p/10428551.html#_label8&lt;/a&gt; 八：参数化数据设置）&lt;/div&gt;
&lt;p&gt;注意修改完成后不要忘了点确认保存修改。&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/209007/202009/209007-20200910012524511-540587968.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/div&gt;
&lt;p&gt;如上图，这个时候您再向客户发送“您好吧”这种消息的时候，客服的回复中就会直接使用我们刚刚拾取的参数。&lt;/p&gt;


&lt;p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;/p&gt;
&lt;p&gt;事实上使用FreeHttp您可对APP移动应用，Web网页，小程序的Websocket 及 HTTP报文创建任意的篡改规则对报文进行修改。&lt;/p&gt;





&lt;p&gt;&lt;img src=&quot;https://common.cnblogs.com/images/loading.gif&quot; alt=&quot;&quot; id=&quot;uploading_image_89575&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 11 Sep 2020 00:02:00 +0000</pubDate>
<dc:creator>lulianqi15</dc:creator>
<og:description>前言 作为Web应用中最常见的数据传输协议之一的Websocket，在我们日常工作中也势必会经常使用到，而在调试或测试中我们常常也有直接改变Websocket数据报文以确认其对应用的影响的需求，本文将</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lulianqi/p/13641844.html</dc:identifier>
</item>
<item>
<title>畅购商城(十二)：接入微信扫码支付 - Robod丶</title>
<link>http://www.cnblogs.com/robod/p/13649569.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/robod/p/13649569.html</guid>
<description>&lt;blockquote readability=&quot;6.5172413793103&quot;&gt;
&lt;p&gt;&lt;strong&gt;好好学习，天天向上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文已收录至我的Github仓库&lt;a href=&quot;https://github.com/RobodLee/DayDayUP&quot;&gt;&lt;strong&gt;DayDayUP&lt;/strong&gt;&lt;/a&gt;：github.com/RobodLee/DayDayUP，欢迎Star&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;支付流程&quot;&gt;支付流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了实现支付的功能，这里选择接入微信支付。流程就是我们通过订单系统下单，然后订单系统调用支付系统去向微信支付的服务器发送请求，然后获取二维码返回给用户，然后订单系统就开始监听MQ。用户扫码支付后，支付系统将支付状态存进MQ中。订单系统检测到用户已经付钱了，就将订单设为已支付，然后存进MySQL中。可能会因为网络问题导致订单系统获取不到支付状态，所以订单系统会定时向微信支付服务器发送请求去查询订单状态。&lt;/p&gt;
&lt;h2 id=&quot;微信支付简介&quot;&gt;微信支付简介&lt;/h2&gt;
&lt;p&gt;要想接入微信支付，就得有认证过的服务号，这个我没有，所以申请不了。就用黑马提供的账号吧，我试了一下，可以用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;appid(公众账号ID)：wx8397f8696b538317
mch_id(商户号)：1473426802
key(商户密钥)：T6m9iK73b0kn9g5v426MKfHQH7X8rKwb
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;1.6483516483516&quot;&gt;
&lt;p&gt;微信支付的开发文档：&lt;a href=&quot;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_1&quot;&gt;https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_1&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这个官方的开发文档里面介绍了微信支付相关的API并且提供了SDK。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98sdk%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个SDK的内容不多，只有几个类，我稍微介绍一下：&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;WXPayConfig：这是个抽象类，里面有几个方法，是用来获取核心参数的，比如公众号id，商户号，密钥等，所以在使用的时候要先去实例化这个类将几个重要参数配置进去。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;WXPay：和订单相关的方法都封装在这个类里面，比如下单，查询订单，取消订单等。里面有个方法&lt;strong&gt;fillRequestData()&lt;/strong&gt;，每次执行下单等操作的时候都会去调用这个方法将WXPayConfig中的几个核心参数封装到请求参数的Map集合里。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;WXPayRequest：这个是负责请求服务器的，WXPay也都是通过调用这个类中的方法去请求服务器的，执行相应方法的时候，会将WXPay传过来的Map集合转换成XML格式的字符串，然后使用HttpClient向服务器发送请求。没错，微信支付是通过XML进行数据传输的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;WXPayUtil：这是个工具类，封装了一些常用方法，比如Map转XML，XML转Map等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这个项目中用到的微信的Native支付，也就是扫码支付，有两种模式，我们用到的是模式二。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/%E5%BE%AE%E4%BF%A1%E6%89%AB%E7%A0%81%E6%94%AF%E4%BB%98%E6%A8%A1%E5%BC%8F%E4%BA%8C%E6%97%B6%E5%BA%8F%E5%9B%BE.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先在畅购的订单系统中生成订单，然后将一些必要的参数传入到微信支付的后台，然后就会产生一个预支付的订单，将支付链接返回给我们，我们再根据支付链接生成二维码传给用户。用户扫码支付后再将支付结果传到我们的后台，这样整个支付的流程就结束了。&lt;/p&gt;
&lt;h2 id=&quot;准备工作&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;介绍完了微信支付后，就来说一下项目中该怎么去集成微信支付。视频中用的是第三方的依赖，我用的是官方的。微信支付的SDK在Maven的远程仓库里是没有的，所以需要自己下载然后手动导入。这里面有两个坑有必要说一下，前面不是提到&lt;strong&gt;WXPayConfig&lt;/strong&gt;是个抽象类么，那么用的时候肯定得去继承才能实例化吧。但是里面的抽象方法都没有权限修饰符，所以默认是包访问权限，我们既然是Maven依赖这个SDK，那么我们写的代码自然不会和它在同一个包下，所以要先在这几个抽象方法前面添加&lt;strong&gt;public&lt;/strong&gt;修饰符。而且，微信提供的sdk文档里还写成了implements抽象类，真搞不懂微信怎么会犯这种错~~~&lt;/p&gt;
&lt;p&gt;现在就可以将这个SDK添加到我们本地的Maven仓库里了，在解压后的sdk的根目录下执行&lt;code&gt;mvn install&lt;/code&gt;命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/mvninstallsdk.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当出现&lt;strong&gt;BUILD SUCCESS&lt;/strong&gt;的字样的时候，就说明已经成功添加到本地的Maven仓库了。这时候第二个坑就来了，如果就这么添加到我们的项目中就有可能会出现Maven依赖冲突：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/maven%E4%BE%9D%E8%B5%96%E5%86%B2%E7%AA%81.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，出现冲突的包是&lt;strong&gt;slf4j-simple&lt;/strong&gt;，而微信支付sdk恰好依赖了这个包，所以在导入微信支付的时候把这个依赖排除掉即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.wxpay&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;wxpay-sdk&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.0.9&amp;lt;/version&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;slf4j-simple&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以创建支付的工程了。在changgou-service下创建一个Moudle名为&lt;strong&gt;changgou-service-wechatpay&lt;/strong&gt;，然后&lt;strong&gt;将微信支付的依赖添加到这个工程下&lt;/strong&gt;，启动类没啥好说的，配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 18090
spring:
  application:
    name: wechatpay
  main:
    allow-bean-definition-overriding: true
eureka:
  client:
    service-url:
      defaultZone: http://127.0.0.1:7001/eureka
  instance:
    prefer-ip-address: true
feign:
  hystrix:
    enabled: true
#hystrix 配置
hystrix:
  command:
    default:
      execution:
        timeout:
          #如果enabled设置为false，则请求超时交给ribbon控制
          enabled: true
        isolation:
          strategy: SEMAPHORE

#微信支付信息配置
wechat:
  # 应用id
  app_id: wx8397f8696b538317
  # 商户号id
  mch_id: 1473426802
  # 密钥
  key: T6m9iK73b0kn9g5v426MKfHQH7X8rKwb
  # 支付回调地址
  notify_url: http://www.itcast.cn
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里配置了appid，mch_id，key，notify_url这几个参数，用的时候直接读取就可以了。这样支付微服务就搭建好了。&lt;/p&gt;
&lt;h2 id=&quot;微信支付二维码生成&quot;&gt;微信支付二维码生成&lt;/h2&gt;
&lt;p&gt;添加一个Controller层的类WeChatPayController，然后再创建一个入口方法，因为二维码支付叫做Native支付，所以这里就起名为createNative了，接收一个Order参数，视频中用的是Map接收参数。但是既然是创建订单，直接用Order作为参数可读性不是好很多吗。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//创建二维码
@RequestMapping(value = &quot;/create/native&quot;)
public Result createNative(@RequestBody Order order){
    Map&amp;lt;String,String&amp;gt; resultMap = weChatPayService.createNative(order);
    return new Result(true, StatusCode.OK,&quot;创建二维码预付订单成功！&quot;,resultMap);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写完了Controller就可以写Service层了，视频中是用HttpClient调用微信支付的远程接口，既然微信已经提供了sdk，为什么还要重复造轮子呢？所以我就没和视频中写的一样，而是直接使用微信的sdk，虽然底层用的也是HttpClient。&lt;/p&gt;
&lt;p&gt;首先需要将WXPayConfig给实现一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class MyWXPayConfig extends WXPayConfig {

    private String appId;

    private String mchId;

    private String key;

    public MyWXPayConfig(String appId, String mchId, String key) {
        this.appId = appId;
        this.mchId = mchId;
        this.key = key;
    }

    @Override
    public String getAppID() {
        return appId;
    }

    @Override
    public String getMchID() {
        return mchId;
    }

    @Override
    public String getKey() {
        return key;
    }

    @Override
    public InputStream getCertStream() {
        return null;
    }

    @Override
    public int getHttpConnectTimeoutMs() {
        return 8000;
    }

    @Override
    public int getHttpReadTimeoutMs() {
        return 10000;
    }

    @Override
    public IWXPayDomain getWXPayDomain() {
        IWXPayDomain iwxPayDomain = new IWXPayDomain() {
            @Override
            public void report(String domain, long elapsedTimeMillis, Exception ex) {
            }
            @Override
            public DomainInfo getDomain(WXPayConfig config) {
                return new IWXPayDomain.DomainInfo(WXPayConstants.DOMAIN_API, true);
            }
        };
        return iwxPayDomain;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;strong&gt;WeChatPayServiceImpl&lt;/strong&gt;编写相应的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Value(&quot;${wechat.appid}&quot;)
private String appId;

@Value(&quot;${wechat.mch_id}&quot;)
private String mcnId;

@Value(&quot;${wechat.key}&quot;)
private String key;

@Value(&quot;${wechat.notify_url}&quot;)
private String notifyUrl;

@Override
public Map&amp;lt;String, String&amp;gt; createNative(Order order) {
    try {
        Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;(16);
        map.put(&quot;body&quot;, &quot;腾讯充值中心-QQ会员充值&quot;);    //商品描述
        map.put(&quot;out_trade_no&quot;, order.getId());      //商户订单号
        map.put(&quot;total_fee&quot;, String.valueOf((int)(order.getTotalMoney() * 100))); //标价金额,单位为分
        map.put(&quot;spbill_create_ip&quot;, &quot;127.0.0.1&quot;);    //终端IP
        map.put(&quot;trade_type&quot;, &quot;NATIVE &quot;);    //交易类型，JSAPI -JSAPI支付,NATIVE -Native支付,APP -APP支付

        Map&amp;lt;String, String&amp;gt; response = wxpay.unifiedOrder(map);
        if (response == null || response.size() == 0) {
                throw new RuntimeException(&quot;下单失败&quot;);
        }
        return response;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里用到了&lt;strong&gt;@Value&lt;/strong&gt;注解将配置文件中的几个参数注入了进来。然后将创建订单的几个参数添加到Map集合中，键的名称在文档中有说明，不能改变，金额的单位是分，我们传过来的是元，所以需要乘100，微信要求金额是整数，所以再强转成int。然后就去创建&lt;strong&gt;MyWXPayConfig&lt;/strong&gt;的实例，将三个参数传入进入，然后去创建WXPay的对象，将config和notifyUrl传入进去，然后调用&lt;strong&gt;unifiedOrder()&lt;/strong&gt;方法把map传入进去就可以创建订单了，其实内部就是把appid这几个参数放在了我们传入的map中，所以在这里放入到map中也是OK的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/%E5%88%9B%E5%BB%BA%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%B5%8B%E8%AF%95.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;测试一下，OK了，成功创建了订单，也拿到了二维码的地址，接下来只要把&lt;strong&gt;code_url&lt;/strong&gt;转换成二维码图片就可以了。&lt;/p&gt;
&lt;p&gt;如果是做测试，随便在网上找个二维码生成器，然后把code_url复制过去就行了。在项目中是用&lt;strong&gt;qrious&lt;/strong&gt;生成。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;二维码入门小demo&amp;lt;/title&amp;gt;
&amp;lt;!--1.引入js  2. 创建一个img标签 用来存储显示二维码的图片 3.创建js对象 4.设置js对象的配置项--&amp;gt;
&amp;lt;script src=&quot;qrious.js&quot;&amp;gt; &amp;lt;/script&amp;gt;        &amp;lt;!--下载qrious.js后引入--&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;img id=&quot;myqrious&quot; &amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;script&amp;gt;
   var qrious = new QRious({
                 element:document.getElementById(&quot;myqrious&quot;),// 指定的是图片所在的DOM对象
                 size:250,//指定图片的像素大小
                 level:'H',//指定二维码的容错级别(H:可以恢复30%的数据)
                 value:'weixin://wxpay/bizpayurl?pr=xKlU7lD'//指定二维码图片代表的真正的值
   })
&amp;lt;/script&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查询订单状态&quot;&gt;查询订单状态&lt;/h2&gt;
&lt;p&gt;有时候可能因为网络原因导致支付状态没有及时返回到我们的服务器中，这个时候就要手动地去查询了，代码很简单，我就不多说了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//WeChatPayController
@GetMapping(value = &quot;/status/query&quot;)
public Result&amp;lt;Map&amp;lt;String,String&amp;gt;&amp;gt; queryPayStatus(@RequestParam String outTradeNo) {
    Map&amp;lt;String,String&amp;gt; resultMap = weChatPayService.queryPayStatus(outTradeNo);
    return new Result&amp;lt;&amp;gt;(true, StatusCode.OK,&quot;订单查询成功&quot;,resultMap);
}
--------------------------------------------------------------------------------------
//WeChatPayServiceImpl
@Override
public Map&amp;lt;String, String&amp;gt; queryPayStatus(String outTradeNo) {
    try {
        Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;out_trade_no&quot;, outTradeNo);      //商户订单号
        MyWXPayConfig config = new MyWXPayConfig(appId,mcnId, key);
        WXPay wxpay = new WXPay(config,notifyUrl);
        Map&amp;lt;String, String&amp;gt; response = wxpay.orderQuery(map);
        if (response == null || response.size() == 0) {
            throw new RuntimeException(&quot;订单查询失败&quot;);
        }
        return response;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/%E8%AE%A2%E5%8D%95%E6%9F%A5%E8%AF%A2%E6%B5%8B%E8%AF%95.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;支付结果回调通知及rabbitmq监听&quot;&gt;支付结果回调通知及RabbitMQ监听&lt;/h2&gt;
&lt;p&gt;要实现支付结果回调通知，首先得告诉微信支付的服务器我们的支付结果回调通知的地址，因为我们没有公网IP，所以微信服务器没办法主动发消息到我们的服务器，所以可以使用内网穿透。我选择的是uTools的一个内网穿透插件，不用注册账号就可以直接使用，很方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/utools%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后&lt;strong&gt;将内网穿透的地址配置到之前配置notify_url的地方&lt;/strong&gt;就可以了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;# 支付回调地址
notify_url: http://robod123.cn1.utools.club/wechat/pay/notify/url
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就该配置RabbitMQ了，首先得&lt;strong&gt;在虚拟机中安装RabbitMQ&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;docker pull docker.io/rabbitmq:3.7-management                  # 下载rabbitmq的镜像
docker run --name rabbitmq -d -p 15672:15672 -p 5672:5672 4b23cfb64730  # 安装rabbitmq，最后面的id是docker images查出来的
docker exec -it rabbitmq /bin/bash                                              # 进入到rabbitmq中
rabbitmqctl add_user root 123456                                                # 添加一个名为root的用户，密码为123456
rabbitmqctl set_permissions -p / root &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;      # 赋予root用户所有权限
rabbitmqctl set_user_tags root administrator                    # 赋予root用户administrator角色
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为支付微服务和订单微服务都用到了RabbitMQ，所以在这两个微服务中添加mq的依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-amqp&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在这两个微服务中添加rabbitmq的配置信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:                 # 配置rabbitmq的ip和端口
  rabbitmq:
    host: 192.168.31.200
    port: 5672
    username: root
    password: 123456
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着就去添加exchange和queue了，视频中是用程序自动创建的，但是我遇到了一个问题，就是订单微服务启动的时候报了一个错，导致服务启动不了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;org.springframework.amqp.rabbit.listener.QueuesNotAvailableException: Cannot prepare queue for listener. Either the queue doesn't exist or the broker will not allow us to use it.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我就在网页端手动创建exchange和queue了，并指定routing key将exchange和queue绑定起来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/exchange%E5%92%8Cqueue.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置的部分到这里就已经完成了，接下来就可以去写代码了，为了方便理解，我画了一张流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E5%9B%9E%E8%B0%83%E9%80%9A%E7%9F%A5%E5%8F%8Amq%E7%9B%91%E5%90%AC.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码我就不去解释了，直接贴了，对照着这张流程图应该就能看懂了。视频中提到的两个小作业我也写了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WeChatPayController&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 支付结果回调通知
 * @param request
 * @return
 * @throws Exception
 */
@RequestMapping(&quot;/notify/url&quot;)
public String notifyUrl(HttpServletRequest request) throws Exception {
    ServletInputStream inputStream = request.getInputStream();
    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
    byte[] buffer = new byte[1024];
    int len = 0;
    while ((len = inputStream.read(buffer))!=-1) {
        outputStream.write(buffer,0,len);
    }
    String xmlString = outputStream.toString(&quot;UTF-8&quot;);

    //将java对象转换成amqp消息发送出去，调用的是send方法
    rabbitTemplate.convertAndSend(&quot;exchange.order&quot;,&quot;routing.order&quot;, xmlString);

    return  &quot;&amp;lt;xml&amp;gt;&amp;lt;return_code&amp;gt;&amp;lt;![CDATA[SUCCESS]]&amp;gt;&amp;lt;/return_code&amp;gt;&amp;lt;return_msg&amp;gt;&amp;lt;![CDATA[OK]]&amp;gt;&amp;lt;/return_msg&amp;gt;&amp;lt;/xml&amp;gt;&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;OrderMessageListener&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@RabbitListener(queues = {&quot;queue.order&quot;})
public class OrderMessageListener {

    private final static String SUCCESS = &quot;SUCCESS&quot;;

    @Autowired
    private OrderService orderService;

    @Autowired
    private WeChatPayFeign weChatPayFeign;

    /**
     * 监听mq的消息
     * @param message xml格式的消息
     */
    @RabbitHandler
    public void getMessage(String message) throws Exception {
        Map&amp;lt;String, String&amp;gt; map = WXPayUtil.xmlToMap(message);
        String returnCode = map.getOrDefault(&quot;return_code&quot;,&quot;&quot;);     //返回状态码
        String resultCode = map.getOrDefault(&quot;result_code&quot;,&quot;&quot;);     //业务结果
        if (SUCCESS.equals(returnCode)) {   //支付成功，修改订单状态
            String outTradeNo = map.get(&quot;out_trade_no&quot;);    //商户订单号
            if (! SUCCESS.equals(resultCode)) { //交易失败，关闭订单，从数据库中将订单状态修改为支付失败，回滚库存
                Map&amp;lt;String, String&amp;gt; closeResult = weChatPayFeign.closeOrder(outTradeNo).getData();  //关闭订单时服务器返回的数据
                //如果错误代码为ORDERPAID则说明订单已经支付，当作正常订单处理,反之 回滚库存
                if (!(&quot;FAIL&quot;.equals(closeResult.get(&quot;result_code&quot;)) &amp;amp;&amp;amp; &quot;ORDERPAID&quot;.equals(closeResult.get(&quot;err_code&quot;)))) {
                    orderService.deleteOrder(outTradeNo);
                    return;
                }
            }
            String transactionId = map.get(&quot;transaction_id&quot;);   //微信支付订单号
            String timeEnd = map.get(&quot;time_end&quot;);               //支付完成时间
            orderService.updateStatus(outTradeNo,timeEnd,transactionId);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;OrderServiceImpl&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void updateStatus(String outTradeNo,String timeEnd,String transactionId) {
    Order order = orderMapper.findById(outTradeNo);
    LocalDateTime payTime = LocalDateTime.parse(timeEnd, DateTimeFormatter.ofPattern(&quot;yyyyMMddHHmmss&quot;));

    order.setPayStatus(&quot;1&quot;);                //支付状态修改为1表示已支付
    order.setTransactionId(transactionId);  //交易流水号
    order.setPayTime(payTime);              //交易时间

    orderMapper.updateByPrimaryKey(order);
}

@Override
public void deleteOrder(String outTradeNo) {
    Order order = orderMapper.findById(outTradeNo);
    LocalDateTime time = LocalDateTime.now();
    //修改状态
    order.setPayStatus(&quot;2&quot;);    //交易失败
    order.setUpdateTime(time);
    //提交到数据库
    orderMapper.updateByPrimaryKey(order);
    //回滚库存
    List&amp;lt;OrderItem&amp;gt; orderItems = orderItemMapper.findByOrderId(order.getId());
    List&amp;lt;Long&amp;gt; skuIds = new ArrayList&amp;lt;&amp;gt;();
    for (OrderItem orderItem : orderItems) {
        skuIds.add(orderItem.getSkuId());
    }
    List&amp;lt;Sku&amp;gt; skuList = skuFeign.findBySkuIds(order.getSkuIds()).getData(); //数据库中对应的sku集合
    Map&amp;lt;Long, Sku&amp;gt; skuMap = skuList.stream().collect(Collectors.toMap(Sku::getId, a -&amp;gt; a));
    for (OrderItem orderItem : orderItems) {
        Sku sku = skuMap.get(orderItem.getSkuId());
        sku.setNum(sku.getNum()+orderItem.getNum());    //加库存
    }
    skuFeign.updateMap(skuMap);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定时处理订单状态&quot;&gt;定时处理订单状态&lt;/h2&gt;
&lt;p&gt;当创建一个订单后，可能用户并不会去支付，或者是因为网络的原因导致我们获取不到用户支付的结果。所以可以采用定时处理的方式，具体的操作就是下单成功后就往mq的队列1中发送一条消息，设置30分钟过期，过期后将消息发送给队列2，然后我们监听队列2。这样一旦监听到了队列2的消息，则说明离下单已经过去了30分钟，这时候我们去查询一下订单状态，如果是已支付就不去管它，要是未支付的话就通知微信服务器关闭订单，然后从数据库中删除订单。为了方便理解，我画了一张流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/Java/%E7%95%85%E8%B4%AD%E5%95%86%E5%9F%8E12%EF%BC%9A%E6%8E%A5%E5%85%A5%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98/%E5%AE%9A%E6%97%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%9B%BE.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码挺简单的，首先将添加一个配置类去把&lt;strong&gt;队列创建出来&lt;/strong&gt;，直接在web页面上配置也是OK的，不过上一节是在web页面配置的，这个就在程序中添加吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class MqConfig {

    //队列1，延时队列，消息过期后发送给队列2
    @Bean
    public Queue orderDelayQueue() {
        return QueueBuilder
                .durable(&quot;orderDelayQueue&quot;)
                //orderDelayQueue队列信息会过期，过期之后，进入到死信队列，死信队列数据绑定到其他交换机
                .withArgument(&quot;x-dead-letter-exchange&quot;,&quot;orderListenerExchange&quot;)
                .withArgument(&quot;x-dead-letter-routing-key&quot;,&quot;orderListenerRoutingKey&quot;) //绑定指定的routing-key
                .build();
    }

    //队列2
    @Bean(name = &quot;orderListenerQueue&quot;)  //名称不写默认就是方法名
    public Queue orderListenerQueue() {
        return new Queue(&quot;orderListenerQueue&quot;,true);
    }

    //创建交换机
    @Bean
    public Exchange orderListenerExchange() {
        return new DirectExchange(&quot;orderListenerExchange&quot;);
    }

    //队列queue2绑定exchange
    @Bean
    public Binding orderListenerBinding(Queue orderListenerQueue,Exchange orderListenerExchange) {
        return BindingBuilder
                .bind(orderListenerQueue)
                .to(orderListenerExchange)
                .with(&quot;orderListenerRoutingKey&quot;)
                .noargs();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在创建队列1的时候，配置了将死信队列的数据绑定到队列2的交换机上，这样数据过期后就会被发送到队列2中。&lt;/p&gt;
&lt;p&gt;然后&lt;strong&gt;在创建订单的时候将订单号发送到队列1中&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//OrderServiceImpl
@Override
public synchronized void add(Order order) {
        order.setId(String.valueOf(idWorker.nextId()));
    …………
    rabbitTemplate.convertAndSend(&quot;orderDelayQueue&quot;, (Object)order.getId(), new MessagePostProcessor() {
        @Override
        public Message postProcessMessage(Message message) throws AmqpException {
            message.getMessageProperties().setExpiration(&quot;30*60*1000&quot;);   //定时30min后过时
            return message;
        }
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;监听队列2然后执行相应的操作&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@RabbitListener(queues = &quot;orderListenerQueue&quot;)
public class DelayMessageQueueListener {

    @Autowired
    private OrderService orderService;

    @Autowired
    private WeChatPayFeign weChatPayFeign;

    @RabbitHandler
    public void getMessage(String orderId) throws Exception {
        Order order = orderService.findById(orderId);
        if (&quot;0&quot;.equals(order.getPayStatus())) {
            //0表示未支付，通知微信服务器取消订单，从数据库中删除订单，回滚库存
            Map&amp;lt;String, String&amp;gt; closeResult = weChatPayFeign.closeOrder(orderId).getData();
            //如果错误代码为ORDERPAID则说明订单已经支付，当作正常订单处理,反之 回滚库存
            if (!(&quot;FAIL&quot;.equals(closeResult.get(&quot;result_code&quot;)) &amp;amp;&amp;amp; &quot;ORDERPAID&quot;.equals(closeResult.get(&quot;err_code&quot;)))) {
                orderService.deleteOrder(orderId);
            }
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK，这样就可以定时去处理订单数据了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章主要就是实现了微信扫码支付，因为微信提供的sdk有点问题，还是花了一些时间的，不过最后还是完成了。然后又实现了支付结果回调通知和rabbitmq监听的功能，用到了内网穿透。最后使用两个队列来实现了定时处理订单。还有一个问题就是我没系统地学过RabbitMQ，所以对于很多操作都是一知半解的，都是参考着视频中讲的然后再自己摸索摸索web页面的配置，后期我会系统地学习一下RabbitMQ然后再总结出一篇文章。&lt;/p&gt;
&lt;blockquote readability=&quot;7.0682926829268&quot;&gt;
&lt;p&gt;如果觉得我写的还可以，请不要吝啬你的 &lt;code&gt;赞&lt;/code&gt; &lt;code&gt;赞&lt;/code&gt; &lt;code&gt;赞&lt;/code&gt; ！&lt;/p&gt;
&lt;p&gt;代码：&lt;a href=&quot;https://github.com/RobodLee/changgou&quot;&gt;https://github.com/RobodLee/changgou&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文已收录至我的Github仓库&lt;a href=&quot;https://github.com/RobodLee/DayDayUP&quot;&gt;&lt;strong&gt;DayDayUP&lt;/strong&gt;&lt;/a&gt;：github.com/RobodLee/DayDayUP，欢迎Star&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/RobodLee/image_store/raw/master/QRcode2.0.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Sep 2020 23:32:00 +0000</pubDate>
<dc:creator>Robod丶</dc:creator>
<og:description>好好学习，天天向上 本文已收录至我的Github仓库DayDayUP：github.com/RobodLee/DayDayUP，欢迎Star 畅购商城(一)：环境搭建 畅购商城(二)：分布式文件系统F</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/robod/p/13649569.html</dc:identifier>
</item>
<item>
<title>【Flutter 实战】1.20版本更新及新增组件 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/13649555.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/13649555.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200911070743545-770110016.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;老孟导读&lt;/strong&gt;：Flutter 1.20 更新了 Slider、RangeSlider、日期选择器组件、时间选择器组件的样式，新增了交换组件：InteractiveViewer，下面详细介绍其用法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;滑块&quot;&gt;滑块&lt;/h2&gt;
&lt;p&gt;Flutter 1.20 版本将 &lt;strong&gt;Slider&lt;/strong&gt; 和 &lt;strong&gt;RangeSlider&lt;/strong&gt; 小部件更新为最新的 Material 准则。新的滑块在设计时考虑到了更好的可访问性：轨道更高，滑块带有阴影，并且值指示器具有新的形状和改进的文本缩放支持。&lt;/p&gt;
&lt;h3 id=&quot;slider&quot;&gt;Slider&lt;/h3&gt;
&lt;p&gt;基础用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class SliderDemo extends StatefulWidget {
  @override
  _SliderDemoState createState() =&amp;gt; _SliderDemoState();
}

class _SliderDemoState extends State&amp;lt;SliderDemo&amp;gt; {
  double _sliderValue = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text('值：$_sliderValue'),
            Slider(
              value: _sliderValue,
              onChanged: (v){
                setState(() {
                  _sliderValue = v;
                });
              },
            )
          ],
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;value&lt;/strong&gt;：当前值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onChanged&lt;/strong&gt;：滑块值改变时回调。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f5f3bad0b5e4778bd262a72b67f121a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看看 Flutter 1.20 版本以前的样式（我的珍藏）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/202ded80d62a4eb6bb6b39a2bd636212~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;明显的感觉就是滑块轨道变粗了，滑块变的更有立体感（加了阴影）了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Slider&lt;/strong&gt; 默认滑动范围是 0-1，修改为 1-100:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Slider(
  value: _sliderValue,
  min: 1,
  max: 100,
  onChanged: (v){
    setState(() {
      _sliderValue = v;
    });
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec2623b7b64d44d1a365c332f51b10d1~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置滑块的滑动为 &lt;strong&gt;离散的&lt;/strong&gt;，即滑动值为 0、25 、50、75 100：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Slider(
  value: _sliderValue,
  min: 0,
  max: 100,
  divisions: 4,
  onChanged: (v){
    setState(() {
      _sliderValue = v;
    });
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe7a1bea7784483caa29587029a0e3eb~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置标签，滑动过程中在其上方显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Slider(
  value: _sliderValue,
  label: '$_sliderValue',
  min: 0,
  max: 100,
  divisions: 4,
  onChanged: (v){
    setState(() {
      _sliderValue = v;
    });
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/19e389ce842c47baa5329f668b3739cb~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看看 Flutter 1.20 版本以前的样式（依然是我的珍藏）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b67b25dc51ed4c6cbfdb88642e79a9c7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人感觉以前的更好看。&lt;/p&gt;
&lt;p&gt;下面是官方给的 &lt;strong&gt;Slider&lt;/strong&gt; 结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a05e5da94754de7abbef42682a74470~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt; ：轨道（Track），1 和 4 是有区别的，1 指的是底部整个轨道，轨道显示了可供用户选择的范围。对于从左到右（LTR）的语言，最小值出现在轨道的最左端，而最大值出现在最右端。对于从右到左（RTL）的语言，此方向是相反的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2&lt;/strong&gt;：滑块（Thumb），位置指示器，可以沿着轨道移动，显示其位置的选定值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3&lt;/strong&gt;：标签（label），显示与滑块的位置相对应的特定数字值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4&lt;/strong&gt;：刻度指示器（Tick mark），表示用户可以将滑块移动到的预定值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自定义滑块 &lt;strong&gt;激活的颜色&lt;/strong&gt; 和 &lt;strong&gt;未激活的颜色&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Slider(
  activeColor: Colors.red,
  inactiveColor: Colors.blue,
  value: _sliderValue,
  label: '$_sliderValue',
  min: 0,
  max: 100,
  divisions: 4,
  onChanged: (v){
    setState(() {
      _sliderValue = v;
    });
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ab5186cc90e46309165ee05ab7054ef~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个自定义比较笼统，下面来一个更细致的自定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;SliderTheme(
  data: SliderTheme.of(context).copyWith(
      activeTrackColor: Color(0xff404080),
      thumbColor: Colors.blue,
      overlayColor: Colors.green,
      valueIndicatorColor: Colors.purpleAccent),
  child: Slider(
    value: _sliderValue,
    label: '$_sliderValue',
    min: 0,
    max: 100,
    divisions: 4,
    onChanged: (v) {
      setState(() {
        _sliderValue = v;
      });
    },
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3cf9234077344ca8b758479781fcce21~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个基本可以完全自定义样式了。&lt;/p&gt;
&lt;p&gt;如何在 Flutter 1.20 版本使用以前的标签样式呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;SliderTheme(
  data: SliderTheme.of(context).copyWith(
    valueIndicatorShape: PaddleSliderValueIndicatorShape(),
  ),
  child: Slider(
    value: _sliderValue,
    label: '$_sliderValue',
    min: 0,
    max: 100,
    divisions: 4,
    onChanged: (v) {
      setState(() {
        _sliderValue = v;
      });
    },
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91339995c55245a3a6b46e878ff5ba74~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RectangularSliderValueIndicatorShape&lt;/strong&gt; 表示矩形样式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44f886c15f44488cb67233cdaa416477~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;rangeslider&quot;&gt;RangeSlider&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;RangeSlider&lt;/strong&gt; 和 &lt;strong&gt;Slider&lt;/strong&gt; 几乎一样，&lt;strong&gt;RangeSlider&lt;/strong&gt; 是范围滑块，想要选择一段值，可以使用 RangeSlider。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RangeValues _rangeValues = RangeValues(0, 25);

RangeSlider(
  values: _rangeValues,
  labels: RangeLabels('${_rangeValues.start}','${_rangeValues.end}'),
  min: 0,
  max: 100,
  divisions: 4,
  onChanged: (v) {
    setState(() {
      _rangeValues = v;
    });
  },
),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/673482bd33b842cf8eff1bb7b5d1c809~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;滑块状态&quot;&gt;滑块状态&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/696cd01aa79b4876a25de81acc03de9a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ios风格的-slider&quot;&gt;ios风格的 Slider&lt;/h3&gt;
&lt;p&gt;ios风格的 Slider，使用 CupertinoSlider：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;double _sliderValue = 0;
CupertinoSlider(
  value: _sliderValue,
  onChanged: (v) {
    setState(() {
      _sliderValue = v;
    });
  },
)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ad0677f53f245aeafb640bc4b6702a3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然也可以根据平台显示不同风格的Slider，ios平台显示CupertinoSlider效果，其他平台显示Material风格，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Slider.adaptive(
  value: _sliderValue,
  onChanged: (v) {
    setState(() {
      _sliderValue = v;
    });
  },
)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;material风格日期选择器&quot;&gt;Material风格日期选择器&lt;/h2&gt;
&lt;p&gt;Flutter 1.20 版本更新了 &lt;strong&gt;日期&lt;/strong&gt; 类组件的样式，加入了新的紧凑设计以及对日期范围的支持。&lt;/p&gt;
&lt;h3 id=&quot;showdatepicker&quot;&gt;showDatePicker&lt;/h3&gt;
&lt;h4 id=&quot;结构图&quot;&gt;结构图&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6088ae793e6641bc8d99e82f57dc09aa~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标题&lt;/li&gt;
&lt;li&gt;选中的日期&lt;/li&gt;
&lt;li&gt;切换到&lt;strong&gt;输入模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;年&lt;/strong&gt;选择菜单&lt;/li&gt;
&lt;li&gt;月份分页&lt;/li&gt;
&lt;li&gt;当前时间&lt;/li&gt;
&lt;li&gt;选中日期&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;输入模式&lt;/strong&gt; 结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ef7b0da63964700a252c440cda3ff2a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标题&lt;/li&gt;
&lt;li&gt;选中日期&lt;/li&gt;
&lt;li&gt;切换 &lt;strong&gt;日历模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;输入框&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;基础用法&quot;&gt;基础用法&lt;/h4&gt;
&lt;p&gt;点击按钮弹出日期组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt; RaisedButton(
          child: Text('弹出日期组件'),
          onPressed: () async {
            await showDatePicker(
              context: context,
              initialDate: DateTime.now(),
              firstDate: DateTime(2010),
              lastDate: DateTime(2025),
            );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/af2826a53b094d7bacdced3bec75769d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;initialDate&lt;/strong&gt;：初始化时间，通常情况下设置为当前时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;firstDate&lt;/strong&gt;：表示开始时间，不能选择此时间前面的时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lastDate&lt;/strong&gt;：表示结束时间，不能选择此时间之后的时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置日期选择器对话框的模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime(2010),
  lastDate: DateTime(2025),
  initialEntryMode: DatePickerEntryMode.input,
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34291704b20d49acb40452490cb5e331~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接显示 &lt;strong&gt;输入模式&lt;/strong&gt;，默认是&lt;strong&gt;日历模式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;设置日历日期选择器的初始显示，包含 &lt;strong&gt;day&lt;/strong&gt; 和 &lt;strong&gt;year&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime(2010),
  lastDate: DateTime(2025),
  initialDatePickerMode: DatePickerMode.year,
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82b04af824714f22a5b33de762462f45~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;和以前的版本对比：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d678c5cd511e45db89255f730e049520~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置顶部标题、取消按钮、确定按钮 文案：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime(2010),
  lastDate: DateTime(2025),
  helpText: '选则日期',
  cancelText: '取消',
  confirmText: '确定',
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0151351ddba0463998fa6e862caa428a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改 &lt;strong&gt;输入模式&lt;/strong&gt; 下文案：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime(2010),
  lastDate: DateTime(2025),
  errorFormatText: '错误的日期格式',
  errorInvalidText: '日期格式非法',
  fieldHintText: '月/日/年',
  fieldLabelText: '填写日期',
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9a2e2eafd55479bbfc53a9c90efe454~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8be7f26f2894fa7a0a1cd7091b561c4~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;设置可选日期范围&quot;&gt;设置可选日期范围&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime(2010),
  lastDate: DateTime(2025),
  selectableDayPredicate: (date) {
    return date.difference(DateTime.now()).inMilliseconds &amp;lt; 0;
  },
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64bf98c7c6154ad398b778a12146af16~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天以后的日期全部为灰色，不可选状态。&lt;/p&gt;
&lt;h4 id=&quot;设置深色主题&quot;&gt;设置深色主题&lt;/h4&gt;
&lt;p&gt;设置深色主题使 &lt;code&gt;builder&lt;/code&gt; ，其用于包装对话框窗口小部件以添加继承的窗口小部件，例如&lt;code&gt;Theme&lt;/code&gt;，设置深色主题如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime(2010),
  lastDate: DateTime(2025),
  builder: (context,child){
    return Theme(
      data: ThemeData.dark(),
      child: child,
    );
  }
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c342dd476ff45b28c7ffe297a8a60b3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;获取选中的日期&quot;&gt;获取选中的日期&lt;/h4&gt;
&lt;p&gt;showDatePicker 方法是 Future 方法，点击日期选择控件的确定按钮后，返回选择的日期。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await showDatePicker(
              context: context,
              initialDate: DateTime.now(),
              firstDate: DateTime(2010),
              lastDate: DateTime(2025),
            );

print('$result');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;result 为选择的日期。&lt;/p&gt;
&lt;h3 id=&quot;calendardatepicker&quot;&gt;CalendarDatePicker&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;日期组件&lt;/strong&gt;直接显示在页面上，而不是弹出显示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CalendarDatePicker(
  initialDate: DateTime.now(),
  firstDate: DateTime(2010),
  lastDate: DateTime(2025),
  onDateChanged: (d) {
    print('$d');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8a4f0bd19c44a9192bbba80267c4253~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其参数和 showDatePicker 一样。&lt;/p&gt;
&lt;h3 id=&quot;范围日期&quot;&gt;范围日期&lt;/h3&gt;
&lt;p&gt;选择范围日期使用 &lt;strong&gt;showDateRangePicker&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('范围日期'),
  onPressed: () async {
    var date = showDateRangePicker(context: context, firstDate: DateTime(2010), lastDate: DateTime(2025));
  },
),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd2901d917d412f95f8299368bc7656~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其参数和 showDatePicker 一样。&lt;/p&gt;
&lt;p&gt;范围日期结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40d5e27b9e334ed090914bdbd30000ae~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标题&lt;/li&gt;
&lt;li&gt;选定的日期范围&lt;/li&gt;
&lt;li&gt;切换到&lt;strong&gt;输入模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;月和年标签&lt;/li&gt;
&lt;li&gt;当前时间&lt;/li&gt;
&lt;li&gt;开始时间&lt;/li&gt;
&lt;li&gt;选中时间范围&lt;/li&gt;
&lt;li&gt;结束时间&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;国际化&quot;&gt;国际化&lt;/h3&gt;
&lt;p&gt;国际化都是一个套路，下面以 &lt;strong&gt;showDatePicker&lt;/strong&gt; 为例：&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;pubspec.yaml&lt;/strong&gt; 中引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;dependencies:
  flutter_localizations:
    sdk: flutter
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在顶级组件 &lt;strong&gt;MaterialApp&lt;/strong&gt; 添加支持：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;MaterialApp(
  title: 'Flutter Demo',

  localizationsDelegates: [
    GlobalMaterialLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
  ],
  supportedLocales: [
    const Locale('zh'),
    const Locale('en'),
  ],
  ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;弹出日期组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime(2010),
  lastDate: DateTime(2025),
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时将系统语音调整为&lt;strong&gt;中文&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2101a742179545a289a744104035cec7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此组件只支持&lt;strong&gt;中文&lt;/strong&gt;，不管系统设置语言：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = await showDatePicker(
  context: context,
  initialDate: DateTime.now(),
  firstDate: DateTime(2010),
  lastDate: DateTime(2025),
  locale: Locale('zh')
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;material风格时间选择器&quot;&gt;Material风格时间选择器&lt;/h2&gt;
&lt;p&gt;Flutter 1.20 版本更新了 &lt;strong&gt;时间&lt;/strong&gt; 类组件的样式。&lt;/p&gt;
&lt;h3 id=&quot;基础使用&quot;&gt;基础使用&lt;/h3&gt;
&lt;p&gt;弹出时间组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('弹出时间选择器'),
  onPressed: () async {
    var result =
        showTimePicker(context: context, initialTime: TimeOfDay.now());
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59ca64a7d5c34121a7e7a2235a0b8653~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.20 版以前的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df58f8fbb5fc4ceab39572ce54f5e350~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置 &lt;strong&gt;交互模式&lt;/strong&gt;，交互模式包含 &lt;strong&gt;时钟模式&lt;/strong&gt;（默认）和 &lt;strong&gt;输入模式&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = showTimePicker(
    context: context,
    initialTime: TimeOfDay.now(),
    initialEntryMode: TimePickerEntryMode.input);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;时钟模式（TimePickerEntryMode.dial）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07a7a11e6ce04ad1a4b2a472f4d72c6b~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入模式（TimePickerEntryMode.input）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8151b5089b44d4bbb8b8a9123827218~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置顶部标题、取消按钮、确定按钮 文案：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = showTimePicker(
    context: context,
    initialTime: TimeOfDay.now(),
    initialEntryMode: TimePickerEntryMode.input,
    helpText: '选择时间',
    cancelText: '取消',
    confirmText: '确定');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffe5f8fd66ee4872ac30e55ada0dd384~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24小时-制：&quot;&gt;24小时 制：&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = showTimePicker(
  context: context,
  initialTime: TimeOfDay.now(),
  builder: (BuildContext context, Widget child) {
    return MediaQuery(
      data: MediaQuery.of(context)
          .copyWith(alwaysUse24HourFormat: true),
      child: child,
    );
  },
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6dbbb308fb1544b795c94b123a1e3d32~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;黑暗模式&quot;&gt;黑暗模式&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = showTimePicker(
  context: context,
  initialTime: TimeOfDay.now(),
  builder: (BuildContext context, Widget child) {
    return Theme(
      data: ThemeData.dark(),
      child: child,
    );
  },
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e61e16dffd3543ee9c562280ce37c535~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;国际化-2&quot;&gt;国际化&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;pubspec.yaml&lt;/strong&gt; 中引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;dependencies:
  flutter_localizations:
    sdk: flutter
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在顶级组件 &lt;strong&gt;MaterialApp&lt;/strong&gt; 添加支持：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;MaterialApp(
  title: 'Flutter Demo',

  localizationsDelegates: [
    GlobalMaterialLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
  ],
  supportedLocales: [
    const Locale('zh'),
    const Locale('en'),
  ],
  ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;弹出时间组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  child: Text('弹出时间选择器'),
  onPressed: () async {
    var result =
        showTimePicker(context: context, initialTime: TimeOfDay.now());
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切换系统语言为中文：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cd31ba5b6f543adb5d3c3a12be19c10~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不跟随系统语言，直接指定，比如当前系统语言为中文，指定为英文：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var result = showTimePicker(
  context: context,
  initialTime: TimeOfDay.now(),
  builder: (BuildContext context, Widget child) {
    return Localizations(
      locale: Locale('en'),
      delegates: [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
      ],
      child: child,
    );
  },
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c5504342963f4cdbbba2321befe0e5cc~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ios风格日期选择器&quot;&gt;iOS风格日期选择器&lt;/h2&gt;
&lt;h3 id=&quot;基础使用-2&quot;&gt;基础使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CupertinoDatePicker&lt;/strong&gt; 是 iOS风格的日期选择器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class CupertinoDatePickerDemo extends StatefulWidget {
  @override
  _CupertinoDatePickerDemoState createState() =&amp;gt; _CupertinoDatePickerDemoState();
}

class _CupertinoDatePickerDemoState extends State&amp;lt;CupertinoDatePickerDemo&amp;gt; {

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Center(
        child: Container(
          height: 200,
          color: Colors.grey.withOpacity(.5),
          child: CupertinoDatePicker(
            initialDateTime: DateTime.now(),
            onDateTimeChanged: (date) {
              print('$date');
            },
          ),
        ),
      ),
    );
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cab65cb96af441f99261842dbcc188c~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置最大/小时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoDatePicker(
  initialDateTime: DateTime.now(),
  minimumDate: DateTime.now().add(Duration(days: -1)),
  maximumDate: DateTime.now().add(Duration(days: 1)),
  onDateTimeChanged: (date) {
    print('$date');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最大时间为明天，最小时间为昨天：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/538b1d7aa8de420e958efd6cb330b1ea~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置模式为&lt;strong&gt;时间&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CupertinoDatePicker(
  mode: CupertinoDatePickerMode.time,
  initialDateTime: DateTime.now(),
  onDateTimeChanged: (date) {
    print('$date');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9587db9b4e24190a1858f33c7d11468~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置模式为&lt;strong&gt;日期&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoDatePicker(
  mode: CupertinoDatePickerMode.date,
  initialDateTime: DateTime.now(),
  onDateTimeChanged: (date) {
    print('$date');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/346ce5d897214e3bb95ad0c870a97d2e~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置模式为&lt;strong&gt;日期和时间&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoDatePicker(
  mode: CupertinoDatePickerMode.dateAndTime,
  initialDateTime: DateTime.now(),
  onDateTimeChanged: (date) {
    print('$date');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2991c26185d46e28ccb0471bd4a8e34~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;time&lt;/strong&gt;：只显示时间，效果：&lt;code&gt;4 | 14 | PM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;date&lt;/strong&gt;：只显示日期，效果：&lt;code&gt;July | 13 | 2012&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dateAndTime&lt;/strong&gt;：时间和日期都显示，效果： &lt;code&gt;Fri Jul 13 | 4 | 14 | PM&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用24小时制：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoDatePicker(
  use24hFormat: true,
  initialDateTime: DateTime.now(),
  onDateTimeChanged: (date) {
    print('$date');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d9ab2e6904b4e5f8a618e0b7f57aa28~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;国际化-3&quot;&gt;国际化&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;pubspec.yaml&lt;/strong&gt; 中引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;dependencies:
  flutter_localizations:
    sdk: flutter
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在顶级组件 &lt;strong&gt;MaterialApp&lt;/strong&gt; 添加支持：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;MaterialApp(
  title: 'Flutter Demo',

  localizationsDelegates: [
    GlobalMaterialLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
  ],
  supportedLocales: [
    const Locale('zh'),
    const Locale('en'),
  ],
  ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组件使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoDatePicker(
  initialDateTime: DateTime.now(),
  onDateTimeChanged: (date) {
    print('$date');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组件语言跟随系统语言，当前系统语言为英文，效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e225b897044f4011ab62bb707d5765e3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不跟随系统语言，直接指定，比如当前系统语言为英文，指定为中文：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Localizations(
  locale: Locale('zh'),
  delegates: [
    GlobalMaterialLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
  ],
  child: CupertinoDatePicker(
    initialDateTime: DateTime.now(),
    onDateTimeChanged: (date) {
      print('$date');
    },
  ),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7796274d8a24947a25d2ea5f5882401~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ios风格时间选择器&quot;&gt;iOS风格时间选择器&lt;/h2&gt;
&lt;h3 id=&quot;基础使用-3&quot;&gt;基础使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;CupertinoTimerPicker&lt;/strong&gt; 是 iOS风格的时间选择器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoTimerPicker(onTimerDurationChanged: (time) {
  print('$time');
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/023a842f31d74beba405c9228e2b36e9~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置显示模式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;CupertinoTimerPickerMode.hm&lt;/strong&gt;：显示 小时 | 分钟，英文效果&lt;code&gt;16 hours | 14 min&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CupertinoTimerPickerMode.ms&lt;/strong&gt;： 显示 分钟 | 秒，英文效果&lt;code&gt;14 min | 43 sec&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CupertinoTimerPickerMode.hms&lt;/strong&gt;：显示 小时 | 分钟 | 秒，英文效果&lt;code&gt;16 hours | 14 min | 43 sec&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoTimerPicker(
    mode: CupertinoTimerPickerMode.hm,
    onTimerDurationChanged: (time) {
      print('$time');
    })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f249afd4dc3409b879561528ddee4ff~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，CupertinoTimerPicker显示0:0:0，设置显示当前时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoTimerPicker(
    initialTimerDuration: Duration(
        hours: DateTime.now().hour,
        minutes: DateTime.now().minute,
        seconds: DateTime.now().second),
    onTimerDurationChanged: (time) {
      print('$time');
    })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d65db5210e44a6ebaff24e2c9cfaa67~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置 分/秒 的间隔：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoTimerPicker(
    minuteInterval: 5,
    secondInterval: 5,
    onTimerDurationChanged: (time) {
      print('$time');
    })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70aa7412f2b04b4f819d49c0478ce1f3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;国际化-4&quot;&gt;国际化&lt;/h3&gt;
&lt;p&gt;在 &lt;strong&gt;pubspec.yaml&lt;/strong&gt; 中引入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;dependencies:
  flutter_localizations:
    sdk: flutter
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在顶级组件 &lt;strong&gt;MaterialApp&lt;/strong&gt; 添加支持：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;MaterialApp(
  title: 'Flutter Demo',

  localizationsDelegates: [
    GlobalMaterialLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
  ],
  supportedLocales: [
    const Locale('zh'),
    const Locale('en'),
  ],
  ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组件使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoTimerPicker(onTimerDurationChanged: (time) {
  print('$time');
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组件语言跟随系统语言，当前系统语言为英文，效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8d883bb37c943708ff97e5fb1ca52ed~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不跟随系统语言，直接指定，比如当前系统语言为英文，指定为中文：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;Localizations(
  locale: Locale('zh'),
  delegates: [
    GlobalMaterialLocalizations.delegate,
    GlobalWidgetsLocalizations.delegate,
    GlobalCupertinoLocalizations.delegate,
  ],
  child: CupertinoTimerPicker(onTimerDurationChanged: (time) {
    print('$time');
  }),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a5cb0c592f94dac8644d10dee388d17~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;interactiveviewer&quot;&gt;InteractiveViewer&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;InteractiveViewer&lt;/strong&gt; 是 Flutter 1.20 新增的组件，用户可以通过拖动以平移、缩放和拖放子组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;InteractiveViewer(
  child: Image.asset('assets/images/go_board_09x09.png'),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bfdac0a5bbab422ab07653036a57e536~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;alignPanAxis&lt;/strong&gt; 参数表示是否只在水平和垂直方向上拖拽，默认为false，设置为true，无法沿着对角线（斜着）方向移动。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;InteractiveViewer(
  alignPanAxis: true,
  child: Image.asset('assets/images/go_board_09x09.png'),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8715b3000844ee59df8ff9359d9301b~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;maxScale&lt;/strong&gt; 、&lt;strong&gt;minScale&lt;/strong&gt;、&lt;strong&gt;scaleEnabled&lt;/strong&gt; 是缩放相关参数，分别表示最大缩放倍数、最小缩放倍数、是否可以缩放：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;InteractiveViewer(
  maxScale: 2,
  minScale: 1,
  scaleEnabled: true,
  child: Image.asset('assets/images/go_board_09x09.png'),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;constrained&lt;/strong&gt; 参数表示组件树中的约束是否应用于子组件，默认为true，如果设为true，表示子组件是无限制约束，这对子组件的尺寸比 InteractiveViewer 大时非常有用，比如子组件为滚动系列组件。&lt;/p&gt;
&lt;p&gt;如下的案例，子组件为 Table，Table 尺寸大于屏幕，必须将&lt;code&gt;constrained&lt;/code&gt;设置为 false 以便将其绘制为完整尺寸。超出的屏幕尺寸可以平移到视图中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class InteractiveViewerDemo extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    const int _rowCount = 20;
    const int _columnCount = 10;
    return Scaffold(
      appBar: AppBar(),
      body: Center(
        child: Container(
          height: 300,
          width: 300,
          child: InteractiveViewer(
            constrained: false,
            child: Table(
              columnWidths: &amp;lt;int, TableColumnWidth&amp;gt;{
                for (int column = 0; column &amp;lt; _columnCount; column += 1)
                  column: const FixedColumnWidth(100.0),
              },
              children: &amp;lt;TableRow&amp;gt;[
                for (int row = 0; row &amp;lt; _rowCount; row += 1)
                  TableRow(
                    children: &amp;lt;Widget&amp;gt;[
                      for (int column = 0; column &amp;lt; _columnCount; column += 1)
                        Container(
                          height: 50,
                          color: row % 2 + column % 2 == 1
                              ? Colors.red
                              : Colors.green,
                        ),
                    ],
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/230052b354f34f1d9acab75aaa9bed7a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回调事件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;onInteractionStart&lt;/strong&gt;：当用户开始平移或缩放手势时调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onInteractionUpdate&lt;/strong&gt;：当用户更新组件上的平移或缩放手势时调用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;onInteractionEnd&lt;/strong&gt;：当用户在组件上结束平移或缩放手势时调用。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;InteractiveViewer(
  child: Image.asset('assets/images/go_board_09x09.png'),
  onInteractionStart: (ScaleStartDetails scaleStartDetails){
    print('onInteractionStart:$scaleStartDetails');
  },
  onInteractionUpdate: (ScaleUpdateDetails scaleUpdateDetails){
    print('onInteractionUpdate:$scaleUpdateDetails');
  },
  onInteractionEnd: (ScaleEndDetails endDetails){
    print('onInteractionEnd:$endDetails');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;strong&gt;Matrix4&lt;/strong&gt; 矩阵对其进行变换，比如左移、放大等，添加变换控制器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;final TransformationController _transformationController =
      TransformationController();

InteractiveViewer(
  child: Image.asset('assets/images/go_board_09x09.png'),
  transformationController: _transformationController,
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;放大变换：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var matrix = _transformationController.value.clone();
matrix.scale(1.5, 1.0, 1.0);
_transformationController.value = matrix;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;import 'dart:math';

import 'package:flutter/material.dart';

///
/// desc:
///

class InteractiveViewerDemo extends StatefulWidget {
  @override
  _InteractiveViewerDemoState createState() =&amp;gt; _InteractiveViewerDemoState();
}

class _InteractiveViewerDemoState extends State&amp;lt;InteractiveViewerDemo&amp;gt; {
  final TransformationController _transformationController =
      TransformationController();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(),
      body: Column(
        children: [
          Container(
            padding: EdgeInsets.symmetric(horizontal: 10.0),
            child: Center(
              child: InteractiveViewer(
                child: Image.asset('assets/images/go_board_09x09.png'),
                transformationController: _transformationController,
              ),
            ),
          ),
          Expanded(
            child: Container(),
          ),
          Row(
            children: [
              RaisedButton(
                child: Text('重置'),
                onPressed: () {
                  _transformationController.value = Matrix4.identity();
                },
              ),
              RaisedButton(
                child: Text('左移'),
                onPressed: () {
                  var matrix = _transformationController.value.clone();
                  matrix.translate(-5.0);
                  _transformationController.value = matrix;
                },
              ),
              RaisedButton(
                child: Text('放大'),
                onPressed: () {
                  var matrix = _transformationController.value.clone();
                  matrix.scale(1.5, 1.0, 1.0);
                  _transformationController.value = matrix;
                },
              ),
            ],
          ),
        ],
      ),
    );
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2c1523680b8c4fe79b6f4999c51b2a97~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（330个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200911070744287-1731667927.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202009/467322-20200911070744549-1311450165.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Thu, 10 Sep 2020 23:08:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>老孟导读：Flutter 1.20 更新了 Slider、RangeSlider、日期选择器组件、时间选择器组件的样式，新增了交换组件：InteractiveViewer，下面详细介绍其用法。 滑块</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/13649555.html</dc:identifier>
</item>
<item>
<title>数据结构与算法之排序 - 平酱</title>
<link>http://www.cnblogs.com/p1ng/p/13649366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/p1ng/p/13649366.html</guid>
<description>&lt;ul&gt;&lt;li&gt;冒泡排序（Bubble Sort）&lt;/li&gt;
&lt;li&gt;插入排序（Insertion Sort）&lt;/li&gt;
&lt;li&gt;归并排序（Merge Sort）&lt;/li&gt;
&lt;li&gt;快速排序（Quick Sort）&lt;/li&gt;
&lt;li&gt;堆排序（Heap Sort）&lt;/li&gt;
&lt;li&gt;计数排序（Counting Sort）&lt;/li&gt;
&lt;li&gt;桶排序（Bucket Sort)&lt;/li&gt;
&lt;li&gt;拓扑排序（Topological Sort）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;冒泡排序（bubble-sort）&quot;&gt;冒泡排序（Bubble Sort）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个数组，我们把数组里的元素通通倒入到水池中，这些元素将通过相互之间的比较，按照大小顺序一个一个地像气泡一样浮出水面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一轮，从杂乱无章的数组头部开始，每两个元素比较大小并进行交换，直到这一轮当中最大或最小的元素被放置在数组的尾部，然后不断地重复这个过程，直到所有元素都排好位置。其中，核心操作就是元素相互比较。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定数组 [2, 1, 7, 9, 5, 8]，要求按照从左到右、从小到大的顺序进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从左到右依次冒泡，把较大的数往右边挪动即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014254233-1489169770.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;22.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;首先指针指向第一个数，比较第一个数和第二个数的大小，由于 2 比 1 大，所以两两交换，[1, 2, 7, 9, 5, 8]。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;接下来指针往前移动一步，比较 2 和 7，由于 2 比 7 小，两者保持不动，[1, 2, 7, 9, 5, 8]。到目前为止，7 是最大的那个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;指针继续往前移动，比较 7 和 9，由于 7 比 9 小，两者保持不动，[1, 2, 7, 9, 5, 8]。现在，9 变成了最大的那个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;再往后，比较 9 和 5，很明显，9 比 5 大，交换它们的位置，[1, 2, 7, 5, 9, 8]。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;最后，比较 9 和 8，9 比 8 大，交换它们的位置，[1, 2, 7, 5, 8, 9]。经过第一轮的两两比较，9 这个最大的数就像冒泡一样冒到了数组的最后面。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;接下来进行第二轮的比较，把指针重新指向第一个元素，重复上面的操作，最后，数组变成了：[1, 2, 5, 7, 8, 9]。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在进行新一轮的比较中，判断一下在上一轮比较的过程中有没有发生两两交换，如果一次交换都没有发生，就证明其实数组已经排好序了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void bubbleSort(int[] nums) {
        // 定义一个布尔变量 hasChange，用来标记每轮遍历中是否发生了交换
        boolean hasChange = true;
        for (int i = 0; i &amp;lt; nums.length - 1 &amp;amp;&amp;amp; hasChange; i++) {
            // 每轮遍历开始，将 hasChange 设置为 false
            hasChange = false;
            // 进行两两比较，如果发现当前的数比下一个数还大，那么就交换这两个数，同时记录一下有交换发生
            for (int j = 0; j &amp;lt; nums.length - 1 - i; j++) {
                if (nums[j] &amp;gt; nums[j+1]) {
                    swap(nums, j, j+1);
                    hasChange = true;
                }
            }
        }
    }
        // 交换数组中的两个数
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设数组的元素个数是 n，由于在整个排序的过程中，我们是直接在给定的数组里面进行元素的两两交换，所以空间复杂度是 O(1)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;给定的数组按照顺序已经排好&lt;/p&gt;
&lt;p&gt;在这种情况下，我们只需要进行 n−1 次的比较，两两交换次数为 0，时间复杂度是 O(n)。这是最好的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;给定的数组按照逆序排列&lt;/p&gt;
&lt;p&gt;在这种情况下，我们需要进行 n(n-1)/2 次比较，时间复杂度是 O(n2)。这是最坏的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;给定的数组杂乱无章&lt;/p&gt;
&lt;p&gt;在这种情况下，平均时间复杂度是 O(n2)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由此可见，冒泡排序的时间复杂度是 O(n2)。它是一种稳定的排序算法。（稳定是指如果数组里两个相等的数，那么排序前后这两个相等的数的相对位置保持不变。）&lt;/p&gt;
&lt;h2 id=&quot;插入排序（insertion-sort）&quot;&gt;插入排序（Insertion Sort）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不断地将尚未排好序的数插入到已经排好序的部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在冒泡排序中，经过每一轮的排序处理后，数组后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，数组前端的数都是排好序的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对数组 [2, 1, 7, 9, 5, 8] 进行插入排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先将数组分成左右两个部分，左边是已经排好序的部分，右边是还没有排好序的部分，刚开始，左边已排好序的部分只有第一个元素 2。接下来，我们对右边的元素一个一个进行处理，将它们放到左边。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014337107-1006155320.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先来看 1，由于 1 比 2 小，需要将 1 插入到 2 的前面，做法很简单，两两交换位置即可，[1, 2, 7, 9, 5, 8]。&lt;/li&gt;
&lt;li&gt;然后，我们要把 7 插入到左边的部分，由于 7 已经比 2 大了，表明它是目前最大的元素，保持位置不变，[1, 2, 7, 9, 5, 8]。&lt;/li&gt;
&lt;li&gt;同理，9 也不需要做位置变动，[1, 2, 7, 9, 5, 8]。&lt;/li&gt;
&lt;li&gt;接下来，如何把 5 插入到合适的位置。首先比较 5 和 9，由于 5 比 9 小，两两交换，[1, 2, 7, 5, 9, 8]，继续，由于 5 比 7 小，两两交换，[1, 2, 5, 7, 9, 8]，最后，由于 5 比 2 大，此轮结束。&lt;/li&gt;
&lt;li&gt;最后一个数是 8，由于 8 比 9 小，两两交换，[1, 2, 5, 7, 8, 9]，再比较 7 和 8，发现 8 比 7 大，此轮结束。到此，插入排序完毕。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void insertionSort(int[] nums) {
        // 将数组的第一个元素当作已经排好序的，从第二个元素，即 i 从 1 开始遍历数组
        for (int i = 1, j, current; i &amp;lt; nums.length; i++) {
            // 外围循环开始，把当前 i 指向的值用 current 保存
            current = nums[i];
            // 指针 j 内循环，和 current 值比较，若 j 所指向的值比 current 值大，则该数右移一位
            for (j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; nums[j] &amp;gt; current; j--) {
                nums[j + 1] = nums[j];
            }
            // 内循环结束，j+1 所指向的位置就是 current 值插入的位置
            nums[j + 1] = current;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设数组的元素个数是 n，由于在整个排序的过程中，是直接在给定的数组里面进行元素的两两交换，空间复杂度是 O(1)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;给定的数组按照顺序已经排好&lt;/p&gt;
&lt;p&gt;只需要进行 n-1 次的比较，两两交换次数为 0，时间复杂度是 O(n)。这是最好的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;给定的数组按照逆序排列&lt;/p&gt;
&lt;p&gt;在这种情况下，我们需要进行 n(n-1)/2 次比较，时间复杂度是 O(n2)。这是最坏的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;给定的数组杂乱无章&lt;/p&gt;
&lt;p&gt;在这种情况下，平均时间复杂度是 O(n2)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由此可见，和冒泡排序一样，插入排序的时间复杂度是 O(n2)，并且它也是一种稳定的排序算法。&lt;/p&gt;
&lt;h2 id=&quot;归并排序（merge-sort）&quot;&gt;归并排序（Merge Sort）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;核心是分治，就是把一个复杂的问题分成两个或多个相同或相似的子问题，然后把子问题分成更小的子问题，直到子问题可以简单的直接求解，最原问题的解就是子问题解的合并。归并排序将分治的思想体现得淋漓尽致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一开始先把数组从中间划分成两个子数组，一直递归地把子数组划分成更小的子数组，直到子数组里面只有一个元素，才开始排序。&lt;/p&gt;
&lt;p&gt;排序的方法就是按照大小顺序合并两个元素，接着依次按照递归的返回顺序，不断地合并排好序的子数组，直到最后把整个数组的顺序排好。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例题：利用归并排序算法对数组 [2, 1, 7, 9, 5, 8] 进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014407452-1369183789.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先不断地对数组进行切分，直到各个子数组里只包含一个元素。&lt;/p&gt;
&lt;p&gt;接下来递归地按照大小顺序合并切分开的子数组，递归的顺序和二叉树里的前序遍历类似。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;合并 [2] 和 [1] 为 [1, 2]。&lt;/li&gt;
&lt;li&gt;子数组 [1, 2] 和 [7] 合并。&lt;/li&gt;
&lt;li&gt;右边，合并 [9] 和 [5]。&lt;/li&gt;
&lt;li&gt;然后合并 [5, 9] 和 [8]。&lt;/li&gt;
&lt;li&gt;最后合并 [1, 2, 7] 和 [5, 8, 9] 成 [1, 2, 5, 8, 9]，就可以把整个数组排好序了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;合并数组 [1, 2, 7] 和 [5, 8, 9] 的操作步骤如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014426768-75915295.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把数组 [1, 2, 7] 用 L 表示，[5, 8, 9] 用 R 表示。&lt;/li&gt;
&lt;li&gt;合并的时候，开辟分配一个新数组 T 保存结果，数组大小应该是两个子数组长度的总和&lt;/li&gt;
&lt;li&gt;然后下标 i、j、k 分别指向每个数组的起始点。&lt;/li&gt;
&lt;li&gt;接下来，比较下标i和j所指向的元素 L[i] 和 R[j]，按照大小顺序放入到下标 k 指向的地方，1 小于 5。&lt;/li&gt;
&lt;li&gt;移动 i 和 k，继续比较 L[i] 和 R[j]，2 比 5 小。&lt;/li&gt;
&lt;li&gt;i 和 k 继续往前移动，5 比 7 小。&lt;/li&gt;
&lt;li&gt;移动 j 和 k，继续比较 L[i] 和 R[j]，7 比 8 小。&lt;/li&gt;
&lt;li&gt;这时候，左边的数组已经处理完毕，直接将右边数组剩余的元素放到结果数组里就好。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;合并之所以能成功，先决条件必须是两个子数组都已经分别排好序了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void mergeSort(int[] arr, int lo, int hi) {
        // 判断是否只剩下最后一个元素
        if (lo &amp;gt;= hi) {
            return;
        }
        // 从中间将数组分成两个部分
        int mid = lo + (hi - lo) / 2;
        // 分别递归地将左右两半排好序
        mergeSort(arr, lo, mid);
        mergeSort(arr, mid + 1, hi);
        // 将排好序的左右两半合并
        merge(arr, lo, mid, hi);
    }
    // 归并
    public static void merge(int[] nums, int lo, int mid, int hi) {
        // 复制一份原来的数组
        int[] copy = nums.clone();
        // 定义一个 k 指针表示从什么位置开始修改原来的数组，i 指针表示左半边的起始位置，j 表示右半边的起始位置
        int k = lo, i = lo, j = mid + 1;
        while(k &amp;lt;= hi) {
            if(i &amp;gt; mid) {
                nums[k++] = copy[j++];
            } else if(j &amp;gt; hi) {
                nums[k++] = copy[i++];
            } else if(copy[j] &amp;lt; copy[i]) {
                nums[k++] = copy[j++];
            } else {
                nums[k++] = copy[i++];
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，While 语句比较，一共可能会出现四种情况。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;左半边的数都处理完毕，只剩下右半边的数，只需要将右半边的数逐个拷贝过去。&lt;/li&gt;
&lt;li&gt;右半边的数都处理完毕，只剩下左半边的数，只需要将左半边的数逐个拷贝过去就好。&lt;/li&gt;
&lt;li&gt;右边的数小于左边的数，将右边的数拷贝到合适的位置，j 指针往前移动一位。&lt;/li&gt;
&lt;li&gt;左边的数小于右边的数，将左边的数拷贝到合适的位置，i 指针往前移动一位。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于合并 n 个元素需要分配一个大小为 n 的额外数组，合并完成之后，这个数组的空间就会被释放，所以算法的空间复杂度就是 O(n)。归并排序也是稳定的排序算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;归并算法是一个不断递归的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;：数组的元素个数是 n，时间复杂度是 T(n) 的函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法&lt;/strong&gt;：把这个规模为 n 的问题分成两个规模分别为 n/2 的子问题，每个子问题的时间复杂度就是 T(n/2)，那么两个子问题的复杂度就是 2×T(n/2)。当两个子问题都得到了解决，即两个子数组都排好了序，需要将它们合并，一共有 n 个元素，每次都要进行最多 n-1 次的比较，所以合并的复杂度是 O(n)。由此我们得到了递归复杂度公式：T(n) = 2×T(n/2) + O(n)。&lt;/p&gt;
&lt;p&gt;对于公式求解，不断地把一个规模为 n 的问题分解成规模为 n/2 的问题，一直分解到规模大小为 1。如果 n 等于 2，只需要分一次；如果 n 等于 4，需要分 2 次。这里的次数是按照规模大小的变化分类的。&lt;/p&gt;
&lt;p&gt;以此类推，对于规模为 n 的问题，一共要进行 log(n) 层的大小切分。在每一层里，我们都要进行合并，所涉及到的元素其实就是数组里的所有元素，因此，每一层的合并复杂度都是 O(n)，所以整体的复杂度就是 O(nlogn)。&lt;/p&gt;
&lt;h2 id=&quot;快速排序（quick-sort）&quot;&gt;快速排序（Quick Sort）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快速排序也采用了分治的思想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把原始的数组筛选成较小和较大的两个子数组，然后递归地排序两个子数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;：把班里的所有同学按照高矮顺序排成一排。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解法&lt;/strong&gt;：老师先随机地挑选了同学 A，让所有其他同学和 A 比高矮，比 A 矮的都站在 A 的左边，比 A 高的都站在 A 的右边。接下来，老师分别从左边和右边的同学里选择了同学 B 和 C，然后不断地筛选和排列下去。&lt;/p&gt;
&lt;p&gt;在分成较小和较大的两个子数组过程中，如何选定一个基准值（也就是同学 A、B、C 等）尤为关键。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对数组 [2, 1, 7, 9, 5, 8] 进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014454657-1840565167.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按照快速排序的思想，首先把数组筛选成较小和较大的两个子数组。&lt;/li&gt;
&lt;li&gt;随机从数组里选取一个数作为基准值，比如 7，于是原始的数组就被分成了两个子数组。注意：快速排序是直接在原始数组里进行各种交换操作，所以当子数组被分割出来的时候，原始数组里的排列也被改变了。&lt;/li&gt;
&lt;li&gt;接下来，在较小的子数组里选 2 作为基准值，在较大的子数组里选 8 作为基准值，继续分割子数组。&lt;/li&gt;
&lt;li&gt;继续将元素个数大于 1 的子数组进行划分，当所有子数组里的元素个数都为 1 的时候，原始数组也被排好序了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public static void quickSort(int[] nums, int lo, int hi) {
        // 判断是否只剩下一个元素，是则直接返回
        if (lo &amp;gt;= hi) {
            return;
        }
        // 利用partition函数找到一个随机基准点
        int p = partition(nums, lo, hi);
        // 递归地对基准点左半边和右半边的数进行排序
        quickSort(nums, lo, p - 1);
        quickSort(nums, p + 1, hi);
    }
    // 获得基准值
    public static int partition(int[] nums, int lo, int hi) {
        // 随机选择一个数作为基准值，nums[hi] 就是基准值
        swap(nums, randRange(lo, hi), hi);
        int i, j;
        // 从左到右用每个数和基准值比较，若比基准值小，则放到指针 i 所指向的位置。循环完毕后，i 指针之前的数都比基准值小
        for (i = lo, j = lo; j &amp;lt; hi; j++) {
            if (nums[j] &amp;lt;= nums[hi]) {
                swap(nums, i++, j);
            }
        }
        // 末尾的基准值放置到指针 i 的位置，i 指针之后的数都比基准值大
        swap(nums, i, j);
        // 返回指针 i，作为基准点的位置
        return i;
    }
    // 获取随机值
    public static int randRange(int lo, int hi) {
        return (int) (lo + Math.random() * (hi - lo + 1));
    }

    // 交换数组中的两个数
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和归并排序不同，快速排序在每次递归的过程中，只需要开辟 O(1) 的存储空间来完成交换操作实现直接对数组的修改，又因为递归次数为 logn，所以它的整体空间复杂度完全取决于压堆栈的次数，因此它的空间复杂度是 O(logn)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;最优情况：被选出来的基准值都是当前子数组的中间数。&lt;/p&gt;
&lt;p&gt;这样的分割，能保证对于一个规模大小为 n 的问题，能被均匀分解成两个规模大小为 n/2 的子问题（归并排序也采用了相同的划分方法），时间复杂度就是：T(n) = 2×T(n/2) + O(n)。&lt;/p&gt;
&lt;p&gt;把规模大小为 n 的问题分解成 n/2 的两个子问题时，和基准值进行了 n-1 次比较，复杂度就是 O(n)。很显然，在最优情况下，快速排序的复杂度也是 O(nlogn)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;最坏情况：基准值选择了子数组里的最大或者最小值&lt;/p&gt;
&lt;p&gt;每次都把子数组分成了两个更小的子数组，其中一个的长度为 1，另外一个的长度只比原子数组少 1。划分过程和冒泡排序的过程类似，算法复杂度为 O(n2)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;tips:可以通过随机地选取基准值来避免出现最坏的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;堆排序（heap-sort）&quot;&gt;堆排序（Heap Sort）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；&lt;/li&gt;
&lt;li&gt;将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&amp;lt;=R[n]；&lt;/li&gt;
&lt;li&gt;由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void heapSort(int[] arr) {
        len = arr.length;
        if (len &amp;lt; 1) {
            return;
        }
        //1.构建一个大根堆
        buildMaxHeap(arr);
        //2.循环将堆首位（最大值）与末位交换，然后再重新调整最大堆
        while(len &amp;gt; 0) {
            swap(arr, 0, len-1);
            len--;
            adjustHeap(arr, 0);
        }
    }
    // 建立大根堆
    public static void buildMaxHeap(int[] arr) {
        // 从最后一个非叶子节点开始向上构造大根堆
        for (int i = (len / 2 -1); i &amp;gt;= 0; i--) {
            adjustHeap(arr, i);
        }
    }
    // 调整使之成为大根堆
    public static void adjustHeap(int[] arr, int i ) {
        int maxIndex = i;
        // 如果有左子树且左子树大于父节点，则将最大指针指向左子树
        if (i * 2 &amp;lt; len &amp;amp;&amp;amp; arr[i * 2] &amp;gt; arr[maxIndex]) {
            maxIndex = i * 2;
        }
        // 如果有右子树且右子树大于父节点，则将最大指针指向右子树
        if (i * 2 + 1 &amp;lt; len &amp;amp;&amp;amp; arr[i * 2 + 1] &amp;gt; arr[maxIndex]) {
            maxIndex = i * 2 + 1;
        }
        // 如果父节点不是最大值，则将父节点与最大值交换并递归调整与父节点交换的位置
        if (maxIndex != i) {
            swap(arr, maxIndex, i);
            adjustHeap(arr, maxIndex);
        }
    }
    // 交换数组中的两个数
    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为O(n)，在交换并重建堆的过程中，需交换n-1次，而重建堆的过程中，根据完全二叉树的性质，[log2(n-1),log2(n-2)...1]逐步递减，近似为nlogn。所以堆排序时间复杂度一般认为就是O(nlogn)级。&lt;/p&gt;
&lt;h2 id=&quot;计数排序（counting-sort）&quot;&gt;计数排序（Counting Sort）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。&lt;/p&gt;
&lt;p&gt;计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找出待排序的数组中最大和最小的元素；&lt;/li&gt;
&lt;li&gt;统计数组中每个值为i的元素出现的次数，存入数组C的第i项；&lt;/li&gt;
&lt;li&gt;对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；&lt;/li&gt;
&lt;li&gt;反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;动图演示&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014637743-423667694.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void countingSort(int[] arr) {
        if (arr.length == 0) {
            return;
        }
        int bias, min = arr[0], max = arr[0];
        // 1.确认数组中的最大值最小值
        for (int i = 1; i &amp;lt; arr.length; i++) {
            if (arr[i] &amp;gt; max) {
                max = arr[i];
            }
            if (arr[i] &amp;lt; min) {
                min = arr[i];
            }
        }
        bias = 0 - min; // bias记录新数组的下标偏移量
        int[] bucket = new int[max - min + 1];
        // 2.统计并存入新数组
        for (int i = 0; i &amp;lt; arr.length; i++) {
            bucket[arr[i] + bias]++;
        }
        int index = 0, i = 0;
        // 3.反向填充目标数组
        while(index &amp;lt; arr.length) {
            if (bucket[i] != 0) {
                arr[index] = i - bias;
                bucket[i]--;
                index++;
            } else {
                i++;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;桶排序（bucket-sort）&quot;&gt;桶排序（Bucket Sort）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;桶排序&lt;/code&gt;是计数排序的升级版。当数列取值范围过大，或者不是整数时不能适用计数排序，这时可以使用桶排序来解决问题。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;桶排序 (Bucket sort)&lt;/code&gt;的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个桶（bucket）代表一个区间范围，里面可以承载一个或多个元素。桶排序的第一步，就是创建这些桶，确定每一个桶的区间范围：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014701202-564535928.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体建立多少个桶，如何确定桶的区间范围，有很多不同的方式。我们这里创建的桶数量等于原始数列的元素数量，除了最后一个桶只包含数列最大值，前面各个桶的区间按照比例确定。&lt;/p&gt;
&lt;p&gt;区间跨度 = （最大值-最小值）/ （桶的数量 - 1）&lt;/p&gt;
&lt;p&gt;第二步，遍历原始数列，把元素对号入座放入各个桶中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014714365-106808606.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步，每个桶内部的元素分别排序（显然，只有第一个桶需要排序）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014726062-668953081.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步，遍历所有的桶，输出所有元素：&lt;/p&gt;
&lt;p&gt;0.5，0.84，2.18，3.25，4.5&lt;/p&gt;
&lt;p&gt;到此为止，排序结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public static void bucketSort(double[] array){
        //1.得到数列的最大值和最小值，并算出差值d
        double max = array[0];
        double min = array[0];
        for(int i=1; i&amp;lt;array.length; i++) {
            if(array[i] &amp;gt; max) {
                max = array[i];
            }
            if(array[i] &amp;lt; min) {
                min = array[i];
            }
        }
        double d = max - min;
        //2.初始化桶
        int bucketNum = array.length;
        ArrayList&amp;lt;LinkedList&amp;lt;Double&amp;gt;&amp;gt; bucketList = new ArrayList&amp;lt;LinkedList&amp;lt;Double&amp;gt;&amp;gt;(bucketNum);
        for(int i = 0; i &amp;lt; bucketNum; i++){
            bucketList.add(new LinkedList&amp;lt;Double&amp;gt;());
        }
        //3.遍历原始数组，将每个元素放入桶中
        for(int i = 0; i &amp;lt; array.length; i++){
            int num = (int)((array[i] - min) * (bucketNum-1) / d);
            bucketList.get(num).add(array[i]);
        }
        //4.对每个通内部进行排序
        for(int i = 0; i &amp;lt; bucketList.size(); i++){
            //JDK底层采用了归并排序或归并的优化版本
            Collections.sort(bucketList.get(i));
        }
        //5.输出全部元素
        int index = 0;
        for(LinkedList&amp;lt;Double&amp;gt; list : bucketList){
            for(double element : list){
                array[index] = element;
                index++;
            }
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：O(N + C)&lt;/p&gt;
&lt;p&gt;对于待排序序列大小为 N，共分为 M 个桶，主要步骤有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;N 次循环，将每个元素装入对应的桶中&lt;/li&gt;
&lt;li&gt;M 次循环，对每个桶中的数据进行排序（平均每个桶有 N/M 个元素）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;一般使用较为快速的排序算法，时间复杂度为 O ( N l o g N )，实际的桶排序过程是以链表形式插入的。&lt;/p&gt;
&lt;p&gt;整个桶排序的时间复杂度为：&lt;/p&gt;
&lt;p&gt;O ( N ) + O ( M ∗ ( N / M ∗ l o g ( N / M ) ) ) = O ( N ∗ ( l o g ( N / M ) + 1 ) )&lt;/p&gt;
&lt;p&gt;当 N = M 时，复杂度为 O ( N )&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;：O（N+M）&lt;/p&gt;
&lt;h2 id=&quot;拓扑排序（topological-sort）&quot;&gt;拓扑排序（Topological Sort）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;基本思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和前面介绍的几种排序不同，拓扑排序应用的场合不再是一个简单的数组，而是研究图论里面顶点和顶点连线之间的性质。拓扑排序就是要将这些顶点按照相连的性质进行排序。&lt;/p&gt;
&lt;p&gt;要能实现拓扑排序，得有几个前提：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;图必须是有向图&lt;/li&gt;
&lt;li&gt;图里面没有环&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;拓扑排序一般用来理清具有依赖关系的任务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;：假设有三门课程 A、B、C，如果想要学习课程 C 就必须先把课程 B 学完，要学习课程 B还得先学习课程 A，所以得出课程的学习顺序应该是 A -&amp;gt; B -&amp;gt; C。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将问题用一个有向无环图（DAG, Directed Acyclic Graph）进行抽象表达，定义出哪些是图的顶点，顶点之间如何互相关联。&lt;/li&gt;
&lt;li&gt;可以利用广度优先搜索或深度优先搜索来进行拓扑排序。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;例题分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个学生想要修完 5 门课程的学分，这 5 门课程分别用 1、2、3、4、5 来表示，现在已知学习这些课程有如下的要求：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;课程 2 和 4 依赖于课程 1&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;课程 3 依赖于课程 2 和 4&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;课程 4 依赖于课程 1 和 2&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;课程 5 依赖于课程 3 和 4&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么这个学生应该按照怎样的顺序来学习这 5 门课程呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解题思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以把 5 门课程看成是一个图里的 5 个顶点，用有向线段按照它们的相互关系连起来，于是得出下面的有向图。&lt;/p&gt;
&lt;p&gt;首先可以看到，这个有向图里没有环，无论从哪个顶点出发，都不会再回到那个顶点。并且，这个图里并没有孤岛的出现，因此，我们可以对它进行拓扑排序。&lt;/p&gt;
&lt;p&gt;方法就是，一开始的时候，对每个顶点统计它们各自的前驱（也就是入度）：1(0)，2(1)，3(2)，4(1)，5(2)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1898410/202009/1898410-20200911014744707-110576302.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择其中一个没有前驱（也就是入度为 0）的顶点，在这道题里面，顶点 1 就是我们要找的那个点，将它作为结果输出。同时删除掉该顶点和所有以它作为起始点的有向边，更新顶点的入度表。&lt;/li&gt;
&lt;li&gt;接下来，顶点 2 就是下一个没有前驱的顶点，输出顶点 2，并将以它作为起点的有向边删除，同时更新入度表。&lt;/li&gt;
&lt;li&gt;再来，顶点 4 成为了没有前驱的顶点，输出顶点 4，删除掉它和顶点 3 和 5 的有向边。&lt;/li&gt;
&lt;li&gt;然后，顶点 3 没有了前驱，输出它，并删除它与 5 的有向边。&lt;/li&gt;
&lt;li&gt;最后，顶点 5 没有前驱，输出它，于是得出最后的结果为：1，2，4，3，5。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一般来说，一个有向无环图可以有一个或多个拓扑排序的序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运用广度优先搜索的方法对这个图的结构进行遍历。在构建这个图的过程中，用一个链接矩阵 adj 来表示这个图的结构，用一个 indegree 的数组统计每个顶点的入度，重点看如何实现拓扑排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;void topologicalSort() {
    Queue&amp;lt;Integer&amp;gt; q = new LinkedList(); // 定义一个队列 q

    // 将所有入度为 0 的顶点加入到队列 q
    for (int v = 0; v &amp;lt; V; v++) {
        if (indegree[v] == 0) q.add(v);
    }

    // 循环，直到队列为空
    while (!q.isEmpty()) {
        int v = q.poll();
        // 每次循环中，从队列中取出顶点，即为按照入度数目排序中最小的那个顶点
        print(v);
        
        // 将跟这个顶点相连的其他顶点的入度减 1，如果发现那个顶点的入度变成了 0，将其加入到队列的末尾
        for (int u = 0; u &amp;lt; adj[v].length; u++) {
            if (--indegree[u] == 0) {
                q.add(u);
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;算法分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;统计顶点的入度需要 O(n) 的时间，接下来每个顶点被遍历一次，同样需要 O(n) 的时间，所以拓扑排序的时间复杂度是 O(n)。&lt;/p&gt;
</description>
<pubDate>Thu, 10 Sep 2020 17:48:00 +0000</pubDate>
<dc:creator>平酱</dc:creator>
<og:description>排序 冒泡排序（Bubble Sort） 插入排序（Insertion Sort） 归并排序（Merge Sort） 快速排序（Quick Sort） 堆排序（Heap Sort） 计数排序（Coun</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/p1ng/p/13649366.html</dc:identifier>
</item>
<item>
<title>再深入一点|binlog和relay-log到底长啥样？ - 科技缪缪</title>
<link>http://www.cnblogs.com/ilovejaney/p/13649345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ilovejaney/p/13649345.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇mysql面试的文章之后收到不少朋友的意见，希望深入讲讲复制、日志的格式这些，今天，我们就来深挖一下mysql的复制机制到底有哪一些，以及binlog和relay-log的结构到底是什么样子的。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;binlog作用&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;binlog的主要作用是记录数据库中表的更改，它只记录改变数据的sql，不改变数据的sql不会写入，比如select语句一般不会被记录，因为他们不会对数据产生任何改动。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个实际的场景看下binlog产生的过程，准备sql：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; test(&lt;span&gt;text&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; test &lt;span&gt;values&lt;/span&gt; (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;test_text&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; test;
flush logs;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看binlog&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
show binlog events &lt;span&gt;in&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;binlog.000029&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;span&gt;显示的结果如下：&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gikthd6sbbj31720cq7al.jpg&quot; alt=&quot;binlog&quot; width=&quot;819&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，也可以使用mysqlbinlog工具来查看binlog的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
show variables &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;log_%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;; #查看日志目录
mysqlbinlog &lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;short-form --force-if-open --base64-output=never /usr/local/var/mysql/binlog.000029&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-string&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gilfsvrgv1j30nw0f2n0v.jpg&quot; alt=&quot;&quot; width=&quot;565&quot; height=&quot;356&quot;/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gilfsaocunj311g0u0hdt.jpg&quot; alt=&quot;&quot; width=&quot;754&quot; height=&quot;604&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从日志我们可以看到执行了创建表的语句以及一个Format_desc头和Ratate轮换事件，这个我们会在后面讲到，先看几个字段代表的含义。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Log_name&lt;/strong&gt;代表日志文件的名称，比如我这里的查询是直接查询binlog.000029，默认的写法是show binlog events，但是这样只会查询到第一个binlog，并不是当前激活状态的binlog，如果你不知道binlog有哪些，可以用命令:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
show &lt;span&gt;binary&lt;/span&gt;&lt;span&gt; logs; #查看binlog列表
show master status; #查看最新的binlog&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gilfb6essgj30eq09wdht.jpg&quot; alt=&quot;&quot; width=&quot;374&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Pos&lt;/strong&gt;代表文件开始的位置。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Event_type&lt;/strong&gt;代表事件的类型。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Server_id&lt;/strong&gt;是创建事件的服务器ID。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;End_log_pos&lt;/strong&gt;代表事件在文件中的结束位置，以上面为例，第一次查询的结束位置是723，第二次insert之后文件的开始位置就是从723开始。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Info&lt;/strong&gt;代表事件信息，是一段可读的文本内容。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;binlog日志结构&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;binlog日志的结构大概是长这样的，它由索引文件和binlog文件组成，其中binlog事件又包含通用头、提交头和事件体3个部分组成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gilcgk2jjij30qe0b4406.jpg&quot; alt=&quot;&quot; width=&quot;566&quot; height=&quot;238&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先说说索引文件，索引文件的每一行都包含了一个binlog文件的完整文件名(类似host-bin.001)，一些命令比如flush logs将所有日志写入磁盘会影响到索引文件。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个binlog文件以若干个binlog事件组成，以格式描述事件(Format_description)作为文件头(上面的binlog图片Format_desc事件)，以日志轮换事件(rotate)作为文件尾。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Format_description&lt;/strong&gt;包含binlog文件的服务器信息、文件状态的关键信息等。如果服务器关闭或者重启，则会创建一个新的binlog文件，同时写入一个新的format_description。他的格式大致如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;2&lt;/span&gt;                binlog&lt;span&gt;-&lt;/span&gt;&lt;span&gt;version
string&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;       mysql&lt;span&gt;-&lt;/span&gt;&lt;span&gt;server version
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;                &lt;span&gt;create&lt;/span&gt; &lt;span&gt;timestamp&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;                event header length
string&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;        event type header lengths
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;日志轮换事件&lt;/strong&gt;则包含下一个binlog的文件名以及开始读取的位置，它由服务器写完binlog后添加到文件尾，轮换事件并不会每次都存在，格式如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; binlog&lt;span&gt;-&lt;/span&gt;version &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;              position
}
string&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;      name &lt;span&gt;of&lt;/span&gt; the &lt;span&gt;next&lt;/span&gt; binlog
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;binlog事件&lt;/strong&gt;包含若干个事务组成的组(group)，每个组对应一个事务，如果是create alter语句不属于事务语句的话，则他们本身就是一个组，每个组要么全部执行，要么都不执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gikjc7j2sij30a60ei0ur.jpg&quot; alt=&quot;&quot; width=&quot;292&quot; height=&quot;416&quot;/&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;binlog事件结构&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个binlog事件由3个部分组成：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;通用头，包含binlog中所有事件具备的基本信息。&lt;/li&gt;
&lt;li&gt;提交头，对于不同类型的事件来说，提交头的内容也不尽相同&lt;/li&gt;
&lt;li&gt;事件体，存储事件的主要数据，同样对于不同类型事件也不同。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;binlog轮换和清理&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子我们也可以看出来，binlog并非只有一个，而基于真实的场景来说，始终写一个binlog文件肯定也是不可取的，而binlog轮换主要有3个场景：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;服务器启动，每次服务器启动都会生成一个新的binlog文件。&lt;/li&gt;
&lt;li&gt;达到最大大小，可以通过binlog-cache-size控制大小，达到最大大小后将更换。&lt;/li&gt;
&lt;li&gt;显示刷新，flush logs将所有日志写入磁盘，这时候会创建一个新的文件写入，从第一个例子也能看出来执行完之后生成了一个新的日志binlog.000030的文件并且开始的位置是4。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1giktnquwn9j30xu03wmye.jpg&quot; alt=&quot;&quot; width=&quot;653&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着时间的推移，我们的binlog文件会越来越多，这时候有两种方式可以清除binlog：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;通过设置expire-logs-days控制想保留的binlog日志文件天数，系统将会自动清理。&lt;/li&gt;
&lt;li&gt;通过PURGE BINARY LOGS手动清理&lt;/li&gt;
&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;prefix&quot;&gt;&lt;span class=&quot;content&quot;&gt;relay-log结构&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;relay-log中继日志是连接master和slave的核心，我们来深入了解一下它的结构和使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gikgt0jis3j30ns0bimzr.jpg&quot; alt=&quot;image-20200909161115718&quot; width=&quot;593&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;relay-log的结构和binlog非常相似，只不过他多了一个master.info和relay-log.info的文件。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;master.info&lt;/strong&gt;记录了上一次读取到master同步过来的binlog的位置，以及连接master和启动复制必须的所有信息。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;relay-log.info&lt;/strong&gt;记录了文件复制的进度，下一个事件从什么位置开始，由sql线程负责更新。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇文章我们提到了整个复制流程的过程大概是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gikts3vqiwj30ta0h23zj.jpg&quot; alt=&quot;&quot; width=&quot;607&quot; height=&quot;354&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道binlog和relay-log的结构之后，我们重新梳理一下整个链路的流程，这里我们假定master.info和relay-log.info都是存在的情况：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;Master收到客户端请求语句，在语句结束之前向二进制日志写入一条记录，可能包含多个事件。&lt;/li&gt;
&lt;li&gt;此时，一个Slave连接到Master，Master的dump线程从binlog读取日志并发送到Slave的IO线程。&lt;/li&gt;
&lt;li&gt;IO线程从master.info读取到上一次写入的最后的位置。&lt;/li&gt;
&lt;li&gt;IO线程写入日志到relay-log中继日志，如果超过指定的relay-log大小，写入轮换事件，创建一个新的relay-log。&lt;/li&gt;
&lt;li&gt;更新master.info的最后位置&lt;/li&gt;
&lt;li&gt;SQL线程从relay-log.info读取进上一次读取的位置&lt;/li&gt;
&lt;li&gt;SQL线程读取日志事件&lt;/li&gt;
&lt;li&gt;在数据库中执行sql&lt;/li&gt;
&lt;li&gt;更新relay-log.info的最后位置&lt;/li&gt;
&lt;li&gt;Slave记录自己的binlog日志&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1gikuupwskzj31jg0s6k1n.jpg&quot; alt=&quot;&quot; width=&quot;771&quot; height=&quot;391&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在这里IO和SQL线程有会产生重复事件的问题，举一个场景：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;先记录中继日志，然后更新master.info位置&lt;/li&gt;
&lt;li&gt;此时服务器崩溃，写入master.info失败&lt;/li&gt;
&lt;li&gt;服务器恢复，再次同步从master.info获取到的是上一次的位置，会导致事件重复执行&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然会有这个问题还为什么要这样做呢？假设反过来，先更新master.info再记录中继日志，这样带来的问题就是丢失数据了。而mysql认为丢失比重复更严重，所以要先刷新日志，保大还是保小mysql帮你做了决定。&lt;/p&gt;
&lt;p&gt;- END -&lt;/p&gt;

</description>
<pubDate>Thu, 10 Sep 2020 17:14:00 +0000</pubDate>
<dc:creator>科技缪缪</dc:creator>
<og:description>上一篇mysql面试的文章之后收到不少朋友的意见，希望深入讲讲复制、日志的格式这些，今天，我们就来深挖一下mysql的复制机制到底有哪一些，以及binlog和relay-log的结构到底是什么样子的。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ilovejaney/p/13649345.html</dc:identifier>
</item>
<item>
<title>Java多线程类FutureTask源码阅读以及浅析 - rainple</title>
<link>http://www.cnblogs.com/rainple/p/13609069.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rainple/p/13609069.html</guid>
<description>&lt;p&gt;　　FutureTask是一个具体的实现类，实现了RunnableFuture接口，RunnableFuture分别继承了Runnable和Future接口，因此FutureTask类既可以被线程执行，又可以拿到线程执行的结果。FutrueTask应用于多线程中异步处理并得到处理结果的场景，比如：加入有个流程需要调用远程接口拿到相关数据在本地进行处理，但是这个接口花费时间比较长。如果使用传统的阻塞线程去处理的话，那么就会一直阻塞在调用接口这里，其它的事情都干不了，这样操作显然效率相对较低的。因此，我们可以使用FutureTask来解决这个问题，FutureTask可以异步调用远端接口，那么当前线程就可以做与远端接口无关的数据，双管齐下提高效率。&lt;/p&gt;
&lt;p&gt;　　FutureTask UML类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1519364/202009/1519364-20200903115737925-876692834.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　FutureTask类简单的使用示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 public static void main(String[] args) throws InterruptedException, ExecutionException {
        FutureTask&amp;lt;String&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(() -&amp;gt; {
            System.out.println(&quot;异步处理&quot;);
            Thread.sleep(3000);
            return &quot;ok&quot;;
        });
        new Thread(futureTask).start();
        System.out.println(&quot;同步处理其它事情&quot;);
        Thread.sleep(1000);
        System.out.println(&quot;等待异步处理结果：&quot; + futureTask.get());
        System.out.println(&quot;处理完成&quot;);
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　FutureTask类有state，callable，outcome，runner和waiters 5个成员变量&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1519364/202009/1519364-20200903155942824-417622120.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;


&lt;h3&gt;　　1.state&lt;/h3&gt;
&lt;p&gt;　　　　线程运行状态，有以下几种状态：&lt;/p&gt;
&lt;p&gt;　　　　　　NEW：初始状态，在初始化时的状态，状态值为0；&lt;/p&gt;
&lt;p&gt;　　　　　　COMPLETING: 完成中状态，run方法被调用时，对返回值进行赋值欠的状态，值为1；&lt;/p&gt;
&lt;p&gt;　　　　　　NORMAL: 正常状态，线程正常执行，在返回值被赋值被赋值成功后的状态，值为2；&lt;/p&gt;
&lt;p&gt;　　　　　　EXCEPTIONAL：异常状态，在执行用户回调方式call的过程中出现异常，值为3；&lt;/p&gt;
&lt;p&gt;　　　　　　CANCELLED： 取消状态，用户调用cancel(false)方法时的状态，值为4；&lt;/p&gt;
&lt;p&gt;　　　　　　INTERRUPTING：打断中状态，用户调用cancel(true)方法时的状态，值为5；&lt;/p&gt;
&lt;p&gt;　　　　　　INTERRUPTED： 被打断状态，用户调用cancel(true)方法时，runner线程执行打断方法完成后的状态，值为6；&lt;/p&gt;

&lt;p&gt;　　　　运行状态转换：&lt;/p&gt;
&lt;p&gt;　　　　　　NEW -&amp;gt; COMPLETING -&amp;gt; NORMAL&lt;/p&gt;
&lt;p&gt;　　　　　　NEW -&amp;gt; COMPLETING -&amp;gt; EXCEPTIONAL&lt;/p&gt;
&lt;p&gt;　　　　　　NEW -&amp;gt; CANCELLED&lt;/p&gt;
&lt;p&gt;　　　　　　NEW -&amp;gt; INTERRUPTING -&amp;gt; INTERRUPTED&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1519364/202009/1519364-20200903151322140-1833170702.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;　　2.callable&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;　　该成员变量用于异步执行用户自定义业务代码，当futureTask获得cpu时间片后调用run方法，在run方法中调用callable.call(),获取到执行结果。&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;em&gt;　　&lt;/em&gt;3.outcome&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;　　异步执行输出结果，类型为object。赋值时机时在callable.call()方式执行完成后。&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;&lt;em&gt;　　&lt;/em&gt;4.runner&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;　　用于执行callable接口，在futureTask被cpu调度时会使用cas赋值为当前线程。当前线程执行完成后设置为null，等待gc回收。&lt;/em&gt;&lt;/p&gt;

&lt;h3&gt;&lt;em&gt;　　&lt;/em&gt;5.waiters&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;　　内部类实现的单向链表，用于等待获取执行结果。每次调用get()方法时都会将该线程放入等待队列的头部，当该线程被打断后，或者get（timeout）方法过期后就会重这个等待队列中移除。当callable.call()执行完成后会从头部开始遍历逐个唤醒等待线程，并将执行结果返回。&lt;/em&gt;&lt;/p&gt;


&lt;h3&gt;　　1.run方法&lt;/h3&gt;
&lt;p&gt;　　run方法间接实现于Runnable的接口，所以当futureTask线程获得cpu资源后会调用该方法。&lt;/p&gt;
&lt;p&gt;　　1.首先先判断当前状态是否为初始化状态，如果不是初始状态直接结束该方法。否则使用cas方式给成员变量runner赋值，赋值为当前线程。用cas方式能够保证多线程环境下赋值是线程安全的。不懂cas的同学自行查阅相关资料。&lt;/p&gt;
&lt;p&gt;　　2.如果callable不为null并且state状态为NEW，则执行callable.call()方法，并得到该方法的返回值。&lt;/p&gt;
&lt;p&gt;　　3.如果执行call方法出现异常时，执行setException方法，该方法将state的NEW状态使用cas方式修改为COMPLETING状态，修改成功后outcome设置为当前抛出的异常，状态再次改为EXCEPTIONAL状态。然后将等待队列中的线程都唤醒，并从队列中移除。调用钩子done()方法，将callable掷为null。&lt;/p&gt;
&lt;p&gt;　　4.如果call方式执行成功，下一步则调用set方法，该方法首先将NEW状态用cas修改成COMPLETING状态，修改成功后将call执行结果赋值到outcome变量，COMPLETING状态修改为NORMAL，唤醒等待线程并从队列移除，调用狗子方法。&lt;/p&gt;
&lt;p&gt;　　5.执行finally代码的代码，将runner掷为null，如果当前状态为打断中，那么会将当前资源让出，直到线程最终被打断。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 /**
     * Runnable#run();
     * 线程获得cpu资源后会执行该方法
     */
    public void run() {
        //判断当前状态是不是初始状态
        //将runner赋值为当前线程
        if (state != NEW ||
            !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                         null, Thread.currentThread()))
            return;
        try {
            Callable&amp;lt;V&amp;gt; c = callable;
            if (c != null &amp;amp;&amp;amp; state == NEW) {
                V result;
                boolean ran;
                try {
                    //调用用户业务流程
                    result = c.call();
                    ran = true;
                } catch (Throwable ex) {
                    result = null;
                    ran = false;
                    //抛出异常，修改响应的状态
                    setException(ex);
                }
                if (ran)
                    set(result);
            }
        } finally {
            // runner must be non-null until state is settled to
            // prevent concurrent calls to run()
            runner = null;
            // state must be re-read after nulling runner to prevent
            // leaked interrupts
            int s = state;
            if (s &amp;gt;= INTERRUPTING)
                handlePossibleCancellationInterrupt(s);
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
     * 1.修改状态值  NEW  --&amp;gt; COMPLETING --&amp;gt;  EXCEPTIONAL
     * 2.移除并唤醒所有等待中的线程
     * @param t
     */
    protected void setException(Throwable t) {
        //将state修改为COMPLETING
        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
            outcome = t;
            //将state修改为EXCEPTIONAL
            UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state
            //对返回值进行处理
            finishCompletion();
        }
    }

/**
     * 1.状态值  NEW  --&amp;gt; COMPLETING  --&amp;gt; NORMAL
     * 2.设置执行结果值
     * 3.唤醒所有等待中的线程
     * @param v
     */
    protected void set(V v) {
        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
            outcome = v;
            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state
            finishCompletion();
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;　　2.get() 和 get(long timeout,TimeUnit timeUnit);&lt;/h3&gt;
&lt;p&gt;　　两个方法的区别在于前者没有超时时间，后者由超时时间，流程是基本差不多的。&lt;/p&gt;
&lt;p&gt;　　1.如果state为COMPLETED，进入report方法，该方法会判断当前的状态为NORMAL时将outcome返回，否则抛出异常。&lt;/p&gt;
&lt;p&gt;　　2.如果state不为COMPLETED进入awaitDone方法。&lt;/p&gt;
&lt;p&gt;　　3.awaitDone方法顾名思义就是等待操作结果。方法里面是一个死循环，在循环过程中如果线程被打断，就会抛出异常，并将刚创建的等待线程从队列中移除。&lt;/p&gt;
&lt;p&gt;　　4.如果状态已完成，将等待线程绑定的线程设为null，并将状态返回。&lt;/p&gt;
&lt;p&gt;　　5.如果当前状态为COMPLETING则将当前cpu资源让出给其它线程。&lt;/p&gt;
&lt;p&gt;　　6.如果等待节点为null，就创建一个新的节点，该节点绑定了当前的线程。&lt;/p&gt;
&lt;p&gt;　　7.如果新创建的节点还没有与等待队列进行绑定，那么就将该节点放入队列头部。&lt;/p&gt;
&lt;p&gt;　　8.如果调用的是由过期时间的方法，那么判断如果已经到期了则将该节点从队列中移除，并返回状态。否则进入有过期的等待。&lt;/p&gt;
&lt;p&gt;　　9.线程进入等待状态，线程会阻塞在这里，等待run方法执行完成后调用unPark方法。&lt;/p&gt;
&lt;p&gt;　　10.线程被唤醒后，进入report方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
     * @throws CancellationException {@inheritDoc}
     */
    /**
     * 获取执行结果
     * @return
     * @throws InterruptedException
     * @throws ExecutionException
     */
    public V get() throws InterruptedException, ExecutionException {
        int s = state;
        if (s &amp;lt;= COMPLETING)
            s = awaitDone(false, 0L);
        return report(s);
    }

    /**
     * @throws CancellationException {@inheritDoc}
     */
    /**
     * 获取执行结果
     * @param timeout
     * @param unit
     * @return
     * @throws InterruptedException
     * @throws ExecutionException
     * @throws TimeoutException
     */
    public V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException {
        if (unit == null)
            throw new NullPointerException();
        int s = state;
        if (s &amp;lt;= COMPLETING &amp;amp;&amp;amp;
            (s = awaitDone(true, unit.toNanos(timeout))) &amp;lt;= COMPLETING)
            throw new TimeoutException();
        return report(s);
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;　　3.awaitDone(boolean timed, long nanos)&lt;/h2&gt;
&lt;p&gt;　　该方法是等待完成，或者线程被打断而抛出异常退出，有或者是经过nanos 这么多纳秒后退出。方法内部是一个死循环，通过各种条件判断是否满足条件退出，否则线程进入等待状态，直到被其他线程唤醒。&lt;/p&gt;
&lt;p&gt;　　1.首先会判断当前线程是否有打断标记，如果被打断过，删除刚创建出来的等待节点，并抛出InterruptedException异常。&lt;/p&gt;
&lt;p&gt;　　2.如果当前任务是已完成状态，直接将当前状态返回。&lt;/p&gt;
&lt;p&gt;　　3.如果当前任务状态为完成中，说明其他线程正在操作，当前线程无需要重复操作，只需要将cpu资源让出来。&lt;/p&gt;
&lt;p&gt;　　4.如果前三个条件均未满足，则会创建等待节点，然后进入第二轮循环。&lt;/p&gt;
&lt;p&gt;　　5.第二轮循环，将第二轮循环创建的等待节点放入等待链表的头部，并使用cas方式给waiters赋值，保证多线程下正常正确的赋值。&lt;/p&gt;
&lt;p&gt;　　6.第三轮循环，如果用户调用的是有过期时间的get方法，则会计算当前剩余时间，1）如果剩余时间小于等于0，则说明已经过期，那么就会移除当前等待中的节点，将当前任务状态返回。2）否则调用LockSupport的有过期时间的parkNanos，该方法会让线程进入等待状态，也即线程会阻塞在这里，过期时间不会超过用户传入的过期时间。如果用户调用的是没有过期时间的方法，那么调用LockSupport的有无过期时间的parkNanos，该方法会让线程无限的等待下午，知道有其他线程将他唤醒。&lt;/p&gt;
&lt;p&gt;　　源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
/**
     * Awaits completion or aborts on interrupt or timeout.
     *
     * 等待完成或打断退出或超时退出
     * @param timed true if use timed waits 是否有超时时间
     * @param nanos time to wait, if timed 等待时间
     * @return state upon completion 状态码
     */
    private int awaitDone(boolean timed, long nanos)
        throws InterruptedException {
        final long deadline = timed ? System.nanoTime() + nanos : 0L;
        WaitNode q = null;
        boolean queued = false;
        for (;;) {
            //返回true，线程被打断过，但并不会直接抛出异常
            //而是等其他线程将线程唤醒之后，发现该线程在等待过程中执行了打断操作
            if (Thread.interrupted()) {
                removeWaiter(q);
                throw new InterruptedException();
            }

            int s = state;
            //这里的意思是任务已完成，又可以能是正常结束，也有可以能是用户取消，或者异常，打断
            if (s &amp;gt; COMPLETING) {
                if (q != null)
                    q.thread = null;
                return s;
            }
            //让出cpu资源
            else if (s == COMPLETING) // cannot time out yet
                Thread.yield();
            //第一次循环会进入这个条件创建节点
            else if (q == null)
                q = new WaitNode();
            //第二次循环给新创建的q节点放在waiters链表的头部
            else if (!queued)
                queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                     q.next = waiters, q);
            else if (timed) {
                nanos = deadline - System.nanoTime();
                //过期退出
                if (nanos &amp;lt;= 0L) {
                    removeWaiter(q);
                    return state;
                }
                //有限时间挂起线程
                LockSupport.parkNanos(this, nanos);
            }
            else
                //无限时间挂起线程
                LockSupport.park(this);
        }
    }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　FutureTask是运用了高并发设计思想的Future设计模式。它很好的处理了高并发下处理多件获取或创建数据并无相关联的操作耗时长的问题。设计者可以将耗时比较长的操作（比如远程调用接口等）使用异步的方式（即创建一个新的线程）去处理，那么主线程就可以做其他的事情了，这样可以大大减少整体的处理时间。这个模式适用于多个无关联的时间，如果A操作的进行需要B操作的结果才可以开始，那么A其实是一直带阻塞等待B的结果的，这个串行执行的耗时差不多，使用future模式意义不大。&lt;/p&gt;
&lt;p&gt;　　FutureTask的get方法在用户逻辑代码未返回结果时仍然后进入阻塞，但是用户业务代码的执行并不受主线程（创建FutureTask的线程）的影响。我们可以通过重写done方法来获取到完成动作，这样我们再调用get方法时就不会阻塞。&lt;/p&gt;
&lt;p&gt;　　在现实生活中就有很多类似Future模式的例子。比如你的生日快到了，你需要去蛋糕店订蛋糕，同时还需要买其他的礼品，开party所需的东西等，假设蛋糕店制作蛋糕需要花费1个小时，购买其他物品需要2小时。用传统的串行的方式就是你去蛋糕店跟老板说你要订蛋糕，老板根据你的需求开始制作蛋糕，你就在店里坐着等制作完成。1个小时后终于制作好蛋糕了，然后你才能拿着蛋糕去买其他东西，买完其他东西有需要耗费2小时，最后你总共花费了3小时。当使用Future模式时，你事先写好你需要订多大的，什么口味的蛋糕，然后去到蛋糕跟老板说你先去买其他东西，一会再过来拿。但是你忘记留联系方式给蛋糕店老板了（没有重写done方法），所以你并不知道蛋糕什么时候做好，提前过去拿，那你还得在店里等蛋糕做好。如果重写了done方法，相当于给店老板留了电话号码，等蛋糕做好老板就会打电话给你，你过拿蛋糕时就不会说太早过去要等一会或太晚过去了。我们用最坏的情况来计算，你买其他东西花了两个小时，制作蛋糕花了1个小时。由于制作蛋糕和你没其他东西是分开同时进行的，所以最终你只花了2个小时，比串行的方式快了1个小时。&lt;/p&gt;
&lt;p&gt;　　以上就是我在看FutureTask源码过程中的总结，如有错漏欢迎提出。&lt;/p&gt;
</description>
<pubDate>Thu, 10 Sep 2020 15:59:00 +0000</pubDate>
<dc:creator>rainple</dc:creator>
<og:description>FutureTask是一个具体的实现类，实现了RunnableFuture接口，RunnableFuture分别继承了Runnable和Future接口，因此FutureTask类既可以被线程执行，又</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rainple/p/13609069.html</dc:identifier>
</item>
<item>
<title>Kubernetes-16：一文详解ServiceAccount及RBAC权限控制 - Running的菜鸟</title>
<link>http://www.cnblogs.com/v-fan/p/13648977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/v-fan/p/13648977.html</guid>
<description>&lt;h2 id=&quot;一-serviceaccount&quot; data-source-line=&quot;1&quot;&gt;一、ServiceAccount&lt;/h2&gt;
&lt;h3 id=&quot;1serviceaccount-介绍&quot; data-source-line=&quot;3&quot;&gt;1.ServiceAccount 介绍&lt;/h3&gt;
&lt;p data-source-line=&quot;5&quot;&gt;首先Kubernetes中账户区分为：User Accounts（用户账户） 和 Service Accounts（服务账户） 两种，它们的设计及用途如下：&lt;/p&gt;
&lt;ul data-source-line=&quot;7&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;UserAccount是给kubernetes集群外部用户使用的，例如运维或者集群管理人员，使用kubectl命令时用的就是UserAccount账户；UserAccount是全局性。在集群所有namespaces中，名称具有唯一性，默认情况下用户为admin；&lt;/p&gt;
&lt;p&gt;用户名称可以在kubeconfig中查看&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@Centos8 ~]# cd ~/.kube/&lt;span&gt;
[root@Centos8 .kube]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
cache  config  http&lt;/span&gt;-&lt;span&gt;cache
[root@Centos8 .kube]# &lt;/span&gt;&lt;span&gt;cat&lt;/span&gt;&lt;span&gt; config
    users:
    &lt;/span&gt;- name: kubernetes-admin
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul data-source-line=&quot;22&quot;&gt;&lt;li&gt;ServiceAccount是给运行在Pod的程序使用的身份认证，Pod容器的进程需要访问API Server时用的就是ServiceAccount账户；ServiceAccount仅局限它所在的namespace，每个namespace都会自动创建一个default service account；创建Pod时，如果没有指定Service Account，Pod则会使用default Service Account。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-source-line=&quot;26&quot;&gt; &lt;/h3&gt;
&lt;h3 id=&quot;2secret-与-sa-的关系&quot; data-source-line=&quot;26&quot;&gt;2.Secret 与 SA 的关系&lt;/h3&gt;
&lt;p data-source-line=&quot;28&quot;&gt;Kubernetes设计了一种Secret资源，分为两类，一种是用于 ServiceAccount 的 &lt;a href=&quot;http://kubernetes.io/&quot; target=&quot;_blank&quot;&gt;kubernetes.io/&lt;/a&gt; service-account-token，就是上边说的 SA，另一种就是用户自定义的保密信息Opaque。&lt;/p&gt;
&lt;h3 data-source-line=&quot;32&quot;&gt; &lt;/h3&gt;
&lt;h3 id=&quot;3默认的service-account&quot; data-source-line=&quot;32&quot;&gt;3.默认的Service Account&lt;/h3&gt;
&lt;p data-source-line=&quot;34&quot;&gt;ServiceAccount仅局限它所在的namespace，所以在创建namespace时会自动创建一个默认的 SA，而 SA 创建时，也会创建对应的 Secret，下面操作验证下：&lt;/p&gt;
&lt;p data-source-line=&quot;36&quot;&gt;创建名称空间&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@Centos8 .kube]# kubectl create ns vfan
namespace&lt;/span&gt;/vfan created
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;43&quot;&gt;查看SA&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@Centos8 .kube]# kubectl get sa -&lt;span&gt;n vfan
NAME      SECRETS   AGE
default   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;         67s
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;51&quot;&gt;查看 SA 的 Secret&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Centos8 .kube]# kubectl describe sa default -&lt;span&gt;n vfan
Name:                default
Namespace:           vfan
Labels:              &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Annotations:         &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Image pull secrets:  &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Mountable secrets:   default&lt;/span&gt;-token-&lt;span&gt;wwbc8
Tokens:              default&lt;/span&gt;-token-&lt;span&gt;wwbc8
Events:              &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;

[root@Centos8 &lt;/span&gt;~]# kubectl get secret -&lt;span&gt;n vfan
NAME                  TYPE                                  DATA   AGE
default&lt;/span&gt;-token-wwbc8   kubernetes.io/service-account-token   &lt;span&gt;3&lt;/span&gt;      3m15s
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;69&quot; readability=&quot;3.5206611570248&quot;&gt;
&lt;p&gt;可以看到，创建ns时默认创建了SA，SA默认创建了一个 &lt;a href=&quot;http://kubernetes.io/service-account-token%E7%B1%BB%E5%9E%8B%E7%9A%84secret&quot; target=&quot;_blank&quot;&gt;kubernetes.io/service-account-token类型的secret&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;73&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;73&quot;&gt;创建一个Pod&lt;/p&gt;
&lt;p data-source-line=&quot;75&quot;&gt;vim pods.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  name: test&lt;/span&gt;-&lt;span&gt;sa
  namespace: vfan
spec:
  containers:
  &lt;/span&gt;- name: test-&lt;span&gt;sa
    image: nginx:&lt;/span&gt;&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    imagePullPolicy: IfNotPresent
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Centos8 rbac]# kubectl create -&lt;span&gt;f pods.yaml 
pod&lt;/span&gt;/test-&lt;span&gt;sa created

[root@Centos8 rbac]# kubectl get pod &lt;/span&gt;-&lt;span&gt;n vfan
NAME      READY   STATUS    RESTARTS   AGE
test&lt;/span&gt;-sa   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          12s

[root@Centos8 rbac]# kubectl describe pod test&lt;/span&gt;-sa -&lt;span&gt;n vfan
...
Containers:
  test&lt;/span&gt;-&lt;span&gt;sa:
    Mounts:
      &lt;/span&gt;/var/run/secrets/kubernetes.io/serviceaccount from default-token-&lt;span&gt;wwbc8 (ro)
Volumes:
  default&lt;/span&gt;-token-&lt;span&gt;wwbc8:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default&lt;/span&gt;-token-&lt;span&gt;wwbc8
    Optional:    &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;114&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;在不指定SA的情况下，当前 ns下面的 Pod 会默认使用 “default” 这个 SA，对应的 Secret 会自动挂载到 Pod 的 /var/run/secrets/kubernetes.io/serviceaccount/ 目录中，我们可以在 Pod 里面获取到用于身份认证的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;116&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;116&quot;&gt;进入Pod Container内，查看 SA&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Centos8 rbac]# kubectl exec -it test-sa -n vfan -- /bin/&lt;span&gt;bash
root@test&lt;/span&gt;-sa:/# cd /var/run/secrets/kubernetes.io/serviceaccount/&lt;span&gt;
root@test&lt;/span&gt;-sa:/var/run/secrets/kubernetes.io/serviceaccount# &lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
ca.crt    namespace  token

### 可以看到有三个文件，作用分别为
    ca.crt：根证书，用于Client端验证API Server发送的证书
    namespace：标识这个service&lt;/span&gt;-account-&lt;span&gt;token的作用域空间
    token：使用API Server私钥签名的JWT，用于访问API Server时，Server端的验证&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;4使用自定义sa&quot; data-source-line=&quot;132&quot;&gt;4.使用自定义SA&lt;/h3&gt;
&lt;p data-source-line=&quot;134&quot;&gt;创建一个 SA&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Centos8 rbac]# kubectl create sa vfansa -&lt;span&gt;n vfan
serviceaccount&lt;/span&gt;/&lt;span&gt;vfansa created

[root@Centos8 rbac]# kubectl get sa &lt;/span&gt;-&lt;span&gt;n vfan
NAME      SECRETS   AGE
default   &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;         19m
vfansa    &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;         7s

[root@Centos8 rbac]# kubectl describe sa vfansa &lt;/span&gt;-&lt;span&gt;n vfan
Name:                vfansa
Namespace:           vfan
Labels:              &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Annotations:         &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Image pull secrets:  &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;
Mountable secrets:   vfansa&lt;/span&gt;-token-&lt;span&gt;9s8f7
Tokens:              vfansa&lt;/span&gt;-token-&lt;span&gt;9s8f7
Events:              &lt;/span&gt;&amp;lt;none&amp;gt;&lt;span&gt;

[root@Centos8 rbac]# kubectl get secret &lt;/span&gt;-&lt;span&gt;n vfan
NAME                  TYPE                                  DATA   AGE
default&lt;/span&gt;-token-wwbc8   kubernetes.io/service-account-token   &lt;span&gt;3&lt;/span&gt;&lt;span&gt;      19m
vfansa&lt;/span&gt;-token-9s8f7    kubernetes.io/service-account-token   &lt;span&gt;3&lt;/span&gt;      49s
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;161&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;同样，创建SA后，自动创建了对应的Secret&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;165&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;165&quot;&gt;更新Pod，使用新创建的SA&lt;/p&gt;
&lt;p data-source-line=&quot;167&quot;&gt;vim pods.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: Pod
metadata:
  name: test&lt;/span&gt;-&lt;span&gt;sa
  namespace: vfan
spec:
  containers:
  &lt;/span&gt;- name: test-&lt;span&gt;sa
    image: nginx:&lt;/span&gt;&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    imagePullPolicy: IfNotPresent
    ports:
    &lt;/span&gt;- containerPort: &lt;span&gt;80&lt;/span&gt;&lt;span&gt;
  serviceAccountName: vfansa&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Centos8 rbac]# kubectl create -&lt;span&gt;f pods.yaml 
pod&lt;/span&gt;/test-&lt;span&gt;sa created

[root@Centos8 rbac]# kubectl describe pod test&lt;/span&gt;-sa -&lt;span&gt;n vfan
...
    Mounts:
      &lt;/span&gt;/var/run/secrets/kubernetes.io/serviceaccount from vfansa-token-&lt;span&gt;9s8f7 (ro)
Volumes:
  vfansa&lt;/span&gt;-token-&lt;span&gt;9s8f7:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  vfansa&lt;/span&gt;-token-&lt;span&gt;9s8f7
    Optional:    &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;5serviceaccount中添加image-pull-secrets&quot; data-source-line=&quot;203&quot;&gt;5.ServiceAccount中添加Image pull secrets&lt;/h3&gt;
&lt;p data-source-line=&quot;205&quot;&gt;在笔者之前的博客中：Secret介绍及演示( &lt;a href=&quot;https://www.cnblogs.com/v-fan/p/13269433.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/v-fan/p/13269433.html&lt;/a&gt; )中提及到，可以使用Secret来保存镜像仓库的登录信息，来达到免登录获取image的效果，同样，可以将创建好的Secret直接与SA进行绑定，绑定完成后，只要使用此 SA 的 Pod，都可达到免登录获取image的效果&lt;/p&gt;
&lt;p data-source-line=&quot;209&quot;&gt;创建 docker-registry 的 Secret&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@Centos8 rbac]# kubectl create secret docker-registry myregistrykey --docker-server=hub.vfancloud.com --docker-username=admin --docker-password=admin@&lt;span&gt;123&lt;/span&gt; --docker-email=vfan8991@&lt;span&gt;163&lt;/span&gt;.com -&lt;span&gt;n vfan
secret&lt;/span&gt;/&lt;span&gt;myregistrykey created

[root@Centos8 rbac]# kubectl get secret &lt;/span&gt;-&lt;span&gt;n vfan
NAME                  TYPE                                  DATA   AGE
default&lt;/span&gt;-token-wwbc8   kubernetes.io/service-account-token   &lt;span&gt;3&lt;/span&gt;&lt;span&gt;      62m
myregistrykey         kubernetes.io&lt;/span&gt;/dockerconfigjson        &lt;span&gt;1&lt;/span&gt;&lt;span&gt;      7s
vfansa&lt;/span&gt;-token-9s8f7    kubernetes.io/service-account-token   &lt;span&gt;3&lt;/span&gt;      43m
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;224&quot;&gt;将 docker-registry 的 Secret 添加到SA&lt;/p&gt;
&lt;p data-source-line=&quot;226&quot;&gt;kubectl edit sa vfansa -n vfan&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2020-08-30T03:38:47Z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  name: vfansa
  namespace: vfan
  resourceVersion: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;471829&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
  selfLink: &lt;/span&gt;/api/v1/namespaces/vfan/serviceaccounts/&lt;span&gt;vfansa
  uid: 8a44df93&lt;/span&gt;-b2d6-4e61-ad2e-&lt;span&gt;25bc5852f66e
secrets:
&lt;/span&gt;- name: vfansa-token-&lt;span&gt;9s8f7
imagePullSecrets:
&lt;/span&gt;- name: myregistrykey
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-source-line=&quot;246&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;246&quot;&gt;查看 SA 的 Image pull secrets&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@Centos8 rbac]# kubectl describe sa vfansa -&lt;span&gt;n vfan 
Name:                vfansa
Namespace:           vfan
Labels:              &amp;lt;none&amp;gt;&lt;span&gt;
Annotations:         &amp;lt;none&amp;gt;&lt;span&gt;
Image pull secrets:  myregistrykey
Mountable secrets:   vfansa-token-&lt;span&gt;9s8f7
Tokens:              vfansa-token-&lt;span&gt;9s8f7
Events:              &amp;lt;none&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;260&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;这个时候，只要是使用此 SA 的Pod，都可以在docker-registry拉取镜像了，同样，可以把此 Secret 添加到default 的 SA 中，达到相同的效果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;二-rbac&quot; data-source-line=&quot;264&quot;&gt;二、RBAC权限控制&lt;/h2&gt;
&lt;h3 id=&quot;1rbac介绍&quot; data-source-line=&quot;266&quot;&gt;1.RBAC介绍&lt;/h3&gt;
&lt;p data-source-line=&quot;268&quot;&gt;在Kubernetes中，所有资源对象都是通过API对象进行操作，他们保存在etcd里。而对etcd的操作我们需要通过访问 kube-apiserver 来实现，上面的Service Account其实就是APIServer的认证过程，而授权的机制是通过RBAC：基于角色的访问控制实现。&lt;/p&gt;
&lt;h2 data-source-line=&quot;272&quot;&gt; &lt;/h2&gt;
&lt;h3 id=&quot;2role-and-clusterrole&quot; data-source-line=&quot;272&quot;&gt;2.Role and ClusterRole&lt;/h3&gt;
&lt;p data-source-line=&quot;274&quot;&gt;在RBAC API中，Role表示一组规则权限，权限只会增加(累加权限)，不存在一个资源开始就有很多权限而通过RBAC对其进行减少的操作：Role 是定义在一个 namespace 中，而 ClusterRole 是集群级别的。&lt;/p&gt;
&lt;p data-source-line=&quot;276&quot;&gt;下面我们定义一个Role：&lt;/p&gt;
&lt;p data-source-line=&quot;278&quot;&gt;vim roles.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
apiVersion: rbac.authorization.k8s.io/&lt;span&gt;v1
kind: Role
metadata:
  name: test&lt;/span&gt;-&lt;span&gt;role
  namespace: vfan
rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]  # 为空表示为默认的core api group
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pods&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;] # 数据源类型
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]    #赋予的权限
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;apps&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;deployments&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;update&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;patch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;watch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;295&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;以上Role策略表示在名字为 vfan ns中，对Pods有get,watch,list的权限，对Deployment有......权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;299&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;299&quot;&gt;ClusterRole 具有与 Role 相同权限角色控制能力，不同的就是 Cluster Role是集群级别，它可以用于：&lt;/p&gt;
&lt;ul data-source-line=&quot;301&quot;&gt;&lt;li&gt;集群级别的资源控制（例如 node 访问权限）&lt;/li&gt;
&lt;li&gt;非资源型 endpoints（例如对某个目录或文件的访问：/healthz）&lt;/li&gt;
&lt;li&gt;所有命名空间资源控制（Pod、Deployment等）&lt;/li&gt;
&lt;/ul&gt;&lt;p data-source-line=&quot;305&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;305&quot;&gt;vim clusterroles.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
apiVersion: rbac.authorization.k8s.io/&lt;span&gt;v1
kind: ClusterRole
metadata:
  name: test&lt;/span&gt;-&lt;span&gt;clusterrole
rules:
&lt;/span&gt;- apiGroups: [&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;]
  resources: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;services&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]
  verbs: [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;318&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;以上Cluster role策略表示，有get，create，list整个集群service的权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;322&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;322&quot;&gt;下面开始创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## role
[root@Centos8 rbac]# kubectl create &lt;/span&gt;-&lt;span&gt;f roles.yaml 
role.rbac.authorization.k8s.io&lt;/span&gt;/test-&lt;span&gt;rbac created

[root@Centos8 rbac]# kubectl get role &lt;/span&gt;-&lt;span&gt;n vfan 
NAME        AGE
test&lt;/span&gt;-&lt;span&gt;rbac   27s

## cluster role
[root@Centos8 rbac]# kubectl get clusterrole &lt;/span&gt;-&lt;span&gt;n vfan
NAME                                                                   AGE
admin                                                                  141d
cluster&lt;/span&gt;-&lt;span&gt;admin                                                          141d
edit                                                                   141d
flannel                                                                141d
ingress&lt;/span&gt;-&lt;span&gt;nginx                                                          90d
ingress&lt;/span&gt;-nginx-&lt;span&gt;admission                                                90d
system:aggregate&lt;/span&gt;-to-&lt;span&gt;admin                                              141d
system:aggregate&lt;/span&gt;-to-&lt;span&gt;edit                                               141d
system:aggregate&lt;/span&gt;-to-view                                               141d
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;347&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;可以看到，role和cluster role都已经创建成功，但是clusterrole除了这次创建的还有许多，其中以system开头的全部是系统所用的，其他的都是在装一些插件时自动添加的，也要注意，我们自己创建cluster role时不要以system开通，以免分不清楚&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 data-source-line=&quot;351&quot;&gt; &lt;/h3&gt;
&lt;h3 id=&quot;3rolebinding-and-clusterrolebinding&quot; data-source-line=&quot;351&quot;&gt;3.RoleBinding and ClusterRoleBinding&lt;/h3&gt;
&lt;p data-source-line=&quot;353&quot;&gt;RoleBinding可以将角色中定义的权限授予用户或用户组，RoleBinding包含一组权限列表(Subjects)，权限列表中包含有不同形式的待授予权限资源类型(users,groups, or Service Account)：Rolebinding 同样包含对被 Bind 的 Role 引用；RoleBinding 适用于某个命名空间内授权，ClusterRoleBinding适用于集群范围内的授权。&lt;/p&gt;
&lt;p data-source-line=&quot;355&quot;&gt;创建RoleBinding&lt;/p&gt;
&lt;p data-source-line=&quot;357&quot;&gt;vim rolebindings.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
apiVersion: rbac.authorization.k8s.io/&lt;span&gt;v1
kind: RoleBinding
metadata:
  name: test&lt;/span&gt;-&lt;span&gt;rolebinding
  namespace: vfan
subjects:
&lt;/span&gt;-&lt;span&gt; kind: User    # 权限资源类型
  name: vfan    # 名称
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role    #要绑定的Role的类型(可以是Role或ClusterRole)
  name: test&lt;/span&gt;-&lt;span&gt;role    # Role的名称
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;375&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;此策略表示，将名称为test-role的Role的权限资源赋予名为vfan的用户，仅作用于vfan namespace。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;379&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;379&quot;&gt;RoleBinding同样可以引用ClusterRole来对当前 namespace 内用户、用户组或SA来进行授权，这种操作允许管理员在整个集群中定义一些通用的ClusterRole，然后在不同的namespace中使用RoleBinding绑定。&lt;/p&gt;
&lt;p data-source-line=&quot;381&quot;&gt;vim rolebindings2.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
apiVersion: rbac.authorization.k8s.io/&lt;span&gt;v1
kind: RoleBinding
metadata:
  name: test&lt;/span&gt;-&lt;span&gt;rolebinding2
  namespace: vfan
subjects:
&lt;/span&gt;-&lt;span&gt; kind: User
  name: vfan
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: test&lt;/span&gt;-&lt;span&gt;clusterrole
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;399&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;以上策略表示，将名称为test-clusterrole的ClusterRole的资源权限赋予给了名称为vfan的用户，虽然赋予的是ClusterRole，但是由于Role仅作用于单个namespace，所以此资源策略仅仅对vfan namespace有效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;403&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;403&quot;&gt;vim clusterrolebindings.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
apiVersion: rbac.authorization.k8s.io/&lt;span&gt;v1
kind: ClusterRoleBinding
metadata:
  name: test&lt;/span&gt;-&lt;span&gt;clusterrolebinding
subjects:
&lt;/span&gt;-&lt;span&gt; kind: Group
  name: vfan
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: ClusterRole
  name: test&lt;/span&gt;-&lt;span&gt;clusterrole
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;420&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;以上策略表示，将name为test-clusterrole的ClusterRole的资源权限赋予给groupname为vfan的用户组，此用户组下所有用户拥有对整个集群的 test-clusterrole内的资源权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 data-source-line=&quot;424&quot;&gt; &lt;/h2&gt;
&lt;h2 id=&quot;实践创建一个用户只能管理名为-vfan-的namespace&quot; data-source-line=&quot;424&quot;&gt;实践：创建一个用户只能管理名为 vfan 的NameSpace&lt;/h2&gt;
&lt;h3 id=&quot;1创建系统用户&quot; data-source-line=&quot;426&quot;&gt;1.创建系统用户&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@Centos8 rbac]# useradd vfan
[root@Centos8 rbac]# &lt;/span&gt;&lt;span&gt;su&lt;/span&gt; -&lt;span&gt; vfan 

## 进入vfan用户测试访问k8s集群
[vfan@Centos8 &lt;/span&gt;~&lt;span&gt;]$ kubectl get pod 
The connection to the server localhost:&lt;/span&gt;&lt;span&gt;8080&lt;/span&gt; was refused - did you specify the right host or port?
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;437&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;默认肯定是访问不到的，如果想要访问，必须要创建vfan用户的访问证书&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 data-source-line=&quot;442&quot;&gt; &lt;/h4&gt;
&lt;h3 id=&quot;2为-vfan-用户创建访问证书&quot; data-source-line=&quot;442&quot;&gt;2.为 vfan 用户创建访问证书&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## 下载证书生成工具 cfssl
[root@Centos8 bin]# &lt;/span&gt;&lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pkg.cfssl.org/R1.2/cfssl_linux-amd64&lt;/span&gt;
[root@Centos8 bin]# &lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pkg.cfssl.org/R1.2/cfssljson_linux-amd64&lt;/span&gt;
[root@Centos8 bin]# &lt;span&gt;wget&lt;/span&gt; https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64&lt;/span&gt;
&lt;span&gt;
## 改名，给执行权限
[root@Centos8 bin]# &lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; cfssl_linux-&lt;span&gt;amd64 cfssl
[root@Centos8 bin]# &lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; cfssljson_linux-&lt;span&gt;amd64 cfssljson
[root@Centos8 bin]# &lt;/span&gt;&lt;span&gt;mv&lt;/span&gt; cfssl-certinfo_linux-amd64 cfssl-&lt;span&gt;certinfo
[root@Centos8 bin]# &lt;/span&gt;&lt;span&gt;chmod&lt;/span&gt; +x *&lt;span&gt;
[root@Centos8 bin]# ll &lt;/span&gt;-&lt;span&gt;h 
总用量 19M
&lt;/span&gt;-rwxr-xr-x &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;9.9M&lt;/span&gt; 3月  &lt;span&gt;30&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; cfssl
&lt;/span&gt;-rwxr-xr-x &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;6.3M&lt;/span&gt; 3月  &lt;span&gt;30&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt; cfssl-&lt;span&gt;certinfo
&lt;/span&gt;-rwxr-xr-x &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;2.2M&lt;/span&gt; 3月  &lt;span&gt;30&lt;/span&gt; &lt;span&gt;2016&lt;/span&gt;&lt;span&gt; cfssljson
[root@Centos8 bin]# &lt;/span&gt;&lt;span&gt;mkdir&lt;/span&gt; /usr/local/&lt;span&gt;vfancert
[root@Centos8 bin]# cd &lt;/span&gt;/usr/local/vfancert/
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;467&quot;&gt;创建CA证书签名请求JSON文件&lt;/p&gt;
&lt;p data-source-line=&quot;469&quot;&gt;vim vfan-csr.json&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vfan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,        # 用户名称
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hosts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [],        # 主机地址，不填表示所有主机都可使用
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;algo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;rsa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,    # 加密算法
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;size&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;2048&lt;/span&gt;&lt;span&gt;
},
  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;names&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
    {
       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BeiJing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;O&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ctyun&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ST&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BeiJing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,            
       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
  ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;491&quot;&gt;开始创建访问证书&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[root@Centos8 vfancert]# cd /etc/kubernetes/pki/&lt;span&gt;
[root@Centos8 pki]# cfssl gencert &lt;/span&gt;-ca=ca.crt -ca-key=ca.key -profile=kubernetes /usr/local/vfancert/vfan-csr.json | cfssljson -&lt;span&gt;bare vfanuser
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;/&lt;span&gt;09&lt;/span&gt;/&lt;span&gt;02&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;&lt;span&gt; [INFO] generate received request
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;/&lt;span&gt;09&lt;/span&gt;/&lt;span&gt;02&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;&lt;span&gt; [INFO] received CSR
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;/&lt;span&gt;09&lt;/span&gt;/&lt;span&gt;02&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt; [INFO] generating key: rsa-&lt;span&gt;2048&lt;/span&gt;
&lt;span&gt;2020&lt;/span&gt;/&lt;span&gt;09&lt;/span&gt;/&lt;span&gt;02&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt;&lt;span&gt; [INFO] encoded CSR
&lt;/span&gt;&lt;span&gt;2020&lt;/span&gt;/&lt;span&gt;09&lt;/span&gt;/&lt;span&gt;02&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt; [INFO] signed certificate with serial number &lt;span&gt;191102646650271030964539871811792985454770130197&lt;/span&gt;
&lt;span&gt;2020&lt;/span&gt;/&lt;span&gt;09&lt;/span&gt;/&lt;span&gt;02&lt;/span&gt; &lt;span&gt;22&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;:&lt;span&gt;51&lt;/span&gt; [WARNING] This certificate lacks a &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hosts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; field. This makes it unsuitable &lt;span&gt;for&lt;/span&gt;&lt;span&gt;
websites. For &lt;/span&gt;&lt;span&gt;more&lt;/span&gt; information see the Baseline Requirements &lt;span&gt;for&lt;/span&gt;&lt;span&gt; the Issuance and Management
of Publicly&lt;/span&gt;-Trusted Certificates, v.&lt;span&gt;1.1&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt;, from the CA/Browser Forum (https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;cabforum.org);&lt;/span&gt;
specifically, section &lt;span&gt;10.2&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Information Requirements&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).

## 创建成功，pki目录下多出vfanuser&lt;/span&gt;-&lt;span&gt;key.pem、vfanuser.pem和vfanuser.csr文件
[root@Centos8 pki]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
vfanuser.csr
vfanuser&lt;/span&gt;-&lt;span&gt;key.pem
vfanuser.pem&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;3为-vfan-用户生成集群配置文件&quot; data-source-line=&quot;515&quot;&gt;3.为 vfan 用户生成集群配置文件&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## 设置api server的环境变量
[root@Centos8 vfancert]# export KUBE_APISERVER&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://192.168.152.53:6443&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

## 创建kubeconfig文件，以下详细参数信息可通过kubectl config set&lt;/span&gt;-cluster --&lt;span&gt;help查看
[root@Centos8 vfancert]# kubectl config set&lt;/span&gt;-cluster kubernetes --certificate-authority=/etc/kubernetes/pki/ca.crt --embed-certs=&lt;span&gt;true&lt;/span&gt; --server=${KUBE_APISERVER} --kubeconfig=&lt;span&gt;vfan.kubeconfig
Cluster &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; set.

## 配置文件生成
[root@Centos8 vfancert]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
vfan&lt;/span&gt;-&lt;span&gt;csr.json  vfan.kubeconfig

## 设置客户端参数，绑定用户信息至kubeconfig中
[root@Centos8 vfancert]# kubectl config set&lt;/span&gt;-&lt;span&gt;credentials vfanuser \
&lt;/span&gt;&amp;gt; --client-certificate=/etc/kubernetes/pki/&lt;span&gt;vfanuser.pem \
&lt;/span&gt;&amp;gt; --client-key=/etc/kubernetes/pki/vfanuser-&lt;span&gt;key.pem \
&lt;/span&gt;&amp;gt; --embed-certs=&lt;span&gt;true&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&amp;gt; --kubeconfig=&lt;span&gt;vfan.kubeconfig
User &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vfanuser&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; set.

## 设置上下文参数
[root@Centos8 vfancert]# kubectl config set&lt;/span&gt;-&lt;span&gt;context kubernetes \
&lt;/span&gt;&amp;gt; --cluster=&lt;span&gt;kubernetes \
&lt;/span&gt;&amp;gt; --user=&lt;span&gt;vfan \
&lt;/span&gt;&amp;gt; --namespace=&lt;span&gt;vfan \
&lt;/span&gt;&amp;gt; --kubeconfig=&lt;span&gt;vfan.kubeconfig
Context &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kubenetes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; created.
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;4进行rolebinding-验证权限生效&quot; data-source-line=&quot;548&quot;&gt;4.进行RoleBinding 验证权限生效&lt;/h3&gt;
&lt;p data-source-line=&quot;550&quot;&gt;vim vfanrolebind.yaml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
apiVersion: rbac.authorization.k8s.io/&lt;span&gt;v1
kind: RoleBinding
metadata:
  name: test&lt;/span&gt;-&lt;span&gt;rolebinding
  namespace: vfan
subjects:
&lt;/span&gt;-&lt;span&gt; kind: User
  name: vfan
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: test&lt;/span&gt;-rbac    # 绑定上文中创建的名称为 test-&lt;span&gt;rbac 的Role，具体权限，往上翻下哈
  apiGroup: rbac.authorization.k8s.io&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;570&quot;&gt;把kubeconfig文件复制到 vfan 用户的家目录的.kube下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@Centos8 vfancert]# &lt;span&gt;mkdir&lt;/span&gt; -p /home/vfan/&lt;span&gt;.kube
[root@Centos8 vfancert]# &lt;/span&gt;&lt;span&gt;cp&lt;/span&gt; vfan.kubeconfig /home/vfan/.kube/&lt;span&gt;config
[root@Centos8 vfancert]# cd &lt;/span&gt;/home/vfan/.kube/&lt;span&gt;
[root@Centos8 .kube]# &lt;/span&gt;&lt;span&gt;ls&lt;/span&gt;&lt;span&gt;
config

## 修改文件所有者
[root@Centos8 vfan]# &lt;/span&gt;&lt;span&gt;chown&lt;/span&gt; -R vfan:vfan .kube/
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;585&quot;&gt;切换上下文，使kubectl读取到config的信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[vfan@Centos8 .kube]$ kubectl config use-context kubernetes --kubeconfig=&lt;span&gt;config 
Switched to context &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;

&lt;p data-source-line=&quot;594&quot;&gt;开始测试权限&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[vfan@Centos8 .kube]$ kubectl get pod 
No resources found.

[vfan@Centos8 .kube]$ kubectl get svc 
Error from server (Forbidden): services is forbidden: User &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vfan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; cannot list resource &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;services&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; API group &lt;span&gt;&quot;&quot;&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; the namespace &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vfan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;604&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;可以get pod，但是不可以get service，因为之前的Role中明确的表示了自己的权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-source-line=&quot;608&quot;&gt; &lt;/p&gt;
&lt;p data-source-line=&quot;608&quot;&gt;在vfan名称空间下创建测试Deployment&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;## root用户下创建
[root@Centos8 k8sYaml]# kubectl run deployment test&lt;/span&gt;-vfan --replicas=&lt;span&gt;3&lt;/span&gt; --image=nginx:&lt;span&gt;1.2&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt; --namespace=&lt;span&gt;vfan

[root@Centos8 k8sYaml]# kubectl get pod &lt;/span&gt;-&lt;span&gt;n vfan 
NAME                         READY   STATUS    RESTARTS   AGE
deployment&lt;/span&gt;-7b89b946d-5dtvp   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          17s
deployment&lt;/span&gt;-7b89b946d-jpr5v   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          17s
deployment&lt;/span&gt;-7b89b946d-r8k4l   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          17s

## 前往vfan用户查看
[vfan@Centos8 .kube]$ kubectl get pod 
NAME                         READY   STATUS    RESTARTS   AGE
deployment&lt;/span&gt;-7b89b946d-5dtvp   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          67s
deployment&lt;/span&gt;-7b89b946d-jpr5v   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;&lt;span&gt;          67s
deployment&lt;/span&gt;-7b89b946d-r8k4l   &lt;span&gt;1&lt;/span&gt;/&lt;span&gt;1&lt;/span&gt;     Running   &lt;span&gt;0&lt;/span&gt;          67s
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote data-source-line=&quot;628&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;可以看到，vfan用户也可以查看到相对应的Pod，因为vfan用户在get pod时并没有指定名称空间，所以可以证明vfan的默认名称空间即是vfan&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 10 Sep 2020 15:22:00 +0000</pubDate>
<dc:creator>Running的菜鸟</dc:creator>
<og:description>一、ServiceAccount 1.ServiceAccount 介绍 首先Kubernetes中账户区分为：User Accounts（用户账户） 和 Service Accounts（服务账户）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/v-fan/p/13648977.html</dc:identifier>
</item>
<item>
<title>来讲讲你对ThreadLocal的理解 - 纪莫</title>
<link>http://www.cnblogs.com/jimoer/p/13649008.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jimoer/p/13649008.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;面试的时候被问到ThreadLocal的相关知识，没有回答好（奶奶的，现在感觉问啥都能被问倒），所以我决定先解决这几次面试中都遇到的高频问题，把这几个硬骨头都能理解的透彻的说出来了，感觉最起码不能总是一轮游。&lt;/p&gt;
&lt;h3 id=&quot;threadlocal介绍&quot;&gt;ThreadLocal介绍&lt;/h3&gt;
&lt;p&gt;ThreadLocal是JDK1.2开始就提供的一个用来存储线程本地变量的类。ThreadLocal中的变量是在每个线程中独立存在的，当多个线程访问ThreadLocal中的变量的时候，其实都是访问的自己当前线程的内存中的变量，从而保证的变量的线程安全。&lt;/p&gt;
&lt;p&gt;我们一般在使用ThreadLocal的时候都是为了解决线程中存在的变量竞争问题。其实解决这类问题，通常大家也会想到使用synchronized来加锁解决。&lt;/p&gt;
&lt;p&gt;例如在解决SimpleDateFormat的线程安全的时候。SimpleDateFormat是非线程安全的，它里面无论的是format()方法还是parse()方法，都有使用它自己内部的一个Calendar类的对象，format方法是设置时间，parse()方法里面是先调用Calendar的clear()方法，然后又调用了Calendar的set()方法（赋值），如果一个线程刚调用了set()进行赋值，这个时候又来了一个线程直接调用了clear()方法，那么这个parse()方法执行的结果就会有问题的。&lt;br/&gt;&lt;strong&gt;解决办法一&lt;/strong&gt;&lt;br/&gt;将使用SimpleDateformat的方法加上synchronized，这样虽然保证了线程安全，但却降低了效率，同一时间只有一个线程能使用格式化时间的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);

public static synchronized String formatDate(Date date){
    return simpleDateFormat.format(date);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决办法二&lt;/strong&gt;&lt;br/&gt;将SimpleDateFormat的对象，放到ThreadLocal里面，这样每个线程中都有一个自己的格式对象的副本了。互不干扰，从而保证了线程安全。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static final ThreadLocal&amp;lt;SimpleDateFormat&amp;gt; simpleDateFormatThreadLocal = ThreadLocal.withInitial(() -&amp;gt; new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;));

public static String formatDate(Date date){
   return simpleDateFormatThreadLocal.get().format(date);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;threadlocal的原理&quot;&gt;ThreadLocal的原理&lt;/h3&gt;
&lt;p&gt;我们先看一下ThreadLocal是怎么使用的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ThreadLocal&amp;lt;Integer&amp;gt; threadLocal99 = new ThreadLocal&amp;lt;Integer&amp;gt;();
threadLocal99.set(3);
int num = threadLocal99.get();
System.out.println(&quot;数字:&quot;+num);
threadLocal99.remove();
System.out.println(&quot;数字Empty:&quot;+threadLocal99.get());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;数字:3
数字Empty:null
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用起来很简单，主要是将变量放到ThreadLocal里面，在线程执行过程中就可以取到，当执行完成后在remove掉就可以了，只要没有调用remove()当前线程在执行过程中都是可以拿到变量数据的。&lt;br/&gt;因为是放到了当前执行的线程中，所以ThreadLocal中的变量值只能当前线程来使用，从而保证的了线程安全（&lt;mark&gt;当前线程的子线程其实也是可以获取到的&lt;/mark&gt;）。&lt;/p&gt;
&lt;p&gt;来看一下ThreadLocal的set()方法源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void set(T value) {
   // 获取当前线程
   Thread t = Thread.currentThread();
   // 获取ThreadLocalMap
   ThreadLocal.ThreadLocalMap map = getMap(t);
   // ThreadLocalMap 对象是否为空，不为空则直接将数据放入到ThreadLocalMap中
   if (map != null)
       map.set(this, value);
   else
       createMap(t, value); // ThreadLocalMap对象为空，则先创建对象，再赋值。
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到变量都是存放在了ThreadLocalMap这个变量中的。那么ThreadLocalMap又是怎么来的呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Thread implements Runnable {
        ... ...
        /* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */
    ThreadLocal.ThreadLocalMap threadLocals = null;
    ... ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的源码，我们发现ThreadLocalMap变量是当前执行线程中的一个变量，所以说，ThreadLocal中存放的数据其实都是放到了当前执行线程中的一个变量里面了。也就是存储在了当前的线程对象里了，别的线程里面是另一个线程对象了，拿不到其他线程对象中的数据，所以数据自然就隔离开了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么ThreadLocalMap是怎么存储数据的呢？&lt;/strong&gt;&lt;br/&gt;ThreadLocalMap 是ThreadLocal类里的一个内部类，虽然类的名字上带着Map但却没有实现Map接口，只是结构和Map类似而已。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200909231451433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;ThreadLocalMap内部其实是一个Entry数组，Entry是ThreadLocalMap中的一个内部类，继承自WeakReference，并将ThreadLocal类型的对象设置为了Entry的Key，以及对Key设置成弱引用。&lt;br/&gt;ThreadLocalMap的内部数据结构，就大概是这样的key,value组成的Entry的数组集合。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020090923454535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;和真正的Map还是有区别的，没有链表了，这样在解决key的hash冲突的时候措施肯定就和HashMap不一样了。&lt;br/&gt;一个线程中是可以创建多个ThreadLocal对象的，多个ThreadLocal对象就会存放多个数据，那么在ThreadLocalMap中就会以数组的形式存放这些数据。&lt;br/&gt;我们来看一下具体的ThreadLocalMap的set()方法的源码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Set the value associated with key.
 * @param key the thread local object
 * @param value the value to be set
 */
private void set(ThreadLocal&amp;lt;?&amp;gt; key, Object value) {

    // We don't use a fast path as with get() because it is at
    // least as common to use set() to create new entries as
    // it is to replace existing ones, in which case, a fast
    // path would fail more often than not.

    Entry[] tab = table;
    int len = tab.length;
    // 定位在数组中的位置
    int i = key.threadLocalHashCode &amp;amp; (len-1);

    for (Entry e = tab[i];
         e != null;
         e = tab[i = nextIndex(i, len)]) {
        ThreadLocal&amp;lt;?&amp;gt; k = e.get();
        // 如果当前位置不为空，并且当前位置的key和传过来的key相等，那么就会覆盖当前位置的数据
        if (k == key) {
            e.value = value;
            return;
        }
        // 如果当前位置为空，则初始化一个Entry对象，放到当前位置。
        if (k == null) {
            replaceStaleEntry(key, value, i);
            return;
        }
    }
    // 如果当前位置不为空，并且当前位置的key也不等于要赋值的key ，那么将去找下一个空位置，直接将数据放到下一个空位置处。
    tab[i] = new Entry(key, value);
    int sz = ++size;
    if (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)
        rehash();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们从set()方法中可以看到，处理逻辑有四步。&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第一步先根据Threadlocal对象的hashcode和数组长度做与运算获取数据应该放在当前数组中的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第二步就是判断当前位置是否为空，为空的话就直接初始化一个Entry对象，放到当前位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第三步如果当前位置不为空，而当前位置的Entry中的key和传过来的key一样，那么直接覆盖掉当前位置的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第四步如果当前位置不为空，并且当前位置的Entry中的key和传过来的key&lt;br/&gt;也不一样，那么就会去找下一个空位置，然后将数据存放到空位置（&lt;strong&gt;数组超过长度后，会执行扩容的&lt;/strong&gt;）；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在get的时候也是类似的逻辑，先通过传入的ThreadLocal的hashcode获取在Entry数组中的位置，然后拿当前位置的Entry的Key和传入的ThreadLocal对比，相等的话，直接把数据返回，如果不相等就去判断和数组中的下一个值的key是否相等。。。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Entry getEntry(ThreadLocal&amp;lt;?&amp;gt; key) {
    int i = key.threadLocalHashCode &amp;amp; (table.length - 1);
    Entry e = table[i];
    if (e != null &amp;amp;&amp;amp; e.get() == key)
        return e;
    else
        return getEntryAfterMiss(key, i, e);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * Version of getEntry method for use when key is not found in
 * its direct hash slot.
 *
 * @param  key the thread local object
 * @param  i the table index for key's hash code
 * @param  e the entry at table[i]
 * @return the entry associated with key, or null if no such
 */
private Entry getEntryAfterMiss(ThreadLocal&amp;lt;?&amp;gt; key, int i, Entry e) {
    Entry[] tab = table;
    int len = tab.length;

    while (e != null) {
        ThreadLocal&amp;lt;?&amp;gt; k = e.get();
        if (k == key)
            return e;
        if (k == null)
            expungeStaleEntry(i);
        else
            i = nextIndex(i, len);
        e = tab[i];
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们上文一直说，ThreadLocal是保存在单个线程中的数据，每个线程都有自己的数据，但是实际ThreadLocal里面的真正的对象数据，其实是保存在堆里面的，而线程里面只是存储了对象的引用而已。&lt;br/&gt;并且我们在使用的时候通常需要在上一个线程执行的方法的上下文共享ThreadLocal中的变量。&lt;br/&gt;例如我的主线程是在某个方法中执行代码呢，但是这个方法中有一段代码时新创建了一个线程，在这个线程里面还使用了我这个正在执行的方法里面的定义的ThreadLocal里面的变量。这个时候，就是需要从新线程里面调用外面线程的数据，这个就需要线程间共享了。这种子父线程共享数据的情况，ThreadLocal也是支持的。&lt;br/&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; ThreadLocal threadLocalMain = new InheritableThreadLocal();
 threadLocalMain.set(&quot;主线程变量&quot;);
 Thread t = new Thread() {
     @Override
     public void run() {
         super.run();
         System.out.println( &quot;现在获取的变量是 =&quot; + threadLocalMain.get());
     }
 };
 t.start();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;现在获取的变量是 =主线程变量
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这样的代码就能实现子父线程共享数据的情况，重点是使用InheritableThreadLocal来实现的共享。&lt;br/&gt;那么它是怎么实现数据共享的呢？&lt;br/&gt;在Thread类的init()方法中有这么一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (inheritThreadLocals &amp;amp;&amp;amp; parent.inheritableThreadLocals != null)
            this.inheritableThreadLocals =ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的意思是，&lt;mark&gt;在创建线程的时候，如果当前线程的inheritThreadLocals变量和父线程的inheritThreadLocals变量都不为空的时候，会将父线程的inheritThreadLocals变量中的数据，赋给当前线程中的inheritThreadLocals变量。&lt;/mark&gt;&lt;/p&gt;
&lt;h3 id=&quot;threadlocal的内存泄漏问题&quot;&gt;ThreadLocal的内存泄漏问题&lt;/h3&gt;
&lt;p&gt;上文我们也提到过，ThreadLocal中的ThreadLocalMap里面的Entry对象是继承自WeakReference类的，说明Entry的key是一个弱引用。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200910083829900.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_SmlNb2Vy,size_60,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;弱引用是用来描述那些非必须的对象，弱引用的对象，只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这个弱引用还是ThreadLocal对象本身，所以一般在线程执行完成后，ThreadLocal对象就会变成null了，而为null的弱引用对象，在下一次GC的时候就会被清除掉，这样Entry的Key的内存空间就被释放出来了，但是Entry的value还在占用的内存，如果线程是被复用的（例如&lt;mark&gt;线程池中的线程&lt;/mark&gt;），那么这里面的value值就会越来越多，最终就导致了内存泄漏。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;防止内存泄漏的办法就是在每次使用完ThreadLocal的时候都去执行以下remove()方法，就可以把key和value的空间都释放了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;mark&gt;那既然容易产生内存泄漏，为什么还要设置成弱引用的呢？&lt;/mark&gt;&lt;br/&gt;如果正常情况下应该是强引用，但是强引用只要引用关系还在就一直不会被回收，所以如果线程被复用了，那么Entry中的Key和Value都不会被回收，这样就造成了Key和Value都会发生内存泄漏了。&lt;/p&gt;
</description>
<pubDate>Thu, 10 Sep 2020 15:08:00 +0000</pubDate>
<dc:creator>纪莫</dc:creator>
<og:description>前言 面试的时候被问到ThreadLocal的相关知识，没有回答好（奶奶的，现在感觉问啥都能被问倒），所以我决定先解决这几次面试中都遇到的高频问题，把这几个硬骨头都能理解的透彻的说出来了，感觉最起码不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jimoer/p/13649008.html</dc:identifier>
</item>
</channel>
</rss>