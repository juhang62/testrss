<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>计算机网络知识① - 故屿</title>
<link>http://www.cnblogs.com/guyu-/p/13468548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guyu-/p/13468548.html</guid>
<description>
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;计算机网络知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;1. 网卡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;    就是计算机要连接到网络上的一种硬件设备&lt;br/&gt;    它分有线和无线&lt;br/&gt;    有线网卡的接口主要采用 RJ45头，俗称 水晶头。采用双胶线、同轴电缆、光纤&lt;br/&gt;    等介质进行传输。&lt;/p&gt;&lt;p&gt;    无线，主要是采用电磁波的调制来进行通信。也就是WIFI通信,它采用的是&lt;br/&gt;    802.11b 协议&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;2. IP地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;    代表网络上各个节点的一个符号，在外网上，每台计算机都有唯一的外网&lt;br/&gt;    IP地址，但是在局域网中，是处在局域网上的所有电脑共享同一个外网IP。&lt;br/&gt;    &lt;br/&gt;    IPv4&lt;br/&gt;    格式： xxx.xxx.xxx.xxx&lt;br/&gt;    总共是32位二进制，每8位分隔一下，这8位二进制最大可以表示255，所以&lt;br/&gt;    每一位的范围都是0－255，如：&lt;br/&gt;    10进制表示法：10.137.18.27&lt;br/&gt;    &lt;br/&gt;    IPv6&lt;/p&gt;
&lt;p&gt;　　··· ···&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;3. 网络协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;    就是计算机之间通信的一种标准。&lt;br/&gt;    TCP/IP  [4层]&lt;br/&gt;        应用层&lt;br/&gt;        网络层  [IP, Internet Protocol]&lt;br/&gt;        传输层  [TCP, Transfer Control Protocol]&lt;br/&gt;        物理层&lt;/p&gt;&lt;p&gt;    OSI/ISO 网络七层模型&lt;br/&gt;        应用层&lt;br/&gt;        表示层&lt;br/&gt;        会话层&lt;br/&gt;        网络层&lt;br/&gt;        传输层&lt;br/&gt;        数据链路层&lt;br/&gt;        物理层&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;4. 局域网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;    同属一个网段内的计算机组成的局部网络。&lt;br/&gt;    它采用内网IP，一般使用 192.168 开头或 10.10打头。&lt;br/&gt;    &lt;br/&gt;    192.168.50.242&lt;br/&gt;    255.255.254.0&lt;br/&gt;    192.168.50.1&lt;/p&gt;&lt;p&gt;    子网掩码,submask&lt;br/&gt;        &lt;br/&gt;    默认网关, gateway&lt;/p&gt;&lt;p&gt;二进制，由0和1组成&lt;br/&gt;计算机中采用二进制存储数据，所有的数据计算机中都是二进制的，也就是0和1组成&lt;/p&gt;&lt;p&gt;在计算机中，规定8位是一个字节。&lt;br/&gt;以8位为例：&lt;br/&gt;0000 0000&lt;br/&gt;....            中间会历经多少种变化? 2^8 = 256&lt;br/&gt;1111 1111&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;这256种变化，如果采用数字来表达的话，有两种表达方式：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;一、不考虑负数，也就是 0 ~ 255 或 1 ~ 256&lt;br/&gt;二、考虑负数， 也就是 －128~ －1以及 0~127, 总范围：-128~+127&lt;/p&gt;&lt;p&gt;所以，规定最高位是符号位，1代表负数，0代表正数&lt;br/&gt;0 000 0000    =&amp;gt; 0&lt;br/&gt;0 111 1111    =&amp;gt; +127&lt;/p&gt;&lt;p&gt;1 000 0000    =&amp;gt; -128&lt;br/&gt;1 111 1111    =&amp;gt; -1&lt;br/&gt;注：负数 采用补码来计算。补码 ＝ 原码取反+ 1&lt;/p&gt;&lt;p&gt;十进制与二进制之间的换算：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;十            二&lt;br/&gt;0            0&lt;br/&gt;1            1&lt;br/&gt;2            10&lt;br/&gt;3            11&lt;br/&gt;4            100&lt;br/&gt;5            101&lt;br/&gt;6            110&lt;br/&gt;7            111&lt;br/&gt;8            1000&lt;br/&gt;...&lt;br/&gt;15            1111&lt;/p&gt;&lt;p&gt;十转二：除2取余，直到商为0&lt;br/&gt;二转十：乘2的幂相加&lt;/p&gt;&lt;p&gt;2^0 =  1&lt;br/&gt;2^1 =  2&lt;br/&gt;2^2 =  4&lt;br/&gt;2^3 =  8&lt;br/&gt;2^4 =  16&lt;br/&gt;2^5 =  32&lt;br/&gt;2^6 =  64&lt;br/&gt;2^7 =  128&lt;br/&gt;2^8 =  256&lt;br/&gt;2^9 = 512&lt;br/&gt;2^10 = 1024&lt;/p&gt;&lt;p&gt;-----------------------------------------------------------------&lt;br/&gt;相关的命令&lt;br/&gt;    ping   命令&lt;/p&gt;&lt;p&gt;ping 127.0.0.1   =&amp;gt; 查看自己电脑的网卡是否正常工作&lt;br/&gt;        只要网卡能正常工作，这个是一定能ping 得通的。&lt;br/&gt;ping localhost  =&amp;gt; 同上&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;strong&gt;5. 广域网&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;也就是互联网，它的前身是美国军方的ARPNET。&lt;br/&gt;每台互联网上的“节点”，都有一个唯一的“外网IP”，而提供互联网服务，&lt;br/&gt;就必需有这个IP，但是，这个IP又非常难记忆，所以，推出了域名服务，域&lt;br/&gt;名与IP之间是映射的关系，我们把域名映射到IP上去。&lt;/p&gt;&lt;p&gt;当我们访问域名时，由互联网上的域名解析器帮助我们去解析这个域名成为&lt;br/&gt;目标IP地址，然后通过网络访问IP对应的主机，从而使用互联网服务。&lt;/p&gt;&lt;p&gt;域名解析器由域名提供商来提供。这就要求，所有的域名必需要由统一的机构&lt;br/&gt;来管理。&lt;/p&gt;
&lt;p&gt;-----------------------------------------------------------------&lt;br/&gt;服务[service]&lt;br/&gt;    也叫后台进程[Daemon Process]&lt;br/&gt;    这类软件一般没有桌面图标，所以，不可能“双击”去执行，它可以设置&lt;br/&gt;    成在开机时启动，也可以手动启动，这类服务有专门的“页面”来进行管理。&lt;/p&gt;&lt;p&gt;    命令 =&amp;gt;   compmgmt.msc&lt;/p&gt;&lt;p&gt;开机启动项&lt;br/&gt;    命令 =&amp;gt;  msconfig&lt;/p&gt;&lt;p&gt;-----------------------------------------------------------------&lt;br/&gt;有关本机的 hosts 文件：&lt;br/&gt;    位置：c:\windows\system32\drivers\etc\hosts&lt;/p&gt;&lt;p&gt;此文件的作用：&lt;br/&gt;    当我们在浏览器输出域名去访问时，系统会优先从本机的hosts文件中去查&lt;br/&gt;    找对应的记录，如果找到，则直接访问配置的IP地址，如果没有找到，则&lt;br/&gt;    请求网络DNS解析器进行解析。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2016157/202008/2016157-20200801210210637-545475094.png&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;&lt;br/&gt;                  故屿γ                   &lt;/strong&gt;&lt;/p&gt;


</description>
<pubDate>Tue, 11 Aug 2020 00:44:00 +0000</pubDate>
<dc:creator>故屿</dc:creator>
<og:description>计算机网络知识 1. 网卡 就是计算机要连接到网络上的一种硬件设备 它分有线和无线 有线网卡的接口主要采用 RJ45头，俗称 水晶头。采用双胶线、同轴电缆、光纤 等介质进行传输。 无线，主要是采用电磁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guyu-/p/13468548.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.32：VScode 韭菜基金插件，极大提高“工作”效率 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13469659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13469659.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143930936-516971021.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;小鱼干&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：有什么比干着本职工作——编码，而又兼顾“外快”——炒股更有开心的事情呢？leek-fund 就是这么一个极大提升你工作幸福度和效率的插件，可随时关注上证指数 &amp;amp; 实时基金数据。除了 leek-fund 这个插件，本周特推 simdjson 也是一大效率杀器，它可以每秒解析千兆字节的 JSON，除了效率，周获 1000+ star 的 955.WLB 则关注你的生活和工作，让你平衡二者，也不失为一个提升你找工作效率 repo…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周特推&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 json 解析大杀器：simdjson&lt;/li&gt;
&lt;li&gt;1.2 安全工程：how-to-secure-anything&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;GitHub Trending 周榜&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 万物皆可动：first-order-model&lt;/li&gt;
&lt;li&gt;2.2 平衡生活和工作：955.WLB&lt;/li&gt;
&lt;li&gt;2.3 VSCode 韭菜基金插件：leek-fund&lt;/li&gt;
&lt;li&gt;2.4 cat 克隆版：bat&lt;/li&gt;
&lt;li&gt;2.5 rust 小练习：rustlings&lt;/li&gt;
&lt;li&gt;2.6 深度学习引擎：oneflow&lt;/li&gt;
&lt;li&gt;2.7 资源监视器：bpytop&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Emoji Time&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1-本周特推&quot;&gt;1. 本周特推&lt;/h2&gt;
&lt;h3 id=&quot;11-json-解析大杀器：simdjson&quot;&gt;1.1 json 解析大杀器：simdjson&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1400+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;simdjson 是一个每秒解析千兆字节的 JSON 解析工具。simdjson 库使用常用的 SIMD 指令和微并行算法来解析 JSON，速度比其他解析器快 2.5 倍。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/simdjson/simdjson&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143550579-1584387371.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-安全工程：how-to-secure-anything&quot;&gt;1.2 安全工程：how-to-secure-anything&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;how-to-secure-anything 是一个安全工程课程，收录了大量同安全相关的资料，从最基础的安全工程是什么讲起，到已知的安全最佳实践，到安全模型构建、增强防御方法、科学查找漏洞，终于安全工程的未来展望，是一份详细全面的安全工程教程。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/veeral-patel/how-to-secure-anything&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143601216-681812395.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-github-trending-周榜&quot;&gt;2. GitHub Trending 周榜&lt;/h2&gt;
&lt;h3 id=&quot;21-万物皆可动：first-order-model&quot;&gt;2.1 万物皆可动：first-order-model&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：600+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;first-order-model 这个模型可以对视频中的对象进行动画处理，并生成视频序列。基于这个模型，可以实现图片换装，静态小马跑起来，特朗普和权力游戏角色对话等等功能。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/AliaksandrSiarohin/first-order-model&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143609721-1196389443.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-平衡生活和工作：955wlb&quot;&gt;2.2 平衡生活和工作：955.WLB&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;955.WLB 是一份 955 不加班的公司名单，如果你想要找一份 955 的工作，不妨 pick 这份名单。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/formulahendry/955.WLB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143616098-871945251.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-vscode-韭菜基金插件：leek-fund&quot;&gt;2.3 VSCode 韭菜基金插件：leek-fund&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：150+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; leek-fund 是一个 VSCode 插件，在编码的时候随时关注实时股票&amp;amp;基金数据。功能主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基金涨跌查看，可自定义配置基金代码，支持查看基金历史净值详情&lt;/li&gt;
&lt;li&gt;股票涨跌查看，可自定义配置股票代码，支持查看股票实时 K 线图&lt;/li&gt;
&lt;li&gt;左侧菜单面板&lt;/li&gt;
&lt;li&gt;底部状态 bar&lt;/li&gt;
&lt;li&gt;支持 GUI 操作新增&amp;amp;删除 基金 和 股票&lt;/li&gt;
&lt;li&gt;每天 9~15 点之间轮询刷新数据（刷新频率最低 3 秒，可配置）&lt;/li&gt;
&lt;li&gt;支持升序/降序排序&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/giscafer/leek-fund&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143621796-621626254.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-cat-克隆版：bat&quot;&gt;2.4 cat 克隆版：bat&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：750+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bat 是一个 cat 命令的一个克隆版，带有语法高亮、集成 git 等特性。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/sharkdp/bat&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143627104-244443141.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;25-rust-小练习：rustlings&quot;&gt;2.5 rust 小练习：rustlings&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：900+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rustlings 收录一些关于 rust 的小练习，方便你阅读和编写 rust 代码。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/rust-lang/rustlings&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143633669-1056968406.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-深度学习引擎：oneflow&quot;&gt;2.6 深度学习引擎：oneflow&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;oneflow 是国内一流科技开源的深度学习框架，oneflow 团队的目标是研发一个通用框架自动解决这些问题，让那些没有框架研发能力的团队也能够享受分布式 GPU 集群带来的效率。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/Oneflow-Inc/oneflow&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;27-资源监视器：bpytop&quot;&gt;2.7 资源监视器：bpytop&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：2700+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bpytop 是基于 Python 语言的 Linux / OSX / FreeBSD 资源监视，用于显示处理器，内存，磁盘，网络和进程的使用情况和状态。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/aristocratos/bpytop&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143640361-1534443276.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3-ttime&quot;&gt;3. TTime&lt;/h2&gt;
&lt;p&gt;Talk Time (&lt;sup&gt;o&lt;/sup&gt;)/ 你永远不知道在 GitHub 会找到什么有意思的项目，本篇 TT 话题 #让你惊呆了的 GitHub 项目# ，评论区就坐吧 😊&lt;/p&gt;
&lt;p&gt;依旧我先来，这是一个本周 Twitter 上和 HN 上讨论热烈的项目——通过微信小程序控制小强的移动 [手动狗头] 围观地址在这里：&lt;a href=&quot;https://github.com/chuangzhu/insect-robot/tree/2f466f8a04e431f5b42ae0229402c28271fdfaf2&quot;&gt;https://github.com/chuangzhu/insect-robot/tree/2f466f8a04e431f5b42ae0229402c28271fdfaf2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143649206-730818683.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有前年的口红色号项目… 🤔 下面，交给你来说说你遇到过的 amazing GitHub repo 啦~~&lt;/p&gt;
&lt;h2 id=&quot;4-推荐阅读&quot;&gt;4. 推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 32 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 &lt;a href=&quot;https://github.com/521xueweihan/HelloGitHub&quot;&gt;HelloGitHub&lt;/a&gt; issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202008/759200-20200810143823578-1303441549.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 11 Aug 2020 00:42:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者：HelloGitHub-小鱼干 摘要：有什么比干着本职工作——编码，而又兼顾“外快”——炒股更有开心的事情呢？leek-fund 就是这么一个极大提升你工作幸福度和效率的插件，可随时关注上证指数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13469659.html</dc:identifier>
</item>
<item>
<title>1302图像模糊处理（二维数组） - knbit</title>
<link>http://www.cnblogs.com/cyk20081108/p/13473422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyk20081108/p/13473422.html</guid>
<description>&lt;p class=&quot;title&quot; data-v-6e5e6c6e=&quot;&quot;&gt;描述&lt;/p&gt;
&lt;p&gt;给定m行n列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：&lt;br/&gt;1.四周最外侧的像素点灰度值不变；&lt;br/&gt;2.中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均(舍入到最接近的整数)&lt;/p&gt;

&lt;p class=&quot;title&quot; data-v-6e5e6c6e=&quot;&quot;&gt;输入&lt;/p&gt;
&lt;p&gt;第一行包含两个整数n和m，表示图像包含像素点的行数和列数。1≤n≤100，1≤m≤100。接下来n行，每行m个整数，表示图像的每个像素点灰度。相邻两个整数之间用单个空格隔开，每个元素均在0~255之间。&lt;/p&gt;

&lt;p class=&quot;title&quot; data-v-6e5e6c6e=&quot;&quot;&gt;输出&lt;/p&gt;
&lt;p&gt;m行，每行n个整数，为模糊处理后的图像。相邻两个整数之间用单个空格隔开。（行尾没有多余的空格）&lt;/p&gt;

&lt;div data-v-6e5e6c6e=&quot;&quot;&gt;
&lt;div class=&quot;flex-container sample&quot; data-v-6e5e6c6e=&quot;&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;sample-input&quot; data-v-6e5e6c6e=&quot;&quot; readability=&quot;7&quot;&gt;
&lt;p class=&quot;title&quot; data-v-6e5e6c6e=&quot;&quot;&gt;输入样例 1 &lt;/p&gt;
&lt;pre data-v-6e5e6c6e=&quot;&quot;&gt;
4 5
100 0 100 0 50
50 100 200 0 0
50 50 100 100 200
100 100 50 50 100
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;sample-output&quot; data-v-6e5e6c6e=&quot;&quot; readability=&quot;12.5&quot;&gt;
&lt;p class=&quot;title&quot; data-v-6e5e6c6e=&quot;&quot;&gt;输出样例 1&lt;/p&gt;
&lt;pre data-v-6e5e6c6e=&quot;&quot;&gt;
100 0 100 0 50
50 80 100 60 0
50 80 100 90 200
100 100 50 50 100
&lt;/pre&gt;
&lt;pre data-v-6e5e6c6e=&quot;&quot;&gt;
&lt;span&gt;这道题用到二维数组，乍一看很难，但其实也没有多难。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;代码：&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;bits/stdc++.h&amp;gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n,m;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;&lt;span&gt;m;　　//输入行数和列数
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;float&lt;/span&gt; a[n+&lt;span&gt;1&lt;/span&gt;][m+&lt;span&gt;1&lt;/span&gt;],b[n+&lt;span&gt;1&lt;/span&gt;][m+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]; 　　//定义二维数组
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;=m;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             cin&amp;gt;&amp;gt;&lt;span&gt;a[i][j];　　　　//输入二维数组
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             b[i][j]=&lt;span&gt;a[i][j];　　//这个数组用来计算输出
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;2&lt;/span&gt;;i&amp;lt;n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;2&lt;/span&gt;;j&amp;lt;m;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             b[i][j]=(a[i-&lt;span&gt;1&lt;/span&gt;][j]+a[i+&lt;span&gt;1&lt;/span&gt;][j]+a[i][j-&lt;span&gt;1&lt;/span&gt;]+a[i][j+&lt;span&gt;1&lt;/span&gt;]+a[i][j])/&lt;span&gt;5&lt;/span&gt;&lt;span&gt;;　　//模糊处理
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;1&lt;/span&gt;;j&amp;lt;m;j++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             cout&amp;lt;&amp;lt;&lt;span&gt;fixed&lt;/span&gt;&amp;lt;&amp;lt;setprecision(&lt;span&gt;0&lt;/span&gt;)&amp;lt;&amp;lt;b[i][j]&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;　　//行尾无空格输出
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         cout&amp;lt;&amp;lt;&lt;span&gt;fixed&lt;/span&gt;&amp;lt;&amp;lt;setprecision(&lt;span&gt;0&lt;/span&gt;)&amp;lt;&amp;lt;b[i][m]&amp;lt;&amp;lt;&lt;span&gt;endl;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;pre data-v-6e5e6c6e=&quot;&quot;&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
<pubDate>Tue, 11 Aug 2020 00:14:00 +0000</pubDate>
<dc:creator>knbit</dc:creator>
<og:description>描述 给定m行n列的图像各像素点的灰度值，要求用如下方法对其进行模糊化处理：1.四周最外侧的像素点灰度值不变；2.中间各像素点新灰度值为该像素点及其上下左右相邻四个像素点原灰度值的平均(舍入到最接近的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cyk20081108/p/13473422.html</dc:identifier>
</item>
<item>
<title>Web优化躬行记（4）——用户体验和工具 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/13218969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/13218969.html</guid>
<description>&lt;p&gt;　　用户体验（UE/UX）是指一个人使用一个特定产品、系统或服务时的行为、情绪与态度，还包含用户对于系统的功能、易用和效率的感受，因此用户体验在本质上可以视为一个人对于系统的主观感受与主观想法。&lt;/p&gt;
&lt;p&gt;　　用户体验是动态的，由于不断变化的使用情况、不停变化的各个系统，以及变化发生背后的情境与脉络，因此它是随着时间而不断地变化着。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）Loading动画&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有一份调查指出，用户能够忍受加载的最长时间在：6到8秒。8秒是一个临界值，如果加载时间在8秒以上，大部分访问者最终会选择放弃，除非他一定要打开那个页面。&lt;/p&gt;
&lt;p&gt;　　加载动画就是为了弥补服务器加载过慢的问题而设计的，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200701140456034-1447532918.jpg&quot; width=&quot;400&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　一个好的加载动画可以从两个层次分析，第一个层次是满足用户心理基本需求，缓解用户烦躁情绪，第二个层次是给予用户惊喜感，增加用户对产品的好感度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）过渡动画&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　过渡动画是为了在结构中插入或者删除一个视图时表现的不突兀，让用户可以感受到那段过程。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）记住用户习惯&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　记住用户习惯包括在页面刷新后定位到之前滚动的位置，缓存表单中的输入信息等，其实就是保留用户的操作痕迹。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）骨架屏&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　骨架屏（Skeleton Screen）是一个页面的空白版本，通过这个空白版本来传递一种信息，即页面正在渐进式的加载中。&lt;/p&gt;
&lt;p&gt;　　骨架屏的布局能与页面的视觉呈现保持一致，这样就能引导用户的关注点聚焦到感兴趣的位置，如下图所示，之前研究过一些制作&lt;span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/102919195&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;骨架屏的原理&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200701140756501-192001371.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）Chrome Devtools&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Chrome浏览器为开发人员提供了专业的开发者工具。不但能模拟网络连接，还能查看内存、研究重绘以及资源请求等功能。&lt;/p&gt;
&lt;p&gt;　　1. Elements：页面元素面板，可查看或修改DOM结构，以及元素的样式。&lt;/p&gt;
&lt;p&gt;　　2. Console：控制台面板，可打印日志，或断点调试。&lt;/p&gt;
&lt;p&gt;　　3. Sources：资源管理面板，包括JavaScript、CSS、图像、视频等。&lt;/p&gt;
&lt;p&gt;　　4. &lt;span&gt;&lt;a href=&quot;https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/reference&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Performance&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;：性能监控面板。&lt;/p&gt;
&lt;p&gt;　　5. Network：网络面板，包括请求列表、请求详情、网页加载所需的各项资源，并且还能模拟网络连接（2G、3G等）。&lt;/p&gt;
&lt;p&gt;　　6. Application：应用面板，Cookie、LocalStorage、Service Worker等，都可以在这里处理。&lt;/p&gt;
&lt;p&gt;　　7. Security：网络安全性概览面板，可查看网站的数字证书信息。&lt;/p&gt;
&lt;p&gt;　　Performance面板可以记录页面的加载、脚本执行、渲染和绘制活动，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200701140907458-1851249115.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　底部的Summary选项卡中可查看到摘要。&lt;/p&gt;
&lt;p&gt;　　1. Loading：加载中，网络接收/发送事件，以及HTML、图像和CSS解析活动。&lt;/p&gt;
&lt;p&gt;　　2. Scripting：JavaScript相关活动。&lt;/p&gt;
&lt;p&gt;　　3. Rendering：布局和回流，包括CSS、HTML变化，以及JavaScript对CSS的修改。&lt;/p&gt;
&lt;p&gt;　　4. Painting：将Web页面绘制和光栅化（输出转换为像素）到屏幕上。&lt;/p&gt;
&lt;p&gt;　　5. Other：Chrome不能细分的活动。&lt;/p&gt;
&lt;p&gt;　　6. Idle：闲置。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）webpack&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　webpack是一个静态模块打包器，此处的模块可以是任意文件，包括Sass、TypeScript、模板和图像等。&lt;/p&gt;
&lt;p&gt;　　webpack可压缩图像、JavaScript、CSS等文件，并且能合并JavaScript、预处理Sass并将其合并。&lt;/p&gt;
&lt;p&gt;　　借助&lt;span&gt;&lt;a href=&quot;https://www.kancloud.cn/pwstrick/fe-questions/1280320&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;webpack&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;还能实现Tree Shaking剔除未引用的代码，利用Code Spliting把代码分离到不同的bundle中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）WebPageTest&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/category/980651.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;WebPageTest&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是一款综合类的网站性能优化工具，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200701141107882-1727266161.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　WebPageTest通过布置一些特定的场景（例如不同的网速、浏览器、位置等）进行测试，并且在测试完成后就能获得优化等级、性能参数、请求瀑布图、网页幻灯片快照等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）RUM&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　RUM（Real User Monitoring）是一种实时监控用户的系统（例如自制的简易的&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/pineapple&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;pineapple&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，如下图所示），可以持续评估用户交互并收集典型用户设备上的真实数据，为Web应用程序提供完整的性能图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202007/211606-20200701141216352-305024034.png&quot; width=&quot;800&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　市面上成熟的RUM性能监控系统包括&lt;span&gt;&lt;a href=&quot;https://www.oneapm.com/bi/feature.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;OneAPM Browser Insight&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;、 &lt;span&gt;&lt;a href=&quot;https://www.datadoghq.com/dg/apm/ts-comp/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;DATADOG&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;、&lt;span&gt;&lt;a href=&quot;https://cn.aliyun.com/product/arms&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;阿里云ARMS&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;等。&lt;/p&gt;

</description>
<pubDate>Mon, 10 Aug 2020 23:35:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、用户体验 用户体验（UE/UX）是指一个人使用一个特定产品、系统或服务时的行为、情绪与态度，还包含用户对于系统的功能、易用和效率的感受，因此用户体验在本质上可以视为一个人对于系统的主观感受与主观想</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/13218969.html</dc:identifier>
</item>
<item>
<title>【译】gRPC-Web for .NET now available - MeteorSeed</title>
<link>http://www.cnblogs.com/MeteorSeed/p/13473250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeteorSeed/p/13473250.html</guid>
<description>&lt;p&gt;gRPC-Web 变成了 grpc-dotnet 项目的一个完全受支持的组件，它已经准备就绪。现在可以通过 gRPC-Web 和 .NET 在浏览器中使用 gRPC。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;99.44723764981&quot;&gt;
&lt;p&gt;　　.NET 的 gRPC-Web 现在正式发布了。我们在一月份发布了实验版，从那时起，我们就根据早期的用户反馈进行着改进。&lt;/p&gt;
&lt;p&gt;　　有了这个版本，gRPC-Web 就变成了 grpc-dotnet 项目的一个完全受支持的组件，它已经准备就绪。现在可以通过 gRPC-Web 和 .NET 在浏览器中使用 gRPC。&lt;/p&gt;

&lt;p&gt;　　刚接触 gRPC 的开发者，应该学习下微软的《教程：在 ASP.NET Core 中创建 gRPC 客户端和服务器》，该教程介绍如何使用 .NET 创建一个 gRPC client 和 server。&lt;/p&gt;
&lt;p&gt;　　如果你已经有一个 gRPC 应用，那么《在浏览器应用中使用 gRPC》将展示如何将 gRPC-Web 添加到 .NET gRPC server。&lt;/p&gt;

&lt;p&gt;　　gRPC 是一个现代的高性能 RPC（Remote Procedure Call）框架。gRPC 基于 HTTP/2、Protocol Buffers 和其他基于标准的现代技术。gRPC 是一种开放标准，受到许多编程语言的支持，包括 .NET。&lt;/p&gt;
&lt;p&gt;　　目前在浏览器中实现 gRPC HTTP/2 规范是不可能的，因为没有对请求进行足够细粒度控制的浏览器API。gRPC-Web 是一个标准化的协议，它解决了这个问题，并使 gRPC 在浏览器中可用。 gRPC-Web 为现代浏览器应用程序带来了许多 gRPC 的优秀特性，比如较小的二进制消息和 contract-first 的 API。&lt;/p&gt;

&lt;p&gt;　　gRPC-Web 旨在使 gRPC 在更多的场景中可用，包括:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;从浏览器调用 ASP.NET Core gRPC 应用&lt;/strong&gt;——浏览器 API 不能调用gRPC HTTP/2。gRPC-Web 提供了一个兼容的替代方案。
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;JavaScript SPAs&lt;/li&gt;
&lt;li&gt;.NET Blazor Web Assembly 应用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在 IIS 和 Azure App Service 中的 Host ASP.NET Core gRPC 应用&lt;/strong&gt;——一些服务器，如 IIS 和 Azure App Service，目前不能托管 gRPC 服务。虽然这方面的工作正在积极进行，但 gRPC-Web 提供了一个有趣的替代方案，可以在当今的每个环境中工作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;从非 .NET Core 平台调用 gRPC&lt;/strong&gt;——HttpClient 在所有 .NET 平台上不支持 HTTP/2。gRPC-Web 可以用来调用 Blazor 和 Xamarin 的 gRPC 服务。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202008/270073-20200811013550610-439989078.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（gRPC 是 Linux 基金会的注册商标。Blazor 兼容 gRPC-WEB。）&lt;/p&gt;
&lt;p&gt;　　我们已经与 Blazor 团队合作，使 gRPC-Web 在 Blazor WebAssembly 应用程序中使用时具有良好的端到端开发体验。gRPC 工具不仅会自动生成强类型的客户端，让你从 Blazor 应用程序中调用 gRPC 服务，而且 gRPC 比 JSON 提供了显著的性能优势。&lt;/p&gt;
&lt;p&gt;　　性能优势的一个很好的例子就是 Blazor 的默认模板应用程序。使用 gRPC 代替 JSON 时，获取数据页面上传输的数据减少了一半。数据大小从627字节减少到309字节。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/270073/202008/270073-20200811013712759-1075681313.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里的性能提高来自于 gRPC 比传统的基于文本的 JSON 高效的二进制序列化。gRPC-Web 是改进基于浏览器的富应用程序的一个令人兴奋的机遇。&lt;/p&gt;

&lt;p&gt;　　有关 gRPC-Web 的更多信息，请查看文档，或尝试使用 gRPC-Web 的示例应用程序。&lt;/p&gt;
&lt;p&gt;　　.NET 的 gRPC-Web 已经在 NuGet 上发布了:&lt;/p&gt;
&lt;p&gt;　　我们期待看到你用 .NET、gRPC 和现在的 gRPC-Web 所创造的东西!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;       &lt;/em&gt;&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/?utm_source=vs_developer_news&amp;amp;utm_medium=referral&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;https://devblogs.microsoft.com/aspnet/grpc-web-for-net-now-available/?utm_source=vs_developer_news&amp;amp;utm_medium=referral&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 10 Aug 2020 17:44:00 +0000</pubDate>
<dc:creator>MeteorSeed</dc:creator>
<og:description>gRPC-Web 变成了 grpc-dotnet 项目的一个完全受支持的组件，它已经准备就绪。现在可以通过 gRPC-Web 和 .NET 在浏览器中使用 gRPC。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MeteorSeed/p/13473250.html</dc:identifier>
</item>
<item>
<title>设计模式之观察者模式 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/observer-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/observer-pattern.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;观察者模式又叫做 发布订阅（Publish/Subscribe）模式&lt;br/&gt;观察者模式定义了一种一对多的依赖关系，让多个观察者同时监听某一主题对象。&lt;br/&gt;这个主题对象在状态发生变化时，会通知所有观察者对象，使得他们能够自动更新自己。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;观察者模式所做的工作其实就是在解耦，让耦合的双方都依赖于抽象而不是具体，从而使得各自的变化都不会影响另一边的变化。&lt;/p&gt;
&lt;p&gt;当一个对象的改变需要改变其他对象的时候，而且它不知道具体有多少对象有待改变的时候，应该考虑使用观察者模式。&lt;/p&gt;
&lt;p&gt;一个抽象模型有两方面，其中一方面依赖于另一方面，这时用观察者模式可以将这两者封装在独立的对象中使得他们各自独立地改变和复用。&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public interface ISubject
{
    void Notify();

    string SubjectState { get; set; }
}
public class Boss : ISubject
{
    private readonly IList&amp;lt;Observer&amp;gt; _observers = new List&amp;lt;Observer&amp;gt;();

    public void Attach(Observer observer)
    {
        _observers.Add(observer);
    }

    public void Detach(Observer observer)
    {
        _observers.Remove(observer);
    }

    public void Notify()
    {
        foreach (var observer in _observers)
        {
            observer.Update();
        }
    }

    public string SubjectState { get; set; }
}

public abstract class Observer
{
    protected string Name;
    protected ISubject Subject;

    protected Observer(string name, ISubject subject)
    {
        Name = name;
        Subject = subject;
    }

    public abstract void Update();
}
public class StockObserver : Observer
{
    public StockObserver(string name, ISubject subject) : base(name, subject)
    {
    }

    public override void Update()
    {
        Console.WriteLine($&quot;{Name} {Subject.SubjectState} 关闭股票行情，继续工作&quot;);
    }
}
public class NBAObserver : Observer
{
    public NBAObserver(string name, ISubject subject) : base(name, subject)
    {
    }

    public override void Update()
    {
        Console.WriteLine($&quot;{Name} {Subject.SubjectState} 关闭 NBA 直播，继续工作&quot;);
    }
}


var boss = new Boss();
var stockObserver = new StockObserver(&quot;魏关姹&quot;, boss);
var nbaObserver = new NBAObserver(&quot;易管查&quot;, boss);

boss.Attach(stockObserver);
boss.Attach(nbaObserver);

boss.Detach(stockObserver);

boss.SubjectState = &quot;老板我胡汉三回来了&quot;;
boss.Notify();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;借助 event（委托） 我们可以实现可以灵活的观察者模式，我们定义了一个新老板来演示事件的方式，来看下面的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class NewBoss : ISubject
{
    public event Action Update;

    public void Notify()
    {
        Update?.Invoke();
    }

    public string SubjectState { get; set; }
}

public class GamePlayerObserver
{
    private readonly string _name;
    private readonly ISubject _subject;

    public GamePlayerObserver(string name, ISubject subject)
    {
        _name = name;
        _subject = subject;
    }

    public void CloseGame()
    {
        Console.WriteLine($&quot;{_name} {_subject.SubjectState} 关闭 LOL 游戏，继续工作&quot;);
    }
}

var newBoss = new NewBoss();
var stockObserver = new StockObserver(&quot;魏关姹&quot;, boss);
var nbaObserver = new NBAObserver(&quot;易管查&quot;, boss);
var gameObserver = new GamePlayerObserver(&quot;西门&quot;, newBoss);

// 注册通知事件
newBoss.Update += stockObserver.Update;
newBoss.Update += nbaObserver.Update;
newBoss.Update += gameObserver.CloseGame;

newBoss.Update -= stockObserver.Update;

newBoss.SubjectState = &quot;老板我胡汉三回来了&quot;;
newBoss.Notify();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面这个示例可以看到，通过事件的方式，我们可以不要求显示继承于 &lt;code&gt;Observer&lt;/code&gt; 这个抽象类，可以更加灵活，扩展性更强，这也是很多类库中会使用事件来扩展的重要原因&lt;/p&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;设计模式要干的事情就是解耦。创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦，具体到观察者模式，它是将观察者和被观察者代码解耦。&lt;/p&gt;
&lt;p&gt;根据应用场景的不同，观察者模式会对应不同的代码实现方式：有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。&lt;/p&gt;
&lt;p&gt;在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。一般情况下，被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EventBus&lt;/code&gt;(事件总线) 就是一个观察者模式的实际应用。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Mon, 10 Aug 2020 16:56:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>观察者模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/observer-pattern.html</dc:identifier>
</item>
<item>
<title>Java程序员面试必备：Volatile全方位解析 - Jay_huaxiao</title>
<link>http://www.cnblogs.com/jay-huaxiao/p/13473197.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-huaxiao/p/13473197.html</guid>
<description>&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile是Java程序员必备的基础，也是面试官非常喜欢问的一个话题，本文跟大家一起开启vlatile学习之旅，如果有不正确的地方，也麻烦大家指出哈，一起相互学习~&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;1.volatile的用法&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;2.vlatile变量的作用&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;3.现代计算机的内存模型（计算机模型，总线，MESI协议，嗅探技术）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;4.Java内存模型（JMM）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;5.并发编程的3个特性（原子性、可见性、有序性、happen-before、as-if-serial、指令重排）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;6.volatile的底层原理（如何保证可见性，如何保证指令重排，内存屏障）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;7.volatile的典型场景（状态标志，DCL单例模式）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;8.volatile常见面试题&amp;amp;&amp;amp;答案解析&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;公众号：捡田螺的小男孩&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;github 地址&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://github.com/whx123/JavaHome&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1.volatile的用法&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile关键字是Java虚拟机提供的的&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;最轻量级的同步机制&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，它作为一个修饰符出现，用来&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;修饰变量&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，但是这里不包括局部变量哦。我们来看个demo吧，代码如下:&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;15&quot;&gt;/**&lt;br/&gt;*  @Author 捡田螺的小男孩&lt;br/&gt;*  @Date 2020/08/02&lt;br/&gt;*  @Desc volatile的可见性探索&lt;br/&gt;*/&lt;br/&gt;public class VolatileTest  {&lt;p&gt;public static void main(String[] args) throws InterruptedException {&lt;br/&gt;Task task = new Task();&lt;/p&gt;&lt;p&gt;Thread t1 = new Thread(task, &lt;span class=&quot;hljs-string&quot;&gt;&quot;线程t1&quot;&lt;/span&gt;);&lt;br/&gt;Thread t2 = new Thread(new &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;@Override&lt;br/&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;try {&lt;br/&gt;Thread.sleep(1000);&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;开始通知线程停止&quot;&lt;/span&gt;);&lt;br/&gt;task.stop = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;; //修改stop变量值。&lt;br/&gt;} catch (InterruptedException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}, &lt;span class=&quot;hljs-string&quot;&gt;&quot;线程t2&quot;&lt;/span&gt;);&lt;br/&gt;t1.start();  //开启线程t1&lt;br/&gt;t2.start();  //开启线程t2&lt;br/&gt;Thread.sleep(1000);&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class Task implements Runnable {&lt;br/&gt;boolean stop = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;int i = 0;&lt;/p&gt;&lt;p&gt;@Override&lt;br/&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;long s = System.currentTimeMillis();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (!stop) {&lt;br/&gt;i++;&lt;br/&gt;}&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;线程退出&quot;&lt;/span&gt; + (System.currentTimeMillis() - s));&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;运行结果：&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; &lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/057e2eec568a40fe9f47e05f3b47bdb7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt; 可以发现线程t2，虽然把stop设置为true了，但是线程t1对t2的&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;stop变量视而不可见&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，因此，它一直在死循环running中。如果给变量stop加上volatile修饰，线程t1是可以停下来的,运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;volatile boolean stop = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81326a66e9cc4350af71b0e9ff4dc304~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. vlatile修饰变量的作用&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上例子，我们可以发现变量stop，加了vlatile修饰之后，线程t1对stop就可见了。其实，vlatile的作用就是：&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;保证变量对所有线程可见性&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。当然，vlatile还有个作用就是，&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;禁止指令重排&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，但是它&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;不保证原子性&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。 &lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5177218cf2b491da99d43392c7bd271~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以当面试官问你&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;volatile的作用或者特性&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，都可以这么回答：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;保证变量对所有线程可见性;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;禁止指令重排序&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;不保证原子性&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 现代计算机的内存模型（计算机模型，MESI协议，嗅探技术，总线）&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更好理解volatile，先回顾一下计算机的内存模型与JMM（Java内存模型）吧~&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;计算机模型&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机执行程序时，指令是由CPU处理器执行的，而打交道的数据是在主内存当中的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于计算机的存储设备与处理器的运算速度有几个数量级的差距，总不能每次CPU执行完指令，然后等主内存慢悠悠存取数据吧， 所以现代计算机系统加入一层读写速度接近处理器运算速度的高速缓存（Cache），以作为来作为内存与处理器之间的缓冲。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多路处理器系统中，每个处理器都有自己的高速缓存，而它们共享同一主内存。&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;计算机抽象内存模型&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;如下：&lt;/p&gt;
&lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f995fb284a7241b9b95431e79a1c37b0~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;程序执行时，把需要用到的数据，从主内存拷贝一份到高速缓存。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;CPU处理器计算时，从它的高速缓存中读取，把计算完的数据写入高速缓存。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;当程序运算结束，把高速缓存的数据刷新会主内存。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着科学技术的发展，为了效率，高速缓存又衍生出一级缓存（L1），二级缓存（L2），甚至三级缓存(L3); &lt;img src=&quot;https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05fa9ff22d7f42ae82122bfc6c233bd9~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当多个处理器的运算任务都涉及同一块主内存区域，可能导致&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;缓存数据不一致&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;问题。如何解决这个问题呢？有两种方案&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;1、通过在总线加LOCK#锁的方式。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;2、通过缓存一致性协议（Cache Coherence Protocol）&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总线&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;总线（Bus）是计算机各种功能部件之间传送信息的公共通信干线，它是由导线组成的传输线束， 按照计算机所传输的信息种类，计算机的总线可以划分为数据总线、地址总线和控制总线，分别用来传输数据、数据地址和控制信号。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU和其他功能部件是通过总线通信的，如果在总线加LOCK#锁，那么在锁住总线期间，其他CPU是无法访问内存，这样一来，&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;效率就比较低了&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;MESI协议&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决一致性问题，还可以通过缓存一致性协议。即各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol等。比较著名的就是Intel的MESI（Modified Exclusive Shared Or Invalid）协议，它的核心思想是：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU中每个缓存行标记的4种状态（M、E、S、I）,也了解一下吧:&lt;/p&gt;
&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;缓存状态&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;M，被修改（Modified)&lt;/td&gt;
&lt;td&gt;该缓存行只被该CPU缓存，与主存的值不同，会在它被其他CPU读取之前写入内存，并设置为Shared&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;E，独享的（Exclusive)&lt;/td&gt;
&lt;td&gt;该缓存行只被该CPU缓存，与主存的值相同，被其他CPU读取时置为Shared，被其他CPU写时置为Modified&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;S，共享的（Shared)&lt;/td&gt;
&lt;td&gt;该缓存行可能被多个CPU缓存，各个缓存中的数据与主存数据相同&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;I，无效的（Invalid）&lt;/td&gt;
&lt;td&gt;该缓存行数据是无效，需要时需重新从主存载入&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MESI协议是如何实现的？如何保证当前处理器的内部缓存、主内存和其他处理器的缓存数据在总线上保持一致的？&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;多处理器总线嗅探&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;嗅探技术&lt;/span&gt;&lt;/h4&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存值是不是过期了，如果处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据库读到处理器缓存中。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. Java内存模型（JMM）&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Java虚拟机规范试图定义一种Java内存模型,来&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;屏蔽掉各种硬件和操作系统的内存访问差异&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，以实现让Java程序在各种平台上都能达到一致的内存访问效果。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Java内存模型&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;类比&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;于计算机内存模型。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;为了更好的执行性能，java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存打交道，也没有限制编译器进行调整代码顺序优化。所以Java内存模型&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;会存在缓存一致性问题和指令重排序问题的&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Java内存模型规定所有的变量都是存在主内存当中（类似于计算机模型中的物理内存），每个线程都有自己的工作内存（类似于计算机模型的高速缓存）。这里的&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;变量&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;包括实例变量和静态变量，但是&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;不包括局部变量&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，因为局部变量是线程私有的。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;线程的工作内存保存了被该线程使用的变量的主内存副本，&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;线程对变量的所有操作都必须在工作内存中进行&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，而不能直接操作操作主内存。并且每个线程不能访问其他线程的工作内存。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6ca8c98a8cc42c998dd4fe3324ded79~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子吧，假设i的初始值是0，执行以下语句：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;i = i+1;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，执行线程t1从主内存中读取到i=0，到工作内存。然后在工作内存中，赋值i+1,工作内存就得到i=1，最后把结果写回主内存。因此，如果是单线程的话，该语句执行是没问题的。但是呢，线程t2的本地工作内存还没过期，那么它读到的数据就是脏数据了。如图： &lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0abe171336e4f89a58722a1569d64ce~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java内存模型是围绕着如何在并发过程中如何处理&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;原子性、可见性和有序性&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;这3个特征来建立的，我们再来一起回顾一下~&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5.并发编程的3个特性（原子性、可见性、有序性）&lt;/span&gt;&lt;/h3&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;原子性&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原子性，指操作是不可中断的，要么执行完成，要么不执行，基本数据类型的访问和读写都是具有原子性，当然（long和double的非原子性协定除外）。我们来看几个小例子：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;i =666； // 语句1&lt;br/&gt;i = j;   // 语句2&lt;br/&gt;i = i+1;  //语句 3&lt;br/&gt;i++;   // 语句4&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;语句1操作显然是原子性的，将数值666赋值给i，即线程执行这个语句时，直接将数值666写入到工作内存中。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;语句2操作看起来也是原子性的，但是它实际上涉及两个操作，先去读j的值，再把j的值写入工作内存，两个操作分开都是原子操作，但是合起来就不满足原子性了。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;语句3读取i的值，加1，再写回主存，这个就不是原子性操作了。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;语句4 等同于语句3，也是非原子性操作。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;可见性&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volatile变量都是如此。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;volatile变量，保证新值能立即同步回主内存，以及每次使用前立即从主内存刷新，所以我们说volatile保证了多线程操作变量的可见性。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;synchronized和Lock也能够保证可见性，线程在释放锁之前，会把共享变量值都刷回主存。final也可以实现可见性。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;有序性&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java虚拟机这样描述Java程序的有序性的：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中，观察另一个线程，所有的操作都是无序的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后半句意思就是，在Java内存模型中，&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;允许编译器和处理器对指令进行重排序&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，会影响到多线程并发执行的正确性；前半句意思就是&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;as-if-serial&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的语义，即不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不会被改变。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如以下程序代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;double pi  = 3.14;    //A&lt;br/&gt;double r   = 1.0;     //B&lt;br/&gt;double area = pi * r * r; //C&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤C依赖于步骤A和B，因为指令重排的存在，程序执行顺讯可能是A-&amp;gt;B-&amp;gt;C,也可能是B-&amp;gt;A-&amp;gt;C,但是C不能在A或者B前面执行，这将违反as-if-serial语义。 &lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87387195b86749ddbe1f36582a562988~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看段代码吧，假设程序先执行read方法，再执行add方法，结果一定是输出sum=2嘛？&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;bool flag = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;int b = 0;&lt;p&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;b = 1;              //1&lt;br/&gt;flag = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;        //2&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (flag) {         //3&lt;br/&gt;int sum =b+b;   //4&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;bb sum is&quot;&lt;/span&gt;+sum); &lt;br/&gt;} &lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是单线程，结果应该没问题，如果是多线程，线程t1对步骤1和2进行了&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;指令重排序&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;呢？结果sum就不是2了，而是0，如下图所示： &lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/093c6e37453c462985bed78c4d239979~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是为啥呢？&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;指令重排序&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;了解一下，指令重排是指在程序执行过程中,&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;为了提高性能&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;span&gt;「&lt;/span&gt;编译器和CPU可能会对指令进行重新排序&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。CPU重排序包括指令并行重排序和内存系统重排序，重排序类型和重排序执行过程如下：&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d8a24934eab24bf9b80c402039371aa2~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，可以给flag加上volatile关键字，来保证有序性。当然，也可以通过synchronized和Lock来保证有序性。synchronized和Lock保证某一时刻是只有一个线程执行同步代码，相当于是让线程顺序执行程序代码了，自然就保证了有序性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上Java内存模型的有序性并不是仅靠volatile、synchronized和Lock来保证有序性的。这是因为Java语言中，有一个先行发生原则（happens-before）：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;程序次序规则&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;管程锁定规则&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：一个unLock操作先行发生于后面对同一个锁额lock操作&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;volatile变量规则&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：对一个变量的写操作先行发生于后面对这个变量的读操作&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;线程启动规则&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：Thread对象的start()方法先行发生于此线程的每个一个动作&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;线程终止规则&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;线程中断规则&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;对象终结规则&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：一个对象的初始化完成先行发生于他的finalize()方法的开始&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;传递性&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据happens-before的八大规则，我们回到刚的例子，一起分析一下。给flag加上volatile关键字，look look它是如何保证有序性的，&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;volatile bool flag = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;int b = 0;&lt;p&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;read&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;b = 1;              //1&lt;br/&gt;flag = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;        //2&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;add&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (flag) {         //3&lt;br/&gt;int sum =b+b;   //4&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;bb sum is&quot;&lt;/span&gt;+sum); &lt;br/&gt;} &lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;首先呢，flag加上volatile关键字，那就禁止了指令重排，也就是1 happens-before 2了&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;根据&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;volatile变量规则&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，2 happens-before 3&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;由&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;程序次序规则&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，得出 3 happens-before 4&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;最后由&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;传递性&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，得出1 happens-before 4，因此妥妥的输出sum=2啦~&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6.volatile底层原理&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上讨论学习，我们知道volatile的语义就是保证变量对所有线程可见性以及禁止指令重排优化。那么，它的底层是如何保证可见性和禁止指令重排的呢？&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;图解volatile是如何保证可见性的？&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，先看几个图吧，哈哈~&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设flag变量的初始值false，现在有两条线程t1和t2要访问它，就可以简化为以下图： &lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ddbe230c8dc4501a77ffbe0587b5ba6~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程t1执行以下代码语句，并且flag没有volatile修饰的话；t1刚修改完flag的值，还没来得及刷新到主内存，t2又跑过来读取了，很容易就数据flag不一致了，如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;flag=&lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc065cf75803496aa1efafd6d68ba968~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果flag变量是由volatile修饰的话，就不一样了，如果线程t1修改了flag值，volatile能保证修饰的flag变量后，可以&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;立即同步回主内存&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。如图：&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27e9e195810a4a71bdeb38dd128b27e4~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的朋友会发现，线程t2不还是flag旧的值吗，这不还有问题嘛？其实volatile还有一个保证，就是&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;每次使用前立即先从主内存刷新最新的值&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，线程t1修改完后，线程t2的变量副本会过期了，如图： &lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e67dcdfe9d9412dab89961bf92b5b53~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，这里还不是底层，实际上volatile保证可见性和禁止指令重排都跟&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;内存屏障&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;有关，我们编译volatile相关代码看看~&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;DCL单例模式（volatile）&amp;amp;编译对比&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DCL单例模式（Double Check Lock，双重检查锁）比较常用，它是需要volatile修饰的，所以就拿这段代码编译吧&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;public class Singleton {  &lt;br/&gt;private volatile static Singleton instance;  &lt;br/&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;Singleton&lt;/span&gt;&lt;/span&gt; (){}  &lt;br/&gt;public static Singleton &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (instance == null) {  &lt;br/&gt;synchronized (Singleton.class) {  &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (instance == null) {  &lt;br/&gt;instance = new Singleton();  &lt;br/&gt;}  &lt;br/&gt;}  &lt;br/&gt;}  &lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; instance;  &lt;br/&gt;}  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译这段代码后，观察有volatile关键字和没有volatile关键字时的instance所生成的汇编代码发现，有volatile关键字修饰时，会多出一个lock addl $0x0,(%esp)，即多出一个lock前缀指令&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;0x01a3de0f: mov    &lt;span class=&quot;hljs-variable&quot;&gt;$0x3375cdb0&lt;/span&gt;,%esi   ;...beb0cd75 33  &lt;br/&gt;;   {oop(&lt;span class=&quot;hljs-string&quot;&gt;'Singleton'&lt;/span&gt;)}  &lt;br/&gt;0x01a3de14: mov    %eax,0x150(%esi)   ;...89865001 0000  &lt;br/&gt;0x01a3de1a: shr    &lt;span class=&quot;hljs-variable&quot;&gt;$0x9&lt;/span&gt;,%esi          ;...c1ee09  &lt;br/&gt;0x01a3de1d: movb   &lt;span class=&quot;hljs-variable&quot;&gt;$0x0&lt;/span&gt;,0x1104800(%esi)  ;...c6860048 100100  &lt;br/&gt;0x01a3de24: lock addl &lt;span class=&quot;hljs-variable&quot;&gt;$0x0&lt;/span&gt;,(%esp)     ;...f0830424 00  &lt;br/&gt;;*putstatic instance  &lt;br/&gt;; - Singleton::getInstance@24 &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lock指令相当于一个&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;内存屏障&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，它保证以下这几点：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;1.重排序时不能把后面的指令重排序到内存屏障之前的位置&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;2.将本处理器的缓存写入内存&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;3.如果是写入动作，会导致其他处理器中对应的缓存无效。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，第2、3点不就是volatile保证可见性的体现嘛，第1点就是禁止指令重排列的体现。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;内存屏障&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存屏障四大分类：（Load 代表读取指令，Store代表写入指令）&lt;/p&gt;
&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;内存屏障类型&lt;/th&gt;
&lt;th&gt;抽象场景&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LoadLoad屏障&lt;/td&gt;
&lt;td&gt;Load1; LoadLoad; Load2&lt;/td&gt;
&lt;td&gt;在Load2要读取的数据被访问前，保证Load1要读取的数据被读取完毕。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;StoreStore屏障&lt;/td&gt;
&lt;td&gt;Store1; StoreStore; Store2&lt;/td&gt;
&lt;td&gt;在Store2写入执行前，保证Store1的写入操作对其它处理器可见&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;LoadStore屏障&lt;/td&gt;
&lt;td&gt;Load1; LoadStore; Store2&lt;/td&gt;
&lt;td&gt;在Store2被写入前，保证Load1要读取的数据被读取完毕。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;StoreLoad屏障&lt;/td&gt;
&lt;td&gt;Store1; StoreLoad; Load2&lt;/td&gt;
&lt;td&gt;在Load2读取操作执行前，保证Store1的写入对所有处理器可见。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了实现volatile的内存语义，Java内存模型采取以下的保守策略&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;在每个volatile写操作的前面插入一个StoreStore屏障。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在每个volatile写操作的后面插入一个StoreLoad屏障。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在每个volatile读操作的前面插入一个LoadLoad屏障。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在每个volatile读操作的后面插入一个LoadStore屏障。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴，可能对这个还是有点疑惑，内存屏障这玩意太抽象了。我们照着代码看下吧：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3097b7467304540b6a552d897d46997~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt; 内存屏障保证前面的指令先执行，所以这就保证了禁止了指令重排啦，同时内存屏障保证缓存写入内存和其他处理器缓存失效，这也就保证了可见性，哈哈~&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7.volatile的典型场景&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常来说，使用volatile必须具备以下2个条件：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;1）对变量的写操作不依赖于当前值&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;2）该变量没有包含在具有其他变量的不变式中&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，volatile场景一般就是&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;状态标志&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，以及&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;DCL单例模式&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7.1 状态标志&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;深入理解Java虚拟机，书中的例子：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;11&quot;&gt;Map configOptions;&lt;br/&gt;char[] configText;&lt;br/&gt;// 此变量必须定义为 volatile&lt;br/&gt;volatile boolean initialized = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;p&gt;// 假设以下代码在线程 A 中运行&lt;br/&gt;// 模拟读取配置信息, 当读取完成后将 initialized 设置为 &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt; 以告知其他线程配置可用&lt;br/&gt;configOptions = new HashMap();&lt;br/&gt;configText = readConfigFile(fileName);&lt;br/&gt;processConfigOptions(configText, configOptions);&lt;br/&gt;initialized = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;// 假设以下代码在线程 B 中运行&lt;br/&gt;// 等待 initialized 为 &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;, 代表线程 A 已经把配置信息初始化完成&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(!initialized) {&lt;br/&gt;sleep();&lt;br/&gt;}&lt;br/&gt;// 使用线程 A 中初始化好的配置信息&lt;br/&gt;doSomethingWithConfig();&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7.2 DCL单例模式&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;3&quot;&gt;class Singleton{&lt;br/&gt;private volatile static Singleton instance = null;&lt;p&gt;private &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;Singleton&lt;/span&gt;&lt;/span&gt;() {   &lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static Singleton &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(instance==null) {&lt;br/&gt;synchronized (Singleton.class) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(instance==null)&lt;br/&gt;instance = new Singleton();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; instance;&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8. volatile相关经典面试题&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;谈谈volatile的特性&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;volatile的内存语义&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;说说并发编程的3大特性&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;什么是内存可见性，什么是指令重排序？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;volatile是如何解决java并发中可见性的问题&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;volatile如何防止指令重排&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;volatile可以解决原子性嘛？为什么？&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;volatile底层的实现机制&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;volatile和synchronized的区别？&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8.1 谈谈volatile的特性&lt;/span&gt;&lt;/h4&gt;
&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e624231e978455ebec33c7380ffba0d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8.2 volatile的内存语义&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8.3 说说并发编程的3大特性&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;原子性&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;可见性&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;有序性&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8.4 什么是内存可见性，什么是指令重排序？&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8.5 volatile是如何解决java并发中可见性的问题&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;底层是通过内存屏障实现的哦，volatile能保证修饰的变量后，可以立即同步回主内存，每次使用前立即先从主内存刷新最新的值。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8.6 volatile如何防止指令重排&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也是内存屏障哦，跟面试官讲下Java内存的保守策略：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;在每个volatile写操作的前面插入一个StoreStore屏障。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在每个volatile写操作的后面插入一个StoreLoad屏障。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在每个volatile读操作的前面插入一个LoadLoad屏障。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在每个volatile读操作的后面插入一个LoadStore屏障。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再讲下volatile的语义哦，重排序时不能把内存屏障后面的指令重排序到内存屏障之前的位置&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8.7 volatile可以解决原子性嘛？为什么？&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不可以，可以直接举i++那个例子，原子性需要synchronzied或者lock保证&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;8&quot;&gt;public class Test {&lt;br/&gt;public volatile int race = 0;&lt;p&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;increase&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;race++;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public static void main(String[] args) {&lt;br/&gt;final Test &lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt; = new Test();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(int i=0;i&amp;lt;10;i++){&lt;br/&gt;new &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;Thread&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;public void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(int j=0;j&amp;lt;100;j++)&lt;br/&gt;test.increase();&lt;br/&gt;};&lt;br/&gt;}.start();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;//等待所有累加线程结束&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt;(Thread.activeCount()&amp;gt;1)  &lt;br/&gt;Thread.yield();&lt;br/&gt;System.out.println(test.race);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8.8 volatile底层的实现机制&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看本文的第六小节，volatile底层原理哈，主要你要跟面试官讲述，volatile如何保证可见性和禁止指令重排，需要讲到内存屏障~&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8.9 volatile和synchronized的区别？&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;volatile修饰的是变量，synchronized一般修饰代码块或者方法&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;volatile保证可见性、禁止指令重排，但是不保证原子性；synchronized可以保证原子性&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;volatile不会造成线程阻塞，synchronized可能会造成线程的阻塞，所以后面才有锁优化那么多故事~&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;哈哈，你还有补充嘛~&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐之前写的一篇文章： &lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;公众号&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07e9fd0521c244adab8556fee99a2011~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;参考与感谢&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&amp;lt;&amp;lt;深入理解Java虚拟机&amp;gt;&amp;gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt; &lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section/&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Mon, 10 Aug 2020 16:47:00 +0000</pubDate>
<dc:creator>Jay_huaxiao</dc:creator>
<og:description>前言 volatile是Java程序员必备的基础，也是面试官非常喜欢问的一个话题，本文跟大家一起开启vlatile学习之旅，如果有不正确的地方，也麻烦大家指出哈，一起相互学习~ 1.volatile的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jay-huaxiao/p/13473197.html</dc:identifier>
</item>
<item>
<title>从零开始,Windows操作系统下的超详细的阿里云发布项目过程 - 荣光无限</title>
<link>http://www.cnblogs.com/leslie1943/p/13472784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leslie1943/p/13472784.html</guid>
<description>&lt;ul&gt;&lt;li&gt;图片小,建议放大浏览器尺寸,不会失真.&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;--步骤0-购买阿里云服务器-&quot;&gt;🚀🚀 ==================== 步骤0: 购买阿里云服务器 ====================&lt;/h4&gt;
&lt;ul readability=&quot;6.8330683624801&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;🎃 0.1 从来没有搞过外网部署的我，当然是先买服务器了，感谢很多小伙伴的帮忙😊&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.51612903225806&quot;&gt;
&lt;p&gt;🎃 0.2 登录 &lt;a href=&quot;https://www.aliyun.com/?utm_content=se_1000301881&quot;&gt;阿里云网址&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810223524997-118471090.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;🎃 0.3 选择 &lt;code&gt;云服务器ECS&lt;/code&gt; (不要选香港的,后期备案容易出问题)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;像我这种没有经验的先买一个月的试玩下,土豪请无视，任意选择👍！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;选择 &lt;code&gt;Ubantu&lt;/code&gt;镜像,社区大，资源多，出现问题比较容易得到解决&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810223626350-415706318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810223736194-940799816.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🎃 0.4 确认下单&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810223954758-1490784059.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🎃 0.5 确认支付&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810224032761-1074487034.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🎃 0.6 扫一扫，你就会损失一些money😭&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810224134822-1407773040.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🎃 0.7 恭喜你，拾取服务器一台😁&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810224142543-1057025421.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🎃 0.8 建议修改实例密码，为本地机器访问(请记住你设置的密码)&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810224413724-1930510676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;--步骤1-开启window的ssh-&quot;&gt;🚀🚀 ==================== 步骤1: 开启window的ssh ====================&lt;/h4&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🚖 1.1 右下角 -&amp;gt; 所有配置&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810224823818-329734493.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🚖 1.2 应用&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810224854552-468834229.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;🚖 1.3 可选功能&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810224951314-1611527247.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🚖 1.4 添加可选功能 &lt;code&gt;OpenSSH客户端&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810225100150-601240755.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🚖 1.5 测试ssh 是否启动成功，命令行 &lt;code&gt;ssh&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810225149177-209822528.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🚖 1.6 用&lt;code&gt;root&lt;/code&gt;账户连接阿里云远程服务器 &lt;code&gt;ssh root@47.114.105.120 -p 22&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;47.114.105.120&lt;/code&gt;是云服务器的外网ip, &lt;code&gt;-p 22 指定端口为22&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;password: &lt;code&gt;🎃 0.8&lt;/code&gt;中设置的密码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ssh root@47.114.105.120 -p 22
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810225735127-919490334.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;哇，登录成功了,好兴奋啊,作为完全没使用过&lt;code&gt;Linux/Ubantu&lt;/code&gt;的小白来说不要太兴奋 😋🙃&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🚖 1.7 使用 &lt;code&gt;ls&lt;/code&gt;命令查看服务器的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我之前发布项目创建过一个文件夹&lt;code&gt;realworld-nuxtjs&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;具体步骤会在下一部分出现&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810225940012-1517743121.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;--步骤2-远程操作服务器上传项目的压缩包-&quot;&gt;🚀🚀 ==================== 步骤2: 远程操作服务器,上传项目的压缩包 ====================&lt;/h4&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;🏳‍🌈 2.1 给服务器创建一个目录,存放要发布项目的资源&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810230441987-1375232275.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🏳‍🌈 2.2 跳转到新建的目录下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810230713554-521548545.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;🏳‍🌈 2.3 准备要发布项目的压缩包(依项目实际情况而定)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;由于现在要发布的是nuxt项目,将这5个文件选中进行压缩打包(压缩后的文件是&lt;code&gt;realworld-nuxtjs.zip&lt;/code&gt;)&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810231005750-1328660946.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;🏳‍🌈2.4 新建一个本地命令窗口,使用&lt;code&gt;scp(secure copy)&lt;/code&gt;上传本地压缩文件到远程服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;scp&lt;/code&gt; = &lt;code&gt;secure copy&lt;/code&gt;：Linux系统或者Ubuntu的安全copy命令&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;这部分操作不是在远程ssh链接&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;而是压缩文件所在的目录&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 将2.3中本地压缩的文件上传到远程服务器
scp .\realworld-nuxtjs.zip root@47.114.105.120:/root/realworld-nuxtjs
# 语法格式 scp filepath\filename account@remote address:root/directory
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810231841886-714954284.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;🏳‍🌈2.5 通过【ssh命令窗口】或者【服务器上的远程连接】查看 上传的文件, 本地打包的文件已经上传到服务器了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810231857098-1599930709.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;--步骤3-服务器上的文件操作和必需的模块安装-&quot;&gt;🚀🚀 ==================== 步骤3: 服务器上的文件操作和必需的模块安装 ====================&lt;/h4&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;以下操作可通过【ssh命令窗口】或者【服务器上的远程连接】&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;操作目录,之前新建的&lt;code&gt;realworld-nuxtjs&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;⚡ 3.1 安装 &lt;code&gt;unzip&lt;/code&gt;模块 =&amp;gt; 解压我们之前上传的&lt;code&gt;zip&lt;/code&gt;文件 &lt;code&gt;apt install unzip&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810232433091-1128822394.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;⚡ 3.2 安装 &lt;code&gt;nodejs&lt;/code&gt;模块 提供项目的依赖环境&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 指定资源模块: setup_12.x代表的是nodejs版本12.x,可根据自己的需要自行修改
curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -
# 安装nodejs
sudo apt-get install nodejs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810233415970-1178218252.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810233431847-1592040061.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;⚡ 3.3 安装 &lt;code&gt;npm&lt;/code&gt;模块 提供项目的模块依赖下载&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 安装 npm 模块
sudo apt install npm
#如果出现问题，执行
sudo apt-get install nodejs-dev node-gyp libssl1.0-dev
# 然后再执行
sudo apt install npm
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 解压资源包
unzip realworld-nuxtjs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810232807543-1696196743.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;⚡ 3.5 安装依赖&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 根据package.json安装项目的相关依赖
npm install 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;⚡ 3.6 运行项目&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;npm run start
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810234158530-129324503.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;成功了!!!&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;--步骤4-ipport-配置项-&quot;&gt;🚀🚀 ==================== 步骤4: IP/PORT 配置项 ====================&lt;/h4&gt;
&lt;ul readability=&quot;6.3372093023256&quot;&gt;&lt;li&gt;
&lt;p&gt;🔰 4.1 IP&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;步骤3中项目启动后的地址是服务器的私有IP &lt;code&gt;http://172.27.110.181:3000/&lt;/code&gt; 不能对外访问&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;需要将自己的公网IP替换后才可以 &lt;code&gt;http://47.114.105.120:3000&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810234440015-1973324439.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;🔰 4.2 端口,&lt;code&gt;3000&lt;/code&gt;端口号是在项目文件里配置的,所以我们要去【本实例安全组】开启&lt;code&gt;3000&lt;/code&gt;端口的使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;【本实例安全组】-&amp;gt; 【配置规则】-&amp;gt; 【手动添加】&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;红框内的是系统自带的, 绿色的是手动添加的端口号为&lt;code&gt;3000&lt;/code&gt;的一条规则&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810234851817-930479166.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.83333333333333&quot;&gt;
&lt;p&gt;到这里,如过没有特殊情况,服务可以被外网访问了 &lt;a href=&quot;http://47.114.105.120:3000&quot;&gt;RealWorld-Nuxt&lt;/a&gt; ✅&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;--步骤5-其他配置项-&quot;&gt;🚀🚀 ==================== 步骤5: 其他配置项 ====================&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;💛 5.1 查看服务器防火墙状态&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 服务器防火墙状态: active-启动 | inactive-关闭
sudo ufw status
# 开启或关闭
sudo ufw enable|disable
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810235606632-2047494558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;💛 5.2 查看端口号状态&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;netstat -anp|grep 3000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2102897/202008/2102897-20200810235904665-72801707.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;💛 5.3 未完待续...&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 10 Aug 2020 16:00:00 +0000</pubDate>
<dc:creator>荣光无限</dc:creator>
<og:description>图片小,建议放大浏览器尺寸,不会失真. &amp;amp;#128640;&amp;amp;#128640; 步骤0: 购买阿里云服务器 &amp;amp;#127875; 0.1 从来没有搞过外网部署的我，当然是先买服务器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leslie1943/p/13472784.html</dc:identifier>
</item>
<item>
<title>Quartz.Net的基础使用方法，多任务执行继续扩展 - 畅饮无绪</title>
<link>http://www.cnblogs.com/cool-net/p/13473062.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cool-net/p/13473062.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;前一篇随笔讲了Quartz多任务的简单实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;这一篇，来简单对前一篇进行一下简单的扩展&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;看了前一篇的代码会发现，每次新增一个任务还要去GetJobs方法里往任务列表新增一个任务&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;有没有一种简单的方法自动往任务列表去添加新增的任务呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;从代码可以发现，所有的任务都必须继承IJob接口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Task_1 : IJob
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、我们定义一个接口IJobBase，继承IJob接口，并且新增一个执行时间间隔的属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Quartz;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; HHF.Quartz
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IJobBase : IJob
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 执行时间间隔(秒)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; seconds { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、使Task_1，Task_2继承IJobBase接口，并实现seconds属性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Task_1 : IJobBase
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; s = &lt;span&gt;5&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; seconds { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; s; } &lt;span&gt;set&lt;/span&gt; { s =&lt;span&gt; value; } }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task Execute(IJobExecutionContext context)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Console.Out.WriteLineAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是任务一，执行时间：{DateTime.Now}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、先准备两个实体对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 任务明细
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TaskDetail
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; IJobDetail job { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; key { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; seconds { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 类明细
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClassDetail
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Type tasktype { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; seconds { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、根据类名获取类对象的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取类对象
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;assembly&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;className&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; GetClassObj(Assembly assembly, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; className)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从程序集中获取指定对象类型;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     Type type =&lt;span&gt; assembly.GetType(className); 
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     Object obj =&lt;span&gt; type.Assembly.CreateInstance(type.ToString());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、获取所有继承IJobBase接口类的方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取所有继承IJob的类
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;ClassDetail&amp;gt;&lt;span&gt; GetIJobTypes()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; res = &lt;span&gt;new&lt;/span&gt; List&amp;lt;ClassDetail&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据反射获取所有继承了IJobBase接口的类&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; types =&lt;span&gt; AppDomain.CurrentDomain.GetAssemblies()
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 .SelectMany(a =&amp;gt; a.GetTypes().Where(t =&amp;gt; t.GetInterfaces().Contains(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IJobBase))))
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;                .ToArray();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (types.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; types.Length; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 类对象&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; GetClassObj(types[i].Assembly, types[i].FullName);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取指定名称的属性，执行间隔时间&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; propertyInfo = types[i].GetProperty(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;seconds&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取属性值&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; value = (&lt;span&gt;int&lt;/span&gt;)propertyInfo.GetValue(obj, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; entity = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassDetail();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             entity.tasktype =&lt;span&gt; types[i];
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             entity.seconds =&lt;span&gt; value;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            res.Add(entity);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;6、生成执行任务集合的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取执行的任务集合
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;TaskDetail&amp;gt;&lt;span&gt; GetJobs()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;TaskDetail&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; types =&lt;span&gt; GetIJobTypes();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (types.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; types.Count; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; item =&lt;span&gt; types[i];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; task = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TaskDetail();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             IJobDetail job = JobBuilder.Create(item.tasktype).WithIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;job&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i).Build();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             task.job =&lt;span&gt; job;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             task.key =&lt;span&gt; key;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             task.seconds =&lt;span&gt; item.seconds;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            list.Add(task);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; list;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;7、再对Run方法进行一点小小的改造&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 任务调度的使用过程
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Task Run()
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建scheduler的引用&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     ISchedulerFactory schedFact = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StdSchedulerFactory();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     IScheduler sched = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; schedFact.GetScheduler();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所有任务集合&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; jobs =&lt;span&gt; TaskCollections.GetJobs();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 申明一个任务与触发器映射的字典集合&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; jobAndTriggerMapping = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;IJobDetail, IReadOnlyCollection&amp;lt;ITrigger&amp;gt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历任务列表&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; job &lt;span&gt;in&lt;/span&gt;&lt;span&gt; jobs)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成只读的触发器集合&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; triggers = &lt;span&gt;new&lt;/span&gt; ReadOnlyCollection&amp;lt;ITrigger&amp;gt;&lt;span&gt;(
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; List&amp;lt;ITrigger&amp;gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    TriggerBuilder.Create()
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         .WithIdentity(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;trigger_&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; job.key)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         .WithSimpleSchedule(x =&amp;gt;&lt;span&gt; x.WithIntervalInSeconds(job.seconds).RepeatForever())
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                        .Build() });
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         jobAndTriggerMapping[job.job] =&lt;span&gt; triggers;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将映射关系包装成制度字典集合&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; readOnlyjobAndTriggerMapping = &lt;span&gt;new&lt;/span&gt; ReadOnlyDictionary&amp;lt;IJobDetail, IReadOnlyCollection&amp;lt;ITrigger&amp;gt;&amp;gt;&lt;span&gt;(jobAndTriggerMapping);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        * 使用trigger规划执行任务job
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        *第二个参数replace：如果为true，则指定的触发器或者任务名称已经存在将会替换，否则将抛出异常
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;await&lt;/span&gt; sched.ScheduleJobs(readOnlyjobAndTriggerMapping, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动 scheduler&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; sched.Start();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;8、我们给任务一设置5秒执行间隔，任务二设置7秒执行间隔，启动看一看效果，正常执行&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1539844/202008/1539844-20200810233951034-855072417.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;9、我们再添加一个Task_3，设置执行间隔为10秒看看效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1539844/202008/1539844-20200810234321888-1948726307.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 以上就是对Quartz一个比较简单的扩展，功能上比较粗糙，也算是一点小总结。后续，比如：可视化执行界面、自定义任务的开关操作等，都是可以作为扩展的内容。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Aug 2020 15:52:00 +0000</pubDate>
<dc:creator>畅饮无绪</dc:creator>
<og:description>前一篇随笔讲了Quartz多任务的简单实现 Quartz.Net的基础使用方法，多任务执行 这一篇，来简单对前一篇进行一下简单的扩展 看了前一篇的代码会发现，每次新增一个任务还要去GetJobs方法里</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cool-net/p/13473062.html</dc:identifier>
</item>
<item>
<title>从一次外卖到对oauth2.0的思考 - 张小云的博客</title>
<link>http://www.cnblogs.com/zhangweicheng/p/13473036.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangweicheng/p/13473036.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;别问oauth1.0哪去了，问就是不好讲。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;  今天下班得早，想吃顿好的，于是就点了一份外卖，过了一会儿，外卖到了，但是在小区大门被堵住了，我亲自远程开门后才能进来，又过了一会，被楼下的门禁堵住了，于是我又得为其开门，拿到晚饭正准备坐下去时，突然又来了电话，出去还得确认两次，四次周折，终于吃到了我的晚饭。吃完之后，我站在阳台，望着窗外，沉思了一会儿，还是决定把这家外卖拉入我的黑名单。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/08/10/EhDQKzCdpLloky2.jpg&quot; alt=&quot;皮一下很开心l&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  此外，我还想到了另一个问题，每次点个外卖都要这样操作，是不是有点太麻烦了，要是我能在大门确认的时候就给外卖小哥一个临时的令牌，这个令牌只能用来开&lt;strong&gt;楼下的门&lt;/strong&gt;和&lt;strong&gt;小区的大门&lt;/strong&gt;，&lt;strong&gt;除此之外没有其他功能，并且几分钟后就过期没用了&lt;/strong&gt;，这样的话我省下的时间至少可以多抠两次脚。&lt;br/&gt;  然而现实并没有这么好的事情，小区不提供这样的操作。但是这个想法却让我想到了一种协议——&lt;strong&gt;oauth2.0&lt;/strong&gt;，我拉完肚子之后想了一想，上面说的这种方式不就是&lt;strong&gt;oauth2.0&lt;/strong&gt;中最常用的&lt;strong&gt;授权码&lt;/strong&gt;方式吗，&lt;strong&gt;通过给临时令牌的方式来让第三方应用访问特定权限的资源&lt;/strong&gt;。小区不提供这种操作， 但是互联网可以。&lt;/p&gt;

&lt;p&gt;  直接说&lt;strong&gt;oauth2.0&lt;/strong&gt;你可能觉得很陌生，但是下面这张图，你一定见过。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/08/10/zdk9Z5MbxjO7FQX.jpg&quot; alt=&quot;小程序授权&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  熟悉吧，这是微信上的小程序，这种用的就是授权码的方式了，那么这种方式的具体流程是咋样的呢？很简单。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;第三方（小程序）在授权服务（微信）上提前进行登记，这是前期工作，拿到属于自己的标识，之后请求的时候需要带上这个标识来表明自己的身份。&lt;/li&gt;
&lt;li&gt;第三方想要用户资源的时候首先要先拿到授权码，再通过授权码和上面的身份ID拿到属于自己的临时令牌，但是授权服务直接给的话可能会被用户投诉，所以就把这个同意操作交给用户自己处理，于是就弹出了上面这个框。&lt;/li&gt;
&lt;li&gt;用户同意之后，授权服务生成授权码，记录对应的信息，接着返回给第三方。&lt;/li&gt;
&lt;li&gt;第三方拿到授权码之后就可以向授权服务申请临时令牌了，授权服务校验通过之后生成令牌并设置权限范围，然后返回。&lt;/li&gt;
&lt;li&gt;之外第三方如果想要从授权服务这边获取用户的信息就得带上这个令牌和自己的身份ID，通过校验并且在权限范围内则返回。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;  就这样，&lt;strong&gt;oauth2.0&lt;/strong&gt;就这样结束了。可能有人会说：&quot;诶，你上面这么多个字看了也全忘光了，就不能整张图出来嘛？&quot;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/08/10/mjg2qp7GHdA5ahl.jpg&quot; alt=&quot;听不懂&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  okay，诺，这是你要的图：&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/08/10/BVMGKcWEsmYNifg.png&quot; alt=&quot;微信小程序授权流程图&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  这张图应该能很清晰的描述整个过程，那么为什么要整得这么复杂呢，整这么多花里胡哨的，简单点不好吗？不好！简单点，我们可能就看不到微信了。我们先来看如果不这么做的话会是怎么样的。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/08/10/EFWan6vTk4oHDGJ.png&quot; alt=&quot;不用oauth2.0的交互方式&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;  你看，这种方式就会损失很多暴躁的用户，所以为了用（&lt;strong&gt;zhuan&lt;/strong&gt;）户（&lt;strong&gt;geng&lt;/strong&gt;）更（&lt;strong&gt;duo&lt;/strong&gt;）方（&lt;strong&gt;de&lt;/strong&gt;）便（&lt;strong&gt;qian&lt;/strong&gt;），必须自己先把麻烦的事情给做了，才能让用户满意。&lt;br/&gt;  退一万步讲，就算用户足够耐心，接受输入账号密码，但是还有一个人肯定不同意，那就是微信，为啥呢？如果微信用户的数据第三方都能知道，那么微信再见，因此微信肯定不会同意让数据泄露的，所以使用&lt;strong&gt;oauth2.0&lt;/strong&gt;=&lt;strong&gt;win-win&lt;/strong&gt;。&lt;br/&gt;  最后&lt;strong&gt;oauth2.0&lt;/strong&gt;还有其他几种方式：&lt;strong&gt;隐藏式&lt;/strong&gt;、&lt;strong&gt;密码式&lt;/strong&gt;和&lt;strong&gt;凭证式&lt;/strong&gt;。前两个是针对没有后端直接将令牌给前端用的，&lt;strong&gt;凭证式的话就是本章的方式中去掉了授权码的形式，这种形式主要是针对应用的&lt;/strong&gt;。就是说，这个应用可以拿到不止一个用户的数据，而且不需要用户同意。有兴趣的话深入的话可以自己去了解一下，不过除了凭证式另外两个基本都很少用。&lt;br/&gt; &lt;br/&gt; &lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/08/10/lV357On1ZMpFmWr.png&quot; alt=&quot;求点赞2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.8032786885246&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhangweicheng/p/13473036.html&quot;&gt;本文为博客园文章，点此跳转&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;nope！nope！nope！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 10 Aug 2020 15:45:00 +0000</pubDate>
<dc:creator>张小云的博客</dc:creator>
<og:description>别问oauth1.0哪去了，问就是不好讲。 1. 外卖并不好吃 今天下班得早，想吃顿好的，于是就点了一份外卖，过了一会儿，外卖到了，但是在小区大门被堵住了，我亲自远程开门后才能进来，又过了一会，被楼下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangweicheng/p/13473036.html</dc:identifier>
</item>
</channel>
</rss>