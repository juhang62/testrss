<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java注解（Annotation）：请不要小看我！ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10505627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10505627.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Java注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;网络上对注解的解释过于严肃、刻板，这并不是&lt;a href=&quot;https://mp.weixin.qq.com/s/feoOINGSyivBO8Z1gaQVOA&quot;&gt;我&lt;/a&gt;喜欢的风格。尽管这样的解释听起来非常的专业。&lt;/p&gt;
&lt;p&gt;为了缓解大家对“注解”的陌生感，我来说点有意思的。其实我对“注解”这个词的第一印象并不是Java的注解，而是朱熹的名作《四书章句集注》。为什么我会有这么大的脑洞呢？因为当我试着去翻译&lt;code&gt;Annotation&lt;/code&gt;这个单词的时候，得到的结果是“注释”而不是“注解”。《四书章句集注》正是朱熹对《大学》、《中庸》、《论语》、《孟子》四书做出的重要的注释。要知道，该书可是明清以后科举考试的题库和标准答案！&lt;/p&gt;
&lt;p&gt;注解（&lt;code&gt;Annotation&lt;/code&gt;）是在 Java SE 5.0 版本中开始引入的概念，同&lt;code&gt;class&lt;/code&gt;和&lt;code&gt;interface&lt;/code&gt;一样，也属于一种类型。很多开发人员认为注解的地位不高，但其实不是这样的。像&lt;code&gt;@Transactional&lt;/code&gt;、&lt;code&gt;@Service&lt;/code&gt;、&lt;code&gt;@RestController&lt;/code&gt;、&lt;code&gt;@RequestMapping&lt;/code&gt;、&lt;code&gt;@CrossOrigin&lt;/code&gt;等等这些注解的使用频率越来越高。&lt;/p&gt;
&lt;h3 id=&quot;h01&quot;&gt;01、为什么要使用注解呢？&lt;/h3&gt;
&lt;p&gt;为什么要使用注解呢？让我们从另外一个问题说起。&lt;/p&gt;
&lt;p&gt;“跨域”这两个字就像一块狗皮膏药黏在每一个前端开发者的身上；我也不例外，虽然我并不是一个纯粹的前端开发者。&lt;/p&gt;
&lt;p&gt;跨域问题的出现，源于浏览器的同源策略——限制一个源加载的脚本去访问另外一个源的资源，可有效地隔离潜在的恶意文件，是一种重要的安全机制。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;跨域问题&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-231c6637863232d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;跨域问题&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跨域问题的解决方案也有很多，比如说：&lt;/p&gt;
&lt;p&gt;1）JSONP&lt;/p&gt;
&lt;p&gt;2）Nginx代理&lt;/p&gt;
&lt;p&gt;3）&quot;跨域资源共享&quot;（Cross-origin resource sharing），简称&lt;code&gt;CORS&lt;/code&gt;，可以说是处理跨域问题的标准做法。&lt;/p&gt;
&lt;p&gt;记得第一次遇到跨域问题的时候，我特意向一个同学请教了解决方案，他告诉我的答案如下。&lt;/p&gt;
&lt;p&gt;第一步，在web.xml添加filter。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;xml language-xml hljs&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter-name&amp;gt;contextfilter&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter-name&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter-class&amp;gt;com.cmower.filter.WebContextFilter&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter-class&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter-mapping&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;filter-name&amp;gt;contextfilter&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter-name&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;url-pattern&amp;gt;/*&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;url-pattern&amp;gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;filter-mapping&amp;gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步，实现WebContextFilter类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;WebContextFilter &lt;span class=&quot;hljs-keyword&quot; readability=&quot;10.5&quot;&gt;implements &lt;span class=&quot;hljs-title&quot; readability=&quot;21&quot;&gt;Filter {&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;destroy&lt;span class=&quot;hljs-params&quot;&gt;() {&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;doFilter&lt;span class=&quot;hljs-params&quot;&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throws IOException, ServletException {&lt;br/&gt;HttpServletResponse  httpServletResponse = (HttpServletResponse) response;&lt;br/&gt;httpServletResponse.setHeader(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Access-Control-Allow-Origin&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;*&quot;);&lt;br/&gt;httpServletResponse.setHeader(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Access-Control-Allow-Headers&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;accept,content-type&quot;); &lt;br/&gt;httpServletResponse.setHeader(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Access-Control-Allow-Methods&quot;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;OPTIONS,GET,POST,DELETE,PUT&quot;); &lt;br/&gt;chain.doFilter(request, httpServletResponse);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;init&lt;span class=&quot;hljs-params&quot;&gt;(FilterConfig arg0) &lt;span class=&quot;hljs-keyword&quot;&gt;throws ServletException {&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这样的解决方案，我真的是蛮崩溃的。不就一个跨域问题嘛，用得着这么多代码吗？&lt;/p&gt;
&lt;p&gt;我对这样的解决方案非常的不满意。于是下定决心要好好的研究一番，大概花了半天的时间吧，我终于搞清楚了“跨域”问题，以及它的标准解决方案&lt;code&gt;CORS&lt;/code&gt;。并且找到了一个极为简洁的解决方案——&lt;code&gt;@CrossOrigin&lt;/code&gt;，只要在Controller类上加上这个注解，就可以轻松地解决跨域问题。&lt;/p&gt;
&lt;p&gt;代码如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RestController&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;course&quot;)&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@CrossOrigin&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;CourseController {&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有找到&lt;code&gt;@CrossOrigin&lt;/code&gt;这个注解，我真的就要按照同学提供的方案去解决跨域的问题了。但那样做就好像，我们卖掉家里的小汽车，然后出行的时候驾一辆马车一样。&lt;/p&gt;
&lt;p&gt;这也正是我想告诉你的，为什么要使用注解的原因：它让我们的代码看起来更简洁，更有时代的进步感。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;02、该如何定义注解呢？&lt;/h3&gt;
&lt;p&gt;注解需要通过&lt;code&gt;@interface&lt;/code&gt;关键字（形式和接口非常的相似，只是前面多了一个&lt;code&gt;@&lt;/code&gt;）进行定义。我们可以打开&lt;code&gt;@CrossOrigin&lt;/code&gt;的源码来看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Target({ ElementType.METHOD, ElementType.TYPE })&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Retention(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Documented&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-meta&quot;&gt;@interface CrossOrigin {&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的代码可以看得出来，“注解”真的很“注解”，除了注释多和“元注解”多之外，真没有别的了。&lt;/p&gt;
&lt;p&gt;“元注解”？什么是“元注解”呢？&lt;/p&gt;
&lt;p&gt;“元注解”是用来注解（动词）注解（名词）的注解（名词）。请感受汉语的博大精深。&lt;code&gt;@Target&lt;/code&gt;、&lt;code&gt;@Retention&lt;/code&gt;和&lt;code&gt;@Documented&lt;/code&gt;就是所谓的元注解。&lt;/p&gt;
&lt;p&gt;1）@Target&lt;/p&gt;
&lt;p&gt;Target是目标的意思，&lt;code&gt;@Target&lt;/code&gt;指定了注解运用的场景。都有哪些场景值呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ElementType.ANNOTATION_TYPE&lt;/code&gt;：可以给注解进行注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ElementType.CONSTRUCTOR&lt;/code&gt;：可以给构造方法进行注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ElementType.FIELD&lt;/code&gt;：可以给字段进行注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ElementType.LOCAL_VARIABLE&lt;/code&gt;：可以给局部变量进行注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ElementType.METHOD&lt;/code&gt;：可以给方法进行注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ElementType.PACKAGE&lt;/code&gt;：可以给包进行注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ElementType.PARAMETER&lt;/code&gt;：可以给方法内的参数进行注解&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ElementType.TYPE&lt;/code&gt;：可以给类型进行注解，比如类、接口和枚举&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2）@Retention&lt;/p&gt;
&lt;p&gt;Retention这个单词的意思为保留期。也就是说，当&lt;code&gt;@Retention&lt;/code&gt;应用到一个注解上的时候，它解释说明了这个注解的存活时间。来看它的取值范围。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;RetentionPolicy.SOURCE&lt;/code&gt;：注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RetentionPolicy.CLASS&lt;/code&gt;：注解只被保留到编译进行的时候，并不会被加载到 JVM 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RetentionPolicy.RUNTIME&lt;/code&gt;：注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3）@Documented&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Documented&lt;/code&gt;就比较容易理解，它和文档有关。作用就是能够将注解中的元素包含到 Javadoc 中。&lt;/p&gt;
&lt;p&gt;当我们了解了元注解的概念后，再回头看一下&lt;code&gt;@CrossOrigin&lt;/code&gt;的源码，是不是感觉清晰多了呢？&lt;/p&gt;
&lt;p&gt;如果能够细致地读一读源码中的注释，你就会看到WebContextFilter类中出现的关键字，诸如&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;、&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;、&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;。也就是说，当我们通过&lt;code&gt;@CrossOrigin&lt;/code&gt;对Controller类注解后，SpringMVC就能够在运行时对这个类自动加上解决跨域问题的过滤器。&lt;/p&gt;
&lt;h3 id=&quot;h03&quot;&gt;03、注解可以反射吗？&lt;/h3&gt;
&lt;p&gt;注解是可以通过反射获取的。&lt;/p&gt;
&lt;p&gt;1）可以通过 Class 对象的 &lt;code&gt;isAnnotationPresent()&lt;/code&gt; 方法判断该类是否应用了某个指定的注解。&lt;/p&gt;
&lt;p&gt;2）通过 &lt;code&gt;getAnnotation()&lt;/code&gt; 方法来获取注解对象。&lt;/p&gt;
&lt;p&gt;3）当获取到注解对象后，就可以获取使用注解时定义的属性值。&lt;/p&gt;
&lt;p&gt;示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@CrossOrigin(origins = &lt;span class=&quot;hljs-string&quot;&gt;&quot;http://qingmiaokeji.com&quot;, allowedHeaders = &lt;span class=&quot;hljs-string&quot;&gt;&quot;accept,content-type&quot;, methods = { RequestMethod.GET, RequestMethod.POST })&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;TestController {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot; readability=&quot;3&quot;&gt;main&lt;span class=&quot;hljs-params&quot; readability=&quot;6&quot;&gt;(String[] args) {&lt;br/&gt;Class c = TestController.class;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (c.isAnnotationPresent(CrossOrigin.class)) {&lt;br/&gt;CrossOrigin crossOrigin = (CrossOrigin) c.getAnnotation(CrossOrigin.class);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;System.out.println(Arrays.asList(crossOrigin.allowedHeaders()));&lt;br/&gt;System.out.println(Arrays.asList(crossOrigin.methods()));&lt;br/&gt;System.out.println(Arrays.asList(crossOrigin.origins()));&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h04&quot;&gt;04、注解经常用在哪里呢？&lt;/h3&gt;
&lt;p&gt;1）&lt;code&gt;@Transactional&lt;/code&gt;：Spring 为事务管理提供的功能支持。&lt;/p&gt;
&lt;p&gt;2）&lt;code&gt;@ Service&lt;/code&gt;：Spring在进行包扫描的时候，会自动将这个类注册到Spring容器中。&lt;/p&gt;
&lt;p&gt;3）&lt;code&gt;@RestController&lt;/code&gt;：是&lt;code&gt;@ResponseBody&lt;/code&gt;和&lt;code&gt;@Controller&lt;/code&gt;的组合注解。&lt;/p&gt;
&lt;p&gt;也就是说，下面这段代码与下下面的代码等同。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RestController&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;1&quot;&gt;class &lt;span class=&quot;hljs-title&quot; readability=&quot;2&quot;&gt;HelloController {&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;)&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;sayHello&lt;span class=&quot;hljs-params&quot;&gt;(){&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Controller&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@ResponseBody&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;1&quot;&gt;class &lt;span class=&quot;hljs-title&quot; readability=&quot;2&quot;&gt;HelloController {&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@RequestMapping(value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;)&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;sayHello&lt;span class=&quot;hljs-params&quot;&gt;(){&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello&quot;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4）&lt;code&gt;@RequestMapping&lt;/code&gt; ：Spring Web 应用程序中最常用到的注解之一，将 HTTP 请求映射到 MVC 和 REST 控制器的处理方法上。&lt;/p&gt;
&lt;p&gt;5）&lt;code&gt;@Select&lt;/code&gt;：MyBatis提供的查询语句注解。示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Select(&lt;span class=&quot;hljs-string&quot;&gt;&quot;select * from city&quot;)&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;List&amp;lt;City&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;getCitys&lt;span class=&quot;hljs-params&quot;&gt;();&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6）还有很多很多，就不再一一列举了。&lt;/p&gt;
&lt;h3 id=&quot;h&quot;&gt;最后&lt;/h3&gt;
&lt;p&gt;我想说的是，注解有许多用处，主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供信息给编译器： 编译器可以利用注解来探测错误和警告信息。&lt;/li&gt;
&lt;li&gt;编译阶段时的处理： 软件工具可以利用注解信息来生成代码、HTML文档。&lt;/li&gt;
&lt;li&gt;运行时的处理： 某些注解可以在程序运行的时候接受代码的提取。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;别忘了：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;四书章句集注&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-da737513d45cd9bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;四书章句集注&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 07:58:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>Java注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。 网络上对注解的解释过于严肃、刻板，这并不是我喜欢的风格。尽管这样的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10505627.html</dc:identifier>
</item>
<item>
<title> [macOS开发.NET Core] 一个简单的WEB程序 - zfCode</title>
<link>http://www.cnblogs.com/zfcode/p/macOS-kai-faNET-Core-yi-ge-jian-dan-deWEB-cheng-xu.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zfcode/p/macOS-kai-faNET-Core-yi-ge-jian-dan-deWEB-cheng-xu.html</guid>
<description>&lt;p&gt;上一篇咱们提到了在macOS下选进行开发。&lt;br/&gt;咱们已经把工具准备完成了。&lt;br/&gt;现在咱们做一个简单的DEMO&lt;/p&gt;
&lt;h2 id=&quot;toc_0&quot;&gt;创建WEB程序&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/807393/201903/807393-20190310155305038-409693875.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;之前咱们已经创建过WEB程序，并且成功的运行过数据&lt;/p&gt;
&lt;p&gt;现在咱们创建一个页面，并显示出来。&lt;/p&gt;
&lt;p&gt;在咱们的系统中，最常见的应该是Grid列表。&lt;/p&gt;
&lt;p&gt;下面咱们创建一个列表界面&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;Grid列表&lt;/h2&gt;
&lt;p&gt;首先创建一个Model&lt;br/&gt;一个简单的用户类，非常简单&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;using System;

namespace WEB._01.Models
{
    public class UserModel
    {
        /// &amp;lt;summary&amp;gt;
        /// ID
        /// &amp;lt;/summary&amp;gt;
        public int UserId { get; set; }
        
        /// &amp;lt;summary&amp;gt;
        /// Name
        /// &amp;lt;/summary&amp;gt;
        public string UserName { get; set; }
        
        /// &amp;lt;summary&amp;gt;
        /// 注册时间
        /// &amp;lt;/summary&amp;gt;
        public DateTime RegDateTime { get; set; }
        
        
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后创建一个UserController&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;using System;
using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;
using WEB._01.Models;

namespace WEB._01.Controllers
{
    public class UserController : Controller
    {
        // GET
        public IActionResult Index()
        {
            var user = new List&amp;lt;UserModel&amp;gt;();

            for (int i = 0; i &amp;lt; 10; i++)
            {
                user.Add(new UserModel()
                {
                    UserId = i,
                    UserName = i+1.ToString()+&quot; name&quot;,
                    RegDateTime = DateTime.Now.AddDays(-i)
                    
                });
            }
            return View(user);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意一点，首先给实体赋值，然后将数据返回给前台。&lt;/p&gt;
&lt;p&gt;然后在Views目录下创建一个User目录，再创建一个View&lt;br/&gt;目录结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/807393/201903/807393-20190310155305106-1830731812.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;然后直接创建Index&lt;br/&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;@model List&amp;lt;UserModel&amp;gt;

@{
    ViewBag.Title = &quot;用户列表&quot;;
    Layout = &quot;_Layout&quot;;
}

&amp;lt;h2&amp;gt;用户列表&amp;lt;/h2&amp;gt;
&amp;lt;div class=&quot;panel panel-default todo-panel&quot;&amp;gt;
    &amp;lt;div class=&quot;panel-heading&quot;&amp;gt;@ViewData[&quot;Title&quot;]&amp;lt;/div&amp;gt;

    &amp;lt;table class=&quot;table table-hover&quot;&amp;gt;
        &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;用户ID&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;用户名&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;注册时间&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;/thead&amp;gt;

        @foreach (var item in Model)
        {
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;@item.UserId&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;@item.UserName&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;@item.RegDateTime&amp;lt;/td&amp;gt;

            &amp;lt;/tr&amp;gt;
        }
    &amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个Table，并生成数据。&lt;/p&gt;
&lt;p&gt;ok，最后一步加入到导航条中。&lt;/p&gt;
&lt;p&gt;在Views&amp;gt;Share目录下&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/807393/201903/807393-20190310155305267-29712266.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;加入导航栏中。&lt;/p&gt;
&lt;p&gt;OK。咱们运行起来看一下效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/807393/201903/807393-20190310155305132-367564354.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;点击咱们加入的新功能【用户列表】&lt;/p&gt;
&lt;p&gt;效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/807393/201903/807393-20190310155305313-1622930100.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;至此，咱们新功能完成了。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 07:53:00 +0000</pubDate>
<dc:creator>zfCode</dc:creator>
<og:description>上一篇咱们提到了在macOS下选进行开发。咱们已经把工具准备完成了。现在咱们做一个简单的DEMO创建WEB程序￼之前咱们已经创建过WEB程序，并且成功的运行过数据现在咱们创建一个页面，并显示出来。在咱</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zfcode/p/macOS-kai-faNET-Core-yi-ge-jian-dan-deWEB-cheng-xu.html</dc:identifier>
</item>
<item>
<title>Vue图片懒加载插件 - 辛月</title>
<link>http://www.cnblogs.com/chenwenhao/p/10505387.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenwenhao/p/10505387.html</guid>
<description>&lt;p&gt;图片懒加载是一个很常用的功能，特别是一些电商平台，这对性能优化至关重要。今天就用vue来实现一个图片懒加载的插件。 这篇博客采用“三步走”战略——Vue.use()、Vue.direction、Vue图片懒加载插件实现，逐步实现一个Vue的图片懒加载插件。&lt;/p&gt;
&lt;h3 id=&quot;vue.use&quot;&gt;Vue.use()&lt;/h3&gt;
&lt;p&gt;就像开发jQuery插件要用$.fn.extent()一样，开发Vue插件我们要用Vue.use()。其实就是官方内部实现的一个方法，供广大开发者灵活开发属于自己的插件。只需要按照约定好的规则开发就行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;用法&lt;/strong&gt;&lt;br/&gt;安装 Vue.js 插件。如果插件是一个对象，必须提供 install 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。&lt;br/&gt;该方法需要在调用 new Vue() 之前被调用。&lt;br/&gt;当 install 方法被同一个插件多次调用，插件将只会被安装一次。&lt;br/&gt;注：install方法或者被当做install方法的方法&lt;strong&gt;它的第一个参数是 Vue 构造器&lt;/strong&gt;，第二个参数是一个可选的选项对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考链接：&lt;br/&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/api/#Vue-use&quot; class=&quot;uri&quot;&gt;https://cn.vuejs.org/v2/api/#Vue-use&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000012296163&quot; class=&quot;uri&quot;&gt;https://segmentfault.com/a/1190000012296163&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;vue.direction自定义指令&quot;&gt;Vue.direction自定义指令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;用法&lt;/strong&gt;——全局注册和局部注册&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;全局注册&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;局部注册&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;钩子函数&lt;/strong&gt;&lt;br/&gt;一个指令定义对象可以提供如下几个钩子函数 (均为可选)：&lt;br/&gt;bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。&lt;br/&gt;inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。&lt;br/&gt;update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。&lt;br/&gt;componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。&lt;br/&gt;unbind：只调用一次，指令与元素解绑时调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;钩子函数的参数&lt;/strong&gt;&lt;br/&gt;el：指令所绑定的元素，可以用来直接操作 DOM 。&lt;br/&gt;binding：一个对象，包含以下属性：&lt;br/&gt;name：指令名，不包括 v- 前缀。&lt;br/&gt;value：指令的绑定值，例如：v-my-directive=&quot;1 + 1&quot; 中，绑定值为 2。&lt;br/&gt;oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。&lt;br/&gt;expression：字符串形式的指令表达式。例如 v-my-directive=&quot;1 + 1&quot; 中，表达式为 &quot;1 + 1&quot;。&lt;br/&gt;arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &quot;foo&quot;。&lt;br/&gt;modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。&lt;br/&gt;vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。&lt;br/&gt;oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;br/&gt;&lt;a href=&quot;https://cn.vuejs.org/v2/guide/custom-directive.html&quot; class=&quot;uri&quot;&gt;https://cn.vuejs.org/v2/guide/custom-directive.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;vue图片懒加载插件实现&quot;&gt;Vue图片懒加载插件实现&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;：事先提供俩个空数组listenList（收集未加载的图片元素和资源）和imageCacheList（收集已加载的图片资源）。然后，判断图片是否到达可视区，如果到达，则用Image对象去加载资源图片，加载完毕后赋值给绑定元素的src让其显示。同时，将加载过的资源放入imageCacheList数组，用isAlredyLoad方法做个判断，防止之后相同的资源重复加载。如果没到达，则将元素和资源对象放到listenList数组，最后进行滚动监听。监听listenList数组中的元素是否可以加载资源。&lt;/p&gt;
&lt;p&gt;插件的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 引入Vue构造函数
import Vue from 'vue'

var lazyload = {
  // Vue.use() 默认加载install,并且将Vue当做第一个参数传递过来
  install(vue,payload) {
    // 数组扩展移除元素
    if(!Array.prototype.remove){
      Array.prototype.remove = function(item){
        if(!this.length) return
          var index = this.indexOf(item);
        if( index &amp;gt; -1){
          this.splice(index,1);
          return this
        }
      }
    }

    // 默认值图片 
    var defaultImage = payload.defaultImage || 'https://gw.alicdn.com/tps/i1/TB147JCLFXXXXc1XVXXxGsw1VXX-112-168.png';
    var errorImage = payload.errorImage || 'https://gw.alicdn.com/tps/i1/TB147JCLFXXXXc1XVXXxGsw1VXX-112-168.png';
    // 默认离可视区10px时加载图片
    var distanece = payload.scrollDistance || 10;
    // 收集未加载的图片元素和资源
    var listenList = [];
    // 收集已加载的图片元素和资源
    var imageCacheList = [];

    // 是否已经加载完成的图片
    const isAlredyLoad = (imageSrc) =&amp;gt; {
      if(imageCacheList.indexOf(imageSrc) &amp;gt; -1){
        return true;
      }else{
        return false;
      }
    }

    //检测图片是否可以加载，如果可以则进行加载
    const isCanShow = (item) =&amp;gt;{
      var ele = item.ele;
      var src = item.src;
      //图片距离页面顶部的距离
      var top = ele.getBoundingClientRect().top;
      //页面可视区域的高度
      var windowHeight = window.innerHight;
      // top - distance 距离可视区域还有distance像素
      if(top - distanece &amp;lt; window.innerHeight){ 
        var image = new Image();
        image.src = src;
        image.onload = function() {
          ele.src = src;
          imageCacheList.push(src);
          listenList.remove(item);
        }
        image.onerror = function() {
          ele.src = errorImage;
          imageCacheList.push(src);
          listenList.remove(item);
        }
        return true;
      }else{
        return false;
      }
    };

    const onListenScroll = () =&amp;gt; {
      window.addEventListener('scroll',function(){
        var length = listenList.length;
        for(let i = 0;i&amp;lt;length;i++ ){
          isCanShow(listenList[i]);
        }
      })

    }

    //Vue 指令最终的方法
    const addListener = (ele,binding) =&amp;gt;{
      //绑定的图片地址
      var imageSrc = binding.value;

      // 防止重复加载。如果已经加载过，则无需重新加载，直接将src赋值
      if(isAlredyLoad(imageSrc)){  
        ele.src = imageSrc;
        return false;
      }

      var item = {
        ele: ele,
        src: imageSrc
      }

      //图片显示默认的图片
      ele.src = defaultImage;

      //再看看是否可以显示此图片
      if(isCanShow(item)){
        return
      }

      //否则将图片地址和元素均放入监听的lisenList里
      listenList.push(item);
      
      //然后开始监听页面scroll事件
      onListenScroll();
    }

    Vue.directive('lazyload',{
      inserted: addListener,
      updated: addListener
    })
  }
}

export default lazyload;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插件的调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import Vue from 'vue'
import App from './App'
import router from './router'
import Lazyload from './common/js/lazyload'

// 参数均为可选
Vue.use(Lazyload,{
  scrollDistance: 15,  // 距离可视区还有15px时开发加载资源
  defaultImage: '',  // 资源图片未加载前的默认图片（绝对路径）
  errorImage:''  // 资源图片加载失败时要加载的资源（绝对路径）
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考链接：&lt;br/&gt;&lt;a href=&quot;http://www.cnblogs.com/mdengcc/p/6773672.html&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/mdengcc/p/6773672.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 07:50:00 +0000</pubDate>
<dc:creator>辛月</dc:creator>
<og:description>图片懒加载是一个很常用的功能，特别是一些电商平台，这对性能优化至关重要。今天就用vue来实现一个图片懒加载的插件。 这篇博客采用“三步走”战略——Vue.use()、Vue.direction、Vue</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenwenhao/p/10505387.html</dc:identifier>
</item>
<item>
<title>ASP.NET MVC , ASP.NET Web API 的路由系统与 ASP.NET 的路由系统是怎么衔接的? - 热敷哥</title>
<link>http://www.cnblogs.com/refuge/p/10505565.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refuge/p/10505565.html</guid>
<description>&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201903/1189148-20190310131826669-1703206326.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt; 在拦截时,它做了这么几件事(部分源码省略):&lt;/p&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    public virtual void&lt;span&gt; PostResolveRequestCache(HttpContextBase context)
    {
      RouteData routeData = this&lt;span&gt;.RouteCollection.GetRouteData(context);     &lt;span&gt;
      IRouteHandler routeHandler =&lt;span&gt; routeData.RouteHandler;&lt;span&gt;
      IHttpHandler httpHandler =&lt;span&gt; routeHandler.GetHttpHandler(requestContext);
&lt;span&gt;      context.RemapHandler(httpHandler);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;1.遍历所有注册的路由,也就是所有添加到全局路由表中的 Route 类型的实例,通过调用它们的 GetRouteData 方法,拿到第一个匹配的 RouteData (路由数据);&lt;/p&gt;
&lt;p&gt;2.拿到路由数据中的 RouteHandler 对象, 其实就是 MvcRouteHandler 类型的实例;&lt;/p&gt;
&lt;p&gt;3.调用 MvcRouteHandler 的 GetHttpHandler 方法,拿到 HttpHandler.&lt;/p&gt;
&lt;p&gt;MvcRouteHandler 的 GetHttpHandler 方法源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    protected virtual&lt;span&gt; IHttpHandler GetHttpHandler(RequestContext requestContext)
    {
      requestContext.HttpContext.SetSessionStateBehavior(this&lt;span&gt;.GetSessionStateBehavior(requestContext));
      return (IHttpHandler) new&lt;span&gt; MvcHandler(requestContext);
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到,直接 new 了一个 MvcHandler 类型的实例,&lt;/p&gt;
&lt;p&gt;最终,请求转交给这个 MvcHandler 类型的实例处理.&lt;/p&gt;


&lt;p&gt;我们知道, ASP.NET 的路由系统对路由的解析是通过一个注册的 HttpModule 对象实现对请求的拦截,然后为当前 Http 上下文动态映射一个 HttpHandler 对象, 而这个  HttpHandler 对象会接管对当前请求的处理并最终对请求予以响应.&lt;/p&gt;
&lt;p&gt;这一条不仅对 MVC 适用, 对 Web API 同样适用,因为他俩都是借助于 ASP.NET 的路由系统.&lt;/p&gt;
&lt;p&gt;区别在于 HttpHandler 的类型不一样而已.&lt;/p&gt;
&lt;p&gt;ASP.NET Web API 注册路由的代码通常是这样的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            config.Routes.MapHttpRoute(
                name: &quot;DefaultApi&quot;&lt;span&gt;,
                routeTemplate: &quot;api/{controller}/{id}&quot;&lt;span&gt;,
                defaults: new&lt;span&gt;
                {
                    id =&lt;span&gt; RouteParameter.Optional
                }
            );&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;config.Routes 是一个 HttpRouteCollection 类型的实例,并且是只读的.&lt;/p&gt;
&lt;p&gt;只读的,就意味着只能在该实例所属的类的构造函数中初始化.&lt;/p&gt;
&lt;p&gt;我们知道,这个 config 是 HttpConfiguration 类型,它在 GlobalConfiguration 类中初始化.&lt;/p&gt;
&lt;p&gt;在它的初始化代码中,我们可以看到:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        private static Lazy&amp;lt;HttpConfiguration&amp;gt;&lt;span&gt; CreateConfiguration()
        {
            return new Lazy&amp;lt;HttpConfiguration&amp;gt;(() =&amp;gt;&lt;span&gt;
            {
                HttpConfiguration config = new HttpConfiguration(new&lt;span&gt; HostedHttpRouteCollection(RouteTable.Routes));
　　　　　　　　　　......return&lt;span&gt; config;
            });
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;HttpConfiguration 实际是对 HostedHttpRouteCollection 的封装,而后者是对 RouteTable.Route 的封装. 即 ASP.NET 全局路由表的封装.&lt;/p&gt;
&lt;p&gt;所以说, HttpConfiguration 类型封装了 ASP.NET 的全局路由表. 它的 Routes 属性的实际类型是  HostedHttpRouteCollection&lt;/p&gt;
&lt;p&gt;我们再回头看 config.Routes.MapHttpRoute 方法 , 也就是 HostedHttpRouteCollection 类型的 MapHttpRoute 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
        public static IHttpRoute MapHttpRoute(this HttpRouteCollection routes, string name, string routeTemplate, object defaults, object&lt;span&gt; constraints, HttpMessageHandler handler)
        {
            ......&lt;span&gt;
            IHttpRoute route = routes.CreateRoute(routeTemplate, defaultsDictionary, constraintsDictionary, dataTokens: null&lt;span&gt;, handler: handler);
            routes.Add(name, route);
            return&lt;span&gt; route;
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很简单,创建了一个路由,然后添加它.&lt;/p&gt;
&lt;p&gt;我们继续查看 HostedHttpRouteCollection 类型的 CreateRoute 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    public override IHttpRoute CreateRoute(string uriTemplate, IDictionary&amp;lt;string, object&amp;gt; defaults, IDictionary&amp;lt;string, object&amp;gt; constraints, IDictionary&amp;lt;string, object&amp;gt;&lt;span&gt; dataTokens, HttpMessageHandler handler)
    {
　　　　......&lt;br/&gt;　　　　return (IHttpRoute) new&lt;span&gt; HostedHttpRoute(uriTemplate, defaults, constraints, dataTokens, handler);
    }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回了一个 HostedHttpRoute 类型的实例.&lt;/p&gt;
&lt;p&gt;我们可以把这个方法 和 上面 MVC 的 MapRoute 方法做比较:&lt;/p&gt;
&lt;p&gt;MVC:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
    public static Route MapRoute(this RouteCollection routes, string name, string url, object defaults, object constraints, string&lt;span&gt;[] namespaces)
    {
      ......
      Route route = new Route(url, (IRouteHandler) new&lt;span&gt; MvcRouteHandler())
      {
　　　　......
      };
　　　 ......
      routes.Add(name, (RouteBase) route);
      return&lt;span&gt; route;
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;是不是非常像!不同的只是 MVC  new 的路由对象是 Route 类型,而 Web API new 的路由对象是 HostedHttpRoute 类型.&lt;/p&gt;
&lt;p&gt;讲到这里,其实 ASP.NET Web API 的路由系统还没有和 ASP.NET 的路由系统衔接起来,它们二者的关系仅仅体现在下面这句话:&lt;/p&gt;
&lt;p&gt;HttpConfiguration 实际是对 HostedHttpRouteCollection 的封装,而后者是对 RouteTable.Route 的封装. 即 ASP.NET 全局路由表的封装.&lt;/p&gt;
&lt;p&gt;但是,当 HostedHttpRoute 创建后,调用 HostedHttpRouteCollection 的 Add 方法添加时,衔接就真正开始了:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        public override void Add(string&lt;span&gt; name, IHttpRoute route)
        {
            _routeCollection.Add(name, route.ToRoute());
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;p&gt; _routeCollection 是 RouteCollection 类型,没看错,就是 ASP.NET 路由系统的 RouteCollection .&lt;/p&gt;
&lt;p&gt;所以,这句代码实际是向 ASP.NET 路由系统的路由集合中添加路由,目的就是为了让 UrlRoutingModule 能够拦截到匹配了 Web API 注册的路由的请求.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是,问题来了,从上面 MVC 的讲解中我们知道, ASP.NET 路由系统的 RouteCollection 是一个继承自 Collection&amp;lt;RouteBase&amp;gt; 的子类, RouteBase 是 ASP.NET 路由的基类,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而 HostedHttpRoute 是实现了 IHttpRoute 接口的实例, &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;IHttpRoute  和 RouteBase 风马牛不相接啊!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以,添加时,Web API 通过 HostedHttpRoute  的 ToRoute 方法,将自己转成了 RouteBase 类型!!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个转化非常简单:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
 public static Route ToRoute(this&lt;span&gt; IHttpRoute httpRoute)
        {&lt;br/&gt;　　　　　　　......&lt;span&gt;
            HostedHttpRoute hostedHttpRoute = httpRoute as&lt;span&gt; HostedHttpRoute;
            if (hostedHttpRoute != null&lt;span&gt;)
            {
                return&lt;span&gt; hostedHttpRoute.OriginalRoute;
            }&lt;br/&gt;　　　　　　  ......&lt;span&gt;
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题又来了, HostedHttpRoute 类型的 OriginalRoute 是个什么鬼?当然,肯定是个 Route  类型,也就是说,它是一个 ASP.NET 路由系统定义的 Route 类型.那它是怎么来的呢?&lt;/p&gt;
&lt;p&gt;我们知道,在 Web API 注册路由时, MapHttpRoute 内部创建了一个 HostedHttpRoute 类型的实例,并且是直接 new 的.&lt;/p&gt;
&lt;p&gt;那么我们去看看 HostedHttpRoute 的构造函数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
        public HostedHttpRoute(string uriTemplate, IDictionary&amp;lt;string, object&amp;gt; defaults, IDictionary&amp;lt;string, object&amp;gt; constraints, IDictionary&amp;lt;string, object&amp;gt;&lt;span&gt; dataTokens, HttpMessageHandler handler)
        {
            ......&lt;span&gt;
            OriginalRoute = new HttpWebRoute(uriTemplate, routeDefaults, routeConstraints, routeDataTokens, HttpControllerRouteHandler.Instance, this&lt;span&gt;);
            ......&lt;span&gt;
        }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OriginalRoute 原来是一个 HttpWebRoute 类型,而 HttpWebRoute 则是 ASP.NET 路由系统定义的 Route 类型的子类.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201903/1189148-20190310152653114-384999441.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且,创建 HttpWebRoute 类型的实例时,传入了一个 ASP.NET 路由系统定义的 IRouteHandler 类型的实例 : HttpControllerRouteHandler.Instance&lt;/p&gt;
&lt;p&gt;而 HttpControllerRouteHandler 的 GetHttpHandler 方法如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        /// &amp;lt;summary&amp;gt;
        /// Provides the object that processes the request.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;requestContext&quot;&amp;gt;An object that encapsulates information about the request.&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;
        /// An object that processes the request.
        /// &amp;lt;/returns&amp;gt;
        protected virtual&lt;span&gt; IHttpHandler GetHttpHandler(RequestContext requestContext)
        {
            return new&lt;span&gt; HttpControllerHandler(requestContext.RouteData);
        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回了一个 HttpControllerHandler 类型的实例.&lt;/p&gt;
&lt;p&gt;HttpControllerHandler 类型的XML注释则非常清晰的解释了它的作用:&lt;/p&gt;
&lt;p&gt;  /// 用于将 ASP.NET 请求传递给管道并写回结果。&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;这里说的管道,自然就是 Web API 的消息处理管道了.&lt;/p&gt;

&lt;p&gt;总结:&lt;/p&gt;
&lt;p&gt;ASP.NET MVC 和 ASP.NET Web API 都是通过 UrlRoutingModule ,在 PostResolveRequestCache 事件实现对请求的拦截.&lt;/p&gt;
&lt;p&gt;拦截后,通过对HTTP上下文,路由等一系列处理后,&lt;/p&gt;
&lt;p&gt;MVC 创建了 MvcHandler 进行具体的请求处理及响应;&lt;/p&gt;
&lt;p&gt;Web API 创建了 HttpControllerHandler 进行具体的请求处理及响应.&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 07:47:00 +0000</pubDate>
<dc:creator>热敷哥</dc:creator>
<og:description>ASP.NET MVC 的路由实际上是建立在 ASP.NET 的路由系统之上的. MVC 路由注册通常是这样的: RouteTable 是一个全局路由表, 它的 Routes 静态属性是一个 </og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refuge/p/10505565.html</dc:identifier>
</item>
<item>
<title>浅谈Git - 绿水青山蓝天白云</title>
<link>http://www.cnblogs.com/cd123/p/10505544.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cd123/p/10505544.html</guid>
<description>&lt;p&gt;我们在学习过程中，经常接触到Git,这是我记录一下Git的相关知识，便于自己关于Git的深入学习，进一步提升自己。&lt;/p&gt;
&lt;p&gt;谈到Git，首先我们应该知道什么是版本控制，因为&lt;/p&gt;
&lt;p&gt;版本控制：&lt;/p&gt;
&lt;p&gt;在Git(https://git-scm.com/)官网上说：版本控制是一种记录文件或文件集随时间变化的系统，以便您以后可以调用特定版本。简单来说，就是可以记录我们每次做出的修改和增删，便于我们自己查询对开发的版本进行的操作，根据版本控制的使用场合又可以分为：&lt;/p&gt;
&lt;p&gt;本地版本控制系统(VCS)和集中版本控制系统(CVCS)和分布式版本控制系统(DVCS）：&lt;/p&gt;
&lt;p&gt;本地版本控制系统:它有一个简单的数据库，可以对文件的所有更改进行修订控制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611178/201903/1611178-20190310152809354-1847135489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;集中版本控制系统:主要是用于团队协作开发，因为本地版本控制系统无法满足人们日常的工作需要，现在的软件开发几乎都是团队协作，便于大家各自独立完场相应工作的实现，对版本的进行迭代，开发了集中式版本控制系统。其&lt;span&gt;具有包含所有版本化文件的单个服务器，以及从该中心位置检出文件的许多客户端。&lt;/span&gt;&lt;span&gt;多年来，这一直是版本控制的标准。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1611178/201903/1611178-20190310153408662-1124221346.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;便于项目中的成员知道其他人在干什么，知道软件开发的进度。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是，集中版本控制系统也有一些严重的缺点。&lt;/span&gt;&lt;span&gt;最明显的是集中式服务器所代表的单点故障。&lt;/span&gt;&lt;span&gt;如果该服务器停机一小时，那么在那个小时内，任何人都无法进行协作或将版本化更改保存到他们正在处理的任何内容中。&lt;/span&gt;&lt;span&gt;如果中央数据库所在的硬盘损坏，并且没有保留适当的备份，那么您绝对会丢失所有内容 - 项目的整个历史记录，除了人们碰巧在本地计算机上发生的任何单个快照。&lt;/span&gt;&lt;span&gt;本地VCS系统也遇到同样的问题 - 只要您将项目的整个历史记录放在一个地方，就有可能失去一切&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;分布式版本控制系统:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分布式版本控制系统（DVCS）的出现，解决了这个问题，在DVCS中，&lt;span&gt;客户端不只是查看文件的最新快照; &lt;/span&gt;&lt;span&gt;相反，它们完全镜像了存储库，包括其完整的历史记录。&lt;/span&gt;&lt;span&gt;因此，如果任何服务器死亡，并且这些系统通过该服务器进行协作，则可以将任何客户端存​​储库复制回服务器以还原它。&lt;/span&gt;&lt;span&gt;每个克隆都是所有数据的完整备份。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1611178/201903/1611178-20190310154056232-617150834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这主要是Git的分类，接下来，我还将继续记录Git的学习。&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 07:43:00 +0000</pubDate>
<dc:creator>绿水青山蓝天白云</dc:creator>
<og:description>我们在学习过程中，经常接触到Git,这是我记录一下Git的相关知识，便于自己关于Git的深入学习，进一步提升自己。 谈到Git，首先我们应该知道什么是版本控制，因为 版本控制： 在Git(https:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cd123/p/10505544.html</dc:identifier>
</item>
<item>
<title>.NET Core 微服务之grpc 初体验（干货） - 孙悟猪</title>
<link>http://www.cnblogs.com/DanielYao/p/10505392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DanielYao/p/10505392.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　Grpc介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GitHub： https://github.com/grpc/grpc&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。gRPC提供了一种简单的方法来精确地定义服务和为iOS、Android和后台支持服务自动生成可靠性很强的客户端功能库。客户端充分利用高级流和链接功能，从而有助于节省带宽、降低的TCP链接次数、节省CPU使用、和电池寿命。&lt;/p&gt;
&lt;p&gt;gRPC支持多种语言，并能够基于语言自动生成客户端和服务端功能库。目前，在GitHub上已提供了C版本grpc、Java版本grpc-java 和 Go版本grpc-go，其它语言的版本正在积极开发中，其中 grpc支持C、C++、Node.js、Python、Ruby、Objective-C、PHP和C#等语言，grpc-java已经支持Android开发。&lt;/p&gt;
&lt;p&gt;gRPC已经应用在Google的云服务和对外提供的API中，其主要应用场景如下：&lt;/p&gt;
&lt;p&gt;低延迟、高扩展性、分布式的系统&lt;br/&gt;同云服务器进行通信的移动应用客户端&lt;br/&gt;&lt;span&gt;设计语言独立、高效、精确的新协议&lt;/span&gt;&lt;br/&gt;&lt;span&gt;便于各方面扩展的分层设计，如认证、负载均衡、日志记录、监控等&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上边是官方腔调介绍，总结下来就几点，跨平台，可靠，通信快，扩展性强，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 貌似现在还出了个前端的grcp-web，.proto 来定义客户端 Web 应用程序和后端 gRPC 服务器之间的服务“契约”，并自动生成客户端 JavaScript 与服务端同行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 毕竟google出品，不多说，🐮🍺。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 是骡子是马拉出来溜溜&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;.NET core&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;编写跨语言服务文件(.proto) &lt;/p&gt;
&lt;p&gt;具体语法可以谷歌或者百度一下，主要方法的定义有点不一样，但是基本就是我下面这样定义，数据类型都是一样的。大差不差&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
syntax =&quot;proto3&quot;&lt;span&gt;;

option java_multiple_files &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
option java_package &lt;/span&gt;= &quot;md.logservice&quot;&lt;span&gt;;
option java_outer_classname &lt;/span&gt;= &quot;Logger&quot;&lt;span&gt;;
option objc_class_prefix &lt;/span&gt;= &quot;LLL&quot;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;package&lt;/span&gt;&lt;span&gt; gRPCTest;
  

service gRPC {  
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    *方法
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    rpc SayHello (TestRequest) returns(TestReply) {}  
}  
   
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
*请求对象
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
message TestRequest {  
    string name &lt;/span&gt;= 1&lt;span&gt;;
}  
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
*返回对象
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
message TestReply {  
    string message &lt;/span&gt;= 1&lt;span&gt;;
}  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编写成功后，接下来咱们就要把proto文件生成为C#代码了&lt;/p&gt;
&lt;p&gt;先创建一个控制台项目&lt;/p&gt;
&lt;p&gt;通过NuGet应用如下文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033808/201903/1033808-20190310133015259-926251824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033808/201903/1033808-20190310133020501-973574097.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这时开始用到了tools, 这个tools就是个解析grpc proto文件的工具，在nuget下载类库时会自动下载带目录下&lt;/p&gt;
&lt;p&gt;建议新建一个文件夹专门用了处理proto文件。这里只说windows下怎么解析proto文件。解析proto会自动生成Markdown接口文档，很方便有木有&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033808/201903/1033808-20190310140918047-364165927.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里说一下generate.bat批处理文件怎么写&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;setlocal

@rem enter &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; directory
cd &lt;/span&gt;/d %~&lt;span&gt;dp0

set TOOLS_PATH&lt;/span&gt;=D:\grpcTest\Tools\Grpc.Tools.1.2.0&lt;span&gt;\tools\windows_x64
set DOC_TOOL_PATH&lt;/span&gt;=&lt;span&gt;D:\grpcTest\Tools\doc

&lt;/span&gt;%TOOLS_PATH%\protoc.exe -I./protos --csharp_out build ./protos/test.proto --grpc_out build --plugin=protoc-gen-grpc=%TOOLS_PATH%&lt;span&gt;\grpc_csharp_plugin.exe



&lt;/span&gt;%TOOLS_PATH%\protoc.exe -I./protos --plugin=protoc-gen-doc=%DOC_TOOL_PATH%\protoc-gen-doc.exe --doc_out=markdown,test.md:./doc protos/&lt;span&gt;test.proto

endlocal
PAUSE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其实这就是一个批处理命令，但是网上很多资料复制都是报错，运行时候各种报错，神特么烦，也不跟你细说选项作用，注意事项。&lt;/p&gt;
&lt;p&gt; 下面咱们就详细说说&lt;/p&gt;
&lt;p&gt;　　　　　A、set TOOLS_PATH=D:\grpcTest\Tools\Grpc.Tools.1.2.0\tools\windows_x64 就是设置tools解析工具所在目录，下面一个set时设置接口文档生成目录，如果不需要生成grpc文档，可不写&lt;/p&gt;
&lt;p&gt;　　　　　B、 -I 指定一个或者多个目录，用来搜索.proto文件的。注意：如果不指定，那就是当前目录，没毛病。&lt;/p&gt;
&lt;p&gt;　　　　　C、--csharp_out 生成C#代码，当然了还能cpp_out、java_out、javanano_out、js_out、objc_out、php_out、python_out、ruby_out 这时候你就应该知道，这玩意就是支持多语言的，才用的，生成一些文件，然后给各个语言平台调用。参数1是输出路径，参数2是proto的文件名或者路径。 &lt;/p&gt;
&lt;p&gt;　　　　　D、--grpc_out 到这里可能有人会懵逼，咋回事？C#不是有一个自己的输出目录么？怎么又一个输出？  &lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　csharp_out是输出类似于咱们平时写的实体类，接口，定义之类的。生成的文件叫，额，就叫xxx.cs吧.&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　grpc_out是跟服务相关，创建，调用，绑定，实现相关。生成的玩意叫xxxGrpc.cs。 对比上个选项生成的文件名，大概能了解个十之八九吧。&lt;/p&gt;
&lt;p&gt;　　　　　E、--plugin=protoc-gen-grpc=grpc_csharp_plugin.exe 这个就是csharp的插件，python有python的，java有java的。你不指定它，你毛都生成不了。&lt;/p&gt;

&lt;p&gt;接下来咱们直接上代码了&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码挺简单的，简单到我不好意思贴代码，直接上图吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说下需要注意的两个点，就是客户端和服务端都需要引用生成的grpc文件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务端代&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033808/201903/1033808-20190310145706960-1609783803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;客户端代码&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033808/201903/1033808-20190310145815113-898257241.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;先启动服务端，然后启动客户端 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行成功后如下图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033808/201903/1033808-20190310145930713-920496402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 客户端&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1033808/201903/1033808-20190310150113671-1227971897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 可以看到，已经调用成功了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;结束&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对了，我司基本上都是用.net core 微服务了，和其他部门都是通过微发rpc形式合作，后面视情况，可以把，微服务docker部署 本地运行k8s，服务治理，kafka日志收集等都分享给大家, 咱们的.net core 氛围越来越好了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感谢各位老铁能看到最后，谢谢 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;拜拜~~~（无彩蛋）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1033808/201903/1033808-20190310150524453-1654086094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 10 Mar 2019 07:12:00 +0000</pubDate>
<dc:creator>孙悟猪</dc:creator>
<og:description>Grpc介绍 GitHub： https://github.com/grpc/grpc gRPC是一个高性能、通用的开源RPC框架，其由Google主要面向移动应用开发并基于HTTP/2协议</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DanielYao/p/10505392.html</dc:identifier>
</item>
<item>
<title>【awesome-dotnet-core-learning】(1)-Sprache-解析器构建库 - WAKU</title>
<link>http://www.cnblogs.com/waku/p/10505196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/waku/p/10505196.html</guid>
<description>&lt;h2 id=&quot;关于awesome-dotnet-core-learning&quot;&gt;关于awesome-dotnet-core-learning&lt;/h2&gt;
&lt;p&gt;.NET Core从2016年发布1.0以来,至今已经3岁了,可以说现在的.NET Core的生态已经相当完善了,可满足各行业的生产要求.如果你还在怀疑.NET Core的实用性质,是时候转变想法了.&lt;/p&gt;
&lt;p&gt;在GITHUB上有一个项目:&lt;a href=&quot;https://github.com/thangchung/awesome-dotnet-core&quot;&gt;awesome-dotnet-core&lt;/a&gt;.专门罗列了各种.NET Core优秀的开源库,该列表几乎每天都在增长,.NET Core生态的高速增长由此可见一斑.&lt;/p&gt;
&lt;p&gt;为了更好地普及.NET Core,方便.NET开发者,为.NET Core生态建设添砖加瓦,我产生了创建awesome-dotnet-core系列博客的想法.该系列会不定期发布博客,介绍awesome-dotnet-core其中一些实用的,有意思的,&lt;del&gt;我能看懂的&lt;/del&gt;库,尽量以浅显的文字,简单的例子说明库的用法和使用场景等.&lt;/p&gt;
&lt;p&gt;本系列所有博客文章和代码示例可在我的GITHUB项目&lt;a href=&quot;https://github.com/wakuflair/awesome-dotnet-core-learning&quot;&gt;awesome-dotnet-core-learning&lt;/a&gt;中找到,欢迎STAR~&lt;/p&gt;
&lt;p&gt;第一篇,介绍Sprache-解析器构建库&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sprache/Sprache&quot;&gt;Sprache&lt;/a&gt;是​​一个简单，轻量级的库，用于直接在C＃代码中构造解析器,用来解析如代码这类的结构化文本.官方的说明中,该库不是那种&quot;工业强度&quot;的语言工作台,而是介于正则表达式与全功能工具集(如&lt;a href=&quot;http://antlr.org/&quot;&gt;ANTLR&lt;/a&gt;)中间的一种工具.&lt;/p&gt;
&lt;p&gt;说白了,就是Sprache要比正则表达式强大,而稍逊于ANTLR这样的文本解析工具.&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;直接从程序代码中使用Sprache,而无需设置任何构建时代码生成任务&lt;/li&gt;
&lt;li&gt;强类型的解析规则&lt;/li&gt;
&lt;li&gt;可通过继承和组合解析规则,扩展已有的解析器&lt;/li&gt;
&lt;li&gt;支持解析规则的单元测试,完美适配测试驱动开发(TDD)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;快速上手&quot;&gt;快速上手&lt;/h2&gt;
&lt;p&gt;以下示例演示了用Sprache编写一个解析编程语言中标识符(如变量名,类名,方法名等)的示例程序.该示例参考了README中代码.&lt;/p&gt;
&lt;ol readability=&quot;18&quot;&gt;&lt;li&gt;创建一个.NET Core的命令行应用程序(详细步骤略)&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用Nuget安装Sprache:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package Sprache&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;在&lt;code&gt;Program.cs&lt;/code&gt;中,首先增加标识符的解析规则:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// 标识符解析规则
private static Parser&amp;lt;string&amp;gt; Identifier =
    from leading in Parse.WhiteSpace.Many()             // 可以包含前置空格
    from first in Parse.Letter.Once()                   // 第一个字符只能是字母
    from rest in Parse.LetterOrDigit.Many()             // 剩余的字符可以是字母或数字
    from trailing in Parse.WhiteSpace.Many()            // 可以包含后置空格
    select new string(first.Concat(rest).ToArray());    // first+rest做为标识符&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出,解析规则是直接使用C#代码定义的,利用Sprache提供的一些内置定义(如:&lt;code&gt;Parse.Letter&lt;/code&gt;),以LINQ形式组合成了一个新定义.代码非常直观易读,并且是单元测试友好的.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;编写一个辅助方法,用于检查输入的文本中是否包含合法的标识符:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 检查输入的文本中是否包含合法的标识符
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;text&quot;&amp;gt;文本&amp;lt;/param&amp;gt;
private static void CheckIdentifier(string text)
{
    var result = Identifier.TryParse(text);
    if (result.WasSuccessful)
    {
        Console.WriteLine($&quot;[{text}]中包含合法的标识符.标识符为: {result.Value}&quot;);
    }
    else
    {
        Console.WriteLine($&quot;[{text}]中不包含合法的标识符.&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;TryParse&lt;/code&gt;方法,尝试利用我们定义的规则解析一个字符串,如果成功了那么&lt;code&gt;result.WasSuccessful&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;,并且&lt;code&gt;Value&lt;/code&gt;中包含了规则的值.否则为&lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;在&lt;code&gt;Main&lt;/code&gt;方法中,调用&lt;code&gt;CheckIdentifier&lt;/code&gt;,测试解析效果:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    CheckIdentifier(&quot;    a123  &quot;);
    CheckIdentifier(&quot; 1abc&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[    a123  ]中包含合法的标识符.标识符为: a123
[ 1abc]中不包含合法的标识符.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见我们定义的规则可以正确工作.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;另外,GITHUB上&lt;a href=&quot;https://github.com/sprache/Sprache&quot;&gt;Sprache&lt;/a&gt;的README中,包含了很多资源,从教程到示例,较详细的介绍了Sprache的用法,感兴趣的朋友不要错过.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;类似库&quot;&gt;类似库&lt;/h2&gt;
&lt;ul readability=&quot;1.3984375&quot;&gt;&lt;li readability=&quot;3.84&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/benjamin-hodgson/Pidgin&quot;&gt;Pidgin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者是Stackoverflow的员工,做为Sprache的后继者,从性能和功能上有一些改进,但是可能诞生较晚,知名度不如Sprache.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.82926829268293&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/stephan-tolksdorf/fparsec&quot;&gt;FParsec&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用F#编写的解析组合器.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sun, 10 Mar 2019 06:14:00 +0000</pubDate>
<dc:creator>WAKU</dc:creator>
<og:description>【awesome dotnet core learning】(1) Sprache 解析器构建库 关于awesome dotnet core learning .NET Core从2016年发布1.0</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/waku/p/10505196.html</dc:identifier>
</item>
<item>
<title>【排序算法】归并排序 - c1714-gzr</title>
<link>http://www.cnblogs.com/TFLS-gzr/p/10505002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TFLS-gzr/p/10505002.html</guid>
<description>&lt;p&gt;　　小编记得在老早以前就梳理过一期排序算法，可是小编从未精讲，这一次就单独拿出众所周知的归并排序来讲一讲吧。&lt;/p&gt;
&lt;p&gt;【问题引入】&lt;/p&gt;
&lt;p&gt;　　在生活中，我们常常会看到一些数字，需要你来排序，当数字数量较大时，我们就会用到计算机来处理，那么如果是你，你会怎么写这个程序呢？&lt;/p&gt;
&lt;p&gt;【题目分析】&lt;/p&gt;
&lt;p&gt;　　如果你有一定的基础，一定会想到使用排序算法，你会用什么呢？冒泡？插入？归并？快排？&lt;/p&gt;
&lt;p&gt;　　今天我们来精讲归并排序。&lt;/p&gt;
&lt;p&gt;【归并排序】&lt;/p&gt;
&lt;p&gt;1）使用思想：分治；&lt;/p&gt;
&lt;p&gt;2）算法图解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1551435/201903/1551435-20190310130501148-2107341033.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3）代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; data[&lt;span&gt;1000&lt;/span&gt;],result[&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge_compare(&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; mid=(l+r)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; left_start=&lt;span&gt;l;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; left_end=&lt;span&gt;mid;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; right_start=mid+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; right_end=&lt;span&gt;r;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; result_start=&lt;span&gt;l;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(left_start&amp;lt;=left_end&amp;amp;&amp;amp;right_start&amp;lt;=right_end)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将两个子序列合并 &lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(data[left_start]&amp;lt;&lt;span&gt;data[right_start])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         result[result_start++]=data[left_start++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         result[result_start++]=data[right_start++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(left_start&amp;lt;=left_end)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将左序列剩余放入数组中 &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     result[result_start++]=data[left_start++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(right_start&amp;lt;=right_end)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将右序列剩余放入数组中 &lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     result[result_start++]=data[right_start++&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; merge_sort(&lt;span&gt;int&lt;/span&gt; l,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; r)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(l==r) &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有一个数时返回 &lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(r-l==&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(data[l]&amp;gt;&lt;span&gt;data[r])
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        swap(data[l],data[r]);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;两个数时直接交换顺序 &lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; mid=(l+r)&amp;gt;&amp;gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     merge_sort(l,mid);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;划分左序列 &lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;     merge_sort(mid+&lt;span&gt;1&lt;/span&gt;,r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;划分右序列 &lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     merge_compare(l,r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;划分完成后合并 &lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=l;i&amp;lt;=r;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     data[i]=result[i];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将临时数组中的值赋给原数组 &lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     cin&amp;gt;&amp;gt;&lt;span&gt;n;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     cin&amp;gt;&amp;gt;&lt;span&gt;data[i];
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     merge_sort(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,n);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;=n;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     cout&amp;lt;&amp;lt;data[i]&amp;lt;&amp;lt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;亲测能用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1551435/201903/1551435-20190310131117212-6537305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4）优劣成都：&lt;/p&gt;
&lt;p&gt;优：稳定，速度快&lt;/p&gt;
&lt;p&gt;劣：空间复杂度较高&lt;/p&gt;
&lt;p&gt;5）与快速排序的差别&lt;/p&gt;
&lt;p&gt;个人认为归并排序很稳定，速度已经很快了，只不过空间复杂度较高。而快速排序极不稳定，时快时慢，最慢能成为冒泡排序一样，而归并却保持在O( n log n）的速度，所以平时最好用归并。&lt;/p&gt;
&lt;p&gt;之前曾写过&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl03_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/TFLS-gzr/p/10127152.html&quot;&gt;各路传奇排序&lt;/a&gt;，讲的种类较多，有兴趣的读者可以看一看。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 05:17:00 +0000</pubDate>
<dc:creator>c1714-gzr</dc:creator>
<og:description>小编记得在老早以前就梳理过一期排序算法，可是小编从未精讲，这一次就单独拿出众所周知的归并排序来讲一讲吧。 【问题引入】 在生活中，我们常常会看到一些数字，需要你来排序，当数字数量较大时，我们就会用到计</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/TFLS-gzr/p/10505002.html</dc:identifier>
</item>
<item>
<title>python scapy的用法之ARP主机扫描和ARP欺骗 - 雨中落叶</title>
<link>http://www.cnblogs.com/yuzly/p/10492644.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuzly/p/10492644.html</guid>
<description>&lt;p&gt;&lt;span&gt;python scapy的用法之ARP主机扫描和ARP欺骗&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 目录:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.scapy介绍&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.安装scapy&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.scapy常用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.ARP主机扫描&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.ARP欺骗&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;一、scapy介绍&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;scapy是一个可用于网络嗅探的非常强大的第三方库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;具有以下几个特点:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　1.交互模式,用作第三方库。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　2.可以用开做packet嗅探和伪造packet&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　3.已经再内部实现了大量的网络协议。(DNS,ARP,IP,TCP,UDP等等)，可以用它来编写非常灵活实用的工具。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;二、安装&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;pip intall scapy&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;pip install ipython(运行命令行方式需要)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;注意:windows下安装scapy需要安装winpcap或者npcap(用于抓取网卡的数据),如果电脑安装果wireshark或者nmap就不用安装winpcap或者npcap。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;winpcap官方下载地址:https://www.winpcap.org/install/default.htm&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;npcap官方下载地址:https://nmap.org/npcap/&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;测试scapy是否安装好以及能否抓取网卡(不能抓取网卡的话,请检查winpcap或者npcap是否安装成功)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307211801810-1480631684.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;三、scapy常用&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1.嗅探流量包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;sniff函数进行嗅探流量,iface表示使用的网卡接口，filter是过滤条件，count是嗅探包的个数。结果显示嗅探到了3个ARP包。可以输入pkts[i]查看包的具体内容。sniff别的参数可以查看帮助文档:help(sniff)&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307212553167-1122606303.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2.将嗅探到的包内容写到pcap文件和读取pcap文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;wrpcap写，rdpcap读&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307213142703-1773686749.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.收发数据包&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.1、send(),在第三层发送数据包,但没有接收功能。其他参数可以查看帮助:help(send)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　fuzz函数的作用:可以更改一些默认的不被计算的值(比如校验和checksums),更改的值是随机的,但是是符合字段的值的。　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307213951880-1595747459.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.2、sendp(),在第二层发送数据包，但没有接收功能。&quot;(1,4)&quot;小括号是范围代表1到4，第二个例子:发送4个包,ttl的值是1到4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307214858605-1314139980.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.3、sr()，在第三层发送数据包，有接收功能&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;srp同时收到响应数据包和不响应数据包,需要用两个变量来接收。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ans中有请求有响应,unans只有请求没有响应&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下图可以看到ans[0]查看的数据是以元组的形式,利用下图的示例可以对特定主机的特定端口进行tcp扫描。&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307220417566-1663707691.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.4、sr1(),在第三层发送数据包,有接收功能，但只接收第一个数据包。用于哪些判断和目标是否通，接收一个数据包就能判断，没必要接收多个。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;下图可以看到,发送20个包,收到3个包,但只变量m存储一个包。　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307221250546-1309281188.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.5、srloop()，在第三层连续发送数据包，有接收功能，且连续接收数据包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.6、srp()、srp1()、srploop()工作在第二层，具体用法可以查看帮助。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 四、ARP主机扫描&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.使用scapy写一个ARP主机扫描脚本　&lt;/span&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;局域网主机扫描器  使用ARP扫描&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;主机扫描&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; scapy.all &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
wifi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Intel(R) Dual Band Wireless-AC 3165&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;构造数据包   Ether()层可以省略构造内容,因为默认就是,当然可以写上,可以加快速度&lt;/span&gt;
p=Ether(dst=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b8:81:98:e0:46:6a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)/ARP(pdst=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.43.0/24&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据包发送,srp同时收到响应数据包和不响应数据包,需要用两个变量来接收。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ans中有请求有响应,unans只有请求没有响应&lt;/span&gt;
ans,unans=srp(p,iface=wifi,timeout=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一共扫描到了%d个主机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;len(ans))
result&lt;/span&gt;=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ans是元组的形式,可以测试ans[0],发现结果是元组的形式&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; s,r &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ans:
    result.append([r[ARP].psrc,r[ARP].hwsrc])   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把目标的IP以及MAC地址加入到新的列表&lt;/span&gt;
&lt;span&gt;
result.sort()   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对列表进行排序&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;遍历列表,打印ip以及对应的mac地址&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; ip,mac &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ip,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,mac)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2.扫描结果如下:　&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307223334028-29726005.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.上面的脚本把要扫描的主机直接写死了，这里也可以使用sys模块接收命令行传递的参数。&lt;/span&gt;　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;局域网主机扫描器  使用ARP扫描&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;主机扫描,主机不是写死的,接收命令行传递的参数。&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; scapy.all &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
wifi&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Intel(R) Dual Band Wireless-AC 3165&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;构造数据包   Ether()层可以省略构造内容,因为默认就是,当然可以写上,可以加快速度&lt;/span&gt;
ip=sys.argv[1&lt;span&gt;]
p&lt;/span&gt;=Ether(dst=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b8:81:98:e0:46:6a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)/ARP(pdst=&lt;span&gt;ip)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;数据包发送,srp同时收到响应数据包和不响应数据包,需要用两个变量来接收。&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;ans中有请求有响应,unans只有请求没有响应&lt;/span&gt;
ans,unans=srp(p,iface=wifi,timeout=2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一共扫描到了%d个主机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;len(ans))
result&lt;/span&gt;=&lt;span&gt;[]
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ans是元组的形式,可以测试ans[0],发现结果是元组的形式&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; s,r &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ans:
    result.append([r[ARP].psrc,r[ARP].hwsrc])   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;把目标的IP以及MAC地址加入到新的列表&lt;/span&gt;
&lt;span&gt;
result.sort()   &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对列表进行排序&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;遍历列表,打印ip以及对应的mac地址&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; ip,mac &lt;span&gt;in&lt;/span&gt;&lt;span&gt; result:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(ip,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;---&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,mac)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4.运行效果如下:　&lt;/span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307224014347-1466732200.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、ARP欺骗&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ARP欺骗就是攻击者一直发包告诉被攻击者(目标)自己(攻击者)是网卡,欺骗目标的数据经过自己，以实现造成目标不能上网或者对目标数据进行监听的目的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.首先查看目标的ARP缓存,可以看到目标原来的网关IP以及对应的mac地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307224218833-1929926125.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; 2.开始ARP欺骗&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;ARP欺骗&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; scapy.all &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;构造包&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;pdst是目标IP，psrc是网关的ip&lt;/span&gt;
p1=Ether(dst=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ff:ff:ff:ff:ff:ff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;b8:81:98:e0:46:6a&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)/ARP(pdst=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.43.250&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,psrc=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.43.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(6000&lt;span&gt;):
    sendp(p1)
    time.sleep(&lt;/span&gt;0.1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3.运行脚本，可以看到脚本一直发包，这时再看目标的arp缓存,可以看到网关的mac地址变成攻击者的mac了(说明目标把攻击者当成了网关，ARP欺骗成功)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307225636050-357310696.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;4.ARP欺骗之后，由于攻击者不是真正的网关，无法转发数据(默认情况下)，导致目标不能上网，这就实现了目标的断网攻击了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;5.那么能不能让目标能上网，只对目标进行流量的嗅探呢，答案是有的，需要开启攻击者的路由转发功能，把目标的数据转发出去。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307230515285-536069302.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;6.查看是否开启IP路由转发功能&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1592114/201903/1592114-20190307230734894-869892284.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 05:13:00 +0000</pubDate>
<dc:creator>雨中落叶</dc:creator>
<og:description>python scapy的用法之ARP主机扫描和ARP欺骗 目录: 1.scapy介绍 2.安装scapy 3.scapy常用 4.ARP主机扫描 5.ARP欺骗 一、scapy介绍 scapy是一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuzly/p/10492644.html</dc:identifier>
</item>
<item>
<title>关于集合中一些常考的知识点总结 - 帅地</title>
<link>http://www.cnblogs.com/kubidemanong/p/10504842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kubidemanong/p/10504842.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本章主要总结了集合的一些基础但有重点的知识点，例如他们的底层数据结构以及集合之间的区别，其中 HashMap 最为重点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;集合&quot;&gt;集合&lt;/h3&gt;
&lt;p&gt;Java的集合框架中可以分为两大类：第一类是按照&lt;strong&gt;单个元素&lt;/strong&gt;存储的 Collection 集合，其中 Set, List， Queue 都实现了 Collection 接口。第二类是按照 &lt;strong&gt;Key-Value&lt;/strong&gt; 存储的 Map 集合。&lt;/p&gt;
&lt;h3 id=&quot;list&quot;&gt;List&lt;/h3&gt;
&lt;p&gt;List常量的两个子类分别是 ArrayList 和 LinkedList 这两个集合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)、ArrayList 的特点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A. ArrayList 底层数据结构是&lt;strong&gt;数组&lt;/strong&gt;，数组的特点就是可以快速随机访问，直接根据下标定位，缺点是插入和删除速度比较慢，需要移动元素。&lt;/p&gt;
&lt;p&gt;B. ArrayList 每次扩容之后的大小为之前的 1.5 倍。默认初始容量大小为 10。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)、LinkedList 的特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LinkedList 底层数据结构是&lt;strong&gt;双向链表&lt;/strong&gt;，链表的特点就是随机访问速度慢，必须一个一个遍历，不能直接通过下标定位，不过在插入、删除方面速度就比较快。不过由于链表是内存分配不要求连续，内存的利用率比较高。&lt;/p&gt;
&lt;p&gt;LinkedList 还实现了另外一个接口&lt;strong&gt;Deque&lt;/strong&gt;，即 double-ended queue，使得 LinkedList 同时具有&lt;strong&gt;队列&lt;/strong&gt;和&lt;strong&gt;栈&lt;/strong&gt;的特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3)、vector 的特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vector 和 ArrayList 基本一样，不过 Vector 是线程安全的，而 ArrayList 是线程不安全的，&lt;/p&gt;
&lt;p&gt;ArrayList 和 LinkedList 都是线程不安全的集合。&lt;/p&gt;
&lt;h3 id=&quot;map&quot;&gt;Map&lt;/h3&gt;
&lt;p&gt;Map 是一种 key-value 的集合，其常用的集合实现类有 HashMap, HashTable, TreeMap。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)、HashMap(重重点)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashMap 的底层数据结构是 链表 + 数组，如果对他的底层结构不大懂的可以看我之前写的一篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/xb0qsljOIqLVCp_BVeDWeQ&quot;&gt;HashMap的存取原理你知道多少&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HashMap 在进行 put 操作时，允许 key 和 value 为 null，且是线程不安全的，所以 HashMap 的性能非常好，只不过在多线程的环境下使用，需要给他加上对应的锁&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点数据&lt;/strong&gt;：HashMap 的默认容量为 capacity = 16, 默认扩容因子 loadFactor = 0.75，至于扩容因子有什么用，下面会涉及到。&lt;/p&gt;
&lt;p&gt;不过需要注意的是，HashMap 内部用变量 threshold 变量来表示 HashMap 中能放入的元素个数，且在 threshold 不超过最大值前提下， threshold = loadFactor * capacity。&lt;/p&gt;
&lt;p&gt;也就是说，当元素的个数达到 threshold 之后，就会触发 HashMap 的扩容，而不是达到 capacity 才触发扩容。每次扩容之后的容量为之前的 &lt;strong&gt;2 倍&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而 ArrayList 则是元素达到 capacity 时才触发扩容。&lt;/p&gt;
&lt;p&gt;还有一个需要注意的是，HashMap 容量并不会在 new 的时候分配，而是在第一次 put 的时候才完成创建的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public V put(K key, V value){
    if(table == EMPTY_TABLE){
        // 初始化
        inflateTable(threshold);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认初始化容量大小 capacity = 16，如果我们在初始化的时候指定了容量的大小 initialCapacity，则会先计算出比 initialCapacity 大的 2 的幂存入 threshold，并且也会把初始化容量置为 capacity = threshold。例如当我们指定初始容量 initialCapacity = 26 的话，则 threshold = 32, capacity = 32。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)、HashTable的特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a. HashTable 和 HashMap 在工作原理上几乎一样，不过 HashTable 是线程安全的，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/26/1692a7f27154ab3f?w=557&amp;amp;h=113&amp;amp;f=png&amp;amp;s=56503&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过锁是直接加在方法外面，所以在多线程环境下，性能极差。&lt;/p&gt;
&lt;p&gt;不过在多线程的环境下，我们优先使用 ConcurrentHashMap 集合，这个集合在工作原理上也几乎和前面两个一样，但它是线程安全的，并且不像 HashTable 那样，把整个方法都给加锁了，而是把方法里面的关键代码加锁了，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/26/1692a8028cccb025?w=541&amp;amp;h=458&amp;amp;f=png&amp;amp;s=226673&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以在处理速度上比较快。&lt;/p&gt;
&lt;p&gt;b. HashTable 不允许 key 和 value 为 null。&lt;/p&gt;
&lt;p&gt;c. HashMap 的迭代器是 fail-fast 机制(快速失败机制), 而 HashTable 则是 fail-safe 机制(快速安全)，如果不知道 fail-fast 与 fail-safe 的，可以看我之前写 的一篇文章：&lt;a href=&quot;https://mp.weixin.qq.com/s/kCyK-P8EygSsB9XOYRX-9w&quot;&gt;谈谈fail-fast与fail-safe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3)、LinkedHashMap 的特点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LinkedHashMap 是 HashMap 的一个子类，我们知道 HashMap是在插入的时候是根据哈希码来选择位置的，是无序的，而 LinkedHashMap 在插入的时候具有双向链表的特性，内部使用链表维护了插入的顺序，能够保证输出的顺序和输入时的相同。&lt;/p&gt;
&lt;p&gt;LinkedHashMap 也是线程不安全的，并且允许 key-value 为 null。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(4)、TreeMap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TreesMap 的底层数据结构是&lt;strong&gt;红黑树&lt;/strong&gt;，和 HashMap 不同，它的 get, put, remove 操作都是 O(logn) 的时间复杂度，并且元素是有序的。&lt;/p&gt;
&lt;p&gt;同样，TreeMap 也是线程不安全的。&lt;/p&gt;
&lt;h3 id=&quot;set&quot;&gt;Set&lt;/h3&gt;
&lt;p&gt;Set 是一种不允许出现重复元素的集合类型，常用的三个实现类是 HashSet、TreeSet 和 LinkedHashSet。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(1)、HashSet&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HashSet 实际上是用 HashMap 来实现的，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/26/169292ea886e3a75?w=783&amp;amp;h=279&amp;amp;f=png&amp;amp;s=29641&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只是 Value 被固定为一个静态对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/2/26/169293091b35ec28?w=824&amp;amp;h=96&amp;amp;f=png&amp;amp;s=13093&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 Key 来保证集合元素的唯一性，不过它不保证集合元素的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2)、TreeSet&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TreeSet 也是用 TreeMap 来实现的，底层为&lt;strong&gt;树结构&lt;/strong&gt;，TreeSet 则能够保证集合元素是有序的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(3)、LinkedHashSet&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LinkedHashSet 继承 HashSet，具有 HashSet 优点，不过与 HashSet 不同的是，LinkedHashSet 内部使用了链表来维护元素的插入顺序。&lt;/p&gt;
&lt;p&gt;这些知识点如果都能自己打开源码配合看一下，很多有关集合的面试题就可以应付了。&lt;/p&gt;
&lt;p&gt;最后推广下我的公众号：&lt;strong&gt;苦逼的码农&lt;/strong&gt;：&lt;a href=&quot;https://qr.tschangcun.net/q/ugTygS&quot;&gt;戳我即可关注&lt;/a&gt;，文章都会首发于我的公众号，期待各路英雄的关注交流。&lt;/p&gt;
</description>
<pubDate>Sun, 10 Mar 2019 04:10:00 +0000</pubDate>
<dc:creator>帅地</dc:creator>
<og:description>本章主要总结了集合的一些基础但有重点的知识点，例如他们的底层数据结构以及集合之间的区别，其中 HashMap 最为重点。 集合 Java的集合框架中可以分为两大类：第一类是按照 单个元素 存储的 Co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kubidemanong/p/10504842.html</dc:identifier>
</item>
</channel>
</rss>