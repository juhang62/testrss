<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>50124总体设计 - Zander_Zhao</title>
<link>http://www.cnblogs.com/ZanderZhao/p/11094740.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZanderZhao/p/11094740.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;第5章  总体设计&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;总体设计任务&lt;/p&gt;
&lt;p&gt;• 系统方案设计&lt;/p&gt;
&lt;p&gt;    划分出组成系统的物理元素—&lt;span&gt;—程序、文件、数据库、人工过程和文档等等，但是每个物理元素仍然处于黑盒子级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;• 体系结构设计&lt;/p&gt;
&lt;p&gt;    设计软件的结构，&lt;span&gt;确定系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;5.1  设计过程&lt;/h2&gt;
&lt;p&gt;两个主要阶段组成：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统设计阶段&lt;/strong&gt;：确定系统的具体实现方案；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构设计阶段&lt;/strong&gt;：确定软件结构。&lt;/p&gt;


&lt;p&gt;    典型的总体设计过程包括下述9个步骤：&lt;/p&gt;
&lt;p&gt;1. 设想供选择的方案&lt;/p&gt;
&lt;p&gt;    以数据流图为基础，寻找实现目标系统的各种不同的方案。&lt;/p&gt;

&lt;p&gt;2. 选取合理的方案&lt;/p&gt;
&lt;p&gt;    至少选取低成本、中等成本和高成本的三种方案。&lt;/p&gt;
&lt;p&gt;    对每个合理的方案分析员都应该准备下列资料：&lt;/p&gt;
&lt;p&gt;(1) 系统流程图；&lt;/p&gt;
&lt;p&gt;(2) 组成系统的物理元素清单；&lt;/p&gt;
&lt;p&gt;(3) 成本/效益分析；&lt;/p&gt;
&lt;p&gt;(4) 实现这个系统的进度计划。&lt;/p&gt;

&lt;p&gt;3. 推荐最佳方案&lt;/p&gt;

&lt;p&gt;4. 功能分解&lt;/p&gt;
&lt;p&gt;确定软件结构，从实现角度把复杂的功能进一步分解。&lt;/p&gt;
&lt;p&gt;通常分为两个阶段完成：&lt;/p&gt;
&lt;p&gt;    结构设计：确定程序由哪些模块组成，以及这些模块之间的关系。总体设计阶段的任务&lt;/p&gt;
&lt;p&gt;    过程设计：确定每个模块的处理过程。&lt;/p&gt;
&lt;p&gt;                        详细设计阶段的任务&lt;/p&gt;

&lt;p&gt;    功能分解导致数据流图的进一步细化，同时用IPO图简要描述细化后每个处理的算法。&lt;/p&gt;

&lt;p&gt;5. 设计软件结构&lt;/p&gt;
&lt;p&gt;     把模块组织成良好的层次系统，顶层模块调用它的下层模块以实现程序的完整功能，每个下层模块再调用更下层的模块，从而完成程序的一个子功能，最下层的模块完成最具体的功能。&lt;/p&gt;
&lt;p&gt;   软件结构(即由模块组成的层次系统)可以用层次图或结构图来描绘，第5.4节将介绍这些图形工具。&lt;/p&gt;
&lt;p&gt;    如果数据流图已经细化到适当的层次，可以直接从数据流图映射出软件结构，这就是第5.5节中将要讲述的面向数据流的设计方法。&lt;/p&gt;

&lt;p&gt;6. 设计数据库&lt;/p&gt;

&lt;p&gt;7. 制定测试计划&lt;/p&gt;
&lt;p&gt;    开发早期考虑测试问题，可提高软件的可测试性。&lt;/p&gt;

&lt;p&gt;8. 书写文档&lt;/p&gt;
&lt;p&gt;(1) 系统说明。主要内容包括：&lt;/p&gt;
&lt;p&gt;    系统流程图描绘的系统构成方案，组成系统的物理元素清单，成本/效益分析；&lt;/p&gt;
&lt;p&gt;    精化的数据流图，用层次图或结构图描绘的软件结构，用IPO图描述的各个模块的算法，模块间的接口关系等。&lt;/p&gt;
&lt;p&gt;(2) 用户手册&lt;/p&gt;
&lt;p&gt;(3) 测试计划&lt;/p&gt;
&lt;p&gt;(4) 详细的实现计划&lt;/p&gt;
&lt;p&gt;(5) 数据库设计结果&lt;/p&gt;

&lt;p&gt;9. 审查和复审&lt;/p&gt;


&lt;h2&gt;5.2  设计原理  &lt;/h2&gt;
&lt;p&gt;好的设计准则&lt;/p&gt;
&lt;p&gt;• 模块化&lt;/p&gt;
&lt;p&gt;• 抽象&lt;/p&gt;
&lt;p&gt;• 逐步求精&lt;/p&gt;
&lt;p&gt;• 信息隐藏和局部化&lt;/p&gt;
&lt;p&gt;• 模块独立&lt;/p&gt;

&lt;h3&gt; 5.2.1  模块化&lt;/h3&gt;
&lt;p&gt;模块： 是由边界元素限定的相邻程序元素（例如，数据说明，可执行的语句）的序列，而且有一个总体标识符代表它。按照模块的定义，过程、函数、子程序和宏等，都可作为模块。&lt;/p&gt;

&lt;p&gt;模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能，满足用户的需求。&lt;/p&gt;
&lt;p&gt;模块化的根据：把复杂的问题分解成许多容易解决的小问题，原来的问题也就容易解决了。&lt;/p&gt;
&lt;p&gt;模块化的后果：随着模块数目增加，设计模块间接口所需要的工作量也将增加。&lt;/p&gt;
&lt;p&gt;    根据这两个因素，得出了图中的总成本曲线。每个程序都有一个最适当的模块数目M，使得系统的开发成本最小。&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082011780-665727965.png&quot; alt=&quot;&quot; width=&quot;319&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.1 模块化和软件成本&lt;/p&gt;

&lt;h3&gt;5.2.1  模块化优点&lt;/h3&gt;
&lt;p&gt;• 使软件结构清晰，容易设计也容易阅读和理解。&lt;/p&gt;
&lt;p&gt;•提高软件的可靠性。&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;  程序错误局限在有限的模块中，使软件容易测试和调试。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;•提高了软件的可修改性。&lt;/p&gt;
&lt;p&gt;     &lt;span&gt;即使有变动，往往只涉及少数几个模块，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;• 有助于软件开发工程的组织管理。&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;  一个大型程序由许多程序员分工编写，分配技术熟练的程序员编写困难的模块。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;5.2.2  抽象&lt;/h3&gt;
&lt;p&gt;抽象：把事务相似的方面集中和概括起来，暂时忽略它们之间的差异。&lt;/p&gt;
&lt;p&gt;    抽象就是抽出事物的本质特性而暂时不考虑它们的细节。&lt;/p&gt;
&lt;h3&gt;5.2.3  逐步求精&lt;/h3&gt;
&lt;p&gt;Miller法则：一个人在任何时候都只能把注意力集中在（7±2）个知识块上。&lt;/p&gt;
&lt;p&gt;逐步求精是人类解决复杂问题时采用的基本方法。&lt;/p&gt;

&lt;p&gt;逐步求精实际上是自顶向下的细化过程。&lt;/p&gt;
&lt;p&gt;    高抽象级别定义的功能，仅作概念性地描述，没有提供功能的内部工作情况。&lt;/p&gt;
&lt;p&gt;    求精要求设计者细化原始陈述，随着每个后续求精（即细化）步骤的完成，提供越来越多的细节。&lt;/p&gt;

&lt;p&gt;    抽象与求精是一对互补的概念。&lt;/p&gt;
&lt;p&gt;    抽象使得设计者能够说明过程和数据，同时却忽略低层细节。&lt;/p&gt;
&lt;p&gt;    求精则帮助设计者在设计过程中逐步揭示出低层细节。&lt;/p&gt;
&lt;p&gt;    这两个概念都有助于设计者在设计演化过程中创造出完整的设计模型。&lt;/p&gt;
&lt;h3&gt;5.2.4  信息隐藏和局部化&lt;/h3&gt;
&lt;p&gt;信息隐藏：一个模块内包含的信息(过程和数据)对于不需要这些信息的模块来说，是不能访问的。&lt;/p&gt;
&lt;p&gt;局部化：是指把一些关系密切的软件元素物理地放得彼此靠近。&lt;/p&gt;
&lt;p&gt;在模块中使用局部数据元素是局部化的一个例子。有助于实现信息隐藏。&lt;/p&gt;
&lt;h3&gt;5.2.5  模块独立&lt;/h3&gt;
&lt;p&gt;    模块独立的概念是模块化、抽象、信息隐藏和局部化概念的直接结果。&lt;/p&gt;
&lt;p&gt;模块独立：具有独立功能而且和其他模块之间没有过多的相互作用的模块。&lt;/p&gt;
&lt;p&gt;模块独立的重要性：&lt;/p&gt;
&lt;p&gt;第一，具有独立模块的软件比较容易开发。&lt;/p&gt;
&lt;p&gt;第二，独立模块比较容易测试和维护。&lt;/p&gt;
&lt;p&gt;    错误传播范围小，容易测试与修改，需要扩充功能时能够“插入”模块。&lt;/p&gt;

&lt;p&gt;　&lt;strong&gt;模块独立程度的度量标准：内聚和耦合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;耦合：模块间互相依赖(连接)的紧密程度；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内聚：模块内部各个元素彼此结合的紧密程度。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1. 耦合&lt;/p&gt;
&lt;p&gt;　影响耦合强度的因素&lt;/p&gt;
&lt;p&gt;• 一个模块对另一个模块的引用&lt;/p&gt;
&lt;p&gt;• 一个模块向另一个模块传递的数据量&lt;/p&gt;
&lt;p&gt;• 一个模块施加到另一个模块的控制的数量&lt;/p&gt;
&lt;p&gt;• 模块之间接口的复杂程度&lt;/p&gt;

&lt;p&gt;耦合的类型&lt;/p&gt;
&lt;p&gt;•         内容耦合　　强&lt;/p&gt;
&lt;p&gt;•         公共耦合　　¦&lt;/p&gt;
&lt;p&gt;•         控制耦合　　¦&lt;/p&gt;
&lt;p&gt;•         标记耦合　　↓&lt;/p&gt;
&lt;p&gt;•         数据耦合　　弱&lt;/p&gt;


&lt;p&gt;　在软件设计中应该追求尽可能松散耦合。&lt;/p&gt;

&lt;p&gt;    对模块的测试或维护时，不需要对系统的其他模块有很多了解。&lt;/p&gt;
&lt;p&gt;　此外，由于模块间联系简单，发生在一处的错误传播到整个系统的可能性就很小。&lt;/p&gt;

&lt;p&gt;    因此，模块间的耦合程度强烈影响系统的可理解性、可测试性、可靠性和可维护性。&lt;/p&gt;


&lt;p&gt;数据耦合&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据耦合：模块彼此间通过参数交换信息，交换的信息仅仅是数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　数据耦合是低耦合。系统中至少必须存在这种耦合，因为只有当某些模块的输出数据作为另一些模块的输入数据时，系统才能完成有价值的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    一般说来，一个系统内可以只包含数据耦合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082411979-586519781.png&quot; alt=&quot;&quot; width=&quot;271&quot; height=&quot;291&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;标记耦合&lt;br/&gt;&lt;span&gt;（ Stamp coupled ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;• 若两个模块间传递的参数中至少有一个是数据结构，如字符串或记录，并且在模块中仅用到该数据结构中的部分元素，则称这两个模块之间存在标记耦合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在这种情况下，被调用的模块可以使用的数据多于它确实需要的数据，将导致对数据的访问失去控制，从而给计算机犯罪提供了机会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082442690-1703244618.png&quot; alt=&quot;&quot; width=&quot;254&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;


&lt;p&gt;控制耦合&lt;br/&gt;（Control coupled）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;控制耦合：一个模块向另一个模块传递控制信息，接收信息的模块的动作根据信息值进行调整。 　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    控制耦合是中等程度的耦合，它增加了系统的复杂程度。在把模块适当分解之后通常可以用数据耦合代替它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082507228-1453732062.png&quot; alt=&quot;&quot; width=&quot;240&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;


&lt;p&gt;公共耦合&lt;br/&gt;&lt;span&gt;（ Common coupled ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•两个模块共享全局的数据区域，称他们为公共耦合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•不要使用全局变量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082543514-43447415.png&quot; alt=&quot;&quot; width=&quot;385&quot; height=&quot;258&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;公共耦合&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 耦合的复杂程度随耦合模块的个数而变化，随个数的增加显著增加。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     两个模块的公共耦合有两种可能：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(1) 一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;(2) 两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;内容耦合&lt;br/&gt;&lt;span&gt;（ Content coupled ）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•内容耦合的三种情况:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•一个模块修改另一个模块的语句 (Lisp 具有此种能力)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•一个模块引用或者修改另一个模块内部的数据&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;•一个模块不通过正常入口而跳转到另一个模块的内部&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;模块独立性与耦合的关系&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082649115-1365249766.png&quot; alt=&quot;&quot; width=&quot;413&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;


&lt;p&gt;　总之，耦合是影响软件复杂程度的一个重要因素。应该采取下述设计原则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　尽量使用数据耦合，少用控制耦合和标记耦合，限制公共环境耦合的范围，完全不用内容耦合。&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;2. 内聚&lt;/p&gt;
&lt;p&gt;　内聚标志一个模块内各个元素彼此结合的紧密程度。理想内聚的模块只做一件事情。&lt;/p&gt;
&lt;p&gt;　度量一个模块内部各成分之间相互关联的强度&lt;/p&gt;

&lt;p&gt;•         偶然内聚　　弱&lt;/p&gt;
&lt;p&gt;•         逻辑内聚&lt;/p&gt;
&lt;p&gt;•         时间内聚&lt;/p&gt;
&lt;p&gt;•         过程内聚　　↓&lt;/p&gt;
&lt;p&gt;•         通信内聚&lt;/p&gt;
&lt;p&gt;•         顺序内聚&lt;/p&gt;
&lt;p&gt;•         功能内聚　　强&lt;/p&gt;


&lt;p&gt;偶然内聚&lt;br/&gt;（ &lt;em&gt;coincidental cohesion&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;    如果一个模块的各成分之间毫无关系，则称为偶然内聚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082856307-451386105.png&quot; alt=&quot;&quot; width=&quot;110&quot; height=&quot;101&quot;/&gt;&lt;/p&gt;


&lt;p&gt;逻辑内聚&lt;br/&gt;（ &lt;em&gt;logically cohesive&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;几个逻辑上相关的功能被放在同一模块中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082913627-969907749.png&quot; alt=&quot;&quot; width=&quot;110&quot; height=&quot;124&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082928740-208997172.png&quot; alt=&quot;&quot; width=&quot;295&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;


&lt;p&gt;时间内聚&lt;br/&gt;（ &lt;em&gt;Temporal cohesion&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;如果一个模块完成的功能只是因为时间因素关联在一起。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627082946812-831083402.png&quot; alt=&quot;&quot; width=&quot;93&quot; height=&quot;105&quot;/&gt;&lt;/p&gt;



&lt;p&gt;时间内聚&lt;br/&gt;（ &lt;em&gt;Temporal cohesion&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;•Consider a module called &quot;On_Really_Bad_Failure&quot; that is invoked when a Really_Bad_Failure happens. The module performs several tasks that are not functionally similar or logically related, but all tasks need to happen at the moment when the failure occurs.&lt;/p&gt;
&lt;p&gt;•The module might&lt;/p&gt;
&lt;p&gt;cancel all outstanding requests for services&lt;/p&gt;
&lt;p&gt;cut power to all assembly line machines&lt;/p&gt;
&lt;p&gt;notify the operator console of the failure&lt;/p&gt;
&lt;p&gt;make an entry in a database of failure records&lt;/p&gt;


&lt;p&gt;过程内聚&lt;br/&gt;（ &lt;em&gt;procedurally cohesive&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;如果一个模块内部的各个处理成分必须以特定的次序执行，则称为过程内聚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083032643-1069172606.png&quot; alt=&quot;&quot; width=&quot;107&quot; height=&quot;121&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通信内聚&lt;br/&gt;（ &lt;em&gt;communicationally cohesive&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;如果一个模块的所有成分都操作同一数据集或生成同一数据集，则称为通信内聚。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083056761-403719439.png&quot; alt=&quot;&quot; width=&quot;236&quot; height=&quot;121&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083109521-1661337395.png&quot; alt=&quot;&quot; width=&quot;331&quot; height=&quot;281&quot;/&gt;&lt;/p&gt;



&lt;p&gt;顺序内聚&lt;br/&gt;（ &lt;em&gt;sequentially cohesive&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;如果一个模块的各个成分和同一个功能密切相关，而且一个成分的输出作为另一个成分的输入，则称为顺序内聚。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083125778-945634064.png&quot; alt=&quot;&quot; width=&quot;124&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;



&lt;p&gt;功能内聚&lt;br/&gt;（ &lt;em&gt;functionally cohesive&lt;/em&gt; ）&lt;/p&gt;
&lt;p&gt;模块的所有成分对于完成单一的功能都是基本的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083140511-1279862573.png&quot; alt=&quot;&quot; width=&quot;165&quot; height=&quot;134&quot;/&gt;&lt;/p&gt;


&lt;p&gt;设计时尽量使用&lt;strong&gt;高内聚，低耦合模块。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• 高内聚：尽量使用内聚度高的模块；中内聚也可；低内聚很坏，不要采用。&lt;/p&gt;
&lt;p&gt;低内聚：偶然内聚，逻辑内聚，时间内聚&lt;/p&gt;
&lt;p&gt;中内聚：过程内聚，通信内聚&lt;/p&gt;
&lt;p&gt;高内聚：顺序内聚，功能内聚；&lt;/p&gt;

&lt;p&gt;• 低耦合：尽量使用数据耦合，少用控制耦合和标记耦合，限制公共耦合的范围，完全不用内容耦合。&lt;/p&gt;


&lt;h2&gt;5.3  启发式规则&lt;/h2&gt;
&lt;p&gt;改进软件设计，提高软件质量的途径。&lt;/p&gt;
&lt;p&gt;•改进软件结构提高模块独立性&lt;/p&gt;
&lt;p&gt;•模块规模应该适中&lt;/p&gt;
&lt;p&gt;•深度、宽度、扇出和扇入应适中&lt;/p&gt;
&lt;p&gt;•模块的作用域应该在控制域之内&lt;/p&gt;
&lt;p&gt;•力争降低模块接口的复杂性&lt;/p&gt;
&lt;p&gt;•设计单入口和单出口的模块&lt;/p&gt;
&lt;p&gt;•模块功能应该可以预测&lt;/p&gt;

&lt;p&gt;1. 改进软件结构提高模块独立性&lt;/p&gt;
&lt;p&gt;•降低耦合&lt;/p&gt;
&lt;p&gt;•提高内聚&lt;/p&gt;

&lt;p&gt;2. 模块规模应该适中&lt;/p&gt;
&lt;p&gt;•模块规模：&lt;/p&gt;
&lt;p&gt;不超过60行&lt;/p&gt;
&lt;p&gt;超过30，可理解程度迅速下降&lt;/p&gt;
&lt;p&gt;•模块数量：&lt;/p&gt;
&lt;p&gt;适中&lt;/p&gt;

&lt;p&gt;模块过大：往往是由于分解不充分。&lt;/p&gt;
&lt;p&gt;模块过小：导致模块数目过多，使系统接口复杂。可以把它合并到上级模块中去。&lt;/p&gt;

&lt;p&gt;3. 深度、宽度、扇出和扇入都应适当&lt;/p&gt;
&lt;p&gt;• 深度：表示软件结构中控制的层数。&lt;/p&gt;
&lt;p&gt;      能粗略地标志一个系统的大小和复杂程度。如果层数过多，应考虑管理模块是否过分简单，能否适当合并。&lt;/p&gt;
&lt;p&gt;• 宽度：软件结构内同一个层次上的模块总数的最大值。&lt;/p&gt;
&lt;p&gt;      宽度越大系统越复杂。对宽度影响最大的因素是模块的扇出。&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;扇出：是一个模块直接控制(调用)的模块数目。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;     扇出过大意味着模块过分复杂，需要控制和协调的下级模块过多；扇出过小(例如总是1)也不好。&lt;/p&gt;
&lt;p&gt;    通常是3或4(上限是5～9)。&lt;/p&gt;
&lt;p&gt;扇出太大：缺乏中间层次，应适当增加中间层次的控制模块。&lt;/p&gt;
&lt;p&gt;扇出太小：把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。&lt;/p&gt;
&lt;p&gt;    分解或合并模块应符合问题结构，不能违背模块独立原理。&lt;/p&gt;

&lt;p&gt;• &lt;strong&gt;扇入：表明有多少个上级模块。扇入越大则共享该模块的上级模块数目越多，这是有好处的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    好的软件结构通常顶层扇出比较高，中层扇出较少，底层模块有高扇入。&lt;/p&gt;
&lt;p&gt;    系统的模块结构呈现为“葫芦形”。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083351360-1923069287.png&quot; alt=&quot;&quot; width=&quot;287&quot; height=&quot;215&quot;/&gt;&lt;/p&gt;


&lt;p&gt;4. 模块的作用域应该在控制域之内&lt;/p&gt;
&lt;p&gt;• 模块的作用域：受该模块内一个判定影响的所有模块的集合。&lt;/p&gt;
&lt;p&gt;• 模块的控制域：模块本身以及所有直接或间接从属于它的模块的集合。&lt;/p&gt;
&lt;p&gt;    例如，在图5.2中模块A的控制域是A、B、C、D、E、F等模块的集合。&lt;/p&gt;
&lt;p&gt;    受判定影响的模块应在做出判定的那个模块的控制域之内。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083505495-1329326915.png&quot; alt=&quot;&quot; width=&quot;378&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;图5.2 模块的作用域和控制域&lt;/p&gt;

&lt;p&gt;5. 力争降低模块接口的复杂程度&lt;/p&gt;
&lt;p&gt;    应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。&lt;/p&gt;

&lt;p&gt;6. 设计单入口单出口的模块&lt;/p&gt;
&lt;p&gt;    使模块间避免出现内容耦合。当从顶部进入模块并且从底部退出来时，软件是比较容易理解的，因此也是比较容易维护的。&lt;/p&gt;

&lt;p&gt;7. 模块功能应该可以预测&lt;/p&gt;
&lt;p&gt;    只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。&lt;/p&gt;
&lt;p&gt;    带有内部“存储器”的模块的功能可能是不可预测的，不宜测试与维护。&lt;/p&gt;


&lt;h2&gt;5.4  描绘软件结构的图形工具  &lt;/h2&gt;
&lt;h3&gt;5.4.1  层次图和HIPO图&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;层次图：用来描绘软件的层次结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    形式和描绘数据结构的层次方框图相同，但表现的内容却完全不同。&lt;/p&gt;
&lt;p&gt;•层次图中的一个矩形框代表一个模块，方框间的连线表示调用关系&lt;/p&gt;
&lt;p&gt;•层次方框图中的一个矩形框代表数据的子集，方框间的连线表示组成关系。&lt;/p&gt;
&lt;p&gt;图5.3是层次图的一个例子。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083636013-1259452767.png&quot; alt=&quot;&quot; width=&quot;399&quot; height=&quot;201&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.3 正文加工系统的层次图&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;HIPO： “层次图加输入/处理/输出图”的英文缩写。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    为了能使HIPO图具有可追踪性，在H图(层次图)里除了最顶层的方框之外，每个方框都加了编号。编号规则和数据流图的编号规则相同。&lt;/p&gt;
&lt;p&gt;例如，图5.3加了编号后得到图5.4。&lt;/p&gt;
&lt;p&gt;    H图中每个方框对应一张IPO图，描绘这个方框代表的模块的处理过程。每张IPO图内都应标出它所描绘的模块在H图中的编号。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083702752-142844991.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.4 带编号的层次图(H图)&lt;/p&gt;
&lt;h3&gt;5.4.2  结构图&lt;/h3&gt;
&lt;p&gt;     结构图和层次图类似，也是描绘软件结构的图形工具。&lt;/p&gt;
&lt;p&gt;结构图基本符号：&lt;/p&gt;
&lt;p&gt;•方框——模块&lt;/p&gt;
&lt;p&gt;•方框间连线——模块调用关系（上方的模块调用下方的模块）&lt;/p&gt;
&lt;p&gt;•带注释的箭头——模块间传递的信息&lt;/p&gt;
&lt;p&gt;•箭头尾部空心圆——数据信息&lt;/p&gt;
&lt;p&gt;•箭头尾部实心圆——控制信息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083839831-461590419.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;图5.5 结构图的例子——产生最佳解的一般结构&lt;/p&gt;

&lt;p&gt;    还有一些附加的符号，可以表示模块的选择调用或循环调用。&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083923178-1722395151.png&quot; alt=&quot;&quot; width=&quot;263&quot; height=&quot;135&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图5.6 判定为真时调用A，为假时调用B&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627083936421-141293575.png&quot; alt=&quot;&quot; width=&quot;252&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5.7 模块M循环调用模块A、B、C&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;h2&gt;5.5 面向数据流的设计方法&lt;/h2&gt;
&lt;h3&gt;&lt;br/&gt;5.5.1  概念&lt;/h3&gt;
&lt;p&gt;面向数据流的设计方法：把数据流图中的信息流映射成软件结构。信息流的类型决定了映射的方法。信息流有下述两种类型。&lt;/p&gt;

&lt;p&gt;1. 变换流&lt;/p&gt;
&lt;p&gt;变换流：具有较明显的输入、变换（或称主加工）和输出界面的数据流图。&lt;/p&gt;
&lt;p&gt;参看图5.8&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084037194-1197904796.png&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.8 变换流&lt;/p&gt;

&lt;p&gt;2. 事务流&lt;/p&gt;
&lt;p&gt;事务流：数据沿输入通路到达一个处理T，这个处理根据输入数据的类型在若干个动作序列中选出一个来执行。&lt;/p&gt;
&lt;p&gt;此时数据流图形状如图5.9，是“以事务为中心的”。&lt;/p&gt;
&lt;p&gt;图5.9中的处理T称为事务中心，它完成下述任务：&lt;/p&gt;
&lt;p&gt;(1) 接收输入数据(输入数据又称为事务)；&lt;/p&gt;
&lt;p&gt;(2) 分析每个事务以确定它的类型；&lt;/p&gt;
&lt;p&gt;(3) 根据事务类型选取一条活动通路。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084104740-815480904.png&quot; alt=&quot;&quot; width=&quot;266&quot; height=&quot;230&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.9 事务流&lt;/p&gt;

&lt;p&gt;3. 设计过程&lt;/p&gt;
&lt;p&gt;    图5.10（见书96页）说明了使用面向数据流方法逐步设计的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084136127-748299264.png&quot; alt=&quot;&quot; width=&quot;369&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;5.5.2  变换分析&lt;/h3&gt;
&lt;p&gt;变换分析：把数据流图按预先确定的模式映射成软件结构的一系列设计步骤的总称。&lt;/p&gt;


&lt;p&gt;下面通过一个例子说明变换分析的方法。&lt;/p&gt;
&lt;p&gt;1. 例子&lt;/p&gt;
&lt;p&gt;考虑汽车数字仪表板的设计。&lt;/p&gt;
&lt;p&gt;假设的仪表板将完成下述功能：&lt;/p&gt;
&lt;p&gt;(1) 通过模数转换实现传感器和微处理机接口；&lt;/p&gt;
&lt;p&gt;(2) 在发光二极管面板上显示数据；&lt;/p&gt;
&lt;p&gt;(3) 指示每小时英里数(mph)，行驶的里程，每加仑油行驶的英里数(mpg)等等；&lt;/p&gt;
&lt;p&gt;(4) 指示加速或减速；&lt;/p&gt;
&lt;p&gt;(5) 超速警告：如果车速超过55英里/小时，则发出超速警告铃声。&lt;/p&gt;
&lt;p&gt;在需求分析阶段建立起相应的数据流图。&lt;/p&gt;

&lt;p&gt;2. 设计步骤&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第1步&lt;/strong&gt; 复查基本系统模型。&lt;/p&gt;
&lt;p&gt;复查的目的是确保系统的输入数据和输出数据符合实际。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第2步&lt;/strong&gt; 复查并精化数据流图。&lt;/p&gt;
&lt;p&gt;应该对需求分析阶段得出的数据流图认真复查，并且在必要时进行精化。使数据流图中每个处理都代表一个规模适中相对独立的子功能。&lt;/p&gt;
&lt;p&gt;假设在需求分析阶段产生的数字仪表板系统的数据流图如图5.11（见书97页）所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第3步&lt;/strong&gt; 确定数据流图具有变换特性还是事务特性。&lt;/p&gt;
&lt;p&gt;    一般地说，一个系统中的所有信息流都可以认为是变换流，但是，当遇到有明显事务特性的信息流时，建议采用事务分析方法进行设计。&lt;/p&gt;
&lt;p&gt;     从图5.11看出，数据沿着两条输入通路进入系统，然后沿着5条通路离开，没有明显的事务中心。&lt;/p&gt;
&lt;p&gt;    因此可以认为这个信息流具有变换流的总特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第4步&lt;/strong&gt; 确定输入流和输出流的边界，从而孤立出变换中心。&lt;/p&gt;
&lt;p&gt;    对于汽车数字仪表板的例子，设计人员确定的流的边界如图5.12（见书98页）所示。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第5步&lt;/strong&gt; 完成“第一级分解”。&lt;/p&gt;
&lt;p&gt;分解：就是分配控制的过程，对控制的自顶向下的分配----软件结构。&lt;/p&gt;
&lt;p&gt;    图5.13说明了第一级分解的方法。位于软件结构最顶层的控制模块Cm协调下述从属的控制功能：&lt;/p&gt;
&lt;p&gt;输入信息处理控制模块Ca：协调对所有输入数据的接收；&lt;/p&gt;
&lt;p&gt;变换中心控制模块Ct：管理对内部形式的数据的所有操作；&lt;/p&gt;
&lt;p&gt;输出信息处理控制模块Ce：协调输出信息的产生过程。&lt;/p&gt;
&lt;p&gt;    数据流图被映射成一个特殊的软件结构，这个结构控制输入、变换和输出等信息处理过程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084339584-1424267869.png&quot; alt=&quot;&quot; width=&quot;290&quot; height=&quot;168&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.13 第一级分解的方法&lt;/p&gt;
&lt;p&gt;    对于数字仪表板的例子，第一级分解得出的结构如图5.14所示。每个控制模块的名字表明了为它所控制的那些模块的功能。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084357840-1787465429.png&quot; alt=&quot;&quot; width=&quot;303&quot; height=&quot;199&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.14 数字仪表板系统的第一级分解&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第6步&lt;/strong&gt; 完成“第二级分解”。&lt;/p&gt;
&lt;p&gt;第二级分解：就是把数据流图中的每个处理映射成软件结构中一个适当的模块。&lt;/p&gt;
&lt;p&gt;完成第二级分解的方法是：&lt;/p&gt;
&lt;p&gt;•从变换中心的边界开始沿着输入通路向外移动，把输入通路中每个处理映射成软件结构中Ca控制下的一个低层模块；&lt;/p&gt;
&lt;p&gt;•然后沿输出通路向外移动，把输出通路中每个处理映射成直接或间接受模块Ce控制的一个低层模块；&lt;/p&gt;
&lt;p&gt;•最后把变换中心内的每个处理映射成受Ct控制的一个模块。&lt;/p&gt;
&lt;p&gt;       图5.15表示进行第二级分解的普遍途径。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084426298-2106498059.png&quot; alt=&quot;&quot; width=&quot;283&quot; height=&quot;220&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.15 第二级分解的方法&lt;/p&gt;

&lt;p&gt;    对于数字仪表板系统的例子，第二级分解的结果分别用图5.16，5.17和5.18描绘。&lt;/p&gt;
&lt;p&gt;    这3张图表示对软件结构的初步设计结果。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084445011-1816326290.png&quot; alt=&quot;&quot; width=&quot;194&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.16 未经精化的输入结构&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084500399-1222507780.png&quot; alt=&quot;&quot; width=&quot;323&quot; height=&quot;185&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;图5.17 未经精化的变换结构&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084512579-364384095.png&quot; alt=&quot;&quot; width=&quot;301&quot; height=&quot;178&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;图5.18 未经精化的输出结构&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第7步&lt;/strong&gt; 使用设计度量和启发式规则对第一次分割得到的软件结构进一步精化。&lt;/p&gt;
&lt;p&gt; 根据模块独立原理进行精化。得到尽可能高的内聚、尽可能松散的耦合。需对初步分割得到的模块进行再分解或合并。&lt;/p&gt;
&lt;p&gt;    具体到数字仪表板的例子，对于从前面的设计步骤得到的软件结构，还可以做许多修改：&lt;/p&gt;
&lt;p&gt;• 输入结构中的模块“转换成rpm”和“收集sps”可以合并；&lt;/p&gt;
&lt;p&gt;• 模块“确定加速/减速”可以放在模块“计算mph”下面，以减少耦合；&lt;/p&gt;
&lt;p&gt;• 模块“加速/减速显示”可以相应地放在模块“显示mph”的下面。&lt;/p&gt;
&lt;p&gt;经过上述修改后的软件结构画在图5.19中。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084530894-92312987.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;251&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.19 精化后的数字仪表板系统的软件结构&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;h3&gt;5.5.3  事务分析&lt;/h3&gt;
&lt;p&gt;    在数据流具有明显的事务特点时，也就是有一个明显的“发射中心”(事务中心)时，还是以采用事务分析方法为宜。&lt;/p&gt;
&lt;p&gt;事务分析的设计步骤和变换分析的设计步骤大部分相同或类似，主要差别仅在于：&lt;/p&gt;
&lt;p&gt;    由数据流图到软件结构的映射方法不同。&lt;/p&gt;

&lt;p&gt;    由事务流映射成的软件结构包括一个接收分支和一个发送分支。&lt;/p&gt;
&lt;p&gt;• 接收分支结构&lt;/p&gt;
&lt;p&gt;    映射方法和变换分析映射出输入结构的方法很相像。&lt;/p&gt;
&lt;p&gt;    从事务中心的边界开始，把沿着接收流通路的处理映射成模块。&lt;/p&gt;
&lt;p&gt;• 发送分支结构&lt;/p&gt;
&lt;p&gt;    包含一个调度模块，它控制下层的所有活动模块；&lt;/p&gt;
&lt;p&gt;    然后把数据流图中的每个活动流通路映射成与它的流特征相对应的结构。&lt;/p&gt;
&lt;p&gt;     图5.20说明了上述映射过程。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1427277/201906/1427277-20190627084606694-843880092.png&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;287&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;图5.20 事务分析的映射方法&lt;/p&gt;
&lt;h3&gt;5.5.4  设计优化&lt;/h3&gt;
&lt;p&gt;    对第一次分割得到的软件结构，总可以根据模块独立原理和启发式设计规则进行优化。&lt;/p&gt;
&lt;p&gt;   为了产生合理的分解，得到尽可能高的内聚﹑尽可能松散的耦合，最重要的是，为了得到一个易于实现﹑易于测试和易于维护的软件结构，应该对初步分割得到的模块进行再分解或合并。&lt;/p&gt;
&lt;p&gt;    注意，设计优化应该力求做到在有效的模块化的前提下使用最少量的模块，以及在能够满足信息要求的前提下使用最简单的数据结构。&lt;/p&gt;
&lt;h2&gt;5.6  小结&lt;/h2&gt;
&lt;p&gt;总体设计阶段的基本目的：&lt;strong&gt;是用比较抽象概括的方式确定系统如何完成预定的任务，确定系统的物理配置方案，确定组成系统的每个程序的结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总体设计阶段主要由两个小阶段组成。&lt;/p&gt;
&lt;p&gt;首先需要进行系统设计；然后进行软件结构设计，确定软件由哪些模块组成以及这些模块之间的动态调用关系。&lt;/p&gt;
&lt;p&gt;层次图和结构图是描绘软件结构的常用工具。&lt;/p&gt;

&lt;p&gt;在进行软件结构设计时应该遵循的最主要的原理是模块独立原理。&lt;/p&gt;
&lt;p&gt;抽象和求精是一对互补的概念。在进行软件结构设计时就是由抽象到具体地构造出软件的层次结构。&lt;/p&gt;

&lt;p&gt;软件工程师在开发软件的长期实践中积累了丰富的经验，总结这些经验得出一些很有参考价值的启发式规则。&lt;/p&gt;
&lt;p&gt;自顶向下逐步求精是进行软件结构设计的常用途径；&lt;/p&gt;
&lt;p&gt;如果已经有了详细的数据流图，也可以使用面向数据流的设计方法，由数据流图映射出软件结构。&lt;/p&gt;
&lt;p&gt;    这样映射出来的只是软件的初步结构，还必须根据设计原理并且参考启发式规则，认真分析和改进软件的初步结构，以得到质量更高的模块和更合理的软件结构。&lt;/p&gt;

</description>
<pubDate>Thu, 27 Jun 2019 00:47:00 +0000</pubDate>
<dc:creator>Zander_Zhao</dc:creator>
<og:description>第5章 总体设计 总体设计任务 • 系统方案设计 划分出组成系统的物理元素——程序、文件、数据库、人工过程和文档等等，但是每个物理元素仍然处于黑盒子级。 • 体系结构设计 设计软件的结构，确定系统中每</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZanderZhao/p/11094740.html</dc:identifier>
</item>
<item>
<title>在前后端分离项目中使用SpringBoot集成Shiro - garfieldzf</title>
<link>http://www.cnblogs.com/sword-successful/p/11093803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sword-successful/p/11093803.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;       这次在处理一个小项目时用到了前后端分离，服务端使用springboot2.x。权限验证使用了Shiro。前后端分离首先需要解决的是跨域问题，POST接口跨域时会预发送一个OPTIONS请求，浏览器收到响应后会继续执行POST请求。 前后端分离后为了保持会话状态使用session持久化插件shiro-redis，持久化session可以持久化到关系型数据库，也可以持久化到非关系型数据库（主要是重写SessionDao）。Shiro已提供了SessionDao接口和抽象类。如果项目中用到Swagger的话，还需要把swagger相关url放行。&lt;/p&gt;

&lt;h3&gt;搭建依赖&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;!--session持久化插件--&amp;gt;
        &amp;lt;groupId&amp;gt;org.crazycake&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;shiro-redis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.2.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;!--spring shiro依赖--&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.shiro&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;shiro-spring&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt; Shiro权限配置&lt;/h3&gt;
&lt;p&gt;1、ShiroConfig。这里主要是shiro核心配置。比如SecurityManager、SessionManager、CacheManager。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ShiroConfig {

    @Value(&quot;${spring.redis.shiro.host}&quot;)
    private String host;
    @Value(&quot;${spring.redis.shiro.port}&quot;)
    private int port;
    @Value(&quot;${spring.redis.shiro.timeout}&quot;)
    private int timeout;
    @Value(&quot;${spring.redis.shiro.password}&quot;)
    private String password;


    /**
     * 权限规则配置
     **/
    @Bean
    public ShiroFilterFactoryBean shiroFilterFactoryBean(SecurityManager securityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();
        shiroFilterFactoryBean.setSecurityManager(securityManager);

        Map&amp;lt;String, Filter&amp;gt; filters = shiroFilterFactoryBean.getFilters();
        filters.put(&quot;authc&quot;, new MyFormAuthorizationFilter());

        Map&amp;lt;String, String&amp;gt; filterChainDefinitionMap = new LinkedHashMap&amp;lt;&amp;gt;();

        //swagger资源不拦截
        filterChainDefinitionMap.put(&quot;/swagger-ui.html&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/swagger-resources/**/**&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/v2/api-docs&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/webjars/springfox-swagger-ui/**&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/configuration/security&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/configuration/ui&quot;, &quot;anon&quot;);

        filterChainDefinitionMap.put(&quot;/login/ajaxLogin&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/login/unauth&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/login/logout&quot;, &quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/login/register&quot;,&quot;anon&quot;);
        filterChainDefinitionMap.put(&quot;/**&quot;, &quot;authc&quot;);

        shiroFilterFactoryBean.setLoginUrl(&quot;/login/unauth&quot;);
        shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);
        return shiroFilterFactoryBean;
    }


    /**
     * shiro安全管理器（权限验证核心配置）
     **/
    @Bean
    public SecurityManager securityManager() {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();
        securityManager.setRealm(myShiroRealm());
        securityManager.setSessionManager(sessionManager());
        securityManager.setCacheManager(cacheManager());

        return securityManager;
    }

    /**
     * 会话管理
     **/
    @Bean
    public SessionManager sessionManager() {
        MySessionManager sessionManager = new MySessionManager();
        sessionManager.setSessionIdUrlRewritingEnabled(false); //取消登陆跳转URL后面的jsessionid参数
        sessionManager.setSessionDAO(sessionDAO());
        sessionManager.setGlobalSessionTimeout(-1);//不过期
        return sessionManager;
    }

    /**
     * 使用的是shiro-redis开源插件 缓存依赖
     **/
    @Bean
    public RedisManager redisManager() {
        RedisManager redisManager = new RedisManager();
        redisManager.setHost(host+&quot;:&quot;+port);
        redisManager.setTimeout(timeout);
        redisManager.setPassword(password);
        return redisManager;
    }

    /**
     * 使用的是shiro-redis开源插件 session持久化
     **/
    public RedisSessionDAO sessionDAO() {
        RedisSessionDAO redisSessionDAO = new RedisSessionDAO();
        redisSessionDAO.setRedisManager(redisManager());
        return redisSessionDAO;
    }


    /**
     * 缓存管理
     **/
    @Bean
    public CacheManager cacheManager() {
        RedisCacheManager redisCacheManager = new RedisCacheManager();
        redisCacheManager.setRedisManager(redisManager());
        return redisCacheManager;
    }


    /**
     * 权限管理
     **/
    @Bean
    public MyShiroRealm myShiroRealm() {

        return new MyShiroRealm();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 2、MyShiroRealm 用户身份验证、自定义权限。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MyShiroRealm extends AuthorizingRealm {

    private Logger logger= LoggerFactory.getLogger(MyShiroRealm.class);

    @Resource
    UserDao userDao;


    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        logger.info(&quot;===================权限验证==================&quot;);
        return null;
    }



    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {

        UsernamePasswordToken token=(UsernamePasswordToken) authenticationToken;
        User currentUser=userDao.findUser(token.getUsername());
        if(null == currentUser){
            throw new AuthenticationException(&quot;账户不存在&quot;);
        }

        if(!currentUser.getPassword().equals(new String(token.getPassword()))){
            throw new IncorrectCredentialsException(&quot;账户密码不正确&quot;);
        }

        if(currentUser.getIsdel()==1){
            throw new LockedAccountException(&quot;账户已冻结&quot;);
        }

        Subject subject = SecurityUtils.getSubject();

        BIUser biUser=new BIUser();
        biUser.setUserId(currentUser.getUserId());
        biUser.setOrgId(currentUser.getOrgid());
        biUser.setUserName(currentUser.getUsername());
        biUser.setPassword(currentUser.getPassword());
        biUser.setSessionId(subject.getSession().getId().toString());
        biUser.setIsdel(currentUser.getIsdel());
        biUser.setCreateTime(currentUser.getCreatetime());

        logger.info(&quot;======已授权&quot;+biUser.toString()+&quot;====&quot;);

        return new SimpleAuthenticationInfo(biUser,biUser.getPassword(),biUser.getUserName());
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 3、MySessionManager。shiro权限验证是根据客户端Cookie中的JSESSIONID值来确定身份是否合格。前后端分离后这个地方需要处理。客户端调用服务端登陆接口，验证通过后返回给客户端一个token值（这里我放的是sessionid）。客户端保存token值，然后调用其他接口时把token值放在header中。对前端来说也就是放在ajax的headers参数中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MySessionManager extends DefaultWebSessionManager {

    private static final String AUTHORIZATION = &quot;Authorization&quot;;

    private static final String REFERENCED_SESSION_ID_SOURCE = &quot;Stateless request&quot;;

    public MySessionManager() {
    }

    @Override
    protected Serializable getSessionId(ServletRequest request, ServletResponse response) {
        //从前端ajax headers中获取这个参数用来判断授权
        String id = WebUtils.toHttp(request).getHeader(AUTHORIZATION);
        if (StringUtils.hasLength(id)) {
            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE, REFERENCED_SESSION_ID_SOURCE);
            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID, id);
            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID, Boolean.TRUE);
            return id;
        } else {
            //从前端的cookie中取值
            return super.getSessionId(request, response);
        }

    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4、MyFormAuthorizationFilter。对于跨域的POST请求，浏览器发起POST请求前都会发送一个OPTIONS请求已确定服务器是否可用，OPTIONS请求通过后继续执行POST请求，而shiro自带的权限验证是无法处理OPTIONS请求的，所以这里需要重写&lt;strong&gt;isAccessAllowed&lt;/strong&gt;方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class MyFormAuthorizationFilter extends FormAuthenticationFilter {
    protected boolean isAccessAllowed(ServletRequest servletRequest, ServletResponse servletResponse, Object o) {
        HttpServletRequest httpServletRequest = WebUtils.toHttp(servletRequest);
        if (&quot;OPTIONS&quot;.equals(httpServletRequest.getMethod())) {
            return true;
        }
        return super.isAccessAllowed(servletRequest, servletResponse, o);
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、处理跨域&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping(&quot;/**&quot;)
                .allowedOrigins(&quot;*&quot;)
                .allowedMethods(&quot;PUT&quot;, &quot;DELETE&quot;, &quot;GET&quot;, &quot;POST&quot;)
                .allowedHeaders(&quot;*&quot;)
                .exposedHeaders(&quot;access-control-allow-headers&quot;, &quot;access-control-allow-methods&quot;, &quot;access-control-allow&quot; +
                        &quot;-origin&quot;, &quot;access-control-max-age&quot;, &quot;X-Frame-Options&quot;,&quot;Authorization&quot;)
                .allowCredentials(false).maxAge(3600);

    }
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Thu, 27 Jun 2019 00:42:00 +0000</pubDate>
<dc:creator>garfieldzf</dc:creator>
<og:description>前言 这次在处理一个小项目时用到了前后端分离，服务端使用springboot2.x。权限验证使用了Shiro。前后端分离首先需要解决的是跨域问题，POST接口跨域时会预发送一个OPTIONS请求，浏览</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sword-successful/p/11093803.html</dc:identifier>
</item>
<item>
<title>泡一杯茶，学一学同异步 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/11094896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/11094896.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/a49510e0f4294270bf317eaa9a8921c8_0065_01.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Java 多线程系列文章第 2 篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来几篇会给大家屡清楚多线程中涉及到的一些概念，理解了这些概念，往后的文章才好明白。&lt;/p&gt;
&lt;p&gt;今天给大家讲讲&lt;strong&gt;同步&lt;/strong&gt;和&lt;strong&gt;异步&lt;/strong&gt;这兄弟俩。&lt;/p&gt;
&lt;h2 id=&quot;同步-异步&quot;&gt;同步 &amp;amp; 异步&lt;/h2&gt;
&lt;p&gt;通过咱们现实中的一个场景来描述这 2 个干巴巴的词。大家身边不知道有木有朋友是潮汕的？潮汕地区每家每户都有功夫茶，只要来客人，一定会用功夫茶来招待。功夫茶关键在于&lt;strong&gt;功夫&lt;/strong&gt;两字，&lt;strong&gt;功夫&lt;/strong&gt;指的是泡茶方式比较讲究，它不像咱上班时用保温瓶泡茶，而是有一道泡茶的流程和工具。下面在网上找到的&lt;strong&gt;功夫茶口诀&lt;/strong&gt;（作为潮汕人这么久，都不知道有这口诀，是听我女朋友说有这个口诀才知道。。。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;潮汕功夫茶冲泡口诀：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;白鹤沐浴(洗杯)：用开水洗净茶杯并提高茶具温度。&lt;/li&gt;
&lt;li&gt;观音入宫(落茶)：把铁观音茶放入茶具，放茶量约占茶具容量的五分。&lt;/li&gt;
&lt;li&gt;悬壶高冲(冲茶)：把滚开的水提高冲入茶壶或盖瓯，使茶叶转动。&lt;/li&gt;
&lt;li&gt;春风拂面(刮泡沫)：用壶盖或瓯盖轻轻刮去漂浮的白泡沫，使其清新洁净。&lt;/li&gt;
&lt;li&gt;关公巡城(倒茶)：把泡一、二分钟后的茶水依次巡回注入并列的茶杯里。&lt;/li&gt;
&lt;li&gt;韩信点兵(点茶)：茶水倒到少许时要一点一点均匀地滴到各杯中，使其浓淡均匀。&lt;/li&gt;
&lt;li&gt;鉴尝汤色(看茶)：观赏杯中茶水的颜色，闻茶之香气。&lt;/li&gt;
&lt;li&gt;品啜甘霖(喝茶)：乘热细缀，先嗅其香，后尝其味，边啜边嗅，浅斟细饮。饮量虽不多，但能齿颊留香，喉底回甘，心旷神怡，别有情趣。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有客人来的时候，我们会先煮水，没等到水煮沸就先洗茶杯，落茶，等到水煮沸了，再冲茶，倒茶。这个过程中，有些步骤是同步的，比如洗茶杯和落茶，肯定要把茶杯先洗干净后再落茶，一个人没法同时干这 2 件事，我们关注点放在煮水这个过程，是先煮水，煮水需要比较长的时间，煮水的过程中把茶杯洗了，还有落茶，这个过程其实就是&lt;strong&gt;异步&lt;/strong&gt;，异步指没有干等待水煮沸，在煮水的过程做其他事情（洗茶杯、落茶），这就像是发送了一个消息，通知说要煮水，然后就继续自己该干嘛干嘛，异步的过程完全不影响当前做的其他事。下图反映了煮水步骤是异步的这个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/0bbe45d179aa4becbf5719b0c3a46845_0065_02.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果主人用下面方式来泡茶，不是新手就是不欢迎你（开玩笑，有可能是主人一见如故，想趁着煮水和你唠家常）。上面讲了异步泡茶的方式，下面讲同步泡茶是啥回事。看下图，把煮水这个过程放在了时间线下方，也就是在煮水的时候干等着水煮沸，不做其他的事情，这就是&lt;strong&gt;同步&lt;/strong&gt;，很明显，最后整个泡茶的过程耗时比异步的长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/ba2bde5d6ca24c6287f7b0778fecccd0_0065_03.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这里在简单总结一下（如有错误请大家帮忙纠正）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步（Synchronous）&lt;/strong&gt;：特指在同一个线程里面执行的内容之间的关系是有顺序的；线程之间需要同步时，就需要使用一些显式的同步方式，这也是多线程带来的大问题，在多线程编程需要特别关注。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异步（Asynchronous）&lt;/strong&gt;：特指一些执行内容可以不用直接等待运行结果，异步执行的内容一般是在另一个线程运行，只需要运行完结果反馈回来就行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;推荐阅读&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/HJIVxnzyDesYPGGyJsaFyQ&quot;&gt;进程知多少？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/WiPwb7AyVlxyr1_kYXt96w&quot;&gt;设计模式看了又忘，忘了又看？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;公众号后台回复『设计模式』可以获取《一故事一设计模式》电子书&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;觉得文章有用帮忙转发&amp;amp;点赞，多谢朋友们！&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/c50a23a8826d45a7b66b3be24c89205e_.jpg&quot; alt=&quot;LieBrother&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 27 Jun 2019 00:30:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>Java 多线程系列文章第 2 篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liebrother/p/11094896.html</dc:identifier>
</item>
<item>
<title>案例解析：springboot自动配置未生效问题定位（条件断点） - 【空山新雨】</title>
<link>http://www.cnblogs.com/spec-dog/p/11094890.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spec-dog/p/11094890.html</guid>
<description>
&lt;p&gt;Spring Boot在为开发人员提供更高层次的封装，进而提高开发效率的同时，也为出现问题时如何进行定位带来了一定复杂性与难度。但Spring Boot同时又提供了一些诊断工具来辅助开发与分析，如spring-boot-starter-actuator。本文分享一个基于actuator与IDEA条件断点来定位自动配置未生效的案例。望对类似问题分析与处理提供参考。&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注我的微信公众号：jboost-ksxy &lt;/p&gt;
&lt;h3 id=&quot;问题确认&quot;&gt;问题确认&lt;/h3&gt;
&lt;p&gt;在前文介绍的 &lt;a href=&quot;http://blog.jboost.cn/2019/06/24/springboot-tkmapper.html&quot;&gt;Spring Boot从入门到实战：整合通用Mapper简化单表操作&lt;/a&gt; 中，我们对druid连接池做了自动配置，并且注入了druid的监控统计功能，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pso1tuwfq.bkt.clouddn.com/statviewservlet.png&quot; alt=&quot;druidstat&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但本地运行后通过 &lt;a href=&quot;http://localhost:8080/druid/index.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/druid/index.html&lt;/a&gt; 访问时却出现错误，通过浏览器的开发者工具查看该请求返回404，推测上述代码中定义的&lt;code&gt;StatViewServlet&lt;/code&gt;未注入成功。我们用actuator来确认下是否如此。在项目中加入spring-boot-starter-actuator，并且application.yml中添加如下配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;management:
    endpoints:
        web:
            exposure:
                include: &quot;*&quot;
                exclude: beans,trace
    endpoint:
        health:
            show-details: always&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;在spring-boot 2.x 版本当中，作为安全性考虑，将actuator 控件中的端口，只默认开放/health 和/info 两个端口，其他端口默认关闭， 因此需要添加如上配置。注意include的值 &lt;/span&gt;&lt;code&gt;*&lt;/code&gt;&lt;span&gt; 必须加引号，否则无法启动。&lt;/span&gt; &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;重启程序后访问 &lt;a href=&quot;http://localhost:8080/actuator/conditions&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/actuator/conditions&lt;/a&gt; 确认上述两个实例化方法未满足&lt;code&gt;@ConditionalOnProperty&lt;/code&gt;的条件，从而未执行生效，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pso1tuwfq.bkt.clouddn.com/actuatorconditions.png&quot; alt=&quot;actuator&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3 id=&quot;条件断点&quot;&gt;条件断点&lt;/h3&gt;
&lt;p&gt;从上面分析确认是因为条件注解 &lt;code&gt;@ConditionalOnProperty(prefix = &quot;spring.datasource.druid&quot;, name = &quot;druidServletSettings&quot;)&lt;/code&gt; 未满足使方法未执行导致。那这个条件为什么没有满足呢，查看application.yml中也做了 spring.datasource.druid.druidServletSettings属性的配置。&lt;/p&gt;
&lt;p&gt;当你无法理清头绪，确定问题原因时，那就Debug吧。查看注解&lt;code&gt;@ConditionalOnProperty&lt;/code&gt;源码，找到其实现支持类&lt;code&gt;OnPropertyCondition&lt;/code&gt;，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
@Documented
@Conditional({OnPropertyCondition.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ConditionalOnProperty {
    String[] value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String prefix() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    String[] name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; {};

    String havingValue() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; matchIfMissing() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看&lt;code&gt;OnPropertyCondition&lt;/code&gt;源码，了解它是通过&lt;code&gt;getMatchOutcome&lt;/code&gt;方法来判断是否满足注解参数所指定的条件的，如下所示 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ConditionOutcome getMatchOutcome(ConditionContext context,
        AnnotatedTypeMetadata metadata) {
    List&lt;/span&gt;&amp;lt;AnnotationAttributes&amp;gt; allAnnotationAttributes =&lt;span&gt; annotationAttributesFromMultiValueMap(
            metadata.getAllAnnotationAttributes(
                    ConditionalOnProperty.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName()));
    List&lt;/span&gt;&amp;lt;ConditionMessage&amp;gt; noMatch = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    List&lt;/span&gt;&amp;lt;ConditionMessage&amp;gt; match = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (AnnotationAttributes annotationAttributes : allAnnotationAttributes) {
        ConditionOutcome outcome &lt;/span&gt;=&lt;span&gt;&lt;span&gt; determineOutcome&lt;/span&gt;(annotationAttributes,
                context.getEnvironment());
        (outcome.isMatch() &lt;/span&gt;?&lt;span&gt; match : noMatch).add(outcome.getConditionMessage());
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;noMatch.isEmpty()) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ConditionOutcome.noMatch(ConditionMessage.of(noMatch));
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ConditionOutcome.match(ConditionMessage.of(match));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在调用&lt;code&gt;determineOutcome&lt;/code&gt;处打断点，调试什么原因导致条件未满足，但是这里是一个for循环，如果for元素过多的话，将可能需要断点阻断很多次才能找到你想要查看的那个元素。所幸IDEA提供了不同类型的断点来处理这类问题，前面 &lt;a href=&quot;http://blog.jboost.cn/2019/06/21/issue-errortrack.html&quot;&gt;案例解析：使用IDEA异常断点来定位java.lang.ArrayStoreException的问题&lt;/a&gt; 我们介绍了异常断点的使用。这里介绍用条件断点来处理这类循环块中的debug问题。 &lt;/p&gt;
&lt;p&gt;在上述代码for循环中调用&lt;code&gt;determineOutcome&lt;/code&gt;行打断点，并在断点上右键，弹出如下窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pso1tuwfq.bkt.clouddn.com/conditionbreak.png&quot; alt=&quot;条件断点&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中Condition框即可输入你要指定的条件，可以直接写java判断表达式代码，并引用该行代码处能访问的变量，如这里我们输入 &lt;code&gt;annotationAttributes.get(&quot;name&quot;).equals(&quot;druidServletSettings&quot;)&lt;/code&gt;，然后点击Debug窗口的“Resume Program (F9)”按钮，则在不满足指定条件时，断点处将不会被阻断，直到条件满足，这样就能很容易定位到我们想要查看的元素。（当然这里&lt;code&gt;allAnnotationAttributes&lt;/code&gt;变量其实只有一个元素，仅仅是为了演示条件变量的使用，当集合元素很多时，使用条件断点就能体会到它的方便之处）&lt;/p&gt;
&lt;h3&gt;问题定位&lt;/h3&gt;
&lt;p&gt;通过Debug的方式深入条件注解的判断逻辑（其中循环处可使用条件断点），最终来到如下代码片段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pso1tuwfq.bkt.clouddn.com/conditonbreak3.png&quot; alt=&quot;判断条件&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里是判断来自所有属性源配置的属性中，是否包含条件注解指定的属性，即&lt;code&gt;spring.datasource.druid.druidServletSettings&lt;/code&gt;，由上图可见，&lt;code&gt;spring.datasource.druid.druidServletSettings&lt;/code&gt;只是某些属性的前缀，并不存在完全匹配的属性，因此返回false，导致条件不满足。回看注解@ConditionOnProperty的javadoc，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
*&lt;span&gt; If the property is not contained in the {@link Environment} at all, the
 &lt;/span&gt;* {@link #matchIfMissing()} attribute is consulted. By &lt;span&gt;default&lt;/span&gt; missing attributes &lt;span&gt;do&lt;/span&gt;&lt;span&gt; not
 &lt;/span&gt;*&lt;span&gt; match.
 &lt;/span&gt;* &amp;lt;p&amp;gt;
 * This condition cannot be reliably used &lt;span&gt;for&lt;/span&gt;&lt;span&gt; matching collection properties. For example,
 &lt;/span&gt;* in the following configuration, the condition matches &lt;span&gt;if&lt;/span&gt;&lt;span&gt; {@code spring.example.values}
 &lt;/span&gt;* is present in the {@link Environment} but does not match &lt;span&gt;if&lt;/span&gt;
 * {@code spring.example.values[0&lt;span&gt;]} is present.
 &lt;/span&gt;*
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当Environment中不包含该属性时，则看matchIfMissing的值，该值默认为false，如果包含该属性，则再对比属性值与havingValue的值，相等即满足，不等则不满足。并且该条件注解不能用于匹配集合类型属性。上述&lt;code&gt;spring.datasource.druid.druidServletSettings&lt;/code&gt;实际上属于一个Map类型，因此不能想当然地认为该注解是只要属性集中某属性名称包含该值即满足。 &lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;当难以定位到问题原因时，可以进行Debug，跟踪程序运行的各个步骤，当要在循环中Debug定位到某个元素时，可以用条件断点来实现。@ConditionalOnProperty注解不是存在某属性就行，还需要值相等，并且不适用于集合类型属性。&lt;/p&gt;&lt;p&gt;我的个人博客地址：&lt;a href=&quot;http://blog.jboost.cn/&quot;&gt;http://blog.jboost.cn&lt;/a&gt;&lt;br/&gt;我的github地址：&lt;a href=&quot;https://github.com/ronwxy&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://github.com/ronwxy&lt;/a&gt;&lt;br/&gt;我的微信公众号：jboost-ksxy&lt;/p&gt;
&lt;p&gt;———————————————————————————————————————————————————————————————&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pso1tuwfq.bkt.clouddn.com/qrcode-05.jpg&quot; alt=&quot;微信公众号&quot;/&gt;&lt;br/&gt;欢迎关注我的微信公众号，及时获取最新分享&lt;/p&gt;
</description>
<pubDate>Thu, 27 Jun 2019 00:23:00 +0000</pubDate>
<dc:creator>【空山新雨】</dc:creator>
<og:description>Spring Boot在为开发人员提供更高层次的封装，进而提高开发效率的同时，也为出现问题时如何进行定位带来了一定复杂性与难度。但Spring Boot同时又提供了一些诊断工具来辅助开发与分析，如sp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/spec-dog/p/11094890.html</dc:identifier>
</item>
<item>
<title>kubernetes之使用http rest api访问集群 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11094872.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11094872.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Kubernetes集群中，API Server是集群管理API的入口，由运行在Master节点上的一个名为kube-apiserver的进程提供的服务。 用户进入API可以通过kubectl、客户端库或者http rest，User 或者 Service Account可以被授权进入API。当一个请求到达API时， 往往要经过几个阶段的安全控制，在一个典型的应用集群中，API Server通常会使用自签名的证书提供HTTPS服务，同时开启认证与授权等安全机制。&lt;/p&gt;
&lt;p&gt;通常，在Kubernetes集群搭建之后，除了使用官方的kubectl工具与API Server进行交互，我们还可以使用Postman或者curl了，有些时候直接使用curl功能更强大， 与API Server交互通常需要首先创建一个有正确权限的ServiceAccount，这个ServiceAccount通过ClusterRole/Role、ClusterRoleBinding/RoleBinding等给其赋予相关资源的操作权限， 而Service Account对应的Token则用于API Server进行基本的认证。与API Server的交互是基于TLS，所以请求的时候还需要自签名的证书，当然也可以非安全方式连接API Server， 但是不推荐。&lt;/p&gt;
&lt;h2 id=&quot;创建serviceaccount&quot;&gt;创建ServiceAccount&lt;/h2&gt;
&lt;p&gt;前面我们讲到过ServiceAccount,它类似于传统登陆里的用户.创建一个ServiceAccount以后,会自动为它创建一个关联的secret(密钥)&lt;/p&gt;
&lt;p&gt;我们创建一个名为&lt;code&gt;apiviewer&lt;/code&gt;的ServiceAccount&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl create sa apiviewer
serviceaccount/apiviewer created&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以查看这个sa对应的secret的名字&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl get sa apiviewer  -ojson
{
    &quot;apiVersion&quot;: &quot;v1&quot;,
    &quot;kind&quot;: &quot;ServiceAccount&quot;,
    &quot;metadata&quot;: {
        &quot;creationTimestamp&quot;: &quot;2019-05-27T08:09:56Z&quot;,
        &quot;name&quot;: &quot;apiviewer&quot;,
        &quot;namespace&quot;: &quot;default&quot;,
        &quot;resourceVersion&quot;: &quot;16750207&quot;,
        &quot;selfLink&quot;: &quot;/api/v1/namespaces/default/serviceaccounts/apiviewer&quot;,
        &quot;uid&quot;: &quot;d078f034-8056-11e9-99bc-0050568417a2&quot;
    },
    &quot;secrets&quot;: [
        {
            &quot;name&quot;: &quot;apiviewer-token-z5bpq&quot;
        }
    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用&lt;code&gt;secretes&lt;/code&gt;里的&lt;code&gt;name&lt;/code&gt;去查看这个secretes的值&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;apiviewer-token-z5bpq[centos@k8s-master ~]$ kubectl describe secret apiviewer-token-z5bpq
Name:         apiviewer-token-z5bpq
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  kubernetes.io/service-account.name: apiviewer
              kubernetes.io/service-account.uid: d078f034-8056-11e9-99bc-0050568417a2

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1025 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImFwaXZpZXdlci10b2tlbi16NWJwcSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhcGl2aWV3ZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJkMDc4ZjAzNC04MDU2LTExZTktOTliYy0wMDUwNTY4NDE3YTIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6ZGVmYXVsdDphcGl2aWV3ZXIifQ.GUd7uCwTntMXhwXEGFvo62tJBTVdI_SNATDIbuxINmbmBI2bjHuQ-whRE5183AXqWiifoM0HjOGoams11f_R2Dtak3fRxPLNRGGFTMyUN1uHmwedPmsAK0GTW0xPgInyIy4SF-uI7lghrpsRzBQ4AmA2AuctwCGdXUC3YuqrZPEnla3HeF6Tz72KpddlgiA3N1T5yvoOHPL4AgQRDPGKJ6L-nEdXumg3BlTWR0ENBNgzAz2eh6RZLRSsKlG0zQ8vhApkMGru7k5a_PKkU3Z3b0ZhKBKmE_LsMJ7bAunr9J9bbG--Id4rnuPpcj1DoJ0ZlJ3G1IP3xTUVncxO_gV4VQ
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们熟练了可以使用一条命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;apiviewer-token-z5bpq[centos@k8s-master ~]$ kubectl describe secret `kubectl get sa apiviewer -ojsonpath='{.secrets[0].name}'`
Name:         apiviewer-token-z5bpq
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  kubernetes.io/service-account.name: apiviewer
              kubernetes.io/service-account.uid: d078f034-8056-11e9-99bc-0050568417a2

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1025 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImFwaXZpZXdlci10b2tlbi16NWJwcSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhcGl2aWV3ZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJkMDc4ZjAzNC04MDU2LTExZTktOTliYy0wMDUwNTY4NDE3YTIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6ZGVmYXVsdDphcGl2aWV3ZXIifQ.GUd7uCwTntMXhwXEGFvo62tJBTVdI_SNATDIbuxINmbmBI2bjHuQ-whRE5183AXqWiifoM0HjOGoams11f_R2Dtak3fRxPLNRGGFTMyUN1uHmwedPmsAK0GTW0xPgInyIy4SF-uI7lghrpsRzBQ4AmA2AuctwCGdXUC3YuqrZPEnla3HeF6Tz72KpddlgiA3N1T5yvoOHPL4AgQRDPGKJ6L-nEdXumg3BlTWR0ENBNgzAz2eh6RZLRSsKlG0zQ8vhApkMGru7k5a_PKkU3Z3b0ZhKBKmE_LsMJ7bAunr9J9bbG--Id4rnuPpcj1DoJ0ZlJ3G1IP3xTUVncxO_gV4VQ&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然,也可以使用jq工具&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl describe secret `kubectl get sa apiviewer -ojson|jq -r  .secrets[].name`
Name:         apiviewer-token-z5bpq
Namespace:    default
Labels:       &amp;lt;none&amp;gt;
Annotations:  kubernetes.io/service-account.name: apiviewer
              kubernetes.io/service-account.uid: d078f034-8056-11e9-99bc-0050568417a2

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1025 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImFwaXZpZXdlci10b2tlbi16NWJwcSIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50Lm5hbWUiOiJhcGl2aWV3ZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiJkMDc4ZjAzNC04MDU2LTExZTktOTliYy0wMDUwNTY4NDE3YTIiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6ZGVmYXVsdDphcGl2aWV3ZXIifQ.GUd7uCwTntMXhwXEGFvo62tJBTVdI_SNATDIbuxINmbmBI2bjHuQ-whRE5183AXqWiifoM0HjOGoams11f_R2Dtak3fRxPLNRGGFTMyUN1uHmwedPmsAK0GTW0xPgInyIy4SF-uI7lghrpsRzBQ4AmA2AuctwCGdXUC3YuqrZPEnla3HeF6Tz72KpddlgiA3N1T5yvoOHPL4AgQRDPGKJ6L-nEdXumg3BlTWR0ENBNgzAz2eh6RZLRSsKlG0zQ8vhApkMGru7k5a_PKkU3Z3b0ZhKBKmE_LsMJ7bAunr9J9bbG--Id4rnuPpcj1DoJ0ZlJ3G1IP3xTUVncxO_gV4VQ&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建clusterrolerolebinding&quot;&gt;创建ClusterRole、RoleBinding&lt;/h2&gt;
&lt;p&gt;我们可以从头创建一个ClusterRole,但是k8s集群里默认也是有若干个ClusterRole的,我们可以通过&lt;code&gt;kubectl get clusterrole&lt;/code&gt;来查看都有哪些clusterrole,这里我们使用一个名为&lt;code&gt;cluster-admin&lt;/code&gt;,把刚创建的ServiceAccount与它绑定&lt;/p&gt;
&lt;p&gt;创建RoleBinding的命令如下&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$  kubectl create rolebinding apiadmin --clusterrole cluster-admin --serviceaccount default:apiviewer
rolebinding.rbac.authorization.k8s.io/apiadmin created&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取Bearer Token、Certificate、API Server URL&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ SECRET=$(kubectl get serviceaccount ${SERVICE_ACCOUNT} -ojsonpath='{.secrets[0].name}')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这条命令用于获取SECRET的名称,上面我们已经讲到过.&lt;/p&gt;
&lt;p&gt;然后我们就可以用secret的名称来获取token了,前面也是讲到过的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TOKEN=$(kubectl get secret ${SECRET} -ojsonpath='{.data.token}'|base64 -d)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;使用jsonpath时,我们需要预先知道json的结构,比较笨但是往往非常有效的办法是先把整个json全部输出出来,然后再根据结构截取.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于token是经过base64编码过的,因此需要base64解码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面从secret里把证书提取出来&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt; kubectl get secret ${SECRET} -o jsonpath=&quot;{.data['ca\.crt']}&quot; | base64 -d &amp;gt; /tmp/ca.crt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取API Server URL，如果API Server部署在多台Master上，只需访问其中一台即可。&lt;br/&gt;APISERVER=https://$(kubectl -n default get endpoints kubernetes --no-headers | awk '{ print $2 }' | cut -d &quot;,&quot; -f 1)&lt;/p&gt;
&lt;p&gt;通过jq -r提取所有的Pod名字&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;curl -s $APISERVER/api/v1/namespaces/default/pods/ --header &quot;Authorization: Bearer $TOKEN&quot; \
&amp;gt; --cacert /tmp/ca.crt  | jq -r '.items[].metadata.name'&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;由于这里不是kubectl命令,无法再直接通过jsonpath过滤结果,这里我们使用jq工具来过滤.关于jq工具本章节前面部分也有介绍.想详细了解的童鞋可以参考一下.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 27 Jun 2019 00:02:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 在Kubernetes集群中，API Server是集群管理API的入口，由运行在Master节点上的一个名为kube apiserver的进程提供的服务。 用户进入API可以通过kub</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11094872.html</dc:identifier>
</item>
<item>
<title>高仿富途牛牛-组件化(六)-炒鸡牛逼的布局记忆功能(序列化和反序列化) - 朝十晚八</title>
<link>http://www.cnblogs.com/swarmbees/p/11094667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swarmbees/p/11094667.html</guid>
<description>&lt;h2 id=&quot;一布局记忆&quot;&gt;一、布局记忆&lt;/h2&gt;
&lt;p&gt;一款优秀的软件，不仅仅要求功能强健、稳定性高和可靠的精准率，往往很多时候我们都需要去关注用户界面是否友好，用户操作是否顺畅，软件跨机器使用到底咋样。&lt;/p&gt;
&lt;p&gt;说起到怎么让用户交互友好，这就是用户体验和视觉设计师的主场啦。这里我就不多说了，今天主要是想说明一个问题--布局记忆功能&lt;/p&gt;
&lt;p&gt;现在客户端软件各式各样，种类多了去了，但是不知道大家有没有注意到有这么一些交互上的细节。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用过QQ的同学应该都比较清楚。我们在QQ使用时，除过第一次登录QQ软件，其余时间段登录QQ时，QQ的初始位置往往会是上一次退出时的位置&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;windows资源管理器我们大家应该都经常在使用，不知道大家有没有仔细观察。我们修改了资源管理器窗口大小后，再次打开资源管理器窗口时，新的窗口大小和我们之前修改后的窗口大小一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;firefox邮件客户端，大家都用过吧，也是会记忆窗口最后&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;还有一些工具软件，比如说PicPick，选择的使用模式会一直记录&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;QQ飞车是一款腾讯出的客户端游戏，他支持多种显示模式，设置一次后，会一直生效，直到我们再次设置为止。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上是我随便写的几个数据记忆的事例，相信大家都不陌生。除过这些简单的数据持久化以外，其实还有很多其他的事例，这里就不一一例举了。&lt;/p&gt;
&lt;p&gt;今天我们主要是想给大家展示下我们负责窗口布局是怎么进行布局记忆的。&lt;/p&gt;
&lt;h2 id=&quot;二效果展示&quot;&gt;二、效果展示&lt;/h2&gt;
&lt;p&gt;窗口布局记忆如效果图所示。&lt;/p&gt;
&lt;p&gt;当我们通过主窗口关闭了软件时，程序会自动把布局信息序列化成字符串，然后进行保存。&lt;/p&gt;
&lt;p&gt;再次启动软件时，我们首先会去加载序列化的布局信息，然后进行解析布局信息，并构造我们的窗口，这个工程称之为反序列化。&lt;/p&gt;
&lt;center&gt;
&lt;div&gt;&lt;img src=&quot;https://www.cnblogs.com/images/cnblogs_com/swarmbees/1482844/o_layout_persistence.gif&quot;/&gt;&lt;/div&gt;
&lt;/center&gt;
&lt;h2 id=&quot;三重点回顾&quot;&gt;三、重点回顾&lt;/h2&gt;
&lt;h3 id=&quot;窗口管理&quot;&gt;1、窗口管理&lt;/h3&gt;
&lt;p&gt;之前我已经写了好几天文章都是讲组件化相关的东西，其中有一篇文章&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11062824.html&quot;&gt;高仿富途牛牛-组件化(五)-如何去管理炒鸡多的小窗口&lt;/a&gt;主要是讲解怎么去管理过多的小窗口，主要是把创建的过程进行了封装，让外界使用起来更加的接口化。&lt;/p&gt;
&lt;p&gt;本篇文章主要是讲述布局怎么去记忆？记忆后又是怎么去恢复？关于窗口创建和消息通信这里我就不在去讲解了。感兴趣的同学可以翻看之前的文章，因为我的这个demo是在一直的维护，更新过程中，因此讲到这篇文章的时候，之前的一些主题中的方式、方法可能已经发现了变化，如果有问题的欢迎留言。&lt;/p&gt;
&lt;h3 id=&quot;页签tabbutton&quot;&gt;2、页签TabButton&lt;/h3&gt;
&lt;p&gt;一个组件窗口中同时只允许一个页签被选中，选中另一个页签时，其他的页签都会被重置为非选中状态。&lt;/p&gt;
&lt;p&gt;TabButton是一个复杂的小窗口，支持同一个工具栏内拖拽，也支持多个工具栏之间拖拽。&lt;/p&gt;
&lt;h3 id=&quot;子面板subpanel&quot;&gt;3、子面板SubPanel&lt;/h3&gt;
&lt;p&gt;每一个组件窗口都包含有多个页签和多个SubPanel，其中SubPanel和页签时一对一的关系。&lt;/p&gt;
&lt;p&gt;我们切换页签的时候，SubPanel也会跟随者切换，而每一个SubPanel上都包含有不同的小窗口，这些小窗口都是由工具箱进行创建的。&lt;/p&gt;
&lt;p&gt;工具箱这里就不在多说了，看展示的效果图，上边就有一个工具箱窗口，当我们点击其上的工具按钮时，就会在当前的SubPanel上创建一个对应的小窗口。&lt;/p&gt;
&lt;h2 id=&quot;四布局记忆内容&quot;&gt;四、布局记忆内容&lt;/h2&gt;
&lt;p&gt;首先我一直强调的是高仿富途牛牛-组件化，因此这里记忆的内容我也是根据福牛的交互行为来记忆的，可能记忆的内容有下面这些，但也可能更多。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;组件窗口个数&lt;/li&gt;
&lt;li&gt;组件窗口位置和大小，包括层次关系&lt;/li&gt;
&lt;li&gt;组件窗口关联的工具箱是否显示和其位置&lt;/li&gt;
&lt;li&gt;工具栏的状态，包括工具按钮状态，页签个数、顺序、名称和当前选中项&lt;/li&gt;
&lt;li&gt;子面板上的小窗口&lt;/li&gt;
&lt;li&gt;小窗口的层次关系、位置和大小&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上内容就是我们序列化时会存储的信息，但又不仅限于这些。&lt;/p&gt;
&lt;h2 id=&quot;五布局信息序列化&quot;&gt;五、布局信息序列化&lt;/h2&gt;
&lt;p&gt;要让布局信息持久化，那么布局信息必然要被我们存储到硬盘上，因此电脑上的内存信息系统重启后就会消息。&lt;/p&gt;
&lt;p&gt;好，那么接下来就是考虑把布局信息写入硬盘，这个时候我们就得找个合适的实际写入时机，目前我写入的时机是在关闭软件的时候，但是这里不建议大家也这么搞，因此这回导致关节关闭有延迟，当我们有大量的数据需要写入的时，可能会影响用户体验。&lt;/p&gt;
&lt;p&gt;关于写入时机选择，不是本篇文章讨论的主要内容，感兴趣的可以自己去研究。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据写入时需要注意，给读取数据时写入一些标志，否则读取数据时如果包含一些循环，则不知道循环应该什么时候结束。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;流程&quot;&gt;1、流程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;主组件窗口关闭时，开始序列化布局信息&lt;/li&gt;
&lt;li&gt;首先写入组件窗口个数，方便后期读数据&lt;/li&gt;
&lt;li&gt;工具栏按钮状态写入&lt;/li&gt;
&lt;li&gt;工具栏页签个数写入&lt;/li&gt;
&lt;li&gt;工具栏页签循环写入&lt;/li&gt;
&lt;li&gt;工具栏页签选中项index写入&lt;/li&gt;
&lt;li&gt;工具箱大小和位置写入&lt;/li&gt;
&lt;li&gt;循环子面板SubPanel&lt;/li&gt;
&lt;li&gt;写入SubPanel中所有小窗体信息&lt;/li&gt;
&lt;li&gt;小窗体信息吸入：标题栏名称、所属组、窗口大小、位置等&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;主流程写入&quot;&gt;2、主流程写入&lt;/h3&gt;
&lt;p&gt;窗口信息使用二进制的方式写入文件，由于现在是demo阶段，因此这里为了方便测试，随手写了一个文件路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void TemplateLayout::SaveMainLayout()
{
    Q_ASSERT(m_pToolBar);

    QString path = &quot;d:\\main.ttlayout&quot;;
    QFile file(path);
    if (file.open(QIODevice::WriteOnly | QIODevice::Truncate))
    {
        QDataStream in(&amp;amp;file);

        int count = templates.size();
        in &amp;lt;&amp;lt; count;//存储组件窗口个数

        //从最下面一级的窗体开始序列化
        for (int i = templates.size() - 1; i &amp;gt;= 0; --i)
        {
            TemplateLayout * widget = templates.at(i);
            widget-&amp;gt;m_pToolBar-&amp;gt;SaveLayout(in);
            in &amp;lt;&amp;lt; QString(&quot;toolBar&quot;);//toolBar结束标志

            widget-&amp;gt;SaveToolBox(in);

            widget-&amp;gt;m_pPanel-&amp;gt;SaveLayout(in);
            in &amp;lt;&amp;lt; QString(&quot;panels&quot;);//panel结束标志
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;从最下面一级的组件窗体开始序列化，主要创建的时候，就是自下而上创建，窗口的z值就不存在问题。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;序列化代码主体流程看起来就像上边这样，我们使用QDataStream来进行二进制信息的写入。&lt;/p&gt;
&lt;p&gt;在整个写入的过程中，我们使用了一个QDataStream对象，并把文件作为他的输入设备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里需要注意一点，我们不能在函数调用过程中使用多个QDataStream，把每个窗口的布局信息都存储到一个QByteArray中去。因为QDataStream内部在存储数据时，会在末尾加上4个字节的结束符，这样我们在多层嵌套写数据时，虽然没有问题，但是读数据时就会出现问题，这个问题我也是查了好久就通过调试代码发现的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;标签页写入&quot;&gt;3、标签页写入&lt;/h3&gt;
&lt;p&gt;前边我们也说了，我们整个的写入过程都使用了一个QDataStream，内部窗口的写入都是使用了最外层的QDataStream，这里从参数我们也可以看得出来。&lt;/p&gt;
&lt;p&gt;标签页写入方式和之前的模式差不多，主要是存储的数据不同，这里主要存放了3种信息：标签页数量、标签页名称和选中项下标&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void DragTabWidget::SaveLayout(QDataStream &amp;amp; in) const
{
    Q_ASSERT(m_pTabLayout);
    in &amp;lt;&amp;lt;  m_buttonMaps.size();//记录button个数
    int selectedIndex = 0;
    int buttonIndex = 0;
    for (int index = 0; index &amp;lt; m_pTabLayout-&amp;gt;count(); ++index)
    {
        if (TabButton * desButton = dynamic_cast&amp;lt;TabButton *&amp;gt;(m_pTabLayout-&amp;gt;itemAt(index)-&amp;gt;widget()))
        {
            in &amp;lt;&amp;lt; desButton-&amp;gt;Text();
            if (desButton-&amp;gt;IsSelected())
            {
                selectedIndex = buttonIndex;
            }
            ++buttonIndex;
        }
    }
    in &amp;lt;&amp;lt; selectedIndex;//记录选中按钮
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小窗口写入&quot;&gt;4、小窗口写入&lt;/h3&gt;
&lt;p&gt;小窗口写入时，首先写入了的是标题栏的信息，然后在写入窗口自身的位置、大小和窗口类型&lt;/p&gt;
&lt;p&gt;这里需要重点提下窗口类型，这个信息很重要。当我们反序列化的时候，需要根据这个类型来进行创建窗口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void SmallWidget::SaveLayout(QDataStream &amp;amp; in) const
{
    QPoint pos = this-&amp;gt;pos();//保存位置
    QSize size = this-&amp;gt;size();//保存大小
    SubWindowNormalType type = GetSmallType();//保存窗口类型

    m_pTitle-&amp;gt;SaveLayout(in);
    
    in &amp;lt;&amp;lt; pos;
    in &amp;lt;&amp;lt; size;
    in &amp;lt;&amp;lt; (int)type;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其他&quot;&gt;5、其他&lt;/h3&gt;
&lt;p&gt;序列化的整个过程基本都是一样的套路，主要就是使用QDataStream对象把布局信息以二级制的形式写入到硬盘文件中。&lt;/p&gt;
&lt;p&gt;其他的布局信息写入方式大豆差不多，这里就不一一列出。&lt;/p&gt;
&lt;h2 id=&quot;六布局信息反序列化&quot;&gt;六、布局信息反序列化&lt;/h2&gt;
&lt;p&gt;说完序列化后，接下来就是我们的反序列化的过程了。&lt;/p&gt;
&lt;p&gt;反序列化就是序列化的相反过程，主要是我们需要写入正确的信息，然后按写入时的顺序进行读取布局信息即可&lt;/p&gt;
&lt;h3 id=&quot;流程-1&quot;&gt;1、流程&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;启动程序时，打开布局文件&lt;/li&gt;
&lt;li&gt;读出组件窗口个数&lt;/li&gt;
&lt;li&gt;读取工具栏按钮状态&lt;/li&gt;
&lt;li&gt;初始化页签，这个时候SubPanel也会被初始化&lt;/li&gt;
&lt;li&gt;初始化页签选中项&lt;/li&gt;
&lt;li&gt;读取工具箱大小和位置&lt;/li&gt;
&lt;li&gt;初始化各子面板上的小窗口&lt;/li&gt;
&lt;li&gt;循环第三步&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;反序列化主流程&quot;&gt;2、反序列化主流程&lt;/h3&gt;
&lt;p&gt;反序列化就是序列化的逆序，不过这里需要注意的一个地方就是，我们序列化的时候，主窗口时最后保存的，因此反序列化的时候，主窗口也是最后才进行初始化的。&lt;/p&gt;
&lt;p&gt;注意代码中的if (i == count - 1)这个if判断，就是处理主窗口初始化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void TemplateLayout::RestoreLayout()
{
    QString path = &quot;d:\\main.ttlayout&quot;;
    QFile file(path);
    if (file.open(QIODevice::ReadOnly))
    {
        QDataStream out(&amp;amp;file);

        int count;
        out &amp;gt;&amp;gt; count;//存储组件窗口个数
        
        for (int i = 0; i &amp;lt; count; ++i)
        {
            TemplateLayout * widget = nullptr; 
            if (i == count - 1)//最后一个是主窗口
            {
                widget = this; 
            }
            else
            {
                widget = new TemplateLayout;
                widget-&amp;gt;setWindowFlags(Qt::FramelessWindowHint);
                widget-&amp;gt;m_pToolBar-&amp;gt;SetMoveable(true);
                widget-&amp;gt;SetIsMajor(false);
                widget-&amp;gt;show();
            }
            widget-&amp;gt;m_pToolBar-&amp;gt;LoadLayout(out);

            QString toolSign;
            out &amp;gt;&amp;gt; toolSign;//toolBar结束标志
            Q_ASSERT(toolSign == &quot;toolBar&quot;);

            widget-&amp;gt;LoadToolBox(out);

            widget-&amp;gt;m_pPanel-&amp;gt;LoadLayout(out);

            QString panelSign;
            out &amp;gt;&amp;gt; panelSign;//panel结束标志
            Q_ASSERT(panelSign == &quot;panels&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;工具栏按钮&quot;&gt;3、工具栏按钮&lt;/h3&gt;
&lt;p&gt;读取工具栏按钮的信息，并进行初始化。&lt;/p&gt;
&lt;p&gt;工具栏按钮主要是有两个&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;小工具窗口是否打开&lt;/li&gt;
&lt;li&gt;磁力吸附特性是否启用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码中toolBoxChecked就是表示工具箱按钮是否被选中，magneticChecked表示吸力吸附按钮是否被选中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void DragToolBar::LoadLayout(QDataStream &amp;amp; out)
{
    bool toolBoxChecked, magneticChecked;
    out &amp;gt;&amp;gt; toolBoxChecked;
    out &amp;gt;&amp;gt; magneticChecked;

    Q_ASSERT(m_pToolBoxAct);
    m_pToolBoxAct-&amp;gt;setChecked(toolBoxChecked);
    m_pToolBoxAct-&amp;gt;triggered(toolBoxChecked);

    Q_ASSERT(m_pMagneticAct);
    m_pMagneticAct-&amp;gt;setChecked(magneticChecked);
    m_pMagneticAct-&amp;gt;triggered(magneticChecked);

    Q_ASSERT(m_pDragTab);
    m_pDragTab-&amp;gt;LoadLayout(out);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化标签页&quot;&gt;4、初始化标签页&lt;/h3&gt;
&lt;p&gt;加载工具栏上标签页，分3个步骤&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;读取标签页个数&lt;/li&gt;
&lt;li&gt;循环读取所有标签页&lt;/li&gt;
&lt;li&gt;读取选中的标签页下标&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根据读取到的信息初始化工具栏。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void DragTabWidget::LoadLayout(QDataStream &amp;amp; out)
{
    int count;
    out &amp;gt;&amp;gt; count;
    QStringList titles;

    while (count-- &amp;gt; 0)
    {
        QString title;
        out &amp;gt;&amp;gt; title;
        titles.append(title);
    }
    
    int selectedIndex = 0;
    out &amp;gt;&amp;gt; selectedIndex;

    TabButton * selected = nullptr;
    for (int i = 0; i &amp;lt; titles.size(); ++i)
    {
        QString title = titles.at(i);
        UpdateMaxOrder(title);
        TabButton * button = AddNewButton(title);
        if (i == selectedIndex)
        {
            selected = button;
        }
    }

    if (selected)
    {
        ButtonClicked(selected-&amp;gt;GetID());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;子面板初始化&quot;&gt;5、子面板初始化&lt;/h3&gt;
&lt;p&gt;在布局信息序列化小结中，我们讲述了子面板中的小窗口在写入信息时，写入了窗口的类型type，这个时候我们就会发现这个type真的太重要了&lt;/p&gt;
&lt;p&gt;看如下代码，我们读出了小窗口的type值，然后使用SmallFactory工厂的CreateWidget方法创建了小窗口，代码看起来是不是还是比较流畅的。&lt;/p&gt;
&lt;p&gt;除过窗口类型外，还包括了窗口标题栏名称、所属组、位置、大小等信息&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void SubContentWidget::LoadeLayout(QDataStream &amp;amp; out)
{
    QString titleName, groupName;
    QPoint pos;
    QSize size;
    int type;
    int count;
    out &amp;gt;&amp;gt; count;

    while (count-- &amp;gt; 0)
    {
        out &amp;gt;&amp;gt; titleName;
        out &amp;gt;&amp;gt; groupName;

        out &amp;gt;&amp;gt; pos;//保存位置

        out &amp;gt;&amp;gt; size;//保存大小

        out &amp;gt;&amp;gt; (int)type;//保存窗口类型

        SmallWidget * smallWidget = SmallFactory::GetInstance()-&amp;gt;CreateWidget(SubWindowNormalType(type), this);
        AddSmallWidget(smallWidget);

        smallWidget-&amp;gt;SetWindowTitle(titleName);
        if (groupName.isEmpty() == false)
        {
            smallWidget-&amp;gt;SetToolText(STT_GROUP, groupName);
        }
        smallWidget-&amp;gt;move(pos);
        smallWidget-&amp;gt;resize(size);
        smallWidget-&amp;gt;show();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其他-1&quot;&gt;6、其他&lt;/h3&gt;
&lt;p&gt;反序列化的整个过程基本都是一样的套路，主要就是使用QDataStream对象把布局信息以二级制的形式读入到内存中。&lt;/p&gt;
&lt;p&gt;其他窗口的反序列化操作基本类似，这里就不一一列出。&lt;/p&gt;
&lt;h2 id=&quot;七相关文章&quot;&gt;七、相关文章&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11027429.html&quot;&gt;高仿富途牛牛-组件化(一)-支持页签拖拽、增删、小工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11042704.html&quot;&gt;高仿富途牛牛-组件化(二)-磁力吸附&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11048378.html&quot;&gt;高仿富途牛牛-组件化(三)-界面美化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11055495.html&quot;&gt;高仿富途牛牛-组件化(四)-优秀的时钟&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/swarmbees/p/11062824.html&quot;&gt;高仿富途牛牛-组件化(五)-如何去管理炒鸡多的小窗口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mmc1206x/p/11053826.html#4283559&quot;&gt;C++序列化对象&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上的内容，基本上就是本篇文章的内容所有内容啦！序列化和反序列化功能基本完成，希望可以帮到大家。&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;很重要--转载声明&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本站文章无特别说明，皆为原创，版权所有，转载时请用链接的方式，给出原文出处。同时写上原作者：&lt;a href=&quot;https://www.cnblogs.com/swarmbees/&quot;&gt;朝十晚八&lt;/a&gt; or &lt;a href=&quot;https://www.jianshu.com/u/7673f8cfb4e6&quot;&gt;Twowords&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如要转载，请原文转载，如在转载时修改本文，请事先告知，谢绝在转载时通过修改本文达到有利于转载者的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;</description>
<pubDate>Wed, 26 Jun 2019 23:06:00 +0000</pubDate>
<dc:creator>朝十晚八</dc:creator>
<og:description>[TOC] 一、布局记忆 一款优秀的软件，不仅仅要求功能强健、稳定性高和可靠的精准率，往往很多时候我们都需要去关注用户界面是否友好，用户操作是否顺畅，软件跨机器使用到底咋样。 说起到怎么让用户交互友好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/swarmbees/p/11094667.html</dc:identifier>
</item>
<item>
<title>一步步教你怎么用python写贪吃蛇游戏 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/11094832.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/11094832.html</guid>
<description>&lt;p&gt;目录&lt;br/&gt;0 引言&lt;br/&gt;1 环境&lt;br/&gt;2 需求分析&lt;br/&gt;3 代码实现&lt;br/&gt;4 后记&lt;/p&gt;

&lt;p&gt;前几天，星球有人提到贪吃蛇，一下子就勾起了我的兴趣，毕竟在那个Nokia称霸的年代，这款游戏可是经典中的经典啊！而用Python(蛇)玩Snake(贪吃蛇)，那再合适不过了🤣🤣🤣&lt;/p&gt;
&lt;p&gt;先通过下面这个效果图来感受下吧！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201906/649191-20190627065505200-1024066686.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;操作系统：Windows&lt;/p&gt;
&lt;p&gt;Python版本：3.7.3&lt;/p&gt;

&lt;p&gt;我们先来回顾下贪吃蛇中的游戏元素及游戏规则。&lt;/p&gt;
&lt;p&gt;首先呢，需要有贪吃蛇、有食物；需要能控制贪吃蛇来上下移动获取食物；贪吃蛇在吃取食物后，自身长度增加，同时食物消失并随机生成新的食物；如果贪吃蛇触碰到四周墙壁或是触碰到自己身体时，则游戏结束。&lt;/p&gt;
&lt;p&gt;游戏规则就是这么简单，接下来我们借助一个第三方库pygame来实现它。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Pygame是一个利用SDL库的游戏库， 是一组用来开发游戏软件的 Python 程序模块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;SDL（Simple DirectMedia Layer）是一个跨平台库，支持访问计算机多媒体硬件（声音、视频、输入等），SDL非常强大，但美中不足的是它是基于 C 语言的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;PyGame是 SDL 库的 Python 包装器（wrapper），Pygame 在SDL库的基础上提供了各种接口，从而使用用户能够使用python语言创建各种各样的游戏或多媒体程序。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;它的安装方法很简单，如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install pygame&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;想要了解更多pygame功能的朋友也可以查阅官方的文档。&lt;/p&gt;

&lt;p&gt;首先导入我们要用到的模块，除了第三方库pygame外，我们还会用到一些Python内置的模块如sys、random、time等，一并导入即可。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pygame, sys, random, time
# 从pygame模块导入常用的函数和常量
from pygame.locals import *   &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一些全局参数的初始化&quot;&gt;3.1 一些全局参数的初始化&lt;/h2&gt;
&lt;p&gt;接下来，我们需要声明一些全局参数。如初始化pygame、定义游戏窗口的大小、窗口的标题、定义全局的颜色变量等信息。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 初始化Pygame库
pygame.init()
# 初始化一个游戏界面窗口
DISPLAY = pygame.display.set_mode((640, 480))
# 设置游戏窗口的标题
pygame.display.set_caption('人人都是Pythonista - Snake')
# 定义一个变量来控制游戏速度
FPSCLOCK = pygame.time.Clock()
# 初始化游戏界面内使用的字体
BASICFONT = pygame.font.SysFont(&quot;SIMYOU.TTF&quot;, 80)

# 定义颜色变量
BLACK = pygame.Color(0, 0, 0)
WHITE = pygame.Color(255, 255, 255)
RED = pygame.Color(255, 0, 0)
GREY = pygame.Color(150, 150, 150)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;初始化贪吃蛇及食物&quot;&gt;3.2 初始化贪吃蛇及食物&lt;/h2&gt;
&lt;p&gt;游戏中需要有贪吃蛇及食物，我们给定一个初始值。我们将整个界面看成许多20*20的小方块，每个小方块代表一个标准小格子，贪吃蛇的长度就可以用几个标准小格子表示。我们将贪吃蛇身体用列表的形式存储，方便之后的删减。&lt;br/&gt;'''初始化贪吃蛇及食物'''&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 贪吃蛇的的初始位置
snake_Head = [100,100]
# 初始化贪吃蛇的长度 (注：这里以20*20为一个标准小格子)
snake_Body = [[80,100],[60,100],[40,100]]
# 指定蛇初始前进的方向，向右
direction = &quot;right&quot;

# 给定第一枚食物的位置
food_Position = [300,300]
# 食物标记：0代表食物已被吃掉；1代表未被吃掉。
food_flag = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现贪吃蛇的上下左右移动&quot;&gt;3.3 实现贪吃蛇的上下左右移动&lt;/h2&gt;
&lt;p&gt;我们需要控制贪吃蛇的上下左右的移动，这里通过监听键盘输入来实现。利用键盘中的上下左右键或WASD键来控制贪吃蛇的运动。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 检测按键等Pygame事件
for event in pygame.event.get():
    if event.type == QUIT:
        # 接收到退出事件后，退出程序
        pygame.quit()
        sys.exit()
        
    # 判断键盘事件，用 方向键 或 wsad 来表示上下左右
    elif event.type == KEYDOWN:
        if (event.key == K_UP or event.key == K_w) and direction != DOWN:
            direction = UP
        if (event.key == K_DOWN or event.key == K_s) and direction != UP:
            direction = DOWN
        if (event.key == K_LEFT or event.key == K_a) and direction != RIGHT:
            direction = LEFT
        if (event.key == K_RIGHT or event.key == K_d) and direction != LEFT:
            direction = RIGHT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是将蛇前进方向按照键盘的输入进行转弯操作，并将蛇的头部当前的位置加入到蛇身的列表中。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 根据键盘的输入，改变蛇的头部，进行转弯操作
if direction == LEFT:
    snake_Head[0] -= 20
if direction == RIGHT:
    snake_Head[0] += 20
if direction == UP:
    snake_Head[1] -= 20
if direction == DOWN:
    snake_Head[1] += 20

# 将蛇的头部当前的位置加入到蛇身的列表中
snake_Body.insert(0, list(snake_Head))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;判断是否吃到食物&quot;&gt;3.4 判断是否吃到食物&lt;/h2&gt;
&lt;p&gt;如果蛇头与食物的位置重合，则判定吃到食物，将食物数量清零；而没吃到食物的话，蛇身就会跟着蛇头运动，蛇身的最后一节将被踢出列表。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 判断是否吃掉食物
if snake_Head[0]==food_Position[0] and snake_Head[1]==food_Position[1]:
    food_flag = 0
else:
    snake_Body.pop()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;重新生成食物&quot;&gt;3.5 重新生成食物&lt;/h2&gt;
&lt;p&gt;当游戏界面中的食物数量为0时，需要重新生成食物。利用random函数来生成随机位置&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 生成新的食物
if food_flag == 0:
    # 随机生成x, y
    x = random.randrange(1,32)
    y = random.randrange(1,24)
    food_Position = [int(x*20),int(y*20)]
    food_flag = 1&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;绘制贪吃蛇食物分数等信息&quot;&gt;3.6 绘制贪吃蛇、食物、分数等信息&lt;/h2&gt;
&lt;p&gt;定义贪吃蛇的绘制函数&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 绘制贪吃蛇
def drawSnake(snake_Body):
    for i in snake_Body:
        pygame.draw.rect(DISPLAY, WHITE, Rect(i[0], i[1], 20, 20))

定义食物的绘制函数
# 绘制食物的位置
def drawFood(food_Position):
    pygame.draw.rect(DISPLAY, RED, Rect(food_Position[0], food_Position[1], 20, 20))

定义分数的绘制函数
# 打印出当前得分
def drawScore(score):
    # 设置分数的显示颜色
    score_Surf = BASICFONT.render('%s' %(score), True, GREY)
    # 设置分数的位置
    score_Rect = score_Surf.get_rect()
    score_Rect.midtop = (320, 240)
    # 绑定以上设置到句柄
    DISPLAY.blit(score_Surf, score_Rect)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些都定义好之后，我们需要在游戏主逻辑中调用它们，并刷新Pygame的显示层，贪吃蛇与食物的每一次移动，都会进行刷新显示层的操作来显示。最后我们可以设定一个速度值来合理控制游戏执行的速度。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;DISPLAY.fill(BLACK)
# 画出贪吃蛇
drawSnake(snake_Body)
# 画出食物的位置
drawFood(food_Position)
# 打印出玩家的分数
drawScore(len(snake_Body) - 3)
# 刷新Pygame的显示层，贪吃蛇与食物的每一次移动，都会进行刷新显示层的操作来显示。
pygame.display.flip()
# 控制游戏速度
FPSCLOCK.tick(7)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定义游戏结束的画面并判断游戏是否结束&quot;&gt;3.7 定义游戏结束的画面并判断游戏是否结束&lt;/h2&gt;
&lt;p&gt;定义函数，用于展示游戏结束的画面并退出程序&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 游戏结束并退出
def GameOver():
    # 设置GameOver的显示颜色
    GameOver_Surf = BASICFONT.render('Game Over!', True, GREY)
    # 设置GameOver的位置
    GameOver_Rect = GameOver_Surf.get_rect()
    GameOver_Rect.midtop = (320, 10)
    # 绑定以上设置到句柄
    DISPLAY.blit(GameOver_Surf, GameOver_Rect)

    pygame.display.flip()
    # 等待3秒
    time.sleep(3)
    # 退出游戏
    pygame.quit()
    # 退出程序
    sys.exit()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在游戏主逻辑中加入判断，游戏是否结束&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;'''游戏结束的判断'''
# 贪吃蛇触碰到边界
if snake_Head[0]&amp;lt;0 or snake_Head[0]&amp;gt;620:
    GameOver()
if snake_Head[1]&amp;lt;0 or snake_Head[1]&amp;gt;460:
    GameOver()
# 贪吃蛇触碰到自己
for i in snake_Body[1:]:
    if snake_Head[0]==i[0] and snake_Head[1]==i[1]:
        GameOver()&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文利用Pygame模块实现了最简单的贪吃蛇版本。当然还有很多需要优化的地方，比如随机生成食物时如何避免出现在贪吃蛇的自身上、通过贪吃蛇的长度来自动控制游戏速度等等。更高级一点的有如何通过AI自动玩贪吃蛇、贪吃蛇的双人对战等，期待大家利用Python可以把贪吃蛇玩出一个新的高度！😎😎😎&lt;/p&gt;
&lt;p&gt;公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」后台回复关键字「&lt;strong&gt;贪吃蛇&lt;/strong&gt;」获取本文全套完整代码！&lt;/p&gt;
</description>
<pubDate>Wed, 26 Jun 2019 22:56:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>前几天，星球有人提到贪吃蛇，一下子就勾起了我的兴趣，毕竟在那个Nokia称霸的年代，这款游戏可是经典中的经典啊！而用Python(蛇)玩Snake(贪吃蛇)，那再合适不过了🤣🤣🤣</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moonhmily/p/11094832.html</dc:identifier>
</item>
<item>
<title>netty中的发动机--EventLoop及其实现类NioEventLoop的源码分析 - _朱葛</title>
<link>http://www.cnblogs.com/zhuge134/p/11094766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuge134/p/11094766.html</guid>
<description>&lt;p&gt;在之前介绍Bootstrap的初始化以及启动过程时，我们多次接触了NioEventLoopGroup这个类，关于这个类的理解，还需要了解netty的线程模型。NioEventLoopGroup可以理解为一组线程，这些线程每一个都可以独立地处理多个channel产生的io事件。&lt;/p&gt;
&lt;h2 id=&quot;nioeventloopgroup初始化&quot;&gt;NioEventLoopGroup初始化&lt;/h2&gt;
&lt;p&gt;我们看其中一个参数比较多的构造方法，其他一些参数较少的构造方法使用了一些默认值，使用的默认参数如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SelectorProvider类型，用于创建socket通道，udp通道，创建Selector对象等，默认值是SelectorProvider.provider()，大部分情况下使用默认值就行，这个方法最终创建的是一个WindowsSelectorProvider对象&lt;/li&gt;
&lt;li&gt;SelectStrategyFactory，Select策略类的工厂类，它的默认值是DefaultSelectStrategyFactory.INSTANCE，就是一个SelectStrategyFactory对象本身，而SelectStrategyFactory工厂产生的是DefaultSelectStrategy策略类。&lt;/li&gt;
&lt;li&gt;RejectedExecutionHandler，拒绝任务的策略类，决定在任务队列已满时采取什么样的策略，类似于jdk线程池的RejectedExecutionHandler的作用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们看一下其中的一个常用的构造方法，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public NioEventLoopGroup(int nThreads, ThreadFactory threadFactory,
    final SelectorProvider selectorProvider, final SelectStrategyFactory selectStrategyFactory) {
    super(nThreads, threadFactory, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，当前类中并没有什么初始化逻辑，直接调用了父类的构造方法，所以我们接着看父类MultithreadEventLoopGroup的构造方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) {
    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，并未做任务处理，直接调用父类构造方法，所以我们接着看MultithreadEventExecutorGroup构造方法，初始化逻辑的实现在这个类中，&lt;/p&gt;
&lt;h3 id=&quot;multithreadeventexecutorgroup构造方法&quot;&gt;MultithreadEventExecutorGroup构造方法&lt;/h3&gt;
&lt;p&gt;通过上一小结的分析，我们知道NioEventLoopGroup的构造方法的主要逻辑的实现是在MultithreadEventExecutorGroup类中，并且在调用构造方法的过程中加上了一个参数的默认值，即EventExecutorChooserFactory类型参数的默认值DefaultEventExecutorChooserFactory.INSTANCE，这个类以轮询(roundrobin)的方式从多个线程中依次选出线程用于注册channel。&lt;br/&gt;总结一下这段代码的主要步骤：&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li&gt;首先是一些变量的非空检查和合法性检查&lt;/li&gt;
&lt;li&gt;然后根据传入的线程数量，创建若干个子执行器，每个执行器对应一个线程&lt;/li&gt;
&lt;li&gt;最后以子执行器数组为参数，使用选择器工厂类创建一个选择器&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;最后给每个子执行器添加一个监听器，以监听子执行器的终止，做一些簿记工作，使得在所有子执行器全部终止后将当前的执行器组终止&lt;/p&gt;
&lt;p&gt;protected MultithreadEventExecutorGroup(int nThreads, Executor executor,&lt;br/&gt;EventExecutorChooserFactory chooserFactory, Object... args) {&lt;br/&gt;// 首先是变量的非空检查以及合法性判断，&lt;br/&gt;// nThreads在MultithreadEventLoopGroup的构造方法中已经经过一些默认值处理，&lt;br/&gt;if (nThreads &amp;lt;= 0) {&lt;br/&gt;throw new IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &amp;gt; 0)&quot;, nThreads));&lt;br/&gt;}&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 这里一般都会使用默认值，
  // ThreadPerTaskExecutor的作用即字面意思，一个任务一个线程
  if (executor == null) {
      executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
  }

  // 子执行器的数组，一个子执行器对应一个线程
  children = new EventExecutor[nThreads];

  // 根据传入的线程数量创建多个自执行器
  // 注意，这里子执行器创建好后并不会立即运行起来
  for (int i = 0; i &amp;lt; nThreads; i ++) {
      boolean success = false;
      try {
          children[i] = newChild(executor, args);
          success = true;
      } catch (Exception e) {
          // TODO: Think about if this is a good exception type
          throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e);
      } finally {
          // 如果创建子执行器不成功，那么需要将已经创建好的子执行器也全部销毁
          if (!success) {
              for (int j = 0; j &amp;lt; i; j ++) {
                  children[j].shutdownGracefully();
              }

              // 等待所以子执行器停止后在退出
              for (int j = 0; j &amp;lt; i; j ++) {
                  EventExecutor e = children[j];
                  try {
                      while (!e.isTerminated()) {
                          e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                      }
                  } catch (InterruptedException interrupted) {
                      // Let the caller handle the interruption.
                      Thread.currentThread().interrupt();
                      break;
                  }
              }
          }
      }
  }

  // 创建一个子执行器的选择器，选择器的作用是从子执行器中选出一个
  // 默认使用roundRobin的方式
  chooser = chooserFactory.newChooser(children);

  final FutureListener&amp;lt;Object&amp;gt; terminationListener = new FutureListener&amp;lt;Object&amp;gt;() {
      @Override
      public void operationComplete(Future&amp;lt;Object&amp;gt; future) throws Exception {
          if (terminatedChildren.incrementAndGet() == children.length) {
              terminationFuture.setSuccess(null);
          }
      }
  };

  // 给每个子执行器添加监听器，在子执行器终止的时候做一些工作
  // 每有一个子执行器终止时就将terminatedChildren变量加一
  // 当所有子执行器全部终止时，当前这个执行器组就终止了
  for (EventExecutor e: children) {
      e.terminationFuture().addListener(terminationListener);
  }

  // 包装一个不可变的集合
  Set&amp;lt;EventExecutor&amp;gt; childrenSet = new LinkedHashSet&amp;lt;EventExecutor&amp;gt;(children.length);
  Collections.addAll(childrenSet, children);
  readonlyChildren = Collections.unmodifiableSet(childrenSet);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;nioeventloopgroup.newchild&quot;&gt;NioEventLoopGroup.newChild&lt;/h3&gt;
&lt;p&gt;上面的方法中调用了newChild方法来创建一个子执行器，而这个方法是一个抽象方法，我们看NioEventLoopGroup类的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected EventLoop newChild(Executor executor, Object... args) throws Exception {
    return new NioEventLoop(this, executor, (SelectorProvider) args[0],
        ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见仅仅是简单地创建了一个NioEventLoop对象。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;到这里，我们就把NioEventLoopGroup的初始化过程分析完了。我们不禁思考，既然NioEventLoopGroup是一个执行器组，说白了就是一组线程，那这些线程是什么时候跑起来的呢？如果读者还有印象，应该能记得我们在分析Bootstrap建立连接过程时，channel初始化之后需要注册到EventLoopGroup中，其实是注册到其中的一个EventLoop上，注册逻辑最终是在AbstractChannel.AbstractUnsafe.register方法中实现的，其中有一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;      if (eventLoop.inEventLoop()) {
            register0(promise);
        } else {
            try {
                eventLoop.execute(new Runnable() {
                    @Override
                    public void run() {
                        register0(promise);
                    }
                });
            } catch (Throwable t) {
                logger.warn(
                        &quot;Force-closing a channel whose registration task was not accepted by an event loop: {}&quot;,
                        AbstractChannel.this, t);
                closeForcibly();
                closeFuture.setClosed();
                safeSetFailure(promise, t);
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先调用eventLoop.inEventLoop()判断执行器的线程与当前线程是否是同一个，如果是则直接执行注册的代码，如果不是就调用eventLoop.execute将注册逻辑封装成一个任务放到执行器的任务队列中，接下里我们就以这个方法为切入点，探究一下子执行器线程的启动过程。&lt;/p&gt;
&lt;h3 id=&quot;abstracteventexecutor.ineventloop&quot;&gt;AbstractEventExecutor.inEventLoop&lt;/h3&gt;
&lt;p&gt;首先，让我们来看一下这个方法，这个方法的作用是判断当前线程与执行器的线程是否同一个线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean inEventLoop() {
    return inEventLoop(Thread.currentThread());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;singlethreadeventexecutor.ineventloop&quot;&gt;SingleThreadEventExecutor.inEventLoop&lt;/h4&gt;
&lt;p&gt;代码很简单，就不多说了。&lt;br/&gt;public boolean inEventLoop(Thread thread) {&lt;br/&gt;return thread == this.thread;&lt;br/&gt;}&lt;/p&gt;
&lt;h3 id=&quot;singlethreadeventexecutor.execute&quot;&gt;SingleThreadEventExecutor.execute&lt;/h3&gt;
&lt;p&gt;方法很简单，核心逻辑在startThread方法中，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public void execute(Runnable task) {
    // 非空检查
    if (task == null) {
        throw new NullPointerException(&quot;task&quot;);
    }

    // 执行到这里一般都是外部调用者，
    boolean inEventLoop = inEventLoop();
    // 向任务队列中添加一个任务
    addTask(task);
    // 如果当前线程不是执行器的线程，那么需要检查执行器线程是否已经运行，
    // 如果还没在运行，就需要启动线程
    if (!inEventLoop) {
        startThread();
        // 检查线程是否被关闭
        if (isShutdown()) {
            boolean reject = false;
            try {
                // 将刚刚添加的任务移除
                if (removeTask(task)) {
                    reject = true;
                }
            } catch (UnsupportedOperationException e) {
                // The task queue does not support removal so the best thing we can do is to just move on and
                // hope we will be able to pick-up the task before its completely terminated.
                // In worst case we will log on termination.
            }
            if (reject) {
                reject();
            }
        }
    }

    // addTaskWakesUp不知道这个变量意义是什么，NioEventLoop传进来的是false
    // 向任务队列中添加一个空任务，这样就能够唤醒阻塞的执行器线程
    // 有些情况下执行器线程会阻塞在taskQueue上，
    // 所以向阻塞队列中添加一个元素能够唤醒哪些因为队列空而被阻塞的线程
    if (!addTaskWakesUp &amp;amp;&amp;amp; wakesUpForTask(task)) {
        wakeup(inEventLoop);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;singlethreadeventexecutor.startthread&quot;&gt;SingleThreadEventExecutor.startThread&lt;/h3&gt;
&lt;p&gt;这个方法的主要作用是维护内部的状态量state，使用cas指令并发情况下对状态量的修改是线程安全的，并且对于状态量的判断保证启动逻辑只被执行一次&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void startThread() {
    // 状态量的维护
    if (state == ST_NOT_STARTED) {
        // 这里使用了jdk中的原子更新器AtomicIntegerFieldUpdater类，
        // 使用cpu的cas指令保证并发情况下能够安全地维护状态量
        // 保证只有一个线程能够执行启动逻辑，保证启动逻辑只被执行一次
        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) {
            boolean success = false;
            try {
                // 实际启动线程的逻辑
                doStartThread();
                success = true;
            } finally {
                if (!success) {
                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);
                }
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;singlethreadeventexecutor.dostartthread&quot;&gt;SingleThreadEventExecutor.doStartThread&lt;/h3&gt;
&lt;p&gt;这个方法我就不贴代码了，说一下它的主要作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用内部的Executor对象（一般是一个ThreadPerTaskExecutor）启动一个线程，并执行任务&lt;/li&gt;
&lt;li&gt;维护执行器的运行状态，主要是通过内部的状态量和cas指令来保证线程安全；此外维护内部的一些簿记量，例如线程本身的引用，线程启动时间等&lt;/li&gt;
&lt;li&gt;线程结束时做一些收尾和清理工作，例如将剩余的任务跑完，运行关闭钩子，关闭底层的selector(这个是具体的子类的清理逻辑)，同时更新状态量&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体的业务逻辑仍然是在子类中实现的，也就是SingleThreadEventExecutor.run()方法的具体实现。&lt;/p&gt;
&lt;h3 id=&quot;nioeventloop.run&quot;&gt;NioEventLoop.run&lt;/h3&gt;
&lt;p&gt;我们仍然以NioEventLoop为例，看一下它实现的run方法。还大概讲一下它的主要逻辑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首选这个方法是一个循环，不断地通过调用jdk底层的selector接收io事件，并对不同的io事件做处理，同时也会处理任务队列中的任务，以及定时调度或延迟调度的任务&lt;/li&gt;
&lt;li&gt;调用jdk的api， selector接收io事件&lt;/li&gt;
&lt;li&gt;处理各种类型的io事件&lt;/li&gt;
&lt;li&gt;处理任务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里，我就不贴代码了，其中比较重要的是对一些并发情况的考虑和处理，如selector的唤醒时机。接下来，主要看一下对于各种io事件的处理，至于任务队列以及调度队列中任务的处理比较简单，就不展开了。&lt;/p&gt;
&lt;h3 id=&quot;nioeventloop.processselectedkeysoptimized&quot;&gt;NioEventLoop.processSelectedKeysOptimized&lt;/h3&gt;
&lt;p&gt;这个方法会遍历所有接受到的io事件对应的selectionKey，然后依次处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void processSelectedKeysOptimized() {
    // 遍历所有的io事件的SelectionKey
    for (int i = 0; i &amp;lt; selectedKeys.size; ++i) {
        final SelectionKey k = selectedKeys.keys[i];
        // null out entry in the array to allow to have it GC'ed once the Channel close
        // See https://github.com/netty/netty/issues/2363
        selectedKeys.keys[i] = null;

        final Object a = k.attachment();

        if (a instanceof AbstractNioChannel) {
            // 处理事件
            processSelectedKey(k, (AbstractNioChannel) a);
        } else {
            @SuppressWarnings(&quot;unchecked&quot;)
            NioTask&amp;lt;SelectableChannel&amp;gt; task = (NioTask&amp;lt;SelectableChannel&amp;gt;) a;
            processSelectedKey(k, task);
        }

        // 如果需要重新select，那么把后面的selectionKey全部置0，然后再次调用selectNow方法
        if (needsToSelectAgain) {
            // null out entries in the array to allow to have it GC'ed once the Channel close
            // See https://github.com/netty/netty/issues/2363
            selectedKeys.reset(i + 1);

            selectAgain();
            i = -1;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;nioeventloop.processselectedkey&quot;&gt;NioEventLoop.processSelectedKey&lt;/h3&gt;
&lt;p&gt;这个方法首先对SelectionKey无效的情况做了处理，分为两种情况：channel本身无效了；channel仍然是正常的，只不过是被从当前的selector上注销了，可能在其他的selector中仍然是正常运行的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于第一种情况，需要关闭channel，即关闭底层的连接&lt;/li&gt;
&lt;li&gt;对于第二种情况则不需要做任何处理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来，我们着重分析一下对于四种事件的处理逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    // 如果selectionKey是无效的，那么说明相应的channel是无效的，此时需要关闭这个channel
    if (!k.isValid()) {
        final EventLoop eventLoop;
        try {
            eventLoop = ch.eventLoop();
        } catch (Throwable ignored) {
            // If the channel implementation throws an exception because there is no event loop, we ignore this
            // because we are only trying to determine if ch is registered to this event loop and thus has authority
            // to close ch.
            return;
        }
        // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
        // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
        // still healthy and should not be closed.
        // See https://github.com/netty/netty/issues/5125
        // 只关闭注册在当前EventLoop上的channel，
        // 理论上来说，一个channel是可以注册到多个Eventloop上的，
        // SelectionKey无效可能是因为channel从当前EventLoop上注销了，
        // 但是channel本身依然是正常的，并且注册在其他的EventLoop中
        if (eventLoop != this || eventLoop == null) {
            return;
        }
        // close the channel if the key is not valid anymore
        // 到这里说明channel已经无效了，关闭它
        unsafe.close(unsafe.voidPromise());
        return;
    }

    // 下面处理正常情况
    try {
        // 准备好的io事件
        int readyOps = k.readyOps();
        // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
        // the NIO JDK channel implementation may throw a NotYetConnectedException.
        // 处理connect事件
        if ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != 0) {
            // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
            // See https://github.com/netty/netty/issues/924
            int ops = k.interestOps();
            ops &amp;amp;= ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);

            unsafe.finishConnect();
        }

        // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
        // 处理write事件
        if ((readyOps &amp;amp; SelectionKey.OP_WRITE) != 0) {
            // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
            ch.unsafe().forceFlush();
        }

        // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
        // to a spin loop
        // 处理read和accept事件
        if ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            unsafe.read();
        }
    } catch (CancelledKeyException ignored) {
        unsafe.close(unsafe.voidPromise());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;connect事件处理&quot;&gt;connect事件处理&lt;/h4&gt;
&lt;p&gt;从代码中可以看出，connect事件的处理时通过调用NioUnsafe.finishConnect完成的，我们看一下AbstractNioUnsafe.finishConnect的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final void finishConnect() {
        // Note this method is invoked by the event loop only if the connection attempt was
        // neither cancelled nor timed out.

        assert eventLoop().inEventLoop();

        try {
            // 是否已经处于连接成功的状态
            boolean wasActive = isActive();
            // 抽象方法，有子类实现
            doFinishConnect();
            // 处理future对象，将其标记为成功
            fulfillConnectPromise(connectPromise, wasActive);
        } catch (Throwable t) {
            fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));
        } finally {
            // Check for null as the connectTimeoutFuture is only created if a connectTimeoutMillis &amp;gt; 0 is used
            // See https://github.com/netty/netty/issues/1770
            if (connectTimeoutFuture != null) {
                connectTimeoutFuture.cancel(false);
            }
            connectPromise = null;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，主要是通过调用doFinishConnect实现完成连接的逻辑，具体到子类中，NioSocketChannel.doFinishConnect的实现是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected void doFinishConnect() throws Exception {
    if (!javaChannel().finishConnect()) {
        throw new Error();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;write事件处理&quot;&gt;write事件处理&lt;/h4&gt;
&lt;p&gt;对于的write事件的处理时通过调用NioUnsafe.forceFlush方法完成，最终的实现在AbstractChannel.AbstractUnsafe.flush0中：&lt;br/&gt;大体上看，这个方法的逻辑比较简单，但是实际上最复杂也是最核心的写入逻辑在子类实现的doWrite方法中。由于本篇的重点在于把NioEventLoop的主干逻辑梳理一下，所以这里不再继续展开，后面会单独来分析这一块的源码，这里涉及到netty中对缓冲区的封装，其中涉及到一些比较复杂的逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  protected void flush0() {
        // 如果正在写数据，直接返回
        if (inFlush0) {
            // Avoid re-entrance
            return;
        }

        // 输出的缓冲区
        final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
        if (outboundBuffer == null || outboundBuffer.isEmpty()) {
            return;
        }

        inFlush0 = true;

        // Mark all pending write requests as failure if the channel is inactive.
        if (!isActive()) {
            try {
                if (isOpen()) {
                    outboundBuffer.failFlushed(new NotYetConnectedException(), true);
                } else {
                    // Do not trigger channelWritabilityChanged because the channel is closed already.
                    outboundBuffer.failFlushed(newClosedChannelException(initialCloseCause), false);
                }
            } finally {
                inFlush0 = false;
            }
            return;
        }

        try {
            // 将缓冲区的数据写入到channel中
            doWrite(outboundBuffer);
        } catch (Throwable t) {
            if (t instanceof IOException &amp;amp;&amp;amp; config().isAutoClose()) {
                /**
                 * Just call {@link #close(ChannelPromise, Throwable, boolean)} here which will take care of
                 * failing all flushed messages and also ensure the actual close of the underlying transport
                 * will happen before the promises are notified.
                 *
                 * This is needed as otherwise {@link #isActive()} , {@link #isOpen()} and {@link #isWritable()}
                 * may still return {@code true} even if the channel should be closed as result of the exception.
                 */
                initialCloseCause = t;
                close(voidPromise(), t, newClosedChannelException(t), false);
            } else {
                try {
                    shutdownOutput(voidPromise(), t);
                } catch (Throwable t2) {
                    initialCloseCause = t;
                    close(voidPromise(), t2, newClosedChannelException(t), false);
                }
            }
        } finally {
            inFlush0 = false;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;read事件和accept事件处理&quot;&gt;read事件和accept事件处理&lt;/h4&gt;
&lt;p&gt;乍看会比较奇怪，为什么这两个事件要放到一起处理呢，他们明明是不同的事件。这里主要还是考虑到编码的统一，因为read事件只有NioSocketChannel才会有，而accept事件只有NioServerSocketChannel才会有，所以这里通过抽象方法，让不同的子类去实现各自的逻辑，是的代码结构上更统一。我们这里看一下NioScketChannel的实现，而对于NioServerSocketChannel的实现我会在后续分析netty服务端的启动过程时在具体讲到，即ServerBootstrap的启动过程。&lt;/p&gt;
&lt;h5 id=&quot;niobyteunsafe.read&quot;&gt;NioByteUnsafe.read&lt;/h5&gt;
&lt;p&gt;总结一下这个方法的主要逻辑：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li&gt;首先会获取缓冲分配器和相应的处理器RecvByteBufAllocator.Handle对象&lt;/li&gt;
&lt;li&gt;循环读取数据，每次分配一个一定大小（大小可配置）的缓冲，将channel中待读取的数据读取到缓冲中&lt;/li&gt;
&lt;li&gt;以装载有数据的缓冲为消息体，向channel的处理流水线（即pipeline）中触发一个读取的事件，让读取到的数据在流水线中传播，被各个处理器处理&lt;/li&gt;
&lt;li&gt;重复此过程，知道channel中没有可供读取的数据&lt;/li&gt;
&lt;li&gt;最后向pipeline中触发一个读取完成的事件&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;最后还要根据最后一次读取到的数据量决定是否关闭通道，如果最后一次读取到的数据量小于0，说明对端已经关闭了输出，所以这里需要将输入关闭，即通道处于半关闭状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public final void read() {
          final ChannelConfig config = config();
          // 如果通道已经关闭，那么就不需要再读取数据，直接返回
          if (shouldBreakReadReady(config)) {
              clearReadPending();
              return;
          }
          final ChannelPipeline pipeline = pipeline();
          // 缓冲分配器
          final ByteBufAllocator allocator = config.getAllocator();
          // 缓冲分配的处理器，处理缓冲分配，读取计数等
          final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();
          allocHandle.reset(config);

          ByteBuf byteBuf = null;
          boolean close = false;
          try {
              do {
                  // 分配一个缓冲
                  byteBuf = allocHandle.allocate(allocator);
                  // 将通道的数据读取到缓冲中
                  allocHandle.lastBytesRead(doReadBytes(byteBuf));
                  // 如果没有读取到数据，说明通道中没有待读取的数据了，
                  if (allocHandle.lastBytesRead() &amp;lt;= 0) {
                      // nothing was read. release the buffer.
                      // 因为没读取到数据，所以应该释放缓冲
                      byteBuf.release();
                      byteBuf = null;
                      // 如果读取到的数据量是负数，说明通道已经关闭了
                      close = allocHandle.lastBytesRead() &amp;lt; 0;
                      if (close) {
                          // There is nothing left to read as we received an EOF.
                          readPending = false;
                      }
                      break;
                  }

                  // 更新Handle内部的簿记量
                  allocHandle.incMessagesRead(1);
                  readPending = false;
                  // 向channel的处理器流水线中触发一个事件，
                  // 让取到的数据能够被流水线上的各个ChannelHandler处理
                  pipeline.fireChannelRead(byteBuf);
                  byteBuf = null;
                  // 这里根据如下条件判断是否继续读：
                  // 上一次读取到的数据量大于0，并且读取到的数据量等于分配的缓冲的最大容量，
                  // 此时说明通道中还有待读取的数据
              } while (allocHandle.continueReading());

              // 读取完成
              allocHandle.readComplete();
              // 触发一个读取完成的事件
              pipeline.fireChannelReadComplete();

              if (close) {
                  closeOnRead(pipeline);
              }
          } catch (Throwable t) {
              handleReadException(pipeline, byteBuf, t, close, allocHandle);
          } finally {
              // Check if there is a readPending which was not processed yet.
              // This could be for two reasons:
              // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
              // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
              //
              // See https://github.com/netty/netty/issues/2254
              // 这里isAutoRead默认是true, 所以正常情况下会继续监听read事件
              if (!readPending &amp;amp;&amp;amp; !config.isAutoRead()) {
                  removeReadOp();
              }
          }
      }
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本篇主要分析了EventLoop的事件监听以及处理逻辑，此外处理处理io事件，也会处理添加进来的任务和定时调度任务和延迟调度任务。EventLoop就像是整个框架的发动机或者说是心脏，它通过jdk api进而简介地调用系统调用，不断地监听各种io事件，同时对不同的io事件分门别类采用不同的处理方式，对于read事件则会将网络io数据读取到缓冲中，并将读取到的数据传递给用户的处理器进行链式处理。Channelpipeline就像一个流水线一样，对触发的的各种事件进行处理。&lt;/p&gt;
&lt;h2 id=&quot;遗留问题&quot;&gt;遗留问题&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;NioSocketChannel.doWrite方法的写入逻辑的，待进一步分析&lt;/li&gt;
&lt;li&gt;ChannelPipeline的详细分析，各种事件是怎么在处理器之间传播的，设计模式，代码结构等&lt;/li&gt;
&lt;li&gt;缓冲分配器和缓冲处理器的分析，它们是怎么对内存进行管理的，这也是netty高性能的原因之一。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 26 Jun 2019 17:11:00 +0000</pubDate>
<dc:creator>_朱葛</dc:creator>
<og:description>EventLoop 在之前介绍Bootstrap的初始化以及启动过程时，我们多次接触了NioEventLoopGroup这个类，关于这个类的理解，还需要了解netty的线程模型。NioEventLoo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuge134/p/11094766.html</dc:identifier>
</item>
<item>
<title>RocketMQ(1)-架构原理 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/11094624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/11094624.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;RocketMQ是阿里开源的分布式消息中间件，跟其它中间件相比，RocketMQ的特点是&lt;strong&gt;纯JAVA实现&lt;/strong&gt;；&lt;strong&gt;集群和HA实现相对简单&lt;/strong&gt;；&lt;strong&gt;在发生宕机和其它故障时消息丢失率更低&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;一rocketmq专业术语&quot;&gt;&lt;span&gt;一、RocketMQ专业术语&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;先讲专业术语的含义，后面会画流程图来更好的去理解它们。&lt;/p&gt;
&lt;h4 id=&quot;producer&quot;&gt;Producer&lt;/h4&gt;
&lt;p&gt;消息生产者，位于用户的进程内，&lt;code&gt;Producer通过NameServer获取所有Broker的路由信息&lt;/code&gt;，根据负载均衡策略选择将消息发到哪个Broker，然后调用Broker接口提交消息。&lt;/p&gt;
&lt;h4 id=&quot;producer-group&quot;&gt;Producer Group&lt;/h4&gt;
&lt;p&gt;生产者组，简单来说就是多个发送同一类消息的生产者称之为一个生产者组。&lt;/p&gt;
&lt;h4 id=&quot;consumer&quot;&gt;Consumer&lt;/h4&gt;
&lt;p&gt;消息消费者，位于用户进程内。Consumer通过NameServer获取所有broker的路由信息后，向Broker发送Pull请求来获取消息数据。Consumer可以以两种模式启动，&lt;strong&gt;广播（Broadcast）和集群（Cluster）&lt;/strong&gt;，&lt;strong&gt;广播模式下，一条消息会发送给所有Consumer，集群模式下消息只会发送给一个Consumer&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;consumer-group&quot;&gt;Consumer Group&lt;/h4&gt;
&lt;p&gt;消费者组，和生产者类似，消费同一类消息的多个 Consumer 实例组成一个消费者组。&lt;/p&gt;
&lt;h4 id=&quot;topic&quot;&gt;Topic&lt;/h4&gt;
&lt;p&gt;Topic用于将消息按主题做划分，&lt;strong&gt;Producer将消息发往指定的Topic，Consumer订阅该Topic就可以收到这条消息&lt;/strong&gt;。Topic跟发送方和消费方都没有强关联关系，发送方可以同时往多个Topic投放消息，消费方也可以订阅多个Topic的消息。在RocketMQ中，&lt;strong&gt;Topic是一个上逻辑概念。消息存储不会按Topic分开&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;message&quot;&gt;Message&lt;/h4&gt;
&lt;p&gt;代表一条消息，使用&lt;code&gt;MessageId&lt;/code&gt;唯一识别，用户在发送时可以设置messageKey，便于之后查询和跟踪。一个 Message 必须指定 Topic，相当于寄信的地址。Message 还有一个可选的 Tag 设置，以便消费端可以基于 Tag 进行过滤消息。也可以添加额外的键值对，例如你需要一个业务 key 来查找 Broker 上的消息，方便在开发过程中诊断问题。&lt;/p&gt;
&lt;h4 id=&quot;tag&quot;&gt;Tag&lt;/h4&gt;
&lt;p&gt;标签可以被认为是对 Topic 进一步细化。一般在相同业务模块中通过引入标签来标记不同用途的消息。&lt;/p&gt;
&lt;h4 id=&quot;broker&quot;&gt;Broker&lt;/h4&gt;
&lt;p&gt;Broker是RocketMQ的核心模块，&lt;code&gt;负责接收并存储消息&lt;/code&gt;，同时提供Push/Pull接口来将消息发送给Consumer。Consumer可选择从Master或者Slave读取数据。多个主/从组成Broker集群，集群内的Master节点之间不做数据交互。Broker同时提供消息查询的功能，可以通过MessageID和MessageKey来查询消息。Borker会将自己的Topic配置信息实时同步到NameServer。&lt;/p&gt;
&lt;h4 id=&quot;queue&quot;&gt;Queue&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Topic和Queue是1对多的关系&lt;/strong&gt;，&lt;strong&gt;一个Topic下可以包含多个Queue&lt;/strong&gt;，主要用于负载均衡。发送消息时，用户只指定Topic，Producer会根据Topic的路由信息选择具体发到哪个Queue上。Consumer订阅消息时，会根据负载均衡策略决定订阅哪些Queue的消息。&lt;/p&gt;
&lt;h4 id=&quot;offset&quot;&gt;Offset&lt;/h4&gt;
&lt;p&gt;RocketMQ在存储消息时会为每个Topic下的每个Queue生成一个消息的索引文件，每个Queue都对应一个Offset&lt;strong&gt;记录当前Queue中消息条数&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;nameserver&quot;&gt;NameServer&lt;/h4&gt;
&lt;p&gt;NameServer可以看作是RocketMQ的注册中心，它管理两部分数据：集群的Topic-Queue的路由配置；Broker的实时配置信息。其它模块通过Nameserv提供的接口获取最新的Topic配置和路由信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Producer/Consumer&lt;/code&gt; ：通过查询接口获取Topic对应的Broker的地址信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Broker&lt;/code&gt; ： 注册配置信息到NameServer， 实时更新Topic信息到NameServer&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;二流程图&quot;&gt;&lt;span&gt;二、流程图&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们由简单到复杂的来理解，它的一些核心概念&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190626173010056-1457807155.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图很好理解，消息先发到Topic，然后消费者去Topic拿消息。只是Topic在这里只是个概念，那它到底是怎么存储消息数据的呢，这里就要引入Broker概念。&lt;/p&gt;
&lt;h4 id=&quot;topic的存储&quot;&gt;2、Topic的存储&lt;/h4&gt;
&lt;p&gt;​ Topic是一个逻辑上的概念，实际上Message是在每个Broker上以Queue的形式记录。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190626173042073-147043337.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的图片可以总结下几条结论。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、消费者发送的Message会在Broker中的Queue队列中记录。
2、一个Topic的数据可能会存在多个Broker中。
3、一个Broker存在多个Queue。
4、单个的Queue也可能存储多个Topic的消息。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说每个Topic在Broker上会划分成几个逻辑队列，每个逻辑队列保存一部分消息数据，但是保存的消息数据实际上不是真正的消息数据，而是指向commit log的消息索引。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Queue不是真正存储Message的地方，真正存储Message的地方是在CommitLog&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如图（盗图）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190626235211016-2054524747.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边的是CommitLog。这个是真正存储消息的地方。RocketMQ所有生产者的消息都是往这一个地方存的。&lt;/p&gt;
&lt;p&gt;右边是ConsumeQueue。这是一个逻辑队列。和上文中Topic下的Queue是一一对应的。消费者是直接和ConsumeQueue打交道。ConsumeQueue记录了消费位点，这个消费位点关联了commitlog的位置。所以即使ConsumeQueue出问题，只要commitlog还在，消息就没丢，可以恢复出来。还可以通过修改消费位点来重放或跳过一些消息。&lt;/p&gt;
&lt;h4 id=&quot;部署模型&quot;&gt;3、部署模型&lt;/h4&gt;
&lt;p&gt;在部署RocketMQ时，会部署两种角色。NameServer和Broker。如图（盗图）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201906/1090617-20190626233829426-1023022108.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对这张图做个说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、Product和consumer集群部署，是你开发的项目进行集群部署。
2、Broker 集群部署是为了高可用，因为Broker是真正存储Message的地方，集群部署是为了避免一台挂掉，导致整个项目KO.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那Name SerVer是做什么用呢，它和Product、Consumer、Broker之前存在怎样的关系呢？&lt;/p&gt;
&lt;p&gt;先简单概括Name Server的特点&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、Name Server是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。
2、每个Broker与Name Server集群中的所有节点建立长连接，定时注册Topic信息到所有Name Server。
3、Producer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息。
4、Consumer与Name Server集群中的其中一个节点（随机选择）建立长连接，定期从Name Server取Topic路由信息。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面最核心的是&lt;code&gt;每个Broker与Name Server集群中的所有节点建立长连接&lt;/code&gt;这样做好处多多。&lt;/p&gt;
&lt;p&gt;1、这样可以使Name Server之间可以没有任何关联，因为它们绑定的Broker是一致的。&lt;/p&gt;
&lt;p&gt;2、作为Producer或者Consumer可以绑定任何一个Name Server 因为它们都是一样的。&lt;/p&gt;

&lt;h2 id=&quot;三详解broker&quot;&gt;&lt;span&gt;三、详解Broker&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;broker与name-server关系&quot;&gt;1、Broker与Name Server关系&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1）连接&lt;/strong&gt; 单个Broker和所有Name Server保持长连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）心跳&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;心跳间隔&lt;/strong&gt;：每隔&lt;strong&gt;30秒&lt;/strong&gt;向所有NameServer发送心跳，心跳包含了自身的Topic配置信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;心跳超时&lt;/strong&gt;：NameServer每隔&lt;strong&gt;10秒&lt;/strong&gt;，扫描所有还存活的Broker连接，若某个连接2分钟内没有发送心跳数据，则断开连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）断开&lt;/strong&gt; ：当Broker挂掉；NameServer会根据心跳超时主动关闭连接,一旦连接断开，会更新Topic与队列的对应关系，但不会通知生产者和消费者。&lt;/p&gt;
&lt;h4 id=&quot;负载均衡&quot;&gt;2、 负载均衡&lt;/h4&gt;
&lt;p&gt;一个Topic分布在多个Broker上，一个Broker可以配置多个Topic，它们是多对多的关系。&lt;br/&gt;如果某个Topic消息量很大，应该给它多配置几个Queue，并且尽量多分布在不同Broker上，减轻某个Broker的压力。&lt;/p&gt;
&lt;h4 id=&quot;可用性&quot;&gt;3 、可用性&lt;/h4&gt;
&lt;p&gt;由于消息分布在各个Broker上，一旦某个Broker宕机，则该Broker上的消息读写都会受到影响。&lt;/p&gt;
&lt;p&gt;所以RocketMQ提供了Master/Slave的结构，Salve定时从Master同步数据，如果Master宕机，则Slave提供消费服务，但是不能写入消息，此过程对应用透明，由RocketMQ内部解决。&lt;br/&gt;有两个关键点：&lt;br/&gt;&lt;code&gt;思考1&lt;/code&gt;一旦某个broker master宕机，生产者和消费者多久才能发现？&lt;/p&gt;
&lt;p&gt;受限于Rocketmq的网络连接机制，默认情况下最多需要&lt;strong&gt;30秒&lt;/strong&gt;，因为消费者每隔30秒从nameserver获取所有topic的最新队列情况，这意味着某个broker如果宕机，客户端最多要30秒才能感知。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;思考2&lt;/code&gt; master恢复恢复后，消息能否恢复。&lt;br/&gt;消费者得到Master宕机通知后，转向Slave消费，但是Slave不能保证Master的消息100%都同步过来了，因此会有少量的消息丢失。但是消息最终不会丢的，一旦Master恢复，未同步过去的消息会被消费掉。&lt;/p&gt;

&lt;h2 id=&quot;四-consumer-消费者&quot;&gt;&lt;span&gt;四 Consumer (消费者)&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;consumer与name-server关系&quot;&gt;1 、Consumer与Name Server关系&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1）连接&lt;/strong&gt; : 单个Consumer和一台NameServer保持长连接，如果该NameServer挂掉，消费者会自动连接下一个NameServer，直到有可用连接为止，并能自动重连。&lt;br/&gt;&lt;strong&gt;2）心跳&lt;/strong&gt;: 与NameServer没有心跳&lt;br/&gt;&lt;strong&gt;3）轮询时间&lt;/strong&gt; : 默认情况下，消费者每隔&lt;strong&gt;30秒&lt;/strong&gt;从NameServer获取所有Topic的最新队列情况，这意味着某个Broker如果宕机，客户端最多要30秒才能感知。&lt;/p&gt;
&lt;h4 id=&quot;consumer与broker关系&quot;&gt;2、 Consumer与Broker关系&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1）连接&lt;/strong&gt; :单个消费者和该消费者关联的所有broker保持长连接。&lt;/p&gt;
&lt;h4 id=&quot;负载均衡-1&quot;&gt;3、 负载均衡&lt;/h4&gt;
&lt;p&gt;集群消费模式下，一个消费者集群多台机器共同消费一个Topic的多个队列，一个队列只会被一个消费者消费。如果某个消费者挂掉，分组内其它消费者会接替挂掉的消费者继续消费。&lt;/p&gt;

&lt;h2 id=&quot;五-producer生产者&quot;&gt;&lt;span&gt;五、 Producer(生产者)&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;producer与name-server关系&quot;&gt;1、 Producer与Name Server关系&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1）连接&lt;/strong&gt; 单个Producer和一台NameServer保持长连接，如果该NameServer挂掉，生产者会自动连接下一个NameServer，直到有可用连接为止，并能自动重连。&lt;br/&gt;&lt;strong&gt;2）轮询时间&lt;/strong&gt; 默认情况下，生产者每隔30秒从NameServer获取所有Topic的最新队列情况，这意味着某个Broker如果宕机，生产者最多要30秒才能感知，在此期间，&lt;br/&gt;发往该broker的消息发送失败。&lt;br/&gt;&lt;strong&gt;3）心跳&lt;/strong&gt; 与nameserver没有心跳&lt;/p&gt;
&lt;h4 id=&quot;与broker关系&quot;&gt;2、 与broker关系&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;连接&lt;/strong&gt; 单个生产者和该生产者关联的所有broker保持长连接。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://jm.taobao.org/2017/01/12/rocketmq-quick-start-in-10-minutes/&quot;&gt;1、十分钟入门RocketMQ&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/linyaogai/article/details/77876078&quot;&gt;2、RocketMQ nameserver、broker之间的关系&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/3d8d594d9161&quot;&gt;3、RocketMQ-NameServer&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（中将8）&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 26 Jun 2019 16:09:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>RocketMQ(1) 架构原理 RocketMQ是阿里开源的分布式消息中间件，跟其它中间件相比，RocketMQ的特点是 纯JAVA实现 ； 集群和HA实现相对简单 ； 在发生宕机和其它故障时消息丢</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/11094624.html</dc:identifier>
</item>
<item>
<title>STL-空间配置器、迭代器、traits编程技巧 - gatsby123</title>
<link>http://www.cnblogs.com/gatsby123/p/11094655.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gatsby123/p/11094655.html</guid>
<description>&lt;h2 id=&quot;内存分配和释放&quot;&gt;内存分配和释放&lt;/h2&gt;
&lt;p&gt;STL中有两个分配器，一级分配器和二级分配器，默认使用二级分配器，使用二级分配器分配大内存时会调用一级分配器去执行，一级分配器使用malloc和free分配和释放内存。如果分配小内存那么二级分配器会从内存池中进行查找，防止malloc/free的开销。&lt;br/&gt;&lt;img src=&quot;https://blog-1253119293.cos.ap-beijing.myqcloud.com/STL/traits_alloc/allocator.png&quot; alt=&quot;二级配置器&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了了解原理，不深挖细节，只实现一级分配器也是可以的：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class first_level_alloc {
public:
    static void* allocate(size_t n) {
        void* result = malloc(n);       //直接使用malloc
        //todo: out of memory handler
        return result;
    }
    static void deallocate(void* p, size_t) {
        free(p);            //直接使用free
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一级分配器，直接调用malloc和free分配和释放内存。这里也没有处理分配失败的情况。&lt;/p&gt;
&lt;p&gt;为了方便使用定义一个包装类：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T, typename Alloc&amp;gt;
class simple_alloc {
public:
    static T* allocate(size_t n) {
        return (0 == n) ? nullptr : static_cast&amp;lt;T *&amp;gt;(Alloc::allocate(n * sizeof(T)));
    }
    static T* allocate() {
        return static_cast&amp;lt;T *&amp;gt;(Alloc::allocate(sizeof(T)));
    }
    static void deallocate(T *p, size_t n) {
        if (0 != n) {
            Alloc::deallocate(p, n * sizeof(T));
        }
    }
    static void deallocate(T *p) {
        Alloc::deallocate(p, sizeof(T));
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对外使用这个包装类模板参数T指定要分配的对象类型，Alloc指定分配器，因为没有实现二级分配器，所以都是指定为一级分配器first_level_alloc。&lt;/p&gt;
&lt;h2 id=&quot;对象的构造和析构&quot;&gt;对象的构造和析构&lt;/h2&gt;
&lt;p&gt;定义如下三个函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
inline void construct(T* p, const T&amp;amp; value) {
    new(p) T(value);   //placement new
}
template &amp;lt;typename T&amp;gt;
inline void destroy(T *p) {
    p-&amp;gt;~T();
}
//todo:low efficiency
template &amp;lt;typename ForwardIterator&amp;gt;
inline void destroy(ForwardIterator first, ForwardIterator last) {
    for (; first != last; ++first) {
        destroy(&amp;amp;*first);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;void construct(T* p, const T&amp;amp; value)&lt;/code&gt;：在p指向的位置用value拷贝构造T对象并返回。这里用到了placement new。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void destroy(T *p)&lt;/code&gt;：析构p指向处的T对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void destroy(ForwardIterator first, ForwardIterator last)&lt;/code&gt;：析构[first, last)区间的对象。这里没有考虑效率，直接使用for循环调用destroy。STL库中使用模板特例化，根据迭代器指向的类型有没有trivial destructor，执行不同的特例化版本。如果有trivial destructor，比如内置类型，那么什么也不用做。如果有non-trivial destructor才调用上述的那个版本。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;traits要解决的问题&quot;&gt;traits要解决的问题&lt;/h2&gt;
&lt;p&gt;假如算法中要声明“迭代器所指类别”的变量，该怎么办？&lt;/p&gt;
&lt;h3 id=&quot;内嵌类别声明解决非指针迭代器的情况&quot;&gt;内嵌类别声明解决非指针迭代器的情况&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
struct MyIter {                     //模拟迭代器类型
    typedef T value_type;   //内嵌类别声明
    T* ptr;
    MyIter(T* p = 0) :ptr(p) {}
    T&amp;amp; operator*() const {
        return *ptr;
    }
};

template &amp;lt;typename I&amp;gt;
typename I::value_type    //返回类型为迭代器指向的类型
func(I ite) {      //该函数传入一个指针，返回指针指向的值。
    return *ite;
}

int main() {
    MyIter&amp;lt;int&amp;gt; ite(new int(8));
    cout &amp;lt;&amp;lt; func(ite);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MyIter模拟迭代器，T是迭代器所指的类型，通过在迭代器内&lt;code&gt;typedef T value_type;&lt;/code&gt;后，就能用MyIter::value_type定义T类型的变量。&lt;br/&gt;上面的方法解决了一部分问题，但是普通指针也是迭代器类型，我们没办法给指针应用上面的方法。比如上面的func，如果我们传入一个指针，肯定无法通过编译。&lt;/p&gt;
&lt;h3 id=&quot;使用模板特例化解决普通指针的情况&quot;&gt;使用模板特例化解决普通指针的情况&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
struct MyIter {
    typedef T value_type;
    T* ptr;
    MyIter(T* p = 0) :ptr(p) {}
    T&amp;amp; operator*() const {
        return *ptr;
    }
};

template &amp;lt;typename I&amp;gt;
struct iterator_traits {            //针对普通迭代器的模板类
    typedef typename I::value_type value_type;
};

template &amp;lt;typename I&amp;gt;
struct iterator_traits&amp;lt;I*&amp;gt; {      //针对指针类型的模板特例化
    typedef I value_type;
};

template &amp;lt;typename I&amp;gt;
typename iterator_traits&amp;lt;I&amp;gt;::value_type
func(I ite) {                   //该函数返回迭代器或这种指向的值
    return *ite;
}

int main() {
    MyIter&amp;lt;int&amp;gt; it(new int(8));
    int* ip = new int(8);
    std::cout &amp;lt;&amp;lt; func(ip) &amp;lt;&amp;lt; std::endl;
    std::cout &amp;lt;&amp;lt; func(it);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了一个模板类iterator_traits，实际使用时&lt;code&gt;iterator_traits&amp;lt;I&amp;gt;::value_type&lt;/code&gt;就是迭代器I所指的类型，如果是迭代器是指针类型，那么匹配的是itetraor_traits的特例化，&lt;code&gt;iterator_traits&amp;lt;I&amp;gt;::value_type&lt;/code&gt;依然可以得到指针所指类型。&lt;/p&gt;
&lt;p&gt;所以所谓的traits就是一个模板类和一系列模板特例化。通过这个模板类可以得到指针或者迭代器的相关类型。&lt;/p&gt;
&lt;p&gt;同时如果一个迭代器类型如果想要和traits类配合使用需要在其内部通过typedef定义value_type类型。&lt;/p&gt;
&lt;h2 id=&quot;迭代器相应类别&quot;&gt;迭代器相应类别&lt;/h2&gt;
&lt;p&gt;前面的迭代器所指类型value_type就是迭代器的相关类别之一，除了迭代器所指类型，还有几个迭代器相关类型。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;value_type：迭代器所指类型，上一节已经讲过了。&lt;/li&gt;
&lt;li&gt;difference type：用来表示两个迭代器之间的距离。&lt;/li&gt;
&lt;li&gt;reference type：迭代器所指类型的引用类型。&lt;/li&gt;
&lt;li&gt;pointer type：迭代器所指类型的指针类型。&lt;/li&gt;
&lt;li&gt;iterator_category：迭代器的类别。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 26 Jun 2019 16:01:00 +0000</pubDate>
<dc:creator>gatsby123</dc:creator>
<og:description>[TOC] 内存分配和释放 STL中有两个分配器，一级分配器和二级分配器，默认使用二级分配器，使用二级分配器分配大内存时会调用一级分配器去执行，一级分配器使用malloc和free分配和释放内存。如果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gatsby123/p/11094655.html</dc:identifier>
</item>
</channel>
</rss>