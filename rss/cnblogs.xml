<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Java 分布式任务调度平台：PowerJob 快速开始+配置详解 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13301803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13301803.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文适合有 Java 基础知识的人群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200714212306208-772904771.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;Salieri&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列。&lt;/p&gt;
&lt;blockquote readability=&quot;1.5686274509804&quot;&gt;
&lt;p&gt;项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/KFCFans/PowerJob&quot;&gt;https://github.com/KFCFans/PowerJob&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;PowerJob 的设计目标为企业级的分布式任务调度平台，即成为公司内部的调度中间件。整个公司统一部署调度中心 powerjob-server，旗下所有业务线应用只需要依赖 'powerjob-worker' 即可接入获取任务调度与分布式计算能力。&lt;/p&gt;
&lt;p&gt;因此，PowerJob 由调度服务器（powerjob-server）和执行器（powerjob-worker）两部分组成，powerjob-server 负责提供 Web 服务和完成任务的调度，powerjob-worker 则负责执行用户所编写的任务代码，同时提供分布式计算能力。&lt;/p&gt;
&lt;p&gt;以下为在本地开发环境快速搭建并试用 PowerJob 的教程。&lt;/p&gt;
&lt;h2 id=&quot;一、step1-初始化项目&quot;&gt;一、STEP1: 初始化项目&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;git clone https://github.com/KFCFans/PowerJob.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;导入 IDE，源码结构如下，我们需要启动调度服务器（powerjob-server），同时在 samples 工程中编写自己的处理器代码&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200714212340501-1023750931.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二、step2-启动调度服务器&quot;&gt;二、STEP2: 启动调度服务器&lt;/h2&gt;
&lt;ol readability=&quot;3.8716981132075&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建数据库（不需要建表，只需要创建数据库）powerjob-daily&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.97489539748954&quot;&gt;
&lt;p&gt;修改配置文件，配置文件的说明&lt;a href=&quot;https://www.yuque.com/ohmyscheduler/guidence/bdvp1u#4DTFD&quot;&gt;官方文档&lt;/a&gt;写的非常详细，此处不再赘述。由于是在本地 IDE 搭建测试环境，因此我们选择使用开发环境的配置文件 &lt;code&gt;application-daily.properties&lt;/code&gt; 来修改并使用。需要修改的地方为数据库配置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;spring.datasource.core.jdbc-url&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring.datasource.core.username&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;spring.datasource.core.password&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当然，有 mongoDB 的同学也可以修改 &lt;code&gt;spring.data.mongodb.uri&lt;/code&gt; 以获取完全版体验。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;0.91970802919708&quot;&gt;
&lt;p&gt;完成配置文件的修改后，可以直接通过启动类 &lt;code&gt;OhMyApplication&lt;/code&gt; 启动调度服务器，观察启动日志，查看是否启动成功～启动成功后，访问 &lt;a href=&quot;http://127.0.0.1:7700/&quot;&gt;http://127.0.0.1:7700/&lt;/a&gt; ，如果能顺利出现 Web 界面，则说明调度服务器启动成功！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;注册应用：点击主页&lt;strong&gt;应用注册&lt;/strong&gt;按钮，填入 &lt;code&gt;oms-test&lt;/code&gt; 和控制台密码（用于进入控制台），注册示例应用（当然你也可以注册其他的 appName，只是别忘记在示例程序中同步修改～）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200714212352912-728982191.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三、step3-编写示例代码&quot;&gt;三、STEP3: 编写示例代码&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;进入示例工程（powerjob-worker-samples），修改配置文件连接 powerjob-server 并编写自己的处理器代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;5.9213973799127&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;修改 powerjob-worker-samples 的启动配置类 &lt;code&gt;OhMySchedulerConfig&lt;/code&gt;，&lt;strong&gt;将 &lt;code&gt;appName&lt;/code&gt; 修改为刚刚在控制台注册的名称&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8.8375939849624&quot;&gt;
&lt;p&gt;编写自己的处理器：在示例工程中新建一个类，继承你想要使用的处理器（各个处理器的介绍可见&lt;a href=&quot;https://www.yuque.com/ohmyscheduler/guidence/hczm7m&quot;&gt;官方文档&lt;/a&gt;），这里为了简单演示，选择使用单机处理器 &lt;code&gt;BasicProcessor&lt;/code&gt; ，以下代码示例演示了在线日志功能的使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Component
public class StandaloneProcessorDemo implements BasicProcessor {

    @Override
    public ProcessResult process(TaskContext context) throws Exception {

        OmsLogger omsLogger = context.getOmsLogger();
        omsLogger.info(&quot;start process,context is {}.&quot;, context);
        System.out.println(&quot;jobParams is &quot; + context.getJobParams());
        
        return new ProcessResult(true, &quot;process successfully~&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;启动示例程序，即直接运行主类 &lt;code&gt;SampleApplication&lt;/code&gt;，观察控制台输出信息，判断是否启动成功。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;四、step4-任务的配置与运行&quot;&gt;四、STEP4: 任务的配置与运行&lt;/h2&gt;
&lt;p&gt;调度服务器与示例工程都启动完毕后，再次前往 Web 页面（ &lt;a href=&quot;http://127.0.0.1:7700/&quot;&gt;http://127.0.0.1:7700/&lt;/a&gt; ），进行任务的配置与运行。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在首页输入框输入配置的应用名称，成功操作后会正式进入前端管理界面。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200714212406672-1031402515.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;点击任务管理 -&amp;gt; 新建任务（右上角），开始创建任务。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200714212417916-722190959.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;完成任务创建后，即可在控制台看到刚才创建的任务，如果觉得等待调度太过于漫长，可以直接点击&lt;strong&gt;运行&lt;/strong&gt;按钮，立即运行本任务。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200714212425432-985227474.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前往&lt;strong&gt;任务示例&lt;/strong&gt;边栏，查看任务的运行状态和在线日志&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200714212434116-1733488259.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;41-基本配置&quot;&gt;4.1 基本配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;任务名称：名称&lt;/li&gt;
&lt;li&gt;任务描述：描述&lt;/li&gt;
&lt;li&gt;任务参数：任务处理时能够获取到的参数（即各个 Processor的process 方法入参 &lt;code&gt;TaskContext&lt;/code&gt; 对象的 jobParams 属性）（进行一次处理器开发就能理解了）&lt;/li&gt;
&lt;li&gt;定时信息：该任务的触发方式，由下拉框和输入框组成&lt;/li&gt;
&lt;li&gt;API -&amp;gt; 不需要填写任何参数，表明该任务由 OpenAPI 触发&lt;/li&gt;
&lt;li&gt;CRON -&amp;gt; 填写 CRON 表达式（&lt;a href=&quot;https://cron.qqe2.com/&quot;&gt;在线生成网站&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;固定频率 -&amp;gt; 填写整数，单位&lt;strong&gt;毫秒&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;固定延迟 -&amp;gt; 填写整数，单位&lt;strong&gt;毫秒&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;工作流 -&amp;gt; 不需要填写任何参数，表明该任务由工作流（workflow）触发&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;42-执行配置&quot;&gt;4.2 执行配置&lt;/h3&gt;
&lt;p&gt;由执行类型（单机、广播和 MapReduce）、处理器类型和处理器参数组成，后两项相互关联。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;内置 Java 处理器 -&amp;gt; 填写该处理器的&lt;strong&gt;全限定类名&lt;/strong&gt;（eg，&lt;code&gt;com.github.kfcfans.oms.processors.demo.MapReduceProcessorDemo&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;Java（容器） -&amp;gt; 填写&lt;strong&gt;容器ID#处理器全限定类名&lt;/strong&gt;（eg，&lt;code&gt;18#com.github.kfcfans.oms.container.DemoProcessor&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;SHELL -&amp;gt; 填写需要处理的脚本（直接复制文件内容）或脚本下载链接（&lt;a href=&quot;http://xxx&quot;&gt;http://xxx&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;PYTHON -&amp;gt; 填写完整的 python 脚本或下载链接（&lt;a href=&quot;http://xxx&quot;&gt;http://xxx&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;43-运行配置&quot;&gt;4.3 运行配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;最大实例数：该任务同时执行的数量&lt;/li&gt;
&lt;li&gt;单机线程并发数：该实例执行过程中每个 Worker 使用的线程数量（MapReduce 任务生效，其余无论填什么，都只会使用必要的线程数...）&lt;/li&gt;
&lt;li&gt;运行时间限制：限定任务的最大运行时间，超时则视为失败，单位&lt;strong&gt;毫秒&lt;/strong&gt;，0 代表不限制超时时间（&lt;strong&gt;不建议不限制超时时间&lt;/strong&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;44-重试配置&quot;&gt;4.4 重试配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Instance 重试次数：实例级别，失败了整个任务实例重试，会更换 TaskTracker（本次任务实例的Master节点），代价较大，大型 Map/MapReduce 慎用。&lt;/li&gt;
&lt;li&gt;Task重试次数：Task 级别，每个子 Task 失败后单独重试，会更换 ProcessorTracker（本次任务实际执行的 Worker 节点），代价较小，推荐使用。&lt;/li&gt;
&lt;li&gt;注：&lt;strong&gt;请注意同时配置任务重试次数和子任务重试次数之后的重试放大&lt;/strong&gt;，比如对于单机任务来说，假如任务重试次数和子任务重试次数都配置了 1 且都执行失败，实际执行次数会变成 4 次！推荐任务实例重试配置为 0，子任务重试次数根据实际情况配置。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;45-机器配置&quot;&gt;4.5 机器配置&lt;/h3&gt;
&lt;p&gt;用来标明允许执行任务的机器状态，避开那些摇摇欲坠的机器，0 代表无任何限制。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最低 CPU 核心数：填写浮点数，CPU 可用核心数小于该值的 Worker 将不会执行该任务。&lt;/li&gt;
&lt;li&gt;最低内存（GB）：填写浮点数，可用内存小于该值的 Worker 将不会执行该任务。&lt;/li&gt;
&lt;li&gt;最低磁盘（GB）：填写浮点数，可用磁盘空间小于该值的 Worker 将不会执行该任务。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;46-集群配置&quot;&gt;4.6 集群配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;执行机器地址：指定集群中的某几台机器执行任务（debug 的好帮手），多值英文逗号分割，如&lt;code&gt;192.168.1.1:27777,192.168.1.2:27777&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最大执行机器数量：限定调动执行的机器数量&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;47-报警配置&quot;&gt;4.7 报警配置&lt;/h3&gt;
&lt;p&gt;选择任务执行失败后报警通知的对象，需要事先录入。&lt;/p&gt;
&lt;p&gt;基础的教程到这里也就结束了～更多功能示例可见&lt;a href=&quot;https://www.yuque.com/ohmyscheduler/guidence/ysug77&quot;&gt;官方文档&lt;/a&gt;，工作流、MapReduce、容器等高级特性等你来探索！&lt;/p&gt;
&lt;h2 id=&quot;五、总结与预告&quot;&gt;五、总结与预告&lt;/h2&gt;
&lt;p&gt;本章详细介绍了 PowerJob 的快速入门，根据本文能够快速搭建起本地开发/测试环境。下一章节，我将会对PowerJob 整体的架构做一个介绍，为后面的技术剖析做准备。&lt;/p&gt;
&lt;p&gt;那我们下期再见喽～&lt;/p&gt;
&lt;h2 id=&quot;作者游记&quot;&gt;作者游记&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200714212448729-1796604363.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“常在河边走，哪有不湿鞋”，然而，这句话在茶卡盐湖却属于奢望。&lt;/p&gt;
&lt;p&gt;稍有不慎，隐秘的盐窟便对你敞开怀抱，瞬间将你吞噬～&lt;/p&gt;
&lt;p&gt;盐湖如此，人生亦是如此。&lt;/p&gt;
&lt;p&gt;难免不幸时，也要对着美好的明天微笑～&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放（作者在 Java 群），添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214622307-1765002891.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jul 2020 00:37:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文适合有 Java 基础知识的人群 作者：HelloGitHub-Salieri 引言 HelloGitHub 推出的《讲解开源项目》系列。 项目地址： https://github.com/KFC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13301803.html</dc:identifier>
</item>
<item>
<title>说透代码评审 - 张飞洪[厦门]</title>
<link>http://www.cnblogs.com/jackyfei/p/13299877.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackyfei/p/13299877.html</guid>
<description>&lt;ul&gt;&lt;li&gt;《互联网大厂如何玩转代码评审》 梁松华 京东高级开发工程师&lt;/li&gt;
&lt;li&gt;《学习Facebook真正发挥代码审查的提效作用》 葛俊 前Facebook内部工具团队Tech Lead&lt;/li&gt;
&lt;li&gt;《代码审查哪种方式更适合我的团队》 葛俊 前Facebook内部工具团队Tech Lead&lt;/li&gt;
&lt;li&gt;《聊一聊代码审查》熊燚（四火）Oracle首席软件工程师&lt;/li&gt;
&lt;li&gt;《代码审查普遍存在的 6 大问题》松花皮蛋me InfoQ&lt;/li&gt;
&lt;li&gt;《代码评审：寄望与哀伤》胡峰 京东成都研究院技术专家&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613&quot; data-header=&quot;1&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　代码如熵，不加外力很容易就会随着代码的不断堆积而发生腐烂和溃败。我们不是不知道代码问题，而是对既成事实难有改变。但是如果站在迭代的角度思考下一次升级，如何确保新的代码质量就显得很有必要，特别是你的代码需要重写的时候，我想你一定会遇到和我一样的问题，我们究竟应该如何保证我们的代码的质量？于是就有了这篇工具型的文章。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613&quot; data-header=&quot;1&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;        以下内容架构是我摘录觉得比较重要的纬度，很多方法论借鉴了以上几篇文章思想，对代码评审的各种情况基本都谈得比较到位了，反复精读基本上就可以采用拿来主义，希望对你的团队评审有所帮助。&lt;/span&gt;&lt;/p&gt;

&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;不审查的坏处&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　代码的质量反应了我们的产品质量，产品不稳定、老是出现BUG，直接影响客户满意度和口碑。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　同时，代码的好坏决定了未来运维的成本，如果因为一时疏忽和妥协，回头又没有及时修改，中间又出现人员变动，那么这份代码的后患是无穷的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　因为不规范，可读性差，对交接人来说从心态上是本能反抗的，但是又不得不改，于是就一通乱改，能贴膏药就贴膏药，能运行就可以，管他规范不规范。这样导致的后果是，代码从不规范走向更加不规范，很难想象经过5-10年持之以恒的不规范，这个产品还能活着。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　技术债务的危害怎么形容都不为过，轻则系统局部异常，中等的会导致修改困难，严重的需要推翻重来。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　从物理学上看，&lt;a class=&quot;ql-link ql-author-13832613 ql-font-microsoftyahei&quot; href=&quot;http://www.ruanyifeng.com/blog/2017/04/entropy.html&quot; rel=&quot;noopener noreferrer nofollow&quot; target=&quot;_blank&quot;&gt;熵&lt;/a&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;让我们理解了一件事，如果不施加外力影响，事物永远向着更混乱的状态发展，所以规范和审查就显得弥足珍贵了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　从软件设计看，软件设计要关注长期变化，需要应对需求规模的膨胀。如果腐烂的代码日积月累，这些在不断流变腐烂的东西又怎能支撑起长期的变化呢！&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　做产品，不审查不足以长久。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;评审的好处&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　在软件工程师日常的开发工作中，&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;如果要挑出一项极其重要，却又很容易被忽视的工作，在我看来代码审查几乎是无可争议的第一&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;。代码审查是一个&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;低投入、高产出&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;的开发活动，就个人而言，从其中学到的习惯、方法和知识，获益匪浅。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　代码评审的作用很多，主要表现在 6 个方面。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　好处 1，&lt;strong class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;尽早发现 Bug 和设计中存在的问题。&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;我们都知道，问题发现得越晚，修复的代价越大。代码审查把问题的发现尽量提前，自然会提高效能。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　好处 2，&lt;strong class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;提高个人工程能力。&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;不言而喻，别人对你的代码提建议，自然能提高你的工程能力。事实上，仅仅因为知道自己的代码会被同事审查，你就会注意提高代码质量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　好处 3，&lt;strong class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;团队知识共享。&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;一段代码入库之后，就从个人的代码变成了团队的代码。代码审查可以帮助其他开发者了解这些代码的设计思想、实现方式等。另外，代码审查中的讨论记录还可以作为参考文档，帮助他人理解代码、查找问题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　好处 4，&lt;strong class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;针对某个特定方面提高质量&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;。一些比较专业的领域，比如安全、性能、UI 等，可以邀请专家进行专项审查。另外，一些核心代码或者高风险代码，也可以通过团队集体审查的方式来保证质量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　好处 5，&lt;strong class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;统一编码风格。&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;这，也是代码审查的一个常见功能，但最好能通过工具来实现自动化检查。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　好处 6，&lt;strong class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;社会性功用。&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;如果你在编程，而且知道一定会有同事将检查你的代码，那么你编程的姿势和心态就会完全不同。这之间的微妙差异正是在于会不会有人将对你的代码做出反馈与评价。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　大多数的争议，都不是在否认代码审查的好处，而是聚焦在不进行代码审查的那些“原因” 或者 “借口”上。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;1）代码评审费时费力：&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　项目期限 Deadline 已定，时间紧迫，天天加班忙成狗了，谁还愿意搞代码评审？这是一个最常见的客观阻碍因素，因为 Deadline 很多时候都不是我们自己能确定和改变的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;改来改去无非是一些格式、注释、命名之类不痛不痒的问题。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;2）代码审查不利于团建：&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　因为经常有程序员因为观点不同在代码审查的时候吵起来。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;3）主观意愿&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　评审人用自己主观意见看待别人的代码。觉得别人的代码风格不够好，或者把个人的喜好强加到别人身上。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;4）团队人员结构搭配不合理。&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　新人没经验的多，有经验的少。新人交叉评审可能效果不好，老是安排经验多的少数人帮助 Review 多数新人的代码，新人或有收获，但对高级或资深程序员又有多大裨益？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　一个好的规则或制度，总是需要既符合多方参与者的个体利益又能满足组织或团队的共同利益，这样的规则或制度才能更顺畅、有效地实施和运转。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;5）有人就是不喜欢别人 Review 他的代码，他会感觉是在找茬。&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　比如，团队中存在一些自信超强大的程序员，觉得自己写的代码绝对没问题，不需要别人来给他 Review。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;6）效果非常差、形式主义&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　代码评审做得不好确实像形式主义，纯粹走个过场。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　落地之前，我们先搞清楚评审形式是什么样子的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　一般来说人工检查才叫审查，机器进行的检查一般叫作代码检查或者代码自动检查。常见的办法是人工评审和机器检查同时进行。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　代码评审形式可以分为：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;机器检查&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;人工评审&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;纯线上评审&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;线下投屏评审&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;(推荐)&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　这里推荐做法是线下投屏评审，或许传统、保守，但是利大于弊。根据我的经验，线上问题处理和后续工作计划调整，所产生的一次性成本远远大于一次性线下评审。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　我们应该约定以下几种操作都要进行评审，一般变动比较大的需要多人评审，一般性修改只需要其他同事二次检查即可。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/127185/202007/127185-20200714162638306-1936664276.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　在这个问题上，原则是业务密切相关的人员都要参加，比如说：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;开发人员的导师&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;负责这个业务流转链路的下一个环节的同事&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　大家参与进来能够及时同步信息，避免信息的不对称，也就是说可以避免其他环节需要人员兼容改动的，可是实际上没有人考虑到，而导致漏改问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　问题：为什么说要坚持密切相关的人员都参加这个原则？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　答案：大部分人对于自己不感兴趣或者听不懂的事务时，非常容易走神。所以组织业务密切相关的一线开发，组长，及领导参与评审就足够了。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　最后还有一个需要我们搞懂的问题，弄清楚之后，我们才能很好的把代码评审落地。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;代码评审容易犯的错误：评审人用自己主观意见看待别人的代码。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　觉得别人的代码风格不够好，或者把个人的喜好强加到别人身上，有这种想法固然好，如果觉得在团队内应该统一使用这种风格，最好申请把他纳入到团队的代码规范文档中，以避免代码评审的重点产生偏移。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;代码评审的目的：最大化维护团队的利益。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　为了软件的良好发展和团队的高效协作，每个人的代码最好看上去都差不多，这样修改别人的代码就比较亲切。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;代码评审应该关注的重点：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;是否明显的逻辑错误&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;是否落实了代码规范&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;代码的可读性和可维护性是否良好&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;代码是否有违背基本的设计模式理念&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;代码评审不应该过多关注：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;代码是否能正常运行&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;代码是否满足业务需求&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;是否覆盖业务场景&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　这些应该由编写代码的人和测试人员共同保证&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　每个想要高效工作的程序员，都不希望自己的计划被频繁打断，大多数情况下按部就班，跟着规划走才是最稳妥的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　下面是评审中的六个流程：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613&quot;&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/127185/202007/127185-20200714162842929-794058399.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;约定规范文档&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　为了避免审查当中的主观喜好，制定有章可循的约定是前提条件。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;制定排期：&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　我们可以约定每周一发起代码评审，由提交人根据逻辑变动情况，给出一个评审大概需要花费的时间，同时结合需求的提测时间，上线时间，确定好什么时候进行评审，避免过多杂乱的时间线。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;补充资料&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　在评审工期申请后，还需要补充资料，交代清楚需求背景、编码内容以及功能影响的范围，评审人就可以根据这些资料，评估应该重点关注哪些代码隐患。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;比如需求涉及到金钱往来，那么评审人就应该更加仔细留意每一行代码，检查是否有明显的逻辑错误，避免上线后导致用户或者公司的利益受到损害。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;代码评审&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　代码评审中发现的问题，根据严重性决定是否进行二次评审。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;完善必备要素&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　发现问题并不可怕，可怕的是相同的问题不同的同事重复犯，所以必须在评审后完善代码评审必须具备的元素清单，比如监控、注释等。如果不满足任何一个，直接驳回，毕竟重复提及相同的问题，会大家参与者的积极性。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;完善代码规范约定&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　另外也需要定期回顾之前的代码评审，完善团队代码规范约束，让软件质量和团队能力都想着更好的方向走。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　从我的经验来看，要成功引入代码审查，首先要在团队内达成一些&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;重要的共识&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;，然后选择&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;试点团队&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;实行，最后选择合适的&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;工具和流程&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　个人觉得不是所有的团队都适合做代码审查，一定要慎用。特别是那种项目类型的团队，救火类型的团队，团队规模很小，业务优先的团队。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;1、代码审查应该计入工作量&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　代码审查如果没有为它预留时间，结果是大家没有时间做审查，效果自然也就不好。于是，形成恶性循环，代码审查要么被逐渐废弃，要么流于形式。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　预估工作量的时候需要考虑代码审查的时间。比如，平均每天大约预留 30-60分钟用于代码审查，大概占写代码总时间的 1/5。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　一般的代码审查速度约是一小时 150 行，对于一些关键的软件，一小时数百行代码的审查速度太快，可能无法找到程序中的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　同时，代码审查的情况会作为绩效考评的一个重要指标。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　另外，平时需要给审查者关于审查质量的实时反馈。比如，刚加入公司的时候，对代码审查不够重视，做得不够好。主管应该对给反馈意见，让新人提高审查质量。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　其次，让新人多给同事做审查，另外，是让新人多给一些结构上的建议，不用太重视语法细节。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　总之，管理者要明确代码审查是开发工作的重要组成部分，并记入工作量和绩效考评。这，是成功引入代码审查的前提，再怎么强调都不为过。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;2、选择试点团队&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　为什么要选择试点团队，说白了就是要避免纸上谈兵的不足，在小范围内做实验可以有效降低风险，尽可能得收集负面效果，并及时改进。&lt;/span&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;否则大规模出现负面效果是很影响大家信心，甚至出现反面效果。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;3、选择工具，融合机器审查和人工审查&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　关于工具，如果你的团队本来已经在使用 GitLab、GitHub、Gerrit、Phabricator 管理代码的话，那么很容易上手代码审查。因为，GitHub、GitLab 有基于 PR 的审查。而 Gerrit 和 Phabricator 本身就主打代码审查的功能。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　第一，将代码提交到本地 Git 仓库或者用于审查的远端 Git 服务器的分支上；第二，把 commit 提交给代码审查工具；第三，代码审查工具开始进行机器审查和人工审查；第四，如果审查通不过就打回重做，开发者修改后重新提交审查，直到审查通过后代码入库。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/127185/202007/127185-20200714163130793-1964432125.png&quot; width=&quot;600&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　关于工具集的适用：使用 GitLab、Jenkins 和 SonarQube 进行配置。具体使用 GitLab 管理代码，代码入库后通过钩子触发 Jenkins，Jenkins 从 GitLab 获取代码，运行构建，并通过 Sonar 分析结果。这里有一篇不错的文章供你参考&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;提高提交的原子性&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　每次提交的代码粒度至关重要，我们可以反过来思考：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;如果提交的是半个功能的代码会怎么样？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;如果提交的是一周的代码会怎么样？&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;所以原子性就是合适的粒度，大功能要拆分来提交，一周的代码的代码要按天来提交。否则对于评审人员来说是很反感的，因为只会增加审查的难度。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;提高提交说明的质量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-indent-1&quot;&gt;&lt;span class=&quot;ql-font-microsoftyahei ql-author-13832613&quot;&gt;　　我们应该经常见到很多的提交是这样描述的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-font-microsoftyahei ql-author-13832613&quot;&gt;BUG&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-font-microsoftyahei ql-author-13832613&quot;&gt;FIX&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-font-microsoftyahei ql-author-13832613&quot;&gt;更新&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　下面是葛俊给出的三个改进步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;　　第一步，&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;规定提交说明一定要包括标题、描述和测试情况三部分，但暂时还不具体要求必须写多少字。比如，测试部分可以简单写一句“没有做测试”，但一定要写。如果格式不符合要求，审查者就直接打回。这个格式要求工作量很小，比较容易做到，两个星期后整个团队就习惯了。虽然只是在提交说明里增加了简单描述，也已经为审查者和后续工作中进行问题排查提供一些必要信息，所以大家也比较认可这个操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;　　第二步，&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;要求提交说明必须详细写明测试情况。如果没有做测试一定要写出具体理由，否则会被直接打回。这样做，不但为审查者提供了方便，还促进了开发人员的自测。整个团队在一个多月后，也养成了详细描述测试情况的习惯。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;　　第三步，&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;逐步要求提交的原子性。我要求每一个提交要在详细描述部分描述具体实现了哪些功能。如果一个提交同时实现了多个功能，那就必须解释为什么不能拆开提交；如果解释不合理的话，提交直接被打回。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　提交说明是提高代码审查的利器，好的格式应该包含以下几个方面：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;　　标题，&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;简明扼要地描述这个提交。这部分最好在 70 个字符之内，以确保在单行显示的时候能够显示完整。比如，在命令行常用的 git log --oneline 输出结果要能显示完全。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;　　详细描述，&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;包括提交的目的、选择这个方法的原因，以及实现细节的总结性描述。这三个方面的内容最能帮助审查者阅读代码。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;　　测试情况，&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;描述的是你对这个提交做了什么样的测试验证，具体包括正常情况的输出、错误情况的输出，以及性能、安全等方面的专项测试结果。这部分内容，可以增加审查者对提交代码的了解程度以及信心。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;strong class=&quot;ql-author-13832613&quot;&gt;　　与其他工具和系统相关的信息&lt;/strong&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;，比如相关任务 ID、相关的冲刺（sprint，也可翻译为“迭代”）链接。这些信息对工具的网状互联提供基础信息，非常重要。这里还有一个 Git 的技巧是，你可以使用 Git 的提交说明模板（Commit Message Template），来帮助团队使用统一的格式。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　虽说评审需要规范文档做指导，但是很多规范其实无法做的那么细，特别是规范早期，很多规范是缺失的。在评审过程中难免会出现争论或者相持不下的情况。这个时候有必要把评审的原则提前做一个说明，可以消除未来不必要的麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;相互尊重&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　从编码作者的角度来看，审查者要花费时间去阅读他并不熟悉的代码，来帮助你提高，应该尽量为审查者提供方便。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;比如，提高提交说明的质量，就是对审查者最基本的尊重。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;还有，如果你的代码都没有进行自测就提交审查，你觉得审查者心里会怎么想呢？&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;又如，如果你提交的一个审查有一万行代码，让审查者怎么看呢？&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　所以，代码作者一定要提审查者着想，帮助审查者能够比较轻松地完成审查。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　从审查者的角度来看，在提出建议的时候，一定要考虑代码作者的感受。最重要的一点是，不要用一些主观标准来评判别人的代码。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;基于讨论&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　代码审查的目的是讨论，而不是评判，这个原则至关重要。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　讨论的心态，有助于放下不必要的自尊心，从而顺利地进行技术交流，提高审查效率。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　另外，讨论的心态也能促进大家提早发出审查，从而尽早发现结构设计方面的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　另外，我还有一些关于讨论的建议：审查者切记不要说教，说教容易让人反感，不是讨论的好方法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-13832613 ql-text-indent-1&quot;&gt;&lt;span class=&quot;ql-author-13832613&quot;&gt;　　审查者提意见即可，不一定要提供解决方法。给定答案也可能会引起不必要的反感。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　这些是代码评审过程中发现的共同的问题，可以一起放在代码规范文档中。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;缺少注释和变更说明&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　比如下面三个方法名称，参数，返回值相似，为什么会出现这种情况？&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　大半是开发者发现原来的代码没有注释，所以不敢修改，于是拷贝一份后只是稍微修改了一下，这样才出现了相似冗余的代码。重复代码最可怕的地方就是错该或者漏改。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
publi Article GetArticleById(long id)
{
  return null;
}
publi MaterialPO GetMaterialById(long id)
{
  return null;
}
publi ArticleVO GetArticleByIdWithoutStatus(long id)
{
  return null;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;过渡相信第三方&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;对请求参数没有限制&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;对请求参数没有校验&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//错误示范
Boolean SaveError(List&amp;lt;ShareDetail&amp;gt; list)
{
   //错误原因：只判断非空，但是无法保证list中的detail是非空的
   if(list.IsEmpty())
   {
      return false;
   }  
   //错误原因：无法保证list中的id都是一样的
   Int id = list.get(0).getId();
   //保存数据
   return Save(id,list)
}


//正确示范
Boolean SaveRight(Int id,List&amp;lt;ShareDetail&amp;gt; list)
{
   //深度判断非空情况
   if(id==null || CollectionUtil.hasNull(list))
   {
      return false;
   }  
   //id从参数中获取，避免二义性
   return Save(id,list)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;变量作用域过大&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public static void main(Sstring[] args){
  ShareDetail shareDetail1 =new ShareDetail();
  //错误示例：对象在多个方法间进行值地址引用传递
  varErrorStep1(shareDetail1);  
  //正常示例
  ShareDetail shareDetail2=varRight();
}


public static varErrorStep1(ShareDetail shareDetail)
{
   //其他复杂操作
  shareDetail.setId(111);
  var ErrorStep2(shareDetail);
}


public static void varErrorStep2(ShareDetail shareDetail)
{
  //其他复制操作
  shareDetail.setName(&quot;hello&quot;);
}


public static ShareDetail varRight()
{
  ShareDetail shareDetail =new ShareDetail();
  shareDetail.setId(111);
  shareDetail.setName(&quot;hello&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;缺少阶段性结果&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　对于过多的if-else判断，优化方法：先进性异常判断，如果有异常就快速返回结果。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//错误示范
public void SetpError()
{
  //标记位
  Boolean flag=false;
  List&amp;lt;Integer&amp;gt; list=new ArrayList&amp;lt;&amp;gt;();
  for(Integer detail:list)
  {
    //如果列表中有值大于10则将标记设置为true
    if(detail&amp;gt;0)
      {
        flag=true;
      }
    }
  }
  //
  if(flag)
  {
    return；
  }
}
//正确示范
public void SetpRight()
{
  //步骤一：校验参数
  List&amp;lt;Integer&amp;gt; list=new ArrayList&amp;lt;&amp;gt;();
  for(Integer detail:list)
  {
    //如果列表中有值大于10则将标记设置为true
    if(detail&amp;gt;0)
      {
        return; //移除多余的标记，直接中断；
      }
    }
  }
  //步骤二：
  
  //步骤三：


}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　同时为了增加代码的层次感，可以让代码阶段性的输出结果，比如编写时注释好每一个步骤要做什么。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;ql-long-13832613&quot; data-header=&quot;2&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;日志打印问题&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
//错误示范
public Boolean logError(Integer id,List&amp;lt;ShareDetail&amp;gt; list)
{
  if(id==null || CollectionUtil.hasNull(list))
  {
      return false;
  }
  logger.info(&quot;logError run&quot;);
  
  try{
    return shareDao.save(id,list);
  }catch(Exception e)
  {
    //错误一：不记录异常上下文
   logger.error(&quot;save error&quot;);
   //错误二：只记录了有限的上下文
   logger.error(&quot;save error e:{0}&quot;,e.getMessage());
  }
  return false;
}


//正确示范
public Boolean logError(Integer id,List&amp;lt;ShareDetail&amp;gt; list)
{
  if(id==null || CollectionUtil.hasNull(list))
  {
      return false;
  }
  //info级别在非线上环境很容易
  logger.info(&quot;logError run&quot;);
  
  try{
    return shareDao.save(id,list);
  }catch(Exception e)
  {
    //正确：充分记录错误上下文
    logger.error(&quot;save error&quot;);
    //正确：规避记录日志时出现控制着，规避内存OOM
    logger.error(&quot;save error id:{},e:{},list:{},id,list==null?list:JSONObject.toJSON(list),e);
  }
  return false;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　想让团队从心里接受代码评审的理念，认可它是日常开发过程必不可少的步骤，那么就要提高代码评审的质量，否则评审的时候，大家都在搞私事，容易流于形式，而要提高代码评审的质量，我们必须明确代码评审的形式，对象，参与者，关注点，流程，常见问题。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1 ql-long-13832613&quot;&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;　　我希望大家能记住一件事，代码评审要从团队利益出发，让每个人都能够从里面持续得到正反馈，这才是最重要的。&lt;/span&gt;&lt;span class=&quot;ql-author-13832613 ql-font-microsoftyahei&quot;&gt;如果时间充足的话最好邀请测试人员一起参与，让测试人员充分了解代码改动点，有助于对测试场景边界的把控。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1&quot;&gt; &lt;/p&gt;



&lt;p class=&quot;ql-text-indent-1&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-text-indent-1&quot;&gt; &lt;/p&gt;

</description>
<pubDate>Wed, 15 Jul 2020 00:30:00 +0000</pubDate>
<dc:creator>张飞洪[厦门]</dc:creator>
<og:description>参考资料： 《互联网大厂如何玩转代码评审》 梁松华 京东高级开发工程师 《学习Facebook真正发挥代码审查的提效作用》 葛俊 前Facebook内部工具团队Tech Lead 《代码审查哪种方式更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackyfei/p/13299877.html</dc:identifier>
</item>
<item>
<title>小书MybatisPlus第4篇-表格分页与下拉分页查询 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13303550.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13303550.html</guid>
<description>&lt;p&gt;本文为mybatis系列文档的第4篇，前三篇请访问下面的网址。&lt;/p&gt;
&lt;h2 id=&quot;一、让spring-boot-mybatisplus支持分页&quot;&gt;一、让Spring Boot-MybatisPlus支持分页&lt;/h2&gt;
&lt;p&gt;在已经集成了Mybatis Plus的Spring项目中加入如下分页拦截器的配置，让MybatisPlus支持分页&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class MybatisPlusConfiguration {
    //配置分页拦截器
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        return new PaginationInterceptor();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二、单表查询分页-表格分页&quot;&gt;二、单表查询分页-表格分页&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void testSelect() {
  LambdaQueryWrapper&amp;lt;User&amp;gt; query = new LambdaQueryWrapper&amp;lt;&amp;gt;();
  query.ge(User::getAge,10)      //查询条件：年龄大于10
       .orderByDesc(User::getAge);   //按照年龄的倒序排序

  Page&amp;lt;User&amp;gt; page = new Page&amp;lt;&amp;gt; (1,10);   //查询第1页，每页10条数据
  userMapper.selectPage(page,query);   //page分页信息，query查询条件

  System.out.println(&quot;总页数：&quot;+ page.getPages());
  System.out.println(&quot;总记录数：&quot;+ page.getTotal());

  // 分页返回的对象与传入的对象是同一个
  List&amp;lt;User&amp;gt; list = page.getRecords();
  list.forEach(System.out::println);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;总页数：1
总记录数：6
User(id=3, name=Tom, age=28, email=test3@baomidou.com)
User(id=5, name=Billie, age=24, email=test5@baomidou.com)
User(id=4, name=Sandy, age=21, email=test4@baomidou.com)
User(id=2, name=Jack, age=20, email=test2@baomidou.com)
User(id=1, name=Jone, age=18, email=test1@baomidou.com)
User(id=1280261858003038209, name=字母哥, age=18, email=null)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在分页查询过程中，一共执行了两条SQL&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 第一条SQL用于查询在query条件下的总条数
SELECT COUNT(1) FROM user WHERE age &amp;gt;= ? 

# 第二条SQL用于查询具体的数据
SELECT id,name,age,email 
FROM user 
WHERE age &amp;gt;= ? 
ORDER BY age DESC 
LIMIT ?,? 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种分页方式比较适合于传统应用中，表格分页的开发。需要给出总条数，以及每页多少条。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200715082617289-1157480982.png&quot; alt=&quot;表格分页查询&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、不查询总记录数的分页-下拉分页&quot;&gt;三、不查询总记录数的分页-下拉分页&lt;/h2&gt;
&lt;p&gt;在一些现代的互联网资讯网站，或者应用app。通常不会给出数据的总条数，而是通过鼠标或者手势，每次下拉都加载n条数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200715082617875-39516512.gif&quot; alt=&quot;下拉分页&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况下的分页通常就不需要查询总条数了，如果查询总条数浪费数据库的计算资源，使响应时间变长。所以我们应该只做分页数据查询，不查询总条数。设置page分页的第三个参数为false。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200715082618262-1477166855.png&quot; alt=&quot;下拉分页查询&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出结果总页数和总条数都是0，但是分页数据正常查询回来了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;总页数：0
总记录数：0
User(id=3, name=Tom, age=28, email=test3@baomidou.com)
User(id=5, name=Billie, age=24, email=test5@baomidou.com)
User(id=4, name=Sandy, age=21, email=test4@baomidou.com)
User(id=2, name=Jack, age=20, email=test2@baomidou.com)
User(id=1, name=Jone, age=18, email=test1@baomidou.com)
User(id=1280261858003038209, name=字母哥, age=18, email=null)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只执行了这样一个SQL&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ELECT id,name,age,email 
FROM user 
WHERE age &amp;gt;= ? 
ORDER BY age DESC 
LIMIT ?,? 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jul 2020 00:26:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文为mybatis系列文档的第4篇，前三篇请访问下面的网址。 小书MybatisPlus第1篇-整合SpringBoot快速开始增删改查 小书MybatisPlus第2篇-条件构造器的应用及总结 小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13303550.html</dc:identifier>
</item>
<item>
<title>如果你每次面试前都要去背一篇Spring中Bean的生命周期，请看完这篇文章 - 程序员DMZ</title>
<link>http://www.cnblogs.com/daimzh/p/13303528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daimzh/p/13303528.html</guid>
<description>&lt;p&gt;当你准备去复习Spring中Bean的生命周期的时候，这个时候你开始上网找资料，很大概率会看到下面这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200707094637369.png&quot; alt=&quot;image-20200707094637369&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先不论这张图上是否全面，但是就说这张图吧，你是不是背了又忘，忘了又背？&lt;/p&gt;
&lt;p&gt;究其原因在于，你没有理解为什么需要这些步骤，也不知道为什么要按这个顺序执行&lt;/p&gt;
&lt;p&gt;笔者在阅读完整个&lt;code&gt;IOC&lt;/code&gt;跟&lt;code&gt;AOP&lt;/code&gt;的源码后，希望通过这篇文章讲一讲我的Spring中Bean生命周期的看法，帮助大家能理解性的记忆整个流程，而不是死记硬背！&lt;/p&gt;

&lt;p&gt;所谓理解也是建立在有一定知识储备的基础上的，所以这里先补充一些基础概念&lt;/p&gt;
&lt;h2 id=&quot;bean创建的三个阶段&quot;&gt;Bean创建的三个阶段&lt;/h2&gt;
&lt;p&gt;Spring在创建一个Bean时是分为三个步骤的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实例化，可以理解为new一个对象&lt;/li&gt;
&lt;li&gt;属性注入，可以理解为调用setter方法完成属性注入&lt;/li&gt;
&lt;li&gt;初始化，你可以按照Spring的规则配置一些初始化的方法（例如，&lt;code&gt;@PostConstruct&lt;/code&gt;注解）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;生命周期的概念&quot;&gt;生命周期的概念&lt;/h2&gt;
&lt;p&gt;Bean的生命周期指的就是在上面三个步骤中后置处理器&lt;code&gt;BeanPostprocessor&lt;/code&gt;穿插执行的过程&lt;/p&gt;
&lt;h2 id=&quot;后置处理器的分析&quot;&gt;后置处理器的分析&lt;/h2&gt;
&lt;p&gt;按照实现接口进行分类&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;直接实现了&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最简单的后置处理器，也就是说直接实现了&lt;code&gt;BeanPostProcessor&lt;/code&gt;接口，这种后置处理器只能在初始化前后执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface BeanPostProcessor {
    
        // 初始化前执行的方法
        @Nullable
        default Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
                return bean;
        }    
    
        // 初始化后执行的方法
        default Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
                return bean;
        }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;直接实现了&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;接口&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在第一种后置处理的基础上进行了一层扩展，可以在Bean的实例化阶段前后执行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 继承了BeanPostProcessor，额外提供了两个方法用于在实例化前后的阶段执行
// 因为实例化后紧接着就要进行属性注入，所以这个接口中还提供了一个属性注入的方法
public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {
        
    // 实例化前执行
        default Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
                return null;
        }
        
    // 实例化后置
        default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
                return true;
        }
    
    // 属性注入
    default PropertyValues postProcessPropertyValues(
        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {

        return pvs;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Spring内部专用的后置处理器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可能有的小伙伴认为，第三种后置处理器肯定就是用来在属性注入前后执行了的吧。我只能说，大兄弟，太天真了，看看下面这张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200707163736980.png&quot; alt=&quot;image-20200707163736980&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况下再为属性注入阶段专门提供两个方法是不是有点多余呢？实际上第三种后置处理器是Spring为了自己使用而专门设计的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface SmartInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessor {
        
    // 推测bean的类型，例如在属性注入阶段我们就需要知道符合依赖类型的Bean有哪些
    @Nullable
    default Class&amp;lt;?&amp;gt; predictBeanType(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
        return null;
    }
        
    // 推断出所有符合要求的构造函数，在实例化对象的时候我们就需要明确到底使用哪个构造函数
    @Nullable
    default Constructor&amp;lt;?&amp;gt;[] determineCandidateConstructors(Class&amp;lt;?&amp;gt; beanClass, String beanName)
        throws BeansException {

        return null;
    }
        
    // 获取一个提前暴露的对象，用于解决循环依赖
    default Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
        return bean;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般我们在探究生命周期的时候都不会考虑这种后置处理器的执行&lt;/p&gt;

&lt;p&gt;在了解了上面的概念后，我们再来看看这张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/wx_cc347be696/blogImage/raw/master/image-20200707094637369.png&quot; alt=&quot;image-20200707094637369&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至少现在这张图上缺少了实例化前后后置处理器的执行流程，对吧？&lt;/p&gt;
&lt;p&gt;再补充上这一点之后，我们再来看看，属性注入后紧接着已经是初始化的阶段，在初始化阶段开始前应该要调用&lt;code&gt;BeanPostProcessor&lt;/code&gt;的预初始化方法（&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;），然后调用自定义的初始化方法，最后调用&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;，这是没有问题，但是为什么要在初始前还要调用Aware接口的方法，如果你看了源码的话可能会说，源码就是这么写的，别人就是这么设计的，但是为什么要这么设计呢？&lt;strong&gt;我们看源码到一定阶段后不应该仅仅停留在是什么的阶段，而应该多思考为什么，这样能帮助你更好的了解这个框架&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么为什么Aware接口非要在初始化前执行呢？&lt;/p&gt;
&lt;p&gt;这样做的目的是因为，初始化可能会依赖Aware接口提供的状态，例如下面这个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class A implements InitializingBean, ApplicationContextAware {

    ApplicationContext applicationContext;

    @Override
    public void afterPropertiesSet() throws Exception {
        // 初始化方法需要用到ApplicationContextAware提供的ApplicationContext
        System.out.println(applicationContext);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种情况下Aware接口当然要在初始化前执行啦！&lt;/p&gt;
&lt;p&gt;另外，在讨论Bean的初始化的时候经常会碰到下面这个问题，&lt;code&gt;@PostConstruct&lt;/code&gt;,&lt;code&gt;afterPropertiesSet&lt;/code&gt;跟XML中配置的&lt;code&gt;init-method&lt;/code&gt;方法的执行顺序。&lt;/p&gt;
&lt;p&gt;请注意，&lt;code&gt;@PostConstruct&lt;/code&gt;实际上是在&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;方法中处理的，严格来说它不属于初始化阶段调用的方法，所以这个方法是最先调用的&lt;/p&gt;
&lt;p&gt;其次我们思考下是调用&lt;code&gt;afterPropertiesSet&lt;/code&gt;方法的开销大还是执行配置文件中指定名称的初始化方法开销大呢？我们不妨用伪代码演示下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// afterPropertiesSet，强转后直接调用
((InitializingBean) bean).afterPropertiesSet()
    
// 反射调用init-method方法
// 第一步：找到这个方法
Method method = class.getMethod(methodName)
// 第二步：反射调用这个方法
method.invoke(bean,null)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相比而言肯定是第一种的效率高于第二种，一个只是做了一次方法调用，而另外一个要调用两次反射。&lt;/p&gt;
&lt;p&gt;因此，&lt;code&gt;afterPropertiesSet&lt;/code&gt;的优先级高于XML配置的方式&lt;/p&gt;
&lt;p&gt;所以，这三个方法的执行顺序为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;@PostConstruct&lt;/code&gt;注解标注的方法&lt;/li&gt;
&lt;li&gt;实现了&lt;code&gt;InitializingBean&lt;/code&gt;接口后复写的&lt;code&gt;afterPropertiesSet&lt;/code&gt;方法&lt;/li&gt;
&lt;li&gt;XML中自定义的初始化方法&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在完成初始化，没什么好说的了，最后调用一下&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;，整个Bean的生命周期到此结束&lt;/p&gt;

&lt;p&gt;本文的主要目的是想要帮助大家更好的理解整个Bean的生命周期，不过理解是建立在有一定知识存储的基础上的&lt;/p&gt;
&lt;p&gt;你至少要对Bean的后置处理器跟Bean创建有一个大概的理解，那么通过本文你能理清一些细节方面的东西&lt;/p&gt;
&lt;p&gt;例如，为什么Aware接口执行在初始化阶段之前？为什么初始化的三个方法会按&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@PostConstruct&lt;/code&gt;，&lt;code&gt;afterPropertiesSet&lt;/code&gt;，XML中定义的初始化方法这个顺序执行。&lt;/p&gt;
&lt;p&gt;本文也将是我整个Spring关于&lt;code&gt;IOC&lt;/code&gt;跟&lt;code&gt;AOP&lt;/code&gt;的最后一篇文字，在这之后我打算做一个Spring事务专题，预计6到7篇文章，事务结束后关于整个Spring源码的学习也就结束啦！本来预期要一年才能完成，不过因为最近离职了，所以打算全职在家写完这个系列！&lt;/p&gt;
&lt;p&gt;如果本文对你由帮助的话，记得点个赞吧！也欢迎关注我的公众号，微信搜索：程序员DMZ，或者扫描下方二维码，跟着我一起认认真真学Java,踏踏实实做一个coder。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3hfY2MzNDdiZTY5Ni9ibG9nSW1hZ2UvcmF3L21hc3Rlci8lRTUlODUlQUMlRTQlQkMlOTclRTUlOEYlQjcuanBn?x-oss-process=image/format,png&quot; alt=&quot;公众号&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我叫DMZ，一个在学习路上匍匐前行的小菜鸟！&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jul 2020 00:07:00 +0000</pubDate>
<dc:creator>程序员DMZ</dc:creator>
<og:description>前言 当你准备去复习Spring中Bean的生命周期的时候，这个时候你开始上网找资料，很大概率会看到下面这张图： 先不论这张图上是否全面，但是就说这张图吧，你是不是背了又忘，忘了又背？ 究其原因在于，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daimzh/p/13303528.html</dc:identifier>
</item>
<item>
<title>MVC + EFCore 项目实战 - 数仓管理系统5 – 菜单配置及里程碑划分 - 编程小纸条</title>
<link>http://www.cnblogs.com/miro/p/13303527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miro/p/13303527.html</guid>
<description>&lt;p&gt;&lt;span&gt;上次课程我们完成了需求的梳理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们根据梳理的需求把菜单配好，另外我们把项目里程碑也配置在系统中，开发和管理都在系统中，形成无文档化管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200715080610584-547479663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;




&lt;p&gt;&lt;span&gt;根据我们的归纳图，我们先将菜单配置好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们遵循敏捷开发的原则，近期要开发的功能列的详细点，远期要开发的先不展开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200715080253102-2103992490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们要开发的第一个功能是 数据仓库管理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将这部分需求回顾下，菜单对应功能是：&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;1、数据源&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;管理数据源。主要功能是配置一个连接字符串，根据此连接字符串可以读取相应的数据库，即我们的数据仓库。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;2、数据表预览&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;根据上一条，选择相应的数据源，我们可以显示该数据源下所有的 表/视图，点击 表/视图 后可以查询数据。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;3、SQL模型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;SQL模型是根据已有表产生新的表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;连接完数据源后，可通过SQL将多张表关联成一张大表，并进行其他的数据处理（如字段重命名、新建计算字段、调整字段顺序等操作），建立数据模型可以弥补本身数据仓库中表的局限性。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;4、数据值映射&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有些值看起来不直观。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如数据库表中1代表男性，2代表女性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以通过配置将数字 1、2分别映射成性别的值 男性、女性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;另外其他几个一级菜单做个简单说明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;驾驶舱&lt;/strong&gt;：放置一些常用功能的入口，显示一些 常用/重要 信息，管理员可以从这个界面上完成大部分工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据采集管理&lt;/strong&gt;：提供用户录入数据功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据字典管理&lt;/strong&gt;：提供数据字典导出功能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;系统管理&lt;/strong&gt;：用户，权限等的配置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;开发路线图&lt;/strong&gt;：放一些开发里程碑，随着开发进度动态调整，可概要性查看开发进度，本次将会完成初始版。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;用户手册&lt;/strong&gt;：在线操作手册。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;菜单基本上是通过 ul、li标签及其嵌套形成的，包括两类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、单层级菜单，如驾驶舱。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200715080253340-583718971.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、多级嵌套菜单，在li里面再嵌套ul, 如数据采集管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200715080253717-1886175405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们暂时只用到了两层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然, 如果要用多层的话只要一直嵌套下去就可以。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，如果需要根据数据库中配置动态生成菜单结构的话，可以参考我之前的文章， MVC5+EF6 入门完整教程13 -- 动态生成多级菜单 。&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;我们紧接着来完成开发路线图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将整个开发阶段分为5个里程碑：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、数据仓库管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、数据采集管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、数据字典管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、系统管理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、检查与第一轮迭代，用户手册补充、上线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们用不同颜色来标注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;蓝色 -- 计划，红色 -- 进行中，绿色 -- 已完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200715080254071-987034571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来完成上图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新建一个专门放文档相关的DocsController&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200715080254469-1904566419.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;新建对应的View, 以项目启动部分为例：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200715080254893-1273623223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中 ts1是我们定义的天数，可以计算已经过去的天数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/101211/202007/101211-20200715080255191-2103283694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;我们完成了项目的开发计划，配置好了菜单，并划分出了里程碑节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后面每一次课程结束都会维护一次里程碑，如调整日期、添加更多的功能描述、记录一些问题等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们遵循敏捷开发的原则，认为一开始不能把事情做对。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过快速的迭代来获取更多的细节信息，调整我们的开发计划。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;欢迎大家参与交流，祝大家学习进步 ：）&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Jul 2020 00:03:00 +0000</pubDate>
<dc:creator>编程小纸条</dc:creator>
<og:description>上次课程我们完成了需求的梳理。 我们根据梳理的需求把菜单配好，另外我们把项目里程碑也配置在系统中，开发和管理都在系统中，形成无文档化管理。 一、菜单配置 根据我们的归纳图，我们先将菜单配置好。 我们遵</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/miro/p/13303527.html</dc:identifier>
</item>
<item>
<title>ajax配合art-template模板引擎的使用 - CR7Ronaldo</title>
<link>http://www.cnblogs.com/hcyesdo/p/13303517.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hcyesdo/p/13303517.html</guid>
<description>&lt;p&gt;最近才接触js的模板引擎听说相比以前使用的js foreach加载后台返回的json数据简便很多而且效率方面也很不错。今天自己玩了一下&lt;/p&gt;
&lt;p&gt;后台使用的是.net mvc，数据库脚本就不提供了，返回的JsonResult，将数据存放在data中，前台通过ajax配合模板引擎进行一个调用然后以表格的形式显示数据。&lt;/p&gt;
&lt;p&gt;前台html代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;a href=&quot;#&quot; onclick=&quot;GetData()&quot;&amp;gt;获取数据&amp;lt;/a&amp;gt;
    &amp;lt;table class=&quot;table&quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;姓名&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;年龄&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;说明&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tbody id=&quot;tb&quot;&amp;gt;
            
        &amp;lt;/tbody&amp;gt;
    &amp;lt;/table&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;js代码：当然首先你得先导入art-template.js 下载地址：&lt;a href=&quot;http://aui.github.io/art-template/&quot; target=&quot;_blank&quot;&gt;http://aui.github.io/art-template/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;重点来说说这里：&lt;/p&gt;
&lt;p&gt;首先第一步：加载art-template.js的文件&lt;/p&gt;
&lt;p&gt;第二步：定义模板引擎并在里面进行数据的加载吧（个人理解），在网上也找了一下资料，说script type的值不能是text/script，不然会造成无法解析。也就是说除开text/script应该都可以，这里我用的是text/template（原谅我不去度娘）。&lt;/p&gt;
&lt;p&gt;第三步：就是处理请求回来的数据怎么显示了，先来看看ajax请求成功后我直接将data存放在template作为第二个参数，第一个参数对应定义模板引擎的id通过最后var去接收。完了以后就是在模板引擎中进行渲染，这里通过each data，这是一种标准语法吧，就好比之前通过模板字符串拼接的一个升级版，当然可能好处更多。data就是后台返回回来的json数据，&lt;/p&gt;
&lt;p&gt;通过{{$(value)}}的方式去拿到对应的数据，这样看来比以前foreach循环然后拼接字符串真的好太多，后期维护也比较好。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;~/resources/art-template.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script type=&quot;text/template&quot; id=&quot;tbdata&quot;&amp;gt;&lt;span&gt;
    {{each data}}
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;{{$value.Name}}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;{{$value.Age}}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;{{$value.Desc}}&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    {{/each}}
&amp;lt;/script&amp;gt;
 &amp;lt;script&amp;gt;
        function&lt;span&gt; GetData() {
            $.ajax({
                type: &quot;post&quot;&lt;span&gt;,
                url: &quot;/Test/Index&quot;&lt;span&gt;,
                data: {},
                success: function&lt;span&gt; (data) {
                    var result = template('tbdata'&lt;span&gt;, data);
                    $(&quot;#tb&quot;&lt;span&gt;).html(result);
                }
            });
        }
    &amp;lt;/script&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;后台代码：这里通过ef从数据库加载数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; TestController : Controller
    {
        testDBEntities db=new&lt;span&gt; testDBEntities();
        // GET: Test
&lt;span&gt;        [HttpPost]
        public&lt;span&gt; JsonResult Index()
        {
            var datas =&lt;span&gt; db.Tests.ToList();
            return Json(new { data =&lt;span&gt; datas });
        }
        
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的显示效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998632/202007/1998632-20200714225555712-1173136477.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一次玩模板引擎，希望以后会有更多的认识。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jul 2020 23:53:00 +0000</pubDate>
<dc:creator>CR7Ronaldo</dc:creator>
<og:description>最近才接触js的模板引擎听说相比以前使用的js foreach加载后台返回的json数据简便很多而且效率方面也很不错。今天自己玩了一下 后台使用的是.net mvc，数据库脚本就不提供了，返回的Jso</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hcyesdo/p/13303517.html</dc:identifier>
</item>
<item>
<title>5分钟带你快速入门和了解 OAM Kubernetes - KAnts</title>
<link>http://www.cnblogs.com/ants/p/13300407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ants/p/13300407.html</guid>
<description>&lt;p&gt;OAM 的全称为开放应用模型（Open Application Model），由阿里巴巴宣布联合微软共同推出。&lt;/p&gt;
&lt;h2 id=&quot;oam-解决了什么问题？&quot;&gt;OAM 解决了什么问题？&lt;/h2&gt;
&lt;p&gt;OAM 本质是为了解耦K8S中现存的形形色色的资源，让每个角色的关注点更为集中和专注。&lt;/p&gt;
&lt;p&gt;举个例子，我们在生产环境中部署了Deployment资源，其中容器的image，健康检查，资源请求开发人员一般会了然于胸，但涉及到Pod副本数、PV、PVC、网络带宽、网络策略、对外负载配置等，一般的开发人员根本无从下手。&lt;/p&gt;
&lt;p&gt;为什么会无从下手？原因很简单，正常的开发人员根本不会有这些内容的权限，而且绝大部分开发人员没有公司资源的监控数据，无法对应用所使用的资源进行平衡。最简单的情况，如果开放了CPU、内存、共享存储大小、网络带宽的上限配置，我相信很多人一上来就设置为8C，16GB，100GB，100MB这样奢侈配置，实际的集群资源能支持几个这样的应用呢？&lt;/p&gt;
&lt;p&gt;所以这类的事情更适合应用运维人员去做，当然应用运维的人员也需要一定的水准。应用运维人员可以根据监控和告警按需的对CPU、内存、共享存储、网络等资源进行弹性伸缩，甚至可以从监控数据中发现一定的规律配置自动的程序来进行自动扩缩容，例如HPA、CronHPA。&lt;/p&gt;
&lt;h2 id=&quot;oam-是如何解决这些问题的？&quot;&gt;OAM 是如何解决这些问题的？&lt;/h2&gt;
&lt;p&gt;在 OAM 体系中大致分了三个角色，分别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础设施运维人员&lt;br/&gt;负责开发、安装和维护各种 Kubernetes 级别的功能。具体工作包括但不限于维护大规模的 K8s 集群、实现控制器/Operator，以及开发各种 K8s 插件。在公司内部，我们通常被称为“平台团队（Platform Builder）&lt;/li&gt;
&lt;li&gt;业务研发人员&lt;br/&gt;以代码形式传递业务价值。大多数业务研发都对基础设施或 K8s 不甚了解，他们与 PaaS 和 CI 流水线交互以管理其应用程序。业务研发人员的生产效率对公司而言价值巨大。&lt;/li&gt;
&lt;li&gt;应用运维人员&lt;br/&gt;为业务研发人员提供有关集群容量、稳定性和性能的专业知识，帮助业务研发人员大规模配置、部署和运行应用程序（例如，更新、扩展、恢复）。请注意，尽管应用运维人员对 K8s 的 API 和功能具有一定了解，但他们并不直接在 K8s 上工作。在大多数情况下，他们利用 PaaS 系统为业务研发人员提供基础 K8s 功能。在这种情况下，许多应用运维人员实际上也是 PaaS 工程人员。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;各个角色之间的服务关系为：基础设施运维人员 &amp;lt; 应用运维人员 &amp;lt; 业务研发人员。&lt;/p&gt;
&lt;p&gt;与角色对应的也同样的有三个核心内容，分别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Component（组件）&lt;br/&gt;由业务开发人员输出，它可能包含微服务集合、数据库和云负载均衡器。&lt;/li&gt;
&lt;li&gt;Trait（运维特征）&lt;br/&gt;由应用运维人员管理，例如：弹性伸缩、日志、监控、告警和 Ingress 等功能。&lt;/li&gt;
&lt;li&gt;Application Configuration（应用配置）&lt;br/&gt;组合Component和Trait等内容描述应用最终能力的配置文件。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;OAM 从资源角度上就隔离了不同角色所关心的内容，而不再将这些内容混杂在一起。&lt;br/&gt;整体示意图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/384997/202007/384997-20200714175046553-140184622.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;更详细的内容可以阅读：《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&amp;amp;mid=2650740549&amp;amp;idx=1&amp;amp;sn=da4000870f6d3008ae3091366ebf61da&amp;amp;scene=21#wechat_redirect&quot;&gt;深度解读！阿里统一应用管理架构升级的教训与实践&lt;/a&gt;》&lt;/p&gt;

&lt;p&gt;由于OAM是一个新的概念，所以社区的文档目前比较混乱，下面列出还在活动并在维护的几个仓库。&lt;/p&gt;
&lt;h2 id=&quot;oam标准规范&quot;&gt;OAM标准规范&lt;/h2&gt;
&lt;p&gt;截至目前的版本&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.0.0-alpha1&lt;/li&gt;
&lt;li&gt;1.0.0-alpha2&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/oam-dev/spec&quot;&gt;https://github.com/oam-dev/spec&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于crossplane的oam-核心运行时实现&quot;&gt;基于Crossplane的OAM 核心运行时实现&lt;/h2&gt;
&lt;p&gt;支持的OAM规范：1.0.0-alpha2&lt;br/&gt;&lt;a href=&quot;https://github.com/crossplane/oam-kubernetes-runtime&quot;&gt;https://github.com/crossplane/oam-kubernetes-runtime&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;oam工作负载、特征、范围集合&quot;&gt;OAM工作负载、特征、范围集合&lt;/h2&gt;
&lt;p&gt;可以理解为非OAM Runtime必须实现的OAM插件和扩展&lt;br/&gt;&lt;a href=&quot;https://github.com/oam-dev/catalog&quot;&gt;https://github.com/oam-dev/catalog&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该库提供了以下内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Workloads
&lt;ul&gt;&lt;li&gt;Containerized&lt;/li&gt;
&lt;li&gt;StatefulSet&lt;/li&gt;
&lt;li&gt;Deployment&lt;/li&gt;
&lt;li&gt;AdvancedStatefulSet&lt;/li&gt;
&lt;li&gt;CloneSet&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Traits
&lt;ul&gt;&lt;li&gt;ManualScaler（手动伸缩器）&lt;/li&gt;
&lt;li&gt;trait-injector（资源注入器）&lt;/li&gt;
&lt;li&gt;ServiceExpose（服务导出）&lt;/li&gt;
&lt;li&gt;IngressTrait（Ingress）&lt;/li&gt;
&lt;li&gt;HPATrait（自动伸缩）&lt;/li&gt;
&lt;li&gt;CronHPATrait（基于Cron表达式的定时伸缩）&lt;/li&gt;
&lt;li&gt;MetricHPATrait（基于指标的自动伸缩）&lt;/li&gt;
&lt;li&gt;SimpleRolloutTrait（简单的滚动更新）&lt;/li&gt;
&lt;li&gt;ServiceMonitor（服务监控器，还在PR中）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Scopes
&lt;ul&gt;&lt;li&gt;HealthScope&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;不维护或过时的仓库&quot;&gt;不维护或过时的仓库&lt;/h2&gt;
&lt;p&gt;这边列出一些容易被误导的仓库，大家遇到了可以跳过查阅，避免绕弯路。&lt;/p&gt;
&lt;h3 id=&quot;rudr&quot;&gt;Rudr&lt;/h3&gt;
&lt;p&gt;实现了 OAM 规范 1.0.0-alpha1&lt;br/&gt;&lt;a href=&quot;https://github.com/oam-dev/rudr&quot;&gt;https://github.com/oam-dev/rudr&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;addon-oam-kubernetes-local&quot;&gt;addon-oam-kubernetes-local&lt;/h3&gt;
&lt;p&gt;被 oam-kubernetes-runtime 替代&lt;br/&gt;&lt;a href=&quot;https://github.com/crossplane/addon-oam-kubernetes-local&quot;&gt;https://github.com/crossplane/addon-oam-kubernetes-local&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;先决条件&quot;&gt;先决条件&lt;/h2&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-console&quot;&gt;helm repo add oam https://github.com/oam-dev/crossplane-oam-sample/tree/master/archives/
kubectl create namespace oam-system
helm install crossplane --namespace oam-system oam/crossplane-oam
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;尝试一个应用配置样本&quot;&gt;尝试一个应用配置样本&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;# sample_application_config.yaml

apiVersion: core.oam.dev/v1alpha2
kind: Component
metadata:
  name: example-component
spec:
  workload:
    apiVersion: core.oam.dev/v1alpha2
    kind: ContainerizedWorkload
    spec:
      containers:
        - name: my-nginx
          image: nginx:1.16.1
          resources:
            limits:
              memory: &quot;200Mi&quot;
          ports:
            - containerPort: 4848
              protocol: &quot;TCP&quot;
          env:
            - name: WORDPRESS_DB_PASSWORD
              value: &quot;&quot;
  parameters:
    - name: instance-name
      required: true
      fieldPaths:
        - metadata.name
    - name: image
      fieldPaths:
        - spec.containers[0].image
---
apiVersion: core.oam.dev/v1alpha2
kind: ApplicationConfiguration
metadata:
  name: example-appconfig
spec:
  components:
    - componentName: example-component
      parameterValues:
        - name: instance-name
          value: example-appconfig-workload
        - name: image
          value: nginx:latest
      traits:
        - trait:
            apiVersion: core.oam.dev/v1alpha2
            kind: ManualScalerTrait
            metadata:
              name:  example-appconfig-trait
            spec:
              replicaCount: 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-console&quot;&gt;$ kubectl apply -f samples/sample_application_config.yaml
component.core.oam.dev/example-component created
applicationconfiguration.core.oam.dev/example-appconfig created
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-console&quot;&gt;$ kubectl get manualscalertraits.core.oam.dev
NAME                      AGE
example-appconfig-trait   4s
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-console&quot;&gt;$ kubectl get containerizedworkloads.core.oam.dev
NAME                         AGE
example-appconfig-workload   58s
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-console&quot;&gt;$ kubectl get deploy
NAME                                    READY   UP-TO-DATE   AVAILABLE   AGE
example-appconfig-workload-deployment   3/3     3            3           114s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，通过Component和Trait、ApplicationConfiguration的抽象，开发人员和运维人员所关心的内容不再混合在一起，变得更为清晰。&lt;/p&gt;

&lt;p&gt;受限于篇幅的原因，本文简单介绍了 OAM 概念并实践了一个简单的基于 OAM 概念的应用程序样本，还没有完全发挥 OAM 的能力。&lt;br/&gt;下一节将会详解如何一步一步使用kubebuilder为OAM添加一个基于Cron表达式定时伸缩的Train。&lt;/p&gt;
&lt;p&gt;小伙伴们可以前往：&lt;a href=&quot;https://github.com/oam-dev/catalog/pull/44&quot;&gt;https://github.com/oam-dev/catalog/pull/44&lt;/a&gt; 查看该 Train 的 PR 情况。&lt;br/&gt;CronHPATrain 目前已被 oam-dev catalog 接收并合并。&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jul 2020 23:50:00 +0000</pubDate>
<dc:creator>KAnts</dc:creator>
<og:description>什么是 OAM？ OAM 的全称为开放应用模型（Open Application Model），由阿里巴巴宣布联合微软共同推出。 OAM 解决了什么问题？ OAM 本质是为了解耦K8S中现存的形形色色</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ants/p/13300407.html</dc:identifier>
</item>
<item>
<title>Docker 基础知识 - 使用卷(volume)管理应用程序数据 - 技术译民</title>
<link>http://www.cnblogs.com/ittranslator/p/13303417.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ittranslator/p/13303417.html</guid>
<description>&lt;p&gt;卷（volumes）是 Docker 容器生产和使用持久化数据的首选机制。&lt;a href=&quot;https://docs.docker.com/storage/bind-mounts/&quot;&gt;绑定挂载（bind mounts）&lt;/a&gt;依赖于主机的目录结构，卷（volumes）完全由 Docker 管理。卷与绑定挂载相比有几个优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;卷比绑定挂载更容易备份或迁移。&lt;/li&gt;
&lt;li&gt;您可以使用 Docker CLI 命令或 Docker API 来管理卷。&lt;/li&gt;
&lt;li&gt;卷可以在 Linux 和 Windows 容器上工作。&lt;/li&gt;
&lt;li&gt;卷可以更安全地在多个容器之间共享。&lt;/li&gt;
&lt;li&gt;卷驱动程序允许您在远程主机或云提供商上存储卷、加密卷的内容或添加其他功能。&lt;/li&gt;
&lt;li&gt;新卷的内容可以由容器预先填充。（New volumes can have their content pre-populated by a container.）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，与将数据持久化到容器的可写层相比，卷通常是更好的选择，因为卷不会增加使用它的容器的大小，而且卷的内容存在于给定容器的生命周期之外。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2074831/202007/2074831-20200715011755142-1123249985.png&quot; alt=&quot;docker-types-of-mounts-volume&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果容器生成非持久性状态数据，请考虑使用 &lt;a href=&quot;https://docs.docker.com/storage/tmpfs/&quot;&gt;tmpfs 挂载（tmpfs mount）&lt;/a&gt;以避免将数据永久存储在任何位置，并通过避免写入容器的可写层来提高容器的性能。&lt;/p&gt;
&lt;p&gt;卷使用 &lt;code&gt;rprivate&lt;/code&gt; 绑定传播，并且绑定传播对于卷是不可配置的。&lt;/p&gt;
&lt;h2 id=&quot;选择--v-或---mount-标记&quot;&gt;选择 -v 或 --mount 标记&lt;/h2&gt;
&lt;p&gt;最初，&lt;code&gt;-v&lt;/code&gt; 或 &lt;code&gt;--volume&lt;/code&gt; 标记用于独立容器，&lt;code&gt;--mount&lt;/code&gt; 标记用于集群服务。但是，从 Docker 17.06 开始，您也可以将 &lt;code&gt;--mount&lt;/code&gt; 用于独立容器。通常，&lt;code&gt;--mount&lt;/code&gt; 标记表达更加明确和冗长。最大的区别是 &lt;code&gt;-v&lt;/code&gt; 语法将所有选项组合在一个字段中，而 &lt;code&gt;--mount&lt;/code&gt; 语法将选项分离。下面是每个标记的语法比较。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;新用户推荐使用 &lt;code&gt;--mount&lt;/code&gt; 语法，它比 &lt;code&gt;--volume&lt;/code&gt; 语法更简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果需要指定卷驱动程序选项，则必须使用 &lt;code&gt;--mount&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 或 &lt;code&gt;--volume&lt;/code&gt;: 由三个字段组成，以冒号(:)分隔。字段必须按照正确的顺序排列，且每个字段的含义不够直观明显。
&lt;ul&gt;&lt;li&gt;对于命名卷，第一个字段是卷的名称，在给定的主机上是惟一的。对于匿名卷，省略第一个字段。&lt;/li&gt;
&lt;li&gt;第二个字段是容器中文件或目录挂载的路径。&lt;/li&gt;
&lt;li&gt;第三个字段是可选的，是一个逗号分隔的选项列表，比如 &lt;code&gt;ro&lt;/code&gt;。这些选项会在本文下面讨论。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--mount&lt;/code&gt;：由多个键-值对组成，以逗号分隔，每个键-值对由一个 &lt;code&gt;&amp;lt;key&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt; 元组组成。&lt;code&gt;--mount&lt;/code&gt; 语法比 &lt;code&gt;-v&lt;/code&gt; 或 &lt;code&gt;--volume&lt;/code&gt; 更冗长，但是键的顺序并不重要，标记的值也更容易理解。
&lt;ul&gt;&lt;li&gt;挂载的类型（&lt;code&gt;type&lt;/code&gt;），可以是 &lt;code&gt;bind&lt;/code&gt;、&lt;code&gt;volume&lt;/code&gt; 或者 &lt;code&gt;tmpfs&lt;/code&gt;。本主题讨论卷（volume），因此类型（&lt;code&gt;type&lt;/code&gt;）始终为卷（&lt;code&gt;volume&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;挂载的源（&lt;code&gt;source&lt;/code&gt;），对于命名卷，这是卷的名称。对于匿名卷，此字段被省略。可以用 &lt;code&gt;source&lt;/code&gt; 或者 &lt;code&gt;src&lt;/code&gt; 来指定。&lt;/li&gt;
&lt;li&gt;目标（&lt;code&gt;destination&lt;/code&gt;），将容器中文件或目录挂载的路径作为其值。可以用 &lt;code&gt;destination&lt;/code&gt;、&lt;code&gt;dst&lt;/code&gt; 或者 &lt;code&gt;target&lt;/code&gt; 来指定。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readonly&lt;/code&gt; 选项（如果存在），则会将绑定挂载以&lt;a href=&quot;https://www.cnblogs.com/ittranslator/p/13303417.html#use-a-read-only-volume&quot;&gt;只读形式挂载到容器&lt;/a&gt;中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;volume-opt&lt;/code&gt; 选项，可以被指定多次，接受由选项名及其值组成的键-值对。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;29&quot;&gt;
&lt;p&gt;&lt;strong&gt;从外部 CSV 解析器转义值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果卷驱动程序接受以逗号分隔的列表作为选项，则必须从外部 CSV 解析器转义该值。要转义 &lt;code&gt;volume-opt&lt;/code&gt;, 请使用双引号(&quot;)将其括起来，并使用单引号(')将整个挂载参数括起来。&lt;/p&gt;
&lt;p&gt;例如，本地(&lt;code&gt;local&lt;/code&gt;)驱动程序在参数 &lt;code&gt;o&lt;/code&gt; 中接受以逗号分隔的列表作为挂载选项。下面这个例子展示了转义列表的正确写法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker service create \
    --mount 'type=volume,src=&amp;lt;VOLUME-NAME&amp;gt;,dst=&amp;lt;CONTAINER-PATH&amp;gt;,volume-driver=local,volume-opt=type=nfs,volume-opt=device=&amp;lt;nfs-server&amp;gt;:&amp;lt;nfs-path&amp;gt;,&quot;volume-opt=o=addr=&amp;lt;nfs-address&amp;gt;,vers=4,soft,timeo=180,bg,tcp,rw&quot;'
    --name myservice \
    &amp;lt;IMAGE&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;下面的示例尽可能同时展示 &lt;code&gt;--mount&lt;/code&gt; 和 &lt;code&gt;-v&lt;/code&gt; 两种语法，并且先展示 &lt;code&gt;--mount&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;-v-和---mount-行为之间的差异&quot;&gt;&lt;code&gt;-v&lt;/code&gt; 和 &lt;code&gt;--mount&lt;/code&gt; 行为之间的差异&lt;/h3&gt;
&lt;p&gt;与绑定挂载不同，卷的所有选项对于 &lt;code&gt;--mount&lt;/code&gt; 和 &lt;code&gt;-v&lt;/code&gt; 标记都可用。&lt;/p&gt;
&lt;p&gt;当卷与服务一起使用时，只有 &lt;code&gt;--mount&lt;/code&gt; 支持。&lt;/p&gt;
&lt;h2 id=&quot;创建和管理卷&quot;&gt;创建和管理卷&lt;/h2&gt;
&lt;p&gt;与绑定挂载不同，您可以在任何容器的作用域之外创建和管理卷。&lt;/p&gt;
&lt;p&gt;创建一个卷：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker volume create my-vol
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;卷列表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker volume ls
# 输出结果：
DRIVER              VOLUME NAME
local               my-vol
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检查卷：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker volume inspect my-vol
# 输出结果：
[
    {
        &quot;CreatedAt&quot;: &quot;2020-07-04T07:06:47Z&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Labels&quot;: {},
        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,
        &quot;Name&quot;: &quot;my-vol&quot;,
        &quot;Options&quot;: {},
        &quot;Scope&quot;: &quot;local&quot;
    }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除卷：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker volume rm my-vol
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;启动一个带有卷的容器&quot;&gt;启动一个带有卷的容器&lt;/h2&gt;
&lt;p&gt;如果您启动一个有尚不存在的卷的容器，Docker 将为您创建这个卷。下面的示例将卷 &lt;code&gt;myvol2&lt;/code&gt; 挂载到容器中的 &lt;code&gt;/app/&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;下面的 &lt;code&gt;--mount&lt;/code&gt; 和 &lt;code&gt;-v&lt;/code&gt; 示例会产生相同的结果。除非在运行第一个示例之后删除了 &lt;code&gt;devtest&lt;/code&gt; 容器和 &lt;code&gt;myvol2&lt;/code&gt; 卷，否则不能同时运行它们。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--mount&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d \
  --name devtest \
  --mount source=myvol2,target=/app \
  nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d \
  --name devtest \
  -v myvol2:/app \
  nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;docker inspect devtest&lt;/code&gt; 验证卷的创建和挂载是否正确。查看 &lt;code&gt;Mounts&lt;/code&gt; 部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;volume&quot;,
        &quot;Name&quot;: &quot;myvol2&quot;,
        &quot;Source&quot;: &quot;/var/lib/docker/volumes/myvol2/_data&quot;,
        &quot;Destination&quot;: &quot;/app&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mode&quot;: &quot;&quot;,
        &quot;RW&quot;: true,
        &quot;Propagation&quot;: &quot;&quot;
    }
],
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这表明挂载是一个卷，它显示了正确的源和目标，并且挂载是可读写的。&lt;/p&gt;
&lt;p&gt;停止容器并删除卷。注意删除卷是一个单独的步骤。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker container stop devtest

$ docker container rm devtest

$ docker volume rm myvol2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动带有卷的服务&quot;&gt;启动带有卷的服务&lt;/h3&gt;
&lt;p&gt;启动服务并定义卷时，每个服务容器都使用自己的本地卷。 如果使用本地（&lt;code&gt;local&lt;/code&gt;）卷驱动程序，则没有任何容器可以共享此数据，但某些卷驱动程序确实支持共享存储。Docker for AWS 和 Docker for Azure 都支持使用 Cloudstor 插件的持久存储。&lt;/p&gt;
&lt;p&gt;下面的示例使用四个副本启动 &lt;code&gt;nginx&lt;/code&gt; 服务，每个副本使用一个名为 &lt;code&gt;myvol2&lt;/code&gt; 的本地卷。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker service create -d \
  --replicas=4 \
  --name devtest-service \
  --mount source=myvol2,target=/app \
  nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;docker service ps devtest-service&lt;/code&gt; 验证服务是否正在运行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker service ps devtest-service

ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
4d7oz1j85wwn        devtest-service.1   nginx:latest        moby                Running             Running 14 seconds ago
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除服务，该服务将停止其所有任务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker service rm devtest-service
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除服务不会删除该服务创建的任何卷。删除卷是一个单独的步骤。&lt;/p&gt;
&lt;h4 id=&quot;服务的语法差异&quot;&gt;服务的语法差异&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;docker service create&lt;/code&gt; 命令不支持 &lt;code&gt;-v&lt;/code&gt; 或 &lt;code&gt;--volume&lt;/code&gt; 标记，在将卷挂载到服务的容器中时，必须使用 &lt;code&gt;--mount&lt;/code&gt; 标记。&lt;/p&gt;
&lt;h3 id=&quot;使用容器填充卷&quot;&gt;使用容器填充卷&lt;/h3&gt;
&lt;p&gt;如果您启动了一个创建新卷的容器，如上所述，并且该容器在要挂载的目录(例如上面的 &lt;code&gt;/app/&lt;/code&gt;)中有文件或目录，那么该目录的内容将复制到新卷中。然后容器挂载并使用该卷，使用该卷的其他容器也可以访问预填充的内容。&lt;/p&gt;
&lt;p&gt;为了说明这一点，这个例子启动了一个 &lt;code&gt;nginx&lt;/code&gt; 容器，并用容器的 &lt;code&gt;/usr/share/nginx/html&lt;/code&gt; 目录中的内容填充新的卷 &lt;code&gt;nginx-vol&lt;/code&gt;，这个目录是 Nginx 存储默认的 HTML 内容的地方。&lt;/p&gt;
&lt;p&gt;下面的 &lt;code&gt;--mount&lt;/code&gt; 和 &lt;code&gt;-v&lt;/code&gt; 示例具有相同的最终结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--mount&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d \
  --name=nginxtest \
  --mount source=nginx-vol,destination=/usr/share/nginx/html \
  nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d \
  --name=nginxtest \
  -v nginx-vol:/usr/share/nginx/html \
  nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行两个示例中的任何一个之后，运行以下命令来清理容器和卷。注意：删除卷是一个单独的步骤。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker container stop nginxtest

$ docker container rm nginxtest

$ docker volume rm nginx-vol
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用只读卷&quot;&gt;&lt;span id=&quot;use-a-read-only-volume&quot;&gt;使用只读卷&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;对于某些开发应用程序，容器需要写入绑定挂载，以便更改传播回 Docker 主机。在其他时候，容器只需要对数据进行读访问。记住，多个容器可以挂载相同的卷，并且可以对其中一些容器以读写方式挂载，而对其他容器以只读方式挂载。&lt;/p&gt;
&lt;p&gt;这个示例修改了上面的示例，但是通过在容器内的挂载点之后的选项列表（默认为空）中添加 &lt;code&gt;ro&lt;/code&gt;，将目录挂载为只读卷。当有多个选项时，使用逗号分隔它们。&lt;/p&gt;
&lt;p&gt;下面 &lt;code&gt;--mount&lt;/code&gt; 和 &lt;code&gt;-v&lt;/code&gt; 示例有相同的结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;--mount&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d \
  --name=nginxtest \
  --mount source=nginx-vol,destination=/usr/share/nginx/html,readonly \
  nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-v&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d \
  --name=nginxtest \
  -v nginx-vol:/usr/share/nginx/html:ro \
  nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;docker inspect nginxtest&lt;/code&gt; 验证是否正确创建了只读挂载。查看 &lt;code&gt;Mounts&lt;/code&gt; 部分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;&quot;Mounts&quot;: [
    {
        &quot;Type&quot;: &quot;volume&quot;,
        &quot;Name&quot;: &quot;nginx-vol&quot;,
        &quot;Source&quot;: &quot;/var/lib/docker/volumes/nginx-vol/_data&quot;,
        &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,
        &quot;Driver&quot;: &quot;local&quot;,
        &quot;Mode&quot;: &quot;&quot;,
        &quot;RW&quot;: false,
        &quot;Propagation&quot;: &quot;&quot;
    }
],
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;停止并删除容器，再删除卷。删除卷是一个单独的步骤。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker container stop nginxtest

$ docker container rm nginxtest

$ docker volume rm nginx-vol
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在机器之间共享数据&quot;&gt;在机器之间共享数据&lt;/h2&gt;
&lt;p&gt;在构建故障容错的应用程序时，您可能需要配置同一服务的多个副本，以访问相同的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2074831/202007/2074831-20200715012136113-1402102667.png&quot; alt=&quot;volumes-shared-storage&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在开发应用程序时，有几种方法可以实现这一点。一种方法是向您的应用程序添加逻辑，在云对象存储系统（如 Amazon S3）上存储文件。另一个方法是使用支持将文件写入外部存储系统（如 NFS 或 Amazon S3）的驱动程序来创建卷。&lt;/p&gt;
&lt;p&gt;卷驱动程序使您可以从应用程序逻辑中抽象底层存储系统。例如，如果您的服务使用带有 NFS 驱动程序的卷，那么您可以更新服务以使用其他的驱动程序（例如，将数据存储在云上），而无需更改应用程序逻辑。&lt;/p&gt;
&lt;h2 id=&quot;使用卷驱动程序&quot;&gt;使用卷驱动程序&lt;/h2&gt;
&lt;p&gt;当您使用 &lt;code&gt;docker volume create&lt;/code&gt; 创建卷时，或者当您启动使用尚未创建的卷的容器时，可以指定一个卷驱动程序。下面的示例使用 &lt;code&gt;vieux/sshfs&lt;/code&gt; 卷驱动程序，首先在创建独立卷时使用，然后在启动创建新卷的容器时使用。&lt;/p&gt;
&lt;h3 id=&quot;初始设置&quot;&gt;初始设置&lt;/h3&gt;
&lt;p&gt;这个示例假定您有两个节点，第一个节点是 Docker 主机，可以使用 SSH 连接到第二个节点。&lt;/p&gt;
&lt;p&gt;在 Docker 主机上，安装 &lt;code&gt;vieux/sshfs&lt;/code&gt; 插件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker plugin install --grant-all-permissions vieux/sshfs
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用卷驱动程序创建卷&quot;&gt;使用卷驱动程序创建卷&lt;/h3&gt;
&lt;p&gt;本例指定了一个 SSH 密码，但是如果两个主机配置了共享密钥，则可以省略该密码。每个卷驱动程序可能有零个或多个可配置选项，每个选项都使用 &lt;code&gt;-o&lt;/code&gt; 标记指定。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker volume create --driver vieux/sshfs \
  -o sshcmd=test@node2:/home/test \
  -o password=testpassword \
  sshvolume
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动使用卷驱动程序创建卷的容器&quot;&gt;启动使用卷驱动程序创建卷的容器&lt;/h3&gt;
&lt;p&gt;本例指定了一个 SSH 密码，但是如果两个主机配置了共享密钥，则可以省略该密码。每个卷驱动程序可能有零个或多个可配置选项。&lt;strong&gt;如果卷驱动程序要求您传递选项，则必须使用 &lt;code&gt;--mount&lt;/code&gt; 标记挂载卷，而不是使用 &lt;code&gt;-v&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -d \
  --name sshfs-container \
  --volume-driver vieux/sshfs \
  --mount src=sshvolume,target=/app,volume-opt=sshcmd=test@node2:/home/test,volume-opt=password=testpassword \
  nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建创建-nfs-卷的服务&quot;&gt;创建创建 NFS 卷的服务&lt;/h3&gt;
&lt;p&gt;此示例显示如何在创建服务时创建 NFS 卷。本例使用 &lt;code&gt;10.0.0.10&lt;/code&gt; 作为 NFS 服务器，使用 &lt;code&gt;/var/docker-nfs&lt;/code&gt; 作为 NFS 服务器上的出口目录。请注意，指定的卷驱动程序是 &lt;code&gt;local&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;nfsv3&quot;&gt;NFSV3&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker service create -d \
  --name nfs-service \
  --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,volume-opt=o=addr=10.0.0.10' \
  nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;nfsv4&quot;&gt;NFSV4&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;docker service create -d \
    --name nfs-service \
    --mount 'type=volume,source=nfsvolume,target=/app,volume-driver=local,volume-opt=type=nfs,volume-opt=device=:/var/docker-nfs,&quot;volume-opt=o=10.0.0.10,rw,nfsvers=4,async&quot;' \
    nginx:latest
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;备份、还原或迁移数据卷&quot;&gt;备份、还原或迁移数据卷&lt;/h2&gt;
&lt;p&gt;卷对于备份、还原和迁移非常有用。使用 &lt;code&gt;--volumes-from&lt;/code&gt; 标记创建一个挂载该卷的新容器。&lt;/p&gt;
&lt;h3 id=&quot;备份容器&quot;&gt;备份容器&lt;/h3&gt;
&lt;p&gt;例如，创建一个名为 &lt;code&gt;dbstore&lt;/code&gt; 的新容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -v /dbdata --name dbstore ubuntu /bin/bash
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在下一条命令中，我们：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动一个新容器并从 &lt;code&gt;dbstore&lt;/code&gt; 容器挂载卷&lt;/li&gt;
&lt;li&gt;挂载一个本地主机目录作为 &lt;code&gt;/backup&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;传递一个命令，将 &lt;code&gt;/dbdata&lt;/code&gt; 卷的内容压缩到目录 &lt;code&gt;/backup&lt;/code&gt; 中的 &lt;code&gt;backup.tar&lt;/code&gt; 文件。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run --rm --volumes-from dbstore -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当命令完成且容器停止时，我们留下了 &lt;code&gt;/dbdata&lt;/code&gt; 卷的一个备份。&lt;/p&gt;
&lt;h3 id=&quot;从备份中还原容器&quot;&gt;从备份中还原容器&lt;/h3&gt;
&lt;p&gt;使用刚刚创建的备份，您可以将其还原到同一个容器，或者其他地方创建的容器。&lt;/p&gt;
&lt;p&gt;例如，创建一个名为 &lt;code&gt;dbstore2&lt;/code&gt; 的新容器：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run -v /dbdata --name dbstore2 ubuntu /bin/bash
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在新容器的数据卷中解压备份文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run --rm --volumes-from dbstore2 -v $(pwd):/backup ubuntu bash -c &quot;cd /dbdata &amp;amp;&amp;amp; tar xvf /backup/backup.tar --strip 1&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可以使用上述技术，使用您喜欢的工具自动执行备份、迁移和还原测试。&lt;/p&gt;
&lt;h2 id=&quot;删除卷&quot;&gt;删除卷&lt;/h2&gt;
&lt;p&gt;当删除容器后，Docker 数据卷仍然存在。有两种类型的卷需要考虑：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;命名卷&lt;/strong&gt;具有来自容器外部的特定源，例如 &lt;code&gt;awesome:/bar&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;匿名卷&lt;/strong&gt;没有特定的源，因此当容器被删除时，通知 Docker 引擎守护进程删除它们。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;删除匿名卷&quot;&gt;删除匿名卷&lt;/h3&gt;
&lt;p&gt;要自动删除匿名卷，请使用 &lt;code&gt;--rm&lt;/code&gt; 选项。例如，这个命令创建一个匿名的 &lt;code&gt;/foo&lt;/code&gt; 卷。当容器被删除时，Docker 引擎会删除 &lt;code&gt;/foo&lt;/code&gt; 卷，但不会删除 &lt;code&gt;awesome&lt;/code&gt; 卷。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker run --rm -v /foo -v awesome:/bar busybox top
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除所有卷&quot;&gt;删除所有卷&lt;/h3&gt;
&lt;p&gt;要删除所有未使用的卷并释放空间，请执行以下操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ docker volume prune
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;作者 ： Docker 官网&lt;br/&gt;译者 ： 技术译民&lt;br/&gt;出品 ： &lt;a href=&quot;https://ittranslator.cn/&quot;&gt;技术译站&lt;/a&gt;&lt;br/&gt;链接 ： &lt;a href=&quot;https://docs.docker.com/storage/volumes/&quot;&gt;英文原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 14 Jul 2020 17:20:00 +0000</pubDate>
<dc:creator>技术译民</dc:creator>
<og:description>卷（volumes）是 Docker 容器生产和使用持久化数据的首选机制。绑定挂载（bind mounts）依赖于主机的目录结构，卷（volumes）完全由 Docker 管理。卷与绑定挂载相比有几个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ittranslator/p/13303417.html</dc:identifier>
</item>
<item>
<title>【Nginx】如何配置Nginx日志？这是最全面的一篇了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13303325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13303325.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;日志对于统计排错来说非常有利的。本文总结了 Nginx 日志相关的配置如 access_log、 log_format、open_log_file_cache、 log_not_found、 log_subrequest、 rewrite_log、 error_log。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;配置nginx日志&quot;&gt;配置Nginx日志&lt;/h2&gt;
&lt;p&gt;Nginx 有一个非常灵活的日志记录模式。每个级别的配置可以有各自独立的访问日志。日志格式通过 log_format命令来定义。 ngx_http_log_module 是用来定义请求日志格式的。&lt;/p&gt;
&lt;h2 id=&quot;access_log-指令&quot;&gt;access_log 指令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;access_log path [format [buffer=size [flush=time]]];
access_log path format gzip[=level] [buffer=size] [flush=time];
access_log syslog:server=address[,parameter=value] [format];
access_log off;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;access_log logs/access.log combined;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置段:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http, server, location, if in location, limit_except
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;gzip 压缩等级。&lt;/li&gt;
&lt;li&gt;buffer 设置内存缓存区大小。&lt;/li&gt;
&lt;li&gt;flush 保存在缓存区中的最长时间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;不记录日志：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;access_log off;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用默认 combined 格式记录日志：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;access_log logs/access.log
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;access_log logs/access.log combined;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;log_format-指令&quot;&gt;log_format 指令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;log_format name string …;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;log_format combined “…” ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置段:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;name 表示格式名称&lt;/li&gt;
&lt;li&gt;string 表示等义的格式。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;log_format 有一个默认的无需设置的 combined 日志格式，相当于apache 的 combined 日志格式，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;log_format combined '$remote_addr - $remote_user [$time_local] '
' &quot;$request&quot; $status $body_bytes_sent '
' &quot;$http_referer&quot; &quot;$http_user_agent&quot; ';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 nginx 位于负载均衡器， squid， nginx 反向代理之后， web 服务器无法直接获取到客户端真实的 IP 地址了。&lt;br/&gt;$remote_addr 获取反向代理的 IP 地址。反向代理服务器在转发请求的 http 头信息中，可以增加 X-ForwardedFor 信息，用来记录 客户端 IP 地址和客户端请求的服务器地址。 如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;log_format porxy '$http_x_forwarded_for - $remote_user [$time_local] '
' &quot;$request&quot; $status $body_bytes_sent '
' &quot;$http_referer&quot; &quot;$http_user_agent&quot; ';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志格式允许包含的变量注释如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;$remote_addr, $http_x_forwarded_for 记录客户端 IP 地址&lt;/li&gt;
&lt;li&gt;$remote_user 记录客户端用户名称&lt;/li&gt;
&lt;li&gt;$request 记录请求的 URL 和 HTTP 协议&lt;/li&gt;
&lt;li&gt;$status 记录请求状态&lt;/li&gt;
&lt;li&gt;$body_bytes_sent 发送给客户端的字节数，不包括响应头的大小； 该变量与 Apache 模块 mod_log_config 里的“%B”参数兼容。&lt;/li&gt;
&lt;li&gt;$bytes_sent 发送给客户端的总字节数。&lt;/li&gt;
&lt;li&gt;$connection 连接的序列号。&lt;/li&gt;
&lt;li&gt;$connection_requests 当前通过一个连接获得的请求数量。&lt;/li&gt;
&lt;li&gt;$msec 日志写入时间。单位为秒，精度是毫秒。&lt;/li&gt;
&lt;li&gt;$pipe 如果请求是通过 HTTP 流水线(pipelined)发送， pipe 值为“p”，否则为“.”。&lt;/li&gt;
&lt;li&gt;$http_referer 记录从哪个页面链接访问过来的&lt;/li&gt;
&lt;li&gt;$http_user_agent 记录客户端浏览器相关信息&lt;/li&gt;
&lt;li&gt;$request_length 请求的长度（包括请求行，请求头和请求正文）。&lt;/li&gt;
&lt;li&gt;$request_time 请求处理时间，单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。&lt;/li&gt;
&lt;li&gt;$time_iso8601 ISO8601 标准格式下的本地时间。&lt;/li&gt;
&lt;li&gt;$time_local 通用日志格式下的本地时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：发送给客户端的响应头拥有“sent_http_”前缀。 比如$sent_http_content_range。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http {
        log_format main '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
        '&quot;$status&quot; $body_bytes_sent &quot;$http_referer&quot; '
        '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot; '
        '&quot;$gzip_ratio&quot; $request_time $bytes_sent $request_length';
        log_format srcache_log '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
        '&quot;$status&quot; $body_bytes_sent $request_time $bytes_sent
        $request_length '
        '[$upstream_response_time] [$srcache_fetch_status]
        [$srcache_store_status] [$srcache_expire]';
        open_log_file_cache max=1000 inactive=60s;
        server {
                server_name ~^(www\.)?(.+)$;
                access_log logs/$2-access.log main;
                error_log logs/$2-error.log;
                location /srcache {
                        access_log logs/access-srcache.log srcache_log;
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;open_log_file_cache-指令&quot;&gt;open_log_file_cache 指令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;open_log_file_cache max=N [inactive=time] [min_uses=N] [valid=time];
open_log_file_cache off;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;open_log_file_cache off;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置段:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http, server, location
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于每一条日志记录，都将是先打开文件，再写入日志，然后关闭。可以使用 open_log_file_cache 来设置日志文件缓存(默认是 off)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数注释如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;max:设置缓存中的最大文件描述符数量，如果缓存被占满，采用 LRU 算法将描述符关闭。&lt;/li&gt;
&lt;li&gt;inactive:设置存活时间，默认是 10s&lt;/li&gt;
&lt;li&gt;min_uses:设置在 inactive 时间段内，日志文件最少使用多少次后，该日志文件描述符记入缓存中，默认是 1 次&lt;/li&gt;
&lt;li&gt;valid:设置检查频率，默认 60s&lt;/li&gt;
&lt;li&gt;off：禁用缓存&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;实例如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;log_not_found-指令&quot;&gt;log_not_found 指令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;log_not_found on | off;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;log_not_found on;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置段:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http, server, location
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是否在 error_log 中记录不存在的错误。默认是。&lt;/p&gt;
&lt;h2 id=&quot;log_subrequest-指令&quot;&gt;log_subrequest 指令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;log_subrequest on | off;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;log_subrequest off;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置段:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http, server, location
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是否在 access_log 中记录子请求的访问日志。默认不记录。&lt;/p&gt;
&lt;h2 id=&quot;rewrite_log-指令&quot;&gt;rewrite_log 指令&lt;/h2&gt;
&lt;p&gt;由 ngx_http_rewrite_module 模块提供的。用来记录重写日志的。对于调试重写规则建议开启。 Nginx 重写规则指南&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;rewrite_log on | off;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;rewrite_log off;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置段:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;http, server, location, if
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启用时将在 error log 中记录 notice 级别的重写日志。&lt;/p&gt;
&lt;h2 id=&quot;error_log-指令&quot;&gt;error_log 指令&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;语法:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;error_log file | stderr | syslog:server=address[,parameter=value] [debug | info | notice |
warn | error | crit | alert | emerg];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;默认值:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;error_log logs/error.log error;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置段:&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;main, http, server, location
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置错误日志。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200709131720844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jul 2020 16:29:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 日志对于统计排错来说非常有利的。本文总结了 Nginx 日志相关的配置如 access_log、 log_format、open_log_file_cache、 log_not_found、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13303325.html</dc:identifier>
</item>
<item>
<title>MySQL索引——总结篇 - boardMan</title>
<link>http://www.cnblogs.com/CodeMLB/p/13303301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CodeMLB/p/13303301.html</guid>
<description>&lt;h2 id=&quot;数据库的三范式，反模式&quot;&gt;数据库的三范式，反模式&lt;/h2&gt;
&lt;p&gt;数据库范式是为了解决关系数据库中数据冗余、更新异常、插入异常、删除异常等问题而引入的。数据范式可以避免数据冗余、节省空间、增加维护便利性&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第一范式（原子性）&lt;br/&gt;强调属性的原子性，要求属性不可再分解&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第二范式（唯一约束性）&lt;br/&gt;强调记录的唯一约束性，表中必须有一主键，且非主键不能只依赖主键的一部分&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;第三范式（冗余性约束）&lt;br/&gt;强调属性的冗余性约束，非主键列必须直接依赖于主键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;反模式&lt;br/&gt;范式设计下，数据库业务设计的表可能增多，涉及到多表联合查询，导致性能变差。因此，出于性能优先的考量，在数据库结构中使用反模式的设计，利用空间换取时间，采用数据冗余的方式避免多表联合查询。数据一致性的问题，可选择尽可能使数据达到用户一致，保证系统一段时间的自我恢复和修正，最终达成一致。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;零碎知识&quot;&gt;零碎知识&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据类型&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;数值、日期、字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;可变长度类型数据&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可变长度类型中varchar(200)与varchar(50)存储hello所占空间相同，但前者在排序时会占用更多内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;自增id删除之后的记录&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;InnoDB引擎只将当前自增主键的最大id存到内存中，重启后可能会使最大id丢失；而MyISAM会将最大id记录到数据文件中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;count 语句的统计&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;没有where限定时，InnoDB的count(*)相对MyISM可能慢很多，因为InnoDB是实时统计。而MyISM维护了一个计数器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;索引&quot;&gt;索引&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;优点：&lt;br/&gt;提高检索速度，降低IO成本&lt;br/&gt;事前排序，降低查询时CPU消耗&lt;br/&gt;缺点：&lt;br/&gt;增加存储空间、降低表更新速度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用场景&lt;br/&gt;小型表不建议使用，适用于中大型表；对特大型表索引的代价更大，可对数据库表进行分区&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;索引的六种类型&lt;br/&gt;普通索引、唯一索引（唯一性）、主键索引（不允许为空）、复合索引、外建索引、全文索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;索引创建原则&lt;br/&gt;出现在where语句后，而不是select；索引基数越大，效果越好；有时复合索引提高效率；过多索引会占用磁盘空间；主键尽量选取较短的数据类型；字符串索引应建立一个前缀长度，节省索引空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;索引使用注意事项&lt;br/&gt;避免在where后面使用逻辑或表达式操作、使用OR连接条件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;索引原理&quot;&gt;索引原理&lt;/h3&gt;
&lt;p&gt;默认使用B Tree索引&lt;/p&gt;
&lt;h4 id=&quot;b-tree索引&quot;&gt;B Tree索引&lt;/h4&gt;
&lt;p&gt;以M路BTree结构为例（M&amp;gt;=2，否则为空树）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;排序方式：所有节点都递增排序&lt;/li&gt;
&lt;li&gt;子节点数：1&amp;lt;非叶子节点数&amp;lt;=M&lt;/li&gt;
&lt;li&gt;关键字数：ceil(M/2)-1 &amp;lt; 关键字数 &amp;lt; M-1&lt;/li&gt;
&lt;li&gt;叶子节点：所有子节点均在同一层，包换关键字及关键字记录的地址（此外，也有指向其子节点的指针，值为null）&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;btree索引&quot;&gt;B+Tree索引&lt;/h4&gt;
&lt;p&gt;对B Tree索引的一种优化，B+Tree中所有数据记录节点都按照键值大小顺序存放在同一层节点上，每个非叶子节点都只存储key值信息，这样可大大增加每个节点存储的key值数量，降低树的高度&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;非叶子节点只记录键信息&lt;/li&gt;
&lt;li&gt;所有叶子节点之间都有一个链指针&lt;/li&gt;
&lt;li&gt;数据记录都放在叶子节点中&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;b-tree-与-btree的比较&quot;&gt;B Tree 与 B+Tree的比较&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;B+树层级更少：B+树每个非叶子节点存储的关键字更多，所以层级更少，查询速度更快&lt;/li&gt;
&lt;li&gt;B+树查询更稳定：B+树所有关键字地址都存储在叶子节点上，所以每次查找次数相同，查询速度更稳定&lt;/li&gt;
&lt;li&gt;B+树具有天然的排序功能：B+树所有叶子节点数据构成了一个有序链表，在查询区间数据时更方便，数据紧密性高，缓存命中率也高&lt;/li&gt;
&lt;li&gt;B+树全局遍历更快：B+树只需要遍历所有叶子节点，而不需要像B树一层层进行遍历&lt;/li&gt;
&lt;li&gt;B数对根节点附近的数据访问速度更快：因为B数非叶子节点本身存有关键字其数据地址&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;聚集索引和辅助索引&quot;&gt;聚集索引和辅助索引&lt;/h3&gt;
&lt;p&gt;聚集索引（主键索引），其叶子节点存储的数据是整行的具体数据；&lt;br/&gt;辅助索引（二级索引），其叶子节点存的是整行数据对应的主键值，根据辅助索引查询数据要经过两步，即回表：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;InnoDB 存储引擎会遍历辅助索引找到主键&lt;/li&gt;
&lt;li&gt;再通过主键在聚集索引中找到完整的行记录数据&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;聚集索引的主键
&lt;ol&gt;&lt;li&gt;定义主键时，InnoDB 存储引擎会将其当做聚集索引&lt;/li&gt;
&lt;li&gt;没有定义主键时，InnoDB 存储引擎会定位到第一个唯一索引，且改索引的所有列值均为非空，将其当做聚集索引&lt;/li&gt;
&lt;li&gt;没有主键且没有适合的唯一索引，InnoDB 存储引擎产生一个ID值6字节的聚集索引&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;聚集索引的注意事项&quot;&gt;聚集索引的注意事项&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;插入速度严重依赖插入顺序，按照主键的顺序插入是最快的方式，否则出现页分裂 会影响性能。（因此，一般定义一个自增的Id作为主键）&lt;/li&gt;
&lt;li&gt;更新主键会导致更新的行移动，因此一般定义主键为不可更新&lt;/li&gt;
&lt;li&gt;二级索引访问需要两次查询，第一次找到主键值，第二次找到行数据。（但是当查询数据只有id和索引时，可一次查询直接返回数据，即索引覆盖）&lt;/li&gt;
&lt;li&gt;主键id建议使用整型。如此，主键索引的B+树节点可以存储更多主键id，辅佐索引的B+树节点可以存储更多主键id&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;索引的最左匹配特征&quot;&gt;索引的最左匹配特征&lt;/h3&gt;
&lt;p&gt;当索引种类是复合索引时，B+树通过从左往右建立搜索树，即索引的最左匹配特征&lt;/p&gt;
</description>
<pubDate>Tue, 14 Jul 2020 16:24:00 +0000</pubDate>
<dc:creator>boardMan</dc:creator>
<og:description>MySQL索引 MySQL索引 数据库的三范式，反模式 零碎知识 索引 索引原理 B Tree索引 B+Tree索引 B Tree 与 B+Tree的比较 聚集索引和辅助索引 聚集索引的注意事项 索引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CodeMLB/p/13303301.html</dc:identifier>
</item>
</channel>
</rss>