<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>volatile底层原理详解 - JavaStorm</title>
<link>http://www.cnblogs.com/uniqueDong/p/10944244.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/uniqueDong/p/10944244.html</guid>
<description>&lt;p&gt;今天我们聊聊volatile底层原理；&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Java语言规范对于volatile定义如下：&lt;/p&gt;
&lt;p&gt;Java编程语言允许线程访问共享变量，为了确保共享变量能够被准确和一致性地更新，线程应该确保通过排它锁单独获得这个变量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先我们从定义开始入手，官方定义比较拗口。通俗来说就是&lt;strong&gt;一个字段被volatile修饰，Java的内存模型确保所有的线程看到的这个变量值是一致的，&lt;/strong&gt;但是它并不能保证多线程的原子操作。这就是所谓的线程可见性。&lt;strong&gt;我们要知道他是不能保证原子性的&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;内存模型相关概念&quot;&gt;内存模型相关概念&lt;/h2&gt;
&lt;p&gt;Java线程之间的通信由Java内存模型(JMM)控制，JMM决定一个线程对共享变量的修改何时对另外一个线程可见。JMM定义了线程与主内存的抽象关系：线程之间的变量存储在主内存(Main Memory)中，每个线程都有一个私有的本地内存(Local Memory)保存着共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17987782-450f4a923f40b9f4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果线程A与线程B通信：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程A要先把本地内存A中更新过的共享变量刷写到主内存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;线程B到主内存中读取线程A更新后的共享变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;计算机在运行程序时，每条指令都是在CPU中执行的，在执行过程中势必会涉及到数据的读写。我们知道程序运行的数据是存储在主存中，这时就会有一个问题，读写主存中的数据没有CPU中执行指令的速度快，如果任何的交互都需要与主存打交道则会大大影响效率，所以就有了CPU高速缓存。CPU高速缓存为某个CPU独有，只与在该CPU运行的线程有关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。&lt;/strong&gt;在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;i++;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当线程运行这行代码时，首先会从主内存中读取i，然后复制一份到CPU高速缓存中,接着CPU执行+1的操作，再将+1后的数据写在缓存中，最后一步才是刷新到主内存中。在单线程时没有问题，多线程就有问题了。&lt;/p&gt;
&lt;p&gt;如下：假如有两个线程A、B都执行这个操作（i++），按照我们正常的逻辑思维主存中的i值应该=3，但事实是这样么？&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;分析如下：&lt;/p&gt;
&lt;p&gt;两个线程从主存中读取i的值（1）到各自的高速缓存中，然后线程A执行+1操作并将结果写入高速缓存中，最后写入主存中，此时主存i==2,线程B做同样的操作，主存中的i仍然=2。所以最终结果为2并不是3。这种现象就是缓存一致性问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决缓存一致性方案有两种：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;通过在总线加LOCK#锁的方式；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;通过缓存一致性协议。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;但是方案1存在一个问题，&lt;strong&gt;它是采用一种独占的方式来实现的，即总线加LOCK#锁的话，只能有一个CPU能够运行，其他CPU都得阻塞，效率较为低下。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二种方案，&lt;strong&gt;缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。&lt;/strong&gt;所以JMM就解决这个问题。&lt;/p&gt;
&lt;h2 id=&quot;volatile实现原理&quot;&gt;volatile实现原理&lt;/h2&gt;
&lt;p&gt;有volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令，该指令在多核处理器下会引发两件事情。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将当前处理器缓存行数据刷写到系统主内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这个刷写回主内存的操作会使其他CPU缓存的该共享变量内存地址的数据无效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样就保证了多个处理器的缓存是一致的，对应的处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器缓存行设置无效状态，当处理器对这个数据进行修改操作的时候会重新从主内存中把数据读取到缓存里。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;使用场景&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;volatile经常用于两个场景：状态标记、double check&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;状态标记&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//线程1
boolean stop = false;
while(!stop){
   doSomething();
}

//线程2
stop = true;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。&lt;/p&gt;
&lt;p&gt;下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。&lt;/p&gt;
&lt;p&gt;那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是加上volatile就没问题了。&lt;/strong&gt;如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    volatile boolean flag = false;

    while(!flag){
       doSomething();
    }

    public void setFlag() {
       flag = true;
    }

    volatile boolean inited = false;
    //线程1:
    context = loadContext();  
    inited = true;            

    //线程2:
    while(!inited ){
    sleep()
    }
    doSomethingwithconfig(context);&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;double check&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;public class Singleton{
   private volatile static Singleton instance = null;

   private Singleton() {

  }

   public static Singleton getInstance() {
       if(instance==null) {
           synchronized (Singleton.class) {
               if(instance==null)
                   instance = new Singleton();
          }
      }
       return instance;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;客官觉得有用请点赞或收藏，关注公众号JavaStorm，你将发现一个有趣的灵魂！&lt;br/&gt;后面我们继续分析JMM内存模型相关技术。&lt;br/&gt;将自己的知识分享，以后会持续输出，希望给读者朋友们带来帮助。若有帮助读者朋友可以点赞或者关注。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17987782-ea9137a978975f5c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;JavaStorm.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 29 May 2019 07:47:00 +0000</pubDate>
<dc:creator>JavaStorm</dc:creator>
<og:description>今天我们聊聊volatile底层原理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/uniqueDong/p/10944244.html</dc:identifier>
</item>
<item>
<title>记一次序列化的JSON解析问题 - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/10944164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/10944164.html</guid>
<description>&lt;h2 id=&quot;一问题初探&quot;&gt;一、问题初探&lt;/h2&gt;
&lt;p&gt;我今天在使用Ribbon 远程调用的时候&lt;/p&gt;
&lt;p&gt;消费者去消费服务端所提供的服务，在使用Post请求中的PostForEntity传递参数的时候，我是这样写的&lt;/p&gt;
&lt;p&gt;Ribbon 消费端：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529153735195-643289776.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;User 是一个 Pojo 对象，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User {

    private Integer id;
    private String name;

    public User(Integer id, String name) {
        this.id = id;
        this.name = name;
    }

    get... and set ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ribbon 服务端：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529153522586-2027612831.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是一个很简单的Ribbon 远程调用的一个操作，报如下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529153536382-363918546.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跟入源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529153554430-2076615010.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529153602587-960545191.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后就不明觉厉了，第一开始比较烦躁，一直以为是消费端的问题，因为错误是从消费服务端报出来的。后来经过冷静发现，上述代码是在处理服务端响应的时候报出来的，应该还是服务端报错来的错误。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;2019-04-14 13:56:27.183  WARN 3500 --- [nio-8080-exec-1] .w.s.m.s.DefaultHandlerExceptionResolver : Failed to read HTTP message: org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Can not construct instance of com.service.provider.pojo.User: no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?); nested exception is com.fasterxml.jackson.databind.JsonMappingException: Can not construct instance of com.service.provider.pojo.User: no suitable constructor found, can not deserialize from Object value (missing default constructor or creator, or perhaps need to add/enable type information?)
 at [Source: java.io.PushbackInputStream@25979c35; line: 1, column: 2]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码并不能看懂什么意思，求助google，从stackoverflow上找到了问题的答案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529153617778-1285062230.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有加默认的构造函数？？？？？？ 这是什么鬼？ 默认的构造函数和JSON解析有什么关系？&lt;/p&gt;
&lt;p&gt;但是能够解决问题了，我检查了一遍我一直以为我的值没有传递过去，但我看已经传递到服务端了(避免了一个白痴问题)。&lt;/p&gt;
&lt;h2 id=&quot;二问题原因&quot;&gt;二、问题原因&lt;/h2&gt;
&lt;p&gt;====================================华丽的分割线====================================&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;事实印证了我是个菜比。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;事情是这样的&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Ribbon的消费者向服务者提供的数据转换是要把对象转换为二进制数据，这个过程称之为&lt;code&gt;序列化&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;而服务端收到二进制的数据再转换为对应的对象，这个过程称之为&lt;code&gt;反序列化&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;序列化会把对象保存在磁盘中，或允许直接在网络中直接传输对象&lt;/p&gt;
&lt;p&gt;反序列化就是收到二进制的数据，再转换为对应的对象。&lt;/p&gt;
&lt;p&gt;而实现对象序列化的方法有两种：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;1. 实现序列化接口&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;2. 提供无参构造函数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而上面报错的原因就是因为没有提供默认的构造函数或者实现序列化接口！！！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三解决问题&quot;&gt;三、解决问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;添加无参构造函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;解决问题一，再上面的Pojo类上添加默认的构造函数&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class User {

    private Integer id;
    private String name;

    public User(){}
    public User(Integer id, String name) {
        this.id = id;
        this.name = name;
    }

    get and set...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次调用接口，客户端能够打印出来对应的日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529153743981-1077653903.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 07:37:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>[TOC] 一、问题初探 我今天在使用Ribbon 远程调用的时候 消费者去消费服务端所提供的服务，在使用Post请求中的PostForEntity传递参数的时候，我是这样写的 Ribbon 消费端：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/10944164.html</dc:identifier>
</item>
<item>
<title>Angular 8的新特性介绍 - 寻找石头鱼</title>
<link>http://www.cnblogs.com/xzsty/p/10942900.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xzsty/p/10942900.html</guid>
<description>&lt;p&gt;在今天早些时候Angular团队发布了8.0.0稳定版。其实早在NgConf 2019大会上，演讲者就已经提及了从工具到差分加载的许多内容以及更多令人敬畏的功能。下面是我对8.0.0一些新功能的简单介绍，希望可以帮助大家快速了解新版本。&lt;/p&gt;

&lt;h2 id=&quot;差分加载&quot;&gt;差分加载&lt;/h2&gt;
&lt;p&gt;根据您的browserlist 文件，在构建期间，Angular将为其创建单独的包polyfills。所以基本上你会有：&lt;br/&gt;&lt;img src=&quot;https://github.com/xunzhaoshitouyu/markdowm/raw/master/images/ng8.0.0_1.jpeg&quot;/&gt;&lt;br/&gt;使用此功能将减小捆绑包大小。&lt;br/&gt;&lt;img src=&quot;https://github.com/xunzhaoshitouyu/markdowm/raw/master/images/ng8.0.0_2.jpeg&quot;/&gt;&lt;br/&gt;但这是如何工作的？&lt;/p&gt;
&lt;p&gt;基本上，Angular将使用polyfill构建其他文件，并且它们将注入nomodule 属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt; 
  &amp;lt;pp-root&amp;gt; &amp;lt;/ pp-root&amp;gt;
&amp;lt;script type =“text / javascript”src =“runtime.js”&amp;gt; &amp;lt;/ script&amp;gt; 
  &amp;lt;script type =“text / javascript”src =“es2015- polyfills.js ” nomodule &amp;gt; &amp;lt;/ script&amp;gt; 
  &amp;lt;script type =“ text / javascript“src =”polyfills.js“&amp;gt; &amp;lt;/ script&amp;gt; 
  &amp;lt;script type =”text / javascript“src =”styles.js“&amp;gt; &amp;lt;/ script&amp;gt; 
  &amp;lt;script type =”text / javascript“src =”vendor .js“&amp;gt; &amp;lt;/ script&amp;gt; 
  &amp;lt;script type =”text / javascript“src =”main.js“&amp;gt; &amp;lt;/ script&amp;gt; 
&amp;lt;/ body&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;nomodule属性是一个布尔属性，用于阻止脚本在支持模块脚本的用户代理中执行。这允许在现代用户代理和旧用户代理中的经典脚本中选择性地执行模块脚本.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;svg作为模板&quot;&gt;SVG作为模板&lt;/h2&gt;
&lt;p&gt;您现在可以将SVG文件用作模板。到目前为止，我们只能选择使用内联HTML或外部HTML作为模板。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component({
  selector: &quot;app-icon&quot;,
  templateUrl: &quot;./icon.component.svg&quot;,
  styleUrls: [&quot;./icon.component.css&quot;]
})
export class AppComponent {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ivy渲染引擎实验&quot;&gt;Ivy渲染引擎实验&lt;/h2&gt;
&lt;p&gt;虽然早在angular 6的时候就提出了Ivy，但是Ivy仍处于试验阶段，通过Angular 8版本，您可以通过创建一个enable-ivy标志设置为true 的应用程序来测试它，如下所示。它不是完全正常运行（选择预览），正如Igor Minar在ngConf 2019中建议的那样，视图引擎仍然推荐用于新应用。&lt;/p&gt;
&lt;p&gt;To enable Ivy in an existing project set enableIvyoption in the angularCompilerOptions in your project’s tsconfig.app.json&lt;br/&gt;要在现有项目中使用Ivy的话，需要在tsconfig.app.json文件中设置angularCompilerOptions选项的enableIvy属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;“angularCompilerOptions”： {“enableIvy”：true}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您也可以使用新引擎创建新应用程序&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ng new my-app --enable-ivy&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ivy将提供以下优势，Angular 9中预计前3个功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编译速度更快（V9）。&lt;/li&gt;
&lt;li&gt;改进了模板的类型检查（V9）。&lt;/li&gt;
&lt;li&gt;较小的捆绑尺寸（V9）（如果您错过了I / O 19，Vikram Subramanian显示了一个4.3 KB版本的应用程序）。&lt;/li&gt;
&lt;li&gt;向后兼容性。&lt;/li&gt;
&lt;li&gt;我最喜欢的：你可以调试模板（我确信很多开发人员需要这个功能）。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;bazel支持&quot;&gt;Bazel支持&lt;/h2&gt;
&lt;p&gt;Bazel是谷歌开源的另一款工具，“我们不喜欢谷歌”。正如Igor Minar所解释的那样，Bazel已经在内部使用了很长时间，现在可供所有人使用。您可以参考Bazel文档，并了解如何将其与Angular一起使用。&lt;br/&gt;你可能想知道：“Bazel准备好了吗？”简答：还没有。目前，它处于“选择预览”模式。&lt;/p&gt;
&lt;p&gt;Bazel可作为选择加入，预计将包含@angular/cli在第9版中。&lt;/p&gt;
&lt;p&gt;Bazel将提供以下优势：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;更快的构建时间（对于第一次构建需要时间，但并发构建将更快），Angular已经在使用它，现在CI在7.5分钟内完成，而不是在Bazel之前的60分钟。&lt;/li&gt;
&lt;li&gt;增量构建：您将能够仅构建和部署已更改的内容而不是整个应用程序。&lt;/li&gt;
&lt;li&gt;您可以弹出Bazel文件，默认情况下它们是隐藏的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;您可以使用以下命令添加Bazel支持：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ng add @ angular / bazel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者，您也可以使用Bazel创建一个新的应用程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install -g @ angular / bazel 
ng new my-app --colection = @ angular / bazel&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;builders-api&quot;&gt;Builders API&lt;/h2&gt;
&lt;p&gt;新版本允许我们使用Builders API，也称为Architect API。&lt;br/&gt;angular使用builders进行主要操作：serve ，build ，test ，lint和e2e 。您可以在angular.json文件中查看使用过的构建器。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
&quot;projects&quot;: {
  &quot;app-name&quot;: {
    ...
    &quot;architect&quot;: {
      &quot;build&quot;: {
        &quot;builder&quot;: &quot;@angular-devkit/build-angular:browser&quot;,
        ...
      },
      &quot;serve&quot;: {
        &quot;builder&quot;: &quot;@angular-devkit/build-angular:dev-server&quot;,
        ...
      },
      &quot;test&quot;: {
        &quot;builder&quot;: &quot;@angular-devkit/build-angular:karma&quot;,
        ...
      },
      &quot;lint&quot;: {
        &quot;builder&quot;: &quot;@angular-devkit/build-angular:tslint&quot;,
        ...
      },
      &quot;e2e&quot;: {
        &quot;builder&quot;: &quot;@angular-devkit/build-angular:protractor&quot;,
        ...
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从现在开始，我们可以创建自定义构建器。我认为这是gulp/grunt“旧时代”中的命令。&lt;/p&gt;
&lt;p&gt;基本上，构建器只是一个带有一组命令的函数，您可以createBuilder()从@angular-devkit/architect包传递给方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import { createBuilder } from '@angular-devkit/architect';
function customBuild(options, context) { 
  return new Promise((resolve, reject) =&amp;gt; {
    // set of commands
  })
}
createBuilder(customBuild);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;您可以在&lt;a href=&quot;https://github.com/angular/angular-cli/tree/a41c18571370a164d8a36695dbf4faf65860fc19/packages/angular_devkit/build_angular/src&quot;&gt;此处&lt;/a&gt;查看内置的Angular构建器。&lt;/p&gt;
&lt;h2 id=&quot;懒加载的变动&quot;&gt;懒加载的变动&lt;/h2&gt;
&lt;p&gt;新版本不推荐使用loadChildren:string 懒惰加载模块的语法。&lt;br/&gt;在8.0.0之前，懒加载的使用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;loadChildren: './lazy/lazy.module#LazyModule';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在的使用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;loadChildren: () =&amp;gt; import('./lazy/lazy.module').then(m =&amp;gt; m.LazyModule)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你有很多的懒加载的模块，并希望通过软件包做到这一点，可以点击&lt;a href=&quot;https://blog.angularindepth.com/automatically-upgrade-lazy-loaded-angular-modules-for-ivy-e760872e6084&quot;&gt;此处&lt;/a&gt;参考&lt;/p&gt;
&lt;h2 id=&quot;对angularjs-api中location的支持&quot;&gt;对AngularJS API中$location的支持&lt;/h2&gt;
&lt;p&gt;Angular团队希望为使用AngularJS的所有开发人员提供支持，并帮助他们升级到Angular。该团队现在在升级时添加了对$ location服务的支持。添加了angular/common/upgrade这个新包。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;允许从位置服务检索状态的功能。&lt;/li&gt;
&lt;li&gt;添加跟踪所有位置更改的功能。&lt;/li&gt;
&lt;li&gt;它将允许您读取hostname protocol port searchAngularJS中可用的属性。&lt;/li&gt;
&lt;li&gt;MockPlatformLocation 添加了API以测试位置服务。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;web-worker&quot;&gt;Web Worker&lt;/h2&gt;
&lt;p&gt;Angular 8中添加了Web worker支持。现在，您可以添加Web worker并将要在后台运行的耗时进程委派给Web worker。运行以下命令以使用Angular CLI生成新的Web worker：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ng g webWorker &amp;lt;name&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;service-worker&quot;&gt;Service Worker&lt;/h2&gt;
&lt;p&gt;随着PWA的使用日益增长，对Service Worker进行了许多改进。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一项改进是SwRegistrationOptions增加了选项。&lt;/li&gt;
&lt;li&gt;在一个域中支持多个应用。&lt;/li&gt;
&lt;li&gt;阅读&lt;a href=&quot;https://next.angular.io/guide/service-worker-config&quot;&gt;Angular Doc&lt;/a&gt;上有关服务工作者的更多信息。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;表单改进&quot;&gt;表单改进&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;添加了markAllAsTouched方法以标记所有的控件FormGroupas as touched。如果要触发一个表单组中所有控件的验证，这个方法将是非常有用的。之前我们不得不使用下面的代码片段来实现相同的功能：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;validateFormAndDisplayErrors(form: FormGroup) {
  Object.keys(form.controls).map((controlName) =&amp;gt; {
    form.get(controlName).markAsTouched({onlySelf: true});
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;从FormArray中清除所有元素&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以前要删除所有元素，formArray 我们必须循环删除第一个元素直到空：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while（formArray.length）{ 
  formArray.removeAt（0）; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在就不需要那样操作了，直接使用clear方法就可以完成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;formArray.clear()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;对typescript-3.4.x的支持&quot;&gt;对Typescript 3.4.x的支持&lt;/h2&gt;
&lt;p&gt;Angular现在使用TypeScript 3.3（v7使用3.2.x）。没有太多突破性的变化 - 所以你可能应该做得很好。你可以在&lt;a href=&quot;https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#typescript-34&quot;&gt;这里&lt;/a&gt;查看。&lt;/p&gt;
&lt;h2 id=&quot;性能改善&quot;&gt;性能改善&lt;/h2&gt;
&lt;p&gt;为每个请求ServerRendererFactory2创建一个新的实例DomElementSchemaRegistry，这是非常昂贵的。现在它将共享全局实例DomElementSchemaRegistry.&lt;/p&gt;

&lt;h2 id=&quot;从-angularplatform-browser中删除了已弃用的document&quot;&gt;从 @angular/platform-browser中删除了已弃用的DOCUMENT&lt;/h2&gt;
&lt;p&gt;从@angular/platform-browser中移除了DOCUMENT。如果您使用DOCUMENT from @angular/platform-browser，则应从此处开始导入@angular/common。&lt;/p&gt;
&lt;h2 id=&quot;angularhttp&quot;&gt;@angular/http&lt;/h2&gt;
&lt;p&gt;@angular/http在Angular 5中不推荐使用package，但由于@angular/platform-server依赖于它，所以仍然可用。从现在它已从包列表中删除。&lt;/p&gt;
&lt;h2 id=&quot;配置viewchild-contentchild查询的时间&quot;&gt;配置ViewChild / ContentChild查询的时间&lt;/h2&gt;
&lt;p&gt;使用此功能时，必须提供静态标志以定义何时需要解析ViewChild和ContentChild实例。&lt;/p&gt;
&lt;p&gt;使用此功能时，必须提供静态标志以定义何时需要解析ViewChild和ContentChild实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Ensure Change Detection runs before accessing the instance
@ContentChild('foo', { static: false }) foo!: ElementRef;
// If you need to access it in ngOnInt hook
@ViewChild(TemplateRef, { static: true }) foo!: TemplateRef;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上功能不适用于ViewChildren或ContentChildren。它们将在变更检测运行后解析。&lt;/p&gt;
&lt;p&gt;需要注意的是，设置static: true将不允许您从动态模板分辨率（例如*ngIf）获得结果。&lt;/p&gt;
&lt;p&gt;添加了原理图支持以将现有代码迁移到此语法，因为将使用此语法Ivy 。您可以运行ng update @angular/core以迁移现有代码。&lt;/p&gt;
&lt;h2 id=&quot;angular-material&quot;&gt;Angular Material&lt;/h2&gt;
&lt;p&gt;Angular Material工程重命名为Angular Components。包还是跟以前保持一样的。&lt;/p&gt;

&lt;p&gt;以上就是angular 8版本的一些改动。总体来说变化不是很大，延续了angular每年一个稳定版的习惯。&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 07:34:00 +0000</pubDate>
<dc:creator>寻找石头鱼</dc:creator>
<og:description>Angular 8新特性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xzsty/p/10942900.html</dc:identifier>
</item>
<item>
<title>张高兴的 .NET Core IoT 入门指南：（四）使用 SPI 进行通信 - 张高兴</title>
<link>http://www.cnblogs.com/zhanggaoxing/p/10943822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanggaoxing/p/10943822.html</guid>
<description>&lt;h2 id=&quot;什么是-spi&quot;&gt;什么是 SPI&lt;/h2&gt;
&lt;p&gt;和上一篇文章的 I&lt;sup&gt;2&lt;/sup&gt;C 总线一样，SPI（Serial Peripheral Interface，串行外设接口）也是设备与设备间通信方式的一种。SPI 是一种全双工（数据可以两个方向同时传输）的串行通信总线，由摩托罗拉于上个世纪 80 年代开发&lt;sup&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Serial_Peripheral_Interface&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;，用于短距离设备之间的通信。SPI 包含 4 根信号线，一根时钟线 SCK（Serial Clock，串行时钟），两根数据线 MOSI（Master Output Slave Input，主机输出从机输入）和 MISO（Master Input Slave Output，主机输入从机输出），以及一根片选信号 CS（Chip Select，或者叫 SS，Slave Select）。所谓的时钟线就是一种周期，两台设备数据传输不能各发各的，这样就没有意义，因此需要一种周期去对通信进行约束；数据线就是按照 MOSI 和 MISO 的中文翻译理解即可；片选信号用于主设备选择 SPI 上的从设备，I&lt;sup&gt;2&lt;/sup&gt;C 是靠地址选择设备，而 SPI 靠的是片选信号，一般来说要选择哪个从设备只要将相应的 CS 线设置为低电平即可，特殊情况需要看数据手册。下图展示了一个 SPI 主设备和三个 SPI 从设备的示意图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190529144634727-1001704001.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;图源：&lt;a href=&quot;https://en.wikipedia.org/wiki/File:SPI_three_slaves.svg&quot;&gt;Wikipedia&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;SPI 还有一个重要的概念就是时钟的极性（CPOL，Clock Polarity）和相位（CPHA，Clock Phase），对其这里不过多解释，我们只需要知道极性和相位的组合构成了 SPI 的传输模式（SPI Mode）。在数据手册中，只要是 SPI 通信协议的，一定会给出传输模式，我们根据数据手册进行设置即可。SPI 的传输模式是有固定编号的，下表给出了各个模式，常用的模式有 Mode0 和 Mode3。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Mode0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Mode1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Mode2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Mode3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190529144652192-519073321.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;该时序图显示了时钟的极性和相位。图源：&lt;a href=&quot;https://en.wikipedia.org/wiki/File:SPI_timing_diagram2.svg&quot;&gt;Wikipedia&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;SPI 相比较 I&lt;sup&gt;2&lt;/sup&gt;C 最大的优点就是传输速率高，并且数据在同一时间内可以双向传输，这都得益于它的两根输入和输出数据线。当然缺点也很明显，比 I&lt;sup&gt;2&lt;/sup&gt;C 多了两根线，这就要多占用两个 IO 接口。而且 SPI 采用 CS 线去选择设备，不像 I&lt;sup&gt;2&lt;/sup&gt;C 有寻址机制，如果你有很多个 SPI 设备需要连接的话 IO 接口的占用数量是相当高的。&lt;/p&gt;
&lt;p&gt;在 Raspberry Pi 的引脚中，引出了两组 SPI 接口。但有意思的是，在 Raspbian 中 SPI-1 是被禁用的，你需要修改一些参数去启用 SPI-1。SPI 接口的引脚编号如下图所示。&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;p&gt;  提示&lt;/p&gt;
&lt;p&gt;如何在 Raspbian 上开启 SPI-1？（在 Win10 IoT 上 SPI-1 是开启的）&lt;/p&gt;
&lt;p&gt;1. 使用编辑器打开 /boot/config.txt ，如：&lt;code&gt;sudo nano /boot/config.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2. 添加 &lt;code&gt;dtoverlay=spi1-3cs&lt;/code&gt; 并保存&lt;/p&gt;
&lt;p&gt;3. 重启&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190529144804033-1638051243.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;&lt;small&gt;Raspberry Pi B+/2B/3B/3B+/Zero 引脚图&lt;/small&gt;&lt;/p&gt;
&lt;h2 id=&quot;相关类&quot;&gt;相关类&lt;/h2&gt;
&lt;p&gt;SPI 操作的相关类位于 &lt;strong&gt;System.Device.Spi&lt;/strong&gt; 和 &lt;strong&gt;System.Device.Spi.Drivers&lt;/strong&gt; 命名空间下。&lt;/p&gt;
&lt;h3 id=&quot;spiconnectionsettings&quot;&gt;SpiConnectionSettings&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SpiConnectionSettings&lt;/code&gt; 类位于 &lt;strong&gt;System.Device.Spi&lt;/strong&gt; 命名空间下，表示 SPI 设备的连接设置。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public sealed class SpiConnectionSettings
{
    // 构造函数
    // busId 是 SPI 的内部 ID
    // chipSelectLine 是 CS Pin 的编号（在 Raspberry Pi 上，SPI-0 对应 0 和 1，SPI-1 对应 2）
    public SpiConnectionSettings(int busId, int chipSelectLine);

    // 属性
    // SPI 传输模式
    public SpiMode Mode { get; set; }
    // SPI 时钟频率
    public int ClockFrequency { get; set; }
    // CS 线激活状态（即高电平选中设备还是低电平选中设备）
    public PinValue ChipSelectLineActiveState { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;unixspidevice-和-windows10spidevice&quot;&gt;UnixSpiDevice 和 Windows10SpiDevice&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;UnixSpiDevice&lt;/code&gt; 和 &lt;code&gt;Windows10SpiDevice&lt;/code&gt; 类位于 &lt;strong&gt;System.Device.Spi.Drivers&lt;/strong&gt; 命名空间下。两个类均派生自抽象类 &lt;strong&gt;SpiDevice&lt;/strong&gt;，分别代表 Unix 和 Windows10 下的 SPI 控制器，使用时按照所处的平台有选择的进行实例化。这里以 &lt;code&gt;UnixSpiDevice&lt;/code&gt; 类为例说明。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class UnixSpiDevice : SpiDevice
{
    // 构造函数
    // 需要传入一个 SpiConnectionSettings 对象
    public UnixSpiDevice(SpiConnectionSettings settings);

    // 方法
    // 从从设备中读取一段数据，数据长度由 Span 的长度决定
    public override void Read(Span&amp;lt;byte&amp;gt; buffer);
    // 从从设备中读取一个字节的数据
    public override byte ReadByte();

    // 全双工传输，即主从设备同时传输
    // writeBuffer 为要写入从设备的数据
    // readBuffer 为要从从设备中读取的数据
    // 需要注意的是 writeBuffer 和 readBuffer 需要长度一致
    public override void TransferFullDuplex(ReadOnlySpan&amp;lt;byte&amp;gt; writeBuffer, Span&amp;lt;byte&amp;gt; readBuffer);
    
    // 向从设备中写入一段数据，通常 Span 中的第一个数据为要写入数据的寄存器的地址
    public override void Write(ReadOnlySpan&amp;lt;byte&amp;gt; buffer);
    // 向从设备中写入一个字节的数据，通常这个字节为寄存器的地址
    public override void WriteByte(byte value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spi-的通信步骤&quot;&gt;SPI 的通信步骤&lt;/h2&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;初始化 SPI 连接设置 &lt;code&gt;SpiConnectionSettings&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，我们只需要配置 SPI 的 ID，CS 的编号，时钟频率和 SPI 传输模式。其中像时钟频率、传输模式等设置都来自于设备的数据手册。比如要使用 Raspberry Pi 的 SPI-0 去操作一个时钟频率为 5 MHz，SPI 传输模式为 Mode3 的设备，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;SpiConnectionSettings settings = new SpiConnectionSettings(busId: 0, chipSelectLine: 0)
{
    ClockFrequency = 5000000,
    Mode = SpiMode.Mode3
};&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;读取和写入&lt;/p&gt;
&lt;p&gt;读取和写入与 I&lt;sup&gt;2&lt;/sup&gt;C 类似，这里不再过多赘述，详见上一篇博客，这里只提供一个代码示例。唯一要说明的就是使用全双工通信 &lt;code&gt;TransferFullDuplex()&lt;/code&gt; 时，要求写入的数据和读取的数据长度要一致，并且能否使用也需要看设备是否支持。比如从地址为 0x00 的寄存器中向后连续读取 8 个字节的数据，并且向地址为 0x01 的寄存器写入一个字节的数据，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// 读取
sensor.WriteByte(0x00);
Span&amp;lt;byte&amp;gt; readBuffer = stackalloc byte[8]; 
sensor.Read(readBuffer);

// 写入
Span&amp;lt;byte&amp;gt; writeBuffer = stackalloc byte[] { 0x01, 0xFF }; 
sensor.Write(writeBuffer);

// 全双工读取
Span&amp;lt;byte&amp;gt; writeBuffer = stackalloc byte[8]; 
Span&amp;lt;byte&amp;gt; readBuffer = stackalloc byte[8];
writeBuffer[0] = 0x00;
sensor.TransferFullDuplex(writeBuffer, readBuffer);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;加速度传感器读取实验&quot;&gt;加速度传感器读取实验&lt;/h2&gt;
&lt;p&gt;本实验选用的是三轴加速度传感器 &lt;strong&gt;ADXL345&lt;/strong&gt; ，数据手册地址：&lt;a href=&quot;http://wenku.baidu.com/view/87a1cf5c312b3169a451a47e.html&quot; class=&quot;uri&quot;&gt;http://wenku.baidu.com/view/87a1cf5c312b3169a451a47e.html&lt;/a&gt; 。&lt;/p&gt;
&lt;h3 id=&quot;传感器图像&quot;&gt;传感器图像&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190529144715907-30366779.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;硬件需求&quot;&gt;硬件需求&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ADXL345&lt;/td&gt;
&lt;td&gt;x1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;杜邦线&lt;/td&gt;
&lt;td&gt;若干&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;电路&quot;&gt;电路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190529144729816-213482312.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;VCC - 3.3 V&lt;/li&gt;
&lt;li&gt;GND - GND&lt;/li&gt;
&lt;li&gt;CS - CS0 (Pin24)&lt;/li&gt;
&lt;li&gt;SDO - SPI0 MISO (Pin21)&lt;/li&gt;
&lt;li&gt;SDA - SPI0 MOSI (Pin19)&lt;/li&gt;
&lt;li&gt;SCL - SPI0 SCLK (Pin23)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;ol readability=&quot;10&quot;&gt;&lt;li&gt;打开 Visual Studio ，新建一个 .NET Core 控制台应用程序，项目名称为“Adxl345”。&lt;/li&gt;
&lt;li&gt;引入 &lt;strong&gt;System.Device.Gpio&lt;/strong&gt; NuGet 包。&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;新建类 &lt;strong&gt;Adxl345&lt;/strong&gt;，替换如下代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class Adxl345 : IDisposable
{
    #region 寄存器地址
    private const byte ADLX_POWER_CTL = 0x2D；      // 电源控制地址
    private const byte ADLX_DATA_FORMAT = 0x31;     // 范围地址
    private const byte ADLX_X0 = 0x32;              // X轴数据地址
    private const byte ADLX_Y0 = 0x34;              // Y轴数据地址
    private const byte ADLX_Z0 = 0x36;              // Z轴数据地址
    #endregion

    private SpiDevice _sensor = null;

    private readonly int _range = 16;               // 测量范围（-8，8）
    private const int Resolution = 1024;            // 分辨率

    #region SpiSetting
    /// &amp;lt;summary&amp;gt;
    /// ADX1345 SPI 时钟频率
    /// &amp;lt;/summary&amp;gt;
    public const int SpiClockFrequency = 5000000;

    /// &amp;lt;summary&amp;gt;
    /// ADX1345 SPI 传输模式
    /// &amp;lt;/summary&amp;gt;
    public const SpiMode SpiMode = System.Device.Spi.SpiMode.Mode3;
    #endregion

    /// &amp;lt;summary&amp;gt;
    /// 加速度
    /// &amp;lt;/summary&amp;gt;
    public Vector3 Acceleration =&amp;gt; ReadAcceleration();

    /// &amp;lt;summary&amp;gt;
    /// 实例化一个 ADX1345
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;sensor&quot;&amp;gt;SpiDevice&amp;lt;/param&amp;gt;
    public Adxl345(SpiDevice sensor)
    {
        _sensor = sensor;

        // 设置 ADXL345 测量范围
        // 数据手册 P28，表 21
        Span&amp;lt;byte&amp;gt; dataFormat = stackalloc byte[] { ADLX_DATA_FORMAT, 0b_0000_0010 };
        // 设置 ADXL345 为测量模式
        // 数据手册 P24
        Span&amp;lt;byte&amp;gt; powerControl = stackalloc byte[] { ADLX_POWER_CTL, 0b_0000_1000 };

        _sensor.Write(dataFormat);
        _sensor.Write(powerControl);
    }

    /// &amp;lt;summary&amp;gt;
    /// 读取加速度
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;加速度&amp;lt;/returns&amp;gt;
    private Vector3 ReadAcceleration()
    {
        int units = Resolution / _range;

        // 7 = 1个地址 + 3轴数据（每轴数据2字节）
        Span&amp;lt;byte&amp;gt; writeBuffer = stackalloc byte[7];
        Span&amp;lt;byte&amp;gt; readBuffer = stackalloc byte[7];

        writeBuffer[0] = ADLX_X0;
        _sensor.TransferFullDuplex(writeBuffer, readBuffer);
        Span&amp;lt;byte&amp;gt; readData = readBuffer.Slice(1);      // 切割空白数据

        // 将小端数据转换成正常的数据
        short AccelerationX = BinaryPrimitives.ReadInt16LittleEndian(readData.Slice(0, 2));
        short AccelerationY = BinaryPrimitives.ReadInt16LittleEndian(readData.Slice(2, 2));
        short AccelerationZ = BinaryPrimitives.ReadInt16LittleEndian(readData.Slice(4, 2));

        Vector3 accel = new Vector3
        {
            X = (float)AccelerationX / units,
            Y = (float)AccelerationY / units,
            Z = (float)AccelerationZ / units
        };

        return accel;
    }

    /// &amp;lt;summary&amp;gt;
    /// 释放资源
    /// &amp;lt;/summary&amp;gt;
    public void Dispose()
    {
        _sensor?.Dispose();
        _sensor = null;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;在 &lt;strong&gt;Program.cs&lt;/strong&gt; 中，将主函数代码替换如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;static void Main(string[] args)
{
    SpiConnectionSettings settings = new SpiConnectionSettings(busId: 0, chipSelectLine: 0)
    {
        ClockFrequency = Adxl345.SpiClockFrequency,
        Mode = Adxl345.SpiMode
    };
    UnixSpiDevice device = new UnixSpiDevice(settings);

    using (Adxl345 sensor = new Adxl345(device))
    {
        while (true)
        {
            Vector3 data = sensor.Acceleration;

            Console.WriteLine($&quot;X: {data.X.ToString(&quot;0.00&quot;)} g&quot;);
            Console.WriteLine($&quot;Y: {data.Y.ToString(&quot;0.00&quot;)} g&quot;);
            Console.WriteLine($&quot;Z: {data.Z.ToString(&quot;0.00&quot;)} g&quot;);
            Console.WriteLine();

            Thread.Sleep(500);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;发布、拷贝、更改权限、运行&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;效果图&quot;&gt;效果图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1085877/201905/1085877-20190529144743318-1345090585.jpg&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;  备注&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一篇文章将谈谈 PWM 的使用。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 29 May 2019 06:49:00 +0000</pubDate>
<dc:creator>张高兴</dc:creator>
<og:description>什么是 SPI 和上一篇文章的 I2C 总线一样，SPI（Serial Peripheral Interface，串行外设接口）也是设备与设备间通信方式的一种。SPI 是一种全双工（数据可以两个方向同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanggaoxing/p/10943822.html</dc:identifier>
</item>
<item>
<title>大型网站架构演化发展历程 - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/10943743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/10943743.html</guid>
<description>&lt;h2 id=&quot;一大型网站系统的特点&quot;&gt;一、大型网站系统的特点&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;高并发，大流量&lt;/code&gt;: 需要面对高并发用户，大流量访问，Google日均PV数为35亿，日均IP访问数为3亿，2011年腾讯QQ最大用户在线数1.4亿，淘宝2012年双11活动一天交易额191亿，活动开始第一分钟独立访问用户达1000万&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;&lt;strong&gt;拓展: PV、UV、IV的概念&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PV: PV访问量（Page View），即页面访问量，每打开一次页面PV计数+1，刷新页面也是。&lt;/p&gt;
&lt;p&gt;UV: UV访问数（Unique Visitor）指独立访客访问数，一台电脑终端为一个访客。&lt;/p&gt;
&lt;p&gt;IV: IV是IP访问数指独立IP访问数，计算是以一个独立的IP在一个计算时段内访问网站计算为1次IP访问数。在同一个计算时段内不管这个IP访问多少次均计算为1次。计算时段有以1天为一个计算时段，也有以1个小时为一个计算时段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;高可用&lt;/code&gt;: 7 * 24小时不间断提供服务。大型网站的宕机一般会成为焦点，例如2010年百度域名被黑客劫持事件，双11淘宝宕机事件，12306网站并发数过高的宕机事件，微博流量明星宕机事件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144244956-1528301606.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;海量数据&lt;/code&gt;： 需要存储管理海量的数据，同时需要大量服务器，Facebook 每周上传的照片数目接近10亿，百度收录的网站有百亿，Google有接近百万台服务器为全球用户提供服务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;用户分布广泛，网络情况复杂&lt;/code&gt;：许多大型互联网公司都是为全球用户提供服务，各地网络情况千差万别，在国内，还有各个运营商网络互通难的问题，而中美光缆的数次故障，也让很多互联网公司不得不考虑在海外建立数据中心。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;安全环境恶劣&lt;/code&gt;: 由于互联网的开放性，使大型互联网公司更易遭到黑客的攻击，例如facebook用户泄漏事件。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144307724-1697393192.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;需求快速变更，发布频繁&lt;/code&gt;: 和传统的企业级应用不同，互联网公司为快速适应市场，满足用户需求，其产品发布频率是极高的。至于中小型互联网公司的发布频率，那就更高了，有时候一天会发布十几次&lt;/p&gt;
&lt;p&gt;&lt;code&gt;渐进式发展&lt;/code&gt;: 与传统行业一开始规划好全部的功能和非功能的需求不同，很多大型互联网公司都是从小公司开始做起，渐进的发展起来的。Facebook的创始人扎克伯克在哈佛的宿舍开发出来的，阿里巴巴是诞生在马云家的客厅的，好的互联网产品都是迭代出来的，不是一开始就发展的很好的。&lt;/p&gt;
&lt;h2 id=&quot;二大型网站的演变过程&quot;&gt;二、大型网站的演变过程&lt;/h2&gt;
&lt;h3 id=&quot;初始阶段的网站架构&quot;&gt;1. 初始阶段的网站架构&lt;/h3&gt;
&lt;p&gt;​ 大型网站都是从小型网站发展起来的，网站架构也是一样，网站刚开始搭建处于雏形阶段，访问量小，一台服务器完全够用，也是大部分企业级应用的选择&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529143950768-758670624.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;应用程序，数据库，文件都部署在一台服务器的，通常服务器选用Linux，应用程序选用PHP，然后部署在Apache 上，数据库使用MySQL，汇集各种开源软件以及一架廉价的服务器就可以进行开发&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;应用服务和数据分离&quot;&gt;2. 应用服务和数据分离&lt;/h3&gt;
&lt;p&gt;​ 随着业务的发展，一台服务器不能满足业务需求：越来越多的用户访问导致性能越来越差，越来越多的数据导致服务器存储空间不足，这就需要将应用和数据分离。应用和数据分离后整个网站使用三台服务器，应用服务器，文件服务器，数据库服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144007280-797591565.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;应用和数据分离后，不同特性的服务器承担不同的服务角色，网站的并发处理能力和数据存储都得到了很大的改善，支持业务的进一步发展。但是随着业务的增多，访问量增大，网站又一次面临挑战，数据库压力太多导致访问延迟，进而影响整个网站的性能，用户体验收到影响&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用缓存改善网站性能&quot;&gt;3. 使用缓存改善网站性能&lt;/h3&gt;
&lt;p&gt;​ 网站访问特点和现实世界的财富分配通常符合二八定律: 80%的业务访问集中在20% 的数据上，淘宝买家浏览的商品集中在少部分成交数多、评价良好的商品上；百度搜索的关键词集中在少部分热门词汇上，搜索出来的词条你也会浏览前两页的内容。&lt;/p&gt;
&lt;p&gt;​ 既然大部分的浏览都只会放在一小部分数据上，那么是否能把这些数据缓存起来放在内存中，是不是就可以减少数据库的压力，从而提高整个网站的数据访问速度，改善数据库的写入性能了呢？&lt;/p&gt;
&lt;p&gt;​ 网站的缓存分为&lt;code&gt;两种&lt;/code&gt;： 缓存在&lt;code&gt;本地服务器&lt;/code&gt;上的本地缓存，缓存在&lt;code&gt;远程服务器&lt;/code&gt;上的远程缓存，本地缓存的访问速度要比远程缓存的更快。但是受应用服务器的内存限制，往往会存在本地缓存和应用程序竞争内存的情况，这种情况在&lt;code&gt;远程服务器&lt;/code&gt;上就不会存在，远程分布式缓存可以使用集群的方式，部署大内存的服务器使用专门的缓存服务器，理论上可以做到不受内存限制的缓存服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144019692-1056009028.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;使用缓存后，有效的改善了数据库访问的压力，但是单一应用程序的服务器能够处理的连接有限，在网站访问的高峰期间，应用服务器会成为网站的瓶颈&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用应用服务器集群改善网站的并发处理能力&quot;&gt;4. 使用应用服务器集群改善网站的并发处理能力&lt;/h3&gt;
&lt;p&gt;​ 使用集群是解决高并发，海量数据问题的关键手段，当一台服务器的处理能力、存储空间不足的时候，不要尝试去更换一台存储量更大的服务器，而是考虑&lt;code&gt;集群&lt;/code&gt;部署，因为对于大型网站而言，不管多么强大的服务器，都满足不了网站持续增长的业务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144031751-1667104631.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;应用服务器集群部署，使用负载均衡服务器做负载控制，能够改善流量峰值对应用服务器的压力，避免单一服务器承担更多的请求压力。如果还有更多的请求，那么就在现有的基础上增加更多的应用服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据库读写分离&quot;&gt;5. 数据库读写分离&lt;/h3&gt;
&lt;p&gt;​ 使用缓存后，能够改善一部分的数据库访问压力，使绝大多数数据读操作访问不用通过数据库就能完成，但是仍有一部分读(缓存访问不命中，缓存过期)和全部的写操作都会直接访问数据库，在网站到达一定的规模后，也会增大数据库的压力&lt;/p&gt;
&lt;p&gt;​ 目前大部分主流数据库都提供主从热备功能，通过配置两台数据库搭建&lt;code&gt;主从&lt;/code&gt;关系，可以将一台数据库服务器的数据&lt;code&gt;更新同步&lt;/code&gt;到另一台服务器上，网站可以利用这一特性，实现数据库的&lt;code&gt;读写分离&lt;/code&gt;的功能，从而改善数据库的压力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144041852-300208556.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;应用在写数据的时候，访问主服务器，在读数据的时候，访问从服务器，主数据库通过主从复制的功能将数据同步更新到从服务器，这样当有读操作的时候，就会直接访问从服务器，当有写操作的时候，会直接访问主服务器，为了便于应用程序访问读写分离后的数据库，通常在应用服务器端使用专门的数据访问模块，使数据库读写分离对应用透明&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用反向代理和cdn加速网站响应&quot;&gt;6. 使用反向代理和CDN加速网站响应&lt;/h3&gt;
&lt;p&gt;​ 随着网站规模不断扩大，用户规模越来越大，由于国内网络情况复杂，不同地区的用户访问网站时，速度差别也极大。有研究表明，网站访问延迟和用户流失率正相关，网站访问越慢，用户的流失率越快，所以为了更好的用户体验，留住用户，网站需要更快的访问速度，主要手段有使用CDN和反向代理&lt;/p&gt;
&lt;p&gt;​ CDN和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从&lt;code&gt;距离自己最近&lt;/code&gt;的机房获取数据；而CDN则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器是&lt;code&gt;反向代理服务器&lt;/code&gt;，如果反向代理服务器缓存着资源，就会直接返回给用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144051553-1180308196.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;使用CDN的目的都是尽早返回数据给用户，一方面能够加快访问速度，一方面都能减轻服务器的压力&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用分布式文件系统和分布式数据库系统&quot;&gt;7. 使用分布式文件系统和分布式数据库系统&lt;/h3&gt;
&lt;p&gt;​ 任何强大的单一服务器都满足不了大型网站持续增长的业务需求。数据库经过读写分离后，从一台服务器拆分成两台服务器，但是随着网站业务的发展不能满足业务的需求，需要使用&lt;code&gt;分布式的存储服务器&lt;/code&gt;，文件系统能够也是一样，需要使用分布式文件系统。&lt;/p&gt;
&lt;p&gt;​ 分布式数据库是网站数据库拆分的重要手段，只有在单表数据非常庞大的时候才使用。不到不得已时，网站最常用的数据库拆分手段是业务分库。将不同业务的数据部署在不同的服务器上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144104068-477535997.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用nosql和搜索引擎&quot;&gt;8. 使用NoSQL和搜索引擎&lt;/h3&gt;
&lt;p&gt;​ 随着网站业务的扩大，对数据存储和检索的要求也越来越高，网站需要采用一些非关系型数据库技术如NoSQL和非数据库查询技术和搜索引擎&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144112727-1662714750.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;NoSQL和搜索引擎都是源自互联网的技术手段，对可伸缩的分布式特性具有更好的支持。应用服务器则通过一个统一数据访问模块访问各种数据。减轻应用程序管理诸多数据源的麻烦&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;业务拆分&quot;&gt;9. 业务拆分&lt;/h3&gt;
&lt;p&gt;​ 大型网站为了应对日益繁杂的业务场景，通过使用分而治之的方式将整个网站的业务拆分成不同的产品线，如大型购物交易网站就会将首页、商铺、订单、买家、卖家等拆分成不同的产品线，分归不同的业务部门负责管理。&lt;/p&gt;
&lt;p&gt;​ 具体到技术上，也会根据产品线划分产品，将一个产品拆分成不同的应用。每个应用独立部署和维护，应用之间可以通过超链接简历关系，也可以通过&lt;code&gt;消息队列&lt;/code&gt;进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144203971-73726470.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;分布式服务&quot;&gt;10. 分布式服务&lt;/h3&gt;
&lt;p&gt;​ 随着业务拆分越来越小，存储系统越来越大，应用系统的整体复杂度呈指数增长，部署越来越困难。由于所有的应用都要和数据库系统连接。在数万台服务器规模的网站中，这些连接的数目是服务器规模的平方。导致存数据库连接资源不足。拒绝服务。&lt;/p&gt;
&lt;p&gt;​ 既然每一个应用系统都需要执行许多相同的业务操作，可以把&lt;code&gt;相同的&lt;/code&gt;业务提取出来。由这些可服用的业务连接数据库。提供公用业务服务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201905/1515111-20190529144213421-1925646786.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;大型网站演化到这里，基本上大多数的技术问题都可以解决，诸如跨数据中心的实时数据同步和具体网站业务相关的问题都可以通过组合改进现有的技术架构来解决。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三大型网站架构演化的价值观&quot;&gt;三、大型网站架构演化的价值观&lt;/h2&gt;
&lt;h3 id=&quot;大型网站架构技术的核心价值是随网站所需灵活应对&quot;&gt;1. 大型网站架构技术的核心价值是随网站所需灵活应对&lt;/h3&gt;
&lt;p&gt;​ &lt;code&gt;大型网站&lt;/code&gt;架构技术的核心价值不是&lt;code&gt;从无到有&lt;/code&gt;搭建一个大型的网站，而是能够伴随小型网站业务的逐步发展，慢慢演化成一个大型网站。在这个过程中，不需要放弃什么，不需要推翻什么，技术选型都是非常重要的，所有的大公司例如FaceBook、Google、淘宝无不遵循这样一条发展路线&lt;/p&gt;
&lt;h3 id=&quot;驱动大型网站技术发展的主要力量是网站业务的发展&quot;&gt;2. 驱动大型网站技术发展的主要力量是网站业务的发展&lt;/h3&gt;
&lt;p&gt;​ 创新的业务发展模式对网站架构提出了更高的要求，才使得创新的网站架构得以发展成熟。是业务成就了技术，是事业成就了人。而不是相反。&lt;/p&gt;
&lt;h2 id=&quot;四网站架构设计误区&quot;&gt;四、网站架构设计误区&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 盲目追随大公司的解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 为了技术而技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.企图用技术解决所有问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章来源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;《大型网站技术架构：核心原理与案例分析》&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 06:39:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>[TOC] 一、大型网站系统的特点 : 需要面对高并发用户，大流量访问，Google日均PV数为35亿，日均IP访问数为3亿，2011年腾讯QQ最大用户在线数1.4亿，淘宝2012年双11活动一天交易</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/10943743.html</dc:identifier>
</item>
<item>
<title>机器学习框架ML.NET学习笔记【1】基本概念 - seabluescn</title>
<link>http://www.cnblogs.com/seabluescn/p/10904391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seabluescn/p/10904391.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、序言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       微软的机器学习框架于2018年5月出了0.1版本，2019年5月发布1.0版本。期间各版本之间差异（包括命名空间、方法等）还是比较大的，随着1.0版发布，应该是趋于稳定了。之前在园子里也看到不少相关介绍的文章，对我的学习提供了不少帮助。由于目前资料不是很丰富，所以学习过程中也走了不少弯路，本系列的文章主要记录我学习过程中的一些心得体会，并对一些细节会做详细的解释，希望能为机器学习零基础的同学提供一些帮助。（C#零基础可不行）&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、基本概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、什么是机器学习？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;定义：一个电脑程序要完成任务（T），如果电脑获取的关于T的经验（E）越多就表现（P）得越好，那么我们就可以说这个程序‘学习’了关于T的经验。&lt;/p&gt;
&lt;p&gt;简单解释什么叫“机器的学习”：如果输入的经验越多表现的越好，这就叫“学习”。举个例子：传统的程序逻辑是基于算法的，在算法不变的情况下，程序就是运行100年能力也不会有提升，但机器学习是基于数据（样本）的，在算法不变的情况下，累计的有效数据越多，程序表现能力就越强。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、通过机器学习解决问题和传统算法解决问题的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;需要解决的问题：会议室进来一位男生，请他站在摄像头前面，通过一个程序评价一下这位男生身材是否很好。&lt;/p&gt;
&lt;p&gt;（1）传统解决方案&lt;/p&gt;
&lt;p&gt;  首先我们分析要判断一个人身材是否很好，主要的判断特征包括：身高、体重、三围等等，然后通过一个衡量算法（比如BMI）进行计算，流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190522104124903-631853871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（2）机器学习算法&lt;/p&gt;
&lt;p&gt;   机器学习是依赖样本数据的，所以解决这个问题的思路是这样的：&lt;/p&gt;
&lt;p&gt;①首先你得上街去收集数据，询问你采访对象的身高、体重、三围数据，然后根据你的经验给他一个评判，形成下表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190522105441774-1744414886.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②对收集到的数据进行训练，形成模型，然后通过模型对要判断的对象进行评判。流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/18393/201905/18393-20190522105859737-1960584302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;小结：通过这个问题的解决，感觉通过机器学习来解决问题比传统方法麻烦多了，是的，对于身材判断这样的问题，人类可以很简单找到一个逻辑分析的方法，所以通过逻辑算法解决就比较方便，但有时候很多事情我们人类是很容易处理的，但我们却不知道其中的逻辑，比如：判断一张图片是否是18+图片，判断一片论文是否写得很好，判断一个人是否长得漂亮等等。这些问题人类很轻松就能处理，但无法总结出其中的规律并交给机器去执行，这时候机器学习算法就可以派上用场了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 三、机器学习的流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 机器学习的流程如下：&lt;/p&gt;
&lt;p&gt;数据准备 -&amp;gt; 建模 -&amp;gt; 训练 -&amp;gt; 评估 -&amp;gt; 应用&lt;br/&gt;在实际应用时，由于训练的过程可能时间比较长，所以我们会分两个阶段进行：&lt;br/&gt;1、学习阶段：数据准备 -&amp;gt; 建模 -&amp;gt; 训练 -&amp;gt; 评估 -&amp;gt; 保存模型&lt;br/&gt;2、消费阶段：读取模型 -&amp;gt; 应用&lt;/p&gt;
&lt;p&gt;评估的过程就是对模型的检验，我们一般会把样本数据随机分成两份，其中一部分用来学习，另一部分用来检验模型效果，判断一下我们的模型能力。&lt;/p&gt;

&lt;p&gt;以上是涉及到机器学习的有些最基础的理论知识，下面几篇文章会由浅入深介绍ML.NET的一些应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系列文章目录：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;机器学习框架ML.NET学习笔记【1】基本概念&lt;/p&gt;
&lt;p&gt;机器学习框架ML.NET学习笔记【2】入门之二元分类&lt;/p&gt;
&lt;p&gt;机器学习框架ML.NET学习笔记【3】文本特征分析&lt;/p&gt;
&lt;p&gt;机器学习框架ML.NET学习笔记【4】手写数字识别&lt;/p&gt;
&lt;p&gt;机器学习框架ML.NET学习笔记【5】手写数字识别（续）&lt;/p&gt;
&lt;p&gt;机器学习框架ML.NET学习笔记【6】TensorFlow图片分类&lt;/p&gt;
&lt;p&gt;机器学习框架ML.NET学习笔记【7】人物图片颜值判断&lt;/p&gt;
&lt;p&gt;机器学习框架ML.NET学习笔记【8】目标检测&lt;/p&gt;
&lt;p&gt;机器学习框架ML.NET学习笔记【9】自动学习&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;资源下载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目源码：https://github.com/seabluescn/Study_ML.NET&lt;/p&gt;
&lt;p&gt;资源文件：https://gitee.com/seabluescn/ML_Assets&lt;/p&gt;
&lt;p&gt;（由于资源文件较大，所以放在码云平台提供下载）&lt;/p&gt;

</description>
<pubDate>Wed, 29 May 2019 06:07:00 +0000</pubDate>
<dc:creator>seabluescn</dc:creator>
<og:description>微软的机器学习框架于2018年5月出了0.1版本，2019年5月发布1.0版本。期间各版本之间差异（包括命名空间、方法等）还是比较大的，随着1.0版发布，应该是趋于稳定了。之前在园子里也看到不少相关介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/seabluescn/p/10904391.html</dc:identifier>
</item>
<item>
<title>RabbitMQ使用教程（三）如何保证消息99.99%被发送成功？ - 周伟伟的博客</title>
<link>http://www.cnblogs.com/zwwhnly/p/10943340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwwhnly/p/10943340.html</guid>
<description>&lt;h2 id=&quot;前情回顾&quot;&gt;1. 前情回顾&lt;/h2&gt;
&lt;blockquote readability=&quot;0.052287581699346&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zwwhnly/p/10911926.html&quot;&gt;RabbitMQ使用教程（一）RabbitMQ环境安装配置及Hello World示例&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zwwhnly/p/10918665.html&quot;&gt;RabbitMQ使用教程（二）RabbitMQ用户管理,角色管理及权限设置&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在以上两篇博客发布后不久，有细心的网友就评论，创建的队列和发送的消息，如果在没有启动消费者程序的时候，重启了RabbitMQ服务，队列和消息都丢失了。&lt;/p&gt;
&lt;p&gt;这就引出了一个非常重要的问题，也是面试中经常会问的：&lt;strong&gt;在使用RabbitMQ时，如何保证消息最大程度的不丢失并且被正确消费？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;本篇概要&quot;&gt;2. 本篇概要&lt;/h2&gt;
&lt;p&gt;RabbitMQ针对这个问题，提供了以下几个机制来解决：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生产者确认&lt;/li&gt;
&lt;li&gt;持久化&lt;/li&gt;
&lt;li&gt;手动Ack&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本篇博客我们先讲解下生产者确认机制，剩余的机制后续单独写博客进行讲解。&lt;/p&gt;
&lt;h2 id=&quot;生产者确认&quot;&gt;3. 生产者确认&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;要想保证消息不丢失，首先我们得保证生产者能成功的将消息发送到RabbitMQ服务器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但在之前的示例中，当生产者将消息发送出去之后，消息到底有没有正确地到达服务器呢？如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何消息给生产者的，也就是默认情况下生产者是不知道消息有没有正确的到达服务器。&lt;/p&gt;
&lt;p&gt;从basicPublish方法的返回类型我们也能知晓：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException {
    this.basicPublish(exchange, routingKey, false, props, body);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了更好理解，我们将之前的生产者Producer类中的&lt;code&gt;channel.queueDeclare(QUEUE_NAME, false, false, false, null);&lt;/code&gt;注释：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zwwhnly.springbootaction.rabbitmq.helloworld;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class Producer {
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws IOException, TimeoutException {
        // 创建连接
        ConnectionFactory factory = new ConnectionFactory();
        // 设置 RabbitMQ 的主机名
        factory.setHost(&quot;localhost&quot;);
        // 创建一个连接
        Connection connection = factory.newConnection();
        // 创建一个通道
        Channel channel = connection.createChannel();
        // 指定一个队列,不存在的话自动创建
        //channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        // 发送消息
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
        System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);
        // 关闭频道和连接
        channel.close();
        connection.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时运行代码，因为队列不存在，消息肯定没地方存储，但是程序却并未出错，也就是消息丢失了但是我们却并不知晓。&lt;/p&gt;
&lt;p&gt;RabblitMQ针对这个问题，提供了两种解决方案：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过事务机制实现&lt;/li&gt;
&lt;li&gt;通过发送方确认（publisher confirm）机制实现&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;事务机制&quot;&gt;4. 事务机制&lt;/h2&gt;
&lt;p&gt;RabblitMQ客户端中与事务机制相关的方法有以下3个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;channel.txSelect：用于将当前的信道设置成事务模式&lt;/li&gt;
&lt;li&gt;channel.txCommit：用于提交事务&lt;/li&gt;
&lt;li&gt;channel.txRollback：用于回滚事务&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;新建事务生产者类TransactionProducer，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zwwhnly.springbootaction.rabbitmq.producerconfirm;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class TransactionProducer {
    private final static String QUEUE_NAME = &quot;hello&quot;;

    public static void main(String[] args) throws IOException, TimeoutException {
        // 创建连接
        ConnectionFactory factory = new ConnectionFactory();
        // 设置 RabbitMQ 的主机名
        factory.setHost(&quot;localhost&quot;);
        // 创建一个连接
        Connection connection = factory.newConnection();
        // 创建一个通道
        Channel channel = connection.createChannel();
        // 指定一个队列,不存在的话自动创建
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);

        channel.txSelect();

        // 发送消息
        String message = &quot;Hello World!&quot;;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());

        channel.txCommit();
        System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);

        // 关闭频道和连接
        channel.close();
        connection.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行代码，发现队列新增成功，消息发送成功：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201905/424537-20190528154020878-2021735016.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稍微修改下代码，看下异常机制的事务回滚：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;try {
    channel.txSelect();

    // 发送消息
    String message = &quot;Hello World!&quot;;
    channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());

    int result = 1 / 0;

    channel.txCommit();
    System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);
} catch (IOException e) {
    e.printStackTrace();
    channel.txRollback();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;int result = 1 / 0;&lt;/code&gt;肯定会触发java.lang.ArithmeticException异常，所以事务会回滚，消息发送失败：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201905/424537-20190528154553858-399928896.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要发送多条消息，可以将channel.basicPublish,channel.txCommit等方法放在循环体内，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;channel.txSelect();
int loopTimes = 10;

for (int i = 0; i &amp;lt; loopTimes; i++) {
    try {
        // 发送消息
        String message = &quot;Hello World!&quot; + i;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());

        channel.txCommit();
        System.out.println(&quot; [x] Sent '&quot; + message + &quot;'&quot;);
    } catch (IOException e) {
        e.printStackTrace();
        channel.txRollback();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然事务能够解决消息发送方和RabbitMQ之间消息确认的问题，只有消息成功被RabbitMQ接收，事务才能提交成功，否则便可在捕获异常之后进行事务回滚。但是使用事务机制会“吸干”RabbitMQ的性能，因此建议使用下面讲到的发送方确认机制。&lt;/p&gt;
&lt;h2 id=&quot;发送方确认机制&quot;&gt;5. 发送方确认机制&lt;/h2&gt;
&lt;p&gt;发送方确认机制是指生产者将信道设置成confirm（确认）模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到RabbitMQ服务器之后，RabbitMQ就会发送一个确认（Basic.Ack）给生产者（包含消息的唯一ID），这就使得生产者知晓消息已经正确到达了目的地了。&lt;/p&gt;
&lt;p&gt;如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack（Basic.Nack）命令，生产者应用程序同样可以在回调方法中处理该nack指令。&lt;/p&gt;
&lt;p&gt;如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。&lt;/p&gt;
&lt;p&gt;事务机制在一条消息发送之后会使发送端阻塞，以等待RabbitMQ的回应，之后才能继续发送下一条消息。&lt;/p&gt;
&lt;p&gt;相比之下，发送方确认机制最大的好处在于它是异步的，一旦发布一条消息。生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认后，生产者应用程序便可以通过回调方法来处理该确认消息。&lt;/p&gt;
&lt;h4 id=&quot;普通confirm&quot;&gt;5.1 普通confirm&lt;/h4&gt;
&lt;p&gt;新建确认生产类NormalConfirmProducer，代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zwwhnly.springbootaction.rabbitmq.producerconfirm;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.TimeoutException;

public class NormalConfirmProducer {
    private final static String EXCHANGE_NAME = &quot;normal-confirm-exchange&quot;;

    public static void main(String[] args) throws IOException, TimeoutException {
        // 创建连接
        ConnectionFactory factory = new ConnectionFactory();
        // 设置 RabbitMQ 的主机名
        factory.setHost(&quot;localhost&quot;);
        // 创建一个连接
        Connection connection = factory.newConnection();
        // 创建一个通道
        Channel channel = connection.createChannel();
        // 创建一个Exchange
        channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);


        try {
            channel.confirmSelect();
            // 发送消息
            String message = &quot;normal confirm test&quot;;
            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
            if (channel.waitForConfirms()) {
                System.out.println(&quot;send message success&quot;);
            } else {
                System.out.println(&quot;send message failed&quot;);
                // do something else...
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 关闭频道和连接
        channel.close();
        connection.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;channel.confirmSelect();将信道设置成confirm模式。&lt;/p&gt;
&lt;p&gt;channel.waitForConfirms();等待发送消息的确认消息，如果发送成功，则返回ture，如果发送失败，则返回false。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果要发送多条消息，可以将channel.basicPublish,channel.waitForConfirms等方法放在循环体内，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;channel.confirmSelect();
int loopTimes = 10;

for (int i = 0; i &amp;lt; loopTimes; i++) {
    try {
        // 发送消息
        String message = &quot;normal confirm test&quot; + i;
        channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
        if (channel.waitForConfirms()) {
            System.out.println(&quot;send message success&quot;);
        } else {
            System.out.println(&quot;send message failed&quot;);
            // do something else...
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;p&gt;send message success&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果不开启信道的confirm模式，调用channel.waitForConfirms()会报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201905/424537-20190528171100608-669943480.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1)事务机制和publisher confirm机制是互斥的，不能共存。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果企图将已开启事务模式的信道再设置为publisher confirm模式，RabbitMQ会报错：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;channel.txSelect();
channel.confirmSelect();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201905/424537-20190528172529418-411348559.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果企图将已开启publisher confirm模式的信道再设置为事务模式，RabbitMQ也会报错：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;channel.confirmSelect();
channel.txSelect();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/424537/201905/424537-20190528172837634-1849410565.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2)事务机制和publisher confirm机制确保的是消息能够正确地发送至RabbitMQ，这里的“发送至RabbitMQ”的含义是指消息被正确地发往至RabbitMQ的交换器，如果此交换器没有匹配的队列，那么消息也会丢失。所以在使用这两种机制的时候要确保所涉及的交换器能够有匹配的队列。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如上面的NormalConfirmProducer类发送的消息，发送到了交换器normal-confirm-exchange，但是该交换器并没有绑定任何队列，从业务角度来讲，消息仍然是丢失了。&lt;/p&gt;
&lt;p&gt;普通confirm模式是每发送一条消息后就调用channel.waitForConfirms()方法，之后等待服务端的确认，这实际上是一种串行同步等待的方式。因此相比于事务机制，性能提升的并不多。&lt;/p&gt;
&lt;h4 id=&quot;批量confirm&quot;&gt;5.2 批量confirm&lt;/h4&gt;
&lt;p&gt;批量confirm模式是每发送一批消息后，调用channel.waitForConfirms()方法，等待服务器的确认返回，因此相比于5.1中的普通confirm模式，性能更好。&lt;/p&gt;
&lt;p&gt;但是不好的地方在于，如果出现返回Basic.Nack或者超时情况，生产者客户端需要将这一批次的消息全部重发，这样会带来明显的重复消息数量，如果消息经常丢失，批量confirm模式的性能应该是不升反降的。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zwwhnly.springbootaction.rabbitmq.producerconfirm;

import com.rabbitmq.client.Channel;
import com.rabbitmq.client.Connection;
import com.rabbitmq.client.ConnectionFactory;

import java.io.IOException;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeoutException;

public class BatchConfirmProducer {
    private final static String EXCHANGE_NAME = &quot;batch-confirm-exchange&quot;;

    public static void main(String[] args) throws IOException, TimeoutException {
        // 创建连接
        ConnectionFactory factory = new ConnectionFactory();
        // 设置 RabbitMQ 的主机名
        factory.setHost(&quot;localhost&quot;);
        // 创建一个连接
        Connection connection = factory.newConnection();
        // 创建一个通道
        Channel channel = connection.createChannel();
        // 创建一个Exchange
        channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);

        int batchCount = 100;
        int msgCount = 0;
        BlockingQueue blockingQueue = new ArrayBlockingQueue(100);
        try {
            channel.confirmSelect();
            while (msgCount &amp;lt;= batchCount) {
                String message = &quot;batch confirm test&quot;;
                channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
                // 将发送出去的消息存入缓存中，缓存可以是一个ArrayList或者BlockingQueue之类的
                blockingQueue.add(message);
                if (++msgCount &amp;gt;= batchCount) {
                    try {
                        if (channel.waitForConfirms()) {
                            // 将缓存中的消息清空
                            blockingQueue.clear();
                        } else {
                            // 将缓存中的消息重新发送
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        // 将缓存中的消息重新发送
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 关闭频道和连接
        channel.close();
        connection.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;异步confirm&quot;&gt;5.3 异步confirm&lt;/h4&gt;
&lt;p&gt;异步confirm模式是在生产者客户端添加ConfirmListener回调接口，重写接口的handAck()和handNack()方法，分别用来处理RabblitMQ回传的Basic.Ack和Basic.Nack。&lt;/p&gt;
&lt;p&gt;这两个方法都有两个参数，第1个参数deliveryTag用来标记消息的唯一序列号，第2个参数multiple表示的是是否为多条确认,值为true代表是多个确认，值为false代表是单个确认。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.zwwhnly.springbootaction.rabbitmq.producerconfirm;

import com.rabbitmq.client.*;

import java.io.IOException;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.concurrent.TimeoutException;

public class AsyncConfirmProducer {

    private final static String EXCHANGE_NAME = &quot;async-confirm-exchange&quot;;

    public static void main(String[] args) throws IOException, TimeoutException {
        // 创建连接
        ConnectionFactory factory = new ConnectionFactory();
        // 设置 RabbitMQ 的主机名
        factory.setHost(&quot;localhost&quot;);
        // 创建一个连接
        Connection connection = factory.newConnection();
        // 创建一个通道
        Channel channel = connection.createChannel();
        // 创建一个Exchange
        channel.exchangeDeclare(EXCHANGE_NAME, &quot;direct&quot;);

        int batchCount = 100;
        long msgCount = 1;
        SortedSet&amp;lt;Long&amp;gt; confirmSet = new TreeSet&amp;lt;Long&amp;gt;();
        channel.confirmSelect();
        channel.addConfirmListener(new ConfirmListener() {
            @Override
            public void handleAck(long deliveryTag, boolean multiple) throws IOException {
                System.out.println(&quot;Ack,SeqNo：&quot; + deliveryTag + &quot;,multiple：&quot; + multiple);
                if (multiple) {
                    confirmSet.headSet(deliveryTag - 1).clear();
                } else {
                    confirmSet.remove(deliveryTag);
                }
            }

            @Override
            public void handleNack(long deliveryTag, boolean multiple) throws IOException {
                System.out.println(&quot;Nack,SeqNo：&quot; + deliveryTag + &quot;,multiple：&quot; + multiple);
                if (multiple) {
                    confirmSet.headSet(deliveryTag - 1).clear();
                } else {
                    confirmSet.remove(deliveryTag);
                }
                // 注意这里需要添加处理消息重发的场景
            }
        });
        // 演示发送100个消息
        while (msgCount &amp;lt;= batchCount) {
            long nextSeqNo = channel.getNextPublishSeqNo();
            channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, &quot;async confirm test&quot;.getBytes());
            confirmSet.add(nextSeqNo);
            msgCount = nextSeqNo;
        }

        // 关闭频道和连接
        channel.close();
        connection.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;blockquote readability=&quot;43&quot;&gt;
&lt;p&gt;Ack,SeqNo：1,multiple：false&lt;/p&gt;
&lt;p&gt;Ack,SeqNo：2,multiple：false&lt;/p&gt;
&lt;p&gt;Ack,SeqNo：3,multiple：false&lt;/p&gt;
&lt;p&gt;Ack,SeqNo：4,multiple：false&lt;/p&gt;
&lt;p&gt;Ack,SeqNo：5,multiple：false&lt;/p&gt;
&lt;p&gt;Ack,SeqNo：6,multiple：false&lt;/p&gt;
&lt;p&gt;Ack,SeqNo：7,multiple：false&lt;/p&gt;
&lt;p&gt;Ack,SeqNo：8,multiple：false&lt;/p&gt;
&lt;p&gt;Ack,SeqNo：9,multiple：false&lt;/p&gt;
&lt;p&gt;Ack,SeqNo：10,multiple：false&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：多次运行，发现每次运行的输出结果是不一样的，说明RabbitMQ端回传给生产者的ack消息并不是以固定的批量大小回传的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;性能比较&quot;&gt;6. 性能比较&lt;/h2&gt;
&lt;p&gt;到目前为止，我们了解到4种模式（事务机制，普通confirm，批量confirm，异步confirm）可以实现生产者确认，让我们来对比下它们的性能，简单修改下以上示例代码中发送消息的数量，比如10000条，以下为4种模式的耗时：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;发送10000条消息,事务机制耗时：2103&lt;/p&gt;
&lt;p&gt;发送10000条消息,普通confirm机制耗时：1483&lt;/p&gt;
&lt;p&gt;发送10000条消息,批量confirm机制耗时：281&lt;/p&gt;
&lt;p&gt;发送10000条消息,异步confirm机制耗时：214&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以看出，事务机制最慢，普通confirm机制虽有提升但是不多，批量confirm和异步confirm性能最好，大家可以根据自己喜好自行选择使用哪种机制，个人建议使用异步confirm机制。&lt;/p&gt;
&lt;h2 id=&quot;源码&quot;&gt;7. 源码&lt;/h2&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/zwwhnly/springboot-action.git&quot; class=&quot;uri&quot;&gt;https://github.com/zwwhnly/springboot-action.git&lt;/a&gt;，欢迎下载。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;8. 参考&lt;/h2&gt;
&lt;p&gt;《RabbitMQ实战指南》&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 05:37:00 +0000</pubDate>
<dc:creator>周伟伟的博客</dc:creator>
<og:description>1. 前情回顾 'RabbitMQ使用教程（一）RabbitMQ环境安装配置及Hello World示例' 'RabbitMQ使用教程（二）RabbitMQ用户管理,角色管理及权限设置' 在以上两篇博</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zwwhnly/p/10943340.html</dc:identifier>
</item>
<item>
<title>关于PCA降维中遇到的python问题小结 - hezzzzzzz</title>
<link>http://www.cnblogs.com/hezhuoheng/p/10942258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hezhuoheng/p/10942258.html</guid>
<description>&lt;p&gt;由于论文需要，开始逐渐的学习CNN关于文本抽取的问题，由于语言功底不好，所以在学习中难免会有很多函数不会用的情况.....￣へ￣&lt;/p&gt;
&lt;p&gt;主要是我自己的原因，但是我更多的把语言当成是一个工具，需要的时候查找就行~~~~但是这也仅限于搬砖的时候，大多数时候如果要自己写代码，这个还是行不通的。&lt;/p&gt;
&lt;p&gt;简单的说一下在PCA，第一次接触这个名词还是在学习有关CNN算法时，一篇博客提到的数据输入层中，数据简单处理的几种方法之一，有提到PCA降维，因为论文需要CNN做一些相关的工作，想做一篇综述类文章，所以思路大概是这样：CNN处理文本历史，CNN处理文本的概述，基本方法，常用框架，具体方法，方法优劣确定，未来研究趋势。&lt;/p&gt;
&lt;p&gt;在查看相关常用框架的时候，才发现还有很多没有学过，(ｷ｀ﾟДﾟ´)!!，于是乎，抓紧吧~&lt;/p&gt;

&lt;p&gt;PCA（Principal Component Analysis）主成分分析法&lt;/p&gt;
&lt;p&gt;在数据处理中，经常会遇到特征维度比样本数量多得多的情况，如果拿到实际工程中去跑，效果不一定好。一是因为冗余的特征会带来一些噪音，影响计算的结果；二是因为无关的特征会加大计算量，耗费时间和资源。所以我们通常会对数据重新变换一下，再跑模型。数据变换的目的不仅仅是降维，还可以消除特征之间的相关性，并发现一些潜在的特征变量。&lt;/p&gt;
&lt;p&gt;目的：&lt;/p&gt;
&lt;p&gt;PCA是一种在尽可能减少信息损失的情况下找到某种方式降低数据的维度的方法。通常来说，我们期望得到的结果，是把原始数据的特征空间（n个d维样本）投影到一个小一点的子空间里去，并尽可能表达的很好（就是说损失信息最少）。常见的应用在于模式识别中，我们可以通过减少特征空间的维度，抽取子空间的数据来最好的表达我们的数据，从而减少参数估计的误差。注意，主成分分析通常会得到协方差矩阵和相关矩阵。这些矩阵可以通过原始数据计算出来。协方差矩阵包含平方和与向量积的和。相关矩阵与协方差矩阵类似，但是第一个变量，也就是第一列，是标准化后的数据。如果变量之间的方差很大，或者变量的量纲不统一，我们必须先标准化再进行主成分分析。（这里引用了一个大哥的文档，写的真的很漂亮，https://www.cnblogs.com/charlotte77/p/5625984.html）&lt;/p&gt;
&lt;p&gt;简单介绍一下，详细的可以看这篇博客，关于PCA降维的方法什么的都在里面，我主要在学习这篇的时候关于语言方面有些小障碍，所以能看懂上面，我这也就基本不用看了~&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在第一个问题中&lt;/span&gt;：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
mu_vec1 = np.array([0,0,0])&lt;br/&gt;cov_mat1 = np.array([[1,0,0],[0,1,0],[0,0,1]])&lt;p&gt;np.random.multivariate_normal(mu_vec1, cov_mat1, 20).T
&lt;/p&gt;&lt;/pre&gt;
&lt;pre&gt;
#def multivariate_normal(mean, cov, size=None, check_valid=None, tol=None)
&lt;/pre&gt;
&lt;p&gt;这段代码中，开始的时候对语法掌握不熟悉，定义部分在注释展示出了，主要的目的是生成随机数组，mean和cov是必须填写的参数，mean为一维数组，cov为协方差矩阵，size为生成随机数组的时候，具体的长度，比如size=20，则第一行元素就一共有20个；check_valid主要是为了检验是否为协方差矩阵，有三种写法：&lt;/p&gt;
&lt;p&gt;warn，raise以及ignore。当使用warn作为传入的参数时，如果cov不是半正定的程序会输出警告但仍旧会得到结果；当使用raise作为传入的参数时，如果cov不是半正定的程序会报错且不会计算出结果；当使用ignore时忽略这个问题即无论cov是否为半正定的都会计算出结果。3种情况的console打印结果如下：&lt;/p&gt;
&lt;p&gt;使用warn时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394859/201905/1394859-20190529102402762-630169663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用raise时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394859/201905/1394859-20190529102427233-1131135079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用ignore时：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1394859/201905/1394859-20190529102450830-1980075807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; tol：检查协方差矩阵奇异值时的公差，float类型。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这个问题算是解决了~下一个：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
class1_sample[0,:]和class1_sample[：,0]
&lt;/pre&gt;
&lt;p&gt;    &lt;br/&gt;X[:,0]是numpy中数组的一种写法，表示对一个二维数组，取该二维数组第一维中的所有数据，第二维中取第0个数据，直观来说，X[:,0]就是取所有行的第0个数据, X[:,1] 就是取所有行的第1个数据。&lt;/p&gt;
&lt;p&gt;import numpy as np&lt;/p&gt;
&lt;p&gt;X = np.array(&lt;span class=&quot;hljs-string&quot;&gt;[[0, 1], [2, 3], [4, 5], [6, 7], [8, 9], [10, 11], [12, 13], [14, 15], [16, 17], [18, 19]])&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;print(X[:, &lt;span class=&quot;hljs-number&quot;&gt;0])&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;为例&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;X[:, &lt;span class=&quot;hljs-number&quot;&gt;0]&lt;/span&gt;输出则为，[0,2,4,6,8,10,12,14,16,18]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;X[:, &lt;span class=&quot;hljs-number&quot;&gt;1]输出则为，[1,3,5,7,9,11,13,15,17,19]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;X[0, &lt;span class=&quot;hljs-number&quot;&gt;:]输出则为，[0,1]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;&lt;span class=&quot;hljs-number&quot;&gt;X[1, &lt;span class=&quot;hljs-number&quot;&gt;:]输出则为，[2,3]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;其中还有一个为X[:,  m:n]，即取所有数据的第m到n-1列数据，含左不含右&lt;/p&gt;
&lt;p&gt;例：输出X数组中所有行第1到2列数据&lt;/p&gt;
&lt;ol class=&quot;dp-py&quot; start=&quot;1&quot;&gt;&lt;li class=&quot;alt&quot;&gt;X = &lt;span&gt;np.array([[&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;0,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;1,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;2],[&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;3,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;4,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;5],[&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;6,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;7,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;8],[&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;9,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;10,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;11],[&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;12,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;13,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;14],[&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;15,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;16,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;17],[&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;18,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;19,&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;&lt;span&gt;20]])&lt;/span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;keyword&quot;&gt;print X[:,&lt;span class=&quot;number&quot;&gt;1:&lt;span class=&quot;number&quot;&gt;3]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;number&quot;&gt;结果为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;keyword&quot;&gt;&lt;span class=&quot;number&quot;&gt;&lt;span class=&quot;number&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1394859/201905/1394859-20190529103254443-274653413.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 第三个：&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
 np.concatenate((class1_sample, class2_sample), axis=1)
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;其中主要对axis=0和axis=1的问题做一下笔记：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;axis=0时：数组的拼接方式为首尾相连接&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;a = np.array([[1, 2], [3, 4]])&lt;/p&gt;
&lt;p&gt;b = np.array([[5, 6]])&lt;/p&gt;
&lt;p&gt;c = np.concatenate((a, b), axis=0)&lt;br/&gt;输出为：&lt;br/&gt;array([[1, 2],&lt;br/&gt;[3, 4],&lt;br/&gt;[5, 6]])&lt;/p&gt;
&lt;p&gt;axis=1时：数组的拼接方式为在a的每行元素末尾添加b对应行元素。&lt;/p&gt;
&lt;p&gt;a = np.array([[1, 2], [3, 4]])&lt;/p&gt;
&lt;p&gt;b = np.array([[5, 6]])&lt;/p&gt;
&lt;p&gt;c = np.concatenate((a, b), axis=1)&lt;br/&gt;输出为：&lt;br/&gt;array([[1, 2,3],&lt;br/&gt;[4，5, 6]])&lt;/p&gt;

</description>
<pubDate>Wed, 29 May 2019 04:58:00 +0000</pubDate>
<dc:creator>hezzzzzzz</dc:creator>
<og:description>由于论文需要，开始逐渐的学习CNN关于文本抽取的问题，由于语言功底不好，所以在学习中难免会有很多函数不会用的情况.....￣へ￣ 主要是我自己的原因，但是我更多的把语言当成是一个工具，需要的时候查找就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hezhuoheng/p/10942258.html</dc:identifier>
</item>
<item>
<title>python接口自动化（四十一）- 发xml格式参数的post请求（超详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10923930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10923930.html</guid>
<description>&lt;p&gt;　　最近在工作中，遇到一种奇葩的接口，它的参数数据是通过xml，进行传递的，不要大惊小怪的，林子大了什么鸟都有，每个人的思路想法不一样，开发的接口也是各式各样的，如果想要统一的话，必须是提前团队已经做好沟通定好规则，这样就像在产品线上生成一&lt;/p&gt;
&lt;p&gt;样规格大小一致。就不会出现前边的问题了，如果出现了怎么办？而且项目进度比较急，没有时间修改，一期上线就只能凑合着用这组接口了，那么作为QA的你，会不会测试，如何用代码、工具实现呢？？？等等问题跟着就产生了。&lt;/p&gt;
&lt;p&gt;　　前边就有介绍到有关：post请求相对于get请求多一个body部分，body部分常见的数据类型有以下四种（注意是常见的，并不是只有4种）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;application/x-www-form-urlencoded&lt;/li&gt;
&lt;li&gt;application/json&lt;/li&gt;
&lt;li&gt;text/xml&lt;/li&gt;
&lt;li&gt;multipart/form-data&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　本篇就来给各位看官和小伙伴们来讲xml这种类型的body案例，如何用python去实现，由于公司的制度的保密性，所以公司的接口就不能在这里给小伙伴们演示了，我给小伙伴们模拟了一个类似的接口，来给小伙伴们讲解一下思路，希望小伙伴们在遇到的时候不至于&lt;/p&gt;
&lt;p&gt;慌了神，不知道从何处入手，其实说到底，说破大天了，它的本质还是一个接口，那就还是按照接口的那套思路往上边靠，这样就思路不至于太偏，也会走很少的弯路。好了就不啰嗦了，直接进入今天的正题吧。&lt;/p&gt;

&lt;p&gt;1、首先要确定post请求的body部分类型是xml格式，可以用fiddler抓包工具、postman、jemter、Google浏览器接口调试插件来进行缺洞，这里我是用fiddler抓包工具来确定的。看到body部分格式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529103203555-917537625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、body里xml的参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=“&lt;span&gt;1.0&lt;/span&gt;” encoding = “UTF-&lt;span&gt;8&lt;/span&gt;”?&amp;gt;
&amp;lt;COM&amp;gt;
&amp;lt;REQ name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;北京-宏哥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;USER_ID&amp;gt;bjhongge&amp;lt;/USER_ID&amp;gt;
&amp;lt;COMMODITY_ID&amp;gt;&lt;span&gt;123456&lt;/span&gt;&amp;lt;/COMMODITY_ID&amp;gt;
&amp;lt;SESSION_ID&amp;gt;absbnmasbnfmasbm1213&amp;lt;/SESSION_ID&amp;gt;
&amp;lt;/REQ&amp;gt;
&amp;lt;/COM&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;PS：！！！&lt;/span&gt;&lt;/strong&gt;先不要着急的去用代码实现，而是先用工具请求一次，看是否可以请求是否可以成功。不要一开始就抨击怕啦的敲了半天，运行代码，傻眼了，运行结果和股市一样行情大涨，一片红色。结果你费了半天劲调试代码，也没查出错误。一问开发，开发用工具一试，一脸淫笑，然后笑呵呵的告诉你：额。。。，这个接口有点小问题，我需要调整一下下，这个时候是不是有一种想把开发接口的人痛揍一顿冲动，但是仔细想想还是自己的问题，如果一开始你就用工具模拟一下，出现问题立马找开发人员确认沟通，就不会有后面的剧情了。这种场景一般是萌新、小白可能会遇到的。好了，以下给小伙伴们列举了两种方法，当然了你也可以用其他方法模拟，条条大路通罗马，即可。&lt;/p&gt;
&lt;h2&gt;1、Google浏览器接口调试插件模拟&lt;/h2&gt;
&lt;p&gt;1、将url、请求方法、参数在插件中填写好，以后直接点击“Send”，即可&lt;/p&gt;

&lt;h2 id=&quot;使用fiddler模拟&quot;&gt;2、使用fiddler模拟&lt;/h2&gt;
&lt;p&gt;1、点开fiddler工具上composer菜单&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529111000157-219486083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、填写URL、选择请求方法、将xml数据直接复制到右下方Request Body部分，然后点右上角Execute就能执行了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529110827734-469829660.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1、宏哥演示环境：&lt;/p&gt;
&lt;p&gt;（1）python37 （2）PyCharm 2018.3.5 x64  （3）操作系统win10&lt;/p&gt;
&lt;p&gt;2、其实很简单的，难而不会，会而不难。将xml格式的body部分直接写成一个字符串类型就行了，遇到换行的字符串，在后面加个反斜杠&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529115030121-1515245717.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、body参数用data去接收传入，要是遇到编码问题报错，就对body部分encode下再传入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529114810548-1659119572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529115116941-117439250.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、参考代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;29&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-宏哥     QQ交流群：&lt;span&gt;984942724&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用 发xml格式参数的post请求
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import requests
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://httpbin.org/post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;# python3字符串换行，在右边加个反斜杠
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; body = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding = &quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;COM&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;REQ name=&quot;北京-宏哥&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;USER_ID&amp;gt;&amp;lt;/USER_ID&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;COMMODITY_ID&amp;gt;123456&amp;lt;/COMMODITY_ID&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;SESSION_ID&amp;gt;absbnmasbnfmasbm1213&amp;lt;/SESSION_ID&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/REQ&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/COM&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;# 遇到编码报错时候，对body进行encode
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; r = requests.post(url, data=body.encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; print(r.text)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1、xml格式的数据写到代码里面，不太直观，后期维护也不方便，可以把xml格式数据单独拿出来写到一个文件里，再用open函数去读取&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529113555518-1045039716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、新建一个body1_xml文件，写入内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529113715561-117859115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、参考内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=“&lt;span&gt;1.0&lt;/span&gt;” encoding = “UTF-&lt;span&gt;8&lt;/span&gt;”?&amp;gt;
&amp;lt;COM&amp;gt;
    &amp;lt;REQ name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;北京-宏哥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;USER_ID&amp;gt;bjhongge&amp;lt;/USER_ID&amp;gt;
        &amp;lt;COMMODITY_ID&amp;gt;&lt;span&gt;123456&lt;/span&gt;&amp;lt;/COMMODITY_ID&amp;gt;
        &amp;lt;SESSION_ID&amp;gt;absbnmasbnfmasbm1213&amp;lt;/SESSION_ID&amp;gt;
    &amp;lt;/REQ&amp;gt;
&amp;lt;/COM&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、用open函数去读xml内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529113847169-838819342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190529114236318-1821806204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、参考代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;29&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-宏哥     QQ交流群：&lt;span&gt;984942724&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用 发xml格式参数的post请求
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import requests
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; url = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://httpbin.org/post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;# python3字符串换行，在右边加个反斜杠
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; body = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding = &quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;COM&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;REQ name=&quot;北京-宏哥&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;USER_ID&amp;gt;&amp;lt;/USER_ID&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;COMMODITY_ID&amp;gt;123456&amp;lt;/COMMODITY_ID&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;SESSION_ID&amp;gt;absbnmasbnfmasbm1213&amp;lt;/SESSION_ID&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/REQ&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;        &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;/COM&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;body1.xml&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; fp:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;        body =&lt;span&gt; fp.read()
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; print(body)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　嘿嘿，今天到这里有&lt;span&gt;关发xml格式参数的post请求&lt;/span&gt;就给小伙伴们介绍完了，看起来是不是相当简单啊，但是在工作中遇到类似的问题，要灵活应用，不要生搬硬套。&lt;/p&gt;
</description>
<pubDate>Wed, 29 May 2019 04:50:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 最近在工作中，遇到一种奇葩的接口，它的参数数据是通过xml，进行传递的，不要大惊小怪的，林子大了什么鸟都有，每个人的思路想法不一样，开发的接口也是各式各样的，如果想要统一的话，必须是提前团队已经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/du-hong/p/10923930.html</dc:identifier>
</item>
<item>
<title>了解【Docker】从这里开始 - 我没有三颗心脏</title>
<link>http://www.cnblogs.com/wmyskxz/p/10943169.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wmyskxz/p/10943169.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-caeed3c30fd4dcc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;软件开发最大的难题之一就是环境配置的问题。现在用户环境纷乱复杂，并且由于开源社区的进一步推广和许多开源项目不停地迭代更新，项目可能会有越来越多的依赖以及越来越难管理的依赖版本，如何保证编写的程序能不只是在“我的电脑上能运行”（It works on my machine）成了一个复杂麻烦的事情。&lt;/p&gt;
&lt;p&gt;于是就有人提出：能不能从根本上解决问题，让软件可以自带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。&lt;/p&gt;
&lt;h2 id=&quot;虚拟机&quot;&gt;虚拟机&lt;/h2&gt;
&lt;p&gt;虚拟机（virtual machine）就是一种自带环境安装的解决方案。它可以在一个操作系统里面运行另一个操作系统，比如在 Windows 系统里运行一个 Linux 的操作系统。&lt;/p&gt;
&lt;p&gt;应用程序对虚拟机是毫无感知的，因为虚拟机看上去跟真实的操作系统一模一样，而且对于底层的系统来说，虚拟机就是一个普通文件，不需要了就删除，对其他部分毫无影响。&lt;/p&gt;
&lt;p&gt;虽然用户可以通过虚拟机还原软件的原始环境。但是，该方案有以下的几个缺点：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 资源占用多&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机会独占一部分本属于操作系统的内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕你想在虚拟机里面使用的应用程序它实际只会占用 1MB 的内存，虚拟机仍然需要几百 MB 的内存才能运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 冗余步骤多&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机是完整的操作系统，一些系统层面上的操作步骤，往往无法调过，比如用户登录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 启动慢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，才能让应用程序真正的运行起来。&lt;/p&gt;
&lt;h2 id=&quot;linux-容器&quot;&gt;Linux 容器&lt;/h2&gt;
&lt;p&gt;由于虚拟机存在上述的这些缺点，Linux 提出了另一种虚拟机化技术：Linux 容器（Linux Containers，缩写 LXC）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。&lt;/strong&gt;或者说，在正常进程的外面套了一个&lt;a href=&quot;https://opensource.com/article/18/1/history-low-level-container-runtimes&quot;&gt;保护层&lt;/a&gt;。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。&lt;/p&gt;
&lt;p&gt;由于容器是进程级别的，相比虚拟机有很多优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 启动快&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 资源占用少&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 体积小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。&lt;/p&gt;
&lt;p&gt;总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。&lt;/p&gt;

&lt;hr/&gt;&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;Enterprise Container Platform for High-Velocity Innovation&lt;/strong&gt;&lt;br/&gt;Securely build, share and run any application, anywhere&lt;/p&gt;
&lt;p&gt;译：&lt;br/&gt;&lt;strong&gt;企业高速容器平台&lt;/strong&gt;&lt;br/&gt;在任何地方安全的建造、分享、运行你的应用程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方对 Docker 的定义是一个容器平台。简单来说，&lt;strong&gt;Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。&lt;/strong&gt;它是目前最流行的 Linux 容器解决方案。开发人员可以利用 Docker 来消除协作编码时 “在我的电脑上可以正常工作” 的问题。&lt;/p&gt;
&lt;p&gt;Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。&lt;/p&gt;
&lt;p&gt;总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。&lt;/p&gt;
&lt;h2 id=&quot;为什么要使用-docker&quot;&gt;为什么要使用 Docker？&lt;/h2&gt;
&lt;p&gt;Docker 是一个为开发者和运维者去开发、发布和在容器中运行应用的平台。使用 Linux 容器来部署应用程序被称为容器化。 容器不是新的概念，它的优势在于很容易发布一个应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-c12397c3a9cb8ee2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;容器化变得非常的流行，因为容器化具有以下的优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;灵活：即使最复杂的应用也能够被容器化。&lt;/li&gt;
&lt;li&gt;轻量：容器最大化利用和分享主机的内核。&lt;/li&gt;
&lt;li&gt;可互换：你可以即时部署更新和升级应用。&lt;/li&gt;
&lt;li&gt;便捷：你可以在本地构建应用，并部署到容器云，并在任何地方运行。&lt;/li&gt;
&lt;li&gt;可扩展：你可以增加和自动分发容器的个数。&lt;/li&gt;
&lt;li&gt;可堆叠：您可以垂直堆叠服务并即时堆叠服务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而Docker 只需要启动 10 个隔离的应用即可。&lt;/p&gt;
&lt;p&gt;具体说来，Docker 在如下几个方面具有较大的优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 更快速的交付和部署&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。&lt;/p&gt;
&lt;p&gt;开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 更高效的虚拟化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 更轻松的迁移和扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 更简单的管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。&lt;/p&gt;
&lt;h2 id=&quot;docker-vs-vm&quot;&gt;Docker VS VM&lt;/h2&gt;
&lt;p&gt;容器和虚拟机对资源的隔离和分配有相同的优势，但不同的是容器虚拟化操作系统而不是硬件，这使得容器更加的方便和高效。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-97017f1c0f687840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个容器是在 Linux 服务本地运行，并和其他的容器共享主机的内核。它运行在一个独立的进程中，相对于其他可执行的进程（比如虚拟机）来说，容器的内存占用空间更小，更加的轻量化。&lt;/p&gt;
&lt;p&gt;相比之下，虚拟机（VM）运行一个完整的“客户”操作系统，通过虚拟机管理程序虚拟访问主机资源。 一般来说，虚拟机提供的环境比大多数应用程序需要的资源更多。&lt;/p&gt;
&lt;p&gt;由于 Docker 轻量、资源占用少，使得 Docker 可以轻易的应用到构建标准化的应用中。但 Docker 目前还不够完善，比如隔离效果不如 VM，共享宿主机操作系统的一些基础库等；网络配置功能相对简单，主要以桥接方式为主；查看日志也不够方便灵活。&lt;/p&gt;
&lt;h2 id=&quot;docker-的用途&quot;&gt;Docker 的用途&lt;/h2&gt;
&lt;p&gt;Docker 的主要用途，目前有三大类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 提供一次性的环境。&lt;/strong&gt;比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 提供弹性的云服务。&lt;/strong&gt;因为 Docker 容器可以随开随关，很适合动态扩容和缩容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 组建微服务架构。&lt;/strong&gt;通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;下面这张图非常的经典，很形象地展示了，什么是容器，什么是镜像，什么是仓库，以及三者之间的联系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-b4c5dd5a03dfa67e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们来解释一下这张图。现在我们要造一间厨房，在造之前我们首先要干的一件事，就是先列举出我们造厨房需要的东西。我们可能需要一个通了水电煤的房子以及一些必需的厨房用具诸如锅碗瓢勺、煤气灶、冰箱、水槽等等这些东西。现在我们知道需要了什么东西之后，我们就去找这些东西。首先我们先去京东购买一些厨房用具，这些用具就好比我们的Docker镜像，我们厨房的用具到了之后得找个地方把它们放在，不可能随处丢吧，不然后面用的时候就找不到它了，那么我们Docker镜像也是这样，需要一个Docker仓库去存储这些镜像。现在我们有了这些厨房用具之后就可以做饭了吗？答案当然是不能，没水没电没火啊！这时候我们得把厨房用具给装到一个通了水电煤的房子才行，那么Docker镜像也是这样，单纯的Docker镜像是不能用的，它得装到Docker容器中通了水电煤才能使用。等我们装好了厨房用具之后我们就可以开始做饭，那么我们的Docker镜像装到Docker容器之后，我们应用就可以跑起来了。&lt;/p&gt;
&lt;h2 id=&quot;概念详解&quot;&gt;概念详解&lt;/h2&gt;
&lt;p&gt;Docker是CS架构，主要有两个概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Docker daemon:&lt;/strong&gt; 运行在宿主机上，Docker守护进程，用户通过Docker client(Docker命令)与Docker daemon交互&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker client:&lt;/strong&gt; Docker 命令行工具，是用户使用Docker的主要方式，Docker client与Docker daemon通信并将结果返回给用户，Docker client也可以通过socket或者RESTful api访问远程的Docker daemon&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/7896890-7f1b0975e1eee6d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解了Docker的组成，再来了解一下Docker的三个主要概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Docker image：&lt;/strong&gt; 镜像是只读的，镜像中包含有需要运行的文件。镜像用来创建container，一个镜像可以运行多个container；镜像可以通过Dockerfile创建，也可以从Docker hub/registry上下载。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker container：&lt;/strong&gt; 容器是Docker的运行组件，启动一个镜像就是一个容器，容器是一个隔离环境，多个容器之间不会相互影响，保证容器中的程序运行在一个相对安全的环境中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Docker hub/registry:&lt;/strong&gt; 共享和管理Docker镜像，用户可以上传或者下载上面的镜像，官方地址为https://registry.hub.docker.com/，也可以搭建自己私有的Docker registry。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;镜像就相当于打包好的版本，镜像启动之后运行在容器中，仓库就是装存储镜像的地方。&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;安装过程都大同小异，这里就不细说了，详细的可以参考这里：&lt;a href=&quot;https://www.runoob.com/docker/macos-docker-install.html&quot; class=&quot;uri&quot;&gt;https://www.runoob.com/docker/macos-docker-install.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;唯一需要注意的就是由于国内网络问题，需要给 Docker 镜像加个速（详细的可以戳上面链接，最后有...）&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;首先，运行下面的命令，将 image 文件从仓库抓取到本地。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ docker image pull library/hello-world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码中，&lt;code&gt;docker image pull&lt;/code&gt;是抓取 image 文件的命令。&lt;code&gt;library/hello-world&lt;/code&gt;是 image 文件在仓库里面的位置，其中&lt;code&gt;library&lt;/code&gt;是 image 文件所在的组，&lt;code&gt;hello-world&lt;/code&gt;是 image 文件的名字。&lt;/p&gt;
&lt;p&gt;由于 Docker 官方提供的 image 文件，都放在&lt;a href=&quot;https://hub.docker.com/r/library/&quot;&gt;&lt;code&gt;library&lt;/code&gt;&lt;/a&gt;组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ docker image pull hello-world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抓取成功以后，就可以在本机看到这个 image 文件了。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ docker image ls&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，运行这个 image 文件&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ docker container run hello-world&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;docker container run&lt;/code&gt; 命令会从 image 文件，生成一个正在运行的容器实例。&lt;/p&gt;
&lt;p&gt;注意，&lt;code&gt;docker container run&lt;/code&gt; 命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的 &lt;code&gt;docker image pull&lt;/code&gt; 命令并不是必需的步骤。&lt;/p&gt;
&lt;p&gt;如果运行成功，你会在屏幕上读到下面的输出。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ docker container run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.

... ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出这段提示以后，&lt;code&gt;hello world&lt;/code&gt; 就会停止运行，容器自动终止。&lt;/p&gt;
&lt;p&gt;有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ docker container run -it ubuntu bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于那些不会自动终止的容器，必须使用&lt;a href=&quot;https://docs.docker.com/engine/reference/commandline/container_kill/&quot;&gt;&lt;code&gt;docker container kill&lt;/code&gt;&lt;/a&gt; 命令手动终止。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ docker container kill [containID]&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;杀死所有正在运行的容器&lt;br/&gt;&lt;code&gt;docker kill $(docker ps -a -q)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除所有已经停止的容器&lt;br/&gt;&lt;code&gt;docker rm $(docker ps -a -q)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除所有镜像&lt;br/&gt;&lt;code&gt;docker rmi $(docker images -q)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关闭容器&lt;br/&gt;&lt;code&gt;docker stop CONTAINER ID或者NAMES&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;重新启动关闭的容器&lt;br/&gt;&lt;code&gt;docker start CONTAINER ID或者NAMES&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移除本地容器&lt;br/&gt;&lt;code&gt;docker rm CONTAINER ID或者NAMES&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看本地容器&lt;br/&gt;&lt;code&gt;docker ps //查看正在运行的容器&lt;/code&gt;&lt;br/&gt;&lt;code&gt;docker ps -a //查看所有容器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看本地镜像&lt;br/&gt;&lt;code&gt;docker images&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;创建镜像&lt;br/&gt;&lt;code&gt;docker build -t name:tag Dockerfile路径&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;修改本地镜像标记&lt;br/&gt;&lt;code&gt;docker tag IMAGE ID name:tag&lt;/code&gt;&lt;br/&gt;&lt;code&gt;docker rmi name:tag&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除本地镜像&lt;br/&gt;&lt;code&gt;docker rmi name:tag或者IMAGE ID&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;进入容器&lt;br/&gt;&lt;code&gt;docker exec -it IMAGE ID或者NAMES /bin/bash&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取镜像中心的镜像&lt;br/&gt;&lt;code&gt;docker pull name:tag&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取容器的端口映射配置&lt;br/&gt;&lt;code&gt;docker port CONTAINER ID或者NAMES&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考资料&quot;&gt;# 参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&quot;&gt;1. Docker入门教程(阮一峰) - http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/ityouknow/p/8520296.html&quot;&gt;2. Docker(一)：Docker入门教程(纯洁的微笑) - https://www.cnblogs.com/ityouknow/p/8520296.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.runoob.com/docker/docker-tutorial.html&quot;&gt;3. Docker教程(菜鸟教程) - https://www.runoob.com/docker/docker-tutorial.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000009544565#articleHeader6&quot;&gt;4. - Docker入门，看这篇就够了 - https://segmentfault.com/a/1190000009544565#articleHeader6&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.docker.com/&quot;&gt;5. 官方文档 - https://www.docker.com&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;按照惯例黏一个尾巴：&lt;/p&gt;
&lt;blockquote readability=&quot;6.0896860986547&quot;&gt;
&lt;p&gt;欢迎转载，转载请注明出处！&lt;br/&gt;简书ID：&lt;a href=&quot;https://www.jianshu.com/u/a40d61a49221&quot;&gt;@我没有三颗心脏&lt;/a&gt;&lt;br/&gt;github：&lt;a href=&quot;https://github.com/wmyskxz/&quot;&gt;wmyskxz&lt;/a&gt;&lt;br/&gt;欢迎关注公众微信号：wmyskxz&lt;br/&gt;分享自己的学习 &amp;amp; 学习资料 &amp;amp; 生活&lt;br/&gt;想要交流的朋友也可以加qq群：3382693&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 29 May 2019 04:47:00 +0000</pubDate>
<dc:creator>我没有三颗心脏</dc:creator>
<og:description>一、环境配置的难题 软件开发最大的难题之一就是环境配置的问题。现在用户环境纷乱复杂，并且由于开源社区的进一步推广和许多开源项目不停地迭代更新，项目可能会有越来越多的依赖以及越来越难管理的依赖版本，如何</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wmyskxz/p/10943169.html</dc:identifier>
</item>
</channel>
</rss>