<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SQL行列乾坤大挪移 - 正版乔</title>
<link>http://www.cnblogs.com/qiaohaoforever/p/10236626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiaohaoforever/p/10236626.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;“生活总是这样，有时候，你需要一个苹果，但别人却给了你一个梨。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天dalao邮件里需要添加一张每月累计长长的图，可是，拿到手上的&lt;code&gt;SQL&lt;/code&gt;导出数据不符合我最爱的&lt;code&gt;pyecharts&lt;/code&gt;的数据输入格式，头大。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获得到的数据&lt;/span&gt;&lt;/p&gt;
&lt;table width=&quot;890&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;种类&lt;/th&gt;
&lt;th&gt;数量&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td height=&quot;35&quot;&gt;9012-01-01&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;香蕉&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td height=&quot;35&quot;&gt;9012-01-01&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;苹果&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;99&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td height=&quot;35&quot;&gt;9012-01-01&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;梨&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td height=&quot;35&quot;&gt;9012-01-02&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;香蕉&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;100&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td height=&quot;35&quot;&gt;9012-01-02&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;苹果&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;999&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td height=&quot;35&quot;&gt;9012-01-02&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;梨&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;99&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;code&gt;pyecharts&lt;/code&gt;想要的数据&lt;/span&gt;&lt;/p&gt;
&lt;table width=&quot;890&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;香蕉&lt;/th&gt;
&lt;th&gt;苹果&lt;/th&gt;
&lt;th&gt;梨&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td height=&quot;35&quot;&gt;9012-01-01&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;10&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;99&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;9&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td height=&quot;35&quot;&gt;9012-01-02&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;100&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;999&lt;/td&gt;
&lt;td height=&quot;35&quot;&gt;99&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;想到两个方案：&lt;br/&gt;方案一，&lt;code&gt;python&lt;/code&gt;处理数据，修正为所需数据格式；&lt;br/&gt;方案二，修改SQL代码，直接输出指定格式。&lt;/p&gt;
&lt;p&gt;其实以前有遇到过类似的问题，但总是习惯使用方案一来处理类似问题，稍微思考了一下，方案二居然一时半会想一个简单实现的好办法，，，难受。经过一番学习研究，获取到了&lt;code&gt;SQL行列乾坤大挪移&lt;/code&gt;的精髓。&lt;/p&gt;
&lt;table width=&quot;NaN&quot;&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr readability=&quot;19.5&quot;&gt;&lt;td height=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td height=&quot;35&quot; readability=&quot;16&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;day&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;&quot;日期&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;SUM&lt;/span&gt;(&lt;span&gt;IF&lt;/span&gt;(product=&lt;span&gt;&quot;香蕉&quot;&lt;/span&gt;, nums, &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;&quot;香蕉&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;SUM&lt;/span&gt;(&lt;span&gt;IF&lt;/span&gt;(product=&lt;span&gt;&quot;苹果&quot;&lt;/span&gt;, nums, &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;&quot;苹果&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;SUM&lt;/span&gt;(&lt;span&gt;IF&lt;/span&gt;(product=&lt;span&gt;&quot;梨&quot;&lt;/span&gt;, nums, &lt;span&gt;0&lt;/span&gt;)) &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;&quot;梨&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    一张待拯救的表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;GROUP&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;day&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;day&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当当当，行变成了列，这样就可以愉快的玩耍了，结合&lt;code&gt;pyecharts&lt;/code&gt;画出dalao想要的款了，搞定收工！&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;记得关注微信公众号：正版乔&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;一个学统计的程序员&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢Coding&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢硬件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢树莓派&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢深度学习&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;喜欢你&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 07 Jan 2019 15:44:00 +0000</pubDate>
<dc:creator>正版乔</dc:creator>
<og:description>“生活总是这样，有时候，你需要一个苹果，但别人却给了你一个梨。”今天dalao邮件里需要添加一张每月累计长长的图，可是，拿到手上的SQL导出数据不符合我最爱的pyecharts的数据输入格式，头大。获</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiaohaoforever/p/10236626.html</dc:identifier>
</item>
<item>
<title>迁移桌面程序到MS Store（5）——.NET Standard - 楼上那个蜀黍</title>
<link>http://www.cnblogs.com/manupstairs/p/10236601.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/manupstairs/p/10236601.html</guid>
<description>&lt;p&gt;　　接下来的几篇，我想讨论下迁移桌面程序到MS Store，可以采用的比较常见、通用性比较强的实施步骤和分层架构。&lt;br/&gt;　　通常商业项目一般都是不断的迭代，不太可能突然停止更新现有的桌面版本，然后花很长时间从头来写UWP版本，所以我建议将迁移的过程分阶段，通过几个版本的迭代，慢慢地从传统桌面程序，转变成一个可以通过MS Store审核的APPX程序。至于之后要不要变成真·UWP可以视市场反馈决定。&lt;br/&gt;　　假设现有的桌面程序包含一个MainUI的WPF工程，多个.NET Framework 4.5的类库，以及一个C++编写的后台服务，以Windows Service的形式运行。之所以假设存在一个C++的Service,是考虑有些桌面程序要和硬件打交道，只有C语言版本的API。或者需要调用公司自己的通用类库，通常是C或C++写的跨平台版本。&lt;br/&gt;　　我推荐第一步，也是最简单的一步从.NET Framework类库着手改起。第一阶段的目标是将.NET Frramwork 4.5的类库，转换成.NET Standard 2.0版本的类库。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/362529/201901/362529-20190107232837045-1090111509.png&quot; alt=&quot;&quot; width=&quot;855&quot; height=&quot;593&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　这里要着重介绍一下.NET Standard。MSDN上对于.NET Standard的解释虽然每个字都认识，可把这些字连成句子，读起来就不太容易看懂。&lt;br/&gt;　　&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/standard/net-standard&lt;/a&gt;&lt;br/&gt;　　总而言之呢，就是一个Class Library(.NET Standard)，它既可以被WPF工程引用，也可以被UWP工程引用，同时还可以被.NET Core的工程引用。&lt;br/&gt;　　在我们的例子中，因为我们的MainUI仍然是WPF的工程，所以不能直接将.NET Framework 4.5的Class Library转换成Universal Windows版本。同时我们又需要对未来可能存在的UWP版本提供支持，那么.NET Standard就是最佳的选择。&lt;br/&gt;　　在这种情况下，我们甚至可以在保留WPF的MainUI以支持Win 7（该死的老古董）的同时，新建一个UWP的UI工程来支持Win10。二者共用同一份的.NET Standard的Class Library。&lt;br/&gt;　　可能有些同学会问，同样一个C#的Class Library，为什么会有.NET Framework，Universal Windows，.NET Core和.NET Standard四种类型。下面我们来简单介绍以上几个概念，这些拗口的名称得感谢某软改名部八辈子祖宗，顺便问下还招人不？&lt;br/&gt;　　.NET Framework最为好懂，从2000年左右的.NET 1.0开始，现今已经发展到.NET 4.7.2。你说4.5以后怎么光升小版本号啊？啥时候出.NET 5啊？我说孩子你别傻了，.NET 5不就是.NET Core嘛？&lt;br/&gt;　　.NET Core，个人理解就是为了跨平台，重写的.NET Framework，也同样是为了跨平台，所以现阶段主打ASP.NET Core，而和Windows紧密结合的WPF，Winform，甚至UWP都是暂不支持的。毕竟在短时间内，重新写一份包含.NET 4.7.2所有功能的.NET Core不太现实。也没有迫切的需要。从GitHub的roadmap看，至少要到3.0版本才会支持UWP及桌面开发。&lt;br/&gt;　　&lt;a href=&quot;https://blogs.msdn.microsoft.com/dotnet/2018/05/07/net-core-3-and-support-for-windows-desktop-applications&quot; target=&quot;_blank&quot;&gt;https://blogs.msdn.microsoft.com/dotnet/2018/05/07/net-core-3-and-support-for-windows-desktop-applications&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/362529/201901/362529-20190107233014638-775099188.png&quot; alt=&quot;&quot; width=&quot;858&quot; height=&quot;823&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　Universal Windows class library就比较尴尬了，作为Win8那时候的Windows Runtime portable class library的Win10升级版。技术是好技术，可惜没赶上好时候。Win8和WP8的口碑不行，连累了Win10。简而言之就是给所有UWP程序用的class library。&lt;br/&gt;　　.NET Standard则是Universal Windows Class Library的跨平台再升级版。最终的大一统，今日的主角。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/362529/201901/362529-20190107233106920-838252444.png&quot; alt=&quot;&quot; width=&quot;841&quot; height=&quot;547&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　上面这个表格看上去内容很多，实际我们仅仅需要看最后一列，使用最新的.NET Standard 2.0就可以了。抛去和我们迁移桌面程序关系不大的Mono，Xamarion和Unity，实际我们可以看到从.NET 4.6.1开始就已经支持.NET Standard 2.0了。从Windows 10版本来看的话，RS3的16299也已经是非常普及的版本了。&lt;br/&gt;　　升级到.NET Standard的好处非常明显，.NET Standard版本的类库可以在.NET Framework，UWP和.NET Core 之间共享，同时面向未来的升级做到无缝衔接。&lt;br/&gt;　　本着先易后难，循序渐进的原则，这一篇我们先讨论了什么是.NET Standard，以及升级的目的和意义。下一篇我们会介绍在升级.NET Framework到.NET Standard的过程中，可以使用的兼容性检测工具The .NET Portability Analyzer。顺便在展望一下.NET Core 3.0，一边写代码一边吹吹水，体验双倍的快乐！&lt;/p&gt;

</description>
<pubDate>Mon, 07 Jan 2019 15:37:00 +0000</pubDate>
<dc:creator>楼上那个蜀黍</dc:creator>
<og:description>接下来的几篇，我想讨论下迁移桌面程序到MS Store，可以采用的比较常见、通用性比较强的实施步骤和分层架构。 通常商业项目一般都是不断的迭代，不太可能突然停止更新现有的桌面版本，然后花很长时间从头来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/manupstairs/p/10236601.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core&amp;Docker部署到树莓派3B中 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10233780.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10233780.html</guid>
<description>&lt;p&gt;　　花了一点时间将吃灰数月的树莓派装上了Docker，并在容器中部署了一个Asp.Net Core应用程序，通过花生壳映射树莓派中的程序，可以使用外网访问树莓派，玩起来很有意思(外网访问地址：&lt;a href=&quot;http://2194cn9096.imwork.net/&quot; target=&quot;_blank&quot;&gt;http://2194cn9096.imwork.net/&lt;/a&gt;，访问不通可能树莓派断电了)，过程中发现了一点问题，或许对于同样路线的朋友有所帮助，特此写出玩转过程。&lt;/p&gt;
&lt;p&gt;　　码云Demo地址：&lt;a href=&quot;https://gitee.com/530521314/ControlEvent.git&quot; target=&quot;_blank&quot;&gt;https://gitee.com/530521314/ControlEvent.git&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、树莓派安装操作系统&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;　　1、进入官网下载操作系统：&lt;a href=&quot;https://www.raspberrypi.org/downloads/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.raspberrypi.org/downloads/&lt;/a&gt;，我使用了官方的Raspbian系统，并且选择了无界面的轻量版&lt;strong&gt;Raspbian Stretch Lite.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107215043655-2093497119.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　2、下载格式化SD卡的工具：&lt;a href=&quot;https://www.sdcard.org/downloads/formatter_4/eula_windows/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.sdcard.org/downloads/formatter_4/eula_windows/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　3、下载将系统烧录到SD卡中的工具Win32 DiskImager：&lt;a href=&quot;http://sourceforge.net/projects/win32diskimager/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://sourceforge.net/projects/win32diskimager/&lt;/a&gt;，选择系统磁盘路径地址，选择卡，然后执行Write即可，等待几分钟，便完成烧录工作&lt;/p&gt;
&lt;h4&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107215228392-1186981426.png&quot; alt=&quot;&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;　　4、做一些配置工作，方便启动树莓派后可以快速玩转&lt;/p&gt;
&lt;p&gt;　　　4.1、启动SSH，在卡分区内创建一个名为ssh的文件夹即可&lt;/p&gt;
&lt;p&gt;　　　4.2、设置无线连接，本次我没有使用外接显示器到树莓派中，使用Putty工具直接无线连接，个人感觉更为方便，在卡内boot文件夹内，创建一个wpa_supplicant.conf的文件，并写下如下内容，该内容在树莓派通电后会由系统自动添加到/etc/wpa_supplicant/wpa_supplicant.conf中，设置完毕后便可以插入到树莓派，开始通电了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
country=&lt;span&gt;CN
ctrl_interface&lt;/span&gt;=DIR=/&lt;span&gt;var&lt;/span&gt;/run/wpa_supplicant GROUP=&lt;span&gt;netdev
update_config&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WiFi没有密码&lt;/span&gt;
network=&lt;span&gt;{
ssid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;你的无线网络名称（ssid）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    key_mgmt&lt;/span&gt;=&lt;span&gt;NONE
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WiFi使用WEP加密&lt;/span&gt;
network=&lt;span&gt;{
    ssid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无线网络名称（ssid）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    key_mgmt&lt;/span&gt;=&lt;span&gt;NONE
    wep_key0&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wifi密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;WiFi使用WPA/WPA2加密&lt;/span&gt;
network=&lt;span&gt;{
    ssid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;无线网络名称（ssid）&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    key_mgmt&lt;/span&gt;=WPA-&lt;span&gt;PSK
    psk&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wifi密码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以我的举例(priority连接优先级最高)：&lt;/span&gt;
network=&lt;span&gt;{
    ssid&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Yang1802&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    key_mgmt&lt;/span&gt;=WPA-&lt;span&gt;PSK
    psk&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxxxxxxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    priority&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　　&lt;span&gt;4.3、使用Putty连接树莓派，树莓派ip地址可以找办法查看（如我使用的华为路由器，则可以登录路由器管理平台查看），使用账号pi，密码raspberry完成登录，开始校正树莓派时间&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置时区为 亚洲（Asia） 上海（Shanghai）&lt;/span&gt;
sudo dpkg-&lt;span&gt;reconfigure tzdata
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动 NTP 使计算机时钟与 Internet 时间服务器同步&lt;/span&gt;
sudo timedatectl &lt;span&gt;set&lt;/span&gt;-ntp &lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　5、切换到root账号，方便操作&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;&lt;span&gt;二、树莓派安装Docker&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; 　　1、开始安装Docker，由于树莓派使用的是ARM板，因此在安装Docker时，需要使用ARM板的安装教程：&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-convenience-script&quot; target=&quot;_blank&quot;&gt;https://docs.docker.com/install/linux/docker-ce/debian/#install-using-the-convenience-script&lt;/a&gt;，使用提供的安装脚本完成安装即可，需要等待一些时间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ curl -fsSL https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;get.docker.com -o get-docker.sh&lt;/span&gt;
$ sudo sh &lt;span&gt;get&lt;/span&gt;-docker.sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、安装Git工具，安装Git的目的是用于下载码云上的代码到树莓派中，虽然这个环节是有点冗余的，当我配置好了一台Jenkins服务器后，完全可以使用Jenkins服务器的功能将需要的镜像生产完成，因此这个环节就显得不这么重要了，但是，如果没有Jenkins服务器，那么这个环节就不得不进行了，毕竟需要将代码转移到树莓派中，或是开发环境中开发完毕，使用ftp转移到树莓派中等多种方式实现，使用如下命令安装git工具。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo apt-get install&lt;/span&gt; git
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;三、使用Dockerfile编译镜像并生成容器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　 1、新建应用程序，按照约定的标准化应用程序构建方式完成项目搭建(前几篇文章中讲到了)，具体的项目结构可以从码云中查看。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107223344376-1768952529.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、增加Dockerfile并修改默认的Dockerfile内容，由于树莓派使用的是Arm板子，因此对于.net core运行环境也有所不同，在Dockerfile中需要指定发布目标平台，具体Dockerfile如下，使用的基础镜像可以从dotnet组织提供的示例中找到：&lt;a href=&quot;https://github.com/dotnet/dotnet-docker&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnet/dotnet-docker&lt;/a&gt;，我针对该示例中有的Dockerfile做了一些改动，以适应项目结构的需要。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM&lt;/span&gt; microsoft/dotnet:2.2&lt;span&gt;-sdk-stretch-arm32v7 AS build
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app

# copy csproj and restore as distinct layers
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; ControlEvent.Web.csproj ./ControlEvent.Web/
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app/ControlEvent.Web
&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; dotnet restore

# copy and build app and libraries
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app/
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; . ./ControlEvent.Web/
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app/ControlEvent.Web
&lt;/span&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; dotnet publish -c Release -r linux-arm -o out

&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; microsoft/dotnet:2.2&lt;span&gt;-runtime-deps-stretch-slim-arm32v7 AS runtime
&lt;/span&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /app
&lt;/span&gt;&lt;span&gt;COPY&lt;/span&gt;&lt;span&gt; --from=build /app/ControlEvent.Web/out ./
&lt;/span&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&quot;./ControlEvent.Web&quot;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、提交代码，在树莓派中使用Git克隆项目获取代码，并进入到Dockerfile层级使用命令构建镜像&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107224102460-401697734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　使用如下命令构建镜像，我的目标镜像名称为controlevent，此次构建要花费点时间，需要下载相关的基础镜像，下一次构建时会很快了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker build --pull -t controlevent .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、使用如下命令生成容器，本次指定了-it参数，在生成完毕后可以查看控制台输出，直接按Ctrl Q和P退出即可，也可直接使用-d参数后台运行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run --&lt;span&gt;rm&lt;/span&gt; -it -p &lt;span&gt;9527&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; controlevent
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107224902122-533602531.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　5、使用ip地址及端口访问，如果绑定了花生壳，并且在花生壳中做了本地映射，也可以直接使用域名加端口直接访问树莓派中的服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107225027304-296374935.png&quot; alt=&quot;&quot; width=&quot;1063&quot; height=&quot;474&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;strong&gt;至此，本次树莓派中安装Docker并部署Asp.Net Core应用程序就完成了。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: Asp.Net Core&amp;amp;amp;Docker部署到树莓派3B中&quot; href=&quot;https://www.cnblogs.com/CKExp/p/10233780.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/CKExp/p/10233780.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　欢迎关注微信订阅号，有新的文章将同步到订阅号中&lt;/p&gt;
&lt;p&gt;　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201901/1133736-20190107225239033-980180739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;2019-1-7,望技术有成后能回来看见自己的脚步&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 07 Jan 2019 14:56:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>花了一点时间将吃灰数月的树莓派装上了Docker，并在容器中部署了一个Asp.Net Core应用程序，通过花生壳映射树莓派中的程序，可以使用外网访问树莓派，玩起来很有意思(外网访问地址：http:/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/10233780.html</dc:identifier>
</item>
<item>
<title>.NET Core中的一个接口多种实现的依赖注入与动态选择看这篇就够了 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10236163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10236163.html</guid>
<description>&lt;p&gt;最近有个需求就是一个抽象仓储层接口方法需要SqlServer以及Oracle两种实现方式，为了灵活我在依赖注入的时候把这两种实现都给注入进了依赖注入容器中，但是在服务调用的时候总是获取到最后注入的那个方法的实现，这时候就在想能不能实现动态的选择使用哪种实现呢？如果可以的话那么我只需要在配置文件中进行相应的配置即可获取到正确的实现方法的调用，这样的话岂不快哉！今天我们就来一起探讨下实现这种需求的几种实现方式吧。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10236163.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10236163.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;代码演示&quot;&gt;代码演示&lt;/h2&gt;
&lt;p&gt;在开始实现的方式之前，我们先模拟下代码。由于真实系统的结构比较复杂，所以这里我就单独建一个类似的项目结构代码。项目如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224802724-2026925439.png&quot; alt=&quot;1546866490439&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我来详细说下上面的结果作用及代码。&lt;/p&gt;
&lt;ol readability=&quot;18&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;MultiImpDemo.I 这个项目是接口项目，里面有一个简单的接口定义&lt;code&gt;ISayHello&lt;/code&gt;，代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public interface ISayHello
    {
        string Talk();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单，就一个模拟讲话的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;MultiImpDemo.A 这个类库项目是接口的一种实现方式，里面有一个&lt;code&gt;SayHello&lt;/code&gt;类用来实现&lt;code&gt;ISayHello&lt;/code&gt;接口,代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/**
*┌──────────────────────────────────────────────────────────────┐
*│　描    述：                                                    
*│　作    者：yilezhu                                             
*│　版    本：1.0                                                 
*│　创建时间：2019/1/7 17:41:33                             
*└──────────────────────────────────────────────────────────────┘
*┌──────────────────────────────────────────────────────────────┐
*│　命名空间： MultiImpDemo.A                                   
*│　类    名： SayHello                                      
*└──────────────────────────────────────────────────────────────┘
*/
using MultiImpDemo.I;
using System;
using System.Collections.Generic;
using System.Text;

namespace MultiImpDemo.A
{
    public class SayHello : ISayHello
    {
        public string Talk()
        {
            return &quot;Talk from A.SayHello&quot;;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;MultiImpDemo.B 这个类库项目是接口的另一种实现方式，里面也有一个&lt;code&gt;SayHello&lt;/code&gt;类用来实现&lt;code&gt;ISayHello&lt;/code&gt;接口,代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;/**
*┌──────────────────────────────────────────────────────────────┐
*│　描    述：                                                    
*│　作    者：yilezhu                                             
*│　版    本：1.0                                                 
*│　创建时间：2019/1/7 17:41:45                             
*└──────────────────────────────────────────────────────────────┘
*┌──────────────────────────────────────────────────────────────┐
*│　命名空间： MultiImpDemo.B                                   
*│　类    名： SayHello                                      
*└──────────────────────────────────────────────────────────────┘
*/
using MultiImpDemo.I;
using System;
using System.Collections.Generic;
using System.Text;

namespace MultiImpDemo.B
{
    public class SayHello:ISayHello
    {
        public string Talk()
        {
            return &quot;Talk from B.SayHello&quot;;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;MultiImpDemo.Show 这个就是用来显示我们模拟效果的API项目，首选我们在&lt;code&gt;ConfigureServices&lt;/code&gt;中加入如下的代码来进行上述两种实现方式的注入：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; services.AddTransient&amp;lt;ISayHello, MultiImpDemo.A.SayHello&amp;gt;();
 services.AddTransient&amp;lt;ISayHello, MultiImpDemo.B.SayHello&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;在api实现里面获取服务并进行模拟调用：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private readonly ISayHello sayHello;

        public ValuesController(ISayHello sayHello)
        {
            this.sayHello = sayHello;
        }

        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHello.Talk() };
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码很简单对不对？你应该看的懂吧，这时候我们运行起来项目，然后访问API'api/values'这个接口，结果总是显示如下的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224802333-1614503570.png&quot; alt=&quot;1546867091226&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;两种需求对应两种实现&quot;&gt;两种需求对应两种实现&lt;/h2&gt;
&lt;p&gt;这里有两种业务需求！第一种业务中只需要对其中一种实现方式进行调用，如：业务需要SqlServer数据库的实现就行了。第二种是业务中对这两种实现方式都有用到，如：业务急需要用到Oracle的数据库实现同时也有用到SqlServer的数据库实现，需要同时往这两个数据库中插入相同的数据。下面分别对这两种需求进行解决。&lt;/p&gt;
&lt;h3 id=&quot;业务中对这两种实现方式都有用到&quot;&gt;业务中对这两种实现方式都有用到&lt;/h3&gt;
&lt;p&gt;针对这种情况有如下两种实现方式：&lt;/p&gt;
&lt;ol readability=&quot;22.5&quot;&gt;&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;第二种实现方式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实，在ASP.NET Core中，当你对一个接口注册了多个实现的时候，构造函数是可以注入一个该接口集合的，这个集合里是所有注册过的实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面我们先改造下&lt;code&gt;ConfigureServices&lt;/code&gt;,分别注入下这两种实现&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;services.AddTransient&amp;lt;ISayHello, A.SayHello&amp;gt;();
services.AddTransient&amp;lt;ISayHello,B.SayHello&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着继续改造下注入的方式，这里我们直接注入&lt;code&gt;IEnumerable&amp;lt;ISayHello&amp;gt;&lt;/code&gt;如下代码所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private readonly ISayHello sayHelloA;
        private readonly ISayHello sayHelloB;
        public ValuesController(IEnumerable&amp;lt;ISayHello&amp;gt; sayHellos)
        {
            sayHelloA = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == &quot;MultiImpDemo.A&quot;);
            sayHelloB = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == &quot;MultiImpDemo.B&quot;);
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHelloA.Talk() , sayHelloB.Talk()};
        } private readonly ISayHello sayHelloA;
 private readonly ISayHello sayHelloB;
 public ValuesController(IEnumerable&amp;lt;ISayHello&amp;gt; sayHellos)
{
      sayHelloA = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == &quot;MultiImpDemo.A&quot;);
      sayHelloB = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == &quot;MultiImpDemo.B&quot;);
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行起来看下效果吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224802127-1252127746.png&quot; alt=&quot;1546870734607&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;27&quot;&gt;
&lt;p&gt;利用&lt;code&gt;AddTransient&lt;/code&gt;的扩展方法&lt;code&gt;public static IServiceCollection AddTransient&amp;lt;TService&amp;gt;(this IServiceCollection services, Func&amp;lt;IServiceProvider, TService&amp;gt; implementationFactory) where TService : class;&lt;/code&gt; 然后根据我们的配置的实现来进行服务实现的获取。下面就让我们利用代码来实现一番吧：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  services.AddTransient&amp;lt;A.SayHello&amp;gt;();
            services.AddTransient&amp;lt;B.SayHello&amp;gt;();

            services.AddTransient(implementationFactory =&amp;gt;
            {
                Func&amp;lt;string, ISayHello&amp;gt; accesor = key =&amp;gt;
                {
                    if (key.Equals(&quot;MultiImpDemo.A&quot;))
                    {
                        return implementationFactory.GetService&amp;lt;A.SayHello&amp;gt;();
                    }
                    else if (key.Equals(&quot;MultiImpDemo.B&quot;))
                    {
                        return implementationFactory.GetService&amp;lt;B.SayHello&amp;gt;();
                    }
                    else
                    {
                        throw new ArgumentException($&quot;Not Support key : {key}&quot;);
                    }
                };
                return accesor;
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然了，既然用到了我们配置文件中的代码，因此我们需要设置下这个配置：&lt;/p&gt;
&lt;p&gt;然后我们具体调用的依赖注入的方式需要变化一下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;private readonly ISayHello sayHelloA;
        private readonly ISayHello sayHelloB;

        private readonly Func&amp;lt;string, ISayHello&amp;gt; _serviceAccessor;

        public ValuesController(Func&amp;lt;string, ISayHello&amp;gt; serviceAccessor)
        {
            this._serviceAccessor = serviceAccessor;

            sayHelloA = _serviceAccessor(&quot;MultiImpDemoA&quot;);
            sayHelloB = _serviceAccessor(&quot;MultiImpDemoB&quot;);
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHelloA.Talk() , sayHelloB.Talk()};
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后运行看下效果吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224801843-1474916958.png&quot; alt=&quot;1546869793187&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到A跟B的实现都获取到了！效果实现！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;业务只需要对其中一种实现方式的调用&quot;&gt;业务只需要对其中一种实现方式的调用&lt;/h3&gt;
&lt;p&gt;这时候我们可以根据我们预设的配置来动态获取我们所需要的实现。这段话说的我自己都感觉拗口。话不多少，开鲁吧！这里我将介绍三种实现方式。&lt;/p&gt;
&lt;ol readability=&quot;31&quot;&gt;&lt;li readability=&quot;20&quot;&gt;
&lt;p&gt;根据我们的配置文件中设置的key来进行动态的注入。&lt;/p&gt;
&lt;p&gt;这种方式实现之前首先得进行相应的配置，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  &quot;CommonSettings&quot;: {
    &quot;ImplementAssembly&quot;: &quot;MultiImpDemo.A&quot;
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在注入的时候根据配置进行动态的进行注入：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; services.AddTransient&amp;lt;ISayHello, A.SayHello&amp;gt;();
            services.AddTransient&amp;lt;ISayHello, B.SayHello&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在服务调用的时候稍作修改：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private readonly ISayHello sayHello;
        public ValuesController(IEnumerable&amp;lt;ISayHello&amp;gt; sayHellos,IConfiguration configuration)
        {
            sayHello = sayHellos.FirstOrDefault(h =&amp;gt; h.GetType().Namespace == configuration.GetSection(&quot;CommonSettings:ImplementAssembly&quot;).Value);
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHello.Talk() };
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;OK,到这里运行一下看下效果吧！然后改下配置文件再看下效果！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201901/1377250-20190107224801170-951306441.png&quot; alt=&quot;1546871452531&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;第二种实现方式，即接口参数的方式这样可以避免上个方法中反射所带来的性能损耗。&lt;/p&gt;
&lt;p&gt;这里我们改造下接口，接口中加入一个程序集的属性，如下所示：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface ISayHello
    {
        string ImplementAssemblyName { get; }
        string Talk();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的A跟B中的实现代码也要少做调整：&lt;/p&gt;
&lt;p&gt;A:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public string ImplementAssemblyName =&amp;gt; &quot;MultiImpDemo.A&quot;;

        public string Talk()
        {
            return &quot;Talk from A.SayHello&quot;;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;B:&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; public string ImplementAssemblyName =&amp;gt; &quot;MultiImpDemo.B&quot;;

        public string Talk()
        {
            return &quot;Talk from B.SayHello&quot;;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，在实现方法调用的时候稍微修改下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; private readonly ISayHello sayHello;
        public ValuesController(IEnumerable&amp;lt;ISayHello&amp;gt; sayHellos,IConfiguration configuration)
        {
            sayHello = sayHellos.FirstOrDefault(h =&amp;gt; h.ImplementAssemblyName == configuration.GetSection(&quot;CommonSettings:ImplementAssembly&quot;).Value);
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { sayHello.Talk() };
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果自己运行下看下吧！&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;第三种实现是根据配置进行动态的注册&lt;/p&gt;
&lt;p&gt;首先修改下&lt;code&gt;ConfigureServices&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt; var implementAssembly = Configuration.GetSection(&quot;CommonSettings:ImplementAssembly&quot;).Value;
            if (string.IsNullOrWhiteSpace(implementAssembly)) throw new ArgumentNullException(&quot;CommonSettings:ImplementAssembly未配置&quot;);
            if (implementAssembly.Equals(&quot;MultiImpDemo.A&quot;))
            {
                services.AddTransient&amp;lt;ISayHello, A.SayHello&amp;gt;();

            }
            else
            {
                services.AddTransient&amp;lt;ISayHello, B.SayHello&amp;gt;();

            }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的话就会根据我们的配置文件来进行动态的注册，然后我们像往常一样进行服务的调取即可：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;  private readonly ISayHello _sayHello;
        public ValuesController(ISayHello sayHello)
        {
            _sayHello = sayHello;
        }


        // GET api/values
        [HttpGet]
        public ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt; Get()
        {
            return new string[] { _sayHello.Talk() };
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行即可得到我们想要的效果！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文从具体的业务需求入手，根据需求来或动态的进行对应服务的获取，或同时使用两个不同的实现！希望对您有所帮助！如果您有更多的实现方法可以在下方留言，或者加入.NET Core实战千人群跟637326624大伙进行交流，最后感谢您的阅读！&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 14:50:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>最近有个需求就是一个抽象仓储层接口方法需要SqlServer以及Oracle两种实现方式，为了灵活我在依赖注入的时候把这两种实现都给注入进了依赖注入容器中，但是在服务调用的时候总是获取到最后注入的那个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10236163.html</dc:identifier>
</item>
<item>
<title>希望2019不要过得像2018那样 - ChessZhang</title>
<link>http://www.cnblogs.com/yugege/p/10236124.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yugege/p/10236124.html</guid>
<description>&lt;p&gt;本来也懒得写什么总结的，但2018作为自己的本命年，确实发生了一些不同寻常的经历，还是得简单的吹一下水才行。&lt;/p&gt;
&lt;p&gt;在做总结或立flag之前，先回顾一下自己的2018有哪些大事件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;18年初，被临时安排到了Next游戏工作室帮忙，参与了《我的世界》春节版启动器的开发，主要使用React Native。&lt;/li&gt;
&lt;li&gt;春节之后，又回到了自己原来的项目组，整个2018年，几乎都是在做网易大神和逆水寒社区相关需求。&lt;/li&gt;
&lt;li&gt;3月，花了一万多（几乎是自己那时的全部积蓄）买了一台mbp。但是公司不允许自带电脑，就只能放在宿舍，平时主要用来看看视频，有点浪费了，现在欲6k出，需要的私聊，哈哈哈。&lt;/li&gt;
&lt;li&gt;4-6月，这是比较纠结的一段时间，受迫于家里人及女朋友的压力，一直都在为省考复习。报考了老家的国土局，笔试第2名，但是接到面试通知的那一刻，我后悔了，觉得还是喜欢继续做我的程序员，放弃了面试机会，也导致了和女友的矛盾突然加剧。&lt;/li&gt;
&lt;li&gt;7月，参加了第一届中国React开发者大会。会上遇到了腾讯前同事黄琼姐姐，那一刻感觉到，离开腾讯两年时间，自己跟人家的差距是多么的大，她现在已经有能力上去做讲师了，而自己还是一名普通的听众。&lt;/li&gt;
&lt;li&gt;8月，公司年度旅游，本来想着节省点钱，去了菲律宾。结果也不便宜，公司补贴3000，自己还要出4000多。不过，确实深深的喜欢上了菲律宾那淳朴、自然的风情。12月又来了一次~&lt;/li&gt;
&lt;li&gt;9月，刚旅游回来，和大一就相恋、一起五年多的女友分手了，主要原因是职业规则不同，她家里人希望我跟她一起回老家做公务员，而我却想在广州继续做我的程序员。&lt;/li&gt;
&lt;li&gt;分手之后的日子，整个人像走了魂一样，开始了自暴自弃的生活。大四时戒掉的烟瘾又复发了。到香港买了一条软中华，每天下班就抽烟。周末常常约一些朋友去夜店、蒲酒吧之类的。&lt;/li&gt;
&lt;li&gt;颓废了两个多月，11月开始考虑要振作起来了，参加了讯雷区块链沙龙，认识了一些好棒的dalao，跟他们的一些交流中，开始初步了解到一些区块链技术，并从中找到了快乐。&lt;/li&gt;
&lt;li&gt;12月，参与了两次OSC创源会，并在OSC年终盛典做了志愿者，认识了好多志同道合的的伙伴。另外，在老妈的赞助一下，在老家首付20多万买了套属于自己的房子。最后，在12月底又去了一趟菲律宾。&lt;/li&gt;
&lt;li&gt;然后，2018，卒！&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上，就是自己的2018了。&lt;/p&gt;
&lt;p&gt;这一年，技术上，没有什么太大的突破，技术书箱看得少得可怜，只有完整的看了张鑫旭老师的《CSS世界》一书。其他的呢，就研究了Redux及其相关的了些中间件的源码，然后还学习了Webpack4的新特性，然后好像就没有其他了。&lt;/p&gt;
&lt;p&gt;生活上，这一年看了挺多小说，有《傲慢与偏见》、《水知道答案》、《放风筝的人》、《看见》、《解忧杂货店》、《撒哈拉的故事》等，阅读量还是可以的。可是，运动量就少得可怜了，没有坚持跑步，虽然公司离天河公园只有几百米路程，但是大概平均只有两个星期跑一次。此外，虽然公司每周二和周四有免费去华师游泳的福利，上半年还经常去的，但是，后来泳帽弄丢了之后，整个下半年一次都没有去过了。大学比较喜欢打的篮球的，这一年也荒废了，8月买了一个篮球，但是一次没有打过。反而，坏习惯却养成了不少，9月分手之后的日子，抽烟喝酒成为了常态，导致身体素质差了好多啦，年度体检尿酸偏高，心率不齐，已经是病入膏肓了。在这里，也热心的劝一下抽烟喝酒的朋友们，能戒掉就早点戒啦，毕竟那玩意儿除了摧毁你的身体，真的一无是处。（我现在还在努力戒烟戒酒中）&lt;/p&gt;
&lt;p&gt;好啦，总结就写这么多了。新的一年，新的希望，该立一些flag了。&lt;br/&gt;作为一名程序员，发展技术才是硬道理。2019技术上的目标是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拥抱TypeScript，并在项目中使用&lt;/li&gt;
&lt;li&gt;用微信小程序做点东西出来 ，虽然目前还没有这样的工作需求&lt;/li&gt;
&lt;li&gt;深入学习react-native&lt;/li&gt;
&lt;li&gt;学习一下flutter&lt;/li&gt;
&lt;li&gt;学习pwa&lt;/li&gt;
&lt;li&gt;作为一名切图仔，要好好学习一下拍照技术和PS&lt;/li&gt;
&lt;li&gt;多参与沙龙技术，并在争取在沙龙上做一次讲师&lt;/li&gt;
&lt;li&gt;多参与开源项目&lt;/li&gt;
&lt;li&gt;多做技术总结，多写博客&lt;/li&gt;
&lt;li&gt;前端发展太快，就是保持“终身学习”的心态吧&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;生活上：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;早日脱单，遇到对的那个她&lt;/li&gt;
&lt;li&gt;多运动，多打篮球、多游泳、多跑步&lt;/li&gt;
&lt;li&gt;去一趟美国旅行&lt;/li&gt;
&lt;li&gt;把英语当成一门兴趣，好好练习口语&lt;/li&gt;
&lt;li&gt;学会理财&lt;/li&gt;
&lt;li&gt;少玩游戏&lt;/li&gt;
&lt;li&gt;多回家陪家里人&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前人有云：职场，三年一个坎。从17年7月毕业到现在刚好一年半，只剩下一年半的时间去跨越这个所谓的职业坎，正如炉石传说的火车王所言：“时间不多了，我们上吧！”&lt;/p&gt;
&lt;p&gt;好吧，最后，祝大家2019不要过得像2018那样！&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 14:41:00 +0000</pubDate>
<dc:creator>ChessZhang</dc:creator>
<og:description>本来也懒得写什么总结的，但2018作为自己的本命年，确实发生了一些不同寻常的经历，还是得简单的吹一下水才行。 在做总结或立flag之前，先回顾一下自己的2018有哪些大事件： 18年初，被临时安排到了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yugege/p/10236124.html</dc:identifier>
</item>
<item>
<title>【Netty】(8）---ChannelPipeline概念理解 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10234908.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10234908.html</guid>
<description>&lt;p&gt;     ChannelPipeline不是单独存在,它肯定会和Channel、ChannelHandler、ChannelHandlerContext关联在一起,所以有关概念这里一起讲。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、ChannelHandler&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;  1、概念&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt; 先看图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107173400728-1427023893.jpg&quot; alt=&quot;&quot; width=&quot;590&quot; height=&quot;369&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ChannelHandler下主要是两个子接口&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;ChannelInboundHandler(入站):&lt;/span&gt; 处理输入数据和Channel状态类型改变。&lt;/p&gt;
&lt;p&gt;                                      适配器: ChannelInboundHandlerAdapter（适配器设计模式）&lt;/p&gt;
&lt;p&gt;                                      常用的: SimpleChannelInboundHandler&lt;/p&gt;
&lt;p&gt;    &lt;span&gt;ChannelOutboundHandler(出站)&lt;/span&gt;: 处理输出数据&lt;/p&gt;
&lt;p&gt;                                      适配器: ChannelOutboundHandlerAdapter&lt;/p&gt;
&lt;p&gt;每一个Handler都一定会处理出站或者入站(可能两者都处理数据),例如对于入站的Handler可能会继承SimpleChannelInboundHandler或者ChannelInboundHandlerAdapter,&lt;/p&gt;
&lt;p&gt;而SimpleChannelInboundHandler又是继承于ChannelInboundHandlerAdapter，最大的区别在于SimpleChannelInboundHandler会对没有外界引用的资源进行一定的清理,&lt;/p&gt;
&lt;p&gt;并且入站的消息可以通过泛型来规定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里为什么有设配器模式呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      我们在写自定义Handel时候,很少会直接实现上面两个接口,因为接口中有很多默认方法需要实现,所以这里就采用了设配器模式,ChannelInboundHandlerAdapter和&lt;/p&gt;
&lt;p&gt;ChannelInboundHandlerAdapter就是设配器模式的产物,让它去实现上面接口,实现它所有方法。那么你自己写自定义Handel时,只要继承它,就无须重写上面接口的所有方法了。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt; 2、Channel 生命周期(执行顺序也是从上倒下)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;   （1）&lt;span&gt;channelRegistered&lt;/span&gt;: channel注册到一个EventLoop。&lt;/p&gt;
&lt;p&gt;   （2）&lt;span&gt;channelActive&lt;/span&gt;: 变为活跃状态（连接到了远程主机），可以接受和发送数据&lt;/p&gt;
&lt;p&gt;   （3）&lt;span&gt;channelInactive&lt;/span&gt;: channel处于非活跃状态，没有连接到远程主机&lt;/p&gt;
&lt;p&gt;   （4）&lt;span&gt;channelUnregistered&lt;/span&gt;: channel已经创建，但是未注册到一个EventLoop里面，也就是没有和Selector绑定&lt;/p&gt;
&lt;h4&gt;&lt;span&gt; 3、ChannelHandler 生命周期&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      &lt;span&gt;handlerAdded&lt;/span&gt;： 当 ChannelHandler 添加到 ChannelPipeline 调用&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;handlerRemoved&lt;/span&gt;： 当 ChannelHandler 从 ChannelPipeline 移除时调用&lt;/p&gt;
&lt;p&gt; &lt;span&gt;exceptionCaught&lt;/span&gt;： 当 ChannelPipeline 执行抛出异常时调用&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、ChannelPipeline&lt;/span&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;  1、概念&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;先看图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107174428233-1255389580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       ChannelPipeline类是&lt;span&gt;ChannelHandler实例对象的链表，用于处理或截获通道的接收和发送数据&lt;/span&gt;。它提供了一种高级的&lt;span&gt;截取过滤模式&lt;/span&gt;（类似serverlet中的filter功能），让用&lt;/p&gt;
&lt;p&gt;户可以在ChannelPipeline中完全控制一个事件以及如何处理ChannelHandler与ChannelPipeline的交互。&lt;/p&gt;
&lt;p&gt;       对于&lt;span&gt;每个新的通道Channel，都会创建一个新的ChannelPipeline&lt;/span&gt;，并将器pipeline附加到channel中。&lt;/p&gt;
&lt;p&gt;下图描述ChannelHandler与pipeline中的关系，一个io操作可以由一个ChannelInboundHandler或ChannelOutboundHandle进行处理，并通过调用ChannelInboundHandler&lt;/p&gt;
&lt;p&gt;处理入站io或通过ChannelOutboundHandler处理出站IO。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107174742676-39346276.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、常用方法&lt;/span&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
      addFirst(...)   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加ChannelHandler在ChannelPipeline的第一个位置&lt;/span&gt;&lt;span&gt;
     addBefore(...)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在ChannelPipeline中指定的ChannelHandler名称之前添加ChannelHandler&lt;/span&gt;&lt;span&gt;
      addAfter(...)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在ChannelPipeline中指定的ChannelHandler名称之后添加ChannelHandler&lt;/span&gt;&lt;span&gt;
       addLast(...)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在ChannelPipeline的末尾添加ChannelHandler&lt;/span&gt;&lt;span&gt;
        remove(...)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;删除ChannelPipeline中指定的ChannelHandler&lt;/span&gt;&lt;span&gt;
       replace(...)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;替换ChannelPipeline中指定的ChannelHandler&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ChannelPipeline可以动态添加、删除、替换其中的ChannelHandler，这样的机制可以提高灵活性。示例:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
1.    ChannelPipeline pipeline =&lt;span&gt; ch.pipeline(); 
&lt;/span&gt;2.    FirstHandler firstHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FirstHandler(); 
&lt;/span&gt;3.    pipeline.addLast(&quot;handler1&quot;&lt;span&gt;, firstHandler); 
&lt;/span&gt;4.    pipeline.addFirst(&quot;handler2&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecondHandler()); 
&lt;/span&gt;5.    pipeline.addLast(&quot;handler3&quot;, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThirdHandler()); 
&lt;/span&gt;6.    pipeline.remove(&quot;“handler3“&quot;&lt;span&gt;); 
&lt;/span&gt;7&lt;span&gt;.    pipeline.remove(firstHandler); 
&lt;/span&gt;8.    pipeline.replace(&quot;handler2&quot;, &quot;handler4&quot;, &lt;span&gt;new&lt;/span&gt; FourthHandler());&amp;lt;span style=&quot;font-family:Microsoft YaHei;font-size:14px;&quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt; 3、入站出站Handler执行顺序&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  一般的项目中，inboundHandler和outboundHandler有多个，在Pipeline中的执行顺序？&lt;/p&gt;
&lt;p&gt;   重点记住: &lt;span&gt;InboundHandler顺序执行&lt;/span&gt;，&lt;span&gt;OutboundHandler逆序执行&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;   &lt;span&gt;问题&lt;/span&gt;: 下面的handel的执行顺序？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
          ch.pipeline().addLast(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InboundHandler1());
          ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutboundHandler1());
          ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutboundHandler2());
          ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InboundHandler2());
  或者：
          ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutboundHandler1());
          ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OutboundHandler2());
          ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; InboundHandler1());
          ch.pipeline().addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; InboundHandler2());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实上面的执行顺序都是一样的:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 InboundHandler1--&amp;gt; InboundHandler2 --&amp;gt;OutboundHandler2 --&amp;gt;OutboundHandler1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      1）InboundHandler顺序执行，OutboundHandler逆序执行&lt;/p&gt;
&lt;p&gt;      2）InboundHandler之间传递数据，通过&lt;span&gt;ctx.fireChannelRead(msg)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      3）InboundHandler通过&lt;span&gt;ctx.write(msg)&lt;/span&gt;，则会传递到outboundHandler&lt;/p&gt;
&lt;p&gt;      4)  使用ctx.write(msg)传递消息，Inbound需要放在结尾，在Outbound之后，不然outboundhandler会不执行；&lt;/p&gt;
&lt;p&gt;           但是使用channel.write(msg)、pipline.write(msg)情况会不一致，都会执行,那是因为channel和pipline会贯穿整个流。&lt;/p&gt;
&lt;p&gt;      5)  outBound和Inbound谁先执行，针对客户端和服务端而言，&lt;span&gt;客户端是发起请求再接受数据，先outbound再inbound，服务端则相反&lt;/span&gt;。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三、ChannelHandlerContext&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    ChannelPipeline并不是直接管理ChannelHandler，而是通过ChannelHandlerContext来间接管理&lt;/span&gt;，这一点通过ChannelPipeline的默认实现DefaultChannelPipeline可以看出来。&lt;/p&gt;
&lt;p&gt;    DefaultChannelHandlerContext和DefaultChannelPipeline是ChannelHandlerContext和ChannelPipeline的默认实现在DefaultPipeline内部&lt;/p&gt;
&lt;p&gt;DefaultChannelHandlerContext组成了一个双向链表。 我们看下DefaultChannelPipeline的构造函数:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * 可以看到,DefaultChinnelPipeline 内部使用了两个特殊的Hander 来表示Handel链的头和尾。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DefaultChannelPipeline(AbstractChannel channel) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channel == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;channel&quot;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.channel =&lt;span&gt; channel;
 
        TailHandler tailHandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TailHandler();
        tail &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DefaultChannelHandlerContext(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, generateName(tailHandler), tailHandler);
 
        HeadHandler headHandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HeadHandler(channel.unsafe());
        head &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DefaultChannelHandlerContext(&lt;span&gt;this&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, generateName(headHandler), headHandler);
 
        head.next &lt;/span&gt;=&lt;span&gt; tail;
        tail.prev &lt;/span&gt;=&lt;span&gt; head;
    }&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以对于DefaultChinnelPipeline它的Handel头部和尾部的Handel是固定的,我们所添加的Handel是添加在这个头和尾之前的Handel。（下面这个图更加清晰）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107182524986-296107070.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、几者关系&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;先大致说下什么是Channel&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通常来说, 所有的 NIO 的 I/O 操作都是从 Channel 开始的. 一个 channel 类似于一个 stream。在Netty中,&lt;span&gt;Channel是客户端和服务端建立的一个连接通道&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;虽然java Stream 和 NIO Channel都是负责I/O操作,但他们还是有许多区别的:&lt;/p&gt;
&lt;p&gt;      1）我们可以在&lt;span&gt;同一个 Channel 中执行读和写操作, 然而同一个 Stream 仅仅支持读或写&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;     2）&lt;span&gt;Channel 可以异步地读写, 而 Stream 是阻塞的同步读写&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;     3）Channel 总是&lt;span&gt;从 Buffer 中读取数据, 或将数据写入到 Buffer 中&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt; 几者的关系图如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107182913543-217821213.jpg&quot; alt=&quot;&quot; width=&quot;733&quot; height=&quot;369&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      一个Channel包含一个ChannelPipeline，创建Channel时会自动创建一个ChannelPipeline，每个Channel都有一个管理它的pipeline，这关联是永久性的。&lt;/p&gt;
&lt;p&gt;这点从源码中就可以看出,我之前写的博客里有说到:&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/10105887.html&quot; target=&quot;_blank&quot;&gt;【Netty】5 源码 Bootstrap&lt;/a&gt;。每一个ChannelPipeline中可以包含多个ChannelHandler。所有ChannelHandler&lt;/p&gt;
&lt;p&gt;都会顺序加入到ChannelPipeline中,ChannelHandler实例与ChannelPipeline之间的桥梁是ChannelHandlerContext实例。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;五、整个传播流程&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;     现在将上面的整个传播流程,通过源码大致走一遍。&lt;/p&gt;
&lt;p&gt;     为了搞清楚事件如何在Pipeline里传播，让我们从Channel的抽象子类AbstractChannel开始，下面是AbstractChannel#write()方法的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; AbstractChannel &lt;span&gt;extends&lt;/span&gt; DefaultAttributeMap &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Channel {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Channel write(Object msg) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pipeline.write(msg);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     AbstractChannel直接调用了Pipeline的write()方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107183731295-1479944799.png&quot; alt=&quot;&quot; width=&quot;836&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看DefaultChannelPipeline的write()方法实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultChannelPipeline &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ChannelPipeline {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelFuture write(Object msg) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tail.write(msg);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为write是个outbound事件，所以DefaultChannelPipeline直接找到tail部分的context，调用其write()方法：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107183900471-1993188721.png&quot; alt=&quot;&quot; width=&quot;853&quot; height=&quot;255&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着看DefaultChannelHandlerContext的write()方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DefaultChannelHandlerContext &lt;span&gt;extends&lt;/span&gt; DefaultAttributeMap &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ChannelHandlerContext {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ChannelFuture write(Object msg) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; write(msg, newPromise());
    }
 
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ChannelFuture write(&lt;span&gt;final&lt;/span&gt; Object msg, &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ChannelPromise promise) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (msg == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&quot;msg&quot;&lt;span&gt;);
        }
 
        validatePromise(promise, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
 
        write(msg, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;, promise);
 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; promise;
    }
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(Object msg, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; flush, ChannelPromise promise) {
        DefaultChannelHandlerContext next &lt;/span&gt;=&lt;span&gt; findContextOutbound();
        next.invokeWrite(msg, promise);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flush) {
            next.invokeFlush();
        }
    }
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; DefaultChannelHandlerContext findContextOutbound() {
        DefaultChannelHandlerContext ctx &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
            ctx &lt;/span&gt;=&lt;span&gt; ctx.prev;
        } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;ctx.outbound);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ctx;
    }
 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; invokeWrite(Object msg, ChannelPromise promise) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            ((ChannelOutboundHandler) handler).write(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, msg, promise);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
            notifyOutboundHandlerException(t, promise);
        }
    }
 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;context的write()方法沿着context链往前找，直至找到一个outbound类型的context为止，然后调用其invokeWrite()方法&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107184035723-844989140.png&quot; alt=&quot;&quot; width=&quot;754&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  invokeWrite()接着调用handler的write()方法&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107184136647-832347333.png&quot; alt=&quot;&quot; width=&quot;764&quot; height=&quot;331&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后看看ChannelOutboundHandlerAdapter的write()方法实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ChannelOutboundHandlerAdapter &lt;span&gt;extends&lt;/span&gt; ChannelHandlerAdapter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ChannelOutboundHandler {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        ctx.write(msg, promise);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 默认的实现调用了context的write()方法而不做任何处理，这样write事件就沿着outbound链继续传播：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190107184246743-1726416842.png&quot; alt=&quot;&quot; width=&quot;803&quot; height=&quot;349&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，Pipeline的事件传播，是靠Pipeline，Context和Handler共同协作完成的。&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;参考 &lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;title-article&quot;&gt;   &lt;a href=&quot;https://blog.csdn.net/zxhoo/article/details/17264263&quot; target=&quot;_blank&quot;&gt;Netty4学习笔记-- ChannelPipeline&lt;/a&gt;（非常感谢作者分享,让我对事件传播有了更清晰的认识）&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如果一个人充满快乐，正面的思想，那么好的人事物就会和他共鸣，而且被他吸引过来。同样，一个人老带悲伤，倒霉的事情也会跟过来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                                    ——在自己心情低落的时候，告诫自己不要把负能量带给别人。（大校18） &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 07 Jan 2019 14:26:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>ChannelPipeline ChannelPipeline不是单独存在,它肯定会和Channel、ChannelHandler、ChannelHandlerContext关联在一起,所以有关概念这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10234908.html</dc:identifier>
</item>
<item>
<title>敏捷开发-Scrum介绍 - 朝阳小胖</title>
<link>http://www.cnblogs.com/nelson2013/p/10235980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nelson2013/p/10235980.html</guid>
<description>&lt;p&gt;更多请关注微信公众号 SystemEngineeringLab&lt;br/&gt;&lt;img src=&quot;https://github.com/nixxyahoocn/resources/blob/master/imgs/common/weixin.png?raw=true&quot; alt=&quot;SystemEngineeringLab&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Scrum Guide: &lt;a href=&quot;https://www.scrumguides.org/scrum-guide.html&quot; class=&quot;uri&quot;&gt;https://www.scrumguides.org/scrum-guide.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Scrum是一种敏捷过程框架，不同于其他敏捷开发方法，Scrum不仅仅适用于软件开发领域。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Deliver the highest business value in the shorttest time&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Scrum的目标是“交付最高的商业价值，通过尽量短的时间”。用英文表达可能更准确一些，中文的语义比较容易混淆。Scrum的目标并不是“在最短的时间内交付最高的商业价值”，它强调的不是最短的时间，而是价值。我们关注的是如何在交付最高价值的前提下花费更少的时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3 个工件&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Product Backlog&lt;br/&gt;Sprint Backlog&lt;br/&gt;Product Increment&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;3 个角色&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Product Owner&lt;br/&gt;Scrum Master&lt;br/&gt;Development Team&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;5 个价值观&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;勇气 专注 承诺 尊重 开放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;5 个事件&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Sprint、Sprint Planning、Daily Scrum、Sprint Review、Spring Retrospective&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;价值观&quot;&gt;2.1 价值观&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190107220836377-796085358.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;勇气：面对难题团队成员都有勇气做正确的事情和工作&lt;br/&gt;专注: 团队成员要专注于冲刺要完成的工作以及团队目标&lt;br/&gt;承诺: 团队成员对完成Sprint目标做出承诺&lt;br/&gt;尊重：团队成员之间都尊重对方是有能力的、独立的人&lt;br/&gt;开放：Scrum团队以及利益相关者对所有的工作以及完成工作所面临的挑战的开放性一致认同。&lt;/p&gt;
&lt;h2 id=&quot;角色&quot;&gt;2.2 角色&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190107220537449-314716469.jpg&quot;/&gt;&lt;br/&gt;Scrum核心框架包含三个角色，即PO、SM、DevTeam。与传统的开发方法不同，Scrum的研发团队不再有细分的例如系统架构师、后端工程师、前端工程师、UI工程师等角色，而是将整个开发团队统一在了“Development Team”这一Scrum角色下。以上三个角色构成了 &quot;Scrum Team&quot;。&lt;/p&gt;
&lt;h3 id=&quot;product-owner&quot;&gt;Product Owner&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;关键职责&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;为Product Backlog负责&lt;/li&gt;
&lt;li&gt;为投资回报率负责&lt;br/&gt;&lt;strong&gt;关键属性:&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;是利益相关者和客户的代表&lt;/li&gt;
&lt;li&gt;只能由一个人担任&lt;/li&gt;
&lt;li&gt;有绝对的决策权&lt;/li&gt;
&lt;li&gt;随时能够被团队找到&lt;/li&gt;
&lt;li&gt;决定产品发布日期和内容&lt;/li&gt;
&lt;li&gt;不能兼任Scrum Master&lt;/li&gt;
&lt;li&gt;根据业务价值和重要性为PBI排序&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;能够决定Sprint是否取消&lt;/p&gt;
&lt;h3 id=&quot;scrum-master&quot;&gt;Scrum Master&lt;/h3&gt;
&lt;strong&gt;职责&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;促进Scrum的进行，为开发团队移除障碍&lt;br/&gt;&lt;strong&gt;特征：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;没有权利&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务型领导&lt;/p&gt;
&lt;h3 id=&quot;development-team&quot;&gt;Development Team&lt;/h3&gt;
&lt;strong&gt;职责&lt;/strong&gt;&lt;br/&gt;DevTeam的职责就是实现Sprint目标，在每个Sprint结束交付可潜在发布的产品增量。&lt;br/&gt;&lt;strong&gt;特征：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;自组织&lt;/li&gt;
&lt;li&gt;跨职能：团队是跨职能的，具备交付产品所需要的所有能力&lt;/li&gt;
&lt;li&gt;同地协作&lt;/li&gt;
&lt;li&gt;T型人才，成员具备“一专多通”的特点&lt;/li&gt;
&lt;li&gt;没有头衔，大家都是平等的团队成员&lt;/li&gt;
&lt;li&gt;开发团队的成员必须是全职参与&lt;/li&gt;
&lt;li&gt;人数范围3-9人：人数不宜过多或过少。过少的团队无法具备跨职能的要求，过多的团队降低沟通效率&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;没有子团队：团队是平级团队，子团队增加了沟通的成本&lt;/p&gt;
&lt;h2 id=&quot;工件&quot;&gt;2.3 工件&lt;/h2&gt;
&lt;h3 id=&quot;产品清单---product-backlog&quot;&gt;产品清单 - Product Backlog&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Product Backlog是已排序的产品需求列表，它定义了最终要交付什么(What)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Product Owner 对Product Backlog负责，其有权决定产品清单的内容，例如哪些需要纳入产品清单、哪些需要修改、哪些需要删除、哪些PBI(Product Backlog Item)优先级需要调整。大多数的PBI对客户有实际的业务价值，有些可能针对客户来说没有直接的业务价值。原则上PO认为PBI对整个产品的交付是有价值的，那么它也可以放入PBL.&lt;br/&gt;PBI最常见的表述形式是&lt;strong&gt;用户故事&lt;/strong&gt;，但这不是绝对的。用户故事本身不是Scrum框架的一部分，Scrum并没有要求PBI的表现形式，用户可以使用用户故事、用例或其他有意义的格式均可。&lt;br/&gt;好的Product Backlog遵循 &lt;strong&gt;DEEP&lt;/strong&gt; 原则&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Detailed appropriately - 详略得当&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;PBI的表述要详略得当，近期要做的PBI要足够详细，以便团队能够清晰的认识需求。同时，PBI的粒度要足够小，能够放到一个冲刺中执行。&lt;/li&gt;
&lt;li&gt;越靠近PBL顶端的PBI要越详细且粒度越小，越靠近底部的PBI粒度越大。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Emergent - 涌现式的&lt;br/&gt;产品清单是动态的，随着对产品认识的深入，以及产品内外部环境的变化，已有的PBI可能会被修改、废弃，新的PBI会被加入到产品清单，因此，PBL是一个会被持续更新动态需求池。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Estimated - 已估算的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Prioritized - 已排序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sprint-backlog&quot;&gt;Sprint Backlog&lt;/h3&gt;
&lt;p&gt;SBL是在当前冲刺中开发团队需要完成的工作任务列表，有点像传统开发方法中的WBS，这是DevTeam对实现PBI所做出的承诺。在冲刺计划会议中，DevTeam要对当前迭代所选择的PBI进行任务拆解，细化为具体的工作任务，足以支撑实现这些PBIs。&lt;br/&gt;Spring Backlog的形式有多样，可以采用看板、电子表格或专门的在线系统进行记录和追踪。同时，拆分后的任务和PBI的对应关系也要一同记录&lt;/p&gt;
&lt;h3 id=&quot;产品增量---product-increment&quot;&gt;产品增量 - Product Increment&lt;/h3&gt;
&lt;p&gt;Potentially Shippable Increment，PSI&lt;br/&gt;冲刺中所完成的所有的PBI的总和，在冲刺结束时作为产品增量交付。增量是稳定的、可工作的产品组成部分。冲刺中没有完成的部分不纳入增量。&lt;/p&gt;
&lt;h2 id=&quot;事件&quot;&gt;2.4 事件&lt;/h2&gt;
&lt;p&gt;冲刺 - Sprint&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Spring的目标是完成可潜在可交付的产品增量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;Scrum的核心，也是Scrum开发方法中的基本单元&lt;/li&gt;
&lt;li&gt;固定的时间盒&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Sprint是一个容器，以冲刺计划开始，以冲刺评审和冲刺回顾结束&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;冲刺计划 - Sprint Planning&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;确定当前冲刺所要完成的工作范围&lt;/li&gt;
&lt;li&gt;从Product Backlog中选择当前冲刺需要完成的PBI&lt;/li&gt;
&lt;li&gt;确定Sprint Backlog，以支撑所选的PBIs&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;以两周的冲刺为例，建议会议时间为4小时&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;每日站会 - Daily Scrum&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;开发团队成员必须到场，PO 和SM可选参加&lt;/li&gt;
&lt;li&gt;欢迎其他人参加每日站会，但只允许开发团队成员发言
&lt;ul&gt;&lt;li&gt;每天同一时间、同一地点&lt;/li&gt;
&lt;li&gt;准时开始，即使有开发团队成员缺席&lt;/li&gt;
&lt;li&gt;控制在15分钟以内&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;会议模式基于三个问题：
&lt;ul&gt;&lt;li&gt;昨天&lt;strong&gt;完成&lt;/strong&gt;了什么&lt;/li&gt;
&lt;li&gt;今天准备&lt;strong&gt;完成&lt;/strong&gt;什么&lt;/li&gt;
&lt;li&gt;遇到了什么&lt;strong&gt;障碍&lt;/strong&gt;阻碍了自己或团队达成冲刺目标&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;冲刺评审 - Sprint Review&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;评审的目的并不在于评价已完成产品增量的好坏，更不是在没有达到既定要求时的批判和追责。评审的本质在于通过现场的交流和演示，获得利益相关者对产品增量的反馈！反馈！反馈！&lt;br/&gt;主要内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;审视已经完成的工作以及已经计划但是没有完成的工作&lt;/li&gt;
&lt;li&gt;向利益相关者展示已经完成的工作（Demo）&lt;/li&gt;
&lt;li&gt;与利益相关者协作，进一步明确后续要做的工作&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;冲刺回顾 - Sprint Retrospective&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回顾会议的精髓在于检视和调整，以期持续改进：&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;回顾已经过去的冲刺&lt;/li&gt;
&lt;li&gt;识别持续改进的行动项并达成一致&lt;br/&gt;典型的会议内容：&lt;/li&gt;
&lt;li&gt;三个主要问题：
&lt;ul&gt;&lt;li&gt;在当前冲刺中，哪些做的好？&lt;/li&gt;
&lt;li&gt;在当前冲刺中，哪些做的不好？&lt;/li&gt;
&lt;li&gt;为了提高生产力，在下一个冲刺中哪些需要改进？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;以两周的冲刺为例，建议时间为一个半小时&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;回顾会议由SM负责推进&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190107220631074-1705293293.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Scrum的工作流以Sprint为核心，通过迭代和增量的方式逐步完成最终产品的交付。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;产品需求被汇总到Product Backlog，PO依据业务价值、重要性等对PBI进行排序。&lt;/li&gt;
&lt;li&gt;冲刺会议标志着Sprint的正式开始，团队对输入的PBL进行选择，确定本次冲刺所需要完成的PBI。DevTeam基于所确定的PBI进行任务拆分，形成Sprint Backlog。&lt;/li&gt;
&lt;li&gt;DevTeam执行开发过程，交付潜在可发布的产品增量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Scrum不是具体的敏捷方法，它通过价值观、角色、工件和事件等要为我们搭建了一个骨架，但骨架内填充的内容就需要具体情况具体分析了。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/557590/201901/557590-20190107220737126-401527950.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同其他敏捷开发方法不同的是Scrum更具有普适性，它不仅仅适用于软件开发领域。&lt;br/&gt;本文主要是对Scrum框架的核心元素进行了总结和记录，理论看戏去简单，但落地Scrum却不容易，尤其是结合不同行业的工程实践更加导致Scrum落地的复杂性，而这也恰恰是Scrum实践者所需要攻坚的问题。&lt;/p&gt;

&lt;p&gt;这已经是关于敏捷的第二篇博文了，基本上对敏捷和Scrum做了基本的介绍，后续的博文我们更关注如何在汽车行业中实施敏捷。&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 14:10:00 +0000</pubDate>
<dc:creator>朝阳小胖</dc:creator>
<og:description>Scrum是一种敏捷过程框架，不同于其他敏捷开发方法，Scrum不仅仅适用于软件开发领域。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nelson2013/p/10235980.html</dc:identifier>
</item>
<item>
<title>Java多线程之Executor框架和手写简易的线程池 - 宁愿呢</title>
<link>http://www.cnblogs.com/liyus/p/10235942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liyus/p/10235942.html</guid>
<description>&lt;h4 id=&quot;目录&quot;&gt;目录&lt;/h4&gt;
&lt;h2 id=&quot;线程池&quot;&gt;线程池&lt;/h2&gt;
&lt;h3 id=&quot;什么是线程池&quot;&gt;什么是线程池&lt;/h3&gt;
&lt;p&gt;线程池一种线程使用模式，线程池会维护多个线程，等待着分配可并发执行的任务，当有任务需要线程执行时，从线程池中分配线程给该任务而不用主动的创建线程。&lt;/p&gt;
&lt;h3 id=&quot;线程池的好处&quot;&gt;线程池的好处&lt;/h3&gt;
&lt;p&gt;如果在我们平时如果需要用到线程时，我们一般是这样做的：创建线程(T1)，使用创建的线程来执行任务(T2)，任务执行完成后销毁当前线程(T3)，这三个阶段是必须要有的。&lt;/p&gt;
&lt;p&gt;而如果使用线程池呢？&lt;/p&gt;
&lt;p&gt;线程池会预先创建好一定数量的线程，需要的时候申请使用，在一个任务执行完后也不需要将该线程销毁，很明显的节省了T1和T3这两阶段的时间。&lt;/p&gt;
&lt;p&gt;同时我们的线程由线程池来统一进行管理，这样也提高了线程的可管理性。&lt;/p&gt;
&lt;h3 id=&quot;手写一个自己的线程池&quot;&gt;手写一个自己的线程池&lt;/h3&gt;
&lt;p&gt;现在我们可以简单的理解为线程池实际上就是存放多个线程的数组，在程序启动是预先实例化一定得线程实例，当有任务需要时分配出去。现在我们先来写一个自己的线程池来理解一下线程池基本的工作过程。&lt;/p&gt;
&lt;h4 id=&quot;线程池需要些什么&quot;&gt;线程池需要些什么？&lt;/h4&gt;
&lt;p&gt;首先线程池肯定需要一定数量的线程，所以首先需要一个&lt;strong&gt;线程数组&lt;/strong&gt;，当然也可以是一个集合。&lt;/p&gt;
&lt;p&gt;线程数组是用来进行存放线程实例的，要使用这些线程就需要有任务提交过来。当任务量过大时，我们是不可能在同一时刻给所有的任务分配一个线程的，所以我们还需要一个用于&lt;strong&gt;存放任务的容器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里的预先&lt;strong&gt;初始化线程实例的数量&lt;/strong&gt;也需要我们来根据业务确定。&lt;/p&gt;
&lt;p&gt;同时线程实例的数量也不能随意的定义，所以我们还需要设置一个&lt;strong&gt;最大线程数&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //线程池中允许的最大线程数
    private static int MAXTHREDNUM = Integer.MAX_VALUE;
    //当用户没有指定时默认的线程数
    private  int threadNum = 6;
    //线程队列，存放线程任务
    private List&amp;lt;Runnable&amp;gt; queue;

    private WorkerThread[] workerThreads;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;线程池工作&quot;&gt;线程池工作&lt;/h4&gt;
&lt;p&gt;线程池的线程一般需要预先进行实例化，这里我们通过构造函数来模拟这个过程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public MyThreadPool(int threadNum) {
        this.threadNum = threadNum;
        if(threadNum &amp;gt; MAXTHREDNUM)
            threadNum = MAXTHREDNUM;
        this.queue = new LinkedList&amp;lt;&amp;gt;();
        this.workerThreads = new WorkerThread[threadNum];
        init();
    }

    //初始化线程池中的线程
 private void init(){
    for(int i=0;i&amp;lt;threadNum;i++){
        workerThreads[i] = new WorkerThread();
        workerThreads[i].start();
    }
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在线程池准备好了后，我们需要像线程池中提交工作任务，任务统一提交到队列中，当有任务时，自动分发线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //提交任务
    public void execute(Runnable task){
        synchronized (queue){
            queue.add(task);
            //提交任务后唤醒等待在队列的线程
            queue.notifyAll();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的工作线程为了获取任务，需要一直监听任务队列，当队列中有任务时就由一个线程去执行，这里我们用到了前面提到的安全中断。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private class WorkerThread extends Thread {

    private volatile boolean on = true;
    @Override
    public void run() {
        Runnable task = null;
        //判断是否可以取任务
        try {
            while(on&amp;amp;&amp;amp;!isInterrupted()){
                synchronized (queue){
                    while (on &amp;amp;&amp;amp; !isInterrupted() &amp;amp;&amp;amp; queue.isEmpty()) {
                        //这里如果使用阻塞队列来获取在执行时就不会报错
                        //报错是因为退出时销毁了所有的线程资源，不影响使用
                        queue.wait(1000);
                    }
                    if (on &amp;amp;&amp;amp; !isInterrupted() &amp;amp;&amp;amp; !queue.isEmpty()) {
                        task = queue.remove(0);
                    }

                    if(task !=null){
                        //取到任务后执行
                        task.run();
                    }
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        task = null;//任务结束后手动置空，加速回收
    }

    public void cancel(){
        on = false;
        interrupt();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然退出时还需要对线程池中的线程等进行销毁。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //销毁线程池
    public void shutdown(){
        for(int i=0;i&amp;lt;threadNum;i++){
            workerThreads[i].cancel();
            workerThreads[i] = null;
        }
        queue.clear();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好了，到这里我们的一个简易版的线程池就完成了，功能虽然不多但是线程池运行的基本原理差不多实现了，实际上非常简单，我们来写个程序测试一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadPoolTest {
    public static void main(String[] args) throws InterruptedException {
        // 创建3个线程的线程池
        MyThreadPool t = new MyThreadPool(3);
        CountDownLatch countDownLatch = new CountDownLatch(5);
        t.execute(new MyTask(countDownLatch, &quot;testA&quot;));
        t.execute(new MyTask(countDownLatch, &quot;testB&quot;));
        t.execute(new MyTask(countDownLatch, &quot;testC&quot;));
        t.execute(new MyTask(countDownLatch, &quot;testD&quot;));
        t.execute(new MyTask(countDownLatch, &quot;testE&quot;));
        countDownLatch.await();
        Thread.sleep(500);
        t.shutdown();// 所有线程都执行完成才destory
        System.out.println(&quot;finished...&quot;);
    }

    // 任务类
    static class MyTask implements Runnable {

        private CountDownLatch countDownLatch;
        private String name;
        private Random r = new Random();

        public MyTask(CountDownLatch countDownLatch, String name) {
            this.countDownLatch = countDownLatch;
            this.name = name;
        }

        public String getName() {
            return name;
        }

        @Override
        public void run() {// 执行任务
            try {
                countDownLatch.countDown();
                Thread.sleep(r.nextInt(1000));
                System.out.println(&quot;任务 &quot; + name + &quot; 完成&quot;);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getId()+&quot; sleep InterruptedException:&quot;
                        +Thread.currentThread().isInterrupted());
            }
        }
    }
}

result：
任务 testA 完成
任务 testB 完成
任务 testC 完成
任务 testD 完成
任务 testE 完成
finished...
java.lang.InterruptedException
    at java.lang.Object.wait(Native Method)
    at com.learn.threadpool.MyThreadPool$WorkerThread.run(MyThreadPool.java:75)
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从结果可以看到我们提交的任务都被执行了，当所有任务执行完成后，我们强制销毁了所有线程，所以会抛出异常。&lt;/p&gt;
&lt;h3 id=&quot;jdk中的线程池&quot;&gt;JDK中的线程池&lt;/h3&gt;
&lt;p&gt;上面我们实现了一个简易的线程池，稍微理解线程池的基本运作原理。现在我们来认识一些JDK中提供了线程池吧。&lt;/p&gt;
&lt;h4 id=&quot;threadpoolexecutor&quot;&gt;ThreadPoolExecutor&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadPoolExecutor extends AbstractExecutorService&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ThreadPoolExecutor是一个ExecutorService ，使用可能的几个合并的线程执行每个提交的任务，通常使用Executors工厂方法配置，通过Executors可以配置多种适合不同场景的线程池。&lt;/p&gt;
&lt;h5 id=&quot;threadpoolexecutor中的主要参数&quot;&gt;ThreadPoolExecutor中的主要参数&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, RejectedExecutionHandler handler) &lt;/code&gt;
&lt;/pre&gt;
&lt;h6 id=&quot;corepoolsize&quot;&gt;corePoolSize&lt;/h6&gt;
&lt;p&gt;线程池中的核心线程数，当外部提交一个任务时，线程池就创建一个新线程执行任务，直到当前线程数等于corePoolSize时不再创建新线程；&lt;br/&gt;如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；&lt;br/&gt;如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。&lt;/p&gt;
&lt;h6 id=&quot;maximumpoolsize&quot;&gt;maximumPoolSize&lt;/h6&gt;
&lt;p&gt;线程池中允许的最大线程数。如果当前阻塞队列已满，还在继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。&lt;/p&gt;
&lt;h6 id=&quot;keepalivetime&quot;&gt;keepAliveTime&lt;/h6&gt;
&lt;p&gt;线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间。默认情况下，线程一般不会被销毁，该参数只在线程数大于corePoolSize时才有用。&lt;/p&gt;
&lt;h6 id=&quot;workqueue&quot;&gt;workQueue&lt;/h6&gt;
&lt;p&gt;workQueue必须是阻塞队列。当线程池中的线程数超过corePoolSize的时候，线程会进入阻塞队列进行等待。阻塞队列可以使有界的也可以是无界的。&lt;/p&gt;
&lt;h6 id=&quot;threadfactory&quot;&gt;threadFactory&lt;/h6&gt;
&lt;p&gt;创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个线程名。Executors静态工厂里默认的threadFactory，线程的命名规则是“pool-{数字}-thread-{数字}”。&lt;/p&gt;
&lt;h6 id=&quot;rejectedexecutionhandler&quot;&gt;RejectedExecutionHandler&lt;/h6&gt;
&lt;p&gt;线程池的饱和处理策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;AbortPolicy：直接抛出异常，默认的处理策略&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：使用调用者所属的线程来执行当前任务&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务&lt;/li&gt;
&lt;li&gt;DiscardPolicy：直接丢弃该任务&lt;br/&gt;如果上述提供的处理策略无法满足业务需求，也可以根据场景实现RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;threadpoolexecutor中的主要执行流程&quot;&gt;ThreadPoolExecutor中的主要执行流程&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/1/7/168289bbf5fe5531?w=793&amp;amp;h=382&amp;amp;f=png&amp;amp;s=123645&quot; alt=&quot;线程池&quot;/&gt;&lt;/p&gt;
&lt;p&gt;//图片来自网络&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程池判断核心线程池里的线程(corePoolSize)是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入2。&lt;/li&gt;
&lt;li&gt;线程池判断工作队列(workQueue)是否已满。如果工作队列没有满，则将新提交的任务存储在该队列里。如果工作队列满了，则进入3。&lt;/li&gt;
&lt;li&gt;线程池判断线程池的线程(maximumPoolSize)是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里需要注意的是核心线程池大小指得是corePoolSize参数，而线程池工作线程数指的是maximumPoolSize。&lt;/p&gt;
&lt;h3 id=&quot;executor&quot;&gt;Executor&lt;/h3&gt;
&lt;p&gt;实际上我们在使用线程池时，并不一定需要自己来定义上面介绍的参数的值，JDK为我们提供了一个调度框架。通过这个调度框架我们可以轻松的创建好线程池以及异步的获取任务的执行结果。&lt;/p&gt;
&lt;h4 id=&quot;调度框架的组成&quot;&gt;调度框架的组成&lt;/h4&gt;
&lt;h5 id=&quot;任务&quot;&gt;任务&lt;/h5&gt;
&lt;p&gt;一般是指需要被执行的任务，多为使用者提供。被提交的任务需要实现Runnable接口或Callable接口。&lt;/p&gt;
&lt;h5 id=&quot;任务的执行&quot;&gt;任务的执行&lt;/h5&gt;
&lt;p&gt;Executor是任务执行机制的核心接口，其将任务的提交和执行分离开来。ExecutorService继承了Executor并做了一些扩展，可以产生Future为跟踪一个或多个异步任务执行。任务的执行主要是通过实现了Executor和ExecutorService接口的类来进行实现。例如：ThreadPoolExecutor和ScheduledThreadPoolExecutor。&lt;/p&gt;
&lt;h5 id=&quot;结果获取&quot;&gt;结果获取&lt;/h5&gt;
&lt;p&gt;对结果的获取可以通过Future接口以及其子类接口来实现。Future接口提供了一系列诸如检查是否就绪，是否执行完成，阻塞以及获取结果等方法。&lt;/p&gt;
&lt;h4 id=&quot;executors工厂中的线程池&quot;&gt;Executors工厂中的线程池&lt;/h4&gt;
&lt;h5 id=&quot;fixedthreadpool&quot;&gt;FixedThreadPool&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;new ThreadPoolExecutor(nThreads, nThreads, 0L, 
                        TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该线程池中corePoolSize和maximumPoolSize参数一致。同时使用无界阻塞队列，将会导致maximumPoolSize和keepAliveTime已经饱和策略无效，因为队列会一直接收任务，直到OOM。&lt;/p&gt;
&lt;h5 id=&quot;singlethreadexecutor&quot;&gt;SingleThreadExecutor&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该线程池中corePoolSize和maximumPoolSize都为1，表示始终只有一个线程在工作，适用于需要保证顺序地执行各个任务；并且在任意时间点，不会有多个线程是活动的应用场景。同时使用无界阻塞队列，当任务多时极有可能OOM。&lt;/p&gt;
&lt;h5 id=&quot;cachedthreadpool&quot;&gt;CachedThreadPool&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS,
                                      new SynchronousQueue&amp;lt;Runnable&amp;gt;()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CachedThreadPool类型的线程池corePoolSize为0，表示任务将会提交给队列，但是SynchronousQueue又是一个不包含任何容量的队列。所以每一个任务提交过来都会创建一个新的线程来执行，该类型的线程池适用于执行很多的短期异步任务的程序，或者是负载较轻的服务器。如果当任务的提交速度一旦超过任务的执行速度，在极端情况下可能会因为创建过多线程而耗尽CPU和内存资源。&lt;/p&gt;
&lt;h5 id=&quot;scheduledthreadpool&quot;&gt;ScheduledThreadPool&lt;/h5&gt;
&lt;p&gt;对于定时任务类型的线程池，Executor可以创建两种不同类型的线程池：ScheduledThreadPoolExecutor和SingleThreadScheduledExecutor，前者是包含若干个线程的ScheduledThreadPoolExecutor，后者是只包含一个的ScheduledThreadPoolExecutor。&lt;/p&gt;
&lt;p&gt;ScheduledThreadPoolExecutor适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景。&lt;/p&gt;
&lt;p&gt;SingleThreadScheduledExecutor适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;new ThreadPoolExecutor(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在对该类型线程池进行实例化时，我们可以看到maximumPoolSize设置为了Integer的最大值，所以很明显在极端情况下和CachedThreadPool类型一样可能会因为创建过多线程而耗尽CPU和内存资源。&lt;/p&gt;
&lt;p&gt;DelayedWorkQueue是一种延时阻塞队列，此队列的特点为其中元素只能在其延迟到期时才被使用。ScheduledThreadPool类型在执行任务时和其他线程池有些不同。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ScheduledThreadPool类型线程池中的线程(假设现在线程A开始取任务)从DelayedWorkQueue中取已经到期的任务。&lt;/li&gt;
&lt;li&gt;线程A获取到任务后开始执行。&lt;/li&gt;
&lt;li&gt;任务执行完成后设置该任务下一次执行的时间。&lt;/li&gt;
&lt;li&gt;将该任务重新放入到线程池中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;ScheduledThreadPool中存在着定时任务和延时任务两种。&lt;/p&gt;
&lt;p&gt;延时任务通过&lt;code&gt;schedule(...)&lt;/code&gt;方法以及重载方法和&lt;code&gt;scheduleWithFixedDelay&lt;/code&gt;实现，延时任务通过设置某个时间间隔后执行，&lt;code&gt;schedule(...)&lt;/code&gt;仅执行一次。&lt;/p&gt;
&lt;p&gt;定时任务由&lt;code&gt;scheduleAtFixedRate&lt;/code&gt;实现。该方法创建并执行在给定的初始延迟之后，随后以给定的时间段进行周期性动作，即固定时间间隔的任务。&lt;/p&gt;
&lt;p&gt;特殊的&lt;code&gt;scheduleWithFixedDelay&lt;/code&gt;方法是创建并执行在给定的初始延迟之后首先启用的定期动作，随后在一个执行的终止和下一个执行的开始之间给定的延迟，即固定延时间隔的任务。&lt;/p&gt;
&lt;p&gt;固定时间间隔的任务不论每次任务花费多少时间，下次任务开始执行时间是确定的。对于&lt;code&gt;scheduleAtFixedRate&lt;/code&gt;方法中，若任务处理时长超出设置的定时频率时长,本次任务执行完才开始下次任务,下次任务已经处于超时状态,会马上开始执行。若任务处理时长小于定时频率时长,任务执行完后,定时器等待,下次任务会在定时器等待频率时长后执行。&lt;/p&gt;
&lt;p&gt;固定延时间隔的任务是指每次执行完任务以后都等待一个固定的时间。由于操作系统调度以及每次任务执行的语句可能不同，所以每次任务执行所花费的时间是不确定的，也就导致了每次任务的执行周期存在一定的波动。&lt;/p&gt;
&lt;p&gt;需要注意的是定时或延时任务中所涉及到时间、周期不能保证实时性及准确性，实际运行中会有一定的误差。&lt;/p&gt;
&lt;h4 id=&quot;callablefuture&quot;&gt;Callable/Future&lt;/h4&gt;
&lt;p&gt;在介绍实现多线程的时候我们有简单介绍过Runnable和Callable的，这两者基本相同，不同在于Callable可以返回一个结果，而Runnable不返回结果。对于Callable接口的使用方法和Runnable基本相同，同时我们也可以选择是否对结果进行接收处理。在Executors中提供了将Runnable转换为Callable的api：&lt;code&gt;Callable&amp;lt;Object&amp;gt; callable(Runnable task)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Future是一个用于接收Runnable和Callable计算结果的接口，当然它还提供了查询任务状态，中断或者阻塞任务以及查询结果的能力。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;boolean cancel(boolean mayInterruptIfRunning)  //尝试取消执行此任务。  
V get()  //等待计算完成，然后检索其结果。  
V get(long timeout, TimeUnit unit) //等待最多在给定的时间，然后检索其结果（如果可用）。  
boolean isCancelled() //如果此任务在正常完成之前被取消，则返回 true 。  
boolean isDone() //如果任务已完成返回true。  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FutureTask是对Future的基本实现，具有启动和取消计算的方法，查询计算是否完整，并检索计算结果。FutureTask对Future做了一定得扩展：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void run() //将此future设置为其计算结果，除非已被取消。  
protected boolean runAndReset()  //执行计算而不设置其结果，然后重置为初始状态，如果计算遇到异常或被取消，则不执行此操作。  
protected void set(V v) //将此Future的结果设置为给定值，除非Future已被设置或已被取消。  
protected void setException(Throwable t) //除非已经设置了此 Future 或已将其取消，否则它将报告一个 ExecutionException，并将给定的 throwable 作为其原因。  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FutureTask除了实现Future接口外，还实现了Runnable接口。所以FutureTask可以由Executor执行，也可以由调用线程直接执行futureTask.run()。&lt;/p&gt;
&lt;p&gt;当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞；&lt;/p&gt;
&lt;p&gt;当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。&lt;/p&gt;
&lt;p&gt;当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行；&lt;/p&gt;
&lt;p&gt;当FutureTask处于已启动状态时，执行FutureTask.cancel(true)方法将以中断执行此任务线程的方式来尝试停止该任务；&lt;/p&gt;
&lt;p&gt;当FutureTask处于已启动状态时，执行FutureTask.cancel(false)方法将不会对正在执行此任务的线程产生影响（让正在执行的任务运行完成）。&lt;/p&gt;
&lt;h4 id=&quot;关于是否使用executors&quot;&gt;关于是否使用Executors&lt;/h4&gt;
&lt;p&gt;在之前阿里巴巴出的java开发手册中，有明确提出禁止使用Executors：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，&lt;br/&gt;这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上面我们分析过使用Executors创建的几种线程池的使用场景和缺点，大多数情况下出问题在于可能导致OOM，在我实际使用中基本没有遇到过这样的情况。但是考虑到阿里巴巴这样体量的并发请求，可能遇到这种情况的几率较大。所以我们还是应该根据实际情况考虑是否使用，当然实际遵循阿里巴巴开发手册来可能会更好一点，毕竟这是国类顶尖公司常年在生产中积累下的经验。&lt;/p&gt;
&lt;p&gt;最后，在本节中只是简单介绍线程池及其基本原理，帮助更好的理解线程池。并不涉及具体如何使用。&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 14:00:00 +0000</pubDate>
<dc:creator>宁愿呢</dc:creator>
<og:description>目录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liyus/p/10235942.html</dc:identifier>
</item>
<item>
<title>ffmpeg简易播放器的实现-音视频播放 - 叶余</title>
<link>http://www.cnblogs.com/leisure_chn/p/10235926.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leisure_chn/p/10235926.html</guid>
<description>&lt;p&gt;基于FFmpeg和SDL实现的简易视频播放器，主要分为读取视频文件解码和调用SDL显示两大部分。&lt;br/&gt;前面两个实验分别实现了视频播放和音频播放：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10047035.html&quot;&gt;FFmpeg简易播放器的实现-视频播放&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10068490.html&quot;&gt;FFmpeg简易播放器的实现-音频播放&lt;/a&gt;&lt;br/&gt;本实验将视频播放和音频播放结合在一起。&lt;br/&gt;本实验主要参考如下两篇文章：&lt;br/&gt;[1]. &lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/38868499&quot;&gt;最简单的基于FFMPEG+SDL的视频播放器ver2(采用SDL2.0)&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/38868499&quot;&gt;An ffmpeg and SDL Tutorial&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;视频播放器基本原理&quot;&gt;1. 视频播放器基本原理&lt;/h2&gt;
&lt;p&gt;下图引用自“&lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/18893769&quot;&gt;雷霄骅，视音频编解码技术零基础学习方法&lt;/a&gt;”，因原图太小，看不太清楚，故重新制作了一张图片。&lt;br/&gt;&lt;img src=&quot;https://leihl.github.io/img/ffmpeg_player/01_player_flow.jpg&quot; title=&quot;播放器基本原理示意图&quot; alt=&quot;播放器基本原理示意图&quot;/&gt;&lt;br/&gt;如下内容引用自“&lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/18893769&quot;&gt;雷霄骅，视音频编解码技术零基础学习方法&lt;/a&gt;”：&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p&gt;&lt;strong&gt;解协议&lt;/strong&gt;&lt;br/&gt;将流媒体协议的数据，解析为标准的相应的封装格式数据。视音频在网络上传播的时候，常常采用各种流媒体协议，例如HTTP，RTMP，或是MMS等等。这些协议在传输视音频数据的同时，也会传输一些信令数据。这些信令数据包括对播放的控制（播放，暂停，停止），或者对网络状态的描述等。解协议的过程中会去除掉信令数据而只保留视音频数据。例如，采用RTMP协议传输的数据，经过解协议操作后，输出FLV格式的数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解封装&lt;/strong&gt;&lt;br/&gt;将输入的封装格式的数据，分离成为音频流压缩编码数据和视频流压缩编码数据。封装格式种类很多，例如MP4，MKV，RMVB，TS，FLV，AVI等等，它的作用就是将已经压缩编码的视频数据和音频数据按照一定的格式放到一起。例如，FLV格式的数据，经过解封装操作后，输出H.264编码的视频码流和AAC编码的音频码流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解码&lt;/strong&gt;&lt;br/&gt;将视频/音频压缩编码数据，解码成为非压缩的视频/音频原始数据。音频的压缩编码标准包含AAC，MP3，AC-3等等，视频的压缩编码标准则包含H.264，MPEG2，VC-1等等。解码是整个系统中最重要也是最复杂的一个环节。通过解码，压缩编码的视频数据输出成为非压缩的颜色数据，例如YUV420P，RGB等等；压缩编码的音频数据输出成为非压缩的音频抽样数据，例如PCM数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;音视频同步&lt;/strong&gt;&lt;br/&gt;根据解封装模块处理过程中获取到的参数信息，同步解码出来的视频和音频数据，并将视频音频数据送至系统的显卡和声卡播放出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简易播放器的实现-音视频播放&quot;&gt;2. 简易播放器的实现-音视频播放&lt;/h2&gt;
&lt;h3 id=&quot;实验平台&quot;&gt;2.1 实验平台&lt;/h3&gt;
&lt;p&gt;实验平台：openSUSE Leap 42.3&lt;br/&gt;FFmpeg版本：4.1&lt;br/&gt;SDL版本：2.0.9&lt;br/&gt;FFmpeg开发环境搭建可参考“&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10035365.html&quot;&gt;ffmpeg开发环境构建&lt;/a&gt;”&lt;/p&gt;
&lt;h3 id=&quot;源码流程分析&quot;&gt;2.2 源码流程分析&lt;/h3&gt;
&lt;p&gt;参考如下：&lt;br/&gt;&lt;img src=&quot;https://leihl.github.io/img/ffmpeg_player/02_player_avideo_flow.jpg&quot; title=&quot;FFmpeg简易播放器-音视频播放流程图&quot; alt=&quot;FFmpeg简易播放器-音频播放流程图&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;解复用线程&quot;&gt;2.3 解复用线程&lt;/h3&gt;
&lt;p&gt;解复用线程就是main()函数所在的主线程。main()函数作一些必要的初始化工作后，创建音频处理线程和视频处理线程。&lt;br/&gt;然后main()函数进入主循环，从输入文件中读取packet，并根据packet类型，将之放入视频packet队列或音频packet队列。&lt;/p&gt;
&lt;h3 id=&quot;音频处理线程&quot;&gt;2.4 音频处理线程&lt;/h3&gt;
&lt;p&gt;音频处理线程是SDL库内建线程。用户提供回调函数供音频处理线程调用。实现过程参考：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10068490.html&quot;&gt;FFmpeg简易播放器的实现-音频播放&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;视频处理线程&quot;&gt;2.5 视频处理线程&lt;/h3&gt;
&lt;p&gt;视频处理线程实现视频解码及播放。实现过程参考：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/10068490.html&quot;&gt;FFmpeg简易播放器的实现-音频播放&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码清单&quot;&gt;2.6 源码清单&lt;/h3&gt;
&lt;p&gt;代码已经变得挺长了，不贴完整源码了，源码参考：&lt;br/&gt;&lt;a href=&quot;https://github.com/leihl/exercises/tree/master/source/ffmpeg/player_avideo/ffplayer.c&quot; class=&quot;uri&quot;&gt;https://github.com/leihl/exercises/tree/master/source/ffmpeg/player_avideo/ffplayer.c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码清单中涉及的一些概念简述如下：&lt;br/&gt;&lt;strong&gt;container:&lt;/strong&gt;&lt;br/&gt;对应数据结构AVFormatContext&lt;br/&gt;封装器，将流数据封装为指定格式的文件，文件格式如AVI、MP4等。&lt;br/&gt;FFmpeg可识别五种流类型：视频video(v)、音频audio(a)、attachment(t)、数据data(d)、字幕subtitle。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;codec:&lt;/strong&gt;&lt;br/&gt;对应数据结构AVCodec&lt;br/&gt;编解码器。编码器将未压缩的原始图像或音频数据编码为压缩数据。解码器与之相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;codec context&lt;/strong&gt;:&lt;br/&gt;对应数据结构AVCodecContext&lt;br/&gt;编解码器上下文。此为非常重要的一个数据结构，后文分析。各API大量使用AVCodecContext来引用编解码器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;codec par&lt;/strong&gt;:&lt;br/&gt;对应数据结构AVCodecParameters&lt;br/&gt;编解码器参数。新版本增加的字段。新版本建议使用AVStream-&amp;gt;codepar替代AVStream-&amp;gt;codec。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;packet&lt;/strong&gt;:&lt;br/&gt;对应数据结构AVPacket&lt;br/&gt;经过编码的数据。通过av_read_frame()从媒体文件中获取得到的一个packet可能包含多个(整数个)音频帧或单个&lt;br/&gt;视频帧，或者其他类型的流数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;frame&lt;/strong&gt;:&lt;br/&gt;对应数据结构AVFrame&lt;br/&gt;解码后的原始数据。解码器将packet解码后生成frame。&lt;/p&gt;
&lt;h3 id=&quot;编译&quot;&gt;2.7 编译&lt;/h3&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;gcc -o ffplayer ffplayer.c -lavutil -lavformat -lavcodec -lavutil -lswscale -lSDL2&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;2.8 测试&lt;/h3&gt;
&lt;p&gt;选用clock_320.avi测试文件，此文件&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ffprobe clock_320.avi&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印视频文件信息如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[avi @ 0x9286c0] non-interleaved AVI
Input #0, avi, from 'clock_320.avi':
  Duration: 00:00:12.00, start: 0.000000, bitrate: 42 kb/s
    Stream #0:0: Video: msrle ([1][0][0][0] / 0x0001), pal8, 320x320, 1 fps, 1 tbr, 1 tbn, 1 tbc
    Stream #0:1: Audio: truespeech ([34][0][0][0] / 0x0022), 8000 Hz, mono, s16, 8 kb/s&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行测试命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;./ffplayer clock_320.avi &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以听到每隔1秒播放一次“嘀”声，声音播放12次。时针每隔1秒跳动一格，跳动12次。声音播放正常，画面播放也正常，但是声音和画面不能对应，因为没有考虑音视频同步。下一次实验研究音视频同步问题。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;3. 参考资料&lt;/h2&gt;
&lt;p&gt;[1] 雷霄骅，&lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/18893769&quot;&gt;视音频编解码技术零基础学习方法&lt;/a&gt;&lt;br/&gt;[2] 雷霄骅，&lt;a href=&quot;https://blog.csdn.net/leixiaohua1020/article/details/38868499&quot;&gt;最简单的基于FFMPEG+SDL的视频播放器ver2(采用SDL2.0)&lt;/a&gt;&lt;br/&gt;[3] SDL WIKI, &lt;a href=&quot;https://wiki.libsdl.org/&quot; class=&quot;uri&quot;&gt;https://wiki.libsdl.org/&lt;/a&gt;&lt;br/&gt;[4] Martin Bohme, &lt;a href=&quot;http://dranger.com/ffmpeg/ffmpegtutorial_all.html#tutorial03.html&quot;&gt;An ffmpeg and SDL Tutorial, Tutorial 03: Playing Sound&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;修改记录&quot;&gt;4. 修改记录&lt;/h2&gt;
&lt;p&gt;2018-12-06 V1.0 初稿&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 13:56:00 +0000</pubDate>
<dc:creator>叶余</dc:creator>
<og:description>基于FFmpeg和SDL实现的简易视频播放器，主要分为读取视频文件解码和调用SDL显示两大部分。 前面两个实验分别实现了视频播放和音频播放：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leisure_chn/p/10235926.html</dc:identifier>
</item>
<item>
<title>arguments对象详解 - 热爱前端的17号诶</title>
<link>http://www.cnblogs.com/sqh17/p/10232185.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sqh17/p/10232185.html</guid>
<description>&lt;hr/&gt;&lt;p&gt;在javascript中，函数是没有重载这一项的，所谓的重载，一个函数可以有多个，就是参数的个数和形式不同所以引用的功能不同，而js不存在函数重载，不管传不传参数，函数里面是否引用，关系都不大，一个函数对应一个功能，但是函数可以模拟函数重载，所以有一个Arguments对象。&lt;/p&gt;
&lt;h4 id=&quot;定义&quot;&gt;定义&lt;/h4&gt;
&lt;p&gt;arguments是一个对应于传递给函数的参数的&lt;code&gt;类数组&lt;/code&gt;对象。&lt;br/&gt;&lt;code&gt;类数组：是数组的形式，有length，但不具有数组的一切方法&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;描述&quot;&gt;描述&lt;/h4&gt;
&lt;p&gt;arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数，第一个参数在索引0处。&lt;br/&gt;&lt;code&gt;箭头函数没有arguments对象&lt;/code&gt;&lt;br/&gt;&lt;code&gt;arguments是函数中必有的对象，用来读取调用该函数的参数&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function foo(){
    console.log(arguments[0])  // 1
    console.log(arguments[1])  // 2
    console.log(arguments[2])  // 3
}
foo(1,2,3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;arguments对象不是数组，但可以通过其他方式转化为数组，进而使用数组的方法。&lt;br/&gt;&lt;code&gt;var args = Array.prototype.slice.call(arguments)&lt;/code&gt;&lt;br/&gt;&lt;code&gt;var args = [].slice.call(arguments);&lt;/code&gt;&lt;br/&gt;&lt;code&gt;var args = Array.from(arguments)&lt;/code&gt;&lt;br/&gt;&lt;code&gt;var args = [...arguments]&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function foo() {
    var f = Array.prototype.slice.call(arguments);
    // var f = [].slice.call(arguments);
    // var f = Array.from(arguments);
    // var f = [...arguments];
    console.log(f)  // [1,2,3]
    console.log(f instanceof Array) // true
}
foo(1, 2, 3)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;属性&quot;&gt;属性&lt;/h4&gt;
&lt;p&gt;arguments既然是个对象，也有它的自带的属性。&lt;/p&gt;
&lt;ul readability=&quot;13.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;length 长度，本次函数调用时传入函数的实参数量.
&lt;ul&gt;&lt;li&gt;表示的是实际上向函数传入了多少个参数,这个数字可以比形参数量大,也可以比形参数量小&lt;/li&gt;
&lt;li&gt;形参：全称“形参变量”，只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量。&lt;/li&gt;
&lt;li&gt;实参：全称为&quot;实际参数&quot;是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。&lt;br/&gt;&lt;code&gt;形参就是函数声明的参数，实参是函数调用的参数&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function foo(a,b){}  // a,b代表形参
foo(1,2) // 1,2代表实参&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;callee 当前正在执行的函数
&lt;ul readability=&quot;0&quot;&gt;&lt;li&gt;可以用于引用该函数的函数体内当前正在执行的函数（类似于递归）&lt;/li&gt;
&lt;li&gt;es5之后废弃，但不代表不使用这个callee了&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;callee可以使用在匿名递归函数中。
&lt;ul&gt;&lt;li&gt;匿名函数 (通过 函数表达式 或者 函数构造器 创建) 没有名称。因此如果没有可访问的变量指向该函数，唯一能引用它的方式就是通过 arguments.callee。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function create() {
    return function (n) {
        if (n &amp;lt;= 1)
            return 1;
        return n * arguments.callee(n - 1);
    };
}

var result = create()(5); 
console.log(result) // returns 120 (5 * 4 * 3 * 2 * 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;但不提倡使用callee来递归，最好形成有名函数，进而使用函数名递归。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function create() {
    return function multiply(n) {
        if (n &amp;lt;= 1)
            return 1;
        return n * multiply(n - 1);
    };
}

var result = create()(5); 
console.log(result) // returns 120 (5 * 4 * 3 * 2 * 1)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;caller 指向调用当前函数的函数
&lt;ul&gt;&lt;li&gt;原先用在函数执行的时候调用自身&lt;/li&gt;
&lt;li&gt;已废弃，不能用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;24&quot;&gt;arguments[@@iterator] 返回一个新的Array迭代器对象，该对象包含参数中每个索引的值。
&lt;ul&gt;&lt;li&gt;这个意思就是可以调用for-of循环 - -!&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function add(){
    for(var i of arguments){
        console.log(i)   //1 2 3 4 5 6 
    }
}
add(1,2,3,4,5,6)&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;特殊点&quot;&gt;特殊点&lt;/h4&gt;
当arguments遇到剩余函数，解构赋值和默认参数的情况：
&lt;ul&gt;&lt;li&gt;在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变 arguments对象的行为，&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&quot;use strict&quot;
function func(...a) {
  a[0] = 11
  console.log(arguments);
}
func(1,2,3,4,5); // [1,2,3,4,5]
function func1(a=4) {
  console.log(arguments);
}
func1(1); // [1]&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当非严格模式中的函数没有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值会跟踪参数的值（反之亦然）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  function func(a) { 
      arguments[0] = 99;   // 更新了arguments[0] 同样更新了a
      console.log(a);
  }
  func(10); // 99
  function func1(a) { 
      a = 99;              // 更新了a 同样更新了arguments[0] 
      console.log(arguments[0]);
  }
  func1(10); // 99&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值不会跟踪参数的值（反之亦然）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  function func(a = 55) { 
      arguments[0] = 99; // 更新了 arguments[0] 但没更新 a
      console.log(a);
  }
  func(10); // 10
  function func1(a = 55) { 
      a = 99; // 更新了 a 但没更新arguments[0]
      console.log(arguments[0]);
  }
  func1(10); // 10
  function func2(a = 55) { 
      console.log(arguments[0]);
  }
  func2(); // undefined&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;前段时间看到arguments对象，不是很懂，所以抽空学习了一下。es6箭头函数的出现，arguments对象相对来说少用了，因为箭头函数没有arguments对象。再加上有一些属性都被遗弃。但是不能不学，所有的知识都是从底层创建出来的，了解底层知识是有好处的。&lt;br/&gt;如果此文有什么不对的地方，欢迎评论私信，大家一起进步。我把我总结的知识点放到&lt;a href=&quot;https://github.com/sqh17/notes&quot;&gt;GitHub&lt;/a&gt;了，如果满意，给个star。&lt;/p&gt;
&lt;h6 id=&quot;参考文献&quot;&gt;参考文献&lt;/h6&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments&quot;&gt;MDN&lt;/a&gt; https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments&lt;/p&gt;
</description>
<pubDate>Mon, 07 Jan 2019 13:48:00 +0000</pubDate>
<dc:creator>热爱前端的17号诶</dc:creator>
<og:description>在javascript中，函数是没有重载这一项的，所谓的重载，一个函数可以有多个，就是参数的个数和形式不同所以引用的功能不同，而js不存在函数重载，不管传不传参数，函数里面是否引用，关系都不大，一个函</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sqh17/p/10232185.html</dc:identifier>
</item>
</channel>
</rss>