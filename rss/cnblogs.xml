<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>MyBatis初级实战之一：Spring Boot集成 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14280311.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14280311.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;mybatis初级实战&quot;&gt;MyBatis初级实战&lt;/h3&gt;
&lt;p&gt;《MyBatis初级实战》系列旨在通过一系列编码实战，和读者一起掌握MyBatis的基本用法，帮助初学者快速运用MyBatis参与实际开发；&lt;/p&gt;
&lt;h3 id=&quot;聚焦mybatis&quot;&gt;聚焦MyBatis&lt;/h3&gt;
&lt;p&gt;《MyBatis初级实战》面向的是对MyBatis有兴趣的读者，向读者们提供可用的方案和代码，这里不是比较Hibernate、sqltoy-orm的地方，作者也十分认可这些ORM框架，但《MyBatis初级实战》不参与比较；&lt;/p&gt;
&lt;h3 id=&quot;关于mybatis&quot;&gt;关于MyBatis&lt;/h3&gt;
&lt;p&gt;引自官方：MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/p&gt;
&lt;h3 id=&quot;实战环境&quot;&gt;实战环境&lt;/h3&gt;
&lt;p&gt;《MyBatis初级实战》系列的环境信息如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JDK：1.8.0_181&lt;/li&gt;
&lt;li&gt;mybatis-spring-boot-starter：2.1.3（对应的MyBatis：3.5.5）&lt;/li&gt;
&lt;li&gt;Spring Boot：2.3.2.RELEASE&lt;/li&gt;
&lt;li&gt;MySQL：5.7.29&lt;/li&gt;
&lt;li&gt;实战环境：win10&lt;/li&gt;
&lt;li&gt;开发工具：IntelliJ IDEA 2019.2.1 (Ultimate Edition)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;spring-boot集成mybatis常规步骤概览&quot;&gt;Spring Boot集成MyBatis常规步骤概览&lt;/h3&gt;
&lt;p&gt;Spring Boot集成MyBatis的常规步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;maven中添加mybatis-spring-boot-starter的依赖；&lt;/li&gt;
&lt;li&gt;Spring Boot的配置中指定MyBatis配置文件的位置；&lt;/li&gt;
&lt;li&gt;Spring Boot的配置中指定MyBatis映射文件的位置；&lt;/li&gt;
&lt;li&gt;添加MyBatis配置文件，后续MyBatis的常规配置集中在此；&lt;/li&gt;
&lt;li&gt;映射文件xxxMapper.xml及其对应的接口文件；&lt;/li&gt;
&lt;li&gt;业务代码中，Autowired注解修饰接口文件并使用；&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;接下来开始实战，咱们先把数据准备好；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;准备数据&quot;&gt;准备数据&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;请您自行准备好MySQL服务，我这边MySQL是部署在docker上的，可以参考&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/105460567&quot; target=&quot;_blank&quot;&gt;《群晖DS218+部署mysql》&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;创建名为&lt;span&gt;mybatis&lt;/span&gt;的数据库；&lt;/li&gt;
&lt;li&gt;在&lt;span&gt;mybatis&lt;/span&gt;数据库下执行以下SQL，即可创建本次实战所需数据：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;USE mybatis;

DROP TABLE IF EXISTS `user`;

CREATE TABLE `user` (
  `id` int(32) NOT NULL AUTO_INCREMENT,
  `name` varchar(32) NOT NULL,
  `age` int(32) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;


DROP TABLE IF EXISTS `log`;

CREATE TABLE `log` (
  `id` int(32) NOT NULL AUTO_INCREMENT,
  `user_id` int(32),
  `action` varchar(255) NOT NULL,
  `create_time` datetime not null,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

INSERT INTO mybatis.user (id, name, age) VALUES (3, 'tom', 11);
INSERT INTO mybatis.log (id, user_id, action, create_time) VALUES (3, 3, 'read book', '2020-08-07 08:18:16');
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;mybatis&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210115075624880-1773120229.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;关于父子工程&quot;&gt;关于父子工程&lt;/h3&gt;
&lt;p&gt;为了整个系列的代码好管理，我这边用maven创建的是父子工程，如果您只要子工程，不需要父子结构，要对子工程的pom.xml做以下调整：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;parent节点原本如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请替换成以下内容(也就是直接用&amp;gt;spring-boot-starter-parent作为父工程)：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.2.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;子工程种的&lt;span&gt;dependency&lt;/span&gt;节点中没有version子节点，这些都放在父工程的&lt;span&gt;dependencyManagement&lt;/span&gt;中统一管理了，请您将&lt;span&gt;version&lt;/span&gt;添加到子工程的各个dependency节点：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210115075625285-403251202.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接下来开始编码&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;创建父工程&quot;&gt;创建父工程&lt;/h3&gt;
&lt;p&gt;创建名为&lt;span&gt;mybatis&lt;/span&gt;的maven工程，pom.xml内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.3.2.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;packaging&amp;gt;pom&amp;lt;/packaging&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
        &amp;lt;project.reporting.outputEncoding&amp;gt;UTF-8&amp;lt;/project.reporting.outputEncoding&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;simple&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;

    &amp;lt;dependencyManagement&amp;gt;

        &amp;lt;dependencies&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.1.3&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;

    &amp;lt;/dependencyManagement&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;至此，准备工作算是全部完成了，接下来咱们开始创建一个典型的Spring Boot集成MyBatis的项目吧；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;spring-boot集成mybatis&quot;&gt;Spring Boot集成MyBatis&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在父工程mybatis之下新建名为&lt;span&gt;simple&lt;/span&gt;的Spring Boot子工程，其pom.xml内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;simple&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;simple&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.1.3&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;Spring Boot配置文件是&lt;span&gt;simple/src/main/resources/application.yml&lt;/span&gt;，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 8080

spring:
  # 数据源
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://192.168.50.43:3306/mybatis?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=true&amp;amp;serverTimezone=UTC
    driver-class-name: com.mysql.cj.jdbc.Driver

# mybatis配置
mybatis:
  # 配置文件所在位置
  config-location: classpath:mybatis-config.xml
  # 映射文件所在位置
  mapper-locations: classpath:mappers/*Mapper.xml

# 日志配置
logging:
  level:
    root: INFO
    com:
      bolingcavalry:
        simple:
          mapper: debug
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;新建user表对应的实体类User.java：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.simple.entity;

/**
 * @Description: 实体类
 * @author: willzhao E-mail: zq2599@gmail.com
 * @date: 2020/8/4 8:24
 */
public class User {
    private Integer id;
    private String name;
    private Integer age;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, age=&quot; + age +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;新建log表对应的实体类Log.java：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.simple.entity;

import java.sql.Date;

/**
 * @Description: 实体类
 * @author: willzhao E-mail: zq2599@gmail.com
 * @date: 2020/8/4 8:24
 */
public class Log {
    private Integer id;
    private Integer userId;
    private String action;
    private Date createTime;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Integer getUserId() {
        return userId;
    }

    public void setUserId(Integer userId) {
        this.userId = userId;
    }

    public String getAction() {
        return action;
    }

    public void setAction(String action) {
        this.action = action;
    }

    public Date getCreateTime() {
        return createTime;
    }

    public void setCreateTime(Date createTime) {
        this.createTime = createTime;
    }

    @Override
    public String toString() {
        return &quot;Log{&quot; +
                &quot;id=&quot; + id +
                &quot;, userId=&quot; + userId +
                &quot;, action='&quot; + action + '\'' +
                &quot;, createTime=&quot; + createTime +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;接下来会新建三个配置文件，先来看下它们的位置，以免后面放错地方引起不必要的麻烦：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210115075625810-1240442995.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;6. application.yml所在目录下，新增名为&lt;span&gt;mybatis-config.xml&lt;/span&gt;的文件，这是mybatis的配置文件，本例很简单只有一个配置，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;typeAliases&amp;gt;
        &amp;lt;!-- 映射文件中的类不用写全路径了--&amp;gt;
        &amp;lt;package name=&quot;com.bolingcavalry.simple.entity&quot;/&amp;gt;
    &amp;lt;/typeAliases&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;&lt;span&gt;resources/mappers&lt;/span&gt;目录下，新增名为&lt;span&gt;UserMapper.xml&lt;/span&gt;的文件，和user表相关的查询都在此，本文只有一个查询user表的操作，注意下文中的resultType等于User，这里没有写User类的完整路径，是因为前面mybatis-config.xml文件中配置了typeAliases的package节点的缘故：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.bolingcavalry.simple.mapper.UserMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;sel&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&amp;gt;
        select * from user where id = #{id}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;再新增&lt;span&gt;LogMapper.xml&lt;/span&gt;，如下所示，log表中的&lt;span&gt;user_id&lt;/span&gt;字段在Log.java中没有同名的字段，因此要新增resultMap来建立数据库和实体类的字段映射关系，再在select节点用上这个关系，注意要用&lt;span&gt;resultMap&lt;/span&gt;属性(UserMapper.xml中用的是&lt;span&gt;resultType&lt;/span&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.bolingcavalry.simple.mapper.LogMapper&quot;&amp;gt;

    &amp;lt;resultMap id=&quot;logResultMap&quot; type=&quot;Log&quot;&amp;gt;
        &amp;lt;id property=&quot;id&quot; column=&quot;id&quot; /&amp;gt;
        &amp;lt;result column=&quot;user_id&quot; jdbcType=&quot;INTEGER&quot; property=&quot;userId&quot; /&amp;gt;
        &amp;lt;result column=&quot;action&quot; jdbcType=&quot;VARCHAR&quot; property=&quot;action&quot; /&amp;gt;
        &amp;lt;result column=&quot;create_time&quot; jdbcType=&quot;TIMESTAMP&quot; property=&quot;createTime&quot; /&amp;gt;
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;select id=&quot;sel&quot; parameterType=&quot;int&quot; resultMap=&quot;logResultMap&quot;&amp;gt;
        select * from log where id = #{id}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;接下来是业务要用到的接口文件，第一个是UserMapper.java：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.simple.mapper;

import com.bolingcavalry.simple.entity.User;
import org.springframework.stereotype.Repository;

@Repository
public interface UserMapper {
    User sel(int id);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;第二个是LogMapper.java：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.simple.mapper;

import com.bolingcavalry.simple.entity.Log;
import org.springframework.stereotype.Repository;

@Repository
public interface LogMapper {
    Log sel(int id);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;上述两个类都使用了&lt;span&gt;Repository&lt;/span&gt;注解，作用是避免在编码过程中,IDEA给出红线提示，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210115075626670-1402549221.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;12. 映射配置完毕，接下来就可以在应用中使用了，先为user做一个service类UserService.java，里面通过&lt;span&gt;Autowired&lt;/span&gt;注解注入UserMapper的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.simple.service;

import com.bolingcavalry.simple.entity.User;
import com.bolingcavalry.simple.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserService {
    @Autowired
    UserMapper userMapper;

    public User sel(int id){
        return userMapper.sel(id);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;13&quot;&gt;&lt;li&gt;再为log做service类LogService.java：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.simple.service;

import com.bolingcavalry.simple.entity.Log;
import com.bolingcavalry.simple.mapper.LogMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class LogService {
    @Autowired
    LogMapper logMapper;

    public Log sel(int id){
        return logMapper.sel(id);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;14&quot;&gt;&lt;li&gt;最后是响应web请求的controller类，第一个是UserController.java：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.simple.controller;

import com.bolingcavalry.simple.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {
    @Autowired
    private UserService userService;

    @RequestMapping(&quot;user/{id}&quot;)
    public String GetUser(@PathVariable int id){
        return userService.sel(id).toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;15&quot;&gt;&lt;li&gt;然后是LogController.java：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.simple.controller;

import com.bolingcavalry.simple.service.LogService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LogController {
    @Autowired
    private LogService logService;

    @RequestMapping(&quot;log/{id}&quot;)
    public String log(@PathVariable int id){
        return logService.sel(id).toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;16&quot;&gt;&lt;li&gt;最后是引导类SimpleApplication.java，注意MapperScan注解会自动扫描包路径下的所有接口，这样UserMapper和LogMapper就不用加Mapper注解了：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.simple;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(&quot;com.bolingcavalry.simple.mapper&quot;)
public class SimpleApplication {

    public static void main(String[] args) {
        SpringApplication.run(SimpleApplication.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;至此，编码完成，可以启动验证了；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;启动SpringBoot应用的方式有两种，最简单的办法是再IDEA中直接启动，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210115075627204-1088381405.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;第二种是simple的目录下执行&lt;span&gt;mvn clean package -U&lt;/span&gt;，就会在&lt;span&gt;target&lt;/span&gt;目录得到文件&lt;span&gt;simple-0.0.1-SNAPSHOT.jar&lt;/span&gt;，再执行&lt;span&gt;java -jar simple-0.0.1-SNAPSHOT.jar&lt;/span&gt;即可启动；&lt;/li&gt;
&lt;li&gt;在浏览器访问&lt;a href=&quot;http://localhost:8080/user/3&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://localhost:8080/user/3&lt;/span&gt;&lt;/a&gt;，可以得到user表的查询结果：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210115075627419-428758699.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;4. 访问&lt;a href=&quot;http://localhost:8080/log/3&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://localhost:8080/log/3&lt;/span&gt;&lt;/a&gt;，可以得到log表的查询结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210115075627572-344691280.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;5. 在控制台可以看到日志如下所示，这是我们开发期间调试问题的重要线索：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210115075628129-128641281.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;至此，入门级SpringBoot集成MyBatis的实战就完成了，接下来的系列内容会有更多实战，咱们一起来学习和掌握MyBatis的基本用法；&lt;/p&gt;
&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Jan 2021 23:56:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14280311.html</dc:identifier>
</item>
<item>
<title>Java安全之RMI协议分析 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/14280278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/14280278.html</guid>
<description>&lt;h2 id=&quot;java安全之rmi协议分析&quot;&gt;Java安全之RMI协议分析&lt;/h2&gt;
&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;在前面其实有讲到过RMI，但是只是简单描述了一下RMI反序列化漏洞的利用。但是RMI底层的实现以及原理等方面并没有去涉及到，以及RMI的各种攻击方式。在其他师傅们的文章中发现RMI的攻击方式很多。 所以在此去对RMI的底层做一个分析，后面再去对各种攻击方式去做一个了解。&lt;/p&gt;
&lt;h2 id=&quot;0x01-底层协议概述&quot;&gt;0x01 底层协议概述&lt;/h2&gt;
&lt;h3 id=&quot;rpc&quot;&gt;RPC&lt;/h3&gt;
&lt;p&gt;RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。&lt;/p&gt;
&lt;p&gt;小总结：&lt;/p&gt;
&lt;p&gt;在最原始数据通讯中其实还是归根到TCP/UDP协议，但是自使用了RPC后可以不需要了解底层网络协议，但是底层还是通过TCP/UDP去进行网络调用的。 其实RPC也只是远程方法调用的统称，重点在于方法调用中。而RMI实现就是Java版的一个RPC实现。&lt;/p&gt;
&lt;h3 id=&quot;jmx&quot;&gt;JMX&lt;/h3&gt;
&lt;p&gt;JMS：Java 消息服务(Java Messaging Service) 是一种允许应用程序创建、发送、接受和读取消息的Java API。JMS 在其中扮演的角色与JDBC 很相似， &lt;strong&gt;JDBC 提供了一套用于访问各种不同关系数据库的公共API&lt;/strong&gt;，&lt;strong&gt;JMS 也提供了独立于特定厂商的企业消息系统访问方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;JMS 的编程过程很简单，概括为：应用程序A 发送一条消息到消息服务器(也就是JMS Provider)的某个目的地(Destination)，然后消息服务器把消息转发给应用程序B。因为应用程序A 和应用程序B 没有直接的代码关连。&lt;/p&gt;
&lt;h3 id=&quot;rpc-和rmi的区别&quot;&gt;RPC 和RMI的区别&lt;/h3&gt;
&lt;p&gt;RPC（Remote Procedure Call Protocol）远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC不依赖于具体的网络传输协议，tcp、udp等都可以。&lt;/p&gt;
&lt;p&gt;RPC是跨语言的通信标准。&lt;/p&gt;
&lt;p&gt;RMI可以被看作SUN对RPC的Java版本的实现，当然也还有其他的RPC&lt;/p&gt;
&lt;p&gt;微软的DCOM就是建立在ORPC协议之上实现的RPC。&lt;/p&gt;
&lt;p&gt;RMI集合了&lt;strong&gt;Java序列化&lt;/strong&gt;和&lt;strong&gt;Java远程方法协议(Java Remote Method Protocol)&lt;/strong&gt;。这里的Java远程方法协议则是JRMP。&lt;/p&gt;
&lt;h3 id=&quot;rmi和jms的区别&quot;&gt;RMI和JMS的区别&lt;/h3&gt;
&lt;h4 id=&quot;传输方式&quot;&gt;传输方式&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;JMS 与 RMI 的区别在于：采用 JMS 服务，对象是在物理上被异步从网络的某个 JVM 上直接移动到另一个 JVM 上。&lt;/li&gt;
&lt;li&gt;RMI 对象是绑定在本地 JVM 中，只有函数参数和返回值是通过网络传送的。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;方法调用&quot;&gt;方法调用&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;RMI 一般都是&lt;strong&gt;同步&lt;/strong&gt;的，也就是说，当client端调用Server端的一个方法的时候，需要等到对方的返回，才能继续执行client端，这个过程跟调用本地方法感觉上是一样的，这也是RMI的一个特点。&lt;/li&gt;
&lt;li&gt;JMS 一般只是一个点发出一个Message(消息)到Message Server端，发出之后一般不会关心谁用了这个message(消息)。&lt;/li&gt;
&lt;li&gt;一般RMI的应用是紧耦合，JMS的应用相对来说是松散耦合的应用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本段取自&lt;a href=&quot;https://cloud.tencent.com/developer/article/1353191&quot; target=&quot;_blank&quot;&gt;RMI与RPC的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由此得知其实RMI协议是发送方法以及方法参数，请求到server端后，server进行执行后返回结果给client端。&lt;/p&gt;
&lt;h2 id=&quot;0x02-rmi底层架构&quot;&gt;0x02 RMI底层架构&lt;/h2&gt;
&lt;h3 id=&quot;底层架构概念&quot;&gt;底层架构概念&lt;/h3&gt;
&lt;p&gt;根据上面内容其实可以总结为一句话，RPC是为了隐藏网络通信过程中的细节，方便使用。而在RMI中也是一样的。RMI中为了隐藏网络通讯的过程细节采用了动态代理的方式来进行实现。&lt;/p&gt;
&lt;p&gt;下面先来看到调用流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210115045424255-1424830926.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在客户端和服务器各有一个代理，客户端的代理叫Stub（存根），服务端的代理叫Skeleton（骨架），合在一起形成了 RMI 构架协议，负责网络通信相关的功能。&lt;strong&gt;代理都是由服务端产生的，客户端的代理是在服务端产生后动态加载过去的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;stub担当远程对象的客户本地代表或代理人角色，负责把要调用的远程对象方法的方法名及其参数编组打包,并将该包转发给远程对象所在的服务器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210115045447261-670204483.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stub编码后发送的数据包内容，包含如下内容：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;1. 被使用的远程对象的标识符
2. 被调用的方法的描述
3. 编组后的参数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Skeleton接收到Stub发送数据会执行如下操作：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;1. 从数据包中定位要调用的远程对象
2. 调用所需的方法，并传递客户端提供的参数
3. 捕获返回值或调用产生的异常。
4. 将打包返回值编组，返回给客户端Stub
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本段内容部分取自：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/78386523&quot; target=&quot;_blank&quot;&gt;RMI反序列化漏洞分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结大体的内容如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;客户端(Client)：服务调用方。
    
客户端存根(Client Stub)：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。
    
服务端存根(Server Stub)：接收客户端发送过来的请求消息并进行解包，然后再调用本地服务进行处理。
    
服务端(Server)：服务的真正提供者。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里值得注意的一点是前面说到的传输进行打包和解包的步骤其实就是序列化和反序列化，传输的是序列化的数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210115045455872-1209673588.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;架构调用流程&quot;&gt;架构调用流程&lt;/h3&gt;
&lt;p&gt;RMI大致的远程调用执行流程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;1. 客户端发起请求，请求转交至RMI客户端的stub类；

2. stub类将请求的接口、方法、参数等信息进行序列化；

3. 基于socket将序列化后的流传输至服务器端；

4. 服务器端接收到流后转发至相应的Skeleton类；

5. Skeleton类将请求的信息反序列化后调用实际的处理类；

6. 处理类处理完毕后将结果返回给Skeleton类；

7. Skelton类将结果序列化，通过socket将流传送给客户端的stub；

8. stub在接收到流后反序列化，将反序列化后的Java Object返回给调用者。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;socket层中执行流程&quot;&gt;socket层中执行流程&lt;/h3&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;server在远程机器上监听一个端口，这个端口是jvm或者os在运行时随机选择的一个端口。可以说server在远程机器上在这个端口上导出自己。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;client并不知道server在哪，以及sever监听哪个端口，但是他有stub。stub知道所有这些东西，这样client可以调用stub上他想调用的任何方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;client调用给你stub上的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;stub链接server监听的端口并发送参数，详细过程如下：&lt;/p&gt;
&lt;p&gt;4.1 client连接server监听的端口&lt;br/&gt;4.2 server收到请求并创建一个socket来处理这个连接&lt;br/&gt;4.3 server继续监听到来的请求&lt;br/&gt;4.4 使用双方协定的歇息，传送参数和结果&lt;br/&gt;4.5 协议可以是JRMP或者 iiop&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法在远程server上执行，并发执行结果返回给stub&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;stub返回结果给client，就好像是stub执行了这个方法一样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实也是一样对于了下面的这张图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210115045514356-803415079.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是第二部分内容是值得思索的一点，为什么client不知道server的监听端口和server在哪，而stub却知道呢？client不知道server的host和port的话，stub是如何创建一个知道所有这一切的stub对象呢？&lt;/p&gt;
&lt;p&gt;这时候就引出了RMIRegistry（注册中心）的作用了。&lt;/p&gt;
&lt;h3 id=&quot;rmiregistry作用&quot;&gt;RMIRegistry作用&lt;/h3&gt;
&lt;p&gt;RMIRegistry 可以认为是一个服务，它提供了一个hashmap，里面是 &lt;code&gt;public_name&lt;/code&gt;, &lt;code&gt;Stub_object&lt;/code&gt; 名值对。比如有一个远程服务对象叫做 &lt;code&gt;Scientific_Calculator&lt;/code&gt;，然后想把这个服务对外公布为 calc，这样会在server上创建一个stub对象，把他注册到RMIRegistry ，这样client就可以从RMIRegistry 中得到这个stub对象了，可以使用一个工具类&lt;code&gt;java.rmi.Naming&lt;/code&gt;来方便的操作注册和操作。&lt;/p&gt;
&lt;p&gt;实现可看&lt;a href=&quot;https://www.cnblogs.com/nice0e3/p/13927460.html&quot; target=&quot;_blank&quot;&gt;Java安全之RMI反序列化&lt;/a&gt;该篇文章。&lt;/p&gt;
&lt;h4 id=&quot;总结：&quot;&gt;总结：&lt;/h4&gt;
&lt;p&gt;简单来说就是使用&lt;code&gt;java.rmi.Naming&lt;/code&gt;将一个某一个类注册进RMIRegistry 里面，注册后会在server端创建stub对象，而client就可以从RMIRegistry 中得到这个stub对象。前面内容说到过&lt;strong&gt;代理都是由服务端产生的，客户端的代理是在服务端产生后动态加载过去的。&lt;/strong&gt;RMIRegistry运行在server端当中。&lt;/p&gt;
&lt;h3 id=&quot;rmiregistry--执行流程详解&quot;&gt;RMIRegistry 执行流程详解&lt;/h3&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先RMIRegistry 运行在server端，RMIRegistry 自身也是一个远程对象。有一点需要注意的是：所有的远程对象（继承了UnicastRemoteObject对象）都会在sever上任意的端口导出自己，因为RMIRegistry 也是一个远程对象，他也在server上导出自己，这个端口是1099。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;服务端运行在server上，在UnicastRemoteObject构造函数里面，他把自己导出在server上一个任意端口上，这个端口client是不知道的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;当你调用Naming.rebind()的时候，会传入一个CalcImpl 的引用（这里叫做 c）作为第2个参数，Naming 就会构造一个stub对象，详细如下：&lt;br/&gt;a. Naming会使用getClass来获取类的名字，这里就是CalcImpl&lt;br/&gt;b. 加上后缀_Stub 变成了 CalcImpl _Stub&lt;br/&gt;c. 加载CalcImpl_Stub.class到虚拟机中&lt;br/&gt;d. 从c中获取RemoteRef 对象&lt;/p&gt;
&lt;p&gt;e. 就是这个RemoteRef 对象中封装了服务端细节，包括服务端的hostname、port&lt;br/&gt;f. 获取了RemoteRef 对象之后，就可以构造stub对象了。&lt;br/&gt;g. 传递stud对象到RMIRegistry中进行绑定，即（publicname,stub）&lt;br/&gt;f. RMIRegistry 中内部使用一个hashmap来存储（publicname,stub）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当客户端使用 Naming.lookup()的时候，会传入public name 作为参数，RMIRegistry 就会返回stub给客户端调用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里作者说的&lt;code&gt;导出自己&lt;/code&gt;这个没太理解这个的意思，我的理解是映射，将内容映射到1099端口中。&lt;/p&gt;
&lt;h4 id=&quot;总结：-1&quot;&gt;总结：&lt;/h4&gt;
&lt;p&gt;总体来说就是所以的远程对象都会在server的任意的端口上映射，RMIRegistry 也会进行映射，但是RMIRegistry 映射的端口是1099（默认是，可以修改）。远程对象进行映射的端口，client是不知道的。但是stub对象会知道。&lt;/p&gt;
&lt;p&gt;在调用Naming.rebind()并并且传入某一个引用的时候，Naming 就会构造一个stub对象。Naming内部采用getClass来获取类的名字，并且添加&lt;code&gt;_Stub&lt;/code&gt;后缀后价值到虚拟机中，然后从引用中获取 RemoteRef 对象，该对象就封装了封装了服务端的细节。而获取到该RemoteRef 就可以构造stub对象了，构造完成后传递到RMIRegistry注册中心中进行绑定，内部采用hashmap键值对的方式，即（publicname,stub），这时候使用Naming.lookup()传入对应的方法名，则会返回对应的stub到client端。&lt;/p&gt;
&lt;p&gt;RMIRegistry 存在的意义只是为了方便client获取到stub对象，stub构造函数中需要一个RemoteRef 对象，这个对象只能在server端获取。&lt;/p&gt;
&lt;p&gt;本段内容部分摘取自：&lt;a href=&quot;https://www.jianshu.com/p/2c78554a3f36&quot; target=&quot;_blank&quot;&gt;深入理解rmi原理&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x03-结尾&quot;&gt;0x03 结尾&lt;/h2&gt;
&lt;p&gt;简单的分析了一下RMI底层的架构，但是这些其实都仅仅是基于概念和理论层面的，具体的代码实现其实还没去看。在其中也是看得晕头转向的，部分也摘取了其他师傅们的文章内容，感觉已经总结很到位了，疯狂安利。摘取的内容下也贴出来 摘取内容的出处，感谢各位师傅们的详细讲解。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210115045525369-2097319158.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Jan 2021 20:56:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>Java安全之RMI协议分析 0x00 前言 在前面其实有讲到过RMI，但是只是简单描述了一下RMI反序列化漏洞的利用。但是RMI底层的实现以及原理等方面并没有去涉及到，以及RMI的各种攻击方式。在其</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/14280278.html</dc:identifier>
</item>
<item>
<title>工具用的好，下班回家早！iTerm2使用技巧指北！ - Java填坑笔记</title>
<link>http://www.cnblogs.com/liqiangchn/p/14280203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/14280203.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;strong&gt;同时打开多个终端窗口，来回切换太麻烦！&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;能不能像IDEA一样，能够查看历史粘贴记录？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有没有办法一键登陆服务器？&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;工欲善其事，必先利其器！无论工作还是学习，选择好用的工具真的太重要了。今天就给大家介绍一下笔者感觉相见恨晚的工具iTerm2，如果让我说日常开发中好用的工具有哪些，iTerm2必须拥有姓名。&lt;/p&gt;
&lt;p&gt;作为经常和Terminal打交道的工程师来说，对于自带的Terminal来说，Windows的命令行最难用，笔者一般使用XShell。入坑Mac后发现大家都在用iTerm2，半年下来感受只有两个字：真香！&lt;/p&gt;

&lt;p&gt;窗口，当然是想怎么分就怎么分！和Mac原生的Terminal一个关键的区别就是iTerm2支持任意分割和创建窗口。&lt;/p&gt;
&lt;h2 id=&quot;热键window&quot;&gt;热键Window&lt;/h2&gt;
&lt;p&gt;首先，你可以设置一个打开iTerm窗口的快捷键，iTerm2-&amp;gt;Perferences-&amp;gt;Kes-&amp;gt;Hotkey，这样就可以在打开时快人一步！&lt;/p&gt;
&lt;p&gt;如果已经打开了iTem2应用，就可以通过快捷键一键打开和隐藏。默认的Hotkey Window最大的特点就是透明和悬浮，它能够悬浮在任意窗口上面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/354bed0e0f48d9e923a014349657b668.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;普通window&quot;&gt;普通Window&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/35ee24bda11b4265badfcab6e153879f.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建Window：&lt;strong&gt;Command + N&lt;/strong&gt;&lt;br/&gt;关闭Window：&lt;strong&gt;Command + W&lt;/strong&gt;&lt;br/&gt;全屏：&lt;strong&gt;Command + Enter&lt;/strong&gt;， 再按一次还原&lt;br/&gt;展示所有窗口：&lt;strong&gt;Command + Option + e&lt;/strong&gt;&lt;br/&gt;关闭窗口：&lt;strong&gt;Command + w&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;选项卡tab&quot;&gt;选项卡Tab&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/43f1e257083f1243e18f8ccbe7650593.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建标签：&lt;strong&gt;Command + t&lt;/strong&gt;&lt;br/&gt;关闭标签：&lt;strong&gt;Command + w&lt;/strong&gt;&lt;br/&gt;切换标签：&lt;strong&gt;Command + 数字&lt;/strong&gt; 或者 &lt;strong&gt;Command + 左/右方向&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;窗格panes&quot;&gt;窗格Panes&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/b71b5653846859b81ec06d0469c25654.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;垂直分屏：&lt;strong&gt;Command + d&lt;/strong&gt;&lt;br/&gt;水平分屏：&lt;strong&gt;Command + shift + d&lt;/strong&gt;&lt;br/&gt;切换窗格：&lt;strong&gt;Command + Option + 方向键&lt;/strong&gt; 或者 &lt;strong&gt;Command + 左右中括号&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;除了窗口划分，Term2的另一杀手锏就是&lt;strong&gt;回放&lt;/strong&gt;。不仅可以查看剪切板的历史记录，还能像视频一样回放窗口内的历史记录！&lt;/p&gt;
&lt;h2 id=&quot;历史剪切板&quot;&gt;历史剪切板&lt;/h2&gt;
&lt;p&gt;对于普通文本编辑器来说，每次复制后都会覆盖之前的剪切板，非常不好用。而iTerm2提供了和IDEA一样查看历史剪切板功能，对于笔者这种CV工程师来说是相当友好了！&lt;/p&gt;
&lt;p&gt;快捷键&lt;strong&gt;：Command + Shift + h&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/544dc58c1a145f16da3aabea89391cef.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;历史命令提示&quot;&gt;历史命令提示&lt;/h2&gt;
&lt;p&gt;命令提示，能够提示最近输入的内容，以及常用的命令；需要注意的是，这里仅仅会&lt;strong&gt;输入过的内容&lt;/strong&gt;，当然iTerm也有命令补全插件，后面会进行介绍。&lt;/p&gt;
&lt;p&gt;快捷键：&lt;strong&gt;Command + ;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/794725b72527d959e36b970520e6ac05.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然除了历史命令提示之外，也可以使用系统支持的方式来搜索和查看历史命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上一条命令&lt;/strong&gt;：Ctrl + p(previous) 或 向上方向键&lt;br/&gt;&lt;strong&gt;下一条命令&lt;/strong&gt;： Ctrl + n(next) 或 向下方向键&lt;br/&gt;&lt;strong&gt;搜索历史命令&lt;/strong&gt;：ctrl + r&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/d08c79619675c82107dcd023233537db.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;即时回放&quot;&gt;即时回放&lt;/h2&gt;
&lt;p&gt;非常有意思的功能，像录屏一样，记录过去一段时间内窗口显示的内容。&lt;/p&gt;
&lt;p&gt;快捷键：&lt;strong&gt;Command + Option + b&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/66ce672e31173e656734dab98343f4b0.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;前进/后退&lt;/strong&gt;：左右箭头/鼠标拖动进度条**&lt;br/&gt;&lt;strong&gt;退出回放&lt;/strong&gt;：esc&lt;/p&gt;

&lt;h2 id=&quot;智能复制&quot;&gt;智能复制&lt;/h2&gt;
&lt;p&gt;在item中&lt;strong&gt;选中即复制&lt;/strong&gt;，被选择的文本会自动保存在剪切板中。双击选中，三击选中整行，四击智能选择，可以智能的选中你想要的数据，如网址，邮箱，括号或引号中的数据等。&lt;/p&gt;
&lt;p&gt;同样也支持快速粘贴，鼠标选中复制后，可以通过&lt;strong&gt;鼠标中键&lt;/strong&gt;或者Command+v进行粘贴。同时，选中后也可以通过&lt;strong&gt;拖拽&lt;/strong&gt;实现快速的复制和粘贴。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/9609061c7ca9f1486347c2ebc0db70e1.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;Command+f&lt;/strong&gt;即可完成搜索，搜索后，通过&lt;strong&gt;Tab&lt;/strong&gt; 或者 &lt;strong&gt;Tab + Shift&lt;/strong&gt;可向右或向左扩大选中范围，完成复制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/4b8158d203aac6742d9952dd014e049d.gif&quot; alt=&quot;Command+f&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;妙用command&quot;&gt;妙用Command&lt;/h2&gt;
&lt;p&gt;Command既可以和其他按键组合成快捷键，也可以搭配鼠标实现一些快捷功能。只需要&lt;strong&gt;按下Command&lt;/strong&gt;在搭配一下操作即可。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;点击url&lt;/strong&gt;，调用默认浏览器访问该网址&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;点击文件&lt;/strong&gt;，调用默认程序打开文件。如果选中的是 &lt;strong&gt;文件名:数字&lt;/strong&gt;，且默认文本编辑器是Mac vim 将会直接打开到这一行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;点击文件夹&lt;/strong&gt;，在Finder中打开该文件夹&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配合&lt;strong&gt;Optional&lt;/strong&gt;键，使用鼠标可以选择&lt;strong&gt;矩形区域&lt;/strong&gt;内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/8beacd6202e4c5d4c150b7210a83a046.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;常用快捷键&quot;&gt;常用快捷键&lt;/h2&gt;
&lt;p&gt;这些快捷键并非iTem2特有，也是非常基础的快捷键。当然最重要的是它们非常实用，几乎每天都会用到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;清屏&lt;/strong&gt;：Command + r 或者 ctrl + l&lt;br/&gt;&lt;strong&gt;清除当前行&lt;/strong&gt;：Ctrl + u&lt;br/&gt;&lt;strong&gt;删除当前光标的字符&lt;/strong&gt;：ctrl + d&lt;br/&gt;&lt;strong&gt;删除光标之前的字符&lt;/strong&gt;：ctrl + h&lt;br/&gt;&lt;strong&gt;删除光标之前的单词&lt;/strong&gt;：ctrl + w&lt;br/&gt;&lt;strong&gt;删除到文本末尾&lt;/strong&gt;：ctrl + k&lt;br/&gt;&lt;strong&gt;交换光标处文本&lt;/strong&gt;：ctrl + t&lt;br/&gt;&lt;strong&gt;光标移动导行首&lt;/strong&gt;：Ctrl + a&lt;br/&gt;&lt;strong&gt;光标移动到行位&lt;/strong&gt;：Ctrl + e&lt;/p&gt;

&lt;p&gt;对于快捷登陆这种基本操作，iTerm2当然也能很好支持。只需要在将脚本配置到iTerm2-&amp;gt;Preferences-&amp;gt;Profiles-&amp;gt;General中的Command输入框中，既可以是单行命令，也可以是Shell脚本文件。&lt;/p&gt;
&lt;h2 id=&quot;ssh--sshpass&quot;&gt;ssh + sshpass&lt;/h2&gt;
&lt;p&gt;ssh命令一般用来远程登陆Linux主机，不过需要两段式登陆，先输ssh连接命令，当服务器响应后再输入密码。&lt;/p&gt;
&lt;p&gt;要把两段式登陆合并成一步到位，只需要安装sshpass工具即可，sshpass用于非交互的ssh密码验证，允许你指定明文密码，然后配置ssh命令直接登录远程服务器。&lt;/p&gt;
&lt;p&gt;它支持密码从命令行，文件，环境变量中读取。三种用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 1. 密码
sshpass -p {密码} ssh -p ${端口} {用户名}@{主机IP} 
# 2. 密码文本文件
sshpass -f {密码文本文件} ssh -p ${端口} {用户名}@{主机IP} 
# 3. 环境变量
# 配置环境变量
export SSHPASS='my_pass_here'
echo $SSHPASS
# 登陆
sshpass -e ssh username@192.168.0.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/f96004ebed87728ecbb02e04cec13307.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，为了防止密码先是在屏幕上，一般使用密码文件和环境变量的方式登陆。&lt;/p&gt;
&lt;h2 id=&quot;expect脚本&quot;&gt;expect脚本&lt;/h2&gt;
&lt;p&gt;工作中通常不能直接连线上服务器或数据库，而是需要先登陆跳板机，再通过跳板机连接线上服务器/数据库。这些就可以通过expect脚本来解决。&lt;/p&gt;
&lt;p&gt;expect 是用来进行自动化控制和测试的工具，主要是用来和ssh/talnet/ftp等这些交互式软件进行自动交互，比如远程自动输入密码，执行脚本等。&lt;/p&gt;
&lt;p&gt;expect的大致原理就是，首先spawn我们要执行的命令A，然后设置一个或多个预期命令A会输出的结果，根据设置匹配的结果选择接下来执行的分支，然后通过send命令执行后续命令，模拟键盘输入。&lt;/p&gt;
&lt;p&gt;假如我们要实现自动登录线上数据库，并查看所有数据表。具体步骤可以分为以下几步：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;登陆跳板机&lt;/li&gt;
&lt;li&gt;通过跳板机登陆线上数据库&lt;/li&gt;
&lt;li&gt;选择database，然后执行 show tables 命令&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;以下是笔者提供一个简单的脚本程序模版：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#!/usr/bin/expect -f
# 脚本的参数，mysql服务器的登陆地址，密码，以及 选择数据库指令
set loginCommand [lrange $argv 0 1]
set passwd [lrange $argv 2 2]
set script [lrange $argv 3 4]
# 等待命令执行的超时时间，10s
set timeout 10

# 1. 登陆跳板机
spawn ssh 用户名@跳板机的host
expect {
    # 输入跳板机登陆密码（第1步指令执行完后，会输出xxx@xxx's password: 提示输入跳板机密码)
    &quot;用户名@跳板机的host's password:&quot; {send &quot;跳板机密码\r&quot;; exp_continue}
    
    # 2. 通过跳板机登陆数据库(笔者公司的跳板机登陆完成后，会提示输入INPUT:,提示输入要登陆的服务器ip)
    &quot;*INPUT:&quot; {send &quot;$loginCommand\r&quot;; exp_continue}
    # 输入要登陆数据库的密码
    &quot;Enter password:&quot; {send &quot;$passwd\r&quot; ; exp_continue}
    
    # 密码输入错误，退出（如果密码输入错误，提示文案中会出现ERROR字样）
    &quot;*ERROR*&quot; interact;
    # 3. 输入数据库指令
    &quot;Welcome to the MySQL monitor*&quot; {send &quot;$script\r&quot;; exp_continue}
    # 执行show tables指令
    &quot;Reading table information*&quot; {send &quot;show tables;\r&quot;}
}
interact
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Command中配置脚本文件和执行参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;/Users/xxx/ssh_login.exp mysql yaccount_relay@xxaccount.db.xxx.com:3456  数据库密码 use dbzz_zzpayaccount
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/1.png&quot; alt=&quot;1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行配置文件，效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/2a221eef6c6d8e46db95c8850b27a80b.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;iTerm2支持很多自定义的个性化配置，还有有趣且实用的功能等着你去探索。如果你想让你的iTerm2外观变得炫酷的，更加极客。不妨看看这里https://www.jianshu.com/p/7de00c73a2bb，以下是笔者修改后的效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/e5824e2aee3b16ae81cc607d03a50a26.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;篇幅有限，像&lt;strong&gt;密码管理器&lt;/strong&gt;，&lt;strong&gt;输入（命令）广播&lt;/strong&gt;等实用的功能还有很多，这里就不一一列举。据说每个程序员都有自己的一套葵花宝典，欢迎各位同学在留言区把你最顺手的工具分享给大家！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;看后有收获记得点推荐哦！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 14 Jan 2021 16:57:00 +0000</pubDate>
<dc:creator>Java填坑笔记</dc:creator>
<og:description>天下武功，无坚不摧，唯快不破！Mac用户请留步！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/14280203.html</dc:identifier>
</item>
<item>
<title>Spring Cloud实战 | 第十篇 ：Spring Cloud + Seata 1.4.1  + Nacos1.4.0 整合实现微服务架构中的必不可少的分布式事务 - 你好，旧时光</title>
<link>http://www.cnblogs.com/haoxianrui/p/14280184.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoxianrui/p/14280184.html</guid>
<description>&lt;p&gt;Seata分布式事务在线体验地址： &lt;a href=&quot;http://www.youlai.store&quot; target=&quot;_blank&quot;&gt;www.youlai.store&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/14/ACcKBaGte5s7Wy9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本篇完整源码地址：&lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot; target=&quot;_blank&quot;&gt;https://github.com/hxrui/youlai-mall&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有想加入开源项目开发的童鞋也可以联系我（微信号：haoxianrui），希望大家能够一起交流学习。觉得项目对你有帮助希望能给一个star或者关注，持续更新中。。。&lt;/p&gt;
&lt;h2 id=&quot;一-前言&quot;&gt;一. 前言&lt;/h2&gt;
&lt;p&gt;相信了解过开源项目 &lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot; target=&quot;_blank&quot;&gt;youlai-mall&lt;/a&gt; 的童鞋应该知道该项目主要是基于Spring Cloud + Vue等&lt;strong&gt;当前最新最主流技术&lt;/strong&gt;落地实现的一套微服务架构 + 前后端分离的全栈商城系统（App、微信小程序等）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;往期文章链接：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13581881.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第一篇：Windows搭建Nacos服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13584204.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第二篇：Spring Cloud整合Nacos实现注册中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13585125.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第三篇：Spring Cloud整合Nacos实现配置中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13608650.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第四篇：Spring Cloud整合Gateway实现API网关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13615592.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第五篇：Spring Cloud整合OpenFeign实现微服务之间的调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13719356.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 第六篇：Spring Cloud Gateway+Spring Security OAuth2+JWT实现微服务统一认证授权&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13740264.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 最七篇：Spring Cloud Gateway+Spring Security OAuth2集成统一认证授权平台下实现注销使JWT失效方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14022632.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 最八篇：Spring Cloud +Spring Security OAuth2+ Vue前后端分离模式下无感知刷新实现JWT续期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14022632.html&quot; target=&quot;_blank&quot;&gt;Spring Cloud实战 | 最九篇：Spring Security OAuth2认证服务器统一认证自定义异常处理&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;管理前端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13624548.html&quot; target=&quot;_blank&quot;&gt;vue-element-admin实战 | 第一篇： 移除mock接入后台，搭建有来商城youlai-mall前后端分离管理平台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13676619.html&quot; target=&quot;_blank&quot;&gt;vue-element-admin实战 | 第二篇： 最小改动接入后台实现根据权限动态加载菜单&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;微信小程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13882310.html&quot; target=&quot;_blank&quot;&gt;vue+uniapp商城实战 | 第一篇：【有来小店】微信小程序快速开发接入Spring Cloud OAuth2认证中心完成授权登录&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;部署篇&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14088400.html&quot; target=&quot;_blank&quot;&gt;Docker实战 | 第二篇：IDEA集成Docker插件实现一键自动打包部署微服务项目，一劳永逸的技术手段值得一试&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14091762.html&quot; target=&quot;_blank&quot;&gt;Docker实战 | 第三篇：Docker安装Nginx，实现基于vue-element-admin框架构建的项目线上部署&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说到微服务，自然就少不了保证服务之间数据一致性的分布式事务，所以本篇就以Seata的AT模式如何在微服务的实际场景中应用进行实战说明，希望大家都能有个看其形知其意的效果。&lt;/p&gt;
&lt;h3 id=&quot;1-需求描述&quot;&gt;1. 需求描述&lt;/h3&gt;
&lt;p&gt;会员提交订单，扣减商品库存，增加会员积分，完成前面步骤，更改订单状态为已完成。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/08/pa8OziyTcYbDg1G.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据需求可知这其中牵涉到订单、商品、会员3个微服务，分别对应 &lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot; target=&quot;_blank&quot;&gt;youlai-mall&lt;/a&gt; 商城项目的 mall-oms、mall-pms、mall-ums微服务。&lt;/p&gt;
&lt;h3 id=&quot;2-技术版本&quot;&gt;2. 技术版本&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;技术&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Spring Cloud&lt;/td&gt;
&lt;td&gt;Hoxton.SR9&lt;/td&gt;
&lt;td&gt;微服务架构&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Nacos&lt;/td&gt;
&lt;td&gt;1.4.0&lt;/td&gt;
&lt;td&gt;注册、配置中心&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Seata&lt;/td&gt;
&lt;td&gt;1.4.1&lt;/td&gt;
&lt;td&gt;分布式事务&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;3-环境准备&quot;&gt;3. 环境准备&lt;/h3&gt;
&lt;h4 id=&quot;31-nacos安装和配置&quot;&gt;3.1 Nacos安装和配置&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/14059009.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/haoxianrui/p/14059009.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;进入Nacos控制台,创建seata命名空间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/08/db2eiAvSW7gG85s.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记住命名空间ID自定义为&lt;code&gt;seata_namespace_id&lt;/code&gt;，后面需要&lt;/p&gt;
&lt;h4 id=&quot;32-seata数据库创建&quot;&gt;3.2 Seata数据库创建&lt;/h4&gt;
&lt;p&gt;创建数据库名为&lt;code&gt;seata&lt;/code&gt;，执行Seata的Github官方源码中提供的的MySQL数据库脚本&lt;/p&gt;
&lt;p&gt;MySQL脚本地址：&lt;br/&gt;&lt;a href=&quot;https://github.com/seata/seata/blob/1.4.1/script/server/db/mysql.sql&quot; target=&quot;_blank&quot;&gt;https://github.com/seata/seata/blob/1.4.1/script/server/db/mysql.sql&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二-seata-server安装&quot;&gt;二. seata-server安装&lt;/h2&gt;
&lt;p&gt;点击 &lt;a href=&quot;https://registry.hub.docker.com/r/seataio/seata-server/tags?page=1&amp;amp;ordering=last_updated&quot; target=&quot;_blank&quot;&gt;Docker Hub链接&lt;/a&gt; 查看最新Seata版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/08/PSiyeXL1ZpBKfEQ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到最新版本为1.4.1版本，复制指令获取最新版本镜像&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull seataio/seata-server:1.4.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动临时容器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d --name seata -p 8091:8091 seataio/seata-server
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从临时容器获取到 &lt;code&gt;registry.conf&lt;/code&gt; 配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /opt/seata
docker cp seata:/seata-server/resources/registry.conf  /etc/seata
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;registry.conf&lt;/code&gt;配置,类型选择nacos，namesapce为上文中在nacos新建的命名空间id即&lt;code&gt;seata_namespace_id&lt;/code&gt;，精简如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /opt/seata/registry.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;registry {
  type = &quot;nacos&quot;
  loadBalance = &quot;RandomLoadBalance&quot;
  loadBalanceVirtualNodes = 10

  nacos {
    application = &quot;seata-server&quot;
    serverAddr = &quot;c.youlai.store:8848&quot;
    namespace = &quot;seata_namespace_id&quot;
    cluster = &quot;default&quot;
  }
}
config {
  type = &quot;nacos&quot;
  
  nacos {
    serverAddr = &quot;c.youlai.store:8848&quot;
    namespace = &quot;seata_namespace_id&quot;
    group = &quot;SEATA_GROUP&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安排好 &lt;code&gt;registry.conf&lt;/code&gt; 之后，删除临时容器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker rm -f seata
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来着手开始推送Seata依赖配置至Nacos&lt;/p&gt;
&lt;p&gt;从Seata的GitHub官方源码获取配置文件(config.txt)和推送脚本文件(nacos/nacos-config.sh)&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://github.com/seata/seata/blob/develop/script/config-center&quot; target=&quot;_blank&quot;&gt;https://github.com/seata/seata/blob/develop/script/config-center&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;因为脚本的关系，文件存放目录如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;/opt/seata
├── config.txt
└── nacos
    └── nacos-config.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改配置文件 &lt;code&gt;config.txt&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vim /opt/seata/config.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改事务组和MySQL连接信息，修改信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;service.vgroupMapping.mall_tx_group=default

store.mode=db
store.db.driverClassName=com.mysql.cj.jdbc.Driver
store.db.url=jdbc:mysql://www.youlai.store:3306/seata?useUnicode=true&amp;amp;rewriteBatchedStatements=true
store.db.user=root
store.db.password=123456
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行推送命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cd /opt/seata/nacos

bash nacos-config.sh -h c.youlai.store -p 8848 -g SEATA_GROUP -t seata_namespace_id -u nacos -w nacos
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;-t seata_namespace_id 指定Nacos配置命名空间ID&lt;/li&gt;
&lt;li&gt;-g SEATA_GROUP 指定Nacos配置组名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果有 &lt;code&gt;init nacos config fail.&lt;/code&gt; 报错信息，请检查修改信息，如果有属性修改提示&lt;code&gt;failure&lt;/code&gt;，请修改config.txt中属性。&lt;/p&gt;
&lt;p&gt;如果出现类似 &lt;code&gt;cat: /tmp/tmp.rRGz1B7MUP: No such file or directory&lt;/code&gt; 的错误不用慌，重新执行推送命令直至成功。&lt;/p&gt;
&lt;p&gt;推送执行完毕，到Nacos控制台查看配置是否已添加成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/09/iuK4jUw1cqeVP97.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;做完上述准备工作之后，接下来最后一步:启动Seata容器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d --name seata --restart=always -p 8091:8091  \
-e SEATA_IP=c.youlai.store \
-e SEATA_CONFIG_NAME=file:/seata-server/resources/registry.conf \
-v /opt/seata/registry.conf:/seata-server/resources/registry.conf \
-v /opt/seata/logs:/root/logs \
seataio/seata-server
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三-seata客户端&quot;&gt;三. Seata客户端&lt;/h2&gt;
&lt;p&gt;上文完成了Seata服务端应用安装、添加Seata配置至Nacos配置中心以及注册Seata到Nacos注册中心。&lt;/p&gt;
&lt;p&gt;接下来的工作就是客户端的配置，通过相关配置把订单(mall-oms)、商品(mall-pms)、会员(mall-ums)这3个微服务关联seata-server。&lt;/p&gt;
&lt;h3 id=&quot;1-添加undo_log表&quot;&gt;1. 添加undo_log表&lt;/h3&gt;
&lt;p&gt;Seata的AT模式下之所以在第一阶段直接提交事务，依赖的是需要在每个RM创建一张undo_log表，记录业务执行前后的数据快照。&lt;/p&gt;
&lt;p&gt;如果二阶段需要回滚，直接根据undo_log表回滚，如果执行成功，则在第二阶段删除对应的快照数据。&lt;/p&gt;
&lt;p&gt;Seata官方Github源码库undo_log表脚本地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/seata/seata/blob/1.4.1/script/client/at/db/mysql.sql&quot; target=&quot;_blank&quot;&gt;https://github.com/seata/seata/blob/1.4.1/script/client/at/db/mysql.sql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注意第一行的注释说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- for AT mode you must to init this sql for you business database. the seata server not need it.
CREATE TABLE IF NOT EXISTS `undo_log`
(
    `branch_id`     BIGINT(20)   NOT NULL COMMENT 'branch transaction id',
    `xid`           VARCHAR(100) NOT NULL COMMENT 'global transaction id',
    `context`       VARCHAR(128) NOT NULL COMMENT 'undo_log context,such as serialization',
    `rollback_info` LONGBLOB     NOT NULL COMMENT 'rollback info',
    `log_status`    INT(11)      NOT NULL COMMENT '0:normal status,1:defense status',
    `log_created`   DATETIME(6)  NOT NULL COMMENT 'create datetime',
    `log_modified`  DATETIME(6)  NOT NULL COMMENT 'modify datetime',
    UNIQUE KEY `ux_undo_log` (`xid`, `branch_id`)
) ENGINE = InnoDB
  AUTO_INCREMENT = 1
  DEFAULT CHARSET = utf8 COMMENT ='AT transaction mode undo table';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别在项目的 mall-oms、mall-pms、mall-ums 的三个数据库执行脚本创建 &lt;code&gt;undo_log&lt;/code&gt; 表&lt;/p&gt;
&lt;h3 id=&quot;2-添加依赖&quot;&gt;2. 添加依赖&lt;/h3&gt;
&lt;p&gt;分别为 &lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot; target=&quot;_blank&quot;&gt;youlai-mall&lt;/a&gt; 的 mall-oms、mall-pms、mall-ums 微服务添加如下seata客户端依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.seata&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;seata-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-seata&amp;lt;/artifactId&amp;gt;
    &amp;lt;exclusions&amp;gt;
        &amp;lt;!-- 排除依赖 指定版本和服务器端一致 --&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;io.seata&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;seata-all&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
        &amp;lt;exclusion&amp;gt;
            &amp;lt;groupId&amp;gt;io.seata&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;seata-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/exclusion&amp;gt;
    &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.seata&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;seata-all&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.seata&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;seata-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.4.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用Alibaba官方提供的Spring Cloud和Seata整合好的Spring Boot启动器 &lt;code&gt;spring-cloud-starter-alibaba-seata&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要指定seata版本和服务版本一致，这里也就是1.4.1&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3-yml配置&quot;&gt;3. yml配置&lt;/h3&gt;
&lt;p&gt;Seata官方Github源码库Spring配置链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/seata/seata/blob/1.4.1/script/client/spring/application.yml&quot; target=&quot;_blank&quot;&gt;https://github.com/seata/seata/blob/1.4.1/script/client/spring/application.yml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置精简如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 分布式事务配置
seata:
  tx-service-group: mall_tx_group
  enable-auto-data-source-proxy: true
  registry:
    type: nacos
    nacos:
      server-addr: c.youlai.store:8848
      namespace: seata_namespace_id
      group: SEATA_GROUP
  config:
    type: nacos
    nacos:
      server-addr: c.youlai.store:8848
      namespace: seata_namespace_id
      group: SEATA_GROUP
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tx-service-group: mall_tx_group&lt;/code&gt; 配置事务群组,其中群组名称 &lt;code&gt;mall_tx_group&lt;/code&gt; 需和服务端的配置 &lt;code&gt;service.vgroupMapping.mall_tx_group=default&lt;/code&gt; 一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enable-auto-data-source-proxy: true&lt;/code&gt; 自动为Seata开启了代理数据源，实现集成对undo_log表操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;namespace: seata_namespace_id&lt;/code&gt; seata-server一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;group: SEATA_GROUP&lt;/code&gt; seata-server一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将精简的配置分别放置到 mall-oms、mall-pms、mall-ums的配置文件中&lt;/p&gt;
&lt;h3 id=&quot;4-启动类调整&quot;&gt;4. 启动类调整&lt;/h3&gt;
&lt;p&gt;因为要使用Seata提供的代理数据源，所以在启动类移除SpringBoot自动默认装配的数据源&lt;/p&gt;
&lt;p&gt;同样也是需要在3个微服务启动类分别调整，不然分布式事务不会生效&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四-测试环境模拟&quot;&gt;四. 测试环境模拟&lt;/h2&gt;
&lt;p&gt;根据上诉步骤完成Seata服务安装以及客户端的配置之后&lt;/p&gt;
&lt;p&gt;接下来就开始着手 &lt;code&gt;透过现象看本质&lt;/code&gt; 的工作，根据业务需求创建业务表和编写业务代码&lt;/p&gt;
&lt;h3 id=&quot;1-业务表&quot;&gt;1. 业务表&lt;/h3&gt;
&lt;p&gt;提供业务表关键字段，完整表结构请点击 &lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot; target=&quot;_blank&quot;&gt;youlai-mall&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;订单表(oms_order):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE `oms_order` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT 'id',
  `status` int NOT NULL DEFAULT '101' COMMENT '订单状态【101-&amp;gt;待付款；102-&amp;gt;用户取消；103-&amp;gt;系统取消；201-&amp;gt;已付款；202-&amp;gt;申请退款；203-&amp;gt;已退款；301-&amp;gt;待发货；401-&amp;gt;已发货；501-&amp;gt;用户收货；502-&amp;gt;系统收货；901-&amp;gt;已完成】',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='订单表';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;库存表(pms_sku):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE `pms_sku` (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '商品id',
  `stock` int NOT NULL DEFAULT '0' COMMENT '库存',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci ROW_FORMAT=DYNAMIC COMMENT='商品库存表';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;会员表(ums_user):&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE TABLE `ums_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `point` int DEFAULT '0' COMMENT '会员积分',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 ROW_FORMAT=DYNAMIC COMMENT='会员信息表';
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-业务代码&quot;&gt;2. 业务代码&lt;/h3&gt;
&lt;p&gt;提供核心业务代码，完整代码请点击 &lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot; target=&quot;_blank&quot;&gt;youlai-mall&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;订单微服务(mall-oms)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码定位：OmsOrderServiceImpl#submit&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
@GlobalTransactional(rollbackFor = Exception.class)
public boolean submit() {
    log.info(&quot;扣减库存----begin&quot;);
    productFeignService.updateStock(1l, -1);
    log.info(&quot;扣减库存----end&quot;);

    log.info(&quot;增加积分----begin&quot;);
    memberFeignService.updatePoint(1l, 10);
    log.info(&quot;增加积分----end&quot;);

    log.info(&quot;修改订单状态----begin&quot;);
    boolean result = this.update(new LambdaUpdateWrapper&amp;lt;OmsOrder&amp;gt;().eq(OmsOrder::getId, 1l).set(OmsOrder::getStatus, 901));
    log.info(&quot;修改订单状态----end&quot;);
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;@GlobalTransactional注解，标识TM（事务管理器）开启全局事务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;商品微服务(mall-pms)：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码定位：AppSkuController#updateStock&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@PutMapping(&quot;/{id}/stock&quot;)
public Result updateStock(@PathVariable Long id, @RequestParam Integer num) {
    PmsSku sku = iPmsSkuService.getById(id);
    sku.setStock(sku.getStock() + num);
    boolean result = iPmsSkuService.updateById(sku);
    return Result.status(result);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;会员微服务(mall-ums)：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; @PutMapping(&quot;/{id}/point&quot;)
public Result updatePoint(@PathVariable Long id, @RequestParam Integer num) {
    UmsUser user = iUmsUserService.getById(id);
    user.setPoint(user.getPoint() + num);
    boolean result = iUmsUserService.updateById(user);
    try {
        Thread.sleep(15 * 1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return Result.status(result);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Thread.sleep(15 * 1000); 模拟超时异常验证事务是否能正常回滚&lt;/p&gt;
&lt;p&gt;注意15s的设定有讲究的&lt;/p&gt;
&lt;p&gt;先看下订单微服务的feign调用配置,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ribbon:
  ReadTimeout: 10000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;feign底层使用ribbon做负载均衡和远程调用，上面设置ribbon的超时时间为10s&lt;/p&gt;
&lt;p&gt;然而在订单调用会员服务的时候需要至少15s才能获得结果，显然会造成接口请求超时的异常，接下来就看事务能不能进行正常回滚。&lt;/p&gt;
&lt;h2 id=&quot;五-验证测试&quot;&gt;五. 验证测试&lt;/h2&gt;
&lt;p&gt;本篇源码包括测试用例均已整合到 &lt;a href=&quot;https://github.com/hxrui/youlai-mall&quot; target=&quot;_blank&quot;&gt;youlai-mall&lt;/a&gt; ，大家有条件的话可以搭建一个本地环境调试一下，项目从无到有的搭建参考项目中的说明文档。&lt;/p&gt;
&lt;p&gt;但如果你想快速验证Seata分布式事务和看到效果，ok，满足你，在项目中添加了一个 &lt;code&gt;实验室&lt;/code&gt; 的菜单，计划用于技术点测试，也方便给大家提供一个完整的测试环境。&lt;/p&gt;
&lt;p&gt;话不多说，看界面效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/10/hsPp7MtZiKluW6Y.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看完上图标注的地方，接下来通过界面来进行分布式事务测试&lt;/p&gt;
&lt;p&gt;首先确定一下前提订单提交肯定会因为会员积分服务超时出现异常&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;关闭事务提交&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/14/vQq9zrPOWwsmdpt.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到在关闭事务提交订单异常的情况下，库存和积分更新成功了，然而订单确更新失败了&lt;/p&gt;
&lt;p&gt;接下来再看下开启事务提交的结果又会是如何呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;开启事务提交&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/10/qtZ2FX5DWM8VA4O.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更新订单状态失败，因开启了全局事务，导致已更新的商品库存、积分被回滚至初始状态。&lt;/p&gt;
&lt;h2 id=&quot;六-结语&quot;&gt;六. 结语&lt;/h2&gt;
&lt;p&gt;以上就Seata分布式事务结合实际场景应用的案例进行整合和测试，最后可以看到通过Seata实现了微服务调用链的最终数据一致性。最后提供了在线体验实验室功能模块，大家可以拉取到本地然后断点调试以及监听数据表的数据变化，相信应该会很快掌握Seata的执行流程和实现原理。&lt;/p&gt;
&lt;p&gt;最后，觉得项目不错的话或对你有帮助的话，希望能给个star，持续更新中...&lt;/p&gt;
</description>
<pubDate>Thu, 14 Jan 2021 16:41:00 +0000</pubDate>
<dc:creator>你好，旧时光</dc:creator>
<og:description>Seata分布式事务在线体验地址： www.youlai.store 本篇完整源码地址：https://github.com/hxrui/youlai-mall 有想加入开源项目开发的童鞋也可以联系我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haoxianrui/p/14280184.html</dc:identifier>
</item>
<item>
<title>利用github给国外文件下载加速 - 吃西瓜的星星</title>
<link>http://www.cnblogs.com/zhuxiaoxiao/p/14280136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuxiaoxiao/p/14280136.html</guid>
<description>&lt;p&gt;作为一名程序员，经常需要下载一些编程相关的环境，而国内的网络环境大家都知道，有的文件用浏览器是下载不动的，于是我有了利用github下载文件的想法。&lt;/p&gt;
&lt;p&gt;我的demo项目地址：&lt;a href=&quot;https://github.com/bobowire/wireboy.remote.download&quot; target=&quot;_blank&quot;&gt;https://github.com/bobowire/wireboy.remote.download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;NodeJS使用node-fetch下载文件并显示下载进度示例：&lt;a href=&quot;https://www.jianshu.com/p/4b58711cb72a&quot; target=&quot;_blank&quot;&gt;https://www.jianshu.com/p/4b58711cb72a&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;nodejs——发送邮件（带附件）：&lt;a href=&quot;https://www.cnblogs.com/yourstars/p/6728931.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yourstars/p/6728931.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用github的Action远程执行文件下载（下载qt环境速度可以达到3mb/s），然后将下载的文件进行分片，每片15mb，分片后的文件以邮件附件的方式发送到国内邮箱，我们通过下载邮箱中的附件，将分片的附件合并成完整文件，从而实现不翻墙、不用下载器也能下载国外文件的目的。&lt;/p&gt;
&lt;h2 id=&quot;简单点说&quot;&gt;简单点说&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;github远程下载&lt;/li&gt;
&lt;li&gt;文件分片&lt;/li&gt;
&lt;li&gt;通过邮箱发到国内&lt;/li&gt;
&lt;li&gt;对附件进行合并&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;新建github项目&lt;/li&gt;
&lt;li&gt;创建js文件download.js文件，内容请查阅后文&lt;/li&gt;
&lt;li&gt;创建workflows/RunDownload.yml文件，内容请查阅后文&lt;/li&gt;
&lt;li&gt;修改download.js中的fileURL 变量值，此为文件url地址&lt;/li&gt;
&lt;li&gt;在项目github-&amp;gt;settings-&amp;gt;Secrets中，点击右上方“new responsitory secret”按钮，添加&quot;EMAILPASS&quot;,&quot;SENDEMAIL&quot;,&quot;TOEMAIL&quot;变量（授权码、发送邮箱、目标邮箱）&lt;/li&gt;
&lt;li&gt;以上全部完成后，我们每次修改download.js文件的fileURL地址，github都会自动进行一次下载。原理请自行百度“github action”。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;授权码（EMAILPASS）是指“邮箱第三方登录授权码”，如何获取授权码，以QQ邮箱为例，请点击：&lt;a href=&quot;http://jingyan.baidu.com/article/fedf0737af2b4035ac8977ea.html&quot; target=&quot;_blank&quot;&gt;http://jingyan.baidu.com/article/fedf0737af2b4035ac8977ea.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;
&lt;code&gt;name: Github wireboy.remote.download
 
on:
    push:
        branches:
            - main
    schedule:
     - cron: '* * * * *'
jobs:
    build:
        runs-on: ubuntu-latest
 
        steps:
            - name: Checkout codes
              uses: actions/checkout@v2
            - name: Use Node.js
              uses: actions/setup-node@v1
              with:
                node-version: '12.x'
            - name: Run
              run: npm install
              
            - run: node download.js
              
              env:
                EMAILPASS: ${{ secrets.EMAILPASS }}
                SENDEMAIL: ${{ secrets.SENDEMAIL }}
                TOEMAIL: ${{ secrets.TOEMAIL }}

&lt;/code&gt;
&lt;/pre&gt;

&lt;pre&gt;
&lt;code&gt;const fetch = require(&quot;node-fetch&quot;);
const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const progressStream = require('progress-stream');
const nodemailer = require('nodemailer');


//下载 的文件 地址 （https://nodejs.org/dist/v12.18.3/node-v12.18.3-x64.msi）
let fileURL = 'https://nodejs.org/dist/v12.18.3/node-v12.18.3-x64.msi';


//下载保存的文件路径
let fileSavePath = path.join(__dirname, path.basename(fileURL));
//缓存文件路径
let tmpFileSavePath = fileSavePath + &quot;.tmp&quot;;
//创建写入流
const fileStream = fs.createWriteStream(tmpFileSavePath).on('error', function (e) {
    console.error('error==&amp;gt;', e)
}).on('ready', function () {
    console.log(&quot;开始下载:&quot;, fileURL);
}).on('finish', function () {
    //下载完成后重命名文件
    fs.renameSync(tmpFileSavePath, fileSavePath);
    console.log('文件下载完成:', fileSavePath);
    const readstream = fs.createReadStream(fileSavePath);
        let i = 0;
        console.time('readtime');
    let patchIndex = 0;
        readstream.on('readable', () =&amp;gt; {
        {
            console.log('start read');
            let chunk = readstream.read(1024 * 1024 * 15);
            while (null !== chunk) {
                patchIndex = patchIndex + 1;
                console.log('read times:'+patchIndex)
                console.log(fileSavePath+'.email_'+patchIndex);
                let emailFile = fs.createWriteStream(fileSavePath+'.email_'+patchIndex).on('finish',function(){
    
                })
                emailFile.write(chunk);
                emailFile.end();
                let msg = createEmailMessage(patchIndex+'_'+path.basename(fileURL),fileSavePath+'.email_'+patchIndex,path.basename(fileURL) + '(' + patchIndex + ')');
                console.log('Send Mail ' + patchIndex + ' times');
                console.log(path.basename(fileURL));
                var transporter = createTransporter();
                transporter.sendMail(msg, (error, info) =&amp;gt; {
                    if (error) {
                        console.log('Error occurred');
                        console.log(error.message);
                        return;
                    }
                    console.log('Message sent successfully!');
                    console.log('Server responded with &quot;%s&quot;', info.response);
                    transporter.close();
                });
    
                chunk = readstream.read(1024 * 1024 * 10);
            }
            console.log('end read');
        }
        });
        readstream.on('close', () =&amp;gt; {
                console.timeEnd('readtime');
    });
    
});
//请求文件
fetch(fileURL, {
    method: 'GET',
    headers: { 'Content-Type': 'application/octet-stream' },
    // timeout: 100,    
}).then(res =&amp;gt; {
    //获取请求头中的文件大小数据
    let fsize = res.headers.get(&quot;content-length&quot;);
    //创建进度
    let str = progressStream({
        length: fsize,
        time: 100 /* ms */
    });
    // 下载进度 
    str.on('progress', function (progressData) {
        //不换行输出
        let percentage = Math.round(progressData.percentage) + '%';
        console.log(percentage);
        // process.stdout.write('\033[2J'+);
        // console.log(progress);
        /*
        {
            percentage: 9.05,
            transferred: 949624,
            length: 10485760,
            remaining: 9536136,
            eta: 42,
            runtime: 3,
            delta: 295396,
            speed: 949624
        }
        */
    });
    res.body.pipe(str).pipe(fileStream);
}).catch(e =&amp;gt; {
    //自定义异常处理
    console.log(e);
});



var createTransporter = function(){
    return nodemailer.createTransport({
        service: 'qq',
        auth: {
            user: process.env.SENDEMAIL,//发送者邮箱
            pass: process.env.EMAILPASS //邮箱第三方登录授权码
        },
       //  logger: bunyan.createLogger({
       //      name: 'nodemailer'
       //  }),//打印日志
        debug: true
    },{
        from: process.env.SENDEMAIL,//发送者邮箱
        headers: {
            'X-Laziness-level': 1000
        }
    });
} 

console.log('SMTP Configured');

var createEmailMessage = function(filename,filepath,subject){
    var message = {
        // Comma separated lsit of recipients 收件人用逗号间隔
        to: process.env.TOEMAIL,
    
        // Subject of the message 信息主题
        subject:  subject,
    
        // plaintext body
        text: '请查阅附件',
    
        // Html body
        html: '&amp;lt;p&amp;gt;下载文件成功&amp;lt;/p&amp;gt;',
    
        // Apple Watch specific HTML body 苹果手表指定HTML格式
        watchHtml: '&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt; to myself',
    
        // An array of attachments 附件
        attachments: [
            // String attachment
           //  {
           //      filename: 'notes.txt',
           //      content: 'Some notes about this e-mail',
           //      contentType: 'text/plain' // optional,would be detected from the filename 可选的，会检测文件名
           //  },
           //  // Binary Buffer attchment
           //  {
           //      filename: 'image.png',
           //      content: Buffer.from('iVBORw0KGgoAAAANSUhEUgAAABAAAAAQAQMAAAAlPW0iAAAABlBMVEUAAAD/' +
           //         '//+l2Z/dAAAAM0lEQVR4nGP4/5/h/1+G/58ZDrAz3D/McH8yw83NDDeNGe4U' +
           //         'g9C9zwz3gVLMDA/A6P9/AFGGFyjOXZtQAAAAAElFTkSuQmCC', 'base64'),
           //      cid: '00001'  // should be as unique as possible 尽可能唯一
           //  },
            // File Stream attachment
            {
                filename: filename,
                path: filepath,
                // cid: '00002'  // should be as unique as possible 尽可能唯一
             }
        ]
    
    };
    return message;
};

&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;收件箱&quot;&gt;收件箱&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/614311/202101/614311-20210115001717516-947066890.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/614311/202101/614311-20210115001911025-2046540940.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/614311/202101/614311-20210115001757088-1170194519.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Jan 2021 16:20:00 +0000</pubDate>
<dc:creator>吃西瓜的星星</dc:creator>
<og:description>前言 作为一名程序员，经常需要下载一些编程相关的环境，而国内的网络环境大家都知道，有的文件用浏览器是下载不动的，于是我有了利用github下载文件的想法。 我的demo项目地址：https://git</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuxiaoxiao/p/14280136.html</dc:identifier>
</item>
<item>
<title>.NET 云原生架构师训练营（模块二 基础巩固 RabbitMQ Masstransit 异常处理）--学习笔记 - MingsonZheng</title>
<link>http://www.cnblogs.com/MingsonZheng/p/14280129.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingsonZheng/p/14280129.html</guid>
<description>&lt;ul&gt;&lt;li&gt;异常处理&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;li&gt;高级功能&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;异常处理&quot;&gt;异常处理&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;异常与重试&lt;/li&gt;
&lt;li&gt;重试配置&lt;/li&gt;
&lt;li&gt;重试条件&lt;/li&gt;
&lt;li&gt;重新投递信息&lt;/li&gt;
&lt;li&gt;信箱&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;异常与重试&quot;&gt;异常与重试&lt;/h3&gt;
&lt;p&gt;Exception&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SubmitOrderConsumer :
    IConsumer&amp;lt;SubmitOrder&amp;gt;
{
    public Task Consume(ConsumeContext&amp;lt;SubmitOrder&amp;gt; context)
    {
        throw new Exception(&quot;Very bad things happened&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;UseMessageRetry&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var sessionFactory = CreateSessionFactory();

var busControl = Bus.Factory.CreateUsingRabbitMq(cfg =&amp;gt;
{
    cfg.Host(&quot;rabbitmq://localhost/&quot;);

    cfg.ReceiveEndpoint(&quot;submit-order&quot;, e =&amp;gt;
    {
        e.UseMessageRetry(r =&amp;gt; r.Immediate(5));

        e.Consumer(() =&amp;gt; new SubmitOrderConsumer(sessionFactory));
    });
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重试配置&quot;&gt;重试配置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210115000828342-284032162.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 立即重试：一共连续重试10次
ep.UseMessageRetry(r =&amp;gt; r.Immediate(10));

// 间隔重试：一共重试10次，每次间隔10秒
ep.UseMessageRetry(r =&amp;gt; r.Interval(10, TimeSpan.FromSeconds(10)));

// 多个间隔重试：5秒后第一次，5+10秒后第二次，5+10+15秒后第三次
ep.UseMessageRetry(r =&amp;gt; r.Intervals(TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(15)));

// 指数级间隔重试：共10次，每次间隔：当前重试次数 * 60秒
ep.UseMessageRetry(r =&amp;gt; r.Exponential(10, TimeSpan.FromSeconds(60), TimeSpan.FromHours(24), TimeSpan.FromSeconds(60)));

// 每次叠加50秒
ep.UseMessageRetry(r =&amp;gt; r.Incremental(10, TimeSpan.FromSeconds(10), TimeSpan.FromSeconds(50)));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;重试条件&quot;&gt;重试条件&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;e.UseMessageRetry(r =&amp;gt; 
{
    r.Handle&amp;lt;ArgumentNullException&amp;gt;();
    r.Ignore(typeof(InvalidOperationException), typeof(InvalidCastException));
    r.Ignore&amp;lt;ArgumentException&amp;gt;(t =&amp;gt; t.ParamName == &quot;orderTotal&quot;);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过滤某些异常类型不进行重试&lt;/p&gt;
&lt;h3 id=&quot;重新投递信息&quot;&gt;重新投递信息&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cfg.ReceiveEndpoint(&quot;submit-order&quot;, e =&amp;gt;
{
    e.UseScheduledRedelivery(r =&amp;gt; r.Intervals(TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(15), TimeSpan.FromMinutes(30)));
    e.UseMessageRetry(r =&amp;gt; r.Immediate(5));
    e.Consumer(() =&amp;gt; new SubmitOrderConsumer(sessionFactory));
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消息冲队列移除之后，在一定时间之后重新投入消息队列。需要配置调度模块（scheduling）&lt;/p&gt;
&lt;h2 id=&quot;信箱&quot;&gt;信箱&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;cfg.ReceiveEndpoint(&quot;submit-order&quot;, e =&amp;gt;
{
    e.UseScheduledRedelivery(r =&amp;gt; r.Intervals(TimeSpan.FromMinutes(5), TimeSpan.FromMinutes(15), TimeSpan.FromMinutes(30)));
    e.UseMessageRetry(r =&amp;gt; r.Immediate(5));
    e.UseInMemoryOutbox();

    e.Consumer(() =&amp;gt; new SubmitOrderConsumer(sessionFactory));
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有些消息是在 consume 方法中发送或发布的，如果在发送之后 consume 中产生了异常，那原来发出去的消息就需要撤回，如果使用信箱之后，在 consume 中要发布/发送的消息就会先暂存在内存中直到 consume 方法成功之后才真正发出去&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Fault&lt;/li&gt;
&lt;li&gt;Consuming Faults&lt;/li&gt;
&lt;li&gt;Error Pipe&lt;/li&gt;
&lt;li&gt;Dead-Letter Pipe&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;fault&quot;&gt;Fault&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public interface Fault&amp;lt;T&amp;gt;
    where T : class
{
    Guid FaultId { get; }
    Guid? FaultedMessageId { get; }
    DateTime Timestamp { get; }
    ExceptionInfo[] Exceptions { get; }
    HostInfo Host { get; }
    T Message { get; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Fault 消息在异常的时候会发布出来&lt;/p&gt;
&lt;h3 id=&quot;consuming-faults&quot;&gt;Consuming Faults&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class DashboardFaultConsumer :
    IConsumer&amp;lt;Fault&amp;lt;SubmitOrder&amp;gt;&amp;gt;
{
    public async Task Consume(ConsumeContext&amp;lt;Fault&amp;lt;SubmitOrder&amp;gt;&amp;gt; context)
    {
        // update the dashboard
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Fault 消息也是可以进行订阅的&lt;/p&gt;
&lt;h3 id=&quot;error-pipe&quot;&gt;Error Pipe&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cfg.ReceiveEndpoint(&quot;input-queue&quot;, ec =&amp;gt;
{
    ec.DiscardFaultedMessages();
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下错误的消息会被投递到了 _error 队列，可以配置直接抛弃错误信息&lt;/p&gt;
&lt;h3 id=&quot;dead-letter-pipe&quot;&gt;Dead-Letter Pipe&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cfg.ReceiveEndpoint(&quot;input-queue&quot;, ec =&amp;gt;
{
    ec.DiscardSkippedMessages();
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;死信队列：没有消费者的消息会被移到 _skipped 队列，但可以配置为不移到 _skipped 队列&lt;/p&gt;
&lt;h2 id=&quot;高级功能&quot;&gt;高级功能&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;持久化&lt;/li&gt;
&lt;li&gt;Saga 事件串&lt;/li&gt;
&lt;li&gt;调度&lt;/li&gt;
&lt;li&gt;Courier 最终一致性&lt;/li&gt;
&lt;li&gt;监控&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;p&gt;欢迎转载、使用、重新发布，但务必保留文章署名 郑子铭 （包含链接： &lt;a href=&quot;http://www.cnblogs.com/MingsonZheng/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/MingsonZheng/&lt;/a&gt; ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。&lt;/p&gt;
&lt;p&gt;如有任何疑问，请与我联系 (MingsonZheng@outlook.com) 。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Jan 2021 16:09:00 +0000</pubDate>
<dc:creator>MingsonZheng</dc:creator>
<og:description>2.6.8 RabbitMQ -- Masstransit 异常处理 异常处理 其他 高级功能 异常处理 异常与重试 重试配置 重试条件 重新投递信息 信箱 异常与重试 Exception publi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingsonZheng/p/14280129.html</dc:identifier>
</item>
<item>
<title>用户画像分析与场景应用 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/14280004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/14280004.html</guid>
<description>&lt;p&gt;用户画像，作为一种勾画目标用户、联系用户诉求与设计方向的有效工具，用户画像在各领域得到了广泛的应用。用户画像最初是在电商领域得到应用的，尤其在数字化营销范畴之内，核心的依赖依据就是描述用户画像的丰富标签。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;121.49751801441&quot;&gt;

&lt;h2 id=&quot;1、概念描述&quot;&gt;1、概念描述&lt;/h2&gt;
&lt;p&gt;用户画像，作为一种勾画目标用户、联系用户诉求与设计方向的有效工具，用户画像在各领域得到了广泛的应用。用户画像最初是在电商领域得到应用的，尤其在数字化营销范畴之内，核心的依赖依据就是描述用户画像的丰富标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210114230822176-1527948800.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在大数据时代背景下，用户信息充斥在网络中，将用户的每个具体信息抽象成标签，基于标签运用用户画像的方式了解用户，利用这些标签将用户形象具体化，从而为用户提供有针对性的服务。例如上述基于最简单的用户数据可以分析出来的用户画像信息。&lt;/p&gt;
&lt;h2 id=&quot;2、组成结构&quot;&gt;2、组成结构&lt;/h2&gt;
&lt;p&gt;用户画像的最核心工作是基于数据采集为用户贴上标签，随着标签的不断丰富用户的画像也会越来越清晰，最终达到了解甚至理解用户的能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210114230834172-212935833.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在实际的用户画像体系中，对于标签的分类分级远远不止这么简单，更加的细致和精确：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础属性：性别，年龄，消费能力，职业等；&lt;/li&gt;
&lt;li&gt;行为属性：活跃度，浏览，点击查看，不感兴趣；&lt;/li&gt;
&lt;li&gt;现实场景：经常进入的商圈，电影院，景区等；&lt;/li&gt;
&lt;li&gt;兴趣描述：购物，影视，音乐，游戏，读书等&lt;/li&gt;
&lt;li&gt;定制化：通过机器分析，基于某些标签组合判定；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过用户产生的多种场景数据，去分析或者推测用户的并信息标签化，可视化的描述出来，通过用户画像，产品能自动化的深入理解用户并服务用户，例如很多信息流的应用，会根据用户的阅读内容自动判断推送用户可能喜欢的内容。&lt;/p&gt;
&lt;h2 id=&quot;3、画像的价值&quot;&gt;3、画像的价值&lt;/h2&gt;
&lt;p&gt;在用户量大业务复杂的公司，都会花很高的成本构建用户画像体系，在各个业务线上采集数据做分析，不断深入的了解用户才能提供更加精准的服务和多样化的运营策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210114230845977-914936957.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户引流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过现有用户的画像分析，在相关DMP广告平台做投放，重点推荐其平台上具有相关类似标签的用户，为产品做用户引流，这里也是相似用户快速扩量的概念类似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新用户冷启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;快速分析新注册用户可能偏向的属性和兴趣偏好，实现服务快速精准推荐，例如用户注册地所在区域，可以通过该区域用户的通用标签推测该新用户的特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;精准或个性化服务&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里就是根据丰富的用户画像分析，理解用户并提供精准服务或个性化服务。提供好的服务自然能做到用户的深度沉淀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多场景识别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里场景相对偏复杂，通过一个案例描述，例如在某个平台用手机号A注册，之后该手机号A丢失，换用手机号B之后，通过相关行为去理解用户是否手机号A的用户，也可以根据同个手机序列识别不同用户或者多个手机序列识别相同用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;沉默用户唤醒&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于精细化的标签和多个场景数据，对用户的沉默程度做快速识别，基于画像分析制定运营策略进行激活召回减少用户流失。&lt;/p&gt;

&lt;p&gt;每次开发用户群分析的案例，脑海都能响起一段话：独生子女，傲娇，温室花朵，冷漠自私，精致利己，想法清奇，个性张扬，缺乏团队意识，非主流，垮掉。之前几年这是很多长辈或者社会对90这代人贴的标签，也有很多是90自我嘲讽的标签，作为90后的一员我对这份画像还是挺满意的...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202101/1691717-20210114230857884-1652137991.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述就是典型的人群画像分析的非典型案例，实际上最近几年对90人群分析报告已经非常多而且准确，很多数据公司都会从：社会属性、消费能力、游戏爱好、宠物、网络应用等多个热门领域做深度分析。分析人群画像可以在商业应用中产生非常高的价值。&lt;/p&gt;

&lt;h2 id=&quot;1、商圈分析&quot;&gt;1、商圈分析&lt;/h2&gt;
&lt;p&gt;首先基于商圈区域圈用户群，这里很好理解用户在某个商圈内产生数据，依次获取用户相关标签做该商圈内用户画像分析。&lt;/p&gt;
&lt;p&gt;其次分析商圈本身服务，例如美食领域人流、娱乐领域人流、购物领域人流等，对比不同商圈为商业圈的运营提供策略。&lt;/p&gt;
&lt;p&gt;通过综合商圈分析获取的画像，对商圈的构成、特点和影响商圈规模变化的各种因素进行综合性的研究，即服务于企业合理选择店址，也服务商圈精准引入丰富的品牌店铺。&lt;/p&gt;
&lt;h2 id=&quot;2、行业分析&quot;&gt;2、行业分析&lt;/h2&gt;
&lt;p&gt;行业分析画像是非常复杂的一种报告，通常会考量：用户体量、人群特征、技术、营收规模、竞争力、竞争格局、行业政策、市场饱和度等多个要素。不同的角度看行业分析也是不同的概念，例如从行业产品角度看：基于行业分析判断是否要做、如何做、如何做好、明确产品方向和运营策略等问题；从投行领域看则判断新产品是否值得投资有没有稳定高回报，风险控制等。&lt;/p&gt;
&lt;p&gt;通过多个场景下数据构建用户画像，在应用到产品的众多业务场景，进行商业化运营和管理，产生更高的价值。&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;GitHub·地址
https://github.com/cicadasmile
GitEE·地址
https://gitee.com/cicadasmile
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;数据洞察业务系列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推荐阅读：编程体系整理&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 14 Jan 2021 15:22:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>用户画像，作为一种勾画目标用户、联系用户诉求与设计方向的有效工具，用户画像在各领域得到了广泛的应用。用户画像最初是在电商领域得到应用的，尤其在数字化营销范畴之内，核心的依赖依据就是描述用户画像的丰富标</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/14280004.html</dc:identifier>
</item>
<item>
<title>使用SpringBoot搭建Web项目 - 林静生寒</title>
<link>http://www.cnblogs.com/ljsh/p/14279992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljsh/p/14279992.html</guid>
<description>&lt;h3 id=&quot;序言&quot;&gt;序言&lt;/h3&gt;
&lt;p&gt;从简入深的使用SpringBoot搭建一个Web项目，同时也包括一些小的问题。第一篇博文是以较为简单的方式完成一个可以连接数据库的Springboot web程序。之前自己学习的时候看网上的教程总是感觉有点太大，我只是想最简单的搭建一个可以运行的项目，之后再去深究细节。每个教程的配置还都不一样，让我不知所措，所以我就写了这篇博文来记录自我感觉的较简单的步骤较少的方法去搭建一个springboot web项目，不常写文可能思路有点混乱。&lt;/p&gt;
&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;
&lt;h4 id=&quot;创建项目&quot;&gt;创建项目&lt;/h4&gt;
&lt;p&gt;这里使用的IDE是IDEA，选择软件左上角File -&amp;gt; New -&amp;gt; Project来创建一个新的项目&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230423084-310390012.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择Spring Initializr来初始化我们的SpringBoot项目，选择JDK8之后点击Next，接下来的点击Next操作就不做说明了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230511599-786121850.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在如下界面我们设置包名，项目类型选择Maven项目，语言选择Java，打包方式选择Jar，Java版本选择8&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230552637-2054187120.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依赖这部分，我们分别选择Web下的Spring Web，Template Engines下的Thymeleaf(为以后挖坑)，SQL下的MyBatis Framework，当然这里也可以创建项目之后手动在POM文件中写入，不过这样更方便一些。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230632222-1988542184.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来选择项目的存放路径，即可完成项目的创建，创建完成项目打开项目之后IDEA右下角会弹出Maven projects need to be imported弹窗，选择Enable Auto-Import即可，这样Maven就可以自己下载依赖。&lt;/p&gt;
&lt;h4 id=&quot;目录结构&quot;&gt;目录结构&lt;/h4&gt;
&lt;p&gt;我们打开新建的项目之后大致如下图所示。.idea文件夹下存放的是IDEA项目的配置文件，比如compiler.xml 配置了JDK版本，encodings.xml 配置了编码类型，该文件夹我们不需要过多了解。.mvn文件夹下存放的是Maven的配置和相关Jar包。src文件夹是我们主要编码的地方，src.main.java路径下是我们编写java代码的地方，src.main.resources是我们存放静态资源，页面以及配置文件的地方。test文件夹是我们编写测试代码的地方。.gitignore文件配置了我们使用git时忽略上传的文件。HELP.md是一个帮助文档。mvnw是一个linux脚本文件，可以使我们运行指定版本的Maven，mvnw.cmd则是相同功能的windows版本脚本文件，pom.xml是Maven项目的依赖配置文件。t1.iml是 intellij idea的工程配置文件，里面是当前t1 project的一些配置信息。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230700983-1685333480.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们主要关注的还是src文件夹下的文件，其余不重要的文件可以隐藏，选中t1 项目，然后点击这个文件夹右下角带三个小蓝色方块的图标&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230740172-1356188572.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择要隐藏的文件右键选择Excluded 然后这些文件夹就会变成橙黄色&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230818019-1547510307.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Apply回到原来的页面点击图片中右上角的小齿轮，点击取消Show Excluded Files，这样想要隐藏的文件就消失了&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230843073-1205170852.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;测试启动&quot;&gt;测试启动&lt;/h4&gt;
&lt;p&gt;首先我们先来测试一下SpringBoot框架是否能够启动，创建TestController文件，目录结构如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230908413-2050896697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该类的代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController  // 标注该类为Controller，SpringBoot会自动扫描该类
public class TestController {
    @RequestMapping(&quot;/test&quot;)  // 处理请求路径为/test的请求
    public String test(){
        return &quot;测试成功&quot;;  
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注：自己敲代码的时候会自动导包，如果是复制上去的话可能不会自动导，需要手动处理。&lt;/p&gt;
&lt;p&gt;接下来点击下图左侧主启动类的小箭头或者右上角的箭头都可以启动项目&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114230937714-53086672.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后观察控制台的输出，很自然的没有运行成功，出错了，我们看一下错误提示&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;hr/&gt;&lt;p&gt;APPLICATION FAILED TO START&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;Description:&lt;/p&gt;
&lt;p&gt;Failed to configure a DataSource: 'url' attribute is not specified and no embedded datasource could be configured.&lt;/p&gt;
&lt;p&gt;Reason: Failed to determine a suitable driver class&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大体意思就是没有配置数据库驱动，我们也没用到数据库啊？为啥要配置数据库驱动呢？还记得我们之前选择依赖的时候选择了mybatis吗，原因就出在这里，找到pom.xml文件注释掉mybatis依赖，重启项目。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--        &amp;lt;dependency&amp;gt;--&amp;gt;
&amp;lt;!--            &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;--&amp;gt;
&amp;lt;!--            &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;--&amp;gt;
&amp;lt;!--            &amp;lt;version&amp;gt;2.1.3&amp;lt;/version&amp;gt;--&amp;gt;
&amp;lt;!--        &amp;lt;/dependency&amp;gt;--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;项目成功启动控制台输出如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114231004345-1505341105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到程序启动在8080端口，在浏览器中输入请求地址即可看到我们想要得到的测试成功字符串&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114231031276-6207512.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们百度可以了解到mybatis是一个Java持久层框架，JDBC才是连接数据库用到的驱动，那为什么我们引入mybatis需要配置数据库驱动呢？&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114231053654-893722009.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们从上面这张图片可以看到mybatis-spring-boot-starter依赖包含了jdbc依赖，所以引入了mybatis就相当于引入了jdbc，再加上SpringBoot的自动配置是根据是否引入类来进行自动配置的，自然的，引入了jdbc依赖就需要配置数据库驱动程序(选择数据库驱动自然是没法自动配置的)，从如下的报错也可以得出同样结论。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Exception encountered during context initialization - cancelling refresh attempt: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [org/springframework/boot/autoconfigure/jdbc/DataSourceConfiguration$Hikari.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.zaxxer.hikari.HikariDataSource]: Factory method 'dataSource' threw exception; nested exception is org.springframework.boot.autoconfigure.jdbc.DataSourceProperties$DataSourceBeanCreationException: Failed to determine a suitable driver class
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;连接数据库&quot;&gt;连接数据库&lt;/h4&gt;
&lt;p&gt;我们使用mysql数据库，首先创建一个数据库，我起的名字叫t1并创建了一张表Bear&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114231130237-1472445158.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;表内字段如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114231149164-1120844294.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后随便添加点数据，这样我们数据库就准备好了。&lt;/p&gt;
&lt;p&gt;再次回到代码这边，首先我们是要配置数据库的连接信息，在&lt;code&gt;application.properties&lt;/code&gt;里做如下配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;# 数据库设置
## 数据库驱动
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
# 数据库连接地址
spring.datasource.url=jdbc:mysql://localhost:3306/t1
# 数据库用户名
spring.datasource.username=root
# 数据库密码
spring.datasource.password=root
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次是导入JDBC驱动，在&lt;code&gt;pom.xml&lt;/code&gt;中添加如下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;!-- mysql jdbc 驱动 https://mvnrepository.com/artifact/mysql/mysql-connector-java --&amp;gt;
  &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;5.1.47&amp;lt;/version&amp;gt;
  &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我安装的是5.7版本的mysql所以这里我选择的是5版本的jdbc，如果是8版本的mysql可能就需要选择8版本的驱动了，驱动程序可以在&lt;a href=&quot;https://mvnrepository.com/&quot; target=&quot;_blank&quot;&gt;maven仓库&lt;/a&gt;找到，同时我们要解开之前对mybatis依赖的注释。&lt;/p&gt;
&lt;p&gt;接下来我们要创建一个实体Bear，用来承接Bear表查询出来的数据，在t1目录下创建controller的同级目录entity，再在entity内创建java文件Bear.java,内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ljsh.t1.entity;

public class Bear {

    private String name;
    private String type;
    private String weight;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getWeight() {
        return weight;
    }

    public void setWeight(String weight) {
        this.weight = weight;
    }

    public Bear(String name, String type, String weight) {
        this.name = name;
        this.type = type;
        this.weight = weight;
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一个典型的pojo，下面的getter和setter方法可以在idea编码页面右键选择 Generate -&amp;gt; Getter and Setter 自动生成。&lt;/p&gt;
&lt;p&gt;再之后是对mybaitis的配置与操作，创建controller目录同级目录mapper，在mapper目录中创建接口文件TestMapper.java,代码内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ljsh.t1.mapper;

import com.ljsh.t1.entity.Bear;
import java.util.List;

public interface TestMapper {
    List&amp;lt;Bear&amp;gt; getAllBears();  //查询Bear表所有数据，作为List查出来
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样的在resources目录下也创建一个mapper文件夹，mapper文件夹里创建TestMapper.xml文件，内容如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;com.ljsh.t1.mapper.TestMapper&quot;&amp;gt;

    &amp;lt;select id=&quot;getAllBears&quot;  resultType=&quot;com.ljsh.t1.entity.Bear&quot;&amp;gt;
        select
        *
        from Bear
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在T1Applicatin文件也就是主启动类中添加一个注解如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ljsh.t1;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(&quot;com.ljsh.t1.mapper&quot;) //扫描mapper接口类
public class T1Application {

    public static void main(String[] args) {
        SpringApplication.run(T1Application.class, args);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在&lt;code&gt;application.properties&lt;/code&gt;中增加一行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;# 指向映射xml文件目录
mybatis.mapperLocations=classpath:mapper/*.xml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在的目录结构如下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114231315001-584085434.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过在主启动类上配置@MapperScan注解，让springboot扫描需要实现的Mapper接口文件。通过配置文件里xml地址的配置，让Mapper接口和Mapper的xml实现可以对应起来。&lt;/p&gt;
&lt;p&gt;最后我们在TestController里修改代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.ljsh.t1.controller;

import com.ljsh.t1.entity.Bear;
import com.ljsh.t1.mapper.TestMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController  // 标注该类为Controller，SpringBoot会自动扫描该类
public class TestController {

    @Autowired
    TestMapper testMapper;  //自动注入

    @RequestMapping(&quot;/test&quot;)  // 处理请求路径为/test的请求
    public Object test(){
        List&amp;lt;Bear&amp;gt; bears = testMapper.getAllBears();
        return bears;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重新启动项目访问http://localhost:8080/test我们会收到从数据库查询出来的数据&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1425720/202101/1425720-20210114231402363-638228015.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候查看控制台可能会发现一些警告&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Thu Jan 14 22:45:15 CST 2021 WARN: Establishing SSL connection without server's identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn't set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to 'false'. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改&lt;code&gt;application.properties&lt;/code&gt;中的数据库连接为如下即可消除警告&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;spring.datasource.url=jdbc:mysql://localhost:3306/t1?useSSL=false
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;p&gt;本来的出发点是以最简单的方式搭建一个能跑起来的web项目，但是写完了感觉还是有点复杂，但有基础的话还是很好理解的。之后应该还会根据这个demo更新 mvc / 配置 /mybatis 具体的一些细节，也是自己的一次复习，如果有时间的话。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Jan 2021 15:17:00 +0000</pubDate>
<dc:creator>林静生寒</dc:creator>
<og:description>序言 从简入深的使用SpringBoot搭建一个Web项目，同时也包括一些小的问题。第一篇博文是以较为简单的方式完成一个可以连接数据库的Springboot web程序。之前自己学习的时候看网上的教程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ljsh/p/14279992.html</dc:identifier>
</item>
<item>
<title>Spring Security OAuth2.0认证授权五：用户信息扩展到jwt - 狂盗一枝梅</title>
<link>http://www.cnblogs.com/kuangdaoyizhimei/p/14279979.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kuangdaoyizhimei/p/14279979.html</guid>
<description>&lt;p&gt;历史文章&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.kdyzm.cn/post/24&quot; target=&quot;_blank&quot;&gt;Spring Security OAuth2.0认证授权一：框架搭建和认证测试&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.kdyzm.cn/post/25&quot; target=&quot;_blank&quot;&gt;Spring Security OAuth2.0认证授权二：搭建资源服务&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.kdyzm.cn/post/26&quot; target=&quot;_blank&quot;&gt;Spring Security OAuth2.0认证授权三：使用JWT令牌&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.kdyzm.cn/post/30&quot; target=&quot;_blank&quot;&gt;Spring Security OAuth2.0认证授权四：分布式系统认证授权&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇文章讲解了如何在分布式系统环境下进行认证和鉴权，总体来说就是网关认证，目标服务鉴权，但是存在着一个问题：关于用户信息，目标服务只能获取到网关转发过来的username信息，为啥呢，因为认证服务颁发jwt令牌的时候就只存放了这么多信息，我们到&lt;a href=&quot;https://www.cnblogs.com/kuangdaoyizhimei/p/jwt.io&quot; target=&quot;_blank&quot;&gt;jwt.io&lt;/a&gt;网站上贴出jwt令牌查看下payload中内容就就知道有什么内容了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/516671/202101/516671-20210114231225756-649470493.png;%20charset=UTF-8&quot; alt=&quot;jwt base64 decode结果&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本篇文章的目的&lt;/strong&gt;就是为了解决该问题，把用户信息（用户名、头像、手机号、邮箱等）放到jwt token中，经过网关解析之后携带用户信息访问目标服务，目标服务将用户信息保存到上下文并保证线程安全性的情况下封装成工具类提供给各种环境下使用。&lt;/p&gt;
&lt;p&gt;注：本文章基于源代码&lt;a href=&quot;https://gitee.com/kdyzm/spring-security-oauth-study/tree/v5.0.0&quot; target=&quot;_blank&quot;&gt;https://gitee.com/kdyzm/spring-security-oauth-study/tree/v5.0.0&lt;/a&gt; 分析和改造。&lt;/p&gt;
&lt;h2 id=&quot;一、实现userdetailsservice接口&quot;&gt;一、实现UserDetailsService接口&lt;/h2&gt;
&lt;h3 id=&quot;1问题分析和修改&quot;&gt;1.问题分析和修改&lt;/h3&gt;
&lt;p&gt;jwt令牌中用户信息过于少的原因在于认证服务auth-server中&lt;a href=&quot;https://gitee.com/kdyzm/spring-security-oauth-study/blob/v5.0.0/auth-server/src/main/java/com/kdyzm/spring/security/auth/center/service/MyUserDetailsServiceImpl.java#L44&quot; target=&quot;_blank&quot;&gt;com.kdyzm.spring.security.auth.center.service.MyUserDetailsServiceImpl#loadUserByUsername&lt;/a&gt; 方法中的这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;return User
                .withUsername(tUser.getUsername())
                .password(tUser.getPassword())
                .authorities(array).build();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里User类实现了&lt;code&gt;UserDetailsService&lt;/code&gt;接口，并使用建造者模式生成了需要的&lt;code&gt;UserDetailsService&lt;/code&gt;对象，可以看到生成该对象仅仅传了三个参数，而用户信息仅仅有用户名和password两个参数———那么如何扩展用户信息就一目了然了，我们自己也实现&lt;code&gt;UserDetailsService&lt;/code&gt;接口然后返回改值不就好了吗？不好！！实现&lt;code&gt;UserDetailsService&lt;/code&gt;接口要实现它需要的好几个方法，不如直接继承User类，在改动最小的情况下保持原有的功能基本不变，这里定义&lt;code&gt;UserDetailsExpand&lt;/code&gt;继承&lt;code&gt;User&lt;/code&gt;类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class UserDetailsExpand extends User {
    public UserDetailsExpand(String username, String password, Collection&amp;lt;? extends GrantedAuthority&amp;gt; authorities) {
        super(username, password, authorities);
    }
    //userId
    private Integer id;
    //电子邮箱
    private String email;
    //手机号
    private String mobile;
    private String fullname;
    //Getter/Setter方法略
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后，修改&lt;a href=&quot;https://gitee.com/kdyzm/spring-security-oauth-study/blob/v5.0.0/auth-server/src/main/java/com/kdyzm/spring/security/auth/center/service/MyUserDetailsServiceImpl.java#L29&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;com.kdyzm.spring.security.auth.center.service.MyUserDetailsServiceImpl#loadUserByUsername&lt;/code&gt;&lt;/a&gt;方法返回该类的对象即可&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;        UserDetailsExpand userDetailsExpand = new UserDetailsExpand(tUser.getUsername(), tUser.getPassword(), AuthorityUtils.createAuthorityList(array));
        userDetailsExpand.setId(tUser.getId());
        userDetailsExpand.setMobile(tUser.getMobile());
        userDetailsExpand.setFullname(tUser.getFullname());
        return userDetailsExpand;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2测试修改和源码分析&quot;&gt;2.测试修改和源码分析&lt;/h3&gt;
&lt;p&gt;修改了以上代码之后我们启动服务，获取jwt token之后查看其中的内容，会发现用户信息并没有填充进去，测试失败。。。。再分析下，为什么会没有填充进去？关键在于&lt;code&gt;JwtAccessTokenConverter&lt;/code&gt;这个类，该类未发起作用的时候，返回请求放的token只是一个uuid类型（好像是uuid）的简单字符串，经过该类的转换之后就将一个简单的uuid转换成了jwt字符串，该类中的&lt;code&gt;org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter#convertAccessToken&lt;/code&gt;方法在起作用，顺着该方法找下去：&lt;code&gt;org.springframework.security.oauth2.provider.token.DefaultAccessTokenConverter#convertAccessToken&lt;/code&gt;，然后就发现了这行代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;response.putAll(token.getAdditionalInformation());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个token就是&lt;code&gt;OAuth2AccessToken&lt;/code&gt;对象，也就是真正返回给请求者的对象，查看该类中该字段的解释&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
         * The additionalInformation map is used by the token serializers to export any fields used by extensions of OAuth.
         * @return a map from the field name in the serialized token to the value to be exported. The default serializers 
         * make use of Jackson's automatic JSON mapping for Java objects (for the Token Endpoint flows) or implicitly call 
         * .toString() on the &quot;value&quot; object (for the implicit flow) as part of the serialization process.
         */
        Map&amp;lt;String, Object&amp;gt; getAdditionalInformation();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，该字段是专门用来扩展OAuth字段的属性，万万没想到JWT同时用它扩展jwt串。。。接下来就该想想怎么给&lt;code&gt;OAuth2AccessToken&lt;/code&gt;对象填充这个扩展字段了。&lt;/p&gt;
&lt;p&gt;如果仔细看&lt;code&gt;JwtAccessTokenConverter&lt;/code&gt;这个类的源码，可以看到有个方法&lt;code&gt;org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter#enhance&lt;/code&gt;，该方法有个参数&lt;code&gt;OAuth2AccessToken accessToken&lt;/code&gt;，同时它的返回值也是&lt;code&gt;OAuth2AccessToken&lt;/code&gt;，也就是说这个方法，传入了&lt;code&gt;OAuth2AccessToken&lt;/code&gt;对象，完事儿了之后还传出了&lt;code&gt;OAuth2AccessToken&lt;/code&gt;对象，再根据&lt;code&gt;enhance&lt;/code&gt;这个名字，可以推测出，它是一个增强方法，修改了或者代理了&lt;code&gt;OAuth2AccessToken&lt;/code&gt;对象，查看父接口，是&lt;code&gt;TokenEnhancer&lt;/code&gt;接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface TokenEnhancer {
        /**
         * Provides an opportunity for customization of an access token (e.g. through its additional information map) during
         * the process of creating a new token for use by a client.
         * 
         * @param accessToken the current access token with its expiration and refresh token
         * @param authentication the current authentication including client and user details
         * @return a new token enhanced with additional information
         */
        OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据该注释可以看出该方法用于定制access_token，那么通过这个方法填充access token的AdditionalInformation属性貌似正合适（别忘了目的是干啥的）。&lt;/p&gt;
&lt;p&gt;看下&lt;code&gt;JwtAccessTokenConverter&lt;/code&gt;是如何集成到认证服务的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @Bean
    public AuthorizationServerTokenServices tokenServices(){
        DefaultTokenServices services = new DefaultTokenServices();
        services.setClientDetailsService(clientDetailsService);
        services.setSupportRefreshToken(true);
        services.setTokenStore(tokenStore);
        services.setAccessTokenValiditySeconds(7200);
        services.setRefreshTokenValiditySeconds(259200);

        TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();
        tokenEnhancerChain.setTokenEnhancers(Collections.singletonList(jwtAccessTokenConverter));
        services.setTokenEnhancer(tokenEnhancerChain);
        return services;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这里的&lt;code&gt;tokenEnhancerChain&lt;/code&gt;可以传递一个列表，这里只传了一个&lt;code&gt;jwtAccessTokenConverter&lt;/code&gt;对象，那么解决方案就有了，实现TokenEnhancer接口并将对象填到该列表中就可以了&lt;/p&gt;
&lt;h3 id=&quot;3实现tokenenhancer接口&quot;&gt;3.实现TokenEnhancer接口&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
@Component
public class CustomTokenEnhancer implements TokenEnhancer {

    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public OAuth2AccessToken enhance(OAuth2AccessToken accessToken, OAuth2Authentication authentication) {
        Map&amp;lt;String,Object&amp;gt; additionalInfo = new HashMap&amp;lt;&amp;gt;();
        Object principal = authentication.getPrincipal();
        try {
            String s = objectMapper.writeValueAsString(principal);
            Map map = objectMapper.readValue(s, Map.class);
            map.remove(&quot;password&quot;);
            map.remove(&quot;authorities&quot;);
            map.remove(&quot;accountNonExpired&quot;);
            map.remove(&quot;accountNonLocked&quot;);
            map.remove(&quot;credentialsNonExpired&quot;);
            map.remove(&quot;enabled&quot;);
            additionalInfo.put(&quot;user_info&quot;,map);
            ((DefaultOAuth2AccessToken)accessToken).setAdditionalInformation(additionalInfo);
        } catch (IOException e) {
            log.error(&quot;&quot;,e);
        }
        return accessToken;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码干了以下几件事儿：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从OAuth2Authentication对象取出principal对象&lt;/li&gt;
&lt;li&gt;转换principal对象为map并删除map对象中的若干个不想要的字段属性&lt;/li&gt;
&lt;li&gt;将map对象填充进入OAuth2AccessToken对象的additionalInfo属性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实现TokenEnhancer接口后将该对象加入到TokenEnhancerChain中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TokenEnhancerChain tokenEnhancerChain = new TokenEnhancerChain();
tokenEnhancerChain.setTokenEnhancers(Arrays.asList(customTokenEnhancer,jwtAccessTokenConverter));
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4接口测试&quot;&gt;4.接口测试&lt;/h3&gt;
&lt;p&gt;POST请求&lt;a href=&quot;http://127.0.0.1:30000/oauth/token?client_id=c1&amp;amp;client_secret=secret&amp;amp;grant_type=password&amp;amp;username=zhangsan&amp;amp;password=123&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:30000/oauth/token?client_id=c1&amp;amp;client_secret=secret&amp;amp;grant_type=password&amp;amp;username=zhangsan&amp;amp;password=123&lt;/a&gt;得到结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;access_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX2luZm8iOnsidXNlcm5hbWUiOiJ6aGFuZ3NhbiIsImlkIjoxLCJlbWFpbCI6IjEyMzQ1NkBmb3htYWlsLmNvbSIsIm1vYmlsZSI6IjEyMzQ1Njc4OTEyIiwiZnVsbG5hbWUiOiLlvKDkuIkifSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FETUlOIiwiUk9MRV9VU0VSIiwiUk9MRV9BUEkiXSwiZXhwIjoxNjEwNjM4NjQzLCJhdXRob3JpdGllcyI6WyJwMSIsInAyIl0sImp0aSI6IjFkOGY3OGFmLTg1N2EtNGUzMS05ODYxLTZkYWJjNjU4NzcyNiIsImNsaWVudF9pZCI6ImMxIn0.Y9f5psNCgZi_I2KY3PLBLjuK5-U1VhXIB1vjKjMb9fc&quot;,
    &quot;token_type&quot;: &quot;bearer&quot;,
    &quot;refresh_token&quot;: &quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX2luZm8iOnsidXNlcm5hbWUiOiJ6aGFuZ3NhbiIsImlkIjoxLCJlbWFpbCI6IjEyMzQ1NkBmb3htYWlsLmNvbSIsIm1vYmlsZSI6IjEyMzQ1Njc4OTEyIiwiZnVsbG5hbWUiOiLlvKDkuIkifSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FETUlOIiwiUk9MRV9VU0VSIiwiUk9MRV9BUEkiXSwiYXRpIjoiMWQ4Zjc4YWYtODU3YS00ZTMxLTk4NjEtNmRhYmM2NTg3NzI2IiwiZXhwIjoxNjEwODkwNjQzLCJhdXRob3JpdGllcyI6WyJwMSIsInAyIl0sImp0aSI6IjM1OGFkMzA1LTU5NzUtNGM3MS05ODI4LWQ2N2ZjN2MwNDMyMCIsImNsaWVudF9pZCI6ImMxIn0._bhajMIdqnUL1zgc8d-5xlXSzhsCWbZ2jBWlNb8m_hw&quot;,
    &quot;expires_in&quot;: 7199,
    &quot;scope&quot;: &quot;ROLE_ADMIN ROLE_USER ROLE_API&quot;,
    &quot;user_info&quot;: {
        &quot;username&quot;: &quot;zhangsan&quot;,
        &quot;id&quot;: 1,
        &quot;email&quot;: &quot;123456@foxmail.com&quot;,
        &quot;mobile&quot;: &quot;12345678912&quot;,
        &quot;fullname&quot;: &quot;张三&quot;
    },
    &quot;jti&quot;: &quot;1d8f78af-857a-4e31-9861-6dabc6587726&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到结果中多了user_info字段，而且access_token长了很多，我们的目的是为了在jwt也就是access_token中放入用户信息，先不管为何user_info会以明文出现在这里，我们先看下access_token中多了哪些内容&lt;/p&gt;
&lt;p&gt;POST请求h&lt;a href=&quot;http://127.0.0.1:30000/oauth/check_token?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX2luZm8iOnsidXNlcm5hbWUiOiJ6aGFuZ3NhbiIsImlkIjoxLCJlbWFpbCI6IjEyMzQ1NkBmb3htYWlsLmNvbSIsIm1vYmlsZSI6IjEyMzQ1Njc4OTEyIiwiZnVsbG5hbWUiOiLlvKDkuIkifSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FETUlOIiwiUk9MRV9VU0VSIiwiUk9MRV9BUEkiXSwiZXhwIjoxNjEwNjM4NjQzLCJhdXRob3JpdGllcyI6WyJwMSIsInAyIl0sImp0aSI6IjFkOGY3OGFmLTg1N2EtNGUzMS05ODYxLTZkYWJjNjU4NzcyNiIsImNsaWVudF9pZCI6ImMxIn0.Y9f5psNCgZi_I2KY3PLBLjuK5-U1VhXIB1vjKjMb9fc&quot; target=&quot;_blank&quot;&gt;http://127.0.0.1:30000/oauth/check_token?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOlsicmVzMSJdLCJ1c2VyX2luZm8iOnsidXNlcm5hbWUiOiJ6aGFuZ3NhbiIsImlkIjoxLCJlbWFpbCI6IjEyMzQ1NkBmb3htYWlsLmNvbSIsIm1vYmlsZSI6IjEyMzQ1Njc4OTEyIiwiZnVsbG5hbWUiOiLlvKDkuIkifSwidXNlcl9uYW1lIjoiemhhbmdzYW4iLCJzY29wZSI6WyJST0xFX0FETUlOIiwiUk9MRV9VU0VSIiwiUk9MRV9BUEkiXSwiZXhwIjoxNjEwNjM4NjQzLCJhdXRob3JpdGllcyI6WyJwMSIsInAyIl0sImp0aSI6IjFkOGY3OGFmLTg1N2EtNGUzMS05ODYxLTZkYWJjNjU4NzcyNiIsImNsaWVudF9pZCI6ImMxIn0.Y9f5psNCgZi_I2KY3PLBLjuK5-U1VhXIB1vjKjMb9fc&lt;/a&gt;，得到相应结果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;aud&quot;: [
        &quot;res1&quot;
    ],
    &quot;user_info&quot;: {
        &quot;username&quot;: &quot;zhangsan&quot;,
        &quot;id&quot;: 1,
        &quot;email&quot;: &quot;123456@foxmail.com&quot;,
        &quot;mobile&quot;: &quot;12345678912&quot;,
        &quot;fullname&quot;: &quot;张三&quot;
    },
    &quot;user_name&quot;: &quot;zhangsan&quot;,
    &quot;scope&quot;: [
        &quot;ROLE_ADMIN&quot;,
        &quot;ROLE_USER&quot;,
        &quot;ROLE_API&quot;
    ],
    &quot;exp&quot;: 1610638643,
    &quot;authorities&quot;: [
        &quot;p1&quot;,
        &quot;p2&quot;
    ],
    &quot;jti&quot;: &quot;1d8f78af-857a-4e31-9861-6dabc6587726&quot;,
    &quot;client_id&quot;: &quot;c1&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到user_info也已经填充到了jwt串中，那么为什么这个串还会以明文的形式出现在相应结果的其它字段中呢？还记得本文章中说过的一句话&lt;code&gt;&quot;可以看到，该字段是专门用来扩展OAuth字段的属性，万万没想到JWT同时用它扩展jwt串&quot;&lt;/code&gt;，我们给&lt;code&gt;OAuth2AccessToken&lt;/code&gt;对象填充了&lt;code&gt;AdditionalInformation&lt;/code&gt;字段，而这本来是为了扩展OAuth用的，所以返回结果中自然会出现这个字段。&lt;/p&gt;
&lt;p&gt;到此为止，接口测试已经成功了，接下来修改网关和目标服务（这里是资源服务），将用户信息提取出来并保存到上下文中&lt;/p&gt;
&lt;h2 id=&quot;二、修改网关&quot;&gt;二、修改网关&lt;/h2&gt;
&lt;p&gt;网关其实不需要做啥大的修改，但是会出现中文乱码问题，这里使用Base64编码之后再将用户数据放到请求头带给目标服务。修改TokenFilter类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//builder.header(&quot;token-info&quot;, payLoad).build();
builder.header(&quot;token-info&quot;, Base64.encode(payLoad.getBytes(StandardCharsets.UTF_8))).build();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、修改资源服务&quot;&gt;三、修改资源服务&lt;/h2&gt;
&lt;h3 id=&quot;1修改authfiltercustom&quot;&gt;1.修改AuthFilterCustom&lt;/h3&gt;
&lt;p&gt;上一篇文章中床架了该类并将userName填充到了UsernamePasswordAuthenticationToken对象的Principal，这里我们需要将扩展的UserInfo整个填充到Principal，完整代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AuthFilterCustom extends OncePerRequestFilter {

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        ObjectMapper objectMapper = new ObjectMapper();
        String base64Token = request.getHeader(&quot;token-info&quot;);
        if(StringUtils.isEmpty(base64Token)){
            log.info(&quot;未找到token信息&quot;);
            filterChain.doFilter(request,response);
            return;
        }
        byte[] decode = Base64.decode(base64Token);
        String tokenInfo = new String(decode, StandardCharsets.UTF_8);
        JwtTokenInfo jwtTokenInfo = objectMapper.readValue(tokenInfo, JwtTokenInfo.class);
        List&amp;lt;String&amp;gt; authorities1 = jwtTokenInfo.getAuthorities();
        String[] authorities=new String[authorities1.size()];
        authorities1.toArray(authorities);
        //将用户信息和权限填充 到用户身份token对象中
        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(
                        jwtTokenInfo.getUser_info(),
                null,
                AuthorityUtils.createAuthorityList(authorities)
        );
        authenticationToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
        //将authenticationToken填充到安全上下文
        SecurityContextHolder.getContext().setAuthentication(authenticationToken);
        filterChain.doFilter(request,response);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里JwtTokenInfo新增了user_info字段，而其类型正是前面说的&lt;code&gt;UserDetailsExpand&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;通过上述修改，我们可以在Controller中使用如下代码获取到上下文中的信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
UserDetailsExpand principal = (UserDetailsExpand)authentication.getPrincipal();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过测试，结果良好，但是还存在问题，那就是在异步情况下，比如使用线程池或者新开线程的情况下，极有可能出现线程池内缓存或者取不到数据的情况（未测试，瞎猜的），具体可以参考我以前的文章&lt;a href=&quot;https://blog.kdyzm.cn/post/14&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;使用 transmittable-thread-local 组件解决 ThreadLocal 父子线程数据传递问题&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2解决线程安全性问题&quot;&gt;2.解决线程安全性问题&lt;/h3&gt;
&lt;p&gt;这一步是选做，但是还是建议做，如果不考虑线程安全性问题，上一步就可以了。&lt;/p&gt;
&lt;p&gt;首先新增AuthContextHolder类维护我们需要的ThreadLocal，这里一定要使用TransmittableThreadLocal。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AuthContextHolder {
    private TransmittableThreadLocal threadLocal = new TransmittableThreadLocal();
    private static final AuthContextHolder instance = new AuthContextHolder();

    private AuthContextHolder() {
    }

    public static AuthContextHolder getInstance() {
        return instance;
    }

    public void setContext(UserDetailsExpand t) {
        this.threadLocal.set(t);
    }

    public UserDetailsExpand getContext() {
        return (UserDetailsExpand)this.threadLocal.get();
    }

    public void clear() {
        this.threadLocal.remove();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后新建拦截器AuthContextIntercepter&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class AuthContextIntercepter implements HandlerInterceptor {

    @Autowired
    private ObjectMapper objectMapper;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if(Objects.isNull(authentication) || Objects.isNull(authentication.getPrincipal())){
            //无上下文信息，直接放行
            return true;
        }
        UserDetailsExpand principal = (UserDetailsExpand) authentication.getPrincipal();
        AuthContextHolder.getInstance().setContext(principal);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        AuthContextHolder.getInstance().clear();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该拦截器在AuthFilter之后执行的，所以一定能获取到SecurityContextHolder中的内容，之后，我们就可以在Controller中使用如下代码获取用户信息了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;UserDetailsExpand context = AuthContextHolder.getInstance().getContext();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是简单了很多~&lt;/p&gt;
&lt;h3 id=&quot;3其他问题&quot;&gt;3.其他问题&lt;/h3&gt;
&lt;p&gt;如果走到了上一步，则一定要使用阿里巴巴配套的TransmittableThreadLocal解决方案，否则TransmittableThreadLocal和普通的ThreadLocal没什么区别。具体参考&lt;a href=&quot;https://blog.kdyzm.cn/post/14&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;使用 transmittable-thread-local 组件解决 ThreadLocal 父子线程数据传递问题&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;四、源代码&quot;&gt;四、源代码&lt;/h2&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://gitee.com/kdyzm/spring-security-oauth-study/tree/v6.0.0&quot; target=&quot;_blank&quot;&gt;https://gitee.com/kdyzm/spring-security-oauth-study/tree/v6.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我的博客原文章地址：&lt;a href=&quot;https://blog.kdyzm.cn/post/31&quot; target=&quot;_blank&quot;&gt;https://blog.kdyzm.cn/post/31&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 14 Jan 2021 15:16:00 +0000</pubDate>
<dc:creator>狂盗一枝梅</dc:creator>
<og:description>历史文章 Spring Security OAuth2.0认证授权一：框架搭建和认证测试 Spring Security OAuth2.0认证授权二：搭建资源服务 Spring Security OA</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kuangdaoyizhimei/p/14279979.html</dc:identifier>
</item>
<item>
<title>图片质量评估论文 | 无监督SER-FIQ | CVPR2020 - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/14279972.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/14279972.html</guid>
<description>&lt;p&gt;文章转自：同作者微信公主号【机器学习炼丹术】。欢迎交流，共同进步。&lt;/p&gt;
&lt;h2 id=&quot;0-综述&quot;&gt;0 综述&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/16ecd2a9f8592cf028817fb8cbde2a1d.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这可能是我看CVPR论文中，唯一一个5分钟就看完原理的论文了，&lt;strong&gt;简单有趣&lt;/strong&gt;。这一篇文章是CVPR2020的与图像质量评估相关的文章，整体思想比较新颖，而且是&lt;strong&gt;无监督&lt;/strong&gt;的方式，感觉构思不错，我要好好读读这一篇。&lt;/p&gt;
&lt;h2 id=&quot;1-细节&quot;&gt;1 细节&lt;/h2&gt;
&lt;p&gt;人脸质量评估的目的是评估一个人脸图片与面部识别算法的适用性，什么是高质量的人脸图片？不是看的清晰的，而是可以正确被面部识别算法识别的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于这种思想，计算人脸识别算法的随机子网络的输出的方差，得到图片的鲁棒性，从而反应图片的质量&lt;/strong&gt;，如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/ebf8b44ad8a702cb85215a4731e7c1a9.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的随机子网络，其实就是&lt;strong&gt;dropout实现的全连接层&lt;/strong&gt;，所以要求人脸识别模型中必须包含dropout层。&lt;/p&gt;
&lt;p&gt;作者对于每个图片，随机构建了m个随机子网络，然后对m个输出计算方差。我们用数学来表示这m个随机子网络的输出：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(X(I)=\{x_s\}, s \in {1,2,...,m}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中I表示原始图像，m为随机子网络的数量，&lt;span class=&quot;math inline&quot;&gt;\(s_m\)&lt;/span&gt;表示第m个随机子网络，输入I的时候的输出。&lt;/p&gt;
&lt;p&gt;那么我们用下面的公式来计算图像I的quality score：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/551b8e44d60011fb24c25a3732aef1fb.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样质量分数是在0和1之间的一个数字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/5a539fd4ef7c77b0c3496a72ce136b79.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这个流程图也很简单，跟我们刚才说的一样。&lt;/p&gt;
&lt;h2 id=&quot;2-总结&quot;&gt;2 总结&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/cd498e277a0c67ec25f8f52ed23ddeeb.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;上图是一个实验结果图，不同模型的之间的对比。论文后面用大量篇幅在各种人面识别模型和数据集上做实验和对比，这里就不多描述了。回头有机会，这个方法可以试一试，简单又有意思。&lt;/p&gt;
</description>
<pubDate>Thu, 14 Jan 2021 15:11:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>文章转自：同作者微信公主号【机器学习炼丹术】。欢迎交流，共同进步。 论文名称：SER-FIQ: Unsupervised Estimation of Face Image Quality Based</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/14279972.html</dc:identifier>
</item>
</channel>
</rss>