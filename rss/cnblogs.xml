<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2019.1.22 文献阅读日记，内容理解篇 ：用于无监督医疗检测的自动心电图噪声监测和分类系统《Automated ECG Noise Detection and Classification System for Unsupervised Healthcare Monitoring》 - 徐冰块的程序员成长日记</title>
<link>http://www.cnblogs.com/xubingkuai/p/10299584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xubingkuai/p/10299584.html</guid>
<description>

&lt;p&gt;以下是对文章内容的理解，在这里做个笔记，便于回顾，没有什么技术含量，就是一个学习日记笔记，嘻嘻。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;&lt;span&gt;文章内容的思路：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一、框架包括：&lt;/p&gt;
&lt;p&gt;1.改进的集合经验模式分解 modified &lt;em&gt;ensemble empirical mode decomposition (CEEMD)，CEEMD全称为 &lt;/em&gt;complete ensemble empirical mode decomposition，完全集合经验模式分解。&lt;/p&gt;
&lt;p&gt;2.短期时间特征提取&lt;/p&gt;
&lt;p&gt;3.基于决策规则的噪声噪声监测和分类&lt;/p&gt;

&lt;p&gt;二、框架的处理步骤：&lt;/p&gt;
&lt;p&gt;1.首先使用修改的CEEMD算法分解ECG信号，区分ECG分量与噪声和伪像。&lt;/p&gt;
&lt;p&gt;2.根据提取的高频HF和低频LF信号计算诸如最大绝对幅度，零交叉数，和自相关函数的局部最大峰值幅度的短期时间特征。&lt;/p&gt;
&lt;p&gt;3.提出了一种基于决策规则的算法，用于检测噪声的存在，并将处理后的ECG信号分为六个信号组：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）无噪声心电图 noise-free ECG,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  (2)基线漂移心电图 ECG+BW,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）肌肉伪迹心电图 ECG+MA,&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）电力线干扰心电图 ECG+PLI&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（5）基线漂移电力线干扰心电图 ECG+BW+PLI&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（6）基线漂移 肌肉伪迹心电图ECG+BW+MA&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;该框架简化了单个和组合ECG噪声的检测和分类流程，如下图（文献原图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121152640369-1717549826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;       上图说明了该框架的主要组成部分，用于检测和分类的单一和组合心电图的声音。本节提出了一种改进的具有新的停止准则的完全集成经验模态分解(complete ensemble empirical mode decomposition, CEEMD)算法，并讨论了与传统的CEEMD算法相比，所提出的停止准则在显著降低计算负荷方面的优势。&lt;/p&gt;
&lt;p&gt;       然后，描述了该框架的主要组成部分，包括(一)心电信号和噪声分离;(二)短期时间特征提取;和(三)基于噪声检测与分类的决策规则。&lt;/p&gt;



&lt;p&gt;       当然为了方便理解，我还搜索了网上的资料，然后看到了大神的智慧的结晶，如下图（为表尊重，附上大神的博客链接，方便以后看      https://blog.csdn.net/Couragebelief/article/details/75339460）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121152608028-312545063.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 三、相关工作和动机：&lt;/p&gt;
&lt;p&gt;       本文已采用各种策略来处理由于噪声和伪影引起的高误报率问题：&lt;/p&gt;
&lt;p&gt;     （1）基于ECG去噪的方法来抑制ECG记录中的噪声和伪影&lt;/p&gt;
&lt;p&gt;     （2）基于信号质量指数SQI的方法来评估记录的ECG信号的临床可接受性&lt;/p&gt;
&lt;p&gt; 具体内容如下：&lt;/p&gt;
&lt;p&gt;（1） 基于心电图去噪的策略：&lt;/p&gt;
&lt;p&gt;      为了降低误报率，基于移动平均值和中值滤波器，频率选择滤波器，自适应滤波器，维纳滤波器，多项式滤波器，奇异值分解，提出了各种心电图去噪方法SVD，离散余弦变换DCT，离散小波变化DWT，切换卡尔曼滤波器，经验模式分解EMD，非线性贝叶斯滤波器NBF，数学形态学算子MM，主成分分析PCA，独立成分分析VMD，和EMD小波方法，用于出去单个组合的县点图噪声源。&lt;/p&gt;
&lt;p&gt;      评估结果表明，由于ECG信号的低频分量衰减，基线漂移消除方法可能会使ST段失真。结果进一步表明，简单的滤波器不足以消除严重的EMD噪声，而不会扭曲ECG信号的幅度、持续时间、间隔和形状特征。基于EMD的去噪方法在QRS波群的开始和结束时，引入显著的失真，这可能导致QRS波群扩大。&lt;/p&gt;
&lt;p&gt;（2）基于信号质量评估的策略：&lt;/p&gt;
&lt;p&gt;      除降噪策略外，还采用信号质量评估SQA策略来解决误报问题。文献中简要介绍了用于评估ECG信号质量的特征提取方法如下（这里只是列举，文章没有扩展，我的日记当然我会在后面添加，尽量的做到我自己满意吧，菜鸟上到，前方高能，啊哈哈。）：&lt;/p&gt;
&lt;p&gt;1】基于频谱信号表示和相关性提出了基于调制频谱的ECG质量指数&lt;/p&gt;
&lt;p&gt;2】基于心率，RR期间特征和末班匹配的信号质量指标&lt;/p&gt;
&lt;p&gt;3】基于连导，决策树和SVM分类之间的互相关的ECG质量估计方法&lt;/p&gt;
&lt;p&gt;4】使用七个SQI研究了ECG质量评估方法，这七部分是：&lt;/p&gt;
&lt;p&gt;     1]峰度 kSQI&lt;/p&gt;
&lt;p&gt;     2]偏度 sSQI&lt;/p&gt;
&lt;p&gt;     3]QRS波群中的相对功率 pSQI&lt;/p&gt;
&lt;p&gt;     4]基线中的相对功率 basSQI&lt;/p&gt;
&lt;p&gt;     5]wqrs检测到的节拍与eplimited (bSQI)检测到的节拍匹配的比例&lt;/p&gt;
&lt;p&gt;     6]eplimited与wqrs (rSQI)检测到的拍数之比&lt;/p&gt;
&lt;p&gt;     7]由与五个主成分相关的特征值之和与经时向心电图周期(pcaSQI)主成分分析得到的所有特征值之和和SVM分类器构成的比率&lt;/p&gt;
&lt;p&gt;5】基于检测到的PQRST复合波的集合平均和来自ECG信号的每个PQRST复合波的平均PQRST复数减去的ECG信号质量分析&lt;/p&gt;
&lt;p&gt;6】七种信号质量指数（iSQI,bSQI，fSQI,sSQI,kSQI,pSQI,basSQI）和多层感知器（MLP）和SVM分类器，用于确定ECG信号的临床可接受性&lt;/p&gt;
&lt;p&gt;7】不依赖于特定形态特征的多通道自适应滤波的点到点信号质量指数(SQI)心电图beat-by-beat分析&lt;/p&gt;
&lt;p&gt;8】一种改进的基于相关性和多样性的心电信号质量测量方法&lt;/p&gt;
&lt;p&gt;9】一种基于阈值的噪声检测系统，该系统采用6个并行滤波器分支对不同频段的心电图振幅和斜率进行分析&lt;/p&gt;
&lt;p&gt;10】基于QRS特征与心率相关性均值和中值的心电信号质量测量方法。&lt;/p&gt;
&lt;p&gt;11】一种利用时间特征(转折点、动态范围和预测误差)进行心电信号质量评估和电极放置的方法&lt;/p&gt;
&lt;p&gt;12】基于鲁棒最优子集线性预测特征的心电图质量评估方法&lt;/p&gt;
&lt;p&gt;    小结：&lt;/p&gt;
&lt;p&gt;               大多数方法都是基于QRS复合物检测器和心电图形态学和间期特征开发的，这些特征依赖于使用两个开源QRS检测器准确可靠地测定心电图信号中的r峰(eplimited和wqrs)。&lt;/p&gt;
&lt;p&gt;               由于ECG频谱与噪声显著重叠，因此某些ECG局部波和复合波的提取特征模型可能类似于噪声和伪像的特征模型。&lt;/p&gt;
&lt;p&gt;               基于机器学习的SQA方法高度需要大量的ECG信号和噪声数据库，以充分捕捉不同心电图节拍模式和各种噪声和伪像的独特特征。&lt;/p&gt;

&lt;p&gt;四、目标和主要贡献：&lt;/p&gt;
&lt;p&gt;         本文献研究表明，单一信号处理技术不足以消除ECG信号中的不同类型的噪声和伪影。&lt;/p&gt;
&lt;p&gt;         实验去噪结果表明，每种滤波技术都可能引入不同类型的波形失真。&lt;/p&gt;
&lt;p&gt;         重要的是确定局部噪声ECG部分的边界，以标记为不可靠的测量值或者从特征提取中丢弃有噪声的ECG段。&lt;/p&gt;
&lt;p&gt;         静息、走动和运动心电图记录条件下的实时ECG信号分析和诊断系统而言是非常重要的设计考虑因素。&lt;/p&gt;

&lt;p&gt;         本研有四个主要目标：&lt;/p&gt;
&lt;p&gt;       （1）与过去的SQA研究不同，我们的目标是提出统一的心电噪声检测，定位和分类框架，（据我们所知，没有系统框架可以对ECG信号中存在的噪声和伪像进行自动检测，定位，和分类），在减少误报率和选择噪声特定信号处理(或噪声模型)技术有效去除噪声方面具有巨大的潜力心电信号。&lt;/p&gt;
&lt;p&gt;       （2）为了减少常用CEEMD算法的计算负荷，我们在迭代过程中引入了&lt;span&gt;新的停止准则&lt;/span&gt;&lt;span&gt;，如零交叉数(NZC)和最大绝对振幅(MAA)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;       （3）探索短期时间特征提取，用于基线漂移(BW)、肌肉伪影(MA)和电力线干扰(PLI)的检测、定位和分类。&lt;/p&gt;
&lt;p&gt;      （4）建立了基于决策规则的分类算法心电图信号分为6组:无噪声心电图、心电图+BW、ECG+MA, ECG+PLI, ECG+BW+PLI, ECG+BW+MA。&lt;/p&gt;

&lt;p&gt;            评价结果表明，该框架在检测和分类心电信号中存在的噪声和伪影方面具有较高的灵敏度、正预测性和准确性。&lt;/p&gt;


&lt;p&gt;五、结果：&lt;/p&gt;
&lt;p&gt;      所提出的的框架在五个基准ECG数据库和实际ECG信号上进行了严格的评估，所提出的的框架不仅比当前最先进的方法实现了更好的噪声监测和分类，而且还准确的定位了具有低端点描绘误差的短脉冲噪声。&lt;/p&gt;

&lt;p&gt;六、意义：&lt;/p&gt;
&lt;p&gt;      对基准数据库的广泛研究表明，所提出的框架更适合于降低误报率并在自动ECG分析应用中选择适当的噪声特定去噪技术。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;&lt;span&gt;文献主要内容整理：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; A.修改CEEMD算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;         有几种技术可以将心电图信号分解成几个子信号。经验模态分解(EMD)是一种自适应时频分析技术，被广泛应用于将复杂的多分量信号分解成若干个快速和缓慢的振荡，称为固有模态函数(IMFs)。&lt;/p&gt;
&lt;p&gt;         为了克服基本EMD和集成EMD (EEMD)技术的不足，提出了完整的集成EMD技术。例如基本EMD的模态混合问题，在同一个IMF中存在不同的振荡，或者在相似振荡中存在的类似的不同的IMFs。产生不同数目的固有模式函数IMF;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;    在信噪比较低的情况下，重构信号分解后含有残余噪声。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Torres等人提出了CEEMD算法，该算法在提取后续固有模态函数后，将高斯噪声的不同实现方式加入到剩余信号中。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经证明，CEEMD算法对原始信号进行了精确的重构，并对模式进行了改进的谱划分，其所需的筛选迭代次数不到EEMD算法的一半，从而降低了计算成本。&lt;/p&gt;
&lt;p&gt;       &lt;strong&gt;&lt;span&gt;通过应用CEEMD算法,信号自适应分解为有限的固有模式函数(或振荡模式)和残留,在分解过程直到获得被分解残留不再是可行的(一个常数或单调的斜坡,或只有一个极值)或达到预定的阈值。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;         &lt;/span&gt; &lt;strong&gt; 低阶IMFs捕获肌肉伪影、电源线干扰和记录仪器噪声引起的高频噪声的快速振荡模式，而高阶IMFs通常捕获基线漂移的慢振荡模式。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         &lt;strong&gt; &lt;span&gt;最后的残差表示信号的趋势分量&lt;/span&gt;。&lt;/strong&gt;&lt;span&gt;为了减少传统CEEMD算法的计算量，本研究拟探讨IMF提取过程中残差的零阶数和慢振荡模式的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       &lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-0&quot;&gt;在改进的CEEMD算法中，当满足以下任一&lt;span&gt;&lt;strong&gt;停止准则&lt;/strong&gt;&lt;/span&gt;时，&lt;span&gt;&lt;strong&gt;即当前残差的大小小于预先设定的阈值，或当前残差的零点个数(NZC)小于预先设定的NZC值时，分解过程终止&lt;/strong&gt;&lt;/span&gt;。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;改进的CEEMD算法的结果产生了有限的IMFs集和基线漂移的残差。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;strong&gt;根据基线漂移慢振荡的最大绝对振幅和零点个数等时间参数，选择预先设定的停止准则阈值。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;通过考虑频率小于1 Hz的基线漂移和严重基线漂移的大小，选取NZC为10,MAA为0.1 mV，将基线漂移与心电图分量、MA、PLI噪声进行区分。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;      对于给定的输入ECG信号x[n]，改进的具有新的停止准则的CEEMD算法可以总结为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;       1)获得不同的体现形式的信号加上标准偏差为&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121210514316-131181883.png&quot; alt=&quot;&quot;/&gt;的指数误差的&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;高斯白噪声&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121205901599-1518806062.png&quot; alt=&quot;&quot;/&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121210614710-2126978544.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121210633931-1655506004.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;       2）分解信号加噪声的实现 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121210824586-1805330527.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121210839105-1558646178.png&quot; alt=&quot;&quot;/&gt;使用EMD得到第一个IMF，然后计算第一个IMF 为：&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121210932880-1816170333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      3）计算第一残差（residue）为：&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190121211028921-2086855724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      4）分解实现&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122090813364-1218673359.png&quot; alt=&quot;&quot;/&gt;从而的得到第一次EMD模式，得到第二种模式:&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122090939612-213761857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     5)寻找第 i 个模式,分解实现第 i 个残渣,&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122091139319-1442686584.png&quot; alt=&quot;&quot;/&gt;得到它们的第一个EMD模态，得到第(i + 1)个模态为：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122091240135-1537164148.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;             当 i 表示模式和，&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122091416634-1672084202.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122091443168-1302442803.png&quot; alt=&quot;&quot;/&gt;是第 i 个模式的残渣模式。&lt;/p&gt;

&lt;p&gt;     6)计算&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122091700528-819351838.png&quot; alt=&quot;&quot;/&gt;的NZC和MAA[n]。&lt;/p&gt;
&lt;p&gt;     7)继续下一模态的步骤5，直到得到的残差不满足所提出的停止条件:&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122091846156-1672247268.png&quot; alt=&quot;&quot;/&gt;为真。&lt;/p&gt;

&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;       本研究的目标之一是提高CEEMD算法的计算负载。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;对于10秒心电信号的处理，图2给出了改进的CEEMD算法和传统CEEMD算法在筛选操作次数方面的计算负荷。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;初步评价结果表明，改进的CEEMD算法可以显著降低不同基线漂移和无噪声心电信号的计算负荷。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;与传统的CEEMD算法相比，改进的CEEMD算法在筛选操作方面的计算负载提高了12.77%到39.33%。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;从&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;1-0&quot;&gt;结果表明，与传统的CEEMD算法相比，改进的CEEMD算法平均节省了22.18%的计算时间。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; 图2：&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122092507219-712545974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;         图2所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;改进的CEEMD算法和传统CEEMD算法在筛选(a)无噪声心电信号(b)基线漂移损坏的心电信号方面的计算负载。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;strong&gt;B.信号与噪声分离：&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;       &lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;改进的CEEMD算法分解结果如图3所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;结果表明，低阶IMFs和高阶IMFs分别捕获了心电信号的细尺度(或高频(HF)分量)和粗尺度(或低频(LF)分量)。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;对于无噪声的心电图信号，低阶IMFs，或图3(a)中的模式M1和M2，捕获QRS波复合物的快速变化分量和高阶IMFs，或图3(a)中的模式M8和M9，捕获局域波的极低频分量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122103403475-85559740.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;    图3所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;说明了干净和噪声心电信号的固有模态分解函数(IMFs): (a)干净心电信号取自记录号100，(b)噪声心电信号，包括基线漂移和肌肉伪影，取自记录号104。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;      为了表征不同类型的心电噪声，我们首先构建三个子信号，如加入前三个IMFs得到的：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;      (一)高频信号h[n]，其中可能包括MA、PLI和仪器噪声的分量以及QRS复合物的HF分量;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;      (二)低频信号b[n]，包括基线漂移，为最终残差；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;      (三)加入剩余IMFs得到的心电图信号c[n]， IMFs包括Pwave、QRS-complex和t波的主要成分。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;信号与噪声分离过程的初步评价结果如图4所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;图4(a2)和(b2)的结果表明，高频信号能够充分捕捉MA和PLI噪声。&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;进一步指出，提取的高频信号可能包含QRS复合物的高频成分。&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-6&quot;&gt;由图4(a3)、(b3)可知，提取的信号c[n]含有局域波的主要分量。&lt;span class=&quot;transSent&quot; data-group=&quot;0-7&quot;&gt;从图4(a4)和(b4)的结果可以看出，最终的残差信号b[n]捕获了基线的漂移。&lt;span class=&quot;transSent&quot; data-group=&quot;0-8&quot;&gt;对提取的高频和低频信号h[n]和b[n]进行进一步处理，对不同类型心电图噪声进行检测、定位和分类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-6&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-7&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-8&quot;&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122103530030-659536249.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;_tgt transPara&quot;&gt;      &lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;图4所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;说明从心电信号中提取的三个候选子信号:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;      (a1)-(b1)被BW和MA破坏的心电信号，以及PLI噪声。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;      (a2)-(b2)高频(HF)信号，包括MA和PLI噪声。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;      (a3)- (b3)心电图信号包括p波、QRS波、t波。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;      (a4)-(b4)低频率(LF)信号，包括BW噪音。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;strong&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;C.短时特征提取：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;     心电图噪声和伪影的典型特征是峰间振幅、频率含量和持续时间&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;[1]。本研究拟从提取的高频和低频信号h[n]和b[n]中，分别计算出最大绝对振幅(MAA)、零点个数(NZC)和自相关函数(ACF)等时间特征，对不同类型的噪声进行检测和分类。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p&gt;     &lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;1)最大绝对振幅:根据提取的HF和LF噪声信号h[n]和b[n]的峰间振幅，可以定义每种噪声和伪影的存在和严重程度。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;因此，从最终剩余信号b[n]中提取MAA特征，检测BW噪声的存在。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;根据p波、q波、QRS-complex、t波等局域波的幅值范围，本文选取0.1 mV的最大绝对幅值阈值。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;高频噪声的严重程度可以根据高频信号h[n]的MAA来确定。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;选择0.05 mV的最大绝对振幅阈值检测肌肉伪影和PLI噪声的存在。&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-5&quot;&gt;但是，可以根据特定应用的心电图分析系统可接受的最大噪声水平设置预定义的阈值。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;     &lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;2)零点包络数(NZC):分解结果表明，提取的高频信号可能包含QRS复合物的高频噪声或/及高频成分。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;对于无噪声心电图信号，提取的高频信号h[n]包括QRS波复合物的局域高频成分和非QRS波复合物部分的很小幅度噪声成分。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;在实际应用中，高频信号中QRS波复合体的振幅在不同类型的正常和异常心电图信号下是不可预测的。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;因此，简单的最大振幅阈值规则不适用于心电图信号中高频噪声的检测。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;因此，本研究探索了高频噪声检测与分类中具有显著噪声特异性的特征，如短时零噪声和自相关特征。&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;首先将提取到的高频信号h[n]分为重叠帧，每帧移动一个样本。&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;重叠过程实现为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122104335539-1872747385.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;     k = 0,1··M·L−−1。hk[n]为第k帧，M为帧大小。然后，计算每个HF信号h[n]帧的NZC。NZC特征包络线计算为：&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122104425338-1280727327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      对于干净噪声的心电信号，从高频信号h[n]中提取的NZC包络如图5(a3)和(b3)、6(a3)和(b3)所示。图5(a3)和(b3)的结果表明，NZC包络线由QRS波复段的局域短脉冲和无噪声和基线漂移心电图信号的小振幅噪声部分的零值组成。对于MA破坏的噪声心电图信号，图6(a3)中提取的NZC包络线包含更宽的杂散峰脉冲。为了检测高频噪声的存在，计算了门信号：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122104506967-918193959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       提取的门信号如图5(a4)所示，(b4)及6(a4)及(b4)为无噪音及有噪音的心电图信号。从图5(a4)和(b4)的栅极信号可以看出，QRS波的复数部分对应的局部脉冲持续时间一般在50 - 300 ms之间。同时，图6(a4)和(b4)中栅极信号对于MA和PLI噪声破坏的心电图信号，局部脉冲持续时间较短，持续时间较长。此外，局部脉冲的持续时间是不相等的。因此，QRS波宽持续时间(50- 200ms)和不应期(200- 300ms)的参数相同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122104709463-739661223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;           ( a)心电图信号受基线漂移影响                                                                      (b)无噪声心电图信号&lt;/p&gt;
&lt;p&gt;                 MIT-BIHA创纪录的111。                                                                             MIT-BIHA创纪录的100。 &lt;/p&gt;


&lt;div readability=&quot;9&quot;&gt;                  图5所示。该框架在无噪声检测中的有效性

心电图信号与基线的存在在心电图信号中漂移。&lt;/div&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;      3)自相关最大振幅:&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;         在本研究中当检测到高频噪声时，进行MA/PLI鉴别。对于MA/PLI区分，第一个IMF被划分为100 ms的重叠帧，帧位移为帧大小的20%。得到第k个坐标系为：&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122105115338-277122962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;       其中M为帧大小。对于第k个坐标系(zk[n])ACF序列计算为&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122105304180-858980701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;   其中rk(l)为信号帧zk[n]的ACF, l为ACF时滞数。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;对于每一帧，计算ACF的第一个局部最大值，提取局部最大值的ACF包络线。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;对于噪声ECG信号，提取的ACF包络线如图6(a6)和(b6)所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;从图6(a6)的ACF包络线可以看出，肌肉伪影帧的ACF值小于0.5,PLI噪声帧的ACF值大于0.7。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;初步评价结果表明，ACF特征更适合于MA/PLI识别任务。&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;在本研究中，敏感性分析用于选择预先设定的阈值，以获得更好的敏感性(Se)和正预测性(Pp)性能。&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;本研究结果如图7所示，选取最优ACF和持续阈值，可以显著影响MA/PLI识别和hf -噪声检测算法的性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122105608156-1336915868.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(a)心电图信号受基线漂移和来自MIT-BIHA记录104的肌肉伪影影响。     (b)电力线干扰损坏的心电图信号。&lt;/p&gt;

&lt;p&gt;                  图6所示。该框架在检测心电信号中存在的BW、MA和PLI噪声方面的有效性。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;D.噪声检测与分类规则：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      基于上述三个时间特征，我们构建了用于单噪声和组合噪声自动检测的噪声检测规则，总结如下:&lt;/p&gt;
&lt;p&gt;     1)基线漂移检测规则:利用以下时间特征检测基线漂移的存在MAA和NZC。定义BW噪声检测规则为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122105846611-343329991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;      检测结果如图5(a6)-(a7)和(b6)-(b7)所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;检测结果如图6(a6)-(a7)和(b6)-(b7)所示，分别为MA + BW噪声和PLI噪声破坏的噪声心电图信号。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;实验结果表明，该方法能够有效地检测单一噪声源和复合噪声源干扰的心电信号中BW噪声的存在。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;     2) MA/PLI噪声检测规则:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;       高频噪声的严重程度是根据高频信号h[n]的最大绝对振幅(MAA)来确定的。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;如果HF信号h[n]的MAA小于预先设定的0.05 mV阈值，则将ECG信号检测为无HF噪声的ECG信号。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;否则，对提取的高频信号h[n]进行进一步处理，从NZC包络线中得到门信号g[n]，因为高频信号h[n]可能包含无噪声心电图信号的大振幅QRS分量。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;为高频信号h[n]获得的门信号g[n]可以包括脉冲持续时间相等/不等的局部脉冲。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;为了检测高频噪声的存在，将每个局部脉冲的持续时间与预先设定的上、下持续时间阈值进行比较。&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;高频噪声检测规则定义为：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122110502746-1221255581.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;     &lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;如果所有的局部脉冲都满足持续时间阈值，则检测为无高频噪声心电图信号。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;否则，从信号的第一个IMF中提取ACF包络线。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;MA/PLI噪声识别规则定义为：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122110642266-475177440.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;      &lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;然后对阈值化的ACF包络线的门信号进行进一步处理，确定心电信号中MA和PLI噪声部分的边界。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;从图5(a4)和(b4)的检测结果可以看出，所有的局部脉冲都满足一个预定义的宽度阈值。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;因此，心电图信号被检测为高频无噪声信号。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;高频噪声检测规则的输出结果如图5(a5)和(b5)所示，为无噪声心电图和只有BW噪声的噪声心电图信号。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;图6(a4)和图6(b4)的检测结果不符合脉宽判定规则。&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;因此，心电图信号被检测为高频噪声的噪声心电图信号。&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;高频噪声检测规则的输出如图6(a5)和(b5)所示，分别为MA和PLI噪声破坏的噪声心电图信号。&lt;span class=&quot;transSent&quot; data-group=&quot;0-7&quot;&gt;噪声ECG信号的MA/PLI噪声识别结果如图6(a8)和(b8)所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-8&quot;&gt;结果表明，ACF特征在区分MA噪声和PLI噪声方面是有效的。&lt;span class=&quot;transSent&quot; data-group=&quot;0-9&quot;&gt;最后，结合上述三个决策结果，将处理后的心电信号分为6组:无噪声心电、心电+BW、心电+MA、心电+PLI、心电+BW+PLI、心电+BW+MA。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122134806405-308867448.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                             图7所示。说明了MA/PLI识别和HF噪声检测算法中预定义ACF和持续阈值的选择。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-7&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-8&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-9&quot;&gt;结果与讨论：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-7&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-8&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-9&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;    本节首先简要介绍用于评估该框架性能的不同基准ECG数据库和性能指标。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;在此基础上，提出了一种用于单噪声和复合噪声检测、局部化和分类的方法。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;     A:测试心电图数据库和性能指标：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;       在这项研究中,我们评估拟议的框架使用不同种类的无噪声的性能和嘈杂的ECG信号来自各种各样的基准心电图数据库,包括MIT-BIH心律失常(MIT-BIHA)数据库(34),MIT-BIH ST改变(MIT-BIHSTC)数据库(35),肺结核诊断心电图(PTBDECG)数据库(36),幻想曲数据库(37)和生理网/计算2011年心脏病的挑战(PCICC2011)数据库[38]。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;MIT-BIHA数据库包含48个两导联的动态心电图记录，每个半小时，来自47名受试者。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;这些录音以每秒360个样本的速度数字化，分辨率为11位。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;心跳、心跳类型和信号质量由专家标注。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;MIT-BIHA数据库包含15种不同类型的心跳、良好的心电图信号质量、信号丢失以及不同类型的噪音，如基线漂移和肌肉产物[34]。&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;PCICC2011数据库包含2000条标准诊断带宽(0.05- 100hz)的12导联心电图记录(I, II, II, aVR, aVL,aVF, V1, V2, V3, V4, V5, V6)。&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;同时记录引线至少10秒，并以每秒500个样本的速度进行数字化，分辨率为16位。&lt;span class=&quot;transSent&quot; data-group=&quot;0-7&quot;&gt;由于电极错位、外界干扰、皮肤电极接触不良以及患者运动产生的伪影，心电图信号表现出不同程度的噪声和伪影。&lt;span class=&quot;transSent&quot; data-group=&quot;0-8&quot;&gt;心电图信号被专家标注为“可接受”或“不可接受”。&lt;span class=&quot;transSent&quot; data-group=&quot;0-9&quot;&gt;PTBDECG数据库包含290个受试者的549条高分辨率记录。&lt;span class=&quot;transSent&quot; data-group=&quot;0-10&quot;&gt;每条记录由15条引线组成，包括12条引线和3条Frank引线ECGs (vx, vy, vz)。&lt;span class=&quot;transSent&quot; data-group=&quot;0-11&quot;&gt;信号以每秒1000个样本的速度数字化，分辨率为16位[36]。&lt;span class=&quot;transSent&quot; data-group=&quot;0-12&quot;&gt;MIT-BIHSTC数据库包括28个不同长度的双导联心电图记录，这些记录是在运动应激测试[35]期间记录的。&lt;span class=&quot;transSent&quot; data-group=&quot;0-13&quot;&gt;Fantasia数据库包含20名年轻受试者和20名老年受试者120分钟连续仰卧休息心电图信号。&lt;span class=&quot;transSent&quot; data-group=&quot;0-14&quot;&gt;每个信号以250hz的分辨率数字化，分辨率为12/16位。&lt;span class=&quot;transSent&quot; data-group=&quot;0-15&quot;&gt;心电图信号显示明显的基线漂移和快速运动伪影噪声。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122135043275-576424860.png&quot; alt=&quot;&quot;/&gt;           &lt;/p&gt;
&lt;p&gt;                       (a)用坐姿记录静息心电图                                                      (b)广泛的活动条件和站立位置&lt;/p&gt;
&lt;p&gt;                                  图8所示。实时记录心电图信号的实验装置allenger Virgo多导联心电/脑电图数据采集系统&lt;/p&gt;

&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;       在本研究中，我们也使用Allengers Virgo多导联心电图/脑电图数据采集系统实时记录心电图信号，评估了该框架的性能。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;记录50名正常受试者的心电图信号，每组10分钟(休息5分钟和广泛肌肉活动5分钟)。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;本研究的实验设置如图8所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;实时记录坐着和广泛的肌肉活动情况下的心电图信号&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-0&quot;&gt;如图9所示。&lt;span class=&quot;transSent&quot; data-group=&quot;1-1&quot;&gt;在性能评估中，利用基线漂移、肌肉伪影、电极运动[33]等真实心电图噪声，生成具有时变噪声水平和复合噪声源的不同类型的噪声心电图信号。&lt;span class=&quot;transSent&quot; data-group=&quot;1-2&quot;&gt;然后，生成PLI噪声，并将其添加到从基准数据库获取的心电图信号中。&lt;span class=&quot;transSent&quot; data-group=&quot;1-3&quot;&gt;对于某些心电图数据库，无法对信号质量和噪声类型进行人工标注。&lt;span class=&quot;transSent&quot; data-group=&quot;1-4&quot;&gt;然而，所有10秒持续时间的心电图信号均手动标记为“可接受”或“不可接受”心电图信号及噪声类，即无噪声心电图、心电图+BW、心电图+MA、心电图+PLI、心电图+BW+PLI、心电图+BW+MA。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-4&quot;&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-4&quot;&gt;       &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;        心电图噪声的性能检测和分类评估使用基准指标,如灵敏度(Se)、积极predictivity (Pp),特异性(Sp)和整体精度(OA),从真阳性的数量计算(TP),真正的底片(TN),假阳性的数量(FP),和假阴性的数量(FN)通过交叉验证的检测和分类的结果。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;性能指标定义为:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-0&quot;&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122135432522-803608609.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122135507497-669966985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;6-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;6-1&quot;&gt;       在本研究中，我们使用Se、Sp和OA指标来评估噪声检测的性能。&lt;span class=&quot;transSent&quot; data-group=&quot;6-2&quot;&gt;噪声分类使用Se、Pp和CA指标进行评估。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;6-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;6-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;6-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;       在第一个实验中，我们评估了该框架在检测心电信号中噪声存在的有效性。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;比较的目的,我们实现了五个方法,QRS波群特征和模板匹配等[5],高阶统计(HOS)特性和QRS complex-based特性之后,机器学习分类器[14],移动average-based过滤器和低级特征[31],相关性PQRST形态的心电图胜[13],QRS-detection和RR-interval特性和启发式规则[18]。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;测试ECG信号包括夏普和高P波和T波,小型和宽QRS复合物,不规则的心电图形态模式、室性心动过速、心室颤动,颤动,心房纤维性颤动,颤动,左束支阻滞,右束支块,不规则的心律,由于设备饱和突变,出现长时间的停顿和各种模式的BW,马英九和PLI噪音。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;这些测试心电图信号分为四组:(i)组:窦性心律正常的干净噪声心电图信号;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;(ii) b组:干净嘈杂的室性心律失常心电图信号;&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;(iii) c组:清洁嘈杂的房颤心电图信号;(iv) d组:实时记录心电图信号。&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;四组心电信号的噪声检测结果如表1所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-7&quot;&gt;该方法检测无噪声心电图和噪声心电图段平均Se为99.12%，Sp为98.56%，OA为98.90%。&lt;span class=&quot;transSent&quot; data-group=&quot;0-8&quot;&gt;此外，对于实时记录的心电信号，该方法平均Se为99.13%，Sp为98.20%，OA为98.67%。&lt;span class=&quot;transSent&quot; data-group=&quot;0-9&quot;&gt;检测结果表明，该方法对四组测试心电信号均优于五种噪声检测方法。&lt;span class=&quot;transSent&quot; data-group=&quot;0-10&quot;&gt;本研究证明了本文提出的局部脉冲持续时间阈值为50ms - 300ms的NZC包络线短时特征对于利用改进的CEEMD算法从提取的高频信号中有效鉴别QRS复合物高频成分与高频噪声存在的潜力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122135223501-383121814.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;                                             图9所示。在(a)坐姿(b)广泛的体力活动条件下实时记录心电图信号。&lt;/p&gt;


&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;         在第二个实验中，我们评估了该方法对心电信号的分类性能，分为无噪声心电、心电+BW、心电+MA、心电+PLI、心电+BW+PLI、心电+BW+MA六大类。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;5个标准心电图数据库的心电图信号噪声分类结果如表二所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;结果表明，该方法平均Se为98.19%，Pp为96.61%，Se为99.18%&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-0&quot;&gt;Pp分别为98.02%、Se为99.76%、Pp为99.89%，用于鉴别ECG+BW、ECG+MA、ECG+PLI的存在。&lt;span class=&quot;transSent&quot; data-group=&quot;1-1&quot;&gt;该方法在识别ECG+BW+MA和ECG+BW+PLI存在时，平均Se为98.74%，Pp为96.46%，Se为99.81%，Pp为99.81%。&lt;span class=&quot;transSent&quot; data-group=&quot;1-2&quot;&gt;本研究的总体混淆矩阵如表3所示。&lt;span class=&quot;transSent&quot; data-group=&quot;1-3&quot;&gt;混淆矩阵的对角线元素表示分类正确的无噪声心电信号和不同噪声的噪声心电信号。&lt;span class=&quot;transSent&quot; data-group=&quot;1-4&quot;&gt;矩阵的非对角元素表示分类错误的心电信号。&lt;span class=&quot;transSent highlight&quot; data-group=&quot;1-5&quot;&gt;从评价结果可以看出，人工标注时，低幅值BW和MA噪声损坏的心电信号被错误标注为无噪声心电信号。&lt;span class=&quot;transSent&quot; data-group=&quot;1-6&quot;&gt;评价结果表明，所提出的归一化ACF的局部最大峰值幅值特征在区分PLI和MA分量方面具有良好的效果。&lt;span class=&quot;transSent&quot; data-group=&quot;1-7&quot;&gt;实验结果进一步证明了改进的CEEMD算法提取心电信号基线漂移的有效性。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-4&quot;&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;1-5&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-6&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-7&quot;&gt;                           表1噪声检测性能比较&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-4&quot;&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;1-5&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-6&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-7&quot;&gt;在本方法与现有方法[5]、[14]之间，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-4&quot;&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;1-5&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-6&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-7&quot;&gt;[13][18][31]使用四个心电图信号组。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;_tgt transPara&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-4&quot;&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;1-5&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-6&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;1-7&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122140208903-727429243.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;  A:窦性心律正常无噪声噪声心电图信号;&lt;/p&gt;
&lt;p&gt;  B:无噪声、有噪声的心电图信号伴室性心律失常;&lt;/p&gt;
&lt;p&gt;  C:无噪声、有噪声的心电图信号伴房性心律失常;&lt;/p&gt;
&lt;p&gt;  D:本研究记录的实时心电图信号。&lt;/p&gt;


&lt;p&gt;                                                                表二   该方法的分类结果      &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122140504383-121881392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;                                          表3 提出的方法的混淆矩阵为所有数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122140551967-955026678.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;                                       表4所提框架的短时突发噪声定位性能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122140654481-1910178555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;       &lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;在实际应用中，心电图信号经常被短脉冲噪声部分破坏，这种噪声不会持续很长时间。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;图10 (a)和(b)中的心电图信号显示存在高频噪声的短脉冲。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;在这种情况下，从心电信号中定位和提取短时突发噪声对鲁棒心电参数提取系统具有重要作用，在鲁棒心电参数提取系统中，不需进一步处理即可自动丢弃严重噪声部分。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;因此，我们研究了更适合该噪声定位任务的MAA、NZC和ACF特征的短期时间估计。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;为了评估性能，我们手工标记心电图信号中短脉冲噪声的端点。&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;该方法的噪声定位性能如图10 (a)和(b)所示。&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;噪声定位结果如表4所示。结果表明，该方法在定位持续时间为0.84 s - 5.56 s的噪声短时突发时，端点误差最大值为0.67 s，最小值为0 s。&lt;span class=&quot;transSent&quot; data-group=&quot;0-7&quot;&gt;结果进一步表明，与BW噪声定位相比，该方法对高频噪声短脉冲定位具有更好的端点刻画性能。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;       &lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;基于广泛研究的五个标准心电图数据库,拟议的框架的关键优势总结如下:(i)它不需要QRS探测器仍是一个具有挑战性的任务甚至在无噪声的ECG信号由高P / T波达到高峰,小型和宽QRS复合物,时变心电图形态和不规则利率[2],[6];&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;(二)产生最佳心电信号和噪声模型，不需要大量不同类型的心电信号和各种类型的单、组合心电噪声;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;(三)检测噪声的存在，识别噪声类型，提供心电信号中短时突发噪声部分的端点;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;(四)与现有的基于心电波形形态特征和区间特征的检测、定位和分类方法不同，它采用了三种时域特征对单个噪声和组合噪声进行检测、定位和分类，这对鲁棒QRS波检测器和心电波形描绘器的要求很高。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;该方法通过引入新的停止准则，大大降低了CEEMD算法的计算负荷。&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-5&quot;&gt;对单导联和多导联心电信号的评估结果表明，该框架在减少自动心电分析系统误报、提高心电去噪/压缩方法性能方面具有巨大的潜力。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-5&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1589956/201901/1589956-20190122153354390-1721818333.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;            图10所示。该方法在检测和定位不同QRS复杂形态学的心电图信号中肌肉噪声短脉冲的有效性。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;transSent&quot; data-group=&quot;0-0&quot;&gt;       本文提出了一种新的心电噪声自动检测、定位和分类的统一框架。&lt;span class=&quot;transSent&quot; data-group=&quot;0-1&quot;&gt;提出了一种改进的CEEMD算法，给出了减少计算量的新的停止准则。&lt;span class=&quot;transSent&quot; data-group=&quot;0-2&quot;&gt;我们探索了自相关函数的最大绝对振幅、零点个数、局部最大峰值等短时特征，用于识别BW、MA和PLI噪声。&lt;span class=&quot;transSent&quot; data-group=&quot;0-3&quot;&gt;根据特征阈值规则，将处理后的心电片段分为6组:无噪声心电、心电+BW、心电+MA、心电+PLI、心电+BW+PLI、心电+BW+MA。&lt;span class=&quot;transSent&quot; data-group=&quot;0-4&quot;&gt;该方法在5个标准心电图数据库中采集的大量单导联和多导联心电图信号上进行了验证。&lt;span class=&quot;transSent&quot; data-group=&quot;0-5&quot;&gt;该方法在检测无噪声噪声心电信号时，平均Se为99.12%，Sp为98.56%，OA为98.90%。&lt;span class=&quot;transSent&quot; data-group=&quot;0-6&quot;&gt;结果表明，在存在各种噪声和伪影的情况下，该方法对不同组心电信号的检测效果优于现有方法。&lt;span class=&quot;transSent&quot; data-group=&quot;0-7&quot;&gt;分类结果表明，该方法将心电信号分为6组，平均Se为98.93%，Pp为98.39%，CA为97.38%。&lt;span class=&quot;transSent&quot; data-group=&quot;0-8&quot;&gt;大量的评估结果表明，该方法的有效性和通用性上述时间特征与预定义的阈值在本研究中使用。&lt;span class=&quot;transSent highlight&quot; data-group=&quot;0-9&quot;&gt;与现有的方法不同，该统一框架不仅可以实现更好的心电噪声检测和分类率，而且可以准确定位心电信号中存在的短时突发噪声。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;





&lt;p&gt;为了便于本论文的理解，记录下看过的觉得非常有价值的大神地址们，大神们的杰作不搬运，为了日后想看，整理如下：&lt;/p&gt;
&lt;p&gt;1. https://wenku.baidu.com/view/3bba7029b4daa58da0114a9a.html&lt;/p&gt;
&lt;p&gt;2. https://www.cnblogs.com/Dinging006/p/10282993.html&lt;/p&gt;
&lt;p&gt;3. https://zhuanlan.zhihu.com/p/40005057&lt;/p&gt;



&lt;p&gt; 下一篇，是本论文的相关知识点补充。&lt;/p&gt;

</description>
<pubDate>Tue, 22 Jan 2019 07:47:00 +0000</pubDate>
<dc:creator>徐冰块的程序员成长日记</dc:creator>
<og:description>以下是对文章内容的理解，在这里做个笔记，便于回顾，没有什么技术含量，就是一个学习日记笔记，嘻嘻。 文章内容的思路： 一、框架包括： 1.改进的集合经验模式分解 modified ensemb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xubingkuai/p/10299584.html</dc:identifier>
</item>
<item>
<title>netty源码解解析(4.0)-12 Channel NIO实现:channel初始化 - 自带buff</title>
<link>http://www.cnblogs.com/brandonli/p/10277841.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brandonli/p/10277841.html</guid>
<description>&lt;p&gt;　　创建一个channel实例，并把它register到eventLoopGroup中之后，这个channel然后处于inactive状态，仍然是不可用的。只有在bind或connect方法调用成功之后才能正常。因此bind或connect算是channel初始化的最后一步，本章这就重点分析这两个功能的实现。&lt;/p&gt;
&lt;p&gt;　　接下来的代码分析如果没有特别说明，都是以NioSocketChannel为例。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;bind实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;bind方法的调用栈如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;io.netty.channel.AbstractChannel#bind(java.net.SocketAddress)
io.netty.channel.DefaultChannelPipeline#bind(java.net.SocketAddress)
io.netty.channel.AbstractChannelHandlerContext#bind(java.net.SocketAddress)　　&lt;br/&gt;io.netty.channel.AbstractChannelHandlerContext#bind(java.net.SocketAddress, io.netty.channel.ChannelPromise)
io.netty.channel.AbstractChannelHandlerContext#invokeBind
io.netty.channel.DefaultChannelPipeline.HeadContext#bind
io.netty.channel.AbstractChannel.AbstractUnsafe#bind
io.netty.channel.socket.nio.NioSocketChannel#doBind
io.netty.channel.socket.nio.NioSocketChannel#doBind0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了能简单明了地展示调用关系，这个调用栈忽略了一些调用。可能有多个AbstractChannelHandlerContext的方法在不同的线程中被调用。以后在描述调用栈时也会忽略这一点，不再赘述。&lt;/p&gt;
&lt;p&gt;　　io.netty.channel.AbstractChannel.AbstractUnsafe#bind执行了主要的bind逻辑，它会调用doBind, 然后在channel的状态从inactive变成active，就调用pipline的fireChannelActive方法触发channelActives事件。doBind是io.netty.channel.AbstractChannel定义的抽象方法。NioSocketChannel只需要实现这个方法，整个bind功能就完整了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 1 &lt;span&gt;    @Override
 2     protected void doBind(SocketAddress localAddress) throws&lt;span&gt; Exception {
 3 &lt;span&gt;        doBind0(localAddress);
 4 &lt;span&gt;    }
 5     private void doBind0(SocketAddress localAddress) throws&lt;span&gt; Exception {
 6         if (PlatformDependent.javaVersion() &amp;gt;= 7&lt;span&gt;) {
 7 &lt;span&gt;            SocketUtils.bind(javaChannel(), localAddress);
 8         } else&lt;span&gt; {
 9 &lt;span&gt;            SocketUtils.bind(javaChannel().socket(), localAddress);
10 &lt;span&gt;        }
11     }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　SocketUtils封装了通过AccessController调用JDK的socket API接口，事实上还是调用Socket或SocketChannel的bind方法。Nio的三个Channel类实现doBind的代码几乎一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;connect实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　connect的调用栈如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;io.netty.channel.AbstractChannel#connect(java.net.SocketAddress)
io.netty.channel.DefaultChannelPipeline#connect(java.net.SocketAddress)
io.netty.channel.AbstractChannelHandlerContext#connect(java.net.SocketAddress)
io.netty.channel.AbstractChannelHandlerContext#connect(java.net.SocketAddress, io.netty.channel.ChannelPromise)
io.netty.channel.AbstractChannelHandlerContext#connect(java.net.SocketAddress, java.net.SocketAddress, io.netty.channel.ChannelPromise)
io.netty.channel.AbstractChannelHandlerContext#invokeConnect
io.netty.channel.DefaultChannelPipeline.HeadContext#connect
io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect
io.netty.channel.socket.nio.NioSocketChannel#doConnect&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　connect的主要逻辑在io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect中实现，它的流程是:&lt;/p&gt;
&lt;p&gt;　　1. 调用doConnect方法，这个方法是AbstractNioChanne定义的抽象方法。&lt;/p&gt;
&lt;p&gt;　　2. 如果doConnect成功，且channel的状态从inactive变成active，则调用pipeline的fireChannelActive方法触发channelActive事件。&lt;/p&gt;
&lt;p&gt;　　3. 如果doConnection失败，调用close关闭channel。&lt;/p&gt;
&lt;p&gt;　　io.netty.channel.socket.nio.NioSocketChannel#doConnect中是socket connect API的调用。下面是connect的关键代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 1 &lt;span&gt;@Override
 2 public final void&lt;span&gt; connect(
 3         final SocketAddress remoteAddress, final SocketAddress localAddress, final&lt;span&gt; ChannelPromise promise) {
 4     if (!promise.setUncancellable() || !&lt;span&gt;ensureOpen(promise)) {
 5         return&lt;span&gt;;
 6 &lt;span&gt;    }
 7 
 8     try&lt;span&gt; {
 9         if (connectPromise != null&lt;span&gt;) {
10             // Already a connect in process.
11             throw new&lt;span&gt; ConnectionPendingException();
12 &lt;span&gt;        }
13 
14         boolean wasActive =&lt;span&gt; isActive();
15         if&lt;span&gt; (doConnect(remoteAddress, localAddress)) {
16 &lt;span&gt;            fulfillConnectPromise(promise, wasActive);
17         } else&lt;span&gt; {
18             connectPromise =&lt;span&gt; promise;
19             requestedRemoteAddress =&lt;span&gt; remoteAddress;
20 
21             // Schedule connect timeout.
22             int connectTimeoutMillis =&lt;span&gt; config().getConnectTimeoutMillis();
23             if (connectTimeoutMillis &amp;gt; 0&lt;span&gt;) {
24                 connectTimeoutFuture = eventLoop().schedule(new&lt;span&gt; Runnable() {
25 &lt;span&gt;                    @Override
26                     public void&lt;span&gt; run() {
27                         ChannelPromise connectPromise = AbstractNioChannel.this&lt;span&gt;.connectPromise;
28                         ConnectTimeoutException cause =
29                                 new ConnectTimeoutException(&quot;connection timed out: &quot; +&lt;span&gt; remoteAddress);
30                         if (connectPromise != null &amp;amp;&amp;amp;&lt;span&gt; connectPromise.tryFailure(cause)) {
31                             close(voidPromise());
32 &lt;span&gt;                        }
33 &lt;span&gt;                    }
34 &lt;span&gt;                }, connectTimeoutMillis, TimeUnit.MILLISECONDS);
35 &lt;span&gt;            }
36 
37             promise.addListener(new&lt;span&gt; ChannelFutureListener() {
38 &lt;span&gt;                @Override
39                 public void operationComplete(ChannelFuture future) throws&lt;span&gt; Exception {
40                     if&lt;span&gt; (future.isCancelled()) {
41                         if (connectTimeoutFuture != null&lt;span&gt;) {
42                             connectTimeoutFuture.cancel(false&lt;span&gt;);
43 &lt;span&gt;                        }
44                         connectPromise = null&lt;span&gt;;
45                         close(voidPromise());
46 &lt;span&gt;                    }
47 &lt;span&gt;                }
48 &lt;span&gt;            });
49 &lt;span&gt;        }
50     } catch&lt;span&gt; (Throwable t) {
51 &lt;span&gt;        promise.tryFailure(annotateConnectException(t, remoteAddress));
52         closeIfClosed();
53 &lt;span&gt;    }
54 &lt;span&gt;}
55 
56 private void fulfillConnectPromise(ChannelPromise promise, boolean&lt;span&gt; wasActive) {
57     if (promise == null&lt;span&gt;) {
58         return&lt;span&gt;;
59 &lt;span&gt;    }
60     boolean active =&lt;span&gt; isActive();
61     boolean promiseSet =&lt;span&gt; promise.trySuccess();
62 
63     if (!wasActive &amp;amp;&amp;amp;&lt;span&gt; active) {
64         pipeline().fireChannelActive();
65 &lt;span&gt;    }
66     if (!&lt;span&gt;promiseSet) {
67 &lt;span&gt;        close(voidPromise());
68 &lt;span&gt;    }
69 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　第14,15行和整个fulfillConnectPromise方法处理正常流程。&lt;/p&gt;
&lt;p&gt;　　第18-52行处理异常流程。代码虽然多，但总结起来就一句话: 设置promis返回错误，确保能够调用close方法&lt;/p&gt;
&lt;p&gt;　　io.netty.channel.socket.nio.NioSocketChannel#doConnect实现和doBind实现类似:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 1 &lt;span&gt;@Override
 2 protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws&lt;span&gt; Exception {
 3     if (localAddress != null&lt;span&gt;) {
 4 &lt;span&gt;        doBind0(localAddress);
 5 &lt;span&gt;    }
 6 
 7     boolean success = false&lt;span&gt;;
 8     try&lt;span&gt; {
 9         boolean connected =&lt;span&gt; SocketUtils.connect(javaChannel(), remoteAddress);
10         if (!&lt;span&gt;connected) {
11 &lt;span&gt;            selectionKey().interestOps(SelectionKey.OP_CONNECT);
12 &lt;span&gt;        }
13         success = true&lt;span&gt;;
14         return&lt;span&gt; connected;
15     } finally&lt;span&gt; {
16         if (!&lt;span&gt;success) {
17 &lt;span&gt;            doClose();
18 &lt;span&gt;        }
19 &lt;span&gt;    }
20 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在第11行，注册OP_CONNECT事件。由于channel在初始化是被设置成非阻塞模式，connect方法可能返回false, 如果返回false表示connect操作没有完成，需要通过selector关注OP_CONNECT事件，把connect变成一个异步过程。只有异步调用io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#finishConnect之后，connect才算完成。finishConnect在eventLoop中被调用:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;io.netty.channel.nio.NioEventLoop#processSelectedKey(java.nio.channels.SelectionKey, io.netty.channel.nio.AbstractNioChannel)&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ((readyOps &amp;amp; SelectionKey.OP_CONNECT) != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ops =&lt;span&gt; k.interestOps();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     ops &amp;amp;= ~&lt;span&gt;SelectionKey.OP_CONNECT;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    k.interestOps(ops);
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    unsafe.finishConnect();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　 finishConnection的实现如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#finishConnect&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; finishConnect() {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Note this method is invoked by the event loop only if the connection attempt was
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; neither cancelled nor timed out.&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;assert&lt;/span&gt;&lt;span&gt; eventLoop().inEventLoop();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9         boolean wasActive = isActive();
10         doFinishConnect();
11         fulfillConnectPromise(connectPromise, wasActive);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        fulfillConnectPromise(connectPromise, annotateConnectException(t, requestedRemoteAddress));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Check for null as the connectTimeoutFuture is only created if a connectTimeoutMillis &amp;gt; 0 is used
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; See &lt;/span&gt;&lt;span&gt;https://github.com/netty/netty/issues/1770&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (connectTimeoutFuture != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             connectTimeoutFuture.cancel(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         connectPromise = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;io.netty.channel.socket.nio.NioSocketChannel#doFinishConnect&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doFinishConnect() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;javaChannel().finishConnect()) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　9-11行是finishConnection的关键代码, 先调用doFinishConnect执行完成连接之后的操作，NioSocketChannel实现是检查连接是否真的已经完成(27-29行)，然后调用fulfillConnectPromise触发事件,设置promise返回值。在前面分析netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect代码时，可以看到在doConnect调用成功以后会立即调用这个方法。这个方法被调用两次是为了确保channelActive事件一定会被触发一次。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;localAddress,remoteAddress实现：得到channel的本地和远程地址&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这个两个方法的实现几乎一样，这里只分析localAddress，它的调用栈如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;io.netty.channel.AbstractChannel#localAddress
2 &lt;span&gt;io.netty.channel.AbstractChannel.AbstractUnsafe#localAddress
3 io.netty.channel.socket.nio.NioSocketChannel#localAddress0&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个方法不会触发任何事件，因此没有通过pipline调用unsafe，它直接调用unsafe的方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 1 //io.netty.channel.AbstractChannel#localAddress
 2 &lt;span&gt;@Override
 3 public&lt;span&gt; SocketAddress localAddress() {
 4     SocketAddress localAddress = this&lt;span&gt;.localAddress;
 5     if (localAddress == null&lt;span&gt;) {
 6         try&lt;span&gt; {
 7             this.localAddress = localAddress =&lt;span&gt; unsafe().localAddress();
 8         } catch&lt;span&gt; (Throwable t) {
 9             // Sometimes fails on a closed socket in Windows.
10             return null&lt;span&gt;;
11 &lt;span&gt;        }
12 &lt;span&gt;    }
13     return&lt;span&gt; localAddress;
14 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在第7行直接调用unsafe的locallAddress方法，这个方法在AbstractUnsafe中实现，它调用了localAddress0，这一个protected的抽象方法，在NioSocketChannel中的实现是:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
1 &lt;span&gt;@Override
2 protected&lt;span&gt; SocketAddress localAddress0() {
3     return&lt;span&gt; javaChannel().socket().getLocalSocketAddress();
4 }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Tue, 22 Jan 2019 07:47:00 +0000</pubDate>
<dc:creator>自带buff</dc:creator>
<og:description>创建一个channel实例，并把它register到eventLoopGroup中之后，这个channel然后处于inactive状态，仍然是不可用的。只有在bind或connect方法调用成功之后才</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brandonli/p/10277841.html</dc:identifier>
</item>
<item>
<title>面试最让你手足无措的一个问题：你的系统如何支撑高并发？ - 架构师你好</title>
<link>http://www.cnblogs.com/bokeyuan1204/p/10304128.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bokeyuan1204/p/10304128.html</guid>
<description>
&lt;p class=&quot;ql-align-center&quot;&gt;&lt;strong&gt;（1）一道面试题的背景引入&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;这篇文章，我们聊聊大量同学问我的一个问题，面试的时候被问到一个让人特别手足无措的问题：你的系统如何支撑高并发？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;大多数同学被问到这个问题压根儿没什么思路去回答，不知道从什么地方说起，其实本质就是没经历过一些真正有高并发系统的锤炼罢了。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;因为没有过相关的项目经历，所以就没法从真实的自身体会和经验中提炼出一套回答，然后系统的阐述出来自己复杂过的系统如何支撑高并发的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以，这篇文章就从这个角度切入来简单说说这个问题，用一个最简单的思路来回答，大致如何应对。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;当然这里首先说清楚一个前提：高并发系统各不相同。比如每秒百万并发的中间件系统、每日百亿请求的网关系统、瞬时每秒几十万请求的秒杀大促系统。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;他们在应对高并发的时候，因为系统各自自身特点的不同，所以应对架构都是不一样的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;另外，比如电商平台中的订单系统、商品系统、库存系统，在高并发场景下的架构设计也是不同的，因为背后的业务场景什么的都不一样。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以，这篇文章主要是给大家提供一个回答这类问题的思路，不涉及任何复杂架构设计，让你不至于在面试中被问到这个问题时，跟面试官大眼瞪小眼。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;具体要真能在面试的时候回答好这个问题，建议各位参考一下本文思路，然后对你自己手头负责的系统多去思考一下，最好做一些相关的架构实践。&lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt;&lt;strong&gt;（2）先考虑一个最简单的系统架构&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;假设刚刚开始你的系统就部署在一台机器上，背后就连接了一台数据库，数据库部署在一台服务器上。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;我们甚至可以再现实点，给个例子，你的系统部署的机器是4核8G，数据库服务器是16核32G。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;此时假设你的系统用户量总共就10万，用户量很少，日活用户按照不同系统的场景有区别，我们取一个较为客观的比例，10%吧，每天活跃的用户就1万。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;按照28法则，每天高峰期算他4个小时，高峰期活跃的用户占比达到80%，就是8000人活跃在4小时内。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;然后每个人对你的系统发起的请求，我们算他每天是20次吧。那么高峰期8000人发起的请求也才16万次，平均到4小时内的每秒（14400秒），每秒也就10次请求。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;好吧！完全跟高并发搭不上边，对不对？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;然后系统层面每秒是10次请求，对数据库的调用每次请求都会好几次数据库操作的，比如做做crud之类的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;那么我们取一个一次请求对应3次数据库请求吧，那这样的话，数据库层每秒也就30次请求，对不对？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;按照这台数据库服务器的配置，支撑是绝对没问题的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;上述描述的系统，用一张图表示，就是下面这样：&lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt;&lt;strong&gt;（3）系统集群化部署&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;假设此时你的用户数开始快速增长，比如注册用户量增长了50倍，上升到了500万。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;此时日活用户是50万，高峰期对系统每秒请求是500/s。然后对数据库的每秒请求数量是1500/s，这个时候会怎么样呢？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;按照上述的机器配置来说，如果你的系统内处理的是较为复杂的一些业务逻辑，是&lt;span&gt;那种重业务逻辑的系统的话，是比较耗费CPU的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;此时，4核8G的机器每秒请求达到500/s的时候，很可能你会发现你的机器CPU负载较高了。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;然后数据库层面，以上述的配置而言，其实基本上1500/s的高峰请求压力的话，还算可以接受。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;这个主要是要观察数据库所在机器的磁盘负载、网络负载、CPU负载、内存负载，按照我们的线上经验而言，&lt;span&gt;那个配置的数据库在1500/s请求压力下是没问题的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以此时你需要做的一个事情，首先就是要支持你的系统集群化部署。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;你可以在前面挂一个负载均衡层，把请求均匀打到系统层面，让系统可以用多台机器集群化支撑更高的并发压力。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;比如说这里假设给系统增加部署一台机器，那么每台机器就只有250/s的请求了。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;这样一来，两台机器的CPU负载都会明显降低，这个初步的“高并发”不就先cover住了吗？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;要是连这个都不做，那单台机器负载越来越高的时候，极端情况下是可能出现机器上部署的系统无法有足够的资源响应请求了，然后出现请求卡死，甚至系统宕机之类的问题。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以，简单小结，第一步要做的：&lt;/p&gt;
&lt;ol&gt;&lt;li class=&quot;ql-align-justify&quot;&gt;添加负载均衡层，将请求均匀打到系统层。&lt;/li&gt;
&lt;li class=&quot;ql-align-justify&quot;&gt;系统层采用集群化部署多台机器，扛住初步的并发压力。&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;此时的架构图变成下面的样子：&lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt;&lt;strong&gt;（4）数据库分库分表 + 读写分离&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;假设此时用户量继续增长，达到了1000万注册用户，然后每天日活用户是100万。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;那么此时对系统层面的请求量会达到每秒1000/s，系统层面，你可以继续通过集群化的方式来扩容，反正前面的负载均衡层会均匀分散流量过去的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;但是，这时数据库层面接受的请求量会达到3000/s，这个就有点问题了。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;此时数据库层面的并发请求翻了一倍，你一定会发现线上的数据库负载越来越高。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;每次到了高峰期，磁盘IO、网络IO、内存消耗、CPU负载的压力都会很高，大家很担心数据库服务器能否抗住。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;没错，一般来说，对那种普通配置的线上数据库，建议就是读写并发加起来，按照上述我们举例的那个配置，不要超过3000/s。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;因为数据库压力过大，首先一个问题就是高峰期系统性能可能会降低，因为数据库负载过高对性能会有影响。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;另外一个，压力过大把你的数据库给搞挂了怎么办？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以此时你必须得对系统做分库分表 + 读写分离，也就是把一个库拆分为多个库，部署在多个数据库服务上，这是作为主库承载写入请求的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;然后每个主库都挂载至少一个从库，由从库来承载读请求。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;此时假设对数据库层面的读写并发是3000/s，其中写并发占到了1000/s，读并发占到了2000/s。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;那么一旦分库分表之后，采用两台数据库服务器上部署主库来支撑写请求，每台服务器承载的写并发就是500/s。每台主库挂载一个服务器部署从库，那么2个从库每个从库支撑的读并发就是1000/s。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;简单总结，并发量继续增长时，我们就需要focus在数据库层面：分库分表、读写分离。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;此时的架构图如下所示：&lt;/p&gt;

&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt;&lt;strong&gt;（5）缓存集群引入&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;接着就好办了，如果你的注册用户量越来越大，此时你可以不停的加机器，比如说系统层面不停加机器，就可以承载更高的并发请求。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;然后数据库层面如果写入并发越来越高，就扩容加数据库服务器，通过分库分表是可以支持扩容机器的，如果数据库层面的读并发越来越高，就扩容加更多的从库。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;但是这里有一个很大的问题：数据库其实本身不是用来承载高并发请求的，所以通常来说，数据库单机每秒承载的并发就在几千的数量级，而且数据库使用的机器都是比较高配置，比较昂贵的机器，成本很高。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;如果你就是简单的不停的加机器，其实是不对的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以在高并发架构里通常都有缓存这个环节，缓存系统的设计就是为了承载高并发而生。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以单机承载的并发量都在每秒几万，甚至每秒数十万，对高并发的承载能力比数据库系统要高出一到两个数量级。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以你完全可以根据系统的业务特性，对那种写少读多的请求，引入缓存集群。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;具体来说，就是在写数据库的时候同时写一份数据到缓存集群里，然后用缓存集群来承载大部分的读请求。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;这样的话，通过缓存集群，就可以用更少的机器资源承载更高的并发。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;比如说上面那个图里，读请求目前是每秒2000/s，两个从库各自抗了1000/s读请求，但是其中可能每秒1800次的读请求都是可以直接读缓存里的不怎么变化的数据的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;那么此时你一旦引入缓存集群，就可以抗下来这1800/s读请求，落到数据库层面的读请求就200/s。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;同样，给大家来一张架构图，一起来感受一下：&lt;/p&gt;

&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;按照上述架构，他的好处是什么呢？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;可能未来你的系统读请求每秒都几万次了，但是可能80%~90%都是通过缓存集群来读的，而缓存集群里的机器可能单机每秒都可以支撑几万读请求，所以耗费机器资源很少，可能就两三台机器就够了。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;你要是换成是数据库来试一下，可能就要不停的加从库到10台、20台机器才能抗住每秒几万的读并发，那个成本是极高的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;好了，我们再来简单小结，承载高并发需要考虑的第三个点：&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;ql-align-justify&quot;&gt;不要盲目进行数据库扩容，数据库服务器成本昂贵，且本身就不是用来承载高并发的&lt;/li&gt;
&lt;li class=&quot;ql-align-justify&quot;&gt;针对写少读多的请求，引入缓存集群，用缓存集群抗住大量的读请求&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt;&lt;strong&gt;（6）引入消息中间件集群&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;接着再来看看数据库写这块的压力，其实是跟读类似的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;假如说你所有写请求全部都落地数据库的主库层，当然是没问题的，但是写压力要是越来越大了呢？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;比如每秒要写几万条数据，此时难道也是不停的给主库加机器吗？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;可以当然也可以，但是同理，你耗费的机器资源是很大的，这个就是数据库系统的特点所决定的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;相同的资源下，数据库系统太重太复杂，所以并发承载能力就在几千/s的量级，所以此时你需要引入别的一些技术。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;比如说消息中间件技术，也就是MQ集群，他是非常好的做写请求异步化处理，实现削峰填谷的效果。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;假如说，你现在每秒是1000/s次写请求，其中比如500次请求是必须请求过来立马写入数据库中的，但是另外500次写请求是可以允许异步化等待个几十秒，甚至几分钟后才落入数据库内的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;那么此时你完全可以引入消息中间件集群，把允许异步化的每秒500次请求写入MQ，然后基于MQ做一个削峰填谷。比如就以平稳的100/s的速度消费出来然后落入数据库中即可，此时就会大幅度降低数据库的写入压力。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;ps：关于MQ削峰填谷的概念，在公众号之前讲消息中间件的文章中已详细阐述，如果大伙儿忘记了，可以回顾一下。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;此时，架构图变成了下面这样：&lt;/p&gt;

&lt;p class=&quot;ql-align-center&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;大家看上面的架构图，首先消息中间件系统本身也是为高并发而生，所以通常单机都是支撑几万甚至十万级的并发请求的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以，他本身也跟缓存系统一样，可以用很少的资源支撑很高的并发请求，用他来支撑部分允许异步化的高并发写入是没问题的，比使用数据库直接支撑那部分高并发请求要减少很多的机器使用量。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;而且经过消息中间件的削峰填谷之后，比如就用稳定的100/s的速度写数据库，那么数据库层面接收的写请求压力，不就成了500/s + 100/s = 600/s了么？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;大家看看，是不是发现减轻了数据库的压力？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;到目前为止，通过下面的手段，我们已经可以让系统架构尽可能用最小的机器资源抗住了最大的请求压力，减轻了数据库的负担。&lt;/p&gt;
&lt;ul&gt;&lt;li class=&quot;ql-align-justify&quot;&gt;系统集群化&lt;/li&gt;
&lt;li class=&quot;ql-align-justify&quot;&gt;数据库层面的分库分表+读写分离&lt;/li&gt;
&lt;li class=&quot;ql-align-justify&quot;&gt;针对读多写少的请求，引入缓存集群&lt;/li&gt;
&lt;li class=&quot;ql-align-justify&quot;&gt;针对高写入的压力，引入消息中间件集群，&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;初步来说，简单的一个高并发系统的阐述是说完了。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;但是，其实故事到这里还远远没有结束。&lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt;&lt;strong&gt;（7）现在能hold住高并发面试题了吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;看完了这篇文章，你觉得自己能回答好面试里的高并发问题了吗？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;很遗憾，答案是不能。而且我觉得单单凭借几篇文章是绝对不可能真的让你完全回答好这个问题的，这里有很多原因在里面。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;首先，高并发这个话题本身是非常复杂的，远远不是一些文章可以说的清楚的，他的本质就在于，真实的支撑复杂业务场景的高并发系统架构其实是非常复杂的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;比如说每秒百万并发的中间件系统、每日百亿请求的网关系统、瞬时每秒几十万请求的秒杀大促系统、支撑几亿用户的大规模高并发电商平台架构，等等。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;为了支撑高并发请求，在系统架构的设计时，会结合具体的业务场景和特点，设计出各种复杂的架构，这需要大量底层技术支撑，需要精妙的架构和机制设计的能力。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;最终，各种复杂系统呈现出来的架构复杂度会远远超出大部分没接触过的同学的想象。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;但是那么复杂的系统架构，通过一些文章是很难说的清楚里面的各种细节以及落地生产的过程的。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;其次，高并发这话题本身包含的内容也远远不止本文说的这么几个topic：分库分表、缓存、消息。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;一个完整而复杂的高并发系统架构中，一定会包含各种复杂的自研基础架构系统、各种精妙的架构设计（比如热点缓存架构设计、多优先级高吞吐MQ架构设计、系统全链路并发性能优化设计，等等）、还有各种复杂系统组合而成的高并发架构整体技术方案、还有NoSQL（Elasticsearch等）/负载均衡/Web服务器等相关技术。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以大家切记要对技术保持敬畏之心，这些东西都很难通过一些文章来表述清楚。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;最后，真正在生产落地的时候，高并发场景下你的系统会出现大量的技术问题。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;比如说消息中间件吞吐量上不去需要优化、磁盘写压力过大性能太差、内存消耗过大容易撑爆、分库分表中间件不知道为什么丢了数据，等等吧。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;诸如此类的问题非常多，这些也不可能通过文章给全部说清楚。&lt;/p&gt;
&lt;p class=&quot;ql-align-center&quot;&gt;&lt;strong&gt;（8）本文能带给你什么启发？&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;其实本文的定位，就是对高并发这个面试topic做一个扫盲，因为我发现大部分来问我这个问题的同学，连本文阐述的最最基本的高并发架构演进思路可能都没理解。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;当然，也是因为毕竟没真的做过高并发系统，没相关经验，确实很难理解好这个问题。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;所以本文就是让很多没接触过的同学有一个初步的感知，这个高并发到底是怎么回事儿，到底对系统哪里有压力，要在系统架构里引入什么东西，才可以比较好的支撑住较高的并发压力。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;而且你可以顺着本文的思路继续思考下去，结合你自己熟悉和知道的一些技术继续思考。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;比如说，你熟悉Elasticsearch技术，那么你就可以思考，唉？在高并发的架构之下，是不是可以通过分布式架构的ES技术支撑高并发的搜索？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;上面所说，权当抛砖引玉。大家自己平时一定要多思考，自己多画图，盘点盘点自己手头系统的请求压力。计算一下分散到各个中间件层面的请求压力，到底应该如何利用最少的机器资源最好的支撑更高的并发请求。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;这才是一个好的高并发架构设计思路。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;如果起到这个效果，本文就成功了。剩下的，还是建议各位同学，对高并发这个话题，结合自己手头负责的系统多做思考。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;比如当前业务场景下，你的系统有多大的请求压力？如果请求压力增长10倍你的架构如何支撑？如果请求压力增长100倍，你的架构如何支撑？如果请求压力增长1000倍，你的架构如何支撑？&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;平时一定多给自己设置一些技术挑战，敦促自己去思考自己的系统，最好多做写架构上的演练、落地和实践，自己实际操作一下，才有更好的感知。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;然后在面试的时候，起码自己做过一定深度的思考，结合自己负责的系统做过一些实践，可以跟面试官有一个较为清晰和系统的阐述。&lt;/p&gt;
&lt;p class=&quot;ql-align-justify&quot;&gt;虽然大部分同学可能没机会经历那种真正大规模超高并发的系统架构的设计，但是本文如果能让大家平时对自己的项目多一些思考。在面试的时候，有一些系统性的思路和阐述，那么也就达到本文的目的了。&lt;/p&gt;

</description>
<pubDate>Tue, 22 Jan 2019 07:29:00 +0000</pubDate>
<dc:creator>架构师你好</dc:creator>
<og:description>（1）一道面试题的背景引入 这篇文章，我们聊聊大量同学问我的一个问题，面试的时候被问到一个让人特别手足无措的问题：你的系统如何支撑高并发？ 大多数同学被问到这个问题压根儿没什么思路去回答，不知道从什么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bokeyuan1204/p/10304128.html</dc:identifier>
</item>
<item>
<title>老代码多=过度耦合=if else？阿里巴巴工程师这样捋直老代码 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10303558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10303558.html</guid>
<description>&lt;p&gt;在业务开发的过程中，往往存在平台代码和业务代码耦合严重难以分离、业务和业务之间代码交织缺少拆解的现象。平台和业务代码交织导致不易修改，不同业务的代码交织增加了不同负责团队之间的协同成本。因此不论从代码质量，还是从团队协作的角度来看都严重地影响了开发团队之间的协同效率和开发效率，最终影响到了用户体验和业务发展。在闲鱼，商品发布和编辑功能也是如此。本文将以闲鱼商品发布和编辑功能的改造为例，向大家展示闲鱼是如何解决此类问题，从而更有效地协同更多团队更快更稳定地支撑各种业务的。&lt;/p&gt;

&lt;p&gt;为了实现上述目标，针对发布和编辑功能，进行了两轮升级。第一轮的目标在于“平台和业务分离、业务和业务隔离”；而第二轮将更进一步，目标在于“系统之间的解耦合，提升团队协同效率”。&lt;/p&gt;
&lt;h2 id=&quot;3&quot;&gt;1.平台和业务分离，业务和业务隔离&lt;/h2&gt;
&lt;p&gt;第一轮改造中，闲鱼将原先的商品发布和编辑功能从老应用中抽取到了新应用item。为了实现“平台和业务分离、业务和业务隔离”的目标，闲鱼自研了一套技术框架SWAK，具体请参考文章《业务代码解构利器--SWAK》，该文介绍了其设计思想和实现原理。接入SWAK框架后，平台逻辑和业务逻辑得到了分离，各个业务（如租房业务、免费送业务）之间的逻辑也不再耦合，而是变成package隔离（当然也是可以做成jar包隔离）。&lt;/p&gt;
&lt;p&gt;看一看改造后的应用情况示意图：&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://gw.alicdn.com/mt/TB1G59yCCzqK1RjSZFjXXblCFXa-657-496.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们根据发布和编辑的主干流程，抽象了17个SWAK扩展点。&lt;/li&gt;
&lt;li&gt;发布和编辑的主干流程主要就是对这些扩展点的编排。主干流程的编写并不需要考虑业务上怎么实现这些扩展点的。&lt;/li&gt;
&lt;li&gt;我们根据不同的业务(在SWAK里面更准确的表述是tag)对这些扩展点进行了各自的实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据这样的开发方式，我们可以把开发同学分成如下的两种角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;各业务开发人员。各业务开发人员主要是负责各个业务相关的代码。在item应用里面，业务同学需要维护其业务中和发布编辑相关的个性化业务逻辑。&lt;/li&gt;
&lt;li&gt;主干开发人员。主干的人员只需要维护主干的代码，尤其是扩展点的抽象。随着不同业务的不断接入，原先的扩展点也需要随之调整。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如在之前的《业务代码解构利器--SWAK》一文中指出的一样，经过SWAK改造后，获得了如下的几个优点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;代码逻辑清晰，可变和不可变一目了然。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;代码复用度变高。&lt;/li&gt;
&lt;li&gt;可变逻辑按照标签进行隔离，单个标签的实现不会影响到其他标签的实现，降低开发和测试成本。无论是按照“类型”分还是按照类目分，对应的开发和测试同学只需要关注对应的逻辑即可。&lt;/li&gt;
&lt;li&gt;新接手的开发人员能够快速理解，轻松上手。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;4&quot;&gt;2.系统之间的解耦合，提升团队协同效率&lt;/h2&gt;
&lt;p&gt;以租房为例——租房业务的同学需要在item应用中维护一套租房发布编辑相关的逻辑（如校验地小区数据、地铁数据真实性等）；租房业务的同学还需要在详情应用的逻辑中维护一套和租房详情相关的逻辑（如展示地图，展示内部设施标签）；租房业务的同学还需要在交易应用的逻辑中维护一套和租房交易相关的逻辑（如预约看房）等等。租房的同学不仅仅需要着手于自己的代码逻辑，还需要修改发布和编辑应用item、还需要修改详情应用，还需要修改交易应用......这种体验是非常糟糕的，有极大的可能性接手一个简单业务就需要修改和发布四五个应用。&lt;/p&gt;
&lt;p&gt;另一方面，从主干开发人员的角度来说，其应用不仅仅由自己或自己的小团队来维护，还有很多业务开发人员也在修改和发布此应用，且频率会远远超过主干开发任务的发布和部署频次（否则就是主干扩展点逻辑抽取得不好了）。这不利于整个应用的稳定性。A业务服务挂了，应该只影响A业务，而不应该影响主干。依此逻辑，最好能做到JVM隔离。本质上来说，第一轮改造完成了业务之间的解耦合，而第二轮则是系统之间的解耦合。&lt;/p&gt;
&lt;p&gt;康威定律告诉我们：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Any organization that designs a system (defined more broadly here than just information systems) will inevitably produce a design whose structure is a copy of the organization's communication structure.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之就是人员组织结构和系统结构之间的一致性。而完成系统之间的解耦合又恰恰是符合康威定律的。这一轮的改造，我们称之为“业务服务化”。&lt;/p&gt;

&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://gw.alicdn.com/mt/TB1S3SACrvpK1RjSZPiXXbmwXXa-661-500.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，我们把租房业务给单独抽取出来。原先的帖子和拍卖业务暂时没有独立的团队来予以维护（但也基本上没有什么新需求）因此暂时仍然放在主干应用中，时机合适将会和租房应用一样迁移出去。&lt;/li&gt;
&lt;li&gt;其次，租房业务通过远程服务的方式给主干应用提供服务。接口即是主干业务的提供的扩展点。由于现在是优先使用远程服务来连接主干应用和垂直应用，考虑到性能问题和安全问题，我们在扩展点的定义上也做了一些特殊的改动，后文会有针对性的详述。&lt;/li&gt;
&lt;li&gt;最后，SWAK框架做了一些改变以注册和调用远程服务。相对于本地服务，远程服务一般都是有超时、连接异常等问题。然而不同接口对于这些异常情况其处理策略也是截然不同的，后文“SWAK框架的针对性改进”会详述这些改动。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过这种方式，我们将主干应用和各业务应用彻底分离了。仍然以租房业务为例，租房团队负责开发和维护租房业务的独立应用rent。租房个性化的发布和编辑需求只需要开发和部署rent应用，而不必修改主干应用。主干应用只由主干团队的同学负责维护，不会被其他业务团队的同学所开发和部署，稳定性更加能得以保障。各业务系统独立开发、独立部署。这些都大幅地减少了不必要的沟通成本、提升协同效率。&lt;/p&gt;
&lt;p&gt;主干应用和业务应用是通过薄薄的一层接口所联系起来的，这层薄薄的接口都是“声明”：Interface定义、DO的定义和扩展点的默认Reduce策略定义。&lt;/p&gt;
&lt;h2 id=&quot;6&quot;&gt;SWAK框架的针对性改进&lt;/h2&gt;
&lt;p&gt;在之前的《业务代码解构利器--SWAK》一文中指出了，SWAK框架在应用启动的时候会通过各种注册器(registery)注册框架所需的信息。其中最重要的信息就是——业务tag及其对应的SWAK接口的实现类类名或者类实例instance。大多RPC框架都会在client端提供一个代理，代理掉内部的服务发现、保活、序列化、网络通信、反序列化等一系列操作。实际上，SWAK为了支持远程服务调用，只需要将业务tag，以及这些RPC的client的instance的对应关系注册进去就可以了。在闲鱼，RPC使用的是阿里通用的HSF框架(其类似的一个开源框架是Dubbo)，这里的RPC的client就是HSF中的ConsumerBean。&lt;/p&gt;
&lt;p&gt;上文还提到了RPC调用会引入服务超时、连接异常的概念。为何要限制超时？是因为不能被单个应用的超时占据了主干应用的服务资源而引起其他服务和整个应用系统受到影响（如大多数线程阻塞在超时调用上）。无论是超时异常还是连接异常，在业务上也有对应的处理策略。在这里，我们定义了三种异常处理策略，通过在配置上设置相应的注解，SWAK框架会自动按照策略来处理异常。这三种策略是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IGNORE。 即，直接向上层抛出异常。&lt;/li&gt;
&lt;li&gt;SKIP。对于一个接口有多个tag执行的时候，本tag下该扩展点将跳过，继续执行其他tag下该扩展点的实现。&lt;/li&gt;
&lt;li&gt;DEFAULT_VALUE。返回默认值。默认值通过spel表达式进行设置。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;7&quot;&gt;减少扩展点数量&lt;/h2&gt;
&lt;p&gt;众所周知，RPC调用相对于本地调用会增加一部分的网络传输和序列化开销。对于单次调用来说，增加若干ms并没有什么问题，但对于调用10次、20次或更多，这笔开销就相当可观而应该引起重视了。为此，如何降低RPC开销，是一个必须要考虑的问题。&lt;/p&gt;
&lt;p&gt;最可靠的方法就是降低RPC的次数。&lt;/p&gt;
&lt;p&gt;在实践中我们发现，很多扩展点实际上都是获取业务配置。如在闲鱼业务中，“是否支持多库存”就是一种配置，如租房不支持多库存。这些业务配置项是由其业务形态所决定的，基本不会变动。因此可以将一组配置项打包一起调用，并且可以缓存下来，也可以直接由主干应用进行维护。在item应用里，这些配置项关系到主干的通用存储过程，目前由各业务方委托主干开发人员进行维护，目前配置在主干环境。可以通过阿里的动态配置平台（如Switch、Diamond）进行动态修改。&lt;/p&gt;
&lt;p&gt;另外我们对部分邻接的扩展点进行了合并。这些相邻扩展点之间的逻辑比较简单，且不会中断主流程。通过“配置型接口”和“邻接扩展点合并”这两种操作，我们将扩展点数量降低由17个降低到了6个。要注意的是，扩展点并不是越少越好。扩展点越少，越意味着“过度拟合”，可能会对后续业务变更无法适应导致主干需要大幅改动，因此需要在数量和扩展性之间找到一个平衡。&lt;/p&gt;
&lt;p&gt;另外值得一提的是，SWAK为配置型扩展点做了相应的小改造，并提供了查看当前配置型扩展点返回值的可视化界面。开发人员可以直观地了解当前各个业务的配置值。&lt;/p&gt;
&lt;h2 id=&quot;8&quot;&gt;接口对象定义和细节设计&lt;/h2&gt;
&lt;p&gt;在闲鱼，各种业务所需要存储的东西大同小异，从闲鱼的发布界面上来看就不难发现这一点，都是在基础对象（如标题、描述、图片）之外添加一些业务相关的数据，如拍卖业务中指定拍卖的开拍时间等信息，免费送业务中设置兑换币值，图书业务上设置条形码。即对一本图书进行拍卖当然也是允许的，这就出现了拍卖业务和图书业务叠加起来的复合型业务。&lt;br/&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://gw.alicdn.com/mt/TB1EimACAvoK1RjSZFNXXcxMVXa-756-459.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于主干应用开发人员来说，应该提供单个接口以支持所有业务类型，这样不用每次修改或者新增业务时都需要提供新接口。从稳定性的角度考虑，这样的要求很合理。既然是单个接口，那么DO的定义也应该统一。以商品DO为例，有以下三种方式：&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://gw.alicdn.com/mt/TB1npqrCzDpK1RjSZFrXXa78VXa-935-229.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一种是继承型结构，该结构不适用于业务叠加的情况。另外主干需要知晓各个业务的DO，每次业务修改或新增，主干都需要做变动。&lt;/li&gt;
&lt;li&gt;第二种是组合型结构，适用于业务叠加的情况，但同上一种一样，主干需要知晓各个业务的DO，每次业务修改或新增，主干也需要随之变动。&lt;/li&gt;
&lt;li&gt;第三种使用了Map类型类承载各个业务（biz）的定义类型。主干完全不知道、也不需要知道各个业务DO是如何组成的。这种方式具有最好的扩展性（有点无边界的扩展），也分离了主干应用和业务应用，最接近主干和业务分离的期望。最终我们选择了这一种。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用第三种的对象模型，以新加一种业务为例，其开发流程是：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;image.png&quot; src=&quot;http://gw.alicdn.com/mt/TB1gUeyCxTpK1RjSZFKXXa2wXXa-742-253.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新业务服务端开发人员和客户端开发人员约定各业务的DO，这些DO会存储到bizMap字段。主干应用开发人员不需要了解这些约定。&lt;/li&gt;
&lt;li&gt;主干应用新增一份新业务的配置，实际上是新业务的识别信息和路由信息。&lt;/li&gt;
&lt;li&gt;新业务应用实现主干扩展点。&lt;/li&gt;
&lt;li&gt;联调、测试和上线。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;业务应用在扩展点返回值中设置需要更新的数据，由主干应用合并。业务应用不应该也不可以直接修改ItemDO，避免影响其他业务的处理逻辑。对于发布和编辑这种需要持久化存储的逻辑来说，必须要强控各业务对ItemDO的修改，否则理论上来说，各业务都有可能将所有的关键字段修改得面目全非。前面提到的“配置型接口”中，就有这样的配置——该业务是否可以修改属性字段、该业务是否可以修改描述字段等配置。&lt;/p&gt;

&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont687947.i1.70aa5b83tdoCbJ&quot;&gt;闲鱼的商品发布和编辑功能基于SWAK框架经过了两次改造升级，第一次升级完成了平台和业务之间的解耦合以及业务和业务之间的解耦合，第二次升级通过平台和业务间使用RPC调用完成了系统和系统之间的解耦合。改造之后，能更有效地协同更多团队更快更稳定地支撑各种业务。SWAK框架依然在继续演进，如部分扩展点原则上可以通过并行处理或异步化处理来提升性能，但暂时还没有提供支持。在这两次改造中， 我们还在测试用例的采集、回放、监控告警等方面也有很多积累，敬请期待后续的文章分享。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/687947?utm_content=g_1000039106&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 06:15:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>简介 在业务开发的过程中，往往存在平台代码和业务代码耦合严重难以分离、业务和业务之间代码交织缺少拆解的现象。平台和业务代码交织导致不易修改，不同业务的代码交织增加了不同负责团队之间的协同成本。因此不论</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10303558.html</dc:identifier>
</item>
<item>
<title>kubernetes系列03—kubeadm安装部署K8S集群 - alonghub</title>
<link>http://www.cnblogs.com/along21/p/10303495.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/along21/p/10303495.html</guid>
<description>&lt;p&gt;&lt;strong&gt;本文收录在&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/along21/p/8116905.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;容器技术学习系列文章总目录&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1、kubernetes安装介绍&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1.1 K8S&lt;span&gt;架构图&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190122135625447-2103399272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.2 K8S&lt;span&gt;搭建安装示意图&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1216496/201901/1216496-20190122135639452-1334832384.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;1.3 &lt;span&gt;安装&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h5&gt;&lt;strong&gt;1.3.1 &lt;span&gt;方法&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;：使用&lt;/span&gt;&lt;span&gt;kubeadm&lt;/span&gt; &lt;span&gt;安装&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;（本文演示的就是此方法）&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt; &lt;span&gt;优点：你只要安装&lt;/span&gt;kubeadm&lt;span&gt;即可；&lt;/span&gt;&lt;strong&gt;kubeadm&lt;span&gt;会帮你自动部署安装&lt;/span&gt;&lt;span&gt;K8S&lt;/span&gt;&lt;span&gt;集群&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;；如：初始化&lt;/span&gt;K8S&lt;span&gt;集群、配置各个插件的证书认证、部署集群网络等。安装简易。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;缺点：不是自己一步一步安装，可能对&lt;/span&gt;K8S&lt;span&gt;的理解不会那么深；并且有那一部分有问题，自己不好修正。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;&lt;strong&gt;1.3.2 &lt;span&gt;方法&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;：二进制安装部署&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;（详见下篇&lt;a href=&quot;https://www.cnblogs.com/along21/p/10044931.html&quot; target=&quot;_blank&quot;&gt;kubernetes系列04—二进制安装部署kubernetes集群&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt; &lt;span&gt;优点：&lt;/span&gt;&lt;strong&gt;K8S&lt;span&gt;集群所有东西，都由自己一手安装搭建&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;；清晰明了，更加深刻细节的掌握&lt;/span&gt;K8S&lt;span&gt;；哪里出错便于快速查找验证。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;span&gt;缺点：安装较为繁琐麻烦，且易于出错。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;strong&gt;2&lt;span&gt;、安装&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;先决条件&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h4&gt;&lt;strong&gt;2.1 &lt;span&gt;组件版本&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt; docker 17.03.2&lt;/li&gt;
&lt;li&gt; kubeadm 1.11.1&lt;/li&gt;
&lt;li&gt; kubelet 1.11.1&lt;/li&gt;
&lt;li&gt; kubectl 1.11.1&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;2.2 &lt;span&gt;集群机器&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt; kube-master&lt;span&gt;：&lt;/span&gt;&lt;span&gt;192.168.10.103&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; kube-node1&lt;span&gt;：&lt;/span&gt;&lt;span&gt;192.168.10.104&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; kube-node2&lt;span&gt;：&lt;/span&gt;&lt;span&gt;192.168.10.105&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;2.3 &lt;span&gt;主机名&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1&lt;span&gt;、设置永久主机名称，然后重新登录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ sudo hostnamectl set-hostname master
$ sudo hostnamectl set-hostname node1 
$ sudo hostnamectl set-hostname node2 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2&lt;span&gt;、修改&lt;/span&gt; &lt;span&gt;/etc/hostname  &lt;/span&gt;&lt;span&gt;文件，添加主机名和&lt;/span&gt; &lt;span&gt;IP&lt;/span&gt; &lt;span&gt;的对应关系：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ vim /etc/hosts
192.168.10.103 master
192.168.10.104 node1
192.168.10.105 node2
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;2.4 &lt;span&gt;同步系统时间&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ yum -y install ntpdate
$ sudo ntpdate cn.pool.ntp.org
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;2.5 &lt;span&gt;关闭防火墙&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在每台机器上关闭防火墙：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① &lt;span&gt;关闭服务，并设为开机不自启&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ sudo systemctl stop firewalld
$ sudo systemctl disable firewalld
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② &lt;span&gt;清空防火墙规则&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ sudo iptables -F &amp;amp;&amp;amp; sudo iptables -X &amp;amp;&amp;amp; sudo iptables -F -t nat &amp;amp;&amp;amp; sudo iptables -X -t nat
$ sudo iptables -P FORWARD ACCEPT
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;2.6 &lt;span&gt;关闭&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt; &lt;span&gt;分区&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1&lt;span&gt;、如果开启了&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt; &lt;span&gt;分区，&lt;/span&gt;&lt;span&gt;kubelet&lt;/span&gt; &lt;span&gt;会启动失败&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;可以通过将参数&lt;/span&gt; &lt;span&gt;--fail-swap-on&lt;/span&gt; &lt;span&gt;设置为&lt;/span&gt;&lt;span&gt;false&lt;/span&gt; &lt;span&gt;来忽略&lt;/span&gt; &lt;span&gt;swap on)&lt;/span&gt;&lt;span&gt;，故需要在每台机器上关闭&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt; &lt;span&gt;分区：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ sudo swapoff -a
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2&lt;span&gt;、为了防止开机自动挂载&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt; &lt;span&gt;分区，可以注释  &lt;/span&gt;&lt;span&gt;/etc/fstab  &lt;/span&gt;&lt;span&gt;中相应的条目：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ sudo sed -i '/ swap / s/^\(.*\)$/#\1/g' /etc/fstab
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;2.7 &lt;span&gt;关闭&lt;/span&gt; &lt;span&gt;SELinux&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1&lt;span&gt;、关闭&lt;/span&gt; &lt;span&gt;SELinux&lt;/span&gt;&lt;span&gt;，否则后续&lt;/span&gt; &lt;span&gt;K8S&lt;/span&gt; &lt;span&gt;挂载目录时可能报错  &lt;/span&gt;&lt;span&gt;Permission denied  &lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ sudo setenforce 0
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2&lt;span&gt;、修改配置文件，永久生效；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ vim /etc/selinux/config
SELINUX=disabled
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;3&lt;span&gt;、使用&lt;/span&gt;&lt;span&gt;kubeadm&lt;/span&gt;&lt;span&gt;安装&lt;/span&gt;&lt;span&gt;K8S&lt;/span&gt;&lt;span&gt;集群&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;3.1 &lt;span&gt;认识&lt;/span&gt;&lt;span&gt;kubeadm&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;以下操作在&lt;/span&gt;3&lt;span&gt;个服务器上，都要执行！&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3.2 &lt;span&gt;配置安装源&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.2.1 &lt;span&gt;配置&lt;/span&gt;&lt;span&gt;docker-ce &lt;/span&gt;&lt;span&gt;源信息&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）添加&lt;/span&gt;&lt;span&gt;docker-ce &lt;/span&gt;&lt;span&gt;源信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# wget -O /etc/yum.repos.d/docker-ce.repo https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）修改&lt;/span&gt;&lt;span&gt;docker-ce &lt;/span&gt;&lt;span&gt;源&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# sed -i 's@download.docker.com@mirrors.tuna.tsinghua.edu.cn/docker-ce@g' /etc/yum.repos.d/docker-ce.repo
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.2.2 &lt;span&gt;配置&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;仓库&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node2 ~]# cd /etc/yum.repos.d/
[root@master yum.repos.d]# vim kubernetes.repo
[kubernetes]
name=Kubernetes Repo
baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/
gpgcheck=0
enable=1
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.2.3 &lt;span&gt;更新&lt;/span&gt;&lt;span&gt;yum&lt;/span&gt;&lt;span&gt;仓库&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master yum.repos.d]# yum clean all
[root@master yum.repos.d]# yum repolist 
repo id                                         repo name                                                               status
base                                            base                                                                            9,363
docker-ce-stable/x86_64         Docker CE Stable - x86_64                                     20
epel/x86_64                             Extra Packages for Enterprise Linux 7 - x86_64          12,663
kubernetes                              Kubernetes Repo                                                 246
repolist: 22,292
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.3 &lt;span&gt;安装&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;kubelet&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;kubeadm&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;kubectl&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt; kubelet&lt;span&gt;：&lt;/span&gt;&lt;span&gt;负责管理&lt;/span&gt;pods&lt;span&gt;和它们上面的容器，&lt;/span&gt;&lt;span&gt;维护容器的生命周期&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; kubeadm&lt;span&gt;：安装&lt;/span&gt;&lt;span&gt;K8S&lt;/span&gt;&lt;span&gt;工具&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; kubectl&lt;span&gt;：&lt;/span&gt;&lt;span&gt;K8S&lt;/span&gt;&lt;span&gt;命令行工具&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）安装&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# yum -y install docker-ce-17.03.2.ce   下载稳定版本17.03.2
[root@master ~]# yum -y install kubeadm-1.11.1 kubelet-1.11.1 kubectl-1.11.1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）安装&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;报错（虚拟机中可能会遇到，如果没有报错请忽略）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Error:&lt;/strong&gt; Package: docker-ce-18.03.1.ce-1.el7.centos.x86_64 (docker-ce-stable)&lt;/p&gt;
&lt;p&gt;           Requires: container-selinux &amp;gt;= 2.9&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;报错原因：&lt;/span&gt;&lt;/strong&gt; docker-ce-selinux &lt;span&gt;版本过低&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;解决办法：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在&lt;/span&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/7/x86_64/stable/Packages/&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/7/x86_64/stable/Packages/&lt;/a&gt;&lt;span&gt;网站下载对应版本的&lt;/span&gt;docker-ce-selinux&lt;span&gt;，安装即可&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# yum -y install https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/7/x86_64/stable/Packages/docker-ce-selinux-17.03.3.ce-1.el7.noarch.rpm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;再次安装&lt;/span&gt;docker &lt;span&gt;成功：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# yum -y install docker-ce-17.03.2.ce
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;3.4 &lt;span&gt;启动服务&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;3.4.1 &lt;span&gt;配置启动&lt;/span&gt;&lt;span&gt;docker&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）添加加速器到配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# mkdir -p /etc/docker
[root@master ~]# tee /etc/docker/daemon.json &amp;lt;&amp;lt;-'EOF'
{
  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
}
EOF
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）启动服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# systemctl daemon-reload
[root@master ~]# systemctl start docker
[root@master ~]# systemctl enable docker.service
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）打开&lt;/span&gt;&lt;span&gt;iptables&lt;/span&gt;&lt;span&gt;内生的桥接相关功能，已经默认开启了，没开启的自行开启&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# cat /proc/sys/net/bridge/bridge-nf-call-ip6tables
1
[root@node1 ~]# cat /proc/sys/net/bridge/bridge-nf-call-iptables
1
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;3.4.2 &lt;span&gt;配置启动&lt;/span&gt;&lt;span&gt;kubelet&lt;/span&gt;&lt;span&gt;服务&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）修改配置文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# vim /etc/sysconfig/kubelet
KUBELET_EXTRA_ARGS=&quot;--fail-swap-on=false&quot;
KUBE_PROXY=MODE=ipvs
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）先设为开机自启&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# systemctl enable kubelet.service
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为&lt;/span&gt;K8S&lt;span&gt;集群还未初始化，所以&lt;/span&gt;&lt;span&gt;kubelet&lt;/span&gt; &lt;span&gt;服务启动不成功，下面初始化完成，再启动即可。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;4&lt;span&gt;、初始化&lt;/span&gt;&lt;span&gt;kubernetes master&lt;/span&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;master&lt;span&gt;服务器上执行，完成以下所有操作&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;4.1 &lt;span&gt;使用&lt;/span&gt;&lt;span&gt;kubeadm init&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）使用&lt;/span&gt;&lt;span&gt;kubeadm init&lt;/span&gt; &lt;span&gt;进行初始化（需要进行很多操作，所以要等待一段时间）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubeadm init --kubernetes-version=v1.11.1 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --ignore-preflight-errors=Swap
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;释：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; &lt;strong&gt;--kubernetes-version&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;指定&lt;/span&gt;&lt;span&gt;kubeadm&lt;/span&gt;&lt;span&gt;版本；我这里下载的时候&lt;/span&gt;&lt;span&gt;kubeadm&lt;/span&gt;&lt;span&gt;最高时&lt;/span&gt;&lt;span&gt;1.11.1&lt;/span&gt;&lt;span&gt;版本&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;--pod-network-cidr&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;指定&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;span&gt;所属网络&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;--service-cidr&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;指定&lt;/span&gt;&lt;span&gt;service&lt;/span&gt;&lt;span&gt;网段&lt;/span&gt;&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;--ignore-preflight-errors=Swap/all&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;忽略&lt;/span&gt; &lt;span&gt;swap/&lt;/span&gt;&lt;span&gt;所有 报错&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为&lt;/span&gt;kubeadm&lt;span&gt;需要拉取必要的镜像，这些镜像需要&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;科学上网&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;；所以可以先在&lt;/span&gt;&lt;span&gt;docker hub&lt;/span&gt;&lt;span&gt;或其他镜像仓库拉取&lt;/span&gt;&lt;span&gt;kube-proxy&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;kube-scheduler&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;kube-apiserver&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;kube-controller-manager&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;etcd&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;pause&lt;/span&gt;&lt;span&gt;镜像；并加上&lt;/span&gt; &lt;strong&gt;--ignore-preflight-errors=all&lt;/strong&gt; &lt;span&gt;忽略所有报错即可&lt;/span&gt;&lt;strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）下载镜像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我已经将我下载的镜像导出，放入我的&lt;a href=&quot;https://pan.baidu.com/s/1Nxukl8xmNMyMQF9nvjeGmQ&quot; target=&quot;_blank&quot;&gt;网盘&lt;/a&gt;，有需要的打赏一杯咖啡钱，私聊博主；博主会很快恢复的；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# docker image load -i kube-apiserver-amd64.tar.gz
[root@master ~]# docker image load -i kube-proxy-amd64.tar.gz
[root@master ~]# docker image load -i kube-controller-manager-amd64.tar.gz
[root@master ~]# docker image load -i kube-scheduler-amd64.tar.gz
[root@master ~]# docker image load -i etcd-amd64.tar.gz
[root@master ~]# docker image load -i pause.tar.gz
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）初始化命令成功后，创建&lt;/span&gt;&lt;span&gt;.kube&lt;/span&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# mkdir -p $HOME/.kube
[root@master ~]# cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;4.2 &lt;span&gt;验证&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）拉取了必须的镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# docker image ls
REPOSITORY                                          TAG                 IMAGE ID            CREATED             SIZE
k8s.gcr.io/kube-proxy-amd64                         v1.11.1             d5c25579d0ff        6 months ago        97.8 MB
k8s.gcr.io/kube-scheduler-amd64                     v1.11.1             272b3a60cd68        6 months ago        56.8 MB
k8s.gcr.io/kube-apiserver-amd64                     v1.11.1             816332bd9d11        6 months ago        187 MB
k8s.gcr.io/kube-controller-manager-amd64            v1.11.1             52096ee87d0e        6 months ago        155 MB
k8s.gcr.io/etcd-amd64                               3.2.18              b8df3b177be2        9 months ago        219 MB
k8s.gcr.io/pause                                    3.1                 da86e6ba6ca1        13 months ago       742 kB
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）开启了&lt;/span&gt;&lt;span&gt;kube-apiserver&lt;/span&gt; &lt;span&gt;的&lt;/span&gt;&lt;span&gt;6443&lt;/span&gt;&lt;span&gt;端口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# ss -nutlp
tcp   LISTEN     0      128                   :::6443                              :::*                   users:((&quot;kube-apiserver&quot;,pid=1609,fd=3))
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）使用&lt;/span&gt;&lt;span&gt;kubectl&lt;/span&gt;&lt;span&gt;命令查询集群信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查询组件状态信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get cs
NAME                 STATUS    MESSAGE              ERROR
controller-manager   Healthy   ok                   
scheduler            Healthy   ok                   
etcd-0               Healthy   {&quot;health&quot;: &quot;true&quot;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查询集群节点信息（因为还没有部署好&lt;/span&gt;flannel&lt;span&gt;，所以节点显示为&lt;/span&gt;&lt;span&gt;NotReady&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get nodes
NAME      STATUS    ROLES     AGE       VERSION
master    NotReady  master    13m       v1.11.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;查询名称空间，默认&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get ns
NAME            STATUS    AGE
default         Active    13m
kube-public     Active    13m
kube-system     Active    13m
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;4.3 &lt;span&gt;部署网络插件&lt;/span&gt;&lt;span&gt;flannel&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）直接使用&lt;/span&gt;&lt;span&gt;kubectl&lt;/span&gt; &lt;span&gt;执行&lt;/span&gt;&lt;span&gt;gitlab&lt;/span&gt;&lt;span&gt;上的&lt;/span&gt;&lt;span&gt;flannel&lt;/span&gt; &lt;span&gt;部署文件&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml
clusterrole.rbac.authorization.k8s.io/flannel created
clusterrolebinding.rbac.authorization.k8s.io/flannel created
serviceaccount/flannel created
configmap/kube-flannel-cfg created
daemonset.extensions/kube-flannel-ds-amd64 created
daemonset.extensions/kube-flannel-ds-arm64 created
daemonset.extensions/kube-flannel-ds-arm created
daemonset.extensions/kube-flannel-ds-ppc64le created
daemonset.extensions/kube-flannel-ds-s390x created
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）会看到下载好的&lt;/span&gt;&lt;span&gt;flannel&lt;/span&gt; &lt;span&gt;的镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# docker image ls |grep flannel
quay.io/coreos/flannel                              v0.10.0-amd64       f0fad859c909        12 months ago       44.6 MB
quay.io/coreos/flannel                              v0.9.1              2b736d06ca4c        14 months ago       51.3 MB
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）验证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;① master &lt;span&gt;节点已经&lt;/span&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get nodes
NAME      STATUS    ROLES     AGE       VERSION
master    Ready     master    14m       v1.11.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② &lt;span&gt;查询&lt;/span&gt;&lt;span&gt;kube-system&lt;/span&gt;&lt;span&gt;名称空间下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get pods -n kube-system(指定名称空间) |grep flannel
NAME                             READY     STATUS    RESTARTS   AGE
kube-flannel-ds-amd64-4wck2      1/1       Running   0          1m
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;5&lt;span&gt;、初始化&lt;/span&gt;&lt;span&gt;kubernetes node&lt;/span&gt;&lt;span&gt;节点&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在&lt;/span&gt;2&lt;span&gt;个&lt;/span&gt;&lt;span&gt;node&lt;/span&gt; &lt;span&gt;服务器上执行，完成以下所有操作&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.1 &lt;span&gt;使用&lt;/span&gt;&lt;span&gt;kubeadm join&lt;/span&gt; &lt;span&gt;初始化&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）初始化&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;节点；下边的命令是&lt;/span&gt;&lt;span&gt;master&lt;/span&gt;&lt;span&gt;初始化完成后，下边有提示的操作命令&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# kubeadm join 192.168.10.103:6443 --token t56pjr.cm898tj09xm9pkqz --discovery-token-ca-cert-hash sha256:3ffe1c840e8a4b334fc2cc3d976b0e3635410e52e3653bb39585b8b557f81bc4 --ignore-preflight-errors=Swap
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）从节点如果不能&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;科学上网&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，只需从本地上传&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;个镜像即可；还是我网盘中的镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# docker image load -i kube-proxy-amd64.tar.gz
[root@node1 ~]# docker image load -i pause.tar.gz
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;strong&gt;5.2 &lt;span&gt;验证集群是否初始化成功&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）查询&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;个节点的镜像&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# docker image ls   
REPOSITORY                    TAG                 IMAGE ID            CREATED             SIZE
k8s.gcr.io/kube-proxy-amd64   v1.11.1             d5c25579d0ff        6 weeks ago         97.8 MB
quay.io/coreos/flannel        v0.10.0-amd64       f0fad859c909        7 months ago        44.6 MB
k8s.gcr.io/pause              3.1                 da86e6ba6ca1        8 months ago        742 kB
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）等&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;个从节点上下载好镜像，初始化完成，再在主上查询验证&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get nodes
NAME      STATUS    ROLES     AGE       VERSION
master    Ready     master    28m       v1.11.1
node1     Ready     &amp;lt;none&amp;gt;    7m        v1.11.1
node2     Ready     &amp;lt;none&amp;gt;    2m        v1.11.1
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）在主节点查询&lt;/span&gt;&lt;span&gt;kube-system&lt;/span&gt;&lt;span&gt;名称空间下关于&lt;/span&gt;&lt;span&gt;node&lt;/span&gt;&lt;span&gt;节点&lt;/span&gt;&lt;span&gt;pod&lt;/span&gt;&lt;span&gt;的信息&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master ~]# kubectl get pods -n kube-system -o wide |grep node
kube-flannel-ds-amd64-fcm9x             1/1       Running   15         91d       192.168.130.105   node2
kube-flannel-ds-amd64-hzkp7             1/1       Running   17         91d       192.168.130.104   node1
kube-proxy-f2kkn                        1/1       Running   34         139d      192.168.130.104   node1
kube-proxy-kkqln                        1/1       Running   35         139d      192.168.130.105   node2
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　至此，&lt;/span&gt;kubernetes&lt;span&gt;集群已经搭建安装完成；&lt;/span&gt;&lt;span&gt;kubeadm&lt;/span&gt;&lt;span&gt;帮助我们在后台完成了所有操作；想要自己全部手动搭建&lt;/span&gt;&lt;span&gt;kubernetes&lt;/span&gt;&lt;span&gt;集群；详解下篇&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/along21/p/10044931.html&quot;&gt;&lt;span&gt;二进制安装部署&lt;/span&gt;kubernetes&lt;span&gt;集群&lt;/span&gt;&lt;span&gt;---&lt;/span&gt;&lt;span&gt;超详细教程&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 22 Jan 2019 06:12:00 +0000</pubDate>
<dc:creator>alonghub</dc:creator>
<og:description>本文收录在容器技术学习系列文章总目录 1、kubernetes安装介绍 1.1 K8S架构图 1.2 K8S搭建安装示意图 1.3 安装kubernetes方法 优点：你只要安装kubeadm即可；k</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/along21/p/10303495.html</dc:identifier>
</item>
<item>
<title>跟你们想的不一样95后 - 56899◎か</title>
<link>http://www.cnblogs.com/qy1234/p/10303473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qy1234/p/10303473.html</guid>
<description>&lt;p&gt;   &lt;span&gt;       前一段，网上也流传这样一句的话，不要大声责骂95后，他们会立刻辞职的。现在提到95后辞职，都用&lt;strong&gt;秒辞&lt;/strong&gt;来形容。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992081/201901/992081-20190122133637220-1584301185.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           其实，95后的世界和你们想象中真的是大不一样，敢闯敢拼敢梦，敢做自己。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           我身边就有这样例子，我的大学同学兼前同事的荣姐，她就是敢闯敢拼敢梦的人，我们实习时候，分配到一个北京的公司，总共有5个人同学，先前走2人，留下3人，因为小公司压力大，太苦了，然后年后我也走了，只留下她，男朋友二人，之后我们偶尔会联系，诉说工作的烦恼。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          前段时间，荣姐，找到我说，她想哭，觉得很委屈，因为她们公司接到一个医疗项目300万，只有她和她男朋友做，项目验收成功后，给她们两个才分3万；她说这个医院的系统，从需求分析，开发，培训，实施，维护，都是她亲力亲为的，国庆节前项目都培训完了，结果开了个会，说要重头做，底层架构全部变了，大哭了一场，不想干了，但是老板三个就劝她说有付出绝对会给她回报，所以她相信了，也坚持了，抬起头卖力的干活，克服了那么多困难，无数遍说服自己坚持，她男友想走她拦下来，就是相信他们不会亏待她们，会分块肉给他们，累死累活熬了这么长时间，到头来换来这样的结果，在这待着完全是这两年多的情义，心里很凉；我让她跟老板谈一谈，把话说清楚，不行，则换份工作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         最近跟她闲聊起，问她工作怎么样了，她告诉我，她跟老板的提成谈完了，最后谈的结果是一人5万，工资涨2000，以后每上一家，按照比例提成，19年底每个人百分之十的股份，我问合同签吗，她说签了，很好奇地问她是如何谈判的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;面谈的过程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一回合：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992081/201901/992081-20190122133734623-711539290.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二回合：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992081/201901/992081-20190122133743283-625028156.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三回合：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992081/201901/992081-20190122133751666-799295932.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四回合：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992081/201901/992081-20190122133757969-2065492170.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我告诉她当心，老板会招新人培训，到时候抛弃你们，她却说不会，分析一下原因：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/992081/201901/992081-20190122133825957-110652099.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992081/201901/992081-20190122133833853-1193207580.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;            &lt;span&gt;其实我还挺佩服她的，她是我见为女生最有主见，有思想的，对自己的定位很准确，有很多事情她都敢想敢做，而且沟通能力也很强的人；我的朋友跟我开玩笑说，如果我之前不放弃开发，或许会跟她一样；我却告诉他说，我不后悔，因为我正是有了之前的经历，才让我慢慢变得成熟起来，而是一种磨炼，其实这都是一个过程，有的人需要通过走很多弯路，到达了终点，走向成功；而有的人是通过直路一直走下去，走向成功，每个人的人生都不同，不管是弯路，还是直路，只要我们踏踏实实的,走好自己脚下的每一步路,弯路直路都是无所谓的，,重要的是最终达到了自己想要到达的地方。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 06:01:00 +0000</pubDate>
<dc:creator>56899◎か</dc:creator>
<og:description>前一段，网上也流传这样一句的话，不要大声责骂95后，他们会立刻辞职的。现在提到95后辞职，都用秒辞来形容。 其实，95后的世界和你们想象中真的是大不一样，敢闯敢拼敢梦，敢做自己。 我身边就有这样例子，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qy1234/p/10303473.html</dc:identifier>
</item>
<item>
<title>MVVM框架在unity开发中的使用 - 禹泽鹏鹏</title>
<link>http://www.cnblogs.com/IAMTOM/p/10303392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IAMTOM/p/10303392.html</guid>
<description>&lt;h2 id=&quot;3367-1548050114747&quot;&gt;1、什么是MVVM&lt;/h2&gt;
&lt;p&gt;借用一下百度百科上对MVVM的介绍，MVVM是Model-View-ViewModel的简写，它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。&lt;/p&gt;

&lt;h2 id=&quot;3081-1548050513812&quot;&gt;2、MVVM在unity开发中的应用&lt;/h2&gt;
&lt;p&gt;MVVM框架应用面十分广泛，通常在前端开发中应用很广，最近看到周围同事在开发WPF时用到了这个框架，抱着好奇的态度来学习一下这个框架，MVVM框架在unity开发中同样适用，在unity中，将每个UI抽象成一个个View，通常我们为每一个UI面板定义一个View，View中包含了该面板中涉及到的UI元素，比如一个Text,一个Button；每一个View都有独立的ViewModel来管理，ViewModel中提供必要的属性和方法来控制View， 而Model只是单纯的定义一个数据模型。前两天在github上发现了这个叫uMVVM的框架，拿来试用了一下，下面分析一下该框架对MVVM模式的设计。&lt;/p&gt;

&lt;h2 id=&quot;7212-1548127253323&quot;&gt;3、uMVVM的设计与实现&lt;/h2&gt;
&lt;p&gt;下载uMVVM后，它提供了一些使用示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1305026/201901/1305026-20190122134334900-2115261493.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个示例中，有两个panel，就定义了两个view，每个view中定义该界面的元素，比如SetupView：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SetupView:UnityGuiView&amp;lt;SetupViewModel&amp;gt;&lt;span&gt;
    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InputField nameInputField;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Text nameMessageText;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InputField jobInputField;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Text jobMessageText;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; InputField atkInputField;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Text atkMessageText;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Slider successRateSlider;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Text successRateMessageText;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Toggle joinToggle;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Button joinInButton;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Button waitButton;
        
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; SetupViewModel ViewModel { &lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (SetupViewModel)BindingContext; } }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，View中需要指定对应的ViewModel来管理该View，ViewModel中定义的属性需要具备当数据改变时通知订阅者的功能，因此uMVVM对这种属性进行了一层封装，具体设计如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BindableProperty&amp;lt;T&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ValueChangedHandler(T oldValue, T newValue);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ValueChangedHandler OnValueChanged;

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; T _value;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T Value
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _value;
            }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Equals(_value, value))
                {
                    T old &lt;/span&gt;=&lt;span&gt; _value;
                    _value &lt;/span&gt;=&lt;span&gt; value;
                    ValueChanged(old, _value);
                }
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ValueChanged(T oldValue, T newValue)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (OnValueChanged != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                OnValueChanged(oldValue, newValue);
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Value != &lt;span&gt;null&lt;/span&gt; ? Value.ToString() : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，BindableProperty类中维护一个T类型数据，当T发生变化时，可以通知到订阅者，有了这种属性之后，那么ViewModel就是这样的了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SetupViewModel:ViewModelBase
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; BindableProperty&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Name = &lt;span&gt;new&lt;/span&gt; BindableProperty&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; BindableProperty&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt; Job=&lt;span&gt;new&lt;/span&gt; BindableProperty&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(); 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; BindableProperty&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; ATK = &lt;span&gt;new&lt;/span&gt; BindableProperty&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; BindableProperty&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt; SuccessRate=&lt;span&gt;new&lt;/span&gt; BindableProperty&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;&lt;span&gt;(); 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; BindableProperty&amp;lt;State&amp;gt; State=&lt;span&gt;new&lt;/span&gt; BindableProperty&amp;lt;State&amp;gt;&lt;span&gt;();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;uMVVM的设计中，每个View都继承UnityGuiView这个泛型类，UnityGuiView大概的内容是这样：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UnityGuiView&amp;lt;T&amp;gt;:MonoBehaviour,IView&amp;lt;T&amp;gt; &lt;span&gt;where&lt;/span&gt;&lt;span&gt; T:ViewModelBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; _isInitialized;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; destroyOnHide;
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; PropertyBinder&amp;lt;T&amp;gt; Binder=&lt;span&gt;new&lt;/span&gt; PropertyBinder&amp;lt;T&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; BindableProperty&amp;lt;T&amp;gt; ViewModelProperty = &lt;span&gt;new&lt;/span&gt; BindableProperty&amp;lt;T&amp;gt;&lt;span&gt;();
 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; T BindingContext
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ViewModelProperty.Value; }
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_isInitialized)
                {
                    OnInitialize();
                    _isInitialized &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发OnValueChanged事件&lt;/span&gt;
                ViewModelProperty.Value =&lt;span&gt; value;
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 初始化View，当BindingContext改变时执行
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnInitialize()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;无所ViewModel的Value怎样变化，只对OnValueChanged事件监听(绑定)一次&lt;/span&gt;
            ViewModelProperty.OnValueChanged +=&lt;span&gt; OnBindingContextChanged;
        }
        
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 当gameObject将被销毁时，这个方法被调用
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnDestroy()
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (BindingContext.IsRevealed)
            {
                Hide(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            }
            BindingContext.OnDestory();
            BindingContext &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            ViewModelProperty.OnValueChanged &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 绑定的上下文发生改变时的响应方法
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 利用反射+=/-=OnValuePropertyChanged
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnBindingContextChanged(T oldValue, T newValue)
        {
            Binder.Unbind(oldValue);
            Binder.Bind(newValue);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;UnityGuiView中有一个BindingContext的属性， 当使用框架时，需要给View的BindingContext指定对应的ViewModel：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Install:MonoBehaviour
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this for initialization&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; SetupView setupView;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TestView testView;
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Start()
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;绑定上下文&lt;/span&gt;
            setupView.BindingContext=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SetupViewModel();
            testView.BindingContext&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TestViewModel();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在View中，就订阅model数据改变的消息，并定义相应的响应函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SetupView:UnityGuiView&amp;lt;SetupViewModel&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;......省略ui元素的定义&lt;/span&gt;
        
        &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnInitialize()
        {
            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnInitialize();
            Binder.Add&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, OnNamePropertyValueChanged);
            Binder.Add&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Job&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,OnJobPropertyValueChanged);
            Binder.Add&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ATK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,OnATKPropertyValueChanged);
            Binder.Add&lt;/span&gt;&amp;lt;&lt;span&gt;float&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;SuccessRate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,OnSuccessRatePropertyValueChanged);
            Binder.Add&lt;/span&gt;&amp;lt;State&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;State&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,OnStatePropertyValueChanged);
        }


        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnSuccessRatePropertyValueChanged(&lt;span&gt;float&lt;/span&gt; oldValue, &lt;span&gt;float&lt;/span&gt;&lt;span&gt; newValue)
        {
            successRateMessageText.text &lt;/span&gt;= newValue.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;F2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnATKPropertyValueChanged(&lt;span&gt;int&lt;/span&gt; oldValue, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; newValue)
        {
            atkMessageText.text &lt;/span&gt;=&lt;span&gt; newValue.ToString();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnJobPropertyValueChanged(&lt;span&gt;string&lt;/span&gt; oldValue, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; newValue)
        {
            jobMessageText.text &lt;/span&gt;=&lt;span&gt; newValue.ToString();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; OnNamePropertyValueChanged(&lt;span&gt;string&lt;/span&gt; oldValue, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; newValue)
        {
            nameMessageText.text &lt;/span&gt;=&lt;span&gt; newValue.ToString();
        }
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnStatePropertyValueChanged(State oldValue, State newValue)
        {
           &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dosomething&lt;/span&gt;
&lt;span&gt;        }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后看一下其中一个model的定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Combatant
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Job { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; SuccessRate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; State State { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; State
    {
        JoinIn,
        Wait
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;3821-1548127570910&quot;&gt;4、总结&lt;/h2&gt;
&lt;div readability=&quot;6.6127167630058&quot;&gt;本文只大概写了一下uMVVM框架的一些设计和使用方法，不全面，如果感兴趣，可以自行阅读源码，github地址为&lt;a href=&quot;https://github.com/MEyes/uMVVM&quot;&gt;https://github.com/MEyes/uMVVM&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;如有错误，欢迎指正！&lt;/p&gt;

</description>
<pubDate>Tue, 22 Jan 2019 05:54:00 +0000</pubDate>
<dc:creator>禹泽鹏鹏</dc:creator>
<og:description>1、什么是MVVM 借用一下百度百科上对MVVM的介绍，MVVM是Model-View-ViewModel的简写，它本质上就是MVC 的改进版。MVVM 就是将其中的View 的状态和行为抽象化，让我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IAMTOM/p/10303392.html</dc:identifier>
</item>
<item>
<title>24分钟让AI跑起飞车类游戏 - 腾讯WeTest</title>
<link>http://www.cnblogs.com/wetest/p/10303206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wetest/p/10303206.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;WeTest 导读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文主要介绍如何&lt;span&gt;让&lt;span&gt;AI在&lt;span&gt;2&lt;span&gt;4&lt;span&gt;分钟内学会玩飞车类游戏。我们使用&lt;span&gt;Distributed &lt;span&gt;PPO&lt;span&gt;训练&lt;span&gt;AI，&lt;span&gt;在&lt;span&gt;短时间内可以取得不错的训练效果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;本方法&lt;span&gt;的特点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1. 纯游戏图像作为输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 不使用游戏内部接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 可靠的强化学习方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4. 简单易行的并行训练&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. PPO简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PPO（Proximal Policy Optimization）是OpenAI在2016年NIPS上提出的一个基于Actor-Critic框架的强化学习方法。该方法主要的创新点是在更新Actor时借鉴了TRPO，确保在每次优化策略时，在一个可信任的范围内进行，从而保证策略可以单调改进。在2017年，DeepMind提出了Distributed PPO，将PPO进行类似于A3C的分布式部署，提高了训练速度。之后，OpenAI又优化了PPO中的代理损失函数，提高了PPO的训练效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文不介绍PPO的算法细节，想学习的同学可以参考以下三篇论文：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【1】Schulman J, Levine S, Abbeel P, et al. Trust region policy optimization[C]//International Conference on Machine Learning. 2015: 1889-1897.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【2】Heess N, Sriram S, Lemmon J, et al. Emergence of locomotion behaviours in rich environments[J]. arXiv preprint arXiv:1707.02286, 2017.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【3】Schulman J, Wolski F, Dhariwal P, et al. Proximal policy optimization algorithms[J]. arXiv preprint arXiv:1707.06347, 2017.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. 图像识别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 游戏状态识别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;游戏状态识别是识别每一局游戏关卡的开始状态和结束状态。在飞车类游戏中，开始状态和结束状态的标志如图1所示。因为红色框中的标志位置都固定，因此我们使用模板匹配的方法来识别这些游戏状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201901/992994-20190122125424810-1209780147.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图1 游戏状态标志&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从开始状态到结束状态之间的图像是游戏关卡内的图像，此时进行强化学习的训练过程。当识别到结束状态后，暂停训练过程。结束状态之后的图像都是UI图像，我们使用UI自动化的方案，识别不同的UI，点击相应的按钮再次进入游戏关卡，开始下一轮的训练过程，如图2所示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201901/992994-20190122125431979-1272431463.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图2 游戏流程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3 游戏图像识别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们对游戏关卡中的图像识别了速度的数值，作为强化学习中计算激励（Reward）的依据，如图3所示。速度识别包括三个步骤：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步，图像分割，将每一位数字从识别区域中分割出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步，数字识别，用卷积神经网络或者模板匹配识别每一位图像中的数字类别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三步，数字拼接，根据图像分割的位置，将识别的数字拼接起来。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201901/992994-20190122125442184-233353599.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图3 图像各个区域示意图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. AI设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 网络结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用的网络结构如图4所示。输入为游戏图像中小地图的图像，Actor输出当前时刻需要执行的动作，Critic输出当前时刻运行状态的评价。AlexNet使用从输入层到全连接层之前的结构，包含5个卷积层和3个池化层。Actor和Critic都有两个全连接层，神经元数量分别为1024和512。Actor输出层使用softmax激活函数，有三个神经元，输出动作策略。Critic输出层不使用激活函数，只有一个神经元，输出评价数值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201901/992994-20190122125455264-1033469239.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图4 网络结构示意图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 输入处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将小地图图像的尺寸变为121X121，输入到AlexNet网络后，在第三个池化层可以获得2304维的特征向量（576*2*2=2304）。将这个特征向量作为Actor和Critic的输入。我们使用在ImageNet上训练后的AlexNet提取图像特征，并且在强化学习的过程中没有更新AlexNet的网络参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 动作设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们目前在设计飞车类游戏动作时，使用离散的动作，包括三种动作：左转、右转和NO Action。每种动作的持续时间为80ms，即模拟触屏的点击时间为80ms。这样的动作设计方式比较简单，便于AI快速地训练出效果。如果将动作修改为连续的动作，就可以将漂移添加到动作中，让AI学习左转、右转、漂移和NO Action的执行时刻和执行时长。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4 激励计算&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果将游戏的胜负作为激励来训练AI，势必会花费相当长的时间。在本文中，我们根据游戏图像中的速度数值，计算当前时刻的激励。假定当前时刻的速度为Vp，前一时刻的速度为Vq，那么激励R按照以下方式计算：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;If  Vp ≥ Vq ， R = 0.25X(Vp - Vq)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;If  Vp &amp;lt; Vq ， R = -0.25X(Vq - Vp)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;If  Vp &amp;gt; 250 ， R = R + 5.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;If  Vp &amp;lt; 50 ， R = R - 5.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样的激励计算方式可以使AI减少撞墙的概率，并且鼓励AI寻找加速点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 训练环境&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.1 硬件&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们搭建了一个简单的分布式强化学习环境，可以提高采样效率和训练速度，硬件部署方式如图5所示。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201901/992994-20190122125519633-1395898303.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图5 硬件部署方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要包含以下硬件：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）3部相同分辨率的手机，用于生成数据和执行动作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）2台带有显卡的电脑，一台电脑Proxy用于收集数据、图像识别以及特征提取，另一台电脑Server用于训练AI。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）1个交换机，连接两台电脑，用于交换数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2 软件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Ubuntu 14.04 + TensorFlow 1.2 + Cuda 7.0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5. 分布式部署&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用的分布式部署方式如图6所示。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201901/992994-20190122125535093-660828321.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图6 分布式部署方式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Proxy端设置三个proxy进程，分别与三部手机相连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Server端设置一个master进程和三个worker线程。master进程和三个worker线程通过内存交换网络参数。master进程主要用于保存最新的网络参数。三个proxy进程分别和三个worker线程通过交换机传输数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;proxy进程有6个功能：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）从手机接收图像数据；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）识别当前游戏状态；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）识别速度计算激励；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）利用AlexNet提取图像特征；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）发送图像特征和激励到worker线程，等待worker线程返回动作；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6）发送动作到手机；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;worker线程有5个功能：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）从proxy进程接收图像特征和激励；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）从master进程拷贝最新的网络参数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）将Actor输出的动作发送到proxy进程；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）利用PPO更新网络参数；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）将更新后的网络参数传输到master进程；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6. 实验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.1 参数设置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;PPO的训练参数很多，这里介绍几个重要参数的设置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）学习速率：Actor和Critic的学习率都设置为1e-5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）优化器：Adam优化器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）Batch Size: 20&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）采样帧率：10帧/秒&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）更新次数：15次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6）激励折扣率：0.9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.2 AI效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.3 数据分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表1和表2分别对比了不同并行数量和不同输入数据情况下AI跑完赛道和取得名次的训练数据。最快的训练过程是在并行数量为3和输入数据为小地图的情况下，利用PPO训练24分钟就可以让AI跑完赛道，训练7.5小时就可以让AI取得第一名（和内置AI比赛）。并且在减少一部手机采样的情况下，也可以达到相同的训练效果，只是训练过程耗时更长一点。另外，如果将输入数据从小地图换成全图，AI的训练难度会有一定程度的增加，不一定能达到相同的训练效果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表1 AI跑完赛道的数据对比&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;输入数据&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;并行数量&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;训练时间&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;训练次数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;训练局数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;全图&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;100分钟&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;4200次&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;78局&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;小地图&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;40分钟&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;1700次&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;32局&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;全图&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;78分钟&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;3900次&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;72局&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;小地图&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;24分钟&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;1400次&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;111&quot;&gt;
&lt;p&gt;&lt;span&gt;25局&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;表2 AI取得名次的数据对比&lt;/span&gt;&lt;/p&gt;
&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;91&quot;&gt;
&lt;p&gt;&lt;span&gt;输入数据&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;91&quot;&gt;
&lt;p&gt;&lt;span&gt;并行数量&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;92&quot;&gt;
&lt;p&gt;&lt;span&gt;训练时间&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;96&quot;&gt;
&lt;p&gt;&lt;span&gt;训练次数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p&gt;&lt;span&gt;训练局数&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;88&quot;&gt;
&lt;p&gt;&lt;span&gt;名次&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;91&quot;&gt;
&lt;p&gt;&lt;span&gt;小地图&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;91&quot;&gt;
&lt;p&gt;&lt;span&gt;2&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;92&quot;&gt;
&lt;p&gt;&lt;span&gt;9小时&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;96&quot;&gt;
&lt;p&gt;&lt;span&gt;19000次&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p&gt;&lt;span&gt;354局&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;88&quot;&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;91&quot;&gt;
&lt;p&gt;&lt;span&gt;全图&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;91&quot;&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;92&quot;&gt;
&lt;p&gt;&lt;span&gt;60小时&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;96&quot;&gt;
&lt;p&gt;&lt;span&gt;98000次&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p&gt;&lt;span&gt;1800局&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;88&quot;&gt;
&lt;p&gt;&lt;span&gt;4-6&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;91&quot;&gt;
&lt;p&gt;&lt;span&gt;小地图&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;91&quot;&gt;
&lt;p&gt;&lt;span&gt;3&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;92&quot;&gt;
&lt;p&gt;&lt;span&gt;7.5小时&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;96&quot;&gt;
&lt;p&gt;&lt;span&gt;17800次&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p&gt;&lt;span&gt;343局&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;88&quot;&gt;
&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;如7展示了利用PPO训练AI过程中激励的趋势图，曲线上每一个点表示一局累计的总激励。训练开始时，AI经常撞墙，总激励为负值。随着训练次数的增加，总激励快速增长，AI撞墙的几率很快降低。当训练到1400多次时，总激励值超过400，此时AI刚好可以跑完赛道。之后的训练过程，总激励的趋势是缓慢增长，AI开始寻找更好的动作策略。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992994/201901/992994-20190122125659336-416249883.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;图7 AI训练过程中激励的趋势图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7. 总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文介绍了如何使用Distributed PPO在24分钟内让AI玩飞车类游戏。当前的方法有一定训练效果，但是也存在很多不足。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;目前，我们想到以下几个改进点，以后会逐一验证：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）将AlexNet替换为其他卷积神经网络，如VGG、Inception-V3等等，提高特征提取的表达能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）提高并行数量，添加更多手机和电脑，提高采样速度和计算速度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）增加Batch Size，使用较长的时间序列数据训练AI。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）将离散动作替换为连续动作，增加漂移的学习。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）多个关卡同时训练，提高AI的泛化能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考文献：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【1】Schulman J, Levine S, Abbeel P, et al. Trust region policy optimization[C]//International Conference on Machine Learning. 2015: 1889-1897.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【2】Heess N, Sriram S, Lemmon J, et al. Emergence of locomotion behaviours in rich environments[J]. arXiv preprint arXiv:1707.02286, 2017.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【3】Schulman J, Wolski F, Dhariwal P, et al. Proximal policy optimization algorithms[J]. arXiv preprint arXiv:1707.06347, 2017.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【4】https://morvanzhou.github.io/tutorials/machine-learning/reinforcement-learning/6-4-DPPO/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“深度兼容测试”现已对外，腾讯专家为您定制自动化测试脚本，覆盖应用核心场景，对上百款主流机型进行适配兼容测试，提供详细测试报告，并且首度使用AI能力助力测试&lt;strong&gt;。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;strong&gt;点击&lt;a href=&quot;http://wetest.qq.com/cloud/deepcompatibilitytesting#/?from=content_cnblogs&quot; target=&quot;_blank&quot;&gt;http://wetest.qq.com/cloud/deepcompatibilitytesting#/&lt;/a&gt; 即可体验。&lt;/strong&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果使用当中有任何疑问，欢迎联系腾讯WeTest企业QQ：2852350015&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 04:58:00 +0000</pubDate>
<dc:creator>腾讯WeTest</dc:creator>
<og:description>WeTest 导读 本文主要介绍如何让AI在24分钟内学会玩飞车类游戏。我们使用Distributed PPO训练AI，在短时间内可以取得不错的训练效果。 本方法的特点： 1. 纯游戏图像作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wetest/p/10303206.html</dc:identifier>
</item>
<item>
<title>以语音评测的PC端demo代码为例，讲解口语评测如何实现 - 腾讯云+社区</title>
<link>http://www.cnblogs.com/qcloud1001/p/10303119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcloud1001/p/10303119.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文由云+社区发表&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：腾讯智慧教育&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/draft/3837106/vggili982m.png?imageView2/2/w/1620&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;腾讯云智聆口语评测（英文版）（Smart Oral Evaluation-English，SOE-E）是腾讯云推出的语音评测产品，是基于英语口语类教育培训场景和腾讯云的语音处理技术，应用特征提取、声学模型和语音识别算法，为儿童和成人提供高准确度的英语口语发音评测。腾讯云智聆口语评测（英文版）支持单词和句子模式的评测，多维度反馈口语表现，可广泛应用于英语口语类教学应用中。&lt;/p&gt;
&lt;p&gt;本 SDK 为智聆口语测评（英文版）的 Web 版本，封装了对智聆口语测评（英文版）网络 API 的调用及本地音频文件处理，并提供简单的录音功能，使用者可以专注于从业务切入，方便简洁地进行二次开发。&lt;/p&gt;
&lt;p&gt;本文档只对 Web SDK 进行描述，详细的网络 API 说明请参见 &lt;a href=&quot;https://cloud.tencent.com/document/product/884/19309&quot;&gt;API 文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;使用说明&quot;&gt;使用说明&lt;/h3&gt;
&lt;h4 id=&quot;sdk引入&quot;&gt;SDK引入&lt;/h4&gt;
&lt;p&gt;只需要在您的 Web 页面中添加如下代码即可：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;html
&amp;lt;script src=&quot;https://imgcache.qq.com/open/qcloud/soe/TencentSOE-0.0.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建对象&quot;&gt;创建对象&lt;/h4&gt;
&lt;p&gt;new TencentSOE&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;InitUrl&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;初始化接口地址&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;TransUrl&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;评分接口地址&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;WorkMode&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;上传方式：语音输入模式，0流式分片，1非流式一次性评估&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;EvalMode&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;评估模式，0:词模式, 1:句子模式&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;ScoreCoeff&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;评价苛刻指数，取值为1.0 - 4.0范围内的浮点数 用于平滑不同年龄段的分数，1.0为小年龄段，4.0为最高年龄段&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;3.5&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;SoeAppId&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;业务应用ID，与账号应用APPID无关，是用来方便客户管理服务的参数&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;StorageMode&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;音频存储模式，0：不存储，1：存储到公共对象存储， 输出结果为该会话最后一个分片TransmitOralProcess 返回结果 AudioUrl 字段。&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;success&lt;/td&gt;
&lt;td&gt;function&lt;/td&gt;
&lt;td&gt;创建成功回调&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;function&lt;/td&gt;
&lt;td&gt;创建失败回调&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;10.731707317073&quot;&gt;
&lt;p&gt;用户需自行替换后台接口地址,nodejs版本可参考&lt;a href=&quot;https://github.com/TencentCloud/tencentcloud-sdk-nodejs&quot;&gt;此SDK&lt;/a&gt;let recorder = new TencentSOE({ InitUrl: 'http://127.0.0.1:3000/cgi/init', TransUrl: 'http://127.0.0.1:3000/cgi/trans', success() { // TODO }, error(err) { console.log(err); } });&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;方法&quot;&gt;方法&lt;/h4&gt;
&lt;p&gt;初始化&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 调用初始化接口，设置测评文本
 * @param {
 *   success: function() {} // 成功回调
 *   error: function() {} // 失败回调
 * }
 */
recorder.init({
  RefText: 'about',
  success() {
    recorder.start();
  },
  error(err) {
    console.log(err);
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开始录音&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 开始录音
 * @param {
 *   error: function() {} // 录音过程出现错误时回调，选填
 * }
 */
recorder.start({
  error(err) {
    console.log(err);
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;停止录音&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 停止录音，返回测评结果
 * @param {
 *   success: function() {} // 成功回调
 *   error: function() {} // 失败回调
 * }
 */
recorder.stop({
  success(res) {
    // 获取blob对象，创建audio进行回放
    let audio = document.createElement('audio');
    audio.setAttribute('controls', '');
    let blobUrl = URL.createObjectURL(res.blob);
    document.body.appendChild(audio);
    
    // 输出测评得分
    console.log(res.PronAccuracy)
  },
  error(err) {
    console.log(err);
  }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重置参数&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * 重置参数，用于修改请求参数
 * @param {Object} params
 */
recorder.reset({
  WorkMode: 1
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;在线demo&quot;&gt;在线Demo&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://soe.cloud.tencent.com/&quot;&gt;https://soe.cloud.tencent.com&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;错误码&quot;&gt;错误码&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;10000&lt;/td&gt;
&lt;td&gt;参数格式错误&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;10001&lt;/td&gt;
&lt;td&gt;当前浏览器不支持录音功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;10002&lt;/td&gt;
&lt;td&gt;未开启麦克风访问权限&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;10003&lt;/td&gt;
&lt;td&gt;未提供发音评估初始化接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;10004&lt;/td&gt;
&lt;td&gt;未提供发音数据传输接口接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;10005&lt;/td&gt;
&lt;td&gt;未提供测评文本&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;10020&lt;/td&gt;
&lt;td&gt;接口错误&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Tip： 非本地环境必须使用https协议&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;极简示例&quot;&gt;极简示例&lt;/h3&gt;
&lt;p&gt;创建html， 引入TencentSOE SDK，代码如下&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
  &amp;lt;title&amp;gt;Title&amp;lt;/title&amp;gt;
  &amp;lt;script src=&quot;//imgcache.qq.com/open/qcloud/soe/TencentSOE-0.0.1.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;input type=&quot;text&quot; value=&quot;about&quot; id=&quot;word&quot;&amp;gt;
  &amp;lt;button id=&quot;start&quot;&amp;gt;开始录音&amp;lt;/button&amp;gt;
  &amp;lt;button id=&quot;stop&quot;&amp;gt;结束录音&amp;lt;/button&amp;gt;
   &amp;lt;!-- 显示当前状态 --&amp;gt;
  &amp;lt;span id=&quot;status&quot;&amp;gt;&amp;lt;/span&amp;gt;
  &amp;lt;!-- 显示测评结果 --&amp;gt;
  &amp;lt;div id=&quot;result&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编写录音代码：开始录音、结束录音、展示结果，代码如下&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let recorder = new TencentSOE({
  InitUrl: 'http://127.0.0.1:3000/cgi/init',
  TransUrl: 'http://127.0.0.1:3000/cgi/trans',
  success(res) {
    console.log('创建成功');
  },
  error(err) {
    console.log('创建失败');
  },
});
startBtn.onclick = function () {
  result.innerHTML = '';
  status.textContent = '初始化中';
  recorder.init({
    RefText: word.value,
    success(res) {
      status.textContent = '录音转码中...';
      recorder.start();
    },
    error(err) {
      console.log('err', err);
    }
  });
};
stopBtn.onclick = function () {
  recorder.stop({
    success(res) {
      status.textContent = '已结束';
      createAudioLinkFromBlob(res, 'wav');
    },
    error(err) {
      console.log('err', err);
    }
  });
};

// 创建音频、下载链接
function createAudioLinkFromBlob(res, type) {
  let audio = document.createElement('audio');
  let alink = document.createElement('a');
  let score = document.createElement('span');
  let blobUrl = URL.createObjectURL(res.blob);
  alink.download = 'demo.' + type;
  alink.textContent = 'demo.' + type;
  alink.href = blobUrl;
  audio.src = blobUrl;
  audio.setAttribute('controls', '');
  score.textContent = '分数：' + res.PronAccuracy;

  let container = document.createElement('div');
  container.appendChild(audio);
  container.appendChild(alink);
  container.appendChild(score);
  result.appendChild(container);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;此文已由腾讯云+社区在各渠道发布&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;获取更多新鲜技术干货，可以关注我们&lt;a href=&quot;https://www.zhihu.com/org/teng-xun-yun-ji-zhu-she-qu/activities&quot;&gt;腾讯云技术社区-云加社区官方号及知乎机构号&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 22 Jan 2019 04:17:00 +0000</pubDate>
<dc:creator>腾讯云+社区</dc:creator>
<og:description>本文由云+社区发表 作者：腾讯智慧教育 概述 腾讯云智聆口语评测（英文版）（Smart Oral Evaluation English，SOE E）是腾讯云推出的语音评测产品，是基于英语口语类教育培训</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcloud1001/p/10303119.html</dc:identifier>
</item>
<item>
<title>【Ray Tracing The Next Week 超详解】 光线追踪2-6 Cornell box - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10303112.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10303112.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Chapter 6：Rectangles and Lights&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;今天，我们来学习长方形区域光照&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;先看效果&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122121308351-996675877.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;light&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们需要设计一个发光的材质&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; light.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2019.1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the areaLight-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing the next week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once



&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;the statement of areaLight class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt; areaLight :&lt;span&gt;public&lt;/span&gt;&lt;span&gt; material
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    areaLight() {  }

    areaLight(texture&lt;/span&gt;*&lt;span&gt; mat) :_emit(mat) {  }

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; scatter(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; InRay, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, rtvec&amp;amp; attenuation, ray&amp;amp; scattered)&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; rtvec emitted(rtvar u, rtvar v, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; p)&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; _emit-&amp;gt;&lt;span&gt;value(u, v, p); }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    texture&lt;/span&gt;*&lt;span&gt; _emit;
    };

} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;关于设计方面，我们需要把发光函数设为可继承虚函数，基类也要添加，但是不是所有的材质都需要发光，所以，基类中的发光函数并不需要设置为纯虚&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; material.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2018.12
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the material-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing in one week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the statement of material class&lt;/span&gt;

&lt;span&gt;class&lt;/span&gt;&lt;span&gt; material
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: produce a scattered ray
    @param: InRay -&amp;gt; Incident light
            info -&amp;gt; the information of intersect-point(hit-point)
            attenuation -&amp;gt; when scattered, how much the ray should be attenuated by tis reflectance R
            scattered -&amp;gt; as we talk, it is a new sight; or
                         it is the scattered ray with the intersect-point
    @retur: the function calculate a scattered ray or not
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; scatter(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; InRay, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, rtvec&amp;amp; attenuation, ray&amp;amp; scattered)&lt;span&gt;const&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;


    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    @brief: 自发光
    @param: 纹理所需信息
    @retur: 纹理像素值
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;virtual&lt;/span&gt; rtvec emitted(rtvar u, rtvar v, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; p)&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtvec(); }

    };

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这样的话，一般的材质继承之后，发光为黑色即不发光，较为合理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们既然添加了光照，那么计算插值函数时候也要将它加进去&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122100729302-487281047.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到此，我们的发光材质就设置妥当了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;rectangle&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们定义的长方形均为平行于轴的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（引用书上一张图）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122101308844-1609437275.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设长方形位于 z = k 平面，x和y边界如上，交点为P(x,y,k)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们如何确定光线参数t？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;已知：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;光线：&lt;span&gt;&lt;em&gt;&lt;strong&gt;p&lt;/strong&gt;&lt;/em&gt;(t) = &lt;em&gt;&lt;strong&gt;eye&lt;/strong&gt;&lt;/em&gt; + t * &lt;strong&gt;&lt;em&gt;direction&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则，z方向的方程为：&lt;span&gt;z(t) = &lt;em&gt;&lt;strong&gt;eye&lt;/strong&gt;&lt;/em&gt;.z + t * &lt;em&gt;&lt;strong&gt;direction&lt;/strong&gt;&lt;/em&gt;.z&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，若满足z = k，则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t = (k - &lt;em&gt;&lt;strong&gt;eye&lt;/strong&gt;&lt;/em&gt;.z) / &lt;em&gt;&lt;strong&gt;direction&lt;/strong&gt;&lt;/em&gt;.z&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同理可得x和y的等式&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果，得到的x坐标或者y坐标不在边界之内，那么就没有相交，反之则光线和长方形相交&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122102305534-1402937855.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122102504647-80374446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上面的代码都比较简单，那个 hit 呢，就是，根据已知的一个分量求出t，然后，把这个解带入求出对应的其他两个分量，如果其他两个分量不在边界内，那么返回false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;反之，我们求取该点的纹理坐标，以及其他碰撞点信息记录之&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;获取包围盒嘛，理论上面无厚薄，线无粗细，但是实际中面有厚薄，我们可以将厚度设置为0.0002，以此模拟理论厚度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个没什么问题，我们就往下进行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们来做Cornell box&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122103428201-31016139.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;相机参数设置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122103516561-1146125637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;得到的图如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122103556063-1801344887.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;有几个面是黑色的？？也就是根本没画出来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们细细看一下，发现，长方形的法向量是关键&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如画出来的红墙，对面与之平行的面的法线是朝左边的，展现在我们视线中的是背面&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以，我们有时候需要反转一下法向量&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; flip_normal.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2019.1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the flip_normal-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing the next week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once


&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{
    
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; flip_normal: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; intersect
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    flip_normal(intersect &lt;/span&gt;*&lt;span&gt; p) :_p(p) {  }
    
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; hit(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; sight, rtvar t_min, rtvar t_max, hitInfo&amp;amp; info)&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_p-&amp;gt;&lt;span&gt;hit(sight, t_min, t_max, info))
            {
            info._n &lt;/span&gt;= -&lt;span&gt;info._n;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }

    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; aabb getbox()&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;
        {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _p-&amp;gt;&lt;span&gt;getbox();
        }

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    intersect&lt;/span&gt;*&lt;span&gt; _p;
    };

} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;这样就可以了，我们改一下场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122112429834-867150728.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122113447783-1103050720.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 此外，我们还需要注意的是，light对应的纹理中的数值越大光强越强&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以试一下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    material * light = &lt;span&gt;new&lt;/span&gt; areaLight(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;20&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;)));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122114601320-2012078526.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可以看出来两张图对比之下，第二张亮多了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;但是我们依旧看着很不舒服，好多黑点点，太难受了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我想啊想，为什么这么多黑点？？可能是因为背景是黑色的，毕竟是漫反射，如果随机反射失败那就是黑色，所以随机反射点可能产生好多黑色小点，你千万别想着换成镜面材质，那个更无语&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以啊，我想了下，把背景改为白色，那样更好，毕竟色彩中掺杂一点白色，无伤大雅&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如是，我改了下，效果可观&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122120051864-687974694.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190122121350750-844594356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 22 Jan 2019 04:14:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>Cornell box</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10303112.html</dc:identifier>
</item>
</channel>
</rss>