<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JavaWeb项目的部署以及远程调试 - Java伴我余生</title>
<link>http://www.cnblogs.com/reminis/p/13413427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reminis/p/13413427.html</guid>
<description>&lt;h2 id=&quot;linux环境下软件的安装&quot;&gt;Linux环境下软件的安装&lt;/h2&gt;
&lt;p&gt;Linux环境下的程序的安装、更新、卸载和查看。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;rpm 命令：相当于windows程序的添加/卸载程序，进程程序的安装，查看，卸载。
&lt;ul&gt;&lt;li&gt;本地程序安装：rpm -ivh 程序名&lt;/li&gt;
&lt;li&gt;本地程序查看：rpm -qa&lt;/li&gt;
&lt;li&gt;本地程序卸载：rpm -e --nodeps 程序名&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;yum 命令：相当于可以联网的rpm命令，相当于联网下程序的安装和更新，自动执行rpm命令&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;jdk的安装&quot;&gt;JDK的安装&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. 查看当前Linux系统是否已经安装java，输入 rpm -qa | grep -i java&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801091040881-347535786.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;2. 卸载两个openJDK，输入rpm -e --nodeps 要卸载的软件&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801091120953-616141131.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;span&gt;3. 上传jdk到linux的/usr/local/src/ 路径下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 解压jdk，输入：tar -zxvf jdk-8u152-linux-x64.tar.gz&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5. 配置jdk环境变量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;  打开/etc/profile配置文件，输入：vim /etc/profile，添加如下配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#set java environment
JAVA_HOME=/usr/local/src/jdk1.8.0_152
CLASSPATH=.:$JAVA_HOME/lib.tools.jar
PATH=$JAVA_HOME/bin:$PATH
export JAVA_HOME CLASSPATH PATH
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;vim命令是vi的增强版，centos7最小安装，默认没有这个命令，安装vim&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入rpm -qa 查看系统所有的安装软件&lt;/li&gt;
&lt;li&gt;rpm -qa|grep vim 查看所有安装软件中名字有vim的&lt;/li&gt;
&lt;li&gt;在线安装vim yum install -y vim*&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;6. 重新加载/etc/profile配置文件 source /etc/profile，是环境变量生效&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;mysql安装&quot;&gt;MySQL安装&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1. 查看CentOS自带的mysql&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入 rpm -qa | grep -i mysql&lt;/li&gt;
&lt;li&gt;输入 rpm -qa | grep mariadb&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2. 将自带的mysql卸载&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;rpm -e --nodeps 软件名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;3. 上传Mysql到linux&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用xftp软件将mysql的客户端和服务端都上传上去，传好后就可以进行本地安装了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;4. 安装perl依赖环境&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;yum install perl&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;5. 在/usr/local/src/mysql下安装mysql&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;安装服务器端：rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm&lt;/li&gt;
&lt;li&gt;安装客户端：rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;6. 启动mysql&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;service mysql start&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;7. 登录mysql&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;mysql –uroot –p 默认密码为空&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;8. 修改mysql密码&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;/usr/bin/mysqladmin -u用户名 -p 旧密码 -password 新密码&lt;/li&gt;
&lt;li&gt;mysqladmin -uroot -password ab12 因为开始时root没有密码，所以-p旧密码一项就可以省略了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;9. 开启mysql的远程登录&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认情况下mysql为安全起见，不支持远程登录mysql，所以需要设置开启远程登录mysql的权限&lt;/li&gt;
&lt;li&gt;登录mysql后输入如下命令：
&lt;ul&gt;&lt;li&gt;grant all privileges on *.* to 'root' @'%' identified by '123';&lt;/li&gt;
&lt;li&gt;flush privileges;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;10. 开放Linux的对外访问的端口3306，将修改永久保存到防火墙中&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查看当前防火墙状态：systemctl status firewalld&lt;/li&gt;
&lt;li&gt;运行命令，可以看到zone名称：firewall-cmd --get-active-zones&lt;/li&gt;
&lt;li&gt;执行如下命令命令：firewall-cmd --zone=public --add-port=3306/tcp --permanent&lt;/li&gt;
&lt;li&gt;重启防火墙，运行命令：firewall-cmd --reload&lt;/li&gt;
&lt;li&gt;查看端口号是否开启，运行命令：firewall-cmd --query-port=3306/tcp&lt;/li&gt;
&lt;li&gt;除此之外，若需要关闭当前防火墙：systemctl stop firewalld，如需要开机防火墙不启动：systemctl disable firewalld&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;tomcat安装&quot;&gt;Tomcat安装&lt;/h3&gt;
&lt;p&gt;  tomcat的安装比较简单，直接将tomcat.tar.gz压缩包上传到指定的路径下后，使用tar -zxvf 您的tomcat压缩包进行解压可以了，进入tomcat的bin下启动：./startup.sh，进入tomcat的bin下关闭：./shutdown.sh。&lt;/p&gt;
&lt;h2 id=&quot;javaweb项目的部署&quot;&gt;JavaWeb项目的部署&lt;/h2&gt;
&lt;h3 id=&quot;部署&quot;&gt;部署&lt;/h3&gt;
&lt;p&gt;  将您需要部署的项目，在IDEA中使用maven打包，在打包之前线clean一下，再进行package&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801100201338-1869717939.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;打包完成后，在target目录下会出现一下war包，将该war包上传到您的Linux服务器上的tomcat的webapp目录下，进入tomcat的bin下执行关闭后（/shutdown.sh），再重新启动tomcat(./startup.sh)。tomcat就会自动为我们解压了，我们就可以访问了。&lt;/p&gt;
&lt;h3 id=&quot;端口转发&quot;&gt;端口转发&lt;/h3&gt;
&lt;p&gt;  为了避免输入麻烦的端口号，我们如何不使用nginx，将80端口转发至8080端口，并让他永久生效呢。在centOS7之前，我么可以使用iptables来进行转发，但CentOs7之后就取消了。但我们可以通过安装iptables.service来进行设置，执行如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;systemctl stop firewalld  #关闭防火墙
systemctl disable firewalld #禁止防火墙开机启动
yum install iptables-service #安装
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080 #将80端口转发至8080端口
service iptables save
systemctl restart iptables.service
systemctl enable iptables.service
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801104129101-1335429535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;本地调试远程程序&quot;&gt;本地调试远程程序&lt;/h2&gt;
&lt;h3 id=&quot;服务器端配置&quot;&gt;服务器端配置&lt;/h3&gt;
&lt;p&gt;由于Linux系统中root启动的进程是不支持远程调试的，我们需要创建一个普通账号来启动程序，并且用该账号重新装一个tomcat，步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;adduser work&lt;/li&gt;
&lt;li&gt;passwd work 设置密码为work，会让你确认密码和再次输入密码，要保持一致&lt;/li&gt;
&lt;li&gt;停掉当前root启动的tomcat&lt;/li&gt;
&lt;li&gt;切换账号 su work，进入到根目录 cd ~,上传一个tomcat到work账号的根目录并进行解压，修改配置文件的信息 vim bin/catalina.sh
&lt;ul&gt;&lt;li&gt;由于远程调试账号的tomcat的端口号不能小于1000，所有我们需要对tomcat的bin目录下的catalina.sh文件添加如下配置：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801102206071-1542205716.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;CATALINA_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,address=8888,server=y,suspend=n&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;重启tomcat，我是腾讯云服务器，需要在控制台的安全组策略打开8888端口&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801104515943-697656792.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;idea配置&quot;&gt;IDEA配置&lt;/h3&gt;
&lt;p&gt;使用IDEA调试远程程序，需要在Run/EditConfidurations中添加Remote，并设置你需要调试的项目，以及该项目所在的远程主机和端口，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801104855547-1461903965.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801104941979-73921451.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801105147673-841518820.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后启动远程调试，如果控制台出现：Connected to the target VM, address: 'ip地址:8888', transport: 'socket'，就说明链接成功，然后在你需要调试的接口打上断点，在浏览器中请求改接口，就会进入该断点，我们就可以看到调试信息了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801105556150-769879881.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202008/1975191-20200801110200138-1553784622.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 02 Aug 2020 00:13:00 +0000</pubDate>
<dc:creator>Java伴我余生</dc:creator>
<og:description>Linux环境下软件的安装 Linux环境下的程序的安装、更新、卸载和查看。 rpm 命令：相当于windows程序的添加/卸载程序，进程程序的安装，查看，卸载。 本地程序安装：rpm -ivh 程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/reminis/p/13413427.html</dc:identifier>
</item>
<item>
<title>项目部署点一下按钮就可以，全流程自动化 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13417568.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13417568.html</guid>
<description>&lt;p&gt;我们平时在开发一些小项目的时候，有快速部署发布的这样的需求，我感觉最智能的方式可能是喊一声“发布”，应用程序就能自动打包发布到服务器上并运行起来。因为项目的规模比较小，我们可能不会应用到DevOps团队。我们希望有一个小工具，帮我们实现应用程序的快速上线。&lt;/p&gt;
&lt;p&gt;Alibaba Cloud ToolKit就可以帮助我们就解决这个问题，但是我们还是得打一点小小的折扣，我们无法实现“喊一声”，但是我们可以实现“按一下”就发布应用程序。对于看文档感觉乏味的同学：&lt;a href=&quot;https://www.bilibili.com/video/BV1cD4y1U7Bx&quot;&gt;点这里，这里有本文对应的操作《视频》&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;IDEA File-&amp;gt; Settings-&amp;gt; Plugins-&amp;gt;插件市场搜索alibaba-&amp;gt; 安装install Alibaba Cloud ToolKit。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200802065500106-536884879.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插件安装完成之后，重启IDEA编辑器。&lt;/p&gt;
&lt;h2 id=&quot;第二步：添加服务器&quot;&gt;第二步：添加服务器&lt;/h2&gt;
&lt;p&gt;插件安装完成之后，在IDEA中找到“Alibaba Cloud View” 里面的Host的Tab框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200802065500523-1786354471.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击“Add Host”按钮之后弹出如下对话框，添加远程服务器主机IP及用户名密码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200802065500874-2054544853.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加完成之后多出一条Host记录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200802065501109-1225593030.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;第三步：为服务器添加命令行&quot;&gt;第三步：为服务器添加命令行&lt;/h2&gt;
&lt;p&gt;将一些在该服务器上经常使用的命令行，固化为command配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200802065501320-1424041810.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;点击command，执行添加命令行操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200802065501574-260330564.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;对于应用部署，需要使用到如下两个命令行&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 删除历史启动的 server-jwt进程
ps -aux|grep -v grep |grep server-jwt| awk '{print $2}'|xargs kill -9;
# 用java 方式启动server-jwt-1.0.jar
nohup java -jar /root/server-jwt-1.0.jar &amp;amp;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将上面的命令行中的“server-jwt”替换为你自己的应用的jar名称或唯一关键字即可。如果对于这两个命令完全无法理解，需要去学习shell脚本、nohup、awk脚本和java -jar启动方式等基础知识。&lt;/p&gt;
&lt;h2 id=&quot;第四步：应用部署配置&quot;&gt;第四步：应用部署配置&lt;/h2&gt;
&lt;p&gt;需要部署的项目右键-&amp;gt;Alibaba Cloud -&amp;gt; Deploy To Host，弹出如下对话框：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200802065501892-1805680275.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图对话框红色区域中，从上到下、从左到右依次是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本次部署配置的名称：Name，配置固化下来之后可以复用&lt;/li&gt;
&lt;li&gt;在项目上传到服务器之前maven打包：Maven Build。也可以选择使用Gradle打包：Gradle Build或者手动打包之后上传文件：Upload File。&lt;/li&gt;
&lt;li&gt;选择远程部署的服务器的Ip，本文中第二步的配置结果&lt;/li&gt;
&lt;li&gt;Target Directory：maven打包之后的文件上传目录（即应用部署目录）：根据自己的主机路径规划填写。&lt;/li&gt;
&lt;li&gt;After Deploy：当文件上传主机之后执行的shell脚本或命令行，我们这里选择执行&lt;code&gt;nohup java -jar /root/server-jwt-1.0.jar &amp;amp;;&lt;/code&gt;启动应用。&lt;/li&gt;
&lt;li&gt;Run Maven Goal :maven 的打包目标，先对父项目打包，再对子模块打包。如果不存在，就点击“+”新建，打包命令是“clean install”&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200802065502159-1907703027.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了应用打包、上传、启动之外，我们通常需要一些额外的动作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;比如：之前已将发过一版，再次部署发版应该先把旧版本进程停掉。选择&lt;code&gt;ps -aux|grep -v grep |grep server-jwt| awk '{print $2}'|xargs kill -9;&lt;/code&gt;命令行，第三步配置好的。&lt;/li&gt;
&lt;li&gt;比如：应用部署完成之后，应该立刻查看应用启动的日志，观察是否正常。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202008/1815316-20200802065502394-1393747837.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过以上的配置之后，就可以实现应用程序“一键”打包、上传、启动、查看日志的效果。&lt;/p&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Aug 2020 22:55:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>我们平时在开发一些小项目的时候，有快速部署发布的这样的需求，我感觉最智能的方式可能是喊一声“发布”，应用程序就能自动打包发布到服务器上并运行起来。因为项目的规模比较小，我们可能不会应用到DevOps团</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13417568.html</dc:identifier>
</item>
<item>
<title>【小白学AI】线性回归与逻辑回归（似然参数估计） - 忽逢桃林</title>
<link>http://www.cnblogs.com/PythonLearner/p/13417542.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/PythonLearner/p/13417542.html</guid>
<description>&lt;p&gt;&lt;strong&gt;文章转自【机器学习炼丹术】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线性回归解决的是回归问题，逻辑回归相当于是线性回归的基础上，来解决分类问题。&lt;/p&gt;

&lt;p&gt;线性回归(Linear Regression)是什么相比不用多说了。格式是这个样子的：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f_{w,b}(x)=\sum_i{w_ix_i}+b\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而逻辑回归（Logistic Regression）的样子呢？&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f_{w,b}(x)=\sigma(\sum_i{w_ix_i}+b)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;要记住的第一句话：&lt;strong&gt;逻辑回归可以理解为在线性回归后加了一个sigmoid函数。将线性回归变成一个0~1输出的分类问题。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;sigmoid函数就是：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\sigma(z)=\frac{1}{1+e^{-z}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;函数图像是：&lt;br/&gt;&lt;a href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_e059496bacb7a71a642ff24b853d74f5.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_e059496bacb7a71a642ff24b853d74f5.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;线性回归得到大于0的输出，逻辑回归就会得到0.5~1的输出；&lt;br/&gt;线性回归得到小于0的输出，逻辑回归就会得到0~0.5的输出；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这篇文章的重点，在于&lt;strong&gt;线性回归的参数估计使用的最小二乘法&lt;/strong&gt;，而&lt;strong&gt;而逻辑回归使用的是似然估计的方法&lt;/strong&gt;。（当然，两者都可以使用梯度下降的方法）。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;举个例子，现在我们有了一个训练数据集，是一个二分类问题：&lt;br/&gt;&lt;a href=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_03c2047d0323c327f16a5de101b0e09f.jpg&quot;&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_03c2047d0323c327f16a5de101b0e09f.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/a&gt;&lt;br/&gt;上面的&lt;span class=&quot;math inline&quot;&gt;\(x^1\)&lt;/span&gt;是样本，下面的&lt;span class=&quot;math inline&quot;&gt;\(C_1\)&lt;/span&gt;是类别，总共有两个类别。&lt;/p&gt;
&lt;p&gt;现在假设我们有一个逻辑回归的模型：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(f_{w,b}(x)=\sigma(\sum_i{w_ix_i}+b)\)&lt;/span&gt;&lt;br/&gt;那么&lt;span class=&quot;math inline&quot;&gt;\(f_{w,b}(x^1)\)&lt;/span&gt;的结果，就是一个0~1的数，我们可以设定好，假设这个数字就是是类别&lt;span class=&quot;math inline&quot;&gt;\(C_1\)&lt;/span&gt;的概率，反之，1减去这个数字，就是类别&lt;span class=&quot;math inline&quot;&gt;\(C_2\)&lt;/span&gt;的概率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;似然简单的理解，就是让我们上面的数据集出现的概率最大&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们来理解一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_1\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(C_1\)&lt;/span&gt;的概率是&lt;span class=&quot;math inline&quot;&gt;\(f_{w,b}(x^1)\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_2\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(C_1\)&lt;/span&gt;的概率是&lt;span class=&quot;math inline&quot;&gt;\(f_{w,b}(x^2)\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_3\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(C_2\)&lt;/span&gt;的概率是&lt;span class=&quot;math inline&quot;&gt;\(1-f_{w,b}(x^3)\)&lt;/span&gt;;&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x_N\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(C_1\)&lt;/span&gt;的概率是&lt;span class=&quot;math inline&quot;&gt;\(f_{w,b}(x^N)\)&lt;/span&gt;;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;样本之间彼此独立，那么上面那个数据集的概率是什么？是每一个样本的乘积，这个就是似然Likelihood：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_a079b1a1905f1c3c4f79170a956a1bd9.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们希望这个w，b的参数估计值，就是能获得最大化似然的那个参数。也就是：&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_f270cc58c869d689f7f47b0d068ba8b3.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加上负号之后，就可以变成最小化的问题。当然，加上一个log并不会影响整个的w,b的估计值。因为&lt;span class=&quot;math inline&quot;&gt;\(L(w,b)\)&lt;/span&gt;最大的时候，&lt;span class=&quot;math inline&quot;&gt;\(log(L(w,b))\)&lt;/span&gt;也是最大的，log是个单调递增的函数。所以可以得到下面的：&lt;br/&gt;【注意：所有的log其实是以e为底数的自然对数】&lt;br/&gt;&lt;img src=&quot;http://helloworld2020.net/wp-content/uploads/2020/06/wp_editor_md_da21f1941b8898472892e89ad4aab9bd.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;log又可以把之前的乘积和，转换成加法。&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(log(L(w,b))=log(f(x^1))+log(f(x^2))+log(1-f(x^3))...\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后，为了更加简化这个算是，我们将&lt;span class=&quot;math inline&quot;&gt;\(C_1, C_2\)&lt;/span&gt;数值化，变成1和0，然后每一个样本的真实标签用&lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;来表示，所以就可以得到：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(log(L(w,b))=\sum_i^N{ylog(f(x^i))+(1-y)log(1-f(x^i))}\)&lt;/span&gt;&lt;br/&gt;【有点像是二值交叉熵，然而其实就是二值交叉熵。。】&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当y=1，也就是类别是&lt;span class=&quot;math inline&quot;&gt;\(C_1\)&lt;/span&gt;的时候，这个是&lt;span class=&quot;math inline&quot;&gt;\(log(f(x^i))\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;当y=0，也就是类别是&lt;span class=&quot;math inline&quot;&gt;\(C_2\)&lt;/span&gt;的时候，这个是&lt;span class=&quot;math inline&quot;&gt;\(1-log(f(x^i))\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以其实我们得到的损失函数是：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(loss=-log(L(w,b))=-\sum_i^N{ylog(f(x^i))+(1-y)log(1-f(x^i))}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;之前说了，要找到让这个loss最小的时候的w和b，那怎么找？&lt;br/&gt;【无情万能的梯度下降】&lt;/p&gt;
&lt;p&gt;所以计算&lt;span class=&quot;math inline&quot;&gt;\(\frac{\partial loss}{\partial w}\)&lt;/span&gt;，然后乘上学习率就好了。这里就不继续推导了，有耐心的可以慢慢推导，反正肯定能推出来的。&lt;br/&gt;这里放个结果把：&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{-\partial lnL(w,b)}{\partial w_i}=\sum_n^N{-(y^n-f_{w,b}(x^n))x_i^n}\)&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;为第i个要估计的参数，第i个特征；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(x^n_i\)&lt;/span&gt;是第n个样本的第i个特征的值；&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;math inline&quot;&gt;\(y^n\)&lt;/span&gt;是第n个样本的真实类别，0或者1。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 01 Aug 2020 19:13:00 +0000</pubDate>
<dc:creator>忽逢桃林</dc:creator>
<og:description>文章转自【机器学习炼丹术】 线性回归解决的是回归问题，逻辑回归相当于是线性回归的基础上，来解决分类问题。 1 公式 线性回归(Linear Regression)是什么相比不用多说了。格式是这个样子的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/PythonLearner/p/13417542.html</dc:identifier>
</item>
<item>
<title>详解Flask上下文  - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/13417529.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/13417529.html</guid>
<description>&lt;p&gt;上下文是在Flask开发中的一个核心概念，本文将通过阅读源码分享下其原理和实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flask系列文章&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/10125532.html&quot;&gt;Flask开发初探&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/12004002.html&quot;&gt;WSGI到底是什么&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/11717347.html&quot;&gt;Flask源码分析一：服务启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/11789983.html&quot;&gt;Flask路由内部实现原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/12014120.html&quot;&gt;Flask容器化部署原理与实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ybjourney/p/12387322.html&quot;&gt;Flask权限管理&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;首先，&lt;strong&gt;什么是Flask中的上下文？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Flask中，对一个请求进行处理时，视图函数一般都会需要请求参数、配置等对象，当然不能对每个请求都传参一层层到视图函数（这显然很不优雅嘛），为此，设计出了上下文机制（比如像我们经常会调用的request就是上下文变量）。&lt;/p&gt;
&lt;p&gt;Flask中提供了两种上下文：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;请求上下文：包括request和session，保存请求相关的信息&lt;/li&gt;
&lt;li&gt;程序上下文：包括current_app和g，为了更好的分离程序的状态，应用起来更加灵活，方便调测等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;这四个是上下文变量具体的作用是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;request：封装客户端发送的请求报文数据&lt;/li&gt;
&lt;li&gt;session：用于记住请求之间的数据，通过签名的cookie实现，常用来记住用户登录状态&lt;/li&gt;
&lt;li&gt;current_app：指向处理请求的当前程序实例，比如获取配置，经常会用current_app.config&lt;/li&gt;
&lt;li&gt;g：当前请求中的全局变量，因为程序上下文的生命周期是伴随请求上下文产生和销毁的，所以每次请求都会重设。一般我会在结合钩子函数在请求处理前使用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;具体是怎么实现的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上下文具体的实现文件：&lt;a href=&quot;https://github.com/pallets/flask/blob/master/src/flask/ctx.py&quot;&gt;ctx.py&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请求上下文对象通过RequestContext类实现，当Flask程序收到请求时，会在wsgi_app()中调用Flask.request_context()，实例化RequestContext()作为请求上下文对象，接着会通过push()方法将请求数据推入到请求上下文堆栈(LocalStack)，然后通过full_dispatch_request对象执行视图函数，调用完成之后通过auto_pop方法来移除。所以，请求上下文的生命周期开始于调用wsgi_app()时，结束与响应生成之后。具体代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def wsgi_app(self, environ, start_response):
    
    ctx = self.request_context(environ)
    error = None
    try:
        try:
            ctx.push()
            response = self.full_dispatch_request()
        except Exception as e:
            error = e
            response = self.handle_exception(e)
        except:  # noqa: B001
            error = sys.exc_info()[1]
            raise
        return response(environ, start_response)
    finally:
        if self.should_ignore_error(error):
            error = None
        ctx.auto_pop(error)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序上下文对象通过AppContext类实现，程序上下文的创建方式有两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;自动创建：在处理请求时，程序上下文会随着请求上下文一起被创建&lt;/li&gt;
&lt;li&gt;手动创建：with语句&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;通过阅读源码，可以看到上面两个上下文对象的push和pop都是通过操作LocalStack对象实现的，那么，&lt;strong&gt;LocalStack是怎样实现的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Werkzeug的LocalStack是栈结构，在 globals.py中定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;_request_ctx_stack = LocalStack()
_app_ctx_stack = LocalStack()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class LocalStack(object):

    def __init__(self):
        self._local = Local()

    def __release_local__(self):
        self._local.__release_local__()

    def _get__ident_func__(self):
        return self._local.__ident_func__

    def _set__ident_func__(self, value):
        object.__setattr__(self._local, '__ident_func__', value)
    __ident_func__ = property(_get__ident_func__, _set__ident_func__)
    del _get__ident_func__, _set__ident_func__

    def __call__(self):
        def _lookup():
            rv = self.top
            if rv is None:
                raise RuntimeError('object unbound')
            return rv
        return LocalProxy(_lookup)

    def push(self, obj):
        &quot;&quot;&quot;Pushes a new item to the stack&quot;&quot;&quot;
        rv = getattr(self._local, 'stack', None)
        if rv is None:
            self._local.stack = rv = []
        rv.append(obj)
        return rv

    def pop(self):
        &quot;&quot;&quot;Removes the topmost item from the stack, will return the
        old value or `None` if the stack was already empty.
        &quot;&quot;&quot;
        stack = getattr(self._local, 'stack', None)
        if stack is None:
            return None
        elif len(stack) == 1:
            release_local(self._local)
            return stack[-1]
        else:
            return stack.pop()

    @property
    def top(self):
        &quot;&quot;&quot;The topmost item on the stack.  If the stack is empty,
        `None` is returned.
        &quot;&quot;&quot;
        try:
            return self._local.stack[-1]
        except (AttributeError, IndexError):
            return None
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;LocalStack实现了栈的push、pop和获取栈顶数据的top数据&lt;/li&gt;
&lt;li&gt;整个类基于Local类，在构造函数中创建Local类的实例_local，数据是push到Werkzeug提供的Local类中&lt;/li&gt;
&lt;li&gt;定义&lt;code&gt;__call__&lt;/code&gt;方法，当实例被调用直接返回栈顶对象的Werkzeug提供的LocalProxy代理，即LocalProxy实例，所以，&lt;code&gt;_request_ctx_stack&lt;/code&gt;和&lt;code&gt;_app_ctx_stack&lt;/code&gt;都是代理。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;看到这里，就有以下问题：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Local类是怎样存储数据的呢？为啥需要存储到Local中？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;try:
    from greenlet import getcurrent as get_ident
except ImportError:
    try:
        from thread import get_ident
    except ImportError:
        from _thread import get_ident


class Local(object):
    __slots__ = (&quot;__storage__&quot;, &quot;__ident_func__&quot;)

    def __init__(self):
        object.__setattr__(self, &quot;__storage__&quot;, {})
        object.__setattr__(self, &quot;__ident_func__&quot;, get_ident)

    def __iter__(self):
        return iter(self.__storage__.items())

    def __call__(self, proxy):
        &quot;&quot;&quot;Create a proxy for a name.&quot;&quot;&quot;
        return LocalProxy(self, proxy)

    def __release_local__(self):
        self.__storage__.pop(self.__ident_func__(), None)

    def __getattr__(self, name):
        try:
            return self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)

    def __setattr__(self, name, value):
        ident = self.__ident_func__()
        storage = self.__storage__
        try:
            storage[ident][name] = value
        except KeyError:
            storage[ident] = {name: value}

    def __delattr__(self, name):
        try:
            del self.__storage__[self.__ident_func__()][name]
        except KeyError:
            raise AttributeError(name)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，Local构造函数中定义了两个属性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;__storage__&lt;/code&gt;：用来保存每个线程的真实数据，对应的存储结构为-&amp;gt;&lt;code&gt;{线程ID:{name:value}}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__ident_func__&lt;/code&gt;：通过get_ident()方法获取线程ID，可以看到优先会使用Greenlet获取协程ID，其次是thread模块的线程ID&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Local类在保存数据的同时，记录对应的线程ID，获取数据时根据当前线程的id即可获取到对应数据，这样就保证了全局使用的上下文对象不会在多个线程中产生混乱，保证了每个线程中上下文对象的独立和准确。&lt;/p&gt;
&lt;p&gt;可以看到，Local类实例被调用时也同样的被包装成了一个LocalProxy代理，&lt;strong&gt;为什么要用LocalProxy代理？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代理是一种设计模式，通过创建一个代理对象来操作实际对象，简单理解就是使用一个中间人来转发操作，Flask上下文处理为什么需要它？&lt;/p&gt;
&lt;p&gt;看下代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;@implements_bool
class LocalProxy(object):
    __slots__ = ('__local', '__dict__', '__name__', '__wrapped__')

    def __init__(self, local, name=None):
        object.__setattr__(self, '_LocalProxy__local', local)
        object.__setattr__(self, '__name__', name)
        if callable(local) and not hasattr(local, '__release_local__'):
            object.__setattr__(self, '__wrapped__', local)

    def _get_current_object(self):
        &quot;&quot;&quot;
        获取被代理的实际对象
        &quot;&quot;&quot;
        if not hasattr(self.__local, '__release_local__'):
            return self.__local()
        try:
            return getattr(self.__local, self.__name__)
        except AttributeError:
            raise RuntimeError('no object bound to %s' % self.__name__)
            
        @property
    def __dict__(self):
        try:
            return self._get_current_object().__dict__
        except RuntimeError:
            raise AttributeError('__dict__')

    def __repr__(self):
        try:
            obj = self._get_current_object()
        except RuntimeError:
            return '&amp;lt;%s unbound&amp;gt;' % self.__class__.__name__
        return repr(obj)

    def __bool__(self):
        try:
            return bool(self._get_current_object())
        except RuntimeError:
            return False

    def __unicode__(self):
        try:
            return unicode(self._get_current_object())  # noqa
        except RuntimeError:
            return repr(self)

    def __dir__(self):
        try:
            return dir(self._get_current_object())
        except RuntimeError:
            return []

    def __getattr__(self, name):
        if name == '__members__':
            return dir(self._get_current_object())
        return getattr(self._get_current_object(), name)

    def __setitem__(self, key, value):
        self._get_current_object()[key] = value

    def __delitem__(self, key):
        del self._get_current_object()[key]
    ...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;__getattr__()&lt;/code&gt;、&lt;code&gt;__setitem__()&lt;/code&gt;和&lt;code&gt;__delitem__&lt;/code&gt;会动态的更新实例对象。&lt;/p&gt;
&lt;p&gt;再结合上下文对象的调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-Python&quot;&gt;current_app = LocalProxy(_find_app)
request = LocalProxy(partial(_lookup_req_object, &quot;request&quot;))
session = LocalProxy(partial(_lookup_req_object, &quot;session&quot;))
g = LocalProxy(partial(_lookup_app_object, &quot;g&quot;))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以很明确的看到：因为上下文的推送和删除是动态进行的，所以使用代理来动态的获取上下文对象。&lt;/p&gt;
&lt;p&gt;以上，希望你对Flask上下文机制的原理有了清晰的认识。&lt;/p&gt;
</description>
<pubDate>Sat, 01 Aug 2020 18:10:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文通过阅读源码分享Flask上下文的原理和实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/13417529.html</dc:identifier>
</item>
<item>
<title>Java 数据类型的包装数据类型 - 陈彦斌</title>
<link>http://www.cnblogs.com/chenyanbin/p/13417527.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenyanbin/p/13417527.html</guid>
<description>[unable to retrieve full-text content]什么是包装数据类型 Java是一个面向对象的编程语言，但基本类型并不具有对象的性质，为了让基本类型也具有对象的特征，就出现了包装类型。 集合框架里面需要存储对象，不能存储基本数据类型，所以需要存储包装类型 Java里面的包装数据类型 基本类型 包装器类型 boolean Boolean char C</description>
<pubDate>Sat, 01 Aug 2020 18:06:00 +0000</pubDate>
<dc:creator>陈彦斌</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fchenyanbin%2Fp%2F13417527.html</dc:identifier>
</item>
<item>
<title>要点1：指针、数组和复合字面量 - CN_Simo</title>
<link>http://www.cnblogs.com/lxmwb/p/13417477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxmwb/p/13417477.html</guid>
<description>&lt;p&gt;一维数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int ar[] = {1,2,3}    // 直接初始化，编译器自动获取数组大小
int br[3] = {1,2,3}   // 直接指定大小
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组的名字ar其实是一个指针：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int *pr = ar;
printf(&quot;%d\n&quot;, pr == ar);  // true
printf(&quot;%d\n&quot;, pr+1 == &amp;amp;ar[1]);  // true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以可以通过指针的方式访问数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;printf(&quot;%d\n&quot;, *(ar+1));  //  2
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;二维数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int ar[][3] = {{1,2,3},{4,5,6}};    // 直接初始化，编译器自动识别大小
int br[2][3] = {{1,2,3},{4,5,6}};  // 初始化时，显示指定大小
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，定义多维数组的时候，只有第一个[]中可以省略长度，其他都要显示的指定，因为通过ar+1的形式获取第二个元素的地址的时候，需要知道每个元素的长度.&lt;/p&gt;
&lt;p&gt;这里的ar和br其实是一个包含2个指针元素的数组，每个指针都指向一个大小为3的int型数组，故可以用如下方式访问：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int (*pr)[3] = ar;     // 定义一个指针，类型为int [3]，这里要区别于int *pr[3]
printf(&quot;%d\n&quot;, *(*(pr+1)+1));   // *(pr+1)可以取出第2个数组的首地址，所以输出 5
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在C99标准以前，对于带数组形参的函数，情况不同，可以传递数组，但是没有等价的数组常量。C99新增了复合字面量（compound literal）。字面量是除符号常量外的常量。例如，5是int类型字面量，81.3是double类型的字面量，'Y'是char类型的字面量，&quot;elephant&quot;是字符串字面量。&lt;/p&gt;
&lt;p&gt;下面创建数组的方式和上面创建一维数组的方式等价：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int *pr;
pr = (int [3]){1,2,3};   // C99之前是不允许的
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样在形参带数组的函数中传参更方便：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void sum(const int [], int n);
int s = sum((int []){1,2,3}, 3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二维的复合字面量可以这么用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int (*pr)[3];
pr = (int [][3]){{1,2,3},{4,5,6}};   // 和传统二维数组定义方式等价，更方便
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 01 Aug 2020 17:02:00 +0000</pubDate>
<dc:creator>CN_Simo</dc:creator>
<og:description>一维数组及其指针表示法 一维数组： int ar[] = {1,2,3} // 直接初始化，编译器自动获取数组大小 int br[3] = {1,2,3} // 直接指定大小 数组的名字ar其实是一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lxmwb/p/13417477.html</dc:identifier>
</item>
<item>
<title>连接云MariaDB实例 - Pam/sh</title>
<link>http://www.cnblogs.com/pam-sh/p/13417438.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pam-sh/p/13417438.html</guid>
<description>&lt;h2&gt;新建实例&lt;/h2&gt;
&lt;h3&gt;MariaDB&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802002101958-2043606278.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;CVM&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802002224275-1390771033.png&quot; alt=&quot;&quot; width=&quot;954&quot; height=&quot;78&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;内网连接&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;CVM远程登录测试（同一个VPC下）：&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;CVM安装客户端：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;yum install mysql&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;连接：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;mysql -h MariaDB内网ip -u 数据库名 -p &lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802002409530-1362652456.png&quot; alt=&quot;&quot; width=&quot;703&quot; height=&quot;387&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;外网连接&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;开启外网地址&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802002519333-1377208172.png&quot; alt=&quot;&quot; width=&quot;729&quot; height=&quot;216&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;CVM 外网连接：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;mysql -h 生成的域名地址  -P 生成的端口  -u 数据库用户名  -p&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802002646686-1765766614.png&quot; alt=&quot;&quot; width=&quot;618&quot; height=&quot;396&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;windows 外网连接：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802002754711-317810640.png&quot; alt=&quot;&quot; width=&quot;544&quot; height=&quot;560&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于开启外网，数据库就处于公网下，比较危险，但又想外网直接访问，所以可以利用一台CVM，作为代理连接！！！&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;代理连接&lt;/h3&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;创建CVM和MariaDB（同VPC）&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802002937369-838428106.png&quot; alt=&quot;&quot; width=&quot;669&quot; height=&quot;133&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;注意：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;云MariaDB 创建实例后，需要手动创建账号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802003023209-1356683440.png&quot; alt=&quot;&quot; width=&quot;680&quot; height=&quot;139&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;控制台登录测试：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802003138217-474330350.png&quot; alt=&quot;&quot; width=&quot;683&quot; height=&quot;535&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;测试联通性&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注意：两个设备的安全组要放通对应端，保证可联通性&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;安装Telnet&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1、检测telnet-server的rpm包是否安装&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;[root@localhost ~]# rpm -qa telnet-server &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;若无输入内容，则表示没有安装。出于安全考虑telnet-server.rpm是默认没有安装的，而telnet的客户端是标配。即下面的软件是默认安装的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2、若未安装，则安装telnet-server，否则忽略此步骤&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;[root@localhost ~]#yum install telnet-server 　&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3、检测telnet-server的rpm包是否安装&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;[root@localhost ~]# rpm -qa telnet &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;telnet-0.17-47.el6_3.1.x86_64&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;4、若未安装，则安装telnet，否则忽略此步骤&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;[root@localhost ~]# yum install telnet&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802003257661-2007650803.png&quot; alt=&quot;&quot; width=&quot;596&quot; height=&quot;107&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;开启路由转发&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;vim /etc/sysctl.conf&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802003326942-174163512.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;154&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;执行 sysctl -p 使之生效&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802003401041-1471086524.png&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;561&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;10.5&quot;&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;添加 iptables&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1、安装 iptables 服务&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
yum install iptables-services -y
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2、添加规则&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
iptables -t nat -A PREROUTING -d &lt;span&gt;10.1&lt;/span&gt;.&lt;span&gt;5.13&lt;/span&gt; -p tcp --dport &lt;span&gt;3306&lt;/span&gt; -j DNAT --to-destination &lt;span&gt;10.1&lt;/span&gt;.&lt;span&gt;5.12&lt;/span&gt;:&lt;span&gt;3306&lt;/span&gt;&lt;span&gt;

iptables &lt;/span&gt;-t nat -A POSTROUTING -d &lt;span&gt;10.1&lt;/span&gt;.&lt;span&gt;5.12&lt;/span&gt; -p tcp --dport &lt;span&gt;3306&lt;/span&gt; -j SNAT --to-source &lt;span&gt;10.1&lt;/span&gt;.&lt;span&gt;5.13&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3、保存规则&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
service iptables save
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802003459465-568133673.png&quot; alt=&quot;&quot; width=&quot;637&quot; height=&quot;45&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;4、查看nat 规则&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
iptables -t nat -L
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802003541539-306919833.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;175&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注意：firewall 如果有开把 firewall 关掉：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;systemctl stop firewalld.service
systemctl disable firewalld.service&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;Windows远程连接:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1928790/202008/1928790-20200802003655941-1438194682.png&quot; alt=&quot;&quot; width=&quot;572&quot; height=&quot;566&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Aug 2020 16:41:00 +0000</pubDate>
<dc:creator>Pam/sh</dc:creator>
<og:description>新建实例 MariaDB CVM 内网连接 CVM远程登录测试（同一个VPC下）： CVM安装客户端： yum install mysql 连接： mysql -h MariaDB内网ip -u 数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pam-sh/p/13417438.html</dc:identifier>
</item>
<item>
<title>async和await的使用总结 ~ 竟然一直用错了c#中的async和await的使用。。 - Vincent-yuan</title>
<link>http://www.cnblogs.com/Vincent-yuan/p/13417356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Vincent-yuan/p/13417356.html</guid>
<description>&lt;p&gt;对于c#中的async和await的使用，没想到我一直竟然都有一个错误。。&lt;/p&gt;
&lt;p&gt;。。还是总结太少，这里记录下。&lt;/p&gt;
&lt;h4&gt;这里以做早餐为例&lt;/h4&gt;
&lt;p&gt;流程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span data-ttu-id=&quot;916bc-112&quot;&gt;倒一杯咖啡。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;916bc-113&quot;&gt;加热平底锅，然后煎两个鸡蛋。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;916bc-114&quot;&gt;煎三片培根。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;916bc-115&quot;&gt;烤两片面包。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;916bc-116&quot;&gt;在烤面包上加黄油和果酱。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span data-ttu-id=&quot;916bc-117&quot;&gt;倒一杯橙汁。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span data-ttu-id=&quot;916bc-117&quot;&gt;当使用同步方式实现时，代码是这样的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AsyncBreakfast
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
            sw.Start();
&lt;span&gt;            Coffee cup &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;span&gt; PourCoffee();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coffee is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Egg eggs &lt;/span&gt;= FryEggs(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eggs are ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Bacon bacon &lt;/span&gt;= FryBacon(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bacon is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Toast toast &lt;/span&gt;= ToastBread(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            ApplyButter(toast);
            ApplyJam(toast);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toast is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Juice oj &lt;/span&gt;=&lt;span&gt; PourOJ();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oj is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Breakfast is ready!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;totol time:{sw.ElapsedMilliseconds/1000}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Juice PourOJ()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pouring orange juice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Juice();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ApplyJam(Toast toast) =&amp;gt;&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Putting jam on the toast&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ApplyButter(Toast toast) =&amp;gt;&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Putting butter on the toast&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Toast ToastBread(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; slices)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; slice = &lt;span&gt;0&lt;/span&gt;; slice &amp;lt; slices; slice++&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Putting a slice of bread in the toaster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start toasting...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Task.Delay(&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;).Wait();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Remove toast from toaster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Toast();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Bacon FryBacon(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; slices)
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;putting {slices} slices of bacon in the pan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cooking first side of bacon...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Task.Delay(&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;).Wait();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; slice = &lt;span&gt;0&lt;/span&gt;; slice &amp;lt; slices; slice++&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flipping a slice of bacon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cooking the second side of bacon...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Task.Delay(&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;).Wait();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Put bacon on plate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bacon();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Egg FryEggs(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; howMany)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warming the egg pan...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Task.Delay(&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;).Wait();
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cracking {howMany} eggs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cooking the eggs ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Task.Delay(&lt;/span&gt;&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;).Wait();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Put eggs on plate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Egg();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Coffee PourCoffee()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pouring coffee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Coffee();
        }
    }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coffee { }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Egg { }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bacon { }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Toast { }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Juice { }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1182288/202008/1182288-20200801230438269-817259533.png&quot; alt=&quot;&quot; width=&quot;364&quot; height=&quot;388&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或表示为这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1182288/202008/1182288-20200801230537673-2025230026.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步准备的早餐大约花费了 30 分钟，因为总耗时是每个任务耗时的总和。这里的total time只是用来表示记录下程序运行的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而我以前写的异步代码是这样的：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Diagnostics;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AsyncBreakfast
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sw = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Stopwatch();
            sw.Start();
            Coffee cup &lt;/span&gt;=&lt;span&gt; PourCoffee();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coffee is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;span&gt;            Egg eggs &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;await&lt;/span&gt; FryEggsAsync(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eggs are ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;

&lt;span&gt;            Bacon bacon &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;await&lt;/span&gt; FryBaconAsync(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bacon is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;

&lt;span&gt;            Toast toast &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;await&lt;/span&gt; ToastBreadAsync(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            ApplyButter(toast);
            ApplyJam(toast);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toast is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;

            Juice oj &lt;/span&gt;=&lt;span&gt; PourOJ();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oj is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Breakfast is ready!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;totol time:{sw.ElapsedMilliseconds/1000}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.ReadKey();
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async &lt;/span&gt;Task&amp;lt;Toast&amp;gt; MakeToastWithButterAndJamAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toast = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ToastBreadAsync(number);
            ApplyButter(toast);
            ApplyJam(toast);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; toast;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Juice PourOJ()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pouring orange juice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Juice();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ApplyJam(Toast toast) =&amp;gt;&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Putting jam on the toast&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ApplyButter(Toast toast) =&amp;gt;&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Putting butter on the toast&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Toast&amp;gt; &lt;span&gt;ToastBreadAsync&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; slices)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; slice = &lt;span&gt;0&lt;/span&gt;; slice &amp;lt; slices; slice++&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Putting a slice of bread in the toaster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start toasting...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Remove toast from toaster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Toast();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Bacon&amp;gt; &lt;span&gt;FryBaconAsync&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; slices)
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;putting {slices} slices of bacon in the pan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cooking first side of bacon...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; slice = &lt;span&gt;0&lt;/span&gt;; slice &amp;lt; slices; slice++&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flipping a slice of bacon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cooking the second side of bacon...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Put bacon on plate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bacon();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Egg&amp;gt; &lt;span&gt;FryEggsAsync&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; howMany)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warming the egg pan...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cracking {howMany} eggs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cooking the eggs ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Put eggs on plate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Egg();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Coffee PourCoffee()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pouring coffee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Coffee();
        }

    }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Coffee { }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Egg { }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bacon { }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Toast { }
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Juice { }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1182288/202008/1182288-20200801232231460-1777648993.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt; 可以看出，这样编写的异步和最初同步版本的总共的耗时大致相同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是因为这段代码还没有利用异步编程的某些关键功能。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;即上面的异步代码的使用在这里是不准确的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看出，&lt;span&gt;这段代码里面的打印输出与同步是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这是因为：在煎鸡蛋或培根时，此代码虽然不会阻塞，但是此代码也不会启动任何其他任务。&lt;/p&gt;
&lt;p&gt;就造成了异步煎鸡蛋的操作完成后，才会开始培根制作。&lt;/p&gt;
&lt;p&gt;但是，对于这里而言，我不希望每个任务都按顺序依次执行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最好是首先启动每个组件任务，然后再等待之前任务的完成。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;例如：首先启动鸡蛋和培根。&lt;/p&gt;
&lt;h4&gt;同时启动任务&lt;/h4&gt;
&lt;p&gt;在很多方案中，&lt;span&gt;你可能都希望立即启动若干独立的任务&lt;/span&gt;。然后，在每个任务完成时，你可以继续&lt;/p&gt;
&lt;p&gt;进行已经准备的其他工作。&lt;/p&gt;
&lt;p&gt;就像这里同时启动煎鸡蛋，培根和烤面包。&lt;/p&gt;
&lt;p&gt;我们这里对早餐代码做些更改。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正确的做法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步是存储任务以便在这些任务启动时进行操作，而不是等待：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Coffee cup =&lt;span&gt; PourCoffee();
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coffee is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;span&gt;Task&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;Egg&amp;gt; eggsTask = FryEggsAsync(&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
&lt;span&gt;Egg eggs &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; eggsTask;&lt;/span&gt;
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eggs are ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;span&gt;Task&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;Bacon&amp;gt; baconTask = FryBaconAsync(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
Bacon bacon &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; baconTask;&lt;/span&gt;
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bacon is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;span&gt;Task&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;Toast&amp;gt; toastTask = ToastBreadAsync(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
Toast toast &lt;/span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; toastTask;&lt;/span&gt;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toast is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

Juice oj &lt;/span&gt;=&lt;span&gt; PourOJ();
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oj is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Breakfast is ready!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来，可以在提供早餐之前将用于处理培根和鸡蛋的await语句移动到此方法的末尾：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Coffee cup =&lt;span&gt; PourCoffee();
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coffee is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;span&gt;Task&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;Egg&amp;gt; eggsTask = FryEggsAsync(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
Task&lt;/span&gt;&amp;lt;Bacon&amp;gt; baconTask = FryBaconAsync(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
Task&lt;/span&gt;&amp;lt;Toast&amp;gt; toastTask = ToastBreadAsync(&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;

&lt;span&gt;Toast toast &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; toastTask;&lt;/span&gt;
ApplyButter(toast);
ApplyJam(toast);
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toast is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Juice oj &lt;/span&gt;=&lt;span&gt; PourOJ();
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oj is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

&lt;span&gt;Egg eggs &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; eggsTask;&lt;/span&gt;
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eggs are ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;span&gt;Bacon bacon &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; baconTask;&lt;/span&gt;
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bacon is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Breakfast is ready!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1182288/202008/1182288-20200801234208785-176929768.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 或者&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1182288/202008/1182288-20200801234247760-1825711448.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;360&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 可以看出，&lt;span&gt;这里一次启动了所有的异步任务。而你仅在需要结果时，才会等待每项任务&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这里异步准备的造成大约花费20分钟，这是因为一些任务可以并发进行。&lt;/p&gt;
&lt;p&gt;而对于直接  Egg eggs = await FryEggsAsync(2); 的方式，适用于你只需要等待这一个异步操作结果，不需要进行其他操作的时候。&lt;/p&gt;
&lt;h4&gt;与任务组合&lt;/h4&gt;
&lt;p&gt;吐司操作由异步操作（烤面包）和同步操作（添加黄油和果酱）组成。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;这里涉及到一个重要概念：&lt;/p&gt;
&lt;p&gt;异步操作后跟同步操作的这种组合也是一个异步操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说，如果操作的任何部分是异步的，整个操作就是异步的。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Toast&amp;gt; MakeToastWithButterAndJamAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number)
{
    &lt;/span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; toast = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ToastBreadAsync(number);
    ApplyButter(toast);
    ApplyJam(toast);

    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; toast;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有，主要代码块现在变为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    Coffee cup &lt;/span&gt;=&lt;span&gt; PourCoffee();
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coffee is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; eggsTask = FryEggsAsync(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; baconTask = FryBaconAsync(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; toastTask = MakeToastWithButterAndJamAsync(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; eggs = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; eggsTask;
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eggs are ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; bacon = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; baconTask;
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bacon is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toast = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; toastTask;
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toast is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    Juice oj &lt;/span&gt;=&lt;span&gt; PourOJ();
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oj is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Breakfast is ready!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;高效的等待任务&lt;/h4&gt;
&lt;p&gt;可以通过使用Task类的方法改进上述代码末尾一系列await语句。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;WhenAll&lt;/span&gt; 是其中的一个api ， &lt;span&gt;它将返回一个其参数列表中的所有任务都已完成时猜完成的Task，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;await&lt;/span&gt;&lt;span&gt;&lt;span&gt; Task.&lt;span&gt;WhenAll&lt;/span&gt;(eggsTask, baconTask, toastTask);&lt;/span&gt;
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eggs are ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bacon is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toast is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Breakfast is ready!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种选择是 WhenAny, 它将返回一个，当其参数完成时猜完成的 Task&amp;lt;Task&amp;gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; breakfastTasks = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Task&amp;gt;&lt;span&gt; { eggsTask, baconTask, toastTask };
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (breakfastTasks.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
{
    &lt;span&gt;Task finishedTask &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.&lt;span&gt;WhenAny&lt;/span&gt;(breakfastTasks);
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (finishedTask ==&lt;span&gt; eggsTask)
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eggs are ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (finishedTask ==&lt;span&gt; baconTask)
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bacon is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (finishedTask ==&lt;span&gt; toastTask)
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toast is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    breakfastTasks.Remove(finishedTask);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;处理已完成任务的结果之后，可以从传递给 &lt;code&gt;WhenAny&lt;/code&gt; 的任务列表中删除此已完成的任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 进行这些更改后，代码的最终版本将如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; AsyncBreakfast
{
    &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
    {
        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            Coffee cup &lt;/span&gt;=&lt;span&gt; PourCoffee();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;coffee is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; eggsTask = FryEggsAsync(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; baconTask = FryBaconAsync(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toastTask = MakeToastWithButterAndJamAsync(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; breakfastTasks = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Task&amp;gt;&lt;span&gt; { eggsTask, baconTask, toastTask };
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (breakfastTasks.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
            {
                &lt;span&gt;Task finishedTask &lt;/span&gt;&lt;/span&gt;&lt;span&gt;= &lt;span&gt;await&lt;/span&gt;&lt;span&gt; Task.WhenAny(breakfastTasks);
                &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (finishedTask ==&lt;span&gt; eggsTask)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eggs are ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (finishedTask ==&lt;span&gt; baconTask)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bacon is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (finishedTask ==&lt;span&gt; toastTask)
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;toast is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
                breakfastTasks.Remove(finishedTask);
            }

            Juice oj &lt;/span&gt;=&lt;span&gt; PourOJ();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;oj is ready&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Breakfast is ready!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Toast&amp;gt; MakeToastWithButterAndJamAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; number)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; toast = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; ToastBreadAsync(number);
            ApplyButter(toast);
            ApplyJam(toast);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; toast;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Juice PourOJ()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pouring orange juice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Juice();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ApplyJam(Toast toast) =&amp;gt;&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Putting jam on the toast&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ApplyButter(Toast toast) =&amp;gt;&lt;span&gt;
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Putting butter on the toast&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Toast&amp;gt; ToastBreadAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; slices)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; slice = &lt;span&gt;0&lt;/span&gt;; slice &amp;lt; slices; slice++&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Putting a slice of bread in the toaster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Start toasting...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Remove toast from toaster&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Toast();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Bacon&amp;gt; FryBaconAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; slices)
        {
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;putting {slices} slices of bacon in the pan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cooking first side of bacon...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; slice = &lt;span&gt;0&lt;/span&gt;; slice &amp;lt; slices; slice++&lt;span&gt;)
            {
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;flipping a slice of bacon&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cooking the second side of bacon...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Put bacon on plate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bacon();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;Egg&amp;gt; FryEggsAsync(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; howMany)
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Warming the egg pan...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cracking {howMany} eggs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cooking the eggs ...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Put eggs on plate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Egg();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Coffee PourCoffee()
        {
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Pouring coffee&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Coffee();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1182288/202008/1182288-20200801235849621-868282585.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1182288/202008/1182288-20200801235947502-79619193.png&quot; alt=&quot;&quot; width=&quot;535&quot; height=&quot;220&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 这种异步的代码实现最终大约花费15分钟，因为一些任务能同时运行，&lt;/p&gt;
&lt;p&gt;并且该代码能够同时监视多个任务，只在需要时才执行操作。&lt;/p&gt;
&lt;h4&gt;总结：&lt;/h4&gt;
&lt;p&gt;async 和 await的功能最好能做到：&lt;/p&gt;
&lt;p&gt;尽可能启动任务，不要在等待任务完成时造成阻塞。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即可以先把任务存储到task，然后在后面需要用的时候，调用await task（）方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参考网址：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/async/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 01 Aug 2020 16:05:00 +0000</pubDate>
<dc:creator>Vincent-yuan</dc:creator>
<og:description>对于c#中的async和await的使用，没想到我一直竟然都有一个错误。。 。。还是总结太少，这里记录下。 这里以做早餐为例 流程如下： 倒一杯咖啡。 加热平底锅，然后煎两个鸡蛋。 煎三片培根。 烤两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Vincent-yuan/p/13417356.html</dc:identifier>
</item>
<item>
<title>Redis服务之常用配置（三） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13416534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13416534.html</guid>
<description>&lt;p&gt;　　上一篇博客我们聊了下redis的rdb持久化、安全连接、资源限制相关配置;回顾请参考:&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13394411.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13394411.html&lt;/a&gt;;今天我们来聊一聊redis主从复制、aof持久化、集群、慢日志相关配置;&lt;/p&gt;
&lt;p&gt;　　 REPLICATION 相关配置&lt;/p&gt;
&lt;p&gt;　　slaveof &amp;lt;masterip&amp;gt; &amp;lt;masterport&amp;gt;：该指令用于指定redis主从复制中的master的ip地址和端口；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801191718197-1581805105.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：redis默认工作在master模式，配置了这个指令以后，redis默认会从master自动降级为slave角色；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801191905214-1123899716.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示让本机redis从属于192.168.0.41 ；也就是说192.168.0.41是master，本节点为slave；&lt;/p&gt;
&lt;p&gt;　　masterauth &amp;lt;master-password&amp;gt;：该指令用于指定连接master的密码&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801192206133-1278559961.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示指定连接master认证密码为admin123.com;这个密码是我们在master上设置的requirepass 指令后面的密码；通常建议一个集群中的redis密码和版本都弄成相同的；&lt;/p&gt;
&lt;p&gt;　　验证：重启redis，连接redis看看是否自动降级为slave？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801192541254-299403794.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　查看同步日志&lt;/p&gt;
&lt;p&gt;　　主节点日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801193050400-77039718.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从节点日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801192734630-2032988348.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的日志信息可以了解到，redis的主从复制主要经历了这几个操作，第一slave连接master，并发送sync命令；第二是master接收到slave的sync命令后，开始执行bgsave命令生成rdb快照文件，并使用缓冲区记录此后执行的所有命令；第三master执行完bgsave后，向所有的slave发送快照，并在发送期间继续记录被执行写操作的命令；第四是slave接收到master的快照后，slave会丢弃之前存在的所有旧数据，然后将接收到的快照文件加载到内存；第五master发送完快照文件后，开始向slave发送缓冲区接收到写操作命令；第六slave完成master发送过来的快照文件加载到内存后，开始接收master发送过来的缓冲区写操作命令，然后将这些命令在slave上执行；第七后期的同步操作，slave会发送自己的slave_repl_offset位置给master，master会根据从服务器发送过来的slave_repl_offset位置，把这之后的数据以rdb快照的方式发送给从服务器；&lt;/p&gt;
&lt;p&gt;　　验证：查看slave中的数据是否和master中的数据一样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801195555891-348216873.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的结果看，master和salve都是空的，没有数据&lt;/p&gt;
&lt;p&gt;　　验证：在master上写入数据，看看slave上是否能够及时的同步过来？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801195900628-1034865698.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到在主服务器上执行写操作，是能够及时的同步到从节点；&lt;/p&gt;
&lt;p&gt;　　slave/replica-serve-stale-data：该指令用于指定当主从复制失去连接，或者主从节点正在同步数据，是否从从节点响应客户端的读请求，默认是yes表示从库会继续响应客户端的读请求；如果设置的no，除去指定点命令之外的任何请求都会返回一个错误“sync with master in progress”&lt;/p&gt;
&lt;p&gt;　　示例：设置slave-serve-stale-data为no 重启redis ，然后将主库宕机，在从库执行读操作，看看是否可以读？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801201453557-1794184923.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　重启redis，在从库上执行读操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801201620292-1128959372.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在主库正常的情况下，从库可以正常的执行读操作。&lt;/p&gt;
&lt;p&gt;　　把主库宕机，看看从库是否还可以执行读操作？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801201848869-1477906509.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：当主库宕机时，从库上执行读操作就报错了；&lt;/p&gt;
&lt;p&gt;　　slave/replica-read-only：该指令用于指定从库是否可以读；默认是从库只读，不可写；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801202839067-933417594.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　repl-diskless-sync：该指令用于指定否使用socket方式复制数据；redis同步数据的方式有两种，一种是socket方式，所谓socker方式复制数据是指在复制数据是master在做快照时，不将快照存入磁盘，直接将rdb文件通过socket方式发送给从节点；这种方式如果是在多个从节点上同步数据，它是串行复制，也就是说第一个slave同步完成后，再同步第二个slave；disk是指主节点将rdb保存到磁盘，然后在发送给从节点；disk方式同步数据在多个slave情景中，它可以共享rdb文件，主节点不用重复生成多个相同的rdb发送给slave;通常情况只有在磁盘速度缓慢但是网络相对较快的情况下才使用 socket 方式，否则都是用disk方式；&lt;/p&gt;
&lt;p&gt;　　repl-diskless-sync-delay：该指令用于指定disk方式同步数据的延迟时间，单位秒；设置为0 表示关闭延迟，关闭延迟则意味着一旦有同步请求，在同步开始到结束前，master不会再接收新的slave的同步请求，直到本次同步完成；&lt;/p&gt;
&lt;p&gt;　　repl-ping-slave-period：该指令用于指定slave根据master指定的时间进行周期性的 PING 监测，单位秒；&lt;/p&gt;
&lt;p&gt;　　repl-timeout：该指令用于指定复制链接超时时间，单位秒；通常这个超时时间要大于上面的repl-ping-slave-period指令指定的时间，否则会经常报同步连接超时；&lt;/p&gt;
&lt;p&gt;　　repl-disable-tcp-nodelay：该指令用于指定socket模式下是否在slave套接字发送sync之后禁用TCP-NODELAY，如果该指令的值为yes，则表示禁用TCP-NODELAY，这样设置后，redis会使用更少的TCP包和带宽向slave发送数据；但是这将使数据传输到 slave上有延迟，Linux 内核的默认配置会达到 40 毫秒；如果该指令的值为no，数据传输到 salve 的延迟将会减少但要使用更多的带宽；&lt;/p&gt;
&lt;p&gt;　　repl-backlog-size：该指令用于指定复制缓冲区大小，只有在 slave 连接之后才分配内存，默认是1MB；&lt;/p&gt;
&lt;p&gt;　　repl-backlog-ttl：该指令用于指定多少时间master没有slave连接，master就情况backlog缓冲区；默认是3600秒；&lt;/p&gt;
&lt;p&gt;　　replica-priority：该指令用于指定当master不可用时，sentinel会根据slave的优先级选举一个新master，最低的优先级的 slave，当选 master。而配置成 0，永远不会被选举。该选项默认是100&lt;/p&gt;
&lt;p&gt;　　min-slaves-to-write：该指令用于指定最少slave数量，如果启用这个选项，master检测从服务的数量小于我们指定数量，将拒绝写请求；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801212201649-1339984112.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在slave小于我们指定的最小slave数量时，master上执行写操作命令就提示我们没有足够的slave节点；&lt;/p&gt;
&lt;p&gt;　　min-slaves-max-lag：该指令用于指定slave的最大延迟时间；如果slave的延迟时间超出我们指定的时间，master就拒绝写操作；&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801213208713-1658904832.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到延迟时间小于我们指定的时间，主服务器上可以正常执行写操作；通常用min-slaves-max-lag和min-slaves-to-write这两个选项来防止主库不安全时主库写操作的命令执行；这两个选项一起使用只要有一个不满足条件，主库将拒绝写操作；&lt;/p&gt;
&lt;p&gt;　　slave/replica-announce-ip：该指令用于指定当在端口转发或NAT网络环境中，slave有多个ip地址，可以使用该选项指定slave的ip地址；&lt;/p&gt;
&lt;p&gt;　　slave/replica-announce-port：该指令用于指定当在端口转发或NAT网络环境中，指定slave的端口；&lt;/p&gt;
&lt;p&gt;　　APPEND ONLY MODE相关配置&lt;/p&gt;
&lt;p&gt; 　　appendonly：该指令 用于指定是否开启AOF日志记录，默认是no不开启； 默认 redis 使用的是 rdb 方式持久化，这种方式如果redis在做完快照后突然宕机，会导致做快照期间写的数据丢失（因为做快照期间的数据还在内存）；AOF持久化是Redis 会把每次写入的数据在接收后都写入 appendonly.aof 文件（有点类似mysql中的binlog），每次启动时 Redis 都会先把这个文件的数据读入内存里，先忽略 RDB 文件（优先级高于RDB）。&lt;/p&gt;
&lt;p&gt;　　appendfilename：该指令用于指定AOF文件名称，默认是appendonly.aof；该文件存储在 dir 指令指定的目录下，同rdb文件在同一个目录下；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801221338687-730121064.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示开启AOF日志持久化，并保持为appendonly.aof&lt;/p&gt;
&lt;p&gt;　　验证：重启redis服务，看看对应目录是否有对应的aof文件生成？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801221540962-2032934470.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　连接redis，执行写操作命令，看看appendonly.aof中是否记录？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# redis-cli -a admin123.com
127.0.0.1:6379&amp;gt; KEYS *
(empty list or set)
127.0.0.1:6379&amp;gt; set k1 v1
OK
127.0.0.1:6379&amp;gt; set k2 v2
OK
127.0.0.1:6379&amp;gt; get k1
&quot;v1&quot;
127.0.0.1:6379&amp;gt; get k2
&quot;v2&quot;
127.0.0.1:6379&amp;gt; quit
[root@node1 ~]# file /var/lib/redis/appendonly.aof 
/var/lib/redis/appendonly.aof: ASCII text, with CRLF line terminators
[root@node1 ~]# cat /var/lib/redis/appendonly.aof
*2
$6
SELECT
$1
0
*3
$3
set
$2
k1
$2
v1
*3
$3
set
$2
k2
$2
v2
[root@node1 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到AOF是一个文本文件，从AOF文件中可以清晰看到我们执行的set命令；&lt;/p&gt;
&lt;p&gt;　　appendfsync：该指令用于指定AOF持久化策略的配置；no表示不自信fsync，有操作系统同步数据到磁盘，always表示每次写入都执行fsync，以保证数据同步到磁盘，everysec表示每秒执行一次fsync同步数据到磁盘；默认是everysec；&lt;/p&gt;
&lt;p&gt;　　no-appendfsync-on-rewrite：该指令用于指定在 aof rewrite 期间,是否对 aof 新记录的 append 暂缓使用文件同步策略,主要考虑磁盘 IO 开支和请求阻塞时间。默认为 no,表示&quot;不暂缓&quot;,新的 aof 记录仍然会被立即同步，Linux 的默认 fsync 策略是 30 秒，如果为 yes 可能丢失 30 秒数据，但由于 yes 性能较好而且会避免出现阻塞因此比较推荐。&lt;/p&gt;
&lt;p&gt;　　auto-aof-rewrite-percentage：该指令用于指定当 AOF log 增长超过指定百分比例时，重写 log file， 设置为 0 表示不自动重写 Aof 日志，重写是为了使 aof 体积保持最小，而确保保存最完整的数据。&lt;/p&gt;
&lt;p&gt;　　auto-aof-rewrite-min-size：该指令用于指定触发AOF重写的最小文件大小；&lt;/p&gt;
&lt;p&gt;　　aof-load-truncated：该指令用于指定是否加载由于其他原因导致的末尾异常的 AOF 文件；比如主进程被 kill/断电等原因造成的AOF文件异常；默认是yes表示加载；&lt;/p&gt;
&lt;p&gt;　　aof-use-rdb-preamble：redis4.0 新增 RDB-AOF 混合持久化格式，在开启了这个功能之后，AOF 重写产生的文件将同时包含 RDB 格式的内容和 AOF 格式的内容，其中 RDB 格式的内容用于记录已有的数据，而 AOF 格式的内存则用于记录最近发生了变化的数据，这样 Redis 就可以同时兼有 RDB 持久化和AOF 持久化的优点（既能够快速地生成重写文件，也能够在出现问题时，快速地载入数据）。&lt;/p&gt;
&lt;p&gt;　　LUA SCRIPTING相关配置&lt;/p&gt;
&lt;p&gt;　　lua-time-limit：该指令用于指定lua脚本的最大执行时间，单位是毫秒；默认是5000毫秒；&lt;/p&gt;
&lt;p&gt;　　REDIS CLUSTER相关配置&lt;/p&gt;
&lt;p&gt;　　cluster-enabled：该指令用于指定是否开启集群模式，默认是单机模式；&lt;/p&gt;
&lt;p&gt;　　cluster-config-file：该指令用于指定由 node 节点自动生成的集群配置文件；&lt;/p&gt;
&lt;p&gt;　　cluster-node-timeout：该指令用于指定集群中 node 节点连接超时时间；&lt;/p&gt;
&lt;p&gt;　　cluster-replica-validity-factor：该指令用于指定集群有效因子，这个选项的值×cluster-node-timeout选项的值就等于节点当选master的有效时间；在执行故障转移的时候可能有些节点和 master 断开一段时间数据比较旧，这些节点就不适用于选举为 master，超过这个时间的就不会被进行故障转移；&lt;/p&gt;
&lt;p&gt;　　cluster-migration-barrier：该指令用于指定一个主节点拥有的至少正常工作的从节点，即如果主节点的 slave 节点故障后会将多余的从节点分配到当前主节点成为其新的从节点。默认是1；&lt;/p&gt;
&lt;p&gt;　　cluster-require-full-coverage：该指令用于指定集群槽位不全时，是否不再对外提供服务；当集群槽位覆盖，如果一个主库宕机且没有备库就会出现集群槽位不全，那么 yes 情况下 redis 集群槽位验证不全就不再对外提供服务，而 no 则可以继续使用但是会出现查询数据查不到的情况(因为有数据丢失)。&lt;/p&gt;
&lt;p&gt;　　SLOW LOG 相关配置&lt;/p&gt;
&lt;p&gt;　　slowlog-log-slower-than：该指令用于指定大于多少时间的命令执行时间为慢日志；单位微妙；该指令值为负数表示禁用慢日志，为 0 会记录每个命令操作。&lt;/p&gt;
&lt;p&gt;　　slowlog-max-len：该指令用于指定慢日志队列长度，超出该队列长度会覆盖最早的记录，以此滚动删除；&lt;/p&gt;
&lt;p&gt;　　示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202008/1503305-20200801230315544-1778243117.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　提示：以上配置表示记录每个命令的操作为慢日志中，慢日志的最大队列长度为10；&lt;/p&gt;
&lt;p&gt;　　验证：重启redis，连接redis执行命令，看看是否都将执行的命令都记录为慢日志中？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# systemctl restart redis
[root@node1 ~]# ss -tnl
State       Recv-Q Send-Q   Local Address:Port                  Peer Address:Port              
LISTEN      0      511       192.168.0.41:6379                             *:*                  
LISTEN      0      511          127.0.0.1:6379                             *:*                  
LISTEN      0      128                  *:22                               *:*                  
LISTEN      0      100          127.0.0.1:25                               *:*                  
LISTEN      0      128                 :::22                              :::*                  
LISTEN      0      100                ::1:25                              :::*                  
[root@node1 ~]# redis-cli -a admin123.com
127.0.0.1:6379&amp;gt; KEYS *
1) &quot;k2&quot;
2) &quot;k1&quot;
127.0.0.1:6379&amp;gt; get k1
&quot;v1&quot;
127.0.0.1:6379&amp;gt; get k2
&quot;v2&quot;
127.0.0.1:6379&amp;gt; set k3 v3
OK
127.0.0.1:6379&amp;gt; SLOWLOG len
(integer) 10
127.0.0.1:6379&amp;gt; SLOWLOG get
 1) 1) (integer) 78
    2) (integer) 1596294355
    3) (integer) 2
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;137&quot;
 2) 1) (integer) 77
    2) (integer) 1596294354
    3) (integer) 2
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;137&quot;
 3) 1) (integer) 76
    2) (integer) 1596294353
    3) (integer) 3
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;137&quot;
 4) 1) (integer) 75
    2) (integer) 1596294352
    3) (integer) 88
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;137&quot;
 5) 1) (integer) 74
    2) (integer) 1596294351
    3) (integer) 3
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;137&quot;
 6) 1) (integer) 73
    2) (integer) 1596294350
    3) (integer) 2
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;137&quot;
 7) 1) (integer) 72
    2) (integer) 1596294349
    3) (integer) 3
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;137&quot;
 8) 1) (integer) 71
    2) (integer) 1596294348
    3) (integer) 2
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;137&quot;
 9) 1) (integer) 70
    2) (integer) 1596294347
    3) (integer) 3
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;137&quot;
10) 1) (integer) 69
    2) (integer) 1596294346
    3) (integer) 3
    4) 1) &quot;REPLCONF&quot;
       2) &quot;ACK&quot;
       3) &quot;123&quot;
127.0.0.1:6379&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面的日志可以看到慢日志的对了长度只有10，但是我们执行的命令没有在里面看到，原因是我们开启了主从复制，后台一直在执行REPLCONF ACK命令，把我们执行的命令给覆盖了；&lt;/p&gt;
&lt;p&gt;　　验证：关闭主从复制，连接redis，再执行命令，看看是否记录我们执行的命令？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node1 ~]# systemctl restart redis
[root@node1 ~]# ss -tnl
State       Recv-Q Send-Q   Local Address:Port                  Peer Address:Port              
LISTEN      0      511       192.168.0.41:6379                             *:*                  
LISTEN      0      511          127.0.0.1:6379                             *:*                  
LISTEN      0      128                  *:22                               *:*                  
LISTEN      0      100          127.0.0.1:25                               *:*                  
LISTEN      0      128                 :::22                              :::*                  
LISTEN      0      100                ::1:25                              :::*                  
[root@node1 ~]# redis-cli -a admin123.com
127.0.0.1:6379&amp;gt; KEYS *
1) &quot;k1&quot;
2) &quot;k3&quot;
3) &quot;k5&quot;
4) &quot;k2&quot;
5) &quot;k4&quot;
127.0.0.1:6379&amp;gt; get k1
&quot;v1&quot;
127.0.0.1:6379&amp;gt; get k2
&quot;v2&quot;
127.0.0.1:6379&amp;gt; del k3
(integer) 1
127.0.0.1:6379&amp;gt; del k4
(integer) 1
127.0.0.1:6379&amp;gt; info replication
# Replication
role:master
connected_slaves:0
master_repl_offset:0
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
127.0.0.1:6379&amp;gt; SLOWLOG len
(integer) 8
127.0.0.1:6379&amp;gt; SLOWLOG get 3
1) 1) (integer) 8
   2) (integer) 1596295476
   3) (integer) 4
   4) 1) &quot;SLOWLOG&quot;
      2) &quot;len&quot;
2) 1) (integer) 7
   2) (integer) 1596295454
   3) (integer) 52
   4) 1) &quot;info&quot;
      2) &quot;replication&quot;
3) 1) (integer) 6
   2) (integer) 1596295447
   3) (integer) 10
   4) 1) &quot;del&quot;
      2) &quot;k4&quot;
127.0.0.1:6379&amp;gt; SLOWLOG get 
 1) 1) (integer) 9
    2) (integer) 1596295482
    3) (integer) 48
    4) 1) &quot;SLOWLOG&quot;
       2) &quot;get&quot;
       3) &quot;3&quot;
 2) 1) (integer) 8
    2) (integer) 1596295476
    3) (integer) 4
    4) 1) &quot;SLOWLOG&quot;
       2) &quot;len&quot;
 3) 1) (integer) 7
    2) (integer) 1596295454
    3) (integer) 52
    4) 1) &quot;info&quot;
       2) &quot;replication&quot;
 4) 1) (integer) 6
    2) (integer) 1596295447
    3) (integer) 10
    4) 1) &quot;del&quot;
       2) &quot;k4&quot;
 5) 1) (integer) 5
    2) (integer) 1596295442
    3) (integer) 8
    4) 1) &quot;del&quot;
       2) &quot;k3&quot;
 6) 1) (integer) 4
    2) (integer) 1596295439
    3) (integer) 7
    4) 1) &quot;get&quot;
       2) &quot;k2&quot;
 7) 1) (integer) 3
    2) (integer) 1596295437
    3) (integer) 7
    4) 1) &quot;get&quot;
       2) &quot;k1&quot;
 8) 1) (integer) 2
    2) (integer) 1596295412
    3) (integer) 31
    4) 1) &quot;KEYS&quot;
       2) &quot;*&quot;
 9) 1) (integer) 1
    2) (integer) 1596295408
    3) (integer) 1410
    4) 1) &quot;COMMAND&quot;
10) 1) (integer) 0
    2) (integer) 1596295408
    3) (integer) 4
    4) 1) &quot;AUTH&quot;
       2) &quot;admin123.com&quot;
127.0.0.1:6379&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到关闭主从复制以后，重启master后，再连接redis执行命令，在慢日志中就可以清楚看到我们执行的命令；slowlog len命令用于获取当前slowlog的对列长度；slowlog get命令用于获取指定个数的慢日志，如果没有指定慢日志条目数表示获取当前队列所有日志；&lt;/p&gt;
</description>
<pubDate>Sat, 01 Aug 2020 15:32:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>上一篇博客我们聊了下redis的rdb持久化、安全连接、资源限制相关配置;回顾请参考:https://www.cnblogs.com/qiuhom-1874/p/13394411.html;今天我们来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13416534.html</dc:identifier>
</item>
<item>
<title>MySQL性能优化 - PinXiong</title>
<link>http://www.cnblogs.com/pinxiong/p/13407904.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pinxiong/p/13407904.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在互联网公司MySQL的使用非常广泛，大家经常会有MySQL性能优化方面的需求。整理了一些在MySQL优化方面的实用技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;schema与数据类型优化&quot;&gt;Schema与数据类型优化&lt;/h2&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;整数通常是标识列最好的选择，因为它们很快并且可以使用&lt;code&gt;AUTO_INCREMENT&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;完全“随机”的字符串（如：&lt;code&gt;MD5()&lt;/code&gt;、&lt;code&gt;SHA1()&lt;/code&gt;或者&lt;code&gt;UUID()&lt;/code&gt;等产生的字符串）会任意分布在很大的空间内，会导致&lt;code&gt;INSERT&lt;/code&gt;以及一些&lt;code&gt;SELECT&lt;/code&gt;语句变的很慢&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果希望查询执行得快速且并发性好，单个查询最好不要做太多的关联查询（互联网公司非常忌讳关联查询），利用程序来完成关联操作&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果需要对一张比较大的表做表结构变更（&lt;code&gt;ALTER TABLE&lt;/code&gt;操作增加一列），建议先拷贝一张与原表结构一样的表，再将数据复制进去，最后通过重命名将新表的表名称修改为原表的表名称。因为在变更表结构的时候很有可能会锁住整个表，并且可能会有长时间的不可用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;避免多表关联的时候可以适当考虑一些反范式的建表方案，增加一些冗余字段&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;innodb索引优化&quot;&gt;InnoDB索引优化&lt;/h2&gt;
&lt;ol readability=&quot;17.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果不是按照索引的最左列开始查找，则无法使用索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所有的非聚簇索引都需要先通过索引定位到对应的主键，然后在到聚簇索引查找数据，所以在定义主键索引的时候一定要谨慎&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;只有当索引的列顺序和&lt;code&gt;ORDER BY&lt;/code&gt;子句的顺序完全一致，并且所有列的排序方向（倒序或者正序）都一样时，MySQL才能够使用索引来对结果做排序。有一种情况下&lt;code&gt;ORDER BY&lt;/code&gt;子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在使用&lt;code&gt;like&lt;/code&gt;来匹配字符串类型的字段的值时，尽可能的使用前缀匹配&lt;code&gt;like ‘XX%’&lt;/code&gt;，避免使用 &lt;code&gt;like ‘%XX’&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;哈希索引是基于哈希表实现的，只有精确匹配索引所有列的查询才有效，也不遵循索引的最左匹配原则&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当服务器需要对多个索引做联合操作时（通常有多个&lt;code&gt;OR&lt;/code&gt;条件），建议修改成&lt;code&gt;UNION&lt;/code&gt;的方式，这样方便命中索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;尽可能多的使用覆盖索引（如果一个索引包含或者说覆盖所有需要查询的字段的值，我们就称之为&lt;strong&gt;覆盖索引&lt;/strong&gt;），通过&lt;code&gt;EXPLAIN&lt;/code&gt;的&lt;code&gt;Extra&lt;/code&gt;列可以看到“Using index”信息&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当ID为主键时，创建索引(A)，相当于创建了(A)和(A, ID)两个索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;表中的索引越多对&lt;code&gt;SELECT&lt;/code&gt;、&lt;code&gt;UPDATE&lt;/code&gt;和&lt;code&gt;DELETE&lt;/code&gt;操作速度变慢，同时占用的内存也会比较多&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;InnoDB在二级索引上使用共享锁，但是访问主键索引需要排他锁&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽可能的使用&lt;code&gt;WHERE IN&lt;/code&gt;和&lt;code&gt;WHERE BETWEEN AND&lt;/code&gt;的方式来进行范围查询&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;LIMIT&lt;/code&gt;的偏移量越大性能越慢&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;编写查询语句时应该避免单行查找、尽可能的使用数据原生顺序从而避免额外的排序操作，并尽可能使用索引覆盖查询&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;查询性能优化&quot;&gt;查询性能优化&lt;/h2&gt;
&lt;ol readability=&quot;16&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于低效的查询，通常从两个方面来分析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候可能是访问了太多的列&lt;/li&gt;
&lt;li&gt;确认MySQL服务器层是否在分析大量超过需要的数据行&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一般MySQL能够使用以下三种方式应用&lt;code&gt;WHERE&lt;/code&gt;条件，从好到坏依次为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在索引中使用WHERE条件俩过滤不匹配的记录&lt;/li&gt;
&lt;li&gt;使用索引覆盖扫描来返回记录&lt;/li&gt;
&lt;li&gt;从数据表中返回数据，然后过滤不满足条件的记录&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;MySQL从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。在一个通用服务器上，也能够运行每秒超过10万的查询，一个千兆网卡也能轻松满足每秒超过2000次的查询，MySQL内部每秒能够扫描内存中上百万行数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在删除大量数据时，建议每次删除一小批量数据后，暂停一会儿再做下一次的删除&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大量数据进行排序&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;COUNT()&lt;/code&gt;函数有两种不同的作用：它可以&lt;strong&gt;统计某个列值的数量&lt;/strong&gt;，也可以&lt;strong&gt;统计行数&lt;/strong&gt;。最简单的就是通过&lt;code&gt;COUNT(*)&lt;/code&gt;来统计行数&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;关联查询的时候要确保关联的字段上有索引&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在数据量很大并且历史数据需要定期删除的情况下，可以考虑使用分区表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果定了的索引列和分区列不匹配，会导致查询无法进行分区过滤&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;外键约束尽可能避免，通常通过程序来实现，心中要有外键&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;触发器、存储过程、自定义函数等最好不要使用&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尽可能的利用查询缓存，如果在写查询语句的时候有一些不确定的数据（&lt;code&gt;NOW()&lt;/code&gt;或者&lt;code&gt;CURRENT_DATE()&lt;/code&gt;等）时，则不会被缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用多个小表代替一个大表对查询缓存有好处&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;批量写入时只需要做一次缓存失效，所以相比单条写入（每写入一次，缓存就失效）效率更好，对于写密集型的应用，直接禁用查询缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果缓存的空间太大，在过期操作的时候可能会导致服务器僵死&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上是个人在工作中的经验总结，如果有描述错误的地方希望大家可以帮忙指出，一起交流学习！&lt;/p&gt;
</description>
<pubDate>Sat, 01 Aug 2020 15:14:00 +0000</pubDate>
<dc:creator>PinXiong</dc:creator>
<og:description>在互联网公司MySQL的使用非常广泛，大家经常会有MySQL性能优化方面的需求。整理了一些在MySQL优化方面的实用技巧。 Schema与数据类型优化 整数通常是标识列最好的选择，因为它们很快并且可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pinxiong/p/13407904.html</dc:identifier>
</item>
</channel>
</rss>