<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring还可以这样用缓存，你知道吗？ - 牛初九</title>
<link>http://www.cnblogs.com/boboooo/p/11248145.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/boboooo/p/11248145.html</guid>
<description>&lt;p&gt;大家在项目开发过程中，或多或少都用过缓存，为了减少数据库的压力，把数据放在缓存当中，当访问的请求过来时，直接从缓存读取。缓存一般都是基于内存的，读取速度比较快，市面上比较常见的缓存有：memcache、redis、mongodb、guava cache等。&lt;/p&gt;

&lt;p&gt;大家使用缓存时，常用的逻辑时这样的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据条件生成key；&lt;/li&gt;
&lt;li&gt;从缓存中读取数据，若成功读取数据，则返回；&lt;/li&gt;
&lt;li&gt;若数据不存在，根据条件从数据库读取；&lt;/li&gt;
&lt;li&gt;将从数据库中读取的数据放入缓存；&lt;/li&gt;
&lt;li&gt;返回数据；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;每一个使用缓存的场景，上面的逻辑都要重写一遍，是不是很烦躁，是不是很浪费时间。有没有简单的方法完成上面的逻辑？当然有了，这就是今天要向大家介绍的Spring Cache。&lt;/p&gt;

&lt;p&gt;Spring Cache并不神秘，而且使用起来非常的方便。它是注解组成的，最常用的一个注解是@Cacheable。这个注解是在方法上使用的，当使用了注解的方法被调用时，会先从缓存中查询，如果缓存中不存在，则执行方法，然后将方法的返回值放入缓存中。具体的使用方法如下：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/1bf0f3615b224be784c3835674e0e2f7&quot; alt=&quot;缓存还可以这样玩 你知道吗？&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;首先，我们在IDEA中使用Spring Boot搭建环境，在选择依赖的页面中，我们选择了Lombok和Cache，最主要的选择Cache哦~ 项目搭建完毕后，我们看一下pom.xml的依赖：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/4d3239c4f9f94bb48ee7526eda40e7ba&quot; alt=&quot;缓存还可以这样玩 你知道吗？&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们看到在依赖中自动添加了cache。接下来我们要在SpringBoot的启动类上加上使用cache的注解@EnableCaching，如图：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p1.pstatp.com/large/pgc-image/99c7cffe00224d6d969329332a22f6a2&quot; alt=&quot;缓存还可以这样玩 你知道吗？&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;然后我们编写测试的controller，如下：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/909762442b67468eafdf78b8b5020dbc&quot; alt=&quot;缓存还可以这样玩 你知道吗？&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们使用@RestController注解，所以它返回的是Json格式的结果。然后在方法上使用了@Cacheable注解，这是我们今天的主角。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cacheNames：当系统中有多个缓存时，指定该方法使用其中的哪几个缓存。&lt;/li&gt;
&lt;li&gt;key：缓存的key，可以使用spEL表达式，上面的例子中，使用了入参name。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有其他的关键字，在这里没有列出来，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sync ：true或false，当并发量非常大时，将同步开启，可以保证只有一个线程执行方法，其他线程将等待，然后从缓存中读取数据。&lt;/li&gt;
&lt;li&gt;condition：使用缓存的条件。&lt;/li&gt;
&lt;li&gt;keyGenerator：指定key的生成器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们启动项目，并在浏览器第一次访问http://localhost:8080/cache/test?name=allen，结果响应很慢，过了5秒后，页面显示结果：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p3.pstatp.com/large/pgc-image/78c49456ecc24beb90cca2bc3e9fa018&quot; alt=&quot;缓存还可以这样玩 你知道吗？&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;我们在看一下后台日志：&lt;/p&gt;
&lt;div class=&quot;pgc-img&quot;&gt;&lt;img src=&quot;http://p9.pstatp.com/large/pgc-image/084ed814f2954d3f8abb8c9311e1d7f7&quot; alt=&quot;缓存还可以这样玩 你知道吗？&quot;/&gt;&lt;p class=&quot;pgc-img-caption&quot;&gt; &lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;打印语句打印出来了，说明第一次访问时，是执行了方法的。我们再在浏览器请求相同的地址，结果返回了相同的结果，而且后台没有打印出日志，和上面两张图一模一样。说明这次请求走了缓存，方法并没有执行。&lt;/p&gt;

&lt;p&gt;怎么样？@Cacheable很好用吧，大家赶快动手，在项目中实践一下吧，有问题评论区留言哦&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jul 2019 00:47:00 +0000</pubDate>
<dc:creator>牛初九</dc:creator>
<og:description>大家在项目开发过程中，或多或少都用过缓存，为了减少数据库的压力，把数据放在缓存当中，当访问的请求过来时，直接从缓存读取。缓存一般都是基于内存的，读取速度比较快，市面上比较常见的缓存有：memcache</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/boboooo/p/11248145.html</dc:identifier>
</item>
<item>
<title>今天来聊Java ClassLoader - Java极客技术</title>
<link>http://www.cnblogs.com/justdojava/p/11211586.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justdojava/p/11211586.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;类加载机制作为一个高频的面试题经常会在面试中被问到，前几天一个电话面试就问到，之前有了解过，但是没有梳理成自己的体系，所以说的有点凌乱，今天花点时间整理一下，分享给大家同时自己也好好梳理一下，顺便帮助一下有需要的人。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;什么是类加载机制&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;众所周知我们编写的 Java 文件都是以.java 为后缀的文件，编译器会将我们编写的.java 的文件编译成.class 文件，简单来说类加载机制就是从文件系统将一系列的 class 文件读入 JVM 内存中为后续程序运行提供资源的动作。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;类加载的流程&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;我们先看下类加载的过程中有哪些阶段，后面再对其一一解释做了什么&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/laEmibHFxFw4mmO6dIGHZ1iaJvb4DQibE8OuAyWowTJscuFESWjMT6IPsRhwjOHSJHgoyDjiaNRooK30pksCYAUqjQ/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.484375&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;简单画了一个图，从上图我们可以看出，类加载的整个过程有五个阶段，下面分别解释每个过程做了什么。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;加载&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;通过一个类的完整路径查找此类字节码文件（class 文件即二进制文件）。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;将二进制文件的静态存储结构转化为方法区的运行时数据结构&lt;/strong&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;strong&gt;并利用二进制流文件创建一个Class对象，存储在 Java 堆中用于对方法区的数据结构引用的入口；&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;class 文件的来源：&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;有一点需要注意的是类加载机制不仅可以从文件系统读取 class 文件，也可以通过网络获取，其他 jar 包或者其他程序生成，如 JSP 应用。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;类加载器：&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;讲到类加载不得不讲到类加载的顺序和类加载器。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;Java 中大概有四种类加载器，分别是：&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;启动类加载器（Bootstrap ClassLoader），扩展类加载器（Extension ClassLoader），系统类加载器（System ClassLoader），自定义类加载器（Custom ClassLoader），依次属于继承关系（注意这里的继承不是 Java 类里面的 extends。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/laEmibHFxFw4mmO6dIGHZ1iaJvb4DQibE8OCjfZAAQLFANNeTtdyjDBoy2g0evaLoz3wYkA3JpKRcHt2P6oNlcYFw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;启动类加载器（Bootstrap ClassLoader）：&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;主要负责加载存放在Java_Home/jre/lib下，或被-Xbootclasspath参数指定的路径下的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载），启动类加载器是无法被Java程序直接引用的。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;4.&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;扩展类加载器（Extension ClassLoader）：&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;主要负责加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载Java_Home/jre/lib/ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;5.&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;系统类加载器（System ClassLoader）：&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;主要负责加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;strong&gt;6.&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;自定义类加载器（Custom ClassLoader：&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;自己开发的类加载器&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;7.&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;双亲委派原则：&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;类加载器在加载 class 文件的时候，遵从双亲委派原则，意思是加载依次由父加载器先执行加载动作，只有当父加载器没有加载到 class 文件时才由子类加载器进行加载。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;这种机制很好的保证了 Java API 的安全性，使得 JDK 的代码不会被篡改。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;验证&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;验证的过程只要是保证 class 文件的安全性和正确性，确保加载了该 class 文件不会导致 JVM 出现任何异常，不会危害JVM 的自身安全。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;验证包括对文件格式的验证，元数据和字节码的验证。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;准备&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;准备阶段是为类变量进行内存分配和初始化零值的过程。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;注意这时候分配的是类变量的内存，这些内存会在方法区中分配。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;此时不会分配实例变量的内存，因为实例变量是在实例化对象时一起创建在Java 堆中的。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;而且此时类变量是赋值为零值，即 int 类型的零值为 0，引用类型零值为 null，而不是代码中显示赋值的数值。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;解析&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;在 class 文件中常量池里面存放了字面量和符号引用，符号引用包括类和接口的全限定名以及字段和方法的名称与描述符。&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;在 JVM 动态链接的时候需要根据这些符号引用来转换为直接引用存放内存使用。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;初始化的阶段是类加载的最后一步，这个阶段主要是执行 java 代码，进行相关初始化的动作。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;整个类加载机制是我们程序运行的开始，虽然这些动作都是 JVM 帮我们自动完成，开发人员在不需要定制类加载器的时候是不会涉及到底层细节的，但是作为一个有追求的程序员，我们还是要知道一些原理，这样不管是在面试的时候还是对自己的提升都有很大的帮助。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;Java 极客技术公众号，是由一群热爱 Java 开发的技术人组建成立，专注分享原创、高质量的 Java 文章。如果您觉得我们的文章还不错，请帮忙赞赏、在看、转发支持，鼓励我们分享出更好的文章。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关注公众号，大家可以在公众号后台回复“博客园”，免费获得作者 Java 知识体系/面试必看资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/laEmibHFxFw4HxcgPDQRiaQcGWmoqB7Fj8MuG51ic0QUXT2Ytq1NRiawzPNfQzjZzAWbv8JfD3ejia1ibvUYQOqFDqIw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;220&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;123&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jul 2019 00:47:00 +0000</pubDate>
<dc:creator>Java极客技术</dc:creator>
<og:description>背景 类加载机制作为一个高频的面试题经常会在面试中被问到，前几天一个电话面试就问到，之前有了解过，但是没有梳理成自己的体系，所以说的有点凌乱，今天花点时间整理一下，分享给大家同时自己也好好梳理一下，顺</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justdojava/p/11211586.html</dc:identifier>
</item>
<item>
<title>通过VS2017发布.net core程序并使用Web 部署到远程服务器最新教程 - CloudH</title>
<link>http://www.cnblogs.com/jessory/p/11248144.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jessory/p/11248144.html</guid>
<description>&lt;p&gt;最近一个项目中，为App开发后台接口，技术选型为最新 .net core版本，使用.net core开发web api接口过程中，为了方便app团队成员直接在线调用接口，找了公网上的一台服务器做为app后台接口的测试服务器，并做了域名解析。服务器配置为Windows Server 2008 R2企业版，刚购买时，云服务器厂商只是安装了IIS的基本功能。所以接下来咱们基于Windows Server 2008 R2 服务器开始今天的教程。&lt;/p&gt;
&lt;h2&gt;第一：首先在IIS上安装管理服务，配置好IIS7 允许使用VS2017远程发布&lt;/h2&gt;
&lt;h3&gt;为IIS7安装管理服务&lt;/h3&gt;
&lt;p&gt;桌面右键我的电脑，打开服务器管理，展开Roles（角色），选中IIS右键，添加角色服务，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726084740696-255255821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装管理服务&lt;/p&gt;

&lt;p&gt;点击添加角色服务后，会出现一个窗口：添加角色服务窗口。在下图中选择“Web管理服务”，因我操作太快，忘记截图上传，因此找了一张英文图供大家查看，操作方式是一样的，中文时，勾选Web管理服务即可安装上此服务。执行这一步是因为云服务器厂商在装机时，不会为你安装这个服务，因此需要我们手工打造。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726084845437-1043933778.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;安装会等一会儿，安装好了后会在IIS的管理界面有一个管理服务的图标，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726084903752-1320753551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功&lt;/p&gt;

&lt;p&gt;安装成功后，在服务里面可以看到有一个服务叫：Web Management Service的服务进程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726084936588-2124387859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行到上面时，就表示安装成功了&lt;/p&gt;
&lt;h3&gt;安装Web Deploy程序&lt;/h3&gt;
&lt;p&gt;安装Web Deploy程序也是必须的，如果不安装时，在VS2017发布时会报以下错误，具体见下图。&lt;/p&gt;
&lt;p&gt;未能连接到远程计算机（“www.jhrs.com”）。请确保在远程计算机上安装了Web Deploy 并启动了所需的进程（“Web 部署代理服务”）。在以下位置了解更多信息：http://go.microsoft.com/fwlink/?LinkId=221672#ERROR_DESTINATION_NOT_REACHABLE。远程服务器返回错误：（404）未找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085015483-1423154295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不安装Web Deploy报错&lt;/p&gt;
&lt;p&gt;出现上面这个错误是因为Server 2008 R2服务器上未安装Web Deploy程序所造成的，这时你需要到服务器上安装最新版本的Web Deploy v3.6这个程序，安装好了后会在服务列表看到一个叫：的程序。&lt;a href=&quot;https://www.microsoft.com/zh-CN/download/details.aspx?id=43717&quot;&gt;Web Deploy v3.6&lt;/a&gt;的下载地址是：https://www.microsoft.com/zh-CN/download/details.aspx?id=43717&lt;/p&gt;
&lt;p&gt;下载后，这家伙长这样，直接双击安装即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085031670-1480961228.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装成功后，在服务里面有个叫：Web 部署代理服务 的服务程序，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085115851-1314933787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Web-Deploy-Services&lt;/p&gt;
&lt;p&gt;经过上面步骤的折腾，基本上就配置好了，接下来我们来配置IIS7，允许我们在VS2017里面直接发布.net core的 web api到服务器上。&lt;/p&gt;
&lt;h2&gt;第二：服务器端配置好IIS7，允许VS2017通过Web部署方式发布程序&lt;/h2&gt;
&lt;h3&gt;设置管理服务&lt;/h3&gt;
&lt;p&gt;点击上面第3张图片的管理服务图标，进入下图设置好即可，最后别忘记点右边的启用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085143082-1018080924.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;为VS2017发布建立专用账户，用于更新，并授好权限&lt;/h3&gt;
&lt;p&gt;此处是在服务器端建个专门的发布用户，我是为了省事，直接授于这个账号管理员权限的，为Server 2008 r2单独建个用户不是什么难事，就直接放个结果图即可，此处操作如有什么不会的童鞋，请google下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085224273-751577844.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面这个步骤完成后，再返回到IIS里面，这时需要选中你的网站，再点击IIS管理权限，将你在上个步骤建的账号赋给这个网站，不然你咋远程发布.net core程序到这儿来呢？见下图姿势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085301138-863211415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为网站设置发布用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085338740-1585599001.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面这个图里面，把新建的用户加进来。&lt;/p&gt;
&lt;p&gt;好了，到此呢服务器端就基本上配置完成了。接下来我们来配置我们本地开发环境的VS2017。&lt;/p&gt;
&lt;h2&gt;第三：VS2017发布配置&lt;/h2&gt;
&lt;p&gt;选中你的项目，我这儿是web api接口，网站是一样的操作，直接右键发布出现下面这个界面，按图提示选择即可，这样就是直接在本地开发环境发布到远程服务器上了。正规点的开发团队可以配置好持续集成工具，一有代码签入经过自动化测试后，可以通过这种方式发布到远程服务器上，这种方式发布是增量发布，不会每次把所有文件发布到服务器上进行替换的。这比我们传统通过复制或者FTP拷到服务器上要方便得多，省事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085410159-1334215080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上面图这儿选择IIS、FTP等这个项目，进入下一步后，按提示配置好即可，一般 来说，出现错误都是服务器端没有配置好的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085459453-237992688.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务器：填写域名或者IP地址，不要带 http:// 这个前缀。&lt;/p&gt;
&lt;p&gt;站点名称：你在IIS上网站的名称&lt;/p&gt;
&lt;p&gt;用户名和密码：就是你在服务器上专门建立的账户和密码&lt;/p&gt;
&lt;p&gt;目标URL：发布成功后，它会自动打开这个地址。&lt;/p&gt;
&lt;p&gt;好了，经过上面的配置，我们就可以愉快的用.net core编写web api接口随时发布给app团队使用了。&lt;/p&gt;
&lt;h2&gt;第四：我遇到的错误及处理方法&lt;/h2&gt;
&lt;h3&gt;错误一：&lt;/h3&gt;
&lt;p&gt;未能连接到远程计算机（“www.jhrs.com”）。请确保在远程计算机上安装了Web Deploy 并启动了所需的进程（“Web 部署代理服务”）。在以下位置了解更多信息：http://go.microsoft.com/fwlink/?LinkId=221672#ERROR_DESTINATION_NOT_REACHABLE。远程服务器返回错误：（404）未找到。&lt;/p&gt;
&lt;p&gt;处理方法：&lt;br/&gt;出现上面这个错误是因为Server 2008 R2服务器上未安装Web Deploy程序所造成的，这时你需要到服务器上安装最新版本的Web Deploy v3.6这个程序，安装好了后会在服务列表看到一个叫：Web 部署代理服务 的程序。Web Deploy v3.6的下载地址是：https://www.microsoft.com/zh-CN/download/details.aspx?id=43717&lt;/p&gt;
&lt;h3&gt;错误二：&lt;/h3&gt;
&lt;p&gt;已使用Web部署代理服务连接到”www.jhrs.com”,但未能授权。请确保你是“www.jhrs.com”上的管理员。在以下位置了解更多信息：http://go.microsoft.com/fwlink/?LinkId=221672#ERROR_USER_NOT_ADMIN。远程服务器返回错误：（401）未经授权。&lt;/p&gt;
&lt;p&gt;处理方法：&lt;/p&gt;
&lt;p&gt;我在部署这个时出现上面这个错误，寻找原因花了近1个小时，很是浪费哥哥时间，原来是粗心大意犯的一个错误，在填写服务器时，它这儿不需要带 “http://”这个前缀。&lt;/p&gt;
&lt;h3&gt;错误三：&lt;/h3&gt;
&lt;p&gt;配置正确后，如果你的VS重启或者重新开关机后，再次发布会出现不信任的证书的问题，具体报错的提示内容如下：&lt;/p&gt;
&lt;p&gt;C:\Program Files\dotnet\sdk\2.1.402\Sdks\Microsoft.NET.Sdk.Publish\build\netstandard1.0\PublishTargets\Microsoft.NET.Sdk.Publish.MSDeploy.targets(139,5): 错误 : Web deployment task failed. (已使用指定的进程(“Web Management Service”)连接到远程计算机(“api.jhrs.com”)，但未能验证服务器的证书。如果你信任该服务器，请再次连接并允许不信任的证书。 在以下位置了解更多信息: http://go.microsoft.com/fwlink/?LinkId=221672#ERROR_CERTIFICATE_VALIDATION_FAILED。)&lt;/p&gt;
&lt;p&gt;已使用指定的进程(“Web Management Service”)连接到远程计算机(“api.jhrs.com”)，但未能验证服务器的证书。如果你信任该服务器，请再次连接并允许不信任的证书。 在以下位置了解更多信息: http://go.microsoft.com/fwlink/?LinkId=221672#ERROR_CERTIFICATE_VALIDATION_FAILED。&lt;br/&gt;基础连接已经关闭: 未能为 SSL/TLS 安全通道建立信任关系。&lt;br/&gt;根据验证过程，远程证书无效。&lt;br/&gt;Publish failed to deploy.&lt;/p&gt;
&lt;p&gt;处理方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一：打开Properties-&amp;gt;PublishProfiles目录&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085534122-1521439290.png&quot; alt=&quot;&quot;/&gt;&lt;/li&gt;
&lt;li&gt;第二：打开CustomProfile.pubxml，在最后一个节点（_SavePWD）后增加一个节点，配置内容是：&amp;lt;AllowUntrustedCertificate&amp;gt;True&amp;lt;/AllowUntrustedCertificate&amp;gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/174373/201907/174373-20190726085635216-90336837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;经过这些处理后，就做到了随时发布，随时更新.net core程序到服务器上，不需要你再远程到服务器上复制文件，再手工替换了。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;https://jhrs.com/2018/26157.html&quot;&gt;https://jhrs.com/2018/26157.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jul 2019 00:46:00 +0000</pubDate>
<dc:creator>CloudH</dc:creator>
<og:description>最近一个项目中，为App开发后台接口，技术选型为最新 .net core版本，使用.net core开发web api接口过程中，为了方便app团队成员直接在线调用接口，找了公网上的一台服务器做为ap</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jessory/p/11248144.html</dc:identifier>
</item>
<item>
<title>基于 Github 存储附件的 wordpress 插件 - 肆月之风</title>
<link>http://www.cnblogs.com/acme-top/p/11248137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/acme-top/p/11248137.html</guid>
<description>&lt;p&gt;原文地址： &lt;a href=&quot;https://acme.top/wp-github-gos&quot; class=&quot;uri&quot;&gt;https://acme.top/wp-github-gos&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;插件名称 &lt;code&gt;wp-github-gos&lt;/code&gt;， 本插件核心功能使用了 GitHub API&lt;/p&gt;
&lt;p&gt;设置页面和核心业务逻辑主要参考插件 &lt;a href=&quot;https://github.com/sy-records/wordpress-qcloud-cos&quot;&gt;wordpress-qcloud-cos&lt;/a&gt; 的实现，替换了其中 &lt;code&gt;腾讯云 COS 官方 SDK&lt;/code&gt; 为 &lt;code&gt;GitHub API&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;插件特色&quot;&gt;插件特色&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用 GitHub 仓库存储 WordPress 站点图片等多媒体文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可配置是否上传缩略图和是否保留本地备份&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;本地删除可同步删除腾讯云上面的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持替换数据库中旧的资源链接地址&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持在图片链接地址后面自定义拼接图片&lt;code&gt;宽度&lt;/code&gt;、&lt;code&gt;高度&lt;/code&gt;、&lt;code&gt;大小&lt;/code&gt;三个参数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;插件缺点&quot;&gt;插件缺点&lt;/h2&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;从 Github 下载源码，通过 WordPress 后台上传安装，或者直接将源码上传到 WordPress 插件目录 &lt;code&gt;wp-content/plugins&lt;/code&gt;，然后在后台启用&lt;/p&gt;
&lt;p&gt;Github 项目地址: &lt;a href=&quot;https://github.com/niqingyang/wp-github-gos&quot; class=&quot;uri&quot; title=&quot;https://github.com/niqingyang/wp-github-gos&quot;&gt;https://github.com/niqingyang/wp-github-gos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;修改配置&lt;/p&gt;
&lt;p&gt;方法一：在 WordPress 插件管理页面有设置按钮，进行设置&lt;/p&gt;
&lt;p&gt;方法二：在 WordPress 后台管理左侧导航栏设置下 &lt;code&gt;Github 存储&lt;/code&gt;，点击进入设置页面&lt;/p&gt;
&lt;p&gt;特别说明&lt;/p&gt;
&lt;p&gt;本插件仅支持PHP 5.4+ 版本&lt;/p&gt;
&lt;h2 id=&quot;设置&quot;&gt;设置&lt;/h2&gt;
&lt;p&gt;因为本插件使用了 Github API，所以需要使用者进行一下操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册一个 Github 账户&lt;/li&gt;
&lt;li&gt;并创建一个用于存放附件的公开的仓库&lt;/li&gt;
&lt;li&gt;创建一个 access token&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://static.acme.top/wp-content/uploads/2019/07/paste-3fcd46b9dd1495dae823a40edfa37fbb-1.png?w=212&amp;amp;h=452&quot; alt=&quot;点击 settings 菜单&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.acme.top/wp-content/uploads/2019/07/paste-05312293588326deb1dbad23b28f41de-1.png?w=1012&amp;amp;h=385&quot; alt=&quot;进入 Developer Settings 页面创建 Token&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.acme.top/wp-content/uploads/2019/07/paste-905e412f7c8cd8018957961c14f9c315-1.png?w=737&amp;amp;h=149&quot; alt=&quot;勾选必要的权限&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将 &lt;code&gt;Github 账户名&lt;/code&gt;、&lt;code&gt;仓库名&lt;/code&gt;、&lt;code&gt;access token&lt;/code&gt; 粘帖到该插件设置页面中相应的位置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://static.acme.top/wp-content/uploads/2019/07/paste-7fa86ef9fd73858f6491d23919e5ac3c-1.png?w=614&amp;amp;h=315&quot; alt=&quot;填写相关设置&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;URL前缀的格式为 &lt;code&gt;https://raw.githubusercontent.com/{用户名}/{仓库名}/master/&lt;/code&gt;，或者 &lt;code&gt;https://raw.githubusercontent.com/{用户名}/{仓库名}/master/{本地文件夹}&lt;/code&gt;，“本地文件夹” 务必与上面设置的 “本地文件夹” 保持一致（结尾无/）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;设置自己的域名：可以使用 &lt;code&gt;Github Page 的域名&lt;/code&gt;，也可以用 CNAME 将自己的域名解析到 &lt;code&gt;Github Page 的域名&lt;/code&gt; 上, 然后将&lt;code&gt;https://raw.githubusercontent.com/{用户名}/{仓库名}/master/&lt;/code&gt; 替换成自己的域名就可以了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;插件预览&quot;&gt;插件预览&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://static.acme.top/wp-content/uploads/2019/07/paste-ac1ecbb94dfeb65dbe5fd75f49171446-1.png?w=1706&amp;amp;h=1266&quot; alt=&quot;设置页预览&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;常见问题&quot;&gt;常见问题&lt;/h2&gt;
&lt;p&gt;1、怎么替换文章中之前的旧资源地址链接&lt;/p&gt;
&lt;p&gt;这个插件已经加上了替换数据库中之前的旧资源地址链接功能，只需要填好对应的链接即可，如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.acme.top/wp-content/uploads/2019/07/paste-be19add5c14b2d259e53a8d1b67ee8e6-1.png?w=743&amp;amp;h=236&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;更新记录&quot;&gt;更新记录&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;V1.0 - 2019/07/23&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 GitHub 仓库存储 WordPress 站点图片等多媒体文件&lt;/li&gt;
&lt;li&gt;可配置是否上传缩略图和是否保留本地备份&lt;/li&gt;
&lt;li&gt;本地删除可同步删除腾讯云上面的文件&lt;/li&gt;
&lt;li&gt;支持替换数据库中旧的资源链接地址&lt;/li&gt;
&lt;li&gt;支持在图片链接地址后面自定义拼接图片宽度、高度、大小三个参数&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;感谢 Github 为开发者提供的服务，也希望大家能够善待 Github，毕竟存储和访问都是在消耗 Github 白花花的银子，切勿恶意滥用 ~&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jul 2019 00:44:00 +0000</pubDate>
<dc:creator>肆月之风</dc:creator>
<og:description>原文地址： 'https://acme.top/wp github gos' 前言 插件名称 ， 本插件核心功能使用了 GitHub API 设置页面和核心业务逻辑主要参考插件 'wordpress</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/acme-top/p/11248137.html</dc:identifier>
</item>
<item>
<title>如何在Windows上使用Python进行开发 - 葡萄城技术团队</title>
<link>http://www.cnblogs.com/powertoolsteam/p/11248091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/powertoolsteam/p/11248091.html</guid>
<description>&lt;blockquote readability=&quot;7.3478260869565&quot;&gt;
&lt;p&gt;本文由葡萄城技术团队于原创并首发&lt;/p&gt;
&lt;p&gt;转载请注明出处：&lt;a href=&quot;https://www.grapecity.com.cn/&quot; target=&quot;_blank&quot;&gt;葡萄城官网&lt;/a&gt;，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一直以来C#都是微软在编程语言方面最为显著的Tag，但时至今日Python已经从一个小众语言，变成了世界编程语言排行榜排名前列的语言了。&lt;/p&gt;
&lt;p&gt;Python也在Web开发、网络爬虫、数据分析、大数据处理、机器学习、科学计算及绘图等领域有着不错的天然优势和不俗的表现。微软再从收购了Github后，在开源社区投入的力度越来越大，所以对于Python的支持，和为Python社区提供更多的贡献，微软本身也承担起了更多的责任。&lt;/p&gt;
&lt;p&gt;所以近日，微软上线了一套Python教程《Develp with Python on Windows》，文档内容包括设置Python开发环境、在Windows与WSL子系统中安装相应开发工具，以及如何集成VS Code与Git工具并进行开发等。下来也让我们先来看看如何配置Python开发环境以及Hello World教程。&lt;/p&gt;
&lt;h2 id=&quot;set-up-your-development-environment&quot;&gt;&lt;span data-ttu-id=&quot;a5c60-106&quot;&gt;设置开发环境&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-107&quot;&gt;对于不熟悉 Python 的新手, 我们建议&lt;a href=&quot;https://www.microsoft.com/en-us/p/python-37/9nj46sx7x90p?activetab=pivot:overviewtab&quot; data-linktype=&quot;external&quot;&gt;从 Microsoft Store 安装 Python&lt;/a&gt;。 &lt;span data-ttu-id=&quot;a5c60-108&quot;&gt;通过 Microsoft Store 安装将使用 basic Python3 解释器, 但会为当前用户 (避免需要管理员访问权限) 设置路径设置, 并提供自动更新。 &lt;span data-ttu-id=&quot;a5c60-109&quot;&gt;如果你处于教育环境或组织中限制权限或管理访问权限的部分, 则此项特别有用。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-110&quot;&gt;如果在 Windows 上使用 Python 进行web 开发, 则建议为开发环境设置其他设置。 &lt;span data-ttu-id=&quot;a5c60-111&quot;&gt;建议通过适用于 Linux 的 Windows 子系统安装和使用 Python, 而不是直接在 Windows 上安装。 &lt;span data-ttu-id=&quot;a5c60-112&quot;&gt;有关帮助, 请参阅:&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/python/get-started/python-for-web&quot; data-linktype=&quot;relative-path&quot;&gt;开始在 Windows 上使用 Python 进行 web 开发&lt;/a&gt;。 &lt;span data-ttu-id=&quot;a5c60-113&quot;&gt;如果你有兴趣自动执行操作系统上的常见任务, 请参阅以下指南:&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows/python/get-started/python-for-scripting&quot; data-linktype=&quot;relative-path&quot;&gt;开始在 Windows 上使用 Python 进行脚本编写和自动化&lt;/a&gt;。 &lt;span data-ttu-id=&quot;a5c60-114&quot;&gt;对于某些高级方案 (例如需要访问/修改 Python 的已安装文件、创建二进制文件的副本或直接使用 Python Dll), 你可能需要考虑直接从&lt;a href=&quot;https://www.python.org/downloads/&quot; data-linktype=&quot;external&quot;&gt;python.org&lt;/a&gt;下载特定的 Python 版本, 或考虑安装一&lt;a href=&quot;https://www.python.org/download/alternatives&quot; data-linktype=&quot;external&quot;&gt;种替代方法&lt;/a&gt;, 如 Anaconda、Jython、PyPy、WinPython、IronPython 等。仅当你是更高级的 Python 程序员时, 才建议使用此方法, 具体原因是选择替代实现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;install-python&quot;&gt;&lt;span data-ttu-id=&quot;a5c60-115&quot;&gt;安装 Python&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-116&quot;&gt;使用 Microsoft Store 安装 Python:&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;8&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-117&quot;&gt;中转到 &quot;开始&quot; 菜单 (左下方的窗口图标), 键入 &quot;Microsoft Store&quot;, 选择用于打开应用商店的链接。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-118&quot;&gt;打开存储区后, 选择右上方菜单中的 &quot;搜索&quot;, 然后输入 &quot;Python&quot;。 &lt;span data-ttu-id=&quot;a5c60-119&quot;&gt;从 &quot;应用&quot; 下的结果中打开 &quot;Python 3.7&quot;。 &lt;span data-ttu-id=&quot;a5c60-120&quot;&gt;选择 &quot;获取&quot;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-121&quot;&gt;Python 完成下载和安装过程后, 请使用 &quot;开始&quot; 菜单 (左下方的窗口图标) 打开 Windows PowerShell。 &lt;span data-ttu-id=&quot;a5c60-122&quot;&gt;打开 PowerShell 后, 输入&lt;code&gt;Python --version&lt;/code&gt;以确认已在计算机上安装 Python3。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-123&quot;&gt;Python 的 Microsoft Store 安装包含pip, 即标准包管理器。 &lt;span data-ttu-id=&quot;a5c60-124&quot;&gt;Pip 允许你安装和管理不属于 Python 标准库的其他包。 &lt;span data-ttu-id=&quot;a5c60-125&quot;&gt;若要确认还具有用于安装和管理包的 pip, 请输入&lt;code&gt;pip --version&lt;/code&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;install-visual-studio-code&quot;&gt;&lt;span data-ttu-id=&quot;a5c60-126&quot;&gt;安装 Visual Studio Code&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-127&quot;&gt;通过使用 VS Code 作为文本编辑器/集成开发环境 (IDE), 可以利用&lt;a href=&quot;https://code.visualstudio.com/docs/editor/intellisense&quot; data-linktype=&quot;external&quot;&gt;IntelliSense&lt;/a&gt; (代码完成帮助) &lt;a href=&quot;https://code.visualstudio.com/docs/python/linting&quot; data-linktype=&quot;external&quot;&gt;Linting&lt;/a&gt; (有助于避免在代码中产生错误)、&lt;a href=&quot;https://code.visualstudio.com/docs/python/debugging&quot; data-linktype=&quot;external&quot;&gt;调试支持&lt;/a&gt;(帮助你在中查找错误)运行后的代码)、&lt;a href=&quot;https://code.visualstudio.com/docs/editor/userdefinedsnippets&quot; data-linktype=&quot;external&quot;&gt;代码片段&lt;/a&gt;(小型可重用代码块的模板) 以及&lt;a href=&quot;https://code.visualstudio.com/docs/python/unit-testing&quot; data-linktype=&quot;external&quot;&gt;单元测试&lt;/a&gt;(使用不同类型的输入测试代码的接口)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-128&quot;&gt;VS Code 还包含一个&lt;a href=&quot;https://code.visualstudio.com/docs/editor/integrated-terminal&quot; data-linktype=&quot;external&quot;&gt;内置终端&lt;/a&gt;, 使你能够使用 Windows 命令提示符、PowerShell 或你喜欢的任何方式打开 Python 命令行, 从而在你的代码编辑器和命令行之间建立无缝的工作流。&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;10.496261682243&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-129&quot;&gt;若要安装 VS Code, 请下载适用于&lt;a href=&quot;https://code.visualstudio.com/&quot; data-linktype=&quot;external&quot;&gt;https://code.visualstudio.com&lt;/a&gt;Windows 的 VS Code:。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9.6825396825397&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-130&quot;&gt;Python 是一种解释型语言, 若要运行 Python 代码, 必须告知 VS Code 要使用的解释器。&lt;span data-ttu-id=&quot;a5c60-131&quot;&gt;建议坚持使用 Python 3.7, 除非你有特定的原因要选择其他内容。 &lt;span data-ttu-id=&quot;a5c60-132&quot;&gt;若要选择 python 3 解释器, 请打开命令面板(Ctrl + Shift + P), 开始键入以下命令:选择 &quot; 解释器&quot; 进行搜索, 并选择命令。 &lt;span data-ttu-id=&quot;a5c60-133&quot;&gt;你还可以使用底部状态栏上的 &quot;选择 Python 环境&quot; 选项 (如果可用) (它可能已显示选定的解释器)。 &lt;span data-ttu-id=&quot;a5c60-134&quot;&gt;该命令显示 VS Code 可以自动查找的可用解释器列表, 包括虚拟环境。 &lt;span data-ttu-id=&quot;a5c60-135&quot;&gt;如果看不到所需的解释器, 请参阅&lt;a href=&quot;https://code.visualstudio.com/docs/python/environments&quot; data-linktype=&quot;external&quot;&gt;配置 Python 环境&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/windows/images/interpreterselection.gif&quot; alt=&quot;在 VS Code 中选择 Python 解释器&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-137&quot;&gt;若要在 VS Code 中打开终端, 请选择 &quot;查看 &amp;gt; 终端&quot;, 或者使用快捷方式Ctrl + ' (使用反撇号字符)。 &lt;span data-ttu-id=&quot;a5c60-138&quot;&gt;默认终端为 PowerShell。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-139&quot;&gt;在 VS Code 终端中, 只需输入以下命令即可打开 Python:&lt;code&gt;python&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-140&quot;&gt;输入以下内容, 尝试使用 Python 解释&lt;code&gt;print(&quot;Hello World&quot;)&lt;/code&gt;器:。 &lt;span data-ttu-id=&quot;a5c60-141&quot;&gt;Python 将返回语句 &quot;Hello World&quot;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/windows/images/python-in-vscode.png&quot; alt=&quot;VS Code 中的 Python 命令行&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;install-git-optional&quot;&gt;&lt;span data-ttu-id=&quot;a5c60-143&quot;&gt;安装 Git (可选)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-144&quot;&gt;如果你计划在 Python 代码上与其他人进行协作, 或在开源站点 (例如 GitHub) 上托管你的项目, VS Code 支持&lt;a href=&quot;https://code.visualstudio.com/docs/editor/versioncontrol#_git-support&quot; data-linktype=&quot;external&quot;&gt;使用 Git 进行版本控制&lt;/a&gt;。 &lt;span data-ttu-id=&quot;a5c60-145&quot;&gt;VS Code 中的 &quot;源代码管理&quot; 选项卡跟踪所有更改, 并在 UI 中内置内置的 Git 命令 (添加、提交、推送和拉取)。 &lt;span data-ttu-id=&quot;a5c60-146&quot;&gt;首先需要安装 Git 才能打开源代码管理面板。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.8252427184466&quot;&gt;&lt;li readability=&quot;-0.76666666666667&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-147&quot;&gt;从&lt;a href=&quot;https://git-scm.com/download/win&quot; data-linktype=&quot;external&quot;&gt;git-scm 网站&lt;/a&gt;下载并安装适用于 Windows 的 Git。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-148&quot;&gt;其中包含了一个安装向导, 该向导将询问一系列有关 Git 安装设置的问题。 &lt;span data-ttu-id=&quot;a5c60-149&quot;&gt;建议使用所有默认设置, 除非您有特定原因要更改某些内容。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-150&quot;&gt;如果以前从未处理过 Git, &lt;a href=&quot;https://guides.github.com/&quot; data-linktype=&quot;external&quot;&gt;GitHub 指南&lt;/a&gt;可帮助你入门。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;hello-world-tutorial-for-some-python-basics&quot;&gt;&lt;span data-ttu-id=&quot;a5c60-151&quot;&gt;有关某些 Python 基础知识的 Hello World 教程&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-152&quot;&gt;根据其 creator Guido van Rossum, Python 是一种 &quot;高级编程语言&quot;, 其核心设计理念全部与代码可读性和语法相关, 使程序员能够在几行代码中表达概念。 &quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-153&quot;&gt;Python 是一种解释型语言。 &lt;span data-ttu-id=&quot;a5c60-154&quot;&gt;与编译的语言不同, 你编写的代码需要转换为机器代码才能由计算机处理器运行, Python 代码直接传递给解释器并直接运行。 &lt;span data-ttu-id=&quot;a5c60-155&quot;&gt;只需键入代码并运行代码。 &lt;span data-ttu-id=&quot;a5c60-156&quot;&gt;试试吧!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;15&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-157&quot;&gt;打开 PowerShell 命令行后, 输入&lt;code&gt;python&lt;/code&gt;以运行 Python 3 解释器。 &lt;span data-ttu-id=&quot;a5c60-158&quot;&gt;(某些指令更喜欢使用命令&lt;code&gt;py&lt;/code&gt;或&lt;code&gt;python3&lt;/code&gt;, 它们也应该有效。) &lt;span data-ttu-id=&quot;a5c60-159&quot;&gt;你将知道, 你会成功, 因为将显示一个 &amp;gt; &amp;gt; &amp;gt; 提示, 其中三个符号为三个。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-160&quot;&gt;可以通过几种内置方法修改 Python 中的字符串。 &lt;span data-ttu-id=&quot;a5c60-161&quot;&gt;使用以下方式创建变量: &lt;code&gt;variable = 'Hello World!'&lt;/code&gt;。 &lt;span data-ttu-id=&quot;a5c60-162&quot;&gt;对于新行, 请按 Enter。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-163&quot;&gt;用以下内容打印变量&lt;code&gt;print(variable)&lt;/code&gt;:。 &lt;span data-ttu-id=&quot;a5c60-164&quot;&gt;这会显示文本 &quot;Hello World!&quot;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-165&quot;&gt;使用: &lt;code&gt;len(variable)&lt;/code&gt;查找字符串变量的长度和使用的字符数。 &lt;span data-ttu-id=&quot;a5c60-166&quot;&gt;这会显示使用了12个字符。 &lt;span data-ttu-id=&quot;a5c60-167&quot;&gt;(请注意, 该空格在总长度中被计为一个字符。)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-168&quot;&gt;将字符串变量转换为大写字母: &lt;code&gt;variable.upper()&lt;/code&gt;。 &lt;span data-ttu-id=&quot;a5c60-169&quot;&gt;现在将字符串变量转换为小写字母: &lt;code&gt;variable.lower()&lt;/code&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-170&quot;&gt;计算在字符串变量中使用字母 &quot;l&quot; 的次数: &lt;code&gt;variable.count(&quot;l&quot;)&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-171&quot;&gt;搜索字符串变量中的特定字符, 让我们查找感叹号, 使用: &lt;code&gt;variable.find(&quot;!&quot;)&lt;/code&gt;。 &lt;span data-ttu-id=&quot;a5c60-172&quot;&gt;这会显示感叹号位于字符串的第11个位置字符中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-173&quot;&gt;将感叹号替换为问号: &lt;code&gt;variable.replace(&quot;!&quot;, &quot;?&quot;)&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-174&quot;&gt;若要退出 Python, 可以输入&lt;code&gt;exit()&lt;/code&gt;、 &lt;code&gt;quit()&lt;/code&gt;或, 然后选择 Ctrl + z。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/windows/images/hello-world-basics.png&quot; alt=&quot;此教程的 PowerShell 屏幕截图&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-176&quot;&gt;希望使用 Python 的某些内置字符串修改方法时要开心。 &lt;span data-ttu-id=&quot;a5c60-177&quot;&gt;现在, 请尝试创建 Python 程序文件并使用 VS Code 运行该文件。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;hello-world-tutorial-for-using-python-with-vs-code&quot;&gt;&lt;span data-ttu-id=&quot;a5c60-178&quot;&gt;使用 Python 与 VS Code Hello World 教程&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-179&quot;&gt;VS Code 团队已结合了有关 Python 的精彩&lt;a href=&quot;https://code.visualstudio.com/docs/python/python-tutorial#_start-vs-code-in-a-project-workspace-folder&quot; data-linktype=&quot;external&quot;&gt;入门&lt;/a&gt;教程, 介绍如何使用 python 创建 Hello World 程序、运行程序文件、配置和运行调试器, 以及安装程序包 (例如&lt;em&gt;matplotlib&lt;/em&gt;和&lt;em&gt;numpy&lt;/em&gt;在虚拟环境中创建图形绘图。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-180&quot;&gt;1. 打开 PowerShell 并创建名为 &quot;hello&quot; 的空文件夹, 导航到此文件夹, 然后在 VS Code 中打开它:&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mkdir hello
cd hello
code .&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-181&quot;&gt;2. VS Code 打开后, 在左侧的资源管理器窗口中显示新的 &quot; &lt;em&gt;hello&lt;/em&gt; &quot; 文件夹, 通过按Ctrl + ' (使用反撇号) 或选择 &quot;查看 &amp;gt; &quot;,在VSCode的底部面板中打开命令行窗口。终端。 &lt;span data-ttu-id=&quot;a5c60-182&quot;&gt;通过在文件夹中开始 VS Code, 该文件夹将成为你的 &quot;工作区&quot;。 &lt;span data-ttu-id=&quot;a5c60-183&quot;&gt;VS Code 存储特定于 vscode/settings 中的工作区的设置, 它们不同于全局存储的用户设置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-184&quot;&gt;3. 继续 VS Code 文档中的教程:&lt;a href=&quot;https://code.visualstudio.com/docs/python/python-tutorial#_create-a-python-hello-world-source-code-file&quot; data-linktype=&quot;external&quot;&gt;创建 Python Hello World 源代码文件&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;create-a-simple-game-with-pygame&quot;&gt;&lt;span data-ttu-id=&quot;a5c60-185&quot;&gt;使用 Pygame 创建简单游戏&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.microsoft.com/zh-cn/windows/images/pygame-shmup.jpg&quot; alt=&quot;运行示例游戏的 Pygame&quot; data-linktype=&quot;relative-path&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-187&quot;&gt;Pygame 是一种流行的 Python 包, 用于编写游戏-鼓励学生学习编程, 同时创建有趣的东西。&lt;span data-ttu-id=&quot;a5c60-188&quot;&gt;Pygame 在新窗口中显示图形, 因此它将无法在 WSL 的命令行方法下运行。 &lt;span data-ttu-id=&quot;a5c60-189&quot;&gt;但是, 如果您通过本教程中所述的 Microsoft Store 安装了 Python, 它将正常工作。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-190&quot;&gt;安装 Python 后, 通过键入&lt;code&gt;python -m pip install -U pygame --user&lt;/code&gt;从命令行 (或 VS Code 内的终端) 安装 pygame。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-191&quot;&gt;通过运行示例游戏来测试安装:&lt;code&gt;python -m pygame.examples.aliens&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-192&quot;&gt;一切正常, 游戏就会打开一个窗口。 &lt;span data-ttu-id=&quot;a5c60-193&quot;&gt;完成播放后, 关闭窗口。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-194&quot;&gt;下面介绍了如何开始编写自己的游戏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-ttu-id=&quot;a5c60-195&quot;&gt;打开 PowerShell (或 Windows 命令提示符) 并创建一个名为 &quot;弹跳&quot; 的空文件夹。 &lt;span data-ttu-id=&quot;a5c60-196&quot;&gt;导航到此文件夹并创建一个名为 &quot;bounce.py&quot; 的文件。 &lt;span data-ttu-id=&quot;a5c60-197&quot;&gt;在 VS Code 中打开文件夹:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jul 2019 00:27:00 +0000</pubDate>
<dc:creator>葡萄城技术团队</dc:creator>
<og:description>本文由葡萄城技术团队于原创并首发 转载请注明出处：葡萄城官网，葡萄城为开发者提供专业的开发工具、解决方案和服务，赋能开发者。 一直以来C#都是微软在编程语言方面最为显著的Tag，但时至今日Python</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/powertoolsteam/p/11248091.html</dc:identifier>
</item>
<item>
<title>我造了个好大的&quot;轮子&quot;,居然还不是&quot;圆&quot;的! - 白菜园</title>
<link>http://www.cnblogs.com/BaiCai/p/11248064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BaiCai/p/11248064.html</guid>
<description>&lt;p&gt;  我造的这个&quot;轮子&quot;指的是集低代码开发与运维为一体的平台，为什么说它不是&quot;圆&quot;的，因为它有些与众不同，甚至可以说是有些另类。至于为什么造这个&quot;轮子&quot;，以及另类在什么地方且听我慢慢道来。&lt;/p&gt;

&lt;p&gt;  我是一个70后码农，开发过不计其数的系统，小到进销存大到电商、物联网甚至是省级平台。每次项目开始都要经历从技术选型、架构设计、开发、测试及最终生产环境部署运维等多个步骤。小项目还好随便一个单体架构就可以搞定，大项目特别是数据量较大的不仔细设计并考虑性能与扩展，随随便便就能把系统玩死。日复一日年复一年的编码，还得时时担心系统crash真是让我身心疲惫。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201907/4928-20190726080624570-1621675548.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  为什么？为什么码农就需要这么累？为什么会没有银弹，哪怕是近似的东东？我又到底需要什么？&lt;/p&gt;
&lt;h2 id=&quot;天下武功唯快不破&quot;&gt;天下武功唯快不破&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我需要的是能够快速的从无到有的开发出一套系统的工具，并且能够快速部署。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;简单的才是最美的&quot;&gt;简单的才是最美的&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我需要的是适用于中小规模的简单架构，并且依赖的技术越少越好。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;唯一不变的是变化&quot;&gt;唯一不变的是变化&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我需要的是能够随时适应需求变化，并且能够按需扩展的分布式架构。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;一切尽在掌握&quot;&gt;一切尽在掌握&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;我需要的是能够轻松掌握的系统状态，并且能尽早发现问题及时告警。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201907/4928-20190726080925348-1680092094.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  经历过痛苦与思考，才知道自己想要的是什么，因而我开始了漫长的寻找与学习过程。先是了解各类开发语言（包括可能您都没有听过的Vala），熟悉其优势、弱势及适用场景。然后学习各种类库及框架，只要觉得能加速开发过程便会研究一番并尝试应用于项目中。最后开始接触各类零代码低代码开发平台，包括国外的OutSystems，国内的起点等。但这些开发平台有些授权费用高，有些有各种各样的限制只能适用于特定场景，且大都是单体架构无法扩展，性能一般般对硬件的要求又高。总之没有我认为完美的技术或组合是我所需要的，难道真的应了“没有银弹”，只能继续疲惫下去。可我偏偏是个比较偏执的人，没有咱就来造一个，哪怕是只提高10%的效率减少10%的成本那就有意义。&lt;/p&gt;

&lt;p&gt;  一开始我只是想参照一些快速开发平台实现类似的功能，并且遵循“物得其所”的原则支持不同的存储技术（Sql, NoSql, 对象存储）。在此基础上我实现了一个版本（代号AppBox），但在实现过程中为了适配各类存储技术及相应的api我烦不胜烦，另外这么多技术叠加在一起对整个架构的部署与运维造成了不小的麻烦，总是觉得不完美太Low。&lt;/p&gt;
&lt;p&gt;  既然选择了造轮子，何不造个大一点的。所以我又开始动起了存储的念头，在学习了NewSql与NoSql技术后，我决定基于Raft与RocksDB直接实现分布式的存储集成在框架内，这样的话关系型数据、半结构化数据、非结构化数据的存储一并搞定。&lt;strong&gt;简单！完美！&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201907/4928-20190726080940914-2046704438.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  “路漫漫其修远兮，吾将上下而求索”，目前原型总算是有点模样了，虽打开代码满屏的TODO，但我抱着愚公移山的态度，相信只要每天码一点，总有一天码出一个近似完美的“巨轮”，也借此寻求志同道合者来共同完成这个“轮子”，共同实现&lt;strong&gt;Enjoy coding! Enjoy life!&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/4928/201907/4928-20190726080955056-594742318.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jul 2019 00:18:00 +0000</pubDate>
<dc:creator>白菜园</dc:creator>
<og:description>  我造的这个'轮子'指的是集低代码开发与运维为一体的平台，为什么说它不是'圆'的，因为它有些与众不同，甚至可以说是有些另类。至于为什么造这个'轮子'，以及另类在什么地方且听我慢慢</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/BaiCai/p/11248064.html</dc:identifier>
</item>
<item>
<title>机器学习之隐马尔可夫模型 - Fate0729</title>
<link>http://www.cnblogs.com/xiaobingqianrui/p/11238764.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobingqianrui/p/11238764.html</guid>
<description>&lt;p&gt;  本文主要是学习笔记，一方面是为了加强理解，感觉在做笔记过程中理解起来更简单，另一方面为了加强记忆，建立大脑关于‘隐马尔可夫模型’的神经网络&lt;/p&gt;

&lt;p&gt;在介绍隐马尔可夫模型之前先来看个例子：&lt;br/&gt;假设有4个盒子，每个盒子里面都装有红、白两种颜色的求，盒子里面的红包球数量如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201907/1117865-20190725161539089-485432383.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照下面的方式抽球，产生一个球的颜色的观测序列：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1)开始，从4个盒子里以等概率随机选取一个盒子，从这个盒子里随机抽出一个球，记录其颜色，然后放回&lt;/li&gt;
&lt;li&gt;(2)然后，从当前盒子随机转移到下一个盒子，规则是：如果当前盒子是盒子1，那么下一个盒子一定是盒子2，如果当前盒子是盒子2或3，那么分别以概率0.4和0.6转移到左边或右边的盒子，如果当前是盒子4，那么各以0.5的概率停留在盒子4或转移到盒子3&lt;/li&gt;
&lt;li&gt;(3)确定转移的盒子后，再从这个盒子里随机抽出一个球，记录其颜色，放回&lt;/li&gt;
&lt;li&gt;(4)如此下去，重复进行5次，得到一个球的颜色的观测序列：&lt;span class=&quot;math display&quot;&gt;\[O = (红，红，白，白，红)\]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这个过程中，观察者只能观测到球的颜色的序列，观测不到球是从哪个盒子取出的，即观测不到盒子的序列&lt;/p&gt;

&lt;p&gt;上面的例子是一个典型的&lt;strong&gt;隐马尔可夫模型&lt;/strong&gt;。有两个随机序列，一个是盒子的序列(状态序列)，一个是球的颜色的观测序列，前者是隐藏的，只有后者是可观测的。&lt;/p&gt;
&lt;p&gt;隐马尔可夫模型有三要素，表示为&lt;span class=&quot;math display&quot;&gt;\[\lambda = (A, B, \pi)\]&lt;/span&gt;&lt;br/&gt;注：A为状态转移矩阵，B为观测概率分布矩阵，&lt;span class=&quot;math inline&quot;&gt;\(\pi 为初始状态概率向量\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;通过上面的例子，来分别计算下A,B和&lt;span class=&quot;math inline&quot;&gt;\(\pi\)&lt;/span&gt;的值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;状态转移概率分布矩阵：&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ A = \left[ \begin{matrix} 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\ 0.4 &amp;amp; 0 &amp;amp; 0.4 &amp;amp; 0 \\ 0 &amp;amp; 0.4 &amp;amp; 0 &amp;amp; 0.6 \\ 0 &amp;amp; 0 &amp;amp; 0.5 &amp;amp; 0.5 \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(A[ij]\)&lt;/span&gt;表示从状态i转移到状态j的概率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;观测概率分布矩阵：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[ B = \left[ \begin{matrix} 0.5 &amp;amp; 0.5 \\ 0.3 &amp;amp; 0.7 \\ 0.6 &amp;amp; 0.4 \\ 0.8 &amp;amp; 0.2 \end{matrix} \right] \]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math inline&quot;&gt;\(B[i0]\)&lt;/span&gt;表示盒子i中取出红球的概率，&lt;span class=&quot;math inline&quot;&gt;\(B[i1]\)&lt;/span&gt;表示盒子i中取出白球的概率&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始概率分布：&lt;/strong&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\pi = (0.25,0.25,0.25,0.25)\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;(1) 概率计算问题&lt;/p&gt;
&lt;p&gt;给定模型&lt;span class=&quot;math inline&quot;&gt;\(\lambda = (A,B,\pi)\)&lt;/span&gt;和观测序列&lt;span class=&quot;math inline&quot;&gt;\(O = (o_1,o_2,...,0_T)\)&lt;/span&gt;,计算在模型&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;下观测模型出现的概率&lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2) 学习问题&lt;/p&gt;
&lt;p&gt;已知观测序列&lt;span class=&quot;math inline&quot;&gt;\(O = (o_1,o_2,...,0_T)\)&lt;/span&gt;,估计模型&lt;span class=&quot;math inline&quot;&gt;\(\lambda = (A,B,\pi)\)&lt;/span&gt;参数，使得在该模型下观测序列概率&lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda)\)&lt;/span&gt;最大，用极大似然估计的方法估计参数&lt;/p&gt;
&lt;p&gt;(3) 预测问题，也称为解码问题&lt;/p&gt;
&lt;p&gt;已知模型&lt;span class=&quot;math inline&quot;&gt;\(\lambda = (A,B,\pi)\)&lt;/span&gt;和观测序列&lt;span class=&quot;math inline&quot;&gt;\(O = (o_1,o_2,...,0_T)\)&lt;/span&gt;，求对给定观测序列条件概率&lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda)\)&lt;/span&gt;最大的状态序列&lt;span class=&quot;math inline&quot;&gt;\(I = (i_1,i_2,...,i_T)\)&lt;/span&gt;。即给定观测序列，求最有可能的对应的状态序列&lt;/p&gt;
&lt;p&gt;下面分别介绍针对不同问题的解决算法&lt;/p&gt;

&lt;h2 id=&quot;问题描述&quot;&gt;4.1 问题描述&lt;/h2&gt;
&lt;p&gt;给定模型&lt;span class=&quot;math inline&quot;&gt;\(\lambda = (A,B,\pi)\)&lt;/span&gt;和观测序列&lt;span class=&quot;math inline&quot;&gt;\(O = (o_1,o_2,...,0_T)\)&lt;/span&gt;,计算在模型&lt;span class=&quot;math inline&quot;&gt;\(\lambda\)&lt;/span&gt;下观测模型出现的概率&lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda)\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;前向算法&quot;&gt;4.2 前向算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(1) 计算状态t1下观测为红球的情况,注：序列和矩阵索引都从1开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一次从盒子1选择红球的情况：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_1(1) = \pi_1 B_1(o_1) = 0.25 * 0.5 = 0.125\]&lt;/span&gt;&lt;br/&gt;第一次从盒子2选择红球的情况：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_1(2) = \pi_2 B_2(o_1) = 0.25 * 0.3 = 0.075\]&lt;/span&gt;&lt;br/&gt;第一次从盒子3选择红球的情况：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_1(3) = \pi_3 B_3(o_1) = 0.25 * 0.6 = 0.15\]&lt;/span&gt;&lt;br/&gt;第一次从盒子4选择红球的情况：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_1(4) = \pi_4 B_4(o_1) = 0.25 * 0.8 = 0.20\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) 计算状态t2下观测为红球的情况，及第二次选择为红球的情况&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二次从盒子1选择红球的情况：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_2(1) = a_1(1)A_{11}B_1(o_2) + a_1(2)A_{21}B_1(o_2) + + a_1(3)A_{31}B_1(o_2) + + a_1(4)A_{41}B_1(o_2)\]&lt;/span&gt;&lt;br/&gt;第二次从盒子2选择红球的情况：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_2(2) = a_1(1)A_{12}B_2(o_2) + a_1(2)A_{22}B_2(o_2) + + a_1(3)A_{32}B_2(o_2) + + a_1(4)A_{42}B_2(o_2)\]&lt;/span&gt;&lt;br/&gt;第二次从盒子3选择红球的情况：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_2(3) = a_1(1)A_{13}B_3(o_2) + a_1(2)A_{23}B_3(o_2) + + a_1(3)A_{33}B_3(o_2) + + a_1(4)A_{43}B_3(o_2)\]&lt;/span&gt;&lt;br/&gt;第二次从盒子4选择红球的情况：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_2(4) = a_1(1)A_{14}B_4(o_2) + a_1(2)A_{24}B_4(o_2) + + a_1(3)A_{34}B_4(o_2) + + a_1(4)A_{44}B_4(o_2)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过上述规律我们得到公式:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 初值&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_1(i) = \pi(i)B_i(o_1)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2) 递推&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[a_{t+1}(i) = [\sum_{j=1}^N a_t(j)A_{ji}]B_i(o_{t+1}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(3) 终止&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P(O|\lambda) = \sum_{i=1}^N a_T(i)\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;后向算法&quot;&gt;4.3 后向算法&lt;/h2&gt;
&lt;p&gt;顾名思义，后向算法就是根据t时刻的观测序列概率算出t-1时刻观测序列的概率&lt;/p&gt;
&lt;p&gt;令在t时刻状态为&lt;span class=&quot;math inline&quot;&gt;\(q_i\)&lt;/span&gt;的条件下，从t+1到T的观测序列的概率为&lt;span class=&quot;math inline&quot;&gt;\(\beta_t(i)\)&lt;/span&gt;,则&lt;span class=&quot;math display&quot;&gt;\[\beta_t(i) = P(o_{t+1}，o_{t+2},...,o_T|i_t=q_i,\lambda)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要特别注意&lt;span class=&quot;math inline&quot;&gt;\(\beta_t(i)\)&lt;/span&gt;的定义，后面才能很好的理解&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;(1) 对最终时刻的所有状态&lt;span class=&quot;math inline&quot;&gt;\(q_i\)&lt;/span&gt;规定&lt;span class=&quot;math display&quot;&gt;\[\beta_T(i) = 1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2) &lt;span class=&quot;math display&quot;&gt;\[\beta_t(i) = \sum_{j=1}^N a_{ij}b_j(0_{t+1})\beta_{t+1}(j)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(3) &lt;span class=&quot;math display&quot;&gt;\[P(O|\lambda) = \sum_{i=1}^N\pi_ib_i(o_1)\beta_1(i)\]&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;问题描述-1&quot;&gt;5.1 问题描述&lt;/h2&gt;
&lt;p&gt;已知观测序列&lt;span class=&quot;math inline&quot;&gt;\(O = (o_1,o_2,...,0_T)\)&lt;/span&gt;,估计模型&lt;span class=&quot;math inline&quot;&gt;\(\lambda = (A,B,\pi)\)&lt;/span&gt;参数，使得在该模型下观测序列概率&lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda)\)&lt;/span&gt;最大，用极大似然估计的方法估计参数&lt;/p&gt;
&lt;p&gt;隐马尔可夫模型的学习，根据训练数据集是包括观测序列和对应的状态序列还是只有观测序列，可以分别由监督学习与无监督学习实现&lt;/p&gt;
&lt;p&gt;对于监督学习，由于数据集包含了观测序列和对应的状态序列，这样就可以直接根据利用数据集预估模型参数&lt;/p&gt;
&lt;p&gt;对于非监督学习，可以使用EM算对隐参数进行学习。EM算法参考附录&lt;/p&gt;

&lt;h2 id=&quot;问题描述-2&quot;&gt;6.1 问题描述&lt;/h2&gt;
&lt;p&gt;已知模型&lt;span class=&quot;math inline&quot;&gt;\(\lambda = (A,B,\pi)\)&lt;/span&gt;和观测序列&lt;span class=&quot;math inline&quot;&gt;\(O = (o_1,o_2,...,0_T)\)&lt;/span&gt;，求对给定观测序列条件概率&lt;span class=&quot;math inline&quot;&gt;\(P(O|\lambda)\)&lt;/span&gt;最大的状态序列&lt;span class=&quot;math inline&quot;&gt;\(I = (i_1,i_2,...,i_T)\)&lt;/span&gt;。即给定观测序列，求最有可能的对应的状态序列&lt;/p&gt;
&lt;h2 id=&quot;维特比算法&quot;&gt;6.2 维特比算法&lt;/h2&gt;
&lt;p&gt;维特比算法实际是用动态规划解隐马尔可夫模型预测问题，即用动态规划求概率最大路径&lt;/p&gt;
&lt;p&gt;定义两个变量：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\delta_t(i)\)&lt;/span&gt;表示在时刻t状态为i的所有单个路径中的最大概率值&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\delta_t(i) = max P(i_t=i,i_{t-1},...,i_1,o_t,...,o_1|\lambda), i = 1,2,...,N\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\psi_t(i)\)&lt;/span&gt;表示在时刻t状态为i的所有单个路径中概率最大的路径的第t-1个节点&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\psi_t(i) = arg max_{1&amp;lt;=j&amp;lt;=N} [\delta_{t-1}(j)a_{ji}],i = 1,2,...,N\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1) 初始化&lt;span class=&quot;math display&quot;&gt;\[\delta_1(i) = \pi_ib_i(o_1)\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\psi_1(i) = 0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2) 递推，对t=2,3,...,T&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\delta_t(i) = max_{1&amp;lt;=j&amp;lt;=N} [\delta_{t-1}(j)a_{ji}]b_i(o_t)\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\psi_t(i) = arg max_{1&amp;lt;=j&amp;lt;=N} [\delta_{t-1}(j)a_{ji}]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(3) 终止&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[P^* = max_{1&amp;lt;=i&amp;lt;=N}\delta_T(i)\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[i_T^* = arg max_{1&amp;lt;=i&amp;lt;=N} [\delta_T(i)]\]&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;em算法定义&quot;&gt;7.1 EM算法定义&lt;/h2&gt;
&lt;p&gt;输入：观测变量数据X，隐变量数据Z,联合分布&lt;span class=&quot;math inline&quot;&gt;\(P(X,Z|\theta)\)&lt;/span&gt;,也称为完全数据，这样更好理解点&lt;/p&gt;
&lt;p&gt;输出：模型参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1)选择初始模型参数&lt;span class=&quot;math inline&quot;&gt;\(\theta^{(0)}\)&lt;/span&gt;，开始迭代&lt;/p&gt;
&lt;p&gt;(2)E步：记&lt;span class=&quot;math inline&quot;&gt;\(\theta^{i}\)&lt;/span&gt;为第i次迭代参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;的估计值，计算在第i次迭代的期望&lt;span class=&quot;math display&quot;&gt;\[Q(\theta,\theta^{(i)}) = E(logP(x,z|\theta)|x,\theta^{(i)}))=\int_zlogp(x,z|\theta)p(z|\theta^{(i)})\]&lt;/span&gt;&lt;br/&gt;(3)M步：求使&lt;span class=&quot;math inline&quot;&gt;\(\theta^{(i+1)} = Q(\theta,\theta^{(i)})的最大值\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(4)重复第(2)步和第(3)步&lt;/p&gt;
&lt;h2 id=&quot;em算法几点说明&quot;&gt;7.2 EM算法几点说明&lt;/h2&gt;
&lt;p&gt;(1)参数的初值可以任意选择，但需注意EM算法对初始值是敏感的&lt;/p&gt;
&lt;p&gt;(2)E步求&lt;span class=&quot;math inline&quot;&gt;\(Q(\theta,\theta^{(i)})\)&lt;/span&gt;,Q函数中的Z是为隐变量，X是观测数据，&lt;span class=&quot;math inline&quot;&gt;\(Q(\theta,\theta^{(i)})\)&lt;/span&gt;中的第一个变元表示要极大化的参数，第二个变元表示参数的当前估计值，每次迭代实际在求Q的极大值&lt;/p&gt;
&lt;p&gt;(3)给出停止迭代的条件，一般是对较小的正数&lt;span class=&quot;math inline&quot;&gt;\(\xi_i,\xi_2\)&lt;/span&gt;,若满足&lt;span class=&quot;math inline&quot;&gt;\(||\theta^{(i+1)} - \theta^{(i)} &amp;lt; \xi_i||或||Q(\theta^{(i+1)},\theta^{(i)})-Q(\theta^{(i)},\theta^{(i)})|| &amp;lt; \xi_2\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;em算法推导&quot;&gt;7.3 EM算法推导&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[L(\theta)= argmaxlogP(x|\theta) = argmaxlog\int_zp(x,z|\theta)dz\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[L(\theta) = argmaxlog\int_z\frac{p(x,z|\theta)}{p(z|\theta^{(i)})}p(z|\theta^{(i)})dz\]&lt;/span&gt;&lt;br/&gt;由于log函数为凹函数，则&lt;span class=&quot;math display&quot;&gt;\[L(\theta) \geq \int_zlog\frac{p(x,z|\theta)}{p(z|\theta^{(i)})}p(z|\theta^{(i)})dz\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[L(\theta) \geq \int_zlogp(x,z|\theta)p(z|\theta^{(i)})dz - \int_zlog(p(z|\theta^{(i)}))p(z|\theta^{(i)})dz\]&lt;/span&gt;&lt;br/&gt;由于减式后面与模型参数&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;无关，&lt;span class=&quot;math inline&quot;&gt;\(P(z|\theta^{(i)})是已知的\)&lt;/span&gt;，所以只需关注减式前面的式子，令&lt;span class=&quot;math display&quot;&gt;\[Q(\theta,\theta^{(i)})=\int_zlogp(x,z|\theta)p(z|\theta^{(i)})\]&lt;/span&gt;&lt;br/&gt;和算法定义中的步骤(2)相同，将原L的优化问题转换为求原问题下界&lt;span class=&quot;math inline&quot;&gt;\(Q(\theta,\theta^{(i)})\)&lt;/span&gt;的最大值&lt;br/&gt;因此，任何可以使&lt;span class=&quot;math inline&quot;&gt;\(Q(\theta,\theta^{(i)})\)&lt;/span&gt;增大的&lt;span class=&quot;math inline&quot;&gt;\(\theta\)&lt;/span&gt;都可以使&lt;span class=&quot;math inline&quot;&gt;\(L(\theta)\)&lt;/span&gt;增大,为了使&lt;span class=&quot;math inline&quot;&gt;\(L(\theta)\)&lt;/span&gt;有尽可能的增长，选择使&lt;span class=&quot;math inline&quot;&gt;\(Q(\theta,\theta^{(i)})\)&lt;/span&gt;达到最大，即&lt;span class=&quot;math display&quot;&gt;\[\theta^{(i+1)} = argmaxQ(\theta,\theta^{(i)})\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;em算法收敛性&quot;&gt;7.4 EM算法收敛性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定理1&lt;/strong&gt;：&lt;span class=&quot;math inline&quot;&gt;\(设P(x|\theta)为观测数据的似然函数，\theta^{(i)}为EM算法得到的参数估计序列，P(x|\theta^{(i)})为对应的似然函数序列，则P(x|\theta^{(i)})单调递增\)&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;定理2&lt;/strong&gt;：&lt;span class=&quot;math inline&quot;&gt;\(设L(\theta) = logP(x|\theta)为观测数据的似然函数，\theta^{(i)}为EM算法得到的参数估计序列，L(\theta^{(i)})为对应的似然函数序列\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1)&lt;span class=&quot;math inline&quot;&gt;\(如果P(x|\theta)有上界，则L(\theta^{(i)})收敛到某一值L^*\)&lt;/span&gt;&lt;br/&gt;(2)&lt;span class=&quot;math inline&quot;&gt;\(在函数Q(\theta,\theta^{(i)})与L(\theta)满足一定条件下，由EM算法得到的参数估计序列\theta^{(i)}的收敛值\theta^*是L(\theta)的稳定值\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以上为EM算法的'官方'说明，若不理解可以参考博客https://www.jianshu.com/p/1121509ac1dc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后针对隐马尔可夫模型抛出抛出两个问题：&lt;/p&gt;
&lt;p&gt;  (1) 如何对中文分词问题用隐马尔可夫模型进行建模和训练？&lt;/p&gt;
&lt;p&gt;  (2) 最大熵马尔可夫模型为什么会产生标注偏置问题？如何解决？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;br/&gt;李航老师的《统计学习方法》&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jul 2019 00:10:00 +0000</pubDate>
<dc:creator>Fate0729</dc:creator>
<og:description>  本文主要是学习笔记，一方面是为了加强理解，感觉在做笔记过程中理解起来更简单，另一方面为了加强记忆，建立大脑关于‘隐马尔可夫模型’的神经网络 1. 模型场景 在介绍隐马尔可夫模型</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaobingqianrui/p/11238764.html</dc:identifier>
</item>
<item>
<title>.net持续集成sonarqube篇之项目管理与用户管理 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11248059.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11248059.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;删除项目&quot;&gt;删除项目&lt;/h2&gt;
&lt;p&gt;在学习阶段,我们可能需要经常删除已构建的项目,在sonarqube中想要删除一个项目有两个入口,都在&lt;code&gt;Administration&lt;/code&gt;导航栏内.&lt;/p&gt;
&lt;h2 id=&quot;在项目内部的管理界面删除&quot;&gt;在项目内部的管理界面删除&lt;/h2&gt;
&lt;p&gt;如果项目处于打开状态,如下图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190726080717038-2007263971.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击&lt;code&gt;Administration&lt;/code&gt;会出现一个下拉菜单,其中最后一项为Deletion,点击后进入提示是否删除界面,确认删除即可.&lt;/p&gt;
&lt;h2 id=&quot;从主控台-管理界面内删除&quot;&gt;从主控台 管理界面内删除&lt;/h2&gt;
&lt;p&gt;如果我们要删除多个项目,分别进入每个项目,然后点击删除再返回主界面再进入下一个要删除的项目...这样显然是低效的.这种场景我们可以从主控台的&lt;code&gt;Administration&lt;/code&gt;导航标签内进入删除.&lt;/p&gt;
&lt;p&gt;我们点击下图示框选部分&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190726080710010-1924692785.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击后进入如下界面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190726080703746-959819794.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们点击&lt;code&gt;Projects&lt;/code&gt;从出现的下拉列表中选择&lt;code&gt;Management&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;执行下图示操作,即先选中要删除的项目(可以选中多个),然后点击&lt;code&gt;delete&lt;/code&gt;按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190726080657684-1483065705.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建用户&quot;&gt;创建用户&lt;/h2&gt;
&lt;p&gt;点击主控制台的&lt;code&gt;administration&lt;/code&gt;进入的界面中有一个&lt;code&gt;Security&lt;/code&gt;选项卡,如下图示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190726080651055-1188788980.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照图未便可以创建一个新用户了.&lt;/p&gt;
&lt;h2 id=&quot;修改用户密码和删除用户&quot;&gt;修改用户密码和删除用户&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190726080644666-862747347.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示,点击用户后面的齿轮从下拉列表里选择&lt;code&gt;change password&lt;/code&gt;便可以修改用户密码了.点击&lt;code&gt;Deactive&lt;/code&gt;实际上就相当于删除了用户&lt;/p&gt;
&lt;h2 id=&quot;重置管理员密码&quot;&gt;重置管理员密码&lt;/h2&gt;
&lt;p&gt;前面我们介绍过,管理员的初始账户和密码都是admin,我们可以通过上面的讲解修改管理员密码.但是管理员密码忘记了如何操作呢?这个时候web管理界面没法进入了,只能通过sql语句来把管理员密码重置为admin&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;update users set crypted_password = '$2a$12$uCkkXmhW5ThVK8mpBvnXOOJRLd64LJeHTeCkSuB3lfaR2N0AYBaSi', salt=null, hash_method='BCRYPT' where login = 'admin'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上sql语句即可把管理员败户密码重置为admin&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jul 2019 00:09:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 删除项目 在学习阶段,我们可能需要经常删除已构建的项目,在sonarqube中想要删除一个项目有两个入口,都在 导航栏内. 在项目内部的管理界面删除 如果项目处于打开状态,如下图示 点击</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11248059.html</dc:identifier>
</item>
<item>
<title>重复造轮子系列——基于Ocelot实现类似支付宝接口模式的网关 - sylla</title>
<link>http://www.cnblogs.com/sylla/p/11248027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sylla/p/11248027.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;重复造轮子系列是自己平时的一些总结。有的轮子依赖社区提供的轮子为基础，这里把使用过程的一些觉得有意思的做个分享。有些思路或者方法在大神看来可能会比较low。但是能解决实际问题，相信有需要的人也在寻找类似的解决方案。这里可以算作是提供了一种思路，类似问题如果有读者能有更好的解决方案，愿闻其详。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若有阅读后引起内心冲突或者愤怒等不适以及自觉被误导者，不需要切换到抖音等欢乐频道进行综合调理，直接就可以在评论区吐槽。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;网关简介&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;什么是网关，为什么用网关。这些问题网上有很多文章，讲解的非常全面。这里就不做重复的讲解了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但后面的内容至少需要了解网关下面两点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;API网关是一个服务器，是系统的唯一入口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;API网关方式的核心要点是，所有的客户端和消费端都通过统一的网关接入微服务，在网关层处理所有的非业务功能（提供监控、鉴权、负载均衡等）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;默认实现&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下面演示的项目使用vs2019，Asp.Net Core 2.1开发&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、创建一个ASP.NET Core API项目Agile.Demo1.API，使用Swagger作为在线UI展示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;项目结构如图1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073220737-1040506771.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;发布并且运行，为了方面启动运行，写了个批处理脚本，如图2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073228693-900694933.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接双击start运行如图3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073236687-583343375.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浏览器打开显示效果如图4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073243505-1883831419.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直接Swagger文档在线测试各个接口正常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、创建一个ASP.NET Core API项目Agile.Demo2.API 与Agile.Demo1.API项目类似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、创建一个基于ocelot的网关服务，项目结构如图5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073253072-1810344682.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里使用Ocelot来做网关，Ocelot是一堆特定顺序的中间件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置ocelot.json，配置内容如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{

  &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReRoutes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;API01 业务接口1&lt;/span&gt;
&lt;span&gt;
    {

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{url}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [

        {

          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9001&lt;/span&gt;&lt;span&gt;

        }

      ],

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/demo1/{url}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHttpMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ],

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReRoutesCaseSensitive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;

    },

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;API02 业务接口2&lt;/span&gt;
&lt;span&gt;
    {

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{url}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [

        {

          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9002&lt;/span&gt;&lt;span&gt;

        }

      ],

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/demo2/{url}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHttpMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Post&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ],

      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReRoutesCaseSensitive&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;

    }

  ]

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个配置比较简单，就配置了两个下游的业务接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把两个业务接口站点和网关站点都运行起来，如图6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073301255-1280561367.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用postman直接测试demo1 里面的 saveorder接口，如图7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073308345-992271286.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用postman直接测试demo2 里面的 saveorder接口，如图8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073314992-209853512.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用postman通过网关访问demo1，如图9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073323707-70451836.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;能正常返回数据，说明网关的转发正常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过网关访问demo2也类似，这里就不截图了。下面提供demo代码可以下载自己测试下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里只介绍，通过网关的转发，其他网关方面的更多应用不在这里做介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;新的问题&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;有一次，我们提供接口和其他部门对接。按照惯例把接口以及网关部署好，文档提供，让他们按照文档规定的传就可以了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;结果，他们看了文档后提出了疑问，这是什么网关。每个接口请求地址还得拼接出来作为完整的请求，我们代码要做很多调整啊。能不能做成支付宝那种，就一个地址固定不变，然后公共参数，业务参数封装的模式。因为这种模式封装的东西都有现成的，这样我们就不用很大的改动就可以快速对接了。看下&lt;a href=&quot;https://docs.open.alipay.com/api_1/alipay.trade.pay&quot; target=&quot;_blank&quot;&gt;支付宝接口&lt;/a&gt;，如图10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073332963-1447682692.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我想你这公共参数还不是动态的，相当于原来我们提供的网关地址后面加的就是对应的动态数据，道理都一样的啊，但受阿里系影响，他们接口的开发还是对接都是习惯按照支付宝这种模式来的，封装的公共参数什么的都做好了，要调整很麻烦。接口不按照他们的样子来就别扭，增加他们工作量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当时我想这怎么办，我出接口应该按照我们的要求来啊，但没办法不够强势，还得按照他们阿里系规则来，那就想办法吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想到ocelot也是一系列的中间件处理 的，我想那就增加一个中间件，把请求给拦截了，重新组合数据，再下发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样可以保证我们内部的调用不变，对外兼容这种请求方式。说干就干，先做个demo试验下能否行得通。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;增加一个中间件GatewayMiddleware，代码如下，既然要按照支付宝接口的来，那干脆把公共参数这块整体搬过来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; You may need to install the Microsoft.AspNetCore.Http.Abstractions package into your project&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GatewayMiddleware

    {

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;

 

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GatewayMiddleware(RequestDelegate next)

        {

            _next &lt;/span&gt;=&lt;span&gt; next;

        }

 

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(HttpContext httpContext)

        {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;支持类似支付宝的网关模式

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;公共请求参数

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;app_id method format charset sign_type sign timestamp version app_auth_token biz_content

 

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求参数(业务)，建议json格式

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;trade_no  out_trade_no operator_id&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt; (httpContext.Request.Path.ToString().ToLower() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/gateway&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;|| httpContext.Request.Path.ToString().ToLower() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/gateway.do&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

            {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用方post form提交，获取公共请求参数，处理做转发&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt; (httpContext.Request.Method.ToLower() == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

                {

                    httpContext.Response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/plain;charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; httpContext.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调试错误，请回到请求来源地，重新发起请求&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

                }

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; reqForm =&lt;span&gt; httpContext.Request.Form;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (reqForm == &lt;span&gt;null&lt;/span&gt; || reqForm.Count == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                {

                    httpContext.Response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/plain;charset=utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                    &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; httpContext.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;调试错误，请回到请求来源地，重新发起请求&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

                }

 

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app_id = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;appid&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; method = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;method&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接口名称（格式：模块.控制器.方法） 比如demo1.Values.SaveOrder&lt;/span&gt;

                &lt;span&gt;var&lt;/span&gt; format = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;format&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; charset = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sign_type = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign_type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;md5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sign = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sign&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; timestamp = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timestamp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; version = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; app_auth_token = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app_auth_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;app_auth_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; biz_content = reqForm.ContainsKey(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;biz_content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ? reqForm[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;biz_content&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;].ToString() : &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;业务接口参数 json格式

 

                

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过method参数拆分出 模块 控制器 方法&lt;/span&gt;

                &lt;span&gt;var&lt;/span&gt; methods = method.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; moduleName = method.Length &amp;gt; &lt;span&gt;0&lt;/span&gt; ? methods[&lt;span&gt;0&lt;/span&gt;] : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; controllerName = method.Length &amp;gt; &lt;span&gt;1&lt;/span&gt; ? methods[&lt;span&gt;1&lt;/span&gt;] : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; actionName = method.Length &amp;gt; &lt;span&gt;2&lt;/span&gt; ? methods[&lt;span&gt;2&lt;/span&gt;] : &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

 

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;区分有版本和无版本两种情况，version不传或传空就是无版本&lt;/span&gt;

                &lt;span&gt;var&lt;/span&gt; nextPath = &lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(version) ? $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{moduleName}/api/{controllerName}/{actionName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; : $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/{moduleName}/api/v{version}/{controllerName}/{actionName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

 

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下游业务接口暂时只支持post json格式的请求&lt;/span&gt;

                &lt;span&gt;byte&lt;/span&gt;[] postData =&lt;span&gt; Encoding.GetEncoding(charset).GetBytes(biz_content);

                httpContext.Request.Path &lt;/span&gt;=&lt;span&gt; nextPath;

                httpContext.Request.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                httpContext.Request.ContentLength &lt;/span&gt;=&lt;span&gt; postData.Length;

                httpContext.Request.Body &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream(postData);                

 

                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(httpContext);

            }

            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;

            {

                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(httpContext);

            }

        }

    }

 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Extension method used to add the middleware to the HTTP request pipeline.&lt;/span&gt;

    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GatewayMiddlewareExtensions

    {

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; UseGatewayMiddleware(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IApplicationBuilder app)

        {

            app.UseMiddleware&lt;/span&gt;&amp;lt;GatewayMiddleware&amp;gt;&lt;span&gt;();

        }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Startup.cs增加如下代码，如图11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073816759-2136438635.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;测试拦截成功，重新组装下发。能够正常返回，测试成功。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体的操作看代码的说明，这里就不再赘述。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里有一点要特别说明。因为公共参数是form表单post提交，所以调用方请求过来肯定是post方式。转到下游的时候这个请求类型没有改变，所有暂时只支持下游是post的接口。不过可以增加个参数或者使用format参数值来做区分下游具体是get还是post。因为现在format是json肯定只能是支持post。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;测试联调&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;以访问demo1为例，这里有三种方式访问demo1，使用postman测试如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、直接访问，如上面图7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、通过网关转发方式1，如上面图9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、通过网关转发方式2，如图12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190726073344138-485466011.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用这种方式还是有优势的，比如参数签名这块就可以从业务里面独立出来，在网关处理了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;说服不了，就多干活，多想方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于一个文件最大10M，这里拆开上传&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://files.cnblogs.com/files/sylla/API%E6%A1%88%E4%BE%8B1.zip&quot; target=&quot;_blank&quot;&gt;APIDemo1代码下载&lt;/a&gt;,&lt;a href=&quot;https://files.cnblogs.com/files/sylla/API%E6%A1%88%E4%BE%8B2.zip&quot; target=&quot;_blank&quot;&gt;APIDemo2代码下载&lt;/a&gt;,&lt;a href=&quot;https://files.cnblogs.com/files/sylla/API%E7%BD%91%E5%85%B3.zip&quot; target=&quot;_blank&quot;&gt;APIGateway代码下载&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感谢阅读，希望这篇文章能给你带来帮助！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jul 2019 23:46:00 +0000</pubDate>
<dc:creator>sylla</dc:creator>
<og:description>网关 API Ocelot</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sylla/p/11248027.html</dc:identifier>
</item>
<item>
<title>JAVA面试题 String s = new String(&quot;xyz&quot;);产生了几个对象？ - Java蚂蚁</title>
<link>http://www.cnblogs.com/marsitman/p/11248001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsitman/p/11248001.html</guid>
<description>&lt;p&gt;面试官Q1：请问String s = new String(&quot;xyz&quot;);产生了几个对象？&lt;/p&gt;
&lt;p&gt;对于这个Java面试题，老套路先上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class StringTest {
    public static void main(String[] args){
        String s1=&quot;Hello&quot;;
        String s2=&quot;Hello&quot;;
        String s3=new String(&quot;Hello&quot;);
        System.out.println(&quot;s1和s2 引用地址是否相同：&quot;+(s1 == s2));
        System.out.println(&quot;s1和s2 值是否相同：&quot;+s1.equals(s2));
        System.out.println(&quot;s1和s3 引用地址是否相同：&quot;+(s1 == s3));
        System.out.println(&quot;s1和s3 值是否相同：&quot;+s1.equals(s3));
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
s1和s2 引用地址是否相同：true
s1和s2 值是否相同：true
s1和s3 引用地址是否相同：false
s1和s3 值是否相同：true
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面程序中的&quot;==&quot;是判断两个对象引用的地址是否相同，也就是判断是否为同一个对象，s1与s2 返回为true，s1与s3返回则是false。说明s1与s2 引用的同一个对象的地址，s3则与其它两个引用不是同一个对象地址。&lt;/p&gt;
&lt;p&gt;Java为了避免产生大量的String对象，设计了一个字符串常量池。工作原理是这样的，创建一个字符串时，JVM首先为检查字符串常量池中是否有值相等的字符串，如果有，则不再创建，直接返回该字符串的引用地址，若没有，则创建，然后放到字符串常量池中，并返回新创建的字符串的引用地址。所以上面s1与s2引用地址相同。&lt;/p&gt;
&lt;p&gt;那为什么s3与s1、s2引用的不是同一个字符串地址呢？ String s3=new String(&quot;Hello&quot;); JVM首先是在字符串常量池中找&quot;Hello&quot; 字符串，如果没有创建字符串常量，然后放到常量池中，若已存在，则不需要创建；当遇到 new 时，还会在内存（不是字符串常量池中，而是在堆里面）上创建一个新的String对象，存储&quot;Hello&quot;，并将内存上的String对象引用地址返回，所以s3与s1、s2引用的不是同一个字符串地址。 内存结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1223046/201907/1223046-20190726071102767-913031096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从内存图可见，s1与s2指向的都是常量池中的字符串常量，所以它们比较的是同一块内存地址，而s3指向的是堆里面的一块地址，说的具体点应该是堆里面的Eden区域，s1跟s3，s2跟s3比较都是不相等的，都不是同一块地址。&lt;/p&gt;

&lt;p&gt;了解了String类的工作原理，回归问题本身：&lt;/p&gt;
&lt;p&gt;在String的工作原理中，已经提到了，new一个String对象，是需要先在字符串常量中查找相同值或创建一个字符串常量，然后再在内存中创建一个String对象，所以String str = new String(&quot;xyz&quot;); 会创建两个对象。&lt;/p&gt;

&lt;p&gt;下面两道Java面试题可以放在留言区回复哟：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
String str1 = new String(&quot;A&quot;+&quot;B&quot;) ; 会创建多少个对象? 
String str2 = new String(&quot;ABC&quot;) + &quot;ABC&quot; ; 会创建多少个对象?
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/marsitman/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Java蚂蚁&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/marsitman/p/11248001.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/marsitman/p/11248001.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;版权：转载请在文章明显位置注明作者及出处。&lt;/strong&gt;&lt;/span&gt;　　　&lt;/p&gt;
</description>
<pubDate>Thu, 25 Jul 2019 23:14:00 +0000</pubDate>
<dc:creator>Java蚂蚁</dc:creator>
<og:description>面试官Q1：请问String s = new String(&quot;xyz&quot;);产生了几个对象？ 对于这个Java面试题，老套路先上代码： 打印结果如下： 上面程序中的&quot;==&amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/marsitman/p/11248001.html</dc:identifier>
</item>
</channel>
</rss>