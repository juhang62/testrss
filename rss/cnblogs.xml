<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>从零开始认识堆排序 - WindWant</title>
<link>http://www.cnblogs.com/niejunlei/p/13195939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niejunlei/p/13195939.html</guid>
<description>&lt;h2&gt;一、什么是堆？&lt;/h2&gt;
&lt;p&gt;维基百科的解释是：堆是一种特别的树状数据结构，它需要满足任意的子节点必须都大于等于（最大堆）或者小于等于（最小堆）其父节点。&lt;/p&gt;
&lt;h2&gt;二、堆排序&lt;/h2&gt;
&lt;p&gt;堆排序是通过二叉堆数据结构实现，二叉堆满足一下两个特性：&lt;/p&gt;
&lt;p&gt;1、满足对的基本特性&lt;/p&gt;
&lt;p&gt;2、完全二叉树，除了最底层外，其它层都已填充满，且是从左到右填充。&lt;/p&gt;
&lt;p&gt;二叉堆的高度即为根节点到叶子节点的最长简单路径长度，即为θ(lgn)。&lt;/p&gt;
&lt;p&gt;二叉堆上的操作时间复杂度为O(lgn)。&lt;/p&gt;
&lt;h3&gt;1、二叉堆中的元素个数&lt;/h3&gt;
&lt;p&gt;根据二叉堆的特性2，我们知道高度为h的二叉堆重元素个数如下：&lt;/p&gt;
&lt;p&gt;根节点为1&lt;sup&gt;&lt;br/&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;第一层为2=2&lt;sup&gt;1&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;第二层为4=2&lt;sup&gt;2&lt;/sup&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;第h-1层为2&lt;sup&gt;h-1&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;第h层元素个数范围为[1，2&lt;sup&gt;h&lt;/sup&gt;]&lt;/p&gt;
&lt;p&gt;最底层之外的元素个数和为1+2+2&lt;sup&gt;2&lt;/sup&gt;+...+2&lt;sup&gt;h-1&lt;/sup&gt;=(1-2&lt;sup&gt;h-1&lt;/sup&gt;)/(1-2)=2&lt;sup&gt;h&lt;/sup&gt;-1&lt;/p&gt;
&lt;p&gt;高度为h的二叉堆元素个数范围：[2&lt;sup&gt;h&lt;/sup&gt;-1 + 1，2&lt;sup&gt;h&lt;/sup&gt;-1+2&lt;sup&gt;h&lt;/sup&gt;]=[2&lt;sup&gt;h&lt;/sup&gt;，2&lt;sup&gt;h+1&lt;/sup&gt;-1]&lt;/p&gt;
&lt;p&gt;以高度为3的最大堆为例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200626175255233-800975465.png&quot; alt=&quot;&quot; width=&quot;411&quot; height=&quot;257&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200626180702305-1371248305.png&quot; alt=&quot;&quot; width=&quot;466&quot; height=&quot;256&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图2&lt;/p&gt;
&lt;h3&gt;2、二叉堆的高度&lt;/h3&gt;
&lt;p&gt;由二.1推导，我们知道高度为h的二叉堆的元素个数n满足：&lt;/p&gt;
&lt;p&gt;2&lt;sup&gt;h &lt;/sup&gt;≦ n ≦ 2&lt;sup&gt;h+1&lt;/sup&gt;-1&lt;/p&gt;
&lt;p&gt;=&amp;gt;&lt;/p&gt;
&lt;p&gt;2&lt;sup&gt;h &lt;/sup&gt;≦ 2&lt;sup&gt;lgn&lt;/sup&gt; ≦ 2&lt;sup&gt;h+1&lt;/sup&gt;-1&lt;/p&gt;
&lt;p&gt;=&amp;gt;&lt;/p&gt;
&lt;p&gt;h&lt;sup&gt; &lt;/sup&gt;≦ lgn &amp;lt; h+1&lt;/p&gt;
&lt;p&gt;由此可得，含有n个元素的二叉堆的高度为θ(lgn)&lt;/p&gt;
&lt;h3&gt;3、使用数组表示堆存储&lt;/h3&gt;
&lt;p&gt;节点下标 i，则父节点下标为 i/2，左子节点下标为 2i，右子节点下标 2i + 1。&lt;/p&gt;
&lt;p&gt;以图1最大堆为例：&lt;/p&gt;
&lt;p&gt;从根节点开始，根节点下标 1。&lt;/p&gt;
&lt;p&gt;第一层节点下标：2、3&lt;/p&gt;
&lt;p&gt;第二层节点下标：4、5、6、7&lt;/p&gt;
&lt;p&gt;第三层节点下标：8&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200626190955250-1264480765.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;316&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3&lt;/p&gt;
&lt;p&gt;数组形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200626192224116-1841217273.png&quot; alt=&quot;&quot; width=&quot;463&quot; height=&quot;109&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 图4&lt;/p&gt;
&lt;p&gt;具体到特定的编程语言，数组以0开始下标的，推导：&lt;/p&gt;
&lt;p&gt;对于节点 i，则其父节点为 (i - 1)/2，左子节点下标为 2i + 1，右子节点下标 2i + 2。&lt;/p&gt;
&lt;h3&gt;4、堆的叶子节点&lt;/h3&gt;
&lt;p&gt;对于有n个元素的二叉堆，最后一个元素的下标为为n，根据二叉堆的性质，其父节点下标为n/2，因为每一层是由左向右进行构建，所以其父节点也是倒数第二层的最后一个节点，所以，其后的节点都为最底层节点，为叶子节点，下标为n/2 + 1、n/2 + 2... n。&lt;/p&gt;
&lt;p&gt;具体到特定的编程语言，数组以0开始下标的，推到：&lt;/p&gt;
&lt;p&gt;叶子节点下标为(n-1)/2 + 1、(n-1)/2 + 2... n。&lt;/p&gt;
&lt;h3&gt;5、堆维护&lt;/h3&gt;
&lt;p&gt;所谓堆维护，即保持堆的基本特性，以最大堆为例：给定某个节点，维护使得以其为根节点的子堆为满足子节点都小于等于父节点。&lt;/p&gt;
&lt;p&gt;如下，给定堆构建数组，及特定元素下标i：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static void&lt;/span&gt; maxHeapify(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; i) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = arr.length; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;堆大小&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; maxIndex = i; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录当前节点及其子节点的最大值节点索引&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; left = 2 * i + 1; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左子节点索引&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; right = 2 * i + 2; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;右子节点索引

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对比节点及其左子节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (left &amp;lt; size &amp;amp;&amp;amp; arr[left] &amp;gt;&lt;span&gt; arr[maxIndex]) {
            maxIndex &lt;/span&gt;=&lt;span&gt; left;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对比节点及其右子节点&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (right &amp;lt; size &amp;amp;&amp;amp; arr[right] &amp;gt;&lt;span&gt; arr[maxIndex]) {
            maxIndex &lt;/span&gt;=&lt;span&gt; right;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;不满足最大堆性质，则进行下沉节点i，递归处理&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (maxIndex !=&lt;span&gt; i) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; tmp =&lt;span&gt; arr[i];
            arr[i] &lt;/span&gt;=&lt;span&gt; arr[maxIndex];
            arr[maxIndex] &lt;/span&gt;=&lt;span&gt; tmp;
            maxHeapify(arr, maxIndex);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如下图，堆中元素9的维护过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200626231057485-778002804.png&quot; alt=&quot;&quot; width=&quot;367&quot; height=&quot;266&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200626231209584-225295195.png&quot; alt=&quot;&quot; width=&quot;381&quot; height=&quot;267&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200626231241688-256179842.png&quot; alt=&quot;&quot; width=&quot;373&quot; height=&quot;267&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 图5&lt;/p&gt;
&lt;p&gt;堆维护过程的时间复杂度：O(lgn)。&lt;/p&gt;
&lt;h3&gt;6、构建堆&lt;/h3&gt;
&lt;p&gt;根据二.4我们可以得到所有叶子节点的下标。我们可以使用二.5中的堆维护过程，对所堆中所有的非叶子节点执行堆维护操作进行堆的构建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; buildHeap(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] arr) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = (arr.length - 1) / 2; i &amp;gt;= 0; i--&lt;span&gt;) {
            maxHeapify(arr, i);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以数组 {27,17,3,16,13,10,1,5,7,12,4,8,9,0} 为例进行堆构建，结果为：{27,17,10,16,13,9,1,5,7,12,4,8,3,0}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202006/603942-20200627000846668-698758752.png&quot; alt=&quot;&quot; width=&quot;648&quot; height=&quot;116&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图6&lt;/p&gt;
&lt;p&gt;构建最大堆的时间复杂度为O(n)。&lt;/p&gt;
&lt;h3&gt;7、堆排序&lt;/h3&gt;
&lt;p&gt;首先执行最大堆构建，当前堆中最大值会上升到根节点，也就是堆数组的首节点。&lt;/p&gt;
&lt;p&gt;我们可以通过交换首尾节点，使得最大值转移至尾部，然后对除尾部元素外的堆数组执行根元素堆维护，上浮堆最大值。&lt;/p&gt;
&lt;p&gt;然后，将最大值交换至数组尾部倒数第二个元素位置，重新执行剩余堆数组的根元素堆维护，依次类推，直至剩余堆数组大小变为2为止。&lt;/p&gt;
&lt;p&gt;以二.6中数组为例：{27,17,3,16,13,10,1,5,7,12,4,8,9,0}&lt;/p&gt;
&lt;p&gt;第一次执行：&lt;/p&gt;
&lt;p&gt;{27,17,10,16,13,9,1,5,7,12,4,8,3,0}，max：27&lt;/p&gt;
&lt;p&gt;第二次执行：&lt;/p&gt;
&lt;p&gt;{17,16,10,7,13,9,1,5,0,12,4,8,3}，max：17&lt;/p&gt;
&lt;p&gt;第三词执行：&lt;/p&gt;
&lt;p&gt;{16,13,10,7,12,9,1,5,0,3,4,8}，max：16&lt;/p&gt;
&lt;p&gt;第四次执行：&lt;/p&gt;
&lt;p&gt;{13,12,10,7,8,9,1,5,0,3,4}，max：13&lt;/p&gt;
&lt;p&gt;第五次执行：&lt;/p&gt;
&lt;p&gt;{12,8,10,7,4,9,1,5,0,3}，max：12&lt;/p&gt;
&lt;p&gt;第六次执行：&lt;/p&gt;
&lt;p&gt;{10,8,9,7,4,3,1,5,0}，max：10&lt;/p&gt;
&lt;p&gt;第七次执行：&lt;/p&gt;
&lt;p&gt;{9,8,3,7,4,0,1,5}，max：9&lt;/p&gt;
&lt;p&gt;第八次执行：&lt;/p&gt;
&lt;p&gt;{8,7,3,5,4,0,1}，max：8&lt;/p&gt;
&lt;p&gt;第九次执行：&lt;/p&gt;
&lt;p&gt;{7,5,3,1,4,0}，max：7&lt;/p&gt;
&lt;p&gt;第十次执行：&lt;/p&gt;
&lt;p&gt;{5,4,3,1,0}，max：5&lt;/p&gt;
&lt;p&gt;第十一次执行：&lt;/p&gt;
&lt;p&gt;{4,1,3,0}，max：4&lt;/p&gt;
&lt;p&gt;第十二次执行：&lt;/p&gt;
&lt;p&gt;{3,1,0}，max：3&lt;/p&gt;
&lt;p&gt;第十三次执行：&lt;/p&gt;
&lt;p&gt;{1,0}，max：1&lt;/p&gt;
&lt;p&gt;堆排序时间复杂度：O(nlgn)&lt;/p&gt;

</description>
<pubDate>Fri, 26 Jun 2020 18:11:00 +0000</pubDate>
<dc:creator>WindWant</dc:creator>
<og:description>一、什么是堆？ 维基百科的解释是：堆是一种特别的树状数据结构，它需要满足任意的子节点必须都大于等于（最大堆）或者小于等于（最小堆）其父节点。 二、堆排序 堆排序是通过二叉堆数据结构实现，二叉堆满足一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niejunlei/p/13195939.html</dc:identifier>
</item>
<item>
<title>Spring IoC bean 的创建（上） - leisurexi</title>
<link>http://www.cnblogs.com/leisurexi/p/13196998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leisurexi/p/13196998.html</guid>
<description>&lt;p&gt;本系列全部基于 &lt;code&gt;Spring 5.2.2.BUILD-SNAPSHOT&lt;/code&gt; 版本。因为 Spring 整个体系太过于庞大，所以只会进行关键部分的源码解析。&lt;/p&gt;
&lt;p&gt;本篇文章主要介绍 Spring IoC 容器是怎么创建 &lt;code&gt;bean&lt;/code&gt; 的实例。&lt;/p&gt;

&lt;p&gt;在上一篇&lt;a href=&quot;https://www.cnblogs.com/leisurexi/p/13194515.html&quot;&gt;Spring IoC bean 的加载&lt;/a&gt;中有这么一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;if (mbd.isSingleton()) {
    // 创建和注册单例 bean
    sharedInstance = getSingleton(beanName, () -&amp;gt; {
        try {
            // 创建 bean 实例
            return createBean(beanName, mbd, args);
        }
        // 省略异常处理...
    });
    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;bean&lt;/code&gt; 的作用域是&lt;strong&gt;单例&lt;/strong&gt;，会调用 &lt;code&gt;getSingleton()&lt;/code&gt; 方法并传入 &lt;code&gt;beanName&lt;/code&gt; 和 &lt;code&gt;ObjectFacoty&lt;/code&gt;作为参数；而 &lt;code&gt;getSingleton()&lt;/code&gt; 方法会调用 &lt;code&gt;ObjectFactory&lt;/code&gt; 的 &lt;code&gt;getObject()&lt;/code&gt; 方法也就是上面代码中的 &lt;code&gt;createBean()&lt;/code&gt; 方法，返回 &lt;code&gt;bean&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;ObjectFactory&lt;/code&gt; 是 &lt;code&gt;bean&lt;/code&gt; 的延迟依赖查找接口，定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@FunctionalInterface
public interface ObjectFactory&amp;lt;T&amp;gt; {

    T getObject() throws BeansException;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有在调用 &lt;code&gt;getObject()&lt;/code&gt; 方法时才会真正去获取 &lt;code&gt;bean&lt;/code&gt;。下面我们正式开始分析 &lt;code&gt;createBean()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h2 id=&quot;abstractautowirecapablebeanfactorycreatebean&quot;&gt;AbstractAutowireCapableBeanFactory#createBean&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException {

    RootBeanDefinition mbdToUse = mbd;

    // 将String类型的class字符串，转换为Class对象，例如在XML中配置的class属性
    Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);
    if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) {
        mbdToUse = new RootBeanDefinition(mbd);
        mbdToUse.setBeanClass(resolvedClass);
    }

    try {
        // 进行定义的方法覆盖
        mbdToUse.prepareMethodOverrides();
    }
    catch (BeanDefinitionValidationException ex) {
        throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, &quot;Validation of method overrides failed&quot;, ex);
    }

    try {
        // 如果bean的实例化前回调方法返回非null，直接返回实例，跳过后面步骤。见下文详解
        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
        if (bean != null) {
            return bean;
        }
    }
    catch (Throwable ex) {
        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
    }

    try {
        // 真正去创建bean的方法
        Object beanInstance = doCreateBean(beanName, mbdToUse, args);
        if (logger.isTraceEnabled()) {
            logger.trace(&quot;Finished creating instance of bean '&quot; + beanName + &quot;'&quot;);
        }
        // 返回bean的实例
        return beanInstance;
    }
    // 省略异常处理...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;bean-实例化前置处理&quot;&gt;bean 实例化前置处理&lt;/h2&gt;
&lt;p&gt;我们先看一下 &lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt; 接口的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {

    /**
     * Bean 实例化前调用，返回非 {@code null} 回调过后面流程
     * 返回 {@code null} 则进行 IoC 容器对 Bean 的实例化
     */
    @Nullable
    default Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
        return null;
    }

    /**
     * Bean 实例化之后，属性填充之前调用，返回 {@code true} 则进行默认的属性填充步骤，
     * 返回 {@code false} 会跳过属性填充阶段，同样也会跳过初始化阶段的生命周期方法的回调。
     */
    default boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException {
        return true;
    }

    /**
     * Bean 实例化后属性赋值前调用，PropertyValues 是已经封装好的设置的属性值，返回 {@code null} 继续
     */
    @Nullable
    default PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) throws BeansException {
        return null;
    }

    /**
     * 5.1 版本后已经被上面 postProcessProperties 方法所替代，功能与上面方法一样
     */
    @Deprecated
    @Nullable
    default PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException {
        return pvs;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面接口继承于 &lt;code&gt;BeanPostProcessor&lt;/code&gt;（&lt;code&gt;BeanPostProcessor&lt;/code&gt; 中定义了 &lt;code&gt;bean&lt;/code&gt; 的初始化阶段生命周期回调方法，会在后续介绍）提供了三个扩展点，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;bean&lt;/code&gt; 实例化前&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bean&lt;/code&gt; 实例化后&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bean&lt;/code&gt; 属性赋值前&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这也是 &lt;code&gt;bean&lt;/code&gt; 实例化阶段的生命周期回调方法。&lt;/p&gt;
&lt;h3 id=&quot;abstractautowirecapablebeanfactoryresolvebeforeinstantiation&quot;&gt;AbstractAutowireCapableBeanFactory#resolveBeforeInstantiation&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {
    Object bean = null;
    // 判断bean在实例化之前是否已经解析过
    if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {
        // 如果bean是合成的 &amp;amp;&amp;amp; 有实现 InstantiationAwareBeanPostProcessor 接口
        if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
            // 解析bean的类型
            Class&amp;lt;?&amp;gt; targetType = determineTargetType(beanName, mbd);
            if (targetType != null) {
                // 执行bean的实例化前回调
                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);
                // 如果实例化前生命周期回调方法返回的不是null
                if (bean != null) {
                    // 执行bean的实例化后回调，因为会跳过后续步骤，所以只能在此处调用了
                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);
                }
            }
        }
        // 如果bean不为空，则将beforeInstantiationResolved赋值为true，代表在实例化之前已经解析
        mbd.beforeInstantiationResolved = (bean != null);
    }
    return bean;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建-bean&quot;&gt;创建 bean&lt;/h2&gt;
&lt;h3 id=&quot;abstractautowirecapablebeanfactorydocreatebean&quot;&gt;AbstractAutowireCapableBeanFactory#doCreateBean&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException {

    // 实例化 bean
    BeanWrapper instanceWrapper = null;
    if (mbd.isSingleton()) {
        // 如果bean的作用域是singleton，则需要移除未完成的FactoryBean实例的缓存
        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
    }
    if (instanceWrapper == null) {
        // 通过构造函数反射创建bean的实例，但是属性并未赋值，见下文详解
        instanceWrapper = createBeanInstance(beanName, mbd, args);
    }
    // 获取bean的实例
    final Object bean = instanceWrapper.getWrappedInstance(); 
    // 获取bean的类型
    Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass(); 
    if (beanType != NullBean.class) {
        mbd.resolvedTargetType = beanType;
    }

    synchronized (mbd.postProcessingLock) {
        if (!mbd.postProcessed) {
            try {
                // BeanDefinition 合并后的回调，见下文详解
                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
            } 
            // 省略异常处理...
            mbd.postProcessed = true;
        }
    }

    // bean的作用域是单例 &amp;amp;&amp;amp; 允许循环引用 &amp;amp;&amp;amp; 当前bean正在创建中
    boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp; isSingletonCurrentlyInCreation(beanName));
    // 如果允许bean提前曝光
    if (earlySingletonExposure) {
        // 将beanName和ObjectFactory形成的key-value对放入singletonFactories缓存中
        addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
    }

    Object exposedObject = bean;
    try {
        // 给 bean 的属性赋值
        populateBean(beanName, mbd, instanceWrapper);
        // 初始化 bean
        exposedObject = initializeBean(beanName, exposedObject, mbd);
    } 
    // 省略异常处理...
    
    // 如果允许单例bean提前暴露
    if (earlySingletonExposure) {
        Object earlySingletonReference = getSingleton(beanName, false);
        // 只有在检测到循环依赖的情况下才不为空
        if (earlySingletonReference != null) {
            // 如果exposedObject没有在初始化方法中被改变，也就是没有被增强
            if (exposedObject == bean) {
                exposedObject = earlySingletonReference;
            } else if (!this.allowRawInjectionDespiteWrapping &amp;amp;&amp;amp; hasDependentBean(beanName)) {
                String[] dependentBeans = getDependentBeans(beanName);
                Set&amp;lt;String&amp;gt; actualDependentBeans = new LinkedHashSet&amp;lt;&amp;gt;(dependentBeans.length);
                // 检测依赖
                for (String dependentBean : dependentBeans) { 
                    if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
                        actualDependentBeans.add(dependentBean);
                    }
                }
                if (!actualDependentBeans.isEmpty()) {
                    throw new BeanCurrentlyInCreationException(beanName, &quot;Bean with name '&quot; + beanName + &quot;' has been injected into other beans [&quot; + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
&quot;] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.&quot;);
                }
            }
        }
    }

    try {
        // 用于注册销毁bean
        registerDisposableBeanIfNecessary(beanName, bean, mbd);
    } catch (BeanDefinitionValidationException ex) {
        throw new BeanCreationException(
            mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
    }
    // 返回bean实例
    return exposedObject;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建-bean-的实例&quot;&gt;创建 bean 的实例&lt;/h3&gt;
&lt;h4 id=&quot;abstractautowirecapablebeanfactorycreatebeaninstance&quot;&gt;AbstractAutowireCapableBeanFactory#createBeanInstance&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
    // 解析 bean 的类型
    Class&amp;lt;?&amp;gt; beanClass = resolveBeanClass(mbd, beanName);
    // 判断beanClass是否是public修饰的类，并且是否允许访问非公共构造函数和方法，不是抛出异常
    if (beanClass != null &amp;amp;&amp;amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;amp;&amp;amp; !mbd.isNonPublicAccessAllowed()) {
        throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName());
    }
    // Spring 5新添加的，如果存在Supplier回调，则使用给定的回调方法初始化策略。
    // 可以使RootBeanDefinition#setInstanceSupplier()设置
    Supplier&amp;lt;?&amp;gt; instanceSupplier = mbd.getInstanceSupplier();
    if (instanceSupplier != null) {
        return obtainFromSupplier(instanceSupplier, beanName);
    }
    // 如果设置工厂方法则使用给定的方法创建bean实例，这里分为静态工厂和实例化工厂
    if (mbd.getFactoryMethodName() != null) {
        return instantiateUsingFactoryMethod(beanName, mbd, args);
    }

    // 快捷方式创建相同的bean
    // resolved: 构造函数或工厂方法是否已经解析过
    boolean resolved = false;
    // autowireNecessary: 是否需要自动注入 (即是否需要解析构造函数)
    boolean autowireNecessary = false;
    if (args == null) {
        synchronized (mbd.constructorArgumentLock) {
            // 如果resolvedConstructorOrFactoryMethod不为空，代表构造函数或工厂方法已经解析过
            if (mbd.resolvedConstructorOrFactoryMethod != null) {
                resolved = true;
                // 根据constructorArgumentsResolved判断是否需要自动注入
                autowireNecessary = mbd.constructorArgumentsResolved;
            }
        }
    }
    if (resolved) {
        if (autowireNecessary) {
            // 如果构造函数或工厂方法已经解析过并且需要自动注入，则执行构造器自动注入，见下文详解
            return autowireConstructor(beanName, mbd, null, null);
        }
        else {
            // 否则使用默认构造函数进行bean实例化，见下文详解
            return instantiateBean(beanName, mbd);
        }
    }

    // 调用SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors()方法
    // 拿到 bean 的候选构造函数
    Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
    // 候选构造函数不为空 || 构造函数依赖注入 || 定义了构造函数的参数值 || args不为空，则执行构造器自动注入
    if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
        mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
        return autowireConstructor(beanName, mbd, ctors, args);
    }

    // 如果有首选的构造函数，使用该构造函数去创建bean实例
    ctors = mbd.getPreferredConstructors();
    if (ctors != null) {
        return autowireConstructor(beanName, mbd, ctors, null);
    }

    // 没有特殊处理，使用默认无参构造器实例化bean
    return instantiateBean(beanName, mbd);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面方法主要判断是使用构造函数自动注入，还是使用默认构造函数构造。总结起来以下几种情况会使用构造函数自动注入：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;已经缓存过构造函数并且构造函数的参数已经解析过。&lt;/li&gt;
&lt;li&gt;候选的构造函数不为空，这里的候选构造函数是通过实现 &lt;code&gt;SmartInstantiationAwareBeanPostProcessor&lt;/code&gt; 接口中的 &lt;code&gt;determineCandidateConstructors()&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;自动注入模式为构造函数自动注入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanDefinition&lt;/code&gt; 定义了构造函数参数，如 XML 中的 &lt;code&gt;&amp;lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在调用 &lt;code&gt;getBean()&lt;/code&gt; 方法时显示指定了 &lt;code&gt;args&lt;/code&gt; 参数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面方法中还有一个判断是否有缓存的过程，是因为一个 &lt;code&gt;bean&lt;/code&gt; 对应的类中可能会有多个构造函数，而每个构造函数的参数不同，Spring 在根据参数及类型去判断最终会使用哪个构造函数进行实例化。但是，判断的过程是个比较消耗性能的步骤，所以采用缓存机制，如果已经解析过则不需要重复解析而是直接从 &lt;code&gt;RootBeanDefinition&lt;/code&gt; 中的属性 &lt;code&gt;resolvedConstructorOrFactoryMethod&lt;/code&gt; 缓存的值去取，否则需要再次解析，并将解析的结果添加至 &lt;code&gt;RootBeanDefinition&lt;/code&gt; 中的属性 &lt;code&gt;resolvedConstructorOrFactoryMethod&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;这里简单介绍一下 &lt;code&gt;SmartInstantiationAwareBeanPostProcessor&lt;/code&gt; 这个接口，它继承于 &lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface SmartInstantiationAwareBeanPostProcessor extends InstantiationAwareBeanPostProcessor {

    /**
     * 预测 bean 的类型
     */
    @Nullable
    default Class&amp;lt;?&amp;gt; predictBeanType(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
        return null;
    }

    /**
     * 选择合适的构造器，比如目标对象有多个构造器，在这里可以进行一些定制化，选择合适的构造器
     */
    @Nullable
    default Constructor&amp;lt;?&amp;gt;[] determineCandidateConstructors(Class&amp;lt;?&amp;gt; beanClass, String beanName) throws BeansException {
        return null;
    }

    /**
     * 获得提前暴露的 bean 引用，主要用于解决循环引用的问题
     * 只有单例对象才会调用此方法
     */
    default Object getEarlyBeanReference(Object bean, String beanName) throws BeansException {
        return bean;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实我们熟知的 &lt;code&gt;@Autowired&lt;/code&gt; 注解标注在构造函数上实现自动注入，也是重写了该接口的 &lt;code&gt;determineCandidateConstructors()&lt;/code&gt; 方法实现的。&lt;/p&gt;
&lt;h3 id=&quot;默认无参构造器实例化-bean&quot;&gt;默认无参构造器实例化 bean&lt;/h3&gt;
&lt;h4 id=&quot;abstractautowirecapablebeanfactoryinstantiatebean&quot;&gt;AbstractAutowireCapableBeanFactory#instantiateBean&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
    try {
        Object beanInstance;
        final BeanFactory parent = this;
        // 使用指定的策略去实力化bean
        beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
        // 将实例化后的bean封装成BeanWrapper后返回
        BeanWrapper bw = new BeanWrapperImpl(beanInstance);
        initBeanWrapper(bw);
        return bw;
    }
    // 省略异常处理...
}

// SimpleInstantiationStrategy.java
public Object instantiate(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner) {
    // 如果有需要覆盖或者动态替换的方法则当然需要使用CGLIB进行动态代理，因为可以在创建代理的同时将方法织入类中
    // 但是如果没有需要动态改变的方法，为了方便直接用反射就可以了
    if (!bd.hasMethodOverrides()) {
        Constructor&amp;lt;?&amp;gt; constructorToUse;
        synchronized (bd.constructorArgumentLock) {
            // 获取缓存的构造方法或工厂方法
            constructorToUse = (Constructor&amp;lt;?&amp;gt;) bd.resolvedConstructorOrFactoryMethod;
            // 缓存为空
            if (constructorToUse == null) {
                final Class&amp;lt;?&amp;gt; clazz = bd.getBeanClass();
                // 如果clazz是接口，抛出异常
                if (clazz.isInterface()) {
                    throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);
                }
                try {
                    // 获取默认的无参构造函数
                    constructorToUse = clazz.getDeclaredConstructor();
                    // 设置缓存
                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;
                }
                catch (Throwable ex) {
                    throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);
                }
            }
        }
        // 这里就是用指定的无参构造器去实例化该bean，不做具体分析了
        return BeanUtils.instantiateClass(constructorToUse);
    }
    else {
        // 用CGLIB生成子类动态织入重写的方法
        return instantiateWithMethodInjection(bd, beanName, owner);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;寻找合适的构造器实例化-bean&quot;&gt;寻找合适的构造器实例化 bean&lt;/h3&gt;
&lt;h4 id=&quot;constructorresolverautowireconstructor&quot;&gt;ConstructorResolver#autowireConstructor&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor&amp;lt;?&amp;gt;[] ctors, @Nullable Object[] explicitArgs) {
        // 寻找适合的构造器，进行实例化
    return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
}

public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd, @Nullable Constructor&amp;lt;?&amp;gt;[] chosenCtors, @Nullable Object[] explicitArgs) {

    BeanWrapperImpl bw = new BeanWrapperImpl();
    this.beanFactory.initBeanWrapper(bw);
    // 最终实例化的构造函数
    Constructor&amp;lt;?&amp;gt; constructorToUse = null;
    // 最终用于实例化的参数Holder
    ArgumentsHolder argsHolderToUse = null;
    // 最终用于实例化的构造函数参数
    Object[] argsToUse = null;
    // 如果explicitArgs不为空，则使用explicitArgs当做构造器函数参数
    if (explicitArgs != null) {
        argsToUse = explicitArgs;
    }
    else {
        Object[] argsToResolve = null;
        synchronized (mbd.constructorArgumentLock) {
            // 获取已经缓存的构造函数或工厂方法
            constructorToUse = (Constructor&amp;lt;?&amp;gt;) mbd.resolvedConstructorOrFactoryMethod;
            if (constructorToUse != null &amp;amp;&amp;amp; mbd.constructorArgumentsResolved) {
                // 获取已经缓存的构造函数参数
                argsToUse = mbd.resolvedConstructorArguments;
                if (argsToUse == null) {
                    // 如果已经缓存了构造函数或工厂方法，
                    // 那么resolvedConstructorArguments和preparedConstructorArguments必定有一个缓存了构造函数参数
                    argsToResolve = mbd.preparedConstructorArguments;
                }
            }
        }
        if (argsToResolve != null) {
            // 如果argsToResolve不为空，则对构造函数参数进行解析，也就是会进行类型转换之类的操作
            // 例如 A(int,int)，把配置中的 (&quot;1&quot;,&quot;1&quot;) 转换为 (1,1)
            argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, true);
        }
    }
    // 如果没有缓存构造函数或者其参数
    if (constructorToUse == null || argsToUse == null) {
        Constructor&amp;lt;?&amp;gt;[] candidates = chosenCtors;
        if (candidates == null) {
            Class&amp;lt;?&amp;gt; beanClass = mbd.getBeanClass();
            try {
                // 如果允许访问非public的构造函数和方法(该值默认为 true)，就获取所有构造函数，否则只获取public修饰的构造函数
                candidates = (mbd.isNonPublicAccessAllowed() ?
                              beanClass.getDeclaredConstructors() : beanClass.getConstructors());
            }
            catch (Throwable ex) {
                throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Resolution of declared constructors on bean Class [&quot; + beanClass.getName() + &quot;] from ClassLoader [&quot; + beanClass.getClassLoader() + &quot;] failed&quot;, ex);
            }
        }
        // 如果只有一个构造函数 &amp;amp;&amp;amp; getBean()没有显示指定args &amp;amp;&amp;amp; 没有定义构造函数的参数值
        if (candidates.length == 1 &amp;amp;&amp;amp; explicitArgs == null &amp;amp;&amp;amp; !mbd.hasConstructorArgumentValues()) {
            // 获取构造函数
            Constructor&amp;lt;?&amp;gt; uniqueCandidate = candidates[0];
            if (uniqueCandidate.getParameterCount() == 0) {
                synchronized (mbd.constructorArgumentLock) {
                    // 设置构造函数和参数的缓存
                    mbd.resolvedConstructorOrFactoryMethod = uniqueCandidate;
                    mbd.constructorArgumentsResolved = true;
                    mbd.resolvedConstructorArguments = EMPTY_ARGS;
                }
                // 通过无参构造函数创建bean的实例，然后直接返回
                bw.setBeanInstance(instantiate(beanName, mbd, uniqueCandidate, EMPTY_ARGS));
                return bw;
            }
        }

        // 如果候选构造函数不为空 || 构造函数自动注入模式
        boolean autowiring = (chosenCtors != null || mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
        ConstructorArgumentValues resolvedValues = null;

        int minNrOfArgs;
        // getBean()显示指定了参数，获取参数长度
        if (explicitArgs != null) {
            minNrOfArgs = explicitArgs.length;
        }
        else {
            // 获取定义的构造函数参数
            ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
            resolvedValues = new ConstructorArgumentValues();
            // 解析构造函数参数并赋值到resolvedValues，返回参数个数。见下文详解
            minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
        }
        // 这里对构造函数进行排序，规则是首先是public构造函数且参数个数从多到少，然后是非public构造函数且参数个数有多到少
        AutowireUtils.sortConstructors(candidates);
        // 最小匹配权重，权重越小，越接近我们要找的目标构造函数
        int minTypeDiffWeight = Integer.MAX_VALUE;
        Set&amp;lt;Constructor&amp;lt;?&amp;gt;&amp;gt; ambiguousConstructors = null;
        LinkedList&amp;lt;UnsatisfiedDependencyException&amp;gt; causes = null;
        // 遍历构造函数，找出符合的构造函数
        for (Constructor&amp;lt;?&amp;gt; candidate : candidates) {
            // 获取参数数量
            int parameterCount = candidate.getParameterCount();
            // 如果已经找到满足的构造函数 &amp;amp;&amp;amp; 目标构造函数参数个数大于当前遍历的构造函数参数个数则终止
            // 因为构造函数已经是排过序的，后面不会再有更适合的了
            if (constructorToUse != null &amp;amp;&amp;amp; argsToUse != null &amp;amp;&amp;amp; argsToUse.length &amp;gt; parameterCount) {
                break;
            }
            // 如果目标的构造函数参数个数小于我们需要的，直接跳过
            if (parameterCount &amp;lt; minNrOfArgs) {
                continue;
            }

            ArgumentsHolder argsHolder;
            // 获取到构造函数的参数类型
            Class&amp;lt;?&amp;gt;[] paramTypes = candidate.getParameterTypes();
            if (resolvedValues != null) {
                try {
                    // 评估参数名称，就是判断构造函数上是否标注了@ConstructorProperties注解，如果标注了，直接取其中定义的参数名称
                    String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);
                    // 没有标注@ConstructorProperties注解，使用参数名称解析器，获取参数名称
                    if (paramNames == null) {
                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                        if (pnd != null) {
                            paramNames = pnd.getParameterNames(candidate);
                        }
                    }
                    // 创建一个参数数组以调用构造函数或工厂方法，见下文详解
                    // 主要是通过参数类型和参数名解析构造函数或工厂方法所需的参数（如果参数是其他bean，则会解析依赖的bean）
                    argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);
                }
                catch (UnsatisfiedDependencyException ex) {
                    // Swallow and try next constructor.
                    if (causes == null) {
                        causes = new LinkedList&amp;lt;&amp;gt;();
                    }
                    causes.add(ex);
                    continue;
                }
            }
            // resolvedValues为空， explicitArgs不为空，即显示指定了getBean()的args参数
            else {
                // 如果当前构造函数参数个数不等的explicitArgs的长度，直接跳过该构造函数
                if (parameterCount != explicitArgs.length) {
                    continue;
                }
                // 把explicitArgs封装进ArgumentsHolder
                argsHolder = new ArgumentsHolder(explicitArgs);
            }
            // 根据mbd的解析构造函数模式(true: 宽松模式，false：严格模式)
            // 将argsHolder的参数和paramTypes进行比较，计算paramTypes的类型差异权重值
            int typeDiffWeight = (mbd.isLenientConstructorResolution() ?argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
            // 差异值越小代表构造函数越匹配，则选择此构造函数
            if (typeDiffWeight &amp;lt; minTypeDiffWeight) {
                constructorToUse = candidate;
                argsHolderToUse = argsHolder;
                argsToUse = argsHolder.arguments;
                minTypeDiffWeight = typeDiffWeight;
                // 如果出现权重值更小的候选者，则将ambiguousConstructors清空，允许之前存在权重值相同的候选者
                ambiguousConstructors = null;
            }
            // 两个候选者权重值相同，并且是当前遍历过权重值最小的
            else if (constructorToUse != null &amp;amp;&amp;amp; typeDiffWeight == minTypeDiffWeight) {
                // 将两个候选者添加到ambiguousConstructors
                if (ambiguousConstructors == null) {
                    ambiguousConstructors = new LinkedHashSet&amp;lt;&amp;gt;();
                    ambiguousConstructors.add(constructorToUse);
                }
                ambiguousConstructors.add(candidate);
            }
        }
        // 没有找到匹配的构造函数，抛出异常
        if (constructorToUse == null) {
            if (causes != null) {
                UnsatisfiedDependencyException ex = causes.removeLast();
                for (Exception cause : causes) {
                    this.beanFactory.onSuppressedException(cause);
                }
                throw ex;
            }
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Could not resolve matching constructor (hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)&quot;);
        }
        // 如果有多个匹配的候选者，并且不是宽松模式，抛出异常
        else if (ambiguousConstructors != null &amp;amp;&amp;amp; !mbd.isLenientConstructorResolution()) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Ambiguous constructor matches found in bean '&quot; + beanName + &quot;'(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): &quot; + ambiguousConstructors);
        }
        // getBean()方法没有指定args参数 &amp;amp;&amp;amp; 构造函数参数不为空
        if (explicitArgs == null &amp;amp;&amp;amp; argsHolderToUse != null) {
            // 缓存解析过后的构造函数和参数
            argsHolderToUse.storeCache(mbd, constructorToUse);
        }
    }

    Assert.state(argsToUse != null, &quot;Unresolved constructor arguments&quot;);
    // 利用反射创建bean实例
    bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));
    return bw;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面方法的功能主要如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造函数参数的确定
&lt;ul&gt;&lt;li&gt;如果 &lt;code&gt;explicitArgs&lt;/code&gt; 参数不为空，那就可以直接确定参数。因为 &lt;code&gt;explicitArgs&lt;/code&gt; 参数是在调用 &lt;code&gt;getBean()&lt;/code&gt; 时手动指定的，这个主要用于静态工厂方法的调用。&lt;/li&gt;
&lt;li&gt;缓存中不为空，那么可以直接拿过来使用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanDefinition&lt;/code&gt; 中读取，我们所定义的 &lt;code&gt;bean&lt;/code&gt; 都会生成一个 &lt;code&gt;BeanDefinition&lt;/code&gt; ，其中记录了定义了构造函数参数通过 &lt;code&gt;getConstructorArgumentValues()&lt;/code&gt; 获取。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;构造函数的确定。经过第一步已经确定构造函数的参数，接下来就是用参数个数在所有的构造函数中锁定对应的构造函数。匹配之前会对构造函数进行排序，首先是 &lt;code&gt;public&lt;/code&gt; 构造函数且参数个数从多到少，然后是非&lt;code&gt;public&lt;/code&gt; 构造函数且参数个数有多到少。这样可以迅速判断排在后面的构造函数参数个数是否符合条件。&lt;/li&gt;
&lt;li&gt;根据对应的构造函数转换对应的参数类型。&lt;/li&gt;
&lt;li&gt;根据实例化策略以及得到的构造函数和构造函数参数实例化 &lt;code&gt;bean&lt;/code&gt; 。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;解析构造函数参数&quot;&gt;解析构造函数参数&lt;/h4&gt;
&lt;h5 id=&quot;constructorresolverresolveconstructorarguments&quot;&gt;ConstructorResolver#resolveConstructorArguments&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private int resolveConstructorArguments(String beanName, RootBeanDefinition mbd, BeanWrapper bw,
ConstructorArgumentValues cargs, ConstructorArgumentValues resolvedValues) {
    // 获取自定义类型转换器
    TypeConverter customConverter = this.beanFactory.getCustomTypeConverter();
    TypeConverter converter = (customConverter != null ? customConverter : bw); 
    // 如果没有自定义的转换器就用bw
    BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this.beanFactory, beanName, mbd, converter);
    // minNrOfArgs初始化为indexedArgumentValues+genericArgumentValues的个数总和
    int minNrOfArgs = cargs.getArgumentCount();
    // 遍历IndexArgumentValues，这里的IndexArgumentValues就带下标的，如：&amp;lt;constructor-arg index=&quot;0&quot; value=&quot;1&quot;/&amp;gt;
    for (Map.Entry&amp;lt;Integer, ConstructorArgumentValues.ValueHolder&amp;gt; entry : cargs.getIndexedArgumentValues().entrySet()) {
        int index = entry.getKey();
        if (index &amp;lt; 0) {
            throw new BeanCreationException(mbd.getResourceDescription(), beanName, &quot;Invalid constructor argument index: &quot; + index);
        } 
        // 如果index大于minNrOfArgs，修改minNrOfArgs值
        if (index &amp;gt; minNrOfArgs) {
            // 因为index是构造函数下标值，所以总数这边要加1
            minNrOfArgs = index + 1; 
        }
        ConstructorArgumentValues.ValueHolder valueHolder = entry.getValue();
        // 如果参数类型已经转换过，直接添加进resolvedValues
        if (valueHolder.isConverted()) { 
            resolvedValues.addIndexedArgumentValue(index, valueHolder);
        }
        // 参数类型没有转换过，进行转换
        else { 
            Object resolvedValue =
                valueResolver.resolveValueIfNecessary(&quot;constructor argument&quot;, valueHolder.getValue());
            // 使用转换过的参数值构建ValueHolder
            ConstructorArgumentValues.ValueHolder resolvedValueHolder = 
                                                new ConstructorArgumentValues.ValueHolder(resolvedValue, valueHolder.getType(), valueHolder.getName());
            resolvedValueHolder.setSource(valueHolder); 
            // 添加进resolvedValues
            resolvedValues.addIndexedArgumentValue(index, resolvedValueHolder);
        }
    }
    // 遍历GenericArgumentValues并进行类型转换和上面一样，这里的GenericArgumentValues就是没有指定下标的
    // 如：&amp;lt;constructor-arg value=&quot;1&quot;/&amp;gt;
    for (ConstructorArgumentValues.ValueHolder valueHolder : cargs.getGenericArgumentValues()) {
        if (valueHolder.isConverted()) {
            resolvedValues.addGenericArgumentValue(valueHolder);
        }
        else {
            Object resolvedValue =
                valueResolver.resolveValueIfNecessary(&quot;constructor argument&quot;, valueHolder.getValue());
            ConstructorArgumentValues.ValueHolder resolvedValueHolder = new ConstructorArgumentValues.ValueHolder(
                resolvedValue, valueHolder.getType(), valueHolder.getName());
            resolvedValueHolder.setSource(valueHolder);
            resolvedValues.addGenericArgumentValue(resolvedValueHolder);
        }
    }
    // 返回参数个数
    return minNrOfArgs;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面方法主要将 &lt;code&gt;indexedArgumentValues&lt;/code&gt; 和 &lt;code&gt;genericArgumentValues&lt;/code&gt; 属性中的值通过调用 &lt;code&gt;resolveValueIfNecessary()&lt;/code&gt; 方法进行解析；&lt;code&gt;resolveValueIfNecessary()&lt;/code&gt; 方法主要解析参数的类型，比如 &lt;code&gt;ref&lt;/code&gt; 属性引用的 &lt;code&gt;beanName&lt;/code&gt; 会通过 &lt;code&gt;getBean()&lt;/code&gt; 返回实例。&lt;/p&gt;
&lt;h4 id=&quot;创建参数数组&quot;&gt;创建参数数组&lt;/h4&gt;
&lt;h5 id=&quot;constructorresolvercreateargumentarray&quot;&gt;ConstructorResolver#createArgumentArray&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private ArgumentsHolder createArgumentArray(String beanName, RootBeanDefinition mbd, @Nullable ConstructorArgumentValues resolvedValues,BeanWrapper bw, Class&amp;lt;?&amp;gt;[] paramTypes, @Nullable String[] paramNames, Executable executable, boolean autowiring, boolean fallback) throws UnsatisfiedDependencyException {
    // 获取类型转换器
    TypeConverter customConverter = this.beanFactory.getCustomTypeConverter();
    TypeConverter converter = (customConverter != null ? customConverter : bw);
    // 构建ArgumentsHolder
    ArgumentsHolder args = new ArgumentsHolder(paramTypes.length);
    Set&amp;lt;ConstructorArgumentValues.ValueHolder&amp;gt; usedValueHolders = new HashSet&amp;lt;&amp;gt;(paramTypes.length);
    Set&amp;lt;String&amp;gt; autowiredBeanNames = new LinkedHashSet&amp;lt;&amp;gt;(4);
    // 遍历参数类型数组
    for (int paramIndex = 0; paramIndex &amp;lt; paramTypes.length; paramIndex++) {
        // 获取参数类型和名称
        Class&amp;lt;?&amp;gt; paramType = paramTypes[paramIndex]; 
        String paramName = (paramNames != null ? paramNames[paramIndex] : &quot;&quot;);
        ConstructorArgumentValues.ValueHolder valueHolder = null;
        if (resolvedValues != null) {
            // 根据参数的下标、类型、名称查询是否有匹配的
            valueHolder = resolvedValues.getArgumentValue(paramIndex, paramType, paramName, usedValueHolders);
            // 没有匹配的 &amp;amp;&amp;amp; 不是自动装配。尝试下一个通用的无类型参数值作为降级方法
            // 它可以在类型转换后匹配 (例如，String -&amp;gt; int)
            if (valueHolder == null &amp;amp;&amp;amp; (!autowiring || paramTypes.length == resolvedValues.getArgumentCount())) {
                valueHolder = resolvedValues.getGenericArgumentValue(null, null, usedValueHolders);
            }
        }
        // 找到了匹配的valueHolder
        if (valueHolder != null) {
            // 添加进usedValueHolders
            usedValueHolders.add(valueHolder);
            Object originalValue = valueHolder.getValue();
            Object convertedValue;
            // 类型已经转换过
            if (valueHolder.isConverted()) {
                // 获取已经转换过的值，作为args在paramIndex的预备参数
                convertedValue = valueHolder.getConvertedValue();
                args.preparedArguments[paramIndex] = convertedValue;
            }
            // 类型没有转换过
            else {
                // 将构造方法和参数下标封装成MethodParameter(MethodParameter是封装方法和参数索引的工具类)
                MethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);
                try {
                    // 将原始值转换为paramType类型的值，无法转换时抛出异常
                    convertedValue = converter.convertIfNecessary(originalValue, paramType, methodParam);
                }
                catch (TypeMismatchException ex) {
                    throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), &quot;Could not convert argument value of type [&quot; + ObjectUtils.nullSafeClassName(valueHolder.getValue()) + &quot;] to required type [&quot; + paramType.getName() + &quot;]: &quot; + ex.getMessage());
                }
                Object sourceHolder = valueHolder.getSource();
                if (sourceHolder instanceof ConstructorArgumentValues.ValueHolder) {
                    Object sourceValue = ((ConstructorArgumentValues.ValueHolder) sourceHolder).getValue();
                    // 标记args需要解析
                    args.resolveNecessary = true;
                    // 将sourceValue作为args在paramIndex位置的预备参数
                    args.preparedArguments[paramIndex] = sourceValue;
                }
            }
            // 将convertedValue作为args在paramIndex位置的参数
            args.arguments[paramIndex] = convertedValue;
            //  将originalValue作为args在paramIndex位置的原始参数
            args.rawArguments[paramIndex] = originalValue;
        }
        // 没有找到匹配的valueHolder
        else {
            // 将构造方法和参数下标封装成MethodParameter
            MethodParameter methodParam = MethodParameter.forExecutable(executable, paramIndex);
            // 找不到明确的匹配，并且不是自动注入，抛出异常
            if (!autowiring) {
                throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), &quot;Ambiguous argument values for parameter of type [&quot; + paramType.getName() +
                    &quot;] - did you specify the correct bean references as arguments?&quot;);
            }
            try {
                // 如果是自动注入，用resolveAutowiredArgument()解析参数，见下文详解
                // 构造函数自动注入中的参数bean就是在这边处理
                Object autowiredArgument = resolveAutowiredArgument(
                    methodParam, beanName, autowiredBeanNames, converter, fallback);
                // 将通过自动装配解析出来的参数赋值给args
                args.rawArguments[paramIndex] = autowiredArgument;
                args.arguments[paramIndex] = autowiredArgument;
                args.preparedArguments[paramIndex] = autowiredArgumentMarker;
                args.resolveNecessary = true;
            }
            catch (BeansException ex) {
                throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, new InjectionPoint(methodParam), ex);
            }
        }
    }
    // 如果依赖了其他的bean，则注册依赖关系(这边的autowiredBeanNames，就是所有依赖的beanName)
    for (String autowiredBeanName : autowiredBeanNames) {
        this.beanFactory.registerDependentBean(autowiredBeanName, beanName);
    }
        // 返回解析后的参数值
    return args;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面方法判断构造函数如果有匹配的参数会转换成对应类型，如果没有匹配的参数，多半是构造函数自动注入，通过 &lt;code&gt;resolveAutowiredArgument()&lt;/code&gt; 去查找 &lt;code&gt;bean&lt;/code&gt; 并返回实例。&lt;/p&gt;
&lt;h5 id=&quot;constructorresolverresolveautowiredargument&quot;&gt;ConstructorResolver#resolveAutowiredArgument&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;protected Object resolveAutowiredArgument(MethodParameter param, String beanName, @Nullable Set&amp;lt;String&amp;gt; autowiredBeanNames, TypeConverter typeConverter, boolean fallback) {
    // 获取参数的类型
    Class&amp;lt;?&amp;gt; paramType = param.getParameterType();
    // 如果参数类型是InjectionPoint
    if (InjectionPoint.class.isAssignableFrom(paramType)) {
        // 拿到当前的InjectionPoint（存储了当前正在解析依赖的方法参数信息，DependencyDescriptor）
        InjectionPoint injectionPoint = currentInjectionPoint.get();
        if (injectionPoint == null) {
            // 当前injectionPoint为空，则抛出异常：目前没有可用的InjectionPoint
            throw new IllegalStateException(&quot;No current InjectionPoint available for &quot; + param);
        }
        // 当前injectionPoint不为空，直接返回
        return injectionPoint;
    }
    try {
        // 解析指定依赖，DependencyDescriptor：
        // 将MethodParameter的方法参数索引信息封装成DependencyDescriptor，见下文详解
        return this.beanFactory.resolveDependency(
                                        new DependencyDescriptor(param, true), beanName, autowiredBeanNames, typeConverter);
    }
    // 忽略异常处理...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面方法中的 &lt;code&gt;resolveDependency()&lt;/code&gt; 方法就是解决依赖注入的关键所在，在分析这个方法之前我们先简单看一下 &lt;code&gt;DependencyDescriptor&lt;/code&gt; 类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DependencyDescriptor extends InjectionPoint implements Serializable {

    // 包装依赖(属性或者方法的某个参数)所在的声明类
    private final Class&amp;lt;?&amp;gt; declaringClass;

    // 如果所包装依赖是方法的某个参数，则这里记录该方法的名称
    @Nullable
    private String methodName;

    // 如果所包装的是方法的某个参数，则这里记录该参数的类型
    @Nullable
    private Class&amp;lt;?&amp;gt;[] parameterTypes;

    // 如果所包装的是方法的某个参数，则这里记录该参数在该函数参数列表中的索引
    private int parameterIndex;

    // 如果所包装的是属性，则这里记录该属性的名称
    @Nullable
    private String fieldName;

    // 标识所包装依赖是否必要依赖
    private final boolean required;

    // 标识所包装依赖是否需要饥饿加载
    private final boolean eager;

    // 标识所包装依赖的嵌套级别
    private int nestingLevel = 1;

    // 标识所包装依赖的包含者类，通常和声明类是同一个
    @Nullable
    private Class&amp;lt;?&amp;gt; containingClass;
    
    // 省略其他代码...
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类就是依赖描述符，存储了需要注入 &lt;code&gt;bean&lt;/code&gt; 的类型、构造器参数的下标（构造器注入该值不为空）、是否必需、字段名称（字段注入该值不为空）、方法名称（&lt;code&gt;set&lt;/code&gt; 方法注入该值不为空）等。&lt;/p&gt;
&lt;h4 id=&quot;依赖解决&quot;&gt;依赖解决&lt;/h4&gt;
&lt;h5 id=&quot;defaultlistablebeanfactoryresolvedependency&quot;&gt;DefaultListableBeanFactory#resolveDependency&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object resolveDependency(DependencyDescriptor descriptor, @Nullable String requestingBeanName,
@Nullable Set&amp;lt;String&amp;gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

    descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
    // Optional类型的处理，说明Spring也可以注入Optional类型的参数
    if (Optional.class == descriptor.getDependencyType()) {
        return createOptionalDependency(descriptor, requestingBeanName);
    }
    // ObjectFactory或ObjectProvider类型的处理
    else if (ObjectFactory.class == descriptor.getDependencyType() ||
             ObjectProvider.class == descriptor.getDependencyType()) {
        return new DependencyObjectProvider(descriptor, requestingBeanName);
    }
    // javax.inject.Provider类型的处理
    else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
        return new Jsr330Factory().createDependencyProvider(descriptor, requestingBeanName);
    }
    else {
        // 获取延迟解析代理
        Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
                                        descriptor, requestingBeanName);
        if (result == null) {
            // 解析依赖，返回的result为最终需要注入的bean实例，见下文详解
            result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
        }
        return result;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;defaultlistablebeanfactorydoresolvedependency&quot;&gt;DefaultListableBeanFactory#doResolveDependency&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Object doResolveDependency(DependencyDescriptor descriptor, @Nullable String beanName,@Nullable Set&amp;lt;String&amp;gt; autowiredBeanNames, @Nullable TypeConverter typeConverter) throws BeansException {

    InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
    try {
        // 获取需要注入bean的快捷方式，不为空直接返回
        Object shortcut = descriptor.resolveShortcut(this);
        if (shortcut != null) {
            return shortcut;
        }
        // 获取需要注入bean的类型
        Class&amp;lt;?&amp;gt; type = descriptor.getDependencyType();
        // 用于支持Spring中新增的注解@Value（确定给定的依赖项是否声明@Value注解，如果有则拿到值）
        Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
        if (value != null) {
            if (value instanceof String) {
                String strVal = resolveEmbeddedValue((String) value);
                BeanDefinition bd = (beanName != null &amp;amp;&amp;amp; containsBean(beanName) ?
                                     getMergedBeanDefinition(beanName) : null);
                value = evaluateBeanDefinitionString(strVal, bd);
            }
            TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
            try {
                return converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());
            }
            catch (UnsupportedOperationException ex) {
                return (descriptor.getField() != null ?
                        converter.convertIfNecessary(value, type, descriptor.getField()) :converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
            }
        }
        // 解析MultipleBean，例如 Array，Collection，Map
        Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
        if (multipleBeans != null) {
            return multipleBeans;
        }
        // 根据类型找到匹配的bean
        // matchingBeans(key: beanName value: 如果bean已经缓存了实例（例如单例bean会缓存其实例），
        // 就是bean的实例，否则就是对应的class对象)
        Map&amp;lt;String, Object&amp;gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);
        if (matchingBeans.isEmpty()) {
            // 没有找到匹配的bean，判断是不是必需的，不是直接返回null，否则抛出异常
            if (isRequired(descriptor)) {
                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
            }
            return null;
        }

        String autowiredBeanName;
        Object instanceCandidate;
        // 如果有多个匹配的候选者
        if (matchingBeans.size() &amp;gt; 1) {
            // 判断最佳的候选者，也就是寻找最匹配的beanName
            autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
            if (autowiredBeanName == null) {
                if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
                    return descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);
                }
                else {
                    return null;
                }
            }
            // 拿到autowiredBeanName对应的value（bean实例或bean实例类型）
            instanceCandidate = matchingBeans.get(autowiredBeanName);
        }
        else {
            // 只找到一个符合的bean
            Map.Entry&amp;lt;String, Object&amp;gt; entry = matchingBeans.entrySet().iterator().next();
            autowiredBeanName = entry.getKey();
            instanceCandidate = entry.getValue();
        }

        if (autowiredBeanNames != null) {
            // 将依赖的beanName添加到autowiredBeanNames中
            autowiredBeanNames.add(autowiredBeanName);
        }
        // 如果需要注入的bean没有缓存实例，那么instanceCandidate是一个Class对象，再根据getBean()去获取对应的实例
        if (instanceCandidate instanceof Class) {
            instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, this);
        }
        Object result = instanceCandidate;
        if (result instanceof NullBean) {
            if (isRequired(descriptor)) {
                raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
            }
            result = null;
        }
        if (!ClassUtils.isAssignableValue(type, result)) {
            throw new BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());
        }
        // 返回最终需要注入的bean实例
        return result;
    }
    finally {
        ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面方法才是真正去获取需要注入的 &lt;code&gt;bean&lt;/code&gt;，大概分为以下几个步骤：&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;查看是否有快捷方式获取注入 &lt;code&gt;bean&lt;/code&gt; 是否为空，不为空直接返回。这里的快捷方式是通过继承 &lt;code&gt;DependencyDescriptor&lt;/code&gt; 并重写 &lt;code&gt;resolveShortcut()&lt;/code&gt; 来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果参数使用 &lt;code&gt;@Value&lt;/code&gt; 注解修饰了，如果获取到值直接返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;解析 &lt;code&gt;MultipleBean&lt;/code&gt;，这里的 &lt;code&gt;MultipleBean&lt;/code&gt; 一般是 &lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Collection&lt;/code&gt;、&lt;code&gt;Map&lt;/code&gt; 这种，不为空直接返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;根据类型找到所有匹配的 &lt;code&gt;bean&lt;/code&gt;，&lt;code&gt;matchingBeans&lt;/code&gt; 中 &lt;code&gt;key&lt;/code&gt; 为 &lt;code&gt;beanName&lt;/code&gt;，&lt;code&gt;value&lt;/code&gt; 的值有两种情况，如果bean已经缓存了实例（例如单例bean会缓存其实例），就是bean的实例，否则就是对应的class对象)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;matchingBeans&lt;/code&gt; 为空，判断需要注入的 &lt;code&gt;bean&lt;/code&gt; 是否是必须的，如果是抛出异常，否则返回 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;matchingBeans&lt;/code&gt; 长度大于1，代表有多个候选者；选择最佳的候选者，规则是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先查找 &lt;code&gt;primary&lt;/code&gt; 属性为 &lt;code&gt;true&lt;/code&gt; 的。&lt;/li&gt;
&lt;li&gt;查找优先级最高的，实现 &lt;code&gt;PriorityOrdered&lt;/code&gt; 接口或者标注 &lt;code&gt;@Priority&lt;/code&gt; 注解的。&lt;/li&gt;
&lt;li&gt;查找名称匹配的。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;只有一个候选者，直接使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果需要注入的 &lt;code&gt;bean&lt;/code&gt; 没有缓存实例，那么 &lt;code&gt;instanceCandidate&lt;/code&gt;是一个 &lt;code&gt;Class&lt;/code&gt; 对象，再根据 &lt;code&gt;getBean()&lt;/code&gt; 方法去获取对应的实例。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最终返回需要注入的 &lt;code&gt;bean&lt;/code&gt; 实例。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文主要介绍了创建 &lt;code&gt;bean&lt;/code&gt; 实例的流程，我们可以重新梳理一下思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进行 &lt;code&gt;bean&lt;/code&gt; 的实例化前方法回调，如果返回非空，跳过后面步骤&lt;/li&gt;
&lt;li&gt;创建 &lt;code&gt;bean&lt;/code&gt; 的实例，如果是构造函数注入会选择最适合的构造函数进行参数自动注入，否则调用默认的无参构造进行实例化 &lt;code&gt;bean&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于 &lt;code&gt;doCreateBean()&lt;/code&gt; 方法中操作太多，这里会分为几篇文章，一一分析各个阶段。&lt;/p&gt;
&lt;blockquote readability=&quot;4.0952380952381&quot;&gt;
&lt;p&gt;最后，我模仿 Spring 写了一个精简版，代码会持续更新。地址：&lt;a href=&quot;https://github.com/leisurexi/tiny-spring&quot;&gt;https://github.com/leisurexi/tiny-spring&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
<pubDate>Fri, 26 Jun 2020 16:44:00 +0000</pubDate>
<dc:creator>leisurexi</dc:creator>
<og:description>前言 本系列全部基于 Spring 5.2.2.BUILD-SNAPSHOT 版本。因为 Spring 整个体系太过于庞大，所以只会进行关键部分的源码解析。 本篇文章主要介绍 Spring IoC 容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leisurexi/p/13196998.html</dc:identifier>
</item>
<item>
<title>Mariadb之显式使用表锁和行级锁 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13196905.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13196905.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200227024455mariadb.jpg&quot; class=&quot;desc_img&quot;/&gt; 首先我们来看看mariadb的锁定概念，所谓锁就是当一个进程或事务在操作某一资源时，为了防止其他用户或者进程或事务对其进行资源操作，导致资源抢占而发生冲突，通常在A进程操作该资源时，会对该资源进行加锁，实现多进程或多用户操作同一资源时，不会发生冲突；通常情况锁的类型分读锁和写锁，所谓读锁就是共享锁，它可以实现多个读操作共享；而写锁就是排它锁，独占锁，一旦加了写锁，其他用户的读写操作将被阻塞，直到该写锁被释放或者因超时而被释放，在其他用户进行的读写操作，此时就会被执行；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;150&quot;&gt;
&lt;p&gt;　　首先我们来看看mariadb的锁定概念，所谓锁就是当一个进程或事务在操作某一资源时，为了防止其他用户或者进程或事务对其进行资源操作，导致资源抢占而发生冲突，通常在A进程操作该资源时，会对该资源进行加锁，实现多进程或多用户操作同一资源时，不会发生冲突；通常情况锁的类型分读锁和写锁，所谓读锁就是共享锁，它可以实现多个读操作共享；而写锁就是排它锁，独占锁，一旦加了写锁，其他用户的读写操作将被阻塞，直到该写锁被释放或者因超时而被释放，在其他用户进行的读写操作，此时就会被执行；对于锁定范围来讲，它又可以分为，表锁和行锁，从字面意思就可以理解到，表锁就是针对整张表所施加的锁，而这种锁定力度相当粗糙，并发相对就比较低，但是维持锁状态锁消耗的成本资源就较小；对于行锁来说，它针对的范围就是行级别所施加的锁，这种锁的粒度就相对要精细，同时并发相对较高，但是维护锁状态消耗的成本资源就相对要大；对于mysql来讲又分为存储引擎的锁和mysql server的锁，存储引擎的锁指的是对于何时施加锁或者释放锁由存储引擎自行决定；mysql server锁指的是表级别的锁，可自行决定施加锁或释放锁，也允许显式请求加锁或释放锁；显式锁就是用户手动施加的锁，隐式锁指的是由存储引擎根据需要自行施加的锁；对于innodb存储引擎来讲，它支持事务，行级锁；而早期的MyISAM存储引擎它不支持事务，对锁的粒度是表级锁，不支持行级锁；&lt;/p&gt;
&lt;p&gt;　　显示锁的使用&lt;/p&gt;
&lt;p&gt;　　1）LOCK TABLES&lt;/p&gt;
&lt;p&gt;　　　　指令使用语法：&lt;/p&gt;
&lt;p&gt;　　　　LOCK TABLES  tbl_name  read|write, tbl_name read|write, ...&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626212412037-1533969161.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上语句表示对test_tb这张表施加读锁操作，这意味着其他用户或进程都不能对该表进行写的操作，只能对，因为读锁上共享锁；&lt;/p&gt;
&lt;p&gt;　　测试：对test_tb表进行写操作，看看是否能够写进去？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626212801006-823075724.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的提示，它告诉我们test_tb这张表施加了读锁，不允许更新；这说明施加读锁，对于写的操作就不能进行；&lt;/p&gt;
&lt;p&gt;　　测试：对test_tb表进行对操作，看看是否能够进行呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626213558548-384041711.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到加了读锁的表，对于读操作上可以继续进行的；&lt;/p&gt;
&lt;p&gt;　　测试：对test_tb表施加写锁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626213820208-1544666005.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：释放锁用unlock tables即可释放刚才的读锁；&lt;/p&gt;
&lt;p&gt;　　测试：对test_tb进行写操作，看看是否能够进行？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626214028828-1138428923.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在当前终端上是可以进行读写操作的；&lt;/p&gt;
&lt;p&gt;　　测试：在其他终端看看是否能够对test_tb表进行读写操作呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626214252413-124379006.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的截图可以看到当我们重新启动一个终端对test_tb进行写操作，它一直处于阻塞状态；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626214652410-663841854.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：对于对操作也是同样的效果；一直阻塞着；&lt;/p&gt;
&lt;p&gt;　　总结：对于施加读锁的表，是可以进行读操作的，但是不能进行写操作，包括当前终端也不能写操作；对于施加写锁的表，在当前施加锁的终端上是可以对其进行对写操作的，但是在别的终端的对写操作都将阻塞；&lt;/p&gt;
&lt;p&gt;　　除了以上指令来对表进行加锁外，还可以使用 flush tables指令来加读锁，具体语法请看下面；&lt;/p&gt;
&lt;p&gt;　　FLUSH TABLES tbl_name,... [WITH READ LOCK];&lt;/p&gt;
&lt;p&gt;　　测试：加读锁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626215511344-1062175301.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上flush tables 只能加读锁，不能加写锁；&lt;/p&gt;
&lt;p&gt;　　行级锁：SELECT cluase [FOR UPDATE | LOCK IN SHARE MODE]&lt;/p&gt;
&lt;p&gt;　　行级排它锁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626221833150-2015538217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上红框中的内容就是给第一行加了一个排它锁，这意味着该事务没有提交，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排它锁的事务是可以对数据就行读取和修改。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626231606818-689398102.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们重新启动一个事务，然后对第一行进行更新操作，语句就阻塞在哪里了；说明行级排它锁对其他事务来讲是不允许对加锁的行进行写操作；默认情况updeate更新会默认加上排它锁，因为对于第一行来讲，已经有一个排它锁了，所以其他事务就不能对其在加其他锁；而对于select语句来讲，它执行时默认不会加任何锁的，所以我们执行select语句是可以正常的查看第一行数据；如果我们在select后面手动加锁，它也会阻塞的；如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626232448383-1692970215.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的截图信息可以看到，我们手动加上排它锁，查询语句也不会顺利执行；从上面信息还可以了解到，我们对第二行也没法进行操作，这又是为什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626232943529-753663688.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：我们查看test_tb这张表上的索引信息，发现没有索引，然后我们在上面创建了一个索引；创建索引时，需要把前面的事务提交了，才可创建成功，否则一直锁在哪里的；接下来我们在创建一个事务，把第一行加上排它锁，然后在对第二行操作看看是否还会一直阻塞呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626233244559-874215609.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626233348205-1908471477.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当我们创建就了索引后，再对第一行加锁，然后更新第二行就可以正常更新了 ，对第一行还是处于阻塞状态；这说明innodb存储引擎的行级锁的实现其实是依靠其对应的索引，所以如果操作的行并没有用到索引，那么用的还是表级锁。施加行级排它锁后，其他事务将不能对其在施加任何锁；那么对于获取到排它锁的是否能够正常操作呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626234443411-1850460682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：对于获取到排它锁的事务，是可以正常更新的；也可以给对应行施加其他锁；&lt;/p&gt;
&lt;p&gt;　　行级共享锁&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626234612381-630551652.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上红框中的内容表示给第一行施加共享锁，这意味着在其他事务锁可以共享这把锁看到数据，但是不能更新修改数据；&lt;/p&gt;
&lt;p&gt;　　测试：在当前事务中更新数据，看看是否可更新？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626234938259-1672069986.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在当前事务中是可以正常修改数据的；也能正常查看数据；&lt;/p&gt;
&lt;p&gt;　　在其他事务中修改数据，看看是否可修改？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200626235140362-102447095.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到在其他事务中，就不能对有共享锁的行进行修改操作，但是可以正常读；&lt;/p&gt;
&lt;p&gt;　　总结：innodb存储引擎的行级锁依赖索引，如果没有索引，就相当于表级锁；对于排它锁来讲，获取到排它锁的事务是可以正常修改更新以及加共享锁，对于没有获取到排它锁的事务，是不能够对有锁的行进行修改更新以及加锁的操作；对于共享锁来讲，对于当前事务（加锁操作的事务）是可以正常修改更新有锁的行，对于其他事务，是不可修改和更新有锁的行；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 26 Jun 2020 16:20:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>首先我们来看看mariadb的锁定概念，所谓锁就是当一个进程或事务在操作某一资源时，为了防止其他用户或者进程或事务对其进行资源操作，导致资源抢占而发生冲突，通常在A进程操作该资源时，会对该资源进行加锁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13196905.html</dc:identifier>
</item>
<item>
<title>互联网是如何连接的：计网概述 - AD_milk</title>
<link>http://www.cnblogs.com/AD-milk/p/13196820.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AD-milk/p/13196820.html</guid>
<description>&lt;h2 id=&quot;当你在浏览器输入网址之后会发生什么&quot;&gt;当你在浏览器输入网址之后会发生什么&lt;/h2&gt;
&lt;p&gt;最直观的感受当然是跳转到网址所指向的页面啦，但在网络比较卡的时候，你可能注意到过，浏览器的左下角通常会有一些等待什么什么请求之类的小字。这时候，一个问题让你搜索到了这篇博文，我输入网址之后，浏览器到底干了什么？更要命的是，我想知道互联网到底是如何把每个人连接起来的？&lt;/p&gt;
&lt;p&gt;我们先来认识一下你的浏览器，虽然大多数时间你都在使用它愉快的网上冲浪。可能在你的印象里，这个玩意儿就是只能开开网页，看看视频，功能强大，但略显单一。现在，随便找个PDF文件然后打开，你的默认方式应该是你心爱的浏览器。如果不是，可以右键选择打开方式，再用浏览器打开。&lt;/p&gt;
&lt;p&gt;应该都能打开吧？这么一说，好像我们从来没注意过这家伙居然还有别的用处。为什么潜意思里觉得它就是看看网页呢？这里要更新一下名词，实际上我们输入的网址，更准确的叫法应该是URL。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;URL: Uniform Resource Locator,统一资源定位符。词听起来有点绕口，你可以看看现在打开PDF标签页的地址栏，看看它的开头是不是跟网址不一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;URL有各种各样的写法“http:”、“https:&quot;、“ftp：”、“file：”、“mailto：”,开头部分表示了浏览器应当采取的访问方式。那么输入网址之后，首先发生了什么事就呼之欲出了。&lt;/p&gt;
&lt;h2 id=&quot;浏览器先得解析url&quot;&gt;浏览器先得解析URL&lt;/h2&gt;
&lt;p&gt;比如我们要访问博客园的首页，那么应该在地址栏输入https://www.cnblogs.com。浏览器看到URL的开头是https，就会明白这是一个web请求，后面的&lt;code&gt;www.cnblogs.com&lt;/code&gt;指的是Web服务器域名。&lt;/p&gt;
&lt;p&gt;域名可以看成是IP地址的别名，你可以在搜索引擎里输入IP，你会看到一连串的数字。没有人会希望上个网还要先拿小本本把经常用到的IP地址记下来，再说，输入这一连串的数字也很麻烦，一不小心就输错了。所以我们使用域名来代替IP地址，帮助记忆。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;IP地址：你可以类比于现实中的住房地址，因特网上的计算机也拥有一个惟一标识符来区别它的网上邻居(其他的电脑)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;APP支持IPv6网络是怎么回事？你可能在APP启动界面的底部看到过这行小字，实际上IPv6之前是IPv4(互联网通信协议第四版),就是一个给大家分配地址的协议，在这个版本里IP用32位的整数表示。32位？看起来很长的样子，然而2011年的时候，IANA就宣布IPv4地址43亿IP地址已经分配完毕。&lt;/p&gt;
&lt;p&gt;后续的IPv6可谓是超级加强版，32位扩展到了128位意味着能给地球上每一粒沙子编号，他能分配大约3.4×10^38个IP地址！&lt;/p&gt;
&lt;h2 id=&quot;向dns查询web服务器的ip地址&quot;&gt;向DNS查询Web服务器的IP地址&lt;/h2&gt;
&lt;p&gt;域名对应着IP地址，那么如何才能知道这个域名对应的IP地址是什么呢？自然是得问拿小本本记下这些东西的人啦。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;DNS : 一个可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只用一台DNS服务器去存储数不胜数的IP地址是不可能的，所以在分散保存的情况下，一台DNS是如何处理它查询不到的域名信息呢？&lt;/p&gt;
&lt;p&gt;实际上，如同域名一样，DNS也是分级的。域名的最左边部分表示机器名字，它随后的部分则是该计算机所属的组织，可能还会有子组织。最右边则代表顶级域名，指定该计算机所属组织的类型。大部分的顶级域都被用于美国的公司和组织，其他国家的计算机一般是用国家的特有顶级域，比如cn(中国)。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;顶级域&lt;/th&gt;
&lt;th&gt;主要应用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;edu&lt;/td&gt;
&lt;td&gt;教育机构&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;com&lt;/td&gt;
&lt;td&gt;商业公司&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;org&lt;/td&gt;
&lt;td&gt;非盈利组织&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;net&lt;/td&gt;
&lt;td&gt;网络供应商&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;cn&lt;/td&gt;
&lt;td&gt;中国国家顶级域名&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;负责管理下级域的DNS服务器找不到该域名对应的IP地址就会发送一个请求到它们的上级DNS服务器中去寻找，然后上级DNS还找不到就到更上一级的DNS服务器中，以此类推。最上一级叫做根域，根域服务器的地址在配置DNS服务器的时候就已经写入其配置文件里面了。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;分配给根域DNS服务器的IP地址在全世界仅有13个，很遗憾中国没有。日本占据一个，其他的全是欧美。&lt;/p&gt;
&lt;p&gt;虽然IP地址只有13个，但实际上服务器的数量远远多于13个，因为根域DNS是使用多台服务器对应一个IP地址的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1932912/202006/1932912-20200626231945750-1132956197.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不知道你是否有过浏览器突然不能访问网页的经历，更离谱的是QQ居然能用，就他浏览器不行。这是为什么呢？多半是DNS服务器地址的问题，在 控制面板\网络和 Internet\网络连接 右键属性选择IPv4 改成下图一般就好了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1932912/202006/1932912-20200626232056397-1770088444.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么QQ没问题呢？因为QQ是直接通过IP连接的。&lt;/p&gt;
&lt;h2 id=&quot;你访问的其实是文件&quot;&gt;你访问的其实是文件&lt;/h2&gt;
&lt;p&gt;现在不如点开一下我首页的第一篇博客吧，或者直接访问&lt;code&gt;https://www.cnblogs.com/AD-milk/p/13171059.html&lt;/code&gt;然后按下F12打开开发者模式，让我们看看都有些什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1932912/202006/1932912-20200626232111884-520203427.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们请求了一个html文件，1317...好像就是输入的网址里的那个。这么说的话，这一个一个斜杆好像确实是像文件路径的结构!&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1932912/202006/1932912-20200626232132676-933120258.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1932912/202006/1932912-20200626232142795-965764377.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但如果你访问博客园的首页，你会发现路径名那里只有一个/，这表示根目录，好像并没有指定文件呀。这种省略文件名的情况下，一般是默认访问根目录下的index.html或者default.html这样的文件。&lt;/p&gt;
&lt;blockquote readability=&quot;4.904347826087&quot;&gt;
&lt;p&gt;html：&lt;a href=&quot;https://baike.baidu.com/item/%E8%B6%85%E6%96%87%E6%9C%AC%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6972570&quot;&gt;超文本标记语言&lt;/a&gt;，你可以简单的认为是可以在文本中嵌入音频，图片和链接的语言&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按理说我们只是请求了13171059.html这个文件，但从图中来看我们好像请求了不止一个文件，这是为什么？回想一下，你会有过因为网卡而导致加载的页面只有文字的情况？这一般是因为网络问题，css文件以及图片没有被传输过来。浏览器在加载文件之前并不知道这里还需要什么图片或者文件,只有加载之后才会继续发送请求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1932912/202006/1932912-20200626232202517-91380275.jpg&quot; alt=&quot;博文中图片的源代码&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;css文件是一种用来指定html样式的文件。缺少了它页面就没有好看的风格了。&lt;/p&gt;
&lt;p&gt;1 条请求消息中只能写 1 个 URI。如果需要获取多个文件，必须对每个文件单独发送 1 条请求。&lt;/p&gt;
&lt;p&gt;URI：Uniform Resource Identifier，统一资源标识符，URL是特殊的URI&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;眨眼间的旅途&quot;&gt;眨眼间的旅途&lt;/h2&gt;
&lt;p&gt;你说的我都知道了，可你还是没有回答我，互联网到底是如何互联的？&lt;/p&gt;
&lt;p&gt;首先来考虑一个简单的场景：两台电脑之间如何互相通讯？当然是接跟线把两个都连上啦，那再来五台怎么办？往电脑上再打五个接口？这显然不现实，我们可以让集线器帮我们的忙。它具有多个端口，可以实现其内部所有网络设备的连通。不过集线器是个榆木脑袋，它唯一知道的事情就是：当某一个端口发出数据时，它就把这个数据复制到与其连接的其他端口，这样所有连接到集线器的设备都可以获得这个数据包。这跟个大喇叭一样，太烦人了，说点悄悄话都不行。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;之所以电缆不如光纤通信速率高，是因为电信号在提升通信速率的同时，其衰减率也会提高（信号在传播过程中减弱），导致信号无法传到目的地。相对地，光信号本来的衰减率就很低，提高通信速率也并不会提高衰减率。此外，光纤还不受电磁噪声的影响，因此光纤能够进行高速通信。&lt;/p&gt;
&lt;p&gt;不是光信号本来就比电信号快啦！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了解决广播所带来的安全问题，以及减少不必要的流量，我们可以换个聪明点的家伙：交换机。交换机比集线器智能的地方在于，它记下了与其相连的主机的物理地址MAC，他把这些存储在地址表里面。那么现在，当数据报从一个端口发出时，它能根据数据报提供的目标MAC，直接将数据发往预期的目的端口。终于可以和喜欢的女同学说悄悄话了，呼~~。&lt;/p&gt;
&lt;p&gt;但集线器和交换机只能在局域网中交换信息，无法在外部网络交换。因为要在互联网上通讯需要识别IP地址，显然集线器和交换机没有这个功能。所以我们需要用到路由器：它是一个能根据IP地址，将数据报从一个路由转发到另外一个路由的设备。这意味着它具有过滤功能，但一个数据报达到该路由时，它会检查这是否是发给自己的，如果不是的话就将它转发给其他路由。所以它相当于一个网络的网关。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现在的路由器大多集成了三者的功能，成了“瑞士军刀”。让人想不到的是，尽管交换机比路由器简单，但实际上路由器早于交换机问世。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在从我们电脑发出的请求数据报就沿着电路，被多个路由器转发，最后到达目的地。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1932912/202006/1932912-20200626232227920-779439303.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，这眨眼间的漫长旅途迎来了终点。但其实网络通讯远不止这些，这里省去了很多东西，其中最重要的就是各式各样的协议了。缺少协议会使得网络世界通讯困难，就好比现实生活中你觉得点头表示OK，摇头表示NO，但另外一个人却持相反的认识，这时候你们俩的交流就会遇上大麻烦！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;协议：定义了在两个或多个通信实体之间交换的报文格式和顺序，以及报文发送和接收一条报文或其他事件采取的动作&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 26 Jun 2020 15:29:00 +0000</pubDate>
<dc:creator>AD_milk</dc:creator>
<og:description>当你在浏览器输入网址之后会发生什么 最直观的感受当然是跳转到网址所指向的页面啦，但在网络比较卡的时候，你可能注意到过，浏览器的左下角通常会有一些等待什么什么请求之类的小字。这时候，一个问题让你搜索到了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AD-milk/p/13196820.html</dc:identifier>
</item>
<item>
<title>状态机模式 与 ajax 的结合运用 - manbax</title>
<link>http://www.cnblogs.com/GManba/p/13196792.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GManba/p/13196792.html</guid>
<description>&lt;p&gt;太神奇了，昨晚做了个梦，梦中我悟出一个道理：凡是涉及到异步操作而且需要返回值的函数，一定要封装成 Promise 的形式，假如返回值取决于多个异步操作的结果，那么需要对每个异步操作进行状态的设计，而且需要封装一个 next 函数。😂😂😂，到了晚上才觉到很有意思，所以结合 ajax 设置最短返回时间 和 最大返回时间进行实践：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  const PENDING = 'PENDING'
  const RESOLVED = 'RESOLVED'
  const REJECTED = 'REJECTED'
  const FULLFILLED = 'FULLFILLED'

  /**
   * @desc 异步操作模拟
   * @param time 响应时间
   * @param isError 是否抛错
   */
  const mock = (time, isError) =&amp;gt; {
    return new Promise((resolve, reject) =&amp;gt; {
      setTimeout(() =&amp;gt; {
        if (!isError) {
          resolve({ user: 'ManbaX' })
        } else {
          reject('request error')
        }
      }, time)
    })
  }

  /**
   * @desc 生产不同类型请求的工厂函数
   * @param time 响应时间
   * @param isError 是否抛错
   */
  var RequestFactory = function (time, isError) {
    var request = function () {
      return new Promise((resolve, reject) =&amp;gt; {
        var min = PENDING
        var max = PENDING
        var state = PENDING
        var res = null

        var next = function (name) {
          const cb = function () {
            if (state === RESOLVED) {
              resolve(res)
            } else {
              reject(res)
            }
          }
          if (name === 'res' &amp;amp;&amp;amp; min === FULLFILLED) {
            cb()
          }

          if (name === 'min' &amp;amp;&amp;amp; (state === RESOLVED || state === REJECTED)) {
            cb()
          }

          if (name === 'max' &amp;amp;&amp;amp; state === PENDING) {
            reject('timeout')
          }
        }

        setTimeout(() =&amp;gt; {
          min = FULLFILLED
          next('min')
        }, 500)

        setTimeout(() =&amp;gt; {
          max = FULLFILLED
          next('max')
        }, 1000)

        mock(time, isError).then(data =&amp;gt; {
          res = data
          state = RESOLVED
          next('res')
        }).catch(error =&amp;gt; {
          res = error
          state = REJECTED
          next('res')
        })
      })
    }

    return request
  }

  // 不超时, 不返回错误
  console.time('r1')
  RequestFactory(200)().then(res =&amp;gt; {
    console.log('data: ', res)
  }).finally(() =&amp;gt; {
    console.timeEnd('r1')
  })
  
  // 不超时, 返回错误
  console.time('r2')
  RequestFactory(200, true)().catch(err =&amp;gt; {
    console.log('error', err)
  }).finally(() =&amp;gt; {
    console.timeEnd('r2')
  })

  // 超时
  console.time('r3')
  RequestFactory(2000)().catch(res =&amp;gt; {
    console.log('error: ', res)
  }).finally(() =&amp;gt; {
    console.timeEnd('r3')
  })

  console.time('r4')
  RequestFactory(2000)().catch(res =&amp;gt; {
    console.log('error: ', res)
  }).finally(() =&amp;gt; {
    console.timeEnd('r4')
  })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2032346/202006/2032346-20200626231503286-1150836422.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的运行结果符合预期，本来梦中还有另外一个有意思的东西，但是太模糊了就搞忘记了，下次一定早点记录。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jun 2020 15:16:00 +0000</pubDate>
<dc:creator>manbax</dc:creator>
<og:description>太神奇了，昨晚做了个梦，梦中我悟出一个道理：凡是涉及到异步操作而且需要返回值的函数，一定要封装成 Promise 的形式，假如返回值取决于多个异步操作的结果，那么需要对每个异步操作进行状态的设计，而且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/GManba/p/13196792.html</dc:identifier>
</item>
<item>
<title>数据结构与算法（七）：迷宫回溯和八皇后问题 - 山猫大战响尾蛇</title>
<link>http://www.cnblogs.com/Createsequence/p/13196730.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Createsequence/p/13196730.html</guid>
<description>&lt;h2 id=&quot;一、迷宫回溯问题&quot;&gt;一、迷宫回溯问题&lt;/h2&gt;
&lt;h3 id=&quot;1问题&quot;&gt;1.问题&lt;/h3&gt;
&lt;p&gt;一个7*8的数组模拟迷宫，障碍用1表示，通路使用0表示，给定起点（1,1）和终点（6,5），要求给出起点到终点的通路&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiajibagao.top/20200626224906.png&quot;/&gt;&lt;img src=&quot;http://img.xiajibagao.top/20200626224701.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2解题思路&quot;&gt;2.解题思路&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首先，我们需要给程序一个寻向的基本策略，我们先假定寻向顺序为“下-右-上-左”，也就是说从起点出发，先往下走，往下走不通就往右.....以此类推&lt;/li&gt;
&lt;li&gt;然后我们需要给走过的路一个标记，暂记为2&lt;/li&gt;
&lt;li&gt;而当从一个方向走到一个只能原路返回的死胡同时，就给这段路标记为3&lt;/li&gt;
&lt;li&gt;当抵达终点坐标（6,5）时程序结束&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;3代码实现&quot;&gt;3.代码实现&lt;/h3&gt;
&lt;h4 id=&quot;31生成地图&quot;&gt;3.1生成地图&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 创建一个二维数组,用于模拟8*7迷宫
 * 使用1表示不可通过的实心方块，0表示可通过砖块
 * （6,5）为默认终点，（1,1）为默认起点
 * @return
 */
public static int[][] getMap(){
    int[][] map = new int[8][7];
    //上下全置为1
    for(int i = 0;i &amp;lt;7 ;i++){
        map[0][i] = 1;
        map[7][i] = 1;
    }
    //左右全置为1
    for(int i = 0;i &amp;lt; 8;i++){
        map[i][0] = 1;
        map[i][6] = 1;
    }
    //设置挡板
    map[3][1] = 1;
    map[3][2] = 1;

    //输出地图
    System.out.println(&quot;地图的初始情况:&quot;);
    showMap(map);

    return map;
}

/**
 * 展示地图
 * @param map
 */
public static void showMap(int[][] map) {
    for(int i = 0;i &amp;lt; 8;i++){
        for(int j = 0;j &amp;lt; 7;j++){
            System.out.print(map[i][j] + &quot; &quot;);
        }
        System.out.println();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;32-寻路逻辑的实现&quot;&gt;3.2 寻路逻辑的实现&lt;/h4&gt;
&lt;p&gt;对于这个寻路程序，我们可以看见，往四个方向走的过程实际上除了方向外动作上是一样的；而具体分析同一个方向，每走过一个坐标的动作也是一样的，我们对流程进行分析：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;出发，先往下走，判断下一格有没有障碍（&lt;code&gt;int[x][y]==1&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;如果没有障碍，就继续往下走，然后重复步骤1到碰到障碍为止&lt;/li&gt;
&lt;li&gt;如果有障碍，就按“下-右-上-左”的顺序，换个方向，然后重复步骤1到碰到障碍为止&lt;/li&gt;
&lt;li&gt;如果找到了（6,5）就结束&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;表现为代码实际上就是一个递归的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;找路是方法体&lt;/li&gt;
&lt;li&gt;找到了（6,5）或者死胡同是终止条件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 给定起始点，根据地图找路
 * 使用2表示可以走通的路，使用3表示走过但是不通的路
 * @param map 地图二维数组
 * @param x 起始点横坐标
 * @param y 起始点纵坐标
 * @return
 */
public static boolean findWay(int[][] map, int x, int y) {
    //如果走到了终点就终止
    if (map[6][5] == 2){
        return true;
    }else {
        //只有为0的路才能通过
        if (map[y][x] == 0) {
            //如果该点可以走通就打上标记
            map[y][x] = 2;
            if (findWay(map, x, y + 1)) {
                //向下递归
                return true;
            } else if (findWay(map, x + 1, y)) {
                //向右递归
                return true;
            } else if (findWay(map, x, y - 1)) {
                //向上递归
                return true;
            } else if (findWay(map, x - 1, y)) {
                //向左递归
                return true;
            } else {
                //都走不通说明是死胡同
                map[y][x] = 3;
                return false;
            }
        }else {
            //不为0说明要么是死路要么是障碍
            return false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;33-运行结果&quot;&gt;3.3 运行结果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiajibagao.top/20200626225137.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;http://img.xiajibagao.top/20200626225158.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;findWay()&lt;/code&gt;方法中的终止条件从&lt;code&gt;map[6][5] == 2&lt;/code&gt;换成其他坐标即可更换终点位置，&lt;/p&gt;
&lt;p&gt;棋盘大小和障碍物位置不影响&lt;code&gt;findWay()&lt;/code&gt;方法寻路。&lt;/p&gt;
&lt;h2 id=&quot;二、八皇后问题&quot;&gt;二、八皇后问题&lt;/h2&gt;
&lt;h3 id=&quot;1问题-2&quot;&gt;1.问题&lt;/h3&gt;
&lt;p&gt;皇后问题，一个古老而著名的问题，是&lt;strong&gt;回溯算法&lt;/strong&gt;的典型案例。该问题由国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：&lt;/p&gt;
&lt;p&gt;在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，求有多少种摆法？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.xiajibagao.top/20200626224753&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2解题思路-2&quot;&gt;2.解题思路&lt;/h3&gt;
&lt;ol readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;首先，我们先使用一个长度为8数组来表示八皇后的摆放位置，&lt;strong&gt;数组下标+1即表示棋盘的第几行&lt;/strong&gt;，&lt;strong&gt;数组下标对应的存放的数字+1即为棋盘的第几列&lt;/strong&gt;。举个例子：&lt;/p&gt;
&lt;p&gt;arr = {0,2,3,8,4,6,2,7}&lt;/p&gt;
&lt;p&gt;其中，元素0下标为0，即表示&lt;strong&gt;第一行第一列&lt;/strong&gt;；元素2下标为1，即表示&lt;strong&gt;第二行第三列&lt;/strong&gt;......以此类推。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;任意假设任意坐标分标为&lt;code&gt;(x1,y1)，(x2,y2)&lt;/code&gt;，也就是用数组表示为&lt;code&gt;arr[x1]=y1，arr[x2]=y2&lt;/code&gt;的两个皇后不允许在同一列，我们可以理解为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arr[x1] != arr[x2]&lt;/code&gt;;&lt;/p&gt;
&lt;p&gt;而任意坐标的皇后不允许在同一斜线，即&lt;code&gt;(x2-x1)=(y2-y1)&lt;/code&gt;，也就是斜率不应当相同，我们可以理解为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Math.abs(x2-x1) != Math.abs(arr[x2]-arr[x1])&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;（注：&lt;code&gt;Math.abs()&lt;/code&gt;为求绝对值方法）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;3代码实现-2&quot;&gt;3.代码实现&lt;/h3&gt;
&lt;h4 id=&quot;31-检查摆放位置的代码实现&quot;&gt;3.1 检查摆放位置的代码实现&lt;/h4&gt;
&lt;p&gt;在前面明确了如何用数组表示位置，以及如何检查皇后是否允许摆放后，我们有如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//表示皇后位置的数组
int[] arr = new int[8];

/**
 * 检查第n个皇后是否与前面摆放的皇后冲突
 * @param n
 * @return
 */
public boolean check(int n) {
    //检查第n层之前的皇后位置
    for (int i = 0; i &amp;lt; n; i++) {
        // arr[i] == arr[n] 检查是否同一列
        // Math.abs(n - i) == Math.abs(arr[n] - arr[i]) 检查是否同一斜线
        if (arr[i] == arr[n] ||
            Math.abs(n - i) == Math.abs(arr[n] - arr[i])) {
            return false;
        }
    }
    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;32-完整代码&quot;&gt;3.2 完整代码&lt;/h4&gt;
&lt;p&gt;接着我们需要考虑如何使用递归方法来做到以下效果：&lt;/p&gt;
&lt;p&gt;使用一个方法遍历第n行的每一列，检查每一列是否可以放置皇后：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果可以放置皇后，将位置出入arr[n]中，然后递归调用自己，传入n+1开始遍历下一行.....以此类推&lt;/li&gt;
&lt;li&gt;如果不可以放置皇后，就跳过该列检查下一列，如果可以就重复步骤1&lt;/li&gt;
&lt;li&gt;若n行中全部位置都不合适，则结束本层返回上一层n-1层，重复步骤1&lt;/li&gt;
&lt;li&gt;如果最后n=8，即八个皇后全部放置完毕，记一次完成摆放，然后结束递归返回第一层，继续检查第一层的下一列&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最终代码实现结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @Author：黄成兴
 * @Date：2020-06-26 20:53
 * @Description：八皇后问题
 */
public class EightQueens {

    public static void main(String[] args) {
        EightQueens eightQueens = new EightQueens();
        eightQueens.set(0);
        System.out.println(&quot;共有摆法：&quot; + eightQueens.count);
    }

    //记录八皇后有几种摆法
    int count = 0;

    //表示皇后位置的数组
    int[] arr = new int[8];

    /**
     * 摆放皇后
     * @param n 第几个皇后
     */
    private void set(int n) {
        //如果放置好了第8个皇后
        if (n == 8){
            show();
            //记录一种摆放方式
            count++;
            //回到第一层继续递归
            return;
        }

        //遍历第n行的每一列
        for (int i = 0; i &amp;lt; 8; i++) {
            //将该皇后放置在第n行第i列
            arr[n] = i;
            //检查放置位置是否合适
            if (check(n)){
                //如果位置合适，就递归找下一个（n+1）皇后的摆放位置
                set(n + 1);
            }
            //如果位置不合适，就跳过这一列检查下一列
        }
    }

    /**
     * 检查第n个皇后是否与前面摆放的皇后冲突
     * @param n
     * @return
     */
    public boolean check(int n) {
        //检查第n层之前的皇后位置
        for (int i = 0; i &amp;lt; n; i++) {
            // arr[i] == arr[n] 检查是否同一列
            // Math.abs(n - i) == Math.abs(arr[n] - arr[i]) 检查是否同一斜线
            if (arr[i] == arr[n] ||
                Math.abs(n - i) == Math.abs(arr[n] - arr[i])) {
                return false;
            }
        }
        return true;
    }
    

    /**
     * 展示某一摆法中八皇后的摆放位置
     */
    public void show() {
        for (int i : arr) {
            System.out.print(i + &quot; &quot;);
        }
        System.out.println();
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 26 Jun 2020 14:52:00 +0000</pubDate>
<dc:creator>山猫大战响尾蛇</dc:creator>
<og:description>一、迷宫回溯问题 1.问题 一个7*8的数组模拟迷宫，障碍用1表示，通路使用0表示，给定起点（1,1）和终点（6,5），要求给出起点到终点的通路 2.解题思路 首先，我们需要给程序一个寻向的基本策略，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Createsequence/p/13196730.html</dc:identifier>
</item>
<item>
<title>设计模式系列之代理模式(Proxy Pattern)——对象的间接访问 - 行无际</title>
<link>http://www.cnblogs.com/itwild/p/13196590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itwild/p/13196590.html</guid>
<description>&lt;p&gt;说明：设计模式系列文章是读&lt;code&gt;刘伟&lt;/code&gt;所著&lt;code&gt;《设计模式的艺术之道(软件开发人员内功修炼之道)》&lt;/code&gt;一书的阅读笔记。个人感觉这本书讲的不错，有兴趣推荐读一读。详细内容也可以看看此书作者的博客&lt;code&gt;https://blog.csdn.net/LoveLion/article/details/17517213&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;模式概述&quot;&gt;模式概述&lt;/h2&gt;
&lt;p&gt;近年来，代购已逐步成为电子商务的一个重要分支。何谓代购，简单来说就是找人帮忙购买所需要的商品，当然你可能需要向实施代购的人支付一定的费用。代购通常分为两种类型：一种是因为在当地买不到某件商品，又或者是因为当地这件商品的价格比其他地区的贵，因此托人在其他地区甚至国外购买该商品，然后通过快递发货或者直接携带回来；还有一种代购，由于消费者对想要购买的商品相关信息的缺乏，自已无法确定其实际价值而又不想被商家宰，只好委托中介机构帮其讲价或为其代买。&lt;/p&gt;
&lt;p&gt;在软件开发中，也有一种设计模式可以提供与代购类似的功能。由于某些原因，客户端无法直接访问某个对象或访问某个对象存在困难时，可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。&lt;/p&gt;
&lt;h3 id=&quot;模式定义&quot;&gt;模式定义&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;代理模式(&lt;code&gt;Proxy Pattern&lt;/code&gt;)：给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。&lt;/p&gt;
&lt;h3 id=&quot;模式结构图&quot;&gt;模式结构图&lt;/h3&gt;
&lt;p&gt;代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层，代理模式结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1546632/202006/1546632-20200626205846504-1037997627.png&quot; alt=&quot;代理模式结构图&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代理模式包含如下三个角色：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模式伪代码&quot;&gt;模式伪代码&lt;/h3&gt;
&lt;p&gt;代理模式的结构图比较简单，但是在真实的使用和实现过程中要复杂很多，特别是代理类的设计和实现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;抽象主题类&lt;/code&gt;声明了真实主题类和代理类的公共方法，它可以是接口、抽象类或具体类，客户端针对抽象主题类编程，一致性地对待真实主题和代理主题，典型的抽象主题类代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Subject {
    void request();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;真实主题类&lt;/code&gt;实现了抽象主题类，提供了业务方法的具体实现，其典型代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RealSubject implements Subject {
    @Override
    public void request() {
        //业务方法具体实现代码
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;代理类&lt;/code&gt;也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法来对功能进行扩充或约束，最简单的代理类实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Proxy implements Subject {
    // 维持一个对真实主题对象的引用
    private RealSubject realSubject;

    public Proxy(RealSubject realSubject) {
        this.realSubject = realSubject;
    }

    public void preRequest() {
        // ...
    }

    public void postRequest() {
        // ...
    }

    @Override
    public void request() {
        preRequest();
        // 调用真实主题对象的方法
        realSubject.request();
        postRequest();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;模式应用&quot;&gt;模式应用&lt;/h2&gt;
&lt;p&gt;像上面代理类所实现的接口和所代理的方法都在代码中写死，被称之为&lt;code&gt;静态代理&lt;/code&gt;。如果要为不同类的不同方法生成静态代理，代理类的数量将会发生爆炸。Java中也提供了对&lt;code&gt;动态代理&lt;/code&gt;的支持。所谓动态代理(&lt;code&gt;Dynamic Proxy&lt;/code&gt;)，是指系统运行时动态生成代理类。&lt;/p&gt;
&lt;p&gt;JDK中提供的动态代理只能代理一个或者多个接口，如果需要动态代理具体类或者抽象类，可以使用&lt;code&gt;CGLib&lt;/code&gt;(Code Generation Library)等工具。CGLib是一个功能较为强大、性能也较好的代码生成包，在许多&lt;code&gt;AOP&lt;/code&gt;框架中得到广泛应用。后面我会专门写一篇探究动态代理实现的博客，将全面细致地介绍动态代理。&lt;/p&gt;
&lt;h2 id=&quot;模式总结&quot;&gt;模式总结&lt;/h2&gt;
&lt;p&gt;代理模式是常用的结构型设计模式之一，它为对象的间接访问提供了一个解决方案，可以对对象的访问进行控制。代理模式类型较多，其中远程代理、虚拟代理、保护代理等在软件开发中应用非常广泛。&lt;/p&gt;
&lt;h3 id=&quot;主要优点&quot;&gt;主要优点&lt;/h3&gt;
&lt;p&gt;(1) 能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。&lt;/p&gt;
&lt;p&gt;(2) 客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。&lt;/p&gt;
&lt;p&gt;此外，不同类型的代理模式也具有独特的优点，例如：&lt;/p&gt;
&lt;p&gt;(1) 远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。&lt;/p&gt;
&lt;p&gt;(2) 虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。&lt;/p&gt;
&lt;p&gt;(3) 缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。&lt;/p&gt;
&lt;p&gt;(4) 保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。&lt;/p&gt;
&lt;h3 id=&quot;主要缺点&quot;&gt;主要缺点&lt;/h3&gt;
&lt;p&gt;(1) 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。&lt;/p&gt;
&lt;p&gt;(2) 实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。&lt;/p&gt;
&lt;h3 id=&quot;适用场景&quot;&gt;适用场景&lt;/h3&gt;
&lt;p&gt;代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：&lt;/p&gt;
&lt;p&gt;(1) 当客户端对象需要访问远程主机中的对象时可以使用远程代理。&lt;/p&gt;
&lt;p&gt;(2) 当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。&lt;/p&gt;
&lt;p&gt;(3) 当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。&lt;/p&gt;
&lt;p&gt;(4) 当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。&lt;/p&gt;
&lt;p&gt;(5) 当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。&lt;/p&gt;
</description>
<pubDate>Fri, 26 Jun 2020 14:11:00 +0000</pubDate>
<dc:creator>行无际</dc:creator>
<og:description>说明：设计模式系列文章是读刘伟所著《设计模式的艺术之道(软件开发人员内功修炼之道)》一书的阅读笔记。个人感觉这本书讲的不错，有兴趣推荐读一读。详细内容也可以看看此书作者的博客https://blog.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itwild/p/13196590.html</dc:identifier>
</item>
<item>
<title>动态追踪技术之SystemTap - 小胖西瓜</title>
<link>http://www.cnblogs.com/shuqin/p/13196585.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shuqin/p/13196585.html</guid>
<description>&lt;p&gt;SystemTap是一个深入检查Linux系统活动的工具，使用该工具编写一些简单的代码就可以轻松的提取应用或内核的运行数据，以诊断复杂的性能或者功能问题。有了它，开发者不再需要重编译、安装新内核、重启动等烦人的步骤，应用程序同理。&lt;/p&gt;
&lt;p&gt;配合火焰图的可视化，对程序的性能分析极其有利。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;原理&lt;/h2&gt;
&lt;p&gt;SystemTap 基本思想是命名事件，并为它们提供处理程序。每当发生指定的事件时，内核都会将处理程序视为子例程运行，然后继续运行。有一系列的事件，例如进入或退出函数，计时器到期或整个SystemTap会话的开始和停止。处理程序是一系列脚本语言语句，用于指定事件发生时要完成的工作。这项工作通常包含从事件上下文中提取数据，将其存储到内部变量或打印结果。&lt;/p&gt;
&lt;p&gt;SystemTap 的工作原理是将脚本翻译成C语言，执行C编译器创建一个内核模块。当模块被加载后，通过挂载到内核来激活所有的探测事件。然后，当事件发生再任何处理器上时，编译后的处理程序就运行，最终，SystemTap绘画停止，Hook取消，内核模块被移除，整个过程由命令行程序stap驱动。&lt;/p&gt;
&lt;p&gt;原理图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1461087/202006/1461087-20200626220804856-1431058467.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;需要内核级别的支持，依赖了三个rpm&lt;a href=&quot;https://www.cnblogs.com/shuqin/p/13196585.html#rpm_addr&quot;&gt;下载链接&lt;/a&gt;，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;kernel-debuginfo-common&lt;/li&gt;
&lt;li&gt;kernel-debuginfo&lt;/li&gt;
&lt;li&gt;kernel-devel&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这三个包的版本必须匹配当前内核的版本，比如我自己的内核版本是 &lt;code&gt;3.10.0-327&lt;/code&gt;, 那么以上三个包版本都必须保持一致。&lt;/p&gt;
&lt;p&gt;安装 SystemTap：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$ yum install systemtap&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;测试是否成功安装：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;$ stap -ve 'probe begin{printf(&quot;Hello, World\n&quot;); exit();}'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正常的话会输出 Hello, World，但是不出意外会出现版本不一致的情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;ERROR: module version mismatch (#1 SMP Fri Nov 20 11:12:42 CST 2015 vs #1 SMP Thu Nov 19 22:10:57 UTC 2015), release 3.10.0-327.el7.x86_64
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;出现这个的情况是版本相同但是打包事件不相同的情况，修改这个时间和uname -a 中的时间保持一致。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ rpm -ql kernel-devel | xargs grep UTS_VERSION 2&amp;gt;/dev/null

/usr/src/kernels/3.10.0-327.el7.x86_64/include/generated/compile.h:#define UTS_VERSION &quot;#1 SMP Fri Nov 20 11:12:42 CST 2015&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行那个hello测试，出现缓存的错误，删除缓存文件&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;/root/.systemtap/cache/34/stap_34443d4ad1fe1d37c0352b7b8c691aee_975.c&lt;/li&gt;
&lt;li&gt;/root/.systemtap/cache/34/stap_34443d4ad1fe1d37c0352b7b8c691aee_975.ko&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;追踪&quot;&gt;追踪&lt;/h2&gt;
&lt;p&gt;最简单的探测类型就是跟踪事件。Systemtap支持许多内置事件，所有的事件家族见 &lt;code&gt;tapset&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可以探测的的常用事件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;begin, systemtap 会话开始&lt;/li&gt;
&lt;li&gt;end, systemtap 会话结束&lt;/li&gt;
&lt;li&gt;kernel.function(&quot;sys_xxx&quot;), 系统调用xx的入口&lt;/li&gt;
&lt;li&gt;kernel.function(&quot;sys_xxx&quot;).return, 系统调用xx的返回&lt;/li&gt;
&lt;li&gt;timer.ms(300), 每300毫秒的定时器&lt;/li&gt;
&lt;li&gt;timer.profile, 每个CPU上周期触发的定时器&lt;/li&gt;
&lt;li&gt;process(&quot;a.out&quot;).function(&quot;foo*&quot;), a.out 中函数名前缀为foo的函数信息&lt;/li&gt;
&lt;li&gt;process(&quot;a.out&quot;).statement(&quot;*@main.c:200&quot;), a.out中文件main.c 200行处的状态&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常用的可打印值（具体见 tapset）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;tid(), 当前线程id&lt;/li&gt;
&lt;li&gt;pid(), 当前进程id&lt;/li&gt;
&lt;li&gt;uid(), 当前用户id&lt;/li&gt;
&lt;li&gt;execname(), 当前进程名称&lt;/li&gt;
&lt;li&gt;cpu(), 当前cpu编号&lt;/li&gt;
&lt;li&gt;gettimeofday_s(), 秒时间戳&lt;/li&gt;
&lt;li&gt;get_cycles(), 硬件周期计数器快照&lt;/li&gt;
&lt;li&gt;pp(), 探测点事件名称&lt;/li&gt;
&lt;li&gt;ppfunc(), 探测点触发的函数名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$$var&lt;/code&gt;, 上下文中存在 &lt;code&gt;$var&lt;/code&gt;，可以使用该变量&lt;/li&gt;
&lt;li&gt;print_backtrace(), 打印内核栈&lt;/li&gt;
&lt;li&gt;print_ubacktrace(), 打印用户空间栈&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;systemtap-脚本&quot;&gt;SystemTap 脚本&lt;/h2&gt;
&lt;p&gt;stap 脚本简单，语法类似C；&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;# fuck
// fuck
/* fuck */
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;function foo() {
    // exit(); // 退出 systemtap 会话
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;基本的 if/else/while/for 控制结构&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;function if_expr() {
    i = 0
    if (i == 1)
        printf(&quot;[if] i = %d\n&quot;, i);
    else
        printf(&quot;[else] i = %d\n&quot;, i);
}

function while_expr() {
    i = 0;
    while (i != 2)
        printf(&quot;[while] i = %d\n&quot;, i++);
}

function for_expr() {
    for (i = 0; i &amp;lt; 2; i++)
        printf(&quot;[for] i = %d\n&quot;, i);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;字符串比较，拼接，转换&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-lua&quot;&gt;function str() {
    uid = uid();
    s_uid = sprint(uid);
    f_uid = &quot;fuck&quot; . s_uid
    printf(&quot;uid: %d-%s-%s\n&quot;, uid, s_uid); // uid: 0-0-fuck0

    // exit();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;global t; // 声明元组
global tpl[400]; // 声明一个400容量的元组

t[&quot;fuck&quot;]++;  // t[&quot;fuck&quot;] 初始值默认为0, ++ 变成 1
t[&quot;fuck&quot;] = 4396; // 赋值为4396

tpl[&quot;fuck&quot;, pid()]++; // 两个元素
tpl[&quot;shit&quot;, tid()]++;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;聚集统计&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 包含4个维度 @count @avg @min @max
global t;

t[&quot;fuck&quot;, tid()] &amp;lt;&amp;lt;&amp;lt; 1
t[&quot;fuck&quot;, pid()] &amp;lt;&amp;lt;&amp;lt; 1
t[execname(), tid()] &amp;lt;&amp;lt;&amp;lt; 1
t[&quot;fuck&quot;, 5487] &amp;lt;&amp;lt;&amp;lt; 2
t[&quot;fuck&quot;, 5487] &amp;lt;&amp;lt;&amp;lt; 3
t[&quot;fuck&quot;, 5487] &amp;lt;&amp;lt;&amp;lt; 1

具体结构如下：
t[&quot;fuck&quot;,5487] @count=3 @min=1 @max=3 @sum=6 @avg=2
t[&quot;fuck&quot;,26060] @count=2 @min=1 @max=1 @sum=2 @avg=1
t[&quot;stapio&quot;,26060] @count=1 @min=1 @max=1 @sum=1 @avg=1


// 遍历（升序）, 限制5次循环
foreach([key, value] in t+ limit 5)
    printf(&quot;%s: %d\n&quot;, key, value)

// 结果
stapio: 2571
fuck: 2571
fuck: 5487
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;
&lt;h3 id=&quot;stap-常用命令&quot;&gt;stap 常用命令&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;Usage: stap [options] FILE                    Run script in file.
   or: stap [options] -e SCRIPT               Run given script.
   or: stap [options] -l PROBE                List matching probes.
   or: stap [options] -L PROBE                List matching probes and local variables.
[options]
   -T TIME    terminate the script after TIME seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了直接执行脚本文件外，另外一个比较有用的功能 &lt;code&gt;-L&lt;/code&gt; &lt;code&gt;-l&lt;/code&gt; 现象，列出可探测点及局部变量&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;列出程序中的可探测点&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;// 截取部分~
[root@localhost stp]# stap -l 'process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;*&quot;)'
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;write@/tmp/limlog/limlog/Log.cpp:107&quot;)
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;~LimLog@/tmp/limlog/limlog/Log.cpp:213&quot;)
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;~LogLine@/tmp/limlog/limlog/Log.cpp:341&quot;)
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;~LogSink@/tmp/limlog/limlog/Log.cpp:59&quot;)
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;~_Impl@/usr/include/c++/4.8.2/thread:107&quot;)
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;~_Impl_base@/usr/include/c++/4.8.2/thread:97&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;列出程序中的可探测点及局部变量(前缀为&lt;code&gt;$&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;[root@localhost stp]# stap -L 'process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;*&quot;)'
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;id@/usr/include/c++/4.8.2/thread:73&quot;) $this:class id* const
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;incConsumable@/tmp/limlog/limlog/Log.cpp:313&quot;) $this:class LimLog* const $n:uint32_t
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;incConsumablePos@/tmp/limlog/limlog/Log.cpp:135&quot;) $this:class BlockingBuffer* const $n:uint32_t
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;incConsumablePos@/tmp/limlog/limlog/Log.cpp:460&quot;) $n:uint32_t
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;insert@/usr/include/c++/4.8.2/bits/basic_string.h:1319&quot;) $__c:char $__n:size_type $__pos:size_type $this:class basic_string&amp;lt;char, std::char_traits&amp;lt;char&amp;gt;, std::allocator&amp;lt;char&amp;gt; &amp;gt;* const
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有这个功能，我们就可以看到函数所在源文件中的位置及可以根据的局部变量。&lt;/p&gt;
&lt;h3 id=&quot;systemtap-脚本-2&quot;&gt;systemtap 脚本&lt;/h3&gt;
&lt;p&gt;探针事件的关键字是 &lt;code&gt;probe&lt;/code&gt;, 由 probe 引出需要跟踪的事件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 脚本执行后显示 === begin ===
probe begin {
    printf(&quot;=== begin ===\n&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据上述的可跟踪的事件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;begin/end, 分别是systemtap会话的起始和结尾&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;[root@localhost stp]# cat foo.stp
#!/usr/bin/env stap

probe begin {
    printf(&quot;=== begin ===\n&quot;);
}

probe end {
    printf(&quot;=== end ===\n&quot;);
}

// 执行脚本
[root@localhost stp]# stap foo.stp -T 1
=== begin ===
=== end ===
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;kernel.function(&quot;sys_xxx&quot;), 系统调用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 调用open系统调用
[root@localhost stp]# cat foo.stp
#!/usr/bin/env stap

probe kernel.function(&quot;sys_open&quot;).call {
    printf(&quot;%s call %s\n&quot;, execname(), ppfunc());
}

// open系统调用返回
probe kernel.function(&quot;sys_open&quot;).call {
    printf(&quot;%s call %s over\n&quot;, execname(), ppfunc());
}

[root@localhost stp]# stap foo.stp -T 1
sh call SyS_open
sh call SyS_open over
sh call SyS_open
sh call SyS_open over
sh call SyS_open
sh call SyS_open over
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定时器调用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;[root@localhost stp]# cat foo.stp
#!/usr/bin/env stap

// 定时调用函数
probe timer.ms(500) {
    printf(&quot;now: %d\n&quot;, gettimeofday_s());
}

[root@localhost stp]# stap foo.stp -T 3
now: 1593141081
now: 1593141081
now: 1593141082
now: 1593141082
now: 1593141083
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;定时cpu采样&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 取自春哥的sample-bt示例代码，定时调用栈取样
global bts;

probe timer.profile {
    if (pid() == 5291)
        bts[backtrace(), ubacktrace()] &amp;lt;&amp;lt;&amp;lt; 1
}

probe timer.s(10) {
    foreach([k, u] in bts-) {
        print_stack(k);
        print_ustack(u);
        printf(&quot;\\t%d\\n&quot;, @count(bts[k, u]));
    }
    exit();
}

// 结果为16进制地址，截取一部分数据，这部分数据需要进一步加工统计
[root@localhost stp]# stap foo.stp
 0xffffffff810d6244 : 0xffffffff810d6244
 0xffffffff810475fa : 0xffffffff810475fa
\t1\n 0xffffffffa0139f0d : 0xffffffffa0139f0d [xfs]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;指定程序中的函数事件（需要运行程序）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 打印程序 LogTest 所有执行的函数
[root@localhost stp]# cat foo.stp
probe process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;*&quot;) {
    printf(&quot;function: %s\n&quot;, ppfunc());
}

// 库函数也加载进来了
[root@localhost stp]# stap foo.stp
function: offsetOfPos
function: __distance&amp;lt;char*&amp;gt;
function: operator+&amp;lt;long int, std::ratio&amp;lt;1l, 1000000000l&amp;gt;, long int, std::ratio&amp;lt;1l, 1000000l&amp;gt; &amp;gt;
function: operator&amp;lt;&amp;lt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;指定程序指定文件中的可追踪事件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;//打印 LogTest 程序属于 Log.cpp 中的函数信息
[root@localhost stp]# cat foo.stp
probe process(&quot;/tmp/limlog/build/tests/LogTest&quot;).statement(&quot;*@Log.cpp&quot;) {
    printf(&quot;function: %s\n&quot;, ppfunc());
}

// 过滤了库函数，只留下Log.cpp中的函数执行
[root@localhost stp]# stap foo.stp
function: singleton
function: produce
function: produce
function: produce
function: produce
function: used
function: used
function: consumable
function: operator&amp;lt;&amp;lt;
function: ~LogLine
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上下文变量&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;// 获取上下文变量
[root@localhost stp]# stap -L 'process(&quot;/tmp/limlog/build/tests/LogTest&quot;).statement(&quot;*@Log.cpp&quot;)'
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).statement(&quot;LimLog@/tmp/limlog/limlog/Log.cpp:185&quot;) $this:class LimLog* const
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).statement(&quot;LogLine@/tmp/limlog/limlog/Log.cpp:336&quot;) $this:class LogLine* const $level:enum LogLevel $loc:struct LogLoc const&amp;amp;
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).statement(&quot;append@/tmp/limlog/limlog/Log.cpp:346&quot;) $this:class LogLine* const $data:char const* $n:size_t
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).statement(&quot;consumable@/tmp/limlog/limlog/Log.cpp:140&quot;) $this:class BlockingBuffer const* const
process(&quot;/tmp/limlog/build/tests/LogTest&quot;).statement(&quot;consume@/tmp/limlog/limlog/Log.cpp:146&quot;) $this:class BlockingBuffer* const $to:char* $n:uint32_t

// 这里我们追踪 consume 函数中的两个参数
[root@localhost stp]# cat foo.stp
probe process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;consume&quot;) {
    printf(&quot;func = %s, $var(n) = %d, $var(to) = %p\n&quot;, ppfunc(), $n, $to);
}

[root@localhost stp]# stap foo.stp
func = consume, $var(n) = 406, $var(to) = 0x7f902a94d010
func = consume, $var(n) = 203, $var(to) = 0x7f902a94d1a6
func = consume, $var(n) = 790, $var(to) = 0x7f902a94d010
func = consume, $var(n) = 3319, $var(to) = 0x7f902a94d326
func = consume, $var(n) = 4235, $var(to) = 0x7f902a94d010
func = consume, $var(n) = 4235, $var(to) = 0x7f902a94d010
func = consume, $var(n) = 2326, $var(to) = 0x7f902a94d010
func = consume, $var(n) = 8470, $var(to) = 0x7f902a94d010
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;示例分析&quot;&gt;示例分析&lt;/h3&gt;
&lt;p&gt;在探测点被执行时打印这种简单的用法外，还能进一步做一些其它的事情。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;统计某一时间段内运行次数top k的函数&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;[root@localhost stp]# cat foo.stp
#!/usr/bin/env stap

global top_funcs;

probe begin {
    printf(&quot;=== begin ===\n&quot;);
}

probe process(&quot;/tmp/limlog/build/tests/LogTest&quot;).statement(&quot;*@Log.cpp&quot;) {
    top_funcs[ppfunc()]++;
}

probe end {
    foreach(func in top_funcs- limit 10)
        printf(&quot;%s: %d\n&quot;, func, top_funcs[func]);

    printf(&quot;=== end ===\n&quot;);
}

// LogTest 在3秒内执行最多的10个函数及次数
[root@localhost stp]# stap foo.stp -T 3
=== begin ===
produce: 1152
append: 720
singleton: 646
operator&amp;lt;&amp;lt;: 608
produceLog: 576
used: 576
consumable: 359
incConsumablePos: 64
getLogLevel: 32
LogLine: 32
=== end ===
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;统计系统调用某一时间段内被调用最频繁的k个程序及次数&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;[root@localhost stp]# cat foo.stp
#!/usr/bin/env stap

global top_exec;

probe begin {
    printf(&quot;=== begin ===\n&quot;);
}

probe kernel.function(&quot;sys_write&quot;) {
    top_exec[execname()]++;
}

probe end {
    foreach(exec in top_exec- limit 10)
        printf(&quot;%s: %d\n&quot;, exec, top_exec[exec]);

    printf(&quot;=== end ===\n&quot;);
}

[root@localhost stp]# stap foo.stp -T 3
=== begin ===
qemu-kvm: 2948
sync: 2174
virsh: 673
libvirtd: 305
route: 28
grep: 21
ps: 21
ssh: 16
python: 16
nginx: 16
=== end ===
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;打印函数调用层次（用户程序）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;调用层次需要借助 &lt;code&gt;thread_indent&lt;/code&gt; 来打印合适的缩进，另外需要设置函数入口（call）和返回（return）的探测点。函数命名不足以使用function通配符来匹配，而 statement 虽然可以匹配我们想要的结果（过滤第三方函数），但是不支持 call 和return。虽然有一个比较傻但是的确可行的方式是，在脚本里面手动写入这些函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;// 先取出需要关注的函数名称
stap -L 'process(&quot;/tmp/limlog/build/tests/LogTest&quot;).statement(&quot;*@*.cpp&quot;)' |  sed 's/.*statement(\&quot;\(.*\)@.*\&quot;.*/\1/g'  | sort -u
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;脚本如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#!/usr/bin/env stap

global f;

function init() {
    f[&quot;append&quot;] = 1;
    f[&quot;benchmark&quot;] = 1;
    f[&quot;consumable&quot;] = 1;
    f[&quot;consume&quot;] = 1;
    f[&quot;date&quot;] = 1;
    f[&quot;datetime&quot;] = 1;
    f[&quot;formatTimestamp&quot;] = 1;
    f[&quot;getLogLevel&quot;] = 1;
    f[&quot;gettid&quot;] = 1;
    f[&quot;i16toa&quot;] = 1;
    f[&quot;i2a&quot;] = 1;
    f[&quot;i32toa&quot;] = 1;
    f[&quot;i64toa&quot;] = 1;
    f[&quot;incConsumable&quot;] = 1;
    f[&quot;incConsumablePos&quot;] = 1;
    f[&quot;LimLog&quot;] = 1;
    f[&quot;~LimLog&quot;] = 1;
    f[&quot;listStatistic&quot;] = 1;
    f[&quot;log_10_diff_element_len&quot;] = 1;
    f[&quot;log_10_diff_element_str&quot;] = 1;
    f[&quot;log_10_diff_element_x1&quot;] = 1;
    f[&quot;log_16_same_element_x6&quot;] = 1;
    f[&quot;log_1_same_element_x6&quot;] = 1;
    f[&quot;log_4_same_element_x6&quot;] = 1;
    f[&quot;LogLine&quot;] = 1;
    f[&quot;~LogLine&quot;] = 1;
    f[&quot;LogSink&quot;] = 1;
    f[&quot;~LogSink&quot;] = 1;
    f[&quot;main&quot;] = 1;
    f[&quot;now&quot;] = 1;
    f[&quot;operator&amp;lt;&amp;lt;&quot;] = 1;
    f[&quot;produce&quot;] = 1;
    f[&quot;produceLog&quot;] = 1;
    f[&quot;rollFile&quot;] = 1;
    f[&quot;setLogFile&quot;] = 1;
    f[&quot;setLogLevel&quot;] = 1;
    f[&quot;setRollSize&quot;] = 1;
    f[&quot;singleton&quot;] = 1;
    f[&quot;sink&quot;] = 1;
    f[&quot;sinkThreadFunc&quot;] = 1;
    f[&quot;stringifyLogLevel&quot;] = 1;
    f[&quot;test_blocking_buffer&quot;] = 1;
    f[&quot;test_itoa&quot;] = 1;
    f[&quot;test_timestamp&quot;] = 1;
    f[&quot;time&quot;] = 1;
    f[&quot;u16toa&quot;] = 1;
    f[&quot;u2a&quot;] = 1;
    f[&quot;u32toa&quot;] = 1;
    f[&quot;u64toa&quot;] = 1;
    f[&quot;used&quot;] = 1;
    f[&quot;write&quot;] = 1;
}

probe begin {
    printf(&quot;=== begin ===\n&quot;);
    init();
}

probe process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;*&quot;).call {
    fn = ppfunc()
    if (f[fn] == 1)
        printf(&quot;%s -&amp;gt; %s\n&quot;, thread_indent(4), ppfunc());
}

probe process(&quot;/tmp/limlog/build/tests/LogTest&quot;).function(&quot;*&quot;).return {
    fn = ppfunc()
    if (f[fn] == 1)
        printf(&quot;%s &amp;lt;- %s\n&quot;, thread_indent(-4), ppfunc());
}

probe end {
    printf(&quot;=== end ===\n&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数的部分调用树如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;=== begin ===
     0 LogTest(25381):    -&amp;gt; main
   101 LogTest(25381):        -&amp;gt; setLogFile
   111 LogTest(25381):            -&amp;gt; singleton
   121 LogTest(25381):                -&amp;gt; LimLog
   129 LogTest(25381):                    -&amp;gt; LogSink
   270 LogTest(25381):                        -&amp;gt; now
   282 LogTest(25381):                        &amp;lt;- now
   288 LogTest(25381):                        -&amp;gt; date
   296 LogTest(25381):                            -&amp;gt; datetime
   453 LogTest(25381):                            &amp;lt;- datetime
   472 LogTest(25381):                        &amp;lt;- date
   478 LogTest(25381):                    &amp;lt;- LogSink
   576 LogTest(25381):                &amp;lt;- LimLog
   586 LogTest(25381):            &amp;lt;- singleton
   603 LogTest(25381):            -&amp;gt; rollFile
     0 LogTest(25382):    -&amp;gt; sinkThreadFunc
   650 LogTest(25381):            &amp;lt;- rollFile
   ···
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;树状调用可以很清楚的展示出来程序的执行逻辑，甚至可以看到多线程的处理：sinkThreadFunc 和 rollFile 之间的跨度。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;开源库对systemtap的集成&lt;br/&gt;像libguestfs 和libvirt都有支持，恰好工作环境这两个库也经常有一些难以排查的问题出现&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;观察 libguestfs 的启动过程及耗时，libvirt 支持function 和mark（有5个，大致逻辑上的埋点）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#! /usr/bin/env stap

global start_time, prev;

function display_time () {
  now = gettimeofday_us ()
  delta = (prev &amp;gt; 0 ) ? now - prev : 0
  printf (&quot;%18d (+%10d): &quot;, now - start_time, delta)
  prev = now
}

probe begin {
  start_time = gettimeofday_us ()
  prev = 0
  printf (&quot;%-18s (+%10s): %s\n&quot;, &quot;# time_usec&quot;,
          &quot;delta usec&quot;, &quot;event&quot;)
}

probe process(&quot;/usr/lib*/libguestfs.so.0*&quot;).function(&quot;*&quot;)
{
  display_time()
  printf (&quot;%s\n&quot;, ppfunc())
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印的结果，如果使用 libguestfs-test-tools 执行失败，可以根据产生的函数进入源代码中进行排查，缩小排查的范围&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;[root@localhost stp]# stap libguestfs.stp
# time_usec        (+delta usec): event
           1880754 (+         0): _init
           1880765 (+        11): frame_dummy
           1880768 (+         3): register_tm_clones
           1880772 (+         4): compile_regexp_re_hostname_port
           1880804 (+        32): init_libguestfs
           1881074 (+       270): guestfs_int_init_direct_backend
           1881079 (+         5): guestfs_int_register_backend
           1881083 (+         4): guestfs_int_init_libvirt_backend
           1881085 (+         2): guestfs_int_register_backend
           1881088 (+         3): guestfs_int_init_uml_backend
           ···
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 libvirt 中 example/ 目录中就有包含一些关于 systemtap 的脚本文件。&lt;/p&gt;
&lt;h4 id=&quot;火焰图的生成&quot;&gt;火焰图的生成&lt;/h4&gt;
&lt;p&gt;在函数调用树之上更进一步，加入样本的频率得到svg格式的火焰图，用户可以点击不同的图层来查看更详细的信息。&lt;/p&gt;
&lt;p&gt;火焰图工具为brendangregg开发的开源项目&lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;FlameGraph&lt;/a&gt;，配合春哥写的systemtap工具，用一段简单的shell脚本如下，可以得到一张svg的图片&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;#!/bin/bash

# 火焰图工具的路径
FlameGraph_PATH=&quot;/FlameGraph&quot;

# 春哥的栈收集工具
OR_Stap_PATH=&quot;/home/zxh/dev/openresty-systemtap-toolkit&quot;

if [ $# != 1 ] ; then
        echo &quot;Usage: sh $0 PID&quot;
        echo &quot;  e.g.: sh $0 4396&quot;
        exit 1;
fi

${OR_Stap_PATH}/sample-bt -p $1 -t 180 -u &amp;gt; /tmp/bt-sample
${FlameGraph_PATH}/stackcollapse-stap.pl /tmp/bt-sample &amp;gt; /tmp/bt_stap.out
${FlameGraph_PATH}/flamegraph.pl /tmp/bt_stap.out &amp;gt; backtrace.svg

rm -rf /tmp/bt-sample
rm -rf /tmp/bt_stap.out
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CPU定时采样，根据采样生成的 backtrace.svg 如下，横轴为CPU占用的时间比例，纵轴为函数调用的深度：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1461087/202006/1461087-20200626220703062-40634648.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是一个日志库的benchmark，而主要耗时也在阻塞队列的消费上，符合预期。&lt;/p&gt;
&lt;h2 id=&quot;rpm-链接&quot;&gt;&lt;span id=&quot;rpm_addr&quot;&gt;rpm 链接&lt;/span&gt;&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://mirrors.ocf.berkeley.edu/centos-debuginfo/7/x86_64/kernel-debuginfo-common-x86_64-3.10.0-327.el7.x86_64.rpm&quot;&gt;https://mirrors.ocf.berkeley.edu/centos-debuginfo/7/x86_64/kernel-debuginfo-common-x86_64-3.10.0-327.el7.x86_64.rpm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mirrors.ocf.berkeley.edu/centos-debuginfo/7/x86_64/kernel-debuginfo-3.10.0-327.el7.x86_64.rpm&quot;&gt;https://mirrors.ocf.berkeley.edu/centos-debuginfo/7/x86_64/kernel-debuginfo-3.10.0-327.el7.x86_64.rpm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;ftp://ftp.pbone.net/mirror/ftp.scientificlinux.org/linux/scientific/7.0/x86_64/updates/security/kernel-devel-3.10.0-327.el7.x86_64.rpm&quot;&gt;ftp://ftp.pbone.net/mirror/ftp.scientificlinux.org/linux/scientific/7.0/x86_64/updates/security/kernel-devel-3.10.0-327.el7.x86_64.rpm&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;systemtap 原理图, &lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-cn-systemtap3/index.html?ca=drs-&quot;&gt;https://www.ibm.com/developerworks/cn/linux/l-cn-systemtap3/index.html?ca=drs-&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;systemtap 官方教程（推荐），&lt;a href=&quot;https://sourceware.org/systemtap/tutorial/1_Introduction.html&quot;&gt;https://sourceware.org/systemtap/tutorial/1_Introduction.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;systemtap 内置函数库 tapset，&lt;a href=&quot;https://sourceware.org/systemtap/tapsets/index.html&quot;&gt;https://sourceware.org/systemtap/tapsets/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;春哥的一系列stap工具，&lt;a href=&quot;https://github.com/openresty/openresty-systemtap-toolkit&quot;&gt;https://github.com/openresty/openresty-systemtap-toolkit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;火焰图工具，&lt;a href=&quot;https://github.com/brendangregg/FlameGraph&quot;&gt;https://github.com/brendangregg/FlameGraph&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 26 Jun 2020 14:10:00 +0000</pubDate>
<dc:creator>小胖西瓜</dc:creator>
<og:description>SystemTap SystemTap是一个深入检查Linux系统活动的工具，使用该工具编写一些简单的代码就可以轻松的提取应用或内核的运行数据，以诊断复杂的性能或者功能问题。有了它，开发者不再需要重编</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shuqin/p/13196585.html</dc:identifier>
</item>
<item>
<title>.NET 5.0预览版6发布：支持Windows ARM64设备 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/13196251.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/13196251.html</guid>
<description>&lt;p&gt;2020年6月25日，微软dotnet团队在博客宣布了第六个 .NET 5.0 的预览版：&lt;a title=&quot;https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-6/&quot; href=&quot;https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-6/&quot;&gt;https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-6/&lt;/a&gt;，在改进性能的同时增加了一些新的功能。&lt;a href=&quot;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-5-preview-6/&quot;&gt;ASP.NET Core&lt;/a&gt;和 &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-efcore-5-0-preview-6/&quot;&gt;EF Core&lt;/a&gt;也将于今日发布了。注意：EF Core 5.0 不支持 .NET Standard 2.0 或 .NET Framework，但是EF Core 5.0是支持.NET Core 3.1。 将所有内容组合在一起的里程碑式版本离预览版 8 中完成功能只有两步之遥，最终的 GA 版本定于 11 月发布，2019年Build大会上宣布.NET 5时，微软就明确说了，&quot;未来将只有一个.NET，您将能够使用它来定位Windows、Linux、macOS、iOS、Android、tvOS、watchOS和WebAssembly等等。 微软在&lt;a href=&quot;https://www.cnblogs.com/shanyou/p/12633259.html&quot;&gt;4 月份宣布预览版 2&lt;/a&gt;时宣布，它已经处理了其 .NET 站点上 50% 的流量。&lt;/p&gt;
&lt;p&gt; &lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202006/510-20200626202612578-697303206.png&quot;&gt;&lt;img width=&quot;599&quot; height=&quot;321&quot; title=&quot;dotnet5_platform&quot; alt=&quot;dotnet5_platform&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202006/510-20200626202613125-593183055.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自那时以来，一系列稳定的预览版本一直在逐步修复Issue，完善现有功能和添加新的功能，虽然通常是一个小范围，不断敏捷迭代，小步快跑。 今天的预览版 6 依然如此，Microsoft 将其描述为包含&quot;一小组新功能和性能改进&quot;。&lt;/p&gt;
&lt;p&gt;本次更新的主要功能是在 Windows ARM64 上支持 Windows Forms 应用程序。此前.NET 5 Preview 4，Windows ARM64 上只支持控制台和 ASP.NET Core 应用程序。 通过这项支持，开发者可以在 Surface Pro X 等 Windows ARM64 设备上构建和运行 Windows Forms 应用。微软还透露，他们仍在努力为 Windows ARM64 设备提供 WPF支持。 同时.NET 5移除了对WinRT 的内置支持，通过外部工具链进行支持，这么做的最直接的好处是简化 .NET 运行时代码库（一下就删除 6 万行代码），而且这么多代码和跨平台无关。这次版本更新的内容如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Windows 窗体改进：&lt;/strong&gt;开发人员可以强制其应用程序是单实例的，这意味着一次启动一个实例。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RyuJIT 代码质量改进：&lt;/strong&gt;其中大量涉及常规改进（结构处理等）、ARM64 硬件内部功能和 ARM64 生成的代码改进，从而大大减少了 ARM64 代码大小。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单个文件应用改进：&lt;/strong&gt;添加了在单个文件中包含本机二进制文件和任何其他内容（如图片）的新选项，.NET 5目标是为 Windows、macOS 和 Linux 启用将应用作为一个文件发布。这个里程碑进一步接近了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本机托管应用程序改进：&lt;/strong&gt;一位贡献者提供了一种新的模型，用于在本机应用程序中的 .NET 托管模型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;突破性的改变 -- 删除内置 WinRT 支持：&lt;/strong&gt; &quot;已经用 Windows 团队在 .NET 5.0 中提供的&lt;a href=&quot;https://docs.microsoft.com/windows/uwp/csharp-winrt/&quot;&gt;C#/WinRT&lt;/a&gt;工具链取代了内置 WinRT 支持。&lt;a href=&quot;https://github.com/dotnet/runtime/issues/37672&quot;&gt;WinRT 互操作中的此更改是一个&lt;/a&gt;突破性的变化，使用 WinRT 的 .NET Core 3.x 应用将需要重新编译。我们将在即将到来的预览版中提供有关此内容的更多信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;开发工具支持上需要Visual Studio 16.7 预览版才支持.NET 5, Visual Studio For Mac 也支持.NET 5, 当然Visual Studio Code 安装最新版的C#扩展插件也支持.NET 5. Visual Studio .NET远程调试器对Windows ARM64的支持将在Visual Studio 16.7版本中提供。Visual Studio Code .NET远程调试器支持将在以后推出。&lt;/p&gt;
&lt;p&gt;Richard 在博客结束时说：&quot;我们现在已经过了这个发布周期的一半。&quot;事实上，我们开始’关闭发布'。如果您密切关注我们的代码仓库，您会看到我们正开始&lt;a href=&quot;https://github.com/dotnet/runtime/issues/38286&quot;&gt;更仔细地管理问题的&lt;/a&gt;里程碑。 在发布了多个.NET 5 版本之后，我可以告诉你，这是一个伟大的时间。 是时候在一组我们构建的功能上取得胜利，并把它们打磨到您乐于使用它们。 这就是我们现在在家里远程工作所做的。 尽管 11 月首次亮相仍有望实现，但 .NET 5 不会拥有 Microsoft 最初计划的所有特性和功能。这是因为&lt;a href=&quot;https://visualstudiomagazine.com/articles/2020/05/19/net-5-preview-4.aspx&quot;&gt;COVID-19大流行引起的并发症&lt;/a&gt;。因此，完整的包将会在 2021 年 11 月与 .NET 6 一起发布。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202006/510-20200626202613503-1772107362.png&quot;&gt;&lt;img width=&quot;554&quot; height=&quot;309&quot; title=&quot;dotnet_schedule&quot; alt=&quot;dotnet_schedule&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202006/510-20200626202613870-595242793.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;您可以使用以下链接&lt;a href=&quot;https://dotnet.microsoft.com/download/dotnet/5.0&quot;&gt;下载新的 .NET 5.0 的第六个预览版&lt;/a&gt;，适用于于Windows、macOS和Linux: &lt;/p&gt;
</description>
<pubDate>Fri, 26 Jun 2020 12:26:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>2020年6月25日，微软dotnet团队在博客宣布了第六个 .NET 5.0 的预览版：https://devblogs.microsoft.com/dotnet/announcing-net-5-</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/13196251.html</dc:identifier>
</item>
<item>
<title>Spring源码系列(二)--bean组件的源码分析 - 子月生</title>
<link>http://www.cnblogs.com/ZhangZiSheng001/p/13196228.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhangZiSheng001/p/13196228.html</guid>
<description>&lt;p&gt;本文将从`DefaultListableBeanFactory.getBean(Class)`方法开始分析获取 bean 的过程，主要内容如下，由于篇幅较长，可以根据需要选择阅读： 1. beanFactory 的设计 2. 多个 beanName 的处理 3. 获取单例 bean 4. 创建单例 bean 5. bean 的实例化 6. bean 的属性装配 7. bean 的初始化（省略）&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;564.2372039725&quot;&gt;

&lt;p&gt;spring-bean 组件是 Spring IoC 的核心，我们可以使用它的 beanFactory 来获取所需的对象，对象的实例化、属性装配和初始化等都可以交给 spring 来管理。 本文将从&lt;code&gt;DefaultListableBeanFactory.getBean(Class)&lt;/code&gt;方法开始分析获取 bean 的过程，主要内容如下，由于篇幅较长，可以根据需要选择阅读：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;beanFactory 的设计&lt;/li&gt;
&lt;li&gt;多个 beanName 的处理&lt;/li&gt;
&lt;li&gt;获取单例 bean&lt;/li&gt;
&lt;li&gt;创建单例 bean&lt;/li&gt;
&lt;li&gt;bean 的实例化&lt;/li&gt;
&lt;li&gt;bean 的属性装配&lt;/li&gt;
&lt;li&gt;bean 的初始化（省略）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;spring-bean 的源码比较多，有些不影响整体分析思路的代码会被省略掉（代码中会注明），另外，想要分析所有的代码可能不大现实，所以，针对部分内容，我会点到为止，例如，本文只分析单例 bean 而不分析多例 bean。&lt;/p&gt;

&lt;p&gt;上篇博客&lt;a href=&quot;https://www.cnblogs.com/ZhangZiSheng001/p/13126053.html&quot;&gt;Spring源码系列(一)--详细介绍bean组件&lt;/a&gt;介绍了 bean 组件的一些重要理论概念，并通过例子演示如何使用 bean 组件。这里回顾下，这几个概念非常重要，是 bean 组件的理论基础：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;实例化、属性装配和初始化的概念&lt;/strong&gt;。 实例化指创建出一个新的对象；属性装配指给对象的成员属性赋值； 初始化指调用对象的初始化方法。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;什么是 bean&lt;/strong&gt;：某个类的实例或描述对象，被注册到了 Spring IoC 容器，这时通过 Spring IoC 容器获取的这个类的对象就是 bean。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;什么是 beanFactory&lt;/strong&gt;：一个工厂，用于注册 bean 和获取 bean。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;什么是 beanDefinition&lt;/strong&gt;：一个描述对象，用来描述 bean 的实例化、属性装配、初始化等信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从客户端来看，一个完整的 beanFactory 工厂包含以下基本功能:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;注册别名。对应下图的&lt;code&gt;AliasRegistry&lt;/code&gt;接口。&lt;/li&gt;
&lt;li&gt;注册单例对象。对应下图的&lt;code&gt;SingletonBeanRegistry&lt;/code&gt;接口。&lt;/li&gt;
&lt;li&gt;注册&lt;code&gt;BeanDefinition&lt;/code&gt;对象。对应下图的&lt;code&gt;BeanDefinitionRegistry&lt;/code&gt;接口。&lt;/li&gt;
&lt;li&gt;获取 bean。对应下图的&lt;code&gt;BeanFactory&lt;/code&gt;接口。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 spring-bean 组件中，&lt;code&gt;DefaultListableBeanFactory&lt;/code&gt;就是一个完整的 beanFactory 工厂，也可以说是一个 IoC 容器。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1731892/202006/1731892-20200614181541484-2054058872.png&quot; alt=&quot;BeanFactoryUML_01&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BeanFactory&lt;/code&gt;还有几个扩展接口，用的比较多的可能是&lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;和&lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;HierarchicalBeanFactory&lt;/code&gt;用于提供父子工厂的支持。例如，当前 beanFactory 找不到 bean 时，会尝试从 parent beanFactory 中获取。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ConfigurableBeanFactory&lt;/code&gt;用于提供配置 beanFactory 的支持。例如，注册&lt;code&gt;BeanPostProcessor&lt;/code&gt;、注册 &lt;code&gt;TypeConverter&lt;/code&gt;、注册&lt;code&gt;OrderComparator&lt;/code&gt;等。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ListableBeanFactory&lt;/code&gt;用于提供批量获取 bean 的支持（不包含父工厂的 bean）。例如，我们可以根据类型获取 beanName-bean 的 map。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;AutowireCapableBeanFactory&lt;/code&gt;用于提供实例化、属性装配、初始化等一系列管理 bean 生命周期的支持。 例如，该接口包含了 createBean、autowireBean、initializeBean、destroyBean 等方法。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当我们注册 bean 时，根据注册方式的不同，bean 的注册信息会被放入两个不同的地方。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class DefaultSingletonBeanRegistry {
        // beanName=singletonObject键值对
    // 除了registerSingleton的会放在这里，registerBeanDefinition生成的单例bean实例也会放在这里
        private final Map&amp;lt;String, Object&amp;gt; singletonObjects = new ConcurrentHashMap&amp;lt;&amp;gt;(256);
}
class DefaultListableBeanFactory {
        // beanName=beanDefination键值对
        private final Map&amp;lt;String, BeanDefinition&amp;gt; beanDefinitionMap = new ConcurrentHashMap&amp;lt;&amp;gt;(256);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来开始分析源码，注册 bean 比较简单，这里就不看了，我们直接看 getBean(Class) 的代码。&lt;/p&gt;

&lt;p&gt;进入到 &lt;code&gt;DefaultListableBeanFactory.getBean(Class)&lt;/code&gt;方法，并逐渐展开。在&lt;code&gt;DefaultListableBeanFactory.resolveBean(ResolvableType, Object[], boolean)&lt;/code&gt;方法中，如果当前 beanFactory 中获取不到这个 bean，将尝试从 parent beanFactory 中获取，这也说明了一点：&lt;strong&gt;父子 beanFactory 中允许存在相同 beanName 的 bean，只是获取时当前 beanFactory 的优先级更高一些&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) throws BeansException {
        // 适配入参
        // 可以看到，我们获取bean时还可以指定构造参数
                return getBean(requiredType, (Object[]) null);
        }
        public &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType, @Nullable Object... args) throws BeansException {
                Assert.notNull(requiredType, &quot;Required type must not be null&quot;);
        // 继续适配入参
        // 这里的第三个参数表示，如果指定类型对应的beanName不唯一时，true为返回null, false为抛出异常
                Object resolved = resolveBean(ResolvableType.forRawClass(requiredType), args, false);
        // 如果获取不到这个bean，抛出异常
                if (resolved == null) {
                        throw new NoSuchBeanDefinitionException(requiredType);
                }
                return (T) resolved;
        }
        private &amp;lt;T&amp;gt; T resolveBean(ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) {
        // 这里的NamedBeanHolder就是简单的对bean实例封装了一层，不用太关注
                NamedBeanHolder&amp;lt;T&amp;gt; namedBean = resolveNamedBean(requiredType, args, nonUniqueAsNull);
        // 如果获取得到bean实例，则返回
                if (namedBean != null) {
                        return namedBean.getBeanInstance();
                }
        // 如果没有，尝试从parent beanFactory中获取
        // 这部分代码省略······
                return null;
        }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;通过 beanType 来获取 bean，可能会存在一个类型关联了多个 beanName 的情况，使用例子中我们说过，可以通过指定 beanDefination 的 isPrimary = true 或者注册比较器的方式来解决。接下来我们看下具体的处理过程。&lt;/p&gt;
&lt;p&gt;进入到&lt;code&gt;DefaultListableBeanFactory.resolveNamedBean(ResolvableType, Object[], boolean)&lt;/code&gt;方法。如果指定类型匹配到了多个 beanName，会进行以下处理：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果存在通过&lt;code&gt;registerSingleton&lt;/code&gt;注册的 beanName，或者通过&lt;code&gt;registerBeanDefinition&lt;/code&gt;注册且 &lt;code&gt;autowireCandidate = true&lt;/code&gt; 的 beanName，则仅保留它们，并剔除其他的 beanName；&lt;/li&gt;
&lt;li&gt;如果还是存在多个 beanName，检查是否存在唯一一个通过&lt;code&gt;registerBeanDefinition&lt;/code&gt;且&lt;code&gt;isPrimary = true&lt;/code&gt;的（存在多个会报错），存在的话将它作为匹配到的唯一 beanName；&lt;/li&gt;
&lt;li&gt;如果还是存在多个 beanName，通过我们注册的&lt;code&gt;OrderComparator&lt;/code&gt;来确定优先值最小的作为唯一 beanName，注意，通过&lt;code&gt;registerSingleton&lt;/code&gt;注册的和通过&lt;code&gt;registerBeanDefinition&lt;/code&gt;注册的，比较的对象是不一样的；&lt;/li&gt;
&lt;li&gt;如果还是存在多个 beanName，根据 nonUniqueAsNull，为 true 是返回 null，为 false 抛出&lt;code&gt;NoUniqueBeanDefinitionException&lt;/code&gt;异常。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       private &amp;lt;T&amp;gt; NamedBeanHolder&amp;lt;T&amp;gt; resolveNamedBean(
                        ResolvableType requiredType, @Nullable Object[] args, boolean nonUniqueAsNull) throws BeansException {

                Assert.notNull(requiredType, &quot;Required type must not be null&quot;);
        // 获取指定类型的所有beanName，可能匹配到多个
                String[] candidateNames = getBeanNamesForType(requiredType);
        
                // 如果指定类型匹配到了多个beanName，进行以下操作：
        // 如果存在通过registerSingleton注册的beanName，或者通过registerBeanDefinition注册且 autowireCandidate = true的beanName，则仅保留它们，并剔除其他的beanName；
                if (candidateNames.length &amp;gt; 1) {
                        List&amp;lt;String&amp;gt; autowireCandidates = new ArrayList&amp;lt;&amp;gt;(candidateNames.length);
                        for (String beanName : candidateNames) {
                                if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) {
                                        autowireCandidates.add(beanName);
                                }
                        }
                        if (!autowireCandidates.isEmpty()) {
                                candidateNames = StringUtils.toStringArray(autowireCandidates);
                        }
                }
        
                // 如果只剩下一个beanName，那就根据beanName和beanType获取bean
                if (candidateNames.length == 1) {
                        String beanName = candidateNames[0];
                        return new NamedBeanHolder&amp;lt;&amp;gt;(beanName, (T) getBean(beanName, requiredType.toClass(), args));
                }
        
        // 如果存在多个，则还要进一步处理
                else if (candidateNames.length &amp;gt; 1) {
                        Map&amp;lt;String, Object&amp;gt; candidates = new LinkedHashMap&amp;lt;&amp;gt;(candidateNames.length);
            // 遍历候选的beanName
                        for (String beanName : candidateNames) {
                // 如果该beanName是通过registerSingleton注册的，且传入构造参数为空
                // 则获取该bean实例，并放入candidates
                                if (containsSingleton(beanName) &amp;amp;&amp;amp; args == null) {
                                        Object beanInstance = getBean(beanName);
                                        candidates.put(beanName, (beanInstance instanceof NullBean ? null : beanInstance));
                                }
                                else {
                    // 其他情况下，则获取该beanName对应的类型，并放入candidates
                    // 注意，这里的类型不一定是我们入参指定的类型，例如，如果我指定的是UserServiceFactoryBean.class，这里返回的却是UserService.class
                                        candidates.put(beanName, getType(beanName));
                                }
                        }
            // 如果里面存在唯一一个通过registerBeanDefinition注册的且isPrimary=true（存在多个会报错），则将它作为匹配到的唯一beanName
                        String candidateName = determinePrimaryCandidate(candidates, requiredType.toClass());
            // 如果还是确定不了，则通过我们注册的OrderComparator来判断candidates中value的优先数，挑选优先数最小的value对应的key作为唯一的beanName
                        if (candidateName == null) {
                                candidateName = determineHighestPriorityCandidate(candidates, requiredType.toClass());
                        }
                        if (candidateName != null) {
                                Object beanInstance = candidates.get(candidateName);
                // 如果candidates中的value本身就是一个bean实例，那么直接返回就好了
                // 如果不是，则根据beanName和beanType获取bean
                                if (beanInstance == null || beanInstance instanceof Class) {
                                        beanInstance = getBean(candidateName, requiredType.toClass(), args);
                                }
                                return new NamedBeanHolder&amp;lt;&amp;gt;(candidateName, (T) beanInstance);
                        }
            // 如果还是确定不了唯一beanName，且设置了nonUniqueAsNull=false（默认为false），则会抛错
                        if (!nonUniqueAsNull) {
                                throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());
                        }
                }
                
                return null;
        }
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;进入&lt;code&gt;AbstractBeanFactory.getBean(String, Class&amp;lt;T&amp;gt;, Object...)&lt;/code&gt;。这个方法里包括四个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;转义name。主要指的是当 name 是别名或者是 “&amp;amp;” + factory beanName 形式时进行转义；&lt;/li&gt;
&lt;li&gt;如果是单例 bean 且构造参数为空，则会从 singletonObjects 中获取已生成的 bean，或者从 earlySingletonObjects/singletonFactories 中获取已经实例化但可能还没装配或初始化的 bean。如果获取到的不是 null，直接返回对应的 bean 实例；&lt;/li&gt;
&lt;li&gt;如果当前 beanFactory 没有指定的 beanName，则会去 parent beanFactory 中获取；&lt;/li&gt;
&lt;li&gt;如果当前 bean 需要依赖其他 bean，则会先获取依赖的 bean；&lt;/li&gt;
&lt;li&gt;根据 scope 选择生成单例 bean 还是多例 bean；&lt;/li&gt;
&lt;li&gt;进行类型检查，如果获取的 bean 不匹配，会先用我们注册的类型转换器转换，如果还是不匹配就抛出&lt;code&gt;BeanNotOfRequiredTypeException&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public &amp;lt;T&amp;gt; T getBean(String name, @Nullable Class&amp;lt;T&amp;gt; requiredType, @Nullable Object... args)
                        throws BeansException {
                // 适配入参
        // 这里最后一个参数指获取的bean是否纯粹用于类型检查，如果是的话，beanFactory不会标记这个bean正在生成中，仅对单例bean有用
                return doGetBean(name, requiredType, args, false);
        }
        @SuppressWarnings(&quot;unchecked&quot;)
        protected &amp;lt;T&amp;gt; T doGetBean(final String name, @Nullable final Class&amp;lt;T&amp;gt; requiredType,
                        @Nullable final Object[] args, boolean typeCheckOnly) throws BeansException {
                // 转义我们传入的name，这里包括两个内容：
        // 1. 如果是别名，需要转换为别名对象的beanName;
        // 2. 如果是“&amp;amp;”+factoryBeanName,则需要去掉前面的“&amp;amp;”
                final String beanName = transformedBeanName(name);
                Object bean;

                // 获取单例
        // 注意，这里获取到的有可能是已经初始化，也有可能是还没初始化，甚至还没装配的bean
                Object sharedInstance = getSingleton(beanName);
                if (sharedInstance != null &amp;amp;&amp;amp; args == null) {
                        // 省略日志部分······
            
            // 获取bean，因为sharedInstance有可能是factoryBean，如果我们要的是factoryBean对应的bean，则还要getObject
                        bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);
                }

                else {
                        // 如果当前线程已经在生成beanName对应的bean，就会抛错
                        if (isPrototypeCurrentlyInCreation(beanName)) {
                                throw new BeanCurrentlyInCreationException(beanName);
                        }

                        // 如果当前beanFactory没有指定的beanName，则会去parent beanFactory中获取
            // 这部分省略······
                        
                        // 这里标记指定bean正在创建中，一般对单例bean才有意义
                        if (!typeCheckOnly) {
                                markBeanAsCreated(beanName);
                        }

                        try {
                // 获取指定beanName对应的RootBeanDefinition对象
                                final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);
                // 检查RootBeanDefinition，目前就是检查是否对应的类型为抽象类，是的话抛错
                                checkMergedBeanDefinition(mbd, beanName, args);

                                // 如果当前bean需要依赖其他bean，则会先获取依赖的bean
                                // 这部分省略······

                                // 创建单例bean
                                if (mbd.isSingleton()) {
                                        sharedInstance = getSingleton(beanName, () -&amp;gt; {
                                                try {
                            // 进入创建bean或factoryBean
                                                        return createBean(beanName, mbd, args);
                                                }
                                                catch (BeansException ex) {
                                                        destroySingleton(beanName);
                                                        throw ex;
                                                }
                                        });
                    // 获取bean实例
                                        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);
                                }
                                // 创建多例bean
                                else if (mbd.isPrototype()) {
                                        Object prototypeInstance = null;
                                        try {
                        // 标记当前线程正在创建这个bean
                                                beforePrototypeCreation(beanName);
                        // 进入创建bean或factoryBean
                                                prototypeInstance = createBean(beanName, mbd, args);
                                        }
                                        finally {
                        // 去掉当前线程中这个bean正在创建的标记
                                                afterPrototypeCreation(beanName);
                                        }
                                        bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);
                                }
                                // 接下来这种一般是自定义Scope的情况，这里省略不讨论
                                else {
                                        // ·······
                                }
                        }
                        catch (BeansException ex) {
                                cleanupAfterBeanCreationFailure(beanName);
                                throw ex;
                        }
                }

                // 如果获取到的bean实例不是我们指定的类型
                if (requiredType != null &amp;amp;&amp;amp; !requiredType.isInstance(bean)) {
                        try {
                // 使用我们注册的类型转换器进行转换
                                T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);
                // 如果转换不了，则会抛错
                                if (convertedBean == null) {
                                        throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
                                }
                                return convertedBean;
                        }
                        catch (TypeMismatchException ex) {
                                throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());
                        }
                }
                return (T) bean;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于单例 bean 和多例 bean 的创建差不多，本文只选择单例的来分析。&lt;/p&gt;

&lt;p&gt;进入&lt;code&gt;DefaultSingletonBeanRegistry.getSingleton(String, ObjectFactory)&lt;/code&gt;。这个方法包括几个过程，主要就是处理一些多线程问题：&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;获取指定 beanName 的 bean，如果已经存在，就不去创建，这时为了处理多线程同时创建 bean 的问题；&lt;/li&gt;
&lt;li&gt;如果当前 bean 已经在创建中，会抛出 BeanCurrentlyInCreationException，创建单例 bean 之前是有加锁的，按理不会出现这种情况；&lt;/li&gt;
&lt;li&gt;创建单例 bean；&lt;/li&gt;
&lt;li&gt;如果创建成功，将 bean 实例加入 singletonObjects，并且删除掉 singletonFactories 和 earlySingletonObjects 中对应的键值对。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public Object getSingleton(String beanName, ObjectFactory&amp;lt;?&amp;gt; singletonFactory) {
                Assert.notNull(beanName, &quot;Bean name must not be null&quot;);
        // 这里我不是很理解，为什么使用singletonObjects作为锁
        // 因为从earlySingletonObjects/singletonFactories中获取已经实例化但可能还没装配或初始化的 bean时，用的锁也是singletonObjects，这样的话，提前暴露的机制好像就废掉了啊？？？TODO
                synchronized (this.singletonObjects) {
                        Object singletonObject = this.singletonObjects.get(beanName);
                        if (singletonObject == null) {
                // 如果当前beanFactory的单例正在销毁，则不允许创建单例
                                if (this.singletonsCurrentlyInDestruction) {
                                        // 省略抛错······
                                }
                                
                                // 判断当前bean是不是已经在创建中，是的话抛出BeanCurrentlyInCreationException
                // 由于加了锁，这种情况应该是不会发生的
                                beforeSingletonCreation(beanName);
                                boolean newSingleton = false;
                
                // 省略部分代码······
                
                                try {
                    // 这里的执行的是createBean方法
                                        singletonObject = singletonFactory.getObject();
                                        newSingleton = true;
                                }
                // 这种情况我不是很理解，singletonObjects的操作不应该被锁住了吗？TODO
                                catch (IllegalStateException ex) {
                                        singletonObject = this.singletonObjects.get(beanName);
                                        if (singletonObject == null) {
                                                throw ex;
                                        }
                                }
                // 如果抛出的是BeanCreationException，
                                catch (BeanCreationException ex) {
                    // 省略部分代码······
                        
                                        throw ex;
                                }
                                finally {
                    // 省略部分代码······
                    
                    // 如果当前bean不处于创建状态中，会抛出IllegalStateException
                                        afterSingletonCreation(beanName);
                                }
                // 如果创建成功，将bean实例加入singletonObjects，并且删除掉singletonFactories和earlySingletonObjects中对应的键值对
                                if (newSingleton) {
                                        addSingleton(beanName, singletonObject);
                                }
                        }
                        return singletonObject;
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法中，如果获取不到已生成的单例 bean，则会开始创建 bean。&lt;/p&gt;

&lt;p&gt;进入&lt;code&gt;AbstractAutowireCapableBeanFactory.createBean(String, RootBeanDefinition, Object[])&lt;/code&gt;。这个方法包括以下过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解析 beanType，并且再次包装&lt;code&gt;RootBeanDefinition&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;执行我们注册的&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessBeforeInstantiation&lt;/code&gt;方法，如果返回了非空对象，则将其返回。也就是说我们可以在该方法中自定义完成 bean 的实例化、装配和初始化。&lt;/li&gt;
&lt;li&gt;创建 bean。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)
                        throws BeanCreationException {

                RootBeanDefinition mbdToUse = mbd;

                // 解析当前RootBeanDefinition对应生成的bean类型，并进行再次包装
                Class&amp;lt;?&amp;gt; resolvedClass = resolveBeanClass(mbd, beanName);
                if (resolvedClass != null &amp;amp;&amp;amp; !mbd.hasBeanClass() &amp;amp;&amp;amp; mbd.getBeanClassName() != null) {
                        mbdToUse = new RootBeanDefinition(mbd);
                        mbdToUse.setBeanClass(resolvedClass);
                }

                // 省略部分代码······

                try {
                        // 执行我们注册的InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法。也就是说我们可以在该方法中自定义完成 bean 的实例化、装配和初始化。
                        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);
            // 如果该方法返回bean，那就直接返回
                        if (bean != null) {
                                return bean;
                        }
                }
                catch (Throwable ex) {
                        throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName,
                                        &quot;BeanPostProcessor before instantiation of bean failed&quot;, ex);
                }

                try {
            // 创建bean
                        Object beanInstance = doCreateBean(beanName, mbdToUse, args);
                        return beanInstance;
                }
                catch (BeanCreationException | ImplicitlyAppearedSingletonException ex) {
                        throw ex;
                }
                catch (Throwable ex) {
                        throw new BeanCreationException(
                                        mbdToUse.getResourceDescription(), beanName, &quot;Unexpected exception during bean creation&quot;, ex);
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;AbstractAutowireCapableBeanFactory.doCreateBean(String, RootBeanDefinition, Object[])&lt;/code&gt;。这个方法主要包含以下过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实例化 bean；&lt;/li&gt;
&lt;li&gt;执行我们注册的&lt;code&gt;MergedBeanDefinitionPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessMergedBeanDefinition&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;如果是单例，将还没装配和初始化的 bean 先暴露出去，即放在singletonFactories中，如果其他线程进来获取，可以将这个 bean 或 factoryBean 返回，而不需要等待；&lt;/li&gt;
&lt;li&gt;属性装配；&lt;/li&gt;
&lt;li&gt;初始化；&lt;/li&gt;
&lt;li&gt;将生成的 bean 放入 disposableBeans 中。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args)
                        throws BeanCreationException {

                BeanWrapper instanceWrapper = null;
        // 实例化
        // 如果是单例，尝试从factoryBeanInstanceCache中获取
                if (mbd.isSingleton()) {
                        instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
                }
        // 实例化bean
                if (instanceWrapper == null) {
                        instanceWrapper = createBeanInstance(beanName, mbd, args);
                }
                final Object bean = instanceWrapper.getWrappedInstance();
                Class&amp;lt;?&amp;gt; beanType = instanceWrapper.getWrappedClass();
                if (beanType != NullBean.class) {
                        mbd.resolvedTargetType = beanType;
                }

                // 执行我们注册的MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法
                synchronized (mbd.postProcessingLock) {
                        if (!mbd.postProcessed) {
                                try {
                                        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
                                }
                                catch (Throwable ex) {
                                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                                        &quot;Post-processing of merged bean definition failed&quot;, ex);
                                }
                                mbd.postProcessed = true;
                        }
                }

                // 单例的可以将还没装配和初始化的bean先暴露出去，即放在singletonFactories中
                boolean earlySingletonExposure = (mbd.isSingleton() &amp;amp;&amp;amp; this.allowCircularReferences &amp;amp;&amp;amp;
                                isSingletonCurrentlyInCreation(beanName));
                if (earlySingletonExposure) {
                        if (logger.isTraceEnabled()) {
                                logger.trace(&quot;Eagerly caching bean '&quot; + beanName +
                                                &quot;' to allow for resolving potential circular references&quot;);
                        }
                        addSingletonFactory(beanName, () -&amp;gt; getEarlyBeanReference(beanName, mbd, bean));
                }
        
                Object exposedObject = bean;
                try {
            // 属性装配
                        populateBean(beanName, mbd, instanceWrapper);
            // 初始化
                        exposedObject = initializeBean(beanName, exposedObject, mbd);
                }
                catch (Throwable ex) {
                        if (ex instanceof BeanCreationException &amp;amp;&amp;amp; beanName.equals(((BeanCreationException) ex).getBeanName())) {
                                throw (BeanCreationException) ex;
                        }
                        else {
                                throw new BeanCreationException(
                                                mbd.getResourceDescription(), beanName, &quot;Initialization of bean failed&quot;, ex);
                        }
                }

                // 省略部分代码······

                // 将生成的bean或factoryBean放入disposableBeans中
                try {
                        registerDisposableBeanIfNecessary(beanName, bean, mbd);
                }
                catch (BeanDefinitionValidationException ex) {
                        throw new BeanCreationException(
                                        mbd.getResourceDescription(), beanName, &quot;Invalid destruction signature&quot;, ex);
                }

                return exposedObject;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来将展开 bean 的实例化、属性装配和初始化。其中，实例化和属性装配的代码比较复杂，我们重点分析，至于初始化部分，则留给读者自行阅读。&lt;/p&gt;

&lt;p&gt;进入&lt;code&gt;AbstractAutowireCapableBeanFactory.createBeanInstance(String, RootBeanDefinition, Object[])&lt;/code&gt;。这个方法主要过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解析 beanType，并对 beanType 进行一些必要的检查；&lt;/li&gt;
&lt;li&gt;通过我们设置的 InstanceSupplier 或 FactoryMethod 来直接获取 bean，如果有的话，直接返回该对象；&lt;/li&gt;
&lt;li&gt;如果构造参数为空，则可以复用已经解析好的构造对象（如果有的话）；&lt;/li&gt;
&lt;li&gt;执行我们注册的&lt;code&gt;SmartInstantiationAwareBeanPostProcessor&lt;/code&gt;的&lt;code&gt;determineCandidateConstructors&lt;/code&gt;获取构造对象数组；&lt;/li&gt;
&lt;li&gt;如果得到的数组不是空，或者 beanDefination 的装配模式为构造注入，或者 beanDefination 包含构造参数，或者我们传入的构造参数非空，则进入实例化 bean&lt;/li&gt;
&lt;li&gt;其他情况，使用无参构造来实例化。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) {
                // 解析bean类型
                Class&amp;lt;?&amp;gt; beanClass = resolveBeanClass(mbd, beanName);
                
        // 如果bean类型不是public的，则抛错
                if (beanClass != null &amp;amp;&amp;amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;amp;&amp;amp; !mbd.isNonPublicAccessAllowed()) {
                        throw new BeanCreationException(mbd.getResourceDescription(), beanName,
                                        &quot;Bean class isn't public, and non-public access not allowed: &quot; + beanClass.getName());
                }
                
        // 通过RootBeanDefinition中定义的Supplier来获取实例化bean
                Supplier&amp;lt;?&amp;gt; instanceSupplier = mbd.getInstanceSupplier();
                if (instanceSupplier != null) {
                        return obtainFromSupplier(instanceSupplier, beanName);
                }
                // 通过RootBeanDefinition中定义FactoryMethod来实例化bean
                if (mbd.getFactoryMethodName() != null) {
                        return instantiateUsingFactoryMethod(beanName, mbd, args);
                }

                // 如果构造参数为空，则可以复用已经解析好的构造对象（如果有的话）
                boolean resolved = false;
                boolean autowireNecessary = false;
                if (args == null) {
                        synchronized (mbd.constructorArgumentLock) {
                                if (mbd.resolvedConstructorOrFactoryMethod != null) {
                                        resolved = true;
                                        autowireNecessary = mbd.constructorArgumentsResolved;
                                }
                        }
                }
                if (resolved) {
                        if (autowireNecessary) {
                                return autowireConstructor(beanName, mbd, null, null);
                        }
                        else {
                                return instantiateBean(beanName, mbd);
                        }
                }

                // 执行我们注册的SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors获取Constructor对象数组（如果有的话）
                Constructor&amp;lt;?&amp;gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
        // 如果得到的数组不是空，或者beanDefination的装配模式为构造注入，或者beanDefination包含构造参数，或者我们传入的构造参数非空，则进入实例化bean或factoryBean
                if (ctors != null || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||
                                mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) {
                        return autowireConstructor(beanName, mbd, ctors, args);
                }
                
                // 省略部分代码······

                // 使用无参构造实例化bean或factoryBean
                return instantiateBean(beanName, mbd);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例化的方法包括有参构造实例化和无参构造实例化两种，本文只讨论有参构造实例化的情况。&lt;/p&gt;
&lt;h2 id=&quot;constructorargumentvalues和argumentsholder&quot;&gt;ConstructorArgumentValues和ArgumentsHolder&lt;/h2&gt;
&lt;p&gt;在继续分析之前，有必要了解下&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;和&lt;code&gt;ArgumentsHolder&lt;/code&gt;这两个类。&lt;/p&gt;
&lt;p&gt;首先，&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;用于定义构造方法的参数列表的值。spring 中，&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;一般被定义在 &lt;code&gt;BeanDefinition&lt;/code&gt;对象中，它影响着 bean 的实例化，是 bean 实例化时选择构造对象的依据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConstructorArgumentValues {
        // 索引+参数值
    // 例如，对应new User(int age, String name, String address)的构造方法，可以包含元素：0=new ValueHolder(18),2=new ValueHolder(&quot;北京&quot;)
        private final Map&amp;lt;Integer, ValueHolder&amp;gt; indexedArgumentValues = new LinkedHashMap&amp;lt;&amp;gt;();
        // 通用参数值
    // 例如，对应new User(int age, String name, String address)的构造方法，如果indexedArgumentValues中不包含name的值，则可以在genericArgumentValues中查找，我们只需要添加元素：new ValueHolder(&quot;zzs001&quot;, String.class)
        private final List&amp;lt;ValueHolder&amp;gt; genericArgumentValues = new ArrayList&amp;lt;&amp;gt;();
    
    // 内部类，代表一个参数的值
    public static class ValueHolder implements BeanMetadataElement {

                @Nullable
                private Object value;

                @Nullable
                private String type;

                @Nullable
                private String name;

                @Nullable
                private Object source;

                private boolean converted = false;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ArgumentsHolder&lt;/code&gt;是&lt;code&gt;ConstructorResolver&lt;/code&gt;的内部类，和&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;一样，它也是用来定义构造方法的参数列表的值，区别在于，&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;的值是“未解析的”，而&lt;code&gt;ArgumentsHolder&lt;/code&gt;包含了“未解析”（preparedArguments）、“解析未完成”（rawArguments）和&quot;解析完成&quot;（arguments）三种值。&lt;/p&gt;
&lt;p&gt;为什么会这样呢？因为&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;中的参数值的类型不一定和构造方法中的匹配，包括两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;类型不同，但可以通过&lt;code&gt;TypeConverter&lt;/code&gt;转换的类型。例如，在&lt;code&gt;new User(int age, String name, Address address)&lt;/code&gt;的构造方法中，我可以在&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;添加&lt;code&gt;2=new AddressVO()&lt;/code&gt;，这个时候只要 spring 能找到合适的转换器就能转换，这个转换过程为：&lt;strong&gt;“解析未完成”（rawArguments） --》 &quot;解析完成&quot;（arguments）&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;类型不同，参数的值指向其他 bean ，当然也可以是其他 spring 可识别的引用。例如，&lt;code&gt;new User(int age, String name, Address address)&lt;/code&gt;的构造方法中，我可以在&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;添加&lt;code&gt;2=new RootBeanDefinition(Address.class)&lt;/code&gt;，这个转换过程为：&lt;strong&gt;“未解析”（preparedArguments） --》“解析未完成”（rawArguments）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static class ArgumentsHolder {

    public final Object[] rawArguments;

    public final Object[] arguments;

    public final Object[] preparedArguments;

    public boolean resolveNecessary = false;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;理解完这两个类之后，我们继续分析实例化的源码。&lt;/p&gt;
&lt;h2 id=&quot;有参构造实例化&quot;&gt;有参构造实例化&lt;/h2&gt;
&lt;p&gt;进入到&lt;code&gt;AbstractAutowireCapableBeanFactory.autowireConstructor(String, RootBeanDefinition, Constructor&amp;lt;?&amp;gt;[], Object[])&lt;/code&gt;方法。这里创建了一个&lt;code&gt;ConstructorResolver&lt;/code&gt;对象并直接调用它的 autowireConstructor 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected BeanWrapper autowireConstructor(
                        String beanName, RootBeanDefinition mbd, @Nullable Constructor&amp;lt;?&amp;gt;[] ctors, @Nullable Object[] explicitArgs) {

                return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;ConstructorResolver.autowireConstructor(String, RootBeanDefinition, Constructor&amp;lt;?&amp;gt;[], Object[])&lt;/code&gt;。这个方法代码比较多，为了更好地理解，可以分成两种场景来看：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;入参里显式指定构造参数。这种场景的参数值默认都是解析过的，所以不需要解析，该场景要求对应的构造对象的参数数量必须和指定的一样。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BeanDefinition&lt;/code&gt;对象中指定&lt;code&gt;ConstructorArgumentValues&lt;/code&gt;。这种场景的参数值需要经过两步转换，该场景要求对应的构造对象的参数数量不小于指定的数量。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public BeanWrapper autowireConstructor(String beanName, RootBeanDefinition mbd,
                        @Nullable Constructor&amp;lt;?&amp;gt;[] chosenCtors, @Nullable Object[] explicitArgs) {

                BeanWrapperImpl bw = new BeanWrapperImpl();
                this.beanFactory.initBeanWrapper(bw);
                
        // 定义最终用于实例化对象的构造器
                Constructor&amp;lt;?&amp;gt; constructorToUse = null;
        // 定义存放（“未解析”、“解析未完成”、“解析完成”）构造参数的对象
                ArgumentsHolder argsHolderToUse = null;
        // 定义最终用于实例化对象的构造参数
                Object[] argsToUse = null;
                
        // 入参显式声明了构造参数（场景一），则不需要解析参数列表值，但需解析构造对象
                if (explicitArgs != null) {
                        argsToUse = explicitArgs;
                }
                else {
                        Object[] argsToResolve = null;
            // BeanDefinition对象中指定ConstructorArgumentValues（场景二），如果参数列表值或构造对象已经解析，则不需要再解析
                        synchronized (mbd.constructorArgumentLock) {
                                constructorToUse = (Constructor&amp;lt;?&amp;gt;) mbd.resolvedConstructorOrFactoryMethod;
                                if (constructorToUse != null &amp;amp;&amp;amp; mbd.constructorArgumentsResolved) {
                                        // Found a cached constructor...
                                        argsToUse = mbd.resolvedConstructorArguments;
                                        if (argsToUse == null) {
                                                argsToResolve = mbd.preparedConstructorArguments;
                                        }
                                }
                        }
                        if (argsToResolve != null) {
                                argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve, true);
                        }
                }
                
        // 进入解析参数列表值和构造对象
                if (constructorToUse == null || argsToUse == null) {
                        // 如果入参里没有显式指定构造对象的数组，使用反射方式获取
                        Constructor&amp;lt;?&amp;gt;[] candidates = chosenCtors;
                        if (candidates == null) {
                                Class&amp;lt;?&amp;gt; beanClass = mbd.getBeanClass();
                                try {
                    // BeanDefinition中可以定义是否包括非public的方法
                                        candidates = (mbd.isNonPublicAccessAllowed() ?
                                                        beanClass.getDeclaredConstructors() : beanClass.getConstructors());
                                }
                                catch (Throwable ex) {
                                        // 省略代码······
                                }
                        }
                        
            // 如果数组中只有一个无参构造，且入参和BeanDefinition中都未指定参数列表值，则标记该BeanDefinition对象的构造参数已解析，并实例化bean
                        if (candidates.length == 1 &amp;amp;&amp;amp; explicitArgs == null &amp;amp;&amp;amp; !mbd.hasConstructorArgumentValues()) {
                                // 省略代码······
                        }

                        // 判断是否需要解析构造
                        boolean autowiring = (chosenCtors != null ||
                                        mbd.getResolvedAutowireMode() == AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR);
            // 这里存放“解析未完成”的参数列表值
                        ConstructorArgumentValues resolvedValues = null;
                        
            // 获取要求构造参数的最小数量
                        int minNrOfArgs;
            // 入参显式声明了构造参数（场景一），minNrOfArgs即为指定数组的长度
                        if (explicitArgs != null) {
                                minNrOfArgs = explicitArgs.length;
                        }
                        else {
                // BeanDefinition对象中指定ConstructorArgumentValues（场景二），则需要计算minNrOfArgs，并进行“未解析” --&amp;gt; “解析未完成”的转换
                                ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
                                resolvedValues = new ConstructorArgumentValues();
                                minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
                        }
                        // 根据参数数量从小到大排列
                        AutowireUtils.sortConstructors(candidates);
                        int minTypeDiffWeight = Integer.MAX_VALUE;
                        Set&amp;lt;Constructor&amp;lt;?&amp;gt;&amp;gt; ambiguousConstructors = null;
                        LinkedList&amp;lt;UnsatisfiedDependencyException&amp;gt; causes = null;
                        
            // 遍历候选的构造对象
                        for (Constructor&amp;lt;?&amp;gt; candidate : candidates) {
                                // 获取当前构造对象的参数数量
                                int parameterCount = candidate.getParameterCount();
                                //  如果上一个循环已经找到匹配的构造对象，则跳出循环1
                                if (constructorToUse != null &amp;amp;&amp;amp; argsToUse != null &amp;amp;&amp;amp; argsToUse.length &amp;gt; parameterCount) {
                                        break;
                                }
                
                // 如果当前构造对象的参数数量小于minNrOfArgs，则遍历下一个
                // 注意，入参里显式指定构造参数（场景一）要求对应的构造对象的参数数量必须和指定的一样。BeanDefinition对象中指定ConstructorArgumentValues（场景二）要求对应的构造对象的参数数量不小于指定的数量
                                if (parameterCount &amp;lt; minNrOfArgs) {
                                        continue;
                                }

                                ArgumentsHolder argsHolder;
                // 获取当前构造对象的参数类型数组
                                Class&amp;lt;?&amp;gt;[] paramTypes = candidate.getParameterTypes();
                // BeanDefinition对象中指定ConstructorArgumentValues（场景二）的情况
                                if (resolvedValues != null) {
                    // 进行“解析未完成”-&amp;gt;“解析完成”的转换
                                        try {
                        // 这里是为了处理JDK6的ConstructorProperties注解，其他情况都会返回null。
                                                String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, parameterCount);
                                                if (paramNames == null) {
                                                        ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
                                                        if (pnd != null) {
                                // 获取当前构造对象的参数名数组
                                                                paramNames = pnd.getParameterNames(candidate);
                                                        }
                                                }
                        // 创建ArgumentsHolder对象
                                                argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
                                                                getUserDeclaredConstructor(candidate), autowiring, candidates.length == 1);
                                        }
                                        catch (UnsatisfiedDependencyException ex) {
                                                // 省略代码······
                                                continue;
                                        }
                                }
                // 入参里显式指定构造参数（场景一）的情况
                                else {
                    // 如果当前构造参数的数量小于指定参数的数量，则继续循环
                                        if (parameterCount != explicitArgs.length) {
                                                continue;
                                        }
                    // 创建ArgumentsHolder对象，因为不需要解析参数，所以，这种情况raw、prepared、resolved都是一样的
                                        argsHolder = new ArgumentsHolder(explicitArgs);
                                }
                                // 计算指定参数和当前构造的参数类型的差异值
                                int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
                                                argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
                                // 差异值小于阈值
                                if (typeDiffWeight &amp;lt; minTypeDiffWeight) {
                                        // 得到匹配的构造对象和构造参数
                                        constructorToUse = candidate;
                                        argsHolderToUse = argsHolder;
                                        argsToUse = argsHolder.arguments;
                                        minTypeDiffWeight = typeDiffWeight;
                                        ambiguousConstructors = null;
                                }
                // 差异值大于阈值，这种不考虑
                                else if (constructorToUse != null &amp;amp;&amp;amp; typeDiffWeight == minTypeDiffWeight) {
                                        // 省略代码······
                                }
                        }
                        // 如果找不到合适的构造对象，则会抛错
                        if (constructorToUse == null) {
                                // 省略代码······
                        }
                        else if (ambiguousConstructors != null &amp;amp;&amp;amp; !mbd.isLenientConstructorResolution()) {
                                // 省略代码······
                        }
                        // BeanDefinition对象中指定ConstructorArgumentValues（场景二），为了复用解析好的构造和参数列表，需要标记当前BeanDefinition的构造参数已解析
                        if (explicitArgs == null &amp;amp;&amp;amp; argsHolderToUse != null) {
                                argsHolderToUse.storeCache(mbd, constructorToUse);
                        }
                }

                Assert.state(argsToUse != null, &quot;Unresolved constructor arguments&quot;);
        // 接下来就是使用构造对象和参数来实例化对象，就不往下看了。
                bw.setBeanInstance(instantiate(beanName, mbd, constructorToUse, argsToUse));
                return bw;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例化部分比较难，主要还得先理解一些抽象概念，例如：两个场景、参数的转换等。&lt;/p&gt;

&lt;p&gt;进入&lt;code&gt;AbstractAutowireCapableBeanFactory.populateBean(String, RootBeanDefinition, BeanWrapper)&lt;/code&gt;。这个方法包括以下过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;执行我们注册的&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessAfterInstantiation&lt;/code&gt;方法，如果返回了 false，则不进行属性装配，直接返回；&lt;/li&gt;
&lt;li&gt;获取 beanDefinition 中的&lt;code&gt;PropertyValues&lt;/code&gt;对象，根据 beanDefinition 设置的注入类型，填充&lt;code&gt;PropertyValues&lt;/code&gt;对象；&lt;/li&gt;
&lt;li&gt;执行我们注册的&lt;code&gt;InstantiationAwareBeanPostProcessor&lt;/code&gt;的&lt;code&gt;postProcessProperties&lt;/code&gt;方法，可以对&lt;code&gt;PropertyValues&lt;/code&gt;对象进行修改;&lt;/li&gt;
&lt;li&gt;依赖检查（如果设置了）；&lt;/li&gt;
&lt;li&gt;进行属性装配。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected void populateBean(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw) {
        // 如果实例对象为空，则抛出异常或直接返回
                if (bw == null) {
                        if (mbd.hasPropertyValues()) {
                                throw new BeanCreationException(
                                                mbd.getResourceDescription(), beanName, &quot;Cannot apply property values to null instance&quot;);
                        }
                        else {
                                return;
                        }
                }

                // 执行我们注册的InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation方法，如果返回了false，则不进行属性装配，直接返回
                if (!mbd.isSynthetic() &amp;amp;&amp;amp; hasInstantiationAwareBeanPostProcessors()) {
                        for (BeanPostProcessor bp : getBeanPostProcessors()) {
                                if (bp instanceof InstantiationAwareBeanPostProcessor) {
                                        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                                        if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
                                                return;
                                        }
                                }
                        }
                }
                
        // 获取BeanDefinition对象中的PropertyValues，包含了name=value的PropertyValue对象的列表
                PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : null);
                
        // 根据我们设置的注入方式，填充
                int resolvedAutowireMode = mbd.getResolvedAutowireMode();
                if (resolvedAutowireMode == AUTOWIRE_BY_NAME || resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
                        MutablePropertyValues newPvs = new MutablePropertyValues(pvs);
                        // 按名字装配
                        if (resolvedAutowireMode == AUTOWIRE_BY_NAME) {
                                autowireByName(beanName, mbd, bw, newPvs);
                        }
                        // 按类型装配
                        if (resolvedAutowireMode == AUTOWIRE_BY_TYPE) {
                                autowireByType(beanName, mbd, bw, newPvs);
                        }
                        pvs = newPvs;
                }
                // beanFactory中是否注册了InstantiationAwareBeanPostProcessors
                boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
        // BeanDefinition对象中是否设置了依赖检查
                boolean needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);

                PropertyDescriptor[] filteredPds = null;
                if (hasInstAwareBpps) {
                        if (pvs == null) {
                // 如果为空，再次从BeanDefinition对象中获取，TODO？
                                pvs = mbd.getPropertyValues();
                        }
                        for (BeanPostProcessor bp : getBeanPostProcessors()) {
                                if (bp instanceof InstantiationAwareBeanPostProcessor) {
                                        InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
                    // 执行我们注册的InstantiationAwareBeanPostProcessor的postProcessProperties方法，可以对PropertyValues对象进行修改
                                        PropertyValues pvsToUse = ibp.postProcessProperties(pvs, bw.getWrappedInstance(), beanName);
                                        // 省略部分代码······
                                        pvs = pvsToUse;
                                }
                        }
                }
        // 如果BeanDefinition对象中设置了依赖检查，则需要检查依赖设置
                if (needsDepCheck) {
                        if (filteredPds == null) {
                                filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
                        }
                        checkDependencies(beanName, mbd, filteredPds, pvs);
                }

                if (pvs != null) {
            // 执行属性装配
                        applyPropertyValues(beanName, mbd, bw, pvs);
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法中主要涉及&lt;code&gt;autowireByName&lt;/code&gt;、&lt;code&gt;autowireByType&lt;/code&gt;和&lt;code&gt;applyPropertyValues&lt;/code&gt;三个方法，前两个暂时不展开，只讲最后一个方法。&lt;/p&gt;
&lt;h2 id=&quot;几个重要的知识点&quot;&gt;几个重要的知识点&lt;/h2&gt;
&lt;p&gt;在分析&lt;code&gt;applyPropertyValues&lt;/code&gt;方法之前，我们需要知道一下几个知识点。这里以&lt;code&gt;User&lt;/code&gt;这个类来展开例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class User {
    
    private String name;
    
    private int age;
    
    private Address address;
    
    private List&amp;lt;String&amp;gt; hobbies;
}
class Address {
    private String region;
    private String desc;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;propertyname的几种形式&quot;&gt;propertyName的几种形式&lt;/h3&gt;
&lt;p&gt;当我们给 beanDefinition设置属性值时，一般都会这样采用这样的赋值，这里成为“普通形式”。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;rootBeanDefinition.getPropertyValues().add(&quot;name&quot;, &quot;zzs001&quot;);
rootBeanDefinition.getPropertyValues().add(&quot;age&quot;, 18);
rootBeanDefinition.getPropertyValues().add(&quot;address&quot;, new Address(&quot;&quot;, &quot;&quot;));
rootBeanDefinition.getPropertyValues().add(&quot;hobbies&quot;, new ArrayList());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对类型为 object、list、array、map 等成员属性，spring 还支持其他的赋值方式，如下，分别成为“嵌套对象形式”和“索引形式”：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 嵌套对象形式
rootBeanDefinition.getPropertyValues().add(&quot;address.region&quot;, &quot;&quot;);
rootBeanDefinition.getPropertyValues().add(&quot;address.desc&quot;, &quot;&quot;);
// 索引形式
rootBeanDefinition.getPropertyValues().add(&quot;hobbies[0]&quot;, &quot;&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正是由于 propertyName 引入了多种的形式，所以，原本简单的赋值行为被搞得非常复杂。例如，嵌套对象形式还可以是这样：&lt;code&gt;foo.user.address.region&lt;/code&gt;，几乎可以一直嵌套下去。&lt;/p&gt;
&lt;h3 id=&quot;propertyaccessor&quot;&gt;PropertyAccessor&lt;/h3&gt;
&lt;p&gt;propertyAccessor 对象一般绑定了一个实例对象，通过&lt;code&gt;PropertyAccessor&lt;/code&gt;接口的方法可以对对象的属性进行存取操作。属性装配中最终对成员属性赋值就是调用它的&lt;code&gt;setPropertyValue&lt;/code&gt;方法。&lt;code&gt;AbstractNestablePropertyAccessor&lt;/code&gt;中维护了一个 map，key 为当前绑定对象的属性名（不包含嵌套和索引），value 就是对于的&lt;code&gt;PropertyAccessor&lt;/code&gt;对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractNestablePropertyAccessor extends AbstractPropertyAccessor {
    private Map&amp;lt;String, AbstractNestablePropertyAccessor&amp;gt; nestedPropertyAccessors;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的例子中，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;rootBeanDefinition.getPropertyValues().add(&quot;name&quot;, &quot;zzs001&quot;);
rootBeanDefinition.getPropertyValues().add(&quot;age&quot;, 18);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种形式共用一个绑定了&lt;code&gt;User&lt;/code&gt;类型实例的&lt;code&gt;PropertyAccessor&lt;/code&gt;对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 嵌套对象形式
rootBeanDefinition.getPropertyValues().add(&quot;address.region&quot;, &quot;&quot;);
rootBeanDefinition.getPropertyValues().add(&quot;address.desc&quot;, &quot;&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种形式共用一个绑定了&lt;code&gt;Address&lt;/code&gt;类型实例的&lt;code&gt;PropertyAccessor&lt;/code&gt;对象，该对象和&quot;address&quot;这个名字关联起来维护在 nestedPropertyAccessors 中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 索引形式
rootBeanDefinition.getPropertyValues().add(&quot;hobbies[0]&quot;, &quot;&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种形式也是一个绑定了&lt;code&gt;User&lt;/code&gt;类型实例的&lt;code&gt;PropertyAccessor&lt;/code&gt;对象，该对象和&quot;hobbies&quot;这个名字关联起来维护在 nestedPropertyAccessors 中。&lt;/p&gt;
&lt;h3 id=&quot;propertytokenholder&quot;&gt;PropertyTokenHolder&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;PropertyTokenHolder&lt;/code&gt;是&lt;code&gt;AbstractNestablePropertyAccessor&lt;/code&gt;的内部类，它更多的是针对“索引形式”的 propertyName。例如，&quot;hobbies[0]&quot;对于的&lt;code&gt;PropertyTokenHolder&lt;/code&gt;中，actualName = hobbies，canonicalName = [0]，keys = {0}。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected static class PropertyTokenHolder {

                public PropertyTokenHolder(String name) {
                        this.actualName = name;
                        this.canonicalName = name;
                }

                public String actualName;

                public String canonicalName;

                @Nullable
                public String[] keys;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来继续分析属性装配的代码。&lt;/p&gt;
&lt;h2 id=&quot;applypropertyvalues&quot;&gt;applyPropertyValues&lt;/h2&gt;
&lt;p&gt;进入&lt;code&gt;AbstractAutowireCapableBeanFactory.applyPropertyValues(String, BeanDefinition, BeanWrapper, PropertyValues)&lt;/code&gt;方法。和构造参数一样，设置成员属性的参数也需要经过“两次转换”，这里就不详细讲解。这个方法主要包括以下过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取属性对象列表，如果这个列表的属性对象都已经完成“两次转换”，则直接装配属性；&lt;/li&gt;
&lt;li&gt;遍历属性对象列表，分别进行两次转换，如果列表中没有类似&lt;code&gt;BeanDefinition&lt;/code&gt;、&lt;code&gt;BeanDefinitionHolder&lt;/code&gt;等的对象，则设置&lt;code&gt;PropertyValues&lt;/code&gt;对象已经转换完成，下次调用这个方法不用再进行转换；&lt;/li&gt;
&lt;li&gt;属性装配。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {
        // 如果没有需要注入的属性，直接返回
                if (pvs.isEmpty()) {
                        return;
                }

                // 省略部分代码······

                MutablePropertyValues mpvs = null;
        
        // 获取属性对象列表
                List&amp;lt;PropertyValue&amp;gt; original;
                if (pvs instanceof MutablePropertyValues) {
                        mpvs = (MutablePropertyValues) pvs;
            // 如果所有属性对象已经完成“两次转换”，则直接装配属性
                        if (mpvs.isConverted()) {
                                try {
                                        bw.setPropertyValues(mpvs);
                                        return;
                                }
                                catch (BeansException ex) {
                                        throw new BeanCreationException(
                                                        mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
                                }
                        }
                        original = mpvs.getPropertyValueList();
                }
                else {
                        original = Arrays.asList(pvs.getPropertyValues());
                }
                
        // 获取我们注册的类型转换器
                TypeConverter converter = getCustomTypeConverter();
                if (converter == null) {
                        converter = bw;
                }
        // 创建第一次转换所用的解析器
                BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);
                
        // 定义一个列表，用于存放完成“两次转换”的属性对象
                // 这注意，这里并没有进行所谓的复制，不要被命名迷惑了
                List&amp;lt;PropertyValue&amp;gt; deepCopy = new ArrayList&amp;lt;&amp;gt;(original.size());
                boolean resolveNecessary = false;
        // 遍历属性对象
                for (PropertyValue pv : original) {
            // 当前属性对象已经完成“两次转换”，直接添加到列表
                        if (pv.isConverted()) {
                                deepCopy.add(pv);
                        }
                        else {
                                String propertyName = pv.getName();
                                Object originalValue = pv.getValue();
                                // 省略部分代码······
                // 第一次转换
                                Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
                                Object convertedValue = resolvedValue;
                // 如果当前属性为可写属性，且属性名不是类似于foo.bar或addresses[0]的形式，则需要进行第二次转换
                                boolean convertible = bw.isWritableProperty(propertyName) &amp;amp;&amp;amp;
                                                !PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
                                if (convertible) {
                                        convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
                                }
                                // 如果转换后的属性对象和初始对象一样，一般指的是普通对象，而不是BeanDefinition、BeanDefinitionHolder等
                                if (resolvedValue == originalValue) {
                    // 如果需要第二次转换，则设置复用的目标对象
                                        if (convertible) {
                                                pv.setConvertedValue(convertedValue);
                                        }
                    // 将原属性对象添加到列表
                                        deepCopy.add(pv);
                                }
                // 这种情况不考虑
                                else if (convertible &amp;amp;&amp;amp; originalValue instanceof TypedStringValue &amp;amp;&amp;amp;
                                                !((TypedStringValue) originalValue).isDynamic() &amp;amp;&amp;amp;
                                                !(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
                                        pv.setConvertedValue(convertedValue);
                                        deepCopy.add(pv);
                                }
                // 其他情况
                                else {
                    // 标记每次都需要解析
                                        resolveNecessary = true;
                    // 将原属性对象添加到列表
                                        deepCopy.add(new PropertyValue(pv, convertedValue));
                                }
                        }
                }
        // 如果不包含BeanDefinition、BeanDefinitionHolder等对象，则设置PropertyValues为已转换，这样下次调用这个方法，就不需要进行任何的转换了
                if (mpvs != null &amp;amp;&amp;amp; !resolveNecessary) {
                        mpvs.setConverted();
                }

                // 属性装配
                try {
                        bw.setPropertyValues(new MutablePropertyValues(deepCopy));
                }
                catch (BeansException ex) {
                        throw new BeanCreationException(
                                        mbd.getResourceDescription(), beanName, &quot;Error setting property values&quot;, ex);
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;AbstractPropertyAccessor.setPropertyValues(PropertyValues)&lt;/code&gt;方法。这里遍历属性对象列表，逐个进赋值操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public void setPropertyValues(PropertyValues pvs) throws BeansException {
        // 入参适配
        // 后面两个参数分别代表：是否忽略NotWritablePropertyException异常、是否忽略NullValueInNestedPathException异常
                setPropertyValues(pvs, false, false);
        }
        public void setPropertyValues(PropertyValues pvs, boolean ignoreUnknown, boolean ignoreInvalid)
                        throws BeansException {

        // 获取属性对象列表
                List&amp;lt;PropertyValue&amp;gt; propertyValues = (pvs instanceof MutablePropertyValues ?
                                ((MutablePropertyValues) pvs).getPropertyValueList() : Arrays.asList(pvs.getPropertyValues()));
                for (PropertyValue pv : propertyValues) {
                // 省略try-catch的代码和其他异常相关的代码······
                                setPropertyValue(pv);
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;setpropertyvalue&quot;&gt;setPropertyValue&lt;/h2&gt;
&lt;p&gt;进入&lt;code&gt;AbstractNestablePropertyAccessor.setPropertyValue(PropertyValue)&lt;/code&gt;。这个方法包括以下过程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取 propertyName 对应的&lt;code&gt;PropertyAccessor&lt;/code&gt;对象，这里将解析“嵌套对象形式”的 propertyName；&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;PropertyTokenHolder&lt;/code&gt;对象，这里将解析“索引形式”的 propertyName；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;PropertyAccessor&lt;/code&gt;对象进行赋值操作。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       public void setPropertyValue(PropertyValue pv) throws BeansException {
        // 适配入参
                setPropertyValue(pv.getName(), pv.getValue());
        }       
        public void setPropertyValue(String propertyName, @Nullable Object value) throws BeansException {
                AbstractNestablePropertyAccessor nestedPa;
                try {
            // 获取propertyName对应的PropertyAccessor对象，这里将解析“嵌套对象形式”的propertyName
            // 如果缓存里有的话，将复用
                        nestedPa = getPropertyAccessorForPropertyPath(propertyName);
                }
                catch (NotReadablePropertyException ex) {
                        throw new NotWritablePropertyException(getRootClass(), this.nestedPath + propertyName,
                                        &quot;Nested property in path '&quot; + propertyName + &quot;' does not exist&quot;, ex);
                }
        // 创建PropertyTokenHolder对象，这里将解析“索引形式”的propertyName
                PropertyTokenHolder tokens = getPropertyNameTokens(getFinalPath(nestedPa, propertyName));
        // 使用PropertyAccessor对象进行赋值操作
                nestedPa.setPropertyValue(tokens, new PropertyValue(propertyName, value));
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入&lt;code&gt;AbstractNestablePropertyAccessor.setPropertyValue(PropertyTokenHolder, PropertyValue)&lt;/code&gt;方法。这里根据 propertyName 是否为“索引形式”调用不同的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       protected void setPropertyValue(PropertyTokenHolder tokens, PropertyValue pv) throws BeansException {
                if (tokens.keys != null) {
                        processKeyedProperty(tokens, pv);
                }
                else {
                        processLocalProperty(tokens, pv);
                }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们不看 propertyName 为“索引形式”的方法，只看&lt;code&gt;processLocalProperty&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       private void processLocalProperty(PropertyTokenHolder tokens, PropertyValue pv) {
        // 获取actualName对应的PropertyHandler对象，如果有缓存则复用
                PropertyHandler ph = getLocalPropertyHandler(tokens.actualName);
                if (ph == null || !ph.isWritable()) {
                        // 省略部分代码······
                }

                Object oldValue = null;
                try {
                        Object originalValue = pv.getValue();
                        Object valueToApply = originalValue;
                        if (!Boolean.FALSE.equals(pv.conversionNecessary)) {
                // 因为我们的属性参数都是转换过的，所以这里不再看转换的代码
                                if (pv.isConverted()) {
                                        valueToApply = pv.getConvertedValue();
                                }
                                else {
                                        // 省略部分代码······
                                }
                                pv.getOriginalPropertyValue().conversionNecessary = (valueToApply != originalValue);
                        }
            // 接下来就是通过反射方式给属性赋值，后续再展开
                        ph.setValue(valueToApply);
                }
                catch (Exception ex) {
                        // 省略部分代码······
        }
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性装配的代码分析就点到为止吧。&lt;/p&gt;

&lt;p&gt;以上基本看完 spring-bean 的源码。针对 getBean 的过程，本文未展开的内容包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取和创建多例 bean；&lt;/li&gt;
&lt;li&gt;无参构造实例化；&lt;/li&gt;
&lt;li&gt;属性装配中，属性值列表的填充（autowireByName和autowireByType）、属性名为索引形式的属性装配&lt;/li&gt;
&lt;li&gt;bean 的初始化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;感兴趣的读者可以自行分析。另外，以上内容如有错误，欢迎指正。&lt;/p&gt;
&lt;p&gt;最后，感谢阅读。&lt;/p&gt;
&lt;blockquote readability=&quot;3.3783783783784&quot;&gt;
&lt;p&gt;相关源码请移步： &lt;a href=&quot;https://github.com/ZhangZiSheng001/spring-projects/tree/master/spring-beans&quot;&gt;spring-beans&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;3.1304347826087&quot;&gt;
&lt;p&gt;本文为原创文章，转载请附上原文出处链接：&lt;a href=&quot;https://www.cnblogs.com/ZhangZiSheng001/p/13196228.html&quot;&gt;https://www.cnblogs.com/ZhangZiSheng001/p/13196228.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 26 Jun 2020 12:18:00 +0000</pubDate>
<dc:creator>子月生</dc:creator>
<og:description>本文将从`DefaultListableBeanFactory.getBean(Class)`方法开始分析获取 bean 的过程，主要内容如下，由于篇幅较长，可以根据需要选择阅读：  1. beanF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ZhangZiSheng001/p/13196228.html</dc:identifier>
</item>
</channel>
</rss>