<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>讲真，这两款idea插件，能治愈你英语不好的病 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12710278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12710278.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;76.808027923211&quot;&gt;
&lt;p&gt;时不时就有小伙伴问我，“二哥，能推荐一款 IDE 吗？”你看这话问的，现在搞 Java 的不都在用 Intellij IDEA 吗，还用得着推荐（我已经和 Eclipse 分手了）。然后小伙伴又说，“二哥，IDEA 支持中文吗？我英语不太好。”你看这话问的，搞编程的，英语不好是硬伤啊！&lt;/p&gt;
&lt;p&gt;不过，随着 IDEA 最新版（版本号是 2020.1）的发布，英语不好的病可以彻底治愈了。为什么这么说呢？因为 IDEA 支持汉化了！一款插件就能搞定。&lt;/p&gt;
&lt;p&gt;第一步，直接在官网下载最新版。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;安装的时候请选择保留原来的版本，因为新版有点小坑：提示 Lombok 有点小问题。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;虽然直接 Enable 就可以解决， 但版本升级的时候还是要小心，免得遇到大坑，影响队友就糟心了。&lt;/p&gt;
&lt;p&gt;新版本安装成功后，可以直接在插件市场输入关键字“chinese” ，然后福音就来了，看到下图没，有一个中文汉化包的插件。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;install 它，然后重启 IDEA。看到没？是不是有一种从国外旅游回到国内见到老乡的那种热泪盈眶的感觉（打个比方而已）？&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;大部分英文单词汉化得挺优雅的，看上去一目了然。当然了，由于是第一版汉化，难免会有一些瑕疵——有些英文单词还没有来得及翻译成中文。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;大概是做语言包的工程师还没想好中文应该翻译成什么比较合适吧，毕竟汉化还是需要一些语境的，不能硬生生地直译啊——否则就像一个人的名字叫王二一样苍白（冷不丁就来自黑啊）。&lt;/p&gt;
&lt;p&gt;但不管怎么说，Intellij 的整个团队是真的用心了，Eclipse 我用了 10 年，都没碰上这等好福利。虽然说我的英语功底还可以，但有个别单词总不免看上去有些陌生，有时候不得不偷偷地打开金山词霸或者谷歌翻译，嘘。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-06.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;当然了，如果你已经习惯了英文版，反而对中文版有些不适应，想回到汉化之前的版本，也很简单，直接把 Chinese language Pack EAP 这款插件关闭就行了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-07.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;现在来介绍第二款插件，对英语不好的小伙伴简直就是“天上掉个林妹妹”，福利到你不能行。在插件市场搜索“translation” 关键字，见下图。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-08.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;看这款插件的介绍就觉得很牛逼，支持多种翻译引擎，谷歌、百度和有道，很全面了；还支持文档注释的翻译，这对喜欢看源码的小伙伴绝对是神器。&lt;/p&gt;
&lt;p&gt;还等什么，安装啊，立马安装它。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-09.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;安装完成后，有些小伙伴可能就要问了，怎么使用呢？不要着急，马上就来。&lt;/p&gt;
&lt;p&gt;第一种，点击右上角那个翻译的图标（有个 G 有个文那个，鼠标放在上面一会，有快捷键哦），然后输入你想要翻译的单词或者文字就可以翻译了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-10.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;第二种，在编辑中选中文本（支持中英互译），然后右键选择「Translate」 菜单（也可以使用快捷键）。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-11.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;第三种，新建类的时候，输入中文，然后使用快捷键调出「translate and replace」，可以将中文翻译成英文。（再也不用担心老大批评了，优雅的命名我也会啦）&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-12.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;怎么调出快捷键呢，可以在「keymap」中查看默认的，也可以自定义。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-13.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;第四种，在源码文档中（光标在文档注释中）右键选择「Translate Documentation」，见下图：&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-14.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;你会发现一个新的世界，里面再也没有陌生的面孔，从此类是干嘛的，方法是干嘛的，清清楚楚，明明白白，英语不好看起注释来头大的问题迎刃而解啊。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/04/idea-yingyu-chajian-15.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;好了，我亲爱的读者朋友，以上就是本文的全部内容了，是不是感觉英语不好的病彻底地治愈了。我是沉默王二，一枚有趣的程序员，如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读。 &lt;strong&gt;原创不易，莫要白票，请你为本文点赞个吧&lt;/strong&gt;，这将是我写作更多优质文章的最强动力。&lt;/p&gt;
&lt;blockquote readability=&quot;4.0384615384615&quot;&gt;
&lt;p&gt;本文已同步到 GitHub，欢迎 star，&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;传送门~&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 16 Apr 2020 00:33:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>时不时就有小伙伴问我，“二哥，能推荐一款 IDE 吗？”你看这话问的，现在搞 Java 的不都在用 Intellij IDEA 吗，还用得着推荐（我已经和 Eclipse 分手了）。然后小伙伴又说，“</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12710278.html</dc:identifier>
</item>
<item>
<title>Apache Hudi 设计与架构最强解读 - leesf</title>
<link>http://www.cnblogs.com/leesf456/p/12710118.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leesf456/p/12710118.html</guid>
<description>&lt;p&gt;感谢 Apache Hudi contributor：王祥虎 翻译&amp;amp;供稿。&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号：ApacheHudi&lt;/p&gt;
&lt;p&gt;本文将介绍Apache Hudi的基本概念、设计以及总体基础架构。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;1.简介&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Apache Hudi(简称：Hudi)使得您能在hadoop兼容的存储之上存储大量数据，同时它还提供两种原语，使得除了经典的批处理之外，还可以在数据湖上进行流处理。这两种原语分别是：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;Update/Delete&lt;/strong&gt;&lt;strong&gt;记录&lt;/strong&gt;：Hudi使用细粒度的文件/记录级别索引来支持Update/Delete记录，同时还提供写操作的事务保证。查询会处理最后一个提交的快照，并基于此输出结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;变更流&lt;/strong&gt;：Hudi对获取数据变更提供了一流的支持：可以从给定的时间点获取给定表中已updated/inserted/deleted的所有记录的增量流，并解锁新的查询姿势（类别）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3EcuPIickyyFjra2JpRniaIvFNWgxF4PbeI3aWSHlgCTKice3qucoiczjmiaM2ZWzkPGTnlOt1WFaNw6Bb4PFTtJ1TQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.39416058394160586&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1233&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些原语紧密结合，解锁了基于DFS抽象的流/增量处理能力。如果您熟悉流处理，那么这和从kafka主题消费事件，然后使用状态存储逐步累加中间结果类似。这在架构上会有以下几点优势：1）  效率的提升：摄取数据通常需要处理更新、删除以及强制唯一键约束。然而，由于缺乏像Hudi这样能对这些功能提供标准支持的系统，数据工程师们通常会采用大批量的作业来重新处理一整天的事件，或者每次运行都重新加载整个上游数据库，从而导致大量的计算资源浪费。由于Hudi支持记录级更新，它通过只处理有变更的记录并且只重写表中已更新/删除的部分，而不是重写整个表分区甚至整个表，为这些操作带来一个数量级的性能提升。2）  更快的ETL/派生Pipelines：从外部系统摄入数据后，下一步需要使用Apache Spark/Apache Hive或者任何其他数据处理框架来ETL这些数据用于诸如数据仓库、机器学习或者仅仅是数据分析等一些应用场景。通常，这些处理再次依赖以代码或SQL表示的批处理作业，这些作业将批量处理所有输入数据并重新计算所有输出结果。通过使用增量查询而不是快照查询来查询一个或多个输入表，可以大大加速此类数据管道，从而再次像上面一样仅处理来自上游表的增量更改，然后upsert或者delete目标派生表。3）  新鲜数据的获取：减少资源还能获取性能上的提升并不是常见的事。毕竟我们通常会使用更多的资源（例如内存）来提升性能（例如查询延迟）。Hudi通过从根本上摆脱数据集的传统管理方式，将批量处理增量化带来了一个附加的好处：与以前的数据湖相比，pipeline运行的时间会更短，数据交付会更快。4）  统一存储：基于以上三个优点，在现有数据湖之上进行更快速、更轻量的处理意味着仅出于访问近实时数据的目的时不再需要专门的存储或数据集市。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;2.设计原则&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;流式读/写&lt;/strong&gt;:Hudi借鉴了数据库设计的原理，从零设计，应用于大型数据集记录流的输入和输出。为此，Hudi提供了索引实现，可以将记录的键快速映射到其所在的文件位置。同样，对于流式输出数据，Hudi通过其特殊列添加并跟踪记录级的元数据，从而可以提供所有发生变更的精确增量流。&lt;strong&gt;自管理&lt;/strong&gt;：Hudi注意到用户可能对数据新鲜度（写友好）与查询性能（读/查询友好）有不同的期望，它支持了三种查询类型，这些类型提供实时快照，增量流以及稍早的纯列数据。在每一步，Hudi都努力做到自我管理（例如自动优化编写程序的并行性，保持文件大小）和自我修复（例如：自动回滚失败的提交），即使这样做会稍微增加运行时成本（例如：在内存中缓存输入数据已分析工作负载）。如果没有这些内置的操作杠杆/自我管理功能，这些大型流水线的运营成本通常会翻倍。&lt;strong&gt;万物皆日志&lt;/strong&gt;:Hudi还具有 append only、云数据友好的设计，该设计实现了日志结构化存储系统的原理，可以无缝管理所有云提供商的数据。&lt;br/&gt;&lt;strong&gt;键-值数据模型&lt;/strong&gt;：在写方面，Hudi表被建模为键值对数据集，其中每条记录都有一个唯一的记录键。此外，一个记录键还可以包括分区路径，在该路径下，可以对记录进行分区和存储。这通常有助于减少索引查询的搜索空间。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;3. 表设计&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;了解了Hudi项目的关键技术动机后，现在让我们更深入地研究Hudi系统本身的设计。在较高的层次上，用于写Hudi表的组件使用了一种受支持的方式嵌入到Apache Spark作业中，它会在支持DFS的存储上生成代表Hudi表的一组文件。然后，在具有一定保证的情况下，诸如Apache Spark、Presto、Apache Hive之类的查询引擎可以查询该表。 Hudi表的三个主要组件：1）  有序的时间轴元数据。类似于数据库事务日志。2）  分层布局的数据文件：实际写入表中的数据。3）  索引（多种实现方式）：映射包含指定记录的数据集。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3EcuPIickyyFjra2JpRniaIvFNWgxF4PbezolXaddt9LLFbSPC89vNQiciaMQKqNcA9oenpNZV5BSWiceFuLL0TgVGQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.4441860465116279&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1290&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Hudi提供了以下功能来对基础数据进行写入、查询，这使其成为大型数据湖的重要模块：1）  支持快速，可插拔索引的upsert();2）  高效、只扫描新数据的增量查询；3）  原子性的数据发布和回滚，支持恢复的Savepoint；4）  使用mvcc(多版本并发控制)风格设计的读和写快照隔离；5）  使用统计信息管理文件大小；6）  已有记录update/delta的自管理压缩；7）  审核数据修改的时间轴元数据；8）  满足GDPR(通用数据保护条例)、数据删除功能。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.1 时间轴&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在其核心，Hudi维护了一条包含在不同的即时时间（instant time）对数据集做的所有instant操作的timeline，从而提供表的即时视图，同时还有效支持按到达顺序进行数据检索。时间轴类似于数据库的redo/transaction日志，由一组时间轴实例组成。Hudi保证在时间轴上执行的操作的原子性和基于即时时间的时间轴一致性。时间轴被实现为表基础路径下.hoodie元数据文件夹下的一组文件。具体来说，最新的instant被保存为单个文件，而较旧的instant被存档到时间轴归档文件夹中，以限制writers和queries列出的文件数量。一个Hudi 时间轴instant由下面几个组件构成：1）  操作类型：对数据集执行的操作类型；2）  即时时间：即时时间通常是一个时间戳(例如：20190117010349)，该时间戳按操作开始时间的顺序单调增加；3）  即时状态：instant的当前状态;每个instant都有avro或者json格式的元数据信息，详细的描述了该操作的状态以及这个即时时刻instant的状态。 关键的Instant操作类型有：1）  COMMIT：一次提交表示将一组记录原子写入到数据集中；2）  CLEAN: 删除数据集中不再需要的旧文件版本的后台活动;3）  DELTA_COMMIT:将一批记录原子写入到MergeOnRead存储类型的数据集中，其中一些/所有数据都可以只写到增量日志中;4）  COMPACTION: 协调Hudi中差异数据结构的后台活动，例如：将更新从基于行的日志文件变成列格式。在内部，压缩表现为时间轴上的特殊提交;5）  ROLLBACK: 表示提交/增量提交不成功且已回滚，删除在写入过程中产生的所有部分文件;6）  SAVEPOINT: 将某些文件组标记为&quot;已保存&quot;，以便清理程序不会将其删除。在发生灾难/数据恢复的情况下，它有助于将数据集还原到时间轴上的某个点;任何给定的即时都会处于以下状态之一：1）  REQUESTED:表示已调度但尚未初始化；2）  INFLIGHT: 表示当前正在执行该操作;3）  COMPLETED: 表示在时间轴上完成了该操作. &lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;3.2 数据文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Hudi将表组织成DFS上基本路径下的文件夹结构中。如果表是分区的，则在基本路径下还会有其他的分区，这些分区是包含该分区数据的文件夹，与Hive表非常类似。每个分区均由相对于基本路径的分区路径唯一标识。在每个分区内，文件被组织成文件组，由文件ID唯一标识。其中每个切片包含在某个提交/压缩即时时间生成的基本列文件（*.parquet）以及一组日志文件（*.log*），该文件包含自生成基本文件以来对基本文件的插入/更新。Hudi采用了MVCC设计，压缩操作会将日志和基本文件合并以产生新的文件片，而清理操作则将未使用的/较旧的文件片删除以回收DFS上的空间。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3EcuPIickyyFjra2JpRniaIvFNWgxF4PbeMGj8tvSRBrfws1ho7UouaXTJTwwRqe6X74gH95Jibekib3MiabznKkhHQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.4842105263157895&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1900&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;3.3 索引&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Hudi通过索引机制提供高效的upsert操作，该机制会将一个记录键+分区路径组合一致性的映射到一个文件ID.这个记录键和文件组/文件ID之间的映射自记录被写入文件组开始就不会再改变。简而言之，这个映射文件组包含了一组文件的所有版本。Hudi当前提供了3种索引实现（HBaseIndex,、HoodieBloomIndex（HoodieGlobalBloomIndex）、InMemoryHashIndex）来映射一个记录键到包含该记录的文件ID。这将使我们无需扫描表中的每条记录，就可显著提高upsert速度。Hudi索引可以根据其查询分区记录的能力进行分类：1）  全局索引：不需要分区信息即可查询记录键映射的文件ID。比如，写程序可以传入null或者任何字符串作为分区路径（partitionPath）,但索引仍然会查找到该记录的位置。全局索引在记录键在整张表中保证唯一的情况下非常有用，但是查询的消耗随着表的大小呈函数式增加。2）  非全局索引：与全局索引不同，非全局索引依赖分区路径(partitionPath),对于给定的记录键，它只会在给定分区路径下查找该记录。这比较适合总是同时生成分区路径和记录键的场景，同时还能享受到更好的扩展性，因为查询索引的消耗只与写入到该分区下数据集大小有关系。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;4. 表类型&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;4.1 Copy On Write表&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;COW表写的时候数据直接写入basefile,（parquet）不写log文件。所以COW表的文件片只包含basefile(一个parquet文件构成一个文件片)。这种的存储方式的Spark DAG相对简单。关键目标是是使用partitioner将tagged Hudi记录RDD（所谓的tagged是指已经通过索引查询，标记每条输入记录在表中的位置）分成一些列的updates和inserts.为了维护文件大小，我们先对输入进行采样，获得一个工作负载profile,这个profile记录了输入记录的insert和update、以及在分区中的分布等信息。把数据从新打包，这样：1）  对于updates, 该文件ID的最新版本都将被重写一次，并对所有已更改的记录使用新值2）  对于inserts.记录首先打包到每个分区路径中的最小文件中，直到达到配置的最大大小。之后的所有剩余记录将再次打包到新的文件组，新的文件组也会满足最大文件大小要求。 &lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3EcuPIickyyFjra2JpRniaIvFNWgxF4Pbeo67cpAfWm7eqK9DK7XTcBluTge1whc0Wgyhtr0Hq1HRGdhXvVS6wpQ/640?wx_fmt=gif&quot; alt=&quot;&quot; data-ratio=&quot;0.4703125&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;4.2 Merge On Read表&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;MOR表写数据时，记录首先会被快速的写进日志文件，稍后会使用时间轴上的压缩操作将其与基础文件合并。根据查询是读取日志中的合并快照流还是变更流，还是仅读取未合并的基础文件，MOR表支持多种查询类型。在高层次上，MOR writer在读取数据时会经历与COW writer 相同的阶段。这些更新将追加到最新文件篇的最新日志文件中，而不会合并。对于insert,Hudi支持两种模式：1）  插入到日志文件：有可索引日志文件的表会执行此操作（HBase索引）；2）  插入parquet文件：没有索引文件的表（例如布隆索引）与写时复制（COW）一样，对已标记位置的输入记录进行分区，以便将所有发往相同文件id的upsert分到一组。这批upsert会作为一个或多个日志块写入日志文件。Hudi允许客户端控制日志文件大小。对于写时复制（COW）和读时合并（MOR）writer来说，Hudi的WriteClient是相同的。几轮数据的写入将会累积一个或多个日志文件。这些日志文件与基本的parquet文件（如有）一起构成一个文件片，而这个文件片代表该文件的一个完整版本。这种表是用途最广、最高级的表。为写（可以指定不同的压缩策略，吸收突发写流量）和查询（例如权衡数据的新鲜度和查询性能）提供了很大的灵活性。同时它包含一个学习曲线，以便在操作上掌控他。 &lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/3EcuPIickyyFjra2JpRniaIvFNWgxF4PbeWOVH3ibX218thTdKVl9g9jIRIxt88BlshyVJGwWD40Tp48Ze2tSZhBQ/640?wx_fmt=gif&quot; alt=&quot;&quot; data-ratio=&quot;0.4703125&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;5. 写设计&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;5.1 写操作&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;了解Hudi数据源或者deltastreamer工具提供的3种不同写操作以及如何最好的利用他们可能会有所帮助。这些操作可以在对数据集发出的每个commit/delta commit中进行选择/更改。1）  upsert操作：这是默认操作，在该操作中，首先通过查询索引将数据记录标记为插入或更新，然后再运行试探法确定如何最好地将他们打包到存储，以对文件大小进行优化，最终将记录写入。对于诸如数据库更改捕获之类的用例，建议在输入几乎肯定包含更新的情况下使用此操作。2）  insert操作：与upsert相比，insert操作也会运行试探法确定打包方式，优化文件大小，但会完全跳过索引查询。因此对于诸如日志重复数据删除（结合下面提到的过滤重复项选项）的用例而言，它比upsert的速度快得多。这也适用于数据集可以容忍重复项，但只需要Hudi具有事务性写/增量拉取/存储管理功能的用例。3）  bulk insert操作：upsert 和insert操作都会将输入记录保留在内存中，以加快存储启发式计算速度，因此对于最初加载/引导Hudi数据集的用例而言可能会很麻烦。Bulk insert提供了与insert相同的语义，同时实现了基于排序的数据写入算法，该算法可以很好的扩展数百TB的初始负载。但是这只是在调整文件大小方面进行的最大努力，而不是像insert/update那样保证文件大小。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.2 压缩&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;压缩是一个 instant操作，它将一组文件片作为输入，将每个文件切片中的所有日志文件与其basefile文件（parquet文件）合并，以生成新的压缩文件片，并写为时间轴上的一个commit。压缩仅适用于读时合并（MOR）表类型，并且由压缩策略（默认选择具有最大未压缩日志的文件片）决定选择要进行压缩的文件片。这个压缩策略会在每个写操作之后评估。从高层次上讲，压缩有两种方式：1）同步压缩：这里的压缩由写程序进程本身在每次写入之后同步执行的，即直到压缩完成后才能开始下一个写操作。就操作而言，这个是最简单的，因为无需安排单独的压缩过程，但保证的数据新鲜度最低。不过，如果可以在每次写操作中压缩最新的表分区，同时又能延迟迟到/较旧分区的压缩，这种方式仍然非常有用。2）异步压缩：使用这种方式，压缩过程可以与表的写操作同时异步运行。这样具有明显的好处，即压缩不会阻塞下一批数据写入，从而产生近实时的数据新鲜度。Hudi DeltaStreamer之类的工具支持边界的连续模式，其中的压缩和写入操作就是以这种方式在单个Spark运行时集群中进行的。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.3 清理&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;清理是一项基本的即时操作，其执行的目的是删除旧的文件片，并限制表占用的存储空间。清理会在每次写操作之后自动执行，并利用时间轴服务器上缓存的时间轴元数据来避免扫描整个表来评估清理时机。Hudi支持两种清理方式：1）  按commits / deltacommits清理：这是增量查询中最常见且必须使用的模式。以这种方式，Cleaner会保留最近N次commit/delta commit提交中写入的所有文件切片，从而有效提供在任何即时范围内进行增量查询的能力。尽管这对于增量查询很有帮助，但由于保留了配置范围内所有版本的文件片，因此，在某些高写入负载的场景下可能需要更大的存储空间。2）  按保留的文件片清理：这是一种更为简单的清理方式，这里我们仅保存每个文件组中的最后N个文件片。诸如Apache Hive之类的某些查询引擎会处理非常大的查询，这些查询可能需要几个小时才能完成，在这种情况下，将N设置为足够大以至于不会删除查询仍然可以访问的文件片是很有用的。此外，清理操作会保证每个文件组下面会一直只有一个文件片（最新的一片）。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;5.4 DFS访问优化&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Hudi还对表中存储的数据执行了几种秘钥存储管理功能。在DFS上存储数据的关键是管理文件大小和计数以及回收存储空间。例如，HDFS在处理小文件问题上臭名昭著--在NameNode上施加内存/RPC压力，可能破坏整个集群的稳定性。通常，查询引擎可在适当大小的列文件上提供更好的性能，因为它们可以有效地摊销获取列统计信息等的成本。即使在某些云数据存储上，列出包含大量小文件的目录也会产生成本。下面是一些Hudi高效写，管理数据存储的方法：1）小文件处理特性会剖析输入的工作负载，并将内容分配到现有的文件组，而不是创建新文件组（这会导致生成小文件）。2）在writer中使用一个时间轴缓存，这样只要Spark集群不每次都重启，后续的写操作就不需要列出DFS目录来获取指定分区路径下的文件片列表。3）用户还可以调整基本文件和日志文件大小之间的比值系数以及期望的压缩率，以便将足够数量的insert分到统一文件组，从而生成大小合适的基本文件。4）智能调整bulk insert并行度，可以再次调整大小合适的初始文件组。实际上，正确执行此操作非常关键，因为文件组一旦创建就不能被删除，而只能如前面所述对其进行扩展。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;6.查询&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;鉴于这种灵活而全面的数据布局和丰富的时间线，Hudi能够支持三种不同的查询表方式，具体取决于表的类型。&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;141&quot;&gt;查询类型&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;COW&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;184&quot;&gt;MOR&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;141&quot;&gt;快照查询&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;查询在给定表或表分区中所有文件片中的最新基本文件上执行，将查看到最新提交的记录。&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;184&quot;&gt;通过并到给定表或表分区中的所有文件切片中最新的基本文件及其日志文件合来执行查询，将看到最新的delta-commit操作写入的的记录。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;141&quot;&gt;增量查询&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;在给定的开始，结束即时时间范围内，对最新的基本文件执行查询（称为增量查询窗口），同时仅使用Hudi指定的列提取在此窗口中写入的记录。&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;184&quot;&gt;查询是在增量查询窗口中对最新的文件片执行的，具体取决于窗口本身，读取基本块或日志块中读取记录的组合。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;141&quot;&gt;读优化查询&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;227&quot;&gt;和快照查询相同&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;184&quot;&gt;仅访问基本文件，提供给定文件片自上次执行压缩操作以来的数据。通常查询数据的最新程度的保证取决于压缩策略&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3EcuPIickyyFjra2JpRniaIvFNWgxF4PbeKWFsezp37CYJgY7E4zs0Uxuym6B8zhfobM1wGhhib23lalFibEz646BQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.4984375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;6.1 快照查询&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可查看给定delta commit或者commit即时操作后表的最新快照。在读时合并（MOR）表的情况下，它通过即时合并最新文件片的基本文件和增量文件来提供近实时表（几分钟）。对于写时复制（COW），它可以替代现有的parquet表（或相同基本文件类型的表），同时提供upsert/delete和其他写入方面的功能。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;6.2 增量查询&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可查看自给定commit/delta commit即时操作以来新写入的数据。有效的提供变更流来启用增量数据管道。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;6.3 读优化查询&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;可查看给定的commit/compact即时操作的表的最新快照。仅将最新文件片的基本/列文件暴露给查询，并保证与非Hudi表相同的列查询性能。&lt;/p&gt;
&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;指标&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;274&quot;&gt;读优化查询&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;184&quot;&gt;快照查询&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;数据延迟&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;274&quot;&gt;高&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;184&quot;&gt;低&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;94&quot;&gt;查询延迟&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;274&quot;&gt;低&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;184&quot;&gt;高&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
</description>
<pubDate>Wed, 15 Apr 2020 21:34:00 +0000</pubDate>
<dc:creator>leesf</dc:creator>
<og:description>感谢 Apache Hudi contributor：王祥虎&amp;#160;翻译&amp;amp;供稿。 欢迎关注微信公众号：ApacheHudi 本文将介绍Apache Hudi的基本概念、设计以及总体基础架构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leesf456/p/12710118.html</dc:identifier>
</item>
<item>
<title>在SpringBoot中使用SpringSecurity - 小鱼吃猫</title>
<link>http://www.cnblogs.com/Lyn4ever/p/12709953.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lyn4ever/p/12709953.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本教程是基于SpringMVC而创建的，不适用于WebFlux。（如果你不知道这两者，可以忽略这句提示）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;提出一个需求&quot;&gt;提出一个需求&lt;/h2&gt;
&lt;p&gt;所有的技术是为了解决实际问题而出现的，所以我们并不空谈，也不去讲那么多的概念。在这样一个系统中，有三个接口，需要授权给三种权限的人使用，如下表：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;接口地址&lt;/th&gt;
&lt;th&gt;需要的权限描述&lt;/th&gt;
&lt;th&gt;可访问的权限组名称&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;visitor/main&lt;/td&gt;
&lt;td&gt;不需要权限，也不用登录，谁都可以访问&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;admin/main&lt;/td&gt;
&lt;td&gt;必须登录，只有管理员可以访问&lt;/td&gt;
&lt;td&gt;ADMIN&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;user/main&lt;/td&gt;
&lt;td&gt;必须登录，管理员和用户权限都能访问&lt;/td&gt;
&lt;td&gt;USER和ADMIN&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;解决方案：&quot;&gt;解决方案：&lt;/h2&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在Controller中判断用户是否登录和用户的权限组判断是否可以访问&lt;/p&gt;
&lt;p&gt;这是最不现实的解决方案，可是我刚进公司时的项目就是这样设计的，当时我还觉得很高大尚呢。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;使用Web应用的三大组件中和过滤器（Filter）进行判断&lt;/p&gt;
&lt;p&gt;这是正解，SpringSecurity也正是用的这个原理。如果你的项目足够简单，建议你直接使用这种方式就可以了，并不需要集成SpringSecurity。这部分的示例在代码中有演示，自己下载代码查看即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们可以直接使用SpringSecurity框架来解决这个问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;使用springsecurity进行解决&quot;&gt;使用SpringSecurity进行解决&lt;/h2&gt;
&lt;p&gt;​ 网上的教程那么多，但是讲的都不清不楚。所以，请仔细阅读下段这些话，这要比后边的代码重要。&lt;/p&gt;
&lt;p&gt;​ SpringSecurity主要有两部分内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;认证 （你是谁，说白了就是一个用户登录的功能，帮我们验证用户名和密码）&lt;/li&gt;
&lt;li&gt;授权 （你能干什么，就是根据当前登录用户的权限，说明你能访问哪些接口，哪些不能访问。）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里的登录是对于浏览器访问来说的，因为如果是前后端分离时，使用的是Token进行授权的，也可以理解为登录用户，这个后边会讲。这里只是为了知识的严谨性才提到了这点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;springsecurity和springboot结合&quot;&gt;SpringSecurity和SpringBoot结合&lt;/h3&gt;
&lt;h4 id=&quot;1-首先在pomxml中引入依赖：&quot;&gt;1. 首先在pom.xml中引入依赖：&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 不用写版本，继承Springboot的版本--&amp;gt;
&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-boot-starter-security&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2-配置用户角色和接口的权限关系&quot;&gt;2. 配置用户角色和接口的权限关系&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;是支持使用xml进行配置的，但是在SpringBoot中更建议使用Java注解配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    /**
     * 配置用户权限组和接口路径的关系
     * 和一些其他配置
     *
     * @param http
     * @throws Exception
     */
    @Override
     protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()     // 对请求进行验证
                .antMatchers(&quot;/visitor/**&quot;).permitAll()
                .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ROLE_ADMIN&quot;)     // 必须有ADMIN权限
                .antMatchers(&quot;/user/**&quot;).hasAnyRole(&quot;ROLE_USER&quot;, &quot;ROLE_ADMIN&quot;)       //有任意一种权限
                .anyRequest()     //任意请求（这里主要指方法）
                .authenticated()   //// 需要身份认证
                .and()   //表示一个配置的结束
                .formLogin().permitAll()  //开启SpringSecurity内置的表单登录，会提供一个/login接口
                .and()
                .logout().permitAll()  //开启SpringSecurity内置的退出登录，会为我们提供一个/logout接口
                .and()
                .csrf().disable();    //关闭csrf跨站伪造请求
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上边的配置主要内容有两个:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;配置访问三个接口（实际上不仅仅是3个，/**是泛指）需要的权限；&lt;/li&gt;
&lt;li&gt;配置了使用SpringSecurity的内置/login和/loginout接口（这个是完全可以自定义的）&lt;/li&gt;
&lt;li&gt;权限被拒绝后的返回结果也可以自定义，它当权限被拒绝后，会抛出异常&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;上边的配置中，其实就是调用http的这个对象的方法；&lt;/li&gt;
&lt;li&gt;使用.and()只为了表示一上配置结束，并满足链式调用的要求，不然之前的对象可能并不能进行链式调用&lt;/li&gt;
&lt;li&gt;这个配置在SpringBoot应用启动的时候就会调用，也就是会将这些配置加载进内存，当用户调用对应的接口的时候，就会判断它的角色是否可以调用这个接口，流程图如下（我觉得图要比文字更能说明过程）：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vbHluNGV2ZXIvcGljZ28taW1nL3Jhdy9tYXN0ZXIvaW1nLzIwMjAwNDE1MjM1MjMyLnBuZw?x-oss-process=image/format,png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3-配置用户名和密码&quot;&gt;3. 配置用户名和密码&lt;/h4&gt;
&lt;p&gt;​ 配置了上边的接口和用户权限角色的关系后，就是要配置我们的用户名和密码了。如果没有正确的用户名和密码，神仙也登录不上去。&lt;/p&gt;
&lt;p&gt;​ 关于这个，网上的教程有各种各样的配置，其实就一个接口，我们只需要实现这个接口中的方法就可以了。接口代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package org.springframework.security.core.userdetails;

public interface UserDetailsService {
        /**
         * 在登录的时候，就会调用这个方法，它的返回结果是一个UserDetails接口类
         */
    UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 来看一下这个接口，如果想扩展，可以自己写一个实现类，也可以使用SpringSecurity提供的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface UserDetails extends Serializable {
        // 用户授权集合
    Collection&amp;lt;? extends GrantedAuthority&amp;gt; getAuthorities();
    String getPassword();
    String getUsername();
    boolean isAccountNonExpired();
    boolean isAccountNonLocked();
    boolean isCredentialsNonExpired();
    boolean isEnabled();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ UserDetailsServicer接口的实现类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class UserDetailsServiceImpl implements UserDetailsService {
    /**
     * 这个方法要返回一个UserDetails对象
     * 其中包括用户名，密码，授权信息等
     *
     * @param username
     * @return
     * @throws UsernameNotFoundException
     */
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        /**
         * 将我们的登录逻辑写在这里
         * 我是直接在这里写的死代码，其实应该从数据库中根据用户名去查
         */
        if (username == null) {
            //返回null时，后边就会抛出异常，就会登录失败。但这个异常并不需要我们处理
            return null;
        }
        if (username.equals(&quot;lyn4ever&quot;)) {
            //这是构造用户权限组的代码
            //但是这个权限上加了ROLE_前缀，而在之前的配置上却没有加。
            //与其说这不好理解，倒不如说这是他设计上的一个小缺陷
            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(&quot;ROLE_USER&quot;);
            List&amp;lt;SimpleGrantedAuthority&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
            list.add(authority);
            //这个user是UserDetails的一个实现类
            //用户密码实际是lyn4ever,前边加{noop}是不让SpringSecurity对密码进行加密，使用明文和输入的登录密码比较
            //如果不写{noop},它就会将表表单密码进行加密，然后和这个对比
            User user = new User(&quot;lyn4ever&quot;, &quot;{noop}lyn4ever&quot;, list);
            return user;
        }
        if (username.equals(&quot;admin&quot;)) {
            SimpleGrantedAuthority authority = new SimpleGrantedAuthority(&quot;ROLE_USER&quot;);
            SimpleGrantedAuthority authority1 = new SimpleGrantedAuthority(&quot;ROLE_ADMIN&quot;);
            List&amp;lt;SimpleGrantedAuthority&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();
            list.add(authority);
            list.add(authority1);
            User user = new User(&quot;admiin&quot;, &quot;{noop}admin&quot;, list);
            return user;
        }

        //其他返回null
        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4进行测试&quot;&gt;4.进行测试&lt;/h4&gt;
&lt;p&gt;​ 分别访问上边三个接口，可以看到访问结果和上边的流程是一样的。&lt;/p&gt;
&lt;h3 id=&quot;总结：&quot;&gt;总结：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;仔细阅读上边的那个流程图，是理解SpringSecurity最重要的内容，代码啥的都很简单；上边也就两个类，一个配置接口与角色的关系，一个实现了UserDetailsService类中的方法。&lt;/li&gt;
&lt;li&gt;前边说了，SpringSecurity主要就是两个逻辑：
&lt;ul&gt;&lt;li&gt;用户登录后，将用户的角色信息保存在服务器（session中）；&lt;/li&gt;
&lt;li&gt;用户访问接口后，从session中取出用户信息，然后和配置的角色和权限进行比对是否有这个权限访问&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;上述方法中，我们只重写了用户登录时的逻辑。而根据访问接口来判断当前用户是否拥有这个接口的访问权限部分，我们并没有进行修改。所以这只适用于可以使用session的项目中。&lt;/li&gt;
&lt;li&gt;对于前后端分离的项目，一般是利用JWT进行授权的，所以它的主要内容就在判断token中的信息是否有访问这个接口的权限，而并不在用户登录这一部分。&lt;/li&gt;
&lt;li&gt;解决访问的方案有很多种，选择自己最适合自己的才是最好了。SpringSecurity只是提供了一系列的接口，他自己内部也有一些实现，你也可以直接使用。&lt;/li&gt;
&lt;li&gt;上边配置和用户登录逻辑部分的内容是完全可以从数据库中查询出来进行配置的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/Lyn4ever29/springboot-learn&quot;&gt;代码地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://lyn4ever.gitee.io/img/wx/gzh2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Apr 2020 17:38:00 +0000</pubDate>
<dc:creator>小鱼吃猫</dc:creator>
<og:description>@[TOC] 本教程是基于SpringMVC而创建的，不适用于WebFlux。（如果你不知道这两者，可以忽略这句提示） 提出一个需求 所有的技术是为了解决实际问题而出现的，所以我们并不空谈，也不去讲那</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lyn4ever/p/12709953.html</dc:identifier>
</item>
<item>
<title>关于redis单线程的分析 - 肥宅快乐码</title>
<link>http://www.cnblogs.com/fatmanhappycode/p/12708861.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fatmanhappycode/p/12708861.html</guid>
<description>&lt;p&gt;redis为什么那么快？结论有三点，大家都知道，这里主要是分析。&lt;/p&gt;
&lt;p&gt;首先第一点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;redis是内存访问的，所以快&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当然这个大家都知道，所以不是重点&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;一般我们把任务分为&lt;strong&gt;io密集型&lt;/strong&gt;和&lt;strong&gt;&lt;strong&gt;cpu密集型&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;strong&gt;io密集型&lt;/strong&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O (硬盘/内存) 的读/写操作，此时CPU Loading并不高。&lt;/li&gt;
&lt;li&gt;对于io密集型的任务，它的主要时间都在磁盘io上，而io本身在发出中断告知cpu后，cpu只需要短暂的处理一下，之后就由DMA(详见附录)负责数据传输，整个过程对cpu的利用率很低。因此我们需要开更多的线程去充分利用cpu。即一般&lt;strong&gt;线程数 = cpu核心数 * 2&lt;/strong&gt;，如数据库连接池&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;cpu密集型&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPU Loading 100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPU Loading很高。&lt;/li&gt;
&lt;li&gt;对于cpu密集型的任务，它对cpu的利用率很高，所以不需要开更多的线程去提高cpu利用率。假如增加线程，只会引起线程的频繁切换导致本来就不够用的cpu更加不够用。所以一般是&lt;strong&gt;线程数 = cpu核心数 + 1&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;

&lt;p&gt;redis基本都在进行内存io，那它的瓶颈在io上吗？&lt;/p&gt;
&lt;p&gt;redis在网络io上使用epoll实现了一个io多路复用的reactor模型，epoll是非阻塞io，所以避免了cpu阻塞在io上，所以它&lt;strong&gt;不是io密集型&lt;/strong&gt;，瓶颈不在于等待io导致cpu利用率不高，不需要多个线程来屏蔽等待io执行完成的时间。当然redis的io利用率很高，但是io利用率高并不代表它是io密集型，因为它瓶颈不在等待io上。&lt;/p&gt;

&lt;p&gt;所以第二点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;redis在网络io上使用epoll实现了一个io多路复用的reactor模型使得cpu利用率更高，浪费在io上的时间更少&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;redis并不需要多线程来提高cpu利用率减少io等待时间，并且单线程架构也比较容易实现，所以顺理成章就采用了单线程架构。&lt;/p&gt;
&lt;p&gt;关于epoll可以看我的这篇文章：&lt;a href=&quot;https://www.cnblogs.com/fatmanhappycode/p/12362423.html&quot;&gt;https://www.cnblogs.com/fatmanhappycode/p/12362423.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第三点&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于采用了单线程架构，避免了线程线程切换产生的消耗&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;因为一次CPU上下文的切换大概在 1500ns 左右。&lt;/p&gt;
&lt;p&gt;从内存中读取 1MB 的连续数据，耗时大约为 250us，假设1MB的数据由多个线程读取了1000次，那么就有1000次时间上下文的切换，&lt;/p&gt;
&lt;p&gt;那么就有1500ns * 1000 = 1500us ，我单线程的读完1MB数据才250us ,你光时间上下文的切换就用了1500us了，我还不算你每次读一点数据 的时间&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;那么redis是cpu密集型吗？答案是否定的。&lt;/p&gt;
&lt;p&gt;redis也&lt;strong&gt;不是cpu密集型。&lt;/strong&gt;大多数情况下redis机器上的cpu是很够用的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;redis的瓶颈在于内存大小和网络带宽。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果想要更充分的利用多核cpu，可以采用多个redis实例的方法，同时为了减少线程争用，可以将实例和cpu绑定的方法。&lt;/p&gt;
&lt;p&gt;但是如果做了CPU绑定，在rdb和aof时子进程会与父进程共享使用一个CPU。子进程重写时对单核CPU使用率通常在90%以上，父进程与子进程将产生激烈CPU竞争，极大影响Redis稳定性。（解决方法不清楚，也许多绑定一个CPU会好点？）&lt;/p&gt;

&lt;hr/&gt;

&lt;h2&gt;DMA&lt;/h2&gt;
&lt;p&gt;DMA 传输将数据从一个地址空间复制到另外一个地址空间。当CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实行和完成。&lt;/p&gt;
&lt;p&gt;典型的例子就是移动一个外部内存的区块到芯片内部更快的内存区。例如内存移到磁盘。&lt;/p&gt;

&lt;p&gt;最后惯例附一图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1576191/202004/1576191-20200416004641982-1496219650.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.php.cn/redis/422123.html&quot;&gt;https://www.php.cn/redis/422123.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/youanyyou/article/details/78990156&quot;&gt;https://blog.csdn.net/youanyyou/article/details/78990156&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 15 Apr 2020 16:49:00 +0000</pubDate>
<dc:creator>肥宅快乐码</dc:creator>
<og:description>redis为什么那么快？结论有三点，大家都知道，这里主要是分析。 首先第一点 redis是内存访问的，所以快 当然这个大家都知道，所以不是重点 io密集型和cpu密集型 一般我们把任务分为io密集型和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fatmanhappycode/p/12708861.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL 的楼宇智能化集成系统（三） - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12709672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12709672.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200405184700868-733454514.gif&quot; class=&quot;desc_img&quot;/&gt; 2018年7月，信息化部印发了《工业互联网平台建设及推广指南》和《工业互联网平台评价方法》，掀起了 工业互联网 的浪潮，并成为热词写入了报告中。同为信息发展下的产物 建筑智能化集成系统 也是兼具着信息与管理的重要体现，数据化信息通过可视化的管理系统展示出一套互联网智能优化的解决方案，而本系列文章便结合了 HT 的 2D/3D 可视化工具的运用，结合面板的数据展示和大楼建模场景的可视化管理，前面的内容已经讲解了 3D 模型和 2D 面板的融合体现，本次的内容将带您探讨 智慧楼宇管理系统、电梯监控系统 以及 停车场管理系统 的实现方式和整体系统的联合优化体现。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;124.86543056908&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;      2018年7月，信息化部印发了《工业互联网平台建设及推广指南》和《工业互联网平台评价方法》，掀起了 &lt;strong&gt;工业互联网 &lt;/strong&gt;的浪潮，并成为热词写入了报告中。同为信息发展下的产物 &lt;strong&gt;建筑智能化集成系统 &lt;/strong&gt;也是兼具着信息与管理的重要体现，数据化信息通过可视化的管理系统展示出一套互联网智能优化的解决方案，而本系列文章便结合了 &lt;strong&gt;HT&lt;/strong&gt;  的 &lt;strong&gt;2D/3D&lt;/strong&gt; 可视化工具的运用，结合面板的数据展示和大楼建模场景的可视化管理，前面的内容已经讲解了 3D 模型和 2D 面板的融合体现，本次的内容将带您探讨 &lt;strong&gt;智慧楼宇管理系统、&lt;/strong&gt;电梯监控系统 以及 &lt;strong&gt;停车场管理系统 &lt;/strong&gt;的实现方式和整体系统的联合优化体现。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;界面简介及效果预览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;智慧楼宇管理系统优化效果&lt;/strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      主要包括冷站、热站和中央末端智慧群控的联合作用，以及楼层智慧照明，通过清晰的动画体现出整栋大楼智慧节能运作的流程，可以通过面板详情的演示细致地介绍每个场景的作用以及串联的用处。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200405184700868-733454514.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;&lt;strong&gt;电梯以及楼层监控效果&lt;/strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      可视化地实时监控电梯在楼层间的工作运行状态，并且能够准确地浏览每个电梯内的实时监控画面。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200405185824724-312951180.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;停车场管理系统监控效果&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      停车场作为现在楼宇监控不可缺失的一环，这里主要可以体现出实时的车位监控，通过简单的动画演示来表现出整个停车场车辆的运行状态，方便管理。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200405184816218-982770776.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;一、 &lt;/strong&gt;&lt;strong&gt;&lt;strong&gt;智慧楼宇管理系统优化效果的&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;实现&lt;/p&gt;
&lt;div readability=&quot;9.6363636363636&quot;&gt;      在点击智慧楼宇管理系统的按钮后，场景视角会根据 moveCamera 转移到大楼正视的视角后，大楼整体呈现渐变虚化后透明展示大楼内部信息，这个动画是封装了一个 tweenColor 颜色变化的过渡效果，从一种颜色 rgba 状态上改变色值和透明度来体现视觉上的变化。在效果展示上有一种可视化浸入式查看大楼内部信息的体验，具体的 3D 模型属性的变化可参考 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html&quot; target=&quot;_blank&quot;&gt;&amp;lt;HT 的 3D 手册&amp;gt;&lt;/a&gt;。&lt;/div&gt;
&lt;div readability=&quot;24.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过 moveCamera 改变 eye 和 center 来移动场景视角为大楼的正视面
moveCamera(g3d, [134, 399, 1617], [7, 40, 144&lt;span data-mce-=&quot;&quot;&gt;], {
    duration: 2000&lt;span data-mce-=&quot;&quot;&gt;,
    easing: t =&amp;gt; t *&lt;span data-mce-=&quot;&quot;&gt; t,
    finishFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 开启场景大楼模型的可透明为 true
        &lt;span data-mce-=&quot;&quot;&gt;this.building.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            c.s({
                'shape3d.transparent': &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;,
            });
        });
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 大楼模型线框的颜色变化
        tweenColor(&lt;span data-mce-=&quot;&quot;&gt;this.building, 'wf.color', 'rgba(72,149,232,1)', 'rgba(56,156,255,0.03)'&lt;span data-mce-=&quot;&quot;&gt;, {
            duration: 2000&lt;span data-mce-=&quot;&quot;&gt;,
            easing: t =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; t
        });
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 大楼模型整体染色的颜色变化
        tweenColor(&lt;span data-mce-=&quot;&quot;&gt;this.building, 'shape3d.blend', 'rgba(120,180,255,1)', 'rgba(120,180,255,0)'&lt;span data-mce-=&quot;&quot;&gt;, {
            duration: 2000&lt;span data-mce-=&quot;&quot;&gt;,
            easing: t =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; t,
            finishFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 楼层设置为可见
                &lt;span data-mce-=&quot;&quot;&gt;this.floor.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                    setNodeVisible(c, &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;);
                });
                &lt;span data-mce-=&quot;&quot;&gt;this.floorLighting = 1&lt;span data-mce-=&quot;&quot;&gt;;
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 显示大楼建筑信息的动画
                &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.showBuilding();
            }
        });
    }
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;      颜色变化函数的实现是传入参数来改变节点的颜色属性变化值：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;node：&lt;/strong&gt;改变颜色的图元节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;startColor：&lt;/strong&gt;起始颜色的 rgba 值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;endColor：&lt;/strong&gt;变化后颜色的 rgba 值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;animParams：&lt;/strong&gt;过渡动画参数；&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;tweenColor(node, property, startColor, endColor, animParams) {
    animParams = animParams ||&lt;span data-mce-=&quot;&quot;&gt; {};
    &lt;span data-mce-=&quot;&quot;&gt;if (!animParams.frames &amp;amp;&amp;amp; !&lt;span data-mce-=&quot;&quot;&gt;animParams.duration)
        animParams.duration = 5000&lt;span data-mce-=&quot;&quot;&gt;;
    &lt;span data-mce-=&quot;&quot;&gt;if (!&lt;span data-mce-=&quot;&quot;&gt;animParams.easing)
        animParams.easing = t =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; t;

    startColor =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.toColorData(startColor);
    endColor =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.toColorData(endColor);

    const dx = endColor[0] - startColor[0&lt;span data-mce-=&quot;&quot;&gt;];
    const dy = endColor[1] - startColor[1&lt;span data-mce-=&quot;&quot;&gt;];
    const dz = endColor[2] - startColor[2&lt;span data-mce-=&quot;&quot;&gt;];
    const da = endColor[3] - startColor[3&lt;span data-mce-=&quot;&quot;&gt;];
    const postAction =&lt;span data-mce-=&quot;&quot;&gt; animParams.postAction;
    animParams.action = (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        const x = startColor[0] + v *&lt;span data-mce-=&quot;&quot;&gt; dx;
        const y = startColor[1] + v *&lt;span data-mce-=&quot;&quot;&gt; dy;
        const z = startColor[2] + v *&lt;span data-mce-=&quot;&quot;&gt; dz;
        const a = (startColor[3] + v * da) / 255&lt;span data-mce-=&quot;&quot;&gt;;

        node.s(property, ('rgba(' + ([x, y, z, a]).join(', ')) + ')'&lt;span data-mce-=&quot;&quot;&gt;);

        &lt;span data-mce-=&quot;&quot;&gt;if (postAction) postAction(('rgba(' + ([x, y, z, a]).join(', ')) + ')'&lt;span data-mce-=&quot;&quot;&gt;);
    }
    &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt; ht.Default.startAnim(animParams);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      大楼透明化后展示内部信息，此时我们可以看到楼层的照明系统从底楼逐一向上亮起也是通过这种方法实现的。而后大楼两侧的系统介绍面板是通过改变面板的缩放属性来实现延展的效果：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200405200109195-2098011290.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 面板显示
&lt;span data-mce-=&quot;&quot;&gt;showPanel(data) {
    ht.Default.startAnim({
        duration: 1000&lt;span data-mce-=&quot;&quot;&gt;,
        easing: t =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; t,
        action: (v,t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            data.setScaleX(data.getScaleX() + (1 - data.getScaleX()) *&lt;span data-mce-=&quot;&quot;&gt; v);
        }
    });
}

&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 面板隐藏
&lt;span data-mce-=&quot;&quot;&gt;hidePanel(data) {
    ht.Default.startAnim({
        duration: 1000&lt;span data-mce-=&quot;&quot;&gt;,
        easing: t =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; t,
        action: (v,t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            data.setScaleX(data.getScaleX() + (0 - data.getScaleX()) *&lt;span data-mce-=&quot;&quot;&gt; v);
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;二、&lt;/strong&gt;&lt;strong&gt;电梯以及楼层监控效果&lt;/strong&gt;&lt;/span&gt;的实现&lt;/p&gt;
&lt;p&gt;      电梯是大楼日常管理必不可少的一环，而通过可视化场景便可实时对接电梯运行的情况。电梯动画效果的实现原理是判断当前电梯所处楼层的位置和下一层随机楼层的位置，来实现楼梯运行动画，本栋大楼划分设定为每层楼层高50，所以只需要得到电梯所处的高度就很容易可以判断出所处的楼层，而电梯面板也是通过这个判断来实时展示楼层的信息。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200406223730356-1319030728.gif&quot; alt=&quot;&quot; width=&quot;486&quot; height=&quot;356&quot;/&gt;&lt;/div&gt;

&lt;p&gt;      具体实现的伪代码如下：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;elevatorAnimation(data) {
    const g3d = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d;
    const tag =&lt;span data-mce-=&quot;&quot;&gt; data.getTag();
    const e =&lt;span data-mce-=&quot;&quot;&gt; data.getElevation();
    const label = data.getChildAt(0&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断现在所处楼层
    let now = Math.ceil(e / 50&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 下一层楼层取1~7随机数
    let next = randomNumber(1, 7&lt;span data-mce-=&quot;&quot;&gt;);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 根据现在的楼层和下一个楼层，判断电梯运行的范围
    let range =&lt;span data-mce-=&quot;&quot;&gt; numBetween(now, next);
    &lt;span data-mce-=&quot;&quot;&gt;this.animationElevatorMap[tag] =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.startAnim({
        duration: range * 800&lt;span data-mce-=&quot;&quot;&gt;,
        easing: t =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; t,
        action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 电梯运行位置设定
            data.setElevation(now &amp;lt; next ? (e + (range * 50) * v) : (e - (range * 50) *&lt;span data-mce-=&quot;&quot;&gt; v));
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置电梯楼层面板显示并根据电梯位置设定
            &lt;span data-mce-=&quot;&quot;&gt;if (!label) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
            const floor = Math.ceil(data.getElevation() / 50&lt;span data-mce-=&quot;&quot;&gt;);
            &lt;span data-mce-=&quot;&quot;&gt;if (floor === label.a('text')) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
            label.a('text'&lt;span data-mce-=&quot;&quot;&gt;, floor);
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 手动刷新电梯面板信息
&lt;span data-mce-=&quot;&quot;&gt;            g3d.invalidateShape3dCachedImage(label);
        },
        finishFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 销毁电梯间隔动画
            &lt;span data-mce-=&quot;&quot;&gt;delete &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.timeoutElevatorMap[tag];

            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 执行电梯间隔动画后回调电梯运行动画
            &lt;span data-mce-=&quot;&quot;&gt;this.timeoutElevatorMap[tag] = setTimeout(() =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.elevatorAnimation1(data);
            }, Math.floor(Math.random() * 5000) + 2000&lt;span data-mce-=&quot;&quot;&gt;);
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;三、&lt;/strong&gt;&lt;strong&gt;停车场管理系统监控效果&lt;/strong&gt;&lt;/span&gt;的实现&lt;/p&gt;
&lt;p&gt;      停车场的车位信息可以直观地在 3D 场景中去实现管理，而车辆进出的可视化控制也可以用简单的管道动画去实现，实时监控车辆进出去调用这个动画就能很直观地反应停车场的实时情况。而停车场的具体实现方案是通过车辆节点的前进管道和倒退管道去调用封装的管道动画来实现车辆行驶和倒车入库的动画效果：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200406224238700-252887073.gif&quot; alt=&quot;&quot; width=&quot;706&quot; height=&quot;352&quot;/&gt;&lt;/div&gt;

&lt;p&gt;      每个车辆的停车动画都包含着 forwardPath 和 backwardPath 两条路线，分别对应着车辆的前进路线和倒车路线，具体的行驶伪代码如下：&lt;/p&gt;
&lt;div readability=&quot;13.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
park(car, key = 'Path'&lt;span data-mce-=&quot;&quot;&gt;, finishFunc) {
    const dm =&lt;span data-mce-=&quot;&quot;&gt; car.dm();
    const tag =&lt;span data-mce-=&quot;&quot;&gt; car.getTag();
    const forwardPath = dm.getDataByTag(tag + '_forward' +&lt;span data-mce-=&quot;&quot;&gt; key);
    const backwardPath = dm.getDataByTag(tag + '_backward' +&lt;span data-mce-=&quot;&quot;&gt; key);
    &lt;span data-mce-=&quot;&quot;&gt;this.animationMap[tag] = move(car, forwardPath, 'forward', undefined, 24&lt;span data-mce-=&quot;&quot;&gt;, {
        pathEndFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.animationMap[tag].stop();

            &lt;span data-mce-=&quot;&quot;&gt;this.animationMap[tag] = move(car, backwardPath, 'backward'&lt;span data-mce-=&quot;&quot;&gt;, undefined, undefined, {
                pathEndFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                    &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.animationMap[tag].stop();
                    &lt;span data-mce-=&quot;&quot;&gt;delete &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.animationMap[tag];

                    &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (finishFunc) finishFunc();
                    &lt;span data-mce-=&quot;&quot;&gt;return &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;;
                }
            });
            &lt;span data-mce-=&quot;&quot;&gt;return &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;;
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div readability=&quot;29.563719862227&quot;&gt;

&lt;p&gt;      move 是节点沿着路径平滑移动的封装函数，主要参数为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;node：&lt;/strong&gt;动画节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;path：&lt;/strong&gt;运行路径；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;direction：&lt;/strong&gt;节点朝向 forward | backward;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;animParams：&lt;/strong&gt;动画参数；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      通过绘制一条运行路线的管道，ht.Default.getLineCacheInfo() 得到这条管道的点位和分割信息 cache，然后管道信息通过 ht.Default.getLineLength() 得到管道的长度，并且通过 ht.Default.getLineOffset() 来获取连线或者管道指定比例的偏移信息，从而达到移动的效果，注意的是，这里还设定了 direction 来规定动画节点的朝向，主要是为了通过 node.lookAtX() 来获取节点下一个面对的朝向的位置信息，并设置节点此时的位置，从而达到节点沿着路径平滑移动的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
move(node, path, direction, step = 6, interval = 75&lt;span data-mce-=&quot;&quot;&gt;, animParams) {
    let cache =&lt;span data-mce-=&quot;&quot;&gt; path.__cache__;
    &lt;span data-mce-=&quot;&quot;&gt;if (!&lt;span data-mce-=&quot;&quot;&gt;cache)
        cache = path.__cache__ =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.getLineCacheInfo(path.getPoints(), path.getSegments());

    const len =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.getLineLength(cache);

    animParams = animParams ||&lt;span data-mce-=&quot;&quot;&gt; {};

    const face = direction === 'forward' ? 'front' : direction === 'backward' ? 'back'&lt;span data-mce-=&quot;&quot;&gt; : direction;
    let currentLen = 0&lt;span data-mce-=&quot;&quot;&gt;;
    const pathEndFunc =&lt;span data-mce-=&quot;&quot;&gt; animParams.pathEndFunc;
    const action =&lt;span data-mce-=&quot;&quot;&gt; animParams.action;
    animParams.action = (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;if (currentLen &amp;gt;=&lt;span data-mce-=&quot;&quot;&gt; len) {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 档 pathEndFunc 返回 true 是，认为是要结束动画, 不执行后面档 action
            &lt;span data-mce-=&quot;&quot;&gt;if (pathEndFunc &amp;amp;&amp;amp;&lt;span data-mce-=&quot;&quot;&gt; pathEndFunc())
                &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
        }
        currentLen = currentLen %&lt;span data-mce-=&quot;&quot;&gt; len;

        const offset =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.getLineOffset(cache, currentLen);
        const point =&lt;span data-mce-=&quot;&quot;&gt; offset.point;

        node.lookAtX([point.x, node.getElevation(), point.z], face);
        node.p3(point.x, node.getElevation(), point.z);

        currentLen = currentLen +&lt;span data-mce-=&quot;&quot;&gt; step;

        &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (action) action();
    };
    &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt; loop(animParams.action, interval);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      与此同时，我们还可以看到车辆行驶到车位或者离开时，车位上方的红绿灯则表示着这个车位的停放信息，是根据车辆的情况实时设定车位的状况，通过改变其信号灯 image 的 json 图标并手动刷新缓存来实现的。而缓存机制对于整体场景的流畅度是至关重要的，对于一些不必要实时刷新的面板信息，我们可以采取缓存的方式，并且在下一次更新的时候调用 Graph3dView.invalidateShape3dCachedImage(node)来手动刷新这个节点，从而大大提高了场景的性能，有关 3D 面板的属性可以参考 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html?search=invalidateCachedTexture&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;&amp;lt;HT 的 3D 手册 billboard 公告板&amp;gt;&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;updateLight(view, light, color) {
    light.s('shape3d.image', 'symbols/parking/' + color + 'Light.json'&lt;span data-mce-=&quot;&quot;&gt;);
    view.invalidateShape3dCachedImage(light);
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      IBMS 智能化集成系统管理结合数据信息、大楼模型以及每个系统的场景模型，完整地体现出一套系统之间的功能串联。在一栋大楼的功能上，每个子系统负责着各自信息数据的管理和操作，但是通过智能化集成管理系统的管理，便可将每部分子系统的数据信息汇总到一起去可视化 3D/2D 工具上完整地体现。在未来科技的进步下，也许不再需要亲临现场管理着整栋的日常运行，一套可视化的智能化集成管理系统就可以轻松解决日常维护的繁琐，充分的数据也可以实时地反映设备与大楼的关联信息。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200225200053329-1065733339.jpg&quot; alt=&quot;&quot; width=&quot;1533&quot; height=&quot;862&quot;/&gt;&lt;/div&gt;



&lt;/div&gt;</description>
<pubDate>Wed, 15 Apr 2020 15:53:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 2018年7月，信息化部印发了《工业互联网平台建设及推广指南》和《工业互联网平台评价方法》，掀起了&amp;#160;工业互联网&amp;#160;的浪潮，并成为热词写入了报告中。同为信息发展下的产物&amp;#160</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12709672.html</dc:identifier>
</item>
<item>
<title>让 .NET 轻松构建中间件模式代码（二） - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/12709603.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/12709603.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;上次实现了一个基本的构建中间件模式的中间件构建器，现在来丰富一下功能，让它支持中断和分支，分别对应 asp.net core 中的 &lt;code&gt;applicationBuilder.Run&lt;/code&gt; 和 &lt;code&gt;applicationBuilder.MapWhen&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现管道中断&quot;&gt;实现管道中断&lt;/h2&gt;
&lt;p&gt;实现中间件的中断其实很简单，通过上一次的分析我们已经知道，中间件每一个部分其实是一个上下文和 &lt;code&gt;next&lt;/code&gt; 的委托，只需要忽略 &lt;code&gt;next&lt;/code&gt;，不执行 &lt;code&gt;next&lt;/code&gt; 就可以了，就可以中断后面中间件的执行。&lt;/p&gt;
&lt;p&gt;定义一个 &lt;code&gt;Run&lt;/code&gt; 扩展方法来实现方便的实现中间件中断：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IPipelineBuilder&amp;lt;TContext&amp;gt; Run&amp;lt;TContext&amp;gt;(this IPipelineBuilder&amp;lt;TContext&amp;gt; builder, Action&amp;lt;TContext&amp;gt; handler)
{
    return builder.Use(_ =&amp;gt; handler);
}

public static IAsyncPipelineBuilder&amp;lt;TContext&amp;gt; Run&amp;lt;TContext&amp;gt;(this IAsyncPipelineBuilder&amp;lt;TContext&amp;gt; builder, Func&amp;lt;TContext, Task&amp;gt; handler)
{
    return builder.Use(_ =&amp;gt; handler);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现分支&quot;&gt;实现分支&lt;/h2&gt;
&lt;p&gt;分支的实现主要是参考 asp.net core 里 &lt;code&gt;applicationBuilder.Map&lt;/code&gt;/&lt;code&gt;applicationBuilder.MapWhen&lt;/code&gt; 实现分支路由的做法，在 asp.net core 里，&lt;code&gt;MapWhen&lt;/code&gt; 是一个扩展方法，其实现是一个 &lt;code&gt;MapWhenMiddleware&lt;/code&gt;，有兴趣可以看 asp.net core 的源码。&lt;/p&gt;
&lt;p&gt;实现原理也挺简单的，其实就是满足分支的条件时创建一个全新的中间件管道，当满足条件的时候就就执行这个分支中间件管道，否则就跳过这个分支进入下一个中间件。&lt;/p&gt;
&lt;p&gt;首先在 &lt;code&gt;PipelineBuilder&lt;/code&gt; 的接口定义中增加了一个 &lt;code&gt;New&lt;/code&gt; 方法用来创建一个全新的中间件管道，定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public interface IPipelineBuilder&amp;lt;TContext&amp;gt;
{
    IPipelineBuilder&amp;lt;TContext&amp;gt; Use(Func&amp;lt;Action&amp;lt;TContext&amp;gt;, Action&amp;lt;TContext&amp;gt;&amp;gt; middleware);

    Action&amp;lt;TContext&amp;gt; Build();

    IPipelineBuilder&amp;lt;TContext&amp;gt; New();
}

//
public interface IAsyncPipelineBuilder&amp;lt;TContext&amp;gt;
{
    IAsyncPipelineBuilder&amp;lt;TContext&amp;gt; Use(Func&amp;lt;Func&amp;lt;TContext, Task&amp;gt;, Func&amp;lt;TContext, Task&amp;gt;&amp;gt; middleware);

    Func&amp;lt;TContext, Task&amp;gt; Build();

    IAsyncPipelineBuilder&amp;lt;TContext&amp;gt; New();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现就是直接创建了一个新的 &lt;code&gt;PipelineBuilder&amp;lt;TContext&amp;gt;&lt;/code&gt; 对象，示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;internal class PipelineBuilder&amp;lt;TContext&amp;gt; : IPipelineBuilder&amp;lt;TContext&amp;gt;
{
    private readonly Action&amp;lt;TContext&amp;gt; _completeFunc;
    private readonly List&amp;lt;Func&amp;lt;Action&amp;lt;TContext&amp;gt;, Action&amp;lt;TContext&amp;gt;&amp;gt;&amp;gt; _pipelines = new List&amp;lt;Func&amp;lt;Action&amp;lt;TContext&amp;gt;, Action&amp;lt;TContext&amp;gt;&amp;gt;&amp;gt;();

    public PipelineBuilder(Action&amp;lt;TContext&amp;gt; completeFunc)
    {
        _completeFunc = completeFunc;
    }

    public IPipelineBuilder&amp;lt;TContext&amp;gt; Use(Func&amp;lt;Action&amp;lt;TContext&amp;gt;, Action&amp;lt;TContext&amp;gt;&amp;gt; middleware)
    {
        _pipelines.Add(middleware);
        return this;
    }

    public Action&amp;lt;TContext&amp;gt; Build()
    {
        var request = _completeFunc;

        for (var i = _pipelines.Count - 1; i &amp;gt;= 0; i--)
        {
            var pipeline = _pipelines[i];
            request = pipeline(request);
        }

        return request;
    }

    public IPipelineBuilder&amp;lt;TContext&amp;gt; New() =&amp;gt; new PipelineBuilder&amp;lt;TContext&amp;gt;(_completeFunc);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;异步的和同步类似，这里就不再赘述，有疑问可以直接看文末的源码链接&lt;/p&gt;
&lt;p&gt;接着就可以定义我们的分支扩展了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public static IPipelineBuilder&amp;lt;TContext&amp;gt; When&amp;lt;TContext&amp;gt;(this IPipelineBuilder&amp;lt;TContext&amp;gt; builder, Func&amp;lt;TContext, bool&amp;gt; predict, Action&amp;lt;IPipelineBuilder&amp;lt;TContext&amp;gt;&amp;gt; configureAction)
{
    return builder.Use((context, next) =&amp;gt;
    {
        if (predict.Invoke(context))
        {
            var branchPipelineBuilder = builder.New();
            configureAction(branchPipelineBuilder);
            var branchPipeline = branchPipelineBuilder.Build();
            branchPipeline.Invoke(context);
        }
        else
        {
            next();
        }
    });
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用示例&quot;&gt;使用示例&lt;/h2&gt;
&lt;p&gt;我们可以使用分支和中断来改造一下昨天的示例，改造完的示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;var requestContext = new RequestContext()
{
    RequesterName = &quot;Kangkang&quot;,
    Hour = 12,
};

var builder = PipelineBuilder.Create&amp;lt;RequestContext&amp;gt;(context =&amp;gt;
        {
            Console.WriteLine($&quot;{context.RequesterName} {context.Hour}h apply failed&quot;);
        })
        .When(context =&amp;gt; context.Hour &amp;lt;= 2, pipeline =&amp;gt;
                {
                    pipeline.Use((context, next) =&amp;gt;
                    {
                        Console.WriteLine(&quot;This should be invoked&quot;);
                        next();
                    });
                    pipeline.Run(context =&amp;gt; Console.WriteLine(&quot;pass 1&quot;));
                    pipeline.Use((context, next) =&amp;gt;
                    {
                        Console.WriteLine(&quot;This should not be invoked&quot;);
                        next();
                        Console.WriteLine(&quot;will this invoke?&quot;);
                    });
                })
        .When(context =&amp;gt; context.Hour &amp;lt;= 4, pipeline =&amp;gt;
            {
                pipeline.Run(context =&amp;gt; Console.WriteLine(&quot;pass 2&quot;));
            })
        .When(context =&amp;gt; context.Hour &amp;lt;= 6, pipeline =&amp;gt;
            {
                pipeline.Run(context =&amp;gt; Console.WriteLine(&quot;pass 3&quot;));
            })

    ;
var requestPipeline = builder.Build();
Console.WriteLine();
foreach (var i in Enumerable.Range(1, 8))
{
    Console.WriteLine($&quot;--------- h:{i} apply Pipeline------------------&quot;);
    requestContext.Hour = i;
    requestPipeline.Invoke(requestContext);
    Console.WriteLine(&quot;----------------------------&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/489462/202004/489462-20200415233834376-479237140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看输出结果我们可以看到 &lt;code&gt;Run&lt;/code&gt; 后面注册的中间件是不会执行的，&lt;code&gt;Run&lt;/code&gt; 前面注册的中间件正常执行&lt;/p&gt;
&lt;p&gt;然后定义的 &lt;code&gt;When&lt;/code&gt; 分支也是正确执行的~~&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Wed, 15 Apr 2020 15:39:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>支持中间件管道的中断和分支</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/12709603.html</dc:identifier>
</item>
<item>
<title>Git应用详解第五讲：远程仓库Github与Git图形化界面 - AhuntSun</title>
<link>http://www.cnblogs.com/AhuntSun-blog/p/12709573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AhuntSun-blog/p/12709573.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;前情提要：&lt;a href=&quot;https://www.cnblogs.com/AhuntSun-blog/p/12700155.html&quot;&gt;Git应用详解第四讲：版本回退的三种方式与stash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一节将会介绍本地仓库与远程仓库的一些简单互动以及几款常用的&lt;code&gt;Git&lt;/code&gt;图形化界面，让你更加方便地使用&lt;code&gt;git&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;一、git裸库&quot;&gt;一、&lt;code&gt;Git&lt;/code&gt;裸库&lt;/h3&gt;
&lt;p&gt;简单来说&lt;code&gt;git&lt;/code&gt;裸库就是没有工作区的&lt;code&gt;git&lt;/code&gt;仓库。比如服务器，只起到代码托管的作用而不需要也不应该修改服务器上的代码。&lt;/p&gt;
&lt;p&gt;可通过以下指令创建&lt;code&gt;git&lt;/code&gt;裸库:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git init --bare
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建完成之后，查看当前文件目录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/1.png&quot; alt=&quot;image-20200329192222085&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到并不存在工作区目录，表明&lt;code&gt;git&lt;/code&gt;裸库仅仅是用来存放和中转开发者提交的代码。&lt;/p&gt;
&lt;h3 id=&quot;二、本地仓库与远程版本库&quot;&gt;二、本地仓库与远程版本库&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;本地仓库：&lt;/strong&gt;也就是之前所讲的&lt;code&gt;git&lt;/code&gt;仓库，分为三个区：工作区，暂存区和版本库；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;远程版本库：&lt;/strong&gt;与本地版本库相对应的远程在线版本库，属于&lt;strong&gt;裸库&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们一般会在本地&lt;code&gt;git&lt;/code&gt;仓库的工作区和暂存区中对文件进行修改，然后提交到本地版本库，并最终推送到远程版本库进行托管。整个流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/2.png&quot; alt=&quot;image-20200415215625991&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;远程仓库的实质就是本地仓库中的&lt;strong&gt;版本库&lt;/strong&gt;对应的&lt;strong&gt;远程版本库&lt;/strong&gt;，通常直接叫做&lt;strong&gt;远程仓库&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;远程仓库（版本库）的存在作用为：供多台计算机间交换信息，相当于交换两个数过程中的第三方容器。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;1git-push与git-pull&quot;&gt;1.&lt;code&gt;git push&lt;/code&gt;与&lt;code&gt;git pull&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这两个命令是我们使用远程仓库时非常常用的命令，它们十分的重要：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;git push&lt;/code&gt;：将&lt;strong&gt;本地仓库某分支&lt;/strong&gt;上的代码推送到&lt;strong&gt;远程仓库的某分支&lt;/strong&gt;上；注意了，推送操作是分支对分支的，而不是将本地仓库的所有分支都推送到远程仓库，如下图所示（假设推送到远程同名分支）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/2.1.png&quot; alt=&quot;image-20200415222039765&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;git pull&lt;/code&gt;：将远程仓库文件拉取到本地版本库，也就是将本地仓库中没有的文件都拉取到本地仓库的版本库中，所以进行拉取操作后，本地仓库的工作区是干净的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/2.2.png&quot; alt=&quot;image-20200415222320473&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里的&lt;code&gt;st&lt;/code&gt;为&lt;code&gt;status&lt;/code&gt;的别名，有关别名的内容，后续会进行详细讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;push&lt;/code&gt;指令的完整写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git push origin srcBranch:destBranch
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;srcBranch&lt;/code&gt;表示的是&lt;strong&gt;本地分支&lt;/strong&gt;，&lt;code&gt;destBranch&lt;/code&gt;表示的是&lt;strong&gt;远程分支&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pull&lt;/code&gt;指令的完整写法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git pull origin srcBranch:destBranch
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;srcBranch&lt;/code&gt;表示的是&lt;strong&gt;远程分支&lt;/strong&gt;，&lt;code&gt;destBrach&lt;/code&gt;表示的是&lt;strong&gt;本地分支&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;不要混淆了，可以这样理解：&lt;code&gt;srcBranch&lt;/code&gt;表示&lt;strong&gt;从哪里来&lt;/strong&gt;，&lt;code&gt;destBranch&lt;/code&gt;表示&lt;strong&gt;到哪里去&lt;/strong&gt;；&lt;/p&gt;
&lt;h5 id=&quot;git-push的三种情况&quot;&gt;&lt;code&gt;git push&lt;/code&gt;的三种情况&lt;/h5&gt;
&lt;ul readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;情况一：&lt;/strong&gt;只有一个用户操作远程仓库时，由于本地仓库对所有的文件和操作都进行了追踪，所以即使本地仓库删除之前推送到远程仓库的文件，再次执行推送时也不需要执行&lt;code&gt;git pull&lt;/code&gt;操作。&lt;/p&gt;
&lt;p&gt;例如，远程仓库有这么些文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/3.png&quot; alt=&quot;image-20200410204056615&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在对应的本地仓库中将其他文件删除，只留下&lt;code&gt;README.md&lt;/code&gt;，此时再向该远程仓库推送。推送过程十分顺利，并不需要执行&lt;code&gt;git pull&lt;/code&gt;操作拉取合并远程仓库中的文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;情况二：&lt;/strong&gt;也是只有一个用户操作远程仓库，但是不通过本地推送来更新远程仓库，而是直接为远程仓库添加文件，比如手动添加&lt;code&gt;README.md&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个时候，由于本地仓库并没有对远程仓库中新增的&lt;code&gt;README.md&lt;/code&gt;进行追踪，所以再次推送时会出现如下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/4.png&quot; alt=&quot;image-20200410205057781&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时需要执行&lt;code&gt;git pull&lt;/code&gt;操作对远程仓库中新增的文件进行拉取、合并与追踪，之后才能进行&lt;code&gt;git push&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;情况三：&lt;/strong&gt;多人共用同一远程仓库，比如用户&lt;code&gt;A&lt;/code&gt;和&lt;code&gt;B&lt;/code&gt;，这个时候由于远程仓库上有&lt;code&gt;A&lt;/code&gt;提交的而&lt;code&gt;B&lt;/code&gt;没有的文件。所以&lt;code&gt;B&lt;/code&gt;在执行&lt;code&gt;git push&lt;/code&gt;前，要先执行&lt;code&gt;git pull&lt;/code&gt;操作，将远程仓库中这些没有的文件进行拉取、合并与追踪。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;git-pull实质&quot;&gt;&lt;code&gt;git pull&lt;/code&gt;实质&lt;/h5&gt;
&lt;p&gt;在进行拉取操作的过程中，会执行合并操作（&lt;code&gt;merge&lt;/code&gt;），合并操作可能成功也可能失败：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果&lt;code&gt;merge&lt;/code&gt;成功：说明两个人修改的不是一个文件，或者是一个文件的不同地方，这样&lt;code&gt;git&lt;/code&gt;会直接使用&lt;code&gt;Fast-forward&lt;/code&gt;方式自动合并；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;merge&lt;/code&gt;失败：说明两个人可能修改了&lt;strong&gt;同一文件&lt;/strong&gt;的&lt;strong&gt;同一行&lt;/strong&gt;，这时候就需要进行&lt;strong&gt;手动合并&lt;/strong&gt;，解决文件发生的冲突；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;合并完成之后才能进行&lt;code&gt;push&lt;/code&gt;操作，将本地仓库的代码推送到远程仓库；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pull&lt;/code&gt;操作其实是&lt;code&gt;fetch&lt;/code&gt;操作和&lt;code&gt;merge&lt;/code&gt;操作的合成：&lt;/p&gt;
&lt;h4 id=&quot;2github和gitlab&quot;&gt;2.&lt;code&gt;Github&lt;/code&gt;和&lt;code&gt;Gitlab&lt;/code&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;先有&lt;code&gt;Github&lt;/code&gt;后有&lt;code&gt;Gitlab&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Gitlab&lt;/code&gt;为内网的&lt;code&gt;Github&lt;/code&gt;，即&lt;code&gt;Gitlab&lt;/code&gt;为内网的&lt;code&gt;git&lt;/code&gt;远程服务器，代码不开源，仅供公司内网用户使用，并且可以设置管理权限。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;github&quot;&gt;&lt;code&gt;Github&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;不多介绍，世界上最大的开源及私有软件项目的托管和同性交友平台；&lt;/p&gt;
&lt;h5 id=&quot;gitlab&quot;&gt;&lt;code&gt;Gitlab&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Gitlab&lt;/code&gt;可作为内网的远程代码托管服务器，一般都是安装在&lt;code&gt;Linux&lt;/code&gt;系统上：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/5.png&quot; alt=&quot;image-20200330201124866&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;三、本地仓库---远程版本库&quot;&gt;三、本地仓库 &lt;code&gt;-&amp;gt;&lt;/code&gt; 远程版本库&lt;/h3&gt;
&lt;h4 id=&quot;1建立联系&quot;&gt;1.建立联系&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;Github&lt;/code&gt;上克隆项目时，主要可以采用两种协议：&lt;code&gt;HTTP/HTTPS&lt;/code&gt;协议和&lt;code&gt;SSH&lt;/code&gt;协议：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/6.png&quot; alt=&quot;image-20200415195835932&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当使用&lt;code&gt;HTTP/HTTPS&lt;/code&gt;协议建立本地仓库与远程仓库的联系时，不用进行任何配置，但是每次进行推送时都需要输入账号密码。而使用&lt;code&gt;SSH&lt;/code&gt;协议，只需要进行一次配置，就可以实现免密推送。&lt;/p&gt;
&lt;h5 id=&quot;httphttps协议&quot;&gt;&lt;code&gt;HTTP/HTTPS&lt;/code&gt;协议&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;克隆&lt;code&gt;Github&lt;/code&gt;上的项目时，可以采用该协议：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/7.png&quot; alt=&quot;image-20200415195957464&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;建立本地仓库与远程仓库连接时，也可以采用该协议：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;git remote add origin https://github.com/AhuntSun/test.git
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的&lt;code&gt;origin&lt;/code&gt;表示&lt;strong&gt;远程仓库&lt;/strong&gt;的意思，可以不叫这个名字，但是约定俗成叫&lt;code&gt;origin&lt;/code&gt;。执行完这条命令之后，就可以采用&lt;code&gt;origin&lt;/code&gt;来代表远程仓库的&lt;code&gt;URL&lt;/code&gt;了。&lt;/p&gt;
&lt;p&gt;但是，在进行推送时，由于&lt;code&gt;Github&lt;/code&gt;上的项目有权限管理，除了远程仓库的创立者本人，其他用户都无权进行代码的推送。所以，每次将本地仓库的代码进行推送时，都需要输入账号密码验证推送者身份。&lt;/p&gt;
&lt;h5 id=&quot;ssh协议&quot;&gt;&lt;code&gt;SSH&lt;/code&gt;协议&lt;/h5&gt;
&lt;p&gt;虽然公网上推荐使用&lt;code&gt;HTTPS&lt;/code&gt;协议进行加密传输；但是，在公司内网中只有&lt;code&gt;HTTP&lt;/code&gt;协议，每次推送代码都需要重复输入用户名和密码，比较不方便；因此，可以采用&lt;code&gt;SSH&lt;/code&gt;协议进行身份验证，过程如下：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;首先，采用&lt;code&gt;SSH&lt;/code&gt;地址关联远程仓库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/8.png&quot; alt=&quot;image-20200415200040097&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git remote add origin git@github.com:AhuntSun/test.git
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到，&lt;code&gt;Github&lt;/code&gt;已经提示我们当前&lt;code&gt;Github&lt;/code&gt;账号没有任何&lt;code&gt;SSH&lt;/code&gt;公钥。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;添加之后，查看远程仓库地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git remote show origin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/9.png&quot; alt=&quot;image-20200415200521163&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，本地仓库没有远程仓库的访问权限。这是因为我们并没有将本地的&lt;code&gt;SSH&lt;/code&gt;公钥部署到远程仓库上，为了解决这个问题，我们需要在本地生成秘钥对，并将其中的公钥部署到远程仓库上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;生成秘钥对&quot;&gt;生成秘钥对&lt;/h6&gt;
&lt;p&gt;在&lt;code&gt;.ssh&lt;/code&gt;文件夹下有一个&lt;code&gt;known_hosts&lt;/code&gt;的文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/10.png&quot; alt=&quot;image-20200328152518312&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开该文件，可以看到远程仓库&lt;code&gt;Github&lt;/code&gt;的&lt;code&gt;IP&lt;/code&gt;地址已经添加到了本地信任地址中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/11.png&quot; alt=&quot;image-20200415200922784&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，使用以下命令生成本地计算机的公钥和私钥：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ssh-keygen
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/12.png&quot; alt=&quot;image-20200328153029340&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在生成过程中，可以选择公钥和私钥的保存地址，默认是保存在&lt;code&gt;.ssh&lt;/code&gt;文件夹下的；还可以设置密码，也可以不设置，直接两次回车后成功生成公钥和私钥；&lt;/p&gt;
&lt;p&gt;可以看到&lt;code&gt;.ssh&lt;/code&gt;文件夹下多了两个文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/13.png&quot; alt=&quot;image-20200328153154037&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;code&gt;id_rsa&lt;/code&gt;表示私钥，&lt;code&gt;id_rsa.pub&lt;/code&gt;表示公钥，我们可以分别查看一下它们的内容:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/14.png&quot; alt=&quot;image-20200328153258023&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/15.png&quot; alt=&quot;image-20200328153328042&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;部署公钥&quot;&gt;部署公钥&lt;/h6&gt;
&lt;p&gt;接着我们要做的就是把生成的公钥部署到远程仓库&lt;code&gt;Github&lt;/code&gt;上，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/16.png&quot; alt=&quot;image-20200328153538328&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在该界面中可以添加多个公钥，如果项目组会有多个成员，或者一个人使用多台电脑时可以设置多个公钥：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/17.png&quot; alt=&quot;image-20200328154605789&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，可以自定义公钥的名字。注意：一定要勾选&lt;code&gt;Allow write access&lt;/code&gt;选项，否则无法将本地仓库代码推送到该远程仓库。并且，添加时需要输入&lt;code&gt;Github&lt;/code&gt;账号密码进行确认：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/18.png&quot; alt=&quot;image-20200328153903341&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加完成后，就可以在原来的界面看到新增的公钥了。这样使用该公钥的本地计算机就具有了读写这个远程仓库的权限了；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/19.png&quot; alt=&quot;image-20200328154723134&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成公钥的部署后，就可以成功地查看远程仓库的地址了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/20.png&quot; alt=&quot;image-20200415204247670&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际开发中，通常会使用&lt;code&gt;SSH&lt;/code&gt;协议进行本地仓库与远程仓库的连接。因为只需要配置一次公钥，就可以进行免密推送，十分方便；&lt;/p&gt;
&lt;h5 id=&quot;添加账户ssh&quot;&gt;添加账户&lt;code&gt;SSH&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;之前在&lt;code&gt;Github&lt;/code&gt;上的&lt;code&gt;test&lt;/code&gt;仓库中添加了一把&lt;code&gt;SSH&lt;/code&gt;公钥，但是该&lt;code&gt;SSH KEY&lt;/code&gt;仅限于本地与&lt;code&gt;test&lt;/code&gt;仓库的通信，不能在其他仓库中使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/21.png&quot; alt=&quot;image-20200415204439936&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们想要让&lt;code&gt;Github&lt;/code&gt;上的所有仓库都使用同一把&lt;code&gt;SSH KEY&lt;/code&gt;，就需要配置针对账号的&lt;code&gt;SSH KEY&lt;/code&gt;了。点击&lt;code&gt;Github&lt;/code&gt;右上角的&lt;code&gt;Settings&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/22.png&quot; alt=&quot;image-20200329193849833&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在该界面可以新建全局的&lt;code&gt;SSH KEY&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/23.png&quot; alt=&quot;image-20200329194410138&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2推送代码&quot;&gt;2.推送代码&lt;/h4&gt;
&lt;p&gt;建立了本地仓库与远程仓库的联系之后，就可以将本地仓库的文件推送到远程仓库了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git push -u origin master
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述指令表示将本地的&lt;code&gt;master&lt;/code&gt;分支推送到远程仓库的&lt;code&gt;master&lt;/code&gt;分支上，加上&lt;code&gt;-u&lt;/code&gt;表示将本地的&lt;code&gt;master&lt;/code&gt;分支与远程的&lt;code&gt;master&lt;/code&gt;分支&lt;strong&gt;建立关联&lt;/strong&gt;；再次推送时就可以直接通过&lt;code&gt;git push&lt;/code&gt;进行推送了。&lt;/p&gt;
&lt;h4 id=&quot;3查看远程仓库地址&quot;&gt;3.查看远程仓库地址&lt;/h4&gt;
&lt;p&gt;可以通过以下三种方法查看所有与本地仓库关联的远程仓库的地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;git remote //只显示远程仓库地址名
git remote -v //显示远程仓库地址名和对应URL
git remote show origin//显示详细信息
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/24.png&quot; alt=&quot;image-20200407221734277&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在通过&lt;code&gt;git remote show origin&lt;/code&gt;显示的详细信息中：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Fetch URL&lt;/code&gt;：表示拉取文件到本地的远程仓库的&lt;code&gt;URL&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Push URL&lt;/code&gt;：表示推送时的远程仓库的&lt;code&gt;URL&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以看到进行&lt;code&gt;git pull&lt;/code&gt;和&lt;code&gt;git push&lt;/code&gt;操作时，本地与远程分支之间是一一对应的关系；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;4修改远程仓库地址&quot;&gt;4.修改远程仓库地址&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法一&lt;/strong&gt;：删除原有地址，再添加新的&lt;code&gt;URL&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;git remote rm origin
git remote add origin https://gitee.com/ahuntsun/gitTest.git
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法二&lt;/strong&gt;：修改原有的远程仓库&lt;code&gt;URL&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;git remote set-url origin https://163.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;方法三&lt;/strong&gt;：直接修改&lt;code&gt;.git&lt;/code&gt;仓库的&lt;code&gt;config&lt;/code&gt;文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/25.png&quot; alt=&quot;image-20200328063634159&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不建议使用这种方法，&lt;strong&gt;建议使用命令行修改&lt;/strong&gt;。手动修改时，可能只是修改了一部分（不全）。这样可能会造成一些无法维护的情况；&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;尽量避免直接手动操作文件，对于常见的，合理的操作&lt;code&gt;git&lt;/code&gt;都提供了相应的指令，使用这些指令更加安全和高效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于&lt;code&gt;git&lt;/code&gt;来说，默认情况下，它的&lt;strong&gt;远程仓库&lt;/strong&gt;的地址都叫&lt;code&gt;origin&lt;/code&gt;；当需要为本地仓库添加多个远程仓库地址时，可通过以下方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git remote add newOrigin https://biliwa.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/26.png&quot; alt=&quot;image-20200328145720489&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过，在将本地仓库的文件推送到不同的远程仓库时，需要重新建立关联：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; git push -u newOrigin master
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与远程仓库的相关分支建立关联后，可直接使用&lt;code&gt;git push&lt;/code&gt;进行推送（简写的原理将在下一节进行讲解）。&lt;/p&gt;
&lt;h3 id=&quot;四、git图形化界面&quot;&gt;四、&lt;code&gt;Git&lt;/code&gt;图形化界面&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Git&lt;/code&gt;图形化界面非常之多，各种图形化界面的操作不尽相同。但是，它们的实质都是一样的。都是通过执行一条条&lt;code&gt;Git&lt;/code&gt;命令，来实现图形化界面中的各种操作。因此，在熟练掌握&lt;code&gt;Git&lt;/code&gt;底层操作命令的前提下，再使用&lt;code&gt;Git&lt;/code&gt;图形化界面会更加得心应手。因此，十分不建议初学者直接从&lt;code&gt;Git&lt;/code&gt;图形化界面入门。&lt;/p&gt;
&lt;p&gt;下面简单介绍比较常见的四种&lt;code&gt;Git&lt;/code&gt;图形化界面，分别是：&lt;code&gt;gitk&lt;/code&gt;、&lt;code&gt;Git Gui&lt;/code&gt;、&lt;code&gt;Github DeskTop&lt;/code&gt;和&lt;code&gt;SourceTree&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;1gitk&quot;&gt;1.&lt;code&gt;gitk&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;gitk&lt;/code&gt;是&lt;code&gt;git&lt;/code&gt;自带的图形化界面，输入命令：&lt;code&gt;gitk&lt;/code&gt;，就可以打开下图所示的图形化界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/27.png&quot; alt=&quot;image-20200329103724204&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;gitk&lt;/code&gt;图形化界面中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/28.png&quot; alt=&quot;image-20200329104548998&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该界面很好地展示了&lt;strong&gt;&lt;code&gt;git&lt;/code&gt;合并的原则&lt;/strong&gt;：&lt;strong&gt;三方合并&lt;/strong&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/29.png&quot; alt=&quot;image-20200329104940260&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;append 1&lt;/code&gt;和&lt;code&gt;append 2&lt;/code&gt;两次提交的合并过程为：找到它们公共的父节点&lt;code&gt;add a hello&lt;/code&gt;，然后在该节点的基础上合并两个节点，得到合并后的&lt;code&gt;master&lt;/code&gt;节点。该节点有两个&lt;code&gt;parent&lt;/code&gt;指针，分别指向&lt;code&gt;append 1&lt;/code&gt;和&lt;code&gt;append 2&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gitk&lt;/code&gt;界面的下半部分如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/30.png&quot; alt=&quot;image-20200329105310417&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上图的&lt;code&gt;SHA1 ID&lt;/code&gt;表示每次提交的识别码，也就是&lt;code&gt;commit_id&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Author&lt;/code&gt;和&lt;code&gt;Committer&lt;/code&gt;分别表示代码的作者和代码的提交者，一般情况下二者是同一人；但是在一些开源项目中，代码的作者是没有权力提交代码的（如&lt;code&gt;Github&lt;/code&gt;）。只能提交一个补丁&lt;code&gt;issue&lt;/code&gt;，待开源项目作者同意修改后，才会由项目作者代替代码作者提交代码；&lt;/li&gt;
&lt;li&gt;再下面的就是各个文件修改的详细信息；如下图所示，&lt;code&gt;Parent&lt;/code&gt;表示的是上一次提交，&lt;code&gt;Child&lt;/code&gt;表示的是下一次提交：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/31.png&quot; alt=&quot;image-20200329105659158&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/32.png&quot; alt=&quot;image-20200329105824734&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2git-gui&quot;&gt;2.&lt;code&gt;Git Gui&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Git Gui&lt;/code&gt;同样也是&lt;code&gt;git&lt;/code&gt;内置的图形化界面，输入&lt;code&gt;git gui&lt;/code&gt;命令便可打开：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/33.png&quot; alt=&quot;image-20200329110131346&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Unstaged Changes&lt;/code&gt;：表示未添加到暂存区的文件或改动，即工作区文件；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Staged Changes&lt;/code&gt;：表示暂存区中的文件或改动，即将被提交；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Modified,not stage&lt;/code&gt;：表示文件已修改但未被纳入暂存区；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/34.png&quot; alt=&quot;image-20200329110304513&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;git add .&lt;/code&gt;可将所有改动纳入暂存区：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/35.png&quot; alt=&quot;image-20200329110610386&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完上述指令后，再次查看&lt;code&gt;Git Gui&lt;/code&gt;会发现，文件转移到了&lt;code&gt;Stage Changes&lt;/code&gt;区域中。随后可以直接在&lt;code&gt;Git Gui&lt;/code&gt; 界面进行提交，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/36.png&quot; alt=&quot;image-20200329110714387&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Git Gui&lt;/code&gt;中的每一步操作，实际上都是通过命令行中的一条条指令实现的。除此之外，&lt;code&gt;Git Gui&lt;/code&gt;的菜单栏还提供了很多功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/37.png&quot; alt=&quot;image-20200329111217827&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;3github-desktop&quot;&gt;3.&lt;code&gt;Github DeskTop&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这是&lt;code&gt;Github&lt;/code&gt;的客户端应用程序，同样属于&lt;code&gt;Git&lt;/code&gt;图形化界面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/38.png&quot; alt=&quot;image-20200329111727510&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在界面的&lt;code&gt;File&lt;/code&gt;选项中可以添加一个本地仓库进行管理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/39.png&quot; alt=&quot;image-20200329111945655&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/40.png&quot; alt=&quot;image-20200329112002719&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加后可以查看该本地仓库的提交历史和其他相关信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/41.png&quot; alt=&quot;image-20200329112057396&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;4sourcetree&quot;&gt;4.&lt;code&gt;Sourcetree&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;这是一个比较受欢迎的&lt;code&gt;Git&lt;/code&gt;图形化界面，官方网址为：&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;https://www.sourcetreeapp.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/42.png&quot; alt=&quot;image-20200415112533399&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装时需要注册一个账号：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/43.png&quot; alt=&quot;image-20200415210504189&quot;/&gt;&lt;/p&gt;
&lt;p&gt;安装完成后，就可以使用了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ahuntsun.gitee.io/blogimagebed/img/git/lesson5/44.png&quot; alt=&quot;image-20200415232345617&quot;/&gt;&lt;/p&gt;
&lt;p&gt;功能十分强大，使用起来也十分地方便，这里就不详细介绍了，有兴趣的可以查阅网上的资料。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;以上就是本节的全部内容，本节简单地介绍了使用&lt;code&gt;Git&lt;/code&gt;实现本地仓库与远程仓库的互动，以及四种常见的&lt;code&gt;Git&lt;/code&gt;图形化操作界面。看到这里相信你已经对本地仓库与远程仓库的关系有了一定的认识，并且会抱有不少的疑问。没关系，在下一节当中，将会详细地为你介绍如何使用远程仓库进行多人协作开发，我们下一节再见！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 15 Apr 2020 15:35:00 +0000</pubDate>
<dc:creator>AhuntSun</dc:creator>
<og:description>前言 前情提要： &amp;quot;Git应用详解第四讲：版本回退的三种方式与stash&amp;quot; 这一节将会介绍本地仓库与远程仓库的一些简单互动以及几款常用的 图形化界面，让你更加方便地使用 。 一、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AhuntSun-blog/p/12709573.html</dc:identifier>
</item>
<item>
<title>【高并发】在高并发环境下该如何构建应用级缓存？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/12709316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/12709316.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;随着我们的系统负载越来越高，系统的性能就会有所下降，此时，我们可以很自然地想到使用缓存来解决数据读写性能低下的问题。但是，立志成为资深架构师的你，是否能够在高并发环境下合理并且高效的构建应用级缓存呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;缓存命中率&quot;&gt;缓存命中率&lt;/h2&gt;
&lt;p&gt;缓存命中率是从缓存中读取数据的次数与总读取次数的比率，命中率越高越好。缓存命中率=从缓存中读取次数 / (总读取次数 (从缓存中读取次数 + 从慢速设备上读取次数))。这是一个非常重要的监控指标，如果做缓存，则应通过监控这个指标来看缓存是否工作良好。&lt;/p&gt;
&lt;h2 id=&quot;缓存回收策略&quot;&gt;缓存回收策略&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.基于空间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于空间指缓存设置了存储空间，如设置为10MB，当达到存储空间上限时，按照一定的策略移除数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.基于容量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基于容量指缓存设置了最大大小，当缓存的条目超过最大大小时，按照一定的策略移除旧数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.基于时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TTL(Time To Live):存活期，即缓存数据从创建开始直到到期的一个时间段（不管在这个时间段内有没有被访问，缓存数据都将过期）。&lt;br/&gt;TTI(Time To Idle)：空闲期，即缓存数据多久没被访问后移除缓存的时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.基于对象引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软引用：如果一个对象是软引用，则当JVM堆内存不足时，垃圾回收器可以回收这些对象。软引用适合用来做缓存，从而当JVM堆内存不足时，可以回收这些对象腾出一些空间供强引用对象使用，从而避免OOM。&lt;br/&gt;弱引用：当垃圾回收器回收内存时，如果发现弱引用，则将它立即回收。相对于软引用，弱引用有更短的生命周期。&lt;/p&gt;
&lt;p&gt;注意：只有在没有其他强引用对象引用弱引用/软引用对象时，垃圾回收时才回收该引用。即如果有一个对象（不是弱引用/软引用对象）引用了弱引用/软引用对象，那么垃圾回收时不会回收该弱引用/软引用对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.回收算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用基于空间和基于容量的缓存会使用一定的策略移除旧数据，常见的如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FIFO(First In First Out)：先进先出算法，即先放入缓存的先被移除。&lt;/li&gt;
&lt;li&gt;LRU(Least Recently Used)：最近最少使用算法，时间时间距离现在最久的那个被移除。&lt;/li&gt;
&lt;li&gt;LFU(Least Frequently Used)：最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实际应用中基于LRU的缓存居多。&lt;/p&gt;
&lt;h2 id=&quot;缓存类型&quot;&gt;缓存类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;堆内存：&lt;/strong&gt; 使用Java堆内存来存储对象。使用堆缓存的好处是没有序列化/反序列化，是最快的缓存。缺点也很明显，当缓存的数据量很大时，GC（垃圾回收）暂停时间会变长，存储容量受限于堆空间大小。一般通过软引用/弱引用来存储缓存对象。即当堆内存不足时，可以强制回收这部分内存释放堆内存空间。一般使用堆缓存存储较热的数据。可以使用Guava Cache、Ehcache 3.x、 MapDB实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆外内存：&lt;/strong&gt; 即缓存数据存储在堆外内存，可以减少GC暂停时间（堆对象转移到堆外，GC扫描和移动的对象变少了），可以支持更多的缓存空间（只受机器内存大小限制，不受堆空间的影响）。但是，读取数据时需要序列化/反序列化。因此，会比堆缓存慢很多。可以使用Ehcache 3.x、 MapDB实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;磁盘缓存：&lt;/strong&gt; 即缓存数据存储在磁盘上，在JVM重启时数据还存在，而堆/堆外缓存数据会丢失，需要重新加载。可以使用Ehcache 3.x、MapDB实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分布式缓存：&lt;/strong&gt; 分布式缓存可以使用ehcache-clustered(配合Terracotta server)实现Java进程间分布式缓存。也可以使用Memcached、Redis实现。&lt;/p&gt;
&lt;h2 id=&quot;缓存模式&quot;&gt;缓存模式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;单机模式：&lt;/strong&gt; 存储最热的数据到堆缓存，相对热的数据到堆外缓存，不热的数据到磁盘缓存。&lt;br/&gt;&lt;strong&gt;集群模式：&lt;/strong&gt; 存储最热的数据到堆缓存，相对热的数据到对外缓存，全量数据到分布式缓存。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发编程技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，附上并发编程需要掌握的核心技能知识图，祝大家在学习并发编程时，少走弯路。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200415225306790.jpg&quot; alt=&quot;sandahexin_20200322&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Apr 2020 14:58:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 随着我们的系统负载越来越高，系统的性能就会有所下降，此时，我们可以很自然地想到使用缓存来解决数据读写性能低下的问题。但是，立志成为资深架构师的你，是否能够在高并发环境下合理并且高效的构建应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/12709316.html</dc:identifier>
</item>
<item>
<title>物联网海量设备心跳注册，脱网清除——多线程高并发互斥锁落地 - JerryMouseLi</title>
<link>http://www.cnblogs.com/JerryMouseLi/p/12709048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JerryMouseLi/p/12709048.html</guid>
<description>&lt;p&gt;在物联网应用场景中，需要维护很多个设备的连接，比如基于TCP socket通信的长连接，目的是为了获取设备采集的信息，反向控制设备的数字开关或者模拟量。我们把这些TCP长连接都放入了基于线程安全的ConcurrentDictionary激活字典表中，IP地址作为key，设备箱领域模型作为value。我们需要把激活设备箱的字典表维护好，需要将超时没有心跳的设备，我们可以称之为脱网设备，给清理出激活字典表，写入到脱网告警字典表中去。当脱网设备下次再有心跳时，可以再次移入到激活字典表中，从而再产生恢复告警，进行一系列其他动作。&lt;/p&gt;

&lt;h2 id=&quot;21心跳注册框架&quot;&gt;2.1.心跳注册框架&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202004/1606616-20200415222129609-1018598607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;211海量设备&quot;&gt;2.1.1.海量设备&lt;/h3&gt;
&lt;p&gt;因为要模拟海量设备的TCP场景，我们利用模拟器生成了12000台模拟设备。8台真实设备。&lt;/p&gt;
&lt;h3 id=&quot;212心跳上报handler流程&quot;&gt;2.1.2.心跳上报Handler流程&lt;/h3&gt;
&lt;p&gt;详细心跳上报流程详见上述框架图&lt;/p&gt;
&lt;p&gt;突然发现我可以写一个物联网的采集系统的系列了，组织一个目录。希望自己坚持下去吧。&lt;/p&gt;
&lt;h2 id=&quot;22脱网清理框架&quot;&gt;2.2.脱网清理框架&lt;/h2&gt;
&lt;h3 id=&quot;221激活字典表清理脱网设备方法&quot;&gt;2.2.1.激活字典表清理脱网设备方法&lt;/h3&gt;
&lt;p&gt;原理很简单，遍历字典表中超过设置的检测周期，筛选到一个字典的IEnumerable中去，然后在激活字典表中删除对应超时key（这里就是指IP地址）即可。当然这里的_internal周期可以*N，多个周期，自行在配置文件中设置即可，配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &quot;ipboxNumStaticInternal&quot;: 12
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public static void DeleteDeadBoxFromActiveBox(in _internal)
    {
        {
            var outTime = DateTime.Now.AddSeconds(-_internal);
            var iboxTimeOutList = iboxActiveDictionary.Where(q =&amp;gt; (outTime &amp;gt; q.Value.UpdateTime));//.Select(x=&amp;gt; iboxActiveDictionary[x.Key]) ;
            foreach (var item in iboxTimeOutList)
            {
                iboxActiveDictionary.Remove(item.Key);
            }               
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;222脱网清理流程图&quot;&gt;2.2.2.脱网清理流程图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202004/1606616-20200415222157146-1965827432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里主要开启了一个系统定时器，主动会去调用清理脱网设备方法，调用时间间隔即ipboxNumStaticInternal。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void systemTimerStart()
    {
        var interval = ReadTheInternalFromSetting();
        _systemTimer = new Timer(state =&amp;gt;
        {               
            IBoxActiveDicManager.DeleteDeadBoxFromActiveBo(_internal);
            Console.WriteLine(&quot;{1},激活设备数量：{0}\n&quot;,IBoxActiveDicManager.iboxActiveDictionary.Count,DateTime.Now);
        }, null, interval, interval);
        Console.WriteLine(&quot;PemsCom采集系统时钟已经开启&quot;);
        LoggerHelper.Info(&quot;PemsCom采集系统时钟已经开启&quot;);
    }

    /// &amp;lt;summary&amp;gt;
    /// 配置文件读入时间间隔方法
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private int ReadTheInternalFromSetting()
    {
        _internal = int.Parse(Appsettings.app(new string[] {&quot;ipboxNumStaticInternal&quot; }));
        Console.WriteLine(&quot;PemsCom采集系统时钟配置参数已经读&quot;);
        LoggerHelper.Info(&quot;PemsCom采集系统时钟配置参数已经读&quot;);
        return Convert.ToInt32(TimeSpan.FromSecond(_internal).TotalMilliseconds);
    }

&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;31多线程说明&quot;&gt;3.1.多线程说明&lt;/h2&gt;
&lt;p&gt;这里会有很多的线程让CPU来轮片执行，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;12008个Receive事件触发线程；&lt;/li&gt;
&lt;li&gt;定时清除脱网设备线程；&lt;/li&gt;
&lt;li&gt;主线程，监控命令行输入，并执行对应的命令；&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;举个实际的例子，以图为证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202004/1606616-20200415222201379-1160988575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;12008台设备，每秒处理接受网络包的峰峰值是9218个包，就是在某一秒，CPU共轮片执行了9218个线程。比如是双核4线程的，则9218/4=2304.5。即CPU在1秒轮片执行了2305次。即0.43毫秒就轮片执行一次。&lt;/p&gt;
&lt;h2 id=&quot;32高并发说明&quot;&gt;3.2.高并发说明&lt;/h2&gt;
&lt;p&gt;其实3.1已经解释了高并发。在某一秒，需要处理的接收事件有接近1万件。而这一时刻的执行顺序是无序的，9218里的这么多线程，我们不知道哪个先执行，哪个后执行。如果不认为地加一些逻辑控制，比如我们今天要介绍的互斥锁，就会出现一些异常现象。&lt;/p&gt;

&lt;p&gt;这里只描述现象，原因会在下面5.分析异常原因 做具体描述。&lt;/p&gt;
&lt;h2 id=&quot;41空引用&quot;&gt;4.1.空引用&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202004/1606616-20200415222205030-1468276891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;异常所在的位置：心跳处理类如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class HeartHandler
    {
        static string _deviceIndex = Appsettings.app(new string[] { &quot;DeviceIndex&quot; });
        private static IBoxActive iboxActive;
        public static void Register(TcpHeartPacket heartPacket,int sessId)
        {
            UInt32 IP;
            UInt64 mac;
            if (_deviceIndex == &quot;IP&quot;)
            {
         
                IP =(UInt32)BitConverter.ToUInt32(heartPacket.IP, 0);
                if (IBoxActiveDicManager.GetBoxActive(IP, out iboxActive) != true)
                {       
                    IBoxActiveDicManager.iboxActiveDictionary.TryAdd(IP, iboxActive);
                    iboxActive.SessID = sessId;
                }
               
            }
            else
            {
                 mac = (UInt64)BitConverter.ToUInt64(heartPacket.Mac, 0);
                if (IBoxActiveDicManager.GetBoxActive(mac, out iboxActive) != true)
                {
                    IBoxActiveDicManager.iboxActiveDictionary.TryAdd(mac, iboxActive);
                    iboxActive.SessID = sessId;
                }
            }

            //引用类型，智能指针，使用方便
            iboxActive.UpdateTime = DateTime.Now;

           
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;42字典表里元素赋值不成功&quot;&gt;4.2.字典表里元素赋值不成功&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202004/1606616-20200415222208866-254039859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 查询激活设备箱字典中是否有存在上报的设备箱,
        /// 存在返回true，不存在返回false，并且新建好设备箱模型
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;mac&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;iboxActive&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static bool GetBoxActive(UInt32 IP, out IBoxActive iboxActive)
        {
 
            if (iboxActiveDictionary.TryGetValue(IP, outiboxActive))
            {
                return true;
            }
            
            iboxActive = new IBoxActive();
           
            iboxActive.IP = IP;

            if (iboxActive.IP != IP)
            {
                LoggerHelper.Error(string.Format(&quot;实例化赋值不成功.iboxActive.IP:{0};IP{1}&quot;, iboxActive.IP, IP));
            }

            return false;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有没有感觉很奇怪，上一句都赋值了，下一句对比就不相等。但是在多线程大并发里就是有这种可能，下面会详细分析。&lt;/p&gt;
&lt;h2 id=&quot;43统计设备总数不正确&quot;&gt;4.3.统计设备总数不正确&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1606616/202004/1606616-20200415222211934-984700083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为12008台大并发时很容易出错，所以改成了1000台。如下统计数据会有出错情况，这同样也是因为多线程高并发引起的错误。&lt;/p&gt;

&lt;h2 id=&quot;51造成空引用的原因&quot;&gt;5.1.造成空引用的原因&lt;/h2&gt;
&lt;p&gt;其实第4的三点原因都是同一个原因造成，所以在5.1会详细阐述，5.2，,5.3只做简单阐述。这里敲下黑板，&lt;span&gt;分析多线程高并发的异常问题，程序运行的特点就是见缝就插，就像个老司机一样，概括起来就是线程与线程之间的无序性&lt;/span&gt;。比如我们设备心跳线程正在更新设备心跳时间的时候。脱网清理线程就把该设备给清理掉了。如此一来，时间没法赋值给空对象（已被脱网线程给清理）。因此只能报空引用异常，对没错，就是这么简单，耗费了我很长时间去debug跟思考这个异常。&lt;/p&gt;
&lt;h2 id=&quot;52设备ip赋值不成功原因&quot;&gt;5.2.设备IP赋值不成功原因&lt;/h2&gt;
&lt;p&gt;同样，在创建了设备实例之后，IP赋值完成，刚好脱网清除设备线程运行清除了设备，当对比的时候，引用原来的地址，字典的原来地址已经存了其他设备箱的IP，所以IP地址不相等。&lt;/p&gt;
&lt;h2 id=&quot;53统计设备总数不正确原因&quot;&gt;5.3.统计设备总数不正确原因&lt;/h2&gt;
&lt;p&gt;原因其实是5.2造成的，没法成功注册，当然数量就不对啦。&lt;/p&gt;

&lt;p&gt;就是当我在创建激活设备实例（第一次心跳注册）或者更新心跳时间的时候（非第一次注册），不要让无序的脱网清除线程运行。敲黑板:&lt;span&gt;就是保证心跳处理注册过程的原子性&lt;/span&gt;。对，其实这里很像关系型数据库的事务，原子性。原子性就是对抗程序无序造成异常的有力武器。我们可以在注册心跳处理方法上加个互斥锁，让编译器跟运行时去安排更加合理的执行顺序。&lt;/p&gt;

&lt;p&gt;代码很简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //定义一把锁
    public static Mutex activeIpboxDicMutex = new Mutex();
    //设备箱注册加锁。异常全部消除
    IBoxActiveDicManager.activeIpboxDicMWaitOne();
    HeartHandler.Register(tcpHeartPacsessionId);
    IBoxActiveDicManager.activeIpboxDicMReleaseMutex();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里插入一下事务的使用，也是很类似的，把我们的主业务加中中间，类比方便大家理解记忆。就像夹心饼干（瞎扯）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            unitOfWork.BeginTransaction();

            // Adds new device
            unitOfWork.DeviceRepository.Add(device);

            // Commit transaction
            unitOfWork.Commit();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也可以给设备箱脱网清除线程加锁。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     IBoxActiveDicManager.activeIpboxDicMutex.WaitOne();
     IBoxActiveDicManager.DeleteDeadBoxFromActiveBox(_internal);
     IBoxActiveDicManager.activeIpboxDicMutex.ReleaseMutex();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;考虑到脱网清除线程会损耗部分性能，我也测试了去掉该锁的情况，也不会有第4的3个异常，至此问题全部解决。&lt;/p&gt;

&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;模拟设备数量小测不出这个问题，如此看出海量设备的重要性，因为现实情况肯定会出现以上三个问题，而且都是很严重很致命的问题。好的测试方法可以把问题扼杀在摇篮中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;多线程高并发时容易出现这样那样的异常，要怀着敬畏之心去思考，去解决问题；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;https://www.cnblogs.com/JerryMouseLi/p/12709048.html&quot;&gt;https://www.cnblogs.com/JerryMouseLi/p/12709048.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 Apr 2020 14:29:00 +0000</pubDate>
<dc:creator>JerryMouseLi</dc:creator>
<og:description>物联网海量设备心跳注册，脱网清除——多线程高并发互斥锁落地 [toc] 1.应用背景 在物联网应用场景中，需要维护很多个设备的连接，比如基于TCP socket通信的长连接，目的是为了获取设备采集的信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JerryMouseLi/p/12709048.html</dc:identifier>
</item>
<item>
<title>【C#】写一个支持多人聊天的TCP程序 - 巴塞罗那的余晖</title>
<link>http://www.cnblogs.com/robotpaul/p/12709022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/robotpaul/p/12709022.html</guid>
<description>&lt;p&gt;使用c#平台的winform编写一个tcp多人聊天程序，包括一对一、广播。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;221&quot;&gt;

&lt;p&gt;先谈谈我们要实现的效果：客户端可以选择要聊天的对象，或者直接广播消息（类似QQ的私聊和群消息）&lt;/p&gt;
&lt;p&gt;那么，该如何实现呢？&lt;/p&gt;
&lt;p&gt;首先明确的是，要分客户端和服务器端两个部分（&lt;span&gt;废话&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;客户端：选择要发送的对象，发送信息。同时有一个线程在监听是否收到新的信息。&lt;/p&gt;
&lt;p&gt;服务器端：负责转发收到的消息，并负责管理所有接入的连接&lt;/p&gt;
&lt;p&gt;好了有了大体思路后，开始编程吧~&lt;/p&gt;

&lt;h2&gt;界面设计&lt;/h2&gt;
&lt;p&gt;客户端要提供的信息主要是发送对象、发送信息内容，故设计如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1539811/202004/1539811-20200415212636986-1987490673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中用户名必须提供（这里考虑的比较简单，不需要验证用户名是否重复），发送信息时需要选择目标用户。&lt;/p&gt;
&lt;h2&gt;编码实现&lt;/h2&gt;
&lt;h3&gt;连接服务器部分&lt;/h3&gt;
&lt;p&gt;连接服务器和正常的tcp连接没什么区别，由于要考虑到 目标用户 选项刷新的问题，这里必须在建立连接后向服务器发送一条信息告知服务器自己的身份，服务器接收后会再返回一条信息来告知客户端目前服务器在线用户的名称。&lt;/p&gt;
&lt;p&gt;因为请求的信息内容、作用不一样，这里使用自定义的“信息格式”，使用$符号来分割，请求格式为 code$message&lt;/p&gt;
&lt;p&gt;以下是请求的说明表&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1539811/202004/1539811-20200415213358086-283022769.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;故我们可以根据该表写出一个Encode函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; String EncodeMessage(String message, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; code,String goalName)
        {
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (code)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;汇报用户名&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; message;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送信息&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + message+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;goalName;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;断开连接&lt;/span&gt;
                    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; message;
                &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-1$错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;紧接着对其进行发送信息功能进行封装:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; SendMessage(String message, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; code, String goalName)
        {
            String sendmessage &lt;/span&gt;=&lt;span&gt; EncodeMessage(message, code, goalName);
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                bw.Write(sendmessage);
                bw.Flush();
                log &lt;/span&gt;= DateUtil.getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;发送信息：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + message;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;日志&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (code != &lt;span&gt;1&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1是第一次建立连接的时候发送的自己用户名，所以没必要打印出来，故这里加了一个判断&lt;/span&gt;
&lt;span&gt;                {
                    textbox_chatbox.AppendText(log);

                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    flag_open &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该标志是用来控制接收信息的循环的，下面再讲&lt;/span&gt;
&lt;span&gt;                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;捕获异常是为了防止服务器意外断开连接&lt;/span&gt;
&lt;span&gt;            {
                log &lt;/span&gt;= DateUtil.getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务器已断开连接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }
        }                &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了下面开始主体tcp连接代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;全局变量声明    &lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; port = &lt;span&gt;8848&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; TcpClient tcpClient;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; NetworkStream networkStream;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BinaryReader br;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BinaryWriter bw;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; String log = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Boolean flag_open = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;    

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
           &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button_connect_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开始连接服务器，同步方式阻塞进行&lt;/span&gt;
&lt;span&gt;
            IPHostEntry remoteHost &lt;/span&gt;=&lt;span&gt; Dns.GetHostEntry(textbox_ip.Text);
            tcpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TcpClient();
            tcpClient.Connect(remoteHost.HostName, port);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞啦！！！&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (tcpClient != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                String username &lt;/span&gt;=&lt;span&gt; textBox_name.Text;
                log &lt;/span&gt;= DateUtil.getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;以用户名为 &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+username+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接服务器&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                textbox_chatbox.AppendText(log);
                networkStream &lt;/span&gt;=&lt;span&gt; tcpClient.GetStream();
                br &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryReader(networkStream);
                bw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryWriter(networkStream);
                SendMessage(username, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向服务器发送信息，告诉服务器自己的用户名&lt;/span&gt;
&lt;span&gt;                
                Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(ReceiveMessage);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开一个新的线程来接收信息&lt;/span&gt;
&lt;span&gt;                thread.Start();
                thread.IsBackground &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程自动关闭&lt;/span&gt;
&lt;span&gt;            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                log &lt;/span&gt;= DateUtil.getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;连接服务器失败，请重试&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                textbox_chatbox.AppendText(log);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;接收信息部分&lt;/h3&gt;
&lt;p&gt; 为了程序的人性化，接收信息一定是自动接收，这里使用线程来实现。因为接收信息也是阻塞，故新开一个线程并使用while循环一直监听，有消息进来就更新。&lt;/p&gt;
&lt;p&gt; 因此我们也需要规定服务器发过来的信息的格式，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1539811/202004/1539811-20200415214455508-1926010561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 因此同样我们可以写出解析函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; DecodeMessage(String message)
        {
            String[] results &lt;/span&gt;= message.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; code = &lt;span&gt;int&lt;/span&gt;.Parse(results[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
            &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (code)
            {
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新的是用户&lt;/span&gt;
                    comboBox1.Invoke(updateComboBox, message);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;委托，更新下拉框内容&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;收到信息&lt;/span&gt;
                    String rev = message.Substring(message.IndexOf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
                    textbox_chatbox.Invoke(showLog,DateUtil.getTime()&lt;/span&gt;+rev);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印在日志&lt;/span&gt;
                    &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
           
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接收信息函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ReceiveMessage()
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (flag_open)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; rcvMsgStr =&lt;span&gt; br.ReadString();
                    DecodeMessage(rcvMsgStr);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
                {
                    log &lt;/span&gt;= DateUtil.getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务器已断开连接&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    textbox_chatbox.Invoke(showLog,log);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应的委托函数自己根据你的命名写就可以啦~这里就不再赘述&lt;/p&gt;
&lt;h3&gt;终止连接&lt;/h3&gt;
&lt;p&gt;终止连接的思路也很简单：向服务器发送消息通知服务器我要下线了，然后关闭相应的流即可。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button_stop_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            SendMessage(textBox_name.Text, &lt;/span&gt;&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            log &lt;/span&gt;= DateUtil.getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已发起下线请求&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            textbox_chatbox.Invoke(showLog, log);
            flag_open &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bw != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                bw.Close();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (br != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                br.Close();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcpClient != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                tcpClient.Close();
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此客户端基本完成，细节你们可以再优化优化~&lt;/p&gt;

&lt;p&gt;服务器端是挺复杂的，我的思路是&lt;/p&gt;
&lt;p&gt;线程1：循环监听是否有新的客户端连接加入，若有则加入容器中，并向容器中所有的连接广播一下目前在线的客户。&lt;/p&gt;
&lt;p&gt;线程n：每一个连接都应该有一个线程循环监听是否有新的消息到来，有则回调给主线程去处理（这样不是很高效但基本满足需求）&lt;/p&gt;
&lt;h2&gt;界面设计&lt;/h2&gt;
&lt;p&gt;因为服务器只负责启动、暂停和转发消息，界面只需要日志窗口、状态口和两个按钮即可。（&lt;span&gt;不是我懒&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1539811/202004/1539811-20200415215450493-879309320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;编码实现&lt;/h2&gt;
&lt;h3&gt;启动服务器部分&lt;/h3&gt;
&lt;p&gt;启动服务器，就需要开启一个新的线程来循环监听，来一个连接就要存入容器中去管理。&lt;/p&gt;
&lt;p&gt;因为写习惯Java了，所以这里容器也选择List&amp;lt;&amp;gt;，首先我们先创建一个Client类来封装一些方法。&lt;/p&gt;
&lt;p&gt;在编写客户端的时候我们知道，每一个客户端都应该有相应的名称，所以Client类一定要包括一个名称以及相应的连接类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String userName;
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TcpClient tcpClient;
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BinaryReader br;
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; BinaryWriter bw;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发送信息函数类似客户端，直接调用bw即可。但接收信息必须是一个线程循环监听，故需要设计一个接口来实现新消息来临就回调传给主线程操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ReceiveMessageListener
  {
      &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; getMessage(String accountName,String message);
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;顺便把名字传过来可以知道到底是谁发送的消息。&lt;/p&gt;
&lt;p&gt;Client类的总体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Client
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String userName;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TcpClient tcpClient;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BinaryReader br;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BinaryWriter bw;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ReceiveMessageListener listener;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Client(String userName,TcpClient client,ReceiveMessageListener receiveMessageListener)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.userName =&lt;span&gt; userName;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.tcpClient =&lt;span&gt; client;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.listener =&lt;span&gt; receiveMessageListener;
            NetworkStream networkStream &lt;/span&gt;=&lt;span&gt; tcpClient.GetStream();
            br &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryReader(networkStream);
            bw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryWriter(networkStream);
            Thread thread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(receiveMessage);
            thread.Start();
            flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            thread.IsBackground &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Equals(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; obj)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; obj &lt;span&gt;is&lt;/span&gt; Client client &amp;amp;&amp;amp;&lt;span&gt;
                   userName &lt;/span&gt;==&lt;span&gt; client.userName;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; sendMessage(String ecodeMessage)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                bw.Write(ecodeMessage);
                bw.Flush();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }

            
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; receiveMessage()
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    String temp &lt;/span&gt;=&lt;span&gt; br.ReadString();
                    listener.getMessage(userName, temp);
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
            
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stop()
        {
            flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bw != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                bw.Close();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (br != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                br.Close();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcpClient != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                tcpClient.Close();
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; ReceiveMessageListener
        {
            &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; getMessage(String accountName,String message);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;写好Client以后我们就可以准备编写启动服务器的代码了，步骤：启动服务器-&amp;gt;监听-&amp;gt;新客户来-&amp;gt;加入List-&amp;gt;更新（广播）用户表-&amp;gt;继续监听&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; StartServer()
        {
            log &lt;/span&gt;= getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开始启动服务器中。。。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            textBox_log.Invoke(showLog, log);
            tcpListener &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TcpListener(localAddress, port);
            tcpListener.Start();
            log &lt;/span&gt;= getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IP:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + localAddress + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 端口号：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + port + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; 已启用监听&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            textBox_log.Invoke(showLog, log);
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
                {
                    tcpClient &lt;/span&gt;=&lt;span&gt; tcpListener.AcceptTcpClient();
                    networkStream &lt;/span&gt;=&lt;span&gt; tcpClient.GetStream();
                    br &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryReader(networkStream);
                    bw &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryWriter(networkStream);
                    String accountName &lt;/span&gt;=&lt;span&gt;br.ReadString();
                    accountName &lt;/span&gt;=&lt;span&gt; decodeUserName(accountName);
                    log &lt;/span&gt;= getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+accountName+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已上线&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    count&lt;/span&gt;++&lt;span&gt;;
                    label_status.Invoke(showNumber);
                    textBox_log.Invoke(showLog, log);
                    clientList.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Client(accountName,tcpClient,listener));
                    notifyUpdateUserList();
                }
                &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;
                {
                    log &lt;/span&gt;= getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已终止监听&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    textBox_log.Invoke(showLog, log);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                }
            }
            
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动服务器只需要开启新线程就行了~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 Thread thread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(StartServer);
            thread.Start();
            thread.IsBackground &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;更新名称函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notifyUpdateUserList()
        {
            String message &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; getCurUserName();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (Client i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; clientList)
            {
                i.sendMessage(message);
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getCurUserName()
        {
            String aa &lt;/span&gt;= &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(Client i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; clientList)
            {
                aa &lt;/span&gt;= aa + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i.userName;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; aa;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;回调接口实现、接收信息处理&lt;/h3&gt;
&lt;p&gt;在创建Client的时候需要传入一个监听接口，我们自己创建一个类来实现：&lt;/p&gt;
&lt;p&gt;根据之前设置的信息传送格式，写出对应的处理函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyListener : Client.ReceiveMessageListener
        {
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Form1 f;
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MyListener(Form1 form)
            {
                f &lt;/span&gt;=&lt;span&gt; form;
            }
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; getMessage(String accountname,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; message)
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO&lt;/span&gt;
                &lt;span&gt;string&lt;/span&gt; []results = message.Split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;.Parse(results[&lt;span&gt;0&lt;/span&gt;]) == &lt;span&gt;2&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送信息&lt;/span&gt;
&lt;span&gt;                {
                    String content &lt;/span&gt;= results[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                    String goalName &lt;/span&gt;= results[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;];
                    f.SendMessageToClient(content,goalName,accountname);
                }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;.Parse(results[&lt;span&gt;0&lt;/span&gt;]) ==&lt;span&gt;3&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;终止连接&lt;/span&gt;
&lt;span&gt;                {
                    String content &lt;/span&gt;= results[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                    f.stopClientByName(content);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求add&lt;/span&gt;
&lt;span&gt;                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;转发信息的逻辑：拿到目标用户名称，判断是不是所有人（广播）若是则广播,若不是则再去遍历寻找对应的客户再发送。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SendMessageToClient(String content,String goalName,String userName)
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (goalName.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;所有人&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))
            {
                flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(Client i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; clientList)
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (flag)
                {
                    i.sendMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2$广播：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + userName+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;说: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;content);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (i.userName.Equals(goalName))
                    {
                        i.sendMessage(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2$&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + userName + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;说: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;content);
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
                    }
                }
                
            }

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关闭对应客户端连接的思路：遍历&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; stopClientByName(String name)
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(Client i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; clientList){
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (i.userName.Equals(name))
                {
                    i.stop();
                    count&lt;/span&gt;--&lt;span&gt;;
                    label_status.Invoke(showNumber);
                    textBox_log.Invoke(showLog, getTime() &lt;/span&gt;+ name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已下线&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    clientList.Remove(i);
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;停止服务器部分&lt;/h3&gt;
&lt;p&gt;先断开所有在线客户端的连接，再断开总的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; button_stop_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)
        {
            CloseAllClients();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bw != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                bw.Close();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (br != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                br.Close();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcpClient != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                tcpClient.Close();
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tcpListener != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                tcpListener.Stop();
            }
            log &lt;/span&gt;= getTime() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;已停止服务器&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            textBox_log.Invoke(showLog, log);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; CloseAllClients()
        {
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(Client i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; clientList)
            {
                i.stop();
            }
            clientList.Clear();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完成。&lt;/p&gt;

&lt;p&gt;因为代码是我在很短时间内敲出来的，如果有不妥或者不足之处欢迎指正。&lt;/p&gt;
&lt;p&gt;当你掌握了一对一（一个客户端和一个服务器端连接）这种形式以后再去看多人聊天，也是很简单的，关键是多线程的使用以及回调。接口返回数据这种形式真的太重要了，在这里用的也非常方便。&lt;/p&gt;
&lt;p&gt;同时消息传送格式也很关键，尤其是当你在服务器端加入一些功能后，通信之间传输的是指令还是消息，都必须很好地区别出来。&lt;/p&gt;
&lt;p&gt;我在文中的写法不是特别建议，最好是单独抽出来写成一个类，这样以后维护方便、看起来简洁明了，不像我这个都杂在一起了。。。&lt;/p&gt;
&lt;p&gt;写本文章主要是总结一下自己编码实现的思路，关键代码都已经放在上面了，相信你按照我的步骤和思路来应该都能做出来，不自己做只是复制粘贴是没用的（而且也没啥专业代码嗯，自己写写呗），当然大佬请绕路。&lt;/p&gt;
&lt;p&gt;下面放一张运行截图（人格分裂）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1539811/202004/1539811-20200415222401742-597159589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Wed, 15 Apr 2020 14:25:00 +0000</pubDate>
<dc:creator>巴塞罗那的余晖</dc:creator>
<og:description>使用c#平台的winform编写一个tcp多人聊天程序，包括一对一、广播。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/robotpaul/p/12709022.html</dc:identifier>
</item>
</channel>
</rss>