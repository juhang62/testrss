<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringCloud 分布式事务解决方案 - SimpleWu</title>
<link>http://www.cnblogs.com/SimpleWu/p/10922654.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SimpleWu/p/10922654.html</guid>
<description>&lt;h2 id=&quot;tx-lcn分布式事务框架&quot;&gt;TX-LCN分布式事务框架&lt;/h2&gt;
&lt;p&gt;随着互联化的蔓延，各种项目都逐渐向分布式服务做转换。如今微服务已经普遍存在，本地事务已经无法满足分布式的要求，由此分布式事务问题诞生。 分布式事务被称为世界性的难题，目前分布式事务存在两大理论依据：CAP定律 BASE理论。&lt;/p&gt;
&lt;p&gt;官网地址:https://www.txlcn.org/zh-cn/&lt;/p&gt;
&lt;p&gt;GitHun:https://github.com/yizhishang/tx-lcn/&lt;/p&gt;
&lt;p&gt;在一个分布式系统下存在多个模块协调来完成一次业务。那么就存在一次业务事务下可能横跨多种数据源节点的可能。TX-LCN将可以解决这样的问题。&lt;/p&gt;
&lt;p&gt;​ 例如存在服务模块A 、B、 C。A模块是mysql作为数据源的服务，B模块是基于redis作为数据源的服务，C模块是基于mongo作为数据源的服务。若需要解决他们的事务一致性就需要针对不同的节点采用不同的方案，并且统一协调完成分布式事务的处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.txlcn.org/img/docs/abc.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;方案：&lt;/p&gt;
&lt;p&gt;​ 若采用TX-LCN分布式事务框架，则可以将A模块采用LCN模式、B/C采用TCC模式就能完美解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TX-LCN 主要有两个模块，Tx-Client(TC) Tx-Manager(TM). TC作为微服务下的依赖，TM是独立的服务。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;安装TM需要依赖的中间件： JRE1.8+, Mysql5.6+, Redis3.2+&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果需要手动编译源码， 还需要Git, Maven, JDK1.8+&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;创建MySQL数据库, 名称为: tx-manager&lt;/li&gt;
&lt;li&gt;创建数据表&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE `t_tx_exception`  (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `group_id` varchar(64) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `unit_id` varchar(32) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `mod_id` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL,
  `transaction_state` tinyint(4) NULL DEFAULT NULL,
  `registrar` tinyint(4) NULL DEFAULT NULL,
  `remark` varchar(4096) NULL DEFAULT  NULL,
  `ex_state` tinyint(4) NULL DEFAULT NULL COMMENT '0 未解决 1已解决',
  `create_time` datetime(0) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 1 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;tm下载与配置&quot;&gt;TM下载与配置&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;从&lt;a href=&quot;https://bbs.txlcn.org/viewtopic.php?id=44&quot;&gt;历史版本TM下载&lt;/a&gt;找到5.0.2.RELEASE的TM, 下载.&lt;/li&gt;
&lt;li&gt;修改配置信息&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;spring.application.name=tx-manager
server.port=7970
spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/tx-manager?characterEncoding=UTF-8
spring.datasource.username=root
spring.datasource.password=root
mybatis.configuration.map-underscore-to-camel-case=true
mybatis.configuration.use-generated-keys=true
# TxManager Host Ip
tx-lcn.manager.host=127.0.0.1
# TxClient连接请求端口
tx-lcn.manager.port=8070
# 心跳检测时间(ms)
tx-lcn.manager.heart-time=15000
# 分布式事务执行总时间
tx-lcn.manager.dtx-time=30000
#参数延迟删除时间单位ms
tx-lcn.message.netty.attr-delay-time=10000
tx-lcn.manager.concurrent-level=128
# TM后台登陆密码，默认值为codingapi
tx-lcn.manager.admin-key=123456
logging.level.com.codingapi=debug
#redis 主机
spring.redis.host=127.0.0.1
#redis 端口
spring.redis.port=6379
#redis 密码
spring.redis.password=
# 开启日志,默认为false
tx-lcn.logger.enabled=true
tx-lcn.logger.driver-class-name=${spring.datasource.driver-class-name}
tx-lcn.logger.jdbc-url=${spring.datasource.url}
tx-lcn.logger.username=${spring.datasource.username}
tx-lcn.logger.password=${spring.datasource.password}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 给出信息都是默认值&lt;br/&gt;关于详细配置说明见&lt;a href=&quot;https://www.txlcn.org/zh-cn/docs/setting/manager.html&quot;&gt;TM配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;application.properties 加载顺序如下：&lt;br/&gt;0、命令行启动参数指定&lt;br/&gt;1、file:./config/（当前jar目录下的config目录）&lt;br/&gt;2、file:./（当前jar目录）&lt;br/&gt;3、classpath:/config/（classpath下的config目录）&lt;br/&gt;4、classpath:/（classpath根目录）&lt;br/&gt;发布的二进制可执行Jar包含一个默认配置文件（也就是4），可按需要覆盖默认配置&lt;/li&gt;
&lt;li&gt;把txlcn-tm的pom打包方式修改成&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;手动编译TM，简单指引&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;# git clone https://github.com/codingapi/tx-lcn.git &amp;amp; cd txlcn-tm
# mvn clean  package '-Dmaven.test.skip=true'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;target文件夹下，即为Ttxlcn-tm-5.0.2.RELEASE.jar&lt;/p&gt;
&lt;h4 id=&quot;tc微服务模块&quot;&gt;TC微服务模块&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.txlcn.org/img/quick_arch.png&quot; alt=&quot;arch&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务A作为DTX发起方，远程调用服务B&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;工程说明&quot;&gt;工程说明&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;finchley 父项目主要进行依赖管理&lt;/li&gt;
&lt;li&gt;common-config 可存方公共配置级工具&lt;/li&gt;
&lt;li&gt;common-eureka 服务注册中心&lt;/li&gt;
&lt;li&gt;gateway-zuul 网关&lt;/li&gt;
&lt;li&gt;user-server 服务1&lt;/li&gt;
&lt;li&gt;money-server 服务2&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;忽略其他工程搭建步骤。&lt;/p&gt;
&lt;h4 id=&quot;事务操作实例&quot;&gt;事务操作实例&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;user-server&lt;/code&gt; 提供远程服务，&lt;code&gt;money-server&lt;/code&gt;通过fegin发现服务调用进行事务回滚。&lt;/p&gt;
&lt;p&gt;这两个服务需要加入依赖，如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- springcloud 分布式事物 --&amp;gt;
&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.codingapi.txlcn&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;txlcn-tc&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.2.RELEASE&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
 &amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;com.codingapi.txlcn&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;txlcn-txmsg-netty&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.0.2.RELEASE&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;com.google.guava&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;guava&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;依赖最好跟随TM管理器版本，方式出现奇怪问题。&lt;/p&gt;
&lt;p&gt;两个工程的启动类使用该&lt;code&gt;@EnableDistributedTransaction&lt;/code&gt;标记启动分布式事务。&lt;/p&gt;
&lt;p&gt;两个工程properties需要加入事务管理器监控地址，如下：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;#该配置根据TM打包时的配置进行
tx-lcn.client.manager-address=127.0.0.1:8070&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;user-server&lt;/code&gt; 和&lt;code&gt;money-server&lt;/code&gt;插入数据，server实例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * user-server
 * @Auhotr:SimpleWu
 * @TxTransaction 使用该注解启动分布式事务
 * @Transactional 同时使用spring事务开启本地事务
 * 插入一个用户
 */
@Override
@TxTransaction
@Transactional
public int insertUser(Map&amp;lt;String, Object&amp;gt; map) {
    userServerMapper.insert(map);
    return &quot;insertUser success&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; //fegin调用user-server服务
 @Autowired
 private UserFegin userFegin;

 //对money表操作mapper
 @Autowired
 private MoneyServerMapper moneyServerMapper;

/**
 * user-server
 * @Auhotr:SimpleWu
 * @TxTransaction 使用该注解启动分布式事务
 * @Transactional 同时使用spring事务开启本地事务
 * 插入一个用户
 */
@Override
@TxTransaction
@Transactional
public String insert() {
        String userId = UUID.randomUUID().toString();

        Map&amp;lt;String,Object&amp;gt; param = new HashMap&amp;lt;&amp;gt;();
        param.put(&quot;ID&quot;,userId);
        param.put(&quot;USER_ID&quot;,userId);
        param.put(&quot;MONEY&quot;,100);
        param.put(&quot;USERPASS&quot;,&quot;12321321&quot;);

        //先调用远程服务测试事务回滚
        System.out.println( userFegin.hello(&quot;张三&quot;,&quot;12321321&quot;,userId));

        int i = 0 / 0;

        moneyServerMapper.insert(param);

        return &quot;success &quot; + param;
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动顺序:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;部署Redis&lt;/li&gt;
&lt;li&gt;部署TM的Jar包&lt;/li&gt;
&lt;li&gt;部署Eureka服务注册中心&lt;/li&gt;
&lt;li&gt;部署user-server服务&lt;/li&gt;
&lt;li&gt;部署money-server服务&lt;/li&gt;
&lt;li&gt;忽略网关等.....&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;访问&lt;code&gt;money-server服务&lt;/code&gt; :&lt;code&gt;http://localhost:13000/hello&lt;/code&gt; 调用 insert();&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int i = 0 / 0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该行代码发生异常,UserFegin为&lt;code&gt;user-server&lt;/code&gt;远程放服务调用后打印&lt;code&gt;&quot;insertUser success&quot;&lt;/code&gt;代表调用成功，如果分布式事务没有效果，那么遇见该异常远程方不会进行回滚。&lt;/p&gt;
&lt;p&gt;在本次测试是回滚成功的，就不贴图了，亲自尝试才能体会到，那种感觉。&lt;/p&gt;
&lt;p&gt;然后删除&lt;code&gt;money-server&lt;/code&gt;中删除&lt;code&gt;int i = 0 / 0;&lt;/code&gt;重新启动。&lt;/p&gt;
&lt;p&gt;再次调用&lt;code&gt;http://localhost:13000/hello&lt;/code&gt;调用 insert()，成功插入两条数据。&lt;/p&gt;
&lt;p&gt;访问：&lt;code&gt;http://localhost:7970&lt;/code&gt;进入TxManager系统后台，登录密码是我们设置的&lt;code&gt;123456&lt;/code&gt;。里面可以看到配置信息，以及异常信息日志，系统日志。&lt;/p&gt;
&lt;p&gt;该篇案例源代码与工具见：https://github.com/450255266/open-doubi&lt;/p&gt;
</description>
<pubDate>Sat, 25 May 2019 07:46:00 +0000</pubDate>
<dc:creator>SimpleWu</dc:creator>
<og:description>[TOC] TX LCN分布式事务框架 随着互联化的蔓延，各种项目都逐渐向分布式服务做转换。如今微服务已经普遍存在，本地事务已经无法满足分布式的要求，由此分布式事务问题诞生。 分布式事务被称为世界性的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SimpleWu/p/10922654.html</dc:identifier>
</item>
<item>
<title>[Inside HotSpot] Java分代堆 - kelthuzadx</title>
<link>http://www.cnblogs.com/kelthuzadx/p/10922602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kelthuzadx/p/10922602.html</guid>
<description>&lt;h2 id=&quot;宇宙初始化&quot;&gt;1. 宇宙初始化&lt;/h2&gt;
&lt;p&gt;JVM在启动的时候会初始化各种结构，比如模板解释器，类加载器，当然也包括这篇文章的主题，Java堆。在hotspot源码结构中&lt;code&gt;gc/shared&lt;/code&gt;表示所有GC共同拥有的信息，&lt;code&gt;gc/g1&lt;/code&gt;,&lt;code&gt;gc/cms&lt;/code&gt;则是不同实现需要用到的特设信息。&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;λ tree
├─gc
│  ├─cms
│  ├─epsilon
│  ├─g1
│  ├─parallel
│  ├─serial
│  ├─shared
│  └─z&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如所有的Java堆都继承自CollectedHeap,这个结构就位于&lt;code&gt;gc/shared&lt;/code&gt;，然后Serial GC需要的特设信息位于&lt;code&gt;gc/serial&lt;/code&gt;，关于这点我们后面马上会提到。另外Java堆的类型很多，本文所述Java堆均为分代堆(Generational Heap)，它广泛用于Serial GC,CMS GC：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190525153224198-677579933.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于什么是分代堆应该不用多说，新生代老年代堆模型都是融入每个Javer灵魂的东西。&lt;/p&gt;
&lt;p&gt;在讨论分代堆之前，我们先从头说起。Java堆初始化会经过一个调用链：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;JNI_CreateJavaVM(prims/jni.cpp)
  -&amp;gt;JNI_CreateJavaVM_inner
    -&amp;gt;Threads::create_vm(runtime/thread.cpp)
      -&amp;gt;init_globals(runtime/init.cpp)
        -&amp;gt;universe_init(memory/universe.cpp)
          -&amp;gt;Universe::initialize_heap()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Universe模块（宇宙模块？hh）会负责高层次的Java堆的创建与初始化：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;jint Universe::initialize_heap() {
  // 创建Java堆
  _collectedHeap = create_heap();
  // 初始化Java堆
  jint status = _collectedHeap-&amp;gt;initialize();
  if (status != JNI_OK) {
    return status;
  }
  // 使用的GC，如[38.500s][info][gc] Using G1
  log_info(gc)(&quot;Using %s&quot;, _collectedHeap-&amp;gt;name());

  ThreadLocalAllocBuffer::set_max_size(Universe::heap()-&amp;gt;max_tlab_size());

  if (UseCompressedOops) {
    if ((uint64_t)Universe::heap()-&amp;gt;reserved_region().end() &amp;gt; UnscaledOopHeapMax) {
      Universe::set_narrow_oop_shift(LogMinObjAlignmentInBytes);
    }
    if ((uint64_t)Universe::heap()-&amp;gt;reserved_region().end() &amp;lt;= OopEncodingHeapMax) {
      Universe::set_narrow_oop_base(0);
    }
    AOTLoader::set_narrow_oop_shift();

    Universe::set_narrow_ptrs_base(Universe::narrow_oop_base());

    LogTarget(Info, gc, heap, coops) lt;
    if (lt.is_enabled()) {
      ResourceMark rm;
      LogStream ls(lt);
      Universe::print_compressed_oops_mode(&amp;amp;ls);
    }
    Arguments::PropertyList_add(new SystemProperty(&quot;java.vm.compressedOopsMode&quot;,
                                                   narrow_oop_mode_to_string(narrow_oop_mode()),
                                                   false));
  }

  // TLAB初始化
  if (UseTLAB) {
    assert(Universe::heap()-&amp;gt;supports_tlab_allocation(),
           &quot;Should support thread-local allocation buffers&quot;);
    ThreadLocalAllocBuffer::startup_initialization();
  }
  return JNI_OK;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建java堆&quot;&gt;2. 创建Java堆&lt;/h2&gt;
&lt;p&gt;在JVM初始化宇宙模块时会调用create_heap()创建堆，这个函数会进一步调用位于&lt;code&gt;memory/allocation&lt;/code&gt;模块的AllocateHeap，但是这些APIs实际还没有做分配动作，它们只是包装底层分配，处理一下分配失败，真正的内存分配是位于底层&lt;code&gt;runtime/os&lt;/code&gt;模块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190525153251078-895480665.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说到&lt;code&gt;runtime/os&lt;/code&gt;是底层内存分配，那它到底有多底层？打开源码看看，并没有像OS这个名字一样使用操作系统的VirtualAlloc，sbrk，而是使用C/C++语言运行时的&lt;code&gt;malloc()/free()&lt;/code&gt;进行分配/释放的。&lt;/p&gt;
&lt;h2 id=&quot;初始化java堆&quot;&gt;3. 初始化Java堆&lt;/h2&gt;
&lt;p&gt;在第一步中create_heap()创建了堆这个数据结构，但是里面的成员都是无效的，而第二步就是负责初始化这些成员。初始化分为initialize()和post_initialize()。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// hotspot\share\gc\shared\genCollectedHeap.cpp
jint GenCollectedHeap::initialize() {
  char* heap_address;
  ReservedSpace heap_rs;
  // 获取堆对齐
  size_t heap_alignment = collector_policy()-&amp;gt;heap_alignment();
  // 给堆分配空间
  heap_address = allocate(heap_alignment, &amp;amp;heap_rs);
  // 如果分配失败则关闭虚拟机
  if (!heap_rs.is_reserved()) {
    vm_shutdown_during_initialization(
      &quot;Could not reserve enough space for object heap&quot;);
    return JNI_ENOMEM;
  }
  // 根据刚刚获得的堆空间来初始化
  // CollectedHeap中的_reserved字段
  initialize_reserved_region((HeapWord*)heap_rs.base(), (HeapWord*)(heap_rs.base() + heap_rs.size()));
  
  // 创建并初始化remembered set
  _rem_set = create_rem_set(reserved_region());
  _rem_set-&amp;gt;initialize();
  CardTableBarrierSet *bs = new CardTableBarrierSet(_rem_set);
  bs-&amp;gt;initialize();
  BarrierSet::set_barrier_set(bs);
  
  // 根据刚刚获得的堆来初始化GenCollectedHeap的新生代
  ReservedSpace young_rs = heap_rs.first_part(_young_gen_spec-&amp;gt;max_size(), false, false);
  _young_gen = _young_gen_spec-&amp;gt;init(young_rs, rem_set());
  heap_rs = heap_rs.last_part(_young_gen_spec-&amp;gt;max_size());
 // 根据刚刚获得的堆来初始化GenCollectedHeap的老年代
  ReservedSpace old_rs = heap_rs.first_part(_old_gen_spec-&amp;gt;max_size(), false, false);
  _old_gen = _old_gen_spec-&amp;gt;init(old_rs, rem_set());
  clear_incremental_collection_failed();

  return JNI_OK;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;initialize()初始化新生代老年代，完成基础的分代；然后post_initialize()将新生代细分为Eden和Survivor，然后再初始化标记清楚算法用到的一些数据结构。至此JVM的分代堆就可以为垃圾回收器所用了。&lt;/p&gt;
&lt;h2 id=&quot;jvm分代堆详细结构&quot;&gt;4. JVM分代堆详细结构&lt;/h2&gt;
&lt;h3 id=&quot;collectedheap&quot;&gt;4.1 CollectedHeap&lt;/h3&gt;
&lt;p&gt;前面我们提到JVM是如何建立一个堆的，这一节将详细分析这个堆长什么样子。JVM有很多垃圾回收器，每个垃圾回收器处理的堆结构都是不一样的，比如G1GC处理的堆是由Region组成，CMS处理由老年代新生代组成的分代堆。这些不同的堆类型都继承自&lt;code&gt;gc/share/CollectedHeap&lt;/code&gt;，抽象基类CollectedHeap表示所有堆都拥有的一些属性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190525153307718-971667936.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// hotspot\share\gc\shared\collectedHeap.hpp
class CollectedHeap : public CHeapObj&amp;lt;mtInternal&amp;gt; {
 private:
  GCHeapLog* _gc_heap_log;                  // GC日志
  MemRegion _reserved;                      // 堆内存表示
 protected:
  bool _is_gc_active;                       // 是否正在GC

  unsigned int _total_collections;          // Minor GC次数
  unsigned int _total_full_collections;     // Full GC次数

  GCCause::Cause _gc_cause;                 // 当前引发GC的原因
  GCCause::Cause _gc_lastcause;             // 上次引发GC的原因
  ...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的**_reserved**就表示Java堆这片连续的地址，它包含堆的起始地址和大小，即&lt;code&gt;[start,start+size]&lt;/code&gt;。然而这样的堆是不能满足GC需求的，Full GC处理老年代，Minor GC处理新生代，可是这两个“代”都没有在CollectedHeap中体现。翻翻上图继承模型，GenCollectedHeap才是分代堆。&lt;/p&gt;
&lt;h3 id=&quot;gencollectedheap&quot;&gt;4.2 GenCollectedHeap&lt;/h3&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;//hotspot\share\gc\shared\genCollectedHeap.hpp
class GenCollectedHeap : public CollectedHeap {
public:
  enum GenerationType {
    YoungGen,
    OldGen
  };

protected:
  Generation* _young_gen;     // 新生代
  Generation* _old_gen;       // 老年代
  ...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到GenCollectedHeap里面的&lt;code&gt;_young_gen&lt;/code&gt;和&lt;code&gt;_old_gen&lt;/code&gt;基本就稳了。它继承自CollectedHeap，其中CollectedHeap里面的_reserved表示整个堆，GenCollectedHeap的新生代和老年代进一步划分_reserved。这个划分工作发生在堆初始化中。不同GC使用的新生代老年代也是不同的，所以不能一概而论，hotspot为此建立了如下分代模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190525153326258-1507237488.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分代基类：公有结构，保存上次GC耗时，该代的内存起始地址，GC性能计数&lt;/li&gt;
&lt;li&gt;默认新生代：一种包含Eden,From survivor, To survivor的分代&lt;/li&gt;
&lt;li&gt;并行新生代：可并行GC的默认新生代&lt;/li&gt;
&lt;li&gt;卡表代：包含卡表(CardTable)的分代&lt;/li&gt;
&lt;li&gt;久任代：可Mark-Compact的卡表代&lt;/li&gt;
&lt;li&gt;并行标记清楚代：可并行Mark-Sweep的卡表代&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每个代都自己的特色，不同GC根据不同需要可以&quot;自由&quot;组合，比如Serial GC就使用的是&lt;code&gt;DefNewGeneration&lt;/code&gt; + &lt;code&gt;TenuredGeneration&lt;/code&gt;的组合，CMS使用&lt;code&gt;ParNewGeneration&lt;/code&gt; + &lt;code&gt;ConcurrentMarkSweepGeneration&lt;/code&gt;的组合。&lt;/p&gt;
&lt;h3 id=&quot;serialheap&quot;&gt;4.3 SerialHeap&lt;/h3&gt;
&lt;p&gt;最后一步，Serial GC专用的堆继承自GenCollectedHeap并在其上稍作封装。这个SerialHeap最终将用于串行垃圾回收器(&lt;code&gt;-XX:+UseSerialGC&lt;/code&gt;)。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// hotspot\share\gc\serial\serialHeap.hpp
class SerialHeap : public GenCollectedHeap {
  static SerialHeap* heap();
  virtual Name kind() const {
    return CollectedHeap::Serial;
  }
  virtual const char* name() const {
    return &quot;Serial&quot;;
  }
  ...
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分代堆中的卡表代&quot;&gt;5. 分代堆中的卡表代&lt;/h2&gt;
&lt;p&gt;关于GenCollectedHeap的各种代还有很多内容，我们关注&lt;code&gt;DefNewGeneration&lt;/code&gt; + &lt;code&gt;TenuredGeneration&lt;/code&gt;的组合，它被用于SerialGC。&lt;/p&gt;
&lt;p&gt;久任代继承自卡表代，所谓卡表代是指用卡(Card)划分整个老年代。我们知道，标记清除需要遍历整个老年代来找出指向新生代的指针，至于为什么要做这个遍历看两副图即可明白。假设有堆中已经存在这样的引用关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190525153343898-562386369.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在加入分配了新的对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190525153352678-1592511071.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中老年代的对象存在指向新生代的指针，但是GC Root并没有，如果这时候只从GC Root出发标记对象，就会错过红线指向的对象，继而导致被误做垃圾而清除，所以必须遍历老年代找到指向新生代的对象。但是问题是老年代一般都很大，这样的遍历是比较慢的。卡表应此而生，它将老年代划分为512字节的卡(Card)，这些卡组成卡表(Card table)，卡表具体来说是一个字节数组。如果卡表中某一个字节不为dirty，则表示对应的512字节的区域不存在指向新生代的引用，那么就可以直接跳过该区域，减少了遍历时间：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654682/201905/1654682-20190525153401018-403601177.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中只有卡1和卡5存在指向新生代的指针，对整个老年代的遍历就缩小到只对卡1、卡5的遍历了。&lt;/p&gt;
</description>
<pubDate>Sat, 25 May 2019 07:34:00 +0000</pubDate>
<dc:creator>kelthuzadx</dc:creator>
<og:description>[Inside HotSpot] Java分代堆 1. 宇宙初始化 JVM在启动的时候会初始化各种结构，比如模板解释器，类加载器，当然也包括这篇文章的主题，Java堆。在hotspot源码结构中 表示</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kelthuzadx/p/10922602.html</dc:identifier>
</item>
<item>
<title>从源码解析 Spring 数据库异常抽理 - good_andyxu</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/10922497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/10922497.html</guid>
<description>&lt;p&gt;初入学习 JDBC 操作数据库，想必大家都写过下面的代码：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库为：H2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558763379012-ad6cfc3d-5bf3-4e2d-8b24-9fbc21ded14a.png&quot; alt=&quot;JDBC 操作数据库&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果需要处理特定 SQL 异常，比如 SQL 语句错误，这个时候我们应该怎么办？&lt;/p&gt;
&lt;p&gt;查看 &lt;strong&gt;SQLException&lt;/strong&gt; 源码，我们可以发现两个重要的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLException.getErrorCode&lt;/strong&gt;:返回数据库特定的错误码，由数据库厂商制定，不同厂商错误码不同。如重复主键错误码在 &lt;strong&gt;MySQL&lt;/strong&gt; 中是 1062，而在 &lt;strong&gt;Oracle&lt;/strong&gt; 中却是 1。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLException.getSQLState&lt;/strong&gt;：返回 &lt;strong&gt;XOPEN&lt;/strong&gt; 或 &lt;strong&gt;SQL:2003&lt;/strong&gt; 制定的错误码规范。数据库厂商会将不同错误消息映射成同一个错误码&lt;/p&gt;
&lt;p&gt;所以我们可以根据 &lt;strong&gt;SQLException.getErrorCode&lt;/strong&gt; 处理相应的数据库异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558763697752-9093ef11-6cbd-4a4e-9038-656c7e697778.png&quot; alt=&quot;JDBC 异常处理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于数据库厂商错误码不相同，这就导致如果我们更换数据库，上面判断逻辑就必须重写。&lt;/p&gt;
&lt;p&gt;下面我们使用 Spring 操作数据库。&lt;/p&gt;
&lt;h2 id=&quot;spring-操作数据库&quot;&gt;Spring 操作数据库&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558763769890-26d5d088-8134-43e1-84fe-f4d247fe79e9.png&quot; alt=&quot;Spring 数据库处理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用 Spring 之后，我们不再需要强制捕获异常。如果 SQL 语句运行存在异常，Spring 会抛出其内置特定的异常。如上面 SQL 语句异常将会抛出 &lt;strong&gt;BadSqlGrammarException&lt;/strong&gt;。除了这个异常之外，Spring 还定义很多数据库异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/images/DataAccessException.png&quot; alt=&quot;Spring 数据库异常&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个 Spring 数据库异常的基类都是 &lt;strong&gt;DataAccessException&lt;/strong&gt;。由于 &lt;strong&gt;DataAccessException&lt;/strong&gt; 继承自 &lt;strong&gt;RuntimeException&lt;/strong&gt;，所以在这类异常无需强制捕获。&lt;/p&gt;
&lt;p&gt;在 Spring 中使用 &lt;strong&gt;SQLExceptionTranslator&lt;/strong&gt; 进行异常转换，默认的转换规则会根据 &lt;strong&gt;SQLException.getErrorCode&lt;/strong&gt; 返回的错误码进行相应的转换。&lt;/p&gt;
&lt;p&gt;下面我们从源码分析转换过程。&lt;/p&gt;
&lt;h2 id=&quot;实现细节&quot;&gt;实现细节&lt;/h2&gt;
&lt;p&gt;调试 JdbcTemplate 的源码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558764253835-35e0fb83-1491-4f4a-a9fd-86d97d2c212b.png&quot; alt=&quot;JdbcTemplate&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这里捕获了 &lt;strong&gt;SQLException&lt;/strong&gt;，转换之后再将其抛出。&lt;/p&gt;
&lt;p&gt;整个转换过程，最后交给 &lt;strong&gt;SQLExceptionTranslator&lt;/strong&gt; 进行转换。&lt;/p&gt;
&lt;p&gt;首先我们查看 &lt;strong&gt;SQLExceptionTranslator&lt;/strong&gt; 类图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558764498907-d72f4185-2e87-4c6c-a6b3-70216f8f0243.png&quot; alt=&quot;类图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到其实现了一个抽象类以及三个子类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558764729835-900605b4-b26f-45fa-97c9-a565ea6402c5.png&quot; alt=&quot;抽象方法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抽象类中会首先会使用子类转换，若未能转换成功，将会启动 &lt;strong&gt;fallback&lt;/strong&gt;机制，再次转换，作为兜底。&lt;/p&gt;
&lt;p&gt;接着我们先看下三个子类的区别。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLErrorCodeSQLExceptionTranslator&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;默认转换类&lt;/li&gt;
&lt;li&gt;主要根据 &lt;strong&gt;SQLException.getErrorCode&lt;/strong&gt; 进行转换。&lt;/li&gt;
&lt;li&gt;默认使用 &lt;strong&gt;SQLExceptionSubclassTranslator&lt;/strong&gt; 作为 &lt;strong&gt;fallback&lt;/strong&gt; 对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;SQLExceptionSubclassTranslator&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于 JDBC 的 &lt;strong&gt;SQLException&lt;/strong&gt; 标准子类判断，如 &lt;strong&gt;java.sql.SQLTransientException&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;SQLStateSQLExceptionTranslator&lt;/strong&gt; 作为 &lt;strong&gt;fallback&lt;/strong&gt; 对象。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;SQLStateSQLExceptionTranslator&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;基于 &lt;strong&gt;SQLException.getSQLState&lt;/strong&gt; 规则判断。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面分析 &lt;strong&gt;SQLErrorCodeSQLExceptionTranslator&lt;/strong&gt; ，其他两个比较类似，同学们可以自己看源码分析。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SQLErrorCodeSQLExceptionTranslator&lt;/strong&gt; 转换器主要根据 &lt;strong&gt;SQLException.getErrorCode&lt;/strong&gt; 进行判断。Spring 默认在 &lt;strong&gt;org/springframework/jdbc/support/sql-error-codes.xml&lt;/strong&gt; 归纳不同数据库厂商相关错误码。该配置文件会在第一次发生 SQL 异常时由 &lt;strong&gt;SQLErrorCodesFactory&lt;/strong&gt; 进行加载，最后生成 &lt;strong&gt;SQLErrorCodes&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558765030827-8d7e4c1d-dce6-4b83-99d2-84f7de62653c.png&quot; alt=&quot;SQLErrorCodes&quot;/&gt;&lt;/p&gt;
&lt;p&gt;另外在 &lt;strong&gt;SQLErrorCodes&lt;/strong&gt; 提供扩展方法，可以根据错误码转换成自定义的异常。&lt;/p&gt;
&lt;p&gt;最后查看 &lt;strong&gt;SQLErrorCodeSQLExceptionTranslator&lt;/strong&gt; 里的转换方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558765513323-00ff7f1c-4bc0-4d70-ace8-d5ee9e9dfadb.png&quot; alt=&quot;SQLErrorCodeSQLExceptionTranslator&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前三个方法是 Spring 留下扩展方法，可以根据自己需求分别扩展。若都没有实现，将会根据错误码判断转换成具体的异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558765591114-e6e8e9f2-73da-4cd2-a3fc-bf95eabbd449.png&quot; alt=&quot;默认转换规则&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义异常转换&quot;&gt;自定义异常转换&lt;/h2&gt;
&lt;p&gt;上面说到 Spring 总共给我们留下三处扩展点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;继承 &lt;strong&gt;SQLErrorCodeSQLExceptionTranslator&lt;/strong&gt;，重写 &lt;strong&gt;customTranslate&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;继承 &lt;strong&gt;SQLExceptionTranslator&lt;/strong&gt;，重写 &lt;strong&gt;translate&lt;/strong&gt;，然后在 &lt;strong&gt;sql-error-codes.xml&lt;/strong&gt;注入。&lt;/li&gt;
&lt;li&gt;使用 &lt;strong&gt;SQLErrorCodes#customTranslations&lt;/strong&gt; ，然后在 &lt;strong&gt;sql-error-codes.xml&lt;/strong&gt; 配置相关错误码转换的规则。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第三种方式改动最小，比较简单。首先在 &lt;strong&gt;classpath&lt;/strong&gt; 下生成 &lt;strong&gt;sql-error-codes.xml&lt;/strong&gt;，复制原有配置，最后配置 &lt;strong&gt;customTranslations&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558765757759-d187567a-9d4e-46d9-8d0a-d7a92ce47fc8.png&quot; alt=&quot;customTranslations&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意的是，需要转化的异常类型必须为 &lt;strong&gt;DataAccessException&lt;/strong&gt; 子类。下面面我们自定义一个异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558765816909-94d85838-32b8-49b5-be65-e40e32299558.png&quot; alt=&quot;自定义异常&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Spirng 异常处理将 SQL 异常转化成内置异常，屏蔽不同数据库返回码不一致的带来的问题。&lt;/p&gt;
&lt;p&gt;最后总结本文的知识点，希望帮助到大家。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2019/png/254022/1558766967613-76682d3e-84f6-47d7-a70a-add6811f111f.png&quot; alt=&quot;知识图谱&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;帮助&quot;&gt;帮助&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.oracle.com/javase/tutorial/jdbc/basics/sqlexception.html&quot;&gt;Handling SQLExceptions&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 May 2019 07:17:00 +0000</pubDate>
<dc:creator>good_andyxu</dc:creator>
<og:description>初入学习 JDBC 操作数据库，想必大家都写过下面的代码： 数据库为：H2 如果需要处理特定 SQL 异常，比如 SQL 语句错误，这个时候我们应该怎么办？ 查看 SQLException 源码，我们</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/10922497.html</dc:identifier>
</item>
<item>
<title>关于线程的几个函数 - 小二郎**</title>
<link>http://www.cnblogs.com/sjks/p/10922414.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sjks/p/10922414.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5个基本线程函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pthread_create函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当一个程序启动时，这个时候主线程也叫初始线程就创建了。其余线程则有pthread_create函数创建。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include &amp;lt;pthread.h&amp;gt;
&lt;span&gt;int&lt;/span&gt; pthread_create(pthread_t *tid, &lt;span&gt;const&lt;/span&gt; pthread_attr_t *&lt;span&gt;attr,
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *(*func)(&lt;span&gt;void&lt;/span&gt; *),&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg);
返回:若成功则为0，若出错则为正的Exxx值&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个线程都有一个线程id(thread ID)标识，如果新的线程创建成功，其ID就通过tid指针返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后我们来看下最后一个参数，这个是线程执行的函数和参数，该线程通过调用这个函数开始执行，然后或者显式的终止(通过调用pthread_exit)，或者隐式的终止(通过让该函数返回)。该函数的地址由func参数指定，该函数的唯一调用参数是指针arg。如果我们需要传递多个参数，我们就要把他们打包成一个结构，传给这个参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pthread_join函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以通过调用pthread_join函数等待一个给定线程终止.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include &amp;lt;pthread.h&amp;gt;
&lt;span&gt;int&lt;/span&gt; pthread_join(pthread_t *tid,&lt;span&gt;void&lt;/span&gt; **&lt;span&gt;status);
返回:若成功则为0，若出错则为正的Exxx值&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个参数tid就是需要等待的那个线程id，status这个参数如果非空，那么来自所等待线程的返回值将存入由status指向的位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说通过调用这个函数，我们可以获取到该线程退出的状态的数据，当然这个线程的状态必须是可汇合的(joinable,默认值)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么意思呢？就是说如果某个线程的状态是可汇合的(joinable)，那么别的线程就可以通过pthread_join获取到该线程的退出状态和线程id，如果设置为脱离的(detached)，那么当该线程终止时，所有相关资源全部释放，我们不能等待他们终止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pthread_self函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个线程都有一个在所属进程内标识自身的ID,线程ID由pthread_create返回，我们在上面那个函数中也用到了，每个线程可以使用pthread_self获取自身的线程ID。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include &amp;lt;pthread.h&amp;gt;&lt;span&gt;
pthread_t pthread_self(&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt;);
返回:调用线程的线程ID&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pthread_detach函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在说pthread_join函数的时候我们提到过线程的状态，一种是可汇合的（joinable，默认值），一种是脱离的(detached)，这个函数的作用就是把某个线程的状态变为脱离的(detached)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include &amp;lt;pthread.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; pthread_detach(pthread_t tid);
返回:若成功则为0，若出错则为正的Exxx值&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本函数通过由想让自己脱离的线程调用，就如以下语句，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;pthread_detach(pthread_self());&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;pthread_exit函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让一个线程终止的方法之一是调用pthread_exit。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#include &amp;lt;pthread.h&amp;gt;
&lt;span&gt;void&lt;/span&gt; pthread_exit(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;status);
不返回到调用者&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果本线程未曾脱离，它的线程ID和退出状态将一直留存到调用进程内的某个其他线程对它调用pthread_join。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 May 2019 06:52:00 +0000</pubDate>
<dc:creator>小二郎**</dc:creator>
<og:description>5个基本线程函数 pthread_create函数 当一个程序启动时，这个时候主线程也叫初始线程就创建了。其余线程则有pthread_create函数创建。 #include &lt;pthread.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sjks/p/10922414.html</dc:identifier>
</item>
<item>
<title>.net core webapi jwt 更为清爽的认证 - FreeTimeWorker</title>
<link>http://www.cnblogs.com/zzfstudy/p/10922384.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zzfstudy/p/10922384.html</guid>
<description>&lt;p&gt;我的方式非主流，控制却可以更加灵活，喜欢的朋友，不妨花一点时间学习一下&lt;/p&gt;
&lt;p&gt;jwt认证分为两部分，第一部分是加密解密，第二部分是灵活的应用于中间件，我的处理方式是将获取token放到api的一个具体的controller中，将发放token与验证分离，token的失效时间，发证者，使用者等信息存放到config中。&lt;/p&gt;
&lt;p&gt;1.配置：&lt;/p&gt;
&lt;p&gt;在appsettings.json中增加配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&quot;Jwt&quot;&lt;span&gt;: {
&lt;/span&gt;&quot;Issuer&quot;: &quot;issuer&quot;&lt;span&gt;,//随意定义
&lt;/span&gt;&quot;Audience&quot;: &quot;Audience&quot;&lt;span&gt;,//随意定义
&lt;/span&gt;&quot;SecretKey&quot;: &quot;abc&quot;&lt;span&gt;,//随意定义
&lt;/span&gt;&quot;Lifetime&quot;: 20, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;单位分钟&lt;/span&gt;
&quot;ValidateLifetime&quot;: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,//验证过期时间
&lt;/span&gt;&quot;HeadField&quot;: &quot;useless&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;头字段&lt;/span&gt;
&quot;Prefix&quot;: &quot;prefix&quot;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前缀&lt;/span&gt;
&quot;IgnoreUrls&quot;: [ &quot;/Auth/GetToken&quot;&lt;span&gt; ]//忽略验证的url
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2:定义配置类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
internal class JwtConfig
    {
        public string Issuer { get; set; }
        public string Audience { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 加密key
        /// &amp;lt;/summary&amp;gt;
        public string SecretKey { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 生命周期
        /// &amp;lt;/summary&amp;gt;
        public int Lifetime { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 是否验证生命周期
        /// &amp;lt;/summary&amp;gt;
        public bool ValidateLifetime { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 验证头字段
        /// &amp;lt;/summary&amp;gt;
        public string HeadField { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// jwt验证前缀
        /// &amp;lt;/summary&amp;gt;
        public string Prefix { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 忽略验证的url
        /// &amp;lt;/summary&amp;gt;
        public List&amp;lt;string&amp;gt; IgnoreUrls { get; set; }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.加密解密接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IJwt
    {
        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; GetToken(Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Clims);
        &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; ValidateToken(&lt;span&gt;string&lt;/span&gt; Token,&lt;span&gt;out&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt; ,&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Clims);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.加密解密的实现类：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;&lt;span&gt;install&lt;/span&gt;-package System.IdentityModel.Tokens.Jwt&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Jwt : IJwt
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IConfiguration _configuration;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _base64Secret;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; JwtConfig _jwtConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtConfig();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Jwt(IConfiguration configration)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._configuration =&lt;span&gt; configration;
            configration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Bind(_jwtConfig);
            GetSecret();
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取到加密串
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; GetSecret()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; encoding = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; System.Text.ASCIIEncoding();
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] keyByte = encoding.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;salt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] messageBytes = encoding.GetBytes(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._jwtConfig.SecretKey);
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; hmacsha256 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HMACSHA256(keyByte))
            {
                &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] hashmessage =&lt;span&gt; hmacsha256.ComputeHash(messageBytes);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._base64Secret=&lt;span&gt; Convert.ToBase64String(hashmessage);
            }
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 生成Token
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;Claims&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; GetToken(Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Claims)
        {
            List&lt;/span&gt;&amp;lt;Claim&amp;gt; claimsAll = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Claim&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Claims)
            {
                claimsAll.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(item.Key, item.Value));
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; symmetricKey = Convert.FromBase64String(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._base64Secret);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tokenHandler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tokenDescriptor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SecurityTokenDescriptor
            {
                Issuer &lt;/span&gt;=&lt;span&gt; _jwtConfig.Issuer,
                Audience &lt;/span&gt;=&lt;span&gt; _jwtConfig.Audience,
                Subject &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClaimsIdentity(claimsAll),
                NotBefore &lt;/span&gt;=&lt;span&gt; DateTime.Now,
                Expires &lt;/span&gt;= DateTime.Now.AddMinutes(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._jwtConfig.Lifetime),
                SigningCredentials &lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; SigningCredentials(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SymmetricSecurityKey(symmetricKey),
                                           SecurityAlgorithms.HmacSha256Signature)
            };
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; securityToken =&lt;span&gt; tokenHandler.CreateToken(tokenDescriptor);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tokenHandler.WriteToken(securityToken);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; ValidateToken(&lt;span&gt;string&lt;/span&gt; Token, &lt;span&gt;out&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Clims)
        {
            Clims &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
            ClaimsPrincipal principal &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(Token))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler();
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jwt =&lt;span&gt; handler.ReadJwtToken(Token);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (jwt == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; secretBytes = Convert.FromBase64String(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._base64Secret);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; validationParameters = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
                {
                    RequireExpirationTime &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                    IssuerSigningKey &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SymmetricSecurityKey(secretBytes),
                    ClockSkew &lt;/span&gt;=&lt;span&gt; TimeSpan.Zero,
                    ValidateIssuer &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Issuer&lt;/span&gt;
                    ValidateAudience = &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Audience&lt;/span&gt;
                    ValidateLifetime = &lt;span&gt;this&lt;/span&gt;._jwtConfig.ValidateLifetime,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证失效时间&lt;/span&gt;
                    ValidateIssuerSigningKey = &lt;span&gt;true&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证SecurityKey&lt;/span&gt;
                    ValidAudience = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._jwtConfig.Audience,
                    ValidIssuer &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._jwtConfig.Issuer
                };
                SecurityToken securityToken;
                principal &lt;/span&gt;= handler.ValidateToken(Token, validationParameters, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; securityToken);
                &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; principal.Claims)
                {
                    Clims.Add(item.Type, item.Value);
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5.定义获取Token的Controller:&lt;/p&gt;
&lt;p&gt;在Startup.ConfigureServices中注入 IJwt&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;services.AddTransient&amp;lt;IJwt, Jwt&amp;gt;();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Jwt注入&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[controller]/[action]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    [ApiController]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AuthController : ControllerBase
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IJwt _jwt;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; AuthController(IJwt jwt)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._jwt =&lt;span&gt; jwt;
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; getToken
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult GetToken(&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            {
                Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; clims = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;();
                clims.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;userName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, userName);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; JsonResult(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._jwt.GetToken(clims));
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6.创建中间件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UseJwtMiddleware
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; JwtConfig _jwtConfig =&lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtConfig();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IJwt _jwt;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UseJwtMiddleware(RequestDelegate next, IConfiguration configration,IJwt jwt)
        {
            _next &lt;/span&gt;=&lt;span&gt; next;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._jwt =&lt;span&gt; jwt;
            configration.GetSection(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jwt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Bind(_jwtConfig);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Task InvokeAsync(HttpContext context)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_jwtConfig.IgnoreUrls.Contains(context.Request.Path))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._next(context);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (context.Request.Headers.TryGetValue(&lt;span&gt;this&lt;/span&gt;._jwtConfig.HeadField, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; Microsoft.Extensions.Primitives.StringValues authValue))
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; authstr =&lt;span&gt; authValue.ToString();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;._jwtConfig.Prefix.Length &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                    {
                        authstr &lt;/span&gt;= authValue.ToString().Substring(&lt;span&gt;this&lt;/span&gt;._jwtConfig.Prefix.Length+&lt;span&gt;1&lt;/span&gt;, authValue.ToString().Length -(&lt;span&gt;this&lt;/span&gt;._jwtConfig.Prefix.Length+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;._jwt.ValidateToken(authstr, &lt;span&gt;out&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Clims))
                    {
                        &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Clims)
                        {
                            context.Items.Add(item.Key, item.Value);
                        }
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._next(context);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        context.Response.StatusCode &lt;/span&gt;= &lt;span&gt;401&lt;/span&gt;&lt;span&gt;;
                        context.Response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{\&quot;status\&quot;:401,\&quot;statusMsg\&quot;:\&quot;auth vaild fail\&quot;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    context.Response.StatusCode &lt;/span&gt;= &lt;span&gt;401&lt;/span&gt;&lt;span&gt;;
                    context.Response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; context.Response.WriteAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{\&quot;status\&quot;:401,\&quot;statusMsg\&quot;:\&quot;auth vaild fail\&quot;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;7.中间件暴露出去&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
 public static class UseUseJwtMiddlewareExtensions
    {
        /// &amp;lt;summary&amp;gt;
        /// 权限检查
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;builder&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static IApplicationBuilder UseJwt(this IApplicationBuilder builder)
        {
            return builder.UseMiddleware&amp;lt;UseJwtMiddleware&amp;gt;();
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;8.在Startup.Configure中使用中间件：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;app.UseJwt();&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;以1的配置为例：&lt;/p&gt;
&lt;p&gt;除了请求 /auth/getToken 不需要加头信息外，其他的请求一律要求头信息中必须带着 &lt;/p&gt;
&lt;p&gt;userless:prefix (从Auth/GetToken中获取到的token)&lt;/p&gt;

</description>
<pubDate>Sat, 25 May 2019 06:46:00 +0000</pubDate>
<dc:creator>FreeTimeWorker</dc:creator>
<og:description>我的方式非主流，控制却可以更加灵活，喜欢的朋友，不妨花一点时间学习一下 jwt认证分为两部分，第一部分是加密解密，第二部分是灵活的应用于中间件，我的处理方式是将获取token放到api的一个具体的co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zzfstudy/p/10922384.html</dc:identifier>
</item>
<item>
<title>.NET Core 3.0之创建基于Consul的Configuration扩展组件 - 艾心❤</title>
<link>http://www.cnblogs.com/edison0621/p/10922281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edison0621/p/10922281.html</guid>
<description>&lt;p&gt;经过前面三篇关于.NET Core Configuration的文章之后，本篇文章主要讨论如何扩展一个Configuration组件出来。如果前面三篇文章没有看到，可以点击如下地址访问&lt;/p&gt;
&lt;p&gt;了解了Configuration的源码后，再去扩展一个组件就会比较简单，接下来我们将在.NET Core 3.0-preview5的基础上创建一个基于Consul的配置组件。&lt;/p&gt;
&lt;p&gt;相信大家对Consul已经比较了解了，很多项目都会使用Consul作为配置中心，此处也不做其他阐述了，主要是讲一下，创建Consul配置扩展的一些思路。使用Consul配置功能时，我们可以将信息转成JSON格式后再存储，那么我们在读取的时候，在体验上就像是从读取JSON文件中读取一样。&lt;/p&gt;

&lt;h2&gt;初始化Consul&lt;/h2&gt;
&lt;p&gt;假设你已经安装并启动了Consul，我们打开Key/Value功能界面，创建两组配置选项出来，分别是commonservice和userservice，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525141703543-181117393.png&quot;&gt;&lt;img title=&quot;Consul-key-value-dashboard&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525141703887-490125888.png&quot; alt=&quot;Consul-key-value-dashboard&quot; width=&quot;1908&quot; height=&quot;561&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;配置值采用JSON格式&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525141704218-2144717142.png&quot;&gt;&lt;img title=&quot;Consul-key-value-commonservice-json&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525141704515-1853572589.png&quot; alt=&quot;Consul-key-value-commonservice-json&quot; width=&quot;1908&quot; height=&quot;689&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;实现思路&lt;/h2&gt;
&lt;p&gt;我们知道在Configuration整个的设计框架里，比较重要的类ConfigurationRoot，内部又有一个IConfigurationProvider集合属性，也就是说我们追加IConfigurationProvider实例最终也会被放到到该集合中，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525141704760-1220559954.png&quot;&gt;&lt;img title=&quot;rootproviders&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525141704958-1392897877.png&quot; alt=&quot;rootproviders&quot; width=&quot;727&quot; height=&quot;251&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该项目中，我使用到了一个已经封装好的Consul(V0.7.2.6)类库，同时基于.NET Core关于Configuration的设计风格，做如下的框架设计&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525141705304-1647877483.png&quot;&gt;&lt;img title=&quot;consul&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525141705605-1764892279.png&quot; alt=&quot;consul&quot; width=&quot;710&quot; height=&quot;334&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;考虑到我会在该组件内部创建ConsulClient实例，所以对ConsulClient构造函数的一部分参数做了抽象提取，并添加到了IConsulConfigurationSource中，以增强该组件的灵活性。&lt;/p&gt;
&lt;p&gt;之前说过，Consul中的配置信息是以JSON格式存储的，所以此处使用到了Microsoft.Extensions.Configuration.Json.JsonConfigurationFileParser，用以将JSON格式的信息转换为Configuration的通用格式Key/Value。&lt;/p&gt;

&lt;h2&gt;IConsulConfigurationSource&lt;/h2&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// ConsulConfigurationSource&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;interface&lt;/span&gt; IConsulConfigurationSource : IConfigurationSource
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// CancellationToken&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    CancellationToken CancellationToken { get; }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// Consul构造函数实例，可自定义传入&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt;    Action&amp;lt;ConsulClientConfiguration&amp;gt; ConsulClientConfiguration { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;///  Consul构造函数实例，可自定义传入&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  18:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  19:  &lt;/span&gt;    Action&amp;lt;HttpClient&amp;gt; ConsulHttpClient { get; set; }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  20:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  21:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  22:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;///  Consul构造函数实例，可自定义传入&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  23:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  24:  &lt;/span&gt;    Action&amp;lt;HttpClientHandler&amp;gt; ConsulHttpClientHandler { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  25:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  26:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  27:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// 服务名称&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  28:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  29:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; ServiceKey { get; }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  30:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  31:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  32:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// 可选项&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  33:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  34:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;bool&lt;/span&gt; Optional { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  35:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  36:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  37:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// Consul查询选项&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  38:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  39:  &lt;/span&gt;    QueryOptions QueryOptions { get; set; }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  40:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  41:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  42:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// 重新加载延迟时间，单位是毫秒&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  43:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  44:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;int&lt;/span&gt; ReloadDelay { get; set; }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  45:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  46:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  47:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// 是否在配置改变的时候重新加载&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  48:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  49:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;bool&lt;/span&gt; ReloadOnChange { get; set; }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  50:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;ConsulConfigurationSource&lt;/h2&gt;
&lt;p&gt;该类提供了一个构造函数，用于接收ServiceKey和CancellationToken实例&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;16&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; ConsulConfigurationSource(&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; serviceKey, CancellationToken cancellationToken)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(serviceKey))
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; ArgumentNullException(nameof(serviceKey));
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.ServiceKey = serviceKey;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.CancellationToken = cancellationToken;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其build()方法也比较简单，主要是初始化ConsulConfigurationParser实例&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;12&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; IConfigurationProvider Build(IConfigurationBuilder builder)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    ConsulConfigurationParser consulParser = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; ConsulConfigurationParser(&lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; ConsulConfigurationProvider(&lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;, consulParser);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;ConsulConfigurationParser&lt;/h2&gt;
&lt;p&gt;该类比较复杂，主要实现Consul配置的获取、监控以及容错处理，公共方法源码如下&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;59&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// 获取并转换Consul配置信息&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;param name=&quot;reloading&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;param name=&quot;source&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; async Task&amp;lt;IDictionary&amp;lt;&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt;&amp;gt;&amp;gt; GetConfig(&lt;span class=&quot;kwrd&quot;&gt;bool&lt;/span&gt; reloading, IConsulConfigurationSource source)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;try&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;        QueryResult&amp;lt;KVPair&amp;gt; kvPair = await &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.GetKvPairs(source.ServiceKey, source.QueryOptions, source.CancellationToken).ConfigureAwait(&lt;span class=&quot;kwrd&quot;&gt;false&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; ((kvPair?.Response == &lt;span class=&quot;kwrd&quot;&gt;null&lt;/span&gt;) &amp;amp;&amp;amp; !source.Optional)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;        {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt;            &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; (!reloading)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt;            {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;                &lt;span class=&quot;kwrd&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; FormatException(Resources.Error_InvalidService(source.ServiceKey));
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt;            }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  18:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  19:  &lt;/span&gt;            &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt;, &lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt;&amp;gt;();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  20:  &lt;/span&gt;        }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  21:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  22:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; (kvPair?.Response == &lt;span class=&quot;kwrd&quot;&gt;null&lt;/span&gt;)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  23:  &lt;/span&gt;        {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  24:  &lt;/span&gt;            &lt;span class=&quot;kwrd&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; FormatException(Resources.Error_ValueNotExist(source.ServiceKey));
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  25:  &lt;/span&gt;        }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  26:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  27:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.UpdateLastIndex(kvPair);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  28:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  29:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt; JsonConfigurationFileParser.Parse(source.ServiceKey, &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; MemoryStream(kvPair.Response.Value));
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  30:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  31:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;catch&lt;/span&gt; (Exception exception)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  32:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  33:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;throw&lt;/span&gt; exception;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  34:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  35:  &lt;/span&gt;}
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  36:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  37:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  38:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// Consul配置信息监控&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  39:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  40:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;param name=&quot;key&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  41:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;param name=&quot;cancellationToken&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  42:  &lt;/span&gt;&lt;span class=&quot;rem&quot;&gt;/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  43:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; IChangeToken Watch(&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt; key, CancellationToken cancellationToken)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  44:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  45:  &lt;/span&gt;    Task.Run(() =&amp;gt; &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.RefreshForChanges(key, cancellationToken), cancellationToken);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  46:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  47:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.reloadToken;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  48:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，关于Consul的监控主要利用了QueryResult.LastIndex属性，该类缓存了该属性的值，并与实获取的值进行比较，以判断是否需要重新加载内存中的缓存配置&lt;/p&gt;
&lt;h2&gt;ConsulConfigurationProvider&lt;/h2&gt;
&lt;p&gt;该类除了实现Load方法外，还会根据ReloadOnChange属性，在构造函数中注册OnChange事件，用于重新加载配置信息，源码如下：&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;sealed&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; ConsulConfigurationProvider : ConfigurationProvider
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;readonly&lt;/span&gt; ConsulConfigurationParser configurationParser;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;readonly&lt;/span&gt; IConsulConfigurationSource source;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; ConsulConfigurationProvider(IConsulConfigurationSource source, ConsulConfigurationParser configurationParser)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.configurationParser = configurationParser;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.source = source;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;if&lt;/span&gt; (source.ReloadOnChange)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;        {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;            ChangeToken.OnChange(
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt;                () =&amp;gt; &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.configurationParser.Watch(&lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.source.ServiceKey, &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.source.CancellationToken),
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt;                async () =&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;                {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt;                    await &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.configurationParser.GetConfig(&lt;span class=&quot;kwrd&quot;&gt;true&lt;/span&gt;, source).ConfigureAwait(&lt;span class=&quot;kwrd&quot;&gt;false&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  18:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  19:  &lt;/span&gt;                    Thread.Sleep(source.ReloadDelay);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  20:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  21:  &lt;/span&gt;                    &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.OnReload();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  22:  &lt;/span&gt;                });
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  23:  &lt;/span&gt;        }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  24:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  25:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  26:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; Load()
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  27:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  28:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;try&lt;/span&gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  29:  &lt;/span&gt;        {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  30:  &lt;/span&gt;            &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.Data = &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.configurationParser.GetConfig(&lt;span class=&quot;kwrd&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.source).ConfigureAwait(&lt;span class=&quot;kwrd&quot;&gt;false&lt;/span&gt;).GetAwaiter().GetResult();
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  31:  &lt;/span&gt;        }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  32:  &lt;/span&gt;        &lt;span class=&quot;kwrd&quot;&gt;catch&lt;/span&gt; (AggregateException aggregateException)
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  33:  &lt;/span&gt;        {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  34:  &lt;/span&gt;            &lt;span class=&quot;kwrd&quot;&gt;throw&lt;/span&gt; aggregateException.InnerException;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  35:  &lt;/span&gt;        }
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  36:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  37:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;此处调用在Program中实现&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;class&lt;/span&gt; Program
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kwrd&quot;&gt;void&lt;/span&gt; Main(&lt;span class=&quot;kwrd&quot;&gt;string&lt;/span&gt;[] args)
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt;    {
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;        CancellationTokenSource cancellationTokenSource = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; CancellationTokenSource();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;        WebHost.CreateDefaultBuilder(args).ConfigureAppConfiguration(
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt;            (hostingContext, builder) =&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;            {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;                builder.AddConsul(&lt;span class=&quot;str&quot;&gt;&quot;userservice&quot;&lt;/span&gt;, cancellationTokenSource.Token, source =&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  11:  &lt;/span&gt;                {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  12:  &lt;/span&gt;                    source.ConsulClientConfiguration = cco =&amp;gt; cco.Address = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; Uri(&lt;span class=&quot;str&quot;&gt;&quot;http://localhost:8500&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  13:  &lt;/span&gt;                    source.Optional = &lt;span class=&quot;kwrd&quot;&gt;true&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  14:  &lt;/span&gt;                    source.ReloadOnChange = &lt;span class=&quot;kwrd&quot;&gt;true&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  15:  &lt;/span&gt;                    source.ReloadDelay = 300;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  16:  &lt;/span&gt;                    source.QueryOptions = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; QueryOptions
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  17:  &lt;/span&gt;                    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  18:  &lt;/span&gt;                        WaitIndex = 0
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  19:  &lt;/span&gt;                    };
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  20:  &lt;/span&gt;                });
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  21:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  22:  &lt;/span&gt;                builder.AddConsul(&lt;span class=&quot;str&quot;&gt;&quot;commonservice&quot;&lt;/span&gt;, cancellationTokenSource.Token, source =&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  23:  &lt;/span&gt;                {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  24:  &lt;/span&gt;                    source.ConsulClientConfiguration = cco =&amp;gt; cco.Address = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; Uri(&lt;span class=&quot;str&quot;&gt;&quot;http://localhost:8500&quot;&lt;/span&gt;);
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  25:  &lt;/span&gt;                    source.Optional = &lt;span class=&quot;kwrd&quot;&gt;true&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  26:  &lt;/span&gt;                    source.ReloadOnChange = &lt;span class=&quot;kwrd&quot;&gt;true&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  27:  &lt;/span&gt;                    source.ReloadDelay = 300;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  28:  &lt;/span&gt;                    source.QueryOptions = &lt;span class=&quot;kwrd&quot;&gt;new&lt;/span&gt; QueryOptions
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  29:  &lt;/span&gt;                    {
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  30:  &lt;/span&gt;                        WaitIndex = 0
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  31:  &lt;/span&gt;                    };
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  32:  &lt;/span&gt;                });
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  33:  &lt;/span&gt;            }).UseStartup&amp;lt;Startup&amp;gt;().Build().Run();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  34:  &lt;/span&gt;    }
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;  35:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果，如下图所示，我们已经加载到了两个ConsulProvider实例，这与我们在Program中添加的两个Consul配置一致，其中所加载到的值也和.NET Core Configuration的Key/Value风格相一致，所加载到的值也会Consul中所存储的相一致&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525142159337-171469605.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525142159945-256961900.png&quot; alt=&quot;image&quot; width=&quot;1479&quot; height=&quot;604&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525142200441-1807114625.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525142201007-207317337.png&quot; alt=&quot;image&quot; width=&quot;1329&quot; height=&quot;278&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525142338191-155181235.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201905/533598-20190525142338499-410564952.png&quot; alt=&quot;image&quot; width=&quot;1252&quot; height=&quot;498&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;基于源码扩展一个配置组件出来，还是比较简单的，另外需要说明的是，该组件关于JSON的处理主要基于.NET Core原生组件，位于命名空间内的System.Text.Json中，所以该组件无法在.NET Core 3.0之前的版本中运行，需要引入额外的JSON组件辅助处理。&lt;/p&gt;
&lt;p&gt;源码已经托管于GitHub，地址：&lt;a href=&quot;https://github.com/littlehorse8/Navyblue.Extensions.Configuration.Consul&quot;&gt;https://github.com/littlehorse8/Navyblue.Extensions.Configuration.Consul&lt;/a&gt;，记得点个小星星哦&lt;/p&gt;
</description>
<pubDate>Sat, 25 May 2019 06:24:00 +0000</pubDate>
<dc:creator>艾心❤</dc:creator>
<og:description>写在前面 经过前面三篇关于.NET Core Configuration的文章之后，本篇文章主要讨论如何扩展一个Configuration组件出来。如果前面三篇文章没有看到，可以点击如下地址访问 .N</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/edison0621/p/10922281.html</dc:identifier>
</item>
<item>
<title>30个Python物联网小实验5：光线感应灯 - asukafighting</title>
<link>http://www.cnblogs.com/asukafighting/p/10922305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/asukafighting/p/10922305.html</guid>
<description>&lt;h2 id=&quot;个python物联网小实验5光线感应灯&quot;&gt;30个Python物联网小实验5：光线感应灯&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683594/201905/1683594-20190525142016799-1550074874.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683594/201905/1683594-20190525142037636-2048354041.gif&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;光线传感器&quot;&gt;光线传感器&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;可以检测周围环境的亮度；&lt;/li&gt;
&lt;li&gt;方向性较好，感知特定方向的亮度；&lt;/li&gt;
&lt;li&gt;灵敏度可调，用螺丝刀旋转图中蓝色电位器即可；&lt;/li&gt;
&lt;li&gt;工作电压：3.3v~5v&lt;/li&gt;
&lt;li&gt;数字开关输出：0或1&lt;/li&gt;
&lt;li&gt;设有固定螺栓孔，方便安装&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;光线变化执行函数&quot;&gt;光线变化执行函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;接线方法：正极接树莓派的5v正极，负极接树莓派的GND地线，信号输出针脚接&lt;code&gt;GPIO18&lt;/code&gt;号口。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683594/201905/1683594-20190525142058543-311541343.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from gpiozero import LightSensor

sensor = LightSensor(18)

while True:
    sensor.wait_for_light()
    print(&quot;It's dark! :)&quot;)
    sensor.wait_for_dark()
    print(&quot;It's light! :(&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;可以看到代码的核心就是&lt;code&gt;wait_for_light()&lt;/code&gt;和&lt;code&gt;wait_for_dark()&lt;/code&gt;这两个函数，手遮挡住光线的时候，显示&lt;code&gt;&quot;It's dark! :)&quot;&lt;/code&gt;，手拿开之后，显示&lt;code&gt;&quot;It's light! :(&quot;&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;光线状态执行函数&quot;&gt;光线状态执行函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;上代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;from gpiozero import LightSensor, LED
from signal import pause

sensor = LightSensor(18)
led = LED(17)

sensor.when_dark = led.off
sensor.when_light = led.on

pause()&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;代码的核心在于将&lt;code&gt;sensor&lt;/code&gt;的状态直接提供给&lt;code&gt;led&lt;/code&gt;，这样光线传感器检测到亮光的时候&lt;code&gt;led&lt;/code&gt;熄灭，检测不到光线的时候，&lt;code&gt;led&lt;/code&gt;点亮。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;好了，本次介绍就到这里，本文收录在我的《手把手教你玩树莓派》系列教程，立足于普及树莓派搭配&lt;strong&gt;人工智能、物联网和机器人&lt;/strong&gt;的玩法，想要跟我一起学习的童鞋可以加我微信/微博ID：asukafighting，也可以直接看教程：&lt;a href=&quot;https://github.com/asukafighting/RaspberrypiHandbyHand&quot; class=&quot;uri&quot;&gt;https://github.com/asukafighting/RaspberrypiHandbyHand&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 25 May 2019 06:21:00 +0000</pubDate>
<dc:creator>asukafighting</dc:creator>
<og:description>'30个Python物联网小实验5：光线感应灯' '光线传感器' '光线变化执行函数' '光线状态执行函数' 30个Python物联网小实验5：光线感应灯 光线传感器 可以检测周围环境的亮度； 方向性</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/asukafighting/p/10922305.html</dc:identifier>
</item>
<item>
<title>快速掌握RabbitMQ(四)——两种种消费模式和QOS的C#实现 - 捞月亮的猴子</title>
<link>http://www.cnblogs.com/wyy1234/p/10883568.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyy1234/p/10883568.html</guid>
<description>&lt;p&gt;　　本篇介绍一下RabbitMQ中的消费模式，在前边的所有栗子中我们采用的消费者都是EventingBasicConsumer，其实RabbitMQ中还有其他两种消费模式：BasicGet和QueueBaicConsumer，下边介绍RabiitMQ的消费模式，及使用它们时需要注意的一些问题。&lt;/p&gt;
&lt;h2&gt;1 RabbitMQ的消费模式&lt;/h2&gt;
&lt;h3&gt;0 准备工作&lt;/h3&gt;
&lt;p&gt;　　使用Web管理工具添加exchange、queue并绑定，bindingKey为“mykey”，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190517185007703-1331480421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;span&gt;生产者代码&lt;/span&gt;如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
       &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory()
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq-server所在设备ip，这里就是本机&lt;/span&gt;
                HostName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接connection&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建通道channel&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生产者准备就绪....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; message = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在控制台输入消息，按enter键发送消息&lt;/span&gt;
                    &lt;span&gt;while&lt;/span&gt; (!message.Equals(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;quit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StringComparison.CurrentCultureIgnoreCase))
                    {
                        message &lt;/span&gt;=&lt;span&gt; Console.ReadLine();
                        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; body =&lt;span&gt; Encoding.UTF8.GetBytes(message);
                        channel.BasicPublish(exchange: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myexchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                             routingKey: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                             basicProperties: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                                             body: body);
                        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【{message}】发送到Broke成功！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    }
                }
            }
            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1 EventingBasicConsumer介绍&lt;/h3&gt;
&lt;p&gt;　　EventingBasicConsumer是发布/订阅模式的消费者，即只要订阅的queue中有了新消息，Broker就会立即把消息推送给消费者，这种模式可以保证消息及时地被消费者接收到。EventingBasicConsumer是长连接的：只需要创建一个Connection,然后在Connection的基础上创建通道channel，消息的发送都是通过channel来执行的，这样可以减少Connection的创建，比较节省资源。前边我们已经使用了很多次EventingBaiscConsumer，这里简单展示一下使用的方式，注释比较详细，就不多介绍了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory()
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq-server所在设备ip，这里就是本机&lt;/span&gt;
                HostName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
                {
                    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; EventingBasicConsumer
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义一个EventingBasicConsumer消费者                                    &lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到消息时触发的事件&lt;/span&gt;
                    consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
                    {

                        Console.WriteLine(Encoding.UTF8.GetString(ea.Body));
                    };
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消费者准备就绪....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用消费方法 queue指定消费的队列，autoAck指定是否自动确认，consumer就是消费者对象&lt;/span&gt;
                    channel.BasicConsume(queue: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myqueue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                           autoAck: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                                           consumer: consumer);
                    Console.ReadKey();
                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　执行程序，结果如下，只要我们在生产者端发送一条消息到Broker，Broker就会立即推送消息到消费者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190517191104211-2034221513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2 BasicGet方法介绍&lt;/h3&gt;
&lt;p&gt; 　　我们知道使用EventingBasicConsumer可以让消费者最及时地获取到消息，使用EventingBasicConsumer模式时消费者在被动的接收消息，即消息是推送过来的，Broker是主动的一方。那么能不能让消费者作为主动的一方，消费者什么时候想要消息了，就自己发送一个请求去找Broker要？答案使用Get方式。Get方式是短连接的，消费者每次想要消息的时候，首先建立一个Connection，发送一次请求，Broker接收到请求后，响应一条消息给消费者，然后断开连接。RabbitMQ中Get方式和HTTP的请求响应流程基本一样，Get方式的实时性比较差，也比较耗费资源。我们看一个Get方式的栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory()
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq-server所在设备ip，这里就是本机&lt;/span&gt;
                HostName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
                {
                    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; BasicGet
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过BasicGet获取消息，开启自动确认&lt;/span&gt;
                    &lt;span&gt;&lt;strong&gt;BasicGetResult result = channel.BasicGet(queue:&quot;myqueue&quot;,autoAck:true&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;);&lt;/strong&gt;&lt;/span&gt;
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;接收到消息【{Encoding.UTF8.GetString(&lt;span&gt;result.Body&lt;/span&gt;)}】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;打印exchange和routingKey&lt;/span&gt;
                    Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exchange：{&lt;span&gt;result.Exchange&lt;/span&gt;},routingKey:{&lt;span&gt;result.RoutingKey&lt;/span&gt;}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    Console.ReadLine();
                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行生成者和消费者程序，生产者发送三条消息，而消费者只获取了一条消息，这是因为channel.BasicGet()一次只获取一条消息，获取到消息后就把连接断开了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190517192201725-681397968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　补充：RabbitMQ还有一种消费者QueueBaicConsumer，用法和Get方式类似，QueueBaicConsumer在官方API中标记已过时，这里不再介绍，有兴趣的小伙伴可以自己研究下。 &lt;/p&gt;
&lt;h2&gt;2 Qos介绍&lt;/h2&gt;
&lt;p&gt;　　在介绍Qos(服务质量)前我们先看一下使用EventingBasicConsumer的一个坑，使用代码演示一下，简单修改一下上边栗子的代码&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;生产者代码&lt;/strong&gt;&lt;/span&gt;如下，这里生产者发送了100条消费到Broker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory()
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq-server所在设备ip，这里就是本机&lt;/span&gt;
                HostName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建连接connection&lt;/span&gt;
            &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建通道channel&lt;/span&gt;
                &lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
                {
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生产者准备就绪....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; 添加100条数据
                    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++&lt;span&gt;)
                    {
                        channel.BasicPublish(exchange: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myexchange&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                             routingKey: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                             basicProperties: &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
                                             body: Encoding.UTF8.GetBytes($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第{i}条消息&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
                    }
                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;

                }
            }
            Console.ReadKey();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;消费端代码&lt;/span&gt;&lt;/strong&gt;如下，消费端采用的是自动确认(autoAck=true)，即Broker把消息发送给消费者就会确认成功，不关心消息有没有处理完成，假设每条消息处理需要5s&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory()
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq-server所在设备ip，这里就是本机&lt;/span&gt;
                HostName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
                {
                    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; EventingBasicConsumer
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义消费者                                      &lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到消息时执行的任务&lt;/span&gt;
                    consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        &lt;strong&gt;&lt;span&gt;Thread.Sleep(&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;1000 * 5&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;);&lt;/span&gt;&lt;/strong&gt;
                        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;处理消息【{Encoding.UTF8.GetString(ea.Body)}】完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    };
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消费者准备就绪....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理消息&lt;/span&gt;
                    channel.BasicConsume(queue: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myqueue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                           &lt;strong&gt;&lt;span&gt;autoAck: &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;true&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;,&lt;/span&gt;&lt;/strong&gt;
                                           consumer: consumer);
                    Console.ReadKey();
                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我们先执行生产者程序，执行完成后发现queue中有了100条ready状态的消息，表示消息成功发送到了队列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190517194314274-53311145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　接着我们执行消费者，消费者执行后，Broker会把消息一股脑发送过去，通过Web管理界面我们看到queue中已经没有消息了，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190517194417120-400912235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　我们再看一下消费者的执行情况，发现消费者仅仅处理了4条消息，还有96条消息没有处理&lt;strong&gt;，这就是说消费者没有处理完消息，但是queue中的消息都已经删除了&lt;/strong&gt;。如果这时消费者挂掉了，所有未处理的消息都会丢失，在某些场合中，丢失数据的后果是十分严重的。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190517194441110-1799814060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　对于上边的问题，我们可能会想到使用显示确认来保证消息不会丢失：将BasicConsume方法的autoAck设置为false,然后处理一条消息后手动确认一下，这样的话已处理的消息在接收到确认回执时被删除，未处理的消息以Unacked状态存放在queue中。如果消费者挂了，Unacked状态的消息会自动重新变成Ready状态，如此一来就不用担心消息丢失了，修改消费者代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory()
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq-server所在设备ip，这里就是本机&lt;/span&gt;
                HostName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
                {
                    &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; EventingBasicConsumer
                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义消费者                                      &lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到消息时执行的任务&lt;/span&gt;
                    consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理完成，手动确认&lt;/span&gt;
                       &lt;strong&gt;&lt;span&gt; channel.BasicAck(ea.DeliveryTag, false&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;);&lt;/span&gt;&lt;/strong&gt;
                        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;处理消息【{Encoding.UTF8.GetString(ea.Body)}】完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    };
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消费者准备就绪....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理消息&lt;/span&gt;
                    channel.BasicConsume(queue: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myqueue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                         &lt;strong&gt;&lt;span&gt;  autoAck: &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;false&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;,&lt;/span&gt;&lt;/strong&gt;
                                           consumer: consumer);
                    Console.ReadKey();
                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　重新执行生产者，然后执行消费者，Web管理其中看到结果如下：在执行消费者时，消息会一股脑的发送给消费者，然后状态都变成Unacked，消费者执行完一条数据手动确认后，这条消息从queue中删除。当消费者挂了(我们可以直接把消费者关掉来模拟挂掉的情况)，没有处理的消息会自动从Unacked状态变成Ready状态，不用担心消息丢失了！打开Web管理界面看到状态如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190517200239181-15093146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　通过显式确认的方式可以解决消息丢失的问题，但这种方式也存在一些问题：①当消息有十万，百万条时，一股脑的把消息发送给消费者，可能会造成消费者内存爆满；②当消息处理比较慢的时，单一的消费者处理这些消息可能很长时间，我们自然想到再添加一个消费者加快消息的处理速度，但是这些消息都被原来的消费者接收了，状态为Unacked，所以这些消息不会再发送给新添加的消费者。针对这些问题怎么去解决呢？&lt;/p&gt;
&lt;p&gt;　　RabbitMQ提供的Qos(服务质量)可以完美解决上边的问题，使用Qos时，Broker不会再把消息一股脑的发送给消费者，我们可以设置每次传输给消费者的消息条数n，消费者把这n条消息处理完成后，再获取n条数据进行处理，这样就不用担心消息丢失、服务端内存爆满的问题了，因为没有发送的消息状态都是Ready，所以当我们新增一个消费者时，消息也可以立即发送给新增的消费者。注意Qos只有在消费端使用显示确认时才有效，使用Qos的方式十分简单，在消费端调用 &lt;span class=&quot;cnblogs_code&quot;&gt;channel.BasicQos()&lt;/span&gt; 方法即可，修改服务端代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConnectionFactory()
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;rabbitmq-server所在设备ip，这里就是本机&lt;/span&gt;
                HostName = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                UserName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户名&lt;/span&gt;
                Password = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123321&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;
&lt;span&gt;            };
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; connection =&lt;span&gt; factory.CreateConnection())
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; channel =&lt;span&gt; connection.CreateModel())
                {
                    &lt;strong&gt;&lt;span&gt;channel.BasicQos(prefetchSize: &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;0, prefetchCount: 2, global: false);
                    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;#region&lt;/span&gt; EventingBasicConsumer

                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义消费者                                      &lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; consumer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventingBasicConsumer(channel);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收到消息时执行的任务&lt;/span&gt;
                    consumer.Received += (model, ea) =&amp;gt;&lt;span&gt;
                    {
                        Thread.Sleep(&lt;/span&gt;&lt;span&gt;1000&lt;/span&gt; * &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理完成，手动确认&lt;/span&gt;
                        channel.BasicAck(ea.DeliveryTag, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                        Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;处理消息【{Encoding.UTF8.GetString(ea.Body)}】完成&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    };
                    Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消费者准备就绪....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理消息&lt;/span&gt;
                    channel.BasicConsume(queue: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myqueue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                           autoAck: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
                                           consumer: consumer);
                    Console.ReadKey();
                    &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
                }
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　清空一下queue中的消息，重新启动生产者，然后启动消费者，打开Web管理界面，看到状态如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1007918/201905/1007918-20190517204529967-1074982288.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　 &lt;span class=&quot;cnblogs_code&quot;&gt;channel.BasicQos(prefetchSize: &lt;span&gt;0&lt;/span&gt;, prefetchCount: &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;global&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;)&lt;/span&gt; 方法中参数prefetchSize为预取的长度，一般设置为0即可，表示长度不限；prefetchCount表示预取的条数，即发送的最大消息条数；global表示是否在Connection中全局设置，true表示Connetion下的所有channel都设置为这个配置。&lt;/p&gt;
&lt;h2&gt;3 小结&lt;/h2&gt;
&lt;p&gt;　　本节演示了RabbitMQ的两种消费者：EventingBasicConsumer和BasicGet。EventingBasicConsumer是基于长连接，发布订阅模式的消费方式，节省资源且实时性好，这是开发中最常用的消费模式。在一些需要消费者主动获取消息的场合，我们可以使用Get方式，Get方式是基于短连接的，请求响应模式的消费方式。&lt;/p&gt;
&lt;p&gt;　　Qos可以设置消费者一次接收消息的最大条数，能够解决消息拥堵时造成的消费者内存爆满问题。Qos也比较适用于耗时任务队列，当任务队列中的任务很多时，使用Qos后我们可以随时添加新的消费者来提高任务的处理效率。&lt;/p&gt;

</description>
<pubDate>Sat, 25 May 2019 05:26:00 +0000</pubDate>
<dc:creator>捞月亮的猴子</dc:creator>
<og:description>本篇介绍一下RabbitMQ中的消费模式，在前边的所有栗子中我们采用的消费者都是EventingBasicConsumer，其实RabbitMQ中还有其他两种消费模式：BasicGet和QueueBa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyy1234/p/10883568.html</dc:identifier>
</item>
<item>
<title>Jenkins持续部署-Windows环境持续部署探究1 - 杰哥很忙</title>
<link>http://www.cnblogs.com/Jack-Blog/p/10922038.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jack-Blog/p/10922038.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/10291612.html&quot;&gt;Jenkins持续集成学习-Windows环境进行.Net开发1&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/10316116.html&quot;&gt;Jenkins持续集成学习-Windows环境进行.Net开发2&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/10331263.html&quot;&gt;Jenkins持续集成学习-Windows环境进行.Net开发3&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/10346032.html&quot;&gt;Jenkins持续集成学习-Windows环境进行.Net开发4&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/10439325.html&quot;&gt;Jenkins持续集成学习-搭建jenkins问题汇总&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/10922038.html&quot;&gt;Jenkins持续部署-Windows环境持续部署探究1&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在之前的文章中，对Windows环境下的持续集成方案进行探究，接下来对Windows环境下持续部署的方案进行学习与研究。&lt;/p&gt;
&lt;h2 id=&quot;目的&quot;&gt;目的&lt;/h2&gt;
&lt;p&gt;当jenkins集成编译成功后，将文件上传到指定的服务器FTP目录。本文将介绍关于持续部署需要的一些技术方案的实现，在后续文章中继续对持续集成具体的逻辑进行细化梳理。&lt;/p&gt;
&lt;h2 id=&quot;方案流程&quot;&gt;方案流程&lt;/h2&gt;
&lt;p&gt;当jenkins编译完成之后，我们需要处理以下事项完成持续部署。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190525121347373-1671420405.png&quot; alt=&quot;20190525121346.png&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;jenkins编译成功，则将所有的exe和dll文件先压缩打包，文件名可以命名为Job名称或者版本号&lt;/li&gt;
&lt;li&gt;压缩完成后将压缩文件上传到指定的FTP&lt;/li&gt;
&lt;li&gt;上传完成后，则需要关闭服务器上的指定服务&lt;/li&gt;
&lt;li&gt;关闭完成后替换原始的程序目录下的文件&lt;/li&gt;
&lt;li&gt;启动服务&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里暂时不探讨服务可用性的具体细节，也不讨论服务升级失败的回退工作等具体细节。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;技术实现&quot;&gt;技术实现&lt;/h2&gt;
&lt;p&gt;可以分析出上述流程中涉及到的技术要点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用脚本对指定的文件进行压缩，在windows上使用PowerShell执行脚本再合适不过了。&lt;/li&gt;
&lt;li&gt;通过FTP上传到服务器，可以通过jenkins的FTP插件或者通过PowerShell脚本将文件上传到指定服务器上。&lt;/li&gt;
&lt;li&gt;关闭服务器上的指定服务，这里就需要支持远程调用，在windows上可以通过winrm执行远程服务调用。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;powershell&quot;&gt;PowerShell&lt;/h3&gt;
&lt;p&gt;Windows PowerShell 是专门为系统管理员设计的 Windows 命令行 Shell。 Windows PowerShell 包括可以单独或组合使用的交互提示和脚本编写环境。这里不探讨PowerShell的使用细节，因为这不是本篇文章的关注重点，具体的关于PowerShell的介绍可以看微软的官方文档&lt;a href=&quot;https://docs.microsoft.com/zh-cn/PowerShell/scripting/getting-started/getting-started-with-windows-PowerShell?view=powershell-6&quot;&gt;Windows PowerShell 入门&lt;/a&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;ftp上传插件&quot;&gt;FTP上传插件&lt;/h3&gt;
&lt;p&gt;jenkins上有支持的FTP插件，比如&lt;a href=&quot;https://wiki.jenkins.io/display/JENKINS/Publish+Over+FTP+Plugin&quot;&gt;Publish Over FTP Plugin&lt;/a&gt;,下载之后安装重启jenkins。&lt;/p&gt;
&lt;h4 id=&quot;插件配置&quot;&gt;插件配置&lt;/h4&gt;
&lt;p&gt;在系统管理-系统设置下找到&lt;code&gt;Publish over FTP&lt;/code&gt;项的设置，添加FTP服务的地址，端口，用户名和密码等相关配置，然后点击&lt;code&gt;TestConfiguration&lt;/code&gt;按钮，若显示Success表示配置成功。可以手工添加多个FTP配置。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190523203211858-2095195771.png&quot; alt=&quot;20190523203211.png&quot;/&gt;&lt;br/&gt;点击&lt;code&gt;Advanced&lt;/code&gt;按钮修改端口或超时时间等配置&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190523203430494-837364931.png&quot; alt=&quot;20190523203430.png&quot;/&gt;&lt;br/&gt;配置完成后到Job中添加FTP上传功能，在&lt;code&gt;Build&lt;/code&gt;中点击&lt;code&gt;Add Build step&lt;/code&gt;选择&lt;code&gt;Send file over FTP&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190523203623938-1070424322.png&quot; alt=&quot;20190523203623.png&quot;/&gt;&lt;br/&gt;在&lt;code&gt;Name&lt;/code&gt;通过下拉选择前面配置的FTP站点，在&lt;code&gt;Transfers&lt;/code&gt;配置需要上传的文件和上传到远程的目录。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190523203826159-127528585.png&quot; alt=&quot;20190523203825.png&quot;/&gt;&lt;br/&gt;&lt;code&gt;Source files&lt;/code&gt;:支持通配符，如上传所有文件&lt;code&gt;*.*&lt;/code&gt;，或&lt;code&gt;bin/Release/&lt;/code&gt;下的所有文件&lt;br/&gt;&lt;code&gt;Remove prefix&lt;/code&gt;:表示上传文件去除前缀，FTP默认会将文件的相对路径一起上传，若不需要&lt;code&gt;bin/Release&lt;/code&gt;则可以配置去除该相对路径，如&lt;code&gt;bin/Release/Test.exe&lt;/code&gt;上传到FTP上若没有指定FTP远程相对路径，则为FTP根目录下的&lt;code&gt;Test.exe&lt;/code&gt;文件。&lt;br/&gt;&lt;code&gt;Remote directory&lt;/code&gt;:表示上传到FTP目录下的哪个相对目录中，一般来说我们可以按Job名称分文件夹，可以通配置Jenkins内置的环境变量，如&lt;code&gt;$JOB_NAME&lt;/code&gt;/&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上传FTP前需要保证FTP上目录结构存在，否则会上传失败。因此上传FTP前需要通过脚本到服务器的FTP目录上创对应的文件夹路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说我们编译完成后需要将程序按版本号分目录存在，比如1.0.X的存放到1.0的目录中。2.0.X的存放到2.0的目录中。因此我们可以在&lt;code&gt;Remote directory&lt;/code&gt;填写&lt;code&gt;${JOB_NAME}/$PROCESS_VERSION&lt;/code&gt;,如下图所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190524142925277-689266010.png&quot; alt=&quot;20190524142924.png&quot;/&gt;&lt;br/&gt;而&lt;code&gt;$PROCESS_VERSION&lt;/code&gt;变量的值我们需要在前面的脚本中获取，由于在jenkins&lt;code&gt;Build&lt;/code&gt;步骤中创建的每个powershell脚本块，jenkins都会将其保存到临时的&lt;code&gt;XXXX.ps1&lt;/code&gt;脚本文件中，因此不同的步骤产生的变量是在不同的脚本文件中，也就是在不同的作用域中。因此在前面创建的脚本获取到的版本号，无法直接在下一个脚本中获取。&lt;/p&gt;
&lt;blockquote readability=&quot;3.1818181818182&quot;&gt;
&lt;p&gt;关于powershell的变量作用域可以查看&lt;a href=&quot;https://www.pstips.net/powershell-scope-of-variables.html&quot;&gt;Powershell变量的作用域&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如下图所示，第一个脚本中赋值的&lt;code&gt;$PROCESS_VERSION&lt;/code&gt;在后面的脚本以及FTP目录中都是获取不到该变量的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190524143519425-55044057.png&quot; alt=&quot;20190524143518.png&quot;/&gt;&lt;br/&gt;因此我们可以通过将变量保存到文件，然后重新载入到Jenkins的环境变量中，Jenkins的环境变量在Jenkins当前Job中都可以获取到。&lt;/p&gt;
&lt;h3 id=&quot;环境变量插件&quot;&gt;环境变量插件&lt;/h3&gt;
&lt;p&gt;使用Jenkins的环境变量插件&lt;a href=&quot;https://wiki.jenkins.io/display/JENKINS/EnvInject+Plugin&quot;&gt;EnvInject Plugin&lt;/a&gt;实现上述功能。安装完插件之后重启Jenkins。&lt;br/&gt;如果我们多个Job需要用到同样的参数常量，那我们可以将参数直接在Jenkins配置中注入到环境变量中，然后可以通过环境变量&lt;code&gt;$Env:XXXX&lt;/code&gt;获取到我们配置的变量值。&lt;/p&gt;
&lt;h4 id=&quot;配置全局环境变量&quot;&gt;配置全局环境变量&lt;/h4&gt;
&lt;p&gt;在系统管理-系统设置下找到&lt;code&gt;Global properties&lt;/code&gt;项，勾选环境变量，后即可设置全局的环境变量。这样当这些变量修改后，只需要在设置中修改一次，而无需修改每个Job中的脚本变量值。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190524144503085-620273042.png&quot; alt=&quot;20190524144502.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用环境变量&quot;&gt;使用环境变量&lt;/h4&gt;
&lt;p&gt;我们现在可以直接在Job中使用配置好的全局环境变量。在构建之后，可以在当前构建项的&lt;code&gt;Environment Variables&lt;/code&gt;查看到已加载的环境变量&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190524144818943-126083746.png&quot; alt=&quot;20190524144818.png&quot;/&gt;、&lt;/p&gt;
&lt;h4 id=&quot;从文件注入环境变量&quot;&gt;从文件注入环境变量&lt;/h4&gt;
&lt;p&gt;现在我们就可以将将版本号信息存入到文件中，然后重新加载到全局环境变量中了。&lt;br/&gt;首先在通过脚本获取到程序的版本号，将它保存到文件中，保存格式为&lt;code&gt;变量名=变量值&lt;/code&gt;，如将&lt;code&gt;PROCESS_VERSION=&quot;1.0.0.0&quot;&lt;/code&gt;保存到&lt;code&gt;Version.txt&lt;/code&gt;文件中。&lt;br/&gt;然后通过环境变量注入插件从文本中读取环境变量，在&lt;code&gt;Build&lt;/code&gt;中添加&lt;code&gt;Inject environment variables&lt;/code&gt;步骤，在&lt;code&gt;Properties File Path&lt;/code&gt;中填写&lt;code&gt;Version.txt&lt;/code&gt;，则会从文本中读取环境变量，多个环境变量通过换行分割。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/580757/201905/580757-20190524150234766-1763539437.png&quot; alt=&quot;20190524150233.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;默认PowerShell保存的格式是含有BOM的Unicode编码，而Jenkins读取ASCII编码格式。因此需要指定文本输出编码为ASCII&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;脚本执行&quot;&gt;脚本执行&lt;/h3&gt;
&lt;p&gt;通过Powershell脚本也可以调用.Net库将文件压缩或上传，这里暂时不讨论脚本编写细节问题。后续文章将给出完整的解决方案。&lt;/p&gt;
&lt;h3 id=&quot;远程调用&quot;&gt;远程调用&lt;/h3&gt;
&lt;p&gt;在Linux环境下可以通过SSH进行远程调用，而在Windows环境下则可以使用Windows 远程管理 (Windows Remote Management，简称WinRM)。&lt;br/&gt;WinRM是微软实现的WS-Management协议的, 这是一种基于标准的简单对象访问协议(SOAP), 由于它是基于防火墙友好的协议, 因此允许来自不同供应商的硬件和操作系统交互。关于WinRM具体的介绍可以查看&lt;a href=&quot;https://technet.microsoft.com/zh-cn/aa384426(v=vs.71)&quot;&gt;Windows Remote Management&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以理解为WinRM提供了一个服务端，同时向外暴露了相关的API，而同时Powershell可以与WinRM进行交互，即Powershell本身就是一个远程调用的客户端，通过Powershell执行相关的命令与WinRM交互，从而实现远程调用，执行自定义脚本，甚至是执行服务器上的指定路径下的脚本。&lt;/p&gt;
&lt;p&gt;因此我们若需要进行远程调用，首先在对应的服务器上需要开启WinRM的相关功能。&lt;/p&gt;
&lt;h4 id=&quot;启用winrm服务&quot;&gt;启用WinRM服务&lt;/h4&gt;
&lt;ol readability=&quot;36&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;快速配置&lt;/p&gt;
&lt;p&gt;微软为了简化WinRM的配置，提供了一个快捷命令进行默认的快速配置。通过调用&lt;code&gt;winrm quickconfig&lt;/code&gt;进行快速配置。如下返回则为正常配置成功&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Administrator&amp;gt; winrm quickconfig
在此计算机上，WinRM 已设置为接收请求。
WinRM 没有设置成为了管理此计算机而允许对其进行远程访问。
必须进行以下更改:

在 HTTP://* 上创建 WinRM 侦听程序接受 WS-Man 对此机器上任意 IP 的请求
启用 WinRM 防火墙异常。
配置 LocalAccountTokenFilterPolicy 以远程向本地用户授予管理权限。

进行这些更改吗[y/n]? y

WinRM 已经进行了更新，以用于远程管理。

在 HTTP://* 上创建 WinRM 侦听程序接受 WS-Man 对此机器上任意 IP 的请求
WinRM 防火墙异常已启用。
已配置 LocalAccountTokenFilterPolicy 以远程向本地用户授予管理权限。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，在我本地win10环境，无法执行快速配置，提示说网络连接类型是公用，但是我改为专用仍然还是报错,目前暂未解决。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Dm_ca&amp;gt; winrm quickconfig
已在此计算机上运行 WinRM 服务。
WSManFault
    Message
        ProviderFault
            WSManFault
                Message = 由于此计算机上的网络连接类型之一设置为公用，因此 WinRM 防火墙例外将不运行。 将网络连接类型更改为域或专用，然后再次尝试。

错误编号: -2144108183 0x80338169
由于此计算机上的网络连接类型之一设置为公用，因此 WinRM 防火墙例外将不运行。 将网络连接类型更改为域或专用，然后再次尝试。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;查看WinRM服务监听&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;winrm enumerate winrm/config/listener&lt;/code&gt;可以查看WinRM服务的当前监听信息&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Administrator&amp;gt; winrm enumerate winrm/config/listener
Listener
    Address = *
    Transport = HTTP
    Port = 5985
    Hostname
    Enabled = true
    URLPrefix = wsman
    CertificateThumbprint
    ListeningOn = 10.60.45.239, 127.0.0.1, XXXXXXXXXXX&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;若上一步快速配置没有成功，则会返回以下信息&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Dm_ca&amp;gt; winrm enumerate winrm/config/listener
WSManFault
    Message
        ProviderFault
            WSManFault
                Message = 拒绝访问。&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;启用远程调用&lt;/p&gt;
&lt;p&gt;通过输入&lt;code&gt;Enable-PSRemoting –Force&lt;/code&gt;启用Powershell远程调用功能。&lt;br/&gt;&lt;code&gt;powershell PS C:\Users\Administrator&amp;gt; Enable-PSRemoting –Force 在此计算机上，WinRM 已设置为接收请求。 WinRM 已经进行了设置，以用于在此计算机上进行远程管理。&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;启用Powershell本地脚本执行&lt;/p&gt;
&lt;p&gt;若需要在服务上执行本地脚本，则需要启用本地脚本执行权限。通过执行&lt;code&gt;set-ExecutionPolicy RemoteSigned&lt;/code&gt;允许本地脚本执行。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Administrator&amp;gt; set-ExecutionPolicy RemoteSigned

执行策略更改
执行策略可以防止您执行不信任的脚本。更改执行策略可能会使您面临 about_Execution_Policies
帮助主题中所述的安全风险。是否要更改执行策略?
[Y] 是(Y)  [N] 否(N)  [S] 挂起(S)  [?] 帮助 (默认值为“Y”): y&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;获取winrm客户端配置信息&lt;/p&gt;
&lt;p&gt;通过上述4个步骤，服务端的远程调用已经开启，由于winrm本身有白名单安全策略，因此需要配置以下客户端的配置，允许指定的ip执行远程调用。通过输入&lt;code&gt;winrm get winrm/config/client&lt;/code&gt;获取客户端配置。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;PS C:\Users\Administrator&amp;gt; winrm get winrm/config/client
Client
    NetworkDelayms = 5000
    URLPrefix = wsman
    AllowUnencrypted = false
    Auth
        Basic = true
        Digest = true
        Kerberos = true
        Negotiate = true
        Certificate = true
        CredSSP = false
    DefaultPorts
        HTTP = 5985
        HTTPS = 5986
    TrustedHosts&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;设置白名单地址&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TrustedHosts&lt;/code&gt;表示的是白名单地址。&lt;br/&gt;通过&lt;code&gt;Set-Item wsman:\localhost\client\trustedhosts *&lt;/code&gt;设置允许所有IP调用。&lt;br/&gt;通过&lt;code&gt;Set-Item wsman:\localhost\client\trustedhosts &quot;127.0.0.1,127.0.0.2&quot;&lt;/code&gt;设置允许指定IP调用&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;Set-Item wsman:\localhost\client\trustedhosts &quot;127.0.0.1,127.0.0.2&quot;

WinRM 安全配置。
此命令修改 WinRM 客户端的 TrustedHosts 列表。TrustedHosts
列表中的计算机可能不会经过身份验证。该客户端可能会向这些计算机发送凭据信息。是否确实要修改此列表?
[Y] 是(Y)  [N] 否(N)  [S] 暂停(S)  [?] 帮助 (默认值为“Y”): y
PS C:\WINDOWS\system32&amp;gt; winrm get winrm/config/client
Client
    NetworkDelayms = 5000
    URLPrefix = wsman
    AllowUnencrypted = false
    Auth
        Basic = true
        Digest = true
        Kerberos = true
        Negotiate = true
        Certificate = true
        CredSSP = false
    DefaultPorts
        HTTP = 5985
        HTTPS = 5986
    TrustedHosts = 127.0.0.1,127.0.0.2&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;客户端远程调用&lt;/p&gt;
&lt;p&gt;当设置好上述配置我们就可以测试以下远程调用是否完成，通过在d盘放一个&lt;code&gt;hellworld.ps1&lt;/code&gt;脚本，填写以下内容。&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;hello world!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以在本地powershell中输入以下指令测试远程调用是否正常返回hello world！&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;$account = &quot;administrator&quot;
$password = &quot;test1&quot;
$address=&quot;127.0.0.1&quot;
$secpwd = convertto-securestring $password -asplaintext -force
$cred = new-object System.Management.Automation.PSCredential -argumentlist $account,$secpwd
invoke-command -computername $address -Credential $cred  -command {d:helloworld.ps1}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;其中需要输入服务器的用户名和密码。通过&lt;code&gt;convertto-securestring&lt;/code&gt;将明文密码转换为安全字符串，这样避免了明文密码在网络上传输泄露。&lt;/li&gt;
&lt;li&gt;然后通过用户名和密码创建一个身份授权对象。&lt;/li&gt;
&lt;li&gt;最终通过&lt;code&gt;invoke-command&lt;/code&gt; 将服务器地址传入以及授权对象传入即可执行远程脚本调用。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;升级服务&quot;&gt;升级服务&lt;/h2&gt;
&lt;p&gt;通过powershell与winrm实现远程调用，服务升级就是将上传到FTP的程序替换原有的程序即可。&lt;/p&gt;
&lt;h2 id=&quot;启动服务&quot;&gt;启动服务&lt;/h2&gt;
&lt;p&gt;这里需要说明的一点是，控制台程序和含有GUI界面的程序可以通过调用命令杀掉进行实现关闭程序，但是要通过powershell启用相关的控制他程序或含有用户界面的程序，则很难做到。主要原因是在windows环境下远程命令执行和登录windows用户一样，都是基于会话执行。在Windows安全模型设计上，是不支持启动其他会话的程序。相关问题可以查看&lt;a href=&quot;https://serverfault.com/questions/690852/use-powershell-to-start-a-gui-program-on-a-remote-machine&quot;&gt;Use Powershell to start a GUI program on a remote machine&lt;/a&gt;。&lt;br/&gt;换句话说，在会话连接释放时，则会自动注销会话相关的资源。因此当WinRM远程调用结束后则会释放临时会话资源。&lt;/p&gt;
&lt;p&gt;为了实现启用GUI程序，可以使用&lt;a href=&quot;https://docs.microsoft.com/zh-cn/sysinternals/downloads/psexec&quot;&gt;PsExec&lt;/a&gt;。PsExec 是一款轻量级的远程替换设备, 可让您在其他系统上执行进程, 并为控制台应用程序提供完整的交互功能, 而无需手动安装客户端软件。对于PsExec具体使用暂时没有验证过，有时间后面再做探讨，这里不进行深究。&lt;/p&gt;
&lt;p&gt;另一种方案是Powershell所能实现的是，基于Windows的定时任务，可以设定在1分钟后启动GUI的exe文件。（Windows任务最小时间单位是1分钟）实际上来说服务中断1分钟可不是好事，虽然能实现启动服务，但是不建议使用，不做过多探讨。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;最好的方式是将服务器上的程序注册为Windows服务，那么就很好的支持服务的关闭和启动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文对Windows下的持续部署方案所设计到相关的技术进行了简单介绍，后续的持续集成将完全使用本篇文章设计到的Powershell脚本和远程调用相关技术实现，后续持续集成唯一的要点就是持续集成逻辑的脚本编写。在后续文章中，将会介绍powershell的压缩解压，ftp脚本上传，以及通过脚本生成差量更新包等具体工作。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/PowerShell/scripting/getting-started/getting-started-with-windows-PowerShell?view=PowerShell-6&quot;&gt;Windows PowerShell 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.pstips.net/powershell-scope-of-variables.html&quot;&gt;Powershell变量的作用域&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://technet.microsoft.com/zh-cn/aa384426(v=vs.71)&quot;&gt;Windows Remote Management&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/info/a410c623cb0de5396ce4330effb7efe3.html&quot;&gt;windows服务器远程执行命令（PowerShell+WinRM）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/weloveshare/p/5569719.html&quot;&gt;winServer-常用winrm命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://serverfault.com/questions/690852/use-powershell-to-start-a-gui-program-on-a-remote-machine&quot;&gt;Use Powershell to start a GUI program on a remote machine&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;blockquote readability=&quot;4&quot;&gt;
&lt;p&gt;本文地址：&lt;a href=&quot;https://www.cnblogs.com/Jack-Blog/p/10922038.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/Jack-Blog/p/10922038.html&lt;/a&gt;&lt;br/&gt;作者博客：杰哥很忙&lt;br/&gt;欢迎转载，请在明显位置给出出处及链接&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 25 May 2019 04:42:00 +0000</pubDate>
<dc:creator>杰哥很忙</dc:creator>
<og:description>本篇文章对Windows环境下持续部署的方案进行学习与研究，对相关的技术要点进行了梳理。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jack-Blog/p/10922038.html</dc:identifier>
</item>
<item>
<title>Java_AOP原理 - 周昌洋</title>
<link>http://www.cnblogs.com/zhouchangyang/p/10920202.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouchangyang/p/10920202.html</guid>
<description>&lt;p&gt;&lt;span&gt;AOP :&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面向切面编程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在程序设计中,我们需要满足高耦合低内聚,所以编程需满足六大原则,一个法则.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AOP面向切面编程正是为了满足这些原则的一种编程思想.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一.装饰者模式:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当我们需要给对象增加功能时,为了满足单一职责原则,可利用装饰者模式编程,创建一个类用来装饰原来的类,这个类写需要在原来的功能上增加的功能.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如:一个类里面有一个增加图书的功能,&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookSericeImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BookSerice {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addOne(BokBean bokBean) {
        System.out.println(&lt;/span&gt;&quot;执行逻辑:插入一本书&quot;&lt;span&gt;);
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deletOne(Long bookId) {
        System.out.println(&lt;/span&gt;&quot;执行逻辑:删除一本书&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们需要在这个基础上新增打印日志的功能,&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BooklogServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BookSerice {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BookSerice bookSerice;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BooklogServiceImpl(BookSerice bookSerice) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bookSerice =&lt;span&gt; bookSerice;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addOne(BokBean bokBean) {

        System.out.println(&lt;/span&gt;&quot;准备新增一本书&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.bookSerice.addOne(bokBean);
        System.out.println(&lt;/span&gt;&quot;新增一本书完成&quot;&lt;span&gt;);
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deletOne(Long bookId) {

        System.out.println(&lt;/span&gt;&quot;准备删除一本书&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bookSerice.deletOne(323L&lt;span&gt;);
        System.out.println(&lt;/span&gt;&quot;删除一本书完成&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面我们调用这个增强过后的的对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1(){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Aop :面向切面编程

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用装饰者模式设计对象&lt;/span&gt;
        BookSerice bookSerice = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookSericeImpl();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把原来功能的对象通过构造方传给新增功能的类,并把新增功能类的对象赋给原来对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里新增功能类和原来的类都是实现了同一个接口.&lt;/span&gt;
        bookSerice = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BooklogServiceImpl(bookSerice);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用新增功能类的方法,在这个方法里让构造方法传过去的对象调用原来的功能&lt;/span&gt;
        bookSerice.addOne(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BokBean());
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样我们就在不改变原来代码的基础上新增了功能,并且也满足单一职责的原则,降低了代码的耦合性.&lt;/p&gt;
&lt;p&gt;但是如果接口里面有很多方法,如果每个方法都需要增加日志功能,这样就会出现很多重复代码,并且装饰者模式不能同时为多个没有关系的类同时增强&lt;/p&gt;
&lt;p&gt;所以java引入动态代理技术来增加功能.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;二.动态代理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在java里动态代理有两个实现方式:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①针对有接口的类的代理,使用jdk中反射包下的动态代理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②针对没有接口的类的代理,使用第三方的jar包Enhancer&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果一个类既没有接口,又是final,那么不能进行增强&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.第一种实现:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;基于接口的动态代理,使用java内部反射包增强&lt;/p&gt;
&lt;p&gt;这种方式创建对象是目标对象的兄弟对象.&lt;/p&gt;

&lt;p&gt;&lt;span&gt;同样上面是实现了接口的两个功能的类:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BookSericeImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BookSerice {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; addOne(BokBean bokBean) {
        System.out.println(&lt;/span&gt;&quot;执行逻辑:插入一本书&quot;&lt;span&gt;);
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; deletOne(Long bookId) {
        System.out.println(&lt;/span&gt;&quot;执行逻辑:删除一本书&quot;&lt;span&gt;);&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
调用通过对象调用上面两个方法:
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2(){

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建需要代理的对象&lt;/span&gt;
    BookSerice bookSerice = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookSericeImpl();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据对象的类获取类加载器&lt;/span&gt;
    ClassLoader classLoader =&lt;span&gt; bookSerice.getClass().getClassLoader();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取被代理对象说实现的所有接口&lt;/span&gt;
    Class&amp;lt;?&amp;gt;[] interfaces =&lt;span&gt; bookSerice.getClass().getInterfaces();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;新建代理对象,里面参数需要(类加载器,一个对象所实现的接口,InvocationHandler接口类的对象)&lt;/span&gt;
    bookSerice = (BookSerice) Proxy.newProxyInstance(classLoader, interfaces, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LogHandler(bookSerice)); 
    bookSerice.addOne(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BokBean());
    bookSerice.deletOne(&lt;/span&gt;232L&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在创建代理对象的时候需要一个InvocationHandler接口类的对象,下面创建一个该类的实现类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LogHandler &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InvocationHandler {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过构造方法接受一个没有被代理的原来的对象
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过下面的方法名的反射找到这个对象对应方法&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object target;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; LogHandler(Object target) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当代理对象调用原方法的时候,就会调用这个invoke方法&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object invoke(Object proxy, Method method, Object[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        String classname &lt;/span&gt;=&lt;span&gt; target.getClass().getName();
        String methodName &lt;/span&gt;=&lt;span&gt; method.getName();
        System.out.println(classname&lt;/span&gt;+&quot;.&quot;+methodName+&quot;方法开始执行&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里实际是Method类通过方法名反射调用了原方法(addone)&lt;/span&gt;
        Object value =&lt;span&gt; method.invoke(target, args);
        System.out.println(classname&lt;/span&gt;+&quot;.&quot;+methodName+&quot;方法执行完毕&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; value;

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样实现了动态代理之后,不管实现的接口里有多少个方法,你只需调用该方法,就会增强该方法,而不需要针对每个方法写一遍增强功能,&lt;/p&gt;
&lt;p&gt;并且这个增强类LogHandler类和原来的实现类BookSericeImpl类并没有耦合性,这就是说不管你是什么接口类的实现类,只需要对该类的对象进行代理即可,就能对该类的方法添加上这个新增的功能&lt;/p&gt;
&lt;p&gt;总的来说,这种动态代理实现方式就是利用反射技术,找到调用的方法名,针对这个方法进行增强.&lt;/p&gt;
&lt;p&gt;如果当不需要对某方法增加功能时,就不用不带.&lt;/p&gt;

&lt;p&gt;2.第二种实现:&lt;/p&gt;
&lt;p&gt;基于类的动态代理,使用cglib框架.&lt;br/&gt;这种方式创建的代理对象是目标对象的子类对象&lt;/p&gt;
&lt;p&gt; 第二种方式是利用第三方jar包来实现,下载CGLIB包:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1546981/201905/1546981-20190525114629811-436030802.png&quot; alt=&quot;&quot; width=&quot;652&quot; height=&quot;135&quot;/&gt;&lt;/p&gt;
&lt;p&gt;利用jar包中的Enhancer类创建增强对象.&lt;/p&gt;
&lt;p&gt;创建增强对象需要根据原对象的类名创建类增强器,还需要根据原对象的类型创建子类代理对象&lt;/p&gt;
&lt;p&gt;属性通过增强对象set方法赋值,上一种方式是通过调用方法Proxy.newProxyInstance传参&lt;em id=&quot;__mceDel&quot;&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3(){

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建需要代理增强的对象&lt;/span&gt;
        BookSerice bookSerice = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BookSericeImpl();
        Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用增强器对象创建类增强器&lt;/span&gt;
&lt;span&gt;        enhancer.setClassLoader(bookSerice.getClass().getClassLoader());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为创建的代理对象是目标对象的子类,所以这里填的就是目标对象的类&lt;/span&gt;
&lt;span&gt;        enhancer.setSuperclass(bookSerice.getClass());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建代理对象,这里需要的参数是Callback接口的对象,所以需要创建一个接口的实现类.&lt;/span&gt;
        enhancer.setCallback(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimeMethodInterceptor(bookSerice));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把代理对象赋给原对象&lt;/span&gt;
        bookSerice =&lt;span&gt; (BookSerice) enhancer.create();
        bookSerice.addOne(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BokBean());
        bookSerice.deletOne(&lt;/span&gt;1l&lt;span&gt;);
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建Callback接口的实现类,也就是功能增强部分,&lt;/p&gt;
&lt;p&gt;这一部分跟第一种方式的实现是一样的,都是通过反射在添加功能过程中调用原方法.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Callback接口没有实现方法,所以这里实现的是他的子接口&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; TimeMethodInterceptor &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MethodInterceptor {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  Object target;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimeMethodInterceptor(Object target) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.target =&lt;span&gt; target;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Throwable {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录当前系统时间
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个时间是从1970年1月1日 0点0分到现在的毫秒数&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; start =&lt;span&gt; System.currentTimeMillis();
        Object value &lt;/span&gt;=&lt;span&gt; method.invoke(target, objects);
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; time = System.currentTimeMillis() -&lt;span&gt; start;
        System.out.println(&lt;/span&gt;&quot;当前时长&quot;+time+&quot;毫秒&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;总结:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;两种方法的区别:&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第一种是用jdk内部方法创建代理对象,由于创建过程中需要一个对象的接口,所以只能针对有接口类的对象进行代理.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;第二种是利用第三方jar包中的增强器(Enhancer)创建代理对象,通过set方法给需要的属性赋值.由于没有接口实现,所以创建的是对象的子类代理对象.&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 25 May 2019 04:10:00 +0000</pubDate>
<dc:creator>周昌洋</dc:creator>
<og:description>AOP : 面向切面编程 在程序设计中,我们需要满足高耦合低内聚,所以编程需满足六大原则,一个法则. AOP面向切面编程正是为了满足这些原则的一种编程思想. 一.装饰者模式: 当我们需要给对象增加功能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhouchangyang/p/10920202.html</dc:identifier>
</item>
</channel>
</rss>