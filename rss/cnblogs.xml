<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>YuniKorn 介绍 - 南风99</title>
<link>http://www.cnblogs.com/nanfeng99/p/11220143.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nanfeng99/p/11220143.html</guid>
<description>&lt;h3&gt;本文参考自：YuniKorn 中文官网：&lt;a title=&quot;YuniKorn 中文官网&quot; href=&quot;http://www.yunikorn.cn/&quot; target=&quot;_blank&quot;&gt;http://www.yunikorn.cn/&lt;/a&gt;&lt;/h3&gt;
&lt;h2&gt;一、YuniKorn 简介&lt;/h2&gt;
&lt;p&gt;YuniKorn 是一种轻量级的通用资源调度程序，适用于容器编排系统。它的创建是为了一方面在大规模，多租户环境中有效地实现各种工作负载的细粒度资源共享，另一方面可以动态地创建云原生环境。&lt;/p&gt;
&lt;p&gt;YuniKorn 为混合工作负载提供统一的跨平台调度体验，包括无状态批处理工作负载和状态服务，支持但不限于 YARN 和 Kubernetes。YuniKorn['ju:nikɔ:n] 是一个虚构的词，&quot;Y&quot;代表 YARN，&quot;K&quot;代表 K8s，&quot;Uni&quot;代表统一，其发音与&quot;Unicorn&quot;相同。创建它是为了最初支持这两个系统，但最终目的是创建一个可以支持任何容器协调器系统的统一调度程序。&lt;/p&gt;
&lt;h2&gt;二、YuniKorn 组件介绍&lt;/h2&gt;
&lt;p&gt;YuniKorn 目前有 4 个组件，如下所示：&lt;/p&gt;
&lt;p&gt;（1）yunikorn-scheduler-interface&lt;br/&gt;（2）yunikorn-core&lt;br/&gt;（3）yunikorn-k8shim&lt;br/&gt;（4）yunikorn-web&lt;/p&gt;
&lt;h2&gt;三、YuniKorn 组件功能&lt;/h2&gt;
&lt;p&gt;YuniKorn -scheduler-interface：调度程序接口是资源管理平台（如 YARN / K8s）将通过诸如 GRPC / 编程语言绑定之类的 API 与之交谈的抽象层。&lt;/p&gt;
&lt;p&gt;YuniKorn Core：YuniKorn Core 封装了所有调度算法，它从资源管理平台（如 YARN / K8s）下面收集资源，并负责资源分配请求。它决定每个请求的最佳部署位置，然后将响应分配发送到资源管理平台。调度程序核心与下层平台无关，所有通信都通过调度程序接口。&lt;/p&gt;
&lt;p&gt;Scheduler Shim Layers：调度程序 Shim 在主机系统内运行（如 YARN / K8s），它负责通过调度程序接口转换主机系统资源和资源请求，并将它们发送到调度程序核心。在做出调度程序决策时，它负责实际的 pod / 容器绑定。&lt;/p&gt;
&lt;p&gt;Scheduler UI：调度程序 UI 为已托管的节点，计算资源，应用程序和队列提供简单视图。&lt;/p&gt;
&lt;h2&gt;四、YuniKorn 诞生背景&lt;/h2&gt;
&lt;p&gt;很多企业用户在不同的平台上运行工作负载，例如 YARN 和 Kubernetes。他们需要使用不同的资源调度程序，以便规划其工作负载有效地在这些平台上运行。但是，在目前来看，调度程序生态系统是分散的，并且在很多方面不是很理想。例如：&lt;br/&gt;（1）YARN 具有批量工作负载的 Capacity Scheduler 和 Fair Scheduler。&lt;br/&gt;（2）K8s 具有服务的默认调度程序。对于批处理工作负载，社区有 Kube-batch，Poseidon，Rubix（Spark 的 Scheduler 扩展）。&lt;/p&gt;
&lt;h2&gt;五、YuniKorn 架构设计&lt;/h2&gt;
&lt;p&gt;YuniKorn 的其中一个设计目标是将调度程序与下面的资源管理系统分离，为此，YuniKorn创建了一个定义通信协议的通用调度程序接口。通过利用它，scheduler-core 和 shim 一起工作来处理调度请求。关于 YuniKorn 架构设计，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;yk.jpeg&quot; src=&quot;http://www.yunikorn.cn/usr/uploads/2019/07/3241922163.jpeg&quot; alt=&quot;yk.jpeg&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、YuniKorn 的调度功能特性&lt;/h2&gt;
&lt;p&gt;以下是 YuniKorn 目前支持的调度功能列表：&lt;/p&gt;
&lt;p&gt;（1）调度功能支持批处理作业和长期运行 / 有状态服务&lt;/p&gt;
&lt;p&gt;（2）具有最小 / 最大资源配额的分层池 / 队列&lt;/p&gt;
&lt;p&gt;（3）队列，用户和应用程序之间的资源公平性&lt;/p&gt;
&lt;p&gt;（4）基于公平性的跨队列抢占&lt;/p&gt;
&lt;p&gt;（5）自定义资源类型（如 GPU）调度支持&lt;/p&gt;
&lt;p&gt;（6）丰富的编排约束支持&lt;/p&gt;
&lt;p&gt;（7）根据策略自动将传入的容器请求映射到队列&lt;/p&gt;
&lt;p&gt;（8）对节点使用专用配额 / ACL 管理将大的集群拆分成若干子群集&lt;/p&gt;

&lt;h2&gt;七、参考&lt;/h2&gt;
&lt;h4&gt;YuniKorn 中文官网：&lt;a title=&quot;YuniKorn 中文官网&quot; href=&quot;http://www.yunikorn.cn/&quot; target=&quot;_blank&quot;&gt;http://www.yunikorn.cn/&lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Sun, 21 Jul 2019 00:14:00 +0000</pubDate>
<dc:creator>南风99</dc:creator>
<og:description>本文参考自：YuniKorn 中文官网：http://www.yunikorn.cn/ 一、YuniKorn 简介 YuniKorn 是一种轻量级的通用资源调度程序，适用于容器编排系统。它的创建是为了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nanfeng99/p/11220143.html</dc:identifier>
</item>
<item>
<title>jmeter_遍历转换浮点时间戳 - 飞天小子</title>
<link>http://www.cnblogs.com/Zfc-Cjk/p/11220088.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Zfc-Cjk/p/11220088.html</guid>
<description>&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;近期帮朋友解决了一个浮点时间戳转换的问题，在这里记录一下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体场景是有一个十位浮点时间戳的list，需要遍历转换为当前的标准时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;list如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201907/946454-20190721055950176-2046287867.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;实现步骤&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;实现步骤其实很简单，只需要一个foreach控制器，和一段转换时间戳的代码&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;第一步把时间戳提取出来&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201907/946454-20190721060324423-1649703080.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201907/946454-20190721060350661-1723121168.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;第二步把提取的时间戳传入&lt;span&gt;&lt;strong&gt;foreach&lt;/strong&gt;&lt;/span&gt;控制器，然后在控制器下面遍历转换&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201907/946454-20190721060542785-1137062462.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201907/946454-20190721060604480-634869037.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.text.SimpleDateFormat;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Calendar;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Date;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10位的秒级时间戳&lt;/span&gt;
&lt;span&gt;long&lt;/span&gt; time1 =&lt;span&gt; ${start};
String result1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(&lt;span&gt;new&lt;/span&gt; Date(time1 * 1000&lt;span&gt;));
vars.put(&lt;/span&gt;&quot;result1&quot;&lt;span&gt;,result1);
log.info(&lt;/span&gt;&quot;10位时间戳（秒）---&amp;gt;Date:&quot; +&lt;span&gt;result1);

 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;13位的毫秒级时间戳
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;double time2 = 1515730332000d;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;String result2 = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(time2);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;System.out.println(&quot;13位数的时间戳（毫秒）---&amp;gt;Date:&quot; + result2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;最后在log日志中观察结果&lt;/h3&gt;
&lt;h3&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201907/946454-20190721060719166-1471701932.png&quot; alt=&quot;&quot; width=&quot;700&quot;/&gt;&lt;/h3&gt;
&lt;h2&gt;&lt;span&gt;结论：操作很简单，只不过各种元件之间的组合使用需要多加思考和练习。&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;微信公众号搜索 &lt;span&gt;测试驿栈&lt;/span&gt;，回复mock，会下发mock接口让各位练习&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/946454/201907/946454-20190721061132838-245421892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jul 2019 22:18:00 +0000</pubDate>
<dc:creator>飞天小子</dc:creator>
<og:description>概述 近期帮朋友解决了一个浮点时间戳转换的问题，在这里记录一下。 具体场景是有一个十位浮点时间戳的list，需要遍历转换为当前的标准时间。 list如下： 实现步骤 实现步骤其实很简单，只需要一个fo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Zfc-Cjk/p/11220088.html</dc:identifier>
</item>
<item>
<title>C#跟Lua如何超高性能传递数据 - 李嘉的博客</title>
<link>http://www.cnblogs.com/lijiajia/p/11219964.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijiajia/p/11219964.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在&lt;strong&gt;UWA学堂&lt;/strong&gt;上线那天，我买了&lt;strong&gt;招文勇&lt;/strong&gt;这篇Lua交互的课程，19块还算值，但是前段时间太忙，一直没空研究，他的demo是基于xlua的，今天终于花了大半天时间在tolua下跑起来了，记录一下我的理解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-bc1ec1b21bec3a48.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;性能仍然是lua中与c混用的大坑&quot;&gt;性能，仍然是Lua中与C＃混用的大坑&lt;/h2&gt;
&lt;p&gt;Lua跟C#交互的性能问题是老生常谈的了，c#跟lua数据交互是通过lua虚拟栈，进行压栈、出栈来传递的，一次调用就需要执行很多指令，性能会随着调用次数的频繁，函数参数的增多而变差。直接操作内存的方式，可以在c#端修改lua内存，&lt;strong&gt;省去了操作虚拟栈，函数调用的大把指令，性能也就很高效了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;腾讯的UnLua（给虚幻4用的）中也有类似的直接操作内存的交互方式，看来这种方式会渐渐成为主流，毕竟性能摆在这呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/1208599-69691555cba4b0e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;UnLua&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;lua跟c高效共享大量数据的一种方法&quot;&gt;Lua跟C#高效共享大量数据的一种方法&lt;/h2&gt;
&lt;p&gt;原理其实很简单，在c#端定义好lua table的结构体，必须在内存中对齐lua端的table，然后在c#端拿到lua table的指针，读写这块内存，就能读写这个lua table了。&lt;/p&gt;
&lt;p&gt;是不是觉得非常简单，哈哈哈哈。感觉自己马上就能弄出来了&lt;/p&gt;
&lt;h2 id=&quot;想要实现这套东西还得搞懂几个问题下面开始一一讲解&quot;&gt;想要实现这套东西，还得搞懂几个问题，下面开始一一讲解&lt;/h2&gt;
&lt;h3 id=&quot;lua-table结构体是什么样的&quot;&gt;Lua Table结构体是什么样的？&lt;/h3&gt;
&lt;p&gt;想在c#端写一个lua table结构体，那就先看看lua端这个结构体是怎么实现的吧。在tolua下，我们使用的是luajit，jit的源码跟lua是不一样的，luajit又分32位跟64位。所以我们这个table结构体也需要做多套才行&lt;/p&gt;
&lt;p&gt;luajit中的GCTab就是Table的结构体了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct GCtab {
  GCHeader;
  uint8_t nomm;     /* Negative cache for fast metamethods. */
  int8_t colo;      /* Array colocation. */
  MRef array;       /* Array part. */
  GCRef gclist;
  GCRef metatable;  /* Must be at same offset in GCudata. */
  MRef node;        /* Hash part. */
  uint32_t asize;   /* Size of array part (keys [0, asize-1]). */
  uint32_t hmask;   /* Hash part mask (size of hash part - 1). */
#if LJ_GC64
  MRef freetop;     /* Top of free elements. */
#endif
} GCtab;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GCHeader是每一个GC对象都要包含的一个宏，定义了这些属性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#define GCHeader    GCRef nextgc; uint8_t marked; uint8_t gct&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;lua的table支持数组、哈希表两种用法，甚至可以同时是数组又是哈希表。我们主要处理数组的数据交互，结构体中的&lt;strong&gt;MRef array;&lt;/strong&gt;就是这个table的所有数据存储的地方了，而asize就等于这个数组的长度+1。所以我们重点关注这&lt;strong&gt;2个字段的内存地址&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何设计c端的table结构体呢&quot;&gt;如何设计c#端的table结构体呢？&lt;/h3&gt;
&lt;p&gt;我们把GCTab结构体展开成这样看&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GCRef nextgc; 
uint8_t marked; uint8_t gct; uint8_t nomm; int8_t colo;
MRef array;
GCRef gclist;
GCRef metatable;
MRef node;
uint32_t asize;
uint32_t hmask;
MRef freetop;//这个是64位的才会有&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;GCRef 跟 MRef 都是一个jit中封装的指针类型，会自动根据宏展开为32位跟64位。&lt;br/&gt;GCRef 表示这是一个GC对象的指针&lt;br/&gt;MRef 表示非GC对象的内存指针&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在c#中都可以用IntPtr类型代替&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;uint8_t 是8字节的，我们把4个8字节的放在一起，可以用一个int32位占用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么转换到c#中，结构体就变成了这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// GC64 version
public struct LuaJitGCtabGC64
{
    IntPtr nextgc;

    UInt32 masks;

    IntPtr array;

    IntPtr gclist;

    IntPtr metatable;

    IntPtr node;

    UInt32 asize;

    UInt32 hmask;

    IntPtr freetop; // only valid for LJ_GC64
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;指针array指向的数据是什么&quot;&gt;指针array指向的数据是什么？&lt;/h2&gt;
&lt;p&gt;在lj_tab.c中看tab的实现，我们很快就能找到array里存的是&lt;strong&gt;TValue结构&lt;/strong&gt;，TValue其实是一个联合体。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;联合体是多个结构体可以共享同一块内存，访问的时候可以用不同的结构体方式去访问。具体什么是联合体可以自行百度哦&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;TValue源码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/* Tagged value. */
typedef LJ_ALIGN(8) union TValue {
  uint64_t u64;     /* 64 bit pattern overlaps number. */
  lua_Number n;     /* Number object overlaps split tag/value object. */
#if LJ_GC64
  GCRef gcr;        /* GCobj reference with tag. */
  int64_t it64;
  struct {
    LJ_ENDIAN_LOHI(
      int32_t i;    /* Integer value. */
    , uint32_t it;  /* Internal object tag. Must overlap MSW of number. */
    )
  };
#else
  struct {
    LJ_ENDIAN_LOHI(
      union {
    GCRef gcr;  /* GCobj reference (if any). */
    int32_t i;  /* Integer value. */
      };
    , uint32_t it;  /* Internal object tag. Must overlap MSW of number. */
    )
  };
#endif
#if LJ_FR2
  int64_t ftsz;     /* Frame type and size of previous frame, or PC. */
#else
  struct {
    LJ_ENDIAN_LOHI(
      GCRef func;   /* Function for next frame (or dummy L). */
    , FrameLink tp; /* Link to previous frame. */
    )
  } fr;
#endif
  struct {
    LJ_ENDIAN_LOHI(
      uint32_t lo;  /* Lower 32 bits of number. */
    , uint32_t hi;  /* Upper 32 bits of number. */
    )
  } u32;
} TValue;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这中间有很多宏，看着很乱，但其实我们只需要用2种模式就行了，因为我们只实现int跟double。作者给出的方式是如下这种&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[StructLayout(LayoutKind.Explicit, Size = 8)]
public struct LuaJitTValue
{
    // uint64
    [FieldOffset(0)]
    public UInt64 u64;

    // number
    [FieldOffset(0)]
    public double n;

    // integer value
    [FieldOffset(0)]
    public int i;

    // internal object tag for GC64
    [FieldOffset(0)]
    public Int64 it64;

    // internal object tag
    [FieldOffset(4)]
    public UInt32 it;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;但这里我有一些我还没弄明白，因为我实际运行起来后，不管lua赋值的是整形，还是浮点，int i始终没有值，值都存在了double n中。那为啥作者要弄一个int i跟UInt32 it; 这个it还偏移了4字节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在c#端我们可以使用&lt;strong&gt;[StructLayout(LayoutKind.Explicit)]&lt;/strong&gt;和&lt;strong&gt;[FieldOffset(0)]&lt;/strong&gt;来实现c语言中的联合体，具体方式可以看这篇文章&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/wonengxing/article/details/44302661&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/wonengxing/article/details/44302661&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何用unsafe模式读写结构体&quot;&gt;如何用unsafe模式读写结构体?&lt;/h2&gt;
&lt;p&gt;结构体都定义好了，接下来我们看看怎么读写一个double&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;LuaJitGCtab32* TableRawPtr; //需要拿到Lua端Table的指针

 //赋值操作
TableRawPtr-&amp;gt;array[index].n = val;
//取值操作
TableRawPtr-&amp;gt;array[index].n;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;没错，就是这么简单。直接就可以操作lua内存了。&lt;/p&gt;
&lt;h2 id=&quot;如何拿到lua端table的指针&quot;&gt;如何拿到lua端table的指针?&lt;/h2&gt;
&lt;p&gt;在lua端传入一个table参数过来，我们可以在c#端操作虚拟栈转成指针&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.IntPtr arg0 = LuaDLL.lua_topointer(L, 1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里，相信大部分的谜团都已经解开了，真的自己可以实现一套出来了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;作者提供的方案里，只支持int、double。只支持array类型的table。还有luajit64位貌似没支持好。所以如果真正要使用的话，还要改很多东西&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jul 2019 16:58:00 +0000</pubDate>
<dc:creator>李嘉的博客</dc:creator>
<og:description>前言 在 UWA学堂 上线那天，我买了 招文勇 这篇Lua交互的课程，19块还算值，但是前段时间太忙，一直没空研究，他的demo是基于xlua的，今天终于花了大半天时间在tolua下跑起来了，记录一下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lijiajia/p/11219964.html</dc:identifier>
</item>
<item>
<title>JavaScript函数及闭包 - 吸血鬼小姐姐</title>
<link>http://www.cnblogs.com/jiaobaba/p/11218624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiaobaba/p/11218624.html</guid>
<description>&lt;p&gt;&lt;span&gt;前面一片文章讲到过一点函数，了解到每声明一个函数就会产生一个作用域。而外面的作用域访问不了里面的作用域（把里面的变量和函数&lt;span&gt;隐藏&lt;/span&gt;起来），而里面的可以访问到外面的。&lt;/span&gt;&lt;span&gt;对于隐藏变量和函数是一个非常有用的技术。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;基于作用域隐藏的方法叫做&lt;span&gt;最小授权&lt;/span&gt;或&lt;span&gt;最小暴露原则&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个原则是指在软件设计中，应该最小限度的暴露必要内容，而将其内容都隐藏起来，比如某个模块或对象得API设计。&lt;/span&gt;&lt;span&gt;&lt;span&gt;隐藏变量和函数可以解决同名标识符的之间的冲突&lt;/span&gt;，冲突会导致变量的意外覆盖。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    　　 &lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 3&lt;span&gt;;
            console.log(a);
        }
        foo();
        console.log(a);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;虽然这种技术可以解决一些问题，但是他并不理想，会导致一些额外的问题，首先必须声明一个具名函数foo（），意味着foo这个名称本身“污染”了所在的作用域，其次必须显式的通过函数名foo（）调用这个函数才能运行其中的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果函数不需要函数名，并且能够自动运行，这会更加理想。幸好js提供了同时解决这两个问题的方案 -- (IIFE) Immediately Invoked Function Expression  --  &lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;立即执行函数&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 3&lt;span&gt;;
    console.log(a);
})()
console.log(a);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;首先&lt;span&gt;立即执行函数&lt;/span&gt;不会当做函数声明处理而&lt;span&gt;是&lt;/span&gt;当做&lt;span&gt;函数表达式&lt;/span&gt;处理。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;区分函数声明还是函数表达式：&lt;/span&gt;看function在声明中是不是第一个词，如果是第一个词就是函数声明否则就是函数表达式。而立即执行函数&quot; (function &quot;，不是&quot;     function &quot;,所以是函数表达式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;函数声明&lt;/span&gt;和&lt;span&gt;函数表达式之间&lt;/span&gt;&lt;/span&gt;&lt;span&gt;最&lt;span&gt;重要&lt;/span&gt;的区别&lt;/span&gt;&lt;span&gt;是他们的名称标识符将会绑定在何处&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数声明的函名称数会绑定在当前作用域内。假如在全局作用域创建一个函数声明，就可以在全局作用域访问这个函数名称并执行。而函数表达式的函数名称会绑定在自身的函数中，而不是当前说在作用域中。例如你全局创建一个函数表达式，如果你直接执行这个你创建的函数表达式的函数名就会报错，因为当前作用域下没有这个标识符，而你在函数表达式里面的作用域里访问这个函数名就会返回这个函数的引用。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;作用域闭包，嗯，闭包这儿两个字就有点让人难以理解，（可以想象成一个包是关上的，里面隐藏了一些神秘的东西）而对于闭包的定义是这样说的：当函数可以记住并访问所在的作用域时，就产生了闭包，即使函数是在当前作用域之外执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;for instance（拽个英文，哈哈）。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
        console.log(a);
    }
    bar();
}
foo();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;上面的 代码bar()可以访问外部作用域中的变量。根据上面的定义这是闭包吗？从技术来讲也许是，但我们理解的是作用域在当前作用域查找变量如果没找到会继续向上面查找，找到返回，找不到继续找，直到全局作用域。-- 而这些正是闭包的一部分。函数bar()具有一个涵盖foo()作用域的闭包。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a  = 2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar (){
        console.log(a);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bar;
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; baz =&lt;span&gt; foo();
baz();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;在上面的代码更好的展示了闭包。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;bar()函数在定义时作用域以外的地方执行（此时在全局作用域执行）。在foo()函数执行后，通常会期待foo()整个内部作用域都被销毁，因为我们知道引擎有&lt;span&gt;垃圾回收器&lt;/span&gt;用来&lt;span&gt;释放不在使用的内存空间&lt;/span&gt;，由于foo（）已经执行完，看上去内容不会再被使用，所以很自然的会考虑对齐进行回收，回收后意味着里面的函数和变量访问不到了。foo（）执行完，baz变量存着bar函数的引用。当执行baz也就是bar函数时。console.log(a)。不理解闭包的人可能认为会报错，事实上，打印的是2；？？？what？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;foo（）函数作用域不是执行完销毁了吗？怎么还能访问到a变量？-- &lt;/span&gt;&lt;span&gt;&lt;span&gt;这就是闭包。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;当foo（）执行后，bar函数被返回全局作用域下，但是bar函数还保留着当时的词法作用域（当时写代码是的顺序就已经定义了作用域，这个作用域叫词法作用域--外面函数套着里面的函数的那种）甚至直到全局作用域。所以bar还留有foo()函数的引用。使得foo（）函数没有被回收。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;闭包可以说不出不在，只是你没有发现认出他。在定时器，事件监听器，ajax请求，跨窗口通信或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是使用闭包。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;for instance&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; wait(message) {
    setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer() {
        console.log(message);
    }, &lt;/span&gt;1000&lt;span&gt;);
}
wait(&lt;/span&gt;&quot;hello&quot;);
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;在上面的代码中将一个内部函数（名为timer）传递给setTimerout(...).timer具有涵盖wait（...）的作用域的闭包。因此还保有对变量message的引用。wait()执行1000毫秒后，它的内部作用域不会消失，timer函数依然保有wait（）作用域的闭包。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;而闭包和立即执行函数息息相关。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;循环和闭包&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt;= 5; i++&lt;span&gt;){
    setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer(){
        console.log(i);
    },i&lt;/span&gt;*1000&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;span&gt;&lt;span&gt;上面代码我们以为输出的会是1-5，可事实上输出的是5个6，这是为啥啊 -- 闭包啊。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;延迟函数的回调会在循环结束时执行。事实上，当定时器运行时即使每个迭代的是setTimerout(...,0),所有的回调函数依然是循环结束后才会执行。我猜是跟js执行机制有关系吧。至于为什么都是6. 因为即使5个函数是在各个迭代中分别定义的，但是他们又被封闭在一个共享的全局作用域中因此实际上只有一个i.而怎么解决呢，立即执行函数来了！！！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 1; i &amp;lt;= 5; i++&lt;span&gt;) {
    (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (i) {
        setTimeout(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timer() {
            console.log(i);
        }, i &lt;/span&gt;* 1000&lt;span&gt;);
    })(i)

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;span&gt;打印出来1,2,3,4,5了欧，这回是你想要的数了。解释一下，5次循环创建了5个立即执行函数，这5个函数的作用域都不相同，立即函数接收的参数是当前循环的i.所以当timer执行时访问的就是自己立即执行函数对应的作用域。也就是说5个timer函数分别对应5个作用域，每个作用域保存的变量i都不同，解决啦！！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;你懂闭包了吗？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;js执行机制&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span class=&quot;bjh-p&quot;&gt;JavaScript语言的一大特点就是单线程，也就是说，&lt;span class=&quot;bjh-strong&quot;&gt;同一个时间只能做一件事。那么，为什么JavaScript不能有多个线程呢？这样能提高效率啊。&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;bjh-p&quot;&gt;JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准&lt;/span&gt;&lt;span class=&quot;bjh-p&quot;&gt;所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;bjh-p&quot;&gt;单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。JavaScript语言的设计者意识到这个问题，将所有任务分成两种，&lt;span class=&quot;bjh-strong&quot;&gt;一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;bjh-p&quot;&gt;主线程从&quot;任务队列&quot;中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。只要主线程空了，就会去读取&quot;任务队列&quot;，这就是JavaScript的运行机制。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;bjh-h3&quot;&gt;哪些语句会放入异步任务队列及放入时机&lt;/span&gt;&lt;span class=&quot;bjh-p&quot;&gt;一般来说，有以下四种会放入异步任务队列：&lt;/span&gt;&lt;span class=&quot;bjh-ol&quot;&gt;&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;setTimeout 和 setlnterval  ，&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;DOM事件，&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;ES6中的Promise，&lt;span class=&quot;bjh-li&quot;&gt;&lt;span class=&quot;bjh-p&quot;&gt;Ajax异步请求&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jul 2019 16:31:00 +0000</pubDate>
<dc:creator>吸血鬼小姐姐</dc:creator>
<og:description>前面一片文章讲到过一点函数，了解到每声明一个函数就会产生一个作用域。而外面的作用域访问不了里面的作用域（把里面的变量和函数隐藏起来），而里面的可以访问到外面的。对于隐藏变量和函数是一个非常有用的技术。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiaobaba/p/11218624.html</dc:identifier>
</item>
<item>
<title>单链表的基本操作(一） - tuxiaoping</title>
<link>http://www.cnblogs.com/1121518wo/p/11219934.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/1121518wo/p/11219934.html</guid>
<description>&lt;p&gt;一、单链表的初始化：&lt;/p&gt;
&lt;p&gt;1、生成新结点作为头结点，用头指针L指向头结点&lt;/p&gt;
&lt;p&gt;2、头结点的指针域置空&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Status InitList(LinkList &amp;amp;&lt;span&gt;L)
{ 
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造一个空的单链表L&lt;/span&gt;
   L=&lt;span&gt;new&lt;/span&gt; LNode ;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成新结点作为头结点，用头指针L指向头结点&lt;/span&gt;
   L-next=NuLL;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;头结点的指针域置空&lt;/span&gt;
   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ok;
 
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、取值：&lt;/p&gt;
&lt;p&gt;1、用指针p指向首元结点，用j做计数器初值赋为1&lt;/p&gt;
&lt;p&gt;2、从首元结点开始依次顺着链域next向下访问，只要指向当前结点的指针p不为空（NULL）,并且没有到达序号为i的结点，则循环执行以下操作： a、p指向下一个结点   b、计数器j相应加1  c、退出循环时，如果指针p为空，或者计数器j大于i，说明指定的序号i值不合法（i大于表长n或i小于等于0），取值失败返回ERROR;否则取值成功，此时j=i时，p所指的结点就是要找的第i个结点，用参数e保存当前结点的数据域，返回ok。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Status GetElem(LinkList L,&lt;span&gt;int&lt;/span&gt; i,ElemType &amp;amp;&lt;span&gt;e)
{
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在带头结点的单链表L中根据序号i获取元素的值，用e返回L中第i个数据元素的值&lt;/span&gt;
     p=L-&amp;gt;&lt;span&gt;next;
      j&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化，p指向首元结点，计数器j初值为1&lt;/span&gt;
      &lt;span&gt;while&lt;/span&gt;(p&amp;amp;&amp;amp;j&amp;lt;i)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺链表向后扫描，直到p为空或p指向第i个元素&lt;/span&gt;
&lt;span&gt;      {
          p&lt;/span&gt;=p-&amp;gt;next; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;p指向下一个结点&lt;/span&gt;
          ++j;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计数器j相应加1&lt;/span&gt;
&lt;span&gt;      }
     &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!p || j&amp;gt;i) &lt;span&gt;return&lt;/span&gt;  ERROR;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;i值不合法i&amp;gt;n或i&amp;lt;=0&lt;/span&gt;
    e=p-&amp;gt;data;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取第i个结点的数据域&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ok;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、查找：&lt;br/&gt;1、用指针p指向首元结点&lt;/p&gt;
&lt;p&gt;2、从首元结点开始依次顺着链域next向下查找，只要指向当前结点的指针p不为空，并且p所指结点的数据域不等于给定值e,则循环执行以下操作，：p指向下一个结点&lt;/p&gt;
&lt;p&gt;3、返回p，若查找成功，p此时即为结点的地址值，若查找失败，p的值即为NULL。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
LNode *&lt;span&gt;LocateElem(LinkList L,ElemType e)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在带头结点的单链表L中查找值为e的元素&lt;/span&gt;
    p=L-&amp;gt;next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化，p指向首元结点&lt;/span&gt;
   &lt;span&gt;while&lt;/span&gt;(p &amp;amp;&amp;amp; p-&amp;gt;data !=e)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顺着链表向后扫描，直到p为空域或p所指结点的数据域等于e&lt;/span&gt;
&lt;span&gt;  {
     p&lt;/span&gt;=p-&amp;gt;next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;p指向下一个结点&lt;/span&gt;
     &lt;span&gt;return&lt;/span&gt; p;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;成功查找返回值为e的结点地址为p,查找失败p为NULL&lt;/span&gt;
&lt;span&gt;
}


}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、插入&lt;/p&gt;
&lt;table border=&quot;0&quot; cellspacing=&quot;100&quot; cellpadding=&quot;100&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;a    -------指针域，且指向x&lt;/td&gt;
&lt;td&gt;b------指针域&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;table border=&quot;0&quot; cellspacing=&quot;100&quot; cellpadding=&quot;100&quot; align=&quot;left&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;   x------指针域，且指向b&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;说明：为插入数据元素x，首先要生成一个数据域为x的结点，然后插入到单链表中，根据插入操作的逻辑定义，还需要修改结点a中的指针域，令其指向 结点x，而结点x中的指针域应指向节点b，从而实现3个元素a、b、x之间逻辑关系的变化。&lt;/p&gt;
&lt;p&gt;算法步骤：&lt;/p&gt;
&lt;p&gt;将值为e的新结点插入到表的第i个结点的位置上，即插入到结点a与b之间，具体插入过程如下：&lt;/p&gt;
&lt;p&gt;1、查找结点a，并由指针p指向该结点&lt;/p&gt;
&lt;p&gt;2、生成一个新的结点*s&lt;/p&gt;
&lt;p&gt;3、将新的结点*s的数据域设置为e&lt;/p&gt;
&lt;p&gt;4、将新的结点*s 的指针域指向结点b&lt;/p&gt;
&lt;p&gt;5、将结点*p的指针域指向新结点*s           &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Status ListInsert(LinkList &amp;amp;L,&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i,ElemType e)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在带头结点的单链表L中第i个位置插入值为e 的新结点&lt;/span&gt;
   p=&lt;span&gt;L;
   j&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(p&amp;amp;&amp;amp; (j&amp;lt;i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
  {
      p&lt;/span&gt;=p-&amp;gt;&lt;span&gt;next;
      &lt;/span&gt;++j;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查找第i-1个结点，p指向该结点&lt;/span&gt;
&lt;span&gt;   }
   &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!p ||j&amp;gt;i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ERROR;
    s&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; LNode;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成一个新的结点*s&lt;/span&gt;
    s-&amp;gt;data=e;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将结点*s的数据域设置为e&lt;/span&gt;
   s-&amp;gt;next=p-&amp;gt;next;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将结点*s的指针域指向结点b&lt;/span&gt;
    p-&amp;gt;next=s;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将结点*p的指针域指向结点*s&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ok;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 20 Jul 2019 16:31:00 +0000</pubDate>
<dc:creator>tuxiaoping</dc:creator>
<og:description>一、单链表的初始化： 1、生成新结点作为头结点，用头指针L指向头结点 2、头结点的指针域置空 二、取值： 1、用指针p指向首元结点，用j做计数器初值赋为1 2、从首元结点开始依次顺着链域next向下访</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/1121518wo/p/11219934.html</dc:identifier>
</item>
<item>
<title>Java中lambda表达式详解 - 付威的网络博客</title>
<link>http://www.cnblogs.com/OceanHeaven/p/11218661.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/OceanHeaven/p/11218661.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.laofu.online/2018/04/20/java-lambda/&quot;&gt;http://blog.laofu.online/2018/04/20/java-lambda/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;为什么使用lambda&quot;&gt;为什么使用lambda&lt;/h2&gt;
&lt;p&gt;在java中我们很容易将一个变量赋值，比如int a =0;int b=a;&lt;/p&gt;
&lt;p&gt;但是我们如何将一段代码和一个函数赋值给一个变量？这个变量应该是什么的类型？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720175256768-1074746286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在javascript中，可以用一个对象来存储。   &lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; t=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;()
{
  &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a=1&lt;span&gt;;
  a&lt;/span&gt;=a+1&lt;span&gt;;
  alert(a);
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在java中，直到java8的lambda的特性问世，才有办法解决这个问题&lt;/p&gt;
&lt;h2 id=&quot;什么是lambda&quot;&gt;什么是lambda&lt;/h2&gt;
&lt;p&gt;什么是lambda? lambda在程序中到底是怎样的一个存在？ 首先看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; eat 
{
  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatFood();
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) 
{

  eat e &lt;/span&gt;= () -&amp;gt; System.out.printf(&quot;hello\n&quot;&lt;span&gt;);
  e.eatFood();
  
  eat e1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; eat() 
  {
      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatFood() 
      {
          System.out.printf(&lt;/span&gt;&quot;anoymous class\n&quot;&lt;span&gt;);
      }
  };
  e1.eatFood();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面的代码中，e是一个lambda的对象,根据java的继承的特性，我们可以说e对象的类型是继承自eat接口。而e1是一个正常的匿名类的对象.&lt;/p&gt;
&lt;p&gt;通过对比， 可以说 lambda的表达式其实是接口的实现的“另一种方式”。这种方式更加简洁，更容易阅读。除了代码层面的简洁外，在编译的结果时候lambda也不会产生一个多余的匿名类。&lt;/p&gt;
&lt;p&gt;对于eat这个特殊的接口，称之为：函数式接口&lt;/p&gt;
&lt;h2 id=&quot;lamda的优点&quot;&gt;lamda的优点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h3&gt;&lt;strong&gt;代码缩减&lt;/strong&gt;&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720175455395-664116558.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Option&amp;lt;Person&amp;gt; std=getStudent();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;       1、是否为空的判断&lt;/p&gt;
&lt;p&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720175640186-397371912.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     2、返回不为空的对象&lt;/p&gt;
&lt;p&gt;          &lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720175711203-434259300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  3、多重if else的简化&lt;/p&gt;
&lt;p&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720175742561-1091899011.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;函数式接口&quot;&gt;函数式接口&lt;/h2&gt;
&lt;p&gt;什么是函数式接口？这个是我们理解Lambda表达式的重点，也是产生lambda表达式的“母体”，这里我们引用一个比较容易理解的说法：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;函数式接口是 一个只有一个抽象方法（不包含object中的方法）的接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个需要说明一点，就是在Java中任何一个对象都来自Object 所有接口中自然会继承自Object中的方法，但在判断是否是函数式接口的时候要排除Object中的方法，下面举几个例子如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是函数式接口&lt;/span&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; eat 
{  
   &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatFood();    
}


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个不是是函数式接口&lt;/span&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; eat
{  
  &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatFood()
  {
     System.out.println(&lt;/span&gt;&quot;hello&quot;&lt;span&gt;);
  };    
}



&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是一个函数式接口&lt;/span&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; eat 
{  
 &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatFood();    
 String toString();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 对于是否是函数式接口，java8中也提供了一个专用的注解：@FunctionalInterface。通过这个注解，可以确定是否是函数式接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处会报编译错误&lt;/span&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; eat 
{  
  &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eatFood()
  {
    System.out.println(&lt;/span&gt;&quot;hello&quot;&lt;span&gt;);
  };    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   下面我们写一段lambda简单的代码,找出指定的身份证号码，并打印出来。&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720175853910-137296781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终的调用：&lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720175909448-1372997761.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;对于上面的代码实现，在我们调用excutor方法前，并不知道findName的实现方法，直到在最后把一个方法作为参数传入到excutor方法中。&lt;/p&gt;
&lt;p&gt;反思：函数式接口NameCheckInterface，是不是可以用来表示所有返回值为bool类型的，有两个形参（类型是passager 和String类型）的lambda表达式？&lt;/p&gt;
&lt;p&gt;如果我们再配合泛型的话，是不是我们只需要定义一个通用的函数式接口？下面我们改写下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; NameCheckInterface&amp;lt;T,T1,T2&amp;gt;&lt;span&gt; 
{
   T2 findName(T passager,T1 name);
}

@FunctionalInterface
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; PrintInterface&amp;lt;T&amp;gt;&lt;span&gt; 
{
  &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; printName(T name);
}

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; excutor(List&amp;lt;passager&amp;gt; passagerList, NameCheckInterface&amp;lt;Boolean,passager,String&amp;gt; checker, PrintInterface&amp;lt;String&amp;gt;&lt;span&gt; printer) 
{
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (passager p : passagerList) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (checker.findName(p,&quot;李四&quot;&lt;span&gt;)){
        printer.printName(p.getPassagerNo());
      }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对应的调用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; simpTest() 
{
  List&lt;/span&gt;&amp;lt;passager&amp;gt; passagerList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
  passagerList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; passager(&quot;李四&quot;, &quot;123456789&quot;&lt;span&gt;));
  passagerList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; passager(&quot;张三&quot;, &quot;123456789&quot;&lt;span&gt;));
  passagerList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; passager(&quot;王二&quot;, &quot;123456789&quot;&lt;span&gt;));

  excutor(passagerList,(p,str)&lt;/span&gt;-&amp;gt;p.getName().equals(str),str-&amp;gt;&lt;span&gt; System.out.println(str));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;对于这段代码，可以得出lambda中的函数式接口是可以公用的,而jdk中也已经定义了很多通用的函数式接口。  &lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;常用的函数式接口&quot;&gt;常用的函数式接口&lt;/h2&gt;
&lt;p&gt;在jdk中通用的函数式接口如下（都在java.util.function包中）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
Runnable r = () -&amp;gt; System.out.printf(&quot;say hello&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有输入参数，也没有输出&lt;/span&gt;
Supplier&amp;lt;String&amp;gt; sp = () -&amp;gt; &quot;hello&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只有输出消息，没有输入参数&lt;/span&gt;
Consumer&amp;lt;String&amp;gt; cp = r -&amp;gt; System.out.printf(r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有一个输入参数，没有输出&lt;/span&gt;
Function&amp;lt;Integer, String&amp;gt; func = r -&amp;gt; String.valueOf(r);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有一个输入参数 有一个输出参数&lt;/span&gt;
BiFunction&amp;lt;Integer, Integer, String&amp;gt; biFunc = (a, b) -&amp;gt; String.valueOf(a + b);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有两个输入参数 有一个输出参数&lt;/span&gt;
BiConsumer&amp;lt;Integer, Integer&amp;gt; biCp = (a, b) -&amp;gt; System.out.printf(String.valueOf(a + b));&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有两个输入参数 没有输出参数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;PS:上面是基本的方法，其他的都是基于这几个扩展而来&lt;/p&gt;
&lt;p&gt;如果上面的代码使用jdk中的函数式接口的话，就不用额外的定义NameCheckInterface和PrintInterface 接口了。根据上面的参数和返回值的形式，可以使用BiFunction和Consumer直接改写excutor方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; excutor(List&amp;lt;passager&amp;gt; passagerList, BiFunction&amp;lt;passager,String,Boolean&amp;gt; checker, Consumer&amp;lt;String&amp;gt;&lt;span&gt; printer) {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (passager p : passagerList) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (checker.apply(p,&quot;李四&quot;&lt;span&gt;)){
                printer.accept(p.getPassagerNo());
            }
        }
        
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id=&quot;函数的引用&quot;&gt;函数的引用&lt;/h2&gt;
&lt;p&gt;从上面的demo中，使用通用的函数表达式能够减少自定义函数式接口，为了进一步简化代码，lambda表达式可以改写成函数的引用的形式&lt;/p&gt;
&lt;p&gt;函数的引用是lambda表达式的更简洁的一种写法，也是更能体现出函数式编程的一种形式，让我们更能理解lambda终归也是一个“函数的对象”。 下面我们改写一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Consumer&amp;lt;String&amp;gt; c1 = r -&amp;gt;&lt;span&gt; System.out.printf(r); 
 c1.accept(&lt;/span&gt;&quot;1&quot;&lt;span&gt;);
 Consumer&lt;/span&gt;&amp;lt;String&amp;gt; c2 =&lt;span&gt;System.out::printf; 
 c1.accept(&lt;/span&gt;&quot;2&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在上面的demo中lambda表达式被我们改写成&lt;strong&gt;System.out::printf&lt;/strong&gt;这个形式，等于我们把一个函数直接赋值给了一个c2对象，这里我们可以俗称（非官方）c2为java函数的一个对象，这个也结局填补了java中一个空白。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;函数引用的规则&quot;&gt;&lt;strong&gt;函数引用的规则&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;对于Java中lambda改成函数的引用要遵循一定的规则,具体可以分为下面的四种形式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;静态方法的引用&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;          如果函数式接口的实现恰好可以通过调用一个静态方法来实现，那么就可以使用静态方法引用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720180103233-1488132757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Consumer&amp;lt;String&amp;gt; c1 = r -&amp;gt;&lt;span&gt; Integer.parseInt(r);
     c1.accept(&lt;/span&gt;&quot;1&quot;&lt;span&gt;);
     Consumer&lt;/span&gt;&amp;lt;String&amp;gt; c2 =&lt;span&gt;Integer::parseInt;
     c1.accept(&lt;/span&gt;&quot;2&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    2.实例方法引用&lt;/p&gt;
&lt;p&gt;     如果函数式接口的实现恰好可以通过调用一个实例方法来实现，那么就可以使用实例方法引用&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720180145783-1736042697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 Consumer&amp;lt;String&amp;gt; ins1 = r -&amp;gt; System.out.print(r);
 c1.accept(&quot;1&quot;);
 Consumer&amp;lt;String&amp;gt; ins2 =System.out::print;
 c1.accept(&quot;2&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;  3.对象方法引用&lt;/p&gt;
&lt;p&gt;     抽象方法的第一个参数类型刚好是实例方法的类型，抽象方法剩余的参数恰好可以当做实例方法的参数。如果函数式接口的实现能由上面说的实例方法调用来实现的话，那么就可以使用对象方法的引用。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720180220954-240461444.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
  Function&amp;lt;BigDecimal,Double&amp;gt; fuc1=t-&amp;gt;&lt;span&gt;t.doubleValue();
  fuc1.apply(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BigDecimal(&quot;1.025&quot;&lt;span&gt;));
  Function&lt;/span&gt;&amp;lt;BigDecimal,Double&amp;gt; fuc2=&lt;span&gt;BigDecimal::doubleValue;
  fuc2.apply(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BigDecimal(&quot;1.025&quot;&lt;span&gt;));


  BiFunction&lt;/span&gt;&amp;lt;BigDecimal, BigDecimal, BigDecimal&amp;gt; func3 = (x, y) -&amp;gt;&lt;span&gt; x.add(y);
  func3.apply(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BigDecimal(&quot;1.025&quot;), &lt;span&gt;new&lt;/span&gt; BigDecimal(&quot;1.254&quot;&lt;span&gt;));
  BiFunction&lt;/span&gt;&amp;lt;BigDecimal, BigDecimal, BigDecimal&amp;gt; func4 =&lt;span&gt; BigDecimal::add;
  func4.apply(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; BigDecimal(&quot;1.025&quot;), &lt;span&gt;new&lt;/span&gt; BigDecimal(&quot;1.254&quot;));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;   4.构造方法引用&lt;/p&gt;
&lt;p&gt;      如果函数式接口的实现恰好可以通过调用一个类的构造方法来实现，那么就可以使用构造方法引用。&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720180257429-1096176952.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
 Consumer&amp;lt;String&amp;gt; n1 = r -&amp;gt;new BigDecimal(r);
  c1.accept(&quot;1&quot;);
  Consumer&amp;lt;String&amp;gt; n2 =BigDecimal::new;
  c1.accept(&quot;2&quot;);
&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&quot;stream-api的引用&quot;&gt;stream API的引用&lt;/h2&gt;
&lt;p&gt;Stream是处理数组和集合的API,Stream具有以下特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不是数据结构，没有内部存储&lt;/li&gt;
&lt;li&gt;不支持索引访问&lt;/li&gt;
&lt;li&gt;延迟计算&lt;/li&gt;
&lt;li&gt;支持过滤，查找，转换，汇总等操作&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于StreamAPI的学习，首先需要弄清楚lambda的两个操作类型：中间操作和终止操作。 下面通过一个demo来认识下这个过程。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
Stream st=Arrays.asList(1,2,3,4,5).stream().filter(x-&amp;gt;&lt;span&gt;{
           System.out.print(x);
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  x&amp;gt;3&lt;span&gt;;
       });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;当我们执行这段代码的时候，发现并没有任何输出，这是因为lambda表达式需要一个终止操作来完成最后的动作。 我们修改代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Stream st=Arrays.asList(1,2,3,4,5).stream().filter(x-&amp;gt;&lt;span&gt;{
           System.out.print(x);
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;  x&amp;gt;3&lt;span&gt;;
       });
       
   st.forEach(t&lt;/span&gt;-&amp;gt; System.out.print(t));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对应的输出结果是：&lt;/p&gt;


&lt;p&gt;为什么会有这个输出呢？因为在filter函数的时候并没有真正的执行，在forEach的时候才开始执行整个lambda表达式，所以当执行到4的时候，filter输出之后，forEach也执行了，最终结果是1234455&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;对于Java中的lambda表达式的操作，可以归类和整理如下：&lt;/p&gt;
&lt;h3 id=&quot;中间操作&quot;&gt;中间操作：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;过滤 filter&lt;/li&gt;
&lt;li&gt;去重 distinct&lt;/li&gt;
&lt;li&gt;排序 sorted&lt;/li&gt;
&lt;li&gt;截取 limit、skip&lt;/li&gt;
&lt;li&gt;转换 map/flatMap&lt;/li&gt;
&lt;li&gt;其他 peek&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;终止操作&quot;&gt;终止操作&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;循环 forEach&lt;/li&gt;
&lt;li&gt;计算 min、max、count、 average&lt;/li&gt;
&lt;li&gt;匹配 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny&lt;/li&gt;
&lt;li&gt;汇聚 reduce&lt;/li&gt;
&lt;li&gt;收集器 toArray collect&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;常用的几个lambda&quot;&gt;常用的几个lambda&lt;/h2&gt;
&lt;p&gt;下面我们对这几个常用的lambda表达式写几个demo,首先定义公共的Student类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;125&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student {
      
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Student(String stuName, &lt;span&gt;int&lt;/span&gt; age, BigDecimal score, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; clazz) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.stuName =&lt;span&gt; stuName;
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.score =&lt;span&gt; score;
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clazz =&lt;span&gt; clazz;
      }
      
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String stuName;
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; age;
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BigDecimal score;
      &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; clazz;
      
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getStuName() {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stuName;
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setStuName(String stuName) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.stuName =&lt;span&gt; stuName;
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getAge() {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; age;
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setAge(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; age) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BigDecimal getScore() {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; score;
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setScore(BigDecimal score) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.score =&lt;span&gt; score;
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getClazz() {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; clazz;
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setClazz(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; clazz) {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.clazz =&lt;span&gt; clazz;
      }
  }
  
  List&lt;/span&gt;&amp;lt;Student&amp;gt; studentList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;黎  明&quot;, 20, &lt;span&gt;new&lt;/span&gt; BigDecimal(80), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;郭敬明&quot;, 22, &lt;span&gt;new&lt;/span&gt; BigDecimal(90), 2&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;明  道&quot;, 21, &lt;span&gt;new&lt;/span&gt; BigDecimal(65.5), 3&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;郭富城&quot;, 30, &lt;span&gt;new&lt;/span&gt; BigDecimal(90.5), 4&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;刘诗诗&quot;, 20, &lt;span&gt;new&lt;/span&gt; BigDecimal(75), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;成  龙&quot;, 60, &lt;span&gt;new&lt;/span&gt; BigDecimal(88), 5&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;郑伊健&quot;, 60, &lt;span&gt;new&lt;/span&gt; BigDecimal(86), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;刘德华&quot;, 40, &lt;span&gt;new&lt;/span&gt; BigDecimal(81), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;古天乐&quot;, 50, &lt;span&gt;new&lt;/span&gt; BigDecimal(83), 2&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;赵文卓&quot;, 40, &lt;span&gt;new&lt;/span&gt; BigDecimal(84), 2&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;吴奇隆&quot;, 30, &lt;span&gt;new&lt;/span&gt; BigDecimal(86), 4&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;言承旭&quot;, 50, &lt;span&gt;new&lt;/span&gt; BigDecimal(68), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;郑伊健&quot;, 60, &lt;span&gt;new&lt;/span&gt; BigDecimal(86), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;黎  明&quot;, 20, &lt;span&gt;new&lt;/span&gt; BigDecimal(80), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;李连杰&quot;, 65, &lt;span&gt;new&lt;/span&gt; BigDecimal(86), 4&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;周润发&quot;, 69, &lt;span&gt;new&lt;/span&gt; BigDecimal(58), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;徐若萱&quot;, 28, &lt;span&gt;new&lt;/span&gt; BigDecimal(88), 6&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;许慧欣&quot;, 26, &lt;span&gt;new&lt;/span&gt; BigDecimal(86), 8&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;陈慧琳&quot;, 35, &lt;span&gt;new&lt;/span&gt; BigDecimal(64), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;关之琳&quot;, 45, &lt;span&gt;new&lt;/span&gt; BigDecimal(50), 9&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;温碧霞&quot;, 67, &lt;span&gt;new&lt;/span&gt; BigDecimal(53), 2&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;林青霞&quot;, 22, &lt;span&gt;new&lt;/span&gt; BigDecimal(56), 3&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;李嘉欣&quot;, 25, &lt;span&gt;new&lt;/span&gt; BigDecimal(84), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;彭佳慧&quot;, 26, &lt;span&gt;new&lt;/span&gt; BigDecimal(82), 5&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;陈紫涵&quot;, 39, &lt;span&gt;new&lt;/span&gt; BigDecimal(88), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;张韶涵&quot;, 41, &lt;span&gt;new&lt;/span&gt; BigDecimal(90), 6&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;梁朝伟&quot;, 58, &lt;span&gt;new&lt;/span&gt; BigDecimal(74), 1&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;梁咏琪&quot;, 65, &lt;span&gt;new&lt;/span&gt; BigDecimal(82), 7&lt;span&gt;));
  studentList.add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&quot;范玮琪&quot;, 22, &lt;span&gt;new&lt;/span&gt; BigDecimal(83), 1));    
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id=&quot;foreach&quot;&gt;forEach&lt;/h3&gt;
&lt;hr/&gt;&lt;p&gt;forEach:代表循环当前的list ,下面的例子是循环打印出student的名字&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
studentList.stream().forEach(x -&amp;gt; System.out.println(x.getStuName()));
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;filter&lt;/h3&gt;
&lt;p&gt;根据条件过滤当前的数据，获得分数大于80的学生名称&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
studentList.stream().filter(t -&amp;gt; t.getScore().compareTo(new BigDecimal(80)) &amp;gt; 0).forEach(x -&amp;gt; System.out.println(x.getStuName()));
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;distinctsorted-group&quot;&gt;distinct、sorted 、group&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; 1.去除重复数据&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
studentList.stream().distinct().forEach(x -&amp;gt; System.out.println(x.getStuName()));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.单条件排序和多条件排序&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  
   studentList.stream().sorted(Comparator.comparing(Student::getScore)).forEach(x &lt;/span&gt;-&amp;gt;&lt;span&gt; System.out.println(x.getStuName()));
   
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多条件排序&lt;/span&gt;
  studentList.stream().sorted(Comparator.comparing(Student::getScore).thenComparing(Student::getStuName)).forEach(x -&amp;gt; System.out.println(x.getStuName()));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3.group 的使用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
  System.out.println(studentList.stream().collect(Collectors.groupingBy(x-&amp;gt;x.getAge(),Collectors.counting())));
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;limitskip&quot;&gt;limit、skip&lt;/h3&gt;
&lt;p&gt;跳过多少，取多少个元素，可以根据当前的数据进行分页&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
studentList.stream().skip(10).limit(5).forEach(x -&amp;gt; System.out.println(x.getStuName())); 

//具体的分页
int pageIndex=1;
int pageSize=5;
studentList.stream().skip((pageIndex-1)*pageSize).limit(pageSize).forEach(x -&amp;gt; System.out.println(x.getStuName())); 
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;mapflatmap&quot;&gt;map/flatMap&lt;/h3&gt;
&lt;p&gt;map是一个转换的工具，提供很多转换的方法，mapToInt,mapToDouble&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
studentList.stream().map(Student::getScore).forEach(x -&amp;gt; System.out.println(x));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720180730578-1238907819.png&quot; alt=&quot;&quot;/&gt;　　&lt;/p&gt;
&lt;p&gt;上面的结果是输出当前的所有同学的得分。&lt;/p&gt;
&lt;p&gt;flatMap是一个可以把子数组的值放到数组里面, 下面的实例是把所有的名字都拆开成一个新的数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
studentList.stream().flatMap(x-&amp;gt; Arrays.stream(x.getStuName().split(&quot;&quot;))).forEach(x -&amp;gt; System.out.println(x));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720180806148-393226330.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;minmaxcount-average&quot;&gt;min、max、count、 average&lt;/h3&gt;
&lt;p&gt;一组常用的统计函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
studentList.stream().max(Comparator.comparing(x -&amp;gt; x.getAge())).ifPresent(x-&amp;gt; System.out.println(x.getAge()));
  studentList.stream().min(Comparator.comparing(x -&amp;gt; x.getAge())).ifPresent(x-&amp;gt; System.out.println(x.getAge()));
  System.out.println(studentList.stream().count());
  studentList.stream().mapToDouble(x -&amp;gt; x.getScore().doubleValue()).average().ifPresent(x-&amp;gt; System.out.println(x));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/562505/201907/562505-20190720180834171-154916827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;anymatchnonematch-allmatch--findfirst-findany&quot;&gt;anyMatch、noneMatch、 allMatch、 findFirst、 findAny&lt;/h3&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;anyMatch： 操作用于判断Stream中的是否有满足指定条件的元素。如果最少有一个满足条件返回true，否则返回false。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;noneMatch： 与anyMatch相反。allMatch是判断所有元素是不是都满足表达式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;findFirst： 操作用于获取含有Stream中的第一个元素的Optional，如果Stream为空，则返回一个空的Optional。若Stream并未排序，可能返回含有Stream中任意元素的Optional。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;findAny： 操作用于获取含有Stream中的某个元素的Optional，如果Stream为空，则返回一个空的Optional。由于此操作的行动是不确定的，其会自由的选择Stream中的任何元素。在并行操作中，在同一个Stram中多次调用，可能会不同的结果。在串行调用时，都是获取的第一个元素， 默认的是获取第一个元素,并行是随机的返回。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
System.out.println(studentList.stream().anyMatch(r -&amp;gt; r.getStuName().contains(&quot;伟&quot;&lt;span&gt;)));
System.out.println(studentList.stream().allMatch(r &lt;/span&gt;-&amp;gt; r.getStuName().contains(&quot;伟&quot;&lt;span&gt;)));
System.out.println(studentList.stream().noneMatch(r &lt;/span&gt;-&amp;gt; r.getStuName().contains(&quot;伟&quot;&lt;span&gt;)));
System.out.println(studentList.stream().findFirst());
System.out.println(studentList.stream().findAny());

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;)
{
   System.out.println(studentList.stream().parallel().findAny().get().getStuName());
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;reduce&quot;&gt;reduce&lt;/h3&gt;
&lt;p&gt;对于reduce的使用，应该在js中也有接触到，但也是比较小众的功能，但使用起来功能却非常的强大，先看一个正常的demo：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
Stream.of(1, 5, 10, 8).reduce((x, y) -&amp;gt;&lt;span&gt; {
        System.out.println(&lt;/span&gt;&quot;x : &quot; +&lt;span&gt; x);
        System.out.println(&lt;/span&gt;&quot;y : &quot; +&lt;span&gt; y);
        System.out.println(&lt;/span&gt;&quot;x+y : &quot; +&lt;span&gt;x);
        
        System.out.println(&lt;/span&gt;&quot;--------&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; x +&lt;span&gt; y;
    });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;打印结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
x : 1
y : 5
x+y : 1
--------
x : 6
y : 10
x+y : 6
--------
x : 16
y : 8
x+y : 16
--------
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;reduce是一个循环，有两个参数&lt;/li&gt;
&lt;li&gt;第一次执行的时候x是第一个值，y是第二个值。&lt;/li&gt;
&lt;li&gt;在第二次执行的时候，x是上次返回的值，y是第三个值&lt;br/&gt;…. 直到循环结束为止。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;再修改代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
//指定了初始值

Stream.of(1, 5, 10, 8).reduce(100,(x, y) -&amp;gt; {
        System.out.println(&quot;x : &quot; + x);
        System.out.println(&quot;y : &quot; + y);
        System.out.println(&quot;x+y : &quot; +x);
        System.out.println(&quot;--------&quot;);
        return x + y;
});
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
x : 100
y : 1
x+y : 100
--------
x : 101
y : 5
x+y : 101
--------
x : 106
y : 10
x+y : 106
--------
x : 116
y : 8
x+y : 116
--------
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&quot;toarraycollect&quot;&gt;toArray、collect&lt;/h3&gt;
&lt;p&gt;toArray和collect是两个收集器，toArray是把数据转换成数组，collect是转成其他的类型。这里就不在讨论了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
System.out.println(studentList.stream().collect(Collectors.groupingBy(x-&amp;gt;x.getAge(),Collectors.counting())));
&lt;/pre&gt;&lt;/div&gt;





</description>
<pubDate>Sat, 20 Jul 2019 16:02:00 +0000</pubDate>
<dc:creator>付威的网络博客</dc:creator>
<og:description>原文地址：http://blog.laofu.online/2018/04/20/java-lambda/ 为什么使用lambda 在java中我们很容易将一个变量赋值，比如int a =0;int</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/OceanHeaven/p/11218661.html</dc:identifier>
</item>
<item>
<title>互联网浪潮之下，聊聊 90 后所面临的困境 - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/11219865.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/11219865.html</guid>
<description>&lt;p&gt;阅读本文大概需要 4 分钟。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWN0dXJlY2RuLmVqaWFubWVkaWEuY29tL2E2ZTY4NTk1NmNlNjQ2MDRhZTcyY2UyYjNkMDg0OGNmLmpwZw&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWN0dXJlY2RuLmVqaWFubWVkaWEuY29tL2E2ZTY4NTk1NmNlNjQ2MDRhZTcyY2UyYjNkMDg0OGNmLmpwZw&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://picturecdn.ejianmedia.com/a6e685956ce64604ae72ce2b3d0848cf.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;作为一名 90 后，从曾经被认为玩世不恭的一代，到现在自称佛系养生的一代，这十年间经历了什么？&lt;/p&gt;

&lt;p&gt;如今大家很少在说 90 后这个词，因为 00 后成为了互联网的话题焦点，因为他们已经开始成年，开始步入社会。&lt;/p&gt;

&lt;p&gt;90 后接过了 80 后的接力棒，来到了这个社会的主战场上，他们是这个时代的新生力量，即将成为八零后的接班人，成为职场里的主力军。&lt;/p&gt;

&lt;p&gt;我经常在想，我们这些 90 后在成长过程中背负了多少压力，承受着多少争议，要面对多少的挑战，以及不公平的对待。&lt;/p&gt;

&lt;p&gt;当今的 90 后，也是时候想想自己的出路到底是什么了。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWN0dXJlY2RuLmVqaWFubWVkaWEuY29tLzNhOWYxMWJmMTA5YzQxN2Y5Y2Q2ZDUxMTc2ZjYxNThiLmpwZw&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWN0dXJlY2RuLmVqaWFubWVkaWEuY29tLzNhOWYxMWJmMTA5YzQxN2Y5Y2Q2ZDUxMTc2ZjYxNThiLmpwZw&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://picturecdn.ejianmedia.com/3a9f11bf109c417f9cd6d51176f6158b.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;90 后的遭遇或许和 80 后更加类似，他们大多都要经历九年义务教育，参加高考。&lt;/p&gt;

&lt;p&gt;可能有更多的 90 后选择了读研，但他们最终都要面临着就业的压力，比起80后，90 后的学业压力是更加大的，因为每年的考生越来越多，大学生的数量也越来越多，直到大学生已经失去了原有的价值，读研成为了很多 90 后，00 后不得不选择的一个方向。&lt;/p&gt;

&lt;p&gt;越来越多的 90 后开始考虑读博，为自己更长远的职业生涯做规划。&lt;/p&gt;

&lt;p&gt;很多年前还有一种言论在说 90 后是垮掉的一代，现在他们却不得不承认，九零后可能是最有压力的一代，因为他们的父辈所在的时代，可以说是百废待兴，他们有很多的机会去改变自己的命运。就算是 70 后，80后，可能早年投资一套房产，多年之后就改变了命运。&lt;/p&gt;

&lt;p&gt;90 后似乎已经成功地避开了这一些时代红利。&lt;/p&gt;

&lt;p&gt;虽然在互联网时代，如今的 90 后改变命运的方式实际上更多，但是也都更加困难，因为竞争更激烈了，成功的比例更小了。&lt;/p&gt;

&lt;p&gt;与此同时，他们要面对更多的来自现实生活的压力，他们必须要在小学、中学、大学都保持成绩优异，还需要在毕业后找到一份好工作，找到一个好对象，并且能够达到有车有房的标准配套，才算是一个人们眼中的成功人士。&lt;/p&gt;

&lt;p&gt;90 后的压力大吗？其实还是挺很大的。这也是为什么越来越多 90 后选择佛系生活，学会了养生。因为他们真的太累了，九零后是中国互联网时代迅猛发展的见证者，他们见证了移动互联网最辉煌的时期。&lt;/p&gt;

&lt;p&gt;00 后在移动互联网末期享受最好的时代馈赠，而 90 后在这个时代交替的关键时刻经历了这一切，他们中有很少数人可以抓住这个时代的机遇，更多人则只能沉迷于这个时代快速发展带来的副产品，比如泛娱乐、游戏等等足以占据年轻人所有时间的事物。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWN0dXJlY2RuLmVqaWFubWVkaWEuY29tLzZkYzhmNTlmNWVjMjRiNTI5NTZlYTJhOTZlZWYxNzE4LmpwZw&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWN0dXJlY2RuLmVqaWFubWVkaWEuY29tLzZkYzhmNTlmNWVjMjRiNTI5NTZlYTJhOTZlZWYxNzE4LmpwZw&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://picturecdn.ejianmedia.com/6dc8f59f5ec24b52956ea2a96eef1718.jpg&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这也不能怪他们，因为这个时候的九零后大多还在学校，还未踏入职场，他们虽然经历了这世界的变迁，却很难去改变什么，他们通常是心有余而力不足的。&lt;/p&gt;

&lt;p&gt;他们接受着互联网浪潮的洗礼，他们去体验每一款互联网产品，他们喜欢分享，传播各种有意思的东西。同时他们在变化之中，倍感焦虑，他们无所适从，却又希望抓住什么。&lt;/p&gt;

&lt;p&gt;他们在这个信息爆炸的时代里，不断迷失自己。因为这个时代是个娱乐化的时代，他们被一样又一样的新鲜事物所吸引，却无法从中获得自己想要的东西，他们只能够从中获得短暂的欢愉。&lt;/p&gt;

&lt;p&gt;当然当今也有很多 90 后已经迈出了他们改变这个时代的第一步，他们也许可以成为职场中的佼佼者，也许可以成为这个时代的领军人物。&lt;/p&gt;

&lt;p&gt;在二次元圈子里，九零后绝对是主力军，在直播时代，网红经济的时代里，90 后的身影也随处可见，他们都是最有创造力的人，他们都是最具有时代特征的 90 后。&lt;/p&gt;

&lt;p&gt;但是与此同时也有很多 90 后还没从这个泛娱乐时代里走出来，他们没有能够把握住这个时代的命脉，没有把握住属于自己的机会，于是他们在这个时代的洗礼中不断老去，直到成为了自己最讨厌的那种人而不自知。&lt;/p&gt;
&lt;p&gt;也许这就是泛娱乐时代带来的冲击吧，要么娱乐至死，要么就应该更加懂得生活。&lt;/p&gt;

&lt;p&gt;我是一名 90 后，我希望有越来越多的 90 后可以理解，这个时代需要我们去改变，或者，让自己做出改变。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;文章作者 黄小斜&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;大厂程序员，互联网职场新知，终身学习践行者，懂技术，懂职场，更想懂你。据说，每个上进又好看的互联网人都关注我了&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jul 2019 15:58:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>阅读本文大概需要 4 分钟。 ​ 作为一名 90 后，从曾经被认为玩世不恭的一代，到现在自称佛系养生的一代，这十年间经历了什么？ 如今大家很少在说 90 后这个词，因为 00 后成为了互联网的话题焦点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xll1025/p/11219865.html</dc:identifier>
</item>
<item>
<title>JVM的内存区域 - 城序猿</title>
<link>http://www.cnblogs.com/cheng21553516/p/11219856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cheng21553516/p/11219856.html</guid>
<description>&lt;p&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，&lt;/p&gt;
&lt;p&gt;包含程序计数器、虚拟机栈、本地方法栈、Java堆、方法区（运行时常量池）、直接内存等，不同的版本会有所差异&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213093/201907/1213093-20190720231222513-1732087805.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各区域的作用：&lt;/p&gt;

&lt;p&gt;1、程序计数器：较小的内存空间，当前线程执行的字节码的行号指示器；各线程之间独立存储，互不影响；&lt;/p&gt;
&lt;p&gt; 2、虚拟机栈：线程私有，生命周期和线程同生共死，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。方法的执行就对应着栈帧在虚拟机栈中入栈和出栈的过程；&lt;/p&gt;
&lt;p&gt;        栈里面存放着各种基本数据类型和对象的引用（-Xss） ；-Xss参数是用来调整JAVA虚拟机栈的。一个线程调用多个方法，只会有一个栈。栈的缺省大小为1M&lt;/p&gt;
&lt;p&gt;3、本地方法栈：本地方法栈保存的是native方法的信息，当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机栈中创建栈帧，JVM只是简单地动态链接并直接调用native方法；&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213093/201907/1213093-20190720231527355-1123530516.png&quot; alt=&quot;&quot;/&gt;   &lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;堆：&lt;/p&gt;
&lt;p&gt;方法区（运行时常量池）：也叫永久区（永久代），用于存储已经被虚拟机加载的类信息，常量(&quot;zdy&quot;,&quot;123&quot;等)，静态变量(static变量)等数据（-XX:PermSize；- XX:MaxPermSize；-XX:MetaspaceSize； - XX:MaxMetaspaceSize ），&lt;/p&gt;
&lt;p&gt;                在JDK7及之前用的是-XX:PermSize；-XX:MaxPermSize；在JDK8及之后用的是（元数据空间）-XX:MetaspaceSize；-XX:MaxMetaspaceSize&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;em id=&quot;__mceDel&quot;&gt;JAVA堆：&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;与我们操作最为紧密的区域，在代码中用new对象的时候，操作的就是该区域。几乎是所有的对象都在堆上分配，与堆相关的命令是：（-Xms；-Xmx；-Xmn；-XX:NewSize；-XX:MaxNewSize）&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;-Xms；堆的最小值&lt;br/&gt;-Xmx；堆的最大值&lt;br/&gt;-Xmn；新生代的大小&lt;br/&gt;-XX:NewSize；新生代的最小值&lt;br/&gt;-XX:MaxNewSize；新生代的最大值&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;运行时常量池：严格来说是方法区的一部分，JDK8及之后运行时常量池放到了堆里面。JDK8之后提出了元数据空间的概念，这个方法区就消失了，方法区从运行时数据区挪到了虚拟机本身管理之外，只受制于物理内存的大小，不再受制于虚拟机的管理内存大小。同时运行时常量池也挪到了方法区。元空间不是直接内存，直接内存主要用于IO通信。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213093/201907/1213093-20190720232014109-1467534276.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;不同JDK版本之间运行时数据区也是有所不同的。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;如JDK6 的时候，常量池是放在方法区中的&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213093/201907/1213093-20190720232337385-666363420.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;


&lt;p&gt;在JDK7的时候，运行时常量池在对中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213093/201907/1213093-20190720232508058-1846371317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;em&gt;JDK8及之后运行时常量池放到了堆里面&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1213093/201907/1213093-20190720235521074-1476010816.png&quot; alt=&quot;&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;




&lt;p&gt;栈和堆对比分析 ：&lt;br/&gt;栈的特点：&lt;br/&gt;1.以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量（int、short、long、byte、float、double、boolean、char等）以及对象的引用变量，&lt;br/&gt;2.其内存分配在栈上，变量出了作用域就会自动释放；&lt;br/&gt;3.栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。&lt;br/&gt;栈的内存要远远小于堆内存，栈的深度是有限制的，可能发生StackOverFlowError问题&lt;br/&gt;堆的特点：&lt;br/&gt;1.堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中&lt;br/&gt;2.堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jul 2019 15:57:00 +0000</pubDate>
<dc:creator>城序猿</dc:creator>
<og:description>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域， 包含程序计数器、虚拟机栈、本地方法栈、Java堆、方法区（运行时常量池）、直接内存等，不同的版本会有所差异 各区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cheng21553516/p/11219856.html</dc:identifier>
</item>
<item>
<title>Android 开发感想 - 宋晓华</title>
<link>http://www.cnblogs.com/clar/p/9658227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/clar/p/9658227.html</guid>
<description>&lt;p&gt;18年从.net转行做安卓开发，现在已经过去一年多了。说一下感想和心得体会！&lt;/p&gt;


&lt;p&gt;说一下我的经厉，从毕业开始出来工作一直是从事.net方向的开发工作。一开始也是没什么经验，加上也没有其他手艺就找了一个.net的开发岗位，刚开始两年都是做一些基本的系统开发OA、CRM什么的。后来跳槽换了几家公司，也都差不多主要是.net web系统开发或者是后台接口的开发。跟着团队一起做项目，完成需求开发，解决bug等等。做了几年看到现在移动互联网是趋势就打算换个方向，本来在我工作的第二年是有一次机会的但是错过了，当时买了mac准备转ios开发的但是刚出来工作基础不好加上没有自制能力所以就没有成功转型。&lt;/p&gt;

&lt;p&gt;后来就还是在做.net相关的工作，结果发现做.net的越来越少，加上51上面发现工作岗位远远没有java和Android的多就想着换个方向了，另一个原因是做.net技术一般工资也没提高多少。然后就准备学习Android了&lt;/p&gt;


&lt;p&gt;Android学习是自学的花了两三个月的时间吧，买了几本书，《Android第一行代码》《Android开发艺术》再加上Google的文档和菜鸟教程。刚开始是从一个创意开始，比如想做一个app。下载开发环境，配置开发工具，然后写一个helloworld开始！那时候就是在家自学，做几个例子。跟着网上的教程写一下，因为之前做开发也有一段时间了，java基础还行基本掌握，就从Android开发的ui开始学习，一开始是了解基本的一些ui和xml怎么写，然后学习如何交互，基本上是把第一行代码里面的例子都敲了一遍。然后就是做一个项目实战一下，比如一个天气应用，刚开始学习的时候也是什么都不会，经常百度，看别人写的代码复制然后改一下，后来发现不行。还是要思考一下原理，然后在家做了一两个app之后觉得差不多了解一点了。&lt;/p&gt;
&lt;p&gt;1使用listview 和ReceryView的问题二自定义listview中的东西。&lt;/p&gt;


&lt;p&gt;学完Android基础加上做了几个例子程序之后有了一点点信心，就开始写简历了，写的是一年工作经验。然后投简历，找工作的时候已经是6月份了，给我打电话的公司也不多就每天投一下简历，然后看看面试题，想想怎么面试。再就是修改简历。大概找了一个星期左右吧，面试成功了一家公司，是一家外包公司，之前没进过外包加上刚开始也什么经验就去了工资待遇还可以。面试的时候问了一些简单的view基本原理，常用的控件和多线程知识，以及java基础等等。我大概答上来了，自我感觉70分吧。然后把之前公司的一些项目写上去了。之前公司也有移动端的项目，我大概了解一些，只不过当时是负责写后台接口的。就这样就找到了第一份Android的开发工作。当然也有一些不好的地方，比如编造了一些经验。但是不这样的话根本连面试的机会都没有。&lt;/p&gt;


&lt;p&gt;工作也快一年多了吧，刚开始进入公司是负责公司的一个内部系统的Android端的开发工作，根据每一期的需求进行开发。一般一个月到一个半月左右发布一个版本，更新迭代也是很快的，然后一开始是写一些简单的ui界面，调用一下接口。第一个月就是熟悉一下项目，刚好公司有同时和我交接，期间有不懂的也会问问其他同事，经常是问一下ios端的开发。然后因为一些事情项目组的一个同事离职了，我才发现原来招我进来是替代他的，然后Android端的话就只有我一个人了，感觉压力有点大。不过那位同事走之前把项目基本和我介绍了，然后里面系统框架也已经搭建好了，平时的主要工作就是改改界面，根据需求做一下系统的开发，和之前界面的修改。只是因为基础不好，加上经验也不是很足。常常加班，不过进步也是有的。这一年多来基本保证了项目的正常开发上线，虽然有时候会拖延几天。也紧急修改过一下bug。但是对我也是一种锻炼吧。工作总体来说还好，和同事们相处也比较愉快。同时也感谢他们对我的帮助，从别人身上也学到了不少东西，有时候有问题也是一起交流讨论。&lt;/p&gt;
&lt;p&gt;工作中的一个技术问题和知识点，自定义View，视频播放，图片加载缓存，获取视频缩略图，复杂界面的布局，以及一些特殊效果的实现。这些问题下一篇文章会详细写出来。&lt;/p&gt;


&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;通过这一年左右的工作经历让我对移动端开发有了一个新的认识，Android入门简单但是要想深入学习也需要花一番功夫。同时在这一年的开发工作中，业余还是没有主动学习和提高。对于项目的开发和代码的质量没有更好的要求自己。有时候也应该主动的去学习和思考一下项目中的代码应该怎么写。能不能提高一点，在完成任务的同时还需要对自己要求高一点。刚开始可能工作比较认真，到后来也会发现工作不够热情，&lt;strong&gt;对于项目和代码的激情也开始减少，这都是应该思考和反思的&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;感慨&lt;/p&gt;
&lt;p&gt;从毕业到现在也已经工作四五年了，本来以为可以一直做.net的但是还是换了方向，但是一些基础的编程思想都是相同的，比如数据结构，面向对象，接口。一般的开发语言只是语法的不同，但是基本思想基本差不多。只是其适合使用的场景不同，例如编译型语言适合后端开发和一些大型的系统，例如java和C#。解释型语言比较适合web方向的开发比如php和python等。不知道还能写多久的代码，工作到现在进步也不是很明显，大多数程序员基本都是写需求。那一份还可以的薪水，勉强养活自己。要赚钱还是需要有其他的方向。工作之余也要考虑一下未来的路该怎么走，不可能写一辈子代码。最多到30多岁，要找到自己方向吧，工作时间越久想找到一份好工作也越来越难。快30了也有一定的危机感了，人最怕温水煮青蛙。所以趁年轻还是多学点东西，不能到最后才发现想转行已经不会其他技能了。是很痛苦的一件事情!这句话是给自己说的，要加油，要努力!&lt;/p&gt;

</description>
<pubDate>Sat, 20 Jul 2019 15:53:00 +0000</pubDate>
<dc:creator>宋晓华</dc:creator>
<og:description>18年从.net转行做安卓开发，现在已经过去一年多了。说一下感想和心得体会！ 一、开始 说一下我的经厉，从毕业开始出来工作一直是从事.net方向的开发工作。一开始也是没什么经验，加上也没有其他手艺就找</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/clar/p/9658227.html</dc:identifier>
</item>
<item>
<title>排序算法 - 李十八</title>
<link>http://www.cnblogs.com/lixuec/p/11219826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixuec/p/11219826.html</guid>
<description>&lt;p&gt;  数组有很多排序算法，主要的排序算法有10种：，&lt;strong&gt;冒泡排序，选择排序，插入排序，希尔排序，快速排序，归并排序，基数排序，堆排序，计数排序，桶排序&lt;/strong&gt;。下面为大家简单介绍几种排序算法。&lt;/p&gt;
&lt;h4 id=&quot;一冒泡算法&quot;&gt;一、冒泡算法&lt;/h4&gt;
&lt;h5 id=&quot;基本思想&quot;&gt;  1. 基本思想&lt;/h5&gt;
&lt;p&gt;  冒泡排序的相邻的元素进行比较，如果满足条件就交换两个元素，把大的元素放到后面，小的元素像气泡一样上升到顶部。&lt;/p&gt;
&lt;h5 id=&quot;算法实现&quot;&gt;  2. 算法实现&lt;/h5&gt;
&lt;p&gt;  冒泡排序需要双层循环来实现，其中外层循环控制排序的轮数，内存循环控制用于对比两个元素的大小，以确定是否进行交换。下面代码进行代码实现：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;

public class Maopao {
    public static void main(String[] args) {
        int arr[]={2,5,8,7,1,0,9};
        for (int i = 0; i &amp;lt; arr.length; i++) {
            for(int j=1;j&amp;lt;arr.length;j++){
                if(arr[j]&amp;lt;arr[j-1]){
                    int s=arr[j];
                    arr[j]=arr[j-1];
                    arr[j-1]=s;
                }

            }
        }
        System.out.println(Arrays.toString(arr));   
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  运行结果如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508203950426.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;二选择排序&quot;&gt;二、选择排序&lt;/h4&gt;
&lt;h5 id=&quot;基本思想-1&quot;&gt;  1. 基本思想&lt;/h5&gt;
&lt;p&gt;  选择排序的基本思想就是将指定的元素与其他的元素分别进行对比，如果满足条件就交换这两个元素，区别于冒泡排序的是，选择排序是一个分别与其他元素进行对比，而冒泡排序只是两个相邻的元素进行比较。&lt;/p&gt;
&lt;h5 id=&quot;算法实现-1&quot;&gt;  2. 算法实现&lt;/h5&gt;
&lt;p&gt;  选择排序在每一轮的排序都能找出一个最大或者最小的元素，顺序的排放数组的最后，直到元素全部排完顺序。选择排序也是使用双层循环，外层循环控制每一轮指定的元素，内层循环则控制每一个与指定元素进行比较的元素。代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;

public class Xuanzhe {
    public static void main(String[] args) {
        int arr[] = {2, 5, 8, 7, 1, 0, 9,-2,-3};
        for (int i = 0; i &amp;lt; arr.length-1; i++) {
            for (int j = 1 + i; j &amp;lt; arr.length; j++) {
                if (arr[i] &amp;gt; arr[j]) {
                    int s = arr[j];
                    arr[j] = arr[i];
                    arr[i] = s;
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  运行结果如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508210512721.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;三插入排序&quot;&gt;三、插入排序&lt;/h4&gt;
&lt;h5 id=&quot;基本思想-2&quot;&gt;  1. 基本思想&lt;/h5&gt;
&lt;p&gt;  直接插入排序的比较就是把后一个元素和前面的有序列表进行比较，使之仍然有序，比如一个数组为｛2，3，5，1，9，0｝，那么先让 3 和｛2｝ 进行 比较，符合条件的话交换两个元素，否则让5和前面的有序数列｛2，3｝进行比较得到有序数列｛2，3，5｝然后让1和这个数列再进行比较，如果1小于数列中的元素那么就进行交换，直到1和三个元素比较完毕。然后得到数列｛1，2，3，5｝，以此类推，当到最后一个元素比较完毕会得到一个完整的有序数列｛0，1，2，3，5，9｝。&lt;/p&gt;
&lt;h5 id=&quot;算法实现-2&quot;&gt;  2. 算法实现&lt;/h5&gt;
&lt;p&gt;  插入排序也可以使用双层循环，外层循环控制轮次，内层循环控制每个元素和有序数列进行比较，具体代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;

public class Charu {
    public static void main(String[] args) {
        int arr[] = {2, 5, 8, 7, 1, 0, 9};
        for (int i = 1; i &amp;lt; arr.length; i++) {
            for (int j = i; j &amp;gt; 0; j--) {
                if (arr[j] &amp;lt; arr[j - 1]) {
                    int s = arr[j];
                    arr[j] = arr[j - 1];
                    arr[j - 1] = s;
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  运行结果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508212026923.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;四希尔排序&quot;&gt;四、希尔排序&lt;/h4&gt;
&lt;h5 id=&quot;基本思想-3&quot;&gt;  1. 基本思想&lt;/h5&gt;
&lt;p&gt;  其实希尔排序是插入排序的升级版本，因为插入排序就相当于间隔为1的希尔排序。希尔排序就是选取一个合适的间隔n，让间隔为n的两个数进行比较，这样可以使数组大致的有点顺序，让我们再缩小间隔，直到把间隔缩小到1，那么整个数组就完成了排序。原理如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508212652273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpeGNfMTg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508212707654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpeGNfMTg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508212719417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpeGNfMTg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  如上面的图示，每一轮都可以使数组大致有序，当间隔为1的时候，数组就全部排好顺序。&lt;/p&gt;
&lt;h5 id=&quot;算法实现-3&quot;&gt;  2. 算法实现&lt;/h5&gt;
&lt;p&gt;  希尔排序用到了三层for循环，第一层是控制间隔d，第二层确定间隔为d的那个元素，第三次循环则控制间隔为d的两个元素进行比较，具体代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;

public class Shell {
    public static void main(String[] args) {
        int arr[] = {100, -2, 2, 5, 8, 7, 1, 0, 9};
        int index = 1;
        while (index &amp;lt; arr.length / 3) {
            index = index * 3 + 1;
        }
        for (int h = index; h &amp;gt; 0; h = (h - 1) / 3) {
            for (int i = h; i &amp;lt; arr.length; i++) {
                for (int j = i; j &amp;gt; h - 1; j -= h) {
                    if (arr[j] &amp;lt; arr[j - h]) {
                        int s = arr[j - h];
                        arr[j - h] = arr[j];
                        arr[j] = s;
                    }
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  代码中是while循环是为了选择一个合适的间隔，利用的克努特序列（h=3*h+1），因为选择一个合适的间隔可以减少循环的次数，提高效率。&lt;/p&gt;
&lt;h4 id=&quot;五快速排序&quot;&gt;五、快速排序&lt;/h4&gt;
&lt;h5 id=&quot;基本思想-4&quot;&gt;  1. 基本思想&lt;/h5&gt;
&lt;p&gt;  快速排序的基本思想就是选一个参照数，让每个元素和它进行比较，如果小于这个数就把这个数排到它的左边，如果小于它就排到它的右边。然后再对参照数左边的数据和右边的数据重复上述步骤，直到整个数组有序。&lt;/p&gt;
&lt;h5 id=&quot;算法实现-4&quot;&gt;  2. 算法实现&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508214740667.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpeGNfMTg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;实现的时候就&quot;/&gt;&lt;br/&gt;  具体代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Quicksort {
    public static void main(String[] args) {
        int arr[] = {100, -5, -56, 2, 5, 8, 7, 1, 0, 9};
        pai(arr,0,arr.length-1);
        System.out.println(Arrays.toString(arr));
    }
    public static void pai(int arr[], int start, int end) {
        if (end &amp;gt; start) {
            int index = getIndex(arr, start, end);
            pai(arr, start, index - 1);
            pai(arr, index + 1, end);
        }
    }
    private static int getIndex(int arr[], int startIndex, int endIndex) {
        int i = startIndex;
        int j = endIndex;
        int x = arr[i];
        while (j &amp;gt; i) {
            while (j &amp;gt; i &amp;amp;&amp;amp; arr[j] &amp;gt;= x) {
                j--;
            }
            if (j&amp;gt;i) {
                arr[i] = arr[j];
                i++;
            }
            while (j &amp;gt; i &amp;amp;&amp;amp; x &amp;gt;=arr[i]) {
                i++;
            }
            if (j&amp;gt;i) {
                arr[j] = arr[i];
                j--;
            }
        }
        arr[i] = x;
        return i;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  上面的代码主要内容就是要获取那个参照数的索引，getIndex()方法就是获取参照数的索引，而pai()方法就是对符号条件的元素进行交换，然后递归调用，直到排序完成。&lt;/p&gt;
&lt;h4 id=&quot;六归并排序&quot;&gt;六、归并排序&lt;/h4&gt;
&lt;h5 id=&quot;基本思想-5&quot;&gt;  1. 基本思想&lt;/h5&gt;
&lt;p&gt;  归并排序的思想就是该算法采用经典的分治（divide-and-conquer）策略，将大的问题分成小的问题，然后用递归进行解决。如下图所示，把数组分成单个的有序数列，然后再进行治的操作，把他们再合并为一个有序的数列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509161205102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpeGNfMTg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;算法实现-5&quot;&gt;  2. 算法实现&lt;/h5&gt;
&lt;p&gt;  代码分为两部分，第一步是就是利用递归把一个数组分成多个单个元素，第二步是治的阶段，把分完的元素，归到一块去，使之成为一个有序的数组。在实现的时候我们要创建一个临时数组进行存放元素，排序之后再把元素放到原来的数组里面。具体代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;

public class Guibing {
    public static void main(String[] args) {
        int arr[] = {1, -2, 3, 4, 5, 9, 6};
        chai(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }

    private static void chai(int[] arr, int start, int end) {
        int center = (start + end) / 2;
        if (end &amp;gt; start) {
            chai(arr, start, center);
            chai(arr, center + 1, end);
            gui(arr, start, center, end);

        }
    }

    private static void gui(int arr[], int start, int center, int end) {
        int tempArr[] = new int[end - start + 1];
        int i = start;
        int j = center + 1;
        int index = 0;
        while (i &amp;lt;= center &amp;amp;&amp;amp; j &amp;lt;= end) {
            if (arr[i] &amp;lt;= arr[j]) {
                tempArr[index] = arr[i];
                i++;
            } else {
                tempArr[index] = arr[j];
                j++;
            }
            index++;
        }
        while (i &amp;lt;= center) {
            tempArr[index] = arr[i];
            i++;
            index++;
        }
        while (j &amp;lt;= end) {
            tempArr[index] = arr[j];
            j++;
            index++;
        }
        for (int k = 0; k &amp;lt; tempArr.length; k++) {
            arr[k + start] = tempArr[k];
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  运行结果如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509162455850.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;#### 七、基数排序&lt;br/&gt;#####   1. 基本思想&lt;br/&gt;  基数排序和前面排序不同的是，基数排序不进行数据是比较，他是遍历每个元素，然后把个位相同的元素按顺序放到一个容器里面，得到一个顺序的数组；然后再把该数组里十位数相同的元素再次放到容器里面，再得到一个顺序的数组，直到把最大位的元素也排序成功，这时就会得到一个由顺序的数组。如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509165511448.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xpeGNfMTg=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;#####   2. 算法实现&lt;br/&gt;  基数排序需要创建一个二维数组，里面放10个容器用来存放数据，然后我们还需要找出最大的那个数，判断他是几位数，具体代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;

public class JishuSort {
    public static void main(String[] args) {
        int[] arr = {73, 22, 93, 43, 55, 14, 28};
        sortArr(arr);
        System.out.println(Arrays.toString(arr));
    }

    private static void sortArr(int[] arr) {
        //最大数有几位,我们就排几轮
        int max = getMax(arr);
        int len = String.valueOf(max).length();
        //定义一个二维数组,长度为10
        int[][] tempArr = new int[10][arr.length];
        //再定义一个数组,长度和二维数组的长度一样,用于记录二维数组中的每一个桶位存了几个数字
        int[] counts = new int[10];
        for (int i = 0, n = 1; i &amp;lt; len; i++, n *= 10) {
            //循环遍历,取每个位上的数字
            for (int j = 0; j &amp;lt; arr.length; j++) {
                //取每个位上的数字
                int ys = arr[j] / n % 10;
                //int count=counts[ys];
                tempArr[ys][counts[ys]] = arr[j];
                counts[ys]++;
                // count++;//二维数组中的一维数组放了要一个数,就在统计数组对应的位置统计一下
                // counts[ys] = count; //将累加后的值,赋值给统计数组
            }
            //取出每个桶中的元素,放入原来的数组
            int index = 0;
            for (int k = 0; k &amp;lt; counts.length; k++) {
                //取出统计数组在每个位置上统计的个数
                if (counts[k] != 0) {
                    for (int h = 0; h &amp;lt; counts[k]; h++) {
                        arr[index] = tempArr[k][h];
                        index++;
                    }
                    counts[k] = 0; //一趟完成后,把统计的个数清0
                }

            }
        }
    }

    private static int getMax(int[] arr) {
        int max = arr[0];
        for (int i = 1; i &amp;lt; arr.length; i++) {
            if (arr[i] &amp;gt; max) {
                max = arr[i];
            }
        }
        return max;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  以上就是我为大家介绍的几种排序。&lt;/p&gt;
</description>
<pubDate>Sat, 20 Jul 2019 15:44:00 +0000</pubDate>
<dc:creator>李十八</dc:creator>
<og:description>  数组有很多排序算法，主要的排序算法有10种：， 冒泡排序，选择排序，插入排序，希尔排序，快速排序，归并排序，基数排序，堆排序，计数排序，桶排序 。下面为大家简单介绍几种排序算法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixuec/p/11219826.html</dc:identifier>
</item>
</channel>
</rss>