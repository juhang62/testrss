<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>硬肝4.4w字为你写成Java开发手册 - 程序员cxuan</title>
<link>http://www.cnblogs.com/cxuanBlog/p/12854535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/12854535.html</guid>
<description>&lt;p&gt;先来看一下本篇文章的思维导图吧，我会围绕下面这些内容进行讲解。内容很干，小伙伴们看完还希望不吝转发。(高清思维导图版本关注作者公众号 &lt;code&gt;Java建设者&lt;/code&gt; 回复 &lt;code&gt;Java666&lt;/code&gt; 获取，其他思维导图获取方式在文末)。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200509064225879-1748594128.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面开始我们的文章。&lt;/p&gt;
&lt;h2 id=&quot;java-概述&quot;&gt;Java 概述&lt;/h2&gt;
&lt;h3 id=&quot;什么是-java？&quot;&gt;什么是 Java？&lt;/h3&gt;
&lt;p&gt;Java 是 Sun Microsystems 于1995 年首次发布的一种&lt;code&gt;编程语言&lt;/code&gt;和计算平台。编程语言还比较好理解，那么什么是 &lt;code&gt;计算平台&lt;/code&gt; 呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;计算平台是在电脑中运行应用程序（软件）的环境，包括&lt;code&gt;硬件环境&lt;/code&gt;和&lt;code&gt;软件环境&lt;/code&gt;。一般系统平台包括一台电脑的硬件体系结构、操作系统、运行时库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java 是快速，安全和可靠的。 从笔记本电脑到数据中心，从游戏机到科学超级计算机，从手机到互联网，Java 无处不在！Java 主要分为三个版本&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JavaSE(J2SE)(Java2 Platform Standard Edition，java平台标准版）&lt;/li&gt;
&lt;li&gt;JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)&lt;/li&gt;
&lt;li&gt;JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;java-的特点&quot;&gt;Java 的特点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Java 是一门&lt;code&gt;面向对象&lt;/code&gt;的编程语言&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;什么是面向对象？&lt;code&gt;面向对象(Object Oriented)&lt;/code&gt; 是一种软件开发思想。它是对现实世界的一种抽象，面向对象会把相关的数据和方法组织为一个整体来看待。&lt;/p&gt;
&lt;p&gt;相对的另外一种开发思想就是面向过程的开发思想，什么面向过程？&lt;code&gt;面向过程(Procedure Oriented)&lt;/code&gt; 是一种以过程为中心的编程思想。举个例子：比如你是个学生，你每天去上学需要做几件事情？&lt;/p&gt;
&lt;p&gt;起床、穿衣服、洗脸刷牙，吃饭，去学校。一般是顺序性的完成一系列动作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class student {
                void student_wakeUp(){...}
        void student_cloth(){...}
        void student_wash(){...}
        void student_eating(){...}
        void student_gotoSchool(){...}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而面向对象可以把学生进行抽象，所以这个例子就会变为&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class student(){
        void wakeUp(){...}
        void cloth(){...}
        void wash(){...}
        void eating(){...}
        void gotoSchool(){...}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以不用严格按照顺序来执行每个动作。这是特点一。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 摒弃了 C++ 中难以理解的多继承、指针、内存管理等概念；不用手动管理对象的生命周期，这是特征二。&lt;/li&gt;
&lt;li&gt;Java 语言具有功能强大和简单易用两个特征，现在企业级开发，快速敏捷开发，尤其是各种框架的出现，使 Java 成为越来越火的一门语言。这是特点三。&lt;/li&gt;
&lt;li&gt;Java 是一门静态语言，静态语言指的就是在编译期间就能够知道数据类型的语言，在运行前就能够检查类型的正确性，一旦类型确定后就不能再更改，比如下面这个例子。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void foo() {
    int x = 5;
    boolean b = x;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;静态语言主要有 &lt;strong&gt;Pascal, Perl, C/C++, JAVA, C#, Scala&lt;/strong&gt; 等。&lt;/p&gt;
&lt;p&gt;相对应的，动态语言没有任何特定的情况需要指定变量的类型，在运行时确定的数据类型。比如有**Lisp, Perl, Python、Ruby、JavaScript **等。&lt;/p&gt;
&lt;p&gt;从设计的角度上来说，所有的语言都是设计用来把人类可读的代码转换为机器指令。动态语言是为了能够让程序员提高编码效率，因此你可以使用更少的代码来实现功能。静态语言设计是用来让硬件执行的更高效，因此需要程序员编写准确无误的代码，以此来让你的代码尽快的执行。从这个角度来说，静态语言的执行效率要比动态语言高，速度更快。这是特点四。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 具有平台独立性和可移植性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java 有一句非常著名的口号： &lt;code&gt;Write once, run anywhere&lt;/code&gt;，也就是一次编写、到处运行。为什么 Java 能够吹出这种牛批的口号来？核心就是 &lt;code&gt;JVM&lt;/code&gt;。我们知道，计算机应用程序和硬件之间会屏蔽很多细节，它们之间依靠操作系统完成调度和协调，大致的体系结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwycV.png&quot; alt=&quot;YKwycV.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么加上 Java 应用、JVM 的体系结构会变为如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKws10.png&quot; alt=&quot;YKws10.png&quot;/&gt;&lt;p&gt;Java 是跨平台的，已编译的 Java 程序可以在任何带有 JVM 的平台上运行。你可以在 Windows 平台下编写代码，然后拿到 Linux 平台下运行，该如何实现呢？&lt;/p&gt;
&lt;p&gt;首先你需要在应用中编写 Java 代码；&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;Eclipse&lt;/code&gt; 或者 &lt;code&gt;javac&lt;/code&gt; 把 Java 代码编译为 &lt;code&gt;.class&lt;/code&gt; 文件；&lt;/p&gt;
&lt;p&gt;然后把你的 .class 文件打成 &lt;code&gt;.jar&lt;/code&gt; 文件；&lt;/p&gt;
&lt;p&gt;然后你的 .jar 文件就能够在 Windows 、Mac OS X、Linux 系统下运行了。不同的操作系统有不同的 JVM 实现，切换平台时，不需要再次编译你的 Java 代码了。这是特点五。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 能够容易实现多线程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java 是一门高级语言，高级语言会对用户屏蔽很多底层实现细节。比如 Java 是如何实现多线程的。从操作系统的角度来说，实现多线程的方式主要有下面这几种&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在用户空间中实现多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在内核空间中实现多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在用户和内核空间中混合实现线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而我认为 Java 应该是在 &lt;code&gt;用户空间&lt;/code&gt; 实现的多线程，内核是感知不到 Java 存在多线程机制的。这是特点六。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 具有高性能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们编写的代码，经过 javac 编译器编译称为 &lt;code&gt;字节码(bytecode)&lt;/code&gt;，经过 JVM 内嵌的解释器将字节码转换为机器代码，这是解释执行，这种转换过程效率较低。但是部分 JVM 的实现比如 &lt;code&gt;Hotspot JVM&lt;/code&gt; 都提供了 &lt;code&gt;JIT(Just-In-Time)&lt;/code&gt; 编译器，也就是通常所说的动态编译􏱆器，JIT 能够在运行时将􏲀热点代码编译机器码，这种方式运行效率比较高，这是编译执行。所以 Java 不仅仅只是一种解释执行的语言。这是特点七。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 语言具有健壮性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证。这也是 Java 与 C 语言的重要区别。这是特点八。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java 很容易开发分布式项目&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java 语言支持 Internet 应用的开发，Java 中有 net api，它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的 &lt;code&gt;RMI（远程方法激活）&lt;/code&gt;机制也是开发分布式应用的重要手段。这是特点九。&lt;/p&gt;
&lt;h3 id=&quot;java-开发环境&quot;&gt;Java 开发环境&lt;/h3&gt;
&lt;h4 id=&quot;jdk&quot;&gt;JDK&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;JDK（Java Development Kit）&lt;/code&gt;称为 Java 开发包或 Java 开发工具，是一个编写 Java 的 Applet 小程序和应用程序的程序开发环境。JDK是整个Java的核心，包括了&lt;code&gt;Java运行环境（Java Runtime Environment）&lt;/code&gt;，一些&lt;code&gt;Java 工具&lt;/code&gt; 和 &lt;code&gt;Java 的核心类库（Java API）&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwgnU.png&quot; alt=&quot;YKwgnU.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以认真研究一下这张图，它几乎包括了 Java 中所有的概念，我使用的是 &lt;code&gt;jdk1.8&lt;/code&gt;，可以点进去 &lt;code&gt;Description of Java Conceptual Diagram&lt;/code&gt;， 可以发现这里面包括了所有关于 Java 的描述&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKw2BF.png&quot; alt=&quot;YKw2BF.png&quot;/&gt;&lt;p&gt;Oracle 提供了两种 Java 平台的实现，一种是我们上面说的 JDK，Java 开发标准工具包，一种是 JRE，叫做Java Runtime Environment，Java 运行时环境。JDK 的功能要比 JRE 全很多。&lt;/p&gt;
&lt;h4 id=&quot;jre&quot;&gt;JRE&lt;/h4&gt;
&lt;p&gt;JRE 是个运行环境，JDK 是个开发环境。因此写 Java 程序的时候需要 JDK，而运行 Java 程序的时候就需要JRE。而 JDK 里面已经包含了JRE，因此只要安装了JDK，就可以编辑 Java 程序，也可以正常运行 Java 程序。但由于 JDK 包含了许多与运行无关的内容，占用的空间较大，因此运行普通的 Java 程序无须安装 JDK，而只需要安装 JRE 即可。&lt;/p&gt;
&lt;h2 id=&quot;java-开发环境配置&quot;&gt;Java 开发环境配置&lt;/h2&gt;
&lt;p&gt;这个地方不再多说了，网上有很多教程配置的资料可供参考。&lt;/p&gt;
&lt;h2 id=&quot;java-基本语法&quot;&gt;Java 基本语法&lt;/h2&gt;
&lt;p&gt;在配置完 Java 开发环境，并下载 Java 开发工具（Eclipse、IDEA 等）后，就可以写 Java 代码了，因为本篇文章是从头梳理 Java 体系，所以有必要从基础的概念开始谈起。&lt;/p&gt;
&lt;h3 id=&quot;数据类型&quot;&gt;数据类型&lt;/h3&gt;
&lt;p&gt;在 Java 中，数据类型只有&lt;code&gt;四类八种&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整数型：byte、short、int、long&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;byte 也就是字节，1 byte = 8 bits，byte 的默认值是 0 ；&lt;/p&gt;
&lt;p&gt;short 占用两个字节，也就是 16 位，1 short = 16 bits，它的默认值也是 0 ；&lt;/p&gt;
&lt;p&gt;int 占用四个字节，也就是 32 位，1 int = 32 bits，默认值是 0 ；&lt;/p&gt;
&lt;p&gt;long 占用八个字节，也就是 64 位，1 long = 64 bits，默认值是 0L；&lt;/p&gt;
&lt;p&gt;所以整数型的占用字节大小空间为 long &amp;gt; int &amp;gt; short &amp;gt; byte&lt;/p&gt;
&lt;p&gt;浮点型有两种数据类型：float 和 double&lt;/p&gt;
&lt;p&gt;float 是单精度浮点型，占用 4 位，1 float = 32 bits，默认值是 0.0f；&lt;/p&gt;
&lt;p&gt;double 是双精度浮点型，占用 8 位，1 double = 64 bits，默认值是 0.0d；&lt;/p&gt;
&lt;p&gt;字符型就是 char，char 类型是一个单一的 16 位 Unicode 字符，最小值是 &lt;code&gt;\u0000 (也就是 0 )&lt;/code&gt;，最大值是 &lt;code&gt;\uffff (即为 65535)&lt;/code&gt;，char 数据类型可以存储任何字符，例如 char a = 'A'。&lt;/p&gt;
&lt;p&gt;布尔型指的就是 boolean，boolean 只有两种值，true 或者是 false，只表示 1 位，默认值是 false。&lt;/p&gt;
&lt;p&gt;以上 &lt;code&gt;x 位&lt;/code&gt;都指的是在内存中的占用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwR74.png&quot; alt=&quot;YKwR74.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础语法&quot;&gt;基础语法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;大小写敏感：Java 是对大小写敏感的语言，例如 Hello 与 hello 是不同的，这其实就是 Java 的字符串表示方式&lt;/li&gt;
&lt;li&gt;类名：对于所有的类来说，首字母应该大写，例如 &lt;code&gt;MyFirstClass&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;包名：包名应该尽量保证小写，例如 &lt;code&gt;my.first.package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;方法名：方法名首字母需要小写，后面每个单词字母都需要大写，例如 &lt;code&gt;myFirstMethod()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;运算符&quot;&gt;运算符&lt;/h3&gt;
&lt;p&gt;运算符不只 Java 中有，其他语言也有运算符，运算符是一些特殊的符号，主要用于数学函数、一些类型的赋值语句和逻辑比较方面，我们就以 Java 为例，来看一下运算符。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;赋值运算符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;赋值运算符使用操作符 &lt;code&gt;=&lt;/code&gt; 来表示，它的意思是把 = 号右边的值复制给左边，右边的值可以是任何常数、变量或者表达式，但左边的值必须是一个明确的，已经定义的变量。比如 &lt;code&gt;int a = 4&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是对于对象来说，复制的不是对象的值，而是对象的引用，所以如果说将一个对象复制给另一个对象，实际上是将&lt;strong&gt;一个对象的引用赋值给另一个对象&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算数运算符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;算数运算符就和数学中的数值计算差不多，主要有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKw4hR.png&quot; alt=&quot;YKw4hR.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;算数运算符需要注意的就是&lt;code&gt;优先级问题&lt;/code&gt;，当一个表达式中存在多个操作符时，操作符的优先级顺序就决定了计算顺序，最简单的规则就是先乘除后加减，&lt;code&gt;()&lt;/code&gt; 的优先级最高，没必要记住所有的优先级顺序，不确定的直接用 () 就可以了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自增、自减运算符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个就不文字解释了，解释不如直接看例子明白&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int a = 5;
b = ++a;
c = a++;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;比较运算符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比较运算符用于程序中的变量之间，变量和自变量之间以及其他类型的信息之间的比较。&lt;/p&gt;
&lt;p&gt;比较运算符的运算结果是 boolean 型。当运算符对应的关系成立时，运算的结果为 true，否则为 false。比较运算符共有 6 个，通常作为判断的依据用于条件语句中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwfAJ.png&quot; alt=&quot;YKwfAJ.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;逻辑运算符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;逻辑运算符主要有三种，与、或、非&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwhN9.png&quot; alt=&quot;YKwhN9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是逻辑运算符对应的 true/false 符号表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwI91.png&quot; alt=&quot;YKwI91.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按位运算符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;按位运算符用来操作整数基本类型中的每个&lt;code&gt;比特&lt;/code&gt;位，也就是二进制位。按位操作符会对两个参数中对应的位执行布尔代数运算，并最终生成一个结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwo1x.png&quot; alt=&quot;YKwo1x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果进行比较的双方是数字的话，那么进行比较就会变为按位运算。&lt;/p&gt;
&lt;p&gt;按位与：按位进行与运算（AND），两个操作数中位都为1，结果才为1，否则结果为0。需要首先把比较双方转换成二进制再按每个位进行比较&lt;/p&gt;
&lt;p&gt;按位或：按位进行或运算（OR），两个位只要有一个为1，那么结果就是1，否则就为0。&lt;/p&gt;
&lt;p&gt;按位非：按位进行异或运算（XOR），如果位为0，结果是1，如果位为1，结果是0。&lt;/p&gt;
&lt;p&gt;按位异或：按位进行取反运算（NOT），两个操作数的位中，相同则结果为0，不同则结果为1。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;移位运算符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;移位运算符用来将操作数向某个方向（向左或者右）移动指定的二进制位数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwTc6.png&quot; alt=&quot;YKwTc6.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;三元运算符&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;三元运算符是类似 &lt;code&gt;if...else...&lt;/code&gt; 这种的操作符，语法为：&lt;strong&gt;条件表达式？表达式 1：表达式 2&lt;/strong&gt;。问号前面的位置是判断的条件，判断结果为布尔型，为 true 时调用表达式 1，为 false 时调用表达式 2。&lt;/p&gt;
&lt;h2 id=&quot;java-执行控制流程&quot;&gt;Java 执行控制流程&lt;/h2&gt;
&lt;p&gt;Java 中的控制流程其实和 C 一样，在 Java 中，流程控制会涉及到包括 &lt;strong&gt;if-else、while、do-while、for、return、break&lt;/strong&gt; 以及选择语句 &lt;code&gt;switch&lt;/code&gt;。下面以此进行分析&lt;/p&gt;
&lt;h3 id=&quot;条件语句&quot;&gt;条件语句&lt;/h3&gt;
&lt;p&gt;条件语句可根据不同的条件执行不同的语句。包括 if 条件语句与 switch 多分支语句。&lt;/p&gt;
&lt;h4 id=&quot;if-条件语句&quot;&gt;if 条件语句&lt;/h4&gt;
&lt;p&gt;if 语句可以单独判断表达式的结果，表示表达的执行结果，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int a = 10;
if(a &amp;gt; 10){
  return true;
}
return false;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;ifelse-条件语句&quot;&gt;if...else 条件语句&lt;/h4&gt;
&lt;p&gt;if 语句还可以与 else 连用，通常表现为 &lt;strong&gt;如果满足某种条件，就进行某种处理，否则就进行另一种处理&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int a = 10;
int b = 11;
if(a &amp;gt;= b){
  System.out.println(&quot;a &amp;gt;= b&quot;);
}else{
  System.out.println(&quot;a &amp;lt; b&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;if 后的 () 内的表达式必须是 boolean 型的。如果为 true，则执行 if 后的复合语句；如果为 false，则执行 else 后的复合语句。&lt;/p&gt;
&lt;h4 id=&quot;ifelse-if-多分支语句&quot;&gt;if...else if 多分支语句&lt;/h4&gt;
&lt;p&gt;上面中的 if...else 是单分支和两个分支的判断，如果有多个判断条件，就需要使用 &lt;strong&gt;if...else if&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int x = 40;
if(x &amp;gt; 60) {
  System.out.println(&quot;x的值大于60&quot;);
} else if (x &amp;gt; 30) {
  System.out.println(&quot;x的值大于30但小于60&quot;);
} else if (x &amp;gt; 0) {
  System.out.println(&quot;x的值大于0但小于30&quot;);
} else {
  System.out.println(&quot;x的值小于等于0&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;switch-多分支语句&quot;&gt;switch 多分支语句&lt;/h4&gt;
&lt;p&gt;一种比 **if...else if ** 语句更优雅的方式是使用 &lt;code&gt;switch&lt;/code&gt; 多分支语句，它的示例如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;switch (week) {
  case 1:
    System.out.println(&quot;Monday&quot;);
    break;
  case 2:
    System.out.println(&quot;Tuesday&quot;);
    break;
  case 3:
    System.out.println(&quot;Wednesday&quot;);
    break;
  case 4:
    System.out.println(&quot;Thursday&quot;);
    break;
  case 5:
    System.out.println(&quot;Friday&quot;);
    break;
  case 6:
    System.out.println(&quot;Saturday&quot;);
    break;
  case 7:
    System.out.println(&quot;Sunday&quot;);
    break;
  default:
    System.out.println(&quot;No Else&quot;);
    break;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;循环语句&quot;&gt;循环语句&lt;/h3&gt;
&lt;p&gt;循环语句就是在满足一定的条件下反复执行某一表达式的操作，直到满足循环语句的要求。使用的循环语句主要有 **for、do...while() 、 while **，&lt;/p&gt;
&lt;h4 id=&quot;while-循环语句&quot;&gt;while 循环语句&lt;/h4&gt;
&lt;p&gt;while 循环语句的循环方式为利用一个条件来控制是否要继续反复执行这个语句。while 循环语句的格式如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;while(布尔值){
  表达式
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它的含义是，当 (布尔值) 为 true 的时候，执行下面的表达式，布尔值为 false 的时候，结束循环，布尔值其实也是一个表达式，比如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int a = 10;
while(a &amp;gt; 5){
  a--;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;dowhile-循环&quot;&gt;do...while 循环&lt;/h4&gt;
&lt;p&gt;while 与 do...while 循环的唯一区别是 do...while 语句至少执行一次，即使第一次的表达式为 false。而在 while 循环中，如果第一次条件为 false，那么其中的语句根本不会执行。在实际应用中，while 要比 do...while 应用的更广。它的一般形式如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int b = 10;
// do···while循环语句
do {
  System.out.println(&quot;b == &quot; + b);
  b--;
} while(b == 1);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;for-循环语句&quot;&gt;for 循环语句&lt;/h4&gt;
&lt;p&gt;for 循环是我们经常使用的循环方式，这种形式会在第一次迭代前进行初始化。它的形式如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for(初始化; 布尔表达式; 步进){}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每次迭代前会测试布尔表达式。如果获得的结果是 false，就会执行 for 语句后面的代码；每次循环结束，会按照步进的值执行下一次循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;逗号操作符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里不可忽略的一个就是逗号操作符，Java 里唯一用到逗号操作符的就是 for 循环控制语句。在表达式的初始化部分，可以使用一系列的逗号分隔的语句；通过逗号操作符，可以在 for 语句内定义多个变量，但它们必须具有相同的类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for(int i = 1;j = i + 10;i &amp;lt; 5;i++, j = j * 2){}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;for-each 语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Java JDK 1.5 中还引入了一种更加简洁的、方便对数组和集合进行遍历的方法，即 &lt;code&gt;for-each&lt;/code&gt; 语句，例子如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int array[] = {7, 8, 9};

for (int arr : array) {
     System.out.println(arr);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;跳转语句&quot;&gt;跳转语句&lt;/h3&gt;
&lt;p&gt;Java 语言中，有三种跳转语句: &lt;strong&gt;break、continue 和 return&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;break-语句&quot;&gt;break 语句&lt;/h4&gt;
&lt;p&gt;break 语句我们在 switch 中已经见到了，它是用于终止循环的操作，实际上 break 语句在for、while、do···while循环语句中，用于强行退出当前循环，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for(int i = 0;i &amp;lt; 10;i++){
        if(i == 5){
    break;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;continue-语句&quot;&gt;continue 语句&lt;/h4&gt;
&lt;p&gt;continue 也可以放在循环语句中，它与 break 语句具有相反的效果，它的作用是用于执行下一次循环，而不是退出当前循环，还以上面的例子为主&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for(int i = 0;i &amp;lt; 10;i++){
  
  System.out.printl(&quot; i = &quot; + i );
        if(i == 5){
    System.out.printl(&quot;continue ... &quot;);
    continue;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;return 语句&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;return 语句可以从一个方法返回，并把控制权交给调用它的语句。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void getName() {
    return name;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;面向对象&quot;&gt;面向对象&lt;/h2&gt;
&lt;p&gt;下面我们来探讨面向对象的思想，面向对象的思想已经逐步取代了过程化的思想 --- 面向过程，Java 是面向对象的高级编程语言，面向对象语言具有如下特征&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;面向对象是一种常见的思想，比较符合人们的思考习惯；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;面向对象可以将复杂的业务逻辑简单化，增强代码复用性；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;面向对象具有抽象、封装、继承、多态等特性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;面向对象的编程语言主要有：C++、Java、C#等。&lt;/p&gt;
&lt;p&gt;所以必须熟悉面向对象的思想才能编写出 Java 程序。&lt;/p&gt;
&lt;h3 id=&quot;类也是一种对象&quot;&gt;类也是一种对象&lt;/h3&gt;
&lt;p&gt;现在我们来认识一个面向对象的新的概念 --- 类，什么是类，它就相当于是一系列对象的抽象，就比如书籍一样，类相当于是书的封面，大多数面向对象的语言都使用 &lt;code&gt;class&lt;/code&gt; 来定义类，它告诉你它里面定义的对象都是什么样的，我们一般使用下面来定义类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class ClassName {
        // body;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码段中涉及一个新的概念 &lt;code&gt;//&lt;/code&gt; ，这个我们后面会说。上面，你声明了一个 class 类，现在，你就可以使用 new 来创建这个对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ClassName classname = new ClassName();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般，类的命名遵循&lt;code&gt;驼峰原则&lt;/code&gt;，它的定义如下&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;骆驼式命名法（Camel-Case）又称驼峰式命名法，是电脑程式编写时的一套命名规则（惯例）。正如它的名称 CamelCase 所表示的那样，是指混合使用大小写字母来构成变量和函数的名字。程序员们为了自己的代码能更容易的在同行之间交流，所以多采取统一的可读性比较好的命名方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;对象的创建&quot;&gt;对象的创建&lt;/h3&gt;
&lt;p&gt;在 Java 中，&lt;strong&gt;万事万物都是对象&lt;/strong&gt;。这句话相信你一定不陌生，尽管一切都看作是对象，但是你操纵的却是一个对象的 &lt;code&gt;引用(reference)&lt;/code&gt;。在这里有一个很形象的比喻：你可以把车钥匙和车看作是一组&lt;strong&gt;对象引用和对象&lt;/strong&gt;的组合。当你想要开车的时候，你首先需要拿出车钥匙点击开锁的选项，停车时，你需要点击加锁来锁车。车钥匙相当于就是引用，车就是对象，由车钥匙来驱动车的加锁和开锁。并且，即使没有车的存在，车钥匙也是一个独立存在的实体，也就是说，&lt;strong&gt;你有一个对象引用，但你不一定需要一个对象与之关联&lt;/strong&gt;，也就是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Car carKey;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里创建的只是引用，而并非对象，但是如果你想要使用 s 这个引用时，会返回一个异常，告诉你需要一个对象来和这个引用进行关联。一种安全的做法是，在创建对象引用时同时把一个对象赋给它。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Car carKey = new Car();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 Java 中，一旦创建了一个引用，就希望它能与一个新的对象进行关联，通常使用 &lt;code&gt;new&lt;/code&gt; 操作符来实现这一目的。new 的意思是，给我一个新&lt;code&gt;对象&lt;/code&gt;，如果你不想相亲，自己 new 一个对象就好了。祝你下辈子幸福。&lt;/p&gt;
&lt;h3 id=&quot;属性和方法&quot;&gt;属性和方法&lt;/h3&gt;
&lt;p&gt;类一个最基本的要素就是有属性和方法。&lt;/p&gt;
&lt;p&gt;属性也被称为字段，它是类的重要组成部分，属性可以是任意类型的对象，也可以是基本数据类型。例如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class A{
  int a;
  Apple apple;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类中还应该包括方法，方法表示的是 &lt;strong&gt;做某些事情的方式&lt;/strong&gt;。方法其实就是函数，只不过 Java 习惯把函数称为方法。这种叫法也体现了面向对象的概念。&lt;/p&gt;
&lt;p&gt;方法的基本组成包括 &lt;strong&gt;方法名称、参数、返回值和方法体&lt;/strong&gt;， 下面是它的示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int getResult(){
  // ...
  return 1;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&lt;code&gt;getResult&lt;/code&gt; 就是方法名称、&lt;code&gt;()&lt;/code&gt; 里面表示方法接收的参数、&lt;code&gt;return&lt;/code&gt; 表示方法的返回值，注意：方法的返回值必须和方法的&lt;code&gt;参数&lt;/code&gt;类型保持一致。有一种特殊的参数类型 --- &lt;code&gt;void&lt;/code&gt; 表示方法无返回值。&lt;code&gt;{}&lt;/code&gt; 包含的代码段被称为方法体。&lt;/p&gt;
&lt;h4 id=&quot;构造方法&quot;&gt;构造方法&lt;/h4&gt;
&lt;p&gt;在 Java 中，有一种特殊的方法被称为 &lt;code&gt;构造方法&lt;/code&gt;，也被称为构造函数、构造器等。在 Java 中，通过提供这个构造器，来确保每个对象都被初始化。构造方法只能在对象的创建时期调用一次，保证了对象初始化的进行。构造方法比较特殊，它没有参数类型和返回值，它的名称要和类名保持一致，并且构造方法可以有多个，下面是一个构造方法的示例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Apple {
  
  int sum;
  String color;
  
  public Apple(){}
  public Apple(int sum){}
  public Apple(String color){}
  public Apple(int sum,String color){}
  
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面定义了一个 Apple 类，你会发现这个 Apple 类没有参数类型和返回值，并且有多个以 Apple 同名的方法，而且各个 Apple 的参数列表都不一样，这其实是一种多态的体现，我们后面会说。在定义完成构造方法后，我们就能够创建 Apple 对象了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class createApple {

    public static void main(String[] args) {
        Apple apple1 = new Apple();
        Apple apple2 = new Apple(1);
        Apple apple3 = new Apple(&quot;red&quot;);
        Apple apple4 = new Apple(2,&quot;color&quot;);

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上面所示，我们定义了四个 Apple 对象，并调用了 Apple 的四种不同的构造方法，其中，不加任何参数的构造方法被称为默认的构造方法，也就是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Apple apple1 = new Apple();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果类中没有定义任何构造方法，那么 JVM 会为你自动生成一个构造方法，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Apple {
  
  int sum;
  String color;
  
}

class createApple {

    public static void main(String[] args) {
        Apple apple1 = new Apple();

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码不会发生编译错误，因为 Apple 对象包含了一个默认的构造方法。&lt;/p&gt;
&lt;p&gt;默认的构造方法也被称为默认构造器或者无参构造器。&lt;/p&gt;
&lt;p&gt;这里需要注意一点的是，即使 JVM 会为你默认添加一个无参的构造器，但是如果你手动定义了任何一个构造方法，&lt;strong&gt;JVM 就不再为你提供默认的构造器，你必须手动指定，否则会出现编译错误&lt;/strong&gt;。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwbnO.png&quot; alt=&quot;YKwbnO.png&quot;/&gt;&lt;p&gt;显示的错误是，必须提供 Apple 带有 int 参数的构造函数，而默认的无参构造函数没有被允许使用。&lt;/p&gt;
&lt;h4 id=&quot;方法重载&quot;&gt;方法重载&lt;/h4&gt;
&lt;p&gt;在 Java 中一个很重要的概念是方法的重载，它是类名的不同表现形式。我们上面说到了构造函数，其实构造函数也是重载的一种。另外一种就是方法的重载&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Apple {

    int sum;
    String color;

    public Apple(){}
    public Apple(int sum){}
    
    public int getApple(int num){
        return 1;
    }
    
    public String getApple(String color){
        return &quot;color&quot;;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上面所示，就有两种重载的方式，一种是 Apple 构造函数的重载，一种是 getApple 方法的重载。&lt;/p&gt;
&lt;p&gt;但是这样就涉及到一个问题，要是有几个相同的名字，Java 如何知道你调用的是哪个方法呢？这里记住一点即可，&lt;strong&gt;每个重载的方法都有独一无二的参数列表&lt;/strong&gt;。其中包括参数的类型、顺序、参数数量等，满足一种一个因素就构成了重载的必要条件。&lt;/p&gt;
&lt;p&gt;请记住下面重载的条件&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法名称必须相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;参数列表必须不同（个数不同、或类型不同、参数类型排列顺序不同等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法的返回类型可以相同也可以不相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;仅仅返回类型不同不足以成为方法的重载。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;重载是发生在编译时的，因为编译器可以根据参数的类型来选择使用哪个方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;方法的重写&quot;&gt;方法的重写&lt;/h4&gt;
&lt;p&gt;方法的重写与重载虽然名字很相似，但却完全是不同的东西。方法重写的描述是对&lt;code&gt;子类和父类&lt;/code&gt;之间的。而重载指的是同一类中的。例如如下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Fruit {
 
        public void eat(){
    System.out.printl('eat fruit');
  }
}

class Apple extends Fruit{
  
  @Override
  public void eat(){
    System.out.printl('eat apple');
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码描述的就是重写的代码，你可以看到，子类 Apple 中的方法和父类 Fruit 中的方法同名，所以，我们能够推断出重写的原则&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重写的方法必须要和父类保持一致，包括&lt;strong&gt;返回值类型,方法名,参数列表&lt;/strong&gt; 也都一样。&lt;/li&gt;
&lt;li&gt;重写的方法可以使用 &lt;code&gt;@Override&lt;/code&gt; 注解来标识&lt;/li&gt;
&lt;li&gt;子类中重写方法的访问权限不能低于父类中方法的访问权限。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;h4 id=&quot;类的初始化&quot;&gt;类的初始化&lt;/h4&gt;
&lt;p&gt;上面我们创建出来了一个 Car 这个对象，其实在使用 new 关键字创建一个对象的时候，其实是调用了这个对象无参数的构造方法进行的初始化，也就是如下这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Car{
  public Car(){}
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个无参数的构造函数可以隐藏，由 JVM 自动添加。也就是说，构造函数能够确保类的初始化。&lt;/p&gt;
&lt;h4 id=&quot;成员初始化&quot;&gt;成员初始化&lt;/h4&gt;
&lt;p&gt;Java 会尽量保证每个变量在使用前都会获得初始化，初始化涉及两种初始化。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;一种是编译器默认指定的字段初始化，基本数据类型的初始化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKw7jK.png&quot; alt=&quot;YKw7jK.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一种是其他对象类型的初始化，String 也是一种对象，对象的初始值都为 &lt;code&gt;null&lt;/code&gt; ，其中也包括基本类型的包装类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一种是指定数值的初始化，例如&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int a = 11
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说， 指定 a 的初始化值不是 0 ，而是 11。其他基本类型和对象类型也是一样的。&lt;/p&gt;
&lt;h4 id=&quot;构造器初始化&quot;&gt;构造器初始化&lt;/h4&gt;
&lt;p&gt;可以利用构造器来对某些方法和某些动作进行初始化，确定初始值，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Counter{
  int i;
  public Counter(){
    i = 11;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用构造函数，能够把 i 的值初始化为 11。&lt;/p&gt;
&lt;h4 id=&quot;初始化顺序&quot;&gt;初始化顺序&lt;/h4&gt;
&lt;p&gt;首先先来看一下有哪些需要探讨的初始化顺序&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;静态属性：static 开头定义的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;静态方法块： static {} 包起来的代码块&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;普通属性： 非 static 定义的属性&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;普通方法块： {} 包起来的代码块&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;构造函数： 类名相同的方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方法： 普通方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LifeCycle {
    // 静态属性
    private static String staticField = getStaticField();
    // 静态方法块
    static {
        System.out.println(staticField);
        System.out.println(&quot;静态方法块初始化&quot;);
    }
    // 普通属性
    private String field = getField();
    // 普通方法块
    {
        System.out.println(field);
    }
    // 构造函数
    public LifeCycle() {
        System.out.println(&quot;构造函数初始化&quot;);
    }

    public static String getStaticField() {
        String statiFiled = &quot;Static Field Initial&quot;;
        return statiFiled;
    }

    public static String getField() {
        String filed = &quot;Field Initial&quot;;
        return filed;
    }   
    // 主函数
    public static void main(String[] argc) {
        new LifeCycle();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的执行结果就反应了它的初始化顺序&lt;/p&gt;
&lt;p&gt;静态属性初始化&lt;br/&gt;静态方法块初始化&lt;br/&gt;普通属性初始化&lt;br/&gt;普通方法块初始化&lt;br/&gt;构造函数初始化&lt;/p&gt;
&lt;h4 id=&quot;数组初始化&quot;&gt;数组初始化&lt;/h4&gt;
&lt;p&gt;数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方括号下标操作符 &lt;code&gt;[]&lt;/code&gt; 来定义使用。&lt;/p&gt;
&lt;p&gt;一般数组是这么定义的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int[] a1;

//或者

int a1[];
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两种格式的含义是一样的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接给每个元素赋值 : int array[4] = {1,2,3,4};&lt;/li&gt;
&lt;li&gt;给一部分赋值，后面的都为 0 ： int array[4] = {1,2};&lt;/li&gt;
&lt;li&gt;由赋值参数个数决定数组的个数 ： int array[] = {1,2};&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;可变参数列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java 中一种数组冷门的用法就是&lt;code&gt;可变参数&lt;/code&gt; ，可变参数的定义如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public int add(int... numbers){
  int sum = 0;
  for(int num : numbers){
    sum += num;
  }
  return sum;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，你可以使用下面这几种方式进行可变参数的调用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;add();  // 不传参数
add(1);  // 传递一个参数
add(2,1);  // 传递多个参数
add(new Integer[] {1, 3, 2});  // 传递数组
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;对象的销毁&quot;&gt;对象的销毁&lt;/h3&gt;
&lt;p&gt;虽然 Java 语言是基于 C++ 的，但是它和 C/C++ 一个重要的特征就是不需要手动管理对象的销毁工作。在著名的一书 《深入理解 Java 虚拟机》中提到一个观点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwqBD.png&quot; alt=&quot;YKwqBD.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 Java 中，我们不再需要手动管理对象的销毁，它是由 &lt;code&gt;Java 虚拟机&lt;/code&gt;进行管理和销毁的。虽然我们不需要手动管理对象，但是你需要知道 &lt;code&gt;对象作用域&lt;/code&gt; 这个概念。&lt;/p&gt;
&lt;h4 id=&quot;对象作用域&quot;&gt;对象作用域&lt;/h4&gt;
&lt;p&gt;J多数语言都有&lt;code&gt;作用域(scope)&lt;/code&gt; 这个概念。作用域决定了其内部定义的变量名的可见性和生命周期。在 C、C++ 和 Java 中，作用域通常由 &lt;code&gt;{}&lt;/code&gt; 的位置来决定，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  int a = 11;
  {
    int b = 12;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;a 变量会在两个 &lt;code&gt;{}&lt;/code&gt; 作用域内有效，而 b 变量的值只能在它自己的 &lt;code&gt;{}&lt;/code&gt; 内有效。&lt;/p&gt;
&lt;p&gt;虽然存在作用域，但是不允许这样写&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  int x = 11;
  {
    int x = 12;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种写法在 C/C++ 中是可以的，但是在 Java 中不允许这样写，因为 Java 设计者认为这样写会导致程序混乱。&lt;/p&gt;
&lt;h3 id=&quot;this-和-super&quot;&gt;this 和 super&lt;/h3&gt;
&lt;p&gt;this 和 super 都是 Java 中的关键字&lt;/p&gt;
&lt;p&gt;this 表示的当前对象，this 可以调用方法、调用属性和指向对象本身。this 在 Java 中的使用一般有三种：指向当前对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Apple {

    int i = 0;

    Apple eatApple(){
        i++;
        return this;
    }

    public static void main(String[] args) {
        Apple apple = new Apple();
        apple.eatApple().eatApple();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码比较精妙，精妙在哪呢，我一个 eatApple() 方法竟然可以调用多次，你在后面还可以继续调用，这就很神奇了，为啥呢？其实就是 this 在作祟了，我在 &lt;code&gt;eatApple&lt;/code&gt; 方法中加了一个 &lt;code&gt;return this&lt;/code&gt; 的返回值，也就是说哪个对象调用 eatApple 方法都能返回对象的自身。&lt;/p&gt;
&lt;p&gt;this 还可以修饰属性，最常见的就是在构造方法中使用 this ，如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Apple {

    private int num;
    
    public Apple(int num){
        this.num = num;
    }

    public static void main(String[] args) {
        new Apple(10);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;main 方法中传递了一个 int 值为 10 的参数，它表示的就是苹果的数量，并把这个数量赋给了 num 全局变量。所以 num 的值现在就是 10。&lt;/p&gt;
&lt;p&gt;this 还可以和构造函数一起使用，充当一个全局关键字的效果&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Apple {

    private int num;
    private String color;

    public Apple(int num){
        this(num,&quot;红色&quot;);
    }
    
    public Apple(String color){
        this(1,color);
    }

    public Apple(int num, String color) {
        this.num = num;
        this.color = color;
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你会发现上面这段代码使用的不是 this, 而是 &lt;code&gt;this(参数)&lt;/code&gt;。它相当于调用了其他构造方法，然后传递参数进去。这里注意一点：this() 必须放在构造方法的第一行，否则编译不通过&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwLHe.png&quot; alt=&quot;YKwLHe.png&quot;/&gt;&lt;p&gt;如果你把 this 理解为指向自身的一个引用，那么 super 就是指向父类的一个引用。super 关键字和 this 一样，你可以使用 &lt;code&gt;super.对象&lt;/code&gt; 来引用父类的成员，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Fruit {

    int num;
    String color;

    public void eat(){
        System.out.println(&quot;eat Fruit&quot;);
    }
}

public class Apple extends Fruit{

    @Override
    public void eat() {
        super.num = 10;
        System.out.println(&quot;eat &quot; + num + &quot; Apple&quot;);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你也可以使用 &lt;code&gt;super(参数)&lt;/code&gt; 来调用父类的构造函数，这里不再举例子了。&lt;/p&gt;
&lt;p&gt;下面为你汇总了 this 关键字和 super 关键字的比较。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwXAH.png&quot; alt=&quot;YKwXAH.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;访问控制权限&quot;&gt;访问控制权限&lt;/h2&gt;
&lt;p&gt;访问控制权限又称为&lt;code&gt;封装&lt;/code&gt;，它是面向对象三大特性中的一种，我之前在学习过程中经常会忽略封装，心想这不就是一个访问修饰符么，怎么就是三大特性的必要条件了？后来我才知道，&lt;strong&gt;如果你信任的下属对你隐瞒 bug，你是根本不知道的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;访问控制权限其实最核心就是一点：只对需要的类可见。&lt;/p&gt;
&lt;p&gt;Java中成员的访问权限共有四种，分别是 &lt;strong&gt;public、protected、default、private&lt;/strong&gt;，它们的可见性如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwjNd.png&quot; alt=&quot;YKwjNd.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;
&lt;p&gt;继承是所有 &lt;code&gt;OOP(Object Oriented Programming)&lt;/code&gt; 语言和 Java 语言都不可或缺的一部分。只要我们创建了一个类，就隐式的继承自 &lt;code&gt;Object&lt;/code&gt; 父类，只不过没有指定。如果你显示指定了父类，那么你继承于父类，而你的父类继承于 Object 类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKw6XT.png&quot; alt=&quot;YKw6XT.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继承的关键字是 &lt;code&gt;extends&lt;/code&gt; ，如上图所示，如果使用了 extends 显示指定了继承，那么我们可以说 Father 是父类，而 Son 是子类，用代码表示如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Father{}

class Son extends Father{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承双方拥有某种共性的特征&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class Father{
  
  public void feature(){
    System.out.println(&quot;父亲的特征&quot;);
  }
}

class Son extends Father {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 Son 没有实现自己的方法的话，那么默认就是用的是父类的 &lt;code&gt;feature&lt;/code&gt; 方法。如果子类实现了自己的 feature 方法，那么就相当于是重写了父类的 feature 方法，这也是我们上面提到的重写了。&lt;/p&gt;
&lt;h3 id=&quot;多态&quot;&gt;多态&lt;/h3&gt;
&lt;p&gt;多态指的是同一个行为具有多个不同表现形式。是指一个类实例（对象）的相同方法在不同情形下具有不同表现形式。封装和继承是多态的基础，也就是说，多态只是一种表现形式而已。&lt;/p&gt;
&lt;p&gt;如何实现多态？多态的实现具有三种充要条件&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;重写父类方法&lt;/li&gt;
&lt;li&gt;父类引用指向子类对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比如下面这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Fruit {

    int num;

    public void eat(){
        System.out.println(&quot;eat Fruit&quot;);
    }
}

public class Apple extends Fruit{

    @Override
    public void eat() {
        super.num = 10;
        System.out.println(&quot;eat &quot; + num + &quot; Apple&quot;);
    }

    public static void main(String[] args) {
        Fruit fruit = new Apple();
        fruit.eat();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以发现 &lt;code&gt;main&lt;/code&gt; 方法中有一个很神奇的地方，&lt;code&gt;Fruit fruit = new Apple()&lt;/code&gt;，Fruit 类型的对象竟然指向了 Apple 对象的引用，这其实就是多态 -&amp;gt; 父类引用指向子类对象，因为 Apple 继承于 Fruit，并且重写了 eat 方法，所以能够表现出来多种状态的形式。&lt;/p&gt;
&lt;h3 id=&quot;组合&quot;&gt;组合&lt;/h3&gt;
&lt;p&gt;组合其实不难理解，就是将对象引用置于新类中即可。组合也是一种提高类的复用性的一种方式。如果你想让类具有更多的扩展功能，你需要记住一句话&lt;strong&gt;多用组合，少用继承&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SoccerPlayer {
    
    private String name;
    private Soccer soccer;
    
}

public class Soccer {
    
    private String soccerName;    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中 SoccerPlayer 引用了 Soccer 类，通过引用 Soccer 类，来达到调用 soccer 中的属性和方法。&lt;/p&gt;
&lt;p&gt;组合和继承是有区别的，它们的主要区别如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwv4A.png&quot; alt=&quot;YKwv4A.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于继承和组合孰优孰劣的争论没有结果，只要发挥各自的长处和优点即可，一般情况下，组合和继承也是一对可以连用的好兄弟。&lt;/p&gt;
&lt;h3 id=&quot;代理&quot;&gt;代理&lt;/h3&gt;
&lt;p&gt;除了继承和组合外，另外一种值得探讨的关系模型称为 &lt;code&gt;代理&lt;/code&gt;。代理的大致描述是，A 想要调用 B 类的方法，A 不直接调用，A 会在自己的类中创建一个 B 对象的代理，再由代理调用 B 的方法。例如如下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Destination {

    public void todo(){
        System.out.println(&quot;control...&quot;);
    }
}

public class Device {

    private String name;
    private Destination destination;
    private DeviceController deviceController;

    public void control(Destination destination){
        destination.todo();
    }

}

public class DeviceController {

    private Device name;
    private Destination destination;

    public void control(Destination destination){
        destination.todo();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;向上转型&quot;&gt;向上转型&lt;/h3&gt;
&lt;p&gt;向上转型代表了父类与子类之间的关系，其实父类和子类之间不仅仅有向上转型，还有向下转型，它们的转型后的范围不一样&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;向上转型&lt;/code&gt;：通过子类对象(小范围)转化为父类对象(大范围)，这种转换是自动完成的，不用强制。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;向下转型&lt;/code&gt; : 通过父类对象(大范围)实例化子类对象(小范围)，这种转换不是自动完成的，需要强制指定。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;static&quot;&gt;static&lt;/h3&gt;
&lt;p&gt;static 是 Java 中的关键字，它的意思是 &lt;code&gt;静态的&lt;/code&gt;，static 可以用来修饰成员变量和方法，static 用在没有创建对象的情况下调用 方法/变量。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用 static 声明的成员变量为静态成员变量，也成为类变量。类变量的生命周期和类相同，在整个应用程序执行期间都有效。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static String name = &quot;cxuan&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用 static 修饰的方法称为静态方法，静态方法能够直接使用&lt;strong&gt;类名.方法名&lt;/strong&gt; 进行调用。由于静态方法不依赖于任何对象就可以直接访问，因此对于静态方法来说，是没有 this 关键字的，实例变量都会有 this 关键字。在静态方法中不能访问类的非静态成员变量和非静态方法，&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static void printMessage(){
  System.out.println(&quot;cxuan is writing the article&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;static 除了修饰属性和方法外，还有&lt;code&gt;静态代码块&lt;/code&gt; 的功能，可用于类的初始化操作。进而提升程序的性能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StaicBlock {
    static{
        System.out.println(&quot;I'm A static code block&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于静态代码块随着类的加载而执行，因此，很多时候会将只需要进行一次的初始化操作放在 static 代码块中进行。&lt;/p&gt;
&lt;h3 id=&quot;final&quot;&gt;final&lt;/h3&gt;
&lt;p&gt;final 的意思是最后的、最终的，它可以修饰类、属性和方法。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;final 修饰类时，表明这个类不能被继承。final 类中的成员变量可以根据需要设为 final，但是要注意 final 类中的所有成员方法都会被隐式地指定为 final 方法。&lt;/li&gt;
&lt;li&gt;final 修饰方法时，表明这个方法不能被任何子类重写，因此，如果只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为 final。&lt;/li&gt;
&lt;li&gt;final 修饰变量分为两种情况，一种是修饰基本数据类型，表示数据类型的值不能被修改；一种是修饰引用类型，表示对其初始化之后便不能再让其指向另一个对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;接口和抽象类&quot;&gt;接口和抽象类&lt;/h2&gt;
&lt;h3 id=&quot;接口&quot;&gt;接口&lt;/h3&gt;
&lt;p&gt;接口相当于就是对外的一种约定和标准，这里拿操作系统举例子，为什么会有操作系统？就会为了屏蔽软件的复杂性和硬件的简单性之间的差异，为软件提供统一的标准。&lt;/p&gt;
&lt;p&gt;在 Java 语言中，接口是由 &lt;code&gt;interface&lt;/code&gt; 关键字来表示的，比如我们可以向下面这样定义一个接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface CxuanGoodJob {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如我们定义了一个 CxuanGoodJob 的接口，然后你就可以在其内部定义 cxuan 做的好的那些事情，比如 cxuan 写的文章不错。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface CxuanGoodJob {

    void writeWell();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里隐含了一些接口的特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;interface&lt;/code&gt; 接口是一个完全抽象的类，他不会提供任何方法的实现，只是会进行方法的定义。&lt;/li&gt;
&lt;li&gt;接口中只能使用两种访问修饰符，一种是 &lt;code&gt;public&lt;/code&gt;，它对整个项目可见；一种是 &lt;code&gt;default&lt;/code&gt; 缺省值，它只具有包访问权限。&lt;/li&gt;
&lt;li&gt;接口只提供方法的定义，接口没有实现，但是接口可以被其他类实现。也就是说，实现接口的类需要提供方法的实现，实现接口使用 &lt;code&gt;implements&lt;/code&gt; 关键字来表示，一个接口可以有多个实现。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class CXuanWriteWell implements CxuanGoodJob{

    @Override
    public void writeWell() {
        System.out.println(&quot;Cxuan write Java is vary well&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;接口不能被实例化，所以接口中不能有任何构造方法，你定义构造方法编译会出错。&lt;/li&gt;
&lt;li&gt;接口的实现比如实现接口的全部方法，否则必须定义为&lt;code&gt;抽象类&lt;/code&gt;，这就是我们下面要说的内容&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;抽象类&quot;&gt;抽象类&lt;/h3&gt;
&lt;p&gt;抽象类是一种抽象能力弱于接口的类，在 Java 中，抽象类使用 &lt;code&gt;abstract&lt;/code&gt; 关键字来表示。如果把接口形容为狗这个物种，那么抽象类可以说是毛发是白色、小体的品种，而实现类可以是具体的类，比如说是博美、泰迪等。你可以像下面这样定义抽象类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Dog {

    void FurColor();

}

abstract class WhiteDog implements Dog{

    public void FurColor(){
        System.out.println(&quot;Fur is white&quot;);
    }

    abstract void SmallBody();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在抽象类中，具有如下特征&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果一个类中有抽象方法，那么这个类一定是抽象类，也就是说，使用关键字 &lt;code&gt;abstract&lt;/code&gt; 修饰的方法一定是抽象方法，具有抽象方法的类一定是抽象类。实现类方法中只有方法具体的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;抽象类中不一定只有抽象方法，抽象类中也可以有具体的方法，你可以自己去选择是否实现这些方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;抽象类中的约束不像接口那么严格，你可以在抽象类中定义 &lt;strong&gt;构造方法、抽象方法、普通属性、方法、静态属性和静态方法&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;抽象类和接口一样不能被实例化，实例化只能实例化&lt;code&gt;具体的类&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;异常&quot;&gt;异常&lt;/h2&gt;
&lt;p&gt;异常是程序经常会出现的，发现错误的最佳时机是在编译阶段，也就是你试图在运行程序之前。但是，在编译期间并不能找到所有的错误，有一些 &lt;code&gt;NullPointerException&lt;/code&gt; 和 &lt;code&gt;ClassNotFoundException&lt;/code&gt; 异常在编译期找不到，这些异常是 RuntimeException 运行时异常，这些异常往往在运行时才能被发现。&lt;/p&gt;
&lt;p&gt;我们写 Java 程序经常会出现两种问题，一种是 java.lang.Exception ，一种是 java.lang.Error，都用来表示出现了异常情况，下面就针对这两种概念进行理解。&lt;/p&gt;
&lt;h3 id=&quot;认识-exception&quot;&gt;认识 Exception&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Exception&lt;/code&gt; 位于 &lt;code&gt;java.lang&lt;/code&gt; 包下，它是一种顶级接口，继承于 &lt;code&gt;Throwable&lt;/code&gt; 类，Exception 类及其子类都是 Throwable 的组成条件，是程序出现的合理情况。&lt;/p&gt;
&lt;p&gt;在认识 Exception 之前，有必要先了解一下什么是 &lt;code&gt;Throwable&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;什么是-throwable&quot;&gt;什么是 Throwable&lt;/h3&gt;
&lt;p&gt;Throwable 类是 Java 语言中所有&lt;code&gt;错误(errors)&lt;/code&gt;和&lt;code&gt;异常(exceptions)&lt;/code&gt;的父类。只有继承于 Throwable 的类或者其子类才能够被抛出，还有一种方式是带有 Java 中的 &lt;code&gt;@throw&lt;/code&gt; 注解的类也可以抛出。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se9/html/jls-11.html#jls-11.1.1&quot;&gt;Java规范&lt;/a&gt;中，对非受查异常和受查异常的定义是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;The &lt;em&gt;unchecked exception classes&lt;/em&gt; are the run-time exception classes and the error classes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;The &lt;em&gt;checked exception classes&lt;/em&gt; are all exception classes other than the unchecked exception classes. That is, the checked exception classes are &lt;code&gt;Throwable&lt;/code&gt; and all its subclasses other than &lt;code&gt;RuntimeException&lt;/code&gt; and its subclasses and &lt;code&gt;Error&lt;/code&gt;and its subclasses.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说，除了 &lt;code&gt;RuntimeException&lt;/code&gt; 和其子类，以及&lt;code&gt;error&lt;/code&gt;和其子类，其它的所有异常都是 &lt;code&gt;checkedException&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么，按照这种逻辑关系，我们可以对 Throwable 及其子类进行归类分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YKwz9I.png&quot; alt=&quot;YKwz9I.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，Throwable 位于异常和错误的最顶层，我们查看 Throwable 类中发现它的方法和属性有很多，我们只讨论其中几个比较常用的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 返回抛出异常的详细信息
public string getMessage();
public string getLocalizedMessage();

//返回异常发生时的简要描述
public public String toString()；
  
// 打印异常信息到标准输出流上
public void printStackTrace();
public void printStackTrace(PrintStream s);
public void printStackTrace(PrintWriter s)

// 记录栈帧的的当前状态
public synchronized Throwable fillInStackTrace();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此外，因为 Throwable 的父类也是 &lt;code&gt;Object&lt;/code&gt;，所以常用的方法还有继承其父类的&lt;code&gt;getClass()&lt;/code&gt; 和 &lt;code&gt;getName()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h3 id=&quot;常见的-exception&quot;&gt;常见的 Exception&lt;/h3&gt;
&lt;p&gt;下面我们回到 Exception 的探讨上来，现在你知道了 Exception 的父类是 Throwable，并且 Exception 有两种异常，一种是 &lt;code&gt;RuntimeException&lt;/code&gt; ；一种是 &lt;code&gt;CheckedException&lt;/code&gt;，这两种异常都应该去&lt;code&gt;捕获&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面列出了一些 Java 中常见的异常及其分类，这块面试官也可能让你举出几个常见的异常情况并将其分类&lt;/p&gt;
&lt;p&gt;RuntimeException&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0S3t.png&quot; alt=&quot;YK0S3t.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UncheckedException&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0pgP.png&quot; alt=&quot;YK0pgP.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;与-exception-有关的-java-关键字&quot;&gt;与 Exception 有关的 Java 关键字&lt;/h3&gt;
&lt;p&gt;那么 Java 中是如何处理这些异常的呢？在 Java 中有这几个关键字 &lt;strong&gt;throws、throw、try、finally、catch&lt;/strong&gt; 下面我们分别来探讨一下&lt;/p&gt;
&lt;h4 id=&quot;throws-和-throw&quot;&gt;throws 和 throw&lt;/h4&gt;
&lt;p&gt;在 Java 中，异常也就是一个对象，它能够被程序员自定义抛出或者应用程序抛出，必须借助于 &lt;code&gt;throws&lt;/code&gt; 和 &lt;code&gt;throw&lt;/code&gt; 语句来定义抛出异常。&lt;/p&gt;
&lt;p&gt;throws 和 throw 通常是成对出现的，例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static void cacheException() throws Exception{

  throw new Exception();

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;throw 语句用在方法体内，表示抛出异常，由方法体内的语句处理。&lt;br/&gt;throws 语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。&lt;/p&gt;
&lt;p&gt;throws 主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。&lt;br/&gt;throw 是具体向外抛异常的动作，所以它是抛出一个异常实例。&lt;/p&gt;
&lt;h4 id=&quot;try-、finally-、catch&quot;&gt;try 、finally 、catch&lt;/h4&gt;
&lt;p&gt;这三个关键字主要有下面几种组合方式 &lt;strong&gt;try...catch 、try...finally、try...catch...finally&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;try...catch 表示对某一段代码可能抛出异常进行的捕获，如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static void cacheException() throws Exception{

  try {
    System.out.println(&quot;1&quot;);
  }catch (Exception e){
    e.printStackTrace();
  }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;try...finally 表示对一段代码不管执行情况如何，都会走 finally 中的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static void cacheException() throws Exception{
  for (int i = 0; i &amp;lt; 5; i++) {
    System.out.println(&quot;enter: i=&quot; + i);
    try {
      System.out.println(&quot;execute: i=&quot; + i);
      continue;
    } finally {
      System.out.println(&quot;leave: i=&quot; + i);
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;try...catch...finally 也是一样的，表示对异常捕获后，再走 finally 中的代码逻辑。&lt;/p&gt;
&lt;h3 id=&quot;什么是-error&quot;&gt;什么是 Error&lt;/h3&gt;
&lt;p&gt;Error 是程序无法处理的错误，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。这些错误是不可检查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况，比如 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 和 &lt;code&gt;StackOverflowError&lt;/code&gt;异常的出现会有几种情况，这里需要先介绍一下 Java 内存模型 JDK1.7。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK09jf.png&quot; alt=&quot;YK09jf.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中包括两部分，&lt;strong&gt;由所有线程共享的数据区和线程隔离的数据区&lt;/strong&gt;组成，在上面的 Java 内存模型中，&lt;strong&gt;只有程序计数器&lt;/strong&gt;是不会发生 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 情况的区域，程序计数器控制着计算机指令的分支、循环、跳转、异常处理和线程恢复，并且程序计数器是每个线程私有的。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;什么是线程私有：表示的就是各条线程之间互不影响，独立存储的内存区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果应用程序执行的是 Java 方法，那么这个计数器记录的就是&lt;code&gt;虚拟机字节码&lt;/code&gt;指令的地址；如果正在执行的是 &lt;code&gt;Native&lt;/code&gt; 方法，这个计数器值则为&lt;code&gt;空(Undefined)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;除了程序计数器外，其他区域：&lt;code&gt;方法区(Method Area)&lt;/code&gt;、&lt;code&gt;虚拟机栈(VM Stack)&lt;/code&gt;、&lt;code&gt;本地方法栈(Native Method Stack)&lt;/code&gt; 和 &lt;code&gt;堆(Heap)&lt;/code&gt; 都是可能发生 OutOfMemoryError 的区域。&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;虚拟机栈：如果线程请求的栈深度大于虚拟机栈所允许的深度，将会出现 &lt;code&gt;StackOverflowError&lt;/code&gt; 异常；如果虚拟机动态扩展无法申请到足够的内存，将出现 &lt;code&gt;OutOfMemoryError&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;本地方法栈和虚拟机栈一样&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;堆：Java 堆可以处于物理上不连续，逻辑上连续，就像我们的磁盘空间一样，如果堆中没有内存完成实例分配，并且堆无法扩展时，将会抛出 OutOfMemoryError。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;方法区：方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在 Java 中，你可以把异常理解为是一种能够提高你程序健壮性的机制，它能够让你在编写代码中注意这些问题，也可以说，如果你写代码不会注意这些异常情况，你是无法成为一位硬核程序员的。&lt;/p&gt;
&lt;h2 id=&quot;内部类&quot;&gt;内部类&lt;/h2&gt;
&lt;p&gt;距今为止，我们了解的都是普通类的定义，那就是直接在 IDEA 中直接新建一个 class 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0Pu8.png&quot; alt=&quot;YK0Pu8.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新建完成后，你就会拥有一个 class 文件的定义，这种操作太简单了，时间长了就会枯燥，我们年轻人多需要更新潮和骚气的写法，好吧，既然你提到了那就使用 &lt;code&gt;内部类&lt;/code&gt;吧，这是一种有用而且骚气的定义类的方式，内部类的定义非常简单：&lt;strong&gt;可以将一个类的定义放在另一个类的内部，这就是内部类&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内部类是一种非常有用的特性，定义在类内部的类，持有外部类的引用，但却对其他外部类不可见，看起来就像是一种隐藏代码的机制，就和 &lt;code&gt;弗兰奇将军&lt;/code&gt; 似的，弗兰奇可以和弗兰奇将军进行通讯，但是外面的敌人却无法直接攻击到弗兰奇本体。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0iDS.png&quot; alt=&quot;YK0iDS.png&quot;/&gt;&lt;p&gt;下面我们就来聊一聊创建内部类的方式。&lt;/p&gt;
&lt;h3 id=&quot;创建内部类&quot;&gt;创建内部类&lt;/h3&gt;
&lt;p&gt;定义内部类非常简单，就是直接将一个类定义在外围类的里面，如下代码所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class OuterClass {
    private String name ;
    private int age;
    
    class InnerClass{
        public InnerClass(){
            name = &quot;cxuan&quot;;
            age = 25;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码中，InnerClass 就是 OuterClass 的一个内部类。也就是说，每个内部类都能独立地继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。这也是隐藏了内部实现细节。&lt;strong&gt;内部类拥有外部类的访问权&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内部类不仅仅能够定义在类的内部，还可以定义在方法和作用域内部，这种被称为&lt;code&gt;局部内部类&lt;/code&gt;，除此之外，还有匿名内部类、内部类可以实现 Java 中的 &lt;code&gt;多重继承&lt;/code&gt;。下面是定义内部类的方式&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;一个在方法中定义的类(局部内部类)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;一个定义在作用域内的类，这个作用域在方法的内部(成员内部类)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;一个实现了接口的匿名类(匿名内部类)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;一个匿名类，它扩展了非默认构造器的类
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;一个匿名类，执行字段初始化操作
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;pre&gt;
&lt;code&gt;一个匿名类，它通过实例初始化实现构造
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于每个类都会产生一个 &lt;code&gt;.class&lt;/code&gt; 文件，其中包含了如何创建该类型的对象的全部信息，那么，如何表示内部类的信息呢？可以使用 &lt;code&gt;$&lt;/code&gt; 来表示，比如 &lt;strong&gt;OuterClass$InnerClass.class&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;集合&quot;&gt;集合&lt;/h2&gt;
&lt;p&gt;集合在我们的日常开发中所使用的次数简直太多了，你已经把它们都用的熟透了，但是作为一名合格的程序员，你不仅要了解它的基本用法，你还要了解它的源码；存在即合理，你还要了解它是如何设计和实现的，你还要了解它的衍生过程。&lt;/p&gt;
&lt;p&gt;这篇博客就来详细介绍一下 Collection 这个庞大集合框架的家族体系和成员，让你了解它的设计与实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;是时候祭出这张神图了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0AEQ.png&quot; alt=&quot;YK0AEQ.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先来介绍的就是列表爷爷辈儿的接口- &lt;strong&gt;Iterator&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;iterable-接口&quot;&gt;Iterable 接口&lt;/h3&gt;
&lt;p&gt;实现此接口允许对象成为 for-each 循环的目标，也就是增强 for 循环，它是 Java 中的一种&lt;code&gt;语法糖&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;Object&amp;gt; list = new ArrayList();
for (Object obj: list){}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了实现此接口的对象外，数组也可以用 for-each 循环遍历，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Object[] list = new Object[10];
for (Object obj: list){}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其他遍历方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jdk 1.8之前&lt;code&gt;Iterator&lt;/code&gt;只有 iterator 一个方法，就是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Iterator&amp;lt;T&amp;gt; iterator();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现次接口的方法能够创建一个轻量级的迭代器，用于安全的遍历元素，移除元素，添加元素。这里面涉及到一个 &lt;code&gt;fail-fast&lt;/code&gt; 机制。&lt;/p&gt;
&lt;p&gt;总之一点就是能创建迭代器进行元素的添加和删除的话，就尽量使用迭代器进行添加和删除。&lt;/p&gt;
&lt;p&gt;也可以使用迭代器的方式进行遍历&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;for(Iterator it = coll.iterator(); it.hasNext(); ){
    System.out.println(it.next());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;顶层接口&quot;&gt;顶层接口&lt;/h3&gt;
&lt;p&gt;Collection 是一个顶层接口，它主要用来定义集合的约定&lt;/p&gt;
&lt;p&gt;List 接口也是一个顶层接口，它继承了 Collection 接口 ，同时也是 ArrayList、LinkedList 等集合元素的父类&lt;/p&gt;
&lt;p&gt;Set 接口位于与 List 接口同级的层次上，它同时也继承了 Collection 接口。Set 接口提供了额外的规定。它对add、equals、hashCode 方法提供了额外的标准。&lt;/p&gt;
&lt;p&gt;Queue 是和 List、Set 接口并列的 Collection 的三大接口之一。Queue 的设计用来在处理之前保持元素的访问次序。除了 Collection 基础的操作之外，队列提供了额外的插入，读取，检查操作。&lt;/p&gt;
&lt;p&gt;SortedSet 接口直接继承于 Set 接口，使用 Comparable 对元素进行自然排序或者使用 Comparator 在创建时对元素提供定制的排序规则。set 的迭代器将按升序元素顺序遍历集合。&lt;/p&gt;
&lt;p&gt;Map 是一个支持 key-value 存储的对象，Map 不能包含重复的 key，每个键最多映射一个值。这个接口代替了Dictionary 类，Dictionary 是一个抽象类而不是接口。&lt;/p&gt;
&lt;h4 id=&quot;arraylist&quot;&gt;ArrayList&lt;/h4&gt;
&lt;p&gt;ArrayList 是实现了 List 接口的&lt;code&gt;可扩容数组(动态数组)&lt;/code&gt;，它的内部是基于数组实现的。它的具体定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ArrayList&amp;lt;E&amp;gt; extends AbstractList&amp;lt;E&amp;gt; implements List&amp;lt;E&amp;gt;, RandomAccess, Cloneable, java.io.Serializable {...}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ArrayList 可以实现所有可选择的列表操作，允许所有的元素，包括空值。ArrayList 还提供了内部存储 list 的方法，它能够完全替代 Vector，只有一点例外，ArrayList 不是线程安全的容器。&lt;/li&gt;
&lt;li&gt;ArrayList 有一个容量的概念，这个数组的容量就是 List 用来存储元素的容量。&lt;/li&gt;
&lt;li&gt;ArrayList 不是线程安全的容器，如果多个线程中至少有两个线程修改了 ArrayList 的结构的话就会导致线程安全问题，作为替代条件可以使用线程安全的 List，应使用 &lt;code&gt;Collections.synchronizedList&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List list = Collections.synchronizedList(new ArrayList(...))
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ArrayList 具有 fail-fast 快速失败机制，能够对 ArrayList 作出失败检测。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生 fail-fast，即抛出 &lt;code&gt;ConcurrentModificationException&lt;/code&gt; 异常。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;vector&quot;&gt;Vector&lt;/h4&gt;
&lt;p&gt;Vector 同 ArrayList 一样，都是基于数组实现的，只不过 Vector 是一个线程安全的容器，它对内部的每个方法都简单粗暴的上锁，避免多线程引起的安全性问题，但是通常这种同步方式需要的开销比较大，因此，访问元素的效率要远远低于 ArrayList。&lt;/p&gt;
&lt;p&gt;还有一点在于扩容上，ArrayList 扩容后的数组长度会增加 50%，而 Vector 的扩容长度后数组会增加一倍。&lt;/p&gt;
&lt;h4 id=&quot;linkedlist-类&quot;&gt;LinkedList 类&lt;/h4&gt;
&lt;p&gt;LinkedList 是一个双向链表，允许存储任何元素(包括 null )。它的主要特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LinkedList 所有的操作都可以表现为双向性的，索引到链表的操作将遍历从头到尾，视哪个距离近为遍历顺序。&lt;/li&gt;
&lt;li&gt;注意这个实现也不是线程安全的，如果多个线程并发访问链表，并且至少其中的一个线程修改了链表的结构，那么这个链表必须进行外部加锁。或者使用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List list = Collections.synchronizedList(new LinkedList(...))
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;stack&quot;&gt;Stack&lt;/h4&gt;
&lt;p&gt;堆栈是我们常说的&lt;code&gt;后入先出(吃了吐)&lt;/code&gt;的容器 。它继承了 Vector 类，提供了通常用的 push 和 pop 操作，以及在栈顶的 peek 方法，测试 stack 是否为空的 empty 方法，和一个寻找与栈顶距离的 search 方法。&lt;/p&gt;
&lt;p&gt;第一次创建栈，不包含任何元素。一个更完善，可靠性更强的 LIFO 栈操作由 Deque 接口和他的实现提供，应该优先使用这个类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Deque&amp;lt;Integer&amp;gt; stack = new ArrayDeque&amp;lt;Integer&amp;gt;()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;hashset&quot;&gt;HashSet&lt;/h4&gt;
&lt;p&gt;HashSet 是 Set 接口的实现类，由哈希表支持(实际上 HashSet 是 HashMap 的一个实例)。它不能保证集合的迭代顺序。这个类允许 null 元素。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注意这个实现不是线程安全的。如果多线程并发访问 HashSet，并且至少一个线程修改了set，必须进行外部加锁。或者使用 &lt;code&gt;Collections.synchronizedSet()&lt;/code&gt; 方法重写。&lt;/li&gt;
&lt;li&gt;这个实现支持 fail-fast 机制。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;treeset&quot;&gt;TreeSet&lt;/h4&gt;
&lt;p&gt;TreeSet 是一个基于 TreeMap 的 NavigableSet 实现。这些元素使用他们的自然排序或者在创建时提供的Comparator 进行排序，具体取决于使用的构造函数。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;此实现为基本操作 add,remove 和 contains 提供了 log(n) 的时间成本。&lt;/li&gt;
&lt;li&gt;注意这个实现不是线程安全的。如果多线程并发访问 TreeSet，并且至少一个线程修改了 set，必须进行外部加锁。或者使用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;SortedSet s = Collections.synchronizedSortedSet(new TreeSet(...))
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这个实现持有 fail-fast 机制。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;linkedhashset-类&quot;&gt;LinkedHashSet 类&lt;/h4&gt;
&lt;p&gt;LinkedHashSet 继承于 Set，先来看一下 LinkedHashSet 的继承体系：&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0FHg.png&quot; alt=&quot;YK0FHg.png&quot;/&gt;&lt;p&gt;LinkedHashSet 是 Set 接口的 Hash 表和 LinkedList 的实现。这个实现不同于 HashSet 的是它维护着一个贯穿所有条目的双向链表。此链表定义了元素插入集合的顺序。注意：如果元素重新插入，则插入顺序不会受到影响。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LinkedHashSet 有两个影响其构成的参数： 初始容量和加载因子。它们的定义与 HashSet 完全相同。但请注意：对于 LinkedHashSet，选择过高的初始容量值的开销要比 HashSet 小，因为 LinkedHashSet 的迭代次数不受容量影响。&lt;/li&gt;
&lt;li&gt;注意 LinkedHashSet 也不是线程安全的，如果多线程同时访问 LinkedHashSet，必须加锁，或者通过使用&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Collections.synchronizedSet
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;该类也支持fail-fast机制&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;priorityqueue&quot;&gt;PriorityQueue&lt;/h4&gt;
&lt;p&gt;PriorityQueue 是 AbstractQueue 的实现类，优先级队列的元素根据自然排序或者通过在构造函数时期提供Comparator 来排序，具体根据构造器判断。PriorityQueue 不允许 null 元素。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;队列的头在某种意义上是指定顺序的最后一个元素。队列查找操作 poll,remove,peek 和 element 访问队列头部元素。&lt;/li&gt;
&lt;li&gt;优先级队列是无限制的，但具有内部 capacity，用于控制用于在队列中存储元素的数组大小。&lt;/li&gt;
&lt;li&gt;该类以及迭代器实现了 Collection、Iterator 接口的所有可选方法。这个迭代器提供了 &lt;code&gt;iterator()&lt;/code&gt; 方法不能保证以任何特定顺序遍历优先级队列的元素。如果你需要有序遍历，考虑使用 &lt;code&gt;Arrays.sort(pq.toArray())&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;注意这个实现不是线程安全的，多线程不应该并发访问 PriorityQueue 实例如果有某个线程修改了队列的话，使用线程安全的类 &lt;code&gt;PriorityBlockingQueue&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;hashmap&quot;&gt;HashMap&lt;/h4&gt;
&lt;p&gt;HashMap 是一个利用哈希表原理来存储元素的集合，并且允许空的 key-value 键值对。HashMap 是非线程安全的，也就是说在多线程的环境下，可能会存在问题，而 Hashtable 是线程安全的容器。HashMap 也支持 fail-fast 机制。HashMap 的实例有两个参数影响其性能：初始容量 和加载因子。可以使用 &lt;code&gt;Collections.synchronizedMap(new HashMap(...))&lt;/code&gt; 来构造一个线程安全的 HashMap。&lt;/p&gt;
&lt;h4 id=&quot;treemap-类&quot;&gt;TreeMap 类&lt;/h4&gt;
&lt;p&gt;一个基于 NavigableMap 实现的红黑树。这个 map 根据 key 自然排序存储，或者通过 Comparator 进行定制排序。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;TreeMap 为 containsKey,get,put 和remove方法提供了 log(n) 的时间开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;注意这个实现不是线程安全的。如果多线程并发访问 TreeMap，并且至少一个线程修改了 map，必须进行外部加锁。这通常通过在自然封装集合的某个对象上进行同步来实现，或者使用 &lt;code&gt;SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...))&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这个实现持有fail-fast机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;linkedhashmap-类&quot;&gt;LinkedHashMap 类&lt;/h4&gt;
&lt;p&gt;LinkedHashMap 是 Map 接口的哈希表和链表的实现。这个实现与 HashMap 不同之处在于它维护了一个贯穿其所有条目的双向链表。这个链表定义了遍历顺序，通常是插入 map 中的顺序。&lt;/p&gt;
&lt;ul readability=&quot;7.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;它提供一个特殊的 LinkedHashMap(int,float,boolean) 构造器来创建 LinkedHashMap，其遍历顺序是其最后一次访问的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以重写 removeEldestEntry(Map.Entry) 方法，以便在将新映射添加到 map 时强制删除过期映射的策略。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;这个类提供了所有可选择的 map 操作，并且允许 null 元素。由于维护链表的额外开销，性能可能会低于HashMap，有一条除外：遍历 LinkedHashMap 中的 collection-views 需要与 map.size 成正比，无论其容量如何。HashMap 的迭代看起来开销更大，因为还要求时间与其容量成正比。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;LinkedHashMap 有两个因素影响了它的构成：初始容量和加载因子。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;注意这个实现不是线程安全的。如果多线程并发访问LinkedHashMap，并且至少一个线程修改了map，必须进行外部加锁。这通常通过在自然封装集合的某个对象上进行同步来实现 &lt;code&gt;Map m = Collections.synchronizedMap(new LinkedHashMap(...))&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;这个实现持有fail-fast机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;hashtable-类&quot;&gt;Hashtable 类&lt;/h4&gt;
&lt;p&gt;Hashtable 类实现了一个哈希表，能够将键映射到值。任何非空对象都可以用作键或值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;此实现类支持 fail-fast 机制&lt;/li&gt;
&lt;li&gt;与新的集合实现不同，Hashtable 是线程安全的。如果不需要线程安全的容器，推荐使用 HashMap，如果需要多线程高并发，推荐使用 &lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;identityhashmap-类&quot;&gt;IdentityHashMap 类&lt;/h4&gt;
&lt;p&gt;IdentityHashMap 是比较小众的 Map 实现了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这个类不是一个通用的 Map 实现！虽然这个类实现了 Map 接口，但它故意违反了 Map 的约定，该约定要求在比较对象时使用 equals 方法，此类仅适用于需要引用相等语义的极少数情况。&lt;/li&gt;
&lt;li&gt;同 HashMap，IdentityHashMap 也是无序的，并且该类不是线程安全的，如果要使之线程安全，可以调用&lt;code&gt;Collections.synchronizedMap(new IdentityHashMap(...))&lt;/code&gt;方法来实现。&lt;/li&gt;
&lt;li&gt;支持fail-fast机制&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;weakhashmap-类&quot;&gt;WeakHashMap 类&lt;/h4&gt;
&lt;p&gt;WeakHashMap 类基于哈希表的 Map 基础实现，带有弱键。WeakHashMap 中的 entry 当不再使用时还会自动移除。更准确的说，给定key的映射的存在将不会阻止 key 被垃圾收集器丢弃。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基于 map 接口，是一种弱键相连，WeakHashMap 里面的键会自动回收&lt;/li&gt;
&lt;li&gt;支持 null 值和 null 键。&lt;/li&gt;
&lt;li&gt;fast-fail 机制&lt;/li&gt;
&lt;li&gt;不允许重复&lt;/li&gt;
&lt;li&gt;WeakHashMap 经常用作缓存&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;collections-类&quot;&gt;Collections 类&lt;/h3&gt;
&lt;p&gt;Collections 不属于 Java 框架继承树上的内容，它属于单独的分支，Collections 是一个包装类，它的作用就是为集合框架提供某些功能实现，此类只包括静态方法操作或者返回 collections。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步包装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步包装器将自动同步（线程安全性）添加到任意集合。 六个核心集合接口（Collection，Set，List，Map，SortedSet 和 SortedMap）中的每一个都有一个静态工厂方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static  Collection synchronizedCollection(Collection c);
public static  Set synchronizedSet(Set s);
public static  List synchronizedList(List list);
public static &amp;lt;K,V&amp;gt; Map&amp;lt;K,V&amp;gt; synchronizedMap(Map&amp;lt;K,V&amp;gt; m);
public static  SortedSet synchronizedSortedSet(SortedSet s);
public static &amp;lt;K,V&amp;gt; SortedMap&amp;lt;K,V&amp;gt; synchronizedSortedMap(SortedMap&amp;lt;K,V&amp;gt; m);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;不可修改的包装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不可修改的包装器通过拦截修改集合的操作并抛出 &lt;code&gt;UnsupportedOperationException&lt;/code&gt;，主要用在下面两个情景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构建集合后使其不可变。在这种情况下，最好不要去获取返回 collection 的引用，这样有利于保证不变性&lt;/li&gt;
&lt;li&gt;允许某些客户端以只读方式访问你的数据结构。 你保留对返回的 collection 的引用，但分发对包装器的引用。 通过这种方式，客户可以查看但不能修改，同时保持完全访问权限。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些方法是：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static  Collection unmodifiableCollection(Collection&amp;lt;? extends T&amp;gt; c);
public static  Set unmodifiableSet(Set&amp;lt;? extends T&amp;gt; s);
public static  List unmodifiableList(List&amp;lt;? extends T&amp;gt; list);
public static &amp;lt;K,V&amp;gt; Map&amp;lt;K, V&amp;gt; unmodifiableMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m);
public static  SortedSet unmodifiableSortedSet(SortedSet&amp;lt;? extends T&amp;gt; s);
public static &amp;lt;K,V&amp;gt; SortedMap&amp;lt;K, V&amp;gt; unmodifiableSortedMap(SortedMap&amp;lt;K, ? extends V&amp;gt; m);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;线程安全的Collections&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java1.5 并发包 &lt;code&gt;(java.util.concurrent)&lt;/code&gt; 提供了线程安全的 collections 允许遍历的时候进行修改，通过设计iterator 为 fail-fast 并抛出 ConcurrentModificationException。一些实现类是&lt;code&gt;CopyOnWriteArrayList&lt;/code&gt;，&lt;code&gt;ConcurrentHashMap&lt;/code&gt;，&lt;code&gt;CopyOnWriteArraySet&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Collections 算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此类包含用于集合框架算法的方法，例如二进制搜索，排序，重排，反向等。&lt;/p&gt;
&lt;h3 id=&quot;集合实现类特征图&quot;&gt;集合实现类特征图&lt;/h3&gt;
&lt;p&gt;下图汇总了部分集合框架的主要实现类的特征图，让你能有清晰明了看出每个实现类之间的差异性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0ENj.png&quot; alt=&quot;YK0ENj.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有一种类型是关于强引用、弱引用、虚引用的文章，请参考&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/ZflBpn2TBzTNv_-G-zZxNg&quot;&gt;https://mp.weixin.qq.com/s/ZflBpn2TBzTNv_-G-zZxNg&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;泛形&quot;&gt;泛形&lt;/h2&gt;
&lt;p&gt;在 Jdk1.5 中，提出了一种新的概念，那就是泛型，那么什么是泛型呢？&lt;/p&gt;
&lt;p&gt;泛型其实就是一种参数化的集合，它限制了你添加进集合的类型。泛型的本质就是一种参数化类型。多态也可以看作是泛型的机制。一个类继承了父类，那么就能通过它的父类找到对应的子类，但是不能通过其他类来找到具体要找的这个类。泛型的设计之处就是希望对象或方法具有最广泛的表达能力。&lt;/p&gt;
&lt;p&gt;下面来看一个例子说明没有泛型的用法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List arrayList = new ArrayList();
arrayList.add(&quot;cxuan&quot;);
arrayList.add(100);

for(int i = 0; i&amp;lt; arrayList.size();i++){
    String item = (String)arrayList.get(i);
                System.out.println(&quot;test === &quot;, item);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段程序不能正常运行，原因是 Integer 类型不能直接强制转换为 String 类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们用泛型进行改写后，示例代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;String&amp;gt;();

arrayList.add(100);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码在编译期间就会报错，编译器会在编译阶段就能够帮我们发现类似这样的问题。&lt;/p&gt;
&lt;h3 id=&quot;泛型的使用&quot;&gt;泛型的使用&lt;/h3&gt;
&lt;p&gt;泛型的使用有多种方式，下面我们就来一起探讨一下。&lt;/p&gt;
&lt;h4 id=&quot;用泛型表示类&quot;&gt;用泛型表示类&lt;/h4&gt;
&lt;p&gt;泛型可以加到类上面，来表示这个类的类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//此处 T 可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
public class GenericDemo&amp;lt;T&amp;gt;{ 
    //value 这个成员变量的类型为T,T的类型由外部指定  
    private T value;

    public GenericDemo(T value) {
        this.value = value;
    }

    public T getValue(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return value;
    }
 
                public void setValue(T value){
              this.value = value
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;用泛型表示接口&quot;&gt;用泛型表示接口&lt;/h4&gt;
&lt;p&gt;泛型接口与泛型类的定义及使用基本相同。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//定义一个泛型接口
public interface Generator&amp;lt;T&amp;gt; {
    public T next();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般泛型接口常用于 &lt;code&gt;生成器(generator)&lt;/code&gt; 中，生成器相当于对象工厂，是一种专门用来创建对象的类。&lt;/p&gt;
&lt;h4 id=&quot;泛型方法&quot;&gt;泛型方法&lt;/h4&gt;
&lt;p&gt;可以使用泛型来表示方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class GenericMethods {
  public &amp;lt;T&amp;gt; void f(T x){
    System.out.println(x.getClass().getName());
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;泛型通配符&quot;&gt;泛型通配符&lt;/h4&gt;
&lt;p&gt;List 是泛型类，为了 表示各种泛型 List 的父类，可以使用类型通配符，类型通配符使用&lt;code&gt;问号(?)&lt;/code&gt;表示，它的元素类型可以匹配任何类型。例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
    List&amp;lt;String&amp;gt; name = new ArrayList&amp;lt;String&amp;gt;();
    List&amp;lt;Integer&amp;gt; age = new ArrayList&amp;lt;Integer&amp;gt;();
    List&amp;lt;Number&amp;gt; number = new ArrayList&amp;lt;Number&amp;gt;();
    name.add(&quot;cxuan&quot;);
    age.add(18);
    number.add(314);
    generic(name);
    generic(age);
    generic(number);   
}

public static void generic(List&amp;lt;?&amp;gt; data) {
    System.out.println(&quot;Test cxuan :&quot; + data.get(0));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;下界通配符&lt;/strong&gt; : &amp;lt;? extends ClassType&amp;gt; 该通配符为 ClassType 的所有子类型。它表示的是任何类型都是 ClassType 类型的子类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上界通配符&lt;/strong&gt;： &amp;lt;? super ClassType&amp;gt; 该通配符为 ClassType 的所有超类型。它表示的是任何类型的父类都是 ClassType。&lt;/p&gt;
&lt;h2 id=&quot;反射&quot;&gt;反射&lt;/h2&gt;
&lt;p&gt;反射是 Java 中一个非常重要同时也是一个高级特性，基本上 Spring 等一系列框架都是基于反射的思想写成的。我们首先来认识一下什么反射。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java 反射机制是在程序的运行过程中，对于任何一个类，都能够知道它的所有属性和方法；对于任意一个对象，都能够知道调用它的任意属性和方法，这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。&lt;/strong&gt;（来源于百度百科）&lt;/p&gt;
&lt;p&gt;Java 反射机制主要提供了以下这几个功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在运行时判断任意一个对象所属的类&lt;/li&gt;
&lt;li&gt;在运行时构造任意一个类的对象&lt;/li&gt;
&lt;li&gt;在运行时判断任意一个类所有的成员变量和方法&lt;/li&gt;
&lt;li&gt;在运行时调用任意一个对象的方法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这么一看，反射就像是一个掌控全局的角色，不管你程序怎么运行，我都能够知道你这个类有哪些属性和方法，你这个对象是由谁调用的，嗯，很屌。&lt;/p&gt;
&lt;p&gt;在 Java 中，使用 &lt;code&gt;Java.lang.reflect&lt;/code&gt;包实现了反射机制。Java.lang.reflect 所设计的类如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0V4s.png&quot; alt=&quot;YK0V4s.png&quot;/&gt;&lt;p&gt;下面是一个简单的反射类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Person {
    public String name;// 姓名
    public int age;// 年龄
 
    public Person() {
        super();
    }
 
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
 
    public String showInfo() {
        return &quot;name=&quot; + name + &quot;, age=&quot; + age;
    }
}

public class Student extends Person implements Study {
    public String className;// 班级
    private String address;// 住址
 
    public Student() {
        super();
    }
 
    public Student(String name, int age, String className, String address) {
        super(name, age);
        this.className = className;
        this.address = address;
    }
 
    public Student(String className) {
        this.className = className;
    }
 
    public String toString() {
        return &quot;姓名：&quot; + name + &quot;,年龄：&quot; + age + &quot;,班级：&quot; + className + &quot;,住址：&quot;
                + address;
    }
 
    public String getAddress() {
        return address;
    }
 
    public void setAddress(String address) {
        this.address = address;
    }
}

public class TestRelect {
 
    public static void main(String[] args) {
        Class student = null;
        try {
            student = Class.forName(&quot;com.cxuan.reflection.Student&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
 
        // 获取对象的所有公有属性。
        Field[] fields = student.getFields();
        for (Field f : fields) {
            System.out.println(f);
        }
        System.out.println(&quot;---------------------&quot;);
        // 获取对象所有属性，但不包含继承的。
        Field[] declaredFields = student.getDeclaredFields();
        for (Field df : declaredFields) {
            System.out.println(df);
        }
      
        // 获取对象的所有公共方法
        Method[] methods = student.getMethods();
        for (Method m : methods) {
            System.out.println(m);
        }
        System.out.println(&quot;---------------------&quot;);
        // 获取对象所有方法，但不包含继承的
        Method[] declaredMethods = student.getDeclaredMethods();
        for (Method dm : declaredMethods) {
            System.out.println(dm);
        }
                                
        // 获取对象所有的公共构造方法
        Constructor[] constructors = student.getConstructors();
        for (Constructor c : constructors) {
            System.out.println(c);
        }
        System.out.println(&quot;---------------------&quot;);
        // 获取对象所有的构造方法
        Constructor[] declaredConstructors = student.getDeclaredConstructors();
        for (Constructor dc : declaredConstructors) {
            System.out.println(dc);
        }
      
        Class c = Class.forName(&quot;com.cxuan.reflection.Student&quot;);
        Student stu1 = (Student) c.newInstance();
        // 第一种方法，实例化默认构造方法，调用set赋值
        stu1.setAddress(&quot;河北石家庄&quot;);
        System.out.println(stu1);

        // 第二种方法 取得全部的构造函数 使用构造函数赋值
        Constructor&amp;lt;Student&amp;gt; constructor = c.getConstructor(String.class, 
                                                            int.class, String.class, String.class);
        Student student2 = (Student) constructor.newInstance(&quot;cxuan&quot;, 24, &quot;六班&quot;, &quot;石家庄&quot;);
        System.out.println(student2);

        /**
        * 獲取方法并执行方法
        */
        Method show = c.getMethod(&quot;showInfo&quot;);//获取showInfo()方法
        Object object = show.invoke(stu2);//调用showInfo()方法
        
 
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有一些是比较常用的，有一些是我至今都没见过怎么用的，下面进行一个归类。&lt;/p&gt;
&lt;p&gt;与 Java 反射有关的类主要有&lt;/p&gt;
&lt;h3 id=&quot;class-类&quot;&gt;Class 类&lt;/h3&gt;
&lt;p&gt;在 Java 中，你每定义一个 java class 实体都会产生一个 Class 对象。也就是说，当我们编写一个类，编译完成后，在生成的 &lt;code&gt;.class&lt;/code&gt; 文件中，就会产生一个 Class 对象，这个 Class 对象用于表示这个类的类型信息。Class 中没有公共的构造器，也就是说 Class 对象不能被实例化。下面来简单看一下 Class 类都包括了哪些方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;toString()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public String toString() {
  return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
    + getName();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;toString() 方法能够将对象转换为字符串，toString() 首先会判断 Class 类型是否是接口类型，也就是说，普通类和接口都能够用 Class 对象来表示，然后再判断是否是基本数据类型，这里判断的都是基本数据类型和包装类，还有 &lt;code&gt;void&lt;/code&gt; 类型。&lt;/p&gt;
&lt;p&gt;所有的类型如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;java.lang.Boolean : 代表 boolean 数据类型的包装类&lt;/li&gt;
&lt;li&gt;java.lang.Character: 代表 char 数据类型的包装类&lt;/li&gt;
&lt;li&gt;java.lang.Byte: 代表 byte 数据类型的包装类&lt;/li&gt;
&lt;li&gt;java.lang.Short: 代表 short 数据类型的包装类&lt;/li&gt;
&lt;li&gt;java.lang.Integer: 代表 int 数据类型的包装类&lt;/li&gt;
&lt;li&gt;java.lang.Long: 代表 long 数据类型的包装类&lt;/li&gt;
&lt;li&gt;java.lang.Float: 代表 float 数据类型的包装类&lt;/li&gt;
&lt;li&gt;java.lang.Double: 代表 double 数据类型的包装类&lt;/li&gt;
&lt;li&gt;java.lang.Void: 代表 void 数据类型的包装类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后是 &lt;code&gt;getName()&lt;/code&gt; 方法，这个方法返回类的全限定名称。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果是引用类型，比如 String.class.getName() -&amp;gt; &lt;code&gt;java.lang.String&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果是基本数据类型，byte.class.getName() -&amp;gt; &lt;code&gt;byte&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果是数组类型，new Object[3]).getClass().getName() -&amp;gt; &lt;code&gt;[Ljava.lang.Object&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;toGenericString()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个方法会返回类的全限定名称，而且包括类的修饰符和类型参数信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;forName()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据类名获得一个 Class 对象的引用，这个方法会使类对象进行初始化。&lt;/p&gt;
&lt;p&gt;例如 &lt;code&gt;Class t = Class.forName(&quot;java.lang.Thread&quot;)&lt;/code&gt; 就能够初始化一个 Thread 线程对象&lt;/p&gt;
&lt;p&gt;在 Java 中，一共有三种获取类实例的方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Class.forName(java.lang.Thread)&lt;/li&gt;
&lt;li&gt;Thread.class&lt;/li&gt;
&lt;li&gt;thread.getClass()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;newInstance()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建一个类的实例，代表着这个类的对象。上面 forName() 方法对类进行初始化，newInstance 方法对类进行实例化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getClassLoader()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获取类加载器对象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getTypeParameters()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照声明的顺序获取对象的参数类型信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getPackage()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回类的包&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getInterfaces()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得当前类实现的类或是接口，可能是有多个，所以返回的是 Class 数组。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cast&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把对象转换成代表类或是接口的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;asSubclass(Class clazz)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;把传递的类的对象转换成代表其子类的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getClasses()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回一个数组，数组中包含该类中所有公共类和接口类的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getDeclaredClasses()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回一个数组，数组中包含该类中所有类和接口类的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getSimpleName()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得类的名字&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getFields()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得所有公有的属性对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getField(String name)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得某个公有的属性对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getDeclaredField(String name)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得某个属性对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getDeclaredFields()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得所有属性对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getAnnotation(Class annotationClass)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回该类中与参数类型匹配的公有注解对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getAnnotations()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回该类所有的公有注解对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getDeclaredAnnotation(Class annotationClass)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回该类中与参数类型匹配的所有注解对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getDeclaredAnnotations()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回该类所有的注解对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getConstructor(Class...&amp;lt;?&amp;gt; parameterTypes)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得该类中与参数类型匹配的公有构造方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getConstructors()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得该类的所有公有构造方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getDeclaredConstructor(Class...&amp;lt;?&amp;gt; parameterTypes)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得该类中与参数类型匹配的构造方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getDeclaredConstructors()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得该类所有构造方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getMethod(String name, Class...&amp;lt;?&amp;gt; parameterTypes)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得该类某个公有的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getMethods()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得该类所有公有的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getDeclaredMethod(String name, Class...&amp;lt;?&amp;gt; parameterTypes)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得该类某个方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getDeclaredMethods()&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得该类所有方法&lt;/p&gt;
&lt;h3 id=&quot;field-类&quot;&gt;Field 类&lt;/h3&gt;
&lt;p&gt;Field 类提供类或接口中单独字段的信息，以及对单独字段的动态访问。&lt;/p&gt;
&lt;p&gt;这里就不再对具体的方法进行介绍了，读者有兴趣可以参考官方 API&lt;/p&gt;
&lt;p&gt;这里只介绍几个常用的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;equals(Object obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;属性与obj相等则返回true&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;get(Object obj)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;获得obj中对应的属性值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set(Object obj, Object value)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设置obj中对应属性值&lt;/p&gt;
&lt;h3 id=&quot;method-类&quot;&gt;Method 类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;invoke(Object obj, Object... args)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;传递object对象及参数调用该对象对应的方法&lt;/p&gt;
&lt;h3 id=&quot;classloader-类&quot;&gt;ClassLoader 类&lt;/h3&gt;
&lt;p&gt;反射中，还有一个非常重要的类就是 ClassLoader 类，类装载器是用来把&lt;code&gt;类(class)&lt;/code&gt; 装载进 &lt;code&gt;JVM&lt;/code&gt; 的。ClassLoader 使用的是双亲委托模型来搜索加载类的，这个模型也就是双亲委派模型。ClassLoader 的类继承图如下&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0eCn.png&quot; alt=&quot;YK0eCn.png&quot;/&gt;&lt;h2 id=&quot;枚举&quot;&gt;枚举&lt;/h2&gt;
&lt;p&gt;枚举可能是我们使用次数比较少的特性，在 Java 中，枚举使用 &lt;code&gt;enum&lt;/code&gt; 关键字来表示，枚举其实是一项非常有用的特性，你可以把它理解为具有特定性质的类。enum 不仅仅 Java 有，C 和 C++ 也有枚举的概念。下面是一个枚举的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum Family {

    FATHER,
    MOTHER,
    SON,
    Daughter;

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面我们创建了一个 &lt;code&gt;Family&lt;/code&gt;的枚举类，它具有 4 个值，由于枚举类型都是常量，所以都用大写字母来表示。那么 enum 创建出来了，该如何引用呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class EnumUse {

    public static void main(String[] args) {
        Family s = Family.FATHER;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;枚举特性&quot;&gt;枚举特性&lt;/h3&gt;
&lt;p&gt;enum 枚举这个类比较有意思，当你创建完 enum 后，编译器会自动为你的 enum 添加 &lt;code&gt;toString()&lt;/code&gt; 方法，能够让你方便的显示 enum 实例的具体名字是什么。除了 toString() 方法外，编译器还会添加 &lt;code&gt;ordinal()&lt;/code&gt; 方法，这个方法用来表示 enum 常量的声明顺序，以及 &lt;code&gt;values()&lt;/code&gt; 方法显示顺序的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {

  for(Family family : Family.values()){
    System.out.println(family + &quot;, ordinal&quot; + family.ordinal());
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;enum 可以进行静态导入包，静态导入包可以做到不用输入 &lt;code&gt;枚举类名.常量&lt;/code&gt;，可以直接使用常量，神奇吗? 使用 ennum 和 &lt;code&gt;static&lt;/code&gt; 关键字可以做到静态导入包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0m3q.png&quot; alt=&quot;YK0m3q.png&quot;/&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0ng0.png&quot; alt=&quot;YK0ng0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面代码导入的是 Family 中所有的常量，也可以单独指定常量。&lt;/p&gt;
&lt;h3 id=&quot;枚举和普通类一样&quot;&gt;枚举和普通类一样&lt;/h3&gt;
&lt;p&gt;枚举就和普通类一样，除了枚举中能够方便快捷的定义&lt;code&gt;常量&lt;/code&gt;，我们日常开发使用的 &lt;code&gt;public static final xxx&lt;/code&gt; 其实都可以用枚举来定义。在枚举中也能够定义属性和方法，千万不要把它看作是异类，它和万千的类一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum OrdinalEnum {

    WEST(&quot;live in west&quot;),
    EAST(&quot;live in east&quot;),
    SOUTH(&quot;live in south&quot;),
    NORTH(&quot;live in north&quot;);

    String description;

    OrdinalEnum(String description){
        this.description = description;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public static void main(String[] args) {
        for(OrdinalEnum ordinalEnum : OrdinalEnum.values()){
            System.out.println(ordinalEnum.getDescription());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般 switch 可以和 enum 一起连用，来构造一个小型的状态转换机。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;enum Signal {
  GREEN, YELLOW, RED
}

public class TrafficLight {
    Signal color = Signal.RED;

    public void change() {
        switch (color) {
        case RED:
            color = Signal.GREEN;
            break;
        case YELLOW:
            color = Signal.RED;
            break;
        case GREEN:
            color = Signal.YELLOW;
            break;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是代码顿时觉得优雅整洁了些许呢？&lt;/p&gt;
&lt;h3 id=&quot;枚举神秘之处&quot;&gt;枚举神秘之处&lt;/h3&gt;
&lt;p&gt;在 Java 中，万事万物都是对象，enum 虽然是个关键字，但是它却隐式的继承于 &lt;code&gt;Enum&lt;/code&gt; 类。我们来看一下 Enum 类，此类位于 &lt;code&gt;java.lang&lt;/code&gt; 包下，可以自动引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0ng0.png&quot; alt=&quot;YK0ng0.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此类的属性和方法都比较少。你会发现这个类中没有我们的 values 方法。前面刚说到，&lt;code&gt;values()&lt;/code&gt; 方法是你使用枚举时被编译器添加进来的 static 方法。&lt;strong&gt;可以使用反射来验证一下&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除此之外，enum 还和 Class 类有交集，在 Class 类中有三个关于 Enum 的方法&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0uvV.png&quot; alt=&quot;YK0uvV.png&quot;/&gt;&lt;p&gt;前面两个方法用于获取 enum 常量，&lt;code&gt;isEnum&lt;/code&gt; 用于判断是否是枚举类型的。&lt;/p&gt;
&lt;h3 id=&quot;枚举类&quot;&gt;枚举类&lt;/h3&gt;
&lt;p&gt;除了 Enum 外，还需要知道两个关于枚举的工具类，一个是 &lt;code&gt;EnumSet&lt;/code&gt; ，一个是 &lt;code&gt;EnumMap&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EnumSet 和 EnumMap&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;EnumSet 是 JDK1.5 引入的，EnumSet 的设计充分考虑到了速度因素，使用 EnumSet 可以作为 Enum 的替代者，因为它的效率比较高。&lt;/p&gt;
&lt;p&gt;EnumMap 是一种特殊的 Map，它要求其中的 key 键值是来自一个 enum。因为 EnumMap 速度也很快，我们可以使用 EnumMap 作为 key 的快速查找。&lt;/p&gt;
&lt;p&gt;总的来说，枚举的使用不是很复杂，它也是 Java 中很小的一块功能，但有时却能够因为这一个小技巧，能够让你的代码变得优雅和整洁。&lt;/p&gt;
&lt;h2 id=&quot;io&quot;&gt;I/O&lt;/h2&gt;
&lt;p&gt;创建一个良好的 I/O 程序是非常复杂的。JDK 开发人员编写了大量的类只为了能够创建一个良好的工具包，想必编写 I/O 工具包很费劲吧。&lt;/p&gt;
&lt;p&gt;IO 类设计出来，肯定是为了解决 IO 相关操作的，最常见的 I/O 读写就是网络、磁盘等。在 Java 中，对文件的操作是一个典型的 I/O 操作。下面我们就对 I/O 进行一个分类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0MuT.png&quot; alt=&quot;YK0MuT.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;公号回复 &lt;code&gt;IO&lt;/code&gt;获取思维导图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I/O 还可以根据操作对象来进行区分：主要分为&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0QDU.png&quot; alt=&quot;YK0QDU.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，I/O 中还有其他比较重要的类&lt;/p&gt;
&lt;h3 id=&quot;file-类&quot;&gt;File 类&lt;/h3&gt;
&lt;p&gt;File 类是对文件系统中文件以及文件夹进行操作的类，可以通过面向对象的思想操作文件和文件夹，是不是很神奇？&lt;/p&gt;
&lt;p&gt;文件创建操作如下，主要涉及 &lt;strong&gt;文件创建、删除文件、获取文件描述符等&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class FileDemo{
   public static void main(String[] args) {
       File file = new File(&quot;D:\\file.txt&quot;);
       try{
         f.createNewFile(); // 创建一个文件
         
         // File类的两个常量
         //路径分隔符(与系统有关的）&amp;lt;windows里面是 ; linux里面是 ： &amp;gt;
        System.out.println(File.pathSeparator);  //   ;
        //与系统有关的路径名称分隔符&amp;lt;windows里面是 \ linux里面是/ &amp;gt;
        System.out.println(File.separator);      //  \
         
         // 删除文件
         /*
         File file = new File(fileName);
         if(f.exists()){
             f.delete();
         }else{
             System.out.println(&quot;文件不存在&quot;);
         }   
         */

         
       }catch (Exception e) {
           e.printStackTrace();
       }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以对文件夹进行操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;class FileDemo{
  public static void main(String[] args) {
    String fileName = &quot;D:&quot;+ File.separator + &quot;filepackage&quot;;
    File file = new File(fileName);
    f.mkdir();
    
                // 列出所有文件
    /*
    String[] str = file.list();
    for (int i = 0; i &amp;lt; str.length; i++) {
      System.out.println(str[i]);
    }
    */
    
    // 使用 file.listFiles(); 列出所有文件，包括隐藏文件
    
    // 使用 file.isDirectory() 判断指定路径是否是目录
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面只是举出来了两个简单的示例，实际上，还有一些其他对文件的操作没有使用。比如创建文件，就可以使用三种方式来创建&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;File(String directoryPath);
File(String directoryPath, String filename);
File(File dirObj, String filename);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;directoryPath 是文件的路径名，filename 是文件名，dirObj 是一个 File 对象。例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;File file = new File(&quot;D:\\java\\file1.txt&quot;);  //双\\是转义
System.out.println(file);
File file2 = new File(&quot;D:\\java&quot;,&quot;file2.txt&quot;);//父路径、子路径--可以适用于多个文件的！
System.out.println(file2);
File parent = new File(&quot;D:\\java&quot;);
File file3 = new File(parent,&quot;file3.txt&quot;);//File类的父路径、子路径
System.out.println(file3);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在对 File 类进行总结&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0lbF.png&quot; alt=&quot;YK0lbF.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;基础-io-类和相关方法&quot;&gt;基础 IO 类和相关方法&lt;/h3&gt;
&lt;p&gt;虽然. IO 类有很多，但是最基本的是四个抽象类，&lt;strong&gt;InputStream、OutputStream、Reader、Writer&lt;/strong&gt;。最基本的方法也就是 &lt;code&gt;read()&lt;/code&gt; 和 &lt;code&gt;write()&lt;/code&gt; 方法，其他流都是上面这四类流的子类，方法也是通过这两类方法衍生而成的。而且大部分的 IO 源码都是 &lt;code&gt;native&lt;/code&gt; 标志的，也就是说源码都是 C/C++ 写的。这里我们先来认识一下这些流类及其方法&lt;/p&gt;
&lt;h4 id=&quot;inputstream&quot;&gt;InputStream&lt;/h4&gt;
&lt;p&gt;InputStream 是一个定义了 Java 流式字节输入模式的抽象类。该类的所有方法在出错条件下引发一个IOException 异常。它的主要方法定义如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK03E4.png&quot; alt=&quot;YK03E4.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;outputstream&quot;&gt;OutputStream&lt;/h4&gt;
&lt;p&gt;OutputStream 是定义了流式字节输出模式的抽象类。该类的所有方法返回一个void 值并且在出错情况下引发一个IOException异常。它的主要方法定义如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK08UJ.png&quot; alt=&quot;YK08UJ.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;reader-类&quot;&gt;Reader 类&lt;/h4&gt;
&lt;p&gt;Reader 是 Java 定义的流式字符输入模式的抽象类。类中的方法在出错时引发 &lt;code&gt;IOException&lt;/code&gt; 异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0YCR.png&quot; alt=&quot;YK0YCR.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;writer-类&quot;&gt;Writer 类&lt;/h4&gt;
&lt;p&gt;Writer 是定义流式字符输出的抽象类。 所有该类的方法都返回一个 void 值并在出错条件下引发 IOException 异常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0t81.png&quot; alt=&quot;YK0t81.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;inputstream-及其子类&quot;&gt;InputStream 及其子类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FileInputStream 文件输入流&lt;/strong&gt;： FileInputStream 类创建一个能从文件读取字节的 InputStream 类&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ByteArrayInputStream 字节数组输入流&lt;/strong&gt; ： 把内存中的一个缓冲区作为 InputStream 使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PipedInputStream 管道输入流&lt;/strong&gt;： 实现了pipe 管道的概念，主要在线程中使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SequenceInputStream 顺序输入流&lt;/strong&gt;：把多个 InputStream 合并为一个 InputStream&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FilterOutputStream 过滤输入流&lt;/strong&gt;：其他输入流的包装。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ObjectInputStream 反序列化输入流&lt;/strong&gt; ： 将之前使用 ObjectOutputStream 序列化的原始数据恢复为对象，以流的方式读取对象&lt;/p&gt;
&lt;p&gt;**DataInputStream ** : 数据输入流允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PushbackInputStream 推回输入流&lt;/strong&gt;： 缓冲的一个新颖的用法是实现&lt;code&gt;推回 （pushback）&lt;/code&gt; 。 Pushback 用于输入流允许字节被读取然后返回到流。&lt;/p&gt;
&lt;h3 id=&quot;outputstream-及其子类&quot;&gt;OutputStream 及其子类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FileOutputStream 文件输出流&lt;/strong&gt;： 该类实现了一个输出流，其数据写入文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ByteArrayOutputStream 字节数组输出流&lt;/strong&gt; ：该类实现了一个输出流，其数据被写入由 byte 数组充当的缓冲区，缓冲区会随着数据的不断写入而自动增长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PipedOutputStream 管道输出流&lt;/strong&gt; ：管道的输出流，是管道的发送端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ObjectOutputStream 基本类型输出流&lt;/strong&gt; ：该类将实现了序列化的对象序列化后写入指定地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FilterOutputStream 过滤输出流&lt;/strong&gt;：其他输出流的包装。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PrintStream 打印流&lt;/strong&gt; 通过 PrintStream 可以将文字打印到文件或者网络中去。&lt;/p&gt;
&lt;p&gt;**DataOutputStream ** : 数据输出流允许应用程序以与机器无关方式向底层输出流中写入基本 Java 数据类型。&lt;/p&gt;
&lt;h3 id=&quot;reader-及其子类&quot;&gt;Reader 及其子类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FileReader 文件字符输入流&lt;/strong&gt; ： 把文件转换为字符流读入&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CharArrayReader 字符数组输入流&lt;/strong&gt; ： 是一个把字符数组作为源的输入流的实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BufferedReader 缓冲区输入流&lt;/strong&gt; ： BufferedReader 类从字符输入流中读取文本并缓冲字符，以便有效地读取字符，数组和行&lt;/p&gt;
&lt;p&gt;**PushbackReader **: PushbackReader 类允许一个或多个字符被送回输入流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PipedReader 管道输入流&lt;/strong&gt;： 主要用途也是在线程间通讯，不过这个可以用来传输字符&lt;/p&gt;
&lt;h3 id=&quot;writer-及其子类&quot;&gt;Writer 及其子类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;FileWriter 字符输出流&lt;/strong&gt; ： FileWriter 创建一个可以写文件的 Writer 类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CharArrayWriter 字符数组输出流&lt;/strong&gt;： CharArrayWriter 实现了以数组作为目标的输出流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BufferedWriter 缓冲区输出流&lt;/strong&gt; ： BufferedWriter是一个增加了&lt;code&gt;flush( )&lt;/code&gt; 方法的Writer。 flush( )方法可以用来确保数据缓冲器确实被写到实际的输出流。&lt;/p&gt;
&lt;p&gt;**PrintWriter ** ： PrintWriter 本质上是 PrintStream 的字符形式的版本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PipedWriter 管道输出流&lt;/strong&gt;： 主要用途也是在线程间通讯，不过这个可以用来传输字符&lt;/p&gt;
&lt;p&gt;Java 的输入输出的流式接口为复杂而繁重的任务提供了一个简洁的抽象。过滤流类的组合允许你动态建立客户端流式接口来配合数据传输要求。继承高级流类 InputStream、InputStreamReader、 Reader 和 Writer 类的 Java 程序在将来 （即使创建了新的和改进的具体类）也能得到合理运用。&lt;/p&gt;
&lt;h2 id=&quot;注解&quot;&gt;注解&lt;/h2&gt;
&lt;p&gt;Java &lt;code&gt;注解（Annotation）&lt;/code&gt; 又称为&lt;code&gt;元数据&lt;/code&gt; ，它为我们在代码中添加信息提供了一种形式化的方法。它是 JDK1.5 引入的，Java 定义了一套注解，共有 7 个，3 个在 &lt;code&gt;java.lang&lt;/code&gt; 中，剩下 4 个在 &lt;code&gt;java.lang.annotation&lt;/code&gt; 中。&lt;/p&gt;
&lt;p&gt;作用在代码中的注解有三个，它们分别是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Override&lt;/code&gt;： 重写标记，一般用在子类继承父类后，标注在重写过后的子类方法上。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Deprecated&lt;/code&gt; ：用此注解注释的代码已经过时，不再推荐使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@SuppressWarnings&lt;/code&gt;： 这个注解起到忽略编译器的警告作用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;元注解有四个，元注解就是用来标志注解的注解。它们分别是&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Retention&lt;/code&gt;: 标识如何存储，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RetentionPolicy.SOURCE：注解只保留在源文件，当 Java 文件编译成class文件的时候，注解被遗弃；&lt;/p&gt;
&lt;p&gt;RetentionPolicy.CLASS：注解被保留到 class 文件，但 jvm 加载 class 文件时候被遗弃，这是&lt;code&gt;默认的&lt;/code&gt;生命周期；&lt;/p&gt;
&lt;p&gt;RetentionPolicy.RUNTIME：注解不仅被保存到 class 文件中，jvm 加载 class 文件之后，仍然存在；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Documented&lt;/code&gt;: 标记这些注解是否包含在 JavaDoc 中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@Target&lt;/code&gt;： 标记这个注解说明了 Annotation 所修饰的对象范围，Annotation 可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。取值如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum ElementType {
    TYPE,
    FIELD,
    METHOD,
    PARAMETER,
    CONSTRUCTOR,
    LOCAL_VARIABLE,
    ANNOTATION_TYPE,
    PACKAGE,
    TYPE_PARAMETER,
    TYPE_USE
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;@Inherited&lt;/code&gt; ： 标记这个注解是继承于哪个注解类的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从 JDK1.7 开始，又添加了三个额外的注解，它们分别是&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;@SafeVarargs&lt;/code&gt; ：在声明可变参数的构造函数或方法时，Java 编译器会报 unchecked 警告。使用 @SafeVarargs 可以忽略这些警告&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;@FunctionalInterface&lt;/code&gt;: 表明这个方法是一个函数式接口&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;@Repeatable&lt;/code&gt;： 标识某注解可以在同一个声明上使用多次。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：注解是不支持继承的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于-null-的几种处理方式&quot;&gt;关于 null 的几种处理方式&lt;/h2&gt;
&lt;p&gt;对于 Java 程序员来说，空指针一直是恼人的问题，我们在开发中经常会受到 NullPointerException 的蹂躏和壁咚。Java 的发明者也承认这是一个巨大的设计错误。&lt;/p&gt;
&lt;p&gt;那么关于 null ，你应该知道下面这几件事情来有效的了解 null ，从而避免很多由 null 引起的错误。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0Ngx.png&quot; alt=&quot;YK0Ngx.png&quot;/&gt;&lt;h3 id=&quot;大小写敏感&quot;&gt;大小写敏感&lt;/h3&gt;
&lt;p&gt;首先，null 是 Java 中的&lt;code&gt;关键字&lt;/code&gt;，像是 &lt;strong&gt;public、static、final。&lt;/strong&gt;它是大小写敏感的，你不能将 null 写成 Null 或 NULL，编辑器将不能识别它们然后报错。&lt;/p&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0Uv6.png&quot; alt=&quot;YK0Uv6.png&quot;/&gt;&lt;p&gt;这个问题已经几乎不会出现，因为 eclipse 和 Idea 编译器已经给出了编译器提示，所以你不用考虑这个问题。&lt;/p&gt;
&lt;h3 id=&quot;null-是任何引用类型的初始值&quot;&gt;null 是任何引用类型的初始值&lt;/h3&gt;
&lt;p&gt;null 是所有引用类型的默认值，Java 中的任何引用变量都将null作为默认值，也就是说所有 Object 类下的引用类型默认值都是 null。这对所有的引用变量都适用。就像是基本类型的默认值一样，例如 int 的默认值是 0，boolean 的默认值是 false。&lt;/p&gt;
&lt;p&gt;下面是基本数据类型的初始值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0dKK.png&quot; alt=&quot;YK0dKK.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;null-只是一种特殊的值&quot;&gt;null 只是一种特殊的值&lt;/h3&gt;
&lt;p&gt;null 既不是对象也不是一种类型，它仅是一种特殊的值，你可以将它赋予任何类型，你可以将 null 转换为任何类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
  String str = null;
  Integer itr = null;
  Double dou = null;

  Integer integer = (Integer) null;
  String string = (String)null;

  System.out.println(&quot;integer = &quot; + integer);
  System.out.println(&quot;string = &quot; + string);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以看到在编译期和运行期内，将 null 转换成任何的引用类型都是可行的，并且不会抛出空指针异常。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;null 只能赋值给引用变量，不能赋值给基本类型变量&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;持有 null 的包装类在进行自动拆箱的时候，不能完成转换，会抛出空指针异常，并且 null 也不能和基本数据类型进行对比&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
  int i = 0;
  Integer itr = null;
  System.out.println(itr == i);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用了带有 null 值的引用类型变量，&lt;code&gt;instanceof&lt;/code&gt; 操作会返回 false&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
  Integer isNull = null;
  // instanceof = isInstance 方法
  if(isNull instanceof Integer){
    System.out.println(&quot;isNull is instanceof Integer&quot;);
  }else{
    System.out.println(&quot;isNull is not instanceof Integer&quot;);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是 instanceof 操作符一个很重要的特性，使得对类型强制转换检查很有用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态变量为 null 调用静态方法不会抛出 NullPointerException。因为静态方法使用了静态绑定&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;使用-null-safe-方法&quot;&gt;使用 Null-Safe 方法&lt;/h3&gt;
&lt;p&gt;你应该使用 null-safe 安全的方法，java 类库中有很多工具类都提供了静态方法，例如基本数据类型的包装类，Integer , Double 等。例如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class NullSafeMethod {

    private static String number;

    public static void main(String[] args) {
        String s = String.valueOf(number);
        String string = number.toString();
        System.out.println(&quot;s = &quot; + s);
        System.out.println(&quot;string = &quot; + string);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;number 没有赋值，所以默认为null，使用&lt;code&gt;String.value(number)&lt;/code&gt; 静态方法没有抛出空指针异常，但是使用 &lt;code&gt;toString()&lt;/code&gt; 却抛出了空指针异常。所以尽量使用对象的静态方法。&lt;/p&gt;
&lt;h3 id=&quot;null-判断&quot;&gt;null 判断&lt;/h3&gt;
&lt;p&gt;你可以使用 &lt;code&gt;==&lt;/code&gt; 或者 &lt;code&gt;!=&lt;/code&gt; 操作来比较 null 值，但是不能使用其他算法或者逻辑操作，例如小于或者大于。跟SQL不一样，在Java中 null == null 将返回 true，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CompareNull {

    private static String str1;
    private static String str2;

    public static void main(String[] args) {
        System.out.println(&quot;str1 == str2 ? &quot; + str1 == str2);
        System.out.println(null == null);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;关于思维导图&quot;&gt;关于思维导图&lt;/h2&gt;
&lt;p&gt;我把一些常用的 Java 工具包的思维导图做了汇总，方便读者查阅。&lt;/p&gt;
&lt;h3 id=&quot;javaio&quot;&gt;Java.IO&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0wDO.png&quot; alt=&quot;YK0wDO.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;javalang&quot;&gt;Java.lang&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK00bD.png&quot; alt=&quot;YK00bD.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;javamath&quot;&gt;Java.math&lt;/h3&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0DVe.png&quot; alt=&quot;YK0DVe.png&quot;/&gt;&lt;h3 id=&quot;javanet&quot;&gt;Java.net&lt;/h3&gt;
&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YK0rUH.png&quot; alt=&quot;YK0rUH.png&quot;/&gt;&lt;p&gt;思维导图持续更新中～～～ 欢迎关注公众号 &lt;code&gt;程序员cxuan&lt;/code&gt; 领取超全思维导图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1515111/202005/1515111-20200509064248032-50997312.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 May 2020 00:51:00 +0000</pubDate>
<dc:creator>程序员cxuan</dc:creator>
<og:description>先来看一下本篇文章的思维导图吧，我会围绕下面这些内容进行讲解。内容很干，小伙伴们看完还希望不吝转发。(高清思维导图版本关注作者公众号 回复 获取，其他思维导图获取方式在文末)。 下面开始我们的文章。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/12854535.html</dc:identifier>
</item>
<item>
<title>一篇博客带你轻松应对java面试中的多线程与高并发 - 经典鸡翅</title>
<link>http://www.cnblogs.com/jichi/p/12854685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jichi/p/12854685.html</guid>
<description>&lt;h2&gt;1. &lt;strong&gt;Java&lt;span&gt;线程的创建方式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;（1）&lt;span&gt;继承&lt;/span&gt;thread&lt;span&gt;类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;thread&lt;span&gt;类本质是实现了&lt;/span&gt;&lt;span&gt;runnable&lt;/span&gt;&lt;span&gt;接口的一个实例，代表线程的一个实例。启动线程的方式&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;是一个本地方法，执行后，执行&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;方法的代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509082917533-34864050.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;（2）&lt;span&gt;实现&lt;/span&gt;runnable&lt;span&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果自己的类已经继承了别的类，就不能继承&lt;/span&gt;thread&lt;span&gt;类。只能实现&lt;/span&gt;&lt;span&gt;runnable&lt;/span&gt;&lt;span&gt;接口。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509082925643-1967850328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;（3）&lt;span&gt;实现&lt;/span&gt;callable&lt;span&gt;接口&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有返回值的任务必须实现&lt;/span&gt;callable&lt;span&gt;接口，无返回值的任务必须实现&lt;/span&gt;&lt;span&gt;runnable&lt;/span&gt;&lt;span&gt;接口。执行&lt;/span&gt;&lt;span&gt;callable&lt;/span&gt;&lt;span&gt;接口后，可以获取一个&lt;/span&gt;&lt;span&gt;future&lt;/span&gt;&lt;span&gt;对象，通过&lt;/span&gt;&lt;span&gt;future&lt;/span&gt;&lt;span&gt;对象的&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;方法可以获得返回值。结合线程池可以实现有返回值的多线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509082930829-1535793258.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;（4）基于线程池的方式&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509082934806-649612112.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;2. &lt;strong&gt;&lt;span&gt;介绍一下&lt;/span&gt;java&lt;span&gt;的线程池&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;java&lt;span&gt;里面线程池的顶级接口是&lt;/span&gt;&lt;span&gt;executor&lt;/span&gt;&lt;span&gt;。严格意义上讲。&lt;/span&gt;&lt;span&gt;executor&lt;/span&gt;&lt;span&gt;只是一个接口，真正的线程池是&lt;/span&gt;&lt;span&gt;executorservice&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）&lt;/span&gt;newCachedThreadPool&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用&lt;/span&gt; execute &lt;span&gt;将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有&lt;/span&gt; &lt;span&gt;60&lt;/span&gt; &lt;span&gt;秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;2&lt;span&gt;）&lt;/span&gt;newFixedThreadPool&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数&lt;/span&gt; nThreads &lt;span&gt;线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;3&lt;span&gt;）&lt;/span&gt;&lt;span&gt;newScheduledThreadPool&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509082940757-407299562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;（&lt;/span&gt;4&lt;span&gt;）&lt;/span&gt;newSingleThreadExecutor&lt;/p&gt;
&lt;p&gt;Executors.newSingleThreadExecutor()&lt;span&gt;返回一个线程池（这个线程池只有一个线程）&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;这个线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;3. &lt;strong&gt;线程的声明周期&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;线程的生命周期包括新建&lt;/span&gt;new&lt;span&gt;，就绪&lt;/span&gt;&lt;span&gt;runable&lt;/span&gt;&lt;span&gt;，运行&lt;/span&gt;&lt;span&gt;running&lt;/span&gt;&lt;span&gt;，阻塞&lt;/span&gt;&lt;span&gt;blocked&lt;/span&gt;&lt;span&gt;和死亡&lt;/span&gt;&lt;span&gt;dead&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）新建状态&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当程序使用&lt;/span&gt;new&lt;span&gt;关键字创建了一个线程之后，该线程就属于新建状态，此时仅由&lt;/span&gt;&lt;span&gt;jvm&lt;/span&gt;&lt;span&gt;为其分配内存，并初始化成员变量的值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）就绪状态&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当线程对象调用了&lt;/span&gt;start&lt;span&gt;方法之后。线程处于就绪状态，&lt;/span&gt;&lt;span&gt;jvm&lt;/span&gt;&lt;span&gt;会为其创建方法调用栈和程序计数器。此时的现场等待&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;的调度。一旦拿到&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;就可以立即执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）运行状态&lt;/p&gt;
&lt;p&gt;&lt;span&gt;处于就绪状态的线程获得了&lt;/span&gt;cpu&lt;span&gt;的执行权，状态就更改为&lt;/span&gt;&lt;span&gt;running&lt;/span&gt;&lt;span&gt;。此时线程处于运行状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）阻塞状态&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阻塞状态是指线程因为某种原因，放弃了&lt;/span&gt;cpu&lt;span&gt;的使用权，暂时停止运行。恢复阻塞后进入就绪状态，获得&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;使用权之后，才进入执行状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;阻塞的情况分为三种：&lt;/p&gt;
&lt;p&gt;等待阻塞&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行中的线程执行&lt;/span&gt;wait&lt;span&gt;方法，&lt;/span&gt;&lt;span&gt;jvm&lt;/span&gt;&lt;span&gt;会把他放入等待队列中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同步阻塞&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行的线程获取对象的同步锁的时候，&lt;/span&gt;jvm&lt;span&gt;会把该线程放入锁池中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其他阻塞&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行中的线程执行线程的&lt;/span&gt;sleep&lt;span&gt;方法或&lt;/span&gt;&lt;span&gt;join&lt;/span&gt;&lt;span&gt;方法。或者发出&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;请求的时候，&lt;/span&gt;&lt;span&gt;jvm&lt;/span&gt;&lt;span&gt;把对象置为阻塞状态。当&lt;/span&gt;&lt;span&gt;sleep&lt;/span&gt;&lt;span&gt;超时，&lt;/span&gt;&lt;span&gt;join&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt;&lt;span&gt;io&lt;/span&gt;&lt;span&gt;完毕后，就可以拿到&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;的权，继续执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（5）死亡状态&lt;/p&gt;
&lt;p&gt;&lt;span&gt;正常结束，&lt;/span&gt;run&lt;span&gt;或&lt;/span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt;的方法结束。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;异常结束，出现报错&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用&lt;/span&gt;stop&lt;span&gt;，调用&lt;/span&gt;&lt;span&gt;stop&lt;/span&gt;&lt;span&gt;方法可能会产生思索。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;4. &lt;strong&gt;终止线程的四种方式&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;（1）正常执行结束&lt;/p&gt;
&lt;p&gt;（2）&lt;span&gt;使用同一标志，多个线程共用一个变量，变量使用&lt;/span&gt;volite&lt;span&gt;修饰，每次把他作为标志位来进行判断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）interrupt&lt;span&gt;结束线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当线程处于阻塞状态的时候，如果使用&lt;/span&gt;sleep&lt;span&gt;，同步锁的&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt;方法，&lt;/span&gt;&lt;span&gt;socket&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;receive&lt;/span&gt;&lt;span&gt;方法的时候，会使现场处于阻塞状态。当调用线程的&lt;/span&gt;&lt;span&gt;interrupt&lt;/span&gt;&lt;span&gt;方法的时候。会抛出&lt;/span&gt;&lt;span&gt;interruptexception&lt;/span&gt;&lt;span&gt;异常。阻塞中的那个方法抛出异常，通过代码捕获异常，然后结束执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程未处于阻塞状态的时候，可以使用&lt;/span&gt;isinterrupted&lt;span&gt;来进行判断，&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt;来调这个函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509082950016-86168053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;（4）stop&lt;span&gt;方法终止线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;stop&lt;span&gt;方法强制执行，会导致现场释放他所占有的所有锁、被保护的数据可能就会出现不一致性。可能会出现很多奇怪的应用程序错误。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;5. &lt;strong&gt;sleep&lt;span&gt;和&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt;方法的区别&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;对于&lt;/span&gt;sleep&lt;span&gt;方法，属于&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;类，&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt;方法数据&lt;/span&gt;&lt;span&gt;object&lt;/span&gt;&lt;span&gt;类中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;sleep&lt;span&gt;方法导致线程的短暂执行，让出&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;去执行其他线程。依然监控&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;，当时间到了，立马拿到&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;的执行权。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用&lt;/span&gt;sleep&lt;span&gt;方法的时候，线程不会释放锁。&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt;&lt;span&gt;方法会放弃对象锁，进入锁的等待池。此方法调用了&lt;/span&gt;&lt;span&gt;notify&lt;/span&gt;&lt;span&gt;之后，才能进入锁池，进行重新竞争。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6. &lt;strong&gt;start&lt;span&gt;与&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;方法的区别&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;start&lt;span&gt;方法来启动线程，真正实现了多线程运行。无需等待&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;方法结束。可以直接执行其他方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用&lt;/span&gt;start&lt;span&gt;方法使线程进入就绪状态，获得&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;即可运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;run&lt;span&gt;方法是线程的&lt;/span&gt;&lt;span&gt;run&lt;/span&gt;&lt;span&gt;方法执行体。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;7. &lt;strong&gt;Java&lt;span&gt;的后台进程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1. &lt;span&gt;定义：守护线程&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;也称&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;服务线程&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;，他是后台线程，它有一个特性，即为用户线程提供公&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;共服务，在没有用户线程可服务时会自动离开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;设置：通过&lt;/span&gt; &lt;span&gt;setDaemon(true)&lt;/span&gt;&lt;span&gt;来设置线程为&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;守护线程&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;；将一个用户线程设置为守护线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的方式是在&lt;/span&gt; &lt;span&gt;线程对象创建&lt;/span&gt; &lt;span&gt;之前&lt;/span&gt; &lt;span&gt;用线程对象的&lt;/span&gt; setDaemon &lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;在&lt;/span&gt; &lt;span&gt;Daemon&lt;/span&gt; &lt;span&gt;线程中产生的新线程也是&lt;/span&gt; &lt;span&gt;Daemon&lt;/span&gt; &lt;span&gt;的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;span&gt;线程则是&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;级别的，以&lt;/span&gt; &lt;span&gt;Tomcat&lt;/span&gt; &lt;span&gt;为例，如果你在&lt;/span&gt; &lt;span&gt;Web&lt;/span&gt; &lt;span&gt;应用中启动一个线程，这个线程的生命周期并不会和&lt;/span&gt; &lt;span&gt;Web&lt;/span&gt; &lt;span&gt;应用程序保持同步。也就是说，即使你停止了&lt;/span&gt; &lt;span&gt;Web&lt;/span&gt; &lt;span&gt;应用，这个线程依旧是活跃的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. example: &lt;span&gt;垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的&lt;/span&gt;&lt;span&gt;Thread,&lt;/span&gt;&lt;span&gt;程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7. &lt;span&gt;生命周期：守护进程（&lt;/span&gt;&lt;span&gt;Daemon&lt;/span&gt;&lt;span&gt;）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;同生共死&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;。当&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;中所有的线程都是守护线程的时候，&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;就可以退出了；如果还有一个或以上的非守护线程则&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;不会退出&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;8. &lt;strong&gt;Java&lt;span&gt;的锁&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），如果失败则要重复读&lt;/span&gt;-&lt;span&gt;比较&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;写的操作。&lt;/span&gt;&lt;span&gt;java&lt;/span&gt; &lt;span&gt;中的乐观锁基本都是通过&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;操作实现的，&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会&lt;/span&gt; block &lt;span&gt;直到拿到锁。&lt;/span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;中的悲观锁就是&lt;/span&gt;&lt;span&gt;Synchronized,AQS&lt;/span&gt;&lt;span&gt;框架下的锁则是先尝试&lt;/span&gt;&lt;span&gt;cas&lt;/span&gt;&lt;span&gt;乐观锁去获取锁，获取不到，才会转换为悲观锁，如&lt;/span&gt; &lt;span&gt;RetreenLock&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;自旋锁&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程自旋是需要消耗&lt;/span&gt; cup &lt;span&gt;的，说白了就是让&lt;/span&gt; &lt;span&gt;cup&lt;/span&gt; &lt;span&gt;在做无用功，如果一直获取不到锁，那线程也不能一直占用&lt;/span&gt; &lt;span&gt;cup&lt;/span&gt; &lt;span&gt;自旋做无用功，所以需要设定一个自旋等待的最大时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;自旋锁的优缺点&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用自旋锁了，因为自旋锁在获取锁前一直都是占用&lt;/span&gt; cpu &lt;span&gt;做无用功，占着&lt;/span&gt; &lt;span&gt;XX&lt;/span&gt; &lt;span&gt;不&lt;/span&gt; &lt;span&gt;XX&lt;/span&gt;&lt;span&gt;，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要&lt;/span&gt; &lt;span&gt;cup&lt;/span&gt; &lt;span&gt;的线程又不能获取到&lt;/span&gt; &lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;，造成&lt;/span&gt; &lt;span&gt;cpu&lt;/span&gt; &lt;span&gt;的浪费。所以这种情况下我们要关闭自旋锁；&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;自旋锁时间阈值&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;自旋锁的目的是为了占着&lt;/span&gt; CPU &lt;span&gt;的资源不释放，等到获取到锁立即进行处理。但是如何去选择自旋的执行时间呢？如果自旋执行时间太长，会有大量的线程处于自旋状态占用&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;资源，进而会影响整体系统的性能。因此自旋的周期选的额外重要！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JVM &lt;span&gt;对于自旋周期的选择，&lt;/span&gt;&lt;span&gt;jdk1.5&lt;/span&gt; &lt;span&gt;这个限度是一定的写死的，在&lt;/span&gt; &lt;span&gt;1.6&lt;/span&gt; &lt;span&gt;引入了适应性自旋锁，适应性自旋锁意味着自旋的时间不在是固定的了，而是由前一次在同一个锁上的自旋时间以及锁的拥有者的状态来决定，基本认为一个线程上下文切换的时间是最佳的一个时间，同时&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;还针对当前&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;的负荷情况做了较多的优化，如果平均负载小于&lt;/span&gt; &lt;span&gt;CPUs&lt;/span&gt; &lt;span&gt;则一直自旋，如果有超过&lt;/span&gt;&lt;span&gt;(CPUs/2)&lt;/span&gt;&lt;span&gt;个线程正在自旋，则后来线程直接阻塞，如果正在自旋的线程发现&lt;/span&gt; &lt;span&gt;Owner&lt;/span&gt; &lt;span&gt;发生了变化则延迟自旋时间（自旋计数）或进入阻塞，如果&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;处于节电模式则停止自旋，自旋时间的最坏情况是&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;的存储延迟（&lt;/span&gt;&lt;span&gt;CPU A&lt;/span&gt; &lt;span&gt;存储了一个数据，到&lt;/span&gt; &lt;span&gt;CPU B&lt;/span&gt; &lt;span&gt;得知这个数据直接的时间差），自旋时会适当放弃线程优先级之间的差异。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509083002086-2087426917.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;Synchronized &lt;span&gt;同步锁&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;synchronized &lt;span&gt;它可以把任意一个非&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;的对象当作锁。他属于独占式的悲观锁，同时属于可重入锁。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Synchronized &lt;span&gt;作用范围&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1. &lt;span&gt;作用于方法时，锁住的是对象的实例&lt;/span&gt;&lt;span&gt;(this)&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;当作用于静态方法时，锁住的是&lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;实例，又因为&lt;/span&gt;&lt;span&gt;Class&lt;/span&gt;&lt;span&gt;的相关数据存储在永久带&lt;/span&gt;&lt;span&gt;PermGen&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;jdk1.8&lt;/span&gt; &lt;span&gt;则是&lt;/span&gt; &lt;span&gt;metaspace&lt;/span&gt;&lt;span&gt;），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. synchronized &lt;span&gt;作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。它有多个队列，当多个线程一起访问某个对象监视器的时候，对象监视器会将这些线程存储在不同的容器中。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Synchronized &lt;span&gt;核心组件&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1) Wait Set&lt;span&gt;：哪些调用&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;方法被阻塞的线程被放置在这里；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2) Contention List&lt;span&gt;：竞争队列，所有请求锁的线程首先被放在这个竞争队列中；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3) Entry List&lt;span&gt;：&lt;/span&gt;&lt;span&gt;Contention List&lt;/span&gt; &lt;span&gt;中那些有资格成为候选资源的线程被移动到&lt;/span&gt; &lt;span&gt;Entry List&lt;/span&gt; &lt;span&gt;中；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4) OnDeck&lt;span&gt;：任意时刻，最多只有一个线程正在竞争锁资源，该线程被成为&lt;/span&gt; &lt;span&gt;OnDeck&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5) Owner&lt;span&gt;：当前已经获取到所资源的线程被称为&lt;/span&gt; &lt;span&gt;Owner&lt;/span&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6) !Owner&lt;span&gt;：当前释放锁的线程。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1. JVM &lt;span&gt;每次从队列的尾部取出一个数据用于锁竞争候选者（&lt;/span&gt;&lt;span&gt;OnDeck&lt;/span&gt;&lt;span&gt;），但是并发情况下，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ContentionList &lt;span&gt;会被大量的并发线程进行&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;访问，为了降低对尾部元素的竞争，&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;会将一部分线程移动到&lt;/span&gt; &lt;span&gt;EntryList&lt;/span&gt; &lt;span&gt;中作为候选竞争线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. Owner &lt;span&gt;线程会在&lt;/span&gt; &lt;span&gt;unlock&lt;/span&gt; &lt;span&gt;时，将&lt;/span&gt; &lt;span&gt;ContentionList&lt;/span&gt; &lt;span&gt;中的部分线程迁移到&lt;/span&gt; &lt;span&gt;EntryList&lt;/span&gt; &lt;span&gt;中，并指定&lt;/span&gt;&lt;span&gt;EntryList&lt;/span&gt; &lt;span&gt;中的某个线程为&lt;/span&gt; &lt;span&gt;OnDeck&lt;/span&gt; &lt;span&gt;线程（一般是最先进去的那个线程）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. Owner &lt;span&gt;线程并不直接把锁传递给&lt;/span&gt; &lt;span&gt;OnDeck&lt;/span&gt; &lt;span&gt;线程，而是把锁竞争的权利交给&lt;/span&gt; &lt;span&gt;OnDeck&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;OnDeck &lt;span&gt;需要重新竞争锁。这样虽然牺牲了一些公平性，但是能极大的提升系统的吞吐量，在&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;中，也把这种选择行为称之为&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;竞争切换&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. OnDeck &lt;span&gt;线程获取到锁资源后会变为&lt;/span&gt; &lt;span&gt;Owner&lt;/span&gt; &lt;span&gt;线程，而没有得到锁资源的仍然停留在&lt;/span&gt; &lt;span&gt;EntryList&lt;/span&gt;&lt;span&gt;中。如果&lt;/span&gt; &lt;span&gt;Owner&lt;/span&gt; &lt;span&gt;线程被&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;方法阻塞，则转移到&lt;/span&gt; &lt;span&gt;WaitSet&lt;/span&gt; &lt;span&gt;队列中，直到某个时刻通过&lt;/span&gt; &lt;span&gt;notify&lt;/span&gt;&lt;span&gt;或者&lt;/span&gt; &lt;span&gt;notifyAll&lt;/span&gt; &lt;span&gt;唤醒，会重新进去&lt;/span&gt; &lt;span&gt;EntryList&lt;/span&gt; &lt;span&gt;中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;span&gt;处于&lt;/span&gt; &lt;span&gt;ContentionList&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;EntryList&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;WaitSet&lt;/span&gt; &lt;span&gt;中的线程都处于阻塞状态，该阻塞是由操作系统&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;来完成的（&lt;/span&gt;Linux &lt;span&gt;内核下采用&lt;/span&gt; &lt;span&gt;pthread_mutex_lock&lt;/span&gt; &lt;span&gt;内核函数实现的）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. Synchronized &lt;span&gt;是非公平锁。&lt;/span&gt; &lt;span&gt;Synchronized&lt;/span&gt; &lt;span&gt;在线程进入&lt;/span&gt; &lt;span&gt;ContentionList&lt;/span&gt; &lt;span&gt;时，等待的线程会先尝试自旋获取锁，如果获取不到就进入&lt;/span&gt; &lt;span&gt;ContentionList&lt;/span&gt;&lt;span&gt;，这明显对于已经进入队列的线程是不公平的，还有一个不公平的事情就是自旋获取锁的线程还可能直接抢占&lt;/span&gt; &lt;span&gt;OnDeck&lt;/span&gt; &lt;span&gt;线程的锁资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;参考：&lt;/span&gt;https://blog.csdn.net/zqz_zqz/article/details/70233767&lt;/p&gt;
&lt;p&gt;7. &lt;span&gt;每个对象都有个&lt;/span&gt; &lt;span&gt;monitor&lt;/span&gt; &lt;span&gt;对象，加锁就是在竞争&lt;/span&gt; &lt;span&gt;monitor&lt;/span&gt; &lt;span&gt;对象，代码块加锁是在前后分别加上&lt;/span&gt; &lt;span&gt;monitorenter&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;monitorexit&lt;/span&gt; &lt;span&gt;指令来实现的，方法加锁是通过一个标记位来判断的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8. synchronized &lt;span&gt;是一个重量级操作，需要调用操作系统相关接口，性能是低效的，有可能给线程加锁消耗的时间比有用操作消耗的时间更多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;9. Java1.6&lt;span&gt;，&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;进行了很多的优化，有适应自旋、锁消除、锁粗化、轻量级锁及偏向锁等，效率有了本质上的提高。在之后推出的&lt;/span&gt; &lt;span&gt;Java1.7&lt;/span&gt; &lt;span&gt;与&lt;/span&gt; &lt;span&gt;1.8&lt;/span&gt; &lt;span&gt;中，均对该关键字的实现机理做了优化。引入了偏向锁和轻量级锁。都是在对象头中有标记位，不需要经过操作系统加锁。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;ReentrantLock&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;ReentantLock &lt;span&gt;继承接口&lt;/span&gt; &lt;span&gt;Lock&lt;/span&gt; &lt;span&gt;并实现了接口中定义的方法，他是一种可重入锁，除了能完&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成&lt;/span&gt; synchronized &lt;span&gt;所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Lock &lt;span&gt;接口的主要方法&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1. void lock(): &lt;span&gt;执行此方法时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;如果锁处于空闲状态&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;当前线程将获取到锁&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; &lt;span&gt;相反&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;如果锁已经被其他线程持有&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;将禁用当前线程&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;直到当前线程获取到锁&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. boolean tryLock()&lt;span&gt;：如果锁可用&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;则获取锁&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;并立即返回&lt;/span&gt; &lt;span&gt;true,&lt;/span&gt; &lt;span&gt;否则返回&lt;/span&gt; &lt;span&gt;false.&lt;/span&gt; &lt;span&gt;该方法和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;lock()&lt;span&gt;的区别在于&lt;/span&gt;&lt;span&gt;, tryLock()&lt;/span&gt;&lt;span&gt;只是&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;试图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取锁&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;如果锁不可用&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;不会导致当前线程被禁用&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前线程仍然继续往下执行代码&lt;/span&gt;. &lt;span&gt;而&lt;/span&gt; &lt;span&gt;lock()&lt;/span&gt;&lt;span&gt;方法则是一定要获取到锁&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;如果锁不可用&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;就一&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;直等待&lt;/span&gt;, &lt;span&gt;在未获得锁之前&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;当前线程并不继续向下执行&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. void unlock()&lt;span&gt;：执行此方法时&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;当前线程将释放持有的锁&lt;/span&gt;&lt;span&gt;.&lt;/span&gt; &lt;span&gt;锁只能由持有者释放&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;如果线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;并不持有锁&lt;/span&gt;, &lt;span&gt;却执行该方法&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;可能导致异常的发生&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. Condition newCondition()&lt;span&gt;：条件对象，获取等待通知组件。该组件和当前的锁绑定，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前线程只有获取了锁，才能调用该组件的&lt;/span&gt; await()&lt;span&gt;方法，而调用后，当前线程将缩放锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. getHoldCount() &lt;span&gt;：查询当前线程保持此锁的次数，也就是执行此线程执行&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt; &lt;span&gt;方法的次&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. getQueueLength&lt;span&gt;（）：返回正等待获取此锁的线程估计数，比如启动&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;个线程，&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程获得锁，此时返回的是&lt;/span&gt; 9&lt;/p&gt;
&lt;p&gt;7. getWaitQueueLength&lt;span&gt;：（&lt;/span&gt;&lt;span&gt;Condition condition&lt;/span&gt;&lt;span&gt;）返回等待与此锁相关的给定条件的线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程估计数。比如&lt;/span&gt; 10 &lt;span&gt;个线程，用同一个&lt;/span&gt; &lt;span&gt;condition&lt;/span&gt; &lt;span&gt;对象，并且此时这&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;个线程都执行了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;condition &lt;span&gt;对象的&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; &lt;span&gt;方法，那么此时执行此方法返回&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8. hasWaiters(Condition condition)&lt;span&gt;：查询是否有线程等待与此锁有关的给定条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(condition)&lt;span&gt;，对于指定&lt;/span&gt; &lt;span&gt;contidion&lt;/span&gt; &lt;span&gt;对象，有多少线程执行了&lt;/span&gt; &lt;span&gt;condition.await&lt;/span&gt; &lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;9. hasQueuedThread(Thread thread)&lt;span&gt;：查询给定线程是否等待获取此锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;10. hasQueuedThreads()&lt;span&gt;：是否有线程等待此锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;11. isFair()&lt;span&gt;：该锁是否公平锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;12. isHeldByCurrentThread()&lt;span&gt;： 当前线程是否保持锁锁定，线程的执行&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt; &lt;span&gt;方法的前后分&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;别是&lt;/span&gt; false &lt;span&gt;和&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;13. isLock()&lt;span&gt;：此锁是否有任意线程占用&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;14. lockInterruptibly&lt;span&gt;（）：如果当前线程未被中断，获取锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;15. tryLock&lt;span&gt;（）：尝试获得锁，仅在调用时锁未被线程占用，获得锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;16. tryLock(long timeout TimeUnit unit)&lt;span&gt;：如果锁在给定等待时间内没有被另一个线程保持，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则获取该锁&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;&lt;strong&gt;&lt;span&gt;非公平锁&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;JVM &lt;span&gt;按随机、就近原则分配锁的机制则称为不公平锁，&lt;/span&gt;&lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;在构造函数中提供了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是否公平锁的初始化方式，默认为非公平锁。非公平锁实际执行的效率要远远超出公平锁，除非程序有特殊需要，否则最常用非公平锁的分配机制。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;公平锁&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;公平锁指的是锁的分配机制是公平的，通常先对锁提出获取请求的线程会先被分配到锁，&lt;/span&gt;ReentrantLock &lt;span&gt;在构造函数中提供了是否公平锁的初始化方式来定义公平锁。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;ReentrantLock &lt;span&gt;与&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1. ReentrantLock &lt;span&gt;通过方法&lt;/span&gt; &lt;span&gt;lock()&lt;/span&gt;&lt;span&gt;与&lt;/span&gt; &lt;span&gt;unlock()&lt;/span&gt;&lt;span&gt;来进行加锁与解锁操作，与&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;会被&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;自动解锁机制不同，&lt;/span&gt;&lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;加锁后需要手动进行解锁。为了避免程序出现异常而无法正常解锁的情况，使用&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;必须在&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;控制块中进行解锁操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. ReentrantLock &lt;span&gt;相比&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;的优势是可中断、公平锁、多个锁。这种情况下需要&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用&lt;/span&gt; ReentrantLock&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509083858797-1423125672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;h4&gt;&lt;strong&gt;Condition &lt;span&gt;类和&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;类锁方法区别区别&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1. Condition &lt;span&gt;类的&lt;/span&gt; &lt;span&gt;awiat&lt;/span&gt; &lt;span&gt;方法和&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;类的&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;方法等效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. Condition &lt;span&gt;类的&lt;/span&gt; &lt;span&gt;signal&lt;/span&gt; &lt;span&gt;方法和&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;类的&lt;/span&gt; &lt;span&gt;notify&lt;/span&gt; &lt;span&gt;方法等效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. Condition &lt;span&gt;类的&lt;/span&gt; &lt;span&gt;signalAll&lt;/span&gt; &lt;span&gt;方法和&lt;/span&gt; &lt;span&gt;Object&lt;/span&gt; &lt;span&gt;类的&lt;/span&gt; &lt;span&gt;notifyAll&lt;/span&gt; &lt;span&gt;方法等效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. ReentrantLock &lt;span&gt;类可以唤醒指定条件的线程，而&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; &lt;span&gt;的唤醒是随机的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指定条件唤醒，多建立几个&lt;/span&gt;condition&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;tryLock &lt;span&gt;和&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;lockInterruptibly&lt;/span&gt; &lt;span&gt;的区别&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1. tryLock &lt;span&gt;能获得锁就返回&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;，不能就立即返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;tryLock(long timeout,TimeUnit&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;unit)&lt;span&gt;，可以增加时间限制，如果超过该时间段还没获得锁，返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;2. lock &lt;span&gt;能获得锁就返回&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;，不能的话一直等待获得锁&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;3. lock &lt;span&gt;和&lt;/span&gt; &lt;span&gt;lockInterruptibly&lt;/span&gt;&lt;span&gt;，如果两个线程分别执行这两个方法，但此时中断这两个线程，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;lock &lt;span&gt;不会抛出异常，而&lt;/span&gt; &lt;span&gt;lockInterruptibly&lt;/span&gt; &lt;span&gt;会抛出异常。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;可重入锁的好处&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;假如一个线程拥有了这个锁。另一个线程需要这个锁，这个时候进行调用。可以直接调用，不用等待重新获取。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Semaphore &lt;span&gt;信号量&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Semaphore &lt;span&gt;是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。&lt;/span&gt;&lt;span&gt;Semaphore&lt;/span&gt; &lt;span&gt;可以用来构建一些对象池，资源池之类的，比如数据库连接池&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;实现互斥锁（计数器为&lt;/span&gt; 1&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;我们也可以创建计数为&lt;/span&gt; 1 &lt;span&gt;的&lt;/span&gt; &lt;span&gt;Semaphore&lt;/span&gt;&lt;span&gt;，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/h4&gt;

&lt;h4&gt;&lt;strong&gt;其他用途&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;可以创建一个信号量，每个线程消耗一下信号量。用完之后。获取一下剩余数量，如果和初始相等，证明线程内部都执行完毕了，可以继续执行主线程了。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;Semaphore &lt;span&gt;与&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;Semaphore &lt;span&gt;基本能完成&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;的所有工作，使用方法也与之类似，通过&lt;/span&gt; &lt;span&gt;acquire()&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;release()&lt;/span&gt;&lt;span&gt;方法来获得和释放临界资源。经实测，&lt;/span&gt;&lt;span&gt;Semaphone.acquire()&lt;/span&gt;&lt;span&gt;方法默认为可响应中断锁，与&lt;/span&gt; &lt;span&gt;ReentrantLock.lockInterruptibly()&lt;/span&gt;&lt;span&gt;作用效果一致，也就是说在等待临界资源的过程中可以被&lt;/span&gt;&lt;span&gt;Thread.interrupt()&lt;/span&gt;&lt;span&gt;方法中断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，&lt;/span&gt;Semaphore &lt;span&gt;也实现了可轮询的锁请求与定时锁的功能，除了方法名&lt;/span&gt; &lt;span&gt;tryAcquire&lt;/span&gt; &lt;span&gt;与&lt;/span&gt; &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;不同，其使用方法与&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;几乎一致。&lt;/span&gt;&lt;span&gt;Semaphore&lt;/span&gt; &lt;span&gt;也提供了公平与非公平锁的机制，也可在构造函数中进行设定。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Semaphore &lt;span&gt;的锁释放操作也由手动进行，因此与&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;一样，为避免线程因抛出异常而无法正常释放锁的情况发生，释放锁的操作也必须在&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;代码块中完成。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;AtomicInteger&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;首先说明，此处&lt;/span&gt; AtomicInteger &lt;span&gt;，一个提供原子操作的&lt;/span&gt; &lt;span&gt;Integer&lt;/span&gt; &lt;span&gt;的类，常见的还有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;AtomicBoolean&lt;span&gt;、&lt;/span&gt;&lt;span&gt;AtomicInteger&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;AtomicLong&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;AtomicReference&lt;/span&gt; &lt;span&gt;等，他们的实现原理相同，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;区别在与运算对象类型的不同。令人兴奋地，还可以通过&lt;/span&gt; AtomicReference&amp;lt;V&amp;gt;&lt;span&gt;将一个对象的所有操作转化成原子操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们知道，在多线程程序中，诸如&lt;/span&gt;++i &lt;span&gt;或&lt;/span&gt; &lt;span&gt;i++&lt;/span&gt;&lt;span&gt;等运算不具有原子性，是不安全的线程操作之一。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常我们会使用&lt;/span&gt; synchronized &lt;span&gt;将该操作变成一个原子操作，但&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;为此类操作特意提供了一些同步类，使得使用更方便，且使程序运行效率变得更高。通过相关资料显示，通常&lt;/span&gt;&lt;span&gt;AtomicInteger&lt;/span&gt;&lt;span&gt;的性能是&lt;/span&gt; &lt;span&gt;ReentantLock&lt;/span&gt; &lt;span&gt;的好几倍。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;可重入锁（递归锁）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;本文里面讲的是广义上的可重入锁，而不是单指&lt;/span&gt; JAVA &lt;span&gt;下的&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;。可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。在&lt;/span&gt; &lt;span&gt;JAVA&lt;/span&gt; &lt;span&gt;环境下&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;都是可重入锁&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;公平锁与非公平锁&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;公平锁（&lt;/span&gt;Fair&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;非公平锁（&lt;/span&gt;Nonfair&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;非公平锁性能比公平锁高&lt;/span&gt; &lt;span&gt;5~10&lt;/span&gt; &lt;span&gt;倍，因为公平锁需要在多核的情况下维护一个队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. Java &lt;span&gt;中的&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;是非公平锁，&lt;/span&gt;&lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;默认的&lt;/span&gt; &lt;span&gt;lock()&lt;/span&gt;&lt;span&gt;方法采用的是非公平锁。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;ReadWriteLock &lt;span&gt;读写锁&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;为了提高性能，&lt;/span&gt;Java &lt;span&gt;提供了读写锁，在读的地方使用读锁，在写的地方使用写锁，灵活控制，如果没有写锁的情况下，读是无阻塞的&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;在一定程度上提高了程序的执行效率。读写锁分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，这是由&lt;/span&gt; &lt;span&gt;jvm&lt;/span&gt; &lt;span&gt;自己控制的，你只要上好相应的锁即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你的代码只读数据，可以很多人同时读，但不能同时写，那就上读锁&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你的代码修改数据，只能有一个人在写，且不能同时读取，那就上写锁。总之，读的时候上读锁，写的时候上写锁！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java &lt;span&gt;中读写锁有个接口&lt;/span&gt; &lt;span&gt;java.util.concurrent.locks.ReadWriteLock&lt;/span&gt; &lt;span&gt;，也有具体的实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ReentrantReadWriteLock&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;共享锁和独占锁&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;独占锁&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;独占锁模式下，每次只能有一个线程能持有锁，&lt;/span&gt;ReentrantLock &lt;span&gt;就是以独占方式实现的互斥锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;独占锁是一种悲观保守的加锁策略，它避免了读&lt;/span&gt;/&lt;span&gt;读冲突，如果某个只读线程获取锁，则其他读线程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;共享锁&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;共享锁则允许多个线程同时获取锁，并发访问&lt;/span&gt; &lt;span&gt;共享资源，如：&lt;/span&gt;ReadWriteLock&lt;span&gt;。共享锁则是一种乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. AQS &lt;span&gt;的内部类&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt; &lt;span&gt;定义了两个常量&lt;/span&gt; &lt;span&gt;SHARED&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;EXCLUSIVE&lt;/span&gt;&lt;span&gt;，他们分别标识&lt;/span&gt; &lt;span&gt;AQS&lt;/span&gt; &lt;span&gt;队列中等待线程的锁获取模式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. java &lt;span&gt;的并发包中提供了&lt;/span&gt; &lt;span&gt;ReadWriteLock&lt;/span&gt;&lt;span&gt;，读&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;写锁。它允许一个资源可以被多个读操作访问，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者被一个写操作访问，但两者不能同时进行。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;重量级锁（&lt;/span&gt;Mutex Lock&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Synchronized &lt;span&gt;是通过对象内部的一个叫做监视器锁（&lt;/span&gt;&lt;span&gt;monitor&lt;/span&gt;&lt;span&gt;）来实现的。但是监视器锁本质又是依赖于底层的操作系统的&lt;/span&gt; &lt;span&gt;Mutex Lock&lt;/span&gt; &lt;span&gt;来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么&lt;/span&gt;&lt;span&gt;Synchronized&lt;/span&gt; &lt;span&gt;效率低的原因。因此，这种依赖于操作系统&lt;/span&gt; &lt;span&gt;Mutex Lock&lt;/span&gt; &lt;span&gt;所实现的锁我们称之为&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;重量级锁&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;JDK&lt;/span&gt; &lt;span&gt;中对&lt;/span&gt; &lt;span&gt;Synchronized&lt;/span&gt; &lt;span&gt;做的种种优化，其核心都是为了减少这种重量级锁的使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDK1.6 &lt;span&gt;以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;轻量级锁&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;偏向锁&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;轻量级锁&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;锁的状态总共有四种：无锁状态、偏向锁、轻量级锁和重量级锁。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;锁升级&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;“&lt;span&gt;轻量级&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀为重量级锁。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;偏向锁&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Hotspot &lt;span&gt;的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt;&lt;span&gt;）的开销，看起来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;原子指令，而偏向锁只需要在置换&lt;/span&gt;&lt;span&gt;ThreadID&lt;/span&gt; &lt;span&gt;的时候依赖一次&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所以偏向锁的撤销操作的性能损耗必须小于节省下来的&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;原子指令的性能消耗）。上面说过，轻量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进一步提高性能。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;分段锁&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;分段锁也并非一种实际的锁，而是一种思想&lt;/span&gt; ConcurrentHashMap &lt;span&gt;是学习分段锁的最好实践&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;锁优化&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;减少锁持有时间&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;只用在有线程安全要求的程序上加锁&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;减小锁粒度&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;将大对象（这个对象可能会被很多线程访问），拆成小对象，大大增加并行度，降低锁竞争。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;降低了锁的竞争，偏向锁，轻量级锁成功率才会提高。最最典型的减小锁粒度的案例就是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ConcurrentHashMap&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;锁分离&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;最常见的锁分离就是读写锁&lt;/span&gt; ReadWriteLock&lt;span&gt;，根据功能进行分离成读锁和写锁，这样读读不互斥，读写互斥，写写互斥，即保证了线程安全，又提高了性能&lt;/span&gt;。JDK &lt;span&gt;并发包&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;。读写分离思想可以延伸，只要操作互不影响，锁就可以分离。比如&lt;/span&gt;&lt;span&gt;LinkedBlockingQueue&lt;/span&gt; &lt;span&gt;从头部取出，从尾部放数据&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;锁粗化&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化&lt;/span&gt; &lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;锁消除&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;锁消除是在编译器级别的事情。在即时编译器时，如果发现不可能被共享的对象，则可以消除这些对象的锁操作，多数是因为程序员编码不规范引起。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;9. &lt;strong&gt;线程基本方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509083918898-1100053925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程等待（&lt;/span&gt;wait&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;调用该方法的线程进入&lt;/span&gt; WAITING &lt;span&gt;状态，只有等待另外线程的通知或被中断才会返回，需要注意的是调用&lt;/span&gt; &lt;span&gt;wait()&lt;/span&gt;&lt;span&gt;方法后，会释放对象的锁。因此，&lt;/span&gt;&lt;span&gt;wait&lt;/span&gt; &lt;span&gt;方法一般用在同步方法或同步代码块中。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程睡眠（&lt;/span&gt;sleep&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;sleep &lt;span&gt;导致当前线程休眠，与&lt;/span&gt; &lt;span&gt;wait&lt;/span&gt; &lt;span&gt;方法不同的是&lt;/span&gt; &lt;span&gt;sleep&lt;/span&gt; &lt;span&gt;不会释放当前占有的锁&lt;/span&gt;&lt;span&gt;,sleep(long)&lt;/span&gt;&lt;span&gt;会导致线程进入&lt;/span&gt; &lt;span&gt;TIMED-WATING&lt;/span&gt; &lt;span&gt;状态，而&lt;/span&gt; &lt;span&gt;wait()&lt;/span&gt;&lt;span&gt;方法会导致当前线程进入&lt;/span&gt; &lt;span&gt;WATING&lt;/span&gt; &lt;span&gt;状态&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程让步（&lt;/span&gt;yield&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;yield &lt;span&gt;会使当前线程让出&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;执行时间片，与其他线程一起重新竞争&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;时间片。一般情况下，优先级高的线程有更大的可能性成功竞争得到&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;时间片，但这又不是绝对的，有的操作系统对线程优先级并不敏感。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程中断（&lt;/span&gt;interrupt&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位。这个线程本身并不会因此而改变状态&lt;/span&gt;(&lt;span&gt;如阻塞，终止等&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;调用&lt;/span&gt; &lt;span&gt;interrupt()&lt;/span&gt;&lt;span&gt;方法并不会中断一个正在运行的线程。也就是说处于&lt;/span&gt; &lt;span&gt;Running&lt;/span&gt; &lt;span&gt;状态的线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程并不会因为被中断而被终止，仅仅改变了内部维护的中断标识位而已。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;若调用&lt;/span&gt; &lt;span&gt;sleep()&lt;/span&gt;&lt;span&gt;而使线程处于&lt;/span&gt; &lt;span&gt;TIMED-WATING&lt;/span&gt; &lt;span&gt;状态，这时调用&lt;/span&gt; &lt;span&gt;interrupt()&lt;/span&gt;&lt;span&gt;方法，会抛出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;InterruptedException,&lt;span&gt;从而使线程提前结束&lt;/span&gt; &lt;span&gt;TIMED-WATING&lt;/span&gt; &lt;span&gt;状态。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;许多声明抛出&lt;/span&gt; &lt;span&gt;InterruptedException&lt;/span&gt; &lt;span&gt;的方法&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;如&lt;/span&gt; &lt;span&gt;Thread.sleep(long mills&lt;/span&gt; &lt;span&gt;方法&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;&lt;span&gt;，抛出异&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;常前，都会清除中断标识位，所以抛出异常后，调用&lt;/span&gt; isInterrupted()&lt;span&gt;方法将会返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;中断状态是线程固有的一个标识位，可以通过此标识位安全的终止线程。比如&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;你想终止&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个线程&lt;/span&gt; thread &lt;span&gt;的时候，可以调用&lt;/span&gt; &lt;span&gt;thread.interrupt()&lt;/span&gt;&lt;span&gt;方法，在线程的&lt;/span&gt; &lt;span&gt;run&lt;/span&gt; &lt;span&gt;方法内部可以&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据&lt;/span&gt; thread.isInterrupted()&lt;span&gt;的值来优雅的终止线程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Join &lt;span&gt;等待其他线程终止&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;join() &lt;span&gt;方法，等待其他线程终止，在当前线程中调用一个线程的&lt;/span&gt; &lt;span&gt;join()&lt;/span&gt; &lt;span&gt;方法，则当前线程转为阻塞状态，回到另一个线程结束，当前线程再由阻塞状态变为就绪状态，等待&lt;/span&gt; &lt;span&gt;cpu&lt;/span&gt; &lt;span&gt;的宠幸。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;为什么要用&lt;/span&gt; join()&lt;span&gt;方法？&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;很多情况下，主线程生成并启动了子线程，需要用到子线程返回的结果，也就是需要主线程需要在子线程结束后再结束，这时候就要用到&lt;/span&gt; join() &lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509083925826-717646858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程唤醒（&lt;/span&gt;notify&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Object &lt;span&gt;类中的&lt;/span&gt; &lt;span&gt;notify()&lt;/span&gt; &lt;span&gt;方法，唤醒在此对象监视器上等待的单个线程，如果所有线程都在此对象上等待，则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个&lt;/span&gt; &lt;span&gt;wait()&lt;/span&gt; &lt;span&gt;方法，在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有&lt;/span&gt; &lt;span&gt;notifyAll()&lt;/span&gt; &lt;span&gt;，唤醒再次监视器上等待的所有线程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;其他方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. sleep()&lt;span&gt;：强迫一个线程睡眠Ｎ毫秒。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. isAlive()&lt;span&gt;： 判断一个线程是否存活。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. join()&lt;span&gt;： 等待线程终止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. activeCount()&lt;span&gt;： 程序中活跃的线程数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. enumerate()&lt;span&gt;： 枚举程序中的线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. currentThread()&lt;span&gt;： 得到当前线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7. isDaemon()&lt;span&gt;： 一个线程是否为守护线程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8. setDaemon()&lt;span&gt;： 设置一个线程为守护线程。&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;用户线程和守护线程的区别在于，是否等待主线&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;程依赖于主线程结束而结束&lt;/span&gt;)&lt;/p&gt;
&lt;p&gt;9. setName()&lt;span&gt;： 为线程设置一个名称。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;10. wait()&lt;span&gt;： 强迫一个线程等待。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;11. notify()&lt;span&gt;： 通知一个线程继续运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;12. setPriority()&lt;span&gt;： 设置一个线程的优先级。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;13. getPriority():&lt;span&gt;：获得一个线程的优先级。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;10. &lt;strong&gt;线程的上下文切换&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;巧妙地利用了时间片轮转的方式&lt;/span&gt;, CPU &lt;span&gt;给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;这段过程就叫做上下文切换。时间片轮转的方式使多个任务在同一颗&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;上执行变成了可能。&lt;/span&gt;&lt;/p&gt;



&lt;h3&gt;&lt;strong&gt;线&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;程&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;（有时候也称做任务）是指一个程序运行的实例。在&lt;/span&gt; Linux &lt;span&gt;系统中，线程就是能并行运行并且与他们的父进程（创建他们的进程）共享同一地址空间（一段内存区域）和其他资源的轻量级的进程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;上下文&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;是指某一时间点&lt;/span&gt; CPU &lt;span&gt;寄存器和程序计数器的内容。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;寄存器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;是&lt;/span&gt; CPU &lt;span&gt;内部的数量较少但是速度很快的内存（与之对应的是&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;外部相对较慢的&lt;/span&gt; &lt;span&gt;RAM&lt;/span&gt; &lt;span&gt;主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;程序计数器&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;是一个专用的寄存器，用于表明指令序列中&lt;/span&gt; CPU &lt;span&gt;正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;PCB-“&lt;span&gt;切换桢&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;上下文切换可以认为是内核（操作系统的核心）在&lt;/span&gt; CPU &lt;span&gt;上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（&lt;/span&gt;&lt;span&gt;PCB, process control block&lt;/span&gt;&lt;span&gt;）中的。&lt;/span&gt;&lt;span&gt;PCB&lt;/span&gt; &lt;span&gt;还经常被称作&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;切换桢&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;（&lt;/span&gt;&lt;span&gt;switchframe&lt;/span&gt;&lt;span&gt;）。信息会一直保存到&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;的内存中，直到他们被再次使用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;上下文切换的活动&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;挂起一个进程，将这个进程在&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;中的状态（上下文）存储于内存中的某处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;在内存中检索下一个进程的上下文并将其在&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;的寄存器中恢复。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;引起线程上下文切换的原因&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;当前执行任务的时间片用完之后，系统&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;正常调度下一个任务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;当前执行任务碰到&lt;/span&gt; &lt;span&gt;IO&lt;/span&gt; &lt;span&gt;阻塞，调度器将此任务挂起，继续下一任务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;用户代码挂起当前任务，让出&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;时间；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;span&gt;硬件中断；&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;11. &lt;strong&gt;&lt;span&gt;同步锁与死锁&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;同步锁&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。&lt;/span&gt; Java &lt;span&gt;中可以使用&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;关键字来取得一个对象的同步锁。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;死锁&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;12. &lt;strong&gt;&lt;span&gt;线程池原理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程复用&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;每一个&lt;/span&gt; Thread &lt;span&gt;的类都有一个&lt;/span&gt; &lt;span&gt;start&lt;/span&gt; &lt;span&gt;方法。 当调用&lt;/span&gt; &lt;span&gt;start&lt;/span&gt; &lt;span&gt;启动线程时&lt;/span&gt; &lt;span&gt;Java&lt;/span&gt; &lt;span&gt;虚拟机会调用该类的&lt;/span&gt; &lt;span&gt;run&lt;/span&gt; &lt;span&gt;方法。 那么该类的&lt;/span&gt; &lt;span&gt;run()&lt;/span&gt; &lt;span&gt;方法中就是调用了&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;对象的&lt;/span&gt; &lt;span&gt;run()&lt;/span&gt; &lt;span&gt;方法。 我们可以继承重写&lt;/span&gt;&lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;类，在其&lt;/span&gt; &lt;span&gt;start&lt;/span&gt; &lt;span&gt;方法中添加不断循环调用传递过来的&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;对象。 这就是线程池的实现原理。循环方法中不断获取&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;是用&lt;/span&gt; &lt;span&gt;Queue&lt;/span&gt; &lt;span&gt;实现的，在获取下一个&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;之前可以是阻塞的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程池的组成&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;一般的线程池主要分为以下&lt;/span&gt; 4 &lt;span&gt;个组成部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;线程池管理器：用于创建并管理线程池&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;工作线程：线程池中的线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;任务接口：每个任务必须实现的接口，用于工作线程调度其运行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;任务队列：用于存放待处理的任务，提供一种缓冲机制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Java &lt;span&gt;中的线程池是通过&lt;/span&gt; &lt;span&gt;Executor&lt;/span&gt; &lt;span&gt;框架实现的，该框架中用到了&lt;/span&gt; &lt;span&gt;Executor&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Executors&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ExecutorService&lt;span&gt;，&lt;/span&gt;&lt;span&gt;ThreadPoolExecutor&lt;/span&gt; &lt;span&gt;，&lt;/span&gt;&lt;span&gt;Callable&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;Future&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;FutureTask&lt;/span&gt; &lt;span&gt;这几个类。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;ThreadPoolExecutor &lt;span&gt;的构造方法如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. corePoolSize&lt;span&gt;：指定了线程池中的线程数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. maximumPoolSize&lt;span&gt;：指定了线程池中的最大线程数量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. keepAliveTime&lt;span&gt;：当前线程池数量超过&lt;/span&gt; &lt;span&gt;corePoolSize&lt;/span&gt; &lt;span&gt;时，多余的空闲线程的存活时间，即多&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;次时间内会被销毁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. unit&lt;span&gt;：&lt;/span&gt;&lt;span&gt;keepAliveTime&lt;/span&gt; &lt;span&gt;的单位。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. workQueue&lt;span&gt;：任务队列，被提交但尚未被执行的任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. threadFactory&lt;span&gt;：线程工厂，用于创建线程，一般用默认的即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7. handler&lt;span&gt;：拒绝策略，当任务太多来不及处理，如何拒绝任务。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;拒绝策略&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;JDK &lt;span&gt;内置的拒绝策略如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. AbortPolicy &lt;span&gt;： 直接抛出异常，阻止系统正常运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. CallerRunsPolicy &lt;span&gt;： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. DiscardOldestPolicy &lt;span&gt;： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;次提交当前任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. DiscardPolicy &lt;span&gt;： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;失，这是最好的一种方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上内置拒绝策略均实现了&lt;/span&gt; RejectedExecutionHandler &lt;span&gt;接口，若以上策略仍无法满足实际&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要，完全可以自己扩展&lt;/span&gt; RejectedExecutionHandler &lt;span&gt;接口。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Java &lt;span&gt;线程池工作过程&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;当调用&lt;/span&gt; &lt;span&gt;execute()&lt;/span&gt; &lt;span&gt;方法添加一个任务时，线程池会做如下判断：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;a) &lt;span&gt;如果正在运行的线程数量小于&lt;/span&gt; &lt;span&gt;corePoolSize&lt;/span&gt;&lt;span&gt;，那么马上创建线程运行这个任务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;b) &lt;span&gt;如果正在运行的线程数量大于或等于&lt;/span&gt; &lt;span&gt;corePoolSize&lt;/span&gt;&lt;span&gt;，那么将这个任务放入队列；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;c) &lt;span&gt;如果这时候队列满了，而且正在运行的线程数量小于&lt;/span&gt; &lt;span&gt;maximumPoolSize&lt;/span&gt;&lt;span&gt;，那么还是要&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建非核心线程立刻运行这个任务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;d) &lt;span&gt;如果队列满了，而且正在运行的线程数量大于或等于&lt;/span&gt; &lt;span&gt;maximumPoolSize&lt;/span&gt;&lt;span&gt;，那么线程池&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;会抛出异常&lt;/span&gt; RejectExecutionException&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;当一个线程完成任务时，它会从队列中取下一个任务来执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. &lt;span&gt;当一个线程无事可做，超过一定的时间（&lt;/span&gt;&lt;span&gt;keepAliveTime&lt;/span&gt;&lt;span&gt;）时，线程池会判断，如果当前运行的线程数大于&lt;/span&gt; &lt;span&gt;corePoolSize&lt;/span&gt;&lt;span&gt;，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到&lt;/span&gt; &lt;span&gt;corePoolSize&lt;/span&gt; &lt;span&gt;的大小。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;13. &lt;strong&gt;JAVA &lt;span&gt;阻塞队列原理&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;阻塞队列，关键字是阻塞，先理解阻塞的含义，在阻塞队列中，线程阻塞有这样的两种情况：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;阻塞队列的主要方法&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509083949671-1582249900.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;„ &lt;span&gt;抛出异常：抛出一个异常；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;„ &lt;span&gt;特殊值：返回一个特殊值（&lt;/span&gt;&lt;span&gt;null&lt;/span&gt; &lt;span&gt;或&lt;/span&gt; &lt;span&gt;false,&lt;/span&gt;&lt;span&gt;视情况而定）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;„ &lt;span&gt;则塞：在成功操作之前，一直阻塞线程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;„ &lt;span&gt;超时：放弃前只在最大的时间内阻塞&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;插入操作：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1&lt;span&gt;：&lt;/span&gt;&lt;span&gt;public abstract boolean add(E paramE)&lt;/span&gt;&lt;span&gt;：将指定元素插入此队列中（如果立即可行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;且不会违反容量限制），成功时返回&lt;/span&gt; true&lt;span&gt;，如果当前没有可用的空间，则抛&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出&lt;/span&gt; IllegalStateException&lt;span&gt;。如果该元素是&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;，则会抛出&lt;/span&gt; &lt;span&gt;NullPointerException&lt;/span&gt; &lt;span&gt;异常。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;：&lt;/span&gt;&lt;span&gt;public abstract boolean offer(E paramE)&lt;/span&gt;&lt;span&gt;：将指定元素插入此队列中（如果立即可行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;且不会违反容量限制），成功时返回&lt;/span&gt; true&lt;span&gt;，如果当前没有可用的空间，则返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;：&lt;/span&gt;&lt;span&gt;public abstract void put(E paramE) throws InterruptedException&lt;/span&gt;&lt;span&gt;： 将指定元素插入此队列中，将等待可用的空间（如果有必要）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;public void put(E paramE) throws InterruptedException {&lt;/p&gt;
&lt;p&gt; checkNotNull(paramE);&lt;/p&gt;
&lt;p&gt; ReentrantLock localReentrantLock = this.lock;&lt;/p&gt;
&lt;p&gt; localReentrantLock.lockInterruptibly();&lt;/p&gt;
&lt;p&gt; try {&lt;/p&gt;
&lt;p&gt; while (this.count == this.items.length)&lt;/p&gt;
&lt;p&gt; this.notFull.await();//&lt;span&gt;如果队列满了，则线程阻塞等待&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; enqueue(paramE);&lt;/p&gt;
&lt;p&gt; localReentrantLock.unlock();&lt;/p&gt;
&lt;p&gt; } finally {&lt;/p&gt;
&lt;p&gt; localReentrantLock.unlock();&lt;/p&gt;
&lt;p&gt; }&lt;/p&gt;
&lt;p&gt; }&lt;/p&gt;
&lt;p&gt; 4&lt;span&gt;：&lt;/span&gt;&lt;span&gt;offer(E o, long timeout, TimeUnit unit)&lt;/span&gt;&lt;span&gt;：可以设定等待的时间，如果在指定的时间&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;内，还不能往队列中加入&lt;/span&gt; BlockingQueue&lt;span&gt;，则返回失败。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;&lt;span&gt;获取数据操作：&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1&lt;span&gt;：&lt;/span&gt;&lt;span&gt;poll(time):&lt;/span&gt;&lt;span&gt;取走&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt; &lt;span&gt;里排在首位的对象&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;若不能立即取出&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;则可以等&lt;/span&gt; &lt;span&gt;time&lt;/span&gt; &lt;span&gt;参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;规定的时间&lt;/span&gt;,&lt;span&gt;取不到时返回&lt;/span&gt; &lt;span&gt;null;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;：&lt;/span&gt;&lt;span&gt;poll(long timeout, TimeUnit unit)&lt;/span&gt;&lt;span&gt;：从&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt; &lt;span&gt;取出一个队首的对象，如果在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则直到时间超时还没有数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;据可取，返回失败。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3&lt;span&gt;：&lt;/span&gt;&lt;span&gt;take():&lt;/span&gt;&lt;span&gt;取走&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt; &lt;span&gt;里排在首位的对象&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;若&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt; &lt;span&gt;为空&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;阻断进入等待状&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;态直到&lt;/span&gt; BlockingQueue &lt;span&gt;有新的数据被加入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.drainTo():&lt;span&gt;一次性从&lt;/span&gt; &lt;span&gt;BlockingQueue&lt;/span&gt; &lt;span&gt;获取所有可用的数据对象（还可以指定获取数据的个&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;Java &lt;span&gt;中的阻塞队列&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. ArrayBlockingQueue &lt;span&gt;：由数组结构组成的有界阻塞队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. LinkedBlockingQueue &lt;span&gt;：由链表结构组成的有界阻塞队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. PriorityBlockingQueue &lt;span&gt;：支持优先级排序的无界阻塞队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. DelayQueue&lt;span&gt;：使用优先级队列实现的无界阻塞队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. SynchronousQueue&lt;span&gt;：不存储元素的阻塞队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. LinkedTransferQueue&lt;span&gt;：由链表结构组成的无界阻塞队列。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7. LinkedBlockingDeque&lt;span&gt;：由链表结构组成的双向阻塞队列&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;ArrayBlockingQueue&lt;span&gt;（公平、非公平）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;用数组实现的有界阻塞队列。此队列按照先进先出（&lt;/span&gt;FIFO&lt;span&gt;）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列，所谓公平访问队列是指阻塞的所有生产者线程或消费者线程，当队列可用时，可以按照阻塞的先后顺序访问队列，即先阻塞的生产者线程，可以先往队列里插入元素，先阻塞的消费者线程，可以先从队列里获取元素。通常情况下为了保证公平性会降低吞吐量。我们可以使用以下代码创建一个公平的阻塞队列：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ArrayBlockingQueue fairQueue = new ArrayBlockingQueue(1000,true);&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;LinkedBlockingQueue&lt;span&gt;（两个独立锁提高并发）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;基于链表的阻塞队列，同&lt;/span&gt; ArrayListBlockingQueue &lt;span&gt;类似，此队列按照先进先出（&lt;/span&gt;&lt;span&gt;FIFO&lt;/span&gt;&lt;span&gt;）的原则对元素进行排序。而&lt;/span&gt; &lt;span&gt;LinkedBlockingQueue&lt;/span&gt; &lt;span&gt;之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LinkedBlockingQueue &lt;span&gt;会默认一个类似无限大小的容量（&lt;/span&gt;&lt;span&gt;Integer.MAX_VALUE&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;PriorityBlockingQueue&lt;span&gt;（&lt;/span&gt;&lt;span&gt;compareTo&lt;/span&gt; &lt;span&gt;排序实现优先）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;compareTo()&lt;span&gt;方法来指定元素进行排序规则，或者初始化&lt;/span&gt; &lt;span&gt;PriorityBlockingQueue&lt;/span&gt; &lt;span&gt;时，指定构造参数&lt;/span&gt; &lt;span&gt;Comparator&lt;/span&gt; &lt;span&gt;来对元素进行排序。需要注意的是不能保证同优先级元素的顺序。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;DelayQueue&lt;span&gt;（缓存失效、定时任务 ）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;是一个支持延时获取元素的无界阻塞队列。队列使用&lt;/span&gt; PriorityQueue &lt;span&gt;来实现。队列中的元素必须实现&lt;/span&gt; &lt;span&gt;Delayed&lt;/span&gt; &lt;span&gt;接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。我们可以将&lt;/span&gt; &lt;span&gt;DelayQueue&lt;/span&gt; &lt;span&gt;运用在以下应用场景：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;span&gt;缓存系统的设计：可以用&lt;/span&gt; &lt;span&gt;DelayQueue&lt;/span&gt; &lt;span&gt;保存缓存元素的有效期，使用一个线程循环查询&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DelayQueue&lt;span&gt;，一旦能从&lt;/span&gt; &lt;span&gt;DelayQueue&lt;/span&gt; &lt;span&gt;中获取元素时，表示缓存有效期到了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;定时任务调度：使用&lt;/span&gt; &lt;span&gt;DelayQueue&lt;/span&gt; &lt;span&gt;保存当天将会执行的任务和执行时间，一旦从&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;DelayQueue &lt;span&gt;中获取到任务就开始执行，从比如&lt;/span&gt; &lt;span&gt;TimerQueue&lt;/span&gt; &lt;span&gt;就是使用&lt;/span&gt; &lt;span&gt;DelayQueue&lt;/span&gt; &lt;span&gt;实现的。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;SynchronousQueue&lt;span&gt;（不存储数据、可用于传递数据）&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;是一个不存储元素的阻塞队列。每一个&lt;/span&gt; put &lt;span&gt;操作必须等待一个&lt;/span&gt; &lt;span&gt;take&lt;/span&gt; &lt;span&gt;操作，否则不能继续添加元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;SynchronousQueue &lt;span&gt;可以看成是一个传球手，负责把生产者线程处理的数据直接传递给消费者线程。队列本身并不存储任何元素，非常适合于传递性场景&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;比如在一个线程中使用的数据，传递给另外一个线程使用，&lt;/span&gt; &lt;span&gt;SynchronousQueue&lt;/span&gt; &lt;span&gt;的吞吐量高于&lt;/span&gt; &lt;span&gt;LinkedBlockingQueue&lt;/span&gt; &lt;span&gt;和&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ArrayBlockingQueue&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;LinkedTransferQueue&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;是一个由链表结构组成的无界阻塞&lt;/span&gt; TransferQueue &lt;span&gt;队列。相对于其他阻塞队列，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;LinkedTransferQueue &lt;span&gt;多了&lt;/span&gt; &lt;span&gt;tryTransfer&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;transfer&lt;/span&gt; &lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. transfer &lt;span&gt;方法：如果当前有消费者正在等待接收元素（消费者使用&lt;/span&gt; &lt;span&gt;take()&lt;/span&gt;&lt;span&gt;方法或带时间限制的&lt;/span&gt;&lt;span&gt;poll()&lt;/span&gt;&lt;span&gt;方法时），&lt;/span&gt;&lt;span&gt;transfer&lt;/span&gt; &lt;span&gt;方法可以把生产者传入的元素立刻&lt;/span&gt; &lt;span&gt;transfer&lt;/span&gt;&lt;span&gt;（传输）给消费者。如果没有消费者在等待接收元素，&lt;/span&gt;&lt;span&gt;transfer&lt;/span&gt; &lt;span&gt;方法会将元素存放在队列的&lt;/span&gt; &lt;span&gt;tail&lt;/span&gt; &lt;span&gt;节点，并等到该元素被消费者消费了才返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. tryTransfer &lt;span&gt;方法。则是用来试探下生产者传入的元素是否能直接传给消费者。如果没有消费者等待接收元素，则返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。和&lt;/span&gt; &lt;span&gt;transfer&lt;/span&gt; &lt;span&gt;方法的区别是&lt;/span&gt; &lt;span&gt;tryTransfer&lt;/span&gt; &lt;span&gt;方法无论消费者是否接收，方法立即返回。而&lt;/span&gt; &lt;span&gt;transfer&lt;/span&gt; &lt;span&gt;方法是必须等到消费者消费了才返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于带有时间限制的&lt;/span&gt; tryTransfer(E e, long timeout, TimeUnit unit)&lt;span&gt;方法，则是试图把生产者传&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;入的元素直接传给消费者，但是如果没有消费者消费该元素则等待指定的时间再返回，如果超时还没消费元素，则返回&lt;/span&gt; false&lt;span&gt;，如果在超时时间内消费了元素，则返回&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;LinkedBlockingDeque&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素。双端队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。相比其他的阻塞队列，&lt;/span&gt;LinkedBlockingDeque &lt;span&gt;多了&lt;/span&gt; &lt;span&gt;addFirst&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;addLast&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;offerFirst&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;offerLast&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;peekFirst&lt;span&gt;，&lt;/span&gt;&lt;span&gt;peekLast&lt;/span&gt; &lt;span&gt;等方法，以&lt;/span&gt; &lt;span&gt;First&lt;/span&gt; &lt;span&gt;单词结尾的方法，表示插入，获取（&lt;/span&gt;&lt;span&gt;peek&lt;/span&gt;&lt;span&gt;）或移除双端队列的第一个元素。以&lt;/span&gt; &lt;span&gt;Last&lt;/span&gt; &lt;span&gt;单词结尾的方法，表示插入，获取或移除双端队列的最后一个元素。另外插入方法&lt;/span&gt; &lt;span&gt;add&lt;/span&gt; &lt;span&gt;等同于&lt;/span&gt; &lt;span&gt;addLast&lt;/span&gt;&lt;span&gt;，移除方法&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt; &lt;span&gt;等效于&lt;/span&gt; &lt;span&gt;removeFirst&lt;/span&gt;&lt;span&gt;。但是&lt;/span&gt; &lt;span&gt;take&lt;/span&gt; &lt;span&gt;方法却等同于&lt;/span&gt; &lt;span&gt;takeFirst&lt;/span&gt;&lt;span&gt;，不知道是不是&lt;/span&gt; &lt;span&gt;Jdk&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;bug&lt;/span&gt;&lt;span&gt;，使用时还是用带有&lt;/span&gt; &lt;span&gt;First&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;Last&lt;/span&gt; &lt;span&gt;后缀的方法更清楚。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在初始化&lt;/span&gt; LinkedBlockingDeque &lt;span&gt;时可以设置容量防止其过渡膨胀。另外双向阻塞队列可以运用在&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;工作窃取&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;模式中。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;14. &lt;strong&gt;CyclicBarrier&lt;span&gt;、&lt;/span&gt;&lt;span&gt;CountDownLatch&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Semaphore&lt;/span&gt; &lt;span&gt;的用法&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;CountDownLatch&lt;span&gt;（线程计数器）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;CountDownLatch &lt;span&gt;类位于&lt;/span&gt; &lt;span&gt;java.util.concurrent&lt;/span&gt; &lt;span&gt;包下，利用它可以实现类似计数器的功能。比如有一个任务&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;&lt;span&gt;，它要等待其他&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;个任务执行完毕之后才能执行，此时就可以利用&lt;/span&gt; &lt;span&gt;CountDownLatch&lt;/span&gt;&lt;span&gt;来实现这种功能了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509084000688-1508483018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;h3&gt;&lt;strong&gt;CyclicBarrier&lt;span&gt;（回环栅栏&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;等待至&lt;/span&gt; &lt;span&gt;barrier&lt;/span&gt; &lt;span&gt;状态再全部同时执行）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，&lt;/span&gt;CyclicBarrier &lt;span&gt;可以被重用。我们暂且把这个状态就叫做&lt;/span&gt;&lt;span&gt;barrier&lt;/span&gt;&lt;span&gt;，当调用&lt;/span&gt; &lt;span&gt;await()&lt;/span&gt;&lt;span&gt;方法之后，线程就处于&lt;/span&gt; &lt;span&gt;barrier&lt;/span&gt; &lt;span&gt;了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CyclicBarrier &lt;span&gt;中最重要的方法就是&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; &lt;span&gt;方法，它有&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;个重载版本：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. public int await()&lt;span&gt;：用来挂起当前线程，直至所有线程都到达&lt;/span&gt; &lt;span&gt;barrier&lt;/span&gt; &lt;span&gt;状态再同时执行后续任务；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. public int await(long timeout, TimeUnit unit)&lt;span&gt;：让这些线程等待至一定的时间，如果还有&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程没有到达&lt;/span&gt; barrier &lt;span&gt;状态就直接让到达&lt;/span&gt; &lt;span&gt;barrier&lt;/span&gt; &lt;span&gt;的线程执行后续任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;具体使用如下，另外&lt;/span&gt; CyclicBarrier &lt;span&gt;是可以重用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509084005425-2108414575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;&lt;strong&gt;Semaphore&lt;span&gt;（信号量&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;控制同时访问的线程个数）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Semaphore &lt;span&gt;翻译成字面意思为信号量，&lt;/span&gt;&lt;span&gt;Semaphore&lt;/span&gt; &lt;span&gt;可以控制同时访问的线程个数，通过&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;acquire() &lt;span&gt;获取一个许可，如果没有就等待，而&lt;/span&gt; &lt;span&gt;release()&lt;/span&gt; &lt;span&gt;释放一个许可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Semaphore &lt;span&gt;类中比较重要的几个方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. public void acquire(): &lt;span&gt;用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. public void acquire(int permits):&lt;span&gt;获取&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt; &lt;span&gt;个许可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. public void release() { } :&lt;span&gt;释放许可。注意，在释放许可之前，必须先获获得许可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. public void release(int permits) { }:&lt;span&gt;释放&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt; &lt;span&gt;个许可&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面&lt;/span&gt; 4 &lt;span&gt;个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. public boolean tryAcquire():&lt;span&gt;尝试获取一个许可，若获取成功，则立即返回&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;，若获取失&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;败，则立即返回&lt;/span&gt; false&lt;/p&gt;
&lt;p&gt;2. public boolean tryAcquire(long timeout, TimeUnit unit):&lt;span&gt;尝试获取一个许可，若在指定的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;时间内获取成功，则立即返回&lt;/span&gt; true&lt;span&gt;，否则则立即返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. public boolean tryAcquire(int permits):&lt;span&gt;尝试获取&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt; &lt;span&gt;个许可，若获取成功，则立即返&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回&lt;/span&gt; true&lt;span&gt;，若获取失败，则立即返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. public boolean tryAcquire(int permits, long timeout, TimeUnit unit): &lt;span&gt;尝试获取&lt;/span&gt; &lt;span&gt;permits&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;个许可，若在指定的时间内获取成功，则立即返回&lt;/span&gt; true&lt;span&gt;，否则则立即返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. &lt;span&gt;还可以通过&lt;/span&gt; &lt;span&gt;availablePermits()&lt;/span&gt;&lt;span&gt;方法得到可用的许可数目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例子：若一个工厂有&lt;/span&gt; 5 &lt;span&gt;台机器，但是有&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; &lt;span&gt;个工人，一台机器同时只能被一个工人使用，只有使用完&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;了，其他工人才能继续使用。那么我们就可以通过&lt;/span&gt; Semaphore &lt;span&gt;来实现：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509084011290-283877692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;CountDownLatch &lt;span&gt;和&lt;/span&gt; &lt;span&gt;CyclicBarrier&lt;/span&gt; &lt;span&gt;都能够实现线程之间的等待，只不过它们侧重点不&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同；&lt;/span&gt;CountDownLatch &lt;span&gt;一般用于某个线程&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;span&gt;等待若干个其他线程执行完任务之后，它才&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行；而&lt;/span&gt; CyclicBarrier &lt;span&gt;一般用于一组线程互相等待至某个状态，然后这一组线程再同时&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行；另外，&lt;/span&gt;CountDownLatch &lt;span&gt;是不能够重用的，而&lt;/span&gt; &lt;span&gt;CyclicBarrier&lt;/span&gt; &lt;span&gt;是可以重用的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Semaphore &lt;span&gt;其实和锁有点类似，它一般用于控制对某组资源的访问权限。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;15. &lt;strong&gt;volatile &lt;span&gt;关键字的作用（变量可见性、禁止重排序）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Java &lt;span&gt;语言提供了一种稍弱的同步机制，即&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;变量，用来确保将变量的更新操作通知到其他线程。&lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;变量具备两种特性，&lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;类型的变量时总会返回最新写入的值。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;变量可见性&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;其一是保证该变量对所有线程可见，这里的可见性指的是当一个线程修改了变量的值，那么新的值对于其他线程是可以立即获取的。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;禁止重排序&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;volatile &lt;span&gt;禁止了指令重排。 比&lt;/span&gt; &lt;span&gt;sychronized&lt;/span&gt; &lt;span&gt;更轻量级的同步锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在访问&lt;/span&gt; volatile &lt;span&gt;变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;变量是一种比&lt;/span&gt; &lt;span&gt;sychronized&lt;/span&gt; &lt;span&gt;关键字更轻量级的同步机制。&lt;/span&gt;&lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当对非&lt;/span&gt; volatile &lt;span&gt;变量进行读写的时候，每个线程先从内存拷贝变量到&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;缓存中。如果计算机有多个&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;，每个线程可能在不同的&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;上被处理，这意味着每个线程可以拷贝到不同的&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt;  cache &lt;span&gt;中。而声明变量是&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;的，&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;保证了每次读变量都从内存中读，跳过&lt;/span&gt; &lt;span&gt;CPU cache&lt;/span&gt; &lt;span&gt;这一步。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;适用场景&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;值得说明的是对&lt;/span&gt; volatile &lt;span&gt;变量的单次读&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;写操作可以保证原子性的，如&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;和&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;类型变量，但是并不能保证&lt;/span&gt; &lt;span&gt;i++&lt;/span&gt;&lt;span&gt;这种操作的原子性，因为本质上&lt;/span&gt; &lt;span&gt;i++&lt;/span&gt;&lt;span&gt;是读、写两次操作。在某些场景下可以代替&lt;/span&gt; &lt;span&gt;Synchronized&lt;/span&gt;&lt;span&gt;。但是&lt;/span&gt;&lt;span&gt;,volatile&lt;/span&gt; &lt;span&gt;的不能完全取代&lt;/span&gt; &lt;span&gt;Synchronized&lt;/span&gt; &lt;span&gt;的位置，只有在一些特殊的场景下，才能适用&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（&lt;/span&gt;1&lt;span&gt;）对变量的写操作不依赖于当前值（比如&lt;/span&gt; &lt;span&gt;i++&lt;/span&gt;&lt;span&gt;），或者说是单纯的变量赋值（&lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;flag = true&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）&lt;span&gt;该变量没有包含在具有其他变量的不变式中，也就是说，不同的&lt;/span&gt; volatile &lt;span&gt;变量之间，不能互相依赖。只有在状态真正独立于程序内其他内容时才能使用&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;16. &lt;strong&gt;&lt;span&gt;如何在两个线程之间共享数据&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Java &lt;span&gt;里面进行多线程通信的主要方式就是共享内存的方式，共享内存主要的关注点有两个：可见性和有序性原子性。&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt; &lt;span&gt;内存模型（&lt;/span&gt;&lt;span&gt;JMM&lt;/span&gt;&lt;span&gt;）解决了可见性和有序性的问题，而锁解决了原子性的问题，理想情况下我们希望做到&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;同步&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;互斥&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;。有以下常规实现方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将数据抽象成一个类，并将数据的操作作为这个类的方法&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;将数据抽象成一个类，并将对这个数据的操作作为这个类的方法，这么设计可以和容易做到同步，只要在方法上加&lt;/span&gt;”synchronized“。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Runnable &lt;span&gt;对象作为一个类的内部类&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;将&lt;/span&gt; Runnable &lt;span&gt;对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;span&gt;对象调用外部类的这些方法&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;17. &lt;strong&gt;ThreadLocal &lt;span&gt;作用（线程本地存储）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;ThreadLocal&lt;span&gt;，很多地方叫做线程本地变量，也有些地方叫做线程本地存储，&lt;/span&gt;&lt;span&gt;ThreadLocal&lt;/span&gt; &lt;span&gt;的作用是提供线程内的局部变量，这种变量在线程的生命周期内起作用，减少同一个线程内多个函数或者组件之间一些公共变量的传递的复杂度。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;ThreadLocalMap&lt;span&gt;（线程的一个属性）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;每个线程中都有一个自己的&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;span&gt;类对象，可以将线程自己的对象保持到其中，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;各管各的，线程可以正确的访问到自己的对象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;将一个共用的&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt; &lt;span&gt;静态实例作为&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt;，将不同对象的引用保存到不同线程的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ThreadLocalMap &lt;span&gt;中，然后在线程执行的各处通过这个静态&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt; &lt;span&gt;实例的&lt;/span&gt; &lt;span&gt;get()&lt;/span&gt;&lt;span&gt;方法取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得自己线程保存的那个对象，避免了将这个对象作为参数传递的麻烦。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. ThreadLocalMap &lt;span&gt;其实就是线程里面的一个属性，它在&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;类中定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;ThreadLocal.ThreadLocalMap threadLocals = null;&lt;/p&gt;
&lt;p&gt;使&lt;span&gt;用场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最常见的&lt;/span&gt; ThreadLocal &lt;span&gt;使用场景为 用来解决 数据库连接、&lt;/span&gt;&lt;span&gt;Session&lt;/span&gt; &lt;span&gt;管理等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509084019252-248451264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;18. &lt;strong&gt;synchronized &lt;span&gt;和&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;的区别&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;两者的共同点：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;都是用来协调多线程对共享对象、变量的访问&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;都是可重入锁，同一线程可以多次获得同一个锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;都保证了可见性和互斥性&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;两者的不同点：&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. ReentrantLock &lt;span&gt;显示的获得、释放锁，&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;隐式获得释放锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. ReentrantLock &lt;span&gt;可响应中断、可轮回，&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;是不可以响应中断的，为处理锁的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不可用性提供了更高的灵活性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. ReentrantLock &lt;span&gt;是&lt;/span&gt; &lt;span&gt;API&lt;/span&gt; &lt;span&gt;级别的，&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;是&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;级别的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4. ReentrantLock &lt;span&gt;可以实现公平锁&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5. ReentrantLock &lt;span&gt;通过&lt;/span&gt; &lt;span&gt;Condition&lt;/span&gt; &lt;span&gt;可以绑定多个条件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;6. &lt;span&gt;底层实现不一样，&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;是同步阻塞，使用的是悲观并发策略，&lt;/span&gt;&lt;span&gt;lock&lt;/span&gt; &lt;span&gt;是同步非阻&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;塞，采用的是乐观并发策略&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;7. Lock &lt;span&gt;是一个接口，而&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;是&lt;/span&gt; &lt;span&gt;Java&lt;/span&gt; &lt;span&gt;中的关键字，&lt;/span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;是内置的语言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;实现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;8. synchronized &lt;span&gt;在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而&lt;/span&gt; Lock &lt;span&gt;在发生异常时，如果没有主动通过&lt;/span&gt; &lt;span&gt;unLock()&lt;/span&gt;&lt;span&gt;去释放锁，则很可能造成死锁现象，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因此使用&lt;/span&gt; Lock &lt;span&gt;时需要在&lt;/span&gt; &lt;span&gt;finally&lt;/span&gt; &lt;span&gt;块中释放锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;9. Lock &lt;span&gt;可以让等待锁的线程响应中断，而&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;却不行，使用&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;时，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;等待的线程会一直等待下去，不能够响应中断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;10. &lt;span&gt;通过&lt;/span&gt; &lt;span&gt;Lock&lt;/span&gt; &lt;span&gt;可以知道有没有成功获取锁，而&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;却无法办到。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;11. Lock &lt;span&gt;可以提高多个线程进行读操作的效率，既就是实现读写锁等。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;19. &lt;strong&gt;Java &lt;span&gt;中用到的线程调度&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;抢占式调度&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;抢占式调度指的是每条线程执行的时间、线程的切换都由系统控制，系统控制指的是在系统某种运行机制下，可能每条线程都分同样的执行时间片，也可能是某些线程执行的时间片较长，甚至某些线程得不到执行的时间片。在这种机制下，一个线程的堵塞不会导致整个进程堵塞。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;协同式调度&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;协同式调度指某一线程执行完后主动通知系统切换到另一线程上执行，这种模式就像接力赛一样，一个人跑完自己的路程就把接力棒交接给下一个人，下个人继续往下跑。线程的执行时间由线程本身控制，线程切换可以预知，不存在多线程同步问题，但它有一个致命弱点：如果一个线程编写有问题，运行到一半就一直堵塞，那么可能导致整个系统崩溃。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;JVM &lt;span&gt;的线程调度实现（抢占式调度）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;java &lt;span&gt;使用的线程调使用抢占式调度，&lt;/span&gt;&lt;span&gt;Java&lt;/span&gt; &lt;span&gt;中线程会按优先级分配&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;时间片运行，且优先级越高越优先执行，但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;线程让出&lt;/span&gt; cpu &lt;span&gt;的情况&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1. &lt;span&gt;当前运行线程主动放弃&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;暂时放弃&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;操作（基于时间片轮转调度的&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;操作系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;统不会让线程永久放弃&lt;/span&gt; CPU&lt;span&gt;，或者说放弃本次时间片的执行权），例如调用&lt;/span&gt; &lt;span&gt;yield()&lt;/span&gt;&lt;span&gt;方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2. &lt;span&gt;当前运行线程因为某些原因进入阻塞状态，例如阻塞在&lt;/span&gt; &lt;span&gt;I/O&lt;/span&gt; &lt;span&gt;上。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;3. &lt;span&gt;当前运行线程结束，即运行完&lt;/span&gt; &lt;span&gt;run()&lt;/span&gt;&lt;span&gt;方法里面的任务。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;20. &lt;strong&gt;&lt;span&gt;什么是&lt;/span&gt; CAS&lt;span&gt;（比较并交换&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;乐观锁机制&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;锁自旋）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;概念及特性&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;CAS&lt;span&gt;（&lt;/span&gt;&lt;span&gt;Compare And Swap/Set&lt;/span&gt;&lt;span&gt;）比较并交换，&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;算法的过程是这样：它包含&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; &lt;span&gt;个参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CAS(V,E,N)&lt;span&gt;。&lt;/span&gt;&lt;span&gt;V&lt;/span&gt; &lt;span&gt;表示要更新的变量&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;内存值&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;E&lt;/span&gt; &lt;span&gt;表示预期值&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;旧的&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;N&lt;/span&gt; &lt;span&gt;表示新值。当且仅当&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; &lt;span&gt;值等于&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; &lt;span&gt;值时，才会将&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; &lt;span&gt;的值设为&lt;/span&gt; &lt;span&gt;N&lt;/span&gt;&lt;span&gt;，如果&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; &lt;span&gt;值和&lt;/span&gt; &lt;span&gt;E&lt;/span&gt; &lt;span&gt;值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;返回当前&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; &lt;span&gt;的真实值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CAS &lt;span&gt;操作是抱着乐观的态度进行的&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;乐观锁&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，它总是认为自己可以成功完成操作。当多个线程同时使用&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;原子包&lt;/span&gt; java.util.concurrent.atomic&lt;span&gt;（锁自旋）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;JDK1.5 &lt;span&gt;的原子包：&lt;/span&gt;&lt;span&gt;java.util.concurrent.atomic&lt;/span&gt; &lt;span&gt;这个包里面提供了一组原子类。其基本的特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由&lt;/span&gt; &lt;span&gt;JVM&lt;/span&gt; &lt;span&gt;从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;相对于对于&lt;/span&gt; synchronized &lt;span&gt;这种阻塞算法，&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;是非阻塞算法的一种常见实现。由于一般&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;切换时间比&lt;/span&gt; &lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;指令集操作更加长， 所以&lt;/span&gt; &lt;span&gt;J.U.C&lt;/span&gt; &lt;span&gt;在性能上有了很大的提升。如下代码&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200509084034345-787639194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;getAndIncrement &lt;span&gt;采用了&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;操作，每次从内存中读取数据然后将此数据和&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt; &lt;span&gt;后的结果进行&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;操作，如果成功就返回结果，否则重试直到成功为止。而&lt;/span&gt; &lt;span&gt;compareAndSet&lt;/span&gt; &lt;span&gt;利用&lt;/span&gt; &lt;span&gt;JNI&lt;/span&gt; &lt;span&gt;来完成&lt;/span&gt;&lt;span&gt;CPU&lt;/span&gt; &lt;span&gt;指令的操作。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;ABA &lt;span&gt;问题&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;CAS &lt;span&gt;会导致&lt;/span&gt;&lt;span&gt;“ABA&lt;/span&gt; &lt;span&gt;问题&lt;/span&gt;&lt;span&gt;”&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;算法实现一个重要前提需要取出内存中某时刻的数据，而在下时刻比较并替换，那么在这个时间差类会导致数据的变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如说一个线程&lt;/span&gt; one &lt;span&gt;从内存位置&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; &lt;span&gt;中取出&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;&lt;span&gt;，这时候另一个线程&lt;/span&gt; &lt;span&gt;two&lt;/span&gt; &lt;span&gt;也从内存中取出&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;&lt;span&gt;，并且&lt;/span&gt;&lt;span&gt;two&lt;/span&gt; &lt;span&gt;进行了一些操作变成了&lt;/span&gt; &lt;span&gt;B&lt;/span&gt;&lt;span&gt;，然后&lt;/span&gt; &lt;span&gt;two&lt;/span&gt; &lt;span&gt;又将&lt;/span&gt; &lt;span&gt;V&lt;/span&gt; &lt;span&gt;位置的数据变成&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;&lt;span&gt;，这时候线程&lt;/span&gt; &lt;span&gt;one&lt;/span&gt; &lt;span&gt;进行&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;操作发现内存中仍然是&lt;/span&gt; &lt;span&gt;A&lt;/span&gt;&lt;span&gt;，然后&lt;/span&gt; &lt;span&gt;one&lt;/span&gt; &lt;span&gt;操作成功。尽管线程&lt;/span&gt; &lt;span&gt;one&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;操作成功，但是不代表这个过程就是没有问题的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;部分乐观锁的实现是通过版本号（&lt;/span&gt;version&lt;span&gt;）的方式来解决&lt;/span&gt; &lt;span&gt;ABA&lt;/span&gt; &lt;span&gt;问题，乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行&lt;/span&gt;&lt;span&gt;+1&lt;/span&gt; &lt;span&gt;操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现&lt;/span&gt; &lt;span&gt;ABA&lt;/span&gt; &lt;span&gt;问题，因为版本号只会增加不会减少。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;21. &lt;strong&gt;&lt;span&gt;什么是&lt;/span&gt; AQS&lt;span&gt;（抽象的队列同步器）&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;AbstractQueuedSynchronizer &lt;span&gt;类如其名，抽象的队列式的同步器，&lt;/span&gt;&lt;span&gt;AQS&lt;/span&gt; &lt;span&gt;定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的&lt;/span&gt;&lt;span&gt;ReentrantLock/Semaphore/CountDownLatch&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;它维护了一个&lt;/span&gt; volatile int state&lt;span&gt;（代表共享资源）和一个&lt;/span&gt; &lt;span&gt;FIFO&lt;/span&gt; &lt;span&gt;线程等待队列（多线程争用资源被&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;阻塞时会进入此队列）。这里&lt;/span&gt; volatile &lt;span&gt;是核心关键词，具体&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;的语义，在此不述。&lt;/span&gt;&lt;span&gt;state&lt;/span&gt; &lt;span&gt;的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;访问方式有三种&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;getState()&lt;/p&gt;
&lt;p&gt;setState()&lt;/p&gt;
&lt;p&gt;compareAndSetState()&lt;/p&gt;
&lt;p&gt;AQS &lt;span&gt;定义两种资源共享方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;xclusive &lt;span&gt;独占资源&lt;/span&gt;&lt;span&gt;-ReentrantLock&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Exclusive&lt;span&gt;（独占，只有一个线程能执行，如&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Share &lt;span&gt;共享资源&lt;/span&gt;&lt;span&gt;-Semaphore/CountDownLatch&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Share&lt;span&gt;（共享，多个线程可同时执行，如&lt;/span&gt; &lt;span&gt;Semaphore/CountDownLatch&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;AQS &lt;span&gt;只是一个框架，具体资源的获取&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;释放方式交由自定义同步器去实现，&lt;/span&gt;&lt;span&gt;AQS&lt;/span&gt; &lt;span&gt;这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过&lt;/span&gt; &lt;span&gt;state&lt;/span&gt; &lt;span&gt;的&lt;/span&gt; &lt;span&gt;get/set/CAS)&lt;/span&gt;&lt;span&gt;之所以没有定义成&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;，是因为独占模式下只用实现&lt;/span&gt; &lt;span&gt;tryAcquire-tryRelease&lt;/span&gt; &lt;span&gt;，而共享模式下只用实现&lt;/span&gt;&lt;span&gt;tryAcquireShared-tryReleaseShared&lt;/span&gt;&lt;span&gt;。如果都定义成&lt;/span&gt;&lt;span&gt;abstract&lt;/span&gt;&lt;span&gt;，那么每个模式也要去实现另一模式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源&lt;/span&gt; &lt;span&gt;state&lt;/span&gt; &lt;span&gt;的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;唤醒出队等），&lt;/span&gt;&lt;span&gt;AQS&lt;/span&gt; &lt;span&gt;已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1&lt;span&gt;．&lt;/span&gt;&lt;span&gt;isHeldExclusively()&lt;/span&gt;&lt;span&gt;：该线程是否正在独占资源。只有用到&lt;/span&gt; &lt;span&gt;condition&lt;/span&gt; &lt;span&gt;才需要去实现它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2&lt;span&gt;．&lt;/span&gt;&lt;span&gt;tryAcquire(int)&lt;/span&gt;&lt;span&gt;：独占方式。尝试获取资源，成功则返回&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;，失败则返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;．&lt;/span&gt;&lt;span&gt;tryRelease(int)&lt;/span&gt;&lt;span&gt;：独占方式。尝试释放资源，成功则返回&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;，失败则返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;．&lt;/span&gt;&lt;span&gt;tryAcquireShared(int)&lt;/span&gt;&lt;span&gt;：共享方式。尝试获取资源。负数表示失败；&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; &lt;span&gt;表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;5&lt;span&gt;．&lt;/span&gt;&lt;span&gt;tryReleaseShared(int)&lt;/span&gt;&lt;span&gt;：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;，否则返回&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;同步器的实现是&lt;/span&gt; ABS &lt;span&gt;核心（&lt;/span&gt;&lt;span&gt;state&lt;/span&gt; &lt;span&gt;资源状态计数）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同步器的实现是&lt;/span&gt; ABS &lt;span&gt;核心，以&lt;/span&gt; &lt;span&gt;ReentrantLock&lt;/span&gt; &lt;span&gt;为例，&lt;/span&gt;&lt;span&gt;state&lt;/span&gt; &lt;span&gt;初始化为&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;，表示未锁定状态。&lt;/span&gt;&lt;span&gt;A&lt;/span&gt; &lt;span&gt;线程&lt;/span&gt;&lt;span&gt;lock()&lt;/span&gt;&lt;span&gt;时，会调用&lt;/span&gt; &lt;span&gt;tryAcquire()&lt;/span&gt;&lt;span&gt;独占该锁并将&lt;/span&gt; &lt;span&gt;state+1&lt;/span&gt;&lt;span&gt;。此后，其他线程再&lt;/span&gt; &lt;span&gt;tryAcquire()&lt;/span&gt;&lt;span&gt;时就会失败，直到&lt;/span&gt; &lt;span&gt;A&lt;/span&gt; &lt;span&gt;线程&lt;/span&gt; &lt;span&gt;unlock()&lt;/span&gt;&lt;span&gt;到&lt;/span&gt; &lt;span&gt;state=0&lt;/span&gt;&lt;span&gt;（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，&lt;/span&gt;&lt;span&gt;A&lt;/span&gt; &lt;span&gt;线程自己是可以重复获取此锁的（&lt;/span&gt;&lt;span&gt;state&lt;/span&gt; &lt;span&gt;会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证&lt;/span&gt; &lt;span&gt;state&lt;/span&gt; &lt;span&gt;是能回到零态的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以&lt;/span&gt; CountDownLatch &lt;span&gt;以例，任务分为&lt;/span&gt; &lt;span&gt;N&lt;/span&gt; &lt;span&gt;个子线程去执行，&lt;/span&gt;&lt;span&gt;state&lt;/span&gt; &lt;span&gt;也初始化为&lt;/span&gt; &lt;span&gt;N&lt;/span&gt;&lt;span&gt;（注意&lt;/span&gt; &lt;span&gt;N&lt;/span&gt; &lt;span&gt;要与线程个数一致）。这&lt;/span&gt; &lt;span&gt;N&lt;/span&gt; &lt;span&gt;个子线程是并行执行的，每个子线程执行完后&lt;/span&gt; &lt;span&gt;countDown()&lt;/span&gt;&lt;span&gt;一次，&lt;/span&gt;&lt;span&gt;state&lt;/span&gt;&lt;span&gt;会&lt;/span&gt; &lt;span&gt;CAS&lt;/span&gt; &lt;span&gt;减&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;。等到所有子线程都执行完后&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;即&lt;/span&gt; &lt;span&gt;state=0)&lt;/span&gt;&lt;span&gt;，会&lt;/span&gt; &lt;span&gt;unpark()&lt;/span&gt;&lt;span&gt;主调用线程，然后主调用线程就会从&lt;/span&gt; &lt;span&gt;await()&lt;/span&gt;&lt;span&gt;函数返回，继续后余动作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ReentrantReadWriteLock &lt;span&gt;实现独占和共享两种方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现&lt;/span&gt; tryAcquiretryRelease&lt;span&gt;、&lt;/span&gt;&lt;span&gt;tryAcquireShared-tryReleaseShared&lt;/span&gt; &lt;span&gt;中的一种即可。但&lt;/span&gt; &lt;span&gt;AQS&lt;/span&gt; &lt;span&gt;也支持自定义同步器同时实现独占和共享两种方式，如&lt;/span&gt; &lt;span&gt;ReentrantReadWriteLock&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 09 May 2020 00:42:00 +0000</pubDate>
<dc:creator>经典鸡翅</dc:creator>
<og:description>1.&amp;#160;Java线程的创建方式 （1）继承thread类 thread类本质是实现了runnable接口的一个实例，代表线程的一个实例。启动线程的方式start方法。start是一个本地方法，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jichi/p/12854685.html</dc:identifier>
</item>
<item>
<title>Golang 实现 Redis(5): 使用跳表实现 SortedSet - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/12854599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/12854599.html</guid>
<description>&lt;p&gt;本文是使用 golang 实现 redis 系列的第五篇， 将介绍如何使用跳表实现有序集合(SortedSet)的相关功能。&lt;/p&gt;
&lt;p&gt;跳表(skiplist) 是 Redis 中 SortedSet 数据结构的底层实现, 跳表优秀的范围查找能力为&lt;code&gt;ZRange&lt;/code&gt;和&lt;code&gt;ZRangeByScore&lt;/code&gt;等命令提供了支持。&lt;/p&gt;
&lt;p&gt;本文完整源代码在Github&lt;a href=&quot;https://github.com/HDT3213/godis/tree/master/src/datastruct/sortedset&quot;&gt;HDT3213/godis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;实现&lt;code&gt;ZRange&lt;/code&gt;命令最简单的数据结构是有序链表:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/793413/202005/793413-20200503230726387-221850327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在有序链表上实现&lt;code&gt;ZRange key start end&lt;/code&gt;命令需要进行&lt;code&gt;end&lt;/code&gt;次查询, 即时间复杂度为 &lt;em&gt;O(n)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;跳表的优化思路是添加上层链表，上层链表中会跳过一些节点。如图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/793413/202005/793413-20200503230748021-1515963822.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在有两层的跳表中，搜索的时间复杂度降低为了&lt;em&gt;O(n / 2)&lt;/em&gt;。以此类推在有 log2(n) 层的跳表中，搜索元素的时间复杂度为&lt;em&gt;O(log n)&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;了解数据结构之后，可以定义相关的类型了:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 对外的元素抽象
type Element struct {
    Member string
    Score  float64
}

type Node struct {
    Element // 元素的名称和 score
    backward *Node // 后向指针
    level []*Level // 前向指针, level[0] 为最下层
}

// 节点中每一层的抽象 
type Level struct {
    forward *Node // 指向同层中的下一个节点
    span int64 // 到 forward 跳过的节点数
}

// 跳表的定义
type skiplist struct {
    header *Node
    tail *Node
    length int64
    level int16
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用一张图来表示一下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/793413/202005/793413-20200503230906423-1276062392.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;有了上文的描述查找节点的逻辑不难实现, 以 RangeByRank 的核心逻辑为例:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 寻找排名为 rank 的节点, rank 从1开始
func (skiplist *skiplist) getByRank(rank int64)*Node {
    var i int64 = 0
    n := skiplist.header
    // 从顶层向下查询
    for level := skiplist.level - 1; level &amp;gt;= 0; level-- {
        // 从当前层向前搜索
        // 若当前层的下一个节点已经超过目标 (i+n.level[level].span &amp;gt; rank)，则结束当前层搜索进入下一层
        for n.level[level].forward != nil &amp;amp;&amp;amp; (i+n.level[level].span) &amp;lt;= rank {
            i += n.level[level].span
            n = n.level[level].forward
        }
        if i == rank {
            return n
        }
    }
    return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ZRangeByScore&lt;/code&gt; 命令需要 &lt;code&gt;getFirstInScoreRange&lt;/code&gt; 函数找到分数范围内第一个节点:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func (skiplist *skiplist) getFirstInScoreRange(min *ScoreBorder, max *ScoreBorder) *Node {
    // 判断跳表和范围是否有交集，若无交集提早返回
    if !skiplist.hasInRange(min, max) {
        return nil
    }
    n := skiplist.header
    // 从顶层向下查询
    for level := skiplist.level - 1; level &amp;gt;= 0; level-- {
        // 若 forward 节点仍未进入范围则继续向前(forward)
        // 若 forward 节点已进入范围，当 level &amp;gt; 0 时 forward 节点不能保证是 *第一个* 在 min 范围内的节点， 因此需进入下一层查找
        for n.level[level].forward != nil &amp;amp;&amp;amp; !min.less(n.level[level].forward.Score) {
            n = n.level[level].forward
        }
    }
    // 当从外层循环退出时 level=0 (最下层), n.level[0].forward 一定是 min 范围内的第一个节点
    n = n.level[0].forward
    if !max.greater(n.Score) {
        return nil
    }
    return n
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;插入节点的操作比较多，我们以注释的方式进行说明:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (skiplist *skiplist)insert(member string, score float64)*Node {
    // 寻找新节点的先驱节点，它们的 forward 将指向新节点
    // 因为每层都有一个 forward 指针, 所以每层都会对应一个先驱节点
    // 找到这些先驱节点并保存在 update 数组中
    update := make([]*Node, maxLevel)
    rank := make([]int64, maxLevel) // 保存各层先驱节点的排名，用于计算span

    node := skiplist.header
    for i := skiplist.level - 1; i &amp;gt;= 0; i-- { // 从上层向下寻找
        // 初始化 rank
        if i == skiplist.level - 1 {
            rank[i] = 0
        } else {
            rank[i] = rank[i + 1]
        }
        if node.level[i] != nil {
            // 遍历搜索
            for node.level[i].forward != nil &amp;amp;&amp;amp;
                (node.level[i].forward.Score &amp;lt; score ||
                    (node.level[i].forward.Score == score &amp;amp;&amp;amp; node.level[i].forward.Member &amp;lt; member)) { // same score, different key
                rank[i] += node.level[i].span
                node = node.level[i].forward
            }
        }
        update[i] = node
    }

    level := randomLevel() // 随机决定新节点的层数
    // 可能需要创建新的层
    if level &amp;gt; skiplist.level {
        for i := skiplist.level; i &amp;lt; level; i++ {
            rank[i] = 0
            update[i] = skiplist.header
            update[i].level[i].span = skiplist.length
        }
        skiplist.level = level
    }

    // 创建新节点并插入跳表
    node = makeNode(level, score, member)
    for i := int16(0); i &amp;lt; level; i++ {
        // 新节点的 forward 指向先驱节点的 forward
        node.level[i].forward = update[i].level[i].forward
        // 先驱节点的 forward 指向新节点
        update[i].level[i].forward = node

        // 计算先驱节点和新节点的 span
        node.level[i].span = update[i].level[i].span - (rank[0] - rank[i])
        update[i].level[i].span = (rank[0] - rank[i]) + 1
    }

    // 新节点可能不会包含所有层
    // 对于没有层，先驱节点的 span 会加1 (后面插入了新节点导致span+1)
    for i := level; i &amp;lt; skiplist.level; i++ {
        update[i].level[i].span++
    }

    // 更新后向指针
    if update[0] == skiplist.header {
        node.backward = nil
    } else {
        node.backward = update[0]
    }
    if node.level[0].forward != nil {
        node.level[0].forward.backward = node
    } else {
        skiplist.tail = node
    }
    skiplist.length++
    return node
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;randomLevel 用于随机决定新节点包含的层数，随机结果出现2的概率是出现1的25%， 出现3的概率是出现2的25%:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;func randomLevel() int16 {
    level := int16(1)
    for float32(rand.Int31()&amp;amp;0xFFFF) &amp;lt; (0.25 * 0xFFFF) {
        level++
    }
    if level &amp;lt; maxLevel {
        return level
    }
    return maxLevel
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;删除节点的思路与插入节点基本一致:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 删除操作可能一次删除多个节点
func (skiplist *skiplist) RemoveRangeByRank(start int64, stop int64)(removed []*Element) {
    var i int64 = 0  // 当前指针的排名
    update := make([]*Node, maxLevel)
    removed = make([]*Element, 0)

    // 从顶层向下寻找目标的先驱节点
    node := skiplist.header
    for level := skiplist.level - 1; level &amp;gt;= 0; level-- {
        for node.level[level].forward != nil &amp;amp;&amp;amp; (i+node.level[level].span) &amp;lt; start {
            i += node.level[level].span
            node = node.level[level].forward
        }
        update[level] = node
    }

    i++
    node = node.level[0].forward // node 是目标范围内第一个节点

    // 删除范围内的所有节点
    for node != nil &amp;amp;&amp;amp; i &amp;lt; stop {
        next := node.level[0].forward
        removedElement := node.Element
        removed = append(removed, &amp;amp;removedElement)
        skiplist.removeNode(node, update)
        node = next
        i++
    }
    return removed
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来分析一下执行具体节点删除操作的removeNode函数:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 传入目标节点和删除后的先驱节点
// 在批量删除时我们传入的 update 数组是相同的
func (skiplist *skiplist) removeNode(node *Node, update []*Node) {
    for i := int16(0); i &amp;lt; skiplist.level; i++ {
        // 如果先驱节点的forward指针指向了目标节点，则需要修改先驱的forward指针跳过要删除的目标节点
        // 同时更新先驱的 span
        if update[i].level[i].forward == node {
            update[i].level[i].span += node.level[i].span - 1
            update[i].level[i].forward = node.level[i].forward
        } else {
            update[i].level[i].span--
        }
    }
    // 修改目标节点后继节点的backward指针
    if node.level[0].forward != nil {
        node.level[0].forward.backward = node.backward
    } else {
        skiplist.tail = node.backward
    }
    // 必要时删除空白的层
    for skiplist.level &amp;gt; 1 &amp;amp;&amp;amp; skiplist.header.level[skiplist.level-1].forward == nil {
        skiplist.level--
    }
    skiplist.length--
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 08 May 2020 23:58:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>跳表和 SortedSet 实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Finley/p/12854599.html</dc:identifier>
</item>
<item>
<title>Elasticsearch系列---Term Vector工具探查数据 - 清茶豆奶</title>
<link>http://www.cnblogs.com/huangying2124/p/12854592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangying2124/p/12854592.html</guid>
<description>&lt;h3 id=&quot;概要&quot;&gt;概要&lt;/h3&gt;
&lt;p&gt;本篇主要介绍一个Term Vector的概念和基本使用方法。&lt;/p&gt;
&lt;h3 id=&quot;term-vector是什么？&quot;&gt;term vector是什么？&lt;/h3&gt;
&lt;p&gt;每次有document数据插入时，elasticsearch除了对document进行正排、倒排索引的存储之外，如果此索引的field设置了term_vector参数，elasticsearch还会对这个的分词信息进行计算、统计，比如这个document有多少个field，每个field的值分词处理后得到的term的df值，ttf值是多少，每个term存储的位置偏移量等信息，这些统计信息统称为term vector。&lt;br/&gt;term vector的值有5个&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;no：不存储term vector信息，默认值&lt;/li&gt;
&lt;li&gt;yes：只存储field terms信息，不包含position和offset信息&lt;/li&gt;
&lt;li&gt;with_positions：存储term信息和position信息&lt;/li&gt;
&lt;li&gt;with_offsets：存储term信息和offset信息&lt;/li&gt;
&lt;li&gt;with_positions_offsets：存储完整的term vector信息，包括field terms、position、offset信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;term vector的信息生成有两种方式：index-time和query-time。index-time即建立索引时生成term vector信息，query-time是在查询过程中实时生成term vector信息，前者以空间换时间，后者以时间换空间。&lt;/p&gt;
&lt;h3 id=&quot;term-vector有什么作用？&quot;&gt;term vector有什么作用？&lt;/h3&gt;
&lt;p&gt;term vector本质上是一个数据探查的工具（可以看成是一个debugger工具），上面记录着一个document内的field分词后的term的详细情况，如拆分成几个term，每个term在正排索引的哪个位置，各自的df值、ttf值分别是多少等等。一般用于数据疑似问题的排查，比如说排序和搜索与预期的结果不一致，需要了解根本原因，可以拿这个工具手动进行数据分析，帮助判断问题的根源。&lt;/p&gt;
&lt;h3 id=&quot;读懂term-vector信息&quot;&gt;读懂term vector信息&lt;/h3&gt;
&lt;p&gt;我们来看看一个完整的term vector报文，都有哪些信息，带#号的一行代码是添加的注释，如下示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;_index&quot;: &quot;music&quot;,
  &quot;_type&quot;: &quot;children&quot;,
  &quot;_id&quot;: &quot;1&quot;,
  &quot;_version&quot;: 1,
  &quot;found&quot;: true,
  &quot;took&quot;: 0,
  &quot;term_vectors&quot;: {
    &quot;text&quot;: {
      &quot;field_statistics&quot;: {
        &quot;sum_doc_freq&quot;: 3,
        &quot;doc_count&quot;: 1,
        &quot;sum_ttf&quot;: 3
      },
      &quot;terms&quot;: {
        &quot;elasticsearch&quot;: {
          &quot;doc_freq&quot;: 1,
          &quot;ttf&quot;: 1,
          &quot;term_freq&quot;: 1,
          &quot;tokens&quot;: [
            {
              &quot;position&quot;: 2,
              &quot;start_offset&quot;: 11,
              &quot;end_offset&quot;: 24
            }
          ]
        },
        &quot;hello&quot;: {
          &quot;doc_freq&quot;: 1,
          &quot;ttf&quot;: 1,
          &quot;term_freq&quot;: 1,
          &quot;tokens&quot;: [
            {
              &quot;position&quot;: 0,
              &quot;start_offset&quot;: 0,
              &quot;end_offset&quot;: 5
            }
          ]
        },
        &quot;java&quot;: {
          &quot;doc_freq&quot;: 1,
          &quot;ttf&quot;: 1,
          &quot;term_freq&quot;: 1,
          &quot;tokens&quot;: [
            {
              &quot;position&quot;: 1,
              &quot;start_offset&quot;: 6,
              &quot;end_offset&quot;: 10
            }
          ]
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一段完整的term vector信息，term vector是按field为维度来统计的，主要包含三个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;field statistics&lt;/li&gt;
&lt;li&gt;term statistics&lt;/li&gt;
&lt;li&gt;term information&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;field-statistics&quot;&gt;field statistics&lt;/h4&gt;
&lt;p&gt;指该索引和type下所有的document，对这个field所有term的统计信息，注意document的范围，不是某一条，是指定index/type下的所有document。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sum_doc_freq(sum of document frequency)：这个field中所有的term的df之和。&lt;/li&gt;
&lt;li&gt;doc_count(document count)：有多少document包含这个field，有些document可能没有这个field。&lt;/li&gt;
&lt;li&gt;sum_ttf(sum of total term frequency)：这个field中所有的term的tf之和。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;term-statistics&quot;&gt;term statistics&lt;/h4&gt;
&lt;p&gt;hello为当前document中，text field字段分词后的term，查询时设置term_statistics=true时生效。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;doc_freq(document frequency)：有多少document包含这个term。&lt;/li&gt;
&lt;li&gt;ttf(total term frequency)：这个term在所有document中出现的频率。&lt;/li&gt;
&lt;li&gt;term_freq(term frequency in the field)：这个term在当前document中出现的频率。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;term-information&quot;&gt;term information&lt;/h4&gt;
&lt;p&gt;示例中tokens里面的内容，tokens里面是个数组&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;position：这个term在field里的正排索引位置，如果有多个相同的term，tokens下面会有多条记录。&lt;/li&gt;
&lt;li&gt;start_offset：这个term在field里的偏移，表示起始位置偏移量。&lt;/li&gt;
&lt;li&gt;end_offset：这个term在field里的偏移量，表示结束位置偏移量。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;term-vector使用案例&quot;&gt;term vector使用案例&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;建立索引music，type命名为children，指定text字段为index-time，fullname字段为query-time&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /music
{
  &quot;mappings&quot;: {
    &quot;children&quot;: {
      &quot;properties&quot;: {
        &quot;content&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;term_vector&quot;: &quot;with_positions_offsets&quot;,
            &quot;store&quot; : true,
            &quot;analyzer&quot; : &quot;standard&quot;
         },
         &quot;fullname&quot;: {
            &quot;type&quot;: &quot;text&quot;,
            &quot;analyzer&quot; : &quot;standard&quot;
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;添加3条示例数据&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;PUT /music/children/1
{
  &quot;fullname&quot; : &quot;Jean Ritchie&quot;,
  &quot;content&quot; : &quot;Love Somebody&quot;
}

PUT /music/children/2
{
  &quot;fullname&quot; : &quot;John Smith&quot;,
  &quot;content&quot; : &quot;wake me, shark me ...&quot;
}
PUT /music/children/3
{
  &quot;fullname&quot; : &quot;Peter Raffi&quot;,
  &quot;content&quot; : &quot;brush your teeth&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;对document id为1这条数据进行term vector探查&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/1/_termvectors
{
  &quot;fields&quot; : [&quot;content&quot;],
  &quot;offsets&quot; : true,
  &quot;positions&quot; : true,
  &quot;term_statistics&quot; : true,
  &quot;field_statistics&quot; : true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的结果即为上文的term vector示例。&lt;br/&gt;另外可以提一下，用这3个document的id进行查询，field_statistics部分是一样的。&lt;/p&gt;
&lt;h3 id=&quot;term-vector常见用法&quot;&gt;term vector常见用法&lt;/h3&gt;
&lt;p&gt;除了上一节的标准查询用法，还有一些参数可以丰富term vector的查询。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_termvectors
{
  &quot;doc&quot; : {
    &quot;fullname&quot; : &quot;Peter Raffi&quot;,
    &quot;content&quot; : &quot;brush your teeth&quot;
  },
  &quot;fields&quot; : [&quot;content&quot;],
  &quot;offsets&quot; : true,
  &quot;positions&quot; : true,
  &quot;term_statistics&quot; : true,
  &quot;field_statistics&quot; : true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个语法的含义是针对指定的doc进行term vector分析，doc里的内容可以随意指定，特别实用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;per_field_analyzer参数&lt;br/&gt;可以指定字段的分词器进行探查&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_termvectors
{
  &quot;doc&quot; : {
    &quot;fullname&quot; : &quot;Jimmie Davis&quot;,
    &quot;content&quot; : &quot;you are my sunshine&quot;
  },
  &quot;fields&quot; : [&quot;content&quot;],
  &quot;offsets&quot; : true,
  &quot;positions&quot; : true,
  &quot;term_statistics&quot; : true,
  &quot;field_statistics&quot; : true,
  &quot;per_field_analyzer&quot; : {
    &quot;text&quot;: &quot;standard&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;filter参数&lt;br/&gt;对term vector统计结果进行过滤&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET /music/children/_termvectors
{
  &quot;doc&quot; : {
    &quot;fullname&quot; : &quot;Jimmie Davis&quot;,
    &quot;content&quot; : &quot;you are my sunshine&quot;
  },
  &quot;fields&quot; : [&quot;content&quot;],
  &quot;offsets&quot; : true,
  &quot;positions&quot; : true,
  &quot;term_statistics&quot; : true,
  &quot;field_statistics&quot; : true,
  &quot;filter&quot; : {
      &quot;max_num_terms&quot; : 3,
      &quot;min_term_freq&quot; : 1,
      &quot;min_doc_freq&quot; : 1
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据term统计信息，过滤出你想要看到的term vector统计结果。也挺有用的，比如你探查数据可以过滤掉一些出现频率过低的term。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;docs参数&lt;br/&gt;允许你同时对多个doc进行探查，这个使用频率看个人习惯。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;GET _mtermvectors
{
   &quot;docs&quot;: [
      {
         &quot;_index&quot;: &quot;music&quot;,
         &quot;_type&quot;: &quot;children&quot;,
         &quot;_id&quot;: &quot;2&quot;,
         &quot;term_statistics&quot;: true
      },
      {
         &quot;_index&quot;: &quot;music&quot;,
         &quot;_type&quot;: &quot;children&quot;,
         &quot;_id&quot;: &quot;1&quot;,
         &quot;fields&quot;: [
            &quot;content&quot;
         ]
      }
   ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;term-vector使用建议&quot;&gt;term vector使用建议&lt;/h3&gt;
&lt;p&gt;有两种方式可以得到term vector信息，一种是像上面案例，建立时指定，另一种是直接查询时生成&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;index-time，在mapping里配置，建立索引的时候，就直接给你生成这些term和field的统计信息，如果term_vector设置为with_positions_offsets，索引所占的空间是不设置term vector时的2倍。&lt;/li&gt;
&lt;li&gt;query-time，你之前没有生成过任何的Term vector信息，然后在查看term vector的时候，直接就可以看到了，会on the fly，现场计算出各种统计信息，然后返回给你。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两种方式采用哪种取决于对term vector的使用期望，query-time更常用一些，毕竟这个工具的用处是协助定位问题，实时计算就行。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;term vector是一个比较实用的工具，尤其是针对线上数据进行分析、协助问题定位的时候，可以派上很大的用场。&lt;/p&gt;
&lt;p&gt;专注Java高并发、分布式架构，更多技术干货分享与心得，请关注公众号：Java架构社区&lt;br/&gt;可以扫左边二维码添加好友，邀请你加入Java架构社区微信群共同探讨技术&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1834889/202003/1834889-20200303074927076-1724862603.jpg&quot; alt=&quot;Java架构社区&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 May 2020 23:53:00 +0000</pubDate>
<dc:creator>清茶豆奶</dc:creator>
<og:description>概要 本篇主要介绍一个Term Vector的概念和基本使用方法。 term vector是什么？ 每次有document数据插入时，elasticsearch除了对document进行正排、倒排索引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huangying2124/p/12854592.html</dc:identifier>
</item>
<item>
<title>你真的会用Flutter日期类组件吗 - 老孟Flutter</title>
<link>http://www.cnblogs.com/mengqd/p/12854577.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengqd/p/12854577.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073650029-64800718.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Flutter系统提供了一些日期选择类组件，比如DayPicker、MonthPicker、YearPicker、showDatePicker、CupertinoDatePicker等，其中前4个为Material风格组件，最后一个为iOS风格组件。本文介绍了控件的基本用法及如何实现国际化，如果系统提供的国际化不满足你的需要，最后也介绍了如何实现自定义国际化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;daypicker&quot;&gt;DayPicker&lt;/h2&gt;
&lt;p&gt;显示给定月份的日期，并允许选择一天。这些天以矩形网格排列，一周的每一天都有一列。&lt;/p&gt;
&lt;p&gt;DayPicker有几个必填参数，分别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;selectedDate：选中的日期，选中的日期有圆形背景。&lt;/li&gt;
&lt;li&gt;currentDate：当前日期，文字高亮。&lt;/li&gt;
&lt;li&gt;onChanged：用户选择的日期发生变化时回调。&lt;/li&gt;
&lt;li&gt;firstDate：可选日期的开始值。&lt;/li&gt;
&lt;li&gt;lastDate：可选日期的结束值。&lt;/li&gt;
&lt;li&gt;displayedMonth：显示的月份&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;显示2020年5月，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;DateTime _selectedDate = DateTime.now();

DayPicker(
  selectedDate: _selectedDate,
  currentDate: DateTime.now(),
  onChanged: (date) {
    setState(() {
      _selectedDate = date;
    });
  },
  firstDate: DateTime(2020, 5, 1),
  lastDate: DateTime(2020, 5, 31),
  displayedMonth: DateTime(2020, 5),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073650408-463644501.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;selectableDayPredicate&lt;/code&gt;参数定义用户的可选日期，返回false表示不可选，例如只可选今天以前的日期：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;DayPicker(
  selectableDayPredicate: (date) {
    return date.difference(DateTime.now()).inMilliseconds &amp;lt; 0;
  },
  ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073650657-594345020.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;今天以后的日期全部为灰色，不可选状态。&lt;/p&gt;
&lt;h2 id=&quot;monthpicker&quot;&gt;MonthPicker&lt;/h2&gt;
&lt;p&gt;可选择的月份选择器，在顶部有一个滚动的月份列表，每个月份下面展示当前月份的天，本质上MonthPicker是滚动的月份列表+ DayPicker，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;DateTime _selectedDate = DateTime.now();
MonthPicker(
  selectedDate: _selectedDate,
  onChanged: (date) {
    setState(() {
      _selectedDate = date;
    });
  },
  firstDate: DateTime(2020, 1),
  lastDate: DateTime(2020, 12),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073651327-1654990834.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;属性和&lt;code&gt;DayPicker&lt;/code&gt;基本一致。&lt;/p&gt;
&lt;h2 id=&quot;yearpicker&quot;&gt;YearPicker&lt;/h2&gt;
&lt;p&gt;年份选择器，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;YearPicker(
  selectedDate: _selectedDate,
  onChanged: (date) {
    setState(() {
      _selectedDate = date;
    });
  },
  firstDate: DateTime(2000, 1),
  lastDate: DateTime(2020, 12),
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073651927-38025459.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;年份选择器和月份选择器略有不同，年份选择器并不包含当前年份下的月份。&lt;/p&gt;
&lt;p&gt;不管是YearPicker，还是MonthPicker、DayPicker，&quot;我们都很少直接使用&quot;，而是使用&lt;code&gt;showDatePicker&lt;/code&gt;，它会创建一个日期选择器对话框。个人觉得&lt;code&gt;showDatePicker&lt;/code&gt;的样式风格不是很符合国内的审美，我们可能更多的时候是使用YearPicker、MonthPicker和DayPicker自定义日期控件。&lt;/p&gt;
&lt;h2 id=&quot;showdatepicker&quot;&gt;showDatePicker&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;showDatePicker&lt;/code&gt;并不是一个新的控件，而是封装了YearPicker和MonthPicker，并进行了联动，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  onPressed: () async {
    var result = await showDatePicker(
        context: context,
        initialDate: DateTime.now(),
        firstDate: DateTime(2020),
        lastDate: DateTime(2030));
    print('$result');
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073652354-1510794466.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关参数介绍如下：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;initialDate&lt;/code&gt;初始化时间，通常情况下设置为当前时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;firstDate&lt;/code&gt;表示开始时间，不能选择此时间前面的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;lastDate&lt;/code&gt;表示结束时间，不能选择此时间之后的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;showDatePicker&lt;/code&gt;方法是Future方法，点击日期选择控件的确定按钮后，返回选择的日期。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;selectableDayPredicate&lt;/code&gt;参数定义用户的可选日期，返回false表示不可选，与DayPicker用法相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;builder&lt;/code&gt;参数可用于包装对话框窗口小部件以添加继承的窗口小部件，例如&lt;code&gt;Theme&lt;/code&gt;，设置深色主题用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;showDatePicker(
  builder: (context, child) {
    return Theme(
      data: ThemeData.dark(),
      child: child,
    );
  },
        ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073652661-855999450.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是Material风格的日期控件，下面介绍下iOS风格的日期控件。&lt;/p&gt;
&lt;h2 id=&quot;cupertinodatepicker&quot;&gt;CupertinoDatePicker&lt;/h2&gt;
&lt;p&gt;ios风格的日期选择器，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt; var _dateTime = DateTime.now();
CupertinoDatePicker(
  initialDateTime: _dateTime,
  onDateTimeChanged: (date) {
    setState(() {
      _dateTime = date;
    });
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073652861-270935256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mode&lt;/code&gt;参数设置日期的格式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;time：只显示时间，效果：&lt;code&gt;4 | 14 | PM&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;date：只显示日期，效果：&lt;code&gt;July | 13 | 2012&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;dateAndTime：时间和日期都显示，效果： &lt;code&gt;Fri Jul 13 | 4 | 14 | PM&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;设置最大日期和最小日期：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoDatePicker(
  minimumDate: DateTime.now().add(Duration(days: -1)),
  maximumDate: DateTime.now().add(Duration(days: 1)),
  ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073653139-225707677.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用24小时制：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoDatePicker(
  use24hFormat: true,
        ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;showtimepicker&quot;&gt;showTimePicker&lt;/h2&gt;
&lt;p&gt;时间选择器只能通过&lt;code&gt;showTimePicker&lt;/code&gt;的方式来调用，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;RaisedButton(
  onPressed: () async {
    showTimePicker(
        context: context, initialTime: TimeOfDay.now());
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073653372-1454309535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;builder&lt;/code&gt;参数用于控制子控件，可以向DatePicker一样设置深色主题，还可以设置其显示24小时，用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;showTimePicker(
    context: context,
    initialTime: TimeOfDay.now(),
    builder: (context, child) {
      return MediaQuery(
        data: MediaQuery.of(context)
            .copyWith(alwaysUse24HourFormat: true),
        child: child,
      );
    });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073653576-1602902627.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cupertinotimerpicker&quot;&gt;CupertinoTimerPicker&lt;/h2&gt;
&lt;p&gt;CupertinoTimerPicker 是ios风格的时间选择器，基本用法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoTimerPicker(
  onTimerDurationChanged: (Duration duration){
  },
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073653827-989264446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置只显示小时和分钟：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;CupertinoTimerPicker(
  mode: CupertinoTimerPickerMode.hm,
  ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，CupertinoTimerPicker显示0:0:0，设置显示当前时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;var now = DateTime.now();
return Container(
  height: 200,
  child: CupertinoTimerPicker(
    initialTimerDuration: Duration(hours: now.hour,minutes: now.minute,seconds: now.second),
    onTimerDurationChanged: (Duration duration) {},
  ),
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;国际化&quot;&gt;国际化&lt;/h2&gt;
&lt;p&gt;增加国际化处理，在pubspec.yaml添加支持：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;dependencies:
  flutter_localizations:
    sdk: flutter    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在顶级控件MaterialApp添加支持，具体信息可查&lt;a href=&quot;http://laomengit.com/flutter/widgets/MaterialApp.html&quot;&gt;MaterialApp控件&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;MaterialApp(
  localeListResolutionCallback:
          (List&amp;lt;Locale&amp;gt; locales, Iterable&amp;lt;Locale&amp;gt; supportedLocales) {
        return Locale('zh');
      },
      localeResolutionCallback:
          (Locale locale, Iterable&amp;lt;Locale&amp;gt; supportedLocales) {
        return Locale('zh');
      },
      localizationsDelegates: [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: [
        const Locale('zh', 'CH'),
        const Locale('en', 'US'),
      ],
  ...
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方式对所有日期控件都有效果，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073653992-779486944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073654215-2057605200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义国际化&quot;&gt;自定义国际化&lt;/h2&gt;
&lt;p&gt;我们对iOS风格的控件自定义国际化为例，新建新的类&lt;code&gt;MyLocalizationsDelegate&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class MyLocalizationsDelegate
    extends LocalizationsDelegate&amp;lt;CupertinoLocalizations&amp;gt; {
  const MyLocalizationsDelegate();

  @override
  bool isSupported(Locale locale) =&amp;gt; locale.languageCode == 'zh';

  @override
  Future&amp;lt;CupertinoLocalizations&amp;gt; load(Locale locale) =&amp;gt;
      ZhCupertinoLocalizations.load(locale);

  @override
  bool shouldReload(MyLocalizationsDelegate old) =&amp;gt; false;

  @override
  String toString() =&amp;gt; 'DefaultCupertinoLocalizations.delegate(zh)';
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ZhCupertinoLocalizations&lt;/code&gt;定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-dart&quot;&gt;class ZhCupertinoLocalizations implements CupertinoLocalizations {
  const ZhCupertinoLocalizations();

  static const List&amp;lt;String&amp;gt; _shortWeekdays = &amp;lt;String&amp;gt;[
    '自周一',
    '自周二',
    '自周三',
    '自周四',
    '自周五',
    '自周六',
    '自周日',
  ];

  static const List&amp;lt;String&amp;gt; _shortMonths = &amp;lt;String&amp;gt;[
    '1月',
    '2月',
    '3月',
    '4月',
    '5月',
    '6月',
    '7月',
    '8月',
    '9月',
    '10月',
    '11月',
    '12月',
  ];

  static const List&amp;lt;String&amp;gt; _months = &amp;lt;String&amp;gt;[
    '1月',
    '2月',
    '3月',
    '4月',
    '5月',
    '6月',
    '7月',
    '8月',
    '9月',
    '10月',
    '11月',
    '12月',
  ];

  @override
  String datePickerYear(int yearIndex) =&amp;gt; yearIndex.toString();

  @override
  String datePickerMonth(int monthIndex) =&amp;gt; _months[monthIndex - 1];

  @override
  String datePickerDayOfMonth(int dayIndex) =&amp;gt; dayIndex.toString();

  @override
  String datePickerHour(int hour) =&amp;gt; hour.toString();

  @override
  String datePickerHourSemanticsLabel(int hour) =&amp;gt; hour.toString() + &quot; o'clock&quot;;

  @override
  String datePickerMinute(int minute) =&amp;gt; minute.toString().padLeft(2, '0');

  @override
  String datePickerMinuteSemanticsLabel(int minute) {
    if (minute == 1) return '1 分';
    return minute.toString() + ' 分';
  }

  @override
  String datePickerMediumDate(DateTime date) {
    return '${_shortWeekdays[date.weekday - DateTime.monday]} '
        '${_shortMonths[date.month - DateTime.january]} '
        '${date.day.toString().padRight(2)}';
  }

  @override
  DatePickerDateOrder get datePickerDateOrder =&amp;gt; DatePickerDateOrder.mdy;

  @override
  DatePickerDateTimeOrder get datePickerDateTimeOrder =&amp;gt;
      DatePickerDateTimeOrder.date_time_dayPeriod;

  @override
  String get anteMeridiemAbbreviation =&amp;gt; '上午';

  @override
  String get postMeridiemAbbreviation =&amp;gt; '下午';

  @override
  String get todayLabel =&amp;gt; '今天';

  @override
  String get alertDialogLabel =&amp;gt; 'Alert';

  @override
  String timerPickerHour(int hour) =&amp;gt; hour.toString();

  @override
  String timerPickerMinute(int minute) =&amp;gt; minute.toString();

  @override
  String timerPickerSecond(int second) =&amp;gt; second.toString();

  @override
  String timerPickerHourLabel(int hour) =&amp;gt; hour == 1 ? '小时' : '小时';

  @override
  String timerPickerMinuteLabel(int minute) =&amp;gt; '分.';

  @override
  String timerPickerSecondLabel(int second) =&amp;gt; '秒.';

  @override
  String get cutButtonLabel =&amp;gt; '剪贴';

  @override
  String get copyButtonLabel =&amp;gt; '拷贝';

  @override
  String get pasteButtonLabel =&amp;gt; '黏贴';

  @override
  String get selectAllButtonLabel =&amp;gt; '选择全部';

  static Future&amp;lt;CupertinoLocalizations&amp;gt; load(Locale locale) {
    return SynchronousFuture&amp;lt;CupertinoLocalizations&amp;gt;(
        const ZhCupertinoLocalizations());
  }

  /// A [LocalizationsDelegate] that uses [DefaultCupertinoLocalizations.load]
  /// to create an instance of this class.
  static const LocalizationsDelegate&amp;lt;CupertinoLocalizations&amp;gt; delegate =
      MyLocalizationsDelegate();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意开始的属性&lt;code&gt;_shortWeekdays&lt;/code&gt;，这个属性表示星期几，故意写成'自周x'，为了和系统的区分，在根控件&lt;code&gt;MaterialApp&lt;/code&gt;的&lt;code&gt;localizationsDelegates&lt;/code&gt;属性中增加：&lt;code&gt;ZhCupertinoLocalizations.delegate&lt;/code&gt;，这个就是上面定义的国际化文件，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073654434-2046048862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：&lt;code&gt;ZhCupertinoLocalizations.delegate&lt;/code&gt;要放在&lt;code&gt;GlobalCupertinoLocalizations.delegate,&lt;/code&gt;的前面，系统加载顺序为从上到下。&lt;/p&gt;
&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073654625-315813178.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;交流&quot;&gt;交流&lt;/h2&gt;
&lt;p&gt;老孟Flutter博客地址（近200个控件用法）：&lt;a href=&quot;http://laomengit.com&quot;&gt;http://laomengit.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎加入Flutter交流群（微信：laomengit）、关注公众号【老孟Flutter】：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th/&gt;
&lt;th/&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073655035-1474804035.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/467322/202005/467322-20200509073655376-1973722488.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Fri, 08 May 2020 23:37:00 +0000</pubDate>
<dc:creator>老孟Flutter</dc:creator>
<og:description>Flutter系统提供了一些日期选择类组件，比如DayPicker、MonthPicker、YearPicker、showDatePicker、CupertinoDatePicker等，其中前4个为M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengqd/p/12854577.html</dc:identifier>
</item>
<item>
<title>经典卷积神经网络算法(2)：AlexNet - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/12854564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/12854564.html</guid>
<description>&lt;pre&gt;
&lt;span class=&quot;n&quot;&gt;model&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sequential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Conv2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;96&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;# input_shape=(in_shape[1],in_shape[2],in_shape[3]),&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'same'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kernel_initializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'uniform'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaxPooling2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pool_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Conv2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'same'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kernel_initializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'uniform'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaxPooling2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pool_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Conv2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;384&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'same'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kernel_initializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'uniform'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Conv2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;384&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'same'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kernel_initializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'uniform'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Conv2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'same'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kernel_initializer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'uniform'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaxPooling2D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pool_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strides&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Flatten&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2048&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dropout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2048&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'relu'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dropout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;layers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dense&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'softmax'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 08 May 2020 23:23:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>上文中实现了LeNet-5卷积网络，不可否认这是一个十分经典的网络结构，但是迫于种种复杂的现实场景限制，只能在一些领域应用，所以在接下来的10年间，卷积网络的锋芒一度被SVN算法覆盖，指导2012年A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/12854564.html</dc:identifier>
</item>
<item>
<title>聚合类型与POD类型 - jerry_fuyi</title>
<link>http://www.cnblogs.com/jerry-fuyi/p/12854248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jerry-fuyi/p/12854248.html</guid>
<description>&lt;p&gt;Lippman在《深度探索C++对象模型》的前言中写道：&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;I have heard a number of people over the years voice opinions similar to those of your colleagues. In every case, those opinions could be attributed to a lack of factual knowledge about the C++ language. Just last week I was chatting with an acquaintance who happens to work for an IC testing manufacturer, and he said they don't use C++ because &quot;it does things behind your back.&quot; When I pressed him, he said that he understood that C++ calls malloc() and free() without the programmer knowing it. This is of course not true. It is this sort of &quot;myth and legend&quot; that leads to opinions such as those held by your colleagues….&lt;/p&gt;
&lt;p&gt;Finding the right balance [between abstraction and pragmatism] requires knowledge, experience, and above all, thought. Using C++ well requires effort, but in my experience the returns on the invested effort can be quite high.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要想C++学得好、用得好，了解编译器在你背后做的事情是很有必要的。&lt;/p&gt;
&lt;p&gt;在C++中有一类特殊的类型，聚合类型，可以被看作是纯正的数据类型；聚合类型有一个子集，POD类型，C++可以通过POD类型与其他语言交互。C++11定义了标准的内存模型，POD的概念被淡化，取而代之的是平凡性与标准布局。&lt;/p&gt;
&lt;p&gt;在介绍这些类型分类之前，我们先来了解几种初始化。&lt;/p&gt;
&lt;h3 id=&quot;零初始化&quot;&gt;零初始化&lt;/h3&gt;
&lt;p&gt;零初始化，顾名思义，就是初始化成零。零是指该类型的零，可能不是每一位都是0的表示。&lt;/p&gt;
&lt;p&gt;在以下情形中，零初始化被执行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;code&gt;static T object;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;T();&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;T t = {};&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;T{};&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CharT array[n] = &quot;&quot;;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后一种指的是字符串字面量长度不足数组长度，剩余的部分被零初始化。&lt;/p&gt;
&lt;p&gt;零初始化和&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/constant_initialization&quot; target=&quot;_blank&quot;&gt;常量初始化&lt;/a&gt;与下面要讲的默认初始化和值初始化不在一个层次上，前者是静态存储期限对象的行为，后者是初始化器的行为。&lt;/p&gt;
&lt;h3 id=&quot;默认初始化&quot;&gt;默认初始化&lt;/h3&gt;
&lt;p&gt;当一个对象没有初始化器时，它被默认初始化，包括以下情形：&lt;/p&gt;
&lt;p&gt;默认初始化的效果是递归的：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于类类型，默认构造函数被调用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于数组类型，每个元素被默认初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其他情况，什么都不做，对象被初始化为非确定值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;依据上面的规则，全局作用域下的&lt;code&gt;int i;&lt;/code&gt;会被默认初始化，&lt;code&gt;i&lt;/code&gt;会拥有非确定值，然而我们又知道，作为一个静态存储期限的对象，&lt;code&gt;i&lt;/code&gt;的初始值是&lt;code&gt;0&lt;/code&gt;。事实上，&lt;code&gt;i&lt;/code&gt;先被零初始化，再被默认初始化，第二步中它的&lt;code&gt;0&lt;/code&gt;值保持不变。&lt;/p&gt;
&lt;p&gt;合成的默认构造函数对每个对象执行默认初始化，即使是显式&lt;code&gt;= default&lt;/code&gt;也一样，类中的非类类型对象的初始值是非确定的，参见&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/12070856.html&quot; target=&quot;_blank&quot;&gt;C++类成员默认初始值&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;访问一个非确定值的行为是未定义的，尽管那个对象可能只是一个普通整数，但如果较起真来，程序直接崩溃也是符合预期的。没有什么理由需要使用一个非确定值，如果需要随机数可以用专门的&lt;a href=&quot;https://www.cnblogs.com/jerry-fuyi/p/12728941.html&quot; target=&quot;_blank&quot;&gt;随机数设施&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;值初始化&quot;&gt;值初始化&lt;/h3&gt;
&lt;p&gt;当一个对象的初始化器为空时，它被值初始化，包括以下情形：&lt;/p&gt;
&lt;p&gt;列表初始化包括前三种把&lt;code&gt;()&lt;/code&gt;换成&lt;code&gt;{}&lt;/code&gt;，以及&lt;code&gt;T object{};&lt;/code&gt;，但后者没有对应的圆括号版本，因为&lt;code&gt;T object();&lt;/code&gt;是在声明一个函数。&lt;/p&gt;
&lt;p&gt;值初始化的行为是：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于有用户提供的默认构造函数的类型，执行默认初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;对于隐式声明或显式&lt;code&gt;= default&lt;/code&gt;默认构造函数的类型，先执行零初始化，再执行默认初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果是数组类型，对每个元素值初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则，零初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所谓用户提供的构造函数，是指有&lt;code&gt;{...}&lt;/code&gt;定义的，&lt;code&gt;= default&lt;/code&gt;和&lt;code&gt;= delete&lt;/code&gt;不在此列。&lt;/p&gt;
&lt;p&gt;值初始化的意义在于它可以提供确定的对象。标准库容器在以容器大小为参数的构造函数中，执行的初始化就是元素类型的值初始化。&lt;/p&gt;
&lt;h3 id=&quot;聚合类型&quot;&gt;聚合类型&lt;/h3&gt;
&lt;p&gt;聚合类型的概念在C++的发展中有过许多细节调整，这里先根据C++11标准讲解。&lt;/p&gt;
&lt;p&gt;聚合类型是数组类型，或满足以下条件的类类型：&lt;/p&gt;
&lt;p&gt;注意，这个定义不是递归的——聚合类型的成员完全可以是非聚合类型。&lt;/p&gt;
&lt;p&gt;初始化一个聚合类型的方式有：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;T object = {arg1, arg2, ...};&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;T object{arg1, arg2, ...};&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;C++14解禁了类内初始化；C++17允许基类，但不能是&lt;code&gt;private&lt;/code&gt;、&lt;code&gt;protected&lt;/code&gt;或&lt;code&gt;virtual&lt;/code&gt;，相应地构造函数不能有继承的，还加了一条不能有&lt;code&gt;explicit&lt;/code&gt;的；C++20又把构造函数的要求改回了没有用户声明的构造函数（&lt;code&gt;= default&lt;/code&gt;也不行了）。虽然每次修改都有道理，但是频繁修改语言核心真心头疼。至于C99中的指定元素名称的初始化，也在C++20中才进入标准。&lt;/p&gt;
&lt;p&gt;聚合初始化的行为是：&lt;/p&gt;
&lt;ul readability=&quot;6&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;所有基类、数组、非静态数据成员，按照在类中的出现顺序与数组下标的顺序，从初始化列表中的对应项拷贝初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;除了列表初始化以外，隐式转换都是允许的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;聚合初始化是递归的——如果初始化列表中有嵌套列表，对应项会被列表初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;不指定长度的数组可以从初始化列表推导长度，非静态数据成员除外；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;静态数据成员与未命名的位域跳过；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;初始化列表的长度不能超过需要初始化的基类与成员的数量；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果长度不够，包括初始化列表为空：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果有类内初始化，用它；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;否则按照列表初始化的规则，对于非类类型和非聚合类类型，值初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于聚合类型，递归使用该规则；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有对应初始化项的成员不能有引用类型的，否则报错；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于联合体，只有第一个成员被初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;学习聚合类型的规则，重在理解聚合初始化的行为——初始化要做的就是、只是拷贝构造每一个成员。这样就不难解释一些行为，比如，由于静态数据成员不是对象的一部分，因此在初始化时被跳过；虚函数和虚基类会引入vptr之类的东西，在初始化列表中没有体现，因而不被允许。这种思考方式在C++中是很实用的。&lt;/p&gt;
&lt;h3 id=&quot;pod类型&quot;&gt;POD类型&lt;/h3&gt;
&lt;p&gt;在C++11以前，POD（Plain Old Data）类型定义为下列类型之一：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;标量类型，包括算术类型（整数与浮点数）、指针、成员指针、枚举类型、&lt;code&gt;std::nullptr_t&lt;/code&gt;（C++11特性，只是为了给标量类型一个完整的定义）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;POD类型的数组类型；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类类型，满足：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li&gt;
&lt;p&gt;是聚合类型；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有非POD的非静态数据成员；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有引用类型的成员；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有用户提供的拷贝构造函数；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有用户提供的析构函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从C++11起，上述最后一大类修改为：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;是平凡类型（见下）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;是标准布局类型（见下）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有非POD的非静态数据成员、&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那我们先来看这两个定义。&lt;/p&gt;
&lt;h3 id=&quot;平凡&quot;&gt;平凡&lt;/h3&gt;
&lt;p&gt;一个平凡（trivial）的类型是这样的类型：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;符合TriviallyCopyable要求；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有一个或多个默认构造函数，每个都是平凡的（稍后解释）或删除的，至少有一个不是删除的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应类型特征（type trait）&lt;code&gt;is_trivial&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;TriviallyCopyable的要求是指：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个拷贝构造函数都是平凡的或删除的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个移动构造函数都是平凡的或删除的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个拷贝赋值运算符都是平凡的或删除的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;每个移动赋值运算符都是平凡的或删除的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;析构函数是平凡的、非删除的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;TriviallyCopyable类型的数组仍然是TriviallyCopyable的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里有很多平凡，我不打算一一列出其要求，它们大致上讲了同一件事：&lt;/p&gt;
&lt;p&gt;平凡的构造函数还有一条：没有类内初始化。&lt;/p&gt;
&lt;h3 id=&quot;标准布局&quot;&gt;标准布局&lt;/h3&gt;
&lt;p&gt;平凡规定了对象控制行为，标准布局（StandardLayoutType，&lt;code&gt;is_standard_layout&lt;/code&gt;）则规定了对象模型：&lt;/p&gt;
&lt;ul readability=&quot;4.4208675263775&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;所有非静态数据成员都有相同的访问控制等级，即同为&lt;code&gt;public&lt;/code&gt;、同为&lt;code&gt;protected&lt;/code&gt;或同为&lt;code&gt;private&lt;/code&gt;（这是因为，编译器有权把相同访问等级的成员安排在一起，那样会破坏布局）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有虚拟；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;没有非静态数据成员是引用类型；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对基类和非静态数据成员类型递归要求StandardLayoutType；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不能有同一个基类被继承两次，即所谓菱形继承（&lt;code&gt;virtual&lt;/code&gt;早就已经否决了）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;继承链中只有一个类型有非静态数据成员；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.95562130177515&quot;&gt;
&lt;p&gt;为了不与&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/ebo&quot; target=&quot;_blank&quot;&gt;空基类优化&lt;/a&gt;冲突，基类不能有以下类型：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于非联合类型，第一个非静态数据成员的类型；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于联合类型，所有非静态成员类型；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于数组类型，其元素类型；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;以及这些类型递归调用这条规则产生的类型，有点计算LL(1)分析算法中FIRST集的味道。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在可以回到POD类型了。POD是特殊的类型，它有许多非POD类型不具有的性质：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;完全与C兼容，但是仍然可以有成员函数；POD类型标准到甚至可以与其他语言兼容；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可以用&lt;code&gt;std::memcpy&lt;/code&gt;拷贝（对于非POD类型，即使满足TriviallyCopyable，用&lt;code&gt;std::memcpy&lt;/code&gt;拷贝的行为也是未定义的）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;有更长的生命周期，从资源获取到资源释放，而非POD类型的是从构造函数结束到析构函数结束；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;语句不能跳过变量的定义，但POD类型的是允许的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;POD类型对象的前部没有填充字节，即对象指针与第一个成员的指针是相等的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 08 May 2020 17:32:00 +0000</pubDate>
<dc:creator>jerry_fuyi</dc:creator>
<og:description>Lippman在《深度探索C++对象模型》的前言中写道： I have heard a number of people over the years voice opinions similar t</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jerry-fuyi/p/12854248.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Blazor 初探之 Blazor WebAssembly - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/try-blazorwebassembly.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/try-blazorwebassembly.html</guid>
<description>&lt;p&gt;最近Blazor热度很高，传说马上就要发布正式版了，做为微软脑残粉，赶紧也来凑个热闹，学习一下。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;338.60180109632&quot;&gt;
&lt;p&gt;最近Blazor热度很高，传说马上就要发布正式版了，做为微软脑残粉，赶紧也来凑个热闹，学习一下。&lt;/p&gt;
&lt;h2 id=&quot;blazor&quot;&gt;Blazor&lt;/h2&gt;
&lt;p&gt;Blazor是微软在ASP.NET Core框架下开发的一种全新的Web开发框架。Blazor利用WebAssembly使得开发者可以抛开JavaScript而使用优雅的C#来开发web单页应用。微软利用WebAssembly在浏览器里实现了一个.NET Runtime，任何.NET STANDARD 2.1的代码都可以在浏览器上运行，真的是屌炸了。Blazor强化了Razor模板引擎，并且借鉴了当前热门前端框架的优点，比如双向绑定技术，组件化，使前端开发敏捷高效。如果你对NG，VUE等框架熟悉那么很容易找到其中的共通点。&lt;/p&gt;
&lt;h2 id=&quot;blazor-webassembly&quot;&gt;Blazor WebAssembly&lt;/h2&gt;
&lt;p&gt;Blazor 技术又分两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Blazor WebAssembly&lt;/li&gt;
&lt;li&gt;Blazor Server&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Blazor WebAssembly 是真正的SPA，页面的渲染在前端实现，可以实现真正的前后端分离设计。而Blazor Server可以认为是前者的服务端渲染版本，它使用SignalR实现了客户端的实时通讯，它的计算跟渲染都在服务端处理。本次咱先研究WebAssembly技术，因为我觉得它的应用前景可能更适合一般项目。废话不多说，直接开干吧，我们的目标还是完成一个标准的对学员进行CRUD的并且前后端分离的小项目。&lt;/p&gt;
&lt;h2 id=&quot;安装blazor-webassembly模板&quot;&gt;安装Blazor WebAssembly模板&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;dotnet new -i Microsoft.AspNetCore.Components.WebAssembly.Templates::3.2.0-preview5.20216.8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为Blzor WebAssembly还在预览阶段所以要手工安装模板，在控制台运行以上命令来安装最新的模板。&lt;/p&gt;
&lt;h2 id=&quot;新建blazor-webassembly项目&quot;&gt;新建Blazor WebAssembly项目&lt;/h2&gt;
&lt;p&gt;打开vs找到Blazor的项目模板，就是那个特别像火影标志的那个图标。新建一个项目名叫BlazorWebAssemblyApp。点下一步，这里会让选是Blazor Server还是Blazor WebAssembly，不要选错了。&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/YmBx8P&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/07/YmBx8P.md.png&quot; alt=&quot;YmBx8P.md.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;先看一下项目结构：&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/YmrQQf&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/07/YmrQQf.png&quot; alt=&quot;YmrQQf.png&quot;/&gt;&lt;/a&gt;&lt;br/&gt;Blazor Webassembly的项目结构比较简单，跟Razor Page的项目结构比较类似。&lt;/p&gt;
&lt;h2 id=&quot;新建aspnet-core-webapi项目&quot;&gt;新建ASP.NET CORE WebApi项目&lt;/h2&gt;
&lt;p&gt;我们的目标是打造一个前后端分离的项目，那么自然还要建一个Api项目。并且这个项目对外提供一个Student的Restful API。在vs里新建ASP.NET CORE WebApi项目，名为BlazorWebassemblyApisite。&lt;br/&gt;为了演示方便，使用静态变量实现一个StudentRepository。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Student
    {
        public int Id { get; set; }
        public string Name { get; set; }

        public string Class { get; set; }

        public int Age { get; set; }

        public string Sex { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;    public interface IStudentRepository
    {
        List&amp;lt;Student&amp;gt; List();

        Student Get(int id);

        bool Add(Student student);

        bool Update(Student student);

        bool Delete(int id);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; public class StudentRepository : IStudentRepository
    {
        private static List&amp;lt;Student&amp;gt; Students = new List&amp;lt;Student&amp;gt; {
                new Student{ Id=1, Name=&quot;小红&quot;, Age=10, Class=&quot;1班&quot;, Sex=&quot;女&quot;},
                new Student{ Id=2, Name=&quot;小明&quot;, Age=11, Class=&quot;2班&quot;, Sex=&quot;男&quot;},
                new Student{ Id=3, Name=&quot;小强&quot;, Age=12, Class=&quot;3班&quot;, Sex=&quot;男&quot;}
        };

        public bool Add(Student student)
        {
            Students.Add(student);

            return true;
        }

        public bool Delete(int id)
        {
            var stu = Students.FirstOrDefault(s =&amp;gt; s.Id == id);
            if (stu != null)
            {
                Students.Remove(stu);
            }

            return true;
        }

        public Student Get(int id)
        {
            return Students.FirstOrDefault(s =&amp;gt; s.Id == id);
        }

        public List&amp;lt;Student&amp;gt; List()
        {
            return Students;
        }

        public bool Update(Student student)
        {
            var stu = Students.FirstOrDefault(s =&amp;gt; s.Id == student.Id);
            if (stu != null)
            {
                Students.Remove(stu);
            }

            Students.Add(student);
            return true;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在Startup里注册这个Repository：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddScoped&amp;lt;IStudentRepository, StudentRepository&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现StudentController用来暴露API：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ApiController]
    [Route(&quot;[controller]&quot;)]
    public class StudentController : ControllerBase
    {
        private IStudentRepository _studentRepository;
        public StudentController(IStudentRepository studentRepository)
        {
            _studentRepository = studentRepository;
        }

        [HttpGet]
        public List&amp;lt;Student&amp;gt; Get()
        {
            return _studentRepository.List();
        }

        [HttpGet(&quot;{id}&quot;)]
        public Student Get(int id)
        {
            return _studentRepository.Get(id);
        }

        [HttpPost]
        public Student Post(Student model)
        {
            _studentRepository.Add(model);

            return model;
        }

        [HttpPut]
        public Student Put(Student model)
        {
            _studentRepository.Update(model);

            return model;
        }

        [HttpDelete(&quot;{id}&quot;)]
        public void Delete(int id)
        {
            _studentRepository.Delete(id);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为我们的前后端项目会分两个网址部署，所以肯定需要配置CORS的问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; app.UseCors(config =&amp;gt;
            {
                config.AllowAnyOrigin();
                config.AllowAnyMethod();
                config.AllowAnyHeader();
            });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们的后端API网站就完成了，接来下就是真正的Blazor环节了。&lt;/p&gt;
&lt;h2 id=&quot;配置httpclient与注入&quot;&gt;配置HttpClient与注入&lt;/h2&gt;
&lt;p&gt;让我们切换回BlazorWebAssemblyApp项目。我们的Blazor项目需要通过Http与API站点进行通信，所以肯定需要一个访问Http的类库。如果是JavaScript我们平时使用如axios等库，但是Blazor可以使用C#实现的HttpClient，在前端由C#发起Http请求，Cool！当然最后HttpClient发出的请求会还是会转换为浏览器的Fetch请求。Blazor项目支持依赖注入，这个用法跟ASP.NET Core项目的体验是一致的，通过IServiceCollection配置注入的生命周期：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;builder.Services.AddTransient(sp =&amp;gt; new HttpClient { BaseAddress = new Uri(&quot;https://localhost:6001&quot;) });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Blazor的注入同样分Transient、Scope、Singleton等生命周期。这里我们注册HttpClient为Transient，并且配置baseAddress为https://localhost:6001，这是ApiSite的地址。&lt;/p&gt;
&lt;h2 id=&quot;实现学生列表（studentlist）&quot;&gt;实现学生列表（student/list）&lt;/h2&gt;
&lt;p&gt;因为新建成的项目会自动生成一些页面，为了减少干扰，先删掉点内容。&lt;br/&gt;简化MainLayout.razor，删除一些不必要的东西：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@inherits LayoutComponentBase

&amp;lt;div class=&quot;main&quot;&amp;gt;
    &amp;lt;div class=&quot;content px-4&quot;&amp;gt;
        @Body
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除Index.razor的内容，就留一个page指令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建Model文件夹，用来存放Student模型，这里其实可以把Api网站的Student模型提取出来，作为公共的定义模块，为了简单就直接定义一个一模一样的吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class Student
    {
        public int Id { get; set; }
        public string Name { get; set; }

        public string Class { get; set; }

        public int Age { get; set; }

        public string Sex { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新建一个student文件夹，在这个文件夹内新建一个List.razor文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/student/list&quot;

@using BlazorWebAssemblyApp.Model

@inject HttpClient Http

&amp;lt;h1&amp;gt;List&amp;lt;/h1&amp;gt;

&amp;lt;p class=&quot;text-right&quot;&amp;gt;
    &amp;lt;a class=&quot;btn btn-primary&quot; href=&quot;/student/add&quot;&amp;gt;Add&amp;lt;/a&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;table class=&quot;table&quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th&amp;gt;Id&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;Age&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;Sex&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;Class&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    @if (_stutdents != null)
    {
        foreach (var item in _stutdents)
        {
            &amp;lt;tr&amp;gt;
                &amp;lt;td&amp;gt;@item.Id&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;@item.Name&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;@item.Age&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;@item.Sex&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;@item.Class&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;
                    &amp;lt;a class=&quot;btn btn-primary&quot; href=&quot;/student/modify/@item.Id&quot;&amp;gt;修改&amp;lt;/a&amp;gt;
                    &amp;lt;a class=&quot;btn btn-danger&quot; href=&quot;/student/delete/@item.Id&quot;&amp;gt;删除&amp;lt;/a&amp;gt;
                &amp;lt;/td&amp;gt;
            &amp;lt;/tr&amp;gt;
        }
    }

&amp;lt;/table&amp;gt;

@code {
    private List&amp;lt;Student&amp;gt; _stutdents;

    protected override async Task OnInitializedAsync()
    {
        var students = await Http.GetFromJsonAsync&amp;lt;List&amp;lt;Student&amp;gt;&amp;gt;(&quot;/student&quot;);
        this._stutdents = students;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个文件大体上看跟RazorPages的页面差不多，Html主体使用razor语法渲染。但是还是有很大的不同，让我们从头开始一个个的解释:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/student/list&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@page指令指示这个页面的路由，当用户访问/student/list时就会路由到这个页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@using BlazorWebAssemblyApp.Model
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@using指令不多说了，引用namespace，这个跟Razor Pages是一样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@inject HttpClient Http
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@inject指令从字面看就很容易理解，注入。上面的意思就是注入HttpClient对象，并且命名为Http。后面就可以使用这个Http对象了，当然前提是在Program里注册好。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@code {
    private List&amp;lt;Student&amp;gt; _stutdents;

    protected override async Task OnInitializedAsync()
    {
        var students = await Http.GetFromJsonAsync&amp;lt;List&amp;lt;Student&amp;gt;&amp;gt;(&quot;/student&quot;);
        this._stutdents = students;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@code指令指示这个scope里的内容为C#代码。虽然没有明确定义为class，但是显然这个代码块最后会被编译成一个类。这个类里的变量可以作为razor模板的数据源，可以进行绑定或者for循环。OnInitializedAsync方法为初始化方法，可以在这里处理一些初始化工作，比如我们这里就是通过一次Http请求获取学生的列表数据。如果是同步方法请使用OnInitialized。这个文件的结构看起是不是很像VUE的单文件组件，笑哭。&lt;br/&gt;让我们运行一下吧：&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/YmIGvQ&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/07/YmIGvQ.md.png&quot; alt=&quot;YmIGvQ.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现新增学生页面（studentadd）&quot;&gt;实现新增学生页面（/student/add）&lt;/h2&gt;
&lt;p&gt;当点击列表页面的Add按钮的时候，需要导航至新增页面，导航直接使用a标签没有任何问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   &amp;lt;a class=&quot;btn btn-primary&quot; href=&quot;/student/add&quot;&amp;gt;Add&amp;lt;/a&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;考虑到后面还有编辑页面，新增跟编辑页面整体是一样的，只是后台处理的逻辑不一样。既然Blazor支持组件化，那么这种重复的东西既然是封装为一个组件为好了。&lt;/p&gt;
&lt;h3 id=&quot;封装edit组件&quot;&gt;封装Edit组件&lt;/h3&gt;
&lt;p&gt;我们把对学生信息编辑的功能抽象成一个组件叫做Edit。在student文件夹下新建一个component文件夹，在文件夹内新建Edit.razor文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@using BlazorWebAssemblyApp.Model

&amp;lt;div&amp;gt;
    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
        &amp;lt;label&amp;gt;Id&amp;lt;/label&amp;gt;
        &amp;lt;input @bind=&quot;Student.Id&quot; class=&quot;form-control&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
        &amp;lt;label&amp;gt;Name&amp;lt;/label&amp;gt;
        &amp;lt;input @bind=&quot;Student.Name&quot; class=&quot;form-control&quot;/&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
        &amp;lt;label&amp;gt;Age&amp;lt;/label&amp;gt;
        &amp;lt;input @bind=&quot;Student.Age&quot; class=&quot;form-control&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
        &amp;lt;label&amp;gt;Class&amp;lt;/label&amp;gt;
        &amp;lt;input @bind=&quot;Student.Class&quot; class=&quot;form-control&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;form-group&quot;&amp;gt;
        &amp;lt;label&amp;gt;Sex&amp;lt;/label&amp;gt;
        &amp;lt;input @bind=&quot;Student.Sex&quot; class=&quot;form-control&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;

     &amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;TrySave&quot;&amp;gt;
         保存
     &amp;lt;/button&amp;gt;

&amp;lt;/div&amp;gt;

@code{

    [Parameter]
    public Student Student { get; set; }
    [Parameter]
    public EventCallback&amp;lt;Student&amp;gt; OnSaveCallback { get; set; }

    protected override Task OnInitializedAsync()
    {
        if (Student == null)
        {
            Student = new Student();
        }

        return Task.CompletedTask;
    }

    private void TrySave()
    {
        OnSaveCallback.InvokeAsync(Student);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续解释下这个文件:&lt;/p&gt;
&lt;h4 id=&quot;数据绑定&quot;&gt;数据绑定&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;input @bind=&quot;Student.Id&quot; class=&quot;form-control&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用@bind指令可以跟某个对象实现的属性实现双向绑定。@bind指令本质上是通过对value跟onchange这个属性的绑定配合来实现双向绑定，这个套路怎么那么熟悉？对了VUE也是这么干的，笑哭。@bind=&quot;Student.Id&quot;翻译过来等效于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;input value=&quot;@Student.Id&quot;
    @onchange=&quot;@((ChangeEventArgs __e) =&amp;gt; Student.Id = 
        __e.Value.ToString())&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;事件绑定&quot;&gt;事件绑定&lt;/h4&gt;
&lt;p&gt;除了对数据的绑定，Blazor还支持对事件的绑定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     &amp;lt;button class=&quot;btn btn-primary&quot; @onclick=&quot;TrySave&quot;&amp;gt;
         保存
     &amp;lt;/button&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@onclick=&quot;TrySave&quot; 表示这个button的click事件指向TrySave这个方法。&lt;/p&gt;
&lt;h4 id=&quot;组件属性&quot;&gt;组件属性&lt;/h4&gt;
&lt;p&gt;我们封装组件经常对外暴露属性，以便接受外部传入的数据，比如我们这个Edit组件就需要外部传入一个Student对象才能正常工作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    [Parameter]
    public Student Student { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在@code代码里的属性上打上[Parameter]标签。这里叫做Parameter，估计是为了跟C#里的属性（property）进行区分。这样的话，这个属性就可以接受父组件的传参，注意这个属性是单项数据流，组件内对Student修改并不会修改外部组件的数据源，这个也很VUE啊，笑哭。&lt;/p&gt;
&lt;h4 id=&quot;组件事件&quot;&gt;组件事件&lt;/h4&gt;
&lt;p&gt;我们除了需要对外暴露属性，常常还需要对外暴露事件，用来通知外部组件。当外部组件接受到事件的时候可以进行相应的处理。比如这个Edit组件点击保存的时候并没有进行真正的保存操作，而是对外抛一个事件，当外部组件接受这个事件的时候进行真正的处理，比如是调用新增API还是更新API。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Parameter]
    public EventCallback&amp;lt;Student&amp;gt; OnSaveCallback { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在@code代码里的EventCallback事件上打上[Parameter]标签。这样外部组件就可以注册这个事件了。当我们在这个组件上点击保存的时候激发这个事件,并且把修改过的Student对象传递出去。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; OnSaveCallback.InvokeAsync(Student);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用edit组件&quot;&gt;使用Edit组件&lt;/h3&gt;
&lt;p&gt;Edit组件封装完成了，让我们开始使用它。新建一个Add.razor文件，并且在这里使用Edit组件。组件的使用跟VUE等一样，使用一个自定义的Tag插入到html的里。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/student/add&quot;

@using BlazorWebAssemblyApp.Model

@inject HttpClient Http
@inject NavigationManager NavManager

&amp;lt;h1&amp;gt;Add&amp;lt;/h1&amp;gt;

&amp;lt;Edit OnSaveCallback=&quot;OnSaveAsync&quot;&amp;gt;&amp;lt;/Edit&amp;gt;

&amp;lt;div class=&quot;text-danger&quot;&amp;gt;
    @_errmsg
&amp;lt;/div&amp;gt;

@code {

    private Student Student { get; set; }

    private string _errmsg;

    protected override Task OnInitializedAsync()
    {
        return base.OnInitializedAsync();
    }

    private async Task OnSaveAsync(Student student)
    {
        Student = student;

        var result = await Http.PostAsJsonAsync(&quot;/student&quot;, Student);

        if (result.IsSuccessStatusCode)
        {
            NavManager.NavigateTo(&quot;/student/list&quot;);
        }
        else
        {
            _errmsg = &quot;保存失败&quot;;
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Add.razor的逻辑很简单，接受Edit组件的保存事件，然后把Student通过Http提交到后台。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Edit OnSaveCallback=&quot;OnSaveAsync&quot;&amp;gt;&amp;lt;/Edit&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过OnSaveCallback=&quot;OnSaveAsync&quot;设置Edit组件的OnSaveCallback事件回调为OnSaveAsync方法。&lt;br/&gt;当我们保存功能的时候，需要跳转到列表页面。Blazor提供了一个简单的导航框架：NavigationManager。NavigationManager是默认注册到IoC容器的，所以可以直接使用@inject注入到需要的地方：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@inject NavigationManager NavManager
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用NavigateTo方法进行页面跳转。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NavManager.NavigateTo(&quot;/student/list&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们运行一下看看吧：&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/YnDgXT&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YnDgXT.md.png&quot; alt=&quot;YnDgXT.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现修改学生信息页面（studentmodify）&quot;&gt;实现修改学生信息页面（/student/modify）&lt;/h2&gt;
&lt;p&gt;修改界面相对新增页面会多涉及一个知识点，url传参。当我们需要修改学生信息的时候，需要传递一个id参数过去，告诉页面需要修改哪一个学生。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/student/modify/{Id:int}&quot;

@using BlazorWebAssemblyApp.Model
@using BlazorWebAssemblyApp.Data

@inject HttpClient Http
@inject NavigationManager NavManager
@inject Store Store

&amp;lt;h1&amp;gt;Modify&amp;lt;/h1&amp;gt;

&amp;lt;Edit Student=&quot;Student&quot; OnSaveCallback=&quot;OnSaveAsync&quot;&amp;gt;&amp;lt;/Edit&amp;gt;

&amp;lt;div class=&quot;text-danger&quot;&amp;gt;
    @_errmsg
&amp;lt;/div&amp;gt;

@code {
    [Parameter]
    public int Id { get; set; }

    private Student Student { get; set; }

    private string _errmsg;

    protected override void OnInitialized()
    {
        Student = Store.GetStudentById(Id);
    }

    private async Task OnSaveAsync(Student student)
    {
        Student = student;

        var result = await Http.PutAsJsonAsync(&quot;/student&quot;, Student);

        if (result.IsSuccessStatusCode)
        {
            NavManager.NavigateTo(&quot;/student/list&quot;);
        }
        else
        {
            _errmsg = &quot;保存失败&quot;;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;@page指令配置的路由模板可以支持参数匹配&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/student/modify/{Id:int}&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在列表页面使用a标签进行跳转，url组合成/student/modify/1样式,其中1会匹配给属性Id，并且这里限制了Id的类型为int。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;Edit Student=&quot;Student&quot; OnSaveCallback=&quot;OnSaveAsync&quot;&amp;gt;&amp;lt;/Edit&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对Edit组件的使用，修改页面跟新增页面不同的是，修改页面需要传递一个Student对象到Edit组件内部，以便显示学员信息。&lt;/p&gt;
&lt;h3 id=&quot;实现一个store&quot;&gt;实现一个Store&lt;/h3&gt;
&lt;p&gt;修改页面显然需要显示学生当前的信息。我们通过url传递过来的参数只有id，那么需要一次Http请求去后台获取学生信息，这没什么问题。但是如果是SPA应用，其实学生的信息本身已经在列表页面了，对于那些不是高频更新的数据，我们没有必要每次都去数据库里获取最新的数据，况且即使你从数据库里获取到了最新的数据，也可能在你修改的过程中被别人修改。因为SPA跟传统的Web项目不同，它可以完整的维护状态，所以如果我们把列表的数据存起来，那么其他地方可以很方便直接在内存里查询到，高效又便捷。通常使用Angularjs的时候这种场景会使用一个单例的Service来完成。这里我也简单使用C#来实现一个Service来存储页面的数据，名称就借鉴一下VUE的Vuex吧，叫Store。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public class Store
    {
        private  List&amp;lt;Student&amp;gt; _students;

        public  void SetStudents(List&amp;lt;Student&amp;gt; list)
        {
            _students = list;
        }

        public List&amp;lt;Student&amp;gt; GetStudents()
        {
            return _students;
        }

        public  Student GetStudentById(int id)
        {
            var stu = _students?.FirstOrDefault(s =&amp;gt; s.Id == id);

            return stu;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;builder.Services.AddSingleton&amp;lt;Store&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个service很简单，就是一个简单的class。使用List来存储学生列表信息，对外提供几个Set，Get方法来存储数据跟获取数据。这里我并没有手工实现为单例，直接在框架的容器上注册为单例生命周期。&lt;/p&gt;
&lt;h3 id=&quot;改造列表页面&quot;&gt;改造列表页面&lt;/h3&gt;
&lt;p&gt;现在我们有了Store，所以当列表获取到数据后需要存储到Store里，这样我们在修改页面或者其他地方就能根据id直接获取数据了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@inject Store Store

@code {
    private List&amp;lt;Student&amp;gt; _stutdents =&amp;gt; Store.GetStudents();

    protected override async Task OnInitializedAsync()
    {
        var students = await Http.GetFromJsonAsync&amp;lt;List&amp;lt;Student&amp;gt;&amp;gt;(&quot;/student&quot;);
        Store.SetStudents(students);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的改造完成了，运行一下看看吧：&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/YnTaRK&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YnTaRK.md.png&quot; alt=&quot;YnTaRK.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现删除页面（studentdelete）&quot;&gt;实现删除页面（/student/delete）&lt;/h2&gt;
&lt;p&gt;删除页面比较简单，使用前面的知识点轻松可以搞定。同样通过Url传递一个Id到删除页面，页面上获取学生数据后进行显示，并且提示用户是否确定删除这个学生信息。如果点击确定就调用删除API进行删除操作，如果点击取消则回退到前一页。为了增加乐趣，这里会增加C#跟JavaScript交互的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@page &quot;/student/delete/{id:int}&quot;

@using BlazorWebAssemblyApp.Model
@using BlazorWebAssemblyApp.Data

@inject HttpClient Http
@inject Store Store
@inject NavigationManager NavManager
@inject IJSRuntime JSRuntime

&amp;lt;h1&amp;gt;Delete&amp;lt;/h1&amp;gt;

&amp;lt;h3&amp;gt;
    确定删除（@Student.Id）@Student.Name ？
&amp;lt;/h3&amp;gt;

&amp;lt;button class=&quot;btn btn-danger&quot; @onclick=&quot;OnDeleteAsync&quot;&amp;gt;
    删除
&amp;lt;/button&amp;gt;

&amp;lt;button class=&quot;btn btn-info&quot; @onclick=&quot;OnCancel&quot;&amp;gt;取消&amp;lt;/button&amp;gt;

@code {
    [Parameter]
    public int Id { get; set; }

    private Student Student { get; set; }

    protected override void OnInitialized()
    {
        Student = Store.GetStudentById(Id);
    }

    private async Task OnDeleteAsync()
    {
        var result = await Http.DeleteAsync(&quot;/student/&quot; + Id);
        if (result.IsSuccessStatusCode)
        {
            NavManager.NavigateTo(&quot;/student/list&quot;);
        }
    }

    private void OnCancel()
    {
        JSRuntime.InvokeVoidAsync(&quot;history.back&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;ijsruntime&quot;&gt;IJSRuntime&lt;/h3&gt;
&lt;p&gt;当用户点击取消的时候我们需要回退到前一个页面，但是Blazor的NavigationManager并没有提供GoBack这种操作。这个我实在是想不明白，不管是WPF的导航框架、还是VUE的路由服务都有这种机制，以至于我还得通过JavaScript的能力去调用浏览器的原生后退功能来实现。Blazor中想要跟JavaScript交互需要注入JSRuntime对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JSRuntime.InvokeVoidAsync(&quot;history.back&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在取消按钮的事件代码里调用以上代码，这样就能顺利后退了。&lt;br/&gt;&lt;a href=&quot;https://imgchr.com/i/YuZE5R&quot;&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/05/08/YuZE5R.md.png&quot; alt=&quot;YuZE5R.md.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过以上，我们使用Blazor实现了一个简单的前后端分离的SPA。总体涉及了Blazor的几个重要知识点，比如：数据绑定，事件处理，封装组件，JavaScript交互等。其中每个知识点都可以再深入展开来写一篇。我们使用Blazor，在几乎没用JavaScript的情况下顺利的完成了一个SPA，总体感觉还是比较良好的。虽然不用JavaScript，但是显然它借鉴了热门JavaScript框架的一些特点，如果你有一点前端基础跟.NET基础很容易就能上手。但是，我不想在这神吹Blazor，毕竟它也没有到让人惊艳的地步，比如我熟悉Angular，熟悉VUE，说真的，目前来说，我没有什么动力切换到Blazor上来。如果Blazor早出现那么几年，或许一切都不一样了。但是，又要但是。。。但是我还是会学习Blazor，就像我当年学习Silverlight一样。没错，我就是那个被微软伤害两次（Silverlight，Windows Phone）依然待他如初恋的男人，笑哭。微软的东西虽然不流行，但是不代表它不先进，有的时候或许是过于先进。比如MVVM、双向绑定、前后端分离，这些概念都是当年Silverlight RIA应用早就有的。虽然Silverlight后来黄了，但是它里面的一些设计理念，开发模式并不落后，甚至是超前的。这些经验对后来我学习Angularjs，VUE来说有非常大的帮助，学起来得心应手，因为套路都是那个套路。所以哪天说不定WebAssembly大行其道，Blazor又成了开山鼻祖，学习它的经验一定是有用的。&lt;/p&gt;
&lt;p&gt;最后demo的源码：&lt;a href=&quot;https://github.com/kklldog/BlazorWebAssemblyAppDemo&quot;&gt;BlazorWebAssemblyAppDemo&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 08 May 2020 16:18:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>最近Blazor热度很高，传说马上就要发布正式版了，做为微软脑残粉，赶紧也来凑个热闹，学习一下。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/try-blazorwebassembly.html</dc:identifier>
</item>
<item>
<title>Spring Boot 整合 Apache Dubbo - 风尘博客</title>
<link>http://www.cnblogs.com/vandusty/p/12853973.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vandusty/p/12853973.html</guid>
<description>&lt;p&gt;&lt;code&gt;Apache Dubbo&lt;/code&gt;是一款高性能、轻量级的开源 &lt;code&gt;Java&lt;/code&gt; &lt;code&gt;RPC&lt;/code&gt; 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。&lt;/p&gt;
&lt;blockquote readability=&quot;5.1017964071856&quot;&gt;
&lt;p&gt;注意，是 &lt;code&gt;Apache Dubbo&lt;/code&gt;，不再是 &lt;code&gt;Alibaba Dubbo&lt;/code&gt;。简单来说就是 &lt;code&gt;Alibaba&lt;/code&gt; 将 &lt;code&gt;Dubbo&lt;/code&gt; 移交给 &lt;code&gt;Apache&lt;/code&gt; 开源社区进行维护。参见 &lt;a href=&quot;https://github.com/apache/dubbo-spring-boot-project/blob/master/README_CN.md&quot;&gt;dubbo-spring-boot-project&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_42036952/article/details/89473680&quot;&gt;Spring Boot 系列：整合 Alibaba Dubbo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、本文示例说明&quot;&gt;一、本文示例说明&lt;/h2&gt;
&lt;h3 id=&quot;11-框架版本&quot;&gt;1.1 框架版本&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Dubbo&lt;/code&gt; 版本&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.7.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Spring Boot&lt;/code&gt; 版本&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;parent&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1.1.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;relativePath/&amp;gt;
&amp;lt;/parent&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;12-模块关系&quot;&gt;1.2 模块关系&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;根工程 &lt;code&gt;order&lt;/code&gt;：管理工程信息；&lt;/li&gt;
&lt;li&gt;子工程 &lt;code&gt;order-api&lt;/code&gt;：定义&lt;code&gt;RPC&lt;/code&gt;服务的接口、参数以及响应结果的结果集；&lt;/li&gt;
&lt;li&gt;子工程 &lt;code&gt;order-provider&lt;/code&gt;：&lt;code&gt;RPC&lt;/code&gt;服务的提供端；&lt;/li&gt;
&lt;li&gt;子工程 &lt;code&gt;order-consumer&lt;/code&gt;：&lt;code&gt;RPC&lt;/code&gt;服务的消费端，实际开发过程中实际情况是其它服务的调用该订单&lt;code&gt;RPC&lt;/code&gt;服务&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、根工程&quot;&gt;二、根工程&lt;/h2&gt;
&lt;h3 id=&quot;21-创建项目-order&quot;&gt;2.1 创建项目 &lt;code&gt;order&lt;/code&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我这里为了和之前老版本的&lt;code&gt;alibaba&lt;/code&gt;的&lt;code&gt;dubbo&lt;/code&gt;项目区分，文件名取为&lt;code&gt;apache-dubbo-demo&lt;/code&gt;，&lt;code&gt;maven&lt;/code&gt; 项目名称为&lt;code&gt;order&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该项目主要作用是定义工程信息、管理整个项目依赖版本等等，所以&lt;code&gt;src&lt;/code&gt;目录不需要。&lt;/p&gt;
&lt;h3 id=&quot;22-pomxml&quot;&gt;2.2 &lt;code&gt;pom.xml&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;根工程中使用了&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;dependencies&amp;gt;&lt;/code&gt;进行依赖管理。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;&lt;/code&gt;：声明全局依赖，当子项目指定引用才会继承依赖；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;&lt;/code&gt;：声明全局依赖，子项目直接自动继承依赖。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;!-- 父级引用 --&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;!-- 基本信息 --&amp;gt;
    &amp;lt;groupId&amp;gt;cn.van.order&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;order&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;${project.artifactId}&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Apache Dubbo 根项目&amp;lt;/description&amp;gt;

    &amp;lt;!--配置--&amp;gt;
    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
        &amp;lt;dubbo.version&amp;gt;2.7.5&amp;lt;/dubbo.version&amp;gt;
        &amp;lt;zookeeper.version&amp;gt;3.4.14&amp;lt;/zookeeper.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;!-- 子项目 --&amp;gt;
    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;order-api&amp;lt;/module&amp;gt;
        &amp;lt;module&amp;gt;order-provider&amp;lt;/module&amp;gt;
        &amp;lt;module&amp;gt;order-consumer&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;

    &amp;lt;!--声明全局依赖（子项目需要显示的引用才会继承依赖）--&amp;gt;
    &amp;lt;dependencyManagement&amp;gt;
        &amp;lt;dependencies&amp;gt;
            &amp;lt;!-- dubbo-start依赖 --&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
            &amp;lt;!--zookeeper 注册中心客户端引入 使用的是curator客户端 --&amp;gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;dubbo-dependencies-zookeeper&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt;
                &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
                &amp;lt;exclusions&amp;gt;
                    &amp;lt;exclusion&amp;gt;
                        &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
                        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                    &amp;lt;/exclusion&amp;gt;
                &amp;lt;/exclusions&amp;gt;
            &amp;lt;/dependency&amp;gt;
        &amp;lt;/dependencies&amp;gt;
    &amp;lt;/dependencyManagement&amp;gt;

    &amp;lt;!--声明全局依赖（子项目不需要显示的引用，自动继承依赖）--&amp;gt;
    &amp;lt;dependencies&amp;gt;
        &amp;lt;!-- spring boot 依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.junit.vintage&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;junit-vintage-engine&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;!-- 打包插件 --&amp;gt;
    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三、order-api&quot;&gt;三、&lt;code&gt;order-api&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&quot;31-项目依赖&quot;&gt;3.1 项目依赖&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;无需更多依赖，所以很简单。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;cn.van.order&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;order&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;cn.van.order&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;order-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;${project.artifactId}&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;dubbo公共项目&amp;lt;/description&amp;gt;


    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-封装-rpc-结果集&quot;&gt;3.2 封装 &lt;code&gt;RPC&lt;/code&gt; 结果集&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;先封装一个返回码枚举类&lt;code&gt;ResultCodeEnum.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public enum ResultCodeEnum {
    /*** 通用部分 100 - 599***/
    // 成功请求
    SUCCESS(200, &quot;successful&quot;),
    
    /*** 这里可以根据不同模块用不同的区级分开错误码，例如:  ***/

    // 1000～1999 区间表示用户模块错误
    // 2000～2999 区间表示订单模块错误
    // 3000～3999 区间表示商品模块错误
    // 。。。

    ORDER_NOT_FOUND(2000, &quot;order not found&quot;),
    ;
    /**
     * 响应状态码
     */
    private Integer code;
    /**
     * 响应信息
     */
    private String message;

    ResultCodeEnum(Integer code, String msg) {
        this.code = code;
        this.message = msg;
    }

    public Integer getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;先封装一个RPC 响应结果集&lt;code&gt;RpcResult.java&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class RpcResult &amp;lt;T&amp;gt; implements Serializable {

    /**
     * 是否响应成功
     */
    private Boolean success;
    /**
     * 响应状态码
     */
    private Integer code;
    /**
     * 响应数据
     */
    private T data;
    /**
     * 错误信息
     */
    private String message;

    // 构造器开始
    /**
     * 无参构造器(构造器私有，外部不可以直接创建)
     */
    private RpcResult() {
        this.code = 200;
        this.success = true;
    }
    /**
     * 有参构造器
     * @param obj
     */
    private RpcResult(T obj) {
        this.code = 200;
        this.data = obj;
        this.success = true;
    }

    /**
     * 有参构造器
     * @param resultCode
     */
    private RpcResult(ResultCodeEnum resultCode) {
        this.success = false;
        this.code = resultCode.getCode();
        this.message = resultCode.getMessage();
    }
    // 构造器结束

    /**
     * 通用返回成功（没有返回结果）
     * @param &amp;lt;T&amp;gt;
     * @return
     */
    public static&amp;lt;T&amp;gt; RpcResult&amp;lt;T&amp;gt; success(){
        return new RpcResult();
    }

    /**
     * 返回成功（有返回结果）
     * @param data
     * @param &amp;lt;T&amp;gt;
     * @return
     */
    public static&amp;lt;T&amp;gt; RpcResult&amp;lt;T&amp;gt; success(T data){
        return new RpcResult&amp;lt;T&amp;gt;(data);
    }

    /**
     * 通用返回失败
     * @param resultCode
     * @param &amp;lt;T&amp;gt;
     * @return
     */
    public static&amp;lt;T&amp;gt; RpcResult&amp;lt;T&amp;gt; failure(ResultCodeEnum resultCode){
        return  new RpcResult&amp;lt;T&amp;gt;(resultCode);
    }

    public Boolean getSuccess() {
        return success;
    }

    public void setSuccess(Boolean success) {
        this.success = success;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    @Override
    public String toString() {
        return &quot;RpcResult{&quot; +
                &quot;success=&quot; + success +
                &quot;, code=&quot; + code +
                &quot;, data=&quot; + data +
                &quot;, message='&quot; + message + '\'' +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-编写一个-rpc-接口&quot;&gt;3.3 编写一个 &lt;code&gt;RPC&lt;/code&gt; 接口&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface OrderDubboService {
    RpcResult&amp;lt;OrderDomain&amp;gt; getOrder();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;实体&lt;code&gt;OrderDomain.java&lt;/code&gt;挺简单的，详见 &lt;code&gt;Github&lt;/code&gt; 仓库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;四、order-provider&quot;&gt;四、&lt;code&gt;order-provider&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;此子项目是一个服务类项目，也就是将接口服务注册到&lt;code&gt;zookeeper&lt;/code&gt;注册中心供消费端调取使用。&lt;/p&gt;
&lt;h3 id=&quot;41-项目依赖&quot;&gt;4.1 项目依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;cn.van.order&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;order&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;cn.van.order&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;order-provider&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;${project.artifactId}&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Dubbo 服务提供者&amp;lt;/description&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;cn.van.order&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;order-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- zookeeper依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-dependencies-zookeeper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;42-服务实现接口&quot;&gt;4.2 服务实现接口&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Service
public class OrderDubboServiceImpl implements OrderDubboService {
    
    @Override
    public RpcResult&amp;lt;OrderDomain&amp;gt; getOrder() {
        return RpcResult.success(new OrderDomain(1, 10086, LocalDateTime.now()));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;@Service&lt;/code&gt; 是 &lt;code&gt;dubbo&lt;/code&gt; 包下面的注解不是 &lt;code&gt;Spring&lt;/code&gt; 里面的注解。&lt;/p&gt;
&lt;h3 id=&quot;43-项目配置&quot;&gt;4.3 项目配置&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;dubbo&lt;/code&gt; 的配置直接用 &lt;code&gt;dubbo&lt;/code&gt;，不再以 &lt;code&gt;Spring&lt;/code&gt; 开头;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;base-packages&lt;/code&gt;：指定接口实现所在路径。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;server:
  # 服务端口
  port: 7777
spring:
  application:
    name: order-provider
# dubbo 相关配置(dubbo 的配置不再以 Spring 开头)
dubbo:
  application:
    # 应用名称
    name: order-provider
  scan:
    # 接口实现者（服务实现）包
    base-packages: cn.van.order.service.impl
  # 注册中心信息
  registry:
    address: zookeeper://127.0.0.1:2181
  protocol:
    # 协议名称
    name: dubbo
    # 协议端口
    port: 20880
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五、order-consumer&quot;&gt;五、&lt;code&gt;order-consumer&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;此子项目就是一个消费项目，比如商品模块、财务模块等等。&lt;/p&gt;
&lt;h3 id=&quot;51-项目依赖&quot;&gt;5.1 项目依赖&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;cn.van.order&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;order&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;cn.van.order&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;order-consumer&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;${project.artifactId}&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Dubbo 消费者&amp;lt;/description&amp;gt;


    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;cn.van.order&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;order-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.0.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- web项目依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- dubbo依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-spring-boot-starter&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- dubbo的zookeeper依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.dubbo&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;dubbo-dependencies-zookeeper&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${dubbo.version}&amp;lt;/version&amp;gt;
            &amp;lt;type&amp;gt;pom&amp;lt;/type&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;52-测试接口&quot;&gt;5.2 测试接口&lt;/h3&gt;
&lt;p&gt;模拟一个接口获取订单详情。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@RequestMapping(&quot;/order&quot;)
public class OrderConsumerController {
    @Reference
    OrderDubboService orderDubboService;

    @GetMapping(&quot;getOrder&quot;)
    public RpcResult getOrder() {
        return orderDubboService.getOrder();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;code&gt;@Reference&lt;/code&gt;引入的是 &lt;code&gt;Dubbo&lt;/code&gt; 接口，所以是 &lt;code&gt;Dubbo&lt;/code&gt; 的注解。&lt;/p&gt;
&lt;h3 id=&quot;53-配置文件&quot;&gt;5.3 配置文件&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;server:
  port: 7000
spring:
  application:
    name: order-consumer
# dubbo 相关配置
dubbo:
  application:
    name: order-consumer
  registry:
    address: zookeeper://127.0.0.1:2181
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六、测试&quot;&gt;六、测试&lt;/h2&gt;
&lt;p&gt;一切就绪，如果在&lt;code&gt;order-consumer&lt;/code&gt; 的测试接口能成功请求到数据，则证明 &lt;code&gt;Dubbo&lt;/code&gt; 服务搭建成功。&lt;/p&gt;
&lt;h3 id=&quot;61-启动-zookeeper&quot;&gt;6.1 启动 &lt;code&gt;zookeeper&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;我们选用&lt;code&gt;zookeeper&lt;/code&gt;作为注册中心，因此启动项目之前需要先启动它。&lt;/p&gt;
&lt;h3 id=&quot;62-dubbo-admin&quot;&gt;6.2 &lt;code&gt;dubbo-admin&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;dubbo-admin&lt;/code&gt; 便于观察 &lt;code&gt;order-provider&lt;/code&gt; 是否成功将接口注册，具体安装步骤详见&lt;a href=&quot;https://github.com/apache/dubbo-admin/blob/develop/README_ZH.md&quot;&gt;apache/dubbo-admin&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;默认端口：&lt;code&gt;8080&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;63-启动-dubbo-provider&quot;&gt;6.3 启动 &lt;code&gt;dubbo-provider&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;成功启动后可以在&lt;code&gt;dubbo-admin&lt;/code&gt;：已经成功将接口 &lt;code&gt;OrderService&lt;/code&gt; 注册到 &lt;code&gt;zookeeper&lt;/code&gt; 上如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200506220659686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAzNjk1Mg==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;风尘博客&quot;/&gt;&lt;/p&gt;
&lt;p&gt;成功将借口注册到注册中心，说明&lt;code&gt;dubbo-provider&lt;/code&gt; 注册成功。&lt;/p&gt;
&lt;h3 id=&quot;64-启动-order-cosumer&quot;&gt;6.4 启动 &lt;code&gt;order-cosumer&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;启动消费者项目，在浏览器请求消费接口：&lt;a href=&quot;http://localhost:7000/order/getOrder&quot;&gt;http://localhost:7000/order/getOrder&lt;/a&gt;，成功返回数据如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;success&quot;:true,
    &quot;code&quot;:200,
    &quot;data&quot;:{
        &quot;id&quot;:1,
        &quot;orderNum&quot;:10086,
        &quot;gmtCreate&quot;:&quot;2020-05-06T11:59:45.535&quot;
    },
    &quot;message&quot;:null
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功请求到 &lt;code&gt;order-provider&lt;/code&gt; 提供的数据，说明 &lt;code&gt;Dubbo&lt;/code&gt; 搭建成功！&lt;/p&gt;
&lt;h2 id=&quot;七、总结&quot;&gt;七、总结&lt;/h2&gt;
&lt;p&gt;以上的完整代码我已上传到 &lt;a href=&quot;https://github.com/vanDusty/SpringBoot-Home/tree/master/springboot-demo-dubbo/apache-dubbo-demo&quot;&gt;Github&lt;/a&gt;，需要的可以自取测试，欢迎&lt;code&gt;star&lt;/code&gt;！&lt;/p&gt;
&lt;h3 id=&quot;文化交流&quot;&gt;文化交流&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.dusty.vip&quot;&gt;风尘博客&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/user/5d5ea68e6fb9a06afa328f56/posts&quot;&gt;风尘博客-掘金&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/vandusty/&quot;&gt;风尘博客-博客园&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://me.csdn.net/weixin_42036952&quot;&gt;风尘博客-CSDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/vanDusty&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Fri, 08 May 2020 16:07:00 +0000</pubDate>
<dc:creator>风尘博客</dc:creator>
<og:description>`Apache Dubbo Java RPC` 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 注意，是 ，不再是 。简单来说就是 将 移交给 开源社</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vandusty/p/12853973.html</dc:identifier>
</item>
<item>
<title>不需要爬虫也能轻松获取 unsplash 上的图片 - 和牛</title>
<link>http://www.cnblogs.com/heniu/p/12853897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heniu/p/12853897.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我经常会使用 unsplash， 这里面的图片非常清爽，我的大多数文章的图片都是在这个网上找的，虽然也有同类型网站，但是用过一段时间以后基本都放弃了，图片质量参差不齐，筛选过程太费劲。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 unsplash 访问速度是个大问题，我经常会因为图片无法加载而被劝退。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/89843073-a30d-4d5d-b949-4e4d8bb69ecb.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天一时手痒，顺手搜了 unsplash api 这个关键字，看官方有没有提供相关的 api 服务，还真有！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/fb475142-666f-4785-a735-e7020296fc4e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;unsplash 提供了 2 个版本的 API。 一个是简单版，主要是给小型应用，流量比较少的 app 使用，可以通过 source.unsplash.com 进入；一个是进阶版的开发者中心 API, 支持更多流量的 app 使用，可以通过 unsplash.com/developers 进入。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/3b707222-b426-4faf-b081-c99d9a5c6c2a.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Source API&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;source api 提供的功能比较简单。如果想获取一张随机图片，可以访问地址：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;https://source.unsplash.com/random
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个地址会重定向到一张图片的地址，可以通过响应直接获取到一张图片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/63803f7b-39c5-40fe-91d8-28fb44cb512d.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果图片太大，加载速度也会比较慢。你可以在 url 后面添加尺寸，控制返回的图片大小：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;https://source.unsplash.com/random/800x600
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果原图片不是这种长宽比，unsplash 会对图片进行裁剪，某些部分就会丢失。如果你想保持图片的原始比例，可以把高度设成 0 ：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;https://source.unsplash.com/random/800x0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/967c8285-7a11-429c-90c3-a806d9a69cd6.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;小提示&lt;/p&gt;
&lt;p&gt;无论是什么 API, 你都可以在最后使用 /800x0 这样的方式控制图片的大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以指定获取某位作者的图片。比如我特别喜欢 Raamin ka 拍摄的照片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/772ae001-5ba0-45f1-a109-b69e7645e93c.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我可以把它的用户名小写以后再去掉空格，添加到 /user 的后面：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;https://source.unsplash.com/user/raaminka
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我就能获取到这位作者拍摄的随机妹子照片了。不要忘了，你同样是可以控制图片尺寸的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/d51bd2ae-38c1-45dd-824c-a79030909333.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取某个用户喜欢的照片：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;https://source.unsplash.com/user/raaminka/like
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/679f1990-698d-4ee3-95ed-a50923c6917e.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;unsplash api 还支持搜索。通常来说，我都会根据要写的文章的主题在 unsplash 上搜索图片。比如我要写一篇关于加密的文章，那我就会去搜索 encryption 相关的图片：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;https://source.unsplash.com/800x0/?encryption
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/ac90b8db-afb1-47f2-9583-0736cb5e56df.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你也可以组合多个不同的关键字。如果没有图片同时包含这些关键字，则会优先匹配最后的关键字。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;https://source.unsplash.com/800x0/?encryption,girl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们每次访问同一个 API, 得到图片都不一样，因为是随机生成的。但是如果我们在每个 API 的后面添加 /daily 或者 /weekly， 则可以得到固定的一张图。需要注意，这并不是说这些图片更加热门或者质量更高，只是每天/每周保持不变的随机图片而已。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;https://source.unsplash.com/800x0/daily?sports
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/dc028aa4-c92f-4790-ad3e-172ad7420af5.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Developer API&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;source api 的功能有限，而且如果访问频率太快总是会返回相同的图片。现在我们来看一下更加专业的开发者 API。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发者 API 不是马上就可以使用的。你需要先注册成为开发者，得到一个 access token， 之后你可以通过这个 token 访问 API:&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;https://api.unsplash.com/photos?client_id=fowflsfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 API 还支持 3 个参数&lt;/p&gt;
&lt;table data-tool=&quot;mdnice编辑器&quot;&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;param&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;page&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第几页&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;per_page&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;每页的图片数量&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;&lt;code&gt;order_by&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;排序 (可以是: &lt;code&gt;latest&lt;/code&gt;, &lt;code&gt;oldest&lt;/code&gt;, &lt;code&gt;popular&lt;/code&gt;; 默认是: &lt;code&gt;latest&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他的 api 文档你都可以在官网上查看到，这里不复制粘贴了。developer api 相比 resource api 的好处在于他可以同时提供多张图片，同时能获取到丰富的信息，比如作者，日期，大小等等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 unsplash 的主页只能看到编辑推荐的图片。没有最新的和流行的可以看，所以我写了个简陋的外壳查看最新和流行的图片。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先定义一个函数获取图片：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;get_photos&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(order_by=&lt;span class=&quot;hljs-string&quot;&gt;'popular'&lt;/span&gt;, page=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, per_page=&lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;&quot;通过developer api 获取图片。&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;session = requests.Session()&lt;br/&gt;url = &lt;span class=&quot;hljs-string&quot;&gt;'https://api.unsplash.com/photos'&lt;/span&gt;&lt;br/&gt;params = {&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;client_id&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;your access token&quot;&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;order_by&quot;&lt;/span&gt;: order_by,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;page&quot;&lt;/span&gt;: page,&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;per_page&quot;&lt;/span&gt;: per_page&lt;br/&gt;}&lt;br/&gt;resp = session.get(url, params=params).json()&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; resp&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我可以得到 50 张图的 url 地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/05/08/gJlKCMDyW3Bre5X.png&quot; alt=&quot;image.png&quot;/&gt;image.png&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来使用 flask 搭建一个简易服务：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;6&quot;&gt;app = Flask(__name__)&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@app.route('/')&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;pictures = get_photos()&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; render_template(&lt;span class=&quot;hljs-string&quot;&gt;'index.html'&lt;/span&gt;, pictures=pictures)&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;hljs-string&quot;&gt;'__main__'&lt;/span&gt;:&lt;br/&gt;app.run()&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接把图片地址返回给前端页面：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;{% for pic in pictures %}&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;{{ pic.urls.regular }}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;img&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;{{ pic.urls.small }}&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;a&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;{% endfor %}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我通过访问本地的 http://localhost:5000 就可以看到很多的图片。我没有对图片展示效果进行任何的美化，这种凌乱的风格其实也挺好看的。后面如果用得多我在用 css 框架去做一下页面布局。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我点击一张图片时，则可以进入这张图片的大图地址，并且可以直接作为链接地址应用到 markdown 当中，而在 unsplash 官方网站上不能直接获取链接地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/3b3a6fb7-598b-4837-97ed-8bc2e622dfea.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后补充一点。这个小应用只是作为 unsplash 网站访问非常慢的时候一个备选，并不能真正代替官网。对于图片的筛选和分类搜索操作，官网提供了非常人性化的操作，我就不重复造轮子了。对于这个备选服务，我把他设成了命令行形式，只需要在命令行输入 unsplash 就可以启动网站，还算比较方便。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击 &lt;a href=&quot;https://github.com/looker53/unsplash_url.git&quot;&gt;阅读原文&lt;/a&gt; 获取完整代码。&lt;/p&gt;
</description>
<pubDate>Fri, 08 May 2020 15:53:00 +0000</pubDate>
<dc:creator>和牛</dc:creator>
<og:description>获取免费图片又可以轻松一点点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heniu/p/12853897.html</dc:identifier>
</item>
</channel>
</rss>