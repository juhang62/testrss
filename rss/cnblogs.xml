<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>什么是注解？ - hncboy</title>
<link>http://www.cnblogs.com/hncboy/p/12208132.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hncboy/p/12208132.html</guid>
<description>&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Java 注解是在 JDK5 时引入的新特性，注解（也被称为元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。注解类型定义指定了一种新的类型，一种特殊的接口类型。 在关键词 interface 前加 @ 符号也就是用 @interface 来区分注解的定义和普通的接口声明。目前大部分框架(如 Spring Boot 等)都通过使用注解简化了代码并提高的编码效率。&lt;/span&gt;&lt;/p&gt;

&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;提供信息给编译器： 编译器可以利用注解来探测错误和警告信息，如 @Override、@Deprecated。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html 文档或者做其它相应处理，如 @Param、@Return、@See、@Author 用于生成 Javadoc 文档。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;运行时的处理： 某些注解可以在程序运行的时候接受代码的提取，值得注意的是，注解不是代码本身的一部分。如Spring 2.5 开始注解配置，减少了配置。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.1 注解的本质&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;所有的注解本质上都是继承自 Annotation 接口。但是，手动定义一个接口继承 Annotation 接口无效的，需要通过 @interface 声明注解，Annotation 接口本身也不定义注解类型，只是一个普通的接口。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Annotation {
    
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; equals(Object obj);
    
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; hashCode();
    
    String toString();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     *获取注解类型 
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt;&lt;span&gt; annotationType();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;来对比下 @interface 定义注解和继承 Annotation 接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestAnnotation1 {
}
​
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; TestAnnotation2 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Annotation  {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过使用 javap 指令对比两个文件的字节码，发现通过 @interface 定义注解，本质上就是继承 Annotation 接口。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; javap -c TestAnnotation1.class&lt;/span&gt;
Compiled from &quot;TestAnnotation1.java&quot;                                                                 
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; com.hncboy.corejava.annotation.TestAnnotation1 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; java.lang.annotation.Annotation {}
​
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; javap -c TestAnnotation2.class&lt;/span&gt;
Compiled from &quot;TestAnnotation2.java&quot;                                                                 
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; com.hncboy.corejava.annotation.TestAnnotation2 &lt;span&gt;extends&lt;/span&gt; java.lang.annotation.Annotation {}
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;虽然本质上都是继承 Annotation 接口，但即使接口可以实现多继承，注解的定义仍然无法使用继承关键字来实现。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过 @interface 定义注解后，该注解也不能继承其他的注解或接口，注解是不支持继承的，如下代码就会报错。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestAnnotation1 {
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 错误的定义，注解不能继承注解 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt; TestAnnotation2 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; TestAnnotation1 {
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 错误的定义，注解不能继承接口 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt; TestAnnotation3 &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Annotation {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;虽然注解不支持继承其他注解或接口，但可以使用组合注解的方式来解决这个问题。如 @SpringBootApplication 就采用了组合注解的方式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters &lt;/span&gt;= { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;),
        @Filter(type &lt;/span&gt;= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;) })
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SpringBootApplication {
    
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.2 注解的架构&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;md-htmlblock md-rawblock md-end-block&quot;&gt;​
&lt;div class=&quot;md-htmlblock-container md-rawblock-container&quot;&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191216231904436.jpg&quot; alt=&quot;&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191216231904436.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
​&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注解的基本架构如图所示，先简单了解下该架构，后面会详细讲解。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;该架构的左半部分为基本注解的组成，一个基本的注解包含了 @interface 以及 ElementType 和 RententionPolicy 这两个枚举类。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;该架构的右半部分为 JDK 部分内置的标准注解及元注解。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.3 注解的属性&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注解的属性也称为成员变量，注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注解内的可使用的数据类型是有限制的，类型如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;所有的基本类型（int，float，boolean 等）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;String&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Class&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;enum（@Retention 中属性的类型为枚举）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Annotation&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;以上类型的数组（@Target 中属性类型为枚举类型的数组）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;编译器对属性的&lt;span&gt;&lt;strong&gt;默认值&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;也有约束。首先，属性不能有不确定的的值。也就是说，属性要么具有默认值，要么在使用注解时提供属性的值。对于非基本类型的属性，无论是在源代码中声明时，或是在注解接口中定义默认值时，都不能使用 &lt;span&gt;&lt;strong&gt;null&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;为其值。因此，为了绕开这个约束，我们需要自己定义一些特殊的值，例如空字符串或负数，来表示某个属性不存在。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过一个案例来演示下注解可使用的数据类型及默认值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
@&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Reference {
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; contain() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
}
​
&lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; Week {
    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
}
​
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestAnnotation {
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * int 基本数据类型
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; type() &lt;span&gt;default&lt;/span&gt; -1&lt;span&gt;;
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * boolean 基本数据类型
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; status() &lt;span&gt;default&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * String 类型
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String name() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Class 类型
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Class&lt;/span&gt;&amp;lt;?&amp;gt; loadClass() &lt;span&gt;default&lt;/span&gt; String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;;
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 枚举类型
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Week today() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; Week.Sunday;
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 注解类型
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Reference reference() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; @Reference(contain = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 枚举数组类型
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Week[] value();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们已经了解了注解的架构，先来定义一个简单的注解。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestAnnotation {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3.1 ElementType&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;ElementType 枚举类型的常量为 Java 程序中可能出现注解的声明位置提供了简单的分类。这些常量用于 @Target 注解中。@Target 用于描述注解适用的范围，即注解能修饰的对象范围，通过 ElementType 的枚举常量表示。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;先来看下 ElementType 该枚举类的代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ElementType {
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于描述类、接口（包括注解类型）、枚举的定义
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    TYPE,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于描述成员变量、对象、属性（包括枚举常量）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    FIELD,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用户描述方法
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    METHOD,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于描述参数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    PARAMETER,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于描述构造器
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    CONSTRUCTOR,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于描述局部变量
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    LOCAL_VARIABLE,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于描述注解的（元注解）
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ANNOTATION_TYPE,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用于描述包
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    PACKAGE,
​
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 表示该注解能写在类型变量的声明语句中
     * @since 1.8
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    TYPE_PARAMETER,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 表示该注解能写在使用类型的任何语句中（声明语句、泛型和强制转换语句中的类型）
     * &lt;/span&gt;&lt;span&gt;@since&lt;/span&gt;&lt;span&gt; 1.8
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    TYPE_USE
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;因为 Annotation 和 ElementType 是一对多的关系，所以 @Target 中可以存放数组，表示多个范围，默认所有范围。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;JDK8 之前，注解只能用于声明的地方，JDK8 中添加了 TYPE_PARAMETER 和 TYPE_USE 类型注解，可以应用于所有地方：泛型、父类、接口，异常、局部变量等。举个例子，定义一个 @AnyWhere 注解，Boy 接口和 Test 类。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({ElementType.TYPE_USE, ElementType.TYPE_PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; AnyWhere {
}
​
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Boy {
}
​
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Test&amp;lt;@AnyWhere T&amp;gt; &lt;span&gt;extends&lt;/span&gt; @AnyWhere Object &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; @AnyWhere Boy {
​
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; @AnyWhere T test1(@AnyWhere T t) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; @AnyWhere Exception {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; t;
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
        Test&lt;/span&gt;&amp;lt;Integer&amp;gt; test = &lt;span&gt;new&lt;/span&gt; @AnyWhere Test&amp;lt;&amp;gt;&lt;span&gt;();
        @AnyWhere List&lt;/span&gt;&amp;lt;@AnyWhere Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3.2 RetentionPolicy&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;RetentionPolicy 枚举类型的常量用于保留注解的各种策略，即该注解的有效期。它们与 @Retention 注解类型一起使用，以指定保留注解的时间。RetentionPolicy 枚举的代码如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; RetentionPolicy {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 表示该注解只存在于源码阶段，
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    SOURCE,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 表示该注解存在于源码阶段和编译后的字节码文件里
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    CLASS,
​
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 表示该注解存在于源码阶段、编译后的字节码文件和运行时期，且注解的内容将会被 JVM 解释执行
     * 该范围的注解可通过反射获取到
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    RUNTIME
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Annotation 和 RetentionPolicy 是一对一的关系，即每个注解只能有一种保留策略。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这三个枚举值是有等级关系的，SOURCE &amp;lt; CLASS &amp;lt; RUNTIME，即 RUNTIME 的有效范围是最大的，其次的是 CLASS，最小的范围是 SOURCE，默认的保留范围为 CLASS。&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;RUNTIME 范围使用于在运行期间通过反射的方式去获取注解。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;CLASS 适用于编译时进行一些预处理操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;SOURCE 适用于一些检查性的工作，或者生成一些辅助的代码，如 @Override 检查重写的方法，Lombok 中的 @Date、@Getter、@Setter 注解。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3.3 注解与反射&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过前面我们了解到，注解本质上继承 Annotation 接口，也就是说，Annotation 接口是所有注解的父接口。@Retention 的保留策略为 RetentionPolicy.RUNTIME 的情况下，我们可以通过反射获取注解的相关信息。Java 在 java.lang.reflect 包下也提供了对注解支持的接口。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;md-htmlblock md-rawblock md-end-block&quot;&gt;​
&lt;div class=&quot;md-htmlblock-container md-rawblock-container&quot;&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191216232209118.png&quot; alt=&quot;&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191216232209118.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
​&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;主要来了解下 AnnotationElement 这个接口，其他接口都为该接口的子接口。该接口的对象代表 JVM 运行期间使用注解的类型（Class，Method，Field 等）。该包下的 Constructor 类、Method 类、Package 类和 Class 类等都实现了该接口。简单了解下该接口的部分函数。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; AnnotatedElement {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * default 方法是 Java8 新增的
     * 如果指定类型的注解存在该类型上，则返回 true，否则返回 false。此方法的主要目的是方便访问一些已知的注解
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; annotationClass 该泛型参数表示所有继承了Annotation 接口的接口，也就是注解
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; 返回该类型上是否有指定的注解
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;default&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isAnnotationPresent(Class&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt;&lt;span&gt; annotationClass) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getAnnotation(annotationClass) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 根据注解的 Class 查询注解
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &amp;lt;T &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt; T getAnnotation(Class&amp;lt;T&amp;gt;&lt;span&gt; annotationClass);
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回该类型上的所有注解，包含继承的
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Annotation[] getAnnotations();
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回该类型上的所有注解，不包含继承的
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Annotation[] getDeclaredAnnotations();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们使用代码来测试下反射获取注解。定义两个注解，一个保留策略为 RetentionPolicy.RUNTIME，另一个为 RetentionPolicy.CLASS。创建 TestAnnotation 类测试注解，该类上使用了这两个注解。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestAnnotation1 {
    String status() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;hncboy&quot;&lt;span&gt;;
}
​
@Retention(RetentionPolicy.CLASS)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestAnnotation2 {
    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;hncboy&quot;&lt;span&gt;;
}
​
@TestAnnotation1(status &lt;/span&gt;= &quot;hncboy2&quot;&lt;span&gt;)
@TestAnnotation2(&lt;/span&gt;&quot;hncboy2&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestAnnotation {
​
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz = Class.forName(&quot;com.hncboy.corejava.annotation.TestAnnotation&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取该类的所有注解&lt;/span&gt;
        Annotation[] annotations =&lt;span&gt; clazz.getAnnotations();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Annotation annotation : annotations) {
            System.out.println(annotation.annotationType());
            System.out.println(annotation.toString());
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;输出结果如下，可见 TestAnnotation2 注解没有输出，因为 TestAnnotation2 注解类型是 RetentionPolicy.CLASS 的，所以用反射方法获取不到。这里还涉及到了注解的一个快捷方法，就是当注解里的属性名字定义为 value 时，可以在使用该注解时不指定属性名，上面的 @Target 注解和 @Retention 注解都属于这种情况，不过当注解里有多个属性时，那就必须指定属性名了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; com.hncboy.corejava.annotation.TestAnnotation1
@com.hncboy.corejava.annotation.TestAnnotation1()(status&lt;/span&gt;=hncboy2)
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;元注解即注解的注解且只能作用于注解上的注解，也就是说元注解负责其他注解的注解，而且只能用在注解上面。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;JDK8 以前内置的元注解有 @Documented、@Retention、@Target、@Inherited 这四个，JDK 8 引入了 @Repeatable， 前面已经了解过了 @Target 和 @Retention，下面做一些简单的补充。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;元注解的 @Target 都为 ElementType.ANNOTATION_TYPE，因为元注解只能应用于注解的注解。元注解在定义该注解的同时也可以直接使用该注解。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;5.1 @Target&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;该注解用于定义注解能使用的范围，取值为 ElementType 枚举。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Target {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回可以应用注解类型的各种范围的枚举数组
     * 名字为 value 时可以省略属性名
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    ElementType[] value();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.METHOD)
@Target(value &lt;/span&gt;=&lt;span&gt; ElementType.METHOD)
@Target({ElementType.METHOD, ElementType.TYPE})
@Target(value &lt;/span&gt;= {ElementType.METHOD, ElementType.TYPE})
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;5.2 @Retention&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;该注解定义注解的保留策略或者说定义注解的有效期，取值范围为 RetationPolicy 枚举。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Retention {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 返回保留策略
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    RetentionPolicy value();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用方式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
@Retention(value &lt;/span&gt;= RetentionPolicy.RUNTIME)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;5.3 @Documented&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;该注解的使用表示是否包含在生成的 javadoc 文档中。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Documented {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;举个例子，定义一个 @TestAnnotation 注解和 Test 类。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
@Retention(value =&lt;span&gt; RetentionPolicy.RUNTIME)
@Documented
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestAnnotation {

}

@TestAnnotation
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过 javadoc -d doc *.java 命令将该目录下的这两个类生成文档并放在 doc 目录下。生成的文件如下，点击 index.html。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;md-htmlblock md-rawblock md-end-block&quot;&gt;​
&lt;div class=&quot;md-htmlblock-container md-rawblock-container&quot;&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191216232447774.png&quot; alt=&quot;&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191216232447774.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
​&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;看到如图所示的样子，Test 类中包含 @TestAnnotation。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;md-htmlblock md-rawblock md-end-block&quot;&gt;​
&lt;div class=&quot;md-htmlblock-container md-rawblock-container&quot;&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191216232502709.png&quot; alt=&quot;&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191216232502709.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
​&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我们再把 @TestAnnotation 注解上的 @Documenet 注解注释掉再来生成下文档。此时发现 Test 类中没有 @TestAnnotation 注解了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;md-htmlblock md-rawblock md-end-block&quot;&gt;​
&lt;div class=&quot;md-htmlblock-container md-rawblock-container&quot;&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191216232518542.png&quot; alt=&quot;&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191216232518542.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
​&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;5.4 @Inherited&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;该注解表示注解是否具有继承的特性。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Inherited {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;举个例子来测试下。新建 TestAnnotation 注解，Father 类，Son 类，Father 类使用了该注解，Son 类继承 Father 类。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
@Inherited
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestAnnotation {
}

@TestAnnotation
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Father {
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Son &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Father {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;新建一个测试类，测试 Father 和 Son 这两个类是否包这两个注解。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        System.out.println(Father.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.isAnnotationPresent(TestAnnotation.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
        System.out.println(Son.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;.isAnnotationPresent(TestAnnotation.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;输出为 true true，当把 @TestAnnotation 注解上的 @Inherited 注解注释掉时，输出 true false，如此可见该注解的作用。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;5.5 @Repeatable&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;JDK8 以前是不支持重复注解的，同一个地方只能使用同一个注解一次。 该注解从 JDK8 引入，该注解类型用于表示其声明注解的注解类型为可重复时。 value() 的值表示可重复注解的类型，包含注解类型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Repeatable {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 指可重复注解的类型，包含注解类型
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    Class&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; Annotation&amp;gt;&lt;span&gt; value();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;举个例子，定义 @Activity 和 @Activities 注解，定义 Hncboy 类测试重复注解。@Activity 注解被 @Repeatable(Activities.class) 注解，@Activities 相当于一个容器注解，属性为 Activity 类型的数组，通过这样的方式，使得 @Activity 注解可以被重复使用。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Activities {
    Activity[] value();
}

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Repeatable(Activities.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Activity {
    String value();
}

@Activity(&lt;/span&gt;&quot;打代码&quot;&lt;span&gt;)
@Activity(&lt;/span&gt;&quot;吃饭&quot;&lt;span&gt;)
@Activity(&lt;/span&gt;&quot;睡觉&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Hncboy {
}

@Activities({@Activity(&lt;/span&gt;&quot;打代码&quot;), @Activity(&quot;吃饭&quot;), @Activity(&quot;睡觉&quot;&lt;span&gt;)})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Hncboy {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;JDK 内置的注解有 @Deprecated、@Override、@SuppressWarnnings、@SafeVarargs（JDK 7 引入）、@FunctionalInterface（JDK 引入）等。接下来介绍下 3 中常用的内置注解。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;6.1 @Deprecated&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注解为 @Deprecated 的类型是不鼓励程序员使用的元素，通常是因为这样做很危险，或者是因为存在更好的替代方法。当在不推荐使用的代码中使用或覆盖不推荐使用的程序元素时，编译器会发出警告。该注解可以用来修饰构造器、字段、局部变量、方法等类型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value&lt;/span&gt;=&lt;span&gt;{CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Deprecated {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;举个例子，使用 @Deprecated 修饰的元素是不推荐使用的，编译器会帮我们将这些类和方法用删除线标记。直接声明在包上会报 Package annotations should be in file package-info.java 错误。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Deprecated
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestDeprecated {

    @Deprecated
    String s &lt;/span&gt;= &quot;hncboy&quot;&lt;span&gt;;

    @Deprecated
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;md-htmlblock md-rawblock md-end-block&quot;&gt;​
&lt;div class=&quot;md-htmlblock-container md-rawblock-container&quot;&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191216232757691.png&quot; alt=&quot;&quot; data-src=&quot;https://img-blog.csdnimg.cn/20191216232757691.png&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
​&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;6.2 @Override&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;@Override 注解我们经常用到，提示子类需要重写父类的方法。方法重写或实现了在父类中声明的方法时需要加上该注解，该注解用于编译器检查重写的操作是否正确，保留策略为 RetentionPolicy.SOURCE。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Override {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;6.3 @SuppressWarnings&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;用来关闭编译器生成警告信息，可以用来修饰类、方法、成员变量等，在使用该注解时，应采用就近原则，如方法产生警告是，应该针对方法声明该注解，而不是对类声明，有利于发现该类的其他警告信息。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; SuppressWarnings {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 带有注解的元素中的编译器将禁止的警告集。
     * 使用 unchecked 忽略无法识别的警告
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String[] value();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;举个例子，rawtypes 用于使用泛型时忽略没有指定相应的类型，unused 用于没有使用过的代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    @SuppressWarnings({&lt;/span&gt;&quot;rawtypes&quot;, &quot;unused&quot;&lt;span&gt;})
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; List test() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;自定义注解实现 Spring IOC Bean 实例创建，自定义简单的注解： @Component、@Bean 和 @ComponentScan。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;通过&lt;span&gt;&lt;strong&gt;什么是反射？&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;这篇文章我们已经学习到通过反射实现 Spring IOC Bean 实例的三种创建方式，不清楚的可以去看下那篇文章。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;7.1 新建 @MyComponent、@MyBean、 @MyComponentScan&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MyBean {

    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MyComponent {

    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MyComponentScan {

    String value() &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;7.2 新建 A、B、C 三个类&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
@MyComponent(&quot;a&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; A() {
        System.out.println(&lt;/span&gt;&quot;调用 A 的无参构造器&quot;&lt;span&gt;);
    }

    @MyBean(&lt;/span&gt;&quot;b&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; B createBInstance() {
        System.out.println(&lt;/span&gt;&quot;调用 A 的静态方法 createBInstance&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; B();
    }

    @MyBean(&lt;/span&gt;&quot;c&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; C createCInstance() {
        System.out.println(&lt;/span&gt;&quot;调用 A 的实例方法 createCInstance&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; C();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; B {}
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; C {}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;7.3 新建 IOCContainer 类&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 定义 map 存放 bean
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; IOCContainer {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt; container = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; putBean(String id, Object object) {
        container.put(id, object);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object getBean(String id) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; container.get(id);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;7.4 新建 Test 类&lt;/span&gt;&lt;/h2&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;1&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;先获取 @MyComponentScan 注解中的包名&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;然后扫描该包下所有类的全限定名&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;遍历类名，判断改类是否实现 @MyComponent 注解&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;遍历方法，判断该方法是否实现 @MyBean 注解&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;大致过程是这样，具体的可以见代码的注释。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
@MyComponentScan(&quot;com.hncboy.corejava.annotation.spring&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        Test test &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Test();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 MyComponentScan 注解中的包名&lt;/span&gt;
        String scanPackage =&lt;span&gt; test.getScanPackage();

        HashSet&lt;/span&gt;&amp;lt;String&amp;gt; classPathSet = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 扫描包下的所有类并将类的全限定名放进 classPathSet&lt;/span&gt;
&lt;span&gt;        test.doScanPackage(classPathSet, scanPackage);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历扫描包下的所有类&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String className : classPathSet) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过类的全限定名获取 Class&lt;/span&gt;
            Class&amp;lt;?&amp;gt; clazz =&lt;span&gt; Class.forName(className);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断该类是否实现了 MyComponent 注解&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (clazz.isAnnotationPresent(MyComponent.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方式1：通过构造器实例化&lt;/span&gt;
&lt;span&gt;                IOCContainer.putBean(className, clazz.newInstance());
            }

            Method[] methods &lt;/span&gt;=&lt;span&gt; clazz.getDeclaredMethods();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Method method : methods) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断方法是否有 MyBean 注解&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (method.isAnnotationPresent(MyBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 bean 值&lt;/span&gt;
                    String beanName = method.getAnnotation(MyBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;).value();
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断该方法是否是静态方法或实例方法&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Modifier.isStatic(method.getModifiers())) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方式2：通过静态工厂实例化&lt;/span&gt;
                        IOCContainer.putBean(beanName, method.invoke(&lt;span&gt;null&lt;/span&gt;&lt;span&gt;));
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 方式3：通过实例工厂实例化
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先获取该类的实例对象，再调用实例方法进行实例化&lt;/span&gt;
&lt;span&gt;                        IOCContainer.putBean(beanName, method.invoke(IOCContainer.getBean(className)));
                    }
                }
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 获取 MyComponentScan 注解中的包名
     *
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getScanPackage() {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getClass();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!clazz.isAnnotationPresent(MyComponentScan.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;&quot;&lt;span&gt;;
        }
        MyComponentScan scanPackage &lt;/span&gt;= clazz.getDeclaredAnnotation(MyComponentScan.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; scanPackage.value();
    }

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 扫描该包下的类
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; classPathSet
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; scanPackage
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doScanPackage(HashSet&amp;lt;String&amp;gt;&lt;span&gt; classPathSet, String scanPackage) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过正则表达式将包名中的 . 替代为 /，并获取到该路径的 class url&lt;/span&gt;
        URL url = &lt;span&gt;this&lt;/span&gt;.getClass().getResource(&quot;/&quot; + scanPackage.replaceAll(&quot;\\.&quot;, &quot;/&quot;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取该 url 下的所有 File（目录/文件）&lt;/span&gt;
        File classDir = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; File(url.getFile());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 遍历所有 File&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (File file : classDir.listFiles()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断该 file 如果是目录的话&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (file.isDirectory()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拼接该目录的名字并递归遍历该目录&lt;/span&gt;
                doScanPackage(classPathSet, scanPackage + &quot;.&quot; +&lt;span&gt; file.getName());
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果文件不是以 .class 结尾&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!file.getName().endsWith(&quot;.class&quot;&lt;span&gt;)) {
                    &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过 包名+目录名+除去.class的类名 拼接该类的全限定名&lt;/span&gt;
                String clazzName = (scanPackage + &quot;.&quot; + file.getName().replace(&quot;.class&quot;, &quot;&quot;&lt;span&gt;));
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将该类的全限定名放入 classPathSet&lt;/span&gt;
&lt;span&gt;                classPathSet.add(clazzName);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;输出如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;调用 A 的无参构造器
调用 A 的静态方法 createBInstance
调用 A 的实例方法 createCInstance&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注：APT——这些处理提取和处理 Annotation 的代码统称为 APT（Annotation Processing Tool)。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Java 编程思想&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot; md-link&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/skywang12345/p/3344137.html&quot;&gt;Java Annotation认知&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 23:58:00 +0000</pubDate>
<dc:creator>hncboy</dc:creator>
<og:description>注解的定义和使用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hncboy/p/12208132.html</dc:identifier>
</item>
<item>
<title>一文搞定Spring Boot + Vue 项目在Linux Mysql环境的部署（强烈建议收藏） - siwei718</title>
<link>http://www.cnblogs.com/siweihz/p/12206566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/siweihz/p/12206566.html</guid>
<description>&lt;p&gt;本文介绍Spring Boot、Vue 、Vue Element编写的项目，在Linux下的部署，系统采用Mysql数据库。按照本文进行项目部署，不迷路。&lt;/p&gt;

&lt;p&gt;典型的软件开发，经过“需求分析”,“概要设计”，“详细设计”，“开发及单元测试”，“前后端联调”，“生产环境上线”。到了发布到生产环节的环节，紧张的神经，终于可以松一口气了！！！&lt;/p&gt;
&lt;p&gt;且慢，部署也是很重要的一环，稍有不慎就会“前功尽弃”。&lt;/p&gt;
&lt;p&gt;开发中，每个人的开发环境、工具可能都不同。目前大部分人用Windows（Win 10）开发，部分用Mac系统开发，还有极少数用Linux系统开发。但，为了运行的稳定，开发的系统大部分都部署在Linux平台。本文采用Centos 7部署Spring Boot项目，并介绍前后端项目的打包和部署。&lt;/p&gt;

&lt;p&gt;1）开发环境说明&lt;/p&gt;
&lt;p&gt;本着一切为了“开发效率”，在项目开发的时候：&lt;/p&gt;
&lt;p&gt;后端采用了IntelliJ IDEA作为Spring Boot的开发工具（其实用Eclipse也是Ok的），用了典型“controller、service、dao三层架构”；&lt;/p&gt;
&lt;p&gt;前端采用Vs Code作为Vue及Vue Element的开发工具，用webpack进行项目打包，“地球人都知道，这里就不多啰嗦了”；&lt;/p&gt;
&lt;p&gt;用Git作为分布式版本控制系统；&lt;/p&gt;
&lt;p&gt;Mysql数据；&lt;/p&gt;
&lt;p&gt;用mybatis作为持久层框架。&lt;/p&gt;
&lt;p&gt;2）Centos 7安装Jdk，MariaDB&lt;/p&gt;
&lt;p&gt;Centos 7操作系统的安装，略！网上有大量的教程，不再赘述。&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;安装Jdk环境&lt;/p&gt;
&lt;p&gt;最简单的方式，莫过于用yum安装，一个命令搞定（千万别告诉我你还在用32位系统）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum install java-11-openjdk.x86_64&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;18&quot;&gt;
&lt;p&gt;安装MariaDB&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[注意]&lt;/strong&gt; 一般情况下Linux安装的时候会包含Mysql，这将导致MariaDb安装不成功。&lt;/p&gt;
&lt;p&gt;首先运行如下命令检查是否有Mysql：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rpm -qa | grep mariadb&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果系统里面预装了Mysql，则先卸载：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum remove mysql mysql-server mysql-libs compat-mysql51&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后添加源（都2020年了，不会用vi，拿什么来拯救你）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vi /etc/yum.repos.d/MariaDB.repo&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;[mariadb]&quot;&gt;
&lt;code&gt;[mariadb]
name = MariaDB
baseurl = http://yum.mariadb.org/10.2.4/centos7-amd64
gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB
gpgcheck=1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装MariaDb：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum -y install MariaDB-server MariaDB-client&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动MariaDb服务：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl start mariadb #启动服务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;加入开机启动：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;systemctl enable mariadb #设置开机启动&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3）开放防火墙端口&lt;/p&gt;
&lt;p&gt;默认情况下，防火墙拦截是不能访问的，此处我们开放80、22端口：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firewall-cmd --zone=public --add-port=80/tcp --permanent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firewall-cmd --zone=public --add-port=22/tcp --permanent&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;[注意]&lt;/strong&gt; 需要重启防火墙，命令是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firewall-cmd --reload&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看是否添加成功，这里我就不截图演示了：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;firewall-cmd --zone=public --list-ports&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;4） 前后端打包及部署&lt;/p&gt;
&lt;p&gt;忙碌了大半天，准备工作终于做好了。激动人心的时刻终于要来了！！！&lt;/p&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;前端项目打包&lt;/p&gt;
&lt;p&gt;前端项目采用webpack进行管理，编译非常简单，也是一个命令搞定(so easy!!!)：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;npm run build&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;运行该命令后，会在项目的根文件夹下生产一个&lt;code&gt;dist&lt;/code&gt;目录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/202001/600632-20200117192534648-1878557330.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;后端项目打包&lt;/p&gt;
&lt;p&gt;将前端项目拷贝到springboot项目的resources的static目录下，然后运行&lt;code&gt;mvn clean package&lt;/code&gt;构建项目，即可生成一个项目的jar文件，此处文件名为“myproject.jar”（该名称可以在pom文件中进行设定）。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;数据库部署&lt;/p&gt;
&lt;p&gt;安装MariaDb后，默认root用户是没有密码的，此时通过&lt;code&gt;mysql -uroot&lt;/code&gt;命令登录到MariaDB，然后通过如下命令修改密码为&lt;code&gt;654321&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  mysql&amp;gt; use mysql; 
  mysql&amp;gt; update user set password=password('654321') where user='root' and host='localhost'; 
  mysql&amp;gt; flush privileges; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后就可以导入数据库脚本了，我是通过&lt;code&gt;Navicat&lt;/code&gt;客户端操作的。当然还有其他的工具，需要经过“大象装冰箱”三步走：&lt;/p&gt;
&lt;p&gt;新建数据库，设置编码utf-8，导入Sql文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;运行并见证奇迹&lt;/p&gt;
&lt;p&gt;我们通过如下命令运行项目，如未报错，则可以通过&lt;code&gt;http://ip&lt;/code&gt;访问项目：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;nohup java -jar myproject.jar &amp;gt;log.txt &amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目经过辛苦的开发，终于进入上线，试运行。大公司一般会有专门人员负责部署工作，一般的小公司，开发人员要“全栈”。从需求，开发，测试，部署，等等都要负责。&lt;/p&gt;
&lt;p&gt;此文不涉及自动化部署，也不谈docker等方式部署。&lt;/p&gt;
&lt;p&gt;传统工艺，纯手工打造，值得拥有！&lt;/p&gt;
&lt;p&gt;本文是个人项目部署的经验总结，结合了互联网上众多成功案例，不敢独自居功。&lt;/p&gt;
&lt;p&gt;如果您阅读本文后哪怕有一丢丢收获，请不要吝啬你手中&lt;strong&gt;关注&lt;/strong&gt;和&lt;strong&gt;点赞&lt;/strong&gt;的权力，谢谢！&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 23:31:00 +0000</pubDate>
<dc:creator>siwei718</dc:creator>
<og:description>本文介绍Spring Boot、Vue 、Vue Element编写的项目，在Linux下的部署，系统采用Mysql数据库。按照本文进行项目部署，不迷路。 1. 前言 典型的软件开发，经过“需求分析”</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/siweihz/p/12206566.html</dc:identifier>
</item>
<item>
<title>Netty之缓冲区ByteBuf解读（一） - ytao丨杨滔</title>
<link>http://www.cnblogs.com/ytao-blog/p/12208074.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ytao-blog/p/12208074.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021245631-573677110.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Netty 在数据传输过程中，会使用缓冲区设计来提高传输效率。虽然，Java 在 NIO 编程中已提供 ByteBuffer 类进行使用，但是在使用过程中，其编码方式相对来说不太友好，也存在一定的不足。所以高性能的 Netty 框架实现了一套更加强大，完善的 ByteBuf，其设计理念也是堪称一绝。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在分析 ByteBuf 之前，先简单讲下 ByteBuffer 类的操作。便于更好理解 ByteBuf 。&lt;/p&gt;
&lt;p&gt;ByteBuffer 的读写操作共用一个位置指针，读写过程通过以下代码案例分析：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 分配一个缓冲区，并指定大小
ByteBuffer buffer = ByteBuffer.allocate(100);
// 设置当前最大缓存区大小限制
buffer.limit(15);
System.out.println(String.format(&quot;allocate: pos=%s lim=%s cap=%s&quot;, buffer.position(), buffer.limit(), buffer.capacity()));

String content = &quot;ytao公众号&quot;;
// 向缓冲区写入数据
buffer.put(content.getBytes());
System.out.println(String.format(&quot;put: pos=%s lim=%s cap=%s&quot;, buffer.position(), buffer.limit(), buffer.capacity()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中打印了缓冲区三个参数，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;position 读写指针位置&lt;/li&gt;
&lt;li&gt;limit 当前缓存区大小限制&lt;/li&gt;
&lt;li&gt;capacity 缓冲区大小&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021246669-1655902162.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们写入内容后，读写指针值为 13，&lt;code&gt;ytao公众号&lt;/code&gt;英文字符占 1 个 byte，每个中文占 4 个 byte，刚好 13，小于设置的当前缓冲区大小 15。&lt;/p&gt;
&lt;p&gt;接下来，读取内容里的 ytao 数据：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;buffer.flip();
System.out.println(String.format(&quot;flip: pos=%s lim=%s cap=%s&quot;, buffer.position(), buffer.limit(), buffer.capacity()));

byte[] readBytes = new byte[4];
buffer.get(readBytes);
System.out.println(String.format(&quot;get(4): pos=%s lim=%s cap=%s&quot;, buffer.position(), buffer.limit(), buffer.capacity()));

String readContent = new String(readBytes);
System.out.println(&quot;readContent:&quot;+readContent);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取内容需要创建个 byte 数组来接收，并制定接收的数据大小。&lt;/p&gt;
&lt;p&gt;在写入数据后再读取内容，必须主动调用&lt;code&gt;ByteBuffer#flip&lt;/code&gt;或&lt;code&gt;ByteBuffer#clear&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ByteBuffer#flip&lt;/code&gt;它会将写入数据后的指针位置值作为当前缓冲区大小，再将指针位置归零。会使写入数据的缓冲区改为待取数据的缓冲区，也就是说，读取数据会从刚写入的数据第一个索引作为读取数据的起始索引。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ByteBuffer#flip&lt;/code&gt;相关源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021246896-659423048.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ByteBuffer#clear&lt;/code&gt;则会重置 limit 为默认值，与 capacity 大小相同。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021247104-1570608989.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下读取剩余部分内容：&lt;/p&gt;
&lt;p&gt;第二次读取的时候，可使用&lt;code&gt;buffer#remaining&lt;/code&gt;来获取大于或等于剩下的内容的字节大小，该函数实现为&lt;code&gt;limit - position&lt;/code&gt;，所以当前缓冲区域一定在这个值范围内。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;readBytes = new byte[buffer.remaining()];
buffer.get(readBytes);
System.out.println(String.format(&quot;get(remaining): pos=%s lim=%s cap=%s&quot;, buffer.position(), buffer.limit(), buffer.capacity()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021247329-1358543721.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上操作过程中，索引变化如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021247641-1433221872.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;ByteBuf 有读写指针是分开的，分别是&lt;code&gt;buf#readerIndex&lt;/code&gt;和&lt;code&gt;buf#writerIndex&lt;/code&gt;，当前缓冲器大小&lt;code&gt;buf#capacity&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里缓冲区被两个指针索引和容量划分为三个区域：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0 -&amp;gt; readerIndex 为已读缓冲区域，已读区域可重用节约内存，readerIndex 值大于或等于 0&lt;/li&gt;
&lt;li&gt;readerIndex -&amp;gt; writerIndex 为可读缓冲区域，writerIndex 值大于或等于 readerIndex&lt;/li&gt;
&lt;li&gt;writerIndex -&amp;gt; capacity 为可写缓冲区域，capacity 值大于或等于 writerIndex&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021248153-1861384832.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;分配缓冲区&quot;&gt;分配缓冲区&lt;/h2&gt;
&lt;p&gt;ByteBuf 分配一个缓冲区，仅仅给定一个初始值就可以。默认是 256。初始值不像 ByteBuffer 一样是最大值，ByteBuf 的最大值是&lt;code&gt;Integer.MAX_VALUE&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ByteBuf buf = Unpooled.buffer(13);
System.out.println(String.format(&quot;init: ridx=%s widx=%s cap=%s&quot;, buf.readerIndex(), buf.writerIndex(), buf.capacity()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021248369-1760960618.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;写操作&quot;&gt;写操作&lt;/h2&gt;
&lt;p&gt;ByteBuf 写操作和 ByteBuffer 类似，只是写指针是单独记录的，ByteBuf 的写操作支持多种类型，有以下多个API：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021248746-587410623.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写入字节数组类型：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;String content = &quot;ytao公众号&quot;;
buf.writeBytes(content.getBytes());
System.out.println(String.format(&quot;write: ridx=%s widx=%s cap=%s&quot;, buf.readerIndex(), buf.writerIndex(), buf.capacity()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021248968-1219732117.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;索引示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021249442-1351435121.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;读操作&quot;&gt;读操作&lt;/h2&gt;
&lt;p&gt;一样的，ByteBuf 写操作和 ByteBuffer 类似，只是写指针是单独记录的，ByteBuf 的读操作支持多种类型，有以下多个API：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021249695-2018804715.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从当前 readerIndex 位置读取四个字节内容：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;byte[] dst = new byte[4];
buf.readBytes(dst);
System.out.println(new String(dst));
System.out.println(String.format(&quot;read(4): ridx=%s widx=%s cap=%s&quot;, buf.readerIndex(), buf.writerIndex(), buf.capacity()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021249927-584001076.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;索引示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021250107-764795118.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过上面的 ByteBuffer 分配缓冲区例子，向里面添加 [ytao公众号ytao公众号] 内容，使写入的内容大于 limit 的值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ByteBuffer buffer = ByteBuffer.allocate(100);
buffer.limit(15);

String content = &quot;ytao公众号ytao公众号&quot;;
buffer.put(content.getBytes());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果异常：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021250369-687653368.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内容字节大小超过了 limit 的值时，缓冲区溢出异常，所以我们每次写入数据前，得检查缓区大小是否有足够空间，这样对编码上来说，不是一个好的体验。&lt;/p&gt;
&lt;p&gt;使用 ByteBuf 添加同样的内容，给定同样的初始容器大小。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ByteBuf buf = Unpooled.buffer(15);
String content = &quot;ytao公众号ytao公众号&quot;;
buf.writeBytes(content.getBytes());
System.out.println(String.format(&quot;write: ridx=%s widx=%s cap=%s&quot;, buf.readerIndex(), buf.writerIndex(), buf.capacity()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021250568-1205855674.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面打印信息，可以看到 cap 从设置的 15 变为了 64，当我们容器大小不够时，就是进行扩容，接下来我们分析扩容过程中是如何做的。&lt;br/&gt;进入 writeBytes 里面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021250770-2112511821.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;校验写入内容长度：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021250962-85076815.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在可写区域检查里：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果写入内容为空，抛出非法参数异常。&lt;/li&gt;
&lt;li&gt;如果写入内容大小小于或等于可写区域大小，则返回当前缓冲区，当中的&lt;code&gt;writableBytes()&lt;/code&gt;函数为可写区域大小&lt;code&gt;capacity - writerIndex&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果写入内容大小大于最大可写区域大小，则抛出索引越界异常。&lt;/li&gt;
&lt;li&gt;最后剩下条件的就是写入内容大小大于可写区域，小于最大区域大小，则分配一个新的缓冲区域。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021251284-1064864790.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在容量不足，重新分配缓冲区的里面，以 4M 为阀门：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果待写内容刚好为 4M, 那么就分配 4M 的缓冲区。&lt;/li&gt;
&lt;li&gt;如果待写内容超过这个阀门且与阀门值之和不大于最大容量值，就分配(阀门值+内容大小值)的缓冲区；如果超过这个阀门且与阀门值之和大于最大容量值，则分配最大容量的缓冲区。&lt;/li&gt;
&lt;li&gt;如果待写内容不超过阀门值且大于 64，那么待分配缓冲区大小就以 64 的大小进行倍增，直到相等或大于待写内容。&lt;/li&gt;
&lt;li&gt;如果待写内容不超过阀门值且不大于 64，则返回待分配缓冲区大小为 64。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021251581-1210747252.png&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Netty 实现的缓冲区，八个基本类型中，除了布尔类型，其他7种都有自己对应的 Buffer，但是实际使用过程中， ByteBuf 才是我们尝试用的，它可兼容任何类型。ByteBuf 在 Netty 体系中是最基础也是最重要的一员，要想更好掌握和使用 Netty，先理解并掌握 ByteBuf 是必需条件之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;个人博客： &lt;a href=&quot;https://ytao.top&quot; class=&quot;uri&quot;&gt;https://ytao.top&lt;/a&gt;&lt;br/&gt;关注公众号 【ytao】，更多原创好文&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1850167/202001/1850167-20200118021251888-186279802.jpg&quot; alt=&quot;我的公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 18:13:00 +0000</pubDate>
<dc:creator>ytao丨杨滔</dc:creator>
<og:description>Netty 在数据传输过程中，会使用缓冲区设计来提高传输效率。虽然，Java 在 NIO 编程中已提供 ByteBuffer 类进行使用，但是在使用过程中，其编码方式相对来说不太友好，也存在一定的不足</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ytao-blog/p/12208074.html</dc:identifier>
</item>
<item>
<title>RocketMQ客户端加载流程 - 啊驼</title>
<link>http://www.cnblogs.com/cxyAtuo/p/12208001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxyAtuo/p/12208001.html</guid>
<description>&lt;p&gt; 这节介绍RocketMQ客户端的启动流程，即Consumer和Producer的启动流程。&lt;/p&gt;
&lt;h4 id=&quot;客户端demo&quot;&gt;1. 客户端demo&lt;/h4&gt;
&lt;p&gt; 首先先看下客户端的demo&lt;/p&gt;
&lt;p&gt;Producer:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class SyncProducer {

    public static void main (String[] args) throws Exception {
        // 实例化消息生产者Producer
        DefaultMQProducer producer = new DefaultMQProducer (&quot;GroupTest&quot;);
        // 设置NameServer的地址
        producer.setNamesrvAddr (&quot;localhost:9876&quot;);
        // 启动Producer实例
        producer.start ();
        for (int i = 0; i &amp;lt; 100; i++) {
            // 创建消息，并指定Topic，Tag和消息体
            Message msg = new Message (&quot;TopicTest&quot; /* Topic */,
                &quot;TagA&quot; /* Tag */,
                (&quot;Hello RocketMQ &quot; + i).getBytes (RemotingHelper.DEFAULT_CHARSET) /* Message body */
            );
            // 发送消息到一个Broker
            SendResult sendResult = producer.send (msg);
            // 通过sendResult返回消息是否成功送达
            System.out.printf (&quot;%s%n&quot;, sendResult);
        }
        // 如果不再发送消息，关闭Producer实例。
        producer.shutdown ();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Consumer:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Consumer {

    public static void main (String[] args) throws InterruptedException, MQClientException {

        // 实例化消费者
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer (&quot;GroupTest&quot;);

        // 设置NameServer的地址
        consumer.setNamesrvAddr (&quot;localhost:9876&quot;);

        // 订阅一个或者多个Topic，以及Tag来过滤需要消费的消息
        consumer.subscribe (&quot;TopicTest&quot;, &quot;*&quot;);
        // 注册回调实现类来处理从broker拉取回来的消息
        consumer.registerMessageListener (new MessageListenerConcurrently () {
            @Override
            public ConsumeConcurrentlyStatus consumeMessage (List&amp;lt;MessageExt&amp;gt; msgs, ConsumeConcurrentlyContext context) {
                System.out.printf (&quot;%s Receive New Messages: %s %n&quot;, Thread.currentThread ().getName (), msgs);
                // 标记该消息已经被成功消费
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        // 启动消费者实例
        consumer.start ();
        System.out.printf (&quot;Consumer Started.%n&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Producer和Consumer的启动类似，在初始化然后进行必要设置（主要是客户端所属的Group和NameServer地址）后，执行start方法启动后台监听服务，事实上Producer和Consumer都是调用同一个类MQClientInstance的start方法，下图为继承关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/202001/1812801-20200118002843104-860880631.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DefaultMQproducer和DefaultMQPushConsumer都继承自ClientConfig，顾名思义ClientConfig表示客户端的配置，包括NameServer地址、客户端地址、客户端实例名等。由于Producer和Consumer都需要同Broker和NameServer交互，所以配置上有很多相同，这两个将主要功能的实现都委托给了对应的Impl(DefaultMQProducerImpl和DefaultMQPushConsumerImpl)。Impl内部调用了MQClientInstance来完成客户端同远程交互的主要功能，而Producer和Consumer则封装自己相关的行为，MQClientInstance内部又委托忒了MQClientAPIImpl。&lt;/p&gt;
&lt;h4 id=&quot;producer的启动&quot;&gt;2. Producer的启动&lt;/h4&gt;
&lt;p&gt; DefaultMQProducer的启动如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/202001/1812801-20200118002843361-774008944.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DefaultMQProducer将start委托给了DefaultMQProducerImpl来完成，主要过程为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DefaultMQProducerImpl先标记客户端当前状态为START_FAILED（初始状态为CREATE_JUST）&lt;/li&gt;
&lt;li&gt;调用MQClientManager的getAndCreateMQClientInstance方法获取MQClientInstance，每个客户端实例都会对应一个MQClientInstance，并由MQClientManager管理。MQClientManager内部使用一个Map维护各客户端的关系，key为clientId(格式为ip@instName,instName为pid)，value为MQClientInstance实例。当key不存在时则会初始化一个实例，在初始化时连带初始化MQClientAPIImpl、NettyRemoteClient等。&lt;/li&gt;
&lt;li&gt;调用MQClientInstance的registerProducer方法，注册当前客户端自身。实现上是客户端放入client实例缓存中，定时器定时上报，后面会说。&lt;/li&gt;
&lt;li&gt;调用MQClientInstance的start方法，启动客户端的后台任务，该方法是重点，后面会介绍。&lt;/li&gt;
&lt;li&gt;标记客户端当前状态为RUNNING&lt;/li&gt;
&lt;li&gt;调用MQClientInstance的sendHeartbeatToAllBrokerWithLock方法，向所有Broker上报心跳&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;consumer的启动&quot;&gt;3. Consumer的启动&lt;/h4&gt;
&lt;p&gt; DefaultMQPushConsumer的启动如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/202001/1812801-20200118002843623-1822496498.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DefaultMQPushConsumer同样将start委托给了DefaultMQPushConsumerImpl来完成，流程上也相似。但相比DefaultMQProducer多了很多其他组件来辅助消费过程，如rebalance、offset管理等，主要过程为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DefaultMQPushConsumerImpl先标记客户端当前状态为START_FAILED（初始状态为CREATE_JUST）&lt;/li&gt;
&lt;li&gt;同步设置RebalanceImpl的topic(Map&amp;lt;/*topic*/String,/*sub expression*/String&amp;gt;)信息&lt;/li&gt;
&lt;li&gt;同DefaultMQProducer一致，调用MQClientManager的getAndCreateMQClientInstance方法获取MQClientInstance，每个客户端实例都会对应一个MQClientInstance，并由MQClientManager管理。MQClientManager内部使用一个Map维护各客户端的关系，key为clientId(格式为ip@instName)，value为MQClientInstance实例。当key不存在时则会初始化一个实例，在初始化时连带初始化MQClientAPIImpl、NettyRemoteClient等。这里需要说明的是，RocketMQ中Consumer的消费模式分为CLUSTERING和BROADCASTING，即集群消费和广播消费。区别在于集群消费时，一条消息只会被一个实例消费，即各实例会平分所有的消息；而广播消费时所有实例都会收到同一条消息。体现在clientId的是，集群模式下instName为pid，而广播模式instName为DEFAULT。&lt;/li&gt;
&lt;li&gt;设置RebalanceImpl属性，包括所在Group、消费模式、消息分配策略(平均分配q的策略)&lt;/li&gt;
&lt;li&gt;初始化PlullAPIWrapper,设置消息过滤器钩子列表&lt;/li&gt;
&lt;li&gt;初始化OffsetStore，设置offset的存储模式，广播模式使用本地存储；集群模式使用远程存储&lt;/li&gt;
&lt;li&gt;初始化ConsumeMessageService，根据监听器类型设定消息消费模式(顺序消费/并行消费)，pull模式需要自己指定offset，push不需要设定。&lt;/li&gt;
&lt;li&gt;启动ConsumeMessageService&lt;/li&gt;
&lt;li&gt;同DefaultMQProducer一致，调用MQClientInstance的registerProducer方法，注册当前客户端自身。实现上是客户端放入client实例缓存中，定时器定时上报，后面会说。&lt;/li&gt;
&lt;li&gt;调用MQClientInstance的start方法，启动客户端的后台任务，该方法是重点，后面会介绍。&lt;/li&gt;
&lt;li&gt;标记客户端当前状态为RUNNING&lt;/li&gt;
&lt;li&gt;判断监听信息是否发生改变，从namesrv更新topic的路由信息&lt;/li&gt;
&lt;li&gt;调用MQClientInstance的checkClientInBroker方法，确认该实例已经在broker注册成功，否则抛异常&lt;/li&gt;
&lt;li&gt;调用MQClientInstance的sendHeartbeatToAllBrokerWithLock方法，向所有Broker上报心跳&lt;/li&gt;
&lt;li&gt;调用MQClientInstance的rebalanceImmediately方法，触发一次rebalance&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; DefaultMQPushConsumer为推模式，RocketMQ还提供了拉模式来消费消息，实现类为DefaultMQPullConsumer，启动过程类似，推模式是用拉模式来实现的，重点实现都在MQClientInstace中。&lt;/p&gt;
&lt;h4 id=&quot;mqclientinstance&quot;&gt;4. MQClientInstance&lt;/h4&gt;
&lt;p&gt; MQClientInstance为一个门户类，组合了各功能，如下，包括Rebalance、消费数据统计、生产消息、消费消息等,这些都有对应的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/202001/1812801-20200118002843925-24056704.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 上面说过，Producer和Consumer在启动的时候，都会在内部先初始化一个MQClientInstance对象，然后调用其start方法启动对应的后台程序，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/202001/1812801-20200118002844419-1705602600.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MQClientInstance的start方法除了调用自身进行准备工作外，也调用了其他组件的start方法开始它们的准备工作，主要流程为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先标记客户端当前状态为START_FAILED（初始状态为CREATE_JUST）&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;若没有指定nameserver地址，则调用MQClientAPIImpl同步获取一次（通过设置的Http endpoint同步）&lt;/li&gt;
&lt;li&gt;调用MQClientAPIImpl的start方法，主要是初始化Netty客户端，启动netty client初始化任务，连接的建立发生在第一次请求时&lt;/li&gt;
&lt;li&gt;开启MQClientInstance的定时任务，包括：
&lt;ol&gt;&lt;li&gt;如果没有指定nameserver地址，每两分钟从配置的endpoint处同步nameserver地址&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;定时从namesrv同步topic路由信息&lt;/li&gt;
&lt;li&gt;定时清除下线的broker信息;发送心跳&lt;/li&gt;
&lt;li&gt;定时持久化消费者消费的offset信息&lt;/li&gt;
&lt;li&gt;每1分钟调整线程池的大小&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调用PullMessageService的start方法，启动拉取消息线程&lt;/li&gt;
&lt;li&gt;调用RebalanceService的start方法，启动rebalance线程&lt;/li&gt;
&lt;li&gt;调用内部Producer(CLIENT_INNER_PRODUCER)的start方法&lt;/li&gt;
&lt;li&gt;标记客户端当前状态为RUNNING&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面详细介绍下各个过程。&lt;/p&gt;
&lt;h5 id=&quot;mqclientapiimpl.fetchnameserveraddr&quot;&gt;4.2. MQClientAPIImpl.fetchNameServerAddr&lt;/h5&gt;
&lt;p&gt; 该方法用于更新NameServer地址，该方法会从&lt;code&gt;http://xxx:port/rocketmq/yyy&lt;/code&gt;，默认8080端口(如果xxx中没有:，即不带端口时)中获取NameServer地址(xxx为域名，由系统配置项rocketmq.namesrv.domain控制，默认为jmenv.tbsite.net；yyy为访问路径，由系统配置项rocketmq.namesrv.domain.subgroup控制，默认为nsaddr)。该地址要求返回结果为一个ip列表，以;隔开，如果获取回来的地址跟现有的地址不一致则会更新缓存的NameServer地址列表。解析出来的地址列表用于根据NettyRemotingClient内部持有的变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final AtomicReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; namesrvAddrList = new AtomicReference&amp;lt;List&amp;lt;String&amp;gt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;mqclientapiimpl.start&quot;&gt;4.3. MQClientAPIImpl.start&lt;/h5&gt;
&lt;p&gt; 该方法在内部调用了NettyRemotingClient的start方法，用于初始化Netty客户端。NettyRemotingClient是基于Netty实现的tcp协议客户端，主要流程为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化客户端bootstrap连接池&lt;/li&gt;
&lt;li&gt;设置处理链：编码、解码、空闲处理、连接管理(服务端)、请求分发&lt;/li&gt;
&lt;li&gt;每3秒清除超时的请求（netty主线程不处理逻辑）&lt;/li&gt;
&lt;li&gt;启动客户端的事件处理器，处理IDLE、CLOSE、CONNECT、EXCEPTION事件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于NettyRemotingClient后面会专门进行讲解，这里只介绍在客户端启动时其做了哪些动作。&lt;/p&gt;
&lt;h5 id=&quot;mqclientinstance.updatetopicrouteinfofromnameserver&quot;&gt;4.4.2. MQClientInstance.updateTopicRouteInfoFromNameServer&lt;/h5&gt;
&lt;p&gt; 该方法用于根据客户端实例关注的所有topic的路由信息，包括客户端监听的topic以及producer生产的topic。首先会遍历从MQClientInstance内部的consumerTable和consumerTable的客户端实例，拿到所有的topic信息，然后挨个更新topic的路由。&lt;/p&gt;
&lt;p&gt; 同步topic路由时，会通过NettyRemotingClient选择一个NameServer获取topic路由信息，然后判断topic信息是否发生了更改，主要比较topic所对应的Queue和Broker是否发生了更改。若路由信息发生了更改则会同步topic所在的broker地址列表，即内部的brokerAddrTable属性；接着同步produer关注的topic路由信息，即producerTable属性；接着同步consumer订阅的topic路由信息，即consumerTable属性；最后更新本地topic信息，即topicRouteTable属性。&lt;/p&gt;
&lt;h5 id=&quot;mqclientinstance.sendheartbeattoallbrokerwithlock&quot;&gt;4.4.3. MQClientInstance.sendHeartbeatToAllBrokerWithLock&lt;/h5&gt;
&lt;p&gt; 该方法会遍历MQClient所持有的各个producer和consumer，将客户端信息构造为HeartbeatData对象，然后调用MQClientAPIImpl的sendHearbeat方法，向所有的broker上报心跳数据。心跳内容包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Consumer:所有Consumer的Group、消费类型、消息模式、消费起始offset、订阅消息的筛选类型等&lt;/li&gt;
&lt;li&gt;Producer:所有Producer的group&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;mqclientinstance.persistallconsumeroffset&quot;&gt;4.4.4. MQClientInstance.persistAllConsumerOffset&lt;/h5&gt;
&lt;p&gt; 该方法会遍历consumerTable里的所有MQConsumer对象，获取每个队列处理的MessageQueue，然后调用OffsetStore持久化所有的MessageQueue。OffsetStore后面会专门进行讲解。&lt;/p&gt;
&lt;h5 id=&quot;mqclientinstance.adjustthreadpool&quot;&gt;4.4.5. MQClientInstance.adjustThreadPool&lt;/h5&gt;
&lt;p&gt; 该方法主要是动态调整DefaultMQPushConsumerImpl(推模式)客户端消费线程池的大小。前面说过推模式是通过包装拉模式来实现的，内部都依赖PullAPIWrapper。实现上推模式多了一个ConsumeMessageService定时使用拉模式消费消息，该实现需要一个线程池，adjustThreadPool就是动态调整该线程池的大小。关于客户端消费消息的过程，后面也会专门进行讲解。&lt;/p&gt;
&lt;h5 id=&quot;pullmessageservice.start&quot;&gt;4.5. PullMessageService.start&lt;/h5&gt;
&lt;p&gt; PullMessageService用于封装拉模式以实现推模式。它会循环从内部的LinkedBlockingQueue&amp;lt;PullRequest&amp;gt;中拿出PullRequest对象(消费q消息封装的对象)，选取一个可用的客户端实例DefaultMQPushConsumerImpl，调用其pullMessage方法.该方法会判断消费进度，决定是立即消费还是延迟消费，如果是延迟消费则再放回LinkedBlockingQueue中等待消费;如果是直接消费，则调用PullMessageService(拉模式)的executePullRequestImmediately消费消息.&lt;/p&gt;
&lt;p&gt; PullMessageService的基础关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/202001/1812801-20200118002844921-922092608.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;PullMessageService.start内部主要是启动线程，该线程会循环执行执行任务，具体实现会在后续介绍消息消费的时候提及。&lt;/p&gt;
&lt;h5 id=&quot;rebalanceservice.start&quot;&gt;4.6. RebalanceService.start&lt;/h5&gt;
&lt;p&gt; 该方法用于启动rebalance任务。RebalanceService同PullMessageService相同，都继承自ServiceThread类，，并实现了run方法。RebalanceService在run方法中等待一定时间(默认20S,可以通过rocketmq.client.rebalance.waitInterval配置具体时间)后会调用MQClientInstance.doRebalance执行具体的动作。具体实现会在后续介绍rebalance实现的时候提及。&lt;/p&gt;
&lt;h5 id=&quot;defaultmqpushconsumerimpl.start&quot;&gt;4.7. DefaultMQPushConsumerImpl.start&lt;/h5&gt;
&lt;p&gt; 在上面&lt;code&gt;2.&lt;/code&gt;时有提及该流程，这里的DefaultMQPushConsumerImpl对象是Group为&lt;code&gt;CLIENT_INNER_PRODUCER&lt;/code&gt;的内部对象。&lt;/p&gt;
&lt;p&gt; 客户端的启动过程就如上面介绍，下面附上该部分当时源码阅读过程做的笔记简图，该图描述了客户端启动过程的大致过程：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1812801/202001/1812801-20200118002845169-1246766249.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;更多原创内容请搜索微信公众号：啊驼（doubaotaizi）&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 17 Jan 2020 16:29:00 +0000</pubDate>
<dc:creator>啊驼</dc:creator>
<og:description>&amp;amp;emsp;这节介绍RocketMQ客户端的启动流程，即Consumer和Producer的启动流程。 1. 客户端demo &amp;amp;emsp;首先先看下客户端的demo Producer:</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxyAtuo/p/12208001.html</dc:identifier>
</item>
<item>
<title>关于Log4Net的使用及配置方式 - shanzm</title>
<link>http://www.cnblogs.com/shanzhiming/p/12207896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanzhiming/p/12207896.html</guid>
<description>&lt;p&gt;志铭-2020年1月17日 23:18:37&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;简介&quot;&gt;0.简介&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Log4Net库是Apache log4j框架在 .NET平台下的实现，其开源免费。它可以将日志分不同的等级，以不同的格式，输出到不同的媒介。&lt;/li&gt;
&lt;li&gt;官网地址：http://logging.apache.org/log4net/index.html&lt;/li&gt;
&lt;li&gt;Log4Net开源地址：https://github.com/apache/logging-log4net/&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h3 id=&quot;安装程序包&quot;&gt;1.安装程序包&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;NuGet:&lt;code&gt;Install-Package log4net -Version 2.0.8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;我发现网上一些关于Log4Net的配置的文章中的配置在我的项目中无法运行，所以以下关于Log4Net的使用是在基于 .net 4.6.1的 ASP .NET MVC项目中，开发工具VS2015。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h3 id=&quot;配置文件示例&quot;&gt;2.配置文件示例&lt;/h3&gt;
&lt;p&gt;在项目（此处为Web项目）的配置文件Web.config中添加配置信息&lt;/p&gt;
&lt;h5 id=&quot;注意事项&quot;&gt;2.1注意事项：&lt;/h5&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;strong&gt;&quot;&amp;lt;configSections&amp;gt;&quot;节点必须配置在&amp;lt;configuration&amp;gt;之后的第一个位置，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;否则报错，提示：“只允许一个 &amp;lt;configSections&amp;gt; 元素。它必须是根 &amp;lt;configuration&amp;gt; 元素第一个子元素”&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;可以有多个&quot; &amp;lt;appender name=&quot;XXXX&quot;&amp;gt; &amp;lt;/appender&amp;gt;&quot;,只要在&quot;&amp;lt;root&amp;gt;&amp;lt;/root&amp;gt;&quot;中添加相应的“&amp;lt;appender-ref ref=&quot;XXXX&quot;&amp;gt;”&lt;br/&gt;即可以设置多个日志输出的形式，下面我们是把日志以txt文件的形式保存在App_Data/Log文件夹中的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在ASP .NET MVC项目中使用Log4Net,首先要在Global.asax.cs中初始化Log4Net，即添加&lt;code&gt;log4net.Config.XmlConfigurator.Configure();&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;示例&quot;&gt;2.2示例&lt;/h5&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;  &amp;lt;!-- ................为Log4Net添加的配置.....开始................--&amp;gt;

  &amp;lt;configSections&amp;gt;
    &amp;lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler,log4net&quot; /&amp;gt;
  &amp;lt;/configSections&amp;gt;

  &amp;lt;log4net&amp;gt;
    &amp;lt;root&amp;gt;
      &amp;lt;level value=&quot;DEBUG&quot; /&amp;gt;&amp;lt;!--定义此记录器的日志记录级别。此记录器仅接受此级别（此处即DEBUG级别）或更高级别的事件--&amp;gt;
      &amp;lt;appender-ref ref=&quot;RollingFileTracer&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
    &amp;lt;appender name=&quot;RollingFileTracer&quot; type=&quot;log4net.Appender.RollingFileAppender,log4net&quot;&amp;gt;
      &amp;lt;param name=&quot;File&quot; value=&quot;App_Data/Log/&quot; /&amp;gt;&amp;lt;!--日志文件的保存位置为：App_Data/Log/Log.txt--&amp;gt;
      &amp;lt;param name=&quot;AppendToFile&quot; value=&quot;false&quot; /&amp;gt;&amp;lt;!--日志文件为后续内容附加到已有文件（若是false，则为后续覆盖向前的内存）--&amp;gt;
      &amp;lt;param name=&quot;RollingStyle&quot; value=&quot;Composite&quot; /&amp;gt;&amp;lt;!--根据文件的大小和日期滚动文件--&amp;gt;
      &amp;lt;param name=&quot;MaxSizeRollBackups&quot; value=&quot;10&quot; /&amp;gt;&amp;lt;!--备份文件的个数--&amp;gt;
      &amp;lt;param name=&quot;MaximumFileSize&quot; value=&quot;1MB&quot; /&amp;gt;&amp;lt;!--如果我们将最大文件大小设置为1MB并将maxSizeRollBackups设置为10 MB，那么根据日期或文件大小，它将只保留最后10MB的文件--&amp;gt;
      &amp;lt;param name=&quot;DatePattern&quot; value=&quot;&amp;amp;quot;Logs_&amp;amp;quot;yyyyMMdd&amp;amp;quot;.txt&amp;amp;quot;&quot; /&amp;gt;&amp;lt;!--日志文件名为Logs_20200114.txt的类似格式--&amp;gt;
      &amp;lt;param name=&quot;StaticLogFileName&quot; value=&quot;false&quot; /&amp;gt;&amp;lt;!--日志文件名，是否固定不变--&amp;gt;
      
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout,log4net&quot;&amp;gt; &amp;lt;!--日志记录的格式--&amp;gt;
        &amp;lt;!--&amp;lt;param name=&quot;ConversionPattern&quot; value=&quot;%d [%t] %-5p %c - %m%n&quot; /&amp;gt;格式为：时间+[线程]+级别+项目.Controller -messsage+exception.innerMessage--&amp;gt;
        &amp;lt;param name=&quot;ConversionPattern&quot; value=&quot;记录时间：%date 线程ID:[%thread] 日志级别：%-5level 出错类：%logger property:[%property{NDC}] - 错误描述：%message%newline&quot; /&amp;gt;
        &amp;lt;!--格式类似：记录时间：2020-01-15 20:34:37,946 线程ID:[6] 日志级别：DEBUG 出错类：_008Log4Net.Controllers.HomeController property:[(null)] - 错误描述：Hi I am log4net Debug Level--&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
  &amp;lt;/log4net&amp;gt;
  &amp;lt;!-- ................为Log4Net添加的配置.....结束................--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置细节说明&quot;&gt;2.3配置细节说明&lt;/h5&gt;
&lt;ul readability=&quot;9.2111111111111&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;level value=&quot;DEBUG&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;写入日记的级别：DEBUG以上级别（包含该级别）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;File&quot; value=&quot;App_Data/Log/&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;日志的保存位置：&lt;code&gt;App_Data/Log/&lt;/code&gt;, 因为App_Data文件夹下的文件无法被用户下载，不希望访问者下载的文件放到这里(如果是控制台项目是生成到 bin\Debug 下)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;AppendToFile&quot; value=&quot;false&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;日志文件为后续内容附加到已有文件（若是false，则为后续覆盖向前的内存）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.48598130841122&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;RollingStyle&quot; value=&quot;Composite&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;见 &lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12207896.html#JumpTo6&quot;&gt;6.日志文件变换方式(回滚方式)：RollingStyle&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;layout type=&quot;log4net.Layout.PatternLayout,log4net&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;见&lt;a href=&quot;https://www.cnblogs.com/shanzhiming/p/12207896.html#JumpTo5&quot;&gt;5.2格式示例1&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;日志写入文件时，不锁定文本文件，防止多线程时不能写Log,&lt;br/&gt;官方说线程非安全,所以示例中没有写此配置，若是需要可以添加：&lt;br/&gt;&lt;code&gt;&amp;lt;param name=&quot;lockingModel&quot; type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h3 id=&quot;日记的级别level&quot;&gt;3.日记的级别：Level&lt;/h3&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在Log4Net中日志的level: &lt;strong&gt;OFF &amp;gt; FATAL &amp;gt; ERROR &amp;gt; WARN &amp;gt; INFO &amp;gt; DEBUG &amp;gt; ALL&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一般正式项目中只记录InFo以上&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Undone：怎么区分级别（什么时候用什么等级）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h3 id=&quot;日志的输出源appenders&quot;&gt;4.日志的输出源：Appenders&lt;/h3&gt;
&lt;p&gt;Appenders用来定义日志的输出方式，可以保存为文件，可以保存到数据库，可以发送邮件，可以写到远程接收端。&lt;/p&gt;
&lt;p&gt;Appender节点下可以配置Filters和Layout来实现日志的过滤和输出格式&lt;/p&gt;
&lt;p&gt;在配置文件中配置如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;appender name=&quot;RollingFileTracer&quot; type=&quot;log4net.Appender.RollingFileAppender,log4net&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中的type属性可以设置日志保存的方式，具体的type参数值可以查阅 :&lt;a href=&quot;https://blog.csdn.net/ydm19891101/article/details/50561638&quot;&gt;非常完善的Log4net详细说明&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;常用的两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;type=&quot;log4net.Appender.RollingFileAppender&quot; 表示将日志以回滚文件的形式写到文件中。&lt;/li&gt;
&lt;li&gt;type=&quot;log4net.Appender.AdoNetAppender&quot;表示将日志记录到数据库中。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;&lt;h3 id=&quot;日志格式layout&quot;&gt;5.日志格式：Layout&lt;/h3&gt;
&lt;p&gt;在配置的Layout节点中可以设置日记记录的格式&lt;/p&gt;
&lt;h5 id=&quot;设置格式的参数&quot;&gt;5.1设置格式的参数&lt;/h5&gt;
&lt;blockquote readability=&quot;24&quot;&gt;
&lt;p&gt;%m(message):输出的日志消息，如ILog.Debug(…)输出的一条消息&lt;/p&gt;
&lt;p&gt;%n(new line):换行&lt;/p&gt;
&lt;p&gt;%d(datetime):输出当前语句运行的时刻&lt;/p&gt;
&lt;p&gt;%r(run time):输出程序从运行到执行到当前语句时消耗的毫秒数&lt;/p&gt;
&lt;p&gt;%t(thread id):当前语句所在的线程ID&lt;/p&gt;
&lt;p&gt;%p(priority):等同于：%level 日志的当前优先级别，即DEBUG、INFO、WARN…等&lt;/p&gt;
&lt;p&gt;%c(class):当前日志对象的名称&lt;/p&gt;
&lt;p&gt;%f(file):输出语句所在的文件名。&lt;/p&gt;
&lt;p&gt;%l(line)：输出语句所在的行号。&lt;/p&gt;
&lt;p&gt;%数字：表示该项的最小长度，如果不够，则用空格填充，如“%-5level”表示level的最小宽度是5个字符，如果实际长度不够5个字符则以空格填充。（&lt;strong&gt;因为日志的几个等级的单词长度不一样，通过设置字符长度，可以示日志更加整齐&lt;/strong&gt;）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h5 id=&quot;格式示例1&quot;&gt;5.2格式示例1&lt;/h5&gt;
&lt;p&gt;上面的配置文件中的格式：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--日志记录的格式--&amp;gt;
&amp;lt;layout type=&quot;log4net.Layout.PatternLayout,log4net&quot;&amp;gt; 
        &amp;lt;param name=&quot;ConversionPattern&quot; value=&quot;记录时间：%date 线程ID:[%thread] 日志级别：%-5level 出错类：%logger property:[%property{NDC}] - 错误描述：%message%newline&quot; /&amp;gt;
        &amp;lt;!--格式类似：--&amp;gt;
&amp;lt;/layout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上述布局，每一条日志的格式类似：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;记录时间：2020-01-15 20:34:37,946 线程ID:[6] 日志级别：DEBUG 出错类：_008Log4Net.Controllers.HomeController property:[(null)] - 错误描述：Hi I am log4net Debug Level&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;格式示例2&quot;&gt;5.3格式示例2&lt;/h5&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!--日志记录的格式--&amp;gt;
&amp;lt;layout type=&quot;log4net.Layout.PatternLayout,log4net&quot;&amp;gt; 
        &amp;lt;param name=&quot;ConversionPattern&quot; value=&quot;%d [%t] %-5p %c - %m%n&quot; /&amp;gt;
&amp;lt;/layout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上述布局，每一条日志的格式类似：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2020-01-15 21:09:17,362 [6] DEBUG _008Log4Net.Controllers.HomeController - Hi I am log4net Debug Level&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;格式示例3&quot;&gt;5.4格式示例3&lt;/h5&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
    &amp;lt;conversionPattern value=&quot;%newline %n记录时间：%date %n线程ID:[%thread] %n日志级别：  %-5level %n出错类：%logger property: [%property{NDC}] - %n错误描述：%message%newline %n&quot;/&amp;gt;
&amp;lt;/layout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照上述布局，每一条日志的格式类似：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;记录时间：2020-01-15 22:51:44,106 
线程ID:[7] 
日志级别：  ERROR 
出错类：_008Log4Net.Controllers.HomeController property: [(null)] - 
错误描述：Hi I am log4net Error Level
 
System.NullReferenceException: 未将对象引用设置到对象的实例。
   在 _008Log4Net.Controllers.HomeController.Index() 位置 F:\ForGit\ASP.NET MVC\008Log4Net\Controllers\HomeController.cs:行号 29
   &lt;/code&gt;
&lt;/pre&gt;


&lt;hr/&gt;&lt;h3 id=&quot;日志文件变换方式回滚方式rollingstyle&quot;&gt;6.日志文件变换方式（回滚方式）：RollingStyle&lt;/h3&gt;
&lt;h5 id=&quot;三种日志回滚方式&quot;&gt;6.1 三种日志回滚方式&lt;/h5&gt;
&lt;p&gt;回滚方式即&lt;strong&gt;按照何种方式产生多个日志文件&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;RollingStyle&quot; value=&quot;XXXX&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照何种方式产生多个日志文件，其中value参数的可选值：&lt;code&gt;Date&lt;/code&gt;(日期),&lt;code&gt;Size&lt;/code&gt;(文件大小), &lt;code&gt;Composite&lt;/code&gt;(混合)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;按照混合模式回滚&quot;&gt;6.2 按照混合模式回滚&lt;/h5&gt;
&lt;ul readability=&quot;9.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;RollingStyle&quot; value=&quot;Composite&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;按照混合模式产生多个日志文件（即既考虑时间，也文件考虑大小）&lt;/p&gt;
&lt;p&gt;上述示例中的选择使用混合模式生成日志文件，即一定时间内达到一定大小则生成新的一个日志文件&lt;/p&gt;
&lt;p&gt;以下两个节点设置日志文件的大小和数量&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;MaxSizeRollBackups&quot; value=&quot;10&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最大变换数量，如果超过这个数量则从第一个文件开始复写（即最多保持10个日志文件）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;MaximumFileSize&quot; value=&quot;1MB&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最大文件大小为1MB，支持KB,MB,GB&lt;/p&gt;
&lt;p&gt;注意根据以上两个参数：我们将最大文件大小设置为1MB并将文件变换数量设置为10，那么根据日期或文件大小，它将只保留最后（1*10）MB大小的日志文件。&lt;br/&gt;具体根据项目一定时间内可能产生的日志大小，可以进行文件大小和文件数量的合理分配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;按照时间回滚&quot;&gt;6.3 按照时间回滚&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;rollingStyle value=&quot;Date&quot;/&amp;gt;&lt;/code&gt;(注意这种写法和&lt;code&gt;&amp;lt;param name=&quot;RollingStyle&quot; value=&quot;Date&quot; /&amp;gt;&lt;/code&gt; 等价)&lt;/p&gt;
&lt;p&gt;示例：实现日志每一天一个文件夹，每一分钟一个文件&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- ................为Log4Net添加的配置.....开始................--&amp;gt;
&amp;lt;!----&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler,log4net&quot; /&amp;gt;
  &amp;lt;/configSections&amp;gt;
  
  &amp;lt;log4net&amp;gt;
    &amp;lt;root&amp;gt;
    &amp;lt;level value=&quot;ALL&quot;/&amp;gt;
    &amp;lt;appender-ref ref=&quot;RollingLogFileAppender&quot;/&amp;gt;
  &amp;lt;/root&amp;gt;
    &amp;lt;appender name=&quot;RollingLogFileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender,log4net&quot;&amp;gt;
      &amp;lt;file value=&quot;App_Data/Log/&quot;/&amp;gt;
      &amp;lt;appendToFile value=&quot;true&quot;/&amp;gt;
      &amp;lt;rollingStyle value=&quot;Date&quot;/&amp;gt;&amp;lt;!--按照时间回滚 --&amp;gt;
      &amp;lt;!--&amp;lt;datePattern value=&quot;yyyy\\yyyyMM\\yyyyMMdd'.txt'&quot;/&amp;gt;--&amp;gt;&amp;lt;!--日志文件夹格式：2020/202001/20200117.txt--&amp;gt;
      &amp;lt;datePattern value=&quot;yyyyMMdd\\yyyyMMddhhmm'.txt'&quot;/&amp;gt;&amp;lt;!--日志文件夹格式：20200117/202001170307.txt--&amp;gt;
      &amp;lt;staticLogFileName value=&quot;false&quot;/&amp;gt;
      
      &amp;lt;!--待研究：日志到底是保留多少，怎么自动删除就日志--&amp;gt;
      &amp;lt;MaxSizeRollBackups value=&quot;3&quot;/&amp;gt; &amp;lt;!--定义文件最大个数，超过按顺序删除--&amp;gt;
      &amp;lt;maximumFileSize value=&quot;6KB&quot; /&amp;gt; 
      
      &amp;lt;lockingModel type=&quot;log4net.Appender.FileAppender+MinimalLock&quot; /&amp;gt;
      &amp;lt;filter type=&quot;log4net.Filter.LevelRangeFilter&quot;&amp;gt;
        &amp;lt;levelMin value=&quot;ERROR&quot; /&amp;gt;
        &amp;lt;levelMax value=&quot;FATAL&quot; /&amp;gt;
      &amp;lt;/filter&amp;gt;
      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;%newline %n记录时间：%date %n线程ID:[%thread] %n日志级别：  %-5level %n出错类：%logger property: [%property{NDC}] - %n错误描述：%message%newline %n&quot;/&amp;gt;
      &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;
  &amp;lt;/log4net&amp;gt;
  &amp;lt;!-- ................为Log4Net添加的配置.....结束................--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;按照文件大小回滚&quot;&gt;6.4 按照文件大小回滚&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;RollingStyle&quot; value=&quot;Size&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;MaxSizeRollBackups&quot; value=&quot;10&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;param name=&quot;MaximumFileSize&quot; value=&quot;1MB&quot; /&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;示例：Undone&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;日志的过滤器filter&quot;&gt;7.日志的过滤器：Filter&lt;/h3&gt;
&lt;p&gt;filter可以过滤不同等级的日志&lt;/p&gt;
&lt;p&gt;按照：OFF &amp;gt; FATAL &amp;gt; ERROR &amp;gt; WARN &amp;gt; INFO &amp;gt; DEBUG &amp;gt; ALL的顺序可以设置一个范围&lt;/p&gt;
&lt;p&gt;实例：将不同级别的日记记录在不同的日志文件中&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;!-- ................为Log4Net添加的配置.....开始................--&amp;gt;
  &amp;lt;!--实现日志分等级记录在不同的日志文件中--&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler,log4net&quot; /&amp;gt;
  &amp;lt;/configSections&amp;gt;

  &amp;lt;log4net&amp;gt;
  &amp;lt;root&amp;gt;
    &amp;lt;level value=&quot;ALL&quot;/&amp;gt;
    &amp;lt;!--在root节点中设置为记录日记的所有等级--&amp;gt;
    &amp;lt;appender-ref ref=&quot;RollingFile&quot;/&amp;gt;
    &amp;lt;appender-ref ref=&quot;RollingFileTracer&quot;/&amp;gt;
  &amp;lt;/root&amp;gt;
  
    &amp;lt;appender name=&quot;RollingFile&quot; type=&quot;log4net.Appender.RollingFileAppender,log4net&quot;&amp;gt;
      &amp;lt;param name=&quot;File&quot; value=&quot;App_Data/Log/&quot; /&amp;gt;
      &amp;lt;param name=&quot;AppendToFile&quot; value=&quot;true&quot; /&amp;gt;
      &amp;lt;param name=&quot;RollingStyle&quot; value=&quot;Composite&quot; /&amp;gt;
      &amp;lt;param name=&quot;MaxSizeRollBackups&quot; value=&quot;10&quot; /&amp;gt;
      &amp;lt;param name=&quot;MaximumFileSize&quot; value=&quot;1MB&quot; /&amp;gt;
      &amp;lt;param name=&quot;DatePattern&quot; value=&quot;&amp;amp;quot;Logs_&amp;amp;quot;yyyyMMdd&amp;amp;quot;.txt&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;param name=&quot;StaticLogFileName&quot; value=&quot;false&quot; /&amp;gt;

      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;[%-5p %t] [%date{yyyy-MM-dd HH:mm:ss,fff}] %-5logger - %m%n&quot;/&amp;gt;
      &amp;lt;/layout&amp;gt;
      &amp;lt;filter type=&quot;log4net.Filter.LevelRangeFilter&quot;&amp;gt;
        &amp;lt;!--使用过滤器，过滤出WARN &amp;gt; INFO &amp;gt; DEBUG 等级并记录Logs_20200117.txt--&amp;gt;
        &amp;lt;levelMin value=&quot;DEBUG&quot; /&amp;gt;
        &amp;lt;levelMax value=&quot;WARN&quot; /&amp;gt;
      &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;appender name=&quot;RollingFileTracer&quot; type=&quot;log4net.Appender.RollingFileAppender,log4net&quot;&amp;gt;
      &amp;lt;param name=&quot;File&quot; value=&quot;App_Data/Log/&quot; /&amp;gt;
      &amp;lt;param name=&quot;AppendToFile&quot; value=&quot;true&quot; /&amp;gt;
      &amp;lt;param name=&quot;RollingStyle&quot; value=&quot;Composite&quot; /&amp;gt;
      &amp;lt;param name=&quot;MaxSizeRollBackups&quot; value=&quot;10&quot; /&amp;gt;
      &amp;lt;param name=&quot;MaximumFileSize&quot; value=&quot;1MB&quot; /&amp;gt;
      &amp;lt;param name=&quot;DatePattern&quot; value=&quot;&amp;amp;quot;Errors_&amp;amp;quot;yyyyMMdd&amp;amp;quot;.txt&amp;amp;quot;&quot; /&amp;gt;
      &amp;lt;param name=&quot;StaticLogFileName&quot; value=&quot;false&quot; /&amp;gt;

      &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
        &amp;lt;conversionPattern value=&quot;[%p] %m%n&quot;/&amp;gt;
      &amp;lt;/layout&amp;gt;
      &amp;lt;filter type=&quot;log4net.Filter.LevelRangeFilter&quot;&amp;gt;
        &amp;lt;!--使用过滤器，过滤出FATAL &amp;gt; ERROR等级并记录在Errors_20200117.txt（在程序中将抛异的日志记录为ERROR和FATAL等级）--&amp;gt;
        &amp;lt;levelMin value=&quot;ERROR&quot; /&amp;gt;
        &amp;lt;levelMax value=&quot;FATAL&quot; /&amp;gt;
      &amp;lt;/filter&amp;gt;
    &amp;lt;/appender&amp;gt;

  &amp;lt;/log4net&amp;gt;
  &amp;lt;!--................为Log4Net添加的配置.....结束................--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;h3 id=&quot;将日志记录在数据库中&quot;&gt;8.将日志记录在数据库中&lt;/h3&gt;
&lt;p&gt;示例：将日记记录在MS SQL Server数据库中&lt;/p&gt;
&lt;p&gt;在MS SQLServer中新建一个库，添加一个db_Log表，存放日记信息&lt;br/&gt;建表SQL：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE TABLE [dbo].[Log](
       [Id] [int] IDENTITY(1,1) NOT NULL,
       [Date] [datetime] NOT NULL,
       [Thread] [varchar](255) NOT NULL,
       [Level] [varchar](50) NOT NULL,
       [Logger] [varchar](255) NOT NULL,
       [Message] [varchar](4000) NOT NULL,
       [Exception] [varchar](2000) NULL
) ON [PRIMARY]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置信息：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt; &amp;lt;!-- ...................为Log4Net添加的配置.....开始...................--&amp;gt;
  &amp;lt;configSections&amp;gt;
    &amp;lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler,log4net&quot; /&amp;gt;
  &amp;lt;/configSections&amp;gt;
&amp;lt;!-- 数据库连接字符串 --&amp;gt;
  &amp;lt;connectionStrings&amp;gt;   
    &amp;lt;add name=&quot;ConnectionStringLogging&quot; connectionString=&quot;server=.;database=db_Tome1;uid=sa;pwd=shanzm&quot;
    providerName=&quot;System.Data.SqlClient&quot; /&amp;gt;
  &amp;lt;/connectionStrings&amp;gt;


  &amp;lt;log4net&amp;gt;
    &amp;lt;root&amp;gt;
      &amp;lt;level value=&quot;ALL&quot;&amp;gt;&amp;lt;/level&amp;gt;
      &amp;lt;appender-ref ref=&quot;AdoNetAppender&quot;&amp;gt;&amp;lt;/appender-ref&amp;gt;
    &amp;lt;/root&amp;gt;
    
    &amp;lt;appender name=&quot;AdoNetAppender&quot; type=&quot;log4net.Appender.AdoNetAppender&quot;&amp;gt;
      &amp;lt;bufferSize value=&quot;1&quot; /&amp;gt;
      &amp;lt;connectionType value=&quot;System.Data.SqlClient.SqlConnection,System.Data, 
      Version=1.0.3300.0, Culture=neutral, PublicKeyToken=b77a5c561934e089&quot; /&amp;gt;
      &amp;lt;connectionStringName value=&quot;ConnectionStringLogging&quot; /&amp;gt;
      &amp;lt;commandText value=&quot;INSERT INTO Log ([Date],[Thread],[Level],[Logger],[Message],[Exception]) 
      VALUES (@log_date, @thread, @log_level, @logger, @message, @exception)&quot; /&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@log_date&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;DateTime&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.RawTimeStampLayout&quot; /&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@thread&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;255&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%thread&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@log_level&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;50&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%level&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@logger&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;255&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%logger&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@message&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;4000&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&amp;gt;
          &amp;lt;conversionPattern value=&quot;%message&quot; /&amp;gt;
        &amp;lt;/layout&amp;gt;
      &amp;lt;/parameter&amp;gt;
      &amp;lt;parameter&amp;gt;
        &amp;lt;parameterName value=&quot;@exception&quot; /&amp;gt;
        &amp;lt;dbType value=&quot;String&quot; /&amp;gt;
        &amp;lt;size value=&quot;2000&quot; /&amp;gt;
        &amp;lt;layout type=&quot;log4net.Layout.ExceptionLayout&quot; /&amp;gt;
      &amp;lt;/parameter&amp;gt;
    &amp;lt;/appender&amp;gt;
  &amp;lt;/log4net&amp;gt;

  &amp;lt;!-- ...................为Log4Net添加的配置.....结束...................--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照以上方式配置，存放在数据库中的日志类似如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1576687/202001/1576687-20200117233108251-2063473079.png&quot; alt=&quot;数据库中日志&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;记入日志的原则&quot;&gt;9.记入日志的原则&lt;/h3&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;最后从网上找了一段写日志的原则，感觉还是很好的：&lt;/p&gt;
&lt;p&gt;【写日志的原则】&lt;/p&gt;
&lt;p&gt;.在catch后,把异常写入日志.&lt;/p&gt;
&lt;p&gt;.在调用第三方控件的开始和结束处.&lt;/p&gt;
&lt;p&gt;.在连接数据库的开始结束处.&lt;/p&gt;
&lt;p&gt;.除非必要,不要在循环体中加入日志,否则一旦出问题可能导致日志暴增.&lt;/p&gt;
&lt;p&gt;.在自己认为很重要的逻辑处写入日志.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr/&gt;&lt;h3 id=&quot;参考&quot;&gt;10.参考&lt;/h3&gt;

&lt;hr/&gt;&lt;h3 id=&quot;完整的案例源码&quot;&gt;11.完整的案例源码&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/shanzm/ASP.NET-MVC/tree/master/008Log4Net&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 15:33:00 +0000</pubDate>
<dc:creator>shanzm</dc:creator>
<og:description>[TOC] 志铭 2020年1月17日 23:18:37 0.简介 Log4Net库是Apache log4j框架在 .NET平台下的实现，其开源免费。它可以将日志分不同的等级，以不同的格式，输出到不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanzhiming/p/12207896.html</dc:identifier>
</item>
<item>
<title>H5录音音频可视化-实时波形频谱绘制、频率直方图 - xiangyuecn</title>
<link>http://www.cnblogs.com/xiangyuecn/p/12207875.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiangyuecn/p/12207875.html</guid>
<description>&lt;blockquote readability=&quot;7.1504424778761&quot;&gt;
&lt;p&gt;这段时间给&lt;a href=&quot;https://github.com/xiangyuecn/Recorder&quot;&gt;GitHub Recorder开源库&lt;/a&gt;添加了两个新的音频可视化功能，比以前单一的动态波形显示丰富了好多（下图后两行是不是比第一行看起来丰满些）；趁热打铁写了一个音频可视化相关扩展测试代码，下面这张就是测试Gif截图，看起来还算过得去，&lt;a href=&quot;https://xiangyuecn.github.io/Recorder/assets/%E5%B7%A5%E5%85%B7-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E5%8F%91Runtime.html?jsname=test.extensions.visualization&quot;&gt;测试地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMTUyNjY5LTFiNjI5YTY3OTBhZTc2ZjQuZ2lm&quot; alt=&quot;test.extensions.visualization&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这些波形、频率的计算和显示都是由纯js代码编写的，并未用到浏览器专有特性，因此可以方便的移植到其他语言实现，比如移植到Android、IOS原生实现。&lt;/p&gt;
&lt;h2 id=&quot;frequencyhistogramview音频可视化频率直方图显示&quot;&gt;FrequencyHistogramView音频可视化频率直方图显示&lt;/h2&gt;
&lt;p&gt;此功能源码：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/frequency.histogram.view.js&quot;&gt;frequency.histogram.view.js&lt;/a&gt; + &lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/lib.fft.js&quot;&gt;lib.fft.js&lt;/a&gt; 12kb大小源码，音频可视化频率直方图显示；外观为上面Gif图最后一行，可通过参数配置绘制成不同的外观。&lt;/p&gt;
&lt;p&gt;此扩展核心算法参考Java开源库&lt;a href=&quot;https://sourceforge.net/projects/jmp123/files/&quot;&gt;jmp123&lt;/a&gt;的代码编写的，&lt;code&gt;jmp123&lt;/code&gt;版本&lt;code&gt;0.3&lt;/code&gt;；直方图我特意优化主要显示0-5khz语音部分，其他高频显示区域较小，不适合用来展示音乐频谱。&lt;/p&gt;
&lt;p&gt;要获得PCM频率信息，需要将PCM由时域转换成频域，这里就用到了&lt;code&gt;FFT算法&lt;/code&gt;快速傅里叶变换，里面水很深我就没有深入研究了，这里直接用的jmp123里面的FFT实现，纯js代码实现100行不到。我们只管使用就ok了，假设有&lt;code&gt;44100hz&lt;/code&gt;采样率的&lt;code&gt;16位&lt;/code&gt;PCM数据，取&lt;code&gt;1024个&lt;/code&gt;采样数据经过FFT变换后，会输出&lt;code&gt;512个&lt;/code&gt;频率信息点，每个点之间的频率间隔为&lt;code&gt;44100/2/512=43hz&lt;/code&gt;，0hz是第1个点，1khz是第&lt;code&gt;1000/43&lt;/code&gt;个点，以此类推，最高能识别到&lt;code&gt;22050hz&lt;/code&gt;，有了这些频率点信息就能绘制不同频率下的音量幅度了，或者获得需要的频率分信号。&lt;/p&gt;
&lt;p&gt;通过FFT获得了频率信息，我们就可以绘制直方图了，将所有频率点按照我们需要绘制的直方图柱子数量平均划分成频段（jmp123里面采用的非线性划分，没看懂是什么原理，就采用更多人使用的线性划分），每个频段内取最大值并转换成音量，音量计算公式：&lt;code&gt;dB=20*Math.log10(maxValue)&lt;/code&gt;，然后计算实际的绘制高度：&lt;code&gt;DrawMaxHeight * dB / MaxDB&lt;/code&gt;，&lt;code&gt;DrawMaxHeight&lt;/code&gt;是你最大绘制高度（画布高度），&lt;code&gt;MaxDB&lt;/code&gt;为最大音量等于&lt;code&gt;20*Math.log10(0x7FFF)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;按照你想要的样子绘制完成后，通过实时数据驱动，一个可视化频率直方图就完工了。&lt;/p&gt;
&lt;h2 id=&quot;wavesurferview音频可视化波形显示&quot;&gt;WaveSurferView音频可视化波形显示&lt;/h2&gt;
&lt;p&gt;此功能源码：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/wavesurfer.view.js&quot;&gt;wavesurfer.view.js&lt;/a&gt;，7kb大小源码，音频可视化波形显示；外观为上面Gif图第二行，可通过参数配置绘制成不同的外观。&lt;/p&gt;
&lt;p&gt;外观和名称来源于&lt;a href=&quot;https://github.com/katspaugh/wavesurfer.js&quot;&gt;wavesurfer.js&lt;/a&gt;，这个波形的绘制直接简单的使用16位PCM的采样数值大小来进行线条的绘制，同一段音频绘制出的波形和Audition内显示的波形外观上几乎没有差异。&lt;/p&gt;
&lt;p&gt;由于是直接简单的用PCM的值大小来绘制线条，因此没有什么复杂的逻辑；对于绘制这种前进式的动画，无需每次都绘制所有线条，只需往另外一块画布上不断的在后面绘制即可，然后再绘制回显示的画布并移动位置，就能实现不断前进的动画，并且性能有保障。&lt;/p&gt;
&lt;h2 id=&quot;waveview动态显示波形&quot;&gt;WaveView动态显示波形&lt;/h2&gt;
&lt;p&gt;此功能源码：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder/blob/master/src/extensions/waveview.js&quot;&gt;waveview.js&lt;/a&gt;，4kb大小源码，录音时动态显示波形；外观为上面Gif图第一行，可通过参数配置绘制成不同的外观。&lt;/p&gt;
&lt;p&gt;这个是这个库最原始的一款可视化波形，参考&lt;a href=&quot;https://github.com/HaloMartin/MCVoiceWave&quot;&gt;MCVoiceWave&lt;/a&gt;库编写的，简单用用还可以，就是代码里面相位计算不太懂，波形的显示难控制和优化，微调一下参数波形就乱套。&lt;/p&gt;
&lt;p&gt;别说，这个波形还是很耐看的，相比其他可视化界面各有特色吧。&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;这些可视化波形、频谱要动起来就需要实时的输入pcm数据，输入源可以是麦克风实时录音数据块，也可以是音频文件解码的实时播放数据块。&lt;/p&gt;
&lt;p&gt;虽然目前只用在了我的H5录音库里面当做实时的音频展示，但移植到别的语言还是很轻松的，因为他们的源码都没有用到浏览器特有的东西。&lt;/p&gt;
&lt;p&gt;测试地址：&lt;a href=&quot;https://xiangyuecn.github.io/Recorder/assets/%E5%B7%A5%E5%85%B7-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E5%8F%91Runtime.html?jsname=test.extensions.visualization&quot; class=&quot;uri&quot;&gt;https://xiangyuecn.github.io/Recorder/assets/工具-代码运行和静态分发Runtime.html?jsname=test.extensions.visualization&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMTUyNjY5LWQwZjA0MWJlY2MwMGMxYjMucG5n?x-oss-process=image/format,png&quot; alt=&quot;完整测试界面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关源码请到GitHub中查阅：&lt;a href=&quot;https://github.com/xiangyuecn/Recorder&quot; class=&quot;uri&quot;&gt;https://github.com/xiangyuecn/Recorder&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;完.&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 15:18:00 +0000</pubDate>
<dc:creator>xiangyuecn</dc:creator>
<og:description>这段时间给 &amp;quot;GitHub Recorder开源库&amp;quot; 添加了两个新的音频可视化功能，比以前单一的动态波形显示丰富了好多（下图后两行是不是比第一行看起来丰满些）；趁热打铁写了一个音频</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiangyuecn/p/12207875.html</dc:identifier>
</item>
<item>
<title>搞定SpringBoot多数据源(2)：动态数据源 - Mason技术记录</title>
<link>http://www.cnblogs.com/masonlee/p/12207853.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/masonlee/p/12207853.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一句话概括：使用动态数据源对多个数据库进行操作，灵活，简洁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于多个数据库的处理，上一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/0J-FLYScYtEMnj0vZToX7g&quot;&gt;搞定SpringBoot多数据源(1)：多套源策略&lt;/a&gt;》已有提及，有多套数据源、动态数据源、参数化变更数据源等方式，本文是第二篇：“动态数据源”。动态数据源可以解决多套数据源的处理不够灵活、占用资源多等问题。用户可以根据实际的业务需要，统一操作逻辑，只要在需要切换数据源的进行处理即可。何为动态，其实是批切换数据源的时机可以动态选择，在需要的地方进行切换即可。&lt;/p&gt;
&lt;p&gt;本文延续上一篇文章的示例，以主从场景为示例，结合代码，对动态数据源的实现进行讲解，内容包括搭建动态数据源原理、动态数据源配置、动态数据源使用，AOP 注解方式切换数据源等。&lt;/p&gt;
&lt;p&gt;本文所涉及到的&lt;a href=&quot;https://github.com/mianshenglee/my-example/tree/master/multi-datasource&quot;&gt;示例代码&lt;/a&gt;:&lt;code&gt;https://github.com/mianshenglee/my-example/tree/master/multi-datasource&lt;/code&gt;，读者可结合一起看。&lt;/p&gt;

&lt;p&gt;Spring Boot 的动态数据源，本质上是把多个数据源存储在一个 Map 中，当需要使用某个数据源时，从 Map 中获取此数据源进行处理。而在 Spring 中，已提供了抽象类 &lt;code&gt;AbstractRoutingDataSource&lt;/code&gt; 来实现此功能。因此，我们在实现动态数据源的，只需要继承它，实现自己的获取数据源逻辑即可。动态数据源流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/multi-datasource/dynamic-datasource.png&quot; alt=&quot;动态数据源&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用户访问应用，在需要访问不同的数据源时，根据自己的数据源路由逻辑，访问不同的数据源，实现对应数据源的操作。本示例中的两数据库的分别有一个表 &lt;code&gt;test_user&lt;/code&gt;，表结构一致，为便于说明，两个表中的数据是不一样的。两个表结构可在&lt;a href=&quot;https://github.com/mianshenglee/my-example/tree/master/multi-datasource&quot;&gt;示例代码&lt;/a&gt;中的 &lt;code&gt;sql&lt;/code&gt; 目录中获取。&lt;/p&gt;

&lt;h2 id=&quot;说明及数据源配置&quot;&gt;3.1 说明及数据源配置&lt;/h2&gt;
&lt;h3 id=&quot;包结构说明&quot;&gt;3.1.1 包结构说明&lt;/h3&gt;
&lt;p&gt;本示例中，主要有以下几个包：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;├─annotation ---- // 自定义注解
├─aop ----------- // 切面
├─config -------- // 数据源配置
├─constants ----- // 常用注解
├─context ------- // 自定义上下文
├─controller ---- // 访问接口
├─entity -------- // 实体
├─mapper -------- // 数据库dao操作
├─service ------- // 服务类
└─vo ------------ // 视图返回数据&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据库连接信息配置&quot;&gt;3.1.2 数据库连接信息配置&lt;/h3&gt;
&lt;p&gt;Spring Boot 的默认配置文件是 &lt;code&gt;application.properties&lt;/code&gt; ，由于有两个数据库配置，独立配置数据库是好的实践，因此添加配置文件 &lt;code&gt;jbdc.properties&lt;/code&gt; ，添加以下自定义的主从数据库配置：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# master
spring.datasource.master.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.master.jdbc-url=jdbc:mysql://localhost:3306/mytest?useSSL=false&amp;amp;serverTimezone=GMT%2B8&amp;amp;characterEncoding=UTF-8
spring.datasource.master.username=root
spring.datasource.master.password=111111

# slave
spring.datasource.slave.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.slave.jdbc-url=jdbc:mysql://localhost:3306/my_test1?useSSL=false&amp;amp;serverTimezone=GMT%2B8&amp;amp;characterEncoding=UTF-8
spring.datasource.slave.username=root
spring.datasource.slave.password=111111&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;数据源配置&quot;&gt;3.1.3 数据源配置&lt;/h3&gt;
&lt;p&gt;根据连接信息，把数据源注入到 Spring 中，添加 &lt;code&gt;DynamicDataSourceConfig&lt;/code&gt; 文件，配置如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@PropertySource(&quot;classpath:config/jdbc.properties&quot;)
@MapperScan(basePackages = &quot;me.mason.demo.dynamicdatasource.mapper&quot;)
public class DynamicDataSourceConfig {
    @Bean(DataSourceConstants.DS_KEY_MASTER)
    @ConfigurationProperties(prefix = &quot;spring.datasource.master&quot;)
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }

    @Bean(DataSourceConstants.DS_KEY_SLAVE)
    @ConfigurationProperties(prefix = &quot;spring.datasource.slave&quot;)
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;此处使用 &lt;code&gt;PropertySource&lt;/code&gt; 指定配置文件，&lt;code&gt;ConfigurationProperties&lt;/code&gt; 指定数据源配置前缀&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;MapperScan&lt;/code&gt; 指定包，自动注入相应的 mapper 类。&lt;/li&gt;
&lt;li&gt;把数据源常量写在 &lt;code&gt;DataSourceConstants&lt;/code&gt; 类中&lt;/li&gt;
&lt;li&gt;从此配置可以看到，已经把 SqlSessionFactory 这个配置从代码中擦除，直接使用 Spring Boot 自动配置的 SqlSessionFactory 即可，无需我们自己配置。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;动态数据源设置&quot;&gt;3.2 动态数据源设置&lt;/h2&gt;
&lt;p&gt;前面的配置已把多个数据源注入到 Spring 中，接着对动态数据源进行配置。&lt;/p&gt;
&lt;h3 id=&quot;动态数据源配置&quot;&gt;3.2.1 动态数据源配置&lt;/h3&gt;
&lt;p&gt;** （1） 添加jdbc依赖 **&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-jdbc&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;** （2） 添加动态数据源类 **&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DynamicDataSource extends AbstractRoutingDataSource {
    @Override
    protected Object determineCurrentLookupKey() {
        // 此处暂时返回固定 master 数据源, 后面按动态策略修改
        return DataSourceConstants.DS_KEY_MASTER;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继承抽象类 &lt;code&gt;AbstractRoutingDataSource&lt;/code&gt; ，需要实现方法 &lt;code&gt;determineCurrentLookupKey&lt;/code&gt;，即路由策略。&lt;/li&gt;
&lt;li&gt;动态路由策略下一步实现，当前策略直接返回 master 数据源&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（3） 设置动态数据源为主数据源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在前面的数据源配置文件 &lt;code&gt;DynamicDataSourceConfig&lt;/code&gt; 中，添加以下代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
@Primary
public DataSource dynamicDataSource() {
    Map&amp;lt;Object, Object&amp;gt; dataSourceMap = new HashMap&amp;lt;&amp;gt;(2);
    dataSourceMap.put(DataSourceConstants.DS_KEY_MASTER, masterDataSource());
    dataSourceMap.put(DataSourceConstants.DS_KEY_SLAVE, slaveDataSource());
    //设置动态数据源
    DynamicDataSource dynamicDataSource = new DynamicDataSource();
    dynamicDataSource.setTargetDataSources(dataSourceMap);
    dynamicDataSource.setDefaultTargetDataSource(masterDataSource());

    return dynamicDataSource;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;使用 Map 保存多个数据源，并设置到动态数据源对象中。&lt;/li&gt;
&lt;li&gt;设置默认的数据源是 master 数据源&lt;/li&gt;
&lt;li&gt;使用注解 &lt;code&gt;Primary&lt;/code&gt; 优先从动态数据源中获取&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;同时，需要在 &lt;code&gt;DynamicDataSourceConfig&lt;/code&gt; 中，排除 &lt;code&gt;DataSourceAutoConfiguration&lt;/code&gt; 的自动配置，否则 会出现&lt;code&gt;The dependencies of some of the beans in the application context form a cycle&lt;/code&gt;的错误。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@EnableAutoConfiguration(exclude = { DataSourceAutoConfiguration.class })&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;动态选择数据源&quot;&gt;3.2.2 动态选择数据源&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1） 数据源 key 的上下文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面固定写了一个数据源路由策略，总是返回 master，显然不是我们想要的。我们想要的是在需要的地方，想切换就切换。因此，需要有一个动态获取数据源 key 的地方（我们称为上下文），对于 web 应用，访问以线程为单位，使用 ThreadLocal 就比较合适，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DynamicDataSourceContextHolder {
    /**
     * 动态数据源名称上下文
     */
    private static final ThreadLocal&amp;lt;String&amp;gt; DATASOURCE_CONTEXT_KEY_HOLDER = new ThreadLocal&amp;lt;&amp;gt;();
    /**
     * 设置/切换数据源
     */
    public static void setContextKey(String key){
        DATASOURCE_CONTEXT_KEY_HOLDER.set(key);
    }
    /**
     * 获取数据源名称
     */
    public static String getContextKey(){
        String key = DATASOURCE_CONTEXT_KEY_HOLDER.get();
        return key == null?DataSourceConstants.DS_KEY_MASTER:key;
    }

    /**
     * 删除当前数据源名称
     */
    public static void removeContextKey(){
        DATASOURCE_CONTEXT_KEY_HOLDER.remove();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（2） 设置动态数据 &lt;code&gt;DynamicDataSource&lt;/code&gt; 路由策略&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们需要达到的路由策略是，当设置数据源 key 到上下文，则从上下文中得到此数据源 key ，从而知道使用此对应的数据源。因此，修改前面 &lt;code&gt;DynamicDataSource&lt;/code&gt; 的 &lt;code&gt;determineCurrentLookupKey&lt;/code&gt; 方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
protected Object determineCurrentLookupKey() {
    return DynamicDataSourceContextHolder.getContextKey();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;动态数据源使用&quot;&gt;3.2.3 动态数据源使用&lt;/h3&gt;
&lt;p&gt;有了上面的动态路由选择，则不需要像之前的多套数据源那样，mapper、entity、service等都写一套相同逻辑的代码，因为是主从，一般来说数据库结构是一致的，只需要一套entity、mapper、service即可，在需要在不同的数据源进行操作时，直接对上下文进行设置即可。如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/user&quot;)
public class TestUserController {

    @Autowired
    private TestUserMapper testUserMapper;

    /**
     * 查询全部
     */
    @GetMapping(&quot;/listall&quot;)
    public Object listAll() {
        int initSize = 2;
        Map&amp;lt;String, Object&amp;gt; result = new HashMap&amp;lt;&amp;gt;(initSize);
        //默认master查询
        QueryWrapper&amp;lt;TestUser&amp;gt; queryWrapper = new QueryWrapper&amp;lt;&amp;gt;();
        List&amp;lt;TestUser&amp;gt; resultData = testUserMapper.selectAll(queryWrapper.isNotNull(&quot;name&quot;));
        result.put(DataSourceConstants.DS_KEY_MASTER, resultData);

        //切换数据源，在slave查询
        DynamicDataSourceContextHolder.setContextKey(DataSourceConstants.DS_KEY_SLAVE);
        List&amp;lt;TestUser&amp;gt; resultDataSlave = testUserMapper.selectList(null);
        result.put(DataSourceConstants.DS_KEY_SLAVE, resultDataSlave);
        //恢复数据源
        DynamicDataSourceContextHolder.removeContextKey();
        //返回数据
        return ResponseResult.success(result);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;默认是使用 master 数据源查询&lt;/li&gt;
&lt;li&gt;使用上下文的 setContextKey 来切换数据源，使用完后使用 removeContextKey 进行恢复&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;使用-aop-选择数据源&quot;&gt;3.3 使用 AOP 选择数据源&lt;/h2&gt;
&lt;p&gt;经过上面的动态数据源配置，可以实现动态数据源切换，但我们会发现，在进行数据源切换时，都需要做 &lt;code&gt;setContextKey&lt;/code&gt; 和 &lt;code&gt;removeContextKey&lt;/code&gt; 操作，如果需要切换的方法比多，就会发现很多重复的代码，如何消除这些重复的代码，就需要用到动态代理了，如果不了解动态代理，可以参考一下我的这篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s/a3x_pKUryb_at_4Xk48IiQ&quot;&gt;java开发必学知识:动态代理&lt;/a&gt;》。在 Spring 中，AOP 的实现也是基于动态代理的。此处，我们希望通过注解的方式指定函数需要的数据源，从而消除数据源切换时产品的模板代码。&lt;/p&gt;
&lt;h3 id=&quot;定义数据源注解&quot;&gt;3.3.1 定义数据源注解&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;annotation&lt;/code&gt;包中，添加数据源注解 &lt;code&gt;DS&lt;/code&gt;，此注解可以写在类中，也可以写在方法定义中，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.METHOD,ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface DS {
    /**
     * 数据源名称
     */
    String value() default DataSourceConstants.DS_KEY_MASTER;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;定义数据源切面&quot;&gt;3.3.2 定义数据源切面&lt;/h3&gt;
&lt;p&gt;定义数据源切面，此切面可以针对使用了 &lt;code&gt;DS&lt;/code&gt; 注解的方法或者类，进行数据源切换。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）添加aop依赖&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-aop&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2） 定义切面&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
@Component
public class DynamicDataSourceAspect {
    @Pointcut(&quot;@annotation(me.mason.demo.dynamicdatasource.annotation.DS)&quot;)
    public void dataSourcePointCut(){

    }

    @Around(&quot;dataSourcePointCut()&quot;)
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        String dsKey = getDSAnnotation(joinPoint).value();
        DynamicDataSourceContextHolder.setContextKey(dsKey);
        try{
            return joinPoint.proceed();
        }finally {
            DynamicDataSourceContextHolder.removeContextKey();
        }
    }

    /**
     * 根据类或方法获取数据源注解
     */
    private DS getDSAnnotation(ProceedingJoinPoint joinPoint){
        Class&amp;lt;?&amp;gt; targetClass = joinPoint.getTarget().getClass();
        DS dsAnnotation = targetClass.getAnnotation(DS.class);
        // 先判断类的注解，再判断方法注解
        if(Objects.nonNull(dsAnnotation)){
            return dsAnnotation;
        }else{
            MethodSignature methodSignature = (MethodSignature)joinPoint.getSignature();
            return methodSignature.getMethod().getAnnotation(DS.class);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;注解 Pointcut 使用 &lt;code&gt;annotation&lt;/code&gt; 指定注解&lt;/li&gt;
&lt;li&gt;注解 Around 使用环绕通知处理，使用上下文进行对使用注解 &lt;code&gt;DS&lt;/code&gt; 的值进行数据源切换，处理完后，恢复数据源。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;使用-aop-进行数据源切换&quot;&gt;3.3.3 使用 AOP 进行数据源切换&lt;/h3&gt;
&lt;p&gt;在service层，我们定义一个 &lt;code&gt;TestUserService&lt;/code&gt; ，里面有两个方法，分别是从 master 和 slave 中获取数据，使用了注解&lt;code&gt;DS&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 查询master库User
 */
@DS(DataSourceConstants.DS_KEY_MASTER)
public List&amp;lt;TestUser&amp;gt; getMasterUser(){
    QueryWrapper&amp;lt;TestUser&amp;gt; queryWrapper = new QueryWrapper&amp;lt;&amp;gt;();
    return testUserMapper.selectAll(queryWrapper.isNotNull(&quot;name&quot;));
}

/**
 * 查询slave库User
 */
@DS(DataSourceConstants.DS_KEY_SLAVE)
public List&amp;lt;TestUser&amp;gt; getSlaveUser(){ return testUserMapper.selectList(null); }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样定义后，在 controller 层的处理就可以变成：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@GetMapping(&quot;/listall&quot;)
public Object listAll() {
    int initSize = 2;
    Map&amp;lt;String, Object&amp;gt; result = new HashMap&amp;lt;&amp;gt;(initSize);
    //默认master数据源查询
    List&amp;lt;TestUser&amp;gt; masterUser = testUserService.getMasterUser();
    result.put(DataSourceConstants.DS_KEY_MASTER, masterUser);
    //从slave数据源查询
    List&amp;lt;TestUser&amp;gt; slaveUser = testUserService.getSlaveUser();
    result.put(DataSourceConstants.DS_KEY_SLAVE, slaveUser);
    //返回数据
    return ResponseResult.success(result);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可见，已经把数据库切换的模板代码消除，只需要关注业务逻辑处理即可。这就是AOP的好处。&lt;/p&gt;

&lt;p&gt;经过上面的动态数据源及 AOP 选择数据源的讲解，我们可以看到动态数据源已经很灵活，想切换只需在上下文中进行设置数据源即可，也可以直接在方法或类中使用注解来完成。现在我们是手动编码实现的，其实，对于MyBatis Plus ，它也提供了一个&lt;a href=&quot;https://mybatis.plus/guide/dynamic-datasource.html&quot;&gt;动态数据源的插件&lt;/a&gt;，有兴趣的小伙伴也可以根据它的官方文档进行实验使用。&lt;/p&gt;
&lt;p&gt;对于动态数据源，还有哪些地方需要考虑或者说值得改进的地方呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事务如何处理？其实在开发中应该尽量避免跨库事务，但如果避免不了，则需要使用分布式事务。&lt;/li&gt;
&lt;li&gt;对于当前的动态数据源，相对来说还是固定的数据源（如一主一从，一主多从等），即在编码时已经确定的数据库数量，只是在具体使用哪一个时进行动态处理。如果数据源本身并不确定，或者说需要根据用户输入来连接数据库，这时，如何处理呢？这种情况出现得比较多的是在对多个数据库进行管理时的处理。这种情况，我将在下一篇文章中进行讲解，我把它叫做&quot;参数化变更数据源&quot;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文对动态数据源的实现进行了讲解，主要是动态数据源的配置、实现、使用，另外还使用 AOP 消除切换数据源时的模板代码，使我们开发专注于业务代码，最后对动态数据源的进行了一下扩展思考。希望小伙伴们可以掌握动态数据源的处理。&lt;/p&gt;
&lt;p&gt;本文配套的示例，&lt;a href=&quot;https://github.com/mianshenglee/my-example/tree/master/multi-datasource&quot;&gt;示例代码&lt;/a&gt;，有兴趣的可以运行示例来感受一下。&lt;/p&gt;


&lt;p&gt;我的公众号（搜索&lt;code&gt;Mason技术记录&lt;/code&gt;），获取更多技术记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/mianshenglee/datastorage/raw/master/md-photo/myphoto/wx/wx-public.jpg&quot; alt=&quot;mason&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 15:06:00 +0000</pubDate>
<dc:creator>Mason技术记录</dc:creator>
<og:description>使用动态数据源对多个数据库进行操作，灵活，简洁。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/masonlee/p/12207853.html</dc:identifier>
</item>
<item>
<title>常见基本数据结构——散列 - Baby-Lily</title>
<link>http://www.cnblogs.com/baby-lily/p/12207816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baby-lily/p/12207816.html</guid>
<description>&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;散列表的实现通常叫做散列。散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是任何排序的信息都不会得到有效的支持。所以FindMax()，FindMin()，以及以线性时间打印的操作都是散列所不支持的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;理想的散列表数据结构值不过是一个包含有关键字的具有固定大小的数组。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;关键字映射的函数叫做散列函数，通常散列函数应该运算简单并且保证任何两个不同的关键字映射到不同的单元。不过这是不可能的，因为单元的数目是有限的，然而关键字是用不完的。因此，我们寻找一个散列函数，该函数要在单元之间均匀的分配的关键字。对于两个关键字映射到同一个值的时候，我们称之为冲突，需要设定一个函数来进行处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;散列函数&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;对于关键字是整数，则一般合理的方法就是直接返回&quot;Key mod TableSize&quot;的结果，除非Key具有某些不理想的性质。例如：表的大小是10，但是关键字的大小都是0为个位。好的大小通常是保证表的大小是一个素数。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;通常，关键字是字符串，在这种情况下，散列函数需要仔细的选择。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;一种比较简单的方法是把字符串中的字符的ASCLL码值加起来。下面是这种方式的代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Indexx Hash(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *Key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; TableSize){
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; HashVal = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(*Key != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){
        HashVal &lt;/span&gt;+= *Key++&lt;span&gt;;    
    } 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HashVal %&lt;span&gt; TableSize;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;上述的散列函数实现起来简单而且很快地算出答案。不过，如果表很大的话，函数将不会很好的分配关键字。假设TableSize=10007，并且假设所有的关键字最多有8个字符长，127*8=1016，显然这是不均匀的分配。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;另一种散列函数有下面的代码所示，假设关键字key至少有两个字符加上NULL结束，729=27^2&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;假设它们是随机的，而表还是10007的大小，我们就会得到一个合理的均匀分配，虽然3个字符有26^3=17576种可能的组合，但是实际的词汇量却揭示了：3和字母不同的组合数实际上面只有2851种，也只不过有28%的空间被利用上。当表足够大的时候，它们还是不合适的&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Index Hash(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *Key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; TableSize){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; (Key[&lt;span&gt;0&lt;/span&gt;] + &lt;span&gt;27&lt;/span&gt; * Key[&lt;span&gt;1&lt;/span&gt;] + &lt;span&gt;729&lt;/span&gt; * Key[&lt;span&gt;2&lt;/span&gt;]) %&lt;span&gt; TableSize;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;下面的散列函数，涉及到关键字中的所有字符，并且一般可以分布的很好，程序根据Horner法则计算一个(32的)多项式。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Index Hash(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; *Key, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; TableSize){
    unsigned &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; HashVal=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(*Key != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;){
        HashVal &lt;/span&gt;= (HashVal&amp;lt;&amp;lt;&lt;span&gt;5&lt;/span&gt;) + *Key++&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; HashVal %&lt;span&gt; TableSize;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;之所以使用32是因为可以使用位运算来加速，并且还可以使用按位异或来代替。上述的散列函数的优点是简单且允许溢出。当关键字长的时候，可以选用部分的关键字。有些程序人员通过只使用奇数位置上的字符来实现他们的散列函数。这里的一层想法是：用计算散列函数节省下来的时间来补偿由此产生的对均匀分布的函数的轻微干扰。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;剩下的主要问题是解决冲突的消除问题，当一个元素被插入时，另一个元素已经存在(散列值相同)，那么产生一个冲突，这个冲突需要消除。解决冲突的方法有很多种，下面介绍的是最简单的两种：分离链接法和开放定址法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;分离链接法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;解决冲突的第一种方法通常叫做分离链接法，其做法是将散列到同一个值的所有元素保留到一个表中。为了方便起见，这些表都有表头。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;为执行Find，我们使用散列函数来确定究竟考查那个表。此时我们以通常的方式遍历该表并返回所找到的被考查项所在位置。为了执行Insert，我们遍历一个相应的表以检查该元素是否已经处在适当的位置(如果要插入重复元素，那么通常要留出一个额外的域，这个域当重复元出现时增加1)。如果元素是一个新的元素，那么它或者被插入到表的前端，或者被插入到表的末端，那个容易就执行那个。新的元素插入到表的前端，不仅是因为方便，而且还因为新插入的元素最有可能最先被访问到。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;下面是具体的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ListNode;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; ListNode *&lt;span&gt;Position;
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HashTbl;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; HashTbl *&lt;span&gt;HashTable;

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ListNode{
    ElementType Element;
    Position Next;  
};
typedef Position List;
&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HashTbl{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; TableSize;
    List &lt;/span&gt;*&lt;span&gt;TheLists;
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;下面是初始化例程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HashTable InitializeTable(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; TableSize){
    HashTable H;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(TableSize &amp;lt;&lt;span&gt; MinTableSize){
        Error(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Table size too&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NULL;
    }  
    H &lt;/span&gt;= &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HashTbl));
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(H ==&lt;span&gt; NULL){
        FatalError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;out of space&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    H&lt;/span&gt;-&amp;gt;TableSize =&lt;span&gt; NextPrime(TableSize);
    H&lt;/span&gt;-&amp;gt;TheLists = &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(List)*H-&amp;gt;&lt;span&gt;TableSize);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(H-&amp;gt;TheLists ==&lt;span&gt; NULL){
        FatalError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;out of space&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;; i &amp;lt; H-&amp;gt;TableSize; i++&lt;span&gt;){
        H&lt;/span&gt;-&amp;gt;TheLists[i] = &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ListNode));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(H-&amp;gt;TheLists[i] ==&lt;span&gt; NULL){
            FatalError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Out of space&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            H&lt;/span&gt;-&amp;gt;TheLists[i]-&amp;gt;Next =&lt;span&gt; NULL;
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; H;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;上面的代码需要注意的是：TheLists是一个数组，它的每个值都是一个指向单元链表的指针。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;对Find(Key，H)的调用将返回一个指针，该指针指向包含Key的那个单元。下面是具体的代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Position Find(ElementType Key, HashTable H){
    Position P;
    List L;
    L &lt;/span&gt;= H-&amp;gt;TheLists[Hash(Key, H-&amp;gt;&lt;span&gt;TableSize)];
    P &lt;/span&gt;= L-&amp;gt;&lt;span&gt;Next;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(P != NULL &amp;amp;&amp;amp; P-&amp;gt;Element !=&lt;span&gt; Key){
        P &lt;/span&gt;= P-&amp;gt;&lt;span&gt;Next;
    }
    reutrn P;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;下一个是插入例程。如果要插入项已经存在，那么我们什么也不做，否则我们就放在表的最前端。下面是插入的代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Insert(ElementType Key, HashTable H){
    Position Pos, NewCell;
    List L;
    Pos &lt;/span&gt;=&lt;span&gt; Find(Key, H);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(Pos ==&lt;span&gt; NULL){
        NewCell &lt;/span&gt;= &lt;span&gt;malloc&lt;/span&gt;(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ListNode));
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(NewCell ==&lt;span&gt; NULL){
            FatalError(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Out of space&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
            L &lt;/span&gt;= H-&amp;gt;TheLists[Hash(Key, H-&amp;gt;&lt;span&gt;TableSize)];
            NewCell&lt;/span&gt;-&amp;gt;Next = L-&amp;gt;&lt;span&gt;Next;
            NewCell&lt;/span&gt;-&amp;gt;Element =&lt;span&gt; Key;
            L&lt;/span&gt;-&amp;gt;Next =&lt;span&gt; NewCell;
        }
    }  
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;除链表外，任何的方案都有可能用来解决冲突现象，一颗二叉树甚至是另外一个散列。我们定义散列表的装填因子λ为散列表的元素个数与散列表的大小的比例。在上面的例子中，λ=1.0。表的平均长度为λ。执行一次查找所需要的时间是执行散列函数的常数时间加上链表遍历的时间。成功的查找则需要遍历大约1+(λ/2)个链表，我们期望沿着一个表中途就能找到匹配的元素。表的大小是一个素数可以保证一个好的分布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;开放定址法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;分离链表法的缺点是需要使用指针，由于给新的单元分配地址需要时间，因此就导致了算法的速度有些减慢，同时算法实际上面还要使用另外一种数据结构的实现。除了分离链接法之外，开放定址散列法是另外一种不用链表解决冲突的方法。在开放定址散列算法中，如果没有算法冲突，那么就要尝试另外的单元，直到找到空的单元。更一般的，单元h0(X)，h1(X)，h2(X)，等等，其中hi(X) = (Hash(X) + F(i) ) mod TableSize，且F(0)=0。函数F是冲突解决函数方法。因为所有的数据都要置入表内，所以开放定址散列法所需要的表要比分裂链接散列的表大。一般对于开放定址散列算法来说，装填因子应该低于λ=0.5，下面是具体的分析：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;线性探测法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;在线性探测法中，函数F是i的线性函数，典型情况是F(i)=i。这相当于逐个探测每个单元，以查找一个空单元。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;平方探测法&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;消除线性探测中一次聚集问题的冲突解决方法。平方探测就是冲突函数为二次函数的探测方法，流行的选择是F(i) = i^2，对于线性探测，让元素几乎填满列表并不是个好主意，因为此时列表的性能会降低，对于平方探测来说情况更糟：一旦表被填满超过一半，当表的大小不是素数时甚至在表被填充满一半之前，就不能保证一次找到一个空单元了。这是因为最多有表的一半可以作为冲突解决的备选位置。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;开放定址散列表的例程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
typedef unsigned &lt;span&gt;int&lt;/span&gt;&lt;span&gt; Index;
typedef Index Position;

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HashEntry{
    ElementType Element;
    &lt;/span&gt;&lt;span&gt;enum&lt;/span&gt;&lt;span&gt; KindOfEntry Info;
}
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HashEntry Cell;

&lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; HashTbl{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; TableSize;
    Cell &lt;/span&gt;*&lt;span&gt;TheCell;      
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;如同分离链接散列法一样，Find(Key, H)将返回Key在散列表中的位置。如果Key不出现，那么Find将返回最后的单元。该单元就是当需要时，Key将被插入的地方。此外，因为被标记了Empty，所以表达式Find失败很容易。下面是使用平方探测散列法的Find例程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Position Find(ElementType Key, HashTable H){
    Position CurrentPos;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; CollisionNum;
    CollisionNum &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    CurrentPos &lt;/span&gt;= Hash(Key, H-&amp;gt;&lt;span&gt;TableSize);
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(H-&amp;gt;TheCells[CurrentPos].Info != Empty &amp;amp;&amp;amp; H-&amp;gt;TheCells[CurrentPos].Element !=&lt;span&gt; Key){
        CurrentPos &lt;/span&gt;+=&lt;span&gt;2&lt;/span&gt; * ++CollisionNum - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(CurrentPos &amp;gt;= H-&amp;gt;&lt;span&gt;TableSize)
            CurrentPos &lt;/span&gt;-= H-&amp;gt;&lt;span&gt;TableSize;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; CurrentPos;
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;使用平方探测散列表的插入例程：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; Insert(ElementType Key, HashTable H){
    Position Pos;
    Pos &lt;/span&gt;=&lt;span&gt; Find(Key, H);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(H-&amp;gt;TheCells[Pos].Info !=&lt;span&gt; Legitimate){
        H&lt;/span&gt;-&amp;gt;TheCells[Pos].Info =&lt;span&gt; Legitimate;
        H&lt;/span&gt;-&amp;gt;TheCells[Pos].Element =&lt;span&gt; Key;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;虽然平方探测排除了一次聚集，但是散列到同一位置上的那些元素将探测相同的备选单元。这叫做二次聚集。二次聚集是理论上的一个小遗憾。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;双散列&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;对于双散列，一种流行的选择是F(i) = i·hash2(X)。这个公式是说，我们将第二个散列函数应用到X并在举例hash2(X)，2hash2(X)等处探测。hash2(X)选择得不好将会是灾难性的。函数需要保证所有的单元都能探测到也是很重要的。例如：hash2(X) = R - (X mod R) 这样的函数将起到良好的作用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;再散列&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;对于使用平方探测的开放定址散列法，如果表的元素填得太满，那么操作的运行时间将开始消耗过长，且Insert操作可能失败。这可能发生在有多太多的移动和插入混合的场合。此时，另外的一种解决方法是建立另外一个大约两倍的表，扫描整个原始散列表，计算每个元素的新散列值并将其插入到新表中。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;显然这是一种昂贵的操作，其运行时间是O(N)，因为有N个元素要再散列而表的大小大约是2N，不过由于不是经常发生，因此实际效果根本没有这么差。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;在散列可以用平方探测以多种方法实现，一种做法是只要表满到一半就再散列，另外一种极端的方式是只有插入失败了才进行再散列，第三种方式是途中策略，当表到达某一个装填因子时进行再散列。由于随着装填因子的增加表的性能会有所下降，因此以好的手段实现第三种策略，是一种好的方法。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;下面是在再散列的开放定址散列表的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;HashTable ReHash(HashTable H){
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i, OldSize;
    Cell &lt;/span&gt;*&lt;span&gt;OldCells;
    OldCells &lt;/span&gt;= H-&amp;gt;&lt;span&gt;THeCells;
    OldSize &lt;/span&gt;= H-&amp;gt;&lt;span&gt;TableSize;
    H &lt;/span&gt;= InitializeTable(&lt;span&gt;2&lt;/span&gt; *&lt;span&gt; OldSize);
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(i=&lt;span&gt;0&lt;/span&gt;; i&amp;lt;OldSize; i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(OldCells[i].Info ==&lt;span&gt; Legitimate)
            Insert(OldCells[i].Element, H);
    }
    &lt;/span&gt;&lt;span&gt;free&lt;/span&gt;&lt;span&gt;(OldCells);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; H;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;可扩散列&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;当数据处理量太大以至于不能装进主存的时候，我们就需要使用可扩散列，此时主要考虑的是检索数据所需要的磁盘存取次数。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;在B树中，B树的深度随着M的增大而减小，理论上，我们可以使用足够大的M，使得树的深度是1。这样所有的Find操作只需要查找一次的磁盘，但是由于分支的数量太大，需要花费大量的时间确定分支。如果运行这一步的时间可以大大缩减，那么这将是一个实际可行的方案。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;总结&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;散列表可以用来以常数平均时间实现Insert和Find操作。当使用散列表时，需要注意装填因子这样的细节是特别重要的，否则时间界将不再奏效。当关键值不是短串或整数时，仔细选择散列函数也是非常重要的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;对于分离链接法，虽然装填因子不是很大时性能并不明显降低，但装填因子还是应该接近1，对于开放定址法，除非完全不可避免，否则装填因子不应该超过0.5。如果使用线性探测，那么性能随着装填因子接近1将急速下降。再散列通过使表增加或者收缩来实现，这样就能够保证装填因子在合理范围。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;二叉查找树的Insert和Find运算时间的界是O(logN)，但是二叉查找树支持需要序的例程而更加强大。使用散列表不可能找出最小的元素，并且O(logN)的时间界也不比O(1)大太多。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;在另一方面，散列的最坏情况一般来自于实现的缺憾，而有序的输入却可能是二叉树运行的很差。平衡查找树实现代价相当高，因此，如果不需要序的信息及排序的话，散列是一种比较好的选择。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;散列的使用非常的多，编译器使用散列表跟踪源代码中声明的变量。这种数据结构叫做符号表，散列表是这种问题的理想应用，因为只需要Insert 和 Find操作。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;散列表对于节点是实际的名字而不是数字的任何图论问题都是有用的。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;散列表的第三种运用是在游戏编制中，当程序搜索游戏的不同的运行时，它跟踪通过计算基于位置的散列函数而看到一些位置。如果位置再出现，程序通常通过简单变换来避免昂贵的计算，在游戏程序中，叫做变换表。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt;&lt;span class=&quot;ql-author-26037818 ql-size-12 ql-font-microsoftyahei&quot;&gt;散列的另一个用途是在线拼写检验程序，如果错拼检验更重要，那么整个词典都可以预先被散列，单词就能在常数时间内被校验。散列表很合适做这项工作，因为排列排列单词并不重要。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;ql-long-26037818&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 14:54:00 +0000</pubDate>
<dc:creator>Baby-Lily</dc:creator>
<og:description>散列表的实现通常叫做散列。散列是一种用于以常数平均时间执行插入、删除和查找的技术。但是任何排序的信息都不会得到有效的支持。所以FindMax()，FindMin()，以及以线性时间打印的操作都是散列所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/baby-lily/p/12207816.html</dc:identifier>
</item>
<item>
<title>android:整理drawable（shapdrawable）（二） - 族语1996</title>
<link>http://www.cnblogs.com/aoximin/p/12207098.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aoximin/p/12207098.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;bitmapdrawable 与nithpathdrawable 完结，接下来是shapedrawable。&lt;/p&gt;
&lt;p&gt;shapedrawable是使用频率最高的drawable 可见其重要性。&lt;/p&gt;
&lt;h3 id=&quot;shapedrawable&quot;&gt;shapedrawable&lt;/h3&gt;
&lt;p&gt;shapedrawable 有 rectangle、oval、line、ring&lt;/p&gt;
&lt;p&gt;分别对应 矩形、椭圆、横线、圆环。&lt;/p&gt;
&lt;h3 id=&quot;矩形&quot;&gt;矩形&lt;/h3&gt;
&lt;p&gt;先看一段:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;rectangle&quot;
    &amp;gt;
    &amp;lt;corners android:radius=&quot;20dp&quot;&amp;gt;
    &amp;lt;/corners&amp;gt;
    &amp;lt;gradient
        android:angle=&quot;0&quot;
        android:startColor=&quot;#008577&quot;
        android:centerColor=&quot;#FFF200&quot;
        android:endColor=&quot;#D81B60&quot;
        &amp;gt;
    &amp;lt;/gradient&amp;gt;
    &amp;lt;size
        android:height=&quot;100dp&quot;
        android:width=&quot;100dp&quot;&amp;gt;
    &amp;lt;/size&amp;gt;
&amp;lt;/shape&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117165050702-479629625.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总结起来就4个字，华丽庸俗。&lt;/p&gt;
&lt;p&gt;那就来介绍一下其中的作用:&lt;/p&gt;
&lt;p&gt;android:shape：形状&lt;/p&gt;
&lt;p&gt;corners android:radius=&quot;20dp&quot; 边角20dp。&lt;/p&gt;
&lt;p&gt;gradient：渐变&lt;/p&gt;
&lt;p&gt;size:大小,有宽高两个属性。&lt;/p&gt;
&lt;p&gt;那么重点就是:gradient，其他的都很简单易懂。&lt;/p&gt;
&lt;p&gt;gradient 属性:&lt;/p&gt;
&lt;p&gt;angle 表示渐变的角度，这个角度只能是45的倍数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117172141512-1196188755.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果把角度比作是旋转，不如把角度比作灯光照射，如上图。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;android:startColor=&quot;#008577&quot; // 开始渐变的颜色
android:centerColor=&quot;#FFF200&quot; // 中间渐变的颜色
android:endColor=&quot;#D81B60&quot; // 结束渐变的颜色&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这上面还有一个重要的属性:centerX:&lt;/p&gt;
&lt;p&gt;如图比较下:centerX:0.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117172624011-1423389856.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;centerX:0.2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117172900056-1272838838.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;centerX:0.3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117173645800-766516386.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相信已经明白了这个属性的意思了。&lt;/p&gt;
&lt;p&gt;渐变分为:线性渐变，径向渐变，以及扫描线渐变&lt;/p&gt;
&lt;p&gt;上面就是线性的了。&lt;/p&gt;
&lt;p&gt;看下径向的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;gradient
    android:startColor=&quot;#008577&quot;
    android:centerColor=&quot;#FFF200&quot;
    android:endColor=&quot;#D81B60&quot;
    android:gradientRadius=&quot;45dp&quot;
    android:type=&quot;radial&quot;
    &amp;gt;
&amp;lt;/gradient&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他不变替换gradient部分:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117173748329-2034829017.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;黄色的太阳，感觉有点科技感了。&lt;/p&gt;
&lt;p&gt;关键部分，既然是径向变，其实就是gradientRadius要设置，毕竟要有半径的吧，设置gradientRadius=&quot;60dp&quot;看下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117174340423-577311224.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可看，其实就是中心点到黄色的圆环位置，设置100看下，这里为什么设置100呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;size
        android:height=&quot;100dp&quot;
        android:width=&quot;100dp&quot;&amp;gt;
&amp;lt;/size&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200118011505787-977802040.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在加上另外两个有用的属性:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;gradient
    android:startColor=&quot;#008577&quot;
    android:centerColor=&quot;#FFF200&quot;
    android:endColor=&quot;#D81B60&quot;
    android:gradientRadius=&quot;45dp&quot;
    android:type=&quot;radial&quot;
    android:centerX=&quot;0.1&quot;
    android:centerY=&quot;0.5&quot;
    &amp;gt;
&amp;lt;/gradient&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117175012672-636061781.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如此可见，真的就非常明了了。&lt;/p&gt;
&lt;p&gt;接下来就是sweep：这东西就诡异了。。。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;gradient
    android:startColor=&quot;#008577&quot;
    android:centerColor=&quot;#FFF200&quot;
    android:endColor=&quot;#D81B60&quot;
    android:type=&quot;sweep&quot;
    &amp;gt;
&amp;lt;/gradient&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非常好，非常beautiful。&lt;br/&gt;这里可以看到中心点在中间，那么可以遐想一下，是否可以改变其位置。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117180032154-1380930372.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;padding:padding是内边距的意思。&lt;/p&gt;
&lt;pre class=&quot;android&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;rectangle&quot;
    &amp;gt;
    &amp;lt;corners
        android:radius=&quot;20dp&quot;
        &amp;gt;&amp;lt;/corners&amp;gt;
    &amp;lt;gradient
        android:startColor=&quot;#008577&quot;
        android:centerColor=&quot;#FFF200&quot;
        android:endColor=&quot;#D81B60&quot;
        android:type=&quot;sweep&quot;
        android:centerX=&quot;0.3&quot;
        android:centerY=&quot;0.6&quot;
        /&amp;gt;
&amp;lt;!--&amp;lt;padding--&amp;gt;
&amp;lt;!--android:left=&quot;100dp&quot;--&amp;gt;
&amp;lt;!--&amp;amp;gt;&amp;lt;/padding&amp;gt;--&amp;gt;
        &amp;lt;stroke
            android:width=&quot;2dp&quot;
            android:color=&quot;@color/colorPrimary&quot;
            android:dashWidth=&quot;2dp&quot;
            android:dashGap=&quot;2dp&quot;
            &amp;gt;

        &amp;lt;/stroke&amp;gt;
        &amp;lt;size
            android:height=&quot;100dp&quot;
            android:width=&quot;100dp&quot;&amp;gt;
        &amp;lt;/size&amp;gt;
&amp;lt;/shape&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再layout中引用:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:background=&quot;@drawable/testdrawable&quot;
    &amp;gt;
    &amp;lt;ImageView
        android:layout_width=&quot;100dp&quot;
        android:layout_height=&quot;100dp&quot;
        android:background=&quot;@drawable/testdrawable&quot;
        /&amp;gt;
&amp;lt;/LinearLayout&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117232027325-1308515973.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加上padding:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;padding android:left=&quot;100dp&quot; &amp;gt;&amp;lt;/padding&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117231537526-839960331.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;solid&quot;&gt;solid&lt;/h4&gt;
&lt;p&gt;关于solid 没什么好介绍的，solid就是设置color的，和gradient 是冲突的，android：color就可以设置其整体颜色。&lt;/p&gt;
&lt;h4 id=&quot;stroke&quot;&gt;stroke&lt;/h4&gt;
&lt;p&gt;我翻译过来是轻抚，其实就是border的意思。&lt;br/&gt;加上:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;stroke
    android:width=&quot;2dp&quot;
    android:color=&quot;@color/colorPrimary&quot;
    &amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117232224416-608205886.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;加上2dp的绿色的框。&lt;br/&gt;其他两个属性:dashWidth,dashGap&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;stroke
    android:width=&quot;2dp&quot;
    android:color=&quot;@color/colorPrimary&quot;
    android:dashWidth=&quot;2dp&quot;
    android:dashGap=&quot;2dp&quot;
    &amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个觉得了边框设置为虚线:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117181014940-905392224.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;椭圆&quot;&gt;椭圆&lt;/h3&gt;
&lt;p&gt;设置一下type=&quot;oval&quot;,如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117181205321-769184941.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为宽高都是相等的，所以是圆。&lt;br/&gt;里面的属性一致，不多介绍。&lt;/p&gt;
&lt;h3 id=&quot;横线&quot;&gt;横线&lt;/h3&gt;
&lt;p&gt;type 设置为type=&quot;line&quot;,如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117181420103-86399456.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就真的是条线了。&lt;/p&gt;
&lt;h3 id=&quot;圆环&quot;&gt;圆环&lt;/h3&gt;
&lt;p&gt;设置type=&quot;ring&quot;,然后修改code:&lt;/p&gt;
&lt;pre class=&quot;android&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;ring&quot;
    android:useLevel=&quot;false&quot;
    &amp;gt;
    &amp;lt;gradient
        android:centerColor=&quot;#ff0000&quot;
        android:endColor=&quot;#0ff676&quot;
        android:startColor=&quot;#B23AEE&quot;
        android:useLevel=&quot;false&quot; /&amp;gt;
    &amp;lt;size
        android:height=&quot;100dp&quot;
        android:width=&quot;100dp&quot;
        &amp;gt;&amp;lt;/size&amp;gt;
&amp;lt;/shape&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202001/1289794-20200117223302412-2073021979.png&quot;/&gt;&lt;br/&gt;| 值| 描述|&lt;br/&gt;|-|-|&lt;br/&gt;|android:innerRadius|圆的内半径,优先级高于android:innerRadiusRatio|&lt;br/&gt;|android:innerRadiusRatio|圆的半径与drawable的比例，默认值为3，也就是宽度的1/3。如果是n的话，就是宽度/n|&lt;br/&gt;|android:thickness| 圆环的厚度,外径-内径|&lt;br/&gt;|android:thicknessRatio| 圆环的厚度的比例,默认值为9，占用1/9。如果是n的话，就是宽度/n|&lt;/p&gt;
&lt;p&gt;现在可以看出上图圆环厚度，大概是1/3，因为分成9份，占用3份。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:shape=&quot;ring&quot;
    android:innerRadiusRatio=&quot;3&quot;
    android:thicknessRatio=&quot;9&quot;
    android:useLevel=&quot;false&quot;
    &amp;gt;
    &amp;lt;gradient
        android:centerColor=&quot;#ff0000&quot;
        android:endColor=&quot;#0ff676&quot;
        android:startColor=&quot;#B23AEE&quot;
        android:useLevel=&quot;false&quot; /&amp;gt;
    &amp;lt;size
        android:height=&quot;100dp&quot;
        android:width=&quot;100dp&quot;
        /&amp;gt;
&amp;lt;/shape&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样设置和刚才的效果一样，接下来就是自己的设计与审美了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;shapeDrawable 分为rectangle,oval,line,ring。&lt;br/&gt;总结如上述。。。。&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 14:52:00 +0000</pubDate>
<dc:creator>族语1996</dc:creator>
<og:description>前言 bitmapdrawable 与nithpathdrawable 完结，接下来是shapedrawable。 shapedrawable是使用频率最高的drawable 可见其重要性。 shap</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aoximin/p/12207098.html</dc:identifier>
</item>
<item>
<title>Java小白集合源码的学习系列：Vector - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/12207803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/12207803.html</guid>
<description>&lt;p&gt;前文传送门：&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/summerday152/p/12206193.html&quot;&gt;Java小白集合源码的学习系列：LinkedList&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/summerday152/p/12198779.html&quot;&gt;Java小白集合源码的学习系列：ArrayList&lt;/a&gt;&lt;br/&gt;Vector是JDK1.0中的集合，是集合中的老大哥，其中大部分的方法都被&lt;strong&gt;synchronized&lt;/strong&gt;关键字所修饰，与ArrayList和LinkedList不同，它是&lt;strong&gt;线程安全&lt;/strong&gt;的（关于线程安全，之后学习再做系统总结）。但是随着一系列的更新迭代，它的缺点渐渐暴露：如方法名字太长，实现接口时出现了许多重复多余的方法等等。&lt;br/&gt;从JDK1.2开始，Vector类被改进以实现List接口，让它成为Java集合框架的一员，如果不需要线程安全，建议使用ArrayList，效率更高。&lt;/p&gt;
&lt;h2 id=&quot;vector继承体系&quot;&gt;Vector继承体系&lt;/h2&gt;
&lt;p&gt;还是按照惯例，先看看它的继承图，当然这张图是基于JDK1.8的。&lt;br/&gt;&lt;img src=&quot;https://s2.ax1x.com/2020/01/17/1SwsaV.png&quot; alt=&quot;1SwsaV.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以看出来它和&lt;code&gt;ArrayList&lt;/code&gt;一样，继承了&lt;code&gt;AbstractList&lt;/code&gt;，实现&lt;code&gt;List&lt;/code&gt;接口。&lt;/li&gt;
&lt;li&gt;实现了&lt;code&gt;RandomAccess&lt;/code&gt;接口，支持随机访问。&lt;/li&gt;
&lt;li&gt;实现了&lt;code&gt;Cloneable&lt;/code&gt;接口，实现了克隆的功能。&lt;/li&gt;
&lt;li&gt;实现了&lt;code&gt;Serializable&lt;/code&gt;接口，支持序列化。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;vector核心源码&quot;&gt;Vector核心源码&lt;/h2&gt;
&lt;h3 id=&quot;基本属性&quot;&gt;基本属性&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //存储元素的数组
    protected Object[] elementData;
    //元素个数
    protected int elementCount;

    //该值决定了增长机制的不同
    protected int capacityIncrement;
    private static final long serialVersionUID = -2767605614048989439L;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造器&quot;&gt;构造器&lt;/h3&gt;
&lt;p&gt;我们可以得出结论：&lt;code&gt;Vector&lt;/code&gt;的底层也是基于数组实现的，但是这些属性和我们之前提到的&lt;code&gt;ArrayList&lt;/code&gt;有什么不同之处呢？我们继续向下看它所提供的几个构造器：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //两个参数，创建initialCapacity大小的数组，并为capacityIncrement赋值
    public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity &amp;lt; 0)
            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+
                                               initialCapacity);
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }

    //带一个参数，调用public Vector(int initialCapacity, int capacityIncrement)
    public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }

    //无参构造器，调用Vector(int initialCapacity)
    public Vector() {
        this(10);
    }

    //传入集合
    public Vector(Collection&amp;lt;? extends E&amp;gt; c) {
        elementData = c.toArray();
        elementCount = elementData.length;
        //类型判断
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以发现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;initialCapacity&lt;/code&gt;代表的是数组的容量，我们可以指定容量，&lt;strong&gt;不指定默认为10&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;capacityIncrement&lt;/code&gt;从字面上看，就可以知道它代表的是&lt;strong&gt;容量增量&lt;/strong&gt;，意味着这个值将会影响之后的扩容，可以指定，不指定默认为0。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;扩容机制&quot;&gt;扩容机制&lt;/h3&gt;
&lt;p&gt;那么我们继续来看看它的&lt;strong&gt;扩容机制&lt;/strong&gt;，是否可以验证我们的说法：&lt;br/&gt;基本上的部分，都是和ArrayList类似，我们直接截取有差异的部分：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    private void grow(int minCapacity) {
        int oldCapacity = elementData.length;
        //如果增量大于0,新容量 = 原容量 + 增量
        //如果增量不大于0，新容量 = 原容量*2
        int newCapacity = oldCapacity + ((capacityIncrement &amp;gt; 0) ?
                                         capacityIncrement : oldCapacity);
        if (newCapacity - minCapacity &amp;lt; 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
            newCapacity = hugeCapacity(minCapacity);
        elementData = Arrays.copyOf(elementData, newCapacity);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他的部分就不做分析了，之前讲的很详细，可以看看前面的文章。我们需要关注的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果指定增量（增量&amp;gt;0)，那么每次在扩容的时候，新容量就是在&lt;strong&gt;原容量的基础上加上指定增量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果没有指定增量，那么每次在扩容的时候，&lt;strong&gt;新容量默认变成原容量的两倍&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;enumeration&quot;&gt;Enumeration&lt;/h2&gt;
&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;p&gt;说起迭代器，我们总是第一个想到的就是&lt;code&gt;Iterator&lt;/code&gt;，而再Iterator是在JDK1.2的时候诞生的，用于取代JDK1.0版本的唯一迭代器&lt;code&gt;Enumeration&lt;/code&gt;。官方对它的解释是这样的：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;An object that implements the Enumeration interface &lt;strong&gt;generates a series of elements&lt;/strong&gt;, one at a time. Successive calls to the &lt;strong&gt;nextElement&lt;/strong&gt; method return successive elements of the series.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我用拙劣的英语试着翻译一下：实现Enumeration这个接口的对象呢，&lt;strong&gt;将会生成一系列的元素，生成的时候是一个一个生成的&lt;/strong&gt;，通过调用&lt;code&gt;nextElement&lt;/code&gt;这个方法，就可以返回这个系列里所有的连续元素。&lt;/p&gt;
&lt;p&gt;今天我们励志做个光荣的官方文档搬运工！&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Methods are provided to enumerate through &lt;strong&gt;the elements of a vector&lt;/strong&gt;, &lt;strong&gt;the keys of a hashtable&lt;/strong&gt;, and &lt;strong&gt;the values in a hashtable&lt;/strong&gt;. Enumerations are also used to specify the input streams to a SequenceInputStream.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这段的意思也很明白：Enumeration接口为&lt;strong&gt;Vector的元素&lt;/strong&gt;，&lt;strong&gt;hashtable的键和值&lt;/strong&gt;提供了枚举的方法，它也被运用到指定&lt;strong&gt;SequenceInputStream&lt;/strong&gt;的输入流中。我们暂时只需要知道，Vector类中，有一种方法能够产生Eumeration对象就完事了。其他的我们后面会进行总结。&lt;/p&gt;
&lt;p&gt;接下来这段话相当关键！官方文档中用了大写的NOTE:&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;NOTE&lt;/strong&gt;:The functionality of this interface is duplicated by the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementations should consider using Iterator in preference to Enumeration.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;大致的意思就是：现在这个方法呢，不太适应潮流了，那个年代用起来挺不错，现在需要年轻一辈来代替了。这个新一代的产物就是Iterator，它&lt;strong&gt;复制了Enumeration的功能&lt;/strong&gt;，并且&lt;strong&gt;增加可选的remove操作&lt;/strong&gt;，而且&lt;strong&gt;提供了更简短的命名&lt;/strong&gt;。官方仿佛在嬉皮笑脸对你说：亲，这边建议你迭代器尽量用Iterator哟。&lt;/p&gt;
&lt;p&gt;但是尽管如此，我们还需需要了解以下它的基本操作，毕竟以后可能还是会见到。&lt;/p&gt;
&lt;h3 id=&quot;源码描述&quot;&gt;源码描述&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//Enumeration接口  
public interface Enumeration&amp;lt;E&amp;gt; {
    //判断是否还有更多的元素
    boolean hasMoreElements();
    //没有下一个元素就报错，有就返回
    E nextElement();
}
//Vector中的elements方法对接口的实现
public Enumeration&amp;lt;E&amp;gt; elements() {
    //通过匿名内部类实现接口
    return new Enumeration&amp;lt;E&amp;gt;() {
        int count = 0;

        public boolean hasMoreElements() {
            return count &amp;lt; elementCount;
        }

        public E nextElement() {
            synchronized (Vector.this) {
                if (count &amp;lt; elementCount) {
                    return elementData(count++);
                }
            }
            throw new NoSuchElementException(&quot;Vector Enumeration&quot;);
        }
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;具体操作&quot;&gt;具体操作&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    Vector&amp;lt;String&amp;gt; v = new Vector&amp;lt;&amp;gt;();
    v.add(&quot;天&quot;);
    v.add(&quot;乔&quot;);
    v.add(&quot;巴&quot;);
    v.add(&quot;夏&quot;);
    //利用vector对象产生迭代器对象
    Enumeration&amp;lt;String&amp;gt; e = v.elements();
    //判断后边是否还有元素
    while(e.hasMoreElements()){
        //挪动指针指向下一个元素
        System.out.print(e.nextElement()+&quot; &quot;);
    }
    //天 乔 巴 夏 &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;vector总结&quot;&gt;Vector总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;底层基于数组&lt;/strong&gt;，可以实现动态扩增，支持根据索引快速访问。&lt;/li&gt;
&lt;li&gt;如果没有指定容量，默认为10。如果没有指定增量，默认为0。&lt;/li&gt;
&lt;li&gt;扩容时，如果增量&amp;gt;0，则新容量=&lt;strong&gt;指定增量+原容量&lt;/strong&gt;；如果增量&amp;lt;=0，则新容量为&lt;strong&gt;原容量的两倍&lt;/strong&gt;。（注意，Vector里也有实现确定容量的方法ensureCapacity）&lt;/li&gt;
&lt;li&gt;线程安全，如在创建迭代器之后的任何时间对结构进行修改，除了迭代器本身的remove和add外，都会抛出ConcurrentModification异常。所以，Vector通过&lt;code&gt;synchronized&lt;/code&gt;关键字实现线程同步。可以参考：&lt;a href=&quot;https://blog.csdn.net/yjclsx/article/details/85283169&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/yjclsx/article/details/85283169&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文若有叙述不当之处，还望各位评论区加以批评指正，谢谢。&lt;/p&gt;
&lt;p&gt;参考资料：JDK1.8官方文档&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jan 2020 14:51:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>[toc] Vector源码学习 前文传送门： &amp;quot;Java小白集合源码的学习系列：LinkedList&amp;quot; &amp;quot;Java小白集合源码的学习系列：ArrayList&amp;quot;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/12207803.html</dc:identifier>
</item>
</channel>
</rss>