<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>阿里一道Java并发面试题 (详细分析篇) - 匠心零度</title>
<link>http://www.cnblogs.com/jiangxinlingdu/p/10842321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiangxinlingdu/p/10842321.html</guid>
<description>&lt;h2 id=&quot;说明&quot;&gt;说明&lt;/h2&gt;
&lt;p&gt;前天分享了一篇关于阿里的“&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;amp;mid=2247486079&amp;amp;idx=1&amp;amp;sn=b12b74bc98c3e814f04c5a5e2a7b2b6f&amp;amp;chksm=fcaed063cbd9597551f4fb85e575dad51301d43141ba1aafc6377231cd32f79b17f5ef8c2334&amp;amp;token=1677546003&amp;amp;lang=zh_CN#rd&quot;&gt;Java常见疑惑和陷阱&lt;/a&gt;”的文章，有人说这个很早就有了，可能我才注意到，看完之后发现内容非常不错，有几个我也是需要停顿下想想，如果后续有机会我录制一个视频把这个ppt里面的所有内容，根据我的理解和知道的给大家分享一遍。&lt;/p&gt;
&lt;p&gt;如果你之前还没有看过建议好好看一遍：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;amp;mid=2247486079&amp;amp;idx=1&amp;amp;sn=b12b74bc98c3e814f04c5a5e2a7b2b6f&amp;amp;chksm=fcaed063cbd9597551f4fb85e575dad51301d43141ba1aafc6377231cd32f79b17f5ef8c2334&amp;amp;token=1677546003&amp;amp;lang=zh_CN#rd&quot;&gt;Java常见疑惑和陷阱&lt;/a&gt;，如果你需要获取&lt;strong&gt;完整ppt&lt;/strong&gt;，可以在公号对话框回复： “&lt;strong&gt;PPT&lt;/strong&gt;” 即可获取完整文件，只要你发现你看到里面知识点的时候，你需要思考一会，那么就表示你还不太熟悉，你应该去补补相关的基础知识了。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;题目&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;我个人一直认为：&lt;/strong&gt; 网络、并发相关的知识，相对其他一些编程知识点更难一些，主要是不好调试并且涉及内容太多 ！&lt;/p&gt;
&lt;p&gt;所以今天就取一篇并发相关的内容分享下，我相信大家认真看完会有收获的。&lt;/p&gt;
&lt;p&gt;大家可以先看看这个问题，看看这个是否有问题呢？ 那里有问题呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/1557404112458.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你在这个问题上面停留超过5s的话，那么表示你对这块某些知识还有点模糊，需要再巩固下，下面我们一起来分析下！&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;多线程并发的同时进行set、get操作，&lt;strong&gt;A线程调用set方法，B线程并一定能对这个改变可见！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分析&quot;&gt;分析&lt;/h2&gt;
&lt;p&gt;这个类非常简单，里面有一个属性，有2个方法：get、set方法，一个用来设置属性值，一个用来获取属性值，在设置属性方法上面加了synchronized。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐式信息：&lt;/strong&gt; 多线程并发的同时进行set、get操作，&lt;strong&gt;A线程调用set方法，B线程可以里面感知到吗？？？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说到这里，&lt;strong&gt;问题就变成了synchronized在刚刚说的上下文下面能否保证可见性！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;关键词synchronized的用法&quot;&gt;关键词synchronized的用法&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;指定加锁对象:对给定对象加锁，进入同步代码前需要获得给定对象的锁。&lt;/li&gt;
&lt;li&gt;直接作用于实例方法:相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。&lt;/li&gt;
&lt;li&gt;直接作用于静态方法:相当于对当前类加锁，进入同步代码前要获得当前类的锁。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;synchronized它的工作就是对需要同步的代码加锁，使得每一次只有一个线程可以进入同步块（其实是一种悲观策略）从而保证线程之间得安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从这里我们可以知道，我们需要分析的属于第二类情况，也就是说多个线程如果同时进行set方法的时候，由于存在锁，所以会一个一个进行set操作，并且是线程安全的，但是get方法并没有加锁，表示假如A线程在进行set的同时B线程可以进行get操作。并且可以多个线程同时进行get操作，但是同一时间最多只能有一个set操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;java-内存模型-happens-before原则&quot;&gt;Java 内存模型 happens-before原则&lt;/h2&gt;
&lt;p&gt;JSR-133 内存模型使用 happens-before 的概念来阐述操作之间的内存可见性。在 JMM 中，如果&lt;strong&gt;一个操作执行的结果需要对另一个操作可见&lt;/strong&gt;，那么这两个操作之间必须要存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。&lt;/p&gt;
&lt;p&gt;与程序员密切相关的 happens-before 规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。&lt;/li&gt;
&lt;li&gt;监视器锁规则：对一个监视器的解锁，happens-before 于随后对这个监视器的加锁。&lt;/li&gt;
&lt;li&gt;volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。&lt;/li&gt;
&lt;li&gt;传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。&lt;/p&gt;
&lt;p&gt;其中有&lt;strong&gt;监视器锁规则：对一个监视器的解锁，happens-before 于随后对这个监视器的加锁。&lt;/strong&gt;这一条，仅仅只是针对synchronized的set方法，而对于get并没有这方面的说明。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实在这种上下文下面一个synchronized的set方法，一个普通的get方法，a线程调用set方法，b线程并一定能对这个改变可见！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更多Java内存模型内存欢迎查看：&lt;strong&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rkxcqZCvCnC0Psr0_oJzbQ&quot;&gt;深入理解 Java 内存模型&lt;/a&gt;&lt;/strong&gt;，写的非常详细，建议多读几遍！！！&lt;/p&gt;
&lt;h2 id=&quot;volatile&quot;&gt;volatile&lt;/h2&gt;
&lt;h4 id=&quot;volatile可见性&quot;&gt;volatile可见性&lt;/h4&gt;
&lt;p&gt;前面happens-before原则就提到：&lt;strong&gt;volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。&lt;/strong&gt; volatile从而保证了多线程下的可见性！！！&lt;/p&gt;
&lt;h4 id=&quot;volatile-禁止内存重排序&quot;&gt;volatile 禁止内存重排序&lt;/h4&gt;
&lt;p&gt;下面是 JMM 针对编译器制定的 volatile 重排序规则表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/1557412536681.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。&lt;/p&gt;
&lt;p&gt;下面是基于保守策略的 JMM 内存屏障插入策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在每个 volatile 写操作的前面插入一个 StoreStore 屏障。&lt;/li&gt;
&lt;li&gt;在每个 volatile 写操作的后面插入一个 StoreLoad 屏障。&lt;/li&gt;
&lt;li&gt;在每个 volatile 读操作的后面插入一个 LoadLoad 屏障。&lt;/li&gt;
&lt;li&gt;在每个 volatile 读操作的后面插入一个 LoadStore 屏障。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是保守策略下，volatile 写操作 插入内存屏障后生成的指令序列示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/1557412648770.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是在保守策略下，volatile 读操作 插入内存屏障后生成的指令序列示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/1557412676220.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述 volatile 写操作和 volatile 读操作的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile 写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。&lt;/p&gt;
&lt;p&gt;更多Java内存模型内存欢迎查看：&lt;strong&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rkxcqZCvCnC0Psr0_oJzbQ&quot;&gt;深入理解 Java 内存模型&lt;/a&gt;&lt;/strong&gt;，写的非常详细，建议多读几遍！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;双重检查锁实现单例中就需要用到这个特性！！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;模拟&quot;&gt;模拟&lt;/h2&gt;
&lt;p&gt;通过上面的分析，其实这个题目涉及到的内容都提到了，并且进行了解答。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然你知道的原因，但是想模拟并不是一件容易的事情！&lt;/strong&gt;，下面我们来模拟看看效果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ThreadSafeCache {
    int result;

    public int getResult() {
        return result;
    }

    public synchronized void setResult(int result) {
        this.result = result;
    }

    public static void main(String[] args) {
        ThreadSafeCache threadSafeCache = new ThreadSafeCache();

        for (int i = 0; i &amp;lt; 8; i++) {
            new Thread(() -&amp;gt; {
                int x = 0;
                while (threadSafeCache.getResult() &amp;lt; 100) {
                    x++;
                }
                System.out.println(x);
            }).start();
        }

        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        threadSafeCache.setResult(200);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;效果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/1557414406255.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序会一直卡在这边不动，表示set修改的200，get方法并不可见！！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;添加volatile 关键词观察效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实例子中synchronized关键字可以去掉，仅仅用volatile即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/1557413697981.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/2019/1557413622655.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码很快正常结束了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结论：&lt;/strong&gt;多线程并发的同时进行set、get操作，&lt;strong&gt;A线程调用set方法，B线程并一定能对这个改变可见！！！&lt;/strong&gt;，上面的代码中，如果对get方法也加synchronized也是可见的，还是happens-before的&lt;strong&gt;监视器锁规则：对一个监视器的解锁，happens-before 于随后对这个监视器的加锁。&lt;/strong&gt;，只是volatile比synchronized更轻量级，所以本例直接用volatile。但是对于符合原子操作i++这里还是不行的还是需要synchronized。&lt;/p&gt;
&lt;p&gt;更多Java内存模型内存欢迎查看：&lt;strong&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/rkxcqZCvCnC0Psr0_oJzbQ&quot;&gt;深入理解 Java 内存模型&lt;/a&gt;&lt;/strong&gt;，写的非常详细，建议多读几遍！！！&lt;/p&gt;
&lt;p&gt;建议好好看看&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU2NjIzNDk5NQ==&amp;amp;mid=2247486079&amp;amp;idx=1&amp;amp;sn=b12b74bc98c3e814f04c5a5e2a7b2b6f&amp;amp;chksm=fcaed063cbd9597551f4fb85e575dad51301d43141ba1aafc6377231cd32f79b17f5ef8c2334&amp;amp;token=1677546003&amp;amp;lang=zh_CN#rd&quot;&gt;Java常见疑惑和陷阱&lt;/a&gt;，里面有很多很优秀的东西，如果你需要获取&lt;strong&gt;完整ppt&lt;/strong&gt;，可以在公号对话框回复： “&lt;strong&gt;PPT&lt;/strong&gt;” 即可获取完整文件！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;如果读完觉得有收获的话，欢迎点赞、关注、加公众号【匠心零度】，查阅更多精彩历史！！！&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://www.jiangxinlingdu.com/assets/images/lingdu.gif&quot;/&gt;)&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 23:06:00 +0000</pubDate>
<dc:creator>匠心零度</dc:creator>
<og:description>说明 前天分享了一篇关于阿里的“ 'Java常见疑惑和陷阱' ”的文章，有人说这个很早就有了，可能我才注意到，看完之后发现内容非常不错，有几个我也是需要停顿下想想，如果后续有机会我录制一个视频把这个p</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jiangxinlingdu/p/10842321.html</dc:identifier>
</item>
<item>
<title>Spring IOC 一——Spring容器装配Bean - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/10842218.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/10842218.html</guid>
<description>&lt;p&gt;这篇文章去年写的，缘起于去年某段时间被领导临时“抓壮丁”般的叫过去做java开发，然后在网上找了一个 SpringMVC 的 demo，学习一下，然后依葫芦画瓢，开始了自己的项目开发，也还顺利完成了任务。在使用 SpringMVC 的过程中，我被这个被称作“最优秀”的 java 框架 —— Spring 深深地吸引了，那些曾经掌握的多种设计模式的思想在其中都有实现，比如工厂模式、单例模式、观察者模式等等，于是在工作之余认真地学习了这个框架。&lt;br/&gt;学习新东西总是令人兴奋的，然而大多数学过的知识很容易又会忘记，所以便想整理一下，写点笔记，方便自己以后复习查看。&lt;/p&gt;
&lt;p&gt;部分参考资料：&lt;br/&gt;《Spring实战（第4版）》&lt;br/&gt;《轻量级 JavaEE 企业应用实战（第四版）》&lt;br/&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/5.0.6.RELEASE/spring-framework-reference/core.html#spring-core&quot;&gt;Spring 官方文档&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.w3cschool.cn/wkspring/&quot;&gt;W3CSchool Spring教程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.yiibai.com/spring/&quot;&gt;易百教程 Spring教程&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and Design中阐述的部分理念和原型衍生而来。它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件。Spring提供了约20多个组件，开发者可以根据自己需要选择组件。&lt;strong&gt;Spring的核心是控制反转(IoC)和面向切面编程(AOP)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IoC：控制反转。&lt;br/&gt;控制反转（Inversion of Control），又叫依赖注入（Dependency Injection）。举例来说，在之前的操作中，比方说有一个类，我们想要调用类里面的方法(不是静态方法)，就要创建类的对象，使用对象调用方法实现。对于Spring来说，Spring创建对象的过程，不是在代码里面实现的，而是交给Spring来进行配置实现的。&lt;/li&gt;
&lt;li&gt;AOP：面向切面编程。&lt;br/&gt;面向切面编程（Aspect Orient Programming）支持允许将一些通用的任务入安全、事物、日志、缓存等进行集中式处理，从而提供了更好的复用，AOP通常用来处理一些具有横切性质的系统级服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从最简单的 Hello，Spring 例子来体会一下使用 Spring 框架。首先看看不使用 Spring 框架的代码：&lt;br/&gt;HelloSpring.java 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

public class HelloSpring {
    private String name;

    public void sayHello() {
        System.out.println(&quot;Hello,&quot; + name + &quot;!&quot;);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Test.java 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

public class Test {
    public static void main(String[] args) {
        HelloSpring hs = new HelloSpring();
        hs.setName(&quot;Spring&quot;);
        hs.sayHello();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello,Spring!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们用 Spring 框架来实现这个例子。&lt;br/&gt;Spring 框架官方下载地址: &lt;a href=&quot;http://repo.springsource.org/libs-release-local/&quot; class=&quot;uri&quot;&gt;http://repo.springsource.org/libs-release-local/&lt;/a&gt;&lt;br/&gt;Spring 框架阿里云下载地址：&lt;a href=&quot;http://maven.aliyun.com/nexus/content/groups/public/springframework/&quot; class=&quot;uri&quot;&gt;http://maven.aliyun.com/nexus/content/groups/public/springframework/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;添加从 Spring 框架核心 JAR 文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;commons-logging-1.1.1&lt;/li&gt;
&lt;li&gt;spring-aop-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-aspects-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-beans-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-context-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-context-support-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-core-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-expression-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-instrument-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-instrument-tomcat-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-jdbc-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-jms-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-messaging-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-orm-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-oxm-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-test-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-tx-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-web-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-webmvc-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-webmvc-portlet-5.0.6.RELEASE&lt;/li&gt;
&lt;li&gt;spring-websocket-5.0.6.RELEASE&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里只是使用Spring的基本功能，所以需要使用到下面的这几个Jar包:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190510024329999-1054394083.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我使用的 idea，用 gradle 编译的（用 maven 过程类似）。为了提高下载速度，我使用了阿里云的 maven 仓库，然后添加依赖，最新稳定版本是 5.0.6 ， &lt;code&gt;build.gradle&lt;/code&gt;文件部分截图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201905/758949-20190510024321210-1168305511.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码更改如下：&lt;br/&gt;HelloSpring.java 类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

public class HelloSpring {
    private String name;

    public void sayHello() {
        System.out.println(&quot;Hello,&quot; + name + &quot;!&quot;);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Test.java 类&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.FileSystemXmlApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext context = new FileSystemXmlApplicationContext(&quot;src/beans.xml&quot;);
        HelloSpring hs = context.getBean(&quot;helloSpring&quot;, HelloSpring.class);
        hs.sayHello();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时在 src 目录下新建了一个文件 &lt;code&gt;beans.xml&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;helloSpring&quot; class=&quot;com.sharpcj.HelloSpring&quot;&amp;gt;
        &amp;lt;property name=&quot;name&quot; value=&quot;Spring&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时运行 Test.java 的 main 方法，打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Hello,Spring!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就用 Spring 框架实现了最简单的 Hello Spring 程序。&lt;/p&gt;

&lt;p&gt;上面用 Spring 框架实现的代码中，我们在 Test.java 类中，并没有通过 “new HelloSpring()” 这样的调用 Spring 构造方法去创建 HelloSpring 的对象，而是使用 Spring 核心容器创建的。&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第一步是我们使用框架 API FileSystemXmlApplicationContext() 来创建应用程序的上下文。这个 API 加载 beans 的配置文件并最终基于所提供的 API，它处理创建并初始化所有的对象，即在配置文件中提到的 beans。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第二步是使用已创建的上下文的 getBean() 方法来获得所需的 bean。这个方法使用 bean 的 ID 返回一个最终可以转换为实际对象的通用对象。一旦有了对象，你就可以使用这个对象调用任何类的方法。能通过这种方式创建的对象，一定是在 beans.xml 文件中配置的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Spring 核心容器就好像是一个超级大的工厂，在配置文件中配置过的对象都会被当成 Spring 容器管理的对象。Spring 把容器中的一切对象统称为 Bean 。 Spring 中的 Bean 与传统的 java Bean 不同，对 Spring 而言，任何一个 java 类，都可以当成是 Bean 来处理。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;在XML中进行装配&lt;/li&gt;
&lt;li&gt;自动装配 bean&lt;/li&gt;
&lt;li&gt;在Java中进行装配&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还是用上面 HelloSpring 的例子，该例子实在过于简单，只有一个 bean, 没有涉及到两个 bean 之间的依赖关系，不过还是可以用它来理解Spring容器装配Bean的三种装配方式。为了说明依赖注入的场景，举个其它例子：&lt;br/&gt;人用笔写字。伪代码如下：&lt;br/&gt;Pen 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Pen {
    // property 暂不关心
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Person 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Person {
    private Pen pen;

    public Person(Pen pen) {
        this.pen = pen;
    }

    public Pen getPen() {
        return this.pen;
    }

    public void setPen(Pen pen) {
        this.pen = pen;
    }

    // 这里我们暂不关心该方法
    public void write() {

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面对于这种依赖关系，将分别用伪代码来说明构造注入和设置注入。&lt;/p&gt;
&lt;h2 id=&quot;在-xml-中进行装配&quot;&gt;在 XML 中进行装配&lt;/h2&gt;
&lt;h3 id=&quot;基本使用&quot;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;上面例子即是，不再赘述。&lt;/p&gt;
&lt;h3 id=&quot;依赖注入&quot;&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;如果存在多个Bean, 之间有依赖关系：&lt;br/&gt;构造注入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;pen&quot; class=&quot;com.sharpcj.Pen&quot;&amp;gt; &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;person&quot; class=&quot;com.sharpcj.Person&quot;&amp;gt;
        &amp;lt;constructor-arg name = &quot;pen&quot;, ref = &quot;pen&quot;&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设值注入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&amp;gt;

    &amp;lt;bean id=&quot;pen&quot; class=&quot;com.sharpcj.Pen&quot;&amp;gt; &amp;lt;/bean&amp;gt;

    &amp;lt;bean id=&quot;person&quot; class=&quot;com.sharpcj.Person&quot;&amp;gt;
        &amp;lt;property name = &quot;pen&quot;,  ref = &quot;pen&quot;&amp;gt;
    &amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自动装配-bean&quot;&gt;4.2 自动装配 bean&lt;/h2&gt;
&lt;h3 id=&quot;基本使用-1&quot;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;com.sharpcj.HelloSpring.java&lt;/code&gt; 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class HelloSpring {
    private String name;

    public void sayHello() {
        System.out.println(&quot;Hello,&quot; + name + &quot;!&quot;);
    }

    public String getName() {
        return name;
    }

    @Value(&quot;Spring&quot;)
    public void setName(String name) {
        this.name = name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建类 &lt;code&gt;com.sharpcj.HelloConfig.java&lt;/code&gt;用来开启组件扫描：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
public class HelloConfig {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改&lt;code&gt;com.sharpcj.Test.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Test {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(com.sharpcj.HelloConfig.class);
        HelloSpring hello = context.getBean(&quot;helloSpring&quot;, HelloSpring.class);
        hello.sayHello();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@Component&lt;/code&gt; 注解的类即为 Bean 。 &lt;code&gt;@Configuration&lt;/code&gt; 注解的即为配置文件，&lt;code&gt;@ComponentScan&lt;/code&gt; 注解表示开启自动扫描，默认扫描该配置类所在的包，如果扫描其它包，多个包，形式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@ComponentScan(basePackageClasses = {com.a.A.class, com.b.B.class})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以每个包内配置之后，再配置一个总的配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@Import({com.a.AConfig.class, com.b.BConfig.class})
public class TotalConfig {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;依赖注入-1&quot;&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;如果存在多个Bean, 之间有依赖关系：&lt;/p&gt;
&lt;p&gt;// pen 类:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class Pen {
    // property 暂不关心
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造注入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class Person {

    private Pen pen;
    
    @Autowired
    public Person(Pen pen) {
        this.pen = pen;
    }

    public Pen getPen() {
        return this.pen;
    }

    public void setPen(Pen pen) {
        this.pen = pen;
    }

    // 这里我们暂不关心该方法
    public void write() {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设值注入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class Person {

    private Pen pen;

    public Pen getPen() {
        return this.pen;
    }

    @Autowired
    public void setPen(Pen pen) {
        this.pen = pen;
    }

    // 这里我们暂不关心该方法
    public void write() {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通过-java-代码进行装配&quot;&gt;通过 java 代码进行装配&lt;/h2&gt;
&lt;h3 id=&quot;基本使用-2&quot;&gt;基本使用&lt;/h3&gt;
&lt;p&gt;此时 java 类无需使用注解。&lt;br/&gt;同样创建一个类，&lt;code&gt;com.sharpcj.HelloConfig.java&lt;/code&gt;来进行装配 Bean。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class HelloConfig {
    @Bean
    public HelloSpring helloSpring(){
        return new HelloSpring();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;被 @Bean 标注的方法返回的即为唯一 Bean（默认单例模式），方法名随便取。&lt;/p&gt;
&lt;p&gt;Test:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ApplicationContext context=new AnnotationConfigApplicationContext(com.sharpcj.HelloConfig.class);
Person person = context.getBean(Person.class);
person.write();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;依赖注入-2&quot;&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;如果存在多个Bean, 之间有依赖关系：&lt;br/&gt;构造注入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class PConfig {
    @Bean
    public GPen hehe() {
        return new GPen();
    }

    @Bean
    public QPen haha() {
        return new QPen();
    }

    @Bean
    public Person xixi() {
        Person person = new Person(hehe());
        return person;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设值注入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class PConfig {
    @Bean
    public GPen hehe() {
        return new GPen();
    }

    @Bean
    public QPen haha() {
        return new QPen();
    }

    @Bean
    public Person xixi() {
        Person person = new Person();
        person.setPen(hehe());
        return person;
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这篇文章记录了Spring容器和Bean的概念，Spring 的基本使用，以及Spring容器装配Bean的三种方式。关于Spring 容器的知识点比较多，下篇文章接着写点 Spring 容器装配 Bean 的高级知识点。&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 18:53:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<og:description>Spring是一个开源框架，Spring是于2003年兴起的一个轻量级的Java开发框架，由Rod Johnson在其著作Expert One-On-One J2EE Development and</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/joy99/p/10842218.html</dc:identifier>
</item>
<item>
<title>dubbo源码阅读之服务目录 - the.forgotten</title>
<link>http://www.cnblogs.com/zhuge134/p/10841889.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuge134/p/10841889.html</guid>
<description>&lt;h2 id=&quot;服务目录&quot;&gt;服务目录&lt;/h2&gt;
&lt;p&gt;服务目录对应的接口是Directory，这个接口里主要的方法是&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; list(Invocation invocation) throws RpcException;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;列出所有的Invoker，对于服务消费端而言，一个Invoker对应一个可用的服务提供者，底层封装了一个tcp连接。当然Invoker也可以是嵌套的，一个Invoker内包含了多个实际的Invoker。通过Cluster对象将一个服务目录封装成一个Invoker，内部包含了故障转移，服务路由，负载均衡，等等相关的集群逻辑。&lt;br/&gt;回到服务目录，主要包括两种服务目录，StaticDirectory，RegistryDirectory。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;StaticDirectory。静态服务目录，顾名思义，这个目录在创建的时候就会通过构造方法传进一个Invoker列表，在之后过程中这个列表不再变化。&lt;/li&gt;
&lt;li&gt;RegistryDirectory。通过监听注册中心的服务提供者信息动态更新Invoker列表的服务目录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上节服务引入，我们知道，不论是StaticDirectory还是RegistryDirectory，最终都会通过Cluster.join方法封装为一个Invoker。由于静态服务目录的逻辑很简单，这里不再赘述，本节我们主要分析一下注册中心的服务目录。&lt;/p&gt;
&lt;h3 id=&quot;registrydirectory概述&quot;&gt;RegistryDirectory概述&lt;/h3&gt;
&lt;p&gt;这个类除了继承了AbstractDirectory，还实现了NotifyListener接口。NotifyListener接口是一个监听类，用于监听注册中心配置信息的变更事件。我们首先简单看一下RegistryDirectory中实现Directory接口的部分代码。&lt;/p&gt;
&lt;h4 id=&quot;abstractdirectory.list&quot;&gt;AbstractDirectory.list&lt;/h4&gt;
&lt;p&gt;list方法的实现放在抽象类AbstractDirectory中，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; list(Invocation invocation) throws RpcException {
    if (destroyed) {
        throw new RpcException(&quot;Directory already destroyed .url: &quot; + getUrl());
    }

    return doList(invocation);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;wishing就是一个状态的判断。doList是一个模板方法，由子类实现。&lt;/p&gt;
&lt;h4 id=&quot;registrydirectory.dolist&quot;&gt;RegistryDirectory.doList&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; doList(Invocation invocation) {
    // 当状态量forbidden为true时，服务调用被禁止
    // 什么时候forbidden为true呢？？当url只有一个，且协议名称为empty时，就以为这没有服务提供者可用。
    if (forbidden) {
        // 1. No service provider 2. Service providers are disabled
        throw new RpcException(RpcException.FORBIDDEN_EXCEPTION, &quot;No provider available from registry &quot; +
                getUrl().getAddress() + &quot; for service &quot; + getConsumerUrl().getServiceKey() + &quot; on consumer &quot; +
                NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() +
                &quot;, please check status of providers(disabled, not registered or in blacklist).&quot;);
    }

    // 服务分组
    if (multiGroup) {
        return this.invokers == null ? Collections.emptyList() : this.invokers;
    }

    List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; invokers = null;
    try {
        // Get invokers from cache, only runtime routers will be executed.
        // 从缓存中取出Invoker列表，并经由服务路由获取相应的Invoker
        invokers = routerChain.route(getConsumerUrl(), invocation);
    } catch (Throwable t) {
        logger.error(&quot;Failed to execute router: &quot; + getUrl() + &quot;, cause: &quot; + t.getMessage(), t);
    }


    // FIXME Is there any need of failing back to Constants.ANY_VALUE or the first available method invokers when invokers is null?
    /*Map&amp;lt;String, List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt;&amp;gt; localMethodInvokerMap = this.methodInvokerMap; // local reference
    if (localMethodInvokerMap != null &amp;amp;&amp;amp; localMethodInvokerMap.size() &amp;gt; 0) {
        String methodName = RpcUtils.getMethodName(invocation);
        invokers = localMethodInvokerMap.get(methodName);
        if (invokers == null) {
            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);
        }
        if (invokers == null) {
            Iterator&amp;lt;List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt;&amp;gt; iterator = localMethodInvokerMap.values().iterator();
            if (iterator.hasNext()) {
                invokers = iterator.next();
            }
        }
    }*/
    return invokers == null ? Collections.emptyList() : invokers;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法的主要逻辑是，首先判断服务是否可用（根据forbidden状态变量）。然后从路由链中取出Invoker列表。由于服务路由并不是本节的重点，所以我们只是简单第看一下RouterChain.route方法&lt;/p&gt;
&lt;h4 id=&quot;routerchain.route&quot;&gt;RouterChain.route&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;public List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; route(URL url, Invocation invocation) {
    List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; finalInvokers = invokers;
    for (Router router : routers) {
        finalInvokers = router.route(finalInvokers, url, invocation);
    }
    return finalInvokers;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一次调用路由列表中的路由规则，最终返回经过多个路由规则路由过的Invoker列表。&lt;strong&gt;&lt;em&gt;类似于责任链模式，有点像web容器的过滤器，或者是spring-mvc中的拦截器，都是一个链式的调用。&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;实际上我们平时一般较少使用到路由功能，所以这里routers列表实际上是空的，这种情况下不用经过任何路由，直接原样返回Invokers列表。而至于RouterChain内部的invokers成员是哪来的，RegistryDirectory监听注册中心发生变更后刷新本地缓存中的Invokers列表，并将其注入到RouterChain对象中，我们后面会讲到。&lt;/p&gt;
&lt;h4 id=&quot;registrydirectory.notify&quot;&gt;RegistryDirectory.notify&lt;/h4&gt;
&lt;p&gt;接下来我们分析RegistryDirectory中最重要的方法，也就是监听方法，用于监听注册中心的变更事件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public synchronized void notify(List&amp;lt;URL&amp;gt; urls) {
    // 将监听到的url分类，
    // 按照协议名称或者category参数分为configurators，routers，providers三类
    Map&amp;lt;String, List&amp;lt;URL&amp;gt;&amp;gt; categoryUrls = urls.stream()
            .filter(Objects::nonNull)
            .filter(this::isValidCategory)
            .filter(this::isNotCompatibleFor26x)
            .collect(Collectors.groupingBy(url -&amp;gt; {
                if (UrlUtils.isConfigurator(url)) {
                    return CONFIGURATORS_CATEGORY;
                } else if (UrlUtils.isRoute(url)) {
                    return ROUTERS_CATEGORY;
                } else if (UrlUtils.isProvider(url)) {
                    return PROVIDERS_CATEGORY;
                }
                return &quot;&quot;;
            }));

    // 如果有变化的configurators类别的url，那么将其转化为参数并设到成员变量configurators
    List&amp;lt;URL&amp;gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());
    this.configurators = Configurator.toConfigurators(configuratorURLs).orElse(this.configurators);

    // 如果有变更的路由信息url，那么将其转化为Router对象并覆盖原先的路由信息
    List&amp;lt;URL&amp;gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());
    toRouters(routerURLs).ifPresent(this::addRouters);

    // providers
    // 最后处理最重要的服务提供者变更信息，并用这些url刷新当前缓存的Invoker
    List&amp;lt;URL&amp;gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());
    refreshOverrideAndInvoker(providerURLs);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先将从注册中心获取到的最新的url进行分类，根据协议名称或者category参数将url分为三类：configurators, routers, providers,&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;configurators类型的url被转换为Configurator列表，覆盖本地缓存&lt;/li&gt;
&lt;li&gt;routers类型的url被转换为Router列表，并被设置到routerChain对象中&lt;/li&gt;
&lt;li&gt;providers类型的url则被用于接下来的创建Invoker&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;registrydirectory.refreshoverrideandinvoker&quot;&gt;RegistryDirectory.refreshOverrideAndInvoker&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;private void refreshOverrideAndInvoker(List&amp;lt;URL&amp;gt; urls) {
    // mock zookeeper://xxx?mock=return null
    // 用变更的配置信息覆盖overrideDirectoryUrl成员变量
    overrideDirectoryUrl();
    // 刷新缓存中的Invokers
    refreshInvoker(urls);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;overrideDirectoryUrl方法的作用主要是用从注册中心以及配置中心监听到的变更的配置覆盖本地的overrideDirectoryUrl成员变量中的配置。我们接着往下走。&lt;/p&gt;
&lt;h4 id=&quot;registrydirectory.refreshinvoker&quot;&gt;RegistryDirectory.refreshInvoker&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 入参invokerUrls是从注册中心拉取的服务提供者url
private void refreshInvoker(List&amp;lt;URL&amp;gt; invokerUrls) {
    Assert.notNull(invokerUrls, &quot;invokerUrls should not be null&quot;);

    // 如果只有一个服务提供者，并且协议名称是empty，说明无提供者可用
    // 将状态forbidden设为true， invokers设为空列表
    if (invokerUrls.size() == 1
            &amp;amp;&amp;amp; invokerUrls.get(0) != null
            &amp;amp;&amp;amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) {
        this.forbidden = true; // Forbid to access
        this.invokers = Collections.emptyList();
        routerChain.setInvokers(this.invokers);
        destroyAllInvokers(); // Close all invokers
    } else {
        this.forbidden = false; // Allow to access
        // 记下旧的Invoker列表
        Map&amp;lt;String, Invoker&amp;lt;T&amp;gt;&amp;gt; oldUrlInvokerMap = this.urlInvokerMap; // local reference
        if (invokerUrls == Collections.&amp;lt;URL&amp;gt;emptyList()) {
            invokerUrls = new ArrayList&amp;lt;&amp;gt;();
        }
        // 如果从注册中心没有拉取到服务提供者信息，那么使用之前缓存的服务提供者信息
        // 这就是为什么dubbo在注册中心挂了之后消费者仍然能够调用提供者，因为消费者在本地进行了缓存
        if (invokerUrls.isEmpty() &amp;amp;&amp;amp; this.cachedInvokerUrls != null) {
            invokerUrls.addAll(this.cachedInvokerUrls);
        } else {
            this.cachedInvokerUrls = new HashSet&amp;lt;&amp;gt;();
            this.cachedInvokerUrls.addAll(invokerUrls);//Cached invoker urls, convenient for comparison
        }
        // 如果注册中心没有提供者信息，并且本地也没有缓存，那么就没法进行服务调用了
        if (invokerUrls.isEmpty()) {
            return;
        }
        // 将服务提供者url转化为Invoker对象存放到map中
        Map&amp;lt;String, Invoker&amp;lt;T&amp;gt;&amp;gt; newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map

        /**
         * If the calculation is wrong, it is not processed.
         *
         * 1. The protocol configured by the client is inconsistent with the protocol of the server.
         *    eg: consumer protocol = dubbo, provider only has other protocol services(rest).
         * 2. The registration center is not robust and pushes illegal specification data.
         *
         */
        if (CollectionUtils.isEmptyMap(newUrlInvokerMap)) {
            logger.error(new IllegalStateException(&quot;urls to invokers error .invokerUrls.size :&quot; + invokerUrls.size() + &quot;, invoker.size :0. urls :&quot; + invokerUrls
                    .toString()));
            return;
        }

        List&amp;lt;Invoker&amp;lt;T&amp;gt;&amp;gt; newInvokers = Collections.unmodifiableList(new ArrayList&amp;lt;&amp;gt;(newUrlInvokerMap.values()));
        // pre-route and build cache, notice that route cache should build on original Invoker list.
        // toMergeMethodInvokerMap() will wrap some invokers having different groups, those wrapped invokers not should be routed.
        // 将生成的Invoker列表设置到routerChain的缓存中，
        // routerChain将对这些Invoker进行路由
        routerChain.setInvokers(newInvokers);
        // 处理服务分组的情况
        this.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;
        // 将缓存的Invoker设置为新生成的
        this.urlInvokerMap = newUrlInvokerMap;

        try {
            // 这里实际上求新的Invoker列表和旧的差集，将不再使用的旧的Invoker销毁
            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker
        } catch (Exception e) {
            logger.warn(&quot;destroyUnusedInvokers error. &quot;, e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;这个方法首先根据监听到的提供者url列表判断是否处于服务禁用状态，判断依据是：如果只有一个url，并且该url协议名称是empty，说明无提供者可用，将forbidden变量设为true,即禁止服务调用，&lt;br/&gt;并做一下其他的相关设置以及销毁缓存中的Invoker。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;如果不是禁止状态，继续往下走。如果从注册中心获取到的url列表为空，那么检查本地缓存的url列表是否为空，如果缓存不为空就用缓存的列表。如果本地缓存也为空，说明无服务可用，直接返回。&lt;/li&gt;
&lt;li&gt;如果如果从注册中心获取到的url列表不为空，说明有服务可用，这时就不会再去尝试本地缓存了（因为缓存已经过期了）,并且将本地缓存更新为新获取的url列表。&lt;/li&gt;
&lt;li&gt;将可用的提供者url列表转化为Invoker列表。&lt;/li&gt;
&lt;li&gt;将新创建的Invoker列表设置到routerChain中，这里呼应了前文提到的在doList方法中，从routerChain对象中取出缓存的Invoker列表。&lt;/li&gt;
&lt;li&gt;将本地缓存的url-&amp;gt;Invoker map更新为新创建的。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;最后销毁缓存中不再使用的Invoker&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;registrydirectory.toinvokers&quot;&gt;RegistryDirectory.toInvokers&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * Turn urls into invokers, and if url has been refer, will not re-reference.
 *
 * @param urls 从注册中心拉取的服务提供者信息
 * @return invokers
 */
private Map&amp;lt;String, Invoker&amp;lt;T&amp;gt;&amp;gt; toInvokers(List&amp;lt;URL&amp;gt; urls) {
    Map&amp;lt;String, Invoker&amp;lt;T&amp;gt;&amp;gt; newUrlInvokerMap = new HashMap&amp;lt;&amp;gt;();
    if (urls == null || urls.isEmpty()) {
        return newUrlInvokerMap;
    }
    // 用于防止对相同的url重复创建Invoker
    Set&amp;lt;String&amp;gt; keys = new HashSet&amp;lt;&amp;gt;();
    String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);
    for (URL providerUrl : urls) {
        // If protocol is configured at the reference side, only the matching protocol is selected
        // 如果消费端配置了协议名称，那么只有符合条件的提供者url才会被使用
        // 这段代码有待商榷 ，应该先把queryProtocols处理好，避免重复做同样的工作
        if (queryProtocols != null &amp;amp;&amp;amp; queryProtocols.length() &amp;gt; 0) {
            boolean accept = false;
            String[] acceptProtocols = queryProtocols.split(&quot;,&quot;);
            for (String acceptProtocol : acceptProtocols) {
                if (providerUrl.getProtocol().equals(acceptProtocol)) {
                    accept = true;
                    break;
                }
            }
            if (!accept) {
                continue;
            }
        }
        // 如果协议名称是empty，那么忽略该条url
        if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) {
            continue;
        }
        // 如果当前classpath下找不到与提供者url中协议名称相对应的Protocol类，那么打印错误日志同时忽略该条url
        if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) {
            logger.error(new IllegalStateException(&quot;Unsupported protocol &quot; + providerUrl.getProtocol() +
                    &quot; in notified url: &quot; + providerUrl + &quot; from registry &quot; + getUrl().getAddress() +
                    &quot; to consumer &quot; + NetUtils.getLocalHost() + &quot;, supported protocol: &quot; +
                    ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));
            continue;
        }
        // 合并消费端设置的参数以及从注册中心，配置中心监听到的配置变更
        URL url = mergeUrl(providerUrl);

        // 以全路径作为该url的唯一标识
        String key = url.toFullString(); // The parameter urls are sorted
        if (keys.contains(key)) { // Repeated url
            continue;
        }
        keys.add(key);
        // Cache key is url that does not merge with consumer side parameters, regardless of how the consumer combines parameters, if the server url changes, then refer again
        Map&amp;lt;String, Invoker&amp;lt;T&amp;gt;&amp;gt; localUrlInvokerMap = this.urlInvokerMap; // local reference
        // 如果之前已经创建过该url的Invoker对象，那么就不用再重复创建
        Invoker&amp;lt;T&amp;gt; invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);
        if (invoker == null) { // Not in the cache, refer again
            try {
                boolean enabled = true;
                // 检查disabled和enabled参数的值
                if (url.hasParameter(Constants.DISABLED_KEY)) {
                    enabled = !url.getParameter(Constants.DISABLED_KEY, false);
                } else {
                    enabled = url.getParameter(Constants.ENABLED_KEY, true);
                }
                if (enabled) {
                    // 真正创建Invoker的地方，
                    // InvokerDelegate只是个简单的包装类，不需要多说
                    invoker = new InvokerDelegate&amp;lt;&amp;gt;(protocol.refer(serviceType, url), url, providerUrl);
                }
            } catch (Throwable t) {
                logger.error(&quot;Failed to refer invoker for interface:&quot; + serviceType + &quot;,url:(&quot; + url + &quot;)&quot; + t.getMessage(), t);
            }
            if (invoker != null) { // Put new invoker in cache
                newUrlInvokerMap.put(key, invoker);
            }
        } else {
            newUrlInvokerMap.put(key, invoker);
        }
    }
    keys.clear();
    return newUrlInvokerMap;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;首先根据协议名称检查url是否可用。url的协议必须在本地配置的协议列表中（如果没有配置就不需要做此检查）；如果协议名称是empty则忽略这个url；如果当前classpath下找不到与提供者url中协议名称相对应的Protocol类，那么打印错误日志同时忽略该条url&lt;/li&gt;
&lt;li&gt;合并消费端设置的参数以及从注册中心，配置中心监听到的配置变更&lt;/li&gt;
&lt;li&gt;检查disabled，enabled参数的值，判断该url是否启用，如果disabled为true则跳过该url；如果没有disabled参数，检查enabled参数，如果enabled为false则跳过该url，enabled默认是true。&lt;/li&gt;
&lt;li&gt;调用Protocol.refer方法创建Invoker对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里需要说明一下，由于Directory不是通过SPI机制加载的，所以RegistryDirectory也不是通过ExtensionLoader加载的，所以也就不会受到ExtensionLoader的IOC影响。RegistryDirectory内部的protocol成员是在RegistryDirectory初始化之后通过调用setter方法设置进去的，是在RegistryProtocol.doRefer方法中完成的。而RegistryProtocol是通过ExtensionLoader机制加载的，会受到IOC影响，所以RegistryProtocol实例内部的protocol成员是通过ExtensionLoader的IOC机制自动注入的，是一个自适应的扩展类。&lt;/p&gt;
&lt;p&gt;另外，InvokerDelegate只是个简单的包装类，不需要多说。&lt;br/&gt;Invoker的创建最终还是通过protocol.refer方法，我们以最常用的dubbo协议为例进行分析。&lt;/p&gt;
&lt;h4 id=&quot;dubboprotocol.refer&quot;&gt;DubboProtocol.refer&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public &amp;lt;T&amp;gt; Invoker&amp;lt;T&amp;gt; refer(Class&amp;lt;T&amp;gt; serviceType, URL url) throws RpcException {
    optimizeSerialization(url);

    // create rpc invoker.
    DubboInvoker&amp;lt;T&amp;gt; invoker = new DubboInvoker&amp;lt;T&amp;gt;(serviceType, url, getClients(url), invokers);
    invokers.add(invoker);

    return invoker;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法很简单，直接new了一个DubboInvoker。&lt;/p&gt;
&lt;h4 id=&quot;dubboinvoker&quot;&gt;DubboInvoker&lt;/h4&gt;
&lt;p&gt;看一下doInvoke方法，这个方法主要是处理了同步，异步，超时，单向调用等参数，并且对调用结果封装了异步调用，同步调用的逻辑。&lt;br/&gt;真正执行远程调用的部分是靠ExchangeClient实现的，再往下就是调用参数的序列化，tcp连接创建，发送报文，获取响应报文，反序列化结果等的逻辑了，本文不再深入下去。&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 15:49:00 +0000</pubDate>
<dc:creator>the.forgotten</dc:creator>
<og:description>服务目录 服务目录对应的接口是Directory，这个接口里主要的方法是 List list(Invocation invocation) throws RpcException; 列出所有的Invo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuge134/p/10841889.html</dc:identifier>
</item>
<item>
<title>MySQL 中的索引 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/mysql_index.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/mysql_index.html</guid>
<description>&lt;p&gt;索引用来加速查询。正常来说，当查询数据时，MySQL 需要从表的第一条记录开始，读取整个表的内容，进行查询。&lt;/p&gt;
&lt;p&gt;但如果有索引，MySQL 可根据索引快速定位需要查询条目的具体位置，加快了查询速度。&lt;/p&gt;
&lt;h2&gt;原理&lt;/h2&gt;
&lt;p&gt;索引的原理是将被索引列的值，单独取出来存到另一种结构中以获取快速查询的效果。&lt;/p&gt;
&lt;p&gt;当列有这些属性中任意一个时，会被索引， &lt;code&gt;PRIMARY KEY&lt;/code&gt;, &lt;code&gt;UNIQUE&lt;/code&gt;, &lt;code&gt;INDEX&lt;/code&gt;, 以及 &lt;code&gt;FULLTEXT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;大部分索引以 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_b_tree&quot; rel=&quot;nofollow&quot;&gt;B-trees&lt;/a&gt; 结构存储。但有些例外：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/spatial-types.html&quot; rel=&quot;nofollow&quot;&gt;Spatial Data 数据类型&lt;/a&gt;，一种基于地理坐标使用数字来标识现实中对象的数据类型，使用 &lt;a href=&quot;https://en.wikipedia.org/wiki/R-tree&quot; rel=&quot;nofollow&quot;&gt;R-trees&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;MEMORY 内存表同时支持使用 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_hash_index&quot; rel=&quot;nofollow&quot;&gt;hash 索引&lt;/a&gt; 。&lt;/li&gt;
&lt;li&gt;InnoDB 引擎中对于全文本索引（FULLTEXT）直接使用列表（lists）结构。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;MySQL 使用索引的场景&lt;/h2&gt;
&lt;p&gt;以下场景将借助或依赖于索引：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;WHERE&lt;/code&gt; 进行条件查询时&lt;/li&gt;
&lt;li&gt;用于排除一些记录。存在多个索引可选时，MySQL 选择会获取最小记录的那个索引（the most &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_selectivity&quot; rel=&quot;nofollow&quot;&gt;selective&lt;/a&gt; index）。&lt;/li&gt;
&lt;li&gt;存在多列索引的情况下，从左排开始的列的组合都可用于查询时的优化。比如三个索引列 （col1, col2, col3），查询时可以有这些组合的优化查询 (col1), (col1, col2), and (col1, col2, col3)，详见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/multiple-column-indexes.html&quot; rel=&quot;nofollow&quot;&gt;Section 8.3.6, “Multiple-Column Indexes”&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;联表查询时。特别地，如果列的类型及大小相同的话，查询时会更加高效。比如 VARCHAR 和 CHAR 会当成同一类型，VARCHAR(10) and CHAR(15) 则不是同一类型，因为长度不同。&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_min&quot; rel=&quot;nofollow&quot;&gt;MIN()&lt;/a&gt;，&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html#function_max&quot; rel=&quot;nofollow&quot;&gt;MAX()&lt;/a&gt; 函数时。&lt;/li&gt;
&lt;li&gt;进行排序或分组时。&lt;/li&gt;
&lt;li&gt;某些情况下，仅仅通过索引就能完成查询操作，无须操作真实的表记录。这种提供了查询中足够信息的索引被称为 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/glossary.html#glos_covering_index&quot; rel=&quot;nofollow&quot;&gt;covering index&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;索引并不是万能的，对于数据量小的表以及对于那些查询全部数据的操作，索引的效果并不明显。相反，对于那些查询时涉及到表中大部分数据的情况下，逐条查询比使用索引要快。&lt;/p&gt;
&lt;h2&gt;索引的类型&lt;/h2&gt;
&lt;p&gt;主要有以下四种索引类型，关于创建索引的其他详情可参见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/create-index.html&quot; rel=&quot;nofollow&quot;&gt;MySQL Manual - 13.1.15 CREATE INDEX Syntax&lt;/a&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Index Prefixes&lt;/li&gt;
&lt;li&gt;FULLTEXT 索引&lt;/li&gt;
&lt;li&gt;Spatial 索引&lt;/li&gt;
&lt;li&gt;MEMORY Storage Engine 中的索引&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Index Prefixes&lt;/h3&gt;
&lt;p&gt;对于字符串类型的列，在索引创建语法中指定 &lt;code&gt;col_name(N)&lt;/code&gt;，可将该列中前 N 个字符进行索引。通过只索引列中前 N 个字符 而非整列，可有效减小索引大小。比如索引 BLOB or TEXT 类型的列：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;test&lt;/span&gt; (blob_col BLOB, INDEX(blob_col(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;)));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询时，如果查询项超过了索引长度，索引将用来排除掉那些在索引长度范围内匹配失败的记录，剩下的记录则正常查询。&lt;/p&gt;
&lt;h3&gt;FULLTEXT 索引&lt;/h3&gt;
&lt;p&gt;全文本索引用于全文本（full-text）的搜索。只 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html&quot; rel=&quot;nofollow&quot;&gt;InnoDB&lt;/a&gt; 和 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/myisam-storage-engine.html&quot; rel=&quot;nofollow&quot;&gt;MyISAM&lt;/a&gt; 两种引擎下的 CHAR，VARCHAR，TEXT 数据类型支持全文本索引。不像 Index Prefixes，该类型的索引是会对整列的。&lt;/p&gt;
&lt;h3&gt;Spatial 索引&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/spatial-types.html&quot; rel=&quot;nofollow&quot;&gt;Spatial Data 数据类型&lt;/a&gt; 上创建的索引。&lt;/p&gt;
&lt;h3&gt;MEMORY Storage Engine 中的索引&lt;/h3&gt;
&lt;p&gt; MEMORY 存储引擎默认使用 HASH 索引，但也支持 BTREE 索引。&lt;/p&gt;
&lt;h2&gt;索引的创建&lt;/h2&gt;
&lt;p&gt;索引可在创建表时创建，参考 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/create-table.html#create-table-indexes-keys&quot; rel=&quot;nofollow&quot;&gt;13.1.20 CREATE TABLE Syntax&lt;/a&gt;，也可针对已有的表进行创建，使用 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/create-index.html&quot; rel=&quot;nofollow&quot;&gt;CREATE INDEX&lt;/a&gt; 语句。&lt;/p&gt;
&lt;details readability=&quot;3&quot;&gt;创建索引的语法
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
    [index_type]
    &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; tbl_name (key_part,...)
    [index_option]
    [algorithm_option | lock_option] ...

key_part: {col_name [(length)] | (expr)} [&lt;span class=&quot;pl-k&quot;&gt;ASC&lt;/span&gt; | &lt;span class=&quot;pl-k&quot;&gt;DESC&lt;/span&gt;]

index_option:
    KEY_BLOCK_SIZE [&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;] value
  | index_type
  | WITH PARSER parser_name
  | COMMENT &lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;string&lt;span class=&quot;pl-pds&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
  | {VISIBLE | INVISIBLE}

index_type:
    USING {BTREE | HASH}

algorithm_option:
    ALGORITHM [&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;] {DEFAULT | INPLACE | COPY}

lock_option:
    LOCK [&lt;span class=&quot;pl-k&quot;&gt;=&lt;/span&gt;] {DEFAULT | NONE | SHARED | EXCLUSIVE}
&lt;/pre&gt;&lt;/div&gt;
&lt;/details&gt;&lt;p&gt;有如下类型的索引指定方式，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;以列前缀的方/Column Prefix Key Parts&lt;/li&gt;
&lt;li&gt;函数形式/Functional Key Parts&lt;/li&gt;
&lt;li&gt;Unique 索引&lt;/li&gt;
&lt;li&gt;Full-Text 索引&lt;/li&gt;
&lt;li&gt;Spatial 索引&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;以列前缀的方&lt;/h3&gt;
&lt;p&gt;可用于创建列中指定前缀部分 &lt;code&gt;col_name(length)&lt;/code&gt; 的索引。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;part_of_name&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; customer (name(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上语句对名为 &lt;code&gt;name&lt;/code&gt; 的例索引其前 10 个字符。&lt;/p&gt;
&lt;h3&gt;函数形式&lt;/h3&gt;
&lt;p&gt;普通形式的索引只能索引列中的值，比如：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (
  col1 &lt;span class=&quot;pl-k&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;),
  col2 &lt;span class=&quot;pl-k&quot;&gt;VARCHAR&lt;/span&gt;(&lt;span class=&quot;pl-c1&quot;&gt;20&lt;/span&gt;),
  INDEX (col1, col2(&lt;span class=&quot;pl-c1&quot;&gt;10&lt;/span&gt;))
);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上语句对 &lt;code&gt;col1&lt;/code&gt; 整列 及 &lt;code&gt;col2&lt;/code&gt; 前 10 个字符进行索引。&lt;/p&gt;
&lt;p&gt;但使用函数形式，可创建针对表达式的索引，而不是表中的列。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;t1&lt;/span&gt; (col1 &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;, col2 &lt;span class=&quot;pl-k&quot;&gt;INT&lt;/span&gt;, INDEX func_index ((ABS(col1))));
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;idx1&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; t1 ((col1 &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; col2));
&lt;span class=&quot;pl-k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;INDEX&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;idx2&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;ON&lt;/span&gt; t1 ((col1 &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; col2), (col1 &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; col2), col1);
&lt;span class=&quot;pl-k&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;TABLE&lt;/span&gt; t1 ADD INDEX ((col1 &lt;span class=&quot;pl-k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;pl-c1&quot;&gt;40&lt;/span&gt;) &lt;span class=&quot;pl-k&quot;&gt;DESC&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数形式的索引在定义时需要满足以下的条件，否则抛错：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表达式使用括号包裹，以和列名或列的其他前缀属性区别开来。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; 🚨 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
INDEX (col1 &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; col2, col3 &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; col4)

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; ✅ &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
INDEX ((col1 &lt;span class=&quot;pl-k&quot;&gt;+&lt;/span&gt; col2), (col3 &lt;span class=&quot;pl-k&quot;&gt;-&lt;/span&gt; col4))
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;函数形式的表达式不能形成一个单独的列名，譬如：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;highlight highlight-source-sql&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; 🚨 &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
INDEX ((col1), (col2))

&lt;span class=&quot;pl-c&quot;&gt;&lt;span class=&quot;pl-c&quot;&gt;/*&lt;/span&gt; ✅ &lt;span class=&quot;pl-c&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;
INDEX (col1, col2)
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;函数中不能引用列前缀（column prefixes）。&lt;/li&gt;
&lt;li&gt;外键（foreign key）中不使用使用函数形式。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Unique 索引&lt;/h3&gt;
&lt;p&gt;指定为 &lt;code&gt;UNIQUE&lt;/code&gt; 的列约束了列中的值在记录中是唯一的，尝试插入重复值时会抛错。但允许存在多个 NULL 值，如果该列允许为空的话。&lt;/p&gt;
&lt;p&gt;如果一个表拥有 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 或 &lt;code&gt;UNIQUE NOT NULL&lt;/code&gt; 类型的单列整型形成的索引，在 &lt;code&gt;SELECT&lt;/code&gt; 语句中可使用 &lt;code&gt;_rowid&lt;/code&gt; 关键词来获取索引的列：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果存在一个整型的 &lt;code&gt;PRIMARY KEY&lt;/code&gt; 列，&lt;code&gt;_rowid&lt;/code&gt; 则指代该列。&lt;/li&gt;
&lt;li&gt;否则 &lt;code&gt;_rowid&lt;/code&gt; 指代第一个 &lt;code&gt;UNIQUE NOT NULL&lt;/code&gt; 列。如果不存在一个 &lt;code&gt;UNIQUE NOT NULL&lt;/code&gt; 类型的整型列，则不能使用 &lt;code&gt;_rowid&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Full-Text 索引&lt;/h3&gt;
&lt;p&gt;详细的操作参见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/full-text-adding-collation.html&quot; rel=&quot;nofollow&quot;&gt;12.9.7 Adding a Collation for Full-Text Indexing&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Spatial 索引&lt;/h3&gt;
&lt;p&gt;不同存储引擎对其支持情况不一，详见 &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/create-index.html#create-index-spatial&quot; rel=&quot;nofollow&quot;&gt;Spatial Indexes&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;相关资源&lt;/h2&gt;
</description>
<pubDate>Thu, 09 May 2019 15:35:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>索引用来加速查询。正常来说，当查询数据时，MySQL 需要从表的第一条记录开始，读取整个表的内容，进行查询。 但如果有索引，MySQL 可根据索引快速定位需要查询条目的具体位置，加快了查询速度。 原理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/mysql_index.html</dc:identifier>
</item>
<item>
<title>[开发技巧]·pandas如何保存numpy元素 - 小宋是呢</title>
<link>http://www.cnblogs.com/xiaosongshine/p/10841818.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaosongshine/p/10841818.html</guid>
<description>&lt;h3&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;14&quot;&gt;&lt;img class=&quot;cke_widget_element has&quot; src=&quot;https://img-blog.csdnimg.cn/20190509232645344.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/20190509232645344.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:false,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/20190509232645344.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9zb25nc2hpbmU=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h3&gt;1.问题描述&lt;/h3&gt;
&lt;p&gt;在开发的过程中遇到一个问题，就是需要把numpy作为pandas的一个元素进行保存，注意不是作为一列元素。但是实践的过程中却不顺利，会报错，现在我解决了这个问题，并且把心得和理解分享出来，希望能帮到后来人。&lt;/p&gt;

&lt;h3&gt;2.开发实战&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.新建一些伪数据，用于保存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2.新建DataFrame进行保存并且显示&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这时程序报错：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
    raise Exception('Data must be 1-dimensional')
Exception: Data must be 1-dimensional
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;错误出现在&lt;em&gt;df[&quot;list&quot;] = lists，&lt;/em&gt;错误的原因是lists不是一维数据（Data must be 1-dimensional），为什么会出现这个问题呢？&lt;/p&gt;
&lt;p&gt;原因在&lt;em&gt;lists = np.array([l1,l2])&lt;/em&gt;，lists成为了二维的np.array，shape为（2，4）。&lt;/p&gt;
&lt;p&gt;如何解决呢？需要把np.array转为list，就变为一维数据了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.修正代码&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;p&gt;可能会有些朋友觉得代码有些麻烦，为什么先用np.array([l1,l2])转换为np.array再用list(lists)转换为list，其实这是为了模拟真实使用场景。一般我们接触到的数据都是np.array，再保存为pandas，就会报错（Data must be 1-dimensional），解决方法就是转换为list。&lt;/p&gt;
&lt;p&gt;numpy.array和list区别是什么呢？后面我会通过一个博客来好好阐述一下。&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 15:30:00 +0000</pubDate>
<dc:creator>小宋是呢</dc:creator>
<og:description>[开发技巧]·pandas如何保存numpy元素 ​ 1.问题描述 在开发的过程中遇到一个问题，就是需要把numpy作为pandas的一个元素进行保存，注意不是作为一列元素。但是实践的过程中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaosongshine/p/10841818.html</dc:identifier>
</item>
<item>
<title>Java课堂笔记（二）：面向对象 - 尼尔森写代码</title>
<link>http://www.cnblogs.com/NelsonProgram/p/10832406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NelsonProgram/p/10832406.html</guid>
<description>&lt;p&gt;        几乎每一本介绍Java语言的书中都会提到“面向对象”的这个概念，然而博主初学Java时看到这方面的内容一般都是草草地看一看，甚至是直接略过。原因很简单：考试基本不考，而且初学阶段写代码也很少用上。但事实上面向对象时Java中一个非常重要的内容，而且与代码这整体设计关系很大。越是具有丰富的编程经验，就越能体会到这个思想在实际代码结构设计中的重要性。在《Java编程思想》中，作者用了很大的篇幅来介绍面向对象的相关内容，其中不乏一些关于如何运用面向对象来优化程序结构，提高代码的可读性和可维护性的内容。这一章就来整理一下关于面向对象的相关内容。&lt;/p&gt;

&lt;p&gt;《Java编程思想》一书，对于面向对象程序设计总结了一下五个特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;万物皆为对象。&lt;/strong&gt;&lt;/span&gt;将对象视为奇特的变量，它可以存储数据，除此之外，你还可以要求它在自身上执行操作。理论上讲，你可以出去带求解问题的任何概念化构件（狗、建筑物、服务等），将其表示为程序中的对象。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;程序是对象的合集，它们通过发送消息来告知彼此所要做的。&lt;/strong&gt;&lt;/span&gt;要想请求一个对象，就必须对该对象发送一条消息。更具体地说，可以把消息想象为对某个特定对象的方法调用请求。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;每个对象都有自己的由其他对象所构成的存储。&lt;/strong&gt;&lt;/span&gt;换句话说，可以通过创建包含现有对象的包的方式来创建新类型的对象。因此，可以在程序中构建复杂的体系，同时将其复杂性隐藏在对象的简单性背后。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;每个对象都拥有其类型。&lt;/strong&gt;&lt;span&gt;按照通用的说法，“每个对象都是某个类（class）的一个实例（instance）”，这里“类”就是“类型”的同义词。每个类最重要的区别于其他类的特征就是“可以发送什么样的消息给它”。&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;某些特定类型的所有对象都可以接受相同的消息。&lt;/span&gt;&lt;/strong&gt;“圆形”类型的对象同时也是“几何形”类型的对象，所以一个“圆形”对象必定能够接受发送给“几何形”对象的消息。这意味着可以编写与“几何形”交互并自动处理所有与几何形性质相关的事物的代码。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;　　讨论这个问题前要先说说“抽象”机制。所有的编程语言都提供抽象机制，所谓抽象就是用编程语言的元素来表达某些内容。不同的编程语言所能够抽象的对象是不一样的。汇编语言是对底层机器的轻微抽象，能够表达计算机底层结构以及操作。还有一些&quot;命令式&quot;的编程语言（例如C、FORTRAN等），这些语言是对汇编语言的抽象。这些语言能够更易于阅读，更方便地被人所理解。但这些语言依然是在基于计算机的底层结构进行抽象的，因此在解决问题时依然会受限制与计算机的机构。程序员在解决某个特定问题的时候，需要构建该问题与计算机机构模型之间的映射，这使得编写程序变得很困难。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果编程语言能够直接对所需要解决的问题进行抽象，能够直接表达问题中的元素，那么就能够省去计算机结构和问题之间的映射的工作。面向对象就是能够为程序员提供面向问题空间元素的一个工具。如上文所述，面向对象的语言中，万物皆为对象，且每个对象都有其类型，也就是类（class）。因此，程序员就可以自定义适用于问题空间的类来解决问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　面向对象程序设计能够降低各组件之间的耦合性，增加了代码的可维护性，复用性和可扩展性。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　&lt;strong&gt;&lt;span&gt;封装&lt;/span&gt;&lt;/strong&gt;、&lt;strong&gt;&lt;span&gt;继承&lt;/span&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;span&gt;多态&lt;/span&gt;&lt;/strong&gt;是面向对象程序设计的三大特性。在具体介绍这三者前，先对Java中的类进行简单介绍。类是一组具有相同特性（数据元素）和行为（功能）的对象的集合，一个类可以有很多个对象。Java的类包含两部分元素：属性（也叫字段）和方法（也叫成员函数）。属性可以使任何类型的对象，包括基本类型和引用类型；方法是该类的对象能够进行的操作，用OOP中的说法，方法决定了一个对象能够接受什么样的消息。方法的组成包括名称，参数，返回值和方法体几部分。类的基本形式如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; ClassTypeA{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; dataA;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt;&lt;span&gt; dataB;
    ClassTypeB classTypeB;

    ReturnType methodName(&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Argument list &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Method body &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;封装&lt;/h2&gt;
&lt;p&gt;　　封装是指将类的内部实现隐藏起来，仅暴露出必要的接口给使用者。隐藏实现的第一个优点是可以避免类的使用者接触和操作到他们不应该接触的部分，避免由于使用者的粗心或错误操作产生程序bug。第二，隐藏具体实现，仅暴露接口给使用者，那么设计者在修改类的实现的时候就不用顾忌对使用者的影响，只需要保持对外的接口不变就可以。第三点，使用接口调用来连接设计者和使用者，可以降低系统的耦合性。&lt;/p&gt;
&lt;p&gt;　　在具体的开发过程中，设计者对于类中的不同元素的可访问情况会有不同的要求：对于类内部的关键性字段，设计者会希望其完全被隐藏，不希望被任何使用者访问或修改；而对于提供给外部使用的接口，一定是希望其能够被所有使用者访问；还有一些元素，设计者希望该类的子类能够访问和使用，而不会被其他的使用者接触到。Java用访问权限关键字来区别这种不同的可访问性。&lt;/p&gt;
&lt;p&gt;　　Java中一共有3中访问权限关键字：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;public&lt;/span&gt;&lt;/strong&gt;表示紧随其后的元素对任何人都是可用的；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;private&lt;/strong&gt;&lt;/span&gt;关键字表示除了类型的创建者和类型内部的方法以外，任何人都不能访问该元素。如果有人试图访问private成员，就会在编译时收到错误信息提示；&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;protected&lt;/strong&gt;&lt;/span&gt;关键字与private相比，区别在于继承的类可以访问protected修饰的元素，而不能访问private修饰的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　除了以上三种访问权限以外，Java还有一种默认的访问权限，在没有使用任何访问权限关键字的情况下，默认制定为这种控制权限，也被称为包控制权限，因为被其修饰的元素可以被同一个包中的其他类所访问。&lt;/p&gt;
&lt;p&gt;　　访问权限关键字的使用方式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; accessDemo {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; privateData;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; protectedData;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; publicMethod() {...}

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; defaultMethod() {...}
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　继承是面向对象程序设计中必不可少的组成部分。在Java中，使用extends关键字来表示类的继承关系。继承关系中，将已有的类成为父类（基类），由父类生成的新类称为子类（导出类）。如下面一段代码中，Animal类为父类，Dog类为它的子类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Animal(){

    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog(){

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　事实上在Java中创建一个类时，总是在继承，如果新建类时没有用extends指定继承自那个类，则就隐式地从Java的标准根类Object类进行继承。也就是说所有的类都继承自Object类。让所有类都继承自Object可以使所有的类都具有一些相同的特性，或者可以都可以进行某些操作。例如Java中所有的类都具有&lt;strong&gt;hashcode()&lt;/strong&gt;方法，可以计算该类对象的哈希值。这是Java中HashMap等重要数据结构实现的基础，也是判断对象间是否相同重要依据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　1、子类中的元素&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;子类继承父类的成员变量和方法。当一个子类继承一个父类时，子类便可以具有父类中的一些成员变量和方法，但子类只能继承父类中public和protected修饰的成员变量和方法。&lt;/li&gt;
&lt;li&gt;子类可以定义自己的成员变量和方法。在定义自己的成员变量和父类的中的变量名一致时，就会发生&lt;span&gt;&lt;strong&gt;隐藏&lt;/strong&gt;&lt;/span&gt;的现象。即子类中的变量会掩盖父类的变量。同样的，在定义方法时，如果子类的方法和父类的方法的方法名、参数列表和返回值都相同，则子类的方法就会&lt;span&gt;&lt;strong&gt;覆盖&lt;/strong&gt;&lt;/span&gt;父类的方法。&lt;strong&gt;&lt;span&gt;隐藏&lt;/span&gt;&lt;/strong&gt;和&lt;span&gt;&lt;strong&gt;覆盖&lt;/strong&gt;&lt;/span&gt;是有差别的，简单来说。隐藏适用于成员变脸和静态方法，是指在子类中不显示父类的成员变量和方法，如果将子类转换为父类，调用的还是父类的成员变量和方法；覆盖针对的是普通方法，如果将子类转换成父类，访问的还是子类的具体方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;　　2、构造器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;子类不会继承父类的构造器，但是既然子类能够继承父类中的成员变量，那么自然也需要对其成员变量进行必要的初始化，初始化的方法就是调用父类的构造器。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无参数构造器。如果父类的构造器没有参数，那么在调用子类的构造器时，编译器会默认调用父类的构造器，完成相关初始化工作。如下面这段代码：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Animal(){
        System.out.println(&lt;/span&gt;&quot;animal constructor&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Dog dog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Dog(){
        System.out.println(&lt;/span&gt;&quot;dog constructor&quot;&lt;span&gt;);
    }
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 运行结果：
 * animal constructor
 * dog constructor
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;有参数构造器。如果父类只有有参数的构造器，那么在子类的构造器中必须显式地调用父类的构造器，并且要位于子类构造器的最开始。否则在编译时就会报错。原因是在没有调用父类构造器的情况下，编译器会默认调用父类的无参数构造器。但此时编译器会找不到父类的无参数构造器，从而报错。如下面代码所示：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Animal(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
        System.out.println(&lt;/span&gt;&quot;animal constructor &quot; +&lt;span&gt; i);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        Dog dog &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Dog(0&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Dog(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; i){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(i);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用父类构造器&lt;/span&gt;
        System.out.println(&quot;dog constructor &quot; +&lt;span&gt; i);
    }
}
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 运行结果：
 * animal constructor 0
 * dog constructor 0
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1655095/201905/1655095-20190509211823334-1159117423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　多态的定义是允许不同的对象对同一消息进行相应，即同一消息可以根据对象的不同而进行不同的行为，这里的行为就是指方法的效用。多态的意义在于分离“做什么”和“怎么做”，从而消除类型之间的耦合性，改善代码的组织结构和可读性，创造可扩展的程序。我们通过以下这个程序来具体说明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Animal {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; takeFood(Animal animal){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         System.out.println(&quot;===start eat food===&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        animal.eat();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         System.out.println(&quot;====end eat food====&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         Animal animal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Dog();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        takeFood(animal);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         animal = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cat();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        takeFood(animal);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Dog &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal{
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         System.out.println(&quot;dog eat food&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Cat &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Animal{
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; eat() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         System.out.println(&quot;cat eat food&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt; * 运行结果：
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt; * ===start eat food===
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt; * dog eat food
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt; * ====end eat food====
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt; * ===start eat food===
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt; * cat eat food
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt; * ====end eat food====
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在上述代码中，Dog类和Cat类都继承自Animal类，并且各自&lt;span&gt;&lt;strong&gt;重写&lt;/strong&gt;&lt;/span&gt;了eat()方法。在代码的12行中创建了一个Dog类对象，但是却把它付给了一个Dog类的父类引用，第14行同样这么做。takeFood（）方法中的传入参数为一个父类对象，但是这并不影响第13行和15行中，将一个指向子类对象的Animal引用作为参数传入。并且在takeFood（）方法中调用传入对象内部的方法时，实际调用的是子类中的方法。&lt;/p&gt;
&lt;p&gt;　　通过以上代码我们可以总结，&lt;strong&gt;&lt;span&gt;多态存在的三个必要条件&lt;/span&gt;&lt;/strong&gt;是：1）继承；2）重写；3）父类引用指向子类对象。&lt;/p&gt;
&lt;p&gt;　　在上述代码中，takeFood（）方法体中的内容决定了“做什么”，具体“怎么做”却决定于参入对象的eat（）方法。而传入的对象中如何定义eat（）方法与takeFood（）的内容并不相关，因此便实现了两者的&lt;strong&gt;&lt;span&gt;解耦&lt;/span&gt;&lt;/strong&gt;。当我们将传入takeFood（）的参数由Dog类对象改为Cat类对象时，只需要修改引用的指向即可。这也就增强了代码的&lt;strong&gt;&lt;span&gt;可替换性&lt;/span&gt;&lt;/strong&gt;；当需要新增加一个新的动物Pig并进行相同的操作时，我们只需要新建一个Pig类，重写其中eat（）方法，然后将Pig类对象传入takeFood（）方法即可，这就是增强了代码的&lt;strong&gt;&lt;span&gt;可扩展性&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;动态绑定&lt;/h2&gt;
&lt;p&gt; 　　你可能会想知道，在takeFood（）方法中，调用的是Animal类的eat（）方法，而具体执行的方法主体却是子类中的方法。那么编译器是怎么知道调用一个方法时具体应该执行哪个方法主体呢？&lt;/p&gt;
&lt;p&gt;　　我们把方法调用和一个方法主体的关联起来成为&lt;strong&gt;&lt;span&gt;绑定&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。如果方法调用和方法主体在程序执行前就能关联起来，则称为&lt;strong&gt;&lt;span&gt;前期绑定（静态绑定）&lt;/span&gt;&lt;/strong&gt;，反之，如果必须到程序运行时才能知道方法调用具体应该执行哪一个方法，则称为&lt;strong&gt;&lt;span&gt;后期绑定（动态绑定）&lt;/span&gt;&lt;/strong&gt;。&lt;/span&gt;如果类B是类A的子类，A中定义了方法func(String s)，B中重写了方法func(String s)，那么此方法就需要使用动态绑定。如果x是B的一个实例，通过x.func(str)调用方法时，Java虚拟机会先在B中寻找此方法，如果B类中有对应方法，则直接调用它，否则就在B的父类A中寻找此方法。&lt;/p&gt;

&lt;p&gt; 　　在Java中，除了用static方法、final方法、private方法和构造方法以外，其他方法均采用动态绑定。这四种方法中：　　&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;private方法无法被继承，那么自然无法被重写，所以在编译时就可以确定具体调用的方法&lt;/li&gt;
&lt;li&gt;static方法可以被继承，可以被子类隐藏，但是不能被子类重写。所以也可以在编译时确定&lt;/li&gt;
&lt;li&gt;final方法可以被继承，但是不能被子类重写&lt;/li&gt;
&lt;li&gt;构造方法也不能被子类继承。子类的构造方法有两种：使用系统自动生成的无参数构造方法；调用父类的构造方法（包括自己定义构造方法并在其中调用父类的构造方法）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　由以上分析我们可以看出，上述四种方法可以使用静态绑定的最终原因都是：不会出现方法重写，不会产生子类与父类具有信息（方法名，参数个数，参数类型，返回类型等）完全相同的方法。&lt;/p&gt;

&lt;p&gt;[1]. &lt;a href=&quot;https://blog.csdn.net/u012340794/article/details/73194674&quot;&gt;https://blog.csdn.net/u012340794/article/details/73194674&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2].Java编程思想 第四版&lt;/p&gt;


&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 15:07:00 +0000</pubDate>
<dc:creator>尼尔森写代码</dc:creator>
<og:description>几乎每一本介绍Java语言的书中都会提到“面向对象”的这个概念，然而博主初学Java时看到这方面的内容一般都是草草地看一看，甚至是直接略过。原因很简单：考试基本不考，而且初学阶段写代码也很少用上。但事</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NelsonProgram/p/10832406.html</dc:identifier>
</item>
<item>
<title>[数据结构] - 线性表 - 梁天</title>
<link>http://www.cnblogs.com/gwyy/p/10841687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gwyy/p/10841687.html</guid>
<description>&lt;p&gt;&lt;span&gt;什么是线性表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线性表是其组成元素间具有线性关系的一种线性结构，对线性表的基本操作主要有获得元素，设置元素值，遍历，插入，删除，查找，替换，和排序等，在线性表任意位置都可以插入和删除，&lt;/span&gt;&lt;span&gt;可以采用顺序存储结构和链式存储结构表示线性表。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;8326-1550463662077-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;存储类别&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8326-1550463662077-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;顺序存储结构&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8326-1550463662077-cell-0-2&quot;&gt;
&lt;p&gt;&lt;span&gt;单链表&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td data-cell-id=&quot;8326-1550463662077-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;存储分配方式&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8326-1550463662077-cell-1-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;用一段连续的存储单元依次存储线性表的数据元素&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8326-1550463662077-cell-1-2&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;采用链式存储结构，用一组任意的存储单元存放线性表的元素&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td data-cell-id=&quot;8326-1550463662077-cell-2-0&quot;&gt;
&lt;p&gt;&lt;span&gt;时间性能&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8326-1550463662077-cell-2-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;查找O（1）、插入和删除O（n）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8326-1550463662077-cell-2-2&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;查找O（n）、插入和删除O（1）&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td data-cell-id=&quot;8326-1550463662077-cell-3-0&quot;&gt;
&lt;p&gt;&lt;span&gt;空间性能&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8326-1550463662077-cell-3-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;需要预分配存储空间，分大了浪费，小了容易发生上溢&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;8326-1550463662077-cell-3-2&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;不需要分配存储空间，只要有就可以分配，元素个数不受限制&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过上面的对比，可以得出一些经验性的结论：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;若线性表需要频繁查找，很少进行插入和删除操作时，宜采用顺序存储结构。若需要频繁插入和删除时，宜采用单链表结构。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;当线性表中的元素个数变化较大或者根本不知道有多大时，最好用单链表结构，这样可以不需要考虑存储空间的大小问题。而如果事先知道线性表的大致长度，用顺序存储结构效率会高很多.&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/319374/201905/319374-20190509230155744-1222316258.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;线性表抽象数据类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线性表（Linear List） 是由 n(n&amp;gt;=0) 个类型相同的数据元素组成的有限序列，（a0,a1,a2,an-1） 其中 ，元素ai 的数据类型可以是整数，浮点，字符串等，n是线性表元素个数，&lt;/span&gt;&lt;span&gt;称为线性表长度&lt;/span&gt;&lt;span&gt;（Length）.若n=0,则为空表，若n&amp;gt;0,则ai(0&amp;lt;i&amp;lt;n-1)有且仅有一个前驱元素ai-1,和一个后继元素ai+1. a0没有前驱元素，an-1没有后继元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在线性表逻辑结构中，使用序号约定数据元素在线性表中的位置，即表示元素之间具有的顺序关系。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;线性表的顺序存储&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组是实现顺序存储结构的基础，存储具有相同数据类型的元素集合，一位数组占用一块内存，数组的存储单元个数称为数组容量，也是数组长度，每个存储单元地址是连续的，每个元素连续存储，计算i个元素地址所需要的时间是个常量，时间复杂度是O(1),存取任何一个元素的时间复杂度是O(1)的数据结构是&lt;/span&gt;&lt;span&gt;随机存取结构&lt;/span&gt;&lt;span&gt;，因此数组是随机存取结构&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组通过下表识别元素，元素的下表是其存储单元序号，表示元素在数组中的位置，一位数组使用一个喜爱博爱唯一确定一个元素，二维数组使用两个下表唯一确定一个元素。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组一旦占用一片存储空间，其地址和容量就是确定的，不能更改，一次，数组只能进行赋值，取值两种随机操作。不能插入，删除。当容量不够时不能就地扩容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数组取值公式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;设loc(a0)表示第0个存储地址。每个元素占用c个字节 则 aI存储地址 Loc(ai) = Loc(a0) +i * c.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当数组容量不够，解决办法就是申请个容量更大的数组，然后把数据复制进去。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;微信公众号 (胡说代码) 输入：数组源码 即可获得源代码&lt;/p&gt;
&lt;p&gt;&lt;span&gt;链式：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线性表的链式存储结构是用若干地址分散的存储单元存储数据元素，逻辑上相邻的数据元素在物理位置不一定相邻，因此，必须采用附加信息表上数据元素之间的顺序关系，存储一个数据元素的存储单元称为节点（Node）一个节点至少包含两个部分：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;节点(数据域，地址域)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中，数据域存储元素数据，地址域（也成为链）存储前驱或后继元素地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个节点表示一个元素数据，通过节点中的地址域将节点连接起来，节点间的链接关系体现了线性表数据元素之间的顺序关系，采用链式存储结构的线性表称为线性链表（Linked List）一条线性链表必须使用一个头指针记住元素a0的节点位置。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个节点只有一个地址域的的线性表称为单链表（Singly Linked list）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单链表节点（data 数据域，next 地址域 指向后置节点）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;空单链表的头指针是 head = null ，最后一个节点的地址域也是null&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/319374/201905/319374-20190509230243991-1915677409.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;单链表中的存储空间是插入删除中动态申请和释放的，不需要给单链表预先分配存储空间，这样就可以避免顺序表因为空间不足，需要拷贝复制扩大空间，提高了运动效率和存储空间利用率。对单链表插入和删除操作只需要改变少量几个节点，不需要移动元素数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在c/c++中使用指针存储地址实现链式存储结构，java中没有指针使用引用来存储，引用是比指针更安全的一种连接方式，有指针的全部功能，而且避免了指针使用不当产生的安全性问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单链表：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单链表是由一个一个节点连接成的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;头节点：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;单链表的存储结构通常是带头结点的，在单链表最前增加一个特殊的节点，称为头节点，忽略其数据域，单链表的头指针head指向头结点，头节点 next域 指向单链表第0个元素， 空单链表只有一个头节点，head.next == null.遍历起始位置是 p=head.next 头插入和头删除不会改变head.有了头节点 单链表 插入和删除就不需要分开操作&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/319374/201905/319374-20190509230256795-1004108475.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;微信公众号 (胡说代码) 输入：单链表源码 即可获得源代码&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双链表（Doubly Linked Link）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在单链表中，每个节点只有一个指向后置节点的链，若要查找前驱节点，必须从单链表头指针开始沿着链表方向逐渐检索，操作效率很低，此时需要采用双链表。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;双链表节点（data数据域，prev前驱节点，next后继节点）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;双链表比单链表增加了一个前驱节点，给链表操作带来了很大的方便，能沿着向前，向后对双链表进行遍历&lt;/p&gt;

&lt;p&gt;&lt;span&gt;循环双链表（Circular Doubly Linked Link）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果双链表的最后一个节点的next指向头节点，头结点的prev指向最后一个节点，则构成循环双链表&lt;/p&gt;
&lt;p&gt;微信公众号 (胡说代码) 输入：循环双链表源码 即可获得源代码&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随机存取存储器概述&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;随机存取存储器（RAM）是计算机存储器中最为人熟知的一种。之所以RAM被称为“随机存储”，是因为您可以直接访问任一个存储单元，只要您知道该单元所在记忆行和记忆列的地址即可。&lt;/p&gt;
&lt;p&gt;与RAM形成鲜明对比的是顺序存取存储器（SAM）。SAM中的数据存储单元按照线性顺序排列，因而只能依顺序访问（类似于盒式录音带）。如果当前位置不能找到所需数据，就必须依次查找下一个存储单元，直至找到所需数据为止。SAM非常适合作缓冲存储器之用，一般情况下，缓存中数据的存储顺序与调用顺序相同（显卡中的质素缓存就是个很好的例子）。而RAM则能以任意的顺序存取数据。&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 15:01:00 +0000</pubDate>
<dc:creator>梁天</dc:creator>
<og:description>什么是线性表 线性表是其组成元素间具有线性关系的一种线性结构，对线性表的基本操作主要有获得元素，设置元素值，遍历，插入，删除，查找，替换，和排序等，在线性表任意位置都可以插入和删除，可以采用顺序存储结</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gwyy/p/10841687.html</dc:identifier>
</item>
<item>
<title>消息中间件——RocketMQ（一） 环境搭建（完整版） - Coder编程</title>
<link>http://www.cnblogs.com/coder-programming/p/10841650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/coder-programming/p/10841650.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509221741422.gif&quot; alt=&quot;求关注&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019050922482650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;环境搭建&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;每章一点正能量：自我控制是最强者的本能。——萧伯纳&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在学习消息中间件——RocketMQ，打算把这个学习过程记录下来。此章主要介绍环境搭建。此次主要是单机搭建（条件有限），包括在Windows、Linux环境下的搭建，以及console监控平台搭建，最后加一demo验证一下。&lt;/p&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;
&lt;p&gt;在搭建RocketMQ之前，请先确保如下环境已经搭建完毕&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java环境（我的JDK1.8）&lt;/li&gt;
&lt;li&gt;Maven环境（我的3.6.1目前最新版）&lt;/li&gt;
&lt;li&gt;Git环境&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;没有搭建的同学走传送门：&lt;/p&gt;
&lt;p&gt;JDK环境搭建： &lt;a href=&quot;https://jingyan.baidu.com/article/624e74597753b734e8ba5acb.html&quot;&gt;JAVA8环境搭建&lt;/a&gt;&lt;br/&gt;Maven环境搭建： &lt;a href=&quot;https://blog.csdn.net/Michael_HM/article/details/78207279&quot;&gt;Windows环境下使用Nexus 3.X 搭建Maven私服及使用介绍&lt;/a&gt;&lt;br/&gt;Git环境搭建：&lt;a href=&quot;https://jingyan.baidu.com/article/9f7e7ec0b17cac6f2815548d.html&quot;&gt;Git环境搭建及配置&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;windows环境下搭建&quot;&gt;1. Windows环境下搭建&lt;/h2&gt;
&lt;h3 id=&quot;下载&quot;&gt;1.1 下载&lt;/h3&gt;
&lt;p&gt;官方网站：http://rocketmq.apache.org/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508200005107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;官网&quot;/&gt;&lt;br/&gt;目前最新版的是V4.5.0，点击进去。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508200254586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;rocketmq-all-4.5.0-bin-release.zip&quot;/&gt;&lt;br/&gt;选择下载 rocketmq-all-4.5.0-bin-release.zip。弹出另外一个页面，这里选择rocketmq-all-4.5.0-bin-release.zip进行下载。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019050820241887.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;rocketmq-all-4.5.0-bin-release.zip&quot;/&gt;&lt;br/&gt;下载成功后，选择一个目录放好并解压。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508202601889.png&quot; alt=&quot;解压&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改jvm配置&quot;&gt;1.2 修改JVM配置&lt;/h3&gt;
&lt;p&gt;以上操作完毕之后，进入目录bin目录，我这里是&lt;br/&gt;&lt;code&gt;H:\rocketmq\rocketmq-all-4.5.0-bin-release\rocketmq-all-4.5.0-bin-release\bin&lt;/code&gt;。&lt;br/&gt;找到&lt;code&gt;runserver.cmd&lt;/code&gt;和&lt;code&gt;runbroker.cmd&lt;/code&gt;中的JAVA_OPT。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508202905620.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;原JAVA_OPT：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set &quot;JAVA_OPT=%JAVA_OPT% -server -Xms2g -Xmx2g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将 Xms Xmx 这两个值改小一些，改为1g，如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set &quot;JAVA_OPT=%JAVA_OPT% -server -Xms1g -Xmx1g -Xmn1g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;自己根据虚拟机内存大小设置，超出内存大小可能会报错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;配置环境变量&quot;&gt;1.3 配置环境变量&lt;/h3&gt;
&lt;p&gt;上述步骤执行完毕后，我们需要将RocketMQ安装目录的bin目录配置到环境变量中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508212226745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;RocketMQ_HOME&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动&quot;&gt;1.4 启动&lt;/h3&gt;
&lt;p&gt;以上配置都完成，接下来就是启动过程。中间有点坑，请务必按步骤安装。&lt;/p&gt;
&lt;p&gt;在RocketMQ安装目录的bin目录下，执行命令cmd：&lt;/p&gt;
&lt;p&gt;我的目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;H:\rocketmq\rocketmq-all-4.5.0-bin-release\rocketmq-all-4.5.0-bin-release\bin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过shift+鼠标右击 触发cmd窗口选项。也可以通过win+R 在窗口输入cmd，进入cmd窗口后移动到bin目录下。&lt;/p&gt;
&lt;h4 id=&quot;启动nameserver&quot;&gt;1.4.1 启动NAMESERVER&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;执行命令：start mqnamesrv.cmd&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;成功后会弹出提示框，此框勿关闭。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508212733393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;success&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;启动broker&quot;&gt;1.4.3 启动BROKER&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;执行命令：‘start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true’&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：假如弹出提示框提示‘错误: 找不到或无法加载主类 xxxxxx’。打开runbroker.cmd，然后将‘%CLASSPATH%’加上英文双引号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508213304353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;失败&quot;/&gt;&lt;br/&gt;打开 &lt;code&gt;runbroker.cmd&lt;/code&gt; 进行修改&lt;br/&gt;原：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set &quot;JAVA_OPT=%JAVA_OPT% -cp %CLASSPATH%&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;set &quot;JAVA_OPT=%JAVA_OPT% -cp &quot;%CLASSPATH%&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508213616854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;修改后&quot;/&gt;&lt;br/&gt;再次执行命令：&lt;br/&gt;启动成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019050821383525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;成功&quot;/&gt;&lt;br/&gt;这时候一共有三个窗口。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;安装console监控&quot;&gt;2. 安装Console监控&lt;/h2&gt;
&lt;h3 id=&quot;下载-1&quot;&gt;2.1 下载&lt;/h3&gt;
&lt;p&gt;下载地址：https://github.com/apache/rocketmq-externals&lt;/p&gt;
&lt;p&gt;下载完后如图所示：选择——&amp;gt;rocketmq-console&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508221338838.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;rocketmq-console&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置&quot;&gt;2.2 配置&lt;/h3&gt;
&lt;p&gt;下载完成之后，进入‘rocketmq-externals\rocketmq-console\src\main\resources’文件夹，打开‘application.properties’进行配置。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508221541791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;修改配置&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508221834416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;修改配置&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;编译启动&quot;&gt;2.2 编译启动&lt;/h3&gt;
&lt;p&gt;进入‘\rocketmq-externals\rocketmq-console’文件夹，执行‘mvn clean package -Dmaven.test.skip=true’，编译生成。中间有个比较慢的下载过程需要等待。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508222920827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;编译&quot;/&gt;&lt;br/&gt;编译成功之后，cmd进入‘target’文件夹，执行‘java -jar rocketmq-console-ng-1.0.1.jar’，启动‘rocketmq-console-ng-1.0.1.jar’。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508225631720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;rocketmq-console-ng-1.0.1.jar&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508225653418.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;rocketmq-console-ng-1.0.1.jar&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;查看&quot;&gt;2.3 查看&lt;/h3&gt;
&lt;p&gt;访问地址：localhost:8082&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190508230623194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;界面&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux环境下搭建&quot;&gt;2.Linux环境下搭建&lt;/h2&gt;
&lt;h3 id=&quot;环境准备-1&quot;&gt;2.1 环境准备&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Java环境&lt;/li&gt;
&lt;li&gt;Maven环境&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;linux环境搭建jdk&quot;&gt;2.1.1 Linux环境搭建Jdk&lt;/h4&gt;
&lt;p&gt;下载JDK:https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html&lt;/p&gt;
&lt;p&gt;下载需要的版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509213344234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;下载地址&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上传到创建的目录/usr/java&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;解压命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf jdk-8u181-linux-x64.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;配置环境变量命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;vim /etc/profile
 
JAVA_HOME=/usr/java/jdk1.8.0_161
JRE_HOME=/usr/java/jdk1.8.0_161/jre
CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
export JAVA_HOME JRE_HOME CLASS_PATH PATH
 
source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;验证是否成功命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;
java -version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509132000241.png&quot; alt=&quot;JDK安装成功&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照以上操作，完成JDK的安装。接下来安装Maven环境。&lt;/p&gt;
&lt;h4 id=&quot;linux环境搭建maven&quot;&gt;2.1.2 Linux环境搭建Maven&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;下载命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
wget http://mirror.bit.edu.cn/apache/maven/binaries/apache-maven-3.2.2-bin.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;解压命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
tar -zxvf apache-maven-3.2.2-bin.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;配置Maven环境命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
vim /etc/profile
 
#配置maven环境变量
export MAVEN_HOME=/usr/maven/apache-maven-3.5.4
export MAVEN_HOME
export PATH=$PATH:$MAVEN_HOME/bin
 
source /etc/profile
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;验证是否成功命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
mvn -v

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509131928304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;Maven安装成功&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;下载rocketmq&quot;&gt;2.2 下载RocketMQ&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;下载命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;
wget http://mirrors.hust.edu.cn/apache/rocketmq/4.4.0/rocketmq-all-4.4.0-source-release.zip
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;解压命令：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;unzip rocketmq-all-4.4.0-source-release.zip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509131950994.png&quot; alt=&quot;解压完毕&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构建二进制文件命令&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;进入解压后的文件目录。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mvn -Prelease-all -DskipTests clean install -U
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509132127685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;构建二进制成功&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改jvm配置-1&quot;&gt;2.3 修改JVM配置&lt;/h3&gt;
&lt;p&gt;同Windows环境一样，修改JVM配置。&lt;br/&gt;移动到目录 &lt;code&gt;/home/rocketmq/rocketmq-all-4.4.0/distribution/target/apache-rocketmq/bin&lt;/code&gt; 中。编辑bin目录下&lt;code&gt;runserver.sh&lt;/code&gt; 与 &lt;code&gt;runbroker.sh&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根据个人虚拟机大小进行修改&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
vim runserver.sh 
JAVA_OPT=&quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:PermSize=64m -XX:MaxPermSize=128m&quot;
vim runbroker.sh
JAVA_OPT=&quot;${JAVA_OPT} -server -Xms256m -Xmx256m -Xmn128m -XX:PermSize=64m -XX:MaxPermSize=128m&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509131833218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;修改JVM配置&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置rocketmq环境变量&quot;&gt;2.4 配置RocketMQ环境变量&lt;/h3&gt;
&lt;p&gt;分别执行如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#修改环境变量
vim /etc/profile

export ROCKETMQ=/home/rocketmq/rocketmq-all-4.4.0/distribution/target/apache-rocketmq
export PATH=$PATH:$ROCKETMQ/bin

#更新配置
source /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509132150873.png&quot; alt=&quot;配置RocketMQ环境变量&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动nameserver-1&quot;&gt;2.5 启动NAMESERVER&lt;/h3&gt;
&lt;p&gt;依然在之前的目录 &lt;code&gt;/home/rocketmq/rocketmq-all-4.4.0/distribution/target/apache-rocketmq&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行命令：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;##启动命令
nohup sh bin/mqnamesrv  &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;

##查看日志
tail -f ~/logs/rocketmqlogs/namesrv.log
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019050913220593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;启动NAMESERVER&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看图已经成功了！&lt;/p&gt;
&lt;h3 id=&quot;启动broker-1&quot;&gt;2.6 启动BROKER&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;执行命令：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;##启动命令
nohup sh bin/mqbroker -n localhost:9876 &amp;amp;

##查看日志
tail -f ~/logs/rocketmqlogs/broker.log
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509132244296.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;启动BROKER&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意防火墙，如果端口连接失败，注意开通。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;关闭命令&quot;&gt;2.7 关闭命令&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;sh bin/mqshutdown broker    //停止 broker
 
sh bin/mqshutdown namesrv   //停止 nameserver
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置console监控平台&quot;&gt;2.8 配置Console监控平台&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;同Windows平台搭建&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;启动console&quot;&gt;2.8.1 启动Console&lt;/h3&gt;
&lt;p&gt;我这里直接将Windows平台打包好的jar包直接丢到了Linux系统中&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动命令：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;java -jar rocketmq-console-ng-1.0.1.jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509132307484.png&quot; alt=&quot;console 启动&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;访问console管理界面&quot;&gt;2.8.2 访问Console管理界面&lt;/h3&gt;
&lt;p&gt;访问地址：http://192.168.220.72:8082&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509132320783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;Console管理界面&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;console监控平台说明&quot;&gt;3. Console监控平台说明&lt;/h2&gt;
&lt;p&gt;这里不做过多介绍，可以参考以下文章&lt;/p&gt;
&lt;p&gt;官网地址：https://github.com/apache/rocketmq-externals/blob/master/rocketmq-console/doc/1_0_0/UserGuide_CN.md&lt;/p&gt;
&lt;p&gt;其他博客地址：https://guozh.net/rocketmqzhiconsolejiankongpingtaishiyongxiangjiesan/&lt;/p&gt;
&lt;h2 id=&quot;案例测试&quot;&gt;3. 案例测试&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;案例整合环境：SpringBoot环境&lt;br/&gt;案例来源于网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;pom.xml文件&quot;&gt;3.1 pom.xml文件&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-parent&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.1.4.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;relativePath/&amp;gt; &amp;lt;!-- lookup parent from repository --&amp;gt;
    &amp;lt;/parent&amp;gt;
    &amp;lt;groupId&amp;gt;com.coderprogramming.rocketmq&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;rocketmq&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;rocketmq&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;

    &amp;lt;properties&amp;gt;
        &amp;lt;java.version&amp;gt;1.8&amp;lt;/java.version&amp;gt;
    &amp;lt;/properties&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.rocketmq&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;rocketmq-spring-boot-starter&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.0.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;producer生产者&quot;&gt;3.2 Producer生产者&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
**
　* @Description: 生产者
　* @author Coder编程
　* @date 2019/5/8 17:08
　*/

@Component
public class Producer {
    /**
     * 生产者的组名
     */
    @Value(&quot;${apache.rocketmq.producer.producerGroup}&quot;)
    private String producerGroup;

    /**
     * NameServer 地址
     */
    @Value(&quot;${apache.rocketmq.namesrvAddr}&quot;)
    private String namesrvAddr;


    public void orderedProducer() throws MQClientException, InterruptedException {
        /**
         * 一个应用创建一个Producer，由应用来维护此对象，可以设置为全局对象或者单例
         * 注意：ProducerGroupName需要由应用来保证唯一
         * ProducerGroup这个概念发送普通的消息时，作用不大，但是发送分布式事务消息时，比较关键，
         * 因为服务器会回查这个Group下的任意一个Producer
         */
        DefaultMQProducer producer = new DefaultMQProducer(producerGroup);
        producer.setNamesrvAddr(namesrvAddr);
        /**
         * Producer对象在使用之前必须要调用start初始化，初始化一次即可 注意：切记不可以在每次发送消息时，都调用start方法
         */
        producer.start();


        /**
         * 下面这段代码表明一个Producer对象可以发送多个topic，多个tag的消息。
         * 注意：send方法是同步调用，只要不抛异常就标识成功。但是发送成功也可会有多种状态
         * 例如消息写入Master成功，但是Slave不成功，这种情况消息属于成功，但是对于个别应用如果对消息可靠性要求极高，
         * 需要对这种情况做处理。另外，消息可能会存在发送失败的情况，失败重试由应用来处理。
         */
        try {
            for (int i = 0; i &amp;lt; 10; i++) {
                    Message msg = new Message(&quot;Topic1&quot;,// topic
                            &quot;TagA&quot;,// tag
                            &quot;001&quot;,// key
                            (&quot;Send Msg:Hello MetaQ1&quot;).getBytes());// body
                    SendResult sendResult = producer.send(msg);
                    System.out.println(sendResult);

                    Message msg2 = new Message(&quot;Topic2&quot;,// topic
                            &quot;TagB&quot;,// tag
                            &quot;002&quot;,// key
                            (&quot;Send Msg:Hello MetaQ2&quot;).getBytes());// body
                    SendResult sendResult2 = producer.send(msg2);
                    System.out.println(sendResult2);


                    Message msg3 = new Message(&quot;Topic3&quot;,// topic
                            &quot;TagC&quot;,// tag
                            &quot;003&quot;,// key
                            (&quot;Send Msg:Hello MetaQ3&quot;).getBytes());// body
                    SendResult sendResult3 = producer.send(msg3);
                    System.out.println(sendResult3);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        /**
         * 应用退出时，要调用shutdown来清理资源，关闭网络连接，从MetaQ服务器上注销自己
         * 注意：我们建议应用在JBOSS、Tomcat等容器的退出钩子里调用shutdown方法
         */
        producer.shutdown();
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;consumer消费者&quot;&gt;3.3 Consumer消费者&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;

/**
　* @Description: 消费者
　* @author Coder编程
　* @date 2019/5/8 17:08
　*/

@Component
public class Consumer {

    /**
     * 生产者的组名
     */
    @Value(&quot;${apache.rocketmq.producer.producerGroup}&quot;)
    private String producerGroup;

    /**
     * NameServer 地址
     */
    @Value(&quot;${apache.rocketmq.namesrvAddr}&quot;)
    private String namesrvAddr;


    /**
     * 当前例子是PushConsumer用法，使用方式给用户感觉是消息从RocketMQ服务器推到了应用客户端。
     * 但是实际PushConsumer内部是使用长轮询Pull方式从Broker拉消息，然后再回调用户Listener方法
     */
    public void orderedConsumer() throws InterruptedException,MQClientException {
        /**
         * 一个应用创建一个Consumer，由应用来维护此对象，可以设置为全局对象或者单例
         * 注意：ConsumerGroupName需要由应用来保证唯一
         */
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(producerGroup);
        // consumer.setNamesrvAddr(&quot;10.10.0.102:9876&quot;);
        consumer.setNamesrvAddr(namesrvAddr);
        /**
         * 订阅指定topic下tags分别等于TagA或TagC或TagD
         */
        consumer.subscribe(&quot;Topic1&quot;, &quot;TagA || TagC || TagD&quot;);
        /**
         * 订阅指定topic下所有消息&amp;lt;br&amp;gt;
         * 注意：一个consumer对象可以订阅多个topic
         */
        consumer.subscribe(&quot;Topic2&quot;, &quot;*&quot;);
        consumer.subscribe(&quot;Topic3&quot;, &quot;*&quot;);


        /**
         * 设置Consumer第一次启动是从队列头部开始消费还是队列尾部开始消费 如果非第一次启动，那么按照上次消费的位置继续消费
         */
        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);
        consumer.registerMessageListener(new MessageListenerConcurrently() {
            /**
             * 默认msgs里只有一条消息，可以通过设置consumeMessageBatchMaxSize参数来批量接收消息
             */
            @Override
            public ConsumeConcurrentlyStatus consumeMessage(
                    List&amp;lt;MessageExt&amp;gt; msgs, ConsumeConcurrentlyContext context) {
                System.out.println(Thread.currentThread().getName() + &quot; Receive New Messages: &quot; + msgs);

                MessageExt msg = msgs.get(0);
                if (msg.getTopic().equals(&quot;Topic1&quot;)) {
                    if (null != msg.getTags()) {
                        // 执行Topic1的消费逻辑
                        if (msg.getTags().equals(&quot;TagA&quot;)) {
                            // 执行TagA的消费
                            System.out.println(&quot;TagA开始。&quot;);
                        } else if (msg.getTags().equals(&quot;TagC&quot;)) {
                            System.out.println(&quot;TagC开始。&quot;);
                            // 执行TagC的消费
                        } else if (msg.getTags().equals(&quot;TagD&quot;)) {
                            // 执行TagD的消费
                            System.out.println(&quot;TagD开始。&quot;);
                        }
                    }
                } else if (msg.getTopic().equals(&quot;Topic2&quot;)) {
                    // 执行Topic2的消费逻辑
                    System.out.println(&quot;Topic2&quot;);
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            }
        });
        /**
         * Consumer对象在使用之前必须要调用start初始化，初始化一次即可
         */
        consumer.start();
        System.out.println(&quot;Consumer Started.&quot;);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;properties配置文件&quot;&gt;3.3 properties配置文件&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;
# 消费者的组名
apache.rocketmq.consumer.PushConsumer=PushConsumer
# 生产者的组名
apache.rocketmq.producer.producerGroup=Producer
# NameServer地址
apache.rocketmq.namesrvAddr=192.168.220.72:9876
# 设置应用端口
server.port=8089
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试代码&quot;&gt;3.4 测试代码&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
/**
 * @author Coder编程
 * @Title: HelloWord
 * @ProjectName rocketmq
 * @Description: Hello World
 * @date 2019/5/814:14
 */

@RestController
public class Test {

    @Autowired
    private Producer producer;

    @Autowired
    private Consumer consumer;

    @RequestMapping(&quot;/test&quot;)
    public String testMQ2() {
        try {
            System.out.println(&quot;-----------------开始生产-----------------&quot;);
            producer.orderedProducer();
            System.out.println(&quot;-----------------开始消费-----------------&quot;);
            consumer.orderedConsumer();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return &quot;success&quot;;
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;奉上源码&quot;&gt;4.奉上源码&lt;/h2&gt;
&lt;p&gt;以上安装jar包和案例测试源码已经上传至GitHub/Gitee&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190509163114218.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01pY2hhZWxfSE0=,size_16,color_FFFFFF,t_70&quot; alt=&quot;源码图&quot;/&gt;&lt;br/&gt;源码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/CoderMerlin/java-base-learning&quot;&gt;Github地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/573059382/java-base-learning&quot;&gt;Gitee地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;文末&quot;&gt;文末&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;欢迎关注公众号：&lt;strong&gt;Coder编程&lt;/strong&gt;&lt;br/&gt;获取最新原创技术文章和相关免费学习资料，随时随地学习技术知识！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190426221806703.jpg&quot; alt=&quot;微信公众号&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190429222933150.gif&quot; alt=&quot;求关注&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 09 May 2019 14:54:00 +0000</pubDate>
<dc:creator>Coder编程</dc:creator>
<og:description>每章一点正能量：自我控制是最强者的本能。——萧伯纳 前言 最近在学习消息中间件——RocketMQ，打算把这个学习过程记录下来。此章主要介绍环境搭建。此次主要是单机搭建（条件有限），包括在Window</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/coder-programming/p/10841650.html</dc:identifier>
</item>
<item>
<title>尝试讨论线性方程组相关数学原理、机器学习模型参数求解的数学本质 - Andrew.Hann</title>
<link>http://www.cnblogs.com/LittleHann/p/10547355.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LittleHann/p/10547355.html</guid>
<description>&lt;p&gt;笔者说明：笔者的数学知识和能力有限，本文的主要目的是为了尝试从数学角度讨论一下机器学习模型求解的本质思想，机器学习和深度学习领域中如此众多的模型背后，其共同的核心思想是什么。相关数学原理方面不会也做不到讨论非常深刻，相关数学公式、推导、定义全部来自丘维声教授的《简明线性代数》，不得不说这本书是笔者近几月以来认为最好的一本机器学习相关书籍了，也推荐读者朋友阅读。如果文章中有错误的地方，也请读者朋友一定要在评论区指出，特此感谢。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;0x1：无处不在的线性方程组&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;日常生活或生产实际中经常需要求一些量，用未知数 x1，x2，....，xn表示这些量，根据问题的实际情况列出方程组，而最常见的就是线性方程组（当然并不是说只能用线性方程组，深度神经网路里就是非线性方程组）。&lt;/p&gt;
&lt;p&gt;需要特别理解和思考的是，数学的各个分支以及自然科学、工程技术中，有不少问题都可以归纳为线性方程组的问题，养成抽象思维非常重要。 &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. 问题场景&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;某食品厂收到了某种食品2000kg的订单，要求这种食品含脂肪5%，碳水化合物12%，蛋白质15%。该厂准备用5种原料配置这种食品，其中每一种原料含脂肪、碳水化合物、蛋白质的百分比如下表示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190423211548913-1632902066.png&quot; alt=&quot;&quot; width=&quot;518&quot; height=&quot;108&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在的问题是：能否用上述5种原料配置出2000kg的这种食品？如果可以，那么有多少种这种配方？如果不可以，那么如何在满足营养成分的情况下，尽量的靠近目标产量（2000kg）。&lt;/p&gt;
&lt;p&gt;这是一个非常贴近现实业务的问题，我们从这个例子出来，来一起体会下机器学习是如何运用线性方程组来解决这种问题的。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 将具体问题抽象为行线性方程组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设每种原料（A1、A2、A3、A4、A5）所需要的的量分别为 x1，x2，x3，x4，x5，则将上述问题场景抽象为如下线性方程组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190423213906831-755525757.png&quot; alt=&quot;&quot; width=&quot;472&quot; height=&quot;124&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个方程是我们在初高中学习中非常熟悉的行方程组，从行视角来看，4行方程组5个未知数，无法完全消元，因此方程组的解有无数多个。对应到问题本身的现实场景就是，在实数域空间（强调重点）有无数种搭配方案可以满足题目的要求。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 以列向量形式重写线性方程组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;笔者思考：&lt;strong&gt;列向量相比行向量，有一种瞬间穿透事物表面，洞悉事物全部内核的哲学意味。如果把行向量比作量的累计，那么列向量则是质的变化，直接纵向穿透事物的所有维度&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上面的问题还可以用代数学的视角来重新思考，接下来我们用线性代数的相关知识来重写上述线性方程组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们把上述方程组的系数和常数项以&lt;strong&gt;列向量&lt;/strong&gt;的形式抽象为一个增广矩阵：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428151507636-1995177319.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这个场景中，列向量的物理意义还是相对明确的，即：&lt;strong&gt;每kg原料中包含了4个维度的物质量，这4个维度分别为【原料重量，脂肪量，碳水化合物量，蛋白质量】。A1，A2，A3，A4，A5这5种原料构成了5个实例（样本），每个数据样本的特征维度是4&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将改增广矩阵中系数据很和常数矩阵分别写成列向量组的形式：&lt;/p&gt;
&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;math&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F__latex%2Ff097154887764a05e3c07426bd779fe2.svg%22%2C%22code%22%3A%22X%5E%7BT%7D%20%3D%20(x_1%5E%7BT%7D%2Cx_2%5E%7BT%7D%2Cx_3%5E%7BT%7D%2Cx_4%5E%7BT%7D%2Cx_5%5E%7BT%7D)%22%2C%22width%22%3A192%2C%22height%22%3A25%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;center&quot;&gt;&lt;span class=&quot;lake-math-content&quot;&gt;&lt;span class=&quot;lake-math-content-preview&quot;&gt;&lt;span class=&quot;lake-math-content-preview-img&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428211631832-51251679.png&quot; alt=&quot;&quot;/&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;math&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F__latex%2Ff097154887764a05e3c07426bd779fe2.svg%22%2C%22code%22%3A%22X%5E%7BT%7D%20%3D%20(x_1%5E%7BT%7D%2Cx_2%5E%7BT%7D%2Cx_3%5E%7BT%7D%2Cx_4%5E%7BT%7D%2Cx_5%5E%7BT%7D)%22%2C%22width%22%3A192%2C%22height%22%3A25%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;center&quot;&gt;&lt;span class=&quot;lake-math-content&quot;&gt;&lt;span class=&quot;lake-math-content-preview&quot;&gt;&lt;span class=&quot;lake-math-content-preview-img&quot;&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428211643342-1186315780.png&quot; alt=&quot;&quot;/&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;math&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F__latex%2Ff097154887764a05e3c07426bd779fe2.svg%22%2C%22code%22%3A%22X%5E%7BT%7D%20%3D%20(x_1%5E%7BT%7D%2Cx_2%5E%7BT%7D%2Cx_3%5E%7BT%7D%2Cx_4%5E%7BT%7D%2Cx_5%5E%7BT%7D)%22%2C%22width%22%3A192%2C%22height%22%3A25%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;center&quot;&gt;&lt;span class=&quot;lake-math-content&quot;&gt;&lt;span class=&quot;lake-math-content-preview&quot;&gt;&lt;span class=&quot;lake-math-content-preview-img&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;math&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F__latex%2Ff097154887764a05e3c07426bd779fe2.svg%22%2C%22code%22%3A%22X%5E%7BT%7D%20%3D%20(x_1%5E%7BT%7D%2Cx_2%5E%7BT%7D%2Cx_3%5E%7BT%7D%2Cx_4%5E%7BT%7D%2Cx_5%5E%7BT%7D)%22%2C%22width%22%3A192%2C%22height%22%3A25%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;center&quot;&gt;&lt;span class=&quot;lake-math-content&quot;&gt;&lt;span class=&quot;lake-math-content-preview&quot;&gt;&lt;span class=&quot;lake-math-content-preview-img&quot;&gt;，其中，&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428160232379-927871585.png&quot; alt=&quot;&quot;/&gt;。注意向量的转置。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;math&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F__latex%2F7751c6722eb3c0437a01395d7c1b2f96.svg%22%2C%22code%22%3A%22b%20%3D%20(b_1%5E%7BT%7D)%22%2C%22width%22%3A61%2C%22height%22%3A24%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;center&quot;&gt;&lt;span class=&quot;lake-math-content&quot;&gt;&lt;span class=&quot;lake-math-content-preview&quot;&gt;&lt;span class=&quot;lake-math-content-preview-img&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428211705013-1976897294.png&quot; alt=&quot;&quot;/&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;math&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F__latex%2F7751c6722eb3c0437a01395d7c1b2f96.svg%22%2C%22code%22%3A%22b%20%3D%20(b_1%5E%7BT%7D)%22%2C%22width%22%3A61%2C%22height%22%3A24%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;center&quot;&gt;&lt;span class=&quot;lake-math-content&quot;&gt;&lt;span class=&quot;lake-math-content-preview&quot;&gt;&lt;span class=&quot;lake-math-content-preview-img&quot;&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428160500741-233783173.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;math&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fintranetproxy.alipay.com%2Fskylark%2Flark%2F__latex%2F7751c6722eb3c0437a01395d7c1b2f96.svg%22%2C%22code%22%3A%22b%20%3D%20(b_1%5E%7BT%7D)%22%2C%22width%22%3A61%2C%22height%22%3A24%7D&quot;&gt;&lt;span data-card-element=&quot;body&quot;&gt;&lt;span data-card-element=&quot;center&quot;&gt;&lt;span class=&quot;lake-math-content&quot;&gt;&lt;span class=&quot;lake-math-content-preview&quot;&gt;&lt;span class=&quot;lake-math-content-preview-img&quot;&gt;将要求解的未知量用向量组w来表示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428155428647-235894406.png&quot; alt=&quot;&quot;/&gt;，&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428161346686-150647261.png&quot; alt=&quot;&quot;/&gt;，一个w行向量4个维度都相同，即一个w行向量是一个1维向量。 &lt;/p&gt;
&lt;p&gt;它的物理意义是：&lt;strong&gt;每kg原料中，对4个维度的物质分别包含多少kg的原料&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;用向量组简写形式表达上面增广矩阵：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428162705996-355055781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个公式就是从列向量的角度重新看线性方程组。&lt;/p&gt;
&lt;p&gt;笔者思考：&lt;strong&gt;在这题的特定场景下，这里w1必须是1维的列向量，因为这是一个现实物理世界中的问题，我们不能说我们取了1kg的原料，我们同时也取了2kg的原料，这是不符合现实的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是在其他的抽象逻辑场景中，参数向量w常常可以是高维向量，例如深度神经网络中，参数权重向量w常常是上百甚至上千维的向量，从这个例子也可以更直观地体会到，更高维度的w向量，意味着我们对输入向量X中的不同维度可以由更细粒度的“取舍和控制”，more dimension，more complex&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：围绕线性方程组的数学问题&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;围绕上述线性方程组，需要研究下列几个问题：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 线性方程组是否一定有解？如果有解，有多少个解？
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 如何求线性方程组的解？如何高效地求解？
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;. 线性方程组有解时，它的每一个解是否都符合实际问题的需求，就像上面第一小节的线性方程组，在是属于上这个线性方程组有无穷多的解，但是实数域在现实世界往往不太实用，大多时候我们会选择整数域或者一个有限精度的浮点数域，这样解的个数就是有限的了。
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;. 线性方程组的解不只一个时，这些解之间有什么关系？
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;我们在实际业务场景中遇到的建模和机器学习问题，基本上可以归纳为上述问题的抽象和组合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文章的接下来部分，我们会围绕上面的几个问题展开讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Relevant Link:&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;liyangbit.com/math/jupyter-latex/&lt;/span&gt;
《简明线性代数》 -&lt;span&gt; 丘维声教授
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;zhuanlan.zhihu.com/p/33691914 内含B站的一组线性代数教学视频，讲的超级通俗易懂&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;0x1：线性方程组是否有解的等价问题 - 常数项是否可以由系数矩阵的列向量组线性表出&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;利用向量的加法运算和数乘运算，我们可以把数域K上的n元线性方程组：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428174327769-426343005.png&quot; alt=&quot;&quot; width=&quot;304&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428174359665-1400353120.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428174449308-739416887.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;116&quot;/&gt;&lt;/p&gt;
&lt;p&gt;则该线性方程组可写成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428174518315-317074882.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;24&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，数域K上的线性方程组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428174518315-317074882.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;24&quot;/&gt;有解，等价于下面两种表达：&lt;/p&gt;
&lt;p&gt;K中存在一组数，c1，c2，...，cn，使得&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428175426146-760361589.png&quot; alt=&quot;&quot; width=&quot;278&quot; height=&quot;22&quot;/&gt;成立；即 β 可以由a1，a2，...，an&lt;strong&gt;线性表出&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：线性相关与线性无关的向量组&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;在上一小节中，我们把&lt;strong&gt;线性方程组有没有解的问题归结为：常数项列向量能不能由系数矩阵的列向量线性表出&lt;/strong&gt;。接下来问题就是，如何研究&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中一个向量能不能由一个向量组线性表示呢？&lt;/p&gt;
&lt;p&gt;这个问题涉及到向量组的线性相关性的讨论，我们由浅入深，借助我们容易理解的3维几何空间来逐渐理解这个概念。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. 从3维集合空间出发讨论一个向量能否由向量组线性表出的问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;实数域R上的3维向量空间&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428220915216-1184265624.png&quot; alt=&quot;&quot;/&gt;的元素是3元有序实数组。在几何空间（由所有以原点为起点的向量组成）中，取定一个做个坐标系后，每个3元有序实数组表示一个向量。因此可以把&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428220915216-1184265624.png&quot; alt=&quot;&quot;/&gt;看成几何空间。这样我们可以从几何空间出发，来研究&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中一个向量能否由向量组线性表出的问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在几何空间中，设 a1 和 a2 不共线（这是向量基的充分条件）。&lt;/p&gt;
&lt;p&gt;如果 a3 可以由 a1，a2 线性表出，则 a1，a2，a3 共面；&lt;/p&gt;
&lt;p&gt;如果 a3 不能由 a1，a2 线性表出，则 a1，a2，a3 不共面；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429104410396-317293589.png&quot; alt=&quot;&quot; width=&quot;256&quot; height=&quot;188&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从解析几何角度我们知道：&lt;/p&gt;
&lt;p&gt;a1，a2，a3 共面的充分条件是有不全为零的实数 k1，k2，k3，使得 k1a1 + k2a2  +k3a3 = 0；&lt;/p&gt;
&lt;p&gt;a1，a2，a3 不共面的充要条件是：从  k1a1 + k2a2  +k4a4 = 0，直接推出 k1 = 0，k2 = 0，k4 = 0，即只有零解。&lt;/p&gt;
&lt;p&gt;从几何空间的上述例子受到启发，在&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中为了研究一个向量能否由一个向量组线性表出，就需要研究上述两种类型的向量组，即定义一组向量基，并且计算该向量能否由该向量基线性表出。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 向量组的线性相关性的抽象定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;下面给出向量组线性相关和线性无关的抽象定义公式，具体如何数值化计算该公式，我们文章后面继续深入讨论。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1）线性相关&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;称为线性相关的，如果有K中不全为零的数&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110338792-1128711052.png&quot; alt=&quot;&quot;/&gt;，使得&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110453120-1879787302.png&quot; alt=&quot;&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;从线性组合视角来看：即它们有&lt;strong&gt;系数不全为零&lt;/strong&gt;的线性组合等于零向量。&lt;/p&gt;
&lt;p&gt;从线性表出视角来看：即向量组中&lt;strong&gt;至少有一个向量&lt;/strong&gt;可以由&lt;strong&gt;其余向量线性表出&lt;/strong&gt;，也可以说这个向量组存在冗余向量，后面讨论PCA的时候会再谈到这点。&lt;/p&gt;
&lt;p&gt;从齐次线性方程组视角来看：即齐次线性方程组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429143244490-141856090.png&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;有非零解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从行列式视角来看：n个n维行向量&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;线性相关当且仅当以&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;为行向量组的矩阵的&lt;strong&gt;行列式等于零&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2）线性无关&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;如果不是线性相关的，则称为线性无关的，即如果从&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110453120-1879787302.png&quot; alt=&quot;&quot;/&gt;可以推出所有系数&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110338792-1128711052.png&quot; alt=&quot;&quot;/&gt;全为0，则称向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;是线性无关的。&lt;/p&gt;
&lt;p&gt;从线性组合视角来看：即它们只有&lt;strong&gt;系数全为零&lt;/strong&gt;的线性组合才会等于零向量。&lt;/p&gt;
&lt;p&gt;从线性表出视角来看：向量组中&lt;strong&gt;每一个向量&lt;/strong&gt;都不能由&lt;strong&gt;其余向量&lt;/strong&gt;线性表出。&lt;/p&gt;
&lt;p&gt;从齐次线性方程组视角来看：即齐次线性方程组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429143244490-141856090.png&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;只有非零解&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从行列式视角来看：n个n维行向量&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;线性相关当且仅当以&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;为行向量组的矩阵的&lt;strong&gt;行列式不等于零&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;根据上述定义以及解析几何的结论可以得到第一小节的问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 几何空间中，共面的3个向量是线性相关的，不共面的3个向量是线性无关的；
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;. 共线的2个向量是线性相关的，不共线的2个向量是线性无关的；
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;3. 向量组的延伸组合缩短组的线性相关性性质&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;1）向量组的缩短组 &lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 如果一个向量组线性无关，则它的任何一个部分组也线性无关；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者思考：如果高维的向量组是线性无关的，则它的低维子集组同样也是”紧密的“，即线性无关。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 如果一个向量组线性相关，则该向量组中一定存在某个缩短组也线性相关；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以借助3维空间来理解这个定义，下图中，向量E是一个(x,y,z)3维向量，B和C都是(-x,-y,0)的2维平面上的向量，D是(x,y,0)的2维平面向量，D的方向和B/C相反。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429163822296-212805881.png&quot; alt=&quot;&quot; width=&quot;601&quot; height=&quot;383&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以很容易理解，向量组（B，C，D，E）是线性相关的。同时该向量组的一个缩短组（B，C，E）是线性相关的。&lt;/p&gt;
&lt;p&gt;但是也容易看到，另一个缩短组（B，C）是线性无关的。&lt;/p&gt;
&lt;p&gt;笔者思考：&lt;strong&gt;一个向量组是线性相关的，可以理解为这个向量组中存在一个冗余结构，如果对应的部分组（缩短组）包含了这个冗余结果则该缩短组也同样是线性相关的，但如果该缩短组足够”小“，不包含该冗余结构，则该部分组是线性无关的。需要读者朋友注意的是，从3维几何空间来看线性相关和线性无关非常形象，但是到了更高维的空间就需要借助公式的推导和定义，因为高维空间超出人的想象空间了&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2）向量组的延伸组&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. 如果一个向量组的一个部分组线性相关，则整个向量组（延伸组）也线性相关；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;证明：&lt;/p&gt;
&lt;p&gt;设向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429151744962-502561759.png&quot; alt=&quot;&quot; width=&quot;202&quot; height=&quot;22&quot;/&gt;的一个部分组，例如说&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429151803656-879678375.png&quot; alt=&quot;&quot; width=&quot;103&quot; height=&quot;21&quot;/&gt;线性相关，则有数域K中不全为零的数 k1，k2，...，kt，使得&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429151859405-946277042.png&quot; alt=&quot;&quot; width=&quot;173&quot; height=&quot;21&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;从而有&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429151924554-1885036675.png&quot; alt=&quot;&quot; width=&quot;392&quot; height=&quot;21&quot;/&gt;。&lt;/p&gt;
&lt;p&gt;由于&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429152105973-1648887270.png&quot; alt=&quot;&quot; width=&quot;161&quot; height=&quot;22&quot;/&gt;不全为零，因此&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429151744962-502561759.png&quot; alt=&quot;&quot; width=&quot;202&quot; height=&quot;22&quot;/&gt;线性相关。 &lt;/p&gt;
&lt;p&gt;笔者思考：&lt;strong&gt;如果我们将线性相关理解为一个存在冗余的的空间结构的话，低维的部分组如果存在冗余结构，则维度升高到更高维后，这种冗余度必然是继续存在的（用真子集的概念来理解）&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;2. 如果一个向量组的一个部分组线性无关，存在一个它的延伸组也线性无关，同时也存在一个它的延伸组线性相关；&lt;/h4&gt;
&lt;p&gt;笔者思考：这个很容易理解，一个紧密结构的的向量组，当扩充新的向量进来后，有可能会破坏这种紧密结构。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4. 正交基向量组 - 一种特殊的线性无关向量组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们来一起看一个特殊的线性无关向量组。&lt;/p&gt;
&lt;p&gt;在&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中，向量组”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429174416284-1418950401.png&quot; alt=&quot;&quot; width=&quot;311&quot; height=&quot;141&quot;/&gt;&lt;/p&gt;
&lt;p&gt;是线性无关的。证明：&lt;/p&gt;
&lt;p&gt;设&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429174440269-260838778.png&quot; alt=&quot;&quot; width=&quot;197&quot; height=&quot;20&quot;/&gt;，即&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429174456371-1033102016.png&quot; alt=&quot;&quot; width=&quot;310&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从而：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429174518391-1014529386.png&quot; alt=&quot;&quot; width=&quot;111&quot; height=&quot;144&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此得出&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429174534879-1000517007.png&quot; alt=&quot;&quot; width=&quot;215&quot; height=&quot;20&quot;/&gt;，因此向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429174552408-477693805.png&quot; alt=&quot;&quot; width=&quot;97&quot; height=&quot;20&quot;/&gt;是线性无关的。&lt;/p&gt;
&lt;p&gt;值得注意的是，这个向量组不仅是相关无关的，而且向量组内的向量还是彼此正交的，这样的向量组可以作为其他向量组的&lt;strong&gt;正交基&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x3：向量组的秩&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;上个章节中我们讨论了向量组中部分组和由部分组线性表出一个另一个向量的话题。&lt;/p&gt;
&lt;p&gt;接下来新的问题来了，部分组可以随意选取吗？随便一个部分组都可以线性表出原向量组中的其余向量吗？如果不是，那这个部分组的向量个数是多少呢？部分组的选取是唯一的吗？&lt;/p&gt;
&lt;p&gt;带着这些问题，我们来讨论向量组的秩的问题。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. 从2维几何空间中得到极大线性无关组的启发&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430111626723-486017587.png&quot; alt=&quot;&quot; width=&quot;268&quot; height=&quot;119&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，几何空间中，设 a1，a2，a3 共面，并且 a1，a2，a3 两两不共线。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;它的一个&lt;strong&gt;部分组 a1，a2&lt;/strong&gt; 线性无关；
&lt;strong&gt;部分组 a1&lt;/strong&gt; 也线性无关；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;部分组 a1，a2 和部分组 a1 虽然都线性无关，但是它们有区别：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;对于部分组 a1 来说，添加上 a3 后得到的部分组 a1，a3 仍然线性无关；
而部分组 a1，a2 添加上 a3 后得到的 a1，a2，a3 就线性相关的了；&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从几何的视角来看，a1加上a3后，没有改变部分组的“线性无关紧密结构”。而 a1，a2 加上 a3 后，再也无法保持原部分组的”线性无关紧密结构“，变成了线性相关。&lt;/p&gt;
&lt;p&gt;这个性质非常有趣，也非常有用，在很多算法中，我们都需要获取并利用这个极大线性无关组。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 极大线性无关组的抽象定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中向量组的一个部分组称为一个&lt;strong&gt;极大线性无关组&lt;/strong&gt;，当且仅当这个部分组本身是线性无关的，但是从向量组的其余向量（如果还有的话）中任取一个添加进去，得到的新的部分组都线性相关。&lt;/p&gt;
&lt;p&gt;在上述例子中，a2，a3 和 a1，a3 都是 a1，a2，a3 的一个极大线性无关组。&lt;/p&gt;
&lt;p&gt;可以看到，这2个极大线性无关组的向量个数是相等的，这个性质是普遍存在的吗？这2个极大线性无关组之间的关系是怎样的？互相等价的吗？&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 向量组之间的等价性质&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;如果向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;的每一个向量都可以由向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430152941285-1150283004.png&quot; alt=&quot;&quot;/&gt;线性表出，则称向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;可以由向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430152941285-1150283004.png&quot; alt=&quot;&quot;/&gt;线性表出。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进一步，如果向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;可以由向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430152941285-1150283004.png&quot; alt=&quot;&quot;/&gt;可以&lt;strong&gt;互相线性表出&lt;/strong&gt;，则称向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190429110218843-1681975554.png&quot; alt=&quot;&quot;/&gt;可以由向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430152941285-1150283004.png&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;等价&lt;/strong&gt;，记作&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430153421424-771403365.png&quot; alt=&quot;&quot;/&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;向量组的等价是向量组之间的一种关系，这种关系具有下述三条特性：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 反身性：任何一个向量组都与自身等价；
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 对称性：
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;. 传递性：
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由上述基本特性可以推出：&lt;strong&gt;向量组的任意两个极大线性无关组等价&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的是，向量组的等价性质，不是数值意义上的等价，而是&lt;strong&gt;解空间结构的等价性&lt;/strong&gt;。 两个向量组等价，是在说这&lt;strong&gt;两个向量组的解空间结构相同&lt;/strong&gt;。解空间结构相同，进而这两个向量组的秩也相同，秩可以理解为描述解空间结构维度的度量。&lt;/p&gt;
&lt;p&gt;这里还是从空间几何角度来帮助理解。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1）情形1&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;设 a1，a2 不同线。如果&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430163719313-900137813.png&quot; alt=&quot;&quot;/&gt;可以由 a1，a2 线性表出，则&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430163719313-900137813.png&quot; alt=&quot;&quot;/&gt;一定共面，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430164120002-1588426924.png&quot; alt=&quot;&quot; width=&quot;358&quot; height=&quot;145&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430163719313-900137813.png&quot; alt=&quot;&quot;/&gt;虽然有3个向量，但是因为和向量组 a1，a2 等价，所以它的秩依然是2。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2）情形2&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;设 a1，a2 同线，如果&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430163719313-900137813.png&quot; alt=&quot;&quot;/&gt;可以由 a1，a2 线性表出，则&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430163719313-900137813.png&quot; alt=&quot;&quot;/&gt;一定共线，即秩为1，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190430170117709-822960551.png&quot; alt=&quot;&quot; width=&quot;266&quot; height=&quot;78&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上述可以推出一个推论：&lt;strong&gt;等价的线性无关的向量组所含向量的个数相等&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;这个推论和我们本章的标题本质是一致的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方程组（向量组）的解空间结构，就是由该向量组的所有等价的极大线性无关组组成的。其中每个极大线性无关组都是线性无关的，且他们的向量个数相同（等价的向量组有相同的秩），等于原向量组的秩&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4. 向量组的秩的抽象定义&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;向量组的极大线性无关组所含向量的个数称为这个向量组的秩。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x4：线性方程组有解的充分必要条件&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;有了上面章节的铺垫后，接下来可以来讨论我们如何直接用线性方程组的系数和常数项判断方程组有没有解，有多少解的问题。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. 定理1 - 线性方程组有解判别定理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;线性方程组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505164517444-1080805150.png&quot; alt=&quot;&quot;/&gt;有解的充要条件是：它的系数矩阵A与增广矩阵A'有相同的秩。这个定理可以这么理解，线性方程组有解，等价于：&lt;/p&gt;
&lt;p&gt;存在一组不全为0的{a1，...，an}，使得&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505164517444-1080805150.png&quot; alt=&quot;&quot;/&gt;有解；&lt;/p&gt;
&lt;p&gt;也即 β 可以由向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505165123307-1213164739.png&quot; alt=&quot;&quot;/&gt;线性表出；&lt;/p&gt;
&lt;p&gt;也即向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505165140254-1813064297.png&quot; alt=&quot;&quot;/&gt;线性相关；&lt;/p&gt;
&lt;p&gt;向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505165123307-1213164739.png&quot; alt=&quot;&quot;/&gt;是向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505165907195-1737446404.png&quot; alt=&quot;&quot;/&gt;的一个极大线性无关组，向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505165907195-1737446404.png&quot; alt=&quot;&quot;/&gt;和向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505165123307-1213164739.png&quot; alt=&quot;&quot;/&gt;等价；&lt;/p&gt;
&lt;p&gt;需要注意的是，这个定理只能判断线性方程组是否有解，至于是有唯一解还是有无穷解无法判断。 &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 定理2 - 线性方程组解个数判别定理&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;线性方程组有解时，如果它的系数矩阵A的秩等于未知量的个数n，则方程组有唯一解；&lt;/p&gt;
&lt;p&gt;如果A的秩小于n，则方程组有无穷多个解；&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 推论 - 齐次线性方程组有非零解条件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;其次线性方程组有非零解的充要条件是：它的系数矩阵的秩小于未知量的个数；&lt;/p&gt;
&lt;p&gt;齐次线性方程组比较特殊，如果它又唯一解那一定是零解，因此其次线性方程组要么无解，要么有无穷多个解。&lt;/p&gt;


&lt;p&gt;讨论了通用线性方程组解的一般性质之后，我们来缩小范围，将讨论视角集中在齐次线性方程组，齐次线性方程组是一类非常重要的方程组，在机器学习的很多算法和优化理论中都有它的身影。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x1：从几何空间得到的启发&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;实数域R上一个3元齐次线性方程表示过原点的一个平面。&lt;/p&gt;
&lt;p&gt;因此3元齐次线性方程组的解集W可能是以下几种情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. &lt;strong&gt;过原点的一条直线 l&lt;/strong&gt;：W中每个向量可以由 l 中的一个方向向量线性表出；
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. &lt;strong&gt;过原点的一个平面 ∏&lt;/strong&gt;：W中每个向可以由平面∏上不共线的两个向量线性表出；
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;. &lt;strong&gt;原点&lt;/strong&gt;（即零向量）；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这表明在3元齐次线性方程组对应的3维空间中，解集W中无穷多个向量可以用W中一个或两个向量线性表出。&lt;/p&gt;
&lt;p&gt;接下来讨论一般情况下，齐次线性方程组的解空间结构。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：齐次线性方程组的解集的线性运算封闭特性&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 性质1 - 其次线性方程组的任意两个解的和还是方程组的解 &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;齐次线性方程组的解空间（线性子空间）对加法封闭。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 性质2 - 其次线性方程组的任意一个解的倍数还是方程组的一个解 &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;齐次线性方程组的解空间（线性子空间）对数量乘法封闭。 &lt;/p&gt;
&lt;p&gt;综合上述2个性质得出，齐次线性方程组的解集W是&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;的一个&lt;strong&gt;子空间&lt;/strong&gt;，称为方程组的&lt;strong&gt;解空间&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x3：齐次线性方程组的基础解系&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;齐次线性方程组有非零解时，此时方程组有无限多的解。但是这无限多的解可以由一组有限多个解&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505211622932-1287535830.png&quot; alt=&quot;&quot;/&gt;来归纳表示，这组有限多的解满足以下条件：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505211629047-200040850.png&quot; alt=&quot;&quot;/&gt;线性无关；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 方程组的每一个解都可以由&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505211652453-1871167526.png&quot; alt=&quot;&quot;/&gt;线性表出；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;则称&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505211707500-1145981880.png&quot; alt=&quot;&quot;/&gt;是齐次线性方程组的一个&lt;strong&gt;基础解系&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果齐次线性方程组有一个基础解系，那么&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505212128423-1764993374.png&quot; alt=&quot;&quot;/&gt;称为方程组的通解。&lt;/p&gt;
&lt;p&gt;基础解析是用来表示所有解的一组解集，它本身具有归纳总结特性。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. 定理1 - 基础解系向量个数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;数域K上n元齐次线性方程组的系数矩阵A的秩小于未知量个数n时，它一定有基础解系。并且它的每一个基础解系所含解向量的个数等于 n - rank(A)；&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x4：数域 K 上 n元齐次线性方程组的”基“和”维数“的概念 &lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 线性子空间的基&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;设U是&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;的一个子空间，U中的向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506144641944-412201973.png&quot; alt=&quot;&quot;/&gt;如果满足下述两个条件：&lt;/p&gt;
&lt;p&gt;1. &lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506144656619-389125014.png&quot; alt=&quot;&quot;/&gt;线性无关；&lt;/p&gt;
&lt;p&gt;2. U中每一个向量都可以由&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506144656619-389125014.png&quot; alt=&quot;&quot;/&gt;线性表出；&lt;/p&gt;
&lt;p&gt;则称&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506144656619-389125014.png&quot; alt=&quot;&quot;/&gt;是U的一个&lt;strong&gt;基&lt;/strong&gt;（基可以有很多）。&lt;/p&gt;
&lt;p&gt;于是，如果&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505211622932-1287535830.png&quot; alt=&quot;&quot;/&gt;是齐次线性方程组的一个基础解系，则&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505211622932-1287535830.png&quot; alt=&quot;&quot;/&gt;同时也可以被称为是解空间W的一个基（基的概念比基础解析的范围更泛）。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 线性子空间的标准基&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;由于&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506145520287-824576899.png&quot; alt=&quot;&quot;/&gt;线性无关，并且&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中每一个向量都可以由&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506145520287-824576899.png&quot; alt=&quot;&quot;/&gt;线性表出，因此&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506145520287-824576899.png&quot; alt=&quot;&quot;/&gt;是&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;的一个基，称它为&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;的标准基。&lt;/p&gt;
&lt;p&gt;几何空间中，任取三个不共面的向量a1，a2，a3，由于任何一个向量β 可以由 a1，a2，a3 线性表出，并且 a1，a2，a3 线性无关，因此 a1，a2，a3 是几何空间的一个基。&lt;/p&gt;
&lt;p&gt;可以证明，&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;的每一个非零子空间U 都有一个基。也就是说，任何一个解集，都可以通过对应的一个基（基础解析）来归纳表示。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 非零线性子空间中基所包含的向量个数&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;的非零子空间U的任意两个基所含向量个数相等，这两个基互相等价。&lt;/p&gt;
&lt;p&gt;设U是&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;的一个非零子空间，U的一个基所含向量的个数称为&lt;strong&gt;U的维数&lt;/strong&gt;，记作&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506161001429-2016462079.png&quot; alt=&quot;&quot;/&gt;或者简记为&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506161026535-127053873.png&quot; alt=&quot;&quot;/&gt;。特别的，零子空间的维数规定为0。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;4. n维向量空间&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;由于&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506161144030-1221942176.png&quot; alt=&quot;&quot;/&gt;是&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;的一个基，因此&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506161257189-1589444482.png&quot; alt=&quot;&quot;/&gt;，因此我们也把&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;称为&lt;strong&gt;n维向量空间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在几何空间中，任意三个不共面的向量是它的一个基，因此几何空间是3维空间；&lt;/p&gt;
&lt;p&gt;过原点的一个平面，它的任意两个不共线的向量是它的一个基，因此过原点的平面是2维的子空间；&lt;/p&gt;
&lt;p&gt;过原点的一条直线，它的一个方向向量是它的一个基，因此过原点的直线是1维的子空间；&lt;/p&gt;
&lt;p&gt;数域K上n元齐次线性方程组有非零解时，它的解空间W的每一个基所含向量个数为 n - rank(A)，其中A是方程组的系数矩阵。因此解空间的维数为&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506162107518-1800747336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基对于决定子空间的结构起了非常重要的作用，如果知道了子空间U的一个基，那么U中每一个向量都可以由这个基线性表出，并且&lt;strong&gt;表出的方式是唯一的&lt;/strong&gt;，其中系数组成的有序数组称为该向量在这个基下的&lt;strong&gt;坐标&lt;/strong&gt;。 &lt;/p&gt;
&lt;h3&gt;&lt;span&gt;5. 向量组的极大线性无关组和对应子空间维数的关系&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中，向量组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506174424498-154456117.png&quot; alt=&quot;&quot;/&gt;的一个极大线性无关组是子空间&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506174532524-1296075878.png&quot; alt=&quot;&quot;/&gt;的一个基，从而：&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506174621975-1660952349.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该定理表明：&lt;strong&gt;向量组的秩等于由它生成的子空间的维数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从而将线性子空间的基/维数的概念和线性方程组/极大线性无关组/秩的概念联系了起来。&lt;/p&gt;


&lt;p&gt;数域&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;上n元非齐次线性方程组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505164517444-1080805150.png&quot; alt=&quot;&quot;/&gt;的一个解是&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201904/532548-20190428215934795-44352946.png&quot; alt=&quot;&quot;/&gt;中的一个向量，称它为方程组的一个解向量。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x1：从几何空间得到的启发&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;3元非齐次线性方程组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505221219418-2047476143.png&quot; alt=&quot;&quot; width=&quot;125&quot; height=&quot;19&quot;/&gt;的解集是不过原点的一个平面&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506135719584-911734863.png&quot; alt=&quot;&quot;/&gt;，而相应的齐次线性方程组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506135519836-2016177774.png&quot; alt=&quot;&quot;/&gt;的解集是过原点的一个平面&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506135732344-1000864734.png&quot; alt=&quot;&quot;/&gt;，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505223806236-1798766467.png&quot; alt=&quot;&quot; width=&quot;243&quot; height=&quot;263&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506135719584-911734863.png&quot; alt=&quot;&quot;/&gt;可以由&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506135739178-295017934.png&quot; alt=&quot;&quot;/&gt;沿着向量&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506135801384-447666630.png&quot; alt=&quot;&quot;/&gt;平移得到。&lt;/p&gt;
&lt;p&gt;于是&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506135719584-911734863.png&quot; alt=&quot;&quot;/&gt;上每一个向量&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506135931513-516128452.png&quot; alt=&quot;&quot;/&gt;可以表示成：&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506140039733-570531517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：齐次线性方程组的解结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;从上面3维几何空间的的例子我们受到启发，n元非齐次线性方程组的解集U，与相应的n元齐次线性方程组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506141224628-1860448182.png&quot; alt=&quot;&quot;/&gt;的解集W 有如下关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506141358142-407191280.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506141411448-665730277.png&quot; alt=&quot;&quot;/&gt;是非齐次线性方程组的一个特解，W是方程组的导出组的解集。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. 非齐次线性方程组的导出组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们把n元齐次线性方程组&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506141224628-1860448182.png&quot; alt=&quot;&quot;/&gt;称为&lt;strong&gt;非齐次线性方程组的导出组&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;1）性质1：n元非齐次线性方程组的两个解的差是它的导出组的一个解。&lt;/p&gt;
&lt;p&gt;2）性质2：n元非齐次线性方程组的一个解与它的导出组的一个解之和，仍是非齐次线性方程组的一个解。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 非齐次线性方程组的通解&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;当n元非齐次线性方程组有无穷多个解时，它的导出组必有非零解。此时导出组的一个基础解系&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190505211622932-1287535830.png&quot; alt=&quot;&quot;/&gt;，其中 t 是导出组的系数矩阵A的秩。&lt;/p&gt;
&lt;p&gt;则非齐次线性方程组的解集U为：&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506142528220-1160170554.png&quot; alt=&quot;&quot; width=&quot;422&quot; height=&quot;17&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506135801384-447666630.png&quot; alt=&quot;&quot;/&gt;是&lt;strong&gt;非齐次线性方程组的一个特解&lt;/strong&gt;；解集U的代表元素&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506142628182-538781399.png&quot; alt=&quot;&quot; width=&quot;269&quot; height=&quot;20&quot;/&gt;称为&lt;strong&gt;非齐次线性方程组的通解&lt;/strong&gt;。 &lt;/p&gt;



&lt;h2&gt;&lt;span&gt;0x1：线性方程组解的物理意义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;假设一个维数为3的线性方程组（即基础解析的向量个数为3），该线性方程组包含若干个三元一次方程： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506205803807-54437621.png&quot; alt=&quot;&quot; width=&quot;231&quot; height=&quot;150&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中每一个三元一次方程代表三维空间中的一个平面，也叫由3维基础解析张成的向量空间。&lt;/p&gt;
&lt;p&gt;如果平面个数大于维度，称为&lt;strong&gt;超定方程&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;小于维度，称为&lt;strong&gt;欠定方程&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;等于维度，称为&lt;strong&gt;适定方程&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;满足这个线性方程组的解 &lt;span id=&quot;MathJax-Element-65-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;3&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-108&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-109&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-110&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-111&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-112&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-113&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-114&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-115&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-116&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-117&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-118&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-119&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-120&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-121&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-122&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-123&quot; class=&quot;mn&quot;&gt;3&lt;span id=&quot;MathJax-Span-124&quot; class=&quot;mo&quot;&gt;] &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;同时属于所有平面，接下来我们来讨论线性方程组的解的个数从0，1，无穷多时，分别对应的几何概念。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：齐次方程组的解对应的几何意义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;齐次方程组具有形式&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506211624326-1864596277.png&quot; alt=&quot;&quot; width=&quot;54&quot; height=&quot;18&quot;/&gt;&lt;span id=&quot;MathJax-Element-23-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;，每个方程对应的平面都是过原点的。根据系数矩阵&lt;span id=&quot;MathJax-Element-24-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-508&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-509&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-510&quot; class=&quot;mi&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;的秩不同，有以下三种情况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;1. 【情况1】&lt;span id=&quot;MathJax-Element-25-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;r&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;3&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-511&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-512&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-513&quot; class=&quot;mi&quot;&gt;r&lt;span id=&quot;MathJax-Span-514&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-515&quot; class=&quot;mi&quot;&gt;A&lt;span id=&quot;MathJax-Span-516&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-517&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-518&quot; class=&quot;mn&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;A的每一行，即所有平面的法向量[a11,a12,a13]，[a21,a22,a23]，[a31,a32,a33]...能够张成一个三维空间。&lt;/p&gt;
&lt;p&gt;平面只有一个交点：[0,0,0]，线性方程有一个解，即零解。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506212417829-1409268101.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 【情况2】r(A)=2&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span id=&quot;MathJax-Element-29-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;r&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;所有平面的法向量，都处于同一个平面内。 &lt;br/&gt;由于三个平面都过同一个点&lt;span id=&quot;MathJax-Element-30-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-603&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-604&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-605&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-606&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-607&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-608&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-609&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-610&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-611&quot; class=&quot;mo&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;，所以他们共有一条交线，线性方程有无穷多解。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506212635735-138746381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同时要注意的是，这些解共线，换句话说，解集构成了一个二维的子空间。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 【情况3】r(A)=1 &lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;所有平面的法向量共线，整个线性方程组其实可以简化为一行。&lt;br/&gt;由于三个平面都过同一个点，所有平面重合于过&lt;span id=&quot;MathJax-Element-33-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-630&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-631&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-632&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-633&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-634&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-635&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-636&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-637&quot; class=&quot;mn&quot;&gt;0&lt;span id=&quot;MathJax-Span-638&quot; class=&quot;mo&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;的平面，线性方程有无穷多解。&lt;span id=&quot;MathJax-Element-34-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;c&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mover&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;&amp;amp;#x00AF;&amp;lt;/mo&amp;gt;&amp;lt;/mover&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x3：非齐次方程组的解对应的几何意义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;非齐次方程具有形式&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506213636991-1155671009.png&quot; alt=&quot;&quot; width=&quot;61&quot; height=&quot;17&quot;/&gt;，&lt;span id=&quot;MathJax-Element-38-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;相当于把齐次线性方程组对应的若干平面进行整体平移。&lt;/span&gt;&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;这种情况相当于所有平面都平移&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506213915300-897482364.png&quot; alt=&quot;&quot; width=&quot;83&quot; height=&quot;20&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506213951314-455830150.png&quot; alt=&quot;&quot; width=&quot;386&quot; height=&quot;153&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写成矩阵形式：&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506214021997-1748671410.png&quot; alt=&quot;&quot; width=&quot;95&quot; height=&quot;22&quot;/&gt;，即，常数项&lt;span id=&quot;MathJax-Element-45-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-923&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-924&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-925&quot; class=&quot;mi&quot;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;可以表示成&lt;span id=&quot;MathJax-Element-46-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-926&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-927&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-928&quot; class=&quot;mi&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;的列的线性组合，即&lt;span id=&quot;MathJax-Element-47-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-929&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-930&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-931&quot; class=&quot;mi&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;b处于&lt;span id=&quot;MathJax-Element-48-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-932&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-933&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-934&quot; class=&quot;mi&quot;&gt;A&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;的列空间内。把&lt;span id=&quot;MathJax-Element-49-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-935&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-936&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-937&quot; class=&quot;mi&quot;&gt;A，&lt;span id=&quot;MathJax-Span-938&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-939&quot; class=&quot;mi&quot;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;并列组成的增广矩阵&lt;span id=&quot;MathJax-Element-50-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;[&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;A&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;;&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;]&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-940&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-941&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-942&quot; class=&quot;mo&quot;&gt;[&lt;span id=&quot;MathJax-Span-943&quot; class=&quot;mi&quot;&gt;A&lt;span id=&quot;MathJax-Span-944&quot; class=&quot;mo&quot;&gt;;&lt;span id=&quot;MathJax-Span-945&quot; class=&quot;mi&quot;&gt;b&lt;span id=&quot;MathJax-Span-946&quot; class=&quot;mo&quot;&gt;]。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;从矩阵的角度来说，增加一列不会减少矩阵的秩，即 r(A) ≤ r([A;b] &lt;br/&gt;如果 r(A) = r([A;b])，则 Ax = b 的解的情况和Ax=0相同；&lt;br/&gt;如果 r(A) &amp;lt; r([A;b])，则 Ax = b 无解（参考文章前面对线性方程组解存在条件的讨论）；&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Relevant Link:&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;blog.csdn.net/shenxiaolu1984/article/details/54893299&lt;/span&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;technology.cpm.org/general/3dgraph/ &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;0x1：用三角旋转的例子来说明矩阵的本质是一种变换(transformation)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;平面上取定一个直角坐标系Oxy，所有以原点为起点的向量组成的集合记作V，让V中每个向量绕原点O旋转角度θ，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506215713886-1074384488.png&quot; alt=&quot;&quot; width=&quot;269&quot; height=&quot;179&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个旋转是一个transformation动作，那如何通过数学来形式化定义这个旋转动作呢？&lt;/p&gt;
&lt;p&gt;我们将上述旋转角度θ的这个动作记作σ&lt;/p&gt;
&lt;p&gt;设&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506220327343-400681774.png&quot; alt=&quot;&quot;/&gt;的坐标为（x，y），它在旋转 σ 下的像&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506220422588-1577206781.png&quot; alt=&quot;&quot;/&gt;的坐标为（x'，y'）。设以 x 轴的正半轴为始边，以射线OP为终边的角为a，设&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506220625176-1583044702.png&quot; alt=&quot;&quot;/&gt;，从三角函数的定义得：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506221952211-2108258385.png&quot; alt=&quot;&quot; width=&quot;337&quot; height=&quot;50&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此得出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506222013136-1103377467.png&quot; alt=&quot;&quot; width=&quot;235&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上式就是旋转σ的公式，把公式中的系数写成矩阵的形式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190506222106495-81216219.png&quot; alt=&quot;&quot; width=&quot;176&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该矩阵就表示了转角为θ的旋转，即将输入向量的坐标整体移动一个角度。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x2：矩阵乘法的几何意义&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;设&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507102557466-2012546747.png&quot; alt=&quot;&quot; width=&quot;175&quot; height=&quot;19&quot;/&gt;，令&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507102612673-458053582.png&quot; alt=&quot;&quot; width=&quot;107&quot; height=&quot;22&quot;/&gt;，其中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507103113746-222586119.png&quot; alt=&quot;&quot; width=&quot;344&quot; height=&quot;71&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则矩阵C称为矩阵A与B的乘积，记作 C = AB&lt;/p&gt;
&lt;p&gt;矩阵乘法有几个要点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;&lt;span&gt;. 只有左矩阵的列数与右矩阵的行数相同的两个矩阵才能相乘；
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;. 乘积矩阵的（i，j）元等于左矩阵的第 i 行与右矩阵的第 j 列的对应元素的乘积之和；
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;. 乘积矩阵的行数等于左矩阵的行数，乘积矩阵的列数等于右矩阵的列数； 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进一步来说，&lt;strong&gt;矩阵的乘法本质上是将矩阵对应的变换应用到被乘的向量组上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;矩阵乘法也可以被称为线性转换。矩阵相当于一个转换函数，而向量组是一个输入，已知了输入和函数，我们就可以知道输出，如果是多个矩阵相乘，则可以理解为复合变换函数，即f(g(x...))。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x3：矩阵对应的旋转变换的几何例子&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;下图展示了将原始向量组旋转180°对应的矩阵：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507134605052-1703530677.png&quot; alt=&quot;&quot; width=&quot;765&quot; height=&quot;440&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;读者朋友可以自己修改矩阵的元素值，观察不同的矩阵元素值对应的不同的转换动作。&lt;/p&gt;
&lt;p&gt;笔者这里手工调整了几个参数，通过gif图的方式来展示不同的矩阵对应的不同变换动作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507135445053-1567746919.gif&quot; alt=&quot;&quot; width=&quot;727&quot; height=&quot;312&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Relevant Link:&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jingyan.baidu.com/article/425e69e6f6c290be14fc165c.html&lt;/span&gt;&lt;span&gt;
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.geogebra.org/search/matrix%20transformation&lt;/span&gt;&lt;span&gt;
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.geogebra.org/m/wsTPe55F &lt;/span&gt;&lt;span&gt;
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.geogebra.org/m/u6jD5As8 &lt;/span&gt;&lt;span&gt;
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.yasuotu.com/gifhecheng &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;&lt;span&gt;0x1：线性回归算法模型求解的数学原理&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 为什么不能直接基于样本数据求解n元线性方程组&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;文章的开头，我们举了一个工厂生产某种食品的例子。在这个例子中，我们没有借助任何机器学习算法，而是直接基于样本输入数据，得到了一个线性方程组，然后尝试求解这个线性方程组。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这看起来毫无毛病，我按照你题目给的条件构建一个对应的方程组，然后求解，如果得到了唯一解，则该解就是最优解，也即唯一的可行解。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但遗憾的是，包括本例在内，&lt;strong&gt;现实世界中的几乎所有场景中，几乎不可能刚好得到一个唯一解&lt;/strong&gt;，换句话说，99.99%的场景中，我们都无法得到一个100% recall，100% precision的model。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在很多时候，我们基于样本数据和对应的条件构建出的线性方程组是&lt;strong&gt;无解&lt;/strong&gt;或者有&lt;strong&gt;无穷多的解&lt;/strong&gt;的，这个时候我们如何该如何继续下去呢？宣布放弃，这个问题无法解决了吗？&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 引入损失函数，求解一个等价的最优化问题&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;答案显然不是的，我们可以退而求其次，既然无法100%达到全局最优解，那我们可以尝试获得一个次优解，并使该次优解和最优解的“距离”在所有次优解中最接近。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;引入损失函数的目的就是：&lt;strong&gt;将原始问题转换为另一个最优化问题，通过求解损失函数下最优解得到原始问题的一个次优解，损失函数（loss function）的作用就是完成这个”问题域转换“的桥梁。&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;引入损失函数后，我们的优化目标转换为了：求得一个使当前损失函数值最小的最优解。那接下来的问题就是，基于损失函数构建的新的方程长什么样？解空间结构如何？是否有解？如何求解？&lt;/p&gt;
&lt;p&gt;损失函数有很多种选择，这里以linear regression最契合的MSE(均方损失函数)为例：&lt;/p&gt;
&lt;p&gt;在线性回归问题中，假设模型为：&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507221545933-1955040133.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线性模型试图学得&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190309150901624-2006804985.png&quot; alt=&quot;&quot; width=&quot;213&quot; height=&quot;22&quot;/&gt;。同时在噪声符合高斯分布的假设前提下，均方误差是衡量 f(x) 和 y 之间的差别的最佳损失函数。&lt;/p&gt;
&lt;p&gt;我们构建让均方误差最小化的公式，即：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190312214422528-1291255121.png&quot; alt=&quot;&quot; width=&quot;241&quot; height=&quot;102&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，均方误差最小化公式是一个累加公式，将所有样本数据(通过下标 i 表示)对应的线性方程值和目标值的差值的平方进行了累计，即所有样本的误差的平方和。&lt;/p&gt;
&lt;p&gt;读者朋友可以这么理解：将原本基于样本数据得到线性方程组，每一列(列向量)都减去一个目标值并计算平方，然后将所有方程都累加起来。注意，有的书籍或者paper在上述公式中还会加入一个1/N，但对最终结果是没有影响的，因为我们求的是对w的偏导数，实数在这里会被忽略。&lt;/p&gt;
&lt;p&gt;求解 w 和 b 使&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190312215929897-222271191.png&quot; alt=&quot;&quot; width=&quot;179&quot; height=&quot;22&quot;/&gt;最小化的过程，称为&lt;strong&gt;线性回归模型的最小二乘参数估计（parameter estimation）&lt;/strong&gt;。我们可将&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190312220439174-572800640.png&quot; alt=&quot;&quot; width=&quot;39&quot; height=&quot;20&quot;/&gt;分别对 w 和 b 求导，得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201903/532548-20190318160256977-855599264.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;103&quot;/&gt;&lt;/p&gt;
&lt;p&gt;令上式等于零可得到 w 和 b 最优解的闭式（closed-form）解，同时损失函数中极值就是上式参数优化公式的最小值，线性规划问题得解。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3. 通过矩阵来简化线性回归中损失函数的微分/偏导数运算&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上一小节中我们通过偏导数方式实现了对均方误差函数的求解，这很直观利于理解，但是在计算机科学中，求解偏导数的运算并不高效，像sklearn这种数学库采用的都是矩阵matrix的形式进行快速计算。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Relevant Link:&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/LittleHann/p/10498579.html&lt;/span&gt;&lt;span&gt;
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;zhuanlan.zhihu.com/p/27664917&lt;/span&gt;&lt;span&gt;
https:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/pinard/p/10750718.html &lt;/span&gt;&lt;span&gt;
http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/pinard/p/10791506.html &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;0x2：深度神经网络的隐层结构 = 线性变换+非线性变换组合的多次叠加&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;我们将构建一个神经网络：包括五个全连接层，每层都含有不同数目的单元，结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507151231708-23448119.png&quot; alt=&quot;&quot; width=&quot;458&quot; height=&quot;305&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于单个神经元来说，计算过程对应的线性方程为：&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507171112305-388986143.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507171159929-1479975234.png&quot; alt=&quot;&quot; width=&quot;356&quot; height=&quot;192&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个一层隐藏层的权重参数向量组构成了一个向量矩阵W，为了清楚起见，以下是第二层的所有表达式：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507171429948-294581114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从矩阵视角来看，一层隐藏层对应的矩阵运算公式如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190507171541114-1776778735.png&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的a 是激活函数，激活函数是一种非线性变换，激活函数对输入向量组的扭曲是非线性的，因此提供了更好的适应性，并且能在学习过程中提供一些复杂的函数。&lt;/p&gt;
&lt;p&gt;通过多层的隐层对应的线性变换和非线性变换的组合迭代后，原始输入空间的向量基会被转换到一个新的维度（一般是高维）中，在这个新的线性子空间中，原本线性不可分的向量组可能就可以变得线性可分，或者在一定的错误冗余下线性可分，进而得到一个解空间。 &lt;/p&gt;
&lt;h2&gt;&lt;span&gt;0x3：为什么深度神经网络中不能继续用复合非线性方程组的理论进行直接求解&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;关于这个话题的讨论，笔者目前的理解也不是完全吃透，等以后对凸优化理论的理解更透彻之后会再回来把这部分完善补全，呈现给读者朋友。&lt;/p&gt;
&lt;p&gt;大致的回答是，因为非线性性，和高维度的原因，矩阵偏导数运算变得十分困难，有时甚至无法计算。&lt;/p&gt;
&lt;p&gt;相关的一些讨论，可以参阅我另一篇blog.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.cnblogs.com/LittleHann/p/10498579.html&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;）梯度下降算法（Gradient decent）来求解线性回归模型参数
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;0x4：GD/SGD梯度下降的数学原理&lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;1. 在小学习率下，GD梯度下降公式等价于一阶泰勒级数展开&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们从一阶泰勒级数展开这个话题开始讨论，逐步分析GD梯度下降成立的前提条件以及它的合理性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先，泰勒当年为什么要发明这条公式？因为当时数学界对简单函数的研究和应用已经趋于成熟，而复杂函数，比如：&lt;img src=&quot;https://img-blog.csdn.net/20180602202828948&quot; alt=&quot;&quot;/&gt;这种一看就头疼的函数，还有那种根本就找不到表达式的曲线（例如深度神经网络中，线性和非线性复合层叠，隐层的函数形式已经变得极度复杂）。除了代入一个x可以得到它的y，就啥事都很难干了。所以泰勒同学就迎难而上！决定让这些式子统统现出原形，统统变简单。&lt;/p&gt;
&lt;p&gt;可以简单的理解为：&lt;strong&gt;泰勒级数展开和微积分的本质原理很类似，都是通过大量小区间的线性近似来模拟原始函数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们以一阶泰勒展开式为例：&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;a href=&quot;http://attachbak.dataguru.cn/attachments/portal/201805/16/153042ydfk36dclk5dkfo7.jpg&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://attachbak.dataguru.cn/attachments/portal/201805/16/153042ydfk36dclk5dkfo7.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190509221737380-442337563.png&quot; alt=&quot;&quot; width=&quot;423&quot; height=&quot;267&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;凸函数f(θ)的某一小段[θo，θ]由上图黑色曲线表示，可以利用线性近似的思想求出f(θ)的值，如上图红色直线。该直线的斜率等于f(θ)在θo处的导数。则根据直线方程，很容易得到f(θ)的近似表达式为：&lt;/p&gt;
&lt;div&gt;
&lt;p&gt;&lt;a href=&quot;http://attachbak.dataguru.cn/attachments/portal/201805/16/153042swarnqq3eze88qto.jpg&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;http://attachbak.dataguru.cn/attachments/portal/201805/16/153042swarnqq3eze88qto.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这就是一阶泰勒展开式的推导过程，主要利用的数学思想就是曲线函数的线性拟合近似。牛顿法的原理推导也是类似的原理，有兴趣的读者可以google相关内容。&lt;/p&gt;
&lt;p&gt;讨论完一阶泰勒级数展开的公式后，我们接下里来看一下一阶泰勒级数展开和GD梯度下降的关系。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190509222025703-732383865.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;想要两个向量的乘积小于零，我们先来看一下两个向量乘积包含哪几种情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190509222106511-1109718355.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A和B均为向量，α为两个向量之间的夹角。A和B的乘积为：&lt;/p&gt;
&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/532548/201905/532548-20190509222132366-1465581960.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;由上述讨论可知，GD梯度下降过程中，就等价于不断进行一阶泰勒级数展开来”近似“地”沿着目标函数下降的方向“进行前进。但其实我们也可以看到，每次前进都伴随着一定的损失，这是一阶泰勒级数和真实函数之间的差值导致的。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;要特别强调的是，这既是一个原理性的理解，也是一个工程实践中要谨记的要点，我们在使用pytorch/TensorFlow/keras进行项目开发的时候，学习率η一定要设置的足够小，设置的足够小，不仅仅是为了让我们足够靠近局部最优，这同时也是一阶泰勒级数展开的必要条件，如果不满足这个条件，GD梯度下降本身的误差就会很大，自然也就无法有效逼近全局次优解。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2. 为什么GD梯度下降不能避免误差&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;由上个小节的讨论我们知道，一阶泰勒级数展开本身也只是对原始函数的的一种近似线性模拟，即使你每次选择的是负梯度方向，也不能100%沿着原始函数的真实方向进行下降，每一次GD迭代都是存在误差的。&lt;/p&gt;
&lt;p&gt;即使采用同二阶泰勒级数，误差也同样存在，只是会比一阶要小，但是阶数越往上，计算的复杂度就越大。在一般情况下，一阶泰勒级数展开已经可以获得比较好的近似度和优化速度了，工业场景中基本上默认采用一阶泰勒级数展开。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;Relevant Link:&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt; &lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;juejin.im/post/5a570c25518825734f529e3b&lt;/span&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.tinymind.cn/articles/1272?from=articles_commend &lt;/span&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;blog.csdn.net/SoHardToNamed/article/details/80550935 &lt;/span&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;blog.csdn.net/sinat_15443203/article/details/82048888&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 09 May 2019 14:34:00 +0000</pubDate>
<dc:creator>Andrew.Hann</dc:creator>
<og:description>尝试讨论线性方程组相关数学原理、机器学习模型参数求解的数学本质</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/LittleHann/p/10547355.html</dc:identifier>
</item>
<item>
<title>深度学习 - 常用优化算法 - 常规操作</title>
<link>http://www.cnblogs.com/betabear/p/10184700.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/betabear/p/10184700.html</guid>
<description>&lt;p&gt;更新公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \theta = \theta - \eta \sum_{i=1}^{m}\nabla g(\theta;x_i,y_i) \]&lt;/span&gt;&lt;br/&gt;其中，&lt;code&gt;m&lt;/code&gt; 为样本个数&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;优点：每次更新都会朝着正确的方向进行，最后能够保证收敛于极值点（凸函数收敛于全局极值点，非凸函数可能会收敛于局部极值点）&lt;br/&gt;缺点：每次学习时间过长，并且如果训练集很大以至于需要消耗大量的内存，不能进行在线模型参数更新&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更新公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \theta = \theta - \eta\nabla g(\theta;x_i,y_i) \]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;优点：学习速度快，可在线更新&lt;br/&gt;缺点：每次更新可能不会按照正确的方向进行，因此会带来优化波动，使得迭代次数（学习次数）增多，即收敛速度变慢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不过从另一个方面来看，随机梯度下降所带来的波动有个好处就是，对于类似盆地区域（即很多局部极小值点）那么这个波动的特点可能会使得优化的方向从当前的局部极小值点跳到另一个更好的局部极小值点，这样便可能对于非凸函数，最终收敛于一个较好的局部极值点，甚至全局极值点。如下图所示：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/24/5c2094a1222fc.png&quot; alt=&quot;随机梯度下降&quot;/&gt;&lt;/div&gt;

&lt;p&gt;更新公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[ \theta = \theta - \eta\sum_{i=t}^{t+k}\nabla g(\theta;x_i,y_i)\]&lt;/span&gt;&lt;br/&gt;其中，&lt;code&gt;k&lt;/code&gt;为每批样本的数量&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;优点：相对于随机梯度下降，Mini-batch梯度下降降低了收敛波动性，即降低了参数更新的方差，使得更新更加稳定。相对于批量梯度下降，其提高了每次学习的速度。并且其不用担心内存瓶颈从而可以利用矩阵运算进行高效计算&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;更新公式：&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\nu_t = \gamma\nu_{t-1} -1 + \eta\nabla g(\theta)\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\theta = \theta - \nu_t\]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7.4016620498615&quot;&gt;
&lt;p&gt;优点：能解决SGD在峡谷地区（一些方向较另一些方向上陡峭得多，常见于局部极值点）附近振荡导致收敛速度慢的问题，详见&lt;a href=&quot;https://zh.diveintodeeplearning.org/chapter_optimization/momentum.html&quot;&gt;《动手学深度学习》&lt;/a&gt;&lt;br/&gt;缺点：需要选择足够小的学习率使得自变量在梯度值较大的维度上不发散。但这样会导致自变量在梯度值较小的维度上迭代过慢&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Adagrad 的算法会使用一个小批量随机梯度 &lt;span class=&quot;math inline&quot;&gt;\(g_t\)&lt;/span&gt; 按元素平方的累加变量 &lt;span class=&quot;math inline&quot;&gt;\(s_t\)&lt;/span&gt; 。在时间步 0，Adagrad 将 &lt;span class=&quot;math inline&quot;&gt;\(s_0\)&lt;/span&gt; 中每个元素初始化为 0。在时间步 t ，首先将小批量随机梯度 &lt;span class=&quot;math inline&quot;&gt;\(g_t\)&lt;/span&gt; 按元素平方后累加到变量 &lt;span class=&quot;math inline&quot;&gt;\(s_t\)&lt;/span&gt; ：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[s_t = s_{t-1} + g_t\odot g_t\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;符号 &lt;span class=&quot;math inline&quot;&gt;\(\odot\)&lt;/span&gt; 是按元素相乘。接着，我们将目标函数自变量中每个元素的学习率通过按元素运算重新调整一下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x_t = x_{t-1} - \frac{\eta}{\sqrt{s_t + \epsilon}}\odot g_t\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt; 是学习率，&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 是为了维持数值稳定性而添加的常数，例如&lt;span class=&quot;math inline&quot;&gt;\(10^{-6}\)&lt;/span&gt;。这里开方、除法和乘法的运算都是按元素进行的。这些按元素运算使得目标函数自变量中每个元素都分别拥有自己的学习率。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;优点：每个变量都有自己的学习率，如果目标函数有关自变量中某个元素的偏导数一直都较大，那么该元素的学习率将下降较快；反之，如果目标函数有关自变量中某个元素的偏导数一直都较小，那么该元素的学习率将下降较慢&lt;br/&gt;缺点：由于&lt;span class=&quot;math inline&quot;&gt;\(s_t\)&lt;/span&gt;一直在累加按元素平方的梯度，自变量中每个元素的学习率在迭代过程中一直在降低（或不变），梯度下降太快。所以，当学习率在迭代早期降得较快且当前解依然不佳时，Adagrad 在迭代后期由于学习率过小，可能较难找到一个有用的解&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;不同于 Adagrad 里状态变量 &lt;span class=&quot;math inline&quot;&gt;\(s_t\)&lt;/span&gt; 是截至时间步 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 所有小批量随机梯度 &lt;span class=&quot;math inline&quot;&gt;\(g_t\)&lt;/span&gt; 按元素平方和，RMSProp 将这些梯度按元素平方做指数加权移动平均。具体来说，给定超参数 &lt;span class=&quot;math inline&quot;&gt;\(0\leq\gamma\lt1\)&lt;/span&gt; ，RMSProp 在时间步 &lt;span class=&quot;math inline&quot;&gt;\(t\gt0\)&lt;/span&gt; 计算&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[s_t = \gamma s_{t-1} + (1-\gamma)g_t\odot g_t\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;和 Adagrad 一样，RMSProp 将目标函数自变量中每个元素的学习率通过按元素运算重新调整，然后更新自变量&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x_t = x_{t-1} - \frac{\eta}{\sqrt{s_t + \epsilon}}\odot g_t\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt; 是学习率，&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt; 是为了维持数值稳定性而添加的常数，例如 &lt;span class=&quot;math inline&quot;&gt;\(10 ^ {-6}\)&lt;/span&gt; 。因为 RMSProp 的状态变量是对平方项 &lt;span class=&quot;math inline&quot;&gt;\(g_t \odot g_t\)&lt;/span&gt; 的指数加权移动平均，所以可以看作是最近 &lt;span class=&quot;math inline&quot;&gt;\(\frac{1}{1-\gamma}\)&lt;/span&gt; 个时间步的小批量随机梯度平方项的加权平均&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;优点：自变量每个元素的学习率在迭代过程中不再一直降低（或不变），解决了 Adagrad 学习率衰减过快的问题&lt;br/&gt;缺点：依赖于全局学习率&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Adam 使用了动量变量 &lt;span class=&quot;math inline&quot;&gt;\(\nu_t\)&lt;/span&gt; 和 RMSProp 中小批量随机梯度按元素平方的指数加权移动平均变量 &lt;span class=&quot;math inline&quot;&gt;\(s_t\)&lt;/span&gt; ，并在时间步 0 将它们中每个元素初始化为 0。给定超参数 &lt;span class=&quot;math inline&quot;&gt;\(0\leq\beta_1\lt1\)&lt;/span&gt;（算法作者建议设为 0.9），时间步 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 的动量变量 &lt;span class=&quot;math inline&quot;&gt;\(\nu_t\)&lt;/span&gt; 即小批量随机梯度 &lt;span class=&quot;math inline&quot;&gt;\(g_t\)&lt;/span&gt; 的指数加权移动平均：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\nu_t = \beta_1\nu_{t-1} + (1-\beta_1)g_t\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;和 RMSProp 中一样，给定超参数 &lt;span class=&quot;math inline&quot;&gt;\(0\leq\beta_2\lt1\)&lt;/span&gt;（算法作者建议设为 0.999）， 将小批量随机梯度按元素平方后的项 &lt;span class=&quot;math inline&quot;&gt;\(g_t\odot g_t\)&lt;/span&gt; 做指数加权移动平均得到 &lt;span class=&quot;math inline&quot;&gt;\(s_t\)&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[s_t = \beta_2 s_{t-1} + (1-\beta_2)g_t\odot g_t\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于我们将 &lt;span class=&quot;math inline&quot;&gt;\(\nu_0\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(s_0\)&lt;/span&gt; 中的元素都初始化为 0， 在时间步 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 我们得到 &lt;span class=&quot;math inline&quot;&gt;\(\nu_t = (1-\beta_1)\sum_{i=1}^{t}\beta_{1}^{t-i}g_i\)&lt;/span&gt; 。将过去各时间步小批量随机梯度的权值相加，得到 &lt;span class=&quot;math inline&quot;&gt;\((1-\beta_1)\sum_{i=1}^{t}\beta_{1}^{t-i}g_i = 1-\beta_{1}^{t-i}\)&lt;/span&gt; 。需要注意的是，当 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; 较小时，过去各时间步小批量随机梯度权值之和会较小。例如当 &lt;span class=&quot;math inline&quot;&gt;\(\beta_1=0.9\)&lt;/span&gt; 时，&lt;span class=&quot;math inline&quot;&gt;\(\nu_1 = 0.1 g_1\)&lt;/span&gt; 。为了消除这样的影响，对于任意时间步 &lt;span class=&quot;math inline&quot;&gt;\(t\)&lt;/span&gt; ，我们可以将 &lt;span class=&quot;math inline&quot;&gt;\(\nu_t\)&lt;/span&gt; 再除以 &lt;span class=&quot;math inline&quot;&gt;\(1-\beta_{1}^{t}\)&lt;/span&gt; ，从而使得过去各时间步小批量随机梯度权值之和为 1。这也叫做偏差修正。在 Adam 算法中，我们对变量 &lt;span class=&quot;math inline&quot;&gt;\(\nu_t\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(s_t\)&lt;/span&gt; 均作偏差修正：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{\nu}_t = \frac{\nu_t}{1-\beta_1^{t}}\]&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\hat{s}_t = \frac{s_t}{1-\beta_2^{t}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;接下来，Adam 算法使用以上偏差修正后的变量 &lt;span class=&quot;math inline&quot;&gt;\(\hat{\nu}_t\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(\hat{s}_t\)&lt;/span&gt; ，将模型参数中每个元素的学习率通过按元素运算重新调整：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[g'_t = \frac{\eta \hat{\nu}_t}{\sqrt{\hat{s}_t + \epsilon}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;span class=&quot;math inline&quot;&gt;\(\eta\)&lt;/span&gt; 是学习率，&lt;span class=&quot;math inline&quot;&gt;\(\epsilon\)&lt;/span&gt;是为了维持数值稳定性而添加的常数，例如 &lt;span class=&quot;math inline&quot;&gt;\(10^{-8}\)&lt;/span&gt;。和 Adagrad、RMSProp 以及 Adadelta 一样，目标函数自变量中每个元素都分别拥有自己的学习率。最后，使用 &lt;span class=&quot;math inline&quot;&gt;\(g'_t\)&lt;/span&gt; 迭代自变量：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[x_t = x_{t-1} - g'_t\]&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;优点：Adam 结合了 AdaGrad 和 RMSProp 两种优化算法的优点，拥有自适应学习率，利用梯度的一阶矩估计和二阶矩估计动态调整每个参数的学习率。另外，经偏置校正后，每一次迭代学习率都有个确定范围，使得参数比较平稳&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面两幅图可视化形象地比较上述各优化方法，详细参见&lt;a href=&quot;http://ruder.io/optimizing-gradient-descent/index.html&quot;&gt;这里&lt;/a&gt;，如图：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/24/5c20943d95855.gif&quot; alt=&quot;SGD各优化方法在损失曲面上的表现&quot;/&gt;&lt;/div&gt;
&lt;p&gt;从上图可以看出，Adagrad、Adadelta 与 RMSprop 在损失曲面上能够立即转移到正确的移动方向上达到快速的收敛。而 Momentum 与 NAG 会导致偏离(off-track)。同时 NAG 能够在偏离之后快速修正其路线，因为其根据梯度修正来提高响应性。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://i.loli.net/2018/12/24/5c20947445075.gif&quot; alt=&quot;SGD各优化方法在损失曲面鞍点处上的表现&quot;/&gt;&lt;/div&gt;
&lt;p&gt;在鞍点（saddle points）处(即某些维度上梯度为零，某些维度上梯度不为零)，SGD、Momentum和NAG一直在鞍点梯度为零的方向上振荡，很难打破鞍点位置的对称性；Adagrad、RMSprop 与 Adadelta 能够很快地向梯度不为零的方向上转移。&lt;/p&gt;
&lt;p&gt;从上面两幅图可以看出，自适应学习速率方法（Adagrad、Adadelta、RMSprop 与 Adam）在这些场景下比采用固定学习率的算法（SGD、Momentum等）具有更好的收敛速度与收敛性。&lt;/p&gt;

</description>
<pubDate>Thu, 09 May 2019 13:57:00 +0000</pubDate>
<dc:creator>常规操作</dc:creator>
<og:description>批量梯度下降BGD（Batch Gradient Descent） 更新公式： $$ \theta = \theta \eta \sum_{i=1}^{m}\nabla g(\theta;x_i,y_</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/betabear/p/10184700.html</dc:identifier>
</item>
</channel>
</rss>