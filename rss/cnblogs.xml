<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Scala 系列（十二）—— 类型参数 - 黑白影</title>
<link>http://www.cnblogs.com/heibaiying/p/11437801.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heibaiying/p/11437801.html</guid>
<description>&lt;h2 id=&quot;一泛型&quot;&gt;一、泛型&lt;/h2&gt;
&lt;p&gt;Scala 支持类型参数化，使得我们能够编写泛型程序。&lt;/p&gt;
&lt;h3 id=&quot;泛型类&quot;&gt;1.1 泛型类&lt;/h3&gt;
&lt;p&gt;Java 中使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 符号来包含定义的类型参数，Scala 则使用 &lt;code&gt;[]&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Pair[T, S](val first: T, val second: S) {
  override def toString: String = first + &quot;:&quot; + second
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {

  // 使用时候你直接指定参数类型，也可以不指定，由程序自动推断
  val pair01 = new Pair(&quot;heibai01&quot;, 22)
  val pair02 = new Pair[String,Int](&quot;heibai02&quot;, 33)

  println(pair01)
  println(pair02)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;泛型方法&quot;&gt;1.2 泛型方法&lt;/h3&gt;
&lt;p&gt;函数和方法也支持类型参数。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object Utils {
  def getHalf[T](a: Array[T]): Int = a.length / 2
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二类型限定&quot;&gt;二、类型限定&lt;/h2&gt;
&lt;h3 id=&quot;类型上界限定&quot;&gt;2.1 类型上界限定&lt;/h3&gt;
&lt;p&gt;Scala 和 Java 一样，对于对象之间进行大小比较，要求被比较的对象实现 &lt;code&gt;java.lang.Comparable&lt;/code&gt; 接口。所以如果想对泛型进行比较，需要限定类型上界为 &lt;code&gt;java.lang.Comparable&lt;/code&gt;，语法为 &lt;code&gt;S &amp;lt;: T&lt;/code&gt;，代表类型 S 是类型 T 的子类或其本身。示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 使用 &amp;lt;: 符号，限定 T 必须是 Comparable[T]的子类型
class Pair[T &amp;lt;: Comparable[T]](val first: T, val second: T) {
  // 返回较小的值
  def smaller: T = if (first.compareTo(second) &amp;lt; 0) first else second
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 测试代码
val pair = new Pair(&quot;abc&quot;, &quot;abcd&quot;)
println(pair.smaller) // 输出 abc&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;扩展：如果你想要在 Java 中实现类型变量限定，需要使用关键字 extends 来实现，等价的 Java 代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Pair&amp;lt;T extends Comparable&amp;lt;T&amp;gt;&amp;gt; {
   private T first;
   private T second;
   Pair(T first, T second) {
       this.first = first;
       this.second = second;
   }
   public T smaller() {
       return first.compareTo(second) &amp;lt; 0 ? first : second;
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;视图界定&quot;&gt;2.2 视图界定&lt;/h3&gt;
&lt;p&gt;在上面的例子中，如果你使用 Int 类型或者 Double 等类型进行测试，点击运行后，你会发现程序根本无法通过编译：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;val pair1 = new Pair(10, 12)
val pair2 = new Pair(10.0, 12.0)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以出现这样的问题，是因为 Scala 中的 Int 类并没有实现 Comparable 接口。在 Scala 中直接继承 Comparable 接口的是特质 Ordered，它在继承 compareTo 方法的基础上，额外定义了关系符方法，源码如下:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 除了 compareTo 方法外，还提供了额外的关系符方法
trait Ordered[A] extends Any with java.lang.Comparable[A] {
  def compare(that: A): Int
  def &amp;lt;  (that: A): Boolean = (this compare that) &amp;lt;  0
  def &amp;gt;  (that: A): Boolean = (this compare that) &amp;gt;  0
  def &amp;lt;= (that: A): Boolean = (this compare that) &amp;lt;= 0
  def &amp;gt;= (that: A): Boolean = (this compare that) &amp;gt;= 0
  def compareTo(that: A): Int = compare(that)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之所以在日常的编程中之所以你能够执行 &lt;code&gt;3&amp;gt;2&lt;/code&gt; 这样的判断操作，是因为程序执行了定义在 &lt;code&gt;Predef&lt;/code&gt; 中的隐式转换方法 &lt;code&gt;intWrapper(x: Int)&lt;/code&gt;，将 Int 类型转换为 RichInt 类型，而 RichInt 间接混入了 Ordered 特质，所以能够进行比较。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Predef.scala
@inline implicit def intWrapper(x: Int)   = new runtime.RichInt(x)&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/scala-richInt.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;要想解决传入数值无法进行比较的问题，可以使用视图界定。语法为 &lt;code&gt;T &amp;lt;% U&lt;/code&gt;，代表 T 能够通过隐式转换转为 U，即允许 Int 型参数在无法进行比较的时候转换为 RichInt 类型。示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 视图界定符号 &amp;lt;%
class Pair[T &amp;lt;% Comparable[T]](val first: T, val second: T) {
  // 返回较小的值
  def smaller: T = if (first.compareTo(second) &amp;lt; 0) first else second
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;注：由于直接继承 Java 中 Comparable 接口的是特质 Ordered，所以如下的视图界定和上面是等效的：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 隐式转换为 Ordered[T]
   class Pair[T &amp;lt;% Ordered[T]](val first: T, val second: T) {
def smaller: T = if (first.compareTo(second) &amp;lt; 0) first else second
   }&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;类型约束&quot;&gt;2.3 类型约束&lt;/h3&gt;
&lt;p&gt;如果你用的 Scala 是 2.11+，会发现视图界定已被标识为废弃。官方推荐使用类型约束 (type constraint) 来实现同样的功能，其本质是使用隐式参数进行隐式转换，示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; // 1.使用隐式参数隐式转换为 Comparable[T]
class Pair[T](val first: T, val second: T)(implicit ev: T =&amp;gt; Comparable[T]) 
  def smaller: T = if (first.compareTo(second) &amp;lt; 0) first else second
}

// 2.由于直接继承 Java 中 Comparable 接口的是特质 Ordered，所以也可以隐式转换为 Ordered[T]
class Pair[T](val first: T, val second: T)(implicit ev: T =&amp;gt; Ordered[T]) {
  def smaller: T = if (first.compareTo(second) &amp;lt; 0) first else second
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，隐式参数转换也可以运用在具体的方法上：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object PairUtils{
  def smaller[T](a: T, b: T)(implicit order: T =&amp;gt; Ordered[T]) = if (a &amp;lt; b) a else b
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上下文界定&quot;&gt;2.4 上下文界定&lt;/h3&gt;
&lt;p&gt;上下文界定的形式为 &lt;code&gt;T:M&lt;/code&gt;，其中 M 是一个泛型，它要求必须存在一个类型为 M[T]的隐式值，当你声明一个带隐式参数的方法时，需要定义一个隐式默认值。所以上面的程序也可以使用上下文界定进行改写：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Pair[T](val first: T, val second: T) {
  // 请注意 这个地方用的是 Ordering[T]，而上面视图界定和类型约束，用的是 Ordered[T]，两者的区别会在后文给出解释
  def smaller(implicit ord: Ordering[T]): T = if (ord.compare(first, second) &amp;lt; 0) first else second 
}

// 测试
val pair= new Pair(88, 66)
println(pair.smaller)  //输出：66&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的示例中，我们无需手动添加隐式默认值就可以完成转换，这是因为 Scala 自动引入了 Ordering[Int]这个隐式值。为了更好的说明上下文界定，下面给出一个自定义类型的比较示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 1.定义一个人员类
class Person(val name: String, val age: Int) {
  override def toString: String = name + &quot;:&quot; + age
}

// 2.继承 Ordering[T],实现自定义比较器,按照自己的规则重写比较方法
class PersonOrdering extends Ordering[Person] {
  override def compare(x: Person, y: Person): Int = if (x.age &amp;gt; y.age) 1 else -1
}

class Pair[T](val first: T, val second: T) {
  def smaller(implicit ord: Ordering[T]): T = if (ord.compare(first, second) &amp;lt; 0) first else second
}


object ScalaApp extends App {

  val pair = new Pair(new Person(&quot;hei&quot;, 88), new Person(&quot;bai&quot;, 66))
  // 3.定义隐式默认值,如果不定义,则下一行代码无法通过编译
  implicit val ImpPersonOrdering = new PersonOrdering
  println(pair.smaller) //输出： bai:66
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;classtag上下文界定&quot;&gt;2.5 ClassTag上下文界定&lt;/h3&gt;
&lt;p&gt;这里先看一个例子：下面这段代码，没有任何语法错误，但是在运行时会抛出异常：&lt;code&gt;Error: cannot find class tag for element type T&lt;/code&gt;, 这是由于 Scala 和 Java 一样，都存在类型擦除，即&lt;strong&gt;泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉&lt;/strong&gt;。对于下面的代码，在运行阶段创建 Array 时，你必须明确指明其类型，但是此时泛型信息已经被擦除，导致出现找不到类型的异常。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;object ScalaApp extends App {
  def makePair[T](first: T, second: T) = {
    // 创建以一个数组 并赋值
    val r = new Array[T](2); r(0) = first; r(1) = second; r
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Scala 针对这个问题，提供了 ClassTag 上下文界定，即把泛型的信息存储在 ClassTag 中，这样在运行阶段需要时，只需要从 ClassTag 中进行获取即可。其语法为 &lt;code&gt;T : ClassTag&lt;/code&gt;，示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import scala.reflect._
object ScalaApp extends App {
  def makePair[T : ClassTag](first: T, second: T) = {
    val r = new Array[T](2); r(0) = first; r(1) = second; r
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类型下界限定&quot;&gt;2.6 类型下界限定&lt;/h3&gt;
&lt;p&gt;2.1 小节介绍了类型上界的限定，Scala 同时也支持下界的限定，语法为：&lt;code&gt;U &amp;gt;: T&lt;/code&gt;，即 U 必须是类型 T 的超类或本身。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 首席执行官
class CEO

// 部门经理
class Manager extends CEO

// 本公司普通员工
class Employee extends Manager

// 其他公司人员
class OtherCompany

object ScalaApp extends App {

  // 限定：只有本公司部门经理以上人员才能获取权限
  def Check[T &amp;gt;: Manager](t: T): T = {
    println(&quot;获得审核权限&quot;)
    t
  }

  // 错误写法: 省略泛型参数后,以下所有人都能获得权限,显然这是不正确的
  Check(new CEO)
  Check(new Manager)
  Check(new Employee)
  Check(new OtherCompany)


  // 正确写法,传入泛型参数
  Check[CEO](new CEO)
  Check[Manager](new Manager)
  /*
   * 以下两条语句无法通过编译,异常信息为: 
   * do not conform to method Check's type parameter bounds(不符合方法 Check 的类型参数边界)
   * 这种情况就完成了下界限制，即只有本公司经理及以上的人员才能获得审核权限
   */
  Check[Employee](new Employee)
  Check[OtherCompany](new OtherCompany)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;多重界定&quot;&gt;2.7 多重界定&lt;/h3&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;类型变量可以同时有上界和下界。 写法为 ：&lt;code&gt;T &amp;gt; : Lower &amp;lt;: Upper&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;不能同时有多个上界或多个下界 。但可以要求一个类型实现多个特质，写法为 :&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T &amp;lt; : Comparable[T] with Serializable with Cloneable&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;你可以有多个上下文界定，写法为 &lt;code&gt;T : Ordering : ClassTag&lt;/code&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三ordering-ordered&quot;&gt;三、Ordering &amp;amp; Ordered&lt;/h2&gt;
&lt;p&gt;上文中使用到 Ordering 和 Ordered 特质，它们最主要的区别在于分别继承自不同的 Java 接口：Comparable 和 Comparator：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Comparable&lt;/strong&gt;：可以理解为内置的比较器，实现此接口的对象可以与自身进行比较；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comparator&lt;/strong&gt;：可以理解为外置的比较器；当对象自身并没有定义比较规则的时候，可以传入外部比较器进行比较。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么 Java 中要同时给出这两个比较接口，这是因为你要比较的对象不一定实现了 Comparable 接口，而你又想对其进行比较，这时候当然你可以修改代码实现 Comparable，但是如果这个类你无法修改 (如源码中的类)，这时候就可以使用外置的比较器。同样的问题在 Scala 中当然也会出现，所以 Scala 分别使用了 Ordering 和 Ordered 来继承它们。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/scala-ordered-ordering.png&quot;/&gt;&lt;/div&gt;
&lt;p&gt;下面分别给出 Java 中 Comparable 和 Comparator 接口的使用示例：&lt;/p&gt;
&lt;h3 id=&quot;comparable&quot;&gt;3.1 Comparable&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;
// 实现 Comparable 接口
public class Person implements Comparable&amp;lt;Person&amp;gt; {

    private String name;
    private int age;

    Person(String name,int age) {this.name=name;this.age=age;}
    @Override
    public String toString() { return name+&quot;:&quot;+age; }

    // 核心的方法是重写比较规则，按照年龄进行排序
    @Override
    public int compareTo(Person person) {
        return this.age - person.age;
    }

    public static void main(String[] args) {
        Person[] peoples= {new Person(&quot;hei&quot;, 66), new Person(&quot;bai&quot;, 55), new Person(&quot;ying&quot;, 77)};
        Arrays.sort(peoples);
        Arrays.stream(peoples).forEach(System.out::println);
    }
}

输出：
bai:55
hei:66
ying:77&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;comparator&quot;&gt;3.2 Comparator&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import java.util.Arrays;
import java.util.Comparator;

public class Person {

    private String name;
    private int age;

    Person(String name,int age) {this.name=name;this.age=age;}
    @Override
    public String toString() { return name+&quot;:&quot;+age; }

    public static void main(String[] args) {
        Person[] peoples= {new Person(&quot;hei&quot;, 66), new Person(&quot;bai&quot;, 55), new Person(&quot;ying&quot;, 77)};
        // 这里为了直观直接使用匿名内部类,实现 Comparator 接口
        //如果是 Java8 你也可以写成 Arrays.sort(peoples, Comparator.comparingInt(o -&amp;gt; o.age));
        Arrays.sort(peoples, new Comparator&amp;lt;Person&amp;gt;() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.age-o2.age;
            }
        });
        Arrays.stream(peoples).forEach(System.out::println);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用外置比较器还有一个好处，就是你可以随时定义其排序规则：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 按照年龄大小排序
Arrays.sort(peoples, Comparator.comparingInt(o -&amp;gt; o.age));
Arrays.stream(peoples).forEach(System.out::println);
// 按照名字长度倒序排列
Arrays.sort(peoples, Comparator.comparingInt(o -&amp;gt; -o.name.length()));
Arrays.stream(peoples).forEach(System.out::println);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;上下文界定的优点&quot;&gt;3.3 上下文界定的优点&lt;/h3&gt;
&lt;p&gt;这里再次给出上下文界定中的示例代码作为回顾：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 1.定义一个人员类
class Person(val name: String, val age: Int) {
  override def toString: String = name + &quot;:&quot; + age
}

// 2.继承 Ordering[T],实现自定义比较器,这个比较器就是一个外置比较器
class PersonOrdering extends Ordering[Person] {
  override def compare(x: Person, y: Person): Int = if (x.age &amp;gt; y.age) 1 else -1
}

class Pair[T](val first: T, val second: T) {
  def smaller(implicit ord: Ordering[T]): T = if (ord.compare(first, second) &amp;lt; 0) first else second
}


object ScalaApp extends App {

  val pair = new Pair(new Person(&quot;hei&quot;, 88), new Person(&quot;bai&quot;, 66))
  // 3.在当前上下文定义隐式默认值,这就相当于传入了外置比较器
  implicit val ImpPersonOrdering = new PersonOrdering
  println(pair.smaller) //输出： bai:66
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用上下文界定和 Ordering 带来的好处是：传入 &lt;code&gt;Pair&lt;/code&gt; 中的参数不一定需要可比较，只要在比较时传入外置比较器即可。&lt;/p&gt;
&lt;p&gt;需要注意的是由于隐式默认值二义性的限制，你不能像上面 Java 代码一样，在同一个上下文作用域中传入两个外置比较器，即下面的代码是无法通过编译的。但是你可以在不同的上下文作用域中引入不同的隐式默认值，即使用不同的外置比较器。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;implicit val ImpPersonOrdering = new PersonOrdering
println(pair.smaller) 
implicit val ImpPersonOrdering2 = new PersonOrdering
println(pair.smaller)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四通配符&quot;&gt;四、通配符&lt;/h2&gt;
&lt;p&gt;在实际编码中，通常需要把泛型限定在某个范围内，比如限定为某个类及其子类。因此 Scala 和 Java 一样引入了通配符这个概念，用于限定泛型的范围。不同的是 Java 使用 &lt;code&gt;?&lt;/code&gt; 表示通配符，Scala 使用 &lt;code&gt;_&lt;/code&gt; 表示通配符。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Ceo(val name: String) {
  override def toString: String = name
}

class Manager(name: String) extends Ceo(name)

class Employee(name: String) extends Manager(name)

class Pair[T](val first: T, val second: T) {
  override def toString: String = &quot;first:&quot; + first + &quot;, second: &quot; + second
}

object ScalaApp extends App {
  // 限定部门经理及以下的人才可以组队
  def makePair(p: Pair[_ &amp;lt;: Manager]): Unit = {println(p)}
  makePair(new Pair(new Employee(&quot;heibai&quot;), new Manager(&quot;ying&quot;)))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;目前 Scala 中的通配符在某些复杂情况下还不完善，如下面的语句在 Scala 2.12 中并不能通过编译：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;def min[T &amp;lt;: Comparable[_ &amp;gt;: T]](p: Pair[T]) ={}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以使用以下语法代替：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;type SuperComparable[T] = Comparable[_ &amp;gt;: T]
def min[T &amp;lt;: SuperComparable[T]](p: Pair[T]) = {}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;Martin Odersky . Scala 编程 (第 3 版)[M] . 电子工业出版社 . 2018-1-1&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;凯.S.霍斯特曼 . 快学 Scala(第 2 版)[M] . 电子工业出版社 . 2017-7&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;&lt;strong&gt;更多大数据系列文章可以参见 GitHub 开源项目&lt;/strong&gt;： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;&lt;strong&gt;大数据入门指南&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 30 Aug 2019 23:28:00 +0000</pubDate>
<dc:creator>黑白影</dc:creator>
<og:description>一、泛型 Scala 支持类型参数化，使得我们能够编写泛型程序。 1.1 泛型类 Java 中使用 []`。 1.2 泛型方法 函数和方法也支持类型参数。 二、类型限定 2.1 类型上界限定 Scal</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heibaiying/p/11437801.html</dc:identifier>
</item>
<item>
<title>开发必学的验证码，教你从零写一个验证码 - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/11437800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/11437800.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190831072454922-136293572.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这周一写了一篇《2000字谏言，给那些想学Python的人，建议收藏后细看！》给大家讲了如何快速学习python。&lt;/p&gt;
&lt;p&gt;其中就有说到我们为什么不要执迷于框架、模块的调用，而要自己先去造轮子。那今天就给大家造一个。&lt;/p&gt;
&lt;p&gt;验证码是web开发中不可缺少的元素，而python又提供了非常多的验证码模块帮助大家快速生成各种验证码。&lt;/p&gt;
&lt;p&gt;那你知道验证码生成的原理吗？所谓知其然，还要知其所以然。面试中，面试官不会因为你对框架很熟悉就夸赞你。&lt;/p&gt;
&lt;p&gt;那今天小胖就带大家一层一层拨开验证码的衣服，看看其中的小奥秘 -&amp;lt;-&lt;/p&gt;
&lt;h3 id=&quot;演示环境&quot;&gt;演示环境&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;操作系统：windows10&lt;/li&gt;
&lt;li&gt;python版本：python 3.7&lt;/li&gt;
&lt;li&gt;代码编辑器：pycharm 2018.2&lt;/li&gt;
&lt;li&gt;使用第三方模块：pillow&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;验证码的必须元素&quot;&gt;验证码的必须元素&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;一张图片&lt;/li&gt;
&lt;li&gt;文本&lt;/li&gt;
&lt;li&gt;干扰元素
&lt;ul&gt;&lt;li&gt;线条干扰&lt;/li&gt;
&lt;li&gt;小圆点干扰&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;熟悉pillow库&quot;&gt;熟悉pillow库&lt;/h3&gt;
&lt;p&gt;我们既然需要使用pillow库制作验证码，那么首先我们先来熟悉一下我们需要用到的方法。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Image.new(): 这个方法可以生成一张图片，有三个参数。
&lt;ul&gt;&lt;li&gt;mode:颜色空间模式，可以是&lt;code&gt;'RGBA','RGB','L'&lt;/code&gt;等等模式&lt;/li&gt;
&lt;li&gt;size:图片尺寸，接收一个两个整数的元祖&lt;/li&gt;
&lt;li&gt;color:图片的填充颜色，可以是&lt;code&gt;red，green&lt;/code&gt;等，也可以是rgb的三个整数的元祖。也就是背景颜色&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from PIL import Image

captcha = Image.new('RGB', (1080, 900), (255,255,255))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码创建了一个亿RGB为颜色空间模式，尺寸为1080*900，背景颜色为白色的图片。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Image.save(): 保存图片到本地
&lt;ul&gt;&lt;li&gt;fp: 本地文件名&lt;/li&gt;
&lt;li&gt;format: 可选参数，制定文件后缀名。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from PIL import Image

captcha = Image.new('RGB', (1080, 900), (255,255,255))

# captcha.save('captcha.png')
captcha.save('captcha', format='png')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面两种方式保存效果是一样的。&lt;/p&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Image.show():显示图片，会调用电脑自带的显示图片的软件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;ImageFont.truetype(): 加载一个字体文件。生成一个字体对象。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from PIL import ImageFont
#                        字体文件路径 字体大小
font = ImageFont.truetype('simkai.ttf', 16)&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;ImageDraw.Draw(): 生成画笔对象。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from PIL import Image, ImageDraw

captcha = Image.new('RGB', (1080, 900), 'red')
draw = ImageDraw.Draw(captcha)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就创建了一个在captcha这张图片上的画笔，我们在这个图片上画任何东西都会使用这个画笔对象。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ImageDraw.Draw().text():在图片上绘制给定的字符&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from PIL import Image, ImageDraw, ImageFont

captcha = Image.new('RGB', (1080, 900), 'red')
font = ImageFont.truetype('simkai.ttf', 16)
draw = ImageDraw.Draw(captcha)

#      字符绘制位置  绘制的字符    制定字体      字符颜色
draw.text((0,0), 'hello world', font=font, fill='black')&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;ImageDraw.Draw().line():在图片上绘制线条&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from PIL import Image, ImageDraw, ImageFont

captcha = Image.new('RGB', (1080, 900), 'red')
draw = ImageDraw.Draw(captcha)

#         线条起点  线条终点
draw.line([(0,0),(1080,900)], fill='black')&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;ImageDraw.Draw().point(): 在图片上绘制点&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from PIL import Image, ImageDraw, ImageFont

captcha = Image.new('RGB', (1080, 900), 'red')
font = ImageFont.truetype('simkai.ttf', 16)
draw = ImageDraw.Draw(captcha)

#           点的位置      颜色
draw.point((500,500), fill='black')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;制作我们的验证码我们就会使用到上面的方法。当然，pillow肯定不止这些方法，这里我们就只列举这些了。&lt;/p&gt;
&lt;h3 id=&quot;制作验证码&quot;&gt;制作验证码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首先我们定义一个类，初始化一些需要的参数。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
import string

class Captcha():
    '''
    captcha_size: 验证码图片尺寸
    font_size: 字体大小
    text_number: 验证码中字符个数
    line_number: 线条个数
    background_color: 验证码的背景颜色
    sources: 取样字符集。验证码中的字符就是随机从这个里面选取的
    save_format: 验证码保存格式
    '''
    def __init__(self, captcha_size=(150,100), font_size=30,text_number=4, line_number=4, background_color=(255, 255, 255), sources=None, save_format='png'):
        self.text_number = text_number
        self.line_number = line_number
        self.captcha_size = captcha_size
        self.background_color = background_color
        self.font_size = font_size
        self.format = save_format
        if sources:
            self.sources = sources
        else:
            self.sources = string.ascii_letters + string.digits&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说一下string模块。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;string.ascii_letters: 得到a-zA-Z所有字符&lt;/li&gt;
&lt;li&gt;string.digits: 得到0-9所有数字&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;随机从sources获取字符&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import random

def get_text(self):
    text = random.sample(self.sources,k=self.text_number)
    return ''.join(text)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;random.sample()方法：从第一个参数中随机获取字符。获取个数有第二个参数指定。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;随机获取绘制字符的颜色&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
def get_font_color(self):
    font_color = (random.randint(0, 150), random.randint(0, 150), random.randint(0, 150))
    return font_color&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;随机获取干扰线条的颜色&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_line_color(self):
    line_color = (random.randint(0, 250), random.randint(0, 255), random.randint(0, 250))
    return line_color&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;编写绘制文字的方法&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def draw_text(self,draw, text, font, captcha_width, captcha_height, spacing=20):
    '''
    在图片上绘制传入的字符
    :param draw: 画笔对象
    :param text: 绘制的所有字符
    :param font: 字体对象
    :param captcha_width: 验证码的宽度 
    :param captcha_height: 验证码的高度
    :param spacing: 每个字符的间隙
    :return: 
    '''
    # 得到这一窜字符的高度和宽度
    text_width, text_height = font.getsize(text)
    # 得到每个字体的大概宽度
    every_value_width = int(text_width / 4)

    # 这一窜字符的总长度
    text_length = len(text)
    # 每两个字符之间拥有间隙，获取总的间隙
    total_spacing = (text_length-1) * spacing

    if total_spacing + text_width &amp;gt;= captcha_width:
        raise ValueError(&quot;字体加中间空隙超过图片宽度!&quot;)
    
    # 获取第一个字符绘制位置
    start_width = int( (captcha_width - text_width - total_spacing) / 2 )
    start_height = int( (captcha_height - text_height) / 2 )

    # 依次绘制每个字符
    for value in text:
        position = start_width, start_height
        print(position)
        # 绘制text
        draw.text(position, value, font=font, fill=self.get_font_color())
        # 改变下一个字符的开始绘制位置
        start_width = start_width + every_value_width + spacing&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;绘制线条的方法&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def draw_line(self, draw, captcha_width, captcha_height):
    '''
    绘制线条
    :param draw: 画笔对象 
    :param captcha_width: 验证码的宽度 
    :param captcha_height: 验证码的高度
    :return: 
    '''
    # 随机获取开始位置的坐标
    begin = (random.randint(0,captcha_width/2), random.randint(0, captcha_height))
    # 随机获取结束位置的坐标
    end = (random.randint(captcha_width/2,captcha_width), random.randint(0, captcha_height))
    draw.line([begin, end], fill=self.get_line_color())&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;绘制小圆点&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def draw_point(self, draw, point_chance, width, height):
    '''
    绘制小圆点
    :param draw: 画笔对象
    :param point_chance: 绘制小圆点的几率 概率为 point_chance/100
    :param width: 验证码宽度
    :param height: 验证码高度
    :return:
    '''
    # 按照概率随机绘制小圆点
    for w in range(width):
        for h in range(height):
            tmp = random.randint(0, 100)
            if tmp &amp;lt; point_chance:
                draw.point((w, h), fill=self.get_line_color())&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;制作验证码&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def make_captcha(self):
    # 获取验证码的宽度， 高度
    width, height = self.captcha_size
    # 生成一张图片
    captcha = Image.new('RGB',self.captcha_size,self.background_color)
    # 获取字体对象
    font = ImageFont.truetype('simkai.ttf',self.font_size)
    # 获取画笔对象
    draw = ImageDraw.Draw(captcha)
    # 得到绘制的字符
    text = self.get_text(

    # 绘制字符
    self.draw_text(draw, text, font, width, height)

    # 绘制线条
    for i in range(self.line_number):
        self.draw_line(draw, width, height)

    # 绘制小圆点 10是概率 10/100， 10%的概率
    self.draw_point(draw,10,width,height)

    # 保存图片
    captcha.save('captcha',format=self.format)
    # 显示图片
    captcha.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，我们就生成了我们的图片验证码了，效果图.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201908/649191-20190831072506952-1123257969.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码已全部上传至Github：&lt;a href=&quot;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/App/captcha_project&quot; class=&quot;uri&quot;&gt;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/App/captcha_project&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关注公众号「&lt;strong&gt;Python专栏&lt;/strong&gt;」，后台回复「&lt;strong&gt;机器学习电子书&lt;/strong&gt;」获取100本免费机器学习相关的电子书哦～&lt;/p&gt;
</description>
<pubDate>Fri, 30 Aug 2019 23:27:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>验证码是web开发中不可缺少的元素，而python又提供了非常多的验证码模块帮助大家快速生成各种验证码。  那你知道验证码生成的原理吗？所谓知其然，还要知其所以然。面试中，面试官不会因为你对框架很熟悉</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moonhmily/p/11437800.html</dc:identifier>
</item>
<item>
<title>.Net之微信小程序获取用户UnionID - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/11437754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/11437754.html</guid>
<description>&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　在实际项目开发中我们经常会遇到账号统一的问题，如何在不同端或者是不同的登录方式下保证同一个会员或者用户账号唯一（便于用户信息的管理）。这段时间就有一个这样的需求，之前有个客户做了一个微信小程序商城（店主端的），然后现在又要做一个会员购物端的小程序商场。首先之前用户登录凭证都是使用微信openid来做的唯一标识，而现在客户需求是要做到用户在会员端小程序跳转到到店主端小程序假如之前该用户微信是在店主端审核通过的用户则不需要在进行资料提交审核操作，直接登录。所以，所以我们使用了UnionID来进行关联，如下是我们现在项目的基本流程（画的丑莫见怪）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201908/1336199-20190830231119591-53127198.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;说说UnionID机制：&lt;/h2&gt;
&lt;p&gt;　　如果开发者拥有多个移动应用、网站应用、和公众帐号（包括小程序），可通过 UnionID 来区分用户的唯一性，因为只要是同一个微信开放平台帐号下的移动应用、网站应用和公众帐号（包括小程序），用户的 UnionID 是唯一的。换句话说，同一用户，对同一个微信开放平台下的不同应用，unionid是相同的。&lt;/p&gt;
&lt;p&gt;官方UnionID机制详细说明：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;微信开放平台绑定小程序流程：&lt;/h2&gt;
&lt;p&gt;登录&lt;a href=&quot;https://open.weixin.qq.com/&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;微信开放平台&lt;/a&gt; — 管理中心 — 小程序 — 绑定小程序（直接使用微信官方图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201908/1336199-20190830232938971-1623778731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;微信小程序获取UnoinID的两种方式：&lt;/h2&gt;
&lt;h3&gt;调用接口 wx.getUserInfo，从解密数据（encryptedData）中获取 UnionID（推荐使用）：&lt;/h3&gt;
&lt;p&gt;推荐使用原因：无需关注微信公众号即可获取到UnionID。&lt;/p&gt;
&lt;p&gt;调用接口wx.getUserInfo前提：用户允许授权获取用户信息！&lt;/p&gt;
&lt;h4&gt;开发者后台校验与解密开放数据：&lt;/h4&gt;
&lt;p&gt;　　微信为了保证用户信息，把用户通过wx.getUserInfo接口获取到的相关敏感信息进行了加密。加密方式对称加密（后面会提到），首先我们需要通过&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html&quot; target=&quot;_blank&quot;&gt;微信小程序登录流程&lt;/a&gt;获取到用户的session_key(会话密钥)，然后我们可以报获取到的会话密钥使用缓存存起来，在通过用户授权获取用户相关信息，如下是用户授权成功获取到的用户信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201908/1336199-20190831000527932-906403220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;基本流程图如下：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201908/1336199-20190830235618083-1943041876.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;(encryptedData)加密数据解密算法：&lt;/h4&gt;
&lt;p&gt;开发者如需要获取敏感数据，需要对接口返回的&lt;strong&gt;加密数据(encryptedData)&lt;/strong&gt; 进行对称解密。 解密算法如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对称解密使用的算法为 AES-128-CBC，数据采用PKCS#7填充。&lt;/li&gt;
&lt;li&gt;对称解密的目标密文为 Base64_Decode(encryptedData)。&lt;/li&gt;
&lt;li&gt;对称解密秘钥 aeskey = Base64_Decode(session_key), aeskey 是16字节。&lt;/li&gt;
&lt;li&gt;对称解密算法初始向量 为Base64_Decode(iv)，其中iv由数据接口返回&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;很遗憾的是微信居然没有为我们大.Net提供解密算法demo，实属让人不算，最后自己根据网上的资料还是配上了符合微信对称加密的解密算法。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;p&gt;首先关于session_key（会话密钥）的获取，请看下面的wx.login+code2Session 方式&lt;/p&gt;
&lt;h4&gt;调用接口wx.getUserInfo获取encryptedData（加密数据）和iv（初始向量）：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用户已经授权&lt;/span&gt;
&lt;span&gt;wx.getUserInfo({
success: function(res) {
console.log(res);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userInfo = res.userInfo &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用户基本信息&lt;/span&gt;
let sessionKey = wx.getStorageSync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;session_key&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;临时会话密钥，通过小程序登录流程获取到的
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求.net webapi解密接口&lt;/span&gt;
&lt;span&gt;wx.request({
 url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.xxxtest.com/api/User_oAuth/DecryptSensitiveData&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
data: {
sessionKey:sessionKey,
encryptedData:res.encryptedData,
iv:res.iv
},
 header: {
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content-type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认值&lt;/span&gt;
&lt;span&gt;},
success (res) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解密返回过来的UnionID&lt;/span&gt;
&lt;span&gt;console.log(res.data)
}
})
}
})
})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;.Net WebApi 解密数据接口：&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 解密微信对称加密数据，获取用户联合运营编号
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sessionKey&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;临时会话秘钥&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;encryptedData&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;微信用户敏感加密数据&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;iv&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;解密初始向量&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHttpActionResult DecryptSensitiveData(&lt;span&gt;string&lt;/span&gt; sessionKey,&lt;span&gt;string&lt;/span&gt; encryptedData,&lt;span&gt;string&lt;/span&gt;&lt;span&gt; iv)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; getUnionId=&lt;span&gt;DecryptByAesBytes(encryptedData, sessionKey, iv);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { code =&lt;span&gt;1&lt;/span&gt;, msg=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;解密成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,result=&lt;span&gt; getUnionId });
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { code = &lt;span&gt;0&lt;/span&gt;, msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;解密失败,原因：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;ex.Message });
            }
        }

        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; AES对称解密
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; AES解密
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;encryptedData&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;待解密的字节数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;sessionKey&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;解密密钥字节数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;iv&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;IV初始化向量字节数组&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;cipher&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;运算模式&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;padding&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;填充模式&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DecryptByAesBytes(&lt;span&gt;string&lt;/span&gt; encryptedData, &lt;span&gt;string&lt;/span&gt; sessionKey, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; iv)
        {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非空验证&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(encryptedData) &amp;amp;&amp;amp; !&lt;span&gt;string&lt;/span&gt;.IsNullOrWhiteSpace(sessionKey) &amp;amp;&amp;amp; !&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(iv))
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; decryptBytes = Convert.FromBase64String(encryptedData.Replace(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; keyBytes = Convert.FromBase64String(sessionKey.Replace(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ivBytes = Convert.FromBase64String(iv.Replace(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;));

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; aes = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AesCryptoServiceProvider
                    {
                        Key &lt;/span&gt;=&lt;span&gt; keyBytes,
                        IV &lt;/span&gt;=&lt;span&gt; ivBytes,
                        Mode &lt;/span&gt;=&lt;span&gt; CipherMode.CBC,
                        Padding &lt;/span&gt;=&lt;span&gt; PaddingMode.PKCS7
                    };

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; outputBytes = aes.CreateDecryptor().TransformFinalBlock(decryptBytes, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, decryptBytes.Length);

                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; decryptResult =&lt;span&gt; Encoding.UTF8.GetString(outputBytes);
                    &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; decryptData = JsonConvert.DeserializeObject(decryptResult, &lt;span&gt;new&lt;/span&gt; { unionid = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt; }.GetType());
                    JJHL.Utility.Loghelper.WriteLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AES对称解密结果为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; decryptResult);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; decryptData.unionid;
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
                }
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e)
            {
                JJHL.Utility.Loghelper.WriteLog(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AES对称解密失败原因：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; e.Message);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;注意参数使用Convert.FromBase64String转化，提示“Base-64字符数组的无效长度” 的问题：&lt;/h4&gt;
&lt;p&gt;原因:加密参数中的&quot;+&quot;通过地址栏传过来时,后台会解析为空格。&lt;/p&gt;
&lt;p&gt;解决：最好的做法是 使用encryptedData.Replace(&quot;+&quot;, &quot;%2B&quot;)先将空格编码，然后再作为参数传给另一页面传递，这样页面在提取参数时才会将“%2B”解码为加号.但这儿为了简化，将空格直接还原为&quot;+&quot;或者是直接在后台将空格替换为“+”encryptedData.Replace(' ', '+');&lt;/p&gt;
&lt;h3&gt;直接通过 &lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api/open-api/login/wx.login.html&quot;&gt;wx.login&lt;/a&gt; + &lt;code&gt;code2Session&lt;/code&gt; 获取到该用户 UnionID：&lt;/h3&gt;
&lt;h4&gt;其实这个方式就是实现了小程序的登录流程，微信官方详细说明：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/login.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;优点：无需用户授权。&lt;/p&gt;
&lt;p&gt;前提：用户需要关注该微信公众号。&lt;/p&gt;
&lt;h4&gt;小程序端调用接口wx.login获取code凭证，在通过请求auth.code2Session接口获取用户信息（UnionID,openid,session_key会话密钥）两种方式：&lt;/h4&gt;
&lt;h5&gt;1.直接通过wx.login请求到code凭证后，在请求该地址获取用户信息：&lt;/h5&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
GET：https://api.weixin.qq.com/sns/jscode2session?appid=APPID&amp;amp;secret=SECRET&amp;amp;js_code=JSCODE&amp;amp;grant_type=authorization_code
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详细说明请看微信官方文档（代码略）：&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html&quot;&gt;https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/login/auth.code2Session.html&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;2.通过请求wx.login获取code凭证，在向.net webapi后端请求code2Session接口：&lt;/h5&gt;
&lt;p&gt;原因：因为我们需要对获取的用户信息做相关业务逻辑处理。&lt;/p&gt;
&lt;h5&gt;&lt;strong&gt;微信小程序端代码：&lt;/strong&gt;&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
*封装用户promise登录，通过code凭证获取用户信息（UnionID,openid,session_key会话密钥）
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
userLogin: function() {
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; that = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义promise方法&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Promise(function(resolve, reject) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用登录接口&lt;/span&gt;
&lt;span&gt;wx.login({
success: function(res) {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (res.code) {
console.log(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户登录授权code为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; res.code);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用wx.request请求传递code凭证换取用户openid，并获取后台用户信息&lt;/span&gt;
&lt;span&gt;wx.request({
url: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;https://www.xxxx.xxx.api/User_oAuth/GetUserInfo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后台请求用户信息方法&lt;/span&gt;
&lt;span&gt;data: {
code: res.code &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;code凭证&lt;/span&gt;
&lt;span&gt;},
header: {
&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content-type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认值&lt;/span&gt;
&lt;span&gt;},
success(res) {
console.log(res.data)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (res.data.errcode == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;存入session缓存中&lt;/span&gt;
console.log(res.data.openid);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;微信用户唯一标识&lt;/span&gt;
console.log(res.data.UnionID);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;微信开发平台联合ID&lt;/span&gt;
console.log(res.data.session_key);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;会话密钥&lt;br/&gt;//***注意****&lt;br/&gt;//注意：这里是直接把session_key缓存起来，在上面wx.getUserInfo会使用到&lt;br/&gt;&lt;/span&gt;wx.setStorageSync(&quot;session_key&quot;,res.data.session_key);
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;promise机制放回成功数据&lt;/span&gt; &lt;br/&gt;&lt;span&gt;resolve(res.data); &lt;br/&gt;} &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; &lt;br/&gt;{ reject(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); } &lt;br/&gt;}, fail: function(res) &lt;br/&gt;{ &lt;br/&gt;reject(res); &lt;br/&gt;wx.showToast({ title: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;系统错误&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }) &lt;br/&gt;}, complete: () &lt;/span&gt;=&amp;gt;&lt;span&gt; { } &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;complete接口执行后的回调函数，无论成功失败都会调用&lt;/span&gt; &lt;br/&gt;&lt;span&gt;}) } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; &lt;br/&gt;{ &lt;br/&gt;reject(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); &lt;br/&gt;}}&lt;br/&gt;})
})}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;strong&gt;.Net WebApi 请求用户信息接口：&lt;/strong&gt;&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取用户信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;code&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;信息数据code凭证&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IHttpActionResult GetUserInfo(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; code)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; AppSecret = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小程序秘钥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; AppId = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;应用程序标识&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;请求目标地址和参数（&lt;/span&gt;authorization_code授权类型，此处只需填写 authorization_code）
&lt;/pre&gt;
&lt;pre&gt;
                &lt;span&gt;string&lt;/span&gt; OauthUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://api.weixin.qq.com/sns/jscode2session?appid=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + AppId + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;secret=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + AppSecret + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;js_code=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + code + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;amp;grant_type=authorization_code&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列化解析数据&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; Result =&lt;span&gt; HttpGet(OauthUrl);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { openid = Result.openid, errcode = Result.errcode, UnionID = Result.unionid, session_key =&lt;span&gt; Result.session_key });
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;new&lt;/span&gt; { errcode = &lt;span&gt;1&lt;/span&gt;, msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;获取用户信息失败&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ex.Message });
            }
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 请求code2Session接口获取用户信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;requestDataAndUrl&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;目标地址和参数&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; WxOauthModle HttpGet(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; requestDataAndUrl)
        {
            HttpWebRequest request &lt;/span&gt;=&lt;span&gt; (HttpWebRequest)WebRequest.Create(requestDataAndUrl);
            request.Method &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GET&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            request.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html;charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            HttpWebResponse response &lt;/span&gt;=&lt;span&gt; (HttpWebResponse)request.GetResponse();
            Stream myResponseStream &lt;/span&gt;=&lt;span&gt; response.GetResponseStream();
            StreamReader myStreamReader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StreamReader(myResponseStream, Encoding.UTF8);
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; retString =&lt;span&gt; myStreamReader.ReadToEnd();
            myStreamReader.Close();
            myResponseStream.Close();

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;WxOauthModle&amp;gt;&lt;span&gt;(retString);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WxOauthModle
        {
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 用户唯一标识
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; openid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 会话秘钥
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; session_key { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 联立编号
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; unionid { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误码
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; errcode { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 错误信息
            &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; errmsg { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;关于微信网页开发通过UnionID机制解决用户在不同公众号，或在公众号、移动应用之间帐号统一问题：&lt;/h2&gt;
&lt;p&gt;详情说明请点击：&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/9368844.html&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/9368844.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Aug 2019 18:13:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 在实际项目开发中我们经常会遇到账号统一的问题，如何在不同端或者是不同的登录方式下保证同一个会员或者用户账号唯一（便于用户信息的管理）。这段时间就有一个这样的需求，之前有个客户做了一个微信小程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/11437754.html</dc:identifier>
</item>
<item>
<title>Java连载23-for循环练习、while\dowhile详解 - 心悦君兮君不知-睿</title>
<link>http://www.cnblogs.com/ruigege0000/p/11437669.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ruigege0000/p/11437669.html</guid>
<description>&lt;p&gt;一、for循环练习&lt;/p&gt;
&lt;p&gt;1.例子：输入九九乘法表&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; d23_{

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = 1;i&amp;lt;=9;i++&lt;span&gt;) {

      &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = 1;j&amp;lt;=i;j++&lt;span&gt;) {

        String a &lt;/span&gt;= j+&quot;*&quot;+i+&quot;=&quot;+(j*i)+&quot; &quot;&lt;span&gt;;

        System.out.print(a);

       

      }

      System.out.print(&lt;/span&gt;&quot;\n&quot;&lt;span&gt;);

    }

  }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1707435/201908/1707435-20190831001203079-706736461.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、while语句&lt;/p&gt;
&lt;p&gt;1.while循环语句的语法结构：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;while&lt;/span&gt;&lt;span&gt;(布尔表达式){

    循环体；

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.while循环的执行原理：&lt;/p&gt;
&lt;p&gt;先判断表达式的结果;如果是true则执行循环体，执行完循环体，在进行布尔表达式的判断，循环进行，直到如果结果为false；那么就跳出该循环体&lt;/p&gt;
&lt;p&gt;3.例子:死循环的编译特点&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里面编译是不通过的，因为编译的时候，编译器检测到这是死循环，将会报错&lt;/span&gt;
&lt;span&gt;
      System.out.println(&lt;/span&gt;&quot;这是死循环&quot;&lt;span&gt;);

    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; a = 1&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; b = 2&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(a&amp;lt;b) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里的死循环就会编译通过，因为编译器没有检测到这是死循环，括号里面的语句是运算后才知道这是

      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;死循环的，我们知道在编译阶段，编译器不会计算结果的、&lt;/span&gt;
&lt;span&gt;
      System.out.println(&lt;/span&gt;&quot;这也是一个死循环&quot;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.例子：关于++、--的特殊性&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;int&lt;/span&gt; c = 10&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(c &amp;gt; 0&lt;span&gt;) {

      System.out.print(c&lt;/span&gt;-- + &quot;  &quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里先打印再进行计算&lt;/span&gt;
&lt;span&gt;
    }

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; d = 10&lt;span&gt;;

    System.out.println(&lt;/span&gt;&quot;&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(d &amp;gt; 0&lt;span&gt;) {

      System.out.print(&lt;/span&gt;--d + &quot;  &quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里先计算再进行打印&lt;/span&gt;
&lt;span&gt;
    }

   &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1707435/201908/1707435-20190831001234745-407474680.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、do...while循环&lt;/p&gt;
&lt;p&gt;1.do....while语法结构&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;do&lt;/span&gt;&lt;span&gt;{

    循环体；

}&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(布尔表达式）;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.执行原理：先进行一次循环体，然后判断布尔表达式，如果是真，那么接着进行循环体，再进行判断布尔表达式，直到判断为false.跳出这个循环&lt;/p&gt;
&lt;p&gt;3.do .....while循环的循环体代码片段执行次数为​：1~N次（也就是说最少一次）&lt;/p&gt;
&lt;p&gt;​4.注意：最后的分号千万别忘记了&lt;/p&gt;
&lt;p&gt;三、源码：&lt;/p&gt;
&lt;p&gt;d23_for_and_while_and_do..while_exercise.java&lt;/p&gt;
&lt;p&gt;地址：&lt;/p&gt;
&lt;p&gt;https://github.com/ruigege66/Java/blob/master/d23_for_and_while_and_do..while_exercise.java&lt;/p&gt;
&lt;p&gt;2.CSDN：https://blog.csdn.net/weixin_44630050（心悦君兮君不知-睿）&lt;/p&gt;
&lt;p&gt;3.博客园：https://www.cnblogs.com/ruigege0000/&lt;/p&gt;
&lt;p&gt;4.欢迎关注微信公众号：傅里叶变换，后台回复”礼包“，获取大数据学习资料​&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1707435/201908/1707435-20190831001258106-1752520187.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Aug 2019 16:13:00 +0000</pubDate>
<dc:creator>心悦君兮君不知-睿</dc:creator>
<og:description>一、for循环练习 1.例子：输入九九乘法表 二、while语句 1.while循环语句的语法结构： 2.while循环的执行原理： 先判断表达式的结果;如果是true则执行循环体，执行完循环体，在进</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ruigege0000/p/11437669.html</dc:identifier>
</item>
<item>
<title>SpringBoot自动配置原理 - CharlesWone</title>
<link>http://www.cnblogs.com/charleswone/p/11437635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charleswone/p/11437635.html</guid>
<description>&lt;h2 id=&quot;自动配置原理&quot;&gt;自动配置原理&lt;/h2&gt;
&lt;p&gt;配置文件到底能写什么？怎么写？自动配置原理；&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties&quot;&gt;配置文件能配置的属性参照&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;自动配置原理-1&quot;&gt;1、&lt;strong&gt;自动配置原理：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）、@EnableAutoConfiguration 作用：&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;利用EnableAutoConfigurationImportSelector给容器中导入一些组件？&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以查看selectImports()方法的内容；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;List configurations = getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;==将 类路径下 META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;# Auto Configure
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\
org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\
org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\
org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\
org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\
org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\
org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\
org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\
org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\
org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\
org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\
org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\
org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\
org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\
org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\
org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\
org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\
org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\
org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\
org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\
org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\
org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\
org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\
org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\
org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\
org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\
org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\
org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\
org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\
org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\
org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\
org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\
org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\
org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\
org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\
org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\
org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\
org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\
org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\
org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\
org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每一个这样的 xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；&lt;/p&gt;
&lt;p&gt;3）、每一个自动配置类进行自动配置功能；&lt;/p&gt;
&lt;p&gt;4）、以&lt;strong&gt;HttpEncodingAutoConfiguration（Http编码自动配置）&lt;/strong&gt;为例解释自动配置原理；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration   //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
@EnableConfigurationProperties(HttpEncodingProperties.class)  //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中

@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效

@ConditionalOnClass(CharacterEncodingFilter.class)  //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；

@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)  //判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的
//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
public class HttpEncodingAutoConfiguration {
  
    //他已经和SpringBoot的配置文件映射了
    private final HttpEncodingProperties properties;
  
   //只有一个有参构造器的情况下，参数的值就会从容器中拿
    public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {
        this.properties = properties;
    }
  
    @Bean   //给容器中添加一个组件，这个组件的某些值需要从properties中获取
    @ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？
    public CharacterEncodingFilter characterEncodingFilter() {
        CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
        filter.setEncoding(this.properties.getCharset().name());
        filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
        filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
        return filter;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据当前不同的条件判断，决定这个配置类是否生效？&lt;/p&gt;
&lt;p&gt;一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；&lt;/p&gt;
&lt;p&gt;5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@ConfigurationProperties(prefix = &quot;spring.http.encoding&quot;)  //从配置文件中获取指定的值和bean的属性进行绑定
public class HttpEncodingProperties {

   public static final Charset DEFAULT_CHARSET = Charset.forName(&quot;UTF-8&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;精髓：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;1）、SpringBoot启动会加载大量的自动配置类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;xxxxAutoConfigurartion：自动配置类；&lt;/p&gt;
&lt;p&gt;给容器中添加组件&lt;/p&gt;
&lt;p&gt;xxxxProperties:封装配置文件中相关属性；&lt;/p&gt;
&lt;h3 id=&quot;细节&quot;&gt;2、细节&lt;/h3&gt;
&lt;h4 id=&quot;conditional派生注解spring注解版原生的conditional作用&quot;&gt;1、@Conditional派生注解（Spring注解版原生的@Conditional作用）&lt;/h4&gt;
&lt;p&gt;作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ConditionalOnJava&lt;/td&gt;
&lt;td&gt;系统的java版本是否符合要求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ConditionalOnBean&lt;/td&gt;
&lt;td&gt;容器中存在指定Bean；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;@ConditionalOnMissingBean&lt;/td&gt;
&lt;td&gt;容器中不存在指定Bean；&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ConditionalOnExpression&lt;/td&gt;
&lt;td&gt;满足SpEL表达式指定&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;@ConditionalOnClass&lt;/td&gt;
&lt;td&gt;系统中有指定的类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;@ConditionalOnMissingClass&lt;/td&gt;
&lt;td&gt;系统中没有指定的类&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;@ConditionalOnSingleCandidate&lt;/td&gt;
&lt;td&gt;容器中只有一个指定的Bean，或者这个Bean是首选Bean&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ConditionalOnProperty&lt;/td&gt;
&lt;td&gt;系统中指定的属性是否有指定的值&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ConditionalOnResource&lt;/td&gt;
&lt;td&gt;类路径下是否存在指定资源文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ConditionalOnWebApplication&lt;/td&gt;
&lt;td&gt;当前是web环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@ConditionalOnNotWebApplication&lt;/td&gt;
&lt;td&gt;当前不是web环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@ConditionalOnJndi&lt;/td&gt;
&lt;td&gt;JNDI存在指定项&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;自动配置类必须在一定的条件下才能生效；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们怎么知道哪些自动配置类生效；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;==我们可以通过启用 debug=true属性；来让控制台打印自动配置报告==&lt;/strong&gt;，这样我们就可以很方便的知道哪些自动配置类生效；&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;=========================
AUTO-CONFIGURATION REPORT
=========================


Positive matches:（自动配置类启用的）
-----------------

   DispatcherServletAutoConfiguration matched:
      - @ConditionalOnClass found required class 'org.springframework.web.servlet.DispatcherServlet'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)
      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)
        
    
Negative matches:（没有启动，没有匹配成功的自动配置类）
-----------------

   ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition)

   AopAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required classes 'org.aspectj.lang.annotation.Aspect', 'org.aspectj.lang.reflect.Advice' (OnClassCondition)
        &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 30 Aug 2019 15:54:00 +0000</pubDate>
<dc:creator>CharlesWone</dc:creator>
<og:description>自动配置原理 配置文件到底能写什么？怎么写？自动配置原理； '配置文件能配置的属性参照' 1、 自动配置原理： 1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@Enable</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/charleswone/p/11437635.html</dc:identifier>
</item>
<item>
<title>《Java 编写基于 Netty 的 RPC 框架》 - Java大蜗牛</title>
<link>http://www.cnblogs.com/L10086/p/11437592.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/L10086/p/11437592.html</guid>
<description>&lt;p&gt;一 简单概念&lt;/p&gt;
&lt;p&gt;RPC: ( Remote Procedure Call),远程调用过程,是通过网络调用远程计算机的进程中某个方法,从而获取到想要的数据,过程如同调用本地的方法一样.&lt;/p&gt;
&lt;p&gt;阻塞IO :当阻塞I/O在调用InputStream.read()方法是阻塞的,一直等到数据到来时才返回,同样ServerSocket.accept()方法时,也是阻塞,直到有客户端连接才返回,I/O通信模式如下:&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;http://p1.pstatp.com/large/pgc-image/850ffd4ba15545308dde78a2f55eeb1c&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;缺点:当客户端多时,会创建大量的处理线程,并且为每一个线程分配一定的资源;阻塞可能带来频繁切换上下文,这时引入NIO&lt;/p&gt;
&lt;p&gt;NIO : jdk1.4引入的(NEW Input/Output),是基于通过和缓存区的I/O方式,(插入一段题外话,学的多忘得也多,之前有认真研究过NIO,后来用到的时候,忘得一干二净,所以学习一些东西,经常返回看看),NIO是一种非阻塞的IO模型,通过不断轮询IO事件是否就绪,非阻塞是指线程在等待IO的时候,可以做其他的任务,同步的核心是Selector,Selector代替线程本省的轮询IO事件,避免了阻塞同时减少了不必要的线程消耗;非阻塞的核心是通道和缓存区,当IO事件的就绪时,可以将缓存区的数据写入通道&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;http://p9.pstatp.com/large/pgc-image/71f9bb71884144039a7dec9d58c531e1&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;其工作原理:&lt;/p&gt;
&lt;p&gt;1 由专门的线程来处理所有的IO事件,并且负责转发&lt;/p&gt;
&lt;p&gt;2 事件驱动机制:事件到的时候才触发,而不是同步监视&lt;/p&gt;
&lt;p&gt;3 线程通讯:线程之间通讯通过wait,notify等方式通讯,保证每次上下文切换都是有意义的,减少没必要的线程切换&lt;/p&gt;
&lt;p&gt;通道 : 是对原I/O包中流的模拟,所有数据必须通过Channel对象,常见的通道FileChannel,SocketChannel,ServerSocketChannel,DatagramChannel(UDP协议向网络连接的两端读写数据)&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;http://p1.pstatp.com/large/pgc-image/0a99049e150b43d5b29fee7afefeea02&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Buffer缓存区 :实际上是一个容器,一个连续的数组,任何读写的数据都经过Buffer&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;http://p3.pstatp.com/large/pgc-image/e245eb247ca7470896c8ae69eac1b1ce&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Netty :是由JBOSS提供的一个java开源框架,是一个高性能,异步事件驱动的NIO框架,基于JAVA NIO提供的API实现,他提供了TCP UDP和文件传输的支持,,所有操作都是异步非阻塞的.通过Futrue-Listener机制,本质就是Reactor模式的现实,Selector作为多路复用器,EventLoop作为转发器,而且,netty对NIO中buffer做优化,大大提高了性能&lt;/p&gt;
&lt;p&gt;二 Netty 客户端和服务端的&lt;/p&gt;
&lt;p&gt;Netty中Bootstrap和Channel的生命周期&lt;/p&gt;
&lt;p&gt;Bootstrap简介&lt;/p&gt;
&lt;p&gt;Bootstarp:引导程序,将ChannelPipeline,ChannelHandler,EventLoop进行整体关联&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;http://p3.pstatp.com/large/pgc-image/439fc2b9c8de4472854f0a37a4baa4f6&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;Bootstrap具体分为两个实现&lt;/p&gt;
&lt;p&gt;ServerBootstrap:用于服务端,使用一个ServerChannel接收客户端的连接,并创建对应的子Channel&lt;/p&gt;
&lt;p&gt;Bootstrap:用于客户端,只需要一个单独的Channel,配置整个Netty程序,串联起各个组件&lt;/p&gt;
&lt;p&gt;二者的主要区别:&lt;/p&gt;
&lt;p&gt;1 ServerBootstrap用于Server端,通过调用bind()绑定一个端口监听连接,Bootstrap用于Client端,需要调用connect()方法来连接服务器端,我们也可以调用bind()方法接收返回ChannelFuture中Channel&lt;/p&gt;
&lt;p&gt;2 客户端的Bootstrap一般用一个EventLoopGroup,而服务器的ServerBootstrap会用两个第一个EventLoopGroup专门负责绑定到端口监听连接事件,而第二个EventLoopGroup专门用来处处理每个接收的连接,这样大大提高了并发量&lt;/p&gt;
&lt;pre&gt;
 
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;public class Server { public static void main(String[] args) throws Exception { &lt;span class=&quot;hljs-regexp&quot;&gt;// &lt;span class=&quot;hljs-number&quot;&gt;1 创建线两个事件循环组 // 一个是用于处理服务器端接收客户端连接的 // 一个是进行网络通信的（网络读写的） EventLoopGroup pGroup = new NioEventLoopGroup(); EventLoopGroup cGroup = new NioEventLoopGroup(); &lt;span class=&quot;hljs-regexp&quot;&gt;// &lt;span class=&quot;hljs-number&quot;&gt;2 创建辅助工具类ServerBootstrap，用于服务器通道的一系列配置 ServerBootstrap b = new ServerBootstrap(); b.group(pGroup, cGroup) // 绑定俩个线程组 .channel(NioServerSocketChannel.class) // 指定NIO的模式.NioServerSocketChannel对应TCP, NioDatagramChannel对应UDP .option(ChannelOption.SO_BACKLOG, &lt;span class=&quot;hljs-number&quot;&gt;1024) // 设置TCP缓冲区 .option(ChannelOption.SO_SNDBUF, &lt;span class=&quot;hljs-number&quot;&gt;32 * &lt;span class=&quot;hljs-number&quot;&gt;1024) // 设置发送缓冲大小 .option(ChannelOption.SO_RCVBUF, &lt;span class=&quot;hljs-number&quot;&gt;32 * &lt;span class=&quot;hljs-number&quot;&gt;1024) // 这是接收缓冲大小 .option(ChannelOption.SO_KEEPALIVE, true) // 保持连接 .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() { @Override protected void initChannel(SocketChannel sc) throws Exception { &lt;span class=&quot;hljs-regexp&quot;&gt;//SocketChannel建立连接后的管道 // &lt;span class=&quot;hljs-number&quot;&gt;3 在这里配置 通信数据的处理逻辑, 可以addLast多个... sc.pipeline().addLast(new ServerHandler()); } }); &lt;span class=&quot;hljs-regexp&quot;&gt;// &lt;span class=&quot;hljs-number&quot;&gt;4 绑定端口, &lt;span class=&quot;hljs-keyword&quot;&gt;bind返回future(异步), 加上sync阻塞在获取连接处 ChannelFuture cf1 = b.bind(&lt;span class=&quot;hljs-number&quot;&gt;8765).sync(); &lt;span class=&quot;hljs-regexp&quot;&gt;//ChannelFuture cf2 = b.bind(&lt;span class=&quot;hljs-number&quot;&gt;8764).sync(); &lt;span class=&quot;hljs-regexp&quot;&gt;//可以绑定多个端口 // &lt;span class=&quot;hljs-number&quot;&gt;5 等待关闭, 加上sync阻塞在关闭请求处 cf1.channel().closeFuture().sync(); &lt;span class=&quot;hljs-regexp&quot;&gt;//cf2.channel().closeFuture().sync(); pGroup.shutdownGracefully(); cGroup.shutdownGracefully(); } } public class ServerHandler extends ChannelHandlerAdapter { @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;server channel active... &quot;); } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ByteBuf buf = (ByteBuf) msg; byte[] req = new byte[buf.readableBytes()]; buf.readBytes(req); String body = new String(req, &lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;); System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Server :&quot; + body ); String response = &lt;span class=&quot;hljs-string&quot;&gt;&quot;返回给客户端的响应：&quot; + body ; ctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes())); &lt;span class=&quot;hljs-regexp&quot;&gt;// future完成后触发监听器, 此处是写完即关闭(短连接). 因此需要关闭连接时, 要通过server端关闭. 直接关闭用方法ctx[.channel()].close() //.addListener(ChannelFutureListener.CLOSE); } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;读完了&quot;); ctx.flush(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable t) throws Exception { ctx.close(); } } public class Client { public static void main(String[] args) throws Exception { EventLoopGroup group = new NioEventLoopGroup(); Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() { @Override protected void initChannel(SocketChannel sc) throws Exception { sc.pipeline().addLast(new ClientHandler()); } }); ChannelFuture cf1 = b.connect(&lt;span class=&quot;hljs-string&quot;&gt;&quot;127.0.0.1&quot;, &lt;span class=&quot;hljs-number&quot;&gt;8765).sync(); &lt;span class=&quot;hljs-regexp&quot;&gt;//ChannelFuture cf2 = b.connect(&lt;span class=&quot;hljs-string&quot;&gt;&quot;127.0.0.1&quot;, &lt;span class=&quot;hljs-number&quot;&gt;8764).sync(); &lt;span class=&quot;hljs-regexp&quot;&gt;//可以使用多个端口 //发送消息, Buffer类型. &lt;span class=&quot;hljs-keyword&quot;&gt;write需要flush才发送, 可用writeFlush代替 cf1.channel().writeAndFlush(Unpooled.copiedBuffer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;777&quot;.getBytes())); cf1.channel().writeAndFlush(Unpooled.copiedBuffer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;666&quot;.getBytes())); Thread.sleep(&lt;span class=&quot;hljs-number&quot;&gt;2000); cf1.channel().writeAndFlush(Unpooled.copiedBuffer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;888&quot;.getBytes())); &lt;span class=&quot;hljs-regexp&quot;&gt;//cf2.channel().writeAndFlush(Unpooled.copiedBuffer(&lt;span class=&quot;hljs-string&quot;&gt;&quot;999&quot;.getBytes())); cf1.channel().closeFuture().sync(); &lt;span class=&quot;hljs-regexp&quot;&gt;//cf2.channel().closeFuture().sync(); group.shutdownGracefully(); } } public class ClientHandler extends ChannelHandlerAdapter{ @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { } @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { try { ByteBuf buf = (ByteBuf) msg; byte[] req = new byte[buf.readableBytes()]; buf.readBytes(req); String body = new String(req, &lt;span class=&quot;hljs-string&quot;&gt;&quot;utf-8&quot;); System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Client :&quot; + body ); } finally { &lt;span class=&quot;hljs-regexp&quot;&gt;// 记得释放xxxHandler里面的方法的msg参数: 写(&lt;span class=&quot;hljs-keyword&quot;&gt;write)数据, msg引用将被自动释放不用手动处理; 但只读数据时,!必须手动释放引用数 ReferenceCountUtil.release(msg); } } @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception { } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { ctx.close(); } } &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其他组件:&lt;/p&gt;
&lt;p&gt;Handle: 为了支持各种协议和处理数据的方式,可以是连接,数据接收,异常,数据格式转换等&lt;/p&gt;
&lt;p&gt;ChannelHandler&lt;/p&gt;
&lt;p&gt;ChannelInboundHandler :最常用的Handler,作用是处理接收数据的事件,来处理我们的核心业务逻辑。&lt;/p&gt;
&lt;p&gt;ChannelInitializer :，当一个链接建立时，我们需要知道怎么来接收或者发送数据，当然，我们有各种各样的Handler实现来处理它,那么ChannelInitializer便是用来配置这些Handler，它会提供一个ChannelPipeline，并把Handler加入到ChannelPipeline。&lt;/p&gt;
&lt;p&gt;ChannelPipeline :一个Netty应用基于ChannelPipeline机制,这种机制依赖EventLoop和EventLoopGroup,这三个都和事件或者事件处理相关&lt;/p&gt;
&lt;p&gt;EventLoop : 为Channel处理IO操作,一个EventLoop可以为多个Channel服务&lt;/p&gt;
&lt;p&gt;EventLoopGroup :包含多个EventLoop&lt;/p&gt;
&lt;p&gt;Channel :代表一个Socket连接&lt;/p&gt;
&lt;p&gt;Future :在Netty中所有的IO操作都是异步的,,因此我们不知道,过来的请求是否被处理了,所以我们注册一个监听,当操作执行成功或者失败时监听自动触发,所有操作都会返回一个ChannelFutrue&lt;/p&gt;
&lt;p&gt;ChannelFuture&lt;/p&gt;
&lt;p&gt;Netty 是一个非阻塞的,事件驱动的,网络编程框架,我们通过一张图理解一下,Channel,EventLoop以及EventLoopGroup之间的关系&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;http://p3.pstatp.com/large/pgc-image/9f4c30901ce54747a1462df227d72eb8&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;解释一下,当一个连接过来,Netty首先会注册一个channel,然后EventLoopGroup会分配一个EventLoop绑定到这个channel,在这个channel的整个生命周期过程中,这个EventLoop一直为他服务,这个玩意就是一个线程&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;http://p1.pstatp.com/large/pgc-image/fba5640cf63e4d3cb1a7b7b29af0f59b&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这下聊一下Netty如何处理数据?&lt;/p&gt;
&lt;p&gt;前面有讲到,handler数据处理核心,,而ChannelPipeline负责安排Handler的顺序和执行,我们可以这样理解,数据在ChannelPipeline中流动,其中ChannelHandler就是一个个阀门,这些数据都会经过每一个ChannelHandler并且被他处理,其中ChannelHandler的两个子类ChannelOutboundHandler和ChannelInboundHandler,根据不同的流向,选择不同的Handler&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;http://p1.pstatp.com/large/pgc-image/4ebe5ede2452458c9be470091ac09204&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;由图可以看出,一个数据流进入ChannelPipeline时,一个一个handler挨着执行,各个handler的数据传递,这需要调用方法中ChannelHandlerContext来操作,而这个ChannelHandlerContext可以用来读写Netty中的数据流&lt;/p&gt;
&lt;p&gt;三 Netty中的业务处理&lt;/p&gt;
&lt;p&gt;netty中会有很多Handler.具体哪一种Handler还要看继承是InboundAdapter还是OutboundAdapter,Netty中提供一系列的Adapter来帮助我们简化开发,在ChannelPipeline中的每一个handler都负责把Event传递个洗下一个handler,有这些adapter,这些工作可以自动完成,,我们只需覆盖我们真正实现的部分即可,接下来比较常用的三种ChannelHandler&lt;/p&gt;
&lt;p&gt;Encoders和Decodeers&lt;/p&gt;
&lt;p&gt;我们在网络传输只能传输字节流,在发送数据时,把我们的message转换成bytes这个过程叫Encode(编码),相反,接收数据,需要把byte转换成message,这个过程叫Decode(解码)&lt;/p&gt;
&lt;p&gt;Domain Logic&lt;/p&gt;
&lt;p&gt;我们真正关心的如何处理解码以后的数据,我们真正的业务逻辑便是接收处理的数据,Netty提供一个常用的基类就是SimpleChannelInboundHandler&amp;lt;T&amp;gt;,其中T就是Handler处理的数据类型,消息到达这个Handler,会自动调用这个Handler中的channelRead0(ChannelHandlerContext,T)方法,T就是传过来的数据对象&lt;/p&gt;
&lt;p&gt;四 基于netty实现的Rpc的例子&lt;/p&gt;
&lt;p&gt;这是我的github上项目的位置&lt;/p&gt;
&lt;p&gt;https://github.com/developerxiaofeng/rpcByNetty&lt;/p&gt;
&lt;p&gt;项目目录结构如下&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;zoom-in-cursor&quot; src=&quot;http://p3.pstatp.com/large/pgc-image/f2afc1f077fc44cbbc997280a1cb9a04&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;详细的项目细节看类中的注释,很详细哦。&lt;/p&gt;

&lt;p&gt;最后给大家分享一些学习资料，里面包括：（BATJ面试资料、高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty，Redis，Kafka，Mysql，Zookeeper，Tomcat，Docker，Dubbo，Nginx等多个知识点的架构资料）和Java进阶学习路线图。&lt;/p&gt;
&lt;p&gt;领取方式：加微信号 weixin99ting  备注 ：（资料） 即可获取。&lt;/p&gt;
&lt;p&gt;最后，祝大家早日学有所成！&lt;/p&gt;
</description>
<pubDate>Fri, 30 Aug 2019 15:33:00 +0000</pubDate>
<dc:creator>Java大蜗牛</dc:creator>
<og:description>一 简单概念 RPC: ( Remote Procedure Call),远程调用过程,是通过网络调用远程计算机的进程中某个方法,从而获取到想要的数据,过程如同调用本地的方法一样. 阻塞IO :当阻塞</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/L10086/p/11437592.html</dc:identifier>
</item>
<item>
<title>Java 最全异常讲解 - Java知其所以然</title>
<link>http://www.cnblogs.com/deveypf/p/11437566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deveypf/p/11437566.html</guid>
<description>&lt;h2 id=&quot;导引问题&quot;&gt;1. 导引问题&lt;/h2&gt;
&lt;p&gt;实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是空的等。我们的程序再跑着，内存或硬盘可能满了。等等。&lt;/p&gt;
&lt;p&gt;软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是：Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃。&lt;/p&gt;
&lt;h3 id=&quot;常见的错误&quot;&gt;1.1 常见的错误：&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;用户输入错误&lt;/li&gt;
&lt;li&gt;设备错误。硬件问题，比如打印机关掉、服务器问题&lt;/li&gt;
&lt;li&gt;物理限制。磁盘满了&lt;/li&gt;
&lt;li&gt;代码限制。数组下标越界等&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;设计良好的程序应该在异常发生时提供处理这些错误的方法，使得程序不会因为异常的发生而终断或产生不可预见的结果。&lt;/p&gt;
&lt;p&gt;如果没有异常处理机制，那么：&lt;/p&gt;
&lt;h3 id=&quot;两个坏处&quot;&gt;1.2 两个坏处：&lt;/h3&gt;
&lt;p&gt;1．逻辑代码和错误处理代码放一起！&lt;/p&gt;
&lt;p&gt;2．程序员本身需要考虑的例外情况较复杂，对程序员本身要求较高！&lt;/p&gt;
&lt;p&gt;异常机制就是当程序出现错误，程序如何安全退出的机制。&lt;/p&gt;
&lt;h2 id=&quot;异常exception的概念&quot;&gt;2. 异常（Exception）的概念&lt;/h2&gt;
&lt;p&gt;Java 如何处理异常？&lt;/p&gt;
&lt;p&gt;第一个异常示例和解析：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static void main(String[]args){
    int i=1/0;
}
执行上述代码的异常信息如下：
Exception in thread&quot;main&quot;java.lang.ArithmeticException:/by zero at chuji.BubbleSort.main(BubbleSort.java:11)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Java 是采用面向对象的方式来处理异常的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;处理过程&quot;&gt;3. 处理过程&lt;/h2&gt;
&lt;p&gt;抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给 JRE。&lt;/p&gt;
&lt;p&gt;捕获异常：JRE 得到该异常后，寻找相应的代码来处理该异常。JRE 在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。&lt;/p&gt;
&lt;h2 id=&quot;异常分类&quot;&gt;4. 异常分类&lt;/h2&gt;
&lt;p&gt;JDK 中定义了很多异常类，这些类对应了各种各样可能出现的异常事件，所有异常对象都是派生于 Throwable 类的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常类之间的关系图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images0.cnblogs.com/blog2015/521294/201505/170149357047799.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.3846153846154&quot;&gt;
&lt;p&gt;图引用链接：&lt;a href=&quot;https://www.cnblogs.com/hwaggLee/p/4509038.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/hwaggLee/p/4509038.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;error&quot;&gt;4.2 Error&lt;/h3&gt;
&lt;p&gt;Error 类层次描述了 Java 运行时系统内部错误和资源耗尽错误。这类错误是我们无法控制的，同时也是非常罕见的错误。所以在编程中，不去处理这类错误。&lt;/p&gt;
&lt;p&gt;Error 表明系统 JVM 已经处于不可恢复的崩溃状态中。我们不需要管他。&lt;/p&gt;
&lt;p&gt;打开 JDK 的：java.lang.error，查看他的所有子类。&lt;/p&gt;
&lt;h3 id=&quot;exception&quot;&gt;4.3 Exception&lt;/h3&gt;
&lt;p&gt;所有异常类的父类，其子类对应了各种各样可能出现的异常事件。&lt;/p&gt;
&lt;h3 id=&quot;error-和-exception-的区别&quot;&gt;4.4 Error 和 Exception 的区别&lt;/h3&gt;
&lt;p&gt;我开着车走在路上，一头猪冲在路中间，我刹车。这叫一个异常。&lt;/p&gt;
&lt;p&gt;我开着车在路上，发动机坏了，我停车，这叫错误。系统处于不可恢复的崩溃状态。发动机什么时候坏？我们普通司机能管吗？不能。发动机什么时候坏是汽车厂发动机制造商的事。&lt;/p&gt;
&lt;h3 id=&quot;runtime-exception&quot;&gt;4.4.1 Runtime Exception&lt;/h3&gt;
&lt;p&gt;出现 RuntimeException 就一定是你的问题，可以不捕获，因为小心点这些异常是可以避免的。 派生于RuntimeException 的异常。是一类特殊的异常，如被 0 除、数组下标超范围等，其产生比较频繁，处理麻烦，如果显式的声明或捕获将会对程序可读性和运行效率影响很大。因此由系统自动检测并将它们交给缺省的异常处理程序（用户可不必对其处理）。这类异常通常是由编程错误导致的，因为只有小心点，这些异常都是可以避免的，所以在编写程序时，并不要求必须使用异常处理机制来处理这类异常,所有这类异常都继承自java.lang.RuntimeException。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见的运行时异常有：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li&gt;
&lt;p&gt;ArithmeticException&lt;/p&gt;
&lt;p&gt;如试图除以0&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;NullPointerException&lt;/p&gt;
&lt;p&gt;当程序访问一个空对象的成员变量或方法，访问一个空数组的成员时发生&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;ClassCastException&lt;/p&gt;
&lt;p&gt;发生多态后，如果强制转化的并不是父类的子类时发生。编译的时候可以通过，因为编译的时候并不会检查类型转化的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;ArrayIndexOutOfBoundsException&lt;/p&gt;
&lt;p&gt;访问的元素下表超过数组长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NumberFormatException&lt;/p&gt;
&lt;p&gt;数字格式异常！&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;心得：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大家平时在遇到 NullPointerException，也就是空指针的问题时，不要只记得百度，应该从报错的地方去分析自己的代码，因为空指针其实是你的代码写的不严谨造成的。空指针解决方案：Debug，看你对应的值是否为 null。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;checked-exception&quot;&gt;4.4.2 Checked Exception&lt;/h3&gt;
&lt;p&gt;所有不是 Runtime Exception 的异常，统称为 Checked Exception，又被称为“已检查异常”。 这类异常的产生不是程序本身的问题，通常由外界因素造成的。为了预防这些异常产生时，造成程序的中断或得到不正确的结果，Java 要求编写可能产生这类异常的程序代码时，一定要去做异常的处理。&lt;/p&gt;
&lt;p&gt;编译器将检查是否为所有已检查异常提供异常处理。&lt;/p&gt;
&lt;p&gt;这一类异常，我们必须捕获进行处理。&lt;/p&gt;
&lt;p&gt;Java 语言将派生于 RuntimeException 类或 Error 类的所有异常称为“未检查异常”。&lt;/p&gt;
&lt;h2 id=&quot;异常的处理办法之一捕获异常&quot;&gt;5. 异常的处理办法之一：捕获异常&lt;/h2&gt;
&lt;h3 id=&quot;try&quot;&gt;5.1 try&lt;/h3&gt;
&lt;p&gt;try 语句指定了一段代码，该段代码就是一次捕获并处理的范围。在执行过程中，当任意一条语句产生异常时，就会跳过该段中后面的代码。代码中可能会产生并抛出一种或几种类型的异常对象，它后面的catch语句要分别对这些异常做相应的处理&lt;/p&gt;
&lt;p&gt;一个 try 语句必须带有至少一个 catch 语句块或一个 finally 语句块 。&lt;/p&gt;
&lt;p&gt;注：当异常处理的代码执行结束以后，是不会回到try语句去执行尚未执行的代码。&lt;/p&gt;
&lt;h3 id=&quot;catch&quot;&gt;5.2 catch&lt;/h3&gt;
&lt;p&gt;1、每个 try 语句块可以伴随一个或多个 catch 语句，用于处理可能产生的不同类型的异常对象。&lt;/p&gt;
&lt;p&gt;2.、常用方法：&lt;/p&gt;
&lt;p&gt;toString ( )方法，显示异常的类名和产生异常的原因&lt;br/&gt;getMessage( ) 方法，只显示产生异常的原因，但不显示类名。&lt;br/&gt;printStackTrace( ) 方法，用来跟踪异常事件发生时堆栈的内容。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这些方法均继承自 Throwable 类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3、catch 捕获异常时的捕获顺序：&lt;/p&gt;
&lt;p&gt;如果异常类之间有继承关系，在顺序安排上需注意。越是顶层的类（父类），越放在下面。再不然就直接把多余的catch 省略掉。&lt;/p&gt;
&lt;h3 id=&quot;finally&quot;&gt;5.3 finally&lt;/h3&gt;
&lt;p&gt;有些语句，不管是否发生了异常，都必须要执行，那么就可以把这样的语句放到finally 语句块中。&lt;/p&gt;
&lt;p&gt;通常在 finally 中关闭程序块已打开的资源，比如：文件流、释放数据库连接等。&lt;/p&gt;
&lt;h3 id=&quot;典型代码&quot;&gt;5.4 典型代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class TestException {
    public static void main(String[] args) {
        FileReader reader = null;
        try {
            reader = new FileReader(&quot;d:/a.txt&quot;);
            char temp = (char) reader.read();
            System.out.println(&quot;读出的内容：&quot; + temp);
        } catch (FileNotFoundException e) {
            System.out.println(&quot;文件没有找到！！&quot;);
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
            System.out.println(&quot;文件读取错误！&quot;);
        } finally {
            System.out.println(&quot; 不管有没有异常，我肯定会被执行！&quot;);
            try {
                reader.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;try-catchfinally-return-执行顺序&quot;&gt;5.5 try, catch,finally ,return 执行顺序&lt;/h3&gt;
&lt;h5 id=&quot;执行顺序&quot;&gt;执行顺序：&lt;/h5&gt;
&lt;p&gt;1．执行 try，catch ， 给返回值赋值&lt;/p&gt;
&lt;p&gt;2．执行finally&lt;/p&gt;
&lt;p&gt;3．return&lt;/p&gt;
&lt;h2 id=&quot;异常的处理办法之二声明异常throws-子句&quot;&gt;6. 异常的处理办法之二：声明异常(throws 子句)&lt;/h2&gt;
&lt;p&gt;当 Checked Exception 产生时，不一定立刻处理它，可以再把异常 Throws 出去。&lt;/p&gt;
&lt;p&gt;在方法中使用 try-chatch-finally 由这个方法处理异常。在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。&lt;/p&gt;
&lt;p&gt;如果一个方法中可能产生某种异常，但是并不能确定如何处理这种异常，则应根据异常规范在方法的首部声明该方法可能抛出的异常。&lt;/p&gt;
&lt;p&gt;如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。&lt;/p&gt;
&lt;h3 id=&quot;典型代码-1&quot;&gt;6.1 典型代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;public class FileTest {
    public static void main(String[] args) {
        try {
            readFile(&quot;d:/a.txt&quot;);
        } catch (FileNotFoundException e) {
            System.out.println(&quot;所需要的文件不存在！&quot;);
            e.printStackTrace();
        } catch (IOException e) {
            System.out.println(&quot;文件读写出错误！&quot;);
            e.printStackTrace();
        }
    }

    public static void readFile(String fileName) throws IOException {
        FileReader in = new FileReader(fileName);
        try {
            int tem = 0;
            tem = in.read();
            while (tem != -1) {
                System.out.println((char) tem);
                tem = in.read();
            }
        } finally {
            in.close();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法重写中声明异常原则&quot;&gt;6.2 方法重写中声明异常原则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;子类声明的异常范围不能超过父类声明的范围。包含如下意思：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;父类没有声明异常，子类也不能；&lt;/li&gt;
&lt;li&gt;不可抛出原有方法抛出异常类的父类或上层类&lt;/li&gt;
&lt;li&gt;抛出的异常类型的数目不可以比原有的方法抛出的还多（不是指个数）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;异常的处理办法之三手动抛出异常throw子句&quot;&gt;7. 异常的处理办法之三：手动抛出异常(throw子句)&lt;/h2&gt;
&lt;p&gt;Java 异常类对象除在程序执行过程中出现异常时由系统自动生成并抛出，也可根据需要手工创建并抛出。&lt;/p&gt;
&lt;p&gt;在捕获一个异常前，必须有一段代码先生成异常对象并把它抛出。这个过程我们可以手工做，也可以由 JRE 来实现，但是他们调用的都是 throw 子句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于一个已经存在的异常类，抛出该类异常对象过程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;找到一个合适的异常类。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建一个该类的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将对象抛出&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;File f=new File(&quot;c:/tt.txt&quot;);
if(!f.exists()){
    try{
        throw new FileNotFoundException(&quot;File can't be found!&quot;);
    }catch(FileNotFoundException e){
        e.printStackTrace();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义异常&quot;&gt;8. 自定义异常&lt;/h2&gt;
&lt;p&gt;在程序中，可能会遇到任何标准异常类都没有充分的描述清楚的问题，这种情况下可以创建自己的异常类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么做：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 Exception 类或者它的子类派生一个子类即可&lt;/p&gt;
&lt;p&gt;习惯上，定义的类应该包含 2 个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;典型代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class IllegalAgeException extends Exception {
    public IllegalAgeException() {
    }

    public IllegalAgeException(String msg) {
        super(msg);
    }
}

class Person {
    private String name;
    private int age;

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        if (age &amp;lt; 0) throw new IllegalAgeException(&quot;人的年龄不应该为负数&quot;);
        this.age = age;
    }

    public String toString() {
        return &quot;name is &quot; + name + &quot; and age is &quot; + age;
    }
}

public class MyExceptionTest {
    public static void main(String[] args) {
        Person p = new Person();
        try {
            p.setName(&quot;Lincoln&quot;);
            p.setAge(-1);
        } catch (IllegalAgeException e) {
            e.printStackTrace();
            System.exit(-1);
        }
        System.out.println(p);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用异常机制建议&quot;&gt;9. 使用异常机制建议&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下( Java 是采用面向对象的方式来处理异常的，所以也是会有一定的开销)&lt;/li&gt;
&lt;li&gt;只在异常情况下使用异常机制&lt;/li&gt;
&lt;li&gt;不要进行小粒度的异常处理---应该将整个任务尽可能包装在一个 Try 语句块中&lt;/li&gt;
&lt;li&gt;异常往往在低层抛出，高层处理(捕获)&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;10. 总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一个图&lt;/li&gt;
&lt;li&gt;五个关键字（try, catch, finally, throws, throw）&lt;/li&gt;
&lt;li&gt;先逮小的（子类），再逮大的（父类）&lt;/li&gt;
&lt;li&gt;异常和重写的关系&lt;/li&gt;
&lt;li&gt;自定义异常&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在的喜欢，其实不是真正的喜欢，只是因为不了解而已，真正的喜欢，是建立在非常了解的基础上。了解 java 基础，喜欢上编程，不再迷茫。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;喜欢文章的话可以扫描关注微信公众号&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066199/201908/1066199-20190830232146342-1341539197.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搜索微信公众号：Java知其所以然，可免费领取某课、Java 后端面经等资源，还有统一环境（教你怎么配置一套开发环境）视频领取。&lt;/p&gt;
</description>
<pubDate>Fri, 30 Aug 2019 15:22:00 +0000</pubDate>
<dc:creator>Java知其所以然</dc:creator>
<og:description>1. 导引问题 实际工作中，遇到的情况不可能是非常完美的。比如：你写的某个模块，用户输入不一定符合你的要求、你的程序要打开某个文件，这个文件可能不存在或者文件格式不对，你要读取数据库的数据，数据可能是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/deveypf/p/11437566.html</dc:identifier>
</item>
<item>
<title>Ion内存的带cahce与不带cache问题分享 - OnlyTime_唯有时光</title>
<link>http://www.cnblogs.com/Dreaming-in-Gottingen/p/11437536.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dreaming-in-Gottingen/p/11437536.html</guid>
<description>&lt;p&gt;一次开发中，遇到一个问题：YUV图像（由本地磁盘文件读到ION内存中）缩放时，对于缩放模块的输入源来说，使用带cache的方式要比不带cache的方式速度快数10倍。&lt;/p&gt;
&lt;p&gt;为什么会出现这个情况呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.在解释这个前，需要有一些基础知识，可以回想一下volatile的用途。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它使用在什么场景下呢？多个线程同时访问一个全局变量，例如线程1和线程2都对同一个内存地址的全局变量进行读/写操作，这时就需要将这个变量声明为volatile。&lt;/p&gt;
&lt;p&gt;为什么呢？为了加快cpu的访问速度，会把一些变量值加载到寄存器中使用，当修改了该值后，其只更新在寄存器中，而不是在实际的mem中，虽然看似在对某内存地址上进行修改。而问题发生切换时，线程2中看到的相同地址下的值可能是线程1修改前的值。&lt;/p&gt;
&lt;p&gt;因为cpu被这个线程使用时，cpu觉得“只有我一个人操作这个内存地址，因此我把这个值备份到更快速的地方(cache/register)来加快访问速度，直到万不得已我才把数据加载到mem中”，因此两个线程看到的同一mem地址下的数据可能不相同。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.借此机会，再来引申，说明一下write-through和write-back的概念。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Write-through- Write is done synchronously both to the cache and to the backing store.&lt;br/&gt;Write-back (or Write-behind) – Writing is done only to the cache. A modified cache block is written back to the store, just before it is replaced.&lt;br/&gt;翻译：&lt;/p&gt;
&lt;p&gt;Write-through(直写)——写操作同时被更新到cache和后端存储。&lt;/p&gt;
&lt;p&gt;Write-back(回写)——写操作仅仅被更新到cache中。只有在这个cache将要被更新前，才将旧数据更新到后端存储。&lt;/p&gt;
&lt;p&gt;二者各有优缺点：直写模式下，速度较慢，但数据安全。回写模式下，速度快，但数据不安全(设备断电了！)。&lt;/p&gt;
&lt;p&gt;机械硬盘就是一个很好的例子，例如往硬盘写数据时，也是使用Write-back模式，先写到硬盘的cache中，cpu就去干其它事情了，而接下来时间磁盘可能偷偷将cahe中的数据刷新到物理介质中。&lt;/p&gt;
&lt;p&gt;从磁盘读数据时，也是先将物理介质上一大块数据加载到cache中，下次访问附近的数据时，先在磁盘cache中看下是否能够hit，如果命中了就不必再去物理磁道上去读数据。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.OK，联想打住，回到最初的问题。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为什么ion内存分带cache和不带cache呢？很多模块（VideoCodec、cam、disp）都需要频繁对mem数据进行更新。&lt;/p&gt;
&lt;p&gt;例如h264码流解码后，需要将解码器的output_buf的数据传给(传mem_addr)缩放模块，假如缩放模块进行soft scale down，cpu则去根据一定的算法在mem中抽取像素值。&lt;/p&gt;
&lt;p&gt;假如不带cache，那么速度很慢，因为从phy mem上拿数据毕竟慢，但假如带cache（数据也从phy_mem上刷新到cache），则直接从cache中拿数据则很快。&lt;/p&gt;
&lt;p&gt;同时，特别需要注意一点，这个cache是属于cpu的，而其他外设不知道有这个cache，因而外设只是在实际phy_mem上进行数据更新；然而cpu对mem的访问，表面上看似对phy_mem的访问，但实际上可能是对其镜像(cache)的访问。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.如何保证内存数据一致性呢？（带cache的一个潜在后果）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当编解码模块写数据了后，cpu去读，则需要调用特定的接口，强制从mem中读数据，而不是从cache中读数据。&lt;/p&gt;
&lt;p&gt;当cpu写数据(到cache)了后，编解码模块需要调用特定的接口，将cache中的数据刷新到mem中，编解码模块再从mem中读数据。&lt;/p&gt;
</description>
<pubDate>Fri, 30 Aug 2019 15:07:00 +0000</pubDate>
<dc:creator>OnlyTime_唯有时光</dc:creator>
<og:description>一次开发中，遇到一个问题：YUV图像（由本地磁盘文件读到ION内存中）缩放时，对于缩放模块的输入源来说，使用带cache的方式要比不带cache的方式速度快数10倍。 为什么会出现这个情况呢？ 1.在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dreaming-in-Gottingen/p/11437536.html</dc:identifier>
</item>
<item>
<title>RabbitMQ消息丢失问题和保证消息可靠性-消费端不丢消息和HA（二） - 会飞的笨石头</title>
<link>http://www.cnblogs.com/flyrock/p/11437512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flyrock/p/11437512.html</guid>
<description>&lt;p&gt;继续上篇文章&lt;a href=&quot;https://juejin.im/post/5d468591f265da03b810427e&quot;&gt;解决RabbitMQ消息丢失问题和保证消息可靠性（一）&lt;/a&gt; 未完成部分，我们聊聊MQ Server端的高可用和消费端如何保证消息不丢的问题？&lt;/p&gt;
&lt;p&gt;回归上篇的内容，我们知道消息从生产端到服务端，为了保证消息不丢，我们必须做哪些事情？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送端采用Confirm模式，注意Server端没成功通知发送端，需要重发操作需要额外处理&lt;/li&gt;
&lt;li&gt;消息的持久化处理&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面两个操作保证消息到服务端不丢，但是非高可用状态，如果节点挂掉，服务暂时不可用，需要重启后，消息恢复，消息不会丢失，因为有磁盘存储。&lt;/p&gt;
&lt;p&gt;本文先从消费端讲起：&lt;/p&gt;
&lt;h3 id=&quot;rabbitmqserver&quot;&gt;RabbitMQ Server到消费者消息如何不丢？&lt;/h3&gt;
&lt;p&gt;上面一篇文章也提到了，消费者获取到消息之后，没有来得及处理完毕，自己直接宕机了,因为消息者默认采用自动ack，此时RabbitMQ的自动ack机制会通知MQ Server这条消息已经处理好了，此时消息就丢了，并不是预期的。&lt;/p&gt;
&lt;p&gt;那么我们采用手动ack机制来解决这个问题，消费端处理完逻辑之后再通知MQ Server，这样消费者没处理完消息不会发送ack,如果在消费者拿到消息，没来得及处理的情况下自己挂了，此时MQ集群会自动感知到，它就会自觉的重发消息给其他的消费者服务实例。&lt;/p&gt;
&lt;p&gt;根据上面的思路你需要完成下面的两步操作：&lt;/p&gt;
&lt;p&gt;第一：消费者监听设置手动ack&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;this&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;channel &lt;span class=&quot;pun&quot;&gt;= &lt;span class=&quot;pln&quot;&gt;channelManager&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;getListenerChannel&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;kwd&quot;&gt;namespace&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;this&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;queue &lt;span class=&quot;pun&quot;&gt;= &lt;span class=&quot;pln&quot;&gt;queue&lt;span class=&quot;pun&quot;&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L2&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;this&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;channel&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;basicConsume&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;pln&quot;&gt;queue&lt;span class=&quot;pun&quot;&gt;, &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;false&lt;span class=&quot;pun&quot;&gt;, &lt;span class=&quot;pln&quot;&gt;consumerTag&lt;span class=&quot;pun&quot;&gt;, &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;this&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;this&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;disconnectedCallback&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;setChannel&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;pln&quot;&gt;channel&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;核心代码： this.channel.basicConsume(queue, false, consumerTag, this); 第二个参数设置 false 代表不自动ack&lt;/p&gt;
&lt;p&gt;第二：业务执行完成后手动ack&lt;/p&gt;
&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;kwd&quot;&gt;public &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;static &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;void &lt;span class=&quot;pln&quot;&gt;ack&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;typ&quot;&gt;MessageContext &lt;span class=&quot;pln&quot;&gt;context&lt;span class=&quot;pun&quot;&gt;) &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;long &lt;span class=&quot;pln&quot;&gt;deliveryTag &lt;span class=&quot;pun&quot;&gt;= &lt;span class=&quot;pln&quot;&gt;context&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;getEnvelope&lt;span class=&quot;pun&quot;&gt;().&lt;span class=&quot;pln&quot;&gt;getDeliveryTag&lt;span class=&quot;pun&quot;&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L2&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;try &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L3&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;context&lt;span class=&quot;pun&quot;&gt;.&lt;span class=&quot;pln&quot;&gt;getChannel&lt;span class=&quot;pun&quot;&gt;().&lt;span class=&quot;pln&quot;&gt;basicAck&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;pln&quot;&gt;deliveryTag&lt;span class=&quot;pun&quot;&gt;, &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;false&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L4&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;} &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;catch &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;typ&quot;&gt;IOException &lt;span class=&quot;pln&quot;&gt;e&lt;span class=&quot;pun&quot;&gt;) &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L5&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;throw &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;kwd&quot;&gt;new &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;MqAckException&lt;span class=&quot;pun&quot;&gt;(&lt;span class=&quot;str&quot;&gt;&quot;消息ack出错：连接异常或远端关闭&quot;&lt;span class=&quot;pun&quot;&gt;, &lt;span class=&quot;pln&quot;&gt;context&lt;span class=&quot;pun&quot;&gt;, &lt;span class=&quot;pln&quot;&gt;e&lt;span class=&quot;pun&quot;&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L6&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L7&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;核心代码： context.getChannel().basicAck(deliveryTag, false);&lt;/p&gt;
&lt;p&gt;这里封装来，需要业务在执行完自己的业务代码后，调用对象channel 的ack方法通知MQServer，说我这边执行完了，你可以删除了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意这里有个问题：&lt;/strong&gt; 如果忘记调用这个 context.getChannel().basicAck(deliveryTag, false);&lt;/p&gt;
&lt;p&gt;或者因为代码异常，这个代码没被执行，会怎么样？后面找时间再写一篇文章讲这个问题。&lt;/p&gt;
&lt;h3 id=&quot;rabbitmqserver-1&quot;&gt;RabbitMQ Server中存储的消息高可用&lt;/h3&gt;
&lt;p&gt;当我们解决了，生产端和消费端的问题后，基本保证消息的不丢问题，但是还有一个是消息的高可用问题，单节点问题，普通节点的问题都会影响消息的临时不可用，这个时候要用上我们的HA 镜像集群模式来保证。&lt;/p&gt;
&lt;p&gt;上一篇文章 &lt;a href=&quot;https://juejin.im/post/5d468591f265da03b810427e&quot;&gt;解决RabbitMQ消息丢失问题和保证消息可靠性（一）&lt;/a&gt; 已经提到过，服务端消息部署的三种模式的区别，今天就专门讲镜像模式的介绍。&lt;/p&gt;
&lt;p&gt;镜像模式至少采用3节点，2个磁盘节点和1个内存节点来保证，架构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/29/16cddf2040909d51?w=1688&amp;amp;h=900&amp;amp;f=png&amp;amp;s=266024&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置镜像也有一些策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;同步至所有的，一般不这么做，性能会受到极大影响&lt;/li&gt;
&lt;li&gt;同步最多N个机器&lt;/li&gt;
&lt;li&gt;只同步至符合指定名称的nodes&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;命令处理HA策略模版：rabbitmqctl set_policy [-p Vhost] Name Pattern Definition [Priority]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;为每个以“rock.wechat”开头的队列设置所有节点的镜像，并且设置为自动同步模式&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;rabbitmqctl set_policy ha&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;all &lt;span class=&quot;str&quot;&gt;&quot;^rock.wechat&quot; &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;'{&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;rabbitmqctl set_policy &lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;p rock ha&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;all &lt;span class=&quot;str&quot;&gt;&quot;^rock.wechat&quot; &lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;'{&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}'&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;为每个以“rock.wechat.”开头的队列设置两个节点的镜像，并且设置为自动同步模式&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;rabbitmqctl set_policy &lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;p rock ha&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;exacly &lt;span class=&quot;str&quot;&gt;&quot;^rock.wechat&quot; &lt;span class=&quot;pln&quot;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;code&gt;&lt;span class=&quot;str&quot;&gt;'{&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}'&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ol&gt;&lt;li&gt;为每个以“node.”开头的队列分配指定的节点做镜像&lt;/li&gt;
&lt;/ol&gt;&lt;ol class=&quot;linenums&quot;&gt;&lt;li class=&quot;L0&quot;&gt;&lt;code&gt;&lt;span class=&quot;pln&quot;&gt;rabbitmqctl set_policy ha&lt;span class=&quot;pun&quot;&gt;-&lt;span class=&quot;pln&quot;&gt;nodes &lt;span class=&quot;str&quot;&gt;&quot;^nodes\.&quot; &lt;span class=&quot;pln&quot;&gt;\&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;li class=&quot;L1&quot;&gt;&lt;code&gt;&lt;span class=&quot;str&quot;&gt;'{&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]}'&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;但是：HA 镜像队列有一个很大的缺点就是： 系统的吞吐量会有所下降&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以采用镜像模式，要根据具体的业务规则定制话处理，没那么重要的业务，消息丢了也没关系的场景，又要求必须高的性能的时候，镜像也可以不用设置。&lt;/p&gt;
&lt;h3 id=&quot;&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;两篇文章的讲解，分析了消息中间件高可用问题的大概的思路，没有具体的代码详细，如有疑问可以下方留言评论，我会及时回复解答，后面我会逐步完善相关细节，欢迎多多关注。&lt;/p&gt;
&lt;p&gt;后面计划更新文章如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;什么情况会导致重复消费并怎么解决？&lt;/li&gt;
&lt;li&gt;什么样的真实业务场景需要保障顺序性和如何保证消息的顺序性？&lt;/li&gt;
&lt;li&gt;如何通过消息队列优雅的解决微服务间接口失败的重试？&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;-1&quot;&gt;推荐阅读&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d468591f265da03b810427e&quot;&gt;解决RabbitMQ消息丢失问题和保证消息可靠性（一）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d52a4edf265da03c81516de&quot;&gt;IntelliJ IDEA提升效率开发插件必备&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;end&quot;&gt;END&lt;/h3&gt;
&lt;p&gt;如有收获，请帮忙转发，后续会有更好文章贡献，您的鼓励是作者最大的动力！&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：架构师的修炼，获得独家整理的学习资源和日常干货推送。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/11/16c8008ff72e2619?w=258&amp;amp;h=258&amp;amp;f=jpeg&amp;amp;s=27317&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 30 Aug 2019 15:02:00 +0000</pubDate>
<dc:creator>会飞的笨石头</dc:creator>
<og:description>继续上篇文章解决RabbitMQ消息丢失问题和保证消息可靠性（一）&amp;#160;未完成部分，我们聊聊MQ Server端的高可用和消费端如何保证消息不丢的问题？ 回归上篇的内容，我们知道消息从生产端到服</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flyrock/p/11437512.html</dc:identifier>
</item>
<item>
<title>我是如何学习写一个操作系统（八）：内存管理和段页机制 - dejavudwh</title>
<link>http://www.cnblogs.com/secoding/p/11437268.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/secoding/p/11437268.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;多进程和内存管理是紧密相连的两个模块，因为运行进程也就是从内存中取指执行，创建进程首先要将程序和数据装入内存。将用户原程序变成可在内存中执行的程序，而这就涉及到了内存管理。&lt;/p&gt;
&lt;h2 id=&quot;内存的装入&quot;&gt;内存的装入&lt;/h2&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;h3 id=&quot;绝对装入&quot;&gt;绝对装入。&lt;/h3&gt;
&lt;p&gt;在编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块的地址，将程序和数据装入内存。装入模块被装入内存后，由于程序中的逻辑地址与实际地址完全相同，故不需对程序和数据的地址进行修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;h3 id=&quot;可重定位装入&quot;&gt;可重定位装入。&lt;/h3&gt;
&lt;p&gt;在多道程序环境下，多个目标模块的起始地址通常都是从0开始，程序中的其他地址都是相对于起始地址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对目标程序中指令和数据的修改过程称为重定位，地址变换通常是装入时一次完成，所以成为静态重定位。&lt;br/&gt;其特点是在一个作业装入内存时，必须分配器要求的全部内存空间，如果没有足够的内存，就不能装入，此外一旦作业进入内存后，在整个运行期间，不能在内存中移动，也不能再申请内存空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.5&quot;&gt;
&lt;h3 id=&quot;动态运行时装入&quot;&gt;动态运行时装入&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;也成为动态重定位，程序在内存中如果发生移动，就需要采用动态的装入方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址，这种方式需要一个重定位寄存器的支持。&lt;br/&gt;其特点是可以将程序分配到不连续的存储区中；在程序运行之前可以只装入它的部分代码即可运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以装入内存的最好方法应该就是动态运行时的装入，但是这种方法需要一个方法来进行重定位。这个重定位的信息就保存在每个进程的PCB中，也就是保存这块内存的基地址，所以最后在运行时的地址就是&lt;code&gt;逻辑地址 + 基地址&lt;/code&gt;，而硬件也提供了相应计算的支持，也就是MMU&lt;/p&gt;
&lt;h2 id=&quot;分段机制&quot;&gt;分段机制&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;但是在程序员眼里：程序由若干部分(段)组成，每个段有各自的特点、用途：代码段只读，代码/数据段不会动态增长...。这样就引出了对内存进行分段&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;分段&quot;&gt;分段&lt;/h3&gt;
&lt;p&gt;假如用户进程由主程序、两个字程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并采用一段连续的地址空间（段内要求连续，段间不要求连续），其逻辑地址由两部分组成：段号与段内偏移量，分别记为S、W。&lt;/p&gt;
&lt;p&gt;段号为16位，段内偏移量为16位，则一个作业最多可有2的16次方16=65536个段，最大段长64KB。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/29/a3e14LOJCirRlMc.png&quot; alt=&quot;sdasd.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;gdt和ldt&quot;&gt;GDT和LDT&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;每个进程都有一张逻辑空间与主存空间映射的段表，其中每一段表项对应进程的一个段，段表项纪录路该段在内存中的起始地址和段的长度。在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区。段表用于实现从逻辑端段到物理内存区的映射。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而这个段表就是之前在保护模式提到的GDT和LDT&lt;/p&gt;
&lt;p&gt;&lt;em&gt;一个处理器只有一个GDT。LDT(局部描述表)，一个进程一个LDT，实际上是GTD的一个“子表”。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;LDT和GDT从本质上说是相同的，只是LDT嵌套在GDT之中。&lt;/p&gt;
&lt;p&gt;有一个专门的寄存器LDTR来记录局部描述符表的起始位置，记录的是在GDT中的一个段选择子。所以本质上LDT是一个段描述符，这个描述符就存储在GDT中，对应这个表述符也会有一个选择子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/0073g3xTly1g6gngjr9rbj30ht08dq3j.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;内存分区和分页&quot;&gt;内存分区和分页&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在用了分段机制后，那么就需要对内存进行分区，让各个段载入到相应的内存分区中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;内存分配算法&quot;&gt;内存分配算法&lt;/h4&gt;
&lt;p&gt;在进程装入或换入主存时。如果内存中有多个足够大的空闲块，操作系统必须确定分配那个内存块给进程使用，通常有这几种算法&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首次适应算法：空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;最佳适应算法：空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。&lt;/li&gt;
&lt;li&gt;最坏适应算法：有称最大适应算法，空闲分区以容量递减次序链接。找到第一个能满足要求的空闲分区，也就是挑选最大的分区。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;临近适应算法：又称循环首次适应算法，由首次适应算法演变而成。不同之处是分配内存时从此查找结束的位置开始继续查找。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;内存分页&quot;&gt;内存分页&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;引入内存分页就是为了解决在进行内存分区时导致的内存效率问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分页就是把真正的内存空间划分为大小相等且固定的块，块相对较小，作为内存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。所以这时候对真正的物理内存地址的映射就不能再用分段机制的那套了&lt;/p&gt;
&lt;p&gt;就引入了页表概念：系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，所以对地址的转换变成了对页表的转换&lt;/p&gt;
&lt;p&gt;在系统中通常设置一个页表寄存器PTR，存放页表在内存的初值和页表长度。&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;地址分为页号和页内偏移量两部分，再用页号去检索页表。。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将页表始址与页号和页表项长度的乘积相加，便得到该表项在页表中的位置，于是可从中得到该页的物理块号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是页表还是有两个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;页表占用的内存大&lt;/li&gt;
&lt;li&gt;页表需要频繁的进行地址访问，所以访存速度必须非常快&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;多级页表&quot;&gt;多级页表&lt;/h3&gt;
&lt;p&gt;为了解决页表占用的内存太大，就引入了多级页表&lt;/p&gt;
&lt;p&gt;页目录有2的十次方个4字节的表项，这些表项指向对应的二级表，线性地址的最高10位作为页目录用来寻找二级表的索引&lt;/p&gt;
&lt;p&gt;二级页表里的表项含有相关页面的20位物理基地址，二级页表使用线性地址中间10位来作为寻找表项的索引&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;进程访问某个逻辑地址&lt;/li&gt;
&lt;li&gt;由线性地址中的页号，以及外层页表寄存器(CR3)中的外层页表始址，找到二级页表的始址&lt;/li&gt;
&lt;li&gt;由二级页表的始址，加上线性地址中的外层页内地址，找到对应的二级页表中的页表项&lt;/li&gt;
&lt;li&gt;由页表项中的物理块号，加上线性地址中的页内地址，找到对物理地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/29/VsxrtD32XIpUoBb.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;快表&quot;&gt;快表&lt;/h4&gt;
&lt;p&gt;为了解决访存速度，就有了快表&lt;/p&gt;
&lt;p&gt;在系统中通常设置一个页表寄存器PTR，存放页表在内存的初值和页表长度。&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;CPU给出有效地址后，由硬件进行地址转换，并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号同时进行比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果有找到匹配的页号，说明索要访问的页表项在快表中，则可以直接从中读出该页对应的页框号。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表中，以供后面可能的再次访问。但是如果快表已满，就必须按照一定的算法对其中旧的页表项进行替换。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;段页结合虚拟内存&quot;&gt;段页结合(虚拟内存)&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;既然有了段和页，程序员希望能用段，计算机设计希望用页，那么就需要将二者结合&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以逻辑地址和物理地址的转换：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;首先将给定一个逻辑地址，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;利用其段式内存管理单元，也就是GDT中的断描述符，先将为个逻辑地址转换成一个线性地址，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;再利用页式内存管理单元查表，转换为物理地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;虚拟内存的管理&quot;&gt;虚拟内存的管理&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在实际的操作上，很有可能当前可用的物理内存远小于分配的虚拟内存（4G），这时候就需要请求掉页功能和页面置换功能，也就是在进行地址转换的时候找不到对应页，就启动页错误处理程序来完成调页&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样在页表项中增加了四个段：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;状态位P：用于指示该页是否已调入内存，共程序访问时参考。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改位M：表示该页在调入内存后是否被修改过。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;外存地址：用于指出该也在外存上的地址，通常是物理块号，供调入该页时参考。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以现在在查找物理地址的时候就变成了：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;先检索快表&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;若找到要访问的页，边修改页表中的访问位，然后利用页表项中给出的物理块号和页内地址形成物理地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;若为找到该页的页表项，应到内存中去查找页表，在对比页表项中的状态位P，看该页是否已调入内存，未调入则产生缺页中断，请求从外存把该页调入内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;页面置换算法&quot;&gt;页面置换算法&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;既然有页面的换入换出，那自然就会有相应的不同的算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最佳置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若干页面中那个是未来最长时间内不再被访问的，但是这种算法无法实现。&lt;/p&gt;
&lt;h4 id=&quot;lru算法&quot;&gt;LRU算法&lt;/h4&gt;
&lt;p&gt;选择最近最长时间未访问过的页面予以淘汰，他认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。&lt;/p&gt;
&lt;p&gt;LRU算法一般有两种实现：&lt;/p&gt;
&lt;p&gt;每次地址访问都修改时间戳，淘汰页的时候只需要选择次数最少的即可&lt;/p&gt;
&lt;p&gt;但是需维护一个全局时钟，需找到最小值，实现代价较大&lt;/p&gt;
&lt;p&gt;在每次地址访问的时候都修改栈，这样在淘汰的时候，只需要将栈底换出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/08/30/aMoJ6CDFINzhdBw.png&quot; alt=&quot;fx.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是和上面用时间戳的方法一样，实现的代价都非常大&lt;/p&gt;
&lt;h4 id=&quot;clock算法&quot;&gt;CLOCK算法&lt;/h4&gt;
&lt;p&gt;给每个页帧关联一个使用位。当该页第一次装入内存或者被重新访问到时，将使用位置为1。每次需要替换时，查找使用位被置为0的第一个帧进行替换。在扫描过程中，如果碰到使用位为1的帧，将使用位置为0，在继续扫描。如果所谓帧的使用位都为0，则替换第一个帧&lt;/p&gt;
&lt;p&gt;CLOCK算法的性能比较接近LRU，而通过增加使用的位数目，可是使得CLOCK算法更加高效。在使用位的基础上再增加一个修改位，则得到改进型的CLOCK置换算法。这样，每一帧都出于以下四种情况之一。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;最近未被访问，也未被修改（u=0，m=0）。&lt;/li&gt;
&lt;li&gt;最近被访问，但未被修改（u=1，m=0）。&lt;/li&gt;
&lt;li&gt;最近未被访问，但被修改（u=0，m=1）。&lt;/li&gt;
&lt;li&gt;最近被访问，被修改（u=1，m=1）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;算法执行如下操作步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不作任何修改，选择遇到的第一个帧（u=0，m=0）用于替换。&lt;/li&gt;
&lt;li&gt;如果第1步失败，则重新扫描，查找（u=0，m=1）的帧。选额遇到的第一个这样的帧用于替换。在这个扫面过程中，对每个跳过的帧，把它的使用位设置成0.&lt;/li&gt;
&lt;li&gt;如果第2步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为0.重复第一步，并且如果有必要重复第2步。这样将可以找到供替换的帧。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;改进型的CLOCK算法优于简单的CLOCK算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。&lt;/p&gt;
&lt;h2 id=&quot;linux-0.11的故事&quot;&gt;Linux 0.11的故事&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;所有有关管理内存都是为了服务进程而诞生的，所以先来看一下Linux 0.11里从创建进程开始的故事&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;fork&quot;&gt;fork&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先通过系统调用的中断来创建进程，fork()-&amp;gt;sys_fork-&amp;gt;copy_process&lt;/li&gt;
&lt;li&gt;copy_process的主要作用就是为子进程创建TSS描述符、分配内存和文件设定等等&lt;/li&gt;
&lt;li&gt;copy_mem这里仅为新进程设置自己的页目录表项和页表项，而没有实际为新进程分配物理内存页面。此时新进程与其父进程共享所有内存页面。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int copy_process(int nr,long ebp,long edi,long esi,long gs,long none,
        long ebx,long ecx,long edx,
        long fs,long es,long ds,
        long eip,long cs,long eflags,long esp,long ss)
{
    struct task_struct *p;
    int i;
    struct file *f;

    p = (struct task_struct *) get_free_page();
    if (!p)
        return -EAGAIN;
    task[nr] = p;
    *p = *current;  /* NOTE! this doesn't copy the supervisor stack */
    p-&amp;gt;state = TASK_UNINTERRUPTIBLE;
    p-&amp;gt;pid = last_pid;
    p-&amp;gt;father = current-&amp;gt;pid;
    p-&amp;gt;counter = p-&amp;gt;priority;
    p-&amp;gt;signal = 0;
    p-&amp;gt;alarm = 0;
    p-&amp;gt;leader = 0;      /* process leadership doesn't inherit */
    p-&amp;gt;utime = p-&amp;gt;stime = 0;
    p-&amp;gt;cutime = p-&amp;gt;cstime = 0;
    p-&amp;gt;start_time = jiffies;
    p-&amp;gt;tss.back_link = 0;
    p-&amp;gt;tss.esp0 = PAGE_SIZE + (long) p;
    p-&amp;gt;tss.ss0 = 0x10;
    p-&amp;gt;tss.eip = eip;
    p-&amp;gt;tss.eflags = eflags;
    p-&amp;gt;tss.eax = 0;
    p-&amp;gt;tss.ecx = ecx;
    p-&amp;gt;tss.edx = edx;
    p-&amp;gt;tss.ebx = ebx;
    p-&amp;gt;tss.esp = esp;
    p-&amp;gt;tss.ebp = ebp;
    p-&amp;gt;tss.esi = esi;
    p-&amp;gt;tss.edi = edi;
    p-&amp;gt;tss.es = es &amp;amp; 0xffff;
    p-&amp;gt;tss.cs = cs &amp;amp; 0xffff;
    p-&amp;gt;tss.ss = ss &amp;amp; 0xffff;
    p-&amp;gt;tss.ds = ds &amp;amp; 0xffff;
    p-&amp;gt;tss.fs = fs &amp;amp; 0xffff;
    p-&amp;gt;tss.gs = gs &amp;amp; 0xffff;
    p-&amp;gt;tss.ldt = _LDT(nr);
    p-&amp;gt;tss.trace_bitmap = 0x80000000;
    if (last_task_used_math == current)
        __asm__(&quot;clts ; fnsave %0&quot;::&quot;m&quot; (p-&amp;gt;tss.i387));
    if (copy_mem(nr,p)) {
        task[nr] = NULL;
        free_page((long) p);
        return -EAGAIN;
    }
    for (i=0; i&amp;lt;NR_OPEN;i++)
        if ((f=p-&amp;gt;filp[i]))
            f-&amp;gt;f_count++;
    if (current-&amp;gt;pwd)
        current-&amp;gt;pwd-&amp;gt;i_count++;
    if (current-&amp;gt;root)
        current-&amp;gt;root-&amp;gt;i_count++;
    if (current-&amp;gt;executable)
        current-&amp;gt;executable-&amp;gt;i_count++;
    set_tss_desc(gdt+(nr&amp;lt;&amp;lt;1)+FIRST_TSS_ENTRY,&amp;amp;(p-&amp;gt;tss));
    set_ldt_desc(gdt+(nr&amp;lt;&amp;lt;1)+FIRST_LDT_ENTRY,&amp;amp;(p-&amp;gt;ldt));
    p-&amp;gt;state = TASK_RUNNING;    /* do this last, just in case */
    return last_pid;
}

int copy_mem(int nr,struct task_struct * p)
{
    unsigned long old_data_base,new_data_base,data_limit;
    unsigned long old_code_base,new_code_base,code_limit;

    code_limit=get_limit(0x0f);
    data_limit=get_limit(0x17);
    old_code_base = get_base(current-&amp;gt;ldt[1]);
    old_data_base = get_base(current-&amp;gt;ldt[2]);
    if (old_data_base != old_code_base)
        panic(&quot;We don't support separate I&amp;amp;D&quot;);
    if (data_limit &amp;lt; code_limit)
        panic(&quot;Bad data_limit&quot;);
    new_data_base = new_code_base = nr * 0x4000000;
    p-&amp;gt;start_code = new_code_base;
    set_base(p-&amp;gt;ldt[1],new_code_base);
    set_base(p-&amp;gt;ldt[2],new_data_base);
    if (copy_page_tables(old_data_base,new_data_base,data_limit)) {
        printk(&quot;free_page_tables: from copy_mem\n&quot;);
        free_page_tables(new_data_base,data_limit);
        return -ENOMEM;
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;page&quot;&gt;page&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;copy_page_tables就是复制页目录表项和页表项，从而被复制的页目录和页表对应的原物理内存页面区被两套页表映射而共享使用。复制时，需申请新页面来存放新页表，原物理内存区将被共享。此后两个进程（父进程和其子进程）将共享内存区，直到有一个进程执行操作时，内核才会为写操作进程分配新的内存页(写时复制机制)。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;int copy_page_tables(unsigned long from,unsigned long to,long size)
{
    unsigned long * from_page_table;
    unsigned long * to_page_table;
    unsigned long this_page;
    unsigned long * from_dir, * to_dir;
    unsigned long nr;

    if ((from&amp;amp;0x3fffff) || (to&amp;amp;0x3fffff))
        panic(&quot;copy_page_tables called with wrong alignment&quot;);
    from_dir = (unsigned long *) ((from&amp;gt;&amp;gt;20) &amp;amp; 0xffc); /* _pg_dir = 0 */
    to_dir = (unsigned long *) ((to&amp;gt;&amp;gt;20) &amp;amp; 0xffc);
    size = ((unsigned) (size+0x3fffff)) &amp;gt;&amp;gt; 22;
    for( ; size--&amp;gt;0 ; from_dir++,to_dir++) {
        if (1 &amp;amp; *to_dir)
            panic(&quot;copy_page_tables: already exist&quot;);
        if (!(1 &amp;amp; *from_dir))
            continue;
        from_page_table = (unsigned long *) (0xfffff000 &amp;amp; *from_dir);
        if (!(to_page_table = (unsigned long *) get_free_page()))
            return -1;  /* Out of memory, see freeing */
        *to_dir = ((unsigned long) to_page_table) | 7;
        nr = (from==0)?0xA0:1024;
        for ( ; nr-- &amp;gt; 0 ; from_page_table++,to_page_table++) {
            this_page = *from_page_table;
            if (!(1 &amp;amp; this_page))
                continue;
            this_page &amp;amp;= ~2;
            *to_page_table = this_page;
            if (this_page &amp;gt; LOW_MEM) {
                *from_page_table = this_page;
                this_page -= LOW_MEM;
                this_page &amp;gt;&amp;gt;= 12;
                mem_map[this_page]++;
            }
        }
    }
    invalidate();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;no_page&quot;&gt;no_page&lt;/h3&gt;
&lt;p&gt;如果找不到相应的页，也就是要执行换入和换出了，在此之前CPU会先触发缺页异常&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缺页异常中断的处理，会调用do_no_page&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;s&quot;&gt;
&lt;code&gt;page_fault:
    xchgl %eax,(%esp)       # 取出错码到eax
    pushl %ecx
    pushl %edx
    push %ds
    push %es
    push %fs
    movl $0x10,%edx         # 置内核数据段选择符
    mov %dx,%ds
    mov %dx,%es
    mov %dx,%fs
    movl %cr2,%edx          # 取引起页面异常的线性地址
    pushl %edx              # 将该线性地址和出错码压入栈中，作为将调用函数的参数
    pushl %eax
    testl $1,%eax           # 测试页存在标志P（为0），如果不是缺页引起的异常则跳转
    jne 1f
    call do_no_page         # 调用缺页处理函数
    jmp 2f
1:  call do_wp_page         # 调用写保护处理函数
2:  addl $8,%esp            # 丢弃压入栈的两个参数，弹出栈中寄存器并退出中断。
    pop %fs
    pop %es
    pop %ds
    popl %edx
    popl %ecx
    popl %eax
    iret&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;该函数首先尝试与已加载的相同文件进行页面共享，或者只是由于进程动态申请内存页面而只需映射一页物理内存即可。若共享操作不成功，那么只能从相应文件中读入所缺的数据页面到指定线性地址处。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void do_no_page(unsigned long error_code,unsigned long address)
{
    int nr[4];
    unsigned long tmp;
    unsigned long page;
    int block,i;

    address &amp;amp;= 0xfffff000;
    tmp = address - current-&amp;gt;start_code;
    if (!current-&amp;gt;executable || tmp &amp;gt;= current-&amp;gt;end_data) {
        get_empty_page(address);
        return;
    }
    if (share_page(tmp))
        return;
    if (!(page = get_free_page()))
        oom();
/* remember that 1 block is used for header */
    block = 1 + tmp/BLOCK_SIZE;
    for (i=0 ; i&amp;lt;4 ; block++,i++)
        nr[i] = bmap(current-&amp;gt;executable,block);
    bread_page(page,current-&amp;gt;executable-&amp;gt;i_dev,nr);
    i = tmp + 4096 - current-&amp;gt;end_data;
    tmp = page + 4096;
    while (i-- &amp;gt; 0) {
        tmp--;
        *(char *)tmp = 0;
    }
    if (put_page(page,address))
        return;
    free_page(page);
    oom();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;这一篇的篇幅很长，因为把有关内存管理的东西都写在一起了，主要有三个关键点：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分段&lt;/p&gt;
&lt;p&gt;对内存的分段引申的GDT和IDT来进行物理地址的寻址&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;分页&lt;/p&gt;
&lt;p&gt;再由于分段引出的内存分区，为了提高效率而引入的分页机制，重点就是用页式内存管理单元查表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;段页结合&lt;br/&gt;所以为了将段和页结合就需要一个机制来转化逻辑地址和物理地址，也就分为两步走
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;利用其段式内存管理单元，也就是GDT中的断描述符，先将为个逻辑地址转换成一个线性地址，&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;再利用页式内存管理单元查表，转换为物理地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 30 Aug 2019 13:43:00 +0000</pubDate>
<dc:creator>dejavudwh</dc:creator>
<og:description>前言 多进程和内存管理是紧密相连的两个模块，因为运行进程也就是从内存中取指执行，创建进程首先要将程序和数据装入内存。将用户原程序变成可在内存中执行的程序，而这就涉及到了内存管理。 内存的装入 绝对装入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/secoding/p/11437268.html</dc:identifier>
</item>
</channel>
</rss>