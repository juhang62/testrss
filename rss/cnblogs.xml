<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据分析之漏斗模型 - 白胡子海盗</title>
<link>http://www.cnblogs.com/wzrong/p/10733667.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzrong/p/10733667.html</guid>
<description>&lt;h3&gt;&lt;span&gt;什么是漏斗？&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;提起漏斗，让我首先想到的是它的 形状：圆锥形的、顶部宽底部窄；其次是它的 功能：过滤杂质，如生了虫的白面、炸过豆腐的油等。&lt;/p&gt;

&lt;h4&gt;形状&lt;/h4&gt;
&lt;p&gt;如下图形状才能够有效的行使它的功能职责 — 过滤。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43860/201904/43860-20190419062226709-1471447672.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file:///Users/wzrong/Desktop/数据分析之漏斗模型/漏斗.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;功能&lt;/h4&gt;
&lt;p&gt;过滤杂质&lt;/p&gt;
&lt;p&gt;生了虫的白面&lt;/p&gt;
&lt;p&gt;小时候的农村，夏天雨水较多，家里比较潮湿，缸里的面经常会有虫子光顾。&lt;/p&gt;
&lt;p&gt;那个时候物质匮乏，不舍的扔掉，会把虫子以及结块的面粉经过筛子（筛子及漏斗）给过滤掉，然后继续吃过筛的面粉。&lt;/p&gt;

&lt;p&gt;炸过豆腐的油&lt;/p&gt;
&lt;p&gt;过年的时候，会炸几片豆腐，俗称过油豆腐。然后炸过豆腐的油，里边会有一些豆腐渣子残留，为了重复利用油，会拿油漏把豆腐渣子给过滤掉，然后漏下的油在下次炒菜的时候继续用。&lt;/p&gt;

&lt;h3&gt;什么是漏斗模型？&lt;/h3&gt;
&lt;p&gt;漏斗我们知道了，那什么是模型呢？&lt;/p&gt;

&lt;p&gt;模型一般是指对事物、规律等进行抽象后的一种形式化表达方式。&lt;/p&gt;
&lt;p&gt;大部分的模型都是由三部分组成的，即目标、变量和关系。&lt;/p&gt;

&lt;p&gt;漏斗模型就是对漏斗的形状和功能进行抽象后的一种形式化表达方式，通过目标、变量和关系对数据进行分析。&lt;/p&gt;

&lt;h4&gt;目标&lt;/h4&gt;
&lt;p&gt;在使用漏斗模型进行分析之前，首先需要明确目标，知道需要做什么。比如传统漏斗模型，最早起源于传统行业的商业营销活动中，目标就是商业变现。&lt;/p&gt;

&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;投放广告，提高用户对品牌的认知，占领用户的心智；&lt;/li&gt;
&lt;li&gt;观看广告，提高用户对产品的兴趣；&lt;/li&gt;
&lt;li&gt;评估产品，用户会根据对品牌认证和产品兴趣来决定是否购买；&lt;/li&gt;
&lt;li&gt;付费购买，用户会对评估完后感兴趣的产品进行购买，达成交易；&lt;/li&gt;
&lt;li&gt;重复购买，部分用户会持续重复购买，也可能推荐给亲戚朋友。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上是传统的金典的漏斗模型，是一种收缩型思维，每一步之间都可能会因为各种不确定变量而被过滤掉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43860/201904/43860-20190419062300760-1645057348.png&quot; alt=&quot;&quot; width=&quot;811&quot; height=&quot;475&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file:///Users/wzrong/Desktop/数据分析之漏斗模型/Snip20190418_67.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;变量&lt;/h4&gt;
&lt;p&gt;在明确了漏斗模型的目标以后，才能进一步确定影响目标的各关键变量。&lt;/p&gt;
&lt;p&gt;变量又分为自变量、因变量和中介变量。&lt;/p&gt;

&lt;p&gt;因变量 在组织行为学中就是所要测量的行为反应，而 自变量 则是影响因变量的变量。&lt;/p&gt;

&lt;p&gt;如上边传统漏斗模型，因变量是广告观看率、商品付费率、重复购买率等，那么广告的投放渠道（如电视、报纸杂志、地铁、门户网站等）、观看广告的用户年龄层次、用户所在的区域、用户的兴趣爱好、用户的经济条件等就是影响因变量的自变量。&lt;/p&gt;

&lt;p&gt;中介变量 又称为干扰变量，它会削弱自变量对因变量的影响。中介变量的存在会使自变量与因变量之间的关系更加复杂。&lt;/p&gt;

&lt;p&gt;中介变量也就是我们需要介入的变量，需要我们去无限的进行解构，来影响自变量。比如从 A 到 R （获客 - 盈利）的转换问题，我们可以把 A 拆分为 A1、A2、A3，再看哪一步对自变量的影响比较大，假设是 A2，那么再把 A2拆开，再看其中的主要问题。&lt;/p&gt;

&lt;p&gt;如上边传统的漏斗模型，假设我们的品牌为高端奢侈品，那么我们需要对投放渠道、用户年龄层次、投放区域等进行拆分。然后发现我们的投放区域覆盖面太多，成本比较高。然后我们对投放地区进行拆分，发现偏远地区投放占比比较高，那么这个时候，我们是否找到了问题呢？我们可以收缩投放区域，有针对性的在北上广深等这样的大城市集中投放会不会效果更好一些呢？&lt;/p&gt;

&lt;p&gt;最理想的状态是，我们能够解构到唯一变量的颗粒度。然后我们就能够精准定位并且解决这个问题，从而带来增长。&lt;/p&gt;

&lt;p&gt;如果我们用的漏斗是一个很粗略的漏斗，是无法解决问题的。需要一步步解构、定位问题，然后去解决，这样才能带来有效的增长。&lt;/p&gt;

&lt;h4&gt;关系&lt;/h4&gt;
&lt;p&gt;确定了目标，确定了影响目标的各种变量之后，还需要进一步研究各变量之间的关系。在确定变量之间的关系时，对何者为因、何者为果的判断，应持谨慎态度。不能因为两个变量之间存在着统计上的关系，就简单地认为他们之间存在着因果关系。对变量间因果关系的判断不能轻率。&lt;/p&gt;

&lt;h3&gt;用户增长漏斗转化&lt;/h3&gt;
&lt;p&gt;很多时候我们谈增长，更多的是在谈获客，而没有考虑如何提升现有用户的转化率、激活率。我们需要考虑如何才能让用户变成忠诚用户，只有忠诚用户才不会流失，才能带来更多的收益。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43860/201904/43860-20190419062334276-1218068889.jpg&quot; alt=&quot;&quot; width=&quot;915&quot; height=&quot;293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;file:///Users/wzrong/Desktop/数据分析之漏斗模型/WechatIMG1032.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过漏斗分析可以从前到后还原用户转化的路径，分析每一个转化节点的效率。&lt;/p&gt;

&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;从开始到结尾，整体的转化率是多少？&lt;/li&gt;
&lt;li&gt;每一步的转率是多少？&lt;/li&gt;
&lt;li&gt;哪一步流失最多，原因是什么？流失的用户符合哪些特征？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;file:///Users/wzrong/Desktop/数据分析之漏斗模型/Snip20190418_66.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43860/201904/43860-20190419062350471-1746543290.png&quot; alt=&quot;&quot; width=&quot;783&quot; height=&quot;450&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中注册流程分为 3 个步骤，总体转化率为 42.6%，也就是说有 1000 个用户来到注册页面，其中 426 个成功完成了注册。&lt;/p&gt;

&lt;p&gt;但是我们不难发现注册第 2 步的转化率是 54.2%，明显低于注册第 1 步的 89.9% 和 第三步的 87.5%，可以推测注册第 2 步流程存在问题。&lt;/p&gt;

&lt;p&gt;显而易见注册第 2 步的提升空间是最大的，投入回报比肯定不低；如果要提高注册转化率，我们应该优先解决注册第 2 步。&lt;/p&gt;

&lt;p&gt;请关注公众号：白胡子海盗&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43860/201904/43860-20190419062613165-265742373.jpg&quot; alt=&quot;&quot; width=&quot;430&quot; height=&quot;447&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 22:27:00 +0000</pubDate>
<dc:creator>白胡子海盗</dc:creator>
<og:description>什么是漏斗？ 提起漏斗，让我首先想到的是它的 形状：圆锥形的、顶部宽底部窄；其次是它的 功能：过滤杂质，如生了虫的白面、炸过豆腐的油等。 形状 如下图形状才能够有效的行使它的功能职</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wzrong/p/10733667.html</dc:identifier>
</item>
<item>
<title>python网络-多进程(21) - Se7eN_HOU</title>
<link>http://www.cnblogs.com/Se7eN-HOU/p/10733583.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Se7eN-HOU/p/10733583.html</guid>
<description>&lt;h3&gt;一、什么是进程&lt;/h3&gt;
&lt;p&gt;进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是&lt;a href=&quot;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&quot; target=&quot;_blank&quot;&gt;操作系统&lt;/a&gt;结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。---来自百度百科&lt;/p&gt;
&lt;p&gt;狭义定义：进程是正在运行的程序的实例（an instance of a computer program that is being executed）。&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;9.7411764705882&quot;&gt;广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是&lt;a href=&quot;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192&quot; target=&quot;_blank&quot; data-lemmaid=&quot;192&quot;&gt;操作系统&lt;/a&gt;动态执行的&lt;a href=&quot;https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83&quot; target=&quot;_blank&quot;&gt;基本单元&lt;/a&gt;，在传统的&lt;a href=&quot;https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&quot; target=&quot;_blank&quot;&gt;操作系统&lt;/a&gt;中，进程既是基本的&lt;a href=&quot;https://baike.baidu.com/item/%E5%88%86%E9%85%8D%E5%8D%95%E5%85%83&quot; target=&quot;_blank&quot;&gt;分配单元&lt;/a&gt;，也是基本的执行单元。&lt;/div&gt;

&lt;div class=&quot;para&quot; readability=&quot;17.321821036107&quot;&gt;进程的概念主要有两点：第一，进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括&lt;a href=&quot;https://baike.baidu.com/item/%E6%96%87%E6%9C%AC&quot; target=&quot;_blank&quot;&gt;文本&lt;/a&gt;区域（text region）、数据区域（data region）和&lt;a href=&quot;https://baike.baidu.com/item/%E5%A0%86%E6%A0%88&quot; target=&quot;_blank&quot;&gt;堆栈&lt;/a&gt;（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。第二，进程是一个“执行中的程序”。程序是一个没有生命的实体，只有&lt;a href=&quot;https://baike.baidu.com/item/%E5%A4%84%E7%90%86&quot; target=&quot;_blank&quot;&gt;处理&lt;/a&gt;器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为&lt;a href=&quot;https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B&quot; target=&quot;_blank&quot;&gt;进程&lt;/a&gt;。&lt;/div&gt;

&lt;h3 class=&quot;para&quot;&gt;二、程序和进程的关系&lt;/h3&gt;
&lt;p&gt;编写完毕的代码，在没有运⾏的时候，称之为程序&lt;/p&gt;
&lt;p&gt;正在运⾏着的代码，就成为进程&lt;/p&gt;
&lt;p&gt;进程除了包含代码以外还有需要运⾏的环境等所以和程序是有区别的&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/751754/201904/751754-20190418170841954-1470504862.png&quot; alt=&quot;&quot; width=&quot;750&quot;/&gt;&lt;/div&gt;

&lt;h3 class=&quot;para&quot;&gt;三、fork()&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;fork（）函数只可以在Linux和Mac系统中，在windows中不可以用，所以它使用的也比较少&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
pid &lt;/span&gt;=&lt;span&gt; os.fork()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid ==&lt;span&gt; 0:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;子进程&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;主进程&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;主进程
子进程&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;para&quot;&gt;&lt;strong&gt; getpid()、getppid()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
pid &lt;/span&gt;=&lt;span&gt; os.fork()

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid ==&lt;span&gt; 0:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是子进程(%d),我的父进程(%d)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是父进程(%d),我的子进程(%d)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid,pid))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;父子进程都可以执行的代码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
我是父进程(4488),我的子进程(4491&lt;span&gt;）
父子进程都可以执行的代码
我是子进程(&lt;/span&gt;4491),我的父进程(4488&lt;span&gt;)
父子进城都可以执行的代码&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序执⾏到os.fork()时，操作系统会创建⼀个新的进程（⼦进程），然后复制⽗进程的所有信息到⼦进程中&lt;/li&gt;
&lt;li&gt;然后⽗进程和⼦进程都会从fork()函数中得到⼀个返回值，在⼦进程中这个值⼀定是0，⽽⽗进程中是⼦进程的id号&lt;/li&gt;
&lt;li&gt;普通的函数调⽤，调⽤⼀次，返回⼀次，但是fork()调⽤⼀次，返回两次，因为操作系统⾃动把当前进程（称为⽗进程）复制了⼀份（称为⼦进程），然后，分别在⽗进程和⼦进程内返回&lt;/li&gt;
&lt;li&gt;⼀个⽗进程可以fork出很多⼦进程，所以，⽗进程要记下每个⼦进程的ID，⽽⼦进程只需要调⽤getppid()就可以拿到⽗进程的ID&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;para&quot;&gt;&lt;strong&gt;多个fork()&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os 

pid1 &lt;/span&gt;=&lt;span&gt; os.fork()
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid1 == 0:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子进程1&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1:我是第一个子进程%d,我的父进程是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;父进程&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2:我是父进程%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())
&lt;/span&gt;&lt;span&gt;
pid2 &lt;/span&gt;=&lt;span&gt; os.fork()
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid2==&lt;span&gt;0:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3:我是谁%d,我的父进程是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4:我是谁%d,我的父进程是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(os.getpid(),os.getppid()))
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
运行结果为：
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
2&lt;span&gt;:我是父进程3189
&lt;/span&gt;1&lt;span&gt;:我是第一个子进程3190,我的父进程是3189
&lt;/span&gt;4&lt;span&gt;:我是谁3190,我的父进程是3189
&lt;/span&gt;3&lt;span&gt;:我是谁3191,我的父进程是3189
&lt;/span&gt;3&lt;span&gt;:我是谁3192,我的父进程是3190
&lt;/span&gt;4:我是谁3189,我的父进程是991
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;strong&gt;说明：&lt;/strong&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;pid2开辟的进程将会被子进程1和父进程同时调用&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当父线程调用pid2&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;if pid2 == 0:会在创建一个子进程2，父进程是主进程 　　&lt;/li&gt;
&lt;li&gt;else:及父线程本身，不会再创建进程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当子进程1调用pid2&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;if pid2 ==0:会创建一个子子进程，父进程是子进程1&lt;/li&gt;
&lt;li&gt;else：即子线程1本身，不会再创建进程&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实上面的代码就相当于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os 

pid1 &lt;/span&gt;=&lt;span&gt; os.fork()
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid1 == 0:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子进程1&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1:我是第一个子进程%d,我的父进程是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;:&lt;span&gt;#&lt;/span&gt;&lt;span&gt;父进程&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2:我是父进程%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())


pid2 &lt;/span&gt;=&lt;span&gt; os.fork()
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid1 ==&lt;span&gt; 0:&lt;span&gt;#子进程1
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid2==&lt;span&gt;0:&lt;span&gt;#子子进程
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3:我是谁%d,我的父进程是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;span&gt;#子进程1
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4:我是谁%d,我的父进程是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;span&gt;#父进程
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; pid2==&lt;span&gt;0:&lt;span&gt;#子进程2
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3:我是谁%d,我的父进程是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:&lt;span&gt;#父进程
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4:我是谁%d,我的父进程是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(os.getpid(),os.getppid()))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;四、multiprocessing&lt;/h3&gt;
&lt;p&gt;由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。multiprocessing模块就是跨平台版本的多进程模块。&lt;/p&gt;
&lt;p&gt;multiprocessing模块提供了一个Process类来代表一个进程对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子进程要执行的代码&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; sub_process(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是在子进程中，name=%s,pid=%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(name,os.getpid()))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;父进程：%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())

    p&lt;/span&gt;=Process(target=sub_process,args=(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----子进程将要开启----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    p.start()&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启子进程&lt;/span&gt;
&lt;span&gt;    p.join()&lt;span&gt;#用于等待子进程执行完毕再继续往下执行
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----子进程已经结束----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
父进程：8344
----子进程将要开启----&lt;span&gt;
这是在子进程中，name&lt;/span&gt;=test,pid=9064
----子进程已经结束----
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。&lt;/li&gt;
&lt;li&gt;join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;process语法结构如下：&quot;&gt;&lt;strong&gt;Process语法结构如下：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Process([group [, target [, name [, args [, kwargs]]]]])&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1 group：参数未使用，值始终为None 2 target：表示调用对象，即子进程要执行的任务 3 args：表示调用对象的位置参数元组，args=(1,2,'a',) 4 kwargs：表示调用对象的字典,kwargs={'name':'a','age':18} 5 name：为子进程的名称&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Process类常用方法：&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;
1 start()：启动进程，并调用该子进程中的p.run() 
2 run():进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法  
3 terminate():强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁
4 is_alive():如果p仍然运行，返回True
5 join([timeout]):主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程 
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Process类常用属性：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
1 daemon：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程，必须在p.start()之前设置
2 name:进程的名称
3 pid：进程的pid
4 exitcode:进程在运行时为None、如果为–N，表示被信号N结束(了解即可)
5 authkey:进程的身份验证键,默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功（了解即可）
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;两个子进程将会调用的两个方法&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; worker_1(interval):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker_1：父进程(%s),当前进程(%s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getppid(),os.getpid()))
    t_start &lt;/span&gt;=&lt;span&gt; time.time()
    time.sleep(interval) &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;程序将会被挂起interval秒&lt;/span&gt;
    t_end =&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker_1,执行时间为'%0.2f'秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(t_end -&lt;span&gt; t_start))

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; worker_2(interval):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker_2,父进程(%s),当前进程(%s)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getppid(),os.getpid()))
    t_start &lt;/span&gt;=&lt;span&gt; time.time()
    time.sleep(interval)
    t_end &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;worker_2,执行时间为'%0.2f'秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(t_end -&lt;span&gt; t_start))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出当前程序的ID&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt;==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())
    p1&lt;/span&gt;=Process(target=worker_1,args=(2&lt;span&gt;,))
    p2&lt;/span&gt;=Process(target=worker_2,name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,args=(1&lt;span&gt;,))
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())
    p1.start()
    p2.start()

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;同时父进程仍然往下执行，如果p2进程还在执行，将会返回True&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p2.is_alive=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;p2.is_alive())
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;输出p1和p2进程的别名和pid&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1.name=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;p1.name)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1.pid=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;p1.pid)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p2.name=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;p2.name)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p2.pid=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;p2.pid)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;join括号中不携带参数，表示父进程在这个位置要等待p1进程执行完成后，再继续执行下面的语句，一般用于进程间的数据同步&lt;/span&gt;
&lt;span&gt;    p1.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;p1.is_alive=%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;p1.is_alive())
    p2.join()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;7:%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%os.getpid())
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
1:10452
2:10452
3:10452
4:10452
5:10452&lt;span&gt;
p2.is_alive&lt;/span&gt;=&lt;span&gt;True
p1.name&lt;/span&gt;=Process-1&lt;span&gt;
p1.pid&lt;/span&gt;=10688&lt;span&gt;
p2.name&lt;/span&gt;=&lt;span&gt;Se7eN_HOU
p2.pid&lt;/span&gt;=2192
6:10452 
1:2192
2:2192
3:2192
7:2192&lt;span&gt;
worker_2,父进程(&lt;/span&gt;10452),当前进程(2192&lt;span&gt;)
worker_2,执行时间为&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;秒
&lt;/span&gt;1:10688
2:10688
3:10688
7:10688&lt;span&gt;
worker_1：父进程(&lt;/span&gt;10452),当前进程(10688&lt;span&gt;)
worker_1,执行时间为&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2.00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;秒
p1.is_alive&lt;/span&gt;=&lt;span&gt;False
&lt;/span&gt;7:10452
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;五、创建Process子类创建多进程&lt;/h3&gt;
&lt;p&gt;创建新的进程还能够使用类的方式，可以自定义一个类，继承Process类，每次实例化这个类的时候，就等同于实例化一个进程对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个类，继承Process类&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; My_Process(Process):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,interval):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;因为Process类本身也有__init__方法，这个子类相当于重写了这个方法，&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;但这样就会带来一个问题，我们并没有完全的初始化一个Process类，所以就不能使用从这个类继承的一些方法和属性，&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;最好的方法就是将继承类本身传递给Process.__init__方法，完成这些初始化操作&lt;/span&gt;
        Process.&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)
        self.interval &lt;/span&gt;=&lt;span&gt; interval

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;重写了Process类的run()方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; run(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;子进程：%d,开始执行，父进程：%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
        t_start &lt;/span&gt;=&lt;span&gt; time.time()
        time.sleep(self.interval)
        t_stop &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;子进程：%d,执行结束，耗时%0.2f秒&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(os.getpid(),t_stop-&lt;span&gt;t_start))


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    t_start &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前进程是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())
    p1 &lt;/span&gt;= My_Process(3&lt;span&gt;)
    p1.start()
    p1.join()
    t_stop &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;当前进程%d执行结束，耗时：%0.2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(os.getpid(),t_stop-t_start))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;当前进程是9980
子进程：&lt;/span&gt;7084,开始执行，父进程：9980&lt;span&gt;
子进程：7084执行结束，耗时3.00秒
当前进程9980执行结束，耗时：&lt;/span&gt;3.23
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;六、进程池Pool&lt;/h3&gt;
&lt;p&gt;当需要创建的子进程数量不多时，可以直接利用multiprocessing中的Process动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到multiprocessing模块提供的Pool方法。&lt;/p&gt;
&lt;p&gt;初始化Pool时，可以指定一个最大进程数，当有新的请求提交到Pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pool
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; worker(msg):
    t_start &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d进程开始执行%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),msg))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;random.random()随机生成0~1之间的浮点数&lt;/span&gt;
    time.sleep(random.random()*2&lt;span&gt;) 
    t_stop &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(msg,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行完毕，耗时%0.2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(t_stop-&lt;span&gt;t_start))
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    po&lt;/span&gt;=Pool(3) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个进程池，最大进程数3&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0,10&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Pool.apply_async(要调用的目标,(传递给目标的参数元祖,))&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每次循环将会用空闲出来的子进程去调用目标&lt;/span&gt;
&lt;span&gt;        po.apply_async(worker,(i,))

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----start----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    po.close() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭进程池，关闭后po不再接收新的请求&lt;/span&gt;
    po.join() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待po中所有子进程执行完成，必须放在close语句之后&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----end-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
----start----&lt;span&gt;
4353进程开始执行0
4354进程开始执行1
4355进程开始执行2
&lt;/span&gt;2,执行完毕，耗时0.20&lt;span&gt;
4355进程开始执行3
&lt;/span&gt;1,执行完毕，耗时1.19&lt;span&gt;
4354进程开始执行4
&lt;/span&gt;4,执行完毕，耗时0.37&lt;span&gt;
4354进程开始执行5
0,执行完毕，耗时1.&lt;/span&gt;57&lt;span&gt;
4353进程开始执行6
&lt;/span&gt;5,执行完毕，耗时0.19&lt;span&gt;
4354进程开始执行7
&lt;/span&gt;3,执行完毕，耗时1.63&lt;span&gt;
4355进程开始执行8
&lt;/span&gt;6,执行完毕，耗时0.49&lt;span&gt;
4353进程开始执行9
&lt;/span&gt;8,执行完毕，耗时0.75
7,执行完毕，耗时0.90
9,执行完毕，耗时0.63
-----end-----
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;multiprocessing.Pool常用函数解析：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;apply_async(func[, args[, kwds]]) ：使用非阻塞方式调用func（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），args为传递给func的参数列表，kwds为传递给func的关键字参数列表；&lt;/li&gt;
&lt;li&gt;apply(func[, args[, kwds]])：使用阻塞方式调用func&lt;/li&gt;
&lt;li&gt;close()：关闭Pool，使其不再接受新的任务；&lt;/li&gt;
&lt;li&gt;terminate()：不管任务是否完成，立即终止；&lt;/li&gt;
&lt;li&gt;join()：主进程阻塞，等待子进程的退出， 必须在close或terminate之后使用；&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;apply堵塞式&quot;&gt;&lt;strong&gt;apply堵塞式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pool
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; worker(msg):
    t_start &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d进程开始执行%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),msg))
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;random.random()随机生成0~1之间的浮点数&lt;/span&gt;
    time.sleep(random.random()*2&lt;span&gt;) 
    t_stop &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(msg,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;执行完毕，耗时%0.2f&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%(t_stop-&lt;span&gt;t_start))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    po&lt;/span&gt;=Pool(3) &lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义一个进程池，最大进程数3&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0,10&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;Pool.apply_async(要调用的目标,(传递给目标的参数元祖,))&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;每次循环将会用空闲出来的子进程去调用目标&lt;/span&gt;
&lt;span&gt;        po.apply(worker,(i,))

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;----start----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    po.close() &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭进程池，关闭后po不再接收新的请求&lt;/span&gt;
    po.join() &lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待po中所有子进程执行完成，必须放在close语句之后&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-----end-----&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;4400进程开始执行0
0,执行完毕，耗时1.&lt;/span&gt;89&lt;span&gt;
4401进程开始执行1
&lt;/span&gt;1,执行完毕，耗时1.91&lt;span&gt;
4402进程开始执行2
&lt;/span&gt;2,执行完毕，耗时1.64&lt;span&gt;
4400进程开始执行3
&lt;/span&gt;3,执行完毕，耗时1.16&lt;span&gt;
4401进程开始执行4
&lt;/span&gt;4,执行完毕，耗时1.85&lt;span&gt;
4402进程开始执行5
&lt;/span&gt;5,执行完毕，耗时0.29&lt;span&gt;
4400进程开始执行6
&lt;/span&gt;6,执行完毕，耗时0.19&lt;span&gt;
4401进程开始执行7
&lt;/span&gt;7,执行完毕，耗时1.19&lt;span&gt;
4402进程开始执行8
&lt;/span&gt;8,执行完毕，耗时0.61&lt;span&gt;
4400进程开始执行9
&lt;/span&gt;9,执行完毕，耗时1.08
----start----
-----end-----
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：通过运行结果可以看出来，阻塞式会等进程池中的进程都执行完毕了才会运行主进程的start和end的打印&lt;/p&gt;
&lt;h3&gt;七、进程间的通信-Queue&lt;/h3&gt;
&lt;p id=&quot;1-queue的使用&quot;&gt;&lt;strong&gt;1. Queue的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以使用multiprocessing模块的Queue实现多进程之间的数据传递，Queue本身是一个消息列队程序，首先用一个小实例来演示一下Queue的工作原理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;-*- coding:utf-8 -*-&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Queue
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;创建一个Queue对象，最多可接受三条put消息&lt;/span&gt;
q = Queue(3&lt;span&gt;) 
q.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.full())
q.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(q.full())

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    q.put(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,True,2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; :
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息队列已满，现有消息数量：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;q.qsize())

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
    q.put_nowait(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; :
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息队列已满，现有消息数量：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;q.qsize())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;推荐方式，先判断消息队列是否已满，在写入&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; q.full():
    q.put_nowait(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;消息6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取消息时，先判断消息队列是否为空，在读取&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; q.empty():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(q.qsize()):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(q.get_nowait())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;False
True
消息队列已满，现有消息数量：&lt;/span&gt;3&lt;span&gt;
消息队列已满，现有消息数量：&lt;/span&gt;3&lt;span&gt;
消息1
消息2
消息3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id=&quot;说明&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;初始化Queue()对象时（例如：q=Queue()），若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量没有上限（直到内存的尽头）；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Queue.qsize()：返回当前队列包含的消息数量；&lt;/li&gt;
&lt;li&gt;Queue.empty()：如果队列为空，返回True，反之False ；&lt;/li&gt;
&lt;li&gt;Queue.full()：如果队列满了，返回True,反之False；&lt;/li&gt;
&lt;li&gt;Queue.get([block[, timeout]])：获取队列中的一条消息，然后将其从列队中移除，block默认值为True；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果为空，此时程序将被阻塞（停在读取状态），直到从消息列队读到消息为止，如果设置了timeout，则会等待timeout秒，若还没读取到任何消息，则抛出&quot;Queue.Empty&quot;异常；&lt;/p&gt;
&lt;p&gt;2）如果block值为False，消息列队如果为空，则会立刻抛出&quot;Queue.Empty&quot;异常；&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Queue.get_nowait()：相当Queue.get(False)；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Queue.put(item,[block[, timeout]])：将item消息写入队列，block默认值为True；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;1）如果block使用默认值，且没有设置timeout（单位秒），消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态），直到从消息列队腾出空间为止，如果设置了timeout，则会等待timeout秒，若还没空间，则抛出&quot;Queue.Full&quot;异常；&lt;/p&gt;
&lt;p&gt;2）如果block值为False，消息列队如果没有空间可写入，则会立刻抛出&quot;Queue.Full&quot;异常；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Queue.put_nowait(item)：相当Queue.put(item, False)；&lt;/li&gt;
&lt;/ul&gt;&lt;p id=&quot;2-queue实例&quot;&gt;&lt;strong&gt;2. Queue实例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Queue
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;写数据进程执行的代码&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; write(q):
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; value &lt;span&gt;in&lt;/span&gt; [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Put %s to Queue &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;value)
        q.put(value)
        time.sleep(random.random())
   
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;读取数据进程的代码   &lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; read(q):
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; q.empty():
            value &lt;/span&gt;=&lt;span&gt; q.get(True)
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get %s from Queue &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;value)
            time.sleep(random.random())
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;

&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;父进程创建Queue，并传递给各个子进程&lt;/span&gt;
    q =&lt;span&gt; Queue()
    pw &lt;/span&gt;= Process(target = write,args=&lt;span&gt;(q,))
    pr &lt;/span&gt;= Process(target = read,args=&lt;span&gt;(q,))

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动子进程pw，写入&lt;/span&gt;
&lt;span&gt;    pw.start()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;等待pw结束&lt;/span&gt;
&lt;span&gt;    pw.join()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;启动子进程pr，读取&lt;/span&gt;
&lt;span&gt;    pr.start()
    pr.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;所有数据都写入并且读完&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Put A to Queue 
Put B to Queue 
Put C to Queue 
Get A &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; Queue 
Get B &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; Queue 
Get C &lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; Queue 
所有数据都写入并且读完&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p id=&quot;3-进程池中的queue&quot;&gt;&lt;strong&gt;3. 进程池中的Queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要使用Pool创建进程，就需要使用multiprocessing.Manager()中的Queue()，而不是multiprocessing.Queue()，否则会得到一条如下的错误信息：&lt;/p&gt;
&lt;p&gt;RuntimeError: Queue objects should only be shared between processes through inheritance.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;coding=utf-8&lt;/span&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Manager
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Pool
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; reader(q):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reader启动(%d),父进程为(%d)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(q.qsize()):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reader从Queue获取到的消息时：%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;q.get(True))

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; writer(q):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;writer启动(%d),父进程为(%d)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;(os.getpid(),os.getppid()))
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Se7eN_HOU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
        q.put(i)

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;-------&lt;/span&gt;&lt;span&gt;(%d) Start-------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%&lt;span&gt;os.getpid())
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用Manager中的Queue来初始化&lt;/span&gt;
    q =&lt;span&gt; Manager().Queue()
    po &lt;/span&gt;=&lt;span&gt; Pool()
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;使用阻塞模式创建进程，这样就不需要在reader中使用死循环了，可以让writer完全执行完成后，再用reader去读取&lt;/span&gt;
&lt;span&gt;    po.apply(writer,(q,))
    po.apply(reader,(q,))

    po.close()
    po.join()

    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-------(%d) End-------&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;%os.getpid())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
-------(880) Start-------&lt;span&gt;
writer启动(&lt;/span&gt;7744),父进程为(880&lt;span&gt;)
reader启动(&lt;/span&gt;7936),父进程为(880&lt;span&gt;)
reader从Queue获取到的消息时：S
reader从Queue获取到的消息时：e
reader从Queue获取到的消息时：&lt;/span&gt;7&lt;span&gt;
reader从Queue获取到的消息时：e
reader从Queue获取到的消息时：N
reader从Queue获取到的消息时：_
reader从Queue获取到的消息时：H
reader从Queue获取到的消息时：O
reader从Queue获取到的消息时：U
&lt;/span&gt;-------(880) End-------
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 18 Apr 2019 17:01:00 +0000</pubDate>
<dc:creator>Se7eN_HOU</dc:creator>
<og:description>一、什么是进程 进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Se7eN-HOU/p/10733583.html</dc:identifier>
</item>
<item>
<title>中国.NET：各地微软技术俱乐部汇总(持续更新中...) - Enjoy233</title>
<link>http://www.cnblogs.com/enjoy233/p/China_dotNetClub_list.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoy233/p/China_dotNetClub_list.html</guid>
<description>&lt;div id=&quot;img-content&quot; readability=&quot;21.271676300578&quot;&gt;
&lt;p id=&quot;activity-name&quot; class=&quot;rich_media_title&quot;&gt;&lt;strong&gt;&lt;span&gt;中国.NET：各地微软技术俱乐部汇总(持续更新中...)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;



&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418131104214-1552865100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;div id=&quot;js_content&quot; class=&quot;rich_media_content&quot; readability=&quot;35&quot;&gt;  &lt;em&gt; &lt;/em&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;i&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;
&lt;p&gt;&lt;span&gt;成功的故事荡气回肠，失败的故事千回百转，但是你不去追求与偿试，你永完不会知道成功的原因失败的原因是什么，人生一辈子也就三万天，如果每天糊里糊涂的过去了，若干年后要连故事都没得讲。如果你还是孤单的程序狗，那么加入中国.NET俱乐部这个大家庭，我们一起书写最精彩的故事。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/div&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;★早期三俱★&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418131127523-1131151469.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;与微软技术的发展历程相似，微软俱乐部的发展同样经历着沉沉浮浮。2002年周庆麒先生创办的著名Office技术论坛Excel Home的上线，各种线上技术社区在中国的互联网世界中萌发。接着以&lt;strong&gt;鞠海洋（广州.NET，2004）、刘辉(厦门.NET，2004)、张善友(深圳.NET，2005)为代表的第一批先行者&lt;/strong&gt;，建立了中国最早的一批微软城市俱乐部。此后微软城市俱乐部如雨后春笋般地在全国各地建立起来。相传国内最著名的.NET技术社区“博客园”便是因为这些俱乐部的参与而壮大起来了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418131840855-1700676219.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;9&quot;&gt;★ 传承有序 ★&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;曾经是固执和封闭的微软一度失去了领导地位，相应全国的俱乐部在互联网的大潮下日渐消亡。曾经的广州.NET俱乐部在第一任主席鞠海洋、和第二任主席彭斌，便后继无人。社区的沉默是可怕的，很多社区沉寂消亡。&lt;strong&gt;但在2018年，一个开放与包容的微软回来了，广州.NET俱乐部在叶伟民先生带领下重现辉煌。&lt;/strong&gt;2018年10月25日微软在上海世博举办了10年来规模最大的技术盛会，微软重新回到了世界技术舞台的中央，在.net core等一大批新技术的带动下，越来越多的俱乐部正在重建、成立。&lt;strong&gt;2019年广州把俱乐部的火炬传到了苏州。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418131905046-1887679069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;8&quot;&gt;★ 苏州.NET ★&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;苏州.NET微软技术俱乐部，是由苏州各届微软技术爱好者及发烧友自发形成的民间组织。在这里大家关注微软的前沿技术，探讨交流各种技术问题，会员充分表达自己的思想。苏州.俱乐部是一个成长性组织，一个能让我们学习、成长的平台，是一个属于程序员自己的大家庭。&lt;strong&gt;还没加入苏州.NET俱乐部的微软及编程技术的苏州爱好者们，赶快参与到我们的活动中来吧。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;QQ&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;群：953297025&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;联系人：王飞&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;苏州，&lt;strong&gt;王&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;飞&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，苏州.NET俱乐部秘书长&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;苏州协昌环保科技股份有限公司信息化负责人，物联网专家，有十年以上物联网方向工作经验，目前致力于工业环保云开发建设。&lt;/span&gt;&lt;/p&gt;


&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418131925578-693643523.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;★ 广州.NET ★&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;随着微软走向封闭与固执，.NET社区年轻一代的声音被忽略，.NET社区后继无人。如此正规且强大的厦门.NET俱乐部，还是被我们刘主席弄丢了，广州.NET俱乐部同样好不到哪去，他们是难兄难弟见真情。或许是刘主席往事不堪提起，所以真正的原因我还是不得而知。但好在广州.NET俱乐部被叶伟民主席重捡拾了回来。现任的叶主席提出了复活广州.NET俱乐部的设想，大家都很赞同，并提出了不少意见，于是决定复活了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;QQ&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;群：651477282&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;联系人：叶伟民&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;广州，&lt;strong&gt;叶伟民&lt;/strong&gt;，广州.NET俱乐部主席&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;硅谷海归, 硅谷中国工程师协会会员, 青年海归协会会。2002年开始写.NET程序，JAVA和C#双料程序员。目前致力于复活广州.NET俱乐部。爱好: 开飞机, 狙击枪实弹射击。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418131940714-2064440954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; &lt;span&gt;&lt;strong&gt;★ 厦门.NET ★&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;厦门.NET成立于2004年，在广州的俱乐部的帮助下开始正规化了，财务，外联，讲师啥的都有了，然后主席也有了。到了2005年微软开始介入，2006年给予厦门俱乐部授版，授权LOGO使用，授权函也有。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;QQ&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;群：57043161&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;联系人：刘辉&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;厦门，&lt;strong&gt;刘&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;辉&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，厦门.NET俱乐部主席&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微软资深讲师，从事高性能网站的架构设计，开发和管理工作。精通微软的Web开发领域，对SQL、Ajax、Linq、MVC、Silverlight、Entity Framework有很深入的研究，擅长建立企业级应用框架。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418132031607-1810653954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;★ 深圳.NET ★&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;唯一从始至终经历15年风风雨雨一直走到今天，从2005年开办至今从未中断运营的，便是张善友先生管理的深圳.NET俱乐部。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;张善友毕业于兰州大学数学系，2006年开始连任微软最有价值专家（MVP）至今，他维护运营的公众号“&lt;strong&gt;dotnet跨平台&lt;/strong&gt;” ，汇聚了超过4万的.NET粉丝&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;QQ&lt;/span&gt;&lt;/strong&gt; &lt;strong&gt;&lt;span&gt;群：12439862&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;联系人：张善友&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;深圳，&lt;strong&gt;张善友&lt;/strong&gt;，深圳.NET俱乐部主席&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;深圳.NET俱乐部主席,深圳友浩达科技创始人，微软最有价值专家（MVP，连续13年），曾在腾讯负责研发工作10多年，2018年开始独立创业，从事.NET技术顾问工作。拥有超过17年IT行业经验，运营微信公众号&quot;dotnet跨平台&quot;,热心于进行社区奉献，同时积极参与.NET社区开源项目，被尊称为张队长。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418132048553-745710935.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;★ 西安.NET ★&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;微软技术俱乐部，是由全国各地微软技术爱好者及发烧友自发形成的民间组织。在这里大家关注微软的前沿技术，探讨交流各种技术问题，会员充分表达自己的思想。这是一个成长性组织，一个能让我们学习、成长的平台，是一个属于程序员自己的大家庭，赶快加入吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;QQ&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;群：140775976&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;联系人：王健&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;西安，&lt;strong&gt;王&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;  &lt;/strong&gt;&lt;strong&gt;&lt;span&gt;健&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，西安.NET俱乐部执行秘书&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Thoughtworks&lt;/span&gt; &lt;span&gt;软件工程师，.NET西安社区联系人，有着多年电商行业从业经验，热衷于研究学习优秀的开源项目，目前致力于.NET Core项目的微服务实践。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418132117147-1027989345.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;★ 成都.NET ★&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;微软技术俱乐部，是由全国各地微软技术爱好者及发烧友自发形成的民间组织。在这里大家关注微软的前沿技术，探讨交流各种技术问题，会员充分表达自己的思想。这是一个成长性组织，一个能让我们学习、成长的平台，是一个属于程序员自己的大家庭，赶快加入吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;QQ&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;群：314678764&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;联系人：梁桐铭&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;成都，&lt;strong&gt;梁桐铭&lt;/strong&gt;，成都.NET俱乐部主席&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微软最有价值专家（MVP），Microsoft AI Open Hack 教练，Microsoft Tech Summit 2018 讲师。6年以上开发经验，2年团队管理经验，熟悉互联网及电商行业。15年开始在国内的开源社区中进行推广ASP.NETBoilerplate Project开源框架。负责过多个大型项目的开发和管理，擅长应用系统项目规划设计、及企业解决方案的设计。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418132149739-1335761720.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;★ 福州.NET ★&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;微软技术俱乐部，是由全国各地微软技术爱好者及发烧友自发形成的民间组织。在这里大家关注微软的前沿技术，探讨交流各种技术问题，会员充分表达自己的思想。这是一个成长性组织，一个能让我们学习、成长的平台，是一个属于程序员自己的大家庭，赶快加入吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;QQ&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;群：710090446&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;联系人：郭联钰&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;福州，&lt;strong&gt;郭联钰&lt;/strong&gt;，福州.NET俱乐部主席&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;擅长.NET Core微服务框架开发以及容器的运用，热衷开源技术和技术分享，负责多个项目的实际落地；常在博客园(LouieGuo)及微信公众号(open-sources)发布技术文章。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418132231717-1389226343.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;★ 宁波.NET ★&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;微软技术俱乐部，是由全国各地微软技术爱好者及发烧友自发形成的民间组织。在这里大家关注微软的前沿技术，探讨交流各种技术问题，会员充分表达自己的思想。这是一个成长性组织，一个能让我们学习、成长的平台，是一个属于程序员自己的大家庭，赶快加入吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;QQ&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;群：134117404&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;联系人：王伯承&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;宁波，&lt;strong&gt;王伯承&lt;/strong&gt;，宁波.NET俱乐部主席&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从2010年开始，多年dotnet开发经验。2015年开始接触ABP框架，活跃于国内ABP社区，根据实际经验开源了abplus项目（ABP框架扩展库）2018年在宁波组织本地dotnet社区，推广dotnet core及ABP开发框架推崇领域驱动设计、敏捷实践和用户故事地图。&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190418132252467-760953386.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;★ 中国.NET ★&lt;/strong&gt;&lt;/h2&gt;
&lt;div readability=&quot;133.40009948599&quot;&gt;
&lt;p&gt;&lt;span&gt;微软技术俱乐部，是由全国各地微软技术爱好者及发烧友自发形成的民间组织。在这里大家关注微软的前沿技术，探讨交流各种技术问题，会员充分表达自己的思想。这是一个成长性组织，一个能让我们学习、成长的平台，是一个属于程序员自己的大家庭，赶快加入吧。&lt;span&gt;以下是部分俱乐联系方式，请对号入坐！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;&lt;span&gt;== 筹备 ==&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【长沙.NET俱乐部】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QQ群：44329330&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;联系人：邹溪源&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;湖南拜伦网络高级.NET工程师，资深IT行业从业者。曾任企业级IT架构师、技术负责人，目前致力于IT金融服务场景下的互联网实践过程。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;【南京.NET俱乐部】&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;QQ群：575512408&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;联系人：张柔&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;初码科技创始人，初级架构师，高级程序员，云服务专家，资深软件外包从业者，致力于推动高效技术学习实践与项目实施。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;&lt;span&gt;【杭州.NET俱乐部】&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QQ群：385255797&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;联系人：汪恺&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同花顺远航版智能投资负责人、架构师，同花顺技术委员会常务委员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;【徐州.NET俱乐部】&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QQ群：558482893&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;联系人：迟明秋&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;微软认证解决方案专员（MCSA）。10年以上开发经验，2年团队管理经验，熟悉互联网及电商行业,现在在医疗信息化领域工作。&lt;/span&gt;&lt;span&gt;参与过多个新西兰大型项目的开发和管理，擅长应用系统项目规划设计、及企业解决方案的设计。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;== 计划成立 ==&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;【佛山.NET俱乐部】&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;QQ群：470085911&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;联系人：李福森，anglfs520&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从&lt;/span&gt;12－19年一直致力于量子力学与软件技术结合开发，对于office和MATLAB十分熟悉，一直在以创业者身份用商业布局的战略眼光将新一代ICT产业推向到另一个时空之门,希望能将微软.net技术发扬光大。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;strong&gt;【珠海.NET俱乐部】&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;QQ群：794691385&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;联系人：周泽安，woshidaan9528&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;口袋动画、口袋学院创始人，插件注册用户已超过百万，前&lt;/span&gt;WPS Office演示动画引擎开发工程师，现金山WPS高级产品经理、项目负责人。曾担任全国大学教师职业讲师、微课大赛培训、通用和移动等企业技能内训的讲师，也曾为上海通用、中国移动、航天科技等企业完成幻灯片设计。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;【东莞.NET俱乐部】&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;QQ群：582144931&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;联系人：李伟坚，liweijian08&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Excel催化剂插件作者，运营Excel催化剂公众号，目前为自由职业者。擅长使用Excel+Sqlserver+PowerBI搭建一套轻量化的数据应用解决方案，满足广大中小企业对数据分析的紧迫需求。个人技术领域：Excel等Office家族软件、VBA&amp;amp;VSTO的二次开发、Sqlserver数据库技术、Sqlserver的商业智能BI技术、Powerbi技术、云服务器布署技术等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;【武汉.NET俱乐部】&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;QQ群：286874323&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;联系人：王杰，jiejie964&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;从&lt;/span&gt;09年至今一直从事国际物流企业ERP软件开发，主要擅长EDI 系统对接整合，对ASNI X12, EDIFACT , CargoImp 标准非常熟悉，近年来SAAS 模式席卷企业软件，我们也一直探索SAAS 模式在国际物流软件领域的实践，因此对ABP，Orchard 等.NET 优秀框架研究必不可少。希望有机会把这些经验，分享给需要的同学。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;【合肥.NET俱乐部】&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QQ群：424157108&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;联系人：祝雷，&lt;/span&gt;jkingzhu&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;博客园知名博主&lt;/span&gt;(依乐祝)。6年以上.NET技术栈的开发工作，3年团队管理经验，从去年开始进行.NET Core技术栈的研究，目前发表了：《Ocelot简易教程》，《.NET Core实战项目之CMS 教程》 等系列实战教程并参与了《.NET Core项目实战-统一认证平台》系列教程的编写工作。热衷于研究学习优秀的开源项目如：Ocelot,IdentityServer4等,能够进行相关.NET Core微服务技术栈的落地。目前专注于.NET Core+Linux+Docker+K8S技术栈方向的研究，并运营“DotNetCore实战”公众号。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;【沈阳.NET俱乐部】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QQ群：679654405&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;联系人：何庆欢，&lt;/span&gt;h5300258&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;毕业四年从事水利信息化软件应用开发，对水利、防汛、水库等业务有了解。目前打算使用&lt;/span&gt;.net core 做lims系统以及配套相关系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;【威海.NET俱乐部】&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QQ群：4658233&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;联系人：王明飞，&lt;/span&gt;youmingshenhua&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;07年开始学习.Net，08年从事于北京铁血军事论坛。回山东与朋友合伙成立山东迅思信息技术有限公司，担任技术总监。现主要与浪潮和银联做市场追溯交易平台。三方交互均采用C#开发。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;&lt;span&gt;【济南.NET俱乐部】&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;QQ群：456378675&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;联系人&lt;/span&gt;1：韩聪，congcongsky&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;山东资略信息技术有限公司技术总监&lt;/span&gt;/联合创始人，负责公司互联网产品和SaaS平台的技术架构和管理工作。希望借助.Net Core的发展给.Net技术推广贡献一份力量。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;联系人&lt;/span&gt;2：十方，loundar&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;某国企科技公司&lt;/span&gt;CIO，全栈研发工程师，多年架构经验，10年以上软件开发经历，在电商、网络编程、分布式、资源数字化上有深入研究。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;== 大型城市 ==&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;【上海.NET俱乐部】&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;QQ群：197239851&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 俱 &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;【城市列表】&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、公众号回复：jlb，提示最新的俱乐部信息&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、如果有缺漏俱乐部，请留言补充&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、您有计划帮助当地成，请直接留言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201904/436938-20190419072057854-1059354859.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;----------  最新列表 ----------&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;【苏州.NET】QQ群：953297025&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【广州.NET】QQ群：651477282&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【厦门.NET】QQ群：57043161&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【深圳.NET】QQ群：12439862&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【成都.NET】QQ群：314678764&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【西安.NET】QQ群：140775976&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【福州.NET】QQ群：710090446&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【宁波.NET】QQ群：134117404&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;【长沙.NET】QQ群：44329330&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【南京.NET】QQ群：575512408&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【杭州.NET】QQ群：385255797&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【徐州.NET】QQ群：558482893&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;【佛山.NET】QQ群：470085911&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【珠海.NET】QQ群：794691385&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【东莞.NET】QQ群：582144931&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【武汉.NET】QQ群：286874323&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【合肥.NET】QQ群：424157108&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【沈阳.NET】QQ群：679654405&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【威海.NET】QQ群：4658233&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;【济南.NET】QQ群：456378675&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;【上海.NET】QQ群：197239851&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;
&lt;h2 class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;f22na-0-0&quot;&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;f22na-0-0&quot;&gt;相关链接：&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;
&lt;/p&gt;



&lt;/div&gt;
</description>
<pubDate>Thu, 18 Apr 2019 16:28:00 +0000</pubDate>
<dc:creator>Enjoy233</dc:creator>
<og:description>中国.NET：各地微软技术俱乐部汇总(持续更新中...) 本文是转载文，源地址: https://www.cnblogs.com/panchun/p/JLBList.html by</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoy233/p/China_dotNetClub_list.html</dc:identifier>
</item>
<item>
<title>[开源]WinForm 控件使用总结 - MeetYan</title>
<link>http://www.cnblogs.com/MeetYan/p/10733520.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MeetYan/p/10733520.html</guid>
<description>&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot; readability=&quot;3.8345105953582&quot;&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;都2019年了，还在用WinForm吗？哈哈，其实我也没在用，都是很多年前一些项目积累，所以代码写的有些屎，之所以开源出来，希望能给大家有所帮助，喜欢的话给 一个Star以资鼓励~；&lt;/li&gt;
&lt;li&gt;具体代码：&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief&quot;&gt;MasterChief&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;欢迎Star，欢迎Issues；&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;控件列表&quot;&gt;控件列表&lt;/h2&gt;
&lt;p&gt;由于比较多，所以这里贴出目录，具体源码就不贴出来，您可以点击链接查看；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/ApplicationHelper.cs&quot;&gt;设置程序唯一实例运行，捕获异常，捕获退出，获取exe执行文件夹路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/BindingHelper.cs&quot;&gt;创建用户控件/控件双向绑定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/CheckBoxHelper.cs&quot;&gt;CheckBox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/CheckedListBoxHelper.cs&quot;&gt;CheckedList&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/ColorConsole.cs&quot;&gt;彩色控制台输出&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/ComboBoxHelper.cs&quot;&gt;ComboBox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/DataGridHelper.cs&quot;&gt;DataGridView&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/FormHelper.cs&quot;&gt;弹出模式对话框，设置应用登陆界面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/LanguageHelper.cs&quot;&gt;WinForm语言国际化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/ListBoxHelper.cs&quot;&gt;ListBox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/MdiFormHelper.cs&quot;&gt;MDI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/MenuStripHelper.cs&quot;&gt;MenuStrip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/MessageBoxHelper.cs&quot;&gt;MessageBox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/NotepadHelper.cs&quot;&gt;打开记事本，并往记事本写入内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/NumericUpDownHelper.cs&quot;&gt;NumericUpDown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/OpenFileDialogHelper.cs&quot;&gt;OpenFileDialog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/OpenFolderDialogHelper.cs&quot;&gt;OpenFolderDialog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/ProgressBarHelper.cs&quot;&gt;ProgressBar&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/RichTextBoxHelper.cs&quot;&gt;RichTextBox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/TabControlHelper.cs&quot;&gt;TabControl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/TabPageHelper.cs&quot;&gt;TabPage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/TextBoxHelper.cs&quot;&gt;TextBox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/TooltipHelper.cs&quot;&gt;Tooltip&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/TreeViewHelper.cs&quot;&gt;TreeView&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/TreeViewSerializer.cs&quot;&gt;TreeView 序列化与反序列化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/UIHelper.cs&quot;&gt;处理控件线程安全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/YanZhiwei/MasterChief/blob/master/MasterChief.DotNet4.Utilities/WinForm/WebBrowserHelper.cs&quot;&gt;WebBrowser&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;小弟不才，大佬轻拍；&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;


&lt;div id=&quot;blog_post_info_block&quot;&gt;





&lt;/div&gt;
</description>
<pubDate>Thu, 18 Apr 2019 16:26:00 +0000</pubDate>
<dc:creator>MeetYan</dc:creator>
<og:description>背景 1. 都2019年了，还在用WinForm吗？哈哈，其实我也没在用，都是很多年前一些项目积累，所以代码写的有些屎，之所以开源出来，希望能给大家有所帮助，喜欢的话给 一个Star以资鼓励~； 2.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MeetYan/p/10733520.html</dc:identifier>
</item>
<item>
<title>U盘重装系统方法及常见问题 -赖大大 -博客园 - 赖大大</title>
<link>http://www.cnblogs.com/lyc642983907/p/10733521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lyc642983907/p/10733521.html</guid>
<description>&lt;h2&gt;准备工作：&lt;/h2&gt;
&lt;p&gt;1.下载UltraISO软件安装，把系统iso文件刻录进U盘&lt;/p&gt;
&lt;p&gt;2.下载你想要的系统iso镜像文件&lt;/p&gt;
&lt;p&gt;去MSDN：&lt;a href=&quot;https://msdn.itellyou.cn/&quot;&gt;https://msdn.itellyou.cn/&lt;/a&gt;下载你想要的系统iso镜像文件&lt;/p&gt;
&lt;p&gt;（MSDN是一个很良心的网站，里面的系统是纯净的）&lt;/p&gt;
&lt;h2&gt;1.制作系统U盘&lt;/h2&gt;
&lt;p&gt;去UltraISO官网&lt;a href=&quot;https://cn.ultraiso.net/xiazai.html&quot;&gt;https://cn.ultraiso.net/xiazai.html&lt;/a&gt;下载安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590884/201904/1590884-20190418234906972-398377466.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开UltraISO,记住，一定要用管理员的身份打开，否则没办法刻录（右击以管理员身份运行）&lt;/p&gt;
&lt;p&gt;点击试用进入就好&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件-&amp;gt;打开-&amp;gt;选中你刚刚下载好的iso文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590884/201904/1590884-20190418235714530-503764689.png&quot; alt=&quot;&quot; width=&quot;574&quot; height=&quot;197&quot;/&gt;&lt;/p&gt;
&lt;p&gt;插入你的U盘（记住把U盘的东西备份好，刻录会把u盘的东西清空的）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点击   启动-&amp;gt;写入硬盘映像&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1590884/201904/1590884-20190419000026646-1989821524.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬盘驱动器就是你的U盘，写入方式 USB-HDD+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;没什么问题就点击写入&lt;/p&gt;
&lt;p&gt;完成后，关闭重启就好。&lt;/p&gt;
&lt;h2&gt;2.重装系统&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;在电脑开机屏幕亮的第一个画面，一般狂按F1或F2,如果不行，请自行上网百度，&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电脑不同是没办法确定的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选好要安装的系统盘，下一步，就好了！&lt;/p&gt;

&lt;p&gt;一直下去很顺利，那就没问题，但事实往往没有那么简单&lt;/p&gt;
&lt;p&gt;系统安装出现无法新建分区也找不到现有的分区的情况，没办法点击下一步&lt;/p&gt;
&lt;p&gt;（原因是系统盘是MBR格式，我们需要把他转为GPT格式）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在那界面按Shift + F10进入命令提示符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;diskpart &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;list disk (列出系统盘)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;select disk 0 （选中第一个系统盘，可以自行选择，例如： disk 1）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;clean（清空盘）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;convert GPT（把MBR转为GPT格式）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;完成，现在就可以点击下一步了 &lt;/p&gt;
&lt;p&gt;以上是我在重装系统常见的问题&lt;/p&gt;
&lt;h2&gt; &lt;strong&gt;数据无价，重装需谨慎！！！！！&lt;/strong&gt;&lt;/h2&gt;
</description>
<pubDate>Thu, 18 Apr 2019 16:26:00 +0000</pubDate>
<dc:creator>赖大大</dc:creator>
<og:description>U盘重装系统及常见问题 准备工作： 1.下载UltraISO软件安装，把系统iso文件刻录进U盘 2.下载你想要的系统iso镜像文件 去MSDN：https://msdn.itellyou.cn/下载</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lyc642983907/p/10733521.html</dc:identifier>
</item>
<item>
<title>理解 Node.js 的 Event loop - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/understanding_event_loop.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/understanding_event_loop.html</guid>
<description>
&lt;h2&gt;问题&lt;/h2&gt;
&lt;p&gt;考察如下代码，脑回路中运行并输出结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-js&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;1&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);

&lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;setTimeout1&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;2&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;nextTick&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;nextTick1&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;3&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });
  &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promise1&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;resolve&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;4&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;();
  }).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promiseThen1&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;5&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });
  &lt;span class=&quot;pl-en&quot;&gt;setImmediate&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;immediate1&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;immediate&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });
});

&lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;nextTick&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;nextTick2&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;6&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
});

&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;bar&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;bar&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
}

&lt;span class=&quot;pl-k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;async start&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;bar&lt;/span&gt;();
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;async end&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
}

&lt;span class=&quot;pl-en&quot;&gt;foo&lt;/span&gt;();

&lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promise2&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;resolve&lt;/span&gt;) {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;7&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;();
}).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promiseThen2&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;8&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
});

&lt;span class=&quot;pl-c1&quot;&gt;setTimeout&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;setTimeout2&lt;/span&gt;() {
  &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;9&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  
  &lt;span class=&quot;pl-k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;Promise&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promise3&lt;/span&gt;(&lt;span class=&quot;pl-smi&quot;&gt;resolve&lt;/span&gt;) {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;11&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
    &lt;span class=&quot;pl-en&quot;&gt;resolve&lt;/span&gt;();
  }).&lt;span class=&quot;pl-c1&quot;&gt;then&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;promiseThen3&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;12&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });

  &lt;span class=&quot;pl-c1&quot;&gt;process&lt;/span&gt;.&lt;span class=&quot;pl-en&quot;&gt;nextTick&lt;/span&gt;(&lt;span class=&quot;pl-k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;pl-en&quot;&gt;nextTick3&lt;/span&gt;() {
    &lt;span class=&quot;pl-en&quot;&gt;console&lt;/span&gt;.&lt;span class=&quot;pl-c1&quot;&gt;log&lt;/span&gt;(&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;10&lt;span class=&quot;pl-pds&quot;&gt;&quot;&lt;/span&gt;&lt;/span&gt;);
  });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;JS 事件循环&lt;/h2&gt;
&lt;p&gt;JS 是单线程，朴素地讲，同时只能完成一件事件。如果有耗时的任务，那后续的所有任务都要等待其完成才能执行。&lt;/p&gt;
&lt;p&gt;为了避免这种阻塞，引入了事件循环。即，将代码的执行分成一个个很小的阶段（一次循环），每个阶段重复相应的事情，直到所有任务都完成。&lt;/p&gt;
&lt;p&gt;一个阶段包含以下部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Timers：到期的定时器任务，&lt;code&gt;setTimeout&lt;/code&gt;，&lt;code&gt;setInterval&lt;/code&gt; 等注册的任务。&lt;/li&gt;
&lt;li&gt;IO Callbacks：IO 操作，比如网络请求，文件读写。&lt;/li&gt;
&lt;li&gt;IO Polling：IO 任务的注册&lt;/li&gt;
&lt;li&gt;Set Immediate：通过 &lt;code&gt;setImmediate&lt;/code&gt; 注册的任务&lt;/li&gt;
&lt;li&gt;Close：&lt;code&gt;close&lt;/code&gt; 事件的回调，比如 TCP 的断开。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/51124121-80498000-1858-11e9-8c69-33c760b08904.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/51124121-80498000-1858-11e9-8c69-33c760b08904.png&quot; alt=&quot;image&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;Ticks and Phases of the Node.js Event Loop &lt;em&gt;图片来自 Daniel Khan 的 Medium 博客，见文末&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;同步代码及上面每个环节结束时都会清空一遍微任务队列，记住这点很重要！&lt;/p&gt;
&lt;h2&gt;代码执行流程&lt;/h2&gt;
&lt;p&gt;执行的流程是，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将代码顺序执行。&lt;/li&gt;
&lt;li&gt;遇到异步任务，将任务压入待执行队列后继续往下。&lt;/li&gt;
&lt;li&gt;完成同步代码后，检查是否有微任务（通过 &lt;code&gt;Promise&lt;/code&gt;，&lt;code&gt;process.nextTick&lt;/code&gt;，&lt;code&gt;async/await&lt;/code&gt; 等注册），如果有，则清空。&lt;/li&gt;
&lt;li&gt;清空微任务队列后，从待执行队列中取出最先压入的任务顺序执行，重复步骤一。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;另，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;async/await&lt;/code&gt; 本质上是 &lt;code&gt;Promise&lt;/code&gt;，所以其表现会和 Promise 一致。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;process.nextTick&lt;/code&gt; 注册的回调优先级高于定时器。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;setImmediate&lt;/code&gt; 可看成 Node 版本的 &lt;code&gt;setTimeout&lt;/code&gt;，所以可与后者同等对待。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;示例代码分析&lt;/h2&gt;
&lt;h3&gt;Round 1&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先遇到同步代码 &lt;code&gt;console.log(1)&lt;/code&gt;，立即执行输出 &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;接下来是一个 &lt;code&gt;setTimeout&lt;/code&gt; 定时器，将其回调压入待执行队列 &lt;code&gt;[setTimeout1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;process.nextTick&lt;/code&gt;，将其回调 &lt;code&gt;nextTick2&lt;/code&gt; 压入微任务队列 &lt;code&gt;[nextTick2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后是 async 函数 &lt;code&gt;foo&lt;/code&gt; 的调用，立即执行并输出 &lt;code&gt;async start&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后是 &lt;code&gt;await&lt;/code&gt; 语句，这所在的地方会创建并返回 Promise，所以这里会执行其后面的表达式，也就是 &lt;code&gt;bar()&lt;/code&gt; 函数的调用。&lt;/li&gt;
&lt;li&gt;执行 &lt;code&gt;bar&lt;/code&gt; 函数，输出 &lt;code&gt;bar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在执行了 &lt;code&gt;await&lt;/code&gt; 后面的语句后，它所代表的 Promise 就创建完成了，&lt;code&gt;foo&lt;/code&gt; 函数体后续的代码相当于 promise 的 &lt;code&gt;then&lt;/code&gt;，放入微任务队列 &lt;code&gt;[nextTick2, rest_of_foo]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;继续往下遇到 &lt;code&gt;new Promise&lt;/code&gt;，执行 Promise 的创建输出 &lt;code&gt;7&lt;/code&gt;，将它的 &lt;code&gt;then&lt;/code&gt; 回调压入微任务队列 &lt;code&gt;[nextTick2, rest_of_foo,promiseThen2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到另一个 &lt;code&gt;setTimeout&lt;/code&gt;，回调压入待执行队列 &lt;code&gt;[setTimeout1，setTimeout2]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;至此，代码执行完了一轮。此时的输出应该是 &lt;code&gt;1, async start, bar,7&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 2&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查看微任务队列，并清空。所以依次执行 &lt;code&gt;[nextTick2, rest_of_foo,promiseThen2]&lt;/code&gt;，输出 &lt;code&gt;6,async end,8&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 3&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;查看待执行队列 &lt;code&gt;[setTimeout1，setTimeout2]&lt;/code&gt;，先执行 &lt;code&gt;setTimout1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;console.log(2)&lt;/code&gt; 输出2&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;process.nextTick&lt;/code&gt; 将 &lt;code&gt;nextTick1&lt;/code&gt; 压入微任务队列 &lt;code&gt;[nextTick1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;new Promise&lt;/code&gt; 立即执行 输出 &lt;code&gt;4&lt;/code&gt;，执行 &lt;code&gt;resolve()&lt;/code&gt; 后将 &lt;code&gt;promiseThen1&lt;/code&gt; 压入微任务队列 &lt;code&gt;[nextTick1,promiseThen1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;setImmediate&lt;/code&gt; 将回调压入待执行队列 &lt;code&gt;[setTimeout2,immediate1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此时 &lt;code&gt;setTimeout1&lt;/code&gt; 执行完毕，此时的输出应该为 &lt;code&gt;2,4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 4&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;检查微任务队列 &lt;code&gt;[nextTick1,promiseThen1]&lt;/code&gt; 依次执行并输出 &lt;code&gt;3,5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 5&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;检查待执行队列 &lt;code&gt;[setTimeout2,immediate1]&lt;/code&gt;,执行 &lt;code&gt;setTimeout2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;console&lt;/code&gt;输出 &lt;code&gt;9&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;new Promise&lt;/code&gt; 执行并输出 &lt;code&gt;11&lt;/code&gt;,将 &lt;code&gt;promiseThen3&lt;/code&gt; 压入微任务队列 &lt;code&gt;[promiseThen3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;遇到 &lt;code&gt;process.nextTick&lt;/code&gt; 将 &lt;code&gt;nextTick3&lt;/code&gt; 压入微执行队列。注意，因为 &lt;code&gt;process.nextTick&lt;/code&gt; 的优化级高于 Promise，所以压入后的结果是： &lt;code&gt;[nextTick3,promiseThen3]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;此时 &lt;code&gt;setTimeout2&lt;/code&gt; 执行完毕，输出为 &lt;code&gt;9,11&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 6&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;检查微任务队列 &lt;code&gt;[nextTick3，promiseThen3]&lt;/code&gt; 执行并输出 &lt;code&gt;10,12&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Round 7&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;检查待执行队列 &lt;code&gt;[immediate1]&lt;/code&gt;，执行并输出 &lt;code&gt;immediate&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;至此，走完了所有代码。&lt;/p&gt;
&lt;h2&gt;结果&lt;/h2&gt;
&lt;p&gt;以下是文章开头的结果：&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
1
async start
bar
7
6
async end
8
2
4
3
5
9
11
10
12
immediate
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;参考&lt;/h3&gt;
</description>
<pubDate>Thu, 18 Apr 2019 15:33:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>问题 考察如下代码，脑回路中运行并输出结果： console.log('1'); setTimeout(function setTimeout1() { console.log('2'); proce</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/understanding_event_loop.html</dc:identifier>
</item>
<item>
<title>死磕 java集合之ConcurrentSkipListSet源码分析——Set大汇总 - 彤哥读源码</title>
<link>http://www.cnblogs.com/tong-yuan/p/ConcurrentSkipListSet.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tong-yuan/p/ConcurrentSkipListSet.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;（1）ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？&lt;/p&gt;
&lt;p&gt;（2）ConcurrentSkipListSet是线程安全的吗？&lt;/p&gt;
&lt;p&gt;（3）ConcurrentSkipListSet是有序的吗？&lt;/p&gt;
&lt;p&gt;（4）ConcurrentSkipListSet和之前讲的Set有何不同？&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;ConcurrentSkipListSet底层是通过ConcurrentNavigableMap来实现的，它是一个有序的线程安全的集合。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;p&gt;它的源码比较简单，跟通过Map实现的Set基本是一致，只是多了一些取最近的元素的方法。&lt;/p&gt;
&lt;p&gt;为了保持专栏的完整性，我还是贴一下源码，最后会对Set的整个家族作一个对比，有兴趣的可以直接拉到最下面。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 实现了NavigableSet接口，并没有所谓的ConcurrentNavigableSet接口
public class ConcurrentSkipListSet&amp;lt;E&amp;gt;
    extends AbstractSet&amp;lt;E&amp;gt;
    implements NavigableSet&amp;lt;E&amp;gt;, Cloneable, java.io.Serializable {

    private static final long serialVersionUID = -2479143111061671589L;

    // 存储使用的map
    private final ConcurrentNavigableMap&amp;lt;E,Object&amp;gt; m;

    // 初始化
    public ConcurrentSkipListSet() {
        m = new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;();
    }

    // 传入比较器
    public ConcurrentSkipListSet(Comparator&amp;lt;? super E&amp;gt; comparator) {
        m = new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;(comparator);
    }
    
    // 使用ConcurrentSkipListMap初始化map
    // 并将集合c中所有元素放入到map中
    public ConcurrentSkipListSet(Collection&amp;lt;? extends E&amp;gt; c) {
        m = new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;();
        addAll(c);
    }
    
    // 使用ConcurrentSkipListMap初始化map
    // 并将有序Set中所有元素放入到map中
    public ConcurrentSkipListSet(SortedSet&amp;lt;E&amp;gt; s) {
        m = new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;(s.comparator());
        addAll(s);
    }
    
    // ConcurrentSkipListSet类内部返回子set时使用的
    ConcurrentSkipListSet(ConcurrentNavigableMap&amp;lt;E,Object&amp;gt; m) {
        this.m = m;
    }
    
    // 克隆方法
    public ConcurrentSkipListSet&amp;lt;E&amp;gt; clone() {
        try {
            @SuppressWarnings(&quot;unchecked&quot;)
            ConcurrentSkipListSet&amp;lt;E&amp;gt; clone =
                (ConcurrentSkipListSet&amp;lt;E&amp;gt;) super.clone();
            clone.setMap(new ConcurrentSkipListMap&amp;lt;E,Object&amp;gt;(m));
            return clone;
        } catch (CloneNotSupportedException e) {
            throw new InternalError();
        }
    }

    /* ---------------- Set operations -------------- */
    // 返回元素个数
    public int size() {
        return m.size();
    }

    // 检查是否为空
    public boolean isEmpty() {
        return m.isEmpty();
    }
    
    // 检查是否包含某个元素
    public boolean contains(Object o) {
        return m.containsKey(o);
    }
    
    // 添加一个元素
    // 调用map的putIfAbsent()方法
    public boolean add(E e) {
        return m.putIfAbsent(e, Boolean.TRUE) == null;
    }
    
    // 移除一个元素
    public boolean remove(Object o) {
        return m.remove(o, Boolean.TRUE);
    }

    // 清空所有元素
    public void clear() {
        m.clear();
    }
    
    // 迭代器
    public Iterator&amp;lt;E&amp;gt; iterator() {
        return m.navigableKeySet().iterator();
    }

    // 降序迭代器
    public Iterator&amp;lt;E&amp;gt; descendingIterator() {
        return m.descendingKeySet().iterator();
    }


    /* ---------------- AbstractSet Overrides -------------- */
    // 比较相等方法
    public boolean equals(Object o) {
        // Override AbstractSet version to avoid calling size()
        if (o == this)
            return true;
        if (!(o instanceof Set))
            return false;
        Collection&amp;lt;?&amp;gt; c = (Collection&amp;lt;?&amp;gt;) o;
        try {
            // 这里是通过两次两层for循环来比较
            // 这里是有很大优化空间的，参考上篇文章CopyOnWriteArraySet中的彩蛋
            return containsAll(c) &amp;amp;&amp;amp; c.containsAll(this);
        } catch (ClassCastException unused) {
            return false;
        } catch (NullPointerException unused) {
            return false;
        }
    }
    
    // 移除集合c中所有元素
    public boolean removeAll(Collection&amp;lt;?&amp;gt; c) {
        // Override AbstractSet version to avoid unnecessary call to size()
        boolean modified = false;
        for (Object e : c)
            if (remove(e))
                modified = true;
        return modified;
    }

    /* ---------------- Relational operations -------------- */
    
    // 小于e的最大元素
    public E lower(E e) {
        return m.lowerKey(e);
    }

    // 小于等于e的最大元素
    public E floor(E e) {
        return m.floorKey(e);
    }
    
    // 大于等于e的最小元素
    public E ceiling(E e) {
        return m.ceilingKey(e);
    }

    // 大于e的最小元素
    public E higher(E e) {
        return m.higherKey(e);
    }

    // 弹出最小的元素
    public E pollFirst() {
        Map.Entry&amp;lt;E,Object&amp;gt; e = m.pollFirstEntry();
        return (e == null) ? null : e.getKey();
    }

    // 弹出最大的元素
    public E pollLast() {
        Map.Entry&amp;lt;E,Object&amp;gt; e = m.pollLastEntry();
        return (e == null) ? null : e.getKey();
    }


    /* ---------------- SortedSet operations -------------- */

    // 取比较器
    public Comparator&amp;lt;? super E&amp;gt; comparator() {
        return m.comparator();
    }

    // 最小的元素
    public E first() {
        return m.firstKey();
    }

    // 最大的元素
    public E last() {
        return m.lastKey();
    }
    
    // 取两个元素之间的子set
    public NavigableSet&amp;lt;E&amp;gt; subSet(E fromElement,
                                  boolean fromInclusive,
                                  E toElement,
                                  boolean toInclusive) {
        return new ConcurrentSkipListSet&amp;lt;E&amp;gt;
            (m.subMap(fromElement, fromInclusive,
                      toElement,   toInclusive));
    }
    
    // 取头子set
    public NavigableSet&amp;lt;E&amp;gt; headSet(E toElement, boolean inclusive) {
        return new ConcurrentSkipListSet&amp;lt;E&amp;gt;(m.headMap(toElement, inclusive));
    }

    // 取尾子set
    public NavigableSet&amp;lt;E&amp;gt; tailSet(E fromElement, boolean inclusive) {
        return new ConcurrentSkipListSet&amp;lt;E&amp;gt;(m.tailMap(fromElement, inclusive));
    }

    // 取子set，包含from，不包含to
    public NavigableSet&amp;lt;E&amp;gt; subSet(E fromElement, E toElement) {
        return subSet(fromElement, true, toElement, false);
    }
    
    // 取头子set，不包含to
    public NavigableSet&amp;lt;E&amp;gt; headSet(E toElement) {
        return headSet(toElement, false);
    }
    
    // 取尾子set，包含from
    public NavigableSet&amp;lt;E&amp;gt; tailSet(E fromElement) {
        return tailSet(fromElement, true);
    }
    
    // 降序set
    public NavigableSet&amp;lt;E&amp;gt; descendingSet() {
        return new ConcurrentSkipListSet&amp;lt;E&amp;gt;(m.descendingMap());
    }

    // 可分割的迭代器
    @SuppressWarnings(&quot;unchecked&quot;)
    public Spliterator&amp;lt;E&amp;gt; spliterator() {
        if (m instanceof ConcurrentSkipListMap)
            return ((ConcurrentSkipListMap&amp;lt;E,?&amp;gt;)m).keySpliterator();
        else
            return (Spliterator&amp;lt;E&amp;gt;)((ConcurrentSkipListMap.SubMap&amp;lt;E,?&amp;gt;)m).keyIterator();
    }

    // 原子更新map，给clone方法使用
    private void setMap(ConcurrentNavigableMap&amp;lt;E,Object&amp;gt; map) {
        UNSAFE.putObjectVolatile(this, mapOffset, map);
    }

    // 原子操作相关内容
    private static final sun.misc.Unsafe UNSAFE;
    private static final long mapOffset;
    static {
        try {
            UNSAFE = sun.misc.Unsafe.getUnsafe();
            Class&amp;lt;?&amp;gt; k = ConcurrentSkipListSet.class;
            mapOffset = UNSAFE.objectFieldOffset
                (k.getDeclaredField(&quot;m&quot;));
        } catch (Exception e) {
            throw new Error(e);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，ConcurrentSkipListSet基本上都是使用ConcurrentSkipListMap实现的，虽然取子set部分是使用ConcurrentSkipListMap中的内部类，但是这些内部类其实也是和ConcurrentSkipListMap相关的，它们返回ConcurrentSkipListMap的一部分数据。&lt;/p&gt;
&lt;p&gt;另外，这里的equals()方法实现的相当敷衍，有很大的优化空间，作者这样实现，应该也是知道几乎没有人来调用equals()方法吧。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;（1）ConcurrentSkipListSet底层是使用ConcurrentNavigableMap实现的；&lt;/p&gt;
&lt;p&gt;（2）ConcurrentSkipListSet有序的，基于元素的自然排序或者通过比较器确定的顺序；&lt;/p&gt;
&lt;p&gt;（3）ConcurrentSkipListSet是线程安全的；&lt;/p&gt;
&lt;h2 id=&quot;彩蛋&quot;&gt;彩蛋&lt;/h2&gt;
&lt;p&gt;Set大汇总：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;HashSet&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;HashMap&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;简单&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;LinkedHashSet&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;LinkedHashMap&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;插入顺序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;TreeSet&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;NavigableMap&lt;/td&gt;
&lt;td&gt;NavigableSet&lt;/td&gt;
&lt;td&gt;自然顺序&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CopyOnWriteArraySet&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;CopyOnWriteArrayList&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;插入顺序，读写分离&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ConcurrentSkipListSet&lt;/td&gt;
&lt;td&gt;有&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;ConcurrentNavigableMap&lt;/td&gt;
&lt;td&gt;NavigableSet&lt;/td&gt;
&lt;td&gt;自然顺序&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;从中我们可以发现一些规律：&lt;/p&gt;
&lt;p&gt;（1）除了HashSet其它Set都是有序的；&lt;/p&gt;
&lt;p&gt;（2）实现了NavigableSet或者SortedSet接口的都是自然顺序的；&lt;/p&gt;
&lt;p&gt;（3）使用并发安全的集合实现的Set也是并发安全的；&lt;/p&gt;
&lt;p&gt;（4）TreeSet虽然不是全部都是使用的TreeMap实现的，但其实都是跟TreeMap相关的（TreeMap的子Map中组合了TreeMap）；&lt;/p&gt;
&lt;p&gt;（5）ConcurrentSkipListSet虽然不是全部都是使用的ConcurrentSkipListMap实现的，但其实都是跟ConcurrentSkipListMap相关的（ConcurrentSkipListeMap的子Map中组合了ConcurrentSkipListMap）；&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号“彤哥读源码”，查看更多源码系列文章, 与彤哥一起畅游源码的海洋。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/alan-tang-tt/yuan/raw/master/%E6%AD%BB%E7%A3%95%20java%E9%9B%86%E5%90%88%E7%B3%BB%E5%88%97/resource/qrcode_ss.jpg&quot; alt=&quot;qrcode&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 15:27:00 +0000</pubDate>
<dc:creator>彤哥读源码</dc:creator>
<og:description>ConcurrentSkipListSet的底层是ConcurrentSkipListMap吗？ ConcurrentSkipListSet是线程安全的吗？ ConcurrentSkipListS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tong-yuan/p/ConcurrentSkipListSet.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]数据层缓存（网站性能翻10倍） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_dbcache.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_dbcache.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netcore，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 760+）&lt;/p&gt;

&lt;p&gt;缓存是一把尖刀，合理使用可大大提升吞吐率！&lt;/p&gt;


&lt;p&gt;2006年，某某省电网门户卒！&lt;/p&gt;
&lt;p&gt;经查，首页某个sql先后执行了8次，正好对应页面上8大块新闻列表。&lt;/p&gt;
&lt;p&gt;实在忍无可忍，于是在底层用Hashtable做了一层sql/DataSet缓存，当时.NET1.1好像还没有泛型字典。&lt;/p&gt;
&lt;p&gt;于是世界清静了，效果还不错，特别对于访问量很大的门户网站。&lt;/p&gt;

&lt;p&gt;XCode的数据层缓存设计于2003年，那时候只做网站和普通MIS系统，数据库性能还很差……&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据层缓存：以查询sql为key，把查询结果缓存起来，提升系统性能！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;经过16年的发展，XCode里面数据层缓存曾经一度被干掉，若干年后又请回来，现在是这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190418222422174-1596062212.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据层DAL内，所有查询类方法 Query/Select/SelectCount 都先走一趟缓存（默认配置关闭）；&lt;/p&gt;
&lt;p&gt;所有添删改操作类方法 Execute 都清空本DAL连接的所有缓存；&lt;/p&gt;

&lt;p&gt;** 多年前，查询方法指定要用到的表名，添删改方法指定会影响到的表名，做到部分表缓存过期。现在数据库性能大有提升，为了“简约”设计理念，简化了缓存设计。&lt;/p&gt;


&lt;p&gt;数据层缓存只有一个缓存时间的设置DataCacheExpire，位于配置文件 config/xcode.config 中，默认0秒表示不启用。&lt;/p&gt;
&lt;p&gt;设置缓存时间的方式有多种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;修改配置文件 config/xcode.config 中的DataCacheExpire&lt;/li&gt;
&lt;li&gt;魔方，魔方设置页面，修改数据中间件页的“数据层缓存”&lt;/li&gt;
&lt;li&gt;直接修改DAL类的Expire属性&lt;/li&gt;
&lt;li&gt;连接字符串中配置DataCache参数，如 DataCache=60&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;前面两者的本质相同，也是最常见用法。&lt;/p&gt;
&lt;p&gt;连接字符串配置提供了个性化，针对部分连接需要打开数据层缓存，或者不同连接采用不能缓存时间的场景。&lt;/p&gt;


&lt;p&gt;2016年起，XCode采取了“简约”且稍微“保守”的理念，于是数据层缓存默认配置0秒，大部分场景推荐使用10~60秒。&lt;/p&gt;
&lt;p&gt;各种网站，推荐过期时间60秒起，经实际线上项目压测，吞吐率可轻易从300rps提升到10000rps以上，命中率99.99%。&lt;/p&gt;
&lt;p&gt;每一个应用系统，总会有那么一些表或数据很少改变，非常适合使用数据层缓存，建议在实践中获得最优缓存时间！&lt;/p&gt;



&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd_adv.html&quot; target=&quot;_blank&quot;&gt;高级增删改&lt;/a&gt;。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dirty.html&quot; target=&quot;_blank&quot;&gt;脏数据&lt;/a&gt;。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_additional.html&quot; target=&quot;_blank&quot;&gt;增量累加&lt;/a&gt;。高并发统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_transaction.html&quot; target=&quot;_blank&quot;&gt;事务处理&lt;/a&gt;。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_extend.html&quot; target=&quot;_blank&quot;&gt;扩展属性&lt;/a&gt;。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_search.html&quot; target=&quot;_blank&quot;&gt;高级查询&lt;/a&gt;。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dbcache.html&quot; target=&quot;_blank&quot;&gt;数据层缓存&lt;/a&gt;。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entitycache.html&quot; target=&quot;_blank&quot;&gt;实体缓存&lt;/a&gt;。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_singlecache.html&quot; target=&quot;_blank&quot;&gt;对象缓存&lt;/a&gt;。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_100billion.html&quot; target=&quot;_blank&quot;&gt;百亿级性能&lt;/a&gt;。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_factory.html&quot; target=&quot;_blank&quot;&gt;实体工厂&lt;/a&gt;。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_membership.html&quot; target=&quot;_blank&quot;&gt;角色权限&lt;/a&gt;。Membership&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_import_export.html&quot; target=&quot;_blank&quot;&gt;导入导出&lt;/a&gt;。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_division.html&quot; target=&quot;_blank&quot;&gt;分表分库&lt;/a&gt;。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_stat.html&quot; target=&quot;_blank&quot;&gt;高级统计&lt;/a&gt;。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_batch.html&quot; target=&quot;_blank&quot;&gt;批量写入&lt;/a&gt;。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_queue.html&quot; target=&quot;_blank&quot;&gt;实体队列&lt;/a&gt;。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_backup.html&quot; target=&quot;_blank&quot;&gt;备份同步&lt;/a&gt;。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_service.html&quot; target=&quot;_blank&quot;&gt;数据服务&lt;/a&gt;。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_bigdata.html&quot; target=&quot;_blank&quot;&gt;大数据分析&lt;/a&gt;。ETL抽取，调度计算处理，结果持久化&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Thu, 18 Apr 2019 14:57:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>缓存是一把尖刀，合理使用可大大提升吞吐率！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/xcode_dbcache.html</dc:identifier>
</item>
<item>
<title>带着新人看java虚拟机02 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/10726998.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/10726998.html</guid>
<description>&lt;p&gt;　　上一节是把大概的流程给过了一遍，但是还有很多地方没有说到，后续的慢慢会涉及到，敬请期待！&lt;/p&gt;
&lt;p&gt;　　这次我们说说垃圾收集器，又名gc，顾名思义，就是收集垃圾的容器，那什么是垃圾呢？在我们这里指的就是堆中那些没人要的对象。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.垃圾收集器的由来&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　为什么要有垃圾收集器啊？不知道有没有想过这个问题，你说我运行一个程序要什么垃圾收集器啊？&lt;/p&gt;
&lt;p&gt;　　随意看一下下面两行代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
User user = &lt;span&gt;new&lt;/span&gt; User(&quot;root&quot;,&quot;123456&quot;&lt;span&gt;)
user &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; User(&quot;lisi&quot;,&quot;123123&quot;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　简单画一下内存图，可以看到user这个局部变量本来是指向root这个对象，现在改为指向lisi这个对象，那么此时这个root对象没有人用，假如类似root这样的对象非常多的话，那么jvm性能就会越来越低，直至最后创建个对象可能都要十几秒，而且堆内存总有一天会装满就会报内存溢出异常；&lt;/p&gt;
&lt;p&gt;　　所以我们就要想办法把类似root这种对象给清理掉，这样才能保证jvm高效的运行；&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190417221802398-1431377779.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　假如虚拟机没有提供gc你觉得会怎么样？其实也行，只不过你每次需要你用代码手动释放不需要的对象，关于这点有好处有坏处，好处就是有利于我们对堆内存的控制，坏处就是我们在一些比较复杂的程序之中由于手动释放内存难免会出错，但是这中错误还不怎么明显，可能要你去慢慢调试好久才能看到！&lt;/p&gt;
&lt;p&gt;　　所以java就把这种工作自己处理了，让一个gc线程一直在后台运行，随时准备清理不需要用的对象，虽然相当程度上会对jvm性能造成一些影响，但是由于gc太好用了，我们不用再人为的去关心垃圾对象的释放，简化了我们编写程序的难度，所以这种影响程度完全可以接受！&lt;/p&gt;

&lt;p&gt;　　这里顺便一提两个基本概念，内存泄漏和内存溢出：&lt;/p&gt;
&lt;p&gt;　　内存溢出（Memory Overflow）比较好理解，就是我们保存对象需要的空间太大了，但是申请内存比较小，于是装不下，于是就会报内存溢出异常，比如说你申请了一个integer,但给它存了long才能存下的数，那就是内存溢出；专业点的说法就是：你要求分配的内存超出了系统能给你的，系统不能满足需求，于是产生溢出。&lt;/p&gt;
&lt;p&gt;　　内存泄漏（Memory Leak）指的就是我们new出来的对象保存在堆中但是没有释放，于是堆中内存会越来越少，会导致系统运行速度减慢，严重情况会使程序卡死；专业点的说法就是：你用malloc或new申请了一块内存，但是没有通过free或delete将内存释放，导致这块内存一直处于占用状态。&lt;/p&gt;
&lt;p&gt;　　对于我们jvm来说，通常情况下我们不用担心内存泄漏，因为有一个强大的gc在我们程序的背后默默地为我们清理，但是也会有特殊情况，比如当被分配的对象可达但已无用（未对作废数据内存单元的赋值null）即会引起，至于这个可达是什么意思，后面会慢慢说到；&lt;/p&gt;
&lt;p&gt;　　相对而言内存溢出我们比较常见，还有gc只会对堆内存进行回收，所以静态变量是不会回收的；&lt;/p&gt;

&lt;p&gt;　　再顺便提一下另外两个小概念，非守护线程（也叫用户线程）和守护线程，看下面这个丑陋的程序运行会有几个线程啊？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; User{
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args){
      System.out.println(&lt;/span&gt;&quot;我是java小新人&quot;&lt;span&gt;);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　两个线程，一个是执行main方法的线程，后台还有gc执行gc的线程，在这里，用户线程就是执行main方法的那个线程，执行gc的线程就是守护线程，默默地守护者jvm，假如jvm是雅典娜，那么守护线程就是黄金圣斗士；&lt;/p&gt;
&lt;p&gt;　　当用户线程停止之后整个程序直接停止，守护线程也会终止；但是黄金圣斗士挂了雅典娜还是可以好好活着的继续愉快的玩耍的；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.堆内存结构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　哎，内存中的结构如果真的要通过源代码去看，简直让人崩溃，除了专业搞这方面的不然真的很难懂，本来我想自己画一下草图了，发现太丑陋了，于是去顺手借了一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201904/1368608-20190418111633617-1571949442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　途中可以很清楚的看到，整块堆内存分为年轻人聚集的地方和老年人聚集的地方，年轻人比较少趋势占用1/3空间（新生代），老年人比较多就占用2/3的空间（老年代），然而啊，年轻人又要分分类，分别是Eden区占新生代8/10，From Survivor区占新生代1/10，To Survivor区占新生代1/10，emmm。。。我特意查了一下百度翻译，Eden----&amp;gt;乐园，Survivor-----&amp;gt;幸存者；哦~~~我感觉我仿佛明白了命名人的意图！&lt;/p&gt;
&lt;p&gt;　　 那么新生代和老年代到底是干什么的呢？我们创建的对象是放在哪里啊？&lt;/p&gt;
&lt;p&gt;　　新生代：java对象申请内存和存放对象的地方，而且存放的对象都是那种死的比较快的对象，很多时候创建没多久就清理掉了，那些活的时间比较长的对象都被移动到了老年代。&lt;/p&gt;
&lt;p&gt;　　老年代：存大对象比如长字符串、数组由于需要大量连续的内存空间，可以直接进入老年代；还有长期存活的对象也会进入老年代，具体是多长时间呢，其实默认就是经过15 对新生代的清理（Minor Gc）还能活着的对象。&lt;/p&gt;
&lt;p&gt; 　　而垃圾收集器对这两块内存有两种行为，&lt;span&gt;一种是对新生代的清理，叫做Minor Gc，另外一种是对老年代的清理被叫做Major Gc。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　顺便提一点：很多博客中都把Major GC和Full GC说成是一种，其实还是有区别的，因为很多java虚拟机的实现不一样，所以就有各种各样的名称，比如Minor Gc又叫做Young GC，Major GC也可以叫做Old GC，但是Full GC却有点不同，Full GC 是清理整个堆空间 —— 包括年轻代、老年代和永久代（也叫做方法区）。因此 Full GC 可以说是 Minor GC 和 Major GC 的结合。当然在我们这里，为了好理解我们也就把Full GC当作Major GC就可以了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.筛选清理对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　GC要工作的话，必须首先知道哪些对象要被清理，你想一下，在新生代和老年代有这么多对象，怎么筛选会又快又省事呢？可以有以下两种方法&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1.引用计数算法&lt;/span&gt;，相当于给你创建的对象偷偷的添加一个计数器，每引用一次这个对象，计数器就加一，引用失效就减一，当这个计数器为0的时候，说明这个对象没有变量引用了，于是我们就可以说这个对象可以被清理了&lt;/p&gt;
&lt;p&gt; 　　&lt;span&gt;2.根搜索算法（jvm用的就是这个）&lt;/span&gt;，这个怎么理解呢？你可以想象现在有一个数组，这个数组里面包含了一些东西的引用，我们将这个数组叫做”GC Root“，然后我们根据这个数组中的引用去找到对应的对象，看看这个对象中又引用了哪些对象，一直往下找，这样就形成了很多线路，在这个线路上的对象就叫做”可达对象“，不在这个线路上的对象就是不可达对象，而不可达对象也就是我们要清理的对象；&lt;/p&gt;
&lt;p&gt;　　其中可以作为GC Root的对象：&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;   &lt;/strong&gt;&lt;span&gt;（1）.类中的静态变量，当它持有一个指向一个对象的引用时，它就作为root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      （2）.活动着的线程，可以作为root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      （3）.一个Java方法的参数或者该方法中的局部变量，这两种对象可以作为root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      （4）.JNI方法中的局部变量或者参数，这两种对象可以作为root&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      （5）.其它。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　关于这个根搜索算法专业一点的说法就是：通过一系列的名为“GC Root”的对象作为起始点，从这些节点开始向下搜索，搜索所有走过的路径称为引用链（Reference Chain）,当一个对象到GC Root没有任何引用链相连时（用图论来说就是GC Root到这个对象不可达时），证明该对象是可以被回收的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.进行垃圾回收&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　前面已经筛选出了我们要清理的对象，但是怎么清理比较快呢？难道要一个一个对象慢慢删除嘛？就好像你要清理手机中的垃圾，你会一个应用一个应用去慢慢清理数据吗？当然不可能，这也太浪费时间了！我们当然是用手机管家或者360管家先把要清理的东西给收集起来放在一起，然后我们一清理就是全部，一个字，爽！&lt;/p&gt;
&lt;p&gt;　　ok，在这里也一样，我们要想办法把所有的要清理的对象给放在一起清理，有什么办法呢？&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1.标记-----清除算法&lt;/strong&gt;：这种方法分为两步，先标记然后清除，其实就是需要回收的对象标记一下，然后就是把有标记的对象全部清理即可；这种方式比较适合对象比较少的内存，假如对象太多标记都要好半天，更别说清除了，而且用这种方法清除的内存空间会东一块西一块，下次再创建一个大的对象可能会出问题1&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.复制算法&lt;/strong&gt;：按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚&lt;span&gt;存活的对象&lt;/span&gt;复制到另一块上去，把已经使用的那块内存直接全部清理掉；这种方法最大的缺陷就是耗内存啊，只能用总内存的一半，而且如果对象很多复制都要花很多时间。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3.标记----整理算法&lt;/strong&gt;：结合以上两种方法优缺点进行改良的一种方法，标记和第一种方法一样把要清理的对象做好标记，然后把所有标记的对象移动到本内存的一个小角落，最后集中力量对那个小角落进行消灭&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4.分代收集算法&lt;/strong&gt;：这是集中了上面三种方法的优点所实现的一种最好的方法，是目前大部分JVM所采用的方法，这种算法的核心思想是根据对象存活的时间不同将内存划分为不同的域，一般情况下将GC堆划分为新生代和老年代；新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，少数对象存活，因此可以使用复制算法；老年代的特点是每次垃圾回收时只有少量对象需要被回收，可以选用”标记--清除方法“”或者标记--整理算法“&lt;/p&gt;
&lt;p&gt;　　所以目前大部分JVM的GC都是使用分代收集算法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.执行GC的步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　前面说了这么多无非是介绍堆的内部结构，然后怎么找到要被清理的对象，然后为了提高效率怎么清理最快！&lt;/p&gt;
&lt;p&gt;　　现在我们就大概说说GC的清理步骤（&lt;span&gt;详细版&lt;/span&gt;）：&lt;/p&gt;
&lt;p&gt;　　1.我们创建对象的时候会进行一个判断，极少数很大的对象直接放进老年代中，除此之外所有新创建的对象都放进新生代的Eden区中；&lt;/p&gt;
&lt;p&gt;　　2.此时新生代中只有Eden区中有对象，两个Survivor区中是空的；当我们创建了很多对象，使得Eden区快满的时候第一次GC发生（就是执行了一次Minior GC），Eden区和”From“区（此时“From”区是空的）存活的对象将会被移动到Surviver区的“To”区，并且为每个对象设置一个计数器记录年龄，初始值为1；每进行一次GC，会给那些存活的对象设置一个年龄+1 的操作，默认是当年龄达到15岁，下次GC就会直接把这种”老油条“丢到老年代中。&lt;/p&gt;
&lt;p&gt;　　3.Minior GC之后，会进行一个比较厉害的操作，就是将”To“区和”From“换个名字，没错，就是换个名字，然后进行下一次Minior GC。&lt;/p&gt;
&lt;p&gt;　　4.由于又创建了很多对象使得Eden区要满了，于是又一次Minior GC，Eden区还存活的对象会直接移动到Surviver区的“To”区，此时”From“区（这里就是交换名字之前的”To“区）中的对象有两个地方可以去，要么年龄满15岁了去老年代，要么就移动到”To“区&lt;/p&gt;
&lt;p&gt;　　5.此时我们看一下，只有”To“区的对象是活着的，Eden区都是垃圾对象可以直接全部清理，”From“区是空的；不管怎样，在进行下一次Minior GC之前保证名为”To“的Survivor区域是空的就ok了&lt;/p&gt;
&lt;p&gt;　　6.当老年代中快要装满之后，就会进行一次Major GC，这个清理事件很慢，至少比Minior GC慢十几倍，甚至更多，所以我们尽量要少执行Major GC&lt;/p&gt;
&lt;p&gt;　　注意：如果在移动过程中”To“ 区被填满了，剩余的对象会被直接移动到老年代中。还有在每次Minior GC之前会先进性判断，只要老年代里面的连续空间大于新生代对象总大小或者历次晋升的平均大小进行Minor GC，否则进行Major GC。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;简化版：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;p&gt;　　（1）Eden 区活着的对象 ＋ From Survivor 存储的对象被复制到 To Survivor ；&lt;/p&gt;
&lt;p&gt;　　（2)清空 Eden 和 From Survivor ；&lt;/p&gt;
&lt;p&gt;　　（3)颠倒 From Survivor 和 To Survivor 的逻辑关系： From 变 To ， To 变 From 。&lt;/p&gt;
&lt;p&gt;　　（4）老年代的Major GC执行时间很长，尽量少执行&lt;/p&gt;
&lt;p&gt;　　只有在Eden空间快满的时候才会触发 Minor GC 。而 Eden 空间占新生代的绝大部分，所以 Minor GC 的频率得以降低。当然，使用两个 Survivor 这种方式我们也付出了一定的代价，如 10% 的空间浪费、复制对象的开销等。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.知识点补充&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过查看了很多大佬的博客看到的很多有关的东西还是挺有趣的，于是简单做个小笔记：&lt;/p&gt;
&lt;p&gt;　　6.1.新创建的对象是在堆中的新生代的Eden区，由于堆中内存是所有线程共享，所以在堆中分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上Eden区或者老年代进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。&lt;/p&gt;
&lt;p&gt;　　6.2.很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%~95%的空间，而永久代的垃圾收集效率远低于此。&lt;/p&gt;
&lt;p&gt;　　6.3对象调用.finalize方法被调用后，对象一定会被回收吗？&lt;/p&gt;
&lt;p&gt;　　在经过可达性分析后，到GC Roots不可达的对象可以被回收（但并不是一定会被回收，至少要经过两次标记），此时对象被第一次标记，并进行一次判断，如果该对象没有调用过或者没有重写finalize()方法，那么在第二次标记后可以被回收了；否则，该对象会进入一个FQueue中，稍后由JVM建立的一个Finalizer线程中去执行回收，此时若对象中finalize中“自救”，即和引用链上的任意一个对象建立引用关系，到GC Roots又可达了，在第二次标记时它会被移除“即将回收”的集合；如果finalize中没有逃脱，那就面临被回收。因此finalize方法被调用后，对象不一定会被回收。&lt;/p&gt;
&lt;p&gt;　　6.4.如果在Survivor空间中相同年龄所有对象大小总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象直接进入老年代。不需要等到15岁。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　这篇说的就是java虚拟机怎么去收集对内存的垃圾，首先是要通过可达性分析判断哪些对象是可达的，哪些是不可达的，那些不可达的对象就是我们要处理的对象！这些不可达对象可能在新生代和老年代都有，在新生代用复制算法去处理垃圾，老年代用标记整理算法处理垃圾，这种处理方式也可以叫做分代收集算法！而且还简单说了一下Minor GC和Major GC的触发方式！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　基本的东西就这么多，假如要深入的话可以深入很多，比如我们可以控制新生代的大小，还有很多种垃圾处理器的实现产品等等，都是可以去慢慢了解的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 18 Apr 2019 14:44:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>上一节是把大概的流程给过了一遍，但是还有很多地方没有说到，后续的慢慢会涉及到，敬请期待！ 这次我们说说垃圾收集器，又名gc，顾名思义，就是收集垃圾的容器，那什么是垃圾呢？在我们这里指的就是堆中那些没人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wyq1995/p/10726998.html</dc:identifier>
</item>
<item>
<title>xamarin.forms之实现ListView列表倒计时 - 社会主义接班人</title>
<link>http://www.cnblogs.com/5ishare/p/10732899.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/5ishare/p/10732899.html</guid>
<description>&lt;p&gt;   做商城类APP时经常会遇到抢购倒计时的功能，之前做小区宝iOS的时候也有类似的功能，想着参考iOS做的思路，自定义一个Cell，在Cell中每秒刷新一下控件的文本值，但使用xamarin.forms实现时，自定义cell的方式并不可行，小伙伴上周给发了一个倒计时功能的demo：https://github.com/jsuarezruiz/MyTripCountdown，demo是如下图实现的是一个时间的倒计时效果，需要将一个倒计时的功能放在列表中，实现多个倒计时的效果， 看了源码也一直没思路，昨天也是没思路报着试一试的心态动手操作了下，没想到成功了，还是非常有成就感的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190418220441069-2124758670.png&quot; alt=&quot;&quot; width=&quot;251&quot; height=&quot;351&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一、定义计时器&lt;/p&gt;
&lt;p&gt;xamarin.forms提供了Device.StartTimer来实现定时任务，每隔一秒需要触发事件改变剩余时间。这里定义了两个Action，Completed是在倒计时结束时触发，Ticked是每秒触发一次。RemainTime是剩余时间timespan，EndDate为结束时间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xamarin.Forms;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TimeCountDown
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDown : BindableObject
    {
        TimeSpan _remainTime;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; Action Completed;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;&lt;span&gt; Action Ticked;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime EndDate { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimeSpan RemainTime
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _remainTime; }

            &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                _remainTime &lt;/span&gt;=&lt;span&gt; value;
                OnPropertyChanged();
            }
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Start(&lt;span&gt;int&lt;/span&gt; seconds = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            Device.StartTimer(TimeSpan.FromSeconds(seconds), () &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                RemainTime &lt;/span&gt;= (EndDate -&lt;span&gt; DateTime.Now);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ticked = RemainTime.TotalSeconds &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ticked)
                {
                    Ticked&lt;/span&gt;?&lt;span&gt;.Invoke();
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    Completed&lt;/span&gt;?&lt;span&gt;.Invoke();
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ticked;
            });
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、设置BaseViewModel&lt;/p&gt;
&lt;p&gt;这里创建了一个BaseViewModel，并有2个方法，LoadAsync()、UnloadAsync()，而且继承了ExtendedBindableObject。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TimeCountDown
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseViewModel : ExtendedBindableObject
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task LoadAsync()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt;&lt;span&gt; Task UnloadAsync()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在ExtendedBindableObject中扩展了BindableObject，增加了SetProperty方法，SetProperty方法使用ref引用改变属性的值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Runtime.CompilerServices;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; Xamarin.Forms;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TimeCountDown
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExtendedBindableObject : BindableObject
    {
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; SetProperty&amp;lt;T&amp;gt;(&lt;span&gt;ref&lt;/span&gt; T backingStore, T value, [CallerMemberName]&lt;span&gt;string&lt;/span&gt; propertyName = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (EqualityComparer&amp;lt;T&amp;gt;&lt;span&gt;.Default.Equals(backingStore, value))
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }

            backingStore &lt;/span&gt;=&lt;span&gt; value;
            OnPropertyChanged(propertyName);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;三、设置ViewModel&lt;/p&gt;
&lt;p&gt;新建继承BaseViewModel的类CountDownViewModel，在CountDownViewModel中定义了倒计时类CountDown，当CountDownViewModel调用构造函数时实例化倒计时CountDown，EndDate通过时间戳获得，之后调用LoadAsync()方法，启动计时器，并为计时器绑定具体Actio，在Ticked的Action中每秒定时刷新绑定到界面的数值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Text;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; TimeCountDown
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CountDownViewModel : BaseViewModel
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; Tick { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; _countDownTitle;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; CountDownTitle
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; _countDownTitle;
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt; =&amp;gt; SetProperty(&lt;span&gt;ref&lt;/span&gt;&lt;span&gt; _countDownTitle, value);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; CountDown _countDown;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CountDownViewModel(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; ticks)
        {
            Tick &lt;/span&gt;=&lt;span&gt; ticks;
            _countDown &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CountDown() { EndDate = DateTime.Now.Add(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimeSpan(ticks)) };
            LoadAsync();

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task LoadAsync()
        {
            _countDown.Start();
            _countDown.Ticked &lt;/span&gt;+=&lt;span&gt; OnCountdownTicked;
            _countDown.Completed &lt;/span&gt;+=&lt;span&gt; OnCountdownCompleted;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.LoadAsync();
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task UnloadAsync()
        {
            _countDown.Ticked &lt;/span&gt;-=&lt;span&gt; OnCountdownTicked;
            _countDown.Completed &lt;/span&gt;-=&lt;span&gt; OnCountdownCompleted;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.UnloadAsync();
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnCountdownTicked()
        {
            CountDownTitle &lt;/span&gt;= &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}:{1}:{2}后开抢&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, _countDown.RemainTime.Hours, _countDown.RemainTime.Minutes, _countDown.RemainTime.Seconds);
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnCountdownCompleted()
        {
            CountDownTitle &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;抢购进行中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            UnloadAsync();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;四、测试&lt;/p&gt;
&lt;p&gt;在MainPage中设置了一个ListView，ViewCell模板中设置了一个Label，Text值绑定了CountDownTitle。在MainPage的构造方法中设置listview的ItemsSource。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?xml version=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ?&amp;gt;
&amp;lt;ContentPage xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://xamarin.com/schemas/2014/forms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             xmlns:x&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://schemas.microsoft.com/winfx/2009/xaml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             xmlns:local&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clr-namespace:TimeCountDown&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
             x:Class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TimeCountDown.MainPage&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;StackLayout&amp;gt;
        &amp;lt;ListView x:Name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;listView&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;  VerticalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;ListView.ItemTemplate&amp;gt;
                &amp;lt;DataTemplate&amp;gt;
                    &amp;lt;ViewCell&amp;gt;
                        &amp;lt;Label Text=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{Binding CountDownTitle}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; FontSize=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; TextColor=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Black&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; HorizontalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; VerticalOptions=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;FillAndExpand&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/Label&amp;gt;
                    &amp;lt;/ViewCell&amp;gt;
                &amp;lt;/DataTemplate&amp;gt;
            &amp;lt;/ListView.ItemTemplate&amp;gt;
        &amp;lt;/ListView&amp;gt;
    &amp;lt;/StackLayout&amp;gt;
&amp;lt;/ContentPage&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; MainPage()
        {
            InitializeComponent();
            List&lt;/span&gt;&amp;lt;CountDownViewModel&amp;gt; countDownVMs = &lt;span&gt;new&lt;/span&gt; List&amp;lt;CountDownViewModel&amp;gt;&lt;span&gt;() {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CountDownViewModel(&lt;span&gt;11111111111&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CountDownViewModel(&lt;span&gt;2222222222&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CountDownViewModel(&lt;span&gt;3333333333333&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CountDownViewModel(&lt;span&gt;444444444444&lt;/span&gt;&lt;span&gt;),
            };
            listView.ItemsSource &lt;/span&gt;=&lt;span&gt; countDownVMs;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190418223301782-335013866.png&quot; alt=&quot;&quot; width=&quot;452&quot; height=&quot;904&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733213/201904/733213-20190418223221510-1159738894.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;890&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 18 Apr 2019 14:34:00 +0000</pubDate>
<dc:creator>社会主义接班人</dc:creator>
<og:description>做商城类APP时经常会遇到抢购倒计时的功能，之前做小区宝iOS的时候也有类似的功能，想着参考iOS做的思路，自定义一个Cell，在Cell中每秒刷新一下控件的文本值，但使用xamarin.forms实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/5ishare/p/10732899.html</dc:identifier>
</item>
</channel>
</rss>