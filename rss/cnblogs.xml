<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>技术高手如何炼成 - 技术小工</title>
<link>http://www.cnblogs.com/qianpangzi/p/10556321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianpangzi/p/10556321.html</guid>
<description>&lt;p&gt;面试的时候，我会问面试者，你日常如何构建自己的知识体系，如何让自己更高更快更强？多数工程师并没有深入地思考过这个问题，基本上是零敲碎打，随机性大，基本上是脚踩西瓜皮滑到哪里算哪里。&lt;br/&gt;本着不能让你白来一趟的精神，好为人师的我会娓娓道来：&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;第一阶段 认真构建完整的知识体系&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;十几年前我投身软件行业的时候，光是讲解数据库原理、操作系统、TCP/IP、组网、算法等等基础知识的英文原版书摞起来就等身，认认真真看完，各种上手实践，入行后，读遍 C++ 各种经典著作，读遍各种协议原文，认认真真打基础。&lt;br/&gt;很多工程师都说自己平常就是在某些 IT 门户上看看推荐的博文或新闻，我说这属于典型的零敲碎打，不够刺激。&lt;br/&gt;聊到这时，我会举一个例子，为什么要阅读长篇小说，因为中短篇小说就像用针扎你，而长篇小说就像把你装进一个沙袋里吊起来，从四面八方用狼牙棒打你，酣畅淋漓。构建可用的知识体系，就得读书，书是有体系结构的，你关心不关心，现阶段你用到用不到，它都讲到了，从头到尾看几遍，针扎得透透的。&lt;/p&gt;&lt;p&gt;何谓知识体系？&lt;br/&gt;几年前，前支付宝架构师姚建东曾经在我们公司做过技术人员如何规划自己的分享讲座，他是这么论述的：&lt;br/&gt;技术与技巧包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;计算机基础理论&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;计算机模型：内存/IO/时钟/CPU……&lt;/li&gt;
&lt;li&gt;算法&lt;/li&gt;
&lt;li&gt;专项技术领域：&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;数据挖掘&lt;/li&gt;
&lt;li&gt;数据管理&lt;/li&gt;
&lt;li&gt;智能推荐&lt;/li&gt;
&lt;li&gt;搜索&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;语言与工具&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;语言与相关体系&lt;/li&gt;
&lt;li&gt;开发工具，分析工具，代码管理工具&lt;/li&gt;
&lt;li&gt;HTML/CSS/JS/Ajax&lt;/li&gt;
&lt;li&gt;常用框架与第三方类库&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;调试与测试&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;调试方法和哲学&lt;/li&gt;
&lt;li&gt;定位问题&lt;/li&gt;
&lt;li&gt;BUG管理工具&lt;/li&gt;
&lt;li&gt;单元测试&lt;/li&gt;
&lt;li&gt;集成测试&lt;/li&gt;
&lt;li&gt;性能测试&lt;/li&gt;
&lt;li&gt;安全测试&lt;/li&gt;
&lt;li&gt;兼容性测试与方法&lt;/li&gt;
&lt;li&gt;JS/Ajax测试与方法&lt;/li&gt;
&lt;li&gt;服务层测试&lt;/li&gt;
&lt;li&gt;Web层测试&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;网络与系统&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;TCP/IP协议与模型，HTTP/SMTP等协议&lt;/li&gt;
&lt;li&gt;Linux系统，网络分析工具，系统分析工具&lt;/li&gt;
&lt;li&gt;容量，流量与负载均衡&lt;/li&gt;
&lt;li&gt;应用部署、规范、规划&lt;/li&gt;
&lt;li&gt;安全&lt;/li&gt;
&lt;li&gt;监控与故障分析&lt;/li&gt;
&lt;li&gt;磁盘与存储&lt;/li&gt;
&lt;li&gt;Shell&lt;/li&gt;
&lt;li&gt;DNS与域名&lt;/li&gt;
&lt;li&gt;缓存，反向代理&lt;/li&gt;
&lt;li&gt;图片服务器（海量小文件）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;需求挖掘与分析&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;需求文档格式&lt;/li&gt;
&lt;li&gt;需求访谈&lt;/li&gt;
&lt;li&gt;需求分析方法，需求分析工具&lt;/li&gt;
&lt;li&gt;领域知识与经验&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;系统分析与设计&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;UML语言与模型&lt;/li&gt;
&lt;li&gt;分析模式&lt;/li&gt;
&lt;li&gt;设计模式，领域驱动&lt;/li&gt;
&lt;li&gt;系统分析文档格式&lt;/li&gt;
&lt;li&gt;系统设计文档格式&lt;/li&gt;
&lt;li&gt;功能性需求与非功能性需求&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;数据与系统&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;数据库&lt;/li&gt;
&lt;li&gt;可伸缩策略，扩展策略，备份，容灾，性能，安全，高可用……&lt;/li&gt;
&lt;li&gt;数据设计与范式，SQL/NoSQL，Cache，分布式文件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;架构设计&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;架构模式，典型互联网公司架构演进历史&lt;/li&gt;
&lt;li&gt;架构原则，常用策略&lt;/li&gt;
&lt;li&gt;架构设计方法&lt;/li&gt;
&lt;li&gt;非功能性理解&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;扩展性&lt;/li&gt;
&lt;li&gt;伸缩性&lt;/li&gt;
&lt;li&gt;稳定性&lt;/li&gt;
&lt;li&gt;一致性&lt;/li&gt;
&lt;li&gt;性能&lt;/li&gt;
&lt;li&gt;吞吐量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;容量预测与规划&lt;/li&gt;
&lt;li&gt;架构体系与相关技术&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;过程与管理&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;分析过程&lt;/li&gt;
&lt;li&gt;研发过程&lt;/li&gt;
&lt;li&gt;评审过程&lt;/li&gt;
&lt;li&gt;测试过程&lt;/li&gt;
&lt;li&gt;发布过程&lt;/li&gt;
&lt;li&gt;回滚过程&lt;/li&gt;
&lt;li&gt;文档管理&lt;/li&gt;
&lt;li&gt;知识管理&lt;/li&gt;
&lt;li&gt;项目管理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上其实就是一份从业基础知识清单，你可以按图索骥，阅读相关书籍。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;第二阶段 顺着一个Topic钻进去，锻炼自己的预研能力&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;无论公司业务还是自己喜欢做的事，都可以抽象出通用性课题，然后以做论文的方式杀进去。这个事情得反复操练，有意识操练。&lt;br/&gt;做事方式为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;抽象出 Topic——如分布式锁，分布式并行计算引擎，防CSRF的FormToken自动生成框架，定时任务管理与调度平台，分布式跟踪，等等&lt;/li&gt;
&lt;li&gt;向功课好的学生学习——有针对性地深入了解业界其他公司是如何分析问题和解决问题的，汇总各种方案，站在巨人的肩膀上&lt;/li&gt;
&lt;li&gt;分析特定应用场景，技术选型&lt;/li&gt;
&lt;li&gt;兼顾高可用性和可伸缩，做设计评审&lt;/li&gt;
&lt;li&gt;做测试自证靠谱，梳理知识点，开技术分享会&lt;/li&gt;
&lt;li&gt;上线商用，总结经验教训，开经验分享会&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;br/&gt;其中一个重点是汇总和分享。05年时，应电信级统一消息业务需要，我去研究了 SIP 协议，做了各种试验，分析报文，写了一系列的幻灯片，做了公开分享，一时间还颇受欢迎：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SIP_to_Freshman_by_zhengyun.ppt&lt;/li&gt;
&lt;li&gt;SIP之穿越NAT_by_zhengyun.ppt&lt;/li&gt;
&lt;li&gt;SIP体系架构讲义及消息交互演示_by_zhengyun.ppt&lt;/li&gt;
&lt;li&gt;SIP多方会话消息之实例讲解_by_zhengyun.ppt&lt;/li&gt;
&lt;li&gt;SIP安全框架之认证[NTLM和Kerberos]_by_zhengyun.ppt&lt;/li&gt;
&lt;li&gt;SIP消息之逐项讲解_by_zhengyun.ppt&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为什么要写出来、讲出来呢？&lt;br/&gt;因为有一个学习金字塔理论，如下图所示：&lt;br/&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/90a98144c7ba399f19f5aece2838327c_hd.png&quot; alt=&quot;&quot; width=&quot;664&quot; data-rawwidth=&quot;664&quot; data-rawheight=&quot;368&quot; data-original=&quot;https://pic1.zhimg.com/90a98144c7ba399f19f5aece2838327c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/90a98144c7ba399f19f5aece2838327c_b.png&quot;/&gt;&lt;br/&gt;我们读过的事情能够记住学习内容的10%，&lt;br/&gt;我们听过的事情能够记住20%，&lt;br/&gt;我们看过的事情能够记住30%，&lt;br/&gt;我们听过和看过的事情能够记住50%——如看影像/看展览/看演示/现场观摩，&lt;br/&gt;我们说过的事情能够记住70%——如参与讨论/发言，&lt;br/&gt;&lt;strong&gt;我们说过和做过的事情能够记住90%——如做报告，给别人讲，亲身体验，动手做。&lt;/strong&gt;&lt;br/&gt;这也就是我在《&lt;a class=&quot; wrap external&quot; href=&quot;http://link.zhihu.com/?target=http%3A//www.cnblogs.com/zhengyun_ustc/p/rightThings.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;窝窝研发过去几年做对了哪些事&lt;/a&gt;》中阐述的管理方法：我们从入职之后就有意识地训练大家，让大家能够公开陈述、清晰表达。所以，试用期内，新人必须做一次技术分享和一次技术评审，面对各方的 challenge；预研的中间和结尾都要有分享会；平时也要定期组织技术讲座。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;第三阶段 疯狂回答技术问题&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;知识体系慢慢构建，与业务相关的抽象 Topic 也在探索中。&lt;br/&gt;但这还不够。&lt;br/&gt;因为你亲身接触到的世界太小，可能不足以构成挑战，你可能意识不到自己缺多少知识和技能，不利于你分析问题、提出问题和解决问题的能力培养。&lt;br/&gt;所以，要主动出击：&lt;br/&gt;&lt;strong&gt;疯狂回答问题&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;我曾经在入行的头几年里几乎把我关注的垂直领域（包括语言领域和业务领域）里的所有问题都回答了一遍。我对外宣扬知无不言言无不尽，放出邮件地址和 MSN（那时候 MSN 很高大上），很多网友都会发邮件或者加我好友，问各种开发疑难问题，平均每天都有几个，然后我把解决问题的过程写成微软 KB（KnowledgeBase） 文体发表在我的博客上。&lt;br/&gt;你想想看，工作中的问题你平均每隔几天才能遇到一个，而这么做，每天你都会遇到几个乃至于十几个，第一让你脑力激荡，第二接触到更多新知。&lt;/p&gt;&lt;p&gt;05年到06年期间，我因工作需要学习了 JavaME（或古老的称呼 J2ME），早年间 Symbian 手机上的客户端开发。那段时间我天天扫中文论坛的帖子，力求回答所有问题，尤其是那些 BUG 或故障。对于那些暂时没有人解决的，如流媒体实时播放，如仿 OperaMini 二级菜单界面，都上下求索，最后放出思路以及源码。&lt;br/&gt;同时，我经常整理常见问题，梳理成册并发布。譬如我整理过的 J2ME 疑难问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;[J2ME Q&amp;amp;A]真机报告MontyThread -n的错误之解释&lt;/li&gt;
&lt;li&gt;[J2MEQ&amp;amp;A]WTK初始化WMAClient报错XXX has no IP address的解释&lt;/li&gt;
&lt;li&gt;[J2ME Q&amp;amp;A]untrusted domain is not configured问题回应&lt;/li&gt;
&lt;li&gt;[J2ME]“Cannot open socket for LIME events”错误解决&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;几个月后，我成为 J2ME 中文论坛超级版主。通过这个历程，我想告诉大家，回答网友问题，技巧得当的话，比如别老是重复回答新手问题，试着攻克那些疑难问题，或者离奇故障，绝对不会浪费你的时间。&lt;br/&gt;为什么？&lt;br/&gt;因为你要信奉：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;你学过的每一样东西，你遭受的每一次苦难，都会在你一生中的某个时候派上用场。&lt;br/&gt;——佩内洛普·菲兹杰拉德 《离岸》&lt;/p&gt;&lt;p&gt;Everything that you've learnt and all the hardships you've suffered will all come in handy at some point in your life.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;&lt;strong&gt;第四阶段 RCA/总结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;br/&gt;现在是你把经验教训变为财富的时刻了。&lt;br/&gt;什么是好的技术 Leader？&lt;br/&gt;随便一个业务需求或业务场景讲出来，你立刻把它抽象为几个模块/系统/Topic，然后侃侃而谈，业界都是怎么解决的，我们以前又是怎么分析怎么解决的，现在咱们这种情况下应该如何设计，可能会遇到什么问题，我们应该做哪些预防设计，blabla。&lt;/p&gt;&lt;p&gt;怎么做到这一点？&lt;br/&gt;第一，写 RCA 报告。&lt;br/&gt;我以前说过，『窝窝从 2011 年开始，一直坚持每错必查、错了又错就整改、每错必写，用身体力行告诉每一个新员工直面错误、公开技术细节、分享给所有人，长此以往，每一次事故和线上漏测都会变为我们的财富。这就是我们的 RCA（Root Cause Analysis）制度，截止到目前已经收集整理了近两百个详尽的 RCA 报告。』&lt;br/&gt;RCA 报告格式为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;背景知识（Optional）&lt;/li&gt;
&lt;li&gt;问题现象&lt;/li&gt;
&lt;li&gt;影响范围&lt;/li&gt;
&lt;li&gt;问题原因&lt;/li&gt;
&lt;li&gt;问题分析过程（Optional）&lt;/li&gt;
&lt;li&gt;解决办法&lt;/li&gt;
&lt;li&gt;后续处理措施：如线上脏数据如何修复，如对用户造成的影响如何弥补等（Optional）&lt;/li&gt;
&lt;li&gt;经验教训&lt;/li&gt;
&lt;li&gt;RCA类型：如代码问题、实施问题、配置问题、设计问题、测试问题&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样，作为一名合格的老兵，你见过了足够多的血，并且把它们变成了你的人生财富。&lt;br/&gt;第二，写总结。&lt;br/&gt;话说，要经常拉清单。&lt;br/&gt;侃侃而谈得有资料，这些都得是你自己写才能印象深刻，关键时刻想得起来。&lt;/p&gt;&lt;p&gt;好了，这就是我告诉面试者的高手炼成四个阶段。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 23:18:00 +0000</pubDate>
<dc:creator>技术小工</dc:creator>
<og:description>面试的时候，我会问面试者，你日常如何构建自己的知识体系，如何让自己更高更快更强？多数工程师并没有深入地思考过这个问题，基本上是零敲碎打，随机性大，基本上是脚踩西瓜皮滑到哪里算哪里。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianpangzi/p/10556321.html</dc:identifier>
</item>
<item>
<title>C# 中的Async 和 Await 的用法详解 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10555849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10555849.html</guid>
<description>&lt;p&gt;众所周知C#提供Async和Await关键字来实现异步编程。在本文中，我们将共同探讨并介绍什么是Async 和 Await，以及如何在C#中使用Async 和 Await。&lt;br/&gt;同样本文的内容也大多是翻译的，只不过加上了自己的理解进行了相关知识点的补充，如果你认为自己的英文水平还不错，大可直接跳转到文章末尾查看原文链接进行阅读。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文链接：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10555849.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10555849.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;自从C# 5.0时代引入async和await关键字后，异步编程就变得流行起来。尤其在现在的.NET Core时代，如果你的代码中没有出现async或者await关键字，都会让人感觉到很奇怪。&lt;/p&gt;
&lt;p&gt;想象一下当我们在处理UI和按钮单击时，我们需要运行一个长时间运行的方法，比如读取一个大文件或其他需要很长时间的任务，在这种情况下，整个应用程序必须等待这个长时间运行的任务完成才算完成整个任务。&lt;/p&gt;
&lt;p&gt;换句话说，如果同步应用程序中的任何进程被阻塞，则整个应用程序将被阻塞，我们的应用程序将停止响应，直到整个任务完成。&lt;/p&gt;
&lt;p&gt;在这种情况下，异步编程将非常有用。通过使用异步编程，应用程序可以继续进行不依赖于整个任务完成的其他工作。&lt;/p&gt;
&lt;p&gt;在Async 和 await关键字的帮助下，使得异步编程变得很简单，而且我们将获得传统异步编程的所有好处。&lt;/p&gt;
&lt;h2 id=&quot;实例讲解&quot;&gt;实例讲解&lt;/h2&gt;
&lt;p&gt;假设我们分别使用了两种方法，即Method 1和Method 2，这两种方法不相互依赖，而Method 1需要很长时间才能完成它的任务。在同步编程中，它将执行第一个Method 1，并等待该方法的完成，然后执行Method 2。因此，这将是一个时间密集型的过程，即使这两种方法并不相互依赖。&lt;/p&gt;
&lt;p&gt;我们可以使用简单的多线程编程并行运行所有方法，但是它会阻塞UI并等待完成所有任务。要解决这个问题，我们必须在传统编程中编写很多的代码，但是现在我们有了Async 和 await关键字，那么我们将通过书写很少的并且简洁的代码来解决这个问题。&lt;/p&gt;
&lt;p&gt;此外，我们还将看到更多的示例，如果任何第三个方法(如Method 3)都依赖于Method 1，那么它将在Wait关键字的帮助下等待Method 1的完成。&lt;/p&gt;
&lt;p&gt;Async 和 await是代码标记，它标记代码位置为任务完成后控件应该恢复的位置。&lt;/p&gt;
&lt;p&gt;下面让我们举几个例子来更好进行理解吧&lt;/p&gt;
&lt;p&gt;C#中Async 和 await关键字的示例&lt;/p&gt;
&lt;p&gt;我们将采用控制台应用程序进行演示。&lt;/p&gt;
&lt;h3 id=&quot;第一个例子&quot;&gt;第一个例子&lt;/h3&gt;
&lt;p&gt;在这个例子中，我们将采取两个不相互依赖的方法。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class Program
{  
    static void Main(string[] args)
    {  
Method1();
Method2();
Console.ReadKey();
    }  
  
    public static async Task Method1()
    {  
await Task.Run(() =&amp;gt;
        {  
            for (int i = 0; i &amp;lt; 100; i++)
            {  
Console.WriteLine(&quot; Method 1&quot;);  
            }  
        });  
    }  
  
  
    public static void Method2()
    {  
        for (int i = 0; i &amp;lt; 25; i++)
        {  
Console.WriteLine(&quot; Method 2&quot;);  
        }  
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面给出的代码中，Method 1和Method 2不相互依赖，我们是从主方法调用的。&lt;/p&gt;
&lt;p&gt;在这里，我们可以清楚地看到，方法1和方法2并不是在等待对方完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201903/1377250-20190318225205912-696038953.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在来看第二个例子，假设我们有Method 3，它依赖于Method 1&lt;/p&gt;
&lt;h3 id=&quot;第二个例子&quot;&gt;第二个例子&lt;/h3&gt;
&lt;p&gt;在本例中，Method 1将总长度作为整数值返回，我们在Method 3中以长度的形式传递一个参数，它来自Method 1。&lt;/p&gt;
&lt;p&gt;在这里，在传递Method 3中的参数之前，我们必须使用AWAIT关键字，为此，我们必须使用调用方法中的async 关键字。&lt;/p&gt;
&lt;p&gt;在控制台应用程序的Main方法中，因为不能使用async关键字而不能使用await 关键字，因为它会给出下面给出的错误。(但是如果你使用的是C#7.1及以上的方法是不会有问题的，因为C#7.1及以上的语法支持Mian方法前加async)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201903/1377250-20190318225205653-2039239103.jpg&quot; alt=&quot;img&quot;/&gt;&lt;br/&gt;我们将创建一个新的方法，作为CallMethod，在这个方法中，我们将调用我们的所有方法，分别为Method 1、Method 2和Method 3。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class Program
{  
    static void Main(string[] args)
    {  
callMethod();
Console.ReadKey();
    }  
  
    public static async void callMethod()
    {  
Task&amp;lt;int&amp;gt; task = Method1();
Method2();
        int count = await task;
Method3(count);
    }  
  
    public static async Task&amp;lt;int&amp;gt; Method1()
    {  
        int count = 0;
await Task.Run(() =&amp;gt;
        {  
            for (int i = 0; i &amp;lt; 100; i++)
            {  
Console.WriteLine(&quot; Method 1&quot;);  
count += 1;
            }  
        });  
        return count;
    }  
  
    public static void Method2()
    {  
        for (int i = 0; i &amp;lt; 25; i++)
        {  
Console.WriteLine(&quot; Method 2&quot;);  
        }  
    }  
  
    public static void Method3(int count)
    {  
Console.WriteLine(&quot;Total count is &quot; + count);
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面给出的代码中，Method 3需要一个参数，即Method 1的返回类型。在这里，await关键字对于等待Method 1任务的完成起着至关重要的作用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201903/1377250-20190318225205378-1554546298.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;第三个例子&quot;&gt;第三个例子&lt;/h3&gt;
&lt;p&gt;.NET Framework4.5中有一些支持API，Windows运行时包含支持异步编程的方法。&lt;/p&gt;
&lt;p&gt;在Async 和 await关键字的帮助下，我们可以在实时项目中使用所有这些，以便更快地执行任务。&lt;/p&gt;
&lt;p&gt;包含异步方法的API有HttpClient, SyndicationClient, StorageFile, StreamWriter, StreamReader, XmlReader, MediaCapture, BitmapEncoder, BitmapDecoder 等。&lt;/p&gt;
&lt;p&gt;在本例中，我们将异步读取大型文本文件中的所有字符，并获取所有字符的总长度。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;class Program
{  
    static void Main()
    {  
Task task = new Task(CallMethod);
task.Start();
task.Wait();
Console.ReadLine();
    }  
  
    static async void CallMethod()
    {  
        string filePath = &quot;E:\\sampleFile.txt&quot;;  
Task&amp;lt;int&amp;gt; task = ReadFile(filePath);
  
Console.WriteLine(&quot; Other Work 1&quot;);  
Console.WriteLine(&quot; Other Work 2&quot;);  
Console.WriteLine(&quot; Other Work 3&quot;);  
  
        int length = await task;
Console.WriteLine(&quot; Total length: &quot; + length);
  
Console.WriteLine(&quot; After work 1&quot;);  
Console.WriteLine(&quot; After work 2&quot;);  
    }  
  
    static async Task&amp;lt;int&amp;gt; ReadFile(string file)
    {  
        int length = 0;
  
Console.WriteLine(&quot; File reading is stating&quot;);  
        using (StreamReader reader = new StreamReader(file))
        {  
            // Reads all characters from the current position to the end of the stream asynchronously   
            // and returns them as one string.   
            string s = await reader.ReadToEndAsync();
  
length = s.Length;
        }  
Console.WriteLine(&quot; File reading is completed&quot;);  
        return length;
    }  
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面给出的代码中，我们调用ReadFile方法来读取文本文件的内容，并获取文本文件中总字符的长度。&lt;/p&gt;
&lt;p&gt;在sampleText.txt中，文件包含了太多的字符，因此读取所有字符需要很长时间。&lt;/p&gt;
&lt;p&gt;在这里，我们使用异步编程从文件中读取所有内容，所以它不会等待从这个方法获得一个返回值并执行其他代码行，但是它必须等待下面给出的代码行，因为我们使用的是等待关键字，我们将对下面给出的代码行使用返回值。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;int length = await task;
Console.WriteLine(&quot; Total length: &quot; + length);  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随后，将按顺序执行其他代码行。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;Console.WriteLine(&quot; After work 1&quot;);  
Console.WriteLine(&quot; After work 2&quot;);   &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;输出&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201903/1377250-20190318225204721-965583889.jpg&quot; alt=&quot;img&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;在这里，我们必须了解非常重要的一点，如果我们没有使用await 关键字，那么该方法就作为一个同步方法。编译器将向我们显示警告，但不会显示任何错误。&lt;br/&gt;像上面这种简单的方式一样，我们可以在C#代码中使用async 和await关键字来愉快的进行异步编程了。&lt;br/&gt;最后的最后感谢大家的阅读！&lt;br/&gt;本文大部分内容翻译自：&lt;a href=&quot;https://www.c-sharpcorner.com/article/async-and-await-in-c-sharp/&quot; class=&quot;uri&quot;&gt;https://www.c-sharpcorner.com/article/async-and-await-in-c-sharp/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 23:13:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>众所周知C 提供Async和Await关键字来实现异步编程。在本文中，我们将共同探讨并介绍什么是Async 和 Await，以及如何在C 中使用Async 和 Await。 同样本文的内容也大多是翻译</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10555849.html</dc:identifier>
</item>
<item>
<title>Unix历史及相关概念回顾 - justinme</title>
<link>http://www.cnblogs.com/justinme/p/10556291.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justinme/p/10556291.html</guid>
<description>&lt;h4 id=&quot;欢迎来到unix的世界&quot;&gt;欢迎来到Unix的世界&lt;/h4&gt;
&lt;p&gt;很多人都用了很多年的Unix（其实更熟悉的是叫Linux），也接触到Unix世界中的各种概念，比如GCC、GNU、BSD、POSIX、GPL等等，也大都知道一些传奇的如雷贯耳的人物，比如Ken Thompson、Dennis Ritchie、Linus Torvalds、Richard Stallman等。但是这些概念是怎么发展和相互关联的，以及这些人物是怎么书写历史传奇的，相信能说清楚的人并不多。这里就专门汇总一下这些信息，供大家参考。&lt;/p&gt;
&lt;p&gt;另外，了解这些历史本身也是非常有趣的。看起来各种杂乱无章、琐碎纷繁的点点滴滴，最后还是挡不住历史的潮流，演化出了如今精彩纷呈的现实世界（包括有名的Mac OS、IOS、Android等），而这和人类历史的发展竟如此相像~&lt;/p&gt;
&lt;h4 id=&quot;unix&quot;&gt;Unix&lt;/h4&gt;
&lt;p&gt;下图是对Unit的历史的一个简单汇总，参考了coolshell上的一篇文章&lt;a href=&quot;https://coolshell.cn/articles/1032.html&quot;&gt;UNIX 40年：UNIX年鉴&lt;/a&gt;。如果对其详细历史有兴趣的话，可以去这里看看&lt;a href=&quot;https://www.levenez.com/unix/&quot;&gt;Unix History&lt;/a&gt;（那个白色的横条是一个很残暴的PDF文件，作者牛逼到爆）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pnglgo7yi.bkt.clouddn.com/Unit-history.png&quot; alt=&quot;image-20190131140627679&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中有几个重要信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BSD诞生于1978年，是基于其在1974年收到的Unit的源码拷贝，后面很多重要的发布版本都是源于BSD&lt;/li&gt;
&lt;li&gt;1988年为了统一Unit的标准乱象，IEEE提出了POSIX标准&lt;/li&gt;
&lt;li&gt;1991年，Linux诞生，但其本身只是一个操作系统的内核，不包含任何的配套软件&lt;/li&gt;
&lt;li&gt;1992年，Linux内核被整合近了GNU，GNU+Linux内核，这才是大家常用的Linux系统，实际上应该叫GNU/Linux&lt;/li&gt;
&lt;li&gt;2001年，Mac OS诞生，其基于Mach操作系统，Mach系统又是基于BSD，但是替换了其中的Unix内核&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;linux&quot;&gt;Linux&lt;/h4&gt;
&lt;p&gt;下面的发展简史摘自&lt;a href=&quot;https://www.cnblogs.com/zcl1840/p/6473026.html&quot;&gt;Linux发展历史&lt;/a&gt;，做了少部分改动&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Linux操作系统的诞生、发展和成长过程始终依赖着五个重要支柱：UNIX 操作系统、MINIX 操作系统、GNU计划、POSIX 标准和Internet 网络。。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1981 年IBM公司推出微型计算机IBM PC&lt;/li&gt;
&lt;li&gt;1991年，GNU计划已经开发出了许多工具软件，最受期盼的GNU C编译器已经出现，GNU的操作系统核心HURD一直处于实验阶段，没有任何可用性，实质上也没能开发出完整的GNU操作系统，但是GNU奠定了Linux用户基础和开发环境&lt;/li&gt;
&lt;li&gt;1991年初，林纳斯·托瓦兹开始在一台386sx兼容微机上学习minix操作系统。1991年4月，林纳斯·托瓦兹开始酝酿并着手编制自己的操作系统&lt;/li&gt;
&lt;li&gt;1991 年4 月13 日在comp.os.minix 上发布说自己已经成功地将bash 移植到了minix 上，而且已经爱不释手、不能离开这个shell软件了&lt;/li&gt;
&lt;li&gt;1991年7月3日，第一个与Linux有关的消息是在comp.os.minix上发布的（此时还不存在Linux这个名称）&lt;/li&gt;
&lt;li&gt;1991年的10月5日，林纳斯·托瓦兹在comp.os.minix新闻组上发布消息，正式向外宣布Linux内核的诞生&lt;/li&gt;
&lt;li&gt;1993年，大约有100余名程序员参与了Linux内核代码编写/修改工作，其中核心组由5人组成，此时Linux 0.99的代码大约有十万行，用户大约有10万左右&lt;/li&gt;
&lt;li&gt;1994年3月，Linux1.0发布，代码量17万行，当时是按照完全自由免费的协议发布，随后正式采用GPL协议&lt;/li&gt;
&lt;li&gt;1995年1月，Bob Young创办了RedHat（小红帽），以GNU/Linux为核心，集成了400多个源代码开放的程序模块，搞出了一种冠以品牌的Linux，即RedHat Linux,称为Linux&quot;发行版&quot;，在市场上出售&lt;/li&gt;
&lt;li&gt;1996年6月，Linux 2.0内核发布，此内核有大约40万行代码，并可以支持多个处理器。此时的Linux 已经进入了实用阶段，全球大约有350万人使用&lt;/li&gt;
&lt;li&gt;1998年2月，以Eric Raymond为首的一批年轻的&quot;老牛羚骨干分子&quot;终于认识到GNU/Linux体系的产业化道路的本质，并非是什么自由哲学，而是市场竞争的驱动，创办了&quot;Open Source Intiative&quot;（开放源代码促进会）&quot;复兴&quot;的大旗，在互联网世界里展开了一场历史性的Linux产业化运动&lt;/li&gt;
&lt;li&gt;2001年1月，Linux 2.4发布，它进一步地提升了SMP系统的扩展性，同时它也集成了很多用于支持桌面系统的特性：USB，PC卡（PCMCIA）的支持，内置的即插即用，等等功能&lt;/li&gt;
&lt;li&gt;2003年12月，Linux 2.6版内核发布，相对于2.4版内核2.6在对系统的支持都有很大的变化&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;其系统的进化是这样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1969.9 UNICS(Unix)&lt;/li&gt;
&lt;li&gt;1971.11 Unix Time Sharing System Edition Version V1&lt;/li&gt;
&lt;li&gt;1972.6 V2 -&amp;gt; 1973.2 V3 -&amp;gt;1973.11 V4 -&amp;gt; 1974.6 V5 -&amp;gt; 1975 V6 -&amp;gt; 1979 V7&lt;/li&gt;
&lt;li&gt;1987 Minix V1.0发布，基于Unit Time Sharing System V7&lt;/li&gt;
&lt;li&gt;1991.8.1 Linux 0.0.1发布，基于Minix系统&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;gnu&quot;&gt;GNU&lt;/h4&gt;
&lt;p&gt;GNU(GNU's Not Unix)项目是1984年由Richard Stallman发起的一个开源项目，该项目的目标是开发出一个完整的类Unix系统，其源代码能够不受限制地被修改和传播。GNU项目开发出了一个包含Unix操作系统所有的主要部件的环境，除了内核（内核是由Linux项目独立发展而来的）。GNU环境包括EMACS编辑器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。&lt;/p&gt;
&lt;p&gt;GNU为什么没有包含Unix内核，是因为GNU的开发策略。GNU计划是开发一个与Unix兼容的操作系统，在Unix系统内核已经非常完善的情况下，优先开发周边的应用程序，等自己的内核开发出来之后，直接替换掉内核即可。待大部分应用程序已经开发完毕的时候，GNU开始开发自己的内核，即GNU Hurd。但是GNU Hurd一直处于试验阶段，没有任何可用性，而这时刚好遇到了Linux的横空出世（1991.8.1 Linux发布0.0.1版，GNU Hurd1991.5月发布）。Linux作为内核，配合GNU丰富的应用程序，很自然的就结合在了一起，成为了风靡全球的GNU/Linux系统。&lt;/p&gt;
&lt;p&gt;实际上市面上所有的Linux发行版其实都应该叫做GNU/Linux发行版，关于GNU的详细信息可以参考官网&lt;a href=&quot;http://www.gnu.org/gnu/gnu.en.html&quot;&gt;GNU Operating System&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;posix&quot;&gt;POSIX&lt;/h4&gt;
&lt;p&gt;Portable Operating System Interface of Unix的缩写，定义了一套标准接口 - 操作系统为应用程序提供的接口。由于Unix系统的开放性，到了1988年，各种Unix系统满天飞，在一个系统上正常工作的应用程序不能移植到另一个系统上，这种不可移植性还往往还被大Unix厂商作为自己的卖点，极大地分裂和违背了Unix的初衷。为了统一这种乱象，出现了几种标准：AT&amp;amp;T成立了Unix international标准组织，几大厂商（DEC、HP、IBM等）成立了开放软件基金会（OSF, Open Software Foundation），而IEEE则发布了POSIX标准，这些标准的目的都是为了统一Unix的接口标准（但实际上，POSIX标准并不局限于Unix系统）。&lt;/p&gt;
&lt;p&gt;POSIX标准意在期望获得源码级别的软件可移植性，即为一个POSIX兼容的操作系统编写的程序，可以在任何其它POSIX兼容的操作系统上编译执行。&lt;/p&gt;
&lt;h4 id=&quot;bsd&quot;&gt;BSD&lt;/h4&gt;
&lt;p&gt;Berkeley Software Distribution，伯克利软件套件。&lt;/p&gt;
&lt;p&gt;AT&amp;amp;A的贝尔实验室在1971年发布了第一版的Unix Time Sharing System，到了1975年已经发布到第6版。1974年，加州大学伯克利分校（Berkeley）获取到一份Unix的源码拷贝，在此基础上做一些学术上的研究。1978年，Berkeley的Bill Joy，基于AT&amp;amp;T的Unix V6，增加了一些自己的附件软件，打包在一起发布了一个版本，这个版本就是第一版的BSD。&lt;/p&gt;
&lt;p&gt;1984年，Berkeley发布了第四版的BSD，该版本是世界上第一个支持TCP/IP的Unix发行版（同年，Bill Joy成立了SUN公司）&lt;/p&gt;
&lt;p&gt;BSD有几个比较有名的“分支”系统：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FreeBSD，主打高性能和易用性&lt;/li&gt;
&lt;li&gt;OpenBSD，主打安全性，很多银行系统和重要机构的系统都是基于OpenBSD&lt;/li&gt;
&lt;li&gt;NetBSD，被设计为几乎可用在任何架构上，支持非常多的体系结构&lt;/li&gt;
&lt;li&gt;DragonFly BSD，适用于多线程环境的操作系统，如计算机集群&lt;/li&gt;
&lt;li&gt;Darwin/Mac OS X，Mac OS X基于Darwin操作系统，而Darwin基于BSD。苹果在BSD的基础上开发了MAC OS X和IOS（内核使用开源的BSD代码，其它大部分是闭源的Mac OS代码），类似于谷歌在Linux基础上开发Android&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在今天，提到BSD，并非指任何一个BSD的衍生版本，而是指类Unix操作系统的一个分支的总称。&lt;/p&gt;
&lt;h4 id=&quot;system-v&quot;&gt;System V&lt;/h4&gt;
&lt;p&gt;Unix操作系统在操作风格上主要分为System V和BSD。System V由AT&amp;amp;T发布，1983年发布了第一个版本，直到1998年发布了第四个版本，也是最经典的一个版本，简称SVR4。1985年，AT&amp;amp;A发布了SVID（SystemV Interface Definition），希望统一Unix的接口标准（目标和POSIX类似）。&lt;/p&gt;
&lt;h4 id=&quot;macos&quot;&gt;MacOS&lt;/h4&gt;
&lt;p&gt;MacOS最终可以追溯到BSD分支，其大致演化过程为：&lt;/p&gt;
&lt;p&gt;BSD4.2(1983.9) -&amp;gt; Mach(1986) -&amp;gt; NeXTSTEP 1.0(1989.9) -&amp;gt; Mac OS X 10.0(2001.3)&lt;/p&gt;
&lt;p&gt;1986年，Rick Rashid及其同事在Carnegie Mellon大学创造了Mach操作系统的第一个版本，用于取代BSD的Unix内核。&lt;/p&gt;
&lt;p&gt;2001年，Apple 发布 Mac OS X，这是一个基于Mach内核和BSD开发的桌面操作系统。&lt;/p&gt;
&lt;h4 id=&quot;android&quot;&gt;Android&lt;/h4&gt;
&lt;p&gt;Android系统是基于Linux系统发展而来的。在Linux的内核上运行了一个Java虚拟机（最开始叫Dalvik虚拟机，后面改为Android Run Time，ART虚拟机），由虚拟机来解释执行用java代码编写的应用程序。&lt;/p&gt;
&lt;h4 id=&quot;开源&quot;&gt;开源&lt;/h4&gt;
&lt;p&gt;从Unix诞生开始，就伴随着开源的概念。开源全称是Open Source，是开放源代码的意思，也就意味着开放，任何人都可以得到程序的源代码。但是开源并不意味着免费（虽然大部分都是免费），也是受限于版权限制的，只是这些版权相对闭源来说要开放宽松了很多。在版权限制范围内，可以基于源代码做修改并重新发行，甚至收费。开源的本质是在开放，是接纳、包容和发展，求同存异，互利共赢。&lt;/p&gt;
&lt;h4 id=&quot;许可证&quot;&gt;许可证&lt;/h4&gt;
&lt;p&gt;开源并非是无限制的开放，也是有版权的，这些版权的声明就是开源许可证。比较常见的许可证有：GPL、BSD、Apache、MIT、LGPL、Mozilla等。下图根据网上搜索的信息简单整理了一下各许可证的主要许可范围，从图中可以看到MIT许可证是最宽松的，而GPL是相对比较严格的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pnglgo7yi.bkt.clouddn.com/Open%20Source%20License.jpg&quot; alt=&quot;image-20190319010021235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面分别简单介绍上面几种许可证的特点：&lt;/p&gt;
&lt;ul readability=&quot;14&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;GPL，GNU General Public License，其主要特点在于其“传染性”，只要软件中有使用了GPL协议的产品，包括直接引用源代码或者引用修改后的衍生代码，则该软件也必须采用GPL协议，开源和免费，不允许衍生代码作为商业软件发布和销售。Linux和大部分GNU产品都是采用的GPL协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;LGPL，GNU Library or “Lesser” General Public License，允许商业软件通过引用类库的方式使用LGPL产品，而不需要公开软件的源代码。新增的代码不需要采用LGPL协议，但是修改的代码则必须采用LGPL协议。LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。使用LGPL协议的比较有名的产品有JBoss、Hibernate、FCKeditor等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;BSD，Berkeley Software Distribution，BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。&lt;/p&gt;
&lt;p&gt;当使用了BSD协议的代码，或者以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议&lt;/li&gt;
&lt;li&gt;如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议&lt;/li&gt;
&lt;li&gt;不可以用开源代码的作者/机构名字和原来产品的名字做市场推广&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;很多公司企业在选择开源软件的时候都首选BSD协议，因为可以完全控制这些第三方的代码，而且在必要的时候可以进行修改或者二次开发。使用BSD协议的比较有名的产品有nginx、CruiseControl、Redis等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;MIT，MIT License，是最为宽松的协议，这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息，比较适用商业软件。使用MIT协议的产品如jquery、Node.js等&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Apache License，是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布(作为开源或商业软件)。需要满足的条件也和BSD类似：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要给代码的用户一份Apache Licence&lt;/li&gt;
&lt;li&gt;如果你修改了代码，需要在被修改的文件中说明&lt;/li&gt;
&lt;li&gt;在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明&lt;/li&gt;
&lt;li&gt;如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;MPL，Mozilla Public License，允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL允许修改和无偿使用，对链接没有要求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有其它形形色色的开源协议，详情可以参考&lt;a href=&quot;https://www.gnu.org/licenses/license-list.en.html&quot;&gt;Various Licenses and Comments about Them&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;参考&quot;&gt;参考&lt;/h4&gt;
</description>
<pubDate>Mon, 18 Mar 2019 19:19:00 +0000</pubDate>
<dc:creator>justinme</dc:creator>
<og:description>欢迎来到Unix的世界 很多人都用了很多年的Unix（其实更熟悉的是叫Linux），也接触到Unix世界中的各种概念，比如GCC、GNU、BSD、POSIX、GPL等等，也大都知道一些传奇的如雷贯耳的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/justinme/p/10556291.html</dc:identifier>
</item>
<item>
<title>【MySQL 】MySQL 中的 int(11) 到底代表什么意思？ - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10556206.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10556206.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; class=&quot;output_wrapper&quot; readability=&quot;69.881710646042&quot;&gt;
&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10556206.html#h&quot;&gt;一、前言&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10556206.html#h-1&quot;&gt;二、简介&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10556206.html#h-2&quot;&gt;三、结论&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10556206.html#h-3&quot;&gt;四、参考链接&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  在工作中经常要与 mysql 打交道，但是对 mysql 的各个字段类型一直都是一知半解，因此写本文总结记录一番。&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;&lt;strong&gt;二、简介&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/19/An8X3n.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;  对于 int 类型的一些基础知识其实上图已经说的很明白了，在这里想讨论下常用的 int(11) 代表什么意思，很长时间以来我都以为这代表着限制 int 的长度为 11 位，直到有天看到篇文章才明白，11 代表的并不是长度，而是&lt;code&gt;字符的显示宽度&lt;/code&gt;，在字段类型为 int 时，无论你显示宽度设置为多少，int 类型能存储的最大值和最小值永远都是固定的，这里贴一些原文片段。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;  The number in the parenthesis does not determines the max and min values that can be stored in the integer field. The max and min values that can be stored are always fixed.&lt;br/&gt;  The display width of the column does not affects the maximum value that can be stored in that column. A column with INT(5) or INT(11) can store the same maximum values. Also, if you have a column INT(20) that does not means that you will be able to store 20 digit values (BIGINT values). The column still will store only till the max values of INT.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  那么照文中所说，所以无论怎么设置 int 类型的显示宽度，int 所能存储的最大值和最小值是固定的，那么这个显示宽度到底有什么用呢？&lt;br/&gt;  当 int 字段类型设置为无符号且填充零（UNSIGNED ZEROFILL）时，当数值位数未达到设置的显示宽度时，会在数值前面补充零直到满足设定的显示宽度，为什么会有无符号的限制呢，是因为 ZEROFILL 属性会隐式地将数值转为无符号型，因此不能存储负的数值。&lt;/p&gt;
&lt;p&gt;  具体用以下代码解释。&lt;/p&gt;
&lt;p&gt;首先创建一张表：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;TABLE&lt;/span&gt; int_demo (&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;br/&gt;a &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;b &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;11&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;UNSIGNED&lt;/span&gt; ZEROFILL &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;c &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;d &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;UNSIGNED&lt;/span&gt; ZEROFILL &lt;span class=&quot;hljs-keyword&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;e &lt;span class=&quot;hljs-built_in&quot;&gt;INT&lt;/span&gt;(&lt;span class=&quot;hljs-number&quot;&gt;15&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;NULL&lt;/span&gt;,&lt;br/&gt;PRIMARY &lt;span class=&quot;hljs-keyword&quot;&gt;KEY&lt;/span&gt; (&lt;span class=&quot;hljs-string&quot;&gt;`id`&lt;/span&gt;)&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;插入两条数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; int_demo (a, b, c, d, e) &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;INSERT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;INTO&lt;/span&gt; int_demo (a, b, c, d, e) &lt;span class=&quot;hljs-keyword&quot;&gt;VALUES&lt;/span&gt; (&lt;span class=&quot;hljs-number&quot;&gt;1234567890&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1234567890&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1234567890&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1234567890&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1234567890&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;select * from int_demo;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/19/An8O9s.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;code&gt;注释&lt;/code&gt;：如果用 navicate 软件查询出来并不会显示左边的 0，但把数据导出时可看到真实的数据，猜测是软件对数据格式进行了处理。&lt;/p&gt;
&lt;h2 id=&quot;h-2&quot;&gt;&lt;span&gt;&lt;strong&gt;三、结论&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;从上个例子我们可以得出以下几个结论：&lt;/p&gt;
&lt;p&gt;  1、&lt;code&gt;如果一个字段设置了无符号和填充零属性，那么无论这个字段存储什么数值，数值的长度都会与设置的显示宽度一致&lt;/code&gt;，如上述例子中的字段 b，插入数值 1 显示为00000000001，左边补了 10 个零直至长度达到 11 位；&lt;/p&gt;
&lt;p&gt;  2、&lt;code&gt;设置字段的显示宽度并不限制字段存储值的范围&lt;/code&gt;，比如字段 d 设置为 int(5)，但是仍然可以存储 1234567890 这个 10 位数字；&lt;/p&gt;
&lt;p&gt;  3、&lt;code&gt;设置的字符宽度只对数值长度不满足宽度时有效&lt;/code&gt;，如 d 字段 int(5)，插入 1 时，长度不足 5，因此在左边补充 4 个零直到 5 位，但是插入 1234567890 时超过了 5 位，这时的显示宽度就起不了作用了。&lt;/p&gt;
&lt;h2 id=&quot;h-3&quot;&gt;&lt;span&gt;&lt;strong&gt;四、参考链接&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;https://segmentfault.com/a/1190000012479448&quot; target=&quot;_blank&quot;&gt;https://segmentfault.com/a/1190000012479448&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 18 Mar 2019 16:34:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>一、前言二、简介三、结论四、参考链接 一、前言 在工作中经常要与 mysql 打交道，但是对 mysql 的各个字段类型一直都是一知半解，因此写本文总结记录一番。 二、简介 对于 int 类型的一些基</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10556206.html</dc:identifier>
</item>
<item>
<title>【源码学习】redux-thunk - wenruo</title>
<link>http://www.cnblogs.com/wenruo/p/10239708.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenruo/p/10239708.html</guid>
<description>&lt;p&gt;阅读 redux 源码之后，想要加深一下对中间件的理解，于是选择 &lt;a href=&quot;https://github.com/reduxjs/redux-thunk&quot; target=&quot;_blank&quot;&gt;redux-thunk&lt;/a&gt;（2.3.0）这个源码只有十几行的中间件。&lt;/p&gt;
&lt;p&gt;之前 redux 的学习笔记 &lt;a href=&quot;https://www.cnblogs.com/wenruo/p/9664375.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wenruo/p/9664375.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;redux 中的 &lt;span class=&quot;final-path&quot;&gt;applyMiddleware.js&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; applyMiddleware(...middlewares) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; createStore =&amp;gt; (...args) =&amp;gt;&lt;span&gt; {
    const store &lt;/span&gt;=&lt;span&gt; createStore(...args)
    let dispatch &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Error(
        `Dispatching &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; constructing your middleware is not allowed. ` +&lt;span&gt;
          `Other middleware would not be applied to &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt; dispatch.`
      )
    }

    const middlewareAPI &lt;/span&gt;=&lt;span&gt; {
      getState: store.getState,
      dispatch: (...args) &lt;/span&gt;=&amp;gt;&lt;span&gt; dispatch(...args)
    }
    const chain &lt;/span&gt;= middlewares.map(middleware =&amp;gt;&lt;span&gt; middleware(middlewareAPI))
    dispatch &lt;/span&gt;=&lt;span&gt; compose(...chain)(store.dispatch)

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; {
      ...store,
      dispatch
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每个中间件需要传入 store（只有 getState 和 dispatch）和 next（由上一个中间处理过的 dispatch）&lt;/p&gt;
&lt;p&gt;在生成 dispatch 的时候 传入的  &lt;span class=&quot;cnblogs_code&quot;&gt;middlewareAPI&lt;/span&gt; 中的 dispatch 是一个只抛出异常的函数，用来提示在创建 dispatch 的时候， 中间件不应该使用 dispatch 。&lt;/p&gt;
&lt;p&gt;创建后又将 dispatch 赋值为经过中间件生成的函数。这时&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
const middlewareAPI =&lt;span&gt; {
    getState: store.getState,
    dispatch: (...args) &lt;/span&gt;=&amp;gt;&lt;span&gt; dispatch(...args)
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;中 &lt;span class=&quot;cnblogs_code&quot;&gt;middlewareAPI.dispatch&lt;/span&gt; 就变成了最新的 dispatch 所以在中间件中可以使用 dispatch、&lt;/p&gt;

&lt;p&gt;接下来可以看 redux-thunk 的源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createThunkMiddleware(extraArgument) {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; action === 'function'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; action(dispatch, getState, extraArgument);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next(action);
  };
}

const thunk &lt;/span&gt;=&lt;span&gt; createThunkMiddleware();
thunk.withExtraArgument &lt;/span&gt;=&lt;span&gt; createThunkMiddleware;

export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; thunk;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用时可以是 &lt;span class=&quot;cnblogs_code&quot;&gt;applyMiddleware(thunk)&lt;/span&gt; 或者 &lt;span class=&quot;cnblogs_code&quot;&gt;applyMiddleware(thunk.withExtraArgument(api))&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;如果是默认的 thunk 那么中间件的函数为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const thunk = ({ dispatch, getState }) =&amp;gt; next =&amp;gt; action =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; action === 'function'&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; action(dispatch, getState);
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next(action);
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果是函数 就传入 dispatch 和 getState 否则就执行默认的 next &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
let store =&lt;span&gt; createStore(reducer, applyMiddleware(thunk));
let action &lt;/span&gt;= (dispatch) =&amp;gt;&lt;span&gt; {
    ajax(options).then((res) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        dispatch({ type: &lt;/span&gt;'change'&lt;span&gt;, content: res.data });
    })
}
store.dispatch(action);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样对于异步的操作就可以在 redux 中使用了~&lt;/p&gt;

</description>
<pubDate>Mon, 18 Mar 2019 16:29:00 +0000</pubDate>
<dc:creator>wenruo</dc:creator>
<og:description>阅读 redux 源码之后，想要加深一下对中间件的理解，于是选择 redux-thunk（2.3.0）这个源码只有十几行的中间件。 之前 redux 的学习笔记 https://w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenruo/p/10239708.html</dc:identifier>
</item>
<item>
<title>wiringPi库的pwm配置及使用说明 - ba哥</title>
<link>http://www.cnblogs.com/miaoxiong/p/10556072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miaoxiong/p/10556072.html</guid>
<description>&lt;p&gt;本文介绍树莓派（raspberry pi）在linux c 环境下的硬件pwm配置及使用方法。&lt;/p&gt;
&lt;h2&gt;1. 下载安装wiringPi&lt;/h2&gt;
&lt;p&gt;此步骤建议参考官网指南 http://wiringpi.com/download-and-install/，wiringPi提供了对树莓派的硬件IO访问，包括GPIO/I2C/PWM等&lt;br/&gt;下载安装后，本地会出现wiringpI文件夹，根目录下有/examples 可供参考。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/501870/201903/501870-20190318234455679-722323835.png&quot; alt=&quot;&quot; width=&quot;353&quot; height=&quot;248&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2. 树莓派PWM硬件&lt;/h2&gt;
&lt;p&gt;以raspberry pi 3b 为例，尝试在命令行下输入 pinout，可查看当前pi的io映射图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/501870/201903/501870-20190318234723179-640681366.png&quot; alt=&quot;&quot; width=&quot;353&quot; height=&quot;691&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是当前pi的gpio布局，却不是wiringPi的IO映射表，因此参考时需注意，好在在网上找到一张raspberry 3b的wiringpi io映射表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/501870/201903/501870-20190318234844976-579206953.png&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;674&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中的gpio1(pwm0) 及 gpio23(pwm1) 即为我们需要传输给wiringpi的硬件pwm输出脚&lt;/p&gt;
&lt;h2&gt;3. wiringPi pwm 接口说明&lt;/h2&gt;
&lt;p&gt;在examples/pwm.c 或 wiringPi/wiringPi.c中可查看pwm的相关接口，但却没有详细的调用说明，经过一番查阅，得出接口的使用方法为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pwmSetClock()：设置pwm的工作时钟。19.2MHz晶振为pwm提供时钟输入，wiringpi在初始化gpio时默认采用32倍分频(参考wiringPI.c 中的pinMode() 代码)，因此不调用此函数，pwm的默认工作时钟为600KHz.&lt;/li&gt;
&lt;li&gt;pwmSetRange()：设置pwm的输出周期。以600KHz的工作时钟为例，假设pwm输出频率为freq，则range = 600000/freq.&lt;/li&gt;
&lt;li&gt;pwmSetMode()：设置pwm的工作模式，wiringPi.h头文件中包含此2种模式 PWM_MODE_MS/PWM_MODE_BAL，但并未做任何解释。。.那就看手册《BCM2837-ARM-Peripherals.pdf》吧&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/501870/201903/501870-20190318235226967-679067267.png&quot; alt=&quot;&quot; width=&quot;624&quot; height=&quot;812&quot;/&gt;&lt;em&gt;&lt;em readability=&quot;1.5&quot;&gt;&lt;em readability=&quot;3&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/501870/201903/501870-20190318235330940-1721311921.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;245&quot;/&gt;&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;从描述来看，MSEN=0似乎用来传输N/M数据， MSEN=1才是设置占空比输出，因此处的pwm输出模式选择PWM_MODE_MS&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;/&gt;&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;pwmWrite()：设置pwm的输出占空比。因为一个周期长度为range，因此占空比的范围为0～range.&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 18 Mar 2019 16:00:00 +0000</pubDate>
<dc:creator>ba哥</dc:creator>
<og:description>本文介绍树莓派（raspberry pi）在linux c 环境下的硬件pwm配置及使用方法。 1. 下载安装wiringPi 此步骤建议参考官网指南 http://wiringpi.com/down</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/miaoxiong/p/10556072.html</dc:identifier>
</item>
<item>
<title>redis启动过程源码解析 - killianxu</title>
<link>http://www.cnblogs.com/killianxu/p/10556076.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/killianxu/p/10556076.html</guid>
<description>&lt;p&gt;  redis整个程序的入口函数在server.c中的main函数,函数调用关系如下图1,调用顺序为从上到下,从左至右。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1497240/201903/1497240-20190318233212697-1921571180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1 redis启动函数调用图&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  main函数源码如下,1-55行根据配置文件和启动命令参数设置全局对象server ,57-59设置redis的服务器端为后台进程, initServer主要提前创建一些经常用到的对象用于节约内存,根据设置的ip地址和端口创建监听套接字用于客户端连接,并初始化时间事件,64行用于设置server-&amp;gt;el -&amp;gt;beforesleep = beforesleep,aeMain函数是个循环函数,用于监听客户端连接，接收客户端命令并进行处理等。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;整个程序的入口函数&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; **&lt;span&gt;argv) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化服务器配置,设置全局对象server的状态&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    initServerConfig();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Store the executable path and arguments in a safe place in order
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * to be able to restart the server later. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;存储运行命令的绝对路径及运行参数&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     server.executable = getAbsolutePath(argv[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     server.exec_argv = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(&lt;span&gt;char&lt;/span&gt;*)*(argc+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     server.exec_argv[argc] =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; argc; j++) server.exec_argv[j] =&lt;span&gt; zstrdup(argv[j]);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (argc &amp;gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         j = &lt;span&gt;1&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; First option to parse in argv[] &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         sds options =&lt;span&gt; sdsempty();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;char&lt;/span&gt; *configfile =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;命令指定了配置文件,对配置文件做处理,配置文件跟在程序名后第一位&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; First argument is the config file name? &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (argv[j][&lt;span&gt;0&lt;/span&gt;] != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; || argv[j][&lt;span&gt;1&lt;/span&gt;] != &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             configfile =&lt;span&gt; argv[j];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             server.configfile =&lt;span&gt; getAbsolutePath(configfile);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Replace the config file in server.exec_argv with
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;             * its absolute path. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            zfree(server.exec_argv[j]);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             server.exec_argv[j] =&lt;span&gt; zstrdup(server.configfile);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; All the other options are parsed and conceptually appended to the
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;         * configuration file. For instance --port 6380 will generate the
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;         * string &quot;port 6380\n&quot; to be parsed after the actual file name
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;         * is parsed, if any. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt;(j != argc) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析除配置文件外的其它参数&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (argv[j][&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &amp;amp;&amp;amp; argv[j][&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Option name &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!strcmp(argv[j], &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--check-rdb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Argument has no options, need to skip for parsing. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                     j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (sdslen(options)) options = sdscat(options,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 options = sdscat(options,argv[j]+&lt;span&gt;2&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;去掉参数前面的--&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 options = sdscat(options,&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;参数对应的值和参数名应&quot; &quot;分隔&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Option argument &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;                 options =&lt;span&gt; sdscatrepr(options,argv[j],strlen(argv[j]));
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 options = sdscat(options,&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             j++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;从指定配置文件和命令选项设置服务器对象server参数,覆盖默认配置&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        loadServerConfig(configfile,options);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;     server.supervised =&lt;span&gt; redisIsSupervised(server.supervised_mode);
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; background = server.daemonize &amp;amp;&amp;amp; !&lt;span&gt;server.supervised;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (background) daemonize();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;后台进程模式
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化服务器功能,包括时间事件1ms调用serverCron,文件事件(套接字可读可写时的处理函数)，集群初始化等&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    initServer();
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     aeSetBeforeSleepProc(server.el,beforeSleep);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置beforeSleep事件处理函数&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;     aeSetAfterSleepProc(server.el,afterSleep);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置aftersleep事件处理函数&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;     aeMain(server.el);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;循环,接受客户端连接,处理命令等&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     aeDeleteEventLoop(server.el);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;退出循环,删除事件处理&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;  initServer函数源码如下,主要对server中的变量进行初始化,其中listenToPort根据监听的地址和端口, 设置server.ipfd(监听套接字数组)和server.ipfd_count(监听套接字数目),85行aeCreateTimeEvent设置定时器事件,每1ms执行serverCron函数,94行aeCreateFileEvent函数设置监听套接字有客户端连接时执行的事件处理函数acceptTcpHandler。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initServer(&lt;span&gt;void&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     server.hz =&lt;span&gt; server.config_hz;
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;     server.pid =&lt;span&gt; getpid();
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;     server.current_client =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;     server.clients =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;     server.clients_index =&lt;span&gt; raxNew();
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     server.clients_to_close =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;     server.slaves =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;     server.monitors =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     server.clients_pending_write =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;     server.slaveseldb = -&lt;span&gt;1&lt;/span&gt;; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Force to emit the first SELECT command. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt;     server.unblocked_clients =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;     server.ready_keys =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     server.clients_waiting_acks =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     server.get_ack_from_slaves = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     server.clients_paused = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     server.system_memory_size =&lt;span&gt; zmalloc_get_memory_size();
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建常用字符串,比如命令回复pong及命令字符串等&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; &lt;span&gt;    createSharedObjects();
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据配置的最大连接客户端数和CONFIG_MIN_RESERVED_FDS(用于监听、日志文件等文件描述符)设置最大允许打开的文件描述符数&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;    adjustOpenFilesLimit();
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化aeEventLoop对象并赋值给server中的指针变量el&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt;     server.el = aeCreateEventLoop(server.maxclients+&lt;span&gt;CONFIG_FDSET_INCR);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;     server.db = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(redisDb)*&lt;span&gt;server.dbnum);
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Open the TCP listening socket for the user commands. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于创建监听文件描述符&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (server.port != &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp;
&lt;span&gt; 30&lt;/span&gt;         listenToPort(server.port,server.ipfd,&amp;amp;server.ipfd_count) ==&lt;span&gt; C_ERR)
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Create the Redis databases, and initialize other internal state. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; server.dbnum; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;         server.db[j].dict = dictCreate(&amp;amp;&lt;span&gt;dbDictType,NULL);
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;         server.db[j].expires = dictCreate(&amp;amp;&lt;span&gt;keyptrDictType,NULL);
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt;         server.db[j].blocking_keys = dictCreate(&amp;amp;&lt;span&gt;keylistDictType,NULL);
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         server.db[j].ready_keys = dictCreate(&amp;amp;&lt;span&gt;objectKeyPointerValueDictType,NULL);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;         server.db[j].watched_keys = dictCreate(&amp;amp;&lt;span&gt;keylistDictType,NULL);
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         server.db[j].id =&lt;span&gt; j;
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;         server.db[j].avg_ttl = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         server.db[j].defrag_later =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建lru池,内存超过设置的值时,根据淘汰策略,清除部分key&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;     evictionPoolAlloc(); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Initialize the LRU keys pool. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;     server.pubsub_channels = dictCreate(&amp;amp;&lt;span&gt;keylistDictType,NULL);
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;     server.pubsub_patterns =&lt;span&gt; listCreate();
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;    listSetFreeMethod(server.pubsub_patterns,freePubsubPattern);
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;    listSetMatchMethod(server.pubsub_patterns,listMatchPubsubPattern);
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     server.cronloops = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;     server.rdb_child_pid = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;     server.aof_child_pid = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;     server.rdb_child_type =&lt;span&gt; RDB_CHILD_TYPE_NONE;
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;     server.rdb_bgsave_scheduled = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;     server.child_info_pipe[&lt;span&gt;0&lt;/span&gt;] = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;     server.child_info_pipe[&lt;span&gt;1&lt;/span&gt;] = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;     server.child_info_data.magic = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;    aofRewriteBufferReset();
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;     server.aof_buf =&lt;span&gt; sdsempty();
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;     server.lastsave = time(NULL); &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; At startup we consider the DB saved. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;     server.lastbgsave_try = &lt;span&gt;0&lt;/span&gt;;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; At startup we never tried to BGSAVE. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 62&lt;/span&gt;     server.rdb_save_time_last = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;     server.rdb_save_time_start = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;     server.dirty = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;    resetServerStats();
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; A few stats we don't want to reset: server startup time, and peak mem. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 67&lt;/span&gt;     server.stat_starttime =&lt;span&gt; time(NULL);
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;     server.stat_peak_memory = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;     server.stat_rdb_cow_bytes = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;     server.stat_aof_cow_bytes = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;     server.cron_malloc_stats.zmalloc_used = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;     server.cron_malloc_stats.process_rss = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;     server.cron_malloc_stats.allocator_allocated = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;     server.cron_malloc_stats.allocator_active = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt;     server.cron_malloc_stats.allocator_resident = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     server.lastbgsave_status =&lt;span&gt; C_OK;
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;     server.aof_last_write_status =&lt;span&gt; C_OK;
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;     server.aof_last_write_errno = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 79&lt;/span&gt;     server.repl_good_slaves_count = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Create the timer callback, this is our way to process many background
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;     * operations incrementally, like clients timeout, eviction of unaccessed
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;     * expired keys and so forth. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建时间事件,1ms调用serverCron&lt;/span&gt;
&lt;span&gt; 85&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (aeCreateTimeEvent(server.el, &lt;span&gt;1&lt;/span&gt;, serverCron, NULL, NULL) ==&lt;span&gt; AE_ERR) {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         serverPanic(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Can't create event loop timers.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt;         exit(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; 
&lt;span&gt; 90&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Create an event handler for accepting new connections in TCP and Unix
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;     * domain sockets. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设定套接字可读可写状态的处理函数&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; server.ipfd_count; j++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE,
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             acceptTcpHandler,NULL) ==&lt;span&gt; AE_ERR)
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; &lt;span&gt;                serverPanic(
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Unrecoverable error creating server.ipfd file event.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;  listenToPort函数会对所有配置需要监听的ip地址和端口调用_anetTcpServer函数(anet.c), _anetTcpServer函数源码如下,1-17行建立socket套接字s,23行调用函数anetListen完成服务端socket的bind和listen。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _anetTcpServer(&lt;span&gt;char&lt;/span&gt; *err, &lt;span&gt;int&lt;/span&gt; port, &lt;span&gt;char&lt;/span&gt; *bindaddr, &lt;span&gt;int&lt;/span&gt; af, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; backlog)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; s = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, rv;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;char&lt;/span&gt; _port[&lt;span&gt;6&lt;/span&gt;];  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; strlen(&quot;65535&quot;) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt; addrinfo hints, *servinfo, *&lt;span&gt;p;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     snprintf(_port,&lt;span&gt;6&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,port);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     memset(&amp;amp;hints,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(hints));
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     hints.ai_family =&lt;span&gt; af;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     hints.ai_socktype =&lt;span&gt; SOCK_STREAM;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     hints.ai_flags = AI_PASSIVE;    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; No effect if bindaddr != NULL &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; ((rv = getaddrinfo(bindaddr,_port,&amp;amp;hints,&amp;amp;servinfo)) != &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         anetSetError(err, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, gai_strerror(rv));
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ANET_ERR;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (p = servinfo; p != NULL; p = p-&amp;gt;&lt;span&gt;ai_next) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((s = socket(p-&amp;gt;ai_family,p-&amp;gt;ai_socktype,p-&amp;gt;ai_protocol)) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (af == AF_INET6 &amp;amp;&amp;amp; anetV6Only(err,s) == ANET_ERR) &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (anetSetReuseAddr(err,s) == ANET_ERR) &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;anetListen调用listen和bind&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (anetListen(err,s,p-&amp;gt;ai_addr,p-&amp;gt;ai_addrlen,backlog) == ANET_ERR) s =&lt;span&gt; ANET_ERR;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; end;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (p ==&lt;span&gt; NULL) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         anetSetError(err, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unable to bind socket, errno: %d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, errno);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;goto&lt;/span&gt;&lt;span&gt; error;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;error:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (s != -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) close(s);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     s =&lt;span&gt; ANET_ERR;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;end:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    freeaddrinfo(servinfo);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;  anetListen函数源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; anetListen(&lt;span&gt;char&lt;/span&gt; *err, &lt;span&gt;int&lt;/span&gt; s, &lt;span&gt;struct&lt;/span&gt; sockaddr *sa, socklen_t len, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; backlog) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (bind(s,sa,len) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         anetSetError(err, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bind: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strerror(errno));
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        close(s);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ANET_ERR;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (listen(s, backlog) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         anetSetError(err, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;listen: %s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, strerror(errno));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        close(s);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ANET_ERR;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ANET_OK;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;  在分析aeCreateTimeEvent和aeCreateFileEvent函数之前,先给出server中的aeEventLoop类型变量el结构体定义(ae.h):&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; File event structure &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件事件结构体&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; aeFileEvent {
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/读或者写，也用于标识该事件结构体是否正在使用&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; mask; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; one of AE_(READABLE|WRITABLE|BARRIER) &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;读事件的处理函数&lt;/span&gt;
    aeFileProc *&lt;span&gt;rfileProc;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写事件的处理函数&lt;/span&gt;
    aeFileProc *&lt;span&gt;wfileProc;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递给上述两个函数的数据&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;clientData;
} aeFileEvent;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Time event structure &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间事件&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; aeTimeEvent {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间事件标识符，用于唯一标识该时间事件，并且用于删除时间事件&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; id; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; time event identifier. &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt; when_sec; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; seconds &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt; when_ms; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; milliseconds &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;事件对应的处理程序&lt;/span&gt;
    aeTimeProc *&lt;span&gt;timeProc;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间事件的最后一次处理程序，若已设置，则删除时间事件时会被调用&lt;/span&gt;
    aeEventFinalizerProc *&lt;span&gt;finalizerProc;
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;clientData;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; aeTimeEvent *&lt;span&gt;prev;
    &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt; aeTimeEvent *&lt;span&gt;next;
} aeTimeEvent;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; A fired event &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于保存已触发的事件&lt;/span&gt;
typedef &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; aeFiredEvent {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; fd;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; mask;
} aeFiredEvent;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; State of an event based program &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
typedef &lt;/span&gt;&lt;span&gt;struct&lt;/span&gt;&lt;span&gt; aeEventLoop {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最大文件描述符&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; maxfd;   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; highest file descriptor currently registered &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件描述符的最大监听数&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; setsize; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; max number of file descriptors tracked &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成时间事件的唯一标识&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeEventNextId;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检测系统时钟偏差&lt;/span&gt;
    time_t lastTime;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Used to detect system clock skew &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;双向链表,注册文件事件&lt;/span&gt;
    aeFileEvent *events; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Registered events &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;已触发的文件事件&lt;/span&gt;
    aeFiredEvent *fired; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; Fired events &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注册的时间事件&lt;/span&gt;
    aeTimeEvent *&lt;span&gt;timeEventHead;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; stop;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理底层特定API的数据，对于epoll来说，该结构体包含了epoll fd和epoll_event&lt;/span&gt;
    &lt;span&gt;void&lt;/span&gt; *apidata; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; This is used for polling API specific data &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    aeBeforeSleepProc &lt;/span&gt;*&lt;span&gt;beforesleep;
    aeBeforeSleepProc &lt;/span&gt;*&lt;span&gt;aftersleep;
} aeEventLoop;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;  函数aeCreateTimeEvent(ae.c)用于往server中的变量el时间事件队列添加元素,源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; aeCreateTimeEvent(aeEventLoop *eventLoop, &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; milliseconds,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         aeTimeProc *proc, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;clientData,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         aeEventFinalizerProc *&lt;span&gt;finalizerProc)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; id = eventLoop-&amp;gt;timeEventNextId++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     aeTimeEvent *&lt;span&gt;te;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     te = zmalloc(&lt;span&gt;sizeof&lt;/span&gt;(*&lt;span&gt;te));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (te == NULL) &lt;span&gt;return&lt;/span&gt;&lt;span&gt; AE_ERR;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     te-&amp;gt;id =&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     aeAddMillisecondsToNow(milliseconds,&amp;amp;te-&amp;gt;when_sec,&amp;amp;te-&amp;gt;&lt;span&gt;when_ms);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     te-&amp;gt;timeProc =&lt;span&gt; proc;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     te-&amp;gt;finalizerProc =&lt;span&gt; finalizerProc;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     te-&amp;gt;clientData =&lt;span&gt; clientData;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     te-&amp;gt;prev =&lt;span&gt; NULL;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     te-&amp;gt;next = eventLoop-&amp;gt;&lt;span&gt;timeEventHead;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (te-&amp;gt;&lt;span&gt;next)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         te-&amp;gt;next-&amp;gt;prev =&lt;span&gt; te;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     eventLoop-&amp;gt;timeEventHead =&lt;span&gt; te;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; id;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;  aeCreateFileEvent(ae.c)函数用于server.el增加文件事件队列添加元素,源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; aeApiAddEvent(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mask) {
    aeApiState &lt;/span&gt;*state = eventLoop-&amp;gt;&lt;span&gt;apidata;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mask &amp;amp; AE_READABLE) FD_SET(fd,&amp;amp;state-&amp;gt;&lt;span&gt;rfds);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mask &amp;amp; AE_WRITABLE) FD_SET(fd,&amp;amp;state-&amp;gt;&lt;span&gt;wfds);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; aeCreateFileEvent(aeEventLoop *eventLoop, &lt;span&gt;int&lt;/span&gt; fd, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; mask,
        aeFileProc &lt;/span&gt;*proc, &lt;span&gt;void&lt;/span&gt; *&lt;span&gt;clientData)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fd &amp;gt;= eventLoop-&amp;gt;&lt;span&gt;setsize) {
        errno &lt;/span&gt;=&lt;span&gt; ERANGE;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; AE_ERR;
    }
    aeFileEvent &lt;/span&gt;*fe = &amp;amp;eventLoop-&amp;gt;&lt;span&gt;events[fd];

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (aeApiAddEvent(eventLoop, fd, mask) == -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; AE_ERR;
    fe&lt;/span&gt;-&amp;gt;mask |=&lt;span&gt; mask;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mask &amp;amp; AE_READABLE) fe-&amp;gt;rfileProc =&lt;span&gt; proc;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mask &amp;amp; AE_WRITABLE) fe-&amp;gt;wfileProc =&lt;span&gt; proc;
    fe&lt;/span&gt;-&amp;gt;clientData =&lt;span&gt; clientData;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fd &amp;gt; eventLoop-&amp;gt;&lt;span&gt;maxfd)
        eventLoop&lt;/span&gt;-&amp;gt;maxfd =&lt;span&gt; fd;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; AE_OK;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;  执行完initServer及aeSetBeforeSleepProc和aeSetAfterSleepProc函数设置好全局变量server后,进程调用aeMain函数进入循环,开始接收客户端连接和命令交互。aeMain(ae.c)函数源码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理客户端命令的主函数，由main函数调用,aeEventLoop定义在(ae.h),beforesleep和aftersleep均在服务器启动初始化时设定&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; aeMain(aeEventLoop *&lt;span&gt;eventLoop) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     eventLoop-&amp;gt;stop = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (!eventLoop-&amp;gt;&lt;span&gt;stop) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (eventLoop-&amp;gt;beforesleep !=&lt;span&gt; NULL)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             eventLoop-&amp;gt;&lt;span&gt;beforesleep(eventLoop);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;处理文件时间及时间事件&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         aeProcessEvents(eventLoop, AE_ALL_EVENTS|&lt;span&gt;AE_CALL_AFTER_SLEEP);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 18 Mar 2019 15:47:00 +0000</pubDate>
<dc:creator>killianxu</dc:creator>
<og:description>大部分人在用开源软件的时候,并不知道一个优秀的开源软件内部是如何启动起来的,本文通过分析redis启动过程的源码,来学习优秀软件的启动过程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/killianxu/p/10556076.html</dc:identifier>
</item>
<item>
<title>如何从小白到合格的区块链工程师：写在前面的一些话 - Rocky Ren</title>
<link>http://www.cnblogs.com/renyanlei/p/10556054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renyanlei/p/10556054.html</guid>
<description>&lt;p&gt;&lt;span&gt;      &lt;span&gt; 年前，我所在的公司成立了一个区块链事业部，我被委派为这个事业部的研发经理。2019年，我们要为公司的上下游企业利用区块链技术来做一套“通证（Token）”化的区块链系统。为上下游这些公司消除商业摩擦，并且在区块链系统上可以进行去中心化的价值转移和流通。得到命令后，我负责筹备了新部门的建设。年后和HR合作开始招聘区块链工程师，大概需要4~5个职位。可惜时间过了将近一个月，HR也邀约来了几个面试的工程师，竟然没有一个符合用工条件的。上周一，早上公司按照惯例开了例会，老板在会上对我的工作很不满意，进度延误严重。（我去，如果钱能在多给一些，肯定会招的到啊，但是我又不敢怼他）。于是，在会议上我向老板提议，将年后刚来公司的大学实习生转到我的部门来，我一边给他们培训区块链技能，一边带着他们做公司的项目，争取在未来几个月内将他们培养成合格的区块链工程师（鉴于我以前曾经有过在培训机构做讲师的经验）。据理力争后老板也答应了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        鉴于目前区块链技术在国内外在大环境下比较风潮。国内掌握区块链技术的工程师也比较少。我决定将我这次给公司内训的过程全部公开（当然，涉及到公司商业化的部分因为隐私问题不会开放）。只专注于我是如何将公司这几个小白大学生培养成掌握区块链编程技术的工程师的过程。最近几天，我把自己的知识图谱总结了一遍，也参考了很多外界培训机构的课程大纲，总结出了我这次要培训的主要内容来供大家参考。如果院子里有想学习区块链的朋友或者想加入我们团队的区块链高手欢迎和我联系（待遇私聊）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;大纲内容如下（大纲在后期我会慢慢补充，现在是个大概的）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一阶段： Golang语言开发以及高并发服务器编程（12天）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二阶段： Golang语言的去中心化前端开发和Web服务器开发（10天）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三阶段：如何用golang语言来开发一条区块链公链（7天）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四阶段：以太坊智能合约与DApp开发（5天）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第五阶段：区块链的分布式应用开发（2天）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第六阶段：利用区块链系统框架开发超级账本（HyperLedger Fabric）（5天）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第七阶段：比特币和EOS的底层源代码以及社群分析（2天）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第八节段： R3联盟以及脚本强化开发让你掌握联盟链。（5天）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第九阶段：公司真实区块链项目实战。（7天）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      以上几个步骤，是我把接下来将要内训的课程大致分为了几个部分，我会在后面的授课中详细的拆解这些部分。具体的内容可以关注我后面的每部分的文章。另外，为了方便大家学习和我沟通，我也会把这些课程的视频录制下来，与院子里的各位朋友分享。为了方便院子里的各位要学习区块链技术的朋友沟通，我新建了一个社群，大家可以讨论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/294888/201903/294888-20190318233715988-1480765904.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    如果朋友们加我微信请标注是从博客园来的，谢谢大家，接下来，我就会分享这次培训的区块链技术知识内容。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 15:38:00 +0000</pubDate>
<dc:creator>Rocky Ren</dc:creator>
<og:description>年前，我所在的公司成立了一个区块链事业部，我被委派为这个事业部的研发经理。2019年，我们要为公司的上下游企业利用区块链技术来做一套“通证（Token）”化的区块链系统。为上下游这些公司消除商业摩擦，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renyanlei/p/10556054.html</dc:identifier>
</item>
<item>
<title>自制触摸屏电话 - McKay</title>
<link>http://www.cnblogs.com/aarond/p/arduino_phone.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aarond/p/arduino_phone.html</guid>
<description>&lt;p&gt;几个周末前闲着无聊做了个触摸屏电话，功能是简单了点，只能打电话、接电话、挂断、接听。而且个子还大了点，但是总归还算是做出了点东西，就晒晒。喷吧，哈哈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318223505154-1892854547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小触摸屏是这样的（按钮左上角的编号实际显示时是没有的，这里是截的设计状态的图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318223637149-1659429868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;主要元件：触摸屏、arduino mega、sim800c、功放喇叭、电源（至少1A电流）&lt;/p&gt;
&lt;p&gt;原理很简单：&lt;/p&gt;
&lt;p&gt;设计触摸屏UI、按钮（厂家提供驱动可以通过arduino检测触摸的button）&lt;/p&gt;
&lt;p&gt;通过arduino去发送指令到sim800C&lt;/p&gt;
&lt;p&gt;先介绍下触摸屏UI的设计，如下图就是编辑器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318224421042-538012229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Object_Id: 81代表对应按钮的id，这个id是会回传到arduino中的，需要对应上才行，比如arduino中检测到objectId=81被触发了就代表按下了某个按钮。&lt;/p&gt;
&lt;p&gt;右面的mckay_main代表页面，后面的5是具体arduino中的id，比如初始化的时候arduino会设置page 5 为默认页面&lt;/p&gt;
&lt;p&gt;图片也是可以自定义的，只是不能拉伸&lt;/p&gt;
&lt;p&gt;最上方的就是编译按钮了，会输出一个vImage.bin文件。&lt;/p&gt;
&lt;p&gt;接下来就是将这个vImage.bin烧录到触摸屏flash中了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318225027661-680327237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记得先打开相应的COM接口，等到状态变成了 Open后，click  下载bin，然后就会先擦出整个flash存储，再慢慢写入了，这步是比较慢的。&lt;/p&gt;
&lt;p&gt;taobao链接：&lt;a href=&quot;https://item.taobao.com/item.htm?id=563235539384&amp;amp;_u=iq9aqj84c5&quot; target=&quot;_blank&quot;&gt;https://item.taobao.com/item.htm?id=563235539384&amp;amp;_u=iq9aqj84c5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;厂家会提供触摸屏LCD的设计软件以及接线方式（别忘了同时买USB转串口设备，有了就忽略，刚入门的话就买这个）&lt;/p&gt;

&lt;p&gt;接下来介绍下SIM800C &lt;/p&gt;
&lt;p&gt;淘宝链接：&lt;a href=&quot;https://item.taobao.com/item.htm?id=540672563189&amp;amp;_u=iq9aqj76d8&quot; target=&quot;_blank&quot;&gt;https://item.taobao.com/item.htm?id=540672563189&amp;amp;_u=iq9aqj76d8&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i1/230947266/TB20tPUaFOP.eBjSZFHXXXQnpXa_!!230947266.png&quot; alt=&quot;&quot; width=&quot;493&quot; height=&quot;400&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 这个板子大家还是自己陶下，因为原子哥那里卖的贵。。很贵。。自己买个替代品吧，有便宜的。我是后来才发现买贵了。&lt;/p&gt;
&lt;p&gt;这个板子，看上去很多东西，但其实控制这个板子只要插好micro sim卡（得自己去办卡，或者现成的，得匹配好你买入的板上对应的sim卡座大小）、和通过AT指令就搞定了。&lt;/p&gt;
&lt;p&gt;部分AT指令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
拨号
ATD137xxxxxxxx;

挂断-主动挂断
ATH

接电话
ATA　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么arduino是如何发送这些指令给这个板呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;SoftwareSerial.h&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
SoftwareSerial SIM800C(10, 11);     // Serial RX, TX
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是通过10、11数字pin口模拟了1个串口。　　&lt;/p&gt;
&lt;p&gt;这里刚接触的话比较绕，arduino的10是RX、11是TX；需要与SIM800C的TX，RX相连，就是：arduino 10(RX)----&amp;gt;sim800c tx口, arduino 11(TX)---&amp;gt;sim800c rx口&lt;/p&gt;
&lt;p&gt;sim800c的tx、rx位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318231150743-961402827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，上图中央有2个黄色的pin口，其中1个标记了GND，这个需要与arduino的GND相连，必须相连，不然没效果。&lt;/p&gt;
&lt;p&gt;下面看看arduino代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;LiquidCrystalDisplay.h&amp;gt;             &lt;span&gt;//这个厂家会提供&lt;/span&gt;
#include &amp;lt;SoftwareSerial.h&amp;gt;                   &lt;span&gt;//这个是arduino标准库&lt;/span&gt;

uint8_t   identifier,cnt;
uint8_t   cmd_buffer[CMD_MAX_SIZE];
uint8_t   data_size;
uint8_t   update_en;
uint8_t   command_cmd;
uint8_t   command_statu;
uint8_t   command_length;

LiquidCrystal TFTlcd(13);//RST pin13
SoftwareSerial SIM800C(10, 11);     //Serial RX, TX

void setup()                                            &lt;span&gt;//setup是初始化函数，只运行1次&lt;/span&gt;
{
   update_en =0;
   data_size =0;
   TFTlcd.queue_reset();
   
   Serial.begin(9600);
   TFTlcd.begin();

   attachInterrupt(0,LcdIICInterrupt,FALLING);           &lt;span&gt;//pin 2口是中断0，触摸屏靠这个来发送中断命令，FALLING代表当高电平转变为低电平时触发&lt;/span&gt;
   TFTlcd.SetPage(5);                                    &lt;span&gt;//默认页id&lt;/span&gt;

   SIM800C.begin(9600);
}

void LcdIICInterrupt()
{
    command_cmd = TFTlcd.I2C_Read();
    TFTlcd.queue_push(command_cmd);
    for(cnt =0;cnt &amp;lt;2;cnt++)
    {
      identifier = TFTlcd.I2C_Read();
      TFTlcd.queue_push(identifier);
    }
    command_statu = TFTlcd.I2C_Read();
    TFTlcd.queue_push(command_statu);
    identifier = TFTlcd.I2C_Read();
    TFTlcd.queue_push(identifier);
    command_length = TFTlcd.I2C_Read();
    TFTlcd.queue_push(command_length);
    if((command_cmd == GET_EDIT_VALUE &amp;amp;&amp;amp; command_statu == 0x6f)||(command_cmd == GET_TOUCH_EDIT_VALUE &amp;amp;&amp;amp; command_statu == 0x6f))
    {
      for(cnt =0;cnt &amp;lt;command_length;cnt++)
      {
        identifier = TFTlcd.I2C_Read();
        TFTlcd.queue_push(identifier);
      }
    }
}

void loop()                                               &lt;span&gt;//循环执行的函数&lt;/span&gt;
{
  data_size = TFTlcd.queue_find_cmd(cmd_buffer,CMD_MAX_SIZE);
  if(data_size&amp;gt;0)
      ProcessMessage((PCTRL_MSG)cmd_buffer, data_size);
}

void ProcessMessage( PCTRL_MSG msg, uint16_t dataSize )
{
    uint8_t cmd_type    = msg-&amp;gt;cmd_type;
    uint8_t control_id  = msg-&amp;gt;control_id;
    uint8_t page_id     = msg-&amp;gt;page_id;
    uint8_t _status     = msg-&amp;gt;status;
    uint8_t key_type    = msg-&amp;gt;key_type;
    uint8_t key_value   = msg-&amp;gt;key_value;

    if(control_id==81)                                   &lt;span&gt;//不同的id，代表不同的按钮的被按下&lt;/span&gt;
        dial(&quot;137xxxxxxxx&quot;);
    else if(control_id==82)
        dial(&quot;137xxxxxxxx&quot;);
    else if(control_id==83)
        dial(&quot;137xxxxxxxx&quot;);
    else if(control_id==84)
        dial(&quot;137xxxxxxxx&quot;);
    else if(control_id==89)
        send_cmd_to_sim800c(&quot;ATA&quot;);
    else if(control_id==86)
        send_cmd_to_sim800c(&quot;ATH&quot;);  
}

void dial(String mobileNumber)
{
    String dial_cmd=&quot;ATD&quot;+mobileNumber+&quot;;&quot;;
    send_cmd_to_sim800c(dial_cmd);
}
void send_cmd_to_sim800c(String at_cmd)
{
    Serial.println(at_cmd);
    SIM800C.println(at_cmd);
}　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主要的器件和程序就是上面这些了，不过离最终的完成还是需要其他组件的，比如：喇叭功放、降压模块转USB、1带n DC头、话筒&lt;/p&gt;
&lt;p&gt;OK，该继续学习新东西了，这个就先这样了。&lt;/p&gt;


&lt;p&gt;#include &amp;lt;SoftwareSerial.h&amp;gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Mar 2019 15:24:00 +0000</pubDate>
<dc:creator>McKay</dc:creator>
<og:description>几个周末前闲着无聊做了个触摸屏电话，功能是简单了点，只能打电话、接电话、挂断、接听。而且个子还大了点，但是总归还算是做出了点东西，就晒晒。喷吧，哈哈。 小触摸屏是这样的（按钮左上角的编号实际显示时是没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aarond/p/arduino_phone.html</dc:identifier>
</item>
<item>
<title>python异步编程模块asyncio学习(一) - python学习中</title>
<link>http://www.cnblogs.com/c-x-a/p/10555976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-x-a/p/10555976.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;asyncio模块提供了使用协程构建并发应用的工具。它使用一种单线程单进程的的方式实现并发，应用的各个部分彼此合作, 可以显示的切换任务，一般会在程序阻塞I/O操作的时候发生上下文切换如等待读写文件,或者请求网络。同时asyncio也支持调度代码在将来的某个特定事件运行，从而支持一个协程等待另一个协程完成，以处理系统信号和识别其他一些事件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;异步并发的概念&quot;&gt;异步并发的概念&lt;/h3&gt;
&lt;p&gt;对于其他的并发模型大多数采取的都是线性的方式编写。并且依赖于语言运行时系统或操作系统的底层线程或进程来适当地改变上下文，而基于asyncio的应用要求应用代码显示的处理上下文切换。&lt;br/&gt;asyncio提供的框架以事件循环(event loop)为中心，程序开启一个无限的循环，程序会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。&lt;/p&gt;
&lt;h4 id=&quot;事件循环&quot;&gt;事件循环&lt;/h4&gt;
&lt;p&gt;事件循环是一种处理多并发量的有效方式，在维基百科中它被描述为「一种等待程序分配事件或消息的编程架构」，我们可以定义事件循环来简化使用轮询方法来监控事件，通俗的说法就是「当A发生时，执行B」。事件循环利用poller对象，使得程序员不用控制任务的添加、删除和事件的控制。事件循环使用回调方法来知道事件的发生。它是asyncio提供的「中央处理设备」，支持如下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册、执行和取消延迟调用（超时）&lt;/li&gt;
&lt;li&gt;创建可用于多种类型的通信的服务端和客户端的Transports&lt;/li&gt;
&lt;li&gt;启动进程以及相关的和外部通信程序的Transports&lt;/li&gt;
&lt;li&gt;将耗时函数调用委托给一个线程池&lt;/li&gt;
&lt;li&gt;单线程（进程）的架构也避免的多线程（进程）修改可变状态的锁的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与事件循环交互的应用要显示地注册将运行的代码，让事件循环在资源可用时向应用代码发出必要的调用。如：一个套接字再没有更多的数据可以读取，那么服务器会把控制全交给事件循环。&lt;/p&gt;
&lt;h4 id=&quot;future&quot;&gt;Future&lt;/h4&gt;
&lt;p&gt;future是一个数据结构，表示还未完成的工作结果。事件循环可以监视Future对象是否完成。从而允许应用的一部分等待另一部分完成一些工作。&lt;/p&gt;
&lt;h4 id=&quot;task&quot;&gt;Task&lt;/h4&gt;
&lt;p&gt;task是Future的一个子类，它知道如何包装和管理一个协程的执行。任务所需的资源可用时，事件循环会调度任务允许，并生成一个结果，从而可以由其他协程消费。&lt;/p&gt;
&lt;h3 id=&quot;异步方法&quot;&gt;异步方法&lt;/h3&gt;
&lt;p&gt;使用asyncio也就意味着你需要一直写异步方法。&lt;br/&gt;一个标准方法是这样的：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def regular_double(x):
    return 2 * x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而一个异步方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async def async_double(x):
    return 2 * x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从外观上看异步方法和标准方法没什么区别只是前面多了个async。&lt;br/&gt;“Async” 是“asynchronous”的简写，为了区别于异步函数，我们称标准函数为同步函数，&lt;br/&gt;从用户角度异步函数和同步函数有以下区别：&lt;/p&gt;
&lt;p&gt;要调用异步函数，必须使用&lt;strong&gt;await&lt;/strong&gt;关键字。 因此，不要写regular_double(3)，而是写await async_double(3).&lt;br/&gt;不能在同步函数里使用await，否则会出错。&lt;br/&gt;句法错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def print_double(x):
    print(await async_double(x))   # &amp;lt;-- SyntaxError here&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是在异步函数中，await是被允许的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async def print_double(x):
    print(await async_double(x))   # &amp;lt;-- OK!&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;协程&quot;&gt;协程&lt;/h3&gt;
&lt;h4 id=&quot;启动一个协程&quot;&gt;启动一个协程&lt;/h4&gt;
&lt;p&gt;一般异步方法被称之为协程(Coroutine)。asyncio事件循环可以通过多种不同的方法启动一个协程。一般对于入口函数，最简答的方法就是使用run_until_complete(),并将协程直接传入这个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def foo():
    print(&quot;这是一个协程&quot;)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        print(&quot;开始运行协程&quot;)
        coro = foo()
        print(&quot;进入事件循环&quot;)
        loop.run_until_complete(coro)
    finally:
        print(&quot;关闭事件循环&quot;)
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;开始运行协程
进入事件循环
这是一个协程
关闭事件循环&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是最简单的一个协程的例子，下面让我们了解一下上面的代码.&lt;br/&gt;第一步首先得到一个事件循环的应用也就是定义的对象loop。可以使用默认的事件循环，也可以实例化一个特定的循环类(比如uvloop),这里使用了默认循环run_until_complete(coro)方法用这个协程启动循环，协程返回时这个方法将停止循环。&lt;br/&gt;run_until_complete的参数是一个futrue对象。当传入一个协程，其内部会自动封装成task，其中task是Future的子类。关于task和future后面会提到。&lt;/p&gt;
&lt;h4 id=&quot;从协程中返回值&quot;&gt;从协程中返回值&lt;/h4&gt;
&lt;p&gt;将上面的代码，改写成下面代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def foo():
    print(&quot;这是一个协程&quot;)
    return &quot;返回值&quot;


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        print(&quot;开始运行协程&quot;)
        coro = foo()
        print(&quot;进入事件循环&quot;)
        result = loop.run_until_complete(coro)
        print(f&quot;run_until_complete可以获取协程的{result}，默认输出None&quot;)
    finally:
        print(&quot;关闭事件循环&quot;)
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run_until_complete可以获取协程的返回值，如果没有给定返回值，则像函数一样，默认返回None。&lt;/p&gt;
&lt;h4 id=&quot;协程调用协程&quot;&gt;协程调用协程&lt;/h4&gt;
&lt;p&gt;一个协程可以启动另一个协程，从而可以任务根据工作内容，封装到不同的协程中。我们可以在协程中使用&lt;strong&gt;await&lt;/strong&gt;关键字，链式的调度协程，来形成一个协程任务流。向下面的例子一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def main():
    print(&quot;主协程&quot;)
    print(&quot;等待result1协程运行&quot;)
    res1 = await result1()
    print(&quot;等待result2协程运行&quot;)
    res2 = await result2(res1)
    return (res1,res2)


async def result1():
    print(&quot;这是result1协程&quot;)
    return &quot;result1&quot;


async def result2(arg):
    print(&quot;这是result2协程&quot;)
    return f&quot;result2接收了一个参数,{arg}&quot;


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        result = loop.run_until_complete(main())
        print(f&quot;获取返回值:{result}&quot;)
    finally:
        print(&quot;关闭事件循环&quot;)
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;主协程
等待result1协程运行
这是result1协程
等待result2协程运行
这是result2协程
获取返回值:('result1', 'result2接收了一个参数,result1')
关闭事件循环&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;协程中调用普通函数&quot;&gt;协程中调用普通函数&lt;/h3&gt;
&lt;p&gt;在协程中可以通过一些方法去调用普通的函数。可以使用的关键字有call_soon,call_later，call_at。&lt;/p&gt;
&lt;h4 id=&quot;call_soon&quot;&gt;call_soon&lt;/h4&gt;
&lt;p&gt;可以通过字面意思理解调用立即返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;loop.call_soon(callback, *args, context=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在下一个迭代的时间循环中立刻调用回调函数,大部分的回调函数支持位置参数，而不支持”关键字参数”，如果是想要使用关键字参数，则推荐使用functools.aprtial()对方法进一步包装.可选关键字context允许指定要运行的回调的自定义contextvars.Context。当没有提供上下文时使用当前上下文。在Python 3.7中， asyncio&lt;br/&gt;协程加入了对上下文的支持。使用上下文就可以在一些场景下隐式地传递变量，比如数据库连接session等，而不需要在所有方法调用显示地传递这些变量。&lt;br/&gt;下面来看一下具体的使用例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio
import functools


def callback(args, *, kwargs=&quot;defalut&quot;):
    print(f&quot;普通函数做为回调函数,获取参数:{args},{kwargs}&quot;)


async def main(loop):
    print(&quot;注册callback&quot;)
    loop.call_soon(callback, 1)
    wrapped = functools.partial(callback, kwargs=&quot;not defalut&quot;)
    loop.call_soon(wrapped, 2)
    await asyncio.sleep(0.2)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main(loop))
finally:
    loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;注册callback
普通函数做为回调函数,获取参数:1,defalut
普通函数做为回调函数,获取参数:2,not defalut&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过输出结果我们可以发现我们在协程中成功调用了一个普通函数，顺序的打印了1和2。&lt;/p&gt;
&lt;p&gt;有时候我们不想立即调用一个函数，此时我们就可以call_later延时去调用一个函数了。&lt;/p&gt;
&lt;h4 id=&quot;call_later&quot;&gt;call_later&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;loop.call_later(delay, callback, *args, context=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先简单的说一下它的含义，就是事件循环在delay多长时间之后才执行callback函数.&lt;br/&gt;配合上面的call_soon让我们看一个小例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


def callback(n):
    print(f&quot;callback {n} invoked&quot;)


async def main(loop):
    print(&quot;注册callbacks&quot;)
    loop.call_later(0.2, callback, 1)
    loop.call_later(0.1, callback, 2)
    loop.call_soon(callback, 3)
    await asyncio.sleep(0.4)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;注册callbacks
callback 3 invoked
callback 2 invoked
callback 1 invoked&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的输出可以得到如下结果：&lt;br/&gt;1.&lt;strong&gt;call_soon&lt;/strong&gt;会在call_later之前执行，和它的位置在哪无关&lt;br/&gt;2.&lt;strong&gt;call_later&lt;/strong&gt;的第一个参数越小，越先执行。&lt;/p&gt;
&lt;h4 id=&quot;call_at&quot;&gt;call_at&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;loop.call_at(when, callback, *args, context=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;call_at第一个参数的含义代表的是一个单调时间，它和我们平时说的系统时间有点差异，&lt;br/&gt;这里的时间指的是事件循环内部时间，可以通过loop.time()获取，然后可以在此基础上进行操作。后面的参数和前面的两个方法一样。实际上call_later内部就是调用的call_at。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


def call_back(n, loop):
    print(f&quot;callback {n} 运行时间点{loop.time()}&quot;)


async def main(loop):
    now = loop.time()
    print(&quot;当前的内部时间&quot;, now)
    print(&quot;循环时间&quot;, now)
    print(&quot;注册callback&quot;)
    loop.call_at(now + 0.1, call_back, 1, loop)
    loop.call_at(now + 0.2, call_back, 2, loop)
    loop.call_soon(call_back, 3, loop)
    await asyncio.sleep(1)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        print(&quot;进入事件循环&quot;)
        loop.run_until_complete(main(loop))
    finally:
        print(&quot;关闭循环&quot;)
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;进入事件循环
当前的内部时间 4412.152849525
循环时间 4412.152849525
注册callback
callback 3 运行时间点4412.152942526
callback 1 运行时间点4412.253202825
callback 2 运行时间点4412.354262512
关闭循环&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为call_later内部实现就是通过call_at所以这里就不多说了。&lt;/p&gt;
&lt;h3 id=&quot;future-1&quot;&gt;Future&lt;/h3&gt;
&lt;h4 id=&quot;获取futrue里的结果&quot;&gt;获取Futrue里的结果&lt;/h4&gt;
&lt;p&gt;future表示还没有完成的工作结果。事件循环可以通过监视一个future对象的状态来指示它已经完成。future对象有几个状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Pending&lt;/li&gt;
&lt;li&gt;Running&lt;/li&gt;
&lt;li&gt;Done&lt;/li&gt;
&lt;li&gt;Cancelled&lt;br/&gt;创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消，状态为cancel。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import asyncio


def foo(future, result):
    print(f&quot;此时future的状态:{future}&quot;)
    print(f&quot;设置future的结果:{result}&quot;)
    future.set_result(result)
    print(f&quot;此时future的状态:{future}&quot;)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        all_done = asyncio.Future()
        loop.call_soon(foo, all_done, &quot;Future is done!&quot;)
        print(&quot;进入事件循环&quot;)
        result = loop.run_until_complete(all_done)
        print(&quot;返回结果&quot;, result)
    finally:
        print(&quot;关闭事件循环&quot;)
        loop.close()
    print(&quot;获取future的结果&quot;, all_done.result())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;进入事件循环
此时future的状态:&amp;lt;Future pending cb=[_run_until_complete_cb() at /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/base_events.py:176]&amp;gt;
设置future的结果:Future is done!
此时future的状态:&amp;lt;Future finished result='Future is done!'&amp;gt;
返回结果 Future is done!
关闭事件循环
获取future的结果 Future is done!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过输出结果发现，调用set_result之后future对象的状态由pending变为finished&lt;br/&gt;，Future的实例all_done会保留提供给方法的结果，可以在后续使用。&lt;/p&gt;
&lt;h4 id=&quot;future对象使用await&quot;&gt;Future对象使用await&lt;/h4&gt;
&lt;p&gt;future和协程一样可以使用await关键字获取其结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


def foo(future, result):
    print(&quot;设置结果到future&quot;, result)
    future.set_result(result)


async def main(loop):
    all_done = asyncio.Future()
    print(&quot;调用函数获取future对象&quot;)
    loop.call_soon(foo, all_done, &quot;the result&quot;)

    result = await all_done
    print(&quot;获取future里的结果&quot;, result)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;future回调&quot;&gt;Future回调&lt;/h4&gt;
&lt;p&gt;Future 在完成的时候可以执行一些回调函数，回调函数按注册时的顺序进行调用:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio
import functools


def callback(future, n):
    print('{}: future done: {}'.format(n, future.result()))


async def register_callbacks(all_done):
    print('注册callback到future对象')
    all_done.add_done_callback(functools.partial(callback, n=1))
    all_done.add_done_callback(functools.partial(callback, n=2))


async def main(all_done):
    await register_callbacks(all_done)
    print('设置future的结果')
    all_done.set_result('the result')

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        all_done = asyncio.Future()
        loop.run_until_complete(main(all_done))
    finally:
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过add_done_callback方法给funtrue任务添加回调函数，当funture执行完成的时候,就会调用回调函数。并通过参数future获取协程执行的结果。&lt;br/&gt;到此为止，我们就学会了如何在协程中调用一个普通函数并获取其结果。&lt;/p&gt;
&lt;h3 id=&quot;并发的执行任务&quot;&gt;并发的执行任务&lt;/h3&gt;
&lt;p&gt;任务（Task）是与事件循环交互的主要途径之一。任务可以包装协程，可以跟踪协程何时完成。任务是Future的子类，所以使用方法和future一样。协程可以等待任务，每个任务都有一个结果，在它完成之后可以获取这个结果。&lt;br/&gt;因为协程是没有状态的，我们通过使用create_task方法可以将协程包装成有状态的任务。还可以在任务运行的过程中取消任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def child():
    print(&quot;进入子协程&quot;)
    return &quot;the result&quot;


async def main(loop):
    print(&quot;将协程child包装成任务&quot;)
    task = loop.create_task(child())
    print(&quot;通过cancel方法可以取消任务&quot;)
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        print(&quot;取消任务抛出CancelledError异常&quot;)
    else:
        print(&quot;获取任务的结果&quot;, task.result())


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;将协程child包装成任务
通过cancel方法可以取消任务
取消任务抛出CancelledError异常&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果把上面的task.cancel()注释了我们可以得到正常情况下的结果，如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;将协程child包装成任务
通过cancel方法可以取消任务
进入子协程
获取任务的结果 the result&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外出了使用loop.create_task将协程包装为任务外还可以使用asyncio.ensure_future(coroutine)建一个task。在python3.7中可以使用asyncio.create_task创建任务。&lt;/p&gt;
&lt;h3 id=&quot;组合协程&quot;&gt;组合协程&lt;/h3&gt;
&lt;p&gt;一系列的协程可以通过await链式的调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待1000个异步网络请求，对于访问次序有没有要求的时候，就可以使用另外的关键字wait或gather来解决了。wait可以暂停一个协程，直到后台操作完成。&lt;/p&gt;
&lt;h4 id=&quot;等待多个协程&quot;&gt;等待多个协程&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Task的使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def num(n):
    try:
        await asyncio.sleep(n*0.1)
        return n
    except asyncio.CancelledError:
        print(f&quot;数字{n}被取消&quot;)
        raise


async def main():
    tasks = [num(i) for i in range(10)]
    complete, pending = await asyncio.wait(tasks, timeout=0.5)
    for i in complete:
        print(&quot;当前数字&quot;,i.result())
    if pending:
        print(&quot;取消未完成的任务&quot;)
        for p in pending:
            p.cancel()


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    finally:
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前数字 1
当前数字 2
当前数字 0
当前数字 4
当前数字 3
取消未完成的任务
数字5被取消
数字9被取消
数字6被取消
数字8被取消
数字7被取消&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现我们的结果并没有按照数字的顺序显示，在内部wait()使用一个set保存它创建的Task实例。因为set是无序的所以这也就是我们的任务不是顺序执行的原因。wait的返回值是一个元组，包括两个集合，分别表示已完成和未完成的任务。wait第二个参数为一个超时值&lt;br/&gt;达到这个超时时间后，未完成的任务状态变为pending，当程序退出时还有任务没有完成此时就会看到如下的错误提示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Task was destroyed but it is pending!
task: &amp;lt;Task pending coro=&amp;lt;num() done, defined at 11.py:12&amp;gt; wait_for=&amp;lt;Future pending cb=[&amp;lt;TaskWakeupMethWrapper object at 0x1093e0558&amp;gt;()]&amp;gt;&amp;gt;
Task was destroyed but it is pending!
task: &amp;lt;Task pending coro=&amp;lt;num() done, defined at 11.py:12&amp;gt; wait_for=&amp;lt;Future pending cb=[&amp;lt;TaskWakeupMethWrapper object at 0x1093e06d8&amp;gt;()]&amp;gt;&amp;gt;
Task was destroyed but it is pending!
task: &amp;lt;Task pending coro=&amp;lt;num() done, defined at 11.py:12&amp;gt; wait_for=&amp;lt;Future pending cb=[&amp;lt;TaskWakeupMethWrapper object at 0x1093e0738&amp;gt;()]&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们可以通过迭代调用cancel方法取消任务。也就是这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if pending:
        print(&quot;取消未完成的任务&quot;)
        for p in pending:
            p.cancel()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;gather的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gather的作用和wait类似不同的是。&lt;br/&gt;1.gather任务无法取消。&lt;br/&gt;2.返回值是一个结果列表&lt;br/&gt;3.可以按照传入参数的顺序，顺序输出。&lt;br/&gt;我们将上面的代码改为gather的方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def num(n):
    try:
        await asyncio.sleep(n * 0.1)
        return n
    except asyncio.CancelledError:
        print(f&quot;数字{n}被取消&quot;)
        raise


async def main():
    tasks = [num(i) for i in range(10)]
    complete = await asyncio.gather(*tasks)
    for i in complete:
        print(&quot;当前数字&quot;, i)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    finally:
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前数字 0
当前数字 1
....中间部分省略
当前数字 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;gather通常被用来阶段性的一个操作，做完第一步才能做第二步，比如下面这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio

import time


async def step1(n, start):
    await asyncio.sleep(n)
    print(&quot;第一阶段完成&quot;)
    print(&quot;此时用时&quot;, time.time() - start)
    return n


async def step2(n, start):
    await asyncio.sleep(n)
    print(&quot;第二阶段完成&quot;)
    print(&quot;此时用时&quot;, time.time() - start)
    return n


async def main():
    now = time.time()
    result = await asyncio.gather(step1(5, now), step2(2, now))
    for i in result:
        print(i)
    print(&quot;总用时&quot;, time.time() - now)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    finally:
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第二阶段完成
此时用时 2.0014898777008057
第一阶段完成
此时用时 5.002960920333862
5
2
总用时 5.003103017807007&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过上面结果得到如下结论：&lt;br/&gt;1.step1和step2是并行运行的。&lt;br/&gt;2.gather会等待最耗时的那个完成之后才返回结果，耗时总时间取决于其中任务最长时间的那个。&lt;/p&gt;
&lt;h4 id=&quot;任务完成时进行处理&quot;&gt;任务完成时进行处理&lt;/h4&gt;
&lt;p&gt;as_complete是一个生成器，会管理指定的一个任务列表，并生成他们的结果。每个协程结束运行时一次生成一个结果。与wait一样，as_complete不能保证顺序，不过执行其他动作之前没有必要等待所以后台操作完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio
import time


async def foo(n):
    print('Waiting: ', n)
    await asyncio.sleep(n)
    return n


async def main():
    coroutine1 = foo(1)
    coroutine2 = foo(2)
    coroutine3 = foo(4)

    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    for task in asyncio.as_completed(tasks):
        result = await task
        print('Task ret: {}'.format(result))


now = lambda : time.time()
start = now()

loop = asyncio.get_event_loop()
done = loop.run_until_complete(main())
print(now() - start)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Waiting:  1
Waiting:  2
Waiting:  4
Task ret: 1
Task ret: 2
Task ret: 4
4.004292249679565&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现结果逐个输出。&lt;/p&gt;
&lt;p&gt;到此为止第一部分就结束了，对于asyncio入门级学习来说这些内容就够了。如果想继续跟进asyncio的内容，敬请期待后面的内容。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;更多异步内容请关注微信公众号：python学习开发&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 15:21:00 +0000</pubDate>
<dc:creator>python学习中</dc:creator>
<og:description>asyncio模块提供了使用协程构建并发应用的工具。它使用一种单线程单进程的的方式实现并发，应用的各个部分彼此合作, 可以显示的切换任务，一般会在程序阻塞I/O操作的时候发生上下文切换如等待读写文件,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-x-a/p/10555976.html</dc:identifier>
</item>
</channel>
</rss>