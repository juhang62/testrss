<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux下keepalived下载安装与配置 - darendu</title>
<link>http://www.cnblogs.com/darendu/p/10881791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/darendu/p/10881791.html</guid>
<description>&lt;p&gt;一、下载（原文链接：&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.studyshare.cn%2Fblog-front%2F%2Fsoftware%2Fdetails%2F1158%2F0&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.studyshare.cn/blog-front//software/details/1158/0&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;网盘下载：https://pan.baidu.com/s/1lK0HPBHvjy79pM0Zl-i1tQ 提取码：o1vd&lt;/p&gt;
&lt;p&gt;二、安装&lt;/p&gt;
&lt;p&gt;1、使用ftp工具或者liunx系统窗口中使用快捷键alt+p拖拽上传下载的gz安装包&lt;/p&gt;
&lt;p&gt;2、解压&lt;/p&gt;
&lt;p&gt;命令：tar -zxvf keepalived-1.3.4.tar.gz&lt;/p&gt;
&lt;p&gt;3、安装&lt;/p&gt;
&lt;p&gt;（1）命令：cd keepalived-1.3.4 //进入keepalived-1.3.4目录&lt;/p&gt;
&lt;p&gt;（2）命令：./configure --prefix=/usr/local/keepalived --sysconf=/usr/local/keepalived&lt;/p&gt;
&lt;p&gt;配置解释：&lt;/p&gt;
&lt;p&gt;--prefix=/usr/local/keepalived   ：指定安装在/usr/local/keepalived 路径下&lt;/p&gt;
&lt;p&gt;--sysconf=/usr/local/keepalived ： 指定keepalived的conf配置文件路径&lt;/p&gt;
&lt;p&gt;出现keepalived/dbus/Makefile 表示配置成功，如下图所示：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;
&lt;div class=&quot;image-container-fill&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190517155846671-44745038.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;（3）命令：make &amp;amp;&amp;amp; make install //编译+安装&lt;/p&gt;
&lt;p&gt;三、修改配置&lt;/p&gt;
&lt;p&gt;命令：cd /usr/local/keepalived/keepalived&lt;/p&gt;
&lt;p&gt;命令：vi keepalived.conf&lt;/p&gt;
&lt;p&gt;关键配置：&lt;/p&gt;
&lt;p&gt;global_defs {             #全局配置&lt;/p&gt;
&lt;p&gt;router_id nginx_backup       #表示运行Keepalived服务器的一个标识，唯一的&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;vrrp_instance VI_1 {        #vrrp 实例定义部分&lt;/p&gt;
&lt;p&gt;state BACKUP            # 指定keepalived的角色，MASTER为主，BACKUP为备&lt;/p&gt;
&lt;p&gt;interface eth0         # 当前进行vrrp通讯的网络接口卡(当前centos的网卡)&lt;/p&gt;
&lt;p&gt;virtual_router_id 66    # 虚拟路由编号，主从要一致&lt;/p&gt;
&lt;p&gt;priority 100            # 优先级，数值越大，获取处理请求的优先级越高&lt;/p&gt;
&lt;p&gt;advert_int 1            # 检查间隔，默认为1s(vrrp组播周期秒数)&lt;/p&gt;
&lt;p&gt;authentication {&lt;/p&gt;
&lt;p&gt;auth_type PASS #设置验证类型和密码，MASTER和BACKUP必须使用相同的密码才能正常通信&lt;/p&gt;
&lt;p&gt;auth_pass 1111&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;track_script {&lt;/p&gt;
&lt;p&gt;chk_http_port            #（调用检测脚本）&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;virtual_ipaddress {&lt;/p&gt;
&lt;p&gt;192.168.244.200            # 定义虚拟ip(VIP)，可多设，每行一个&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;global_defs { #全局配置    &lt;/p&gt;
&lt;p&gt;router_id LVS_1&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;四、启动停止&lt;/p&gt;
&lt;p&gt;命令：cd /usr/local/keepalived  #进入keepalived安装目录&lt;/p&gt;
&lt;p&gt;命令：./sbin/keepalived  #启动&lt;/p&gt;
&lt;p&gt;命令：ps -ef|grep keepalived , kill -9 keepalived进程号   #停止&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明出处，更多技术文章：&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Fwww.studyshare.cn%2Fblog-front%2Fblog%2Findex&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://www.studyshare.cn/blog-front/blog/index&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 07:58:00 +0000</pubDate>
<dc:creator>darendu</dc:creator>
<og:description>一、下载（原文链接：http://www.studyshare.cn/blog-front//software/details/1158/0 ） 网盘下载：https://pan.baidu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/darendu/p/10881791.html</dc:identifier>
</item>
<item>
<title>整理了八个开源的 Spring Boot 学习资源 - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/10881744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/10881744.html</guid>
<description>&lt;p&gt;Spring Boot 算是目前 Java 领域最火的技术栈了，松哥年初出版的 《Spring Boot + Vue 全栈开发实战》迄今为止已经加印了 3 次，Spring Boot 的受欢迎程度可见一斑。经常有人问松哥有没有推荐的 Spring Boot 学习资料？当然有！买松哥书就对了，哈哈。除了书呢？当然就是开源项目了，今天松哥整理了几个优质 Spring Boot 开源项目给大家参考，希望能够帮助到正在学习 Spring Boot 的小伙伴！&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-examples&quot;&gt;spring-boot-examples&lt;/h2&gt;
&lt;p&gt;这个项目中整合了 Spring Boot 使用的各种示例，以最简单、最实用为标准，此开源项目中的每个示例都以最小依赖，最简单为标准，帮助初学者快速掌握 Spring Boot 各组件的使用。基本上涉及到了 Spring Boot 使用的方方面面。&lt;/p&gt;
&lt;p&gt;项目部分 demo 截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-1.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;微人事&quot;&gt;微人事&lt;/h2&gt;
&lt;p&gt;微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot + Vue 开发。项目打通了前后端，并且提供了非常详尽的文档，从 Spring Boot 接口设计到前端 Vue 的开发思路，作者全部都记录在项目的 wiki 中，是不可多得的 Java 全栈学习资料。&lt;/p&gt;
&lt;p&gt;项目效果图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;项目部分文档截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-2.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mall&quot;&gt;mall&lt;/h2&gt;
&lt;p&gt;mall 项目是一套电商系统，包括前台商城系统及后台管理系统，基于 Spring Boot + MyBatis 实现。 前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。 后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。&lt;/p&gt;
&lt;p&gt;项目效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-4.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-boot-pay&quot;&gt;spring-boot-pay&lt;/h2&gt;
&lt;p&gt;这是一个支付案例，提供了包括支付宝、微信、银联在内的详细支付代码案例，对于有支付需求的小伙伴来说，这个项目再合适不过了。&lt;/p&gt;
&lt;p&gt;项目效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-5.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;v-部落&quot;&gt;V 部落&lt;/h2&gt;
&lt;p&gt;V部落是一个多用户博客管理平台，采用 Vue + SpringBoot + ElementUI 开发。&lt;strong&gt;这个项目最大的优势是简单，属于功能完整但是又非常简单的那种，非常非常适合初学者。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-6.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;springboot-plus&quot;&gt;springboot-plus&lt;/h2&gt;
&lt;p&gt;一个基于SpringBoot 2 的管理后台系统,包含了用户管理，组织机构管理，角色管理，功能点管理，菜单管理，权限分配，数据权限分配，代码生成等功能 相比其他开源的后台系统，SpringBoot-Plus 具有一定的复杂度。系统基于Spring Boot2.1技术，前端采用了Layui2.4。数据库以MySQL/Oracle/Postgres/SQLServer为实例，理论上是跨数据库平台。&lt;/p&gt;
&lt;p&gt;项目效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-7.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;litemall&quot;&gt;litemall&lt;/h2&gt;
&lt;p&gt;一个商城项目，包括Spring Boot后端 + Vue管理员前端 + 微信小程序用户前端 + Vue用户移动端，功能包括、分类列表、分类详情、品牌列表、品牌详情、新品首发、人气推荐、优惠券列表、优惠券选择、团购（团购业务有待完善）、搜索、商品详情、商品评价、商品分享、购物车、下单、订单列表、订单详情、地址、收藏、足迹、意见反馈以及客服；管理平台功能包括会员管理、商城管理、商品管理、推广管理、系统管理、配置管理、统计报表等。&lt;/p&gt;
&lt;p&gt;项目效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-8.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;另外再向大家推荐两个优质的 Spring Boot 和 Spring Cloud 学习网站，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-9.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.javaboy.org/images/sb/36-10.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;好了，一点点整理的资源，希望能够帮助到大家。&lt;/p&gt;
&lt;p&gt;关注公众号牧码小子，专注于 Spring Boot+微服务，定期视频教程分享，关注后回复 Java ，领取松哥为你精心准备的 Java 干货！&lt;br/&gt;&lt;img src=&quot;http://www.javaboy.org/images/sb/javaboy.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 07:53:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<og:description>Spring Boot 算是目前 Java 领域最火的技术栈了，松哥年初出版的 《Spring Boot + Vue 全栈开发实战》迄今为止已经加印了 3 次，Spring Boot 的受欢迎程度可见</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lenve/p/10881744.html</dc:identifier>
</item>
<item>
<title>SpringBoot第七篇：整合Mybatis-Plus - 追梦1819</title>
<link>http://www.cnblogs.com/yanfei1819/p/10881666.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanfei1819/p/10881666.html</guid>
<description>&lt;p&gt;作者：追梦1819&lt;br/&gt;原文：https://www.cnblogs.com/yanfei1819/p/10881666.html&lt;br/&gt;版权声明：本文为博主原创文章，转载请附上博文链接！&lt;/p&gt;
&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;
&lt;p&gt;  一看这个名字，就能看出与 MyBatis 有关。没错，它就是一款 MyBatis 的增强工具。&lt;/p&gt;
&lt;p&gt;  下面我们先介绍这款工具，然后再介绍在 SpringBoot 中的使用。这样符合博主的习惯：在学习一个新的技术或者新的框架之前，一定会思考这个技术或者框架为什么会出现？解决了什么问题？有没有别的取代方案？&lt;/p&gt;

&lt;h2 id=&quot;mybatis-plus简介&quot;&gt;Mybatis Plus简介&lt;/h2&gt;
&lt;p&gt;1、概念&lt;/p&gt;
&lt;p&gt;  MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。&lt;/p&gt;
&lt;p&gt;2、特性&lt;/p&gt;
&lt;p&gt;  官网列举了很多特性。不过总的来说，无非就是封装好了常规的 CRUD 操作，无需配置，同时内嵌了很多插件（热加载、代码生成、分页、性能分析等），减少了代码量。&lt;/p&gt;
&lt;p&gt;3、关于版本说明&lt;/p&gt;
&lt;p&gt;  MyBatis Plus2.0 是基于 JDK1.7 及以下版本的。MyBatis Plus3.0 是基于 JDK1.8 及以上版本的（因为插件内部使用了JDK8 的新特性 lambda 表达式）。本系列文章的JDK版本是1.8的，故选择的插件版本是3.0版本的。&lt;/p&gt;

&lt;h2 id=&quot;使用&quot;&gt;使用&lt;/h2&gt;
&lt;p&gt;  MyBatis Plus 的核心功能有三个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CRUD 操作；&lt;/li&gt;
&lt;li&gt;代码生成器；&lt;/li&gt;
&lt;li&gt;条件生成器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面逐一介绍。&lt;/p&gt;
&lt;h3 id=&quot;crud操作&quot;&gt;CRUD操作&lt;/h3&gt;
&lt;p&gt;  我们来看看 MyBatis 在 SpringBoot 项目中的应用。&lt;/p&gt;
&lt;p&gt;  准备工作，初始化数据库：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `age` int(3) NOT NULL,
  `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 3 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 21, 'admin');
INSERT INTO `user` VALUES (2, 22, 'test');

SET FOREIGN_KEY_CHECKS = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  首先，创建 SpringBoot 项目，引入 maven 依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.mybatis.spring.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-spring-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.0.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- https://mvnrepository.com/artifact/com.baomidou/mybatis-plus-boot-starter --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  然后，配置数据库信息和数据库方言：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;server.port=8087

spring.datasource.driver-class-name=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql://xx.xx.xx.xx:3306/test
spring.datasource.username=root
spring.datasource.password=root&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.yanfei1819.mybatisplusdemo.config;

import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * MyBatis Plus 的方言配置
 * Created by 追梦1819 on 2019-05-17.
 */
@Configuration
public class MybatisPlusConfig {
    @Bean
    public PaginationInterceptor paginationInterceptor(){
        PaginationInterceptor page = new PaginationInterceptor();
        //设置方言类型
        page.setDialectType(&quot;mysql&quot;);
        return page;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  下面再创建一个实体类，以映射数据库字段：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.yanfei1819.mybatisplusdemo.entity;

/**
 * Created by 追梦1819 on 2019-05-17.
 */
public class User {
    private Long id;
    private String name;
    private int age;
    // get/set 省略
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  然后，创建代理接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.yanfei1819.mybatisplusdemo.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import com.yanfei1819.mybatisplusdemo.entity.User;

/**
 * Created by 追梦1819 on 2019-05-17.
 */
//@Mapper
public interface UserMapper extends BaseMapper&amp;lt;User&amp;gt; {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这里需要注意，需要通过启动类的 &lt;code&gt;@MapperScan&lt;/code&gt; 注解或者代理接口上的 &lt;code&gt;@Mapper&lt;/code&gt; 注解（本示例中用的是前者）。&lt;/p&gt;
&lt;p&gt;  看到这一步，是不是很眼熟？很像前一篇的通用Mapper？&lt;/p&gt;
&lt;p&gt;  这里说一句题外话，其实只要了解 MyBatis 的原理，自己都可以写出想要的插件。后续在 MyBatis 的专栏中，我将分析 Mybatis 的使用和原理。敬请关注。&lt;/p&gt;
&lt;p&gt;  最后创建一个测试接口方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.yanfei1819.mybatisplusdemo.web.controller;

import com.yanfei1819.mybatisplusdemo.entity.User;
import com.yanfei1819.mybatisplusdemo.mapper.UserMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.List;

/**
 * Created by 追梦1819 on 2019-05-17.
 */
@RestController
public class UserController {
    @Autowired
    private UserMapper userMapper;

    @GetMapping(&quot;/queryUsers&quot;)
    public List&amp;lt;User&amp;gt; queryUsers(){
        return userMapper.selectList(null);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  启动程序：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.yanfei1819.mybatisplusdemo;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(&quot;com.yanfei1819.mybatisplusdemo.mapper&quot;)
public class MybatisPlusDemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(MybatisPlusDemoApplication.class, args);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  通过 postman 测试的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201905/1183871-20190517153551886-1949566274.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;常用api&quot;&gt;常用API&lt;/h2&gt;
&lt;p&gt;  该插件封装好的方法有很多，以上只是演示了其中的查询列表的方法。下面是列举几个常用的方法。&lt;br/&gt;  当然，如果感兴趣，想要了解更多，可以研究一下插件中的源码：&lt;code&gt;com.baomidou.mybatisplus.core.mapper.BaseMapper&lt;/code&gt; 。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 插入一条记录
 * @param entity 实体对象
 */
int insert(T entity);
/**
 * 根据 ID 删除
 * @param id 主键ID
 */
int deleteById(Serializable id);
/**
 * 根据 columnMap 条件，删除记录
 *
 * @param columnMap 表字段 map 对象
 */
int deleteByMap(@Param(Constants.COLUMN_MAP) Map&amp;lt;String, Object&amp;gt; columnMap);
/**
 * 根据 ID 修改
 * @param entity 实体对象
 */
int updateById(@Param(Constants.ENTITY) T entity);
/**
 * 根据 ID 查询
 * @param id 主键ID
 */
T selectById(Serializable id);

/**
 * 根据 entity 条件，查询全部记录
 * @param queryWrapper 实体对象封装操作类（可以为 null）
 */
List&amp;lt;T&amp;gt; selectList(@Param(Constants.WRAPPER) Wrapper&amp;lt;T&amp;gt; queryWrapper);&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;代码生成器&quot;&gt;代码生成器&lt;/h2&gt;
&lt;p&gt;  这是这个插件比较好用的一个功能。&lt;/p&gt;
&lt;p&gt;  为了更好的演示该功能，在本小节中重新新建一个工程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201905/1183871-20190517153606692-1138813387.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  首选，引入 maven 依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;3.1.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
    &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.baomidou&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;mybatis-plus-boot-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.2.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- freemarker --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.freemarker&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;freemarker&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  此处要注意版本问题，&lt;code&gt;mybatis-plus-boot-starter&lt;/code&gt; 用的是 &lt;code&gt;3.0&lt;/code&gt; 以上的版本，&lt;code&gt;mybatis-plus-boot-starter&lt;/code&gt; 用了 &lt;code&gt;3.0&lt;/code&gt; 以下的版本。因为MyBatis-Plus 从 &lt;code&gt;3.0.3&lt;/code&gt; 之后移除了代码生成器与模板引擎的默认依赖，需要手动添加相关依赖。此处为了简化演示，故用了 &lt;code&gt;3.0&lt;/code&gt; 以下的版本。&lt;/p&gt;
&lt;p&gt;  另外，MyBatis-Plus 支持 Velocity（默认）、Freemarker、Beetl，用户可以选择自己熟悉的模板引擎，也可以自定义自定义模板引擎。本篇用的是 Freemarker 。&lt;/p&gt;
&lt;p&gt;  下面，就是最代码生成工具了：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.yanfei1819.mybatisplusgeneratordemo.util;

import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.DataSourceConfig;
import com.baomidou.mybatisplus.generator.config.GlobalConfig;
import com.baomidou.mybatisplus.generator.config.PackageConfig;
import com.baomidou.mybatisplus.generator.config.StrategyConfig;
import com.baomidou.mybatisplus.generator.config.converts.MySqlTypeConvert;
import com.baomidou.mybatisplus.generator.config.rules.DbColumnType;
import com.baomidou.mybatisplus.generator.config.rules.DbType;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;

/**
 * &amp;lt;p&amp;gt;
 * 代码生成器演示
 * &amp;lt;/p&amp;gt;
 */
public class CodeGenerator {

    public static void main(String[] args) {
//        assert (false) : &quot;代码生成属于危险操作，请确定配置后取消断言执行代码生成！&quot;;
        AutoGenerator mpg = new AutoGenerator();
        // 选择 freemarker 引擎，默认 Velocity
        mpg.setTemplateEngine(new FreemarkerTemplateEngine());

        // 全局配置
        GlobalConfig gc = new GlobalConfig();
        gc.setAuthor(&quot;追梦1819&quot;);
        gc.setOutputDir(&quot;F://私人文档/springboot/springboot-example/mybatis-plus-generator-demo/src/main/java&quot;);
        gc.setFileOverride(false);// 是否覆盖同名文件，默认是false
        gc.setActiveRecord(true);// 不需要ActiveRecord特性的请改为false
        gc.setEnableCache(false);// XML 二级缓存
        gc.setBaseResultMap(true);// XML ResultMap
        gc.setBaseColumnList(false);// XML columList
        /* 自定义文件命名，注意 %s 会自动填充表实体属性！ */
        // gc.setMapperName(&quot;%sDao&quot;);
        // gc.setXmlName(&quot;%sDao&quot;);
        // gc.setServiceName(&quot;MP%sService&quot;);
        // gc.setServiceImplName(&quot;%sServiceDiy&quot;);
        // gc.setControllerName(&quot;%sAction&quot;);
        mpg.setGlobalConfig(gc);

        // 数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setDbType(DbType.MYSQL);
        dsc.setTypeConvert(new MySqlTypeConvert() {
            // 自定义数据库表字段类型转换【可选】
            @Override
            public DbColumnType processTypeConvert(String fieldType) {
                System.out.println(&quot;转换类型：&quot; + fieldType);
                // 注意！！processTypeConvert 存在默认类型转换，如果不是你要的效果请自定义返回、非如下直接返回。
                return super.processTypeConvert(fieldType);
            }
        });
        dsc.setDriverName(&quot;com.mysql.jdbc.Driver&quot;);
        dsc.setUsername(&quot;root&quot;);
        dsc.setPassword(&quot;pass123&quot;);
        dsc.setUrl(&quot;jdbc:mysql://192.168.1.88:3306/test?serverTimezone=GMT%2B8&quot;);
        mpg.setDataSource(dsc);

        // 策略配置
        StrategyConfig strategy = new StrategyConfig();
        // strategy.setCapitalMode(true);// 全局大写命名 ORACLE 注意
        strategy.setTablePrefix(new String[] { &quot;user_&quot; });// 此处可以修改为您的表前缀
        strategy.setNaming(NamingStrategy.nochange);// 表名生成策略
        strategy.setInclude(new String[] { &quot;user&quot; }); // 需要生成的表
        // strategy.setExclude(new String[]{&quot;test&quot;}); // 排除生成的表
        // 自定义实体父类
        // strategy.setSuperEntityClass(&quot;com.baomidou.demo.TestEntity&quot;);
        // 自定义实体，公共字段
        // strategy.setSuperEntityColumns(new String[] { &quot;test_id&quot;, &quot;age&quot; });
        // 自定义 mapper 父类
        // strategy.setSuperMapperClass(&quot;com.baomidou.demo.TestMapper&quot;);
        // 自定义 service 父类
        // strategy.setSuperServiceClass(&quot;com.baomidou.demo.TestService&quot;);
        // 自定义 service 实现类父类
        // strategy.setSuperServiceImplClass(&quot;com.baomidou.demo.TestServiceImpl&quot;);
        // 自定义 controller 父类
        // strategy.setSuperControllerClass(&quot;com.baomidou.demo.TestController&quot;);
        // 【实体】是否生成字段常量（默认 false）
        // public static final String ID = &quot;test_id&quot;;
        // strategy.setEntityColumnConstant(true);
        // 【实体】是否为构建者模型（默认 false）
        // public User setName(String name) {this.name = name; return this;}
        // strategy.setEntityBuilderModel(true);
        mpg.setStrategy(strategy);

        // 包配置
        PackageConfig pc = new PackageConfig();
        pc.setParent(&quot;com.yanfei1819.mybatisplusgeneratordemo&quot;);
        // pc.setModuleName(&quot;test&quot;);
        mpg.setPackageInfo(pc);

        // 注入自定义配置，可以在 VM 中使用 cfg.abc 【可无】
        // InjectionConfig cfg = new InjectionConfig() {
        // @Override
        // public void initMap() {
        // Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;String, Object&amp;gt;();
        // map.put(&quot;abc&quot;, this.getConfig().getGlobalConfig().getAuthor() +
        // &quot;-mp&quot;);
        // this.setMap(map);
        // }
        // };
        //
        // // 自定义 xxList.jsp 生成
        // List&amp;lt;FileOutConfig&amp;gt; focList = new ArrayList&amp;lt;&amp;gt;();
        // focList.add(new FileOutConfig(&quot;/template/list.jsp.vm&quot;) {
        // @Override
        // public String outputFile(TableInfo tableInfo) {
        // // 自定义输入文件名称
        // return &quot;D://my_&quot; + tableInfo.getEntityName() + &quot;.jsp&quot;;
        // }
        // });
        // cfg.setFileOutConfigList(focList);
        // mpg.setCfg(cfg);
        //
        // // 调整 xml 生成目录演示
        // focList.add(new FileOutConfig(&quot;/templates/mapper.xml.vm&quot;) {
        // @Override
        // public String outputFile(TableInfo tableInfo) {
        // return &quot;/develop/code/xml/&quot; + tableInfo.getEntityName() + &quot;.xml&quot;;
        // }
        // });
        // cfg.setFileOutConfigList(focList);
        // mpg.setCfg(cfg);
        //
        // // 关闭默认 xml 生成，调整生成 至 根目录
        // TemplateConfig tc = new TemplateConfig();
        // tc.setXml(null);
        // mpg.setTemplate(tc);

        // 自定义模板配置，可以 copy 源码 mybatis-plus/src/main/resources/templates 下面内容修改，
        // 放置自己项目的 src/main/resources/templates 目录下, 默认名称一下可以不配置，也可以自定义模板名称
        // TemplateConfig tc = new TemplateConfig();
        // tc.setController(&quot;...&quot;);
        // tc.setEntity(&quot;...&quot;);
        // tc.setMapper(&quot;...&quot;);
        // tc.setXml(&quot;...&quot;);
        // tc.setService(&quot;...&quot;);
        // tc.setServiceImpl(&quot;...&quot;);
        // 如上任何一个模块如果设置 空 OR Null 将不生成该模块。
        // mpg.setTemplate(tc);

        // 执行生成
        mpg.execute();

        // 打印注入设置【可无】
        // System.err.println(mpg.getCfg().getMap().get(&quot;abc&quot;));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  可以看到，所有的配置都在这个类中（当然不是每一项配置都是必须的，“按需所取”）。&lt;/p&gt;
&lt;p&gt;  执行该类，能够得到结果：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201905/1183871-20190517154159015-963978295.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;条件构造器&quot;&gt;条件构造器&lt;/h2&gt;
&lt;p&gt;  简单说，就是通过方法把条件封装好，直接写入参数即可。个人并不推荐这种方式，因为可读性并不强，有点封装过度。如果感兴趣的小伙伴，可以看看 &lt;a href=&quot;https://mp.baomidou.com/guide/wrapper.html#abstractwrapper&quot;&gt;官方文档&lt;/a&gt; ，写得很详细。&lt;/p&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;MyBatis Plus 官网：&lt;a href=&quot;https://mp.baomidou.com/&quot; class=&quot;uri&quot;&gt;https://mp.baomidou.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;源码：com.baomidou.mybatisplus.core.mapper.BaseMapper&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;  其实就个人来说，我并不喜欢这个工具。因为它给我的感觉是封装过度了，从某种程度上来说，把简单问题复杂化了。&lt;/p&gt;
&lt;p&gt;  常规的 CRUD 操作，对应问题的解决方案有很多，比就如上一篇文章【&lt;a href=&quot;https://www.cnblogs.com/yanfei1819/p/10876339.html&quot;&gt;SpringBoot第六篇：整合通用Mapper&lt;/a&gt;】中说到的通用Mapper，就是我比较喜欢的解决方案。&lt;/p&gt;
&lt;p&gt;  针对代码生成器和条件生成器，那就是“萝卜白菜，各有所爱”了。&lt;/p&gt;
&lt;p&gt;  当然，这只是个人的观点。技术与框架的选择，是多个因素的综合考虑的结果。&lt;/p&gt;
&lt;p&gt;&amp;lt;全文完&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201905/1183871-20190517111917538-741495804.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 07:42:00 +0000</pubDate>
<dc:creator>追梦1819</dc:creator>
<og:description>作者：追梦1819 原文：https://www.cnblogs.com/yanfei1819/p/10881666.html 版权声明：本文为博主原创文章，转载请附上博文链接！ 引言  &amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanfei1819/p/10881666.html</dc:identifier>
</item>
<item>
<title>Go语言调度器之盗取goroutine(17) - 爱写程序的阿波张</title>
<link>http://www.cnblogs.com/abozhang/p/10881594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abozhang/p/10881594.html</guid>
<description>&lt;p&gt;&lt;span&gt;本文是《Go语言调度器源代码情景分析》系列的第17篇，也是第三章《Goroutine调度策略》的第2小节。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上一小节我们分析了从全局运行队列与工作线程的本地运行队列获取goroutine的过程，这一小节我们继续分析因无法从上述两个队列中拿到需要运行的goroutine而导致的从其它工作线程的本地运行队列中盗取goroutine的过程。&lt;/p&gt;
&lt;p&gt;findrunnable() 函数负责处理与盗取相关的逻辑，该函数代码很繁杂，因为它还做了与gc和netpoll等相关的事情，为了不影响我们的分析思路，这里我们仍然把不相关的代码删掉了，不过代码还是比较多，但总结起来就一句话：尽力去各个运行队列中寻找goroutine，如果实在找不到则进入睡眠状态。下面是代码细节：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 2176&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;64&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// Finds a runnable goroutine to execute.
// Tries to steal from other P's, get g from global queue, poll network.
func findrunnable() (gp *g, inheritTime bool) {
        _g_ := getg()

        // The conditions here and in handoffp must agree: if
        // findrunnable would return a G to run, handoffp must start
        // an M.

top:
        _p_ := _g_.m.p.ptr()
        
    ......

        // local runq
    //再次看一下本地运行队列是否有需要运行的goroutine
        if gp, inheritTime := runqget(_p_); gp != nil {
                return gp, inheritTime
        }

        // global runq
    //再看看全局运行队列是否有需要运行的goroutine
        if sched.runqsize != 0 {
                lock(&amp;amp;sched.lock)
                gp := globrunqget(_p_, 0)
                unlock(&amp;amp;sched.lock)
                if gp != nil {
                        return gp, false
                }
        }

    ......

        // Steal work from other P's.
    //如果除了当前工作线程还在运行外，其它工作线程已经处于休眠中，那么也就不用去偷了，肯定没有
        procs := uint32(gomaxprocs)
        if atomic.Load(&amp;amp;sched.npidle) == procs-1 {
                // Either GOMAXPROCS=1 or everybody, except for us, is idle already.
                // New work can appear from returning syscall/cgocall, network or timers.
                // Neither of that submits to local run queues, so no point in stealing.
                goto stop
        }
        // If number of spinning M's &amp;gt;= number of busy P's, block.
        // This is necessary to prevent excessive CPU consumption
        // when GOMAXPROCS&amp;gt;&amp;gt;1 but the program parallelism is low.
    // 这个判断主要是为了防止因为寻找可运行的goroutine而消耗太多的CPU。
    // 因为已经有足够多的工作线程正在寻找可运行的goroutine，让他们去找就好了，自己偷个懒去睡觉
        if !_g_.m.spinning &amp;amp;&amp;amp; 2*atomic.Load(&amp;amp;sched.nmspinning) &amp;gt;= procs-atomic.Load(&amp;amp;sched.npidle) {
                goto stop
        }
        if !_g_.m.spinning {
        //设置m的状态为spinning
                _g_.m.spinning = true
        //处于spinning状态的m数量加一
                atomic.Xadd(&amp;amp;sched.nmspinning, 1)
        }
    
    //从其它p的本地运行队列盗取goroutine
        for i := 0; i &amp;lt; 4; i++ {
                for enum := stealOrder.start(fastrand()); !enum.done(); enum.next() {
                        if sched.gcwaiting != 0 {
                                goto top
                        }
                        stealRunNextG := i &amp;gt; 2 // first look for ready queues with more than 1 g
                        if gp := runqsteal(_p_, allp[enum.position()], stealRunNextG); gp != nil {
                                return gp, false
                        }
                }
        }

stop:
        
        ......

        // Before we drop our P, make a snapshot of the allp slice,
        // which can change underfoot once we no longer block
        // safe-points. We don't need to snapshot the contents because
        // everything up to cap(allp) is immutable.
        allpSnapshot := allp

        // return P and block
        lock(&amp;amp;sched.lock)
  
        ......
  
        if sched.runqsize != 0 {
                gp := globrunqget(_p_, 0)
                unlock(&amp;amp;sched.lock)
                return gp, false
        }
    
    // 当前工作线程解除与p之间的绑定，准备去休眠
        if releasep() != _p_ {
                throw(&quot;findrunnable: wrong p&quot;)
        }
    //把p放入空闲队列
        pidleput(_p_)
        unlock(&amp;amp;sched.lock)

        // Delicate dance: thread transitions from spinning to non-spinning state,
        // potentially concurrently with submission of new goroutines. We must
        // drop nmspinning first and then check all per-P queues again (with
        // #StoreLoad memory barrier in between). If we do it the other way around,
        // another thread can submit a goroutine after we've checked all run queues
        // but before we drop nmspinning; as the result nobody will unpark a thread
        // to run the goroutine.
        // If we discover new work below, we need to restore m.spinning as a signal
        // for resetspinning to unpark a new worker thread (because there can be more
        // than one starving goroutine). However, if after discovering new work
        // we also observe no idle Ps, it is OK to just park the current thread:
        // the system is fully loaded so no spinning threads are required.
        // Also see &quot;Worker thread parking/unparking&quot; comment at the top of the file.
        wasSpinning := _g_.m.spinning
        if _g_.m.spinning {
        //m即将睡眠，状态不再是spinning
                _g_.m.spinning = false
                if int32(atomic.Xadd(&amp;amp;sched.nmspinning, -1)) &amp;lt; 0 {
                        throw(&quot;findrunnable: negative nmspinning&quot;)
                }
        }

        // check all runqueues once again
    // 休眠之前再看一下是否有工作要做
        for _, _p_ := range allpSnapshot {
                if !runqempty(_p_) {
                        lock(&amp;amp;sched.lock)
                        _p_ = pidleget()
                        unlock(&amp;amp;sched.lock)
                        if _p_ != nil {
                                acquirep(_p_)
                                if wasSpinning {
                                        _g_.m.spinning = true
                                        atomic.Xadd(&amp;amp;sched.nmspinning, 1)
                                }
                                goto top
                        }
                        break
                }
        }

        ......
    //休眠
        stopm()
        goto top
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的代码可以看到，工作线程在放弃寻找可运行的goroutine而进入睡眠之前，会反复尝试从各个运行队列寻找需要运行的goroutine，可谓是尽心尽力了。这个函数需要重点注意以下两点：&lt;/p&gt;
&lt;p&gt;第一点，&lt;strong&gt;工作线程M的自旋状态(spinning)&lt;/strong&gt;。&lt;strong&gt;工作线程在从其它工作线程的本地运行队列中盗取goroutine时的状态称为自旋状态&lt;/strong&gt;。从上面代码可以看到，当前M在去其它p的运行队列盗取goroutine之前把spinning标志设置成了true，同时增加处于自旋状态的M的数量，而盗取结束之后则把spinning标志还原为false，同时减少处于自旋状态的M的数量，从后面的分析我们可以看到，当有空闲P又有goroutine需要运行的时候，这个处于自旋状态的M的数量决定了是否需要唤醒或者创建新的工作线程。&lt;/p&gt;
&lt;p&gt;第二点，&lt;strong&gt;盗取算法&lt;/strong&gt;。盗取过程用了两个嵌套for循环。内层循环实现了盗取逻辑，从代码可以看出盗取的实质就是遍历allp中的所有p，查看其运行队列是否有goroutine，如果有，则取其一半到当前工作线程的运行队列，然后从findrunnable返回，如果没有则继续遍历下一个p。&lt;strong&gt;但这里为了保证公平性，遍历allp时并不是固定的从allp[0]即第一个p开始，而是从随机位置上的p开始，而且遍历的顺序也随机化了，并不是现在访问了第i个p下一次就访问第i+1个p，而是使用了一种伪随机的方式遍历allp中的每个p，防止每次遍历时使用同样的顺序访问allp中的元素&lt;/strong&gt;。下面是这个算法的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
offset := uint32(random()) % nprocs
coprime := 随机选取一个小于nprocs且与nprocs互质的数
for i := 0; i &amp;lt; nprocs; i++ {
    p := allp[offset]
    从p的运行队列偷取goroutine
    if 偷取成功 {
        break
    }
    offset += coprime
    offset = offset % nprocs
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面举例说明一下上述算法过程，现假设nprocs为8，也就是一共有8个p。&lt;/p&gt;
&lt;p&gt;如果第一次随机选择的offset = 6，coprime = 3(3与8互质，满足算法要求)的话，则从allp切片中偷取的下标顺序为6, 1, 4, 7, 2, 5, 0, 3，计算过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;6&lt;/span&gt;，(&lt;span&gt;6&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;，(&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;4&lt;/span&gt;, (&lt;span&gt;4&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;7&lt;/span&gt;, (&lt;span&gt;7&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;, (&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;, (&lt;span&gt;5&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;, (&lt;span&gt;0&lt;/span&gt;+&lt;span&gt;3&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果第二次随机选择的offset = 4，coprime = 5的话，则从allp切片中偷取的下标顺序为1, 6, 3, 0, 5, 2, 7, 4，计算过程：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;，(&lt;span&gt;1&lt;/span&gt;+&lt;span&gt;5&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;6&lt;/span&gt;，(&lt;span&gt;6&lt;/span&gt;+&lt;span&gt;5&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;3&lt;/span&gt;, (&lt;span&gt;3&lt;/span&gt;+&lt;span&gt;5&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;, (&lt;span&gt;0&lt;/span&gt;+&lt;span&gt;5&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;5&lt;/span&gt;, (&lt;span&gt;5&lt;/span&gt;+&lt;span&gt;5&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;, (&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;5&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;7&lt;/span&gt;, (&lt;span&gt;7&lt;/span&gt;+&lt;span&gt;5&lt;/span&gt;)%&lt;span&gt;8&lt;/span&gt;=&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到只要随机数不一样，偷取p的顺序也不一样，但可以保证经过8次循环，每个p都会被访问到。可以用数论知识证明，不管nprocs是多少，这个算法都可以保证经过nprocs次循环，每个p都可以得到访问。&lt;/p&gt;
&lt;p&gt;挑选出盗取的对象p之后，则调用runqsteal盗取p的运行队列中的goroutine，runqsteal函数再调用runqgrap从p的队列中批量拿出多个goroutine，这两个函数本身比较简单，但runqgrab有一个小细节需要注意一下，见下面代码：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 4854&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// Grabs a batch of goroutines from _p_'s runnable queue into batch.
// Batch is a ring buffer starting at batchHead.
// Returns number of grabbed goroutines.
// Can be executed by any P.
func runqgrab(_p_ *p, batch *[256]guintptr, batchHead uint32, stealRunNextG bool) uint32 {
        for {
                h := atomic.LoadAcq(&amp;amp;_p_.runqhead) // load-acquire, synchronize with other consumers
                t := atomic.LoadAcq(&amp;amp;_p_.runqtail) // load-acquire, synchronize with the producer
                n := t - h        //计算队列中有多少个goroutine
                n = n - n/2     //取队列中goroutine个数的一半
                if n == 0 {
                        ......
                        return ......
                }
        //小细节：按理说队列中的goroutine个数最多就是len(_p_.runq)，
        //所以n的最大值也就是len(_p_.runq)/2，那为什么需要这个判断呢？
                if n &amp;gt; uint32(len(_p_.runq)/2) { // read inconsistent h and t
                        continue
                }
        
                ......
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中n的计算很简单，从计算过程来看n应该是runq队列中goroutine数量的一半，它的最大值不会超过队列容量的一半，但为什么这里的代码却偏偏要去判断n是否大于队列容量的一半呢？这里关键点在于读取runqhead和runqtail是两个操作而非一个原子操作，当我们读取runqhead之后但还未读取runqtail之前，如果有其它线程快速的在增加（这是完全有可能的，其它偷取者从队列中偷取goroutine会增加runqhead，而队列的所有者往队列中添加goroutine会增加runqtail）这两个值，则会导致我们读取出来的runqtail已经远远大于我们之前读取出来放在局部变量h里面的runqhead了，也就是代码注释中所说的h和t已经不一致了，所以这里需要这个if判断来检测异常情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作线程进入睡眠&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分析完盗取过程，我们继续回到findrunnable函数。&lt;/p&gt;
&lt;p&gt;如果工作线程经过多次努力一直找不到需要运行的goroutine则调用stopm进入睡眠状态，等待被其它工作线程唤醒。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/proc.go : 1918&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// Stops execution of the current m until new work is available.
// Returns with acquired P.
func stopm() {
   _g_ := getg()

   if _g_.m.locks != 0 {
      throw(&quot;stopm holding locks&quot;)
   }
   if _g_.m.p != 0 {
      throw(&quot;stopm holding p&quot;)
   }
   if _g_.m.spinning {
      throw(&quot;stopm spinning&quot;)
   }

   lock(&amp;amp;sched.lock)
   mput(_g_.m)   //把m结构体对象放入sched.midle空闲队列
   unlock(&amp;amp;sched.lock)
   notesleep(&amp;amp;_g_.m.park)  //进入睡眠状态
  
   //被其它工作线程唤醒
   noteclear(&amp;amp;_g_.m.park)
   acquirep(_g_.m.nextp.ptr())
   _g_.m.nextp = 0
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;stopm的核心是调用mput把m结构体对象放入sched的midle空闲队列，然后通过notesleep(&amp;amp;m.park)函数让自己进入睡眠状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;note是go runtime实现的一次性睡眠和唤醒机制，一个线程可以通过调用notesleep(*note)进入睡眠状态，而另外一个线程则可以通过notewakeup(*note)把其唤醒&lt;/strong&gt;。note的底层实现机制跟操作系统相关，不同系统使用不同的机制，比如linux下使用的futex系统调用，而mac下则是使用的pthread_cond_t条件变量，note对这些底层机制做了一个抽象和封装，这种封装给扩展性带来了很大的好处，比如当睡眠和唤醒功能需要支持新平台时，只需要在note层增加对特定平台的支持即可，不需要修改上层的任何代码。&lt;/p&gt;
&lt;p&gt;回到stopm，当从notesleep函数返回后，需要再次绑定一个p，然后返回到findrunnable函数继续重新寻找可运行的goroutine，一旦找到可运行的goroutine就会返回到schedule函数，并把找到的goroutine调度起来运行，如何把goroutine调度起来运行的代码我们已经分析过了。现在继续看notesleep函数。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/lock_futex.go : 139&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func notesleep(n *note) {
        gp := getg()
        if gp != gp.m.g0 {
                throw(&quot;notesleep not on g0&quot;)
        }
        ns := int64(-1)  //超时时间设置为-1，表示无限期等待
        if *cgo_yield != nil {
                // Sleep for an arbitrary-but-moderate interval to poll libc interceptors.
                ns = 10e6
        }
  
        //使用循环，保证不是意外被唤醒
        for atomic.Load(key32(&amp;amp;n.key)) == 0 {
                gp.m.blocked = true
                futexsleep(key32(&amp;amp;n.key), 0, ns)
                if *cgo_yield != nil {
                        asmcgocall(*cgo_yield, nil)
                }
                gp.m.blocked = false
        }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;notesleep函数调用futexsleep进入睡眠，这里之所以需要用一个循环，是因为&lt;strong&gt;futexsleep有可能意外从睡眠中返回&lt;/strong&gt;，所以从futexsleep函数返回后还需要检查note.key是否还是0，如果是0则表示并不是其它工作线程唤醒了我们，只是futexsleep意外返回了，需要再次调用futexsleep进入睡眠。&lt;/p&gt;
&lt;p&gt;futexsleep调用futex函数进入睡眠。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/os_linux.go : 32&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;56&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
// Atomically,
//      if(*addr == val) sleep
// Might be woken up spuriously; that's allowed.
// Don't sleep longer than ns; ns &amp;lt; 0 means forever.
//go:nosplit
func futexsleep(addr *uint32, val uint32, ns int64) {
        var ts timespec

        // Some Linux kernels have a bug where futex of
        // FUTEX_WAIT returns an internal error code
        // as an errno. Libpthread ignores the return value
        // here, and so can we: as it says a few lines up,
        // spurious wakeups are allowed.
        if ns &amp;lt; 0 {
         //调用futex进入睡眠
                futex(unsafe.Pointer(addr), _FUTEX_WAIT_PRIVATE, val, nil, nil, 0)
                return
        }

        // It's difficult to live within the no-split stack limits here.
        // On ARM and 386, a 64-bit divide invokes a general software routine
        // that needs more stack than we can afford. So we use timediv instead.
        // But on real 64-bit systems, where words are larger but the stack limit
        // is not, even timediv is too heavy, and we really need to use just an
        // ordinary machine instruction.
        if sys.PtrSize == 8 {
                ts.set_sec(ns / 1000000000)
                ts.set_nsec(int32(ns % 1000000000))
        } else {
                ts.tv_nsec = 0
                ts.set_sec(int64(timediv(ns, 1000000000, (*int32)(unsafe.Pointer(&amp;amp;ts.tv_nsec)))))
        }
        futex(unsafe.Pointer(addr), _FUTEX_WAIT_PRIVATE, val, unsafe.Pointer(&amp;amp;ts), nil, 0)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;futex是go汇编实现的函数，主要功能就是执行futex系统调用进入操作系统内核进行睡眠。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;runtime/sys_linux_amd64.s : 525&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;// int64 futex(int32 *uaddr, int32 op, int32 val,
//    struct timespec *timeout, int32 *uaddr2, int32 val2)&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;TEXT runtime·futex(SB),NOSPLIT,$&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
    #下面的6条指令在为futex系统调用准备参数
    MOVQ    addr+&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;(FP), DI
    MOVL    op+&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;&lt;span&gt;(FP), SI
    MOVL    val+&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;&lt;span&gt;(FP), DX
    MOVQ    ts+&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;&lt;span&gt;(FP), R10
    MOVQ    addr2+&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;&lt;span&gt;(FP), R8
    MOVL    val3+&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;&lt;span&gt;(FP), R9
    
    MOVL    $SYS_futex, AX   #系统调用编号放入AX寄存器
    &lt;/span&gt;&lt;span&gt;SYSCALL&lt;/span&gt;&lt;span&gt;  #执行futex系统调用进入睡眠，从睡眠中被唤醒后接着执行下一条MOVL指令
    MOVL    AX, &lt;/span&gt;&lt;span&gt;ret&lt;/span&gt;+&lt;span&gt;40&lt;/span&gt;&lt;span&gt;(FP)    #保存系统调用的返回值
    &lt;/span&gt;&lt;span&gt;RET&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;futex系统的参数比较多，其函数原型为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
int64 futex(int32*uaddr, int32op, int32val, structtimespec*timeout, int32*uaddr2, int32val2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里，&lt;strong&gt;futex系统调用为我们提供的功能为如果 *uaddr == val 则进入睡眠，否则直接返回&lt;/strong&gt;。顺便说一下，为什么futex系统调用需要第三个参数val，需要在内核判断*uaddr与val是否相等，而不能在用户态先判断它们是否相等，如果相等才进入内核睡眠岂不是更高效？原因在于判断*uaddr与val是否相等和进入睡眠这两个操作必须是一个原子操作，否则会存在一个&lt;strong&gt;竞态条件&lt;/strong&gt;：如果不是原子操作，则当前线程在第一步判断完*uaddr与val相等之后进入睡眠之前的这一小段时间内，有另外一个线程通过唤醒操作把*uaddr的值修改了，这就会导致当前工作线程永远处于睡眠状态而无人唤醒它。而在用户态无法实现判断与进入睡眠这两步为一个原子操作，所以需要内核来为其实现原子操作。&lt;/p&gt;
&lt;p&gt;我们知道线程一旦进入睡眠状态就停止了运行，那么如果后来又有可运行的goroutine需要工作线程去运行，正在睡眠的线程怎么知道有工作可做了呢？&lt;/p&gt;
&lt;p&gt;从前面的代码我们已经看到，stopm调用notesleep时给它传递的参数是m结构体的park成员，而m又早已通过mput放入了全局的milde空闲队列，这样其它运行着的线程一旦发现有更多的goroutine需要运行时就可以通过全局的m空闲队列找到处于睡眠状态的m，然后调用notewakeup(&amp;amp;m.park)将其唤醒，至于怎么唤醒，我们在其它章节继续讨论。&lt;/p&gt;
&lt;p&gt;到此，我们已经完整分析了调度器的调度策略，从下一章起我们将开始讨论有关调度的另外一个话题：调度时机，即什么时候会发生调度。&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 07:30:00 +0000</pubDate>
<dc:creator>爱写程序的阿波张</dc:creator>
<og:description>本文是《Go语言调度器源代码情景分析》系列的第17篇，也是第三章《Goroutine调度策略》的第2小节。 上一小节我们分析了从全局运行队列与工作线程的本地运行队列获取goroutine的过程，这一小</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/abozhang/p/10881594.html</dc:identifier>
</item>
<item>
<title>redis(上)-背景与使用条件 - 冗热</title>
<link>http://www.cnblogs.com/ggmm20141012/p/10881595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ggmm20141012/p/10881595.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;我们都知道，在互联网项目中往往存在大数据量的需求，比如一些商品抢购的场景，或是访问量瞬间较大的时候，一瞬间成千上万的请求就会到来，比如在双十一活动。这就需要在短时间内完成成千上万次读或者写的操作，对于传统数据库来说，这肯定是不行的，容易使系统宕机，所以这时候NoSQL的出现改变了这个现状，例如一些非关系型数据库redis、文档型mongoDB等等。这篇主要介绍我所认识的redis，由于本人才疏学浅，而且刚刚学习不久，若有说的不对的地方希望各位海涵。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这篇文章主要是作为我现阶段对redis认识的总结，另一方面对未来的我可以随时复习这一内容而准备。redis的性能十分优越，大概每秒可以支持十几万次的读或者写的操作，其性能可以非同一般，而且支持集群、分布式、主从同步等配置，而且还支持一定的事物能力，这就在高并发下保证数据的安全和一致性起到了相当大的作用。redis的性能优越主要来源3个方面：第一，它是基于c语言编写的，因为c是接近汇编语言的机器语言，所以运行快。第二，它是基于内存的读写，读取速度自然会比磁盘读写快多了。第三，他的数据结构只有6种数据类型，结构简单且规则少。一般来说，redis在Java web应用中主要存在于两个场景：一个是缓存常用的数据，让数据用其所用。一个是需要在高并发下快速地的读或者写。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用环境一：缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先，当前时代系统的对数据库的读操作远远大于写的操作，所以这就需要读的性能较强。当发送sql去查询数据的时候，就会去数据库就会把数据从磁盘传过来，通过磁盘就相当的缓慢了，当然这只是对比与redis来说，redis是直接从运营时内存中读取数据，这就会快很多，而且减缓了数据库的压力。但是，并不是说它好我们就必须得用它，有的时候不用它会有更好的效果。一般来说，在使用redis存储数据的时候，需要从3个方面进行考虑：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　1. 业务数据常用吗？命中率如何？如果命中率很低，那就没必要用redis把这一数据写入缓存了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　2. 该业务数据是读操作多？还是写操作多？如果写操作多，那就需要频繁的将数据写到数据库中，redis不是做这个的，所以就没必要将这部分数据写入redis的缓存中了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　3. 业务数据的大小如何？如果要存储几百兆字节的文件，这会给缓存带来巨大的压力，因为会耗费我们的内存，影响速度，有没有必要？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　redis的读取逻辑图如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1669847/201905/1669847-20190517145944007-213334385.png&quot; alt=&quot;&quot; width=&quot;419&quot; height=&quot;296&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　          redis作为缓存的读取逻辑&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　当第一次读取数据的时候，读取redis必然会失败，因为redis里没有这一数据，需要先从数据库中拿，然后写入redis。当第二次及以后读取数据时，就直接读取redis，读到数据就将数据返回，并结束这一流程，这样速度就大大提高了。redis也有写操作的流程，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1669847/201905/1669847-20190517150414100-141320291.png&quot; alt=&quot;&quot; width=&quot;153&quot; height=&quot;205&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　redis写操作的流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　从流程可以看出，更新或者写入的操作，需要多个redis的操作。如果业务数据数据的写操作的次数远大于读操作的次数，那就没有必要使用redis缓存了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　使用环境二：高并发场景-也叫高速读写场合&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　我们所知道的例如商品的秒杀、抢红包，抢票等等，在双十一零点的那个瞬间，可能就会有几十万个请求蜂拥而来，想想要在1秒内或更少时间处理这么多的请求，一般的服务器真是受不了。想想一个瞬间数据库就处理这么多sql语句，这样很可能会造成数据库的瘫痪以及系统宕机。我们也看到过某宝在双十一出现过界面延迟加载，系统崩溃等情况，我想一定要理解他们的工作人员，每次到这个时候都有不少的运维人员加班加点的维修，他们真的很辛苦。所以在这种情况下，我们往往考虑异步地去写入数据库，而在高速读或者写的情况下使用redis去应对，把这些需要高速读或写的数据缓存到redis中，而在满足一定的条件后，再将这些数据写入到内存中。流程图如下所示：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1669847/201905/1669847-20190517151851843-1354472639.png&quot; alt=&quot;&quot; width=&quot;343&quot; height=&quot;256&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　　　　　　　　　  redis在高速读或者写的场合的应用流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　也就是，当一个请求到达服务器，只是把业务数据现在redis上进行读写，而没有进行任何对数据库的操作，换句话说就是，系统仅仅是操作redis缓存，而没有操作数据库，这个速度就比操作数据库要快的多。但是缓存不能持久化，因此需要把这些数据存入数据库，所以在一个请求操作完redis的读或写操作后，会判断该高速读写业务是否结束。这个条件一般是商品剩余个数为0，抢红包剩余金额为0。如果不成立，就不会操作数据库，如果成立，则会触发事件将redis缓存的数据以批量的形式一次性写入数据库，从而完成持久化操作。而实际上，真正的情况远比上述更为复杂，因为实际中要考虑高并发下的数据安全和一致性的问题，以及有效请求无效请求以及事物一致性等诸多问题。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 07:30:00 +0000</pubDate>
<dc:creator>冗热</dc:creator>
<og:description>我们都知道，在互联网项目中往往存在大数据量的需求，比如一些商品抢购的场景，或是访问量瞬间较大的时候，一瞬间成千上万的请求就会到来，比如在双十一活动。这就需要在短时间内完成成千上万次读或者写的操作，对于</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ggmm20141012/p/10881595.html</dc:identifier>
</item>
<item>
<title>深入理解事件机制的实现 - snsart</title>
<link>http://www.cnblogs.com/snsart/p/10881168.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snsart/p/10881168.html</guid>
<description>&lt;h2&gt;一、一个实例&lt;/h2&gt;
&lt;p&gt;假设你在你家客厅里玩游戏，口渴了，需要到厨房开一壶水，等水开了的时候，为了防止水熬干，你需要及时把火炉关掉。为了及时了解到水是否烧开，你有三种策略可以选择：&lt;/p&gt;
&lt;p&gt;1. 守在厨房内，等水烧开&lt;/p&gt;
&lt;p&gt;这种策略显然是很愚蠢的，采取这种策略，在烧水的过程中你将不能做任何事情，效率极低。&lt;/p&gt;
&lt;p&gt;2. 呆在客厅玩游戏，每隔一两分钟跑到厨房看一次&lt;/p&gt;
&lt;p&gt;这种策略，在计算机科学中称为轮询，即每隔一定的时间，监测一次。在这里，也是很不明智的，在玩游戏时需要不断的分心。&lt;/p&gt;
&lt;p&gt;3. 在水壶上安装一个报警器，当水开了的时候，发出警报&lt;/p&gt;
&lt;p&gt;这种策略是最好的，既不耽误自己玩游戏，又能在水开了的时候使自己及时获得通知。这种策略在计算机中通过事件机制来实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1193092/201905/1193092-20190517142552230-833134027.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;二、事件机制的组成&lt;/h2&gt;
&lt;p&gt;通过上面的实例，我们可以抽象出一个事件机制有三个组成部分：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;事件源&lt;/strong&gt;：即事件的发送者，在上例中为水壶；&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;事件&lt;/strong&gt;：事件源发出的一种信息或状态，比如上例的警报声，它代表着水开了；&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;事件侦听者&lt;/strong&gt;：对事件作出反应的对象，比如上例中的你。在设计事件机制时一般把侦听者设计为一个函数，当事件发送时，调用此函数。比如上例中可以把倒水设计为侦听者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1193092/201905/1193092-20190517142628632-113995479.png&quot; alt=&quot;&quot; width=&quot;454&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三、初步实现&lt;/h2&gt;
&lt;p&gt;可以使用面向对象设计中的组合模式，把事件侦听者当做事件源内部的一个对象，当事件发生时，调用侦听者即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;事件源：水壶{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     事件侦听者：你关火；//&lt;span&gt;事件源持有事件侦听者
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    发送（事件：“水开了”）{
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        你关火（）；
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;四、出现多个事件侦听者的情况&lt;/h2&gt;
&lt;p&gt;如果你和你女朋友都在客厅玩游戏，水开的时候应该谁去关火呢？假设精明（懒惰）的你，听到水开的警报声，马上假装上厕所，你女朋友只能无奈地去关火。这种情况下，水壶发出的警报声导致了两个反应：1.你上厕所，2.你女朋友去关火。此时我们要如何实现呢？我们依然可以采用上面的实现方案，再在事件源中添加一个事件侦听者：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;事件源：水壶{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    事件侦听者：你上厕所；
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    事件侦听者：你女朋友关火；
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    发送（事件：“水开了”）{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;            你上厕所（）；
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            你女朋友关火（）；
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但这种设计有一个重大缺陷：事件源和事件侦听者过度耦合。所有侦听者都是硬编码入事件源中，在程序执行过程中无法更改，灵活性极差。比如，有一天你女朋友外出了，只能你去关火，那么上面的事件源就需要重新修改。我们可以采用下面的方法使事件源和事件侦听者解耦：&lt;/p&gt;
&lt;p&gt;1.事件源中定义一个列表，比如数组，用来存储所有侦听者；&lt;/p&gt;
&lt;p&gt;2.为列表留一个增删数据的接口，用来随时添加和删除侦听者；&lt;/p&gt;
&lt;p&gt;3.当发送事件时，遍历并执行列表中的侦听者&lt;/p&gt;
&lt;p&gt;实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;事件源：水壶{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    事件侦听者：侦听者列表[]；
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    添加事件侦听者(侦听者){
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        侦听者列表加入侦听者
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    删除事件侦听者(侦听者){
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        侦听者列表移除侦听者
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    发送（事件）{
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     　　//&lt;span&gt;遍历并执行列表中的侦听者
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    　　for(侦听者 in 侦听者列表){
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        　　执行侦听者
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    　　}
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 　　&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种实现方案即为观察者设计模式，可以让侦听者预订事件。&lt;/p&gt;
&lt;h2&gt;五、事件源可发送多种事件的情况&lt;/h2&gt;
&lt;p&gt;假设你家的水壶有点智能，当水温达到90度的时候，会发出一个“水快开了”的警报，为你提前逃到厕所偷懒留出了充足的时间，这种情况下的事件和侦听者的对应关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1193092/201905/1193092-20190517141720496-633102847.png&quot; alt=&quot;&quot; width=&quot;480&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在添加和删除侦听者的时候，把事件类型和侦听者绑定成一个数组（或对象），再加入侦听者列表。在发送事件时，在列表中查找和当前事件绑定的侦听器执行:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;事件源：水壶{

    事件侦听者：侦听者列表[]；

    添加事件侦听者(事件类型，侦听者){
        带类型侦听者&lt;/span&gt;=[事件类型，侦听者]；//&lt;span&gt;通过数组把事件类型和侦听者绑定
        侦听者列表加入带类型侦听者；
    }
    删除事件侦听者(事件类型，侦听者){
        通过事件类型和侦听者查找列表中对应的侦听器删除；
    }

    发送（事件类型）{
        &lt;/span&gt;//&lt;span&gt;遍历并执行列表中的侦听者
        for(带类型侦听者 in 侦听者列表){
            if(带类型侦听者[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;]==&lt;span&gt;事件类型){
                    带类型侦听者[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;]()//&lt;span&gt;执行对应的侦听器    
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;把上面的文字描述翻译成伪码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;水壶类&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;Kettle{
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    array:Listeners[]；
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    addEventListener(eventType，listener){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         typeListener=[eventType，listener];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过数组把事件类型和侦听者绑定&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        Listeners.push(typeListener);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    removeEventListener(eventType，listener){
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        Listeners.delete([eventType，listener]);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    dispatch（eventType）{
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历并执行列表中的侦听者&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt;(typeListener in Listeners){
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(typeListener[0]==&lt;span&gt;eventType){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 typeListener[1]()&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行对应的侦听器    &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;goWc(){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;你上厕所&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;turnOffFire(){
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;女朋友关火&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; kettle=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Kettle();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;水壶注册水快开了事件&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; kettle.addEventListener(&quot;水快开了&quot;&lt;span&gt;，goWC);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; kettle.addEventListener(&quot;水开了&quot;&lt;span&gt;，turnOffFire);    
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; kettle.dispatch(&quot;水快开了&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;优化&lt;/strong&gt;：遵循&quot;针对接口编程&quot;的设计原则，应该为水壶、事件、侦听器设计一个基类，其他具体的类继承这些基类；&lt;/p&gt;
&lt;h2&gt;六、显示对象上的事件：理解事件流&lt;/h2&gt;
&lt;p&gt;当事件发生在显示对象上(比如浏览器)的时候，会遇到一个很有趣的问题：页面的那一部分会拥有某个特定的事件？比如当你点击页面上的一栋小房子的时候，根据视角的远近，你点击的对象会发生变化。从最远处来看你点击的是页面，镜头拉近你点击的是小房子，再拉近你点击的是房子上的一面墙，再拉近你点击的是墙上的一块砖。也就是说，你点击一次页面也许会有很多显示对象发生了点击事件，如果你在每一个显示对象上都绑定了点击处理程序，那么这些程序都会执行。这里会遇到一个问题：&lt;strong&gt;这些程序按什么顺序执行&lt;/strong&gt;。这取决于显示对象接受到点击事件的顺序，一般有两种模式：事件冒泡和事件捕获。这种事件在显示对象上按顺序发生的过程称为事件流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 事件冒泡&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事件冒泡，即事件开始时由最具体的元素(比如上例的砖块)接受，然后逐级向上传播到较为不具体的节点(文档);&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 事件捕获&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事件捕获的思想是不太具体的元素(文档)更早的接受事件，而最具体的元素最后接受到事件(砖块)。事件捕获的用意在于事件到达预订目标之间捕获它。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1193092/201905/1193092-20190517142250442-1198481376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在JavaScript中为DOM中的元素添加事件处理程序时，有三个参数，其中第三个参数是一个布尔值，当为true时，表示在捕获阶段调用事件处理程序，为false时，表示在冒泡阶段调用事件处理程序，举例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;body&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &amp;lt;div id=&quot;outer&quot;&amp;gt;
&lt;span&gt; 3&lt;/span&gt;         &amp;lt;div id=&quot;inner&quot; &amp;gt;
&lt;span&gt; 4&lt;/span&gt;         &amp;lt;/div&amp;gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;/div&amp;gt;
&lt;span&gt; 6&lt;/span&gt; &amp;lt;/body&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;例一&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; btn1=document.getElementById(&quot;outer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; btn1.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     alert('outer'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; },&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; btn2=document.getElementById(&quot;inner&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; btn2.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     alert('inner'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; },&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;例二&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; btn1=document.getElementById(&quot;outer&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; btn1.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     alert('outer'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; },&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; btn2=document.getElementById(&quot;inner&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; btn2.addEventListener(&quot;click&quot;,&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     alert('inner'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; },&lt;span&gt;false&lt;/span&gt;);    
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面例一的事件处理程序都发生在冒泡阶段，所以会先输出inner，再输出outer。例二中id为outer元素上的事件处理程序发生在捕获阶段，所以会先输出outer，再输出inner。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：事件流发生在父元素和子元素之间，而不是两个同级的元素。&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 06:50:00 +0000</pubDate>
<dc:creator>snsart</dc:creator>
<og:description>本文通过一个实例说明了什么是事件，事件机制有哪些组成部分，并深入梳理了事件机制的整个实现过程。最后通过DOM讲解了发生在显示对象上的事件及事件流。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snsart/p/10881168.html</dc:identifier>
</item>
<item>
<title>如何运用多阶构建编写优雅的Dockerfile - 宜信技术</title>
<link>http://www.cnblogs.com/yixinjishu/p/10881141.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yixinjishu/p/10881141.html</guid>
<description>&lt;h2 id=&quot;toc_0&quot;&gt;导读&lt;/h2&gt;
&lt;p&gt;Kubernetes要从容器化开始，而容器又需要从Dockerfile开始，本文将介绍如何写出一个优雅的Dockerfile文件。&lt;/p&gt;
&lt;p&gt;文章主要内容包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;Docker容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dockerfile&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用多阶构建&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;感谢公司提供大量机器资源及时间让我们可以实践，感谢在此专题上不断实践的部分项目及人员的支持。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190423/1556008455394029400.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;一、Docker容器&lt;/h2&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;1.1 容器的特点&lt;/h3&gt;
&lt;p&gt;我们都知道容器就是一个标准的软件单元，它有以下特点：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;高资源利用率：容器提供进程级的隔离，因此可以更加精细地设置CPU和内存的使用率，进而更好地利用服务器的计算资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;toc_3&quot;&gt;1.2 Docker容器&lt;/h3&gt;
&lt;p&gt;目前市面上的主流容器引擎有Docker、Rocket/rkt、OpenVZ/Odin等等，而独霸一方的容器引擎就是使用最多的Docker容器引擎。&lt;/p&gt;
&lt;p&gt;Docker容器是与系统其他部分隔离开的一系列进程，运行这些进程所需的所有文件都由另一个镜像提供，从开发到测试再到生产的整个过程中，Linux 容器都具有可移植性和一致性。相对于依赖重复传统测试环境的开发渠道，容器的运行速度要快得多，并且支持在多种主流云平台（PaaS）和本地系统上部署。Docker容器很好地解决了“开发环境能正常跑，一上线就各种崩”的尴尬。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190423/1556008479934006320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Docker容器的特点：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;轻量：容器是进程级的资源隔离，而虚拟机是操作系统级的资源隔离，所以Docker容器相对于虚拟机来说可以节省更多的资源开销，因为Docker容器不再需要GuestOS这一层操作系统了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;快速：容器的启动和创建无需启动GuestOS，可以实现秒级甚至毫秒级的启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;可移植性：Docker容器技术是将应用及所依赖的库和运行时的环境技术改造包成容器镜像，可以在不同的平台运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;自动化：容器生态中的容器编排工作（如：Kubernetes）可帮助我们实现容器的自动化管理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_4&quot;&gt;二、Dockerfile&lt;/h2&gt;
&lt;p&gt;Dockerfile是用来描述文件的构成的文本文档，其中包含了用户可以在使用行调用以组合Image的所有命令，用户还可以使用Docker build实现连续执行多个命令指今行的自动构建。&lt;/p&gt;
&lt;p&gt;通过编写Dockerfile生磁镜像，可以为开发、测试团队提供基本一致的环境，从而提升开发、测试团队的效率，不用再为环境不统一而发愁，同时运维也能更加方便地管理我们的镜像。&lt;/p&gt;
&lt;p&gt;Dockerfile的语法非常简单，常用的只有11个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190423/1556008492455079426.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;toc_5&quot;&gt;2.1 编写优雅地Dockerfile&lt;/h3&gt;
&lt;p&gt;编写优雅的Dockerfile主要需要注意以下几点：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Dockerfile文件不宜过长，层级越多最终制作出来的镜像也就越大。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;构建出来的镜像不要包含不需要的内容，如日志、安装临时文件等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尽量使用运行时的基础镜像，不需要将构建时的过程也放到运行时的Dockerfile里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只要记住以上三点就能写出不错的Dockerfile。&lt;/p&gt;
&lt;p&gt;为了方便大家了解，我们用两个Dockerfile实例进行简单的对比：&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
FROM ubuntu:&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;
RUN apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt;&lt;span&gt; update
RUN apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt; install -y apt-utils libjpeg-&lt;span&gt;dev \     
python&lt;/span&gt;-&lt;span&gt;pip
RUN pip install &lt;/span&gt;--&lt;span&gt;upgrade pip
RUN easy_install &lt;/span&gt;-&lt;span&gt;U setuptools
RUN apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt; clean
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
FROM ubuntu:&lt;span&gt;16.04&lt;/span&gt;&lt;span&gt;
RUN apt&lt;/span&gt;-&lt;span&gt;get&lt;/span&gt; update &amp;amp;&amp;amp; apt-&lt;span&gt;get&lt;/span&gt; install -y apt-&lt;span&gt;utils \
  libjpeg&lt;/span&gt;-dev python-&lt;span&gt;pip \
           &lt;/span&gt;&amp;amp;&amp;amp; pip install --&lt;span&gt;upgrade pip \
      &lt;/span&gt;&amp;amp;&amp;amp; easy_install -&lt;span&gt;U setuptools \
    &lt;/span&gt;&amp;amp;&amp;amp; apt-&lt;span&gt;get&lt;/span&gt; clean
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;我们看第一个Dockerfile，乍一看条理清晰，结构合理，似乎还不错。再看第二个Dockerfile，紧凑，不易阅读，为什么要这么写？&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第一个Dockerfile的好处是：当正在执行的过程某一层出错，对其进行修正后再次Build，前面已经执行完成的层不会再次执行。这样能大大减少下次Build的时间，而它的问题就是会因层级变多了而使镜像占用的空间也变大。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;第二个Dockerfile把所有的组件全部在一层解决，这样做能一定程度上减少镜像的占用空间，但在制作基础镜像的时候若其中某个组编译出错，修正后再次Build就相当于重头再来了，前面编译好的组件在一个层里，得全部都重新编译一遍，比较消耗时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从下表可以看出两个Dockerfile所编译出来的镜像大小：&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
$ docker images |&lt;span&gt; grep ubuntu      
REPOSITORY      TAG     IMAGE ID    CREATED     SIZE                                                                                                                                   
ubuntu                   &lt;/span&gt;&lt;span&gt;16.04&lt;/span&gt;       9361ce633ff1  &lt;span&gt;1&lt;/span&gt;&lt;span&gt; days ago 422MB
ubuntu                   &lt;/span&gt;&lt;span&gt;16.04&lt;/span&gt;-&lt;span&gt;1&lt;/span&gt;   3f5b979df1a9  &lt;span&gt;1&lt;/span&gt; days ago  412MB
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;呃…. 好像并没有特别的效果，但若Dockerfile非常长的话可以考虑减少层次，因为Dockerfile最高只能有127层。&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;三、使用多阶构建&lt;/h2&gt;
&lt;p&gt;Docker在升级到Docker 17.05之后就能支持多阶构建了，为了使镜像更加小巧，我们采用多阶构建的方式来打包镜像。在多阶构建出现之前我们通常使用一个Dockerfile或多个Dockerfile来构建镜像。&lt;/p&gt;
&lt;h3 id=&quot;toc_7&quot;&gt;3.1单文件构建&lt;/h3&gt;
&lt;p&gt;在多阶构建出来之前使用单个文件进行构建，单文件就是将所有的构建过程（包括项目的依赖、编译、测试、打包过程）全部包含在一个Dockerfile中之下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
FROM golang:&lt;span&gt;1.11&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-alpine3.&lt;span&gt;8&lt;/span&gt; AS build-&lt;span&gt;env
ENV GO111MODULE&lt;/span&gt;=&lt;span&gt;off
ENV GO15VENDOREXPERIMENT&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
ENV BUILDPATH&lt;/span&gt;=github.com/lattecake/&lt;span&gt;hello
RUN mkdir &lt;/span&gt;-p /go/src/&lt;span&gt;${BUILDPATH}
COPY .&lt;/span&gt;/ /go/src/&lt;span&gt;${BUILDPATH}
RUN cd &lt;/span&gt;/go/src/${BUILDPATH} &amp;amp;&amp;amp; CGO_ENABLED=&lt;span&gt;0&lt;/span&gt; GOOS=linux GOARCH=&lt;span&gt;amd64 go install –v

CMD [&lt;/span&gt;/go/bin/hello]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;这种的做法会带来一些问题：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Dockerfile文件会特别长，当需要的东西越来越多的时候可维护性指数级将会下降；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;镜像层次过多，镜像的体积会逐步增大，部署也会变得越来越慢；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;代码存在泄漏风险。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以Golang为例，它运行时不依赖任何环境，只需要有一个编译环境，那这个编译环境在实际运行时是没有任务作用的，编译完成后，那些源码和编译器已经没有任务用处了也就没必要留在镜像里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190423/1556008510096072102.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上表可以看到，单文件构建最终占用了312MB的空间。&lt;/p&gt;
&lt;h3 id=&quot;toc_8&quot;&gt;3.2 多文件构建&lt;/h3&gt;
&lt;p&gt;在多阶构建出来之前有没有好的解决方案呢？有，比如采用多文件构建或在构建服务器上安装编译器，不过在构建服务器上安装编译器这种方法我们就不推荐了，因为在构建服务器上安装编译器会导致构建服务器变得非常臃肿，需要适配各个语言多个版本、依赖，容易出错，维护成本高。所以我们只介绍多文件构建的方式。&lt;/p&gt;
&lt;p&gt;多文件构建，其实就是使用多个Dockerfile，然后通过脚本将它们进行组合。假设有三个文件分别是：Dockerfile.run、Dockerfile.build、build.sh。&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Dockerfile.run就是运行时程序所必须需要的一些组件的Dockerfile，它包含了最精简的库；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Dockerfile.build只是用来构建，构建完就没用了；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;build.sh的功能就是将Dockerfile.run和Dockerfile.build进行组成，把Dockerfile.build构建好的东西拿出来，然后再执行Dockerfile.run，算是一个调度的角色。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Dockerfile.build&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
FROM golang:&lt;span&gt;1.11&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-alpine3.&lt;span&gt;8&lt;/span&gt; AS build-&lt;span&gt;env
ENV GO111MODULE&lt;/span&gt;=&lt;span&gt;off
ENV GO15VENDOREXPERIMENT&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
ENV BUILDPATH&lt;/span&gt;=github.com/lattecake/&lt;span&gt;hello
RUN mkdir &lt;/span&gt;-p /go/src/&lt;span&gt;${BUILDPATH}
COPY .&lt;/span&gt;/ /go/src/&lt;span&gt;${BUILDPATH}
RUN cd &lt;/span&gt;/go/src/${BUILDPATH} &amp;amp;&amp;amp; CGO_ENABLED=&lt;span&gt;0&lt;/span&gt; GOOS=linux GOARCH=amd64 go install –v
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Dockerfile.run&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;FROM alpine:latest
RUN apk –no&lt;/span&gt;-cache add ca-&lt;span&gt;certificates
WORKDIR &lt;/span&gt;/&lt;span&gt;root
ADD hello .
CMD [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Build.sh&lt;/strong&gt;&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#!/bin/&lt;span&gt;sh
docker build &lt;/span&gt;-t –rm hello:build . -&lt;span&gt;f Dockerfile.build
docker create –name extract hello:build
docker cp extract:&lt;/span&gt;/go/bin/hello ./&lt;span&gt;hello
docker rm &lt;/span&gt;-&lt;span&gt;f extract
docker build –no&lt;/span&gt;-cache -t –rm hello:run . -&lt;span&gt;f Dockerfile.run
rm &lt;/span&gt;-rf ./hello
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;执行build.sh完成项目的构建。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190423/1556008521921021707.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上表可以看到，多文件构建大大减小了镜像的占用空间，但它有三个文件需要管理，维护成本也更高一些。&lt;/p&gt;
&lt;h3 id=&quot;toc_9&quot;&gt;3.3 多阶构建&lt;/h3&gt;
&lt;p&gt;最后我们来看看万众期待的多阶构建。&lt;/p&gt;
&lt;p&gt;完成多阶段构建我们只需要在Dockerfile中多次使用FORM声明，每次FROM指令可以使用不同的基础镜像，并且每次FROM指令都会开始新的构建，我们可以选择将一个阶段的构建结果复制到另一个阶段，在最终的镜像中只会留下最后一次构建的结果，这样就可以很容易地解决前面提到的问题，并且只需要编写一个Dockerfile文件。这里值得注意的是：需要确保Docker的版本在17.05及以上。下面我们来说说具体操作。&lt;/p&gt;
&lt;p&gt;在Dockerfile里可以使用as来为某一阶段取一个别名”build-env”：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
FROM golang:&lt;span&gt;1.11&lt;/span&gt;.&lt;span&gt;2&lt;/span&gt;-alpine3.&lt;span&gt;8&lt;/span&gt; AS build-env
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;然后从上一阶段的镜像中复制文件，也可以复制任意镜像中的文件：&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
COPY –&lt;span&gt;from&lt;/span&gt;=build-env /go/bin/hello /usr/bin/hello 
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;看一个简单的例子：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
FROM golang:&lt;span&gt;1.11&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;-alpine3.&lt;span&gt;8&lt;/span&gt; AS build-&lt;span&gt;env
 
ENV GO111MODULE&lt;/span&gt;=&lt;span&gt;off
ENV GO15VENDOREXPERIMENT&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;&lt;span&gt;
ENV GITPATH&lt;/span&gt;=github.com/lattecake/&lt;span&gt;hello
RUN mkdir &lt;/span&gt;-p /go/src/&lt;span&gt;${GITPATH}
COPY .&lt;/span&gt;/ /go/src/&lt;span&gt;${GITPATH}
RUN cd &lt;/span&gt;/go/src/${GITPATH} &amp;amp;&amp;amp; CGO_ENABLED=&lt;span&gt;0&lt;/span&gt; GOOS=linux GOARCH=amd64 go install -&lt;span&gt;v
 
FROM alpine:latest
ENV apk –no&lt;/span&gt;-cache add ca-&lt;span&gt;certificates
COPY &lt;/span&gt;--&lt;span&gt;from&lt;/span&gt;=build-env /go/bin/hello /root/&lt;span&gt;hello
WORKDIR &lt;/span&gt;/&lt;span&gt;root
CMD [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/root/hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;执行docker build -t –rm hello3 .后再执行docker images ，然后我们来看镜像的大小：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190423/1556008529881019210.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多阶构建给我们带来很多便利，最大的优势是在保证运行镜像足够小的情况下还减轻了Dockerfile的维护负担，因此我们极力推荐使用多阶构建来将你的代码打包成Docker 镜像。&lt;/p&gt;
&lt;p&gt;内容来源：&lt;a href=&quot;https://mp.weixin.qq.com/s/24xdWJ2SZ4ODg5T6yD7BwQ&quot;&gt;宜信技术学院&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 06:28:00 +0000</pubDate>
<dc:creator>宜信技术</dc:creator>
<og:description>Kubernetes要从容器化开始，而容器又需要从Dockerfile开始，本文将介绍如何写出一个优雅的Dockerfile文件。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yixinjishu/p/10881141.html</dc:identifier>
</item>
<item>
<title>跟我学: 使用 fireasy 搭建 asp.net core 项目系列之一 —— 开篇 - fireasy</title>
<link>http://www.cnblogs.com/fireasy/p/10880617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fireasy/p/10880617.html</guid>
<description>&lt;p&gt;    fireasy 面世都有六个年头了，至今依旧是默默无闻，知道它的人可能仅限于本人朋友圈内的人士。本人也在写一本关于如何使用该框架的书籍，但苦于事务繁忙，至今也才写了一半，可以说最为实用最为核心的部分，仍然还没有写出来。思来想去，还是通过博文这种方式，通过一个实例的讲解，让朋友们对 fireasy 有个了解吧。&lt;/p&gt;
&lt;p&gt;    首先，得先说说这个fireasy是用来干嘛的。&lt;/p&gt;
&lt;p&gt;    fireasy 是一个灵活度比较高的开发框架，它秉承灵活、开放的态度，包容万事万物。它包括 Common、Data、Entity 三个核心类库，集成了 mvc、easyui、redis、mongodb、rabbitmq、nlog、log4net 等框架，使之能够轻松搭建基于 .net framework 或 .net core 的项目。&lt;/p&gt;
&lt;p&gt;    从面世至今，本人个人及公司的所有项目，均使用 fireasy 进行搭建，可以说无时无刻不在完善和优化。同时呢，fireasy 也发布到了 nuget，对于安装和更新来说绝对是再方便不过了。&lt;/p&gt;
&lt;p&gt;    在 nuget 里搜索 fireasy 关键词，所有最新的组件都以最新的时间更新于此。&lt;/p&gt;
&lt;p&gt;    fireasy 是开源的，git 仓库位于 &lt;a href=&quot;https://github.com/faib920/fireasy2&quot; target=&quot;_blank&quot;&gt;https://github.com/faib920/fireasy2&lt;/a&gt;，随它开源的还有一个实例项目zero，&lt;a href=&quot;https://github.com/faib920/zero&quot; target=&quot;_blank&quot;&gt;https://github.com/faib920/zero&lt;/a&gt;，感兴趣的朋友可以前去了解，记得给星哦，希望你随时给本人提出好的建议，如果你和我趣味相投，也欢迎一起维护和完善它。&lt;/p&gt;
&lt;p&gt;    fireasy 有很多的组件，下面先让大家对它们有个大概的认识。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;一、Fireasy.Common&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Fireasy.Common 是通用的组件库，通过它可以实现配置、日志、缓存、消息订阅、AOP、IOC、动态/静态编译、json/xml/binary 序列化、加密解密等。Common 中还提供了大量的扩展方法。&lt;/p&gt;
&lt;p&gt;    这些组件抽象出来的接口，可由外部的第三方进行适配，比如日志组件，可由 NLog、log4net 等来适配，缓存组件，可由 redis、memcached 等来适配。消息订阅组件可由 redis、rabbitMQ 等来适配，只需实现标准的接口抽象，然后通过配置就可以使用了。&lt;/p&gt;
&lt;p&gt;    AOP 和动态编译贯穿整个 fireasy，为实体框架层提供了很好的解决方案（后面会介绍），IOC 可以与 .net core 相融合。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;二、Fireasy.Data&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Fireasy.Data 是数据层组件库，IDatabase 为抽象出来的数据库操作接口，通过它可以实现数据库的增、删、改、查等操作，它是通过 IProvider 进行扩展的，目前支持的数据库类型有 sqlite、sqlserver、mysql、oracle、firebird、postgresql 等，有能力的朋友可以自己去扩展 。同时，还提供了语法、架构、批量插入、自增量、记录包装等插件服务。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/273258/201905/273258-20190517130037461-986492940.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/273258/201905/273258-20190517130037461-986492940.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;三、Fireasy.Data.Entity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    顾名思义，即实体框架组件库，与 Entity Framework 比较相似，其 linq 语法支持基本上完全一致，对于用过 Entity Framework 的朋友来说，要上手完全不需要什么学习成本。&lt;/p&gt;
&lt;p&gt;    使用 Fireasy Entity 较之 Entity Framework 有一些明显的好处，比如接近于原生sql的 Insert、Update、Delete语法，实体的按需更新，Select 里复杂的构造，json序列化时对于延迟加载的处理等等，这些都会在以后的实例中一一讲解。&lt;/p&gt;
&lt;p&gt;    Entity 组件也是基于灵活的接口配置，比如你要引入 mongodb ，只需要配置 MongoDbProvider 即可，业务层没有任何的改变。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/273258/201905/273258-20190517142849252-1873408669.png&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/273258/201905/273258-20190517142849252-1873408669.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;   &lt;strong&gt;四、Fireasy.Web.Mvc&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Fireasy.Web.Mvc 为 asp.net mvc 提供了一些底层的支持，比如 json 模型的绑定和序列化、异常处理等等。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;五、Fireasy.Web.EasyUI&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Fireasy.Web.EasyUI 是 easyui 的扩展库，为 IHtmlHelper 添加扩展方法，同时将实体验证的特性附加到 easyui 中。&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;六、其他&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Fireasy.Redis 为redis 的支持类库，引用该类库后，只要完成 redis 的参数配置，就可以在 fireasy 里使用 redis 作为缓存和消息队列了。&lt;/p&gt;
&lt;p&gt;    Fireasy.NLog 和 fireasy.log4net 分别为 nlog 和 log4net 提供了适配。&lt;/p&gt;
&lt;p&gt;    Fireasy.RabbitMQ 为 rabbitmq 提供适配，使 fireasy 能够使用 rabbitmq 来处理消息队列。&lt;/p&gt;
&lt;p&gt;    Fireasy.MongoDB 使 fireasy 能够使用 mongodb，而不需要改动实体模型及业务层。&lt;/p&gt;
&lt;p&gt;    Fireasy.WebSockets 作为 websocket 通信的组件，借鉴了 singnalR 的思想，使用 handler 来提供方法进行消息交换。&lt;/p&gt;

&lt;p&gt;    以上就是 fireasy 大家庭中的所有组件，接下来的各篇文章里都会有所提及，对此感兴趣的朋友请随时关注博客的更新。&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 06:11:00 +0000</pubDate>
<dc:creator>fireasy</dc:creator>
<og:description>fireasy 面世都有六个年头了，至今依旧是默默无闻，知道它的人可能仅限于本人朋友圈内的人士。本人也在写一本关于如何使用该框架的书籍，但苦于事务繁忙，至今也才写了一半，可以说最为实用最为核心的部分，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fireasy/p/10880617.html</dc:identifier>
</item>
<item>
<title>推荐一款让你纵横Github的读码神器 - 程序猿DD</title>
<link>http://www.cnblogs.com/didispace/p/10880936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/didispace/p/10880936.html</guid>
<description>&lt;p&gt;当我们想深入了解一个开源项目的时候，通常我们有以下几种姿势：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;懒汉型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过Web的方式，逐个的点击页面寻找和查看具体的源码内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201905/626506-20190517135522743-917406303.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：不依赖任何工具，无须任何额外的操作&lt;br/&gt;&lt;strong&gt;缺点&lt;/strong&gt;：效率低下，查找文件不便，切换查看更不便&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;极客型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过git clone或download的方式，将项目源文件下载到本地，然后通过自己最顺手的IDE打开阅读。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201905/626506-20190517135536938-156601688.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：依靠强大的IDE功能可以快速的搜索以及高效的查看源码&lt;br/&gt;&lt;strong&gt;缺点&lt;/strong&gt;：需要下载源码，并且依赖第三方工具&lt;/p&gt;
&lt;h3 id=&quot;本期推荐&quot;&gt;本期推荐&lt;/h3&gt;
&lt;p&gt;上面的方式从效率与成本上来说，都各有优缺点。那么是不是有什么方式，可以同时兼顾呢？&lt;/p&gt;
&lt;p&gt;下面就隆重请出本期的重点推荐：Chrome插件Octotree。&lt;/p&gt;
&lt;p&gt;TJ我将其定义为：&lt;strong&gt;优雅型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先来看看效果，比如我们来看看它自己的源代码（该插件本身也是个开源项目，有兴趣的读者也可以直接查看哦：&lt;a href=&quot;https://github.com/ovity/octotree&quot; class=&quot;uri&quot;&gt;https://github.com/ovity/octotree&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201905/626506-20190517135556532-1757067957.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，在页面的左侧区域会展现出当前打开项目的树状结构。我们可以很轻松的在这里查看到整个项目的目录结构，可以很方便的定位和打开我们想要查看的源代码文件。再也不用像&lt;strong&gt;懒汉型&lt;/strong&gt;方式那样，一个个目录的点开刷新页面逐层查看那么笨拙、低效，同时由于通过Chrome插件的方式扩展，所以我们也不需要额外的成本支出。&lt;/p&gt;
&lt;p&gt;所以，我觉得如果用两次字来形容，那么”优雅“二字当之无愧。如果要用一个字来形容，那么我觉得只能用”骚“字了，你们觉得呢？&lt;/p&gt;
&lt;h3 id=&quot;如何安装&quot;&gt;如何安装&lt;/h3&gt;
&lt;p&gt;如果您对这个插件感兴趣，并且还不知道如何安装Chrome插件，那么就继续看下去：&lt;/p&gt;
&lt;p&gt;第一步：打开Chrome的扩展商店，搜索”Octotree“&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201905/626506-20190517135614024-2096584267.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二步：在搜索结果中，点击”添加至Chrome“即可完成安装！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/626506/201905/626506-20190517135622268-1464820349.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第三步：重启Chrome，打开Github，开始探索神器的Github大陆吧~&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果因为各种原因，您无法通过Google安装插件。那么关注我的公众号&quot;程序猿DD&quot;，回复：Octotree，直接获取安装文件。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 May 2019 05:57:00 +0000</pubDate>
<dc:creator>程序猿DD</dc:creator>
<og:description>当我们想深入了解一个开源项目的时候，通常我们有以下几种姿势： 懒汉型 通过Web的方式，逐个的点击页面寻找和查看具体的源码内容。 优点 ：不依赖任何工具，无须任何额外的操作 缺点 ：效率低下，查找文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/didispace/p/10880936.html</dc:identifier>
</item>
<item>
<title>通俗易懂，什么是.NET Core以及.NET Core能做什么 - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10880884.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10880884.html</guid>
<description>&lt;blockquote readability=&quot;2.0987654320988&quot;&gt;
&lt;p&gt;作者：依乐祝&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/yilezhu/p/10880884.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/yilezhu/p/10880884.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们都知道.NET Core是一个可以用来构建现代、可伸缩和高性能的跨平台软件应用程序的通用开发框架。可用于为Windows、Linux和MacOS构建软件应用程序。与其他软件框架不同，.NET Core是最通用的框架，可用于构建各种软件，包括Web应用程序、移动应用程序、桌面应用程序、云服务、微服务、API、游戏和物联网应用程序。与其他框架不同，.NET Core并不局限于单一的编程语言，它支持C#、VB.NET、F#、XAML和TypeScript。这些编程语言都是开源的，由独立的社区管理。&lt;/p&gt;
&lt;p&gt;.NET Core提供了最先进、最成熟和最广泛的类库、公共API、多语言支持和工具。借助于Visual Studio 2019和Visual Studio Code 这些最先进和最现代的开发工具，使得.NET Core成为开发人员最高效的平台之一。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 微软最近宣布了.NET 5，这是.NET Core的未来。将来，.NET Core将改名为.NET，下一个版本的.NET Core将是.NET 5.0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;net-core的历史&quot;&gt;&lt;strong&gt;.NET Core的历史&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;.NET Core是由Microsoft开发，目前在.NET Foundation(一个非营利的开源组织)下进行管理。.NET Core是用C#和C++编写的，并采用MIT协议作为开源协议。第一个版本的.NET Core 1.0是在2016年发布的，功能有限。NET Core 2.0于2017年8月14日发布。在这个版本中发布的两个核心框架是ASP.NET Core2.0和 Entity Framework Core 2.0。下一个稳定版本.NET Core 2.1和2.2于2018年5月和12月发布。.NET Core的当前版本为3.0.0，并且在2019年5月6日发布了第5个预览版。&lt;/p&gt;
&lt;p&gt;下表总结了.NET Core的主要里程碑：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;.NET Core 1.0&lt;/td&gt;
&lt;td&gt;6/27/2016&lt;/td&gt;
&lt;td&gt;VisualStudio 2015 Update 3支持的.NET Core的初始版本。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;.net Core 1.1.1&lt;/td&gt;
&lt;td&gt;3/7/2017&lt;/td&gt;
&lt;td&gt;.NET Core Tools 1.0受VisualStudio 2017支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;.NET Core 2.0&lt;/td&gt;
&lt;td&gt;8/14/2017&lt;/td&gt;
&lt;td&gt;VisualStudio 2017 15.3，ASP.NETCore 2.0，实体框架2.0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;.NET Core 2.1&lt;/td&gt;
&lt;td&gt;5/30/2018&lt;/td&gt;
&lt;td&gt;ASP.NET Core 2.1，EF Core 2.1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;.NET Core 2.2&lt;/td&gt;
&lt;td&gt;12/4/2018&lt;/td&gt;
&lt;td&gt;ASP.NET Core 2.2，EF Core 2.2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;.NET Core 3.0预览3&lt;/td&gt;
&lt;td&gt;3/6/2019&lt;/td&gt;
&lt;td&gt;通过VisualStudio2019支持ASP.NET Core 3.0、EF Core3.0、UWP、Windows窗体、WPF。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;net-core的特点&quot;&gt;&lt;strong&gt;.NET Core的特点&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;.NET Core的主要特性包括开源、跨平台、现代、灵活、轻量级、快速、友好、可共享，以及为未来的软件开发而构建的。&lt;/p&gt;
&lt;h3 id=&quot;net-core是免费和开源的&quot;&gt;&lt;strong&gt;.NET Core是免费和开源的&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;.NET Core平台是免费的、开源的。.NET Core的源代码托管在Github上。任何开发人员都可以参与到.NET Core的开发。有数千名参与.NET Core开发的活跃开发人员正在改进特性、添加新特性以及修复bug和问题。&lt;/p&gt;
&lt;p&gt;.NET Core由一个名为.NET Foundation的独立的非营利组织管理。60，000多名开发人员和3，700多家公司正在为.NET生态系统做出贡献。&lt;/p&gt;
&lt;p&gt;.NET Core是免费的，并且采用MIT和Apache协议作为开源协议。对商业十分友好。不像某Java&lt;/p&gt;
&lt;p&gt;了解更多信息并下载.NET Core&lt;a href=&quot;https://github.com/dotnet/core&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;net-core是跨平台的&quot;&gt;&lt;strong&gt;.NET Core是跨平台的&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;.NET Core支持并运行在Windows、MacOS和Linux操作系统上。.NET Core跨体系结构(包括x64、x86和ARM)是一致的。可以导入相同的程序集和库，并在多个平台上使用。这些程序集和库都可以使用如下的.NET语言进行构建，如：C#、VB.NET或F#。&lt;/p&gt;
&lt;h3 id=&quot;net-core是可共享的&quot;&gt;&lt;strong&gt;.NET Core是可共享的&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;.NET Core使用一种用.NET Standard编写的一致API模型，这种模型对所有.NET应用程序都是通用的。相同的API或库可以与多种语言的多个平台一起使用。&lt;/p&gt;
&lt;h3 id=&quot;net-core是现代的&quot;&gt;&lt;strong&gt;.NET Core是现代的&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;与一些较旧的框架不同，.NET Core旨在解决当今的现代需求，包括移动友好、构建一次在任何地方运行、可伸缩和高性能。.NET Core旨在构建针对各种设备的应用程序，包括物联网和游戏机。&lt;/p&gt;
&lt;p&gt;.NET在C# 8的帮助下支持现代语言结构，如面向对象和模块化编程、泛型、集合、lambdas、语言集成查询(LINQ)和异步编程，这使开发人员更加高效。在这里了解更多关于C#7和C#8特性的信息，&lt;/p&gt;
&lt;p&gt;Visual Studio 2019和Visual Studio Code是世界上最先进和最现代的集成开发环境。这两个IDES都支持当今的现代需求，并且专注于干净、速度和生产力。在这里了解有关VisualStudio 2019功能的更多信息：&lt;a href=&quot;https://www.c-sharpcorner.com/article/visual-studio-2019-new-features/&quot;&gt;VisualStudio 2019新特性&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;net-core是快速的&quot;&gt;&lt;strong&gt;.NET Core是快速的&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;.NET Core 3.0 是快速的。与.NET Framework和.NET Core 2.2及以前的版本相比，.NET Core 3.0的速度很快。.NET Core比其他服务器端框架(如Java Servlet和Node.js)快得多。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201905/1377250-20190517134335479-917161804.jpg&quot; alt=&quot;What Is .NET Core&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据TechEmpowers发布的一份报告，.NET Core比任何其他框架都要快得多。 TechEmpower基准测试通过对多个Web应用程序框架做如下比较：数据库的单表查询，多表查询，文件访问，数据更新，明文和JSON序列化等任务进行比较。&lt;/p&gt;
&lt;h3 id=&quot;net-core是轻量级的&quot;&gt;&lt;strong&gt;.NET Core是轻量级的&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;.NET Core是轻量级的。.NET Core可以包含在您的应用程序中，也可以安装在并行用户、机器范围内或服务器上。.NET Core可以部署在Docker容器中。&lt;/p&gt;
&lt;h3 id=&quot;net-core是友好的&quot;&gt;&lt;strong&gt;.NET Core是友好的&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;.NET Core通过.NET Standard与.NET Framework，Xamarin和Mono兼容。 .NET Core还支持使用各种流行的Web框架和库，如React，Angular和JavaScript。 TypeScript是.NET Core和Visual Studio生态系统的关键组件之一。&lt;/p&gt;
&lt;h2 id=&quot;我们可以使用.net-core构建哪些类型的应用程序&quot;&gt;&lt;strong&gt;我们可以使用.NET Core构建哪些类型的应用程序？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;.NET Core是一个通用的软件开发框架。它允许开发人员构建各种软件，包括Web，桌面，移动，云，游戏，物联网等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1377250/201905/1377250-20190517134334632-1574026354.jpg&quot; alt=&quot;What Is .NET Core&quot;/&gt;&lt;/p&gt;
&lt;p&gt;.NET Core更适合跨平台需求。.NET Core应用程序支持在Windows，Linux和macOS上运行。Linux和macOS上也都支持Microsoft流行的开源代码编辑器Visual Studio Code。VS Code支持代码编辑器的现代需求，包括智能提醒和调试。大多数第三方编辑器（如Sublime，Emacs和VI）都支持.NET Core。&lt;/p&gt;
&lt;h3 id=&quot;web应用&quot;&gt;&lt;strong&gt;Web应用&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;ASP.NET Core是.NET Core生态系统的核心组件。ASP.NET Core是一个用于构建网页的框架。ASP.NET Core基于MVC架构，并提供用于构建Web的通用库。&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/?view=aspnetcore-2.2&quot;&gt;开始使用ASP.NET Core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Razor是一个使用C＃和TypeScript构建动态网页的新框架。Razor是一种改变游戏规则的技术，它允许C＃开发人员用C＃构建Web应用程序。&lt;/p&gt;
&lt;h3 id=&quot;移动开发&quot;&gt;&lt;strong&gt;移动开发&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;移动开发是.NET Core的关键产品。Xamarin是一套使用C#构建跨平台移动应用程序的工具和库。Xamarin允许开发人员在共享的.NET代码库上为IOS、Android、Windows和MacOS构建本地应用程序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;桌面应用程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;.NET Core提供各种框架和工具来构建桌面应用程序。Windows窗体、WPF、UWP和Xamarin是构建桌面应用程序的四个主要框架。.NET Core还支持这些框架之间的互操作性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/winforms/&quot;&gt;Windows窗体&lt;/a&gt;是一种构建Windows桌面应用程序的技术。Windows窗体是.NET Framework的首批组件之一。&lt;/p&gt;
&lt;p&gt;WPF(Windows Presentation Foundation)是一种较新的构建Windows桌面应用程序的技术。WPF是作为.NET Framework版本的一部分发布的&lt;/p&gt;
&lt;p&gt;了解有关wpf的更多信息&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/framework/wpf/getting-started/&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/uwp/&quot;&gt;UWP&lt;/a&gt;是一种较新的技术，是在Windows 8之后发布的。如今，UWP已经成熟。UWP使用XAML作为表示层(UI)和C#作为后端编程。但是，貌似微软已经宣布了他的死亡。&lt;/p&gt;
&lt;h3 id=&quot;微服务和容器&quot;&gt;&lt;strong&gt;微服务和容器&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;微服务是一种新的设计模式，它允许开发人员构建软件服务的小模块，这些模块可以使用定义良好的契约相互通信。微服务使开发、测试和部署应用程序的独立部分更加容易。一旦部署完毕，每个微服务都可以根据需要独立地进行缩放。.NET Core支持微服务体系结构，它允许跨平台服务与.NET Core一起工作，包括使用.NET Framework、Java、Ruby或其他开发的服务。&lt;/p&gt;
&lt;p&gt;容器是今天的越野车。.NET Core的模块化、轻量级和灵活性使得将.NET Core应用程序部署到容器中变得更加容易。容器把一个应用程序的所有的配置文件和依赖关系，包含在一个单独的、小型的和独立的软件部署单元中。容器可以部署在任何平台、云、Linux和Windows上。.NET Core与Docker和Azure Kubernetes服务都很好地协作。&lt;/p&gt;
&lt;h3 id=&quot;云应用程序&quot;&gt;&lt;strong&gt;云应用程序&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;云应用程序现在越来越受欢迎。Azure支持各种云应用程序。.NET Core和C#应用程序可以通过Visual Studio 2019部署在Azure上。&lt;/p&gt;
&lt;h3 id=&quot;物联网&quot;&gt;&lt;strong&gt;物联网&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;物联网应用正在增长。.NET Core支持通过UWP框架为运行Windows 10 IoT Core的物联网设备进行物联网开发。UWP可用于构建在由Raspberry Pi，MinnowBoard MAX，DragonBoard 410c等提供支持的物联网上运行的应用程序。&lt;/p&gt;
&lt;h3 id=&quot;机器学习&quot;&gt;&lt;strong&gt;机器学习&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;机器学习是软件开发人员日益增长的领域。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dotnet.microsoft.com/apps/machinelearning-ai/ml-dotnet&quot;&gt;参考微软官方文档&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;游戏&quot;&gt;&lt;strong&gt;游戏&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Unity是最受欢迎的游戏开发框架之一。C＃和UWP用于构建移动，桌面，控制台，电视，VR，AR和Web游戏。&lt;/p&gt;
&lt;h2 id=&quot;net-core-3.0中的新增的功能有哪些&quot;&gt;&lt;strong&gt;.NET Core 3.0中的新增的功能有哪些？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;最新版本的.NET Core 3.0刚刚发布。C#8和Windows桌面是这个版本的两个主要新增部分。&lt;/p&gt;
&lt;p&gt;C＃8是C＃语言的最新版本。C＃8是.NET Core的一部分。C＃8增加了新功能，包括&lt;/p&gt;
&lt;p&gt;Windows桌面是.NET Core 3.0的新增功能，允许开发人员使用Windows窗体，WPF和UWP构建Windows桌面应用程序。&lt;/p&gt;
&lt;p&gt;以下是.NET Core 3.0中的其他功能和增强功能列表，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Windows桌面的MSIX部署&lt;/li&gt;
&lt;li&gt;MSIX是一种新的Windows应用程序包格式。它可用于将.NET Core 3.0桌面应用程序部署到Windows 10。&lt;/li&gt;
&lt;li&gt;快速内置JSON支持&lt;/li&gt;
&lt;li&gt;IEEE浮点改进&lt;/li&gt;
&lt;li&gt;.NET平台依赖内在函数&lt;/li&gt;
&lt;li&gt;依赖于框架的可执行文件支持&lt;/li&gt;
&lt;li&gt;构建副本依赖项&lt;/li&gt;
&lt;li&gt;装配卸载&lt;/li&gt;
&lt;li&gt;Windows Native Interop&lt;/li&gt;
&lt;li&gt;Linux上的TLS 1.3和OpenSSL 1.1.1&lt;/li&gt;
&lt;li&gt;改进的密码学&lt;/li&gt;
&lt;li&gt;适用于Linux的SerialPort&lt;/li&gt;
&lt;li&gt;ARM64 Linux支持&lt;/li&gt;
&lt;li&gt;GPIO支持Raspberry Pi&lt;br/&gt;参考&lt;br/&gt;&lt;em&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0&quot; class=&quot;uri&quot;&gt;https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/h2&gt;
</description>
<pubDate>Fri, 17 May 2019 05:46:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>作者：依乐祝 原文地址：https://www.cnblogs.com/yilezhu/p/10880884.html 我们都知道.NET Core是一个可以用来构建现代、可伸缩和高性能的跨平台软件应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10880884.html</dc:identifier>
</item>
</channel>
</rss>